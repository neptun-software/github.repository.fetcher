{
  "metadata": {
    "timestamp": 1736568071742,
    "page": 209,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "swaggo/swag",
      "stars": 11143,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3388671875,
          "content": "dist\ntestdata/simple*/docs\ntestdata/quotes/docs\ntestdata/quotes/quotes.so\ntestdata/delims/docs\ntestdata/delims/delims.so\nexample/basic/docs/*\nexample/celler/docs/*\ncover.out\n\n\n# Test binary, build with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n.idea\n.vscode\n\n# Etc\n.DS_Store\n\n/swag\n/swag.exe\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 0.5810546875,
          "content": "build:\n  main: cmd/swag/main.go\n  goos:\n    - linux\n    - darwin\n  goarch:\n    - amd64\n    - arm64\n    - 386\n  env:\n    - CGO_ENABLED=0\n\narchives:\n  - id: foo\n    name_template: >-\n      {{ .ProjectName }}_\n      {{- .Version }}_\n      {{- if eq .Os \"linux\"}}Linux{{ else if eq .Os \"darwin\"}}Darwin{{ else }}{{ .Os }}{{ end }}_\n      {{- if eq .Arch \"386\" }}i386{{ else if eq .Arch \"amd64\" }}x86_64{{ else }}{{ .Arch }}{{ end }}\n\nchecksum:\n  name_template: 'checksums.txt'\nsnapshot:\n  name_template: \"{{ .Tag }}-next\"\nchangelog:\n  sort: asc\n  filters:\n    exclude:\n    - '^docs:'\n    - '^test:'\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.173828125,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment include:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [gitter.im/swaggo/swag](https://gitter.im/swaggo/swag).The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [http://contributor-covenant.org/version/1/4][version]\n\n[homepage]: http://contributor-covenant.org\n[version]: http://contributor-covenant.org/version/1/4/\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.5986328125,
          "content": "# Contributing\n\nWhen contributing to this repository, please first discuss the change you wish to make via issue,\nemail, or any other method with the owners of this repository before making a change. \n\nPlease note we have a code of conduct, please follow it in all your interactions with the project.\n\n## Pull Request Process\n\n1. Fork it\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create new Pull Request\n\nPlease make an issue first if the change is likely to increase.\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.955078125,
          "content": "# Dockerfile References: https://docs.docker.com/engine/reference/builder/\n\n# Start from the latest golang base image\nFROM --platform=$BUILDPLATFORM golang:1.21-alpine as builder\n\n# Set the Current Working Directory inside the container\nWORKDIR /app\n\n# Copy go mod and sum files\nCOPY go.mod go.sum ./\n\n# Download all dependencies. Dependencies will be cached if the go.mod and go.sum files are not changed\nRUN go mod download\n\n# Copy the source from the current directory to the Working Directory inside the container\nCOPY . .\n\n# Configure go compiler target platform\nARG TARGETOS\nARG TARGETARCH\nENV GOARCH=$TARGETARCH \\\n    GOOS=$TARGETOS\n\n# Build the Go app\nRUN CGO_ENABLED=0 GOOS=linux go build -v -a -installsuffix cgo -o swag cmd/swag/main.go\n\n\n######## Start a new stage from scratch #######\nFROM --platform=$TARGETPLATFORM scratch\n\nWORKDIR /code/\n\n# Copy the Pre-built binary file from the previous stage\nCOPY --from=builder /app/swag /bin/swag\n\nENTRYPOINT [\"/bin/swag\"]\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.6259765625,
          "content": "GOCMD:=$(shell which go)\nGOLINT:=$(shell which golint)\nGOIMPORT:=$(shell which goimports)\nGOFMT:=$(shell which gofmt)\nGOBUILD:=$(GOCMD) build\nGOINSTALL:=$(GOCMD) install\nGOCLEAN:=$(GOCMD) clean\nGOTEST:=$(GOCMD) test\nGOMODTIDY:=$(GOCMD) mod tidy\nGOGET:=$(GOCMD) get\nGOLIST:=$(GOCMD) list\nGOVET:=$(GOCMD) vet\nGOPATH:=$(shell $(GOCMD) env GOPATH)\nu := $(if $(update),-u)\n\nBINARY_NAME:=swag\nPACKAGES:=$(shell $(GOLIST) github.com/swaggo/swag github.com/swaggo/swag/cmd/swag github.com/swaggo/swag/gen github.com/swaggo/swag/format)\nGOFILES:=$(shell find . -name \"*.go\" -type f)\n\nall: test build\n\n.PHONY: build\nbuild: deps\n\t$(GOBUILD) -o $(BINARY_NAME) ./cmd/swag\n\n.PHONY: install\ninstall: deps\n\t$(GOINSTALL) ./cmd/swag\n\n.PHONY: test\ntest:\n\techo \"mode: count\" > coverage.out\n\tfor PKG in $(PACKAGES); do \\\n\t\t$(GOCMD) test -v -covermode=count -coverprofile=profile.out $$PKG > tmp.out; \\\n\t\tcat tmp.out; \\\n\t\tif grep -q \"^--- FAIL\" tmp.out; then \\\n\t\t\trm tmp.out; \\\n\t\t\texit 1; \\\n\t\telif grep -q \"build failed\" tmp.out; then \\\n\t\t\trm tmp.out; \\\n\t\t\texit; \\\n\t\tfi; \\\n\t\tif [ -f profile.out ]; then \\\n\t\t\tcat profile.out | grep -v \"mode:\" >> coverage.out; \\\n\t\t\trm profile.out; \\\n\t\tfi; \\\n\tdone\n\n.PHONY: clean\nclean:\n\t$(GOCLEAN)\n\trm -f $(BINARY_NAME)\n\n.PHONY: deps\ndeps:\n\t$(GOMODTIDY)\n\n.PHONY: vet\nvet: deps\n\t$(GOVET) $(PACKAGES)\n\n.PHONY: fmt\nfmt:\n\t$(GOFMT) -s -w $(GOFILES)\n\n.PHONY: fmt-check\nfmt-check:\n\t@diff=$$($(GOFMT) -s -d $(GOFILES)); \\\n\tif [ -n \"$$diff\" ]; then \\\n\t\techo \"Please run 'make fmt' and commit the result:\"; \\\n\t\techo \"$${diff}\"; \\\n\t\texit 1; \\\n\tfi;\n\n.PHONY: view-covered\nview-covered:\n\t$(GOTEST) -coverprofile=cover.out $(TARGET)\n\t$(GOCMD) tool cover -html=cover.out\n"
        },
        {
          "name": "PULL_REQUEST_TEMPLATE.md",
          "type": "blob",
          "size": 0.1787109375,
          "content": "**Describe the PR**\ne.g. add cool parser.\n\n**Relation issue**\ne.g. https://github.com/swaggo/swag/pull/118/files\n\n**Additional context**\nAdd any other context about the problem here.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 44.744140625,
          "content": "# swag\n\nüåç *[English](README.md) ‚àô [ÁÆÄ‰Ωì‰∏≠Êñá](README_zh-CN.md) ‚àô [Portugu√™s](README_pt.md)*\n\n<img align=\"right\" width=\"180px\" src=\"https://raw.githubusercontent.com/swaggo/swag/master/assets/swaggo.png\">\n\n[![Build Status](https://github.com/swaggo/swag/actions/workflows/ci.yml/badge.svg?branch=master)](https://github.com/features/actions)\n[![Coverage Status](https://img.shields.io/codecov/c/github/swaggo/swag/master.svg)](https://codecov.io/gh/swaggo/swag)\n[![Go Report Card](https://goreportcard.com/badge/github.com/swaggo/swag)](https://goreportcard.com/report/github.com/swaggo/swag)\n[![codebeat badge](https://codebeat.co/badges/71e2f5e5-9e6b-405d-baf9-7cc8b5037330)](https://codebeat.co/projects/github-com-swaggo-swag-master)\n[![Go Doc](https://godoc.org/github.com/swaggo/swagg?status.svg)](https://godoc.org/github.com/swaggo/swag)\n[![Backers on Open Collective](https://opencollective.com/swag/backers/badge.svg)](#backers)\n[![Sponsors on Open Collective](https://opencollective.com/swag/sponsors/badge.svg)](#sponsors) [![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fswaggo%2Fswag.svg?type=shield)](https://app.fossa.io/projects/git%2Bgithub.com%2Fswaggo%2Fswag?ref=badge_shield)\n[![Release](https://img.shields.io/github/release/swaggo/swag.svg?style=flat-square)](https://github.com/swaggo/swag/releases)\n\n\nSwag converts Go annotations to Swagger Documentation 2.0. We've created a variety of plugins for popular [Go web frameworks](#supported-web-frameworks). This allows you to quickly integrate with an existing Go project (using Swagger UI).\n\n## Contents\n - [Getting started](#getting-started)\n - [Supported Web Frameworks](#supported-web-frameworks)\n - [How to use it with Gin](#how-to-use-it-with-gin)\n - [The swag formatter](#the-swag-formatter)\n - [Implementation Status](#implementation-status)\n - [Declarative Comments Format](#declarative-comments-format)\n\t- [General API Info](#general-api-info)\n\t- [API Operation](#api-operation)\n\t- [Security](#security)\n - [Examples](#examples)\n\t- [Descriptions over multiple lines](#descriptions-over-multiple-lines)\n\t- [User defined structure with an array type](#user-defined-structure-with-an-array-type)\n\t- [Function scoped struct declaration](#function-scoped-struct-declaration)\n\t- [Model composition in response](#model-composition-in-response)\n        - [Add request headers](#add-request-headers)\n\t- [Add response headers](#add-response-headers)\n\t- [Use multiple path params](#use-multiple-path-params)\n\t- [Example value of struct](#example-value-of-struct)\n\t- [SchemaExample of body](#schemaexample-of-body)\n\t- [Description of struct](#description-of-struct)\n\t- [Use swaggertype tag to supported custom type](#use-swaggertype-tag-to-supported-custom-type)\n\t- [Use global overrides to support a custom type](#use-global-overrides-to-support-a-custom-type)\n\t- [Use swaggerignore tag to exclude a field](#use-swaggerignore-tag-to-exclude-a-field)\n\t- [Add extension info to struct field](#add-extension-info-to-struct-field)\n\t- [Rename model to display](#rename-model-to-display)\n\t- [How to use security annotations](#how-to-use-security-annotations)\n\t- [Add a description for enum items](#add-a-description-for-enum-items)\n\t- [Generate only specific docs file types](#generate-only-specific-docs-file-types)\n    - [How to use Go generic types](#how-to-use-generics)\n- [About the Project](#about-the-project)\n\n## Getting started\n\n1. Add comments to your API source code, See [Declarative Comments Format](#declarative-comments-format).\n\n2. Install swag by using:\n```sh\ngo install github.com/swaggo/swag/cmd/swag@latest\n```\nTo build from source you need [Go](https://golang.org/dl/) (1.19 or newer).\n\nAlternatively you can run the docker image:\n```sh\ndocker run --rm -v $(pwd):/code ghcr.io/swaggo/swag:latest\n```\n\nOr download a pre-compiled binary from the [release page](https://github.com/swaggo/swag/releases).\n\n3. Run `swag init` in the project's root folder which contains the `main.go` file. This will parse your comments and generate the required files (`docs` folder and `docs/docs.go`).\n```sh\nswag init\n```\n\n  Make sure to import the generated `docs/docs.go` so that your specific configuration gets `init`'ed. If your General API annotations do not live in `main.go`, you can let swag know with `-g` flag.\n  ```go\n  import _ \"example-module-name/docs\"\n  ```\n  ```sh\n  swag init -g http/api.go\n  ```\n\n4. (optional) Use `swag fmt` format the SWAG comment. (Please upgrade to the latest version)\n\n  ```sh\n  swag fmt\n  ```\n\n## swag cli\n\n```sh\nswag init -h\nNAME:\n   swag init - Create docs.go\n\nUSAGE:\n   swag init [command options] [arguments...]\n\nOPTIONS:\n   --quiet, -q                            Make the logger quiet. (default: false)\n   --generalInfo value, -g value          Go file path in which 'swagger general API Info' is written (default: \"main.go\")\n   --dir value, -d value                  Directories you want to parse,comma separated and general-info file must be in the first one (default: \"./\")\n   --exclude value                        Exclude directories and files when searching, comma separated\n   --propertyStrategy value, -p value     Property Naming Strategy like snakecase,camelcase,pascalcase (default: \"camelcase\")\n   --output value, -o value               Output directory for all the generated files(swagger.json, swagger.yaml and docs.go) (default: \"./docs\")\n   --outputTypes value, --ot value        Output types of generated files (docs.go, swagger.json, swagger.yaml) like go,json,yaml (default: \"go,json,yaml\")\n   --parseVendor                          Parse go files in 'vendor' folder, disabled by default (default: false)\n   --parseDependency, --pd                Parse go files inside dependency folder, disabled by default (default: false)\n   --parseDependencyLevel, --pdl          Enhancement of '--parseDependency', parse go files inside dependency folder, 0 disabled, 1 only parse models, 2 only parse operations, 3 parse all (default: 0)\n   --markdownFiles value, --md value      Parse folder containing markdown files to use as description, disabled by default\n   --codeExampleFiles value, --cef value  Parse folder containing code example files to use for the x-codeSamples extension, disabled by default\n   --parseInternal                        Parse go files in internal packages, disabled by default (default: false)\n   --generatedTime                        Generate timestamp at the top of docs.go, disabled by default (default: false)\n   --parseDepth value                     Dependency parse depth (default: 100)\n   --requiredByDefault                    Set validation required for all fields by default (default: false)\n   --instanceName value                   This parameter can be used to name different swagger document instances. It is optional.\n   --overridesFile value                  File to read global type overrides from. (default: \".swaggo\")\n   --parseGoList                          Parse dependency via 'go list' (default: true)\n   --tags value, -t value                 A comma-separated list of tags to filter the APIs for which the documentation is generated.Special case if the tag is prefixed with the '!' character then the APIs with that tag will be excluded\n   --templateDelims value, --td value     Provide custom delimiters for Go template generation. The format is leftDelim,rightDelim. For example: \"[[,]]\"\n   --collectionFormat value, --cf value   Set default collection format (default: \"csv\")\n   --state value                          Initial state for the state machine (default: \"\"), @HostState in root file, @State in other files\n   --parseFuncBody                        Parse API info within body of functions in go files, disabled by default (default: false)\n   --help, -h                             show help (default: false)\n```\n\n```bash\nswag fmt -h\nNAME:\n   swag fmt - format swag comments\n\nUSAGE:\n   swag fmt [command options] [arguments...]\n\nOPTIONS:\n   --dir value, -d value          Directories you want to parse,comma separated and general-info file must be in the first one (default: \"./\")\n   --exclude value                Exclude directories and files when searching, comma separated\n   --generalInfo value, -g value  Go file path in which 'swagger general API Info' is written (default: \"main.go\")\n   --help, -h                     show help (default: false)\n\n```\n\n## Supported Web Frameworks\n\n- [gin](http://github.com/swaggo/gin-swagger)\n- [echo](http://github.com/swaggo/echo-swagger)\n- [buffalo](https://github.com/swaggo/buffalo-swagger)\n- [net/http](https://github.com/swaggo/http-swagger)\n- [gorilla/mux](https://github.com/swaggo/http-swagger)\n- [go-chi/chi](https://github.com/swaggo/http-swagger)\n- [flamingo](https://github.com/i-love-flamingo/swagger)\n- [fiber](https://github.com/gofiber/swagger)\n- [atreugo](https://github.com/Nerzal/atreugo-swagger)\n- [hertz](https://github.com/hertz-contrib/swagger)\n\n## How to use it with Gin\n\nFind the example source code [here](https://github.com/swaggo/swag/tree/master/example/celler).\n\nFinish the steps in [Getting started](#getting-started)\n1. After using `swag init` to generate Swagger 2.0 docs, import the following packages:\n```go\nimport \"github.com/swaggo/gin-swagger\" // gin-swagger middleware\nimport \"github.com/swaggo/files\" // swagger embed files\n```\n\n2. Add [General API](#general-api-info) annotations in `main.go` code:\n\n```go\n// @title           Swagger Example API\n// @version         1.0\n// @description     This is a sample server celler server.\n// @termsOfService  http://swagger.io/terms/\n\n// @contact.name   API Support\n// @contact.url    http://www.swagger.io/support\n// @contact.email  support@swagger.io\n\n// @license.name  Apache 2.0\n// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html\n\n// @host      localhost:8080\n// @BasePath  /api/v1\n\n// @securityDefinitions.basic  BasicAuth\n\n// @externalDocs.description  OpenAPI\n// @externalDocs.url          https://swagger.io/resources/open-api/\nfunc main() {\n\tr := gin.Default()\n\n\tc := controller.NewController()\n\n\tv1 := r.Group(\"/api/v1\")\n\t{\n\t\taccounts := v1.Group(\"/accounts\")\n\t\t{\n\t\t\taccounts.GET(\":id\", c.ShowAccount)\n\t\t\taccounts.GET(\"\", c.ListAccounts)\n\t\t\taccounts.POST(\"\", c.AddAccount)\n\t\t\taccounts.DELETE(\":id\", c.DeleteAccount)\n\t\t\taccounts.PATCH(\":id\", c.UpdateAccount)\n\t\t\taccounts.POST(\":id/images\", c.UploadAccountImage)\n\t\t}\n    //...\n\t}\n\tr.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n\tr.Run(\":8080\")\n}\n//...\n```\n\nAdditionally some general API info can be set dynamically. The generated code package `docs` exports `SwaggerInfo` variable which we can use to set the title, description, version, host and base path programmatically. Example using Gin:\n\n```go\npackage main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/swaggo/files\"\n\t\"github.com/swaggo/gin-swagger\"\n\n\t\"./docs\" // docs is generated by Swag CLI, you have to import it.\n)\n\n// @contact.name   API Support\n// @contact.url    http://www.swagger.io/support\n// @contact.email  support@swagger.io\n\n// @license.name  Apache 2.0\n// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html\nfunc main() {\n\n\t// programmatically set swagger info\n\tdocs.SwaggerInfo.Title = \"Swagger Example API\"\n\tdocs.SwaggerInfo.Description = \"This is a sample server Petstore server.\"\n\tdocs.SwaggerInfo.Version = \"1.0\"\n\tdocs.SwaggerInfo.Host = \"petstore.swagger.io\"\n\tdocs.SwaggerInfo.BasePath = \"/v2\"\n\tdocs.SwaggerInfo.Schemes = []string{\"http\", \"https\"}\n\n\tr := gin.New()\n\n\t// use ginSwagger middleware to serve the API docs\n\tr.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n\n\tr.Run()\n}\n```\n\n3. Add [API Operation](#api-operation) annotations in `controller` code\n\n``` go\npackage controller\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"strconv\"\n\n    \"github.com/gin-gonic/gin\"\n    \"github.com/swaggo/swag/example/celler/httputil\"\n    \"github.com/swaggo/swag/example/celler/model\"\n)\n\n// ShowAccount godoc\n// @Summary      Show an account\n// @Description  get string by ID\n// @Tags         accounts\n// @Accept       json\n// @Produce      json\n// @Param        id   path      int  true  \"Account ID\"\n// @Success      200  {object}  model.Account\n// @Failure      400  {object}  httputil.HTTPError\n// @Failure      404  {object}  httputil.HTTPError\n// @Failure      500  {object}  httputil.HTTPError\n// @Router       /accounts/{id} [get]\nfunc (c *Controller) ShowAccount(ctx *gin.Context) {\n  id := ctx.Param(\"id\")\n  aid, err := strconv.Atoi(id)\n  if err != nil {\n    httputil.NewError(ctx, http.StatusBadRequest, err)\n    return\n  }\n  account, err := model.AccountOne(aid)\n  if err != nil {\n    httputil.NewError(ctx, http.StatusNotFound, err)\n    return\n  }\n  ctx.JSON(http.StatusOK, account)\n}\n\n// ListAccounts godoc\n// @Summary      List accounts\n// @Description  get accounts\n// @Tags         accounts\n// @Accept       json\n// @Produce      json\n// @Param        q    query     string  false  \"name search by q\"  Format(email)\n// @Success      200  {array}   model.Account\n// @Failure      400  {object}  httputil.HTTPError\n// @Failure      404  {object}  httputil.HTTPError\n// @Failure      500  {object}  httputil.HTTPError\n// @Router       /accounts [get]\nfunc (c *Controller) ListAccounts(ctx *gin.Context) {\n  q := ctx.Request.URL.Query().Get(\"q\")\n  accounts, err := model.AccountsAll(q)\n  if err != nil {\n    httputil.NewError(ctx, http.StatusNotFound, err)\n    return\n  }\n  ctx.JSON(http.StatusOK, accounts)\n}\n//...\n```\n\n```console\nswag init\n```\n\n4. Run your app, and browse to http://localhost:8080/swagger/index.html. You will see Swagger 2.0 Api documents as shown below:\n\n![swagger_index.html](https://raw.githubusercontent.com/swaggo/swag/master/assets/swagger-image.png)\n\n## The swag formatter\n\nThe Swag Comments can be automatically formatted, just like 'go fmt'.\nFind the result of formatting [here](https://github.com/swaggo/swag/tree/master/example/celler).\n\nUsage:\n```shell\nswag fmt\n```\n\nExclude folderÔºö\n```shell\nswag fmt -d ./ --exclude ./internal\n```\n\nWhen using `swag fmt`, you need to ensure that you have a doc comment for the function to ensure correct formatting.\nThis is due to `swag fmt` indenting swag comments with tabs, which is only allowed *after* a standard doc comment.\n\nFor example, use\n\n```go\n// ListAccounts lists all existing accounts\n//\n//  @Summary      List accounts\n//  @Description  get accounts\n//  @Tags         accounts\n//  @Accept       json\n//  @Produce      json\n//  @Param        q    query     string  false  \"name search by q\"  Format(email)\n//  @Success      200  {array}   model.Account\n//  @Failure      400  {object}  httputil.HTTPError\n//  @Failure      404  {object}  httputil.HTTPError\n//  @Failure      500  {object}  httputil.HTTPError\n//  @Router       /accounts [get]\nfunc (c *Controller) ListAccounts(ctx *gin.Context) {\n```\n\n## Implementation Status\n\n[Swagger 2.0 document](https://swagger.io/docs/specification/2-0/basic-structure/)\n\n- [x] Basic Structure\n- [x] API Host and Base Path\n- [x] Paths and Operations\n- [x] Describing Parameters\n- [x] Describing Request Body\n- [x] Describing Responses\n- [x] MIME Types\n- [x] Authentication\n  - [x] Basic Authentication\n  - [x] API Keys\n- [x] Adding Examples\n- [x] File Upload\n- [x] Enums\n- [x] Grouping Operations With Tags\n- [ ] Swagger Extensions\n\n# Declarative Comments Format\n\n## General API Info\n\n**Example**\n[celler/main.go](https://github.com/swaggo/swag/blob/master/example/celler/main.go)\n\n| annotation  | description                                | example                         |\n|-------------|--------------------------------------------|---------------------------------|\n| title       | **Required.** The title of the application.| // @title Swagger Example API   |\n| version     | **Required.** Provides the version of the application API.| // @version 1.0  |\n| description | A short description of the application.    |// @description This is a sample server celler server.         \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t |\n| tag.name    | Name of a tag.| // @tag.name This is the name of the tag                     |\n| tag.description   | Description of the tag  | // @tag.description Cool Description         |\n| tag.docs.url      | Url of the external Documentation of the tag | // @tag.docs.url https://example.com|\n| tag.docs.description  | Description of the external Documentation of the tag| // @tag.docs.description Best example documentation |\n| termsOfService | The Terms of Service for the API.| // @termsOfService http://swagger.io/terms/                     |\n| contact.name | The contact information for the exposed API.| // @contact.name API Support  |\n| contact.url  | The URL pointing to the contact information. MUST be in the format of a URL.  | // @contact.url http://www.swagger.io/support|\n| contact.email| The email address of the contact person/organization. MUST be in the format of an email address.| // @contact.email support@swagger.io                                   |\n| license.name | **Required.** The license name used for the API.|// @license.name Apache 2.0|\n| license.url  | A URL to the license used for the API. MUST be in the format of a URL.                       | // @license.url http://www.apache.org/licenses/LICENSE-2.0.html |\n| host        | The host (name or ip) serving the API.     | // @host localhost:8080         |\n| BasePath    | The base path on which the API is served. | // @BasePath /api/v1             |\n| accept      | A list of MIME types the APIs can consume. Note that Accept only affects operations with a request body, such as POST, PUT and PATCH.  Value MUST be as described under [Mime Types](#mime-types).                     | // @accept json |\n| produce     | A list of MIME types the APIs can produce. Value MUST be as described under [Mime Types](#mime-types).                     | // @produce json |\n| query.collection.format | The default collection(array) param format in query,enums:csv,multi,pipes,tsv,ssv. If not set, csv is the default.| // @query.collection.format multi\n| schemes     | The transfer protocol for the operation that separated by spaces. | // @schemes http https |\n| externalDocs.description | Description of the external document. | // @externalDocs.description OpenAPI |\n| externalDocs.url         | URL of the external document. | // @externalDocs.url https://swagger.io/resources/open-api/ |\n| x-name      | The extension key, must be start by x- and take only json value | // @x-example-key {\"key\": \"value\"} |\n\n### Using markdown descriptions\nWhen a short string in your documentation is insufficient, or you need images, code examples and things like that you may want to use markdown descriptions. In order to use markdown descriptions use the following annotations.\n\n\n| annotation  | description                                | example                         |\n|-------------|--------------------------------------------|---------------------------------|\n| title       | **Required.** The title of the application.| // @title Swagger Example API   |\n| version     | **Required.** Provides the version of the application API.| // @version 1.0  |\n| description.markdown  | A short description of the application. Parsed from the api.md file. This is an alternative to @description    |// @description.markdown No value needed, this parses the description from api.md         \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t |\n| tag.name    | Name of a tag.| // @tag.name This is the name of the tag                     |\n| tag.description.markdown   | Description of the tag this is an alternative to tag.description. The description will be read from a file named like tagname.md  | // @tag.description.markdown         |\n| tag.x-name  | The extension key, must be start by x- and take only string value | // @x-example-key value |\n\n\n## API Operation\n\n**Example**\n[celler/controller](https://github.com/swaggo/swag/tree/master/example/celler/controller)\n\n\n| annotation           | description                                                                                                                                                                                       |\n|----------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| description          | A verbose explanation of the operation behavior.                                                                                                                                                  |\n| description.markdown | A short description of the application. The description will be read from a file.  E.g. `@description.markdown details` will load `details.md`                                                    | // @description.file endpoint.description.markdown  |\n| id                   | A unique string used to identify the operation. Must be unique among all API operations.                                                                                                          |\n| tags                 | A list of tags to each API operation that separated by commas.                                                                                                                                    |\n| summary              | A short summary of what the operation does.                                                                                                                                                       |\n| accept               | A list of MIME types the APIs can consume. Note that Accept only affects operations with a request body, such as POST, PUT and PATCH.  Value MUST be as described under [Mime Types](#mime-types). |\n| produce              | A list of MIME types the APIs can produce. Value MUST be as described under [Mime Types](#mime-types).                                                                                            |\n| param                | Parameters that separated by spaces. `param name`,`param type`,`data type`,`is mandatory?`,`comment` `attribute(optional)`                                                                        |\n| security             | [Security](#security) to each API operation.                                                                                                                                                      |\n| success              | Success response that separated by spaces. `return code or default`,`{param type}`,`data type`,`comment`                                                                                          |\n| failure              | Failure response that separated by spaces. `return code or default`,`{param type}`,`data type`,`comment`                                                                                          |\n| response             | As same as `success` and `failure`                                                                                                                                                                |\n| header               | Header in response that separated by spaces. `return code`,`{param type}`,`data type`,`comment`                                                                                                   |\n| router               | Path definition that separated by spaces. `path`,`[httpMethod]`                                                                                                                                   |\n| deprecatedrouter     | As same as router, but deprecated.                                                                                                                                                     |\n| x-name               | The extension key, must be start by x- and take only json value.                                                                                                                                  |\n| x-codeSample         | Optional Markdown usage. take `file` as parameter. This will then search for a file named like the summary in the given folder.                                                                   |\n| deprecated           | Mark endpoint as deprecated.                                                                                                                                                                      |\n\n\n\n## Mime Types\n\n`swag` accepts all MIME Types which are in the correct format, that is, match `*/*`.\nBesides that, `swag` also accepts aliases for some MIME Types as follows:\n\n| Alias                 | MIME Type                         |\n|-----------------------|-----------------------------------|\n| json                  | application/json                  |\n| xml                   | text/xml                          |\n| plain                 | text/plain                        |\n| html                  | text/html                         |\n| mpfd                  | multipart/form-data               |\n| x-www-form-urlencoded | application/x-www-form-urlencoded |\n| json-api              | application/vnd.api+json          |\n| json-stream           | application/x-json-stream         |\n| octet-stream          | application/octet-stream          |\n| png                   | image/png                         |\n| jpeg                  | image/jpeg                        |\n| gif                   | image/gif                         |\n\n\n\n## Param Type\n\n- query\n- path\n- header\n- body\n- formData\n\n## Data Type\n\n- string (string)\n- integer (int, uint, uint32, uint64)\n- number (float32)\n- boolean (bool)\n- file (param data type when uploading)\n- user defined struct\n\n## Security\n| annotation | description | parameters | example |\n|------------|-------------|------------|---------|\n| securitydefinitions.basic  | [Basic](https://swagger.io/docs/specification/2-0/authentication/basic-authentication/) auth.  |                                   | // @securityDefinitions.basic BasicAuth                      |\n| securitydefinitions.apikey | [API key](https://swagger.io/docs/specification/2-0/authentication/api-keys/) auth.            | in, name, description                          | // @securityDefinitions.apikey ApiKeyAuth                    |\n| securitydefinitions.oauth2.application  | [OAuth2 application](https://swagger.io/docs/specification/authentication/oauth2/) auth.       | tokenUrl, scope, description                   | // @securitydefinitions.oauth2.application OAuth2Application |\n| securitydefinitions.oauth2.implicit     | [OAuth2 implicit](https://swagger.io/docs/specification/authentication/oauth2/) auth.          | authorizationUrl, scope, description           | // @securitydefinitions.oauth2.implicit OAuth2Implicit       |\n| securitydefinitions.oauth2.password     | [OAuth2 password](https://swagger.io/docs/specification/authentication/oauth2/) auth.          | tokenUrl, scope, description                   | // @securitydefinitions.oauth2.password OAuth2Password       |\n| securitydefinitions.oauth2.accessCode   | [OAuth2 access code](https://swagger.io/docs/specification/authentication/oauth2/) auth.       | tokenUrl, authorizationUrl, scope, description | // @securitydefinitions.oauth2.accessCode OAuth2AccessCode   |\n\n\n| parameters annotation           | example                                                                 |\n|---------------------------------|-------------------------------------------------------------------------|\n| in                              | // @in header                                                           |\n| name                            | // @name Authorization                                                  |\n| tokenUrl                        | // @tokenUrl https://example.com/oauth/token                            |\n| authorizationurl                | // @authorizationurl https://example.com/oauth/authorize                |\n| scope.hoge                      | // @scope.write Grants write access                                     |\n| description                     | // @description OAuth protects our entity endpoints                     |\n\n## Attribute\n\n```go\n// @Param   enumstring  query     string     false  \"string enums\"       Enums(A, B, C)\n// @Param   enumint     query     int        false  \"int enums\"          Enums(1, 2, 3)\n// @Param   enumnumber  query     number     false  \"int enums\"          Enums(1.1, 1.2, 1.3)\n// @Param   string      query     string     false  \"string valid\"       minlength(5)  maxlength(10)\n// @Param   int         query     int        false  \"int valid\"          minimum(1)    maximum(10)\n// @Param   default     query     string     false  \"string default\"     default(A)\n// @Param   example     query     string     false  \"string example\"     example(string)\n// @Param   collection  query     []string   false  \"string collection\"  collectionFormat(multi)\n// @Param   extensions  query     []string   false  \"string collection\"  extensions(x-example=test,x-nullable)\n```\n\nIt also works for the struct fields:\n\n```go\ntype Foo struct {\n    Bar string `minLength:\"4\" maxLength:\"16\" example:\"random string\"`\n    Baz int `minimum:\"10\" maximum:\"20\" default:\"15\"`\n    Qux []string `enums:\"foo,bar,baz\"`\n}\n```\n\n### Available\n\nField Name | Type | Description\n---|:---:|---\n<a name=\"validate\"></a>validate | `string` | \tDetermines the validation for the parameter. Possible values are: `required,optional`.\n<a name=\"parameterDefault\"></a>default | * | Declares the value of the parameter that the server will use if none is provided, for example a \"count\" to control the number of results per page might default to 100 if not supplied by the client in the request. (Note: \"default\" has no meaning for required parameters.)  See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2. Unlike JSON Schema this value MUST conform to the defined [`type`](#parameterType) for this parameter.\n<a name=\"parameterMaximum\"></a>maximum | `number` | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.2.\n<a name=\"parameterMinimum\"></a>minimum | `number` | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.3.\n<a name=\"parameterMultipleOf\"></a>multipleOf | `number` | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.1.\n<a name=\"parameterMaxLength\"></a>maxLength | `integer` | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.1.\n<a name=\"parameterMinLength\"></a>minLength | `integer` | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.2.\n<a name=\"parameterEnums\"></a>enums | [\\*] | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1.\n<a name=\"parameterFormat\"></a>format | `string` | The extending format for the previously mentioned [`type`](#parameterType). See [Data Type Formats](https://swagger.io/specification/v2/#dataTypeFormat) for further details.\n<a name=\"parameterCollectionFormat\"></a>collectionFormat | `string` |Determines the format of the array if type array is used. Possible values are: <ul><li>`csv` - comma separated values `foo,bar`. <li>`ssv` - space separated values `foo bar`. <li>`tsv` - tab separated values `foo\\tbar`. <li>`pipes` - pipe separated values <code>foo&#124;bar</code>. <li>`multi` - corresponds to multiple parameter instances instead of multiple values for a single instance `foo=bar&foo=baz`. This is valid only for parameters [`in`](#parameterIn) \"query\" or \"formData\". </ul> Default value is `csv`.\n<a name=\"parameterExample\"></a>example | * | Declares the example for the parameter value\n<a name=\"parameterExtensions\"></a>extensions | `string` | Add extension to parameters.\n\n### Future\n\nField Name | Type | Description\n---|:---:|---\n<a name=\"parameterPattern\"></a>pattern | `string` | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.3.\n<a name=\"parameterMaxItems\"></a>maxItems | `integer` | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.2.\n<a name=\"parameterMinItems\"></a>minItems | `integer` | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.3.\n<a name=\"parameterUniqueItems\"></a>uniqueItems | `boolean` | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.4.\n\n## Examples\n\n### Descriptions over multiple lines\n\nYou can add descriptions spanning multiple lines in either the general api description or routes definitions like so:\n\n```go\n// @description This is the first line\n// @description This is the second line\n// @description And so forth.\n```\n\n### User defined structure with an array type\n\n```go\n// @Success 200 {array} model.Account <-- This is a user defined struct.\n```\n\n```go\npackage model\n\ntype Account struct {\n    ID   int    `json:\"id\" example:\"1\"`\n    Name string `json:\"name\" example:\"account name\"`\n}\n```\n\n\n### Function scoped struct declaration\n\nYou can declare your request response structs inside a function body.\nYou must have to follow the naming convention `<package-name>.<function-name>.<struct-name> `.\n\n```go\npackage main\n\n// @Param request body main.MyHandler.request true \"query params\"\n// @Success 200 {object} main.MyHandler.response\n// @Router /test [post]\nfunc MyHandler() {\n\ttype request struct {\n\t\tRequestField string\n\t}\n\n\ttype response struct {\n\t\tResponseField string\n\t}\n}\n```\n\n\n### Model composition in response\n```go\n// JSONResult's data field will be overridden by the specific type proto.Order\n@success 200 {object} jsonresult.JSONResult{data=proto.Order} \"desc\"\n```\n\n```go\ntype JSONResult struct {\n    Code    int          `json:\"code\" `\n    Message string       `json:\"message\"`\n    Data    interface{}  `json:\"data\"`\n}\n\ntype Order struct { //in `proto` package\n    Id  uint            `json:\"id\"`\n    Data  interface{}   `json:\"data\"`\n}\n```\n\n- also support array of objects and primitive types as nested response\n```go\n@success 200 {object} jsonresult.JSONResult{data=[]proto.Order} \"desc\"\n@success 200 {object} jsonresult.JSONResult{data=string} \"desc\"\n@success 200 {object} jsonresult.JSONResult{data=[]string} \"desc\"\n```\n\n- overriding multiple fields. field will be added if not exists\n```go\n@success 200 {object} jsonresult.JSONResult{data1=string,data2=[]string,data3=proto.Order,data4=[]proto.Order} \"desc\"\n```\n- overriding deep-level fields\n```go\ntype DeepObject struct { //in `proto` package\n\t...\n}\n@success 200 {object} jsonresult.JSONResult{data1=proto.Order{data=proto.DeepObject},data2=[]proto.Order{data=[]proto.DeepObject}} \"desc\"\n```\n### Add request headers\n\n```go\n// @Param        X-MyHeader\t  header    string    true   \t\"MyHeader must be set for valid response\"\n// @Param        X-API-VERSION    header    string    true   \t\"API version eg.: 1.0\"\n```\n\n### Add response headers\n\n```go\n// @Success      200              {string}  string    \"ok\"\n// @failure      400              {string}  string    \"error\"\n// @response     default          {string}  string    \"other error\"\n// @Header       200              {string}  Location  \"/entity/1\"\n// @Header       200,400,default  {string}  Token     \"token\"\n// @Header       all              {string}  Token2    \"token2\"\n```\n\n### Use multiple path params\n\n```go\n/// ...\n// @Param group_id   path int true \"Group ID\"\n// @Param account_id path int true \"Account ID\"\n// ...\n// @Router /examples/groups/{group_id}/accounts/{account_id} [get]\n```\n\n### Add multiple paths\n\n```go\n/// ...\n// @Param group_id path int true \"Group ID\"\n// @Param user_id  path int true \"User ID\"\n// ...\n// @Router /examples/groups/{group_id}/user/{user_id}/address [put]\n// @Router /examples/user/{user_id}/address [put]\n```\n\n### Example value of struct\n\n```go\ntype Account struct {\n    ID   int    `json:\"id\" example:\"1\"`\n    Name string `json:\"name\" example:\"account name\"`\n    PhotoUrls []string `json:\"photo_urls\" example:\"http://test/image/1.jpg,http://test/image/2.jpg\"`\n}\n```\n\n### SchemaExample of body\n\n```go\n// @Param email body string true \"message/rfc822\" SchemaExample(Subject: Testmail\\r\\n\\r\\nBody Message\\r\\n)\n```\n\n### Description of struct\n\n```go\n// Account model info\n// @Description User account information\n// @Description with user id and username\ntype Account struct {\n\t// ID this is userid\n\tID   int    `json:\"id\"`\n\tName string `json:\"name\"` // This is Name\n}\n```\n\n[#708](https://github.com/swaggo/swag/issues/708) The parser handles only struct comments starting with `@Description` attribute.\nBut it writes all struct field comments as is.\n\nSo, generated swagger doc as follows:\n```json\n\"Account\": {\n  \"type\":\"object\",\n  \"description\": \"User account information with user id and username\"\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\",\n      \"description\": \"ID this is userid\"\n    },\n    \"name\": {\n      \"type\":\"string\",\n      \"description\": \"This is Name\"\n    }\n  }\n}\n```\n\n### Use swaggertype tag to supported custom type\n[#201](https://github.com/swaggo/swag/issues/201#issuecomment-475479409)\n\n```go\ntype TimestampTime struct {\n    time.Time\n}\n\n///implement encoding.JSON.Marshaler interface\nfunc (t *TimestampTime) MarshalJSON() ([]byte, error) {\n    bin := make([]byte, 16)\n    bin = strconv.AppendInt(bin[:0], t.Time.Unix(), 10)\n    return bin, nil\n}\n\nfunc (t *TimestampTime) UnmarshalJSON(bin []byte) error {\n    v, err := strconv.ParseInt(string(bin), 10, 64)\n    if err != nil {\n        return err\n    }\n    t.Time = time.Unix(v, 0)\n    return nil\n}\n///\n\ntype Account struct {\n    // Override primitive type by simply specifying it via `swaggertype` tag\n    ID     sql.NullInt64 `json:\"id\" swaggertype:\"integer\"`\n\n    // Override struct type to a primitive type 'integer' by specifying it via `swaggertype` tag\n    RegisterTime TimestampTime `json:\"register_time\" swaggertype:\"primitive,integer\"`\n\n    // Array types can be overridden using \"array,<prim_type>\" format\n    Coeffs []big.Float `json:\"coeffs\" swaggertype:\"array,number\"`\n}\n```\n\n[#379](https://github.com/swaggo/swag/issues/379)\n```go\ntype CerticateKeyPair struct {\n\tCrt []byte `json:\"crt\" swaggertype:\"string\" format:\"base64\" example:\"U3dhZ2dlciByb2Nrcw==\"`\n\tKey []byte `json:\"key\" swaggertype:\"string\" format:\"base64\" example:\"U3dhZ2dlciByb2Nrcw==\"`\n}\n```\ngenerated swagger doc as follows:\n```go\n\"api.MyBinding\": {\n  \"type\":\"object\",\n  \"properties\":{\n    \"crt\":{\n      \"type\":\"string\",\n      \"format\":\"base64\",\n      \"example\":\"U3dhZ2dlciByb2Nrcw==\"\n    },\n    \"key\":{\n      \"type\":\"string\",\n      \"format\":\"base64\",\n      \"example\":\"U3dhZ2dlciByb2Nrcw==\"\n    }\n  }\n}\n\n```\n\n### Use global overrides to support a custom type\n\nIf you are using generated files, the [`swaggertype`](#use-swaggertype-tag-to-supported-custom-type) or `swaggerignore` tags may not be possible.\n\nBy passing a mapping to swag with `--overridesFile` you can tell swag to use one type in place of another wherever it appears. By default, if a `.swaggo` file is present in the current directory it will be used.\n\nGo code:\n```go\ntype MyStruct struct {\n  ID     sql.NullInt64 `json:\"id\"`\n  Name   sql.NullString `json:\"name\"`\n}\n```\n\n`.swaggo`:\n```\n// Replace all NullInt64 with int\nreplace database/sql.NullInt64 int\n\n// Don't include any fields of type database/sql.NullString in the swagger docs\nskip    database/sql.NullString\n```\n\nPossible directives are comments (beginning with `//`), `replace path/to/a.type path/to/b.type`, and `skip path/to/a.type`.\n\n(Note that the full paths to any named types must be provided to prevent problems when multiple packages define a type with the same name)\n\nRendered:\n```go\n\"types.MyStruct\": {\n  \"id\": \"integer\"\n}\n```\n\n\n### Use swaggerignore tag to exclude a field\n\n```go\ntype Account struct {\n    ID   string    `json:\"id\"`\n    Name string     `json:\"name\"`\n    Ignored int     `swaggerignore:\"true\"`\n}\n```\n\n### Add extension info to struct field\n\n```go\ntype Account struct {\n    ID   string    `json:\"id\"   extensions:\"x-nullable,x-abc=def,!x-omitempty\"` // extensions fields must start with \"x-\"\n}\n```\n\ngenerate swagger doc as follows:\n\n```go\n\"Account\": {\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"x-nullable\": true,\n            \"x-abc\": \"def\",\n            \"x-omitempty\": false\n        }\n    }\n}\n```\n### Rename model to display\n\n```golang\ntype Resp struct {\n\tCode int\n}//@name Response\n```\n\n### How to use security annotations\n\nGeneral API info.\n\n```go\n// @securityDefinitions.basic BasicAuth\n\n// @securitydefinitions.oauth2.application OAuth2Application\n// @tokenUrl https://example.com/oauth/token\n// @scope.write Grants write access\n// @scope.admin Grants read and write access to administrative information\n```\n\nEach API operation.\n\n```go\n// @Security ApiKeyAuth\n```\n\nMake it OR condition\n\n```go\n// @Security ApiKeyAuth\n// @Security OAuth2Application[write, admin]\n```\n\nMake it AND condition\n\n```go\n// @Security ApiKeyAuth && firebase\n// @Security OAuth2Application[write, admin] && APIKeyAuth\n```\n\n\n### Add a description for enum items\n\n```go\ntype Example struct {\n\t// Sort order:\n\t// * asc - Ascending, from A to Z.\n\t// * desc - Descending, from Z to A.\n\tOrder string `enums:\"asc,desc\"`\n}\n```\n\n### Generate only specific docs file types\n\nBy default `swag` command generates Swagger specification in three different files/file types:\n- docs.go\n- swagger.json\n- swagger.yaml\n\nIf you would like to limit a set of file types which should be generated you can use `--outputTypes` (short `-ot`) flag. Default value is `go,json,yaml` - output types separated with comma. To limit output only to `go` and `yaml` files, you would write `go,yaml`. With complete command that would be `swag init --outputTypes go,yaml`.\n\n### How to use Generics\n\n```go\n// @Success 200 {object} web.GenericNestedResponse[types.Post]\n// @Success 204 {object} web.GenericNestedResponse[types.Post, Types.AnotherOne]\n// @Success 201 {object} web.GenericNestedResponse[web.GenericInnerType[types.Post]]\nfunc GetPosts(w http.ResponseWriter, r *http.Request) {\n\t_ = web.GenericNestedResponse[types.Post]{}\n}\n```\nSee [this file](https://github.com/swaggo/swag/blob/master/testdata/generics_nested/api/api.go) for more details\nand other examples.\n\n### Change the default Go Template action delimiters\n[#980](https://github.com/swaggo/swag/issues/980)\n[#1177](https://github.com/swaggo/swag/issues/1177)\n\nIf your swagger annotations or struct fields contain \"{{\" or \"}}\", the template generation will most likely fail, as these are the default delimiters for [go templates](https://pkg.go.dev/text/template#Template.Delims).\n\nTo make the generation work properly, you can change the default delimiters with `-td`. For example:\n```console\nswag init -g http/api.go -td \"[[,]]\"\n```\nThe new delimiter is a string with the format \"`<left delimiter>`,`<right delimiter>`\".\n\n### Parse Internal and Dependency Packages\n\nIf the struct is defined in a dependency package, use `--parseDependency`.\n\nIf the struct is defined in your main project, use `--parseInternal`.\n\nif you want to include both internal and from dependencies use both flags \n```\nswag init --parseDependency --parseInternal\n```\n\n## About the Project\nThis project was inspired by [yvasiyarov/swagger](https://github.com/yvasiyarov/swagger) but we simplified the usage and added support a variety of [web frameworks](#supported-web-frameworks). Gopher image source is [tenntenn/gopher-stickers](https://github.com/tenntenn/gopher-stickers). It has licenses [creative commons licensing](http://creativecommons.org/licenses/by/3.0/deed.en).\n## Contributors\n\nThis project exists thanks to all the people who contribute. [[Contribute](CONTRIBUTING.md)].\n<a href=\"https://github.com/swaggo/swag/graphs/contributors\"><img src=\"https://opencollective.com/swag/contributors.svg?width=890&button=false\" /></a>\n\n\n## Backers\n\nThank you to all our backers! üôè [[Become a backer](https://opencollective.com/swag#backer)]\n\n<a href=\"https://opencollective.com/swag#backers\" target=\"_blank\"><img src=\"https://opencollective.com/swag/backers.svg?width=890\"></a>\n\n\n## Sponsors\n\nSupport this project by becoming a sponsor. Your logo will show up here with a link to your website. [[Become a sponsor](https://opencollective.com/swag#sponsor)]\n\n<a href=\"https://opencollective.com/swag/sponsor/0/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/0/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/1/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/1/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/2/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/2/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/3/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/3/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/4/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/4/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/5/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/5/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/6/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/6/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/7/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/7/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/8/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/8/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/9/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/9/avatar.svg\"></a>\n\n\n\n\n## License\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fswaggo%2Fswag.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fswaggo%2Fswag?ref=badge_large)\n"
        },
        {
          "name": "README_pt.md",
          "type": "blob",
          "size": 41.1826171875,
          "content": "# swag\n\nüåç *[English](README.md) ‚àô [ÁÆÄ‰Ωì‰∏≠Êñá](README_zh-CN.md) ‚àô [Portugu√™s](README_pt.md)*\n\n<img align=\"right\" width=\"180px\" src=\"https://raw.githubusercontent.com/swaggo/swag/master/assets/swaggo.png\">\n\n[![Build Status](https://github.com/swaggo/swag/actions/workflows/ci.yml/badge.svg?branch=master)](https://github.com/features/actions)\n[![Coverage Status](https://img.shields.io/codecov/c/github/swaggo/swag/master.svg)](https://codecov.io/gh/swaggo/swag)\n[![Go Report Card](https://goreportcard.com/badge/github.com/swaggo/swag)](https://goreportcard.com/report/github.com/swaggo/swag)\n[![codebeat badge](https://codebeat.co/badges/71e2f5e5-9e6b-405d-baf9-7cc8b5037330)](https://codebeat.co/projects/github-com-swaggo-swag-master)\n[![Go Doc](https://godoc.org/github.com/swaggo/swagg?status.svg)](https://godoc.org/github.com/swaggo/swag)\n[![Backers on Open Collective](https://opencollective.com/swag/backers/badge.svg)](#backers)\n[![Sponsors on Open Collective](https://opencollective.com/swag/sponsors/badge.svg)](#sponsors) [![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fswaggo%2Fswag.svg?type=shield)](https://app.fossa.io/projects/git%2Bgithub.com%2Fswaggo%2Fswag?ref=badge_shield)\n[![Release](https://img.shields.io/github/release/swaggo/swag.svg?style=flat-square)](https://github.com/swaggo/swag/releases)\n\nSwag converte anota√ß√µes Go para Documenta√ß√£o Swagger 2.0. Cri√°mos uma variedade de plugins para populares [Go web frameworks](#supported-web-frameworks). Isto permite uma integra√ß√£o r√°pida com um projecto Go existente (utilizando a Swagger UI).\n\n## Conte√∫do\n- [Come√ßando](#come√ßando)\n - [Estruturas Web Suportadas](#estruturas-web-suportadas)\n - [Como utiliz√°-lo com Gin](#como-como-ser-como-gin)\n - [O formatador de swag](#a-formata√ß√£o-de-swag)\n - [Estado de Implementa√ß√£o](#implementa√ß√£o-estado)\n - [Formato dos coment√°rios declarativos](#formato-dos-comentarios-declarativos)\n\t- [Informa√ß√µes Gerais API](#informa√ß√µes-gerais-api)\n\t- [Opera√ß√£o API](#api-operacao)\n\t- [Seguran√ßa](#seguranca)\n - [Exemplos](#exemplos)\n    - [Descri√ß√µes em m√∫ltiplas linhas](#descricoes-sobre-m√∫ltiplas-linhas)\n\t- [Estrutura definida pelo utilizador com um tipo de matriz](#-estrutura-definida-pelo-utilizador-com-um-um-tipo)\n\t- [Declara√ß√£o de estrutura√ß√£o de fun√ß√µes](#function-scoped-struct-declaration)\n\t- [Composi√ß√£o do modelo em resposta](#model-composi√ß√£o-em-resposta)\n\t- [Adicionar um cabe√ßalho em resposta](#add-a-headers-in-response)\n\t- [Utilizar par√¢metros de caminhos m√∫ltiplos](#use-multiple-path-params)\n\t- [Exemplo de valor de estrutura](#exemplo-do-valor-de-estrutura)\n\t- [Schema Exemplo do corpo](#schemaexample-of-body)\n\t- [Descri√ß√£o da estrutura](#descri√ß√£o-da-estrutura)\n\t- [Usar etiqueta do tipo swaggertype para suportar o tipo personalizado](#use-swaggertype-tag-to-supported-custom-type)\n\t- [Utilizar anula√ß√µes globais para suportar um tipo personalizado](#use-global-overrides-to-support-a-custom-type)\n\t- [Use swaggerignore tag para excluir um campo](#use-swaggerignore-tag-to-excluir-um-campo)\n\t- [Adicionar informa√ß√µes de extens√£o ao campo de estrutura√ß√£o](#add-extension-info-to-struct-field)\n\t- [Renomear modelo a expor](#renome-modelo-a-exibir)\n\t- [Como utilizar as anota√ß√µes de seguran√ßa](#como-utilizar-as-anota√ß√µes-de-seguran√ßa)\n\t- [Adicionar uma descri√ß√£o para enumerar artigos](#add-a-description-for-enum-items)\n\t- [Gerar apenas tipos de ficheiros de documentos espec√≠ficos](#generate-only-specific-docs-file-file-types)\n    - [Como usar tipos gen√©ricos](#como-usar-tipos-gen√©ricos)\n- [Sobre o projecto](#sobre-o-projecto)\n\n## Come√ßando\n\n1. Adicione coment√°rios ao c√≥digo-fonte da API, consulte [Formato dos coment√°rios declarativos](#declarative-comments-format).\n\n2. Descarregue o swag utilizando:\n```sh\ngo install github.com/swaggo/swag/cmd/swag@latest\n```\nPara construir a partir da fonte √© necess√°rio [Go](https://golang.org/dl/) (1.19 ou mais recente).\n\nOu descarregar um bin√°rio pr√©-compilado a partir da [p√°gina de lan√ßamento](https://github.com/swaggo/swag/releases).\n\n3. Executar `swag init` na pasta raiz do projecto que cont√©m o ficheiro `main.go`. Isto ir√° analisar os seus coment√°rios e gerar os ficheiros necess√°rios (pasta `docs` e `docs/docs.go`).\n```sh\nswag init\n```\n\nCertifique-se de importar os `docs/docs.go` gerados para que a sua configura√ß√£o espec√≠fica fique \"init\" ed. Se as suas anota√ß√µes API gerais n√£o viverem em `main.go`, pode avisar a swag com a bandeira `-g`.\n```sh\nswag init -g http/api.go\n```\n\n4. (opcional) Utilizar o formato `swag fmt` no coment√°rio SWAG. (Por favor, actualizar para a vers√£o mais recente)\n\n```sh\nswag fmt\n```\n\n## swag cli\n\n```sh\nswag init -h\nNOME:\n   swag init - Criar docs.go\n\nUTILIZA√á√ÉO:\n   swag init [op√ß√µes de comando] [argumentos...]\n\nOP√á√ïES:\n   --quiet, -q Fazer o logger ficar quiet (por padr√£o: falso)\n   --generalInfo valor, -g valor Go caminho do ficheiro em que 'swagger general API Info' est√° escrito (por padr√£o: \"main.go\")\n   --dir valor, -d valor Os direct√≥rios que deseja analisar, separados por v√≠rgulas e de informa√ß√£o geral devem estar no primeiro (por padr√£o: \"./\")\n   --exclude valor Excluir direct√≥rios e ficheiros ao pesquisar, separados por v√≠rgulas\n   -propertyStrategy da estrat√©gia, -p valor da propriedadeEstrat√©gia de nomea√ß√£o de propriedades como snakecase,camelcase,pascalcase (por padr√£o: \"camelcase\")\n   --output de sa√≠da, -o valor direct√≥rio de sa√≠da para todos os ficheiros gerados(swagger.json, swagger.yaml e docs.go) (por padr√£o: \"./docs\")\n   --outputTypes valor de sa√≠daTypes, -- valor de sa√≠da Tipos de ficheiros gerados (docs.go, swagger.json, swagger.yaml) como go,json,yaml (por padr√£o: \"go,json,yaml\")\n   --parseVendor ParseVendor Parse go files na pasta 'vendor', desactivado por padr√£o (padr√£o: falso)\n   --parseInternal Parse go ficheiros em pacotes internos, desactivados por padr√£o (padr√£o: falso)\n   --generatedTime Gerar timestamp no topo dos docs.go, desactivado por padr√£o (padr√£o: falso)\n   --parteDepth value Depend√™ncia profundidade parse (por padr√£o: 100)\n   --templateDelims value, --td value fornecem delimitadores personalizados para a gera√ß√£o de modelos Go. O formato √© leftDelim,rightDelim. Por exemplo: \"[[,]]\"\n   ...\n\n   --help, -h mostrar ajuda (por padr√£o: falso)\n```\n\n```bash\nswag fmt -h\nNOME:\n   swag fmt - formato swag coment√°rios\n\nUTILIZA√á√ÉO:\n   swag fmt [op√ß√µes de comando] [argumentos...]\n\nOP√á√ïES:\n   --dir valor, -d valor Os direct√≥rios que pretende analisar, separados por v√≠rgulas e de informa√ß√£o geral devem estar no primeiro (por padr√£o: \"./\")\n   --excluir valor Excluir direct√≥rios e ficheiros ao pesquisar, separados por v√≠rgulas\n   --generalInfo value, -g value Go file path in which 'swagger general API Info' is written (por padr√£o: \"main.go\")\n   --ajuda, -h mostrar ajuda (por padr√£o: falso)\n\n```\n\n## Estruturas Web Suportadas\n\n- [gin](http://github.com/swaggo/gin-swagger)\n- [echo](http://github.com/swaggo/echo-swagger)\n- [buffalo](https://github.com/swaggo/buffalo-swagger)\n- [net/http](https://github.com/swaggo/http-swagger)\n- [gorilla/mux](https://github.com/swaggo/http-swagger)\n- [go-chi/chi](https://github.com/swaggo/http-swagger)\n- [flamingo](https://github.com/i-love-flamingo/swagger)\n- [fiber](https://github.com/gofiber/swagger)\n- [atreugo](https://github.com/Nerzal/atreugo-swagger)\n- [hertz](https://github.com/hertz-contrib/swagger)\n\n## Como utiliz√°-lo com Gin\n\nEncontrar o c√≥digo fonte de exemplo [aqui](https://github.com/swaggo/swag/tree/master/example/celler).\n\n1. Depois de utilizar `swag init` para gerar os documentos Swagger 2.0, importar os seguintes pacotes:\n```go\nimport \"github.com/swaggo/gin-swagger\" // gin-swagger middleware\nimport \"github.com/swaggo/files\" // swagger embed files\n```\n\n2. Adicionar [Informa√ß√µes Gerais API](#general-api-info) anota√ß√µes em c√≥digo `main.go`:\n\n\n```go\n// @title           Swagger Example API\n// @version         1.0\n// @description     This is a sample server celler server.\n// @termsOfService  http://swagger.io/terms/\n\n// @contact.name   API Support\n// @contact.url    http://www.swagger.io/support\n// @contact.email  support@swagger.io\n\n// @license.name  Apache 2.0\n// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html\n\n// @host      localhost:8080\n// @BasePath  /api/v1\n\n// @securityDefinitions.basic  BasicAuth\n\n// @externalDocs.description  OpenAPI\n// @externalDocs.url          https://swagger.io/resources/open-api/\nfunc main() {\n\tr := gin.Default()\n\n\tc := controller.NewController()\n\n\tv1 := r.Group(\"/api/v1\")\n\t{\n\t\taccounts := v1.Group(\"/accounts\")\n\t\t{\n\t\t\taccounts.GET(\":id\", c.ShowAccount)\n\t\t\taccounts.GET(\"\", c.ListAccounts)\n\t\t\taccounts.POST(\"\", c.AddAccount)\n\t\t\taccounts.DELETE(\":id\", c.DeleteAccount)\n\t\t\taccounts.PATCH(\":id\", c.UpdateAccount)\n\t\t\taccounts.POST(\":id/images\", c.UploadAccountImage)\n\t\t}\n    //...\n\t}\n\tr.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n\tr.Run(\":8080\")\n}\n//...\n```\n\nAl√©m disso, algumas informa√ß√µes API gerais podem ser definidas de forma din√¢mica. O pacote de c√≥digo gerado `docs` exporta a vari√°vel `SwaggerInfo` que podemos utilizar para definir programticamente o t√≠tulo, descri√ß√£o, vers√£o, hospedeiro e caminho base. Exemplo utilizando Gin:\n\n```go\npackage main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/swaggo/files\"\n\t\"github.com/swaggo/gin-swagger\"\n\n\t\"./docs\" // docs is generated by Swag CLI, you have to import it.\n)\n\n// @contact.name   API Support\n// @contact.url    http://www.swagger.io/support\n// @contact.email  support@swagger.io\n\n// @license.name  Apache 2.0\n// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html\nfunc main() {\n\n\t// programmatically set swagger info\n\tdocs.SwaggerInfo.Title = \"Swagger Example API\"\n\tdocs.SwaggerInfo.Description = \"This is a sample server Petstore server.\"\n\tdocs.SwaggerInfo.Version = \"1.0\"\n\tdocs.SwaggerInfo.Host = \"petstore.swagger.io\"\n\tdocs.SwaggerInfo.BasePath = \"/v2\"\n\tdocs.SwaggerInfo.Schemes = []string{\"http\", \"https\"}\n\n\tr := gin.New()\n\n\t// use ginSwagger middleware to serve the API docs\n\tr.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n\n\tr.Run()\n}\n```\n\n3. Adicionar [Opera√ß√£o API](#api-operacao) anota√ß√µes em c√≥digo `controller`\n\n```go\npackage controller\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"strconv\"\n\n    \"github.com/gin-gonic/gin\"\n    \"github.com/swaggo/swag/example/celler/httputil\"\n    \"github.com/swaggo/swag/example/celler/model\"\n)\n\n// ShowAccount godoc\n// @Summary      Show an account\n// @Description  get string by ID\n// @Tags         accounts\n// @Accept       json\n// @Produce      json\n// @Param        id   path      int  true  \"Account ID\"\n// @Success      200  {object}  model.Account\n// @Failure      400  {object}  httputil.HTTPError\n// @Failure      404  {object}  httputil.HTTPError\n// @Failure      500  {object}  httputil.HTTPError\n// @Router       /accounts/{id} [get]\nfunc (c *Controller) ShowAccount(ctx *gin.Context) {\n  id := ctx.Param(\"id\")\n  aid, err := strconv.Atoi(id)\n  if err != nil {\n    httputil.NewError(ctx, http.StatusBadRequest, err)\n    return\n  }\n  account, err := model.AccountOne(aid)\n  if err != nil {\n    httputil.NewError(ctx, http.StatusNotFound, err)\n    return\n  }\n  ctx.JSON(http.StatusOK, account)\n}\n\n// ListAccounts godoc\n// @Summary      List accounts\n// @Description  get accounts\n// @Tags         accounts\n// @Accept       json\n// @Produce      json\n// @Param        q    query     string  false  \"name search by q\"  Format(email)\n// @Success      200  {array}   model.Account\n// @Failure      400  {object}  httputil.HTTPError\n// @Failure      404  {object}  httputil.HTTPError\n// @Failure      500  {object}  httputil.HTTPError\n// @Router       /accounts [get]\nfunc (c *Controller) ListAccounts(ctx *gin.Context) {\n  q := ctx.Request.URL.Query().Get(\"q\")\n  accounts, err := model.AccountsAll(q)\n  if err != nil {\n    httputil.NewError(ctx, http.StatusNotFound, err)\n    return\n  }\n  ctx.JSON(http.StatusOK, accounts)\n}\n//...\n```\n\n```console\nswag init\n```\n\n4. Execute a sua aplica√ß√£o, e navegue para http://localhost:8080/swagger/index.html. Ver√° os documentos Swagger 2.0 Api, como mostrado abaixo:\n\n![swagger_index.html](https://raw.githubusercontent.com/swaggo/swag/master/assets/swagger-image.png)\n\n## O formatador de swag\n\nOs Swag Comments podem ser formatados automaticamente, assim como 'go fmt'.\nEncontre o resultado da formata√ß√£o [aqui](https://github.com/swaggo/swag/tree/master/example/celler).\n\nUsage:\n```shell\nswag fmt\n```\n\nExclude folderÔºö\n```shell\nswag fmt -d ./ --exclude ./internal\n```\n\nAo utilizar `swag fmt`, √© necess√°rio assegurar-se de que tem um coment√°rio doc para a fun√ß√£o a fim de assegurar uma formata√ß√£o correcta.\nIsto deve-se ao `swag fmt` que tra√ßa coment√°rios swag com separadores, o que s√≥ √© permitido *ap√≥s* um coment√°rio doc padr√£o.\n\nPor exemplo, utilizar\n\n```go\n// ListAccounts lists all existing accounts\n//\n//  @Summary      List accounts\n//  @Description  get accounts\n//  @Tags         accounts\n//  @Accept       json\n//  @Produce      json\n//  @Param        q    query     string  false  \"name search by q\"  Format(email)\n//  @Success      200  {array}   model.Account\n//  @Failure      400  {object}  httputil.HTTPError\n//  @Failure      404  {object}  httputil.HTTPError\n//  @Failure      500  {object}  httputil.HTTPError\n//  @Router       /accounts [get]\nfunc (c *Controller) ListAccounts(ctx *gin.Context) {\n```\n\n## Estado de Implementa√ß√£o\n\n[Documento Swagger 2.0](https://swagger.io/docs/specification/2-0/basic-structure/)\n\n- [x] Estrutura b√°sica\n- [x] Hospedeiro API e Caminho Base\n- [x] Caminhos e opera√ß√µes\n- [x] Descri√ß√£o dos par√¢metros\n- [x] Descrever o corpo do pedido\n- [x] Descri√ß√£o das respostas\n- [x] Tipos MIME\n- [x] Autentica√ß√£o\n  - [x] Autentica√ß√£o b√°sica\n  - [x] Chaves API\n- [x] Acrescentar exemplos\n- [x] Carregamento de ficheiros\n- [x] Enums\n- [x] Opera√ß√µes de Agrupamento com Etiquetas\n- Extens√µes Swagger\n\n## Formato dos coment√°rios declarativos\n\n## Informa√ß√µes Gerais API\n\n**Exemplo**\n[celler/main.go](https://github.com/swaggo/swag/blob/master/example/celler/main.go)\n\n| anota√ß√£o | descri√ß√£o | exemplo |\n|-------------|--------------------------------------------|---------------------------------|\n| title | **Obrigat√≥rio.** O t√≠tulo da aplica√ß√£o.| // @title Swagger Example API |\n| version | **Obrigat√≥rio.** Fornece a vers√£o da aplica√ß√£o API.| // @version 1.0 |\n| description | Uma breve descri√ß√£o da candidatura.    |// @descri√ß√£o Este √© um servidor servidor de celas de amostra.         \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t |\n| tag.name | Nome de uma tag.| // @tag.name Este √© o nome da tag |\n| tag.description | Descri√ß√£o da tag | // @tag.description Cool Description |\n| tag.docs.url | Url da Documenta√ß√£o externa da tag | // @tag.docs.url https://example.com|\n| tag.docs.description | Descri√ß√£o da documenta√ß√£o externa da tag| // @tag.docs.description Melhor exemplo de documenta√ß√£o |\n| TermsOfService | Os Termos de Servi√ßo para o API.| // @termsOfService http://swagger.io/terms/ |\n| contact.name | A informa√ß√£o de contacto para a API exposta.| // @contacto.name Suporte API |\n| contact.url | O URL que aponta para as informa√ß√µes de contacto. DEVE estar no formato de um URL.  | // @contact.url http://www.swagger.io/support|\n| contact.email| O endere√ßo de email da pessoa/organiza√ß√£o de contacto. DEVE estar no formato de um endere√ßo de correio electr√≥nico.| // @contact.email support@swagger.io |\n| license.name | **Obrigat√≥rio.** O nome da licen√ßa utilizada para a API.|// @licen√ßa.name Apache 2.0|\n| license.url | Um URL para a licen√ßa utilizada para a API. DEVE estar no formato de um URL.                       | // @license.url http://www.apache.org/licenses/LICENSE-2.0.html |\n| host | O anfitri√£o (nome ou ip) que serve o API.     | // @host localhost:8080 |\n| BasePath | O caminho de base sobre o qual o API √© servido. | // @BasePath /api/v1 |\n| accept | Uma lista de tipos de MIME que os APIs podem consumir. Note que accept s√≥ afecta opera√ß√µes com um organismo de pedido, tais como POST, PUT e PATCH.  O valor DEVE ser o descrito em [Tipos de Mime](#mime-types).                     | // @accept json |\n| produce | Uma lista de tipos de MIME que os APIs podem produce. O valor DEVE ser o descrito em [Tipos de Mime](#mime-types).                     | // @produce json |\n| query.collection.format | O formato padr√£o de param de colec√ß√£o(array) em query,enums:csv,multi,pipes,tsv,ssv. Se n√£o definido, csv √© o padr√£o.| // @query.collection.format multi\n| schemes | O protocolo de transfer√™ncia para a opera√ß√£o que separou por espa√ßos. | // @schemes http https |\n| externalDocs.description | Descri√ß√£o do documento externo. | // @externalDocs.description OpenAPI |\n| externalDocs.url | URL do documento externo. | // @externalDocs.url https://swagger.io/resources/open-api/ |\n| x-name | A chave de extens√£o, deve ser iniciada por x- e tomar apenas o valor json | // @x-example-key {\"chave\": \"valor\"} |\n\n### Usando descri√ß√µes de remarca√ß√£o para baixo\nQuando uma pequena sequ√™ncia na sua documenta√ß√£o √© insuficiente, ou precisa de imagens, exemplos de c√≥digos e coisas do g√©nero, pode querer usar descri√ß√µes de marca√ß√£o. Para utilizar as descri√ß√µes markdown, utilize as seguintes anota√ß√µes.\n\n| anota√ß√£o | descri√ß√£o | exemplo |\n|-------------|--------------------------------------------|---------------------------------|\n| title | **Obrigat√≥rio.** O t√≠tulo da aplica√ß√£o.| // @title Swagger Example API |\n| version | **Obrigat√≥rio.** Fornece a vers√£o da aplica√ß√£o API.| // @vers√£o 1.0 |\n| description.markdown | Uma breve descri√ß√£o da candidatura. Parsed a partir do ficheiro api.md. Esta √© uma alternativa a @description |// @description.markdown Sem valor necess√°rio, isto analisa a descri√ß√£o do ficheiro api.md |.\n| tag.name | Nome de uma tag.| // @tag.name Este √© o nome da tag |\n| tag.description.markdown | Descri√ß√£o da tag esta √© uma alternativa √† tag.description. A descri√ß√£o ser√° lida a partir de um ficheiro nomeado como tagname.md | // @tag.description.markdown |\n\n## Opera√ß√£o API\n\n**Exemplo**\n[celler/controller](https://github.com/swaggo/swag/tree/master/example/celler/controller)\n\n| anota√ß√£o | descri√ß√£o |\n|-------------|----------------------------------------------------------------------------------------------------------------------------|\n| descri√ß√£o | Uma explica√ß√£o verbosa do comportamento da opera√ß√£o.                                                                           |\n| description.markdown | Uma breve descri√ß√£o da candidatura. A descri√ß√£o ser√° lida a partir de um ficheiro.  Por exemplo, `@description.markdown details` ir√° carregar `details.md`| // @description.file endpoint.description.markdown |\n| id | Um fio √∫nico utilizado para identificar a opera√ß√£o. Deve ser √∫nica entre todas as opera√ß√µes API.                                   |\n| tags | Uma lista de tags para cada opera√ß√£o API que separou por v√≠rgulas.                                                             |\n| summary | Um breve resumo do que a opera√ß√£o faz.                                                                                |\n| accept | Uma lista de tipos de MIME que os APIs podem consumir. Note que accept s√≥ afecta opera√ß√µes com um organismo de pedido, tais como POST, PUT e PATCH.  O valor DEVE ser o descrito em [Tipos de Mime](#mime-types).                     |\n| produce | Uma lista de tipos de MIME que os APIs podem produce. O valor DEVE ser o descrito em [Tipos de Mime](#mime-types).                     |\n| param | Par√¢metros que se separaram por espa√ßos. `param name`,`param type`,`data type`,`is mandatory?`,`comment` `attribute(optional)` |\n| security | [Seguran√ßa](#security) para cada opera√ß√£o API.                                                                               |\n| success | resposta de sucesso que separou por espa√ßos. `return code or default`,`{param type}`,`data type`,`comment` |.\n| failure | Resposta de falha que separou por espa√ßos. `return code or default`,`{param type}`,`data type`,`comment` |\n| response | Igual ao `sucesso` e `falha` |\n| header | Cabe√ßalho em resposta que separou por espa√ßos. `c√≥digo de retorno`,`{tipo de par√¢metro}`,`tipo de dados`,`coment√°rio` |.\n| router | Defini√ß√£o do caminho que separou por espa√ßos. caminho\",`path`,`[httpMethod]` |[httpMethod]` |\n| x-name | A chave de extens√£o, deve ser iniciada por x- e tomar apenas o valor json.                                                           |\n| x-codeSample | Optional Markdown use. tomar `file` como par√¢metro. Isto ir√° ent√£o procurar um ficheiro nomeado como o resumo na pasta dada.                                      |\n| deprecated | Marcar o ponto final como depreciado.                                                                                               |\n\n## Mime Types\n\n`swag` aceita todos os tipos MIME que est√£o no formato correcto, ou seja, correspondem `*/*`.\nAl√©m disso, `swag` tamb√©m aceita pseud√≥nimos para alguns tipos de MIME, como se segue:\n\n\n| Alias                 | MIME Type                         |\n|-----------------------|-----------------------------------|\n| json                  | application/json                  |\n| xml                   | text/xml                          |\n| plain                 | text/plain                        |\n| html                  | text/html                         |\n| mpfd                  | multipart/form-data               |\n| x-www-form-urlencoded | application/x-www-form-urlencoded |\n| json-api              | application/vnd.api+json          |\n| json-stream           | application/x-json-stream         |\n| octet-stream          | application/octet-stream          |\n| png                   | image/png                         |\n| jpeg                  | image/jpeg                        |\n| gif                   | image/gif                         |\n\n\n\n## Tipo de par√¢metro\n\n- query\n- path\n- header\n- body\n- formData\n\n## Tipo de dados\n\n- string (string)\n- integer (int, uint, uint32, uint64)\n- number (float32)\n- boolean (bool)\n- file (param data type when uploading)\n- user defined struct\n\n## Seguran√ßa\n| anota√ß√£o | descri√ß√£o | par√¢metros | exemplo |\n|------------|-------------|------------|---------|\n| securitydefinitions.basic | [Basic](https://swagger.io/docs/specification/2-0/authentication/basic-authentication/) auth.  | | // @securityDefinitions.basicAuth | [B√°sico]()\n| securitydefinitions.apikey | [chave API](https://swagger.io/docs/specification/2-0/authentication/api-keys/) auth.            | in, name, description | // @securityDefinitions.apikey ApiKeyAuth |\n| securitydefinitions.oauth2.application | [Aplica√ß√£o OAuth2](https://swagger.io/docs/specification/authentication/oauth2/) auth.       | tokenUrl, scope, description | // @securitydefinitions.oauth2.application OAuth2Application |\n| securitydefinitions.oauth2.implicit | [OAuth2 implicit](https://swagger.io/docs/specification/authentication/oauth2/) auth.          | authorizationUrl, scope, description | // @securitydefinitions.oauth2.implicit OAuth2Implicit | [OAuth2Implicit]()\n| securitydefinitions.oauth2.password | [OAuth2 password](https://swagger.io/docs/specification/authentication/oauth2/) auth.          | tokenUrl, scope, description | // @securitydefinitions.oauth2.password OAuth2Password |\n| securitydefinitions.oauth2.accessCode | [c√≥digo de acesso OAuth2](https://swagger.io/docs/specification/authentication/oauth2/) auth.       | tokenUrl, authorizationUrl, scope, description | // @securitydefinitions.oauth2.accessCode OAuth2AccessCode | [c√≥digo de acesso OAuth2.accessCode]()\n\n\n| anota√ß√£o de par√¢metros | exemplo |\n|---------------------------------|-------------------------------------------------------------------------|\n| in | // @in header |\n| name | // @name Authorization |\n| tokenUrl | // @tokenUrl https://example.com/oauth/token |\n| authorizationurl | // @authorizationurl https://example.com/oauth/authorize |\n| scope.hoge | // @scope.write Grants write access |\n| description | // @descri√ß√£o OAuth protege os pontos finais da nossa entidade |\n\n## Atributo\n\n```go\n// @Param   enumstring  query     string     false  \"string enums\"       Enums(A, B, C)\n// @Param   enumint     query     int        false  \"int enums\"          Enums(1, 2, 3)\n// @Param   enumnumber  query     number     false  \"int enums\"          Enums(1.1, 1.2, 1.3)\n// @Param   string      query     string     false  \"string valid\"       minlength(5)  maxlength(10)\n// @Param   int         query     int        false  \"int valid\"          minimum(1)    maximum(10)\n// @Param   default     query     string     false  \"string default\"     default(A)\n// @Param   example     query     string     false  \"string example\"     example(string)\n// @Param   collection  query     []string   false  \"string collection\"  collectionFormat(multi)\n// @Param   extensions  query     []string   false  \"string collection\"  extensions(x-example=test,x-nullable)\n```\n\nIt also works for the struct fields:\n\n```go\ntype Foo struct {\n    Bar string `minLength:\"4\" maxLength:\"16\" example:\"random string\"`\n    Baz int `minimum:\"10\" maximum:\"20\" default:\"15\"`\n    Qux []string `enums:\"foo,bar,baz\"`\n}\n```\n\n### Dispon√≠vel\n\nNome do campo | Tipo | Descri√ß√£o\n---|:---:|---\n<a name=\"validate\"></a>validate | `string` | Determina a valida√ß√£o para o par√¢metro. Os valores poss√≠veis s√£o: `required,optional`.\n<a name=\"parameterDefault\"></a>default | * | Declara o valor do par√¢metro que o servidor utilizar√° se nenhum for fornecido, por exemplo, uma \"contagem\" para controlar o n√∫mero de resultados por p√°gina poder√° ser por defeito de 100 se n√£o for fornecido pelo cliente no pedido. (Nota: \"por defeito\" n√£o tem significado para os par√¢metros requeridos).\nSee https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2. Ao contr√°rio do esquema JSON, este valor DEVE estar em conformidade com o definido [`type`](#parameterType) para este par√¢metro.\n<a name=\"parameterMaximum\"></a>maximum | `number` | Ver https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.2.\n<a name=\"parameterMinimum\"></a>minimum | `number` | Ver https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.3.\n<a name=\"parameterMultipleOf\"></a>multipleOf | `number` | Ver https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.1.\n<a name=\"parameterMaxLength\"></a>maxLength | `integer` | Ver https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.1.\n<a name=\"parameterMinLength\"></a>minLength | `integer` | Ver https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.2.\n<a name=\"parameterEnums\"></a>enums | [\\*] | Ver https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1.\n<a name=\"parameterFormat\"></a>format | `string` | O formato de extens√£o para o anteriormente mencionado [`type`](#parameterType). Ver [Data Type Formats](https://swagger.io/specification/v2/#dataTypeFormat) para mais detalhes.\n<a name=\"parameterCollectionFormat\"></a>collectionFormat | `string` |Determina o formato da matriz se for utilizada uma matriz de tipos. Os valores poss√≠veis s√£o: <ul><li>`csv` - valores separados por v√≠rgulas `foo,bar`. <li>`ssv` - valores separados por espa√ßo `foo bar`. <li>`tsv` - valores separados por tabula√ß√£o `foo\\tbar`. <li>`pipes` - valores separados por tubo <code>foo&#124;bar</code>. <li>`multi` - corresponde a m√∫ltiplas inst√¢ncias de par√¢metros em vez de m√∫ltiplos valores para uma √∫nica inst√¢ncia `foo=bar&foo=baz`. This is valid only for parameters [`in`](#parameterIn) \"query\" or \"formData\". </ul> Default value is `csv`.\n<a name=\"parameterExample\"></a>example | * | Declara o exemplo para o valor do par√¢metro\n<a name=\"parameterExtensions\"></a>extensions | `string` | Acrescentar extens√£o aos par√¢metros.\n\n### Futuro\n\nNome do campo | Tipo | Description\n---|:---:|---\n<a name=\"parameterPattern\"></a>pattern | `string` | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.3.\n<a name=\"parameterMaxItems\"></a>maxItems | `integer` | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.2.\n<a name=\"parameterMinItems\"></a>minItems | `integer` | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.3.\n<a name=\"parameterUniqueItems\"></a>uniqueItems | `boolean` | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.4.\n\n## Exemplos\n\n\n### Descri√ß√µes em m√∫ltiplas linhas\n\n√â poss√≠vel acrescentar descri√ß√µes que abranjam v√°rias linhas tanto na descri√ß√£o geral da api como em defini√ß√µes de rotas como esta:\n\n```go\n// @description This is the first line\n// @description This is the second line\n// @description And so forth.\n```\n\n### Estrutura definida pelo utilizador com um tipo de matriz\n\n```go\n// @Success 200 {array} model.Account <-- This is a user defined struct.\n```\n\n```go\npackage model\n\ntype Account struct {\n    ID   int    `json:\"id\" example:\"1\"`\n    Name string `json:\"name\" example:\"account name\"`\n}\n```\n\n\n### Declara√ß√£o de estrutura√ß√£o de fun√ß√µes\n\nPode declarar as estruturas de resposta do seu pedido dentro de um corpo funcional.\nDeve ter de seguir a conven√ß√£o de nomea√ß√£o\n`<package-name>.<function-name>.<struct-name> `.\n\n```go\npackage main\n\n// @Param request body main.MyHandler.request true \"query params\"\n// @Success 200 {object} main.MyHandler.response\n// @Router /test [post]\nfunc MyHandler() {\n\ttype request struct {\n\t\tRequestField string\n\t}\n\n\ttype response struct {\n\t\tResponseField string\n\t}\n}\n```\n\n\n### Composi√ß√£o do modelo em resposta\n```go\n// JSONResult's data field will be overridden by the specific type proto.Order\n@success 200 {object} jsonresult.JSONResult{data=proto.Order} \"desc\"\n```\n\n```go\ntype JSONResult struct {\n    Code    int          `json:\"code\" `\n    Message string       `json:\"message\"`\n    Data    interface{}  `json:\"data\"`\n}\n\ntype Order struct { //in `proto` package\n    Id  uint            `json:\"id\"`\n    Data  interface{}   `json:\"data\"`\n}\n```\n\n- tamb√©m suportam uma variedade de objectos e tipos primitivos como resposta aninhada\n```go\n@success 200 {object} jsonresult.JSONResult{data=[]proto.Order} \"desc\"\n@success 200 {object} jsonresult.JSONResult{data=string} \"desc\"\n@success 200 {object} jsonresult.JSONResult{data=[]string} \"desc\"\n```\n\n- campos m√∫ltiplos que se sobrep√µem. campo ser√° adicionado se n√£o existir\n```go\n@success 200 {object} jsonresult.JSONResult{data1=string,data2=[]string,data3=proto.Order,data4=[]proto.Order} \"desc\"\n```\n- overriding deep-level fields\n```go\ntype DeepObject struct { //in `proto` package\n\t...\n}\n@success 200 {object} jsonresult.JSONResult{data1=proto.Order{data=proto.DeepObject},data2=[]proto.Order{data=[]proto.DeepObject}} \"desc\"\n```\n\n### Adicionar um cabe√ßalho em resposta\n\n```go\n// @Success      200              {string}  string    \"ok\"\n// @failure      400              {string}  string    \"error\"\n// @response     default          {string}  string    \"other error\"\n// @Header       200              {string}  Location  \"/entity/1\"\n// @Header       200,400,default  {string}  Token     \"token\"\n// @Header       all              {string}  Token2    \"token2\"\n```\n\n\n### Utilizar par√¢metros de caminhos m√∫ltiplos\n\n```go\n/// ...\n// @Param group_id   path int true \"Group ID\"\n// @Param account_id path int true \"Account ID\"\n// ...\n// @Router /examples/groups/{group_id}/accounts/{account_id} [get]\n```\n\n### Adicionar m√∫ltiplos caminhos\n\n```go\n/// ...\n// @Param group_id path int true \"Group ID\"\n// @Param user_id  path int true \"User ID\"\n// ...\n// @Router /examples/groups/{group_id}/user/{user_id}/address [put]\n// @Router /examples/user/{user_id}/address [put]\n```\n\n### Exemplo de valor de estrutura\n\n```go\ntype Account struct {\n    ID   int    `json:\"id\" example:\"1\"`\n    Name string `json:\"name\" example:\"account name\"`\n    PhotoUrls []string `json:\"photo_urls\" example:\"http://test/image/1.jpg,http://test/image/2.jpg\"`\n}\n```\n\n### Schema Exemplo do corpo\n\n```go\n// @Param email body string true \"message/rfc822\" SchemaExample(Subject: Testmail\\r\\n\\r\\nBody Message\\r\\n)\n```\n\n### Descri√ß√£o da estrutura\n\n```go\n// Account model info\n// @Description User account information\n// @Description with user id and username\ntype Account struct {\n\t// ID this is userid\n\tID   int    `json:\"id\"`\n\tName string `json:\"name\"` // This is Name\n}\n```\n\n[#708](https://github.com/swaggo/swag/issues/708) O analisador trata apenas de coment√°rios estruturais a partir de `@Description` attribute.\n\nAssim, gerou o doc. de swagger como se segue:\n```json\n\"Account\": {\n  \"type\":\"object\",\n  \"description\": \"User account information with user id and username\"\n  \"properties\": {\n    \"id\": {\n      \"type\": \"integer\",\n      \"description\": \"ID this is userid\"\n    },\n    \"name\": {\n      \"type\":\"string\",\n      \"description\": \"This is Name\"\n    }\n  }\n}\n```\n\n### Usar etiqueta do tipo swaggertype para suportar o tipo personalizado\n[#201](https://github.com/swaggo/swag/issues/201#issuecomment-475479409)\n\n```go\ntype TimestampTime struct {\n    time.Time\n}\n\n///implement encoding.JSON.Marshaler interface\nfunc (t *TimestampTime) MarshalJSON() ([]byte, error) {\n    bin := make([]byte, 16)\n    bin = strconv.AppendInt(bin[:0], t.Time.Unix(), 10)\n    return bin, nil\n}\n\nfunc (t *TimestampTime) UnmarshalJSON(bin []byte) error {\n    v, err := strconv.ParseInt(string(bin), 10, 64)\n    if err != nil {\n        return err\n    }\n    t.Time = time.Unix(v, 0)\n    return nil\n}\n///\n\ntype Account struct {\n    // Override primitive type by simply specifying it via `swaggertype` tag\n    ID     sql.NullInt64 `json:\"id\" swaggertype:\"integer\"`\n\n    // Override struct type to a primitive type 'integer' by specifying it via `swaggertype` tag\n    RegisterTime TimestampTime `json:\"register_time\" swaggertype:\"primitive,integer\"`\n\n    // Array types can be overridden using \"array,<prim_type>\" format\n    Coeffs []big.Float `json:\"coeffs\" swaggertype:\"array,number\"`\n}\n```\n\n[#379](https://github.com/swaggo/swag/issues/379)\n```go\ntype CerticateKeyPair struct {\n\tCrt []byte `json:\"crt\" swaggertype:\"string\" format:\"base64\" example:\"U3dhZ2dlciByb2Nrcw==\"`\n\tKey []byte `json:\"key\" swaggertype:\"string\" format:\"base64\" example:\"U3dhZ2dlciByb2Nrcw==\"`\n}\n```\ngenerated swagger doc as follows:\n```go\n\"api.MyBinding\": {\n  \"type\":\"object\",\n  \"properties\":{\n    \"crt\":{\n      \"type\":\"string\",\n      \"format\":\"base64\",\n      \"example\":\"U3dhZ2dlciByb2Nrcw==\"\n    },\n    \"key\":{\n      \"type\":\"string\",\n      \"format\":\"base64\",\n      \"example\":\"U3dhZ2dlciByb2Nrcw==\"\n    }\n  }\n}\n\n```\n\n### Utilizar anula√ß√µes globais para suportar um tipo personalizado\n\nSe estiver a utilizar ficheiros gerados, as etiquetas [`swaggertype`](#use-swaggertype-tag-to-supported-custom-type) ou `swaggerignore` podem n√£o ser poss√≠veis.\n\nAo passar um mapeamento para swag com `--overridesFile` pode dizer swag para utilizar um tipo no lugar de outro onde quer que apare√ßa. Por defeito, se um ficheiro `.swaggo` estiver presente no direct√≥rio actual, ser√° utilizado.\n\nGo code:\n```go\ntype MyStruct struct {\n  ID     sql.NullInt64 `json:\"id\"`\n  Name   sql.NullString `json:\"name\"`\n}\n```\n\n`.swaggo`:\n```\n// Substituir todos os NullInt64 por int\nreplace database/sql.NullInt64 int\n\n// N√£o inclua quaisquer campos do tipo base de database/sql.\nNullString no swagger docs\nskip    database/sql.NullString\n```\n\nAs directivas poss√≠veis s√£o coment√°rios (come√ßando por `//`), `replace path/to/a.type path/to/b.type`, e `skip path/to/a.type`.\n\n(Note que os caminhos completos para qualquer tipo nomeado devem ser fornecidos para evitar problemas quando v√°rios pacotes definem um tipo com o mesmo nome)\n\nEntregue em:\n```go\n\"types.MyStruct\": {\n  \"id\": \"integer\"\n}\n\n### Use swaggerignore tag para excluir um campo\n\n```go\ntype Account struct {\n    ID   string    `json:\"id\"`\n    Name string     `json:\"name\"`\n    Ignored int     `swaggerignore:\"true\"`\n}\n```\n\n\n### Adicionar informa√ß√µes de extens√£o ao campo de estrutura√ß√£o\n\n```go\ntype Account struct {\n    ID   string    `json:\"id\"   extensions:\"x-nullable,x-abc=def,!x-omitempty\"` // extensions fields must start with \"x-\"\n}\n```\n\ngerar doc. de swagger como se segue:\n\n```go\n\"Account\": {\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"x-nullable\": true,\n            \"x-abc\": \"def\",\n            \"x-omitempty\": false\n        }\n    }\n}\n```\n\n\n### Renomear modelo a expor\n\n```golang\ntype Resp struct {\n\tCode int\n}//@name Response\n```\n\n### Como utilizar as anota√ß√µes de seguran√ßa\n\nInforma√ß√µes API gerais.\n\n```go\n// @securityDefinitions.basic BasicAuth\n\n// @securitydefinitions.oauth2.application OAuth2Application\n// @tokenUrl https://example.com/oauth/token\n// @scope.write Grants write access\n// @scope.admin Grants read and write access to administrative information\n```\n\nCada opera√ß√£o API.\n\n```go\n// @Security ApiKeyAuth\n```\n\nFa√ßa-o OR condicione-o\n\n```go\n// @Security ApiKeyAuth\n// @Security OAuth2Application[write, admin]\n```\n\nFa√ßa-o AND condi√ß√£o\n\n```go\n// @Security ApiKeyAuth && firebase\n// @Security OAuth2Application[write, admin] && APIKeyAuth\n```\n\n\n\n### Adicionar uma descri√ß√£o para enumerar artigos\n\n```go\ntype Example struct {\n\t// Sort order:\n\t// * asc - Ascending, from A to Z.\n\t// * desc - Descending, from Z to A.\n\tOrder string `enums:\"asc,desc\"`\n}\n```\n\n### Gerar apenas tipos de ficheiros de documentos espec√≠ficos\n\nPor defeito, o comando `swag` gera especifica√ß√£o Swagger em tr√™s tipos diferentes de ficheiros/arquivos:\n- docs.go\n- swagger.json\n- swagger.yaml\n\nSe desejar limitar um conjunto de tipos de ficheiros que devem ser gerados pode utilizar a bandeira `--outputTypes` (short `-ot`). O valor por defeito √© `go,json,yaml` - tipos de sa√≠da separados por v√≠rgula. Para limitar a sa√≠da apenas a ficheiros `go` e `yaml`, escrever-se-ia `go,yaml'. Com comando completo que seria `swag init --outputTypes go,yaml`.\n\n### Como usar tipos gen√©ricos\n\n```go\n// @Success 200 {object} web.GenericNestedResponse[types.Post]\n// @Success 204 {object} web.GenericNestedResponse[types.Post, Types.AnotherOne]\n// @Success 201 {object} web.GenericNestedResponse[web.GenericInnerType[types.Post]]\nfunc GetPosts(w http.ResponseWriter, r *http.Request) {\n\t_ = web.GenericNestedResponse[types.Post]{}\n}\n```\nPara mais detalhes e outros exemplos, veja [esse arquivo](https://github.com/swaggo/swag/blob/master/testdata/generics_nested/api/api.go)\n\n### Alterar os delimitadores de ac√ß√£o padr√£o Go Template\n[#980](https://github.com/swaggo/swag/issues/980)\n[#1177](https://github.com/swaggo/swag/issues/1177)\n\nSe as suas anota√ß√µes ou campos estruturantes cont√™m \"{{\" or \"}}\", a gera√ß√£o de modelos ir√° muito provavelmente falhar, uma vez que estes s√£o os delimitadores por defeito para [go templates](https://pkg.go.dev/text/template#Template.Delims).\n\nPara que a gera√ß√£o funcione correctamente, pode alterar os delimitadores por defeito com `-td'. Por exemplo:\n``console\nswag init -g http/api.go -td \"[[,]\"\n```\n\nO novo delimitador √© um fio com o formato \"`<left delimiter>`,`<right delimiter>`\".\n\n## Sobre o projecto\nEste projecto foi inspirado por [yvasiyarov/swagger](https://github.com/yvasiyarov/swagger) mas simplific√°mos a utiliza√ß√£o e acrescent√°mos apoio a uma variedade de [frameworks web](#estruturas-web-suportadas). A fonte de imagem Gopher √© [tenntenn/gopher-stickers](https://github.com/tenntenn/gopher-stickers). Tem licen√ßas [creative commons licensing](http://creativecommons.org/licenses/by/3.0/deed.en).\n\n## Contribuidores\n\nEste projecto existe gra√ßas a todas as pessoas que contribuem. [[Contribute](CONTRIBUTING.md)].\n<a href=\"https://github.com/swaggo/swag/graphs/contributors\"><img src=\"https://opencollective.com/swag/contributors.svg?width=890&button=false\" /></a>\n\n\n## Apoios\n\nObrigado a todos os nossos apoiantes! üôè [[Become a backer](https://opencollective.com/swag#backer)]\n\n<a href=\"https://opencollective.com/swag#backers\" target=\"_blank\"><img src=\"https://opencollective.com/swag/backers.svg?width=890\"></a>\n\n\n## Patrocinadores\n\nApoiar este projecto tornando-se um patrocinador. O seu log√≥tipo aparecer√° aqui com um link para o seu website. [[Become a sponsor](https://opencollective.com/swag#sponsor)]\n\n\n<a href=\"https://opencollective.com/swag/sponsor/0/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/0/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/1/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/1/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/2/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/2/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/3/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/3/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/4/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/4/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/5/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/5/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/6/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/6/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/7/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/7/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/8/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/8/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/9/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/9/avatar.svg\"></a>\n\n\n## Licen√ßa\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fswaggo%2Fswag.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fswaggo%2Fswag?ref=badge_large)\n"
        },
        {
          "name": "README_zh-CN.md",
          "type": "blob",
          "size": 38.396484375,
          "content": "# swag\n\nüåç *[English](README.md) ‚àô [ÁÆÄ‰Ωì‰∏≠Êñá](README_zh-CN.md)*\n\n<img align=\"right\" width=\"180px\" src=\"https://raw.githubusercontent.com/swaggo/swag/master/assets/swaggo.png\">\n\n[![Travis Status](https://img.shields.io/travis/swaggo/swag/master.svg)](https://travis-ci.org/swaggo/swag)\n[![Coverage Status](https://img.shields.io/codecov/c/github/swaggo/swag/master.svg)](https://codecov.io/gh/swaggo/swag)\n[![Go Report Card](https://goreportcard.com/badge/github.com/swaggo/swag)](https://goreportcard.com/report/github.com/swaggo/swag)\n[![codebeat badge](https://codebeat.co/badges/71e2f5e5-9e6b-405d-baf9-7cc8b5037330)](https://codebeat.co/projects/github-com-swaggo-swag-master)\n[![Go Doc](https://godoc.org/github.com/swaggo/swagg?status.svg)](https://godoc.org/github.com/swaggo/swag)\n[![Backers on Open Collective](https://opencollective.com/swag/backers/badge.svg)](#backers) \n[![Sponsors on Open Collective](https://opencollective.com/swag/sponsors/badge.svg)](#sponsors) [![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fswaggo%2Fswag.svg?type=shield)](https://app.fossa.io/projects/git%2Bgithub.com%2Fswaggo%2Fswag?ref=badge_shield)\n[![Release](https://img.shields.io/github/release/swaggo/swag.svg?style=flat-square)](https://github.com/swaggo/swag/releases)\n\nSwagÂ∞ÜGoÁöÑÊ≥®ÈáäËΩ¨Êç¢‰∏∫Swagger2.0ÊñáÊ°£„ÄÇÊàë‰ª¨‰∏∫ÊµÅË°åÁöÑ [Go Web Framework](#ÊîØÊåÅÁöÑWebÊ°ÜÊû∂) ÂàõÂª∫‰∫ÜÂêÑÁßçÊèí‰ª∂ÔºåËøôÊ†∑ÂèØ‰ª•‰∏éÁé∞ÊúâGoÈ°πÁõÆÂø´ÈÄüÈõÜÊàêÔºà‰ΩøÁî®Swagger UIÔºâ„ÄÇ\n\n## ÁõÆÂΩï\n\n- [Âø´ÈÄüÂºÄÂßã](#Âø´ÈÄüÂºÄÂßã)\n- [ÊîØÊåÅÁöÑWebÊ°ÜÊû∂](#ÊîØÊåÅÁöÑwebÊ°ÜÊû∂)\n- [Â¶Ç‰Ωï‰∏éGinÈõÜÊàê](#Â¶Ç‰Ωï‰∏éginÈõÜÊàê)\n- [Ê†ºÂºèÂåñËØ¥Êòé](#Ê†ºÂºèÂåñËØ¥Êòé)\n- [ÂºÄÂèëÁé∞Áä∂](#ÂºÄÂèëÁé∞Áä∂)\n- [Â£∞ÊòéÂºèÊ≥®ÈáäÊ†ºÂºè](#Â£∞ÊòéÂºèÊ≥®ÈáäÊ†ºÂºè)\n    - [ÈÄöÁî®API‰ø°ÊÅØ](#ÈÄöÁî®api‰ø°ÊÅØ)\n    - [APIÊìç‰Ωú](#apiÊìç‰Ωú)\n    - [ÂÆâÂÖ®ÊÄß](#ÂÆâÂÖ®ÊÄß)\n- [Ê†∑‰æã](#Ê†∑‰æã)\n    - [Â§öË°åÁöÑÊèèËø∞](#Â§öË°åÁöÑÊèèËø∞)\n    - [Áî®Êà∑Ëá™ÂÆö‰πâÁöÑÂÖ∑ÊúâÊï∞ÁªÑÁ±ªÂûãÁöÑÁªìÊûÑ](#Áî®Êà∑Ëá™ÂÆö‰πâÁöÑÂÖ∑ÊúâÊï∞ÁªÑÁ±ªÂûãÁöÑÁªìÊûÑ)\n    - [ÂìçÂ∫îÂØπË±°‰∏≠ÁöÑÊ®°ÂûãÁªÑÂêà](#ÂìçÂ∫îÂØπË±°‰∏≠ÁöÑÊ®°ÂûãÁªÑÂêà)\n    - [Âú®ÂìçÂ∫î‰∏≠Â¢ûÂä†Â§¥Â≠óÊÆµ](#Âú®ÂìçÂ∫î‰∏≠Â¢ûÂä†Â§¥Â≠óÊÆµ)\n    - [‰ΩøÁî®Â§öË∑ØÂæÑÂèÇÊï∞](#‰ΩøÁî®Â§öË∑ØÂæÑÂèÇÊï∞)\n    - [ÁªìÊûÑ‰ΩìÁöÑÁ§∫‰æãÂÄº](#ÁªìÊûÑ‰ΩìÁöÑÁ§∫‰æãÂÄº)\n    - [ÁªìÊûÑ‰ΩìÊèèËø∞](#ÁªìÊûÑ‰ΩìÊèèËø∞)\n    - [‰ΩøÁî®`swaggertype`Ê†áÁ≠æÊõ¥ÊîπÂ≠óÊÆµÁ±ªÂûã](#‰ΩøÁî®`swaggertype`Ê†áÁ≠æÊõ¥ÊîπÂ≠óÊÆµÁ±ªÂûã)\n    - [‰ΩøÁî®`swaggerignore`Ê†áÁ≠æÊéíÈô§Â≠óÊÆµ](#‰ΩøÁî®swaggerignoreÊ†áÁ≠æÊéíÈô§Â≠óÊÆµ)\n    - [Â∞ÜÊâ©Â±ï‰ø°ÊÅØÊ∑ªÂä†Âà∞ÁªìÊûÑÂ≠óÊÆµ](#Â∞ÜÊâ©Â±ï‰ø°ÊÅØÊ∑ªÂä†Âà∞ÁªìÊûÑÂ≠óÊÆµ)\n    - [ÂØπÂ±ïÁ§∫ÁöÑÊ®°ÂûãÈáçÂëΩÂêç](#ÂØπÂ±ïÁ§∫ÁöÑÊ®°ÂûãÈáçÂëΩÂêç)\n    - [Â¶Ç‰Ωï‰ΩøÁî®ÂÆâÂÖ®ÊÄßÊ≥®Èáä](#Â¶Ç‰Ωï‰ΩøÁî®ÂÆâÂÖ®ÊÄßÊ≥®Èáä)\n- [È°πÁõÆÁõ∏ÂÖ≥](#È°πÁõÆÁõ∏ÂÖ≥)\n\n## Âø´ÈÄüÂºÄÂßã\n\n1. Â∞ÜÊ≥®ÈáäÊ∑ªÂä†Âà∞APIÊ∫ê‰ª£Á†Å‰∏≠ÔºåËØ∑ÂèÇÈòÖÂ£∞ÊòéÊÄßÊ≥®ÈáäÊ†ºÂºè„ÄÇ\n2. ‰ΩøÁî®Â¶Ç‰∏ãÂëΩ‰ª§‰∏ãËΩΩswagÔºö\n\n```bash\ngo install github.com/swaggo/swag/cmd/swag@latest\n```\n\n‰ªéÊ∫êÁ†ÅÂºÄÂßãÊûÑÂª∫ÁöÑËØùÔºåÈúÄË¶ÅÊúâGoÁéØÂ¢ÉÔºà1.19Âèä‰ª•‰∏äÁâàÊú¨Ôºâ„ÄÇ\n\nÊàñËÄÖ‰ªégithubÁöÑreleaseÈ°µÈù¢‰∏ãËΩΩÈ¢ÑÁºñËØëÂ•ΩÁöÑ‰∫åËøõÂà∂Êñá‰ª∂„ÄÇ\n\n3. Âú®ÂåÖÂê´`main.go`Êñá‰ª∂ÁöÑÈ°πÁõÆÊ†πÁõÆÂΩïËøêË°å`swag init`„ÄÇËøôÂ∞Ü‰ºöËß£ÊûêÊ≥®ÈáäÂπ∂ÁîüÊàêÈúÄË¶ÅÁöÑÊñá‰ª∂Ôºà`docs`Êñá‰ª∂Â§πÂíå`docs/docs.go`Ôºâ„ÄÇ\n\n```bash\nswag init\n```\n\nÁ°Æ‰øùÂØºÂÖ•‰∫ÜÁîüÊàêÁöÑ`docs/docs.go`Êñá‰ª∂ÔºåËøôÊ†∑ÁâπÂÆöÁöÑÈÖçÁΩÆÊñá‰ª∂Êâç‰ºöË¢´ÂàùÂßãÂåñ„ÄÇÂ¶ÇÊûúÈÄöÁî®APIÊ≥®ÈáäÊ≤°ÊúâÂÜôÂú®`main.go`‰∏≠ÔºåÂèØ‰ª•‰ΩøÁî®`-g`Ê†áËØÜÁ¨¶Êù•ÂëäÁü•swag„ÄÇ\n\n```bash\nswag init -g http/api.go\n```\n\n4. (ÂèØÈÄâ) ‰ΩøÁî®`fmt`Ê†ºÂºèÂåñ SWAG Ê≥®Èáä„ÄÇ(ËØ∑ÂÖàÂçáÁ∫ßÂà∞ÊúÄÊñ∞ÁâàÊú¨)\n\n```bash\nswag fmt\n```\n\n## swag cli\n\n```bash\nswag init -h\nNAME:\n   swag init - Create docs.go\n\nUSAGE:\n   swag init [command options] [arguments...]\n\nOPTIONS:\n   --generalInfo value, -g value          APIÈÄöÁî®‰ø°ÊÅØÊâÄÂú®ÁöÑgoÊ∫êÊñá‰ª∂Ë∑ØÂæÑÔºåÂ¶ÇÊûúÊòØÁõ∏ÂØπË∑ØÂæÑÂàôÂü∫‰∫éAPIËß£ÊûêÁõÆÂΩï (ÈªòËÆ§: \"main.go\")\n   --dir value, -d value                  APIËß£ÊûêÁõÆÂΩï (ÈªòËÆ§: \"./\")\n   --exclude value                        Ëß£ÊûêÊâ´ÊèèÊó∂ÊéíÈô§ÁöÑÁõÆÂΩïÔºåÂ§ö‰∏™ÁõÆÂΩïÂèØÁî®ÈÄóÂè∑ÂàÜÈöîÔºàÈªòËÆ§ÔºöÁ©∫Ôºâ\n   --propertyStrategy value, -p value     ÁªìÊûÑ‰ΩìÂ≠óÊÆµÂëΩÂêçËßÑÂàôÔºå‰∏âÁßçÔºösnakecase,camelcase,pascalcase (ÈªòËÆ§: \"camelcase\")\n   --output value, -o value               Êñá‰ª∂(swagger.json, swagger.yaml and doc.go)ËæìÂá∫ÁõÆÂΩï (ÈªòËÆ§: \"./docs\")\n   --parseVendor                          ÊòØÂê¶Ëß£ÊûêvendorÁõÆÂΩïÈáåÁöÑgoÊ∫êÊñá‰ª∂ÔºåÈªòËÆ§‰∏ç\n   --parseDependency                      ÊòØÂê¶Ëß£Êûê‰æùËµñÁõÆÂΩï‰∏≠ÁöÑgoÊ∫êÊñá‰ª∂ÔºåÈªòËÆ§‰∏ç\n   --parseDependencyLevel, --pdl          ÂØπ'--parseDependency'ÂèÇÊï∞ËøõË°åÂ¢ûÂº∫, ÊòØÂê¶Ëß£Êûê‰æùËµñÁõÆÂΩï‰∏≠ÁöÑgoÊ∫êÊñá‰ª∂, 0 ‰∏çËß£Êûê, 1 Âè™Ëß£ÊûêÂØπË±°Ê®°Âûã, 2 Âè™Ëß£ÊûêAPI, 3 ÂØπË±°Ê®°ÂûãÂíåAPIÈÉΩËß£Êûê (default: 0)\n   --markdownFiles value, --md value      ÊåáÂÆöAPIÁöÑÊèèËø∞‰ø°ÊÅØÊâÄ‰ΩøÁî®ÁöÑmarkdownÊñá‰ª∂ÊâÄÂú®ÁöÑÁõÆÂΩï\n   --generatedTime                        ÊòØÂê¶ËæìÂá∫Êó∂Èó¥Âà∞ËæìÂá∫Êñá‰ª∂docs.goÁöÑÈ°∂ÈÉ®ÔºåÈªòËÆ§ÊòØ\n   --codeExampleFiles value, --cef value  Ëß£ÊûêÂåÖÂê´Áî®‰∫é x-codeSamples Êâ©Â±ïÁöÑ‰ª£Á†ÅÁ§∫‰æãÊñá‰ª∂ÁöÑÊñá‰ª∂Â§πÔºåÈªòËÆ§Á¶ÅÁî®\n   --parseInternal                        Ëß£Êûê internal ÂåÖ‰∏≠ÁöÑgoÊñá‰ª∂ÔºåÈªòËÆ§Á¶ÅÁî®\n   --parseDepth value                     ‰æùËµñËß£ÊûêÊ∑±Â∫¶ (ÈªòËÆ§: 100)\n   --instanceName value                   ËÆæÁΩÆÊñáÊ°£ÂÆû‰æãÂêç (ÈªòËÆ§: \"swagger\")\n```\n\n```bash\nswag fmt -h\nNAME:\n   swag fmt - format swag comments\n\nUSAGE:\n   swag fmt [command options] [arguments...]\n\nOPTIONS:\n   --dir value, -d value          APIËß£ÊûêÁõÆÂΩï (ÈªòËÆ§: \"./\")\n   --exclude value                Ëß£ÊûêÊâ´ÊèèÊó∂ÊéíÈô§ÁöÑÁõÆÂΩïÔºåÂ§ö‰∏™ÁõÆÂΩïÂèØÁî®ÈÄóÂè∑ÂàÜÈöîÔºàÈªòËÆ§ÔºöÁ©∫Ôºâ\n   --generalInfo value, -g value  APIÈÄöÁî®‰ø°ÊÅØÊâÄÂú®ÁöÑgoÊ∫êÊñá‰ª∂Ë∑ØÂæÑÔºåÂ¶ÇÊûúÊòØÁõ∏ÂØπË∑ØÂæÑÂàôÂü∫‰∫éAPIËß£ÊûêÁõÆÂΩï (ÈªòËÆ§: \"main.go\")\n   --help, -h                     show help (default: false)\n\n```\n\n## ÊîØÊåÅÁöÑWebÊ°ÜÊû∂\n\n- [gin](http://github.com/swaggo/gin-swagger)\n- [echo](http://github.com/swaggo/echo-swagger)\n- [buffalo](https://github.com/swaggo/buffalo-swagger)\n- [net/http](https://github.com/swaggo/http-swagger)\n- [gorilla/mux](https://github.com/swaggo/http-swagger)\n- [go-chi/chi](https://github.com/swaggo/http-swagger)\n- [flamingo](https://github.com/i-love-flamingo/swagger)\n- [fiber](https://github.com/gofiber/swagger)\n- [atreugo](https://github.com/Nerzal/atreugo-swagger)\n- [hertz](https://github.com/hertz-contrib/swagger)\n\n## Â¶Ç‰Ωï‰∏éGinÈõÜÊàê\n\n[ÁÇπÂáªÊ≠§Â§Ñ](https://github.com/swaggo/swag/tree/master/example/celler)Êü•ÁúãÁ§∫‰æãÊ∫ê‰ª£Á†Å„ÄÇ\n\n1. ‰ΩøÁî®`swag init`ÁîüÊàêSwagger2.0ÊñáÊ°£ÂêéÔºåÂØºÂÖ•Â¶Ç‰∏ã‰ª£Á†ÅÂåÖÔºö\n\n```go\nimport \"github.com/swaggo/gin-swagger\" // gin-swagger middleware\nimport \"github.com/swaggo/files\" // swagger embed files\n```\n\n2. Âú®`main.go`Ê∫ê‰ª£Á†Å‰∏≠Ê∑ªÂä†ÈÄöÁî®ÁöÑAPIÊ≥®ÈáäÔºö\n\n```go\n// @title           Swagger Example API\n// @version         1.0\n// @description     This is a sample server celler server.\n// @termsOfService  http://swagger.io/terms/\n\n// @contact.name   API Support\n// @contact.url    http://www.swagger.io/support\n// @contact.email  support@swagger.io\n\n// @license.name  Apache 2.0\n// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html\n\n// @host      localhost:8080\n// @BasePath  /api/v1\n\n// @securityDefinitions.basic  BasicAuth\n\n// @externalDocs.description  OpenAPI\n// @externalDocs.url          https://swagger.io/resources/open-api/\nfunc main() {\n    r := gin.Default()\n\n    c := controller.NewController()\n\n    v1 := r.Group(\"/api/v1\")\n    {\n        accounts := v1.Group(\"/accounts\")\n        {\n            accounts.GET(\":id\", c.ShowAccount)\n            accounts.GET(\"\", c.ListAccounts)\n            accounts.POST(\"\", c.AddAccount)\n            accounts.DELETE(\":id\", c.DeleteAccount)\n            accounts.PATCH(\":id\", c.UpdateAccount)\n            accounts.POST(\":id/images\", c.UploadAccountImage)\n        }\n    //...\n    }\n    r.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n    r.Run(\":8080\")\n}\n//...\n```\n\nÊ≠§Â§ñÔºåÂèØ‰ª•Âä®ÊÄÅËÆæÁΩÆ‰∏Ä‰∫õÈÄöÁî®ÁöÑAPI‰ø°ÊÅØ„ÄÇÁîüÊàêÁöÑ‰ª£Á†ÅÂåÖ`docs`ÂØºÂá∫`SwaggerInfo`ÂèòÈáèÔºå‰ΩøÁî®ËØ•ÂèòÈáèÂèØ‰ª•ÈÄöËøáÁºñÁ†ÅÁöÑÊñπÂºèËÆæÁΩÆÊ†áÈ¢ò„ÄÅÊèèËø∞„ÄÅÁâàÊú¨„ÄÅ‰∏ªÊú∫ÂíåÂü∫Á°ÄË∑ØÂæÑ„ÄÇ‰ΩøÁî®GinÁöÑÁ§∫‰æãÔºö\n\n```go\npackage main\n\nimport (\n    \"github.com/gin-gonic/gin\"\n    \"github.com/swaggo/files\"\n    \"github.com/swaggo/gin-swagger\"\n\n    \"./docs\" // docs is generated by Swag CLI, you have to import it.\n)\n\n// @contact.name   API Support\n// @contact.url    http://www.swagger.io/support\n// @contact.email  support@swagger.io\n\n// @license.name  Apache 2.0\n// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html\nfunc main() {\n\n    // programatically set swagger info\n    docs.SwaggerInfo.Title = \"Swagger Example API\"\n    docs.SwaggerInfo.Description = \"This is a sample server Petstore server.\"\n    docs.SwaggerInfo.Version = \"1.0\"\n    docs.SwaggerInfo.Host = \"petstore.swagger.io\"\n    docs.SwaggerInfo.BasePath = \"/v2\"\n    docs.SwaggerInfo.Schemes = []string{\"http\", \"https\"}\n\n    r := gin.New()\n\n    // use ginSwagger middleware to serve the API docs\n    r.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\n\n    r.Run()\n}\n```\n\n3. Âú®`controller`‰ª£Á†Å‰∏≠Ê∑ªÂä†APIÊìç‰ΩúÊ≥®ÈáäÔºö\n\n```go\npackage controller\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"strconv\"\n\n    \"github.com/gin-gonic/gin\"\n    \"github.com/swaggo/swag/example/celler/httputil\"\n    \"github.com/swaggo/swag/example/celler/model\"\n)\n\n// ShowAccount godoc\n// @Summary      Show an account\n// @Description  get string by ID\n// @Tags         accounts\n// @Accept       json\n// @Produce      json\n// @Param        id   path      int  true  \"Account ID\"\n// @Success      200  {object}  model.Account\n// @Failure      400  {object}  httputil.HTTPError\n// @Failure      404  {object}  httputil.HTTPError\n// @Failure      500  {object}  httputil.HTTPError\n// @Router       /accounts/{id} [get]\nfunc (c *Controller) ShowAccount(ctx *gin.Context) {\n  id := ctx.Param(\"id\")\n  aid, err := strconv.Atoi(id)\n  if err != nil {\n    httputil.NewError(ctx, http.StatusBadRequest, err)\n    return\n  }\n  account, err := model.AccountOne(aid)\n  if err != nil {\n    httputil.NewError(ctx, http.StatusNotFound, err)\n    return\n  }\n  ctx.JSON(http.StatusOK, account)\n}\n\n// ListAccounts godoc\n// @Summary      List accounts\n// @Description  get accounts\n// @Tags         accounts\n// @Accept       json\n// @Produce      json\n// @Param        q    query     string  false  \"name search by q\"  Format(email)\n// @Success      200  {array}   model.Account\n// @Failure      400  {object}  httputil.HTTPError\n// @Failure      404  {object}  httputil.HTTPError\n// @Failure      500  {object}  httputil.HTTPError\n// @Router       /accounts [get]\nfunc (c *Controller) ListAccounts(ctx *gin.Context) {\n  q := ctx.Request.URL.Query().Get(\"q\")\n  accounts, err := model.AccountsAll(q)\n  if err != nil {\n    httputil.NewError(ctx, http.StatusNotFound, err)\n    return\n  }\n  ctx.JSON(http.StatusOK, accounts)\n}\n//...\n```\n\n```bash\nswag init\n```\n\n4. ËøêË°åÁ®ãÂ∫èÔºåÁÑ∂ÂêéÂú®ÊµèËßàÂô®‰∏≠ËÆøÈóÆ http://localhost:8080/swagger/index.html „ÄÇÂ∞ÜÁúãÂà∞Swagger 2.0 ApiÊñáÊ°£ÔºåÂ¶Ç‰∏ãÊâÄÁ§∫Ôºö\n\n![swagger_index.html](https://raw.githubusercontent.com/swaggo/swag/master/assets/swagger-image.png)\n\n## Ê†ºÂºèÂåñËØ¥Êòé\n\nÂèØ‰ª•ÈíàÂØπSwagÁöÑÊ≥®ÈáäËá™Âä®Ê†ºÂºèÂåñÔºåÂ∞±ÂÉè`go fmt`„ÄÇ   \nÊ≠§Â§ÑÊü•ÁúãÊ†ºÂºèÂåñÁªìÊûú [here](https://github.com/swaggo/swag/tree/master/example/celler).\n\nÁ§∫‰æãÔºö\n```shell\nswag fmt\n```\n\nÊéíÈô§ÁõÆÂΩïÔºà‰∏çÊâ´ÊèèÔºâÁ§∫‰æãÔºö\n```shell\nswag fmt -d ./ --exclude ./internal\n```\n\n## ÂºÄÂèëÁé∞Áä∂\n\n[Swagger 2.0 ÊñáÊ°£](https://swagger.io/docs/specification/2-0/basic-structure/)\n\n- [x] Basic Structure\n- [x] API Host and Base Path\n- [x] Paths and Operations\n- [x] Describing Parameters\n- [x] Describing Request Body\n- [x] Describing Responses\n- [x] MIME Types\n- [x] Authentication\n  - [x] Basic Authentication\n  - [x] API Keys\n- [x] Adding Examples\n- [x] File Upload\n- [x] Enums\n- [x] Grouping Operations With Tags\n- [ ] Swagger Extensions\n\n## Â£∞ÊòéÂºèÊ≥®ÈáäÊ†ºÂºè\n\n## ÈÄöÁî®API‰ø°ÊÅØ\n\n**Á§∫‰æã** [`celler/main.go`](https://github.com/swaggo/swag/blob/master/example/celler/main.go)\n\n| Ê≥®Èáä                    | ËØ¥Êòé                                                                                            | Á§∫‰æã                                                            |\n| ----------------------- | ----------------------------------------------------------------------------------------------- | --------------------------------------------------------------- |\n| title                   | **ÂøÖÂ°´** Â∫îÁî®Á®ãÂ∫èÁöÑÂêçÁß∞„ÄÇ                                                                       | // @title Swagger Example API                                   |\n| version                 | **ÂøÖÂ°´** Êèê‰æõÂ∫îÁî®Á®ãÂ∫èAPIÁöÑÁâàÊú¨„ÄÇ                                                                | // @version 1.0                                                 |\n| description             | Â∫îÁî®Á®ãÂ∫èÁöÑÁÆÄÁü≠ÊèèËø∞„ÄÇ                                                                            | // @description This is a sample server celler server.          |\n| tag.name                | Ê†áÁ≠æÁöÑÂêçÁß∞„ÄÇ                                                                                    | // @tag.name This is the name of the tag                        |\n| tag.description         | Ê†áÁ≠æÁöÑÊèèËø∞„ÄÇ                                                                                    | // @tag.description Cool Description                            |\n| tag.docs.url            | Ê†áÁ≠æÁöÑÂ§ñÈÉ®ÊñáÊ°£ÁöÑURL„ÄÇ                                                                           | // @tag.docs.url https://example.com                            |\n| tag.docs.description    | Ê†áÁ≠æÁöÑÂ§ñÈÉ®ÊñáÊ°£ËØ¥Êòé„ÄÇ                                                                            | // @tag.docs.description Best example documentation             |\n| termsOfService          | APIÁöÑÊúçÂä°Êù°Ê¨æ„ÄÇ                                                                                 | // @termsOfService http://swagger.io/terms/                     |\n| contact.name            | ÂÖ¨ÂºÄÁöÑAPIÁöÑËÅîÁ≥ª‰ø°ÊÅØ„ÄÇ                                                                           | // @contact.name API Support                                    |\n| contact.url             | ËÅîÁ≥ª‰ø°ÊÅØÁöÑURL„ÄÇ ÂøÖÈ°ªÈááÁî®ÁΩëÂùÄÊ†ºÂºè„ÄÇ                                                              | // @contact.url http://www.swagger.io/support                   |\n| contact.email           | ËÅîÁ≥ª‰∫∫/ÁªÑÁªáÁöÑÁîµÂ≠êÈÇÆ‰ª∂Âú∞ÂùÄ„ÄÇ ÂøÖÈ°ªÈááÁî®ÁîµÂ≠êÈÇÆ‰ª∂Âú∞ÂùÄÁöÑÊ†ºÂºè„ÄÇ                                        | // @contact.email support@swagger.io                            |\n| license.name            | **ÂøÖÂ°´** Áî®‰∫éAPIÁöÑËÆ∏ÂèØËØÅÂêçÁß∞„ÄÇ                                                                  | // @license.name Apache 2.0                                     |\n| license.url             | Áî®‰∫éAPIÁöÑËÆ∏ÂèØËØÅÁöÑURL„ÄÇ ÂøÖÈ°ªÈááÁî®ÁΩëÂùÄÊ†ºÂºè„ÄÇ                                                       | // @license.url http://www.apache.org/licenses/LICENSE-2.0.html |\n| host                    | ËøêË°åAPIÁöÑ‰∏ªÊú∫Ôºà‰∏ªÊú∫ÂêçÊàñIPÂú∞ÂùÄÔºâ„ÄÇ                                                               | // @host localhost:8080                                         |\n| BasePath                | ËøêË°åAPIÁöÑÂü∫Êú¨Ë∑ØÂæÑ„ÄÇ                                                                             | // @BasePath /api/v1                                            |\n| accept                  | API ÂèØ‰ª•‰ΩøÁî®ÁöÑ MIME Á±ªÂûãÂàóË°®„ÄÇ ËØ∑Ê≥®ÊÑèÔºåAccept ‰ªÖÂΩ±ÂìçÂÖ∑ÊúâËØ∑Ê±ÇÊ≠£ÊñáÁöÑÊìç‰ΩúÔºå‰æãÂ¶Ç POST„ÄÅPUT Âíå PATCH„ÄÇ ÂÄºÂøÖÈ°ªÂ¶Ç‚Äú[MimeÁ±ªÂûã](#mimeÁ±ªÂûã)‚Äù‰∏≠ÊâÄËø∞„ÄÇ                                  | // @accept json |\n| produce                 | APIÂèØ‰ª•ÁîüÊàêÁöÑMIMEÁ±ªÂûãÁöÑÂàóË°®„ÄÇÂÄºÂøÖÈ°ªÂ¶Ç‚Äú[MimeÁ±ªÂûã](#mimeÁ±ªÂûã)‚Äù‰∏≠ÊâÄËø∞„ÄÇ                                  | // @produce json |\n| query.collection.format | ËØ∑Ê±ÇURI queryÈáåÊï∞ÁªÑÂèÇÊï∞ÁöÑÈªòËÆ§Ê†ºÂºèÔºöcsvÔºåmultiÔºåpipesÔºåtsvÔºåssv„ÄÇ Â¶ÇÊûúÊú™ËÆæÁΩÆÔºåÂàôÈªòËÆ§‰∏∫csv„ÄÇ | // @query.collection.format multi                               |\n| schemes                 | Áî®Á©∫Ê†ºÂàÜÈöîÁöÑËØ∑Ê±ÇÁöÑ‰º†ËæìÂçèËÆÆ„ÄÇ                                                                    | // @schemes http https                                          |\n| externalDocs.description | Description of the external document. | // @externalDocs.description OpenAPI |\n| externalDocs.url         | URL of the external document. | // @externalDocs.url https://swagger.io/resources/open-api/ |\n| x-name                  | Êâ©Â±ïÁöÑÈîÆÂøÖÈ°ª‰ª•x-ÂºÄÂ§¥ÔºåÂπ∂‰∏îÂè™ËÉΩ‰ΩøÁî®jsonÂÄº                                                        | // @x-example-key {\"key\": \"value\"}                              |\n\n### ‰ΩøÁî®MarkdownÊèèËø∞\n\nÂ¶ÇÊûúÊñáÊ°£‰∏≠ÁöÑÁü≠Â≠óÁ¨¶‰∏≤‰∏çË∂≥‰ª•ÂÆåÊï¥Ë°®ËææÔºåÊàñËÄÖÈúÄË¶ÅÂ±ïÁ§∫ÂõæÁâáÔºå‰ª£Á†ÅÁ§∫‰æãÁ≠âÁ±ª‰ººÁöÑÂÜÖÂÆπÔºåÂàôÂèØËÉΩÈúÄË¶Å‰ΩøÁî®MarkdownÊèèËø∞„ÄÇË¶Å‰ΩøÁî®MarkdownÊèèËø∞ÔºåËØ∑‰ΩøÁî®‰∏Ä‰∏ãÊ≥®Èáä„ÄÇ\n\n| Ê≥®Èáä                     | ËØ¥Êòé                                                                                 | Á§∫‰æã                                                                              |\n| ------------------------ | ------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------- |\n| title                    | **ÂøÖÂ°´** Â∫îÁî®Á®ãÂ∫èÁöÑÂêçÁß∞„ÄÇ                                                            | // @title Swagger Example API                                                     |\n| version                  | **ÂøÖÂ°´** Êèê‰æõÂ∫îÁî®Á®ãÂ∫èAPIÁöÑÁâàÊú¨„ÄÇ                                                     | // @version 1.0                                                                   |\n| description.markdown     | Â∫îÁî®Á®ãÂ∫èÁöÑÁÆÄÁü≠ÊèèËø∞„ÄÇ ‰ªé`api.md`Êñá‰ª∂‰∏≠Ëß£Êûê„ÄÇ ËøôÊòØ`@description`ÁöÑÊõø‰ª£Áî®Ê≥ï„ÄÇ           | // @description.markdown No value needed, this parses the description from api.md |\n| tag.name                 | Ê†áÁ≠æÁöÑÂêçÁß∞„ÄÇ                                                                         | // @tag.name This is the name of the tag                                          |\n| tag.description.markdown | Ê†áÁ≠æËØ¥ÊòéÔºåËøôÊòØ`tag.description`ÁöÑÊõø‰ª£Áî®Ê≥ï„ÄÇ ËØ•ÊèèËø∞Â∞Ü‰ªéÂêç‰∏∫`tagname.mdÁöÑ`Êñá‰ª∂‰∏≠ËØªÂèñ„ÄÇ | // @tag.description.markdown                                                      |\n\n## APIÊìç‰Ωú\n\nExample [celler/controller](https://github.com/swaggo/swag/tree/master/example/celler/controller)\n\n| Ê≥®Èáä                   | ÊèèËø∞                                                                                             |\n|----------------------|------------------------------------------------------------------------------------------------|\n| description          | Êìç‰ΩúË°å‰∏∫ÁöÑËØ¶ÁªÜËØ¥Êòé„ÄÇ                                                                                     |\n| description.markdown | Â∫îÁî®Á®ãÂ∫èÁöÑÁÆÄÁü≠ÊèèËø∞„ÄÇËØ•ÊèèËø∞Â∞Ü‰ªéÂêç‰∏∫`endpointname.md`ÁöÑÊñá‰ª∂‰∏≠ËØªÂèñ„ÄÇ                                                      |\n| id                   | Áî®‰∫éÊ†áËØÜÊìç‰ΩúÁöÑÂîØ‰∏ÄÂ≠óÁ¨¶‰∏≤„ÄÇÂú®ÊâÄÊúâAPIÊìç‰Ωú‰∏≠ÂøÖÈ°ªÂîØ‰∏Ä„ÄÇ                                                                    |\n| tags                 | ÊØè‰∏™APIÊìç‰ΩúÁöÑÊ†áÁ≠æÂàóË°®Ôºå‰ª•ÈÄóÂè∑ÂàÜÈöî„ÄÇ                                                                            |\n| summary              | ËØ•Êìç‰ΩúÁöÑÁÆÄÁü≠ÊëòË¶Å„ÄÇ                                                                                      |\n| accept               | API ÂèØ‰ª•‰ΩøÁî®ÁöÑ MIME Á±ªÂûãÂàóË°®„ÄÇ ËØ∑Ê≥®ÊÑèÔºåAccept ‰ªÖÂΩ±ÂìçÂÖ∑ÊúâËØ∑Ê±ÇÊ≠£ÊñáÁöÑÊìç‰ΩúÔºå‰æãÂ¶Ç POST„ÄÅPUT Âíå PATCH„ÄÇ ÂÄºÂøÖÈ°ªÂ¶Ç‚Äú[MimeÁ±ªÂûã](#mimeÁ±ªÂûã)‚Äù‰∏≠ÊâÄËø∞„ÄÇ  |\n| produce              | APIÂèØ‰ª•ÁîüÊàêÁöÑMIMEÁ±ªÂûãÁöÑÂàóË°®„ÄÇÂÄºÂøÖÈ°ªÂ¶Ç‚Äú[MimeÁ±ªÂûã](#mimeÁ±ªÂûã)‚Äù‰∏≠ÊâÄËø∞„ÄÇ                                                  |\n| param                | Áî®Á©∫Ê†ºÂàÜÈöîÁöÑÂèÇÊï∞„ÄÇ`param name`,`param type`,`data type`,`is mandatory?`,`comment` `attribute(optional)` |\n| security             | ÊØè‰∏™APIÊìç‰ΩúÁöÑ[ÂÆâÂÖ®ÊÄß](#ÂÆâÂÖ®ÊÄß)„ÄÇ                                                                           |\n| success              | ‰ª•Á©∫Ê†ºÂàÜÈöîÁöÑÊàêÂäüÂìçÂ∫î„ÄÇ`return code`,`{param type}`,`data type`,`comment`                                  |\n| failure              | ‰ª•Á©∫Ê†ºÂàÜÈöîÁöÑÊïÖÈöúÂìçÂ∫î„ÄÇ`return code`,`{param type}`,`data type`,`comment`                                  |\n| response             | ‰∏ésuccess„ÄÅfailure‰ΩúÁî®Áõ∏Âêå                                                                           |\n| header               | ‰ª•Á©∫Ê†ºÂàÜÈöîÁöÑÂ§¥Â≠óÊÆµ„ÄÇ `return code`,`{param type}`,`data type`,`comment`                                  |\n| router               | ‰ª•Á©∫Ê†ºÂàÜÈöîÁöÑË∑ØÂæÑÂÆö‰πâ„ÄÇ `path`,`[httpMethod]`                                                              |\n| deprecatedrouter     | ‰∏érouterÁõ∏ÂêåÔºå‰ΩÜÊòØÊòØdeprecatedÁöÑ„ÄÇ                                                                      |\n| x-name               | Êâ©Â±ïÂ≠óÊÆµÂøÖÈ°ª‰ª•`x-`ÂºÄÂ§¥ÔºåÂπ∂‰∏îÂè™ËÉΩ‰ΩøÁî®jsonÂÄº„ÄÇ                                                                     |\n| deprecated           | Â∞ÜÂΩìÂâçAPIÊìç‰ΩúÁöÑÊâÄÊúâË∑ØÂæÑËÆæÁΩÆ‰∏∫deprecated                                                                     |\n\n## MimeÁ±ªÂûã\n\n`swag` Êé•ÂèóÊâÄÊúâÊ†ºÂºèÊ≠£Á°ÆÁöÑMIMEÁ±ªÂûã, Âç≥‰ΩøÂåπÈÖç `*/*`„ÄÇÈô§Ê≠§‰πãÂ§ñÔºå`swag`ËøòÊé•ÂèóÊüê‰∫õMIMEÁ±ªÂûãÁöÑÂà´ÂêçÔºåÂ¶Ç‰∏ãÊâÄÁ§∫Ôºö\n\n| Alias                 | MIME Type                         |\n| --------------------- | --------------------------------- |\n| json                  | application/json                  |\n| xml                   | text/xml                          |\n| plain                 | text/plain                        |\n| html                  | text/html                         |\n| mpfd                  | multipart/form-data               |\n| x-www-form-urlencoded | application/x-www-form-urlencoded |\n| json-api              | application/vnd.api+json          |\n| json-stream           | application/x-json-stream         |\n| octet-stream          | application/octet-stream          |\n| png                   | image/png                         |\n| jpeg                  | image/jpeg                        |\n| gif                   | image/gif                         |\n\n## ÂèÇÊï∞Á±ªÂûã\n\n- query\n- path\n- header\n- body\n- formData\n\n## Êï∞ÊçÆÁ±ªÂûã\n\n- string (string)\n- integer (int, uint, uint32, uint64)\n- number (float32)\n- boolean (bool)\n- user defined struct\n\n## ÂÆâÂÖ®ÊÄß\n\n| Ê≥®Èáä                                   | ÊèèËø∞                                                                                          | ÂèÇÊï∞                              | Á§∫‰æã                                                         |\n| -------------------------------------- | --------------------------------------------------------------------------------------------- | --------------------------------- | ------------------------------------------------------------ |\n| securitydefinitions.basic              | [Basic](https://swagger.io/docs/specification/2-0/authentication/basic-authentication/) auth. |                                   | // @securityDefinitions.basic BasicAuth                      |\n| securitydefinitions.apikey             | [API key](https://swagger.io/docs/specification/2-0/authentication/api-keys/) auth.           | in, name                          | // @securityDefinitions.apikey ApiKeyAuth                    |\n| securitydefinitions.oauth2.application | [OAuth2 application](https://swagger.io/docs/specification/authentication/oauth2/) auth.      | tokenUrl, scope                   | // @securitydefinitions.oauth2.application OAuth2Application |\n| securitydefinitions.oauth2.implicit    | [OAuth2 implicit](https://swagger.io/docs/specification/authentication/oauth2/) auth.         | authorizationUrl, scope           | // @securitydefinitions.oauth2.implicit OAuth2Implicit       |\n| securitydefinitions.oauth2.password    | [OAuth2 password](https://swagger.io/docs/specification/authentication/oauth2/) auth.         | tokenUrl, scope                   | // @securitydefinitions.oauth2.password OAuth2Password       |\n| securitydefinitions.oauth2.accessCode  | [OAuth2 access code](https://swagger.io/docs/specification/authentication/oauth2/) auth.      | tokenUrl, authorizationUrl, scope | // @securitydefinitions.oauth2.accessCode OAuth2AccessCode   |\n\n| ÂèÇÊï∞Ê≥®Èáä         | Á§∫‰æã                                                     |\n| ---------------- | -------------------------------------------------------- |\n| in               | // @in header                                            |\n| name             | // @name Authorization                                   |\n| tokenUrl         | // @tokenUrl https://example.com/oauth/token             |\n| authorizationurl | // @authorizationurl https://example.com/oauth/authorize |\n| scope.hoge       | // @scope.write Grants write access                      |\n\n## Â±ûÊÄß\n\n```go\n// @Param   enumstring  query     string     false  \"string enums\"       Enums(A, B, C)\n// @Param   enumint     query     int        false  \"int enums\"          Enums(1, 2, 3)\n// @Param   enumnumber  query     number     false  \"int enums\"          Enums(1.1, 1.2, 1.3)\n// @Param   string      query     string     false  \"string valid\"       minlength(5)  maxlength(10)\n// @Param   int         query     int        false  \"int valid\"          minimum(1)    maximum(10)\n// @Param   default     query     string     false  \"string default\"     default(A)\n// @Param   collection  query     []string   false  \"string collection\"  collectionFormat(multi)\n// @Param   extensions  query     []string   false  \"string collection\"  extensions(x-example=test,x-nullable)\n```\n\n‰πüÈÄÇÁî®‰∫éÁªìÊûÑ‰ΩìÂ≠óÊÆµÔºö\n\n```go\ntype Foo struct {\n    Bar string `minLength:\"4\" maxLength:\"16\"`\n    Baz int `minimum:\"10\" maximum:\"20\" default:\"15\"`\n    Qux []string `enums:\"foo,bar,baz\"`\n}\n```\n\n### ÂΩìÂâçÂèØÁî®ÁöÑ\n\n| Â≠óÊÆµÂêç           | Á±ªÂûã      | ÊèèËø∞                                                                                                                                                                                                                                                                                                                                                                  |\n| ---------------- | --------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| default          | *         | Â£∞ÊòéÂ¶ÇÊûúÊú™Êèê‰æõ‰ªª‰ΩïÂèÇÊï∞ÔºåÂàôÊúçÂä°Âô®Â∞Ü‰ΩøÁî®ÁöÑÈªòËÆ§ÂèÇÊï∞ÂÄºÔºå‰æãÂ¶ÇÔºåÂ¶ÇÊûúËØ∑Ê±Ç‰∏≠ÁöÑÂÆ¢Êà∑Á´ØÊú™Êèê‰æõËØ•ÂèÇÊï∞ÔºåÂàôÁî®‰∫éÊéßÂà∂ÊØèÈ°µÁªìÊûúÊï∞ÁöÑ‚ÄúËÆ°Êï∞‚ÄùÂèØËÉΩÈªòËÆ§‰∏∫100„ÄÇ ÔºàÊ≥®ÊÑèÔºö‚Äúdefault‚ÄùÂØπ‰∫éÂøÖÈúÄÁöÑÂèÇÊï∞Ê≤°ÊúâÊÑè‰πâÔºâ„ÄÇÂèÇÁúã https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2„ÄÇ ‰∏éJSONÊ®°Âºè‰∏çÂêåÔºåÊ≠§ÂÄºÂä°ÂøÖÁ¨¶ÂêàÊ≠§ÂèÇÊï∞ÁöÑÂÆö‰πâ[Á±ªÂûã](#parameterType)„ÄÇ                                  |\n| maximum          | `number`  | ÂèÇÁúã https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.2.                                                                                                                                                                                                                                                                                   |\n| minimum          | `number`  | ÂèÇÁúã https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.3.                                                                                                                                                                                                                                                                                   |\n| maxLength        | `integer` | ÂèÇÁúã https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.1.                                                                                                                                                                                                                                                                                   |\n| minLength        | `integer` | ÂèÇÁúã https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.2.                                                                                                                                                                                                                                                                                   |\n| enums            | [\\*]      | ÂèÇÁúã https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1.                                                                                                                                                                                                                                                                                   |\n| format           | `string`  | ‰∏äÈù¢ÊèêÂà∞ÁöÑ[Á±ªÂûã](#parameterType)ÁöÑÊâ©Â±ïÊ†ºÂºè„ÄÇÊúâÂÖ≥Êõ¥Â§öËØ¶ÁªÜ‰ø°ÊÅØÔºåËØ∑ÂèÇËßÅ[Êï∞ÊçÆÁ±ªÂûãÊ†ºÂºè](https://swagger.io/specification/v2/#dataTypeFormat)„ÄÇ                                                                                                                                                                                                                             |\n| collectionFormat | `string`  | ÊåáÂÆöqueryÊï∞ÁªÑÂèÇÊï∞ÁöÑÊ†ºÂºè„ÄÇ ÂèØËÉΩÁöÑÂÄº‰∏∫Ôºö <ul><li>`csv` - ÈÄóÂè∑ÂàÜÈöîÂÄº `foo,bar`. <li>`ssv` - Á©∫Ê†ºÂàÜÈöîÂÄº `foo bar`. <li>`tsv` - Âà∂Ë°®Á¨¶ÂàÜÈöîÂÄº `foo\\tbar`. <li>`pipes` - ÁÆ°ÈÅìÁ¨¶ÂàÜÈöîÂÄº <code>foo&#124;bar</code>. <li>`multi` - ÂØπÂ∫î‰∫éÂ§ö‰∏™ÂèÇÊï∞ÂÆû‰æãÔºåËÄå‰∏çÊòØÂçï‰∏™ÂÆû‰æã `foo=barÔºÜfoo=baz` ÁöÑÂ§ö‰∏™ÂÄº„ÄÇËøô‰ªÖÂØπ‚Äú`query`‚ÄùÊàñ‚Äú`formData`‚Äù‰∏≠ÁöÑÂèÇÊï∞ÊúâÊïà„ÄÇ </ul> ÈªòËÆ§ÂÄºÊòØ `csv`„ÄÇ |\n\n### Ëøõ‰∏ÄÊ≠•ÁöÑ\n\n| Â≠óÊÆµÂêç      |   Á±ªÂûã    | ÊèèËø∞                                                                               |\n| ----------- | :-------: | ---------------------------------------------------------------------------------- |\n| multipleOf  | `number`  | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.1. |\n| pattern     | `string`  | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.3. |\n| maxItems    | `integer` | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.2. |\n| minItems    | `integer` | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.3. |\n| uniqueItems | `boolean` | See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.4. |\n\n## Ê†∑‰æã\n\n### Â§öË°åÁöÑÊèèËø∞\n\nÂèØ‰ª•Âú®Â∏∏ËßÑapiÊèèËø∞ÊàñË∑ØÁî±ÂÆö‰πâ‰∏≠Ê∑ªÂä†Ë∑®Ë∂äÂ§öË°åÁöÑÊèèËø∞ÔºåÂ¶Ç‰∏ãÊâÄÁ§∫Ôºö\n\n```go\n// @description This is the first line\n// @description This is the second line\n// @description And so forth.\n```\n\n### Áî®Êà∑Ëá™ÂÆö‰πâÁöÑÂÖ∑ÊúâÊï∞ÁªÑÁ±ªÂûãÁöÑÁªìÊûÑ\n\n```go\n// @Success 200 {array} model.Account <-- This is a user defined struct.\n```\n\n```go\npackage model\n\ntype Account struct {\n    ID   int    `json:\"id\" example:\"1\"`\n    Name string `json:\"name\" example:\"account name\"`\n}\n```\n\n### ÂìçÂ∫îÂØπË±°‰∏≠ÁöÑÊ®°ÂûãÁªÑÂêà\n\n```go\n// JSONResultÁöÑdataÂ≠óÊÆµÁ±ªÂûãÂ∞ÜË¢´proto.OrderÁ±ªÂûãÊõøÊç¢\n@success 200 {object} jsonresult.JSONResult{data=proto.Order} \"desc\"\n```\n\n```go\ntype JSONResult struct {\n    Code    int          `json:\"code\" `\n    Message string       `json:\"message\"`\n    Data    interface{}  `json:\"data\"`\n}\n\ntype Order struct { //in `proto` package\n    ...\n}\n```\n\n- ËøòÊîØÊåÅÂØπË±°Êï∞ÁªÑÂíåÂéüÂßãÁ±ªÂûã‰Ωú‰∏∫ÂµåÂ•óÂìçÂ∫î\n\n```go\n@success 200 {object} jsonresult.JSONResult{data=[]proto.Order} \"desc\"\n@success 200 {object} jsonresult.JSONResult{data=string} \"desc\"\n@success 200 {object} jsonresult.JSONResult{data=[]string} \"desc\"\n```\n\n- ÊõøÊç¢Â§ö‰∏™Â≠óÊÆµÁöÑÁ±ªÂûã„ÄÇÂ¶ÇÊûúÊüêÂ≠óÊÆµ‰∏çÂ≠òÂú®ÔºåÂ∞ÜÊ∑ªÂä†ËØ•Â≠óÊÆµ„ÄÇ\n\n```go\n@success 200 {object} jsonresult.JSONResult{data1=string,data2=[]string,data3=proto.Order,data4=[]proto.Order} \"desc\"\n```\n\n### Âú®ÂìçÂ∫î‰∏≠Â¢ûÂä†Â§¥Â≠óÊÆµ\n\n```go\n// @Success      200              {string}  string    \"ok\"\n// @failure      400              {string}  string    \"error\"\n// @response     default          {string}  string    \"other error\"\n// @Header       200              {string}  Location  \"/entity/1\"\n// @Header       200,400,default  {string}  Token     \"token\"\n// @Header       all              {string}  Token2    \"token2\"\n```\n\n### ‰ΩøÁî®Â§öË∑ØÂæÑÂèÇÊï∞\n\n```go\n/// ...\n// @Param  group_id    path  int  true  \"Group ID\"\n// @Param  account_id  path  int  true  \"Account ID\"\n// ...\n// @Router /examples/groups/{group_id}/accounts/{account_id} [get]\n```\n\n### ÁªìÊûÑ‰ΩìÁöÑÁ§∫‰æãÂÄº\n\n```go\ntype Account struct {\n    ID   int    `json:\"id\" example:\"1\"`\n    Name string `json:\"name\" example:\"account name\"`\n    PhotoUrls []string `json:\"photo_urls\" example:\"http://test/image/1.jpg,http://test/image/2.jpg\"`\n}\n```\n\n### ÁªìÊûÑ‰ΩìÊèèËø∞\n\n```go\ntype Account struct {\n    // ID this is userid\n    ID   int    `json:\"id\"`\n    Name string `json:\"name\"` // This is Name\n}\n```\n\n### ‰ΩøÁî®`swaggertype`Ê†áÁ≠æÊõ¥ÊîπÂ≠óÊÆµÁ±ªÂûã\n\n[#201](https://github.com/swaggo/swag/issues/201#issuecomment-475479409)\n\n```go\ntype TimestampTime struct {\n    time.Time\n}\n\n///ÂÆûÁé∞encoding.JSON.MarshalerÊé•Âè£\nfunc (t *TimestampTime) MarshalJSON() ([]byte, error) {\n    bin := make([]byte, 16)\n    bin = strconv.AppendInt(bin[:0], t.Time.Unix(), 10)\n    return bin, nil\n}\n\n///ÂÆûÁé∞encoding.JSON.UnmarshalerÊé•Âè£\nfunc (t *TimestampTime) UnmarshalJSON(bin []byte) error {\n    v, err := strconv.ParseInt(string(bin), 10, 64)\n    if err != nil {\n        return err\n    }\n    t.Time = time.Unix(v, 0)\n    return nil\n}\n///\n\ntype Account struct {\n    // ‰ΩøÁî®`swaggertype`Ê†áÁ≠æÂ∞ÜÂà´ÂêçÁ±ªÂûãÊõ¥Êîπ‰∏∫ÂÜÖÁΩÆÁ±ªÂûãinteger\n    ID     sql.NullInt64 `json:\"id\" swaggertype:\"integer\"`\n\n    // ‰ΩøÁî®`swaggertype`Ê†áÁ≠æÊõ¥ÊîπstructÁ±ªÂûã‰∏∫ÂÜÖÁΩÆÁ±ªÂûãinteger\n    RegisterTime TimestampTime `json:\"register_time\" swaggertype:\"primitive,integer\"`\n\n    // Array types can be overridden using \"array,<prim_type>\" format\n    Coeffs []big.Float `json:\"coeffs\" swaggertype:\"array,number\"`\n}\n```\n\n[#379](https://github.com/swaggo/swag/issues/379)\n\n```go\ntype CerticateKeyPair struct {\n    Crt []byte `json:\"crt\" swaggertype:\"string\" format:\"base64\" example:\"U3dhZ2dlciByb2Nrcw==\"`\n    Key []byte `json:\"key\" swaggertype:\"string\" format:\"base64\" example:\"U3dhZ2dlciByb2Nrcw==\"`\n}\n```\n\nÁîüÊàêÁöÑswaggerÊñáÊ°£Â¶Ç‰∏ãÔºö\n\n```go\n\"api.MyBinding\": {\n  \"type\":\"object\",\n  \"properties\":{\n    \"crt\":{\n      \"type\":\"string\",\n      \"format\":\"base64\",\n      \"example\":\"U3dhZ2dlciByb2Nrcw==\"\n    },\n    \"key\":{\n      \"type\":\"string\",\n      \"format\":\"base64\",\n      \"example\":\"U3dhZ2dlciByb2Nrcw==\"\n    }\n  }\n}\n```\n\n### ‰ΩøÁî®`swaggerignore`Ê†áÁ≠æÊéíÈô§Â≠óÊÆµ\n\n```go\ntype Account struct {\n    ID   string    `json:\"id\"`\n    Name string     `json:\"name\"`\n    Ignored int     `swaggerignore:\"true\"`\n}\n```\n\n### Â∞ÜÊâ©Â±ï‰ø°ÊÅØÊ∑ªÂä†Âà∞ÁªìÊûÑÂ≠óÊÆµ\n\n```go\ntype Account struct {\n    ID   string    `json:\"id\"   extensions:\"x-nullable,x-abc=def,!x-omitempty\"` // Êâ©Â±ïÂ≠óÊÆµÂøÖÈ°ª‰ª•\"x-\"ÂºÄÂ§¥\n}\n```\n\nÁîüÊàêswaggerÊñáÊ°£ÔºåÂ¶Ç‰∏ãÊâÄÁ§∫Ôºö\n\n```go\n\"Account\": {\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"x-nullable\": true,\n            \"x-abc\": \"def\",\n            \"x-omitempty\": false\n        }\n    }\n}\n```\n\n### ÂØπÂ±ïÁ§∫ÁöÑÊ®°ÂûãÈáçÂëΩÂêç\n\n```go\ntype Resp struct {\n    Code int\n}//@name Response\n```\n\n### Â¶Ç‰Ωï‰ΩøÁî®ÂÆâÂÖ®ÊÄßÊ≥®Èáä\n\nÈÄöÁî®API‰ø°ÊÅØ„ÄÇ\n\n```go\n// @securityDefinitions.basic BasicAuth\n\n// @securitydefinitions.oauth2.application OAuth2Application\n// @tokenUrl https://example.com/oauth/token\n// @scope.write Grants write access\n// @scope.admin Grants read and write access to administrative information\n```\n\nÊØè‰∏™APIÊìç‰Ωú„ÄÇ\n\n```go\n// @Security ApiKeyAuth\n```\n\n‰ΩøÁî®ANDÊù°‰ª∂„ÄÇ\n\n```go\n// @Security ApiKeyAuth && OAuth2Application[write, admin]\n```\n\n## È°πÁõÆÁõ∏ÂÖ≥\n\nThis project was inspired by [yvasiyarov/swagger](https://github.com/yvasiyarov/swagger) but we simplified the usage and added support a variety of [web frameworks](#supported-web-frameworks). Gopher image source is [tenntenn/gopher-stickers](https://github.com/tenntenn/gopher-stickers). It has licenses [creative commons licensing](http://creativecommons.org/licenses/by/3.0/deed.en).\n\n## Ë¥°ÁåÆËÄÖ\n\nThis project exists thanks to all the people who contribute. [[Contribute](CONTRIBUTING.md)].\n<a href=\"https://github.com/swaggo/swag/graphs/contributors\"><img src=\"https://opencollective.com/swag/contributors.svg?width=890&button=false\" /></a>\n\n## ÊîØÊåÅËÄÖ\n\nThank you to all our backers! üôè [[Become a backer](https://opencollective.com/swag#backer)]\n\n<a href=\"https://opencollective.com/swag#backers\" target=\"_blank\"><img src=\"https://opencollective.com/swag/backers.svg?width=890\"></a>\n\n## ËµûÂä©ÂïÜ\n\nSupport this project by becoming a sponsor. Your logo will show up here with a link to your website. [[Become a sponsor](https://opencollective.com/swag#sponsor)]\n\n<a href=\"https://opencollective.com/swag/sponsor/0/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/0/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/1/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/1/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/2/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/2/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/3/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/3/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/4/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/4/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/5/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/5/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/6/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/6/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/7/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/7/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/8/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/8/avatar.svg\"></a>\n<a href=\"https://opencollective.com/swag/sponsor/9/website\" target=\"_blank\"><img src=\"https://opencollective.com/swag/sponsor/9/avatar.svg\"></a>\n\n## License\n\n[![FOSSA Status](https://app.fossa.io/api/projects/git%2Bgithub.com%2Fswaggo%2Fswag.svg?type=large)](https://app.fossa.io/projects/git%2Bgithub.com%2Fswaggo%2Fswag?ref=badge_large)\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "const.go",
          "type": "blob",
          "size": 12.9755859375,
          "content": "package swag\n\nimport (\n\t\"go/ast\"\n\t\"go/token\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode/utf8\"\n)\n\n// ConstVariable a model to record a const variable\ntype ConstVariable struct {\n\tName    *ast.Ident\n\tType    ast.Expr\n\tValue   interface{}\n\tComment *ast.CommentGroup\n\tFile    *ast.File\n\tPkg     *PackageDefinitions\n}\n\nvar escapedChars = map[uint8]uint8{\n\t'n':  '\\n',\n\t'r':  '\\r',\n\t't':  '\\t',\n\t'v':  '\\v',\n\t'\\\\': '\\\\',\n\t'\"':  '\"',\n}\n\n// EvaluateEscapedChar parse escaped character\nfunc EvaluateEscapedChar(text string) rune {\n\tif len(text) == 1 {\n\t\treturn rune(text[0])\n\t}\n\n\tif len(text) == 2 && text[0] == '\\\\' {\n\t\treturn rune(escapedChars[text[1]])\n\t}\n\n\tif len(text) == 6 && text[0:2] == \"\\\\u\" {\n\t\tn, err := strconv.ParseInt(text[2:], 16, 32)\n\t\tif err == nil {\n\t\t\treturn rune(n)\n\t\t}\n\t}\n\n\treturn 0\n}\n\n// EvaluateEscapedString parse escaped characters in string\nfunc EvaluateEscapedString(text string) string {\n\tif !strings.ContainsRune(text, '\\\\') {\n\t\treturn text\n\t}\n\tresult := make([]byte, 0, len(text))\n\tfor i := 0; i < len(text); i++ {\n\t\tif text[i] == '\\\\' {\n\t\t\ti++\n\t\t\tif text[i] == 'u' {\n\t\t\t\ti++\n\t\t\t\tchar, err := strconv.ParseInt(text[i:i+4], 16, 32)\n\t\t\t\tif err == nil {\n\t\t\t\t\tresult = utf8.AppendRune(result, rune(char))\n\t\t\t\t}\n\t\t\t\ti += 3\n\t\t\t} else if c, ok := escapedChars[text[i]]; ok {\n\t\t\t\tresult = append(result, c)\n\t\t\t}\n\t\t} else {\n\t\t\tresult = append(result, text[i])\n\t\t}\n\t}\n\treturn string(result)\n}\n\n// EvaluateDataConversion evaluate the type a explicit type conversion\nfunc EvaluateDataConversion(x interface{}, typeName string) interface{} {\n\tswitch value := x.(type) {\n\tcase int:\n\t\tswitch typeName {\n\t\tcase \"int\":\n\t\t\treturn int(value)\n\t\tcase \"byte\":\n\t\t\treturn byte(value)\n\t\tcase \"int8\":\n\t\t\treturn int8(value)\n\t\tcase \"int16\":\n\t\t\treturn int16(value)\n\t\tcase \"int32\":\n\t\t\treturn int32(value)\n\t\tcase \"int64\":\n\t\t\treturn int64(value)\n\t\tcase \"uint\":\n\t\t\treturn uint(value)\n\t\tcase \"uint8\":\n\t\t\treturn uint8(value)\n\t\tcase \"uint16\":\n\t\t\treturn uint16(value)\n\t\tcase \"uint32\":\n\t\t\treturn uint32(value)\n\t\tcase \"uint64\":\n\t\t\treturn uint64(value)\n\t\tcase \"rune\":\n\t\t\treturn rune(value)\n\t\t}\n\tcase uint:\n\t\tswitch typeName {\n\t\tcase \"int\":\n\t\t\treturn int(value)\n\t\tcase \"byte\":\n\t\t\treturn byte(value)\n\t\tcase \"int8\":\n\t\t\treturn int8(value)\n\t\tcase \"int16\":\n\t\t\treturn int16(value)\n\t\tcase \"int32\":\n\t\t\treturn int32(value)\n\t\tcase \"int64\":\n\t\t\treturn int64(value)\n\t\tcase \"uint\":\n\t\t\treturn uint(value)\n\t\tcase \"uint8\":\n\t\t\treturn uint8(value)\n\t\tcase \"uint16\":\n\t\t\treturn uint16(value)\n\t\tcase \"uint32\":\n\t\t\treturn uint32(value)\n\t\tcase \"uint64\":\n\t\t\treturn uint64(value)\n\t\tcase \"rune\":\n\t\t\treturn rune(value)\n\t\t}\n\tcase int8:\n\t\tswitch typeName {\n\t\tcase \"int\":\n\t\t\treturn int(value)\n\t\tcase \"byte\":\n\t\t\treturn byte(value)\n\t\tcase \"int8\":\n\t\t\treturn int8(value)\n\t\tcase \"int16\":\n\t\t\treturn int16(value)\n\t\tcase \"int32\":\n\t\t\treturn int32(value)\n\t\tcase \"int64\":\n\t\t\treturn int64(value)\n\t\tcase \"uint\":\n\t\t\treturn uint(value)\n\t\tcase \"uint8\":\n\t\t\treturn uint8(value)\n\t\tcase \"uint16\":\n\t\t\treturn uint16(value)\n\t\tcase \"uint32\":\n\t\t\treturn uint32(value)\n\t\tcase \"uint64\":\n\t\t\treturn uint64(value)\n\t\tcase \"rune\":\n\t\t\treturn rune(value)\n\t\t}\n\tcase uint8:\n\t\tswitch typeName {\n\t\tcase \"int\":\n\t\t\treturn int(value)\n\t\tcase \"byte\":\n\t\t\treturn byte(value)\n\t\tcase \"int8\":\n\t\t\treturn int8(value)\n\t\tcase \"int16\":\n\t\t\treturn int16(value)\n\t\tcase \"int32\":\n\t\t\treturn int32(value)\n\t\tcase \"int64\":\n\t\t\treturn int64(value)\n\t\tcase \"uint\":\n\t\t\treturn uint(value)\n\t\tcase \"uint8\":\n\t\t\treturn uint8(value)\n\t\tcase \"uint16\":\n\t\t\treturn uint16(value)\n\t\tcase \"uint32\":\n\t\t\treturn uint32(value)\n\t\tcase \"uint64\":\n\t\t\treturn uint64(value)\n\t\tcase \"rune\":\n\t\t\treturn rune(value)\n\t\t}\n\tcase int16:\n\t\tswitch typeName {\n\t\tcase \"int\":\n\t\t\treturn int(value)\n\t\tcase \"byte\":\n\t\t\treturn byte(value)\n\t\tcase \"int8\":\n\t\t\treturn int8(value)\n\t\tcase \"int16\":\n\t\t\treturn int16(value)\n\t\tcase \"int32\":\n\t\t\treturn int32(value)\n\t\tcase \"int64\":\n\t\t\treturn int64(value)\n\t\tcase \"uint\":\n\t\t\treturn uint(value)\n\t\tcase \"uint8\":\n\t\t\treturn uint8(value)\n\t\tcase \"uint16\":\n\t\t\treturn uint16(value)\n\t\tcase \"uint32\":\n\t\t\treturn uint32(value)\n\t\tcase \"uint64\":\n\t\t\treturn uint64(value)\n\t\tcase \"rune\":\n\t\t\treturn rune(value)\n\t\t}\n\tcase uint16:\n\t\tswitch typeName {\n\t\tcase \"int\":\n\t\t\treturn int(value)\n\t\tcase \"byte\":\n\t\t\treturn byte(value)\n\t\tcase \"int8\":\n\t\t\treturn int8(value)\n\t\tcase \"int16\":\n\t\t\treturn int16(value)\n\t\tcase \"int32\":\n\t\t\treturn int32(value)\n\t\tcase \"int64\":\n\t\t\treturn int64(value)\n\t\tcase \"uint\":\n\t\t\treturn uint(value)\n\t\tcase \"uint8\":\n\t\t\treturn uint8(value)\n\t\tcase \"uint16\":\n\t\t\treturn uint16(value)\n\t\tcase \"uint32\":\n\t\t\treturn uint32(value)\n\t\tcase \"uint64\":\n\t\t\treturn uint64(value)\n\t\tcase \"rune\":\n\t\t\treturn rune(value)\n\t\t}\n\tcase int32:\n\t\tswitch typeName {\n\t\tcase \"int\":\n\t\t\treturn int(value)\n\t\tcase \"byte\":\n\t\t\treturn byte(value)\n\t\tcase \"int8\":\n\t\t\treturn int8(value)\n\t\tcase \"int16\":\n\t\t\treturn int16(value)\n\t\tcase \"int32\":\n\t\t\treturn int32(value)\n\t\tcase \"int64\":\n\t\t\treturn int64(value)\n\t\tcase \"uint\":\n\t\t\treturn uint(value)\n\t\tcase \"uint8\":\n\t\t\treturn uint8(value)\n\t\tcase \"uint16\":\n\t\t\treturn uint16(value)\n\t\tcase \"uint32\":\n\t\t\treturn uint32(value)\n\t\tcase \"uint64\":\n\t\t\treturn uint64(value)\n\t\tcase \"rune\":\n\t\t\treturn rune(value)\n\t\tcase \"string\":\n\t\t\treturn string(value)\n\t\t}\n\tcase uint32:\n\t\tswitch typeName {\n\t\tcase \"int\":\n\t\t\treturn int(value)\n\t\tcase \"byte\":\n\t\t\treturn byte(value)\n\t\tcase \"int8\":\n\t\t\treturn int8(value)\n\t\tcase \"int16\":\n\t\t\treturn int16(value)\n\t\tcase \"int32\":\n\t\t\treturn int32(value)\n\t\tcase \"int64\":\n\t\t\treturn int64(value)\n\t\tcase \"uint\":\n\t\t\treturn uint(value)\n\t\tcase \"uint8\":\n\t\t\treturn uint8(value)\n\t\tcase \"uint16\":\n\t\t\treturn uint16(value)\n\t\tcase \"uint32\":\n\t\t\treturn uint32(value)\n\t\tcase \"uint64\":\n\t\t\treturn uint64(value)\n\t\tcase \"rune\":\n\t\t\treturn rune(value)\n\t\t}\n\tcase int64:\n\t\tswitch typeName {\n\t\tcase \"int\":\n\t\t\treturn int(value)\n\t\tcase \"byte\":\n\t\t\treturn byte(value)\n\t\tcase \"int8\":\n\t\t\treturn int8(value)\n\t\tcase \"int16\":\n\t\t\treturn int16(value)\n\t\tcase \"int32\":\n\t\t\treturn int32(value)\n\t\tcase \"int64\":\n\t\t\treturn int64(value)\n\t\tcase \"uint\":\n\t\t\treturn uint(value)\n\t\tcase \"uint8\":\n\t\t\treturn uint8(value)\n\t\tcase \"uint16\":\n\t\t\treturn uint16(value)\n\t\tcase \"uint32\":\n\t\t\treturn uint32(value)\n\t\tcase \"uint64\":\n\t\t\treturn uint64(value)\n\t\tcase \"rune\":\n\t\t\treturn rune(value)\n\t\t}\n\tcase uint64:\n\t\tswitch typeName {\n\t\tcase \"int\":\n\t\t\treturn int(value)\n\t\tcase \"byte\":\n\t\t\treturn byte(value)\n\t\tcase \"int8\":\n\t\t\treturn int8(value)\n\t\tcase \"int16\":\n\t\t\treturn int16(value)\n\t\tcase \"int32\":\n\t\t\treturn int32(value)\n\t\tcase \"int64\":\n\t\t\treturn int64(value)\n\t\tcase \"uint\":\n\t\t\treturn uint(value)\n\t\tcase \"uint8\":\n\t\t\treturn uint8(value)\n\t\tcase \"uint16\":\n\t\t\treturn uint16(value)\n\t\tcase \"uint32\":\n\t\t\treturn uint32(value)\n\t\tcase \"uint64\":\n\t\t\treturn uint64(value)\n\t\tcase \"rune\":\n\t\t\treturn rune(value)\n\t\t}\n\tcase string:\n\t\tswitch typeName {\n\t\tcase \"string\":\n\t\t\treturn value\n\t\t}\n\t}\n\treturn nil\n}\n\n// EvaluateUnary evaluate the type and value of a unary expression\nfunc EvaluateUnary(x interface{}, operator token.Token, xtype ast.Expr) (interface{}, ast.Expr) {\n\tswitch operator {\n\tcase token.SUB:\n\t\tswitch value := x.(type) {\n\t\tcase int:\n\t\t\treturn -value, xtype\n\t\tcase int8:\n\t\t\treturn -value, xtype\n\t\tcase int16:\n\t\t\treturn -value, xtype\n\t\tcase int32:\n\t\t\treturn -value, xtype\n\t\tcase int64:\n\t\t\treturn -value, xtype\n\t\t}\n\tcase token.XOR:\n\t\tswitch value := x.(type) {\n\t\tcase int:\n\t\t\treturn ^value, xtype\n\t\tcase int8:\n\t\t\treturn ^value, xtype\n\t\tcase int16:\n\t\t\treturn ^value, xtype\n\t\tcase int32:\n\t\t\treturn ^value, xtype\n\t\tcase int64:\n\t\t\treturn ^value, xtype\n\t\tcase uint:\n\t\t\treturn ^value, xtype\n\t\tcase uint8:\n\t\t\treturn ^value, xtype\n\t\tcase uint16:\n\t\t\treturn ^value, xtype\n\t\tcase uint32:\n\t\t\treturn ^value, xtype\n\t\tcase uint64:\n\t\t\treturn ^value, xtype\n\t\t}\n\t}\n\treturn nil, nil\n}\n\n// EvaluateBinary evaluate the type and value of a binary expression\nfunc EvaluateBinary(x, y interface{}, operator token.Token, xtype, ytype ast.Expr) (interface{}, ast.Expr) {\n\tif operator == token.SHR || operator == token.SHL {\n\t\tvar rightOperand uint64\n\t\tyValue := reflect.ValueOf(y)\n\t\tif yValue.CanUint() {\n\t\t\trightOperand = yValue.Uint()\n\t\t} else if yValue.CanInt() {\n\t\t\trightOperand = uint64(yValue.Int())\n\t\t}\n\n\t\tswitch operator {\n\t\tcase token.SHL:\n\t\t\tswitch xValue := x.(type) {\n\t\t\tcase int:\n\t\t\t\treturn xValue << rightOperand, xtype\n\t\t\tcase int8:\n\t\t\t\treturn xValue << rightOperand, xtype\n\t\t\tcase int16:\n\t\t\t\treturn xValue << rightOperand, xtype\n\t\t\tcase int32:\n\t\t\t\treturn xValue << rightOperand, xtype\n\t\t\tcase int64:\n\t\t\t\treturn xValue << rightOperand, xtype\n\t\t\tcase uint:\n\t\t\t\treturn xValue << rightOperand, xtype\n\t\t\tcase uint8:\n\t\t\t\treturn xValue << rightOperand, xtype\n\t\t\tcase uint16:\n\t\t\t\treturn xValue << rightOperand, xtype\n\t\t\tcase uint32:\n\t\t\t\treturn xValue << rightOperand, xtype\n\t\t\tcase uint64:\n\t\t\t\treturn xValue << rightOperand, xtype\n\t\t\t}\n\t\tcase token.SHR:\n\t\t\tswitch xValue := x.(type) {\n\t\t\tcase int:\n\t\t\t\treturn xValue >> rightOperand, xtype\n\t\t\tcase int8:\n\t\t\t\treturn xValue >> rightOperand, xtype\n\t\t\tcase int16:\n\t\t\t\treturn xValue >> rightOperand, xtype\n\t\t\tcase int32:\n\t\t\t\treturn xValue >> rightOperand, xtype\n\t\t\tcase int64:\n\t\t\t\treturn xValue >> rightOperand, xtype\n\t\t\tcase uint:\n\t\t\t\treturn xValue >> rightOperand, xtype\n\t\t\tcase uint8:\n\t\t\t\treturn xValue >> rightOperand, xtype\n\t\t\tcase uint16:\n\t\t\t\treturn xValue >> rightOperand, xtype\n\t\t\tcase uint32:\n\t\t\t\treturn xValue >> rightOperand, xtype\n\t\t\tcase uint64:\n\t\t\t\treturn xValue >> rightOperand, xtype\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\tevalType := xtype\n\tif evalType == nil {\n\t\tevalType = ytype\n\t}\n\n\txValue := reflect.ValueOf(x)\n\tyValue := reflect.ValueOf(y)\n\tif xValue.Kind() == reflect.String && yValue.Kind() == reflect.String {\n\t\treturn xValue.String() + yValue.String(), evalType\n\t}\n\n\tvar targetValue reflect.Value\n\tif xValue.Kind() != reflect.Int {\n\t\ttargetValue = reflect.New(xValue.Type()).Elem()\n\t} else {\n\t\ttargetValue = reflect.New(yValue.Type()).Elem()\n\t}\n\n\tswitch operator {\n\tcase token.ADD:\n\t\tif xValue.CanInt() && yValue.CanInt() {\n\t\t\ttargetValue.SetInt(xValue.Int() + yValue.Int())\n\t\t} else if xValue.CanUint() && yValue.CanUint() {\n\t\t\ttargetValue.SetUint(xValue.Uint() + yValue.Uint())\n\t\t} else if xValue.CanInt() && yValue.CanUint() {\n\t\t\ttargetValue.SetUint(uint64(xValue.Int()) + yValue.Uint())\n\t\t} else if xValue.CanUint() && yValue.CanInt() {\n\t\t\ttargetValue.SetUint(xValue.Uint() + uint64(yValue.Int()))\n\t\t}\n\tcase token.SUB:\n\t\tif xValue.CanInt() && yValue.CanInt() {\n\t\t\ttargetValue.SetInt(xValue.Int() - yValue.Int())\n\t\t} else if xValue.CanUint() && yValue.CanUint() {\n\t\t\ttargetValue.SetUint(xValue.Uint() - yValue.Uint())\n\t\t} else if xValue.CanInt() && yValue.CanUint() {\n\t\t\ttargetValue.SetUint(uint64(xValue.Int()) - yValue.Uint())\n\t\t} else if xValue.CanUint() && yValue.CanInt() {\n\t\t\ttargetValue.SetUint(xValue.Uint() - uint64(yValue.Int()))\n\t\t}\n\tcase token.MUL:\n\t\tif xValue.CanInt() && yValue.CanInt() {\n\t\t\ttargetValue.SetInt(xValue.Int() * yValue.Int())\n\t\t} else if xValue.CanUint() && yValue.CanUint() {\n\t\t\ttargetValue.SetUint(xValue.Uint() * yValue.Uint())\n\t\t} else if xValue.CanInt() && yValue.CanUint() {\n\t\t\ttargetValue.SetUint(uint64(xValue.Int()) * yValue.Uint())\n\t\t} else if xValue.CanUint() && yValue.CanInt() {\n\t\t\ttargetValue.SetUint(xValue.Uint() * uint64(yValue.Int()))\n\t\t}\n\tcase token.QUO:\n\t\tif xValue.CanInt() && yValue.CanInt() {\n\t\t\ttargetValue.SetInt(xValue.Int() / yValue.Int())\n\t\t} else if xValue.CanUint() && yValue.CanUint() {\n\t\t\ttargetValue.SetUint(xValue.Uint() / yValue.Uint())\n\t\t} else if xValue.CanInt() && yValue.CanUint() {\n\t\t\ttargetValue.SetUint(uint64(xValue.Int()) / yValue.Uint())\n\t\t} else if xValue.CanUint() && yValue.CanInt() {\n\t\t\ttargetValue.SetUint(xValue.Uint() / uint64(yValue.Int()))\n\t\t}\n\tcase token.REM:\n\t\tif xValue.CanInt() && yValue.CanInt() {\n\t\t\ttargetValue.SetInt(xValue.Int() % yValue.Int())\n\t\t} else if xValue.CanUint() && yValue.CanUint() {\n\t\t\ttargetValue.SetUint(xValue.Uint() % yValue.Uint())\n\t\t} else if xValue.CanInt() && yValue.CanUint() {\n\t\t\ttargetValue.SetUint(uint64(xValue.Int()) % yValue.Uint())\n\t\t} else if xValue.CanUint() && yValue.CanInt() {\n\t\t\ttargetValue.SetUint(xValue.Uint() % uint64(yValue.Int()))\n\t\t}\n\tcase token.AND:\n\t\tif xValue.CanInt() && yValue.CanInt() {\n\t\t\ttargetValue.SetInt(xValue.Int() & yValue.Int())\n\t\t} else if xValue.CanUint() && yValue.CanUint() {\n\t\t\ttargetValue.SetUint(xValue.Uint() & yValue.Uint())\n\t\t} else if xValue.CanInt() && yValue.CanUint() {\n\t\t\ttargetValue.SetUint(uint64(xValue.Int()) & yValue.Uint())\n\t\t} else if xValue.CanUint() && yValue.CanInt() {\n\t\t\ttargetValue.SetUint(xValue.Uint() & uint64(yValue.Int()))\n\t\t}\n\tcase token.OR:\n\t\tif xValue.CanInt() && yValue.CanInt() {\n\t\t\ttargetValue.SetInt(xValue.Int() | yValue.Int())\n\t\t} else if xValue.CanUint() && yValue.CanUint() {\n\t\t\ttargetValue.SetUint(xValue.Uint() | yValue.Uint())\n\t\t} else if xValue.CanInt() && yValue.CanUint() {\n\t\t\ttargetValue.SetUint(uint64(xValue.Int()) | yValue.Uint())\n\t\t} else if xValue.CanUint() && yValue.CanInt() {\n\t\t\ttargetValue.SetUint(xValue.Uint() | uint64(yValue.Int()))\n\t\t}\n\tcase token.XOR:\n\t\tif xValue.CanInt() && yValue.CanInt() {\n\t\t\ttargetValue.SetInt(xValue.Int() ^ yValue.Int())\n\t\t} else if xValue.CanUint() && yValue.CanUint() {\n\t\t\ttargetValue.SetUint(xValue.Uint() ^ yValue.Uint())\n\t\t} else if xValue.CanInt() && yValue.CanUint() {\n\t\t\ttargetValue.SetUint(uint64(xValue.Int()) ^ yValue.Uint())\n\t\t} else if xValue.CanUint() && yValue.CanInt() {\n\t\t\ttargetValue.SetUint(xValue.Uint() ^ uint64(yValue.Int()))\n\t\t}\n\t}\n\treturn targetValue.Interface(), evalType\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.1845703125,
          "content": "/*\nPackage swag converts Go annotations to Swagger Documentation 2.0.\nSee https://github.com/swaggo/swag for more information about swag.\n*/\npackage swag // import \"github.com/swaggo/swag\"\n"
        },
        {
          "name": "enums.go",
          "type": "blob",
          "size": 0.296875,
          "content": "package swag\n\nconst (\n\tenumVarNamesExtension     = \"x-enum-varnames\"\n\tenumCommentsExtension     = \"x-enum-comments\"\n\tenumDescriptionsExtension = \"x-enum-descriptions\"\n)\n\n// EnumValue a model to record an enum consts variable\ntype EnumValue struct {\n\tkey     string\n\tValue   interface{}\n\tComment string\n}\n"
        },
        {
          "name": "enums_test.go",
          "type": "blob",
          "size": 1.3671875,
          "content": "package swag\n\nimport (\n\t\"encoding/json\"\n\t\"math/bits\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestParseGlobalEnums(t *testing.T) {\n\tsearchDir := \"testdata/enums\"\n\texpected, err := os.ReadFile(filepath.Join(searchDir, \"expected.json\"))\n\tassert.NoError(t, err)\n\n\tp := New()\n\terr = p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\tb, err := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.NoError(t, err)\n\tassert.Equal(t, string(expected), string(b))\n\tconstsPath := \"github.com/swaggo/swag/testdata/enums/consts\"\n\tassert.Equal(t, bits.UintSize, p.packages.packages[constsPath].ConstTable[\"uintSize\"].Value)\n\tassert.Equal(t, int32(62), p.packages.packages[constsPath].ConstTable[\"maxBase\"].Value)\n\tassert.Equal(t, 8, p.packages.packages[constsPath].ConstTable[\"shlByLen\"].Value)\n\tassert.Equal(t, 255, p.packages.packages[constsPath].ConstTable[\"hexnum\"].Value)\n\tassert.Equal(t, 15, p.packages.packages[constsPath].ConstTable[\"octnum\"].Value)\n\tassert.Equal(t, `aa\\nbb\\u8888cc`, p.packages.packages[constsPath].ConstTable[\"nonescapestr\"].Value)\n\tassert.Equal(t, \"aa\\nbb\\u8888cc\", p.packages.packages[constsPath].ConstTable[\"escapestr\"].Value)\n\tassert.Equal(t, 1_000_000, p.packages.packages[constsPath].ConstTable[\"underscored\"].Value)\n\tassert.Equal(t, 0b10001000, p.packages.packages[constsPath].ConstTable[\"binaryInteger\"].Value)\n}\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "field_parser.go",
          "type": "blob",
          "size": 14.408203125,
          "content": "package swag\n\nimport (\n\t\"fmt\"\n\t\"go/ast\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"unicode\"\n\n\t\"github.com/go-openapi/spec\"\n)\n\nvar _ FieldParser = &tagBaseFieldParser{p: nil, field: nil, tag: \"\"}\n\nconst (\n\trequiredLabel    = \"required\"\n\toptionalLabel    = \"optional\"\n\tswaggerTypeTag   = \"swaggertype\"\n\tswaggerIgnoreTag = \"swaggerignore\"\n)\n\ntype tagBaseFieldParser struct {\n\tp     *Parser\n\tfield *ast.Field\n\ttag   reflect.StructTag\n}\n\nfunc newTagBaseFieldParser(p *Parser, field *ast.Field) FieldParser {\n\tfieldParser := tagBaseFieldParser{\n\t\tp:     p,\n\t\tfield: field,\n\t\ttag:   \"\",\n\t}\n\tif fieldParser.field.Tag != nil {\n\t\tfieldParser.tag = reflect.StructTag(strings.ReplaceAll(field.Tag.Value, \"`\", \"\"))\n\t}\n\n\treturn &fieldParser\n}\n\nfunc (ps *tagBaseFieldParser) ShouldSkip() bool {\n\t// Skip non-exported fields.\n\tif ps.field.Names != nil && !ast.IsExported(ps.field.Names[0].Name) {\n\t\treturn true\n\t}\n\n\tif ps.field.Tag == nil {\n\t\treturn false\n\t}\n\n\tignoreTag := ps.tag.Get(swaggerIgnoreTag)\n\tif strings.EqualFold(ignoreTag, \"true\") {\n\t\treturn true\n\t}\n\n\t// json:\"tag,hoge\"\n\tname := strings.TrimSpace(strings.Split(ps.tag.Get(jsonTag), \",\")[0])\n\tif name == \"-\" {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc (ps *tagBaseFieldParser) FieldNames() ([]string, error) {\n\tif len(ps.field.Names) <= 1 {\n\t\t// if embedded but with a json/form name ??\n\t\tif ps.field.Tag != nil {\n\t\t\t// json:\"tag,hoge\"\n\t\t\tname := strings.TrimSpace(strings.Split(ps.tag.Get(jsonTag), \",\")[0])\n\t\t\tif name != \"\" {\n\t\t\t\treturn []string{name}, nil\n\t\t\t}\n\n\t\t\t// use \"form\" tag over json tag\n\t\t\tname = ps.FormName()\n\t\t\tif name != \"\" {\n\t\t\t\treturn []string{name}, nil\n\t\t\t}\n\t\t}\n\t\tif len(ps.field.Names) == 0 {\n\t\t\treturn nil, nil\n\t\t}\n\t}\n\tvar names = make([]string, 0, len(ps.field.Names))\n\tfor _, name := range ps.field.Names {\n\t\tswitch ps.p.PropNamingStrategy {\n\t\tcase SnakeCase:\n\t\t\tnames = append(names, toSnakeCase(name.Name))\n\t\tcase PascalCase:\n\t\t\tnames = append(names, name.Name)\n\t\tdefault:\n\t\t\tnames = append(names, toLowerCamelCase(name.Name))\n\t\t}\n\t}\n\treturn names, nil\n}\n\nfunc (ps *tagBaseFieldParser) firstTagValue(tag string) string {\n\tif ps.field.Tag != nil {\n\t\treturn strings.TrimRight(strings.TrimSpace(strings.Split(ps.tag.Get(tag), \",\")[0]), \"[]\")\n\t}\n\treturn \"\"\n}\n\nfunc (ps *tagBaseFieldParser) FormName() string {\n\treturn ps.firstTagValue(formTag)\n}\n\nfunc (ps *tagBaseFieldParser) HeaderName() string {\n\treturn ps.firstTagValue(headerTag)\n}\n\nfunc (ps *tagBaseFieldParser) PathName() string {\n\treturn ps.firstTagValue(uriTag)\n}\n\nfunc toSnakeCase(in string) string {\n\tvar (\n\t\trunes  = []rune(in)\n\t\tlength = len(runes)\n\t\tout    []rune\n\t)\n\n\tfor idx := 0; idx < length; idx++ {\n\t\tif idx > 0 && unicode.IsUpper(runes[idx]) &&\n\t\t\t((idx+1 < length && unicode.IsLower(runes[idx+1])) || unicode.IsLower(runes[idx-1])) {\n\t\t\tout = append(out, '_')\n\t\t}\n\n\t\tout = append(out, unicode.ToLower(runes[idx]))\n\t}\n\n\treturn string(out)\n}\n\nfunc toLowerCamelCase(in string) string {\n\tvar flag bool\n\n\tout := make([]rune, len(in))\n\n\trunes := []rune(in)\n\tfor i, curr := range runes {\n\t\tif (i == 0 && unicode.IsUpper(curr)) || (flag && unicode.IsUpper(curr)) {\n\t\t\tout[i] = unicode.ToLower(curr)\n\t\t\tflag = true\n\n\t\t\tcontinue\n\t\t}\n\n\t\tout[i] = curr\n\t\tflag = false\n\t}\n\n\treturn string(out)\n}\n\nfunc (ps *tagBaseFieldParser) CustomSchema() (*spec.Schema, error) {\n\tif ps.field.Tag == nil {\n\t\treturn nil, nil\n\t}\n\n\ttypeTag := ps.tag.Get(swaggerTypeTag)\n\tif typeTag != \"\" {\n\t\treturn BuildCustomSchema(strings.Split(typeTag, \",\"))\n\t}\n\n\treturn nil, nil\n}\n\ntype structField struct {\n\ttitle        string\n\tschemaType   string\n\tarrayType    string\n\tformatType   string\n\tmaximum      *float64\n\tminimum      *float64\n\tmultipleOf   *float64\n\tmaxLength    *int64\n\tminLength    *int64\n\tmaxItems     *int64\n\tminItems     *int64\n\texampleValue interface{}\n\tenums        []interface{}\n\tenumVarNames []interface{}\n\tunique       bool\n}\n\n// splitNotWrapped slices s into all substrings separated by sep if sep is not\n// wrapped by brackets and returns a slice of the substrings between those separators.\nfunc splitNotWrapped(s string, sep rune) []string {\n\topenCloseMap := map[rune]rune{\n\t\t'(': ')',\n\t\t'[': ']',\n\t\t'{': '}',\n\t}\n\n\tvar (\n\t\tresult    = make([]string, 0)\n\t\tcurrent   = strings.Builder{}\n\t\topenCount = 0\n\t\topenChar  rune\n\t)\n\n\tfor _, char := range s {\n\t\tswitch {\n\t\tcase openChar == 0 && openCloseMap[char] != 0:\n\t\t\topenChar = char\n\n\t\t\topenCount++\n\n\t\t\tcurrent.WriteRune(char)\n\t\tcase char == openChar:\n\t\t\topenCount++\n\n\t\t\tcurrent.WriteRune(char)\n\t\tcase openCount > 0 && char == openCloseMap[openChar]:\n\t\t\topenCount--\n\n\t\t\tcurrent.WriteRune(char)\n\t\tcase openCount == 0 && char == sep:\n\t\t\tresult = append(result, current.String())\n\n\t\t\topenChar = 0\n\n\t\t\tcurrent = strings.Builder{}\n\t\tdefault:\n\t\t\tcurrent.WriteRune(char)\n\t\t}\n\t}\n\n\tif current.String() != \"\" {\n\t\tresult = append(result, current.String())\n\t}\n\n\treturn result\n}\n\n// ComplementSchema complement schema with field properties\nfunc (ps *tagBaseFieldParser) ComplementSchema(schema *spec.Schema) error {\n\ttypes := ps.p.GetSchemaTypePath(schema, 2)\n\tif len(types) == 0 {\n\t\treturn fmt.Errorf(\"invalid type for field: %s\", ps.field.Names[0])\n\t}\n\n\tif IsRefSchema(schema) {\n\t\tvar newSchema = spec.Schema{}\n\t\terr := ps.complementSchema(&newSchema, types)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !reflect.ValueOf(newSchema).IsZero() {\n\t\t\t*schema = *(newSchema.WithAllOf(*schema))\n\t\t}\n\t\treturn nil\n\t}\n\n\treturn ps.complementSchema(schema, types)\n}\n\n// complementSchema complement schema with field properties\nfunc (ps *tagBaseFieldParser) complementSchema(schema *spec.Schema, types []string) error {\n\tif ps.field.Tag == nil {\n\t\tif ps.field.Doc != nil {\n\t\t\tschema.Description = strings.TrimSpace(ps.field.Doc.Text())\n\t\t}\n\n\t\tif schema.Description == \"\" && ps.field.Comment != nil {\n\t\t\tschema.Description = strings.TrimSpace(ps.field.Comment.Text())\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tfield := &structField{\n\t\tschemaType: types[0],\n\t\tformatType: ps.tag.Get(formatTag),\n\t\ttitle:      ps.tag.Get(titleTag),\n\t}\n\n\tif len(types) > 1 && (types[0] == ARRAY || types[0] == OBJECT) {\n\t\tfield.arrayType = types[1]\n\t}\n\n\tjsonTagValue := ps.tag.Get(jsonTag)\n\n\tbindingTagValue := ps.tag.Get(bindingTag)\n\tif bindingTagValue != \"\" {\n\t\tparseValidTags(bindingTagValue, field)\n\t}\n\n\tvalidateTagValue := ps.tag.Get(validateTag)\n\tif validateTagValue != \"\" {\n\t\tparseValidTags(validateTagValue, field)\n\t}\n\n\tenumsTagValue := ps.tag.Get(enumsTag)\n\tif enumsTagValue != \"\" {\n\t\terr := parseEnumTags(enumsTagValue, field)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif IsNumericType(field.schemaType) || IsNumericType(field.arrayType) {\n\t\tmaximum, err := getFloatTag(ps.tag, maximumTag)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif maximum != nil {\n\t\t\tfield.maximum = maximum\n\t\t}\n\n\t\tminimum, err := getFloatTag(ps.tag, minimumTag)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif minimum != nil {\n\t\t\tfield.minimum = minimum\n\t\t}\n\n\t\tmultipleOf, err := getFloatTag(ps.tag, multipleOfTag)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif multipleOf != nil {\n\t\t\tfield.multipleOf = multipleOf\n\t\t}\n\t}\n\n\tif field.schemaType == STRING || field.arrayType == STRING {\n\t\tmaxLength, err := getIntTag(ps.tag, maxLengthTag)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif maxLength != nil {\n\t\t\tfield.maxLength = maxLength\n\t\t}\n\n\t\tminLength, err := getIntTag(ps.tag, minLengthTag)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif minLength != nil {\n\t\t\tfield.minLength = minLength\n\t\t}\n\t}\n\n\t// json:\"name,string\" or json:\",string\"\n\texampleTagValue, ok := ps.tag.Lookup(exampleTag)\n\tif ok {\n\t\tfield.exampleValue = exampleTagValue\n\n\t\tif !strings.Contains(jsonTagValue, \",string\") {\n\t\t\texample, err := defineTypeOfExample(field.schemaType, field.arrayType, exampleTagValue)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tfield.exampleValue = example\n\t\t}\n\t}\n\n\t// perform this after setting everything else (min, max, etc...)\n\tif strings.Contains(jsonTagValue, \",string\") {\n\t\t// @encoding/json: \"It applies only to fields of string, floating point, integer, or boolean types.\"\n\t\tdefaultValues := map[string]string{\n\t\t\t// Zero Values as string\n\t\t\tSTRING:  \"\",\n\t\t\tINTEGER: \"0\",\n\t\t\tBOOLEAN: \"false\",\n\t\t\tNUMBER:  \"0\",\n\t\t}\n\n\t\tdefaultValue, ok := defaultValues[field.schemaType]\n\t\tif ok {\n\t\t\tfield.schemaType = STRING\n\t\t\t*schema = *PrimitiveSchema(field.schemaType)\n\n\t\t\tif field.exampleValue == nil {\n\t\t\t\t// if exampleValue is not defined by the user,\n\t\t\t\t// we will force an example with a correct value\n\t\t\t\t// (eg: int->\"0\", bool:\"false\")\n\t\t\t\tfield.exampleValue = defaultValue\n\t\t\t}\n\t\t}\n\t}\n\n\tif ps.field.Doc != nil {\n\t\tschema.Description = strings.TrimSpace(ps.field.Doc.Text())\n\t}\n\n\tif schema.Description == \"\" && ps.field.Comment != nil {\n\t\tschema.Description = strings.TrimSpace(ps.field.Comment.Text())\n\t}\n\n\tschema.ReadOnly = ps.tag.Get(readOnlyTag) == \"true\"\n\n\tdefaultTagValue := ps.tag.Get(defaultTag)\n\tif defaultTagValue != \"\" {\n\t\tvalue, err := defineType(field.schemaType, defaultTagValue)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tschema.Default = value\n\t}\n\n\tschema.Example = field.exampleValue\n\n\tif field.schemaType != ARRAY {\n\t\tschema.Format = field.formatType\n\t}\n\tschema.Title = field.title\n\n\textensionsTagValue := ps.tag.Get(extensionsTag)\n\tif extensionsTagValue != \"\" {\n\t\tschema.Extensions = setExtensionParam(extensionsTagValue)\n\t}\n\n\tvarNamesTag := ps.tag.Get(\"x-enum-varnames\")\n\tif varNamesTag != \"\" {\n\t\tvarNames := strings.Split(varNamesTag, \",\")\n\t\tif len(varNames) != len(field.enums) {\n\t\t\treturn fmt.Errorf(\"invalid count of x-enum-varnames. expected %d, got %d\", len(field.enums), len(varNames))\n\t\t}\n\n\t\tfield.enumVarNames = nil\n\n\t\tfor _, v := range varNames {\n\t\t\tfield.enumVarNames = append(field.enumVarNames, v)\n\t\t}\n\n\t\tif field.schemaType == ARRAY {\n\t\t\t// Add the var names in the items schema\n\t\t\tif schema.Items.Schema.Extensions == nil {\n\t\t\t\tschema.Items.Schema.Extensions = map[string]interface{}{}\n\t\t\t}\n\t\t\tschema.Items.Schema.Extensions[enumVarNamesExtension] = field.enumVarNames\n\t\t} else {\n\t\t\t// Add to top level schema\n\t\t\tif schema.Extensions == nil {\n\t\t\t\tschema.Extensions = map[string]interface{}{}\n\t\t\t}\n\t\t\tschema.Extensions[enumVarNamesExtension] = field.enumVarNames\n\t\t}\n\t}\n\n\teleSchema := schema\n\n\tif field.schemaType == ARRAY {\n\t\t// For Array only\n\t\tschema.MaxItems = field.maxItems\n\t\tschema.MinItems = field.minItems\n\t\tschema.UniqueItems = field.unique\n\n\t\teleSchema = schema.Items.Schema\n\t\teleSchema.Format = field.formatType\n\t}\n\n\teleSchema.Maximum = field.maximum\n\teleSchema.Minimum = field.minimum\n\teleSchema.MultipleOf = field.multipleOf\n\teleSchema.MaxLength = field.maxLength\n\teleSchema.MinLength = field.minLength\n\teleSchema.Enum = field.enums\n\n\treturn nil\n}\n\nfunc getFloatTag(structTag reflect.StructTag, tagName string) (*float64, error) {\n\tstrValue := structTag.Get(tagName)\n\tif strValue == \"\" {\n\t\treturn nil, nil\n\t}\n\n\tvalue, err := strconv.ParseFloat(strValue, 64)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't parse numeric value of %q tag: %v\", tagName, err)\n\t}\n\n\treturn &value, nil\n}\n\nfunc getIntTag(structTag reflect.StructTag, tagName string) (*int64, error) {\n\tstrValue := structTag.Get(tagName)\n\tif strValue == \"\" {\n\t\treturn nil, nil\n\t}\n\n\tvalue, err := strconv.ParseInt(strValue, 10, 64)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't parse numeric value of %q tag: %v\", tagName, err)\n\t}\n\n\treturn &value, nil\n}\n\nfunc (ps *tagBaseFieldParser) IsRequired() (bool, error) {\n\tif ps.field.Tag == nil {\n\t\treturn false, nil\n\t}\n\n\tbindingTag := ps.tag.Get(bindingTag)\n\tif bindingTag != \"\" {\n\t\tfor _, val := range strings.Split(bindingTag, \",\") {\n\t\t\tswitch val {\n\t\t\tcase requiredLabel:\n\t\t\t\treturn true, nil\n\t\t\tcase optionalLabel:\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tvalidateTag := ps.tag.Get(validateTag)\n\tif validateTag != \"\" {\n\t\tfor _, val := range strings.Split(validateTag, \",\") {\n\t\t\tswitch val {\n\t\t\tcase requiredLabel:\n\t\t\t\treturn true, nil\n\t\t\tcase optionalLabel:\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ps.p.RequiredByDefault, nil\n}\n\nfunc parseValidTags(validTag string, sf *structField) {\n\t// `validate:\"required,max=10,min=1\"`\n\t// ps. required checked by IsRequired().\n\tfor _, val := range strings.Split(validTag, \",\") {\n\t\tvar (\n\t\t\tvalValue string\n\t\t\tkeyVal   = strings.Split(val, \"=\")\n\t\t)\n\n\t\tswitch len(keyVal) {\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tvalValue = strings.ReplaceAll(strings.ReplaceAll(keyVal[1], utf8HexComma, \",\"), utf8Pipe, \"|\")\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch keyVal[0] {\n\t\tcase \"max\", \"lte\":\n\t\t\tsf.setMax(valValue)\n\t\tcase \"min\", \"gte\":\n\t\t\tsf.setMin(valValue)\n\t\tcase \"oneof\":\n\t\t\tsf.setOneOf(valValue)\n\t\tcase \"unique\":\n\t\t\tif sf.schemaType == ARRAY {\n\t\t\t\tsf.unique = true\n\t\t\t}\n\t\tcase \"dive\":\n\t\t\t// ignore dive\n\t\t\treturn\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t}\n}\n\nfunc parseEnumTags(enumTag string, field *structField) error {\n\tenumType := field.schemaType\n\tif field.schemaType == ARRAY {\n\t\tenumType = field.arrayType\n\t}\n\n\tfield.enums = nil\n\n\tfor _, e := range strings.Split(enumTag, \",\") {\n\t\tvalue, err := defineType(enumType, e)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfield.enums = append(field.enums, value)\n\t}\n\n\treturn nil\n}\n\nfunc (sf *structField) setOneOf(valValue string) {\n\tif len(sf.enums) != 0 {\n\t\treturn\n\t}\n\n\tenumType := sf.schemaType\n\tif sf.schemaType == ARRAY {\n\t\tenumType = sf.arrayType\n\t}\n\n\tvalValues := parseOneOfParam2(valValue)\n\tfor i := range valValues {\n\t\tvalue, err := defineType(enumType, valValues[i])\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tsf.enums = append(sf.enums, value)\n\t}\n}\n\nfunc (sf *structField) setMin(valValue string) {\n\tvalue, err := strconv.ParseFloat(valValue, 64)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tswitch sf.schemaType {\n\tcase INTEGER, NUMBER:\n\t\tsf.minimum = &value\n\tcase STRING:\n\t\tintValue := int64(value)\n\t\tsf.minLength = &intValue\n\tcase ARRAY:\n\t\tintValue := int64(value)\n\t\tsf.minItems = &intValue\n\t}\n}\n\nfunc (sf *structField) setMax(valValue string) {\n\tvalue, err := strconv.ParseFloat(valValue, 64)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tswitch sf.schemaType {\n\tcase INTEGER, NUMBER:\n\t\tsf.maximum = &value\n\tcase STRING:\n\t\tintValue := int64(value)\n\t\tsf.maxLength = &intValue\n\tcase ARRAY:\n\t\tintValue := int64(value)\n\t\tsf.maxItems = &intValue\n\t}\n}\n\nconst (\n\tutf8HexComma = \"0x2C\"\n\tutf8Pipe     = \"0x7C\"\n)\n\n// These code copy from\n// https://github.com/go-playground/validator/blob/d4271985b44b735c6f76abc7a06532ee997f9476/baked_in.go#L207\n// ---.\nvar oneofValsCache = map[string][]string{}\nvar oneofValsCacheRWLock = sync.RWMutex{}\nvar splitParamsRegex = regexp.MustCompile(`'[^']*'|\\S+`)\n\nfunc parseOneOfParam2(param string) []string {\n\toneofValsCacheRWLock.RLock()\n\tvalues, ok := oneofValsCache[param]\n\toneofValsCacheRWLock.RUnlock()\n\n\tif !ok {\n\t\toneofValsCacheRWLock.Lock()\n\t\tvalues = splitParamsRegex.FindAllString(param, -1)\n\n\t\tfor i := 0; i < len(values); i++ {\n\t\t\tvalues[i] = strings.ReplaceAll(values[i], \"'\", \"\")\n\t\t}\n\n\t\toneofValsCache[param] = values\n\n\t\toneofValsCacheRWLock.Unlock()\n\t}\n\n\treturn values\n}\n\n// ---.\n"
        },
        {
          "name": "field_parser_test.go",
          "type": "blob",
          "size": 18.3173828125,
          "content": "package swag\n\nimport (\n\t\"go/ast\"\n\t\"testing\"\n\n\t\"github.com/go-openapi/spec\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDefaultFieldParser(t *testing.T) {\n\tt.Run(\"Example tag\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tschema := spec.Schema{}\n\t\tschema.Type = []string{\"string\"}\n\t\terr := newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" example:\"one\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"one\", schema.Example)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"string\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" example:\"\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"\", schema.Example)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"float\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" example:\"one\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.Error(t, err)\n\t})\n\n\tt.Run(\"Format tag\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tschema := spec.Schema{}\n\t\tschema.Type = []string{\"string\"}\n\t\terr := newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" format:\"csv\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"csv\", schema.Format)\n\t})\n\n\tt.Run(\"Title tag\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tschema := spec.Schema{}\n\t\tschema.Type = []string{\"string\"}\n\t\terr := newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" title:\"myfield\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"myfield\", schema.Title)\n\t})\n\n\tt.Run(\"Required tag\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tgot, err := newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" binding:\"required\"`,\n\t\t\t}},\n\t\t).IsRequired()\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, true, got)\n\n\t\tgot, err = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" validate:\"required\"`,\n\t\t\t}},\n\t\t).IsRequired()\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, true, got)\n\t})\n\n\tt.Run(\"Default required tag\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tgot, err := newTagBaseFieldParser(\n\t\t\t&Parser{\n\t\t\t\tRequiredByDefault: true,\n\t\t\t},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\"`,\n\t\t\t}},\n\t\t).IsRequired()\n\t\tassert.NoError(t, err)\n\t\tassert.True(t, got)\n\t})\n\n\tt.Run(\"Optional tag\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tgot, err := newTagBaseFieldParser(\n\t\t\t&Parser{\n\t\t\t\tRequiredByDefault: true,\n\t\t\t},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" binding:\"optional\"`,\n\t\t\t}},\n\t\t).IsRequired()\n\t\tassert.NoError(t, err)\n\t\tassert.False(t, got)\n\n\t\tgot, err = newTagBaseFieldParser(\n\t\t\t&Parser{\n\t\t\t\tRequiredByDefault: true,\n\t\t\t},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" validate:\"optional\"`,\n\t\t\t}},\n\t\t).IsRequired()\n\t\tassert.NoError(t, err)\n\t\tassert.False(t, got)\n\t})\n\n\tt.Run(\"Extensions tag\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tschema := spec.Schema{}\n\t\tschema.Type = []string{\"int\"}\n\t\tschema.Extensions = map[string]interface{}{}\n\t\terr := newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" extensions:\"x-nullable,x-abc=def,!x-omitempty,x-example=[0, 9],x-example2={√ß√£√≠≈ì, (bar=(abc, def)), [0,9]}\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, true, schema.Extensions[\"x-nullable\"])\n\t\tassert.Equal(t, \"def\", schema.Extensions[\"x-abc\"])\n\t\tassert.Equal(t, false, schema.Extensions[\"x-omitempty\"])\n\t\tassert.Equal(t, \"[0, 9]\", schema.Extensions[\"x-example\"])\n\t\tassert.Equal(t, \"{√ß√£√≠≈ì, (bar=(abc, def)), [0,9]}\", schema.Extensions[\"x-example2\"])\n\t})\n\n\tt.Run(\"Enums tag\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tschema := spec.Schema{}\n\t\tschema.Type = []string{\"string\"}\n\t\terr := newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" enums:\"a,b,c\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, []interface{}{\"a\", \"b\", \"c\"}, schema.Enum)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"float\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" enums:\"a,b,c\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.Error(t, err)\n\t})\n\n\tt.Run(\"EnumVarNames tag\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tschema := spec.Schema{}\n\t\tschema.Type = []string{\"int\"}\n\t\tschema.Extensions = map[string]interface{}{}\n\t\tschema.Enum = []interface{}{}\n\t\terr := newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" enums:\"0,1,2\" x-enum-varnames:\"Daily,Weekly,Monthly\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, []interface{}{\"Daily\", \"Weekly\", \"Monthly\"}, schema.Extensions[\"x-enum-varnames\"])\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"int\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" enums:\"0,1,2,3\" x-enum-varnames:\"Daily,Weekly,Monthly\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.Error(t, err)\n\n\t\t// Test for an array of enums\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"array\"}\n\t\tschema.Items = &spec.SchemaOrArray{\n\t\t\tSchema: &spec.Schema{\n\t\t\t\tSchemaProps: spec.SchemaProps{\n\t\t\t\t\tType: []string{\"int\"},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tschema.Extensions = map[string]interface{}{}\n\t\tschema.Enum = []interface{}{}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" enums:\"0,1,2\" x-enum-varnames:\"Daily,Weekly,Monthly\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, []interface{}{\"Daily\", \"Weekly\", \"Monthly\"}, schema.Items.Schema.Extensions[\"x-enum-varnames\"])\n\t\tassert.Equal(t, spec.Extensions{}, schema.Extensions)\n\t})\n\n\tt.Run(\"Default tag\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tschema := spec.Schema{}\n\t\tschema.Type = []string{\"string\"}\n\t\terr := newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" default:\"pass\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"pass\", schema.Default)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"float\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" default:\"pass\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.Error(t, err)\n\t})\n\n\tt.Run(\"Numeric value\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tschema := spec.Schema{}\n\t\tschema.Type = []string{\"integer\"}\n\t\terr := newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" maximum:\"1\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tmax := float64(1)\n\t\tassert.Equal(t, &max, schema.Maximum)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"integer\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" maximum:\"one\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.Error(t, err)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"number\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" maximum:\"1\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tmax = float64(1)\n\t\tassert.Equal(t, &max, schema.Maximum)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"number\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" maximum:\"one\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.Error(t, err)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"number\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" multipleOf:\"1\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tmultipleOf := float64(1)\n\t\tassert.Equal(t, &multipleOf, schema.MultipleOf)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"number\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" multipleOf:\"one\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.Error(t, err)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"integer\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" minimum:\"1\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tmin := float64(1)\n\t\tassert.Equal(t, &min, schema.Minimum)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"integer\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" minimum:\"one\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.Error(t, err)\n\t})\n\n\tt.Run(\"String value\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tschema := spec.Schema{}\n\t\tschema.Type = []string{\"string\"}\n\t\terr := newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" maxLength:\"1\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tmax := int64(1)\n\t\tassert.Equal(t, &max, schema.MaxLength)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"string\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" maxLength:\"one\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.Error(t, err)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"string\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" minLength:\"1\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tmin := int64(1)\n\t\tassert.Equal(t, &min, schema.MinLength)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"string\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" minLength:\"one\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.Error(t, err)\n\t})\n\n\tt.Run(\"Readonly tag\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tschema := spec.Schema{}\n\t\tschema.Type = []string{\"string\"}\n\t\terr := newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" readonly:\"true\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, true, schema.ReadOnly)\n\t})\n\n\tt.Run(\"Invalid tag\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\terr := newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Names: []*ast.Ident{{Name: \"BasicStruct\"}}},\n\t\t).ComplementSchema(nil)\n\t\tassert.Error(t, err)\n\t})\n}\n\nfunc TestValidTags(t *testing.T) {\n\tt.Run(\"Required with max/min tag\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tschema := spec.Schema{}\n\t\tschema.Type = []string{\"string\"}\n\t\terr := newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" validate:\"required,max=10,min=1\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tmax := int64(10)\n\t\tmin := int64(1)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, &max, schema.MaxLength)\n\t\tassert.Equal(t, &min, schema.MinLength)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"string\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" validate:\"required,max=10,gte=1\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, &max, schema.MaxLength)\n\t\tassert.Equal(t, &min, schema.MinLength)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"integer\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" validate:\"required,max=10,min=1\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tmaxFloat64 := float64(10)\n\t\tminFloat64 := float64(1)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, &maxFloat64, schema.Maximum)\n\t\tassert.Equal(t, &minFloat64, schema.Minimum)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"array\"}\n\t\tschema.Items = &spec.SchemaOrArray{\n\t\t\tSchema: &spec.Schema{\n\t\t\t\tSchemaProps: spec.SchemaProps{\n\t\t\t\t\tType: []string{\"string\"},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" validate:\"required,max=10,min=1\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, &max, schema.MaxItems)\n\t\tassert.Equal(t, &min, schema.MinItems)\n\n\t\t// wrong validate tag will be ignored.\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" validate:\"required,max=ten,min=1\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Empty(t, schema.MaxItems)\n\t\tassert.Equal(t, &min, schema.MinItems)\n\t})\n\tt.Run(\"Required with oneof tag\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tschema := spec.Schema{}\n\t\tschema.Type = []string{\"string\"}\n\n\t\terr := newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" validate:\"required,oneof='red book' 'green book'\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, []interface{}{\"red book\", \"green book\"}, schema.Enum)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"integer\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" validate:\"required,oneof=1 2 3\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, []interface{}{1, 2, 3}, schema.Enum)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"array\"}\n\t\tschema.Items = &spec.SchemaOrArray{\n\t\t\tSchema: &spec.Schema{\n\t\t\t\tSchemaProps: spec.SchemaProps{\n\t\t\t\t\tType: []string{\"string\"},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" validate:\"required,oneof=red green yellow\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, []interface{}{\"red\", \"green\", \"yellow\"}, schema.Items.Schema.Enum)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"string\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" validate:\"required,oneof='red green' blue 'c0x2Cc' 'd0x7Cd'\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, []interface{}{\"red green\", \"blue\", \"c,c\", \"d|d\"}, schema.Enum)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"string\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" validate:\"required,oneof='c0x9Ab' book\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, []interface{}{\"c0x9Ab\", \"book\"}, schema.Enum)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"string\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" binding:\"oneof=foo bar\" validate:\"required,oneof=foo bar\" enums:\"a,b,c\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, []interface{}{\"a\", \"b\", \"c\"}, schema.Enum)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"string\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" binding:\"oneof=aa bb\" validate:\"required,oneof=foo bar\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, []interface{}{\"aa\", \"bb\"}, schema.Enum)\n\t})\n\tt.Run(\"Required with unique tag\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tschema := spec.Schema{}\n\t\tschema.Type = []string{\"array\"}\n\t\tschema.Items = &spec.SchemaOrArray{\n\t\t\tSchema: &spec.Schema{\n\t\t\t\tSchemaProps: spec.SchemaProps{\n\t\t\t\t\tType: []string{\"string\"},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\terr := newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" validate:\"required,unique\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, true, schema.UniqueItems)\n\t})\n\n\tt.Run(\"All tag\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tschema := spec.Schema{}\n\t\tschema.Type = []string{\"array\"}\n\t\tschema.Items = &spec.SchemaOrArray{\n\t\t\tSchema: &spec.Schema{\n\t\t\t\tSchemaProps: spec.SchemaProps{\n\t\t\t\t\tType: []string{\"string\"},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\terr := newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" validate:\"required,unique,max=10,min=1,oneof=a0x2Cc 'c0x7Cd book',omitempty,dive,max=1\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, true, schema.UniqueItems)\n\n\t\tmax := int64(10)\n\t\tmin := int64(1)\n\t\tassert.Equal(t, &max, schema.MaxItems)\n\t\tassert.Equal(t, &min, schema.MinItems)\n\t\tassert.Equal(t, []interface{}{\"a,c\", \"c|d book\"}, schema.Items.Schema.Enum)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"array\"}\n\t\tschema.Items = &spec.SchemaOrArray{\n\t\t\tSchema: &spec.Schema{\n\t\t\t\tSchemaProps: spec.SchemaProps{\n\t\t\t\t\tType: []string{\"string\"},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" validate:\"required,oneof=,max=10=90,min=1\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Empty(t, schema.UniqueItems)\n\t\tassert.Empty(t, schema.MaxItems)\n\t\tassert.Equal(t, &min, schema.MinItems)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"array\"}\n\t\tschema.Items = &spec.SchemaOrArray{\n\t\t\tSchema: &spec.Schema{\n\t\t\t\tSchemaProps: spec.SchemaProps{\n\t\t\t\t\tType: []string{\"string\"},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{Tag: &ast.BasicLit{\n\t\t\t\tValue: `json:\"test\" validate:\"required,max=10,min=one\"`,\n\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, &max, schema.MaxItems)\n\t\tassert.Empty(t, schema.MinItems)\n\n\t\tschema = spec.Schema{}\n\t\tschema.Type = []string{\"integer\"}\n\t\terr = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{\n\t\t\t\tNames: []*ast.Ident{{Name: \"Test\"}},\n\t\t\t\tTag: &ast.BasicLit{\n\t\t\t\t\tValue: `json:\"test\" validate:\"required,oneof=one two\"`,\n\t\t\t\t}},\n\t\t).ComplementSchema(&schema)\n\t\tassert.NoError(t, err)\n\t\tassert.Empty(t, schema.Enum)\n\t})\n\n\tt.Run(\"Form Filed Name\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tfilednames, err := newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{\n\t\t\t\tNames: []*ast.Ident{{Name: \"Test\"}},\n\t\t\t\tTag: &ast.BasicLit{\n\t\t\t\t\tValue: `form:\"test[]\"`,\n\t\t\t\t}},\n\t\t).FieldNames()\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test\", filednames[0])\n\n\t\tfilednames, err = newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{\n\t\t\t\tNames: []*ast.Ident{{Name: \"Test\"}},\n\t\t\t\tTag: &ast.BasicLit{\n\t\t\t\t\tValue: `form:\"test\"`,\n\t\t\t\t}},\n\t\t).FieldNames()\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test\", filednames[0])\n\t})\n\n\tt.Run(\"Two Names\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tfieldnames, err := newTagBaseFieldParser(\n\t\t\t&Parser{},\n\t\t\t&ast.Field{\n\t\t\t\tNames: []*ast.Ident{{Name: \"X\"}, {Name: \"Y\"}},\n\t\t\t},\n\t\t).FieldNames()\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 2, len(fieldnames))\n\t\tassert.Equal(t, \"x\", fieldnames[0])\n\t\tassert.Equal(t, \"y\", fieldnames[1])\n\t})\n}\n"
        },
        {
          "name": "format",
          "type": "tree",
          "content": null
        },
        {
          "name": "formatter.go",
          "type": "blob",
          "size": 5.0146484375,
          "content": "package swag\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"go/ast\"\n\tgoparser \"go/parser\"\n\t\"go/token\"\n\t\"log\"\n\t\"os\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strings\"\n\t\"text/tabwriter\"\n\n\t\"golang.org/x/tools/imports\"\n)\n\n// Check of @Param @Success @Failure @Response @Header\nvar specialTagForSplit = map[string]bool{\n\tparamAttr:    true,\n\tsuccessAttr:  true,\n\tfailureAttr:  true,\n\tresponseAttr: true,\n\theaderAttr:   true,\n}\n\nvar skipChar = map[byte]byte{\n\t'\"': '\"',\n\t'(': ')',\n\t'{': '}',\n\t'[': ']',\n}\n\n// Formatter implements a formatter for Go source files.\ntype Formatter struct {\n\t// debugging output goes here\n\tdebug Debugger\n}\n\n// NewFormatter create a new formatter instance.\nfunc NewFormatter() *Formatter {\n\tformatter := &Formatter{\n\t\tdebug: log.New(os.Stdout, \"\", log.LstdFlags),\n\t}\n\treturn formatter\n}\n\n// Format formats swag comments in contents. It uses fileName to report errors\n// that happen during parsing of contents.\nfunc (f *Formatter) Format(fileName string, contents []byte) ([]byte, error) {\n\tfileSet := token.NewFileSet()\n\tast, err := goparser.ParseFile(fileSet, fileName, contents, goparser.ParseComments)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Formatting changes are described as an edit list of byte range\n\t// replacements. We make these content-level edits directly rather than\n\t// changing the AST nodes and writing those out (via [go/printer] or\n\t// [go/format]) so that we only change the formatting of Swag attribute\n\t// comments. This won't touch the formatting of any other comments, or of\n\t// functions, etc.\n\tmaxEdits := 0\n\tfor _, comment := range ast.Comments {\n\t\tmaxEdits += len(comment.List)\n\t}\n\tedits := make(edits, 0, maxEdits)\n\n\tfor _, comment := range ast.Comments {\n\t\tformatFuncDoc(fileSet, comment.List, &edits)\n\t}\n\tformatted, err := imports.Process(fileName, edits.apply(contents), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn formatted, nil\n}\n\ntype edit struct {\n\tbegin       int\n\tend         int\n\treplacement []byte\n}\n\ntype edits []edit\n\nfunc (edits edits) apply(contents []byte) []byte {\n\t// Apply the edits with the highest offset first, so that earlier edits\n\t// don't affect the offsets of later edits.\n\tsort.Slice(edits, func(i, j int) bool {\n\t\treturn edits[i].begin > edits[j].begin\n\t})\n\n\tfor _, edit := range edits {\n\t\tprefix := contents[:edit.begin]\n\t\tsuffix := contents[edit.end:]\n\t\tcontents = append(prefix, append(edit.replacement, suffix...)...)\n\t}\n\n\treturn contents\n}\n\n// formatFuncDoc reformats the comment lines in commentList, and appends any\n// changes to the edit list.\nfunc formatFuncDoc(fileSet *token.FileSet, commentList []*ast.Comment, edits *edits) {\n\t// Building the edit list to format a comment block is a two-step process.\n\t// First, we iterate over each comment line looking for Swag attributes. In\n\t// each one we find, we replace alignment whitespace with a tab character,\n\t// then write the result into a tab writer.\n\n\tlinesToComments := make(map[int]int, len(commentList))\n\n\tbuffer := &bytes.Buffer{}\n\tw := tabwriter.NewWriter(buffer, 1, 4, 1, '\\t', 0)\n\n\tfor commentIndex, comment := range commentList {\n\t\ttext := comment.Text\n\t\tif attr, body, found := swagComment(text); found {\n\t\t\tformatted := \"//\\t\" + attr\n\t\t\tif body != \"\" {\n\t\t\t\tformatted += \"\\t\" + splitComment2(attr, body)\n\t\t\t}\n\t\t\t_, _ = fmt.Fprintln(w, formatted)\n\t\t\tlinesToComments[len(linesToComments)] = commentIndex\n\t\t}\n\t}\n\n\t// Once we've loaded all of the comment lines to be aligned into the tab\n\t// writer, flushing it causes the aligned text to be written out to the\n\t// backing buffer.\n\t_ = w.Flush()\n\n\t// Now the second step: we iterate over the aligned comment lines that were\n\t// written into the backing buffer, pair each one up to its original\n\t// comment line, and use the combination to describe the edit that needs to\n\t// be made to the original input.\n\tformattedComments := bytes.Split(buffer.Bytes(), []byte(\"\\n\"))\n\tfor lineIndex, commentIndex := range linesToComments {\n\t\tcomment := commentList[commentIndex]\n\t\t*edits = append(*edits, edit{\n\t\t\tbegin:       fileSet.Position(comment.Pos()).Offset,\n\t\t\tend:         fileSet.Position(comment.End()).Offset,\n\t\t\treplacement: formattedComments[lineIndex],\n\t\t})\n\t}\n}\n\nfunc splitComment2(attr, body string) string {\n\tif specialTagForSplit[strings.ToLower(attr)] {\n\t\tfor i := 0; i < len(body); i++ {\n\t\t\tif skipEnd, ok := skipChar[body[i]]; ok {\n\t\t\t\tskipStart, n := body[i], 1\n\t\t\t\tfor i++; i < len(body); i++ {\n\t\t\t\t\tif skipStart != skipEnd && body[i] == skipStart {\n\t\t\t\t\t\tn++\n\t\t\t\t\t} else if body[i] == skipEnd {\n\t\t\t\t\t\tn--\n\t\t\t\t\t\tif n == 0 {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if body[i] == ' ' || body[i] == '\\t' {\n\t\t\t\tj := i\n\t\t\t\tfor ; j < len(body) && (body[j] == ' ' || body[j] == '\\t'); j++ {\n\t\t\t\t}\n\t\t\t\tbody = replaceRange(body, i, j, \"\\t\")\n\t\t\t}\n\t\t}\n\t}\n\treturn body\n}\n\nfunc replaceRange(s string, start, end int, new string) string {\n\treturn s[:start] + new + s[end:]\n}\n\nvar swagCommentLineExpression = regexp.MustCompile(`^\\/\\/\\s+(@[\\S.]+)\\s*(.*)`)\n\nfunc swagComment(comment string) (string, string, bool) {\n\tmatches := swagCommentLineExpression.FindStringSubmatch(comment)\n\tif matches == nil {\n\t\treturn \"\", \"\", false\n\t}\n\treturn matches[1], matches[2], true\n}\n"
        },
        {
          "name": "formatter_test.go",
          "type": "blob",
          "size": 7.33984375,
          "content": "package swag\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nconst (\n\tSearchDir = \"./testdata/format_test\"\n\tExcludes  = \"./testdata/format_test/web\"\n\tMainFile  = \"main.go\"\n)\n\nfunc testFormat(t *testing.T, filename, contents, want string) {\n\tgot, err := NewFormatter().Format(filename, []byte(contents))\n\tassert.NoError(t, err)\n\tassert.Equal(t, want, string(got))\n}\n\nfunc Test_FormatMain(t *testing.T) {\n\tcontents := `package main\n\t// @title Swagger Example API\n\t// @version 1.0\n\t// @description This is a sample server Petstore server.\n\t// @termsOfService http://swagger.io/terms/\n\n\t// @contact.name API Support\n\t// @contact.url http://www.swagger.io/support\n\t// @contact.email support@swagger.io\n\n\t// @license.name Apache 2.0\n\t// @license.url http://www.apache.org/licenses/LICENSE-2.0.html\n\n\t// @host petstore.swagger.io\n\t// @BasePath /v2\n\n\t// @securityDefinitions.basic BasicAuth\n\n\t// @securityDefinitions.apikey ApiKeyAuth\n\t// @in header\n\t// @name Authorization\n\n\t// @securitydefinitions.oauth2.application OAuth2Application\n\t// @tokenUrl https://example.com/oauth/token\n\t// @scope.write Grants write access\n\t// @scope.admin Grants read and write access to administrative information\n\n\t// @securitydefinitions.oauth2.implicit OAuth2Implicit\n\t// @authorizationurl https://example.com/oauth/authorize\n\t// @scope.write Grants write access\n\t// @scope.admin Grants read and write access to administrative information\n\n\t// @securitydefinitions.oauth2.password OAuth2Password\n\t// @tokenUrl https://example.com/oauth/token\n\t// @scope.read Grants read access\n\t// @scope.write Grants write access\n\t// @scope.admin Grants read and write access to administrative information\n\n\t// @securitydefinitions.oauth2.accessCode OAuth2AccessCode\n\t// @tokenUrl https://example.com/oauth/token\n\t// @authorizationurl https://example.com/oauth/authorize\n\t// @scope.admin Grants read and write access to administrative information\n\tfunc main() {}`\n\n\twant := `package main\n\n//\t@title\t\t\tSwagger Example API\n//\t@version\t\t1.0\n//\t@description\tThis is a sample server Petstore server.\n//\t@termsOfService\thttp://swagger.io/terms/\n\n//\t@contact.name\tAPI Support\n//\t@contact.url\thttp://www.swagger.io/support\n//\t@contact.email\tsupport@swagger.io\n\n//\t@license.name\tApache 2.0\n//\t@license.url\thttp://www.apache.org/licenses/LICENSE-2.0.html\n\n//\t@host\t\tpetstore.swagger.io\n//\t@BasePath\t/v2\n\n//\t@securityDefinitions.basic\tBasicAuth\n\n//\t@securityDefinitions.apikey\tApiKeyAuth\n//\t@in\t\t\t\t\t\t\theader\n//\t@name\t\t\t\t\t\tAuthorization\n\n//\t@securitydefinitions.oauth2.application\tOAuth2Application\n//\t@tokenUrl\t\t\t\t\t\t\t\thttps://example.com/oauth/token\n//\t@scope.write\t\t\t\t\t\t\tGrants write access\n//\t@scope.admin\t\t\t\t\t\t\tGrants read and write access to administrative information\n\n//\t@securitydefinitions.oauth2.implicit\tOAuth2Implicit\n//\t@authorizationurl\t\t\t\t\t\thttps://example.com/oauth/authorize\n//\t@scope.write\t\t\t\t\t\t\tGrants write access\n//\t@scope.admin\t\t\t\t\t\t\tGrants read and write access to administrative information\n\n//\t@securitydefinitions.oauth2.password\tOAuth2Password\n//\t@tokenUrl\t\t\t\t\t\t\t\thttps://example.com/oauth/token\n//\t@scope.read\t\t\t\t\t\t\t\tGrants read access\n//\t@scope.write\t\t\t\t\t\t\tGrants write access\n//\t@scope.admin\t\t\t\t\t\t\tGrants read and write access to administrative information\n\n// @securitydefinitions.oauth2.accessCode\tOAuth2AccessCode\n// @tokenUrl\t\t\t\t\t\t\t\thttps://example.com/oauth/token\n// @authorizationurl\t\t\t\t\t\thttps://example.com/oauth/authorize\n// @scope.admin\t\t\t\t\t\t\tGrants read and write access to administrative information\nfunc main() {}\n`\n\ttestFormat(t, \"main.go\", contents, want)\n}\n\nfunc Test_FormatMultipleFunctions(t *testing.T) {\n\tcontents := `package main\n\n// @Produce json\n// @Success 200 {object} string\n// @Failure 400 {object} string\n\tfunc A() {}\n\n// @Description Description of B.\n// @Produce json\n// @Success 200 {array} string\n// @Failure 400 {object} string\n\tfunc B() {}`\n\n\twant := `package main\n\n// @Produce\tjson\n// @Success\t200\t{object}\tstring\n// @Failure\t400\t{object}\tstring\nfunc A() {}\n\n// @Description\tDescription of B.\n// @Produce\t\tjson\n// @Success\t\t200\t{array}\t\tstring\n// @Failure\t\t400\t{object}\tstring\nfunc B() {}\n`\n\n\ttestFormat(t, \"main.go\", contents, want)\n}\n\nfunc Test_FormatApi(t *testing.T) {\n\tcontents := `package api\n\nimport \"net/http\"\n\n// @Summary Add a new pet to the store\n// @Description get string by ID\n// @ID get-string-by-int\n// @Accept  json\n// @Produce  json\n// @Param   some_id      path   int     true  \"Some ID\" Format(int64)\n// @Param   some_id      body web.Pet true  \"Some ID\"\n// @Success 200 {string} string\t\"ok\"\n// @Failure 400 {object} web.APIError \"We need ID!!\"\n// @Failure 404 {object} web.APIError \"Can not find ID\"\n// @Router /testapi/get-string-by-int/{some_id} [get]\n\tfunc GetStringByInt(w http.ResponseWriter, r *http.Request) {}`\n\n\twant := `package api\n\nimport \"net/http\"\n\n// @Summary\t\tAdd a new pet to the store\n// @Description\tget string by ID\n// @ID\t\t\t\tget-string-by-int\n// @Accept\t\t\tjson\n// @Produce\t\tjson\n// @Param\t\t\tsome_id\tpath\t\tint\t\t\t\ttrue\t\"Some ID\"\tFormat(int64)\n// @Param\t\t\tsome_id\tbody\t\tweb.Pet\t\t\ttrue\t\"Some ID\"\n// @Success\t\t200\t\t{string}\tstring\t\t\t\"ok\"\n// @Failure\t\t400\t\t{object}\tweb.APIError\t\"We need ID!!\"\n// @Failure\t\t404\t\t{object}\tweb.APIError\t\"Can not find ID\"\n// @Router\t\t\t/testapi/get-string-by-int/{some_id} [get]\nfunc GetStringByInt(w http.ResponseWriter, r *http.Request) {}\n`\n\n\ttestFormat(t, \"api.go\", contents, want)\n}\n\nfunc Test_NonSwagComment(t *testing.T) {\n\tcontents := `package api\n\n// @Summary Add a new pet to the store\n// @Description get string by ID\n// @ID get-string-by-int\n// @ Accept json\n// This is not a @swag comment`\n\twant := `package api\n\n//\t@Summary\t\tAdd a new pet to the store\n//\t@Description\tget string by ID\n//\t@ID\t\t\t\tget-string-by-int\n// @ Accept json\n// This is not a @swag comment\n`\n\n\ttestFormat(t, \"non_swag.go\", contents, want)\n}\n\nfunc Test_EmptyComment(t *testing.T) {\n\tcontents := `package empty\n\n// @Summary Add a new pet to the store\n// @Description  `\n\twant := `package empty\n\n//\t@Summary\tAdd a new pet to the store\n//\t@Description\n`\n\n\ttestFormat(t, \"empty.go\", contents, want)\n}\n\nfunc Test_AlignAttribute(t *testing.T) {\n\tcontents := `package align\n\n// @Summary Add a new pet to the store\n//  @Description Description`\n\twant := `package align\n\n//\t@Summary\t\tAdd a new pet to the store\n//\t@Description\tDescription\n`\n\n\ttestFormat(t, \"align.go\", contents, want)\n\n}\n\nfunc Test_SyntaxError(t *testing.T) {\n\tcontents := []byte(`package invalid\n\tfunc invalid() {`)\n\n\t_, err := NewFormatter().Format(\"invalid.go\", contents)\n\tassert.Error(t, err)\n}\n\nfunc Test_splitComment2(t *testing.T) {\n\ttype args struct {\n\t\tattr string\n\t\tbody string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\t\"test_splitComment2_1\",\n\t\t\targs{\n\t\t\t\tattr: \"@param\",\n\t\t\t\tbody: \"   data body web.GenericBodyMulti[[]types.Post, [][]types.Post]\",\n\t\t\t},\n\t\t\t\"\\tdata\\tbody\\tweb.GenericBodyMulti[[]types.Post, [][]types.Post]\",\n\t\t},\n\t\t{\n\t\t\t\"test_splitComment2_2\",\n\t\t\targs{\n\t\t\t\tattr: \"@param\",\n\t\t\t\tbody: `   some_id      path   int     true  \"Some ID\" Format(int64)`,\n\t\t\t},\n\t\t\t\"\\tsome_id\\tpath\\tint\\ttrue\\t\\\"Some ID\\\"\\tFormat(int64)\",\n\t\t},\n\t\t{\n\t\t\t\"test_splitComment2_3\",\n\t\t\targs{\n\t\t\t\tattr: \"@param\",\n\t\t\t\tbody: `   @Param   some_id      body web.Pet true  \"Some ID\"`,\n\t\t\t},\n\t\t\t\"\\t@Param\\tsome_id\\tbody\\tweb.Pet\\ttrue\\t\\\"Some ID\\\"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tassert.Equalf(t, tt.want, splitComment2(tt.args.attr, tt.args.body), \"splitComment2(%v, %v)\", tt.args.attr, tt.args.body)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "gen",
          "type": "tree",
          "content": null
        },
        {
          "name": "generics.go",
          "type": "blob",
          "size": 12.1650390625,
          "content": "//go:build go1.18\n// +build go1.18\n\npackage swag\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"strings\"\n\t\"unicode\"\n\n\t\"github.com/go-openapi/spec\"\n)\n\ntype genericTypeSpec struct {\n\tTypeSpec *TypeSpecDef\n\tName     string\n}\n\ntype formalParamType struct {\n\tName string\n\tType string\n}\n\nfunc (t *genericTypeSpec) TypeName() string {\n\tif t.TypeSpec != nil {\n\t\treturn t.TypeSpec.TypeName()\n\t}\n\treturn t.Name\n}\n\nfunc normalizeGenericTypeName(name string) string {\n\treturn strings.Replace(name, \".\", \"_\", -1)\n}\n\nfunc (pkgDefs *PackagesDefinitions) getTypeFromGenericParam(genericParam string, file *ast.File) (typeSpecDef *TypeSpecDef) {\n\tif strings.HasPrefix(genericParam, \"[]\") {\n\t\ttypeSpecDef = pkgDefs.getTypeFromGenericParam(genericParam[2:], file)\n\t\tif typeSpecDef == nil {\n\t\t\treturn nil\n\t\t}\n\t\tvar expr ast.Expr\n\t\tswitch typeSpecDef.TypeSpec.Type.(type) {\n\t\tcase *ast.ArrayType, *ast.MapType:\n\t\t\texpr = typeSpecDef.TypeSpec.Type\n\t\tdefault:\n\t\t\tname := typeSpecDef.TypeName()\n\t\t\texpr = ast.NewIdent(name)\n\t\t\tif _, ok := pkgDefs.uniqueDefinitions[name]; !ok {\n\t\t\t\tpkgDefs.uniqueDefinitions[name] = typeSpecDef\n\t\t\t}\n\t\t}\n\t\treturn &TypeSpecDef{\n\t\t\tTypeSpec: &ast.TypeSpec{\n\t\t\t\tName: ast.NewIdent(string(IgnoreNameOverridePrefix) + \"array_\" + typeSpecDef.TypeName()),\n\t\t\t\tType: &ast.ArrayType{\n\t\t\t\t\tElt: expr,\n\t\t\t\t},\n\t\t\t},\n\t\t\tEnums:      typeSpecDef.Enums,\n\t\t\tPkgPath:    typeSpecDef.PkgPath,\n\t\t\tParentSpec: typeSpecDef.ParentSpec,\n\t\t\tSchemaName: \"array_\" + typeSpecDef.SchemaName,\n\t\t\tNotUnique:  false,\n\t\t}\n\t}\n\n\tif strings.HasPrefix(genericParam, \"map[\") {\n\t\tparts := strings.SplitN(genericParam[4:], \"]\", 2)\n\t\tif len(parts) != 2 {\n\t\t\treturn nil\n\t\t}\n\t\ttypeSpecDef = pkgDefs.getTypeFromGenericParam(parts[1], file)\n\t\tif typeSpecDef == nil {\n\t\t\treturn nil\n\t\t}\n\t\tvar expr ast.Expr\n\t\tswitch typeSpecDef.TypeSpec.Type.(type) {\n\t\tcase *ast.ArrayType, *ast.MapType:\n\t\t\texpr = typeSpecDef.TypeSpec.Type\n\t\tdefault:\n\t\t\tname := typeSpecDef.TypeName()\n\t\t\texpr = ast.NewIdent(name)\n\t\t\tif _, ok := pkgDefs.uniqueDefinitions[name]; !ok {\n\t\t\t\tpkgDefs.uniqueDefinitions[name] = typeSpecDef\n\t\t\t}\n\t\t}\n\t\treturn &TypeSpecDef{\n\t\t\tTypeSpec: &ast.TypeSpec{\n\t\t\t\tName: ast.NewIdent(string(IgnoreNameOverridePrefix) + \"map_\" + parts[0] + \"_\" + typeSpecDef.TypeName()),\n\t\t\t\tType: &ast.MapType{\n\t\t\t\t\tKey:   ast.NewIdent(parts[0]), //assume key is string or integer\n\t\t\t\t\tValue: expr,\n\t\t\t\t},\n\t\t\t},\n\t\t\tEnums:      typeSpecDef.Enums,\n\t\t\tPkgPath:    typeSpecDef.PkgPath,\n\t\t\tParentSpec: typeSpecDef.ParentSpec,\n\t\t\tSchemaName: \"map_\" + parts[0] + \"_\" + typeSpecDef.SchemaName,\n\t\t\tNotUnique:  false,\n\t\t}\n\t}\n\tif IsGolangPrimitiveType(genericParam) {\n\t\treturn &TypeSpecDef{\n\t\t\tTypeSpec: &ast.TypeSpec{\n\t\t\t\tName: ast.NewIdent(genericParam),\n\t\t\t\tType: ast.NewIdent(genericParam),\n\t\t\t},\n\t\t\tSchemaName: genericParam,\n\t\t}\n\t}\n\treturn pkgDefs.FindTypeSpec(genericParam, file)\n}\n\nfunc (pkgDefs *PackagesDefinitions) parametrizeGenericType(file *ast.File, original *TypeSpecDef, fullGenericForm string) *TypeSpecDef {\n\tif original == nil || original.TypeSpec.TypeParams == nil || len(original.TypeSpec.TypeParams.List) == 0 {\n\t\treturn original\n\t}\n\n\tname, genericParams := splitGenericsTypeName(fullGenericForm)\n\tif genericParams == nil {\n\t\treturn nil\n\t}\n\n\t//generic[x,y any,z any] considered, TODO what if the type is not `any`, but a concrete one, such as `int32|int64` or an certain interface{}\n\tvar formals []formalParamType\n\tfor _, field := range original.TypeSpec.TypeParams.List {\n\t\tfor _, ident := range field.Names {\n\t\t\tformal := formalParamType{Name: ident.Name}\n\t\t\tif ident, ok := field.Type.(*ast.Ident); ok {\n\t\t\t\tformal.Type = ident.Name\n\t\t\t}\n\t\t\tformals = append(formals, formal)\n\t\t}\n\t}\n\tif len(genericParams) != len(formals) {\n\t\treturn nil\n\t}\n\tgenericParamTypeDefs := map[string]*genericTypeSpec{}\n\n\tfor i, genericParam := range genericParams {\n\t\tvar typeDef *TypeSpecDef\n\t\tif !IsGolangPrimitiveType(genericParam) {\n\t\t\ttypeDef = pkgDefs.getTypeFromGenericParam(genericParam, file)\n\t\t\tif typeDef != nil {\n\t\t\t\tgenericParam = typeDef.TypeName()\n\t\t\t\tif _, ok := pkgDefs.uniqueDefinitions[genericParam]; !ok {\n\t\t\t\t\tpkgDefs.uniqueDefinitions[genericParam] = typeDef\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgenericParamTypeDefs[formals[i].Name] = &genericTypeSpec{\n\t\t\tTypeSpec: typeDef,\n\t\t\tName:     genericParam,\n\t\t}\n\t}\n\n\tname = fmt.Sprintf(\"%s%s-\", string(IgnoreNameOverridePrefix), original.TypeName())\n\tschemaName := fmt.Sprintf(\"%s-\", original.SchemaName)\n\n\tvar nameParts []string\n\tvar schemaNameParts []string\n\n\tfor _, def := range formals {\n\t\tif specDef, ok := genericParamTypeDefs[def.Name]; ok {\n\t\t\tnameParts = append(nameParts, specDef.Name)\n\n\t\t\tschemaNamePart := specDef.Name\n\n\t\t\tif specDef.TypeSpec != nil {\n\t\t\t\tschemaNamePart = specDef.TypeSpec.SchemaName\n\t\t\t}\n\n\t\t\tschemaNameParts = append(schemaNameParts, schemaNamePart)\n\t\t}\n\t}\n\n\tname += normalizeGenericTypeName(strings.Join(nameParts, \"-\"))\n\tschemaName += normalizeGenericTypeName(strings.Join(schemaNameParts, \"-\"))\n\n\tif typeSpec, ok := pkgDefs.uniqueDefinitions[name]; ok {\n\t\treturn typeSpec\n\t}\n\n\tparametrizedTypeSpec := &TypeSpecDef{\n\t\tFile:    original.File,\n\t\tPkgPath: original.PkgPath,\n\t\tTypeSpec: &ast.TypeSpec{\n\t\t\tName: &ast.Ident{\n\t\t\t\tName:    name,\n\t\t\t\tNamePos: original.TypeSpec.Name.NamePos,\n\t\t\t\tObj:     original.TypeSpec.Name.Obj,\n\t\t\t},\n\t\t\tDoc:    original.TypeSpec.Doc,\n\t\t\tAssign: original.TypeSpec.Assign,\n\t\t},\n\t\tSchemaName: schemaName,\n\t}\n\tpkgDefs.uniqueDefinitions[name] = parametrizedTypeSpec\n\n\tparametrizedTypeSpec.TypeSpec.Type = pkgDefs.resolveGenericType(original.File, original.TypeSpec.Type, genericParamTypeDefs)\n\n\treturn parametrizedTypeSpec\n}\n\n// splitGenericsTypeName splits a generic struct name in his parts\nfunc splitGenericsTypeName(fullGenericForm string) (string, []string) {\n\t//remove all spaces character\n\tfullGenericForm = strings.Map(func(r rune) rune {\n\t\tif unicode.IsSpace(r) {\n\t\t\treturn -1\n\t\t}\n\t\treturn r\n\t}, fullGenericForm)\n\n\t// split only at the first '[' and remove the last ']'\n\tif fullGenericForm[len(fullGenericForm)-1] != ']' {\n\t\treturn \"\", nil\n\t}\n\n\tgenericParams := strings.SplitN(fullGenericForm[:len(fullGenericForm)-1], \"[\", 2)\n\tif len(genericParams) == 1 {\n\t\treturn \"\", nil\n\t}\n\n\t// generic type name\n\tgenericTypeName := genericParams[0]\n\n\tdepth := 0\n\tgenericParams = strings.FieldsFunc(genericParams[1], func(r rune) bool {\n\t\tif r == '[' {\n\t\t\tdepth++\n\t\t} else if r == ']' {\n\t\t\tdepth--\n\t\t} else if r == ',' && depth == 0 {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\tif depth != 0 {\n\t\treturn \"\", nil\n\t}\n\n\treturn genericTypeName, genericParams\n}\n\nfunc (pkgDefs *PackagesDefinitions) getParametrizedType(genTypeSpec *genericTypeSpec) ast.Expr {\n\tif genTypeSpec.TypeSpec != nil && strings.Contains(genTypeSpec.Name, \".\") {\n\t\tparts := strings.SplitN(genTypeSpec.Name, \".\", 2)\n\t\treturn &ast.SelectorExpr{\n\t\t\tX:   &ast.Ident{Name: parts[0]},\n\t\t\tSel: &ast.Ident{Name: parts[1]},\n\t\t}\n\t}\n\n\t//a primitive type name or a type name in current package\n\treturn &ast.Ident{Name: genTypeSpec.Name}\n}\n\nfunc (pkgDefs *PackagesDefinitions) resolveGenericType(file *ast.File, expr ast.Expr, genericParamTypeDefs map[string]*genericTypeSpec) ast.Expr {\n\tswitch astExpr := expr.(type) {\n\tcase *ast.Ident:\n\t\tif genTypeSpec, ok := genericParamTypeDefs[astExpr.Name]; ok {\n\t\t\treturn pkgDefs.getParametrizedType(genTypeSpec)\n\t\t}\n\tcase *ast.ArrayType:\n\t\treturn &ast.ArrayType{\n\t\t\tElt:    pkgDefs.resolveGenericType(file, astExpr.Elt, genericParamTypeDefs),\n\t\t\tLen:    astExpr.Len,\n\t\t\tLbrack: astExpr.Lbrack,\n\t\t}\n\tcase *ast.MapType:\n\t\treturn &ast.MapType{\n\t\t\tMap:   astExpr.Map,\n\t\t\tKey:   pkgDefs.resolveGenericType(file, astExpr.Key, genericParamTypeDefs),\n\t\t\tValue: pkgDefs.resolveGenericType(file, astExpr.Value, genericParamTypeDefs),\n\t\t}\n\tcase *ast.StarExpr:\n\t\treturn &ast.StarExpr{\n\t\t\tStar: astExpr.Star,\n\t\t\tX:    pkgDefs.resolveGenericType(file, astExpr.X, genericParamTypeDefs),\n\t\t}\n\tcase *ast.IndexExpr, *ast.IndexListExpr:\n\t\tfullGenericName, _ := getGenericFieldType(file, expr, genericParamTypeDefs)\n\t\ttypeDef := pkgDefs.FindTypeSpec(fullGenericName, file)\n\t\tif typeDef != nil {\n\t\t\treturn typeDef.TypeSpec.Name\n\t\t}\n\tcase *ast.StructType:\n\t\tnewStructTypeDef := &ast.StructType{\n\t\t\tStruct:     astExpr.Struct,\n\t\t\tIncomplete: astExpr.Incomplete,\n\t\t\tFields: &ast.FieldList{\n\t\t\t\tOpening: astExpr.Fields.Opening,\n\t\t\t\tClosing: astExpr.Fields.Closing,\n\t\t\t},\n\t\t}\n\n\t\tfor _, field := range astExpr.Fields.List {\n\t\t\tnewField := &ast.Field{\n\t\t\t\tType:    field.Type,\n\t\t\t\tDoc:     field.Doc,\n\t\t\t\tNames:   field.Names,\n\t\t\t\tTag:     field.Tag,\n\t\t\t\tComment: field.Comment,\n\t\t\t}\n\n\t\t\tnewField.Type = pkgDefs.resolveGenericType(file, field.Type, genericParamTypeDefs)\n\n\t\t\tnewStructTypeDef.Fields.List = append(newStructTypeDef.Fields.List, newField)\n\t\t}\n\t\treturn newStructTypeDef\n\t}\n\treturn expr\n}\n\nfunc getExtendedGenericFieldType(file *ast.File, field ast.Expr, genericParamTypeDefs map[string]*genericTypeSpec) (string, error) {\n\tswitch fieldType := field.(type) {\n\tcase *ast.ArrayType:\n\t\tfieldName, err := getExtendedGenericFieldType(file, fieldType.Elt, genericParamTypeDefs)\n\t\treturn \"[]\" + fieldName, err\n\tcase *ast.StarExpr:\n\t\treturn getExtendedGenericFieldType(file, fieldType.X, genericParamTypeDefs)\n\tcase *ast.Ident:\n\t\tif genericParamTypeDefs != nil {\n\t\t\tif typeSpec, ok := genericParamTypeDefs[fieldType.Name]; ok {\n\t\t\t\treturn typeSpec.Name, nil\n\t\t\t}\n\t\t}\n\t\tif fieldType.Obj == nil {\n\t\t\treturn fieldType.Name, nil\n\t\t}\n\n\t\ttSpec := &TypeSpecDef{\n\t\t\tFile:     file,\n\t\t\tTypeSpec: fieldType.Obj.Decl.(*ast.TypeSpec),\n\t\t\tPkgPath:  file.Name.Name,\n\t\t}\n\t\treturn tSpec.TypeName(), nil\n\tdefault:\n\t\treturn getFieldType(file, field, genericParamTypeDefs)\n\t}\n}\n\nfunc getGenericFieldType(file *ast.File, field ast.Expr, genericParamTypeDefs map[string]*genericTypeSpec) (string, error) {\n\tvar fullName string\n\tvar baseName string\n\tvar err error\n\tswitch fieldType := field.(type) {\n\tcase *ast.IndexListExpr:\n\t\tbaseName, err = getGenericTypeName(file, fieldType.X)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tfullName = baseName + \"[\"\n\n\t\tfor _, index := range fieldType.Indices {\n\t\t\tfieldName, err := getExtendedGenericFieldType(file, index, genericParamTypeDefs)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\n\t\t\tfullName += fieldName + \",\"\n\t\t}\n\n\t\tfullName = strings.TrimRight(fullName, \",\") + \"]\"\n\tcase *ast.IndexExpr:\n\t\tbaseName, err = getGenericTypeName(file, fieldType.X)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tindexName, err := getExtendedGenericFieldType(file, fieldType.Index, genericParamTypeDefs)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tfullName = fmt.Sprintf(\"%s[%s]\", baseName, indexName)\n\t}\n\n\tif fullName == \"\" {\n\t\treturn \"\", fmt.Errorf(\"unknown field type %#v\", field)\n\t}\n\n\tvar packageName string\n\tif !strings.Contains(baseName, \".\") {\n\t\tif file.Name == nil {\n\t\t\treturn \"\", errors.New(\"file name is nil\")\n\t\t}\n\t\tpackageName, _ = getFieldType(file, file.Name, genericParamTypeDefs)\n\t}\n\n\treturn strings.TrimLeft(fmt.Sprintf(\"%s.%s\", packageName, fullName), \".\"), nil\n}\n\nfunc getGenericTypeName(file *ast.File, field ast.Expr) (string, error) {\n\tswitch fieldType := field.(type) {\n\tcase *ast.Ident:\n\t\tif fieldType.Obj == nil {\n\t\t\treturn fieldType.Name, nil\n\t\t}\n\n\t\ttSpec := &TypeSpecDef{\n\t\t\tFile:     file,\n\t\t\tTypeSpec: fieldType.Obj.Decl.(*ast.TypeSpec),\n\t\t\tPkgPath:  file.Name.Name,\n\t\t}\n\t\treturn tSpec.TypeName(), nil\n\tcase *ast.ArrayType:\n\t\ttSpec := &TypeSpecDef{\n\t\t\tFile:     file,\n\t\t\tTypeSpec: fieldType.Elt.(*ast.Ident).Obj.Decl.(*ast.TypeSpec),\n\t\t\tPkgPath:  file.Name.Name,\n\t\t}\n\t\treturn tSpec.TypeName(), nil\n\tcase *ast.SelectorExpr:\n\t\treturn fmt.Sprintf(\"%s.%s\", fieldType.X.(*ast.Ident).Name, fieldType.Sel.Name), nil\n\t}\n\treturn \"\", fmt.Errorf(\"unknown type %#v\", field)\n}\n\nfunc (parser *Parser) parseGenericTypeExpr(file *ast.File, typeExpr ast.Expr) (*spec.Schema, error) {\n\tswitch expr := typeExpr.(type) {\n\t// suppress debug messages for these types\n\tcase *ast.InterfaceType:\n\tcase *ast.StructType:\n\tcase *ast.Ident:\n\tcase *ast.StarExpr:\n\tcase *ast.SelectorExpr:\n\tcase *ast.ArrayType:\n\tcase *ast.MapType:\n\tcase *ast.FuncType:\n\tcase *ast.IndexExpr, *ast.IndexListExpr:\n\t\tname, err := getExtendedGenericFieldType(file, expr, nil)\n\t\tif err == nil {\n\t\t\tif schema, err := parser.getTypeSchema(name, file, false); err == nil {\n\t\t\t\treturn schema, nil\n\t\t\t}\n\t\t}\n\n\t\tparser.debug.Printf(\"Type definition of type '%T' is not supported yet. Using 'object' instead. (%s)\\n\", typeExpr, err)\n\tdefault:\n\t\tparser.debug.Printf(\"Type definition of type '%T' is not supported yet. Using 'object' instead.\\n\", typeExpr)\n\t}\n\n\treturn PrimitiveSchema(OBJECT), nil\n}\n"
        },
        {
          "name": "generics_test.go",
          "type": "blob",
          "size": 14.1884765625,
          "content": "//go:build go1.18\n// +build go1.18\n\npackage swag\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype testLogger struct {\n\tMessages []string\n}\n\nfunc (t *testLogger) Printf(format string, v ...interface{}) {\n\tt.Messages = append(t.Messages, fmt.Sprintf(format, v...))\n}\n\nfunc TestParseGenericsBasic(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/generics_basic\"\n\texpected, err := os.ReadFile(filepath.Join(searchDir, \"expected.json\"))\n\tassert.NoError(t, err)\n\n\tp := New()\n\tp.Overrides = map[string]string{\n\t\t\"types.Field[string]\":               \"string\",\n\t\t\"types.DoubleField[string,string]\":  \"[]string\",\n\t\t\"types.TrippleField[string,string]\": \"[][]string\",\n\t}\n\n\terr = p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\tb, err := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.NoError(t, err)\n\tassert.Equal(t, string(expected), string(b))\n}\n\nfunc TestParseGenericsArrays(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/generics_arrays\"\n\texpected, err := os.ReadFile(filepath.Join(searchDir, \"expected.json\"))\n\tassert.NoError(t, err)\n\n\tp := New()\n\terr = p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\tb, err := json.MarshalIndent(p.swagger, \"\", \"    \")\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, string(expected), string(b))\n}\n\nfunc TestParseGenericsNested(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/generics_nested\"\n\texpected, err := os.ReadFile(filepath.Join(searchDir, \"expected.json\"))\n\tassert.NoError(t, err)\n\n\tp := New()\n\terr = p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\tb, err := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.NoError(t, err)\n\tassert.Equal(t, string(expected), string(b))\n}\n\nfunc TestParseGenericsMultiLevelNesting(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/generics_multi_level_nesting\"\n\texpected, err := os.ReadFile(filepath.Join(searchDir, \"expected.json\"))\n\tassert.NoError(t, err)\n\n\tp := New()\n\terr = p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\tb, err := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.NoError(t, err)\n\tassert.Equal(t, string(expected), string(b))\n}\n\nfunc TestParseGenericsProperty(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/generics_property\"\n\texpected, err := os.ReadFile(filepath.Join(searchDir, \"expected.json\"))\n\tassert.NoError(t, err)\n\n\tp := New()\n\terr = p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\tb, err := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.NoError(t, err)\n\tassert.Equal(t, string(expected), string(b))\n}\n\nfunc TestParseGenericsNames(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/generics_names\"\n\texpected, err := os.ReadFile(filepath.Join(searchDir, \"expected.json\"))\n\tassert.NoError(t, err)\n\n\tp := New()\n\terr = p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\tb, err := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.NoError(t, err)\n\tassert.Equal(t, string(expected), string(b))\n}\n\nfunc TestParseGenericsPackageAlias(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/generics_package_alias/internal\"\n\texpected, err := os.ReadFile(filepath.Join(searchDir, \"expected.json\"))\n\tassert.NoError(t, err)\n\n\tp := New(SetParseDependency(1))\n\terr = p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\tb, err := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.NoError(t, err)\n\tassert.Equal(t, string(expected), string(b))\n}\n\nfunc TestParseGenericsFunctionScoped(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/generics_function_scoped\"\n\texpected, err := os.ReadFile(filepath.Join(searchDir, \"expected.json\"))\n\tassert.NoError(t, err)\n\n\tp := New()\n\terr = p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\tb, err := json.MarshalIndent(p.swagger, \"\", \"    \")\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, string(expected), string(b))\n}\n\nfunc TestParametrizeStruct(t *testing.T) {\n\tpd := PackagesDefinitions{\n\t\tpackages:          make(map[string]*PackageDefinitions),\n\t\tuniqueDefinitions: make(map[string]*TypeSpecDef),\n\t}\n\t// valid\n\ttypeSpec := pd.parametrizeGenericType(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test2\"}},\n\t\t&TypeSpecDef{\n\t\t\tFile: &ast.File{Name: &ast.Ident{Name: \"test\"}},\n\t\t\tTypeSpec: &ast.TypeSpec{\n\t\t\t\tName:       &ast.Ident{Name: \"Field\"},\n\t\t\t\tTypeParams: &ast.FieldList{List: []*ast.Field{{Names: []*ast.Ident{{Name: \"T\"}}}, {Names: []*ast.Ident{{Name: \"T2\"}}}}},\n\t\t\t\tType:       &ast.StructType{Struct: 100, Fields: &ast.FieldList{Opening: 101, Closing: 102}},\n\t\t\t}}, \"test.Field[string, []string]\")\n\tassert.NotNil(t, typeSpec)\n\tassert.Equal(t, \"$test.Field-string-array_string\", typeSpec.Name())\n\tassert.Equal(t, \"test.Field-string-array_string\", typeSpec.TypeName())\n\n\t// definition contains one type params, but two type params are provided\n\ttypeSpec = pd.parametrizeGenericType(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test2\"}},\n\t\t&TypeSpecDef{\n\t\t\tTypeSpec: &ast.TypeSpec{\n\t\t\t\tName:       &ast.Ident{Name: \"Field\"},\n\t\t\t\tTypeParams: &ast.FieldList{List: []*ast.Field{{Names: []*ast.Ident{{Name: \"T\"}}}}},\n\t\t\t\tType:       &ast.StructType{Struct: 100, Fields: &ast.FieldList{Opening: 101, Closing: 102}},\n\t\t\t}}, \"test.Field[string, string]\")\n\tassert.Nil(t, typeSpec)\n\n\t// definition contains two type params, but only one is used\n\ttypeSpec = pd.parametrizeGenericType(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test2\"}},\n\t\t&TypeSpecDef{\n\t\t\tTypeSpec: &ast.TypeSpec{\n\t\t\t\tName:       &ast.Ident{Name: \"Field\"},\n\t\t\t\tTypeParams: &ast.FieldList{List: []*ast.Field{{Names: []*ast.Ident{{Name: \"T\"}}}, {Names: []*ast.Ident{{Name: \"T2\"}}}}},\n\t\t\t\tType:       &ast.StructType{Struct: 100, Fields: &ast.FieldList{Opening: 101, Closing: 102}},\n\t\t\t}}, \"test.Field[string]\")\n\tassert.Nil(t, typeSpec)\n\n\t// name is not a valid type name\n\ttypeSpec = pd.parametrizeGenericType(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test2\"}},\n\t\t&TypeSpecDef{\n\t\t\tTypeSpec: &ast.TypeSpec{\n\t\t\t\tName:       &ast.Ident{Name: \"Field\"},\n\t\t\t\tTypeParams: &ast.FieldList{List: []*ast.Field{{Names: []*ast.Ident{{Name: \"T\"}}}, {Names: []*ast.Ident{{Name: \"T2\"}}}}},\n\t\t\t\tType:       &ast.StructType{Struct: 100, Fields: &ast.FieldList{Opening: 101, Closing: 102}},\n\t\t\t}}, \"test.Field[string\")\n\tassert.Nil(t, typeSpec)\n\n\ttypeSpec = pd.parametrizeGenericType(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test2\"}},\n\t\t&TypeSpecDef{\n\t\t\tTypeSpec: &ast.TypeSpec{\n\t\t\t\tName:       &ast.Ident{Name: \"Field\"},\n\t\t\t\tTypeParams: &ast.FieldList{List: []*ast.Field{{Names: []*ast.Ident{{Name: \"T\"}}}, {Names: []*ast.Ident{{Name: \"T2\"}}}}},\n\t\t\t\tType:       &ast.StructType{Struct: 100, Fields: &ast.FieldList{Opening: 101, Closing: 102}},\n\t\t\t}}, \"test.Field[string, [string]\")\n\tassert.Nil(t, typeSpec)\n\n\ttypeSpec = pd.parametrizeGenericType(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test2\"}},\n\t\t&TypeSpecDef{\n\t\t\tTypeSpec: &ast.TypeSpec{\n\t\t\t\tName:       &ast.Ident{Name: \"Field\"},\n\t\t\t\tTypeParams: &ast.FieldList{List: []*ast.Field{{Names: []*ast.Ident{{Name: \"T\"}}}, {Names: []*ast.Ident{{Name: \"T2\"}}}}},\n\t\t\t\tType:       &ast.StructType{Struct: 100, Fields: &ast.FieldList{Opening: 101, Closing: 102}},\n\t\t\t}}, \"test.Field[string, ]string]\")\n\tassert.Nil(t, typeSpec)\n}\n\nfunc TestSplitGenericsTypeNames(t *testing.T) {\n\tt.Parallel()\n\n\tfield, params := splitGenericsTypeName(\"test.Field\")\n\tassert.Empty(t, field)\n\tassert.Nil(t, params)\n\n\tfield, params = splitGenericsTypeName(\"test.Field]\")\n\tassert.Empty(t, field)\n\tassert.Nil(t, params)\n\n\tfield, params = splitGenericsTypeName(\"test.Field[string\")\n\tassert.Empty(t, field)\n\tassert.Nil(t, params)\n\n\tfield, params = splitGenericsTypeName(\"test.Field[string] \")\n\tassert.Equal(t, \"test.Field\", field)\n\tassert.Equal(t, []string{\"string\"}, params)\n\n\tfield, params = splitGenericsTypeName(\"test.Field[string, []string]\")\n\tassert.Equal(t, \"test.Field\", field)\n\tassert.Equal(t, []string{\"string\", \"[]string\"}, params)\n\n\tfield, params = splitGenericsTypeName(\"test.Field[test.Field[ string, []string] ]\")\n\tassert.Equal(t, \"test.Field\", field)\n\tassert.Equal(t, []string{\"test.Field[string,[]string]\"}, params)\n}\n\nfunc TestGetGenericFieldType(t *testing.T) {\n\tfield, err := getFieldType(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test\"}},\n\t\t&ast.IndexListExpr{\n\t\t\tX:       &ast.Ident{Name: \"types\", Obj: &ast.Object{Decl: &ast.TypeSpec{Name: &ast.Ident{Name: \"Field\"}}}},\n\t\t\tIndices: []ast.Expr{&ast.Ident{Name: \"string\"}},\n\t\t},\n\t\tnil,\n\t)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"test.Field[string]\", field)\n\n\tfield, err = getFieldType(\n\t\t&ast.File{Name: &ast.Ident{}},\n\t\t&ast.IndexListExpr{\n\t\t\tX:       &ast.Ident{Name: \"types\", Obj: &ast.Object{Decl: &ast.TypeSpec{Name: &ast.Ident{Name: \"Field\"}}}},\n\t\t\tIndices: []ast.Expr{&ast.Ident{Name: \"string\"}},\n\t\t},\n\t\tnil,\n\t)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"Field[string]\", field)\n\n\tfield, err = getFieldType(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test\"}},\n\t\t&ast.IndexListExpr{\n\t\t\tX:       &ast.Ident{Name: \"types\", Obj: &ast.Object{Decl: &ast.TypeSpec{Name: &ast.Ident{Name: \"Field\"}}}},\n\t\t\tIndices: []ast.Expr{&ast.Ident{Name: \"string\"}, &ast.Ident{Name: \"int\"}},\n\t\t},\n\t\tnil,\n\t)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"test.Field[string,int]\", field)\n\n\tfield, err = getFieldType(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test\"}},\n\t\t&ast.IndexListExpr{\n\t\t\tX:       &ast.Ident{Name: \"types\", Obj: &ast.Object{Decl: &ast.TypeSpec{Name: &ast.Ident{Name: \"Field\"}}}},\n\t\t\tIndices: []ast.Expr{&ast.Ident{Name: \"string\"}, &ast.ArrayType{Elt: &ast.Ident{Name: \"int\"}}},\n\t\t},\n\t\tnil,\n\t)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"test.Field[string,[]int]\", field)\n\n\tfield, err = getFieldType(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test\"}},\n\t\t&ast.IndexListExpr{\n\t\t\tX:       &ast.BadExpr{},\n\t\t\tIndices: []ast.Expr{&ast.Ident{Name: \"string\"}, &ast.Ident{Name: \"int\"}},\n\t\t},\n\t\tnil,\n\t)\n\tassert.Error(t, err)\n\n\tfield, err = getFieldType(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test\"}},\n\t\t&ast.IndexListExpr{\n\t\t\tX:       &ast.Ident{Name: \"types\", Obj: &ast.Object{Decl: &ast.TypeSpec{Name: &ast.Ident{Name: \"Field\"}}}},\n\t\t\tIndices: []ast.Expr{&ast.Ident{Name: \"string\"}, &ast.ArrayType{Elt: &ast.BadExpr{}}},\n\t\t},\n\t\tnil,\n\t)\n\tassert.Error(t, err)\n\n\tfield, err = getFieldType(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test\"}},\n\t\t&ast.IndexExpr{X: &ast.Ident{Name: \"Field\"}, Index: &ast.Ident{Name: \"string\"}},\n\t\tnil,\n\t)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"test.Field[string]\", field)\n\n\tfield, err = getFieldType(\n\t\t&ast.File{Name: nil},\n\t\t&ast.IndexExpr{X: &ast.Ident{Name: \"Field\"}, Index: &ast.Ident{Name: \"string\"}},\n\t\tnil,\n\t)\n\tassert.Error(t, err)\n\n\tfield, err = getFieldType(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test\"}},\n\t\t&ast.IndexExpr{X: &ast.BadExpr{}, Index: &ast.Ident{Name: \"string\"}},\n\t\tnil,\n\t)\n\tassert.Error(t, err)\n\n\tfield, err = getFieldType(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test\"}},\n\t\t&ast.IndexExpr{X: &ast.Ident{Name: \"Field\"}, Index: &ast.BadExpr{}},\n\t\tnil,\n\t)\n\tassert.Error(t, err)\n\n\tfield, err = getFieldType(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test\"}},\n\t\t&ast.IndexExpr{X: &ast.SelectorExpr{X: &ast.Ident{Name: \"field\"}, Sel: &ast.Ident{Name: \"Name\"}}, Index: &ast.Ident{Name: \"string\"}},\n\t\tnil,\n\t)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"field.Name[string]\", field)\n}\n\nfunc TestGetGenericTypeName(t *testing.T) {\n\tfield, err := getGenericTypeName(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test\"}},\n\t\t&ast.Ident{Name: \"types\", Obj: &ast.Object{Decl: &ast.TypeSpec{Name: &ast.Ident{Name: \"Field\"}}}},\n\t)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"test.Field\", field)\n\n\tfield, err = getGenericTypeName(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test\"}},\n\t\t&ast.ArrayType{Elt: &ast.Ident{Name: \"types\", Obj: &ast.Object{Decl: &ast.TypeSpec{Name: &ast.Ident{Name: \"Field\"}}}}},\n\t)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"test.Field\", field)\n\n\tfield, err = getGenericTypeName(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test\"}},\n\t\t&ast.SelectorExpr{X: &ast.Ident{Name: \"field\"}, Sel: &ast.Ident{Name: \"Name\"}},\n\t)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"field.Name\", field)\n\n\t_, err = getGenericTypeName(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test\"}},\n\t\t&ast.BadExpr{},\n\t)\n\tassert.Error(t, err)\n}\n\nfunc TestParseGenericTypeExpr(t *testing.T) {\n\tt.Parallel()\n\n\tparser := New()\n\tlogger := &testLogger{}\n\tSetDebugger(logger)(parser)\n\n\t_, _ = parser.parseGenericTypeExpr(&ast.File{}, &ast.InterfaceType{})\n\tassert.Empty(t, logger.Messages)\n\t_, _ = parser.parseGenericTypeExpr(&ast.File{}, &ast.StructType{})\n\tassert.Empty(t, logger.Messages)\n\t_, _ = parser.parseGenericTypeExpr(&ast.File{}, &ast.Ident{})\n\tassert.Empty(t, logger.Messages)\n\t_, _ = parser.parseGenericTypeExpr(&ast.File{}, &ast.StarExpr{})\n\tassert.Empty(t, logger.Messages)\n\t_, _ = parser.parseGenericTypeExpr(&ast.File{}, &ast.SelectorExpr{})\n\tassert.Empty(t, logger.Messages)\n\t_, _ = parser.parseGenericTypeExpr(&ast.File{}, &ast.ArrayType{})\n\tassert.Empty(t, logger.Messages)\n\t_, _ = parser.parseGenericTypeExpr(&ast.File{}, &ast.MapType{})\n\tassert.Empty(t, logger.Messages)\n\t_, _ = parser.parseGenericTypeExpr(&ast.File{}, &ast.FuncType{})\n\tassert.Empty(t, logger.Messages)\n\t_, _ = parser.parseGenericTypeExpr(&ast.File{}, &ast.BadExpr{})\n\tassert.NotEmpty(t, logger.Messages)\n\tassert.Len(t, logger.Messages, 1)\n\n\tparser.packages.uniqueDefinitions[\"field.Name[string]\"] = &TypeSpecDef{\n\t\tFile: &ast.File{Name: &ast.Ident{Name: \"test\"}},\n\t\tTypeSpec: &ast.TypeSpec{\n\t\t\tName:       &ast.Ident{Name: \"Field\"},\n\t\t\tTypeParams: &ast.FieldList{List: []*ast.Field{{Names: []*ast.Ident{{Name: \"T\"}}}}},\n\t\t\tType:       &ast.StructType{Struct: 100, Fields: &ast.FieldList{Opening: 101, Closing: 102}},\n\t\t},\n\t}\n\tspec, err := parser.parseTypeExpr(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test\"}},\n\t\t&ast.IndexExpr{X: &ast.SelectorExpr{X: &ast.Ident{Name: \"field\"}, Sel: &ast.Ident{Name: \"Name\"}}, Index: &ast.Ident{Name: \"string\"}},\n\t\tfalse,\n\t)\n\tassert.NotNil(t, spec)\n\tassert.NoError(t, err)\n\n\tlogger.Messages = []string{}\n\tspec, err = parser.parseTypeExpr(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test\"}},\n\t\t&ast.IndexExpr{X: &ast.BadExpr{}, Index: &ast.Ident{Name: \"string\"}},\n\t\tfalse,\n\t)\n\tassert.NotNil(t, spec)\n\tassert.Equal(t, \"object\", spec.SchemaProps.Type[0])\n\tassert.NotEmpty(t, logger.Messages)\n\tassert.Len(t, logger.Messages, 1)\n\n\tlogger.Messages = []string{}\n\tspec, err = parser.parseTypeExpr(\n\t\t&ast.File{Name: &ast.Ident{Name: \"test\"}},\n\t\t&ast.BadExpr{},\n\t\tfalse,\n\t)\n\tassert.NotNil(t, spec)\n\tassert.Equal(t, \"object\", spec.SchemaProps.Type[0])\n\tassert.NotEmpty(t, logger.Messages)\n\tassert.Len(t, logger.Messages, 1)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.203125,
          "content": "module github.com/swaggo/swag\n\ngo 1.18\n\nrequire (\n\tgithub.com/KyleBanks/depth v1.2.1\n\tgithub.com/go-openapi/spec v0.20.4\n\tgithub.com/stretchr/testify v1.7.0\n\tgithub.com/urfave/cli/v2 v2.3.0\n\tgolang.org/x/text v0.14.0\n\tgolang.org/x/tools v0.7.0\n\tsigs.k8s.io/yaml v1.3.0\n)\n\nrequire (\n\tgithub.com/PuerkitoBio/purell v1.1.1 // indirect\n\tgithub.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 // indirect\n\tgithub.com/cpuguy83/go-md2man/v2 v2.0.0-20190314233015-f79a8a8ca69d // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/go-openapi/jsonpointer v0.19.5 // indirect\n\tgithub.com/go-openapi/jsonreference v0.19.6 // indirect\n\tgithub.com/go-openapi/swag v0.19.15 // indirect\n\tgithub.com/josharian/intern v1.0.0 // indirect\n\tgithub.com/mailru/easyjson v0.7.6 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/russross/blackfriday/v2 v2.0.1 // indirect\n\tgithub.com/shurcooL/sanitized_anchor_name v1.0.0 // indirect\n\tgolang.org/x/mod v0.9.0 // indirect\n\tgolang.org/x/net v0.23.0 // indirect\n\tgolang.org/x/sys v0.18.0 // indirect\n\tgopkg.in/yaml.v2 v2.4.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.0 // indirect\n)\n\nretract (\n\tv1.16.0 // published accidentally\n\tv1.9.0 // published accidentally\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 7.0869140625,
          "content": "github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/KyleBanks/depth v1.2.1 h1:5h8fQADFrWtarTdtDudMmGsC7GPbOAu6RVB3ffsVFHc=\ngithub.com/KyleBanks/depth v1.2.1/go.mod h1:jzSb9d0L43HxTQfT+oSA1EEp2q+ne2uh6XgeJcm8brE=\ngithub.com/PuerkitoBio/purell v1.1.1 h1:WEQqlqaGbrPkxLJWfBwQmfEAE1Z7ONdDLqrN38tNFfI=\ngithub.com/PuerkitoBio/purell v1.1.1/go.mod h1:c11w/QuzBsJSee3cPx9rAFu61PvFxuPbtSwDGJws/X0=\ngithub.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 h1:d+Bc7a5rLufV/sSk/8dngufqelfh6jnri85riMAaF/M=\ngithub.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578/go.mod h1:uGdkoq3SwY9Y+13GIhn11/XLaGBb4BfwItxLd5jeuXE=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.0-20190314233015-f79a8a8ca69d h1:U+s90UTSYgptZMwQh2aRr3LuazLJIa+Pg3Kc1ylSYVY=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.0-20190314233015-f79a8a8ca69d/go.mod h1:maD7wRr/U5Z6m/iR4s+kqSMx2CaBsrgA7czyZG/E6dU=\ngithub.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/go-openapi/jsonpointer v0.19.3/go.mod h1:Pl9vOtqEWErmShwVjC8pYs9cog34VGT37dQOVbmoatg=\ngithub.com/go-openapi/jsonpointer v0.19.5 h1:gZr+CIYByUqjcgeLXnQu2gHYQC9o73G2XUeOFYEICuY=\ngithub.com/go-openapi/jsonpointer v0.19.5/go.mod h1:Pl9vOtqEWErmShwVjC8pYs9cog34VGT37dQOVbmoatg=\ngithub.com/go-openapi/jsonreference v0.19.6 h1:UBIxjkht+AWIgYzCDSv2GN+E/togfwXUJFRTWhl2Jjs=\ngithub.com/go-openapi/jsonreference v0.19.6/go.mod h1:diGHMEHg2IqXZGKxqyvWdfWU/aim5Dprw5bqpKkTvns=\ngithub.com/go-openapi/spec v0.20.4 h1:O8hJrt0UMnhHcluhIdUgCLRWyM2x7QkBXRvOs7m+O1M=\ngithub.com/go-openapi/spec v0.20.4/go.mod h1:faYFR1CvsJZ0mNsmsphTMSoRrNV3TEDoAM7FOEWeq8I=\ngithub.com/go-openapi/swag v0.19.5/go.mod h1:POnQmlKehdgb5mhVOsnJFsivZCEZ/vjK9gh66Z9tfKk=\ngithub.com/go-openapi/swag v0.19.15 h1:D2NRCBzS9/pEY3gP9Nl8aDqGUcPFrwG2p+CNFrLyrCM=\ngithub.com/go-openapi/swag v0.19.15/go.mod h1:QYRuS/SOXUCsnplDa677K7+DxSOj6IPNl/eQntq43wQ=\ngithub.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=\ngithub.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/mailru/easyjson v0.0.0-20190614124828-94de47d64c63/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=\ngithub.com/mailru/easyjson v0.0.0-20190626092158-b2ccc519800e/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=\ngithub.com/mailru/easyjson v0.7.6 h1:8yTIVnZgCoiM1TgqoeTl+LfU5Jg6/xL3QhGQnimLYnA=\ngithub.com/mailru/easyjson v0.7.6/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e h1:fD57ERR4JtEqsWbfPhv4DMiApHyliiK5xCTNVSPiaAs=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e/go.mod h1:zD1mROLANZcx1PVRCS0qkT7pwLkGfwJo4zjcN/Tysno=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/russross/blackfriday/v2 v2.0.1 h1:lPqVAte+HuHNfhJ/0LC98ESWRz8afy9tM/0RK8m9o+Q=\ngithub.com/russross/blackfriday/v2 v2.0.1/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/shurcooL/sanitized_anchor_name v1.0.0 h1:PdmoCO6wvbs+7yrJyMORt4/BmY5IYyJwS/kOiWx8mHo=\ngithub.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/urfave/cli/v2 v2.3.0 h1:qph92Y649prgesehzOrQjdWyxFOp/QVM+6imKHad91M=\ngithub.com/urfave/cli/v2 v2.3.0/go.mod h1:LJmUH05zAU44vOAcrfzZQKsZbVcdbOG8rtL3/XcUArI=\ngolang.org/x/mod v0.9.0 h1:KENHtAZL2y3NLMYZeHY9DW8HW8V+kQyJsY/V9JlKvCs=\ngolang.org/x/mod v0.9.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/net v0.0.0-20210421230115-4e50805a0758/go.mod h1:72T/g9IO56b78aLF+1Kcs5dz7/ng1VjMUvfKvpfy+jM=\ngolang.org/x/net v0.23.0 h1:7EYJ93RZ9vYSZAIb2x3lnuvqO5zneoD6IvWjuhfxjTs=\ngolang.org/x/net v0.23.0/go.mod h1:JKghWKKOSdJwpW2GEx0Ja7fmaKnMsbu+MWVZTokSYmg=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210420072515-93ed5bcd2bfe/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.18.0 h1:DBdB3niSjOA/O0blCZBqDefyWNYveAYMNF1Wum0DYQ4=\ngolang.org/x/sys v0.18.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.14.0 h1:ScX5w1eTa3QqT8oi6+ziP7dTV1S2+ALU0bI+0zXKWiQ=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.7.0 h1:W4OVu8VVOaIO0yzWMNdepAulS7YfoS3Zabrm8DOXXU4=\ngolang.org/x/tools v0.7.0/go.mod h1:4pg6aUX35JBAogB10C9AtvVL+qowtN4pT3CGSQex14s=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f h1:BLraFXnmrev5lT+xlilqcH8XK9/i0At2xKjWk4p6zsU=\ngopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.3/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.0-20200615113413-eeeca48fe776/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.0 h1:hjy8E9ON/egN1tAYqKb61G10WtihqetD4sz2H+8nIeA=\ngopkg.in/yaml.v3 v3.0.0/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nsigs.k8s.io/yaml v1.3.0 h1:a2VclLzOGrwOHDiV8EfBGhvjHvP46CtW5j6POvhYGGo=\nsigs.k8s.io/yaml v1.3.0/go.mod h1:GeOyir5tyXNByN85N/dRIT9es5UQNerPYEKK56eTBm8=\n"
        },
        {
          "name": "golist.go",
          "type": "blob",
          "size": 1.6181640625,
          "content": "package swag\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"go/build\"\n\t\"os/exec\"\n\t\"path/filepath\"\n)\n\nfunc listPackages(ctx context.Context, dir string, env []string, args ...string) (pkgs []*build.Package, finalErr error) {\n\tcmd := exec.CommandContext(ctx, \"go\", append([]string{\"list\", \"-json\", \"-e\"}, args...)...)\n\tcmd.Env = env\n\tcmd.Dir = dir\n\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar stderrBuf bytes.Buffer\n\tcmd.Stderr = &stderrBuf\n\tdefer func() {\n\t\tif stderrBuf.Len() > 0 {\n\t\t\tfinalErr = fmt.Errorf(\"%v\\n%s\", finalErr, stderrBuf.Bytes())\n\t\t}\n\t}()\n\n\terr = cmd.Start()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdec := json.NewDecoder(stdout)\n\tfor dec.More() {\n\t\tvar pkg build.Package\n\t\terr = dec.Decode(&pkg)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpkgs = append(pkgs, &pkg)\n\t}\n\terr = cmd.Wait()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn pkgs, nil\n}\n\nfunc (parser *Parser) getAllGoFileInfoFromDepsByList(pkg *build.Package, parseFlag ParseFlag) error {\n\tignoreInternal := pkg.Goroot && !parser.ParseInternal\n\tif ignoreInternal { // ignored internal\n\t\treturn nil\n\t}\n\n\tif parser.skipPackageByPrefix(pkg.ImportPath) {\n\t\treturn nil // ignored by user-defined package path prefixes\n\t}\n\n\tsrcDir := pkg.Dir\n\tvar err error\n\tfor i := range pkg.GoFiles {\n\t\terr = parser.parseFile(pkg.ImportPath, filepath.Join(srcDir, pkg.GoFiles[i]), nil, parseFlag)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// parse .go source files that import \"C\"\n\tfor i := range pkg.CgoFiles {\n\t\terr = parser.parseFile(pkg.ImportPath, filepath.Join(srcDir, pkg.CgoFiles[i]), nil, parseFlag)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "golist_test.go",
          "type": "blob",
          "size": 2.318359375,
          "content": "package swag\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"go/build\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestListPackages(t *testing.T) {\n\n\tcases := []struct {\n\t\tname      string\n\t\targs      []string\n\t\tsearchDir string\n\t\texcept    error\n\t}{\n\t\t{\n\t\t\tname:      \"errorArgs\",\n\t\t\targs:      []string{\"-abc\"},\n\t\t\tsearchDir: \"testdata/golist\",\n\t\t\texcept:    fmt.Errorf(\"exit status 2\"),\n\t\t},\n\t\t{\n\t\t\tname:      \"normal\",\n\t\t\targs:      []string{\"-deps\"},\n\t\t\tsearchDir: \"testdata/golist\",\n\t\t\texcept:    nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"list error\",\n\t\t\targs:      []string{\"-deps\"},\n\t\t\tsearchDir: \"testdata/golist_not_exist\",\n\t\t\texcept:    errors.New(\"searchDir not exist\"),\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\t_, err := listPackages(context.TODO(), c.searchDir, nil, c.args...)\n\t\t\tif c.except != nil {\n\t\t\t\tassert.NotNil(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetAllGoFileInfoFromDepsByList(t *testing.T) {\n\tp := New(ParseUsingGoList(true))\n\tpwd, err := os.Getwd()\n\tassert.NoError(t, err)\n\tcases := []struct {\n\t\tname           string\n\t\tbuildPackage   *build.Package\n\t\tignoreInternal bool\n\t\texcept         error\n\t}{\n\t\t{\n\t\t\tname: \"normal\",\n\t\t\tbuildPackage: &build.Package{\n\t\t\t\tName:       \"main\",\n\t\t\t\tImportPath: \"github.com/swaggo/swag/testdata/golist\",\n\t\t\t\tDir:        \"testdata/golist\",\n\t\t\t\tGoFiles:    []string{\"main.go\"},\n\t\t\t\tCgoFiles:   []string{\"api/api.go\"},\n\t\t\t},\n\t\t\texcept: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"ignore internal\",\n\t\t\tbuildPackage: &build.Package{\n\t\t\t\tGoroot: true,\n\t\t\t},\n\t\t\tignoreInternal: true,\n\t\t\texcept:         nil,\n\t\t},\n\t\t{\n\t\t\tname: \"gofiles error\",\n\t\t\tbuildPackage: &build.Package{\n\t\t\t\tDir:     \"testdata/golist_not_exist\",\n\t\t\t\tGoFiles: []string{\"main.go\"},\n\t\t\t},\n\t\t\texcept: errors.New(\"file not exist\"),\n\t\t},\n\t\t{\n\t\t\tname: \"cgofiles error\",\n\t\t\tbuildPackage: &build.Package{\n\t\t\t\tDir:      \"testdata/golist_not_exist\",\n\t\t\t\tCgoFiles: []string{\"main.go\"},\n\t\t\t},\n\t\t\texcept: errors.New(\"file not exist\"),\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tif c.ignoreInternal {\n\t\t\t\tp.ParseInternal = false\n\t\t\t}\n\t\t\tc.buildPackage.Dir = filepath.Join(pwd, c.buildPackage.Dir)\n\t\t\terr := p.getAllGoFileInfoFromDepsByList(c.buildPackage, ParseModels)\n\t\t\tif c.except != nil {\n\t\t\t\tassert.NotNil(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "license",
          "type": "blob",
          "size": 1.041015625,
          "content": "MIT License\n\nCopyright (c) 2017 Eason Lin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "operation.go",
          "type": "blob",
          "size": 34.4501953125,
          "content": "package swag\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"go/ast\"\n\tgoparser \"go/parser\"\n\t\"go/token\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/go-openapi/spec\"\n\t\"golang.org/x/tools/go/loader\"\n)\n\n// RouteProperties describes HTTP properties of a single router comment.\ntype RouteProperties struct {\n\tHTTPMethod string\n\tPath       string\n\tDeprecated bool\n}\n\n// Operation describes a single API operation on a path.\n// For more information: https://github.com/swaggo/swag#api-operation\ntype Operation struct {\n\tparser              *Parser\n\tcodeExampleFilesDir string\n\tspec.Operation\n\tRouterProperties []RouteProperties\n\tState            string\n}\n\nvar mimeTypeAliases = map[string]string{\n\t\"json\":                  \"application/json\",\n\t\"xml\":                   \"text/xml\",\n\t\"plain\":                 \"text/plain\",\n\t\"html\":                  \"text/html\",\n\t\"mpfd\":                  \"multipart/form-data\",\n\t\"x-www-form-urlencoded\": \"application/x-www-form-urlencoded\",\n\t\"json-api\":              \"application/vnd.api+json\",\n\t\"json-stream\":           \"application/x-json-stream\",\n\t\"octet-stream\":          \"application/octet-stream\",\n\t\"png\":                   \"image/png\",\n\t\"jpeg\":                  \"image/jpeg\",\n\t\"gif\":                   \"image/gif\",\n}\n\nvar mimeTypePattern = regexp.MustCompile(\"^[^/]+/[^/]+$\")\nvar securityPairSepPattern = regexp.MustCompile(`\\|\\||&&`) // || for compatibility with old version, && for clarity\n\n// NewOperation creates a new Operation with default properties.\n// map[int]Response.\nfunc NewOperation(parser *Parser, options ...func(*Operation)) *Operation {\n\tif parser == nil {\n\t\tparser = New()\n\t}\n\n\tresult := &Operation{\n\t\tparser:           parser,\n\t\tRouterProperties: []RouteProperties{},\n\t\tOperation: spec.Operation{\n\t\t\tOperationProps: spec.OperationProps{\n\t\t\t\tID:           \"\",\n\t\t\t\tDescription:  \"\",\n\t\t\t\tSummary:      \"\",\n\t\t\t\tSecurity:     nil,\n\t\t\t\tExternalDocs: nil,\n\t\t\t\tDeprecated:   false,\n\t\t\t\tTags:         []string{},\n\t\t\t\tConsumes:     []string{},\n\t\t\t\tProduces:     []string{},\n\t\t\t\tSchemes:      []string{},\n\t\t\t\tParameters:   []spec.Parameter{},\n\t\t\t\tResponses: &spec.Responses{\n\t\t\t\t\tVendorExtensible: spec.VendorExtensible{\n\t\t\t\t\t\tExtensions: spec.Extensions{},\n\t\t\t\t\t},\n\t\t\t\t\tResponsesProps: spec.ResponsesProps{\n\t\t\t\t\t\tDefault:             nil,\n\t\t\t\t\t\tStatusCodeResponses: make(map[int]spec.Response),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tVendorExtensible: spec.VendorExtensible{\n\t\t\t\tExtensions: spec.Extensions{},\n\t\t\t},\n\t\t},\n\t\tcodeExampleFilesDir: \"\",\n\t}\n\n\tfor _, option := range options {\n\t\toption(result)\n\t}\n\n\treturn result\n}\n\n// SetCodeExampleFilesDirectory sets the directory to search for codeExamples.\nfunc SetCodeExampleFilesDirectory(directoryPath string) func(*Operation) {\n\treturn func(o *Operation) {\n\t\to.codeExampleFilesDir = directoryPath\n\t}\n}\n\n// ParseComment parses comment for given comment string and returns error if error occurs.\nfunc (operation *Operation) ParseComment(comment string, astFile *ast.File) error {\n\tcommentLine := strings.TrimSpace(strings.TrimLeft(comment, \"/\"))\n\tif len(commentLine) == 0 {\n\t\treturn nil\n\t}\n\n\tfields := FieldsByAnySpace(commentLine, 2)\n\tattribute := fields[0]\n\tlowerAttribute := strings.ToLower(attribute)\n\tvar lineRemainder string\n\tif len(fields) > 1 {\n\t\tlineRemainder = fields[1]\n\t}\n\tswitch lowerAttribute {\n\tcase stateAttr:\n\t\toperation.ParseStateComment(lineRemainder)\n\tcase descriptionAttr:\n\t\toperation.ParseDescriptionComment(lineRemainder)\n\tcase descriptionMarkdownAttr:\n\t\tcommentInfo, err := getMarkdownForTag(lineRemainder, operation.parser.markdownFileDir)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\toperation.ParseDescriptionComment(string(commentInfo))\n\tcase summaryAttr:\n\t\toperation.Summary = lineRemainder\n\tcase idAttr:\n\t\toperation.ID = lineRemainder\n\tcase tagsAttr:\n\t\toperation.ParseTagsComment(lineRemainder)\n\tcase acceptAttr:\n\t\treturn operation.ParseAcceptComment(lineRemainder)\n\tcase produceAttr:\n\t\treturn operation.ParseProduceComment(lineRemainder)\n\tcase paramAttr:\n\t\treturn operation.ParseParamComment(lineRemainder, astFile)\n\tcase successAttr, failureAttr, responseAttr:\n\t\treturn operation.ParseResponseComment(lineRemainder, astFile)\n\tcase headerAttr:\n\t\treturn operation.ParseResponseHeaderComment(lineRemainder, astFile)\n\tcase routerAttr:\n\t\treturn operation.ParseRouterComment(lineRemainder, false)\n\tcase deprecatedRouterAttr:\n\t\treturn operation.ParseRouterComment(lineRemainder, true)\n\tcase securityAttr:\n\t\treturn operation.ParseSecurityComment(lineRemainder)\n\tcase deprecatedAttr:\n\t\toperation.Deprecate()\n\tcase xCodeSamplesAttr:\n\t\treturn operation.ParseCodeSample(attribute, commentLine, lineRemainder)\n\tdefault:\n\t\treturn operation.ParseMetadata(attribute, lowerAttribute, lineRemainder)\n\t}\n\n\treturn nil\n}\n\n// ParseCodeSample parse code sample.\nfunc (operation *Operation) ParseCodeSample(attribute, _, lineRemainder string) error {\n\tif lineRemainder == \"file\" {\n\t\tdata, err := getCodeExampleForSummary(operation.Summary, operation.codeExampleFilesDir)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar valueJSON interface{}\n\n\t\terr = json.Unmarshal(data, &valueJSON)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"annotation %s need a valid json value\", attribute)\n\t\t}\n\n\t\t// don't use the method provided by spec lib, because it will call toLower() on attribute names, which is wrongly\n\t\toperation.Extensions[attribute[1:]] = valueJSON\n\n\t\treturn nil\n\t}\n\n\t// Fallback into existing logic\n\treturn operation.ParseMetadata(attribute, strings.ToLower(attribute), lineRemainder)\n}\n\n// ParseStateComment parse state comment.\nfunc (operation *Operation) ParseStateComment(lineRemainder string) {\n\toperation.State = lineRemainder\n}\n\n// ParseDescriptionComment parse description comment.\nfunc (operation *Operation) ParseDescriptionComment(lineRemainder string) {\n\tif operation.Description == \"\" {\n\t\toperation.Description = lineRemainder\n\n\t\treturn\n\t}\n\n\toperation.Description += \"\\n\" + lineRemainder\n}\n\n// ParseMetadata parse metadata.\nfunc (operation *Operation) ParseMetadata(attribute, lowerAttribute, lineRemainder string) error {\n\t// parsing specific meta data extensions\n\tif strings.HasPrefix(lowerAttribute, \"@x-\") {\n\t\tif len(lineRemainder) == 0 {\n\t\t\treturn fmt.Errorf(\"annotation %s need a value\", attribute)\n\t\t}\n\n\t\tvar valueJSON interface{}\n\n\t\terr := json.Unmarshal([]byte(lineRemainder), &valueJSON)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"annotation %s need a valid json value\", attribute)\n\t\t}\n\n\t\t// don't use the method provided by spec lib, because it will call toLower() on attribute names, which is wrongly\n\t\toperation.Extensions[attribute[1:]] = valueJSON\n\t}\n\n\treturn nil\n}\n\nvar paramPattern = regexp.MustCompile(`(\\S+)\\s+(\\w+)\\s+([\\S. ]+?)\\s+(\\w+)\\s+\"([^\"]+)\"`)\n\nfunc findInSlice(arr []string, target string) bool {\n\tfor _, str := range arr {\n\t\tif str == target {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// ParseParamComment parses params return []string of param properties\n// E.g. @Param\tqueryText\t\tformData\t      string\t  true\t\t        \"The email for login\"\n//\n//\t[param name]    [paramType] [data type]  [is mandatory?]   [Comment]\n//\n// E.g. @Param   some_id     path    int     true        \"Some ID\".\nfunc (operation *Operation) ParseParamComment(commentLine string, astFile *ast.File) error {\n\tmatches := paramPattern.FindStringSubmatch(commentLine)\n\tif len(matches) != 6 {\n\t\treturn fmt.Errorf(\"missing required param comment parameters \\\"%s\\\"\", commentLine)\n\t}\n\n\tname := matches[1]\n\tparamType := matches[2]\n\trefType, format := TransToValidSchemeTypeWithFormat(matches[3])\n\n\t// Detect refType\n\tobjectType := OBJECT\n\n\tif strings.HasPrefix(refType, \"[]\") {\n\t\tobjectType = ARRAY\n\t\trefType = strings.TrimPrefix(refType, \"[]\")\n\t\trefType, format = TransToValidSchemeTypeWithFormat(refType)\n\t} else if IsPrimitiveType(refType) ||\n\t\tparamType == \"formData\" && refType == \"file\" {\n\t\tobjectType = PRIMITIVE\n\t}\n\n\tvar enums []interface{}\n\tif !IsPrimitiveType(refType) {\n\t\tschema, _ := operation.parser.getTypeSchema(refType, astFile, false)\n\t\tif schema != nil && len(schema.Type) == 1 && schema.Enum != nil {\n\t\t\tif objectType == OBJECT {\n\t\t\t\tobjectType = PRIMITIVE\n\t\t\t}\n\t\t\trefType, format = TransToValidSchemeTypeWithFormat(schema.Type[0])\n\t\t\tenums = schema.Enum\n\t\t}\n\t}\n\n\trequiredText := strings.ToLower(matches[4])\n\trequired := requiredText == \"true\" || requiredText == requiredLabel\n\tdescription := strings.Join(strings.Split(matches[5], \"\\\\n\"), \"\\n\")\n\n\tparam := createParameter(paramType, description, name, objectType, refType, format, required, enums, operation.parser.collectionFormatInQuery)\n\n\tswitch paramType {\n\tcase \"path\", \"header\", \"query\", \"formData\":\n\t\tswitch objectType {\n\t\tcase ARRAY:\n\t\t\tif !IsPrimitiveType(refType) && !(refType == \"file\" && paramType == \"formData\") {\n\t\t\t\treturn fmt.Errorf(\"%s is not supported array type for %s\", refType, paramType)\n\t\t\t}\n\t\tcase PRIMITIVE:\n\t\t\tbreak\n\t\tcase OBJECT:\n\t\t\tschema, err := operation.parser.getTypeSchema(refType, astFile, false)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif len(schema.Properties) == 0 {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\titems := schema.Properties.ToOrderedSchemaItems()\n\n\t\t\tfor _, item := range items {\n\t\t\t\tname, prop := item.Name, &item.Schema\n\t\t\t\tif len(prop.Type) == 0 {\n\t\t\t\t\tprop = operation.parser.getUnderlyingSchema(prop)\n\t\t\t\t\tif len(prop.Type) == 0 {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnameOverrideType := paramType\n\t\t\t\t// query also uses formData tags\n\t\t\t\tif paramType == \"query\" {\n\t\t\t\t\tnameOverrideType = \"formData\"\n\t\t\t\t}\n\t\t\t\t// load overridden type specific name from extensions if exists\n\t\t\t\tif nameVal, ok := item.Schema.Extensions[nameOverrideType]; ok {\n\t\t\t\t\tname = nameVal.(string)\n\t\t\t\t}\n\n\t\t\t\tswitch {\n\t\t\t\tcase prop.Type[0] == ARRAY:\n\t\t\t\t\tif prop.Items.Schema == nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\titemSchema := prop.Items.Schema\n\t\t\t\t\tif len(itemSchema.Type) == 0 {\n\t\t\t\t\t\titemSchema = operation.parser.getUnderlyingSchema(prop.Items.Schema)\n\t\t\t\t\t}\n\t\t\t\t\tif itemSchema == nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif len(itemSchema.Type) == 0 {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif !IsSimplePrimitiveType(itemSchema.Type[0]) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tparam = createParameter(paramType, prop.Description, name, prop.Type[0], itemSchema.Type[0], format, findInSlice(schema.Required, item.Name), itemSchema.Enum, operation.parser.collectionFormatInQuery)\n\n\t\t\t\tcase IsSimplePrimitiveType(prop.Type[0]):\n\t\t\t\t\tparam = createParameter(paramType, prop.Description, name, PRIMITIVE, prop.Type[0], format, findInSlice(schema.Required, item.Name), nil, operation.parser.collectionFormatInQuery)\n\t\t\t\tdefault:\n\t\t\t\t\toperation.parser.debug.Printf(\"skip field [%s] in %s is not supported type for %s\", name, refType, paramType)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tparam.Nullable = prop.Nullable\n\t\t\t\tparam.Format = prop.Format\n\t\t\t\tparam.Default = prop.Default\n\t\t\t\tparam.Example = prop.Example\n\t\t\t\tparam.Extensions = prop.Extensions\n\t\t\t\tparam.CommonValidations.Maximum = prop.Maximum\n\t\t\t\tparam.CommonValidations.Minimum = prop.Minimum\n\t\t\t\tparam.CommonValidations.ExclusiveMaximum = prop.ExclusiveMaximum\n\t\t\t\tparam.CommonValidations.ExclusiveMinimum = prop.ExclusiveMinimum\n\t\t\t\tparam.CommonValidations.MaxLength = prop.MaxLength\n\t\t\t\tparam.CommonValidations.MinLength = prop.MinLength\n\t\t\t\tparam.CommonValidations.Pattern = prop.Pattern\n\t\t\t\tparam.CommonValidations.MaxItems = prop.MaxItems\n\t\t\t\tparam.CommonValidations.MinItems = prop.MinItems\n\t\t\t\tparam.CommonValidations.UniqueItems = prop.UniqueItems\n\t\t\t\tparam.CommonValidations.MultipleOf = prop.MultipleOf\n\t\t\t\tparam.CommonValidations.Enum = prop.Enum\n\t\t\t\toperation.Operation.Parameters = append(operation.Operation.Parameters, param)\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}\n\tcase \"body\":\n\t\tif objectType == PRIMITIVE {\n\t\t\tparam.Schema = PrimitiveSchema(refType)\n\t\t} else {\n\t\t\tschema, err := operation.parseAPIObjectSchema(commentLine, objectType, refType, astFile)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tparam.Schema = schema\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"not supported paramType: %s\", paramType)\n\t}\n\n\terr := operation.parseParamAttribute(commentLine, objectType, refType, paramType, &param)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toperation.Operation.Parameters = append(operation.Operation.Parameters, param)\n\n\treturn nil\n}\n\nconst (\n\tformTag             = \"form\"\n\tjsonTag             = \"json\"\n\turiTag              = \"uri\"\n\theaderTag           = \"header\"\n\tbindingTag          = \"binding\"\n\tdefaultTag          = \"default\"\n\tenumsTag            = \"enums\"\n\texampleTag          = \"example\"\n\tschemaExampleTag    = \"schemaExample\"\n\tformatTag           = \"format\"\n\ttitleTag            = \"title\"\n\tvalidateTag         = \"validate\"\n\tminimumTag          = \"minimum\"\n\tmaximumTag          = \"maximum\"\n\tminLengthTag        = \"minLength\"\n\tmaxLengthTag        = \"maxLength\"\n\tmultipleOfTag       = \"multipleOf\"\n\treadOnlyTag         = \"readonly\"\n\textensionsTag       = \"extensions\"\n\tcollectionFormatTag = \"collectionFormat\"\n)\n\nvar regexAttributes = map[string]*regexp.Regexp{\n\t// for Enums(A, B)\n\tenumsTag: regexp.MustCompile(`(?i)\\s+enums\\(.*\\)`),\n\t// for maximum(0)\n\tmaximumTag: regexp.MustCompile(`(?i)\\s+maxinum|maximum\\(.*\\)`),\n\t// for minimum(0)\n\tminimumTag: regexp.MustCompile(`(?i)\\s+mininum|minimum\\(.*\\)`),\n\t// for default(0)\n\tdefaultTag: regexp.MustCompile(`(?i)\\s+default\\(.*\\)`),\n\t// for minlength(0)\n\tminLengthTag: regexp.MustCompile(`(?i)\\s+minlength\\(.*\\)`),\n\t// for maxlength(0)\n\tmaxLengthTag: regexp.MustCompile(`(?i)\\s+maxlength\\(.*\\)`),\n\t// for format(email)\n\tformatTag: regexp.MustCompile(`(?i)\\s+format\\(.*\\)`),\n\t// for extensions(x-example=test)\n\textensionsTag: regexp.MustCompile(`(?i)\\s+extensions\\(.*\\)`),\n\t// for collectionFormat(csv)\n\tcollectionFormatTag: regexp.MustCompile(`(?i)\\s+collectionFormat\\(.*\\)`),\n\t// example(0)\n\texampleTag: regexp.MustCompile(`(?i)\\s+example\\(.*\\)`),\n\t// schemaExample(0)\n\tschemaExampleTag: regexp.MustCompile(`(?i)\\s+schemaExample\\(.*\\)`),\n}\n\nfunc (operation *Operation) parseParamAttribute(comment, objectType, schemaType, paramType string, param *spec.Parameter) error {\n\tschemaType = TransToValidSchemeType(schemaType)\n\n\tfor attrKey, re := range regexAttributes {\n\t\tattr, err := findAttr(re, comment)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch attrKey {\n\t\tcase enumsTag:\n\t\t\terr = setEnumParam(param, attr, objectType, schemaType, paramType)\n\t\tcase minimumTag, maximumTag:\n\t\t\terr = setNumberParam(param, attrKey, schemaType, attr, comment)\n\t\tcase defaultTag:\n\t\t\terr = setDefault(param, schemaType, attr)\n\t\tcase minLengthTag, maxLengthTag:\n\t\t\terr = setStringParam(param, attrKey, schemaType, attr, comment)\n\t\tcase formatTag:\n\t\t\tparam.Format = attr\n\t\tcase exampleTag:\n\t\t\terr = setExample(param, schemaType, attr)\n\t\tcase schemaExampleTag:\n\t\t\terr = setSchemaExample(param, schemaType, attr)\n\t\tcase extensionsTag:\n\t\t\tparam.Extensions = setExtensionParam(attr)\n\t\tcase collectionFormatTag:\n\t\t\terr = setCollectionFormatParam(param, attrKey, objectType, attr, comment)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc findAttr(re *regexp.Regexp, commentLine string) (string, error) {\n\tattr := re.FindString(commentLine)\n\n\tl, r := strings.Index(attr, \"(\"), strings.Index(attr, \")\")\n\tif l == -1 || r == -1 {\n\t\treturn \"\", fmt.Errorf(\"can not find regex=%s, comment=%s\", re.String(), commentLine)\n\t}\n\n\treturn strings.TrimSpace(attr[l+1 : r]), nil\n}\n\nfunc setStringParam(param *spec.Parameter, name, schemaType, attr, commentLine string) error {\n\tif schemaType != STRING {\n\t\treturn fmt.Errorf(\"%s is attribute to set to a number. comment=%s got=%s\", name, commentLine, schemaType)\n\t}\n\n\tn, err := strconv.ParseInt(attr, 10, 64)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s is allow only a number got=%s\", name, attr)\n\t}\n\n\tswitch name {\n\tcase minLengthTag:\n\t\tparam.MinLength = &n\n\tcase maxLengthTag:\n\t\tparam.MaxLength = &n\n\t}\n\n\treturn nil\n}\n\nfunc setNumberParam(param *spec.Parameter, name, schemaType, attr, commentLine string) error {\n\tswitch schemaType {\n\tcase INTEGER, NUMBER:\n\t\tn, err := strconv.ParseFloat(attr, 64)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"maximum is allow only a number. comment=%s got=%s\", commentLine, attr)\n\t\t}\n\n\t\tswitch name {\n\t\tcase minimumTag:\n\t\t\tparam.Minimum = &n\n\t\tcase maximumTag:\n\t\t\tparam.Maximum = &n\n\t\t}\n\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"%s is attribute to set to a number. comment=%s got=%s\", name, commentLine, schemaType)\n\t}\n}\n\nfunc setEnumParam(param *spec.Parameter, attr, objectType, schemaType, paramType string) error {\n\tfor _, e := range strings.Split(attr, \",\") {\n\t\te = strings.TrimSpace(e)\n\n\t\tvalue, err := defineType(schemaType, e)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch objectType {\n\t\tcase ARRAY:\n\t\t\tparam.Items.Enum = append(param.Items.Enum, value)\n\t\tdefault:\n\t\t\tswitch paramType {\n\t\t\tcase \"body\":\n\t\t\t\tparam.Schema.Enum = append(param.Schema.Enum, value)\n\t\t\tdefault:\n\t\t\t\tparam.Enum = append(param.Enum, value)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc setExtensionParam(attr string) spec.Extensions {\n\textensions := spec.Extensions{}\n\n\tfor _, val := range splitNotWrapped(attr, ',') {\n\t\tparts := strings.SplitN(val, \"=\", 2)\n\t\tif len(parts) == 2 {\n\t\t\textensions.Add(parts[0], parts[1])\n\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(parts[0]) > 0 && string(parts[0][0]) == \"!\" {\n\t\t\textensions.Add(parts[0][1:], false)\n\n\t\t\tcontinue\n\t\t}\n\n\t\textensions.Add(parts[0], true)\n\t}\n\n\treturn extensions\n}\n\nfunc setCollectionFormatParam(param *spec.Parameter, name, schemaType, attr, commentLine string) error {\n\tif schemaType == ARRAY {\n\t\tparam.CollectionFormat = TransToValidCollectionFormat(attr)\n\n\t\treturn nil\n\t}\n\n\treturn fmt.Errorf(\"%s is attribute to set to an array. comment=%s got=%s\", name, commentLine, schemaType)\n}\n\nfunc setDefault(param *spec.Parameter, schemaType string, value string) error {\n\tval, err := defineType(schemaType, value)\n\tif err != nil {\n\t\treturn nil // Don't set a default value if it's not valid\n\t}\n\n\tparam.Default = val\n\n\treturn nil\n}\n\nfunc setSchemaExample(param *spec.Parameter, schemaType string, value string) error {\n\tval, err := defineType(schemaType, value)\n\tif err != nil {\n\t\treturn nil // Don't set a example value if it's not valid\n\t}\n\t// skip schema\n\tif param.Schema == nil {\n\t\treturn nil\n\t}\n\n\tswitch v := val.(type) {\n\tcase string:\n\t\t//  replaces \\r \\n \\t in example string values.\n\t\tparam.Schema.Example = strings.NewReplacer(`\\r`, \"\\r\", `\\n`, \"\\n\", `\\t`, \"\\t\").Replace(v)\n\tdefault:\n\t\tparam.Schema.Example = val\n\t}\n\n\treturn nil\n}\n\nfunc setExample(param *spec.Parameter, schemaType string, value string) error {\n\tval, err := defineType(schemaType, value)\n\tif err != nil {\n\t\treturn nil // Don't set a example value if it's not valid\n\t}\n\n\tparam.Example = val\n\n\treturn nil\n}\n\n// defineType enum value define the type (object and array unsupported).\nfunc defineType(schemaType string, value string) (v interface{}, err error) {\n\tschemaType = TransToValidSchemeType(schemaType)\n\n\tswitch schemaType {\n\tcase STRING:\n\t\treturn value, nil\n\tcase NUMBER:\n\t\tv, err = strconv.ParseFloat(value, 64)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"enum value %s can't convert to %s err: %s\", value, schemaType, err)\n\t\t}\n\tcase INTEGER:\n\t\tv, err = strconv.Atoi(value)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"enum value %s can't convert to %s err: %s\", value, schemaType, err)\n\t\t}\n\tcase BOOLEAN:\n\t\tv, err = strconv.ParseBool(value)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"enum value %s can't convert to %s err: %s\", value, schemaType, err)\n\t\t}\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"%s is unsupported type in enum value %s\", schemaType, value)\n\t}\n\n\treturn v, nil\n}\n\n// ParseTagsComment parses comment for given `tag` comment string.\nfunc (operation *Operation) ParseTagsComment(commentLine string) {\n\tfor _, tag := range strings.Split(commentLine, \",\") {\n\t\toperation.Tags = append(operation.Tags, strings.TrimSpace(tag))\n\t}\n}\n\n// ParseAcceptComment parses comment for given `accept` comment string.\nfunc (operation *Operation) ParseAcceptComment(commentLine string) error {\n\treturn parseMimeTypeList(commentLine, &operation.Consumes, \"%v accept type can't be accepted\")\n}\n\n// ParseProduceComment parses comment for given `produce` comment string.\nfunc (operation *Operation) ParseProduceComment(commentLine string) error {\n\treturn parseMimeTypeList(commentLine, &operation.Produces, \"%v produce type can't be accepted\")\n}\n\n// parseMimeTypeList parses a list of MIME Types for a comment like\n// `produce` (`Content-Type:` response header) or\n// `accept` (`Accept:` request header).\nfunc parseMimeTypeList(mimeTypeList string, typeList *[]string, format string) error {\n\tfor _, typeName := range strings.Split(mimeTypeList, \",\") {\n\t\tif mimeTypePattern.MatchString(typeName) {\n\t\t\t*typeList = append(*typeList, typeName)\n\n\t\t\tcontinue\n\t\t}\n\n\t\taliasMimeType, ok := mimeTypeAliases[typeName]\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(format, typeName)\n\t\t}\n\n\t\t*typeList = append(*typeList, aliasMimeType)\n\t}\n\n\treturn nil\n}\n\nvar routerPattern = regexp.MustCompile(`^(/[\\w./\\-{}\\(\\)+:$]*)[[:blank:]]+\\[(\\w+)]`)\n\n// ParseRouterComment parses comment for given `router` comment string.\nfunc (operation *Operation) ParseRouterComment(commentLine string, deprecated bool) error {\n\tmatches := routerPattern.FindStringSubmatch(commentLine)\n\tif len(matches) != 3 {\n\t\treturn fmt.Errorf(\"can not parse router comment \\\"%s\\\"\", commentLine)\n\t}\n\n\tsignature := RouteProperties{\n\t\tPath:       matches[1],\n\t\tHTTPMethod: strings.ToUpper(matches[2]),\n\t\tDeprecated: deprecated,\n\t}\n\n\tif _, ok := allMethod[signature.HTTPMethod]; !ok {\n\t\treturn fmt.Errorf(\"invalid method: %s\", signature.HTTPMethod)\n\t}\n\n\toperation.RouterProperties = append(operation.RouterProperties, signature)\n\n\treturn nil\n}\n\n// ParseSecurityComment parses comment for given `security` comment string.\nfunc (operation *Operation) ParseSecurityComment(commentLine string) error {\n\tif len(commentLine) == 0 {\n\t\toperation.Security = []map[string][]string{}\n\t\treturn nil\n\t}\n\n\tvar (\n\t\tsecurityMap    = make(map[string][]string)\n\t\tsecuritySource = commentLine[strings.Index(commentLine, \"@Security\")+1:]\n\t)\n\n\tfor _, securityOption := range securityPairSepPattern.Split(securitySource, -1) {\n\t\tsecurityOption = strings.TrimSpace(securityOption)\n\n\t\tleft, right := strings.Index(securityOption, \"[\"), strings.Index(securityOption, \"]\")\n\n\t\tif !(left == -1 && right == -1) {\n\t\t\tscopes := securityOption[left+1 : right]\n\n\t\t\tvar options []string\n\n\t\t\tfor _, scope := range strings.Split(scopes, \",\") {\n\t\t\t\toptions = append(options, strings.TrimSpace(scope))\n\t\t\t}\n\n\t\t\tsecurityKey := securityOption[0:left]\n\t\t\tsecurityMap[securityKey] = append(securityMap[securityKey], options...)\n\t\t} else {\n\t\t\tsecurityKey := strings.TrimSpace(securityOption)\n\t\t\tsecurityMap[securityKey] = []string{}\n\t\t}\n\t}\n\n\toperation.Security = append(operation.Security, securityMap)\n\n\treturn nil\n}\n\n// findTypeDef attempts to find the *ast.TypeSpec for a specific type given the\n// type's name and the package's import path.\n// TODO: improve finding external pkg.\nfunc findTypeDef(importPath, typeName string) (*ast.TypeSpec, error) {\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tconf := loader.Config{\n\t\tParserMode: goparser.SpuriousErrors,\n\t\tCwd:        cwd,\n\t}\n\n\tconf.Import(importPath)\n\n\tlprog, err := conf.Load()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If the pkg is vendored, the actual pkg path is going to resemble\n\t// something like \"{importPath}/vendor/{importPath}\"\n\tfor k := range lprog.AllPackages {\n\t\trealPkgPath := k.Path()\n\n\t\tif strings.Contains(realPkgPath, \"vendor/\"+importPath) {\n\t\t\timportPath = realPkgPath\n\t\t}\n\t}\n\n\tpkgInfo := lprog.Package(importPath)\n\n\tif pkgInfo == nil {\n\t\treturn nil, fmt.Errorf(\"package was nil\")\n\t}\n\n\t// TODO: possibly cache pkgInfo since it's an expensive operation\n\tfor i := range pkgInfo.Files {\n\t\tfor _, astDeclaration := range pkgInfo.Files[i].Decls {\n\t\t\tgeneralDeclaration, ok := astDeclaration.(*ast.GenDecl)\n\t\t\tif ok && generalDeclaration.Tok == token.TYPE {\n\t\t\t\tfor _, astSpec := range generalDeclaration.Specs {\n\t\t\t\t\ttypeSpec, ok := astSpec.(*ast.TypeSpec)\n\t\t\t\t\tif ok {\n\t\t\t\t\t\tif typeSpec.Name.String() == typeName {\n\t\t\t\t\t\t\treturn typeSpec, nil\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil, fmt.Errorf(\"type spec not found\")\n}\n\nvar responsePattern = regexp.MustCompile(`^([\\w,]+)\\s+([\\w{}]+)\\s+([\\w\\-.\\\\{}=,\\[\\s\\]]+)\\s*(\".*)?`)\n\n// ResponseType{data1=Type1,data2=Type2}.\nvar combinedPattern = regexp.MustCompile(`^([\\w\\-./\\[\\]]+){(.*)}$`)\n\nfunc (operation *Operation) parseObjectSchema(refType string, astFile *ast.File) (*spec.Schema, error) {\n\treturn parseObjectSchema(operation.parser, refType, astFile)\n}\n\nfunc parseObjectSchema(parser *Parser, refType string, astFile *ast.File) (*spec.Schema, error) {\n\tswitch {\n\tcase refType == NIL:\n\t\treturn nil, nil\n\tcase refType == INTERFACE:\n\t\treturn &spec.Schema{}, nil\n\tcase refType == ANY:\n\t\treturn &spec.Schema{}, nil\n\tcase IsGolangPrimitiveType(refType):\n\t\treturn TransToValidPrimitiveSchema(refType), nil\n\tcase IsPrimitiveType(refType):\n\t\treturn PrimitiveSchema(refType), nil\n\tcase strings.HasPrefix(refType, \"[]\"):\n\t\tschema, err := parseObjectSchema(parser, refType[2:], astFile)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn spec.ArrayProperty(schema), nil\n\tcase strings.HasPrefix(refType, \"map[\"):\n\t\t// ignore key type\n\t\tidx := strings.Index(refType, \"]\")\n\t\tif idx < 0 {\n\t\t\treturn nil, fmt.Errorf(\"invalid type: %s\", refType)\n\t\t}\n\n\t\trefType = refType[idx+1:]\n\t\tif refType == INTERFACE || refType == ANY {\n\t\t\treturn spec.MapProperty(nil), nil\n\t\t}\n\n\t\tschema, err := parseObjectSchema(parser, refType, astFile)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn spec.MapProperty(schema), nil\n\tcase strings.Contains(refType, \"{\"):\n\t\treturn parseCombinedObjectSchema(parser, refType, astFile)\n\tdefault:\n\t\tif parser != nil { // checking refType has existing in 'TypeDefinitions'\n\t\t\tschema, err := parser.getTypeSchema(refType, astFile, true)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn schema, nil\n\t\t}\n\n\t\treturn RefSchema(refType), nil\n\t}\n}\n\nfunc parseFields(s string) []string {\n\tnestLevel := 0\n\n\treturn strings.FieldsFunc(s, func(char rune) bool {\n\t\tif char == '{' {\n\t\t\tnestLevel++\n\n\t\t\treturn false\n\t\t} else if char == '}' {\n\t\t\tnestLevel--\n\n\t\t\treturn false\n\t\t}\n\n\t\treturn char == ',' && nestLevel == 0\n\t})\n}\n\nfunc parseCombinedObjectSchema(parser *Parser, refType string, astFile *ast.File) (*spec.Schema, error) {\n\tmatches := combinedPattern.FindStringSubmatch(refType)\n\tif len(matches) != 3 {\n\t\treturn nil, fmt.Errorf(\"invalid type: %s\", refType)\n\t}\n\n\tschema, err := parseObjectSchema(parser, matches[1], astFile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfields, props := parseFields(matches[2]), map[string]spec.Schema{}\n\n\tfor _, field := range fields {\n\t\tkeyVal := strings.SplitN(field, \"=\", 2)\n\t\tif len(keyVal) == 2 {\n\t\t\tschema, err := parseObjectSchema(parser, keyVal[1], astFile)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif schema == nil {\n\t\t\t\tschema = PrimitiveSchema(OBJECT)\n\t\t\t}\n\n\t\t\tprops[keyVal[0]] = *schema\n\t\t}\n\t}\n\n\tif len(props) == 0 {\n\t\treturn schema, nil\n\t}\n\n\tif schema.Ref.GetURL() == nil && len(schema.Type) > 0 && schema.Type[0] == OBJECT && len(schema.Properties) == 0 && schema.AdditionalProperties == nil {\n\t\tschema.Properties = props\n\t\treturn schema, nil\n\t}\n\n\treturn spec.ComposedSchema(*schema, spec.Schema{\n\t\tSchemaProps: spec.SchemaProps{\n\t\t\tType:       []string{OBJECT},\n\t\t\tProperties: props,\n\t\t},\n\t}), nil\n}\n\nfunc (operation *Operation) parseAPIObjectSchema(commentLine, schemaType, refType string, astFile *ast.File) (*spec.Schema, error) {\n\tif strings.HasSuffix(refType, \",\") && strings.Contains(refType, \"[\") {\n\t\t// regexp may have broken generic syntax. find closing bracket and add it back\n\t\tallMatchesLenOffset := strings.Index(commentLine, refType) + len(refType)\n\t\tlostPartEndIdx := strings.Index(commentLine[allMatchesLenOffset:], \"]\")\n\t\tif lostPartEndIdx >= 0 {\n\t\t\trefType += commentLine[allMatchesLenOffset : allMatchesLenOffset+lostPartEndIdx+1]\n\t\t}\n\t}\n\n\tswitch schemaType {\n\tcase OBJECT:\n\t\tif !strings.HasPrefix(refType, \"[]\") {\n\t\t\treturn operation.parseObjectSchema(refType, astFile)\n\t\t}\n\n\t\trefType = refType[2:]\n\n\t\tfallthrough\n\tcase ARRAY:\n\t\tschema, err := operation.parseObjectSchema(refType, astFile)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn spec.ArrayProperty(schema), nil\n\tdefault:\n\t\treturn PrimitiveSchema(schemaType), nil\n\t}\n}\n\n// ParseResponseComment parses comment for given `response` comment string.\nfunc (operation *Operation) ParseResponseComment(commentLine string, astFile *ast.File) error {\n\tmatches := responsePattern.FindStringSubmatch(commentLine)\n\tif len(matches) != 5 {\n\t\terr := operation.ParseEmptyResponseComment(commentLine)\n\t\tif err != nil {\n\t\t\treturn operation.ParseEmptyResponseOnly(commentLine)\n\t\t}\n\n\t\treturn err\n\t}\n\n\tdescription := strings.Trim(matches[4], \"\\\"\")\n\n\tschema, err := operation.parseAPIObjectSchema(commentLine, strings.Trim(matches[2], \"{}\"), strings.TrimSpace(matches[3]), astFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, codeStr := range strings.Split(matches[1], \",\") {\n\t\tif strings.EqualFold(codeStr, defaultTag) {\n\t\t\toperation.DefaultResponse().WithSchema(schema).WithDescription(description)\n\n\t\t\tcontinue\n\t\t}\n\n\t\tcode, err := strconv.Atoi(codeStr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"can not parse response comment \\\"%s\\\"\", commentLine)\n\t\t}\n\n\t\tresp := spec.NewResponse().WithSchema(schema).WithDescription(description)\n\t\tif description == \"\" {\n\t\t\tresp.WithDescription(http.StatusText(code))\n\t\t}\n\n\t\toperation.AddResponse(code, resp)\n\t}\n\n\treturn nil\n}\n\nfunc newHeaderSpec(schemaType, description string) spec.Header {\n\treturn spec.Header{\n\t\tSimpleSchema: spec.SimpleSchema{\n\t\t\tType: schemaType,\n\t\t},\n\t\tHeaderProps: spec.HeaderProps{\n\t\t\tDescription: description,\n\t\t},\n\t\tVendorExtensible: spec.VendorExtensible{\n\t\t\tExtensions: nil,\n\t\t},\n\t\tCommonValidations: spec.CommonValidations{\n\t\t\tMaximum:          nil,\n\t\t\tExclusiveMaximum: false,\n\t\t\tMinimum:          nil,\n\t\t\tExclusiveMinimum: false,\n\t\t\tMaxLength:        nil,\n\t\t\tMinLength:        nil,\n\t\t\tPattern:          \"\",\n\t\t\tMaxItems:         nil,\n\t\t\tMinItems:         nil,\n\t\t\tUniqueItems:      false,\n\t\t\tMultipleOf:       nil,\n\t\t\tEnum:             nil,\n\t\t},\n\t}\n}\n\n// ParseResponseHeaderComment parses comment for given `response header` comment string.\nfunc (operation *Operation) ParseResponseHeaderComment(commentLine string, _ *ast.File) error {\n\tmatches := responsePattern.FindStringSubmatch(commentLine)\n\tif len(matches) != 5 {\n\t\treturn fmt.Errorf(\"can not parse response comment \\\"%s\\\"\", commentLine)\n\t}\n\n\theader := newHeaderSpec(strings.Trim(matches[2], \"{}\"), strings.Trim(matches[4], \"\\\"\"))\n\n\theaderKey := strings.TrimSpace(matches[3])\n\n\tif strings.EqualFold(matches[1], \"all\") {\n\t\tif operation.Responses.Default != nil {\n\t\t\toperation.Responses.Default.Headers[headerKey] = header\n\t\t}\n\n\t\tif operation.Responses.StatusCodeResponses != nil {\n\t\t\tfor code, response := range operation.Responses.StatusCodeResponses {\n\t\t\t\tresponse.Headers[headerKey] = header\n\t\t\t\toperation.Responses.StatusCodeResponses[code] = response\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tfor _, codeStr := range strings.Split(matches[1], \",\") {\n\t\tif strings.EqualFold(codeStr, defaultTag) {\n\t\t\tif operation.Responses.Default != nil {\n\t\t\t\toperation.Responses.Default.Headers[headerKey] = header\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tcode, err := strconv.Atoi(codeStr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"can not parse response comment \\\"%s\\\"\", commentLine)\n\t\t}\n\n\t\tif operation.Responses.StatusCodeResponses != nil {\n\t\t\tresponse, responseExist := operation.Responses.StatusCodeResponses[code]\n\t\t\tif responseExist {\n\t\t\t\tresponse.Headers[headerKey] = header\n\n\t\t\t\toperation.Responses.StatusCodeResponses[code] = response\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nvar emptyResponsePattern = regexp.MustCompile(`([\\w,]+)\\s+\"(.*)\"`)\n\n// ParseEmptyResponseComment parse only comment out status code and description,eg: @Success 200 \"it's ok\".\nfunc (operation *Operation) ParseEmptyResponseComment(commentLine string) error {\n\tmatches := emptyResponsePattern.FindStringSubmatch(commentLine)\n\tif len(matches) != 3 {\n\t\treturn fmt.Errorf(\"can not parse response comment \\\"%s\\\"\", commentLine)\n\t}\n\n\tdescription := strings.Trim(matches[2], \"\\\"\")\n\n\tfor _, codeStr := range strings.Split(matches[1], \",\") {\n\t\tif strings.EqualFold(codeStr, defaultTag) {\n\t\t\toperation.DefaultResponse().WithDescription(description)\n\n\t\t\tcontinue\n\t\t}\n\n\t\tcode, err := strconv.Atoi(codeStr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"can not parse response comment \\\"%s\\\"\", commentLine)\n\t\t}\n\n\t\toperation.AddResponse(code, spec.NewResponse().WithDescription(description))\n\t}\n\n\treturn nil\n}\n\n// ParseEmptyResponseOnly parse only comment out status code ,eg: @Success 200.\nfunc (operation *Operation) ParseEmptyResponseOnly(commentLine string) error {\n\tfor _, codeStr := range strings.Split(commentLine, \",\") {\n\t\tif strings.EqualFold(codeStr, defaultTag) {\n\t\t\t_ = operation.DefaultResponse()\n\n\t\t\tcontinue\n\t\t}\n\n\t\tcode, err := strconv.Atoi(codeStr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"can not parse response comment \\\"%s\\\"\", commentLine)\n\t\t}\n\n\t\toperation.AddResponse(code, spec.NewResponse().WithDescription(http.StatusText(code)))\n\t}\n\n\treturn nil\n}\n\n// DefaultResponse return the default response member pointer.\nfunc (operation *Operation) DefaultResponse() *spec.Response {\n\tif operation.Responses.Default == nil {\n\t\toperation.Responses.Default = &spec.Response{\n\t\t\tResponseProps: spec.ResponseProps{\n\t\t\t\tDescription: \"\",\n\t\t\t\tHeaders:     make(map[string]spec.Header),\n\t\t\t},\n\t\t}\n\t}\n\n\treturn operation.Responses.Default\n}\n\n// AddResponse add a response for a code.\nfunc (operation *Operation) AddResponse(code int, response *spec.Response) {\n\tif response.Headers == nil {\n\t\tresponse.Headers = make(map[string]spec.Header)\n\t}\n\n\toperation.Responses.StatusCodeResponses[code] = *response\n}\n\n// createParameter returns swagger spec.Parameter for given  paramType, description, paramName, schemaType, required.\nfunc createParameter(paramType, description, paramName, objectType, schemaType string, format string, required bool, enums []interface{}, collectionFormat string) spec.Parameter {\n\t// //five possible parameter types. \tquery, path, body, header, form\n\tresult := spec.Parameter{\n\t\tParamProps: spec.ParamProps{\n\t\t\tName:        paramName,\n\t\t\tDescription: description,\n\t\t\tRequired:    required,\n\t\t\tIn:          paramType,\n\t\t},\n\t}\n\n\tif paramType == \"body\" {\n\t\treturn result\n\t}\n\n\tswitch objectType {\n\tcase ARRAY:\n\t\tresult.Type = objectType\n\t\tresult.CollectionFormat = collectionFormat\n\t\tresult.Items = &spec.Items{\n\t\t\tCommonValidations: spec.CommonValidations{\n\t\t\t\tEnum: enums,\n\t\t\t},\n\t\t\tSimpleSchema: spec.SimpleSchema{\n\t\t\t\tType:   schemaType,\n\t\t\t\tFormat: format,\n\t\t\t},\n\t\t}\n\tcase PRIMITIVE, OBJECT:\n\t\tresult.Type = schemaType\n\t\tresult.Enum = enums\n\t\tresult.Format = format\n\t}\n\treturn result\n}\n\nfunc getCodeExampleForSummary(summaryName string, dirPath string) ([]byte, error) {\n\tdirEntries, err := os.ReadDir(dirPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, entry := range dirEntries {\n\t\tif entry.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\tfileName := entry.Name()\n\n\t\tif !strings.Contains(fileName, \".json\") {\n\t\t\tcontinue\n\t\t}\n\n\t\tif strings.Contains(fileName, summaryName) {\n\t\t\tfullPath := filepath.Join(dirPath, fileName)\n\n\t\t\tcommentInfo, err := os.ReadFile(fullPath)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Failed to read code example file %s error: %s \", fullPath, err)\n\t\t\t}\n\n\t\t\treturn commentInfo, nil\n\t\t}\n\t}\n\n\treturn nil, fmt.Errorf(\"unable to find code example file for tag %s in the given directory\", summaryName)\n}\n"
        },
        {
          "name": "operation_test.go",
          "type": "blob",
          "size": 72.2421875,
          "content": "package swag\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"go/ast\"\n\tgoparser \"go/parser\"\n\t\"go/token\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/go-openapi/spec\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestParseEmptyComment(t *testing.T) {\n\tt.Parallel()\n\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(\"//\", nil)\n\n\tassert.NoError(t, err)\n}\n\nfunc TestParseTagsComment(t *testing.T) {\n\tt.Parallel()\n\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(`/@Tags pet, store,user`, nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, operation.Tags, []string{\"pet\", \"store\", \"user\"})\n}\n\nfunc TestParseAcceptComment(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `/@Accept json,xml,plain,html,mpfd,x-www-form-urlencoded,json-api,json-stream,octet-stream,png,jpeg,gif,application/xhtml+xml,application/health+json`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t,\n\t\toperation.Consumes,\n\t\t[]string{\"application/json\",\n\t\t\t\"text/xml\",\n\t\t\t\"text/plain\",\n\t\t\t\"text/html\",\n\t\t\t\"multipart/form-data\",\n\t\t\t\"application/x-www-form-urlencoded\",\n\t\t\t\"application/vnd.api+json\",\n\t\t\t\"application/x-json-stream\",\n\t\t\t\"application/octet-stream\",\n\t\t\t\"image/png\",\n\t\t\t\"image/jpeg\",\n\t\t\t\"image/gif\",\n\t\t\t\"application/xhtml+xml\",\n\t\t\t\"application/health+json\"})\n}\n\nfunc TestParseAcceptCommentErr(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `/@Accept unknown`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\tassert.Error(t, err)\n}\n\nfunc TestParseProduceComment(t *testing.T) {\n\tt.Parallel()\n\n\texpected := `{\n    \"produces\": [\n        \"application/json\",\n        \"text/xml\",\n        \"text/plain\",\n        \"text/html\",\n        \"multipart/form-data\",\n        \"application/x-www-form-urlencoded\",\n        \"application/vnd.api+json\",\n        \"application/x-json-stream\",\n\t\t\"application/octet-stream\",\n\t\t\"image/png\",\n\t\t\"image/jpeg\",\n\t\t\"image/gif\",\n\t\t\"application/health+json\"\n    ]\n}`\n\tcomment := `/@Produce json,xml,plain,html,mpfd,x-www-form-urlencoded,json-api,json-stream,octet-stream,png,jpeg,gif,application/health+json`\n\toperation := new(Operation)\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err, \"ParseComment should not fail\")\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\tassert.JSONEq(t, expected, string(b))\n}\n\nfunc TestParseProduceCommentErr(t *testing.T) {\n\tt.Parallel()\n\n\toperation := new(Operation)\n\terr := operation.ParseComment(\"/@Produce foo\", nil)\n\tassert.Error(t, err)\n}\n\nfunc TestParseRouterComment(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `/@Router /customer/get-wishlist/{wishlist_id} [get]`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\tassert.Len(t, operation.RouterProperties, 1)\n\tassert.Equal(t, \"/customer/get-wishlist/{wishlist_id}\", operation.RouterProperties[0].Path)\n\tassert.Equal(t, \"GET\", operation.RouterProperties[0].HTTPMethod)\n\n\tcomment = `/@Router /customer/get-wishlist/{wishlist_id} [unknown]`\n\toperation = NewOperation(nil)\n\terr = operation.ParseComment(comment, nil)\n\tassert.Error(t, err)\n}\n\nfunc TestParseRouterMultipleComments(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `/@Router /customer/get-wishlist/{wishlist_id} [get]`\n\tanotherComment := `/@Router /customer/get-the-wishlist/{wishlist_id} [post]`\n\toperation := NewOperation(nil)\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\terr = operation.ParseComment(anotherComment, nil)\n\tassert.NoError(t, err)\n\n\tassert.Len(t, operation.RouterProperties, 2)\n\tassert.Equal(t, \"/customer/get-wishlist/{wishlist_id}\", operation.RouterProperties[0].Path)\n\tassert.Equal(t, \"GET\", operation.RouterProperties[0].HTTPMethod)\n\tassert.Equal(t, \"/customer/get-the-wishlist/{wishlist_id}\", operation.RouterProperties[1].Path)\n\tassert.Equal(t, \"POST\", operation.RouterProperties[1].HTTPMethod)\n}\n\nfunc TestParseRouterOnlySlash(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `// @Router / [get]`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\tassert.Len(t, operation.RouterProperties, 1)\n\tassert.Equal(t, \"/\", operation.RouterProperties[0].Path)\n\tassert.Equal(t, \"GET\", operation.RouterProperties[0].HTTPMethod)\n}\n\nfunc TestParseRouterCommentWithPlusSign(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `/@Router /customer/get-wishlist/{proxy+} [post]`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\tassert.Len(t, operation.RouterProperties, 1)\n\tassert.Equal(t, \"/customer/get-wishlist/{proxy+}\", operation.RouterProperties[0].Path)\n\tassert.Equal(t, \"POST\", operation.RouterProperties[0].HTTPMethod)\n}\n\nfunc TestParseRouterCommentWithDollarSign(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `/@Router /customer/get-wishlist/{wishlist_id}$move [post]`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\tassert.Len(t, operation.RouterProperties, 1)\n\tassert.Equal(t, \"/customer/get-wishlist/{wishlist_id}$move\", operation.RouterProperties[0].Path)\n\tassert.Equal(t, \"POST\", operation.RouterProperties[0].HTTPMethod)\n}\n\nfunc TestParseRouterCommentWithParens(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `/@Router /customer({id}) [get]`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\tassert.Len(t, operation.RouterProperties, 1)\n\tassert.Equal(t, \"/customer({id})\", operation.RouterProperties[0].Path)\n\tassert.Equal(t, \"GET\", operation.RouterProperties[0].HTTPMethod)\n}\n\nfunc TestParseRouterCommentNoDollarSignAtPathStartErr(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `/@Router $customer/get-wishlist/{wishlist_id}$move [post]`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\tassert.Error(t, err)\n}\n\nfunc TestParseRouterCommentWithColonSign(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `/@Router /customer/get-wishlist/{wishlist_id}:move [post]`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\tassert.Len(t, operation.RouterProperties, 1)\n\tassert.Equal(t, \"/customer/get-wishlist/{wishlist_id}:move\", operation.RouterProperties[0].Path)\n\tassert.Equal(t, \"POST\", operation.RouterProperties[0].HTTPMethod)\n}\n\nfunc TestParseRouterCommentNoColonSignAtPathStartErr(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `/@Router :customer/get-wishlist/{wishlist_id}:move [post]`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\tassert.Error(t, err)\n}\n\nfunc TestParseRouterCommentMethodSeparationErr(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `/@Router /api/{id}|,*[get`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\tassert.Error(t, err)\n}\n\nfunc TestParseRouterCommentMethodMissingErr(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `/@Router /customer/get-wishlist/{wishlist_id}`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\tassert.Error(t, err)\n}\n\nfunc TestOperation_ParseResponseWithDefault(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Success default {object} nil \"An empty response\"`\n\toperation := NewOperation(nil)\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, \"An empty response\", operation.Responses.Default.Description)\n\n\tcomment = `@Success 200,default {string} Response \"A response\"`\n\toperation = NewOperation(nil)\n\n\terr = operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, \"A response\", operation.Responses.Default.Description)\n\tassert.Equal(t, \"A response\", operation.Responses.StatusCodeResponses[200].Description)\n}\n\nfunc TestParseResponseSuccessCommentWithEmptyResponse(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Success 200 {object} nil \"An empty response\"`\n\toperation := NewOperation(nil)\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tresponse := operation.Responses.StatusCodeResponses[200]\n\tassert.Equal(t, `An empty response`, response.Description)\n\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"An empty response\"\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseResponseFailureCommentWithEmptyResponse(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Failure 500 {object} nil`\n\toperation := NewOperation(nil)\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\texpected := `{\n    \"responses\": {\n        \"500\": {\n            \"description\": \"Internal Server Error\"\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseResponseCommentWithObjectType(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Success 200 {object} model.OrderRow \"Error message, if code != 200`\n\toperation := NewOperation(nil)\n\toperation.parser.addTestType(\"model.OrderRow\")\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tresponse := operation.Responses.StatusCodeResponses[200]\n\tassert.Equal(t, `Error message, if code != 200`, response.Description)\n\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"Error message, if code != 200\",\n            \"schema\": {\n                \"$ref\": \"#/definitions/model.OrderRow\"\n            }\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseResponseCommentWithNestedPrimitiveType(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Success 200 {object} model.CommonHeader{data=string,data2=int} \"Error message, if code != 200`\n\toperation := NewOperation(nil)\n\n\toperation.parser.addTestType(\"model.CommonHeader\")\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tresponse := operation.Responses.StatusCodeResponses[200]\n\tassert.Equal(t, `Error message, if code != 200`, response.Description)\n\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"Error message, if code != 200\",\n            \"schema\": {\n                \"allOf\": [\n                    {\n                        \"$ref\": \"#/definitions/model.CommonHeader\"\n                    },\n                    {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"data\": {\n                                \"type\": \"string\"\n                            },\n                            \"data2\": {\n                                \"type\": \"integer\"\n                            }\n                        }\n                    }\n                ]\n            }\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseResponseCommentWithNestedPrimitiveArrayType(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Success 200 {object} model.CommonHeader{data=[]string,data2=[]int} \"Error message, if code != 200`\n\toperation := NewOperation(nil)\n\n\toperation.parser.addTestType(\"model.CommonHeader\")\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tresponse := operation.Responses.StatusCodeResponses[200]\n\tassert.Equal(t, `Error message, if code != 200`, response.Description)\n\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"Error message, if code != 200\",\n            \"schema\": {\n                \"allOf\": [\n                    {\n                        \"$ref\": \"#/definitions/model.CommonHeader\"\n                    },\n                    {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"data\": {\n                                \"type\": \"array\",\n                                \"items\": {\n                                    \"type\": \"string\"\n                                }\n                            },\n                            \"data2\": {\n                                \"type\": \"array\",\n                                \"items\": {\n                                    \"type\": \"integer\"\n                                }\n                            }\n                        }\n                    }\n                ]\n            }\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseResponseCommentWithNestedObjectType(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Success 200 {object} model.CommonHeader{data=model.Payload,data2=model.Payload2} \"Error message, if code != 200`\n\toperation := NewOperation(nil)\n\toperation.parser.addTestType(\"model.CommonHeader\")\n\toperation.parser.addTestType(\"model.Payload\")\n\toperation.parser.addTestType(\"model.Payload2\")\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tresponse := operation.Responses.StatusCodeResponses[200]\n\tassert.Equal(t, `Error message, if code != 200`, response.Description)\n\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"Error message, if code != 200\",\n            \"schema\": {\n                \"allOf\": [\n                    {\n                        \"$ref\": \"#/definitions/model.CommonHeader\"\n                    },\n                    {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"data\": {\n                                \"$ref\": \"#/definitions/model.Payload\"\n                            },\n                            \"data2\": {\n                                \"$ref\": \"#/definitions/model.Payload2\"\n                            }\n                        }\n                    }\n                ]\n            }\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseResponseCommentWithNestedArrayObjectType(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Success 200 {object} model.CommonHeader{data=[]model.Payload,data2=[]model.Payload2} \"Error message, if code != 200`\n\toperation := NewOperation(nil)\n\n\toperation.parser.addTestType(\"model.CommonHeader\")\n\toperation.parser.addTestType(\"model.Payload\")\n\toperation.parser.addTestType(\"model.Payload2\")\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tresponse := operation.Responses.StatusCodeResponses[200]\n\tassert.Equal(t, `Error message, if code != 200`, response.Description)\n\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"Error message, if code != 200\",\n            \"schema\": {\n                \"allOf\": [\n                    {\n                        \"$ref\": \"#/definitions/model.CommonHeader\"\n                    },\n                    {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"data\": {\n                                \"type\": \"array\",\n                                \"items\": {\n                                    \"$ref\": \"#/definitions/model.Payload\"\n                                }\n                            },\n                            \"data2\": {\n                                \"type\": \"array\",\n                                \"items\": {\n                                    \"$ref\": \"#/definitions/model.Payload2\"\n                                }\n                            }\n                        }\n                    }\n                ]\n            }\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseResponseCommentWithNestedFields(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Success 200 {object} model.CommonHeader{data1=int,data2=[]int,data3=model.Payload,data4=[]model.Payload} \"Error message, if code != 200`\n\toperation := NewOperation(nil)\n\n\toperation.parser.addTestType(\"model.CommonHeader\")\n\toperation.parser.addTestType(\"model.Payload\")\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tresponse := operation.Responses.StatusCodeResponses[200]\n\tassert.Equal(t, `Error message, if code != 200`, response.Description)\n\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"Error message, if code != 200\",\n            \"schema\": {\n                \"allOf\": [\n                    {\n                        \"$ref\": \"#/definitions/model.CommonHeader\"\n                    },\n                    {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"data1\": {\n                                \"type\": \"integer\"\n                            },\n                            \"data2\": {\n                                \"type\": \"array\",\n                                \"items\": {\n                                    \"type\": \"integer\"\n                                }\n                            },\n                            \"data3\": {\n                                \"$ref\": \"#/definitions/model.Payload\"\n                            },\n                            \"data4\": {\n                                \"type\": \"array\",\n                                \"items\": {\n                                    \"$ref\": \"#/definitions/model.Payload\"\n                                }\n                            }\n                        }\n                    }\n                ]\n            }\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseResponseCommentWithDeepNestedFields(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Success 200 {object} model.CommonHeader{data1=int,data2=[]int,data3=model.Payload{data1=int,data2=model.DeepPayload},data4=[]model.Payload{data1=[]int,data2=[]model.DeepPayload}} \"Error message, if code != 200`\n\toperation := NewOperation(nil)\n\n\toperation.parser.addTestType(\"model.CommonHeader\")\n\toperation.parser.addTestType(\"model.Payload\")\n\toperation.parser.addTestType(\"model.DeepPayload\")\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tresponse := operation.Responses.StatusCodeResponses[200]\n\tassert.Equal(t, `Error message, if code != 200`, response.Description)\n\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"Error message, if code != 200\",\n            \"schema\": {\n                \"allOf\": [\n                    {\n                        \"$ref\": \"#/definitions/model.CommonHeader\"\n                    },\n                    {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"data1\": {\n                                \"type\": \"integer\"\n                            },\n                            \"data2\": {\n                                \"type\": \"array\",\n                                \"items\": {\n                                    \"type\": \"integer\"\n                                }\n                            },\n                            \"data3\": {\n                                \"allOf\": [\n                                    {\n                                        \"$ref\": \"#/definitions/model.Payload\"\n                                    },\n                                    {\n                                        \"type\": \"object\",\n                                        \"properties\": {\n                                            \"data1\": {\n                                                \"type\": \"integer\"\n                                            },\n                                            \"data2\": {\n                                                \"$ref\": \"#/definitions/model.DeepPayload\"\n                                            }\n                                        }\n                                    }\n                                ]\n                            },\n                            \"data4\": {\n                                \"type\": \"array\",\n                                \"items\": {\n                                    \"allOf\": [\n                                        {\n                                            \"$ref\": \"#/definitions/model.Payload\"\n                                        },\n                                        {\n                                            \"type\": \"object\",\n                                            \"properties\": {\n                                                \"data1\": {\n                                                    \"type\": \"array\",\n                                                    \"items\": {\n                                                        \"type\": \"integer\"\n                                                    }\n                                                },\n                                                \"data2\": {\n                                                    \"type\": \"array\",\n                                                    \"items\": {\n                                                        \"$ref\": \"#/definitions/model.DeepPayload\"\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    ]\n                                }\n                            }\n                        }\n                    }\n                ]\n            }\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseResponseCommentWithNestedArrayMapFields(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Success 200 {object} []map[string]model.CommonHeader{data1=[]map[string]model.Payload,data2=map[string][]int} \"Error message, if code != 200`\n\toperation := NewOperation(nil)\n\n\toperation.parser.addTestType(\"model.CommonHeader\")\n\toperation.parser.addTestType(\"model.Payload\")\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tresponse := operation.Responses.StatusCodeResponses[200]\n\tassert.Equal(t, `Error message, if code != 200`, response.Description)\n\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"Error message, if code != 200\",\n            \"schema\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"object\",\n                    \"additionalProperties\": {\n                        \"allOf\": [\n                            {\n                                \"$ref\": \"#/definitions/model.CommonHeader\"\n                            },\n                            {\n                                \"type\": \"object\",\n                                \"properties\": {\n                                    \"data1\": {\n                                        \"type\": \"array\",\n                                        \"items\": {\n                                            \"type\": \"object\",\n                                            \"additionalProperties\": {\n                                                \"$ref\": \"#/definitions/model.Payload\"\n                                            }\n                                        }\n                                    },\n                                    \"data2\": {\n                                        \"type\": \"object\",\n                                        \"additionalProperties\": {\n                                            \"type\": \"array\",\n                                            \"items\": {\n                                                \"type\": \"integer\"\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        ]\n                    }\n                }\n            }\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseResponseCommentWithObjectTypeInSameFile(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Success 200 {object} testOwner \"Error message, if code != 200\"`\n\toperation := NewOperation(nil)\n\n\toperation.parser.addTestType(\"swag.testOwner\")\n\n\tfset := token.NewFileSet()\n\tastFile, err := goparser.ParseFile(fset, \"operation_test.go\", `package swag\n\ttype testOwner struct {\n\n\t}\n\t`, goparser.ParseComments)\n\tassert.NoError(t, err)\n\n\terr = operation.ParseComment(comment, astFile)\n\tassert.NoError(t, err)\n\n\tresponse := operation.Responses.StatusCodeResponses[200]\n\tassert.Equal(t, `Error message, if code != 200`, response.Description)\n\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"Error message, if code != 200\",\n            \"schema\": {\n                \"$ref\": \"#/definitions/swag.testOwner\"\n            }\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseResponseCommentWithObjectTypeAnonymousField(t *testing.T) {\n\t//TODO: test Anonymous\n}\n\nfunc TestParseResponseCommentWithObjectTypeErr(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Success 200 {object} model.OrderRow \"Error message, if code != 200\"`\n\toperation := NewOperation(nil)\n\n\toperation.parser.addTestType(\"model.notexist\")\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.Error(t, err)\n}\n\nfunc TestParseResponseCommentWithArrayType(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Success 200 {array} model.OrderRow \"Error message, if code != 200`\n\toperation := NewOperation(nil)\n\toperation.parser.addTestType(\"model.OrderRow\")\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\tresponse := operation.Responses.StatusCodeResponses[200]\n\tassert.Equal(t, `Error message, if code != 200`, response.Description)\n\tassert.Equal(t, spec.StringOrArray{\"array\"}, response.Schema.Type)\n\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"Error message, if code != 200\",\n            \"schema\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"$ref\": \"#/definitions/model.OrderRow\"\n                }\n            }\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseResponseCommentWithBasicType(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Success 200 {string} string \"it's ok'\"`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err, \"ParseComment should not fail\")\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"it's ok'\",\n            \"schema\": {\n                \"type\": \"string\"\n            }\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseResponseCommentWithBasicTypeAndCodes(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Success 200,201,default {string} string \"it's ok\"`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err, \"ParseComment should not fail\")\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"it's ok\",\n            \"schema\": {\n                \"type\": \"string\"\n            }\n        },\n        \"201\": {\n            \"description\": \"it's ok\",\n            \"schema\": {\n                \"type\": \"string\"\n            }\n        },\n        \"default\": {\n            \"description\": \"it's ok\",\n            \"schema\": {\n                \"type\": \"string\"\n            }\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseEmptyResponseComment(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Success 200 \"it is ok\"`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err, \"ParseComment should not fail\")\n\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"it is ok\"\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseEmptyResponseCommentWithCodes(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Success 200,201,default \"it is ok\"`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err, \"ParseComment should not fail\")\n\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"it is ok\"\n        },\n        \"201\": {\n            \"description\": \"it is ok\"\n        },\n        \"default\": {\n            \"description\": \"it is ok\"\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseResponseCommentWithHeader(t *testing.T) {\n\tt.Parallel()\n\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(`@Success 200 \"it's ok\"`, nil)\n\tassert.NoError(t, err, \"ParseComment should not fail\")\n\n\terr = operation.ParseComment(`@Header 200 {string} Token \"qwerty\"`, nil)\n\tassert.NoError(t, err, \"ParseComment should not fail\")\n\n\tb, err := json.MarshalIndent(operation, \"\", \"    \")\n\tassert.NoError(t, err)\n\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"it's ok\",\n            \"headers\": {\n                \"Token\": {\n                    \"type\": \"string\",\n                    \"description\": \"qwerty\"\n                }\n            }\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n\n\terr = operation.ParseComment(`@Header 200 \"Mallformed\"`, nil)\n\tassert.Error(t, err, \"ParseComment should not fail\")\n\n\terr = operation.ParseComment(`@Header 200,asdsd {string} Token \"qwerty\"`, nil)\n\tassert.Error(t, err, \"ParseComment should not fail\")\n}\n\nfunc TestParseResponseCommentWithHeaderForCodes(t *testing.T) {\n\tt.Parallel()\n\n\toperation := NewOperation(nil)\n\n\tcomment := `@Success 200,201,default \"it's ok\"`\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err, \"ParseComment should not fail\")\n\n\tcomment = `@Header 200,201,default {string} Token \"qwerty\"`\n\terr = operation.ParseComment(comment, nil)\n\tassert.NoError(t, err, \"ParseComment should not fail\")\n\n\tcomment = `@Header all {string} Token2 \"qwerty\"`\n\terr = operation.ParseComment(comment, nil)\n\tassert.NoError(t, err, \"ParseComment should not fail\")\n\n\tb, err := json.MarshalIndent(operation, \"\", \"    \")\n\tassert.NoError(t, err)\n\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"it's ok\",\n            \"headers\": {\n                \"Token\": {\n                    \"type\": \"string\",\n                    \"description\": \"qwerty\"\n                },\n                \"Token2\": {\n                    \"type\": \"string\",\n                    \"description\": \"qwerty\"\n                }\n            }\n        },\n        \"201\": {\n            \"description\": \"it's ok\",\n            \"headers\": {\n                \"Token\": {\n                    \"type\": \"string\",\n                    \"description\": \"qwerty\"\n                },\n                \"Token2\": {\n                    \"type\": \"string\",\n                    \"description\": \"qwerty\"\n                }\n            }\n        },\n        \"default\": {\n            \"description\": \"it's ok\",\n            \"headers\": {\n                \"Token\": {\n                    \"type\": \"string\",\n                    \"description\": \"qwerty\"\n                },\n                \"Token2\": {\n                    \"type\": \"string\",\n                    \"description\": \"qwerty\"\n                }\n            }\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n\n\tcomment = `@Header 200 \"Mallformed\"`\n\terr = operation.ParseComment(comment, nil)\n\tassert.Error(t, err, \"ParseComment should not fail\")\n}\n\nfunc TestParseResponseCommentWithHeaderOnlyAll(t *testing.T) {\n\tt.Parallel()\n\n\toperation := NewOperation(nil)\n\n\tcomment := `@Success 200,201,default \"it's ok\"`\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err, \"ParseComment should not fail\")\n\n\tcomment = `@Header all {string} Token \"qwerty\"`\n\terr = operation.ParseComment(comment, nil)\n\tassert.NoError(t, err, \"ParseComment should not fail\")\n\n\tb, err := json.MarshalIndent(operation, \"\", \"    \")\n\tassert.NoError(t, err)\n\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"it's ok\",\n            \"headers\": {\n                \"Token\": {\n                    \"type\": \"string\",\n                    \"description\": \"qwerty\"\n                }\n            }\n        },\n        \"201\": {\n            \"description\": \"it's ok\",\n            \"headers\": {\n                \"Token\": {\n                    \"type\": \"string\",\n                    \"description\": \"qwerty\"\n                }\n            }\n        },\n        \"default\": {\n            \"description\": \"it's ok\",\n            \"headers\": {\n                \"Token\": {\n                    \"type\": \"string\",\n                    \"description\": \"qwerty\"\n                }\n            }\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n\n\tcomment = `@Header 200 \"Mallformed\"`\n\terr = operation.ParseComment(comment, nil)\n\tassert.Error(t, err, \"ParseComment should not fail\")\n}\n\nfunc TestParseEmptyResponseOnlyCode(t *testing.T) {\n\tt.Parallel()\n\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(`@Success 200`, nil)\n\tassert.NoError(t, err, \"ParseComment should not fail\")\n\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"OK\"\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseEmptyResponseOnlyCodes(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Success 200,201,default`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err, \"ParseComment should not fail\")\n\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\n\texpected := `{\n    \"responses\": {\n        \"200\": {\n            \"description\": \"OK\"\n        },\n        \"201\": {\n            \"description\": \"Created\"\n        },\n        \"default\": {\n            \"description\": \"\"\n        }\n    }\n}`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseResponseCommentParamMissing(t *testing.T) {\n\tt.Parallel()\n\n\toperation := NewOperation(nil)\n\n\tparamLenErrComment := `@Success notIntCode`\n\tparamLenErr := operation.ParseComment(paramLenErrComment, nil)\n\tassert.EqualError(t, paramLenErr, `can not parse response comment \"notIntCode\"`)\n\n\tparamLenErrComment = `@Success notIntCode {string} string \"it ok\"`\n\tparamLenErr = operation.ParseComment(paramLenErrComment, nil)\n\tassert.EqualError(t, paramLenErr, `can not parse response comment \"notIntCode {string} string \"it ok\"\"`)\n\n\tparamLenErrComment = `@Success notIntCode \"it ok\"`\n\tparamLenErr = operation.ParseComment(paramLenErrComment, nil)\n\tassert.EqualError(t, paramLenErr, `can not parse response comment \"notIntCode \"it ok\"\"`)\n}\n\nfunc TestOperation_ParseParamComment(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"integer\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tfor _, paramType := range []string{\"header\", \"path\", \"query\", \"formData\"} {\n\t\t\tt.Run(paramType, func(t *testing.T) {\n\t\t\t\to := NewOperation(nil)\n\t\t\t\terr := o.ParseComment(`@Param some_id `+paramType+` int true \"Some ID\"`, nil)\n\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, o.Parameters, []spec.Parameter{{\n\t\t\t\t\tSimpleSchema: spec.SimpleSchema{\n\t\t\t\t\t\tType: \"integer\",\n\t\t\t\t\t},\n\t\t\t\t\tParamProps: spec.ParamProps{\n\t\t\t\t\t\tName:        \"some_id\",\n\t\t\t\t\t\tDescription: \"Some ID\",\n\t\t\t\t\t\tIn:          paramType,\n\t\t\t\t\t\tRequired:    true,\n\t\t\t\t\t},\n\t\t\t\t}})\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"string\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tfor _, paramType := range []string{\"header\", \"path\", \"query\", \"formData\"} {\n\t\t\tt.Run(paramType, func(t *testing.T) {\n\t\t\t\to := NewOperation(nil)\n\t\t\t\terr := o.ParseComment(`@Param some_string `+paramType+` string true \"Some String\"`, nil)\n\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, o.Parameters, []spec.Parameter{{\n\t\t\t\t\tSimpleSchema: spec.SimpleSchema{\n\t\t\t\t\t\tType: \"string\",\n\t\t\t\t\t},\n\t\t\t\t\tParamProps: spec.ParamProps{\n\t\t\t\t\t\tName:        \"some_string\",\n\t\t\t\t\t\tDescription: \"Some String\",\n\t\t\t\t\t\tIn:          paramType,\n\t\t\t\t\t\tRequired:    true,\n\t\t\t\t\t},\n\t\t\t\t}})\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tfor _, paramType := range []string{\"header\", \"path\", \"query\", \"formData\"} {\n\t\t\tt.Run(paramType, func(t *testing.T) {\n\t\t\t\t// unknown object returns error\n\t\t\t\tassert.Error(t, NewOperation(nil).ParseComment(`@Param some_object `+paramType+` main.Object true \"Some Object\"`, nil))\n\n\t\t\t\t// verify objects are supported here\n\t\t\t\to := NewOperation(nil)\n\t\t\t\to.parser.addTestType(\"main.TestObject\")\n\t\t\t\terr := o.ParseComment(`@Param some_object `+paramType+` main.TestObject true \"Some Object\"`, nil)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t})\n\t\t}\n\t})\n}\n\n// Test ParseParamComment Query Params\nfunc TestParseParamCommentBodyArray(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param names body []string true \"Users List\"`\n\to := NewOperation(nil)\n\terr := o.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, o.Parameters, []spec.Parameter{{\n\t\tParamProps: spec.ParamProps{\n\t\t\tName:        \"names\",\n\t\t\tDescription: \"Users List\",\n\t\t\tIn:          \"body\",\n\t\t\tRequired:    true,\n\t\t\tSchema: &spec.Schema{\n\t\t\t\tSchemaProps: spec.SchemaProps{\n\t\t\t\t\tType: []string{\"array\"},\n\t\t\t\t\tItems: &spec.SchemaOrArray{\n\t\t\t\t\t\tSchema: &spec.Schema{\n\t\t\t\t\t\t\tSchemaProps: spec.SchemaProps{\n\t\t\t\t\t\t\t\tType: []string{\"string\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}})\n}\n\n// Test ParseParamComment Params\nfunc TestParseParamCommentArray(t *testing.T) {\n\tparamTypes := []string{\"header\", \"path\", \"query\"}\n\n\tfor _, paramType := range paramTypes {\n\t\tt.Run(paramType, func(t *testing.T) {\n\t\t\toperation := NewOperation(nil)\n\t\t\terr := operation.ParseComment(`@Param names `+paramType+` []string true \"Users List\"`, nil)\n\n\t\t\tassert.NoError(t, err)\n\n\t\t\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\t\t\texpected := `[\n    {\n        \"type\": \"array\",\n        \"items\": {\n            \"type\": \"string\"\n        },\n        \"description\": \"Users List\",\n        \"name\": \"names\",\n        \"in\": \"` + paramType + `\",\n        \"required\": true\n    }\n]`\n\t\t\tassert.Equal(t, expected, string(b))\n\n\t\t\terr = operation.ParseComment(`@Param names `+paramType+` []model.User true \"Users List\"`, nil)\n\t\t\tassert.Error(t, err)\n\t\t})\n\t}\n}\n\n// Test TestParseParamCommentDefaultValue Query Params\nfunc TestParseParamCommentDefaultValue(t *testing.T) {\n\tt.Parallel()\n\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(`@Param names query string true \"Users List\" default(test)`, nil)\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"type\": \"string\",\n        \"default\": \"test\",\n        \"description\": \"Users List\",\n        \"name\": \"names\",\n        \"in\": \"query\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\n// Test ParseParamComment Query Params\nfunc TestParseParamCommentQueryArrayFormat(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param names query []string true \"Users List\" collectionFormat(multi)`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"type\": \"array\",\n        \"items\": {\n            \"type\": \"string\"\n        },\n        \"collectionFormat\": \"multi\",\n        \"description\": \"Users List\",\n        \"name\": \"names\",\n        \"in\": \"query\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseParamCommentByID(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param unsafe_id[lte] query int true \"Unsafe query param\"`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"type\": \"integer\",\n        \"description\": \"Unsafe query param\",\n        \"name\": \"unsafe_id[lte]\",\n        \"in\": \"query\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseParamCommentWithMultilineDescriptions(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param some_id query int true \"First line\\nSecond line\\nThird line\"`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"type\": \"integer\",\n        \"description\": \"First line\\nSecond line\\nThird line\",\n        \"name\": \"some_id\",\n        \"in\": \"query\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseParamCommentByQueryType(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param some_id query int true \"Some ID\"`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"type\": \"integer\",\n        \"description\": \"Some ID\",\n        \"name\": \"some_id\",\n        \"in\": \"query\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseParamCommentByBodyType(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param some_id body model.OrderRow true \"Some ID\"`\n\toperation := NewOperation(nil)\n\n\toperation.parser.addTestType(\"model.OrderRow\")\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"description\": \"Some ID\",\n        \"name\": \"some_id\",\n        \"in\": \"body\",\n        \"required\": true,\n        \"schema\": {\n            \"$ref\": \"#/definitions/model.OrderRow\"\n        }\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseParamCommentByBodyTextPlain(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param text body string true \"Text to process\"`\n\toperation := NewOperation(nil)\n\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"description\": \"Text to process\",\n        \"name\": \"text\",\n        \"in\": \"body\",\n        \"required\": true,\n        \"schema\": {\n            \"type\": \"string\"\n        }\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\n// TODO: fix this\nfunc TestParseParamCommentByBodyEnumsText(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param text body string true \"description\" Enums(ENUM1, ENUM2, ENUM3)`\n\toperation := NewOperation(nil)\n\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"description\": \"description\",\n        \"name\": \"text\",\n        \"in\": \"body\",\n        \"required\": true,\n        \"schema\": {\n            \"type\": \"string\",\n            \"enum\": [\n                \"ENUM1\",\n                \"ENUM2\",\n                \"ENUM3\"\n            ]\n        }\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseParamCommentByBodyTypeWithDeepNestedFields(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param body body model.CommonHeader{data=string,data2=int} true \"test deep\"`\n\toperation := NewOperation(nil)\n\n\toperation.parser.addTestType(\"model.CommonHeader\")\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\tassert.Len(t, operation.Parameters, 1)\n\tassert.Equal(t, \"test deep\", operation.Parameters[0].Description)\n\tassert.True(t, operation.Parameters[0].Required)\n\n\tb, err := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\tassert.NoError(t, err)\n\texpected := `[\n    {\n        \"description\": \"test deep\",\n        \"name\": \"body\",\n        \"in\": \"body\",\n        \"required\": true,\n        \"schema\": {\n            \"allOf\": [\n                {\n                    \"$ref\": \"#/definitions/model.CommonHeader\"\n                },\n                {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"data\": {\n                            \"type\": \"string\"\n                        },\n                        \"data2\": {\n                            \"type\": \"integer\"\n                        }\n                    }\n                }\n            ]\n        }\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseParamCommentByBodyTypeArrayOfPrimitiveGo(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param some_id body []int true \"Some ID\"`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"description\": \"Some ID\",\n        \"name\": \"some_id\",\n        \"in\": \"body\",\n        \"required\": true,\n        \"schema\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"integer\"\n            }\n        }\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseParamCommentByBodyTypeArrayOfPrimitiveGoWithDeepNestedFields(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param body body []model.CommonHeader{data=string,data2=int} true \"test deep\"`\n\toperation := NewOperation(nil)\n\toperation.parser.addTestType(\"model.CommonHeader\")\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\tassert.Len(t, operation.Parameters, 1)\n\tassert.Equal(t, \"test deep\", operation.Parameters[0].Description)\n\tassert.True(t, operation.Parameters[0].Required)\n\n\tb, err := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\tassert.NoError(t, err)\n\texpected := `[\n    {\n        \"description\": \"test deep\",\n        \"name\": \"body\",\n        \"in\": \"body\",\n        \"required\": true,\n        \"schema\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"allOf\": [\n                    {\n                        \"$ref\": \"#/definitions/model.CommonHeader\"\n                    },\n                    {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"data\": {\n                                \"type\": \"string\"\n                            },\n                            \"data2\": {\n                                \"type\": \"integer\"\n                            }\n                        }\n                    }\n                ]\n            }\n        }\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseParamCommentByBodyTypeErr(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param some_id body model.OrderRow true \"Some ID\"`\n\toperation := NewOperation(nil)\n\toperation.parser.addTestType(\"model.notexist\")\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.Error(t, err)\n}\n\nfunc TestParseParamCommentByFormDataType(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param file formData file true \"this is a test file\"`\n\toperation := NewOperation(nil)\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"type\": \"file\",\n        \"description\": \"this is a test file\",\n        \"name\": \"file\",\n        \"in\": \"formData\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseParamCommentByFormDataTypeUint64(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param file formData uint64 true \"this is a test file\"`\n\toperation := NewOperation(nil)\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"type\": \"integer\",\n        \"format\": \"int64\",\n        \"description\": \"this is a test file\",\n        \"name\": \"file\",\n        \"in\": \"formData\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseParamCommentByNotSupportedType(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param some_id not_supported int true \"Some ID\"`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.Error(t, err)\n}\n\nfunc TestParseParamCommentNotMatch(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param some_id body mock true`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.Error(t, err)\n}\n\nfunc TestParseParamCommentByEnums(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param some_id query string true \"Some ID\" Enums(A, B, C)`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"enum\": [\n            \"A\",\n            \"B\",\n            \"C\"\n        ],\n        \"type\": \"string\",\n        \"description\": \"Some ID\",\n        \"name\": \"some_id\",\n        \"in\": \"query\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n\n\tcomment = `@Param some_id query int true \"Some ID\" Enums(1, 2, 3)`\n\toperation = NewOperation(nil)\n\terr = operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ = json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected = `[\n    {\n        \"enum\": [\n            1,\n            2,\n            3\n        ],\n        \"type\": \"integer\",\n        \"description\": \"Some ID\",\n        \"name\": \"some_id\",\n        \"in\": \"query\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n\n\tcomment = `@Param some_id query number true \"Some ID\" Enums(1.1, 2.2, 3.3)`\n\toperation = NewOperation(nil)\n\terr = operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ = json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected = `[\n    {\n        \"enum\": [\n            1.1,\n            2.2,\n            3.3\n        ],\n        \"type\": \"number\",\n        \"description\": \"Some ID\",\n        \"name\": \"some_id\",\n        \"in\": \"query\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n\n\tcomment = `@Param some_id query bool true \"Some ID\" Enums(true, false)`\n\toperation = NewOperation(nil)\n\terr = operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ = json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected = `[\n    {\n        \"enum\": [\n            true,\n            false\n        ],\n        \"type\": \"boolean\",\n        \"description\": \"Some ID\",\n        \"name\": \"some_id\",\n        \"in\": \"query\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n\n\toperation = NewOperation(nil)\n\n\tcomment = `@Param some_id query int true \"Some ID\" Enums(A, B, C)`\n\tassert.Error(t, operation.ParseComment(comment, nil))\n\n\tcomment = `@Param some_id query number true \"Some ID\" Enums(A, B, C)`\n\tassert.Error(t, operation.ParseComment(comment, nil))\n\n\tcomment = `@Param some_id query boolean true \"Some ID\" Enums(A, B, C)`\n\tassert.Error(t, operation.ParseComment(comment, nil))\n\n\tcomment = `@Param some_id query Document true \"Some ID\" Enums(A, B, C)`\n\tassert.Error(t, operation.ParseComment(comment, nil))\n}\n\nfunc TestParseParamCommentByMaxLength(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param some_id query string true \"Some ID\" MaxLength(10)`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"maxLength\": 10,\n        \"type\": \"string\",\n        \"description\": \"Some ID\",\n        \"name\": \"some_id\",\n        \"in\": \"query\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n\n\tcomment = `@Param some_id query int true \"Some ID\" MaxLength(10)`\n\tassert.Error(t, operation.ParseComment(comment, nil))\n\n\tcomment = `@Param some_id query string true \"Some ID\" MaxLength(Goopher)`\n\tassert.Error(t, operation.ParseComment(comment, nil))\n}\n\nfunc TestParseParamCommentByMinLength(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param some_id query string true \"Some ID\" MinLength(10)`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"minLength\": 10,\n        \"type\": \"string\",\n        \"description\": \"Some ID\",\n        \"name\": \"some_id\",\n        \"in\": \"query\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n\n\tcomment = `@Param some_id query int true \"Some ID\" MinLength(10)`\n\tassert.Error(t, operation.ParseComment(comment, nil))\n\n\tcomment = `@Param some_id query string true \"Some ID\" MinLength(Goopher)`\n\tassert.Error(t, operation.ParseComment(comment, nil))\n}\n\nfunc TestParseParamCommentByMinimum(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param some_id query int true \"Some ID\" Minimum(10)`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"minimum\": 10,\n        \"type\": \"integer\",\n        \"description\": \"Some ID\",\n        \"name\": \"some_id\",\n        \"in\": \"query\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n\n\tcomment = `@Param some_id query int true \"Some ID\" Mininum(10)`\n\tassert.NoError(t, operation.ParseComment(comment, nil))\n\n\tcomment = `@Param some_id query string true \"Some ID\" Minimum(10)`\n\tassert.Error(t, operation.ParseComment(comment, nil))\n\n\tcomment = `@Param some_id query integer true \"Some ID\" Minimum(Goopher)`\n\tassert.Error(t, operation.ParseComment(comment, nil))\n}\n\nfunc TestParseParamCommentByMaximum(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param some_id query int true \"Some ID\" Maximum(10)`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"maximum\": 10,\n        \"type\": \"integer\",\n        \"description\": \"Some ID\",\n        \"name\": \"some_id\",\n        \"in\": \"query\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n\n\tcomment = `@Param some_id query int true \"Some ID\" Maxinum(10)`\n\tassert.NoError(t, operation.ParseComment(comment, nil))\n\n\tcomment = `@Param some_id query string true \"Some ID\" Maximum(10)`\n\tassert.Error(t, operation.ParseComment(comment, nil))\n\n\tcomment = `@Param some_id query integer true \"Some ID\" Maximum(Goopher)`\n\tassert.Error(t, operation.ParseComment(comment, nil))\n}\n\nfunc TestParseParamCommentByDefault(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param some_id query int true \"Some ID\" Default(10)`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"type\": \"integer\",\n        \"default\": 10,\n        \"description\": \"Some ID\",\n        \"name\": \"some_id\",\n        \"in\": \"query\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseParamCommentByExampleInt(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param some_id query int true \"Some ID\" Example(10)`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"type\": \"integer\",\n        \"example\": 10,\n        \"description\": \"Some ID\",\n        \"name\": \"some_id\",\n        \"in\": \"query\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseParamCommentByExampleString(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param some_id query string true \"Some ID\" Example(True feelings)`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"type\": \"string\",\n        \"example\": \"True feelings\",\n        \"description\": \"Some ID\",\n        \"name\": \"some_id\",\n        \"in\": \"query\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseParamCommentByExampleUnsupportedType(t *testing.T) {\n\tt.Parallel()\n\tvar param spec.Parameter\n\n\tsetExample(&param, \"something\", \"random value\")\n\tassert.Equal(t, param.Example, nil)\n\n\tsetExample(&param, STRING, \"string value\")\n\tassert.Equal(t, param.Example, \"string value\")\n\n\tsetExample(&param, INTEGER, \"10\")\n\tassert.Equal(t, param.Example, 10)\n\n\tsetExample(&param, NUMBER, \"10\")\n\tassert.Equal(t, param.Example, float64(10))\n}\n\nfunc TestParseParamCommentBySchemaExampleString(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param some_id body string true \"Some ID\" SchemaExample(True feelings)`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"description\": \"Some ID\",\n        \"name\": \"some_id\",\n        \"in\": \"body\",\n        \"required\": true,\n        \"schema\": {\n            \"type\": \"string\",\n            \"example\": \"True feelings\"\n        }\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseParamCommentBySchemaExampleUnsupportedType(t *testing.T) {\n\tt.Parallel()\n\tvar param spec.Parameter\n\n\tsetSchemaExample(&param, \"something\", \"random value\")\n\tassert.Nil(t, param.Schema)\n\n\tsetSchemaExample(&param, STRING, \"string value\")\n\tassert.Nil(t, param.Schema)\n\n\tparam.Schema = &spec.Schema{}\n\tsetSchemaExample(&param, STRING, \"string value\")\n\tassert.Equal(t, \"string value\", param.Schema.Example)\n\n\tsetSchemaExample(&param, INTEGER, \"10\")\n\tassert.Equal(t, 10, param.Schema.Example)\n\n\tsetSchemaExample(&param, NUMBER, \"10\")\n\tassert.Equal(t, float64(10), param.Schema.Example)\n\n\tsetSchemaExample(&param, STRING, \"string \\\\r\\\\nvalue\")\n\tassert.Equal(t, \"string \\r\\nvalue\", param.Schema.Example)\n}\n\nfunc TestParseParamArrayWithEnums(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Param field query []string true \"An enum collection\" collectionFormat(csv) enums(also,valid)`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"type\": \"array\",\n        \"items\": {\n            \"enum\": [\n                \"also\",\n                \"valid\"\n            ],\n            \"type\": \"string\"\n        },\n        \"collectionFormat\": \"csv\",\n        \"description\": \"An enum collection\",\n        \"name\": \"field\",\n        \"in\": \"query\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseAndExtractionParamAttribute(t *testing.T) {\n\tt.Parallel()\n\n\top := NewOperation(nil)\n\tnumberParam := spec.Parameter{}\n\terr := op.parseParamAttribute(\n\t\t\" default(1) maximum(100) minimum(0) format(csv)\",\n\t\t\"\",\n\t\tNUMBER,\n\t\t\"\",\n\t\t&numberParam,\n\t)\n\tassert.NoError(t, err)\n\tassert.Equal(t, float64(0), *numberParam.Minimum)\n\tassert.Equal(t, float64(100), *numberParam.Maximum)\n\tassert.Equal(t, \"csv\", numberParam.SimpleSchema.Format)\n\tassert.Equal(t, float64(1), numberParam.Default)\n\n\terr = op.parseParamAttribute(\" minlength(1)\", \"\", NUMBER, \"\", nil)\n\tassert.Error(t, err)\n\n\terr = op.parseParamAttribute(\" maxlength(1)\", \"\", NUMBER, \"\", nil)\n\tassert.Error(t, err)\n\n\tstringParam := spec.Parameter{}\n\terr = op.parseParamAttribute(\n\t\t\" default(test) maxlength(100) minlength(0) format(csv)\",\n\t\t\"\",\n\t\tSTRING,\n\t\t\"\",\n\t\t&stringParam,\n\t)\n\tassert.NoError(t, err)\n\tassert.Equal(t, int64(0), *stringParam.MinLength)\n\tassert.Equal(t, int64(100), *stringParam.MaxLength)\n\tassert.Equal(t, \"csv\", stringParam.SimpleSchema.Format)\n\terr = op.parseParamAttribute(\" minimum(0)\", \"\", STRING, \"\", nil)\n\tassert.Error(t, err)\n\n\terr = op.parseParamAttribute(\" maximum(0)\", \"\", STRING, \"\", nil)\n\tassert.Error(t, err)\n\n\tarrayParram := spec.Parameter{}\n\terr = op.parseParamAttribute(\" collectionFormat(tsv)\", ARRAY, STRING, \"\", &arrayParram)\n\tassert.Equal(t, \"tsv\", arrayParram.CollectionFormat)\n\tassert.NoError(t, err)\n\n\terr = op.parseParamAttribute(\" collectionFormat(tsv)\", STRING, STRING, \"\", nil)\n\tassert.Error(t, err)\n\n\terr = op.parseParamAttribute(\" default(0)\", \"\", ARRAY, \"\", nil)\n\tassert.NoError(t, err)\n}\n\nfunc TestParseParamCommentByExtensions(t *testing.T) {\n\tcomment := `@Param some_id path int true \"Some ID\" extensions(x-example=test,x-custom=Goopher,x-custom2)`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(operation.Parameters, \"\", \"    \")\n\texpected := `[\n    {\n        \"type\": \"integer\",\n        \"x-custom\": \"Goopher\",\n        \"x-custom2\": true,\n        \"x-example\": \"test\",\n        \"description\": \"Some ID\",\n        \"name\": \"some_id\",\n        \"in\": \"path\",\n        \"required\": true\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseParamStructCodeExample(t *testing.T) {\n\tt.Parallel()\n\n\tfset := token.NewFileSet()\n\tast, err := goparser.ParseFile(fset, \"operation_test.go\", `package swag\n\timport structs \"github.com/swaggo/swag/testdata/param_structs\"\n\t`, goparser.ParseComments)\n\tassert.NoError(t, err)\n\n\tparser := New()\n\terr = parser.parseFile(\"github.com/swaggo/swag/testdata/param_structs\", \"testdata/param_structs/structs.go\", nil, ParseModels)\n\tassert.NoError(t, err)\n\t_, err = parser.packages.ParseTypes()\n\tassert.NoError(t, err)\n\n\tvalidateParameters := func(operation *Operation, params ...spec.Parameter) {\n\t\tassert.Equal(t, len(params), len(operation.Parameters))\n\n\t\tfor _, param := range params {\n\t\t\tfound := false\n\t\t\tfor _, p := range operation.Parameters {\n\t\t\t\tif p.Name == param.Name {\n\t\t\t\t\tassert.Equal(t, param.ParamProps, p.ParamProps)\n\t\t\t\t\tassert.Equal(t, param.CommonValidations, p.CommonValidations)\n\t\t\t\t\tassert.Equal(t, param.SimpleSchema, p.SimpleSchema)\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert.True(t, found, \"found parameter %s\", param.Name)\n\t\t}\n\t}\n\n\t// values used in validation checks\n\tmax := float64(10)\n\tmaxLen := int64(10)\n\tmin := float64(0)\n\n\t// query and form behave the same\n\tfor _, param := range []string{\"query\", \"formData\"} {\n\t\tt.Run(param+\" struct\", func(t *testing.T) {\n\t\t\toperation := NewOperation(parser)\n\t\t\tcomment := fmt.Sprintf(`@Param model %s structs.FormModel true \"query params\"`, param)\n\t\t\terr = operation.ParseComment(comment, ast)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tvalidateParameters(operation,\n\t\t\t\tspec.Parameter{\n\t\t\t\t\tParamProps: spec.ParamProps{\n\t\t\t\t\t\tName:        \"f\",\n\t\t\t\t\t\tDescription: \"\",\n\t\t\t\t\t\tIn:          param,\n\t\t\t\t\t\tRequired:    true,\n\t\t\t\t\t},\n\t\t\t\t\tCommonValidations: spec.CommonValidations{\n\t\t\t\t\t\tMaxLength: &maxLen,\n\t\t\t\t\t},\n\t\t\t\t\tSimpleSchema: spec.SimpleSchema{\n\t\t\t\t\t\tType: \"string\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tspec.Parameter{\n\t\t\t\t\tParamProps: spec.ParamProps{\n\t\t\t\t\t\tName:        \"b\",\n\t\t\t\t\t\tDescription: \"B is another field\",\n\t\t\t\t\t\tIn:          param,\n\t\t\t\t\t},\n\t\t\t\t\tSimpleSchema: spec.SimpleSchema{\n\t\t\t\t\t\tType: \"boolean\",\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t})\n\t}\n\n\tt.Run(\"header struct\", func(t *testing.T) {\n\t\toperation := NewOperation(parser)\n\t\tcomment := `@Param auth header structs.AuthHeader true \"auth header\"`\n\t\terr = operation.ParseComment(comment, ast)\n\t\tassert.NoError(t, err)\n\n\t\tvalidateParameters(operation,\n\t\t\tspec.Parameter{\n\t\t\t\tParamProps: spec.ParamProps{\n\t\t\t\t\tName:        \"X-Auth-Token\",\n\t\t\t\t\tDescription: \"Token is the auth token\",\n\t\t\t\t\tIn:          \"header\",\n\t\t\t\t\tRequired:    true,\n\t\t\t\t},\n\t\t\t\tSimpleSchema: spec.SimpleSchema{\n\t\t\t\t\tType: \"string\",\n\t\t\t\t},\n\t\t\t}, spec.Parameter{\n\t\t\t\tParamProps: spec.ParamProps{\n\t\t\t\t\tName:        \"anotherHeader\",\n\t\t\t\t\tDescription: \"AnotherHeader is another header\",\n\t\t\t\t\tIn:          \"header\",\n\t\t\t\t},\n\t\t\t\tCommonValidations: spec.CommonValidations{\n\t\t\t\t\tMaximum: &max,\n\t\t\t\t\tMinimum: &min,\n\t\t\t\t},\n\t\t\t\tSimpleSchema: spec.SimpleSchema{\n\t\t\t\t\tType: \"integer\",\n\t\t\t\t},\n\t\t\t})\n\t})\n\n\tt.Run(\"path struct\", func(t *testing.T) {\n\t\toperation := NewOperation(parser)\n\t\tcomment := `@Param path path structs.PathModel true \"path params\"`\n\t\terr = operation.ParseComment(comment, ast)\n\t\tassert.NoError(t, err)\n\n\t\tvalidateParameters(operation,\n\t\t\tspec.Parameter{\n\t\t\t\tParamProps: spec.ParamProps{\n\t\t\t\t\tName:        \"id\",\n\t\t\t\t\tDescription: \"ID is the id\",\n\t\t\t\t\tIn:          \"path\",\n\t\t\t\t\tRequired:    true,\n\t\t\t\t},\n\t\t\t\tSimpleSchema: spec.SimpleSchema{\n\t\t\t\t\tType: \"integer\",\n\t\t\t\t},\n\t\t\t}, spec.Parameter{\n\t\t\t\tParamProps: spec.ParamProps{\n\t\t\t\t\tName:        \"name\",\n\t\t\t\t\tDescription: \"\",\n\t\t\t\t\tIn:          \"path\",\n\t\t\t\t},\n\t\t\t\tCommonValidations: spec.CommonValidations{\n\t\t\t\t\tMaxLength: &maxLen,\n\t\t\t\t},\n\t\t\t\tSimpleSchema: spec.SimpleSchema{\n\t\t\t\t\tType: \"string\",\n\t\t\t\t},\n\t\t\t})\n\t})\n}\n\nfunc TestParseIdComment(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Id myOperationId`\n\toperation := NewOperation(nil)\n\terr := operation.ParseComment(comment, nil)\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"myOperationId\", operation.ID)\n}\n\nfunc TestFindTypeDefCoreLib(t *testing.T) {\n\tt.Parallel()\n\n\ts, err := findTypeDef(\"net/http\", \"Request\")\n\tassert.NoError(t, err)\n\tassert.NotNil(t, s)\n}\n\nfunc TestFindTypeDefExternalPkg(t *testing.T) {\n\tt.Parallel()\n\n\ts, err := findTypeDef(\"github.com/KyleBanks/depth\", \"Tree\")\n\tassert.NoError(t, err)\n\tassert.NotNil(t, s)\n}\n\nfunc TestFindTypeDefInvalidPkg(t *testing.T) {\n\tt.Parallel()\n\n\ts, err := findTypeDef(\"does-not-exist\", \"foo\")\n\tassert.Error(t, err)\n\tassert.Nil(t, s)\n}\n\nfunc TestParseSecurityComment(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Security OAuth2Implicit[read, write]`\n\toperation := NewOperation(nil)\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, operation.Security, []map[string][]string{\n\t\t{\n\t\t\t\"OAuth2Implicit\": {\"read\", \"write\"},\n\t\t},\n\t})\n}\n\nfunc TestParseSecurityCommentSimple(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Security ApiKeyAuth`\n\toperation := NewOperation(nil)\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, operation.Security, []map[string][]string{\n\t\t{\n\t\t\t\"ApiKeyAuth\": {},\n\t\t},\n\t})\n}\n\nfunc TestParseSecurityCommentAnd(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Security OAuth2Implicit[read, write] && Firebase[]`\n\toperation := NewOperation(nil)\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\texpect := []map[string][]string{\n\t\t{\n\t\t\t\"OAuth2Implicit\": {\"read\", \"write\"},\n\t\t\t\"Firebase\":       {\"\"},\n\t\t},\n\t}\n\tassert.Equal(t, operation.Security, expect)\n\n\toldVersionComment := `@Security OAuth2Implicit[read, write] || Firebase[]`\n\toperation = NewOperation(nil)\n\terr = operation.ParseComment(oldVersionComment, nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, operation.Security, expect)\n}\n\nfunc TestParseMultiDescription(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Description line one`\n\toperation := NewOperation(nil)\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tcomment = `@Tags multi`\n\terr = operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tcomment = `@Description line two x`\n\terr = operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(operation, \"\", \"    \")\n\n\texpected := `\"description\": \"line one\\nline two x\"`\n\tassert.Contains(t, string(b), expected)\n}\n\nfunc TestParseDescriptionMarkdown(t *testing.T) {\n\tt.Parallel()\n\n\toperation := NewOperation(nil)\n\toperation.parser.markdownFileDir = \"example/markdown\"\n\n\tcomment := `@description.markdown admin.md`\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tcomment = `@description.markdown missing.md`\n\n\terr = operation.ParseComment(comment, nil)\n\tassert.Error(t, err)\n}\n\nfunc TestParseSummary(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@summary line one`\n\toperation := NewOperation(nil)\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tcomment = `@Summary line one`\n\terr = operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n}\n\nfunc TestParseDeprecationDescription(t *testing.T) {\n\tt.Parallel()\n\n\tcomment := `@Deprecated`\n\toperation := NewOperation(nil)\n\n\terr := operation.ParseComment(comment, nil)\n\tassert.NoError(t, err)\n\n\tif !operation.Deprecated {\n\t\tt.Error(\"Failed to parse @deprecated comment\")\n\t}\n}\n\nfunc TestParseExtentions(t *testing.T) {\n\tt.Parallel()\n\t// Fail if there are no args for attributes.\n\t{\n\t\tcomment := `@x-amazon-apigateway-integration`\n\t\toperation := NewOperation(nil)\n\n\t\terr := operation.ParseComment(comment, nil)\n\t\tassert.EqualError(t, err, \"annotation @x-amazon-apigateway-integration need a value\")\n\t}\n\n\t// Fail if args of attributes are broken.\n\t{\n\t\tcomment := `@x-amazon-apigateway-integration [\"broken\"}]`\n\t\toperation := NewOperation(nil)\n\n\t\terr := operation.ParseComment(comment, nil)\n\t\tassert.EqualError(t, err, \"annotation @x-amazon-apigateway-integration need a valid json value\")\n\t}\n\n\t// OK\n\t{\n\t\tcomment := `@x-amazon-apigateway-integration {\"uri\": \"${some_arn}\", \"passthroughBehavior\": \"when_no_match\", \"httpMethod\": \"POST\", \"type\": \"aws_proxy\"}`\n\t\toperation := NewOperation(nil)\n\n\t\terr := operation.ParseComment(comment, nil)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, operation.Extensions[\"x-amazon-apigateway-integration\"],\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"httpMethod\":          \"POST\",\n\t\t\t\t\"passthroughBehavior\": \"when_no_match\",\n\t\t\t\t\"type\":                \"aws_proxy\",\n\t\t\t\t\"uri\":                 \"${some_arn}\",\n\t\t\t})\n\t}\n\n\t// Test x-tagGroups\n\t{\n\t\tcomment := `@x-tagGroups [{\"name\":\"Natural Persons\",\"tags\":[\"Person\",\"PersonRisk\",\"PersonDocuments\"]}]`\n\t\toperation := NewOperation(nil)\n\n\t\terr := operation.ParseComment(comment, nil)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, operation.Extensions[\"x-tagGroups\"],\n\t\t\t[]interface{}{map[string]interface{}{\n\t\t\t\t\"name\": \"Natural Persons\",\n\t\t\t\t\"tags\": []interface{}{\n\t\t\t\t\t\"Person\",\n\t\t\t\t\t\"PersonRisk\",\n\t\t\t\t\t\"PersonDocuments\",\n\t\t\t\t},\n\t\t\t}})\n\t}\n}\n\nfunc TestFindInSlice(t *testing.T) {\n\tt.Parallel()\n\n\tassert.True(t, findInSlice([]string{\"one\", \"two\", \"tree\"}, \"one\"))\n\tassert.True(t, findInSlice([]string{\"tree\", \"two\", \"one\"}, \"one\"))\n\tassert.True(t, findInSlice([]string{\"two\", \"one\", \"tree\"}, \"one\"))\n\tassert.False(t, findInSlice([]string{\"one\", \"two\", \"tree\"}, \"four\"))\n}\n\nfunc TestParseResponseHeaderComment(t *testing.T) {\n\tt.Parallel()\n\n\toperation := NewOperation(nil)\n\toperation.Responses = &spec.Responses{}\n\terr := operation.ParseResponseComment(`default {string} string \"other error\"`, nil)\n\tassert.NoError(t, err)\n\terr = operation.ParseResponseHeaderComment(`all {string} Token \"qwerty\"`, nil)\n\tassert.NoError(t, err)\n}\n\nfunc TestParseObjectSchema(t *testing.T) {\n\tt.Parallel()\n\n\toperation := NewOperation(nil)\n\n\tschema, err := operation.parseObjectSchema(\"interface{}\", nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, schema, &spec.Schema{})\n\n\tschema, err = operation.parseObjectSchema(\"any\", nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, schema, &spec.Schema{})\n\n\tschema, err = operation.parseObjectSchema(\"any{data=string}\", nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, schema,\n\t\t(&spec.Schema{}).WithAllOf(spec.Schema{}, *PrimitiveSchema(OBJECT).SetProperty(\"data\", *PrimitiveSchema(\"string\"))))\n\n\tschema, err = operation.parseObjectSchema(\"int\", nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, schema, PrimitiveSchema(INTEGER))\n\n\tschema, err = operation.parseObjectSchema(\"[]string\", nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, schema, spec.ArrayProperty(PrimitiveSchema(STRING)))\n\n\tschema, err = operation.parseObjectSchema(\"[]int\", nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, schema, spec.ArrayProperty(PrimitiveSchema(INTEGER)))\n\n\t_, err = operation.parseObjectSchema(\"[]bleah\", nil)\n\tassert.Error(t, err)\n\n\tschema, err = operation.parseObjectSchema(\"map[]string\", nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, schema, spec.MapProperty(PrimitiveSchema(STRING)))\n\n\tschema, err = operation.parseObjectSchema(\"map[]int\", nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, schema, spec.MapProperty(PrimitiveSchema(INTEGER)))\n\n\tschema, err = operation.parseObjectSchema(\"map[]interface{}\", nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, schema, spec.MapProperty(nil))\n\n\t_, err = operation.parseObjectSchema(\"map[string\", nil)\n\tassert.Error(t, err)\n\n\t_, err = operation.parseObjectSchema(\"map[]bleah\", nil)\n\tassert.Error(t, err)\n\n\toperation.parser = New()\n\toperation.parser.packages = &PackagesDefinitions{\n\t\tuniqueDefinitions: map[string]*TypeSpecDef{\n\t\t\t\"model.User\": {\n\t\t\t\tFile: &ast.File{\n\t\t\t\t\tName: &ast.Ident{\n\t\t\t\t\t\tName: \"user.go\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tTypeSpec: &ast.TypeSpec{\n\t\t\t\t\tName: &ast.Ident{\n\t\t\t\t\t\tName: \"User\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\t_, err = operation.parseObjectSchema(\"model.User\", nil)\n\tassert.NoError(t, err)\n\n\toperation.parser = nil\n\tschema, err = operation.parseObjectSchema(\"user.Model\", nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, schema, RefSchema(\"user.Model\"))\n}\n\nfunc TestParseCodeSamples(t *testing.T) {\n\tt.Parallel()\n\tconst comment = `@x-codeSamples file`\n\tt.Run(\"Find sample by file\", func(t *testing.T) {\n\n\t\toperation := NewOperation(nil, SetCodeExampleFilesDirectory(\"testdata/code_examples\"))\n\t\toperation.Summary = \"example\"\n\n\t\terr := operation.ParseComment(comment, nil)\n\t\tassert.NoError(t, err, \"no error should be thrown\")\n\t\tassert.Equal(t, operation.Summary, \"example\")\n\t\tassert.Equal(t, operation.Extensions[\"x-codeSamples\"],\n\t\t\tmap[string]interface{}{\"lang\": \"JavaScript\", \"source\": \"console.log('Hello World');\"})\n\t})\n\n\tt.Run(\"With broken file sample\", func(t *testing.T) {\n\t\toperation := NewOperation(nil, SetCodeExampleFilesDirectory(\"testdata/code_examples\"))\n\t\toperation.Summary = \"broken\"\n\n\t\terr := operation.ParseComment(comment, nil)\n\t\tassert.Error(t, err, \"no error should be thrown\")\n\t})\n\n\tt.Run(\"Example file not found\", func(t *testing.T) {\n\t\toperation := NewOperation(nil, SetCodeExampleFilesDirectory(\"testdata/code_examples\"))\n\t\toperation.Summary = \"badExample\"\n\n\t\terr := operation.ParseComment(comment, nil)\n\t\tassert.Error(t, err, \"error was expected, as file does not exist\")\n\t})\n\n\tt.Run(\"Without line reminder\", func(t *testing.T) {\n\t\tcomment := `@x-codeSamples`\n\t\toperation := NewOperation(nil, SetCodeExampleFilesDirectory(\"testdata/code_examples\"))\n\t\toperation.Summary = \"example\"\n\n\t\terr := operation.ParseComment(comment, nil)\n\t\tassert.Error(t, err, \"no error should be thrown\")\n\t})\n\n\tt.Run(\" broken dir\", func(t *testing.T) {\n\t\toperation := NewOperation(nil, SetCodeExampleFilesDirectory(\"testdata/fake_examples\"))\n\t\toperation.Summary = \"code\"\n\n\t\terr := operation.ParseComment(comment, nil)\n\t\tassert.Error(t, err, \"no error should be thrown\")\n\t})\n}\n\nfunc TestParseDeprecatedRouter(t *testing.T) {\n\tp := New()\n\tsearchDir := \"./testdata/deprecated_router\"\n\tif err := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth); err != nil {\n\t\tt.Error(\"Failed to parse api: \" + err.Error())\n\t}\n\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\texpected, err := os.ReadFile(filepath.Join(searchDir, \"expected.json\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, expected, b)\n}\n"
        },
        {
          "name": "package.go",
          "type": "blob",
          "size": 5.83203125,
          "content": "package swag\n\nimport (\n\t\"go/ast\"\n\t\"go/token\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// PackageDefinitions files and definition in a package.\ntype PackageDefinitions struct {\n\t// files in this package, map key is file's relative path starting package path\n\tFiles map[string]*ast.File\n\n\t// definitions in this package, map key is typeName\n\tTypeDefinitions map[string]*TypeSpecDef\n\n\t// const variables in this package, map key is the name\n\tConstTable map[string]*ConstVariable\n\n\t// const variables in order in this package\n\tOrderedConst []*ConstVariable\n\n\t// package name\n\tName string\n\n\t// package path\n\tPath string\n}\n\n// ConstVariableGlobalEvaluator an interface used to evaluate enums across packages\ntype ConstVariableGlobalEvaluator interface {\n\tEvaluateConstValue(pkg *PackageDefinitions, cv *ConstVariable, recursiveStack map[string]struct{}) (interface{}, ast.Expr)\n\tEvaluateConstValueByName(file *ast.File, pkgPath, constVariableName string, recursiveStack map[string]struct{}) (interface{}, ast.Expr)\n\tFindTypeSpec(typeName string, file *ast.File) *TypeSpecDef\n}\n\n// NewPackageDefinitions new a PackageDefinitions object\nfunc NewPackageDefinitions(name, pkgPath string) *PackageDefinitions {\n\treturn &PackageDefinitions{\n\t\tName:            name,\n\t\tPath:            pkgPath,\n\t\tFiles:           make(map[string]*ast.File),\n\t\tTypeDefinitions: make(map[string]*TypeSpecDef),\n\t\tConstTable:      make(map[string]*ConstVariable),\n\t}\n}\n\n// AddFile add a file\nfunc (pkg *PackageDefinitions) AddFile(pkgPath string, file *ast.File) *PackageDefinitions {\n\tpkg.Files[pkgPath] = file\n\treturn pkg\n}\n\n// AddTypeSpec add a type spec.\nfunc (pkg *PackageDefinitions) AddTypeSpec(name string, typeSpec *TypeSpecDef) *PackageDefinitions {\n\tpkg.TypeDefinitions[name] = typeSpec\n\treturn pkg\n}\n\n// AddConst add a const variable.\nfunc (pkg *PackageDefinitions) AddConst(astFile *ast.File, valueSpec *ast.ValueSpec) *PackageDefinitions {\n\tfor i := 0; i < len(valueSpec.Names) && i < len(valueSpec.Values); i++ {\n\t\tvariable := &ConstVariable{\n\t\t\tName:    valueSpec.Names[i],\n\t\t\tType:    valueSpec.Type,\n\t\t\tValue:   valueSpec.Values[i],\n\t\t\tComment: valueSpec.Comment,\n\t\t\tFile:    astFile,\n\t\t}\n\t\tpkg.ConstTable[valueSpec.Names[i].Name] = variable\n\t\tpkg.OrderedConst = append(pkg.OrderedConst, variable)\n\t}\n\treturn pkg\n}\n\nfunc (pkg *PackageDefinitions) evaluateConstValue(file *ast.File, iota int, expr ast.Expr, globalEvaluator ConstVariableGlobalEvaluator, recursiveStack map[string]struct{}) (interface{}, ast.Expr) {\n\tswitch valueExpr := expr.(type) {\n\tcase *ast.Ident:\n\t\tif valueExpr.Name == \"iota\" {\n\t\t\treturn iota, nil\n\t\t}\n\t\tif pkg.ConstTable != nil {\n\t\t\tif cv, ok := pkg.ConstTable[valueExpr.Name]; ok {\n\t\t\t\treturn globalEvaluator.EvaluateConstValue(pkg, cv, recursiveStack)\n\t\t\t}\n\t\t}\n\tcase *ast.SelectorExpr:\n\t\tpkgIdent, ok := valueExpr.X.(*ast.Ident)\n\t\tif !ok {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn globalEvaluator.EvaluateConstValueByName(file, pkgIdent.Name, valueExpr.Sel.Name, recursiveStack)\n\tcase *ast.BasicLit:\n\t\tswitch valueExpr.Kind {\n\t\tcase token.INT:\n\t\t\t// handle underscored number, such as 1_000_000\n\t\t\tif strings.ContainsRune(valueExpr.Value, '_') {\n\t\t\t\tvalueExpr.Value = strings.Replace(valueExpr.Value, \"_\", \"\", -1)\n\t\t\t}\n\t\t\tif len(valueExpr.Value) >= 2 && valueExpr.Value[0] == '0' {\n\t\t\t\tvar start, base = 2, 8\n\t\t\t\tswitch valueExpr.Value[1] {\n\t\t\t\tcase 'x', 'X':\n\t\t\t\t\t//hex\n\t\t\t\t\tbase = 16\n\t\t\t\tcase 'b', 'B':\n\t\t\t\t\t//binary\n\t\t\t\t\tbase = 2\n\t\t\t\tdefault:\n\t\t\t\t\t//octet\n\t\t\t\t\tstart = 1\n\t\t\t\t}\n\t\t\t\tif x, err := strconv.ParseInt(valueExpr.Value[start:], base, 64); err == nil {\n\t\t\t\t\treturn int(x), nil\n\t\t\t\t} else if x, err := strconv.ParseUint(valueExpr.Value[start:], base, 64); err == nil {\n\t\t\t\t\treturn x, nil\n\t\t\t\t} else {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//a basic literal integer is int type in default, or must have an explicit converting type in front\n\t\t\tif x, err := strconv.ParseInt(valueExpr.Value, 10, 64); err == nil {\n\t\t\t\treturn int(x), nil\n\t\t\t} else if x, err := strconv.ParseUint(valueExpr.Value, 10, 64); err == nil {\n\t\t\t\treturn x, nil\n\t\t\t} else {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\tcase token.STRING:\n\t\t\tif valueExpr.Value[0] == '`' {\n\t\t\t\treturn valueExpr.Value[1 : len(valueExpr.Value)-1], nil\n\t\t\t}\n\t\t\treturn EvaluateEscapedString(valueExpr.Value[1 : len(valueExpr.Value)-1]), nil\n\t\tcase token.CHAR:\n\t\t\treturn EvaluateEscapedChar(valueExpr.Value[1 : len(valueExpr.Value)-1]), nil\n\t\t}\n\tcase *ast.UnaryExpr:\n\t\tx, evalType := pkg.evaluateConstValue(file, iota, valueExpr.X, globalEvaluator, recursiveStack)\n\t\tif x == nil {\n\t\t\treturn x, evalType\n\t\t}\n\t\treturn EvaluateUnary(x, valueExpr.Op, evalType)\n\tcase *ast.BinaryExpr:\n\t\tx, evalTypex := pkg.evaluateConstValue(file, iota, valueExpr.X, globalEvaluator, recursiveStack)\n\t\ty, evalTypey := pkg.evaluateConstValue(file, iota, valueExpr.Y, globalEvaluator, recursiveStack)\n\t\tif x == nil || y == nil {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn EvaluateBinary(x, y, valueExpr.Op, evalTypex, evalTypey)\n\tcase *ast.ParenExpr:\n\t\treturn pkg.evaluateConstValue(file, iota, valueExpr.X, globalEvaluator, recursiveStack)\n\tcase *ast.CallExpr:\n\t\t//data conversion\n\t\tif len(valueExpr.Args) != 1 {\n\t\t\treturn nil, nil\n\t\t}\n\t\targ := valueExpr.Args[0]\n\t\tif ident, ok := valueExpr.Fun.(*ast.Ident); ok {\n\t\t\tname := ident.Name\n\t\t\tif name == \"uintptr\" {\n\t\t\t\tname = \"uint\"\n\t\t\t}\n\t\t\tvalue, _ := pkg.evaluateConstValue(file, iota, arg, globalEvaluator, recursiveStack)\n\t\t\tif IsGolangPrimitiveType(name) {\n\t\t\t\tvalue = EvaluateDataConversion(value, name)\n\t\t\t\treturn value, nil\n\t\t\t} else if name == \"len\" {\n\t\t\t\treturn reflect.ValueOf(value).Len(), nil\n\t\t\t}\n\t\t\ttypeDef := globalEvaluator.FindTypeSpec(name, file)\n\t\t\tif typeDef == nil {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn value, valueExpr.Fun\n\t\t} else if selector, ok := valueExpr.Fun.(*ast.SelectorExpr); ok {\n\t\t\ttypeDef := globalEvaluator.FindTypeSpec(fullTypeName(selector.X.(*ast.Ident).Name, selector.Sel.Name), file)\n\t\t\tif typeDef == nil {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn arg, typeDef.TypeSpec.Type\n\t\t}\n\t}\n\treturn nil, nil\n}\n"
        },
        {
          "name": "packages.go",
          "type": "blob",
          "size": 18.53125,
          "content": "package swag\n\nimport (\n\t\"fmt\"\n\t\"go/ast\"\n\tgoparser \"go/parser\"\n\t\"go/token\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"golang.org/x/tools/go/loader\"\n)\n\n// PackagesDefinitions map[package import path]*PackageDefinitions.\ntype PackagesDefinitions struct {\n\tfiles             map[*ast.File]*AstFileInfo\n\tpackages          map[string]*PackageDefinitions\n\tuniqueDefinitions map[string]*TypeSpecDef\n\tparseDependency   ParseFlag\n\tdebug             Debugger\n}\n\n// NewPackagesDefinitions create object PackagesDefinitions.\nfunc NewPackagesDefinitions() *PackagesDefinitions {\n\treturn &PackagesDefinitions{\n\t\tfiles:             make(map[*ast.File]*AstFileInfo),\n\t\tpackages:          make(map[string]*PackageDefinitions),\n\t\tuniqueDefinitions: make(map[string]*TypeSpecDef),\n\t}\n}\n\n// ParseFile parse a source file.\nfunc (pkgDefs *PackagesDefinitions) ParseFile(packageDir, path string, src interface{}, flag ParseFlag) error {\n\t// positions are relative to FileSet\n\tfileSet := token.NewFileSet()\n\tastFile, err := goparser.ParseFile(fileSet, path, src, goparser.ParseComments)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to parse file %s, error:%+v\", path, err)\n\t}\n\treturn pkgDefs.collectAstFile(fileSet, packageDir, path, astFile, flag)\n}\n\n// collectAstFile collect ast.file.\nfunc (pkgDefs *PackagesDefinitions) collectAstFile(fileSet *token.FileSet, packageDir, path string, astFile *ast.File, flag ParseFlag) error {\n\tif pkgDefs.files == nil {\n\t\tpkgDefs.files = make(map[*ast.File]*AstFileInfo)\n\t}\n\n\tif pkgDefs.packages == nil {\n\t\tpkgDefs.packages = make(map[string]*PackageDefinitions)\n\t}\n\n\t// return without storing the file if we lack a packageDir\n\tif packageDir == \"\" {\n\t\treturn nil\n\t}\n\n\tpath, err := filepath.Abs(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdependency, ok := pkgDefs.packages[packageDir]\n\tif ok {\n\t\t// return without storing the file if it already exists\n\t\t_, exists := dependency.Files[path]\n\t\tif exists {\n\t\t\treturn nil\n\t\t}\n\n\t\tdependency.Files[path] = astFile\n\t} else {\n\t\tpkgDefs.packages[packageDir] = NewPackageDefinitions(astFile.Name.Name, packageDir).AddFile(path, astFile)\n\t}\n\n\tpkgDefs.files[astFile] = &AstFileInfo{\n\t\tFileSet:     fileSet,\n\t\tFile:        astFile,\n\t\tPath:        path,\n\t\tPackagePath: packageDir,\n\t\tParseFlag:   flag,\n\t}\n\n\treturn nil\n}\n\n// RangeFiles for range the collection of ast.File in alphabetic order.\nfunc (pkgDefs *PackagesDefinitions) RangeFiles(handle func(info *AstFileInfo) error) error {\n\tsortedFiles := make([]*AstFileInfo, 0, len(pkgDefs.files))\n\tfor _, info := range pkgDefs.files {\n\t\t// ignore package path prefix with 'vendor' or $GOROOT,\n\t\t// because the router info of api will not be included these files.\n\t\tif strings.HasPrefix(info.PackagePath, \"vendor\") || (runtime.GOROOT() != \"\" && strings.HasPrefix(info.Path, runtime.GOROOT()+string(filepath.Separator))) {\n\t\t\tcontinue\n\t\t}\n\t\tsortedFiles = append(sortedFiles, info)\n\t}\n\n\tsort.Slice(sortedFiles, func(i, j int) bool {\n\t\treturn strings.Compare(sortedFiles[i].Path, sortedFiles[j].Path) < 0\n\t})\n\n\tfor _, info := range sortedFiles {\n\t\terr := handle(info)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ParseTypes parse types\n// @Return parsed definitions.\nfunc (pkgDefs *PackagesDefinitions) ParseTypes() (map[*TypeSpecDef]*Schema, error) {\n\tparsedSchemas := make(map[*TypeSpecDef]*Schema)\n\tfor astFile, info := range pkgDefs.files {\n\t\tpkgDefs.parseTypesFromFile(astFile, info.PackagePath, parsedSchemas)\n\t\tpkgDefs.parseFunctionScopedTypesFromFile(astFile, info.PackagePath, parsedSchemas)\n\t}\n\tpkgDefs.removeAllNotUniqueTypes()\n\tpkgDefs.evaluateAllConstVariables()\n\tpkgDefs.collectConstEnums(parsedSchemas)\n\treturn parsedSchemas, nil\n}\n\nfunc (pkgDefs *PackagesDefinitions) parseTypesFromFile(astFile *ast.File, packagePath string, parsedSchemas map[*TypeSpecDef]*Schema) {\n\tfor _, astDeclaration := range astFile.Decls {\n\t\tgeneralDeclaration, ok := astDeclaration.(*ast.GenDecl)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tif generalDeclaration.Tok == token.TYPE {\n\t\t\tfor _, astSpec := range generalDeclaration.Specs {\n\t\t\t\tif typeSpec, ok := astSpec.(*ast.TypeSpec); ok {\n\t\t\t\t\ttypeSpecDef := &TypeSpecDef{\n\t\t\t\t\t\tPkgPath:  packagePath,\n\t\t\t\t\t\tFile:     astFile,\n\t\t\t\t\t\tTypeSpec: typeSpec,\n\t\t\t\t\t}\n\n\t\t\t\t\tif idt, ok := typeSpec.Type.(*ast.Ident); ok && IsGolangPrimitiveType(idt.Name) && parsedSchemas != nil {\n\t\t\t\t\t\tparsedSchemas[typeSpecDef] = &Schema{\n\t\t\t\t\t\t\tPkgPath: typeSpecDef.PkgPath,\n\t\t\t\t\t\t\tName:    astFile.Name.Name,\n\t\t\t\t\t\t\tSchema:  TransToValidPrimitiveSchema(idt.Name),\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif pkgDefs.uniqueDefinitions == nil {\n\t\t\t\t\t\tpkgDefs.uniqueDefinitions = make(map[string]*TypeSpecDef)\n\t\t\t\t\t}\n\n\t\t\t\t\tfullName := typeSpecDef.TypeName()\n\n\t\t\t\t\tanotherTypeDef, ok := pkgDefs.uniqueDefinitions[fullName]\n\t\t\t\t\tif ok {\n\t\t\t\t\t\tif anotherTypeDef == nil {\n\t\t\t\t\t\t\ttypeSpecDef.NotUnique = true\n\t\t\t\t\t\t\tfullName = typeSpecDef.TypeName()\n\t\t\t\t\t\t\tpkgDefs.uniqueDefinitions[fullName] = typeSpecDef\n\t\t\t\t\t\t} else if typeSpecDef.PkgPath != anotherTypeDef.PkgPath {\n\t\t\t\t\t\t\tpkgDefs.uniqueDefinitions[fullName] = nil\n\t\t\t\t\t\t\tanotherTypeDef.NotUnique = true\n\t\t\t\t\t\t\tpkgDefs.uniqueDefinitions[anotherTypeDef.TypeName()] = anotherTypeDef\n\t\t\t\t\t\t\tanotherTypeDef.SetSchemaName()\n\n\t\t\t\t\t\t\ttypeSpecDef.NotUnique = true\n\t\t\t\t\t\t\tfullName = typeSpecDef.TypeName()\n\t\t\t\t\t\t\tpkgDefs.uniqueDefinitions[fullName] = typeSpecDef\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpkgDefs.uniqueDefinitions[fullName] = typeSpecDef\n\t\t\t\t\t}\n\n\t\t\t\t\ttypeSpecDef.SetSchemaName()\n\n\t\t\t\t\tif pkgDefs.packages[typeSpecDef.PkgPath] == nil {\n\t\t\t\t\t\tpkgDefs.packages[typeSpecDef.PkgPath] = NewPackageDefinitions(astFile.Name.Name, typeSpecDef.PkgPath).AddTypeSpec(typeSpecDef.Name(), typeSpecDef)\n\t\t\t\t\t} else if _, ok = pkgDefs.packages[typeSpecDef.PkgPath].TypeDefinitions[typeSpecDef.Name()]; !ok {\n\t\t\t\t\t\tpkgDefs.packages[typeSpecDef.PkgPath].AddTypeSpec(typeSpecDef.Name(), typeSpecDef)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if generalDeclaration.Tok == token.CONST {\n\t\t\t// collect consts\n\t\t\tpkgDefs.collectConstVariables(astFile, packagePath, generalDeclaration)\n\t\t}\n\t}\n}\n\nfunc (pkgDefs *PackagesDefinitions) parseFunctionScopedTypesFromFile(astFile *ast.File, packagePath string, parsedSchemas map[*TypeSpecDef]*Schema) {\n\tfor _, astDeclaration := range astFile.Decls {\n\t\tfuncDeclaration, ok := astDeclaration.(*ast.FuncDecl)\n\t\tif ok && funcDeclaration.Body != nil {\n\t\t\tfunctionScopedTypes := make(map[string]*TypeSpecDef)\n\t\t\tfor _, stmt := range funcDeclaration.Body.List {\n\t\t\t\tif declStmt, ok := (stmt).(*ast.DeclStmt); ok {\n\t\t\t\t\tif genDecl, ok := (declStmt.Decl).(*ast.GenDecl); ok && genDecl.Tok == token.TYPE {\n\t\t\t\t\t\tfor _, astSpec := range genDecl.Specs {\n\t\t\t\t\t\t\tif typeSpec, ok := astSpec.(*ast.TypeSpec); ok {\n\t\t\t\t\t\t\t\ttypeSpecDef := &TypeSpecDef{\n\t\t\t\t\t\t\t\t\tPkgPath:    packagePath,\n\t\t\t\t\t\t\t\t\tFile:       astFile,\n\t\t\t\t\t\t\t\t\tTypeSpec:   typeSpec,\n\t\t\t\t\t\t\t\t\tParentSpec: astDeclaration,\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif idt, ok := typeSpec.Type.(*ast.Ident); ok && IsGolangPrimitiveType(idt.Name) && parsedSchemas != nil {\n\t\t\t\t\t\t\t\t\tparsedSchemas[typeSpecDef] = &Schema{\n\t\t\t\t\t\t\t\t\t\tPkgPath: typeSpecDef.PkgPath,\n\t\t\t\t\t\t\t\t\t\tName:    astFile.Name.Name,\n\t\t\t\t\t\t\t\t\t\tSchema:  TransToValidPrimitiveSchema(idt.Name),\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfullName := typeSpecDef.TypeName()\n\t\t\t\t\t\t\t\tif structType, ok := typeSpecDef.TypeSpec.Type.(*ast.StructType); ok {\n\t\t\t\t\t\t\t\t\tfor _, field := range structType.Fields.List {\n\t\t\t\t\t\t\t\t\t\tvar idt *ast.Ident\n\t\t\t\t\t\t\t\t\t\tvar ok bool\n\t\t\t\t\t\t\t\t\t\tswitch field.Type.(type) {\n\t\t\t\t\t\t\t\t\t\tcase *ast.Ident:\n\t\t\t\t\t\t\t\t\t\t\tidt, ok = field.Type.(*ast.Ident)\n\t\t\t\t\t\t\t\t\t\tcase *ast.StarExpr:\n\t\t\t\t\t\t\t\t\t\t\tidt, ok = field.Type.(*ast.StarExpr).X.(*ast.Ident)\n\t\t\t\t\t\t\t\t\t\tcase *ast.ArrayType:\n\t\t\t\t\t\t\t\t\t\t\tidt, ok = field.Type.(*ast.ArrayType).Elt.(*ast.Ident)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif ok && !IsGolangPrimitiveType(idt.Name) {\n\t\t\t\t\t\t\t\t\t\t\tif functype, ok := functionScopedTypes[idt.Name]; ok {\n\t\t\t\t\t\t\t\t\t\t\t\tidt.Name = functype.TypeName()\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif pkgDefs.uniqueDefinitions == nil {\n\t\t\t\t\t\t\t\t\tpkgDefs.uniqueDefinitions = make(map[string]*TypeSpecDef)\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tanotherTypeDef, ok := pkgDefs.uniqueDefinitions[fullName]\n\t\t\t\t\t\t\t\tif ok {\n\t\t\t\t\t\t\t\t\tif anotherTypeDef == nil {\n\t\t\t\t\t\t\t\t\t\ttypeSpecDef.NotUnique = true\n\t\t\t\t\t\t\t\t\t\tfullName = typeSpecDef.TypeName()\n\t\t\t\t\t\t\t\t\t\tpkgDefs.uniqueDefinitions[fullName] = typeSpecDef\n\t\t\t\t\t\t\t\t\t} else if typeSpecDef.PkgPath != anotherTypeDef.PkgPath {\n\t\t\t\t\t\t\t\t\t\tpkgDefs.uniqueDefinitions[fullName] = nil\n\t\t\t\t\t\t\t\t\t\tanotherTypeDef.NotUnique = true\n\t\t\t\t\t\t\t\t\t\tpkgDefs.uniqueDefinitions[anotherTypeDef.TypeName()] = anotherTypeDef\n\t\t\t\t\t\t\t\t\t\tanotherTypeDef.SetSchemaName()\n\n\t\t\t\t\t\t\t\t\t\ttypeSpecDef.NotUnique = true\n\t\t\t\t\t\t\t\t\t\tfullName = typeSpecDef.TypeName()\n\t\t\t\t\t\t\t\t\t\tpkgDefs.uniqueDefinitions[fullName] = typeSpecDef\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tpkgDefs.uniqueDefinitions[fullName] = typeSpecDef\n\t\t\t\t\t\t\t\t\tfunctionScopedTypes[typeSpec.Name.Name] = typeSpecDef\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttypeSpecDef.SetSchemaName()\n\n\t\t\t\t\t\t\t\tif pkgDefs.packages[typeSpecDef.PkgPath] == nil {\n\t\t\t\t\t\t\t\t\tpkgDefs.packages[typeSpecDef.PkgPath] = NewPackageDefinitions(astFile.Name.Name, typeSpecDef.PkgPath).AddTypeSpec(fullName, typeSpecDef)\n\t\t\t\t\t\t\t\t} else if _, ok = pkgDefs.packages[typeSpecDef.PkgPath].TypeDefinitions[fullName]; !ok {\n\t\t\t\t\t\t\t\t\tpkgDefs.packages[typeSpecDef.PkgPath].AddTypeSpec(fullName, typeSpecDef)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (pkgDefs *PackagesDefinitions) collectConstVariables(astFile *ast.File, packagePath string, generalDeclaration *ast.GenDecl) {\n\tpkg, ok := pkgDefs.packages[packagePath]\n\tif !ok {\n\t\tpkg = NewPackageDefinitions(astFile.Name.Name, packagePath)\n\t\tpkgDefs.packages[packagePath] = pkg\n\t}\n\n\tvar lastValueSpec *ast.ValueSpec\n\tfor _, astSpec := range generalDeclaration.Specs {\n\t\tvalueSpec, ok := astSpec.(*ast.ValueSpec)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tif len(valueSpec.Names) == 1 && len(valueSpec.Values) == 1 {\n\t\t\tlastValueSpec = valueSpec\n\t\t} else if len(valueSpec.Names) == 1 && len(valueSpec.Values) == 0 && valueSpec.Type == nil && lastValueSpec != nil {\n\t\t\tvalueSpec.Type = lastValueSpec.Type\n\t\t\tvalueSpec.Values = lastValueSpec.Values\n\t\t}\n\t\tpkg.AddConst(astFile, valueSpec)\n\t}\n}\n\nfunc (pkgDefs *PackagesDefinitions) evaluateAllConstVariables() {\n\tfor _, pkg := range pkgDefs.packages {\n\t\tfor _, constVar := range pkg.OrderedConst {\n\t\t\tpkgDefs.EvaluateConstValue(pkg, constVar, nil)\n\t\t}\n\t}\n}\n\n// EvaluateConstValue evaluate a const variable.\nfunc (pkgDefs *PackagesDefinitions) EvaluateConstValue(pkg *PackageDefinitions, cv *ConstVariable, recursiveStack map[string]struct{}) (interface{}, ast.Expr) {\n\tif expr, ok := cv.Value.(ast.Expr); ok {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tif fi, ok := pkgDefs.files[cv.File]; ok {\n\t\t\t\t\tpos := fi.FileSet.Position(cv.Name.NamePos)\n\t\t\t\t\tpkgDefs.debug.Printf(\"warning: failed to evaluate const %s at %s:%d:%d, %v\", cv.Name.Name, fi.Path, pos.Line, pos.Column, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tif recursiveStack == nil {\n\t\t\trecursiveStack = make(map[string]struct{})\n\t\t}\n\t\tfullConstName := fullTypeName(pkg.Path, cv.Name.Name)\n\t\tif _, ok = recursiveStack[fullConstName]; ok {\n\t\t\treturn nil, nil\n\t\t}\n\t\trecursiveStack[fullConstName] = struct{}{}\n\n\t\tvalue, evalType := pkg.evaluateConstValue(cv.File, cv.Name.Obj.Data.(int), expr, pkgDefs, recursiveStack)\n\t\tif cv.Type == nil && evalType != nil {\n\t\t\tcv.Type = evalType\n\t\t}\n\t\tif value != nil {\n\t\t\tcv.Value = value\n\t\t}\n\t\treturn value, cv.Type\n\t}\n\treturn cv.Value, cv.Type\n}\n\n// EvaluateConstValueByName evaluate a const variable by name.\nfunc (pkgDefs *PackagesDefinitions) EvaluateConstValueByName(file *ast.File, pkgName, constVariableName string, recursiveStack map[string]struct{}) (interface{}, ast.Expr) {\n\tmatchedPkgPaths, externalPkgPaths := pkgDefs.findPackagePathFromImports(pkgName, file)\n\tfor _, pkgPath := range matchedPkgPaths {\n\t\tif pkg, ok := pkgDefs.packages[pkgPath]; ok {\n\t\t\tif cv, ok := pkg.ConstTable[constVariableName]; ok {\n\t\t\t\treturn pkgDefs.EvaluateConstValue(pkg, cv, recursiveStack)\n\t\t\t}\n\t\t}\n\t}\n\tif pkgDefs.parseDependency > 0 {\n\t\tfor _, pkgPath := range externalPkgPaths {\n\t\t\tif err := pkgDefs.loadExternalPackage(pkgPath); err == nil {\n\t\t\t\tif pkg, ok := pkgDefs.packages[pkgPath]; ok {\n\t\t\t\t\tif cv, ok := pkg.ConstTable[constVariableName]; ok {\n\t\t\t\t\t\treturn pkgDefs.EvaluateConstValue(pkg, cv, recursiveStack)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil, nil\n}\n\nfunc (pkgDefs *PackagesDefinitions) collectConstEnums(parsedSchemas map[*TypeSpecDef]*Schema) {\n\tfor _, pkg := range pkgDefs.packages {\n\t\tfor _, constVar := range pkg.OrderedConst {\n\t\t\tif constVar.Type == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tident, ok := constVar.Type.(*ast.Ident)\n\t\t\tif !ok || IsGolangPrimitiveType(ident.Name) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttypeDef, ok := pkg.TypeDefinitions[ident.Name]\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// delete it from parsed schemas, and will parse it again\n\t\t\tif _, ok = parsedSchemas[typeDef]; ok {\n\t\t\t\tdelete(parsedSchemas, typeDef)\n\t\t\t}\n\n\t\t\tif typeDef.Enums == nil {\n\t\t\t\ttypeDef.Enums = make([]EnumValue, 0)\n\t\t\t}\n\n\t\t\tname := constVar.Name.Name\n\t\t\tif _, ok = constVar.Value.(ast.Expr); ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tenumValue := EnumValue{\n\t\t\t\tkey:   name,\n\t\t\t\tValue: constVar.Value,\n\t\t\t}\n\t\t\tif constVar.Comment != nil && len(constVar.Comment.List) > 0 {\n\t\t\t\tenumValue.Comment = constVar.Comment.List[0].Text\n\t\t\t\tenumValue.Comment = strings.TrimPrefix(enumValue.Comment, \"//\")\n\t\t\t\tenumValue.Comment = strings.TrimPrefix(enumValue.Comment, \"/*\")\n\t\t\t\tenumValue.Comment = strings.TrimSuffix(enumValue.Comment, \"*/\")\n\t\t\t\tenumValue.Comment = strings.TrimSpace(enumValue.Comment)\n\t\t\t}\n\t\t\ttypeDef.Enums = append(typeDef.Enums, enumValue)\n\t\t}\n\t}\n}\n\nfunc (pkgDefs *PackagesDefinitions) removeAllNotUniqueTypes() {\n\tfor key, ud := range pkgDefs.uniqueDefinitions {\n\t\tif ud == nil {\n\t\t\tdelete(pkgDefs.uniqueDefinitions, key)\n\t\t}\n\t}\n}\n\nfunc (pkgDefs *PackagesDefinitions) findTypeSpec(pkgPath string, typeName string) *TypeSpecDef {\n\tif pkgDefs.packages == nil {\n\t\treturn nil\n\t}\n\n\tpd, found := pkgDefs.packages[pkgPath]\n\tif found {\n\t\ttypeSpec, ok := pd.TypeDefinitions[typeName]\n\t\tif ok {\n\t\t\treturn typeSpec\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (pkgDefs *PackagesDefinitions) loadExternalPackage(importPath string) error {\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tconf := loader.Config{\n\t\tParserMode: goparser.ParseComments,\n\t\tCwd:        cwd,\n\t}\n\n\tconf.Import(importPath)\n\n\tloaderProgram, err := conf.Load()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, info := range loaderProgram.AllPackages {\n\t\tpkgPath := strings.TrimPrefix(info.Pkg.Path(), \"vendor/\")\n\t\tfor _, astFile := range info.Files {\n\t\t\tpkgDefs.parseTypesFromFile(astFile, pkgPath, nil)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// findPackagePathFromImports finds out the package path of a package via ranging imports of an ast.File\n// @pkg the name of the target package\n// @file current ast.File in which to search imports\n// @return the package paths of a package of @pkg.\nfunc (pkgDefs *PackagesDefinitions) findPackagePathFromImports(pkg string, file *ast.File) (matchedPkgPaths, externalPkgPaths []string) {\n\tif file == nil {\n\t\treturn\n\t}\n\n\tif strings.ContainsRune(pkg, '.') {\n\t\tpkg = strings.Split(pkg, \".\")[0]\n\t}\n\n\tmatchLastPathPart := func(pkgPath string) bool {\n\t\tpaths := strings.Split(pkgPath, \"/\")\n\t\treturn paths[len(paths)-1] == pkg\n\t}\n\n\t// prior to match named package\n\tfor _, imp := range file.Imports {\n\t\tpath := strings.Trim(imp.Path.Value, `\"`)\n\t\tif imp.Name != nil {\n\t\t\tif imp.Name.Name == pkg {\n\t\t\t\t// if name match, break loop and return\n\t\t\t\t_, ok := pkgDefs.packages[path]\n\t\t\t\tif ok {\n\t\t\t\t\tmatchedPkgPaths = []string{path}\n\t\t\t\t\texternalPkgPaths = nil\n\t\t\t\t} else {\n\t\t\t\t\texternalPkgPaths = []string{path}\n\t\t\t\t\tmatchedPkgPaths = nil\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t} else if imp.Name.Name == \"_\" && len(pkg) > 0 {\n\t\t\t\t// for unused types\n\t\t\t\tpd, ok := pkgDefs.packages[path]\n\t\t\t\tif ok {\n\t\t\t\t\tif pd.Name == pkg {\n\t\t\t\t\t\tmatchedPkgPaths = append(matchedPkgPaths, path)\n\t\t\t\t\t}\n\t\t\t\t} else if matchLastPathPart(path) {\n\t\t\t\t\texternalPkgPaths = append(externalPkgPaths, path)\n\t\t\t\t}\n\t\t\t} else if imp.Name.Name == \".\" && len(pkg) == 0 {\n\t\t\t\t_, ok := pkgDefs.packages[path]\n\t\t\t\tif ok {\n\t\t\t\t\tmatchedPkgPaths = append(matchedPkgPaths, path)\n\t\t\t\t} else if len(pkg) == 0 || matchLastPathPart(path) {\n\t\t\t\t\texternalPkgPaths = append(externalPkgPaths, path)\n\t\t\t\t}\n\t\t\t}\n\t\t} else if pkgDefs.packages != nil && len(pkg) > 0 {\n\t\t\tpd, ok := pkgDefs.packages[path]\n\t\t\tif ok {\n\t\t\t\tif pd.Name == pkg {\n\t\t\t\t\tmatchedPkgPaths = append(matchedPkgPaths, path)\n\t\t\t\t}\n\t\t\t} else if matchLastPathPart(path) {\n\t\t\t\texternalPkgPaths = append(externalPkgPaths, path)\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(pkg) == 0 || file.Name.Name == pkg {\n\t\tmatchedPkgPaths = append(matchedPkgPaths, pkgDefs.files[file].PackagePath)\n\t}\n\n\treturn\n}\n\nfunc (pkgDefs *PackagesDefinitions) findTypeSpecFromPackagePaths(matchedPkgPaths, externalPkgPaths []string, name string) (typeDef *TypeSpecDef) {\n\tif pkgDefs.parseDependency > 0 {\n\t\tfor _, pkgPath := range externalPkgPaths {\n\t\t\tif err := pkgDefs.loadExternalPackage(pkgPath); err == nil {\n\t\t\t\ttypeDef = pkgDefs.findTypeSpec(pkgPath, name)\n\t\t\t\tif typeDef != nil {\n\t\t\t\t\treturn typeDef\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, pkgPath := range matchedPkgPaths {\n\t\ttypeDef = pkgDefs.findTypeSpec(pkgPath, name)\n\t\tif typeDef != nil {\n\t\t\treturn typeDef\n\t\t}\n\t}\n\n\treturn typeDef\n}\n\n// FindTypeSpec finds out TypeSpecDef of a type by typeName\n// @typeName the name of the target type, if it starts with a package name, find its own package path from imports on top of @file\n// @file the ast.file in which @typeName is used\n// @pkgPath the package path of @file.\nfunc (pkgDefs *PackagesDefinitions) FindTypeSpec(typeName string, file *ast.File) *TypeSpecDef {\n\tif IsGolangPrimitiveType(typeName) {\n\t\treturn nil\n\t}\n\n\tif file == nil { // for test\n\t\treturn pkgDefs.uniqueDefinitions[typeName]\n\t}\n\n\tparts := strings.Split(strings.Split(typeName, \"[\")[0], \".\")\n\tif len(parts) > 1 {\n\t\tpkgPaths, externalPkgPaths := pkgDefs.findPackagePathFromImports(parts[0], file)\n\t\tif len(externalPkgPaths) == 0 || pkgDefs.parseDependency == ParseNone {\n\t\t\ttypeDef, ok := pkgDefs.uniqueDefinitions[typeName]\n\t\t\tif ok {\n\t\t\t\treturn typeDef\n\t\t\t}\n\t\t}\n\t\ttypeDef := pkgDefs.findTypeSpecFromPackagePaths(pkgPaths, externalPkgPaths, parts[1])\n\t\treturn pkgDefs.parametrizeGenericType(file, typeDef, typeName)\n\t}\n\n\ttypeDef, ok := pkgDefs.uniqueDefinitions[fullTypeName(file.Name.Name, typeName)]\n\tif ok {\n\t\treturn typeDef\n\t}\n\n\tname := parts[0]\n\ttypeDef, ok = pkgDefs.uniqueDefinitions[fullTypeName(file.Name.Name, name)]\n\tif !ok {\n\t\tpkgPaths, externalPkgPaths := pkgDefs.findPackagePathFromImports(\"\", file)\n\t\ttypeDef = pkgDefs.findTypeSpecFromPackagePaths(pkgPaths, externalPkgPaths, name)\n\t}\n\n\tif typeDef != nil {\n\t\treturn pkgDefs.parametrizeGenericType(file, typeDef, typeName)\n\t}\n\n\t// in case that comment //@name renamed the type with a name without a dot\n\tfor k, v := range pkgDefs.uniqueDefinitions {\n\t\tif v == nil {\n\t\t\tpkgDefs.debug.Printf(\"%s TypeSpecDef is nil\", k)\n\t\t\tcontinue\n\t\t}\n\t\tif v.SchemaName == typeName {\n\t\t\treturn v\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "packages_test.go",
          "type": "blob",
          "size": 6.646484375,
          "content": "package swag\n\nimport (\n\t\"go/ast\"\n\t\"go/token\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestPackagesDefinitions_ParseFile(t *testing.T) {\n\tpd := PackagesDefinitions{}\n\tpackageDir := \"github.com/swaggo/swag/testdata/simple\"\n\tassert.NoError(t, pd.ParseFile(packageDir, \"testdata/simple/main.go\", nil, ParseAll))\n\tassert.Equal(t, 1, len(pd.packages))\n\tassert.Equal(t, 1, len(pd.files))\n}\n\nfunc TestPackagesDefinitions_collectAstFile(t *testing.T) {\n\tpd := PackagesDefinitions{}\n\tfileSet := token.NewFileSet()\n\tassert.NoError(t, pd.collectAstFile(fileSet, \"\", \"\", nil, ParseAll))\n\n\tfirstFile := &ast.File{\n\t\tName: &ast.Ident{Name: \"main.go\"},\n\t}\n\n\tpackageDir := \"github.com/swaggo/swag/testdata/simple\"\n\tassert.NoError(t, pd.collectAstFile(fileSet, packageDir, \"testdata/simple/\"+firstFile.Name.String(), firstFile, ParseAll))\n\tassert.NotEmpty(t, pd.packages[packageDir])\n\n\tabsPath, _ := filepath.Abs(\"testdata/simple/\" + firstFile.Name.String())\n\tastFileInfo := &AstFileInfo{\n\t\tFileSet:     fileSet,\n\t\tFile:        firstFile,\n\t\tPath:        absPath,\n\t\tPackagePath: packageDir,\n\t\tParseFlag:   ParseAll,\n\t}\n\tassert.Equal(t, pd.files[firstFile], astFileInfo)\n\n\t// Override\n\tassert.NoError(t, pd.collectAstFile(fileSet, packageDir, \"testdata/simple/\"+firstFile.Name.String(), firstFile, ParseAll))\n\tassert.Equal(t, pd.files[firstFile], astFileInfo)\n\n\t// Another file\n\tsecondFile := &ast.File{\n\t\tName: &ast.Ident{Name: \"api.go\"},\n\t}\n\tassert.NoError(t, pd.collectAstFile(fileSet, packageDir, \"testdata/simple/\"+secondFile.Name.String(), secondFile, ParseAll))\n}\n\nfunc TestPackagesDefinitions_rangeFiles(t *testing.T) {\n\tpd := PackagesDefinitions{\n\t\tfiles: map[*ast.File]*AstFileInfo{\n\t\t\t{\n\t\t\t\tName: &ast.Ident{Name: \"main.go\"},\n\t\t\t}: {\n\t\t\t\tFile:        &ast.File{Name: &ast.Ident{Name: \"main.go\"}},\n\t\t\t\tPath:        \"testdata/simple/main.go\",\n\t\t\t\tPackagePath: \"main\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: &ast.Ident{Name: \"api.go\"},\n\t\t\t}: {\n\t\t\t\tFile:        &ast.File{Name: &ast.Ident{Name: \"api.go\"}},\n\t\t\t\tPath:        \"testdata/simple/api/api.go\",\n\t\t\t\tPackagePath: \"api\",\n\t\t\t},\n\t\t},\n\t}\n\n\ti, expect := 0, []string{\"testdata/simple/api/api.go\", \"testdata/simple/main.go\"}\n\t_ = pd.RangeFiles(func(fileInfo *AstFileInfo) error {\n\t\tassert.Equal(t, expect[i], fileInfo.Path)\n\t\ti++\n\t\treturn nil\n\t})\n}\n\nfunc TestPackagesDefinitions_ParseTypes(t *testing.T) {\n\tabsPath, _ := filepath.Abs(\"\")\n\n\tmainAST := ast.File{\n\t\tName: &ast.Ident{Name: \"main.go\"},\n\t\tDecls: []ast.Decl{\n\t\t\t&ast.GenDecl{\n\t\t\t\tTok: token.TYPE,\n\t\t\t\tSpecs: []ast.Spec{\n\t\t\t\t\t&ast.TypeSpec{\n\t\t\t\t\t\tName: &ast.Ident{Name: \"Test\"},\n\t\t\t\t\t\tType: &ast.Ident{\n\t\t\t\t\t\t\tName: \"string\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tpd := PackagesDefinitions{\n\t\tfiles: map[*ast.File]*AstFileInfo{\n\t\t\t&mainAST: {\n\t\t\t\tFile:        &mainAST,\n\t\t\t\tPath:        filepath.Join(absPath, \"testdata/simple/main.go\"),\n\t\t\t\tPackagePath: \"main\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: &ast.Ident{Name: \"api.go\"},\n\t\t\t}: {\n\t\t\t\tFile:        &ast.File{Name: &ast.Ident{Name: \"api.go\"}},\n\t\t\t\tPath:        filepath.Join(absPath, \"testdata/simple/api/api.go\"),\n\t\t\t\tPackagePath: \"api\",\n\t\t\t},\n\t\t},\n\t\tpackages: make(map[string]*PackageDefinitions),\n\t}\n\n\t_, err := pd.ParseTypes()\n\tassert.NoError(t, err)\n}\n\nfunc TestPackagesDefinitions_parseFunctionScopedTypesFromFile(t *testing.T) {\n\tmainAST := &ast.File{\n\t\tName: &ast.Ident{Name: \"main.go\"},\n\t\tDecls: []ast.Decl{\n\t\t\t&ast.FuncDecl{\n\t\t\t\tName: ast.NewIdent(\"TestFuncDecl\"),\n\t\t\t\tBody: &ast.BlockStmt{\n\t\t\t\t\tList: []ast.Stmt{\n\t\t\t\t\t\t&ast.DeclStmt{\n\t\t\t\t\t\t\tDecl: &ast.GenDecl{\n\t\t\t\t\t\t\t\tTok: token.TYPE,\n\t\t\t\t\t\t\t\tSpecs: []ast.Spec{\n\t\t\t\t\t\t\t\t\t&ast.TypeSpec{\n\t\t\t\t\t\t\t\t\t\tName: ast.NewIdent(\"response\"),\n\t\t\t\t\t\t\t\t\t\tType: ast.NewIdent(\"struct\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t&ast.TypeSpec{\n\t\t\t\t\t\t\t\t\t\tName: ast.NewIdent(\"stringResponse\"),\n\t\t\t\t\t\t\t\t\t\tType: ast.NewIdent(\"string\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tpd := PackagesDefinitions{\n\t\tpackages: make(map[string]*PackageDefinitions),\n\t}\n\n\tparsedSchema := make(map[*TypeSpecDef]*Schema)\n\tpd.parseFunctionScopedTypesFromFile(mainAST, \"main\", parsedSchema)\n\n\tassert.Len(t, parsedSchema, 1)\n\n\t_, ok := pd.uniqueDefinitions[\"main.go.TestFuncDecl.response\"]\n\tassert.True(t, ok)\n\n\t_, ok = pd.packages[\"main\"].TypeDefinitions[\"main.go.TestFuncDecl.response\"]\n\tassert.True(t, ok)\n}\n\nfunc TestPackagesDefinitions_FindTypeSpec(t *testing.T) {\n\tuserDef := TypeSpecDef{\n\t\tFile: &ast.File{\n\t\t\tName: &ast.Ident{Name: \"user.go\"},\n\t\t},\n\t\tTypeSpec: &ast.TypeSpec{\n\t\t\tName: ast.NewIdent(\"User\"),\n\t\t},\n\t\tPkgPath: \"user\",\n\t}\n\tvar pkg = PackagesDefinitions{\n\t\tuniqueDefinitions: map[string]*TypeSpecDef{\n\t\t\t\"user.Model\": &userDef,\n\t\t},\n\t}\n\n\tvar nilDef *TypeSpecDef\n\tassert.Equal(t, nilDef, pkg.FindTypeSpec(\"int\", nil))\n\tassert.Equal(t, nilDef, pkg.FindTypeSpec(\"bool\", nil))\n\tassert.Equal(t, nilDef, pkg.FindTypeSpec(\"string\", nil))\n\n\tassert.Equal(t, &userDef, pkg.FindTypeSpec(\"user.Model\", nil))\n\tassert.Equal(t, nilDef, pkg.FindTypeSpec(\"Model\", nil))\n}\n\nfunc TestPackage_rangeFiles(t *testing.T) {\n\tpd := NewPackagesDefinitions()\n\tpd.files = map[*ast.File]*AstFileInfo{\n\t\t{\n\t\t\tName: &ast.Ident{Name: \"main.go\"},\n\t\t}: {\n\t\t\tFile:        &ast.File{Name: &ast.Ident{Name: \"main.go\"}},\n\t\t\tPath:        \"testdata/simple/main.go\",\n\t\t\tPackagePath: \"main\",\n\t\t},\n\t\t{\n\t\t\tName: &ast.Ident{Name: \"api.go\"},\n\t\t}: {\n\t\t\tFile:        &ast.File{Name: &ast.Ident{Name: \"api.go\"}},\n\t\t\tPath:        \"testdata/simple/api/api.go\",\n\t\t\tPackagePath: \"api\",\n\t\t},\n\t\t{\n\t\t\tName: &ast.Ident{Name: \"foo.go\"},\n\t\t}: {\n\t\t\tFile:        &ast.File{Name: &ast.Ident{Name: \"foo.go\"}},\n\t\t\tPath:        \"vendor/foo/foo.go\",\n\t\t\tPackagePath: \"vendor/foo\",\n\t\t},\n\t\t{\n\t\t\tName: &ast.Ident{Name: \"bar.go\"},\n\t\t}: {\n\t\t\tFile:        &ast.File{Name: &ast.Ident{Name: \"bar.go\"}},\n\t\t\tPath:        filepath.Join(runtime.GOROOT(), \"bar.go\"),\n\t\t\tPackagePath: \"bar\",\n\t\t},\n\t}\n\n\tvar sorted []string\n\tprocessor := func(fileInfo *AstFileInfo) error {\n\t\tsorted = append(sorted, fileInfo.Path)\n\t\treturn nil\n\t}\n\tassert.NoError(t, pd.RangeFiles(processor))\n\tassert.Equal(t, []string{\"testdata/simple/api/api.go\", \"testdata/simple/main.go\"}, sorted)\n\n\tassert.Error(t, pd.RangeFiles(func(fileInfo *AstFileInfo) error {\n\t\treturn ErrFuncTypeField\n\t}))\n\n}\n\nfunc TestPackagesDefinitions_findTypeSpec(t *testing.T) {\n\tpd := PackagesDefinitions{}\n\tvar nilTypeSpec *TypeSpecDef\n\tassert.Equal(t, nilTypeSpec, pd.findTypeSpec(\"model\", \"User\"))\n\n\tuserTypeSpec := TypeSpecDef{\n\t\tFile:     &ast.File{},\n\t\tTypeSpec: &ast.TypeSpec{},\n\t\tPkgPath:  \"model\",\n\t}\n\tpd = PackagesDefinitions{\n\t\tpackages: map[string]*PackageDefinitions{\n\t\t\t\"model\": {\n\t\t\t\tTypeDefinitions: map[string]*TypeSpecDef{\n\t\t\t\t\t\"User\": &userTypeSpec,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tassert.Equal(t, &userTypeSpec, pd.findTypeSpec(\"model\", \"User\"))\n\tassert.Equal(t, nilTypeSpec, pd.findTypeSpec(\"others\", \"User\"))\n\n}\n"
        },
        {
          "name": "parser.go",
          "type": "blob",
          "size": 51.1279296875,
          "content": "package swag\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/build\"\n\tgoparser \"go/parser\"\n\t\"go/token\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/KyleBanks/depth\"\n\t\"github.com/go-openapi/spec\"\n)\n\nconst (\n\t// CamelCase indicates using CamelCase strategy for struct field.\n\tCamelCase = \"camelcase\"\n\n\t// PascalCase indicates using PascalCase strategy for struct field.\n\tPascalCase = \"pascalcase\"\n\n\t// SnakeCase indicates using SnakeCase strategy for struct field.\n\tSnakeCase = \"snakecase\"\n\n\tidAttr                  = \"@id\"\n\tacceptAttr              = \"@accept\"\n\tproduceAttr             = \"@produce\"\n\tparamAttr               = \"@param\"\n\tsuccessAttr             = \"@success\"\n\tfailureAttr             = \"@failure\"\n\tresponseAttr            = \"@response\"\n\theaderAttr              = \"@header\"\n\ttagsAttr                = \"@tags\"\n\trouterAttr              = \"@router\"\n\tdeprecatedRouterAttr    = \"@deprecatedrouter\"\n\tsummaryAttr             = \"@summary\"\n\tdeprecatedAttr          = \"@deprecated\"\n\tsecurityAttr            = \"@security\"\n\ttitleAttr               = \"@title\"\n\tconNameAttr             = \"@contact.name\"\n\tconURLAttr              = \"@contact.url\"\n\tconEmailAttr            = \"@contact.email\"\n\tlicNameAttr             = \"@license.name\"\n\tlicURLAttr              = \"@license.url\"\n\tversionAttr             = \"@version\"\n\tdescriptionAttr         = \"@description\"\n\tdescriptionMarkdownAttr = \"@description.markdown\"\n\tsecBasicAttr            = \"@securitydefinitions.basic\"\n\tsecAPIKeyAttr           = \"@securitydefinitions.apikey\"\n\tsecApplicationAttr      = \"@securitydefinitions.oauth2.application\"\n\tsecImplicitAttr         = \"@securitydefinitions.oauth2.implicit\"\n\tsecPasswordAttr         = \"@securitydefinitions.oauth2.password\"\n\tsecAccessCodeAttr       = \"@securitydefinitions.oauth2.accesscode\"\n\ttosAttr                 = \"@termsofservice\"\n\textDocsDescAttr         = \"@externaldocs.description\"\n\textDocsURLAttr          = \"@externaldocs.url\"\n\txCodeSamplesAttr        = \"@x-codesamples\"\n\tscopeAttrPrefix         = \"@scope.\"\n\tstateAttr               = \"@state\"\n)\n\n// ParseFlag determine what to parse\ntype ParseFlag int\n\nconst (\n\t// ParseNone parse nothing\n\tParseNone ParseFlag = 0x00\n\t// ParseModels parse models\n\tParseModels = 0x01\n\t// ParseOperations parse operations\n\tParseOperations = 0x02\n\t// ParseAll parse operations and models\n\tParseAll = ParseOperations | ParseModels\n)\n\nvar (\n\t// ErrRecursiveParseStruct recursively parsing struct.\n\tErrRecursiveParseStruct = errors.New(\"recursively parsing struct\")\n\n\t// ErrFuncTypeField field type is func.\n\tErrFuncTypeField = errors.New(\"field type is func\")\n\n\t// ErrFailedConvertPrimitiveType Failed to convert for swag to interpretable type.\n\tErrFailedConvertPrimitiveType = errors.New(\"swag property: failed convert primitive type\")\n\n\t// ErrSkippedField .swaggo specifies field should be skipped.\n\tErrSkippedField = errors.New(\"field is skipped by global overrides\")\n)\n\nvar allMethod = map[string]struct{}{\n\thttp.MethodGet:     {},\n\thttp.MethodPut:     {},\n\thttp.MethodPost:    {},\n\thttp.MethodDelete:  {},\n\thttp.MethodOptions: {},\n\thttp.MethodHead:    {},\n\thttp.MethodPatch:   {},\n}\n\n// Parser implements a parser for Go source files.\ntype Parser struct {\n\t// swagger represents the root document object for the API specification\n\tswagger *spec.Swagger\n\n\t// packages store entities of APIs, definitions, file, package path etc.  and their relations\n\tpackages *PackagesDefinitions\n\n\t// parsedSchemas store schemas which have been parsed from ast.TypeSpec\n\tparsedSchemas map[*TypeSpecDef]*Schema\n\n\t// outputSchemas store schemas which will be export to swagger\n\toutputSchemas map[*TypeSpecDef]*Schema\n\n\t// PropNamingStrategy naming strategy\n\tPropNamingStrategy string\n\n\t// ParseVendor parse vendor folder\n\tParseVendor bool\n\n\t// ParseDependencies whether swag should be parse outside dependency folder: 0 none, 1 models, 2 operations, 3 all\n\tParseDependency ParseFlag\n\n\t// ParseInternal whether swag should parse internal packages\n\tParseInternal bool\n\n\t// Strict whether swag should error or warn when it detects cases which are most likely user errors\n\tStrict bool\n\n\t// RequiredByDefault set validation required for all fields by default\n\tRequiredByDefault bool\n\n\t// structStack stores full names of the structures that were already parsed or are being parsed now\n\tstructStack []*TypeSpecDef\n\n\t// markdownFileDir holds the path to the folder, where markdown files are stored\n\tmarkdownFileDir string\n\n\t// codeExampleFilesDir holds path to the folder, where code example files are stored\n\tcodeExampleFilesDir string\n\n\t// collectionFormatInQuery set the default collectionFormat otherwise then 'csv' for array in query params\n\tcollectionFormatInQuery string\n\n\t// excludes excludes dirs and files in SearchDir\n\texcludes map[string]struct{}\n\n\t// packagePrefix is a list of package path prefixes, packages that do not\n\t// match any one of them will be excluded when searching.\n\tpackagePrefix []string\n\n\t// tells parser to include only specific extension\n\tparseExtension string\n\n\t// debugging output goes here\n\tdebug Debugger\n\n\t// fieldParserFactory create FieldParser\n\tfieldParserFactory FieldParserFactory\n\n\t// Overrides allows global replacements of types. A blank replacement will be skipped.\n\tOverrides map[string]string\n\n\t// parseGoList whether swag use go list to parse dependency\n\tparseGoList bool\n\n\t// tags to filter the APIs after\n\ttags map[string]struct{}\n\n\t// HostState is the state of the host\n\tHostState string\n\n\t// ParseFuncBody whether swag should parse api info inside of funcs\n\tParseFuncBody bool\n}\n\n// FieldParserFactory create FieldParser.\ntype FieldParserFactory func(ps *Parser, field *ast.Field) FieldParser\n\n// FieldParser parse struct field.\ntype FieldParser interface {\n\tShouldSkip() bool\n\tFieldNames() ([]string, error)\n\tFormName() string\n\tHeaderName() string\n\tPathName() string\n\tCustomSchema() (*spec.Schema, error)\n\tComplementSchema(schema *spec.Schema) error\n\tIsRequired() (bool, error)\n}\n\n// Debugger is the interface that wraps the basic Printf method.\ntype Debugger interface {\n\tPrintf(format string, v ...interface{})\n}\n\n// New creates a new Parser with default properties.\nfunc New(options ...func(*Parser)) *Parser {\n\tparser := &Parser{\n\t\tswagger: &spec.Swagger{\n\t\t\tSwaggerProps: spec.SwaggerProps{\n\t\t\t\tInfo: &spec.Info{\n\t\t\t\t\tInfoProps: spec.InfoProps{\n\t\t\t\t\t\tContact: &spec.ContactInfo{},\n\t\t\t\t\t\tLicense: nil,\n\t\t\t\t\t},\n\t\t\t\t\tVendorExtensible: spec.VendorExtensible{\n\t\t\t\t\t\tExtensions: spec.Extensions{},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tPaths: &spec.Paths{\n\t\t\t\t\tPaths: make(map[string]spec.PathItem),\n\t\t\t\t\tVendorExtensible: spec.VendorExtensible{\n\t\t\t\t\t\tExtensions: nil,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tDefinitions:         make(map[string]spec.Schema),\n\t\t\t\tSecurityDefinitions: make(map[string]*spec.SecurityScheme),\n\t\t\t},\n\t\t\tVendorExtensible: spec.VendorExtensible{\n\t\t\t\tExtensions: nil,\n\t\t\t},\n\t\t},\n\t\tpackages:           NewPackagesDefinitions(),\n\t\tdebug:              log.New(os.Stdout, \"\", log.LstdFlags),\n\t\tparsedSchemas:      make(map[*TypeSpecDef]*Schema),\n\t\toutputSchemas:      make(map[*TypeSpecDef]*Schema),\n\t\texcludes:           make(map[string]struct{}),\n\t\ttags:               make(map[string]struct{}),\n\t\tfieldParserFactory: newTagBaseFieldParser,\n\t\tOverrides:          make(map[string]string),\n\t}\n\n\tfor _, option := range options {\n\t\toption(parser)\n\t}\n\n\tparser.packages.debug = parser.debug\n\n\treturn parser\n}\n\n// SetParseDependency sets whether to parse the dependent packages.\nfunc SetParseDependency(parseDependency int) func(*Parser) {\n\treturn func(p *Parser) {\n\t\tp.ParseDependency = ParseFlag(parseDependency)\n\t\tif p.packages != nil {\n\t\t\tp.packages.parseDependency = p.ParseDependency\n\t\t}\n\t}\n}\n\n// SetMarkdownFileDirectory sets the directory to search for markdown files.\nfunc SetMarkdownFileDirectory(directoryPath string) func(*Parser) {\n\treturn func(p *Parser) {\n\t\tp.markdownFileDir = directoryPath\n\t}\n}\n\n// SetCodeExamplesDirectory sets the directory to search for code example files.\nfunc SetCodeExamplesDirectory(directoryPath string) func(*Parser) {\n\treturn func(p *Parser) {\n\t\tp.codeExampleFilesDir = directoryPath\n\t}\n}\n\n// SetExcludedDirsAndFiles sets directories and files to be excluded when searching.\nfunc SetExcludedDirsAndFiles(excludes string) func(*Parser) {\n\treturn func(p *Parser) {\n\t\tfor _, f := range strings.Split(excludes, \",\") {\n\t\t\tf = strings.TrimSpace(f)\n\t\t\tif f != \"\" {\n\t\t\t\tf = filepath.Clean(f)\n\t\t\t\tp.excludes[f] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// SetPackagePrefix sets a list of package path prefixes from a comma-separated\n// string, packages that do not match any one of them will be excluded when\n// searching.\nfunc SetPackagePrefix(packagePrefix string) func(*Parser) {\n\treturn func(p *Parser) {\n\t\tfor _, f := range strings.Split(packagePrefix, \",\") {\n\t\t\tf = strings.TrimSpace(f)\n\t\t\tif f != \"\" {\n\t\t\t\tp.packagePrefix = append(p.packagePrefix, f)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// SetTags sets the tags to be included\nfunc SetTags(include string) func(*Parser) {\n\treturn func(p *Parser) {\n\t\tfor _, f := range strings.Split(include, \",\") {\n\t\t\tf = strings.TrimSpace(f)\n\t\t\tif f != \"\" {\n\t\t\t\tp.tags[f] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// SetParseExtension parses only those operations which match given extension\nfunc SetParseExtension(parseExtension string) func(*Parser) {\n\treturn func(p *Parser) {\n\t\tp.parseExtension = parseExtension\n\t}\n}\n\n// SetStrict sets whether swag should error or warn when it detects cases which are most likely user errors.\nfunc SetStrict(strict bool) func(*Parser) {\n\treturn func(p *Parser) {\n\t\tp.Strict = strict\n\t}\n}\n\n// SetDebugger allows the use of user-defined implementations.\nfunc SetDebugger(logger Debugger) func(parser *Parser) {\n\treturn func(p *Parser) {\n\t\tif logger != nil {\n\t\t\tp.debug = logger\n\t\t}\n\t}\n}\n\n// SetFieldParserFactory allows the use of user-defined implementations.\nfunc SetFieldParserFactory(factory FieldParserFactory) func(parser *Parser) {\n\treturn func(p *Parser) {\n\t\tp.fieldParserFactory = factory\n\t}\n}\n\n// SetOverrides allows the use of user-defined global type overrides.\nfunc SetOverrides(overrides map[string]string) func(parser *Parser) {\n\treturn func(p *Parser) {\n\t\tfor k, v := range overrides {\n\t\t\tp.Overrides[k] = v\n\t\t}\n\t}\n}\n\n// SetCollectionFormat set default collection format\nfunc SetCollectionFormat(collectionFormat string) func(*Parser) {\n\treturn func(p *Parser) {\n\t\tp.collectionFormatInQuery = collectionFormat\n\t}\n}\n\n// ParseUsingGoList sets whether swag use go list to parse dependency\nfunc ParseUsingGoList(enabled bool) func(parser *Parser) {\n\treturn func(p *Parser) {\n\t\tp.parseGoList = enabled\n\t}\n}\n\n// ParseAPI parses general api info for given searchDir and mainAPIFile.\nfunc (parser *Parser) ParseAPI(searchDir string, mainAPIFile string, parseDepth int) error {\n\treturn parser.ParseAPIMultiSearchDir([]string{searchDir}, mainAPIFile, parseDepth)\n}\n\n// skipPackageByPrefix returns true the given pkgpath does not match\n// any user-defined package path prefixes.\nfunc (parser *Parser) skipPackageByPrefix(pkgpath string) bool {\n\tif len(parser.packagePrefix) == 0 {\n\t\treturn false\n\t}\n\tfor _, prefix := range parser.packagePrefix {\n\t\tif strings.HasPrefix(pkgpath, prefix) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// ParseAPIMultiSearchDir is like ParseAPI but for multiple search dirs.\nfunc (parser *Parser) ParseAPIMultiSearchDir(searchDirs []string, mainAPIFile string, parseDepth int) error {\n\tfor _, searchDir := range searchDirs {\n\t\tparser.debug.Printf(\"Generate general API Info, search dir:%s\", searchDir)\n\n\t\tpackageDir, err := getPkgName(searchDir)\n\t\tif err != nil {\n\t\t\tparser.debug.Printf(\"warning: failed to get package name in dir: %s, error: %s\", searchDir, err.Error())\n\t\t}\n\n\t\terr = parser.getAllGoFileInfo(packageDir, searchDir)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tabsMainAPIFilePath, err := filepath.Abs(filepath.Join(searchDirs[0], mainAPIFile))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Use 'go list' command instead of depth.Resolve()\n\tif parser.ParseDependency > 0 {\n\t\tif parser.parseGoList {\n\t\t\tpkgs, err := listPackages(context.Background(), filepath.Dir(absMainAPIFilePath), nil, \"-deps\")\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"pkg %s cannot find all dependencies, %s\", filepath.Dir(absMainAPIFilePath), err)\n\t\t\t}\n\n\t\t\tlength := len(pkgs)\n\t\t\tfor i := 0; i < length; i++ {\n\t\t\t\terr := parser.getAllGoFileInfoFromDepsByList(pkgs[i], parser.ParseDependency)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar t depth.Tree\n\t\t\tt.ResolveInternal = true\n\t\t\tt.MaxDepth = parseDepth\n\n\t\t\tpkgName, err := getPkgName(filepath.Dir(absMainAPIFilePath))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\terr = t.Resolve(pkgName)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"pkg %s cannot find all dependencies, %s\", pkgName, err)\n\t\t\t}\n\t\t\tfor i := 0; i < len(t.Root.Deps); i++ {\n\t\t\t\terr := parser.getAllGoFileInfoFromDeps(&t.Root.Deps[i], parser.ParseDependency)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\terr = parser.ParseGeneralAPIInfo(absMainAPIFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tparser.parsedSchemas, err = parser.packages.ParseTypes()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = parser.packages.RangeFiles(parser.ParseRouterAPIInfo)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn parser.checkOperationIDUniqueness()\n}\n\nfunc getPkgName(searchDir string) (string, error) {\n\tcmd := exec.Command(\"go\", \"list\", \"-f={{.ImportPath}}\")\n\tcmd.Dir = searchDir\n\n\tvar stdout, stderr strings.Builder\n\n\tcmd.Stdout = &stdout\n\tcmd.Stderr = &stderr\n\n\tif err := cmd.Run(); err != nil {\n\t\treturn \"\", fmt.Errorf(\"execute go list command, %s, stdout:%s, stderr:%s\", err, stdout.String(), stderr.String())\n\t}\n\n\toutStr, _ := stdout.String(), stderr.String()\n\n\tif outStr[0] == '_' { // will shown like _/{GOPATH}/src/{YOUR_PACKAGE} when NOT enable GO MODULE.\n\t\toutStr = strings.TrimPrefix(outStr, \"_\"+build.Default.GOPATH+\"/src/\")\n\t}\n\n\tf := strings.Split(outStr, \"\\n\")\n\n\toutStr = f[0]\n\n\treturn outStr, nil\n}\n\n// ParseGeneralAPIInfo parses general api info for given mainAPIFile path.\nfunc (parser *Parser) ParseGeneralAPIInfo(mainAPIFile string) error {\n\tfileTree, err := goparser.ParseFile(token.NewFileSet(), mainAPIFile, nil, goparser.ParseComments)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"cannot parse source files %s: %s\", mainAPIFile, err)\n\t}\n\n\tparser.swagger.Swagger = \"2.0\"\n\n\tfor _, comment := range fileTree.Comments {\n\t\tcomments := strings.Split(comment.Text(), \"\\n\")\n\t\tif !isGeneralAPIComment(comments) {\n\t\t\tcontinue\n\t\t}\n\n\t\terr = parseGeneralAPIInfo(parser, comments)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc parseGeneralAPIInfo(parser *Parser, comments []string) error {\n\tpreviousAttribute := \"\"\n\tvar tag *spec.Tag\n\t// parsing classic meta data model\n\tfor line := 0; line < len(comments); line++ {\n\t\tcommentLine := comments[line]\n\t\tcommentLine = strings.TrimSpace(commentLine)\n\t\tif len(commentLine) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tfields := FieldsByAnySpace(commentLine, 2)\n\n\t\tattribute := fields[0]\n\t\tvar value string\n\t\tif len(fields) > 1 {\n\t\t\tvalue = fields[1]\n\t\t}\n\n\t\tswitch attr := strings.ToLower(attribute); attr {\n\t\tcase versionAttr, titleAttr, tosAttr, licNameAttr, licURLAttr, conNameAttr, conURLAttr, conEmailAttr:\n\t\t\tsetSwaggerInfo(parser.swagger, attr, value)\n\t\tcase descriptionAttr:\n\t\t\tif previousAttribute == attribute {\n\t\t\t\tparser.swagger.Info.Description += \"\\n\" + value\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tsetSwaggerInfo(parser.swagger, attr, value)\n\t\tcase descriptionMarkdownAttr:\n\t\t\tcommentInfo, err := getMarkdownForTag(\"api\", parser.markdownFileDir)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tsetSwaggerInfo(parser.swagger, descriptionAttr, string(commentInfo))\n\n\t\tcase \"@host\":\n\t\t\tparser.swagger.Host = value\n\t\tcase \"@hoststate\":\n\t\t\tfields = FieldsByAnySpace(commentLine, 3)\n\t\t\tif len(fields) != 3 {\n\t\t\t\treturn fmt.Errorf(\"%s needs 3 arguments\", attribute)\n\t\t\t}\n\t\t\tif parser.HostState == fields[1] {\n\t\t\t\tparser.swagger.Host = fields[2]\n\t\t\t}\n\t\tcase \"@basepath\":\n\t\t\tparser.swagger.BasePath = value\n\n\t\tcase acceptAttr:\n\t\t\terr := parser.ParseAcceptComment(value)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase produceAttr:\n\t\t\terr := parser.ParseProduceComment(value)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"@schemes\":\n\t\t\tparser.swagger.Schemes = strings.Split(value, \" \")\n\t\tcase \"@tag.name\":\n\t\t\tif parser.matchTag(value) {\n\t\t\t\tparser.swagger.Tags = append(parser.swagger.Tags, spec.Tag{\n\t\t\t\t\tTagProps: spec.TagProps{\n\t\t\t\t\t\tName: value,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\ttag = &parser.swagger.Tags[len(parser.swagger.Tags)-1]\n\t\t\t} else {\n\t\t\t\ttag = nil\n\t\t\t}\n\t\tcase \"@tag.description\":\n\t\t\tif tag != nil {\n\t\t\t\ttag.TagProps.Description = value\n\t\t\t}\n\t\tcase \"@tag.description.markdown\":\n\t\t\tif tag != nil {\n\t\t\t\tcommentInfo, err := getMarkdownForTag(tag.TagProps.Name, parser.markdownFileDir)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\ttag.TagProps.Description = string(commentInfo)\n\t\t\t}\n\t\tcase \"@tag.docs.url\":\n\t\t\tif tag != nil {\n\t\t\t\ttag.TagProps.ExternalDocs = &spec.ExternalDocumentation{\n\t\t\t\t\tURL: value,\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"@tag.docs.description\":\n\t\t\tif tag != nil {\n\t\t\t\tif tag.TagProps.ExternalDocs == nil {\n\t\t\t\t\treturn fmt.Errorf(\"%s needs to come after a @tags.docs.url\", attribute)\n\t\t\t\t}\n\n\t\t\t\ttag.TagProps.ExternalDocs.Description = value\n\t\t\t}\n\t\tcase secBasicAttr, secAPIKeyAttr, secApplicationAttr, secImplicitAttr, secPasswordAttr, secAccessCodeAttr:\n\t\t\tscheme, err := parseSecAttributes(attribute, comments, &line)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tparser.swagger.SecurityDefinitions[value] = scheme\n\n\t\tcase securityAttr:\n\t\t\tparser.swagger.Security = append(parser.swagger.Security, parseSecurity(value))\n\n\t\tcase \"@query.collection.format\":\n\t\t\tparser.collectionFormatInQuery = TransToValidCollectionFormat(value)\n\n\t\tcase extDocsDescAttr, extDocsURLAttr:\n\t\t\tif parser.swagger.ExternalDocs == nil {\n\t\t\t\tparser.swagger.ExternalDocs = new(spec.ExternalDocumentation)\n\t\t\t}\n\t\t\tswitch attr {\n\t\t\tcase extDocsDescAttr:\n\t\t\t\tparser.swagger.ExternalDocs.Description = value\n\t\t\tcase extDocsURLAttr:\n\t\t\t\tparser.swagger.ExternalDocs.URL = value\n\t\t\t}\n\n\t\tdefault:\n\t\t\tif strings.HasPrefix(attribute, \"@x-\") {\n\t\t\t\textensionName := attribute[1:]\n\n\t\t\t\textExistsInSecurityDef := false\n\t\t\t\t// for each security definition\n\t\t\t\tfor _, v := range parser.swagger.SecurityDefinitions {\n\t\t\t\t\t// check if extension exists\n\t\t\t\t\t_, extExistsInSecurityDef = v.VendorExtensible.Extensions.GetString(extensionName)\n\t\t\t\t\t// if it exists in at least one, then we stop iterating\n\t\t\t\t\tif extExistsInSecurityDef {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if it is present on security def, don't add it again\n\t\t\t\tif extExistsInSecurityDef {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif len(value) == 0 {\n\t\t\t\t\treturn fmt.Errorf(\"annotation %s need a value\", attribute)\n\t\t\t\t}\n\n\t\t\t\tvar valueJSON interface{}\n\t\t\t\terr := json.Unmarshal([]byte(value), &valueJSON)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"annotation %s need a valid json value\", attribute)\n\t\t\t\t}\n\n\t\t\t\tif strings.Contains(extensionName, \"logo\") {\n\t\t\t\t\tparser.swagger.Info.Extensions.Add(extensionName, valueJSON)\n\t\t\t\t} else {\n\t\t\t\t\tif parser.swagger.Extensions == nil {\n\t\t\t\t\t\tparser.swagger.Extensions = make(map[string]interface{})\n\t\t\t\t\t}\n\n\t\t\t\t\tparser.swagger.Extensions[attribute[1:]] = valueJSON\n\t\t\t\t}\n\t\t\t} else if strings.HasPrefix(attribute, \"@tag.x-\") {\n\t\t\t\textensionName := attribute[5:]\n\n\t\t\t\tif len(value) == 0 {\n\t\t\t\t\treturn fmt.Errorf(\"annotation %s need a value\", attribute)\n\t\t\t\t}\n\n\t\t\t\tif tag.Extensions == nil {\n\t\t\t\t\ttag.Extensions = make(map[string]interface{})\n\t\t\t\t}\n\n\t\t\t\t// tag.Extensions.Add(extensionName, value) works wrong (transforms extensionName to lower case)\n\t\t\t\t// needed to save case for ReDoc\n\t\t\t\t// https://redocly.com/docs/api-reference-docs/specification-extensions/x-display-name/\n\t\t\t\ttag.Extensions[extensionName] = value\n\t\t\t}\n\t\t}\n\n\t\tpreviousAttribute = attribute\n\t}\n\n\treturn nil\n}\n\nfunc setSwaggerInfo(swagger *spec.Swagger, attribute, value string) {\n\tswitch attribute {\n\tcase versionAttr:\n\t\tswagger.Info.Version = value\n\tcase titleAttr:\n\t\tswagger.Info.Title = value\n\tcase tosAttr:\n\t\tswagger.Info.TermsOfService = value\n\tcase descriptionAttr:\n\t\tswagger.Info.Description = value\n\tcase conNameAttr:\n\t\tswagger.Info.Contact.Name = value\n\tcase conEmailAttr:\n\t\tswagger.Info.Contact.Email = value\n\tcase conURLAttr:\n\t\tswagger.Info.Contact.URL = value\n\tcase licNameAttr:\n\t\tswagger.Info.License = initIfEmpty(swagger.Info.License)\n\t\tswagger.Info.License.Name = value\n\tcase licURLAttr:\n\t\tswagger.Info.License = initIfEmpty(swagger.Info.License)\n\t\tswagger.Info.License.URL = value\n\t}\n}\n\nfunc parseSecAttributes(context string, lines []string, index *int) (*spec.SecurityScheme, error) {\n\tconst (\n\t\tin               = \"@in\"\n\t\tname             = \"@name\"\n\t\tdescriptionAttr  = \"@description\"\n\t\ttokenURL         = \"@tokenurl\"\n\t\tauthorizationURL = \"@authorizationurl\"\n\t)\n\n\tvar search []string\n\n\tattribute := strings.ToLower(FieldsByAnySpace(lines[*index], 2)[0])\n\tswitch attribute {\n\tcase secBasicAttr:\n\t\treturn spec.BasicAuth(), nil\n\tcase secAPIKeyAttr:\n\t\tsearch = []string{in, name}\n\tcase secApplicationAttr, secPasswordAttr:\n\t\tsearch = []string{tokenURL}\n\tcase secImplicitAttr:\n\t\tsearch = []string{authorizationURL}\n\tcase secAccessCodeAttr:\n\t\tsearch = []string{tokenURL, authorizationURL}\n\t}\n\n\t// For the first line we get the attributes in the context parameter, so we skip to the next one\n\t*index++\n\n\tattrMap, scopes := make(map[string]string), make(map[string]string)\n\textensions, description := make(map[string]interface{}), \"\"\n\nloopline:\n\tfor ; *index < len(lines); *index++ {\n\t\tv := strings.TrimSpace(lines[*index])\n\t\tif len(v) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tfields := FieldsByAnySpace(v, 2)\n\t\tsecurityAttr := strings.ToLower(fields[0])\n\t\tvar value string\n\t\tif len(fields) > 1 {\n\t\t\tvalue = fields[1]\n\t\t}\n\n\t\tfor _, findterm := range search {\n\t\t\tif securityAttr == findterm {\n\t\t\t\tattrMap[securityAttr] = value\n\t\t\t\tcontinue loopline\n\t\t\t}\n\t\t}\n\n\t\tif isExists, err := isExistsScope(securityAttr); err != nil {\n\t\t\treturn nil, err\n\t\t} else if isExists {\n\t\t\tscopes[securityAttr[len(scopeAttrPrefix):]] = value\n\t\t\tcontinue\n\t\t}\n\n\t\tif strings.HasPrefix(securityAttr, \"@x-\") {\n\t\t\t// Add the custom attribute without the @\n\t\t\textensions[securityAttr[1:]] = value\n\t\t\tcontinue\n\t\t}\n\n\t\t// Not mandatory field\n\t\tif securityAttr == descriptionAttr {\n\t\t\tif description != \"\" {\n\t\t\t\tdescription += \"\\n\"\n\t\t\t}\n\t\t\tdescription += value\n\t\t}\n\n\t\t// next securityDefinitions\n\t\tif strings.Index(securityAttr, \"@securitydefinitions.\") == 0 {\n\t\t\t// Go back to the previous line and break\n\t\t\t*index--\n\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif len(attrMap) != len(search) {\n\t\treturn nil, fmt.Errorf(\"%s is %v required\", context, search)\n\t}\n\n\tvar scheme *spec.SecurityScheme\n\n\tswitch attribute {\n\tcase secAPIKeyAttr:\n\t\tscheme = spec.APIKeyAuth(attrMap[name], attrMap[in])\n\tcase secApplicationAttr:\n\t\tscheme = spec.OAuth2Application(attrMap[tokenURL])\n\tcase secImplicitAttr:\n\t\tscheme = spec.OAuth2Implicit(attrMap[authorizationURL])\n\tcase secPasswordAttr:\n\t\tscheme = spec.OAuth2Password(attrMap[tokenURL])\n\tcase secAccessCodeAttr:\n\t\tscheme = spec.OAuth2AccessToken(attrMap[authorizationURL], attrMap[tokenURL])\n\t}\n\n\tscheme.Description = description\n\n\tfor extKey, extValue := range extensions {\n\t\tscheme.AddExtension(extKey, extValue)\n\t}\n\n\tfor scope, scopeDescription := range scopes {\n\t\tscheme.AddScope(scope, scopeDescription)\n\t}\n\n\treturn scheme, nil\n}\n\nfunc parseSecurity(commentLine string) map[string][]string {\n\tsecurityMap := make(map[string][]string)\n\n\tfor _, securityOption := range securityPairSepPattern.Split(commentLine, -1) {\n\t\tsecurityOption = strings.TrimSpace(securityOption)\n\n\t\tleft, right := strings.Index(securityOption, \"[\"), strings.Index(securityOption, \"]\")\n\n\t\tif !(left == -1 && right == -1) {\n\t\t\tscopes := securityOption[left+1 : right]\n\n\t\t\tvar options []string\n\n\t\t\tfor _, scope := range strings.Split(scopes, \",\") {\n\t\t\t\toptions = append(options, strings.TrimSpace(scope))\n\t\t\t}\n\n\t\t\tsecurityKey := securityOption[0:left]\n\t\t\tsecurityMap[securityKey] = append(securityMap[securityKey], options...)\n\t\t} else {\n\t\t\tsecurityKey := strings.TrimSpace(securityOption)\n\t\t\tsecurityMap[securityKey] = []string{}\n\t\t}\n\t}\n\n\treturn securityMap\n}\n\nfunc initIfEmpty(license *spec.License) *spec.License {\n\tif license == nil {\n\t\treturn new(spec.License)\n\t}\n\n\treturn license\n}\n\n// ParseAcceptComment parses comment for given `accept` comment string.\nfunc (parser *Parser) ParseAcceptComment(commentLine string) error {\n\treturn parseMimeTypeList(commentLine, &parser.swagger.Consumes, \"%v accept type can't be accepted\")\n}\n\n// ParseProduceComment parses comment for given `produce` comment string.\nfunc (parser *Parser) ParseProduceComment(commentLine string) error {\n\treturn parseMimeTypeList(commentLine, &parser.swagger.Produces, \"%v produce type can't be accepted\")\n}\n\nfunc isGeneralAPIComment(comments []string) bool {\n\tfor _, commentLine := range comments {\n\t\tcommentLine = strings.TrimSpace(commentLine)\n\t\tif len(commentLine) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tattribute := strings.ToLower(FieldsByAnySpace(commentLine, 2)[0])\n\t\tswitch attribute {\n\t\t// The @summary, @router, @success, @failure annotation belongs to Operation\n\t\tcase summaryAttr, routerAttr, successAttr, failureAttr, responseAttr:\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc getMarkdownForTag(tagName string, dirPath string) ([]byte, error) {\n\tif tagName == \"\" {\n\t\t// this happens when parsing the @description.markdown attribute\n\t\t// it will be called properly another time with tagName=\"api\"\n\t\t// so we can safely return an empty byte slice here\n\t\treturn make([]byte, 0), nil\n\t}\n\n\tdirEntries, err := os.ReadDir(dirPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, entry := range dirEntries {\n\t\tif entry.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\tfileName := entry.Name()\n\n\t\texpectedFileName := tagName\n\t\tif !strings.HasSuffix(tagName, \".md\") {\n\t\t\texpectedFileName = tagName + \".md\"\n\t\t}\n\n\t\tif fileName == expectedFileName {\n\t\t\tfullPath := filepath.Join(dirPath, fileName)\n\n\t\t\tcommentInfo, err := os.ReadFile(fullPath)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Failed to read markdown file %s error: %s \", fullPath, err)\n\t\t\t}\n\n\t\t\treturn commentInfo, nil\n\t\t}\n\t}\n\n\treturn nil, fmt.Errorf(\"Unable to find markdown file for tag %s in the given directory\", tagName)\n}\n\nfunc isExistsScope(scope string) (bool, error) {\n\ts := strings.Fields(scope)\n\tfor _, v := range s {\n\t\tif strings.HasPrefix(v, scopeAttrPrefix) {\n\t\t\tif strings.Contains(v, \",\") {\n\t\t\t\treturn false, fmt.Errorf(\"@scope can't use comma(,) get=\" + v)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn strings.HasPrefix(scope, scopeAttrPrefix), nil\n}\n\nfunc getTagsFromComment(comment string) (tags []string) {\n\tcommentLine := strings.TrimSpace(strings.TrimLeft(comment, \"/\"))\n\tif len(commentLine) == 0 {\n\t\treturn nil\n\t}\n\n\tattribute := strings.Fields(commentLine)[0]\n\tlineRemainder, lowerAttribute := strings.TrimSpace(commentLine[len(attribute):]), strings.ToLower(attribute)\n\n\tif lowerAttribute == tagsAttr {\n\t\tfor _, tag := range strings.Split(lineRemainder, \",\") {\n\t\t\ttags = append(tags, strings.TrimSpace(tag))\n\t\t}\n\t}\n\treturn\n\n}\n\nfunc (parser *Parser) matchTag(tag string) bool {\n\tif len(parser.tags) == 0 {\n\t\treturn true\n\t}\n\n\tif _, has := parser.tags[\"!\"+tag]; has {\n\t\treturn false\n\t}\n\tif _, has := parser.tags[tag]; has {\n\t\treturn true\n\t}\n\n\t// If all tags are negation then we should return true\n\tfor key := range parser.tags {\n\t\tif key[0] != '!' {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (parser *Parser) matchTags(comments []*ast.Comment) (match bool) {\n\tif len(parser.tags) == 0 {\n\t\treturn true\n\t}\n\n\tmatch = false\n\tfor _, comment := range comments {\n\t\tfor _, tag := range getTagsFromComment(comment.Text) {\n\t\t\tif _, has := parser.tags[\"!\"+tag]; has {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif _, has := parser.tags[tag]; has {\n\t\t\t\tmatch = true // keep iterating as it may contain a tag that is excluded\n\t\t\t}\n\t\t}\n\t}\n\n\tif !match {\n\t\t// If all tags are negation then we should return true\n\t\tfor key := range parser.tags {\n\t\t\tif key[0] != '!' {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\nfunc matchExtension(extensionToMatch string, comments []*ast.Comment) (match bool) {\n\tif len(extensionToMatch) != 0 {\n\t\tfor _, comment := range comments {\n\t\t\tcommentLine := strings.TrimSpace(strings.TrimLeft(comment.Text, \"/\"))\n\t\t\tfields := FieldsByAnySpace(commentLine, 2)\n\t\t\tif len(fields) > 0 {\n\t\t\t\tlowerAttribute := strings.ToLower(fields[0])\n\n\t\t\t\tif lowerAttribute == fmt.Sprintf(\"@x-%s\", strings.ToLower(extensionToMatch)) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc getFuncDoc(decl any) (*ast.CommentGroup, bool) {\n\tswitch astDecl := decl.(type) {\n\tcase *ast.FuncDecl: // func name() {}\n\t\treturn astDecl.Doc, true\n\tcase *ast.GenDecl: // var name = namePointToFuncDirectlyOrIndirectly\n\t\tif astDecl.Tok != token.VAR {\n\t\t\treturn nil, false\n\t\t}\n\t\tvarSpec, ok := astDecl.Specs[0].(*ast.ValueSpec)\n\t\tif !ok || len(varSpec.Values) != 1 {\n\t\t\treturn nil, false\n\t\t}\n\t\t_, ok = getFuncDoc(varSpec)\n\t\treturn astDecl.Doc, ok\n\tcase *ast.ValueSpec:\n\t\tvalue, ok := astDecl.Values[0].(*ast.Ident)\n\t\tif !ok || value == nil {\n\t\t\treturn nil, false\n\t\t}\n\t\t_, ok = getFuncDoc(value.Obj.Decl)\n\t\treturn astDecl.Doc, ok\n\t}\n\treturn nil, false\n}\n\n// ParseRouterAPIInfo parses router api info for given astFile.\nfunc (parser *Parser) ParseRouterAPIInfo(fileInfo *AstFileInfo) error {\n\tif (fileInfo.ParseFlag & ParseOperations) == ParseNone {\n\t\treturn nil\n\t}\n\n\t// parse File.Comments instead of File.Decls.Doc if ParseFuncBody flag set to \"true\"\n\tif parser.ParseFuncBody {\n\t\tfor _, astComments := range fileInfo.File.Comments {\n\t\t\tif astComments.List != nil {\n\t\t\t\tif err := parser.parseRouterAPIInfoComment(astComments.List, fileInfo); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tfor _, decl := range fileInfo.File.Decls {\n\t\tfuncDoc, ok := getFuncDoc(decl)\n\t\tif ok && funcDoc != nil && funcDoc.List != nil {\n\t\t\tif err := parser.parseRouterAPIInfoComment(funcDoc.List, fileInfo); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (parser *Parser) parseRouterAPIInfoComment(comments []*ast.Comment, fileInfo *AstFileInfo) error {\n\tif parser.matchTags(comments) && matchExtension(parser.parseExtension, comments) {\n\t\t// for per 'function' comment, create a new 'Operation' object\n\t\toperation := NewOperation(parser, SetCodeExampleFilesDirectory(parser.codeExampleFilesDir))\n\t\tfor _, comment := range comments {\n\t\t\terr := operation.ParseComment(comment.Text, fileInfo.File)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"ParseComment error in file %s for comment: '%s': %+v\", fileInfo.Path, comment.Text, err)\n\t\t\t}\n\t\t\tif operation.State != \"\" && operation.State != parser.HostState {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\terr := processRouterOperation(parser, operation)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc refRouteMethodOp(item *spec.PathItem, method string) (op **spec.Operation) {\n\tswitch method {\n\tcase http.MethodGet:\n\t\top = &item.Get\n\tcase http.MethodPost:\n\t\top = &item.Post\n\tcase http.MethodDelete:\n\t\top = &item.Delete\n\tcase http.MethodPut:\n\t\top = &item.Put\n\tcase http.MethodPatch:\n\t\top = &item.Patch\n\tcase http.MethodHead:\n\t\top = &item.Head\n\tcase http.MethodOptions:\n\t\top = &item.Options\n\t}\n\n\treturn\n}\n\nfunc processRouterOperation(parser *Parser, operation *Operation) error {\n\tfor _, routeProperties := range operation.RouterProperties {\n\t\tvar (\n\t\t\tpathItem spec.PathItem\n\t\t\tok       bool\n\t\t)\n\n\t\tpathItem, ok = parser.swagger.Paths.Paths[routeProperties.Path]\n\t\tif !ok {\n\t\t\tpathItem = spec.PathItem{}\n\t\t}\n\n\t\top := refRouteMethodOp(&pathItem, routeProperties.HTTPMethod)\n\n\t\t// check if we already have an operation for this path and method\n\t\tif *op != nil {\n\t\t\terr := fmt.Errorf(\"route %s %s is declared multiple times\", routeProperties.HTTPMethod, routeProperties.Path)\n\t\t\tif parser.Strict {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tparser.debug.Printf(\"warning: %s\\n\", err)\n\t\t}\n\n\t\tif len(operation.RouterProperties) > 1 {\n\t\t\tnewOp := *operation\n\t\t\tvar validParams []spec.Parameter\n\t\t\tfor _, param := range newOp.Operation.OperationProps.Parameters {\n\t\t\t\tif param.In == \"path\" && !strings.Contains(routeProperties.Path, param.Name) {\n\t\t\t\t\t// This path param is not actually contained in the path, skip adding it to the final params\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tvalidParams = append(validParams, param)\n\t\t\t}\n\t\t\tnewOp.Operation.OperationProps.Parameters = validParams\n\t\t\t*op = &newOp.Operation\n\t\t} else {\n\t\t\t*op = &operation.Operation\n\t\t}\n\n\t\tif routeProperties.Deprecated {\n\t\t\t(*op).Deprecated = routeProperties.Deprecated\n\t\t}\n\n\t\tparser.swagger.Paths.Paths[routeProperties.Path] = pathItem\n\t}\n\n\treturn nil\n}\n\nfunc convertFromSpecificToPrimitive(typeName string) (string, error) {\n\tname := typeName\n\tif strings.ContainsRune(name, '.') {\n\t\tname = strings.Split(name, \".\")[1]\n\t}\n\n\tswitch strings.ToUpper(name) {\n\tcase \"TIME\", \"OBJECTID\", \"UUID\":\n\t\treturn STRING, nil\n\tcase \"DECIMAL\":\n\t\treturn NUMBER, nil\n\t}\n\n\treturn typeName, ErrFailedConvertPrimitiveType\n}\n\nfunc (parser *Parser) getTypeSchema(typeName string, file *ast.File, ref bool) (*spec.Schema, error) {\n\tif override, ok := parser.Overrides[typeName]; ok {\n\t\tparser.debug.Printf(\"Override detected for %s: using %s instead\", typeName, override)\n\t\treturn parseObjectSchema(parser, override, file)\n\t}\n\n\tif IsInterfaceLike(typeName) {\n\t\treturn &spec.Schema{}, nil\n\t}\n\tif IsGolangPrimitiveType(typeName) {\n\t\treturn TransToValidPrimitiveSchema(typeName), nil\n\t}\n\n\tschemaType, err := convertFromSpecificToPrimitive(typeName)\n\tif err == nil {\n\t\treturn PrimitiveSchema(schemaType), nil\n\t}\n\n\ttypeSpecDef := parser.packages.FindTypeSpec(typeName, file)\n\tif typeSpecDef == nil {\n\t\treturn nil, fmt.Errorf(\"cannot find type definition: %s\", typeName)\n\t}\n\n\tif override, ok := parser.Overrides[typeSpecDef.FullPath()]; ok {\n\t\tif override == \"\" {\n\t\t\tparser.debug.Printf(\"Override detected for %s: ignoring\", typeSpecDef.FullPath())\n\n\t\t\treturn nil, ErrSkippedField\n\t\t}\n\n\t\tparser.debug.Printf(\"Override detected for %s: using %s instead\", typeSpecDef.FullPath(), override)\n\n\t\tseparator := strings.LastIndex(override, \".\")\n\t\tif separator == -1 {\n\t\t\t// treat as a swaggertype tag\n\t\t\tparts := strings.Split(override, \",\")\n\n\t\t\treturn BuildCustomSchema(parts)\n\t\t}\n\n\t\ttypeSpecDef = parser.packages.findTypeSpec(override[0:separator], override[separator+1:])\n\t}\n\n\tschema, ok := parser.parsedSchemas[typeSpecDef]\n\tif !ok {\n\t\tvar err error\n\n\t\tschema, err = parser.ParseDefinition(typeSpecDef)\n\t\tif err != nil {\n\t\t\tif err == ErrRecursiveParseStruct && ref {\n\t\t\t\treturn parser.getRefTypeSchema(typeSpecDef, schema), nil\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"%s: %w\", typeName, err)\n\t\t}\n\t}\n\n\tif ref {\n\t\tif IsComplexSchema(schema.Schema) {\n\t\t\treturn parser.getRefTypeSchema(typeSpecDef, schema), nil\n\t\t}\n\t\t// if it is a simple schema, just return a copy\n\t\tnewSchema := *schema.Schema\n\t\treturn &newSchema, nil\n\t}\n\n\treturn schema.Schema, nil\n}\n\nfunc (parser *Parser) getRefTypeSchema(typeSpecDef *TypeSpecDef, schema *Schema) *spec.Schema {\n\t_, ok := parser.outputSchemas[typeSpecDef]\n\tif !ok {\n\t\tparser.swagger.Definitions[schema.Name] = spec.Schema{}\n\n\t\tif schema.Schema != nil {\n\t\t\tparser.swagger.Definitions[schema.Name] = *schema.Schema\n\t\t}\n\n\t\tparser.outputSchemas[typeSpecDef] = schema\n\t}\n\n\trefSchema := RefSchema(schema.Name)\n\n\treturn refSchema\n}\n\nfunc (parser *Parser) isInStructStack(typeSpecDef *TypeSpecDef) bool {\n\tfor _, specDef := range parser.structStack {\n\t\tif typeSpecDef == specDef {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// ParseDefinition parses given type spec that corresponds to the type under\n// given name and package, and populates swagger schema definitions registry\n// with a schema for the given type\nfunc (parser *Parser) ParseDefinition(typeSpecDef *TypeSpecDef) (*Schema, error) {\n\ttypeName := typeSpecDef.TypeName()\n\tschema, found := parser.parsedSchemas[typeSpecDef]\n\tif found {\n\t\tparser.debug.Printf(\"Skipping '%s', already parsed.\", typeName)\n\n\t\treturn schema, nil\n\t}\n\n\tif parser.isInStructStack(typeSpecDef) {\n\t\tparser.debug.Printf(\"Skipping '%s', recursion detected.\", typeName)\n\n\t\treturn &Schema{\n\t\t\t\tName:    typeSpecDef.SchemaName,\n\t\t\t\tPkgPath: typeSpecDef.PkgPath,\n\t\t\t\tSchema:  PrimitiveSchema(OBJECT),\n\t\t\t},\n\t\t\tErrRecursiveParseStruct\n\t}\n\n\tparser.structStack = append(parser.structStack, typeSpecDef)\n\n\tparser.debug.Printf(\"Generating %s\", typeName)\n\n\tdefinition, err := parser.parseTypeExpr(typeSpecDef.File, typeSpecDef.TypeSpec.Type, false)\n\tif err != nil {\n\t\tparser.debug.Printf(\"Error parsing type definition '%s': %s\", typeName, err)\n\t\treturn nil, err\n\t}\n\n\tif definition.Description == \"\" {\n\t\terr = parser.fillDefinitionDescription(definition, typeSpecDef.File, typeSpecDef)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif len(typeSpecDef.Enums) > 0 {\n\t\tvar varnames []string\n\t\tvar enumComments = make(map[string]string)\n\t\tvar enumDescriptions = make([]string, 0, len(typeSpecDef.Enums))\n\t\tfor _, value := range typeSpecDef.Enums {\n\t\t\tdefinition.Enum = append(definition.Enum, value.Value)\n\t\t\tvarnames = append(varnames, value.key)\n\t\t\tif len(value.Comment) > 0 {\n\t\t\t\tenumComments[value.key] = value.Comment\n\t\t\t\tenumDescriptions = append(enumDescriptions, value.Comment)\n\t\t\t}\n\t\t}\n\t\tif definition.Extensions == nil {\n\t\t\tdefinition.Extensions = make(spec.Extensions)\n\t\t}\n\t\tdefinition.Extensions[enumVarNamesExtension] = varnames\n\t\tif len(enumComments) > 0 {\n\t\t\tdefinition.Extensions[enumCommentsExtension] = enumComments\n\t\t\tdefinition.Extensions[enumDescriptionsExtension] = enumDescriptions\n\t\t}\n\t}\n\n\tschemaName := typeName\n\n\tif typeSpecDef.SchemaName != \"\" {\n\t\tschemaName = typeSpecDef.SchemaName\n\t}\n\n\tsch := Schema{\n\t\tName:    schemaName,\n\t\tPkgPath: typeSpecDef.PkgPath,\n\t\tSchema:  definition,\n\t}\n\tparser.parsedSchemas[typeSpecDef] = &sch\n\n\t// update an empty schema as a result of recursion\n\ts2, found := parser.outputSchemas[typeSpecDef]\n\tif found {\n\t\tparser.swagger.Definitions[s2.Name] = *definition\n\t}\n\n\treturn &sch, nil\n}\n\nfunc fullTypeName(parts ...string) string {\n\treturn strings.Join(parts, \".\")\n}\n\n// fillDefinitionDescription additionally fills fields in definition (spec.Schema)\n// TODO: If .go file contains many types, it may work for a long time\nfunc (parser *Parser) fillDefinitionDescription(definition *spec.Schema, file *ast.File, typeSpecDef *TypeSpecDef) (err error) {\n\tif file == nil {\n\t\treturn\n\t}\n\tfor _, astDeclaration := range file.Decls {\n\t\tgeneralDeclaration, ok := astDeclaration.(*ast.GenDecl)\n\t\tif !ok || generalDeclaration.Tok != token.TYPE {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, astSpec := range generalDeclaration.Specs {\n\t\t\ttypeSpec, ok := astSpec.(*ast.TypeSpec)\n\t\t\tif !ok || typeSpec != typeSpecDef.TypeSpec {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar typeName string\n\t\t\tif typeSpec.Name != nil {\n\t\t\t\ttypeName = typeSpec.Name.Name\n\t\t\t}\n\t\t\tdefinition.Description, err =\n\t\t\t\tparser.extractDeclarationDescription(typeName, typeSpec.Doc, typeSpec.Comment, generalDeclaration.Doc)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// extractDeclarationDescription gets first description\n// from attribute descriptionAttr in commentGroups (ast.CommentGroup)\nfunc (parser *Parser) extractDeclarationDescription(typeName string, commentGroups ...*ast.CommentGroup) (string, error) {\n\tvar description string\n\n\tfor _, commentGroup := range commentGroups {\n\t\tif commentGroup == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tisHandlingDescription := false\n\n\t\tfor _, comment := range commentGroup.List {\n\t\t\tcommentText := strings.TrimSpace(strings.TrimLeft(comment.Text, \"/\"))\n\t\t\tif len(commentText) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfields := FieldsByAnySpace(commentText, 2)\n\t\t\tattribute := fields[0]\n\n\t\t\tif attr := strings.ToLower(attribute); attr == descriptionMarkdownAttr {\n\t\t\t\tif len(fields) > 1 {\n\t\t\t\t\ttypeName = fields[1]\n\t\t\t\t}\n\t\t\t\tif typeName == \"\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tdesc, err := getMarkdownForTag(typeName, parser.markdownFileDir)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn \"\", err\n\t\t\t\t}\n\t\t\t\t// if found markdown description, we will only use the markdown file content\n\t\t\t\treturn string(desc), nil\n\t\t\t} else if attr != descriptionAttr {\n\t\t\t\tif !isHandlingDescription {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tisHandlingDescription = true\n\t\t\tdescription += \" \" + strings.TrimSpace(commentText[len(attribute):])\n\t\t}\n\t}\n\n\treturn strings.TrimLeft(description, \" \"), nil\n}\n\n// parseTypeExpr parses given type expression that corresponds to the type under\n// given name and package, and returns swagger schema for it.\nfunc (parser *Parser) parseTypeExpr(file *ast.File, typeExpr ast.Expr, ref bool) (*spec.Schema, error) {\n\tswitch expr := typeExpr.(type) {\n\t// type Foo interface{}\n\tcase *ast.InterfaceType:\n\t\treturn &spec.Schema{}, nil\n\n\t// type Foo struct {...}\n\tcase *ast.StructType:\n\t\treturn parser.parseStruct(file, expr.Fields)\n\n\t// type Foo Baz\n\tcase *ast.Ident:\n\t\treturn parser.getTypeSchema(expr.Name, file, ref)\n\n\t// type Foo *Baz\n\tcase *ast.StarExpr:\n\t\treturn parser.parseTypeExpr(file, expr.X, ref)\n\n\t// type Foo pkg.Bar\n\tcase *ast.SelectorExpr:\n\t\tif xIdent, ok := expr.X.(*ast.Ident); ok {\n\t\t\treturn parser.getTypeSchema(fullTypeName(xIdent.Name, expr.Sel.Name), file, ref)\n\t\t}\n\t// type Foo []Baz\n\tcase *ast.ArrayType:\n\t\titemSchema, err := parser.parseTypeExpr(file, expr.Elt, true)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn spec.ArrayProperty(itemSchema), nil\n\t// type Foo map[string]Bar\n\tcase *ast.MapType:\n\t\tif _, ok := expr.Value.(*ast.InterfaceType); ok {\n\t\t\treturn spec.MapProperty(nil), nil\n\t\t}\n\t\tschema, err := parser.parseTypeExpr(file, expr.Value, true)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn spec.MapProperty(schema), nil\n\n\tcase *ast.FuncType:\n\t\treturn nil, ErrFuncTypeField\n\t\t// ...\n\t}\n\n\treturn parser.parseGenericTypeExpr(file, typeExpr)\n}\n\nfunc (parser *Parser) parseStruct(file *ast.File, fields *ast.FieldList) (*spec.Schema, error) {\n\trequired, properties := make([]string, 0), make(map[string]spec.Schema)\n\n\tfor _, field := range fields.List {\n\t\tfieldProps, requiredFromAnon, err := parser.parseStructField(file, field)\n\t\tif err != nil {\n\t\t\tif errors.Is(err, ErrFuncTypeField) || errors.Is(err, ErrSkippedField) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif len(fieldProps) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\trequired = append(required, requiredFromAnon...)\n\n\t\tfor k, v := range fieldProps {\n\t\t\tproperties[k] = v\n\t\t}\n\t}\n\n\tsort.Strings(required)\n\n\treturn &spec.Schema{\n\t\tSchemaProps: spec.SchemaProps{\n\t\t\tType:       []string{OBJECT},\n\t\t\tProperties: properties,\n\t\t\tRequired:   required,\n\t\t},\n\t}, nil\n}\n\nfunc (parser *Parser) parseStructField(file *ast.File, field *ast.Field) (map[string]spec.Schema, []string, error) {\n\tif field.Tag != nil {\n\t\tskip, ok := reflect.StructTag(strings.ReplaceAll(field.Tag.Value, \"`\", \"\")).Lookup(\"swaggerignore\")\n\t\tif ok && strings.EqualFold(skip, \"true\") {\n\t\t\treturn nil, nil, nil\n\t\t}\n\t}\n\n\tps := parser.fieldParserFactory(parser, field)\n\n\tif ps.ShouldSkip() {\n\t\treturn nil, nil, nil\n\t}\n\n\tfieldNames, err := ps.FieldNames()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tif len(fieldNames) == 0 {\n\t\ttypeName, err := getFieldType(file, field.Type, nil)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\tschema, err := parser.getTypeSchema(typeName, file, false)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\tif len(schema.Type) > 0 && schema.Type[0] == OBJECT {\n\t\t\tif len(schema.Properties) == 0 {\n\t\t\t\treturn nil, nil, nil\n\t\t\t}\n\n\t\t\tproperties := map[string]spec.Schema{}\n\t\t\tfor k, v := range schema.Properties {\n\t\t\t\tproperties[k] = v\n\t\t\t}\n\n\t\t\treturn properties, schema.SchemaProps.Required, nil\n\t\t}\n\t\t// for alias type of non-struct types ,such as array,map, etc. ignore field tag.\n\t\treturn map[string]spec.Schema{typeName: *schema}, nil, nil\n\n\t}\n\n\tschema, err := ps.CustomSchema()\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"%v: %w\", fieldNames, err)\n\t}\n\n\tif schema == nil {\n\t\ttypeName, err := getFieldType(file, field.Type, nil)\n\t\tif err == nil {\n\t\t\t// named type\n\t\t\tschema, err = parser.getTypeSchema(typeName, file, true)\n\t\t} else {\n\t\t\t// unnamed type\n\t\t\tschema, err = parser.parseTypeExpr(file, field.Type, false)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(\"%v: %w\", fieldNames, err)\n\t\t}\n\t}\n\n\terr = ps.ComplementSchema(schema)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"%v: %w\", fieldNames, err)\n\t}\n\n\tvar tagRequired []string\n\n\trequired, err := ps.IsRequired()\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"%v: %w\", fieldNames, err)\n\t}\n\n\tif required {\n\t\ttagRequired = append(tagRequired, fieldNames...)\n\t}\n\n\tif schema.Extensions == nil {\n\t\tschema.Extensions = make(spec.Extensions)\n\t}\n\tif formName := ps.FormName(); len(formName) > 0 {\n\t\tschema.Extensions[\"formData\"] = formName\n\t}\n\tif headerName := ps.HeaderName(); len(headerName) > 0 {\n\t\tschema.Extensions[\"header\"] = headerName\n\t}\n\tif pathName := ps.PathName(); len(pathName) > 0 {\n\t\tschema.Extensions[\"path\"] = pathName\n\t}\n\tfields := make(map[string]spec.Schema)\n\tfor _, name := range fieldNames {\n\t\tfields[name] = *schema\n\t}\n\treturn fields, tagRequired, nil\n}\n\nfunc getFieldType(file *ast.File, field ast.Expr, genericParamTypeDefs map[string]*genericTypeSpec) (string, error) {\n\tswitch fieldType := field.(type) {\n\tcase *ast.Ident:\n\t\treturn fieldType.Name, nil\n\tcase *ast.SelectorExpr:\n\t\tpackageName, err := getFieldType(file, fieldType.X, genericParamTypeDefs)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\treturn fullTypeName(packageName, fieldType.Sel.Name), nil\n\tcase *ast.StarExpr:\n\t\tfullName, err := getFieldType(file, fieldType.X, genericParamTypeDefs)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\treturn fullName, nil\n\tdefault:\n\t\treturn getGenericFieldType(file, field, genericParamTypeDefs)\n\t}\n}\n\nfunc (parser *Parser) getUnderlyingSchema(schema *spec.Schema) *spec.Schema {\n\tif schema == nil {\n\t\treturn nil\n\t}\n\n\tif url := schema.Ref.GetURL(); url != nil {\n\t\tif pos := strings.LastIndexByte(url.Fragment, '/'); pos >= 0 {\n\t\t\tname := url.Fragment[pos+1:]\n\t\t\tif schema, ok := parser.swagger.Definitions[name]; ok {\n\t\t\t\treturn &schema\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(schema.AllOf) > 0 {\n\t\tmerged := &spec.Schema{}\n\t\tMergeSchema(merged, schema)\n\t\tfor _, s := range schema.AllOf {\n\t\t\tMergeSchema(merged, parser.getUnderlyingSchema(&s))\n\t\t}\n\t\treturn merged\n\t}\n\treturn nil\n}\n\n// GetSchemaTypePath get path of schema type.\nfunc (parser *Parser) GetSchemaTypePath(schema *spec.Schema, depth int) []string {\n\tif schema == nil || depth == 0 {\n\t\treturn nil\n\t}\n\n\tif underlying := parser.getUnderlyingSchema(schema); underlying != nil {\n\t\treturn parser.GetSchemaTypePath(underlying, depth)\n\t}\n\n\tif len(schema.Type) > 0 {\n\t\tswitch schema.Type[0] {\n\t\tcase ARRAY:\n\t\t\tdepth--\n\n\t\t\ts := []string{schema.Type[0]}\n\n\t\t\treturn append(s, parser.GetSchemaTypePath(schema.Items.Schema, depth)...)\n\t\tcase OBJECT:\n\t\t\tif schema.AdditionalProperties != nil && schema.AdditionalProperties.Schema != nil {\n\t\t\t\t// for map\n\t\t\t\tdepth--\n\n\t\t\t\ts := []string{schema.Type[0]}\n\n\t\t\t\treturn append(s, parser.GetSchemaTypePath(schema.AdditionalProperties.Schema, depth)...)\n\t\t\t}\n\t\t}\n\n\t\treturn []string{schema.Type[0]}\n\t}\n\n\treturn []string{ANY}\n}\n\n// defineTypeOfExample example value define the type (object and array unsupported).\nfunc defineTypeOfExample(schemaType, arrayType, exampleValue string) (interface{}, error) {\n\tswitch schemaType {\n\tcase STRING:\n\t\treturn exampleValue, nil\n\tcase NUMBER:\n\t\tv, err := strconv.ParseFloat(exampleValue, 64)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"example value %s can't convert to %s err: %s\", exampleValue, schemaType, err)\n\t\t}\n\n\t\treturn v, nil\n\tcase INTEGER:\n\t\tv, err := strconv.Atoi(exampleValue)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"example value %s can't convert to %s err: %s\", exampleValue, schemaType, err)\n\t\t}\n\n\t\treturn v, nil\n\tcase BOOLEAN:\n\t\tv, err := strconv.ParseBool(exampleValue)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"example value %s can't convert to %s err: %s\", exampleValue, schemaType, err)\n\t\t}\n\n\t\treturn v, nil\n\tcase ARRAY:\n\t\tvalues := strings.Split(exampleValue, \",\")\n\t\tresult := make([]interface{}, 0)\n\t\tfor _, value := range values {\n\t\t\tv, err := defineTypeOfExample(arrayType, \"\", value)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tresult = append(result, v)\n\t\t}\n\n\t\treturn result, nil\n\tcase OBJECT:\n\t\tif arrayType == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"%s is unsupported type in example value `%s`\", schemaType, exampleValue)\n\t\t}\n\n\t\tvalues := strings.Split(exampleValue, \",\")\n\n\t\tresult := map[string]interface{}{}\n\n\t\tfor _, value := range values {\n\t\t\tmapData := strings.SplitN(value, \":\", 2)\n\n\t\t\tif len(mapData) == 2 {\n\t\t\t\tv, err := defineTypeOfExample(arrayType, \"\", mapData[1])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tresult[mapData[0]] = v\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\treturn nil, fmt.Errorf(\"example value %s should format: key:value\", exampleValue)\n\t\t}\n\n\t\treturn result, nil\n\t}\n\n\treturn nil, fmt.Errorf(\"%s is unsupported type in example value %s\", schemaType, exampleValue)\n}\n\n// GetAllGoFileInfo gets all Go source files information for given searchDir.\nfunc (parser *Parser) getAllGoFileInfo(packageDir, searchDir string) error {\n\tif parser.skipPackageByPrefix(packageDir) {\n\t\treturn nil // ignored by user-defined package path prefixes\n\t}\n\treturn filepath.Walk(searchDir, func(path string, f os.FileInfo, _ error) error {\n\t\terr := parser.Skip(path, f)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif f.IsDir() {\n\t\t\treturn nil\n\t\t}\n\n\t\trelPath, err := filepath.Rel(searchDir, path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn parser.parseFile(filepath.ToSlash(filepath.Dir(filepath.Clean(filepath.Join(packageDir, relPath)))), path, nil, ParseAll)\n\t})\n}\n\nfunc (parser *Parser) getAllGoFileInfoFromDeps(pkg *depth.Pkg, parseFlag ParseFlag) error {\n\tignoreInternal := pkg.Internal && !parser.ParseInternal\n\tif ignoreInternal || !pkg.Resolved { // ignored internal and not resolved dependencies\n\t\treturn nil\n\t}\n\n\tif pkg.Raw != nil && parser.skipPackageByPrefix(pkg.Raw.ImportPath) {\n\t\treturn nil // ignored by user-defined package path prefixes\n\t}\n\n\t// Skip cgo\n\tif pkg.Raw == nil && pkg.Name == \"C\" {\n\t\treturn nil\n\t}\n\n\tsrcDir := pkg.Raw.Dir\n\n\tfiles, err := os.ReadDir(srcDir) // only parsing files in the dir(don't contain sub dir files)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, f := range files {\n\t\tif f.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\tpath := filepath.Join(srcDir, f.Name())\n\t\tif err := parser.parseFile(pkg.Name, path, nil, parseFlag); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor i := 0; i < len(pkg.Deps); i++ {\n\t\tif err := parser.getAllGoFileInfoFromDeps(&pkg.Deps[i], parseFlag); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (parser *Parser) parseFile(packageDir, path string, src interface{}, flag ParseFlag) error {\n\tif strings.HasSuffix(strings.ToLower(path), \"_test.go\") || filepath.Ext(path) != \".go\" {\n\t\treturn nil\n\t}\n\n\treturn parser.packages.ParseFile(packageDir, path, src, flag)\n}\n\nfunc (parser *Parser) checkOperationIDUniqueness() error {\n\t// operationsIds contains all operationId annotations to check it's unique\n\toperationsIds := make(map[string]string)\n\n\tfor path, item := range parser.swagger.Paths.Paths {\n\t\tvar method, id string\n\n\t\tfor method = range allMethod {\n\t\t\top := refRouteMethodOp(&item, method)\n\t\t\tif *op != nil {\n\t\t\t\tid = (**op).ID\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif id == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tcurrent := fmt.Sprintf(\"%s %s\", method, path)\n\n\t\tprevious, ok := operationsIds[id]\n\t\tif ok {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"duplicated @id annotation '%s' found in '%s', previously declared in: '%s'\",\n\t\t\t\tid, current, previous)\n\t\t}\n\n\t\toperationsIds[id] = current\n\t}\n\n\treturn nil\n}\n\n// Skip returns filepath.SkipDir error if match vendor and hidden folder.\nfunc (parser *Parser) Skip(path string, f os.FileInfo) error {\n\treturn walkWith(parser.excludes, parser.ParseVendor)(path, f)\n}\n\nfunc walkWith(excludes map[string]struct{}, parseVendor bool) func(path string, fileInfo os.FileInfo) error {\n\treturn func(path string, f os.FileInfo) error {\n\t\tif f.IsDir() {\n\t\t\tif !parseVendor && f.Name() == \"vendor\" || // ignore \"vendor\"\n\t\t\t\tf.Name() == \"docs\" || // exclude docs\n\t\t\t\tlen(f.Name()) > 1 && f.Name()[0] == '.' && f.Name() != \"..\" { // exclude all hidden folder\n\t\t\t\treturn filepath.SkipDir\n\t\t\t}\n\n\t\t\tif excludes != nil {\n\t\t\t\tif _, ok := excludes[path]; ok {\n\t\t\t\t\treturn filepath.SkipDir\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n}\n\n// GetSwagger returns *spec.Swagger which is the root document object for the API specification.\nfunc (parser *Parser) GetSwagger() *spec.Swagger {\n\treturn parser.swagger\n}\n\n// addTestType just for tests.\nfunc (parser *Parser) addTestType(typename string) {\n\ttypeDef := &TypeSpecDef{}\n\tparser.packages.uniqueDefinitions[typename] = typeDef\n\tparser.parsedSchemas[typeDef] = &Schema{\n\t\tPkgPath: \"\",\n\t\tName:    typename,\n\t\tSchema:  PrimitiveSchema(OBJECT),\n\t}\n}\n"
        },
        {
          "name": "parser_test.go",
          "type": "blob",
          "size": 116.0693359375,
          "content": "package swag\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"go/ast\"\n\tgoparser \"go/parser\"\n\t\"go/token\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/go-openapi/spec\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nconst defaultParseDepth = 100\n\nconst mainAPIFile = \"main.go\"\n\nfunc TestNew(t *testing.T) {\n\tt.Run(\"SetMarkdownFileDirectory\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\texpected := \"docs/markdown\"\n\t\tp := New(SetMarkdownFileDirectory(expected))\n\t\tassert.Equal(t, expected, p.markdownFileDir)\n\t})\n\n\tt.Run(\"SetCodeExamplesDirectory\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\texpected := \"docs/examples\"\n\t\tp := New(SetCodeExamplesDirectory(expected))\n\t\tassert.Equal(t, expected, p.codeExampleFilesDir)\n\t})\n\n\tt.Run(\"SetStrict\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tp := New()\n\t\tassert.Equal(t, false, p.Strict)\n\n\t\tp = New(SetStrict(true))\n\t\tassert.Equal(t, true, p.Strict)\n\t})\n\n\tt.Run(\"SetDebugger\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tlogger := log.New(&bytes.Buffer{}, \"\", log.LstdFlags)\n\n\t\tp := New(SetDebugger(logger))\n\t\tassert.Equal(t, logger, p.debug)\n\t})\n\n\tt.Run(\"SetFieldParserFactory\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tp := New(SetFieldParserFactory(nil))\n\t\tassert.Nil(t, p.fieldParserFactory)\n\t})\n}\n\nfunc TestSetOverrides(t *testing.T) {\n\tt.Parallel()\n\n\toverrides := map[string]string{\n\t\t\"foo\": \"bar\",\n\t}\n\n\tp := New(SetOverrides(overrides))\n\tassert.Equal(t, overrides, p.Overrides)\n}\n\nfunc TestOverrides_getTypeSchema(t *testing.T) {\n\tt.Parallel()\n\n\toverrides := map[string]string{\n\t\t\"sql.NullString\": \"string\",\n\t}\n\n\tp := New(SetOverrides(overrides))\n\n\tt.Run(\"Override sql.NullString by string\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ts, err := p.getTypeSchema(\"sql.NullString\", nil, false)\n\t\tif assert.NoError(t, err) {\n\t\t\tassert.Truef(t, s.Type.Contains(\"string\"), \"type sql.NullString should be overridden by string\")\n\t\t}\n\t})\n\n\tt.Run(\"Missing Override for sql.NullInt64\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\t_, err := p.getTypeSchema(\"sql.NullInt64\", nil, false)\n\t\tif assert.Error(t, err) {\n\t\t\tassert.Equal(t, \"cannot find type definition: sql.NullInt64\", err.Error())\n\t\t}\n\t})\n}\n\nfunc TestParser_ParseDefinition(t *testing.T) {\n\tp := New()\n\n\t// Parsing existing type\n\tdefinition := &TypeSpecDef{\n\t\tPkgPath: \"github.com/swagger/swag\",\n\t\tFile: &ast.File{\n\t\t\tName: &ast.Ident{\n\t\t\t\tName: \"swag\",\n\t\t\t},\n\t\t},\n\t\tTypeSpec: &ast.TypeSpec{\n\t\t\tName: &ast.Ident{\n\t\t\t\tName: \"Test\",\n\t\t\t},\n\t\t},\n\t}\n\n\texpected := &Schema{}\n\tp.parsedSchemas[definition] = expected\n\n\tschema, err := p.ParseDefinition(definition)\n\tassert.NoError(t, err)\n\tassert.Equal(t, expected, schema)\n\n\t// Parsing *ast.FuncType\n\tdefinition = &TypeSpecDef{\n\t\tPkgPath: \"github.com/swagger/swag/model\",\n\t\tFile: &ast.File{\n\t\t\tName: &ast.Ident{\n\t\t\t\tName: \"model\",\n\t\t\t},\n\t\t},\n\t\tTypeSpec: &ast.TypeSpec{\n\t\t\tName: &ast.Ident{\n\t\t\t\tName: \"Test\",\n\t\t\t},\n\t\t\tType: &ast.FuncType{},\n\t\t},\n\t}\n\t_, err = p.ParseDefinition(definition)\n\tassert.Error(t, err)\n\n\t// Parsing *ast.FuncType with parent spec\n\tdefinition = &TypeSpecDef{\n\t\tPkgPath: \"github.com/swagger/swag/model\",\n\t\tFile: &ast.File{\n\t\t\tName: &ast.Ident{\n\t\t\t\tName: \"model\",\n\t\t\t},\n\t\t},\n\t\tTypeSpec: &ast.TypeSpec{\n\t\t\tName: &ast.Ident{\n\t\t\t\tName: \"Test\",\n\t\t\t},\n\t\t\tType: &ast.FuncType{},\n\t\t},\n\t\tParentSpec: &ast.FuncDecl{\n\t\t\tName: ast.NewIdent(\"TestFuncDecl\"),\n\t\t},\n\t}\n\t_, err = p.ParseDefinition(definition)\n\tassert.Error(t, err)\n\tassert.Equal(t, \"model.TestFuncDecl.Test\", definition.TypeName())\n}\n\nfunc TestParser_ParseGeneralApiInfo(t *testing.T) {\n\tt.Parallel()\n\n\texpected := `{\n    \"schemes\": [\n        \"http\",\n        \"https\"\n    ],\n    \"swagger\": \"2.0\",\n    \"info\": {\n        \"description\": \"This is a sample server Petstore server.\\nIt has a lot of beautiful features.\",\n        \"title\": \"Swagger Example API\",\n        \"termsOfService\": \"http://swagger.io/terms/\",\n        \"contact\": {\n            \"name\": \"API Support\",\n            \"url\": \"http://www.swagger.io/support\",\n            \"email\": \"support@swagger.io\"\n        },\n        \"license\": {\n            \"name\": \"Apache 2.0\",\n            \"url\": \"http://www.apache.org/licenses/LICENSE-2.0.html\"\n        },\n        \"version\": \"1.0\",\n        \"x-logo\": {\n            \"altText\": \"Petstore logo\",\n            \"backgroundColor\": \"#FFFFFF\",\n            \"url\": \"https://redocly.github.io/redoc/petstore-logo.png\"\n        }\n    },\n    \"host\": \"petstore.swagger.io\",\n    \"basePath\": \"/v2\",\n    \"paths\": {},\n    \"securityDefinitions\": {\n        \"ApiKeyAuth\": {\n            \"description\": \"some description\",\n            \"type\": \"apiKey\",\n            \"name\": \"Authorization\",\n            \"in\": \"header\"\n        },\n        \"BasicAuth\": {\n            \"type\": \"basic\"\n        },\n        \"OAuth2AccessCode\": {\n            \"type\": \"oauth2\",\n            \"flow\": \"accessCode\",\n            \"authorizationUrl\": \"https://example.com/oauth/authorize\",\n            \"tokenUrl\": \"https://example.com/oauth/token\",\n            \"scopes\": {\n                \"admin\": \"Grants read and write access to administrative information\"\n            },\n            \"x-tokenname\": \"id_token\"\n        },\n        \"OAuth2Application\": {\n            \"type\": \"oauth2\",\n            \"flow\": \"application\",\n            \"tokenUrl\": \"https://example.com/oauth/token\",\n            \"scopes\": {\n                \"admin\": \"Grants read and write access to administrative information\",\n                \"write\": \"Grants write access\"\n            }\n        },\n        \"OAuth2Implicit\": {\n            \"type\": \"oauth2\",\n            \"flow\": \"implicit\",\n            \"authorizationUrl\": \"https://example.com/oauth/authorize\",\n            \"scopes\": {\n                \"admin\": \"Grants read and write access to administrative information\",\n                \"write\": \"Grants write access\"\n            },\n            \"x-google-audiences\": \"some_audience.google.com\"\n        },\n        \"OAuth2Password\": {\n            \"type\": \"oauth2\",\n            \"flow\": \"password\",\n            \"tokenUrl\": \"https://example.com/oauth/token\",\n            \"scopes\": {\n                \"admin\": \"Grants read and write access to administrative information\",\n                \"read\": \"Grants read access\",\n                \"write\": \"Grants write access\"\n            }\n        }\n    },\n    \"externalDocs\": {\n        \"description\": \"OpenAPI\",\n        \"url\": \"https://swagger.io/resources/open-api\"\n    },\n    \"x-google-endpoints\": [\n        {\n            \"allowCors\": true,\n            \"name\": \"name.endpoints.environment.cloud.goog\"\n        }\n    ],\n    \"x-google-marks\": \"marks values\"\n}`\n\tgopath := os.Getenv(\"GOPATH\")\n\tassert.NotNil(t, gopath)\n\n\tp := New()\n\n\terr := p.ParseGeneralAPIInfo(\"testdata/main.go\")\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParser_ParseGeneralApiInfoTemplated(t *testing.T) {\n\tt.Parallel()\n\n\texpected := `{\n    \"swagger\": \"2.0\",\n    \"info\": {\n        \"termsOfService\": \"http://swagger.io/terms/\",\n        \"contact\": {\n            \"name\": \"API Support\",\n            \"url\": \"http://www.swagger.io/support\",\n            \"email\": \"support@swagger.io\"\n        },\n        \"license\": {\n            \"name\": \"Apache 2.0\",\n            \"url\": \"http://www.apache.org/licenses/LICENSE-2.0.html\"\n        }\n    },\n    \"paths\": {},\n    \"securityDefinitions\": {\n        \"ApiKeyAuth\": {\n            \"type\": \"apiKey\",\n            \"name\": \"Authorization\",\n            \"in\": \"header\"\n        },\n        \"BasicAuth\": {\n            \"type\": \"basic\"\n        },\n        \"OAuth2AccessCode\": {\n            \"type\": \"oauth2\",\n            \"flow\": \"accessCode\",\n            \"authorizationUrl\": \"https://example.com/oauth/authorize\",\n            \"tokenUrl\": \"https://example.com/oauth/token\",\n            \"scopes\": {\n                \"admin\": \"Grants read and write access to administrative information\"\n            }\n        },\n        \"OAuth2Application\": {\n            \"type\": \"oauth2\",\n            \"flow\": \"application\",\n            \"tokenUrl\": \"https://example.com/oauth/token\",\n            \"scopes\": {\n                \"admin\": \"Grants read and write access to administrative information\",\n                \"write\": \"Grants write access\"\n            }\n        },\n        \"OAuth2Implicit\": {\n            \"type\": \"oauth2\",\n            \"flow\": \"implicit\",\n            \"authorizationUrl\": \"https://example.com/oauth/authorize\",\n            \"scopes\": {\n                \"admin\": \"Grants read and write access to administrative information\",\n                \"write\": \"Grants write access\"\n            }\n        },\n        \"OAuth2Password\": {\n            \"type\": \"oauth2\",\n            \"flow\": \"password\",\n            \"tokenUrl\": \"https://example.com/oauth/token\",\n            \"scopes\": {\n                \"admin\": \"Grants read and write access to administrative information\",\n                \"read\": \"Grants read access\",\n                \"write\": \"Grants write access\"\n            }\n        }\n    },\n    \"externalDocs\": {\n        \"description\": \"OpenAPI\",\n        \"url\": \"https://swagger.io/resources/open-api\"\n    },\n    \"x-google-endpoints\": [\n        {\n            \"allowCors\": true,\n            \"name\": \"name.endpoints.environment.cloud.goog\"\n        }\n    ],\n    \"x-google-marks\": \"marks values\"\n}`\n\tgopath := os.Getenv(\"GOPATH\")\n\tassert.NotNil(t, gopath)\n\n\tp := New()\n\n\terr := p.ParseGeneralAPIInfo(\"testdata/templated.go\")\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParser_ParseGeneralApiInfoExtensions(t *testing.T) {\n\t// should return an error because extension value is not a valid json\n\tt.Run(\"Test invalid extension value\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\texpected := \"annotation @x-google-endpoints need a valid json value\"\n\t\tgopath := os.Getenv(\"GOPATH\")\n\t\tassert.NotNil(t, gopath)\n\n\t\tp := New()\n\n\t\terr := p.ParseGeneralAPIInfo(\"testdata/extensionsFail1.go\")\n\t\tif assert.Error(t, err) {\n\t\t\tassert.Equal(t, expected, err.Error())\n\t\t}\n\t})\n\n\t// should return an error because extension don't have a value\n\tt.Run(\"Test missing extension value\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\texpected := \"annotation @x-google-endpoints need a value\"\n\t\tgopath := os.Getenv(\"GOPATH\")\n\t\tassert.NotNil(t, gopath)\n\n\t\tp := New()\n\n\t\terr := p.ParseGeneralAPIInfo(\"testdata/extensionsFail2.go\")\n\t\tif assert.Error(t, err) {\n\t\t\tassert.Equal(t, expected, err.Error())\n\t\t}\n\t})\n}\n\nfunc TestParser_ParseGeneralApiInfoWithOpsInSameFile(t *testing.T) {\n\tt.Parallel()\n\n\texpected := `{\n    \"swagger\": \"2.0\",\n    \"info\": {\n        \"description\": \"This is a sample server Petstore server.\\nIt has a lot of beautiful features.\",\n        \"title\": \"Swagger Example API\",\n        \"termsOfService\": \"http://swagger.io/terms/\",\n        \"contact\": {},\n        \"version\": \"1.0\"\n    },\n    \"paths\": {}\n}`\n\n\tgopath := os.Getenv(\"GOPATH\")\n\tassert.NotNil(t, gopath)\n\n\tp := New()\n\n\terr := p.ParseGeneralAPIInfo(\"testdata/single_file_api/main.go\")\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParser_ParseGeneralAPIInfoMarkdown(t *testing.T) {\n\tt.Parallel()\n\n\tp := New(SetMarkdownFileDirectory(\"testdata\"))\n\tmainAPIFile := \"testdata/markdown.go\"\n\terr := p.ParseGeneralAPIInfo(mainAPIFile)\n\tassert.NoError(t, err)\n\n\texpected := `{\n    \"swagger\": \"2.0\",\n    \"info\": {\n        \"description\": \"Swagger Example API Markdown Description\",\n        \"title\": \"Swagger Example API\",\n        \"termsOfService\": \"http://swagger.io/terms/\",\n        \"contact\": {},\n        \"version\": \"1.0\"\n    },\n    \"paths\": {},\n    \"tags\": [\n        {\n            \"description\": \"Users Tag Markdown Description\",\n            \"name\": \"users\"\n        }\n    ]\n}`\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.Equal(t, expected, string(b))\n\n\tp = New()\n\n\terr = p.ParseGeneralAPIInfo(mainAPIFile)\n\tassert.Error(t, err)\n}\n\nfunc TestParser_ParseGeneralApiInfoFailed(t *testing.T) {\n\tt.Parallel()\n\n\tgopath := os.Getenv(\"GOPATH\")\n\tassert.NotNil(t, gopath)\n\tp := New()\n\tassert.Error(t, p.ParseGeneralAPIInfo(\"testdata/noexist.go\"))\n}\n\nfunc TestParser_ParseAcceptComment(t *testing.T) {\n\tt.Parallel()\n\n\texpected := []string{\n\t\t\"application/json\",\n\t\t\"text/xml\",\n\t\t\"text/plain\",\n\t\t\"text/html\",\n\t\t\"multipart/form-data\",\n\t\t\"application/x-www-form-urlencoded\",\n\t\t\"application/vnd.api+json\",\n\t\t\"application/x-json-stream\",\n\t\t\"application/octet-stream\",\n\t\t\"image/png\",\n\t\t\"image/jpeg\",\n\t\t\"image/gif\",\n\t\t\"application/xhtml+xml\",\n\t\t\"application/health+json\",\n\t}\n\n\tcomment := `@Accept json,xml,plain,html,mpfd,x-www-form-urlencoded,json-api,json-stream,octet-stream,png,jpeg,gif,application/xhtml+xml,application/health+json`\n\n\tparser := New()\n\tassert.NoError(t, parseGeneralAPIInfo(parser, []string{comment}))\n\tassert.Equal(t, parser.swagger.Consumes, expected)\n\n\tassert.Error(t, parseGeneralAPIInfo(parser, []string{`@Accept cookies,candies`}))\n\n\tparser = New()\n\tassert.NoError(t, parser.ParseAcceptComment(comment[len(acceptAttr)+1:]))\n\tassert.Equal(t, parser.swagger.Consumes, expected)\n}\n\nfunc TestParser_ParseProduceComment(t *testing.T) {\n\tt.Parallel()\n\n\texpected := []string{\n\t\t\"application/json\",\n\t\t\"text/xml\",\n\t\t\"text/plain\",\n\t\t\"text/html\",\n\t\t\"multipart/form-data\",\n\t\t\"application/x-www-form-urlencoded\",\n\t\t\"application/vnd.api+json\",\n\t\t\"application/x-json-stream\",\n\t\t\"application/octet-stream\",\n\t\t\"image/png\",\n\t\t\"image/jpeg\",\n\t\t\"image/gif\",\n\t\t\"application/xhtml+xml\",\n\t\t\"application/health+json\",\n\t}\n\n\tcomment := `@Produce json,xml,plain,html,mpfd,x-www-form-urlencoded,json-api,json-stream,octet-stream,png,jpeg,gif,application/xhtml+xml,application/health+json`\n\n\tparser := New()\n\tassert.NoError(t, parseGeneralAPIInfo(parser, []string{comment}))\n\tassert.Equal(t, parser.swagger.Produces, expected)\n\n\tassert.Error(t, parseGeneralAPIInfo(parser, []string{`@Produce cookies,candies`}))\n\n\tparser = New()\n\tassert.NoError(t, parser.ParseProduceComment(comment[len(produceAttr)+1:]))\n\tassert.Equal(t, parser.swagger.Produces, expected)\n}\n\nfunc TestParser_ParseGeneralAPIInfoCollectionFormat(t *testing.T) {\n\tt.Parallel()\n\n\tparser := New()\n\tassert.NoError(t, parseGeneralAPIInfo(parser, []string{\n\t\t\"@query.collection.format csv\",\n\t}))\n\tassert.Equal(t, parser.collectionFormatInQuery, \"csv\")\n\n\tassert.NoError(t, parseGeneralAPIInfo(parser, []string{\n\t\t\"@query.collection.format tsv\",\n\t}))\n\tassert.Equal(t, parser.collectionFormatInQuery, \"tsv\")\n}\n\nfunc TestParser_ParseGeneralAPITagGroups(t *testing.T) {\n\tt.Parallel()\n\n\tparser := New()\n\tassert.NoError(t, parseGeneralAPIInfo(parser, []string{\n\t\t\"@x-tagGroups [{\\\"name\\\":\\\"General\\\",\\\"tags\\\":[\\\"lanes\\\",\\\"video-recommendations\\\"]}]\",\n\t}))\n\n\texpected := []interface{}{map[string]interface{}{\"name\": \"General\", \"tags\": []interface{}{\"lanes\", \"video-recommendations\"}}}\n\tassert.Equal(t, parser.swagger.Extensions[\"x-tagGroups\"], expected)\n}\n\nfunc TestParser_ParseGeneralAPITagDocs(t *testing.T) {\n\tt.Parallel()\n\n\tparser := New()\n\tassert.Error(t, parseGeneralAPIInfo(parser, []string{\n\t\t\"@tag.name Test\",\n\t\t\"@tag.docs.description Best example documentation\"}))\n\n\tparser = New()\n\terr := parseGeneralAPIInfo(parser, []string{\n\t\t\"@tag.name test\",\n\t\t\"@tag.description A test Tag\",\n\t\t\"@tag.docs.url https://example.com\",\n\t\t\"@tag.docs.description Best example documentation\",\n\t\t\"@tag.x-displayName Test group\"})\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(parser.GetSwagger().Tags, \"\", \"    \")\n\texpected := `[\n    {\n        \"description\": \"A test Tag\",\n        \"name\": \"test\",\n        \"externalDocs\": {\n            \"description\": \"Best example documentation\",\n            \"url\": \"https://example.com\"\n        },\n        \"x-displayName\": \"Test group\"\n    }\n]`\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParser_ParseGeneralAPITagDocsWithTagFilters(t *testing.T) {\n\tt.Parallel()\n\n\tfilterTags := []string{\"test1\", \"!test2\"}\n\n\tcomments := []string{\n\t\t\"@tag.name test1\",\n\t\t\"@tag.description A test1 Tag\",\n\t\t\"@tag.docs.url https://example1.com\",\n\t\t\"@tag.docs.description Best example1 documentation\",\n\t\t\"@tag.name test2\",\n\t\t\"@tag.description A test2 Tag\",\n\t\t\"@tag.docs.url https://example2.com\",\n\t\t\"@tag.docs.description Best example2 documentation\"}\n\n\texpected := `[\n    {\n        \"description\": \"A test1 Tag\",\n        \"name\": \"test1\",\n        \"externalDocs\": {\n            \"description\": \"Best example1 documentation\",\n            \"url\": \"https://example1.com\"\n        }\n    }\n]`\n\n\tfor _, tag := range filterTags {\n\t\tparser := New(SetTags(tag))\n\t\terr := parseGeneralAPIInfo(parser, comments)\n\t\tassert.NoError(t, err)\n\t\tb, _ := json.MarshalIndent(parser.GetSwagger().Tags, \"\", \"    \")\n\t\tassert.Equal(t, expected, string(b))\n\t}\n}\n\nfunc TestParser_ParseGeneralAPISecurity(t *testing.T) {\n\tt.Run(\"ApiKey\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tparser := New()\n\t\tassert.Error(t, parseGeneralAPIInfo(parser, []string{\n\t\t\t\"@securitydefinitions.apikey ApiKey\"}))\n\n\t\tassert.Error(t, parseGeneralAPIInfo(parser, []string{\n\t\t\t\"@securitydefinitions.apikey ApiKey\",\n\t\t\t\"@in header\"}))\n\t\tassert.Error(t, parseGeneralAPIInfo(parser, []string{\n\t\t\t\"@securitydefinitions.apikey ApiKey\",\n\t\t\t\"@name X-API-KEY\"}))\n\n\t\terr := parseGeneralAPIInfo(parser, []string{\n\t\t\t\"@securitydefinitions.apikey ApiKey\",\n\t\t\t\"@in header\",\n\t\t\t\"@name X-API-KEY\",\n\t\t\t\"@description some\",\n\t\t\t\"\",\n\t\t\t\"@securitydefinitions.oauth2.accessCode OAuth2AccessCode\",\n\t\t\t\"@tokenUrl https://example.com/oauth/token\",\n\t\t\t\"@authorizationUrl https://example.com/oauth/authorize\",\n\t\t\t\"@scope.admin foo\",\n\t\t})\n\t\tassert.NoError(t, err)\n\n\t\tb, _ := json.MarshalIndent(parser.GetSwagger().SecurityDefinitions, \"\", \"    \")\n\t\texpected := `{\n    \"ApiKey\": {\n        \"description\": \"some\",\n        \"type\": \"apiKey\",\n        \"name\": \"X-API-KEY\",\n        \"in\": \"header\"\n    },\n    \"OAuth2AccessCode\": {\n        \"type\": \"oauth2\",\n        \"flow\": \"accessCode\",\n        \"authorizationUrl\": \"https://example.com/oauth/authorize\",\n        \"tokenUrl\": \"https://example.com/oauth/token\",\n        \"scopes\": {\n            \"admin\": \"foo\"\n        }\n    }\n}`\n\t\tassert.Equal(t, expected, string(b))\n\t})\n\n\tt.Run(\"OAuth2Application\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tparser := New()\n\t\tassert.Error(t, parseGeneralAPIInfo(parser, []string{\n\t\t\t\"@securitydefinitions.oauth2.application OAuth2Application\"}))\n\n\t\terr := parseGeneralAPIInfo(parser, []string{\n\t\t\t\"@securitydefinitions.oauth2.application OAuth2Application\",\n\t\t\t\"@tokenUrl https://example.com/oauth/token\"})\n\t\tassert.NoError(t, err)\n\t\tb, _ := json.MarshalIndent(parser.GetSwagger().SecurityDefinitions, \"\", \"    \")\n\t\texpected := `{\n    \"OAuth2Application\": {\n        \"type\": \"oauth2\",\n        \"flow\": \"application\",\n        \"tokenUrl\": \"https://example.com/oauth/token\"\n    }\n}`\n\t\tassert.Equal(t, expected, string(b))\n\t})\n\n\tt.Run(\"OAuth2Implicit\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tparser := New()\n\t\tassert.Error(t, parseGeneralAPIInfo(parser, []string{\n\t\t\t\"@securitydefinitions.oauth2.implicit OAuth2Implicit\"}))\n\n\t\terr := parseGeneralAPIInfo(parser, []string{\n\t\t\t\"@securitydefinitions.oauth2.implicit OAuth2Implicit\",\n\t\t\t\"@authorizationurl https://example.com/oauth/authorize\"})\n\t\tassert.NoError(t, err)\n\t\tb, _ := json.MarshalIndent(parser.GetSwagger().SecurityDefinitions, \"\", \"    \")\n\t\texpected := `{\n    \"OAuth2Implicit\": {\n        \"type\": \"oauth2\",\n        \"flow\": \"implicit\",\n        \"authorizationUrl\": \"https://example.com/oauth/authorize\"\n    }\n}`\n\t\tassert.Equal(t, expected, string(b))\n\t})\n\n\tt.Run(\"OAuth2Password\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tparser := New()\n\t\tassert.Error(t, parseGeneralAPIInfo(parser, []string{\n\t\t\t\"@securitydefinitions.oauth2.password OAuth2Password\"}))\n\n\t\terr := parseGeneralAPIInfo(parser, []string{\n\t\t\t\"@securitydefinitions.oauth2.password OAuth2Password\",\n\t\t\t\"@tokenUrl https://example.com/oauth/token\"})\n\t\tassert.NoError(t, err)\n\t\tb, _ := json.MarshalIndent(parser.GetSwagger().SecurityDefinitions, \"\", \"    \")\n\t\texpected := `{\n    \"OAuth2Password\": {\n        \"type\": \"oauth2\",\n        \"flow\": \"password\",\n        \"tokenUrl\": \"https://example.com/oauth/token\"\n    }\n}`\n\t\tassert.Equal(t, expected, string(b))\n\t})\n\n\tt.Run(\"OAuth2AccessCode\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tparser := New()\n\t\tassert.Error(t, parseGeneralAPIInfo(parser, []string{\n\t\t\t\"@securitydefinitions.oauth2.accessCode OAuth2AccessCode\"}))\n\n\t\tassert.Error(t, parseGeneralAPIInfo(parser, []string{\n\t\t\t\"@securitydefinitions.oauth2.accessCode OAuth2AccessCode\",\n\t\t\t\"@tokenUrl https://example.com/oauth/token\"}))\n\n\t\tassert.Error(t, parseGeneralAPIInfo(parser, []string{\n\t\t\t\"@securitydefinitions.oauth2.accessCode OAuth2AccessCode\",\n\t\t\t\"@authorizationurl https://example.com/oauth/authorize\"}))\n\n\t\terr := parseGeneralAPIInfo(parser, []string{\n\t\t\t\"@securitydefinitions.oauth2.accessCode OAuth2AccessCode\",\n\t\t\t\"@tokenUrl https://example.com/oauth/token\",\n\t\t\t\"@authorizationurl https://example.com/oauth/authorize\"})\n\t\tassert.NoError(t, err)\n\t\tb, _ := json.MarshalIndent(parser.GetSwagger().SecurityDefinitions, \"\", \"    \")\n\t\texpected := `{\n    \"OAuth2AccessCode\": {\n        \"type\": \"oauth2\",\n        \"flow\": \"accessCode\",\n        \"authorizationUrl\": \"https://example.com/oauth/authorize\",\n        \"tokenUrl\": \"https://example.com/oauth/token\"\n    }\n}`\n\t\tassert.Equal(t, expected, string(b))\n\n\t\tassert.Error(t, parseGeneralAPIInfo(parser, []string{\n\t\t\t\"@securitydefinitions.oauth2.accessCode OAuth2AccessCode\",\n\t\t\t\"@tokenUrl https://example.com/oauth/token\",\n\t\t\t\"@authorizationurl https://example.com/oauth/authorize\",\n\t\t\t\"@scope.read,write Multiple scope\"}))\n\t})\n}\n\nfunc TestParser_RefWithOtherPropertiesIsWrappedInAllOf(t *testing.T) {\n\tt.Run(\"Readonly\", func(t *testing.T) {\n\t\tsrc := `\npackage main\n\ntype Teacher struct {\n\tName string\n} //@name Teacher\n\ntype Student struct {\n\tName string\n\tAge int ` + \"`readonly:\\\"true\\\"`\" + `\n\tTeacher Teacher ` + \"`readonly:\\\"true\\\"`\" + `\n\tOtherTeacher Teacher\n} //@name Student\n\n// @Success 200 {object} Student\n// @Router /test [get]\nfunc Fun()  {\n\n}\n`\n\t\texpected := `{\n    \"info\": {\n        \"contact\": {}\n    },\n    \"paths\": {\n        \"/test\": {\n            \"get\": {\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"OK\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/Student\"\n                        }\n                    }\n                }\n            }\n        }\n    },\n    \"definitions\": {\n        \"Student\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"age\": {\n                    \"type\": \"integer\",\n                    \"readOnly\": true\n                },\n                \"name\": {\n                    \"type\": \"string\"\n                },\n                \"otherTeacher\": {\n                    \"$ref\": \"#/definitions/Teacher\"\n                },\n                \"teacher\": {\n                    \"allOf\": [\n                        {\n                            \"$ref\": \"#/definitions/Teacher\"\n                        }\n                    ],\n                    \"readOnly\": true\n                }\n            }\n        },\n        \"Teacher\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": {\n                    \"type\": \"string\"\n                }\n            }\n        }\n    }\n}`\n\n\t\tp := New()\n\t\t_ = p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\n\t\t_, err := p.packages.ParseTypes()\n\t\tassert.NoError(t, err)\n\n\t\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\t\tassert.NoError(t, err)\n\n\t\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\t\tassert.Equal(t, expected, string(b))\n\t})\n}\n\nfunc TestGetAllGoFileInfo(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/pet\"\n\n\tp := New()\n\terr := p.getAllGoFileInfo(\"testdata\", searchDir)\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, 2, len(p.packages.files))\n}\n\nfunc TestParser_ParseType(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/simple/\"\n\n\tp := New()\n\terr := p.getAllGoFileInfo(\"testdata\", searchDir)\n\tassert.NoError(t, err)\n\n\t_, err = p.packages.ParseTypes()\n\n\tassert.NoError(t, err)\n\tassert.NotNil(t, p.packages.uniqueDefinitions[\"api.Pet3\"])\n\tassert.NotNil(t, p.packages.uniqueDefinitions[\"web.Pet\"])\n\tassert.NotNil(t, p.packages.uniqueDefinitions[\"web.Pet2\"])\n}\n\nfunc TestParseSimpleApi1(t *testing.T) {\n\tt.Parallel()\n\n\texpected, err := os.ReadFile(\"testdata/simple/expected.json\")\n\tassert.NoError(t, err)\n\tsearchDir := \"testdata/simple\"\n\tp := New()\n\tp.PropNamingStrategy = PascalCase\n\terr = p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"  \")\n\tassert.JSONEq(t, string(expected), string(b))\n}\n\nfunc TestParseInterfaceAndError(t *testing.T) {\n\tt.Parallel()\n\n\texpected, err := os.ReadFile(\"testdata/error/expected.json\")\n\tassert.NoError(t, err)\n\tsearchDir := \"testdata/error\"\n\tp := New()\n\terr = p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"  \")\n\tassert.JSONEq(t, string(expected), string(b))\n}\n\nfunc TestParseSimpleApi_ForSnakecase(t *testing.T) {\n\tt.Parallel()\n\n\texpected := `{\n    \"swagger\": \"2.0\",\n    \"info\": {\n        \"description\": \"This is a sample server Petstore server.\",\n        \"title\": \"Swagger Example API\",\n        \"termsOfService\": \"http://swagger.io/terms/\",\n        \"contact\": {\n            \"name\": \"API Support\",\n            \"url\": \"http://www.swagger.io/support\",\n            \"email\": \"support@swagger.io\"\n        },\n        \"license\": {\n            \"name\": \"Apache 2.0\",\n            \"url\": \"http://www.apache.org/licenses/LICENSE-2.0.html\"\n        },\n        \"version\": \"1.0\"\n    },\n    \"host\": \"petstore.swagger.io\",\n    \"basePath\": \"/v2\",\n    \"paths\": {\n        \"/file/upload\": {\n            \"post\": {\n                \"description\": \"Upload file\",\n                \"consumes\": [\n                    \"multipart/form-data\"\n                ],\n                \"produces\": [\n                    \"application/json\"\n                ],\n                \"summary\": \"Upload file\",\n                \"operationId\": \"file.upload\",\n                \"parameters\": [\n                    {\n                        \"type\": \"file\",\n                        \"description\": \"this is a test file\",\n                        \"name\": \"file\",\n                        \"in\": \"formData\",\n                        \"required\": true\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"ok\",\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    },\n                    \"400\": {\n                        \"description\": \"We need ID!!\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/web.APIError\"\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"Can not find ID\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/web.APIError\"\n                        }\n                    }\n                }\n            }\n        },\n        \"/testapi/get-string-by-int/{some_id}\": {\n            \"get\": {\n                \"description\": \"get string by ID\",\n                \"consumes\": [\n                    \"application/json\"\n                ],\n                \"produces\": [\n                    \"application/json\"\n                ],\n                \"summary\": \"Add a new pet to the store\",\n                \"operationId\": \"get-string-by-int\",\n                \"parameters\": [\n                    {\n                        \"type\": \"integer\",\n                        \"format\": \"int64\",\n                        \"description\": \"Some ID\",\n                        \"name\": \"some_id\",\n                        \"in\": \"path\",\n                        \"required\": true\n                    },\n                    {\n                        \"description\": \"Some ID\",\n                        \"name\": \"some_id\",\n                        \"in\": \"body\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/web.Pet\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"ok\",\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    },\n                    \"400\": {\n                        \"description\": \"We need ID!!\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/web.APIError\"\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"Can not find ID\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/web.APIError\"\n                        }\n                    }\n                }\n            }\n        },\n        \"/testapi/get-struct-array-by-string/{some_id}\": {\n            \"get\": {\n                \"security\": [\n                    {\n                        \"ApiKeyAuth\": []\n                    },\n                    {\n                        \"BasicAuth\": []\n                    },\n                    {\n                        \"OAuth2Application\": [\n                            \"write\"\n                        ]\n                    },\n                    {\n                        \"OAuth2Implicit\": [\n                            \"read\",\n                            \"admin\"\n                        ]\n                    },\n                    {\n                        \"OAuth2AccessCode\": [\n                            \"read\"\n                        ]\n                    },\n                    {\n                        \"OAuth2Password\": [\n                            \"admin\"\n                        ]\n                    }\n                ],\n                \"description\": \"get struct array by ID\",\n                \"consumes\": [\n                    \"application/json\"\n                ],\n                \"produces\": [\n                    \"application/json\"\n                ],\n                \"operationId\": \"get-struct-array-by-string\",\n                \"parameters\": [\n                    {\n                        \"type\": \"string\",\n                        \"description\": \"Some ID\",\n                        \"name\": \"some_id\",\n                        \"in\": \"path\",\n                        \"required\": true\n                    },\n                    {\n                        \"enum\": [\n                            1,\n                            2,\n                            3\n                        ],\n                        \"type\": \"integer\",\n                        \"description\": \"Category\",\n                        \"name\": \"category\",\n                        \"in\": \"query\",\n                        \"required\": true\n                    },\n                    {\n                        \"minimum\": 0,\n                        \"type\": \"integer\",\n                        \"default\": 0,\n                        \"description\": \"Offset\",\n                        \"name\": \"offset\",\n                        \"in\": \"query\",\n                        \"required\": true\n                    },\n                    {\n                        \"maximum\": 50,\n                        \"type\": \"integer\",\n                        \"default\": 10,\n                        \"description\": \"Limit\",\n                        \"name\": \"limit\",\n                        \"in\": \"query\",\n                        \"required\": true\n                    },\n                    {\n                        \"maxLength\": 50,\n                        \"minLength\": 1,\n                        \"type\": \"string\",\n                        \"default\": \"\\\"\\\"\",\n                        \"description\": \"q\",\n                        \"name\": \"q\",\n                        \"in\": \"query\",\n                        \"required\": true\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"ok\",\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    },\n                    \"400\": {\n                        \"description\": \"We need ID!!\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/web.APIError\"\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"Can not find ID\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/web.APIError\"\n                        }\n                    }\n                }\n            }\n        }\n    },\n    \"definitions\": {\n        \"web.APIError\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"created_at\": {\n                    \"type\": \"string\"\n                },\n                \"error_code\": {\n                    \"type\": \"integer\"\n                },\n                \"error_message\": {\n                    \"type\": \"string\"\n                }\n            }\n        },\n        \"web.Pet\": {\n            \"type\": \"object\",\n            \"required\": [\n                \"price\"\n            ],\n            \"properties\": {\n                \"birthday\": {\n                    \"type\": \"integer\"\n                },\n                \"category\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"id\": {\n                            \"type\": \"integer\",\n                            \"example\": 1\n                        },\n                        \"name\": {\n                            \"type\": \"string\",\n                            \"example\": \"category_name\"\n                        },\n                        \"photo_urls\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"type\": \"string\",\n                                \"format\": \"url\"\n                            },\n                            \"example\": [\n                                \"http://test/image/1.jpg\",\n                                \"http://test/image/2.jpg\"\n                            ]\n                        },\n                        \"small_category\": {\n                            \"type\": \"object\",\n                            \"required\": [\n                                \"name\"\n                            ],\n                            \"properties\": {\n                                \"id\": {\n                                    \"type\": \"integer\",\n                                    \"example\": 1\n                                },\n                                \"name\": {\n                                    \"type\": \"string\",\n                                    \"example\": \"detail_category_name\"\n                                },\n                                \"photo_urls\": {\n                                    \"type\": \"array\",\n                                    \"items\": {\n                                        \"type\": \"string\"\n                                    },\n                                    \"example\": [\n                                        \"http://test/image/1.jpg\",\n                                        \"http://test/image/2.jpg\"\n                                    ]\n                                }\n                            }\n                        }\n                    }\n                },\n                \"coeffs\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"type\": \"number\"\n                    }\n                },\n                \"custom_string\": {\n                    \"type\": \"string\"\n                },\n                \"custom_string_arr\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"type\": \"string\"\n                    }\n                },\n                \"data\": {},\n                \"decimal\": {\n                    \"type\": \"number\"\n                },\n                \"id\": {\n                    \"type\": \"integer\",\n                    \"format\": \"int64\",\n                    \"example\": 1\n                },\n                \"is_alive\": {\n                    \"type\": \"boolean\",\n                    \"example\": true\n                },\n                \"name\": {\n                    \"type\": \"string\",\n                    \"example\": \"poti\"\n                },\n                \"null_int\": {\n                    \"type\": \"integer\"\n                },\n                \"pets\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"$ref\": \"#/definitions/web.Pet2\"\n                    }\n                },\n                \"pets2\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"$ref\": \"#/definitions/web.Pet2\"\n                    }\n                },\n                \"photo_urls\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"type\": \"string\"\n                    },\n                    \"example\": [\n                        \"http://test/image/1.jpg\",\n                        \"http://test/image/2.jpg\"\n                    ]\n                },\n                \"price\": {\n                    \"type\": \"number\",\n                    \"maximum\": 130,\n                    \"minimum\": 0,\n                    \"multipleOf\": 0.01,\n                    \"example\": 3.25\n                },\n                \"status\": {\n                    \"type\": \"string\"\n                },\n                \"tags\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"$ref\": \"#/definitions/web.Tag\"\n                    }\n                },\n                \"uuid\": {\n                    \"type\": \"string\"\n                }\n            }\n        },\n        \"web.Pet2\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"deleted_at\": {\n                    \"type\": \"string\"\n                },\n                \"id\": {\n                    \"type\": \"integer\"\n                },\n                \"middle_name\": {\n                    \"type\": \"string\"\n                }\n            }\n        },\n        \"web.RevValue\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"data\": {\n                    \"type\": \"integer\"\n                },\n                \"err\": {\n                    \"type\": \"integer\",\n                    \"format\": \"int32\"\n                },\n                \"status\": {\n                    \"type\": \"boolean\"\n                }\n            }\n        },\n        \"web.Tag\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"id\": {\n                    \"type\": \"integer\",\n                    \"format\": \"int64\"\n                },\n                \"name\": {\n                    \"type\": \"string\"\n                },\n                \"pets\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"$ref\": \"#/definitions/web.Pet\"\n                    }\n                }\n            }\n        }\n    },\n    \"securityDefinitions\": {\n        \"ApiKeyAuth\": {\n            \"type\": \"apiKey\",\n            \"name\": \"Authorization\",\n            \"in\": \"header\"\n        },\n        \"BasicAuth\": {\n            \"type\": \"basic\"\n        },\n        \"OAuth2AccessCode\": {\n            \"type\": \"oauth2\",\n            \"flow\": \"accessCode\",\n            \"authorizationUrl\": \"https://example.com/oauth/authorize\",\n            \"tokenUrl\": \"https://example.com/oauth/token\",\n            \"scopes\": {\n                \"admin\": \"Grants read and write access to administrative information\"\n            }\n        },\n        \"OAuth2Application\": {\n            \"type\": \"oauth2\",\n            \"flow\": \"application\",\n            \"tokenUrl\": \"https://example.com/oauth/token\",\n            \"scopes\": {\n                \"admin\": \"Grants read and write access to administrative information\",\n                \"write\": \"Grants write access\"\n            }\n        },\n        \"OAuth2Implicit\": {\n            \"type\": \"oauth2\",\n            \"flow\": \"implicit\",\n            \"authorizationUrl\": \"https://example.com/oauth/authorize\",\n            \"scopes\": {\n                \"admin\": \"Grants read and write access to administrative information\",\n                \"write\": \"Grants write access\"\n            }\n        },\n        \"OAuth2Password\": {\n            \"type\": \"oauth2\",\n            \"flow\": \"password\",\n            \"tokenUrl\": \"https://example.com/oauth/token\",\n            \"scopes\": {\n                \"admin\": \"Grants read and write access to administrative information\",\n                \"read\": \"Grants read access\",\n                \"write\": \"Grants write access\"\n            }\n        }\n    }\n}`\n\tsearchDir := \"testdata/simple2\"\n\tp := New()\n\tp.PropNamingStrategy = SnakeCase\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseSimpleApi_ForLowerCamelcase(t *testing.T) {\n\tt.Parallel()\n\n\texpected := `{\n    \"swagger\": \"2.0\",\n    \"info\": {\n        \"description\": \"This is a sample server Petstore server.\",\n        \"title\": \"Swagger Example API\",\n        \"termsOfService\": \"http://swagger.io/terms/\",\n        \"contact\": {\n            \"name\": \"API Support\",\n            \"url\": \"http://www.swagger.io/support\",\n            \"email\": \"support@swagger.io\"\n        },\n        \"license\": {\n            \"name\": \"Apache 2.0\",\n            \"url\": \"http://www.apache.org/licenses/LICENSE-2.0.html\"\n        },\n        \"version\": \"1.0\"\n    },\n    \"host\": \"petstore.swagger.io\",\n    \"basePath\": \"/v2\",\n    \"paths\": {\n        \"/file/upload\": {\n            \"post\": {\n                \"description\": \"Upload file\",\n                \"consumes\": [\n                    \"multipart/form-data\"\n                ],\n                \"produces\": [\n                    \"application/json\"\n                ],\n                \"summary\": \"Upload file\",\n                \"operationId\": \"file.upload\",\n                \"parameters\": [\n                    {\n                        \"type\": \"file\",\n                        \"description\": \"this is a test file\",\n                        \"name\": \"file\",\n                        \"in\": \"formData\",\n                        \"required\": true\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"ok\",\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    },\n                    \"400\": {\n                        \"description\": \"We need ID!!\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/web.APIError\"\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"Can not find ID\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/web.APIError\"\n                        }\n                    }\n                }\n            }\n        },\n        \"/testapi/get-string-by-int/{some_id}\": {\n            \"get\": {\n                \"description\": \"get string by ID\",\n                \"consumes\": [\n                    \"application/json\"\n                ],\n                \"produces\": [\n                    \"application/json\"\n                ],\n                \"summary\": \"Add a new pet to the store\",\n                \"operationId\": \"get-string-by-int\",\n                \"parameters\": [\n                    {\n                        \"type\": \"integer\",\n                        \"format\": \"int64\",\n                        \"description\": \"Some ID\",\n                        \"name\": \"some_id\",\n                        \"in\": \"path\",\n                        \"required\": true\n                    },\n                    {\n                        \"description\": \"Some ID\",\n                        \"name\": \"some_id\",\n                        \"in\": \"body\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/web.Pet\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"ok\",\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    },\n                    \"400\": {\n                        \"description\": \"We need ID!!\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/web.APIError\"\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"Can not find ID\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/web.APIError\"\n                        }\n                    }\n                }\n            }\n        },\n        \"/testapi/get-struct-array-by-string/{some_id}\": {\n            \"get\": {\n                \"security\": [\n                    {\n                        \"ApiKeyAuth\": []\n                    },\n                    {\n                        \"BasicAuth\": []\n                    },\n                    {\n                        \"OAuth2Application\": [\n                            \"write\"\n                        ]\n                    },\n                    {\n                        \"OAuth2Implicit\": [\n                            \"read\",\n                            \"admin\"\n                        ]\n                    },\n                    {\n                        \"OAuth2AccessCode\": [\n                            \"read\"\n                        ]\n                    },\n                    {\n                        \"OAuth2Password\": [\n                            \"admin\"\n                        ]\n                    }\n                ],\n                \"description\": \"get struct array by ID\",\n                \"consumes\": [\n                    \"application/json\"\n                ],\n                \"produces\": [\n                    \"application/json\"\n                ],\n                \"operationId\": \"get-struct-array-by-string\",\n                \"parameters\": [\n                    {\n                        \"type\": \"string\",\n                        \"description\": \"Some ID\",\n                        \"name\": \"some_id\",\n                        \"in\": \"path\",\n                        \"required\": true\n                    },\n                    {\n                        \"enum\": [\n                            1,\n                            2,\n                            3\n                        ],\n                        \"type\": \"integer\",\n                        \"description\": \"Category\",\n                        \"name\": \"category\",\n                        \"in\": \"query\",\n                        \"required\": true\n                    },\n                    {\n                        \"minimum\": 0,\n                        \"type\": \"integer\",\n                        \"default\": 0,\n                        \"description\": \"Offset\",\n                        \"name\": \"offset\",\n                        \"in\": \"query\",\n                        \"required\": true\n                    },\n                    {\n                        \"maximum\": 50,\n                        \"type\": \"integer\",\n                        \"default\": 10,\n                        \"description\": \"Limit\",\n                        \"name\": \"limit\",\n                        \"in\": \"query\",\n                        \"required\": true\n                    },\n                    {\n                        \"maxLength\": 50,\n                        \"minLength\": 1,\n                        \"type\": \"string\",\n                        \"default\": \"\\\"\\\"\",\n                        \"description\": \"q\",\n                        \"name\": \"q\",\n                        \"in\": \"query\",\n                        \"required\": true\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"ok\",\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    },\n                    \"400\": {\n                        \"description\": \"We need ID!!\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/web.APIError\"\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"Can not find ID\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/web.APIError\"\n                        }\n                    }\n                }\n            }\n        }\n    },\n    \"definitions\": {\n        \"web.APIError\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"createdAt\": {\n                    \"type\": \"string\"\n                },\n                \"errorCode\": {\n                    \"type\": \"integer\"\n                },\n                \"errorMessage\": {\n                    \"type\": \"string\"\n                }\n            }\n        },\n        \"web.Pet\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"category\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"id\": {\n                            \"type\": \"integer\",\n                            \"example\": 1\n                        },\n                        \"name\": {\n                            \"type\": \"string\",\n                            \"example\": \"category_name\"\n                        },\n                        \"photoURLs\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"type\": \"string\",\n                                \"format\": \"url\"\n                            },\n                            \"example\": [\n                                \"http://test/image/1.jpg\",\n                                \"http://test/image/2.jpg\"\n                            ]\n                        },\n                        \"smallCategory\": {\n                            \"type\": \"object\",\n                            \"properties\": {\n                                \"id\": {\n                                    \"type\": \"integer\",\n                                    \"example\": 1\n                                },\n                                \"name\": {\n                                    \"type\": \"string\",\n                                    \"example\": \"detail_category_name\"\n                                },\n                                \"photoURLs\": {\n                                    \"type\": \"array\",\n                                    \"items\": {\n                                        \"type\": \"string\"\n                                    },\n                                    \"example\": [\n                                        \"http://test/image/1.jpg\",\n                                        \"http://test/image/2.jpg\"\n                                    ]\n                                }\n                            }\n                        }\n                    }\n                },\n                \"data\": {},\n                \"decimal\": {\n                    \"type\": \"number\"\n                },\n                \"id\": {\n                    \"type\": \"integer\",\n                    \"format\": \"int64\",\n                    \"example\": 1\n                },\n                \"isAlive\": {\n                    \"type\": \"boolean\",\n                    \"example\": true\n                },\n                \"name\": {\n                    \"type\": \"string\",\n                    \"example\": \"poti\"\n                },\n                \"pets\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"$ref\": \"#/definitions/web.Pet2\"\n                    }\n                },\n                \"pets2\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"$ref\": \"#/definitions/web.Pet2\"\n                    }\n                },\n                \"photoURLs\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"type\": \"string\"\n                    },\n                    \"example\": [\n                        \"http://test/image/1.jpg\",\n                        \"http://test/image/2.jpg\"\n                    ]\n                },\n                \"price\": {\n                    \"type\": \"number\",\n                    \"multipleOf\": 0.01,\n                    \"example\": 3.25\n                },\n                \"status\": {\n                    \"type\": \"string\"\n                },\n                \"tags\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"$ref\": \"#/definitions/web.Tag\"\n                    }\n                },\n                \"uuid\": {\n                    \"type\": \"string\"\n                }\n            }\n        },\n        \"web.Pet2\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"deletedAt\": {\n                    \"type\": \"string\"\n                },\n                \"id\": {\n                    \"type\": \"integer\"\n                },\n                \"middleName\": {\n                    \"type\": \"string\"\n                }\n            }\n        },\n        \"web.RevValue\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"data\": {\n                    \"type\": \"integer\"\n                },\n                \"err\": {\n                    \"type\": \"integer\",\n                    \"format\": \"int32\"\n                },\n                \"status\": {\n                    \"type\": \"boolean\"\n                }\n            }\n        },\n        \"web.Tag\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"id\": {\n                    \"type\": \"integer\",\n                    \"format\": \"int64\"\n                },\n                \"name\": {\n                    \"type\": \"string\"\n                },\n                \"pets\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"$ref\": \"#/definitions/web.Pet\"\n                    }\n                }\n            }\n        }\n    },\n    \"securityDefinitions\": {\n        \"ApiKeyAuth\": {\n            \"type\": \"apiKey\",\n            \"name\": \"Authorization\",\n            \"in\": \"header\"\n        },\n        \"BasicAuth\": {\n            \"type\": \"basic\"\n        },\n        \"OAuth2AccessCode\": {\n            \"type\": \"oauth2\",\n            \"flow\": \"accessCode\",\n            \"authorizationUrl\": \"https://example.com/oauth/authorize\",\n            \"tokenUrl\": \"https://example.com/oauth/token\",\n            \"scopes\": {\n                \"admin\": \"Grants read and write access to administrative information\"\n            }\n        },\n        \"OAuth2Application\": {\n            \"type\": \"oauth2\",\n            \"flow\": \"application\",\n            \"tokenUrl\": \"https://example.com/oauth/token\",\n            \"scopes\": {\n                \"admin\": \"Grants read and write access to administrative information\",\n                \"write\": \"Grants write access\"\n            }\n        },\n        \"OAuth2Implicit\": {\n            \"type\": \"oauth2\",\n            \"flow\": \"implicit\",\n            \"authorizationUrl\": \"https://example.com/oauth/authorize\",\n            \"scopes\": {\n                \"admin\": \"Grants read and write access to administrative information\",\n                \"write\": \"Grants write access\"\n            }\n        },\n        \"OAuth2Password\": {\n            \"type\": \"oauth2\",\n            \"flow\": \"password\",\n            \"tokenUrl\": \"https://example.com/oauth/token\",\n            \"scopes\": {\n                \"admin\": \"Grants read and write access to administrative information\",\n                \"read\": \"Grants read access\",\n                \"write\": \"Grants write access\"\n            }\n        }\n    }\n}`\n\tsearchDir := \"testdata/simple3\"\n\tp := New()\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseStructComment(t *testing.T) {\n\tt.Parallel()\n\n\texpected := `{\n    \"swagger\": \"2.0\",\n    \"info\": {\n        \"description\": \"This is a sample server Petstore server.\",\n        \"title\": \"Swagger Example API\",\n        \"contact\": {},\n        \"version\": \"1.0\"\n    },\n    \"host\": \"localhost:4000\",\n    \"basePath\": \"/api\",\n    \"paths\": {\n        \"/posts/{post_id}\": {\n            \"get\": {\n                \"description\": \"get string by ID\",\n                \"consumes\": [\n                    \"application/json\"\n                ],\n                \"produces\": [\n                    \"application/json\"\n                ],\n                \"summary\": \"Add a new pet to the store\",\n                \"parameters\": [\n                    {\n                        \"type\": \"integer\",\n                        \"format\": \"int64\",\n                        \"description\": \"Some ID\",\n                        \"name\": \"post_id\",\n                        \"in\": \"path\",\n                        \"required\": true\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"OK\",\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    },\n                    \"400\": {\n                        \"description\": \"We need ID!!\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/web.APIError\"\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"Can not find ID\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/web.APIError\"\n                        }\n                    }\n                }\n            }\n        }\n    },\n    \"definitions\": {\n        \"web.APIError\": {\n            \"description\": \"API error with information about it\",\n            \"type\": \"object\",\n            \"properties\": {\n                \"createdAt\": {\n                    \"description\": \"Error time\",\n                    \"type\": \"string\"\n                },\n                \"error\": {\n                    \"description\": \"Error an Api error\",\n                    \"type\": \"string\"\n                },\n                \"errorCtx\": {\n                    \"description\": \"Error ` + \"`\" + `context` + \"`\" + ` tick comment\",\n                    \"type\": \"string\"\n                },\n                \"errorNo\": {\n                    \"description\": \"Error ` + \"`\" + `number` + \"`\" + ` tick comment\",\n                    \"type\": \"integer\",\n                    \"format\": \"int64\"\n                }\n            }\n        }\n    }\n}`\n\tsearchDir := \"testdata/struct_comment\"\n\tp := New()\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseNonExportedJSONFields(t *testing.T) {\n\tt.Parallel()\n\n\texpected := `{\n    \"swagger\": \"2.0\",\n    \"info\": {\n        \"description\": \"This is a sample server.\",\n        \"title\": \"Swagger Example API\",\n        \"contact\": {},\n        \"version\": \"1.0\"\n    },\n    \"host\": \"localhost:4000\",\n    \"basePath\": \"/api\",\n    \"paths\": {\n        \"/so-something\": {\n            \"get\": {\n                \"description\": \"Does something, but internal (non-exported) fields inside a struct won't be marshaled into JSON\",\n                \"consumes\": [\n                    \"application/json\"\n                ],\n                \"produces\": [\n                    \"application/json\"\n                ],\n                \"summary\": \"Call DoSomething\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"OK\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/main.MyStruct\"\n                        }\n                    }\n                }\n            }\n        }\n    },\n    \"definitions\": {\n        \"main.MyStruct\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"data\": {\n                    \"description\": \"Post data\",\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"name\": {\n                            \"description\": \"Post tag\",\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"type\": \"string\"\n                            }\n                        }\n                    }\n                },\n                \"id\": {\n                    \"type\": \"integer\",\n                    \"format\": \"int64\",\n                    \"example\": 1\n                },\n                \"name\": {\n                    \"description\": \"Post name\",\n                    \"type\": \"string\",\n                    \"example\": \"poti\"\n                }\n            }\n        }\n    }\n}`\n\n\tsearchDir := \"testdata/non_exported_json_fields\"\n\tp := New()\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParsePetApi(t *testing.T) {\n\tt.Parallel()\n\n\texpected := `{\n    \"schemes\": [\n        \"http\",\n        \"https\"\n    ],\n    \"swagger\": \"2.0\",\n    \"info\": {\n        \"description\": \"This is a sample server Petstore server.  You can find out more about     Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).      For this sample, you can use the api key 'special-key' to test the authorization     filters.\",\n        \"title\": \"Swagger Petstore\",\n        \"termsOfService\": \"http://swagger.io/terms/\",\n        \"contact\": {\n            \"email\": \"apiteam@swagger.io\"\n        },\n        \"license\": {\n            \"name\": \"Apache 2.0\",\n            \"url\": \"http://www.apache.org/licenses/LICENSE-2.0.html\"\n        },\n        \"version\": \"1.0\"\n    },\n    \"host\": \"petstore.swagger.io\",\n    \"basePath\": \"/v2\",\n    \"paths\": {}\n}`\n\tsearchDir := \"testdata/pet\"\n\tp := New()\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseModelAsTypeAlias(t *testing.T) {\n\tt.Parallel()\n\n\texpected := `{\n    \"swagger\": \"2.0\",\n    \"info\": {\n        \"description\": \"This is a sample server Petstore server.\",\n        \"title\": \"Swagger Example API\",\n        \"termsOfService\": \"http://swagger.io/terms/\",\n        \"contact\": {\n            \"name\": \"API Support\",\n            \"url\": \"http://www.swagger.io/support\",\n            \"email\": \"support@swagger.io\"\n        },\n        \"license\": {\n            \"name\": \"Apache 2.0\",\n            \"url\": \"http://www.apache.org/licenses/LICENSE-2.0.html\"\n        },\n        \"version\": \"1.0\"\n    },\n    \"host\": \"petstore.swagger.io\",\n    \"basePath\": \"/v2\",\n    \"paths\": {\n        \"/testapi/time-as-time-container\": {\n            \"get\": {\n                \"description\": \"test container with time and time alias\",\n                \"consumes\": [\n                    \"application/json\"\n                ],\n                \"produces\": [\n                    \"application/json\"\n                ],\n                \"summary\": \"Get container with time and time alias\",\n                \"operationId\": \"time-as-time-container\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"ok\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/data.TimeContainer\"\n                        }\n                    }\n                }\n            }\n        }\n    },\n    \"definitions\": {\n        \"data.TimeContainer\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"created_at\": {\n                    \"type\": \"string\"\n                },\n                \"name\": {\n                    \"type\": \"string\"\n                },\n                \"timestamp\": {\n                    \"type\": \"string\"\n                }\n            }\n        }\n    }\n}`\n\tsearchDir := \"testdata/alias_type\"\n\tp := New()\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseComposition(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/composition\"\n\tp := New()\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\n\texpected, err := os.ReadFile(filepath.Join(searchDir, \"expected.json\"))\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\n\t// windows will fail: \\r\\n \\n\n\tassert.Equal(t, string(expected), string(b))\n}\n\nfunc TestParseImportAliases(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/alias_import\"\n\tp := New()\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\n\texpected, err := os.ReadFile(filepath.Join(searchDir, \"expected.json\"))\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\t// windows will fail: \\r\\n \\n\n\tassert.Equal(t, string(expected), string(b))\n}\n\nfunc TestParseTypeOverrides(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/global_override\"\n\tp := New(SetOverrides(map[string]string{\n\t\t\"github.com/swaggo/swag/testdata/global_override/types.Application\":  \"string\",\n\t\t\"github.com/swaggo/swag/testdata/global_override/types.Application2\": \"github.com/swaggo/swag/testdata/global_override/othertypes.Application\",\n\t\t\"github.com/swaggo/swag/testdata/global_override/types.ShouldSkip\":   \"\",\n\t}))\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\n\texpected, err := os.ReadFile(filepath.Join(searchDir, \"expected.json\"))\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\t//windows will fail: \\r\\n \\n\n\tassert.Equal(t, string(expected), string(b))\n}\n\nfunc TestGlobalSecurity(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/global_security\"\n\tp := New()\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\n\texpected, err := os.ReadFile(filepath.Join(searchDir, \"expected.json\"))\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"  \")\n\tassert.Equal(t, string(expected), string(b))\n}\n\nfunc TestParseNested(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/nested\"\n\tp := New(SetParseDependency(1))\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\n\texpected, err := os.ReadFile(filepath.Join(searchDir, \"expected.json\"))\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.Equal(t, string(expected), string(b))\n}\n\nfunc TestParseDuplicated(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/duplicated\"\n\tp := New(SetParseDependency(1))\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.Errorf(t, err, \"duplicated @id declarations successfully found\")\n}\n\nfunc TestParseDuplicatedOtherMethods(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/duplicated2\"\n\tp := New(SetParseDependency(1))\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.Errorf(t, err, \"duplicated @id declarations successfully found\")\n}\n\nfunc TestParseDuplicatedFunctionScoped(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/duplicated_function_scoped\"\n\tp := New(SetParseDependency(1))\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.Errorf(t, err, \"duplicated @id declarations successfully found\")\n}\n\nfunc TestParseConflictSchemaName(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/conflict_name\"\n\tp := New(SetParseDependency(1))\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\texpected, err := os.ReadFile(filepath.Join(searchDir, \"expected.json\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, string(expected), string(b))\n}\n\nfunc TestParseExternalModels(t *testing.T) {\n\tsearchDir := \"testdata/external_models/main\"\n\tmainAPIFile := \"main.go\"\n\tp := New(SetParseDependency(1))\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\t//ioutil.WriteFile(\"./testdata/external_models/main/expected.json\",b,0777)\n\texpected, err := os.ReadFile(filepath.Join(searchDir, \"expected.json\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, string(expected), string(b))\n}\n\nfunc TestParseGoList(t *testing.T) {\n\tmainAPIFile := \"main.go\"\n\tp := New(ParseUsingGoList(true), SetParseDependency(1))\n\tgo111moduleEnv := os.Getenv(\"GO111MODULE\")\n\n\tcases := []struct {\n\t\tname      string\n\t\tgomodule  bool\n\t\tsearchDir string\n\t\terr       error\n\t\trun       func(searchDir string) error\n\t}{\n\t\t{\n\t\t\tname:      \"disableGOMODULE\",\n\t\t\tgomodule:  false,\n\t\t\tsearchDir: \"testdata/golist_disablemodule\",\n\t\t\trun: func(searchDir string) error {\n\t\t\t\treturn p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:      \"enableGOMODULE\",\n\t\t\tgomodule:  true,\n\t\t\tsearchDir: \"testdata/golist\",\n\t\t\trun: func(searchDir string) error {\n\t\t\t\treturn p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:      \"invalid_main\",\n\t\t\tgomodule:  true,\n\t\t\tsearchDir: \"testdata/golist_invalid\",\n\t\t\terr:       errors.New(\"no such file or directory\"),\n\t\t\trun: func(searchDir string) error {\n\t\t\t\treturn p.ParseAPI(searchDir, \"invalid/main.go\", defaultParseDepth)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:      \"internal_invalid_pkg\",\n\t\t\tgomodule:  true,\n\t\t\tsearchDir: \"testdata/golist_invalid\",\n\t\t\terr:       errors.New(\"expected 'package', found This\"),\n\t\t\trun: func(searchDir string) error {\n\t\t\t\tmockErrGoFile := \"testdata/golist_invalid/err.go\"\n\t\t\t\tf, err := os.OpenFile(mockErrGoFile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tdefer f.Close()\n\t\t\t\t_, err = f.Write([]byte(`package invalid\n\nfunction a() {}`))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tdefer os.Remove(mockErrGoFile)\n\t\t\t\treturn p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:      \"invalid_pkg\",\n\t\t\tgomodule:  true,\n\t\t\tsearchDir: \"testdata/golist_invalid\",\n\t\t\terr:       errors.New(\"expected 'package', found This\"),\n\t\t\trun: func(searchDir string) error {\n\t\t\t\tmockErrGoFile := \"testdata/invalid_external_pkg/invalid/err.go\"\n\t\t\t\tf, err := os.OpenFile(mockErrGoFile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tdefer f.Close()\n\t\t\t\t_, err = f.Write([]byte(`package invalid\n\nfunction a() {}`))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tdefer os.Remove(mockErrGoFile)\n\t\t\t\treturn p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tif c.gomodule {\n\t\t\t\tos.Setenv(\"GO111MODULE\", \"on\")\n\t\t\t} else {\n\t\t\t\tos.Setenv(\"GO111MODULE\", \"off\")\n\t\t\t}\n\t\t\terr := c.run(c.searchDir)\n\t\t\tos.Setenv(\"GO111MODULE\", go111moduleEnv)\n\t\t\tif c.err == nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Error(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParser_ParseStructArrayObject(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage api\n\ntype Response struct {\n\tCode int\n\tTable [][]string\n\tData []struct{\n\t\tField1 uint\n\t\tField2 string\n\t}\n}\n\n// @Success 200 {object} Response\n// @Router /api/{id} [get]\nfunc Test(){\n}\n`\n\texpected := `{\n   \"api.Response\": {\n      \"type\": \"object\",\n      \"properties\": {\n         \"code\": {\n            \"type\": \"integer\"\n         },\n         \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n               \"type\": \"object\",\n               \"properties\": {\n                  \"field1\": {\n                     \"type\": \"integer\"\n                  },\n                  \"field2\": {\n                     \"type\": \"string\"\n                  }\n               }\n            }\n         },\n         \"table\": {\n            \"type\": \"array\",\n            \"items\": {\n               \"type\": \"array\",\n               \"items\": {\n                  \"type\": \"string\"\n               }\n            }\n         }\n      }\n   }\n}`\n\n\tp := New()\n\t_ = p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\t_, err := p.packages.ParseTypes()\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tout, err := json.MarshalIndent(p.swagger.Definitions, \"\", \"   \")\n\tassert.NoError(t, err)\n\tassert.Equal(t, expected, string(out))\n\n}\n\nfunc TestParser_ParseEmbededStruct(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage api\n\ntype Response struct {\n\trest.ResponseWrapper\n}\n\n// @Success 200 {object} Response\n// @Router /api/{id} [get]\nfunc Test(){\n}\n`\n\trestsrc := `\npackage rest\n\ntype ResponseWrapper struct {\n\tStatus   string\n\tCode     int\n\tMessages []string\n\tResult   interface{}\n}\n`\n\texpected := `{\n   \"api.Response\": {\n      \"type\": \"object\",\n      \"properties\": {\n         \"code\": {\n            \"type\": \"integer\"\n         },\n         \"messages\": {\n            \"type\": \"array\",\n            \"items\": {\n               \"type\": \"string\"\n            }\n         },\n         \"result\": {},\n         \"status\": {\n            \"type\": \"string\"\n         }\n      }\n   }\n}`\n\tparser := New(SetParseDependency(1))\n\n\t_ = parser.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\n\t_ = parser.packages.ParseFile(\"rest\", \"rest/rest.go\", restsrc, ParseAll)\n\n\t_, err := parser.packages.ParseTypes()\n\tassert.NoError(t, err)\n\n\terr = parser.packages.RangeFiles(parser.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tout, err := json.MarshalIndent(parser.swagger.Definitions, \"\", \"   \")\n\tassert.NoError(t, err)\n\tassert.Equal(t, expected, string(out))\n\n}\n\nfunc TestParser_ParseStructPointerMembers(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage api\n\ntype Child struct {\n\tName string\n}\n\ntype Parent struct {\n\tTest1 *string  //test1\n\tTest2 *Child   //test2\n}\n\n// @Success 200 {object} Parent\n// @Router /api/{id} [get]\nfunc Test(){\n}\n`\n\n\texpected := `{\n   \"api.Child\": {\n      \"type\": \"object\",\n      \"properties\": {\n         \"name\": {\n            \"type\": \"string\"\n         }\n      }\n   },\n   \"api.Parent\": {\n      \"type\": \"object\",\n      \"properties\": {\n         \"test1\": {\n            \"description\": \"test1\",\n            \"type\": \"string\"\n         },\n         \"test2\": {\n            \"description\": \"test2\",\n            \"allOf\": [\n               {\n                  \"$ref\": \"#/definitions/api.Child\"\n               }\n            ]\n         }\n      }\n   }\n}`\n\tp := New()\n\t_ = p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\t_, err := p.packages.ParseTypes()\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tout, err := json.MarshalIndent(p.swagger.Definitions, \"\", \"   \")\n\tassert.NoError(t, err)\n\tassert.Equal(t, expected, string(out))\n}\n\nfunc TestParser_ParseStructMapMember(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage api\n\ntype MyMapType map[string]string\n\ntype Child struct {\n\tName string\n}\n\ntype Parent struct {\n\tTest1 map[string]interface{}  //test1\n\tTest2 map[string]string\t\t  //test2\n\tTest3 map[string]*string\t  //test3\n\tTest4 map[string]Child\t\t  //test4\n\tTest5 map[string]*Child\t\t  //test5\n\tTest6 MyMapType\t\t\t\t  //test6\n\tTest7 []Child\t\t\t\t  //test7\n\tTest8 []*Child\t\t\t\t  //test8\n\tTest9 []map[string]string\t  //test9\n}\n\n// @Success 200 {object} Parent\n// @Router /api/{id} [get]\nfunc Test(){\n}\n`\n\texpected := `{\n   \"api.Child\": {\n      \"type\": \"object\",\n      \"properties\": {\n         \"name\": {\n            \"type\": \"string\"\n         }\n      }\n   },\n   \"api.MyMapType\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n         \"type\": \"string\"\n      }\n   },\n   \"api.Parent\": {\n      \"type\": \"object\",\n      \"properties\": {\n         \"test1\": {\n            \"description\": \"test1\",\n            \"type\": \"object\",\n            \"additionalProperties\": true\n         },\n         \"test2\": {\n            \"description\": \"test2\",\n            \"type\": \"object\",\n            \"additionalProperties\": {\n               \"type\": \"string\"\n            }\n         },\n         \"test3\": {\n            \"description\": \"test3\",\n            \"type\": \"object\",\n            \"additionalProperties\": {\n               \"type\": \"string\"\n            }\n         },\n         \"test4\": {\n            \"description\": \"test4\",\n            \"type\": \"object\",\n            \"additionalProperties\": {\n               \"$ref\": \"#/definitions/api.Child\"\n            }\n         },\n         \"test5\": {\n            \"description\": \"test5\",\n            \"type\": \"object\",\n            \"additionalProperties\": {\n               \"$ref\": \"#/definitions/api.Child\"\n            }\n         },\n         \"test6\": {\n            \"description\": \"test6\",\n            \"allOf\": [\n               {\n                  \"$ref\": \"#/definitions/api.MyMapType\"\n               }\n            ]\n         },\n         \"test7\": {\n            \"description\": \"test7\",\n            \"type\": \"array\",\n            \"items\": {\n               \"$ref\": \"#/definitions/api.Child\"\n            }\n         },\n         \"test8\": {\n            \"description\": \"test8\",\n            \"type\": \"array\",\n            \"items\": {\n               \"$ref\": \"#/definitions/api.Child\"\n            }\n         },\n         \"test9\": {\n            \"description\": \"test9\",\n            \"type\": \"array\",\n            \"items\": {\n               \"type\": \"object\",\n               \"additionalProperties\": {\n                  \"type\": \"string\"\n               }\n            }\n         }\n      }\n   }\n}`\n\tp := New()\n\t_ = p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\n\t_, err := p.packages.ParseTypes()\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tout, err := json.MarshalIndent(p.swagger.Definitions, \"\", \"   \")\n\tassert.NoError(t, err)\n\tassert.Equal(t, expected, string(out))\n}\n\nfunc TestParser_ParseRouterApiInfoErr(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage test\n\n// @Accept unknown\nfunc Test(){\n}\n`\n\tp := New()\n\terr := p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.Error(t, err)\n}\n\nfunc TestParser_ParseRouterApiGet(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage test\n\n// @Router /api/{id} [get]\nfunc Test(){\n}\n`\n\tp := New()\n\terr := p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tps := p.swagger.Paths.Paths\n\n\tval, ok := ps[\"/api/{id}\"]\n\n\tassert.True(t, ok)\n\tassert.NotNil(t, val.Get)\n}\n\nfunc TestParser_ParseRouterApiPOST(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage test\n\n// @Router /api/{id} [post]\nfunc Test(){\n}\n`\n\tp := New()\n\terr := p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tps := p.swagger.Paths.Paths\n\n\tval, ok := ps[\"/api/{id}\"]\n\n\tassert.True(t, ok)\n\tassert.NotNil(t, val.Post)\n}\n\nfunc TestParser_ParseRouterApiDELETE(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage test\n\n// @Router /api/{id} [delete]\nfunc Test(){\n}\n`\n\tp := New()\n\terr := p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tps := p.swagger.Paths.Paths\n\n\tval, ok := ps[\"/api/{id}\"]\n\n\tassert.True(t, ok)\n\tassert.NotNil(t, val.Delete)\n}\n\nfunc TestParser_ParseRouterApiPUT(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage test\n\n// @Router /api/{id} [put]\nfunc Test(){\n}\n`\n\tp := New()\n\terr := p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tps := p.swagger.Paths.Paths\n\n\tval, ok := ps[\"/api/{id}\"]\n\n\tassert.True(t, ok)\n\tassert.NotNil(t, val.Put)\n}\n\nfunc TestParser_ParseRouterApiPATCH(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage test\n\n// @Router /api/{id} [patch]\nfunc Test(){\n}\n`\n\tp := New()\n\terr := p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tps := p.swagger.Paths.Paths\n\n\tval, ok := ps[\"/api/{id}\"]\n\n\tassert.True(t, ok)\n\tassert.NotNil(t, val.Patch)\n}\n\nfunc TestParser_ParseRouterApiHead(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage test\n\n// @Router /api/{id} [head]\nfunc Test(){\n}\n`\n\tp := New()\n\terr := p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\tps := p.swagger.Paths.Paths\n\n\tval, ok := ps[\"/api/{id}\"]\n\n\tassert.True(t, ok)\n\tassert.NotNil(t, val.Head)\n}\n\nfunc TestParser_ParseRouterApiOptions(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage test\n\n// @Router /api/{id} [options]\nfunc Test(){\n}\n`\n\tp := New()\n\terr := p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tps := p.swagger.Paths.Paths\n\n\tval, ok := ps[\"/api/{id}\"]\n\n\tassert.True(t, ok)\n\tassert.NotNil(t, val.Options)\n}\n\nfunc TestParser_ParseRouterApiMultipleRoutesForSameFunction(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage test\n\n// @Router /api/v1/{id} [get]\n// @Router /api/v2/{id} [post]\nfunc Test(){\n}\n`\n\tp := New()\n\terr := p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tps := p.swagger.Paths.Paths\n\n\tval, ok := ps[\"/api/v1/{id}\"]\n\n\tassert.True(t, ok)\n\tassert.NotNil(t, val.Get)\n\n\tval, ok = ps[\"/api/v2/{id}\"]\n\n\tassert.True(t, ok)\n\tassert.NotNil(t, val.Post)\n}\n\nfunc TestParser_ParseRouterApiMultiple(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage test\n\n// @Router /api/{id} [get]\nfunc Test1(){\n}\n\n// @Router /api/{id} [patch]\nfunc Test2(){\n}\n\n// @Router /api/{id} [delete]\nfunc Test3(){\n}\n`\n\tp := New()\n\terr := p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tps := p.swagger.Paths.Paths\n\n\tval, ok := ps[\"/api/{id}\"]\n\n\tassert.True(t, ok)\n\tassert.NotNil(t, val.Get)\n\tassert.NotNil(t, val.Patch)\n\tassert.NotNil(t, val.Delete)\n}\n\nfunc TestParser_ParseRouterApiMultiplePathsWithMultipleParams(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage test\n\n// @Success 200\n// @Param group_id path int true \"Group ID\"\n// @Param user_id  path int true \"User ID\"\n// @Router /examples/groups/{group_id}/user/{user_id}/address [get]\n// @Router /examples/user/{user_id}/address [get]\nfunc Test(){\n}\n`\n\tp := New()\n\terr := p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tps := p.swagger.Paths.Paths\n\n\tval, ok := ps[\"/examples/groups/{group_id}/user/{user_id}/address\"]\n\n\tassert.True(t, ok)\n\tassert.Equal(t, 2, len(val.Get.Parameters))\n\n\tval, ok = ps[\"/examples/user/{user_id}/address\"]\n\n\tassert.True(t, ok)\n\tassert.Equal(t, 1, len(val.Get.Parameters))\n}\n\n// func TestParseDeterministic(t *testing.T) {\n// \tmainAPIFile := \"main.go\"\n// \tfor _, searchDir := range []string{\n// \t\t\"testdata/simple\",\n// \t\t\"testdata/model_not_under_root/cmd\",\n// \t} {\n// \t\tt.Run(searchDir, func(t *testing.T) {\n// \t\t\tvar expected string\n\n// \t\t\t// run the same code 100 times and check that the output is the same every time\n// \t\t\tfor i := 0; i < 100; i++ {\n// \t\t\t\tp := New()\n// \t\t\t\tp.PropNamingStrategy = PascalCase\n// \t\t\t\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n// \t\t\t\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n// \t\t\t\tassert.NotEqual(t, \"\", string(b))\n\n// \t\t\t\tif expected == \"\" {\n// \t\t\t\t\texpected = string(b)\n// \t\t\t\t}\n\n// \t\t\t\tassert.Equal(t, expected, string(b))\n// \t\t\t}\n// \t\t})\n// \t}\n// }\n\nfunc TestParser_ParseRouterApiDuplicateRoute(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage api\n\nimport (\n\t\"net/http\"\n)\n\n// @Router /api/endpoint [get]\nfunc FunctionOne(w http.ResponseWriter, r *http.Request) {\n\t//write your code\n}\n\n// @Router /api/endpoint [get]\nfunc FunctionTwo(w http.ResponseWriter, r *http.Request) {\n\t//write your code\n}\n\n`\n\tp := New(SetStrict(true))\n\terr := p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.EqualError(t, err, \"route GET /api/endpoint is declared multiple times\")\n\n\tp = New()\n\terr = p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n}\n\nfunc TestApiParseTag(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/tags\"\n\tp := New(SetMarkdownFileDirectory(searchDir))\n\tp.PropNamingStrategy = PascalCase\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\n\tif len(p.swagger.Tags) != 3 {\n\t\tt.Error(\"Number of tags did not match\")\n\t}\n\n\tdogs := p.swagger.Tags[0]\n\tif dogs.TagProps.Name != \"dogs\" || dogs.TagProps.Description != \"Dogs are cool\" {\n\t\tt.Error(\"Failed to parse dogs name or description\")\n\t}\n\n\tcats := p.swagger.Tags[1]\n\tif cats.TagProps.Name != \"cats\" || cats.TagProps.Description != \"Cats are the devil\" {\n\t\tt.Error(\"Failed to parse cats name or description\")\n\t}\n\n\tif cats.TagProps.ExternalDocs.URL != \"https://google.de\" || cats.TagProps.ExternalDocs.Description != \"google is super useful to find out that cats are evil!\" {\n\t\tt.Error(\"URL: \", cats.TagProps.ExternalDocs.URL)\n\t\tt.Error(\"Description: \", cats.TagProps.ExternalDocs.Description)\n\t\tt.Error(\"Failed to parse cats external documentation\")\n\t}\n}\n\nfunc TestApiParseTag_NonExistendTag(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/tags_nonexistend_tag\"\n\tp := New(SetMarkdownFileDirectory(searchDir))\n\tp.PropNamingStrategy = PascalCase\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.Error(t, err)\n}\n\nfunc TestParseTagMarkdownDescription(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/tags\"\n\tp := New(SetMarkdownFileDirectory(searchDir))\n\tp.PropNamingStrategy = PascalCase\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tif err != nil {\n\t\tt.Error(\"Failed to parse api description: \" + err.Error())\n\t}\n\n\tif len(p.swagger.Tags) != 3 {\n\t\tt.Error(\"Number of tags did not match\")\n\t}\n\n\tapes := p.swagger.Tags[2]\n\tif apes.TagProps.Description == \"\" {\n\t\tt.Error(\"Failed to parse tag description markdown file\")\n\t}\n}\n\nfunc TestParseApiMarkdownDescription(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/tags\"\n\tp := New(SetMarkdownFileDirectory(searchDir))\n\tp.PropNamingStrategy = PascalCase\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tif err != nil {\n\t\tt.Error(\"Failed to parse api description: \" + err.Error())\n\t}\n\n\tif p.swagger.Info.Description == \"\" {\n\t\tt.Error(\"Failed to parse api description: \" + err.Error())\n\t}\n}\n\nfunc TestIgnoreInvalidPkg(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/deps_having_invalid_pkg\"\n\tp := New()\n\tif err := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth); err != nil {\n\t\tt.Error(\"Failed to ignore valid pkg: \" + err.Error())\n\t}\n}\n\nfunc TestFixes432(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/fixes-432\"\n\tmainAPIFile := \"cmd/main.go\"\n\n\tp := New()\n\tif err := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth); err != nil {\n\t\tt.Error(\"Failed to ignore valid pkg: \" + err.Error())\n\t}\n}\n\nfunc TestParseOutsideDependencies(t *testing.T) {\n\tt.Parallel()\n\n\tsearchDir := \"testdata/pare_outside_dependencies\"\n\tmainAPIFile := \"cmd/main.go\"\n\n\tp := New(SetParseDependency(1))\n\tif err := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth); err != nil {\n\t\tt.Error(\"Failed to parse api: \" + err.Error())\n\t}\n}\n\nfunc TestParseStructParamCommentByQueryType(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage main\n\ntype Student struct {\n\tName string\n\tAge int\n\tTeachers []string\n\tSkipField map[string]string\n}\n\n// @Param request query Student true \"query params\"\n// @Success 200\n// @Router /test [get]\nfunc Fun()  {\n\n}\n`\n\texpected := `{\n    \"info\": {\n        \"contact\": {}\n    },\n    \"paths\": {\n        \"/test\": {\n            \"get\": {\n                \"parameters\": [\n                    {\n                        \"type\": \"integer\",\n                        \"name\": \"age\",\n                        \"in\": \"query\"\n                    },\n                    {\n                        \"type\": \"string\",\n                        \"name\": \"name\",\n                        \"in\": \"query\"\n                    },\n                    {\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"type\": \"string\"\n                        },\n                        \"name\": \"teachers\",\n                        \"in\": \"query\"\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"OK\"\n                    }\n                }\n            }\n        }\n    }\n}`\n\n\tp := New()\n\terr := p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NoError(t, err)\n\n\t_, err = p.packages.ParseTypes()\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseParamCommentExtension(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage main\n\n// @Param request query string true \"query params\" extensions(x-example=[0, 9],x-foo=bar)\n// @Success 200\n// @Router /test [get]\nfunc Fun()  {\n\n}\n`\n\texpected := `{\n    \"info\": {\n        \"contact\": {}\n    },\n    \"paths\": {\n        \"/test\": {\n            \"get\": {\n                \"parameters\": [\n                    {\n                       \"type\": \"string\",\n                       \"x-example\": \"[0, 9]\",\n                       \"x-foo\": \"bar\",\n                       \"description\": \"query params\",\n                       \"name\": \"request\",\n                       \"in\": \"query\",\n                       \"required\": true\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"OK\"\n                    }\n                }\n            }\n        }\n    }\n}`\n\n\tp := New()\n\t_ = p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\n\t_, err := p.packages.ParseTypes()\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.JSONEq(t, expected, string(b))\n}\n\nfunc TestParseRenamedStructDefinition(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage main\n\ntype Child struct {\n\tName string\n}//@name Student\n\ntype Parent struct {\n\tName string\n\tChild Child\n}//@name Teacher\n\n// @Param request body Parent true \"query params\"\n// @Success 200 {object} Parent\n// @Router /test [get]\nfunc Fun()  {\n\n}\n`\n\n\tp := New()\n\t_ = p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\t_, err := p.packages.ParseTypes()\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, err)\n\tteacher, ok := p.swagger.Definitions[\"Teacher\"]\n\tassert.True(t, ok)\n\tref := teacher.Properties[\"child\"].SchemaProps.Ref\n\tassert.Equal(t, \"#/definitions/Student\", ref.String())\n\t_, ok = p.swagger.Definitions[\"Student\"]\n\tassert.True(t, ok)\n\tpath, ok := p.swagger.Paths.Paths[\"/test\"]\n\tassert.True(t, ok)\n\tassert.Equal(t, \"#/definitions/Teacher\", path.Get.Parameters[0].Schema.Ref.String())\n\tref = path.Get.Responses.ResponsesProps.StatusCodeResponses[200].ResponseProps.Schema.Ref\n\tassert.Equal(t, \"#/definitions/Teacher\", ref.String())\n}\n\nfunc TestParseTabFormattedRenamedStructDefinition(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := \"package main\\n\" +\n\t\t\"\\n\" +\n\t\t\"type Child struct {\\n\" +\n\t\t\"\\tName string\\n\" +\n\t\t\"}\\t//\\t@name\\tPupil\\n\" +\n\t\t\"\\n\" +\n\t\t\"// @Success 200 {object} Pupil\\n\" +\n\t\t\"func Fun()  { }\"\n\n\tp := New()\n\t_ = p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\t_, err := p.packages.ParseTypes()\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\t_, ok := p.swagger.Definitions[\"Pupil\"]\n\tassert.True(t, ok)\n}\n\nfunc TestParseFunctionScopedStructDefinition(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage main\n\n// @Param request body main.Fun.request true \"query params\"\n// @Success 200 {object} main.Fun.response\n// @Router /test [post]\nfunc Fun()  {\n\ttype request struct {\n\t\tName string\n\t}\n\n\ttype response struct {\n\t\tName string\n\t\tChild string\n\t}\n}\n`\n\tp := New()\n\t_ = p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\t_, err := p.packages.ParseTypes()\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\t_, ok := p.swagger.Definitions[\"main.Fun.response\"]\n\tassert.True(t, ok)\n}\n\nfunc TestParseFunctionScopedComplexStructDefinition(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage main\n\n// @Param request body main.Fun.request true \"query params\" \n// @Success 200 {object} main.Fun.response\n// @Router /test [post]\nfunc Fun()  {\n\ttype request struct {\n\t\tName string\n\t}\n\t\n\ttype grandChild struct {\n\t\tName string\n\t}\n\n\ttype pointerChild struct {\n\t\tName string\n\t}\n\n\ttype arrayChild struct {\n\t\tName string\n\t}\n\n\ttype child struct {\n\t\tGrandChild \t\tgrandChild\n\t\tPointerChild \t*pointerChild\n\t\tArrayChildren   []arrayChild\n\t}\n\n\ttype response struct {\n\t\tChildren \t[]child\n\t}\n}\n`\n\tp := New()\n\t_ = p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\t_, err := p.packages.ParseTypes()\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\t_, ok := p.swagger.Definitions[\"main.Fun.response\"]\n\tassert.True(t, ok)\n\t_, ok = p.swagger.Definitions[\"main.Fun.child\"]\n\tassert.True(t, ok)\n\t_, ok = p.swagger.Definitions[\"main.Fun.grandChild\"]\n\tassert.True(t, ok)\n\t_, ok = p.swagger.Definitions[\"main.Fun.pointerChild\"]\n\tassert.True(t, ok)\n\t_, ok = p.swagger.Definitions[\"main.Fun.arrayChild\"]\n\tassert.True(t, ok)\n}\n\nfunc TestParseFunctionScopedStructRequestResponseJSON(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage main\n\n// @Param request body main.Fun.request true \"query params\"\n// @Success 200 {object} main.Fun.response\n// @Router /test [post]\nfunc Fun()  {\n\ttype request struct {\n\t\tName string\n\t}\n\n\ttype response struct {\n\t\tName string\n\t\tChild string\n\t}\n}\n`\n\texpected := `{\n    \"info\": {\n        \"contact\": {}\n    },\n    \"paths\": {\n        \"/test\": {\n            \"post\": {\n                \"parameters\": [\n                    {\n                        \"description\": \"query params\",\n                        \"name\": \"request\",\n                        \"in\": \"body\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/main.Fun.request\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"OK\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/main.Fun.response\"\n                        }\n                    }\n                }\n            }\n        }\n    },\n    \"definitions\": {\n        \"main.Fun.request\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": {\n                    \"type\": \"string\"\n                }\n            }\n        },\n        \"main.Fun.response\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"child\": {\n                    \"type\": \"string\"\n                },\n                \"name\": {\n                    \"type\": \"string\"\n                }\n            }\n        }\n    }\n}`\n\n\tp := New()\n\t_ = p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\n\t_, err := p.packages.ParseTypes()\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseFunctionScopedComplexStructRequestResponseJSON(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage main\n\ntype PublicChild struct {\n\tName string\n}\t\n\n// @Param request body main.Fun.request true \"query params\" \n// @Success 200 {object} main.Fun.response\n// @Router /test [post]\nfunc Fun()  {\n\ttype request struct {\n\t\tName string\n\t}\n\t\n\ttype grandChild struct {\n\t\tName string\n\t}\n\n\ttype child struct {\n\t\tGrandChild grandChild\n\t}\n\n\ttype response struct {\n\t\tChildren \t[]child\n\t    PublicChild PublicChild\n\t}\n}\n`\n\texpected := `{\n    \"info\": {\n        \"contact\": {}\n    },\n    \"paths\": {\n        \"/test\": {\n            \"post\": {\n                \"parameters\": [\n                    {\n                        \"description\": \"query params\",\n                        \"name\": \"request\",\n                        \"in\": \"body\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/main.Fun.request\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"OK\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/main.Fun.response\"\n                        }\n                    }\n                }\n            }\n        }\n    },\n    \"definitions\": {\n        \"main.Fun.child\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"grandChild\": {\n                    \"$ref\": \"#/definitions/main.Fun.grandChild\"\n                }\n            }\n        },\n        \"main.Fun.grandChild\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": {\n                    \"type\": \"string\"\n                }\n            }\n        },\n        \"main.Fun.request\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": {\n                    \"type\": \"string\"\n                }\n            }\n        },\n        \"main.Fun.response\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"children\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"$ref\": \"#/definitions/main.Fun.child\"\n                    }\n                },\n                \"publicChild\": {\n                    \"$ref\": \"#/definitions/main.PublicChild\"\n                }\n            }\n        },\n        \"main.PublicChild\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": {\n                    \"type\": \"string\"\n                }\n            }\n        }\n    }\n}`\n\n\tp := New()\n\t_ = p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\n\t_, err := p.packages.ParseTypes()\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestPackagesDefinitions_CollectAstFileInit(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage main\n\n// @Router /test [get]\nfunc Fun()  {\n\n}\n`\n\tpkgs := NewPackagesDefinitions()\n\n\t// unset the .files and .packages and check that they're re-initialized by collectAstFile\n\tpkgs.packages = nil\n\tpkgs.files = nil\n\n\t_ = pkgs.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NotNil(t, pkgs.packages)\n\tassert.NotNil(t, pkgs.files)\n}\n\nfunc TestCollectAstFileMultipleTimes(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage main\n\n// @Router /test [get]\nfunc Fun()  {\n\n}\n`\n\n\tp := New()\n\t_ = p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.Equal(t, 1, len(p.packages.files))\n\tvar path string\n\tvar file *ast.File\n\tfor path, file = range p.packages.packages[\"api\"].Files {\n\t\tbreak\n\t}\n\tassert.NotNil(t, file)\n\tassert.NotNil(t, p.packages.files[file])\n\n\t// if we collect the same again nothing should happen\n\t_ = p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.Equal(t, 1, len(p.packages.files))\n\tassert.Equal(t, file, p.packages.packages[\"api\"].Files[path])\n\tassert.NotNil(t, p.packages.files[file])\n}\n\nfunc TestParseJSONFieldString(t *testing.T) {\n\tt.Parallel()\n\n\texpected := `{\n    \"swagger\": \"2.0\",\n    \"info\": {\n        \"description\": \"This is a sample server.\",\n        \"title\": \"Swagger Example API\",\n        \"contact\": {},\n        \"version\": \"1.0\"\n    },\n    \"host\": \"localhost:4000\",\n    \"basePath\": \"/\",\n    \"paths\": {\n        \"/do-something\": {\n            \"post\": {\n                \"description\": \"Does something\",\n                \"consumes\": [\n                    \"application/json\"\n                ],\n                \"produces\": [\n                    \"application/json\"\n                ],\n                \"summary\": \"Call DoSomething\",\n                \"parameters\": [\n                    {\n                        \"description\": \"My Struct\",\n                        \"name\": \"body\",\n                        \"in\": \"body\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/main.MyStruct\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"OK\",\n                        \"schema\": {\n                            \"$ref\": \"#/definitions/main.MyStruct\"\n                        }\n                    },\n                    \"500\": {\n                        \"description\": \"Internal Server Error\"\n                    }\n                }\n            }\n        }\n    },\n    \"definitions\": {\n        \"main.MyStruct\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"boolvar\": {\n                    \"description\": \"boolean as a string\",\n                    \"type\": \"string\",\n                    \"example\": \"false\"\n                },\n                \"floatvar\": {\n                    \"description\": \"float as a string\",\n                    \"type\": \"string\",\n                    \"example\": \"0\"\n                },\n                \"id\": {\n                    \"type\": \"integer\",\n                    \"format\": \"int64\",\n                    \"example\": 1\n                },\n                \"myint\": {\n                    \"description\": \"integer as string\",\n                    \"type\": \"string\",\n                    \"example\": \"0\"\n                },\n                \"name\": {\n                    \"type\": \"string\",\n                    \"example\": \"poti\"\n                },\n                \"truebool\": {\n                    \"description\": \"boolean as a string\",\n                    \"type\": \"string\",\n                    \"example\": \"true\"\n                },\n                \"uuids\": {\n                    \"description\": \"string array with format\",\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"type\": \"string\",\n                        \"format\": \"uuid\"\n                    }\n                }\n            }\n        }\n    }\n}`\n\n\tsearchDir := \"testdata/json_field_string\"\n\tp := New()\n\terr := p.ParseAPI(searchDir, mainAPIFile, defaultParseDepth)\n\tassert.NoError(t, err)\n\tb, _ := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.Equal(t, expected, string(b))\n}\n\nfunc TestParseSwaggerignoreForEmbedded(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage main\n\ntype Child struct {\n\tChildName string\n}//@name Student\n\ntype Parent struct {\n\tName string\n\tChild ` + \"`swaggerignore:\\\"true\\\"`\" + `\n}//@name Teacher\n\n// @Param request body Parent true \"query params\"\n// @Success 200 {object} Parent\n// @Router /test [get]\nfunc Fun()  {\n\n}\n`\n\tp := New()\n\terr := p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NoError(t, err)\n\t_, _ = p.packages.ParseTypes()\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tteacher, ok := p.swagger.Definitions[\"Teacher\"]\n\tassert.True(t, ok)\n\n\tname, ok := teacher.Properties[\"name\"]\n\tassert.True(t, ok)\n\tassert.Len(t, name.Type, 1)\n\tassert.Equal(t, \"string\", name.Type[0])\n\n\tchildName, ok := teacher.Properties[\"childName\"]\n\tassert.False(t, ok)\n\tassert.Empty(t, childName)\n}\n\nfunc TestDefineTypeOfExample(t *testing.T) {\n\n\tt.Run(\"String type\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\texample, err := defineTypeOfExample(\"string\", \"\", \"example\")\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, example.(string), \"example\")\n\t})\n\n\tt.Run(\"Number type\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\texample, err := defineTypeOfExample(\"number\", \"\", \"12.34\")\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, example.(float64), 12.34)\n\n\t\t_, err = defineTypeOfExample(\"number\", \"\", \"two\")\n\t\tassert.Error(t, err)\n\t})\n\n\tt.Run(\"Integer type\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\texample, err := defineTypeOfExample(\"integer\", \"\", \"12\")\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, example.(int), 12)\n\n\t\t_, err = defineTypeOfExample(\"integer\", \"\", \"two\")\n\t\tassert.Error(t, err)\n\t})\n\n\tt.Run(\"Boolean type\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\texample, err := defineTypeOfExample(\"boolean\", \"\", \"true\")\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, example.(bool), true)\n\n\t\t_, err = defineTypeOfExample(\"boolean\", \"\", \"!true\")\n\t\tassert.Error(t, err)\n\t})\n\n\tt.Run(\"Array type\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\texample, err := defineTypeOfExample(\"array\", \"\", \"one,two,three\")\n\t\tassert.Error(t, err)\n\t\tassert.Nil(t, example)\n\n\t\texample, err = defineTypeOfExample(\"array\", \"string\", \"one,two,three\")\n\t\tassert.NoError(t, err)\n\n\t\tvar arr []string\n\n\t\tfor _, v := range example.([]interface{}) {\n\t\t\tarr = append(arr, v.(string))\n\t\t}\n\n\t\tassert.Equal(t, arr, []string{\"one\", \"two\", \"three\"})\n\t})\n\n\tt.Run(\"Object type\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\texample, err := defineTypeOfExample(\"object\", \"\", \"key_one:one,key_two:two,key_three:three\")\n\t\tassert.Error(t, err)\n\t\tassert.Nil(t, example)\n\n\t\texample, err = defineTypeOfExample(\"object\", \"string\", \"key_one,key_two,key_three\")\n\t\tassert.Error(t, err)\n\t\tassert.Nil(t, example)\n\n\t\texample, err = defineTypeOfExample(\"object\", \"oops\", \"key_one:one,key_two:two,key_three:three\")\n\t\tassert.Error(t, err)\n\t\tassert.Nil(t, example)\n\n\t\texample, err = defineTypeOfExample(\"object\", \"string\", \"key_one:one,key_two:two,key_three:three\")\n\t\tassert.NoError(t, err)\n\t\tobj := map[string]string{}\n\n\t\tfor k, v := range example.(map[string]interface{}) {\n\t\t\tobj[k] = v.(string)\n\t\t}\n\n\t\tassert.Equal(t, obj, map[string]string{\"key_one\": \"one\", \"key_two\": \"two\", \"key_three\": \"three\"})\n\t})\n\n\tt.Run(\"Invalid type\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\texample, err := defineTypeOfExample(\"oops\", \"\", \"\")\n\t\tassert.Error(t, err)\n\t\tassert.Nil(t, example)\n\t})\n}\n\ntype mockFS struct {\n\tos.FileInfo\n\tFileName    string\n\tIsDirectory bool\n}\n\nfunc (fs *mockFS) Name() string {\n\treturn fs.FileName\n}\n\nfunc (fs *mockFS) IsDir() bool {\n\treturn fs.IsDirectory\n}\n\nfunc TestParser_Skip(t *testing.T) {\n\tt.Parallel()\n\n\tparser := New()\n\tparser.ParseVendor = true\n\n\tassert.NoError(t, parser.Skip(\"\", &mockFS{FileName: \"vendor\"}))\n\tassert.NoError(t, parser.Skip(\"\", &mockFS{FileName: \"vendor\", IsDirectory: true}))\n\n\tparser.ParseVendor = false\n\tassert.NoError(t, parser.Skip(\"\", &mockFS{FileName: \"vendor\"}))\n\tassert.Error(t, parser.Skip(\"\", &mockFS{FileName: \"vendor\", IsDirectory: true}))\n\n\tassert.NoError(t, parser.Skip(\"\", &mockFS{FileName: \"models\", IsDirectory: true}))\n\tassert.NoError(t, parser.Skip(\"\", &mockFS{FileName: \"admin\", IsDirectory: true}))\n\tassert.NoError(t, parser.Skip(\"\", &mockFS{FileName: \"release\", IsDirectory: true}))\n\tassert.NoError(t, parser.Skip(\"\", &mockFS{FileName: \"..\", IsDirectory: true}))\n\n\tparser = New(SetExcludedDirsAndFiles(\"admin/release,admin/models\"))\n\tassert.NoError(t, parser.Skip(\"admin\", &mockFS{IsDirectory: true}))\n\tassert.NoError(t, parser.Skip(filepath.Clean(\"admin/service\"), &mockFS{IsDirectory: true}))\n\tassert.Error(t, parser.Skip(filepath.Clean(\"admin/models\"), &mockFS{IsDirectory: true}))\n\tassert.Error(t, parser.Skip(filepath.Clean(\"admin/release\"), &mockFS{IsDirectory: true}))\n}\n\nfunc TestGetFieldType(t *testing.T) {\n\tt.Parallel()\n\n\tfield, err := getFieldType(&ast.File{}, &ast.Ident{Name: \"User\"}, nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"User\", field)\n\n\t_, err = getFieldType(&ast.File{}, &ast.FuncType{}, nil)\n\tassert.Error(t, err)\n\n\tfield, err = getFieldType(&ast.File{}, &ast.SelectorExpr{X: &ast.Ident{Name: \"models\"}, Sel: &ast.Ident{Name: \"User\"}}, nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"models.User\", field)\n\n\t_, err = getFieldType(&ast.File{}, &ast.SelectorExpr{X: &ast.FuncType{}, Sel: &ast.Ident{Name: \"User\"}}, nil)\n\tassert.Error(t, err)\n\n\tfield, err = getFieldType(&ast.File{}, &ast.StarExpr{X: &ast.Ident{Name: \"User\"}}, nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"User\", field)\n\n\tfield, err = getFieldType(&ast.File{}, &ast.StarExpr{X: &ast.FuncType{}}, nil)\n\tassert.Error(t, err)\n\n\tfield, err = getFieldType(&ast.File{}, &ast.StarExpr{X: &ast.SelectorExpr{X: &ast.Ident{Name: \"models\"}, Sel: &ast.Ident{Name: \"User\"}}}, nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"models.User\", field)\n}\n\nfunc TestTryAddDescription(t *testing.T) {\n\ttype args struct {\n\t\tspec       *spec.SecurityScheme\n\t\textensions map[string]interface{}\n\t}\n\ttests := []struct {\n\t\tname  string\n\t\tlines []string\n\t\targs  args\n\t\twant  *spec.SecurityScheme\n\t}{\n\t\t{\n\t\t\tname: \"added description\",\n\t\t\tlines: []string{\n\t\t\t\t\"\\t@securitydefinitions.apikey test\",\n\t\t\t\t\"\\t@in header\",\n\t\t\t\t\"\\t@name x-api-key\",\n\t\t\t\t\"\\t@description some description\",\n\t\t\t},\n\t\t\twant: &spec.SecurityScheme{\n\t\t\t\tSecuritySchemeProps: spec.SecuritySchemeProps{\n\t\t\t\t\tName:        \"x-api-key\",\n\t\t\t\t\tType:        \"apiKey\",\n\t\t\t\t\tIn:          \"header\",\n\t\t\t\t\tDescription: \"some description\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"added description with multiline\",\n\t\t\tlines: []string{\n\t\t\t\t\"\\t@securitydefinitions.apikey test\",\n\t\t\t\t\"\\t@in header\",\n\t\t\t\t\"\\t@name x-api-key\",\n\t\t\t\t\"\\t@description line1\",\n\t\t\t\t\"\\t@description line2\",\n\t\t\t},\n\t\t\twant: &spec.SecurityScheme{\n\t\t\t\tSecuritySchemeProps: spec.SecuritySchemeProps{\n\t\t\t\t\tName:        \"x-api-key\",\n\t\t\t\t\tType:        \"apiKey\",\n\t\t\t\t\tIn:          \"header\",\n\t\t\t\t\tDescription: \"line1\\nline2\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"no description\",\n\t\t\tlines: []string{\n\t\t\t\t\" @securitydefinitions.oauth2.application swagger\",\n\t\t\t\t\" @tokenurl https://example.com/oauth/token\",\n\t\t\t\t\" @not-description some description\",\n\t\t\t},\n\t\t\twant: &spec.SecurityScheme{\n\t\t\t\tSecuritySchemeProps: spec.SecuritySchemeProps{\n\t\t\t\t\tType:        \"oauth2\",\n\t\t\t\t\tFlow:        \"application\",\n\t\t\t\t\tTokenURL:    \"https://example.com/oauth/token\",\n\t\t\t\t\tDescription: \"\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\n\t\t{\n\t\t\tname: \"description has invalid format\",\n\t\t\tlines: []string{\n\t\t\t\t\"@securitydefinitions.oauth2.implicit swagger\",\n\t\t\t\t\"@authorizationurl https://example.com/oauth/token\",\n\t\t\t\t\"@description 12345\",\n\t\t\t},\n\n\t\t\twant: &spec.SecurityScheme{\n\t\t\t\tSecuritySchemeProps: spec.SecuritySchemeProps{\n\t\t\t\t\tType:             \"oauth2\",\n\t\t\t\t\tFlow:             \"implicit\",\n\t\t\t\t\tAuthorizationURL: \"https://example.com/oauth/token\",\n\t\t\t\t\tDescription:      \"12345\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tswag := spec.Swagger{\n\t\t\t\tSwaggerProps: spec.SwaggerProps{\n\t\t\t\t\tSecurityDefinitions: make(map[string]*spec.SecurityScheme),\n\t\t\t\t},\n\t\t\t}\n\t\t\tline := 0\n\t\t\tcommentLine := tt.lines[line]\n\t\t\tattribute := strings.Split(commentLine, \" \")[0]\n\t\t\tvalue := strings.TrimSpace(commentLine[len(attribute):])\n\t\t\tsecAttr, _ := parseSecAttributes(attribute, tt.lines, &line)\n\t\t\tif !reflect.DeepEqual(secAttr, tt.want) {\n\t\t\t\tt.Errorf(\"setSwaggerSecurity() = %#v, want %#v\", swag.SecurityDefinitions[value], tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_getTagsFromComment(t *testing.T) {\n\ttype args struct {\n\t\tcomment string\n\t}\n\ttests := []struct {\n\t\tname     string\n\t\targs     args\n\t\twantTags []string\n\t}{\n\t\t{\n\t\t\tname: \"no tags comment\",\n\t\t\targs: args{\n\t\t\t\tcomment: \"//@name Student\",\n\t\t\t},\n\t\t\twantTags: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"empty comment\",\n\t\t\targs: args{\n\t\t\t\tcomment: \"//\",\n\t\t\t},\n\t\t\twantTags: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"tags comment\",\n\t\t\targs: args{\n\t\t\t\tcomment: \"//@Tags tag1,tag2,tag3\",\n\t\t\t},\n\t\t\twantTags: []string{\"tag1\", \"tag2\", \"tag3\"},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif gotTags := getTagsFromComment(tt.args.comment); !reflect.DeepEqual(gotTags, tt.wantTags) {\n\t\t\t\tt.Errorf(\"getTagsFromComment() = %v, want %v\", gotTags, tt.wantTags)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParser_matchTags(t *testing.T) {\n\n\ttype args struct {\n\t\tcomments []*ast.Comment\n\t}\n\ttests := []struct {\n\t\tname      string\n\t\tparser    *Parser\n\t\targs      args\n\t\twantMatch bool\n\t}{\n\t\t{\n\t\t\tname:      \"no tags filter\",\n\t\t\tparser:    New(),\n\t\t\targs:      args{comments: []*ast.Comment{{Text: \"//@Tags tag1,tag2,tag3\"}}},\n\t\t\twantMatch: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"with tags filter but no match\",\n\t\t\tparser:    New(SetTags(\"tag4,tag5,!tag1\")),\n\t\t\targs:      args{comments: []*ast.Comment{{Text: \"//@Tags tag1,tag2,tag3\"}}},\n\t\t\twantMatch: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"with tags filter but match\",\n\t\t\tparser:    New(SetTags(\"tag4,tag5,tag1\")),\n\t\t\targs:      args{comments: []*ast.Comment{{Text: \"//@Tags tag1,tag2,tag3\"}}},\n\t\t\twantMatch: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif gotMatch := tt.parser.matchTags(tt.args.comments); gotMatch != tt.wantMatch {\n\t\t\t\tt.Errorf(\"Parser.matchTags() = %v, want %v\", gotMatch, tt.wantMatch)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParser_parseExtension(t *testing.T) {\n\tpackagePath := \"testdata/parseExtension\"\n\tfilePath := packagePath + \"/parseExtension.go\"\n\tsrc, err := os.ReadFile(filePath)\n\tassert.NoError(t, err)\n\n\tfileSet := token.NewFileSet()\n\tf, err := goparser.ParseFile(fileSet, \"\", src, goparser.ParseComments)\n\tassert.NoError(t, err)\n\n\ttests := []struct {\n\t\tname          string\n\t\tparser        *Parser\n\t\texpectedPaths map[string]bool\n\t}{\n\t\t{\n\t\t\tname:          \"when no flag is set, everything is exported\",\n\t\t\tparser:        New(),\n\t\t\texpectedPaths: map[string]bool{\"/without-extension\": true, \"/with-another-extension\": true, \"/with-correct-extension\": true, \"/with-empty-comment-line\": true},\n\t\t},\n\t\t{\n\t\t\tname:          \"when nonexistent flag is set, nothing is exported\",\n\t\t\tparser:        New(SetParseExtension(\"nonexistent-extension-filter\")),\n\t\t\texpectedPaths: map[string]bool{\"/without-extension\": false, \"/with-another-extension\": false, \"/with-correct-extension\": false, \"/with-empty-comment-line\": false},\n\t\t},\n\t\t{\n\t\t\tname:          \"when correct flag is set, only that Path is exported\",\n\t\t\tparser:        New(SetParseExtension(\"google-backend\")),\n\t\t\texpectedPaths: map[string]bool{\"/without-extension\": false, \"/with-another-extension\": false, \"/with-correct-extension\": true, \"/with-empty-comment-line\": false},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\terr = tt.parser.ParseRouterAPIInfo(&AstFileInfo{\n\t\t\t\tFileSet:     fileSet,\n\t\t\t\tFile:        f,\n\t\t\t\tPath:        filePath,\n\t\t\t\tPackagePath: packagePath,\n\t\t\t\tParseFlag:   ParseAll,\n\t\t\t})\n\t\t\tassert.NoError(t, err)\n\t\t\tfor p, isExpected := range tt.expectedPaths {\n\t\t\t\t_, ok := tt.parser.swagger.Paths.Paths[p]\n\t\t\t\tassert.Equal(t, isExpected, ok)\n\t\t\t}\n\n\t\t\tfor p := range tt.parser.swagger.Paths.Paths {\n\t\t\t\t_, isExpected := tt.expectedPaths[p]\n\t\t\t\tassert.Equal(t, isExpected, true)\n\t\t\t}\n\t\t})\n\n\t}\n}\n\nfunc TestParser_collectionFormat(t *testing.T) {\n\ttests := []struct {\n\t\tname   string\n\t\tparser *Parser\n\t\tformat string\n\t}{\n\t\t{\n\t\t\tname:   \"no collectionFormat\",\n\t\t\tparser: New(),\n\t\t\tformat: \"\",\n\t\t},\n\t\t{\n\t\t\tname:   \"multi collectionFormat\",\n\t\t\tparser: New(SetCollectionFormat(\"multi\")),\n\t\t\tformat: \"multi\",\n\t\t},\n\t\t{\n\t\t\tname:   \"ssv collectionFormat\",\n\t\t\tparser: New(SetCollectionFormat(\"ssv\")),\n\t\t\tformat: \"ssv\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.parser.collectionFormatInQuery != tt.format {\n\t\t\t\tt.Errorf(\"Parser.collectionFormatInQuery = %s, want %s\", tt.parser.collectionFormatInQuery, tt.format)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParser_skipPackageByPrefix(t *testing.T) {\n\tt.Parallel()\n\n\tparser := New()\n\n\tassert.False(t, parser.skipPackageByPrefix(\"github.com/swaggo/swag\"))\n\tassert.False(t, parser.skipPackageByPrefix(\"github.com/swaggo/swag/cmd\"))\n\tassert.False(t, parser.skipPackageByPrefix(\"github.com/swaggo/swag/gen\"))\n\n\tparser = New(SetPackagePrefix(\"github.com/swaggo/swag/cmd\"))\n\n\tassert.True(t, parser.skipPackageByPrefix(\"github.com/swaggo/swag\"))\n\tassert.False(t, parser.skipPackageByPrefix(\"github.com/swaggo/swag/cmd\"))\n\tassert.True(t, parser.skipPackageByPrefix(\"github.com/swaggo/swag/gen\"))\n\n\tparser = New(SetPackagePrefix(\"github.com/swaggo/swag/cmd,github.com/swaggo/swag/gen\"))\n\n\tassert.True(t, parser.skipPackageByPrefix(\"github.com/swaggo/swag\"))\n\tassert.False(t, parser.skipPackageByPrefix(\"github.com/swaggo/swag/cmd\"))\n\tassert.False(t, parser.skipPackageByPrefix(\"github.com/swaggo/swag/gen\"))\n}\n\nfunc TestParser_ParseRouterApiInFuncBody(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage test\n\nfunc Test(){\n    // @Router /api/{id} [get]\n    _ = func() {\n\t}\n}\n`\n\tp := New()\n\tp.ParseFuncBody = true\n\terr := p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tps := p.swagger.Paths.Paths\n\n\tval, ok := ps[\"/api/{id}\"]\n\n\tassert.True(t, ok)\n\tassert.NotNil(t, val.Get)\n}\n\nfunc TestParser_ParseRouterApiInfoInAndOutFuncBody(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage test\n\n// @Router /api/outside [get]\nfunc otherRoute(){\n}\n\nfunc Test(){\n    // @Router /api/inside [get]\n    _ = func() {\n\t}\n}\n`\n\tp := New()\n\tp.ParseFuncBody = true\n\terr := p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NoError(t, err)\n\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tps := p.swagger.Paths.Paths\n\n\tval1, ok := ps[\"/api/outside\"]\n\tassert.True(t, ok)\n\tassert.NotNil(t, val1.Get)\n\n\tval2, ok := ps[\"/api/inside\"]\n\tassert.True(t, ok)\n\tassert.NotNil(t, val2.Get)\n}\n\nfunc TestParser_EmbeddedStructAsOtherAliasGoListNested(t *testing.T) {\n\tt.Parallel()\n\n\tp := New(SetParseDependency(1), ParseUsingGoList(true))\n\n\tp.parseGoList = true\n\n\tsearchDir := \"testdata/alias_nested\"\n\texpected, err := os.ReadFile(filepath.Join(searchDir, \"expected.json\"))\n\tassert.NoError(t, err)\n\n\terr = p.ParseAPI(searchDir, \"cmd/main/main.go\", 0)\n\tassert.NoError(t, err)\n\n\tb, err := json.MarshalIndent(p.swagger, \"\", \"    \")\n\tassert.NoError(t, err)\n\tassert.Equal(t, string(expected), string(b))\n}\n\nfunc TestParser_genVarDefinedFuncDoc(t *testing.T) {\n\tt.Parallel()\n\n\tsrc := `\npackage main\nfunc f() {}\n// @Summary\tgenerate var-defined functions' doc\n// @Router /test [get]\nvar Func = f\n// @Summary generate indirectly pointing\n// @Router /test2 [get]\nvar Func2 = Func\n`\n\tp := New()\n\terr := p.packages.ParseFile(\"api\", \"api/api.go\", src, ParseAll)\n\tassert.NoError(t, err)\n\t_, _ = p.packages.ParseTypes()\n\terr = p.packages.RangeFiles(p.ParseRouterAPIInfo)\n\tassert.NoError(t, err)\n\n\tval, ok := p.swagger.Paths.Paths[\"/test\"]\n\tassert.True(t, ok)\n\tassert.NotNil(t, val.Get)\n\tassert.Equal(t, val.Get.OperationProps.Summary, \"generate var-defined functions' doc\")\n\n\tval2, ok := p.swagger.Paths.Paths[\"/test2\"]\n\tassert.True(t, ok)\n\tassert.NotNil(t, val2.Get)\n\tassert.Equal(t, val2.Get.OperationProps.Summary, \"generate indirectly pointing\")\n}\n"
        },
        {
          "name": "schema.go",
          "type": "blob",
          "size": 7.923828125,
          "content": "package swag\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/go-openapi/spec\"\n)\n\nconst (\n\t// ARRAY represent a array value.\n\tARRAY = \"array\"\n\t// OBJECT represent a object value.\n\tOBJECT = \"object\"\n\t// PRIMITIVE represent a primitive value.\n\tPRIMITIVE = \"primitive\"\n\t// BOOLEAN represent a boolean value.\n\tBOOLEAN = \"boolean\"\n\t// INTEGER represent a integer value.\n\tINTEGER = \"integer\"\n\t// NUMBER represent a number value.\n\tNUMBER = \"number\"\n\t// STRING represent a string value.\n\tSTRING = \"string\"\n\t// FUNC represent a function value.\n\tFUNC = \"func\"\n\t// ERROR represent a error value.\n\tERROR = \"error\"\n\t// INTERFACE represent a interface value.\n\tINTERFACE = \"interface{}\"\n\t// ANY represent a any value.\n\tANY = \"any\"\n\t// NIL represent a empty value.\n\tNIL = \"nil\"\n\n\t// IgnoreNameOverridePrefix Prepend to model to avoid renaming based on comment.\n\tIgnoreNameOverridePrefix = '$'\n)\n\n// CheckSchemaType checks if typeName is not a name of primitive type.\nfunc CheckSchemaType(typeName string) error {\n\tif !IsPrimitiveType(typeName) {\n\t\treturn fmt.Errorf(\"%s is not basic types\", typeName)\n\t}\n\n\treturn nil\n}\n\n// IsSimplePrimitiveType determine whether the type name is a simple primitive type.\nfunc IsSimplePrimitiveType(typeName string) bool {\n\tswitch typeName {\n\tcase STRING, NUMBER, INTEGER, BOOLEAN:\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// IsPrimitiveType determine whether the type name is a primitive type.\nfunc IsPrimitiveType(typeName string) bool {\n\tswitch typeName {\n\tcase STRING, NUMBER, INTEGER, BOOLEAN, ARRAY, OBJECT, FUNC:\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// IsInterfaceLike determines whether the swagger type name is an go named interface type like error type.\nfunc IsInterfaceLike(typeName string) bool {\n\treturn typeName == ERROR || typeName == ANY\n}\n\n// IsNumericType determines whether the swagger type name is a numeric type.\nfunc IsNumericType(typeName string) bool {\n\treturn typeName == INTEGER || typeName == NUMBER\n}\n\n// TransToValidPrimitiveSchema transfer golang basic type to swagger schema with format considered.\nfunc TransToValidPrimitiveSchema(typeName string) *spec.Schema {\n\tswitch typeName {\n\tcase \"int\", \"uint\":\n\t\treturn &spec.Schema{SchemaProps: spec.SchemaProps{Type: []string{INTEGER}}}\n\tcase \"uint8\", \"int8\", \"uint16\", \"int16\", \"byte\", \"int32\", \"uint32\", \"rune\":\n\t\treturn &spec.Schema{SchemaProps: spec.SchemaProps{Type: []string{INTEGER}, Format: \"int32\"}}\n\tcase \"uint64\", \"int64\":\n\t\treturn &spec.Schema{SchemaProps: spec.SchemaProps{Type: []string{INTEGER}, Format: \"int64\"}}\n\tcase \"float32\", \"float64\":\n\t\treturn &spec.Schema{SchemaProps: spec.SchemaProps{Type: []string{NUMBER}, Format: typeName}}\n\tcase \"bool\":\n\t\treturn &spec.Schema{SchemaProps: spec.SchemaProps{Type: []string{BOOLEAN}}}\n\tcase \"string\":\n\t\treturn &spec.Schema{SchemaProps: spec.SchemaProps{Type: []string{STRING}}}\n\t}\n\treturn &spec.Schema{SchemaProps: spec.SchemaProps{Type: []string{typeName}}}\n}\n\n// TransToValidSchemeTypeWithFormat indicates type will transfer golang basic type to swagger supported type with format.\nfunc TransToValidSchemeTypeWithFormat(typeName string) (string, string) {\n\tswitch typeName {\n\tcase \"int\", \"uint\":\n\t\treturn INTEGER, \"\"\n\tcase \"uint8\", \"int8\", \"uint16\", \"int16\", \"byte\", \"int32\", \"uint32\", \"rune\":\n\t\treturn INTEGER, \"int32\"\n\tcase \"uint64\", \"int64\":\n\t\treturn INTEGER, \"int64\"\n\tcase \"float32\", \"float64\":\n\t\treturn NUMBER, typeName\n\tcase \"bool\":\n\t\treturn BOOLEAN, \"\"\n\tcase \"string\":\n\t\treturn STRING, \"\"\n\t}\n\treturn typeName, \"\"\n}\n\n// TransToValidSchemeType indicates type will transfer golang basic type to swagger supported type.\nfunc TransToValidSchemeType(typeName string) string {\n\tswitch typeName {\n\tcase \"uint\", \"int\", \"uint8\", \"int8\", \"uint16\", \"int16\", \"byte\":\n\t\treturn INTEGER\n\tcase \"uint32\", \"int32\", \"rune\":\n\t\treturn INTEGER\n\tcase \"uint64\", \"int64\":\n\t\treturn INTEGER\n\tcase \"float32\", \"float64\":\n\t\treturn NUMBER\n\tcase \"bool\":\n\t\treturn BOOLEAN\n\tcase \"string\":\n\t\treturn STRING\n\t}\n\n\treturn typeName\n}\n\n// IsGolangPrimitiveType determine whether the type name is a golang primitive type.\nfunc IsGolangPrimitiveType(typeName string) bool {\n\tswitch typeName {\n\tcase \"uint\",\n\t\t\"int\",\n\t\t\"uint8\",\n\t\t\"int8\",\n\t\t\"uint16\",\n\t\t\"int16\",\n\t\t\"byte\",\n\t\t\"uint32\",\n\t\t\"int32\",\n\t\t\"rune\",\n\t\t\"uint64\",\n\t\t\"int64\",\n\t\t\"float32\",\n\t\t\"float64\",\n\t\t\"bool\",\n\t\t\"string\":\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// TransToValidCollectionFormat determine valid collection format.\nfunc TransToValidCollectionFormat(format string) string {\n\tswitch format {\n\tcase \"csv\", \"multi\", \"pipes\", \"tsv\", \"ssv\":\n\t\treturn format\n\t}\n\n\treturn \"\"\n}\n\nfunc ignoreNameOverride(name string) bool {\n\treturn len(name) != 0 && name[0] == IgnoreNameOverridePrefix\n}\n\n// IsComplexSchema whether a schema is complex and should be a ref schema\nfunc IsComplexSchema(schema *spec.Schema) bool {\n\t// a enum type should be complex\n\tif len(schema.Enum) > 0 {\n\t\treturn true\n\t}\n\n\t// a deep array type is complex, how to determine deep? here more than 2 ,for example: [][]object,[][][]int\n\tif len(schema.Type) > 2 {\n\t\treturn true\n\t}\n\n\t//Object included, such as Object or []Object\n\tfor _, st := range schema.Type {\n\t\tif st == OBJECT {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// IsRefSchema whether a schema is a reference schema.\nfunc IsRefSchema(schema *spec.Schema) bool {\n\treturn schema.Ref.Ref.GetURL() != nil\n}\n\n// RefSchema build a reference schema.\nfunc RefSchema(refType string) *spec.Schema {\n\treturn spec.RefSchema(\"#/definitions/\" + refType)\n}\n\n// PrimitiveSchema build a primitive schema.\nfunc PrimitiveSchema(refType string) *spec.Schema {\n\treturn &spec.Schema{SchemaProps: spec.SchemaProps{Type: []string{refType}}}\n}\n\n// BuildCustomSchema build custom schema specified by tag swaggertype.\nfunc BuildCustomSchema(types []string) (*spec.Schema, error) {\n\tif len(types) == 0 {\n\t\treturn nil, nil\n\t}\n\n\tswitch types[0] {\n\tcase PRIMITIVE:\n\t\tif len(types) == 1 {\n\t\t\treturn nil, errors.New(\"need primitive type after primitive\")\n\t\t}\n\n\t\treturn BuildCustomSchema(types[1:])\n\tcase ARRAY:\n\t\tif len(types) == 1 {\n\t\t\treturn nil, errors.New(\"need array item type after array\")\n\t\t}\n\n\t\tschema, err := BuildCustomSchema(types[1:])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn spec.ArrayProperty(schema), nil\n\tcase OBJECT:\n\t\tif len(types) == 1 {\n\t\t\treturn PrimitiveSchema(types[0]), nil\n\t\t}\n\n\t\tschema, err := BuildCustomSchema(types[1:])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn spec.MapProperty(schema), nil\n\tdefault:\n\t\terr := CheckSchemaType(types[0])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn PrimitiveSchema(types[0]), nil\n\t}\n}\n\n// MergeSchema merge schemas\nfunc MergeSchema(dst *spec.Schema, src *spec.Schema) *spec.Schema {\n\tif len(src.Type) > 0 {\n\t\tdst.Type = src.Type\n\t}\n\tif len(src.Properties) > 0 {\n\t\tdst.Properties = src.Properties\n\t}\n\tif src.Items != nil {\n\t\tdst.Items = src.Items\n\t}\n\tif src.AdditionalProperties != nil {\n\t\tdst.AdditionalProperties = src.AdditionalProperties\n\t}\n\tif len(src.Description) > 0 {\n\t\tdst.Description = src.Description\n\t}\n\tif src.Nullable {\n\t\tdst.Nullable = src.Nullable\n\t}\n\tif len(src.Format) > 0 {\n\t\tdst.Format = src.Format\n\t}\n\tif src.Default != nil {\n\t\tdst.Default = src.Default\n\t}\n\tif src.Example != nil {\n\t\tdst.Example = src.Example\n\t}\n\tif len(src.Extensions) > 0 {\n\t\tdst.Extensions = src.Extensions\n\t}\n\tif src.Maximum != nil {\n\t\tdst.Maximum = src.Maximum\n\t}\n\tif src.Minimum != nil {\n\t\tdst.Minimum = src.Minimum\n\t}\n\tif src.ExclusiveMaximum {\n\t\tdst.ExclusiveMaximum = src.ExclusiveMaximum\n\t}\n\tif src.ExclusiveMinimum {\n\t\tdst.ExclusiveMinimum = src.ExclusiveMinimum\n\t}\n\tif src.MaxLength != nil {\n\t\tdst.MaxLength = src.MaxLength\n\t}\n\tif src.MinLength != nil {\n\t\tdst.MinLength = src.MinLength\n\t}\n\tif len(src.Pattern) > 0 {\n\t\tdst.Pattern = src.Pattern\n\t}\n\tif src.MaxItems != nil {\n\t\tdst.MaxItems = src.MaxItems\n\t}\n\tif src.MinItems != nil {\n\t\tdst.MinItems = src.MinItems\n\t}\n\tif src.UniqueItems {\n\t\tdst.UniqueItems = src.UniqueItems\n\t}\n\tif src.MultipleOf != nil {\n\t\tdst.MultipleOf = src.MultipleOf\n\t}\n\tif len(src.Enum) > 0 {\n\t\tdst.Enum = src.Enum\n\t}\n\tif len(src.Extensions) > 0 {\n\t\tdst.Extensions = src.Extensions\n\t}\n\tif len(src.ExtraProps) > 0 {\n\t\tdst.ExtraProps = src.ExtraProps\n\t}\n\treturn dst\n}\n"
        },
        {
          "name": "schema_test.go",
          "type": "blob",
          "size": 4.6494140625,
          "content": "package swag\n\nimport (\n\t\"testing\"\n\n\t\"github.com/go-openapi/spec\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestValidDataType(t *testing.T) {\n\tt.Parallel()\n\n\tassert.NoError(t, CheckSchemaType(STRING))\n\tassert.NoError(t, CheckSchemaType(NUMBER))\n\tassert.NoError(t, CheckSchemaType(INTEGER))\n\tassert.NoError(t, CheckSchemaType(BOOLEAN))\n\tassert.NoError(t, CheckSchemaType(ARRAY))\n\tassert.NoError(t, CheckSchemaType(OBJECT))\n\n\tassert.Error(t, CheckSchemaType(\"oops\"))\n}\n\nfunc TestTransToValidSchemeType(t *testing.T) {\n\tt.Parallel()\n\n\tassert.Equal(t, TransToValidSchemeType(\"uint\"), INTEGER)\n\tassert.Equal(t, TransToValidSchemeType(\"uint32\"), INTEGER)\n\tassert.Equal(t, TransToValidSchemeType(\"uint64\"), INTEGER)\n\tassert.Equal(t, TransToValidSchemeType(\"float32\"), NUMBER)\n\tassert.Equal(t, TransToValidSchemeType(\"bool\"), BOOLEAN)\n\tassert.Equal(t, TransToValidSchemeType(\"string\"), STRING)\n\n\t// should accept any type, due to user defined types\n\tother := \"oops\"\n\tassert.Equal(t, TransToValidSchemeType(other), other)\n}\n\nfunc TestTransToValidCollectionFormat(t *testing.T) {\n\tt.Parallel()\n\n\tassert.Equal(t, TransToValidCollectionFormat(\"csv\"), \"csv\")\n\tassert.Equal(t, TransToValidCollectionFormat(\"multi\"), \"multi\")\n\tassert.Equal(t, TransToValidCollectionFormat(\"pipes\"), \"pipes\")\n\tassert.Equal(t, TransToValidCollectionFormat(\"tsv\"), \"tsv\")\n\tassert.Equal(t, TransToValidSchemeType(\"string\"), STRING)\n\n\t// should accept any type, due to user defined types\n\tassert.Equal(t, TransToValidCollectionFormat(\"oops\"), \"\")\n}\n\nfunc TestIsGolangPrimitiveType(t *testing.T) {\n\tt.Parallel()\n\n\tassert.Equal(t, IsGolangPrimitiveType(\"uint\"), true)\n\tassert.Equal(t, IsGolangPrimitiveType(\"int\"), true)\n\tassert.Equal(t, IsGolangPrimitiveType(\"uint8\"), true)\n\tassert.Equal(t, IsGolangPrimitiveType(\"uint16\"), true)\n\tassert.Equal(t, IsGolangPrimitiveType(\"int16\"), true)\n\tassert.Equal(t, IsGolangPrimitiveType(\"byte\"), true)\n\tassert.Equal(t, IsGolangPrimitiveType(\"uint32\"), true)\n\tassert.Equal(t, IsGolangPrimitiveType(\"int32\"), true)\n\tassert.Equal(t, IsGolangPrimitiveType(\"rune\"), true)\n\tassert.Equal(t, IsGolangPrimitiveType(\"uint64\"), true)\n\tassert.Equal(t, IsGolangPrimitiveType(\"int64\"), true)\n\tassert.Equal(t, IsGolangPrimitiveType(\"float32\"), true)\n\tassert.Equal(t, IsGolangPrimitiveType(\"float64\"), true)\n\tassert.Equal(t, IsGolangPrimitiveType(\"bool\"), true)\n\tassert.Equal(t, IsGolangPrimitiveType(\"string\"), true)\n\n\tassert.Equal(t, IsGolangPrimitiveType(\"oops\"), false)\n}\n\nfunc TestIsSimplePrimitiveType(t *testing.T) {\n\tt.Parallel()\n\n\tassert.Equal(t, IsSimplePrimitiveType(\"string\"), true)\n\tassert.Equal(t, IsSimplePrimitiveType(\"number\"), true)\n\tassert.Equal(t, IsSimplePrimitiveType(\"integer\"), true)\n\tassert.Equal(t, IsSimplePrimitiveType(\"boolean\"), true)\n\n\tassert.Equal(t, IsSimplePrimitiveType(\"oops\"), false)\n}\n\nfunc TestBuildCustomSchema(t *testing.T) {\n\tt.Parallel()\n\n\tvar (\n\t\tschema *spec.Schema\n\t\terr    error\n\t)\n\n\tschema, err = BuildCustomSchema([]string{})\n\tassert.NoError(t, err)\n\tassert.Nil(t, schema)\n\n\tschema, err = BuildCustomSchema([]string{\"primitive\"})\n\tassert.Error(t, err)\n\tassert.Nil(t, schema)\n\n\tschema, err = BuildCustomSchema([]string{\"primitive\", \"oops\"})\n\tassert.Error(t, err)\n\tassert.Nil(t, schema)\n\n\tschema, err = BuildCustomSchema([]string{\"primitive\", \"string\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, schema.SchemaProps.Type, spec.StringOrArray{\"string\"})\n\n\tschema, err = BuildCustomSchema([]string{\"array\"})\n\tassert.Error(t, err)\n\tassert.Nil(t, schema)\n\n\tschema, err = BuildCustomSchema([]string{\"array\", \"oops\"})\n\tassert.Error(t, err)\n\tassert.Nil(t, schema)\n\n\tschema, err = BuildCustomSchema([]string{\"array\", \"string\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, schema.SchemaProps.Type, spec.StringOrArray{\"array\"})\n\tassert.Equal(t, schema.SchemaProps.Items.Schema.SchemaProps.Type, spec.StringOrArray{\"string\"})\n\n\tschema, err = BuildCustomSchema([]string{\"object\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, schema.SchemaProps.Type, spec.StringOrArray{\"object\"})\n\n\tschema, err = BuildCustomSchema([]string{\"object\", \"oops\"})\n\tassert.Error(t, err)\n\tassert.Nil(t, schema)\n\n\tschema, err = BuildCustomSchema([]string{\"object\", \"string\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, schema.SchemaProps.Type, spec.StringOrArray{\"object\"})\n\tassert.Equal(t, schema.SchemaProps.AdditionalProperties.Schema.Type, spec.StringOrArray{\"string\"})\n}\n\nfunc TestIsNumericType(t *testing.T) {\n\tt.Parallel()\n\n\tassert.Equal(t, IsNumericType(INTEGER), true)\n\tassert.Equal(t, IsNumericType(NUMBER), true)\n\n\tassert.Equal(t, IsNumericType(STRING), false)\n}\n\nfunc TestIsInterfaceLike(t *testing.T) {\n\tt.Parallel()\n\n\tassert.Equal(t, IsInterfaceLike(ERROR), true)\n\tassert.Equal(t, IsInterfaceLike(ANY), true)\n\n\tassert.Equal(t, IsInterfaceLike(STRING), false)\n}\n"
        },
        {
          "name": "spec.go",
          "type": "blob",
          "size": 1.42578125,
          "content": "package swag\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"strings\"\n\t\"text/template\"\n)\n\n// Spec holds exported Swagger Info so clients can modify it.\ntype Spec struct {\n\tVersion          string\n\tHost             string\n\tBasePath         string\n\tSchemes          []string\n\tTitle            string\n\tDescription      string\n\tInfoInstanceName string\n\tSwaggerTemplate  string\n\tLeftDelim        string\n\tRightDelim       string\n}\n\n// ReadDoc parses SwaggerTemplate into swagger document.\nfunc (i *Spec) ReadDoc() string {\n\ti.Description = strings.ReplaceAll(i.Description, \"\\n\", \"\\\\n\")\n\n\ttpl := template.New(\"swagger_info\").Funcs(template.FuncMap{\n\t\t\"marshal\": func(v interface{}) string {\n\t\t\ta, _ := json.Marshal(v)\n\n\t\t\treturn string(a)\n\t\t},\n\t\t\"escape\": func(v interface{}) string {\n\t\t\t// escape tabs\n\t\t\tvar str = strings.ReplaceAll(v.(string), \"\\t\", \"\\\\t\")\n\t\t\t// replace \" with \\\", and if that results in \\\\\", replace that with \\\\\\\"\n\t\t\tstr = strings.ReplaceAll(str, \"\\\"\", \"\\\\\\\"\")\n\n\t\t\treturn strings.ReplaceAll(str, \"\\\\\\\\\\\"\", \"\\\\\\\\\\\\\\\"\")\n\t\t},\n\t})\n\n\tif i.LeftDelim != \"\" && i.RightDelim != \"\" {\n\t\ttpl = tpl.Delims(i.LeftDelim, i.RightDelim)\n\t}\n\n\tparsed, err := tpl.Parse(i.SwaggerTemplate)\n\tif err != nil {\n\t\treturn i.SwaggerTemplate\n\t}\n\n\tvar doc bytes.Buffer\n\tif err = parsed.Execute(&doc, i); err != nil {\n\t\treturn i.SwaggerTemplate\n\t}\n\n\treturn doc.String()\n}\n\n// InstanceName returns Spec instance name.\nfunc (i *Spec) InstanceName() string {\n\treturn i.InfoInstanceName\n}\n"
        },
        {
          "name": "spec_test.go",
          "type": "blob",
          "size": 4.40234375,
          "content": "package swag\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSpec_InstanceName(t *testing.T) {\n\ttype fields struct {\n\t\tVersion          string\n\t\tHost             string\n\t\tBasePath         string\n\t\tSchemes          []string\n\t\tTitle            string\n\t\tDescription      string\n\t\tInfoInstanceName string\n\t\tSwaggerTemplate  string\n\t}\n\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\twant   string\n\t}{\n\t\t{\n\t\t\tname: \"TestInstanceNameCorrect\",\n\t\t\tfields: fields{\n\t\t\t\tVersion:          \"1.0\",\n\t\t\t\tHost:             \"localhost:8080\",\n\t\t\t\tBasePath:         \"/\",\n\t\t\t\tInfoInstanceName: \"TestInstanceName1\",\n\t\t\t},\n\t\t\twant: \"TestInstanceName1\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdoc := Spec{\n\t\t\t\tVersion:          tt.fields.Version,\n\t\t\t\tHost:             tt.fields.Host,\n\t\t\t\tBasePath:         tt.fields.BasePath,\n\t\t\t\tSchemes:          tt.fields.Schemes,\n\t\t\t\tTitle:            tt.fields.Title,\n\t\t\t\tDescription:      tt.fields.Description,\n\t\t\t\tInfoInstanceName: tt.fields.InfoInstanceName,\n\t\t\t\tSwaggerTemplate:  tt.fields.SwaggerTemplate,\n\t\t\t}\n\n\t\t\tassert.Equal(t, tt.want, doc.InstanceName())\n\t\t})\n\t}\n}\n\nfunc TestSpec_ReadDoc(t *testing.T) {\n\ttype fields struct {\n\t\tVersion          string\n\t\tHost             string\n\t\tBasePath         string\n\t\tSchemes          []string\n\t\tTitle            string\n\t\tDescription      string\n\t\tInfoInstanceName string\n\t\tSwaggerTemplate  string\n\t\tLeftDelim        string\n\t\tRightDelim       string\n\t}\n\n\ttests := []struct {\n\t\tname   string\n\t\tfields fields\n\t\twant   string\n\t}{\n\t\t{\n\t\t\tname: \"TestReadDocCorrect\",\n\t\t\tfields: fields{\n\t\t\t\tVersion:          \"1.0\",\n\t\t\t\tHost:             \"localhost:8080\",\n\t\t\t\tBasePath:         \"/\",\n\t\t\t\tInfoInstanceName: \"TestInstanceName\",\n\t\t\t\tSwaggerTemplate: `{\n\t\t\t\"swagger\": \"2.0\",\n\t\t\t\"info\": {\n\t\t\t\t\"description\": \"{{escape .Description}}\",\n\t\t\t\t\"title\": \"{{.Title}}\",\n\t\t\t\t\"version\": \"{{.Version}}\"\n\t\t\t},\n\t\t\t\"host\": \"{{.Host}}\",\n\t\t\t\"basePath\": \"{{.BasePath}}\",\n\t\t}`,\n\t\t\t},\n\t\t\twant: \"{\" +\n\t\t\t\t\"\\n\\t\\t\\t\\\"swagger\\\": \\\"2.0\\\",\" +\n\t\t\t\t\"\\n\\t\\t\\t\\\"info\\\": {\" +\n\t\t\t\t\"\\n\\t\\t\\t\\t\\\"description\\\": \\\"\\\",\\n\\t\\t\\t\\t\\\"\" +\n\t\t\t\t\"title\\\": \\\"\\\",\" +\n\t\t\t\t\"\\n\\t\\t\\t\\t\\\"version\\\": \\\"1.0\\\"\" +\n\t\t\t\t\"\\n\\t\\t\\t},\" +\n\t\t\t\t\"\\n\\t\\t\\t\\\"host\\\": \\\"localhost:8080\\\",\" +\n\t\t\t\t\"\\n\\t\\t\\t\\\"basePath\\\": \\\"/\\\",\" +\n\t\t\t\t\"\\n\\t\\t}\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestReadDocMarshalTrigger\",\n\t\t\tfields: fields{\n\t\t\t\tVersion:          \"1.0\",\n\t\t\t\tHost:             \"localhost:8080\",\n\t\t\t\tBasePath:         \"/\",\n\t\t\t\tInfoInstanceName: \"TestInstanceName\",\n\t\t\t\tSwaggerTemplate:  \"{{ marshal .Version }}\",\n\t\t\t},\n\t\t\twant: \"\\\"1.0\\\"\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestReadDocParseError\",\n\t\t\tfields: fields{\n\t\t\t\tVersion:          \"1.0\",\n\t\t\t\tHost:             \"localhost:8080\",\n\t\t\t\tBasePath:         \"/\",\n\t\t\t\tInfoInstanceName: \"TestInstanceName\",\n\t\t\t\tSwaggerTemplate:  \"{{ ..Version }}\",\n\t\t\t},\n\t\t\twant: \"{{ ..Version }}\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestReadDocExecuteError\",\n\t\t\tfields: fields{\n\t\t\t\tVersion:          \"1.0\",\n\t\t\t\tHost:             \"localhost:8080\",\n\t\t\t\tBasePath:         \"/\",\n\t\t\t\tInfoInstanceName: \"TestInstanceName\",\n\t\t\t\tSwaggerTemplate:  \"{{ .Schemesa }}\",\n\t\t\t},\n\t\t\twant: \"{{ .Schemesa }}\",\n\t\t},\n\t\t{\n\t\t\tname: \"TestReadDocCustomDelims\",\n\t\t\tfields: fields{\n\t\t\t\tVersion:          \"1.0\",\n\t\t\t\tHost:             \"localhost:8080\",\n\t\t\t\tBasePath:         \"/\",\n\t\t\t\tInfoInstanceName: \"TestInstanceName\",\n\t\t\t\tSwaggerTemplate: `{\n\t\t\t\"swagger\": \"2.0\",\n\t\t\t\"info\": {\n\t\t\t\t\"description\": \"{%escape .Description%}\",\n\t\t\t\t\"title\": \"{%.Title%}\",\n\t\t\t\t\"version\": \"{%.Version%}\"\n\t\t\t},\n\t\t\t\"host\": \"{%.Host%}\",\n\t\t\t\"basePath\": \"{%.BasePath%}\",\n\t\t}`,\n\t\t\t\tLeftDelim:  \"{%\",\n\t\t\t\tRightDelim: \"%}\",\n\t\t\t},\n\t\t\twant: \"{\" +\n\t\t\t\t\"\\n\\t\\t\\t\\\"swagger\\\": \\\"2.0\\\",\" +\n\t\t\t\t\"\\n\\t\\t\\t\\\"info\\\": {\" +\n\t\t\t\t\"\\n\\t\\t\\t\\t\\\"description\\\": \\\"\\\",\\n\\t\\t\\t\\t\\\"\" +\n\t\t\t\t\"title\\\": \\\"\\\",\" +\n\t\t\t\t\"\\n\\t\\t\\t\\t\\\"version\\\": \\\"1.0\\\"\" +\n\t\t\t\t\"\\n\\t\\t\\t},\" +\n\t\t\t\t\"\\n\\t\\t\\t\\\"host\\\": \\\"localhost:8080\\\",\" +\n\t\t\t\t\"\\n\\t\\t\\t\\\"basePath\\\": \\\"/\\\",\" +\n\t\t\t\t\"\\n\\t\\t}\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdoc := Spec{\n\t\t\t\tVersion:          tt.fields.Version,\n\t\t\t\tHost:             tt.fields.Host,\n\t\t\t\tBasePath:         tt.fields.BasePath,\n\t\t\t\tSchemes:          tt.fields.Schemes,\n\t\t\t\tTitle:            tt.fields.Title,\n\t\t\t\tDescription:      tt.fields.Description,\n\t\t\t\tInfoInstanceName: tt.fields.InfoInstanceName,\n\t\t\t\tSwaggerTemplate:  tt.fields.SwaggerTemplate,\n\t\t\t\tLeftDelim:        tt.fields.LeftDelim,\n\t\t\t\tRightDelim:       tt.fields.RightDelim,\n\t\t\t}\n\n\t\t\tassert.Equal(t, tt.want, doc.ReadDoc())\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "swagger.go",
          "type": "blob",
          "size": 1.3779296875,
          "content": "package swag\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n)\n\n// Name is a unique name be used to register swag instance.\nconst Name = \"swagger\"\n\nvar (\n\tswaggerMu sync.RWMutex\n\tswags     map[string]Swagger\n)\n\n// Swagger is an interface to read swagger document.\ntype Swagger interface {\n\tReadDoc() string\n}\n\n// Register registers swagger for given name.\nfunc Register(name string, swagger Swagger) {\n\tswaggerMu.Lock()\n\tdefer swaggerMu.Unlock()\n\n\tif swagger == nil {\n\t\tpanic(\"swagger is nil\")\n\t}\n\n\tif swags == nil {\n\t\tswags = make(map[string]Swagger)\n\t}\n\n\tif _, ok := swags[name]; ok {\n\t\tpanic(\"Register called twice for swag: \" + name)\n\t}\n\n\tswags[name] = swagger\n}\n\n// GetSwagger returns the swagger instance for given name.\n// If not found, returns nil.\nfunc GetSwagger(name string) Swagger {\n\tswaggerMu.RLock()\n\tdefer swaggerMu.RUnlock()\n\n\treturn swags[name]\n}\n\n// ReadDoc reads swagger document. An optional name parameter can be passed to read a specific document.\n// The default name is \"swagger\".\nfunc ReadDoc(optionalName ...string) (string, error) {\n\tswaggerMu.RLock()\n\tdefer swaggerMu.RUnlock()\n\n\tif swags == nil {\n\t\treturn \"\", errors.New(\"no swag has yet been registered\")\n\t}\n\n\tname := Name\n\tif len(optionalName) != 0 && optionalName[0] != \"\" {\n\t\tname = optionalName[0]\n\t}\n\n\tswag, ok := swags[name]\n\tif !ok {\n\t\treturn \"\", fmt.Errorf(\"no swag named \\\"%s\\\" was registered\", name)\n\t}\n\n\treturn swag.ReadDoc(), nil\n}\n"
        },
        {
          "name": "swagger_test.go",
          "type": "blob",
          "size": 6.0654296875,
          "content": "package swag\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nvar doc = `{\n    \"swagger\": \"2.0\",\n    \"info\": {\n        \"description\": \"This is a sample server Petstore server.\",\n        \"title\": \"Swagger Example API\",\n        \"termsOfService\": \"http://swagger.io/terms/\",\n        \"contact\": {\n            \"name\": \"API Support\",\n            \"url\": \"http://www.swagger.io/support\",\n            \"email\": \"support@swagger.io\"\n        },\n        \"license\": {\n            \"name\": \"Apache 2.0\",\n            \"url\": \"http://www.apache.org/licenses/LICENSE-2.0.html\"\n        },\n        \"version\": \"1.0\"\n    },\n    \"host\": \"petstore.swagger.io\",\n    \"basePath\": \"/v2\",\n    \"paths\": {\n        \"/testapi/get-string-by-int/{some_id}\": {\n            \"get\": {\n                \"description\": \"get string by ID\",\n                \"consumes\": [\n                    \"application/json\"\n                ],\n                \"produces\": [\n                    \"application/json\"\n                ],\n                \"summary\": \"Add a new pet to the store\",\n                \"parameters\": [\n                    {\n                        \"description\": \"Some ID\",\n                        \"name\": \"some_id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"int\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"ok\",\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    },\n                    \"400\": {\n                        \"description\": \"We need ID!!\",\n                        \"schema\": {\n                            \"type\": \"object\",\n                            \"$ref\": \"#/definitions/web.APIError\"\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"Can not find ID\",\n                        \"schema\": {\n                            \"type\": \"object\",\n                            \"$ref\": \"#/definitions/web.APIError\"\n                        }\n                    }\n                }\n            }\n        },\n        \"/testapi/get-struct-array-by-string/{some_id}\": {\n            \"get\": {\n                \"description\": \"get struct array by ID\",\n                \"consumes\": [\n                    \"application/json\"\n                ],\n                \"produces\": [\n                    \"application/json\"\n                ],\n                \"parameters\": [\n                    {\n                        \"description\": \"Some ID\",\n                        \"name\": \"some_id\",\n                        \"in\": \"path\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    },\n                    {\n                        \"description\": \"Offset\",\n                        \"name\": \"offset\",\n                        \"in\": \"query\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"int\"\n                        }\n                    },\n                    {\n                        \"description\": \"Offset\",\n                        \"name\": \"limit\",\n                        \"in\": \"query\",\n                        \"required\": true,\n                        \"schema\": {\n                            \"type\": \"int\"\n                        }\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"ok\",\n                        \"schema\": {\n                            \"type\": \"string\"\n                        }\n                    },\n                    \"400\": {\n                        \"description\": \"We need ID!!\",\n                        \"schema\": {\n                            \"type\": \"object\",\n                            \"$ref\": \"#/definitions/web.APIError\"\n                        }\n                    },\n                    \"404\": {\n                        \"description\": \"Can not find ID\",\n                        \"schema\": {\n                            \"type\": \"object\",\n                            \"$ref\": \"#/definitions/web.APIError\"\n                        }\n                    }\n                }\n            }\n        }\n    },\n    \"definitions\": {\n        \"web.APIError\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"ErrorCode\": {\n                    \"type\": \"int\"\n                },\n                \"ErrorMessage\": {\n                    \"type\": \"string\"\n                }\n            }\n        }\n    },\n    \"securityDefinitions\": {\n        \"ApiKey\": {\n            \"description: \"some\",\n            \"type\": \"apiKey\",\n            \"name\": \"X-API-KEY\",\n            \"in\": \"header\"\n        }\n    }\n}`\n\ntype s struct{}\n\nfunc (s *s) ReadDoc() string {\n\treturn doc\n}\n\nfunc TestRegister(t *testing.T) {\n\tsetup()\n\tRegister(Name, &s{})\n\td, _ := ReadDoc()\n\tassert.Equal(t, doc, d)\n}\n\nfunc TestRegisterByName(t *testing.T) {\n\tsetup()\n\tRegister(\"another_name\", &s{})\n\td, _ := ReadDoc(\"another_name\")\n\tassert.Equal(t, doc, d)\n}\n\nfunc TestRegisterMultiple(t *testing.T) {\n\tsetup()\n\tRegister(Name, &s{})\n\tRegister(\"another_name\", &s{})\n\td1, _ := ReadDoc(Name)\n\td2, _ := ReadDoc(\"another_name\")\n\tassert.Equal(t, doc, d1)\n\tassert.Equal(t, doc, d2)\n}\n\nfunc TestReadDocBeforeRegistered(t *testing.T) {\n\tsetup()\n\t_, err := ReadDoc()\n\tassert.Error(t, err)\n}\n\nfunc TestReadDocWithInvalidName(t *testing.T) {\n\tsetup()\n\tRegister(Name, &s{})\n\t_, err := ReadDoc(\"invalid\")\n\tassert.Error(t, err)\n}\n\nfunc TestNilRegister(t *testing.T) {\n\tsetup()\n\tvar swagger Swagger\n\tassert.Panics(t, func() {\n\t\tRegister(Name, swagger)\n\t})\n}\n\nfunc TestCalledTwicelRegister(t *testing.T) {\n\tsetup()\n\tassert.Panics(t, func() {\n\t\tRegister(Name, &s{})\n\t\tRegister(Name, &s{})\n\t})\n}\n\nfunc setup() {\n\tswags = nil\n}\n\nfunc TestGetSwagger(t *testing.T) {\n\tsetup()\n\tinstance := &s{}\n\tRegister(Name, instance)\n\tswagger := GetSwagger(Name)\n\tassert.Equal(t, instance, swagger)\n\n\tswagger = GetSwagger(\"invalid\")\n\tassert.Nil(t, swagger)\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "types.go",
          "type": "blob",
          "size": 2.6015625,
          "content": "package swag\n\nimport (\n\t\"go/ast\"\n\t\"go/token\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/go-openapi/spec\"\n)\n\n// Schema parsed schema.\ntype Schema struct {\n\t*spec.Schema        //\n\tPkgPath      string // package import path used to rename Name of a definition int case of conflict\n\tName         string // Name in definitions\n}\n\n// TypeSpecDef the whole information of a typeSpec.\ntype TypeSpecDef struct {\n\t// ast file where TypeSpec is\n\tFile *ast.File\n\n\t// the TypeSpec of this type definition\n\tTypeSpec *ast.TypeSpec\n\n\tEnums []EnumValue\n\n\t// path of package starting from under ${GOPATH}/src or from module path in go.mod\n\tPkgPath    string\n\tParentSpec ast.Decl\n\n\tSchemaName string\n\n\tNotUnique bool\n}\n\n// Name the name of the typeSpec.\nfunc (t *TypeSpecDef) Name() string {\n\tif t.TypeSpec != nil && t.TypeSpec.Name != nil {\n\t\treturn t.TypeSpec.Name.Name\n\t}\n\n\treturn \"\"\n}\n\n// TypeName the type name of the typeSpec.\nfunc (t *TypeSpecDef) TypeName() string {\n\tif ignoreNameOverride(t.TypeSpec.Name.Name) {\n\t\treturn t.TypeSpec.Name.Name[1:]\n\t}\n\n\tvar names []string\n\tif t.NotUnique {\n\t\tpkgPath := strings.Map(func(r rune) rune {\n\t\t\tif r == '\\\\' || r == '/' || r == '.' {\n\t\t\t\treturn '_'\n\t\t\t}\n\t\t\treturn r\n\t\t}, t.PkgPath)\n\t\tnames = append(names, pkgPath)\n\t} else if t.File != nil {\n\t\tnames = append(names, t.File.Name.Name)\n\t}\n\tif parentFun, ok := (t.ParentSpec).(*ast.FuncDecl); ok && parentFun != nil {\n\t\tnames = append(names, parentFun.Name.Name)\n\t}\n\tnames = append(names, t.TypeSpec.Name.Name)\n\treturn fullTypeName(names...)\n}\n\n// FullPath return the full path of the typeSpec.\nfunc (t *TypeSpecDef) FullPath() string {\n\treturn t.PkgPath + \".\" + t.Name()\n}\n\nconst regexCaseInsensitive = \"(?i)\"\n\nvar reTypeName = regexp.MustCompile(regexCaseInsensitive + `^@name\\s+(\\S+)`)\n\nfunc (t *TypeSpecDef) Alias() string {\n\tif t.TypeSpec.Comment == nil {\n\t\treturn \"\"\n\t}\n\n\t// get alias from comment '// @name '\n\tfor _, comment := range t.TypeSpec.Comment.List {\n\t\ttrimmedComment := strings.TrimSpace(strings.TrimLeft(comment.Text, \"/\"))\n\t\ttexts := reTypeName.FindStringSubmatch(trimmedComment)\n\t\tif len(texts) > 1 {\n\t\t\treturn texts[1]\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\nfunc (t *TypeSpecDef) SetSchemaName() {\n\tif alias := t.Alias(); alias != \"\" {\n\t\tt.SchemaName = alias\n\t\treturn\n\t}\n\n\tt.SchemaName = t.TypeName()\n}\n\n// AstFileInfo information of an ast.File.\ntype AstFileInfo struct {\n\t//FileSet the FileSet object which is used to parse this go source file\n\tFileSet *token.FileSet\n\n\t// File ast.File\n\tFile *ast.File\n\n\t// Path the path of the ast.File\n\tPath string\n\n\t// PackagePath package import path of the ast.File\n\tPackagePath string\n\n\t// ParseFlag determine what to parse\n\tParseFlag ParseFlag\n}\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 1.4404296875,
          "content": "package swag\n\nimport \"unicode\"\n\n// FieldsFunc split a string s by a func splitter into max n parts\nfunc FieldsFunc(s string, f func(rune2 rune) bool, n int) []string {\n\t// A span is used to record a slice of s of the form s[start:end].\n\t// The start index is inclusive and the end index is exclusive.\n\ttype span struct {\n\t\tstart int\n\t\tend   int\n\t}\n\tspans := make([]span, 0, 32)\n\n\t// Find the field start and end indices.\n\t// Doing this in a separate pass (rather than slicing the string s\n\t// and collecting the result substrings right away) is significantly\n\t// more efficient, possibly due to cache effects.\n\tstart := -1 // valid span start if >= 0\n\tfor end, rune := range s {\n\t\tif f(rune) {\n\t\t\tif start >= 0 {\n\t\t\t\tspans = append(spans, span{start, end})\n\t\t\t\t// Set start to a negative value.\n\t\t\t\t// Note: using -1 here consistently and reproducibly\n\t\t\t\t// slows down this code by a several percent on amd64.\n\t\t\t\tstart = ^start\n\t\t\t}\n\t\t} else {\n\t\t\tif start < 0 {\n\t\t\t\tstart = end\n\t\t\t\tif n > 0 && len(spans)+1 >= n {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Last field might end at EOF.\n\tif start >= 0 {\n\t\tspans = append(spans, span{start, len(s)})\n\t}\n\n\t// Create strings from recorded field indices.\n\ta := make([]string, len(spans))\n\tfor i, span := range spans {\n\t\ta[i] = s[span.start:span.end]\n\t}\n\treturn a\n}\n\n// FieldsByAnySpace split a string s by any space character into max n parts\nfunc FieldsByAnySpace(s string, n int) []string {\n\treturn FieldsFunc(s, unicode.IsSpace, n)\n}\n"
        },
        {
          "name": "utils_test.go",
          "type": "blob",
          "size": 0.6171875,
          "content": "package swag\n\nimport (\n\t\"github.com/stretchr/testify/assert\"\n\t\"testing\"\n)\n\nfunc TestFieldsByAnySpace(t *testing.T) {\n\ttype args struct {\n\t\ts string\n\t\tn int\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []string\n\t}{\n\t\t{\"test1\",\n\t\t\targs{\n\t\t\t\t\"\taa\tbb\tcc dd \t\tff\",\n\t\t\t\t2,\n\t\t\t},\n\t\t\t[]string{\"aa\", \"bb\\tcc dd \\t\\tff\"},\n\t\t},\n\t\t{\"test2\",\n\t\t\targs{\n\t\t\t\t`\taa\t\"bb\tcc dd \t\tff\"`,\n\t\t\t\t2,\n\t\t\t},\n\t\t\t[]string{\"aa\", `\"bb\tcc dd \t\tff\"`},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tassert.Equalf(t, tt.want, FieldsByAnySpace(tt.args.s, tt.args.n), \"FieldsByAnySpace(%v,  %v)\", tt.args.s, tt.args.n)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.05859375,
          "content": "package swag\n\n// Version of swag.\nconst Version = \"v1.16.4\"\n"
        }
      ]
    }
  ]
}