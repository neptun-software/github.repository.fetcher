{
  "metadata": {
    "timestamp": 1736568066408,
    "page": 203,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "chromedp/chromedp",
      "stars": 11274,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.107421875,
          "content": "out.txt\nout*.txt\nold*.txt\ncdp-*.log\ncdp-*.txt\n*.out\n\n/chromedp.test\n/chromedp.test.exe\n\n/*.jpeg\n/*.png\n/*.pdf\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05859375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016-2024 Kenneth Shaw\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.080078125,
          "content": "# About chromedp\n\nPackage `chromedp` is a faster, simpler way to drive browsers supporting the\n[Chrome DevTools Protocol][devtools-protocol] in Go without external dependencies.\n\n[![Unit Tests][chromedp-ci-status]][chromedp-ci]\n[![Go Reference][goref-chromedp-status]][goref-chromedp]\n[![Releases][release-status]][releases]\n\n## Installing\n\nInstall in the usual Go way:\n\n```sh\n$ go get -u github.com/chromedp/chromedp\n```\n\n## Examples\n\nRefer to the [Go reference][goref-chromedp] for the documentation and examples.\nAdditionally, the [examples][chromedp-examples] repository contains more\nexamples on complex actions, and other common high-level tasks such as taking\nfull page screenshots.\n\n## Frequently Asked Questions\n\n> I can't see any Chrome browser window\n\nBy default, Chrome is run in headless mode. See `DefaultExecAllocatorOptions`, and\n[an example][goref-chromedp-exec-allocator] to override the default options.\n\n> I'm seeing \"context canceled\" errors\n\nWhen the connection to the browser is lost, `chromedp` cancels the context, and\nit may result in this error. This occurs, for example, if the browser is closed\nmanually, or if the browser process has been killed or otherwise terminated.\n\n> Chrome exits as soon as my Go program finishes\n\nOn Linux, `chromedp` is configured to avoid leaking resources by force-killing\nany started Chrome child processes. If you need to launch a long-running Chrome\ninstance, manually start Chrome and connect using `RemoteAllocator`.\n\n> Executing an action without `Run` results in \"invalid context\"\n\nBy default, a `chromedp` context does not have an executor, however one can be\nspecified manually if necessary; see [issue #326][github-326]\nfor an example.\n\n> I can't use an `Action` with `Run` because it returns many values\n\nWrap it with an `ActionFunc`:\n\n```go\nctx, cancel := chromedp.NewContext(context.Background())\ndefer cancel()\nchromedp.Run(ctx, chromedp.ActionFunc(func(ctx context.Context) error {\n\t_, err := domain.SomeAction().Do(ctx)\n\treturn err\n}))\n```\n\n> I want to use chromedp on a headless environment\n\nThe simplest way is to run the Go program that uses chromedp inside the\n[chromedp/headless-shell][docker-headless-shell] image. That image contains\n`headless-shell`, a smaller headless build of Chrome, which `chromedp` is able\nto find out of the box.\n\n## Resources\n\n* [`headless-shell`][docker-headless-shell] - A build of `headless-shell` that is used for testing `chromedp`\n* [chromedp: A New Way to Drive the Web][gophercon-2017-presentation] - GopherCon SG 2017 talk\n* [Chrome DevTools Protocol][devtools-protocol] - Chrome DevTools Protocol reference\n* [chromedp examples][chromedp-examples] - More complicated examples for `chromedp`\n* [`github.com/chromedp/cdproto`][goref-cdproto] - Go reference for the generated Chrome DevTools Protocol API\n* [`github.com/chromedp/pdlgen`][chromedp-pdlgen] - tool used to generate `cdproto`\n* [`github.com/chromedp/chromedp-proxy`][chromedp-proxy] - a simple CDP proxy for logging CDP clients and browsers\n\n[chromedp-ci]: https://github.com/chromedp/chromedp/actions/workflows/test.yml (Test CI)\n[chromedp-ci-status]: https://github.com/chromedp/chromedp/actions/workflows/test.yml/badge.svg (Test CI)\n[chromedp-examples]: https://github.com/chromedp/examples\n[chromedp-pdlgen]: https://github.com/chromedp/pdlgen\n[chromedp-proxy]: https://github.com/chromedp/chromedp-proxy\n[devtools-protocol]: https://chromedevtools.github.io/devtools-protocol/\n[docker-headless-shell]: https://hub.docker.com/r/chromedp/headless-shell/\n[github-326]: https://github.com/chromedp/chromedp/issues/326\n[gophercon-2017-presentation]: https://www.youtube.com/watch?v=_7pWCg94sKw\n[goref-cdproto]: https://pkg.go.dev/github.com/chromedp/cdproto\n[goref-chromedp-exec-allocator]: https://pkg.go.dev/github.com/chromedp/chromedp#example-ExecAllocator\n[goref-chromedp]: https://pkg.go.dev/github.com/chromedp/chromedp\n[goref-chromedp-status]: https://pkg.go.dev/badge/github.com/chromedp/chromedp.svg\n[release-status]: https://img.shields.io/github/v/release/chromedp/chromedp?display_name=tag&sort=semver (Latest Release)\n[releases]: https://github.com/chromedp/chromedp/releases (Releases)\n"
        },
        {
          "name": "allocate.go",
          "type": "blob",
          "size": 18.2958984375,
          "content": "package chromedp\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n)\n\n// An Allocator is responsible for creating and managing a number of browsers.\n//\n// This interface abstracts away how the browser process is actually run. For\n// example, an Allocator implementation may reuse browser processes, or connect\n// to already-running browsers on remote machines.\ntype Allocator interface {\n\t// Allocate creates a new browser. It can be cancelled via the provided\n\t// context, at which point all the resources used by the browser (such\n\t// as temporary directories) will be freed.\n\tAllocate(context.Context, ...BrowserOption) (*Browser, error)\n\n\t// Wait blocks until an allocator has freed all of its resources.\n\t// Cancelling the allocator context will already perform this operation,\n\t// so normally there's no need to call Wait directly.\n\tWait()\n}\n\n// setupExecAllocator is similar to NewExecAllocator, but it allows NewContext\n// to create the allocator without the unnecessary context layer.\nfunc setupExecAllocator(opts ...ExecAllocatorOption) *ExecAllocator {\n\tep := &ExecAllocator{\n\t\tinitFlags:        make(map[string]interface{}),\n\t\twsURLReadTimeout: 20 * time.Second,\n\t}\n\tfor _, o := range opts {\n\t\to(ep)\n\t}\n\tif ep.execPath == \"\" {\n\t\tep.execPath = findExecPath()\n\t}\n\treturn ep\n}\n\n// DefaultExecAllocatorOptions are the ExecAllocator options used by NewContext\n// if the given parent context doesn't have an allocator set up. Do not modify\n// this global; instead, use NewExecAllocator. See [ExampleExecAllocator].\n//\n// [ExampleExecAllocator]: https://pkg.go.dev/github.com/chromedp/chromedp#example-ExecAllocator\nvar DefaultExecAllocatorOptions = [...]ExecAllocatorOption{\n\tNoFirstRun,\n\tNoDefaultBrowserCheck,\n\tHeadless,\n\n\t// After Puppeteer's default behavior.\n\tFlag(\"disable-background-networking\", true),\n\tFlag(\"enable-features\", \"NetworkService,NetworkServiceInProcess\"),\n\tFlag(\"disable-background-timer-throttling\", true),\n\tFlag(\"disable-backgrounding-occluded-windows\", true),\n\tFlag(\"disable-breakpad\", true),\n\tFlag(\"disable-client-side-phishing-detection\", true),\n\tFlag(\"disable-default-apps\", true),\n\tFlag(\"disable-dev-shm-usage\", true),\n\tFlag(\"disable-extensions\", true),\n\tFlag(\"disable-features\", \"site-per-process,Translate,BlinkGenPropertyTrees\"),\n\tFlag(\"disable-hang-monitor\", true),\n\tFlag(\"disable-ipc-flooding-protection\", true),\n\tFlag(\"disable-popup-blocking\", true),\n\tFlag(\"disable-prompt-on-repost\", true),\n\tFlag(\"disable-renderer-backgrounding\", true),\n\tFlag(\"disable-sync\", true),\n\tFlag(\"force-color-profile\", \"srgb\"),\n\tFlag(\"metrics-recording-only\", true),\n\tFlag(\"safebrowsing-disable-auto-update\", true),\n\tFlag(\"enable-automation\", true),\n\tFlag(\"password-store\", \"basic\"),\n\tFlag(\"use-mock-keychain\", true),\n}\n\n// NewExecAllocator creates a new context set up with an ExecAllocator, suitable\n// for use with NewContext.\nfunc NewExecAllocator(parent context.Context, opts ...ExecAllocatorOption) (context.Context, context.CancelFunc) {\n\tctx, cancel := context.WithCancel(parent)\n\tc := &Context{Allocator: setupExecAllocator(opts...)}\n\n\tctx = context.WithValue(ctx, contextKey{}, c)\n\tcancelWait := func() {\n\t\tcancel()\n\t\tc.Allocator.Wait()\n\t}\n\treturn ctx, cancelWait\n}\n\n// ExecAllocatorOption is an exec allocator option.\ntype ExecAllocatorOption = func(*ExecAllocator)\n\n// ExecAllocator is an Allocator which starts new browser processes on the host\n// machine.\ntype ExecAllocator struct {\n\texecPath  string\n\tinitFlags map[string]interface{}\n\tinitEnv   []string\n\n\t// Chrome will sometimes fail to print the websocket, or run for a long\n\t// time, without properly exiting. To avoid blocking forever in those\n\t// cases, give up after a specified timeout.\n\twsURLReadTimeout time.Duration\n\n\tmodifyCmdFunc func(cmd *exec.Cmd)\n\n\twg sync.WaitGroup\n\n\tcombinedOutputWriter io.Writer\n}\n\n// allocTempDir is used to group all ExecAllocator temporary user data dirs in\n// the same location, useful for the tests. If left empty, the system's default\n// temporary directory is used.\nvar allocTempDir string\n\n// Allocate satisfies the Allocator interface.\nfunc (a *ExecAllocator) Allocate(ctx context.Context, opts ...BrowserOption) (*Browser, error) {\n\tc := FromContext(ctx)\n\tif c == nil {\n\t\treturn nil, ErrInvalidContext\n\t}\n\n\tvar args []string\n\tfor name, value := range a.initFlags {\n\t\tswitch value := value.(type) {\n\t\tcase string:\n\t\t\targs = append(args, fmt.Sprintf(\"--%s=%s\", name, value))\n\t\tcase bool:\n\t\t\tif value {\n\t\t\t\targs = append(args, fmt.Sprintf(\"--%s\", name))\n\t\t\t}\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"invalid exec pool flag\")\n\t\t}\n\t}\n\n\tremoveDir := false\n\tdataDir, ok := a.initFlags[\"user-data-dir\"].(string)\n\tif !ok {\n\t\ttempDir, err := os.MkdirTemp(allocTempDir, \"chromedp-runner\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\targs = append(args, \"--user-data-dir=\"+tempDir)\n\t\tdataDir = tempDir\n\t\tremoveDir = true\n\t}\n\tif _, ok := a.initFlags[\"no-sandbox\"]; !ok && os.Getuid() == 0 {\n\t\t// Running as root, for example in a Linux container. Chrome\n\t\t// needs --no-sandbox when running as root, so make that the\n\t\t// default, unless the user set Flag(\"no-sandbox\", false).\n\t\targs = append(args, \"--no-sandbox\")\n\t}\n\tif _, ok := a.initFlags[\"remote-debugging-port\"]; !ok {\n\t\targs = append(args, \"--remote-debugging-port=0\")\n\t}\n\n\t// Force the first page to be blank, instead of the welcome page;\n\t// --no-first-run doesn't enforce that.\n\targs = append(args, \"about:blank\")\n\n\tcmd := exec.CommandContext(ctx, a.execPath, args...)\n\tdefer func() {\n\t\tif removeDir && cmd.Process == nil {\n\t\t\t// We couldn't start the process, so we didn't get to\n\t\t\t// the goroutine that handles RemoveAll below. Remove it\n\t\t\t// to not leave an empty directory.\n\t\t\tos.RemoveAll(dataDir)\n\t\t}\n\t}()\n\n\tif a.modifyCmdFunc != nil {\n\t\ta.modifyCmdFunc(cmd)\n\t} else {\n\t\tallocateCmdOptions(cmd)\n\t}\n\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcmd.Stderr = cmd.Stdout\n\n\t// Preserve environment variables set in the (lowest priority) existing\n\t// environment, OverrideCmdFunc(), and Env (highest priority)\n\tif len(a.initEnv) > 0 || len(cmd.Env) > 0 {\n\t\tcmd.Env = append(os.Environ(), cmd.Env...)\n\t\tcmd.Env = append(cmd.Env, a.initEnv...)\n\t}\n\n\t// We must start the cmd before calling cmd.Wait, as otherwise the two\n\t// can run into a data race.\n\tif err := cmd.Start(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tcase <-c.allocated: // for this browser's root context\n\t}\n\ta.wg.Add(1) // for the entire allocator\n\tif a.combinedOutputWriter != nil {\n\t\ta.wg.Add(1) // for the io.Copy in a separate goroutine\n\t}\n\tgo func() {\n\t\t// First wait for the process to be finished.\n\t\t// TODO: do we care about this error in any scenario? if the\n\t\t// user cancelled the context and killed chrome, this will most\n\t\t// likely just be \"signal: killed\", which isn't interesting.\n\t\tcmd.Wait()\n\n\t\t// Then delete the temporary user data directory, if needed.\n\t\tif removeDir {\n\t\t\t// Sometimes files/directories are still created in the user data\n\t\t\t// directory at this point. I can not reproduce it with strace, so\n\t\t\t// the reason is unknown yet. As a workaround, we will just wait a\n\t\t\t// little while before removing the directory.\n\t\t\t<-time.After(10 * time.Millisecond)\n\t\t\tif err := os.RemoveAll(dataDir); c.cancelErr == nil {\n\t\t\t\tc.cancelErr = err\n\t\t\t}\n\t\t}\n\t\ta.wg.Done()\n\t\tclose(c.allocated)\n\t}()\n\n\tvar wsURL string\n\twsURLChan := make(chan struct{}, 1)\n\tgo func() {\n\t\twsURL, err = readOutput(stdout, a.combinedOutputWriter, a.wg.Done)\n\t\twsURLChan <- struct{}{}\n\t}()\n\tselect {\n\tcase <-wsURLChan:\n\tcase <-time.After(a.wsURLReadTimeout):\n\t\terr = errors.New(\"websocket url timeout reached\")\n\t}\n\tif err != nil {\n\t\tif a.combinedOutputWriter != nil {\n\t\t\t// There's no io.Copy goroutine to call the done func.\n\t\t\t// TODO: a cleaner way to deal with this edge case?\n\t\t\ta.wg.Done()\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tbrowser, err := NewBrowser(ctx, wsURL, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tgo func() {\n\t\t// If the browser loses connection, kill the entire process and\n\t\t// handler at once. Don't use Cancel, as that will attempt to\n\t\t// gracefully close the browser, which will hang.\n\t\t// Don't cancel if we're in the middle of a graceful Close,\n\t\t// since we want to let Chrome shut itself when it is fully\n\t\t// finished.\n\t\t<-browser.LostConnection\n\t\tselect {\n\t\tcase <-browser.closingGracefully:\n\t\tdefault:\n\t\t\tc.cancel()\n\t\t}\n\t}()\n\tbrowser.process = cmd.Process\n\tbrowser.userDataDir = dataDir\n\treturn browser, nil\n}\n\n// readOutput grabs the websocket address from chrome's output, returning as\n// soon as it is found. All read output is forwarded to forward, if non-nil.\n// done is used to signal that the asynchronous io.Copy is done, if any.\nfunc readOutput(rc io.ReadCloser, forward io.Writer, done func()) (wsURL string, _ error) {\n\tprefix := []byte(\"DevTools listening on\")\n\tvar accumulated bytes.Buffer\n\tbufr := bufio.NewReader(rc)\nreadLoop:\n\tfor {\n\t\tline, err := bufr.ReadBytes('\\n')\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"chrome failed to start:\\n%s\",\n\t\t\t\taccumulated.Bytes())\n\t\t}\n\t\tif forward != nil {\n\t\t\tif _, err := forward.Write(line); err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t}\n\n\t\tif bytes.HasPrefix(line, prefix) {\n\t\t\tline = line[len(prefix):]\n\t\t\t// use TrimSpace, to also remove \\r on Windows\n\t\t\tline = bytes.TrimSpace(line)\n\t\t\twsURL = string(line)\n\t\t\tbreak readLoop\n\t\t}\n\t\taccumulated.Write(line)\n\t}\n\tif forward == nil {\n\t\t// We don't need the process's output anymore.\n\t\trc.Close()\n\t} else {\n\t\t// Copy the rest of the output in a separate goroutine, as we\n\t\t// need to return with the websocket URL.\n\t\tgo func() {\n\t\t\tio.Copy(forward, bufr)\n\t\t\tdone()\n\t\t}()\n\t}\n\treturn wsURL, nil\n}\n\n// Wait satisfies the Allocator interface.\nfunc (a *ExecAllocator) Wait() {\n\ta.wg.Wait()\n}\n\n// ExecPath returns an ExecAllocatorOption which uses the given path to execute\n// browser processes. The given path can be an absolute path to a binary, or\n// just the name of the program to find via exec.LookPath.\nfunc ExecPath(path string) ExecAllocatorOption {\n\treturn func(a *ExecAllocator) {\n\t\t// Convert to an absolute path if possible, to avoid\n\t\t// repeated LookPath calls in each Allocate.\n\t\tif fullPath, _ := exec.LookPath(path); fullPath != \"\" {\n\t\t\ta.execPath = fullPath\n\t\t} else {\n\t\t\ta.execPath = path\n\t\t}\n\t}\n}\n\n// findExecPath tries to find the Chrome browser somewhere in the current\n// system. It finds in different locations on different OS systems.\n// It could perform a rather aggressive search. That may make it a bit slow,\n// but it will only be run when creating a new ExecAllocator.\nfunc findExecPath() string {\n\tvar locations []string\n\tswitch runtime.GOOS {\n\tcase \"darwin\":\n\t\tlocations = []string{\n\t\t\t// Mac\n\t\t\t\"/Applications/Chromium.app/Contents/MacOS/Chromium\",\n\t\t\t\"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\",\n\t\t}\n\tcase \"windows\":\n\t\tlocations = []string{\n\t\t\t// Windows\n\t\t\t\"chrome\",\n\t\t\t\"chrome.exe\", // in case PATHEXT is misconfigured\n\t\t\t`C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe`,\n\t\t\t`C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe`,\n\t\t\tfilepath.Join(os.Getenv(\"USERPROFILE\"), `AppData\\Local\\Google\\Chrome\\Application\\chrome.exe`),\n\t\t\tfilepath.Join(os.Getenv(\"USERPROFILE\"), `AppData\\Local\\Chromium\\Application\\chrome.exe`),\n\t\t}\n\tdefault:\n\t\tlocations = []string{\n\t\t\t// Unix-like\n\t\t\t\"headless_shell\",\n\t\t\t\"headless-shell\",\n\t\t\t\"chromium\",\n\t\t\t\"chromium-browser\",\n\t\t\t\"google-chrome\",\n\t\t\t\"google-chrome-stable\",\n\t\t\t\"google-chrome-beta\",\n\t\t\t\"google-chrome-unstable\",\n\t\t\t\"/usr/bin/google-chrome\",\n\t\t\t\"/usr/local/bin/chrome\",\n\t\t\t\"/snap/bin/chromium\",\n\t\t\t\"chrome\",\n\t\t}\n\t}\n\n\tfor _, path := range locations {\n\t\tfound, err := exec.LookPath(path)\n\t\tif err == nil {\n\t\t\treturn found\n\t\t}\n\t}\n\t// Fall back to something simple and sensible, to give a useful error\n\t// message.\n\treturn \"google-chrome\"\n}\n\n// Flag is a generic command line option to pass a flag to Chrome. If the value\n// is a string, it will be passed as --name=value. If it's a boolean, it will be\n// passed as --name if value is true.\nfunc Flag(name string, value interface{}) ExecAllocatorOption {\n\treturn func(a *ExecAllocator) {\n\t\ta.initFlags[name] = value\n\t}\n}\n\n// Env is a list of generic environment variables in the form NAME=value\n// to pass into the new Chrome process. These will be appended to the\n// environment of the Go process as retrieved by os.Environ.\nfunc Env(vars ...string) ExecAllocatorOption {\n\treturn func(a *ExecAllocator) {\n\t\ta.initEnv = append(a.initEnv, vars...)\n\t}\n}\n\n// ModifyCmdFunc allows for running an arbitrary function on the\n// browser exec.Cmd object. This overrides the default version\n// of the command which sends SIGKILL to any open browsers when\n// the Go program exits.\nfunc ModifyCmdFunc(f func(cmd *exec.Cmd)) ExecAllocatorOption {\n\treturn func(a *ExecAllocator) {\n\t\ta.modifyCmdFunc = f\n\t}\n}\n\n// UserDataDir is the command line option to set the user data dir.\n//\n// Note: set this option to manually set the profile directory used by Chrome.\n// When this is not set, then a default path will be created in the /tmp\n// directory.\nfunc UserDataDir(dir string) ExecAllocatorOption {\n\treturn Flag(\"user-data-dir\", dir)\n}\n\n// ProxyServer is the command line option to set the outbound proxy server.\nfunc ProxyServer(proxy string) ExecAllocatorOption {\n\treturn Flag(\"proxy-server\", proxy)\n}\n\n// IgnoreCertErrors is the command line option to ignore certificate-related\n// errors. This option is useful when you need to access an HTTPS website\n// through a proxy.\nfunc IgnoreCertErrors(a *ExecAllocator) {\n\tFlag(\"ignore-certificate-errors\", true)(a)\n}\n\n// WindowSize is the command line option to set the initial window size.\nfunc WindowSize(width, height int) ExecAllocatorOption {\n\treturn Flag(\"window-size\", fmt.Sprintf(\"%d,%d\", width, height))\n}\n\n// UserAgent is the command line option to set the default User-Agent\n// header.\nfunc UserAgent(userAgent string) ExecAllocatorOption {\n\treturn Flag(\"user-agent\", userAgent)\n}\n\n// NoSandbox is the Chrome command line option to disable the sandbox.\nfunc NoSandbox(a *ExecAllocator) {\n\tFlag(\"no-sandbox\", true)(a)\n}\n\n// NoFirstRun is the Chrome command line option to disable the first run\n// dialog.\nfunc NoFirstRun(a *ExecAllocator) {\n\tFlag(\"no-first-run\", true)(a)\n}\n\n// NoDefaultBrowserCheck is the Chrome command line option to disable the\n// default browser check.\nfunc NoDefaultBrowserCheck(a *ExecAllocator) {\n\tFlag(\"no-default-browser-check\", true)(a)\n}\n\n// Headless is the command line option to run in headless mode. On top of\n// setting the headless flag, it also hides scrollbars and mutes audio.\nfunc Headless(a *ExecAllocator) {\n\tFlag(\"headless\", true)(a)\n\t// Like in Puppeteer.\n\tFlag(\"hide-scrollbars\", true)(a)\n\tFlag(\"mute-audio\", true)(a)\n}\n\n// DisableGPU is the command line option to disable the GPU process.\n//\n// The --disable-gpu option is a temporary workaround for a few bugs\n// in headless mode. According to the references below, it's no longer required:\n//   - https://bugs.chromium.org/p/chromium/issues/detail?id=737678\n//   - https://github.com/puppeteer/puppeteer/pull/2908\n//   - https://github.com/puppeteer/puppeteer/pull/4523\n//\n// But according to this reported issue, it's still required in some cases:\n//   - https://github.com/chromedp/chromedp/issues/904\nfunc DisableGPU(a *ExecAllocator) {\n\tFlag(\"disable-gpu\", true)(a)\n}\n\n// CombinedOutput is used to set an io.Writer where stdout and stderr\n// from the browser will be sent\nfunc CombinedOutput(w io.Writer) ExecAllocatorOption {\n\treturn func(a *ExecAllocator) {\n\t\ta.combinedOutputWriter = w\n\t}\n}\n\n// WSURLReadTimeout sets the waiting time for reading the WebSocket URL.\n// The default value is 20 seconds.\nfunc WSURLReadTimeout(t time.Duration) ExecAllocatorOption {\n\treturn func(a *ExecAllocator) {\n\t\ta.wsURLReadTimeout = t\n\t}\n}\n\n// NewRemoteAllocator creates a new context set up with a RemoteAllocator,\n// suitable for use with NewContext. The url should point to the browser's\n// websocket address, such as \"ws://127.0.0.1:$PORT/devtools/browser/...\".\n//\n// If the url does not contain \"/devtools/browser/\", it will try to detect\n// the correct one by sending a request to \"http://$HOST:$PORT/json/version\".\n//\n// The url with the following formats are accepted:\n//   - ws://127.0.0.1:9222/\n//   - http://127.0.0.1:9222/\n//\n// But \"ws://127.0.0.1:9222/devtools/browser/\" are not accepted.\n// Because the allocator won't try to modify it and it's obviously invalid.\n//\n// Use chromedp.NoModifyURL to prevent it from modifying the url.\nfunc NewRemoteAllocator(parent context.Context, url string, opts ...RemoteAllocatorOption) (context.Context, context.CancelFunc) {\n\ta := &RemoteAllocator{\n\t\twsURL:         url,\n\t\tmodifyURLFunc: modifyURL,\n\t}\n\tfor _, o := range opts {\n\t\to(a)\n\t}\n\tc := &Context{Allocator: a}\n\n\tctx, cancel := context.WithCancel(parent)\n\tctx = context.WithValue(ctx, contextKey{}, c)\n\treturn ctx, cancel\n}\n\n// RemoteAllocatorOption is a remote allocator option.\ntype RemoteAllocatorOption = func(*RemoteAllocator)\n\n// RemoteAllocator is an Allocator which connects to an already running Chrome\n// process via a websocket URL.\ntype RemoteAllocator struct {\n\twsURL         string\n\tmodifyURLFunc func(ctx context.Context, wsURL string) (string, error)\n\n\twg sync.WaitGroup\n}\n\n// Allocate satisfies the Allocator interface.\nfunc (a *RemoteAllocator) Allocate(ctx context.Context, opts ...BrowserOption) (*Browser, error) {\n\tc := FromContext(ctx)\n\tif c == nil {\n\t\treturn nil, ErrInvalidContext\n\t}\n\n\twsURL := a.wsURL\n\tvar err error\n\tif a.modifyURLFunc != nil {\n\t\twsURL, err = a.modifyURLFunc(ctx, wsURL)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to modify wsURL: %w\", err)\n\t\t}\n\t}\n\n\t// Use a different context for the websocket, so we can have a chance at\n\t// closing the relevant pages before closing the websocket connection.\n\twctx, cancel := context.WithCancel(context.Background())\n\n\tclose(c.allocated)\n\ta.wg.Add(1) // for the entire allocator\n\tgo func() {\n\t\t<-ctx.Done()\n\t\tCancel(ctx) // block until all pages are closed\n\t\tcancel()    // close the websocket connection\n\t\ta.wg.Done()\n\t}()\n\n\tbrowser, err := NewBrowser(wctx, wsURL, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tgo func() {\n\t\t// If the browser loses connection, kill the entire process and\n\t\t// handler at once.\n\t\t<-browser.LostConnection\n\t\tselect {\n\t\tcase <-browser.closingGracefully:\n\t\tdefault:\n\t\t\tCancel(ctx)\n\t\t}\n\t}()\n\treturn browser, nil\n}\n\n// Wait satisfies the Allocator interface.\nfunc (a *RemoteAllocator) Wait() {\n\ta.wg.Wait()\n}\n\n// NoModifyURL is a RemoteAllocatorOption that prevents the remote allocator\n// from modifying the websocket debugger URL passed to it.\nfunc NoModifyURL(a *RemoteAllocator) {\n\ta.modifyURLFunc = nil\n}\n"
        },
        {
          "name": "allocate_linux.go",
          "type": "blob",
          "size": 0.404296875,
          "content": "//go:build linux\n// +build linux\n\npackage chromedp\n\nimport (\n\t\"os\"\n\t\"os/exec\"\n\t\"syscall\"\n)\n\nfunc allocateCmdOptions(cmd *exec.Cmd) {\n\tif _, ok := os.LookupEnv(\"LAMBDA_TASK_ROOT\"); ok {\n\t\t// do nothing on AWS Lambda\n\t\treturn\n\t}\n\tif cmd.SysProcAttr == nil {\n\t\tcmd.SysProcAttr = new(syscall.SysProcAttr)\n\t}\n\t// When the parent process dies (Go), kill the child as well.\n\tcmd.SysProcAttr.Pdeathsig = syscall.SIGKILL\n}\n"
        },
        {
          "name": "allocate_other.go",
          "type": "blob",
          "size": 0.1123046875,
          "content": "//go:build !linux\n// +build !linux\n\npackage chromedp\n\nimport \"os/exec\"\n\nfunc allocateCmdOptions(cmd *exec.Cmd) {\n}\n"
        },
        {
          "name": "allocate_test.go",
          "type": "blob",
          "size": 12.1845703125,
          "content": "package chromedp\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestExecAllocator(t *testing.T) {\n\tt.Parallel()\n\n\tallocCtx, cancel := NewExecAllocator(context.Background(), allocOpts...)\n\tdefer cancel()\n\n\t// TODO: test that multiple child contexts are run in different\n\t// processes and browsers.\n\n\ttaskCtx, cancel := NewContext(allocCtx)\n\tdefer cancel()\n\n\twant := \"insert\"\n\tvar got string\n\tif err := Run(taskCtx,\n\t\tNavigate(testdataDir+\"/form.html\"),\n\t\tText(\"#foo\", &got, ByID),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got != want {\n\t\tt.Fatalf(\"want %q, got %q\", want, got)\n\t}\n\n\tcancel()\n\n\ttempDir := FromContext(taskCtx).Browser.userDataDir\n\tif _, err := os.Lstat(tempDir); !os.IsNotExist(err) {\n\t\tt.Fatalf(\"temporary user data dir %q not deleted\", tempDir)\n\t}\n}\n\nfunc TestExecAllocatorCancelParent(t *testing.T) {\n\tt.Parallel()\n\n\tallocCtx, allocCancel := NewExecAllocator(context.Background(), allocOpts...)\n\tdefer allocCancel()\n\n\t// TODO: test that multiple child contexts are run in different\n\t// processes and browsers.\n\n\ttaskCtx, _ := NewContext(allocCtx)\n\tif err := Run(taskCtx); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Canceling the pool context should stop all browsers too.\n\tallocCancel()\n\n\ttempDir := FromContext(taskCtx).Browser.userDataDir\n\tif _, err := os.Lstat(tempDir); !os.IsNotExist(err) {\n\t\tt.Fatalf(\"temporary user data dir %q not deleted\", tempDir)\n\t}\n}\n\nfunc TestExecAllocatorKillBrowser(t *testing.T) {\n\tt.Parallel()\n\n\t// Simulate a scenario where we navigate to a page that never responds,\n\t// and the browser is killed while it's loading.\n\tctx, _ := testAllocateSeparate(t)\n\tctx, cancel := context.WithTimeout(ctx, 3*time.Second)\n\tdefer cancel()\n\n\tkill := make(chan struct{}, 1)\n\ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tkill <- struct{}{}\n\t\t<-ctx.Done() // block until the end of the test\n\t}))\n\tdefer s.Close()\n\tgo func() {\n\t\t<-kill\n\t\tb := FromContext(ctx).Browser\n\t\tif err := b.process.Signal(os.Kill); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}()\n\n\t// Run should error with something other than \"deadline exceeded\" in\n\t// much less than 3s.\n\tswitch err := Run(ctx, Navigate(s.URL)); err {\n\tcase nil:\n\t\t// TODO: figure out why this happens sometimes on Travis\n\t\t// t.Fatal(\"did not expect a nil error\")\n\tcase context.DeadlineExceeded:\n\t\tt.Fatalf(\"did not expect a standard context error: %v\", err)\n\t}\n}\n\nfunc TestSkipNewContext(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := NewExecAllocator(context.Background(), allocOpts...)\n\tdefer cancel()\n\n\t// Using the allocator context directly (without calling NewContext)\n\t// should be an immediate error.\n\terr := Run(ctx, Navigate(testdataDir+\"/form.html\"))\n\n\twant := ErrInvalidContext\n\tif err != want {\n\t\tt.Fatalf(\"want error to be %q, got %q\", want, err)\n\t}\n}\n\nfunc TestRemoteAllocator(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname      string\n\t\tmodifyURL func(wsURL string) string\n\t\topts      []RemoteAllocatorOption\n\t\twantErr   string\n\t}{\n\t\t{\n\t\t\tname:      \"original wsURL\",\n\t\t\tmodifyURL: func(wsURL string) string { return wsURL },\n\t\t},\n\t\t{\n\t\t\tname: \"detect from ws\",\n\t\t\tmodifyURL: func(wsURL string) string {\n\t\t\t\treturn wsURL[0:strings.Index(wsURL, \"devtools\")]\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"detect from http\",\n\t\t\tmodifyURL: func(wsURL string) string {\n\t\t\t\treturn \"http\" + wsURL[2:strings.Index(wsURL, \"devtools\")]\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"hostname\",\n\t\t\tmodifyURL: func(wsURL string) string {\n\t\t\t\th, err := os.Hostname()\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tu, err := url.Parse(wsURL)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\t_, port, err := net.SplitHostPort(u.Host)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tu.Host = net.JoinHostPort(h, port)\n\t\t\t\tu.Path = \"/\"\n\t\t\t\treturn u.String()\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NoModifyURL\",\n\t\t\tmodifyURL: func(wsURL string) string {\n\t\t\t\treturn wsURL[0:strings.Index(wsURL, \"devtools\")]\n\t\t\t},\n\t\t\topts:    []RemoteAllocatorOption{NoModifyURL},\n\t\t\twantErr: \"could not dial\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttestRemoteAllocator(t, tt.modifyURL, tt.wantErr, tt.opts)\n\t\t})\n\t}\n}\n\nfunc testRemoteAllocator(t *testing.T, modifyURL func(wsURL string) string, wantErr string, opts []RemoteAllocatorOption) {\n\ttempDir := t.TempDir()\n\n\tprocCtx, procCancel := context.WithCancel(context.Background())\n\tdefer procCancel()\n\tcmd := exec.CommandContext(procCtx, execPath,\n\t\t// TODO: deduplicate these with allocOpts in chromedp_test.go\n\t\t\"--no-first-run\",\n\t\t\"--no-default-browser-check\",\n\t\t\"--headless\",\n\t\t\"--disable-gpu\",\n\t\t\"--no-sandbox\",\n\n\t\t// TODO: perhaps deduplicate this code with ExecAllocator\n\t\t\"--user-data-dir=\"+tempDir,\n\t\t\"--remote-debugging-address=0.0.0.0\",\n\t\t\"--remote-debugging-port=0\",\n\t\t\"about:blank\",\n\t)\n\n\tstderr, err := cmd.StderrPipe()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer stderr.Close()\n\tif err := cmd.Start(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\twsURL, err := readOutput(stderr, nil, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tallocCtx, allocCancel := NewRemoteAllocator(context.Background(), modifyURL(wsURL), opts...)\n\tdefer allocCancel()\n\n\ttaskCtx, taskCancel := NewContext(allocCtx,\n\t\t// This used to crash when used with RemoteAllocator.\n\t\tWithLogf(func(format string, args ...interface{}) {}),\n\t)\n\n\t{\n\t\tinfos, err := Targets(taskCtx)\n\t\tif len(wantErr) > 0 {\n\t\t\tif err == nil || !strings.Contains(err.Error(), wantErr) {\n\t\t\t\tt.Fatalf(\"\\ngot error:\\n\\t%v\\nwant error contains:\\n\\t%s\", err, wantErr)\n\t\t\t}\n\n\t\t\tprocCancel()\n\t\t\tcmd.Wait()\n\t\t\treturn\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(infos) > 1 {\n\t\t\tt.Fatalf(\"expected Targets on a new RemoteAllocator context to return at most one, got: %d\", len(infos))\n\t\t}\n\t}\n\n\tdefer taskCancel()\n\twant := \"insert\"\n\tvar got string\n\tif err := Run(taskCtx,\n\t\tNavigate(testdataDir+\"/form.html\"),\n\t\tText(\"#foo\", &got, ByID),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got != want {\n\t\tt.Fatalf(\"want %q, got %q\", want, got)\n\t}\n\ttargetID := FromContext(taskCtx).Target.TargetID\n\tif err := Cancel(taskCtx); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Check that cancel closed the tabs. Don't just count the\n\t// number of targets, as perhaps the initial blank tab hasn't\n\t// come up yet.\n\ttargetsCtx, targetsCancel := NewContext(allocCtx)\n\tdefer targetsCancel()\n\tinfos, err := Targets(targetsCtx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor _, info := range infos {\n\t\tif info.TargetID == targetID {\n\t\t\tt.Fatalf(\"target from previous iteration wasn't closed: %v\", targetID)\n\t\t}\n\t}\n\ttargetsCancel()\n\n\t// Finally, if we kill the browser and the websocket connection drops,\n\t// Run should error way before the 5s timeout.\n\t// TODO: a \"defer cancel()\" here adds a 1s timeout, since we try to\n\t// close the target twice. Fix that.\n\tctx, _ := NewContext(allocCtx)\n\tctx, cancel := context.WithTimeout(ctx, 5*time.Second)\n\tdefer cancel()\n\n\t// Connect to the browser, then kill it.\n\tif err := Run(ctx); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tprocCancel()\n\tswitch err := Run(ctx, Navigate(testdataDir+\"/form.html\")); err {\n\tcase nil:\n\t\t// TODO: figure out why this happens sometimes on Travis\n\t\t// t.Fatal(\"did not expect a nil error\")\n\tcase context.DeadlineExceeded:\n\t\tt.Fatalf(\"did not expect a standard context error: %v\", err)\n\t}\n\tcmd.Wait()\n}\n\nfunc TestExecAllocatorMissingWebsocketAddr(t *testing.T) {\n\tt.Parallel()\n\n\tallocCtx, cancel := NewExecAllocator(context.Background(),\n\t\t// Use a bad listen address, so Chrome exits straight away.\n\t\tappend([]ExecAllocatorOption{Flag(\"remote-debugging-address\", \"_\")},\n\t\t\tallocOpts...)...)\n\tdefer cancel()\n\n\tctx, cancel := NewContext(allocCtx)\n\tdefer cancel()\n\n\t// set the \"s\" flag to let \".\" match \"\\n\"\n\t// in GitHub Actions, the error text could be:\n\t// \"chrome failed to start:\\n/bin/bash: /etc/profile.d/env_vars.sh: Permission denied\\nmkdir: cannot create directory ‘/run/user/1001’: Permission denied\\n[0321/081807.491906:ERROR:headless_shell.cc(720)] Invalid devtools server address\\n\"\n\twant := `failed to start`\n\tgot := fmt.Sprintf(\"%v\", Run(ctx))\n\tif !strings.Contains(got, want) {\n\t\tt.Fatalf(\"want error to match %q, got %q\", want, got)\n\t}\n}\n\nfunc TestCombinedOutput(t *testing.T) {\n\tt.Parallel()\n\n\tbuf := new(bytes.Buffer)\n\tallocCtx, cancel := NewExecAllocator(context.Background(),\n\t\tappend([]ExecAllocatorOption{\n\t\t\tCombinedOutput(buf),\n\t\t\tFlag(\"enable-logging\", true),\n\t\t}, allocOpts...)...)\n\tdefer cancel()\n\n\ttaskCtx, _ := NewContext(allocCtx)\n\tif err := Run(taskCtx,\n\t\tNavigate(testdataDir+\"/consolespam.html\"),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcancel()\n\tif !strings.Contains(buf.String(), \"DevTools listening on\") {\n\t\tt.Fatalf(\"failed to find websocket string in browser output test\")\n\t}\n\t// Recent chrome versions have started replacing many \"spam\" messages\n\t// with \"spam 1\", \"spam 2\", and so on. Search for the prefix only.\n\tif want, got := 2000, strings.Count(buf.String(), `\"spam`); want != got {\n\t\tt.Fatalf(\"want %d spam console logs, got %d\", want, got)\n\t}\n}\n\nfunc TestCombinedOutputError(t *testing.T) {\n\tt.Parallel()\n\n\t// CombinedOutput used to hang the allocator if Chrome errored straight\n\t// away, as there was no output to copy and the CombinedOutput would\n\t// never signal it's done.\n\tbuf := new(bytes.Buffer)\n\tallocCtx, cancel := NewExecAllocator(context.Background(),\n\t\t// Use a bad listen address, so Chrome exits straight away.\n\t\tappend([]ExecAllocatorOption{\n\t\t\tFlag(\"remote-debugging-address\", \"_\"),\n\t\t\tCombinedOutput(buf),\n\t\t}, allocOpts...)...)\n\tdefer cancel()\n\n\tctx, cancel := NewContext(allocCtx)\n\tdefer cancel()\n\tgot := fmt.Sprint(Run(ctx))\n\twant := \"failed to start\"\n\tif !strings.Contains(got, want) {\n\t\tt.Fatalf(\"got %q, want %q\", got, want)\n\t}\n}\n\nfunc TestEnv(t *testing.T) {\n\tt.Parallel()\n\n\ttz := \"Australia/Melbourne\"\n\tallocCtx, cancel := NewExecAllocator(context.Background(),\n\t\tappend([]ExecAllocatorOption{\n\t\t\tEnv(\"TZ=\" + tz),\n\t\t}, allocOpts...)...)\n\tdefer cancel()\n\n\tctx, cancel := NewContext(allocCtx)\n\tdefer cancel()\n\n\tvar ret string\n\tif err := Run(ctx,\n\t\tEvaluate(`Intl.DateTimeFormat().resolvedOptions().timeZone`, &ret),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif ret != tz {\n\t\tt.Fatalf(\"got %s, want %s\", ret, tz)\n\t}\n}\n\nfunc TestWithBrowserOptionAlreadyAllocated(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocateSeparate(t)\n\tdefer cancel()\n\n\tdefer func() {\n\t\twant := \"when allocating a new browser\"\n\t\tif got := fmt.Sprint(recover()); !strings.Contains(got, want) {\n\t\t\tt.Errorf(\"expected a panic containing %q, got %q\", want, got)\n\t\t}\n\t}()\n\t// This needs to panic, as we try to set up a browser logf function\n\t// after the browser has already been set up earlier.\n\t_, _ = NewContext(ctx,\n\t\tWithLogf(func(format string, args ...interface{}) {}),\n\t)\n}\n\nfunc TestModifyCmdFunc(t *testing.T) {\n\tt.Parallel()\n\n\ttz := \"Atlantic/Reykjavik\"\n\tallocCtx, cancel := NewExecAllocator(context.Background(),\n\t\tappend([]ExecAllocatorOption{\n\t\t\tModifyCmdFunc(func(cmd *exec.Cmd) {\n\t\t\t\tcmd.Env = append(cmd.Env, \"TZ=\"+tz)\n\t\t\t}),\n\t\t}, allocOpts...)...)\n\tdefer cancel()\n\n\tctx, cancel := NewContext(allocCtx)\n\tdefer cancel()\n\n\tvar ret string\n\tif err := Run(ctx,\n\t\tEvaluate(`Intl.DateTimeFormat().resolvedOptions().timeZone`, &ret),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif ret != tz {\n\t\tt.Fatalf(\"got %s, want %s\", ret, tz)\n\t}\n}\n\n// TestStartsWithNonBlankTab is a regression test to make sure chromedp won't\n// hang when the browser is started with a non-blank tab.\n//\n// In the following cases, the browser will start with a non-blank tab:\n// 1. with the \"--app\" option (should disable headless mode);\n// 2. URL other than \"about:blank\" is placed in the command line arguments.\n//\n// It's hard to disable headless mode on test servers, so we will go with\n// case 2 here.\nfunc TestStartsWithNonBlankTab(t *testing.T) {\n\tt.Parallel()\n\n\tallocCtx, cancel := NewExecAllocator(context.Background(),\n\t\tappend(allocOpts,\n\t\t\tModifyCmdFunc(func(cmd *exec.Cmd) {\n\t\t\t\t// it assumes that the last argument is \"about:blank\" and\n\t\t\t\t// replace it with other URL.\n\t\t\t\tcmd.Args[len(cmd.Args)-1] = testdataDir + \"/form.html\"\n\t\t\t}),\n\t\t)...)\n\tdefer cancel()\n\n\tctx, cancel := NewContext(allocCtx)\n\tdefer cancel()\n\n\tctx, cancel = context.WithTimeout(ctx, 2*time.Second)\n\tdefer cancel()\n\n\tif err := Run(ctx,\n\t\tNavigate(testdataDir+\"/form.html\"),\n\t); err != nil {\n\t\tif errors.Is(err, context.DeadlineExceeded) {\n\t\t\tt.Error(\"chromedp hangs when the browser starts with a non-blank tab.\")\n\t\t} else {\n\t\t\tt.Errorf(\"got error %s, want nil\", err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "browser.go",
          "type": "blob",
          "size": 9.58203125,
          "content": "package chromedp\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/mailru/easyjson\"\n\n\t\"github.com/chromedp/cdproto\"\n\t\"github.com/chromedp/cdproto/browser\"\n\t\"github.com/chromedp/cdproto/cdp\"\n\t\"github.com/chromedp/cdproto/runtime\"\n\t\"github.com/chromedp/cdproto/target\"\n)\n\n// Browser is the high-level Chrome DevTools Protocol browser manager, handling\n// the browser process runner, WebSocket clients, associated targets, and\n// network, page, and DOM events.\ntype Browser struct {\n\t// next is the next message id.\n\t// NOTE: needs to be 64-bit aligned for 32-bit targets too, so be careful when moving this field.\n\t// This will be eventually done by the compiler once https://github.com/golang/go/issues/599 is fixed.\n\tnext int64\n\n\t// LostConnection is closed when the websocket connection to Chrome is\n\t// dropped. This can be useful to make sure that Browser's context is\n\t// cancelled (and the handler stopped) once the connection has failed.\n\tLostConnection chan struct{}\n\n\t// closingGracefully is closed by Close before gracefully shutting down\n\t// the browser. This way, when the connection to the browser is lost and\n\t// LostConnection is closed, we will know not to immediately kill the\n\t// Chrome process. This is important to let the browser shut itself off,\n\t// saving its state to disk.\n\tclosingGracefully chan struct{}\n\n\tdialTimeout time.Duration\n\n\t// pages keeps track of the attached targets, indexed by each's session\n\t// ID. The only reason this is a field is so that the tests can check the\n\t// map once a browser is closed.\n\tpages map[target.SessionID]*Target\n\n\tlistenersMu sync.Mutex\n\tlisteners   []cancelableListener\n\n\tconn Transport\n\n\t// newTabQueue is the queue used to create new target handlers, once a new\n\t// tab is created and attached to. The newly created Target is sent back\n\t// via newTabResult.\n\tnewTabQueue chan *Target\n\n\t// cmdQueue is the outgoing command queue.\n\tcmdQueue chan *cdproto.Message\n\n\t// logging funcs\n\tlogf func(string, ...interface{})\n\terrf func(string, ...interface{})\n\tdbgf func(string, ...interface{})\n\n\t// The optional fields below are helpful for some tests.\n\n\t// process can be initialized by the allocators which start a process\n\t// when allocating a browser.\n\tprocess *os.Process\n\n\t// userDataDir can be initialized by the allocators which set up user\n\t// data dirs directly.\n\tuserDataDir string\n}\n\n// NewBrowser creates a new browser. Typically, this function wouldn't be called\n// directly, as the Allocator interface takes care of it.\nfunc NewBrowser(ctx context.Context, urlstr string, opts ...BrowserOption) (*Browser, error) {\n\tb := &Browser{\n\t\tLostConnection:    make(chan struct{}),\n\t\tclosingGracefully: make(chan struct{}),\n\n\t\tdialTimeout: 10 * time.Second,\n\n\t\tnewTabQueue: make(chan *Target),\n\n\t\t// Fit some jobs without blocking, to reduce blocking in Execute.\n\t\tcmdQueue: make(chan *cdproto.Message, 32),\n\n\t\tlogf: log.Printf,\n\t}\n\t// apply options\n\tfor _, o := range opts {\n\t\to(b)\n\t}\n\t// ensure errf is set\n\tif b.errf == nil {\n\t\tb.errf = func(s string, v ...interface{}) { b.logf(\"ERROR: \"+s, v...) }\n\t}\n\n\tdialCtx := ctx\n\tif b.dialTimeout > 0 {\n\t\tvar cancel context.CancelFunc\n\t\tdialCtx, cancel = context.WithTimeout(ctx, b.dialTimeout)\n\t\tdefer cancel()\n\t}\n\n\tvar err error\n\tb.conn, err = DialContext(dialCtx, urlstr, WithConnDebugf(b.dbgf))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not dial %q: %w\", urlstr, err)\n\t}\n\n\tgo b.run(ctx)\n\treturn b, nil\n}\n\n// Process returns the process object of the browser.\n//\n// It could be nil when the browser is allocated with RemoteAllocator.\n// It could be useful for a monitoring system to collect process metrics of the browser process.\n// (See [prometheus.NewProcessCollector] for an example).\n//\n// Example:\n//\n//\tif process := chromedp.FromContext(ctx).Browser.Process(); process != nil {\n//\t\tfmt.Printf(\"Browser PID: %v\", process.Pid)\n//\t}\n//\n// [prometheus.NewProcessCollector]: https://pkg.go.dev/github.com/prometheus/client_golang/prometheus#NewProcessCollector\nfunc (b *Browser) Process() *os.Process {\n\treturn b.process\n}\n\nfunc (b *Browser) newExecutorForTarget(ctx context.Context, targetID target.ID, sessionID target.SessionID) (*Target, error) {\n\tif targetID == \"\" {\n\t\treturn nil, errors.New(\"empty target ID\")\n\t}\n\tif sessionID == \"\" {\n\t\treturn nil, errors.New(\"empty session ID\")\n\t}\n\tt := &Target{\n\t\tbrowser:   b,\n\t\tTargetID:  targetID,\n\t\tSessionID: sessionID,\n\n\t\tmessageQueue: make(chan *cdproto.Message, 1024),\n\t\tframes:       make(map[cdp.FrameID]*cdp.Frame),\n\t\texecContexts: make(map[cdp.FrameID]runtime.ExecutionContextID),\n\t\tcur:          cdp.FrameID(targetID),\n\n\t\tlogf: b.logf,\n\t\terrf: b.errf,\n\t}\n\n\t// This send should be blocking, to ensure the tab is inserted into the\n\t// map before any more target events are routed.\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tcase b.newTabQueue <- t:\n\t}\n\treturn t, nil\n}\n\nfunc (b *Browser) Execute(ctx context.Context, method string, params easyjson.Marshaler, res easyjson.Unmarshaler) error {\n\t// Certain methods aren't available to the user directly.\n\tif method == browser.CommandClose {\n\t\treturn fmt.Errorf(\"to close the browser gracefully, use chromedp.Cancel\")\n\t}\n\treturn b.execute(ctx, method, params, res)\n}\n\nfunc (b *Browser) execute(ctx context.Context, method string, params easyjson.Marshaler, res easyjson.Unmarshaler) error {\n\tid := atomic.AddInt64(&b.next, 1)\n\tlctx, cancel := context.WithCancel(ctx)\n\tch := make(chan *cdproto.Message, 1)\n\tfn := func(ev interface{}) {\n\t\tif msg, ok := ev.(*cdproto.Message); ok && msg.ID == id {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\tcase ch <- msg:\n\t\t\t}\n\t\t\tcancel()\n\t\t}\n\t}\n\tb.listenersMu.Lock()\n\tb.listeners = append(b.listeners, cancelableListener{lctx, fn})\n\tb.listenersMu.Unlock()\n\n\t// send command\n\tvar buf []byte\n\tif params != nil {\n\t\tvar err error\n\t\tbuf, err = easyjson.Marshal(params)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tcmd := &cdproto.Message{\n\t\tID:     id,\n\t\tMethod: cdproto.MethodType(method),\n\t\tParams: buf,\n\t}\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tcase b.cmdQueue <- cmd:\n\t}\n\n\t// wait for result\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tcase msg := <-ch:\n\t\tswitch {\n\t\tcase msg == nil:\n\t\t\treturn ErrChannelClosed\n\t\tcase msg.Error != nil:\n\t\t\treturn msg.Error\n\t\tcase res != nil:\n\t\t\treturn easyjson.Unmarshal(msg.Result, res)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (b *Browser) run(ctx context.Context) {\n\tdefer b.conn.Close()\n\n\t// incomingQueue is the queue of incoming target events, to be routed by\n\t// their session ID.\n\tincomingQueue := make(chan *cdproto.Message, 1)\n\n\tdelTabQueue := make(chan target.SessionID, 1)\n\n\t// This goroutine continuously reads events from the websocket\n\t// connection. The separate goroutine is needed since a websocket read\n\t// is blocking, so it cannot be used in a select statement.\n\tgo func() {\n\t\t// Signal to run and exit the browser cleanup goroutine.\n\t\tdefer close(b.LostConnection)\n\n\t\tfor {\n\t\t\tmsg := new(cdproto.Message)\n\t\t\tif err := b.conn.Read(ctx, msg); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tswitch {\n\t\t\tcase msg.SessionID != \"\" && (msg.Method != \"\" || msg.ID != 0):\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\tcase incomingQueue <- msg:\n\t\t\t\t}\n\n\t\t\tcase msg.Method != \"\":\n\t\t\t\tev, err := cdproto.UnmarshalMessage(msg)\n\t\t\t\tif err != nil {\n\t\t\t\t\tb.errf(\"%s\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tb.listenersMu.Lock()\n\t\t\t\tb.listeners = runListeners(b.listeners, ev)\n\t\t\t\tb.listenersMu.Unlock()\n\n\t\t\t\tif ev, ok := ev.(*target.EventDetachedFromTarget); ok {\n\t\t\t\t\tdelTabQueue <- ev.SessionID\n\t\t\t\t}\n\n\t\t\tcase msg.ID != 0:\n\t\t\t\tb.listenersMu.Lock()\n\t\t\t\tb.listeners = runListeners(b.listeners, msg)\n\t\t\t\tb.listenersMu.Unlock()\n\n\t\t\tdefault:\n\t\t\t\tb.errf(\"ignoring malformed incoming message (missing id or method): %#v\", msg)\n\t\t\t}\n\t\t}\n\t}()\n\n\tb.pages = make(map[target.SessionID]*Target, 32)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\n\t\tcase msg := <-b.cmdQueue:\n\t\t\tif err := b.conn.Write(ctx, msg); err != nil {\n\t\t\t\tb.errf(\"%s\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\tcase t := <-b.newTabQueue:\n\t\t\tif _, ok := b.pages[t.SessionID]; ok {\n\t\t\t\tb.errf(\"executor for %q already exists\", t.SessionID)\n\t\t\t}\n\t\t\tb.pages[t.SessionID] = t\n\n\t\tcase sessionID := <-delTabQueue:\n\t\t\tif _, ok := b.pages[sessionID]; !ok {\n\t\t\t\tb.errf(\"executor for %q doesn't exist\", sessionID)\n\t\t\t}\n\t\t\tdelete(b.pages, sessionID)\n\n\t\tcase m := <-incomingQueue:\n\t\t\tpage, ok := b.pages[m.SessionID]\n\t\t\tif !ok {\n\t\t\t\t// A page we recently closed still sending events.\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase page.messageQueue <- m:\n\t\t\t}\n\n\t\tcase <-b.LostConnection:\n\t\t\treturn // to avoid \"write: broken pipe\" errors\n\t\t}\n\t}\n}\n\n// BrowserOption is a browser option.\ntype BrowserOption = func(*Browser)\n\n// WithBrowserLogf is a browser option to specify a func to receive general logging.\nfunc WithBrowserLogf(f func(string, ...interface{})) BrowserOption {\n\treturn func(b *Browser) { b.logf = f }\n}\n\n// WithBrowserErrorf is a browser option to specify a func to receive error logging.\nfunc WithBrowserErrorf(f func(string, ...interface{})) BrowserOption {\n\treturn func(b *Browser) { b.errf = f }\n}\n\n// WithBrowserDebugf is a browser option to specify a func to log actual\n// websocket messages.\nfunc WithBrowserDebugf(f func(string, ...interface{})) BrowserOption {\n\treturn func(b *Browser) { b.dbgf = f }\n}\n\n// WithConsolef is a browser option to specify a func to receive chrome log events.\n//\n// Note: NOT YET IMPLEMENTED.\nfunc WithConsolef(f func(string, ...interface{})) BrowserOption {\n\treturn func(b *Browser) {}\n}\n\n// WithDialTimeout is a browser option to specify the timeout when dialing a\n// browser's websocket address. The default is ten seconds; use a zero duration\n// to not use a timeout.\nfunc WithDialTimeout(d time.Duration) BrowserOption {\n\treturn func(b *Browser) { b.dialTimeout = d }\n}\n"
        },
        {
          "name": "call.go",
          "type": "blob",
          "size": 2.46875,
          "content": "package chromedp\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\n\t\"github.com/chromedp/cdproto/runtime\"\n)\n\n// CallAction are actions that calls a JavaScript function using\n// runtime.CallFunctionOn.\ntype CallAction Action\n\n// CallFunctionOn is an action to call a JavaScript function, unmarshaling\n// the result of the function to res.\n//\n// The handling of res is the same as that of Evaluate.\n//\n// Do not call the following methods on runtime.CallFunctionOnParams:\n// - WithReturnByValue: it will be set depending on the type of res;\n// - WithArguments: pass the arguments with args instead.\n//\n// Note: any exception encountered will be returned as an error.\nfunc CallFunctionOn(functionDeclaration string, res interface{}, opt CallOption, args ...interface{}) CallAction {\n\treturn ActionFunc(func(ctx context.Context) error {\n\t\t_, err := callFunctionOn(ctx, functionDeclaration, res, opt, args...)\n\t\treturn err\n\t})\n}\n\nfunc callFunctionOn(ctx context.Context, functionDeclaration string, res interface{}, opt CallOption, args ...interface{}) (*runtime.RemoteObject, error) {\n\t// set up parameters\n\tp := runtime.CallFunctionOn(functionDeclaration).\n\t\tWithSilent(true)\n\n\tswitch res.(type) {\n\tcase **runtime.RemoteObject:\n\tdefault:\n\t\tp = p.WithReturnByValue(true)\n\t}\n\n\t// apply opt\n\tif opt != nil {\n\t\tp = opt(p)\n\t}\n\n\t// arguments\n\tif len(args) > 0 {\n\t\tea := &errAppender{args: make([]*runtime.CallArgument, 0, len(args))}\n\t\tfor _, arg := range args {\n\t\t\tea.append(arg)\n\t\t}\n\t\tif ea.err != nil {\n\t\t\treturn nil, ea.err\n\t\t}\n\t\tp = p.WithArguments(ea.args)\n\t}\n\n\t// call\n\tv, exp, err := p.Do(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif exp != nil {\n\t\treturn nil, exp\n\t}\n\n\treturn v, parseRemoteObject(v, res)\n}\n\n// CallOption is a function to modify the runtime.CallFunctionOnParams\n// to provide more information.\ntype CallOption = func(params *runtime.CallFunctionOnParams) *runtime.CallFunctionOnParams\n\n// errAppender is to help accumulating the arguments and simplifying error checks.\n//\n// see https://blog.golang.org/errors-are-values\ntype errAppender struct {\n\targs []*runtime.CallArgument\n\terr  error\n}\n\n// append method calls the json.Marshal method to marshal the value and appends it to the slice.\n// It records the first error for future reference.\n// As soon as an error occurs, the append method becomes a no-op but the error value is saved.\nfunc (ea *errAppender) append(v interface{}) {\n\tif ea.err != nil {\n\t\treturn\n\t}\n\tvar b []byte\n\tb, ea.err = json.Marshal(v)\n\tea.args = append(ea.args, &runtime.CallArgument{Value: b})\n}\n"
        },
        {
          "name": "chromedp.go",
          "type": "blob",
          "size": 27.1923828125,
          "content": "// Package chromedp is a high level Chrome DevTools Protocol client that\n// simplifies driving browsers for scraping, unit testing, or profiling web\n// pages using the CDP.\n//\n// chromedp requires no third-party dependencies, implementing the async Chrome\n// DevTools Protocol entirely in Go.\n//\n// This package includes a number of simple examples. Additionally,\n// [chromedp/examples] contains more complex examples.\n//\n// [chromedp/examples]: https://github.com/chromedp/examples\npackage chromedp\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/chromedp/cdproto/browser\"\n\t\"github.com/chromedp/cdproto/cdp\"\n\t\"github.com/chromedp/cdproto/css\"\n\t\"github.com/chromedp/cdproto/dom\"\n\t\"github.com/chromedp/cdproto/inspector\"\n\t\"github.com/chromedp/cdproto/log\"\n\t\"github.com/chromedp/cdproto/network\"\n\t\"github.com/chromedp/cdproto/page\"\n\t\"github.com/chromedp/cdproto/runtime\"\n\t\"github.com/chromedp/cdproto/target\"\n)\n\n// Context is attached to any context.Context which is valid for use with Run.\ntype Context struct {\n\t// Allocator is used to create new browsers. It is inherited from the\n\t// parent context when using NewContext.\n\tAllocator Allocator\n\n\t// Browser is the browser being used in the context. It is inherited\n\t// from the parent context when using NewContext.\n\tBrowser *Browser\n\n\t// Target is the target to run actions (commands) against. It is not\n\t// inherited from the parent context, and typically each context will\n\t// have its own unique Target pointing to a separate browser tab (page).\n\tTarget *Target\n\n\t// targetID is set up by WithTargetID. If nil, Run will pick the only\n\t// unused page target, or create a new one.\n\ttargetID target.ID\n\n\t// createBrowserContextParams is set up by WithNewBrowserContext. It is used\n\t// to create a new BrowserContext.\n\tcreateBrowserContextParams *target.CreateBrowserContextParams\n\n\t// browserContextOwner indicates whether this context is a BrowserContext\n\t// owner. The owner is responsible for disposing the BrowserContext once\n\t// the context is done.\n\tbrowserContextOwner bool\n\n\t// BrowserContextID is set up by WithExistingBrowserContext.\n\t//\n\t// Otherwise, BrowserContextID holds a non-empty value in the following cases:\n\t//\n\t// 1. if the context is created with the WithNewBrowserContext option, a new\n\t// BrowserContext is created on its first run, and BrowserContextID holds\n\t// the id of that new BrowserContext;\n\t//\n\t// 2. if the context is not created with the WithTargetID option, and its\n\t// parent context has a non-empty BrowserContextID, this context's\n\t// BrowserContextID is copied from the parent context.\n\tBrowserContextID cdp.BrowserContextID\n\n\tbrowserListeners []cancelableListener\n\ttargetListeners  []cancelableListener\n\n\t// browserOpts holds the browser options passed to NewContext via\n\t// WithBrowserOption, so that they can later be used when allocating a\n\t// browser in Run.\n\tbrowserOpts []BrowserOption\n\n\t// cancel simply cancels the context that was used to start Browser.\n\t// This is useful to stop all activity and avoid deadlocks if we detect\n\t// that the browser was closed or happened to crash. Note that this\n\t// cancel function doesn't do any waiting.\n\tcancel func()\n\n\t// first records whether this context created a brand new Chrome\n\t// process. This is important, because its cancellation should stop the\n\t// entire browser and its handler, and not just a portion of its pages.\n\tfirst bool\n\n\t// closedTarget allows waiting for a target's page to be closed on\n\t// cancellation.\n\tclosedTarget sync.WaitGroup\n\n\t// allocated is closed when an allocated browser completely stops. If no\n\t// browser needs to be allocated, the channel is simply not initialized\n\t// and remains nil.\n\tallocated chan struct{}\n\n\t// cancelErr is the first error encountered when cancelling this\n\t// context, for example if a browser's temporary user data directory\n\t// couldn't be deleted.\n\tcancelErr error\n}\n\n// NewContext creates a chromedp context from the parent context. The parent\n// context's Allocator is inherited, defaulting to an ExecAllocator with\n// DefaultExecAllocatorOptions.\n//\n// If the parent context contains an allocated Browser, the child context\n// inherits it, and its first Run creates a new tab on that browser. Otherwise,\n// its first Run will allocate a new browser.\n//\n// Cancelling the returned context will close a tab or an entire browser,\n// depending on the logic described above. To cancel a context while checking\n// for errors, see [Cancel].\n//\n// Note that NewContext doesn't allocate nor start a browser; that happens the\n// first time Run is used on the context.\nfunc NewContext(parent context.Context, opts ...ContextOption) (context.Context, context.CancelFunc) {\n\tctx, cancel := context.WithCancel(parent)\n\n\tc := &Context{cancel: cancel, first: true}\n\tvar parentBrowserContextID cdp.BrowserContextID\n\tif pc := FromContext(parent); pc != nil {\n\t\tc.Allocator = pc.Allocator\n\t\tc.Browser = pc.Browser\n\t\tparentBrowserContextID = pc.BrowserContextID\n\t\t// don't inherit Target, so that NewContext can be used to\n\t\t// create a new tab on the same browser.\n\n\t\tc.first = c.Browser == nil\n\n\t\t// TODO: make this more generic somehow.\n\t\tif _, ok := c.Allocator.(*RemoteAllocator); ok {\n\t\t\tc.first = false\n\t\t}\n\t}\n\tif c.Browser == nil {\n\t\t// set up the semaphore for Allocator.Allocate\n\t\tc.allocated = make(chan struct{}, 1)\n\t\tc.allocated <- struct{}{}\n\t}\n\n\tfor _, o := range opts {\n\t\to(c)\n\t}\n\tif c.createBrowserContextParams != nil && c.BrowserContextID != \"\" {\n\t\tpanic(\"WithExistingBrowserContext can not be used when WithNewBrowserContext is specified\")\n\t}\n\tif c.targetID == \"\" {\n\t\tif c.BrowserContextID == \"\" {\n\t\t\t// Inherit BrowserContextID from its parent context.\n\t\t\tc.BrowserContextID = parentBrowserContextID\n\t\t}\n\t} else {\n\t\tif c.createBrowserContextParams != nil {\n\t\t\tpanic(\"WithNewBrowserContext can not be used when WithTargetID is specified\")\n\t\t}\n\t\tif c.BrowserContextID != \"\" {\n\t\t\tpanic(\"WithExistingBrowserContext can not be used when WithTargetID is specified\")\n\t\t}\n\t}\n\n\tif c.Allocator == nil {\n\t\tc.Allocator = setupExecAllocator(DefaultExecAllocatorOptions[:]...)\n\t}\n\n\tctx = context.WithValue(ctx, contextKey{}, c)\n\tc.closedTarget.Add(1)\n\tgo func() {\n\t\t<-ctx.Done()\n\t\tdefer c.closedTarget.Done()\n\t\tif c.first {\n\t\t\t// This is the original browser tab, so the entire\n\t\t\t// browser will already be cleaned up elsewhere.\n\t\t\treturn\n\t\t}\n\n\t\tif c.Target == nil {\n\t\t\t// This is a new tab, but we didn't create it and attach\n\t\t\t// to it yet. Nothing to do.\n\t\t\treturn\n\t\t}\n\n\t\t// Not the original browser tab; simply detach and close it.\n\t\t// We need a new context, as ctx is cancelled; use a 1s timeout.\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\t\tdefer cancel()\n\t\tbrowserExecutor := cdp.WithExecutor(ctx, c.Browser)\n\t\tif id := c.Target.SessionID; id != \"\" {\n\t\t\taction := target.DetachFromTarget().WithSessionID(id)\n\t\t\tif err := action.Do(browserExecutor); c.cancelErr == nil && err != nil {\n\t\t\t\tc.cancelErr = err\n\t\t\t}\n\t\t}\n\t\tif id := c.Target.TargetID; id != \"\" {\n\t\t\taction := target.CloseTarget(id)\n\t\t\tif err := action.Do(browserExecutor); c.cancelErr == nil && err != nil {\n\t\t\t\tc.cancelErr = err\n\t\t\t}\n\t\t}\n\t\tif c.browserContextOwner {\n\t\t\taction := target.DisposeBrowserContext(c.BrowserContextID)\n\t\t\tif err := action.Do(browserExecutor); c.cancelErr == nil && err != nil {\n\t\t\t\tc.cancelErr = err\n\t\t\t}\n\t\t}\n\t}()\n\tcancelWait := func() {\n\t\tcancel()\n\t\tc.closedTarget.Wait()\n\t\t// If we allocated, wait for the browser to stop.\n\t\tif c.allocated != nil {\n\t\t\t<-c.allocated\n\t\t}\n\t}\n\treturn ctx, cancelWait\n}\n\ntype contextKey struct{}\n\n// FromContext extracts the Context data stored inside a context.Context.\nfunc FromContext(ctx context.Context) *Context {\n\tc, _ := ctx.Value(contextKey{}).(*Context)\n\treturn c\n}\n\n// Cancel cancels a chromedp context, waits for its resources to be cleaned up,\n// and returns any error encountered during that process.\n//\n// If the context allocated a browser, the browser will be closed gracefully by\n// Cancel. A timeout can be attached to this context to determine how long to\n// wait for the browser to close itself:\n//\n//\ttctx, tcancel := context.WithTimeout(ctx, 10 * time.Second)\n//\tdefer tcancel()\n//\tchromedp.Cancel(tctx)\n//\n// Usually a \"defer cancel()\" will be enough for most use cases. However, Cancel\n// is the better option if one wants to gracefully close a browser, or catch\n// underlying errors happening during cancellation.\nfunc Cancel(ctx context.Context) error {\n\tc := FromContext(ctx)\n\t// c.cancel is nil when Cancel is wrongly called with a context returned\n\t// by chromedp.NewExecAllocator or chromedp.NewRemoteAllocator.\n\tif c == nil || c.cancel == nil {\n\t\treturn ErrInvalidContext\n\t}\n\tgraceful := c.first && c.Browser != nil\n\tif graceful {\n\t\tclose(c.Browser.closingGracefully)\n\t\tif err := c.Browser.execute(ctx, browser.CommandClose, nil, nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tc.cancel()\n\t\tc.closedTarget.Wait()\n\t}\n\t// If we allocated, wait for the browser to stop, up to any possible\n\t// deadline set in this ctx.\n\tready := false\n\tif c.allocated != nil {\n\t\tselect {\n\t\tcase <-c.allocated:\n\t\t\tready = true\n\t\tcase <-ctx.Done():\n\t\t}\n\t}\n\t// If this was a graceful close, cancel the entire context, in case any\n\t// goroutines or resources are left, or if we hit the timeout above and\n\t// the browser hasn't finished yet. Note that, in the non-graceful path,\n\t// we already called c.cancel above.\n\tif graceful {\n\t\tc.cancel()\n\t}\n\n\t// If we allocated and we hit ctx.Done earlier, we can't rely on\n\t// cancelErr being ready until the allocated channel is closed, as that\n\t// is racy. If we didn't hit ctx.Done earlier, then c.allocated was\n\t// already cancelled then, so this will be a no-op.\n\tif !ready && c.allocated != nil {\n\t\t<-c.allocated\n\t}\n\treturn c.cancelErr\n}\n\nfunc initContextBrowser(ctx context.Context) (*Context, error) {\n\tc := FromContext(ctx)\n\t// If c is nil, it's not a chromedp context.\n\t// If c.Allocator is nil, NewContext wasn't used properly.\n\t// If c.cancel is nil, Run is being called directly with an allocator\n\t// context.\n\tif c == nil || c.Allocator == nil || c.cancel == nil {\n\t\treturn nil, ErrInvalidContext\n\t}\n\tif c.Browser == nil {\n\t\tb, err := c.Allocator.Allocate(ctx, c.browserOpts...)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tc.Browser = b\n\t\tc.Browser.listeners = append(c.Browser.listeners, c.browserListeners...)\n\t}\n\treturn c, nil\n}\n\n// Run runs an action against context. The provided context must be a valid\n// chromedp context, typically created via NewContext.\n//\n// Note that the first time Run is called on a context, a browser will be\n// allocated via Allocator. Thus, it's generally a bad idea to use a context\n// timeout on the first Run call, as it will stop the entire browser.\n//\n// Also note that the actions are run with the Target executor. In the case that\n// a Browser executor is required, the action can be written like this:\n//\n//\terr := chromedp.Run(ctx, chromedp.ActionFunc(func(ctx context.Context) error {\n//\t\tc := chromedp.FromContext(ctx)\n//\t\tid, err := target.CreateBrowserContext().Do(cdp.WithExecutor(ctx, c.Browser))\n//\t\treturn err\n//\t}))\nfunc Run(ctx context.Context, actions ...Action) error {\n\tc, err := initContextBrowser(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c.Target == nil {\n\t\tif err := c.newTarget(ctx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn Tasks(actions).Do(cdp.WithExecutor(ctx, c.Target))\n}\n\nfunc (c *Context) newTarget(ctx context.Context) error {\n\tif c.targetID != \"\" {\n\t\tif err := c.attachTarget(ctx, c.targetID); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// This new page might have already loaded its top-level frame\n\t\t// already, in which case we wouldn't see the frameNavigated and\n\t\t// documentUpdated events. Load them here.\n\t\t// Since at the time of writing this (2020-1-27), Page.* CDP methods are\n\t\t// not implemented in worker targets, we need to skip this step when we\n\t\t// attach to workers.\n\t\tif !c.Target.isWorker {\n\t\t\ttree, err := page.GetFrameTree().Do(cdp.WithExecutor(ctx, c.Target))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tc.Target.frameMu.Lock()\n\t\t\tc.Target.frames[tree.Frame.ID] = tree.Frame\n\t\t\tc.Target.cur = tree.Frame.ID\n\t\t\tc.Target.frameMu.Unlock()\n\n\t\t\tc.Target.documentUpdated(ctx)\n\t\t}\n\t\treturn nil\n\t}\n\tif !c.first {\n\t\tvar err error\n\t\tbrowserExecutor := cdp.WithExecutor(ctx, c.Browser)\n\t\tif c.createBrowserContextParams != nil {\n\t\t\tc.BrowserContextID, err = c.createBrowserContextParams.Do(browserExecutor)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.browserContextOwner = true\n\t\t\tc.createBrowserContextParams = nil\n\t\t}\n\t\tc.targetID, err = target.CreateTarget(\"about:blank\").WithBrowserContextID(c.BrowserContextID).Do(browserExecutor)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn c.attachTarget(ctx, c.targetID)\n\t}\n\n\t// This is like WaitNewTarget, but for the entire browser.\n\tch := make(chan target.ID, 1)\n\tlctx, cancel := context.WithCancel(ctx)\n\tListenBrowser(lctx, func(ev interface{}) {\n\t\tvar info *target.Info\n\t\tswitch ev := ev.(type) {\n\t\tcase *target.EventTargetCreated:\n\t\t\tinfo = ev.TargetInfo\n\t\tcase *target.EventTargetInfoChanged:\n\t\t\tinfo = ev.TargetInfo\n\t\tdefault:\n\t\t\treturn\n\t\t}\n\t\t// In the following cases, the browser will start with a non-blank tab:\n\t\t// 1. with the \"--app\" option (should disable headless mode);\n\t\t// 2. URL other than \"about:blank\" is placed in the command line arguments.\n\t\t// So we should not require that the URL to be \"about:blank\".\n\t\t// See issue https://github.com/chromedp/chromedp/issues/1076\n\t\t// In any cases that the browser starts with multiple tabs open,\n\t\t// it should be okay to attach to any one of them (no matter whether it\n\t\t// is blank).\n\t\tif info.Type == \"page\" {\n\t\t\tselect {\n\t\t\tcase <-lctx.Done():\n\t\t\tcase ch <- info.TargetID:\n\t\t\t}\n\t\t\tcancel()\n\t\t}\n\t})\n\n\t// wait for the first tab to appear\n\taction := target.SetDiscoverTargets(true)\n\tif err := action.Do(cdp.WithExecutor(ctx, c.Browser)); err != nil {\n\t\treturn err\n\t}\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tcase c.targetID = <-ch:\n\t}\n\treturn c.attachTarget(ctx, c.targetID)\n}\n\nfunc (c *Context) attachTarget(ctx context.Context, targetID target.ID) error {\n\tsessionID, err := target.AttachToTarget(targetID).WithFlatten(true).Do(cdp.WithExecutor(ctx, c.Browser))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.Target, err = c.Browser.newExecutorForTarget(ctx, targetID, sessionID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.Target.listeners = append(c.Target.listeners, c.targetListeners...)\n\tgo c.Target.run(ctx)\n\n\t// Check if this is a worker target. We cannot use Target.getTargetInfo or\n\t// Target.getTargets in a worker, so we check if \"self\" refers to a\n\t// WorkerGlobalScope or ServiceWorkerGlobalScope.\n\tif err := runtime.Enable().Do(cdp.WithExecutor(ctx, c.Target)); err != nil {\n\t\treturn err\n\t}\n\tres, _, err := runtime.Evaluate(\"self\").Do(cdp.WithExecutor(ctx, c.Target))\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.Target.isWorker = strings.Contains(res.ClassName, \"WorkerGlobalScope\")\n\n\t// Enable available domains and discover targets.\n\tactions := []Action{\n\t\tlog.Enable(),\n\t\tnetwork.Enable(),\n\t}\n\t// These actions are not available on a worker target.\n\tif !c.Target.isWorker {\n\t\tactions = append(actions, []Action{\n\t\t\tinspector.Enable(),\n\t\t\tpage.Enable(),\n\t\t\tdom.Enable(),\n\t\t\tcss.Enable(),\n\t\t\ttarget.SetDiscoverTargets(true),\n\t\t\ttarget.SetAutoAttach(true, false).WithFlatten(true),\n\t\t\tpage.SetLifecycleEventsEnabled(true),\n\t\t}...)\n\t}\n\n\tfor _, action := range actions {\n\t\tif err := action.Do(cdp.WithExecutor(ctx, c.Target)); err != nil {\n\t\t\treturn fmt.Errorf(\"unable to execute %T: %w\", action, err)\n\t\t}\n\t}\n\treturn nil\n}\n\n// ContextOption is a context option.\ntype ContextOption = func(*Context)\n\n// WithTargetID sets up a context to be attached to an existing target, instead\n// of creating a new one.\nfunc WithTargetID(id target.ID) ContextOption {\n\treturn func(c *Context) { c.targetID = id }\n}\n\n// CreateBrowserContextOption is a BrowserContext creation options.\ntype CreateBrowserContextOption = func(*target.CreateBrowserContextParams) *target.CreateBrowserContextParams\n\n// WithNewBrowserContext sets up a context to create a new BrowserContext, and\n// create a new target in this BrowserContext. A child context will create its\n// target in this BrowserContext too, unless it's set up with other options.\n// The new BrowserContext will be disposed when the context is done.\nfunc WithNewBrowserContext(options ...CreateBrowserContextOption) ContextOption {\n\treturn func(c *Context) {\n\t\tif c.first {\n\t\t\tpanic(\"WithNewBrowserContext can not be used before Browser is initialized\")\n\t\t}\n\n\t\tparams := target.CreateBrowserContext().WithDisposeOnDetach(true)\n\t\tfor _, o := range options {\n\t\t\tparams = o(params)\n\t\t}\n\t\tc.createBrowserContextParams = params\n\t}\n}\n\n// WithExistingBrowserContext sets up a context to create a new target in the\n// specified browser context.\nfunc WithExistingBrowserContext(id cdp.BrowserContextID) ContextOption {\n\treturn func(c *Context) {\n\t\tif c.first {\n\t\t\tpanic(\"WithExistingBrowserContext can not be used before Browser is initialized\")\n\t\t}\n\t\tc.BrowserContextID = id\n\t}\n}\n\n// WithLogf is a shortcut for WithBrowserOption(WithBrowserLogf(f)).\nfunc WithLogf(f func(string, ...interface{})) ContextOption {\n\treturn WithBrowserOption(WithBrowserLogf(f))\n}\n\n// WithErrorf is a shortcut for WithBrowserOption(WithBrowserErrorf(f)).\nfunc WithErrorf(f func(string, ...interface{})) ContextOption {\n\treturn WithBrowserOption(WithBrowserErrorf(f))\n}\n\n// WithDebugf is a shortcut for WithBrowserOption(WithBrowserDebugf(f)).\nfunc WithDebugf(f func(string, ...interface{})) ContextOption {\n\treturn WithBrowserOption(WithBrowserDebugf(f))\n}\n\n// WithBrowserOption allows passing a number of browser options to the allocator\n// when allocating a new browser. As such, this context option can only be used\n// when NewContext is allocating a new browser.\nfunc WithBrowserOption(opts ...BrowserOption) ContextOption {\n\treturn func(c *Context) {\n\t\tif c.Browser != nil {\n\t\t\tpanic(\"WithBrowserOption can only be used when allocating a new browser\")\n\t\t}\n\t\tc.browserOpts = append(c.browserOpts, opts...)\n\t}\n}\n\n// RunResponse is an alternative to Run which can be used with a list of actions\n// that trigger a page navigation, such as clicking on a link or button.\n//\n// RunResponse will run the actions and block until a page loads, returning the\n// HTTP response information for its HTML document. This can be useful to wait\n// for the page to be ready, or to catch 404 status codes, for example.\n//\n// Note that if the actions trigger multiple navigations, only the first is\n// used. And if the actions trigger no navigations at all, RunResponse will\n// block until the context is cancelled.\nfunc RunResponse(ctx context.Context, actions ...Action) (*network.Response, error) {\n\tvar resp *network.Response\n\tif err := Run(ctx, responseAction(&resp, actions...)); err != nil {\n\t\treturn nil, err\n\t}\n\treturn resp, nil\n}\n\nfunc responseAction(resp **network.Response, actions ...Action) Action {\n\treturn ActionFunc(func(ctx context.Context) error {\n\t\t// loaderID lets us filter the requests from the currently\n\t\t// loading navigation.\n\t\tvar loaderID cdp.LoaderID\n\n\t\t// reqID is the request we're currently looking at. This can\n\t\t// go through multiple values, e.g. if the page redirects.\n\t\tvar reqID network.RequestID\n\n\t\t// frameID corresponds to the target's root frame.\n\t\tvar frameID cdp.FrameID\n\n\t\tvar loadErr error\n\t\thasInit := false\n\t\tfinished := false\n\n\t\t// First, set up the function to handle events.\n\t\t// We are listening for lifecycle events, so we will use those to\n\t\t// make sure we grab the response for a request initiated by the\n\t\t// loaderID that we want.\n\n\t\tlctx, lcancel := context.WithCancel(ctx)\n\t\tdefer lcancel()\n\t\thandleEvent := func(ev interface{}) {\n\t\t\tswitch ev := ev.(type) {\n\t\t\tcase *network.EventRequestWillBeSent:\n\t\t\t\tif ev.LoaderID == loaderID && ev.Type == network.ResourceTypeDocument {\n\t\t\t\t\treqID = ev.RequestID\n\t\t\t\t}\n\t\t\tcase *network.EventLoadingFailed:\n\t\t\t\tif ev.RequestID == reqID {\n\t\t\t\t\tloadErr = fmt.Errorf(\"page load error %s\", ev.ErrorText)\n\t\t\t\t\t// If Canceled is true, we won't receive a\n\t\t\t\t\t// loadEventFired at all.\n\t\t\t\t\tif ev.Canceled {\n\t\t\t\t\t\tfinished = true\n\t\t\t\t\t\tlcancel()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase *network.EventResponseReceived:\n\t\t\t\tif ev.RequestID == reqID && resp != nil {\n\t\t\t\t\t*resp = ev.Response\n\t\t\t\t}\n\t\t\tcase *page.EventLifecycleEvent:\n\t\t\t\tif ev.FrameID == frameID && ev.Name == \"init\" {\n\t\t\t\t\thasInit = true\n\t\t\t\t}\n\t\t\tcase *page.EventLoadEventFired:\n\t\t\t\t// Ignore load events before the \"init\"\n\t\t\t\t// lifecycle event, as those are old.\n\t\t\t\tif hasInit {\n\t\t\t\t\tfinished = true\n\t\t\t\t\tlcancel()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// earlyEvents is a buffered list of events which happened\n\t\t// before we knew what loaderID to look for.\n\t\tvar earlyEvents []interface{}\n\n\t\t// Obtain frameID from the target.\n\t\tc := FromContext(ctx)\n\t\tc.Target.frameMu.RLock()\n\t\tframeID = c.Target.cur\n\t\tc.Target.frameMu.RUnlock()\n\n\t\tListenTarget(lctx, func(ev interface{}) {\n\t\t\tif loaderID != \"\" {\n\t\t\t\thandleEvent(ev)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tearlyEvents = append(earlyEvents, ev)\n\t\t\tswitch ev := ev.(type) {\n\t\t\tcase *page.EventFrameNavigated:\n\t\t\t\t// Make sure we keep frameID up to date.\n\t\t\t\tif ev.Frame.ParentID == \"\" {\n\t\t\t\t\tframeID = ev.Frame.ID\n\t\t\t\t}\n\t\t\tcase *network.EventRequestWillBeSent:\n\t\t\t\t// Under some circumstances like ERR_TOO_MANY_REDIRECTS, we never\n\t\t\t\t// see the \"init\" lifecycle event we want. Those \"lone\" requests\n\t\t\t\t// also tend to have a loaderID that matches their requestID, for\n\t\t\t\t// some reason. If such a request is seen, use it.\n\t\t\t\t// TODO: research this some more when we have the time.\n\t\t\t\tif ev.FrameID == frameID && string(ev.LoaderID) == string(ev.RequestID) {\n\t\t\t\t\tloaderID = ev.LoaderID\n\t\t\t\t}\n\t\t\tcase *page.EventLifecycleEvent:\n\t\t\t\tif ev.FrameID == frameID && ev.Name == \"init\" {\n\t\t\t\t\tloaderID = ev.LoaderID\n\t\t\t\t}\n\t\t\tcase *page.EventNavigatedWithinDocument:\n\t\t\t\t// A fragment navigation doesn't need extra steps.\n\t\t\t\tfinished = true\n\t\t\t\tlcancel()\n\t\t\t}\n\t\t\tif loaderID != \"\" {\n\t\t\t\tfor _, ev := range earlyEvents {\n\t\t\t\t\thandleEvent(ev)\n\t\t\t\t}\n\t\t\t\tearlyEvents = nil\n\t\t\t}\n\t\t})\n\n\t\t// Second, run the actions.\n\t\tif err := Run(ctx, actions...); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Third, block until we have finished loading.\n\t\tselect {\n\t\tcase <-lctx.Done():\n\t\t\tif loadErr != nil {\n\t\t\t\treturn loadErr\n\t\t\t}\n\n\t\t\t// If the ctx parameter was cancelled by the caller (or\n\t\t\t// by a timeout etc.) the select will race between\n\t\t\t// lctx.Done and ctx.Done, since lctx is a sub-context\n\t\t\t// of ctx. So we can't return nil here, as otherwise\n\t\t\t// that race would mean that we would drop 50% of the\n\t\t\t// parent context cancellation errors.\n\t\t\tif !finished {\n\t\t\t\treturn ctx.Err()\n\t\t\t}\n\t\t\treturn nil\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\t}\n\t})\n}\n\n// Targets lists all the targets in the browser attached to the given context.\nfunc Targets(ctx context.Context) ([]*target.Info, error) {\n\tc, err := initContextBrowser(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// TODO: If this is a new browser, the initial target (tab) might not be\n\t// ready yet. Should we block until at least one target is available?\n\t// Right now, the caller has to add retries with a timeout.\n\treturn target.GetTargets().Do(cdp.WithExecutor(ctx, c.Browser))\n}\n\n// Action is the common interface for an action that will be executed against a\n// context and frame handler.\ntype Action interface {\n\t// Do executes the action using the provided context and frame handler.\n\tDo(context.Context) error\n}\n\n// ActionFunc is an adapter to allow the use of ordinary func's as an Action.\ntype ActionFunc func(context.Context) error\n\n// Do executes the func f using the provided context and frame handler.\nfunc (f ActionFunc) Do(ctx context.Context) error {\n\treturn f(ctx)\n}\n\n// Tasks is a sequential list of Actions that can be used as a single Action.\ntype Tasks []Action\n\n// Do executes the list of Actions sequentially, using the provided context and\n// frame handler.\nfunc (t Tasks) Do(ctx context.Context) error {\n\tfor _, a := range t {\n\t\tif err := a.Do(ctx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Sleep is an empty action that calls time.Sleep with the specified duration.\n//\n// Note: this is a temporary action definition for convenience, and will likely\n// be marked for deprecation in the future, after the remaining Actions have\n// been able to be written/tested.\nfunc Sleep(d time.Duration) Action {\n\treturn ActionFunc(func(ctx context.Context) error {\n\t\treturn sleepContext(ctx, d)\n\t})\n}\n\n// sleepContext sleeps for the specified duration. It returns ctx.Err() immediately\n// if the context is cancelled.\nfunc sleepContext(ctx context.Context, d time.Duration) error {\n\ttimer := time.NewTimer(d)\n\tselect {\n\tcase <-ctx.Done():\n\t\tif !timer.Stop() {\n\t\t\t<-timer.C\n\t\t}\n\t\treturn ctx.Err()\n\tcase <-timer.C:\n\t\treturn nil\n\t}\n}\n\n// retryWithSleep reties the execution of the specified func until the func returns\n// true (means to stop) or a non-nil error.\nfunc retryWithSleep(ctx context.Context, d time.Duration, f func(ctx context.Context) (bool, error)) error {\n\tfor {\n\t\ttoStop, err := f(ctx)\n\t\tif toStop || err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = sleepContext(ctx, d)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\ntype cancelableListener struct {\n\tctx context.Context\n\tfn  func(ev interface{})\n}\n\n// ListenBrowser adds a function which will be called whenever a browser event\n// is received on the chromedp context. Note that this only includes browser\n// events; command responses and target events are not included. Cancelling ctx\n// stops the listener from receiving any more events.\n//\n// Note that the function is called synchronously when handling events. The\n// function should avoid blocking at all costs. For example, any Actions must be\n// run via a separate goroutine (otherwise, it could result in a deadlock if the\n// action sends CDP messages).\nfunc ListenBrowser(ctx context.Context, fn func(ev interface{})) {\n\tc := FromContext(ctx)\n\tif c == nil {\n\t\tpanic(ErrInvalidContext)\n\t}\n\tcl := cancelableListener{ctx, fn}\n\tif c.Browser != nil {\n\t\tc.Browser.listenersMu.Lock()\n\t\tc.Browser.listeners = append(c.Browser.listeners, cl)\n\t\tc.Browser.listenersMu.Unlock()\n\t} else {\n\t\tc.browserListeners = append(c.browserListeners, cl)\n\t}\n}\n\n// ListenTarget adds a function which will be called whenever a target event is\n// received on the chromedp context. Cancelling ctx stops the listener from\n// receiving any more events.\n//\n// Note that the function is called synchronously when handling events. The\n// function should avoid blocking at all costs. For example, any Actions must be\n// run via a separate goroutine (otherwise, it could result in a deadlock if the\n// action sends CDP messages).\nfunc ListenTarget(ctx context.Context, fn func(ev interface{})) {\n\tc := FromContext(ctx)\n\tif c == nil {\n\t\tpanic(ErrInvalidContext)\n\t}\n\tcl := cancelableListener{ctx, fn}\n\tif c.Target != nil {\n\t\tc.Target.listenersMu.Lock()\n\t\tc.Target.listeners = append(c.Target.listeners, cl)\n\t\tc.Target.listenersMu.Unlock()\n\t} else {\n\t\tc.targetListeners = append(c.targetListeners, cl)\n\t}\n}\n\n// WaitNewTarget can be used to wait for the current target to open a new\n// target. Once fn matches a new unattached target, its target ID is sent via\n// the returned channel.\nfunc WaitNewTarget(ctx context.Context, fn func(*target.Info) bool) <-chan target.ID {\n\tch := make(chan target.ID, 1)\n\tlctx, cancel := context.WithCancel(ctx)\n\tListenTarget(lctx, func(ev interface{}) {\n\t\tvar info *target.Info\n\t\tswitch ev := ev.(type) {\n\t\tcase *target.EventTargetCreated:\n\t\t\tinfo = ev.TargetInfo\n\t\tcase *target.EventTargetInfoChanged:\n\t\t\tinfo = ev.TargetInfo\n\t\tdefault:\n\t\t\treturn\n\t\t}\n\t\tif info.OpenerID == \"\" {\n\t\t\treturn // not a child target\n\t\t}\n\t\tif info.Attached {\n\t\t\treturn // already attached; not a new target\n\t\t}\n\t\tif fn(info) {\n\t\t\tselect {\n\t\t\tcase <-lctx.Done():\n\t\t\tcase ch <- info.TargetID:\n\t\t\t}\n\t\t\tclose(ch)\n\t\t\tcancel()\n\t\t}\n\t})\n\treturn ch\n}\n"
        },
        {
          "name": "chromedp_test.go",
          "type": "blob",
          "size": 40.640625,
          "content": "package chromedp\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"image/color\"\n\t\"image/png\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"text/template\"\n\t\"time\"\n\n\t\"github.com/chromedp/cdproto/browser\"\n\t\"github.com/chromedp/cdproto/cdp\"\n\t\"github.com/chromedp/cdproto/dom\"\n\t\"github.com/chromedp/cdproto/network\"\n\t\"github.com/chromedp/cdproto/page\"\n\t\"github.com/chromedp/cdproto/runtime\"\n\t\"github.com/chromedp/cdproto/target\"\n\t\"github.com/ledongthuc/pdf\"\n)\n\nvar (\n\t// these are set up in init\n\texecPath    string\n\ttestdataDir string\n\tallocOpts   = DefaultExecAllocatorOptions[:]\n\n\t// allocCtx is initialised in TestMain, to cancel before exiting.\n\tallocCtx context.Context\n\n\t// browserCtx is initialised with allocateOnce\n\tbrowserCtx context.Context\n)\n\nfunc init() {\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"could not get working directory: %v\", err))\n\t}\n\ttestdataDir = \"file://\" + path.Join(wd, \"testdata\")\n\n\tallocTempDir, err = os.MkdirTemp(\"\", \"chromedp-test\")\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"could not create temp directory: %v\", err))\n\t}\n\n\t// Disabling the GPU helps portability with some systems like Travis,\n\t// and can slightly speed up the tests on other systems.\n\tallocOpts = append(allocOpts, DisableGPU)\n\n\tif noHeadless := os.Getenv(\"CHROMEDP_NO_HEADLESS\"); noHeadless != \"\" && noHeadless != \"false\" {\n\t\tallocOpts = append(allocOpts, Flag(\"headless\", false))\n\t}\n\n\t// Find the exec path once at startup.\n\texecPath = os.Getenv(\"CHROMEDP_TEST_RUNNER\")\n\tif execPath == \"\" {\n\t\texecPath = findExecPath()\n\t}\n\tallocOpts = append(allocOpts, ExecPath(execPath))\n\n\t// Not explicitly needed to be set, as this speeds up the tests\n\tif noSandbox := os.Getenv(\"CHROMEDP_NO_SANDBOX\"); noSandbox != \"false\" {\n\t\tallocOpts = append(allocOpts, NoSandbox)\n\t}\n}\n\nvar browserOpts []ContextOption\n\nfunc TestMain(m *testing.M) {\n\tvar cancel context.CancelFunc\n\tallocCtx, cancel = NewExecAllocator(context.Background(), allocOpts...)\n\n\tif debug := os.Getenv(\"CHROMEDP_DEBUG\"); debug != \"\" && debug != \"false\" {\n\t\tbrowserOpts = append(browserOpts, WithDebugf(log.Printf))\n\t}\n\n\tcode := m.Run()\n\tcancel()\n\n\tif infos, _ := os.ReadDir(allocTempDir); len(infos) > 0 {\n\t\tos.RemoveAll(allocTempDir)\n\t\tpanic(fmt.Sprintf(\"leaked %d temporary dirs under %s\", len(infos), allocTempDir))\n\t} else {\n\t\tos.Remove(allocTempDir)\n\t}\n\n\tos.Exit(code)\n}\n\nvar allocateOnce sync.Once\n\nfunc testAllocate(tb testing.TB, name string) (context.Context, context.CancelFunc) {\n\t// Start the browser exactly once, as needed.\n\tallocateOnce.Do(func() { browserCtx, _ = testAllocateSeparate(tb) })\n\n\tif browserCtx == nil {\n\t\t// allocateOnce.Do failed; continuing would result in panics.\n\t\ttb.FailNow()\n\t}\n\n\t// Same browser, new tab; not needing to start new chrome browsers for\n\t// each test gives a huge speed-up.\n\tctx, _ := NewContext(browserCtx)\n\n\t// Only navigate if we want an HTML file name, otherwise leave the blank page.\n\tif name != \"\" {\n\t\tif err := Run(ctx, Navigate(testdataDir+\"/\"+name)); err != nil {\n\t\t\ttb.Fatal(err)\n\t\t}\n\t}\n\n\tcancel := func() {\n\t\tif err := Cancel(ctx); err != nil {\n\t\t\ttb.Error(err)\n\t\t}\n\t}\n\treturn ctx, cancel\n}\n\nfunc testAllocateSeparate(tb testing.TB) (context.Context, context.CancelFunc) {\n\t// Entirely new browser, unlike testAllocate.\n\tctx, _ := NewContext(allocCtx, browserOpts...)\n\tif err := Run(ctx); err != nil {\n\t\ttb.Fatal(err)\n\t}\n\tListenBrowser(ctx, func(ev interface{}) {\n\t\tif ev, ok := ev.(*runtime.EventExceptionThrown); ok {\n\t\t\ttb.Errorf(\"%+v\\n\", ev.ExceptionDetails)\n\t\t}\n\t})\n\tcancel := func() {\n\t\tif err := Cancel(ctx); err != nil {\n\t\t\ttb.Error(err)\n\t\t}\n\t}\n\treturn ctx, cancel\n}\n\nfunc BenchmarkTabNavigate(b *testing.B) {\n\tb.ReportAllocs()\n\n\tallocCtx, cancel := NewExecAllocator(context.Background(), allocOpts...)\n\tdefer cancel()\n\n\t// start the browser\n\tbctx, _ := NewContext(allocCtx)\n\tif err := Run(bctx); err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tctx, _ := NewContext(bctx)\n\t\t\tif err := Run(ctx,\n\t\t\t\tNavigate(testdataDir+\"/form.html\"),\n\t\t\t\tWaitVisible(`#form`, ByID),\n\t\t\t); err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t\tif err := Cancel(ctx); err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n\n// checkTargets fatals if the browser behind the chromedp context has an\n// unexpected number of pages (tabs).\nfunc checkTargets(tb testing.TB, ctx context.Context, want int) {\n\ttb.Helper()\n\tinfos, err := Targets(ctx)\n\tif err != nil {\n\t\ttb.Fatal(err)\n\t}\n\tvar pages []*target.Info\n\tfor _, info := range infos {\n\t\tif info.Type == \"page\" {\n\t\t\tpages = append(pages, info)\n\t\t}\n\t}\n\tif got := len(pages); want != got {\n\t\tvar summaries []string\n\t\tfor _, info := range pages {\n\t\t\tsummaries = append(summaries, fmt.Sprintf(\"%v\", info))\n\t\t}\n\t\ttb.Fatalf(\"want %d targets, got %d:\\n%s\",\n\t\t\twant, got, strings.Join(summaries, \"\\n\"))\n\t}\n}\n\nfunc TestTargets(t *testing.T) {\n\tt.Parallel()\n\n\t// Start one browser with one tab.\n\tctx1, cancel1 := testAllocateSeparate(t)\n\tdefer cancel1()\n\n\tcheckTargets(t, ctx1, 1)\n\n\t// Start a second tab on the same browser.\n\tctx2, cancel2 := NewContext(ctx1)\n\tdefer cancel2()\n\tif err := Run(ctx2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcheckTargets(t, ctx2, 2)\n\n\t// The first context should also see both targets.\n\tcheckTargets(t, ctx1, 2)\n\n\t// Cancelling the second context should close the second tab alone.\n\tcancel2()\n\tcheckTargets(t, ctx1, 1)\n\n\t// We used to have a bug where Run would reset the first context as if\n\t// it weren't the first, breaking its cancellation.\n\tif err := Run(ctx1); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// We should see one attached target, since we closed the second a while\n\t// ago. If we see two, that means there's a memory leak, as we're\n\t// holding onto the detached target.\n\tpages := FromContext(ctx1).Browser.pages\n\tif len(pages) != 1 {\n\t\tt.Fatalf(\"expected one attached target, got %d\", len(pages))\n\t}\n}\n\nfunc TestCancelError(t *testing.T) {\n\tt.Parallel()\n\n\tctx1, cancel1 := testAllocate(t, \"\")\n\tdefer cancel1()\n\tif err := Run(ctx1); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Open and close a target normally; no error.\n\tctx2, cancel2 := NewContext(ctx1)\n\tdefer cancel2()\n\tif err := Run(ctx2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := Cancel(ctx2); err != nil {\n\t\tt.Fatalf(\"expected a nil error, got %v\", err)\n\t}\n\n\tif err := Cancel(allocCtx); err != ErrInvalidContext {\n\t\tt.Fatalf(\"want error %q, got %q\", ErrInvalidContext, err)\n\t}\n\n\t/*\n\t\t// NOTE: the following test no longer is applicable, as a slight change\n\t\t// to chromium's 89 API deprecated the boolean return value\n\n\t\t// Make \"cancel\" close the wrong target; error.\n\t\tctx3, cancel3 := NewContext(ctx1)\n\t\tdefer cancel3()\n\t\tif err := Run(ctx3); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tFromContext(ctx3).Target.TargetID = \"wrong\"\n\t\tif err := Cancel(ctx3); err == nil {\n\t\t\tt.Fatalf(\"expected a non-nil error, got %v\", err)\n\t\t}\n\t*/\n}\n\nfunc TestPrematureCancel(t *testing.T) {\n\tt.Parallel()\n\n\t// Cancel before the browser is allocated.\n\tctx, _ := NewContext(allocCtx, browserOpts...)\n\tif err := Cancel(ctx); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := Run(ctx); err != context.Canceled {\n\t\tt.Fatalf(\"wanted canceled context error, got %v\", err)\n\t}\n}\n\nfunc TestPrematureCancelTab(t *testing.T) {\n\tt.Parallel()\n\n\tctx1, cancel := testAllocate(t, \"\")\n\tdefer cancel()\n\tif err := Run(ctx1); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tctx2, cancel := NewContext(ctx1)\n\t// Cancel after the browser is allocated, but before we've created a new\n\t// tab.\n\tcancel()\n\tif err := Run(ctx2); err != context.Canceled {\n\t\tt.Fatalf(\"wanted canceled context error, got %v\", err)\n\t}\n}\n\nfunc TestPrematureCancelAllocator(t *testing.T) {\n\tt.Parallel()\n\n\t// To ensure we don't actually fire any Chrome processes.\n\tallocCtx, cancel := NewExecAllocator(context.Background(),\n\t\tExecPath(\"/do-not-run-chrome\"))\n\t// Cancel before the browser is allocated.\n\tcancel()\n\n\tctx, cancel := NewContext(allocCtx)\n\tdefer cancel()\n\tif err := Run(ctx); err != context.Canceled {\n\t\tt.Fatalf(\"wanted canceled context error, got %v\", err)\n\t}\n}\n\nfunc TestConcurrentCancel(t *testing.T) {\n\tt.Parallel()\n\n\t// To ensure we don't actually fire any Chrome processes.\n\tallocCtx, cancel := NewExecAllocator(context.Background(),\n\t\tExecPath(\"/do-not-run-chrome\"))\n\tdefer cancel()\n\n\tvar wg sync.WaitGroup\n\t// 50 is enough for 'go test -race' to easily spot issues.\n\tfor i := 0; i < 50; i++ {\n\t\twg.Add(2)\n\t\tctx, cancel := NewContext(allocCtx)\n\t\tgo func() {\n\t\t\tcancel()\n\t\t\twg.Done()\n\t\t}()\n\t\tgo func() {\n\t\t\t_ = Run(ctx)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc TestListenBrowser(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"\")\n\tdefer cancel()\n\n\t// Check that many ListenBrowser callbacks work, including adding\n\t// callbacks after the browser has been allocated.\n\tvar totalCount int32\n\tListenBrowser(ctx, func(ev interface{}) {\n\t\t// using sync/atomic, as the browser is shared.\n\t\tatomic.AddInt32(&totalCount, 1)\n\t})\n\tif err := Run(ctx); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tseenSessions := make(map[target.SessionID]bool)\n\tListenBrowser(ctx, func(ev interface{}) {\n\t\tif ev, ok := ev.(*target.EventAttachedToTarget); ok {\n\t\t\tseenSessions[ev.SessionID] = true\n\t\t}\n\t})\n\n\tnewTabCtx, cancel := NewContext(ctx)\n\tdefer cancel()\n\tif err := Run(newTabCtx, Navigate(testdataDir+\"/form.html\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcancel()\n\tif id := FromContext(newTabCtx).Target.SessionID; !seenSessions[id] {\n\t\tt.Fatalf(\"did not see Target.attachedToTarget for %q\", id)\n\t}\n\tif want, got := int32(1), atomic.LoadInt32(&totalCount); got < want {\n\t\tt.Fatalf(\"want at least %d browser events; got %d\", want, got)\n\t}\n}\n\nfunc TestListenTarget(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"\")\n\tdefer cancel()\n\n\t// Check that many listen callbacks work, including adding callbacks\n\t// after the target has been attached to.\n\tvar navigatedCount, updatedCount int\n\tListenTarget(ctx, func(ev interface{}) {\n\t\tif _, ok := ev.(*page.EventFrameNavigated); ok {\n\t\t\tnavigatedCount++\n\t\t}\n\t})\n\tif err := Run(ctx); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tListenTarget(ctx, func(ev interface{}) {\n\t\tif _, ok := ev.(*dom.EventDocumentUpdated); ok {\n\t\t\tupdatedCount++\n\t\t}\n\t})\n\n\tif err := Run(ctx, Navigate(testdataDir+\"/form.html\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcancel()\n\tif want := 1; navigatedCount != want {\n\t\tt.Fatalf(\"want %d Page.frameNavigated events; got %d\", want, navigatedCount)\n\t}\n\tif want := 1; updatedCount < want {\n\t\tt.Fatalf(\"want at least %d DOM.documentUpdated events; got %d\", want, updatedCount)\n\t}\n}\n\nfunc TestLargeEventCount(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"\")\n\tdefer cancel()\n\n\t// Simulate an environment where Chrome sends 2000 console log events,\n\t// and we are slow at processing them. In older chromedp versions, this\n\t// would crash as we would fill eventQueue and panic. 50ms is enough to\n\t// make the test fail somewhat reliably on old chromedp versions,\n\t// without making the test too slow.\n\tfirst := true\n\tListenTarget(ctx, func(ev interface{}) {\n\t\tif _, ok := ev.(*runtime.EventConsoleAPICalled); ok && first {\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\tfirst = false\n\t\t}\n\t})\n\n\tif err := Run(ctx,\n\t\tNavigate(testdataDir+\"/consolespam.html\"),\n\t\tWaitVisible(\"#done\", ByID), // wait for the JS to finish\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestLargeQuery(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"\")\n\tdefer cancel()\n\n\ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"<html><body>\\n\")\n\t\tfor i := 0; i < 2000; i++ {\n\t\t\tfmt.Fprintf(w, `<div>`)\n\t\t\tfmt.Fprintf(w, `<a href=\"/%d\">link %d</a>`, i, i)\n\t\t\tfmt.Fprintf(w, `</div>`)\n\t\t}\n\t\tfmt.Fprintf(w, \"</body></html>\\n\")\n\t}))\n\tdefer s.Close()\n\n\t// ByQueryAll queries thousands of events, which triggers thousands of\n\t// DOM events. The target handler used to get into a deadlock, as the\n\t// event queues would fill up and prevent the wait function from\n\t// receiving any result.\n\tvar nodes []*cdp.Node\n\tif err := Run(ctx,\n\t\tNavigate(s.URL),\n\t\tNodes(\"a\", &nodes, ByQueryAll),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestDialTimeout(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"ShortTimeoutError\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tl, err := net.Listen(\"tcp\", \":0\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\turl := \"ws://\" + l.(*net.TCPListener).Addr().String()\n\t\tdefer l.Close()\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tdefer cancel()\n\t\t_, err = NewBrowser(ctx, url, WithDialTimeout(time.Microsecond))\n\t\tgot, want := fmt.Sprintf(\"%v\", err), \"i/o timeout\"\n\t\tif !strings.Contains(got, want) {\n\t\t\tt.Fatalf(\"got %q, want %q\", got, want)\n\t\t}\n\t})\n\tt.Run(\"NoTimeoutSuccess\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tl, err := net.Listen(\"tcp\", \":0\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\turl := \"ws://\" + l.(*net.TCPListener).Addr().String()\n\t\tdefer l.Close()\n\t\tgo func() {\n\t\t\tconn, err := l.Accept()\n\t\t\tif err == nil {\n\t\t\t\tconn.Close()\n\t\t\t}\n\t\t}()\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tdefer cancel()\n\t\t_, err = NewBrowser(ctx, url, WithDialTimeout(0))\n\t\tgot := fmt.Sprintf(\"%v\", err)\n\t\tif !strings.Contains(got, \"EOF\") && !strings.Contains(got, \"connection reset\") {\n\t\t\tt.Fatalf(\"got %q, want %q or %q\", got, \"EOF\", \"connection reset\")\n\t\t}\n\t})\n}\n\nfunc TestListenCancel(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocateSeparate(t)\n\tdefer cancel()\n\n\t// Check that cancelling a listen context stops the listener.\n\tvar browserCount, targetCount int\n\n\tctx1, cancel1 := context.WithCancel(ctx)\n\tListenBrowser(ctx1, func(ev interface{}) {\n\t\tbrowserCount++\n\t\tcancel1()\n\t})\n\n\tctx2, cancel2 := context.WithCancel(ctx)\n\tListenTarget(ctx2, func(ev interface{}) {\n\t\ttargetCount++\n\t\tcancel2()\n\t})\n\n\tif err := Run(ctx, Navigate(testdataDir+\"/form.html\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want := 1; browserCount != 1 {\n\t\tt.Fatalf(\"want %d browser events; got %d\", want, browserCount)\n\t}\n\tif want := 1; targetCount != 1 {\n\t\tt.Fatalf(\"want %d target events; got %d\", want, targetCount)\n\t}\n}\n\nfunc TestLogOptions(t *testing.T) {\n\tt.Parallel()\n\n\tvar bufMu sync.Mutex\n\tvar buf bytes.Buffer\n\tfn := func(format string, a ...interface{}) {\n\t\tbufMu.Lock()\n\t\tfmt.Fprintf(&buf, format, a...)\n\t\tfmt.Fprintln(&buf)\n\t\tbufMu.Unlock()\n\t}\n\n\tctx, cancel := NewContext(context.Background(),\n\t\tWithErrorf(fn),\n\t\tWithLogf(fn),\n\t\tWithDebugf(fn),\n\t)\n\tdefer cancel()\n\tif err := Run(ctx, Navigate(testdataDir+\"/form.html\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcancel()\n\n\tbufMu.Lock()\n\tgot := buf.String()\n\tbufMu.Unlock()\n\tfor _, want := range []string{\n\t\t\"Page.navigate\",\n\t\t\"Page.frameNavigated\",\n\t} {\n\t\tif !strings.Contains(got, want) {\n\t\t\tt.Errorf(\"expected output to contain %q\", want)\n\t\t}\n\t}\n}\n\nfunc TestBrowserContext(t *testing.T) {\n\tctx, cancel := testAllocate(t, \"child1.html\")\n\tdefer cancel()\n\t// There is not a dedicated cdp command to get the default browser context.\n\t// Our workaround is to get it from a target which is created without the\n\t// \"browserContextId\" parameter.\n\tdefaultBrowserContextID := getBrowserContext(t, ctx)\n\n\t// Prepare 2 browser contexts to be used later.\n\trootCtx1, cancel := NewContext(browserCtx, WithNewBrowserContext())\n\tdefer cancel()\n\tif err := Run(rootCtx1); err != nil {\n\t\tt.Fatal(err)\n\t}\n\trootBrowserContextID1 := FromContext(rootCtx1).BrowserContextID\n\n\trootCtx2, cancel := NewContext(browserCtx, WithNewBrowserContext())\n\tdefer cancel()\n\tif err := Run(rootCtx2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\trootBrowserContextID2 := FromContext(rootCtx2).BrowserContextID\n\n\ttests := []struct {\n\t\tname         string\n\t\tarrange      func(t *testing.T) (context.Context, context.CancelFunc, cdp.BrowserContextID)\n\t\twantDisposed bool\n\t\twantPanic    string\n\t}{\n\t\t{\n\t\t\tname: \"default\",\n\t\t\tarrange: func(t *testing.T) (context.Context, context.CancelFunc, cdp.BrowserContextID) {\n\t\t\t\tctx, cancel := NewContext(browserCtx)\n\t\t\t\tif err := Run(ctx); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\treturn ctx, cancel, defaultBrowserContextID\n\t\t\t},\n\t\t\twantDisposed: false,\n\t\t\twantPanic:    \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"new\",\n\t\t\tarrange: func(t *testing.T) (context.Context, context.CancelFunc, cdp.BrowserContextID) {\n\t\t\t\tctx, cancel := NewContext(browserCtx, WithNewBrowserContext())\n\t\t\t\tif err := Run(ctx); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tc := FromContext(ctx)\n\t\t\t\treturn ctx, cancel, c.BrowserContextID\n\t\t\t},\n\t\t\twantDisposed: true,\n\t\t\twantPanic:    \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"existing\",\n\t\t\tarrange: func(t *testing.T) (context.Context, context.CancelFunc, cdp.BrowserContextID) {\n\t\t\t\tctx, cancel := NewContext(browserCtx, WithExistingBrowserContext(rootBrowserContextID1))\n\t\t\t\tif err := Run(ctx); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\treturn ctx, cancel, rootBrowserContextID1\n\t\t\t},\n\t\t\twantDisposed: false,\n\t\t\twantPanic:    \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"inherited 1\",\n\t\t\tarrange: func(t *testing.T) (context.Context, context.CancelFunc, cdp.BrowserContextID) {\n\t\t\t\tctx, cancel := NewContext(rootCtx1)\n\t\t\t\tif err := Run(ctx); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\treturn ctx, cancel, rootBrowserContextID1\n\t\t\t},\n\t\t\twantDisposed: false,\n\t\t\twantPanic:    \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"inherited 2\",\n\t\t\tarrange: func(t *testing.T) (context.Context, context.CancelFunc, cdp.BrowserContextID) {\n\t\t\t\tctx1, _ := NewContext(rootCtx1)\n\t\t\t\tif err := Run(ctx1); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tctx, cancel := NewContext(ctx1)\n\t\t\t\tif err := Run(ctx); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\treturn ctx, cancel, rootBrowserContextID1\n\t\t\t},\n\t\t\twantDisposed: false,\n\t\t\twantPanic:    \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"inherited 3\",\n\t\t\tarrange: func(t *testing.T) (context.Context, context.CancelFunc, cdp.BrowserContextID) {\n\t\t\t\tctx1, _ := NewContext(browserCtx, WithExistingBrowserContext(rootBrowserContextID1))\n\t\t\t\tif err := Run(ctx1); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tctx, cancel := NewContext(ctx1)\n\t\t\t\tif err := Run(ctx); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\treturn ctx, cancel, rootBrowserContextID1\n\t\t\t},\n\t\t\twantDisposed: false,\n\t\t\twantPanic:    \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"break inheritance 1\",\n\t\t\tarrange: func(t *testing.T) (context.Context, context.CancelFunc, cdp.BrowserContextID) {\n\t\t\t\tctx, cancel := NewContext(rootCtx1, WithExistingBrowserContext(rootBrowserContextID2))\n\t\t\t\tif err := Run(ctx); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\t// The target should be added to the second browser context.\n\t\t\t\treturn ctx, cancel, rootBrowserContextID2\n\t\t\t},\n\t\t\twantDisposed: false,\n\t\t\twantPanic:    \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"break inheritance 2\",\n\t\t\tarrange: func(t *testing.T) (context.Context, context.CancelFunc, cdp.BrowserContextID) {\n\t\t\t\tctx, cancel := NewContext(rootCtx1, WithNewBrowserContext())\n\t\t\t\tif err := Run(ctx); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tc := FromContext(ctx)\n\t\t\t\tif c.BrowserContextID == rootBrowserContextID1 {\n\t\t\t\t\tt.Fatal(\"a new BrowserContext should be created\")\n\t\t\t\t}\n\t\t\t\treturn ctx, cancel, c.BrowserContextID\n\t\t\t},\n\t\t\twantDisposed: true,\n\t\t\twantPanic:    \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"break inheritance 3\",\n\t\t\tarrange: func(t *testing.T) (context.Context, context.CancelFunc, cdp.BrowserContextID) {\n\t\t\t\tctx, cancel := NewContext(rootCtx1, WithTargetID(FromContext(rootCtx2).Target.TargetID))\n\t\t\t\tif err := Run(ctx); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\tc := FromContext(ctx)\n\t\t\t\tif c.BrowserContextID != \"\" {\n\t\t\t\t\tt.Fatal(\"when a context is used to attach to a tab, its BrowserContextID should be empty\")\n\t\t\t\t}\n\n\t\t\t\treturn ctx, cancel, rootBrowserContextID2\n\t\t\t},\n\t\t\twantDisposed: false,\n\t\t\twantPanic:    \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"WithNewBrowserContext when WithTargetID is specified\",\n\t\t\tarrange: func(t *testing.T) (context.Context, context.CancelFunc, cdp.BrowserContextID) {\n\t\t\t\tctx, _ := NewContext(rootCtx1)\n\t\t\t\tif err := Run(ctx); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tctx, cancel := NewContext(browserCtx, WithTargetID(FromContext(ctx).Target.TargetID), WithNewBrowserContext())\n\t\t\t\tif err := Run(ctx); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\treturn ctx, cancel, rootBrowserContextID1\n\t\t\t},\n\t\t\twantDisposed: false,\n\t\t\twantPanic:    \"WithNewBrowserContext can not be used when WithTargetID is specified\",\n\t\t},\n\t\t{\n\t\t\tname: \"WithExistingBrowserContext when WithTargetID is specified\",\n\t\t\tarrange: func(t *testing.T) (context.Context, context.CancelFunc, cdp.BrowserContextID) {\n\t\t\t\tctx, _ := NewContext(rootCtx1)\n\t\t\t\tif err := Run(ctx); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tctx, cancel := NewContext(browserCtx, WithTargetID(FromContext(ctx).Target.TargetID), WithExistingBrowserContext(rootBrowserContextID2))\n\t\t\t\tif err := Run(ctx); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\treturn ctx, cancel, rootBrowserContextID1\n\t\t\t},\n\t\t\twantDisposed: false,\n\t\t\twantPanic:    \"WithExistingBrowserContext can not be used when WithTargetID is specified\",\n\t\t},\n\t\t{\n\t\t\tname: \"WithNewBrowserContext before Browser is initialized\",\n\t\t\tarrange: func(t *testing.T) (context.Context, context.CancelFunc, cdp.BrowserContextID) {\n\t\t\t\tctx, cancel := NewContext(context.Background(), WithNewBrowserContext())\n\t\t\t\tif err := Run(ctx); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\treturn ctx, cancel, \"\"\n\t\t\t},\n\t\t\twantDisposed: false,\n\t\t\twantPanic:    \"WithNewBrowserContext can not be used before Browser is initialized\",\n\t\t},\n\t\t{\n\t\t\tname: \"WithExistingBrowserContext before Browser is initialized\",\n\t\t\tarrange: func(t *testing.T) (context.Context, context.CancelFunc, cdp.BrowserContextID) {\n\t\t\t\tctx, cancel := NewContext(context.Background(), WithExistingBrowserContext(rootBrowserContextID1))\n\t\t\t\tif err := Run(ctx); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\treturn ctx, cancel, \"\"\n\t\t\t},\n\t\t\twantDisposed: false,\n\t\t\twantPanic:    \"WithExistingBrowserContext can not be used before Browser is initialized\",\n\t\t},\n\t\t{\n\t\t\tname: \"remote allocator WithExistingBrowserContext \",\n\t\t\tarrange: func(t *testing.T) (context.Context, context.CancelFunc, cdp.BrowserContextID) {\n\t\t\t\tc := FromContext(browserCtx)\n\t\t\t\tvar conn *net.TCPConn\n\t\t\t\tif chromedpConn, ok := c.Browser.conn.(*Conn); ok {\n\t\t\t\t\tconn, _ = chromedpConn.conn.(*net.TCPConn)\n\t\t\t\t}\n\t\t\t\tif conn == nil {\n\t\t\t\t\tt.Skip(\"skip when the remote debugging address is not available\")\n\t\t\t\t}\n\t\t\t\tactx, _ := NewRemoteAllocator(context.Background(), \"ws://\"+conn.RemoteAddr().String())\n\t\t\t\tctx, cancel := NewContext(actx, WithExistingBrowserContext(rootBrowserContextID1))\n\t\t\t\tif err := Run(ctx); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\treturn ctx, cancel, rootBrowserContextID1\n\t\t\t},\n\t\t\twantDisposed: false,\n\t\t\twantPanic:    \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"remote allocator WithNewBrowserContext\",\n\t\t\tarrange: func(t *testing.T) (context.Context, context.CancelFunc, cdp.BrowserContextID) {\n\t\t\t\tc := FromContext(browserCtx)\n\t\t\t\tvar conn *net.TCPConn\n\t\t\t\tif chromedpConn, ok := c.Browser.conn.(*Conn); ok {\n\t\t\t\t\tconn, _ = chromedpConn.conn.(*net.TCPConn)\n\t\t\t\t}\n\t\t\t\tif conn == nil {\n\t\t\t\t\tt.Skip(\"skip when the remote debugging address is not available\")\n\t\t\t\t}\n\t\t\t\tactx, _ := NewRemoteAllocator(context.Background(), \"ws://\"+conn.RemoteAddr().String())\n\t\t\t\tctx, cancel := NewContext(actx, WithNewBrowserContext())\n\t\t\t\tif err := Run(ctx); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\treturn ctx, cancel, FromContext(ctx).BrowserContextID\n\t\t\t},\n\t\t\twantDisposed: true,\n\t\t\twantPanic:    \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif tt.wantPanic != \"\" {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif got := fmt.Sprint(recover()); got != tt.wantPanic {\n\t\t\t\t\t\tt.Errorf(\"want panic %q, got %q\", tt.wantPanic, got)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tctx, cancel, want := tt.arrange(t)\n\t\t\tdefer cancel()\n\n\t\t\tgot := getBrowserContext(t, ctx)\n\n\t\t\tif got != want {\n\t\t\t\tswitch want {\n\t\t\t\tcase defaultBrowserContextID:\n\t\t\t\t\tt.Errorf(\"want default browser context %q, got %q\", want, got)\n\t\t\t\tcase rootBrowserContextID1:\n\t\t\t\t\tt.Errorf(\"want root browser context 1 %q, got %q\", want, got)\n\t\t\t\tcase rootBrowserContextID2:\n\t\t\t\t\tt.Errorf(\"want root browser context 2 %q, got %q\", want, got)\n\t\t\t\tdefault:\n\t\t\t\t\tt.Errorf(\"want browser context %q, got %q\", want, got)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif want == defaultBrowserContextID {\n\t\t\t\t// There is not way to check whether the default browser context\n\t\t\t\t// is disposed, so stop here.\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tcancel()\n\n\t\t\tvar ids []cdp.BrowserContextID\n\t\t\tif err := Run(browserCtx,\n\t\t\t\tActionFunc(func(ctx context.Context) error {\n\t\t\t\t\tc := FromContext(ctx)\n\t\t\t\t\tvar err error\n\t\t\t\t\tids, err = target.GetBrowserContexts().Do(cdp.WithExecutor(ctx, c.Browser))\n\t\t\t\t\treturn err\n\t\t\t\t}),\n\t\t\t); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tdisposed := !contains(ids, want)\n\n\t\t\tif disposed != tt.wantDisposed {\n\t\t\t\tt.Errorf(\"browser context disposed = %v, want %v\", disposed, tt.wantDisposed)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc getBrowserContext(tb testing.TB, ctx context.Context) cdp.BrowserContextID {\n\tvar id cdp.BrowserContextID\n\tif err := Run(ctx,\n\t\tActionFunc(func(ctx context.Context) error {\n\t\t\tinfo, err := target.GetTargetInfo().Do(ctx)\n\t\t\tid = info.BrowserContextID\n\t\t\treturn err\n\t\t}),\n\t); err != nil {\n\t\ttb.Fatal(err)\n\t}\n\treturn id\n}\n\nfunc TestLargeOutboundMessages(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"\")\n\tdefer cancel()\n\n\t// ~5MiB of JS to test the grow feature of github.com/gobwas/ws.\n\texpr := fmt.Sprintf(\"//%s\\n\", strings.Repeat(\"x\", 5<<20))\n\tres := new([]byte)\n\tif err := Run(ctx, Evaluate(expr, res)); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestDirectCloseTarget(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"\")\n\tdefer cancel()\n\n\tc := FromContext(ctx)\n\twant := \"to close the target, cancel its context\"\n\n\t// Check that nothing is closed by running the action twice.\n\tfor i := 0; i < 2; i++ {\n\t\terr := Run(ctx, ActionFunc(func(ctx context.Context) error {\n\t\t\treturn target.CloseTarget(c.Target.TargetID).Do(ctx)\n\t\t}))\n\t\tgot := fmt.Sprint(err)\n\t\tif !strings.Contains(got, want) {\n\t\t\tt.Fatalf(\"want %q, got %q\", want, got)\n\t\t}\n\t}\n}\n\nfunc TestDirectCloseBrowser(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocateSeparate(t)\n\tdefer cancel()\n\n\tc := FromContext(ctx)\n\twant := \"use chromedp.Cancel\"\n\n\t// Check that nothing is closed by running the action twice.\n\tfor i := 0; i < 2; i++ {\n\t\terr := browser.Close().Do(cdp.WithExecutor(ctx, c.Browser))\n\t\tgot := fmt.Sprint(err)\n\t\tif !strings.Contains(got, want) {\n\t\t\tt.Fatalf(\"want %q, got %q\", want, got)\n\t\t}\n\t}\n}\n\nfunc TestDownloadIntoDir(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"\")\n\tdefer cancel()\n\n\tdir := t.TempDir()\n\n\ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tswitch r.URL.Path {\n\t\tcase \"/data.bin\":\n\t\t\tw.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\t\t\tfmt.Fprintf(w, \"some binary data\")\n\t\tdefault:\n\t\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\t\tfmt.Fprintf(w, `go <a id=\"download\" href=\"/data.bin\">download</a> stuff/`)\n\t\t}\n\t}))\n\tdefer s.Close()\n\n\tdone := make(chan string, 1)\n\tListenTarget(ctx, func(v interface{}) {\n\t\tif ev, ok := v.(*browser.EventDownloadProgress); ok {\n\t\t\tif ev.State == browser.DownloadProgressStateCompleted {\n\t\t\t\tdone <- ev.GUID\n\t\t\t\tclose(done)\n\t\t\t}\n\t\t}\n\t})\n\n\tif err := Run(ctx,\n\t\tNavigate(s.URL),\n\t\tbrowser.SetDownloadBehavior(browser.SetDownloadBehaviorBehaviorAllowAndName).WithDownloadPath(dir).WithEventsEnabled(true),\n\t\tClick(\"#download\", ByQuery),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tt.Fatalf(\"unexpected error: %v\", ctx.Err())\n\tcase guid := <-done:\n\t\tif _, err := os.Stat(filepath.Join(dir, guid)); err != nil {\n\t\t\tt.Fatalf(\"want error nil, got: %v\", err)\n\t\t}\n\t}\n}\n\nfunc TestGracefulBrowserShutdown(t *testing.T) {\n\tt.Parallel()\n\n\tdir := t.TempDir()\n\n\t// TODO(mvdan): this doesn't work with DefaultExecAllocatorOptions+UserDataDir\n\topts := []ExecAllocatorOption{\n\t\tNoFirstRun,\n\t\tNoDefaultBrowserCheck,\n\t\tHeadless,\n\t\tUserDataDir(dir),\n\t}\n\tactx, cancel := NewExecAllocator(context.Background(), opts...)\n\tdefer cancel()\n\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.RequestURI == \"/set\" {\n\t\t\thttp.SetCookie(w, &http.Cookie{\n\t\t\t\tName:    \"cookie1\",\n\t\t\t\tValue:   \"value1\",\n\t\t\t\tExpires: time.Now().AddDate(0, 0, 1), // one day later\n\t\t\t})\n\t\t}\n\t}))\n\tdefer ts.Close()\n\n\t{\n\t\tctx, _ := NewContext(actx)\n\t\tif err := Run(ctx, Navigate(ts.URL+\"/set\")); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Close the browser gracefully.\n\t\tif err := Cancel(ctx); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\t{\n\t\tctx, _ := NewContext(actx)\n\t\tvar got string\n\t\tif err := Run(ctx,\n\t\t\tNavigate(ts.URL),\n\t\t\tEvaluateAsDevTools(\"document.cookie\", &got),\n\t\t); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif want := \"cookie1=value1\"; got != want {\n\t\t\tt.Fatalf(\"want cookies %q; got %q\", want, got)\n\t\t}\n\t}\n}\n\nfunc TestAttachingToWorkers(t *testing.T) {\n\tt.Parallel()\n\n\tfor _, tc := range []struct {\n\t\tdesc, pageJS, wantSelf string\n\t}{\n\t\t{\"DedicatedWorker\", \"new Worker('/worker.js')\", \"DedicatedWorkerGlobalScope\"},\n\t\t{\"ServiceWorker\", \"navigator.serviceWorker.register('/worker.js')\", \"ServiceWorkerGlobalScope\"},\n\t} {\n\t\tt.Run(tc.desc, func(t *testing.T) {\n\t\t\tmux := http.NewServeMux()\n\t\t\tmux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\t\t\tfmt.Fprintf(w, `\n\t\t\t\t\t<html>\n\t\t\t\t\t\t<body>\n\t\t\t\t\t\t\t<script>\n\t\t\t\t\t\t\t\t%s\n\t\t\t\t\t\t\t</script>\n\t\t\t\t\t\t</body>\n\t\t\t\t\t</html>`, tc.pageJS)\n\t\t\t})\n\t\t\tmux.HandleFunc(\"/worker.js\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tw.Header().Set(\"Content-Type\", \"text/javascript\")\n\t\t\t\tio.WriteString(w, \"console.log('I am worker code.');\")\n\t\t\t})\n\t\t\tts := httptest.NewServer(mux)\n\t\t\tdefer ts.Close()\n\n\t\t\tctx, cancel := NewContext(context.Background())\n\t\t\tdefer cancel()\n\n\t\t\tch := make(chan target.ID, 1)\n\n\t\t\tListenTarget(ctx, func(ev interface{}) {\n\t\t\t\tif ev, ok := ev.(*target.EventAttachedToTarget); ok {\n\t\t\t\t\tif !strings.Contains(ev.TargetInfo.Type, \"worker\") {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tch <- ev.TargetInfo.TargetID\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tif err := Run(ctx, Navigate(ts.URL)); err != nil {\n\t\t\t\tt.Fatalf(\"Failed to navigate to the test page: %q\", err)\n\t\t\t}\n\n\t\t\ttargetID := <-ch\n\t\t\tctx, cancel = NewContext(ctx, WithTargetID(targetID))\n\t\t\tdefer cancel()\n\n\t\t\tif err := Run(ctx, ActionFunc(func(ctx context.Context) error {\n\t\t\t\tif r, _, err := runtime.Evaluate(\"self\").Do(ctx); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t} else if r.ClassName != tc.wantSelf {\n\t\t\t\t\treturn fmt.Errorf(\"Global scope type mismatch: got %q want: %q\", r.ClassName, tc.wantSelf)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})); err != nil {\n\t\t\t\tt.Fatalf(\"Failed to check evaluating JavaScript in a worker target: %q\", err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRunResponse(t *testing.T) {\n\tt.Parallel()\n\n\t// This test includes many edge cases for RunResponse; navigations that\n\t// fail to start, responses that return errors, responses that redirect,\n\t// and so on.\n\t// We also test each of those with different actions, such as a straight\n\t// navigation, as well as a click.\n\t// What's important here is that we have an iframe that keeps reloading\n\t// every 100ms in the main page. If RunResponse doesn't properly filter\n\t// events for the top level frame, the tests should fail pretty often.\n\n\tindexTmpl := template.Must(template.New(\"\").Parse(`\n\t\t<html>\n\t\t\t<body>\n\t\t\t\t<a id=\"url_index\" href=\"/index\">index</a>\n\t\t\t\t<a id=\"url_200\" href=\"/200\">200</a>\n\t\t\t\t<a id=\"url_404\" href=\"/404\">404</a>\n\t\t\t\t<a id=\"url_500\" href=\"/500\">500</a>\n\t\t\t\t<a id=\"url_badtls\" href=\"https://{{.Host}}/index\">badtls</a>\n\t\t\t\t<a id=\"url_badprotocol\" href=\"bad://{{.Host}}/index\">badprotocol</a>\n\t\t\t\t<a id=\"url_unimplementedprotocol\" href=\"ftp://{{.Host}}/index\">unimplementedprotocol</a>\n\t\t\t\t<a id=\"url_plain\" href=\"/plain\">plain</a>\n\t\t\t\t<a id=\"url_two\" href=\"/two\">two</a>\n\t\t\t\t<a id=\"url_one\" href=\"/one\">one</a>\n\t\t\t\t<a id=\"url_infinite\" href=\"/infinite\">infinite</a>\n\t\t\t\t<a id=\"url_badiframe\" href=\"/badiframe\">badiframe</a>\n\n\t\t\t\t<script>\n\t\t\t\t\tsetInterval(function(){\n\t\t\t\t\t\tdocument.getElementById(\"reloadingframe\").src += \"\";\n\t\t\t\t\t}, 100);\n\t\t\t\t</script>\n\t\t\t\t<iframe id=\"reloadingframe\" src=\"/reloadingframe\"></iframe>\n\t\t\t</body>\n\t\t</html>`))\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/index\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tindexTmpl.Execute(w, r)\n\t})\n\tmux.HandleFunc(\"/200\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tfmt.Fprintf(w, \"OK\")\n\t})\n\tmux.HandleFunc(\"/500\", func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.Error(w, \"500\", 500)\n\t})\n\tmux.HandleFunc(\"/plain\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tfmt.Fprintf(w, \"OK\")\n\t})\n\tmux.HandleFunc(\"/two\", func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.Redirect(w, r, \"/one\", http.StatusMovedPermanently)\n\t})\n\tmux.HandleFunc(\"/one\", func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.Redirect(w, r, \"/zero\", http.StatusMovedPermanently)\n\t})\n\tmux.HandleFunc(\"/zero\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"OK\")\n\t})\n\tmux.HandleFunc(\"/infinite\", func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.Redirect(w, r, \"/infinite\", http.StatusMovedPermanently)\n\t})\n\tmux.HandleFunc(\"/badiframe\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tfmt.Fprintf(w, `<html><body><iframe src=\"badurl://localhost/\"></iframe></body></html>`)\n\t})\n\tts := httptest.NewServer(mux)\n\tt.Cleanup(ts.Close)\n\n\ttests := []struct {\n\t\tname string\n\t\turl  string\n\n\t\twantErr       string\n\t\twantSuffixURL string\n\t\twantStatus    int64\n\t}{\n\t\t{\n\t\t\tname:       \"200\",\n\t\t\turl:        \"200\",\n\t\t\twantStatus: 200,\n\t\t},\n\t\t{\n\t\t\tname:       \"404\",\n\t\t\turl:        \"404\",\n\t\t\twantStatus: 404,\n\t\t},\n\t\t{\n\t\t\tname:       \"500\",\n\t\t\turl:        \"500\",\n\t\t\twantStatus: 500,\n\t\t},\n\n\t\t// Use the local http server as https, which should be a TLS\n\t\t// error and fail to load. If we don't capture the \"loading\n\t\t// failed\" error, we will block until the timeout is hit and\n\t\t// give a generic \"deadline exceeded\" error.\n\t\t{\n\t\t\tname:    \"BadTLS\",\n\t\t\turl:     strings.ReplaceAll(ts.URL, \"http://\", \"https://\") + \"/index\",\n\t\t\twantErr: \"ERR_SSL_PROTOCOL_ERROR\",\n\t\t},\n\n\t\t// In this case, the \"loading failed\" event is received, but the\n\t\t// load itself is cancelled immediately, so we never receive a\n\t\t// load event of any sort.\n\t\t{\n\t\t\tname:    \"BadProtocol\",\n\t\t\turl:     strings.ReplaceAll(ts.URL, \"http://\", \"bad://\") + \"/index\",\n\t\t\twantErr: \"ERR_ABORTED\",\n\t\t},\n\n\t\t// Check that loading a non-HTML document still works normally.\n\t\t{\n\t\t\tname:          \"NonHTML\",\n\t\t\turl:           \"plain\",\n\t\t\twantSuffixURL: \"/plain\",\n\t\t},\n\n\t\t{\n\t\t\tname:          \"BadIframe\",\n\t\t\turl:           \"badiframe\",\n\t\t\twantSuffixURL: \"/badiframe\",\n\t\t},\n\n\t\t{\n\t\t\tname:          \"OneRedirect\",\n\t\t\turl:           \"one\",\n\t\t\twantSuffixURL: \"/zero\",\n\t\t},\n\t\t{\n\t\t\tname:          \"TwoRedirects\",\n\t\t\turl:           \"two\",\n\t\t\twantSuffixURL: \"/zero\",\n\t\t},\n\t\t{\n\t\t\tname:    \"InfiniteRedirects\",\n\t\t\turl:     \"infinite\",\n\t\t\twantErr: \"ERR_TOO_MANY_REDIRECTS\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tallocate := func(t *testing.T) context.Context {\n\t\t\tctx, cancel := testAllocate(t, \"\")\n\t\t\tt.Cleanup(cancel)\n\t\t\tctx, cancel = context.WithTimeout(ctx, 5*time.Second)\n\t\t\tt.Cleanup(cancel)\n\n\t\t\tif err := Run(ctx, Navigate(ts.URL+\"/index\")); err != nil {\n\t\t\t\tt.Fatalf(\"Failed to navigate to the test page: %q\", err)\n\t\t\t}\n\t\t\treturn ctx\n\t\t}\n\t\tcheckResults := func(t *testing.T, resp *network.Response, err error) {\n\t\t\tif test.wantErr == \"\" && err != nil {\n\t\t\t\tt.Fatalf(\"wanted nil error, got %v\", err)\n\t\t\t}\n\t\t\tif got := fmt.Sprint(err); !strings.Contains(got, test.wantErr) {\n\t\t\t\tt.Fatalf(\"wanted error to contain %q, got %q\", test.wantErr, got)\n\t\t\t}\n\t\t\tif test.wantErr == \"\" && resp == nil {\n\t\t\t\tt.Fatalf(\"expected response to be non-nil\")\n\t\t\t} else if test.wantErr != \"\" && resp != nil {\n\t\t\t\tt.Fatalf(\"expected response to be nil\")\n\t\t\t}\n\n\t\t\turl := \"\"\n\t\t\tstatus := int64(0)\n\t\t\tif resp != nil {\n\t\t\t\turl = resp.URL\n\t\t\t\tstatus = resp.Status\n\t\t\t}\n\t\t\tif !strings.HasSuffix(url, test.wantSuffixURL) {\n\t\t\t\tt.Fatalf(\"wanted response URL to end with %q, got %q\", test.wantSuffixURL, url)\n\t\t\t}\n\t\t\tif want := test.wantStatus; want != 0 && status != want {\n\t\t\t\tt.Fatalf(\"wanted status code %d, got %d\", want, status)\n\t\t\t}\n\n\t\t\tif resp != nil {\n\t\t\t\tlatency := time.Since(resp.ResponseTime.Time())\n\t\t\t\tif latency > time.Hour || latency < -time.Hour {\n\t\t\t\t\tt.Errorf(\"responseTime does not hold a reasonable value %s. \"+\n\t\t\t\t\t\t\"Maybe it's in seconds now and we should remove the workaround. \"+\n\t\t\t\t\t\t\"See https://github.com/chromedp/pdlgen/issues/22.\",\n\t\t\t\t\t\tresp.ResponseTime.Time())\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tt.Run(\"Navigate\"+test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tctx := allocate(t)\n\n\t\t\turl := test.url\n\t\t\tif !strings.Contains(url, \"/\") {\n\t\t\t\turl = ts.URL + \"/\" + url\n\t\t\t}\n\t\t\tresp, err := RunResponse(ctx, Navigate(url))\n\t\t\tcheckResults(t, resp, err)\n\t\t})\n\t\tt.Run(\"Click\"+test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tctx := allocate(t)\n\n\t\t\tquery := \"#url_\" + strings.ToLower(test.name)\n\t\t\tif !strings.Contains(test.url, \"/\") {\n\t\t\t\tquery = \"#url_\" + test.url\n\t\t\t}\n\t\t\tresp, err := RunResponse(ctx, Click(query, ByQuery))\n\t\t\tcheckResults(t, resp, err)\n\t\t})\n\t}\n}\n\nfunc TestRunResponse_noResponse(t *testing.T) {\n\tt.Parallel()\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/200\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tfmt.Fprintf(w, `<html><body>\n\t\t<a id=\"same\" href=\"/200\">same</a>\n\t\t<a id=\"fragment\" href=\"/200#fragment\">fragment</a>\n\t\t</body></html>`)\n\t})\n\tts := httptest.NewServer(mux)\n\tdefer ts.Close()\n\n\tctx, cancel := testAllocate(t, \"\")\n\tdefer cancel()\n\n\tctx, cancel = context.WithTimeout(ctx, 5*time.Second)\n\tdefer cancel()\n\n\tsteps := []struct {\n\t\tname     string\n\t\taction   Action\n\t\twantResp bool\n\t}{\n\t\t{\"FirstNavigation\", Navigate(ts.URL + \"/200\"), true},\n\t\t{\"RepeatedNavigation\", Navigate(ts.URL + \"/200\"), true},\n\t\t{\"FragmentNavigation\", Navigate(ts.URL + \"/200#foo\"), false},\n\n\t\t{\"FirstClick\", Click(\"#same\", ByQuery), true},\n\t\t{\"RepeatedClick\", Click(\"#same\", ByQuery), true},\n\t\t{\"FragmentClick\", Click(\"#fragment\", ByQuery), false},\n\n\t\t{\"Blank\", Navigate(\"about:blank\"), false},\n\t}\n\t// Don't use sub-tests, as these are all sequential steps that can't\n\t// happen independently of each other.\n\tfor _, step := range steps {\n\t\tresp, err := RunResponse(ctx, step.action)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%s: %v\", step.name, err)\n\t\t}\n\t\tif resp == nil && step.wantResp {\n\t\t\tt.Fatalf(\"%s: wanted a response, got nil\", step.name)\n\t\t} else if resp != nil && !step.wantResp {\n\t\t\tt.Fatalf(\"%s: did not want a response, got: %#v\", step.name, resp)\n\t\t}\n\t}\n}\n\n// TestWebGL tests that WebGL is correctly configured in headless-shell.\n//\n// This is a regress test for https://github.com/chromedp/chromedp/issues/1073.\nfunc TestWebGL(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"webgl.html\")\n\tdefer cancel()\n\n\tvar buf []byte\n\tif err := Run(ctx,\n\t\tPoll(\"rendered\", nil, WithPollingTimeout(2*time.Second)),\n\t\tScreenshot(`#c`, &buf, ByQuery),\n\t); err != nil {\n\t\tif errors.Is(err, ErrPollingTimeout) {\n\t\t\tt.Fatal(\"The cube is not rendered in 2s.\")\n\t\t} else {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\timg, err := png.Decode(bytes.NewReader(buf))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tbounds := img.Bounds()\n\tif bounds.Dx() != 200 || bounds.Dy() != 200 {\n\t\tt.Fatalf(\"Unexpected screenshot size. got: %d x %d, want 200 x 200.\", bounds.Dx(), bounds.Dy())\n\t}\n\n\tisWhite := func(c color.Color) bool {\n\t\tr, g, b, _ := c.RGBA()\n\t\treturn r == 0xffff && g == 0xffff && b == 0xffff\n\t}\n\tif isWhite(img.At(100, 100)) {\n\t\tt.Fatal(\"When the cube is rendered correctly, the color at the middle of the canvas should not be white.\")\n\t}\n}\n\n// TestPDFTemplate tests that the resource pack is loaded in headless-shell.\n//\n// When it's correctly loaded, the header/footer templates that use the\n// following values should work as expected:\n//   - title\n//   - url\n//   - pageNumber\n//   - totalPages\n//\n// This is a regress test for https://github.com/chromedp/chromedp/issues/922.\nfunc TestPDFTemplate(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"\")\n\tdefer cancel()\n\n\tvar buf []byte\n\tif err := Run(ctx,\n\t\tNavigate(\"about:blank\"),\n\t\tActionFunc(func(ctx context.Context) error {\n\t\t\tframeTree, err := page.GetFrameTree().Do(ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn page.SetDocumentContent(frameTree.Frame.ID, `\n\t\t\t\t<html>\n\t\t\t\t\t<head>\n\t\t\t\t\t\t<title>PDF Template</title>\n\t\t\t\t\t</head>\n\t\t\t\t\t<body>\n\t\t\t\t\t\tHello World!\n\t\t\t\t\t</body>\n\t\t\t\t</html>\n\t\t\t`).Do(ctx)\n\t\t}),\n\t\tActionFunc(func(ctx context.Context) error {\n\t\t\tvar err error\n\t\t\tbuf, _, err = page.PrintToPDF().\n\t\t\t\tWithMarginTop(0.5).\n\t\t\t\tWithMarginBottom(0.5).\n\t\t\t\tWithDisplayHeaderFooter(true).\n\t\t\t\tWithHeaderTemplate(`<div style=\"font-size:8px;width:100%;text-align:center;\"><span class=\"title\"></span> -- <span class=\"url\"></span></div>`).\n\t\t\t\tWithFooterTemplate(`<div style=\"font-size:8px;width:100%;text-align:center;\">(<span class=\"pageNumber\"></span> / <span class=\"totalPages\"></span>)</div>`).\n\t\t\t\tDo(ctx)\n\n\t\t\treturn err\n\t\t}),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tr, err := pdf.NewReader(bytes.NewReader(buf), int64(len(buf)))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tb, err := r.GetPlainText()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := []byte(\"PDF Template -- about:blank\" + \"(1 / 1)\" + \"Hello World!\")\n\tl := len(want)\n\t// try to reuse buf\n\tif len(buf) >= l {\n\t\tbuf = buf[0:l]\n\t} else {\n\t\tbuf = make([]byte, l)\n\t}\n\tn, err := io.ReadFull(b, buf)\n\tif err != nil && !(errors.Is(err, io.EOF) || errors.Is(err, io.ErrUnexpectedEOF)) {\n\t\tt.Fatal(err)\n\t}\n\tbuf = buf[:n]\n\n\tif !bytes.Equal(buf, want) {\n\t\tt.Errorf(\"page.PrintToPDF produces unexpected content. got: %q, want: %q\", buf, want)\n\t}\n}\n\nfunc contains(v []cdp.BrowserContextID, id cdp.BrowserContextID) bool {\n\tfor _, i := range v {\n\t\tif i == id {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "conn.go",
          "type": "blob",
          "size": 3.693359375,
          "content": "package chromedp\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"io\"\n\t\"net\"\n\n\t\"github.com/gobwas/ws\"\n\t\"github.com/gobwas/ws/wsutil\"\n\t\"github.com/mailru/easyjson/jlexer\"\n\t\"github.com/mailru/easyjson/jwriter\"\n\n\t\"github.com/chromedp/cdproto\"\n)\n\n// Transport is the common interface to send/receive messages to a target.\n//\n// This interface is currently used internally by Browser, but it is exposed as\n// it will be useful as part of the public API in the future.\ntype Transport interface {\n\tRead(context.Context, *cdproto.Message) error\n\tWrite(context.Context, *cdproto.Message) error\n\tio.Closer\n}\n\n// Conn implements Transport with a gobwas/ws websocket connection.\ntype Conn struct {\n\tconn net.Conn\n\n\t// reuse the websocket reader and writer to avoid an alloc per\n\t// Read/Write.\n\treader wsutil.Reader\n\twriter wsutil.Writer\n\n\t// reuse the easyjson structs to avoid allocs per Read/Write.\n\tdecoder jlexer.Lexer\n\tencoder jwriter.Writer\n\n\tdbgf func(string, ...interface{})\n}\n\n// DialContext dials the specified websocket URL using gobwas/ws.\nfunc DialContext(ctx context.Context, urlstr string, opts ...DialOption) (*Conn, error) {\n\t// connect\n\tconn, br, _, err := ws.Dial(ctx, urlstr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif br != nil {\n\t\tpanic(\"br should be nil\")\n\t}\n\n\t// apply opts\n\tc := &Conn{\n\t\tconn: conn,\n\t\t// pass 0 to use the default initial buffer size (4KiB).\n\t\t// github.com/gobwas/ws will grow the buffer size if needed.\n\t\twriter: *wsutil.NewWriterBufferSize(conn, ws.StateClientSide, ws.OpText, 0),\n\t}\n\tfor _, o := range opts {\n\t\to(c)\n\t}\n\n\treturn c, nil\n}\n\n// Close satisfies the io.Closer interface.\nfunc (c *Conn) Close() error {\n\treturn c.conn.Close()\n}\n\n// Read reads the next message.\nfunc (c *Conn) Read(_ context.Context, msg *cdproto.Message) error {\n\t// get websocket reader\n\tc.reader = wsutil.Reader{Source: c.conn, State: ws.StateClientSide}\n\th, err := c.reader.NextFrame()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif h.OpCode != ws.OpText {\n\t\treturn ErrInvalidWebsocketMessage\n\t}\n\n\tvar b bytes.Buffer\n\tif _, err := b.ReadFrom(&c.reader); err != nil {\n\t\treturn err\n\t}\n\tbuf := b.Bytes()\n\tif c.dbgf != nil {\n\t\tc.dbgf(\"<- %s\", buf)\n\t}\n\n\t// unmarshal, reusing lexer\n\tc.decoder = jlexer.Lexer{Data: buf}\n\tmsg.UnmarshalEasyJSON(&c.decoder)\n\treturn c.decoder.Error()\n}\n\n// Write writes a message.\nfunc (c *Conn) Write(_ context.Context, msg *cdproto.Message) error {\n\tc.writer.Reset(c.conn, ws.StateClientSide, ws.OpText)\n\t// Chrome doesn't support fragmentation of incoming websocket messages. To\n\t// compensate this, they support single-fragment messages of up to 100MiB.\n\t//\n\t// See https://github.com/ChromeDevTools/devtools-protocol/issues/175.\n\t//\n\t// And according to https://bugs.chromium.org/p/chromium/issues/detail?id=1069431,\n\t// it seems like that fragmentation won't be supported very soon.\n\t// Luckily, now github.com/gobwas/ws will grow the buffer if needed.\n\t// The func name DisableFlush is a little misleading,\n\t// but it do make it grow the buffer if needed.\n\tc.writer.DisableFlush()\n\n\t// Reuse the easyjson writer.\n\tc.encoder = jwriter.Writer{}\n\n\t// Perform the marshal.\n\tmsg.MarshalEasyJSON(&c.encoder)\n\tif err := c.encoder.Error; err != nil {\n\t\treturn err\n\t}\n\n\t// Write the bytes to the websocket.\n\t// BuildBytes consumes the buffer, so we can't use it as well as DumpTo.\n\tif c.dbgf != nil {\n\t\tbuf, _ := c.encoder.BuildBytes()\n\t\tc.dbgf(\"-> %s\", buf)\n\t\tif _, err := c.writer.Write(buf); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif _, err := c.encoder.DumpTo(&c.writer); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn c.writer.Flush()\n}\n\n// DialOption is a dial option.\ntype DialOption = func(*Conn)\n\n// WithConnDebugf is a dial option to set a protocol logger.\nfunc WithConnDebugf(f func(string, ...interface{})) DialOption {\n\treturn func(c *Conn) {\n\t\tc.dbgf = f\n\t}\n}\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "device",
          "type": "tree",
          "content": null
        },
        {
          "name": "emulate.go",
          "type": "blob",
          "size": 4.328125,
          "content": "package chromedp\n\nimport (\n\t\"github.com/chromedp/cdproto/emulation\"\n\t\"github.com/chromedp/chromedp/device\"\n)\n\n// EmulateAction are actions that change the emulation settings for the\n// browser.\ntype EmulateAction Action\n\n// EmulateViewport is an action to change the browser viewport.\n//\n// Wraps calls to emulation.SetDeviceMetricsOverride and emulation.SetTouchEmulationEnabled.\n//\n// Note: this has the effect of setting/forcing the screen orientation to\n// landscape, and will disable mobile and touch emulation by default. If this\n// is not the desired behavior, use the emulate viewport options\n// EmulateOrientation (or EmulateLandscape/EmulatePortrait), EmulateMobile, and\n// EmulateTouch, respectively.\nfunc EmulateViewport(width, height int64, opts ...EmulateViewportOption) EmulateAction {\n\tp1 := emulation.SetDeviceMetricsOverride(width, height, 1.0, false)\n\tp2 := emulation.SetTouchEmulationEnabled(false)\n\tfor _, o := range opts {\n\t\to(p1, p2)\n\t}\n\treturn Tasks{p1, p2}\n}\n\n// EmulateViewportOption is the type for emulate viewport options.\ntype EmulateViewportOption = func(*emulation.SetDeviceMetricsOverrideParams, *emulation.SetTouchEmulationEnabledParams)\n\n// EmulateScale is an emulate viewport option to set the device viewport scaling\n// factor.\nfunc EmulateScale(scale float64) EmulateViewportOption {\n\treturn func(p1 *emulation.SetDeviceMetricsOverrideParams, p2 *emulation.SetTouchEmulationEnabledParams) {\n\t\tp1.DeviceScaleFactor = scale\n\t}\n}\n\n// EmulateOrientation is an emulate viewport option to set the device viewport\n// screen orientation.\nfunc EmulateOrientation(orientation emulation.OrientationType, angle int64) EmulateViewportOption {\n\treturn func(p1 *emulation.SetDeviceMetricsOverrideParams, p2 *emulation.SetTouchEmulationEnabledParams) {\n\t\tp1.ScreenOrientation = &emulation.ScreenOrientation{\n\t\t\tType:  orientation,\n\t\t\tAngle: angle,\n\t\t}\n\t}\n}\n\n// EmulateLandscape is an emulate viewport option to set the device viewport\n// screen orientation in landscape primary mode and an angle of 90.\nfunc EmulateLandscape(p1 *emulation.SetDeviceMetricsOverrideParams, p2 *emulation.SetTouchEmulationEnabledParams) {\n\tEmulateOrientation(emulation.OrientationTypeLandscapePrimary, 90)(p1, p2)\n}\n\n// EmulatePortrait is an emulate viewport option to set the device viewport\n// screen orientation in portrait primary mode and an angle of 0.\nfunc EmulatePortrait(p1 *emulation.SetDeviceMetricsOverrideParams, p2 *emulation.SetTouchEmulationEnabledParams) {\n\tEmulateOrientation(emulation.OrientationTypePortraitPrimary, 0)(p1, p2)\n}\n\n// EmulateMobile is an emulate viewport option to toggle the device viewport to\n// display as a mobile device.\nfunc EmulateMobile(p1 *emulation.SetDeviceMetricsOverrideParams, p2 *emulation.SetTouchEmulationEnabledParams) {\n\tp1.Mobile = true\n}\n\n// EmulateTouch is an emulate viewport option to enable touch emulation.\nfunc EmulateTouch(p1 *emulation.SetDeviceMetricsOverrideParams, p2 *emulation.SetTouchEmulationEnabledParams) {\n\tp2.Enabled = true\n}\n\n// ResetViewport is an action to reset the browser viewport to the default\n// values the browser was started with.\n//\n// Note: does not modify / change the browser's emulated User-Agent, if any.\nfunc ResetViewport() EmulateAction {\n\treturn EmulateViewport(0, 0, EmulatePortrait)\n}\n\n// Device is the shared interface for known device types.\n//\n// See [device] for a set of off-the-shelf devices and modes.\ntype Device interface {\n\t// Device returns the device info.\n\tDevice() device.Info\n}\n\n// Emulate is an action to emulate a specific device.\n//\n// See [device] for a set of off-the-shelf devices and modes.\nfunc Emulate(device Device) EmulateAction {\n\td := device.Device()\n\n\tvar angle int64\n\torientation := emulation.OrientationTypePortraitPrimary\n\tif d.Landscape {\n\t\torientation, angle = emulation.OrientationTypeLandscapePrimary, 90\n\t}\n\n\treturn Tasks{\n\t\temulation.SetUserAgentOverride(d.UserAgent),\n\t\temulation.SetDeviceMetricsOverride(d.Width, d.Height, d.Scale, d.Mobile).\n\t\t\tWithScreenOrientation(&emulation.ScreenOrientation{\n\t\t\t\tType:  orientation,\n\t\t\t\tAngle: angle,\n\t\t\t}),\n\t\temulation.SetTouchEmulationEnabled(d.Touch),\n\t}\n}\n\n// EmulateReset is an action to reset the device emulation.\n//\n// Resets the browser's viewport, screen orientation, user-agent, and\n// mobile/touch emulation settings to the original values the browser was\n// started with.\nfunc EmulateReset() EmulateAction {\n\treturn Emulate(device.Reset)\n}\n"
        },
        {
          "name": "emulate_test.go",
          "type": "blob",
          "size": 0.556640625,
          "content": "package chromedp\n\nimport (\n\t\"bytes\"\n\t\"image/png\"\n\t\"testing\"\n\n\t\"github.com/chromedp/chromedp/device\"\n)\n\nfunc TestEmulate(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"image.html\")\n\tdefer cancel()\n\n\tvar buf []byte\n\tif err := Run(ctx,\n\t\tEmulate(device.IPhone7),\n\t\tScreenshot(`#half-color`, &buf, ByID),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\timg, err := png.Decode(bytes.NewReader(buf))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsize := img.Bounds().Size()\n\tif size.X != 400 || size.Y != 400 {\n\t\tt.Errorf(\"expected size 400x400, got: %dx%d\", size.X, size.Y)\n\t}\n}\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 1.671875,
          "content": "package chromedp\n\n// Error is a chromedp error.\ntype Error string\n\n// Error satisfies the error interface.\nfunc (err Error) Error() string {\n\treturn string(err)\n}\n\n// Error types.\nconst (\n\t// ErrInvalidWebsocketMessage is the invalid websocket message.\n\tErrInvalidWebsocketMessage Error = \"invalid websocket message\"\n\n\t// ErrInvalidDimensions is the invalid dimensions error.\n\tErrInvalidDimensions Error = \"invalid dimensions\"\n\n\t// ErrNoResults is the no results error.\n\tErrNoResults Error = \"no results\"\n\n\t// ErrHasResults is the has results error.\n\tErrHasResults Error = \"has results\"\n\n\t// ErrNotVisible is the not visible error.\n\tErrNotVisible Error = \"not visible\"\n\n\t// ErrVisible is the visible error.\n\tErrVisible Error = \"visible\"\n\n\t// ErrDisabled is the disabled error.\n\tErrDisabled Error = \"disabled\"\n\n\t// ErrNotSelected is the not selected error.\n\tErrNotSelected Error = \"not selected\"\n\n\t// ErrInvalidBoxModel is the invalid box model error.\n\tErrInvalidBoxModel Error = \"invalid box model\"\n\n\t// ErrChannelClosed is the channel closed error.\n\tErrChannelClosed Error = \"channel closed\"\n\n\t// ErrInvalidTarget is the invalid target error.\n\tErrInvalidTarget Error = \"invalid target\"\n\n\t// ErrInvalidContext is the invalid context error.\n\tErrInvalidContext Error = \"invalid context\"\n\n\t// ErrPollingTimeout is the error that the timeout reached before the pageFunction returns a truthy value.\n\tErrPollingTimeout Error = \"waiting for function failed: timeout\"\n\n\t// ErrJSUndefined is the error that the type of RemoteObject is \"undefined\".\n\tErrJSUndefined Error = \"encountered an undefined value\"\n\n\t// ErrJSNull is the error that the value of RemoteObject is null.\n\tErrJSNull Error = \"encountered a null value\"\n)\n"
        },
        {
          "name": "eval.go",
          "type": "blob",
          "size": 4.5048828125,
          "content": "package chromedp\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"reflect\"\n\n\t\"github.com/chromedp/cdproto/runtime\"\n)\n\n// EvaluateAction are actions that evaluate JavaScript expressions using\n// runtime.Evaluate.\ntype EvaluateAction Action\n\n// Evaluate is an action to evaluate the JavaScript expression, unmarshaling\n// the result of the script evaluation to res.\n//\n// When res is nil, the script result will be ignored.\n//\n// When res is a *[]byte, the raw JSON-encoded value of the script\n// result will be placed in res.\n//\n// When res is a **runtime.RemoteObject, res will be set to the low-level\n// protocol type, and no attempt will be made to convert the result.\n// The original objects could be maintained in memory until the page is\n// navigated or closed. `runtime.ReleaseObject` or `runtime.ReleaseObjectGroup`\n// can be used to ask the browser to release the original objects.\n//\n// For all other cases, the result of the script will be returned \"by value\" (i.e.,\n// JSON-encoded), and subsequently an attempt will be made to json.Unmarshal\n// the script result to res. When the script result is \"undefined\" or \"null\",\n// and the value that res points to can not be nil (only the value of a chan,\n// func, interface, map, pointer, or slice can be nil), it returns [ErrJSUndefined]\n// or [ErrJSNull] respectively.\nfunc Evaluate(expression string, res interface{}, opts ...EvaluateOption) EvaluateAction {\n\treturn ActionFunc(func(ctx context.Context) error {\n\t\t// set up parameters\n\t\tp := runtime.Evaluate(expression)\n\t\tswitch res.(type) {\n\t\tcase **runtime.RemoteObject:\n\t\tdefault:\n\t\t\tp = p.WithReturnByValue(true)\n\t\t}\n\n\t\t// apply opts\n\t\tfor _, o := range opts {\n\t\t\tp = o(p)\n\t\t}\n\n\t\t// evaluate\n\t\tv, exp, err := p.Do(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif exp != nil {\n\t\t\treturn exp\n\t\t}\n\n\t\treturn parseRemoteObject(v, res)\n\t})\n}\n\nfunc parseRemoteObject(v *runtime.RemoteObject, res interface{}) (err error) {\n\tif res == nil {\n\t\treturn\n\t}\n\n\tswitch x := res.(type) {\n\tcase **runtime.RemoteObject:\n\t\t*x = v\n\t\treturn\n\n\tcase *[]byte:\n\t\t*x = v.Value\n\t\treturn\n\t}\n\n\tvalue := v.Value\n\tif value == nil {\n\t\trv := reflect.ValueOf(res)\n\t\tif rv.Kind() == reflect.Ptr {\n\t\t\tswitch rv.Elem().Kind() {\n\t\t\t// Common kinds that can be nil.\n\t\t\tcase reflect.Ptr, reflect.Map, reflect.Slice:\n\t\t\t// It's weird that res is a pointer to the following kinds,\n\t\t\t// but they can be nil too.\n\t\t\tcase reflect.Chan, reflect.Func, reflect.Interface:\n\t\t\tdefault:\n\t\t\t\t// When the value that `res` points to can not be set to nil,\n\t\t\t\t// return [ErrJSUndefined] or [ErrJSNull] respectively.\n\t\t\t\tif v.Type == \"undefined\" {\n\t\t\t\t\treturn ErrJSUndefined\n\t\t\t\t}\n\t\t\t\treturn ErrJSNull\n\t\t\t}\n\t\t}\n\t\t// Change the value to the json literal null to make json.Unmarshal happy.\n\t\tvalue = []byte(\"null\")\n\t}\n\n\treturn json.Unmarshal(value, res)\n}\n\n// EvaluateAsDevTools is an action that evaluates a JavaScript expression as\n// Chrome DevTools would, evaluating the expression in the \"console\" context,\n// and making the Command Line API available to the script.\n//\n// See [Evaluate] for more information on how script expressions are evaluated.\n//\n// Note: this should not be used with untrusted JavaScript.\nfunc EvaluateAsDevTools(expression string, res interface{}, opts ...EvaluateOption) EvaluateAction {\n\treturn Evaluate(expression, res, append(opts, EvalObjectGroup(\"console\"), EvalWithCommandLineAPI)...)\n}\n\n// EvaluateOption is the type for JavaScript evaluation options.\ntype EvaluateOption = func(*runtime.EvaluateParams) *runtime.EvaluateParams\n\n// EvalObjectGroup is an evaluate option to set the object group.\nfunc EvalObjectGroup(objectGroup string) EvaluateOption {\n\treturn func(p *runtime.EvaluateParams) *runtime.EvaluateParams {\n\t\treturn p.WithObjectGroup(objectGroup)\n\t}\n}\n\n// EvalWithCommandLineAPI is an evaluate option to make the DevTools Command\n// Line API available to the evaluated script.\n//\n// See [Evaluate] for more information on how evaluate actions work.\n//\n// Note: this should not be used with untrusted JavaScript.\nfunc EvalWithCommandLineAPI(p *runtime.EvaluateParams) *runtime.EvaluateParams {\n\treturn p.WithIncludeCommandLineAPI(true)\n}\n\n// EvalIgnoreExceptions is an evaluate option that will cause JavaScript\n// evaluation to ignore exceptions.\nfunc EvalIgnoreExceptions(p *runtime.EvaluateParams) *runtime.EvaluateParams {\n\treturn p.WithSilent(true)\n}\n\n// EvalAsValue is an evaluate option that will cause the evaluated JavaScript\n// expression to encode the result of the expression as a JSON-encoded value.\nfunc EvalAsValue(p *runtime.EvaluateParams) *runtime.EvaluateParams {\n\treturn p.WithReturnByValue(true)\n}\n"
        },
        {
          "name": "eval_test.go",
          "type": "blob",
          "size": 3.767578125,
          "content": "package chromedp\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/chromedp/cdproto/runtime\"\n)\n\nfunc TestEvaluateNumber(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname       string\n\t\texpression string\n\t\tres        int\n\t\twant       int\n\t\twantErr    string\n\t}{\n\t\t{\n\t\t\tname:       \"normal\",\n\t\t\texpression: \"123\",\n\t\t\twant:       123,\n\t\t},\n\t\t{\n\t\t\tname:       \"undefined\",\n\t\t\texpression: \"\",\n\t\t\twantErr:    \"encountered an undefined value\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctx, cancel := testAllocate(t, \"\")\n\t\t\tdefer cancel()\n\n\t\t\terr := Run(ctx,\n\t\t\t\tEvaluate(tt.expression, &tt.res),\n\t\t\t)\n\t\t\tif tt.wantErr == \"\" && err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\t\t\tif tt.wantErr != \"\" && (err == nil || tt.wantErr != err.Error()) {\n\t\t\t\tt.Fatalf(\"wanted error: %q, got: %q\", tt.wantErr, err)\n\t\t\t} else if tt.res != tt.want {\n\t\t\t\tt.Fatalf(\"want: %v, got: %v\", tt.want, tt.res)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestEvaluateString(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname       string\n\t\texpression string\n\t\tres        string\n\t\twant       string\n\t\twantErr    string\n\t}{\n\t\t{\n\t\t\tname:       \"normal\",\n\t\t\texpression: \"'str'\",\n\t\t\twant:       \"str\",\n\t\t},\n\t\t{\n\t\t\tname:       \"undefined\",\n\t\t\texpression: \"\",\n\t\t\twantErr:    \"encountered an undefined value\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctx, cancel := testAllocate(t, \"\")\n\t\t\tdefer cancel()\n\n\t\t\terr := Run(ctx,\n\t\t\t\tEvaluate(tt.expression, &tt.res),\n\t\t\t)\n\t\t\tif tt.wantErr == \"\" && err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\t\t\tif tt.wantErr != \"\" && (err == nil || tt.wantErr != err.Error()) {\n\t\t\t\tt.Fatalf(\"wanted error: %q, got: %q\", tt.wantErr, err)\n\t\t\t} else if tt.res != tt.want {\n\t\t\t\tt.Fatalf(\"want: %v, got: %v\", tt.want, tt.res)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestEvaluateBytes(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname       string\n\t\texpression string\n\t\tres        []byte\n\t\twant       []byte\n\t}{\n\t\t{\n\t\t\tname:       \"normal\",\n\t\t\texpression: \"'bytes'\",\n\t\t\twant:       []byte(`\"bytes\"`),\n\t\t},\n\t\t{\n\t\t\tname:       \"undefined\",\n\t\t\texpression: \"\",\n\t\t\twant:       []byte(nil),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctx, cancel := testAllocate(t, \"\")\n\t\t\tdefer cancel()\n\n\t\t\terr := Run(ctx,\n\t\t\t\tEvaluate(tt.expression, &tt.res),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(tt.res, tt.want) {\n\t\t\t\tt.Fatalf(\"want: %v, got: %v\", tt.want, tt.res)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestEvaluateRemoteObject(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname       string\n\t\texpression string\n\t\tres        *runtime.RemoteObject\n\t\twantType   string\n\t}{\n\t\t{\n\t\t\tname:       \"object\",\n\t\t\texpression: \"window\",\n\t\t\twantType:   \"object\",\n\t\t},\n\t\t{\n\t\t\tname:       \"function\",\n\t\t\texpression: \"window.alert\",\n\t\t\twantType:   \"function\",\n\t\t},\n\t\t{\n\t\t\tname:       \"undefined\",\n\t\t\texpression: \"\",\n\t\t\twantType:   \"undefined\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctx, cancel := testAllocate(t, \"\")\n\t\t\tdefer cancel()\n\n\t\t\terr := Run(ctx,\n\t\t\t\tEvaluate(tt.expression, &tt.res),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\t\t\tif string(tt.res.Type) != tt.wantType {\n\t\t\t\tt.Fatalf(\"want type: %v, got type: %v\", tt.wantType, tt.res.Type)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestEvaluateNil(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname       string\n\t\texpression string\n\t}{\n\t\t{\n\t\t\tname:       \"number\",\n\t\t\texpression: \"123\",\n\t\t},\n\t\t{\n\t\t\tname:       \"string\",\n\t\t\texpression: \"'str'\",\n\t\t},\n\t\t{\n\t\t\tname:       \"undefined\",\n\t\t\texpression: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctx, cancel := testAllocate(t, \"\")\n\t\t\tdefer cancel()\n\n\t\t\terr := Run(ctx,\n\t\t\t\tEvaluate(tt.expression, nil),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "event_test.go",
          "type": "blob",
          "size": 4.34375,
          "content": "package chromedp\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/chromedp/cdproto/page\"\n\t\"github.com/chromedp/cdproto/target\"\n)\n\nfunc TestCloseDialog(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname       string\n\t\taccept     bool\n\t\tpromptText string\n\t\tdialogType page.DialogType\n\t\tsel        string\n\t\twant       string\n\t}{\n\t\t{\n\t\t\tname:       \"AlertAcceptWithPromptText\",\n\t\t\taccept:     true,\n\t\t\tpromptText: \"this is a prompt text\",\n\t\t\tdialogType: page.DialogTypeAlert,\n\t\t\tsel:        \"#alert\",\n\t\t\twant:       \"alert text\",\n\t\t},\n\t\t{\n\t\t\tname:       \"AlertDismissWithPromptText\",\n\t\t\taccept:     false,\n\t\t\tpromptText: \"this is a prompt text\",\n\t\t\tdialogType: page.DialogTypeAlert,\n\t\t\tsel:        \"#alert\",\n\t\t\twant:       \"alert text\",\n\t\t},\n\t\t{\n\t\t\tname:       \"AlertAcceptWithoutPromptText\",\n\t\t\taccept:     true,\n\t\t\tdialogType: page.DialogTypeAlert,\n\t\t\tsel:        \"#alert\",\n\t\t\twant:       \"alert text\",\n\t\t},\n\t\t{\n\t\t\tname:       \"AlertDismissWithoutPromptText\",\n\t\t\taccept:     false,\n\t\t\tdialogType: page.DialogTypeAlert,\n\t\t\tsel:        \"#alert\",\n\t\t\twant:       \"alert text\",\n\t\t},\n\t\t{\n\t\t\tname:       \"PromptAcceptWithPromptText\",\n\t\t\taccept:     true,\n\t\t\tpromptText: \"this is a prompt text\",\n\t\t\tdialogType: page.DialogTypePrompt,\n\t\t\tsel:        \"#prompt\",\n\t\t\twant:       \"prompt text\",\n\t\t},\n\t\t{\n\t\t\tname:       \"PromptDismissWithPromptText\",\n\t\t\taccept:     false,\n\t\t\tpromptText: \"this is a prompt text\",\n\t\t\tdialogType: page.DialogTypePrompt,\n\t\t\tsel:        \"#prompt\",\n\t\t\twant:       \"prompt text\",\n\t\t},\n\t\t{\n\t\t\tname:       \"PromptAcceptWithoutPromptText\",\n\t\t\taccept:     true,\n\t\t\tdialogType: page.DialogTypePrompt,\n\t\t\tsel:        \"#prompt\",\n\t\t\twant:       \"prompt text\",\n\t\t},\n\t\t{\n\t\t\tname:       \"PromptDismissWithoutPromptText\",\n\t\t\taccept:     false,\n\t\t\tdialogType: page.DialogTypePrompt,\n\t\t\tsel:        \"#prompt\",\n\t\t\twant:       \"prompt text\",\n\t\t},\n\t\t{\n\t\t\tname:       \"ConfirmAcceptWithPromptText\",\n\t\t\taccept:     true,\n\t\t\tpromptText: \"this is a prompt text\",\n\t\t\tdialogType: page.DialogTypeConfirm,\n\t\t\tsel:        \"#confirm\",\n\t\t\twant:       \"confirm text\",\n\t\t},\n\t\t{\n\t\t\tname:       \"ConfirmDismissWithPromptText\",\n\t\t\taccept:     false,\n\t\t\tpromptText: \"this is a prompt text\",\n\t\t\tdialogType: page.DialogTypeConfirm,\n\t\t\tsel:        \"#confirm\",\n\t\t\twant:       \"confirm text\",\n\t\t},\n\t\t{\n\t\t\tname:       \"ConfirmAcceptWithoutPromptText\",\n\t\t\taccept:     true,\n\t\t\tdialogType: page.DialogTypeConfirm,\n\t\t\tsel:        \"#confirm\",\n\t\t\twant:       \"confirm text\",\n\t\t},\n\t\t{\n\t\t\tname:       \"ConfirmDismissWithoutPromptText\",\n\t\t\taccept:     false,\n\t\t\tdialogType: page.DialogTypeConfirm,\n\t\t\tsel:        \"#confirm\",\n\t\t\twant:       \"confirm text\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := testAllocate(t, \"\")\n\t\t\tdefer cancel()\n\n\t\t\tListenTarget(ctx, func(ev interface{}) {\n\t\t\t\tswitch e := ev.(type) {\n\t\t\t\tcase *page.EventJavascriptDialogOpening:\n\t\t\t\t\tif e.Type != test.dialogType {\n\t\t\t\t\t\tt.Errorf(\"expected dialog type to be %q, got: %q\", test.dialogType, e.Type)\n\t\t\t\t\t}\n\t\t\t\t\tif e.Message != test.want {\n\t\t\t\t\t\tt.Errorf(\"expected dialog message to be %q, got: %q\", test.want, e.Message)\n\t\t\t\t\t}\n\n\t\t\t\t\ttask := page.HandleJavaScriptDialog(test.accept)\n\t\t\t\t\tif test.promptText != \"\" {\n\t\t\t\t\t\ttask = task.WithPromptText(test.promptText)\n\t\t\t\t\t}\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tif err := Run(ctx, task); err != nil {\n\t\t\t\t\t\t\tt.Error(err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}()\n\t\t\t\tcase *page.EventJavascriptDialogClosed:\n\t\t\t\t\tif e.Result != test.accept {\n\t\t\t\t\t\tt.Errorf(\"expected result to be %t, got %t\", test.accept, e.Result)\n\t\t\t\t\t}\n\t\t\t\t\tif e.UserInput != test.promptText {\n\t\t\t\t\t\tt.Errorf(\"expected user input to be %q, got %q\", test.promptText, e.UserInput)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tif err := Run(ctx,\n\t\t\t\tNavigate(testdataDir+\"/dialog.html\"),\n\t\t\t\tClick(test.sel, ByID, NodeVisible),\n\t\t\t); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestWaitNewTarget(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"newtab.html\")\n\tdefer cancel()\n\n\tch := WaitNewTarget(ctx, func(info *target.Info) bool {\n\t\treturn info.URL != \"\"\n\t})\n\tif err := Run(ctx, Click(\"#new-tab\", ByID)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tblankCtx, cancel := NewContext(ctx, WithTargetID(<-ch))\n\tdefer cancel()\n\n\tvar urlstr string\n\tif err := Run(blankCtx,\n\t\tLocation(&urlstr),\n\t\tWaitVisible(`#form`, ByID),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !strings.HasSuffix(urlstr, \"form.html\") {\n\t\tt.Errorf(\"want to be on form.html, at %q\", urlstr)\n\t}\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 17.552734375,
          "content": "package chromedp_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/chromedp/chromedp\"\n\t\"github.com/chromedp/chromedp/device\"\n\n\t\"github.com/chromedp/cdproto/cdp\"\n\t\"github.com/chromedp/cdproto/dom\"\n\t\"github.com/chromedp/cdproto/page\"\n\t\"github.com/chromedp/cdproto/runtime\"\n\t\"github.com/chromedp/cdproto/target\"\n)\n\nfunc writeHTML(content string) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tio.WriteString(w, strings.TrimSpace(content))\n\t})\n}\n\nfunc ExampleTitle() {\n\tctx, cancel := chromedp.NewContext(context.Background())\n\tdefer cancel()\n\n\tts := httptest.NewServer(writeHTML(`\n<head>\n\t<title>fancy website title</title>\n</head>\n<body>\n\t<div id=\"content\"></div>\n</body>\n\t`))\n\tdefer ts.Close()\n\n\tvar title string\n\tif err := chromedp.Run(ctx,\n\t\tchromedp.Navigate(ts.URL),\n\t\tchromedp.Title(&title),\n\t); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(title)\n\n\t// Output:\n\t// fancy website title\n}\n\nfunc ExampleRunResponse() {\n\tctx, cancel := chromedp.NewContext(context.Background())\n\tdefer cancel()\n\n\t// This server simply shows the URL path as the page title, and contains\n\t// a link that points to /foo.\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tfmt.Fprintf(w, `\n\t\t\t<head><title>%s</title></head>\n\t\t\t<body><a id=\"foo\" href=\"/foo\">foo</a></body>\n\t\t`, r.URL.Path)\n\t}))\n\tdefer ts.Close()\n\n\t// The Navigate action already waits until a page loads, so Title runs\n\t// once the page is ready.\n\tvar firstTitle string\n\tif err := chromedp.Run(ctx,\n\t\tchromedp.Navigate(ts.URL),\n\t\tchromedp.Title(&firstTitle),\n\t); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"first title:\", firstTitle)\n\n\t// However, actions like Click don't always trigger a page navigation,\n\t// so they don't wait for a page load directly. Wrapping them with\n\t// RunResponse does that waiting, and also obtains the HTTP response.\n\tresp, err := chromedp.RunResponse(ctx, chromedp.Click(\"#foo\", chromedp.ByID))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"second status code:\", resp.Status)\n\n\t// Grabbing the title again should work, as the page has finished\n\t// loading once more.\n\tvar secondTitle string\n\tif err := chromedp.Run(ctx, chromedp.Title(&secondTitle)); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"second title:\", secondTitle)\n\n\t// Finally, it's always possible to wrap Navigate with RunResponse, if\n\t// one wants the response information for that case too.\n\tresp, err = chromedp.RunResponse(ctx, chromedp.Navigate(ts.URL+\"/bar\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"third status code:\", resp.Status)\n\n\t// Output:\n\t// first title: /\n\t// second status code: 200\n\t// second title: /foo\n\t// third status code: 200\n}\n\nfunc ExampleExecAllocator() {\n\tdir, err := os.MkdirTemp(\"\", \"chromedp-example\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer os.RemoveAll(dir)\n\n\topts := append(chromedp.DefaultExecAllocatorOptions[:],\n\t\tchromedp.DisableGPU,\n\t\tchromedp.UserDataDir(dir),\n\t)\n\n\tallocCtx, cancel := chromedp.NewExecAllocator(context.Background(), opts...)\n\tdefer cancel()\n\n\t// also set up a custom logger\n\ttaskCtx, cancel := chromedp.NewContext(allocCtx, chromedp.WithLogf(log.Printf))\n\tdefer cancel()\n\n\t// ensure that the browser process is started\n\tif err := chromedp.Run(taskCtx); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tpath := filepath.Join(dir, \"DevToolsActivePort\")\n\tbs, err := os.ReadFile(path)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlines := bytes.Split(bs, []byte(\"\\n\"))\n\tfmt.Printf(\"DevToolsActivePort has %d lines\\n\", len(lines))\n\n\t// Output:\n\t// DevToolsActivePort has 2 lines\n}\n\nfunc ExampleNewContext_reuseBrowser() {\n\tts := httptest.NewServer(writeHTML(`\n<body>\n<script>\n\t// Show the current cookies.\n\tvar p = document.createElement(\"p\")\n\tp.innerText = document.cookie\n\tp.setAttribute(\"id\", \"cookies\")\n\tdocument.body.appendChild(p)\n\n\t// Override the cookies.\n\tdocument.cookie = \"foo=bar\"\n</script>\n</body>\n\t`))\n\tdefer ts.Close()\n\n\t// create a new browser\n\tctx, cancel := chromedp.NewContext(context.Background())\n\tdefer cancel()\n\n\t// start the browser without a timeout\n\tif err := chromedp.Run(ctx); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor i := 0; i < 2; i++ {\n\t\tfunc() {\n\t\t\tctx, cancel := context.WithTimeout(ctx, time.Second)\n\t\t\tdefer cancel()\n\t\t\tctx, cancel = chromedp.NewContext(ctx)\n\t\t\tdefer cancel()\n\t\t\tvar cookies string\n\t\t\tif err := chromedp.Run(ctx,\n\t\t\t\tchromedp.Navigate(ts.URL),\n\t\t\t\tchromedp.Text(\"#cookies\", &cookies),\n\t\t\t); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t\tfmt.Printf(\"Cookies at i=%d: %q\\n\", i, cookies)\n\t\t}()\n\t}\n\n\t// Output:\n\t// Cookies at i=0: \"\"\n\t// Cookies at i=1: \"foo=bar\"\n}\n\nfunc ExampleNewContext_manyTabs() {\n\t// new browser, first tab\n\tctx1, cancel := chromedp.NewContext(context.Background())\n\tdefer cancel()\n\n\t// ensure the first tab is created\n\tif err := chromedp.Run(ctx1); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// same browser, second tab\n\tctx2, _ := chromedp.NewContext(ctx1)\n\n\t// ensure the second tab is created\n\tif err := chromedp.Run(ctx2); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tc1 := chromedp.FromContext(ctx1)\n\tc2 := chromedp.FromContext(ctx2)\n\n\tfmt.Printf(\"Same browser: %t\\n\", c1.Browser == c2.Browser)\n\tfmt.Printf(\"Same tab: %t\\n\", c1.Target == c2.Target)\n\n\t// Output:\n\t// Same browser: true\n\t// Same tab: false\n}\n\nfunc ExampleListenTarget_consoleLog() {\n\tctx, cancel := chromedp.NewContext(context.Background())\n\tdefer cancel()\n\n\tts := httptest.NewServer(writeHTML(`\n<body>\n<script>\n\tconsole.log(\"hello js world\")\n\tconsole.warn(\"scary warning\", 123)\n\tnull.throwsException\n</script>\n</body>\n\t`))\n\tdefer ts.Close()\n\n\tgotException := make(chan bool, 1)\n\tchromedp.ListenTarget(ctx, func(ev interface{}) {\n\t\tswitch ev := ev.(type) {\n\t\tcase *runtime.EventConsoleAPICalled:\n\t\t\tfmt.Printf(\"* console.%s call:\\n\", ev.Type)\n\t\t\tfor _, arg := range ev.Args {\n\t\t\t\tfmt.Printf(\"%s - %s\\n\", arg.Type, arg.Value)\n\t\t\t}\n\t\tcase *runtime.EventExceptionThrown:\n\t\t\t// Since ts.URL uses a random port, replace it.\n\t\t\ts := ev.ExceptionDetails.Error()\n\t\t\ts = strings.ReplaceAll(s, ts.URL, \"<server>\")\n\t\t\t// V8 has changed the error messages for property access on null/undefined in version 9.3.310.\n\t\t\t// see: https://chromium.googlesource.com/v8/v8/+/c0fd89c3c089e888c4f4e8582e56db7066fa779b\n\t\t\t//      https://github.com/chromium/chromium/commit/1735cbf94c98c70ff7554a1e9e01bb9a4f91beb6\n\t\t\t// The message is normalized to make it compatible with the versions before this change.\n\t\t\ts = strings.ReplaceAll(s, \"Cannot read property 'throwsException' of null\", \"Cannot read properties of null (reading 'throwsException')\")\n\t\t\tfmt.Printf(\"* %s\\n\", s)\n\t\t\tgotException <- true\n\t\t}\n\t})\n\n\tif err := chromedp.Run(ctx, chromedp.Navigate(ts.URL)); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t<-gotException\n\n\t// Output:\n\t// * console.log call:\n\t// string - \"hello js world\"\n\t// * console.warning call:\n\t// string - \"scary warning\"\n\t// number - 123\n\t// * exception \"Uncaught\" (4:6): TypeError: Cannot read properties of null (reading 'throwsException')\n\t//     at <server>/:5:7\n}\n\nfunc ExampleWaitNewTarget() {\n\tctx, cancel := chromedp.NewContext(context.Background())\n\tdefer cancel()\n\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/first\", writeHTML(`\n<input id='newtab' type='button' value='open' onclick='window.open(\"/second\", \"_blank\");'/>\n\t`))\n\tmux.Handle(\"/second\", writeHTML(``))\n\tts := httptest.NewServer(mux)\n\tdefer ts.Close()\n\n\t// Grab the first spawned tab that isn't blank.\n\tch := chromedp.WaitNewTarget(ctx, func(info *target.Info) bool {\n\t\treturn info.URL != \"\"\n\t})\n\tif err := chromedp.Run(ctx,\n\t\tchromedp.Navigate(ts.URL+\"/first\"),\n\t\tchromedp.Click(\"#newtab\", chromedp.ByID),\n\t); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tnewCtx, cancel := chromedp.NewContext(ctx, chromedp.WithTargetID(<-ch))\n\tdefer cancel()\n\n\tvar urlstr string\n\tif err := chromedp.Run(newCtx, chromedp.Location(&urlstr)); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"new tab's path:\", strings.TrimPrefix(urlstr, ts.URL))\n\n\t// Output:\n\t// new tab's path: /second\n}\n\nfunc ExampleListenTarget_acceptAlert() {\n\tctx, cancel := chromedp.NewContext(context.Background())\n\tdefer cancel()\n\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/second\", writeHTML(``))\n\tts := httptest.NewServer(writeHTML(`\n<input id='alert' type='button' value='alert' onclick='alert(\"alert text\");'/>\n\t`))\n\tdefer ts.Close()\n\n\tchromedp.ListenTarget(ctx, func(ev interface{}) {\n\t\tif ev, ok := ev.(*page.EventJavascriptDialogOpening); ok {\n\t\t\tfmt.Println(\"closing alert:\", ev.Message)\n\t\t\tgo func() {\n\t\t\t\tif err := chromedp.Run(ctx,\n\t\t\t\t\tpage.HandleJavaScriptDialog(true),\n\t\t\t\t); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t})\n\n\tif err := chromedp.Run(ctx,\n\t\tchromedp.Navigate(ts.URL),\n\t\tchromedp.Click(\"#alert\", chromedp.ByID),\n\t); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Output:\n\t// closing alert: alert text\n}\n\nfunc Example_retrieveHTML() {\n\tctx, cancel := chromedp.NewContext(context.Background())\n\tdefer cancel()\n\n\tts := httptest.NewServer(writeHTML(`\n<body>\n<p id=\"content\" onclick=\"changeText()\">Original content.</p>\n<script>\nfunction changeText() {\n\tdocument.getElementById(\"content\").textContent = \"New content!\"\n}\n</script>\n</body>\n\t`))\n\tdefer ts.Close()\n\n\tvar outerBefore, outerAfter string\n\tif err := chromedp.Run(ctx,\n\t\tchromedp.Navigate(ts.URL),\n\t\tchromedp.OuterHTML(\"#content\", &outerBefore, chromedp.ByQuery),\n\t\tchromedp.Click(\"#content\", chromedp.ByQuery),\n\t\tchromedp.OuterHTML(\"#content\", &outerAfter, chromedp.ByQuery),\n\t); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"OuterHTML before clicking:\")\n\tfmt.Println(outerBefore)\n\tfmt.Println(\"OuterHTML after clicking:\")\n\tfmt.Println(outerAfter)\n\n\t// Output:\n\t// OuterHTML before clicking:\n\t// <p id=\"content\" onclick=\"changeText()\">Original content.</p>\n\t// OuterHTML after clicking:\n\t// <p id=\"content\" onclick=\"changeText()\">New content!</p>\n}\n\nfunc ExampleEmulate() {\n\tctx, cancel := chromedp.NewContext(context.Background())\n\tdefer cancel()\n\n\tvar buf []byte\n\tif err := chromedp.Run(ctx,\n\t\tchromedp.Emulate(device.IPhone7),\n\t\tchromedp.Navigate(`https://duckduckgo.com/`),\n\t\tchromedp.SendKeys(`input[name=q]`, \"what's my user agent?\\n\"),\n\t\tchromedp.WaitVisible(`#zci-answer`, chromedp.ByID),\n\t\tchromedp.CaptureScreenshot(&buf),\n\t); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif err := os.WriteFile(\"iphone7-ua.png\", buf, 0o644); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Output:\n}\n\nfunc ExamplePrintToPDF() {\n\tctx, cancel := chromedp.NewContext(context.Background())\n\tdefer cancel()\n\n\tvar buf []byte\n\tif err := chromedp.Run(ctx,\n\t\tchromedp.Navigate(`https://pkg.go.dev/github.com/chromedp/chromedp`),\n\t\tchromedp.ActionFunc(func(ctx context.Context) error {\n\t\t\tvar err error\n\t\t\tbuf, _, err = page.PrintToPDF().\n\t\t\t\tWithDisplayHeaderFooter(false).\n\t\t\t\tWithLandscape(true).\n\t\t\t\tDo(ctx)\n\t\t\treturn err\n\t\t}),\n\t); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif err := os.WriteFile(\"page.pdf\", buf, 0o644); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Output:\n}\n\nfunc ExampleByJSPath() {\n\tctx, cancel := chromedp.NewContext(context.Background())\n\tdefer cancel()\n\n\tts := httptest.NewServer(writeHTML(`\n<body>\n\t<div id=\"content\">cool content</div>\n</body>\n\t`))\n\tdefer ts.Close()\n\n\tvar ids []cdp.NodeID\n\tvar html string\n\tif err := chromedp.Run(ctx,\n\t\tchromedp.Navigate(ts.URL),\n\t\tchromedp.NodeIDs(`document`, &ids, chromedp.ByJSPath),\n\t\tchromedp.ActionFunc(func(ctx context.Context) error {\n\t\t\tvar err error\n\t\t\thtml, err = dom.GetOuterHTML().WithNodeID(ids[0]).Do(ctx)\n\t\t\treturn err\n\t\t}),\n\t); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"Outer HTML:\")\n\tfmt.Println(html)\n\n\t// Output:\n\t// Outer HTML:\n\t// <html><head></head><body>\n\t// \t<div id=\"content\">cool content</div>\n\t// </body></html>\n}\n\nfunc ExampleFromNode() {\n\tctx, cancel := chromedp.NewContext(context.Background())\n\tdefer cancel()\n\n\tts := httptest.NewServer(writeHTML(`\n<body>\n\t<p class=\"content\">outer content</p>\n\t<div id=\"section\"><p class=\"content\">inner content</p></div>\n</body>\n\t`))\n\tdefer ts.Close()\n\n\tvar nodes []*cdp.Node\n\tif err := chromedp.Run(ctx,\n\t\tchromedp.Navigate(ts.URL),\n\t\tchromedp.Nodes(\"#section\", &nodes, chromedp.ByQuery),\n\t); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tsectionNode := nodes[0]\n\n\tvar queryRoot, queryFromNode, queryNestedSelector string\n\tif err := chromedp.Run(ctx,\n\t\t// Queries run from the document root by default, so Text will\n\t\t// pick the first node it finds.\n\t\tchromedp.Text(\".content\", &queryRoot, chromedp.ByQuery),\n\n\t\t// We can specify a different node to run the query from; in\n\t\t// this case, we can tailor the search within #section.\n\t\tchromedp.Text(\".content\", &queryFromNode, chromedp.ByQuery, chromedp.FromNode(sectionNode)),\n\n\t\t// A CSS selector like \"#section > .content\" achieves the same\n\t\t// here, but FromNode allows us to use a node obtained by an\n\t\t// entirely separate step, allowing for custom logic.\n\t\tchromedp.Text(\"#section > .content\", &queryNestedSelector, chromedp.ByQuery),\n\t); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"Simple query from the document root:\", queryRoot)\n\tfmt.Println(\"Simple query from the section node:\", queryFromNode)\n\tfmt.Println(\"Nested query from the document root:\", queryNestedSelector)\n\n\t// Output:\n\t// Simple query from the document root: outer content\n\t// Simple query from the section node: inner content\n\t// Nested query from the document root: inner content\n}\n\nfunc Example_dump() {\n\tctx, cancel := chromedp.NewContext(context.Background())\n\tdefer cancel()\n\n\tts := httptest.NewServer(writeHTML(`<!doctype html>\n<html>\n<body>\n  <div id=\"content\" style=\"display:block;\">the content</div>\n</body>\n</html>`))\n\tdefer ts.Close()\n\n\tconst expr = `(function(d, id, v) {\n\t\tvar b = d.querySelector('body');\n\t\tvar el = d.createElement('div');\n\t\tel.id = id;\n\t\tel.innerText = v;\n\t\tb.insertBefore(el, b.childNodes[0]);\n\t})(document, %q, %q);`\n\n\ts := fmt.Sprintf(expr, \"thing\", \"a new thing!\")\n\n\tvar buf bytes.Buffer\n\tif err := chromedp.Run(ctx,\n\t\tchromedp.Navigate(ts.URL),\n\t\tchromedp.WaitVisible(`#content`),\n\t\tchromedp.Evaluate(s, nil),\n\t\tchromedp.WaitVisible(`#thing`),\n\t\tchromedp.Dump(`document`, &buf, chromedp.ByJSPath),\n\t); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"Document tree:\")\n\tfmt.Print(buf.String())\n\n\t// Output:\n\t// Document tree:\n\t// #document <Document>\n\t//   html <DocumentType>\n\t//   html\n\t//     head\n\t//     body\n\t//       div#thing\n\t//         #text \"a new thing!\"\n\t//       div#content [style=\"display:block;\"]\n\t//         #text \"the content\"\n}\n\nfunc Example_documentDump() {\n\tctx, cancel := chromedp.NewContext(context.Background())\n\tdefer cancel()\n\n\tts := httptest.NewServer(writeHTML(`<!doctype html>\n<html>\n<body>\n  <div id=\"content\" style=\"display:block;\">the content</div>\n</body>\n</html>`))\n\tdefer ts.Close()\n\n\tconst expr = `(function(d, id, v) {\n\t\tvar b = d.querySelector('body');\n\t\tvar el = d.createElement('div');\n\t\tel.id = id;\n\t\tel.innerText = v;\n\t\tb.insertBefore(el, b.childNodes[0]);\n\t})(document, %q, %q);`\n\n\ts := fmt.Sprintf(expr, \"thing\", \"a new thing!\")\n\n\tvar nodes []*cdp.Node\n\tif err := chromedp.Run(ctx,\n\t\tchromedp.Navigate(ts.URL),\n\t\tchromedp.Nodes(`document`, &nodes,\n\t\t\tchromedp.ByJSPath, chromedp.Populate(-1, true)),\n\t\tchromedp.WaitVisible(`#content`),\n\t\tchromedp.Evaluate(s, nil),\n\t\tchromedp.WaitVisible(`#thing`),\n\t); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(\"Document tree:\")\n\tfmt.Print(nodes[0].Dump(\"  \", \"  \", false))\n\n\t// Output:\n\t// Document tree:\n\t//   #document <Document>\n\t//     html <DocumentType>\n\t//     html\n\t//       head\n\t//       body\n\t//         div#thing\n\t//           #text \"a new thing!\"\n\t//         div#content [style=\"display:block;\"]\n\t//           #text \"the content\"\n}\n\nfunc ExampleFullScreenshot() {\n\tctx, cancel := chromedp.NewContext(context.Background())\n\tdefer cancel()\n\n\tvar buf []byte\n\tif err := chromedp.Run(ctx,\n\t\tchromedp.Navigate(`https://google.com`),\n\t\tchromedp.FullScreenshot(&buf, 90),\n\t); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif err := os.WriteFile(\"fullScreenshot.jpeg\", buf, 0o644); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"wrote fullScreenshot.jpeg\")\n\t// Output:\n\t// wrote fullScreenshot.jpeg\n}\n\nfunc ExampleEvaluate() {\n\tctx, cancel := chromedp.NewContext(context.Background())\n\tdefer cancel()\n\n\t// Ignore the result:\n\t{\n\t\tif err := chromedp.Run(ctx,\n\t\t\tchromedp.Evaluate(`window.scrollTo(0, 100)`, nil),\n\t\t); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n\n\t// Receive a primary value:\n\t{\n\t\tvar sum int\n\t\tif err := chromedp.Run(ctx,\n\t\t\tchromedp.Evaluate(`1+2`, &sum),\n\t\t); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Println(sum)\n\t}\n\n\t// ErrJSUndefined:\n\t{\n\t\tvar val int\n\t\tif err := chromedp.Run(ctx,\n\t\t\tchromedp.Evaluate(`undefined`, &val),\n\t\t); err != nil {\n\t\t\tfmt.Println(err)\n\t\t}\n\t}\n\n\t// ErrJSNull:\n\t{\n\t\tvar val int\n\t\tif err := chromedp.Run(ctx,\n\t\t\tchromedp.Evaluate(`null`, &val),\n\t\t); err != nil {\n\t\t\tfmt.Println(err)\n\t\t}\n\t}\n\n\t// Accept undefined/null result:\n\t{\n\t\tvar val *int\n\t\tif err := chromedp.Run(ctx,\n\t\t\tchromedp.Evaluate(`undefined`, &val),\n\t\t); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Println(val)\n\t}\n\n\t// Receive an array value:\n\t{\n\t\tvar val []int\n\t\tif err := chromedp.Run(ctx,\n\t\t\tchromedp.Evaluate(`[1,2]`, &val),\n\t\t); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Println(val)\n\t}\n\n\t// Map and Slice accept undefined/null:\n\t{\n\t\tvar val []int\n\t\tif err := chromedp.Run(ctx,\n\t\t\tchromedp.Evaluate(`null`, &val),\n\t\t); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Println(\"slice is nil:\", val == nil)\n\t}\n\n\t// Receive the raw bytes:\n\t{\n\t\tvar buf []byte\n\t\tif err := chromedp.Run(ctx,\n\t\t\tchromedp.Evaluate(`alert`, &buf),\n\t\t); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tfmt.Printf(\"%s\\n\", buf)\n\t}\n\n\t// Receive the RemoteObject:\n\t{\n\t\tvar res *runtime.RemoteObject\n\t\tif err := chromedp.Run(ctx,\n\t\t\tchromedp.Evaluate(`alert`, &res),\n\t\t); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tif res.ObjectID != \"\" {\n\t\t\tfmt.Println(\"objectId is present\")\n\t\t}\n\t}\n\n\t// Output:\n\t// 3\n\t// encountered an undefined value\n\t// encountered a null value\n\t// <nil>\n\t// [1 2]\n\t// slice is nil: true\n\t// {}\n\t// objectId is present\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.5380859375,
          "content": "module github.com/chromedp/chromedp\n\ngo 1.23\n\nrequire (\n\tgithub.com/chromedp/cdproto v0.0.0-20241022234722-4d5d5faf59fb\n\tgithub.com/gobwas/ws v1.4.0\n\tgithub.com/ledongthuc/pdf v0.0.0-20220302134840-0c2507a12d80\n\tgithub.com/mailru/easyjson v0.7.7\n\tgithub.com/orisano/pixelmatch v0.0.0-20220722002657-fb0b55479cde\n)\n\nrequire (\n\tgithub.com/chromedp/sysutil v1.1.0 // indirect\n\tgithub.com/gobwas/httphead v0.1.0 // indirect\n\tgithub.com/gobwas/pool v0.2.1 // indirect\n\tgithub.com/josharian/intern v1.0.0 // indirect\n\tgolang.org/x/sys v0.26.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.8837890625,
          "content": "github.com/chromedp/cdproto v0.0.0-20241022234722-4d5d5faf59fb h1:noKVm2SsG4v0Yd0lHNtFYc9EUxIVvrr4kJ6hM8wvIYU=\ngithub.com/chromedp/cdproto v0.0.0-20241022234722-4d5d5faf59fb/go.mod h1:4XqMl3iIW08jtieURWL6Tt5924w21pxirC6th662XUM=\ngithub.com/chromedp/sysutil v1.1.0 h1:PUFNv5EcprjqXZD9nJb9b/c9ibAbxiYo4exNWZyipwM=\ngithub.com/chromedp/sysutil v1.1.0/go.mod h1:WiThHUdltqCNKGc4gaU50XgYjwjYIhKWoHGPTUfWTJ8=\ngithub.com/gobwas/httphead v0.1.0 h1:exrUm0f4YX0L7EBwZHuCF4GDp8aJfVeBrlLQrs6NqWU=\ngithub.com/gobwas/httphead v0.1.0/go.mod h1:O/RXo79gxV8G+RqlR/otEwx4Q36zl9rqC5u12GKvMCM=\ngithub.com/gobwas/pool v0.2.1 h1:xfeeEhW7pwmX8nuLVlqbzVc7udMDrwetjEv+TZIz1og=\ngithub.com/gobwas/pool v0.2.1/go.mod h1:q8bcK0KcYlCgd9e7WYLm9LpyS+YeLd8JVDW6WezmKEw=\ngithub.com/gobwas/ws v1.4.0 h1:CTaoG1tojrh4ucGPcoJFiAQUAsEWekEWvLy7GsVNqGs=\ngithub.com/gobwas/ws v1.4.0/go.mod h1:G3gNqMNtPppf5XUz7O4shetPpcZ1VJ7zt18dlUeakrc=\ngithub.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=\ngithub.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=\ngithub.com/ledongthuc/pdf v0.0.0-20220302134840-0c2507a12d80 h1:6Yzfa6GP0rIo/kULo2bwGEkFvCePZ3qHDDTC3/J9Swo=\ngithub.com/ledongthuc/pdf v0.0.0-20220302134840-0c2507a12d80/go.mod h1:imJHygn/1yfhB7XSJJKlFZKl/J+dCPAknuiaGOshXAs=\ngithub.com/mailru/easyjson v0.7.7 h1:UGYAvKxe3sBsEDzO8ZeWOSlIQfWFlxbzLZe7hwFURr0=\ngithub.com/mailru/easyjson v0.7.7/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=\ngithub.com/orisano/pixelmatch v0.0.0-20220722002657-fb0b55479cde h1:x0TT0RDC7UhAVbbWWBzr41ElhJx5tXPWkIHA2HWPRuw=\ngithub.com/orisano/pixelmatch v0.0.0-20220722002657-fb0b55479cde/go.mod h1:nZgzbfBr3hhjoZnS66nKrHmduYNpc34ny7RK4z5/HM0=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.26.0 h1:KHjCJyddX0LoSTb3J+vWpupP9p0oznkqVk/IfjymZbo=\ngolang.org/x/sys v0.26.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n"
        },
        {
          "name": "input.go",
          "type": "blob",
          "size": 5.5107421875,
          "content": "package chromedp\n\nimport (\n\t\"context\"\n\n\t\"github.com/chromedp/cdproto/cdp\"\n\t\"github.com/chromedp/cdproto/dom\"\n\t\"github.com/chromedp/cdproto/input\"\n\t\"github.com/chromedp/chromedp/kb\"\n)\n\n// MouseAction are mouse input event actions\ntype MouseAction Action\n\n// MouseEvent is a mouse event action to dispatch the specified mouse event\n// type at coordinates x, y.\nfunc MouseEvent(typ input.MouseType, x, y float64, opts ...MouseOption) MouseAction {\n\tp := input.DispatchMouseEvent(typ, x, y)\n\t// apply opts\n\tfor _, o := range opts {\n\t\tp = o(p)\n\t}\n\treturn p\n}\n\n// MouseClickXY is an action that sends a left mouse button click (i.e.,\n// mousePressed and mouseReleased event) to the X, Y location.\nfunc MouseClickXY(x, y float64, opts ...MouseOption) MouseAction {\n\treturn ActionFunc(func(ctx context.Context) error {\n\t\tp := &input.DispatchMouseEventParams{\n\t\t\tType:       input.MousePressed,\n\t\t\tX:          x,\n\t\t\tY:          y,\n\t\t\tButton:     input.Left,\n\t\t\tClickCount: 1,\n\t\t}\n\n\t\t// apply opts\n\t\tfor _, o := range opts {\n\t\t\tp = o(p)\n\t\t}\n\n\t\tif err := p.Do(ctx); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tp.Type = input.MouseReleased\n\t\treturn p.Do(ctx)\n\t})\n}\n\n// MouseClickNode is an action that dispatches a mouse left button click event\n// at the center of a specified node.\n//\n// Note that the window will be scrolled if the node is not within the window's\n// viewport.\nfunc MouseClickNode(n *cdp.Node, opts ...MouseOption) MouseAction {\n\treturn ActionFunc(func(ctx context.Context) error {\n\t\tt := cdp.ExecutorFromContext(ctx).(*Target)\n\t\tif t == nil {\n\t\t\treturn ErrInvalidTarget\n\t\t}\n\n\t\tif err := dom.ScrollIntoViewIfNeeded().WithNodeID(n.NodeID).Do(ctx); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tboxes, err := dom.GetContentQuads().WithNodeID(n.NodeID).Do(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif len(boxes) == 0 {\n\t\t\treturn ErrInvalidDimensions\n\t\t}\n\n\t\tcontent := boxes[0]\n\n\t\tc := len(content)\n\t\tif c%2 != 0 || c < 1 {\n\t\t\treturn ErrInvalidDimensions\n\t\t}\n\n\t\tvar x, y float64\n\t\tfor i := 0; i < c; i += 2 {\n\t\t\tx += content[i]\n\t\t\ty += content[i+1]\n\t\t}\n\t\tx /= float64(c / 2)\n\t\ty /= float64(c / 2)\n\n\t\treturn MouseClickXY(x, y, opts...).Do(ctx)\n\t})\n}\n\n// MouseOption is a mouse action option.\ntype MouseOption = func(*input.DispatchMouseEventParams) *input.DispatchMouseEventParams\n\n// Button is a mouse action option to set the button to click from a string.\nfunc Button(btn string) MouseOption {\n\treturn ButtonType(input.MouseButton(btn))\n}\n\n// ButtonType is a mouse action option to set the button to click.\nfunc ButtonType(button input.MouseButton) MouseOption {\n\treturn func(p *input.DispatchMouseEventParams) *input.DispatchMouseEventParams {\n\t\treturn p.WithButton(button)\n\t}\n}\n\n// ButtonLeft is a mouse action option to set the button clicked as the left\n// mouse button.\nfunc ButtonLeft(p *input.DispatchMouseEventParams) *input.DispatchMouseEventParams {\n\treturn p.WithButton(input.Left)\n}\n\n// ButtonMiddle is a mouse action option to set the button clicked as the middle\n// mouse button.\nfunc ButtonMiddle(p *input.DispatchMouseEventParams) *input.DispatchMouseEventParams {\n\treturn p.WithButton(input.Middle)\n}\n\n// ButtonRight is a mouse action option to set the button clicked as the right\n// mouse button.\nfunc ButtonRight(p *input.DispatchMouseEventParams) *input.DispatchMouseEventParams {\n\treturn p.WithButton(input.Right)\n}\n\n// ButtonNone is a mouse action option to set the button clicked as none (used\n// for mouse movements).\nfunc ButtonNone(p *input.DispatchMouseEventParams) *input.DispatchMouseEventParams {\n\treturn p.WithButton(input.None)\n}\n\n// ButtonModifiers is a mouse action option to add additional input modifiers\n// for a button click.\nfunc ButtonModifiers(modifiers ...input.Modifier) MouseOption {\n\treturn func(p *input.DispatchMouseEventParams) *input.DispatchMouseEventParams {\n\t\tfor _, m := range modifiers {\n\t\t\tp.Modifiers |= m\n\t\t}\n\t\treturn p\n\t}\n}\n\n// ClickCount is a mouse action option to set the click count.\nfunc ClickCount(n int) MouseOption {\n\treturn func(p *input.DispatchMouseEventParams) *input.DispatchMouseEventParams {\n\t\treturn p.WithClickCount(int64(n))\n\t}\n}\n\n// KeyAction are keyboard (key) input event actions.\ntype KeyAction Action\n\n// KeyEvent is a key action that synthesizes a keyDown, char, and keyUp event\n// for each rune contained in keys along with any supplied key options.\n//\n// Only well-known, \"printable\" characters will have char events synthesized.\n//\n// See the [SendKeys] action to synthesize key events for a specific element\n// node.\n//\n// See the [kb] package for implementation details and list of\n// well-known keys.\nfunc KeyEvent(keys string, opts ...KeyOption) KeyAction {\n\treturn ActionFunc(func(ctx context.Context) error {\n\t\tfor _, r := range keys {\n\t\t\tfor _, k := range kb.Encode(r) {\n\t\t\t\tfor _, o := range opts {\n\t\t\t\t\to(k)\n\t\t\t\t}\n\t\t\t\tif err := k.Do(ctx); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n}\n\n// KeyEventNode is a key action that dispatches a key event on an element node.\nfunc KeyEventNode(n *cdp.Node, keys string, opts ...KeyOption) KeyAction {\n\treturn ActionFunc(func(ctx context.Context) error {\n\t\terr := dom.Focus().WithNodeID(n.NodeID).Do(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn KeyEvent(keys, opts...).Do(ctx)\n\t})\n}\n\n// KeyOption is a key action option.\ntype KeyOption = func(*input.DispatchKeyEventParams) *input.DispatchKeyEventParams\n\n// KeyModifiers is a key action option to add additional modifiers on the key\n// press.\nfunc KeyModifiers(modifiers ...input.Modifier) KeyOption {\n\treturn func(p *input.DispatchKeyEventParams) *input.DispatchKeyEventParams {\n\t\tfor _, m := range modifiers {\n\t\t\tp.Modifiers |= m\n\t\t}\n\t\treturn p\n\t}\n}\n"
        },
        {
          "name": "input_test.go",
          "type": "blob",
          "size": 7.234375,
          "content": "package chromedp\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/chromedp/cdproto/cdp\"\n\t\"github.com/chromedp/cdproto/input\"\n\t\"github.com/chromedp/chromedp/kb\"\n)\n\n// inViewportJS is a JavaScript snippet that will get the specified node\n// position relative to the viewport and returns true if the specified node\n// is within the window's viewport.\nconst inViewportJS = `(function(a) {\n\t\tvar r = a[0].getBoundingClientRect();\n\t\treturn r.top >= 0 && r.left >= 0 && r.bottom <= window.innerHeight && r.right <= window.innerWidth;\n\t})($x(%q))`\n\nfunc TestMouseClickXY(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"input.html\")\n\tdefer cancel()\n\n\tif err := Run(ctx, WaitVisible(`#input1`, ByID)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttests := []struct {\n\t\tx, y float64\n\t}{\n\t\t{100, 100},\n\t\t{0, 0},\n\t\t{9999, 100},\n\t\t{100, 9999},\n\t}\n\n\tfor i, test := range tests {\n\t\tvar xstr, ystr string\n\t\tif err := Run(ctx,\n\t\t\tMouseClickXY(test.x, test.y),\n\t\t\tValue(\"#input1\", &xstr, ByID),\n\t\t); err != nil {\n\t\t\tt.Fatalf(\"test %d got error: %v\", i, err)\n\t\t}\n\n\t\tx, err := strconv.ParseFloat(xstr, 64)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"test %d got error: %v\", i, err)\n\t\t}\n\t\tif x != test.x {\n\t\t\tt.Fatalf(\"test %d expected x to be: %f, got: %f\", i, test.x, x)\n\t\t}\n\t\tif err := Run(ctx, Value(\"#input2\", &ystr, ByID)); err != nil {\n\t\t\tt.Fatalf(\"test %d got error: %v\", i, err)\n\t\t}\n\n\t\ty, err := strconv.ParseFloat(ystr, 64)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"test %d got error: %v\", i, err)\n\t\t}\n\t\tif y != test.y {\n\t\t\tt.Fatalf(\"test %d expected y to be: %f, got: %f\", i, test.y, y)\n\t\t}\n\t}\n}\n\nfunc TestMouseClickNode(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tsel, exp string\n\t\topt      MouseOption\n\t\tby       QueryOption\n\t}{\n\t\t{`button2`, \"foo\", ButtonType(input.None), ByID},\n\t\t{`button2`, \"bar\", ButtonType(input.Left), ByID},\n\t\t{`button2`, \"bar-middle\", ButtonType(input.Middle), ByID},\n\t\t{`input3`, \"foo\", ButtonModifiers(input.ModifierNone), ByID},\n\t\t{`input3`, \"bar-right\", ButtonType(input.Right), ByID},\n\t\t{`input3`, \"bar-right\", Button(\"right\"), ByID},\n\t\t{`document.querySelector('#input3')`, \"bar-right\", ButtonType(input.Right), ByJSPath},\n\t\t{`link`, \"clicked\", ButtonType(input.Left), ByID},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(fmt.Sprintf(\"%02d\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := testAllocate(t, \"input.html\")\n\t\t\tdefer cancel()\n\n\t\t\tvar nodes []*cdp.Node\n\t\t\tif err := Run(ctx, Nodes(test.sel, &nodes, test.by)); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\t\t\tif len(nodes) != 1 {\n\t\t\t\tt.Fatalf(\"expected nodes to have exactly 1 element, got: %d\", len(nodes))\n\t\t\t}\n\t\t\tvar value string\n\t\t\tif err := Run(ctx,\n\t\t\t\tMouseClickNode(nodes[0], test.opt),\n\t\t\t\tValue(\"#input3\", &value, ByID),\n\t\t\t); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\tif value != test.exp {\n\t\t\t\tt.Fatalf(\"expected to have value %s, got: %s\", test.exp, value)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMouseClickOffscreenNode(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tsel string\n\t\texp int\n\t\tby  QueryOption\n\t}{\n\t\t{`#button3`, 0, ByID},\n\t\t{`#button3`, 2, ByID},\n\t\t{`#button3`, 10, ByID},\n\t\t{`document.querySelector('#button3')`, 10, ByJSPath},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(fmt.Sprintf(\"%02d\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := testAllocate(t, \"input.html\")\n\t\t\tdefer cancel()\n\n\t\t\tvar nodes []*cdp.Node\n\t\t\tif err := Run(ctx, Nodes(test.sel, &nodes, test.by)); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\tif len(nodes) != 1 {\n\t\t\t\tt.Fatalf(\"expected nodes to have exactly 1 element, got: %d\", len(nodes))\n\t\t\t}\n\n\t\t\tvar ok bool\n\t\t\tif err := Run(ctx, EvaluateAsDevTools(fmt.Sprintf(inViewportJS, nodes[0].FullXPath()), &ok)); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\tif ok {\n\t\t\t\tt.Fatal(\"expected node to be offscreen\")\n\t\t\t}\n\n\t\t\tfor i := test.exp; i > 0; i-- {\n\t\t\t\tif err := Run(ctx, MouseClickNode(nodes[0])); err != nil {\n\t\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar value int\n\t\t\tif err := Run(ctx, Evaluate(\"window.document.test_i\", &value)); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\tif value != test.exp {\n\t\t\t\tt.Fatalf(\"expected to have value %d, got: %d\", test.exp, value)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestKeyEvent(t *testing.T) {\n\tif os.Getenv(\"HEADLESS_SHELL\") != \"\" {\n\t\tt.Skip(`Skip in headless-shell due to \"Check failed: IsSupportedClipboardBuffer(buffer)\"`)\n\t}\n\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tsel, exp string\n\t\tby       QueryOption\n\t}{\n\t\t{`#input4`, \"foo\", ByID},\n\t\t{`#input4`, \"foo and bar\", ByID},\n\t\t{`#input4`, \"1234567890\", ByID},\n\t\t{`#input4`, \"~!@#$%^&*()_+=[];'\", ByID},\n\t\t{`#input4`, \"你\", ByID},\n\t\t{`#input4`, \"\\n\\nfoo\\n\\nbar\\n\\n\", ByID},\n\t\t{`document.querySelector('#input4')`, \"\\n\\ntest\\n\\n\", ByJSPath},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(fmt.Sprintf(\"%02d\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := testAllocate(t, \"input.html\")\n\t\t\tdefer cancel()\n\n\t\t\tvar nodes []*cdp.Node\n\t\t\tif err := Run(ctx, Nodes(test.sel, &nodes, test.by)); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\tif len(nodes) != 1 {\n\t\t\t\tt.Fatalf(\"expected nodes to have exactly 1 element, got: %d\", len(nodes))\n\t\t\t}\n\t\t\tif err := Run(ctx,\n\t\t\t\tFocus(test.sel, test.by),\n\t\t\t\tKeyEvent(kb.Home),\n\t\t\t\t// \"KeyEvent(kb.End, KeyModifiers(input.ModifierShift))\" crash headless-shell with this error:\n\t\t\t\t// [...:FATAL:headless_clipboard.cc(296)] Check failed: IsSupportedClipboardBuffer(buffer)\n\t\t\t\tKeyEvent(kb.End, KeyModifiers(input.ModifierShift)),\n\t\t\t\tKeyEvent(test.exp),\n\t\t\t); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\tvar value string\n\t\t\tif err := Run(ctx, Value(test.sel, &value, test.by)); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\tif value != test.exp {\n\t\t\t\tt.Fatalf(\"expected to have value %s, got: %s\", test.exp, value)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestKeyEventNode(t *testing.T) {\n\tif os.Getenv(\"HEADLESS_SHELL\") != \"\" {\n\t\tt.Skip(`Skip in headless-shell due to \"Check failed: IsSupportedClipboardBuffer(buffer)\"`)\n\t}\n\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tsel, exp string\n\t\tby       QueryOption\n\t}{\n\t\t{`#input4`, \"foo\", ByID},\n\t\t{`#input4`, \"foo and bar\", ByID},\n\t\t{`#input4`, \"1234567890\", ByID},\n\t\t{`#input4`, \"~!@#$%^&*()_+=[];'\", ByID},\n\t\t{`#input4`, \"你\", ByID},\n\t\t{`#input4`, \"\\n\\nfoo\\n\\nbar\\n\\n\", ByID},\n\t\t{`document.querySelector('#input4')`, \"\\n\\ntest\\n\\n\", ByJSPath},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(fmt.Sprintf(\"%02d\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := testAllocate(t, \"input.html\")\n\t\t\tdefer cancel()\n\n\t\t\tvar nodes []*cdp.Node\n\t\t\tif err := Run(ctx, Nodes(test.sel, &nodes, test.by)); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\tif len(nodes) != 1 {\n\t\t\t\tt.Fatalf(\"expected nodes to have exactly 1 element, got: %d\", len(nodes))\n\t\t\t}\n\t\t\tvar value string\n\t\t\tif err := Run(ctx,\n\t\t\t\tKeyEventNode(nodes[0], kb.Home),\n\t\t\t\t// \"KeyEventNode(nodes[0], kb.End, KeyModifiers(input.ModifierShift))\" crash headless-shell with this error:\n\t\t\t\t// [...:FATAL:headless_clipboard.cc(296)] Check failed: IsSupportedClipboardBuffer(buffer)\n\t\t\t\tKeyEventNode(nodes[0], kb.End, KeyModifiers(input.ModifierShift)),\n\t\t\t\tKeyEventNode(nodes[0], test.exp),\n\t\t\t\tValue(test.sel, &value, test.by),\n\t\t\t); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\tif value != test.exp {\n\t\t\t\tt.Fatalf(\"expected to have value %s, got: %s\", test.exp, value)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "js.go",
          "type": "blob",
          "size": 2.0263671875,
          "content": "package chromedp\n\nimport (\n\t_ \"embed\"\n)\n\nvar (\n\t// textJS is a JavaScript snippet that returns the innerText of the specified\n\t// visible (i.e., offsetWidth || offsetHeight || getClientRects().length ) element.\n\t//go:embed js/text.js\n\ttextJS string\n\n\t// textContentJS is a JavaScript snippet that returns the textContent of the\n\t// specified element.\n\t//go:embed js/textContent.js\n\ttextContentJS string\n\n\t// blurJS is a JavaScript snippet that blurs the specified element.\n\t//go:embed js/blur.js\n\tblurJS string\n\n\t// submitJS is a JavaScript snippet that will call the containing form's\n\t// submit function, returning true or false if the call was successful.\n\t//go:embed js/submit.js\n\tsubmitJS string\n\n\t// resetJS is a JavaScript snippet that will call the containing form's\n\t// reset function, returning true or false if the call was successful.\n\t//go:embed js/reset.js\n\tresetJS string\n\n\t// attributeJS is a JavaScript snippet that returns the attribute of a specified\n\t// node.\n\t//go:embed js/attribute.js\n\tattributeJS string\n\n\t// setAttributeJS is a JavaScript snippet that sets the value of the specified\n\t// node, and returns the value.\n\t//go:embed js/setAttribute.js\n\tsetAttributeJS string\n\n\t// visibleJS is a JavaScript snippet that returns true or false depending on if\n\t// the specified node's offsetWidth, offsetHeight or getClientRects().length is\n\t// not null.\n\t//go:embed js/visible.js\n\tvisibleJS string\n\n\t// getClientRectJS is a JavaScript snippet that returns the information about the\n\t// size of the specified node and its position relative to its owner document.\n\t//go:embed js/getClientRect.js\n\tgetClientRectJS string\n\n\t// waitForPredicatePageFunction is a JavaScript snippet that runs the polling in the\n\t// browser. It's copied from puppeteer. See\n\t// https://github.com/puppeteer/puppeteer/blob/669f04a7a6e96cc8353a8cb152898edbc25e7c15/src/common/DOMWorld.ts#L870-L944\n\t// It's modified to make mutation polling respect timeout even when there is not a DOM mutation.\n\t//go:embed js/waitForPredicatePageFunction.js\n\twaitForPredicatePageFunction string\n)\n"
        },
        {
          "name": "js",
          "type": "tree",
          "content": null
        },
        {
          "name": "kb",
          "type": "tree",
          "content": null
        },
        {
          "name": "nav.go",
          "type": "blob",
          "size": 2.9560546875,
          "content": "package chromedp\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/chromedp/cdproto/page\"\n)\n\n// NavigateAction are actions which always trigger a page navigation, waiting\n// for the page to load.\n//\n// Note that these actions don't collect HTTP response information; for that,\n// see [RunResponse].\ntype NavigateAction Action\n\n// Navigate is an action that navigates the current frame.\nfunc Navigate(urlstr string) NavigateAction {\n\treturn responseAction(nil, ActionFunc(func(ctx context.Context) error {\n\t\t_, _, errorText, err := page.Navigate(urlstr).Do(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif errorText != \"\" {\n\t\t\treturn fmt.Errorf(\"page load error %s\", errorText)\n\t\t}\n\t\treturn nil\n\t}))\n}\n\n// NavigationEntries is an action that retrieves the page's navigation history\n// entries.\nfunc NavigationEntries(currentIndex *int64, entries *[]*page.NavigationEntry) Action {\n\tif currentIndex == nil || entries == nil {\n\t\tpanic(\"currentIndex and entries cannot be nil\")\n\t}\n\n\treturn ActionFunc(func(ctx context.Context) error {\n\t\tvar err error\n\t\t*currentIndex, *entries, err = page.GetNavigationHistory().Do(ctx)\n\t\treturn err\n\t})\n}\n\n// NavigateToHistoryEntry is an action to navigate to the specified navigation\n// entry.\nfunc NavigateToHistoryEntry(entryID int64) NavigateAction {\n\treturn responseAction(nil, page.NavigateToHistoryEntry(entryID))\n}\n\n// NavigateBack is an action that navigates the current frame backwards in its\n// history.\nfunc NavigateBack() NavigateAction {\n\treturn responseAction(nil, ActionFunc(func(ctx context.Context) error {\n\t\tcur, entries, err := page.GetNavigationHistory().Do(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif cur <= 0 || cur > int64(len(entries)-1) {\n\t\t\treturn errors.New(\"invalid navigation entry\")\n\t\t}\n\n\t\tentryID := entries[cur-1].ID\n\t\treturn page.NavigateToHistoryEntry(entryID).Do(ctx)\n\t}))\n}\n\n// NavigateForward is an action that navigates the current frame forwards in\n// its history.\nfunc NavigateForward() NavigateAction {\n\treturn responseAction(nil, ActionFunc(func(ctx context.Context) error {\n\t\tcur, entries, err := page.GetNavigationHistory().Do(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif cur < 0 || cur >= int64(len(entries)-1) {\n\t\t\treturn errors.New(\"invalid navigation entry\")\n\t\t}\n\n\t\tentryID := entries[cur+1].ID\n\t\treturn page.NavigateToHistoryEntry(entryID).Do(ctx)\n\t}))\n}\n\n// Reload is an action that reloads the current page.\nfunc Reload() NavigateAction {\n\treturn responseAction(nil, page.Reload())\n}\n\n// Stop is an action that stops all navigation and pending resource retrieval.\nfunc Stop() Action {\n\treturn page.StopLoading()\n}\n\n// Location is an action that retrieves the document location.\nfunc Location(urlstr *string) Action {\n\tif urlstr == nil {\n\t\tpanic(\"urlstr cannot be nil\")\n\t}\n\treturn EvaluateAsDevTools(`document.location.toString()`, urlstr)\n}\n\n// Title is an action that retrieves the document title.\nfunc Title(title *string) Action {\n\tif title == nil {\n\t\tpanic(\"title cannot be nil\")\n\t}\n\treturn EvaluateAsDevTools(`document.title`, title)\n}\n"
        },
        {
          "name": "nav_test.go",
          "type": "blob",
          "size": 9.79296875,
          "content": "package chromedp\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t_ \"image/png\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/chromedp/cdproto/cdp\"\n\t\"github.com/chromedp/cdproto/page\"\n)\n\nfunc TestNavigate(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"image.html\")\n\tdefer cancel()\n\n\tvar urlstr, title string\n\tif err := Run(ctx,\n\t\tLocation(&urlstr),\n\t\tTitle(&title),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !strings.HasSuffix(urlstr, \"image.html\") {\n\t\tt.Errorf(\"want to be on image.html, at %q\", urlstr)\n\t}\n\texptitle := \"this is title\"\n\tif title != exptitle {\n\t\tt.Errorf(\"want title to be %q, got %q\", title, exptitle)\n\t}\n}\n\nfunc TestNavigationEntries(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"\")\n\tdefer cancel()\n\n\ttests := []struct {\n\t\tfile, waitID string\n\t}{\n\t\t{\"form.html\", \"#form\"},\n\t\t{\"image.html\", \"#icon-brankas\"},\n\t}\n\n\tvar entries []*page.NavigationEntry\n\tvar index int64\n\tif err := Run(ctx, NavigationEntries(&index, &entries)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(entries) != 1 {\n\t\tt.Errorf(\"expected to have 1 navigation entry: got %d\", len(entries))\n\t}\n\tif index != 0 {\n\t\tt.Errorf(\"expected navigation index is 0, got: %d\", index)\n\t}\n\n\texpIdx, expEntries := 1, 2\n\tfor i, test := range tests {\n\t\tif err := Run(ctx,\n\t\t\tNavigate(testdataDir+\"/\"+test.file),\n\t\t\tNavigationEntries(&index, &entries),\n\t\t); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(entries) != expEntries {\n\t\t\tt.Errorf(\"test %d expected to have %d navigation entry: got %d\", i, expEntries, len(entries))\n\t\t}\n\t\tif want := int64(i + 1); index != want {\n\t\t\tt.Errorf(\"test %d expected navigation index is %d, got: %d\", i, want, index)\n\t\t}\n\n\t\texpIdx++\n\t\texpEntries++\n\t}\n}\n\nfunc TestNavigateToHistoryEntry(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"image.html\")\n\tdefer cancel()\n\n\tvar entries []*page.NavigationEntry\n\tvar index int64\n\tif err := Run(ctx,\n\t\tNavigationEntries(&index, &entries),\n\t\tNavigate(testdataDir+\"/form.html\"),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar title string\n\tif err := Run(ctx,\n\t\tNavigateToHistoryEntry(entries[index].ID),\n\t\tTitle(&title),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif title != entries[index].Title {\n\t\tt.Errorf(\"expected title to be %q, instead title is %q\", entries[index].Title, title)\n\t}\n}\n\nfunc TestNavigateBack(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"form.html\")\n\tdefer cancel()\n\n\tvar title, exptitle string\n\tif err := Run(ctx,\n\t\tTitle(&exptitle),\n\n\t\tNavigate(testdataDir+\"/image.html\"),\n\n\t\tNavigateBack(),\n\t\tTitle(&title),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif title != exptitle {\n\t\tt.Errorf(\"expected title to be %q, instead title is %q\", exptitle, title)\n\t}\n}\n\nfunc TestNavigateForward(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"form.html\")\n\tdefer cancel()\n\n\tvar title, exptitle string\n\tif err := Run(ctx,\n\t\tNavigate(testdataDir+\"/image.html\"),\n\t\tTitle(&exptitle),\n\n\t\tNavigateBack(),\n\t\tNavigateForward(),\n\n\t\tTitle(&title),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif title != exptitle {\n\t\tt.Errorf(\"expected title to be %q, instead title is %q\", exptitle, title)\n\t}\n}\n\nfunc TestStop(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"form.html\")\n\tdefer cancel()\n\tif err := Run(ctx, Stop()); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestReload(t *testing.T) {\n\tt.Parallel()\n\n\tcount := 0\n\t// create test server\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tfmt.Fprintf(res, `<html>\n<head>\n\t<title>Title %d</title>\n</head>\n</html>`, count)\n\t\tcount++\n\t})\n\ts := httptest.NewServer(mux)\n\tdefer s.Close()\n\n\tctx, cancel := testAllocate(t, \"\")\n\tdefer cancel()\n\n\tvar firstTitle, secondTitle string\n\tif err := Run(ctx,\n\t\tNavigate(s.URL),\n\t\tTitle(&firstTitle),\n\t\tReload(),\n\t\tTitle(&secondTitle),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want := \"Title 0\"; firstTitle != want {\n\t\tt.Errorf(\"expected first title to be %q, instead title is %q\", want, firstTitle)\n\t}\n\tif want := \"Title 1\"; secondTitle != want {\n\t\tt.Errorf(\"expected second title to be %q, instead title is %q\", want, secondTitle)\n\t}\n}\n\nfunc TestLocation(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"form.html\")\n\tdefer cancel()\n\n\tvar urlstr string\n\tif err := Run(ctx, Location(&urlstr)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !strings.HasSuffix(urlstr, \"form.html\") {\n\t\tt.Fatalf(\"expected to be on form.html, got %q\", urlstr)\n\t}\n}\n\nfunc TestTitle(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"image.html\")\n\tdefer cancel()\n\n\tvar title string\n\tif err := Run(ctx, Title(&title)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\texptitle := \"this is title\"\n\tif title != exptitle {\n\t\tt.Fatalf(\"expected title to be %q, got %q\", exptitle, title)\n\t}\n}\n\nfunc TestQueryIframe(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"iframe.html\")\n\tdefer cancel()\n\n\tvar iframes, forms []*cdp.Node\n\tif err := Run(ctx, Nodes(`iframe`, &iframes, ByQuery)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tiframe := iframes[0]\n\tif err := Run(ctx, Nodes(`#form`, &forms, ByQuery, FromNode(iframe))); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tform := forms[0]\n\n\tvar gotFoo string\n\tif err := Run(ctx,\n\t\tWaitVisible(`#form`, ByQuery, FromNode(iframe)),\n\t\tText(\"#foo\", &gotFoo, ByQuery, FromNode(form)),\n\n\t\tClick(\"#btn1\", ByQuery, FromNode(iframe)),\n\t\tClick(\"#btn2\", ByQuery, FromNode(form)),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif want := \"insert\"; gotFoo != want {\n\t\tt.Fatalf(\"wanted %q, got %q\", want, gotFoo)\n\t}\n}\n\nfunc TestNavigateContextTimeout(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"\")\n\tdefer cancel()\n\n\t// Serve the page, but cancel the context almost immediately after.\n\t// Navigate shouldn't block waiting for the load to finish, which may\n\t// not come as the target is cancelled.\n\ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttime.AfterFunc(time.Millisecond, cancel)\n\t}))\n\tdefer s.Close()\n\n\tif err := Run(ctx, Navigate(s.URL)); err != nil && err != context.Canceled {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc writeHTML(content string) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"text/html\")\n\t\tio.WriteString(w, strings.TrimSpace(content))\n\t})\n}\n\nfunc TestNavigateWhileLoading(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"\")\n\tdefer cancel()\n\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/\", writeHTML(`\n<img src=\"/img.jpg\"></img>\n\t`))\n\tch := make(chan struct{})\n\tmux.HandleFunc(\"/img.jpg\", func(w http.ResponseWriter, r *http.Request) {\n\t\t<-ch\n\t})\n\ts := httptest.NewServer(mux)\n\tdefer s.Close()\n\n\t// First, navigate to a page that starts loading, but doesn't finish.\n\t// Then, tell the server to finish loading the page.\n\t// Immediately after, navigate to another page.\n\t// Finally, grab the page title, which should correspond with the last\n\t// page.\n\t//\n\t// This has caused problems in the past. Because the first page might\n\t// fire its load event just as we start the second navigate, the second\n\t// navigate used to get confused, either blocking forever or not waiting\n\t// for the right load event (the second).\n\tvar title string\n\tif err := Run(ctx,\n\t\tActionFunc(func(ctx context.Context) error {\n\t\t\tvar wg sync.WaitGroup\n\t\t\twg.Add(1)\n\t\t\tlctx, cancel := context.WithCancel(ctx)\n\t\t\tListenTarget(lctx, func(ev interface{}) {\n\t\t\t\tif ev, ok := ev.(*page.EventLifecycleEvent); ok {\n\t\t\t\t\tif ev.Name == \"init\" {\n\t\t\t\t\t\tcancel()\n\t\t\t\t\t\twg.Done()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t_, _, _, err := page.Navigate(s.URL).Do(ctx)\n\n\t\t\t// Make sure the Page.lifecycleEvent with the name \"init\" is emitted\n\t\t\t// before starting the second navigate.\n\t\t\t//\n\t\t\t// Otherwise, it's possible that this event is emitted after the\n\t\t\t// second navigate, and the second navigate will handle the wrong\n\t\t\t// events. See https://github.com/chromedp/chromedp/issues/1080.\n\t\t\t//\n\t\t\t// The implementation of responseAction() is buggy in this case.\n\t\t\t// But it's hard to fix it since there is not a way to tell whether\n\t\t\t// the events are from the first navigate.\n\t\t\t//\n\t\t\t// I (ZekeLu) will just deflake this test by making sure the second\n\t\t\t// navigate won't see this event from the first navigate.\n\t\t\t//\n\t\t\t// The issue can be reproduced by commenting out the next line.\n\t\t\twg.Wait()\n\t\t\tch <- struct{}{}\n\t\t\treturn err\n\t\t}),\n\t\tNavigate(testdataDir+\"/image.html\"),\n\t\tTitle(&title),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\texptitle := \"this is title\"\n\tif title != exptitle {\n\t\tt.Errorf(\"want title to be %q, got %q\", exptitle, title)\n\t}\n}\n\nfunc TestNavigateWithoutWaitingForLoad(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"\")\n\tdefer cancel()\n\n\t// If we run a query without waiting for the page to load, chromedp used\n\t// to panic.\n\tif err := Run(ctx,\n\t\tActionFunc(func(ctx context.Context) error {\n\t\t\t_, _, _, err := page.Navigate(testdataDir + \"/form.html\").Do(ctx)\n\t\t\treturn err\n\t\t}),\n\t\tWaitVisible(`#form`, ByID), // for form.html\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestNavigateCancelled(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"\")\n\tdefer cancel()\n\n\tloadStarted := make(chan struct{})\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/\", writeHTML(`<img src=\"/img.jpg\"></img>`))\n\tmux.HandleFunc(\"/img.jpg\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Block until the entire test is done.\n\t\t<-ctx.Done()\n\t})\n\ts := httptest.NewServer(mux)\n\tdefer s.Close()\n\tdefer cancel() // if we call s.Close first, the ctx.Done above hangs\n\n\t// Navigate to a page that will navigate, but never finish loading. Once\n\t// it has the HTML and starts loading an image, cancel the Run context.\n\t// This should result in us seeing a context error.\n\taction := ActionFunc(func(ctx context.Context) error {\n\t\t_, _, _, err := page.Navigate(s.URL).Do(ctx)\n\t\tloadStarted <- struct{}{}\n\t\treturn err\n\t})\n\tctx2, cancel2 := context.WithCancel(ctx)\n\tgo func() {\n\t\t<-loadStarted\n\t\tcancel2()\n\t}()\n\tif _, err := RunResponse(ctx2, action); !errors.Is(err, context.Canceled) {\n\t\tt.Fatalf(\"expected error to be %q, got: %v\", context.Canceled, err)\n\t}\n}\n"
        },
        {
          "name": "poll.go",
          "type": "blob",
          "size": 5.5009765625,
          "content": "package chromedp\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/chromedp/cdproto/cdp\"\n\t\"github.com/chromedp/cdproto/runtime\"\n)\n\n// PollAction are actions that will wait for a general JavaScript predicate.\n//\n// See [Poll] for details on building poll tasks.\ntype PollAction Action\n\n// pollTask holds information pertaining to a poll task.\n//\n// See Poll for details on building poll tasks.\ntype pollTask struct {\n\tframe     *cdp.Node // the frame to evaluate the predicate, defaults to the root page\n\tpredicate string\n\tpolling   string        // the polling mode, defaults to \"raf\" (triggered by requestAnimationFrame)\n\tinterval  time.Duration // the interval when the poll is triggered by a timer\n\ttimeout   time.Duration // the poll timeout, defaults to 30 seconds\n\targs      []interface{}\n\tres       interface{}\n}\n\n// Do executes the poll task in the browser,\n// until the predicate either returns truthy value or the timeout happens.\nfunc (p *pollTask) Do(ctx context.Context) error {\n\tt := cdp.ExecutorFromContext(ctx).(*Target)\n\tif t == nil {\n\t\treturn ErrInvalidTarget\n\t}\n\tvar (\n\t\texecCtx runtime.ExecutionContextID\n\t\tok      bool\n\t)\n\n\tfor {\n\t\t_, _, execCtx, ok = t.ensureFrame()\n\t\tif ok {\n\t\t\tbreak\n\t\t}\n\t\tif err := sleepContext(ctx, 5*time.Millisecond); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif p.frame != nil {\n\t\tt.frameMu.RLock()\n\t\tframeID := t.enclosingFrame(p.frame)\n\t\texecCtx = t.execContexts[frameID]\n\t\tt.frameMu.RUnlock()\n\t}\n\n\targs := make([]interface{}, 0, len(p.args)+3)\n\targs = append(args, p.predicate)\n\tif p.interval > 0 {\n\t\targs = append(args, p.interval.Milliseconds())\n\t} else {\n\t\targs = append(args, p.polling)\n\t}\n\targs = append(args, p.timeout.Milliseconds())\n\targs = append(args, p.args...)\n\n\tr, err := callFunctionOn(ctx, waitForPredicatePageFunction, p.res,\n\t\tfunc(p *runtime.CallFunctionOnParams) *runtime.CallFunctionOnParams {\n\t\t\treturn p.WithExecutionContextID(execCtx).\n\t\t\t\tWithAwaitPromise(true).\n\t\t\t\tWithUserGesture(true)\n\t\t},\n\t\targs...,\n\t)\n\n\tif r != nil && r.Type == \"undefined\" {\n\t\treturn ErrPollingTimeout\n\t}\n\n\treturn err\n}\n\n// Poll is a poll action that will wait for a general JavaScript predicate.\n// It builds the predicate from a JavaScript expression.\n//\n// This is a copy of puppeteer's [page.waitForFunction].\n// It's named Poll intentionally to avoid messing up with the Wait* query actions.\n// The behavior is not guaranteed to be compatible.\n// For example, our implementation makes the poll task not survive from a navigation,\n// and an error is raised in this case (see unit test TestPoll/NotSurviveNavigation).\n//\n// # Polling Options\n//\n// The default polling mode is \"raf\", to constantly execute pageFunction in requestAnimationFrame callback.\n// This is the tightest polling mode which is suitable to observe styling changes.\n// The WithPollingInterval option makes it to poll the predicate with a specified interval.\n// The WithPollingMutation option makes it to poll the predicate on every DOM mutation.\n//\n// The WithPollingTimeout option specifies the maximum time to wait for the predicate returns truthy value.\n// It defaults to 30 seconds. Pass 0 to disable timeout.\n//\n// The WithPollingInFrame option specifies the frame in which to evaluate the predicate.\n// If not specified, it will be evaluated in the root page of the current tab.\n//\n// The WithPollingArgs option provides extra arguments to pass to the predicate.\n// Only apply this option when the predicate is built from a function.\n// See [PollFunction].\n//\n// [page.waitForFunction]: https://github.com/puppeteer/puppeteer/blob/v8.0.0/docs/api.md#pagewaitforfunctionpagefunction-options-args\nfunc Poll(expression string, res interface{}, opts ...PollOption) PollAction {\n\tpredicate := fmt.Sprintf(`return (%s);`, expression)\n\treturn poll(predicate, res, opts...)\n}\n\n// PollFunction is a poll action that will wait for a general JavaScript predicate.\n// It builds the predicate from a JavaScript function.\n//\n// See [Poll] for details on building poll tasks.\nfunc PollFunction(pageFunction string, res interface{}, opts ...PollOption) PollAction {\n\tpredicate := fmt.Sprintf(`return (%s)(...args);`, pageFunction)\n\n\treturn poll(predicate, res, opts...)\n}\n\nfunc poll(predicate string, res interface{}, opts ...PollOption) PollAction {\n\tp := &pollTask{\n\t\tpredicate: predicate,\n\t\tpolling:   \"raf\",\n\t\ttimeout:   30 * time.Second,\n\t\tres:       res,\n\t}\n\n\t// apply options\n\tfor _, o := range opts {\n\t\to(p)\n\t}\n\treturn p\n}\n\n// PollOption is a poll task option.\ntype PollOption = func(task *pollTask)\n\n// WithPollingInterval makes it to poll the predicate with the specified interval.\nfunc WithPollingInterval(interval time.Duration) PollOption {\n\treturn func(w *pollTask) {\n\t\tw.polling = \"\"\n\t\tw.interval = interval\n\t}\n}\n\n// WithPollingMutation makes it to poll the predicate on every DOM mutation.\nfunc WithPollingMutation() PollOption {\n\treturn func(w *pollTask) {\n\t\tw.polling = \"mutation\"\n\t\tw.interval = 0\n\t}\n}\n\n// WithPollingTimeout specifies the maximum time to wait for the predicate returns truthy value.\n// It defaults to 30 seconds. Pass 0 to disable timeout.\nfunc WithPollingTimeout(timeout time.Duration) PollOption {\n\treturn func(w *pollTask) {\n\t\tw.timeout = timeout\n\t}\n}\n\n// WithPollingInFrame specifies the frame in which to evaluate the predicate.\n// If not specified, it will be evaluated in the root page of the current tab.\nfunc WithPollingInFrame(frame *cdp.Node) PollOption {\n\treturn func(w *pollTask) {\n\t\tw.frame = frame\n\t}\n}\n\n// WithPollingArgs provides extra arguments to pass to the predicate.\nfunc WithPollingArgs(args ...interface{}) PollOption {\n\treturn func(w *pollTask) {\n\t\tw.args = args\n\t}\n}\n"
        },
        {
          "name": "poll_test.go",
          "type": "blob",
          "size": 5.75,
          "content": "package chromedp\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/chromedp/cdproto/cdp\"\n\t\"github.com/chromedp/cdproto/runtime\"\n)\n\nfunc TestPoll(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"\")\n\tdefer cancel()\n\n\ttests := []struct {\n\t\tname   string\n\t\tjs     string\n\t\tisFunc bool\n\t\topts   []PollOption\n\t\thash   string\n\t\terr    string\n\t\tdelay  time.Duration\n\t}{\n\t\t{\n\t\t\tname:   \"ExpressionPredicate\",\n\t\t\tjs:     \"globalThis.__FOO === 1\",\n\t\t\tisFunc: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"LambdaCallPredicate\",\n\t\t\tjs:     \"(() => globalThis.__FOO === 1)()\",\n\t\t\tisFunc: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"MultilinePredicate\",\n\t\t\tjs:     \"\\n(() => globalThis.__FOO === 1)()\\n\",\n\t\t\tisFunc: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"FunctionPredicate\",\n\t\t\tjs:     \"function foo() { return globalThis.__FOO === 1; }\",\n\t\t\tisFunc: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"LambdaAsFunction\",\n\t\t\tjs:     \"() => globalThis.__FOO === 1\",\n\t\t\tisFunc: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"Timeout\",\n\t\t\tjs:     \"false\",\n\t\t\tisFunc: false,\n\t\t\topts:   []PollOption{WithPollingTimeout(10 * time.Millisecond)},\n\t\t\terr:    ErrPollingTimeout.Error(),\n\t\t},\n\t\t{\n\t\t\tname: \"ResolvedRightBeforeExecutionContextDisposal\",\n\t\t\tjs: `() => {\n\t\t\t\tif (window.location.hash === '#reload'){\n\t\t\t\t\twindow.location.replace(window.location.href.substring(0, 0 - '#reload'.length));\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}`,\n\t\t\tisFunc: true,\n\t\t\thash:   \"#reload\",\n\t\t},\n\t\t{\n\t\t\tname: \"NotSurviveNavigation\",\n\t\t\tjs: `() => {\n\t\t\t\tif (window.location.hash === '#navigate'){\n\t\t\t\t\twindow.location.replace(window.location.href.substring(0, 0 - '#navigate'.length));\n\t\t\t\t} else {\n\t\t\t\t\treturn globalThis.__FOO === 1;\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tisFunc: true,\n\t\t\thash:   \"#navigate\",\n\t\t\terr:    \"Execution context was destroyed. (-32000)\",\n\t\t},\n\t\t{\n\t\t\tname:   \"PollingInterval\",\n\t\t\tjs:     \"globalThis.__FOO === 1\",\n\t\t\tisFunc: false,\n\t\t\topts:   []PollOption{WithPollingInterval(100 * time.Millisecond)},\n\t\t\thash:   \"#100\",\n\t\t\tdelay:  50 * time.Millisecond,\n\t\t},\n\t\t{\n\t\t\tname: \"PollingMutation\",\n\t\t\tjs: `() => {\n\t\t\t\tif (globalThis.__Mutation === 1){\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tglobalThis.__Mutation = 1;\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tdocument.body.appendChild(document.createElement('div'))\n\t\t\t\t\t}, 100);\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tisFunc: true,\n\t\t\topts:   []PollOption{WithPollingMutation(), WithPollingTimeout(200 * time.Millisecond)},\n\t\t\tdelay:  50 * time.Millisecond,\n\t\t},\n\t\t{\n\t\t\tname:   \"TimeoutWithoutMutation\",\n\t\t\tjs:     \"globalThis.__Mutation === 1\",\n\t\t\tisFunc: false,\n\t\t\topts:   []PollOption{WithPollingMutation(), WithPollingTimeout(100 * time.Millisecond)},\n\t\t\terr:    ErrPollingTimeout.Error(),\n\t\t},\n\t\t{\n\t\t\tname: \"TimeoutBeforeMutation\",\n\t\t\tjs: `() => {\n\t\t\t\tif (globalThis.__Mutation === 1){\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tglobalThis.__Mutation = 1;\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tdocument.body.appendChild(document.createElement('div'))\n\t\t\t\t\t}, 100);\n\t\t\t\t}\n\t\t\t}`,\n\t\t\tisFunc: true,\n\t\t\topts:   []PollOption{WithPollingMutation(), WithPollingTimeout(50 * time.Millisecond)},\n\t\t\terr:    ErrPollingTimeout.Error(),\n\t\t},\n\t\t{\n\t\t\tname:   \"ExtraArgs\",\n\t\t\tjs:     \"(a1, a2) => a1 === 1 && a2 === 'str'\",\n\t\t\tisFunc: true,\n\t\t\topts:   []PollOption{WithPollingArgs(1, \"str\")},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\ttabCtx, tabCancel := NewContext(ctx)\n\t\t\tdefer tabCancel()\n\t\t\tvar action PollAction\n\t\t\tvar res bool\n\t\t\tif test.isFunc {\n\t\t\t\taction = PollFunction(test.js, &res, test.opts...)\n\t\t\t} else {\n\t\t\t\taction = Poll(test.js, &res, test.opts...)\n\t\t\t}\n\t\t\tstartTime := time.Now()\n\t\t\terr := Run(tabCtx,\n\t\t\t\tNavigate(testdataDir+\"/poll.html\"+test.hash),\n\t\t\t\taction,\n\t\t\t)\n\t\t\tif test.err == \"\" {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t\t} else if !res {\n\t\t\t\t\tt.Fatalf(\"got no error, but res is not true\")\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Fatalf(\"expected err to be %q, got: %v\", test.err, err)\n\t\t\t\t} else if test.err != err.Error() {\n\t\t\t\t\tt.Fatalf(\"want error to be %v, got: %v\", test.err, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif test.delay != 0 {\n\t\t\t\tdelay := time.Since(startTime)\n\t\t\t\tif delay < test.delay {\n\t\t\t\t\tt.Fatalf(\"expected delay to be greater than %v, got: %v\", test.delay, delay)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestPollFrame(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"frameset.html\")\n\tdefer cancel()\n\n\tvar res string\n\tvar frames []*cdp.Node\n\tif err := Run(ctx,\n\t\tNodes(`frame[src=\"child1.html\"]`, &frames, ByQuery),\n\t\tActionFunc(func(ctx context.Context) error {\n\t\t\treturn Poll(`document.querySelector(\"#child1>p\").textContent`, &res, WithPollingInFrame(frames[0])).Do(ctx)\n\t\t}),\n\t); err != nil {\n\t\tt.Fatalf(\"got error: %v\", err)\n\t}\n\n\twant := \"child one\"\n\tif res != want {\n\t\tt.Fatalf(\"want result to be %q, got %q\", want, res)\n\t}\n}\n\nfunc TestPollRemoteObject(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"poll.html\")\n\tdefer cancel()\n\n\texpression := `window`\n\n\tvar res *runtime.RemoteObject\n\tif err := Run(ctx, Poll(expression, &res, WithPollingTimeout(10*time.Millisecond))); err != nil {\n\t\tt.Fatalf(\"got error: %v\", err)\n\t}\n\n\twantClassName := \"Window\"\n\tif res.ClassName != wantClassName {\n\t\tt.Fatalf(\"want class name of remote object to be %q, got %q\", wantClassName, res.ClassName)\n\t}\n}\n\nfunc TestPollTimeout(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"poll.html\")\n\tdefer cancel()\n\n\tif err := Run(ctx, Poll(\"false\", nil, WithPollingTimeout(10*time.Millisecond))); err != ErrPollingTimeout {\n\t\tt.Errorf(\"got error: %v, want error: %v\", err, ErrPollingTimeout)\n\t}\n\n\tvar res1 *runtime.RemoteObject\n\tif err := Run(ctx, Poll(\"false\", &res1, WithPollingTimeout(10*time.Millisecond))); err != ErrPollingTimeout {\n\t\tt.Errorf(\"got error: %v, want error: %v\", err, ErrPollingTimeout)\n\t}\n\n\tvar res2 []byte\n\tif err := Run(ctx, Poll(\"false\", &res2, WithPollingTimeout(10*time.Millisecond))); err != ErrPollingTimeout {\n\t\tt.Errorf(\"got error: %v, want error: %v\", err, ErrPollingTimeout)\n\t}\n}\n"
        },
        {
          "name": "query.go",
          "type": "blob",
          "size": 38.74609375,
          "content": "package chromedp\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/chromedp/cdproto\"\n\t\"github.com/chromedp/cdproto/cdp\"\n\t\"github.com/chromedp/cdproto/css\"\n\t\"github.com/chromedp/cdproto/dom\"\n\t\"github.com/chromedp/cdproto/runtime\"\n)\n\n// QueryAction are element query actions that select node elements from the\n// browser's DOM for retrieval or manipulation.\n//\n// See [Query] for details on building element query selectors.\ntype QueryAction Action\n\n// Selector holds information pertaining to an element selection query.\n//\n// See [Query] for information on building an element selector and relevant\n// options.\ntype Selector struct {\n\tsel           interface{}\n\tfromNode      *cdp.Node\n\tretryInterval time.Duration\n\texp           int\n\tby            func(context.Context, *cdp.Node) ([]cdp.NodeID, error)\n\twait          func(context.Context, *cdp.Frame, runtime.ExecutionContextID, ...cdp.NodeID) ([]*cdp.Node, error)\n\tafter         []func(context.Context, runtime.ExecutionContextID, ...*cdp.Node) error\n}\n\n// Query is a query action that queries the browser for specific element\n// node(s) matching the criteria.\n//\n// Query actions that target a browser DOM element node (or nodes) make use of\n// Query, in conjunction with the [After] option to retrieve data or\n// to modify the element(s) selected by the query.\n//\n// For example:\n//\n//\tchromedp.Run(ctx, chromedp.SendKeys(`thing`, chromedp.ByID))\n//\n// The above will perform a [SendKeys] action on the first element matching a\n// browser CSS query for \"#thing\".\n//\n// [Element] selection queries work in conjunction with specific actions and form\n// the primary way of automating [Tasks] in the browser. They are typically\n// written in the following form:\n//\n//\tAction(selector[, parameter1, ...parameterN][,result][, queryOptions...])\n//\n// Where:\n//\n//   - Action - the action to perform\n//   - selector - element query selection (typically a string), that any matching node(s) will have the action applied\n//   - parameter[1-N] - parameter(s) needed for the individual action (if any)\n//   - result - pointer to a result (if any)\n//   - queryOptions - changes how queries are executed, or how nodes are waited for\n//\n// # Query Options\n//\n// By* options specify the type of element query used By the browser to perform\n// the selection query. When not specified, element queries will use [BySearch]\n// (a wrapper for DOM.performSearch).\n//\n// Node* options specify node conditions that cause the query to wait until the\n// specified condition is true. When not specified, queries will use the\n// [NodeReady] wait condition.\n//\n// The [AtLeast] option alters the minimum number of nodes that must be returned\n// by the element query. If not specified, the default value is 1.\n//\n// The [After] option is used to specify a func that will be executed when\n// element query has returned one or more elements, and after the node condition is\n// true.\n//\n// # By Options\n//\n// The [BySearch] (default) option enables querying for elements by plain text,\n// CSS selector or XPath query, wrapping DOM.performSearch.\n//\n// The [ByID] option enables querying for a single element with the matching CSS\n// ID, wrapping DOM.querySelector. ByID is similar to calling\n// document.querySelector('#' + ID) from within the browser.\n//\n// The [ByQuery] option enables querying for a single element using a CSS\n// selector, wrapping DOM.querySelector. ByQuery is similar to calling\n// document.querySelector() from within the browser.\n//\n// The [ByQueryAll] option enables querying for elements using a CSS selector,\n// wrapping DOM.querySelectorAll. ByQueryAll is similar to calling\n// document.querySelectorAll() from within the browser.\n//\n// The [ByJSPath] option enables querying for a single element using its \"JS\n// Path\" value, wrapping Runtime.evaluate. ByJSPath is similar to executing a\n// JavaScript snippet that returns an element from within the browser. ByJSPath\n// should be used only with trusted element queries, as it is passed directly\n// to Runtime.evaluate, and no attempt is made to sanitize the query. Useful\n// for querying DOM elements that cannot be retrieved using other By* funcs,\n// such as ShadowDOM elements.\n//\n// # Node Options\n//\n// The [NodeReady] (default) option causes the query to wait until all element\n// nodes matching the selector have been retrieved from the browser.\n//\n// The [NodeVisible] option causes the query to wait until all element nodes\n// matching the selector have been retrieved from the browser, and are visible.\n//\n// The [NodeNotVisible] option causes the query to wait until all element nodes\n// matching the selector have been retrieved from the browser, and are not\n// visible.\n//\n// The [NodeEnabled] option causes the query to wait until all element nodes\n// matching the selector have been retrieved from the browser, and are enabled\n// (i.e., do not have a 'disabled' attribute).\n//\n// The [NodeSelected] option causes the query to wait until all element nodes\n// matching the selector have been retrieved from the browser, and are\n// selected (i.e., has a 'selected' attribute).\n//\n// The [NodeNotPresent] option causes the query to wait until there are no\n// element nodes matching the selector.\nfunc Query(sel interface{}, opts ...QueryOption) QueryAction {\n\ts := &Selector{\n\t\tsel:           sel,\n\t\texp:           1,\n\t\tretryInterval: 5 * time.Millisecond,\n\t}\n\n\t// apply options\n\tfor _, o := range opts {\n\t\to(s)\n\t}\n\n\tif s.by == nil {\n\t\tBySearch(s)\n\t}\n\n\tif s.wait == nil {\n\t\tNodeReady(s)\n\t}\n\n\treturn s\n}\n\n// Do executes the selector, only finishing if the selector's by, wait, and\n// after funcs succeed, or if the context is cancelled.\nfunc (s *Selector) Do(ctx context.Context) error {\n\tt := cdp.ExecutorFromContext(ctx).(*Target)\n\tif t == nil {\n\t\treturn ErrInvalidTarget\n\t}\n\treturn retryWithSleep(ctx, s.retryInterval, func(ctx context.Context) (bool, error) {\n\t\tframe, root, execCtx, ok := t.ensureFrame()\n\t\tif !ok {\n\t\t\treturn false, nil\n\t\t}\n\n\t\tfromNode := s.fromNode\n\t\tif fromNode == nil {\n\t\t\tfromNode = root\n\t\t} else {\n\t\t\tframeID := t.enclosingFrame(fromNode)\n\t\t\tt.frameMu.RLock()\n\t\t\texecCtx = t.execContexts[frameID]\n\t\t\tt.frameMu.RUnlock()\n\n\t\t\t// TODO: we probably want to use the nested frame\n\t\t\t// instead, but note that util.go stores the nested\n\t\t\t// frame's nodes in the root frame's Nodes map.\n\t\t\t// frame = t.frames[fromNode.FrameID]\n\t\t\t// if frame == nil {\n\t\t\t// \treturn fmt.Errorf(\"FromNode provided does not belong to any active frame\")\n\t\t\t// }\n\t\t}\n\n\t\t// If this is an iframe node, we want to run the query\n\t\t// on its \"content document\" node instead. Otherwise,\n\t\t// queries will return no results.\n\t\tif doc := fromNode.ContentDocument; doc != nil {\n\t\t\tfromNode = doc\n\t\t}\n\n\t\tids, err := s.by(ctx, fromNode)\n\t\tif err != nil {\n\t\t\tvar e *cdproto.Error\n\t\t\t// When the selector is invalid (for example, \"#a:b\" or \"#3\"), it will\n\t\t\t// always fail with \"DOM Error while querying\". It does not make sense\n\t\t\t// to retry in this case.\n\t\t\t// Maybe \"DOM Error while querying\" is also used for other errors other\n\t\t\t// than invalid selector. But the response does not contain anything\n\t\t\t// else that can be used to distinguish them. So we have to go with it.\n\t\t\tif errors.As(err, &e) && e.Message == \"DOM Error while querying\" {\n\t\t\t\treturn true, err\n\t\t\t}\n\t\t\treturn false, nil\n\t\t}\n\t\tif len(ids) < s.exp {\n\t\t\treturn false, nil\n\t\t}\n\t\tnodes, err := s.wait(ctx, frame, execCtx, ids...)\n\t\t// if nodes==nil, we're not yet ready\n\t\tif nodes == nil || err != nil {\n\t\t\treturn false, nil\n\t\t}\n\t\tfor _, f := range s.after {\n\t\t\tif err := f(ctx, execCtx, nodes...); err != nil {\n\t\t\t\treturn true, err\n\t\t\t}\n\t\t}\n\t\treturn true, nil\n\t})\n}\n\n// selAsString forces sel into a string.\nfunc (s *Selector) selAsString() string {\n\tif sel, ok := s.sel.(string); ok {\n\t\treturn sel\n\t}\n\treturn fmt.Sprintf(\"%s\", s.sel)\n}\n\n// waitReady waits for the specified nodes to be ready.\nfunc (s *Selector) waitReady(check func(context.Context, runtime.ExecutionContextID, *cdp.Node) error) func(context.Context, *cdp.Frame, runtime.ExecutionContextID, ...cdp.NodeID) ([]*cdp.Node, error) {\n\treturn func(ctx context.Context, cur *cdp.Frame, execCtx runtime.ExecutionContextID, ids ...cdp.NodeID) ([]*cdp.Node, error) {\n\t\tnodes := make([]*cdp.Node, len(ids))\n\t\tcur.RLock()\n\t\tfor i, id := range ids {\n\t\t\tnodes[i] = cur.Nodes[id]\n\t\t\tif nodes[i] == nil {\n\t\t\t\tcur.RUnlock()\n\t\t\t\t// not yet ready\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t}\n\t\tcur.RUnlock()\n\n\t\tif check != nil {\n\t\t\terrc := make(chan error, 1)\n\t\t\tfor _, n := range nodes {\n\t\t\t\tgo func(n *cdp.Node) {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t\terrc <- ctx.Err()\n\t\t\t\t\tcase errc <- check(ctx, execCtx, n):\n\t\t\t\t\t}\n\t\t\t\t}(n)\n\t\t\t}\n\n\t\t\tvar first error\n\t\t\tfor range nodes {\n\t\t\t\tif err := <-errc; first == nil {\n\t\t\t\t\tfirst = err\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose(errc)\n\t\t\tif first != nil {\n\t\t\t\treturn nil, first\n\t\t\t}\n\t\t}\n\t\treturn nodes, nil\n\t}\n}\n\n// QueryAfter is an element query action that queries the browser for selector\n// sel. Waits until the visibility conditions of the query have been met, after\n// which executes f.\nfunc QueryAfter(sel interface{}, f func(context.Context, runtime.ExecutionContextID, ...*cdp.Node) error, opts ...QueryOption) QueryAction {\n\treturn Query(sel, append(opts, After(f))...)\n}\n\n// QueryOption is an element query action option.\ntype QueryOption = func(*Selector)\n\n// FromNode is an element query action option where a query will be run. That\n// is, the query will only look at the node's element sub-tree. By default, or\n// when passed nil, the document's root element will be used.\n//\n// Note that, at present, BySearch and ByJSPath do not support FromNode; this\n// option is mainly useful for ByQuery selectors.\nfunc FromNode(node *cdp.Node) QueryOption {\n\treturn func(s *Selector) { s.fromNode = node }\n}\n\n// ByFunc is an element query action option to set the func used to select elements.\nfunc ByFunc(f func(context.Context, *cdp.Node) ([]cdp.NodeID, error)) QueryOption {\n\treturn func(s *Selector) {\n\t\ts.by = f\n\t}\n}\n\n// ByQuery is an element query action option to select a single element by the\n// DOM.querySelector command.\n//\n// Similar to calling document.querySelector() in the browser.\nfunc ByQuery(s *Selector) {\n\tByFunc(func(ctx context.Context, n *cdp.Node) ([]cdp.NodeID, error) {\n\t\tnodeID, err := dom.QuerySelector(n.NodeID, s.selAsString()).Do(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif nodeID == cdp.EmptyNodeID {\n\t\t\treturn []cdp.NodeID{}, nil\n\t\t}\n\n\t\treturn []cdp.NodeID{nodeID}, nil\n\t})(s)\n}\n\n// ByQueryAll is an element query action option to select elements by the\n// DOM.querySelectorAll command.\n//\n// Similar to calling document.querySelectorAll() in the browser.\nfunc ByQueryAll(s *Selector) {\n\tByFunc(func(ctx context.Context, n *cdp.Node) ([]cdp.NodeID, error) {\n\t\treturn dom.QuerySelectorAll(n.NodeID, s.selAsString()).Do(ctx)\n\t})(s)\n}\n\n// ByID is an element query option to select a single element by its CSS #id.\n//\n// Similar to calling document.querySelector('#' + ID) in the browser.\nfunc ByID(s *Selector) {\n\ts.sel = \"#\" + strings.TrimPrefix(s.selAsString(), \"#\")\n\tByQuery(s)\n}\n\n// BySearch is an element query option to select elements by the DOM.performSearch\n// command. It matches nodes by plain text, CSS selector or XPath query.\nfunc BySearch(s *Selector) {\n\tByFunc(func(ctx context.Context, n *cdp.Node) ([]cdp.NodeID, error) {\n\t\tid, count, err := dom.PerformSearch(s.selAsString()).Do(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdefer func() {\n\t\t\t_ = dom.DiscardSearchResults(id).Do(ctx)\n\t\t}()\n\n\t\tif count < 1 {\n\t\t\treturn []cdp.NodeID{}, nil\n\t\t}\n\n\t\tnodes, err := dom.GetSearchResults(id, 0, count).Do(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn nodes, nil\n\t})(s)\n}\n\n// ByJSPath is an element query option to select elements by the \"JS Path\"\n// value (as shown in the Chrome DevTools UI).\n//\n// Allows for the direct querying of DOM elements that otherwise cannot be\n// retrieved using the other By* funcs, such as ShadowDOM elements.\n//\n// Note: Do not use with an untrusted selector value, as any defined selector\n// will be passed to runtime.Evaluate.\nfunc ByJSPath(s *Selector) {\n\tByFunc(func(ctx context.Context, n *cdp.Node) ([]cdp.NodeID, error) {\n\t\t// set up eval command\n\t\tp := runtime.Evaluate(s.selAsString()).\n\t\t\tWithAwaitPromise(true).\n\t\t\tWithObjectGroup(\"console\").\n\t\t\tWithIncludeCommandLineAPI(true)\n\n\t\t// execute\n\t\tv, exp, err := p.Do(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif exp != nil {\n\t\t\treturn nil, exp\n\t\t}\n\n\t\t// use the ObjectID from the evaluation to get the nodeID\n\t\tnodeID, err := dom.RequestNode(v.ObjectID).Do(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif nodeID == cdp.EmptyNodeID {\n\t\t\treturn []cdp.NodeID{}, nil\n\t\t}\n\n\t\treturn []cdp.NodeID{nodeID}, nil\n\t})(s)\n}\n\n// ByNodeID is an element query option to select elements by their node IDs.\n//\n// Uses DOM.requestChildNodes to retrieve elements with specific node IDs.\n//\n// Note: must be used with []cdp.NodeID.\nfunc ByNodeID(s *Selector) {\n\tids, ok := s.sel.([]cdp.NodeID)\n\tif !ok {\n\t\tpanic(\"ByNodeID can only work on []cdp.NodeID\")\n\t}\n\n\tByFunc(func(ctx context.Context, n *cdp.Node) ([]cdp.NodeID, error) {\n\t\tfor _, id := range ids {\n\t\t\terr := dom.RequestChildNodes(id).WithPierce(true).Do(ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\treturn ids, nil\n\t})(s)\n}\n\n// WaitFunc is an element query option to set a custom node condition wait.\nfunc WaitFunc(wait func(context.Context, *cdp.Frame, runtime.ExecutionContextID, ...cdp.NodeID) ([]*cdp.Node, error)) QueryOption {\n\treturn func(s *Selector) {\n\t\ts.wait = wait\n\t}\n}\n\n// NodeReady is an element query option to wait until all queried element nodes\n// have been sent by the browser.\nfunc NodeReady(s *Selector) {\n\tWaitFunc(s.waitReady(nil))(s)\n}\n\nfunc callFunctionOnNode(ctx context.Context, node *cdp.Node, function string, res interface{}, args ...interface{}) error {\n\tr, err := dom.ResolveNode().WithNodeID(node.NodeID).Do(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = CallFunctionOn(function, res,\n\t\tfunc(p *runtime.CallFunctionOnParams) *runtime.CallFunctionOnParams {\n\t\t\treturn p.WithObjectID(r.ObjectID)\n\t\t},\n\t\targs...,\n\t).Do(ctx)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Try to release the remote object.\n\t// It will fail if the page is navigated or closed,\n\t// and it's okay to ignore the error in this case.\n\t_ = runtime.ReleaseObject(r.ObjectID).Do(ctx)\n\n\treturn nil\n}\n\n// NodeVisible is an element query option to wait until all queried element\n// nodes have been sent by the browser and are visible.\nfunc NodeVisible(s *Selector) {\n\tWaitFunc(s.waitReady(func(ctx context.Context, execCtx runtime.ExecutionContextID, n *cdp.Node) error {\n\t\t// check box model\n\t\t_, err := dom.GetBoxModel().WithNodeID(n.NodeID).Do(ctx)\n\t\tif err != nil {\n\t\t\tif isCouldNotComputeBoxModelError(err) {\n\t\t\t\treturn ErrNotVisible\n\t\t\t}\n\n\t\t\treturn err\n\t\t}\n\n\t\t// check visibility\n\t\tvar res bool\n\t\terr = callFunctionOnNode(ctx, n, visibleJS, &res)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !res {\n\t\t\treturn ErrNotVisible\n\t\t}\n\t\treturn nil\n\t}))(s)\n}\n\n// NodeNotVisible is an element query option to wait until all queried element\n// nodes have been sent by the browser and are not visible.\nfunc NodeNotVisible(s *Selector) {\n\tWaitFunc(s.waitReady(func(ctx context.Context, execCtx runtime.ExecutionContextID, n *cdp.Node) error {\n\t\t// check box model\n\t\t_, err := dom.GetBoxModel().WithNodeID(n.NodeID).Do(ctx)\n\t\tif err != nil {\n\t\t\tif isCouldNotComputeBoxModelError(err) {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\treturn err\n\t\t}\n\n\t\t// check visibility\n\t\tvar res bool\n\t\terr = callFunctionOnNode(ctx, n, visibleJS, &res)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif res {\n\t\t\treturn ErrVisible\n\t\t}\n\t\treturn nil\n\t}))(s)\n}\n\n// NodeEnabled is an element query option to wait until all queried element\n// nodes have been sent by the browser and are enabled (i.e., do not have a\n// 'disabled' attribute).\nfunc NodeEnabled(s *Selector) {\n\tWaitFunc(s.waitReady(func(ctx context.Context, execCtx runtime.ExecutionContextID, n *cdp.Node) error {\n\t\tn.RLock()\n\t\tdefer n.RUnlock()\n\n\t\tfor i := 0; i < len(n.Attributes); i += 2 {\n\t\t\tif n.Attributes[i] == \"disabled\" {\n\t\t\t\treturn ErrDisabled\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}))(s)\n}\n\n// NodeSelected is an element query option to wait until all queried element\n// nodes have been sent by the browser and are selected (i.e., has 'selected'\n// attribute).\nfunc NodeSelected(s *Selector) {\n\tWaitFunc(s.waitReady(func(ctx context.Context, execCtx runtime.ExecutionContextID, n *cdp.Node) error {\n\t\tn.RLock()\n\t\tdefer n.RUnlock()\n\n\t\tfor i := 0; i < len(n.Attributes); i += 2 {\n\t\t\tif n.Attributes[i] == \"selected\" {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\treturn ErrNotSelected\n\t}))(s)\n}\n\n// NodeNotPresent is an element query option to wait until no elements are\n// present that match the query.\n//\n// Note: forces the expected number of element nodes to be 0.\nfunc NodeNotPresent(s *Selector) {\n\ts.exp = 0\n\tWaitFunc(func(ctx context.Context, cur *cdp.Frame, execCtx runtime.ExecutionContextID, ids ...cdp.NodeID) ([]*cdp.Node, error) {\n\t\tif len(ids) != 0 {\n\t\t\treturn nil, ErrHasResults\n\t\t}\n\t\treturn []*cdp.Node{}, nil\n\t})(s)\n}\n\n// AtLeast is an element query option to set a minimum number of elements that\n// must be returned by the query.\n//\n// By default, a query will have a value of 1.\nfunc AtLeast(n int) QueryOption {\n\treturn func(s *Selector) {\n\t\ts.exp = n\n\t}\n}\n\n// RetryInterval is an element query action option to set the retry interval to specify\n// how often it should retry when it failed to select the target element(s).\n//\n// The default value is 5ms.\nfunc RetryInterval(interval time.Duration) QueryOption {\n\treturn func(s *Selector) {\n\t\ts.retryInterval = interval\n\t}\n}\n\n// After is an element query option that sets a func to execute after the\n// matched nodes have been returned by the browser, and after the node\n// condition is true.\nfunc After(f func(context.Context, runtime.ExecutionContextID, ...*cdp.Node) error) QueryOption {\n\treturn func(s *Selector) {\n\t\ts.after = append(s.after, f)\n\t}\n}\n\n// Populate is an element query option that causes the queried nodes to be\n// retrieved for later use. Use a depth of -1 to retrieve all child nodes. When\n// pierce is true, will pierce child containers (e.g. iframes and the like)\n//\n// NOTE: this could be extremely resource intensive. Avoid doing this unless\n// necessary.\nfunc Populate(depth int64, pierce bool, opts ...PopulateOption) QueryOption {\n\treturn After(func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tvar d time.Duration\n\t\tfor _, o := range opts {\n\t\t\to(&d)\n\t\t}\n\t\tfor _, n := range nodes {\n\t\t\tif err := dom.RequestChildNodes(n.NodeID).\n\t\t\t\tWithDepth(depth).\n\t\t\t\tWithPierce(pierce).\n\t\t\t\tDo(ctx); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif d != 0 {\n\t\t\t<-time.After(d)\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// PopulateOption is an element populate action option.\ntype PopulateOption = func(*time.Duration)\n\n// PopulateWait is populate option to set a wait interval after requesting\n// child nodes.\nfunc PopulateWait(wait time.Duration) PopulateOption {\n\treturn func(d *time.Duration) {\n\t\t*d = wait\n\t}\n}\n\n// WaitReady is an element query action that waits until the element matching\n// the selector is ready (i.e., has been \"loaded\").\nfunc WaitReady(sel interface{}, opts ...QueryOption) QueryAction {\n\treturn Query(sel, opts...)\n}\n\n// WaitVisible is an element query action that waits until the element matching\n// the selector is visible.\nfunc WaitVisible(sel interface{}, opts ...QueryOption) QueryAction {\n\treturn Query(sel, append(opts, NodeVisible)...)\n}\n\n// WaitNotVisible is an element query action that waits until the element\n// matching the selector is not visible.\nfunc WaitNotVisible(sel interface{}, opts ...QueryOption) QueryAction {\n\treturn Query(sel, append(opts, NodeNotVisible)...)\n}\n\n// WaitEnabled is an element query action that waits until the element matching\n// the selector is enabled (i.e., does not have attribute 'disabled').\nfunc WaitEnabled(sel interface{}, opts ...QueryOption) QueryAction {\n\treturn Query(sel, append(opts, NodeEnabled)...)\n}\n\n// WaitSelected is an element query action that waits until the element\n// matching the selector is selected (i.e., has attribute 'selected').\nfunc WaitSelected(sel interface{}, opts ...QueryOption) QueryAction {\n\treturn Query(sel, append(opts, NodeSelected)...)\n}\n\n// WaitNotPresent is an element query action that waits until no elements are\n// present matching the selector.\nfunc WaitNotPresent(sel interface{}, opts ...QueryOption) QueryAction {\n\treturn Query(sel, append(opts, NodeNotPresent)...)\n}\n\n// Nodes is an element query action that retrieves the document element nodes\n// matching the selector.\nfunc Nodes(sel interface{}, nodes *[]*cdp.Node, opts ...QueryOption) QueryAction {\n\tif nodes == nil {\n\t\tpanic(\"nodes cannot be nil\")\n\t}\n\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, n ...*cdp.Node) error {\n\t\t*nodes = n\n\t\treturn nil\n\t}, opts...)\n}\n\n// NodeIDs is an element query action that retrieves the element node IDs matching the\n// selector.\nfunc NodeIDs(sel interface{}, ids *[]cdp.NodeID, opts ...QueryOption) QueryAction {\n\tif ids == nil {\n\t\tpanic(\"nodes cannot be nil\")\n\t}\n\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tnodeIDs := make([]cdp.NodeID, len(nodes))\n\t\tfor i, n := range nodes {\n\t\t\tnodeIDs[i] = n.NodeID\n\t\t}\n\n\t\t*ids = nodeIDs\n\n\t\treturn nil\n\t}, opts...)\n}\n\n// Focus is an element query action that focuses the first element node matching the\n// selector.\nfunc Focus(sel interface{}, opts ...QueryOption) QueryAction {\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\treturn dom.Focus().WithNodeID(nodes[0].NodeID).Do(ctx)\n\t}, opts...)\n}\n\n// Blur is an element query action that unfocuses (blurs) the first element node\n// matching the selector.\nfunc Blur(sel interface{}, opts ...QueryOption) QueryAction {\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\tvar res bool\n\t\terr := callFunctionOnNode(ctx, nodes[0], blurJS, &res)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !res {\n\t\t\treturn fmt.Errorf(\"could not blur node %d\", nodes[0].NodeID)\n\t\t}\n\n\t\treturn nil\n\t}, opts...)\n}\n\n// Dimensions is an element query action that retrieves the box model dimensions for the\n// first element node matching the selector.\nfunc Dimensions(sel interface{}, model **dom.BoxModel, opts ...QueryOption) QueryAction {\n\tif model == nil {\n\t\tpanic(\"model cannot be nil\")\n\t}\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\t\tvar err error\n\t\t*model, err = dom.GetBoxModel().WithNodeID(nodes[0].NodeID).Do(ctx)\n\t\treturn err\n\t}, opts...)\n}\n\n// Text is an element query action that retrieves the visible text of the first element\n// node matching the selector.\nfunc Text(sel interface{}, text *string, opts ...QueryOption) QueryAction {\n\tif text == nil {\n\t\tpanic(\"text cannot be nil\")\n\t}\n\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\treturn callFunctionOnNode(ctx, nodes[0], textJS, text)\n\t}, opts...)\n}\n\n// TextContent is an element query action that retrieves the text content of the first element\n// node matching the selector.\nfunc TextContent(sel interface{}, text *string, opts ...QueryOption) QueryAction {\n\tif text == nil {\n\t\tpanic(\"text cannot be nil\")\n\t}\n\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\treturn callFunctionOnNode(ctx, nodes[0], textContentJS, text)\n\t}, opts...)\n}\n\n// Clear is an element query action that clears the values of any input/textarea element\n// nodes matching the selector.\nfunc Clear(sel interface{}, opts ...QueryOption) QueryAction {\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\tfor _, n := range nodes {\n\t\t\tif n.NodeType != cdp.NodeTypeElement || (n.NodeName != \"INPUT\" && n.NodeName != \"TEXTAREA\") {\n\t\t\t\treturn fmt.Errorf(\"selector %q matched node %d with name %s\", sel, n.NodeID, strings.ToLower(n.NodeName))\n\t\t\t}\n\t\t}\n\n\t\terrs := make([]error, len(nodes))\n\t\tvar wg sync.WaitGroup\n\t\tfor i, n := range nodes {\n\t\t\twg.Add(1)\n\t\t\tgo func(i int, n *cdp.Node) {\n\t\t\t\tdefer wg.Done()\n\n\t\t\t\tvar a Action\n\t\t\t\tif n.NodeName == \"INPUT\" {\n\t\t\t\t\ta = dom.SetAttributeValue(n.NodeID, \"value\", \"\")\n\t\t\t\t} else {\n\t\t\t\t\t// find textarea's child #text node\n\t\t\t\t\tvar textID cdp.NodeID\n\t\t\t\t\tvar found bool\n\t\t\t\t\tfor _, c := range n.Children {\n\t\t\t\t\t\tif c.NodeType == cdp.NodeTypeText {\n\t\t\t\t\t\t\ttextID = c.NodeID\n\t\t\t\t\t\t\tfound = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif !found {\n\t\t\t\t\t\terrs[i] = fmt.Errorf(\"textarea node %d does not have child #text node\", n.NodeID)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\ta = dom.SetNodeValue(textID, \"\")\n\t\t\t\t}\n\t\t\t\terrs[i] = a.Do(ctx)\n\t\t\t}(i, n)\n\t\t}\n\t\twg.Wait()\n\n\t\tfor _, err := range errs {\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}, opts...)\n}\n\n// Value is an element query action that retrieves the JavaScript value field of the\n// first element node matching the selector.\n//\n// Useful for retrieving an element's JavaScript value, namely form, input,\n// textarea, select, or any other element with a '.value' field.\nfunc Value(sel interface{}, value *string, opts ...QueryOption) QueryAction {\n\tif value == nil {\n\t\tpanic(\"value cannot be nil\")\n\t}\n\n\treturn JavascriptAttribute(sel, \"value\", value, opts...)\n}\n\n// SetValue is an element query action that sets the JavaScript value of the first\n// element node matching the selector.\n//\n// Useful for setting an element's JavaScript value, namely form, input,\n// textarea, select, or other element with a '.value' field.\nfunc SetValue(sel interface{}, value string, opts ...QueryOption) QueryAction {\n\treturn SetJavascriptAttribute(sel, \"value\", value, opts...)\n}\n\n// Attributes is an element query action that retrieves the element attributes for the\n// first element node matching the selector.\nfunc Attributes(sel interface{}, attributes *map[string]string, opts ...QueryOption) QueryAction {\n\tif attributes == nil {\n\t\tpanic(\"attributes cannot be nil\")\n\t}\n\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\tnodes[0].RLock()\n\t\tdefer nodes[0].RUnlock()\n\n\t\tm := make(map[string]string)\n\t\tattrs := nodes[0].Attributes\n\t\tfor i := 0; i < len(attrs); i += 2 {\n\t\t\tm[attrs[i]] = attrs[i+1]\n\t\t}\n\n\t\t*attributes = m\n\n\t\treturn nil\n\t}, opts...)\n}\n\n// AttributesAll is an element query action that retrieves the element attributes for\n// all element nodes matching the selector.\n//\n// Note: this should be used with the ByQueryAll query option.\nfunc AttributesAll(sel interface{}, attributes *[]map[string]string, opts ...QueryOption) QueryAction {\n\tif attributes == nil {\n\t\tpanic(\"attributes cannot be nil\")\n\t}\n\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\tfor _, node := range nodes {\n\t\t\tnode.RLock()\n\t\t\tm := make(map[string]string)\n\t\t\tattrs := node.Attributes\n\t\t\tfor i := 0; i < len(attrs); i += 2 {\n\t\t\t\tm[attrs[i]] = attrs[i+1]\n\t\t\t}\n\t\t\t*attributes = append(*attributes, m)\n\t\t\tnode.RUnlock()\n\t\t}\n\t\treturn nil\n\t}, opts...)\n}\n\n// SetAttributes is an element query action that sets the element attributes for the\n// first element node matching the selector.\nfunc SetAttributes(sel interface{}, attributes map[string]string, opts ...QueryOption) QueryAction {\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn errors.New(\"expected at least one element\")\n\t\t}\n\n\t\ti, attrs := 0, make([]string, len(attributes))\n\t\tfor k, v := range attributes {\n\t\t\tattrs[i] = fmt.Sprintf(`%s=%s`, k, strconv.Quote(v))\n\t\t\ti++\n\t\t}\n\n\t\treturn dom.SetAttributesAsText(nodes[0].NodeID, strings.Join(attrs, \" \")).Do(ctx)\n\t}, opts...)\n}\n\n// AttributeValue is an element query action that retrieves the element attribute value\n// for the first element node matching the selector.\nfunc AttributeValue(sel interface{}, name string, value *string, ok *bool, opts ...QueryOption) QueryAction {\n\tif value == nil {\n\t\tpanic(\"value cannot be nil\")\n\t}\n\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn errors.New(\"expected at least one element\")\n\t\t}\n\n\t\tnodes[0].RLock()\n\t\tdefer nodes[0].RUnlock()\n\n\t\tattrs := nodes[0].Attributes\n\t\tfor i := 0; i < len(attrs); i += 2 {\n\t\t\tif attrs[i] == name {\n\t\t\t\t*value = attrs[i+1]\n\t\t\t\tif ok != nil {\n\t\t\t\t\t*ok = true\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\tif ok != nil {\n\t\t\t*ok = false\n\t\t}\n\n\t\treturn nil\n\t}, opts...)\n}\n\n// SetAttributeValue is an element query action that sets the element attribute with\n// name to value for the first element node matching the selector.\nfunc SetAttributeValue(sel interface{}, name, value string, opts ...QueryOption) QueryAction {\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\treturn dom.SetAttributeValue(nodes[0].NodeID, name, value).Do(ctx)\n\t}, opts...)\n}\n\n// RemoveAttribute is an element query action that removes the element attribute with\n// name from the first element node matching the selector.\nfunc RemoveAttribute(sel interface{}, name string, opts ...QueryOption) QueryAction {\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\treturn dom.RemoveAttribute(nodes[0].NodeID, name).Do(ctx)\n\t}, opts...)\n}\n\n// JavascriptAttribute is an element query action that retrieves the JavaScript\n// attribute for the first element node matching the selector.\nfunc JavascriptAttribute(sel interface{}, name string, res interface{}, opts ...QueryOption) QueryAction {\n\tif res == nil {\n\t\tpanic(\"res cannot be nil\")\n\t}\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\tif err := callFunctionOnNode(ctx, nodes[0], attributeJS, res, name); err != nil {\n\t\t\treturn fmt.Errorf(\"could not retrieve attribute %q: %w\", name, err)\n\t\t}\n\n\t\treturn nil\n\t}, opts...)\n}\n\n// SetJavascriptAttribute is an element query action that sets the JavaScript attribute\n// for the first element node matching the selector.\nfunc SetJavascriptAttribute(sel interface{}, name, value string, opts ...QueryOption) QueryAction {\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\tvar res string\n\t\terr := callFunctionOnNode(ctx, nodes[0], setAttributeJS, &res, name, value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif res != value {\n\t\t\treturn fmt.Errorf(\"could not set value on node %d\", nodes[0].NodeID)\n\t\t}\n\n\t\treturn nil\n\t}, opts...)\n}\n\n// OuterHTML is an element query action that retrieves the outer html of the first\n// element node matching the selector.\nfunc OuterHTML(sel interface{}, html *string, opts ...QueryOption) QueryAction {\n\tif html == nil {\n\t\tpanic(\"html cannot be nil\")\n\t}\n\treturn JavascriptAttribute(sel, \"outerHTML\", html, opts...)\n}\n\n// InnerHTML is an element query action that retrieves the inner html of the first\n// element node matching the selector.\nfunc InnerHTML(sel interface{}, html *string, opts ...QueryOption) QueryAction {\n\tif html == nil {\n\t\tpanic(\"html cannot be nil\")\n\t}\n\treturn JavascriptAttribute(sel, \"innerHTML\", html, opts...)\n}\n\n// Click is an element query action that sends a mouse click event to the first element\n// node matching the selector.\nfunc Click(sel interface{}, opts ...QueryOption) QueryAction {\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\treturn MouseClickNode(nodes[0]).Do(ctx)\n\t}, append(opts, NodeVisible)...)\n}\n\n// DoubleClick is an element query action that sends a mouse double click event to the\n// first element node matching the selector.\nfunc DoubleClick(sel interface{}, opts ...QueryOption) QueryAction {\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\treturn MouseClickNode(nodes[0], ClickCount(2)).Do(ctx)\n\t}, append(opts, NodeVisible)...)\n}\n\n// SendKeys is an element query action that synthesizes the key up, char, and down\n// events as needed for the runes in v, sending them to the first element node\n// matching the selector.\n//\n// See the [keys] for a complete example on how to use SendKeys.\n//\n// Note: when the element query matches an input[type=\"file\"] node, then\n// dom.SetFileInputFiles is used to set the upload path of the input node to v.\n//\n// [keys]: https://github.com/chromedp/examples/tree/master/keys\nfunc SendKeys(sel interface{}, v string, opts ...QueryOption) QueryAction {\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\tn := nodes[0]\n\n\t\t// grab type attribute from node\n\t\ttyp, attrs := \"\", n.Attributes\n\t\tn.RLock()\n\t\tfor i := 0; i < len(attrs); i += 2 {\n\t\t\tif attrs[i] == \"type\" {\n\t\t\t\ttyp = attrs[i+1]\n\t\t\t}\n\t\t}\n\t\tn.RUnlock()\n\n\t\t// when working with input[type=\"file\"], call dom.SetFileInputFiles\n\t\tif n.NodeName == \"INPUT\" && typ == \"file\" {\n\t\t\treturn dom.SetFileInputFiles([]string{v}).WithNodeID(n.NodeID).Do(ctx)\n\t\t}\n\n\t\treturn KeyEventNode(n, v).Do(ctx)\n\t}, append(opts, NodeVisible)...)\n}\n\n// SetUploadFiles is an element query action that sets the files to upload (i.e., for a\n// input[type=\"file\"] node) for the first element node matching the selector.\nfunc SetUploadFiles(sel interface{}, files []string, opts ...QueryOption) QueryAction {\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\treturn dom.SetFileInputFiles(files).WithNodeID(nodes[0].NodeID).Do(ctx)\n\t}, opts...)\n}\n\n// Submit is an element query action that submits the parent form of the first element\n// node matching the selector.\nfunc Submit(sel interface{}, opts ...QueryOption) QueryAction {\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\tvar res bool\n\t\terr := callFunctionOnNode(ctx, nodes[0], submitJS, &res)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !res {\n\t\t\treturn fmt.Errorf(\"could not call submit on node %d\", nodes[0].NodeID)\n\t\t}\n\n\t\treturn nil\n\t}, opts...)\n}\n\n// Reset is an element query action that resets the parent form of the first element\n// node matching the selector.\nfunc Reset(sel interface{}, opts ...QueryOption) QueryAction {\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\tvar res bool\n\t\terr := callFunctionOnNode(ctx, nodes[0], resetJS, &res)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !res {\n\t\t\treturn fmt.Errorf(\"could not call reset on node %d\", nodes[0].NodeID)\n\t\t}\n\n\t\treturn nil\n\t}, opts...)\n}\n\n// ComputedStyle is an element query action that retrieves the computed style of the\n// first element node matching the selector.\nfunc ComputedStyle(sel interface{}, style *[]*css.ComputedStyleProperty, opts ...QueryOption) QueryAction {\n\tif style == nil {\n\t\tpanic(\"style cannot be nil\")\n\t}\n\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\tcomputed, err := css.GetComputedStyleForNode(nodes[0].NodeID).Do(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*style = computed\n\n\t\treturn nil\n\t}, opts...)\n}\n\n// MatchedStyle is an element query action that retrieves the matched style information\n// for the first element node matching the selector.\nfunc MatchedStyle(sel interface{}, style **css.GetMatchedStylesForNodeReturns, opts ...QueryOption) QueryAction {\n\tif style == nil {\n\t\tpanic(\"style cannot be nil\")\n\t}\n\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\tvar err error\n\t\tret := &css.GetMatchedStylesForNodeReturns{}\n\t\tp := css.GetMatchedStylesForNode(nodes[0].NodeID)\n\t\terr = cdp.Execute(ctx, css.CommandGetMatchedStylesForNode, p, ret)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*style = ret\n\n\t\treturn nil\n\t}, opts...)\n}\n\n// ScrollIntoView is an element query action that scrolls the window to the\n// first element node matching the selector.\nfunc ScrollIntoView(sel interface{}, opts ...QueryOption) QueryAction {\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\n\t\treturn dom.ScrollIntoViewIfNeeded().WithNodeID(nodes[0].NodeID).Do(ctx)\n\t}, opts...)\n}\n\n// DumpTo is an element query action that writes a readable tree of the first\n// element node matching the selector and its children, up to the specified\n// depth.\n//\n// See [Dump] for a simpler interface.\nfunc DumpTo(sel interface{}, w io.Writer, prefix, indent string, nodeIDs bool, depth int64, pierce bool, wait time.Duration, opts ...QueryOption) QueryAction {\n\treturn Query(sel, append(opts,\n\t\tPopulate(depth, pierce, PopulateWait(wait)),\n\t\tAfter(func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\t\tvar n *cdp.Node\n\t\t\tif len(nodes) > 0 {\n\t\t\t\tn = nodes[0]\n\t\t\t}\n\t\t\t_, err := n.WriteTo(w, prefix, indent, nodeIDs)\n\t\t\treturn err\n\t\t}),\n\t)...)\n}\n\n// Dump is an element query action that writes a readable tree of the first\n// element node matching the selector and its children, up to the specified\n// depth.\n//\n// See [DumpTo] for more configurable options, which includes the ability to\n// set the sleep wait timeout.\nfunc Dump(sel interface{}, w io.Writer, opts ...QueryOption) QueryAction {\n\treturn DumpTo(sel, w, \"\", \"  \", false, -1, true, 80*time.Millisecond, opts...)\n}\n"
        },
        {
          "name": "query_test.go",
          "type": "blob",
          "size": 35.271484375,
          "content": "package chromedp\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/chromedp/cdproto/cdp\"\n\t\"github.com/chromedp/cdproto/css\"\n\t\"github.com/chromedp/cdproto/dom\"\n\tcdpruntime \"github.com/chromedp/cdproto/runtime\"\n\t\"github.com/chromedp/chromedp/kb\"\n)\n\nfunc TestWaitReady(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"js.html\")\n\tdefer cancel()\n\n\tvar nodeIDs []cdp.NodeID\n\tif err := Run(ctx, NodeIDs(\"#input2\", &nodeIDs, ByID)); err != nil {\n\t\tt.Fatalf(\"got error: %v\", err)\n\t}\n\tif len(nodeIDs) != 1 {\n\t\tt.Errorf(\"expected to have exactly 1 node id: got %d\", len(nodeIDs))\n\t}\n\tvar value string\n\tif err := Run(ctx,\n\t\tWaitReady(\"#input2\", ByID),\n\t\tValue(nodeIDs, &value, ByNodeID),\n\t); err != nil {\n\t\tt.Fatalf(\"got error: %v\", err)\n\t}\n}\n\nfunc TestWaitVisible(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"js.html\")\n\tdefer cancel()\n\n\tvar nodeIDs []cdp.NodeID\n\tif err := Run(ctx, NodeIDs(\"#input2\", &nodeIDs, ByID)); err != nil {\n\t\tt.Fatalf(\"got error: %v\", err)\n\t}\n\tif len(nodeIDs) != 1 {\n\t\tt.Errorf(\"expected to have exactly 1 node id: got %d\", len(nodeIDs))\n\t}\n\tvar value string\n\tif err := Run(ctx,\n\t\tWaitVisible(\"#input2\", ByID),\n\t\tValue(nodeIDs, &value, ByNodeID),\n\t); err != nil {\n\t\tt.Fatalf(\"got error: %v\", err)\n\t}\n}\n\nfunc TestWaitNotVisible(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"js.html\")\n\tdefer cancel()\n\n\tvar nodeIDs []cdp.NodeID\n\tif err := Run(ctx, NodeIDs(\"#input2\", &nodeIDs, ByID)); err != nil {\n\t\tt.Fatalf(\"got error: %v\", err)\n\t}\n\tif len(nodeIDs) != 1 {\n\t\tt.Errorf(\"expected to have exactly 1 node id: got %d\", len(nodeIDs))\n\t}\n\tvar value string\n\tif err := Run(ctx,\n\t\tClick(\"#button2\", ByID),\n\t\tWaitNotVisible(\"#input2\", ByID),\n\t\tValue(nodeIDs, &value, ByNodeID),\n\t); err != nil {\n\t\tt.Fatalf(\"got error: %v\", err)\n\t}\n}\n\nfunc TestWaitEnabled(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"js.html\")\n\tdefer cancel()\n\n\tvar attr string\n\tvar ok bool\n\tif err := Run(ctx, AttributeValue(\"#select1\", \"disabled\", &attr, &ok, ByID)); err != nil {\n\t\tt.Fatalf(\"got error: %v\", err)\n\t}\n\tif !ok {\n\t\tt.Fatal(\"expected element to be disabled\")\n\t}\n\tif err := Run(ctx,\n\t\tClick(\"#button3\", ByID),\n\t\tWaitEnabled(\"#select1\", ByID),\n\t\tAttributeValue(\"#select1\", \"disabled\", &attr, &ok, ByID),\n\t); err != nil {\n\t\tt.Fatalf(\"got error: %v\", err)\n\t}\n\tif ok {\n\t\tt.Fatal(\"expected element to be enabled\")\n\t}\n\tvar value string\n\tif err := Run(ctx,\n\t\tSetAttributeValue(`//*[@id=\"select1\"]/option[1]`, \"selected\", \"true\"),\n\t\tValue(\"#select1\", &value, ByID),\n\t); err != nil {\n\t\tt.Fatalf(\"got error: %v\", err)\n\t}\n\n\tif value != \"foo\" {\n\t\tt.Fatalf(\"expected value to be foo, got: %s\", value)\n\t}\n}\n\nfunc TestWaitSelected(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"js.html\")\n\tdefer cancel()\n\n\tif err := Run(ctx,\n\t\tClick(\"#button3\", ByID),\n\t\tWaitEnabled(\"#select1\", ByID),\n\t); err != nil {\n\t\tt.Fatalf(\"got error: %v\", err)\n\t}\n\n\tvar attr string\n\tok := false\n\tif err := Run(ctx, AttributeValue(`//*[@id=\"select1\"]/option[1]`, \"selected\", &attr, &ok)); err != nil {\n\t\tt.Fatalf(\"got error: %v\", err)\n\t}\n\tif ok {\n\t\tt.Fatal(\"expected element to be not selected\")\n\t}\n\tif err := Run(ctx,\n\t\tSetAttributeValue(`//*[@id=\"select1\"]/option[1]`, \"selected\", \"true\"),\n\t\tWaitSelected(`//*[@id=\"select1\"]/option[1]`),\n\t\tAttributeValue(`//*[@id=\"select1\"]/option[1]`, \"selected\", &attr, nil),\n\t); err != nil {\n\t\tt.Fatalf(\"got error: %v\", err)\n\t}\n\n\tif attr != \"true\" {\n\t\tt.Fatal(\"expected element to be selected\")\n\t}\n}\n\nfunc TestWaitNotPresent(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"js.html\")\n\tdefer cancel()\n\n\tif err := Run(ctx,\n\t\tWaitVisible(\"#input3\", ByID),\n\t\tClick(\"#button4\", ByID),\n\t\tWaitNotPresent(\"#input3\", ByID),\n\t); err != nil {\n\t\tt.Fatalf(\"got error: %v\", err)\n\t}\n}\n\nfunc TestAtLeast(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"js.html\")\n\tdefer cancel()\n\n\tvar nodes []*cdp.Node\n\tif err := Run(ctx, Nodes(\"//input\", &nodes, AtLeast(3))); err != nil {\n\t\tt.Fatalf(\"got error: %v\", err)\n\t}\n\tif len(nodes) < 3 {\n\t\tt.Errorf(\"expected to have at least 3 nodes: got %d\", len(nodes))\n\t}\n}\n\nfunc TestRetryInterval(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname         string\n\t\topts         []QueryOption\n\t\twantCountMin int\n\t\twantCountMax int\n\t}{\n\t\t{\n\t\t\tname: \"default\",\n\t\t\topts: []QueryOption{},\n\t\t\t// in 100ms\n\t\t\twantCountMin: 5,\n\t\t\twantCountMax: 20,\n\t\t},\n\t\t{\n\t\t\tname: \"large interval\",\n\t\t\topts: []QueryOption{RetryInterval(60 * time.Millisecond)},\n\t\t\t// in 100ms\n\t\t\twantCountMin: 1,\n\t\t\twantCountMax: 2,\n\t\t},\n\t}\n\n\tctx, cancel := testAllocate(t, \"js.html\")\n\tdefer cancel()\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tretryCount := 0\n\n\t\t\t// count is a wait function that makes the query always fail and\n\t\t\t// counts the number of retries. Note that the wait func is called\n\t\t\t// only after the number of result nodes >= s.exp .\n\t\t\tcount := WaitFunc(\n\t\t\t\tfunc(ctx context.Context, f *cdp.Frame, eci cdpruntime.ExecutionContextID, ni ...cdp.NodeID) ([]*cdp.Node, error) {\n\t\t\t\t\tretryCount++\n\t\t\t\t\treturn nil, ErrInvalidTarget\n\t\t\t\t},\n\t\t\t)\n\n\t\t\tctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)\n\t\t\tdefer cancel()\n\n\t\t\topts := append(tc.opts, count)\n\t\t\terr := Run(ctx, Query(\"//input\", opts...))\n\n\t\t\tif err == nil || !errors.Is(err, context.DeadlineExceeded) {\n\t\t\t\tt.Fatalf(\"want error context.DeadlineExceeded, got: %v\", err)\n\t\t\t}\n\t\t\tif retryCount < tc.wantCountMin {\n\t\t\t\tt.Fatalf(\"want retry count > %d, got: %d\", tc.wantCountMin, retryCount)\n\t\t\t}\n\t\t\tif retryCount > tc.wantCountMax {\n\t\t\t\tt.Fatalf(\"want retry count < %d, got: %d\", tc.wantCountMax, retryCount)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNoRetryForInvalidSelector(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"table.html\")\n\tdefer cancel()\n\n\tctx, cancel = context.WithTimeout(ctx, time.Second)\n\tdefer cancel()\n\n\ttests := []struct {\n\t\tname    string\n\t\tsel     string\n\t\tby      QueryOption\n\t\twantErr string\n\t}{\n\t\t{`pseudo class`, `#a:b`, ByQuery, \"DOM Error while querying (-32000)\"},\n\t\t{`leading number`, `#3`, ByQuery, \"DOM Error while querying (-32000)\"},\n\t\t{`empty selector`, ``, ByQuery, \"DOM Error while querying (-32000)\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar nodes []*cdp.Node\n\t\t\tif err := Run(ctx, Nodes(test.sel, &nodes, test.by)); err.Error() != test.wantErr {\n\t\t\t\tt.Fatalf(\"want error %v, got error: %v\", test.wantErr, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestByJSPath(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"image2.html\")\n\tdefer cancel()\n\n\t// check nodes == 1\n\tvar nodes []*cdp.Node\n\tif err := Run(ctx,\n\t\tNodes(`document.querySelector('#imagething').shadowRoot.querySelector('.container')`, &nodes, ByJSPath),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(nodes) != 1 {\n\t\tt.Errorf(\"expected nodes to have len 1, got: %d\", len(nodes))\n\t}\n\n\t// check class\n\tclass := nodes[0].AttributeValue(\"class\")\n\tif class != \"container\" {\n\t\tt.Errorf(\"expected class to be 'container', got: %q\", class)\n\t}\n}\n\nfunc TestNodes(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"table.html\")\n\tdefer cancel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t\tn   int\n\t}{\n\t\t{`/html/body/table/tbody[1]/tr[2]/td`, BySearch, 3},\n\t\t{`body > table > tbody:nth-child(2) > tr:nth-child(2) > td:not(:last-child)`, ByQueryAll, 2},\n\t\t{`body > table > tbody:nth-child(2) > tr:nth-child(2) > td`, ByQuery, 1},\n\t\t{`#footer`, ByID, 1},\n\t\t{`document.querySelector(\"body > table > tbody:nth-child(2) > tr:nth-child(2) > td:nth-child(1)\")`, ByJSPath, 1},\n\t}\n\n\tfor i, test := range tests {\n\t\tvar nodes []*cdp.Node\n\t\tif err := Run(ctx, Nodes(test.sel, &nodes, test.by)); err != nil {\n\t\t\tt.Fatalf(\"test %d got error: %v\", i, err)\n\t\t}\n\n\t\tif len(nodes) != test.n {\n\t\t\tt.Errorf(\"test %d expected to have %d nodes: got %d\", i, test.n, len(nodes))\n\t\t}\n\t}\n}\n\nfunc TestNodeIDs(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"table.html\")\n\tdefer cancel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t\tn   int\n\t}{\n\t\t{`/html/body/table/tbody[1]/tr[2]/td`, BySearch, 3},\n\t\t{`body > table > tbody:nth-child(2) > tr:nth-child(2) > td:not(:last-child)`, ByQueryAll, 2},\n\t\t{`body > table > tbody:nth-child(2) > tr:nth-child(2) > td`, ByQuery, 1},\n\t\t{`#footer`, ByID, 1},\n\t\t{`document.querySelector(\"body > table > tbody:nth-child(2) > tr:nth-child(2) > td:nth-child(1)\")`, ByJSPath, 1},\n\t}\n\n\tfor i, test := range tests {\n\t\tvar ids []cdp.NodeID\n\t\tif err := Run(ctx, NodeIDs(test.sel, &ids, test.by)); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif len(ids) != test.n {\n\t\t\tt.Errorf(\"test %d expected to have %d node id's: got %d\", i, test.n, len(ids))\n\t\t}\n\t}\n}\n\nfunc TestFocusBlur(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"js.html\")\n\tdefer cancel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t}{\n\t\t{`//*[@id=\"input1\"]`, BySearch},\n\t\t{`body > input[type=\"number\"]:nth-child(1)`, ByQueryAll},\n\t\t{`body > input[type=\"number\"]:nth-child(1)`, ByQuery},\n\t\t{`#input1`, ByID},\n\t\t{`document.querySelector(\"#input1\")`, ByJSPath},\n\t}\n\n\tif err := Run(ctx, Click(\"#input1\", ByID)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor i, test := range tests {\n\t\tvar value string\n\t\tif err := Run(ctx,\n\t\t\tFocus(test.sel, test.by),\n\t\t\tValue(test.sel, &value, test.by),\n\t\t); err != nil {\n\t\t\tt.Fatalf(\"test %d got error: %v\", i, err)\n\t\t}\n\n\t\tif value != \"9999\" {\n\t\t\tt.Errorf(\"test %d expected value is '9999', got: %q\", i, value)\n\t\t}\n\t\tif err := Run(ctx,\n\t\t\tBlur(test.sel, test.by),\n\t\t\tValue(test.sel, &value, test.by),\n\t\t); err != nil {\n\t\t\tt.Fatalf(\"test %d got error: %v\", i, err)\n\t\t}\n\n\t\tif value != \"0\" {\n\t\t\tt.Errorf(\"test %d expected value is '0', got: %q\", i, value)\n\t\t}\n\t}\n}\n\nfunc TestDimensions(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"image.html\")\n\tdefer cancel()\n\n\ttests := []struct {\n\t\tsel    string\n\t\tby     QueryOption\n\t\twidth  int64\n\t\theight int64\n\t}{\n\t\t{`/html/body/img`, BySearch, 239, 239},\n\t\t{`img`, ByQueryAll, 239, 239},\n\t\t{`img`, ByQuery, 239, 239},\n\t\t{`#icon-github`, ByID, 120, 120},\n\t\t{`document.querySelector(\"#icon-github\")`, ByJSPath, 120, 120},\n\t}\n\n\tfor i, test := range tests {\n\t\tvar model *dom.BoxModel\n\t\tif err := Run(ctx, Dimensions(test.sel, &model, test.by)); err != nil {\n\t\t\tt.Fatalf(\"test %d got error: %v\", i, err)\n\t\t}\n\n\t\tif model.Height != test.height || model.Width != test.width {\n\t\t\tt.Errorf(\"test %d expected %dx%d, got: %dx%d\", i, test.width, test.height, model.Height, model.Width)\n\t\t}\n\t}\n}\n\nfunc TestText(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"form.html\")\n\tdefer cancel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t\texp string\n\t}{\n\t\t{\"#foo\", ByID, \"insert\"},\n\t\t{\"body > form > span\", ByQueryAll, \"insert\"},\n\t\t{\"body > form > span:nth-child(2)\", ByQuery, \"keyword\"},\n\t\t{\"/html/body/form/span[2]\", BySearch, \"keyword\"},\n\t\t{`document.querySelector(\"#form > span:nth-child(2)\")`, ByJSPath, \"keyword\"},\n\t\t{\"#inner-hidden\", ByID, \"this is\"},\n\t\t{\"#hidden\", ByID, \"\"},\n\t}\n\n\tfor i, test := range tests {\n\t\tvar text string\n\t\tif err := Run(ctx, Text(test.sel, &text, test.by)); err != nil {\n\t\t\tt.Fatalf(\"test %d got error: %v\", i, err)\n\t\t}\n\n\t\tif text != test.exp {\n\t\t\tt.Errorf(\"test %d expected %q, got: %s\", i, test.exp, text)\n\t\t}\n\t}\n}\n\nfunc TestTextContent(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"form.html\")\n\tdefer cancel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t\texp string\n\t}{\n\t\t{\"#inner-hidden\", ByID, \"this is hidden\"},\n\t\t{\"#hidden\", ByID, \"hidden\"},\n\t}\n\n\tfor i, test := range tests {\n\t\tvar text string\n\t\tif err := Run(ctx, TextContent(test.sel, &text, test.by)); err != nil {\n\t\t\tt.Fatalf(\"test %d got error: %v\", i, err)\n\t\t}\n\n\t\tif text != test.exp {\n\t\t\tt.Errorf(\"test %d expected %q, got: %s\", i, test.exp, text)\n\t\t}\n\t}\n}\n\nfunc TestClear(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t}{\n\t\t// input fields\n\t\t{`//*[@id=\"form\"]/input[1]`, BySearch},\n\t\t{`#form > input[type=\"text\"]:nth-child(4)`, ByQuery},\n\t\t{`#form > input[type=\"text\"]`, ByQueryAll},\n\t\t{`#keyword`, ByID},\n\t\t{`document.querySelector(\"#keyword\")`, ByJSPath},\n\n\t\t// textarea fields\n\t\t{`//*[@id=\"bar\"]`, BySearch},\n\t\t{`#form > textarea`, ByQuery},\n\t\t{`#form > textarea`, ByQueryAll},\n\t\t{`#bar`, ByID},\n\n\t\t// input + textarea fields\n\t\t{`//*[@id=\"form\"]/input`, BySearch},\n\t\t{`#form > input[type=\"text\"]`, ByQueryAll},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(fmt.Sprintf(\"%02d\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := testAllocate(t, \"form.html\")\n\t\t\tdefer cancel()\n\n\t\t\tvar val string\n\t\t\tif err := Run(ctx, Value(test.sel, &val, test.by)); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\t\t\tif val == \"\" {\n\t\t\t\tt.Errorf(\"expected %q to have non empty value\", test.sel)\n\t\t\t}\n\t\t\tif err := Run(ctx,\n\t\t\t\tClear(test.sel, test.by),\n\t\t\t\tValue(test.sel, &val, test.by),\n\t\t\t); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\t\t\tif val != \"\" {\n\t\t\t\tt.Errorf(\"expected empty value for %q, got: %s\", test.sel, val)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReset(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tsel   string\n\t\tby    QueryOption\n\t\tvalue string\n\t\texp   string\n\t}{\n\t\t{`//*[@id=\"keyword\"]`, BySearch, \"foobar\", \"chromedp\"},\n\t\t{`#form > input[type=\"text\"]:nth-child(6)`, ByQuery, \"foobar\", \"foo\"},\n\t\t{`#form > input[type=\"text\"]`, ByQueryAll, \"foobar\", \"chromedp\"},\n\t\t{\"#bar\", ByID, \"foobar\", \"bar\"},\n\t\t{`document.querySelector(\"#bar\")`, ByJSPath, \"foobar\", \"bar\"},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(fmt.Sprintf(\"%02d\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := testAllocate(t, \"form.html\")\n\t\t\tdefer cancel()\n\n\t\t\tvar value string\n\t\t\tif err := Run(ctx,\n\t\t\t\tSetValue(test.sel, test.value, test.by),\n\t\t\t\tReset(test.sel, test.by),\n\t\t\t\tValue(test.sel, &value, test.by),\n\t\t\t); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\tif value != test.exp {\n\t\t\t\tt.Errorf(\"expected value after reset is %s, got: %q\", test.exp, value)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValue(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"form.html\")\n\tdefer cancel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t}{\n\t\t{`//*[@id=\"form\"]/input[1]`, BySearch},\n\t\t{`#form > input[type=\"text\"]:nth-child(4)`, ByQuery},\n\t\t{`#form > input[type=\"text\"]`, ByQueryAll},\n\t\t{`#keyword`, ByID},\n\t\t{`document.querySelector(\"#keyword\")`, ByJSPath},\n\t}\n\n\tfor i, test := range tests {\n\t\tvar value string\n\t\tif err := Run(ctx, Value(test.sel, &value, test.by)); err != nil {\n\t\t\tt.Fatalf(\"test %d got error: %v\", i, err)\n\t\t}\n\n\t\tif value != \"chromedp\" {\n\t\t\tt.Errorf(\"test %d expected `chromedp`, got: %s\", i, value)\n\t\t}\n\t}\n}\n\nfunc TestValueUndefined(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"form.html\")\n\tdefer cancel()\n\n\tvar value string\n\terr := Run(ctx, Value(\"foo\", &value, ByID))\n\twant := `could not retrieve attribute \"value\": encountered an undefined value`\n\tgot := fmt.Sprint(err)\n\tif !strings.Contains(got, want) {\n\t\tt.Fatalf(\"want error %q, got %q\", want, got)\n\t}\n}\n\nfunc TestSetValue(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t}{\n\t\t{`//*[@id=\"form\"]/input[1]`, BySearch},\n\t\t{`#form > input[type=\"text\"]:nth-child(4)`, ByQuery},\n\t\t{`#form > input[type=\"text\"]`, ByQueryAll},\n\t\t{`#bar`, ByID},\n\t\t{`document.querySelector(\"#bar\")`, ByJSPath},\n\t\t{`#select`, ByQuery},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(fmt.Sprintf(\"%02d\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := testAllocate(t, \"form.html\")\n\t\t\tdefer cancel()\n\n\t\t\tvar value string\n\t\t\tif err := Run(ctx,\n\t\t\t\tSetValue(test.sel, \"FOOBAR\", test.by),\n\t\t\t\tValue(test.sel, &value, test.by),\n\t\t\t); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\tif value != \"FOOBAR\" {\n\t\t\t\tt.Errorf(\"expected `FOOBAR`, got: %s\", value)\n\t\t\t}\n\n\t\t\tctx, cancel = context.WithTimeout(ctx, 2*time.Second)\n\t\t\tdefer cancel()\n\t\t\tif err := Run(ctx,\n\t\t\t\tWaitVisible(\"#event-input\", ByQuery),\n\t\t\t\tWaitVisible(\"#event-change\", ByQuery),\n\t\t\t); err != nil {\n\t\t\t\tif errors.Is(err, context.DeadlineExceeded) {\n\t\t\t\t\tt.Fatal(\"input and/or change events not fired\")\n\t\t\t\t} else {\n\t\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAttributes(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"image.html\")\n\tdefer cancel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t\texp map[string]string\n\t}{\n\t\t{\n\t\t\t`//*[@id=\"icon-brankas\"]`, BySearch,\n\t\t\tmap[string]string{\n\t\t\t\t\"alt\": \"Brankas - Easy Money Management\",\n\t\t\t\t\"id\":  \"icon-brankas\",\n\t\t\t\t\"src\": \"images/brankas.png\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t`body > img:first-child`, ByQuery,\n\t\t\tmap[string]string{\n\t\t\t\t\"alt\": \"Brankas - Easy Money Management\",\n\t\t\t\t\"id\":  \"icon-brankas\",\n\t\t\t\t\"src\": \"images/brankas.png\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t`body > img:nth-child(2)`, ByQueryAll,\n\t\t\tmap[string]string{\n\t\t\t\t\"alt\": `How people build software`,\n\t\t\t\t\"id\":  \"icon-github\",\n\t\t\t\t\"src\": \"images/github.png\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t`#icon-github`, ByID,\n\t\t\tmap[string]string{\n\t\t\t\t\"alt\": \"How people build software\",\n\t\t\t\t\"id\":  \"icon-github\",\n\t\t\t\t\"src\": \"images/github.png\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t`document.querySelector(\"#icon-github\")`, ByJSPath,\n\t\t\tmap[string]string{\n\t\t\t\t\"alt\": \"How people build software\",\n\t\t\t\t\"id\":  \"icon-github\",\n\t\t\t\t\"src\": \"images/github.png\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tvar attrs map[string]string\n\t\tif err := Run(ctx, Attributes(test.sel, &attrs, test.by)); err != nil {\n\t\t\tt.Fatalf(\"test %d got error: %v\", i, err)\n\t\t}\n\n\t\tif !reflect.DeepEqual(test.exp, attrs) {\n\t\t\tt.Errorf(\"test %d expected %v, got: %v\", i, test.exp, attrs)\n\t\t}\n\t}\n}\n\nfunc TestAttributesAll(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"image.html\")\n\tdefer cancel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t\texp []map[string]string\n\t}{\n\t\t{\n\t\t\t\"img\", ByQueryAll,\n\t\t\t[]map[string]string{\n\t\t\t\t{\n\t\t\t\t\t\"alt\": \"Brankas - Easy Money Management\",\n\t\t\t\t\t\"id\":  \"icon-brankas\",\n\t\t\t\t\t\"src\": \"images/brankas.png\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"alt\": \"How people build software\",\n\t\t\t\t\t\"id\":  \"icon-github\",\n\t\t\t\t\t\"src\": \"images/github.png\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tvar attrs []map[string]string\n\t\tif err := Run(ctx, AttributesAll(test.sel, &attrs, test.by)); err != nil {\n\t\t\tt.Fatalf(\"test %d got error: %v\", i, err)\n\t\t}\n\n\t\tif !reflect.DeepEqual(test.exp, attrs) {\n\t\t\tt.Errorf(\"test %d expected %v, got: %v\", i, test.exp, attrs)\n\t\t}\n\t}\n}\n\nfunc TestSetAttributes(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tsel   string\n\t\tby    QueryOption\n\t\tattrs map[string]string\n\t\texp   map[string]string\n\t}{\n\t\t{\n\t\t\t`//*[@id=\"icon-brankas\"]`, BySearch,\n\t\t\tmap[string]string{\"data-url\": \"brankas\"},\n\t\t\tmap[string]string{\n\t\t\t\t\"alt\":      \"Brankas - Easy Money Management\",\n\t\t\t\t\"id\":       \"icon-brankas\",\n\t\t\t\t\"src\":      \"images/brankas.png\",\n\t\t\t\t\"data-url\": \"brankas\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t`body > img:first-child`, ByQuery,\n\t\t\tmap[string]string{\"data-url\": \"brankas\"},\n\t\t\tmap[string]string{\n\t\t\t\t\"alt\":      \"Brankas - Easy Money Management\",\n\t\t\t\t\"id\":       \"icon-brankas\",\n\t\t\t\t\"src\":      \"images/brankas.png\",\n\t\t\t\t\"data-url\": \"brankas\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t`body > img:nth-child(2)`, ByQueryAll,\n\t\t\tmap[string]string{\"width\": \"100\", \"height\": \"200\"},\n\t\t\tmap[string]string{\n\t\t\t\t\"alt\":    `How people build software`,\n\t\t\t\t\"id\":     \"icon-github\",\n\t\t\t\t\"src\":    \"images/github.png\",\n\t\t\t\t\"width\":  \"100\",\n\t\t\t\t\"height\": \"200\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t`#icon-github`, ByID,\n\t\t\tmap[string]string{\"width\": \"100\", \"height\": \"200\"},\n\t\t\tmap[string]string{\n\t\t\t\t\"alt\":    \"How people build software\",\n\t\t\t\t\"id\":     \"icon-github\",\n\t\t\t\t\"src\":    \"images/github.png\",\n\t\t\t\t\"width\":  \"100\",\n\t\t\t\t\"height\": \"200\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t`document.querySelector(\"#icon-github\")`, ByJSPath,\n\t\t\tmap[string]string{\"width\": \"100\", \"height\": \"200\"},\n\t\t\tmap[string]string{\n\t\t\t\t\"alt\":    \"How people build software\",\n\t\t\t\t\"id\":     \"icon-github\",\n\t\t\t\t\"src\":    \"images/github.png\",\n\t\t\t\t\"width\":  \"100\",\n\t\t\t\t\"height\": \"200\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(fmt.Sprintf(\"%02d\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := testAllocate(t, \"image.html\")\n\t\t\tdefer cancel()\n\n\t\t\tif err := Run(ctx, SetAttributes(test.sel, test.attrs, test.by)); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\t// TODO: figure why this test is flaky without this\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\n\t\t\tvar attrs map[string]string\n\t\t\tif err := Run(ctx, Attributes(test.sel, &attrs, test.by)); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(test.exp, attrs) {\n\t\t\t\tt.Errorf(\"expected %v, got: %v\", test.exp, attrs)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAttributeValue(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"image.html\")\n\tdefer cancel()\n\n\ttests := []struct {\n\t\tsel  string\n\t\tby   QueryOption\n\t\tattr string\n\t\texp  string\n\t}{\n\t\t{`//*[@id=\"icon-brankas\"]`, BySearch, \"alt\", \"Brankas - Easy Money Management\"},\n\t\t{`body > img:first-child`, ByQuery, \"alt\", \"Brankas - Easy Money Management\"},\n\t\t{`body > img:nth-child(2)`, ByQueryAll, \"alt\", \"How people build software\"},\n\t\t{`#icon-github`, ByID, \"alt\", \"How people build software\"},\n\t\t{`document.querySelector('#icon-github')`, ByJSPath, \"alt\", \"How people build software\"},\n\t}\n\n\tfor i, test := range tests {\n\t\tvar value string\n\t\tvar ok bool\n\t\tif err := Run(ctx, AttributeValue(test.sel, test.attr, &value, &ok, test.by)); err != nil {\n\t\t\tt.Fatalf(\"test %d got error: %v\", i, err)\n\t\t}\n\t\tif !ok {\n\t\t\tt.Fatalf(\"test %d failed to get attribute %s on %s\", i, test.attr, test.sel)\n\t\t}\n\t\tif value != test.exp {\n\t\t\tt.Errorf(\"test %d expected %s to be %s, got: %s\", i, test.attr, test.exp, value)\n\t\t}\n\t}\n}\n\nfunc TestSetAttributeValue(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tsel  string\n\t\tby   QueryOption\n\t\tattr string\n\t\texp  string\n\t}{\n\t\t{`//*[@id=\"keyword\"]`, BySearch, \"foo\", \"bar\"},\n\t\t{`#form > input[type=\"text\"]:nth-child(6)`, ByQuery, \"foo\", \"bar\"},\n\t\t{`#form > input[type=\"text\"]`, ByQueryAll, \"foo\", \"bar\"},\n\t\t{`#bar`, ByID, \"foo\", \"bar\"},\n\t\t{`document.querySelector('#bar')`, ByJSPath, \"foo\", \"bar\"},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(fmt.Sprintf(\"%02d\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := testAllocate(t, \"form.html\")\n\t\t\tdefer cancel()\n\n\t\t\tif err := Run(ctx, SetAttributeValue(test.sel, test.attr, test.exp, test.by)); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\t// TODO: figure why this test is flaky without this\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\n\t\t\tvar value string\n\t\t\tvar ok bool\n\t\t\tif err := Run(ctx, AttributeValue(test.sel, test.attr, &value, &ok, test.by)); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"failed to get attribute %s on %s\", test.attr, test.sel)\n\t\t\t}\n\t\t\tif value != test.exp {\n\t\t\t\tt.Errorf(\"expected %s to be %s, got: %s\", test.attr, test.exp, value)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRemoveAttribute(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tsel  string\n\t\tby   QueryOption\n\t\tattr string\n\t}{\n\t\t{`/html/body/img`, BySearch, \"alt\"},\n\t\t{`img`, ByQueryAll, \"alt\"},\n\t\t{`img`, ByQuery, \"alt\"},\n\t\t{`#icon-github`, ByID, \"alt\"},\n\t\t{`document.querySelector('#icon-github')`, ByJSPath, \"alt\"},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(fmt.Sprintf(\"%02d\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := testAllocate(t, \"image.html\")\n\t\t\tdefer cancel()\n\n\t\t\tif err := Run(ctx, RemoveAttribute(test.sel, test.attr, test.by)); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\t// TODO: figure why this test is flaky without this\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\n\t\t\tvar value string\n\t\t\tvar ok bool\n\t\t\tif err := Run(ctx, AttributeValue(test.sel, test.attr, &value, &ok, test.by)); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\t\t\tif ok || value != \"\" {\n\t\t\t\tt.Fatalf(\"expected attribute %s removed from element %s\", test.attr, test.sel)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestClick(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t}{\n\t\t{`//*[@id=\"form\"]/input[4]`, BySearch},\n\t\t{`#form > input[type=\"submit\"]:nth-child(11)`, ByQuery},\n\t\t{`#form > input[type=\"submit\"]:nth-child(11)`, ByQueryAll},\n\t\t{`#btn2`, ByID},\n\t\t{`document.querySelector('#btn2')`, ByJSPath},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(fmt.Sprintf(\"%02d\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := testAllocate(t, \"form.html\")\n\t\t\tdefer cancel()\n\n\t\t\tvar title string\n\t\t\tif err := Run(ctx,\n\t\t\t\tClick(test.sel, test.by),\n\t\t\t\tWaitVisible(\"#icon-brankas\", ByID),\n\t\t\t\tTitle(&title),\n\t\t\t); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\tif title != \"this is title\" {\n\t\t\t\tt.Errorf(\"expected title to be 'chromedp - Google Search', got: %q\", title)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDoubleClick(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t}{\n\t\t{`/html/body/input[2]`, BySearch},\n\t\t{`body > input[type=\"button\"]:nth-child(2)`, ByQueryAll},\n\t\t{`body > input[type=\"button\"]:nth-child(2)`, ByQuery},\n\t\t{`#button1`, ByID},\n\t\t{`document.querySelector('#button1')`, ByJSPath},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(fmt.Sprintf(\"%02d\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := testAllocate(t, \"js.html\")\n\t\t\tdefer cancel()\n\n\t\t\tvar value string\n\t\t\tif err := Run(ctx,\n\t\t\t\tDoubleClick(test.sel, test.by),\n\t\t\t\tValue(\"#input1\", &value, ByID),\n\t\t\t); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\tif value != \"1\" {\n\t\t\t\tt.Errorf(\"expected value to be '1', got: %q\", value)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSendKeys(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tsel  string\n\t\tby   QueryOption\n\t\tkeys string\n\t\texp  string\n\t}{\n\t\t{`//*[@id=\"input1\"]`, BySearch, \"INSERT \", \"INSERT some value\"}, // 0\n\t\t{`#box4 > input:nth-child(1)`, ByQuery, \"insert \", \"insert some value\"},\n\t\t{`#box4 > textarea`, ByQueryAll, \"prefix \" + kb.End + \"\\b\\b SUFFIX\\n\", \"prefix textar SUFFIX\\n\"},\n\t\t{`#textarea1`, ByID, \"insert \", \"insert textarea\"},\n\t\t{`#textarea1`, ByID, kb.End + \"\\b\\b\\n\\naoeu\\n\\nfoo\\n\\nbar\\n\\n\", \"textar\\n\\naoeu\\n\\nfoo\\n\\nbar\\n\\n\"},\n\t\t{`#select1`, ByID, kb.ArrowDown + kb.ArrowDown, \"three\"}, // 5\n\t\t{`document.querySelector('#textarea1')`, ByJSPath, \"insert \", \"insert textarea\"},\n\t}\n\n\tfor i, test := range tests {\n\t\ti, test := i, test\n\t\tt.Run(fmt.Sprintf(\"%02d\", i), func(t *testing.T) {\n\t\t\tif runtime.GOOS == \"darwin\" && i == 5 {\n\t\t\t\tt.Skipf(\"skipping test %d on darwin -- FIXME!\", i)\n\t\t\t}\n\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := testAllocate(t, \"visible.html\")\n\t\t\tdefer cancel()\n\n\t\t\tvar val string\n\t\t\tif err := Run(ctx,\n\t\t\t\tSendKeys(test.sel, test.keys, test.by),\n\t\t\t\tValue(test.sel, &val, test.by),\n\t\t\t); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\tif val != test.exp {\n\t\t\t\tt.Errorf(\"expected value %s, got: %s\", test.exp, val)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSubmit(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t}{\n\t\t{`//*[@id=\"keyword\"]`, BySearch},\n\t\t{`#form > input[type=\"text\"]:nth-child(4)`, ByQuery},\n\t\t{`#form > input[type=\"text\"]`, ByQueryAll},\n\t\t{`#form`, ByID},\n\t\t{`document.querySelector('#form')`, ByJSPath},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(fmt.Sprintf(\"%02d\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := testAllocate(t, \"form.html\")\n\t\t\tdefer cancel()\n\n\t\t\tvar title string\n\t\t\tif err := Run(ctx,\n\t\t\t\tSubmit(test.sel, test.by),\n\t\t\t\tWaitVisible(\"#icon-brankas\", ByID),\n\t\t\t\tTitle(&title),\n\t\t\t); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\tif title != \"this is title\" {\n\t\t\t\tt.Errorf(\"expected title to be 'this is title', got: %q\", title)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestComputedStyle(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t}{\n\t\t{`//*[@id=\"input1\"]`, BySearch},\n\t\t{`body > input[type=\"number\"]:nth-child(1)`, ByQueryAll},\n\t\t{`body > input[type=\"number\"]:nth-child(1)`, ByQuery},\n\t\t{`#input1`, ByID},\n\t\t{`document.querySelector('#input1')`, ByJSPath},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(fmt.Sprintf(\"%02d\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := testAllocate(t, \"js.html\")\n\t\t\tdefer cancel()\n\n\t\t\tvar styles []*css.ComputedStyleProperty\n\t\t\tif err := Run(ctx, ComputedStyle(test.sel, &styles, test.by)); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\tfor _, style := range styles {\n\t\t\t\tif style.Name == \"background-color\" {\n\t\t\t\t\tif style.Value != \"rgb(255, 0, 0)\" {\n\t\t\t\t\t\tt.Logf(\"expected style 'rgb(255, 0, 0)' got: %s\", style.Value)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := Run(ctx,\n\t\t\t\tClick(\"#input1\", ByID),\n\t\t\t\tComputedStyle(test.sel, &styles, test.by),\n\t\t\t); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\tfor _, style := range styles {\n\t\t\t\tif style.Name == \"background-color\" {\n\t\t\t\t\tif style.Value != \"rgb(255, 255, 0)\" {\n\t\t\t\t\t\tt.Fatalf(\"expected style 'rgb(255, 255, 0)' got: %s\", style.Value)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMatchedStyle(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t}{\n\t\t{`//*[@id=\"input1\"]`, BySearch},\n\t\t{`body > input[type=\"number\"]:nth-child(1)`, ByQueryAll},\n\t\t{`body > input[type=\"number\"]:nth-child(1)`, ByQuery},\n\t\t{`#input1`, ByID},\n\t\t{`document.querySelector('#input1')`, ByJSPath},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(fmt.Sprintf(\"%02d\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := testAllocate(t, \"js.html\")\n\t\t\tdefer cancel()\n\n\t\t\tvar styles *css.GetMatchedStylesForNodeReturns\n\t\t\tif err := Run(ctx, MatchedStyle(test.sel, &styles, test.by)); err != nil {\n\t\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t\t}\n\n\t\t\t// TODO: Add logic to check if the style returned is true and valid.\n\t\t})\n\t}\n}\n\nfunc TestFileUpload(t *testing.T) {\n\tt.Parallel()\n\n\t// create test server\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tfmt.Fprintf(res, \"%s\", uploadHTML)\n\t})\n\tmux.HandleFunc(\"/upload\", func(res http.ResponseWriter, req *http.Request) {\n\t\tf, _, err := req.FormFile(\"upload\")\n\t\tif err != nil {\n\t\t\thttp.Error(res, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\tdefer f.Close()\n\n\t\tbuf, err := io.ReadAll(f)\n\t\tif err != nil {\n\t\t\thttp.Error(res, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Fprintf(res, resultHTML, len(buf))\n\t})\n\ts := httptest.NewServer(mux)\n\tdefer s.Close()\n\n\tuploadFile := filepath.Join(t.TempDir(), \"chromedp-upload-test\")\n\tif err := os.WriteFile(uploadFile, []byte(uploadHTML), 0o666); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttests := []struct {\n\t\ta Action\n\t}{\n\t\t{SendKeys(`input[name=\"upload\"]`, uploadFile, NodeVisible)},\n\t\t{SetUploadFiles(`input[name=\"upload\"]`, []string{uploadFile}, NodeVisible)},\n\t}\n\n\t// Don't run these tests in parallel. The only way to do so would be to\n\t// fire a separate httptest server and tmpfile for each. There's no way\n\t// to share these resources easily among parallel subtests, as the\n\t// parent must finish for the children to run, made impossible by the\n\t// defers above.\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%02d\", i), func(t *testing.T) {\n\t\t\tctx, cancel := testAllocate(t, \"\")\n\t\t\tdefer cancel()\n\n\t\t\tvar result string\n\t\t\tif err := Run(ctx,\n\t\t\t\tNavigate(s.URL),\n\t\t\t\ttest.a,\n\t\t\t\tClick(`input[name=\"submit\"]`),\n\t\t\t\tText(`#result`, &result, ByID, NodeVisible),\n\t\t\t); err != nil {\n\t\t\t\tt.Fatalf(\"test %d expected no error, got: %v\", i, err)\n\t\t\t}\n\n\t\t\tif result != fmt.Sprintf(\"%d\", len(uploadHTML)) {\n\t\t\t\tt.Errorf(\"test %d expected result to be %d, got: %s\", i, len(uploadHTML), result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestInnerHTML(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"table.html\")\n\tdefer cancel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t}{\n\t\t{`/html/body/table/thead`, BySearch},\n\t\t{`thead`, ByQueryAll},\n\t\t{`thead`, ByQuery},\n\t\t{`document.querySelector(\"#footer > td:nth-child(2)\")`, ByJSPath},\n\t}\n\tfor i, test := range tests {\n\t\tvar html string\n\t\tif err := Run(ctx, InnerHTML(test.sel, &html, test.by)); err != nil {\n\t\t\tt.Fatalf(\"test %d got error: %v\", i, err)\n\t\t}\n\n\t\tif html == \"\" {\n\t\t\tt.Fatalf(\"test %d: InnerHTML is empty\", i)\n\t\t}\n\t}\n}\n\nfunc TestOuterHTML(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"table.html\")\n\tdefer cancel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t}{\n\t\t{`/html/body/table/thead/tr`, BySearch},\n\t\t{`thead tr`, ByQueryAll},\n\t\t{`thead tr`, ByQuery},\n\t\t{`document.querySelector(\"#footer > td:nth-child(2)\")`, ByJSPath},\n\t}\n\tfor i, test := range tests {\n\t\tvar html string\n\t\tif err := Run(ctx, OuterHTML(test.sel, &html, test.by)); err != nil {\n\t\t\tt.Fatalf(\"test %d got error: %v\", i, err)\n\t\t}\n\n\t\tif html == \"\" {\n\t\t\tt.Fatalf(\"test %d: OuterHTML is empty\", i)\n\t\t}\n\t}\n}\n\nfunc TestScrollIntoView(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"image.html\")\n\tdefer cancel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t}{\n\t\t{`/html/body/img`, BySearch},\n\t\t{`img`, ByQueryAll},\n\t\t{`img`, ByQuery},\n\t\t{`#icon-github`, ByID},\n\t\t{`document.querySelector('#icon-github')`, ByJSPath},\n\t}\n\tfor i, test := range tests {\n\t\tif err := Run(ctx, ScrollIntoView(test.sel, test.by)); err != nil {\n\t\t\tt.Fatalf(\"test %d got error: %v\", i, err)\n\t\t}\n\n\t\t// TODO test scroll event\n\t}\n}\n\nfunc TestSVGFullXPath(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tsel string\n\t\tby  QueryOption\n\t}{\n\t\t{`#brankas`, ByQuery},\n\t\t{`text`, ByQueryAll},\n\t\t{`brankas`, ByID},\n\t\t{`//*[local-name()='text']`, BySearch},\n\t\t{`document.querySelector('#brankas')`, ByJSPath},\n\t}\n\n\tfor i, test := range tests {\n\t\ttest := test\n\t\tt.Run(fmt.Sprintf(\"%02d\", i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctx, cancel := testAllocate(t, \"svg.html\")\n\t\t\tdefer cancel()\n\n\t\t\tvar nodes []*cdp.Node\n\t\t\tif err := Run(ctx, Nodes(test.sel, &nodes, test.by)); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif len(nodes) < 1 {\n\t\t\t\tt.Fatalf(\"expected at least 1 node, got: %d\", len(nodes))\n\t\t\t}\n\n\t\t\tconst exp = `/html[1]/body[1]/*[local-name()='svg'][1]/*[local-name()='text'][1]`\n\t\t\txpath := nodes[0].FullXPath()\n\t\t\tif exp != xpath {\n\t\t\t\tt.Errorf(\"expected %q, got: %q\", exp, xpath)\n\t\t\t}\n\n\t\t\tvar text1, text2 string\n\t\t\tif err := Run(ctx, TextContent(test.sel, &text1, test.by)); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif strings.TrimSpace(text1) != \"Brankas\" {\n\t\t\t\tt.Errorf(\"expected %q, got: %q\", \"Brankas\", text1)\n\t\t\t}\n\t\t\tif err := Run(ctx, TextContent(xpath, &text2)); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif strings.TrimSpace(text2) != \"Brankas\" {\n\t\t\t\tt.Errorf(\"expected %q, got: %q\", \"Brankas\", text2)\n\t\t\t}\n\t\t})\n\t}\n}\n\nconst (\n\tuploadHTML = `<!doctype html>\n<html>\n<body>\n\t<form method=\"POST\" action=\"/upload\" enctype=\"multipart/form-data\">\n\t\t<input name=\"upload\" type=\"file\"/>\n\t\t<input name=\"submit\" type=\"submit\"/>\n\t</form>\n</body>\n</html>`\n\n\tresultHTML = `<!doctype html>\n<html>\n<body>\n\t<div id=\"result\">%d</div>\n</body>\n</html>`\n)\n\nfunc TestWaitReadyReuseAction(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"js.html\")\n\tdefer cancel()\n\n\t// Reusing a single WaitReady action used to panic.\n\taction := WaitReady(\"#input2\", ByID)\n\tfor i := 0; i < 3; i++ {\n\t\tif err := Run(ctx, action); err != nil {\n\t\t\tt.Fatalf(\"got error: %v\", err)\n\t\t}\n\t}\n}\n\nfunc TestFromNode(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"nested.html\")\n\tdefer cancel()\n\n\ttests := []struct {\n\t\tname       string\n\t\tfromQuery  string\n\t\tnodesQuery string\n\t\tnodesCount int\n\t}{\n\t\t{\"DefaultRoot\", \"\", \".content\", 4},\n\t\t{\"Body\", \"body\", \".content\", 4},\n\t\t{\"Empty\", \"#empty\", \".content\", 0},\n\t\t{\"Parent1\", \"#parent1\", \".content\", 1},\n\t\t{\"Parent2\", \"#parent2\", \".content\", 2},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar from *cdp.Node\n\t\t\tif test.fromQuery != \"\" {\n\t\t\t\tvar nodes []*cdp.Node\n\t\t\t\tif err := Run(ctx,\n\t\t\t\t\tNodes(test.fromQuery, &nodes, ByQuery, AtLeast(0)),\n\t\t\t\t); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif len(nodes) != 1 {\n\t\t\t\t\tt.Fatalf(\"expected to have 1 node, got %d\", len(nodes))\n\t\t\t\t}\n\t\t\t\tfrom = nodes[0]\n\t\t\t}\n\t\t\tvar nodes []*cdp.Node\n\t\t\tif err := Run(ctx,\n\t\t\t\tNodes(test.nodesQuery, &nodes, ByQueryAll, AtLeast(0), FromNode(from)),\n\t\t\t); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif len(nodes) != test.nodesCount {\n\t\t\t\tt.Fatalf(\"expected to have %d node, got %d\", test.nodesCount, len(nodes))\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "screenshot.go",
          "type": "blob",
          "size": 5.21484375,
          "content": "package chromedp\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math\"\n\n\t\"github.com/chromedp/cdproto/cdp\"\n\t\"github.com/chromedp/cdproto/page\"\n\t\"github.com/chromedp/cdproto/runtime\"\n)\n\n// Screenshot is an element query action that takes a screenshot of the first element\n// node matching the selector.\n//\n// It's supposed to act the same as the command \"Capture node screenshot\" in Chrome.\n//\n// Behavior notes: the Protocol Monitor shows that the command sends the following\n// CDP commands too:\n//   - Emulation.clearDeviceMetricsOverride\n//   - Network.setUserAgentOverride with {\"userAgent\": \"\"}\n//   - Overlay.setShowViewportSizeOnResize with {\"show\": false}\n//\n// These CDP commands are not sent by chromedp. If it does not work as expected,\n// you can try to send those commands yourself.\n//\n// See [CaptureScreenshot] for capturing a screenshot of the browser viewport.\n//\n// See [screenshot] for an example of taking a screenshot of the entire page.\n//\n// [screenshot]: https://github.com/chromedp/examples/tree/master/screenshot\nfunc Screenshot(sel interface{}, picbuf *[]byte, opts ...QueryOption) QueryAction {\n\treturn ScreenshotScale(sel, 1, picbuf, opts...)\n}\n\n// ScreenshotScale is like [Screenshot] but accepts a scale parameter that\n// specifies the page scale factor.\nfunc ScreenshotScale(sel interface{}, scale float64, picbuf *[]byte, opts ...QueryOption) QueryAction {\n\tif picbuf == nil {\n\t\tpanic(\"picbuf cannot be nil\")\n\t}\n\n\treturn QueryAfter(sel, func(ctx context.Context, execCtx runtime.ExecutionContextID, nodes ...*cdp.Node) error {\n\t\tif len(nodes) < 1 {\n\t\t\treturn fmt.Errorf(\"selector %q did not return any nodes\", sel)\n\t\t}\n\t\treturn ScreenshotNodes(nodes, scale, picbuf).Do(ctx)\n\t}, append(opts, NodeVisible)...)\n}\n\n// ScreenshotNodes is an action that captures/takes a screenshot of the\n// specified nodes, by calculating the extents of the top most left node and\n// bottom most right node.\nfunc ScreenshotNodes(nodes []*cdp.Node, scale float64, picbuf *[]byte) Action {\n\tif len(nodes) == 0 {\n\t\tpanic(\"nodes must be non-empty\")\n\t}\n\tif picbuf == nil {\n\t\tpanic(\"picbuf cannot be nil\")\n\t}\n\n\treturn ActionFunc(func(ctx context.Context) error {\n\t\tvar clip page.Viewport\n\n\t\t// get box model of first node\n\t\tif err := callFunctionOnNode(ctx, nodes[0], getClientRectJS, &clip); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// remainder\n\t\tfor _, node := range nodes[1:] {\n\t\t\tvar v page.Viewport\n\t\t\t// get box model of first node\n\t\t\tif err := callFunctionOnNode(ctx, node, getClientRectJS, &v); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tclip.X, clip.Width = extents(clip.X, clip.Width, v.X, v.Width)\n\t\t\tclip.Y, clip.Height = extents(clip.Y, clip.Height, v.Y, v.Height)\n\t\t}\n\n\t\t// The \"Capture node screenshot\" command does not handle fractional dimensions properly.\n\t\t// Let's align with puppeteer:\n\t\t// https://github.com/puppeteer/puppeteer/blob/bba3f41286908ced8f03faf98242d4c3359a5efc/src/common/Page.ts#L2002-L2011\n\t\tx, y := math.Round(clip.X), math.Round(clip.Y)\n\t\tclip.Width, clip.Height = math.Round(clip.Width+clip.X-x), math.Round(clip.Height+clip.Y-y)\n\t\tclip.X, clip.Y = x, y\n\n\t\tclip.Scale = scale\n\n\t\t// take screenshot of the box\n\t\tbuf, err := page.CaptureScreenshot().\n\t\t\tWithFormat(page.CaptureScreenshotFormatPng).\n\t\t\tWithCaptureBeyondViewport(true).\n\t\t\tWithFromSurface(true).\n\t\t\tWithClip(&clip).\n\t\t\tDo(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*picbuf = buf\n\t\treturn nil\n\t})\n}\n\n// CaptureScreenshot is an action that captures/takes a screenshot of the\n// current browser viewport.\n//\n// It's supposed to act the same as the command \"Capture screenshot\" in\n// Chrome. See the behavior notes of Screenshot for more information.\n//\n// See the [Screenshot] action to take a screenshot of a specific element.\n//\n// See [screenshot] for an example of taking a screenshot of the entire page.\n//\n// [screenshot]: https://github.com/chromedp/examples/tree/master/screenshot\nfunc CaptureScreenshot(res *[]byte) Action {\n\tif res == nil {\n\t\tpanic(\"res cannot be nil\")\n\t}\n\n\treturn ActionFunc(func(ctx context.Context) error {\n\t\tvar err error\n\t\t*res, err = page.CaptureScreenshot().\n\t\t\tWithFromSurface(true).\n\t\t\tDo(ctx)\n\t\treturn err\n\t})\n}\n\n// FullScreenshot takes a full screenshot with the specified image quality of\n// the entire browser viewport.\n//\n// It's supposed to act the same as the command \"Capture full size screenshot\"\n// in Chrome. See the behavior notes of Screenshot for more information.\n//\n// The valid range of the compression quality is [0..100]. When this value is\n// 100, the image format is png; otherwise, the image format is jpeg.\nfunc FullScreenshot(res *[]byte, quality int) EmulateAction {\n\tif res == nil {\n\t\tpanic(\"res cannot be nil\")\n\t}\n\treturn ActionFunc(func(ctx context.Context) error {\n\t\tformat := page.CaptureScreenshotFormatPng\n\t\tif quality != 100 {\n\t\t\tformat = page.CaptureScreenshotFormatJpeg\n\t\t}\n\n\t\t// capture screenshot\n\t\tvar err error\n\t\t*res, err = page.CaptureScreenshot().\n\t\t\tWithCaptureBeyondViewport(true).\n\t\t\tWithFromSurface(true).\n\t\t\tWithFormat(format).\n\t\t\tWithQuality(int64(quality)).\n\t\t\tDo(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc extents(m, n, o, p float64) (float64, float64) {\n\ta := min(m, o)\n\tb := max(m+n, o+p)\n\treturn a, b - a\n}\n\nfunc min(a, b float64) float64 {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc max(a, b float64) float64 {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n"
        },
        {
          "name": "screenshot_test.go",
          "type": "blob",
          "size": 5.1142578125,
          "content": "package chromedp\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"image\"\n\t_ \"image/jpeg\"\n\t_ \"image/png\"\n\t\"os\"\n\t\"path\"\n\t\"testing\"\n\n\t\"github.com/orisano/pixelmatch\"\n)\n\nfunc TestScreenshot(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname string\n\t\tsel  string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"padding border\",\n\t\t\tsel:  \"#padding-border\",\n\t\t\twant: \"element-padding-border.png\",\n\t\t},\n\t\t{\n\t\t\tname: \"larger than viewport\",\n\t\t\tsel:  \"#larger-than-viewport\",\n\t\t\twant: \"element-larger-than-viewport.png\",\n\t\t},\n\t\t{\n\t\t\tname: \"outside viewport\",\n\t\t\tsel:  \"#outside-viewport\",\n\t\t\twant: \"element-scrolled-into-view.png\",\n\t\t},\n\t\t{\n\t\t\tname: \"rotate element\",\n\t\t\tsel:  \"#rotated\",\n\t\t\twant: \"element-rotate.png\",\n\t\t},\n\t\t{\n\t\t\tname: \"fractional dimensions\",\n\t\t\tsel:  \"#fractional-dimensions\",\n\t\t\twant: \"element-fractional.png\",\n\t\t},\n\t\t{\n\t\t\tname: \"fractional offset\",\n\t\t\tsel:  \"#fractional-offset\",\n\t\t\twant: \"element-fractional-offset.png\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tctx, cancel := testAllocate(t, \"screenshot.html\")\n\t\t\tdefer cancel()\n\n\t\t\tvar buf []byte\n\t\t\tif err := Run(ctx,\n\t\t\t\tEmulateViewport(500, 500),\n\t\t\t\tEvaluateAsDevTools(\"document.documentElement.scrollTo(20,  30)\", nil),\n\t\t\t\tScreenshot(test.sel, &buf, ByQuery),\n\t\t\t); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tdiff, err := matchPixel(buf, test.want)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif diff != 0 {\n\t\t\t\tt.Fatalf(\"screenshot does not match. diff: %v\", diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestScreenshotScale(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname  string\n\t\tsel   string\n\t\tscale float64\n\t\twant  string\n\t}{\n\t\t{\n\t\t\tname:  \"padding border\",\n\t\t\tsel:   \"#padding-border\",\n\t\t\tscale: 2,\n\t\t\twant:  \"element-padding-border@2x.png\",\n\t\t},\n\t\t{\n\t\t\tname:  \"svg\",\n\t\t\tsel:   \"#svg-circle\",\n\t\t\tscale: 3,\n\t\t\twant:  \"element-svg@3x.png\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tctx, cancel := testAllocate(t, \"screenshot.html\")\n\t\t\tdefer cancel()\n\n\t\t\tvar buf []byte\n\t\t\tif err := Run(ctx,\n\t\t\t\tScreenshotScale(test.sel, test.scale, &buf, ByQuery),\n\t\t\t); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tdiff, err := matchPixel(buf, test.want)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif diff > 20 {\n\t\t\t\tt.Fatalf(\"screenshot does not match. diff: %v\", diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestScreenshotHighDPI(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"image.html\")\n\tdefer cancel()\n\n\t// Use a weird screen dimension with a 1.5 scale factor, so that\n\t// cropping the screenshot is forced to use floating point arithmetic\n\t// and keep the high DPI in mind.\n\t// We also want the dimensions to be large enough to see the element we\n\t// want, since we're not scrolling to ensure it's in view.\n\tif err := Run(ctx, EmulateViewport(905, 705, EmulateScale(1.5))); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar buf []byte\n\tif err := Run(ctx, Screenshot(\"#half-color\", &buf, ByID)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdiff, err := matchPixel(buf, \"half-color.png\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif diff != 0 {\n\t\tt.Fatalf(\"screenshot does not match. diff: %v\", diff)\n\t}\n}\n\nfunc TestCaptureScreenshot(t *testing.T) {\n\tt.Parallel()\n\n\tctx, cancel := testAllocate(t, \"grid.html\")\n\tdefer cancel()\n\n\tvar buf []byte\n\tif err := Run(ctx,\n\t\tEmulateViewport(500, 500),\n\t\tCaptureScreenshot(&buf),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdiff, err := matchPixel(buf, \"sanity.png\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif diff != 0 {\n\t\tt.Fatalf(\"screenshot does not match. diff: %v\", diff)\n\t}\n}\n\nfunc TestFullScreenshot(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname    string\n\t\tquality int\n\t\twant    string\n\t}{\n\t\t{\n\t\t\tname:    \"quality 100\",\n\t\t\tquality: 100,\n\t\t\twant:    \"grid-fullpage.png\",\n\t\t},\n\t\t{\n\t\t\tname:    \"quality 90\",\n\t\t\tquality: 90,\n\t\t\twant:    \"grid-fullpage-90.jpeg\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tctx, cancel := testAllocate(t, \"grid.html\")\n\t\t\tdefer cancel()\n\n\t\t\tvar buf []byte\n\t\t\tif err := Run(ctx,\n\t\t\t\tEmulateViewport(500, 500),\n\t\t\t\tEvaluateAsDevTools(\"document.documentElement.scrollTo(20,  30)\", nil),\n\t\t\t\tFullScreenshot(&buf, test.quality),\n\t\t\t); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tdiff, err := matchPixel(buf, test.want)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif diff != 0 {\n\t\t\t\tt.Fatalf(\"screenshot does not match. diff: %v\", diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc matchPixel(buf []byte, want string) (int, error) {\n\timg1, format1, err := image.Decode(bytes.NewReader(buf))\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\timg2, format2, err := openImage(want)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tif format1 != format2 {\n\t\treturn 0, fmt.Errorf(\"image formats not matched: %s != %s\", format1, format2)\n\t}\n\n\treturn pixelmatch.MatchPixel(img1, img2, pixelmatch.Threshold(0.1))\n}\n\nfunc openImage(screenshot string) (image.Image, string, error) {\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tp := path.Join(wd, \"testdata\", \"screenshots\", screenshot)\n\tf, err := os.Open(p)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tdefer f.Close()\n\n\timg, format, err := image.Decode(f)\n\tif err != nil {\n\t\treturn nil, \"\", fmt.Errorf(\"decode image: %w\", err)\n\t}\n\treturn img, format, nil\n}\n"
        },
        {
          "name": "target.go",
          "type": "blob",
          "size": 10.4716796875,
          "content": "package chromedp\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"github.com/mailru/easyjson\"\n\n\t\"github.com/chromedp/cdproto\"\n\t\"github.com/chromedp/cdproto/cdp\"\n\t\"github.com/chromedp/cdproto/dom\"\n\t\"github.com/chromedp/cdproto/page\"\n\t\"github.com/chromedp/cdproto/runtime\"\n\t\"github.com/chromedp/cdproto/target\"\n)\n\n// Target manages a Chrome DevTools Protocol target.\ntype Target struct {\n\tbrowser   *Browser\n\tSessionID target.SessionID\n\tTargetID  target.ID\n\n\tlistenersMu sync.Mutex\n\tlisteners   []cancelableListener\n\n\tmessageQueue chan *cdproto.Message\n\n\t// frameMu protects frames, execContexts, and cur.\n\tframeMu sync.RWMutex\n\t// frames is the set of encountered frames.\n\tframes       map[cdp.FrameID]*cdp.Frame\n\texecContexts map[cdp.FrameID]runtime.ExecutionContextID\n\t// cur is the current top level frame.\n\tcur cdp.FrameID\n\n\t// logging funcs\n\tlogf, errf func(string, ...interface{})\n\n\t// Indicates if the target is a worker target.\n\tisWorker bool\n}\n\nfunc (t *Target) enclosingFrame(node *cdp.Node) cdp.FrameID {\n\tt.frameMu.RLock()\n\ttop := t.frames[t.cur]\n\tt.frameMu.RUnlock()\n\ttop.RLock()\n\tdefer top.RUnlock()\n\tfor {\n\t\tif node == nil {\n\t\t\t// Avoid crashing. This can happen if we're using an old\n\t\t\t// node that has been replaced, for example.\n\t\t\treturn \"\"\n\t\t}\n\t\tif node.FrameID != \"\" {\n\t\t\tbreak\n\t\t}\n\t\tnode = top.Nodes[node.ParentID]\n\t}\n\treturn node.FrameID\n}\n\n// ensureFrame ensures the top frame of this target is loaded and returns the top frame,\n// the root node and the ExecutionContextID of this top frame; otherwise, it will return\n// false as its last return value.\nfunc (t *Target) ensureFrame() (*cdp.Frame, *cdp.Node, runtime.ExecutionContextID, bool) {\n\tt.frameMu.RLock()\n\tframe := t.frames[t.cur]\n\texecCtx := t.execContexts[t.cur]\n\tt.frameMu.RUnlock()\n\n\t// the frame hasn't loaded yet.\n\tif frame == nil || execCtx == 0 {\n\t\treturn nil, nil, 0, false\n\t}\n\n\tframe.RLock()\n\troot := frame.Root\n\tframe.RUnlock()\n\n\tif root == nil {\n\t\t// not root node yet?\n\t\treturn nil, nil, 0, false\n\t}\n\treturn frame, root, execCtx, true\n}\n\nfunc (t *Target) run(ctx context.Context) {\n\ttype eventValue struct {\n\t\tmethod cdproto.MethodType\n\t\tvalue  interface{}\n\t}\n\t// syncEventQueue is used to handle events synchronously within Target.\n\t// TODO: If this queue gets full, the goroutine below could get stuck on\n\t// a send, and response callbacks would never run, resulting in a\n\t// deadlock. Can we fix this without potentially using lots of memory?\n\tsyncEventQueue := make(chan eventValue, 4096)\n\n\t// This goroutine receives events from the browser, calls listeners, and\n\t// then passes the events onto the main goroutine for the target handler\n\t// to update itself.\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\n\t\t\tcase msg := <-t.messageQueue:\n\t\t\t\tif msg.ID != 0 {\n\t\t\t\t\tt.listenersMu.Lock()\n\t\t\t\t\tt.listeners = runListeners(t.listeners, msg)\n\t\t\t\t\tt.listenersMu.Unlock()\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tev, err := cdproto.UnmarshalMessage(msg)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif _, ok := err.(cdp.ErrUnknownCommandOrEvent); ok {\n\t\t\t\t\t\t// This is most likely an event received from an older\n\t\t\t\t\t\t// Chrome which a newer cdproto doesn't have, as it is\n\t\t\t\t\t\t// deprecated. Ignore that error.\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tt.errf(\"could not unmarshal event: %v\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tt.listenersMu.Lock()\n\t\t\t\tt.listeners = runListeners(t.listeners, ev)\n\t\t\t\tt.listenersMu.Unlock()\n\n\t\t\t\tswitch msg.Method.Domain() {\n\t\t\t\tcase \"Runtime\", \"Page\", \"DOM\":\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase syncEventQueue <- eventValue{msg.Method, ev}:\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase ev := <-syncEventQueue:\n\t\t\tswitch ev.method.Domain() {\n\t\t\tcase \"Runtime\":\n\t\t\t\tt.runtimeEvent(ev.value)\n\t\t\tcase \"Page\":\n\t\t\t\tt.pageEvent(ev.value)\n\t\t\tcase \"DOM\":\n\t\t\t\tt.domEvent(ctx, ev.value)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (t *Target) Execute(ctx context.Context, method string, params easyjson.Marshaler, res easyjson.Unmarshaler) error {\n\tif method == target.CommandCloseTarget {\n\t\treturn errors.New(\"to close the target, cancel its context or use chromedp.Cancel\")\n\t}\n\n\tid := atomic.AddInt64(&t.browser.next, 1)\n\tlctx, cancel := context.WithCancel(ctx)\n\tch := make(chan *cdproto.Message, 1)\n\tfn := func(ev interface{}) {\n\t\tif msg, ok := ev.(*cdproto.Message); ok && msg.ID == id {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\tcase ch <- msg:\n\t\t\t}\n\t\t\tcancel()\n\t\t}\n\t}\n\tt.listenersMu.Lock()\n\tt.listeners = append(t.listeners, cancelableListener{lctx, fn})\n\tt.listenersMu.Unlock()\n\n\t// send command\n\tvar buf []byte\n\tif params != nil {\n\t\tvar err error\n\t\tbuf, err = easyjson.Marshal(params)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tcmd := &cdproto.Message{\n\t\tID:        id,\n\t\tSessionID: t.SessionID,\n\t\tMethod:    cdproto.MethodType(method),\n\t\tParams:    buf,\n\t}\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tcase t.browser.cmdQueue <- cmd:\n\t}\n\n\t// wait for result\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tcase msg := <-ch:\n\t\tswitch {\n\t\tcase msg == nil:\n\t\t\treturn ErrChannelClosed\n\t\tcase msg.Error != nil:\n\t\t\treturn msg.Error\n\t\tcase res != nil:\n\t\t\treturn easyjson.Unmarshal(msg.Result, res)\n\t\t}\n\t}\n\treturn nil\n}\n\n// runtimeEvent handles incoming runtime events.\nfunc (t *Target) runtimeEvent(ev interface{}) {\n\tswitch ev := ev.(type) {\n\tcase *runtime.EventExecutionContextCreated:\n\t\tvar aux struct {\n\t\t\tFrameID cdp.FrameID\n\t\t}\n\t\tif len(ev.Context.AuxData) == 0 {\n\t\t\tbreak\n\t\t}\n\t\tif err := json.Unmarshal(ev.Context.AuxData, &aux); err != nil {\n\t\t\tt.errf(\"could not decode executionContextCreated auxData %q: %v\", ev.Context.AuxData, err)\n\t\t\tbreak\n\t\t}\n\t\tif aux.FrameID != \"\" {\n\t\t\tt.frameMu.Lock()\n\t\t\tt.execContexts[aux.FrameID] = ev.Context.ID\n\t\t\tt.frameMu.Unlock()\n\t\t}\n\tcase *runtime.EventExecutionContextDestroyed:\n\t\tt.frameMu.Lock()\n\t\tfor frameID, ctxID := range t.execContexts {\n\t\t\tif ctxID == ev.ExecutionContextID {\n\t\t\t\tdelete(t.execContexts, frameID)\n\t\t\t}\n\t\t}\n\t\tt.frameMu.Unlock()\n\tcase *runtime.EventExecutionContextsCleared:\n\t\tt.frameMu.Lock()\n\t\tfor frameID := range t.execContexts {\n\t\t\tdelete(t.execContexts, frameID)\n\t\t}\n\t\tt.frameMu.Unlock()\n\t}\n}\n\n// documentUpdated handles the document updated event, retrieving the document\n// root for the root frame.\nfunc (t *Target) documentUpdated(ctx context.Context) {\n\tt.frameMu.RLock()\n\tf := t.frames[t.cur]\n\tt.frameMu.RUnlock()\n\tif f == nil {\n\t\t// TODO: This seems to happen on CI, when running the tests\n\t\t// under the headless-shell Docker image. Figure out why.\n\t\tt.errf(\"received DOM.documentUpdated when there's no top-level frame\")\n\t\treturn\n\t}\n\tf.Lock()\n\tdefer f.Unlock()\n\n\t// invalidate nodes\n\tif f.Root != nil {\n\t\tclose(f.Root.Invalidated)\n\t}\n\n\tf.Nodes = make(map[cdp.NodeID]*cdp.Node)\n\tvar err error\n\tf.Root, err = dom.GetDocument().Do(cdp.WithExecutor(ctx, t))\n\tif err == context.Canceled {\n\t\treturn // TODO: perhaps not necessary, but useful to keep the tests less noisy\n\t}\n\tif err != nil {\n\t\tt.errf(\"could not retrieve document root for %s: %v\", f.ID, err)\n\t\treturn\n\t}\n\tf.Root.Invalidated = make(chan struct{})\n\twalk(f.Nodes, f.Root)\n}\n\n// pageEvent handles incoming page events.\nfunc (t *Target) pageEvent(ev interface{}) {\n\tvar id cdp.FrameID\n\tvar op frameOp\n\n\tswitch e := ev.(type) {\n\tcase *page.EventFrameNavigated:\n\t\tt.frameMu.Lock()\n\t\tt.frames[e.Frame.ID] = e.Frame\n\t\tif e.Frame.ParentID == \"\" {\n\t\t\t// This frame is only the new top-level frame if it has\n\t\t\t// no parent.\n\t\t\tt.cur = e.Frame.ID\n\t\t}\n\t\tt.frameMu.Unlock()\n\t\treturn\n\n\tcase *page.EventFrameAttached:\n\t\tid, op = e.FrameID, frameAttached(e.ParentFrameID)\n\n\tcase *page.EventFrameDetached:\n\t\tid, op = e.FrameID, frameDetached\n\n\tcase *page.EventFrameStartedLoading:\n\t\tid, op = e.FrameID, frameStartedLoading\n\n\tcase *page.EventFrameStoppedLoading:\n\t\tid, op = e.FrameID, frameStoppedLoading\n\n\t\t// ignored events\n\tcase *page.EventCompilationCacheProduced,\n\t\t*page.EventDocumentOpened,\n\t\t*page.EventDomContentEventFired,\n\t\t*page.EventFileChooserOpened,\n\t\t*page.EventFrameRequestedNavigation,\n\t\t*page.EventFrameResized,\n\t\t*page.EventInterstitialHidden,\n\t\t*page.EventInterstitialShown,\n\t\t*page.EventJavascriptDialogClosed,\n\t\t*page.EventJavascriptDialogOpening,\n\t\t*page.EventLifecycleEvent,\n\t\t*page.EventLoadEventFired,\n\t\t*page.EventNavigatedWithinDocument,\n\t\t*page.EventScreencastFrame,\n\t\t*page.EventScreencastVisibilityChanged,\n\t\t*page.EventWindowOpen,\n\t\t*page.EventBackForwardCacheNotUsed,\n\t\t*page.EventFrameSubtreeWillBeDetached:\n\t\treturn\n\n\tdefault:\n\t\tt.errf(\"unhandled page event %T\", ev)\n\t\treturn\n\t}\n\n\tt.frameMu.Lock()\n\tf := t.frames[id]\n\tif f == nil {\n\t\t// This can happen if a frame is attached or starts loading\n\t\t// before it's ever navigated to. We won't have all the frame\n\t\t// details just yet, but that's okay.\n\t\tf = &cdp.Frame{ID: id}\n\t\tt.frames[id] = f\n\t}\n\tt.frameMu.Unlock()\n\n\tf.Lock()\n\top(f)\n\tf.Unlock()\n}\n\n// domEvent handles incoming DOM events.\nfunc (t *Target) domEvent(ctx context.Context, ev interface{}) {\n\tt.frameMu.RLock()\n\tf := t.frames[t.cur]\n\tt.frameMu.RUnlock()\n\n\tvar id cdp.NodeID\n\tvar op nodeOp\n\n\tswitch e := ev.(type) {\n\tcase *dom.EventDocumentUpdated:\n\t\tt.documentUpdated(ctx)\n\t\treturn\n\n\tcase *dom.EventSetChildNodes:\n\t\tid, op = e.ParentID, setChildNodes(f.Nodes, e.Nodes)\n\n\tcase *dom.EventAttributeModified:\n\t\tid, op = e.NodeID, attributeModified(e.Name, e.Value)\n\n\tcase *dom.EventAttributeRemoved:\n\t\tid, op = e.NodeID, attributeRemoved(e.Name)\n\n\tcase *dom.EventInlineStyleInvalidated:\n\t\tif len(e.NodeIDs) == 0 {\n\t\t\treturn\n\t\t}\n\n\t\tid, op = e.NodeIDs[0], inlineStyleInvalidated(e.NodeIDs[1:])\n\n\tcase *dom.EventCharacterDataModified:\n\t\tid, op = e.NodeID, characterDataModified(e.CharacterData)\n\n\tcase *dom.EventChildNodeCountUpdated:\n\t\tid, op = e.NodeID, childNodeCountUpdated(e.ChildNodeCount)\n\n\tcase *dom.EventChildNodeInserted:\n\t\tid, op = e.ParentNodeID, childNodeInserted(f.Nodes, e.PreviousNodeID, e.Node)\n\n\tcase *dom.EventChildNodeRemoved:\n\t\tid, op = e.ParentNodeID, childNodeRemoved(f.Nodes, e.NodeID)\n\n\tcase *dom.EventShadowRootPushed:\n\t\tid, op = e.HostID, shadowRootPushed(f.Nodes, e.Root)\n\n\tcase *dom.EventShadowRootPopped:\n\t\tid, op = e.HostID, shadowRootPopped(f.Nodes, e.RootID)\n\n\tcase *dom.EventPseudoElementAdded:\n\t\tid, op = e.ParentID, pseudoElementAdded(f.Nodes, e.PseudoElement)\n\n\tcase *dom.EventPseudoElementRemoved:\n\t\tid, op = e.ParentID, pseudoElementRemoved(f.Nodes, e.PseudoElementID)\n\n\tcase *dom.EventDistributedNodesUpdated:\n\t\tid, op = e.InsertionPointID, distributedNodesUpdated(e.DistributedNodes)\n\n\tcase *dom.EventScrollableFlagUpdated:\n\t\tid, op = e.NodeID, scrollableFlagUpdated(f.Nodes, e.NodeID)\n\n\tdefault:\n\t\tt.errf(\"unhandled node event %T\", ev)\n\t\treturn\n\t}\n\n\tn, ok := f.Nodes[id]\n\tif !ok {\n\t\t// Node ID has been invalidated. Nothing to do.\n\t\treturn\n\t}\n\n\tf.Lock()\n\top(n)\n\tf.Unlock()\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 8.5771484375,
          "content": "package chromedp\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/chromedp/cdproto\"\n\t\"github.com/chromedp/cdproto/cdp\"\n)\n\n// forceIP tries to force the host component in urlstr to be an IP address.\n//\n// Since Chrome 66+, Chrome DevTools Protocol clients connecting to a browser\n// must send the \"Host:\" header as either an IP address, or \"localhost\".\n// See https://github.com/chromium/chromium/commit/0e914b95f7cae6e8238e4e9075f248f801c686e6.\nfunc forceIP(ctx context.Context, urlstr string) (string, error) {\n\tu, err := url.Parse(urlstr)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\thost, port, err := net.SplitHostPort(u.Host)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\thost, err = resolveHost(ctx, host)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tu.Host = net.JoinHostPort(host, port)\n\treturn u.String(), nil\n}\n\n// resolveHost tries to resolve a host to be an IP address. If the host is\n// an IP address or \"localhost\", it returns the host directly.\nfunc resolveHost(ctx context.Context, host string) (string, error) {\n\tif host == \"localhost\" {\n\t\treturn host, nil\n\t}\n\tip := net.ParseIP(host)\n\tif ip != nil {\n\t\treturn host, nil\n\t}\n\n\taddrs, err := net.DefaultResolver.LookupIPAddr(ctx, host)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn addrs[0].IP.String(), nil\n}\n\n// modifyURL modifies the websocket debugger URL if the provided URL is not a\n// valid websocket debugger URL.\n//\n// A websocket debugger URL containing \"/devtools/browser/\" are considered\n// valid. In this case, urlstr will only be modified by forceIP.\n//\n// Otherwise, it will construct a URL like http://[host]:[port]/json/version\n// and query the valid websocket debugger URL from this endpoint. The [host]\n// and [port] are parsed from the urlstr. If the host component is not an IP,\n// it will be resolved to an IP first. Example parameters:\n//   - ws://127.0.0.1:9222/\n//   - http://127.0.0.1:9222/\n//   - http://container-name:9222/\nfunc modifyURL(ctx context.Context, urlstr string) (string, error) {\n\tlctx, cancel := context.WithTimeout(ctx, 20*time.Second)\n\tdefer cancel()\n\n\tif strings.Contains(urlstr, \"/devtools/browser/\") {\n\t\treturn forceIP(lctx, urlstr)\n\t}\n\n\t// replace the scheme and path to construct a URL like:\n\t// http://127.0.0.1:9222/json/version\n\tu, err := url.Parse(urlstr)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tu.Scheme = \"http\"\n\thost, port, err := net.SplitHostPort(u.Host)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\thost, err = resolveHost(ctx, host)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tu.Host = net.JoinHostPort(host, port)\n\tu.Path = \"/json/version\"\n\n\t// to get \"webSocketDebuggerUrl\" in the response\n\treq, err := http.NewRequestWithContext(lctx, \"GET\", u.String(), nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar result map[string]interface{}\n\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n\t\treturn \"\", err\n\t}\n\t// the browser will construct the debugger URL using the \"host\" header of\n\t// the /json/version request. For example, run headless-shell in a container:\n\t//     docker run -d -p 9000:9222 chromedp/headless-shell:latest\n\t// then:\n\t//     curl http://127.0.0.1:9000/json/version\n\t// and the websocket debugger URL will be something like:\n\t// ws://127.0.0.1:9000/devtools/browser/...\n\twsURL := result[\"webSocketDebuggerUrl\"].(string)\n\treturn wsURL, nil\n}\n\nfunc runListeners(list []cancelableListener, ev interface{}) []cancelableListener {\n\tfor i := 0; i < len(list); {\n\t\tlistener := list[i]\n\t\tselect {\n\t\tcase <-listener.ctx.Done():\n\t\t\tlist = append(list[:i], list[i+1:]...)\n\t\t\tcontinue\n\t\tdefault:\n\t\t\tlistener.fn(ev)\n\t\t\ti++\n\t\t}\n\t}\n\treturn list\n}\n\n// frameOp is a frame manipulation operation.\ntype frameOp func(*cdp.Frame)\n\nfunc frameAttached(id cdp.FrameID) frameOp {\n\treturn func(f *cdp.Frame) {\n\t\tf.ParentID = id\n\t\tsetFrameState(f, cdp.FrameAttached)\n\t}\n}\n\nfunc frameDetached(f *cdp.Frame) {\n\tf.ParentID = cdp.EmptyFrameID\n\tclearFrameState(f, cdp.FrameAttached)\n}\n\nfunc frameStartedLoading(f *cdp.Frame) {\n\tsetFrameState(f, cdp.FrameLoading)\n}\n\nfunc frameStoppedLoading(f *cdp.Frame) {\n\tclearFrameState(f, cdp.FrameLoading)\n}\n\n// setFrameState sets the frame state via bitwise or (|).\nfunc setFrameState(f *cdp.Frame, fs cdp.FrameState) {\n\tf.State |= fs\n}\n\n// clearFrameState clears the frame state via bit clear (&^).\nfunc clearFrameState(f *cdp.Frame, fs cdp.FrameState) {\n\tf.State &^= fs\n}\n\n// nodeOp is a node manipulation operation.\ntype nodeOp func(*cdp.Node)\n\nfunc walk(m map[cdp.NodeID]*cdp.Node, n *cdp.Node) {\n\tn.RLock()\n\tdefer n.RUnlock()\n\tm[n.NodeID] = n\n\n\tfor _, c := range n.Children {\n\t\tc.Lock()\n\t\tc.Parent = n\n\t\tc.Invalidated = n.Invalidated\n\t\tc.Unlock()\n\n\t\twalk(m, c)\n\t}\n\n\tfor _, c := range n.ShadowRoots {\n\t\tc.Lock()\n\t\tc.Parent = n\n\t\tc.Invalidated = n.Invalidated\n\t\tc.Unlock()\n\n\t\twalk(m, c)\n\t}\n\n\tfor _, c := range n.PseudoElements {\n\t\tc.Lock()\n\t\tc.Parent = n\n\t\tc.Invalidated = n.Invalidated\n\t\tc.Unlock()\n\n\t\twalk(m, c)\n\t}\n\n\tfor _, c := range []*cdp.Node{n.ContentDocument, n.TemplateContent} {\n\t\tif c == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tc.Lock()\n\t\tc.Parent = n\n\t\tc.Invalidated = n.Invalidated\n\t\tc.Unlock()\n\n\t\twalk(m, c)\n\t}\n}\n\nfunc setChildNodes(m map[cdp.NodeID]*cdp.Node, nodes []*cdp.Node) nodeOp {\n\treturn func(n *cdp.Node) {\n\t\tn.Lock()\n\t\tn.Children = nodes\n\t\tn.Unlock()\n\n\t\twalk(m, n)\n\t}\n}\n\nfunc attributeModified(name, value string) nodeOp {\n\treturn func(n *cdp.Node) {\n\t\tn.Lock()\n\t\tdefer n.Unlock()\n\n\t\tvar found bool\n\t\tvar i int\n\t\tfor ; i < len(n.Attributes); i += 2 {\n\t\t\tif n.Attributes[i] == name {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif found {\n\t\t\tn.Attributes[i] = name\n\t\t\tn.Attributes[i+1] = value\n\t\t} else {\n\t\t\tn.Attributes = append(n.Attributes, name, value)\n\t\t}\n\t}\n}\n\nfunc attributeRemoved(name string) nodeOp {\n\treturn func(n *cdp.Node) {\n\t\tn.Lock()\n\t\tdefer n.Unlock()\n\n\t\tvar a []string\n\t\tfor i := 0; i < len(n.Attributes); i += 2 {\n\t\t\tif n.Attributes[i] == name {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ta = append(a, n.Attributes[i], n.Attributes[i+1])\n\t\t}\n\t\tn.Attributes = a\n\t}\n}\n\nfunc inlineStyleInvalidated(ids []cdp.NodeID) nodeOp {\n\treturn func(n *cdp.Node) {\n\t}\n}\n\nfunc characterDataModified(characterData string) nodeOp {\n\treturn func(n *cdp.Node) {\n\t\tn.Lock()\n\t\tdefer n.Unlock()\n\n\t\tn.Value = characterData\n\t}\n}\n\nfunc childNodeCountUpdated(count int64) nodeOp {\n\treturn func(n *cdp.Node) {\n\t\tn.Lock()\n\t\tdefer n.Unlock()\n\n\t\tn.ChildNodeCount = count\n\t}\n}\n\nfunc childNodeInserted(m map[cdp.NodeID]*cdp.Node, prevID cdp.NodeID, c *cdp.Node) nodeOp {\n\treturn func(n *cdp.Node) {\n\t\tn.Lock()\n\t\tn.Children = insertNode(n.Children, prevID, c)\n\t\tn.Unlock()\n\n\t\twalk(m, n)\n\t}\n}\n\nfunc childNodeRemoved(m map[cdp.NodeID]*cdp.Node, id cdp.NodeID) nodeOp {\n\treturn func(n *cdp.Node) {\n\t\tn.Lock()\n\t\tdefer n.Unlock()\n\n\t\tn.Children = removeNode(n.Children, id)\n\t\tdelete(m, id)\n\t}\n}\n\nfunc shadowRootPushed(m map[cdp.NodeID]*cdp.Node, c *cdp.Node) nodeOp {\n\treturn func(n *cdp.Node) {\n\t\tn.Lock()\n\t\tn.ShadowRoots = append(n.ShadowRoots, c)\n\t\tn.Unlock()\n\n\t\twalk(m, n)\n\t}\n}\n\nfunc shadowRootPopped(m map[cdp.NodeID]*cdp.Node, id cdp.NodeID) nodeOp {\n\treturn func(n *cdp.Node) {\n\t\tn.Lock()\n\t\tdefer n.Unlock()\n\n\t\tn.ShadowRoots = removeNode(n.ShadowRoots, id)\n\t\tdelete(m, id)\n\t}\n}\n\nfunc pseudoElementAdded(m map[cdp.NodeID]*cdp.Node, c *cdp.Node) nodeOp {\n\treturn func(n *cdp.Node) {\n\t\tn.Lock()\n\t\tn.PseudoElements = append(n.PseudoElements, c)\n\t\tn.Unlock()\n\n\t\twalk(m, n)\n\t}\n}\n\nfunc pseudoElementRemoved(m map[cdp.NodeID]*cdp.Node, id cdp.NodeID) nodeOp {\n\treturn func(n *cdp.Node) {\n\t\tn.Lock()\n\t\tdefer n.Unlock()\n\n\t\tn.PseudoElements = removeNode(n.PseudoElements, id)\n\t\tdelete(m, id)\n\t}\n}\n\nfunc distributedNodesUpdated(nodes []*cdp.BackendNode) nodeOp {\n\treturn func(n *cdp.Node) {\n\t\tn.Lock()\n\t\tdefer n.Unlock()\n\n\t\tn.DistributedNodes = nodes\n\t}\n}\n\nfunc scrollableFlagUpdated(m map[cdp.NodeID]*cdp.Node, id cdp.NodeID) nodeOp {\n\treturn func(n *cdp.Node) {\n\t}\n}\n\nfunc insertNode(n []*cdp.Node, prevID cdp.NodeID, c *cdp.Node) []*cdp.Node {\n\tvar i int\n\tvar found bool\n\tfor ; i < len(n); i++ {\n\t\tif n[i].NodeID == prevID {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\treturn append([]*cdp.Node{c}, n...)\n\t}\n\n\ti++\n\tn = append(n, nil)\n\tcopy(n[i+1:], n[i:])\n\tn[i] = c\n\n\treturn n\n}\n\nfunc removeNode(n []*cdp.Node, id cdp.NodeID) []*cdp.Node {\n\tif len(n) == 0 {\n\t\treturn n\n\t}\n\n\tvar found bool\n\tvar i int\n\tfor ; i < len(n); i++ {\n\t\tif n[i].NodeID == id {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\treturn n\n\t}\n\n\treturn append(n[:i], n[i+1:]...)\n}\n\n// isCouldNotComputeBoxModelError unwraps err as a MessageError and determines\n// if it is a compute box model error.\nfunc isCouldNotComputeBoxModelError(err error) bool {\n\te, ok := err.(*cdproto.Error)\n\treturn ok && e.Code == -32000 && e.Message == \"Could not compute box model.\"\n}\n"
        },
        {
          "name": "util_test.go",
          "type": "blob",
          "size": 4.7158203125,
          "content": "package chromedp\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/chromedp/cdproto/cdp\"\n\t\"github.com/chromedp/cdproto/runtime\"\n)\n\n// dumpJS is a JavaScript snippet that dumps the passed element node in the\n// same text format as cdproto/cdp/Node.Dump.\n//\n// Used to verify that the DOM tree built by chromedp is the same as what\n// chrome itself sees.\n//\n// Note: written to be \"line-by-line equivalent\" with Node.Dump's\n// implementation.\nconst dumpJS = `(function dump(n, prefix, indent, nodeIDs) {\n\tif (n === null || typeof n !== 'object') {\n\t\treturn prefix + '<nil>';\n\t}\n\n\tvar s = '';\n\tif (typeof n.localName !== 'undefined') {\n\t\ts = n.localName;\n\t}\n\tif (s === '' && typeof n.nodeName !== 'undefined') {\n\t\ts = n.nodeName;\n\t}\n\n\tif (s === '') {\n\t\tthrow 'invalid node element';\n\t}\n\n\tif (typeof n.attributes !== 'undefined') {\n\t\tfor (var i = 0; i < n.attributes.length; i++) {\n\t\t\tif (n.attributes[i].name.toLowerCase() === 'id') {\n\t\t\t\ts += '#' + n.attributes[i].value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (n.nodeType !== 1 && n.nodeType !== 3) {\n\t\ts += ' <' + [\n\t\t\t'Element',\n\t\t\t'Attribute',\n\t\t\t'Text',\n\t\t\t'CDATA',\n\t\t\t'EntityReference',\n\t\t\t'Entity',\n\t\t\t'ProcessingInstruction',\n\t\t\t'Comment',\n\t\t\t'Document',\n\t\t\t'DocumentType',\n\t\t\t'DocumentFragment',\n\t\t\t'Notation'\n\t\t][n.nodeType - 1] + '>';\n\t}\n\n\tif (n.nodeType === 3) {\n\t\tvar v = n.nodeValue;\n\t\tif (v.length > 15) {\n\t\t\tv = v.substring(0, 15) + '...';\n\t\t}\n\t\ts += ' ' + JSON.stringify(v);\n\t}\n\n\tif (n.nodeType === 1 && typeof n.attributes !== 'undefined' && n.attributes.length > 0) {\n\t\tvar attrs = '';\n\t\tfor (var i = 0; i <  n.attributes.length; i++) {\n\t\t\tif (n.attributes[i].name.toLowerCase() === 'id') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (attrs !== '') {\n\t\t\t\tattrs += ' ';\n\t\t\t}\n\t\t\tattrs += n.attributes[i].name + '=' + JSON.stringify(n.attributes[i].value);\n\t\t}\n\t\tif (attrs != '') {\n\t\t\ts += ' [' + attrs + ']';\n\t\t}\n\t}\n\n\tif (nodeIDs) {\n\t\tthrow 'cannot read element node ID from scripts';\n\t}\n\n\tif (typeof n.childNodes !== 'undefined' && n.childNodes.length > 0) {\n\t\tfor (var i = 0; i < n.childNodes.length; i++)\t{\n\t\t\t// skip empty #text nodes\n\t\t\tif (n.childNodes[i].nodeType === 3 && n.childNodes[i].nodeValue.trim() === '') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ts += '\\n' + dump(n.childNodes[i], prefix+indent, indent, nodeIDs);\n\t\t}\n\t}\n\n\treturn prefix + s;\n})(%s, %q, %q, %t);`\n\nconst insertJS = `(function(n, typ, id, text) {\n\tvar el = document.createElement(typ);\n\tel.id = id;\n\tel.innerText = text;\n\t%s;\n})(document.querySelector(%q), %q, %q, %q)`\n\n// test:\n// - insertBefore\n// - removeChild\n// - appendChild\n// - replaceChild\n// - prepend\n// - append\n// - insertAdjacentElement\nfunc TestNodeOp(t *testing.T) {\n\tt.Parallel()\n\n\ts := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n\t\tfmt.Fprintf(res, `<!doctype html>\n<html>\n  <head>\n    <title>empty test page</title>\n  </head>\n  <body>\n    <div id=\"div1\">div1 content</div>\n  </body>\n<html>`)\n\t}))\n\tdefer s.Close()\n\n\tctx, cancel := testAllocate(t, \"\")\n\tdefer cancel()\n\n\t// get document root\n\tvar nodes []*cdp.Node\n\tif err := Run(ctx,\n\t\tNavigate(s.URL),\n\t\tNodes(`//*`, &nodes),\n\t\tNodes(`document`, &nodes, ByJSPath),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttests := []struct {\n\t\tq, expr string\n\t}{\n\t\t{`body`, `n.insertBefore(el, n.childNodes[0])`},\n\t\t{`body`, `n.insertBefore(el, n.childNodes[1])`},\n\t\t{`#div3`, `n.prepend(el)`},\n\t\t{`#div2`, `n.append(el)`},\n\t\t{`#div2`, `n.appendChild(el)`},\n\t\t{`#div3`, `n.removeChild(n.childNodes[0])`},\n\t\t{`#div2`, `n.insertAdjacentElement('afterend', el)`},\n\t\t{`body`, `n.insertBefore(el, n.childNodes[0])`},\n\t\t{`body`, `n.insertBefore(el, n.childNodes[1])`},\n\t\t{`#div2`, `n.replaceChild(el, n.childNodes[1])`},\n\t}\n\n\tprev := nodes[0].Dump(\"\", \"  \", false)\n\tfor i, test := range tests {\n\t\t// modify tree\n\t\tif err := Run(ctx,\n\t\t\tActionFunc(func(ctx context.Context) error {\n\t\t\t\tid := strconv.Itoa(i + 2)\n\t\t\t\texpr := fmt.Sprintf(insertJS, test.expr, test.q, `div`, `div`+id, `div`+id+` content`)\n\t\t\t\t_, exp, err := runtime.Evaluate(expr).Do(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif exp != nil {\n\t\t\t\t\treturn exp\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// wait for events to propagate\n\t\ttime.Sleep(5 * time.Millisecond)\n\n\t\ttree := nodes[0].Dump(\"\", \"  \", false)\n\t\tif prev == tree {\n\t\t\tt.Fatalf(\"test %d expected tree to change (prev == tree)\\n-- PREV:\\n%s\\n-- TREE:\\n%s\\n--\\n\", i, prev, tree)\n\t\t}\n\n\t\t// retrieve browser's tree view\n\t\tvar exp string\n\t\tif err := Run(ctx,\n\t\t\tEvaluateAsDevTools(fmt.Sprintf(dumpJS, `document`, \"\", \"  \", false), &exp),\n\t\t); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif exp != tree {\n\t\t\tt.Errorf(\"test %d expected tree and node tree do not match:\\n-- EXPECTED:\\n%s\\n-- GOT:\\n%s\\n--\\n\", i, exp, tree)\n\t\t}\n\n\t\tprev = tree\n\n\t\t// t.Logf(\"test %d:\\n%s\\n--\\n\", i, tree)\n\t}\n}\n"
        }
      ]
    }
  ]
}