{
  "metadata": {
    "timestamp": 1736568108789,
    "page": 247,
    "hasNextPage": false,
    "endCursor": "Y3Vyc29yOjI0OA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jroimartin/gocui",
      "stars": 10023,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.005859375,
          "content": "*.swp\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.712890625,
          "content": "# This is the official list of gocui authors for copyright purposes.\n\n# Names should be added to this file as\n#\tName or Organization <email address> contribution\n#\t\tContribution\n# The email address is not required for organizations.\n\nRoi Martin <jroi.martin@gmail.com>\n\tMain developer\n\nRyan Sullivan <kayoticsully@gmail.com>\n\tToggleable view frames\n\nMatthieu Rakotojaona <matthieu.rakotojaona@gmail.com>\n\tWrapped views\n\nHarry Lawrence <hazbo@gmx.com>\n\tBasic mouse support\n\nDanny Tylman <dtylman@gmail.com>\n\tMasked views\n\nFrederik Deweerdt <frederik.deweerdt@gmail.com>\n\tColored fonts\n\nHenri Koski <henri.t.koski@gmail.com>\n\tCustom current view color\n\nDustin Willis Webber <dustin.webber@gmail.com>\n\t256-colors output mode support\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.484375,
          "content": "Copyright (c) 2014 The gocui Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of the gocui Authors nor the names of its contributors\n      may be used to endorse or promote products derived from this software\n      without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.3203125,
          "content": "# GOCUI - Go Console User Interface\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/jroimartin/gocui.svg)](https://pkg.go.dev/github.com/jroimartin/gocui)\n\nMinimalist Go package aimed at creating Console User Interfaces.\n\n## Features\n\n* Minimalist API.\n* Views (the \"windows\" in the GUI) implement the interface io.ReadWriter.\n* Support for overlapping views.\n* The GUI can be modified at runtime (concurrent-safe).\n* Global and view-level keybindings.\n* Mouse support.\n* Colored text.\n* Customizable edition mode.\n* Easy to build reusable widgets, complex layouts...\n\n## Installation\n\nExecute:\n\n```sh\ngo get github.com/jroimartin/gocui\n```\n\n## Documentation\n\nExecute:\n\n```sh\ngo doc github.com/jroimartin/gocui\n```\n\nOr visit [pkg.go.dev](https://pkg.go.dev/github.com/jroimartin/gocui) to read\nit online.\n\n## Example\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/jroimartin/gocui\"\n)\n\nfunc main() {\n\tg, err := gocui.NewGui(gocui.OutputNormal)\n\tif err != nil {\n\t\tlog.Panicln(err)\n\t}\n\tdefer g.Close()\n\n\tg.SetManagerFunc(layout)\n\n\tif err := g.SetKeybinding(\"\", gocui.KeyCtrlC, gocui.ModNone, quit); err != nil {\n\t\tlog.Panicln(err)\n\t}\n\n\tif err := g.MainLoop(); err != nil && err != gocui.ErrQuit {\n\t\tlog.Panicln(err)\n\t}\n}\n\nfunc layout(g *gocui.Gui) error {\n\tmaxX, maxY := g.Size()\n\tif v, err := g.SetView(\"hello\", maxX/2-7, maxY/2, maxX/2+7, maxY/2+2); err != nil {\n\t\tif err != gocui.ErrUnknownView {\n\t\t\treturn err\n\t\t}\n\t\tfmt.Fprintln(v, \"Hello world!\")\n\t}\n\treturn nil\n}\n\nfunc quit(g *gocui.Gui, v *gocui.View) error {\n\treturn gocui.ErrQuit\n}\n```\n\n## Screenshots\n\n![r2cui](https://cloud.githubusercontent.com/assets/1223476/19418932/63645052-93ce-11e6-867c-da5e97e37237.png)\n\n![_examples/demo.go](https://cloud.githubusercontent.com/assets/1223476/5992750/720b84f0-aa36-11e4-88ec-296fa3247b52.png)\n\n![_examples/dynamic.go](https://cloud.githubusercontent.com/assets/1223476/5992751/76ad5cc2-aa36-11e4-8204-6a90269db827.png)\n\n## Projects using gocui\n\n* [komanda-cli](https://github.com/mephux/komanda-cli): IRC Client For Developers.\n* [vuls](https://github.com/future-architect/vuls): Agentless vulnerability scanner for Linux/FreeBSD.\n* [wuzz](https://github.com/asciimoo/wuzz): Interactive cli tool for HTTP inspection.\n* [httplab](https://github.com/gchaincl/httplab): Interactive web server.\n* [domainr](https://github.com/MichaelThessel/domainr): Tool that checks the availability of domains based on keywords.\n* [gotime](https://github.com/nanohard/gotime): Time tracker for projects and tasks.\n* [claws](https://github.com/thehowl/claws): Interactive command line client for testing websockets.\n* [terminews](http://github.com/antavelos/terminews): Terminal based RSS reader.\n* [diagram](https://github.com/esimov/diagram): Tool to convert ascii arts into hand drawn diagrams.\n* [pody](https://github.com/JulienBreux/pody): CLI app to manage Pods in a Kubernetes cluster.\n* [kubexp](https://github.com/alitari/kubexp): Kubernetes client.\n* [kcli](https://github.com/cswank/kcli): Tool for inspecting kafka topics/partitions/messages.\n* [fac](https://github.com/mkchoi212/fac): git merge conflict resolver\n* [jsonui](https://github.com/gulyasm/jsonui): Interactive JSON explorer for your terminal.\n* [cointop](https://github.com/miguelmota/cointop): Interactive terminal based UI application for tracking cryptocurrencies.\n\nNote: if your project is not listed here, let us know! :)\n"
        },
        {
          "name": "_examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "attribute.go",
          "type": "blob",
          "size": 1.1572265625,
          "content": "// Copyright 2014 The gocui Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gocui\n\nimport \"github.com/nsf/termbox-go\"\n\n// Attribute represents a terminal attribute, like color, font style, etc. They\n// can be combined using bitwise OR (|). Note that it is not possible to\n// combine multiple color attributes.\ntype Attribute termbox.Attribute\n\n// Color attributes.\nconst (\n\tColorDefault Attribute = Attribute(termbox.ColorDefault)\n\tColorBlack             = Attribute(termbox.ColorBlack)\n\tColorRed               = Attribute(termbox.ColorRed)\n\tColorGreen             = Attribute(termbox.ColorGreen)\n\tColorYellow            = Attribute(termbox.ColorYellow)\n\tColorBlue              = Attribute(termbox.ColorBlue)\n\tColorMagenta           = Attribute(termbox.ColorMagenta)\n\tColorCyan              = Attribute(termbox.ColorCyan)\n\tColorWhite             = Attribute(termbox.ColorWhite)\n)\n\n// Text style attributes.\nconst (\n\tAttrBold      Attribute = Attribute(termbox.AttrBold)\n\tAttrUnderline           = Attribute(termbox.AttrUnderline)\n\tAttrReverse             = Attribute(termbox.AttrReverse)\n)\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 3.208984375,
          "content": "// Copyright 2014 The gocui Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n/*\nPackage gocui allows to create console user interfaces.\n\nCreate a new GUI:\n\n\tg, err := gocui.NewGui(gocui.OutputNormal)\n\tif err != nil {\n\t\t// handle error\n\t}\n\tdefer g.Close()\n\n\t// Set GUI managers and key bindings\n\t// ...\n\n\tif err := g.MainLoop(); err != nil && err != gocui.ErrQuit {\n\t\t// handle error\n\t}\n\nSet GUI managers:\n\n\tg.SetManager(mgr1, mgr2)\n\nManagers are in charge of GUI's layout and can be used to build widgets. On\neach iteration of the GUI's main loop, the Layout function of each configured\nmanager is executed. Managers are used to set-up and update the application's\nmain views, being possible to freely change them during execution. Also, it is\nimportant to mention that a main loop iteration is executed on each reported\nevent (key-press, mouse event, window resize, etc).\n\nGUIs are composed by Views, you can think of it as buffers. Views implement the\nio.ReadWriter interface, so you can just write to them if you want to modify\ntheir content. The same is valid for reading.\n\nCreate and initialize a view with absolute coordinates:\n\n\tif v, err := g.SetView(\"viewname\", 2, 2, 22, 7); err != nil {\n\t\tif err != gocui.ErrUnknownView {\n\t\t\t// handle error\n\t\t}\n\t\tfmt.Fprintln(v, \"This is a new view\")\n\t\t// ...\n\t}\n\nViews can also be created using relative coordinates:\n\n\tmaxX, maxY := g.Size()\n\tif v, err := g.SetView(\"viewname\", maxX/2-30, maxY/2, maxX/2+30, maxY/2+2); err != nil {\n\t\t// ...\n\t}\n\nConfigure keybindings:\n\n\tif err := g.SetKeybinding(\"viewname\", gocui.KeyEnter, gocui.ModNone, fcn); err != nil {\n\t\t// handle error\n\t}\n\ngocui implements full mouse support that can be enabled with:\n\n\tg.Mouse = true\n\nMouse events are handled like any other keybinding:\n\n\tif err := g.SetKeybinding(\"viewname\", gocui.MouseLeft, gocui.ModNone, fcn); err != nil {\n\t\t// handle error\n\t}\n\nIMPORTANT: Views can only be created, destroyed or updated in three ways: from\nthe Layout function within managers, from keybinding callbacks or via\n*Gui.Update(). The reason for this is that it allows gocui to be\nconcurrent-safe. So, if you want to update your GUI from a goroutine, you must\nuse *Gui.Update(). For example:\n\n\tg.Update(func(g *gocui.Gui) error {\n\t\tv, err := g.View(\"viewname\")\n\t\tif err != nil {\n\t\t\t// handle error\n\t\t}\n\t\tv.Clear()\n\t\tfmt.Fprintln(v, \"Writing from different goroutines\")\n\t\treturn nil\n\t})\n\nBy default, gocui provides a basic edition mode. This mode can be extended\nand customized creating a new Editor and assigning it to *View.Editor:\n\n\ttype Editor interface {\n\t\tEdit(v *View, key Key, ch rune, mod Modifier)\n\t}\n\nDefaultEditor can be taken as example to create your own custom Editor:\n\n\tvar DefaultEditor Editor = EditorFunc(simpleEditor)\n\n\tfunc simpleEditor(v *View, key Key, ch rune, mod Modifier) {\n\t\tswitch {\n\t\tcase ch != 0 && mod == 0:\n\t\t\tv.EditWrite(ch)\n\t\tcase key == KeySpace:\n\t\t\tv.EditWrite(' ')\n\t\tcase key == KeyBackspace || key == KeyBackspace2:\n\t\t\tv.EditDelete(true)\n\t\t// ...\n\t\t}\n\t}\n\nColored text:\n\nViews allow to add colored text using ANSI colors. For example:\n\n\tfmt.Fprintln(v, \"\\x1b[0;31mHello world\")\n\nFor more information, see the examples in folder \"_examples/\".\n*/\npackage gocui\n"
        },
        {
          "name": "edit.go",
          "type": "blob",
          "size": 7.4677734375,
          "content": "// Copyright 2014 The gocui Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gocui\n\nimport \"errors\"\n\nconst maxInt = int(^uint(0) >> 1)\n\n// Editor interface must be satisfied by gocui editors.\ntype Editor interface {\n\tEdit(v *View, key Key, ch rune, mod Modifier)\n}\n\n// The EditorFunc type is an adapter to allow the use of ordinary functions as\n// Editors. If f is a function with the appropriate signature, EditorFunc(f)\n// is an Editor object that calls f.\ntype EditorFunc func(v *View, key Key, ch rune, mod Modifier)\n\n// Edit calls f(v, key, ch, mod)\nfunc (f EditorFunc) Edit(v *View, key Key, ch rune, mod Modifier) {\n\tf(v, key, ch, mod)\n}\n\n// DefaultEditor is the default editor.\nvar DefaultEditor Editor = EditorFunc(simpleEditor)\n\n// simpleEditor is used as the default gocui editor.\nfunc simpleEditor(v *View, key Key, ch rune, mod Modifier) {\n\tswitch {\n\tcase ch != 0 && mod == 0:\n\t\tv.EditWrite(ch)\n\tcase key == KeySpace:\n\t\tv.EditWrite(' ')\n\tcase key == KeyBackspace || key == KeyBackspace2:\n\t\tv.EditDelete(true)\n\tcase key == KeyDelete:\n\t\tv.EditDelete(false)\n\tcase key == KeyInsert:\n\t\tv.Overwrite = !v.Overwrite\n\tcase key == KeyEnter:\n\t\tv.EditNewLine()\n\tcase key == KeyArrowDown:\n\t\tv.MoveCursor(0, 1, false)\n\tcase key == KeyArrowUp:\n\t\tv.MoveCursor(0, -1, false)\n\tcase key == KeyArrowLeft:\n\t\tv.MoveCursor(-1, 0, false)\n\tcase key == KeyArrowRight:\n\t\tv.MoveCursor(1, 0, false)\n\t}\n}\n\n// EditWrite writes a rune at the cursor position.\nfunc (v *View) EditWrite(ch rune) {\n\tv.writeRune(v.cx, v.cy, ch)\n\tv.MoveCursor(1, 0, true)\n}\n\n// EditDelete deletes a rune at the cursor position. back determines the\n// direction.\nfunc (v *View) EditDelete(back bool) {\n\tx, y := v.ox+v.cx, v.oy+v.cy\n\tif y < 0 {\n\t\treturn\n\t} else if y >= len(v.viewLines) {\n\t\tv.MoveCursor(-1, 0, true)\n\t\treturn\n\t}\n\n\tmaxX, _ := v.Size()\n\tif back {\n\t\tif x == 0 { // start of the line\n\t\t\tif y < 1 {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar maxPrevWidth int\n\t\t\tif v.Wrap {\n\t\t\t\tmaxPrevWidth = maxX\n\t\t\t} else {\n\t\t\t\tmaxPrevWidth = maxInt\n\t\t\t}\n\n\t\t\tif v.viewLines[y].linesX == 0 { // regular line\n\t\t\t\tv.mergeLines(v.cy - 1)\n\t\t\t\tif len(v.viewLines[y-1].line) < maxPrevWidth {\n\t\t\t\t\tv.MoveCursor(-1, 0, true)\n\t\t\t\t}\n\t\t\t} else { // wrapped line\n\t\t\t\tv.deleteRune(len(v.viewLines[y-1].line)-1, v.cy-1)\n\t\t\t\tv.MoveCursor(-1, 0, true)\n\t\t\t}\n\t\t} else { // middle/end of the line\n\t\t\tv.deleteRune(v.cx-1, v.cy)\n\t\t\tv.MoveCursor(-1, 0, true)\n\t\t}\n\t} else {\n\t\tif x == len(v.viewLines[y].line) { // end of the line\n\t\t\tv.mergeLines(v.cy)\n\t\t} else { // start/middle of the line\n\t\t\tv.deleteRune(v.cx, v.cy)\n\t\t}\n\t}\n}\n\n// EditNewLine inserts a new line under the cursor.\nfunc (v *View) EditNewLine() {\n\tv.breakLine(v.cx, v.cy)\n\tv.ox = 0\n\tv.cx = 0\n\tv.MoveCursor(0, 1, true)\n}\n\n// MoveCursor moves the cursor taking into account the width of the line/view,\n// displacing the origin if necessary.\nfunc (v *View) MoveCursor(dx, dy int, writeMode bool) {\n\tmaxX, maxY := v.Size()\n\tcx, cy := v.cx+dx, v.cy+dy\n\tx, y := v.ox+cx, v.oy+cy\n\n\tvar curLineWidth, prevLineWidth int\n\t// get the width of the current line\n\tif writeMode {\n\t\tif v.Wrap {\n\t\t\tcurLineWidth = maxX - 1\n\t\t} else {\n\t\t\tcurLineWidth = maxInt\n\t\t}\n\t} else {\n\t\tif y >= 0 && y < len(v.viewLines) {\n\t\t\tcurLineWidth = len(v.viewLines[y].line)\n\t\t\tif v.Wrap && curLineWidth >= maxX {\n\t\t\t\tcurLineWidth = maxX - 1\n\t\t\t}\n\t\t} else {\n\t\t\tcurLineWidth = 0\n\t\t}\n\t}\n\t// get the width of the previous line\n\tif y-1 >= 0 && y-1 < len(v.viewLines) {\n\t\tprevLineWidth = len(v.viewLines[y-1].line)\n\t} else {\n\t\tprevLineWidth = 0\n\t}\n\n\t// adjust cursor's x position and view's x origin\n\tif x > curLineWidth { // move to next line\n\t\tif dx > 0 { // horizontal movement\n\t\t\tcy++\n\t\t\tif writeMode || v.oy+cy < len(v.viewLines) {\n\t\t\t\tif !v.Wrap {\n\t\t\t\t\tv.ox = 0\n\t\t\t\t}\n\t\t\t\tv.cx = 0\n\t\t\t}\n\t\t} else { // vertical movement\n\t\t\tif curLineWidth > 0 { // move cursor to the EOL\n\t\t\t\tif v.Wrap {\n\t\t\t\t\tv.cx = curLineWidth\n\t\t\t\t} else {\n\t\t\t\t\tncx := curLineWidth - v.ox\n\t\t\t\t\tif ncx < 0 {\n\t\t\t\t\t\tv.ox += ncx\n\t\t\t\t\t\tif v.ox < 0 {\n\t\t\t\t\t\t\tv.ox = 0\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv.cx = 0\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv.cx = ncx\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif writeMode || v.oy+cy < len(v.viewLines) {\n\t\t\t\t\tif !v.Wrap {\n\t\t\t\t\t\tv.ox = 0\n\t\t\t\t\t}\n\t\t\t\t\tv.cx = 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if cx < 0 {\n\t\tif !v.Wrap && v.ox > 0 { // move origin to the left\n\t\t\tv.ox += cx\n\t\t\tv.cx = 0\n\t\t} else { // move to previous line\n\t\t\tcy--\n\t\t\tif prevLineWidth > 0 {\n\t\t\t\tif !v.Wrap { // set origin so the EOL is visible\n\t\t\t\t\tnox := prevLineWidth - maxX + 1\n\t\t\t\t\tif nox < 0 {\n\t\t\t\t\t\tv.ox = 0\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv.ox = nox\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv.cx = prevLineWidth\n\t\t\t} else {\n\t\t\t\tif !v.Wrap {\n\t\t\t\t\tv.ox = 0\n\t\t\t\t}\n\t\t\t\tv.cx = 0\n\t\t\t}\n\t\t}\n\t} else { // stay on the same line\n\t\tif v.Wrap {\n\t\t\tv.cx = cx\n\t\t} else {\n\t\t\tif cx >= maxX {\n\t\t\t\tv.ox += cx - maxX + 1\n\t\t\t\tv.cx = maxX\n\t\t\t} else {\n\t\t\t\tv.cx = cx\n\t\t\t}\n\t\t}\n\t}\n\n\t// adjust cursor's y position and view's y origin\n\tif cy < 0 {\n\t\tif v.oy > 0 {\n\t\t\tv.oy--\n\t\t}\n\t} else if writeMode || v.oy+cy < len(v.viewLines) {\n\t\tif cy >= maxY {\n\t\t\tv.oy++\n\t\t} else {\n\t\t\tv.cy = cy\n\t\t}\n\t}\n}\n\n// writeRune writes a rune into the view's internal buffer, at the\n// position corresponding to the point (x, y). The length of the internal\n// buffer is increased if the point is out of bounds. Overwrite mode is\n// governed by the value of View.overwrite.\nfunc (v *View) writeRune(x, y int, ch rune) error {\n\tv.tainted = true\n\n\tx, y, err := v.realPosition(x, y)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif x < 0 || y < 0 {\n\t\treturn errors.New(\"invalid point\")\n\t}\n\n\tif y >= len(v.lines) {\n\t\ts := make([][]cell, y-len(v.lines)+1)\n\t\tv.lines = append(v.lines, s...)\n\t}\n\n\tolen := len(v.lines[y])\n\n\tvar s []cell\n\tif x >= len(v.lines[y]) {\n\t\ts = make([]cell, x-len(v.lines[y])+1)\n\t} else if !v.Overwrite {\n\t\ts = make([]cell, 1)\n\t}\n\tv.lines[y] = append(v.lines[y], s...)\n\n\tif !v.Overwrite || (v.Overwrite && x >= olen-1) {\n\t\tcopy(v.lines[y][x+1:], v.lines[y][x:])\n\t}\n\tv.lines[y][x] = cell{\n\t\tfgColor: v.FgColor,\n\t\tbgColor: v.BgColor,\n\t\tchr:     ch,\n\t}\n\n\treturn nil\n}\n\n// deleteRune removes a rune from the view's internal buffer, at the\n// position corresponding to the point (x, y).\nfunc (v *View) deleteRune(x, y int) error {\n\tv.tainted = true\n\n\tx, y, err := v.realPosition(x, y)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif x < 0 || y < 0 || y >= len(v.lines) || x >= len(v.lines[y]) {\n\t\treturn errors.New(\"invalid point\")\n\t}\n\tv.lines[y] = append(v.lines[y][:x], v.lines[y][x+1:]...)\n\treturn nil\n}\n\n// mergeLines merges the lines \"y\" and \"y+1\" if possible.\nfunc (v *View) mergeLines(y int) error {\n\tv.tainted = true\n\n\t_, y, err := v.realPosition(0, y)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif y < 0 || y >= len(v.lines) {\n\t\treturn errors.New(\"invalid point\")\n\t}\n\n\tif y < len(v.lines)-1 { // otherwise we don't need to merge anything\n\t\tv.lines[y] = append(v.lines[y], v.lines[y+1]...)\n\t\tv.lines = append(v.lines[:y+1], v.lines[y+2:]...)\n\t}\n\treturn nil\n}\n\n// breakLine breaks a line of the internal buffer at the position corresponding\n// to the point (x, y).\nfunc (v *View) breakLine(x, y int) error {\n\tv.tainted = true\n\n\tx, y, err := v.realPosition(x, y)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif y < 0 || y >= len(v.lines) {\n\t\treturn errors.New(\"invalid point\")\n\t}\n\n\tvar left, right []cell\n\tif x < len(v.lines[y]) { // break line\n\t\tleft = make([]cell, len(v.lines[y][:x]))\n\t\tcopy(left, v.lines[y][:x])\n\t\tright = make([]cell, len(v.lines[y][x:]))\n\t\tcopy(right, v.lines[y][x:])\n\t} else { // new empty line\n\t\tleft = v.lines[y]\n\t}\n\n\tlines := make([][]cell, len(v.lines)+1)\n\tlines[y] = left\n\tlines[y+1] = right\n\tcopy(lines, v.lines[:y])\n\tcopy(lines[y+2:], v.lines[y+1:])\n\tv.lines = lines\n\treturn nil\n}\n"
        },
        {
          "name": "escape.go",
          "type": "blob",
          "size": 4.9814453125,
          "content": "// Copyright 2014 The gocui Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gocui\n\nimport (\n\t\"errors\"\n\t\"strconv\"\n)\n\ntype escapeInterpreter struct {\n\tstate                  escapeState\n\tcurch                  rune\n\tcsiParam               []string\n\tcurFgColor, curBgColor Attribute\n\tmode                   OutputMode\n}\n\ntype escapeState int\n\nconst (\n\tstateNone escapeState = iota\n\tstateEscape\n\tstateCSI\n\tstateParams\n)\n\nvar (\n\terrNotCSI        = errors.New(\"Not a CSI escape sequence\")\n\terrCSIParseError = errors.New(\"CSI escape sequence parsing error\")\n\terrCSITooLong    = errors.New(\"CSI escape sequence is too long\")\n)\n\n// runes in case of error will output the non-parsed runes as a string.\nfunc (ei *escapeInterpreter) runes() []rune {\n\tswitch ei.state {\n\tcase stateNone:\n\t\treturn []rune{0x1b}\n\tcase stateEscape:\n\t\treturn []rune{0x1b, ei.curch}\n\tcase stateCSI:\n\t\treturn []rune{0x1b, '[', ei.curch}\n\tcase stateParams:\n\t\tret := []rune{0x1b, '['}\n\t\tfor _, s := range ei.csiParam {\n\t\t\tret = append(ret, []rune(s)...)\n\t\t\tret = append(ret, ';')\n\t\t}\n\t\treturn append(ret, ei.curch)\n\t}\n\treturn nil\n}\n\n// newEscapeInterpreter returns an escapeInterpreter that will be able to parse\n// terminal escape sequences.\nfunc newEscapeInterpreter(mode OutputMode) *escapeInterpreter {\n\tei := &escapeInterpreter{\n\t\tstate:      stateNone,\n\t\tcurFgColor: ColorDefault,\n\t\tcurBgColor: ColorDefault,\n\t\tmode:       mode,\n\t}\n\treturn ei\n}\n\n// reset sets the escapeInterpreter in initial state.\nfunc (ei *escapeInterpreter) reset() {\n\tei.state = stateNone\n\tei.curFgColor = ColorDefault\n\tei.curBgColor = ColorDefault\n\tei.csiParam = nil\n}\n\n// parseOne parses a rune. If isEscape is true, it means that the rune is part\n// of an escape sequence, and as such should not be printed verbatim. Otherwise,\n// it's not an escape sequence.\nfunc (ei *escapeInterpreter) parseOne(ch rune) (isEscape bool, err error) {\n\t// Sanity checks\n\tif len(ei.csiParam) > 20 {\n\t\treturn false, errCSITooLong\n\t}\n\tif len(ei.csiParam) > 0 && len(ei.csiParam[len(ei.csiParam)-1]) > 255 {\n\t\treturn false, errCSITooLong\n\t}\n\n\tei.curch = ch\n\n\tswitch ei.state {\n\tcase stateNone:\n\t\tif ch == 0x1b {\n\t\t\tei.state = stateEscape\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, nil\n\tcase stateEscape:\n\t\tif ch == '[' {\n\t\t\tei.state = stateCSI\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, errNotCSI\n\tcase stateCSI:\n\t\tswitch {\n\t\tcase ch >= '0' && ch <= '9':\n\t\t\tei.csiParam = append(ei.csiParam, \"\")\n\t\tcase ch == 'm':\n\t\t\tei.csiParam = append(ei.csiParam, \"0\")\n\t\tdefault:\n\t\t\treturn false, errCSIParseError\n\t\t}\n\t\tei.state = stateParams\n\t\tfallthrough\n\tcase stateParams:\n\t\tswitch {\n\t\tcase ch >= '0' && ch <= '9':\n\t\t\tei.csiParam[len(ei.csiParam)-1] += string(ch)\n\t\t\treturn true, nil\n\t\tcase ch == ';':\n\t\t\tei.csiParam = append(ei.csiParam, \"\")\n\t\t\treturn true, nil\n\t\tcase ch == 'm':\n\t\t\tvar err error\n\t\t\tswitch ei.mode {\n\t\t\tcase OutputNormal:\n\t\t\t\terr = ei.outputNormal()\n\t\t\tcase Output256:\n\t\t\t\terr = ei.output256()\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn false, errCSIParseError\n\t\t\t}\n\n\t\t\tei.state = stateNone\n\t\t\tei.csiParam = nil\n\t\t\treturn true, nil\n\t\tdefault:\n\t\t\treturn false, errCSIParseError\n\t\t}\n\t}\n\treturn false, nil\n}\n\n// outputNormal provides 8 different colors:\n//   black, red, green, yellow, blue, magenta, cyan, white\nfunc (ei *escapeInterpreter) outputNormal() error {\n\tfor _, param := range ei.csiParam {\n\t\tp, err := strconv.Atoi(param)\n\t\tif err != nil {\n\t\t\treturn errCSIParseError\n\t\t}\n\n\t\tswitch {\n\t\tcase p >= 30 && p <= 37:\n\t\t\tei.curFgColor = Attribute(p - 30 + 1)\n\t\tcase p == 39:\n\t\t\tei.curFgColor = ColorDefault\n\t\tcase p >= 40 && p <= 47:\n\t\t\tei.curBgColor = Attribute(p - 40 + 1)\n\t\tcase p == 49:\n\t\t\tei.curBgColor = ColorDefault\n\t\tcase p == 1:\n\t\t\tei.curFgColor |= AttrBold\n\t\tcase p == 4:\n\t\t\tei.curFgColor |= AttrUnderline\n\t\tcase p == 7:\n\t\t\tei.curFgColor |= AttrReverse\n\t\tcase p == 0:\n\t\t\tei.curFgColor = ColorDefault\n\t\t\tei.curBgColor = ColorDefault\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// output256 allows you to leverage the 256-colors terminal mode:\n//   0x01 - 0x08: the 8 colors as in OutputNormal\n//   0x09 - 0x10: Color* | AttrBold\n//   0x11 - 0xe8: 216 different colors\n//   0xe9 - 0x1ff: 24 different shades of grey\nfunc (ei *escapeInterpreter) output256() error {\n\tif len(ei.csiParam) < 3 {\n\t\treturn ei.outputNormal()\n\t}\n\n\tmode, err := strconv.Atoi(ei.csiParam[1])\n\tif err != nil {\n\t\treturn errCSIParseError\n\t}\n\tif mode != 5 {\n\t\treturn ei.outputNormal()\n\t}\n\n\tfgbg, err := strconv.Atoi(ei.csiParam[0])\n\tif err != nil {\n\t\treturn errCSIParseError\n\t}\n\tcolor, err := strconv.Atoi(ei.csiParam[2])\n\tif err != nil {\n\t\treturn errCSIParseError\n\t}\n\n\tswitch fgbg {\n\tcase 38:\n\t\tei.curFgColor = Attribute(color + 1)\n\n\t\tfor _, param := range ei.csiParam[3:] {\n\t\t\tp, err := strconv.Atoi(param)\n\t\t\tif err != nil {\n\t\t\t\treturn errCSIParseError\n\t\t\t}\n\n\t\t\tswitch {\n\t\t\tcase p == 1:\n\t\t\t\tei.curFgColor |= AttrBold\n\t\t\tcase p == 4:\n\t\t\t\tei.curFgColor |= AttrUnderline\n\t\t\tcase p == 7:\n\t\t\t\tei.curFgColor |= AttrReverse\n\t\t\t}\n\t\t}\n\tcase 48:\n\t\tei.curBgColor = Attribute(color + 1)\n\tdefault:\n\t\treturn errCSIParseError\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.083984375,
          "content": "module github.com/jroimartin/gocui\n\ngo 1.16\n\nrequire github.com/nsf/termbox-go v1.1.1\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.337890625,
          "content": "github.com/mattn/go-runewidth v0.0.9 h1:Lm995f3rfxdpd6TSmuVCHVb/QhupuXlYr8sCI/QdE+0=\ngithub.com/mattn/go-runewidth v0.0.9/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=\ngithub.com/nsf/termbox-go v1.1.1 h1:nksUPLCb73Q++DwbYUBEglYBRPZyoXJdrj5L+TkjyZY=\ngithub.com/nsf/termbox-go v1.1.1/go.mod h1:T0cTdVuOwf7pHQNtfhnEbzHbcNyCEcVU4YPpouCbVxo=\n"
        },
        {
          "name": "gui.go",
          "type": "blob",
          "size": 15.8505859375,
          "content": "// Copyright 2014 The gocui Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gocui\n\nimport (\n\t\"errors\"\n\n\t\"github.com/nsf/termbox-go\"\n)\n\nvar (\n\t// ErrQuit is used to decide if the MainLoop finished successfully.\n\tErrQuit = errors.New(\"quit\")\n\n\t// ErrUnknownView allows to assert if a View must be initialized.\n\tErrUnknownView = errors.New(\"unknown view\")\n)\n\n// OutputMode represents the terminal's output mode (8 or 256 colors).\ntype OutputMode termbox.OutputMode\n\nconst (\n\t// OutputNormal provides 8-colors terminal mode.\n\tOutputNormal = OutputMode(termbox.OutputNormal)\n\n\t// Output256 provides 256-colors terminal mode.\n\tOutput256 = OutputMode(termbox.Output256)\n)\n\n// Gui represents the whole User Interface, including the views, layouts\n// and keybindings.\ntype Gui struct {\n\ttbEvents    chan termbox.Event\n\tuserEvents  chan userEvent\n\tviews       []*View\n\tcurrentView *View\n\tmanagers    []Manager\n\tkeybindings []*keybinding\n\tmaxX, maxY  int\n\toutputMode  OutputMode\n\n\t// BgColor and FgColor allow to configure the background and foreground\n\t// colors of the GUI.\n\tBgColor, FgColor Attribute\n\n\t// SelBgColor and SelFgColor allow to configure the background and\n\t// foreground colors of the frame of the current view.\n\tSelBgColor, SelFgColor Attribute\n\n\t// If Highlight is true, Sel{Bg,Fg}Colors will be used to draw the\n\t// frame of the current view.\n\tHighlight bool\n\n\t// If Cursor is true then the cursor is enabled.\n\tCursor bool\n\n\t// If Mouse is true then mouse events will be enabled.\n\tMouse bool\n\n\t// If InputEsc is true, when ESC sequence is in the buffer and it doesn't\n\t// match any known sequence, ESC means KeyEsc.\n\tInputEsc bool\n\n\t// If ASCII is true then use ASCII instead of unicode to draw the\n\t// interface. Using ASCII is more portable.\n\tASCII bool\n}\n\n// NewGui returns a new Gui object with a given output mode.\nfunc NewGui(mode OutputMode) (*Gui, error) {\n\tif err := termbox.Init(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tg := &Gui{}\n\n\tg.outputMode = mode\n\ttermbox.SetOutputMode(termbox.OutputMode(mode))\n\n\tg.tbEvents = make(chan termbox.Event, 20)\n\tg.userEvents = make(chan userEvent, 20)\n\n\tg.maxX, g.maxY = termbox.Size()\n\n\tg.BgColor, g.FgColor = ColorDefault, ColorDefault\n\tg.SelBgColor, g.SelFgColor = ColorDefault, ColorDefault\n\n\treturn g, nil\n}\n\n// Close finalizes the library. It should be called after a successful\n// initialization and when gocui is not needed anymore.\nfunc (g *Gui) Close() {\n\ttermbox.Close()\n}\n\n// Size returns the terminal's size.\nfunc (g *Gui) Size() (x, y int) {\n\treturn g.maxX, g.maxY\n}\n\n// SetRune writes a rune at the given point, relative to the top-left\n// corner of the terminal. It checks if the position is valid and applies\n// the given colors.\nfunc (g *Gui) SetRune(x, y int, ch rune, fgColor, bgColor Attribute) error {\n\tif x < 0 || y < 0 || x >= g.maxX || y >= g.maxY {\n\t\treturn errors.New(\"invalid point\")\n\t}\n\ttermbox.SetCell(x, y, ch, termbox.Attribute(fgColor), termbox.Attribute(bgColor))\n\treturn nil\n}\n\n// Rune returns the rune contained in the cell at the given position.\n// It checks if the position is valid.\nfunc (g *Gui) Rune(x, y int) (rune, error) {\n\tif x < 0 || y < 0 || x >= g.maxX || y >= g.maxY {\n\t\treturn ' ', errors.New(\"invalid point\")\n\t}\n\tc := termbox.CellBuffer()[y*g.maxX+x]\n\treturn c.Ch, nil\n}\n\n// SetView creates a new view with its top-left corner at (x0, y0)\n// and the bottom-right one at (x1, y1). If a view with the same name\n// already exists, its dimensions are updated; otherwise, the error\n// ErrUnknownView is returned, which allows to assert if the View must\n// be initialized. It checks if the position is valid.\nfunc (g *Gui) SetView(name string, x0, y0, x1, y1 int) (*View, error) {\n\tif x0 >= x1 || y0 >= y1 {\n\t\treturn nil, errors.New(\"invalid dimensions\")\n\t}\n\tif name == \"\" {\n\t\treturn nil, errors.New(\"invalid name\")\n\t}\n\n\tif v, err := g.View(name); err == nil {\n\t\tv.x0 = x0\n\t\tv.y0 = y0\n\t\tv.x1 = x1\n\t\tv.y1 = y1\n\t\tv.tainted = true\n\t\treturn v, nil\n\t}\n\n\tv := newView(name, x0, y0, x1, y1, g.outputMode)\n\tv.BgColor, v.FgColor = g.BgColor, g.FgColor\n\tv.SelBgColor, v.SelFgColor = g.SelBgColor, g.SelFgColor\n\tg.views = append(g.views, v)\n\treturn v, ErrUnknownView\n}\n\n// SetViewOnTop sets the given view on top of the existing ones.\nfunc (g *Gui) SetViewOnTop(name string) (*View, error) {\n\tfor i, v := range g.views {\n\t\tif v.name == name {\n\t\t\ts := append(g.views[:i], g.views[i+1:]...)\n\t\t\tg.views = append(s, v)\n\t\t\treturn v, nil\n\t\t}\n\t}\n\treturn nil, ErrUnknownView\n}\n\n// SetViewOnBottom sets the given view on bottom of the existing ones.\nfunc (g *Gui) SetViewOnBottom(name string) (*View, error) {\n\tfor i, v := range g.views {\n\t\tif v.name == name {\n\t\t\ts := append(g.views[:i], g.views[i+1:]...)\n\t\t\tg.views = append([]*View{v}, s...)\n\t\t\treturn v, nil\n\t\t}\n\t}\n\treturn nil, ErrUnknownView\n}\n\n// Views returns all the views in the GUI.\nfunc (g *Gui) Views() []*View {\n\treturn g.views\n}\n\n// View returns a pointer to the view with the given name, or error\n// ErrUnknownView if a view with that name does not exist.\nfunc (g *Gui) View(name string) (*View, error) {\n\tfor _, v := range g.views {\n\t\tif v.name == name {\n\t\t\treturn v, nil\n\t\t}\n\t}\n\treturn nil, ErrUnknownView\n}\n\n// ViewByPosition returns a pointer to a view matching the given position, or\n// error ErrUnknownView if a view in that position does not exist.\nfunc (g *Gui) ViewByPosition(x, y int) (*View, error) {\n\t// traverse views in reverse order checking top views first\n\tfor i := len(g.views); i > 0; i-- {\n\t\tv := g.views[i-1]\n\t\tif x > v.x0 && x < v.x1 && y > v.y0 && y < v.y1 {\n\t\t\treturn v, nil\n\t\t}\n\t}\n\treturn nil, ErrUnknownView\n}\n\n// ViewPosition returns the coordinates of the view with the given name, or\n// error ErrUnknownView if a view with that name does not exist.\nfunc (g *Gui) ViewPosition(name string) (x0, y0, x1, y1 int, err error) {\n\tfor _, v := range g.views {\n\t\tif v.name == name {\n\t\t\treturn v.x0, v.y0, v.x1, v.y1, nil\n\t\t}\n\t}\n\treturn 0, 0, 0, 0, ErrUnknownView\n}\n\n// DeleteView deletes a view by name.\nfunc (g *Gui) DeleteView(name string) error {\n\tfor i, v := range g.views {\n\t\tif v.name == name {\n\t\t\tg.views = append(g.views[:i], g.views[i+1:]...)\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn ErrUnknownView\n}\n\n// SetCurrentView gives the focus to a given view.\nfunc (g *Gui) SetCurrentView(name string) (*View, error) {\n\tfor _, v := range g.views {\n\t\tif v.name == name {\n\t\t\tg.currentView = v\n\t\t\treturn v, nil\n\t\t}\n\t}\n\treturn nil, ErrUnknownView\n}\n\n// CurrentView returns the currently focused view, or nil if no view\n// owns the focus.\nfunc (g *Gui) CurrentView() *View {\n\treturn g.currentView\n}\n\n// SetKeybinding creates a new keybinding. If viewname equals to \"\"\n// (empty string) then the keybinding will apply to all views. key must\n// be a rune or a Key.\nfunc (g *Gui) SetKeybinding(viewname string, key interface{}, mod Modifier, handler func(*Gui, *View) error) error {\n\tvar kb *keybinding\n\n\tk, ch, err := getKey(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\tkb = newKeybinding(viewname, k, ch, mod, handler)\n\tg.keybindings = append(g.keybindings, kb)\n\treturn nil\n}\n\n// DeleteKeybinding deletes a keybinding.\nfunc (g *Gui) DeleteKeybinding(viewname string, key interface{}, mod Modifier) error {\n\tk, ch, err := getKey(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor i, kb := range g.keybindings {\n\t\tif kb.viewName == viewname && kb.ch == ch && kb.key == k && kb.mod == mod {\n\t\t\tg.keybindings = append(g.keybindings[:i], g.keybindings[i+1:]...)\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errors.New(\"keybinding not found\")\n}\n\n// DeleteKeybindings deletes all keybindings of view.\nfunc (g *Gui) DeleteKeybindings(viewname string) {\n\tvar s []*keybinding\n\tfor _, kb := range g.keybindings {\n\t\tif kb.viewName != viewname {\n\t\t\ts = append(s, kb)\n\t\t}\n\t}\n\tg.keybindings = s\n}\n\n// getKey takes an empty interface with a key and returns the corresponding\n// typed Key or rune.\nfunc getKey(key interface{}) (Key, rune, error) {\n\tswitch t := key.(type) {\n\tcase Key:\n\t\treturn t, 0, nil\n\tcase rune:\n\t\treturn 0, t, nil\n\tdefault:\n\t\treturn 0, 0, errors.New(\"unknown type\")\n\t}\n}\n\n// userEvent represents an event triggered by the user.\ntype userEvent struct {\n\tf func(*Gui) error\n}\n\n// Update executes the passed function. This method can be called safely from a\n// goroutine in order to update the GUI. It is important to note that the\n// passed function won't be executed immediately, instead it will be added to\n// the user events queue. Given that Update spawns a goroutine, the order in\n// which the user events will be handled is not guaranteed.\nfunc (g *Gui) Update(f func(*Gui) error) {\n\tgo func() { g.userEvents <- userEvent{f: f} }()\n}\n\n// A Manager is in charge of GUI's layout and can be used to build widgets.\ntype Manager interface {\n\t// Layout is called every time the GUI is redrawn, it must contain the\n\t// base views and its initializations.\n\tLayout(*Gui) error\n}\n\n// The ManagerFunc type is an adapter to allow the use of ordinary functions as\n// Managers. If f is a function with the appropriate signature, ManagerFunc(f)\n// is an Manager object that calls f.\ntype ManagerFunc func(*Gui) error\n\n// Layout calls f(g)\nfunc (f ManagerFunc) Layout(g *Gui) error {\n\treturn f(g)\n}\n\n// SetManager sets the given GUI managers. It deletes all views and\n// keybindings.\nfunc (g *Gui) SetManager(managers ...Manager) {\n\tg.managers = managers\n\tg.currentView = nil\n\tg.views = nil\n\tg.keybindings = nil\n\n\tgo func() { g.tbEvents <- termbox.Event{Type: termbox.EventResize} }()\n}\n\n// SetManagerFunc sets the given manager function. It deletes all views and\n// keybindings.\nfunc (g *Gui) SetManagerFunc(manager func(*Gui) error) {\n\tg.SetManager(ManagerFunc(manager))\n}\n\n// MainLoop runs the main loop until an error is returned. A successful\n// finish should return ErrQuit.\nfunc (g *Gui) MainLoop() error {\n\tgo func() {\n\t\tfor {\n\t\t\tg.tbEvents <- termbox.PollEvent()\n\t\t}\n\t}()\n\n\tinputMode := termbox.InputAlt\n\tif g.InputEsc {\n\t\tinputMode = termbox.InputEsc\n\t}\n\tif g.Mouse {\n\t\tinputMode |= termbox.InputMouse\n\t}\n\ttermbox.SetInputMode(inputMode)\n\n\tif err := g.flush(); err != nil {\n\t\treturn err\n\t}\n\tfor {\n\t\tselect {\n\t\tcase ev := <-g.tbEvents:\n\t\t\tif err := g.handleEvent(&ev); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase ev := <-g.userEvents:\n\t\t\tif err := ev.f(g); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif err := g.consumeevents(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := g.flush(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\n// consumeevents handles the remaining events in the events pool.\nfunc (g *Gui) consumeevents() error {\n\tfor {\n\t\tselect {\n\t\tcase ev := <-g.tbEvents:\n\t\t\tif err := g.handleEvent(&ev); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase ev := <-g.userEvents:\n\t\t\tif err := ev.f(g); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\n// handleEvent handles an event, based on its type (key-press, error,\n// etc.)\nfunc (g *Gui) handleEvent(ev *termbox.Event) error {\n\tswitch ev.Type {\n\tcase termbox.EventKey, termbox.EventMouse:\n\t\treturn g.onKey(ev)\n\tcase termbox.EventError:\n\t\treturn ev.Err\n\tdefault:\n\t\treturn nil\n\t}\n}\n\n// flush updates the gui, re-drawing frames and buffers.\nfunc (g *Gui) flush() error {\n\ttermbox.Clear(termbox.Attribute(g.FgColor), termbox.Attribute(g.BgColor))\n\n\tmaxX, maxY := termbox.Size()\n\t// if GUI's size has changed, we need to redraw all views\n\tif maxX != g.maxX || maxY != g.maxY {\n\t\tfor _, v := range g.views {\n\t\t\tv.tainted = true\n\t\t}\n\t}\n\tg.maxX, g.maxY = maxX, maxY\n\n\tfor _, m := range g.managers {\n\t\tif err := m.Layout(g); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, v := range g.views {\n\t\tif v.Frame {\n\t\t\tvar fgColor, bgColor Attribute\n\t\t\tif g.Highlight && v == g.currentView {\n\t\t\t\tfgColor = g.SelFgColor\n\t\t\t\tbgColor = g.SelBgColor\n\t\t\t} else {\n\t\t\t\tfgColor = g.FgColor\n\t\t\t\tbgColor = g.BgColor\n\t\t\t}\n\n\t\t\tif err := g.drawFrameEdges(v, fgColor, bgColor); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := g.drawFrameCorners(v, fgColor, bgColor); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif v.Title != \"\" {\n\t\t\t\tif err := g.drawTitle(v, fgColor, bgColor); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif err := g.draw(v); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\ttermbox.Flush()\n\treturn nil\n}\n\n// drawFrameEdges draws the horizontal and vertical edges of a view.\nfunc (g *Gui) drawFrameEdges(v *View, fgColor, bgColor Attribute) error {\n\truneH, runeV := '─', '│'\n\tif g.ASCII {\n\t\truneH, runeV = '-', '|'\n\t}\n\n\tfor x := v.x0 + 1; x < v.x1 && x < g.maxX; x++ {\n\t\tif x < 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif v.y0 > -1 && v.y0 < g.maxY {\n\t\t\tif err := g.SetRune(x, v.y0, runeH, fgColor, bgColor); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif v.y1 > -1 && v.y1 < g.maxY {\n\t\t\tif err := g.SetRune(x, v.y1, runeH, fgColor, bgColor); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tfor y := v.y0 + 1; y < v.y1 && y < g.maxY; y++ {\n\t\tif y < 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif v.x0 > -1 && v.x0 < g.maxX {\n\t\t\tif err := g.SetRune(v.x0, y, runeV, fgColor, bgColor); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif v.x1 > -1 && v.x1 < g.maxX {\n\t\t\tif err := g.SetRune(v.x1, y, runeV, fgColor, bgColor); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// drawFrameCorners draws the corners of the view.\nfunc (g *Gui) drawFrameCorners(v *View, fgColor, bgColor Attribute) error {\n\truneTL, runeTR, runeBL, runeBR := '┌', '┐', '└', '┘'\n\tif g.ASCII {\n\t\truneTL, runeTR, runeBL, runeBR = '+', '+', '+', '+'\n\t}\n\n\tcorners := []struct {\n\t\tx, y int\n\t\tch   rune\n\t}{{v.x0, v.y0, runeTL}, {v.x1, v.y0, runeTR}, {v.x0, v.y1, runeBL}, {v.x1, v.y1, runeBR}}\n\n\tfor _, c := range corners {\n\t\tif c.x >= 0 && c.y >= 0 && c.x < g.maxX && c.y < g.maxY {\n\t\t\tif err := g.SetRune(c.x, c.y, c.ch, fgColor, bgColor); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// drawTitle draws the title of the view.\nfunc (g *Gui) drawTitle(v *View, fgColor, bgColor Attribute) error {\n\tif v.y0 < 0 || v.y0 >= g.maxY {\n\t\treturn nil\n\t}\n\n\tfor i, ch := range v.Title {\n\t\tx := v.x0 + i + 2\n\t\tif x < 0 {\n\t\t\tcontinue\n\t\t} else if x > v.x1-2 || x >= g.maxX {\n\t\t\tbreak\n\t\t}\n\t\tif err := g.SetRune(x, v.y0, ch, fgColor, bgColor); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// draw manages the cursor and calls the draw function of a view.\nfunc (g *Gui) draw(v *View) error {\n\tif g.Cursor {\n\t\tif curview := g.currentView; curview != nil {\n\t\t\tvMaxX, vMaxY := curview.Size()\n\t\t\tif curview.cx < 0 {\n\t\t\t\tcurview.cx = 0\n\t\t\t} else if curview.cx >= vMaxX {\n\t\t\t\tcurview.cx = vMaxX - 1\n\t\t\t}\n\t\t\tif curview.cy < 0 {\n\t\t\t\tcurview.cy = 0\n\t\t\t} else if curview.cy >= vMaxY {\n\t\t\t\tcurview.cy = vMaxY - 1\n\t\t\t}\n\n\t\t\tgMaxX, gMaxY := g.Size()\n\t\t\tcx, cy := curview.x0+curview.cx+1, curview.y0+curview.cy+1\n\t\t\tif cx >= 0 && cx < gMaxX && cy >= 0 && cy < gMaxY {\n\t\t\t\ttermbox.SetCursor(cx, cy)\n\t\t\t} else {\n\t\t\t\ttermbox.HideCursor()\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttermbox.HideCursor()\n\t}\n\n\tv.clearRunes()\n\tif err := v.draw(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// onKey manages key-press events. A keybinding handler is called when\n// a key-press or mouse event satisfies a configured keybinding. Furthermore,\n// currentView's internal buffer is modified if currentView.Editable is true.\nfunc (g *Gui) onKey(ev *termbox.Event) error {\n\tswitch ev.Type {\n\tcase termbox.EventKey:\n\t\tmatched, err := g.execKeybindings(g.currentView, ev)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif matched {\n\t\t\tbreak\n\t\t}\n\t\tif g.currentView != nil && g.currentView.Editable && g.currentView.Editor != nil {\n\t\t\tg.currentView.Editor.Edit(g.currentView, Key(ev.Key), ev.Ch, Modifier(ev.Mod))\n\t\t}\n\tcase termbox.EventMouse:\n\t\tmx, my := ev.MouseX, ev.MouseY\n\t\tv, err := g.ViewByPosition(mx, my)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tif err := v.SetCursor(mx-v.x0-1, my-v.y0-1); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := g.execKeybindings(v, ev); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// execKeybindings executes the keybinding handlers that match the passed view\n// and event. The value of matched is true if there is a match and no errors.\nfunc (g *Gui) execKeybindings(v *View, ev *termbox.Event) (matched bool, err error) {\n\tmatched = false\n\tfor _, kb := range g.keybindings {\n\t\tif kb.handler == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif kb.matchKeypress(Key(ev.Key), ev.Ch, Modifier(ev.Mod)) && kb.matchView(v) {\n\t\t\tif err := kb.handler(g, v); err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t\tmatched = true\n\t\t}\n\t}\n\treturn matched, nil\n}\n"
        },
        {
          "name": "keybinding.go",
          "type": "blob",
          "size": 4.8046875,
          "content": "// Copyright 2014 The gocui Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gocui\n\nimport \"github.com/nsf/termbox-go\"\n\n// Keybidings are used to link a given key-press event with a handler.\ntype keybinding struct {\n\tviewName string\n\tkey      Key\n\tch       rune\n\tmod      Modifier\n\thandler  func(*Gui, *View) error\n}\n\n// newKeybinding returns a new Keybinding object.\nfunc newKeybinding(viewname string, key Key, ch rune, mod Modifier, handler func(*Gui, *View) error) (kb *keybinding) {\n\tkb = &keybinding{\n\t\tviewName: viewname,\n\t\tkey:      key,\n\t\tch:       ch,\n\t\tmod:      mod,\n\t\thandler:  handler,\n\t}\n\treturn kb\n}\n\n// matchKeypress returns if the keybinding matches the keypress.\nfunc (kb *keybinding) matchKeypress(key Key, ch rune, mod Modifier) bool {\n\treturn kb.key == key && kb.ch == ch && kb.mod == mod\n}\n\n// matchView returns if the keybinding matches the current view.\nfunc (kb *keybinding) matchView(v *View) bool {\n\tif kb.viewName == \"\" {\n\t\treturn true\n\t}\n\treturn v != nil && kb.viewName == v.name\n}\n\n// Key represents special keys or keys combinations.\ntype Key termbox.Key\n\n// Special keys.\nconst (\n\tKeyF1         Key = Key(termbox.KeyF1)\n\tKeyF2             = Key(termbox.KeyF2)\n\tKeyF3             = Key(termbox.KeyF3)\n\tKeyF4             = Key(termbox.KeyF4)\n\tKeyF5             = Key(termbox.KeyF5)\n\tKeyF6             = Key(termbox.KeyF6)\n\tKeyF7             = Key(termbox.KeyF7)\n\tKeyF8             = Key(termbox.KeyF8)\n\tKeyF9             = Key(termbox.KeyF9)\n\tKeyF10            = Key(termbox.KeyF10)\n\tKeyF11            = Key(termbox.KeyF11)\n\tKeyF12            = Key(termbox.KeyF12)\n\tKeyInsert         = Key(termbox.KeyInsert)\n\tKeyDelete         = Key(termbox.KeyDelete)\n\tKeyHome           = Key(termbox.KeyHome)\n\tKeyEnd            = Key(termbox.KeyEnd)\n\tKeyPgup           = Key(termbox.KeyPgup)\n\tKeyPgdn           = Key(termbox.KeyPgdn)\n\tKeyArrowUp        = Key(termbox.KeyArrowUp)\n\tKeyArrowDown      = Key(termbox.KeyArrowDown)\n\tKeyArrowLeft      = Key(termbox.KeyArrowLeft)\n\tKeyArrowRight     = Key(termbox.KeyArrowRight)\n\n\tMouseLeft      = Key(termbox.MouseLeft)\n\tMouseMiddle    = Key(termbox.MouseMiddle)\n\tMouseRight     = Key(termbox.MouseRight)\n\tMouseRelease   = Key(termbox.MouseRelease)\n\tMouseWheelUp   = Key(termbox.MouseWheelUp)\n\tMouseWheelDown = Key(termbox.MouseWheelDown)\n)\n\n// Keys combinations.\nconst (\n\tKeyCtrlTilde      Key = Key(termbox.KeyCtrlTilde)\n\tKeyCtrl2              = Key(termbox.KeyCtrl2)\n\tKeyCtrlSpace          = Key(termbox.KeyCtrlSpace)\n\tKeyCtrlA              = Key(termbox.KeyCtrlA)\n\tKeyCtrlB              = Key(termbox.KeyCtrlB)\n\tKeyCtrlC              = Key(termbox.KeyCtrlC)\n\tKeyCtrlD              = Key(termbox.KeyCtrlD)\n\tKeyCtrlE              = Key(termbox.KeyCtrlE)\n\tKeyCtrlF              = Key(termbox.KeyCtrlF)\n\tKeyCtrlG              = Key(termbox.KeyCtrlG)\n\tKeyBackspace          = Key(termbox.KeyBackspace)\n\tKeyCtrlH              = Key(termbox.KeyCtrlH)\n\tKeyTab                = Key(termbox.KeyTab)\n\tKeyCtrlI              = Key(termbox.KeyCtrlI)\n\tKeyCtrlJ              = Key(termbox.KeyCtrlJ)\n\tKeyCtrlK              = Key(termbox.KeyCtrlK)\n\tKeyCtrlL              = Key(termbox.KeyCtrlL)\n\tKeyEnter              = Key(termbox.KeyEnter)\n\tKeyCtrlM              = Key(termbox.KeyCtrlM)\n\tKeyCtrlN              = Key(termbox.KeyCtrlN)\n\tKeyCtrlO              = Key(termbox.KeyCtrlO)\n\tKeyCtrlP              = Key(termbox.KeyCtrlP)\n\tKeyCtrlQ              = Key(termbox.KeyCtrlQ)\n\tKeyCtrlR              = Key(termbox.KeyCtrlR)\n\tKeyCtrlS              = Key(termbox.KeyCtrlS)\n\tKeyCtrlT              = Key(termbox.KeyCtrlT)\n\tKeyCtrlU              = Key(termbox.KeyCtrlU)\n\tKeyCtrlV              = Key(termbox.KeyCtrlV)\n\tKeyCtrlW              = Key(termbox.KeyCtrlW)\n\tKeyCtrlX              = Key(termbox.KeyCtrlX)\n\tKeyCtrlY              = Key(termbox.KeyCtrlY)\n\tKeyCtrlZ              = Key(termbox.KeyCtrlZ)\n\tKeyEsc                = Key(termbox.KeyEsc)\n\tKeyCtrlLsqBracket     = Key(termbox.KeyCtrlLsqBracket)\n\tKeyCtrl3              = Key(termbox.KeyCtrl3)\n\tKeyCtrl4              = Key(termbox.KeyCtrl4)\n\tKeyCtrlBackslash      = Key(termbox.KeyCtrlBackslash)\n\tKeyCtrl5              = Key(termbox.KeyCtrl5)\n\tKeyCtrlRsqBracket     = Key(termbox.KeyCtrlRsqBracket)\n\tKeyCtrl6              = Key(termbox.KeyCtrl6)\n\tKeyCtrl7              = Key(termbox.KeyCtrl7)\n\tKeyCtrlSlash          = Key(termbox.KeyCtrlSlash)\n\tKeyCtrlUnderscore     = Key(termbox.KeyCtrlUnderscore)\n\tKeySpace              = Key(termbox.KeySpace)\n\tKeyBackspace2         = Key(termbox.KeyBackspace2)\n\tKeyCtrl8              = Key(termbox.KeyCtrl8)\n)\n\n// Modifier allows to define special keys combinations. They can be used\n// in combination with Keys or Runes when a new keybinding is defined.\ntype Modifier termbox.Modifier\n\n// Modifiers.\nconst (\n\tModNone Modifier = Modifier(0)\n\tModAlt           = Modifier(termbox.ModAlt)\n)\n"
        },
        {
          "name": "view.go",
          "type": "blob",
          "size": 11.4443359375,
          "content": "// Copyright 2014 The gocui Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage gocui\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"strings\"\n\n\t\"github.com/nsf/termbox-go\"\n)\n\n// A View is a window. It maintains its own internal buffer and cursor\n// position.\ntype View struct {\n\tname           string\n\tx0, y0, x1, y1 int\n\tox, oy         int\n\tcx, cy         int\n\tlines          [][]cell\n\treadOffset     int\n\treadCache      string\n\n\ttainted   bool       // marks if the viewBuffer must be updated\n\tviewLines []viewLine // internal representation of the view's buffer\n\n\tei *escapeInterpreter // used to decode ESC sequences on Write\n\n\t// BgColor and FgColor allow to configure the background and foreground\n\t// colors of the View.\n\tBgColor, FgColor Attribute\n\n\t// SelBgColor and SelFgColor are used to configure the background and\n\t// foreground colors of the selected line, when it is highlighted.\n\tSelBgColor, SelFgColor Attribute\n\n\t// If Editable is true, keystrokes will be added to the view's internal\n\t// buffer at the cursor position.\n\tEditable bool\n\n\t// Editor allows to define the editor that manages the edition mode,\n\t// including keybindings or cursor behaviour. DefaultEditor is used by\n\t// default.\n\tEditor Editor\n\n\t// Overwrite enables or disables the overwrite mode of the view.\n\tOverwrite bool\n\n\t// If Highlight is true, Sel{Bg,Fg}Colors will be used\n\t// for the line under the cursor position.\n\tHighlight bool\n\n\t// If Frame is true, a border will be drawn around the view.\n\tFrame bool\n\n\t// If Wrap is true, the content that is written to this View is\n\t// automatically wrapped when it is longer than its width. If true the\n\t// view's x-origin will be ignored.\n\tWrap bool\n\n\t// If Autoscroll is true, the View will automatically scroll down when the\n\t// text overflows. If true the view's y-origin will be ignored.\n\tAutoscroll bool\n\n\t// If Frame is true, Title allows to configure a title for the view.\n\tTitle string\n\n\t// If Mask is true, the View will display the mask instead of the real\n\t// content\n\tMask rune\n}\n\ntype viewLine struct {\n\tlinesX, linesY int // coordinates relative to v.lines\n\tline           []cell\n}\n\ntype cell struct {\n\tchr              rune\n\tbgColor, fgColor Attribute\n}\n\ntype lineType []cell\n\n// String returns a string from a given cell slice.\nfunc (l lineType) String() string {\n\tstr := \"\"\n\tfor _, c := range l {\n\t\tstr += string(c.chr)\n\t}\n\treturn str\n}\n\n// newView returns a new View object.\nfunc newView(name string, x0, y0, x1, y1 int, mode OutputMode) *View {\n\tv := &View{\n\t\tname:    name,\n\t\tx0:      x0,\n\t\ty0:      y0,\n\t\tx1:      x1,\n\t\ty1:      y1,\n\t\tFrame:   true,\n\t\tEditor:  DefaultEditor,\n\t\ttainted: true,\n\t\tei:      newEscapeInterpreter(mode),\n\t}\n\treturn v\n}\n\n// Size returns the number of visible columns and rows in the View.\nfunc (v *View) Size() (x, y int) {\n\treturn v.x1 - v.x0 - 1, v.y1 - v.y0 - 1\n}\n\n// Name returns the name of the view.\nfunc (v *View) Name() string {\n\treturn v.name\n}\n\n// setRune sets a rune at the given point relative to the view. It applies the\n// specified colors, taking into account if the cell must be highlighted. Also,\n// it checks if the position is valid.\nfunc (v *View) setRune(x, y int, ch rune, fgColor, bgColor Attribute) error {\n\tmaxX, maxY := v.Size()\n\tif x < 0 || x >= maxX || y < 0 || y >= maxY {\n\t\treturn errors.New(\"invalid point\")\n\t}\n\n\tvar (\n\t\try, rcy int\n\t\terr     error\n\t)\n\tif v.Highlight {\n\t\t_, ry, err = v.realPosition(x, y)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, rcy, err = v.realPosition(v.cx, v.cy)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.Mask != 0 {\n\t\tfgColor = v.FgColor\n\t\tbgColor = v.BgColor\n\t\tch = v.Mask\n\t} else if v.Highlight && ry == rcy {\n\t\tfgColor = v.SelFgColor\n\t\tbgColor = v.SelBgColor\n\t}\n\n\ttermbox.SetCell(v.x0+x+1, v.y0+y+1, ch,\n\t\ttermbox.Attribute(fgColor), termbox.Attribute(bgColor))\n\n\treturn nil\n}\n\n// SetCursor sets the cursor position of the view at the given point,\n// relative to the view. It checks if the position is valid.\nfunc (v *View) SetCursor(x, y int) error {\n\tmaxX, maxY := v.Size()\n\tif x < 0 || x >= maxX || y < 0 || y >= maxY {\n\t\treturn errors.New(\"invalid point\")\n\t}\n\tv.cx = x\n\tv.cy = y\n\treturn nil\n}\n\n// Cursor returns the cursor position of the view.\nfunc (v *View) Cursor() (x, y int) {\n\treturn v.cx, v.cy\n}\n\n// SetOrigin sets the origin position of the view's internal buffer,\n// so the buffer starts to be printed from this point, which means that\n// it is linked with the origin point of view. It can be used to\n// implement Horizontal and Vertical scrolling with just incrementing\n// or decrementing ox and oy.\nfunc (v *View) SetOrigin(x, y int) error {\n\tif x < 0 || y < 0 {\n\t\treturn errors.New(\"invalid point\")\n\t}\n\tv.ox = x\n\tv.oy = y\n\treturn nil\n}\n\n// Origin returns the origin position of the view.\nfunc (v *View) Origin() (x, y int) {\n\treturn v.ox, v.oy\n}\n\n// Write appends a byte slice into the view's internal buffer. Because\n// View implements the io.Writer interface, it can be passed as parameter\n// of functions like fmt.Fprintf, fmt.Fprintln, io.Copy, etc. Clear must\n// be called to clear the view's buffer.\nfunc (v *View) Write(p []byte) (n int, err error) {\n\tv.tainted = true\n\n\tfor _, ch := range bytes.Runes(p) {\n\t\tswitch ch {\n\t\tcase '\\n':\n\t\t\tv.lines = append(v.lines, nil)\n\t\tcase '\\r':\n\t\t\tnl := len(v.lines)\n\t\t\tif nl > 0 {\n\t\t\t\tv.lines[nl-1] = nil\n\t\t\t} else {\n\t\t\t\tv.lines = make([][]cell, 1)\n\t\t\t}\n\t\tdefault:\n\t\t\tcells := v.parseInput(ch)\n\t\t\tif cells == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tnl := len(v.lines)\n\t\t\tif nl > 0 {\n\t\t\t\tv.lines[nl-1] = append(v.lines[nl-1], cells...)\n\t\t\t} else {\n\t\t\t\tv.lines = append(v.lines, cells)\n\t\t\t}\n\t\t}\n\t}\n\treturn len(p), nil\n}\n\n// parseInput parses char by char the input written to the View. It returns nil\n// while processing ESC sequences. Otherwise, it returns a cell slice that\n// contains the processed data.\nfunc (v *View) parseInput(ch rune) []cell {\n\tcells := []cell{}\n\n\tisEscape, err := v.ei.parseOne(ch)\n\tif err != nil {\n\t\tfor _, r := range v.ei.runes() {\n\t\t\tc := cell{\n\t\t\t\tfgColor: v.FgColor,\n\t\t\t\tbgColor: v.BgColor,\n\t\t\t\tchr:     r,\n\t\t\t}\n\t\t\tcells = append(cells, c)\n\t\t}\n\t\tv.ei.reset()\n\t} else {\n\t\tif isEscape {\n\t\t\treturn nil\n\t\t}\n\t\tc := cell{\n\t\t\tfgColor: v.ei.curFgColor,\n\t\t\tbgColor: v.ei.curBgColor,\n\t\t\tchr:     ch,\n\t\t}\n\t\tcells = append(cells, c)\n\t}\n\n\treturn cells\n}\n\n// Read reads data into p. It returns the number of bytes read into p.\n// At EOF, err will be io.EOF. Calling Read() after Rewind() makes the\n// cache to be refreshed with the contents of the view.\nfunc (v *View) Read(p []byte) (n int, err error) {\n\tif v.readOffset == 0 {\n\t\tv.readCache = v.Buffer()\n\t}\n\tif v.readOffset < len(v.readCache) {\n\t\tn = copy(p, v.readCache[v.readOffset:])\n\t\tv.readOffset += n\n\t} else {\n\t\terr = io.EOF\n\t}\n\treturn\n}\n\n// Rewind sets the offset for the next Read to 0, which also refresh the\n// read cache.\nfunc (v *View) Rewind() {\n\tv.readOffset = 0\n}\n\n// draw re-draws the view's contents.\nfunc (v *View) draw() error {\n\tmaxX, maxY := v.Size()\n\n\tif v.Wrap {\n\t\tif maxX == 0 {\n\t\t\treturn errors.New(\"X size of the view cannot be 0\")\n\t\t}\n\t\tv.ox = 0\n\t}\n\tif v.tainted {\n\t\tv.viewLines = nil\n\t\tfor i, line := range v.lines {\n\t\t\tif v.Wrap {\n\t\t\t\tif len(line) < maxX {\n\t\t\t\t\tvline := viewLine{linesX: 0, linesY: i, line: line}\n\t\t\t\t\tv.viewLines = append(v.viewLines, vline)\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\tfor n := 0; n <= len(line); n += maxX {\n\t\t\t\t\t\tif len(line[n:]) <= maxX {\n\t\t\t\t\t\t\tvline := viewLine{linesX: n, linesY: i, line: line[n:]}\n\t\t\t\t\t\t\tv.viewLines = append(v.viewLines, vline)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvline := viewLine{linesX: n, linesY: i, line: line[n : n+maxX]}\n\t\t\t\t\t\t\tv.viewLines = append(v.viewLines, vline)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvline := viewLine{linesX: 0, linesY: i, line: line}\n\t\t\t\tv.viewLines = append(v.viewLines, vline)\n\t\t\t}\n\t\t}\n\t\tv.tainted = false\n\t}\n\n\tif v.Autoscroll && len(v.viewLines) > maxY {\n\t\tv.oy = len(v.viewLines) - maxY\n\t}\n\ty := 0\n\tfor i, vline := range v.viewLines {\n\t\tif i < v.oy {\n\t\t\tcontinue\n\t\t}\n\t\tif y >= maxY {\n\t\t\tbreak\n\t\t}\n\t\tx := 0\n\t\tfor j, c := range vline.line {\n\t\t\tif j < v.ox {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif x >= maxX {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfgColor := c.fgColor\n\t\t\tif fgColor == ColorDefault {\n\t\t\t\tfgColor = v.FgColor\n\t\t\t}\n\t\t\tbgColor := c.bgColor\n\t\t\tif bgColor == ColorDefault {\n\t\t\t\tbgColor = v.BgColor\n\t\t\t}\n\n\t\t\tif err := v.setRune(x, y, c.chr, fgColor, bgColor); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tx++\n\t\t}\n\t\ty++\n\t}\n\treturn nil\n}\n\n// realPosition returns the position in the internal buffer corresponding to the\n// point (x, y) of the view.\nfunc (v *View) realPosition(vx, vy int) (x, y int, err error) {\n\tvx = v.ox + vx\n\tvy = v.oy + vy\n\n\tif vx < 0 || vy < 0 {\n\t\treturn 0, 0, errors.New(\"invalid point\")\n\t}\n\n\tif len(v.viewLines) == 0 {\n\t\treturn vx, vy, nil\n\t}\n\n\tif vy < len(v.viewLines) {\n\t\tvline := v.viewLines[vy]\n\t\tx = vline.linesX + vx\n\t\ty = vline.linesY\n\t} else {\n\t\tvline := v.viewLines[len(v.viewLines)-1]\n\t\tx = vx\n\t\ty = vline.linesY + vy - len(v.viewLines) + 1\n\t}\n\n\treturn x, y, nil\n}\n\n// Clear empties the view's internal buffer.\nfunc (v *View) Clear() {\n\tv.tainted = true\n\n\tv.lines = nil\n\tv.viewLines = nil\n\tv.readOffset = 0\n\tv.clearRunes()\n}\n\n// clearRunes erases all the cells in the view.\nfunc (v *View) clearRunes() {\n\tmaxX, maxY := v.Size()\n\tfor x := 0; x < maxX; x++ {\n\t\tfor y := 0; y < maxY; y++ {\n\t\t\ttermbox.SetCell(v.x0+x+1, v.y0+y+1, ' ',\n\t\t\t\ttermbox.Attribute(v.FgColor), termbox.Attribute(v.BgColor))\n\t\t}\n\t}\n}\n\n// BufferLines returns the lines in the view's internal\n// buffer.\nfunc (v *View) BufferLines() []string {\n\tlines := make([]string, len(v.lines))\n\tfor i, l := range v.lines {\n\t\tstr := lineType(l).String()\n\t\tstr = strings.Replace(str, \"\\x00\", \" \", -1)\n\t\tlines[i] = str\n\t}\n\treturn lines\n}\n\n// Buffer returns a string with the contents of the view's internal\n// buffer.\nfunc (v *View) Buffer() string {\n\tstr := \"\"\n\tfor _, l := range v.lines {\n\t\tstr += lineType(l).String() + \"\\n\"\n\t}\n\treturn strings.Replace(str, \"\\x00\", \" \", -1)\n}\n\n// ViewBufferLines returns the lines in the view's internal\n// buffer that is shown to the user.\nfunc (v *View) ViewBufferLines() []string {\n\tlines := make([]string, len(v.viewLines))\n\tfor i, l := range v.viewLines {\n\t\tstr := lineType(l.line).String()\n\t\tstr = strings.Replace(str, \"\\x00\", \" \", -1)\n\t\tlines[i] = str\n\t}\n\treturn lines\n}\n\n// ViewBuffer returns a string with the contents of the view's buffer that is\n// shown to the user.\nfunc (v *View) ViewBuffer() string {\n\tstr := \"\"\n\tfor _, l := range v.viewLines {\n\t\tstr += lineType(l.line).String() + \"\\n\"\n\t}\n\treturn strings.Replace(str, \"\\x00\", \" \", -1)\n}\n\n// Line returns a string with the line of the view's internal buffer\n// at the position corresponding to the point (x, y).\nfunc (v *View) Line(y int) (string, error) {\n\t_, y, err := v.realPosition(0, y)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif y < 0 || y >= len(v.lines) {\n\t\treturn \"\", errors.New(\"invalid point\")\n\t}\n\n\treturn lineType(v.lines[y]).String(), nil\n}\n\n// Word returns a string with the word of the view's internal buffer\n// at the position corresponding to the point (x, y).\nfunc (v *View) Word(x, y int) (string, error) {\n\tx, y, err := v.realPosition(x, y)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif x < 0 || y < 0 || y >= len(v.lines) || x >= len(v.lines[y]) {\n\t\treturn \"\", errors.New(\"invalid point\")\n\t}\n\n\tstr := lineType(v.lines[y]).String()\n\n\tnl := strings.LastIndexFunc(str[:x], indexFunc)\n\tif nl == -1 {\n\t\tnl = 0\n\t} else {\n\t\tnl = nl + 1\n\t}\n\tnr := strings.IndexFunc(str[x:], indexFunc)\n\tif nr == -1 {\n\t\tnr = len(str)\n\t} else {\n\t\tnr = nr + x\n\t}\n\treturn string(str[nl:nr]), nil\n}\n\n// indexFunc allows to split lines by words taking into account spaces\n// and 0.\nfunc indexFunc(r rune) bool {\n\treturn r == ' ' || r == 0\n}\n"
        }
      ]
    }
  ]
}