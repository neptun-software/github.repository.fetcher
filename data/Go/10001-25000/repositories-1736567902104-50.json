{
  "metadata": {
    "timestamp": 1736567902104,
    "page": 50,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "go-chi/chi",
      "stars": 18926,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.01953125,
          "content": ".idea\n*.sw?\n.vscode\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 15.482421875,
          "content": "# Changelog\n\n## v5.0.12 (2024-02-16)\n\n- History of changes: see https://github.com/go-chi/chi/compare/v5.0.11...v5.0.12\n\n\n## v5.0.11 (2023-12-19)\n\n- History of changes: see https://github.com/go-chi/chi/compare/v5.0.10...v5.0.11\n\n\n## v5.0.10 (2023-07-13)\n\n- Fixed small edge case in tests of v5.0.9 for older Go versions\n- History of changes: see https://github.com/go-chi/chi/compare/v5.0.9...v5.0.10\n\n\n## v5.0.9 (2023-07-13)\n\n- History of changes: see https://github.com/go-chi/chi/compare/v5.0.8...v5.0.9\n\n\n## v5.0.8 (2022-12-07)\n\n- History of changes: see https://github.com/go-chi/chi/compare/v5.0.7...v5.0.8\n\n\n## v5.0.7 (2021-11-18)\n\n- History of changes: see https://github.com/go-chi/chi/compare/v5.0.6...v5.0.7\n\n\n## v5.0.6 (2021-11-15)\n\n- History of changes: see https://github.com/go-chi/chi/compare/v5.0.5...v5.0.6\n\n\n## v5.0.5 (2021-10-27)\n\n- History of changes: see https://github.com/go-chi/chi/compare/v5.0.4...v5.0.5\n\n\n## v5.0.4 (2021-08-29)\n\n- History of changes: see https://github.com/go-chi/chi/compare/v5.0.3...v5.0.4\n\n\n## v5.0.3 (2021-04-29)\n\n- History of changes: see https://github.com/go-chi/chi/compare/v5.0.2...v5.0.3\n\n\n## v5.0.2 (2021-03-25)\n\n- History of changes: see https://github.com/go-chi/chi/compare/v5.0.1...v5.0.2\n\n\n## v5.0.1 (2021-03-10)\n\n- Small improvements\n- History of changes: see https://github.com/go-chi/chi/compare/v5.0.0...v5.0.1\n\n\n## v5.0.0 (2021-02-27)\n\n- chi v5, `github.com/go-chi/chi/v5` introduces the adoption of Go's SIV to adhere to the current state-of-the-tools in Go.\n- chi v1.5.x did not work out as planned, as the Go tooling is too powerful and chi's adoption is too wide.\n  The most responsible thing to do for everyone's benefit is to just release v5 with SIV, so I present to you all,\n  chi v5 at `github.com/go-chi/chi/v5`. I hope someday the developer experience and ergonomics I've been seeking\n  will still come to fruition in some form, see https://github.com/golang/go/issues/44550\n- History of changes: see https://github.com/go-chi/chi/compare/v1.5.4...v5.0.0\n\n\n## v1.5.4 (2021-02-27)\n\n- Undo prior retraction in v1.5.3 as we prepare for v5.0.0 release\n- History of changes: see https://github.com/go-chi/chi/compare/v1.5.3...v1.5.4\n\n\n## v1.5.3 (2021-02-21)\n\n- Update go.mod to go 1.16 with new retract directive marking all versions without prior go.mod support\n- History of changes: see https://github.com/go-chi/chi/compare/v1.5.2...v1.5.3\n\n\n## v1.5.2 (2021-02-10)\n\n- Reverting allocation optimization as a precaution as go test -race fails.\n- Minor improvements, see history below\n- History of changes: see https://github.com/go-chi/chi/compare/v1.5.1...v1.5.2\n\n\n## v1.5.1 (2020-12-06)\n\n- Performance improvement: removing 1 allocation by foregoing context.WithValue, thank you @bouk for\n  your contribution (https://github.com/go-chi/chi/pull/555). Note: new benchmarks posted in README.\n- `middleware.CleanPath`: new middleware that clean's request path of double slashes\n- deprecate & remove `chi.ServerBaseContext` in favour of stdlib `http.Server#BaseContext`\n- plus other tiny improvements, see full commit history below\n- History of changes: see https://github.com/go-chi/chi/compare/v4.1.2...v1.5.1\n\n\n## v1.5.0 (2020-11-12) - now with go.mod support\n\n`chi` dates back to 2016 with it's original implementation as one of the first routers to adopt the newly introduced\ncontext.Context api to the stdlib -- set out to design a router that is faster, more modular and simpler than anything\nelse out there -- while not introducing any custom handler types or dependencies. Today, `chi` still has zero dependencies,\nand in many ways is future proofed from changes, given it's minimal nature. Between versions, chi's iterations have been very\nincremental, with the architecture and api being the same today as it was originally designed in 2016. For this reason it \nmakes chi a pretty easy project to maintain, as well thanks to the many amazing community contributions over the years\nto who all help make chi better (total of 86 contributors to date -- thanks all!).\n\nChi has been a labour of love, art and engineering, with the goals to offer beautiful ergonomics, flexibility, performance\nand simplicity when building HTTP services with Go. I've strived to keep the router very minimal in surface area / code size,\nand always improving the code wherever possible -- and as of today the `chi` package is just 1082 lines of code (not counting\nmiddlewares, which are all optional). As well, I don't have the exact metrics, but from my analysis and email exchanges from\ncompanies and developers, chi is used by thousands of projects around the world -- thank you all as there is no better form of\njoy for me than to have art I had started be helpful and enjoyed by others. And of course I use chi in all of my own projects too :)\n\nFor me, the aesthetics of chi's code and usage are very important. With the introduction of Go's module support\n(which I'm a big fan of), chi's past versioning scheme choice to v2, v3 and v4 would mean I'd require the import path\nof \"github.com/go-chi/chi/v4\", leading to the lengthy discussion at https://github.com/go-chi/chi/issues/462.\nHaha, to some, you may be scratching your head why I've spent > 1 year stalling to adopt \"/vXX\" convention in the import\npath -- which isn't horrible in general -- but for chi, I'm unable to accept it as I strive for perfection in it's API design,\naesthetics and simplicity. It just doesn't feel good to me given chi's simple nature -- I do not foresee a \"v5\" or \"v6\",\nand upgrading between versions in the future will also be just incremental.\n\nI do understand versioning is a part of the API design as well, which is why the solution for a while has been to \"do nothing\",\nas Go supports both old and new import paths with/out go.mod. However, now that Go module support has had time to iron out kinks and\nis adopted everywhere, it's time for chi to get with the times. Luckily, I've discovered a path forward that will make me happy,\nwhile also not breaking anyone's app who adopted a prior versioning from tags in v2/v3/v4. I've made an experimental release of\nv1.5.0 with go.mod silently, and tested it with new and old projects, to ensure the developer experience is preserved, and it's\nlargely unnoticed. Fortunately, Go's toolchain will check the tags of a repo and consider the \"latest\" tag the one with go.mod.\nHowever, you can still request a specific older tag such as v4.1.2, and everything will \"just work\". But new users can just\n`go get github.com/go-chi/chi` or `go get github.com/go-chi/chi@latest` and they will get the latest version which contains\ngo.mod support, which is v1.5.0+. `chi` will not change very much over the years, just like it hasn't changed much from 4 years ago.\nTherefore, we will stay on v1.x from here on, starting from v1.5.0. Any breaking changes will bump a \"minor\" release and\nbackwards-compatible improvements/fixes will bump a \"tiny\" release.\n\nFor existing projects who want to upgrade to the latest go.mod version, run: `go get -u github.com/go-chi/chi@v1.5.0`,\nwhich will get you on the go.mod version line (as Go's mod cache may still remember v4.x). Brand new systems can run\n`go get -u github.com/go-chi/chi` or `go get -u github.com/go-chi/chi@latest` to install chi, which will install v1.5.0+\nbuilt with go.mod support.\n\nMy apologies to the developers who will disagree with the decisions above, but, hope you'll try it and see it's a very\nminor request which is backwards compatible and won't break your existing installations.\n\nCheers all, happy coding!\n\n\n---\n\n\n## v4.1.2 (2020-06-02)\n\n- fix that handles MethodNotAllowed with path variables, thank you @caseyhadden for your contribution\n- fix to replace nested wildcards correctly in RoutePattern, thank you @@unmultimedio for your contribution\n- History of changes: see https://github.com/go-chi/chi/compare/v4.1.1...v4.1.2\n\n\n## v4.1.1 (2020-04-16)\n\n- fix for issue https://github.com/go-chi/chi/issues/411 which allows for overlapping regexp\n  route to the correct handler through a recursive tree search, thanks to @Jahaja for the PR/fix!\n- new middleware.RouteHeaders as a simple router for request headers with wildcard support\n- History of changes: see https://github.com/go-chi/chi/compare/v4.1.0...v4.1.1\n\n\n## v4.1.0 (2020-04-1)\n\n- middleware.LogEntry: Write method on interface now passes the response header\n  and an extra interface type useful for custom logger implementations.\n- middleware.WrapResponseWriter: minor fix\n- middleware.Recoverer: a bit prettier\n- History of changes: see https://github.com/go-chi/chi/compare/v4.0.4...v4.1.0\n\n## v4.0.4 (2020-03-24)\n\n- middleware.Recoverer: new pretty stack trace printing (https://github.com/go-chi/chi/pull/496)\n- a few minor improvements and fixes\n- History of changes: see https://github.com/go-chi/chi/compare/v4.0.3...v4.0.4\n\n\n## v4.0.3 (2020-01-09)\n\n- core: fix regexp routing to include default value when param is not matched\n- middleware: rewrite of middleware.Compress\n- middleware: suppress http.ErrAbortHandler in middleware.Recoverer\n- History of changes: see https://github.com/go-chi/chi/compare/v4.0.2...v4.0.3\n\n\n## v4.0.2 (2019-02-26)\n\n- Minor fixes\n- History of changes: see https://github.com/go-chi/chi/compare/v4.0.1...v4.0.2\n\n\n## v4.0.1 (2019-01-21)\n\n- Fixes issue with compress middleware: #382 #385\n- History of changes: see https://github.com/go-chi/chi/compare/v4.0.0...v4.0.1\n\n\n## v4.0.0 (2019-01-10)\n\n- chi v4 requires Go 1.10.3+ (or Go 1.9.7+) - we have deprecated support for Go 1.7 and 1.8\n- router: respond with 404 on router with no routes (#362)\n- router: additional check to ensure wildcard is at the end of a url pattern (#333)\n- middleware: deprecate use of http.CloseNotifier (#347)\n- middleware: fix RedirectSlashes to include query params on redirect (#334)\n- History of changes: see https://github.com/go-chi/chi/compare/v3.3.4...v4.0.0\n\n\n## v3.3.4 (2019-01-07)\n\n- Minor middleware improvements. No changes to core library/router. Moving v3 into its\n- own branch as a version of chi for Go 1.7, 1.8, 1.9, 1.10, 1.11\n- History of changes: see https://github.com/go-chi/chi/compare/v3.3.3...v3.3.4\n\n\n## v3.3.3 (2018-08-27)\n\n- Minor release\n- See https://github.com/go-chi/chi/compare/v3.3.2...v3.3.3\n\n\n## v3.3.2 (2017-12-22)\n\n- Support to route trailing slashes on mounted sub-routers (#281)\n- middleware: new `ContentCharset` to check matching charsets. Thank you\n  @csucu for your community contribution!\n\n\n## v3.3.1 (2017-11-20)\n\n- middleware: new `AllowContentType` handler for explicit whitelist of accepted request Content-Types\n- middleware: new `SetHeader` handler for short-hand middleware to set a response header key/value\n- Minor bug fixes\n\n\n## v3.3.0 (2017-10-10)\n\n- New chi.RegisterMethod(method) to add support for custom HTTP methods, see _examples/custom-method for usage\n- Deprecated LINK and UNLINK methods from the default list, please use `chi.RegisterMethod(\"LINK\")` and `chi.RegisterMethod(\"UNLINK\")` in an `init()` function\n\n\n## v3.2.1 (2017-08-31)\n\n- Add new `Match(rctx *Context, method, path string) bool` method to `Routes` interface\n  and `Mux`. Match searches the mux's routing tree for a handler that matches the method/path\n- Add new `RouteMethod` to `*Context`\n- Add new `Routes` pointer to `*Context`\n- Add new `middleware.GetHead` to route missing HEAD requests to GET handler\n- Updated benchmarks (see README)\n\n\n## v3.1.5 (2017-08-02)\n\n- Setup golint and go vet for the project\n- As per golint, we've redefined `func ServerBaseContext(h http.Handler, baseCtx context.Context) http.Handler`\n  to `func ServerBaseContext(baseCtx context.Context, h http.Handler) http.Handler`\n\n\n## v3.1.0 (2017-07-10)\n\n- Fix a few minor issues after v3 release\n- Move `docgen` sub-pkg to https://github.com/go-chi/docgen\n- Move `render` sub-pkg to https://github.com/go-chi/render\n- Add new `URLFormat` handler to chi/middleware sub-pkg to make working with url mime \n  suffixes easier, ie. parsing `/articles/1.json` and `/articles/1.xml`. See comments in\n  https://github.com/go-chi/chi/blob/master/middleware/url_format.go for example usage.\n\n\n## v3.0.0 (2017-06-21)\n\n- Major update to chi library with many exciting updates, but also some *breaking changes*\n- URL parameter syntax changed from `/:id` to `/{id}` for even more flexible routing, such as\n  `/articles/{month}-{day}-{year}-{slug}`, `/articles/{id}`, and `/articles/{id}.{ext}` on the\n  same router\n- Support for regexp for routing patterns, in the form of `/{paramKey:regExp}` for example:\n  `r.Get(\"/articles/{name:[a-z]+}\", h)` and `chi.URLParam(r, \"name\")`\n- Add `Method` and `MethodFunc` to `chi.Router` to allow routing definitions such as\n  `r.Method(\"GET\", \"/\", h)` which provides a cleaner interface for custom handlers like\n  in `_examples/custom-handler`\n- Deprecating `mux#FileServer` helper function. Instead, we encourage users to create their\n  own using file handler with the stdlib, see `_examples/fileserver` for an example\n- Add support for LINK/UNLINK http methods via `r.Method()` and `r.MethodFunc()`\n- Moved the chi project to its own organization, to allow chi-related community packages to\n  be easily discovered and supported, at: https://github.com/go-chi\n- *NOTE:* please update your import paths to `\"github.com/go-chi/chi\"`\n- *NOTE:* chi v2 is still available at https://github.com/go-chi/chi/tree/v2\n\n\n## v2.1.0 (2017-03-30)\n\n- Minor improvements and update to the chi core library\n- Introduced a brand new `chi/render` sub-package to complete the story of building\n  APIs to offer a pattern for managing well-defined request / response payloads. Please\n  check out the updated `_examples/rest` example for how it works.\n- Added `MethodNotAllowed(h http.HandlerFunc)` to chi.Router interface\n\n\n## v2.0.0 (2017-01-06)\n\n- After many months of v2 being in an RC state with many companies and users running it in\n  production, the inclusion of some improvements to the middlewares, we are very pleased to\n  announce v2.0.0 of chi.\n\n\n## v2.0.0-rc1 (2016-07-26)\n\n- Huge update! chi v2 is a large refactor targeting Go 1.7+. As of Go 1.7, the popular\n  community `\"net/context\"` package has been included in the standard library as `\"context\"` and\n  utilized by `\"net/http\"` and `http.Request` to managing deadlines, cancelation signals and other\n  request-scoped values. We're very excited about the new context addition and are proud to\n  introduce chi v2, a minimal and powerful routing package for building large HTTP services,\n  with zero external dependencies. Chi focuses on idiomatic design and encourages the use of \n  stdlib HTTP handlers and middlewares.\n- chi v2 deprecates its `chi.Handler` interface and requires `http.Handler` or `http.HandlerFunc`\n- chi v2 stores URL routing parameters and patterns in the standard request context: `r.Context()`\n- chi v2 lower-level routing context is accessible by `chi.RouteContext(r.Context()) *chi.Context`,\n  which provides direct access to URL routing parameters, the routing path and the matching\n  routing patterns.\n- Users upgrading from chi v1 to v2, need to:\n  1. Update the old chi.Handler signature, `func(ctx context.Context, w http.ResponseWriter, r *http.Request)` to\n     the standard http.Handler: `func(w http.ResponseWriter, r *http.Request)`\n  2. Use `chi.URLParam(r *http.Request, paramKey string) string`\n     or `URLParamFromCtx(ctx context.Context, paramKey string) string` to access a url parameter value\n\n\n## v1.0.0 (2016-07-01)\n\n- Released chi v1 stable https://github.com/go-chi/chi/tree/v1.0.0 for Go 1.6 and older.\n\n\n## v0.9.0 (2016-03-31)\n\n- Reuse context objects via sync.Pool for zero-allocation routing [#33](https://github.com/go-chi/chi/pull/33)\n- BREAKING NOTE: due to subtle API changes, previously `chi.URLParams(ctx)[\"id\"]` used to access url parameters\n  has changed to: `chi.URLParam(ctx, \"id\")`\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.1591796875,
          "content": "# Contributing\n\n## Prerequisites\n\n1. [Install Go][go-install].\n2. Download the sources and switch the working directory:\n\n    ```bash\n    go get -u -d github.com/go-chi/chi\n    cd $GOPATH/src/github.com/go-chi/chi\n    ```\n\n## Submitting a Pull Request\n\nA typical workflow is:\n\n1. [Fork the repository.][fork]\n2. [Create a topic branch.][branch]\n3. Add tests for your change.\n4. Run `go test`. If your tests pass, return to the step 3.\n5. Implement the change and ensure the steps from the previous step pass.\n6. Run `goimports -w .`, to ensure the new code conforms to Go formatting guideline.\n7. [Add, commit and push your changes.][git-help]\n8. [Submit a pull request.][pull-req]\n\n[go-install]: https://golang.org/doc/install\n[fork]: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/fork-a-repo\n[branch]: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-branches \n[git-help]: https://docs.github.com/en\n[pull-req]: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0966796875,
          "content": "Copyright (c) 2015-present Peter Kieltyka (https://github.com/pkieltyka), Google Inc.\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.478515625,
          "content": ".PHONY: all\nall:\n\t@echo \"**********************************************************\"\n\t@echo \"**                    chi build tool                    **\"\n\t@echo \"**********************************************************\"\n\n\n.PHONY: test\ntest:\n\tgo clean -testcache && $(MAKE) test-router && $(MAKE) test-middleware\n\n.PHONY: test-router\ntest-router:\n\tgo test -race -v .\n\n.PHONY: test-middleware\ntest-middleware:\n\tgo test -race -v ./middleware\n\n.PHONY: docs\ndocs:\n\tnpx docsify-cli serve ./docs\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 22.759765625,
          "content": "# <img alt=\"chi\" src=\"https://cdn.rawgit.com/go-chi/chi/master/_examples/chi.svg\" width=\"220\" />\n\n\n[![GoDoc Widget]][GoDoc]\n\n`chi` is a lightweight, idiomatic and composable router for building Go HTTP services. It's\nespecially good at helping you write large REST API services that are kept maintainable as your\nproject grows and changes. `chi` is built on the new `context` package introduced in Go 1.7 to\nhandle signaling, cancelation and request-scoped values across a handler chain.\n\nThe focus of the project has been to seek out an elegant and comfortable design for writing\nREST API servers, written during the development of the Pressly API service that powers our\npublic API service, which in turn powers all of our client-side applications.\n\nThe key considerations of chi's design are: project structure, maintainability, standard http\nhandlers (stdlib-only), developer productivity, and deconstructing a large system into many small\nparts. The core router `github.com/go-chi/chi` is quite small (less than 1000 LOC), but we've also\nincluded some useful/optional subpackages: [middleware](/middleware), [render](https://github.com/go-chi/render)\nand [docgen](https://github.com/go-chi/docgen). We hope you enjoy it too!\n\n## Install\n\n`go get -u github.com/go-chi/chi/v5`\n\n\n## Features\n\n* **Lightweight** - cloc'd in ~1000 LOC for the chi router\n* **Fast** - yes, see [benchmarks](#benchmarks)\n* **100% compatible with net/http** - use any http or middleware pkg in the ecosystem that is also compatible with `net/http`\n* **Designed for modular/composable APIs** - middlewares, inline middlewares, route groups and sub-router mounting\n* **Context control** - built on new `context` package, providing value chaining, cancellations and timeouts\n* **Robust** - in production at Pressly, Cloudflare, Heroku, 99Designs, and many others (see [discussion](https://github.com/go-chi/chi/issues/91))\n* **Doc generation** - `docgen` auto-generates routing documentation from your source to JSON or Markdown\n* **Go.mod support** - as of v5, go.mod support (see [CHANGELOG](https://github.com/go-chi/chi/blob/master/CHANGELOG.md))\n* **No external dependencies** - plain ol' Go stdlib + net/http\n\n\n## Examples\n\nSee [_examples/](https://github.com/go-chi/chi/blob/master/_examples/) for a variety of examples.\n\n\n**As easy as:**\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/go-chi/chi/v5/middleware\"\n)\n\nfunc main() {\n\tr := chi.NewRouter()\n\tr.Use(middleware.Logger)\n\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"welcome\"))\n\t})\n\thttp.ListenAndServe(\":3000\", r)\n}\n```\n\n**REST Preview:**\n\nHere is a little preview of what routing looks like with chi. Also take a look at the generated routing docs\nin JSON ([routes.json](https://github.com/go-chi/chi/blob/master/_examples/rest/routes.json)) and in\nMarkdown ([routes.md](https://github.com/go-chi/chi/blob/master/_examples/rest/routes.md)).\n\nI highly recommend reading the source of the [examples](https://github.com/go-chi/chi/blob/master/_examples/) listed\nabove, they will show you all the features of chi and serve as a good form of documentation.\n\n```go\nimport (\n  //...\n  \"context\"\n  \"github.com/go-chi/chi/v5\"\n  \"github.com/go-chi/chi/v5/middleware\"\n)\n\nfunc main() {\n  r := chi.NewRouter()\n\n  // A good base middleware stack\n  r.Use(middleware.RequestID)\n  r.Use(middleware.RealIP)\n  r.Use(middleware.Logger)\n  r.Use(middleware.Recoverer)\n\n  // Set a timeout value on the request context (ctx), that will signal\n  // through ctx.Done() that the request has timed out and further\n  // processing should be stopped.\n  r.Use(middleware.Timeout(60 * time.Second))\n\n  r.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"hi\"))\n  })\n\n  // RESTy routes for \"articles\" resource\n  r.Route(\"/articles\", func(r chi.Router) {\n    r.With(paginate).Get(\"/\", listArticles)                           // GET /articles\n    r.With(paginate).Get(\"/{month}-{day}-{year}\", listArticlesByDate) // GET /articles/01-16-2017\n\n    r.Post(\"/\", createArticle)                                        // POST /articles\n    r.Get(\"/search\", searchArticles)                                  // GET /articles/search\n\n    // Regexp url parameters:\n    r.Get(\"/{articleSlug:[a-z-]+}\", getArticleBySlug)                // GET /articles/home-is-toronto\n\n    // Subrouters:\n    r.Route(\"/{articleID}\", func(r chi.Router) {\n      r.Use(ArticleCtx)\n      r.Get(\"/\", getArticle)                                          // GET /articles/123\n      r.Put(\"/\", updateArticle)                                       // PUT /articles/123\n      r.Delete(\"/\", deleteArticle)                                    // DELETE /articles/123\n    })\n  })\n\n  // Mount the admin sub-router\n  r.Mount(\"/admin\", adminRouter())\n\n  http.ListenAndServe(\":3333\", r)\n}\n\nfunc ArticleCtx(next http.Handler) http.Handler {\n  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    articleID := chi.URLParam(r, \"articleID\")\n    article, err := dbGetArticle(articleID)\n    if err != nil {\n      http.Error(w, http.StatusText(404), 404)\n      return\n    }\n    ctx := context.WithValue(r.Context(), \"article\", article)\n    next.ServeHTTP(w, r.WithContext(ctx))\n  })\n}\n\nfunc getArticle(w http.ResponseWriter, r *http.Request) {\n  ctx := r.Context()\n  article, ok := ctx.Value(\"article\").(*Article)\n  if !ok {\n    http.Error(w, http.StatusText(422), 422)\n    return\n  }\n  w.Write([]byte(fmt.Sprintf(\"title:%s\", article.Title)))\n}\n\n// A completely separate router for administrator routes\nfunc adminRouter() http.Handler {\n  r := chi.NewRouter()\n  r.Use(AdminOnly)\n  r.Get(\"/\", adminIndex)\n  r.Get(\"/accounts\", adminListAccounts)\n  return r\n}\n\nfunc AdminOnly(next http.Handler) http.Handler {\n  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    ctx := r.Context()\n    perm, ok := ctx.Value(\"acl.permission\").(YourPermissionType)\n    if !ok || !perm.IsAdmin() {\n      http.Error(w, http.StatusText(403), 403)\n      return\n    }\n    next.ServeHTTP(w, r)\n  })\n}\n```\n\n\n## Router interface\n\nchi's router is based on a kind of [Patricia Radix trie](https://en.wikipedia.org/wiki/Radix_tree).\nThe router is fully compatible with `net/http`.\n\nBuilt on top of the tree is the `Router` interface:\n\n```go\n// Router consisting of the core routing methods used by chi's Mux,\n// using only the standard net/http.\ntype Router interface {\n\thttp.Handler\n\tRoutes\n\n\t// Use appends one or more middlewares onto the Router stack.\n\tUse(middlewares ...func(http.Handler) http.Handler)\n\n\t// With adds inline middlewares for an endpoint handler.\n\tWith(middlewares ...func(http.Handler) http.Handler) Router\n\n\t// Group adds a new inline-Router along the current routing\n\t// path, with a fresh middleware stack for the inline-Router.\n\tGroup(fn func(r Router)) Router\n\n\t// Route mounts a sub-Router along a `pattern`` string.\n\tRoute(pattern string, fn func(r Router)) Router\n\n\t// Mount attaches another http.Handler along ./pattern/*\n\tMount(pattern string, h http.Handler)\n\n\t// Handle and HandleFunc adds routes for `pattern` that matches\n\t// all HTTP methods.\n\tHandle(pattern string, h http.Handler)\n\tHandleFunc(pattern string, h http.HandlerFunc)\n\n\t// Method and MethodFunc adds routes for `pattern` that matches\n\t// the `method` HTTP method.\n\tMethod(method, pattern string, h http.Handler)\n\tMethodFunc(method, pattern string, h http.HandlerFunc)\n\n\t// HTTP-method routing along `pattern`\n\tConnect(pattern string, h http.HandlerFunc)\n\tDelete(pattern string, h http.HandlerFunc)\n\tGet(pattern string, h http.HandlerFunc)\n\tHead(pattern string, h http.HandlerFunc)\n\tOptions(pattern string, h http.HandlerFunc)\n\tPatch(pattern string, h http.HandlerFunc)\n\tPost(pattern string, h http.HandlerFunc)\n\tPut(pattern string, h http.HandlerFunc)\n\tTrace(pattern string, h http.HandlerFunc)\n\n\t// NotFound defines a handler to respond whenever a route could\n\t// not be found.\n\tNotFound(h http.HandlerFunc)\n\n\t// MethodNotAllowed defines a handler to respond whenever a method is\n\t// not allowed.\n\tMethodNotAllowed(h http.HandlerFunc)\n}\n\n// Routes interface adds two methods for router traversal, which is also\n// used by the github.com/go-chi/docgen package to generate documentation for Routers.\ntype Routes interface {\n\t// Routes returns the routing tree in an easily traversable structure.\n\tRoutes() []Route\n\n\t// Middlewares returns the list of middlewares in use by the router.\n\tMiddlewares() Middlewares\n\n\t// Match searches the routing tree for a handler that matches\n\t// the method/path - similar to routing a http request, but without\n\t// executing the handler thereafter.\n\tMatch(rctx *Context, method, path string) bool\n}\n```\n\nEach routing method accepts a URL `pattern` and chain of `handlers`. The URL pattern\nsupports named params (ie. `/users/{userID}`) and wildcards (ie. `/admin/*`). URL parameters\ncan be fetched at runtime by calling `chi.URLParam(r, \"userID\")` for named parameters\nand `chi.URLParam(r, \"*\")` for a wildcard parameter.\n\n\n### Middleware handlers\n\nchi's middlewares are just stdlib net/http middleware handlers. There is nothing special\nabout them, which means the router and all the tooling is designed to be compatible and\nfriendly with any middleware in the community. This offers much better extensibility and reuse\nof packages and is at the heart of chi's purpose.\n\nHere is an example of a standard net/http middleware where we assign a context key `\"user\"`\nthe value of `\"123\"`. This middleware sets a hypothetical user identifier on the request\ncontext and calls the next handler in the chain.\n\n```go\n// HTTP middleware setting a value on the request context\nfunc MyMiddleware(next http.Handler) http.Handler {\n  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    // create new context from `r` request context, and assign key `\"user\"`\n    // to value of `\"123\"`\n    ctx := context.WithValue(r.Context(), \"user\", \"123\")\n\n    // call the next handler in the chain, passing the response writer and\n    // the updated request object with the new context value.\n    //\n    // note: context.Context values are nested, so any previously set\n    // values will be accessible as well, and the new `\"user\"` key\n    // will be accessible from this point forward.\n    next.ServeHTTP(w, r.WithContext(ctx))\n  })\n}\n```\n\n\n### Request handlers\n\nchi uses standard net/http request handlers. This little snippet is an example of a http.Handler\nfunc that reads a user identifier from the request context - hypothetically, identifying\nthe user sending an authenticated request, validated+set by a previous middleware handler.\n\n```go\n// HTTP handler accessing data from the request context.\nfunc MyRequestHandler(w http.ResponseWriter, r *http.Request) {\n  // here we read from the request context and fetch out `\"user\"` key set in\n  // the MyMiddleware example above.\n  user := r.Context().Value(\"user\").(string)\n\n  // respond to the client\n  w.Write([]byte(fmt.Sprintf(\"hi %s\", user)))\n}\n```\n\n\n### URL parameters\n\nchi's router parses and stores URL parameters right onto the request context. Here is\nan example of how to access URL params in your net/http handlers. And of course, middlewares\nare able to access the same information.\n\n```go\n// HTTP handler accessing the url routing parameters.\nfunc MyRequestHandler(w http.ResponseWriter, r *http.Request) {\n  // fetch the url parameter `\"userID\"` from the request of a matching\n  // routing pattern. An example routing pattern could be: /users/{userID}\n  userID := chi.URLParam(r, \"userID\")\n\n  // fetch `\"key\"` from the request context\n  ctx := r.Context()\n  key := ctx.Value(\"key\").(string)\n\n  // respond to the client\n  w.Write([]byte(fmt.Sprintf(\"hi %v, %v\", userID, key)))\n}\n```\n\n\n## Middlewares\n\nchi comes equipped with an optional `middleware` package, providing a suite of standard\n`net/http` middlewares. Please note, any middleware in the ecosystem that is also compatible\nwith `net/http` can be used with chi's mux.\n\n### Core middlewares\n\n----------------------------------------------------------------------------------------------------\n| chi/middleware Handler | description                                                             |\n| :--------------------- | :---------------------------------------------------------------------- |\n| [AllowContentEncoding] | Enforces a whitelist of request Content-Encoding headers                |\n| [AllowContentType]     | Explicit whitelist of accepted request Content-Types                    |\n| [BasicAuth]            | Basic HTTP authentication                                               |\n| [Compress]             | Gzip compression for clients that accept compressed responses           |\n| [ContentCharset]       | Ensure charset for Content-Type request headers                         |\n| [CleanPath]            | Clean double slashes from request path                                  |\n| [GetHead]              | Automatically route undefined HEAD requests to GET handlers             |\n| [Heartbeat]            | Monitoring endpoint to check the servers pulse                          |\n| [Logger]               | Logs the start and end of each request with the elapsed processing time |\n| [NoCache]              | Sets response headers to prevent clients from caching                   |\n| [Profiler]             | Easily attach net/http/pprof to your routers                            |\n| [RealIP]               | Sets a http.Request's RemoteAddr to either X-Real-IP or X-Forwarded-For |\n| [Recoverer]            | Gracefully absorb panics and prints the stack trace                     |\n| [RequestID]            | Injects a request ID into the context of each request                   |\n| [RedirectSlashes]      | Redirect slashes on routing paths                                       |\n| [RouteHeaders]         | Route handling for request headers                                      |\n| [SetHeader]            | Short-hand middleware to set a response header key/value                |\n| [StripSlashes]         | Strip slashes on routing paths                                          |\n| [Sunset]               | Sunset set Deprecation/Sunset header to response                        |\n| [Throttle]             | Puts a ceiling on the number of concurrent requests                     |\n| [Timeout]              | Signals to the request context when the timeout deadline is reached     |\n| [URLFormat]            | Parse extension from url and put it on request context                  |\n| [WithValue]            | Short-hand middleware to set a key/value on the request context         |\n----------------------------------------------------------------------------------------------------\n\n[AllowContentEncoding]: https://pkg.go.dev/github.com/go-chi/chi/middleware#AllowContentEncoding\n[AllowContentType]: https://pkg.go.dev/github.com/go-chi/chi/middleware#AllowContentType\n[BasicAuth]: https://pkg.go.dev/github.com/go-chi/chi/middleware#BasicAuth\n[Compress]: https://pkg.go.dev/github.com/go-chi/chi/middleware#Compress\n[ContentCharset]: https://pkg.go.dev/github.com/go-chi/chi/middleware#ContentCharset\n[CleanPath]: https://pkg.go.dev/github.com/go-chi/chi/middleware#CleanPath\n[GetHead]: https://pkg.go.dev/github.com/go-chi/chi/middleware#GetHead\n[GetReqID]: https://pkg.go.dev/github.com/go-chi/chi/middleware#GetReqID\n[Heartbeat]: https://pkg.go.dev/github.com/go-chi/chi/middleware#Heartbeat\n[Logger]: https://pkg.go.dev/github.com/go-chi/chi/middleware#Logger\n[NoCache]: https://pkg.go.dev/github.com/go-chi/chi/middleware#NoCache\n[Profiler]: https://pkg.go.dev/github.com/go-chi/chi/middleware#Profiler\n[RealIP]: https://pkg.go.dev/github.com/go-chi/chi/middleware#RealIP\n[Recoverer]: https://pkg.go.dev/github.com/go-chi/chi/middleware#Recoverer\n[RedirectSlashes]: https://pkg.go.dev/github.com/go-chi/chi/middleware#RedirectSlashes\n[RequestLogger]: https://pkg.go.dev/github.com/go-chi/chi/middleware#RequestLogger\n[RequestID]: https://pkg.go.dev/github.com/go-chi/chi/middleware#RequestID\n[RouteHeaders]: https://pkg.go.dev/github.com/go-chi/chi/middleware#RouteHeaders\n[SetHeader]: https://pkg.go.dev/github.com/go-chi/chi/middleware#SetHeader\n[StripSlashes]: https://pkg.go.dev/github.com/go-chi/chi/middleware#StripSlashes\n[Sunset]: https://pkg.go.dev/github.com/go-chi/chi/v5/middleware#Sunset\n[Throttle]: https://pkg.go.dev/github.com/go-chi/chi/middleware#Throttle\n[ThrottleBacklog]: https://pkg.go.dev/github.com/go-chi/chi/middleware#ThrottleBacklog\n[ThrottleWithOpts]: https://pkg.go.dev/github.com/go-chi/chi/middleware#ThrottleWithOpts\n[Timeout]: https://pkg.go.dev/github.com/go-chi/chi/middleware#Timeout\n[URLFormat]: https://pkg.go.dev/github.com/go-chi/chi/middleware#URLFormat\n[WithLogEntry]: https://pkg.go.dev/github.com/go-chi/chi/middleware#WithLogEntry\n[WithValue]: https://pkg.go.dev/github.com/go-chi/chi/middleware#WithValue\n[Compressor]: https://pkg.go.dev/github.com/go-chi/chi/middleware#Compressor\n[DefaultLogFormatter]: https://pkg.go.dev/github.com/go-chi/chi/middleware#DefaultLogFormatter\n[EncoderFunc]: https://pkg.go.dev/github.com/go-chi/chi/middleware#EncoderFunc\n[HeaderRoute]: https://pkg.go.dev/github.com/go-chi/chi/middleware#HeaderRoute\n[HeaderRouter]: https://pkg.go.dev/github.com/go-chi/chi/middleware#HeaderRouter\n[LogEntry]: https://pkg.go.dev/github.com/go-chi/chi/middleware#LogEntry\n[LogFormatter]: https://pkg.go.dev/github.com/go-chi/chi/middleware#LogFormatter\n[LoggerInterface]: https://pkg.go.dev/github.com/go-chi/chi/middleware#LoggerInterface\n[ThrottleOpts]: https://pkg.go.dev/github.com/go-chi/chi/middleware#ThrottleOpts\n[WrapResponseWriter]: https://pkg.go.dev/github.com/go-chi/chi/middleware#WrapResponseWriter\n\n### Extra middlewares & packages\n\nPlease see https://github.com/go-chi for additional packages.\n\n--------------------------------------------------------------------------------------------------------------------\n| package                                            | description                                                 |\n|:---------------------------------------------------|:-------------------------------------------------------------\n| [cors](https://github.com/go-chi/cors)             | Cross-origin resource sharing (CORS)                        |\n| [docgen](https://github.com/go-chi/docgen)         | Print chi.Router routes at runtime                          |\n| [jwtauth](https://github.com/go-chi/jwtauth)       | JWT authentication                                          |\n| [hostrouter](https://github.com/go-chi/hostrouter) | Domain/host based request routing                           |\n| [httplog](https://github.com/go-chi/httplog)       | Small but powerful structured HTTP request logging          |\n| [httprate](https://github.com/go-chi/httprate)     | HTTP request rate limiter                                   |\n| [httptracer](https://github.com/go-chi/httptracer) | HTTP request performance tracing library                    |\n| [httpvcr](https://github.com/go-chi/httpvcr)       | Write deterministic tests for external sources              |\n| [stampede](https://github.com/go-chi/stampede)     | HTTP request coalescer                                      |\n--------------------------------------------------------------------------------------------------------------------\n\n\n## context?\n\n`context` is a tiny pkg that provides simple interface to signal context across call stacks\nand goroutines. It was originally written by [Sameer Ajmani](https://github.com/Sajmani)\nand is available in stdlib since go1.7.\n\nLearn more at https://blog.golang.org/context\n\nand..\n* Docs: https://golang.org/pkg/context\n* Source: https://github.com/golang/go/tree/master/src/context\n\n\n## Benchmarks\n\nThe benchmark suite: https://github.com/pkieltyka/go-http-routing-benchmark\n\nResults as of Nov 29, 2020 with Go 1.15.5 on Linux AMD 3950x\n\n```shell\nBenchmarkChi_Param          \t3075895\t        384 ns/op\t      400 B/op      2 allocs/op\nBenchmarkChi_Param5         \t2116603\t        566 ns/op\t      400 B/op      2 allocs/op\nBenchmarkChi_Param20        \t 964117\t       1227 ns/op\t      400 B/op      2 allocs/op\nBenchmarkChi_ParamWrite     \t2863413\t        420 ns/op\t      400 B/op      2 allocs/op\nBenchmarkChi_GithubStatic   \t3045488\t        395 ns/op\t      400 B/op      2 allocs/op\nBenchmarkChi_GithubParam    \t2204115\t        540 ns/op\t      400 B/op      2 allocs/op\nBenchmarkChi_GithubAll      \t  10000\t     113811 ns/op\t    81203 B/op    406 allocs/op\nBenchmarkChi_GPlusStatic    \t3337485\t        359 ns/op\t      400 B/op      2 allocs/op\nBenchmarkChi_GPlusParam     \t2825853\t        423 ns/op\t      400 B/op      2 allocs/op\nBenchmarkChi_GPlus2Params   \t2471697\t        483 ns/op\t      400 B/op      2 allocs/op\nBenchmarkChi_GPlusAll       \t 194220\t       5950 ns/op\t     5200 B/op     26 allocs/op\nBenchmarkChi_ParseStatic    \t3365324\t        356 ns/op\t      400 B/op      2 allocs/op\nBenchmarkChi_ParseParam     \t2976614\t        404 ns/op\t      400 B/op      2 allocs/op\nBenchmarkChi_Parse2Params   \t2638084\t        439 ns/op\t      400 B/op      2 allocs/op\nBenchmarkChi_ParseAll       \t 109567\t      11295 ns/op\t    10400 B/op     52 allocs/op\nBenchmarkChi_StaticAll      \t  16846\t      71308 ns/op\t    62802 B/op    314 allocs/op\n```\n\nComparison with other routers: https://gist.github.com/pkieltyka/123032f12052520aaccab752bd3e78cc\n\nNOTE: the allocs in the benchmark above are from the calls to http.Request's\n`WithContext(context.Context)` method that clones the http.Request, sets the `Context()`\non the duplicated (alloc'd) request and returns it the new request object. This is just\nhow setting context on a request in Go works.\n\n\n## Credits\n\n* Carl Jackson for https://github.com/zenazn/goji\n  * Parts of chi's thinking comes from goji, and chi's middleware package\n    sources from [goji](https://github.com/zenazn/goji/tree/master/web/middleware).\n  * Please see goji's [LICENSE](https://github.com/zenazn/goji/blob/master/LICENSE) (MIT)\n* Armon Dadgar for https://github.com/armon/go-radix\n* Contributions: [@VojtechVitek](https://github.com/VojtechVitek)\n\nWe'll be more than happy to see [your contributions](./CONTRIBUTING.md)!\n\n\n## Beyond REST\n\nchi is just a http router that lets you decompose request handling into many smaller layers.\nMany companies use chi to write REST services for their public APIs. But, REST is just a convention\nfor managing state via HTTP, and there's a lot of other pieces required to write a complete client-server\nsystem or network of microservices.\n\nLooking beyond REST, I also recommend some newer works in the field:\n* [webrpc](https://github.com/webrpc/webrpc) - Web-focused RPC client+server framework with code-gen\n* [gRPC](https://github.com/grpc/grpc-go) - Google's RPC framework via protobufs\n* [graphql](https://github.com/99designs/gqlgen) - Declarative query language\n* [NATS](https://nats.io) - lightweight pub-sub\n\n\n## License\n\nCopyright (c) 2015-present [Peter Kieltyka](https://github.com/pkieltyka)\n\nLicensed under [MIT License](./LICENSE)\n\n[GoDoc]: https://pkg.go.dev/github.com/go-chi/chi/v5\n[GoDoc Widget]: https://godoc.org/github.com/go-chi/chi?status.svg\n[Travis]: https://travis-ci.org/go-chi/chi\n[Travis Widget]: https://travis-ci.org/go-chi/chi.svg?branch=master\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.3056640625,
          "content": "# Reporting Security Issues\n\nWe appreciate your efforts to responsibly disclose your findings, and will make every effort to acknowledge your contributions.\n\nTo report a security issue, please use the GitHub Security Advisory [\"Report a Vulnerability\"](https://github.com/go-chi/chi/security/advisories/new) tab.\n"
        },
        {
          "name": "_examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "chain.go",
          "type": "blob",
          "size": 1.4814453125,
          "content": "package chi\n\nimport \"net/http\"\n\n// Chain returns a Middlewares type from a slice of middleware handlers.\nfunc Chain(middlewares ...func(http.Handler) http.Handler) Middlewares {\n\treturn Middlewares(middlewares)\n}\n\n// Handler builds and returns a http.Handler from the chain of middlewares,\n// with `h http.Handler` as the final handler.\nfunc (mws Middlewares) Handler(h http.Handler) http.Handler {\n\treturn &ChainHandler{h, chain(mws, h), mws}\n}\n\n// HandlerFunc builds and returns a http.Handler from the chain of middlewares,\n// with `h http.Handler` as the final handler.\nfunc (mws Middlewares) HandlerFunc(h http.HandlerFunc) http.Handler {\n\treturn &ChainHandler{h, chain(mws, h), mws}\n}\n\n// ChainHandler is a http.Handler with support for handler composition and\n// execution.\ntype ChainHandler struct {\n\tEndpoint    http.Handler\n\tchain       http.Handler\n\tMiddlewares Middlewares\n}\n\nfunc (c *ChainHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tc.chain.ServeHTTP(w, r)\n}\n\n// chain builds a http.Handler composed of an inline middleware stack and endpoint\n// handler in the order they are passed.\nfunc chain(middlewares []func(http.Handler) http.Handler, endpoint http.Handler) http.Handler {\n\t// Return ahead of time if there aren't any middlewares for the chain\n\tif len(middlewares) == 0 {\n\t\treturn endpoint\n\t}\n\n\t// Wrap the end handler with the middleware chain\n\th := middlewares[len(middlewares)-1](endpoint)\n\tfor i := len(middlewares) - 2; i >= 0; i-- {\n\t\th = middlewares[i](h)\n\t}\n\n\treturn h\n}\n"
        },
        {
          "name": "chi.go",
          "type": "blob",
          "size": 4.6396484375,
          "content": "// Package chi is a small, idiomatic and composable router for building HTTP services.\n//\n// chi requires Go 1.14 or newer.\n//\n// Example:\n//\n//\tpackage main\n//\n//\timport (\n//\t\t\"net/http\"\n//\n//\t\t\"github.com/go-chi/chi/v5\"\n//\t\t\"github.com/go-chi/chi/v5/middleware\"\n//\t)\n//\n//\tfunc main() {\n//\t\tr := chi.NewRouter()\n//\t\tr.Use(middleware.Logger)\n//\t\tr.Use(middleware.Recoverer)\n//\n//\t\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n//\t\t\tw.Write([]byte(\"root.\"))\n//\t\t})\n//\n//\t\thttp.ListenAndServe(\":3333\", r)\n//\t}\n//\n// See github.com/go-chi/chi/_examples/ for more in-depth examples.\n//\n// URL patterns allow for easy matching of path components in HTTP\n// requests. The matching components can then be accessed using\n// chi.URLParam(). All patterns must begin with a slash.\n//\n// A simple named placeholder {name} matches any sequence of characters\n// up to the next / or the end of the URL. Trailing slashes on paths must\n// be handled explicitly.\n//\n// A placeholder with a name followed by a colon allows a regular\n// expression match, for example {number:\\\\d+}. The regular expression\n// syntax is Go's normal regexp RE2 syntax, except that regular expressions\n// including { or } are not supported, and / will never be\n// matched. An anonymous regexp pattern is allowed, using an empty string\n// before the colon in the placeholder, such as {:\\\\d+}\n//\n// The special placeholder of asterisk matches the rest of the requested\n// URL. Any trailing characters in the pattern are ignored. This is the only\n// placeholder which will match / characters.\n//\n// Examples:\n//\n//\t\"/user/{name}\" matches \"/user/jsmith\" but not \"/user/jsmith/info\" or \"/user/jsmith/\"\n//\t\"/user/{name}/info\" matches \"/user/jsmith/info\"\n//\t\"/page/*\" matches \"/page/intro/latest\"\n//\t\"/page/{other}/latest\" also matches \"/page/intro/latest\"\n//\t\"/date/{yyyy:\\\\d\\\\d\\\\d\\\\d}/{mm:\\\\d\\\\d}/{dd:\\\\d\\\\d}\" matches \"/date/2017/04/01\"\npackage chi\n\nimport \"net/http\"\n\n// NewRouter returns a new Mux object that implements the Router interface.\nfunc NewRouter() *Mux {\n\treturn NewMux()\n}\n\n// Router consisting of the core routing methods used by chi's Mux,\n// using only the standard net/http.\ntype Router interface {\n\thttp.Handler\n\tRoutes\n\n\t// Use appends one or more middlewares onto the Router stack.\n\tUse(middlewares ...func(http.Handler) http.Handler)\n\n\t// With adds inline middlewares for an endpoint handler.\n\tWith(middlewares ...func(http.Handler) http.Handler) Router\n\n\t// Group adds a new inline-Router along the current routing\n\t// path, with a fresh middleware stack for the inline-Router.\n\tGroup(fn func(r Router)) Router\n\n\t// Route mounts a sub-Router along a `pattern`` string.\n\tRoute(pattern string, fn func(r Router)) Router\n\n\t// Mount attaches another http.Handler along ./pattern/*\n\tMount(pattern string, h http.Handler)\n\n\t// Handle and HandleFunc adds routes for `pattern` that matches\n\t// all HTTP methods.\n\tHandle(pattern string, h http.Handler)\n\tHandleFunc(pattern string, h http.HandlerFunc)\n\n\t// Method and MethodFunc adds routes for `pattern` that matches\n\t// the `method` HTTP method.\n\tMethod(method, pattern string, h http.Handler)\n\tMethodFunc(method, pattern string, h http.HandlerFunc)\n\n\t// HTTP-method routing along `pattern`\n\tConnect(pattern string, h http.HandlerFunc)\n\tDelete(pattern string, h http.HandlerFunc)\n\tGet(pattern string, h http.HandlerFunc)\n\tHead(pattern string, h http.HandlerFunc)\n\tOptions(pattern string, h http.HandlerFunc)\n\tPatch(pattern string, h http.HandlerFunc)\n\tPost(pattern string, h http.HandlerFunc)\n\tPut(pattern string, h http.HandlerFunc)\n\tTrace(pattern string, h http.HandlerFunc)\n\n\t// NotFound defines a handler to respond whenever a route could\n\t// not be found.\n\tNotFound(h http.HandlerFunc)\n\n\t// MethodNotAllowed defines a handler to respond whenever a method is\n\t// not allowed.\n\tMethodNotAllowed(h http.HandlerFunc)\n}\n\n// Routes interface adds two methods for router traversal, which is also\n// used by the `docgen` subpackage to generation documentation for Routers.\ntype Routes interface {\n\t// Routes returns the routing tree in an easily traversable structure.\n\tRoutes() []Route\n\n\t// Middlewares returns the list of middlewares in use by the router.\n\tMiddlewares() Middlewares\n\n\t// Match searches the routing tree for a handler that matches\n\t// the method/path - similar to routing a http request, but without\n\t// executing the handler thereafter.\n\tMatch(rctx *Context, method, path string) bool\n\n\t// Find searches the routing tree for the pattern that matches\n\t// the method/path.\n\tFind(rctx *Context, method, path string) string\n}\n\n// Middlewares type is a slice of standard middleware handlers with methods\n// to compose middleware chains and http.Handler's.\ntype Middlewares []func(http.Handler) http.Handler\n"
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 4.7177734375,
          "content": "package chi\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"strings\"\n)\n\n// URLParam returns the url parameter from a http.Request object.\nfunc URLParam(r *http.Request, key string) string {\n\tif rctx := RouteContext(r.Context()); rctx != nil {\n\t\treturn rctx.URLParam(key)\n\t}\n\treturn \"\"\n}\n\n// URLParamFromCtx returns the url parameter from a http.Request Context.\nfunc URLParamFromCtx(ctx context.Context, key string) string {\n\tif rctx := RouteContext(ctx); rctx != nil {\n\t\treturn rctx.URLParam(key)\n\t}\n\treturn \"\"\n}\n\n// RouteContext returns chi's routing Context object from a\n// http.Request Context.\nfunc RouteContext(ctx context.Context) *Context {\n\tval, _ := ctx.Value(RouteCtxKey).(*Context)\n\treturn val\n}\n\n// NewRouteContext returns a new routing Context object.\nfunc NewRouteContext() *Context {\n\treturn &Context{}\n}\n\nvar (\n\t// RouteCtxKey is the context.Context key to store the request context.\n\tRouteCtxKey = &contextKey{\"RouteContext\"}\n)\n\n// Context is the default routing context set on the root node of a\n// request context to track route patterns, URL parameters and\n// an optional routing path.\ntype Context struct {\n\tRoutes Routes\n\n\t// parentCtx is the parent of this one, for using Context as a\n\t// context.Context directly. This is an optimization that saves\n\t// 1 allocation.\n\tparentCtx context.Context\n\n\t// Routing path/method override used during the route search.\n\t// See Mux#routeHTTP method.\n\tRoutePath   string\n\tRouteMethod string\n\n\t// URLParams are the stack of routeParams captured during the\n\t// routing lifecycle across a stack of sub-routers.\n\tURLParams RouteParams\n\n\t// Route parameters matched for the current sub-router. It is\n\t// intentionally unexported so it can't be tampered.\n\trouteParams RouteParams\n\n\t// The endpoint routing pattern that matched the request URI path\n\t// or `RoutePath` of the current sub-router. This value will update\n\t// during the lifecycle of a request passing through a stack of\n\t// sub-routers.\n\troutePattern string\n\n\t// Routing pattern stack throughout the lifecycle of the request,\n\t// across all connected routers. It is a record of all matching\n\t// patterns across a stack of sub-routers.\n\tRoutePatterns []string\n\n\tmethodsAllowed   []methodTyp // allowed methods in case of a 405\n\tmethodNotAllowed bool\n}\n\n// Reset a routing context to its initial state.\nfunc (x *Context) Reset() {\n\tx.Routes = nil\n\tx.RoutePath = \"\"\n\tx.RouteMethod = \"\"\n\tx.RoutePatterns = x.RoutePatterns[:0]\n\tx.URLParams.Keys = x.URLParams.Keys[:0]\n\tx.URLParams.Values = x.URLParams.Values[:0]\n\n\tx.routePattern = \"\"\n\tx.routeParams.Keys = x.routeParams.Keys[:0]\n\tx.routeParams.Values = x.routeParams.Values[:0]\n\tx.methodNotAllowed = false\n\tx.methodsAllowed = x.methodsAllowed[:0]\n\tx.parentCtx = nil\n}\n\n// URLParam returns the corresponding URL parameter value from the request\n// routing context.\nfunc (x *Context) URLParam(key string) string {\n\tfor k := len(x.URLParams.Keys) - 1; k >= 0; k-- {\n\t\tif x.URLParams.Keys[k] == key {\n\t\t\treturn x.URLParams.Values[k]\n\t\t}\n\t}\n\treturn \"\"\n}\n\n// RoutePattern builds the routing pattern string for the particular\n// request, at the particular point during routing. This means, the value\n// will change throughout the execution of a request in a router. That is\n// why it's advised to only use this value after calling the next handler.\n//\n// For example,\n//\n//\tfunc Instrument(next http.Handler) http.Handler {\n//\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n//\t\t\tnext.ServeHTTP(w, r)\n//\t\t\troutePattern := chi.RouteContext(r.Context()).RoutePattern()\n//\t\t\tmeasure(w, r, routePattern)\n//\t\t})\n//\t}\nfunc (x *Context) RoutePattern() string {\n\tif x == nil {\n\t\treturn \"\"\n\t}\n\troutePattern := strings.Join(x.RoutePatterns, \"\")\n\troutePattern = replaceWildcards(routePattern)\n\tif routePattern != \"/\" {\n\t\troutePattern = strings.TrimSuffix(routePattern, \"//\")\n\t\troutePattern = strings.TrimSuffix(routePattern, \"/\")\n\t}\n\treturn routePattern\n}\n\n// replaceWildcards takes a route pattern and recursively replaces all\n// occurrences of \"/*/\" to \"/\".\nfunc replaceWildcards(p string) string {\n\tif strings.Contains(p, \"/*/\") {\n\t\treturn replaceWildcards(strings.Replace(p, \"/*/\", \"/\", -1))\n\t}\n\treturn p\n}\n\n// RouteParams is a structure to track URL routing parameters efficiently.\ntype RouteParams struct {\n\tKeys, Values []string\n}\n\n// Add will append a URL parameter to the end of the route param\nfunc (s *RouteParams) Add(key, value string) {\n\ts.Keys = append(s.Keys, key)\n\ts.Values = append(s.Values, value)\n}\n\n// contextKey is a value for use with context.WithValue. It's used as\n// a pointer so it fits in an interface{} without allocation. This technique\n// for defining context keys was copied from Go 1.7's new use of context in net/http.\ntype contextKey struct {\n\tname string\n}\n\nfunc (k *contextKey) String() string {\n\treturn \"chi context value \" + k.name\n}\n"
        },
        {
          "name": "context_test.go",
          "type": "blob",
          "size": 2.3515625,
          "content": "package chi\n\nimport \"testing\"\n\n// TestRoutePattern tests correct in-the-middle wildcard removals.\n// If user organizes a router like this:\n//\n// (router.go)\n//\n//\tr.Route(\"/v1\", func(r chi.Router) {\n//\t\tr.Mount(\"/resources\", resourcesController{}.Router())\n//\t}\n//\n// (resources_controller.go)\n//\n//\tr.Route(\"/\", func(r chi.Router) {\n//\t\tr.Get(\"/{resource_id}\", getResource())\n//\t\t// other routes...\n//\t}\n//\n// This test checks how the route pattern is calculated\n// \"/v1/resources/{resource_id}\" (right)\n// \"/v1/resources/*/{resource_id}\" (wrong)\nfunc TestRoutePattern(t *testing.T) {\n\troutePatterns := []string{\n\t\t\"/v1/*\",\n\t\t\"/resources/*\",\n\t\t\"/{resource_id}\",\n\t}\n\n\tx := &Context{\n\t\tRoutePatterns: routePatterns,\n\t}\n\n\tif p := x.RoutePattern(); p != \"/v1/resources/{resource_id}\" {\n\t\tt.Fatal(\"unexpected route pattern: \" + p)\n\t}\n\n\tx.RoutePatterns = []string{\n\t\t\"/v1/*\",\n\t\t\"/resources/*\",\n\t\t// Additional wildcard, depending on the router structure of the user\n\t\t\"/*\",\n\t\t\"/{resource_id}\",\n\t}\n\n\t// Correctly removes in-the-middle wildcards instead of \"/v1/resources/*/{resource_id}\"\n\tif p := x.RoutePattern(); p != \"/v1/resources/{resource_id}\" {\n\t\tt.Fatal(\"unexpected route pattern: \" + p)\n\t}\n\n\tx.RoutePatterns = []string{\n\t\t\"/v1/*\",\n\t\t\"/resources/*\",\n\t\t// Even with many wildcards\n\t\t\"/*\",\n\t\t\"/*\",\n\t\t\"/*\",\n\t\t\"/{resource_id}/*\", // Keeping trailing wildcard\n\t}\n\n\t// Correctly removes in-the-middle wildcards instead of \"/v1/resources/*/*/{resource_id}/*\"\n\tif p := x.RoutePattern(); p != \"/v1/resources/{resource_id}/*\" {\n\t\tt.Fatal(\"unexpected route pattern: \" + p)\n\t}\n\n\tx.RoutePatterns = []string{\n\t\t\"/v1/*\",\n\t\t\"/resources/*\",\n\t\t// And respects asterisks as part of the paths\n\t\t\"/*special_path/*\",\n\t\t\"/with_asterisks*/*\",\n\t\t\"/{resource_id}\",\n\t}\n\n\t// Correctly removes in-the-middle wildcards instead of \"/v1/resourcesspecial_path/with_asterisks{resource_id}\"\n\tif p := x.RoutePattern(); p != \"/v1/resources/*special_path/with_asterisks*/{resource_id}\" {\n\t\tt.Fatal(\"unexpected route pattern: \" + p)\n\t}\n\n\t// Testing for the root route pattern\n\tx.RoutePatterns = []string{\"/\"}\n\t// It should just return \"/\" as the pattern\n\tif p := x.RoutePattern(); p != \"/\" {\n\t\tt.Fatal(\"unexpected route pattern for root: \" + p)\n\t}\n\n\t// Testing empty route pattern for nil context\n\tvar nilContext *Context\n\tif p := nilContext.RoutePattern(); p != \"\" {\n\t\tt.Fatalf(\"unexpected non-empty route pattern for nil context: %q\", p)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0400390625,
          "content": "module github.com/go-chi/chi/v5\n\ngo 1.14\n"
        },
        {
          "name": "middleware",
          "type": "tree",
          "content": null
        },
        {
          "name": "mux.go",
          "type": "blob",
          "size": 16.2861328125,
          "content": "package chi\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n)\n\nvar _ Router = &Mux{}\n\n// Mux is a simple HTTP route multiplexer that parses a request path,\n// records any URL params, and executes an end handler. It implements\n// the http.Handler interface and is friendly with the standard library.\n//\n// Mux is designed to be fast, minimal and offer a powerful API for building\n// modular and composable HTTP services with a large set of handlers. It's\n// particularly useful for writing large REST API services that break a handler\n// into many smaller parts composed of middlewares and end handlers.\ntype Mux struct {\n\t// The computed mux handler made of the chained middleware stack and\n\t// the tree router\n\thandler http.Handler\n\n\t// The radix trie router\n\ttree *node\n\n\t// Custom method not allowed handler\n\tmethodNotAllowedHandler http.HandlerFunc\n\n\t// A reference to the parent mux used by subrouters when mounting\n\t// to a parent mux\n\tparent *Mux\n\n\t// Routing context pool\n\tpool *sync.Pool\n\n\t// Custom route not found handler\n\tnotFoundHandler http.HandlerFunc\n\n\t// The middleware stack\n\tmiddlewares []func(http.Handler) http.Handler\n\n\t// Controls the behaviour of middleware chain generation when a mux\n\t// is registered as an inline group inside another mux.\n\tinline bool\n}\n\n// NewMux returns a newly initialized Mux object that implements the Router\n// interface.\nfunc NewMux() *Mux {\n\tmux := &Mux{tree: &node{}, pool: &sync.Pool{}}\n\tmux.pool.New = func() interface{} {\n\t\treturn NewRouteContext()\n\t}\n\treturn mux\n}\n\n// ServeHTTP is the single method of the http.Handler interface that makes\n// Mux interoperable with the standard library. It uses a sync.Pool to get and\n// reuse routing contexts for each request.\nfunc (mx *Mux) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\t// Ensure the mux has some routes defined on the mux\n\tif mx.handler == nil {\n\t\tmx.NotFoundHandler().ServeHTTP(w, r)\n\t\treturn\n\t}\n\n\t// Check if a routing context already exists from a parent router.\n\trctx, _ := r.Context().Value(RouteCtxKey).(*Context)\n\tif rctx != nil {\n\t\tmx.handler.ServeHTTP(w, r)\n\t\treturn\n\t}\n\n\t// Fetch a RouteContext object from the sync pool, and call the computed\n\t// mx.handler that is comprised of mx.middlewares + mx.routeHTTP.\n\t// Once the request is finished, reset the routing context and put it back\n\t// into the pool for reuse from another request.\n\trctx = mx.pool.Get().(*Context)\n\trctx.Reset()\n\trctx.Routes = mx\n\trctx.parentCtx = r.Context()\n\n\t// NOTE: r.WithContext() causes 2 allocations and context.WithValue() causes 1 allocation\n\tr = r.WithContext(context.WithValue(r.Context(), RouteCtxKey, rctx))\n\n\t// Serve the request and once its done, put the request context back in the sync pool\n\tmx.handler.ServeHTTP(w, r)\n\tmx.pool.Put(rctx)\n}\n\n// Use appends a middleware handler to the Mux middleware stack.\n//\n// The middleware stack for any Mux will execute before searching for a matching\n// route to a specific handler, which provides opportunity to respond early,\n// change the course of the request execution, or set request-scoped values for\n// the next http.Handler.\nfunc (mx *Mux) Use(middlewares ...func(http.Handler) http.Handler) {\n\tif mx.handler != nil {\n\t\tpanic(\"chi: all middlewares must be defined before routes on a mux\")\n\t}\n\tmx.middlewares = append(mx.middlewares, middlewares...)\n}\n\n// Handle adds the route `pattern` that matches any http method to\n// execute the `handler` http.Handler.\nfunc (mx *Mux) Handle(pattern string, handler http.Handler) {\n\tparts := strings.SplitN(pattern, \" \", 2)\n\tif len(parts) == 2 {\n\t\tmx.Method(parts[0], parts[1], handler)\n\t\treturn\n\t}\n\n\tmx.handle(mALL, pattern, handler)\n}\n\n// HandleFunc adds the route `pattern` that matches any http method to\n// execute the `handlerFn` http.HandlerFunc.\nfunc (mx *Mux) HandleFunc(pattern string, handlerFn http.HandlerFunc) {\n\tparts := strings.SplitN(pattern, \" \", 2)\n\tif len(parts) == 2 {\n\t\tmx.Method(parts[0], parts[1], handlerFn)\n\t\treturn\n\t}\n\n\tmx.handle(mALL, pattern, handlerFn)\n}\n\n// Method adds the route `pattern` that matches `method` http method to\n// execute the `handler` http.Handler.\nfunc (mx *Mux) Method(method, pattern string, handler http.Handler) {\n\tm, ok := methodMap[strings.ToUpper(method)]\n\tif !ok {\n\t\tpanic(fmt.Sprintf(\"chi: '%s' http method is not supported.\", method))\n\t}\n\tmx.handle(m, pattern, handler)\n}\n\n// MethodFunc adds the route `pattern` that matches `method` http method to\n// execute the `handlerFn` http.HandlerFunc.\nfunc (mx *Mux) MethodFunc(method, pattern string, handlerFn http.HandlerFunc) {\n\tmx.Method(method, pattern, handlerFn)\n}\n\n// Connect adds the route `pattern` that matches a CONNECT http method to\n// execute the `handlerFn` http.HandlerFunc.\nfunc (mx *Mux) Connect(pattern string, handlerFn http.HandlerFunc) {\n\tmx.handle(mCONNECT, pattern, handlerFn)\n}\n\n// Delete adds the route `pattern` that matches a DELETE http method to\n// execute the `handlerFn` http.HandlerFunc.\nfunc (mx *Mux) Delete(pattern string, handlerFn http.HandlerFunc) {\n\tmx.handle(mDELETE, pattern, handlerFn)\n}\n\n// Get adds the route `pattern` that matches a GET http method to\n// execute the `handlerFn` http.HandlerFunc.\nfunc (mx *Mux) Get(pattern string, handlerFn http.HandlerFunc) {\n\tmx.handle(mGET, pattern, handlerFn)\n}\n\n// Head adds the route `pattern` that matches a HEAD http method to\n// execute the `handlerFn` http.HandlerFunc.\nfunc (mx *Mux) Head(pattern string, handlerFn http.HandlerFunc) {\n\tmx.handle(mHEAD, pattern, handlerFn)\n}\n\n// Options adds the route `pattern` that matches an OPTIONS http method to\n// execute the `handlerFn` http.HandlerFunc.\nfunc (mx *Mux) Options(pattern string, handlerFn http.HandlerFunc) {\n\tmx.handle(mOPTIONS, pattern, handlerFn)\n}\n\n// Patch adds the route `pattern` that matches a PATCH http method to\n// execute the `handlerFn` http.HandlerFunc.\nfunc (mx *Mux) Patch(pattern string, handlerFn http.HandlerFunc) {\n\tmx.handle(mPATCH, pattern, handlerFn)\n}\n\n// Post adds the route `pattern` that matches a POST http method to\n// execute the `handlerFn` http.HandlerFunc.\nfunc (mx *Mux) Post(pattern string, handlerFn http.HandlerFunc) {\n\tmx.handle(mPOST, pattern, handlerFn)\n}\n\n// Put adds the route `pattern` that matches a PUT http method to\n// execute the `handlerFn` http.HandlerFunc.\nfunc (mx *Mux) Put(pattern string, handlerFn http.HandlerFunc) {\n\tmx.handle(mPUT, pattern, handlerFn)\n}\n\n// Trace adds the route `pattern` that matches a TRACE http method to\n// execute the `handlerFn` http.HandlerFunc.\nfunc (mx *Mux) Trace(pattern string, handlerFn http.HandlerFunc) {\n\tmx.handle(mTRACE, pattern, handlerFn)\n}\n\n// NotFound sets a custom http.HandlerFunc for routing paths that could\n// not be found. The default 404 handler is `http.NotFound`.\nfunc (mx *Mux) NotFound(handlerFn http.HandlerFunc) {\n\t// Build NotFound handler chain\n\tm := mx\n\thFn := handlerFn\n\tif mx.inline && mx.parent != nil {\n\t\tm = mx.parent\n\t\thFn = Chain(mx.middlewares...).HandlerFunc(hFn).ServeHTTP\n\t}\n\n\t// Update the notFoundHandler from this point forward\n\tm.notFoundHandler = hFn\n\tm.updateSubRoutes(func(subMux *Mux) {\n\t\tif subMux.notFoundHandler == nil {\n\t\t\tsubMux.NotFound(hFn)\n\t\t}\n\t})\n}\n\n// MethodNotAllowed sets a custom http.HandlerFunc for routing paths where the\n// method is unresolved. The default handler returns a 405 with an empty body.\nfunc (mx *Mux) MethodNotAllowed(handlerFn http.HandlerFunc) {\n\t// Build MethodNotAllowed handler chain\n\tm := mx\n\thFn := handlerFn\n\tif mx.inline && mx.parent != nil {\n\t\tm = mx.parent\n\t\thFn = Chain(mx.middlewares...).HandlerFunc(hFn).ServeHTTP\n\t}\n\n\t// Update the methodNotAllowedHandler from this point forward\n\tm.methodNotAllowedHandler = hFn\n\tm.updateSubRoutes(func(subMux *Mux) {\n\t\tif subMux.methodNotAllowedHandler == nil {\n\t\t\tsubMux.MethodNotAllowed(hFn)\n\t\t}\n\t})\n}\n\n// With adds inline middlewares for an endpoint handler.\nfunc (mx *Mux) With(middlewares ...func(http.Handler) http.Handler) Router {\n\t// Similarly as in handle(), we must build the mux handler once additional\n\t// middleware registration isn't allowed for this stack, like now.\n\tif !mx.inline && mx.handler == nil {\n\t\tmx.updateRouteHandler()\n\t}\n\n\t// Copy middlewares from parent inline muxs\n\tvar mws Middlewares\n\tif mx.inline {\n\t\tmws = make(Middlewares, len(mx.middlewares))\n\t\tcopy(mws, mx.middlewares)\n\t}\n\tmws = append(mws, middlewares...)\n\n\tim := &Mux{\n\t\tpool: mx.pool, inline: true, parent: mx, tree: mx.tree, middlewares: mws,\n\t\tnotFoundHandler: mx.notFoundHandler, methodNotAllowedHandler: mx.methodNotAllowedHandler,\n\t}\n\n\treturn im\n}\n\n// Group creates a new inline-Mux with a copy of middleware stack. It's useful\n// for a group of handlers along the same routing path that use an additional\n// set of middlewares. See _examples/.\nfunc (mx *Mux) Group(fn func(r Router)) Router {\n\tim := mx.With()\n\tif fn != nil {\n\t\tfn(im)\n\t}\n\treturn im\n}\n\n// Route creates a new Mux and mounts it along the `pattern` as a subrouter.\n// Effectively, this is a short-hand call to Mount. See _examples/.\nfunc (mx *Mux) Route(pattern string, fn func(r Router)) Router {\n\tif fn == nil {\n\t\tpanic(fmt.Sprintf(\"chi: attempting to Route() a nil subrouter on '%s'\", pattern))\n\t}\n\tsubRouter := NewRouter()\n\tfn(subRouter)\n\tmx.Mount(pattern, subRouter)\n\treturn subRouter\n}\n\n// Mount attaches another http.Handler or chi Router as a subrouter along a routing\n// path. It's very useful to split up a large API as many independent routers and\n// compose them as a single service using Mount. See _examples/.\n//\n// Note that Mount() simply sets a wildcard along the `pattern` that will continue\n// routing at the `handler`, which in most cases is another chi.Router. As a result,\n// if you define two Mount() routes on the exact same pattern the mount will panic.\nfunc (mx *Mux) Mount(pattern string, handler http.Handler) {\n\tif handler == nil {\n\t\tpanic(fmt.Sprintf(\"chi: attempting to Mount() a nil handler on '%s'\", pattern))\n\t}\n\n\t// Provide runtime safety for ensuring a pattern isn't mounted on an existing\n\t// routing pattern.\n\tif mx.tree.findPattern(pattern+\"*\") || mx.tree.findPattern(pattern+\"/*\") {\n\t\tpanic(fmt.Sprintf(\"chi: attempting to Mount() a handler on an existing path, '%s'\", pattern))\n\t}\n\n\t// Assign sub-Router's with the parent not found & method not allowed handler if not specified.\n\tsubr, ok := handler.(*Mux)\n\tif ok && subr.notFoundHandler == nil && mx.notFoundHandler != nil {\n\t\tsubr.NotFound(mx.notFoundHandler)\n\t}\n\tif ok && subr.methodNotAllowedHandler == nil && mx.methodNotAllowedHandler != nil {\n\t\tsubr.MethodNotAllowed(mx.methodNotAllowedHandler)\n\t}\n\n\tmountHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\trctx := RouteContext(r.Context())\n\n\t\t// shift the url path past the previous subrouter\n\t\trctx.RoutePath = mx.nextRoutePath(rctx)\n\n\t\t// reset the wildcard URLParam which connects the subrouter\n\t\tn := len(rctx.URLParams.Keys) - 1\n\t\tif n >= 0 && rctx.URLParams.Keys[n] == \"*\" && len(rctx.URLParams.Values) > n {\n\t\t\trctx.URLParams.Values[n] = \"\"\n\t\t}\n\n\t\thandler.ServeHTTP(w, r)\n\t})\n\n\tif pattern == \"\" || pattern[len(pattern)-1] != '/' {\n\t\tmx.handle(mALL|mSTUB, pattern, mountHandler)\n\t\tmx.handle(mALL|mSTUB, pattern+\"/\", mountHandler)\n\t\tpattern += \"/\"\n\t}\n\n\tmethod := mALL\n\tsubroutes, _ := handler.(Routes)\n\tif subroutes != nil {\n\t\tmethod |= mSTUB\n\t}\n\tn := mx.handle(method, pattern+\"*\", mountHandler)\n\n\tif subroutes != nil {\n\t\tn.subroutes = subroutes\n\t}\n}\n\n// Routes returns a slice of routing information from the tree,\n// useful for traversing available routes of a router.\nfunc (mx *Mux) Routes() []Route {\n\treturn mx.tree.routes()\n}\n\n// Middlewares returns a slice of middleware handler functions.\nfunc (mx *Mux) Middlewares() Middlewares {\n\treturn mx.middlewares\n}\n\n// Match searches the routing tree for a handler that matches the method/path.\n// It's similar to routing a http request, but without executing the handler\n// thereafter.\n//\n// Note: the *Context state is updated during execution, so manage\n// the state carefully or make a NewRouteContext().\nfunc (mx *Mux) Match(rctx *Context, method, path string) bool {\n\treturn mx.Find(rctx, method, path) != \"\"\n}\n\n// Find searches the routing tree for the pattern that matches\n// the method/path.\n//\n// Note: the *Context state is updated during execution, so manage\n// the state carefully or make a NewRouteContext().\nfunc (mx *Mux) Find(rctx *Context, method, path string) string {\n\tm, ok := methodMap[method]\n\tif !ok {\n\t\treturn \"\"\n\t}\n\n\tnode, _, _ := mx.tree.FindRoute(rctx, m, path)\n\tpattern := rctx.routePattern\n\n\tif node != nil {\n\t\tif node.subroutes == nil {\n\t\t\te := node.endpoints[m]\n\t\t\treturn e.pattern\n\t\t}\n\n\t\trctx.RoutePath = mx.nextRoutePath(rctx)\n\t\tsubPattern := node.subroutes.Find(rctx, method, rctx.RoutePath)\n\t\tif subPattern == \"\" {\n\t\t\treturn \"\"\n\t\t}\n\n\t\tpattern = strings.TrimSuffix(pattern, \"/*\")\n\t\tpattern += subPattern\n\t}\n\n\treturn pattern\n}\n\n// NotFoundHandler returns the default Mux 404 responder whenever a route\n// cannot be found.\nfunc (mx *Mux) NotFoundHandler() http.HandlerFunc {\n\tif mx.notFoundHandler != nil {\n\t\treturn mx.notFoundHandler\n\t}\n\treturn http.NotFound\n}\n\n// MethodNotAllowedHandler returns the default Mux 405 responder whenever\n// a method cannot be resolved for a route.\nfunc (mx *Mux) MethodNotAllowedHandler(methodsAllowed ...methodTyp) http.HandlerFunc {\n\tif mx.methodNotAllowedHandler != nil {\n\t\treturn mx.methodNotAllowedHandler\n\t}\n\treturn methodNotAllowedHandler(methodsAllowed...)\n}\n\n// handle registers a http.Handler in the routing tree for a particular http method\n// and routing pattern.\nfunc (mx *Mux) handle(method methodTyp, pattern string, handler http.Handler) *node {\n\tif len(pattern) == 0 || pattern[0] != '/' {\n\t\tpanic(fmt.Sprintf(\"chi: routing pattern must begin with '/' in '%s'\", pattern))\n\t}\n\n\t// Build the computed routing handler for this routing pattern.\n\tif !mx.inline && mx.handler == nil {\n\t\tmx.updateRouteHandler()\n\t}\n\n\t// Build endpoint handler with inline middlewares for the route\n\tvar h http.Handler\n\tif mx.inline {\n\t\tmx.handler = http.HandlerFunc(mx.routeHTTP)\n\t\th = Chain(mx.middlewares...).Handler(handler)\n\t} else {\n\t\th = handler\n\t}\n\n\t// Add the endpoint to the tree and return the node\n\treturn mx.tree.InsertRoute(method, pattern, h)\n}\n\n// routeHTTP routes a http.Request through the Mux routing tree to serve\n// the matching handler for a particular http method.\nfunc (mx *Mux) routeHTTP(w http.ResponseWriter, r *http.Request) {\n\t// Grab the route context object\n\trctx := r.Context().Value(RouteCtxKey).(*Context)\n\n\t// The request routing path\n\troutePath := rctx.RoutePath\n\tif routePath == \"\" {\n\t\tif r.URL.RawPath != \"\" {\n\t\t\troutePath = r.URL.RawPath\n\t\t} else {\n\t\t\troutePath = r.URL.Path\n\t\t}\n\t\tif routePath == \"\" {\n\t\t\troutePath = \"/\"\n\t\t}\n\t}\n\n\t// Check if method is supported by chi\n\tif rctx.RouteMethod == \"\" {\n\t\trctx.RouteMethod = r.Method\n\t}\n\tmethod, ok := methodMap[rctx.RouteMethod]\n\tif !ok {\n\t\tmx.MethodNotAllowedHandler().ServeHTTP(w, r)\n\t\treturn\n\t}\n\n\t// Find the route\n\tif _, _, h := mx.tree.FindRoute(rctx, method, routePath); h != nil {\n\t\tif supportsPathValue {\n\t\t\tsetPathValue(rctx, r)\n\t\t}\n\n\t\th.ServeHTTP(w, r)\n\t\treturn\n\t}\n\tif rctx.methodNotAllowed {\n\t\tmx.MethodNotAllowedHandler(rctx.methodsAllowed...).ServeHTTP(w, r)\n\t} else {\n\t\tmx.NotFoundHandler().ServeHTTP(w, r)\n\t}\n}\n\nfunc (mx *Mux) nextRoutePath(rctx *Context) string {\n\troutePath := \"/\"\n\tnx := len(rctx.routeParams.Keys) - 1 // index of last param in list\n\tif nx >= 0 && rctx.routeParams.Keys[nx] == \"*\" && len(rctx.routeParams.Values) > nx {\n\t\troutePath = \"/\" + rctx.routeParams.Values[nx]\n\t}\n\treturn routePath\n}\n\n// Recursively update data on child routers.\nfunc (mx *Mux) updateSubRoutes(fn func(subMux *Mux)) {\n\tfor _, r := range mx.tree.routes() {\n\t\tsubMux, ok := r.SubRoutes.(*Mux)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tfn(subMux)\n\t}\n}\n\n// updateRouteHandler builds the single mux handler that is a chain of the middleware\n// stack, as defined by calls to Use(), and the tree router (Mux) itself. After this\n// point, no other middlewares can be registered on this Mux's stack. But you can still\n// compose additional middlewares via Group()'s or using a chained middleware handler.\nfunc (mx *Mux) updateRouteHandler() {\n\tmx.handler = chain(mx.middlewares, http.HandlerFunc(mx.routeHTTP))\n}\n\n// methodNotAllowedHandler is a helper function to respond with a 405,\n// method not allowed. It sets the Allow header with the list of allowed\n// methods for the route.\nfunc methodNotAllowedHandler(methodsAllowed ...methodTyp) func(w http.ResponseWriter, r *http.Request) {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tfor _, m := range methodsAllowed {\n\t\t\tw.Header().Add(\"Allow\", reverseMethodMap[m])\n\t\t}\n\t\tw.WriteHeader(405)\n\t\tw.Write(nil)\n\t}\n}\n"
        },
        {
          "name": "mux_test.go",
          "type": "blob",
          "size": 55.341796875,
          "content": "package chi\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestMuxBasic(t *testing.T) {\n\tvar count uint64\n\tcountermw := func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tcount++\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t}\n\n\tusermw := func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tctx := r.Context()\n\t\t\tctx = context.WithValue(ctx, ctxKey{\"user\"}, \"peter\")\n\t\t\tr = r.WithContext(ctx)\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t}\n\n\texmw := func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tctx := context.WithValue(r.Context(), ctxKey{\"ex\"}, \"a\")\n\t\t\tr = r.WithContext(ctx)\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t}\n\n\tlogbuf := bytes.NewBufferString(\"\")\n\tlogmsg := \"logmw test\"\n\tlogmw := func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tlogbuf.WriteString(logmsg)\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t}\n\n\tcxindex := func(w http.ResponseWriter, r *http.Request) {\n\t\tctx := r.Context()\n\t\tuser := ctx.Value(ctxKey{\"user\"}).(string)\n\t\tw.WriteHeader(200)\n\t\tw.Write([]byte(fmt.Sprintf(\"hi %s\", user)))\n\t}\n\n\tping := func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\tw.Write([]byte(\".\"))\n\t}\n\n\theadPing := func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"X-Ping\", \"1\")\n\t\tw.WriteHeader(200)\n\t}\n\n\tcreatePing := func(w http.ResponseWriter, r *http.Request) {\n\t\t// create ....\n\t\tw.WriteHeader(201)\n\t}\n\n\tpingAll := func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\tw.Write([]byte(\"ping all\"))\n\t}\n\n\tpingAll2 := func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\tw.Write([]byte(\"ping all2\"))\n\t}\n\n\tpingOne := func(w http.ResponseWriter, r *http.Request) {\n\t\tidParam := URLParam(r, \"id\")\n\t\tw.WriteHeader(200)\n\t\tw.Write([]byte(fmt.Sprintf(\"ping one id: %s\", idParam)))\n\t}\n\n\tpingWoop := func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\tw.Write([]byte(\"woop.\" + URLParam(r, \"iidd\")))\n\t}\n\n\tcatchAll := func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\tw.Write([]byte(\"catchall\"))\n\t}\n\n\tm := NewRouter()\n\tm.Use(countermw)\n\tm.Use(usermw)\n\tm.Use(exmw)\n\tm.Use(logmw)\n\tm.Get(\"/\", cxindex)\n\tm.Method(\"GET\", \"/ping\", http.HandlerFunc(ping))\n\tm.MethodFunc(\"GET\", \"/pingall\", pingAll)\n\tm.MethodFunc(\"get\", \"/ping/all\", pingAll)\n\tm.Get(\"/ping/all2\", pingAll2)\n\n\tm.Head(\"/ping\", headPing)\n\tm.Post(\"/ping\", createPing)\n\tm.Get(\"/ping/{id}\", pingWoop)\n\tm.Get(\"/ping/{id}\", pingOne) // expected to overwrite to pingOne handler\n\tm.Get(\"/ping/{iidd}/woop\", pingWoop)\n\tm.HandleFunc(\"/admin/*\", catchAll)\n\t// m.Post(\"/admin/*\", catchAll)\n\n\tts := httptest.NewServer(m)\n\tdefer ts.Close()\n\n\t// GET /\n\tif _, body := testRequest(t, ts, \"GET\", \"/\", nil); body != \"hi peter\" {\n\t\tt.Fatal(body)\n\t}\n\ttlogmsg, _ := logbuf.ReadString(0)\n\tif tlogmsg != logmsg {\n\t\tt.Error(\"expecting log message from middleware:\", logmsg)\n\t}\n\n\t// GET /ping\n\tif _, body := testRequest(t, ts, \"GET\", \"/ping\", nil); body != \".\" {\n\t\tt.Fatal(body)\n\t}\n\n\t// GET /pingall\n\tif _, body := testRequest(t, ts, \"GET\", \"/pingall\", nil); body != \"ping all\" {\n\t\tt.Fatal(body)\n\t}\n\n\t// GET /ping/all\n\tif _, body := testRequest(t, ts, \"GET\", \"/ping/all\", nil); body != \"ping all\" {\n\t\tt.Fatal(body)\n\t}\n\n\t// GET /ping/all2\n\tif _, body := testRequest(t, ts, \"GET\", \"/ping/all2\", nil); body != \"ping all2\" {\n\t\tt.Fatal(body)\n\t}\n\n\t// GET /ping/123\n\tif _, body := testRequest(t, ts, \"GET\", \"/ping/123\", nil); body != \"ping one id: 123\" {\n\t\tt.Fatal(body)\n\t}\n\n\t// GET /ping/allan\n\tif _, body := testRequest(t, ts, \"GET\", \"/ping/allan\", nil); body != \"ping one id: allan\" {\n\t\tt.Fatal(body)\n\t}\n\n\t// GET /ping/1/woop\n\tif _, body := testRequest(t, ts, \"GET\", \"/ping/1/woop\", nil); body != \"woop.1\" {\n\t\tt.Fatal(body)\n\t}\n\n\t// HEAD /ping\n\tresp, err := http.Head(ts.URL + \"/ping\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif resp.StatusCode != 200 {\n\t\tt.Error(\"head failed, should be 200\")\n\t}\n\tif resp.Header.Get(\"X-Ping\") == \"\" {\n\t\tt.Error(\"expecting X-Ping header\")\n\t}\n\n\t// GET /admin/catch-this\n\tif _, body := testRequest(t, ts, \"GET\", \"/admin/catch-thazzzzz\", nil); body != \"catchall\" {\n\t\tt.Fatal(body)\n\t}\n\n\t// POST /admin/catch-this\n\tresp, err = http.Post(ts.URL+\"/admin/casdfsadfs\", \"text/plain\", bytes.NewReader([]byte{}))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != 200 {\n\t\tt.Error(\"POST failed, should be 200\")\n\t}\n\n\tif string(body) != \"catchall\" {\n\t\tt.Error(\"expecting response body: 'catchall'\")\n\t}\n\n\t// Custom http method DIE /ping/1/woop\n\tif resp, body := testRequest(t, ts, \"DIE\", \"/ping/1/woop\", nil); body != \"\" || resp.StatusCode != 405 {\n\t\tt.Fatalf(\"expecting 405 status and empty body, got %d '%s'\", resp.StatusCode, body)\n\t}\n}\n\nfunc TestMuxMounts(t *testing.T) {\n\tr := NewRouter()\n\n\tr.Get(\"/{hash}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tv := URLParam(r, \"hash\")\n\t\tw.Write([]byte(fmt.Sprintf(\"/%s\", v)))\n\t})\n\n\tr.Route(\"/{hash}/share\", func(r Router) {\n\t\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tv := URLParam(r, \"hash\")\n\t\t\tw.Write([]byte(fmt.Sprintf(\"/%s/share\", v)))\n\t\t})\n\t\tr.Get(\"/{network}\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tv := URLParam(r, \"hash\")\n\t\t\tn := URLParam(r, \"network\")\n\t\t\tw.Write([]byte(fmt.Sprintf(\"/%s/share/%s\", v, n)))\n\t\t})\n\t})\n\n\tm := NewRouter()\n\tm.Mount(\"/sharing\", r)\n\n\tts := httptest.NewServer(m)\n\tdefer ts.Close()\n\n\tif _, body := testRequest(t, ts, \"GET\", \"/sharing/aBc\", nil); body != \"/aBc\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/sharing/aBc/share\", nil); body != \"/aBc/share\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/sharing/aBc/share/twitter\", nil); body != \"/aBc/share/twitter\" {\n\t\tt.Fatalf(body)\n\t}\n}\n\nfunc TestMuxPlain(t *testing.T) {\n\tr := NewRouter()\n\tr.Get(\"/hi\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"bye\"))\n\t})\n\tr.NotFound(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(404)\n\t\tw.Write([]byte(\"nothing here\"))\n\t})\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\tif _, body := testRequest(t, ts, \"GET\", \"/hi\", nil); body != \"bye\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/nothing-here\", nil); body != \"nothing here\" {\n\t\tt.Fatalf(body)\n\t}\n}\n\nfunc TestMuxEmptyRoutes(t *testing.T) {\n\tmux := NewRouter()\n\n\tapiRouter := NewRouter()\n\t// oops, we forgot to declare any route handlers\n\n\tmux.Handle(\"/api*\", apiRouter)\n\n\tif _, body := testHandler(t, mux, \"GET\", \"/\", nil); body != \"404 page not found\\n\" {\n\t\tt.Fatalf(body)\n\t}\n\n\tif _, body := testHandler(t, apiRouter, \"GET\", \"/\", nil); body != \"404 page not found\\n\" {\n\t\tt.Fatalf(body)\n\t}\n}\n\n// Test a mux that routes a trailing slash, see also middleware/strip_test.go\n// for an example of using a middleware to handle trailing slashes.\nfunc TestMuxTrailingSlash(t *testing.T) {\n\tr := NewRouter()\n\tr.NotFound(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(404)\n\t\tw.Write([]byte(\"nothing here\"))\n\t})\n\n\tsubRoutes := NewRouter()\n\tindexHandler := func(w http.ResponseWriter, r *http.Request) {\n\t\taccountID := URLParam(r, \"accountID\")\n\t\tw.Write([]byte(accountID))\n\t}\n\tsubRoutes.Get(\"/\", indexHandler)\n\n\tr.Mount(\"/accounts/{accountID}\", subRoutes)\n\tr.Get(\"/accounts/{accountID}/\", indexHandler)\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\tif _, body := testRequest(t, ts, \"GET\", \"/accounts/admin\", nil); body != \"admin\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/accounts/admin/\", nil); body != \"admin\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/nothing-here\", nil); body != \"nothing here\" {\n\t\tt.Fatalf(body)\n\t}\n}\n\nfunc TestMuxNestedNotFound(t *testing.T) {\n\tr := NewRouter()\n\n\tr.Use(func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tr = r.WithContext(context.WithValue(r.Context(), ctxKey{\"mw\"}, \"mw\"))\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t})\n\n\tr.Get(\"/hi\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"bye\"))\n\t})\n\n\tr.With(func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tr = r.WithContext(context.WithValue(r.Context(), ctxKey{\"with\"}, \"with\"))\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t}).NotFound(func(w http.ResponseWriter, r *http.Request) {\n\t\tchkMw := r.Context().Value(ctxKey{\"mw\"}).(string)\n\t\tchkWith := r.Context().Value(ctxKey{\"with\"}).(string)\n\t\tw.WriteHeader(404)\n\t\tw.Write([]byte(fmt.Sprintf(\"root 404 %s %s\", chkMw, chkWith)))\n\t})\n\n\tsr1 := NewRouter()\n\n\tsr1.Get(\"/sub\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"sub\"))\n\t})\n\tsr1.Group(func(sr1 Router) {\n\t\tsr1.Use(func(next http.Handler) http.Handler {\n\t\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tr = r.WithContext(context.WithValue(r.Context(), ctxKey{\"mw2\"}, \"mw2\"))\n\t\t\t\tnext.ServeHTTP(w, r)\n\t\t\t})\n\t\t})\n\t\tsr1.NotFound(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tchkMw2 := r.Context().Value(ctxKey{\"mw2\"}).(string)\n\t\t\tw.WriteHeader(404)\n\t\t\tw.Write([]byte(fmt.Sprintf(\"sub 404 %s\", chkMw2)))\n\t\t})\n\t})\n\n\tsr2 := NewRouter()\n\tsr2.Get(\"/sub\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"sub2\"))\n\t})\n\n\tr.Mount(\"/admin1\", sr1)\n\tr.Mount(\"/admin2\", sr2)\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\tif _, body := testRequest(t, ts, \"GET\", \"/hi\", nil); body != \"bye\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/nothing-here\", nil); body != \"root 404 mw with\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/admin1/sub\", nil); body != \"sub\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/admin1/nope\", nil); body != \"sub 404 mw2\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/admin2/sub\", nil); body != \"sub2\" {\n\t\tt.Fatalf(body)\n\t}\n\n\t// Not found pages should bubble up to the root.\n\tif _, body := testRequest(t, ts, \"GET\", \"/admin2/nope\", nil); body != \"root 404 mw with\" {\n\t\tt.Fatalf(body)\n\t}\n}\n\nfunc TestMethodNotAllowed(t *testing.T) {\n\tr := NewRouter()\n\n\tr.Get(\"/hi\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"hi, get\"))\n\t})\n\n\tr.Head(\"/hi\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"hi, head\"))\n\t})\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\tt.Run(\"Registered Method\", func(t *testing.T) {\n\t\tresp, _ := testRequest(t, ts, \"GET\", \"/hi\", nil)\n\t\tif resp.StatusCode != 200 {\n\t\t\tt.Fatal(resp.Status)\n\t\t}\n\t\tif resp.Header.Values(\"Allow\") != nil {\n\t\t\tt.Fatal(\"allow should be empty when method is registered\")\n\t\t}\n\t})\n\n\tt.Run(\"Unregistered Method\", func(t *testing.T) {\n\t\tresp, _ := testRequest(t, ts, \"POST\", \"/hi\", nil)\n\t\tif resp.StatusCode != 405 {\n\t\t\tt.Fatal(resp.Status)\n\t\t}\n\t\tallowedMethods := resp.Header.Values(\"Allow\")\n\t\tif len(allowedMethods) != 2 || ((allowedMethods[0] != \"GET\" || allowedMethods[1] != \"HEAD\") &&\n\t\t\t(allowedMethods[1] != \"GET\" || allowedMethods[0] != \"HEAD\")) {\n\t\t\tt.Fatal(\"Allow header should contain 2 headers: GET, HEAD. Received: \", allowedMethods)\n\t\t}\n\t})\n}\n\nfunc TestMuxNestedMethodNotAllowed(t *testing.T) {\n\tr := NewRouter()\n\tr.Get(\"/root\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"root\"))\n\t})\n\tr.MethodNotAllowed(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(405)\n\t\tw.Write([]byte(\"root 405\"))\n\t})\n\n\tsr1 := NewRouter()\n\tsr1.Get(\"/sub1\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"sub1\"))\n\t})\n\tsr1.MethodNotAllowed(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(405)\n\t\tw.Write([]byte(\"sub1 405\"))\n\t})\n\n\tsr2 := NewRouter()\n\tsr2.Get(\"/sub2\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"sub2\"))\n\t})\n\n\tpathVar := NewRouter()\n\tpathVar.Get(\"/{var}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"pv\"))\n\t})\n\tpathVar.MethodNotAllowed(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(405)\n\t\tw.Write([]byte(\"pv 405\"))\n\t})\n\n\tr.Mount(\"/prefix1\", sr1)\n\tr.Mount(\"/prefix2\", sr2)\n\tr.Mount(\"/pathVar\", pathVar)\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\tif _, body := testRequest(t, ts, \"GET\", \"/root\", nil); body != \"root\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"PUT\", \"/root\", nil); body != \"root 405\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/prefix1/sub1\", nil); body != \"sub1\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"PUT\", \"/prefix1/sub1\", nil); body != \"sub1 405\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/prefix2/sub2\", nil); body != \"sub2\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"PUT\", \"/prefix2/sub2\", nil); body != \"root 405\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/pathVar/myvar\", nil); body != \"pv\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"DELETE\", \"/pathVar/myvar\", nil); body != \"pv 405\" {\n\t\tt.Fatalf(body)\n\t}\n}\n\nfunc TestMuxComplicatedNotFound(t *testing.T) {\n\tdecorateRouter := func(r *Mux) {\n\t\t// Root router with groups\n\t\tr.Get(\"/auth\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(\"auth get\"))\n\t\t})\n\t\tr.Route(\"/public\", func(r Router) {\n\t\t\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tw.Write([]byte(\"public get\"))\n\t\t\t})\n\t\t})\n\n\t\t// sub router with groups\n\t\tsub0 := NewRouter()\n\t\tsub0.Route(\"/resource\", func(r Router) {\n\t\t\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tw.Write([]byte(\"private get\"))\n\t\t\t})\n\t\t})\n\t\tr.Mount(\"/private\", sub0)\n\n\t\t// sub router with groups\n\t\tsub1 := NewRouter()\n\t\tsub1.Route(\"/resource\", func(r Router) {\n\t\t\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tw.Write([]byte(\"private get\"))\n\t\t\t})\n\t\t})\n\t\tr.With(func(next http.Handler) http.Handler { return next }).Mount(\"/private_mw\", sub1)\n\t}\n\n\ttestNotFound := func(t *testing.T, r *Mux) {\n\t\tts := httptest.NewServer(r)\n\t\tdefer ts.Close()\n\n\t\t// check that we didn't break correct routes\n\t\tif _, body := testRequest(t, ts, \"GET\", \"/auth\", nil); body != \"auth get\" {\n\t\t\tt.Fatalf(body)\n\t\t}\n\t\tif _, body := testRequest(t, ts, \"GET\", \"/public\", nil); body != \"public get\" {\n\t\t\tt.Fatalf(body)\n\t\t}\n\t\tif _, body := testRequest(t, ts, \"GET\", \"/public/\", nil); body != \"public get\" {\n\t\t\tt.Fatalf(body)\n\t\t}\n\t\tif _, body := testRequest(t, ts, \"GET\", \"/private/resource\", nil); body != \"private get\" {\n\t\t\tt.Fatalf(body)\n\t\t}\n\t\t// check custom not-found on all levels\n\t\tif _, body := testRequest(t, ts, \"GET\", \"/nope\", nil); body != \"custom not-found\" {\n\t\t\tt.Fatalf(body)\n\t\t}\n\t\tif _, body := testRequest(t, ts, \"GET\", \"/public/nope\", nil); body != \"custom not-found\" {\n\t\t\tt.Fatalf(body)\n\t\t}\n\t\tif _, body := testRequest(t, ts, \"GET\", \"/private/nope\", nil); body != \"custom not-found\" {\n\t\t\tt.Fatalf(body)\n\t\t}\n\t\tif _, body := testRequest(t, ts, \"GET\", \"/private/resource/nope\", nil); body != \"custom not-found\" {\n\t\t\tt.Fatalf(body)\n\t\t}\n\t\tif _, body := testRequest(t, ts, \"GET\", \"/private_mw/nope\", nil); body != \"custom not-found\" {\n\t\t\tt.Fatalf(body)\n\t\t}\n\t\tif _, body := testRequest(t, ts, \"GET\", \"/private_mw/resource/nope\", nil); body != \"custom not-found\" {\n\t\t\tt.Fatalf(body)\n\t\t}\n\t\t// check custom not-found on trailing slash routes\n\t\tif _, body := testRequest(t, ts, \"GET\", \"/auth/\", nil); body != \"custom not-found\" {\n\t\t\tt.Fatalf(body)\n\t\t}\n\t}\n\n\tt.Run(\"pre\", func(t *testing.T) {\n\t\tr := NewRouter()\n\t\tr.NotFound(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(\"custom not-found\"))\n\t\t})\n\t\tdecorateRouter(r)\n\t\ttestNotFound(t, r)\n\t})\n\n\tt.Run(\"post\", func(t *testing.T) {\n\t\tr := NewRouter()\n\t\tdecorateRouter(r)\n\t\tr.NotFound(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(\"custom not-found\"))\n\t\t})\n\t\ttestNotFound(t, r)\n\t})\n}\n\nfunc TestMuxWith(t *testing.T) {\n\tvar cmwInit1, cmwHandler1 uint64\n\tvar cmwInit2, cmwHandler2 uint64\n\tmw1 := func(next http.Handler) http.Handler {\n\t\tcmwInit1++\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tcmwHandler1++\n\t\t\tr = r.WithContext(context.WithValue(r.Context(), ctxKey{\"inline1\"}, \"yes\"))\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t}\n\tmw2 := func(next http.Handler) http.Handler {\n\t\tcmwInit2++\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tcmwHandler2++\n\t\t\tr = r.WithContext(context.WithValue(r.Context(), ctxKey{\"inline2\"}, \"yes\"))\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t}\n\n\tr := NewRouter()\n\tr.Get(\"/hi\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"bye\"))\n\t})\n\tr.With(mw1).With(mw2).Get(\"/inline\", func(w http.ResponseWriter, r *http.Request) {\n\t\tv1 := r.Context().Value(ctxKey{\"inline1\"}).(string)\n\t\tv2 := r.Context().Value(ctxKey{\"inline2\"}).(string)\n\t\tw.Write([]byte(fmt.Sprintf(\"inline %s %s\", v1, v2)))\n\t})\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\tif _, body := testRequest(t, ts, \"GET\", \"/hi\", nil); body != \"bye\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/inline\", nil); body != \"inline yes yes\" {\n\t\tt.Fatalf(body)\n\t}\n\tif cmwInit1 != 1 {\n\t\tt.Fatalf(\"expecting cmwInit1 to be 1, got %d\", cmwInit1)\n\t}\n\tif cmwHandler1 != 1 {\n\t\tt.Fatalf(\"expecting cmwHandler1 to be 1, got %d\", cmwHandler1)\n\t}\n\tif cmwInit2 != 1 {\n\t\tt.Fatalf(\"expecting cmwInit2 to be 1, got %d\", cmwInit2)\n\t}\n\tif cmwHandler2 != 1 {\n\t\tt.Fatalf(\"expecting cmwHandler2 to be 1, got %d\", cmwHandler2)\n\t}\n}\n\nfunc TestMuxHandlePatternValidation(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tpattern        string\n\t\tshouldPanic    bool\n\t\tmethod         string // Method to be used for the test request\n\t\tpath           string // Path to be used for the test request\n\t\texpectedBody   string // Expected response body\n\t\texpectedStatus int    // Expected HTTP status code\n\t}{\n\t\t// Valid patterns\n\t\t{\n\t\t\tname:           \"Valid pattern without HTTP GET\",\n\t\t\tpattern:        \"/user/{id}\",\n\t\t\tshouldPanic:    false,\n\t\t\tmethod:         \"GET\",\n\t\t\tpath:           \"/user/123\",\n\t\t\texpectedBody:   \"without-prefix GET\",\n\t\t\texpectedStatus: http.StatusOK,\n\t\t},\n\t\t{\n\t\t\tname:           \"Valid pattern with HTTP POST\",\n\t\t\tpattern:        \"POST /products/{id}\",\n\t\t\tshouldPanic:    false,\n\t\t\tmethod:         \"POST\",\n\t\t\tpath:           \"/products/456\",\n\t\t\texpectedBody:   \"with-prefix POST\",\n\t\t\texpectedStatus: http.StatusOK,\n\t\t},\n\t\t// Invalid patterns\n\t\t{\n\t\t\tname:        \"Invalid pattern with no method\",\n\t\t\tpattern:     \"INVALID/user/{id}\",\n\t\t\tshouldPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"Invalid pattern with supported method\",\n\t\t\tpattern:     \"GET/user/{id}\",\n\t\t\tshouldPanic: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"Invalid pattern with unsupported method\",\n\t\t\tpattern:     \"UNSUPPORTED /unsupported-method\",\n\t\t\tshouldPanic: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil && !tc.shouldPanic {\n\t\t\t\t\tt.Errorf(\"Unexpected panic for pattern %s:\\n%v\", tc.pattern, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tr1 := NewRouter()\n\t\t\tr1.Handle(tc.pattern, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tw.Write([]byte(tc.expectedBody))\n\t\t\t}))\n\n\t\t\t// Test that HandleFunc also handles method patterns\n\t\t\tr2 := NewRouter()\n\t\t\tr2.HandleFunc(tc.pattern, func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tw.Write([]byte(tc.expectedBody))\n\t\t\t})\n\n\t\t\tif !tc.shouldPanic {\n\t\t\t\tfor _, r := range []Router{r1, r2} {\n\t\t\t\t\t// Use testRequest for valid patterns\n\t\t\t\t\tts := httptest.NewServer(r)\n\t\t\t\t\tdefer ts.Close()\n\n\t\t\t\t\tresp, body := testRequest(t, ts, tc.method, tc.path, nil)\n\t\t\t\t\tif body != tc.expectedBody || resp.StatusCode != tc.expectedStatus {\n\t\t\t\t\t\tt.Errorf(\"Expected status %d and body %s; got status %d and body %s for pattern %s\",\n\t\t\t\t\t\t\ttc.expectedStatus, tc.expectedBody, resp.StatusCode, body, tc.pattern)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRouterFromMuxWith(t *testing.T) {\n\tt.Parallel()\n\n\tr := NewRouter()\n\n\twith := r.With(func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t})\n\n\twith.Get(\"/with_middleware\", func(w http.ResponseWriter, r *http.Request) {})\n\n\tts := httptest.NewServer(with)\n\tdefer ts.Close()\n\n\t// Without the fix this test was committed with, this causes a panic.\n\ttestRequest(t, ts, http.MethodGet, \"/with_middleware\", nil)\n}\n\nfunc TestMuxMiddlewareStack(t *testing.T) {\n\tvar stdmwInit, stdmwHandler uint64\n\tstdmw := func(next http.Handler) http.Handler {\n\t\tstdmwInit++\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tstdmwHandler++\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t}\n\t_ = stdmw\n\n\tvar ctxmwInit, ctxmwHandler uint64\n\tctxmw := func(next http.Handler) http.Handler {\n\t\tctxmwInit++\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tctxmwHandler++\n\t\t\tctx := r.Context()\n\t\t\tctx = context.WithValue(ctx, ctxKey{\"count.ctxmwHandler\"}, ctxmwHandler)\n\t\t\tr = r.WithContext(ctx)\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t}\n\n\tvar inCtxmwInit, inCtxmwHandler uint64\n\tinCtxmw := func(next http.Handler) http.Handler {\n\t\tinCtxmwInit++\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tinCtxmwHandler++\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t}\n\n\tr := NewRouter()\n\tr.Use(stdmw)\n\tr.Use(ctxmw)\n\tr.Use(func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tif r.URL.Path == \"/ping\" {\n\t\t\t\tw.Write([]byte(\"pong\"))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t})\n\n\tvar handlerCount uint64\n\n\tr.With(inCtxmw).Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\thandlerCount++\n\t\tctx := r.Context()\n\t\tctxmwHandlerCount := ctx.Value(ctxKey{\"count.ctxmwHandler\"}).(uint64)\n\t\tw.Write([]byte(fmt.Sprintf(\"inits:%d reqs:%d ctxValue:%d\", ctxmwInit, handlerCount, ctxmwHandlerCount)))\n\t})\n\n\tr.Get(\"/hi\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"wooot\"))\n\t})\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\ttestRequest(t, ts, \"GET\", \"/\", nil)\n\ttestRequest(t, ts, \"GET\", \"/\", nil)\n\tvar body string\n\t_, body = testRequest(t, ts, \"GET\", \"/\", nil)\n\tif body != \"inits:1 reqs:3 ctxValue:3\" {\n\t\tt.Fatalf(\"got: '%s'\", body)\n\t}\n\n\t_, body = testRequest(t, ts, \"GET\", \"/ping\", nil)\n\tif body != \"pong\" {\n\t\tt.Fatalf(\"got: '%s'\", body)\n\t}\n}\n\nfunc TestMuxRouteGroups(t *testing.T) {\n\tvar stdmwInit, stdmwHandler uint64\n\n\tstdmw := func(next http.Handler) http.Handler {\n\t\tstdmwInit++\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tstdmwHandler++\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t}\n\n\tvar stdmwInit2, stdmwHandler2 uint64\n\tstdmw2 := func(next http.Handler) http.Handler {\n\t\tstdmwInit2++\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tstdmwHandler2++\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t}\n\n\tr := NewRouter()\n\tr.Group(func(r Router) {\n\t\tr.Use(stdmw)\n\t\tr.Get(\"/group\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(\"root group\"))\n\t\t})\n\t})\n\tr.Group(func(r Router) {\n\t\tr.Use(stdmw2)\n\t\tr.Get(\"/group2\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(\"root group2\"))\n\t\t})\n\t})\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\t// GET /group\n\t_, body := testRequest(t, ts, \"GET\", \"/group\", nil)\n\tif body != \"root group\" {\n\t\tt.Fatalf(\"got: '%s'\", body)\n\t}\n\tif stdmwInit != 1 || stdmwHandler != 1 {\n\t\tt.Logf(\"stdmw counters failed, should be 1:1, got %d:%d\", stdmwInit, stdmwHandler)\n\t}\n\n\t// GET /group2\n\t_, body = testRequest(t, ts, \"GET\", \"/group2\", nil)\n\tif body != \"root group2\" {\n\t\tt.Fatalf(\"got: '%s'\", body)\n\t}\n\tif stdmwInit2 != 1 || stdmwHandler2 != 1 {\n\t\tt.Fatalf(\"stdmw2 counters failed, should be 1:1, got %d:%d\", stdmwInit2, stdmwHandler2)\n\t}\n}\n\nfunc TestMuxBig(t *testing.T) {\n\tr := bigMux()\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\tvar body, expected string\n\n\t_, body = testRequest(t, ts, \"GET\", \"/favicon.ico\", nil)\n\tif body != \"fav\" {\n\t\tt.Fatalf(\"got '%s'\", body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/hubs/4/view\", nil)\n\tif body != \"/hubs/4/view reqid:1 session:anonymous\" {\n\t\tt.Fatalf(\"got '%v'\", body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/hubs/4/view/index.html\", nil)\n\tif body != \"/hubs/4/view/index.html reqid:1 session:anonymous\" {\n\t\tt.Fatalf(\"got '%s'\", body)\n\t}\n\t_, body = testRequest(t, ts, \"POST\", \"/hubs/ethereumhub/view/index.html\", nil)\n\tif body != \"/hubs/ethereumhub/view/index.html reqid:1 session:anonymous\" {\n\t\tt.Fatalf(\"got '%s'\", body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/\", nil)\n\tif body != \"/ reqid:1 session:elvis\" {\n\t\tt.Fatalf(\"got '%s'\", body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/suggestions\", nil)\n\tif body != \"/suggestions reqid:1 session:elvis\" {\n\t\tt.Fatalf(\"got '%s'\", body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/woot/444/hiiii\", nil)\n\tif body != \"/woot/444/hiiii\" {\n\t\tt.Fatalf(\"got '%s'\", body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/hubs/123\", nil)\n\texpected = \"/hubs/123 reqid:1 session:elvis\"\n\tif body != expected {\n\t\tt.Fatalf(\"expected:%s got:%s\", expected, body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/hubs/123/touch\", nil)\n\tif body != \"/hubs/123/touch reqid:1 session:elvis\" {\n\t\tt.Fatalf(\"got '%s'\", body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/hubs/123/webhooks\", nil)\n\tif body != \"/hubs/123/webhooks reqid:1 session:elvis\" {\n\t\tt.Fatalf(\"got '%s'\", body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/hubs/123/posts\", nil)\n\tif body != \"/hubs/123/posts reqid:1 session:elvis\" {\n\t\tt.Fatalf(\"got '%s'\", body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/folders\", nil)\n\tif body != \"404 page not found\\n\" {\n\t\tt.Fatalf(\"got '%s'\", body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/folders/\", nil)\n\tif body != \"/folders/ reqid:1 session:elvis\" {\n\t\tt.Fatalf(\"got '%s'\", body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/folders/public\", nil)\n\tif body != \"/folders/public reqid:1 session:elvis\" {\n\t\tt.Fatalf(\"got '%s'\", body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/folders/nothing\", nil)\n\tif body != \"404 page not found\\n\" {\n\t\tt.Fatalf(\"got '%s'\", body)\n\t}\n}\n\nfunc bigMux() Router {\n\tvar r *Mux\n\tvar sr3 *Mux\n\t// var sr1, sr2, sr3, sr4, sr5, sr6 *Mux\n\tr = NewRouter()\n\tr.Use(func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tctx := context.WithValue(r.Context(), ctxKey{\"requestID\"}, \"1\")\n\t\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t\t})\n\t})\n\tr.Use(func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t})\n\tr.Group(func(r Router) {\n\t\tr.Use(func(next http.Handler) http.Handler {\n\t\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tctx := context.WithValue(r.Context(), ctxKey{\"session.user\"}, \"anonymous\")\n\t\t\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t\t\t})\n\t\t})\n\t\tr.Get(\"/favicon.ico\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(\"fav\"))\n\t\t})\n\t\tr.Get(\"/hubs/{hubID}/view\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tctx := r.Context()\n\t\t\ts := fmt.Sprintf(\"/hubs/%s/view reqid:%s session:%s\", URLParam(r, \"hubID\"),\n\t\t\t\tctx.Value(ctxKey{\"requestID\"}), ctx.Value(ctxKey{\"session.user\"}))\n\t\t\tw.Write([]byte(s))\n\t\t})\n\t\tr.Get(\"/hubs/{hubID}/view/*\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tctx := r.Context()\n\t\t\ts := fmt.Sprintf(\"/hubs/%s/view/%s reqid:%s session:%s\", URLParamFromCtx(ctx, \"hubID\"),\n\t\t\t\tURLParam(r, \"*\"), ctx.Value(ctxKey{\"requestID\"}), ctx.Value(ctxKey{\"session.user\"}))\n\t\t\tw.Write([]byte(s))\n\t\t})\n\t\tr.Post(\"/hubs/{hubSlug}/view/*\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tctx := r.Context()\n\t\t\ts := fmt.Sprintf(\"/hubs/%s/view/%s reqid:%s session:%s\", URLParamFromCtx(ctx, \"hubSlug\"),\n\t\t\t\tURLParam(r, \"*\"), ctx.Value(ctxKey{\"requestID\"}), ctx.Value(ctxKey{\"session.user\"}))\n\t\t\tw.Write([]byte(s))\n\t\t})\n\t})\n\tr.Group(func(r Router) {\n\t\tr.Use(func(next http.Handler) http.Handler {\n\t\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tctx := context.WithValue(r.Context(), ctxKey{\"session.user\"}, \"elvis\")\n\t\t\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t\t\t})\n\t\t})\n\t\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tctx := r.Context()\n\t\t\ts := fmt.Sprintf(\"/ reqid:%s session:%s\", ctx.Value(ctxKey{\"requestID\"}), ctx.Value(ctxKey{\"session.user\"}))\n\t\t\tw.Write([]byte(s))\n\t\t})\n\t\tr.Get(\"/suggestions\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tctx := r.Context()\n\t\t\ts := fmt.Sprintf(\"/suggestions reqid:%s session:%s\", ctx.Value(ctxKey{\"requestID\"}), ctx.Value(ctxKey{\"session.user\"}))\n\t\t\tw.Write([]byte(s))\n\t\t})\n\n\t\tr.Get(\"/woot/{wootID}/*\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\ts := fmt.Sprintf(\"/woot/%s/%s\", URLParam(r, \"wootID\"), URLParam(r, \"*\"))\n\t\t\tw.Write([]byte(s))\n\t\t})\n\n\t\tr.Route(\"/hubs\", func(r Router) {\n\t\t\t_ = r.(*Mux) // sr1\n\t\t\tr.Route(\"/{hubID}\", func(r Router) {\n\t\t\t\t_ = r.(*Mux) // sr2\n\t\t\t\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\tctx := r.Context()\n\t\t\t\t\ts := fmt.Sprintf(\"/hubs/%s reqid:%s session:%s\",\n\t\t\t\t\t\tURLParam(r, \"hubID\"), ctx.Value(ctxKey{\"requestID\"}), ctx.Value(ctxKey{\"session.user\"}))\n\t\t\t\t\tw.Write([]byte(s))\n\t\t\t\t})\n\t\t\t\tr.Get(\"/touch\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\tctx := r.Context()\n\t\t\t\t\ts := fmt.Sprintf(\"/hubs/%s/touch reqid:%s session:%s\", URLParam(r, \"hubID\"),\n\t\t\t\t\t\tctx.Value(ctxKey{\"requestID\"}), ctx.Value(ctxKey{\"session.user\"}))\n\t\t\t\t\tw.Write([]byte(s))\n\t\t\t\t})\n\n\t\t\t\tsr3 = NewRouter()\n\t\t\t\tsr3.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\tctx := r.Context()\n\t\t\t\t\ts := fmt.Sprintf(\"/hubs/%s/webhooks reqid:%s session:%s\", URLParam(r, \"hubID\"),\n\t\t\t\t\t\tctx.Value(ctxKey{\"requestID\"}), ctx.Value(ctxKey{\"session.user\"}))\n\t\t\t\t\tw.Write([]byte(s))\n\t\t\t\t})\n\t\t\t\tsr3.Route(\"/{webhookID}\", func(r Router) {\n\t\t\t\t\t_ = r.(*Mux) // sr4\n\t\t\t\t\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\t\tctx := r.Context()\n\t\t\t\t\t\ts := fmt.Sprintf(\"/hubs/%s/webhooks/%s reqid:%s session:%s\", URLParam(r, \"hubID\"),\n\t\t\t\t\t\t\tURLParam(r, \"webhookID\"), ctx.Value(ctxKey{\"requestID\"}), ctx.Value(ctxKey{\"session.user\"}))\n\t\t\t\t\t\tw.Write([]byte(s))\n\t\t\t\t\t})\n\t\t\t\t})\n\n\t\t\t\tr.Mount(\"/webhooks\", Chain(func(next http.Handler) http.Handler {\n\t\t\t\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\t\tnext.ServeHTTP(w, r.WithContext(context.WithValue(r.Context(), ctxKey{\"hook\"}, true)))\n\t\t\t\t\t})\n\t\t\t\t}).Handler(sr3))\n\n\t\t\t\tr.Route(\"/posts\", func(r Router) {\n\t\t\t\t\t_ = r.(*Mux) // sr5\n\t\t\t\t\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\t\tctx := r.Context()\n\t\t\t\t\t\ts := fmt.Sprintf(\"/hubs/%s/posts reqid:%s session:%s\", URLParam(r, \"hubID\"),\n\t\t\t\t\t\t\tctx.Value(ctxKey{\"requestID\"}), ctx.Value(ctxKey{\"session.user\"}))\n\t\t\t\t\t\tw.Write([]byte(s))\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\n\t\tr.Route(\"/folders/\", func(r Router) {\n\t\t\t_ = r.(*Mux) // sr6\n\t\t\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tctx := r.Context()\n\t\t\t\ts := fmt.Sprintf(\"/folders/ reqid:%s session:%s\",\n\t\t\t\t\tctx.Value(ctxKey{\"requestID\"}), ctx.Value(ctxKey{\"session.user\"}))\n\t\t\t\tw.Write([]byte(s))\n\t\t\t})\n\t\t\tr.Get(\"/public\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tctx := r.Context()\n\t\t\t\ts := fmt.Sprintf(\"/folders/public reqid:%s session:%s\",\n\t\t\t\t\tctx.Value(ctxKey{\"requestID\"}), ctx.Value(ctxKey{\"session.user\"}))\n\t\t\t\tw.Write([]byte(s))\n\t\t\t})\n\t\t})\n\t})\n\n\treturn r\n}\n\nfunc TestMuxSubroutesBasic(t *testing.T) {\n\thIndex := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"index\"))\n\t})\n\thArticlesList := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"articles-list\"))\n\t})\n\thSearchArticles := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"search-articles\"))\n\t})\n\thGetArticle := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(fmt.Sprintf(\"get-article:%s\", URLParam(r, \"id\"))))\n\t})\n\thSyncArticle := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(fmt.Sprintf(\"sync-article:%s\", URLParam(r, \"id\"))))\n\t})\n\n\tr := NewRouter()\n\t// var rr1, rr2 *Mux\n\tr.Get(\"/\", hIndex)\n\tr.Route(\"/articles\", func(r Router) {\n\t\t// rr1 = r.(*Mux)\n\t\tr.Get(\"/\", hArticlesList)\n\t\tr.Get(\"/search\", hSearchArticles)\n\t\tr.Route(\"/{id}\", func(r Router) {\n\t\t\t// rr2 = r.(*Mux)\n\t\t\tr.Get(\"/\", hGetArticle)\n\t\t\tr.Get(\"/sync\", hSyncArticle)\n\t\t})\n\t})\n\n\t// log.Println(\"~~~~~~~~~\")\n\t// log.Println(\"~~~~~~~~~\")\n\t// debugPrintTree(0, 0, r.tree, 0)\n\t// log.Println(\"~~~~~~~~~\")\n\t// log.Println(\"~~~~~~~~~\")\n\n\t// log.Println(\"~~~~~~~~~\")\n\t// log.Println(\"~~~~~~~~~\")\n\t// debugPrintTree(0, 0, rr1.tree, 0)\n\t// log.Println(\"~~~~~~~~~\")\n\t// log.Println(\"~~~~~~~~~\")\n\n\t// log.Println(\"~~~~~~~~~\")\n\t// log.Println(\"~~~~~~~~~\")\n\t// debugPrintTree(0, 0, rr2.tree, 0)\n\t// log.Println(\"~~~~~~~~~\")\n\t// log.Println(\"~~~~~~~~~\")\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\tvar body, expected string\n\n\t_, body = testRequest(t, ts, \"GET\", \"/\", nil)\n\texpected = \"index\"\n\tif body != expected {\n\t\tt.Fatalf(\"expected:%s got:%s\", expected, body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/articles\", nil)\n\texpected = \"articles-list\"\n\tif body != expected {\n\t\tt.Fatalf(\"expected:%s got:%s\", expected, body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/articles/search\", nil)\n\texpected = \"search-articles\"\n\tif body != expected {\n\t\tt.Fatalf(\"expected:%s got:%s\", expected, body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/articles/123\", nil)\n\texpected = \"get-article:123\"\n\tif body != expected {\n\t\tt.Fatalf(\"expected:%s got:%s\", expected, body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/articles/123/sync\", nil)\n\texpected = \"sync-article:123\"\n\tif body != expected {\n\t\tt.Fatalf(\"expected:%s got:%s\", expected, body)\n\t}\n}\n\nfunc TestMuxSubroutes(t *testing.T) {\n\thHubView1 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"hub1\"))\n\t})\n\thHubView2 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"hub2\"))\n\t})\n\thHubView3 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"hub3\"))\n\t})\n\thAccountView1 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"account1\"))\n\t})\n\thAccountView2 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"account2\"))\n\t})\n\n\tr := NewRouter()\n\tr.Get(\"/hubs/{hubID}/view\", hHubView1)\n\tr.Get(\"/hubs/{hubID}/view/*\", hHubView2)\n\n\tsr := NewRouter()\n\tsr.Get(\"/\", hHubView3)\n\tr.Mount(\"/hubs/{hubID}/users\", sr)\n\tr.Get(\"/hubs/{hubID}/users/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"hub3 override\"))\n\t})\n\n\tsr3 := NewRouter()\n\tsr3.Get(\"/\", hAccountView1)\n\tsr3.Get(\"/hi\", hAccountView2)\n\n\t// var sr2 *Mux\n\tr.Route(\"/accounts/{accountID}\", func(r Router) {\n\t\t_ = r.(*Mux) // sr2\n\t\t// r.Get(\"/\", hAccountView1)\n\t\tr.Mount(\"/\", sr3)\n\t})\n\n\t// This is the same as the r.Route() call mounted on sr2\n\t// sr2 := NewRouter()\n\t// sr2.Mount(\"/\", sr3)\n\t// r.Mount(\"/accounts/{accountID}\", sr2)\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\tvar body, expected string\n\n\t_, body = testRequest(t, ts, \"GET\", \"/hubs/123/view\", nil)\n\texpected = \"hub1\"\n\tif body != expected {\n\t\tt.Fatalf(\"expected:%s got:%s\", expected, body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/hubs/123/view/index.html\", nil)\n\texpected = \"hub2\"\n\tif body != expected {\n\t\tt.Fatalf(\"expected:%s got:%s\", expected, body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/hubs/123/users\", nil)\n\texpected = \"hub3\"\n\tif body != expected {\n\t\tt.Fatalf(\"expected:%s got:%s\", expected, body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/hubs/123/users/\", nil)\n\texpected = \"hub3 override\"\n\tif body != expected {\n\t\tt.Fatalf(\"expected:%s got:%s\", expected, body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/accounts/44\", nil)\n\texpected = \"account1\"\n\tif body != expected {\n\t\tt.Fatalf(\"request:%s expected:%s got:%s\", \"GET /accounts/44\", expected, body)\n\t}\n\t_, body = testRequest(t, ts, \"GET\", \"/accounts/44/hi\", nil)\n\texpected = \"account2\"\n\tif body != expected {\n\t\tt.Fatalf(\"expected:%s got:%s\", expected, body)\n\t}\n\n\t// Test that we're building the routingPatterns properly\n\trouter := r\n\treq, _ := http.NewRequest(\"GET\", \"/accounts/44/hi\", nil)\n\n\trctx := NewRouteContext()\n\treq = req.WithContext(context.WithValue(req.Context(), RouteCtxKey, rctx))\n\n\tw := httptest.NewRecorder()\n\trouter.ServeHTTP(w, req)\n\n\tbody = w.Body.String()\n\texpected = \"account2\"\n\tif body != expected {\n\t\tt.Fatalf(\"expected:%s got:%s\", expected, body)\n\t}\n\n\troutePatterns := rctx.RoutePatterns\n\tif len(rctx.RoutePatterns) != 3 {\n\t\tt.Fatalf(\"expected 3 routing patterns, got:%d\", len(rctx.RoutePatterns))\n\t}\n\texpected = \"/accounts/{accountID}/*\"\n\tif routePatterns[0] != expected {\n\t\tt.Fatalf(\"routePattern, expected:%s got:%s\", expected, routePatterns[0])\n\t}\n\texpected = \"/*\"\n\tif routePatterns[1] != expected {\n\t\tt.Fatalf(\"routePattern, expected:%s got:%s\", expected, routePatterns[1])\n\t}\n\texpected = \"/hi\"\n\tif routePatterns[2] != expected {\n\t\tt.Fatalf(\"routePattern, expected:%s got:%s\", expected, routePatterns[2])\n\t}\n\n}\n\nfunc TestSingleHandler(t *testing.T) {\n\th := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tname := URLParam(r, \"name\")\n\t\tw.Write([]byte(\"hi \" + name))\n\t})\n\n\tr, _ := http.NewRequest(\"GET\", \"/\", nil)\n\trctx := NewRouteContext()\n\tr = r.WithContext(context.WithValue(r.Context(), RouteCtxKey, rctx))\n\trctx.URLParams.Add(\"name\", \"joe\")\n\n\tw := httptest.NewRecorder()\n\th.ServeHTTP(w, r)\n\n\tbody := w.Body.String()\n\texpected := \"hi joe\"\n\tif body != expected {\n\t\tt.Fatalf(\"expected:%s got:%s\", expected, body)\n\t}\n}\n\n// TODO: a Router wrapper test..\n//\n// type ACLMux struct {\n// \t*Mux\n// \tXX string\n// }\n//\n// func NewACLMux() *ACLMux {\n// \treturn &ACLMux{Mux: NewRouter(), XX: \"hihi\"}\n// }\n//\n// // TODO: this should be supported...\n// func TestWoot(t *testing.T) {\n// \tvar r Router = NewRouter()\n//\n// \tvar r2 Router = NewACLMux() //NewRouter()\n// \tr2.Get(\"/hi\", func(w http.ResponseWriter, r *http.Request) {\n// \t\tw.Write([]byte(\"hi\"))\n// \t})\n//\n// \tr.Mount(\"/\", r2)\n// }\n\nfunc TestServeHTTPExistingContext(t *testing.T) {\n\tr := NewRouter()\n\tr.Get(\"/hi\", func(w http.ResponseWriter, r *http.Request) {\n\t\ts, _ := r.Context().Value(ctxKey{\"testCtx\"}).(string)\n\t\tw.Write([]byte(s))\n\t})\n\tr.NotFound(func(w http.ResponseWriter, r *http.Request) {\n\t\ts, _ := r.Context().Value(ctxKey{\"testCtx\"}).(string)\n\t\tw.WriteHeader(404)\n\t\tw.Write([]byte(s))\n\t})\n\n\ttestcases := []struct {\n\t\tCtx            context.Context\n\t\tMethod         string\n\t\tPath           string\n\t\tExpectedBody   string\n\t\tExpectedStatus int\n\t}{\n\t\t{\n\t\t\tMethod:         \"GET\",\n\t\t\tPath:           \"/hi\",\n\t\t\tCtx:            context.WithValue(context.Background(), ctxKey{\"testCtx\"}, \"hi ctx\"),\n\t\t\tExpectedStatus: 200,\n\t\t\tExpectedBody:   \"hi ctx\",\n\t\t},\n\t\t{\n\t\t\tMethod:         \"GET\",\n\t\t\tPath:           \"/hello\",\n\t\t\tCtx:            context.WithValue(context.Background(), ctxKey{\"testCtx\"}, \"nothing here ctx\"),\n\t\t\tExpectedStatus: 404,\n\t\t\tExpectedBody:   \"nothing here ctx\",\n\t\t},\n\t}\n\n\tfor _, tc := range testcases {\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(tc.Method, tc.Path, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t\treq = req.WithContext(tc.Ctx)\n\t\tr.ServeHTTP(resp, req)\n\t\tb, err := ioutil.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t\tif resp.Code != tc.ExpectedStatus {\n\t\t\tt.Fatalf(\"%v != %v\", tc.ExpectedStatus, resp.Code)\n\t\t}\n\t\tif string(b) != tc.ExpectedBody {\n\t\t\tt.Fatalf(\"%s != %s\", tc.ExpectedBody, b)\n\t\t}\n\t}\n}\n\nfunc TestNestedGroups(t *testing.T) {\n\thandlerPrintCounter := func(w http.ResponseWriter, r *http.Request) {\n\t\tcounter, _ := r.Context().Value(ctxKey{\"counter\"}).(int)\n\t\tw.Write([]byte(fmt.Sprintf(\"%v\", counter)))\n\t}\n\n\tmwIncreaseCounter := func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tctx := r.Context()\n\t\t\tcounter, _ := ctx.Value(ctxKey{\"counter\"}).(int)\n\t\t\tcounter++\n\t\t\tctx = context.WithValue(ctx, ctxKey{\"counter\"}, counter)\n\t\t\tnext.ServeHTTP(w, r.WithContext(ctx))\n\t\t})\n\t}\n\n\t// Each route represents value of its counter (number of applied middlewares).\n\tr := NewRouter() // counter == 0\n\tr.Get(\"/0\", handlerPrintCounter)\n\tr.Group(func(r Router) {\n\t\tr.Use(mwIncreaseCounter) // counter == 1\n\t\tr.Get(\"/1\", handlerPrintCounter)\n\n\t\t// r.Handle(GET, \"/2\", Chain(mwIncreaseCounter).HandlerFunc(handlerPrintCounter))\n\t\tr.With(mwIncreaseCounter).Get(\"/2\", handlerPrintCounter)\n\n\t\tr.Group(func(r Router) {\n\t\t\tr.Use(mwIncreaseCounter, mwIncreaseCounter) // counter == 3\n\t\t\tr.Get(\"/3\", handlerPrintCounter)\n\t\t})\n\t\tr.Route(\"/\", func(r Router) {\n\t\t\tr.Use(mwIncreaseCounter, mwIncreaseCounter) // counter == 3\n\n\t\t\t// r.Handle(GET, \"/4\", Chain(mwIncreaseCounter).HandlerFunc(handlerPrintCounter))\n\t\t\tr.With(mwIncreaseCounter).Get(\"/4\", handlerPrintCounter)\n\n\t\t\tr.Group(func(r Router) {\n\t\t\t\tr.Use(mwIncreaseCounter, mwIncreaseCounter) // counter == 5\n\t\t\t\tr.Get(\"/5\", handlerPrintCounter)\n\t\t\t\t// r.Handle(GET, \"/6\", Chain(mwIncreaseCounter).HandlerFunc(handlerPrintCounter))\n\t\t\t\tr.With(mwIncreaseCounter).Get(\"/6\", handlerPrintCounter)\n\n\t\t\t})\n\t\t})\n\t})\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\tfor _, route := range []string{\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\"} {\n\t\tif _, body := testRequest(t, ts, \"GET\", \"/\"+route, nil); body != route {\n\t\t\tt.Errorf(\"expected %v, got %v\", route, body)\n\t\t}\n\t}\n}\n\nfunc TestMiddlewarePanicOnLateUse(t *testing.T) {\n\thandler := func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"hello\\n\"))\n\t}\n\n\tmw := func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t}\n\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Error(\"expected panic()\")\n\t\t}\n\t}()\n\n\tr := NewRouter()\n\tr.Get(\"/\", handler)\n\tr.Use(mw) // Too late to apply middleware, we're expecting panic().\n}\n\nfunc TestMountingExistingPath(t *testing.T) {\n\thandler := func(w http.ResponseWriter, r *http.Request) {}\n\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Error(\"expected panic()\")\n\t\t}\n\t}()\n\n\tr := NewRouter()\n\tr.Get(\"/\", handler)\n\tr.Mount(\"/hi\", http.HandlerFunc(handler))\n\tr.Mount(\"/hi\", http.HandlerFunc(handler))\n}\n\nfunc TestMountingSimilarPattern(t *testing.T) {\n\tr := NewRouter()\n\tr.Get(\"/hi\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"bye\"))\n\t})\n\n\tr2 := NewRouter()\n\tr2.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"foobar\"))\n\t})\n\n\tr3 := NewRouter()\n\tr3.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"foo\"))\n\t})\n\n\tr.Mount(\"/foobar\", r2)\n\tr.Mount(\"/foo\", r3)\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\tif _, body := testRequest(t, ts, \"GET\", \"/hi\", nil); body != \"bye\" {\n\t\tt.Fatalf(body)\n\t}\n}\n\nfunc TestMuxEmptyParams(t *testing.T) {\n\tr := NewRouter()\n\tr.Get(`/users/{x}/{y}/{z}`, func(w http.ResponseWriter, r *http.Request) {\n\t\tx := URLParam(r, \"x\")\n\t\ty := URLParam(r, \"y\")\n\t\tz := URLParam(r, \"z\")\n\t\tw.Write([]byte(fmt.Sprintf(\"%s-%s-%s\", x, y, z)))\n\t})\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\tif _, body := testRequest(t, ts, \"GET\", \"/users/a/b/c\", nil); body != \"a-b-c\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/users///c\", nil); body != \"--c\" {\n\t\tt.Fatalf(body)\n\t}\n}\n\nfunc TestMuxMissingParams(t *testing.T) {\n\tr := NewRouter()\n\tr.Get(`/user/{userId:\\d+}`, func(w http.ResponseWriter, r *http.Request) {\n\t\tuserID := URLParam(r, \"userId\")\n\t\tw.Write([]byte(fmt.Sprintf(\"userId = '%s'\", userID)))\n\t})\n\tr.NotFound(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(404)\n\t\tw.Write([]byte(\"nothing here\"))\n\t})\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\tif _, body := testRequest(t, ts, \"GET\", \"/user/123\", nil); body != \"userId = '123'\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/user/\", nil); body != \"nothing here\" {\n\t\tt.Fatalf(body)\n\t}\n}\n\nfunc TestMuxWildcardRoute(t *testing.T) {\n\thandler := func(w http.ResponseWriter, r *http.Request) {}\n\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Error(\"expected panic()\")\n\t\t}\n\t}()\n\n\tr := NewRouter()\n\tr.Get(\"/*/wildcard/must/be/at/end\", handler)\n}\n\nfunc TestMuxWildcardRouteCheckTwo(t *testing.T) {\n\thandler := func(w http.ResponseWriter, r *http.Request) {}\n\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Error(\"expected panic()\")\n\t\t}\n\t}()\n\n\tr := NewRouter()\n\tr.Get(\"/*/wildcard/{must}/be/at/end\", handler)\n}\n\nfunc TestMuxRegexp(t *testing.T) {\n\tr := NewRouter()\n\tr.Route(\"/{param:[0-9]*}/test\", func(r Router) {\n\t\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(fmt.Sprintf(\"Hi: %s\", URLParam(r, \"param\"))))\n\t\t})\n\t})\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\tif _, body := testRequest(t, ts, \"GET\", \"//test\", nil); body != \"Hi: \" {\n\t\tt.Fatalf(body)\n\t}\n}\n\nfunc TestMuxRegexp2(t *testing.T) {\n\tr := NewRouter()\n\tr.Get(\"/foo-{suffix:[a-z]{2,3}}.json\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(URLParam(r, \"suffix\")))\n\t})\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\tif _, body := testRequest(t, ts, \"GET\", \"/foo-.json\", nil); body != \"\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/foo-abc.json\", nil); body != \"abc\" {\n\t\tt.Fatalf(body)\n\t}\n}\n\nfunc TestMuxRegexp3(t *testing.T) {\n\tr := NewRouter()\n\tr.Get(\"/one/{firstId:[a-z0-9-]+}/{secondId:[a-z]+}/first\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"first\"))\n\t})\n\tr.Get(\"/one/{firstId:[a-z0-9-_]+}/{secondId:[0-9]+}/second\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"second\"))\n\t})\n\tr.Delete(\"/one/{firstId:[a-z0-9-_]+}/{secondId:[0-9]+}/second\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"third\"))\n\t})\n\n\tr.Route(\"/one\", func(r Router) {\n\t\tr.Get(\"/{dns:[a-z-0-9_]+}\", func(writer http.ResponseWriter, request *http.Request) {\n\t\t\twriter.Write([]byte(\"_\"))\n\t\t})\n\t\tr.Get(\"/{dns:[a-z-0-9_]+}/info\", func(writer http.ResponseWriter, request *http.Request) {\n\t\t\twriter.Write([]byte(\"_\"))\n\t\t})\n\t\tr.Delete(\"/{id:[0-9]+}\", func(writer http.ResponseWriter, request *http.Request) {\n\t\t\twriter.Write([]byte(\"forth\"))\n\t\t})\n\t})\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\tif _, body := testRequest(t, ts, \"GET\", \"/one/hello/peter/first\", nil); body != \"first\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/one/hithere/123/second\", nil); body != \"second\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"DELETE\", \"/one/hithere/123/second\", nil); body != \"third\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"DELETE\", \"/one/123\", nil); body != \"forth\" {\n\t\tt.Fatalf(body)\n\t}\n}\n\nfunc TestMuxSubrouterWildcardParam(t *testing.T) {\n\th := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"param:%v *:%v\", URLParam(r, \"param\"), URLParam(r, \"*\"))\n\t})\n\n\tr := NewRouter()\n\n\tr.Get(\"/bare/{param}\", h)\n\tr.Get(\"/bare/{param}/*\", h)\n\n\tr.Route(\"/case0\", func(r Router) {\n\t\tr.Get(\"/{param}\", h)\n\t\tr.Get(\"/{param}/*\", h)\n\t})\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\tif _, body := testRequest(t, ts, \"GET\", \"/bare/hi\", nil); body != \"param:hi *:\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/bare/hi/yes\", nil); body != \"param:hi *:yes\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/case0/hi\", nil); body != \"param:hi *:\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"GET\", \"/case0/hi/yes\", nil); body != \"param:hi *:yes\" {\n\t\tt.Fatalf(body)\n\t}\n}\n\nfunc TestMuxContextIsThreadSafe(t *testing.T) {\n\trouter := NewRouter()\n\trouter.Get(\"/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\tctx, cancel := context.WithTimeout(r.Context(), 1*time.Millisecond)\n\t\tdefer cancel()\n\n\t\t<-ctx.Done()\n\t})\n\n\twg := sync.WaitGroup{}\n\n\tfor i := 0; i < 100; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor j := 0; j < 10000; j++ {\n\t\t\t\tw := httptest.NewRecorder()\n\t\t\t\tr, err := http.NewRequest(\"GET\", \"/ok\", nil)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tctx, cancel := context.WithCancel(r.Context())\n\t\t\t\tr = r.WithContext(ctx)\n\n\t\t\t\tgo func() {\n\t\t\t\t\tcancel()\n\t\t\t\t}()\n\t\t\t\trouter.ServeHTTP(w, r)\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc TestEscapedURLParams(t *testing.T) {\n\tm := NewRouter()\n\tm.Get(\"/api/{identifier}/{region}/{size}/{rotation}/*\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\trctx := RouteContext(r.Context())\n\t\tif rctx == nil {\n\t\t\tt.Error(\"no context\")\n\t\t\treturn\n\t\t}\n\t\tidentifier := URLParam(r, \"identifier\")\n\t\tif identifier != \"http:%2f%2fexample.com%2fimage.png\" {\n\t\t\tt.Errorf(\"identifier path parameter incorrect %s\", identifier)\n\t\t\treturn\n\t\t}\n\t\tregion := URLParam(r, \"region\")\n\t\tif region != \"full\" {\n\t\t\tt.Errorf(\"region path parameter incorrect %s\", region)\n\t\t\treturn\n\t\t}\n\t\tsize := URLParam(r, \"size\")\n\t\tif size != \"max\" {\n\t\t\tt.Errorf(\"size path parameter incorrect %s\", size)\n\t\t\treturn\n\t\t}\n\t\trotation := URLParam(r, \"rotation\")\n\t\tif rotation != \"0\" {\n\t\t\tt.Errorf(\"rotation path parameter incorrect %s\", rotation)\n\t\t\treturn\n\t\t}\n\t\tw.Write([]byte(\"success\"))\n\t})\n\n\tts := httptest.NewServer(m)\n\tdefer ts.Close()\n\n\tif _, body := testRequest(t, ts, \"GET\", \"/api/http:%2f%2fexample.com%2fimage.png/full/max/0/color.png\", nil); body != \"success\" {\n\t\tt.Fatalf(body)\n\t}\n}\n\nfunc TestCustomHTTPMethod(t *testing.T) {\n\t// first we must register this method to be accepted, then we\n\t// can define method handlers on the router below\n\tRegisterMethod(\"BOO\")\n\n\tr := NewRouter()\n\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\".\"))\n\t})\n\n\t// note the custom BOO method for route /hi\n\tr.MethodFunc(\"BOO\", \"/hi\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"custom method\"))\n\t})\n\n\tts := httptest.NewServer(r)\n\tdefer ts.Close()\n\n\tif _, body := testRequest(t, ts, \"GET\", \"/\", nil); body != \".\" {\n\t\tt.Fatalf(body)\n\t}\n\tif _, body := testRequest(t, ts, \"BOO\", \"/hi\", nil); body != \"custom method\" {\n\t\tt.Fatalf(body)\n\t}\n}\n\nfunc TestMuxMatch(t *testing.T) {\n\tr := NewRouter()\n\tr.Get(\"/hi\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"X-Test\", \"yes\")\n\t\tw.Write([]byte(\"bye\"))\n\t})\n\tr.Route(\"/articles\", func(r Router) {\n\t\tr.Get(\"/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tid := URLParam(r, \"id\")\n\t\t\tw.Header().Set(\"X-Article\", id)\n\t\t\tw.Write([]byte(\"article:\" + id))\n\t\t})\n\t})\n\tr.Route(\"/users\", func(r Router) {\n\t\tr.Head(\"/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Header().Set(\"X-User\", \"-\")\n\t\t\tw.Write([]byte(\"user\"))\n\t\t})\n\t\tr.Get(\"/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tid := URLParam(r, \"id\")\n\t\t\tw.Header().Set(\"X-User\", id)\n\t\t\tw.Write([]byte(\"user:\" + id))\n\t\t})\n\t})\n\n\ttctx := NewRouteContext()\n\n\ttctx.Reset()\n\tif r.Match(tctx, \"GET\", \"/users/1\") == false {\n\t\tt.Fatal(\"expecting to find match for route:\", \"GET\", \"/users/1\")\n\t}\n\n\ttctx.Reset()\n\tif r.Match(tctx, \"HEAD\", \"/articles/10\") == true {\n\t\tt.Fatal(\"not expecting to find match for route:\", \"HEAD\", \"/articles/10\")\n\t}\n}\n\nfunc TestMuxMatch_HasBasePath(t *testing.T) {\n\tr := NewRouter()\n\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"X-Test\", \"yes\")\n\t\tw.Write([]byte(\"\"))\n\t})\n\n\ttctx := NewRouteContext()\n\n\ttctx.Reset()\n\tif r.Match(tctx, \"GET\", \"/\") != true {\n\t\tt.Fatal(\"expecting to find match for route:\", \"GET\", \"/\")\n\t}\n}\n\nfunc TestMuxMatch_DoesNotHaveBasePath(t *testing.T) {\n\tr := NewRouter()\n\n\ttctx := NewRouteContext()\n\n\ttctx.Reset()\n\tif r.Match(tctx, \"GET\", \"/\") != false {\n\t\tt.Fatal(\"not expecting to find match for route:\", \"GET\", \"/\")\n\t}\n}\n\nfunc TestMuxFind(t *testing.T) {\n\tr := NewRouter()\n\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"X-Test\", \"yes\")\n\t\tw.Write([]byte(\"\"))\n\t})\n\tr.Get(\"/hi\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"X-Test\", \"yes\")\n\t\tw.Write([]byte(\"bye\"))\n\t})\n\tr.Route(\"/yo\", func(r Router) {\n\t\tr.Get(\"/sup\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(\"sup\"))\n\t\t})\n\t})\n\tr.Route(\"/articles\", func(r Router) {\n\t\tr.Get(\"/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tid := URLParam(r, \"id\")\n\t\t\tw.Header().Set(\"X-Article\", id)\n\t\t\tw.Write([]byte(\"article:\" + id))\n\t\t})\n\t})\n\tr.Route(\"/users\", func(r Router) {\n\t\tr.Head(\"/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Header().Set(\"X-User\", \"-\")\n\t\t\tw.Write([]byte(\"user\"))\n\t\t})\n\t\tr.Get(\"/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tid := URLParam(r, \"id\")\n\t\t\tw.Header().Set(\"X-User\", id)\n\t\t\tw.Write([]byte(\"user:\" + id))\n\t\t})\n\t})\n\tr.Route(\"/api\", func(r Router) {\n\t\tr.Route(\"/groups\", func(r Router) {\n\t\t\tr.Route(\"/v2\", func(r Router) {\n\t\t\t\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\tw.Write([]byte(\"groups\"))\n\t\t\t\t})\n\t\t\t\tr.Post(\"/{id}\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\tw.Write([]byte(\"POST groups\"))\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t})\n\n\ttctx := NewRouteContext()\n\n\ttctx.Reset()\n\tif r.Find(tctx, \"GET\", \"\") == \"/\" {\n\t\tt.Fatal(\"expecting to find pattern / for route: GET\")\n\t}\n\n\ttctx.Reset()\n\tif r.Find(tctx, \"GET\", \"/nope\") != \"\" {\n\t\tt.Fatal(\"not expecting to find pattern for route: GET /nope\")\n\t}\n\n\ttctx.Reset()\n\tif r.Find(tctx, \"GET\", \"/users/1\") != \"/users/{id}\" {\n\t\tt.Fatal(\"expecting to find pattern /users/{id} for route: GET /users/1\")\n\t}\n\n\ttctx.Reset()\n\tif r.Find(tctx, \"HEAD\", \"/articles/10\") != \"\" {\n\t\tt.Fatal(\"not expecting to find pattern for route: HEAD /articles/10\")\n\t}\n\n\ttctx.Reset()\n\tif r.Find(tctx, \"GET\", \"/yo/sup\") != \"/yo/sup\" {\n\t\tt.Fatal(\"expecting to find pattern /yo/sup for route: GET /yo/sup\")\n\t}\n\n\ttctx.Reset()\n\tif r.Find(tctx, \"GET\", \"/api/groups/v2/\") != \"/api/groups/v2/\" {\n\t\tt.Fatal(\"expecting to find pattern /api/groups/v2/ for route: GET /api/groups/v2/\")\n\t}\n\n\ttctx.Reset()\n\tif r.Find(tctx, \"POST\", \"/api/groups/v2/1\") != \"/api/groups/v2/{id}\" {\n\t\tt.Fatal(\"expecting to find pattern /api/groups/v2/{id} for route: POST /api/groups/v2/1\")\n\t}\n}\n\nfunc TestServerBaseContext(t *testing.T) {\n\tr := NewRouter()\n\tr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tbaseYes := r.Context().Value(ctxKey{\"base\"}).(string)\n\t\tif _, ok := r.Context().Value(http.ServerContextKey).(*http.Server); !ok {\n\t\t\tpanic(\"missing server context\")\n\t\t}\n\t\tif _, ok := r.Context().Value(http.LocalAddrContextKey).(net.Addr); !ok {\n\t\t\tpanic(\"missing local addr context\")\n\t\t}\n\t\tw.Write([]byte(baseYes))\n\t})\n\n\t// Setup http Server with a base context\n\tctx := context.WithValue(context.Background(), ctxKey{\"base\"}, \"yes\")\n\tts := httptest.NewUnstartedServer(r)\n\tts.Config.BaseContext = func(_ net.Listener) context.Context {\n\t\treturn ctx\n\t}\n\tts.Start()\n\n\tdefer ts.Close()\n\n\tif _, body := testRequest(t, ts, \"GET\", \"/\", nil); body != \"yes\" {\n\t\tt.Fatalf(body)\n\t}\n}\n\nfunc testRequest(t *testing.T, ts *httptest.Server, method, path string, body io.Reader) (*http.Response, string) {\n\treq, err := http.NewRequest(method, ts.URL+path, body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t\treturn nil, \"\"\n\t}\n\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t\treturn nil, \"\"\n\t}\n\n\trespBody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t\treturn nil, \"\"\n\t}\n\tdefer resp.Body.Close()\n\n\treturn resp, string(respBody)\n}\n\nfunc testHandler(t *testing.T, h http.Handler, method, path string, body io.Reader) (*http.Response, string) {\n\tr, _ := http.NewRequest(method, path, body)\n\tw := httptest.NewRecorder()\n\th.ServeHTTP(w, r)\n\treturn w.Result(), w.Body.String()\n}\n\ntype ctxKey struct {\n\tname string\n}\n\nfunc (k ctxKey) String() string {\n\treturn \"context value \" + k.name\n}\n\nfunc BenchmarkMux(b *testing.B) {\n\th1 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\th2 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\th3 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\th4 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\th5 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\th6 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\tmx := NewRouter()\n\tmx.Get(\"/\", h1)\n\tmx.Get(\"/hi\", h2)\n\tmx.Post(\"/hi-post\", h2) // used to benchmark 405 responses\n\tmx.Get(\"/sup/{id}/and/{this}\", h3)\n\tmx.Get(\"/sup/{id}/{bar:foo}/{this}\", h3)\n\n\tmx.Route(\"/sharing/{x}/{hash}\", func(mx Router) {\n\t\tmx.Get(\"/\", h4)          // subrouter-1\n\t\tmx.Get(\"/{network}\", h5) // subrouter-1\n\t\tmx.Get(\"/twitter\", h5)\n\t\tmx.Route(\"/direct\", func(mx Router) {\n\t\t\tmx.Get(\"/\", h6) // subrouter-2\n\t\t\tmx.Get(\"/download\", h6)\n\t\t})\n\t})\n\n\troutes := []string{\n\t\t\"/\",\n\t\t\"/hi\",\n\t\t\"/hi-post\",\n\t\t\"/sup/123/and/this\",\n\t\t\"/sup/123/foo/this\",\n\t\t\"/sharing/z/aBc\",                 // subrouter-1\n\t\t\"/sharing/z/aBc/twitter\",         // subrouter-1\n\t\t\"/sharing/z/aBc/direct\",          // subrouter-2\n\t\t\"/sharing/z/aBc/direct/download\", // subrouter-2\n\t}\n\n\tfor _, path := range routes {\n\t\tb.Run(\"route:\"+path, func(b *testing.B) {\n\t\t\tw := httptest.NewRecorder()\n\t\t\tr, _ := http.NewRequest(\"GET\", path, nil)\n\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tmx.ServeHTTP(w, r)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "path_value.go",
          "type": "blob",
          "size": 0.5048828125,
          "content": "//go:build go1.22\n// +build go1.22\n\npackage chi\n\nimport \"net/http\"\n\n// supportsPathValue is true if the Go version is 1.22 and above.\n//\n// If this is true, `net/http.Request` has methods `SetPathValue` and `PathValue`.\nconst supportsPathValue = true\n\n// setPathValue sets the path values in the Request value\n// based on the provided request context.\nfunc setPathValue(rctx *Context, r *http.Request) {\n\tfor i, key := range rctx.URLParams.Keys {\n\t\tvalue := rctx.URLParams.Values[i]\n\t\tr.SetPathValue(key, value)\n\t}\n}\n"
        },
        {
          "name": "path_value_fallback.go",
          "type": "blob",
          "size": 0.51171875,
          "content": "//go:build !go1.22\n// +build !go1.22\n\npackage chi\n\nimport \"net/http\"\n\n// supportsPathValue is true if the Go version is 1.22 and above.\n//\n// If this is true, `net/http.Request` has methods `SetPathValue` and `PathValue`.\nconst supportsPathValue = false\n\n// setPathValue sets the path values in the Request value\n// based on the provided request context.\n//\n// setPathValue is only supported in Go 1.22 and above so\n// this is just a blank function so that it compiles.\nfunc setPathValue(rctx *Context, r *http.Request) {\n}\n"
        },
        {
          "name": "path_value_test.go",
          "type": "blob",
          "size": 1.740234375,
          "content": "//go:build go1.22\n// +build go1.22\n\npackage chi\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestPathValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname         string\n\t\tpattern      string\n\t\tmethod       string\n\t\tpathKeys     []string\n\t\trequestPath  string\n\t\texpectedBody string\n\t}{\n\t\t{\n\t\t\tname:         \"Basic path value\",\n\t\t\tpattern:      \"/hubs/{hubID}\",\n\t\t\tmethod:       \"GET\",\n\t\t\tpathKeys:     []string{\"hubID\"},\n\t\t\trequestPath:  \"/hubs/392\",\n\t\t\texpectedBody: \"392\",\n\t\t},\n\t\t{\n\t\t\tname:         \"Two path values\",\n\t\t\tpattern:      \"/users/{userID}/conversations/{conversationID}\",\n\t\t\tmethod:       \"POST\",\n\t\t\tpathKeys:     []string{\"userID\", \"conversationID\"},\n\t\t\trequestPath:  \"/users/Gojo/conversations/2948\",\n\t\t\texpectedBody: \"Gojo 2948\",\n\t\t},\n\t\t{\n\t\t\tname:         \"Wildcard path\",\n\t\t\tpattern:      \"/users/{userID}/friends/*\",\n\t\t\tmethod:       \"POST\",\n\t\t\tpathKeys:     []string{\"userID\", \"*\"},\n\t\t\trequestPath:  \"/users/Gojo/friends/all-of-them/and/more\",\n\t\t\texpectedBody: \"Gojo all-of-them/and/more\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tr := NewRouter()\n\n\t\t\tr.Handle(tc.method+\" \"+tc.pattern, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tpathValues := []string{}\n\t\t\t\tfor _, pathKey := range tc.pathKeys {\n\t\t\t\t\tpathValue := r.PathValue(pathKey)\n\t\t\t\t\tif pathValue == \"\" {\n\t\t\t\t\t\tpathValue = \"NOT_FOUND:\" + pathKey\n\t\t\t\t\t}\n\n\t\t\t\t\tpathValues = append(pathValues, pathValue)\n\t\t\t\t}\n\n\t\t\t\tbody := strings.Join(pathValues, \" \")\n\n\t\t\t\tw.Write([]byte(body))\n\t\t\t}))\n\n\t\t\tts := httptest.NewServer(r)\n\t\t\tdefer ts.Close()\n\n\t\t\t_, body := testRequest(t, ts, tc.method, tc.requestPath, nil)\n\t\t\tif body != tc.expectedBody {\n\t\t\t\tt.Fatalf(\"expecting %q, got %q\", tc.expectedBody, body)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "tree.go",
          "type": "blob",
          "size": 20.2578125,
          "content": "package chi\n\n// Radix tree implementation below is a based on the original work by\n// Armon Dadgar in https://github.com/armon/go-radix/blob/master/radix.go\n// (MIT licensed). It's been heavily modified for use as a HTTP routing tree.\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype methodTyp uint\n\nconst (\n\tmSTUB methodTyp = 1 << iota\n\tmCONNECT\n\tmDELETE\n\tmGET\n\tmHEAD\n\tmOPTIONS\n\tmPATCH\n\tmPOST\n\tmPUT\n\tmTRACE\n)\n\nvar mALL = mCONNECT | mDELETE | mGET | mHEAD |\n\tmOPTIONS | mPATCH | mPOST | mPUT | mTRACE\n\nvar methodMap = map[string]methodTyp{\n\thttp.MethodConnect: mCONNECT,\n\thttp.MethodDelete:  mDELETE,\n\thttp.MethodGet:     mGET,\n\thttp.MethodHead:    mHEAD,\n\thttp.MethodOptions: mOPTIONS,\n\thttp.MethodPatch:   mPATCH,\n\thttp.MethodPost:    mPOST,\n\thttp.MethodPut:     mPUT,\n\thttp.MethodTrace:   mTRACE,\n}\n\nvar reverseMethodMap = map[methodTyp]string{\n\tmCONNECT: http.MethodConnect,\n\tmDELETE:  http.MethodDelete,\n\tmGET:     http.MethodGet,\n\tmHEAD:    http.MethodHead,\n\tmOPTIONS: http.MethodOptions,\n\tmPATCH:   http.MethodPatch,\n\tmPOST:    http.MethodPost,\n\tmPUT:     http.MethodPut,\n\tmTRACE:   http.MethodTrace,\n}\n\n// RegisterMethod adds support for custom HTTP method handlers, available\n// via Router#Method and Router#MethodFunc\nfunc RegisterMethod(method string) {\n\tif method == \"\" {\n\t\treturn\n\t}\n\tmethod = strings.ToUpper(method)\n\tif _, ok := methodMap[method]; ok {\n\t\treturn\n\t}\n\tn := len(methodMap)\n\tif n > strconv.IntSize-2 {\n\t\tpanic(fmt.Sprintf(\"chi: max number of methods reached (%d)\", strconv.IntSize))\n\t}\n\tmt := methodTyp(2 << n)\n\tmethodMap[method] = mt\n\tmALL |= mt\n}\n\ntype nodeTyp uint8\n\nconst (\n\tntStatic   nodeTyp = iota // /home\n\tntRegexp                  // /{id:[0-9]+}\n\tntParam                   // /{user}\n\tntCatchAll                // /api/v1/*\n)\n\ntype node struct {\n\t// subroutes on the leaf node\n\tsubroutes Routes\n\n\t// regexp matcher for regexp nodes\n\trex *regexp.Regexp\n\n\t// HTTP handler endpoints on the leaf node\n\tendpoints endpoints\n\n\t// prefix is the common prefix we ignore\n\tprefix string\n\n\t// child nodes should be stored in-order for iteration,\n\t// in groups of the node type.\n\tchildren [ntCatchAll + 1]nodes\n\n\t// first byte of the child prefix\n\ttail byte\n\n\t// node type: static, regexp, param, catchAll\n\ttyp nodeTyp\n\n\t// first byte of the prefix\n\tlabel byte\n}\n\n// endpoints is a mapping of http method constants to handlers\n// for a given route.\ntype endpoints map[methodTyp]*endpoint\n\ntype endpoint struct {\n\t// endpoint handler\n\thandler http.Handler\n\n\t// pattern is the routing pattern for handler nodes\n\tpattern string\n\n\t// parameter keys recorded on handler nodes\n\tparamKeys []string\n}\n\nfunc (s endpoints) Value(method methodTyp) *endpoint {\n\tmh, ok := s[method]\n\tif !ok {\n\t\tmh = &endpoint{}\n\t\ts[method] = mh\n\t}\n\treturn mh\n}\n\nfunc (n *node) InsertRoute(method methodTyp, pattern string, handler http.Handler) *node {\n\tvar parent *node\n\tsearch := pattern\n\n\tfor {\n\t\t// Handle key exhaustion\n\t\tif len(search) == 0 {\n\t\t\t// Insert or update the node's leaf handler\n\t\t\tn.setEndpoint(method, handler, pattern)\n\t\t\treturn n\n\t\t}\n\n\t\t// We're going to be searching for a wild node next,\n\t\t// in this case, we need to get the tail\n\t\tvar label = search[0]\n\t\tvar segTail byte\n\t\tvar segEndIdx int\n\t\tvar segTyp nodeTyp\n\t\tvar segRexpat string\n\t\tif label == '{' || label == '*' {\n\t\t\tsegTyp, _, segRexpat, segTail, _, segEndIdx = patNextSegment(search)\n\t\t}\n\n\t\tvar prefix string\n\t\tif segTyp == ntRegexp {\n\t\t\tprefix = segRexpat\n\t\t}\n\n\t\t// Look for the edge to attach to\n\t\tparent = n\n\t\tn = n.getEdge(segTyp, label, segTail, prefix)\n\n\t\t// No edge, create one\n\t\tif n == nil {\n\t\t\tchild := &node{label: label, tail: segTail, prefix: search}\n\t\t\thn := parent.addChild(child, search)\n\t\t\thn.setEndpoint(method, handler, pattern)\n\n\t\t\treturn hn\n\t\t}\n\n\t\t// Found an edge to match the pattern\n\n\t\tif n.typ > ntStatic {\n\t\t\t// We found a param node, trim the param from the search path and continue.\n\t\t\t// This param/wild pattern segment would already be on the tree from a previous\n\t\t\t// call to addChild when creating a new node.\n\t\t\tsearch = search[segEndIdx:]\n\t\t\tcontinue\n\t\t}\n\n\t\t// Static nodes fall below here.\n\t\t// Determine longest prefix of the search key on match.\n\t\tcommonPrefix := longestPrefix(search, n.prefix)\n\t\tif commonPrefix == len(n.prefix) {\n\t\t\t// the common prefix is as long as the current node's prefix we're attempting to insert.\n\t\t\t// keep the search going.\n\t\t\tsearch = search[commonPrefix:]\n\t\t\tcontinue\n\t\t}\n\n\t\t// Split the node\n\t\tchild := &node{\n\t\t\ttyp:    ntStatic,\n\t\t\tprefix: search[:commonPrefix],\n\t\t}\n\t\tparent.replaceChild(search[0], segTail, child)\n\n\t\t// Restore the existing node\n\t\tn.label = n.prefix[commonPrefix]\n\t\tn.prefix = n.prefix[commonPrefix:]\n\t\tchild.addChild(n, n.prefix)\n\n\t\t// If the new key is a subset, set the method/handler on this node and finish.\n\t\tsearch = search[commonPrefix:]\n\t\tif len(search) == 0 {\n\t\t\tchild.setEndpoint(method, handler, pattern)\n\t\t\treturn child\n\t\t}\n\n\t\t// Create a new edge for the node\n\t\tsubchild := &node{\n\t\t\ttyp:    ntStatic,\n\t\t\tlabel:  search[0],\n\t\t\tprefix: search,\n\t\t}\n\t\thn := child.addChild(subchild, search)\n\t\thn.setEndpoint(method, handler, pattern)\n\t\treturn hn\n\t}\n}\n\n// addChild appends the new `child` node to the tree using the `pattern` as the trie key.\n// For a URL router like chi's, we split the static, param, regexp and wildcard segments\n// into different nodes. In addition, addChild will recursively call itself until every\n// pattern segment is added to the url pattern tree as individual nodes, depending on type.\nfunc (n *node) addChild(child *node, prefix string) *node {\n\tsearch := prefix\n\n\t// handler leaf node added to the tree is the child.\n\t// this may be overridden later down the flow\n\thn := child\n\n\t// Parse next segment\n\tsegTyp, _, segRexpat, segTail, segStartIdx, segEndIdx := patNextSegment(search)\n\n\t// Add child depending on next up segment\n\tswitch segTyp {\n\n\tcase ntStatic:\n\t\t// Search prefix is all static (that is, has no params in path)\n\t\t// noop\n\n\tdefault:\n\t\t// Search prefix contains a param, regexp or wildcard\n\n\t\tif segTyp == ntRegexp {\n\t\t\trex, err := regexp.Compile(segRexpat)\n\t\t\tif err != nil {\n\t\t\t\tpanic(fmt.Sprintf(\"chi: invalid regexp pattern '%s' in route param\", segRexpat))\n\t\t\t}\n\t\t\tchild.prefix = segRexpat\n\t\t\tchild.rex = rex\n\t\t}\n\n\t\tif segStartIdx == 0 {\n\t\t\t// Route starts with a param\n\t\t\tchild.typ = segTyp\n\n\t\t\tif segTyp == ntCatchAll {\n\t\t\t\tsegStartIdx = -1\n\t\t\t} else {\n\t\t\t\tsegStartIdx = segEndIdx\n\t\t\t}\n\t\t\tif segStartIdx < 0 {\n\t\t\t\tsegStartIdx = len(search)\n\t\t\t}\n\t\t\tchild.tail = segTail // for params, we set the tail\n\n\t\t\tif segStartIdx != len(search) {\n\t\t\t\t// add static edge for the remaining part, split the end.\n\t\t\t\t// its not possible to have adjacent param nodes, so its certainly\n\t\t\t\t// going to be a static node next.\n\n\t\t\t\tsearch = search[segStartIdx:] // advance search position\n\n\t\t\t\tnn := &node{\n\t\t\t\t\ttyp:    ntStatic,\n\t\t\t\t\tlabel:  search[0],\n\t\t\t\t\tprefix: search,\n\t\t\t\t}\n\t\t\t\thn = child.addChild(nn, search)\n\t\t\t}\n\n\t\t} else if segStartIdx > 0 {\n\t\t\t// Route has some param\n\n\t\t\t// starts with a static segment\n\t\t\tchild.typ = ntStatic\n\t\t\tchild.prefix = search[:segStartIdx]\n\t\t\tchild.rex = nil\n\n\t\t\t// add the param edge node\n\t\t\tsearch = search[segStartIdx:]\n\n\t\t\tnn := &node{\n\t\t\t\ttyp:   segTyp,\n\t\t\t\tlabel: search[0],\n\t\t\t\ttail:  segTail,\n\t\t\t}\n\t\t\thn = child.addChild(nn, search)\n\n\t\t}\n\t}\n\n\tn.children[child.typ] = append(n.children[child.typ], child)\n\tn.children[child.typ].Sort()\n\treturn hn\n}\n\nfunc (n *node) replaceChild(label, tail byte, child *node) {\n\tfor i := 0; i < len(n.children[child.typ]); i++ {\n\t\tif n.children[child.typ][i].label == label && n.children[child.typ][i].tail == tail {\n\t\t\tn.children[child.typ][i] = child\n\t\t\tn.children[child.typ][i].label = label\n\t\t\tn.children[child.typ][i].tail = tail\n\t\t\treturn\n\t\t}\n\t}\n\tpanic(\"chi: replacing missing child\")\n}\n\nfunc (n *node) getEdge(ntyp nodeTyp, label, tail byte, prefix string) *node {\n\tnds := n.children[ntyp]\n\tfor i := 0; i < len(nds); i++ {\n\t\tif nds[i].label == label && nds[i].tail == tail {\n\t\t\tif ntyp == ntRegexp && nds[i].prefix != prefix {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nds[i]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (n *node) setEndpoint(method methodTyp, handler http.Handler, pattern string) {\n\t// Set the handler for the method type on the node\n\tif n.endpoints == nil {\n\t\tn.endpoints = make(endpoints)\n\t}\n\n\tparamKeys := patParamKeys(pattern)\n\n\tif method&mSTUB == mSTUB {\n\t\tn.endpoints.Value(mSTUB).handler = handler\n\t}\n\tif method&mALL == mALL {\n\t\th := n.endpoints.Value(mALL)\n\t\th.handler = handler\n\t\th.pattern = pattern\n\t\th.paramKeys = paramKeys\n\t\tfor _, m := range methodMap {\n\t\t\th := n.endpoints.Value(m)\n\t\t\th.handler = handler\n\t\t\th.pattern = pattern\n\t\t\th.paramKeys = paramKeys\n\t\t}\n\t} else {\n\t\th := n.endpoints.Value(method)\n\t\th.handler = handler\n\t\th.pattern = pattern\n\t\th.paramKeys = paramKeys\n\t}\n}\n\nfunc (n *node) FindRoute(rctx *Context, method methodTyp, path string) (*node, endpoints, http.Handler) {\n\t// Reset the context routing pattern and params\n\trctx.routePattern = \"\"\n\trctx.routeParams.Keys = rctx.routeParams.Keys[:0]\n\trctx.routeParams.Values = rctx.routeParams.Values[:0]\n\n\t// Find the routing handlers for the path\n\trn := n.findRoute(rctx, method, path)\n\tif rn == nil {\n\t\treturn nil, nil, nil\n\t}\n\n\t// Record the routing params in the request lifecycle\n\trctx.URLParams.Keys = append(rctx.URLParams.Keys, rctx.routeParams.Keys...)\n\trctx.URLParams.Values = append(rctx.URLParams.Values, rctx.routeParams.Values...)\n\n\t// Record the routing pattern in the request lifecycle\n\tif rn.endpoints[method].pattern != \"\" {\n\t\trctx.routePattern = rn.endpoints[method].pattern\n\t\trctx.RoutePatterns = append(rctx.RoutePatterns, rctx.routePattern)\n\t}\n\n\treturn rn, rn.endpoints, rn.endpoints[method].handler\n}\n\n// Recursive edge traversal by checking all nodeTyp groups along the way.\n// It's like searching through a multi-dimensional radix trie.\nfunc (n *node) findRoute(rctx *Context, method methodTyp, path string) *node {\n\tnn := n\n\tsearch := path\n\n\tfor t, nds := range nn.children {\n\t\tntyp := nodeTyp(t)\n\t\tif len(nds) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar xn *node\n\t\txsearch := search\n\n\t\tvar label byte\n\t\tif search != \"\" {\n\t\t\tlabel = search[0]\n\t\t}\n\n\t\tswitch ntyp {\n\t\tcase ntStatic:\n\t\t\txn = nds.findEdge(label)\n\t\t\tif xn == nil || !strings.HasPrefix(xsearch, xn.prefix) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\txsearch = xsearch[len(xn.prefix):]\n\n\t\tcase ntParam, ntRegexp:\n\t\t\t// short-circuit and return no matching route for empty param values\n\t\t\tif xsearch == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// serially loop through each node grouped by the tail delimiter\n\t\t\tfor idx := 0; idx < len(nds); idx++ {\n\t\t\t\txn = nds[idx]\n\n\t\t\t\t// label for param nodes is the delimiter byte\n\t\t\t\tp := strings.IndexByte(xsearch, xn.tail)\n\n\t\t\t\tif p < 0 {\n\t\t\t\t\tif xn.tail == '/' {\n\t\t\t\t\t\tp = len(xsearch)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t} else if ntyp == ntRegexp && p == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif ntyp == ntRegexp && xn.rex != nil {\n\t\t\t\t\tif !xn.rex.MatchString(xsearch[:p]) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t} else if strings.IndexByte(xsearch[:p], '/') != -1 {\n\t\t\t\t\t// avoid a match across path segments\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tprevlen := len(rctx.routeParams.Values)\n\t\t\t\trctx.routeParams.Values = append(rctx.routeParams.Values, xsearch[:p])\n\t\t\t\txsearch = xsearch[p:]\n\n\t\t\t\tif len(xsearch) == 0 {\n\t\t\t\t\tif xn.isLeaf() {\n\t\t\t\t\t\th := xn.endpoints[method]\n\t\t\t\t\t\tif h != nil && h.handler != nil {\n\t\t\t\t\t\t\trctx.routeParams.Keys = append(rctx.routeParams.Keys, h.paramKeys...)\n\t\t\t\t\t\t\treturn xn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor endpoints := range xn.endpoints {\n\t\t\t\t\t\t\tif endpoints == mALL || endpoints == mSTUB {\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trctx.methodsAllowed = append(rctx.methodsAllowed, endpoints)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// flag that the routing context found a route, but not a corresponding\n\t\t\t\t\t\t// supported method\n\t\t\t\t\t\trctx.methodNotAllowed = true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// recursively find the next node on this branch\n\t\t\t\tfin := xn.findRoute(rctx, method, xsearch)\n\t\t\t\tif fin != nil {\n\t\t\t\t\treturn fin\n\t\t\t\t}\n\n\t\t\t\t// not found on this branch, reset vars\n\t\t\t\trctx.routeParams.Values = rctx.routeParams.Values[:prevlen]\n\t\t\t\txsearch = search\n\t\t\t}\n\n\t\t\trctx.routeParams.Values = append(rctx.routeParams.Values, \"\")\n\n\t\tdefault:\n\t\t\t// catch-all nodes\n\t\t\trctx.routeParams.Values = append(rctx.routeParams.Values, search)\n\t\t\txn = nds[0]\n\t\t\txsearch = \"\"\n\t\t}\n\n\t\tif xn == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// did we find it yet?\n\t\tif len(xsearch) == 0 {\n\t\t\tif xn.isLeaf() {\n\t\t\t\th := xn.endpoints[method]\n\t\t\t\tif h != nil && h.handler != nil {\n\t\t\t\t\trctx.routeParams.Keys = append(rctx.routeParams.Keys, h.paramKeys...)\n\t\t\t\t\treturn xn\n\t\t\t\t}\n\n\t\t\t\tfor endpoints := range xn.endpoints {\n\t\t\t\t\tif endpoints == mALL || endpoints == mSTUB {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\trctx.methodsAllowed = append(rctx.methodsAllowed, endpoints)\n\t\t\t\t}\n\n\t\t\t\t// flag that the routing context found a route, but not a corresponding\n\t\t\t\t// supported method\n\t\t\t\trctx.methodNotAllowed = true\n\t\t\t}\n\t\t}\n\n\t\t// recursively find the next node..\n\t\tfin := xn.findRoute(rctx, method, xsearch)\n\t\tif fin != nil {\n\t\t\treturn fin\n\t\t}\n\n\t\t// Did not find final handler, let's remove the param here if it was set\n\t\tif xn.typ > ntStatic {\n\t\t\tif len(rctx.routeParams.Values) > 0 {\n\t\t\t\trctx.routeParams.Values = rctx.routeParams.Values[:len(rctx.routeParams.Values)-1]\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn nil\n}\n\nfunc (n *node) findEdge(ntyp nodeTyp, label byte) *node {\n\tnds := n.children[ntyp]\n\tnum := len(nds)\n\tidx := 0\n\n\tswitch ntyp {\n\tcase ntStatic, ntParam, ntRegexp:\n\t\ti, j := 0, num-1\n\t\tfor i <= j {\n\t\t\tidx = i + (j-i)/2\n\t\t\tif label > nds[idx].label {\n\t\t\t\ti = idx + 1\n\t\t\t} else if label < nds[idx].label {\n\t\t\t\tj = idx - 1\n\t\t\t} else {\n\t\t\t\ti = num // breaks cond\n\t\t\t}\n\t\t}\n\t\tif nds[idx].label != label {\n\t\t\treturn nil\n\t\t}\n\t\treturn nds[idx]\n\n\tdefault: // catch all\n\t\treturn nds[idx]\n\t}\n}\n\nfunc (n *node) isLeaf() bool {\n\treturn n.endpoints != nil\n}\n\nfunc (n *node) findPattern(pattern string) bool {\n\tnn := n\n\tfor _, nds := range nn.children {\n\t\tif len(nds) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tn = nn.findEdge(nds[0].typ, pattern[0])\n\t\tif n == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar idx int\n\t\tvar xpattern string\n\n\t\tswitch n.typ {\n\t\tcase ntStatic:\n\t\t\tidx = longestPrefix(pattern, n.prefix)\n\t\t\tif idx < len(n.prefix) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\tcase ntParam, ntRegexp:\n\t\t\tidx = strings.IndexByte(pattern, '}') + 1\n\n\t\tcase ntCatchAll:\n\t\t\tidx = longestPrefix(pattern, \"*\")\n\n\t\tdefault:\n\t\t\tpanic(\"chi: unknown node type\")\n\t\t}\n\n\t\txpattern = pattern[idx:]\n\t\tif len(xpattern) == 0 {\n\t\t\treturn true\n\t\t}\n\n\t\treturn n.findPattern(xpattern)\n\t}\n\treturn false\n}\n\nfunc (n *node) routes() []Route {\n\trts := []Route{}\n\n\tn.walk(func(eps endpoints, subroutes Routes) bool {\n\t\tif eps[mSTUB] != nil && eps[mSTUB].handler != nil && subroutes == nil {\n\t\t\treturn false\n\t\t}\n\n\t\t// Group methodHandlers by unique patterns\n\t\tpats := make(map[string]endpoints)\n\n\t\tfor mt, h := range eps {\n\t\t\tif h.pattern == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tp, ok := pats[h.pattern]\n\t\t\tif !ok {\n\t\t\t\tp = endpoints{}\n\t\t\t\tpats[h.pattern] = p\n\t\t\t}\n\t\t\tp[mt] = h\n\t\t}\n\n\t\tfor p, mh := range pats {\n\t\t\ths := make(map[string]http.Handler)\n\t\t\tif mh[mALL] != nil && mh[mALL].handler != nil {\n\t\t\t\ths[\"*\"] = mh[mALL].handler\n\t\t\t}\n\n\t\t\tfor mt, h := range mh {\n\t\t\t\tif h.handler == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tm := methodTypString(mt)\n\t\t\t\tif m == \"\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\ths[m] = h.handler\n\t\t\t}\n\n\t\t\trt := Route{subroutes, hs, p}\n\t\t\trts = append(rts, rt)\n\t\t}\n\n\t\treturn false\n\t})\n\n\treturn rts\n}\n\nfunc (n *node) walk(fn func(eps endpoints, subroutes Routes) bool) bool {\n\t// Visit the leaf values if any\n\tif (n.endpoints != nil || n.subroutes != nil) && fn(n.endpoints, n.subroutes) {\n\t\treturn true\n\t}\n\n\t// Recurse on the children\n\tfor _, ns := range n.children {\n\t\tfor _, cn := range ns {\n\t\t\tif cn.walk(fn) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n// patNextSegment returns the next segment details from a pattern:\n// node type, param key, regexp string, param tail byte, param starting index, param ending index\nfunc patNextSegment(pattern string) (nodeTyp, string, string, byte, int, int) {\n\tps := strings.Index(pattern, \"{\")\n\tws := strings.Index(pattern, \"*\")\n\n\tif ps < 0 && ws < 0 {\n\t\treturn ntStatic, \"\", \"\", 0, 0, len(pattern) // we return the entire thing\n\t}\n\n\t// Sanity check\n\tif ps >= 0 && ws >= 0 && ws < ps {\n\t\tpanic(\"chi: wildcard '*' must be the last pattern in a route, otherwise use a '{param}'\")\n\t}\n\n\tvar tail byte = '/' // Default endpoint tail to / byte\n\n\tif ps >= 0 {\n\t\t// Param/Regexp pattern is next\n\t\tnt := ntParam\n\n\t\t// Read to closing } taking into account opens and closes in curl count (cc)\n\t\tcc := 0\n\t\tpe := ps\n\t\tfor i, c := range pattern[ps:] {\n\t\t\tif c == '{' {\n\t\t\t\tcc++\n\t\t\t} else if c == '}' {\n\t\t\t\tcc--\n\t\t\t\tif cc == 0 {\n\t\t\t\t\tpe = ps + i\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif pe == ps {\n\t\t\tpanic(\"chi: route param closing delimiter '}' is missing\")\n\t\t}\n\n\t\tkey := pattern[ps+1 : pe]\n\t\tpe++ // set end to next position\n\n\t\tif pe < len(pattern) {\n\t\t\ttail = pattern[pe]\n\t\t}\n\n\t\tvar rexpat string\n\t\tif idx := strings.Index(key, \":\"); idx >= 0 {\n\t\t\tnt = ntRegexp\n\t\t\trexpat = key[idx+1:]\n\t\t\tkey = key[:idx]\n\t\t}\n\n\t\tif len(rexpat) > 0 {\n\t\t\tif rexpat[0] != '^' {\n\t\t\t\trexpat = \"^\" + rexpat\n\t\t\t}\n\t\t\tif rexpat[len(rexpat)-1] != '$' {\n\t\t\t\trexpat += \"$\"\n\t\t\t}\n\t\t}\n\n\t\treturn nt, key, rexpat, tail, ps, pe\n\t}\n\n\t// Wildcard pattern as finale\n\tif ws < len(pattern)-1 {\n\t\tpanic(\"chi: wildcard '*' must be the last value in a route. trim trailing text or use a '{param}' instead\")\n\t}\n\treturn ntCatchAll, \"*\", \"\", 0, ws, len(pattern)\n}\n\nfunc patParamKeys(pattern string) []string {\n\tpat := pattern\n\tparamKeys := []string{}\n\tfor {\n\t\tptyp, paramKey, _, _, _, e := patNextSegment(pat)\n\t\tif ptyp == ntStatic {\n\t\t\treturn paramKeys\n\t\t}\n\t\tfor i := 0; i < len(paramKeys); i++ {\n\t\t\tif paramKeys[i] == paramKey {\n\t\t\t\tpanic(fmt.Sprintf(\"chi: routing pattern '%s' contains duplicate param key, '%s'\", pattern, paramKey))\n\t\t\t}\n\t\t}\n\t\tparamKeys = append(paramKeys, paramKey)\n\t\tpat = pat[e:]\n\t}\n}\n\n// longestPrefix finds the length of the shared prefix\n// of two strings\nfunc longestPrefix(k1, k2 string) int {\n\tmax := len(k1)\n\tif l := len(k2); l < max {\n\t\tmax = l\n\t}\n\tvar i int\n\tfor i = 0; i < max; i++ {\n\t\tif k1[i] != k2[i] {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn i\n}\n\nfunc methodTypString(method methodTyp) string {\n\tfor s, t := range methodMap {\n\t\tif method == t {\n\t\t\treturn s\n\t\t}\n\t}\n\treturn \"\"\n}\n\ntype nodes []*node\n\n// Sort the list of nodes by label\nfunc (ns nodes) Sort()              { sort.Sort(ns); ns.tailSort() }\nfunc (ns nodes) Len() int           { return len(ns) }\nfunc (ns nodes) Swap(i, j int)      { ns[i], ns[j] = ns[j], ns[i] }\nfunc (ns nodes) Less(i, j int) bool { return ns[i].label < ns[j].label }\n\n// tailSort pushes nodes with '/' as the tail to the end of the list for param nodes.\n// The list order determines the traversal order.\nfunc (ns nodes) tailSort() {\n\tfor i := len(ns) - 1; i >= 0; i-- {\n\t\tif ns[i].typ > ntStatic && ns[i].tail == '/' {\n\t\t\tns.Swap(i, len(ns)-1)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (ns nodes) findEdge(label byte) *node {\n\tnum := len(ns)\n\tidx := 0\n\ti, j := 0, num-1\n\tfor i <= j {\n\t\tidx = i + (j-i)/2\n\t\tif label > ns[idx].label {\n\t\t\ti = idx + 1\n\t\t} else if label < ns[idx].label {\n\t\t\tj = idx - 1\n\t\t} else {\n\t\t\ti = num // breaks cond\n\t\t}\n\t}\n\tif ns[idx].label != label {\n\t\treturn nil\n\t}\n\treturn ns[idx]\n}\n\n// Route describes the details of a routing handler.\n// Handlers map key is an HTTP method\ntype Route struct {\n\tSubRoutes Routes\n\tHandlers  map[string]http.Handler\n\tPattern   string\n}\n\n// WalkFunc is the type of the function called for each method and route visited by Walk.\ntype WalkFunc func(method string, route string, handler http.Handler, middlewares ...func(http.Handler) http.Handler) error\n\n// Walk walks any router tree that implements Routes interface.\nfunc Walk(r Routes, walkFn WalkFunc) error {\n\treturn walk(r, walkFn, \"\")\n}\n\nfunc walk(r Routes, walkFn WalkFunc, parentRoute string, parentMw ...func(http.Handler) http.Handler) error {\n\tfor _, route := range r.Routes() {\n\t\tmws := make([]func(http.Handler) http.Handler, len(parentMw))\n\t\tcopy(mws, parentMw)\n\t\tmws = append(mws, r.Middlewares()...)\n\n\t\tif route.SubRoutes != nil {\n\t\t\tif err := walk(route.SubRoutes, walkFn, parentRoute+route.Pattern, mws...); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tfor method, handler := range route.Handlers {\n\t\t\tif method == \"*\" {\n\t\t\t\t// Ignore a \"catchAll\" method, since we pass down all the specific methods for each route.\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfullRoute := parentRoute + route.Pattern\n\t\t\tfullRoute = strings.Replace(fullRoute, \"/*/\", \"/\", -1)\n\n\t\t\tif chain, ok := handler.(*ChainHandler); ok {\n\t\t\t\tif err := walkFn(method, fullRoute, chain.Endpoint, append(mws, chain.Middlewares...)...); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err := walkFn(method, fullRoute, handler, mws...); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "tree_test.go",
          "type": "blob",
          "size": 22.1416015625,
          "content": "package chi\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"testing\"\n)\n\nfunc TestTree(t *testing.T) {\n\thStub := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thIndex := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thFavicon := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thArticleList := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thArticleNear := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thArticleShow := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thArticleShowRelated := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thArticleShowOpts := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thArticleSlug := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thArticleByUser := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thUserList := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thUserShow := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thAdminCatchall := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thAdminAppShow := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thAdminAppShowCatchall := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thUserProfile := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thUserSuper := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thUserAll := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thHubView1 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thHubView2 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thHubView3 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\ttr := &node{}\n\n\ttr.InsertRoute(mGET, \"/\", hIndex)\n\ttr.InsertRoute(mGET, \"/favicon.ico\", hFavicon)\n\n\ttr.InsertRoute(mGET, \"/pages/*\", hStub)\n\n\ttr.InsertRoute(mGET, \"/article\", hArticleList)\n\ttr.InsertRoute(mGET, \"/article/\", hArticleList)\n\n\ttr.InsertRoute(mGET, \"/article/near\", hArticleNear)\n\ttr.InsertRoute(mGET, \"/article/{id}\", hStub)\n\ttr.InsertRoute(mGET, \"/article/{id}\", hArticleShow)\n\ttr.InsertRoute(mGET, \"/article/{id}\", hArticleShow) // duplicate will have no effect\n\ttr.InsertRoute(mGET, \"/article/@{user}\", hArticleByUser)\n\n\ttr.InsertRoute(mGET, \"/article/{sup}/{opts}\", hArticleShowOpts)\n\ttr.InsertRoute(mGET, \"/article/{id}/{opts}\", hArticleShowOpts) // overwrite above route, latest wins\n\n\ttr.InsertRoute(mGET, \"/article/{iffd}/edit\", hStub)\n\ttr.InsertRoute(mGET, \"/article/{id}//related\", hArticleShowRelated)\n\ttr.InsertRoute(mGET, \"/article/slug/{month}/-/{day}/{year}\", hArticleSlug)\n\n\ttr.InsertRoute(mGET, \"/admin/user\", hUserList)\n\ttr.InsertRoute(mGET, \"/admin/user/\", hStub) // will get replaced by next route\n\ttr.InsertRoute(mGET, \"/admin/user/\", hUserList)\n\n\ttr.InsertRoute(mGET, \"/admin/user//{id}\", hUserShow)\n\ttr.InsertRoute(mGET, \"/admin/user/{id}\", hUserShow)\n\n\ttr.InsertRoute(mGET, \"/admin/apps/{id}\", hAdminAppShow)\n\ttr.InsertRoute(mGET, \"/admin/apps/{id}/*\", hAdminAppShowCatchall)\n\n\ttr.InsertRoute(mGET, \"/admin/*\", hStub) // catchall segment will get replaced by next route\n\ttr.InsertRoute(mGET, \"/admin/*\", hAdminCatchall)\n\n\ttr.InsertRoute(mGET, \"/users/{userID}/profile\", hUserProfile)\n\ttr.InsertRoute(mGET, \"/users/super/*\", hUserSuper)\n\ttr.InsertRoute(mGET, \"/users/*\", hUserAll)\n\n\ttr.InsertRoute(mGET, \"/hubs/{hubID}/view\", hHubView1)\n\ttr.InsertRoute(mGET, \"/hubs/{hubID}/view/*\", hHubView2)\n\tsr := NewRouter()\n\tsr.Get(\"/users\", hHubView3)\n\ttr.InsertRoute(mGET, \"/hubs/{hubID}/*\", sr)\n\ttr.InsertRoute(mGET, \"/hubs/{hubID}/users\", hHubView3)\n\n\ttests := []struct {\n\t\tr string       // input request path\n\t\th http.Handler // output matched handler\n\t\tk []string     // output param keys\n\t\tv []string     // output param values\n\t}{\n\t\t{r: \"/\", h: hIndex, k: []string{}, v: []string{}},\n\t\t{r: \"/favicon.ico\", h: hFavicon, k: []string{}, v: []string{}},\n\n\t\t{r: \"/pages\", h: nil, k: []string{}, v: []string{}},\n\t\t{r: \"/pages/\", h: hStub, k: []string{\"*\"}, v: []string{\"\"}},\n\t\t{r: \"/pages/yes\", h: hStub, k: []string{\"*\"}, v: []string{\"yes\"}},\n\n\t\t{r: \"/article\", h: hArticleList, k: []string{}, v: []string{}},\n\t\t{r: \"/article/\", h: hArticleList, k: []string{}, v: []string{}},\n\t\t{r: \"/article/near\", h: hArticleNear, k: []string{}, v: []string{}},\n\t\t{r: \"/article/neard\", h: hArticleShow, k: []string{\"id\"}, v: []string{\"neard\"}},\n\t\t{r: \"/article/123\", h: hArticleShow, k: []string{\"id\"}, v: []string{\"123\"}},\n\t\t{r: \"/article/123/456\", h: hArticleShowOpts, k: []string{\"id\", \"opts\"}, v: []string{\"123\", \"456\"}},\n\t\t{r: \"/article/@peter\", h: hArticleByUser, k: []string{\"user\"}, v: []string{\"peter\"}},\n\t\t{r: \"/article/22//related\", h: hArticleShowRelated, k: []string{\"id\"}, v: []string{\"22\"}},\n\t\t{r: \"/article/111/edit\", h: hStub, k: []string{\"iffd\"}, v: []string{\"111\"}},\n\t\t{r: \"/article/slug/sept/-/4/2015\", h: hArticleSlug, k: []string{\"month\", \"day\", \"year\"}, v: []string{\"sept\", \"4\", \"2015\"}},\n\t\t{r: \"/article/:id\", h: hArticleShow, k: []string{\"id\"}, v: []string{\":id\"}},\n\n\t\t{r: \"/admin/user\", h: hUserList, k: []string{}, v: []string{}},\n\t\t{r: \"/admin/user/\", h: hUserList, k: []string{}, v: []string{}},\n\t\t{r: \"/admin/user/1\", h: hUserShow, k: []string{\"id\"}, v: []string{\"1\"}},\n\t\t{r: \"/admin/user//1\", h: hUserShow, k: []string{\"id\"}, v: []string{\"1\"}},\n\t\t{r: \"/admin/hi\", h: hAdminCatchall, k: []string{\"*\"}, v: []string{\"hi\"}},\n\t\t{r: \"/admin/lots/of/:fun\", h: hAdminCatchall, k: []string{\"*\"}, v: []string{\"lots/of/:fun\"}},\n\t\t{r: \"/admin/apps/333\", h: hAdminAppShow, k: []string{\"id\"}, v: []string{\"333\"}},\n\t\t{r: \"/admin/apps/333/woot\", h: hAdminAppShowCatchall, k: []string{\"id\", \"*\"}, v: []string{\"333\", \"woot\"}},\n\n\t\t{r: \"/hubs/123/view\", h: hHubView1, k: []string{\"hubID\"}, v: []string{\"123\"}},\n\t\t{r: \"/hubs/123/view/index.html\", h: hHubView2, k: []string{\"hubID\", \"*\"}, v: []string{\"123\", \"index.html\"}},\n\t\t{r: \"/hubs/123/users\", h: hHubView3, k: []string{\"hubID\"}, v: []string{\"123\"}},\n\n\t\t{r: \"/users/123/profile\", h: hUserProfile, k: []string{\"userID\"}, v: []string{\"123\"}},\n\t\t{r: \"/users/super/123/okay/yes\", h: hUserSuper, k: []string{\"*\"}, v: []string{\"123/okay/yes\"}},\n\t\t{r: \"/users/123/okay/yes\", h: hUserAll, k: []string{\"*\"}, v: []string{\"123/okay/yes\"}},\n\t}\n\n\t// log.Println(\"~~~~~~~~~\")\n\t// log.Println(\"~~~~~~~~~\")\n\t// debugPrintTree(0, 0, tr, 0)\n\t// log.Println(\"~~~~~~~~~\")\n\t// log.Println(\"~~~~~~~~~\")\n\n\tfor i, tt := range tests {\n\t\trctx := NewRouteContext()\n\n\t\t_, handlers, _ := tr.FindRoute(rctx, mGET, tt.r)\n\n\t\tvar handler http.Handler\n\t\tif methodHandler, ok := handlers[mGET]; ok {\n\t\t\thandler = methodHandler.handler\n\t\t}\n\n\t\tparamKeys := rctx.routeParams.Keys\n\t\tparamValues := rctx.routeParams.Values\n\n\t\tif fmt.Sprintf(\"%v\", tt.h) != fmt.Sprintf(\"%v\", handler) {\n\t\t\tt.Errorf(\"input [%d]: find '%s' expecting handler:%v , got:%v\", i, tt.r, tt.h, handler)\n\t\t}\n\t\tif !stringSliceEqual(tt.k, paramKeys) {\n\t\t\tt.Errorf(\"input [%d]: find '%s' expecting paramKeys:(%d)%v , got:(%d)%v\", i, tt.r, len(tt.k), tt.k, len(paramKeys), paramKeys)\n\t\t}\n\t\tif !stringSliceEqual(tt.v, paramValues) {\n\t\t\tt.Errorf(\"input [%d]: find '%s' expecting paramValues:(%d)%v , got:(%d)%v\", i, tt.r, len(tt.v), tt.v, len(paramValues), paramValues)\n\t\t}\n\t}\n}\n\nfunc TestTreeMoar(t *testing.T) {\n\thStub := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub1 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub2 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub3 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub4 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub5 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub6 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub7 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub8 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub9 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub10 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub11 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub12 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub13 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub14 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub15 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub16 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\t// TODO: panic if we see {id}{x} because we're missing a delimiter, its not possible.\n\t// also {:id}* is not possible.\n\n\ttr := &node{}\n\n\ttr.InsertRoute(mGET, \"/articlefun\", hStub5)\n\ttr.InsertRoute(mGET, \"/articles/{id}\", hStub)\n\ttr.InsertRoute(mDELETE, \"/articles/{slug}\", hStub8)\n\ttr.InsertRoute(mGET, \"/articles/search\", hStub1)\n\ttr.InsertRoute(mGET, \"/articles/{id}:delete\", hStub8)\n\ttr.InsertRoute(mGET, \"/articles/{iidd}!sup\", hStub4)\n\ttr.InsertRoute(mGET, \"/articles/{id}:{op}\", hStub3)\n\ttr.InsertRoute(mGET, \"/articles/{id}:{op}\", hStub2)                              // this route sets a new handler for the above route\n\ttr.InsertRoute(mGET, \"/articles/{slug:^[a-z]+}/posts\", hStub)                    // up to tail '/' will only match if contents match the rex\n\ttr.InsertRoute(mGET, \"/articles/{id}/posts/{pid}\", hStub6)                       // /articles/123/posts/1\n\ttr.InsertRoute(mGET, \"/articles/{id}/posts/{month}/{day}/{year}/{slug}\", hStub7) // /articles/123/posts/09/04/1984/juice\n\ttr.InsertRoute(mGET, \"/articles/{id}.json\", hStub10)\n\ttr.InsertRoute(mGET, \"/articles/{id}/data.json\", hStub11)\n\ttr.InsertRoute(mGET, \"/articles/files/{file}.{ext}\", hStub12)\n\ttr.InsertRoute(mPUT, \"/articles/me\", hStub13)\n\n\t// TODO: make a separate test case for this one..\n\t// tr.InsertRoute(mGET, \"/articles/{id}/{id}\", hStub1)                              // panic expected, we're duplicating param keys\n\n\ttr.InsertRoute(mGET, \"/pages/*\", hStub)\n\ttr.InsertRoute(mGET, \"/pages/*\", hStub9)\n\n\ttr.InsertRoute(mGET, \"/users/{id}\", hStub14)\n\ttr.InsertRoute(mGET, \"/users/{id}/settings/{key}\", hStub15)\n\ttr.InsertRoute(mGET, \"/users/{id}/settings/*\", hStub16)\n\n\ttests := []struct {\n\t\th http.Handler\n\t\tr string\n\t\tk []string\n\t\tv []string\n\t\tm methodTyp\n\t}{\n\t\t{m: mGET, r: \"/articles/search\", h: hStub1, k: []string{}, v: []string{}},\n\t\t{m: mGET, r: \"/articlefun\", h: hStub5, k: []string{}, v: []string{}},\n\t\t{m: mGET, r: \"/articles/123\", h: hStub, k: []string{\"id\"}, v: []string{\"123\"}},\n\t\t{m: mDELETE, r: \"/articles/123mm\", h: hStub8, k: []string{\"slug\"}, v: []string{\"123mm\"}},\n\t\t{m: mGET, r: \"/articles/789:delete\", h: hStub8, k: []string{\"id\"}, v: []string{\"789\"}},\n\t\t{m: mGET, r: \"/articles/789!sup\", h: hStub4, k: []string{\"iidd\"}, v: []string{\"789\"}},\n\t\t{m: mGET, r: \"/articles/123:sync\", h: hStub2, k: []string{\"id\", \"op\"}, v: []string{\"123\", \"sync\"}},\n\t\t{m: mGET, r: \"/articles/456/posts/1\", h: hStub6, k: []string{\"id\", \"pid\"}, v: []string{\"456\", \"1\"}},\n\t\t{m: mGET, r: \"/articles/456/posts/09/04/1984/juice\", h: hStub7, k: []string{\"id\", \"month\", \"day\", \"year\", \"slug\"}, v: []string{\"456\", \"09\", \"04\", \"1984\", \"juice\"}},\n\t\t{m: mGET, r: \"/articles/456.json\", h: hStub10, k: []string{\"id\"}, v: []string{\"456\"}},\n\t\t{m: mGET, r: \"/articles/456/data.json\", h: hStub11, k: []string{\"id\"}, v: []string{\"456\"}},\n\n\t\t{m: mGET, r: \"/articles/files/file.zip\", h: hStub12, k: []string{\"file\", \"ext\"}, v: []string{\"file\", \"zip\"}},\n\t\t{m: mGET, r: \"/articles/files/photos.tar.gz\", h: hStub12, k: []string{\"file\", \"ext\"}, v: []string{\"photos\", \"tar.gz\"}},\n\t\t{m: mGET, r: \"/articles/files/photos.tar.gz\", h: hStub12, k: []string{\"file\", \"ext\"}, v: []string{\"photos\", \"tar.gz\"}},\n\n\t\t{m: mPUT, r: \"/articles/me\", h: hStub13, k: []string{}, v: []string{}},\n\t\t{m: mGET, r: \"/articles/me\", h: hStub, k: []string{\"id\"}, v: []string{\"me\"}},\n\t\t{m: mGET, r: \"/pages\", h: nil, k: []string{}, v: []string{}},\n\t\t{m: mGET, r: \"/pages/\", h: hStub9, k: []string{\"*\"}, v: []string{\"\"}},\n\t\t{m: mGET, r: \"/pages/yes\", h: hStub9, k: []string{\"*\"}, v: []string{\"yes\"}},\n\n\t\t{m: mGET, r: \"/users/1\", h: hStub14, k: []string{\"id\"}, v: []string{\"1\"}},\n\t\t{m: mGET, r: \"/users/\", h: nil, k: []string{}, v: []string{}},\n\t\t{m: mGET, r: \"/users/2/settings/password\", h: hStub15, k: []string{\"id\", \"key\"}, v: []string{\"2\", \"password\"}},\n\t\t{m: mGET, r: \"/users/2/settings/\", h: hStub16, k: []string{\"id\", \"*\"}, v: []string{\"2\", \"\"}},\n\t}\n\n\t// log.Println(\"~~~~~~~~~\")\n\t// log.Println(\"~~~~~~~~~\")\n\t// debugPrintTree(0, 0, tr, 0)\n\t// log.Println(\"~~~~~~~~~\")\n\t// log.Println(\"~~~~~~~~~\")\n\n\tfor i, tt := range tests {\n\t\trctx := NewRouteContext()\n\n\t\t_, handlers, _ := tr.FindRoute(rctx, tt.m, tt.r)\n\n\t\tvar handler http.Handler\n\t\tif methodHandler, ok := handlers[tt.m]; ok {\n\t\t\thandler = methodHandler.handler\n\t\t}\n\n\t\tparamKeys := rctx.routeParams.Keys\n\t\tparamValues := rctx.routeParams.Values\n\n\t\tif fmt.Sprintf(\"%v\", tt.h) != fmt.Sprintf(\"%v\", handler) {\n\t\t\tt.Errorf(\"input [%d]: find '%s' expecting handler:%v , got:%v\", i, tt.r, tt.h, handler)\n\t\t}\n\t\tif !stringSliceEqual(tt.k, paramKeys) {\n\t\t\tt.Errorf(\"input [%d]: find '%s' expecting paramKeys:(%d)%v , got:(%d)%v\", i, tt.r, len(tt.k), tt.k, len(paramKeys), paramKeys)\n\t\t}\n\t\tif !stringSliceEqual(tt.v, paramValues) {\n\t\t\tt.Errorf(\"input [%d]: find '%s' expecting paramValues:(%d)%v , got:(%d)%v\", i, tt.r, len(tt.v), tt.v, len(paramValues), paramValues)\n\t\t}\n\t}\n}\n\nfunc TestTreeRegexp(t *testing.T) {\n\thStub1 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub2 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub3 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub4 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub5 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub6 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub7 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\ttr := &node{}\n\ttr.InsertRoute(mGET, \"/articles/{rid:^[0-9]{5,6}}\", hStub7)\n\ttr.InsertRoute(mGET, \"/articles/{zid:^0[0-9]+}\", hStub3)\n\ttr.InsertRoute(mGET, \"/articles/{name:^@[a-z]+}/posts\", hStub4)\n\ttr.InsertRoute(mGET, \"/articles/{op:^[0-9]+}/run\", hStub5)\n\ttr.InsertRoute(mGET, \"/articles/{id:^[0-9]+}\", hStub1)\n\ttr.InsertRoute(mGET, \"/articles/{id:^[1-9]+}-{aux}\", hStub6)\n\ttr.InsertRoute(mGET, \"/articles/{slug}\", hStub2)\n\n\t// log.Println(\"~~~~~~~~~\")\n\t// log.Println(\"~~~~~~~~~\")\n\t// debugPrintTree(0, 0, tr, 0)\n\t// log.Println(\"~~~~~~~~~\")\n\t// log.Println(\"~~~~~~~~~\")\n\n\ttests := []struct {\n\t\tr string       // input request path\n\t\th http.Handler // output matched handler\n\t\tk []string     // output param keys\n\t\tv []string     // output param values\n\t}{\n\t\t{r: \"/articles\", h: nil, k: []string{}, v: []string{}},\n\t\t{r: \"/articles/12345\", h: hStub7, k: []string{\"rid\"}, v: []string{\"12345\"}},\n\t\t{r: \"/articles/123\", h: hStub1, k: []string{\"id\"}, v: []string{\"123\"}},\n\t\t{r: \"/articles/how-to-build-a-router\", h: hStub2, k: []string{\"slug\"}, v: []string{\"how-to-build-a-router\"}},\n\t\t{r: \"/articles/0456\", h: hStub3, k: []string{\"zid\"}, v: []string{\"0456\"}},\n\t\t{r: \"/articles/@pk/posts\", h: hStub4, k: []string{\"name\"}, v: []string{\"@pk\"}},\n\t\t{r: \"/articles/1/run\", h: hStub5, k: []string{\"op\"}, v: []string{\"1\"}},\n\t\t{r: \"/articles/1122\", h: hStub1, k: []string{\"id\"}, v: []string{\"1122\"}},\n\t\t{r: \"/articles/1122-yes\", h: hStub6, k: []string{\"id\", \"aux\"}, v: []string{\"1122\", \"yes\"}},\n\t}\n\n\tfor i, tt := range tests {\n\t\trctx := NewRouteContext()\n\n\t\t_, handlers, _ := tr.FindRoute(rctx, mGET, tt.r)\n\n\t\tvar handler http.Handler\n\t\tif methodHandler, ok := handlers[mGET]; ok {\n\t\t\thandler = methodHandler.handler\n\t\t}\n\n\t\tparamKeys := rctx.routeParams.Keys\n\t\tparamValues := rctx.routeParams.Values\n\n\t\tif fmt.Sprintf(\"%v\", tt.h) != fmt.Sprintf(\"%v\", handler) {\n\t\t\tt.Errorf(\"input [%d]: find '%s' expecting handler:%v , got:%v\", i, tt.r, tt.h, handler)\n\t\t}\n\t\tif !stringSliceEqual(tt.k, paramKeys) {\n\t\t\tt.Errorf(\"input [%d]: find '%s' expecting paramKeys:(%d)%v , got:(%d)%v\", i, tt.r, len(tt.k), tt.k, len(paramKeys), paramKeys)\n\t\t}\n\t\tif !stringSliceEqual(tt.v, paramValues) {\n\t\t\tt.Errorf(\"input [%d]: find '%s' expecting paramValues:(%d)%v , got:(%d)%v\", i, tt.r, len(tt.v), tt.v, len(paramValues), paramValues)\n\t\t}\n\t}\n}\n\nfunc TestTreeRegexpRecursive(t *testing.T) {\n\thStub1 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub2 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\ttr := &node{}\n\ttr.InsertRoute(mGET, \"/one/{firstId:[a-z0-9-]+}/{secondId:[a-z0-9-]+}/first\", hStub1)\n\ttr.InsertRoute(mGET, \"/one/{firstId:[a-z0-9-_]+}/{secondId:[a-z0-9-_]+}/second\", hStub2)\n\n\t// log.Println(\"~~~~~~~~~\")\n\t// log.Println(\"~~~~~~~~~\")\n\t// debugPrintTree(0, 0, tr, 0)\n\t// log.Println(\"~~~~~~~~~\")\n\t// log.Println(\"~~~~~~~~~\")\n\n\ttests := []struct {\n\t\tr string       // input request path\n\t\th http.Handler // output matched handler\n\t\tk []string     // output param keys\n\t\tv []string     // output param values\n\t}{\n\t\t{r: \"/one/hello/world/first\", h: hStub1, k: []string{\"firstId\", \"secondId\"}, v: []string{\"hello\", \"world\"}},\n\t\t{r: \"/one/hi_there/ok/second\", h: hStub2, k: []string{\"firstId\", \"secondId\"}, v: []string{\"hi_there\", \"ok\"}},\n\t\t{r: \"/one///first\", h: nil, k: []string{}, v: []string{}},\n\t\t{r: \"/one/hi/123/second\", h: hStub2, k: []string{\"firstId\", \"secondId\"}, v: []string{\"hi\", \"123\"}},\n\t}\n\n\tfor i, tt := range tests {\n\t\trctx := NewRouteContext()\n\n\t\t_, handlers, _ := tr.FindRoute(rctx, mGET, tt.r)\n\n\t\tvar handler http.Handler\n\t\tif methodHandler, ok := handlers[mGET]; ok {\n\t\t\thandler = methodHandler.handler\n\t\t}\n\n\t\tparamKeys := rctx.routeParams.Keys\n\t\tparamValues := rctx.routeParams.Values\n\n\t\tif fmt.Sprintf(\"%v\", tt.h) != fmt.Sprintf(\"%v\", handler) {\n\t\t\tt.Errorf(\"input [%d]: find '%s' expecting handler:%v , got:%v\", i, tt.r, tt.h, handler)\n\t\t}\n\t\tif !stringSliceEqual(tt.k, paramKeys) {\n\t\t\tt.Errorf(\"input [%d]: find '%s' expecting paramKeys:(%d)%v , got:(%d)%v\", i, tt.r, len(tt.k), tt.k, len(paramKeys), paramKeys)\n\t\t}\n\t\tif !stringSliceEqual(tt.v, paramValues) {\n\t\t\tt.Errorf(\"input [%d]: find '%s' expecting paramValues:(%d)%v , got:(%d)%v\", i, tt.r, len(tt.v), tt.v, len(paramValues), paramValues)\n\t\t}\n\t}\n}\n\nfunc TestTreeRegexMatchWholeParam(t *testing.T) {\n\thStub1 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\trctx := NewRouteContext()\n\ttr := &node{}\n\ttr.InsertRoute(mGET, \"/{id:[0-9]+}\", hStub1)\n\ttr.InsertRoute(mGET, \"/{x:.+}/foo\", hStub1)\n\ttr.InsertRoute(mGET, \"/{param:[0-9]*}/test\", hStub1)\n\n\ttests := []struct {\n\t\texpectedHandler http.Handler\n\t\turl             string\n\t}{\n\t\t{url: \"/13\", expectedHandler: hStub1},\n\t\t{url: \"/a13\", expectedHandler: nil},\n\t\t{url: \"/13.jpg\", expectedHandler: nil},\n\t\t{url: \"/a13.jpg\", expectedHandler: nil},\n\t\t{url: \"/a/foo\", expectedHandler: hStub1},\n\t\t{url: \"//foo\", expectedHandler: nil},\n\t\t{url: \"//test\", expectedHandler: hStub1},\n\t}\n\n\tfor _, tc := range tests {\n\t\t_, _, handler := tr.FindRoute(rctx, mGET, tc.url)\n\t\tif fmt.Sprintf(\"%v\", tc.expectedHandler) != fmt.Sprintf(\"%v\", handler) {\n\t\t\tt.Errorf(\"url %v: expecting handler:%v , got:%v\", tc.url, tc.expectedHandler, handler)\n\t\t}\n\t}\n}\n\nfunc TestTreeFindPattern(t *testing.T) {\n\thStub1 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub2 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\thStub3 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\ttr := &node{}\n\ttr.InsertRoute(mGET, \"/pages/*\", hStub1)\n\ttr.InsertRoute(mGET, \"/articles/{id}/*\", hStub2)\n\ttr.InsertRoute(mGET, \"/articles/{slug}/{uid}/*\", hStub3)\n\n\tif tr.findPattern(\"/pages\") != false {\n\t\tt.Errorf(\"find /pages failed\")\n\t}\n\tif tr.findPattern(\"/pages*\") != false {\n\t\tt.Errorf(\"find /pages* failed - should be nil\")\n\t}\n\tif tr.findPattern(\"/pages/*\") == false {\n\t\tt.Errorf(\"find /pages/* failed\")\n\t}\n\tif tr.findPattern(\"/articles/{id}/*\") == false {\n\t\tt.Errorf(\"find /articles/{id}/* failed\")\n\t}\n\tif tr.findPattern(\"/articles/{something}/*\") == false {\n\t\tt.Errorf(\"find /articles/{something}/* failed\")\n\t}\n\tif tr.findPattern(\"/articles/{slug}/{uid}/*\") == false {\n\t\tt.Errorf(\"find /articles/{slug}/{uid}/* failed\")\n\t}\n}\n\nfunc debugPrintTree(parent int, i int, n *node, label byte) bool {\n\tnumEdges := 0\n\tfor _, nds := range n.children {\n\t\tnumEdges += len(nds)\n\t}\n\n\t// if n.handlers != nil {\n\t// \tlog.Printf(\"[node %d parent:%d] typ:%d prefix:%s label:%s tail:%s numEdges:%d isLeaf:%v handler:%v pat:%s keys:%v\\n\", i, parent, n.typ, n.prefix, string(label), string(n.tail), numEdges, n.isLeaf(), n.handlers, n.pattern, n.paramKeys)\n\t// } else {\n\t// \tlog.Printf(\"[node %d parent:%d] typ:%d prefix:%s label:%s tail:%s numEdges:%d isLeaf:%v pat:%s keys:%v\\n\", i, parent, n.typ, n.prefix, string(label), string(n.tail), numEdges, n.isLeaf(), n.pattern, n.paramKeys)\n\t// }\n\tif n.endpoints != nil {\n\t\tlog.Printf(\"[node %d parent:%d] typ:%d prefix:%s label:%s tail:%s numEdges:%d isLeaf:%v handler:%v\\n\", i, parent, n.typ, n.prefix, string(label), string(n.tail), numEdges, n.isLeaf(), n.endpoints)\n\t} else {\n\t\tlog.Printf(\"[node %d parent:%d] typ:%d prefix:%s label:%s tail:%s numEdges:%d isLeaf:%v\\n\", i, parent, n.typ, n.prefix, string(label), string(n.tail), numEdges, n.isLeaf())\n\t}\n\tparent = i\n\tfor _, nds := range n.children {\n\t\tfor _, e := range nds {\n\t\t\ti++\n\t\t\tif debugPrintTree(parent, i, e, e.label) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc stringSliceEqual(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif b[i] != a[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc BenchmarkTreeGet(b *testing.B) {\n\th1 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\th2 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\ttr := &node{}\n\ttr.InsertRoute(mGET, \"/\", h1)\n\ttr.InsertRoute(mGET, \"/ping\", h2)\n\ttr.InsertRoute(mGET, \"/pingall\", h2)\n\ttr.InsertRoute(mGET, \"/ping/{id}\", h2)\n\ttr.InsertRoute(mGET, \"/ping/{id}/woop\", h2)\n\ttr.InsertRoute(mGET, \"/ping/{id}/{opt}\", h2)\n\ttr.InsertRoute(mGET, \"/pinggggg\", h2)\n\ttr.InsertRoute(mGET, \"/hello\", h1)\n\n\tmctx := NewRouteContext()\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tmctx.Reset()\n\t\ttr.FindRoute(mctx, mGET, \"/ping/123/456\")\n\t}\n}\n\nfunc TestWalker(t *testing.T) {\n\tr := bigMux()\n\n\t// Walk the muxBig router tree.\n\tif err := Walk(r, func(method string, route string, handler http.Handler, middlewares ...func(http.Handler) http.Handler) error {\n\t\tt.Logf(\"%v %v\", method, route)\n\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Error(err)\n\t}\n}\n"
        }
      ]
    }
  ]
}