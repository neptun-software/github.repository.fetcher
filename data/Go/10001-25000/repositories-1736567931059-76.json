{
  "metadata": {
    "timestamp": 1736567931059,
    "page": 76,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "joewalnes/websocketd",
      "stars": 17182,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.015625,
          "content": "websocketd\ngo-*\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.173828125,
          "content": "websocketd authors\n==================\n\nJoe Walnes <joe@walnes.com>\nGareth Jones <gareth.e.jones@gmail.com>\nAjit George <ajit@ajitgeorge.com>\nAlex Sergeyev <abc@alexsergeyev.com>\n"
        },
        {
          "name": "CHANGES",
          "type": "blob",
          "size": 1.705078125,
          "content": "Version 0.4.1 (Jan 24, 2021)\n\n* Minor changes only\n* Updated to Go 1.15.7\n\nVersion 0.3.1  (Jan 28, 2019)\n\n* Minor improvements to websocketd itself\n* Use of go modules, gorilla websockets set to 1.4.0\n* Binaries build code switched to 1.11.5 (improving underlying protocol handlers)\n\nVersion 0.3.0  (??, 2017)\n\n* Migration of underlying websocket server to Gorilla Websocket lib.\n* Binaries build code switched to 1.9.2\n\nVersion 0.2.12  (Feb 17, 2016)\n\n* Update of underlying go standard libraries change how SSL works. SSL3 is no longer supported.\n* Support of commands that do not provide text IO (using them as binary websocket frames)\n* Minor changes in examples and --help output \n\nVersion 0.2.11  (Jul 1, 2015)\n\n* PATH env variable is now passed to process by default\n* new --header* flags could generate custom HTTP headers for all websocketd-generated answers\n* fixed bug causing process to hang when WebSockets client disconnect is detected\n* minor changes for console app (default url building logic and tab char printing)\n* multiple changes of examples.\n\n\nVersion 0.2.10  (Feb 16, 2015)\n\n* fixes for null-origin situations (#75, #96)\n* better bash examples (#103)\n* changelog and checksums for released files (#101, #105)\n\n\nVersion 0.2.9  (May 19, 2014)\n\n* ability to listen multiple IP addresses (#40, #43)\n* proper support for TLS (#17)\n* resource limits enforcement (a.k.a. maxforks feature, #46)\n* passenv option to limit environment variables visible by running commands (#4)\n* fix for problem of closing upgraded websocket connection when script is not found (#29)\n* websocket origin restrictions via command line option (#20)\n* minor update for help flag behavior\n* minor fix for devconsole\n\nVersion 0.2.8  (Jan 11, 2014)\n\n* ..."
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.2958984375,
          "content": "Copyright (c) 2014, Joe Walnes and the websocketd authors.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met: \n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer. \n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution. \n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.2763671875,
          "content": "# Copyright 2013 Joe Walnes and the websocketd team.\n# All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\n# Self contained Go build file that will download and install (locally) the correct\n# version of Go, and build our programs. Go does not need to be installed on the\n# system (and if it already is, it will be ignored).\n\n# To manually invoke the locally installed Go, use ./go\n\n# Go installation config.\nGO_VER=1.11.5\nSYSTEM_NAME:=$(shell uname -s | tr '[:upper:]' '[:lower:]')\nSYSTEM_ARCH:=$(shell uname -m)\nGO_ARCH:=$(if $(filter x86_64, $(SYSTEM_ARCH)),amd64,386)\nGO_VERSION:=$(GO_VER).$(SYSTEM_NAME)-$(GO_ARCH)\nGO_DOWNLOAD_URL:=https://dl.google.com/go/go$(GO_VERSION).tar.gz\nGO_DIR:=go-$(GO_VER)\n\n# Build websocketd binary\nwebsocketd: $(GO_DIR)/bin/go $(wildcard *.go) $(wildcard libwebsocketd/*.go)\n\t$(GO_DIR)/bin/go build\n\nlocalgo: $(GO_DIR)/bin/go\n\n# Download and unpack Go distribution.\n$(GO_DIR)/bin/go:\n\tmkdir -p $(GO_DIR)\n\trm -f $@\n\t@echo Downloading and unpacking Go $(GO_VERSION) to $(GO_DIR)\n\tcurl -s $(GO_DOWNLOAD_URL) | tar xfz - --strip-components=1 -C $(GO_DIR)\n\n# Clean up binary\nclean:\n\trm -rf websocketd\n\n.PHONY: clean\n\n# Also clean up downloaded Go\nclobber: clean\n\trm -rf $(wildcard go-v*)\n\n.PHONY: clobber\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.01171875,
          "content": "websocketd\n==========\n\n`websocketd` is a small command-line tool that will wrap an existing command-line interface program, and allow it to be accessed via a WebSocket.\n\nWebSocket-capable applications can now be built very easily. As long as you can write an executable program that reads `STDIN` and writes to `STDOUT`, you can build a WebSocket server. Do it in Python, Ruby, Perl, Bash, .NET, C, Go, PHP, Java, Clojure, Scala, Groovy, Expect, Awk, VBScript, Haskell, Lua, R, whatever! No networking libraries necessary.\n\n-[@joewalnes](https://twitter.com/joewalnes)\n\nDetails\n-------\n\nUpon startup, `websocketd` will start a WebSocket server on a specified port, and listen for connections.\n\nUpon a connection, it will fork the appropriate process, and disconnect the process when the WebSocket connection closes (and vice-versa).\n\nAny message sent from the WebSocket client will be piped to the process's `STDIN` stream, followed by a `\\n` newline.\n\nAny text printed by the process to `STDOUT` shall be sent as a WebSocket message whenever a `\\n` newline is encountered.\n\n\nDownload\n--------\n\nIf you're on a Mac, you can install `websocketd` using [Homebrew](http://brew.sh/). Just run `brew install websocketd`. For other operating systems, or if you don't want to use Homebrew, check out the link below.\n\n**[Download for Linux, OS X and Windows](https://github.com/joewalnes/websocketd/wiki/Download-and-install)**\n\n\nQuickstart\n----------\n\nTo get started, we'll create a WebSocket endpoint that will accept connections, then send back messages, counting to 10 with 1 second pause between each one, before disconnecting.\n\nTo show how simple it is, let's do it in Bash!\n\n__count.sh__:\n\n```sh\n#!/bin/bash\nfor ((COUNT = 1; COUNT <= 10; COUNT++)); do\n  echo $COUNT\n  sleep 1\ndone\n```\n\nBefore turning it into a WebSocket server, let's test it from the command line. The beauty of `websocketd` is that servers work equally well in the command line, or in shell scripts, as they do in the server - with no modifications required.\n\n```sh\n$ chmod +x count.sh\n$ ./count.sh\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n```\n\nNow let's turn it into a WebSocket server:\n\n```sh\n$ websocketd --port=8080 ./count.sh\n```\n\nFinally, let's create a web-page to test it.\n\n__count.html__:\n\n```html\n<!DOCTYPE html>\n<pre id=\"log\"></pre>\n<script>\n  // helper function: log message to screen\n  function log(msg) {\n    document.getElementById('log').textContent += msg + '\\n';\n  }\n\n  // setup websocket with callbacks\n  var ws = new WebSocket('ws://localhost:8080/');\n  ws.onopen = function() {\n    log('CONNECT');\n  };\n  ws.onclose = function() {\n    log('DISCONNECT');\n  };\n  ws.onmessage = function(event) {\n    log('MESSAGE: ' + event.data);\n  };\n</script>\n```\nOpen this page in your web-browser. It will even work if you open it directly\nfrom disk using a `file://` URL.\n\nMore Features\n-------------\n\n*   Very simple install. Just [download](https://github.com/joewalnes/websocketd/wiki/Download-and-install) the single executable for Linux, Mac or Windows and run it. Minimal dependencies, no installers, no package managers, no external libraries. Suitable for development and production servers.\n*   Server side scripts can access details about the WebSocket HTTP request (e.g. remote host, query parameters, cookies, path, etc) via standard [CGI environment variables](https://github.com/joewalnes/websocketd/wiki/Environment-variables).\n*   As well as serving websocket daemons it also includes a static file server and classic CGI server for convenience.\n*   Command line help available via `websocketd --help`.\n*   Includes [WebSocket developer console](https://github.com/joewalnes/websocketd/wiki/Developer-console) to make it easy to test your scripts before you've built a JavaScript frontend.\n*   [Examples in many programming languages](https://github.com/joewalnes/websocketd/tree/master/examples) are available to help you getting started.\n\nUser Manual\n-----------\n\n**[More documentation in the user manual](https://github.com/joewalnes/websocketd/wiki)**\n\nExample Projects\n----------------\n\n*   [Plot real time Linux CPU/IO/Mem stats to a HTML5 dashboard using websocketd and vmstat](https://github.com/joewalnes/web-vmstats) _(for Linux)_\n*   [Arbitrary REPL in the browser using websocketd](https://github.com/rowanthorpe/ws-repl)\n*   [Retrieve SQL data from server with LiveCode and webSocketd](https://github.com/samansjukur/wslc)\n*   [List files from a configured folder](https://github.com/dbalakirev/directator) _(for Linux)_\n*   [Listen for gamepad events and report them to the system](https://github.com/experiment322/controlloid-server) _(this + android = gamepad emulator)_\n\nGot more examples? Open a pull request.\n\nMy Other Projects\n-----------------\n\n*   [ReconnectingWebSocket](https://github.com/joewalnes/reconnecting-websocket) - Simplest way to add some robustness to your WebSocket connections.\n*   [Smoothie Charts](http://smoothiecharts.org/) - JavaScript charts for streaming data.\n*   Visit [The Igloo Lab](http://theigloolab.com/) to see and subscribe to other thingies I make.\n\nAnd [follow @joewalnes](https://twitter.com/joewalnes)!\n"
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 8.8251953125,
          "content": "// Copyright 2013 Joe Walnes and the websocketd team.\n// All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/joewalnes/websocketd/libwebsocketd\"\n)\n\ntype Config struct {\n\tAddr              []string // TCP addresses to listen on. e.g. \":1234\", \"1.2.3.4:1234\" or \"[::1]:1234\"\n\tMaxForks          int      // Number of allowable concurrent forks\n\tLogLevel          libwebsocketd.LogLevel\n\tRedirPort         int\n\tCertFile, KeyFile string\n\t*libwebsocketd.Config\n}\n\ntype Arglist []string\n\nfunc (al *Arglist) String() string {\n\treturn fmt.Sprintf(\"%v\", []string(*al))\n}\n\nfunc (al *Arglist) Set(value string) error {\n\t*al = append(*al, value)\n\treturn nil\n}\n\n// Borrowed from net/http/cgi\nvar defaultPassEnv = map[string]string{\n\t\"darwin\":  \"PATH,DYLD_LIBRARY_PATH\",\n\t\"freebsd\": \"PATH,LD_LIBRARY_PATH\",\n\t\"hpux\":    \"PATH,LD_LIBRARY_PATH,SHLIB_PATH\",\n\t\"irix\":    \"PATH,LD_LIBRARY_PATH,LD_LIBRARYN32_PATH,LD_LIBRARY64_PATH\",\n\t\"linux\":   \"PATH,LD_LIBRARY_PATH\",\n\t\"openbsd\": \"PATH,LD_LIBRARY_PATH\",\n\t\"solaris\": \"PATH,LD_LIBRARY_PATH,LD_LIBRARY_PATH_32,LD_LIBRARY_PATH_64\",\n\t\"windows\": \"PATH,SystemRoot,COMSPEC,PATHEXT,WINDIR\",\n}\n\nfunc parseCommandLine() *Config {\n\tvar mainConfig Config\n\tvar config libwebsocketd.Config\n\n\tflag.CommandLine = flag.NewFlagSet(os.Args[0], flag.ContinueOnError)\n\tflag.CommandLine.Usage = func() {}\n\n\t// If adding new command line options, also update the help text in help.go.\n\t// The flag library's auto-generate help message isn't pretty enough.\n\n\taddrlist := Arglist(make([]string, 0, 1)) // pre-reserve for 1 address\n\tflag.Var(&addrlist, \"address\", \"Interfaces to bind to (e.g. 127.0.0.1 or [::1]).\")\n\n\t// server config options\n\tportFlag := flag.Int(\"port\", 0, \"HTTP port to listen on\")\n\tversionFlag := flag.Bool(\"version\", false, \"Print version and exit\")\n\tlicenseFlag := flag.Bool(\"license\", false, \"Print license and exit\")\n\tlogLevelFlag := flag.String(\"loglevel\", \"access\", \"Log level, one of: debug, trace, access, info, error, fatal\")\n\tsslFlag := flag.Bool(\"ssl\", false, \"Use TLS on listening socket (see also --sslcert and --sslkey)\")\n\tsslCert := flag.String(\"sslcert\", \"\", \"Should point to certificate PEM file when --ssl is used\")\n\tsslKey := flag.String(\"sslkey\", \"\", \"Should point to certificate private key file when --ssl is used\")\n\tmaxForksFlag := flag.Int(\"maxforks\", 0, \"Max forks, zero means unlimited\")\n\tcloseMsFlag := flag.Uint(\"closems\", 0, \"Time to start sending signals (0 never)\")\n\tredirPortFlag := flag.Int(\"redirport\", 0, \"HTTP port to redirect to canonical --port address\")\n\n\t// lib config options\n\tbinaryFlag := flag.Bool(\"binary\", false, \"Set websocketd to experimental binary mode (default is line by line)\")\n\treverseLookupFlag := flag.Bool(\"reverselookup\", false, \"Perform reverse DNS lookups on remote clients\")\n\tscriptDirFlag := flag.String(\"dir\", \"\", \"Base directory for WebSocket scripts\")\n\tstaticDirFlag := flag.String(\"staticdir\", \"\", \"Serve static content from this directory over HTTP\")\n\tcgiDirFlag := flag.String(\"cgidir\", \"\", \"Serve CGI scripts from this directory over HTTP\")\n\tdevConsoleFlag := flag.Bool(\"devconsole\", false, \"Enable development console (cannot be used in conjunction with --staticdir)\")\n\tpassEnvFlag := flag.String(\"passenv\", defaultPassEnv[runtime.GOOS], \"List of envvars to pass to subprocesses (others will be cleaned out)\")\n\tsameOriginFlag := flag.Bool(\"sameorigin\", false, \"Restrict upgrades if origin and host headers differ\")\n\tallowOriginsFlag := flag.String(\"origin\", \"\", \"Restrict upgrades if origin does not match the list\")\n\n\theaders := Arglist(make([]string, 0))\n\theadersWs := Arglist(make([]string, 0))\n\theadersHttp := Arglist(make([]string, 0))\n\tflag.Var(&headers, \"header\", \"Custom headers for any response.\")\n\tflag.Var(&headersWs, \"header-ws\", \"Custom headers for successful WebSocket upgrade responses.\")\n\tflag.Var(&headersHttp, \"header-http\", \"Custom headers for all but WebSocket upgrade HTTP responses.\")\n\n\terr := flag.CommandLine.Parse(os.Args[1:])\n\tif err != nil {\n\t\tif err == flag.ErrHelp {\n\t\t\tPrintHelp()\n\t\t\tos.Exit(0)\n\t\t} else {\n\t\t\tShortHelp()\n\t\t\tos.Exit(2)\n\t\t}\n\t}\n\n\tport := *portFlag\n\tif port == 0 {\n\t\tif *sslFlag {\n\t\t\tport = 443\n\t\t} else {\n\t\t\tport = 80\n\t\t}\n\t}\n\n\tif socknum := len(addrlist); socknum != 0 {\n\t\tmainConfig.Addr = make([]string, socknum)\n\t\tfor i, addrSingle := range addrlist {\n\t\t\tmainConfig.Addr[i] = fmt.Sprintf(\"%s:%d\", addrSingle, port)\n\t\t}\n\t} else {\n\t\tmainConfig.Addr = []string{fmt.Sprintf(\":%d\", port)}\n\t}\n\tmainConfig.MaxForks = *maxForksFlag\n\tmainConfig.RedirPort = *redirPortFlag\n\tmainConfig.LogLevel = libwebsocketd.LevelFromString(*logLevelFlag)\n\tif mainConfig.LogLevel == libwebsocketd.LogUnknown {\n\t\tfmt.Printf(\"Incorrect loglevel flag '%s'. Use --help to see allowed values.\\n\", *logLevelFlag)\n\t\tShortHelp()\n\t\tos.Exit(1)\n\t}\n\n\tconfig.Headers = []string(headers)\n\tconfig.HeadersWs = []string(headersWs)\n\tconfig.HeadersHTTP = []string(headersHttp)\n\n\tconfig.CloseMs = *closeMsFlag\n\tconfig.Binary = *binaryFlag\n\tconfig.ReverseLookup = *reverseLookupFlag\n\tconfig.Ssl = *sslFlag\n\tconfig.ScriptDir = *scriptDirFlag\n\tconfig.StaticDir = *staticDirFlag\n\tconfig.CgiDir = *cgiDirFlag\n\tconfig.DevConsole = *devConsoleFlag\n\tconfig.StartupTime = time.Now()\n\tconfig.ServerSoftware = fmt.Sprintf(\"websocketd/%s\", Version())\n\tconfig.HandshakeTimeout = time.Millisecond * 1500 // only default for now\n\n\tif len(os.Args) == 1 {\n\t\tfmt.Printf(\"Command line arguments are missing.\\n\")\n\t\tShortHelp()\n\t\tos.Exit(1)\n\t}\n\n\tif *versionFlag {\n\t\tfmt.Printf(\"%s %s\\n\", HelpProcessName(), Version())\n\t\tos.Exit(0)\n\t}\n\n\tif *licenseFlag {\n\t\tfmt.Printf(\"%s %s\\n\", HelpProcessName(), Version())\n\t\tfmt.Printf(\"%s\\n\", libwebsocketd.License)\n\t\tos.Exit(0)\n\t}\n\n\t// Reading SSL options\n\tif config.Ssl {\n\t\tif *sslCert == \"\" || *sslKey == \"\" {\n\t\t\tfmt.Fprintf(os.Stderr, \"Please specify both --sslcert and --sslkey when requesting --ssl.\\n\")\n\t\t\tos.Exit(1)\n\t\t}\n\t} else {\n\t\tif *sslCert != \"\" || *sslKey != \"\" {\n\t\t\tfmt.Fprintf(os.Stderr, \"You should not be using --ssl* flags when there is no --ssl option.\\n\")\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n\n\tmainConfig.CertFile = *sslCert\n\tmainConfig.KeyFile = *sslKey\n\n\t// Building config.ParentEnv to avoid calling Environ all the time in the scripts\n\t// (caller is responsible for wiping environment if desired)\n\tconfig.ParentEnv = make([]string, 0)\n\tnewlineCleaner := strings.NewReplacer(\"\\n\", \" \", \"\\r\", \" \")\n\tfor _, key := range strings.Split(*passEnvFlag, \",\") {\n\t\tif key != \"HTTPS\" {\n\t\t\tif v := os.Getenv(key); v != \"\" {\n\t\t\t\t// inevitably adding flavor of libwebsocketd appendEnv func.\n\t\t\t\t// it's slightly nicer than in net/http/cgi implementation\n\t\t\t\tif clean := strings.TrimSpace(newlineCleaner.Replace(v)); clean != \"\" {\n\t\t\t\t\tconfig.ParentEnv = append(config.ParentEnv, fmt.Sprintf(\"%s=%s\", key, clean))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif *allowOriginsFlag != \"\" {\n\t\tconfig.AllowOrigins = strings.Split(*allowOriginsFlag, \",\")\n\t}\n\tconfig.SameOrigin = *sameOriginFlag\n\n\targs := flag.Args()\n\tif len(args) < 1 && config.ScriptDir == \"\" && config.StaticDir == \"\" && config.CgiDir == \"\" {\n\t\tfmt.Fprintf(os.Stderr, \"Please specify COMMAND or provide --dir, --staticdir or --cgidir argument.\\n\")\n\t\tShortHelp()\n\t\tos.Exit(1)\n\t}\n\n\tif len(args) > 0 {\n\t\tif config.ScriptDir != \"\" {\n\t\t\tfmt.Fprintf(os.Stderr, \"Ambiguous. Provided COMMAND and --dir argument. Please only specify just one.\\n\")\n\t\t\tShortHelp()\n\t\t\tos.Exit(1)\n\t\t}\n\t\tif path, err := exec.LookPath(args[0]); err == nil {\n\t\t\tconfig.CommandName = path // This can be command in PATH that we are able to execute\n\t\t\tconfig.CommandArgs = flag.Args()[1:]\n\t\t\tconfig.UsingScriptDir = false\n\t\t} else {\n\t\t\tfmt.Fprintf(os.Stderr, \"Unable to locate specified COMMAND '%s' in OS path.\\n\", args[0])\n\t\t\tShortHelp()\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n\n\tif config.ScriptDir != \"\" {\n\t\tscriptDir, err := filepath.Abs(config.ScriptDir)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Could not resolve absolute path to dir '%s'.\\n\", config.ScriptDir)\n\t\t\tShortHelp()\n\t\t\tos.Exit(1)\n\t\t}\n\t\tinf, err := os.Stat(scriptDir)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Could not find your script dir '%s'.\\n\", config.ScriptDir)\n\t\t\tShortHelp()\n\t\t\tos.Exit(1)\n\t\t}\n\t\tif !inf.IsDir() {\n\t\t\tfmt.Fprintf(os.Stderr, \"Did you mean to specify COMMAND instead of --dir '%s'?\\n\", config.ScriptDir)\n\t\t\tShortHelp()\n\t\t\tos.Exit(1)\n\t\t} else {\n\t\t\tconfig.ScriptDir = scriptDir\n\t\t\tconfig.UsingScriptDir = true\n\t\t}\n\t}\n\n\tif config.CgiDir != \"\" {\n\t\tif inf, err := os.Stat(config.CgiDir); err != nil || !inf.IsDir() {\n\t\t\tfmt.Fprintf(os.Stderr, \"Your CGI dir '%s' is not pointing to an accessible directory.\\n\", config.CgiDir)\n\t\t\tShortHelp()\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n\n\tif config.StaticDir != \"\" {\n\t\tif inf, err := os.Stat(config.StaticDir); err != nil || !inf.IsDir() {\n\t\t\tfmt.Fprintf(os.Stderr, \"Your static dir '%s' is not pointing to an accessible directory.\\n\", config.StaticDir)\n\t\t\tShortHelp()\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n\n\tmainConfig.Config = &config\n\n\treturn &mainConfig\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0908203125,
          "content": "module github.com/joewalnes/websocketd\n\ngo 1.15\n\nrequire github.com/gorilla/websocket v1.4.0\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.1708984375,
          "content": "github.com/gorilla/websocket v1.4.0 h1:WDFjx/TMzVgy9VdMMQi2K2Emtwi2QcUQsztZ/zLaH/Q=\ngithub.com/gorilla/websocket v1.4.0/go.mod h1:E7qHFY5m1UJ88s3WnNqhKjPHQ0heANvMoAMk2YaljkQ=\n"
        },
        {
          "name": "help.go",
          "type": "blob",
          "size": 6.5068359375,
          "content": "// Copyright 2013 Joe Walnes and the websocketd team.\n// All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst (\n\thelp = `\n{{binary}} ({{version}})\n\n{{binary}} is a command line tool that will allow any executable program\nthat accepts input on stdin and produces output on stdout to be turned into\na WebSocket server.\n\nUsage:\n\n  Export a single executable program a WebSocket server:\n    {{binary}} [options] COMMAND [command args]\n\n  Or, export an entire directory of executables as WebSocket endpoints:\n    {{binary}} [options] --dir=SOMEDIR\n\nOptions:\n\n  --port=PORT                    HTTP port to listen on.\n\n  --address=ADDRESS              Address to bind to (multiple options allowed)\n                                 Use square brackets to specify IPv6 address.\n                                 Default: \"\" (all)\n\n  --sameorigin={true,false}      Restrict (HTTP 403) protocol upgrades if the\n                                 Origin header does not match to requested HTTP\n                                 Host. Default: false.\n\n  --origin=host[:port][,host[:port]...]\n                                 Restrict (HTTP 403) protocol upgrades if the\n                                 Origin header does not match to one of the host\n                                 and port combinations listed. If the port is not\n                                 specified, any port number will match.\n                                 Default: \"\" (allow any origin)\n\n  --ssl                          Listen for HTTPS socket instead of HTTP.\n  --sslcert=FILE                 All three options must be used or all of\n  --sslkey=FILE                  them should be omitted.\n\n  --redirport=PORT               Open alternative port and redirect HTTP traffic\n                                 from it to canonical address (mostly useful\n                                 for HTTPS-only configurations to redirect HTTP\n                                 traffic)\n\n  --passenv VAR[,VAR...]         Lists environment variables allowed to be\n                                 passed to executed scripts. Does not work for\n                                 Windows since all the variables are kept there.\n\n  --binary={true,false}          Switches communication to binary, process reads\n                                 send to browser as blobs and all reads from the\n                                 browser are immediately flushed to the process.\n                                 Default: false\n\n  --reverselookup={true,false}   Perform DNS reverse lookups on remote clients.\n                                 Default: false\n\n  --dir=DIR                      Allow all scripts in the local directory\n                                 to be accessed as WebSockets. If using this,\n                                 option, then the standard program and args\n                                 options should not be specified.\n\n  --staticdir=DIR                Serve static files in this directory over HTTP.\n\n  --cgidir=DIR                   Serve CGI scripts in this directory over HTTP.\n\n  --maxforks=N                   Limit number of processes that websocketd is\n                                 able to execute with WS and CGI handlers.\n                                 When maxforks reached the server will be\n                                 rejecting requests that require executing\n                                 another process (unlimited when 0 or negative).\n                                 Default: 0\n\n  --closems=milliseconds         Specifies additional time process needs to gracefully\n                                 finish before websocketd will send termination signals\n                                 to it. Default: 0 (signals sent after 100ms, 250ms,\n                                 and 500ms of waiting)\n\n  --header=\"...\"                 Set custom HTTP header to each answer. For\n                                 example: --header=\"Server: someserver/0.0.1\"\n\n  --header-ws=\"....\"             Same as --header, just applies to only those\n                                 responses that indicate upgrade of TCP connection\n                                 to a WebSockets protocol.\n\n  --header-http=\"....\"           Same as --header, just applies to only to plain\n                                 HTTP responses that do not indicate WebSockets\n                                 upgrade\n\n\n  --help                         Print help and exit.\n\n  --version                      Print version and exit.\n\n  --license                      Print license and exit.\n\n  --devconsole                   Enable interactive development console.\n                                 This enables you to access the websocketd\n                                 server with a web-browser and use a\n                                 user interface to quickly test WebSocket\n                                 endpoints. For example, to test an\n                                 endpoint at ws://[host]/foo, you can\n                                 visit http://[host]/foo in your browser.\n                                 This flag cannot be used in conjunction\n                                 with --staticdir or --cgidir.\n\n  --loglevel=LEVEL               Log level to use (default access).\n                                 From most to least verbose:\n                                 debug, trace, access, info, error, fatal\n\nFull documentation at http://websocketd.com/\n\nCopyright 2013 Joe Walnes and the websocketd team. All rights reserved.\nBSD license: Run '{{binary}} --license' for details.\n`\n\tshort = `\nUsage:\n\n  Export a single executable program a WebSocket server:\n    {{binary}} [options] COMMAND [command args]\n\n  Or, export an entire directory of executables as WebSocket endpoints:\n    {{binary}} [options] --dir=SOMEDIR\n\n  Or, show extended help message using:\n    {{binary}} --help\n`\n)\n\nfunc get_help_message(content string) string {\n\tmsg := strings.Trim(content, \" \\n\")\n\tmsg = strings.Replace(msg, \"{{binary}}\", HelpProcessName(), -1)\n\treturn strings.Replace(msg, \"{{version}}\", Version(), -1)\n}\n\nfunc HelpProcessName() string {\n\tbinary := os.Args[0]\n\tif strings.Contains(binary, \"/go-build\") { // this was run using \"go run\", let's use something appropriate\n\t\tbinary = \"websocketd\"\n\t} else {\n\t\tbinary = filepath.Base(binary)\n\t}\n\treturn binary\n}\n\nfunc PrintHelp() {\n\tfmt.Fprintf(os.Stderr, \"%s\\n\", get_help_message(help))\n}\n\nfunc ShortHelp() {\n\t// Shown after some error\n\tfmt.Fprintf(os.Stderr, \"\\n%s\\n\", get_help_message(short))\n}\n"
        },
        {
          "name": "libwebsocketd",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 3.7939453125,
          "content": "// Copyright 2013 Joe Walnes and the websocketd team.\n// All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/joewalnes/websocketd/libwebsocketd\"\n)\n\nfunc logfunc(l *libwebsocketd.LogScope, level libwebsocketd.LogLevel, levelName string, category string, msg string, args ...interface{}) {\n\tif level < l.MinLevel {\n\t\treturn\n\t}\n\tfullMsg := fmt.Sprintf(msg, args...)\n\n\tassocDump := \"\"\n\tfor index, pair := range l.Associated {\n\t\tif index > 0 {\n\t\t\tassocDump += \" \"\n\t\t}\n\t\tassocDump += fmt.Sprintf(\"%s:'%s'\", pair.Key, pair.Value)\n\t}\n\n\tl.Mutex.Lock()\n\tfmt.Printf(\"%s | %-6s | %-10s | %s | %s\\n\", libwebsocketd.Timestamp(), levelName, category, assocDump, fullMsg)\n\tl.Mutex.Unlock()\n}\n\nfunc main() {\n\tconfig := parseCommandLine()\n\n\tlog := libwebsocketd.RootLogScope(config.LogLevel, logfunc)\n\n\tif config.DevConsole {\n\t\tif config.StaticDir != \"\" {\n\t\t\tlog.Fatal(\"server\", \"Invalid parameters: --devconsole cannot be used with --staticdir. Pick one.\")\n\t\t\tos.Exit(4)\n\t\t}\n\t\tif config.CgiDir != \"\" {\n\t\t\tlog.Fatal(\"server\", \"Invalid parameters: --devconsole cannot be used with --cgidir. Pick one.\")\n\t\t\tos.Exit(4)\n\t\t}\n\t}\n\n\tif runtime.GOOS != \"windows\" { // windows relies on env variables to find its libs... e.g. socket stuff\n\t\tos.Clearenv() // it's ok to wipe it clean, we already read env variables from passenv into config\n\t}\n\thandler := libwebsocketd.NewWebsocketdServer(config.Config, log, config.MaxForks)\n\thttp.Handle(\"/\", handler)\n\n\tif config.UsingScriptDir {\n\t\tlog.Info(\"server\", \"Serving from directory      : %s\", config.ScriptDir)\n\t} else if config.CommandName != \"\" {\n\t\tlog.Info(\"server\", \"Serving using application   : %s %s\", config.CommandName, strings.Join(config.CommandArgs, \" \"))\n\t}\n\tif config.StaticDir != \"\" {\n\t\tlog.Info(\"server\", \"Serving static content from : %s\", config.StaticDir)\n\t}\n\tif config.CgiDir != \"\" {\n\t\tlog.Info(\"server\", \"Serving CGI scripts from    : %s\", config.CgiDir)\n\t}\n\n\trejects := make(chan error, 1)\n\tfor _, addrSingle := range config.Addr {\n\t\tlog.Info(\"server\", \"Starting WebSocket server   : %s\", handler.TellURL(\"ws\", addrSingle, \"/\"))\n\t\tif config.DevConsole {\n\t\t\tlog.Info(\"server\", \"Developer console enabled   : %s\", handler.TellURL(\"http\", addrSingle, \"/\"))\n\t\t} else if config.StaticDir != \"\" || config.CgiDir != \"\" {\n\t\t\tlog.Info(\"server\", \"Serving CGI or static files : %s\", handler.TellURL(\"http\", addrSingle, \"/\"))\n\t\t}\n\t\t// ListenAndServe is blocking function. Let's run it in\n\t\t// go routine, reporting result to control channel.\n\t\t// Since it's blocking it'll never return non-error.\n\n\t\tgo func(addr string) {\n\t\t\tif config.Ssl {\n\t\t\t\trejects <- http.ListenAndServeTLS(addr, config.CertFile, config.KeyFile, nil)\n\t\t\t} else {\n\t\t\t\trejects <- http.ListenAndServe(addr, nil)\n\t\t\t}\n\t\t}(addrSingle)\n\n\t\tif config.RedirPort != 0 {\n\t\t\tgo func(addr string) {\n\t\t\t\tpos := strings.IndexByte(addr, ':')\n\t\t\t\trediraddr := addr[:pos] + \":\" + strconv.Itoa(config.RedirPort) // it would be silly to optimize this one\n\t\t\t\tredir := &http.Server{Addr: rediraddr, Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\t// redirect to same hostname as in request but different port and probably schema\n\t\t\t\t\turi := \"https://\"\n\t\t\t\t\tif !config.Ssl {\n\t\t\t\t\t\turi = \"http://\"\n\t\t\t\t\t}\n\t\t\t\t\tif cpos := strings.IndexByte(r.Host, ':'); cpos > 0 {\n\t\t\t\t\t\turi += r.Host[:strings.IndexByte(r.Host, ':')] + addr[pos:] + \"/\"\n\t\t\t\t\t} else {\n\t\t\t\t\t\turi += r.Host + addr[pos:] + \"/\"\n\t\t\t\t\t}\n\n\t\t\t\t\thttp.Redirect(w, r, uri, http.StatusMovedPermanently)\n\t\t\t\t})}\n\t\t\t\tlog.Info(\"server\", \"Starting redirect server   : http://%s/\", rediraddr)\n\t\t\t\trejects <- redir.ListenAndServe()\n\t\t\t}(addrSingle)\n\t\t}\n\t}\n\terr := <-rejects\n\tif err != nil {\n\t\tlog.Fatal(\"server\", \"Can't start server: %s\", err)\n\t\tos.Exit(3)\n\t}\n}\n"
        },
        {
          "name": "release",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.6181640625,
          "content": "// Copyright 2013 Joe Walnes and the websocketd team.\n// All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n)\n\n// This value can be set for releases at build time using:\n//   go {build|run} -ldflags \"-X main.version 1.2.3 -X main.buildinfo timestamp-@githubuser-platform\".\n// If unset, Version() shall return \"DEVBUILD\".\nvar version string = \"DEVBUILD\"\nvar buildinfo string = \"--\"\n\nfunc Version() string {\n\treturn fmt.Sprintf(\"%s (%s %s-%s) %s\", version, runtime.Version(), runtime.GOOS, runtime.GOARCH, buildinfo)\n}\n"
        }
      ]
    }
  ]
}