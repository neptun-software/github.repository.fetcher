{
  "metadata": {
    "timestamp": 1736567824271,
    "page": 409,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "caddyserver/certmagic",
      "stars": 5094,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.01171875,
          "content": "_gitignore/\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 31.7763671875,
          "content": "<p align=\"center\">\n\t<a href=\"https://pkg.go.dev/github.com/caddyserver/certmagic?tab=doc\"><img src=\"https://user-images.githubusercontent.com/1128849/49704830-49d37200-fbd5-11e8-8385-767e0cd033c3.png\" alt=\"CertMagic\" width=\"550\"></a>\n</p>\n<h3 align=\"center\">Easy and Powerful TLS Automation</h3>\n<p align=\"center\">The same library used by the <a href=\"https://caddyserver.com\">Caddy Web Server</a></p>\n<p align=\"center\">\n\t<a href=\"https://pkg.go.dev/github.com/caddyserver/certmagic?tab=doc\"><img src=\"https://img.shields.io/badge/godoc-reference-blue.svg\"></a>\n\t<a href=\"https://github.com/caddyserver/certmagic/actions?query=workflow%3ATests\"><img src=\"https://github.com/caddyserver/certmagic/workflows/Tests/badge.svg\"></a>\n\t<a href=\"https://sourcegraph.com/github.com/caddyserver/certmagic?badge\"><img src=\"https://sourcegraph.com/github.com/caddyserver/certmagic/-/badge.svg\"></a>\n</p>\n\n\nCaddy's [automagic TLS features](https://caddyserver.com/docs/automatic-https)&mdash;now for your own Go programs&mdash;in one powerful and easy-to-use library!\n\nCertMagic is the most mature, robust, and powerful ACME client integration for Go... and perhaps ever.\n\nWith CertMagic, you can add one line to your Go application to serve securely over TLS, without ever having to touch certificates.\n\nInstead of:\n\n```go\n// plaintext HTTP, gross 🤢\nhttp.ListenAndServe(\":80\", mux)\n```\n\nUse CertMagic:\n\n```go\n// encrypted HTTPS with HTTP->HTTPS redirects - yay! 🔒😍\ncertmagic.HTTPS([]string{\"example.com\"}, mux)\n```\n\nThat line of code will serve your HTTP router `mux` over HTTPS, complete with HTTP->HTTPS redirects. It obtains and renews the TLS certificates. It staples OCSP responses for greater privacy and security. As long as your domain name points to your server, CertMagic will keep its connections secure.\n\nCompared to other ACME client libraries for Go, only CertMagic supports the full suite of ACME features, and no other library matches CertMagic's maturity and reliability.\n\n\n\n\nCertMagic - Automatic HTTPS using Let's Encrypt\n===============================================\n\n## Menu\n\n- [Features](#features)\n- [Requirements](#requirements)\n- [Installation](#installation)\n- [Usage](#usage)\n\t- [Package Overview](#package-overview)\n\t\t- [Certificate authority](#certificate-authority)\n\t\t- [The `Config` type](#the-config-type)\n\t\t- [Defaults](#defaults)\n\t\t- [Providing an email address](#providing-an-email-address)\n\t\t- [Rate limiting](#rate-limiting)\n\t- [Development and testing](#development-and-testing)\n\t- [Examples](#examples)\n\t\t- [Serving HTTP handlers with HTTPS](#serving-http-handlers-with-https)\n\t\t- [Starting a TLS listener](#starting-a-tls-listener)\n\t\t- [Getting a tls.Config](#getting-a-tlsconfig)\n\t\t- [Advanced use](#advanced-use)\n\t- [Wildcard Certificates](#wildcard-certificates)\n\t- [Behind a load balancer (or in a cluster)](#behind-a-load-balancer-or-in-a-cluster)\n- [The ACME Challenges](#the-acme-challenges)\n\t- [HTTP Challenge](#http-challenge)\n\t- [TLS-ALPN Challenge](#tls-alpn-challenge)\n\t- [DNS Challenge](#dns-challenge)\n- [On-Demand TLS](#on-demand-tls)\n- [Storage](#storage)\n- [Cache](#cache)\n- [Events](#events)\n- [ZeroSSL](#zerossl)\n- [FAQ](#faq)\n- [Contributing](#contributing)\n- [Project History](#project-history)\n- [Credits and License](#credits-and-license)\n\n\n## Features\n\n- Fully automated certificate management including issuance and renewal\n- One-line, fully managed HTTPS servers\n- Full control over almost every aspect of the system\n- HTTP->HTTPS redirects\n- Multiple issuers supported: get certificates from multiple sources/CAs for redundancy and resiliency\n- Solves all 3 common ACME challenges: HTTP, TLS-ALPN, and DNS (and capable of others)\n- Most robust error handling of _any_ ACME client\n\t- Challenges are randomized to avoid accidental dependence\n\t- Challenges are rotated to overcome certain network blockages\n\t- Robust retries for up to 30 days\n\t- Exponential backoff with carefully-tuned intervals\n\t- Retries with optional test/staging CA endpoint instead of production, to avoid rate limits\n- Written in Go, a language with memory-safety guarantees\n- Powered by [ACMEz](https://github.com/mholt/acmez/v3), _the_ premier ACME client library for Go\n- All [libdns](https://github.com/libdns) DNS providers work out-of-the-box\n- Pluggable storage backends (default: file system)\n- Pluggable key sources\n- Wildcard certificates\n- Automatic OCSP stapling ([done right](https://gist.github.com/sleevi/5efe9ef98961ecfb4da8#gistcomment-2336055)) [keeps your sites online!](https://twitter.com/caddyserver/status/1234874273724084226)\n\t- Will [automatically attempt](https://twitter.com/mholt6/status/1235577699541762048) to replace [revoked certificates](https://community.letsencrypt.org/t/2020-02-29-caa-rechecking-bug/114591/3?u=mholt)!\n\t- Staples stored to disk in case of responder outages\n- Distributed solving of all challenges (works behind load balancers)\n\t- Highly efficient, coordinated management in a fleet\n\t- Active locking\n\t- Smart queueing\n- Supports \"on-demand\" issuance of certificates (during TLS handshakes!)\n\t- Caddy / CertMagic pioneered this technology\n\t- Custom decision functions to regulate and throttle on-demand behavior\n- Optional event hooks for observation\n- One-time private keys by default (new key for each cert) to discourage pinning and reduce scope of key compromise\n- Works with any certificate authority (CA) compliant with the ACME specification RFC 8555\n- Certificate revocation (please, only if private key is compromised)\n- Must-Staple (optional; not default)\n- Cross-platform support! Mac, Windows, Linux, BSD, Android...\n- Scales to hundreds of thousands of names/certificates per instance\n- Use in conjunction with your own certificates\n- Full support for [draft-ietf-acme-ari](https://datatracker.ietf.org/doc/draft-ietf-acme-ari/) (ACME Renewal Information; ARI) extension\n\n\n## Requirements\n\n0. ACME server (can be a publicly-trusted CA, or your own)\n1. Public DNS name(s) you control\n2. Server reachable from public Internet\n\t- Or use the DNS challenge to waive this requirement\n3. Control over port 80 (HTTP) and/or 443 (HTTPS)\n\t- Or they can be forwarded to other ports you control\n\t- Or use the DNS challenge to waive this requirement\n\t- (This is a requirement of the ACME protocol, not a library limitation)\n4. Persistent storage\n\t- Typically the local file system (default)\n\t- Other integrations available/possible\n5. Go 1.21 or newer\n\n**_Before using this library, your domain names MUST be pointed (A/AAAA records) at your server (unless you use the DNS challenge)!_**\n\n\n## Installation\n\n```bash\n$ go get github.com/caddyserver/certmagic\n```\n\n\n## Usage\n\n### Package Overview\n\n#### Certificate authority\n\nThis library uses Let's Encrypt by default, but you can use any certificate authority that conforms to the ACME specification. Known/common CAs are provided as consts in the package, for example `LetsEncryptStagingCA` and `LetsEncryptProductionCA`.\n\n#### The `Config` type\n\nThe `certmagic.Config` struct is how you can wield the power of this fully armed and operational battle station. However, an empty/uninitialized `Config` is _not_ a valid one! In time, you will learn to use the force of `certmagic.NewDefault()` as I have.\n\n#### Defaults\n\nThe default `Config` value is called `certmagic.Default`. Change its fields to suit your needs, then call `certmagic.NewDefault()` when you need a valid `Config` value. In other words, `certmagic.Default` is a template and is not valid for use directly.\n\nYou can set the default values easily, for example: `certmagic.Default.Issuer = ...`.\n\nSimilarly, to configure ACME-specific defaults, use `certmagic.DefaultACME`.\n\nThe high-level functions in this package (`HTTPS()`, `Listen()`, `ManageSync()`, and `ManageAsync()`) use the default config exclusively. This is how most of you will interact with the package. This is suitable when all your certificates are managed the same way. However, if you need to manage certificates differently depending on their name, you will need to make your own cache and configs (keep reading).\n\n\n#### Providing an email address\n\nAlthough not strictly required, this is highly recommended best practice. It allows you to receive expiration emails if your certificates are expiring for some reason, and also allows the CA's engineers to potentially get in touch with you if something is wrong. I recommend setting `certmagic.DefaultACME.Email` or always setting the `Email` field of a new `Config` struct.\n\n\n#### Rate limiting\n\nTo avoid firehosing the CA's servers, CertMagic has built-in rate limiting. Currently, its default limit is up to 10 transactions (obtain or renew) every 1 minute (sliding window). This can be changed by setting the `RateLimitEvents` and `RateLimitEventsWindow` variables, if desired.\n\nThe CA may still enforce their own rate limits, and there's nothing (well, nothing ethical) CertMagic can do to bypass them for you.\n\nAdditionally, CertMagic will retry failed validations with exponential backoff for up to 30 days, with a reasonable maximum interval between attempts (an \"attempt\" means trying each enabled challenge type once).\n\n\n### Development and Testing\n\nNote that Let's Encrypt imposes [strict rate limits](https://letsencrypt.org/docs/rate-limits/) at its production endpoint, so using it while developing your application may lock you out for a few days if you aren't careful!\n\nWhile developing your application and testing it, use [their staging endpoint](https://letsencrypt.org/docs/staging-environment/) which has much higher rate limits. Even then, don't hammer it: but it's much safer for when you're testing. When deploying, though, use their production CA because their staging CA doesn't issue trusted certificates.\n\nTo use staging, set `certmagic.DefaultACME.CA = certmagic.LetsEncryptStagingCA` or set `CA` of every `ACMEIssuer` struct.\n\n\n\n### Examples\n\nThere are many ways to use this library. We'll start with the highest-level (simplest) and work down (more control).\n\nAll these high-level examples use `certmagic.Default` and `certmagic.DefaultACME` for the config and the default cache and storage for serving up certificates.\n\nFirst, we'll follow best practices and do the following:\n\n```go\n// read and agree to your CA's legal documents\ncertmagic.DefaultACME.Agreed = true\n\n// provide an email address\ncertmagic.DefaultACME.Email = \"you@yours.com\"\n\n// use the staging endpoint while we're developing\ncertmagic.DefaultACME.CA = certmagic.LetsEncryptStagingCA\n```\n\nFor fully-functional program examples, check out [this Twitter thread](https://twitter.com/mholt6/status/1073103805112147968) (or read it [unrolled into a single post](https://threadreaderapp.com/thread/1073103805112147968.html)). (Note that the package API has changed slightly since these posts.)\n\n\n#### Serving HTTP handlers with HTTPS\n\n```go\nerr := certmagic.HTTPS([]string{\"example.com\", \"www.example.com\"}, mux)\nif err != nil {\n\treturn err\n}\n```\n\nThis starts HTTP and HTTPS listeners and redirects HTTP to HTTPS!\n\n#### Starting a TLS listener\n\n```go\nln, err := certmagic.Listen([]string{\"example.com\"})\nif err != nil {\n\treturn err\n}\n```\n\n\n#### Getting a tls.Config\n\n```go\ntlsConfig, err := certmagic.TLS([]string{\"example.com\"})\nif err != nil {\n\treturn err\n}\n// be sure to customize NextProtos if serving a specific\n// application protocol after the TLS handshake, for example:\ntlsConfig.NextProtos = append([]string{\"h2\", \"http/1.1\"}, tlsConfig.NextProtos...)\n```\n\n\n#### Advanced use\n\nFor more control (particularly, if you need a different way of managing each certificate), you'll make and use a `Cache` and a `Config` like so:\n\n```go\n// First make a pointer to a Cache as we need to reference the same Cache in\n// GetConfigForCert below.\nvar cache *certmagic.Cache\ncache = certmagic.NewCache(certmagic.CacheOptions{\n\tGetConfigForCert: func(cert certmagic.Certificate) (*certmagic.Config, error) {\n\t\t// Here we use New to get a valid Config associated with the same cache.\n\t\t// The provided Config is used as a template and will be completed with\n\t\t// any defaults that are set in the Default config.\n\t\treturn certmagic.New(cache, certmagic.Config{\n\t\t\t// ...\n\t\t}), nil\n\t},\n\t...\n})\n\nmagic := certmagic.New(cache, certmagic.Config{\n\t// any customizations you need go here\n})\n\nmyACME := certmagic.NewACMEIssuer(magic, certmagic.ACMEIssuer{\n\tCA:     certmagic.LetsEncryptStagingCA,\n\tEmail:  \"you@yours.com\",\n\tAgreed: true,\n\t// plus any other customizations you need\n})\n\nmagic.Issuers = []certmagic.Issuer{myACME}\n\n// this obtains certificates or renews them if necessary\nerr := magic.ManageSync(context.TODO(), []string{\"example.com\", \"sub.example.com\"})\nif err != nil {\n\treturn err\n}\n\n// to use its certificates and solve the TLS-ALPN challenge,\n// you can get a TLS config to use in a TLS listener!\ntlsConfig := magic.TLSConfig()\n\n// be sure to customize NextProtos if serving a specific\n// application protocol after the TLS handshake, for example:\ntlsConfig.NextProtos = append([]string{\"h2\", \"http/1.1\"}, tlsConfig.NextProtos...)\n\n//// OR ////\n\n// if you already have a TLS config you don't want to replace,\n// we can simply set its GetCertificate field and append the\n// TLS-ALPN challenge protocol to the NextProtos\nmyTLSConfig.GetCertificate = magic.GetCertificate\nmyTLSConfig.NextProtos = append(myTLSConfig.NextProtos, acmez.ACMETLS1Protocol)\n\n// the HTTP challenge has to be handled by your HTTP server;\n// if you don't have one, you should have disabled it earlier\n// when you made the certmagic.Config\nhttpMux = myACME.HTTPChallengeHandler(httpMux)\n```\n\nGreat! This example grants you much more flexibility for advanced programs. However, _the vast majority of you will only use the high-level functions described earlier_, especially since you can still customize them by setting the package-level `Default` config.\n\n\n### Wildcard certificates\n\nAt time of writing (December 2018), Let's Encrypt only issues wildcard certificates with the DNS challenge. You can easily enable the DNS challenge with CertMagic for numerous providers (see the relevant section in the docs).\n\n\n### Behind a load balancer (or in a cluster)\n\nCertMagic runs effectively behind load balancers and/or in cluster/fleet environments. In other words, you can have 10 or 1,000 servers all serving the same domain names, all sharing certificates and OCSP staples.\n\nTo do so, simply ensure that each instance is using the same Storage. That is the sole criteria for determining whether an instance is part of a cluster.\n\nThe default Storage is implemented using the file system, so mounting the same shared folder is sufficient (see [Storage](#storage) for more on that)! If you need an alternate Storage implementation, feel free to use one, provided that all the instances use the _same_ one. :)\n\nSee [Storage](#storage) and the associated [pkg.go.dev](https://pkg.go.dev/github.com/caddyserver/certmagic?tab=doc#Storage) for more information!\n\n\n## The ACME Challenges\n\nThis section describes how to solve the ACME challenges. Challenges are how you demonstrate to the certificate authority some control over your domain name, thus authorizing them to grant you a certificate for that name. [The great innovation of ACME](https://www.dotconferences.com/2016/10/matthew-holt-go-with-acme) is that verification by CAs can now be automated, rather than having to click links in emails (who ever thought that was a good idea??).\n\nIf you're using the high-level convenience functions like `HTTPS()`, `Listen()`, or `TLS()`, the HTTP and/or TLS-ALPN challenges are solved for you because they also start listeners. However, if you're making a `Config` and you start your own server manually, you'll need to be sure the ACME challenges can be solved so certificates can be renewed.\n\nThe HTTP and TLS-ALPN challenges are the defaults because they don't require configuration from you, but they require that your server is accessible from external IPs on low ports. If that is not possible in your situation, you can enable the DNS challenge, which will disable the HTTP and TLS-ALPN challenges and use the DNS challenge exclusively.\n\nTechnically, only one challenge needs to be enabled for things to work, but using multiple is good for reliability in case a challenge is discontinued by the CA. This happened to the TLS-SNI challenge in early 2018&mdash;many popular ACME clients such as Traefik and Autocert broke, resulting in downtime for some sites, until new releases were made and patches deployed, because they used only one challenge; Caddy, however&mdash;this library's forerunner&mdash;was unaffected because it also used the HTTP challenge. If multiple challenges are enabled, they are chosen randomly to help prevent false reliance on a single challenge type. And if one fails, any remaining enabled challenges are tried before giving up.\n\n\n### HTTP Challenge\n\nPer the ACME spec, the HTTP challenge requires port 80, or at least packet forwarding from port 80. It works by serving a specific HTTP response that only the genuine server would have to a normal HTTP request at a special endpoint.\n\nIf you are running an HTTP server, solving this challenge is very easy: just wrap your handler in `HTTPChallengeHandler` _or_ call `SolveHTTPChallenge()` inside your own `ServeHTTP()` method.\n\nFor example, if you're using the standard library:\n\n```go\nmux := http.NewServeMux()\nmux.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\tfmt.Fprintf(w, \"Lookit my cool website over HTTPS!\")\n})\n\nhttp.ListenAndServe(\":80\", myACME.HTTPChallengeHandler(mux))\n```\n\nIf wrapping your handler is not a good solution, try this inside your `ServeHTTP()` instead:\n\n```go\nmagic := certmagic.NewDefault()\nmyACME := certmagic.NewACMEIssuer(magic, certmagic.DefaultACME)\n\nfunc ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tif myACME.HandleHTTPChallenge(w, r) {\n\t\treturn // challenge handled; nothing else to do\n\t}\n\t...\n}\n```\n\nIf you are not running an HTTP server, you should disable the HTTP challenge _or_ run an HTTP server whose sole job it is to solve the HTTP challenge.\n\n\n### TLS-ALPN Challenge\n\nPer the ACME spec, the TLS-ALPN challenge requires port 443, or at least packet forwarding from port 443. It works by providing a special certificate using a standard TLS extension, Application Layer Protocol Negotiation (ALPN), having a special value. This is the most convenient challenge type because it usually requires no extra configuration and uses the standard TLS port which is where the certificates are used, also.\n\nThis challenge is easy to solve: just use the provided `tls.Config` when you make your TLS listener:\n\n```go\n// use this to configure a TLS listener\ntlsConfig := magic.TLSConfig()\n```\n\nOr make two simple changes to an existing `tls.Config`:\n\n```go\nmyTLSConfig.GetCertificate = magic.GetCertificate\nmyTLSConfig.NextProtos = append(myTLSConfig.NextProtos, acmez.ACMETLS1Protocol}\n```\n\nThen just make sure your TLS listener is listening on port 443:\n\n```go\nln, err := tls.Listen(\"tcp\", \":443\", myTLSConfig)\n```\n\n\n### DNS Challenge\n\nThe DNS challenge is perhaps the most useful challenge because it allows you to obtain certificates without your server needing to be publicly accessible on the Internet, and it's the only challenge by which Let's Encrypt will issue wildcard certificates.\n\nThis challenge works by setting a special record in the domain's zone. To do this automatically, your DNS provider needs to offer an API by which changes can be made to domain names, and the changes need to take effect immediately for best results. CertMagic supports [all DNS providers with `libdns` implementations](https://github.com/libdns)! It always cleans up the temporary record after the challenge completes.\n\nTo enable it, just set the `DNS01Solver` field on a `certmagic.ACMEIssuer` struct, or set the default `certmagic.ACMEIssuer.DNS01Solver` variable. For example, if my domains' DNS was served by Cloudflare:\n\n```go\nimport \"github.com/libdns/cloudflare\"\n\ncertmagic.DefaultACME.DNS01Solver = &certmagic.DNS01Solver{\n\tDNSManager: certmagic.DNSManager{\n\t\tDNSProvider: &cloudflare.Provider{\n\t\t\tAPIToken: \"topsecret\",\n\t\t},\n\t},\n}\n```\n\nNow the DNS challenge will be used by default, and I can obtain certificates for wildcard domains, too. Enabling the DNS challenge disables the other challenges for that `certmagic.ACMEIssuer` instance.\n\n\n## On-Demand TLS\n\nNormally, certificates are obtained and renewed before a listener starts serving, and then those certificates are maintained throughout the lifetime of the program. In other words, the certificate names are static. But sometimes you don't know all the names ahead of time, or you don't want to manage all the certificates up front. This is where On-Demand TLS shines.\n\nOriginally invented for use in Caddy (which was the first program to use such technology), On-Demand TLS makes it possible and easy to serve certificates for arbitrary or specific names during the lifetime of the server. When a TLS handshake is received, CertMagic will read the Server Name Indication (SNI) value and either load and present that certificate in the ServerHello, or if one does not exist, it will obtain it from a CA right then-and-there.\n\nOf course, this has some obvious security implications. You don't want to DoS a CA or allow arbitrary clients to fill your storage with spammy TLS handshakes. That's why, when you enable On-Demand issuance, you should set limits or policy to allow getting certificates. CertMagic has an implicit whitelist built-in which is sufficient for nearly everyone, but also has a more advanced way to control on-demand issuance.\n\nThe simplest way to enable on-demand issuance is to set the OnDemand field of a Config (or the default package-level value):\n\n```go\ncertmagic.Default.OnDemand = new(certmagic.OnDemandConfig)\n```\n\nBy setting this to a non-nil value, on-demand TLS is enabled for that config. For convenient security, CertMagic's high-level abstraction functions such as `HTTPS()`, `TLS()`, `ManageSync()`, `ManageAsync()`, and `Listen()` (which all accept a list of domain names) will whitelist those names automatically so only certificates for those names can be obtained when using the Default config. Usually this is sufficient for most users.\n\nHowever, if you require advanced control over which domains can be issued certificates on-demand (for example, if you do not know which domain names you are managing, or just need to defer their operations until later), you should implement your own DecisionFunc:\n\n```go\n// if the decision function returns an error, a certificate\n// may not be obtained for that name at that time\ncertmagic.Default.OnDemand = &certmagic.OnDemandConfig{\n\tDecisionFunc: func(name string) error {\n\t\tif name != \"example.com\" {\n\t\t\treturn fmt.Errorf(\"not allowed\")\n\t\t}\n\t\treturn nil\n\t},\n}\n```\n\nThe [pkg.go.dev](https://pkg.go.dev/github.com/caddyserver/certmagic?tab=doc#OnDemandConfig) describes how to use this in full detail, so please check it out!\n\n\n## Storage\n\nCertMagic relies on storage to store certificates and other TLS assets (OCSP staple cache, coordinating locks, etc). Persistent storage is a requirement when using CertMagic: ephemeral storage will likely lead to rate limiting on the CA-side as CertMagic will always have to get new certificates.\n\nBy default, CertMagic stores assets on the local file system in `$HOME/.local/share/certmagic` (and honors `$XDG_DATA_HOME` if set). CertMagic will create the directory if it does not exist. If writes are denied, things will not be happy, so make sure CertMagic can write to it!\n\nThe notion of a \"cluster\" or \"fleet\" of instances that may be serving the same site and sharing certificates, etc, is tied to storage. Simply, any instances that use the same storage facilities are considered part of the cluster. So if you deploy 100 instances of CertMagic behind a load balancer, they are all part of the same cluster if they share the same storage configuration. Sharing storage could be mounting a shared folder, or implementing some other distributed storage system such as a database server or KV store.\n\nThe easiest way to change the storage being used is to set `certmagic.Default.Storage` to a value that satisfies the [Storage interface](https://pkg.go.dev/github.com/caddyserver/certmagic?tab=doc#Storage). Keep in mind that a valid `Storage` must be able to implement some operations atomically in order to provide locking and synchronization.\n\nIf you write a Storage implementation, please add it to the [project wiki](https://github.com/caddyserver/certmagic/wiki/Storage-Implementations) so people can find it!\n\n\n## Cache\n\nAll of the certificates in use are de-duplicated and cached in memory for optimal performance at handshake-time. This cache must be backed by persistent storage as described above.\n\nMost applications will not need to interact with certificate caches directly. Usually, the closest you will come is to set the package-wide `certmagic.Default.Storage` variable (before attempting to create any Configs) which defines how the cache is persisted. However, if your use case requires using different storage facilities for different Configs (that's highly unlikely and NOT recommended! Even Caddy doesn't get that crazy), you will need to call `certmagic.NewCache()` and pass in the storage you want to use, then get new `Config` structs with `certmagic.NewWithCache()` and pass in the cache.\n\nAgain, if you're needing to do this, you've probably over-complicated your application design.\n\n## Events\n\n(Events are new and still experimental, so they may change.)\n\nCertMagic emits events when possible things of interest happen. Set the [`OnEvent` field of your `Config`](https://pkg.go.dev/github.com/caddyserver/certmagic#Config.OnEvent) to subscribe to events; ignore the ones you aren't interested in. Here are the events currently emitted along with their metadata you can use:\n\n- **`cached_unmanaged_cert`** An unmanaged certificate was cached\n\t- `sans`: The subject names on the certificate\n- **`cert_obtaining`** A certificate is about to be obtained\n\t- `renewal`: Whether this is a renewal\n\t- `identifier`: The name on the certificate\n\t- `forced`: Whether renewal is being forced (if renewal)\n\t- `remaining`: Time left on the certificate (if renewal)\n\t- `issuer`: The previous or current issuer\n- **`cert_obtained`** A certificate was successfully obtained\n\t- `renewal`: Whether this is a renewal\n\t- `identifier`: The name on the certificate\n\t- `remaining`: Time left on the certificate (if renewal)\n\t- `issuer`: The previous or current issuer\n\t- `storage_path`: The path to the folder containing the cert resources within storage\n\t- `private_key_path`: The path to the private key file in storage\n\t- `certificate_path`: The path to the public key file in storage\n\t- `metadata_path`: The path to the metadata file in storage\n- **`cert_failed`** An attempt to obtain a certificate failed\n\t- `renewal`: Whether this is a renewal\n\t- `identifier`: The name on the certificate\n\t- `remaining`: Time left on the certificate (if renewal)\n\t- `issuers`: The issuer(s) tried\n\t- `error`: The (final) error message\n- **`tls_get_certificate`** The GetCertificate phase of a TLS handshake is under way\n\t- `client_hello`: The tls.ClientHelloInfo struct\n- **`cert_ocsp_revoked`** A certificate's OCSP indicates it has been revoked\n\t- `subjects`: The subject names on the certificate\n\t- `certificate`: The Certificate struct\n\t- `reason`: The OCSP revocation reason\n\t- `revoked_at`: When the certificate was revoked\n\n`OnEvent` can return an error. Some events may be aborted by returning an error. For example, returning an error from `cert_obtained` can cancel obtaining the certificate. Only return an error from `OnEvent` if you want to abort program flow.\n\n## ZeroSSL\n\nZeroSSL has both ACME and HTTP API services for getting certificates. CertMagic works with both of them.\n\nTo use ZeroSSL's ACME server, configure CertMagic with an [`ACMEIssuer`](https://pkg.go.dev/github.com/caddyserver/certmagic#ACMEIssuer) like you would with any other ACME CA (just adjust the directory URL). External Account Binding (EAB) is required for ZeroSSL. You can use the [ZeroSSL API](https://pkg.go.dev/github.com/caddyserver/zerossl) to generate one, or your account dashboard.\n\nTo use ZeroSSL's API instead, use the [`ZeroSSLIssuer`](https://pkg.go.dev/github.com/caddyserver/certmagic#ZeroSSLIssuer). Here is a simple example:\n\n```go\nmagic := certmagic.NewDefault()\n\nmagic.Issuers = []certmagic.Issuer{\n\tcertmagic.ZeroSSLIssuer{\n\t\tAPIKey: \"<your ZeroSSL API key>\",\n\t}),\n}\n\nerr := magic.ManageSync(ctx, []string{\"example.com\"})\n```\n\n## FAQ\n\n### Can I use some of my own certificates while using CertMagic?\n\nYes, just call the relevant method on the `Config` to add your own certificate to the cache:\n\n- [`CacheUnmanagedCertificatePEMBytes()`](https://pkg.go.dev/github.com/caddyserver/certmagic?tab=doc#Config.CacheUnmanagedCertificatePEMBytes)\n- [`CacheUnmanagedCertificatePEMFile()`](https://pkg.go.dev/github.com/caddyserver/certmagic?tab=doc#Config.CacheUnmanagedCertificatePEMFile)\n- [`CacheUnmanagedTLSCertificate()`](https://pkg.go.dev/github.com/caddyserver/certmagic?tab=doc#Config.CacheUnmanagedTLSCertificate)\n\nKeep in mind that unmanaged certificates are (obviously) not renewed for you, so you'll have to replace them when you do. However, OCSP stapling is performed even for unmanaged certificates that qualify.\n\n\n### Does CertMagic obtain SAN certificates?\n\nTechnically all certificates these days are SAN certificates because CommonName is deprecated. But if you're asking whether CertMagic issues and manages certificates with multiple SANs, the answer is no. But it does support serving them, if you provide your own.\n\n\n### How can I listen on ports 80 and 443? Do I have to run as root?\n\nOn Linux, you can use `setcap` to grant your binary the permission to bind low ports:\n\n```bash\n$ sudo setcap cap_net_bind_service=+ep /path/to/your/binary\n```\n\nand then you will not need to run with root privileges.\n\n\n## Contributing\n\nWe welcome your contributions! Please see our **[contributing guidelines](https://github.com/caddyserver/certmagic/blob/master/.github/CONTRIBUTING.md)** for instructions.\n\n\n## Project History\n\nCertMagic is the core of Caddy's advanced TLS automation code, extracted into a library. The underlying ACME client implementation is [ACMEz](https://github.com/mholt/acmez/v3). CertMagic's code was originally a central part of Caddy even before Let's Encrypt entered public beta in 2015.\n\nIn the years since then, Caddy's TLS automation techniques have been widely adopted, tried and tested in production, and served millions of sites and secured trillions of connections.\n\nNow, CertMagic is _the actual library used by Caddy_. It's incredibly powerful and feature-rich, but also easy to use for simple Go programs: one line of code can enable fully-automated HTTPS applications with HTTP->HTTPS redirects.\n\nCaddy is known for its robust HTTPS+ACME features. When ACME certificate authorities have had outages, in some cases Caddy was the only major client that didn't experience any downtime. Caddy can weather OCSP outages lasting days, or CA outages lasting weeks, without taking your sites offline.\n\nCaddy was also the first to sport \"on-demand\" issuance technology, which obtains certificates during the first TLS handshake for an allowed SNI name.\n\nConsequently, CertMagic brings all these (and more) features and capabilities right into your own Go programs.\n\nYou can [watch a 2016 dotGo talk](https://youtu.be/KdX51QJWQTA) by the author of this library about using ACME to automate certificate management in Go programs:\n\n[![Matthew Holt speaking at dotGo 2016 about ACME in Go](https://user-images.githubusercontent.com/1128849/49921557-2d506780-fe6b-11e8-97bf-6053b6b4eb48.png)](https://youtu.be/KdX51QJWQTA)\n\n\n\n## Credits and License\n\nCertMagic is a project by [Matthew Holt](https://twitter.com/mholt6), who is the author; and various contributors, who are credited in the commit history of either CertMagic or Caddy.\n\nCertMagic is licensed under Apache 2.0, an open source license. For convenience, its main points are summarized as follows (but this is no replacement for the actual license text):\n\n- The author owns the copyright to this code\n- Use, distribute, and modify the software freely\n- Private and internal use is allowed\n- License text and copyright notices must stay intact and be included with distributions\n- Any and all changes to the code must be documented\n"
        },
        {
          "name": "account.go",
          "type": "blob",
          "size": 14.9189453125,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"os\"\n\t\"path\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/mholt/acmez/v3/acme\"\n\t\"go.uber.org/zap\"\n)\n\n// getAccount either loads or creates a new account, depending on if\n// an account can be found in storage for the given CA + email combo.\nfunc (am *ACMEIssuer) getAccount(ctx context.Context, ca, email string) (acme.Account, error) {\n\tacct, err := am.loadAccount(ctx, ca, email)\n\tif errors.Is(err, fs.ErrNotExist) {\n\t\tam.Logger.Info(\"creating new account because no account for configured email is known to us\",\n\t\t\tzap.String(\"email\", email),\n\t\t\tzap.String(\"ca\", ca),\n\t\t\tzap.Error(err))\n\t\treturn am.newAccount(email)\n\t}\n\tam.Logger.Debug(\"using existing ACME account because key found in storage associated with email\",\n\t\tzap.String(\"email\", email),\n\t\tzap.String(\"ca\", ca))\n\treturn acct, err\n}\n\n// loadAccount loads an account from storage, but does not create a new one.\nfunc (am *ACMEIssuer) loadAccount(ctx context.Context, ca, email string) (acme.Account, error) {\n\tregBytes, err := am.config.Storage.Load(ctx, am.storageKeyUserReg(ca, email))\n\tif err != nil {\n\t\treturn acme.Account{}, err\n\t}\n\tkeyBytes, err := am.config.Storage.Load(ctx, am.storageKeyUserPrivateKey(ca, email))\n\tif err != nil {\n\t\treturn acme.Account{}, err\n\t}\n\n\tvar acct acme.Account\n\terr = json.Unmarshal(regBytes, &acct)\n\tif err != nil {\n\t\treturn acct, err\n\t}\n\tacct.PrivateKey, err = PEMDecodePrivateKey(keyBytes)\n\tif err != nil {\n\t\treturn acct, fmt.Errorf(\"could not decode account's private key: %v\", err)\n\t}\n\n\treturn acct, nil\n}\n\n// newAccount generates a new private key for a new ACME account, but\n// it does not register or save the account.\nfunc (*ACMEIssuer) newAccount(email string) (acme.Account, error) {\n\tvar acct acme.Account\n\tif email != \"\" {\n\t\tacct.Contact = []string{\"mailto:\" + email} // TODO: should we abstract the contact scheme?\n\t}\n\tprivateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\treturn acct, fmt.Errorf(\"generating private key: %v\", err)\n\t}\n\tacct.PrivateKey = privateKey\n\treturn acct, nil\n}\n\n// GetAccount first tries loading the account with the associated private key from storage.\n// If it does not exist in storage, it will be retrieved from the ACME server and added to storage.\n// The account must already exist; it does not create a new account.\nfunc (am *ACMEIssuer) GetAccount(ctx context.Context, privateKeyPEM []byte) (acme.Account, error) {\n\temail := am.getEmail()\n\tif email == \"\" {\n\t\tif account, err := am.loadAccountByKey(ctx, privateKeyPEM); err == nil {\n\t\t\treturn account, nil\n\t\t}\n\t} else {\n\t\tkeyBytes, err := am.config.Storage.Load(ctx, am.storageKeyUserPrivateKey(am.CA, email))\n\t\tif err == nil && bytes.Equal(bytes.TrimSpace(keyBytes), bytes.TrimSpace(privateKeyPEM)) {\n\t\t\treturn am.loadAccount(ctx, am.CA, email)\n\t\t}\n\t}\n\treturn am.lookUpAccount(ctx, privateKeyPEM)\n}\n\n// loadAccountByKey loads the account with the given private key from storage, if it exists.\n// If it does not exist, an error of type fs.ErrNotExist is returned. This is not very efficient\n// for lots of accounts.\nfunc (am *ACMEIssuer) loadAccountByKey(ctx context.Context, privateKeyPEM []byte) (acme.Account, error) {\n\taccountList, err := am.config.Storage.List(ctx, am.storageKeyUsersPrefix(am.CA), false)\n\tif err != nil {\n\t\treturn acme.Account{}, err\n\t}\n\tfor _, accountFolderKey := range accountList {\n\t\temail := path.Base(accountFolderKey)\n\t\tkeyBytes, err := am.config.Storage.Load(ctx, am.storageKeyUserPrivateKey(am.CA, email))\n\t\tif err != nil {\n\t\t\t// Try the next account: This one is missing its private key, if it turns out to be the one we're looking\n\t\t\t// for we will try to save it again after confirming with the ACME server.\n\t\t\tcontinue\n\t\t}\n\t\tif bytes.Equal(bytes.TrimSpace(keyBytes), bytes.TrimSpace(privateKeyPEM)) {\n\t\t\t// Found the account with the correct private key, try loading it. If this fails we we will follow\n\t\t\t// the same procedure as if the private key was not found and confirm with the ACME server before saving\n\t\t\t// it again.\n\t\t\treturn am.loadAccount(ctx, am.CA, email)\n\t\t}\n\t}\n\treturn acme.Account{}, fs.ErrNotExist\n}\n\n// lookUpAccount looks up the account associated with privateKeyPEM from the ACME server.\n// If the account is found by the server, it will be saved to storage and returned.\nfunc (am *ACMEIssuer) lookUpAccount(ctx context.Context, privateKeyPEM []byte) (acme.Account, error) {\n\tclient, err := am.newACMEClient(false)\n\tif err != nil {\n\t\treturn acme.Account{}, fmt.Errorf(\"creating ACME client: %v\", err)\n\t}\n\n\tprivateKey, err := PEMDecodePrivateKey([]byte(privateKeyPEM))\n\tif err != nil {\n\t\treturn acme.Account{}, fmt.Errorf(\"decoding private key: %v\", err)\n\t}\n\n\t// look up the account\n\taccount := acme.Account{PrivateKey: privateKey}\n\taccount, err = client.GetAccount(ctx, account)\n\tif err != nil {\n\t\treturn acme.Account{}, fmt.Errorf(\"looking up account with server: %v\", err)\n\t}\n\n\t// save the account details to storage\n\terr = am.saveAccount(ctx, client.Directory, account)\n\tif err != nil {\n\t\treturn account, fmt.Errorf(\"could not save account to storage: %v\", err)\n\t}\n\n\treturn account, nil\n}\n\n// saveAccount persists an ACME account's info and private key to storage.\n// It does NOT register the account via ACME or prompt the user.\nfunc (am *ACMEIssuer) saveAccount(ctx context.Context, ca string, account acme.Account) error {\n\tregBytes, err := json.MarshalIndent(account, \"\", \"\\t\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tkeyBytes, err := PEMEncodePrivateKey(account.PrivateKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// extract primary contact (email), without scheme (e.g. \"mailto:\")\n\tprimaryContact := getPrimaryContact(account)\n\tall := []keyValue{\n\t\t{\n\t\t\tkey:   am.storageKeyUserReg(ca, primaryContact),\n\t\t\tvalue: regBytes,\n\t\t},\n\t\t{\n\t\t\tkey:   am.storageKeyUserPrivateKey(ca, primaryContact),\n\t\t\tvalue: keyBytes,\n\t\t},\n\t}\n\treturn storeTx(ctx, am.config.Storage, all)\n}\n\n// deleteAccountLocally deletes the registration info and private key of the account\n// for the given CA from storage.\nfunc (am *ACMEIssuer) deleteAccountLocally(ctx context.Context, ca string, account acme.Account) error {\n\tprimaryContact := getPrimaryContact(account)\n\tif err := am.config.Storage.Delete(ctx, am.storageKeyUserReg(ca, primaryContact)); err != nil {\n\t\treturn err\n\t}\n\treturn am.config.Storage.Delete(ctx, am.storageKeyUserPrivateKey(ca, primaryContact))\n}\n\n// setEmail does everything it can to obtain an email address\n// from the user within the scope of memory and storage to use\n// for ACME TLS. If it cannot get an email address, it does nothing\n// (If user is prompted, it will warn the user of\n// the consequences of an empty email.) This function MAY prompt\n// the user for input. If allowPrompts is false, the user\n// will NOT be prompted and an empty email may be returned.\nfunc (am *ACMEIssuer) setEmail(ctx context.Context, allowPrompts bool) error {\n\tleEmail := am.Email\n\n\t// First try package default email, or a discovered email address\n\tif leEmail == \"\" {\n\t\tleEmail = DefaultACME.Email\n\t}\n\tif leEmail == \"\" {\n\t\tdiscoveredEmailMu.Lock()\n\t\tleEmail = discoveredEmail\n\t\tdiscoveredEmailMu.Unlock()\n\t}\n\n\t// Then try to get most recent user email from storage\n\tvar gotRecentEmail bool\n\tif leEmail == \"\" {\n\t\tleEmail, gotRecentEmail = am.mostRecentAccountEmail(ctx, am.CA)\n\t}\n\tif !gotRecentEmail && leEmail == \"\" && allowPrompts {\n\t\t// Looks like there is no email address readily available,\n\t\t// so we will have to ask the user if we can.\n\t\tvar err error\n\t\tleEmail, err = am.promptUserForEmail()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// User might have just signified their agreement\n\t\tam.mu.Lock()\n\t\tam.agreed = DefaultACME.Agreed\n\t\tam.mu.Unlock()\n\t}\n\n\t// Save the email for later and ensure it is consistent\n\t// for repeated use; then update cfg with the email\n\tleEmail = strings.TrimSpace(strings.ToLower(leEmail))\n\tdiscoveredEmailMu.Lock()\n\tif discoveredEmail == \"\" {\n\t\tdiscoveredEmail = leEmail\n\t}\n\tdiscoveredEmailMu.Unlock()\n\n\t// The unexported email field is the one we use\n\t// because we have thread-safe control over it\n\tam.mu.Lock()\n\tam.email = leEmail\n\tam.mu.Unlock()\n\n\treturn nil\n}\n\n// promptUserForEmail prompts the user for an email address\n// and returns the email address they entered (which could\n// be the empty string). If no error is returned, then Agreed\n// will also be set to true, since continuing through the\n// prompt signifies agreement.\nfunc (am *ACMEIssuer) promptUserForEmail() (string, error) {\n\t// prompt the user for an email address and terms agreement\n\treader := bufio.NewReader(stdin)\n\tam.promptUserAgreement(\"\")\n\tfmt.Println(\"Please enter your email address to signify agreement and to be notified\")\n\tfmt.Println(\"in case of issues. You can leave it blank, but we don't recommend it.\")\n\tfmt.Print(\"  Email address: \")\n\tleEmail, err := reader.ReadString('\\n')\n\tif err != nil && err != io.EOF {\n\t\treturn \"\", fmt.Errorf(\"reading email address: %v\", err)\n\t}\n\tleEmail = strings.TrimSpace(leEmail)\n\tDefaultACME.Agreed = true\n\treturn leEmail, nil\n}\n\n// promptUserAgreement simply outputs the standard user\n// agreement prompt with the given agreement URL.\n// It outputs a newline after the message.\nfunc (am *ACMEIssuer) promptUserAgreement(agreementURL string) {\n\tuserAgreementPrompt := `Your sites will be served over HTTPS automatically using an automated CA.\nBy continuing, you agree to the CA's terms of service`\n\tif agreementURL == \"\" {\n\t\tfmt.Printf(\"\\n\\n%s.\\n\", userAgreementPrompt)\n\t\treturn\n\t}\n\tfmt.Printf(\"\\n\\n%s at:\\n  %s\\n\", userAgreementPrompt, agreementURL)\n}\n\n// askUserAgreement prompts the user to agree to the agreement\n// at the given agreement URL via stdin. It returns whether the\n// user agreed or not.\nfunc (am *ACMEIssuer) askUserAgreement(agreementURL string) bool {\n\tam.promptUserAgreement(agreementURL)\n\tfmt.Print(\"Do you agree to the terms? (y/n): \")\n\n\treader := bufio.NewReader(stdin)\n\tanswer, err := reader.ReadString('\\n')\n\tif err != nil {\n\t\treturn false\n\t}\n\tanswer = strings.ToLower(strings.TrimSpace(answer))\n\n\treturn answer == \"y\" || answer == \"yes\"\n}\n\nfunc storageKeyACMECAPrefix(issuerKey string) string {\n\treturn path.Join(prefixACME, StorageKeys.Safe(issuerKey))\n}\n\nfunc (am *ACMEIssuer) storageKeyCAPrefix(caURL string) string {\n\treturn storageKeyACMECAPrefix(am.issuerKey(caURL))\n}\n\nfunc (am *ACMEIssuer) storageKeyUsersPrefix(caURL string) string {\n\treturn path.Join(am.storageKeyCAPrefix(caURL), \"users\")\n}\n\nfunc (am *ACMEIssuer) storageKeyUserPrefix(caURL, email string) string {\n\tif email == \"\" {\n\t\temail = emptyEmail\n\t}\n\treturn path.Join(am.storageKeyUsersPrefix(caURL), StorageKeys.Safe(email))\n}\n\nfunc (am *ACMEIssuer) storageKeyUserReg(caURL, email string) string {\n\treturn am.storageSafeUserKey(caURL, email, \"registration\", \".json\")\n}\n\nfunc (am *ACMEIssuer) storageKeyUserPrivateKey(caURL, email string) string {\n\treturn am.storageSafeUserKey(caURL, email, \"private\", \".key\")\n}\n\n// storageSafeUserKey returns a key for the given email, with the default\n// filename, and the filename ending in the given extension.\nfunc (am *ACMEIssuer) storageSafeUserKey(ca, email, defaultFilename, extension string) string {\n\tif email == \"\" {\n\t\temail = emptyEmail\n\t}\n\temail = strings.ToLower(email)\n\tfilename := am.emailUsername(email)\n\tif filename == \"\" {\n\t\tfilename = defaultFilename\n\t}\n\tfilename = StorageKeys.Safe(filename)\n\treturn path.Join(am.storageKeyUserPrefix(ca, email), filename+extension)\n}\n\n// emailUsername returns the username portion of an email address (part before\n// '@') or the original input if it can't find the \"@\" symbol.\nfunc (*ACMEIssuer) emailUsername(email string) string {\n\tat := strings.Index(email, \"@\")\n\tif at == -1 {\n\t\treturn email\n\t} else if at == 0 {\n\t\treturn email[1:]\n\t}\n\treturn email[:at]\n}\n\n// mostRecentAccountEmail finds the most recently-written account file\n// in storage. Since this is part of a complex sequence to get a user\n// account, errors here are discarded to simplify code flow in\n// the caller, and errors are not important here anyway.\nfunc (am *ACMEIssuer) mostRecentAccountEmail(ctx context.Context, caURL string) (string, bool) {\n\taccountList, err := am.config.Storage.List(ctx, am.storageKeyUsersPrefix(caURL), false)\n\tif err != nil || len(accountList) == 0 {\n\t\treturn \"\", false\n\t}\n\n\t// get all the key infos ahead of sorting, because\n\t// we might filter some out\n\tstats := make(map[string]KeyInfo)\n\tfor i := 0; i < len(accountList); i++ {\n\t\tu := accountList[i]\n\t\tkeyInfo, err := am.config.Storage.Stat(ctx, u)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif keyInfo.IsTerminal {\n\t\t\t// I found a bug when macOS created a .DS_Store file in\n\t\t\t// the users folder, and CertMagic tried to use that as\n\t\t\t// the user email because it was newer than the other one\n\t\t\t// which existed... sure, this isn't a perfect fix but\n\t\t\t// frankly one's OS shouldn't mess with the data folder\n\t\t\t// in the first place.\n\t\t\taccountList = append(accountList[:i], accountList[i+1:]...)\n\t\t\ti--\n\t\t\tcontinue\n\t\t}\n\t\tstats[u] = keyInfo\n\t}\n\n\tsort.Slice(accountList, func(i, j int) bool {\n\t\tiInfo := stats[accountList[i]]\n\t\tjInfo := stats[accountList[j]]\n\t\treturn jInfo.Modified.Before(iInfo.Modified)\n\t})\n\n\tif len(accountList) == 0 {\n\t\treturn \"\", false\n\t}\n\n\taccount, err := am.getAccount(ctx, caURL, path.Base(accountList[0]))\n\tif err != nil {\n\t\treturn \"\", false\n\t}\n\n\treturn getPrimaryContact(account), true\n}\n\nfunc accountRegLockKey(acc acme.Account) string {\n\tkey := \"register_acme_account\"\n\tif len(acc.Contact) == 0 {\n\t\treturn key\n\t}\n\tkey += \"_\" + getPrimaryContact(acc)\n\treturn key\n}\n\n// getPrimaryContact returns the first contact on the account (if any)\n// without the scheme. (I guess we assume an email address.)\nfunc getPrimaryContact(account acme.Account) string {\n\t// TODO: should this be abstracted with some lower-level helper?\n\tvar primaryContact string\n\tif len(account.Contact) > 0 {\n\t\tprimaryContact = account.Contact[0]\n\t\tif idx := strings.Index(primaryContact, \":\"); idx >= 0 {\n\t\t\tprimaryContact = primaryContact[idx+1:]\n\t\t}\n\t}\n\treturn primaryContact\n}\n\n// When an email address is not explicitly specified, we can remember\n// the last one we discovered to avoid having to ask again later.\n// (We used to store this in DefaultACME.Email but it was racey; see #127)\nvar (\n\tdiscoveredEmail   string\n\tdiscoveredEmailMu sync.Mutex\n)\n\n// stdin is used to read the user's input if prompted;\n// this is changed by tests during tests.\nvar stdin = io.ReadWriter(os.Stdin)\n\n// The name of the folder for accounts where the email\n// address was not provided; default 'username' if you will,\n// but only for local/storage use, not with the CA.\nconst emptyEmail = \"default\"\n"
        },
        {
          "name": "account_test.go",
          "type": "blob",
          "size": 14.2744140625,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"io/fs\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"go.uber.org/zap\"\n)\n\n// memoryStorage is an in-memory storage implementation with known contents *and* fixed iteration order for List.\ntype memoryStorage struct {\n\tcontents []memoryStorageItem\n}\n\ntype memoryStorageItem struct {\n\tkey  string\n\tdata []byte\n}\n\nfunc (m *memoryStorage) lookup(_ context.Context, key string) *memoryStorageItem {\n\tfor _, item := range m.contents {\n\t\tif item.key == key {\n\t\t\treturn &item\n\t\t}\n\t}\n\treturn nil\n}\nfunc (m *memoryStorage) Delete(ctx context.Context, key string) error {\n\tfor i, item := range m.contents {\n\t\tif item.key == key {\n\t\t\tm.contents = append(m.contents[:i], m.contents[i+1:]...)\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn fs.ErrNotExist\n}\nfunc (m *memoryStorage) Store(ctx context.Context, key string, value []byte) error {\n\tm.contents = append(m.contents, memoryStorageItem{key: key, data: value})\n\treturn nil\n}\nfunc (m *memoryStorage) Exists(ctx context.Context, key string) bool {\n\treturn m.lookup(ctx, key) != nil\n}\nfunc (m *memoryStorage) List(ctx context.Context, path string, recursive bool) ([]string, error) {\n\tif recursive {\n\t\tpanic(\"unimplemented\")\n\t}\n\n\tresult := []string{}\nnextitem:\n\tfor _, item := range m.contents {\n\t\tif !strings.HasPrefix(item.key, path+\"/\") {\n\t\t\tcontinue\n\t\t}\n\t\tname := strings.TrimPrefix(item.key, path+\"/\")\n\t\tif i := strings.Index(name, \"/\"); i >= 0 {\n\t\t\tname = name[:i]\n\t\t}\n\n\t\tfor _, existing := range result {\n\t\t\tif existing == name {\n\t\t\t\tcontinue nextitem\n\t\t\t}\n\t\t}\n\t\tresult = append(result, name)\n\t}\n\treturn result, nil\n}\nfunc (m *memoryStorage) Load(ctx context.Context, key string) ([]byte, error) {\n\tif item := m.lookup(ctx, key); item != nil {\n\t\treturn item.data, nil\n\t}\n\treturn nil, fs.ErrNotExist\n}\nfunc (m *memoryStorage) Stat(ctx context.Context, key string) (KeyInfo, error) {\n\tif item := m.lookup(ctx, key); item != nil {\n\t\treturn KeyInfo{Key: key, Size: int64(len(item.data))}, nil\n\t}\n\treturn KeyInfo{}, fs.ErrNotExist\n}\nfunc (m *memoryStorage) Lock(ctx context.Context, name string) error   { panic(\"unimplemented\") }\nfunc (m *memoryStorage) Unlock(ctx context.Context, name string) error { panic(\"unimplemented\") }\n\nvar _ Storage = (*memoryStorage)(nil)\n\ntype recordingStorage struct {\n\tStorage\n\tcalls []recordedCall\n}\n\nfunc (r *recordingStorage) Delete(ctx context.Context, key string) error {\n\tr.record(\"Delete\", key)\n\treturn r.Storage.Delete(ctx, key)\n}\nfunc (r *recordingStorage) Exists(ctx context.Context, key string) bool {\n\tr.record(\"Exists\", key)\n\treturn r.Storage.Exists(ctx, key)\n}\nfunc (r *recordingStorage) List(ctx context.Context, path string, recursive bool) ([]string, error) {\n\tr.record(\"List\", path, recursive)\n\treturn r.Storage.List(ctx, path, recursive)\n}\nfunc (r *recordingStorage) Load(ctx context.Context, key string) ([]byte, error) {\n\tr.record(\"Load\", key)\n\treturn r.Storage.Load(ctx, key)\n}\nfunc (r *recordingStorage) Lock(ctx context.Context, name string) error {\n\tr.record(\"Lock\", name)\n\treturn r.Storage.Lock(ctx, name)\n}\nfunc (r *recordingStorage) Stat(ctx context.Context, key string) (KeyInfo, error) {\n\tr.record(\"Stat\", key)\n\treturn r.Storage.Stat(ctx, key)\n}\nfunc (r *recordingStorage) Store(ctx context.Context, key string, value []byte) error {\n\tr.record(\"Store\", key)\n\treturn r.Storage.Store(ctx, key, value)\n}\nfunc (r *recordingStorage) Unlock(ctx context.Context, name string) error {\n\tr.record(\"Unlock\", name)\n\treturn r.Storage.Unlock(ctx, name)\n}\n\ntype recordedCall struct {\n\tname string\n\targs []any\n}\n\nfunc (r *recordingStorage) record(name string, args ...any) {\n\tr.calls = append(r.calls, recordedCall{name: name, args: args})\n}\n\nvar _ Storage = (*recordingStorage)(nil)\n\nfunc TestNewAccount(t *testing.T) {\n\tam := &ACMEIssuer{CA: dummyCA, Logger: zap.NewNop(), mu: new(sync.Mutex)}\n\ttestConfig := &Config{\n\t\tIssuers:   []Issuer{am},\n\t\tStorage:   &FileStorage{Path: \"./_testdata_tmp\"},\n\t\tLogger:    defaultTestLogger,\n\t\tcertCache: new(Cache),\n\t}\n\tam.config = testConfig\n\n\temail := \"me@foobar.com\"\n\taccount, err := am.newAccount(email)\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating account: %v\", err)\n\t}\n\tif account.PrivateKey == nil {\n\t\tt.Error(\"Private key is nil\")\n\t}\n\tif account.Contact[0] != \"mailto:\"+email {\n\t\tt.Errorf(\"Expected email to be %s, but was %s\", email, account.Contact[0])\n\t}\n\tif account.Status != \"\" {\n\t\tt.Error(\"New account already has a status; it shouldn't\")\n\t}\n}\n\nfunc TestSaveAccount(t *testing.T) {\n\tctx := context.Background()\n\n\tam := &ACMEIssuer{CA: dummyCA, Logger: zap.NewNop(), mu: new(sync.Mutex)}\n\ttestConfig := &Config{\n\t\tIssuers:   []Issuer{am},\n\t\tStorage:   &FileStorage{Path: \"./_testdata1_tmp\"},\n\t\tLogger:    defaultTestLogger,\n\t\tcertCache: new(Cache),\n\t}\n\tam.config = testConfig\n\n\ttestStorageDir := testConfig.Storage.(*FileStorage).Path\n\tdefer func() {\n\t\terr := os.RemoveAll(testStorageDir)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not remove temporary storage directory (%s): %v\", testStorageDir, err)\n\t\t}\n\t}()\n\n\temail := \"me@foobar.com\"\n\taccount, err := am.newAccount(email)\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating account: %v\", err)\n\t}\n\n\terr = am.saveAccount(ctx, am.CA, account)\n\tif err != nil {\n\t\tt.Fatalf(\"Error saving account: %v\", err)\n\t}\n\t_, err = am.getAccount(ctx, am.CA, email)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot access account data, error: %v\", err)\n\t}\n}\n\nfunc TestGetAccountDoesNotAlreadyExist(t *testing.T) {\n\tctx := context.Background()\n\n\tam := &ACMEIssuer{CA: dummyCA, Logger: zap.NewNop(), mu: new(sync.Mutex)}\n\ttestConfig := &Config{\n\t\tIssuers:   []Issuer{am},\n\t\tStorage:   &FileStorage{Path: \"./_testdata_tmp\"},\n\t\tLogger:    defaultTestLogger,\n\t\tcertCache: new(Cache),\n\t}\n\tam.config = testConfig\n\n\taccount, err := am.getAccount(ctx, am.CA, \"account_does_not_exist@foobar.com\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error getting account: %v\", err)\n\t}\n\n\tif account.PrivateKey == nil {\n\t\tt.Error(\"Expected account to have a private key, but it was nil\")\n\t}\n}\n\nfunc TestGetAccountAlreadyExists(t *testing.T) {\n\tctx := context.Background()\n\n\tam := &ACMEIssuer{CA: dummyCA, Logger: zap.NewNop(), mu: new(sync.Mutex)}\n\ttestConfig := &Config{\n\t\tIssuers:   []Issuer{am},\n\t\tStorage:   &FileStorage{Path: \"./_testdata2_tmp\"},\n\t\tLogger:    defaultTestLogger,\n\t\tcertCache: new(Cache),\n\t}\n\tam.config = testConfig\n\n\ttestStorageDir := testConfig.Storage.(*FileStorage).Path\n\tdefer func() {\n\t\terr := os.RemoveAll(testStorageDir)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not remove temporary storage directory (%s): %v\", testStorageDir, err)\n\t\t}\n\t}()\n\n\temail := \"me@foobar.com\"\n\n\t// Set up test\n\taccount, err := am.newAccount(email)\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating account: %v\", err)\n\t}\n\terr = am.saveAccount(ctx, am.CA, account)\n\tif err != nil {\n\t\tt.Fatalf(\"Error saving account: %v\", err)\n\t}\n\n\t// Expect to load account from disk\n\tloadedAccount, err := am.getAccount(ctx, am.CA, email)\n\tif err != nil {\n\t\tt.Fatalf(\"Error getting account: %v\", err)\n\t}\n\n\t// Assert keys are the same\n\tif !privateKeysSame(account.PrivateKey, loadedAccount.PrivateKey) {\n\t\tt.Error(\"Expected private key to be the same after loading, but it wasn't\")\n\t}\n\n\t// Assert emails are the same\n\tif !reflect.DeepEqual(account.Contact, loadedAccount.Contact) {\n\t\tt.Errorf(\"Expected contacts to be equal, but was '%s' before and '%s' after loading\", account.Contact, loadedAccount.Contact)\n\t}\n}\n\nfunc TestGetAccountAlreadyExistsSkipsBroken(t *testing.T) {\n\tctx := context.Background()\n\n\tam := &ACMEIssuer{CA: dummyCA, Logger: zap.NewNop(), mu: new(sync.Mutex)}\n\ttestConfig := &Config{\n\t\tIssuers:   []Issuer{am},\n\t\tStorage:   &memoryStorage{},\n\t\tLogger:    defaultTestLogger,\n\t\tcertCache: new(Cache),\n\t}\n\tam.config = testConfig\n\n\temail := \"me@foobar.com\"\n\n\t// Create a \"corrupted\" account\n\tam.config.Storage.Store(ctx, am.storageKeyUserReg(am.CA, \"notmeatall@foobar.com\"), []byte(\"this is not a valid account\"))\n\n\t// Create the actual account\n\taccount, err := am.newAccount(email)\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating account: %v\", err)\n\t}\n\terr = am.saveAccount(ctx, am.CA, account)\n\tif err != nil {\n\t\tt.Fatalf(\"Error saving account: %v\", err)\n\t}\n\n\t// Expect to load account from disk\n\tkeyBytes, err := PEMEncodePrivateKey(account.PrivateKey)\n\tif err != nil {\n\t\tt.Fatalf(\"Error encoding private key: %v\", err)\n\t}\n\n\tloadedAccount, err := am.GetAccount(ctx, keyBytes)\n\tif err != nil {\n\t\tt.Fatalf(\"Error getting account: %v\", err)\n\t}\n\n\t// Assert keys are the same\n\tif !privateKeysSame(account.PrivateKey, loadedAccount.PrivateKey) {\n\t\tt.Error(\"Expected private key to be the same after loading, but it wasn't\")\n\t}\n\n\t// Assert emails are the same\n\tif !reflect.DeepEqual(account.Contact, loadedAccount.Contact) {\n\t\tt.Errorf(\"Expected contacts to be equal, but was '%s' before and '%s' after loading\", account.Contact, loadedAccount.Contact)\n\t}\n}\n\nfunc TestGetAccountWithEmailAlreadyExists(t *testing.T) {\n\tctx := context.Background()\n\n\tam := &ACMEIssuer{CA: dummyCA, Logger: zap.NewNop(), mu: new(sync.Mutex)}\n\ttestConfig := &Config{\n\t\tIssuers:   []Issuer{am},\n\t\tStorage:   &recordingStorage{Storage: &memoryStorage{}},\n\t\tLogger:    defaultTestLogger,\n\t\tcertCache: new(Cache),\n\t}\n\tam.config = testConfig\n\n\temail := \"me@foobar.com\"\n\n\t// Set up test\n\taccount, err := am.newAccount(email)\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating account: %v\", err)\n\t}\n\terr = am.saveAccount(ctx, am.CA, account)\n\tif err != nil {\n\t\tt.Fatalf(\"Error saving account: %v\", err)\n\t}\n\n\t// Set the expected email:\n\tam.Email = email\n\terr = am.setEmail(ctx, true)\n\tif err != nil {\n\t\tt.Fatalf(\"setEmail error: %v\", err)\n\t}\n\n\t// Expect to load account from disk\n\tkeyBytes, err := PEMEncodePrivateKey(account.PrivateKey)\n\tif err != nil {\n\t\tt.Fatalf(\"Error encoding private key: %v\", err)\n\t}\n\n\tloadedAccount, err := am.GetAccount(ctx, keyBytes)\n\tif err != nil {\n\t\tt.Fatalf(\"Error getting account: %v\", err)\n\t}\n\n\t// Assert keys are the same\n\tif !privateKeysSame(account.PrivateKey, loadedAccount.PrivateKey) {\n\t\tt.Error(\"Expected private key to be the same after loading, but it wasn't\")\n\t}\n\n\t// Assert emails are the same\n\tif !reflect.DeepEqual(account.Contact, loadedAccount.Contact) {\n\t\tt.Errorf(\"Expected contacts to be equal, but was '%s' before and '%s' after loading\", account.Contact, loadedAccount.Contact)\n\t}\n\n\t// Assert that this was found without listing all accounts\n\trs := testConfig.Storage.(*recordingStorage)\n\tfor _, call := range rs.calls {\n\t\tif call.name == \"List\" {\n\t\t\tt.Error(\"Unexpected List call\")\n\t\t}\n\t}\n}\n\nfunc TestGetEmailFromPackageDefault(t *testing.T) {\n\tctx := context.Background()\n\n\tDefaultACME.Email = \"tEsT2@foo.com\"\n\tdefer func() {\n\t\tDefaultACME.Email = \"\"\n\t\tdiscoveredEmail = \"\"\n\t}()\n\n\tam := &ACMEIssuer{CA: dummyCA, Logger: zap.NewNop(), mu: new(sync.Mutex)}\n\ttestConfig := &Config{\n\t\tIssuers:   []Issuer{am},\n\t\tStorage:   &FileStorage{Path: \"./_testdata2_tmp\"},\n\t\tLogger:    defaultTestLogger,\n\t\tcertCache: new(Cache),\n\t}\n\tam.config = testConfig\n\n\terr := am.setEmail(ctx, true)\n\tif err != nil {\n\t\tt.Fatalf(\"getEmail error: %v\", err)\n\t}\n\tlowerEmail := strings.ToLower(DefaultACME.Email)\n\tif am.getEmail() != lowerEmail {\n\t\tt.Errorf(\"Did not get correct email from memory; expected '%s' but got '%s'\", lowerEmail, am.Email)\n\t}\n}\n\nfunc TestGetEmailFromUserInput(t *testing.T) {\n\tctx := context.Background()\n\n\tam := &ACMEIssuer{CA: dummyCA, Logger: zap.NewNop(), mu: new(sync.Mutex)}\n\ttestConfig := &Config{\n\t\tIssuers:   []Issuer{am},\n\t\tStorage:   &FileStorage{Path: \"./_testdata3_tmp\"},\n\t\tLogger:    defaultTestLogger,\n\t\tcertCache: new(Cache),\n\t}\n\tam.config = testConfig\n\n\t// let's not clutter up the output\n\torigStdout := os.Stdout\n\tos.Stdout = nil\n\tagreementTestURL = \"(none - testing)\"\n\tdefer func() {\n\t\tos.Stdout = origStdout\n\t\tagreementTestURL = \"\"\n\t}()\n\n\temail := \"test3@foo.com\"\n\tstdin = bytes.NewBufferString(email + \"\\n\")\n\terr := am.setEmail(ctx, true)\n\tif err != nil {\n\t\tt.Fatalf(\"getEmail error: %v\", err)\n\t}\n\tif am.email != email {\n\t\tt.Errorf(\"Did not get correct email from user input prompt; expected '%s' but got '%s'\", email, am.Email)\n\t}\n\tif !am.isAgreed() {\n\t\tt.Error(\"Expect Config.agreed to be true, but got false\")\n\t}\n}\n\nfunc TestGetEmailFromRecent(t *testing.T) {\n\tctx := context.Background()\n\n\tam := &ACMEIssuer{CA: dummyCA, Logger: zap.NewNop(), mu: new(sync.Mutex)}\n\ttestConfig := &Config{\n\t\tIssuers:   []Issuer{am},\n\t\tStorage:   &FileStorage{Path: \"./_testdata4_tmp\"},\n\t\tLogger:    defaultTestLogger,\n\t\tcertCache: new(Cache),\n\t}\n\tam.config = testConfig\n\n\ttestStorageDir := testConfig.Storage.(*FileStorage).Path\n\tdefer func() {\n\t\terr := os.RemoveAll(testStorageDir)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not remove temporary storage directory (%s): %v\", testStorageDir, err)\n\t\t}\n\t}()\n\n\tDefaultACME.Email = \"\"\n\tdiscoveredEmail = \"\"\n\n\tfor i, eml := range []string{\n\t\t\"test4-1@foo.com\",\n\t\t\"test4-2@foo.com\",\n\t\t\"TEST4-3@foo.com\", // test case insensitivity\n\t} {\n\t\taccount, err := am.newAccount(eml)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error creating user %d: %v\", i, err)\n\t\t}\n\t\terr = am.saveAccount(ctx, am.CA, account)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error saving user %d: %v\", i, err)\n\t\t}\n\n\t\t// Change modified time so they're all different and the test becomes more deterministic\n\t\tfs := testConfig.Storage.(*FileStorage)\n\t\tuserFolder := filepath.Join(fs.Path, am.storageKeyUserPrefix(am.CA, eml))\n\t\tf, err := os.Stat(userFolder)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not access user folder for '%s': %v\", eml, err)\n\t\t}\n\t\tchTime := f.ModTime().Add(time.Duration(i) * time.Hour) // 1 second isn't always enough spacing!\n\t\tif err := os.Chtimes(userFolder, chTime, chTime); err != nil {\n\t\t\tt.Fatalf(\"Could not change user folder mod time for '%s': %v\", eml, err)\n\t\t}\n\t}\n\terr := am.setEmail(ctx, true)\n\tif err != nil {\n\t\tt.Fatalf(\"getEmail error: %v\", err)\n\t}\n\tif am.getEmail() != \"test4-3@foo.com\" {\n\t\tt.Errorf(\"Did not get correct email from storage; expected '%s' but got '%s'\", \"test4-3@foo.com\", am.Email)\n\t}\n}\n\n// agreementTestURL is set during tests to skip requiring\n// setting up an entire ACME CA endpoint.\nvar agreementTestURL string\n"
        },
        {
          "name": "acmeclient.go",
          "type": "blob",
          "size": 13.9521484375,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"context\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/mholt/acmez/v3\"\n\t\"github.com/mholt/acmez/v3/acme\"\n\t\"go.uber.org/zap\"\n\t\"go.uber.org/zap/exp/zapslog\"\n)\n\n// acmeClient holds state necessary to perform ACME operations\n// for certificate management with an ACME account. Call\n// ACMEIssuer.newACMEClientWithAccount() to get a valid one.\ntype acmeClient struct {\n\tiss        *ACMEIssuer\n\tacmeClient *acmez.Client\n\taccount    acme.Account\n}\n\n// newACMEClientWithAccount creates an ACME client ready to use with an account, including\n// loading one from storage or registering a new account with the CA if necessary. If\n// useTestCA is true, am.TestCA will be used if set; otherwise, the primary CA will be used.\nfunc (iss *ACMEIssuer) newACMEClientWithAccount(ctx context.Context, useTestCA, interactive bool) (*acmeClient, error) {\n\t// first, get underlying ACME client\n\tclient, err := iss.newACMEClient(useTestCA)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// we try loading the account from storage before a potential\n\t// lock, and after obtaining the lock as well, to ensure we don't\n\t// repeat work done by another instance or goroutine\n\tgetAccount := func() (acme.Account, error) {\n\t\t// look up or create the ACME account\n\t\tvar account acme.Account\n\t\tif iss.AccountKeyPEM != \"\" {\n\t\t\tiss.Logger.Info(\"using configured ACME account\")\n\t\t\taccount, err = iss.GetAccount(ctx, []byte(iss.AccountKeyPEM))\n\t\t} else {\n\t\t\taccount, err = iss.getAccount(ctx, client.Directory, iss.getEmail())\n\t\t}\n\t\tif err != nil {\n\t\t\treturn acme.Account{}, fmt.Errorf(\"getting ACME account: %v\", err)\n\t\t}\n\t\treturn account, nil\n\t}\n\n\t// first try getting the account\n\taccount, err := getAccount()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// register account if it is new\n\tif account.Status == \"\" {\n\t\tiss.Logger.Info(\"ACME account has empty status; registering account with ACME server\",\n\t\t\tzap.Strings(\"contact\", account.Contact),\n\t\t\tzap.String(\"location\", account.Location))\n\n\t\t// synchronize this so the account is only created once\n\t\tacctLockKey := accountRegLockKey(account)\n\t\terr = acquireLock(ctx, iss.config.Storage, acctLockKey)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"locking account registration: %v\", err)\n\t\t}\n\t\tdefer func() {\n\t\t\tif err := releaseLock(ctx, iss.config.Storage, acctLockKey); err != nil {\n\t\t\t\tiss.Logger.Error(\"failed to unlock account registration lock\", zap.Error(err))\n\t\t\t}\n\t\t}()\n\n\t\t// if we're not the only one waiting for this account, then by this point it should already be registered and in storage; reload it\n\t\taccount, err = getAccount()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// if we are the only or first one waiting for this account, then proceed to register it while we have the lock\n\t\tif account.Status == \"\" {\n\t\t\tif iss.NewAccountFunc != nil {\n\t\t\t\t// obtain lock here, since NewAccountFunc calls happen concurrently and they typically read and change the issuer\n\t\t\t\tiss.mu.Lock()\n\t\t\t\taccount, err = iss.NewAccountFunc(ctx, iss, account)\n\t\t\t\tiss.mu.Unlock()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"account pre-registration callback: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// agree to terms\n\t\t\tif interactive {\n\t\t\t\tif !iss.isAgreed() {\n\t\t\t\t\tvar termsURL string\n\t\t\t\t\tdir, err := client.GetDirectory(ctx)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, fmt.Errorf(\"getting directory: %w\", err)\n\t\t\t\t\t}\n\t\t\t\t\tif dir.Meta != nil {\n\t\t\t\t\t\ttermsURL = dir.Meta.TermsOfService\n\t\t\t\t\t}\n\t\t\t\t\tif termsURL != \"\" {\n\t\t\t\t\t\tagreed := iss.askUserAgreement(termsURL)\n\t\t\t\t\t\tif !agreed {\n\t\t\t\t\t\t\treturn nil, fmt.Errorf(\"user must agree to CA terms\")\n\t\t\t\t\t\t}\n\t\t\t\t\t\tiss.mu.Lock()\n\t\t\t\t\t\tiss.agreed = agreed\n\t\t\t\t\t\tiss.mu.Unlock()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// can't prompt a user who isn't there; they should\n\t\t\t\t// have reviewed the terms beforehand\n\t\t\t\tiss.mu.Lock()\n\t\t\t\tiss.agreed = true\n\t\t\t\tiss.mu.Unlock()\n\t\t\t}\n\t\t\taccount.TermsOfServiceAgreed = iss.isAgreed()\n\n\t\t\t// associate account with external binding, if configured\n\t\t\tif iss.ExternalAccount != nil {\n\t\t\t\terr := account.SetExternalAccountBinding(ctx, client.Client, *iss.ExternalAccount)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// create account\n\t\t\taccount, err = client.NewAccount(ctx, account)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"registering account %v with server: %w\", account.Contact, err)\n\t\t\t}\n\t\t\tiss.Logger.Info(\"new ACME account registered\",\n\t\t\t\tzap.Strings(\"contact\", account.Contact),\n\t\t\t\tzap.String(\"status\", account.Status))\n\n\t\t\t// persist the account to storage\n\t\t\terr = iss.saveAccount(ctx, client.Directory, account)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"could not save account %v: %v\", account.Contact, err)\n\t\t\t}\n\t\t} else {\n\t\t\tiss.Logger.Info(\"account has already been registered; reloaded\",\n\t\t\t\tzap.Strings(\"contact\", account.Contact),\n\t\t\t\tzap.String(\"status\", account.Status),\n\t\t\t\tzap.String(\"location\", account.Location))\n\t\t}\n\t}\n\n\tc := &acmeClient{\n\t\tiss:        iss,\n\t\tacmeClient: client,\n\t\taccount:    account,\n\t}\n\n\treturn c, nil\n}\n\n// newACMEClient creates a new underlying ACME client using the settings in am,\n// independent of any particular ACME account. If useTestCA is true, am.TestCA\n// will be used if it is set; otherwise, the primary CA will be used.\nfunc (iss *ACMEIssuer) newACMEClient(useTestCA bool) (*acmez.Client, error) {\n\tclient, err := iss.newBasicACMEClient()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// fill in a little more beyond a basic client\n\tif useTestCA && iss.TestCA != \"\" {\n\t\tclient.Client.Directory = iss.TestCA\n\t}\n\tcertObtainTimeout := iss.CertObtainTimeout\n\tif certObtainTimeout == 0 {\n\t\tcertObtainTimeout = DefaultACME.CertObtainTimeout\n\t}\n\tclient.Client.PollTimeout = certObtainTimeout\n\tclient.ChallengeSolvers = make(map[string]acmez.Solver)\n\n\t// configure challenges (most of the time, DNS challenge is\n\t// exclusive of other ones because it is usually only used\n\t// in situations where the default challenges would fail)\n\tif iss.DNS01Solver == nil {\n\t\t// enable HTTP-01 challenge\n\t\tif !iss.DisableHTTPChallenge {\n\t\t\tclient.ChallengeSolvers[acme.ChallengeTypeHTTP01] = distributedSolver{\n\t\t\t\tstorage:                iss.config.Storage,\n\t\t\t\tstorageKeyIssuerPrefix: iss.storageKeyCAPrefix(client.Directory),\n\t\t\t\tsolver: &httpSolver{\n\t\t\t\t\thandler: iss.HTTPChallengeHandler(http.NewServeMux()),\n\t\t\t\t\taddress: net.JoinHostPort(iss.ListenHost, strconv.Itoa(iss.getHTTPPort())),\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\t// enable TLS-ALPN-01 challenge\n\t\tif !iss.DisableTLSALPNChallenge {\n\t\t\tclient.ChallengeSolvers[acme.ChallengeTypeTLSALPN01] = distributedSolver{\n\t\t\t\tstorage:                iss.config.Storage,\n\t\t\t\tstorageKeyIssuerPrefix: iss.storageKeyCAPrefix(client.Directory),\n\t\t\t\tsolver: &tlsALPNSolver{\n\t\t\t\t\tconfig:  iss.config,\n\t\t\t\t\taddress: net.JoinHostPort(iss.ListenHost, strconv.Itoa(iss.getTLSALPNPort())),\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// use DNS challenge exclusively\n\t\tclient.ChallengeSolvers[acme.ChallengeTypeDNS01] = iss.DNS01Solver\n\t}\n\n\t// wrap solvers in our wrapper so that we can keep track of challenge\n\t// info: this is useful for solving challenges globally as a process;\n\t// for example, usually there is only one process that can solve the\n\t// HTTP and TLS-ALPN challenges, and only one server in that process\n\t// that can bind the necessary port(s), so if a server listening on\n\t// a different port needed a certificate, it would have to know about\n\t// the other server listening on that port, and somehow convey its\n\t// challenge info or share its config, but this isn't always feasible;\n\t// what the wrapper does is it accesses a global challenge memory so\n\t// that unrelated servers in this process can all solve each others'\n\t// challenges without having to know about each other - Caddy's admin\n\t// endpoint uses this functionality since it and the HTTP/TLS modules\n\t// do not know about each other\n\t// (doing this here in a separate loop ensures that even if we expose\n\t// solver config to users later, we will even wrap their own solvers)\n\tfor name, solver := range client.ChallengeSolvers {\n\t\tclient.ChallengeSolvers[name] = solverWrapper{solver}\n\t}\n\n\treturn client, nil\n}\n\n// newBasicACMEClient sets up a basically-functional ACME client that is not capable\n// of solving challenges but can provide basic interactions with the server.\nfunc (iss *ACMEIssuer) newBasicACMEClient() (*acmez.Client, error) {\n\tcaURL := iss.CA\n\tif caURL == \"\" {\n\t\tcaURL = DefaultACME.CA\n\t}\n\t// ensure endpoint is secure (assume HTTPS if scheme is missing)\n\tif !strings.Contains(caURL, \"://\") {\n\t\tcaURL = \"https://\" + caURL\n\t}\n\tu, err := url.Parse(caURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif u.Scheme != \"https\" && !SubjectIsInternal(u.Host) {\n\t\treturn nil, fmt.Errorf(\"%s: insecure CA URL (HTTPS required for non-internal CA)\", caURL)\n\t}\n\treturn &acmez.Client{\n\t\tClient: &acme.Client{\n\t\t\tDirectory:  caURL,\n\t\t\tUserAgent:  buildUAString(),\n\t\t\tHTTPClient: iss.httpClient,\n\t\t\tLogger:     slog.New(zapslog.NewHandler(iss.Logger.Named(\"acme_client\").Core())),\n\t\t},\n\t}, nil\n}\n\n// GetRenewalInfo gets the ACME Renewal Information (ARI) for the certificate.\nfunc (iss *ACMEIssuer) GetRenewalInfo(ctx context.Context, cert Certificate) (acme.RenewalInfo, error) {\n\tacmeClient, err := iss.newBasicACMEClient()\n\tif err != nil {\n\t\treturn acme.RenewalInfo{}, err\n\t}\n\treturn acmeClient.GetRenewalInfo(ctx, cert.Certificate.Leaf)\n}\n\nfunc (iss *ACMEIssuer) getHTTPPort() int {\n\tuseHTTPPort := HTTPChallengePort\n\tif HTTPPort > 0 && HTTPPort != HTTPChallengePort {\n\t\tuseHTTPPort = HTTPPort\n\t}\n\tif iss.AltHTTPPort > 0 {\n\t\tuseHTTPPort = iss.AltHTTPPort\n\t}\n\treturn useHTTPPort\n}\n\nfunc (iss *ACMEIssuer) getTLSALPNPort() int {\n\tuseTLSALPNPort := TLSALPNChallengePort\n\tif HTTPSPort > 0 && HTTPSPort != TLSALPNChallengePort {\n\t\tuseTLSALPNPort = HTTPSPort\n\t}\n\tif iss.AltTLSALPNPort > 0 {\n\t\tuseTLSALPNPort = iss.AltTLSALPNPort\n\t}\n\treturn useTLSALPNPort\n}\n\nfunc (c *acmeClient) throttle(ctx context.Context, names []string) error {\n\temail := c.iss.getEmail()\n\n\t// throttling is scoped to CA + account email\n\trateLimiterKey := c.acmeClient.Directory + \",\" + email\n\trateLimitersMu.Lock()\n\trl, ok := rateLimiters[rateLimiterKey]\n\tif !ok {\n\t\trl = NewRateLimiter(RateLimitEvents, RateLimitEventsWindow)\n\t\trateLimiters[rateLimiterKey] = rl\n\t\t// TODO: stop rate limiter when it is garbage-collected...\n\t}\n\trateLimitersMu.Unlock()\n\tc.iss.Logger.Info(\"waiting on internal rate limiter\",\n\t\tzap.Strings(\"identifiers\", names),\n\t\tzap.String(\"ca\", c.acmeClient.Directory),\n\t\tzap.String(\"account\", email),\n\t)\n\terr := rl.Wait(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.iss.Logger.Info(\"done waiting on internal rate limiter\",\n\t\tzap.Strings(\"identifiers\", names),\n\t\tzap.String(\"ca\", c.acmeClient.Directory),\n\t\tzap.String(\"account\", email),\n\t)\n\treturn nil\n}\n\nfunc (c *acmeClient) usingTestCA() bool {\n\treturn c.iss.TestCA != \"\" && c.acmeClient.Directory == c.iss.TestCA\n}\n\nfunc (c *acmeClient) revoke(ctx context.Context, cert *x509.Certificate, reason int) error {\n\treturn c.acmeClient.RevokeCertificate(ctx, c.account,\n\t\tcert, c.account.PrivateKey, reason)\n}\n\nfunc buildUAString() string {\n\tua := \"CertMagic\"\n\tif UserAgent != \"\" {\n\t\tua = UserAgent + \" \" + ua\n\t}\n\treturn ua\n}\n\n// RenewalInfoGetter is a type that can get ACME Renewal Information (ARI).\n// Users of this package that wrap the ACMEIssuer or use any other issuer\n// that supports ARI will need to implement this so that CertMagic can\n// update ARI which happens outside the normal issuance flow and is thus\n// not required by the Issuer interface (a type assertion is performed).\ntype RenewalInfoGetter interface {\n\tGetRenewalInfo(context.Context, Certificate) (acme.RenewalInfo, error)\n}\n\n// These internal rate limits are designed to prevent accidentally\n// firehosing a CA's ACME endpoints. They are not intended to\n// replace or replicate the CA's actual rate limits.\n//\n// Let's Encrypt's rate limits can be found here:\n// https://letsencrypt.org/docs/rate-limits/\n//\n// Currently (as of December 2019), Let's Encrypt's most relevant\n// rate limit for large deployments is 300 new orders per account\n// per 3 hours (on average, or best case, that's about 1 every 36\n// seconds, or 2 every 72 seconds, etc.); but it's not reasonable\n// to try to assume that our internal state is the same as the CA's\n// (due to process restarts, config changes, failed validations,\n// etc.) and ultimately, only the CA's actual rate limiter is the\n// authority. Thus, our own rate limiters do not attempt to enforce\n// external rate limits. Doing so causes problems when the domains\n// are not in our control (i.e. serving customer sites) and/or lots\n// of domains fail validation: they clog our internal rate limiter\n// and nearly starve out (or at least slow down) the other domains\n// that need certificates. Failed transactions are already retried\n// with exponential backoff, so adding in rate limiting can slow\n// things down even more.\n//\n// Instead, the point of our internal rate limiter is to avoid\n// hammering the CA's endpoint when there are thousands or even\n// millions of certificates under management. Our goal is to\n// allow small bursts in a relatively short timeframe so as to\n// not block any one domain for too long, without unleashing\n// thousands of requests to the CA at once.\nvar (\n\trateLimiters   = make(map[string]*RingBufferRateLimiter)\n\trateLimitersMu sync.RWMutex\n\n\t// RateLimitEvents is how many new events can be allowed\n\t// in RateLimitEventsWindow.\n\tRateLimitEvents = 10\n\n\t// RateLimitEventsWindow is the size of the sliding\n\t// window that throttles events.\n\tRateLimitEventsWindow = 10 * time.Second\n)\n\n// Some default values passed down to the underlying ACME client.\nvar (\n\tUserAgent   string\n\tHTTPTimeout = 30 * time.Second\n)\n"
        },
        {
          "name": "acmeissuer.go",
          "type": "blob",
          "size": 22.861328125,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/mholt/acmez/v3\"\n\t\"github.com/mholt/acmez/v3/acme\"\n\t\"go.uber.org/zap\"\n)\n\n// ACMEIssuer gets certificates using ACME. It implements the PreChecker,\n// Issuer, and Revoker interfaces.\n//\n// It is NOT VALID to use an ACMEIssuer without calling NewACMEIssuer().\n// It fills in any default values from DefaultACME as well as setting up\n// internal state that is necessary for valid use. Always call\n// NewACMEIssuer() to get a valid ACMEIssuer value.\ntype ACMEIssuer struct {\n\t// The endpoint of the directory for the ACME\n\t// CA we are to use\n\tCA string\n\n\t// TestCA is the endpoint of the directory for\n\t// an ACME CA to use to test domain validation,\n\t// but any certs obtained from this CA are\n\t// discarded\n\tTestCA string\n\n\t// The email address to use when creating or\n\t// selecting an existing ACME server account\n\tEmail string\n\n\t// The PEM-encoded private key of the ACME\n\t// account to use; only needed if the account\n\t// is already created on the server and\n\t// can be looked up with the ACME protocol\n\tAccountKeyPEM string\n\n\t// Set to true if agreed to the CA's\n\t// subscriber agreement\n\tAgreed bool\n\n\t// An optional external account to associate\n\t// with this ACME account\n\tExternalAccount *acme.EAB\n\n\t// Optionally select an ACME profile offered\n\t// by the ACME server. The list of supported\n\t// profile names can be obtained from the ACME\n\t// server's directory endpoint. For details:\n\t// https://datatracker.ietf.org/doc/draft-aaron-acme-profiles/\n\t//\n\t// (EXPERIMENTAL: Subject to change.)\n\tProfile string\n\n\t// Optionally specify the validity period of\n\t// the certificate(s) here as offsets from the\n\t// approximate time of certificate issuance,\n\t// but note that not all CAs support this\n\t// (EXPERIMENTAL: Subject to change)\n\tNotBefore, NotAfter time.Duration\n\n\t// Disable all HTTP challenges\n\tDisableHTTPChallenge bool\n\n\t// Disable all TLS-ALPN challenges\n\tDisableTLSALPNChallenge bool\n\n\t// The host (ONLY the host, not port) to listen\n\t// on if necessary to start a listener to solve\n\t// an ACME challenge\n\tListenHost string\n\n\t// The alternate port to use for the ACME HTTP\n\t// challenge; if non-empty, this port will be\n\t// used instead of HTTPChallengePort to spin up\n\t// a listener for the HTTP challenge\n\tAltHTTPPort int\n\n\t// The alternate port to use for the ACME\n\t// TLS-ALPN challenge; the system must forward\n\t// TLSALPNChallengePort to this port for\n\t// challenge to succeed\n\tAltTLSALPNPort int\n\n\t// The solver for the dns-01 challenge;\n\t// usually this is a DNS01Solver value\n\t// from this package\n\tDNS01Solver acmez.Solver\n\n\t// TrustedRoots specifies a pool of root CA\n\t// certificates to trust when communicating\n\t// over a network to a peer.\n\tTrustedRoots *x509.CertPool\n\n\t// The maximum amount of time to allow for\n\t// obtaining a certificate. If empty, the\n\t// default from the underlying ACME lib is\n\t// used. If set, it must not be too low so\n\t// as to cancel challenges too early.\n\tCertObtainTimeout time.Duration\n\n\t// Address of custom DNS resolver to be used\n\t// when communicating with ACME server\n\tResolver string\n\n\t// Callback function that is called before a\n\t// new ACME account is registered with the CA;\n\t// it allows for last-second config changes\n\t// of the ACMEIssuer and the Account.\n\t// (TODO: this feature is still EXPERIMENTAL and subject to change)\n\tNewAccountFunc func(context.Context, *ACMEIssuer, acme.Account) (acme.Account, error)\n\n\t// Preferences for selecting alternate\n\t// certificate chains\n\tPreferredChains ChainPreference\n\n\t// Set a logger to configure logging; a default\n\t// logger must always be set; if no logging is\n\t// desired, set this to zap.NewNop().\n\tLogger *zap.Logger\n\n\t// Set a http proxy to use when issuing a certificate.\n\t// Default is http.ProxyFromEnvironment\n\tHTTPProxy func(*http.Request) (*url.URL, error)\n\n\tconfig     *Config\n\thttpClient *http.Client\n\n\t// Some fields are changed on-the-fly during\n\t// certificate management. For example, the\n\t// email might be implicitly discovered if not\n\t// explicitly configured, and agreement might\n\t// happen during the flow. Changing the exported\n\t// fields field is racey (issue #195) so we\n\t// control unexported fields that we can\n\t// synchronize properly.\n\temail  string\n\tagreed bool\n\tmu     *sync.Mutex // protects the above grouped fields, as well as entire struct during NewAccountFunc calls\n}\n\n// NewACMEIssuer constructs a valid ACMEIssuer based on a template\n// configuration; any empty values will be filled in by defaults in\n// DefaultACME, and if any required values are still empty, sensible\n// defaults will be used.\n//\n// Typically, you'll create the Config first with New() or NewDefault(),\n// then call NewACMEIssuer(), then assign the return value to the Issuers\n// field of the Config.\nfunc NewACMEIssuer(cfg *Config, template ACMEIssuer) *ACMEIssuer {\n\tif cfg == nil {\n\t\tpanic(\"cannot make valid ACMEIssuer without an associated CertMagic config\")\n\t}\n\tif template.CA == \"\" {\n\t\ttemplate.CA = DefaultACME.CA\n\t}\n\tif template.TestCA == \"\" && template.CA == DefaultACME.CA {\n\t\t// only use the default test CA if the CA is also\n\t\t// the default CA; no point in testing against\n\t\t// Let's Encrypt's staging server if we are not\n\t\t// using their production server too\n\t\ttemplate.TestCA = DefaultACME.TestCA\n\t}\n\tif template.Email == \"\" {\n\t\ttemplate.Email = DefaultACME.Email\n\t}\n\tif template.AccountKeyPEM == \"\" {\n\t\ttemplate.AccountKeyPEM = DefaultACME.AccountKeyPEM\n\t}\n\tif !template.Agreed {\n\t\ttemplate.Agreed = DefaultACME.Agreed\n\t}\n\tif template.ExternalAccount == nil {\n\t\ttemplate.ExternalAccount = DefaultACME.ExternalAccount\n\t}\n\tif template.NotBefore == 0 {\n\t\ttemplate.NotBefore = DefaultACME.NotBefore\n\t}\n\tif template.NotAfter == 0 {\n\t\ttemplate.NotAfter = DefaultACME.NotAfter\n\t}\n\tif !template.DisableHTTPChallenge {\n\t\ttemplate.DisableHTTPChallenge = DefaultACME.DisableHTTPChallenge\n\t}\n\tif !template.DisableTLSALPNChallenge {\n\t\ttemplate.DisableTLSALPNChallenge = DefaultACME.DisableTLSALPNChallenge\n\t}\n\tif template.ListenHost == \"\" {\n\t\ttemplate.ListenHost = DefaultACME.ListenHost\n\t}\n\tif template.AltHTTPPort == 0 {\n\t\ttemplate.AltHTTPPort = DefaultACME.AltHTTPPort\n\t}\n\tif template.AltTLSALPNPort == 0 {\n\t\ttemplate.AltTLSALPNPort = DefaultACME.AltTLSALPNPort\n\t}\n\tif template.DNS01Solver == nil {\n\t\ttemplate.DNS01Solver = DefaultACME.DNS01Solver\n\t}\n\tif template.TrustedRoots == nil {\n\t\ttemplate.TrustedRoots = DefaultACME.TrustedRoots\n\t}\n\tif template.CertObtainTimeout == 0 {\n\t\ttemplate.CertObtainTimeout = DefaultACME.CertObtainTimeout\n\t}\n\tif template.Resolver == \"\" {\n\t\ttemplate.Resolver = DefaultACME.Resolver\n\t}\n\tif template.NewAccountFunc == nil {\n\t\ttemplate.NewAccountFunc = DefaultACME.NewAccountFunc\n\t}\n\tif template.Logger == nil {\n\t\ttemplate.Logger = DefaultACME.Logger\n\t}\n\n\t// absolutely do not allow a nil logger; that would panic\n\tif template.Logger == nil {\n\t\ttemplate.Logger = defaultLogger\n\t}\n\n\tif template.HTTPProxy == nil {\n\t\ttemplate.HTTPProxy = DefaultACME.HTTPProxy\n\t}\n\tif template.HTTPProxy == nil {\n\t\ttemplate.HTTPProxy = http.ProxyFromEnvironment\n\t}\n\n\ttemplate.config = cfg\n\ttemplate.mu = new(sync.Mutex)\n\n\t// set up the dialer and transport / HTTP client\n\tdialer := &net.Dialer{\n\t\tTimeout:   30 * time.Second,\n\t\tKeepAlive: 2 * time.Minute,\n\t}\n\tif template.Resolver != \"\" {\n\t\tdialer.Resolver = &net.Resolver{\n\t\t\tPreferGo: true,\n\t\t\tDial: func(ctx context.Context, network, _ string) (net.Conn, error) {\n\t\t\t\treturn (&net.Dialer{\n\t\t\t\t\tTimeout: 15 * time.Second,\n\t\t\t\t}).DialContext(ctx, network, template.Resolver)\n\t\t\t},\n\t\t}\n\t}\n\ttransport := &http.Transport{\n\t\tProxy:                 template.HTTPProxy,\n\t\tDialContext:           dialer.DialContext,\n\t\tTLSHandshakeTimeout:   30 * time.Second, // increase to 30s requested in #175\n\t\tResponseHeaderTimeout: 30 * time.Second, // increase to 30s requested in #175\n\t\tExpectContinueTimeout: 2 * time.Second,\n\t\tForceAttemptHTTP2:     true,\n\t}\n\tif template.TrustedRoots != nil {\n\t\ttransport.TLSClientConfig = &tls.Config{\n\t\t\tRootCAs: template.TrustedRoots,\n\t\t}\n\t}\n\ttemplate.httpClient = &http.Client{\n\t\tTransport: transport,\n\t\tTimeout:   HTTPTimeout,\n\t}\n\n\treturn &template\n}\n\n// IssuerKey returns the unique issuer key for the\n// configured CA endpoint.\nfunc (am *ACMEIssuer) IssuerKey() string {\n\treturn am.issuerKey(am.CA)\n}\n\nfunc (*ACMEIssuer) issuerKey(ca string) string {\n\tkey := ca\n\tif caURL, err := url.Parse(key); err == nil {\n\t\tkey = caURL.Host\n\t\tif caURL.Path != \"\" {\n\t\t\t// keep the path, but make sure it's a single\n\t\t\t// component (i.e. no forward slashes, and for\n\t\t\t// good measure, no backward slashes either)\n\t\t\tconst hyphen = \"-\"\n\t\t\trepl := strings.NewReplacer(\n\t\t\t\t\"/\", hyphen,\n\t\t\t\t\"\\\\\", hyphen,\n\t\t\t)\n\t\t\tpath := strings.Trim(repl.Replace(caURL.Path), hyphen)\n\t\t\tif path != \"\" {\n\t\t\t\tkey += hyphen + path\n\t\t\t}\n\t\t}\n\t}\n\treturn key\n}\n\nfunc (iss *ACMEIssuer) getEmail() string {\n\tiss.mu.Lock()\n\tdefer iss.mu.Unlock()\n\treturn iss.email\n}\n\nfunc (iss *ACMEIssuer) isAgreed() bool {\n\tiss.mu.Lock()\n\tdefer iss.mu.Unlock()\n\treturn iss.agreed\n}\n\n// PreCheck performs a few simple checks before obtaining or\n// renewing a certificate with ACME, and returns whether this\n// batch is eligible for certificates. It also ensures that an\n// email address is available if possible.\n//\n// IP certificates via ACME are defined in RFC 8738.\nfunc (am *ACMEIssuer) PreCheck(ctx context.Context, names []string, interactive bool) error {\n\tpublicCAsAndIPCerts := map[string]bool{ // map of public CAs to whether they support IP certificates (last updated: Q1 2024)\n\t\t\"api.letsencrypt.org\": false, // https://community.letsencrypt.org/t/certificate-for-static-ip/84/2?u=mholt\n\t\t\"acme.zerossl.com\":    false, // only supported via their API, not ACME endpoint\n\t\t\"api.pki.goog\":        true,  // https://pki.goog/faq/#faq-IPCerts\n\t\t\"api.buypass.com\":     false, // https://community.buypass.com/t/h7hm76w/buypass-support-for-rfc-8738\n\t\t\"acme.ssl.com\":        false,\n\t}\n\tvar publicCA, ipCertAllowed bool\n\tfor caSubstr, ipCert := range publicCAsAndIPCerts {\n\t\tif strings.Contains(am.CA, caSubstr) {\n\t\t\tpublicCA, ipCertAllowed = true, ipCert\n\t\t\tbreak\n\t\t}\n\t}\n\tif publicCA {\n\t\tfor _, name := range names {\n\t\t\tif !SubjectQualifiesForPublicCert(name) {\n\t\t\t\treturn fmt.Errorf(\"subject '%s' does not qualify for a public certificate\", name)\n\t\t\t}\n\t\t\tif !ipCertAllowed && SubjectIsIP(name) {\n\t\t\t\treturn fmt.Errorf(\"subject '%s' cannot have public IP certificate from %s (if CA's policy has changed, please notify the developers in an issue)\", name, am.CA)\n\t\t\t}\n\t\t}\n\t}\n\treturn am.setEmail(ctx, interactive)\n}\n\n// Issue implements the Issuer interface. It obtains a certificate for the given csr using\n// the ACME configuration am.\nfunc (am *ACMEIssuer) Issue(ctx context.Context, csr *x509.CertificateRequest) (*IssuedCertificate, error) {\n\tif am.config == nil {\n\t\tpanic(\"missing config pointer (must use NewACMEIssuer)\")\n\t}\n\n\tvar attempts int\n\tif attemptsPtr, ok := ctx.Value(AttemptsCtxKey).(*int); ok {\n\t\tattempts = *attemptsPtr\n\t}\n\tisRetry := attempts > 0\n\n\tcert, usedTestCA, err := am.doIssue(ctx, csr, attempts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// important to note that usedTestCA is not necessarily the same as isRetry\n\t// (usedTestCA can be true if the main CA and the test CA happen to be the same)\n\tif isRetry && usedTestCA && am.CA != am.TestCA {\n\t\t// succeeded with testing endpoint, so try again with production endpoint\n\t\t// (only if the production endpoint is different from the testing endpoint)\n\t\t// TODO: This logic is imperfect and could benefit from some refinement.\n\t\t// The two CA endpoints likely have different states, which could cause one\n\t\t// to succeed and the other to fail, even if it's not a validation error.\n\t\t// Two common cases would be:\n\t\t// 1) Rate limiter state. This is more likely to cause prod to fail while\n\t\t// staging succeeds, since prod usually has tighter rate limits. Thus, if\n\t\t// initial attempt failed in prod due to rate limit, first retry (on staging)\n\t\t// might succeed, and then trying prod again right way would probably still\n\t\t// fail; normally this would terminate retries but the right thing to do in\n\t\t// this case is to back off and retry again later. We could refine this logic\n\t\t// to stick with the production endpoint on retries unless the error changes.\n\t\t// 2) Cached authorizations state. If a domain validates successfully with\n\t\t// one endpoint, but then the other endpoint is used, it might fail, e.g. if\n\t\t// DNS was just changed or is still propagating. In this case, the second CA\n\t\t// should continue to be retried with backoff, without switching back to the\n\t\t// other endpoint. This is more likely to happen if a user is testing with\n\t\t// the staging CA as the main CA, then changes their configuration once they\n\t\t// think they are ready for the production endpoint.\n\t\tcert, _, err = am.doIssue(ctx, csr, 0)\n\t\tif err != nil {\n\t\t\t// succeeded with test CA but failed just now with the production CA;\n\t\t\t// either we are observing differing internal states of each CA that will\n\t\t\t// work out with time, or there is a bug/misconfiguration somewhere\n\t\t\t// externally; it is hard to tell which! one easy cue is whether the\n\t\t\t// error is specifically a 429 (Too Many Requests); if so, we should\n\t\t\t// probably keep retrying\n\t\t\tvar problem acme.Problem\n\t\t\tif errors.As(err, &problem) {\n\t\t\t\tif problem.Status == http.StatusTooManyRequests {\n\t\t\t\t\t// DON'T abort retries; the test CA succeeded (even\n\t\t\t\t\t// if it's cached, it recently succeeded!) so we just\n\t\t\t\t\t// need to keep trying (with backoff) until this CA's\n\t\t\t\t\t// rate limits expire...\n\t\t\t\t\t// TODO: as mentioned in comment above, we would benefit\n\t\t\t\t\t// by pinning the main CA at this point instead of\n\t\t\t\t\t// needlessly retrying with the test CA first each time\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil, ErrNoRetry{err}\n\t\t}\n\t}\n\n\treturn cert, err\n}\n\nfunc (am *ACMEIssuer) doIssue(ctx context.Context, csr *x509.CertificateRequest, attempts int) (*IssuedCertificate, bool, error) {\n\tuseTestCA := attempts > 0\n\tclient, err := am.newACMEClientWithAccount(ctx, useTestCA, false)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tusingTestCA := client.usingTestCA()\n\n\tnameSet := namesFromCSR(csr)\n\n\tif !useTestCA {\n\t\tif err := client.throttle(ctx, nameSet); err != nil {\n\t\t\treturn nil, usingTestCA, err\n\t\t}\n\t}\n\n\tparams, err := acmez.OrderParametersFromCSR(client.account, csr)\n\tif err != nil {\n\t\treturn nil, false, fmt.Errorf(\"generating order parameters from CSR: %v\", err)\n\t}\n\tif am.NotBefore != 0 {\n\t\tparams.NotBefore = time.Now().Add(am.NotBefore)\n\t}\n\tif am.NotAfter != 0 {\n\t\tparams.NotAfter = time.Now().Add(am.NotAfter)\n\t}\n\tparams.Profile = am.Profile\n\n\t// Notify the ACME server we are replacing a certificate (if the caller says we are),\n\t// only if the following conditions are met:\n\t// - The caller has set a Replaces value in the context, indicating this is a renewal.\n\t// - Not using test CA. This should be obvious, but a test CA should be in a separate\n\t// environment from production, and thus not have knowledge of the cert being replaced.\n\t// - Not a certain attempt number. We skip setting Replaces once early on in the retries\n\t// in case the reason the order is failing is only because there is a state inconsistency\n\t// between client and server or some sort of bookkeeping error with regards to the certID\n\t// and the server is rejecting the ARI certID. In any case, an invalid certID may cause\n\t// orders to fail. So try once without setting it.\n\tif !am.config.DisableARI && !usingTestCA && attempts != 2 {\n\t\tif replacing, ok := ctx.Value(ctxKeyARIReplaces).(*x509.Certificate); ok {\n\t\t\tparams.Replaces = replacing\n\t\t}\n\t}\n\n\t// do this in a loop because there's an error case that may necessitate a retry, but not more than once\n\tvar certChains []acme.Certificate\n\tfor i := 0; i < 2; i++ {\n\t\tam.Logger.Info(\"using ACME account\",\n\t\t\tzap.String(\"account_id\", params.Account.Location),\n\t\t\tzap.Strings(\"account_contact\", params.Account.Contact))\n\n\t\tcertChains, err = client.acmeClient.ObtainCertificate(ctx, params)\n\t\tif err != nil {\n\t\t\tvar prob acme.Problem\n\t\t\tif errors.As(err, &prob) && prob.Type == acme.ProblemTypeAccountDoesNotExist {\n\t\t\t\tam.Logger.Warn(\"ACME account does not exist on server; attempting to recreate\",\n\t\t\t\t\tzap.String(\"account_id\", client.account.Location),\n\t\t\t\t\tzap.Strings(\"account_contact\", client.account.Contact),\n\t\t\t\t\tzap.String(\"key_location\", am.storageKeyUserPrivateKey(client.acmeClient.Directory, am.getEmail())),\n\t\t\t\t\tzap.Any(\"problem\", prob))\n\n\t\t\t\t// the account we have no longer exists on the CA, so we need to create a new one;\n\t\t\t\t// we could use the same key pair, but this is a good opportunity to rotate keys\n\t\t\t\t// (see https://caddy.community/t/acme-account-is-not-regenerated-when-acme-server-gets-reinstalled/22627)\n\t\t\t\t// (basically this happens if the CA gets reset or reinstalled; usually just internal PKI)\n\t\t\t\terr := am.deleteAccountLocally(ctx, client.iss.CA, client.account)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, usingTestCA, fmt.Errorf(\"%v ACME account no longer exists on CA, but resetting our local copy of the account info failed: %v\", nameSet, err)\n\t\t\t\t}\n\n\t\t\t\t// recreate account and try again\n\t\t\t\tclient, err = am.newACMEClientWithAccount(ctx, useTestCA, false)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, false, err\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, usingTestCA, fmt.Errorf(\"%v %w (ca=%s)\", nameSet, err, client.acmeClient.Directory)\n\t\t}\n\t\tif len(certChains) == 0 {\n\t\t\treturn nil, usingTestCA, fmt.Errorf(\"no certificate chains\")\n\t\t}\n\t\tbreak\n\t}\n\n\tpreferredChain := am.selectPreferredChain(certChains)\n\n\tic := &IssuedCertificate{\n\t\tCertificate: preferredChain.ChainPEM,\n\t\tMetadata:    preferredChain,\n\t}\n\n\tam.Logger.Debug(\"selected certificate chain\", zap.String(\"url\", preferredChain.URL))\n\n\treturn ic, usingTestCA, nil\n}\n\n// selectPreferredChain sorts and then filters the certificate chains to find the optimal\n// chain preferred by the client. If there's only one chain, that is returned without any\n// processing. If there are no matches, the first chain is returned.\nfunc (am *ACMEIssuer) selectPreferredChain(certChains []acme.Certificate) acme.Certificate {\n\tif len(certChains) == 1 {\n\t\tif len(am.PreferredChains.AnyCommonName) > 0 || len(am.PreferredChains.RootCommonName) > 0 {\n\t\t\tam.Logger.Debug(\"there is only one chain offered; selecting it regardless of preferences\",\n\t\t\t\tzap.String(\"chain_url\", certChains[0].URL))\n\t\t}\n\t\treturn certChains[0]\n\t}\n\n\tif am.PreferredChains.Smallest != nil {\n\t\tif *am.PreferredChains.Smallest {\n\t\t\tsort.Slice(certChains, func(i, j int) bool {\n\t\t\t\treturn len(certChains[i].ChainPEM) < len(certChains[j].ChainPEM)\n\t\t\t})\n\t\t} else {\n\t\t\tsort.Slice(certChains, func(i, j int) bool {\n\t\t\t\treturn len(certChains[i].ChainPEM) > len(certChains[j].ChainPEM)\n\t\t\t})\n\t\t}\n\t}\n\n\tif len(am.PreferredChains.AnyCommonName) > 0 || len(am.PreferredChains.RootCommonName) > 0 {\n\t\t// in order to inspect, we need to decode their PEM contents\n\t\tdecodedChains := make([][]*x509.Certificate, len(certChains))\n\t\tfor i, chain := range certChains {\n\t\t\tcerts, err := parseCertsFromPEMBundle(chain.ChainPEM)\n\t\t\tif err != nil {\n\t\t\t\tam.Logger.Error(\"unable to parse PEM certificate chain\",\n\t\t\t\t\tzap.Int(\"chain\", i),\n\t\t\t\t\tzap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdecodedChains[i] = certs\n\t\t}\n\n\t\tif len(am.PreferredChains.AnyCommonName) > 0 {\n\t\t\tfor _, prefAnyCN := range am.PreferredChains.AnyCommonName {\n\t\t\t\tfor i, chain := range decodedChains {\n\t\t\t\t\tfor _, cert := range chain {\n\t\t\t\t\t\tif cert.Issuer.CommonName == prefAnyCN {\n\t\t\t\t\t\t\tam.Logger.Debug(\"found preferred certificate chain by issuer common name\",\n\t\t\t\t\t\t\t\tzap.String(\"preference\", prefAnyCN),\n\t\t\t\t\t\t\t\tzap.Int(\"chain\", i))\n\t\t\t\t\t\t\treturn certChains[i]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif len(am.PreferredChains.RootCommonName) > 0 {\n\t\t\tfor _, prefRootCN := range am.PreferredChains.RootCommonName {\n\t\t\t\tfor i, chain := range decodedChains {\n\t\t\t\t\tif chain[len(chain)-1].Issuer.CommonName == prefRootCN {\n\t\t\t\t\t\tam.Logger.Debug(\"found preferred certificate chain by root common name\",\n\t\t\t\t\t\t\tzap.String(\"preference\", prefRootCN),\n\t\t\t\t\t\t\tzap.Int(\"chain\", i))\n\t\t\t\t\t\treturn certChains[i]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tam.Logger.Warn(\"did not find chain matching preferences; using first\")\n\t}\n\n\treturn certChains[0]\n}\n\n// Revoke implements the Revoker interface. It revokes the given certificate.\nfunc (am *ACMEIssuer) Revoke(ctx context.Context, cert CertificateResource, reason int) error {\n\tclient, err := am.newACMEClientWithAccount(ctx, false, false)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcerts, err := parseCertsFromPEMBundle(cert.CertificatePEM)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn client.revoke(ctx, certs[0], reason)\n}\n\n// ChainPreference describes the client's preferred certificate chain,\n// useful if the CA offers alternate chains. The first matching chain\n// will be selected.\ntype ChainPreference struct {\n\t// Prefer chains with the fewest number of bytes.\n\tSmallest *bool\n\n\t// Select first chain having a root with one of\n\t// these common names.\n\tRootCommonName []string\n\n\t// Select first chain that has any issuer with one\n\t// of these common names.\n\tAnyCommonName []string\n}\n\n// DefaultACME specifies default settings to use for ACMEIssuers.\n// Using this value is optional but can be convenient.\nvar DefaultACME = ACMEIssuer{\n\tCA:        LetsEncryptProductionCA,\n\tTestCA:    LetsEncryptStagingCA,\n\tLogger:    defaultLogger,\n\tHTTPProxy: http.ProxyFromEnvironment,\n}\n\n// Some well-known CA endpoints available to use. See\n// the documentation for each service; some may require\n// External Account Binding (EAB) and possibly payment.\n// COMPATIBILITY NOTICE: These constants refer to external\n// resources and are thus subject to change or removal\n// without a major version bump.\nconst (\n\tLetsEncryptStagingCA    = \"https://acme-staging-v02.api.letsencrypt.org/directory\" // https://letsencrypt.org/docs/staging-environment/\n\tLetsEncryptProductionCA = \"https://acme-v02.api.letsencrypt.org/directory\"         // https://letsencrypt.org/getting-started/\n\tZeroSSLProductionCA     = \"https://acme.zerossl.com/v2/DV90\"                       // https://zerossl.com/documentation/acme/\n\tGoogleTrustStagingCA    = \"https://dv.acme-v02.test-api.pki.goog/directory\"        // https://cloud.google.com/certificate-manager/docs/public-ca-tutorial\n\tGoogleTrustProductionCA = \"https://dv.acme-v02.api.pki.goog/directory\"             // https://cloud.google.com/certificate-manager/docs/public-ca-tutorial\n)\n\n// prefixACME is the storage key prefix used for ACME-specific assets.\nconst prefixACME = \"acme\"\n\ntype ctxKey string\n\nconst ctxKeyARIReplaces = ctxKey(\"ari_replaces\")\n\n// Interface guards\nvar (\n\t_ PreChecker = (*ACMEIssuer)(nil)\n\t_ Issuer     = (*ACMEIssuer)(nil)\n\t_ Revoker    = (*ACMEIssuer)(nil)\n)\n"
        },
        {
          "name": "acmeissuer_test.go",
          "type": "blob",
          "size": 0.0703125,
          "content": "package certmagic\n\nconst dummyCA = \"https://example.com/acme/directory\"\n"
        },
        {
          "name": "async.go",
          "type": "blob",
          "size": 5.0185546875,
          "content": "package certmagic\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"log\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n\n\t\"go.uber.org/zap\"\n)\n\nvar jm = &jobManager{maxConcurrentJobs: 1000}\n\ntype jobManager struct {\n\tmu                sync.Mutex\n\tmaxConcurrentJobs int\n\tactiveWorkers     int\n\tqueue             []namedJob\n\tnames             map[string]struct{}\n}\n\ntype namedJob struct {\n\tname   string\n\tjob    func() error\n\tlogger *zap.Logger\n}\n\n// Submit enqueues the given job with the given name. If name is non-empty\n// and a job with the same name is already enqueued or running, this is a\n// no-op. If name is empty, no duplicate prevention will occur. The job\n// manager will then run this job as soon as it is able.\nfunc (jm *jobManager) Submit(logger *zap.Logger, name string, job func() error) {\n\tjm.mu.Lock()\n\tdefer jm.mu.Unlock()\n\tif jm.names == nil {\n\t\tjm.names = make(map[string]struct{})\n\t}\n\tif name != \"\" {\n\t\t// prevent duplicate jobs\n\t\tif _, ok := jm.names[name]; ok {\n\t\t\treturn\n\t\t}\n\t\tjm.names[name] = struct{}{}\n\t}\n\tjm.queue = append(jm.queue, namedJob{name, job, logger})\n\tif jm.activeWorkers < jm.maxConcurrentJobs {\n\t\tjm.activeWorkers++\n\t\tgo jm.worker()\n\t}\n}\n\nfunc (jm *jobManager) worker() {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tbuf := make([]byte, stackTraceBufferSize)\n\t\t\tbuf = buf[:runtime.Stack(buf, false)]\n\t\t\tlog.Printf(\"panic: certificate worker: %v\\n%s\", err, buf)\n\t\t}\n\t}()\n\n\tfor {\n\t\tjm.mu.Lock()\n\t\tif len(jm.queue) == 0 {\n\t\t\tjm.activeWorkers--\n\t\t\tjm.mu.Unlock()\n\t\t\treturn\n\t\t}\n\t\tnext := jm.queue[0]\n\t\tjm.queue = jm.queue[1:]\n\t\tjm.mu.Unlock()\n\t\tif err := next.job(); err != nil {\n\t\t\tnext.logger.Error(\"job failed\", zap.Error(err))\n\t\t}\n\t\tif next.name != \"\" {\n\t\t\tjm.mu.Lock()\n\t\t\tdelete(jm.names, next.name)\n\t\t\tjm.mu.Unlock()\n\t\t}\n\t}\n}\n\nfunc doWithRetry(ctx context.Context, log *zap.Logger, f func(context.Context) error) error {\n\tvar attempts int\n\tctx = context.WithValue(ctx, AttemptsCtxKey, &attempts)\n\n\t// the initial intervalIndex is -1, signaling\n\t// that we should not wait for the first attempt\n\tstart, intervalIndex := time.Now(), -1\n\tvar err error\n\n\tfor time.Since(start) < maxRetryDuration {\n\t\tvar wait time.Duration\n\t\tif intervalIndex >= 0 {\n\t\t\twait = retryIntervals[intervalIndex]\n\t\t}\n\t\ttimer := time.NewTimer(wait)\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\ttimer.Stop()\n\t\t\treturn context.Canceled\n\t\tcase <-timer.C:\n\t\t\terr = f(ctx)\n\t\t\tattempts++\n\t\t\tif err == nil || errors.Is(err, context.Canceled) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tvar errNoRetry ErrNoRetry\n\t\t\tif errors.As(err, &errNoRetry) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif intervalIndex < len(retryIntervals)-1 {\n\t\t\t\tintervalIndex++\n\t\t\t}\n\t\t\tif time.Since(start) < maxRetryDuration {\n\t\t\t\tlog.Error(\"will retry\",\n\t\t\t\t\tzap.Error(err),\n\t\t\t\t\tzap.Int(\"attempt\", attempts),\n\t\t\t\t\tzap.Duration(\"retrying_in\", retryIntervals[intervalIndex]),\n\t\t\t\t\tzap.Duration(\"elapsed\", time.Since(start)),\n\t\t\t\t\tzap.Duration(\"max_duration\", maxRetryDuration))\n\n\t\t\t} else {\n\t\t\t\tlog.Error(\"final attempt; giving up\",\n\t\t\t\t\tzap.Error(err),\n\t\t\t\t\tzap.Int(\"attempt\", attempts),\n\t\t\t\t\tzap.Duration(\"elapsed\", time.Since(start)),\n\t\t\t\t\tzap.Duration(\"max_duration\", maxRetryDuration))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\treturn err\n}\n\n// ErrNoRetry is an error type which signals\n// to stop retries early.\ntype ErrNoRetry struct{ Err error }\n\n// Unwrap makes it so that e wraps e.Err.\nfunc (e ErrNoRetry) Unwrap() error { return e.Err }\nfunc (e ErrNoRetry) Error() string { return e.Err.Error() }\n\ntype retryStateCtxKey struct{}\n\n// AttemptsCtxKey is the context key for the value\n// that holds the attempt counter. The value counts\n// how many times the operation has been attempted.\n// A value of 0 means first attempt.\nvar AttemptsCtxKey retryStateCtxKey\n\n// retryIntervals are based on the idea of exponential\n// backoff, but weighed a little more heavily to the\n// front. We figure that intermittent errors would be\n// resolved after the first retry, but any errors after\n// that would probably require at least a few minutes\n// or hours to clear up: either for DNS to propagate, for\n// the administrator to fix their DNS or network config,\n// or some other external factor needs to change. We\n// chose intervals that we think will be most useful\n// without introducing unnecessary delay. The last\n// interval in this list will be used until the time\n// of maxRetryDuration has elapsed.\nvar retryIntervals = []time.Duration{\n\t1 * time.Minute,\n\t2 * time.Minute,\n\t2 * time.Minute,\n\t5 * time.Minute, // elapsed: 10 min\n\t10 * time.Minute,\n\t10 * time.Minute,\n\t10 * time.Minute,\n\t20 * time.Minute, // elapsed: 1 hr\n\t20 * time.Minute,\n\t20 * time.Minute,\n\t20 * time.Minute, // elapsed: 2 hr\n\t30 * time.Minute,\n\t30 * time.Minute, // elapsed: 3 hr\n\t30 * time.Minute,\n\t30 * time.Minute, // elapsed: 4 hr\n\t30 * time.Minute,\n\t30 * time.Minute, // elapsed: 5 hr\n\t1 * time.Hour,    // elapsed: 6 hr\n\t1 * time.Hour,\n\t1 * time.Hour, // elapsed: 8 hr\n\t2 * time.Hour,\n\t2 * time.Hour, // elapsed: 12 hr\n\t3 * time.Hour,\n\t3 * time.Hour, // elapsed: 18 hr\n\t6 * time.Hour, // repeat for up to maxRetryDuration\n}\n\n// maxRetryDuration is the maximum duration to try\n// doing retries using the above intervals.\nconst maxRetryDuration = 24 * time.Hour * 30\n"
        },
        {
          "name": "cache.go",
          "type": "blob",
          "size": 13.8984375,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"fmt\"\n\tweakrand \"math/rand\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"go.uber.org/zap\"\n)\n\n// Cache is a structure that stores certificates in memory.\n// A Cache indexes certificates by name for quick access\n// during TLS handshakes, and avoids duplicating certificates\n// in memory. Generally, there should only be one per process.\n// However, that is not a strict requirement; but using more\n// than one is a code smell, and may indicate an\n// over-engineered design.\n//\n// An empty cache is INVALID and must not be used. Be sure\n// to call NewCache to get a valid value.\n//\n// These should be very long-lived values and must not be\n// copied. Before all references leave scope to be garbage\n// collected, ensure you call Stop() to stop maintenance on\n// the certificates stored in this cache and release locks.\n//\n// Caches are not usually manipulated directly; create a\n// Config value with a pointer to a Cache, and then use\n// the Config to interact with the cache. Caches are\n// agnostic of any particular storage or ACME config,\n// since each certificate may be managed and stored\n// differently.\ntype Cache struct {\n\t// User configuration of the cache\n\toptions   CacheOptions\n\toptionsMu sync.RWMutex\n\n\t// The cache is keyed by certificate hash\n\tcache map[string]Certificate\n\n\t// cacheIndex is a map of SAN to cache key (cert hash)\n\tcacheIndex map[string][]string\n\n\t// Protects the cache and cacheIndex maps\n\tmu sync.RWMutex\n\n\t// Close this channel to cancel asset maintenance\n\tstopChan chan struct{}\n\n\t// Used to signal when stopping is completed\n\tdoneChan chan struct{}\n\n\tlogger *zap.Logger\n}\n\n// NewCache returns a new, valid Cache for efficiently\n// accessing certificates in memory. It also begins a\n// maintenance goroutine to tend to the certificates\n// in the cache. Call Stop() when you are done with the\n// cache so it can clean up locks and stuff.\n//\n// Most users of this package will not need to call this\n// because a default certificate cache is created for you.\n// Only advanced use cases require creating a new cache.\n//\n// This function panics if opts.GetConfigForCert is not\n// set. The reason is that a cache absolutely needs to\n// be able to get a Config with which to manage TLS\n// assets, and it is not safe to assume that the Default\n// config is always the correct one, since you have\n// created the cache yourself.\n//\n// See the godoc for Cache to use it properly. When\n// no longer needed, caches should be stopped with\n// Stop() to clean up resources even if the process\n// is being terminated, so that it can clean up\n// any locks for other processes to unblock!\nfunc NewCache(opts CacheOptions) *Cache {\n\t// assume default options if necessary\n\tif opts.OCSPCheckInterval <= 0 {\n\t\topts.OCSPCheckInterval = DefaultOCSPCheckInterval\n\t}\n\tif opts.RenewCheckInterval <= 0 {\n\t\topts.RenewCheckInterval = DefaultRenewCheckInterval\n\t}\n\tif opts.Capacity < 0 {\n\t\topts.Capacity = 0\n\t}\n\n\t// this must be set, because we cannot not\n\t// safely assume that the Default Config\n\t// is always the correct one to use\n\tif opts.GetConfigForCert == nil {\n\t\tpanic(\"cache must be initialized with a GetConfigForCert callback\")\n\t}\n\n\tc := &Cache{\n\t\toptions:    opts,\n\t\tcache:      make(map[string]Certificate),\n\t\tcacheIndex: make(map[string][]string),\n\t\tstopChan:   make(chan struct{}),\n\t\tdoneChan:   make(chan struct{}),\n\t\tlogger:     opts.Logger,\n\t}\n\n\t// absolutely do not allow a nil logger; panics galore\n\tif c.logger == nil {\n\t\tc.logger = defaultLogger\n\t}\n\n\tgo c.maintainAssets(0)\n\n\treturn c\n}\n\nfunc (certCache *Cache) SetOptions(opts CacheOptions) {\n\tcertCache.optionsMu.Lock()\n\tcertCache.options = opts\n\tcertCache.optionsMu.Unlock()\n}\n\n// Stop stops the maintenance goroutine for\n// certificates in certCache. It blocks until\n// stopping is complete. Once a cache is\n// stopped, it cannot be reused.\nfunc (certCache *Cache) Stop() {\n\tclose(certCache.stopChan) // signal to stop\n\t<-certCache.doneChan      // wait for stop to complete\n}\n\n// CacheOptions is used to configure certificate caches.\n// Once a cache has been created with certain options,\n// those settings cannot be changed.\ntype CacheOptions struct {\n\t// REQUIRED. A function that returns a configuration\n\t// used for managing a certificate, or for accessing\n\t// that certificate's asset storage (e.g. for\n\t// OCSP staples, etc). The returned Config MUST\n\t// be associated with the same Cache as the caller,\n\t// use New to obtain a valid Config.\n\t//\n\t// The reason this is a callback function, dynamically\n\t// returning a Config (instead of attaching a static\n\t// pointer to a Config on each certificate) is because\n\t// the config for how to manage a domain's certificate\n\t// might change from maintenance to maintenance. The\n\t// cache is so long-lived, we cannot assume that the\n\t// host's situation will always be the same; e.g. the\n\t// certificate might switch DNS providers, so the DNS\n\t// challenge (if used) would need to be adjusted from\n\t// the last time it was run ~8 weeks ago.\n\tGetConfigForCert ConfigGetter\n\n\t// How often to check certificates for renewal;\n\t// if unset, DefaultOCSPCheckInterval will be used.\n\tOCSPCheckInterval time.Duration\n\n\t// How often to check certificates for renewal;\n\t// if unset, DefaultRenewCheckInterval will be used.\n\tRenewCheckInterval time.Duration\n\n\t// Maximum number of certificates to allow in the cache.\n\t// If reached, certificates will be randomly evicted to\n\t// make room for new ones. 0 means unlimited.\n\tCapacity int\n\n\t// Set a logger to enable logging\n\tLogger *zap.Logger\n}\n\n// ConfigGetter is a function that returns a prepared,\n// valid config that should be used when managing the\n// given certificate or its assets.\ntype ConfigGetter func(Certificate) (*Config, error)\n\n// cacheCertificate calls unsyncedCacheCertificate with a write lock.\n//\n// This function is safe for concurrent use.\nfunc (certCache *Cache) cacheCertificate(cert Certificate) {\n\tcertCache.mu.Lock()\n\tcertCache.unsyncedCacheCertificate(cert)\n\tcertCache.mu.Unlock()\n}\n\n// unsyncedCacheCertificate adds cert to the in-memory cache unless\n// it already exists in the cache (according to cert.Hash). It\n// updates the name index.\n//\n// This function is NOT safe for concurrent use. Callers MUST acquire\n// a write lock on certCache.mu first.\nfunc (certCache *Cache) unsyncedCacheCertificate(cert Certificate) {\n\t// if this certificate already exists in the cache, this is basically\n\t// a no-op so we reuse existing cert (prevent duplication), but we do\n\t// modify the cert to add tags it may be missing (see issue #211)\n\tif existingCert, ok := certCache.cache[cert.hash]; ok {\n\t\tlogMsg := \"certificate already cached\"\n\n\t\tif len(cert.Tags) > 0 {\n\t\t\tfor _, tag := range cert.Tags {\n\t\t\t\tif !existingCert.HasTag(tag) {\n\t\t\t\t\texistingCert.Tags = append(existingCert.Tags, tag)\n\t\t\t\t}\n\t\t\t}\n\t\t\tcertCache.cache[cert.hash] = existingCert\n\t\t\tlogMsg += \"; appended any missing tags to cert\"\n\t\t}\n\n\t\tcertCache.logger.Debug(logMsg,\n\t\t\tzap.Strings(\"subjects\", cert.Names),\n\t\t\tzap.Time(\"expiration\", expiresAt(cert.Leaf)),\n\t\t\tzap.Bool(\"managed\", cert.managed),\n\t\t\tzap.String(\"issuer_key\", cert.issuerKey),\n\t\t\tzap.String(\"hash\", cert.hash),\n\t\t\tzap.Strings(\"tags\", cert.Tags))\n\t\treturn\n\t}\n\n\t// if the cache is at capacity, make room for new cert\n\tcacheSize := len(certCache.cache)\n\tcertCache.optionsMu.RLock()\n\tatCapacity := certCache.options.Capacity > 0 && cacheSize >= certCache.options.Capacity\n\tcertCache.optionsMu.RUnlock()\n\n\tif atCapacity {\n\t\t// Go maps are \"nondeterministic\" but not actually random,\n\t\t// so although we could just chop off the \"front\" of the\n\t\t// map with less code, that is a heavily skewed eviction\n\t\t// strategy; generating random numbers is cheap and\n\t\t// ensures a much better distribution.\n\t\trnd := weakrand.Intn(cacheSize)\n\t\ti := 0\n\t\tfor _, randomCert := range certCache.cache {\n\t\t\tif i == rnd {\n\t\t\t\tcertCache.logger.Debug(\"cache full; evicting random certificate\",\n\t\t\t\t\tzap.Strings(\"removing_subjects\", randomCert.Names),\n\t\t\t\t\tzap.String(\"removing_hash\", randomCert.hash),\n\t\t\t\t\tzap.Strings(\"inserting_subjects\", cert.Names),\n\t\t\t\t\tzap.String(\"inserting_hash\", cert.hash))\n\t\t\t\tcertCache.removeCertificate(randomCert)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t}\n\n\t// store the certificate\n\tcertCache.cache[cert.hash] = cert\n\n\t// update the index so we can access it by name\n\tfor _, name := range cert.Names {\n\t\tcertCache.cacheIndex[name] = append(certCache.cacheIndex[name], cert.hash)\n\t}\n\n\tcertCache.optionsMu.RLock()\n\tcertCache.logger.Debug(\"added certificate to cache\",\n\t\tzap.Strings(\"subjects\", cert.Names),\n\t\tzap.Time(\"expiration\", expiresAt(cert.Leaf)),\n\t\tzap.Bool(\"managed\", cert.managed),\n\t\tzap.String(\"issuer_key\", cert.issuerKey),\n\t\tzap.String(\"hash\", cert.hash),\n\t\tzap.Int(\"cache_size\", len(certCache.cache)),\n\t\tzap.Int(\"cache_capacity\", certCache.options.Capacity))\n\tcertCache.optionsMu.RUnlock()\n}\n\n// removeCertificate removes cert from the cache.\n//\n// This function is NOT safe for concurrent use; callers\n// MUST first acquire a write lock on certCache.mu.\nfunc (certCache *Cache) removeCertificate(cert Certificate) {\n\t// delete all mentions of this cert from the name index\n\tfor _, name := range cert.Names {\n\t\tkeyList := certCache.cacheIndex[name]\n\t\tfor i := 0; i < len(keyList); i++ {\n\t\t\tif keyList[i] == cert.hash {\n\t\t\t\tkeyList = append(keyList[:i], keyList[i+1:]...)\n\t\t\t\ti--\n\t\t\t}\n\t\t}\n\t\tif len(keyList) == 0 {\n\t\t\tdelete(certCache.cacheIndex, name)\n\t\t} else {\n\t\t\tcertCache.cacheIndex[name] = keyList\n\t\t}\n\t}\n\n\t// delete the actual cert from the cache\n\tdelete(certCache.cache, cert.hash)\n\n\tcertCache.optionsMu.RLock()\n\tcertCache.logger.Debug(\"removed certificate from cache\",\n\t\tzap.Strings(\"subjects\", cert.Names),\n\t\tzap.Time(\"expiration\", expiresAt(cert.Leaf)),\n\t\tzap.Bool(\"managed\", cert.managed),\n\t\tzap.String(\"issuer_key\", cert.issuerKey),\n\t\tzap.String(\"hash\", cert.hash),\n\t\tzap.Int(\"cache_size\", len(certCache.cache)),\n\t\tzap.Int(\"cache_capacity\", certCache.options.Capacity))\n\tcertCache.optionsMu.RUnlock()\n}\n\n// replaceCertificate atomically replaces oldCert with newCert in\n// the cache.\n//\n// This method is safe for concurrent use.\nfunc (certCache *Cache) replaceCertificate(oldCert, newCert Certificate) {\n\tcertCache.mu.Lock()\n\tcertCache.removeCertificate(oldCert)\n\tcertCache.unsyncedCacheCertificate(newCert)\n\tcertCache.mu.Unlock()\n\tcertCache.logger.Info(\"replaced certificate in cache\",\n\t\tzap.Strings(\"subjects\", newCert.Names),\n\t\tzap.Time(\"new_expiration\", expiresAt(newCert.Leaf)))\n}\n\n// getAllMatchingCerts returns all certificates with exactly this subject\n// (wildcards are NOT expanded).\nfunc (certCache *Cache) getAllMatchingCerts(subject string) []Certificate {\n\tcertCache.mu.RLock()\n\tdefer certCache.mu.RUnlock()\n\n\tallCertKeys := certCache.cacheIndex[subject]\n\n\tcerts := make([]Certificate, len(allCertKeys))\n\tfor i := range allCertKeys {\n\t\tcerts[i] = certCache.cache[allCertKeys[i]]\n\t}\n\n\treturn certs\n}\n\nfunc (certCache *Cache) getAllCerts() []Certificate {\n\tcertCache.mu.RLock()\n\tdefer certCache.mu.RUnlock()\n\tcerts := make([]Certificate, 0, len(certCache.cache))\n\tfor _, cert := range certCache.cache {\n\t\tcerts = append(certs, cert)\n\t}\n\treturn certs\n}\n\nfunc (certCache *Cache) getConfig(cert Certificate) (*Config, error) {\n\tcertCache.optionsMu.RLock()\n\tgetCert := certCache.options.GetConfigForCert\n\tcertCache.optionsMu.RUnlock()\n\n\tcfg, err := getCert(cert)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif cfg.certCache == nil {\n\t\treturn nil, fmt.Errorf(\"config returned for certificate %v has nil cache; expected %p (this one)\",\n\t\t\tcert.Names, certCache)\n\t}\n\tif cfg.certCache != certCache {\n\t\treturn nil, fmt.Errorf(\"config returned for certificate %v is not nil and points to different cache; got %p, expected %p (this one)\",\n\t\t\tcert.Names, cfg.certCache, certCache)\n\t}\n\treturn cfg, nil\n}\n\n// AllMatchingCertificates returns a list of all certificates that could\n// be used to serve the given SNI name, including exact SAN matches and\n// wildcard matches.\nfunc (certCache *Cache) AllMatchingCertificates(name string) []Certificate {\n\t// get exact matches first\n\tcerts := certCache.getAllMatchingCerts(name)\n\n\t// then look for wildcard matches by replacing each\n\t// label of the domain name with wildcards\n\tlabels := strings.Split(name, \".\")\n\tfor i := range labels {\n\t\tlabels[i] = \"*\"\n\t\tcandidate := strings.Join(labels, \".\")\n\t\tcerts = append(certs, certCache.getAllMatchingCerts(candidate)...)\n\t}\n\n\treturn certs\n}\n\n// SubjectIssuer pairs a subject name with an issuer ID/key.\ntype SubjectIssuer struct {\n\tSubject, IssuerKey string\n}\n\n// RemoveManaged removes managed certificates for the given subjects from the cache.\n// This effectively stops maintenance of those certificates. If an IssuerKey is\n// specified alongside the subject, only certificates for that subject from the\n// specified issuer will be removed.\nfunc (certCache *Cache) RemoveManaged(subjects []SubjectIssuer) {\n\tdeleteQueue := make([]string, 0, len(subjects))\n\tfor _, subj := range subjects {\n\t\tcerts := certCache.getAllMatchingCerts(subj.Subject) // does NOT expand wildcards; exact matches only\n\t\tfor _, cert := range certs {\n\t\t\tif !cert.managed {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif subj.IssuerKey == \"\" || cert.issuerKey == subj.IssuerKey {\n\t\t\t\tdeleteQueue = append(deleteQueue, cert.hash)\n\t\t\t}\n\t\t}\n\t}\n\tcertCache.Remove(deleteQueue)\n}\n\n// Remove removes certificates with the given hashes from the cache.\n// This is effectively used to unload manually-loaded certificates.\nfunc (certCache *Cache) Remove(hashes []string) {\n\tcertCache.mu.Lock()\n\tfor _, h := range hashes {\n\t\tcert := certCache.cache[h]\n\t\tcertCache.removeCertificate(cert)\n\t}\n\tcertCache.mu.Unlock()\n}\n\nvar (\n\tdefaultCache   *Cache\n\tdefaultCacheMu sync.Mutex\n)\n"
        },
        {
          "name": "cache_test.go",
          "type": "blob",
          "size": 1.45703125,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport \"testing\"\n\nfunc TestNewCache(t *testing.T) {\n\tnoop := func(Certificate) (*Config, error) { return new(Config), nil }\n\tc := NewCache(CacheOptions{GetConfigForCert: noop})\n\tdefer c.Stop()\n\n\tc.optionsMu.RLock()\n\tdefer c.optionsMu.RUnlock()\n\n\tif c.options.RenewCheckInterval != DefaultRenewCheckInterval {\n\t\tt.Errorf(\"Expected RenewCheckInterval to be set to default value, but it wasn't: %s\", c.options.RenewCheckInterval)\n\t}\n\tif c.options.OCSPCheckInterval != DefaultOCSPCheckInterval {\n\t\tt.Errorf(\"Expected OCSPCheckInterval to be set to default value, but it wasn't: %s\", c.options.OCSPCheckInterval)\n\t}\n\tif c.options.GetConfigForCert == nil {\n\t\tt.Error(\"Expected GetConfigForCert to be set, but it was nil\")\n\t}\n\tif c.cache == nil {\n\t\tt.Error(\"Expected cache to be set, but it was nil\")\n\t}\n\tif c.stopChan == nil {\n\t\tt.Error(\"Expected stopChan to be set, but it was nil\")\n\t}\n}\n"
        },
        {
          "name": "certificates.go",
          "type": "blob",
          "size": 23.681640625,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/mholt/acmez/v3/acme\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/crypto/ocsp\"\n)\n\n// Certificate is a tls.Certificate with associated metadata tacked on.\n// Even if the metadata can be obtained by parsing the certificate,\n// we are more efficient by extracting the metadata onto this struct,\n// but at the cost of slightly higher memory use.\ntype Certificate struct {\n\ttls.Certificate\n\n\t// Names is the list of subject names this\n\t// certificate is signed for.\n\tNames []string\n\n\t// Optional; user-provided, and arbitrary.\n\tTags []string\n\n\t// OCSP contains the certificate's parsed OCSP response.\n\t// It is not necessarily the response that is stapled\n\t// (e.g. if the status is not Good), it is simply the\n\t// most recent OCSP response we have for this certificate.\n\tocsp *ocsp.Response\n\n\t// The hex-encoded hash of this cert's chain's DER bytes.\n\thash string\n\n\t// Whether this certificate is under our management.\n\tmanaged bool\n\n\t// The unique string identifying the issuer of this certificate.\n\tissuerKey string\n\n\t// ACME Renewal Information, if available\n\tari acme.RenewalInfo\n}\n\n// Empty returns true if the certificate struct is not filled out; at\n// least the tls.Certificate.Certificate field is expected to be set.\nfunc (cert Certificate) Empty() bool {\n\treturn len(cert.Certificate.Certificate) == 0\n}\n\n// Hash returns a checksum of the certificate chain's DER-encoded bytes.\nfunc (cert Certificate) Hash() string { return cert.hash }\n\n// NeedsRenewal returns true if the certificate is expiring\n// soon (according to ARI and/or cfg) or has expired.\nfunc (cert Certificate) NeedsRenewal(cfg *Config) bool {\n\treturn cfg.certNeedsRenewal(cert.Leaf, cert.ari, true)\n}\n\n// certNeedsRenewal consults ACME Renewal Info (ARI) and certificate expiration to determine\n// whether the leaf certificate needs to be renewed yet. If true is returned, the certificate\n// should be renewed as soon as possible. The reasoning for a true return value is logged\n// unless emitLogs is false; this can be useful to suppress noisy logs in the case where you\n// first call this to determine if a cert in memory needs renewal, and then right after you\n// call it again to see if the cert in storage still needs renewal -- you probably don't want\n// to log the second time for checking the cert in storage which is mainly for synchronization.\nfunc (cfg *Config) certNeedsRenewal(leaf *x509.Certificate, ari acme.RenewalInfo, emitLogs bool) bool {\n\texpiration := expiresAt(leaf)\n\n\tvar logger *zap.Logger\n\tif emitLogs {\n\t\tlogger = cfg.Logger.With(\n\t\t\tzap.Strings(\"subjects\", leaf.DNSNames),\n\t\t\tzap.Time(\"expiration\", expiration),\n\t\t\tzap.String(\"ari_cert_id\", ari.UniqueIdentifier),\n\t\t\tzap.Timep(\"next_ari_update\", ari.RetryAfter),\n\t\t\tzap.Duration(\"renew_check_interval\", cfg.certCache.options.RenewCheckInterval),\n\t\t\tzap.Time(\"window_start\", ari.SuggestedWindow.Start),\n\t\t\tzap.Time(\"window_end\", ari.SuggestedWindow.End))\n\t} else {\n\t\tlogger = zap.NewNop()\n\t}\n\n\tif !cfg.DisableARI {\n\t\t// first check ARI: if it says it's time to renew, it's time to renew\n\t\t// (notice that we don't strictly require an ARI window to also exist; we presume\n\t\t// that if a time has been selected, a window does or did exist, even if it didn't\n\t\t// get stored/encoded for some reason - but also: this allows administrators to\n\t\t// manually or explicitly schedule a renewal time independently of ARI which could\n\t\t// be useful)\n\t\tselectedTime := ari.SelectedTime\n\n\t\t// if, for some reason a random time in the window hasn't been selected yet, but an ARI\n\t\t// window does exist, we can always improvise one... even if this is called repeatedly,\n\t\t// a random time is a random time, whether you generate it once or more :D\n\t\t// (code borrowed from our acme package)\n\t\tif selectedTime.IsZero() &&\n\t\t\t(!ari.SuggestedWindow.Start.IsZero() && !ari.SuggestedWindow.End.IsZero()) {\n\t\t\tstart, end := ari.SuggestedWindow.Start.Unix()+1, ari.SuggestedWindow.End.Unix()\n\t\t\tselectedTime = time.Unix(rand.Int63n(end-start)+start, 0).UTC()\n\t\t\tlogger.Warn(\"no renewal time had been selected with ARI; chose an ephemeral one for now\",\n\t\t\t\tzap.Time(\"ephemeral_selected_time\", selectedTime))\n\t\t}\n\n\t\t// if a renewal time has been selected, start with that\n\t\tif !selectedTime.IsZero() {\n\t\t\t// ARI spec recommends an algorithm that renews after the randomly-selected\n\t\t\t// time OR just before it if the next waking time would be after it; this\n\t\t\t// cutoff can actually be before the start of the renewal window, but the spec\n\t\t\t// author says that's OK: https://github.com/aarongable/draft-acme-ari/issues/71\n\t\t\tcutoff := ari.SelectedTime.Add(-cfg.certCache.options.RenewCheckInterval)\n\t\t\tif time.Now().After(cutoff) {\n\t\t\t\tlogger.Info(\"certificate needs renewal based on ARI window\",\n\t\t\t\t\tzap.Time(\"selected_time\", selectedTime),\n\t\t\t\t\tzap.Time(\"renewal_cutoff\", cutoff))\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\t// according to ARI, we are not ready to renew; however, we do not rely solely on\n\t\t\t// ARI calculations... what if there is a bug in our implementation, or in the\n\t\t\t// server's, or the stored metadata? for redundancy, give credence to the expiration\n\t\t\t// date; ignore ARI if we are past a \"dangerously close\" limit, to avoid any\n\t\t\t// possibility of a bug in ARI compromising a site's uptime: we should always always\n\t\t\t// always give heed to actual validity period\n\t\t\tif currentlyInRenewalWindow(leaf.NotBefore, expiration, 1.0/20.0) {\n\t\t\t\tlogger.Warn(\"certificate is in emergency renewal window; superseding ARI\",\n\t\t\t\t\tzap.Duration(\"remaining\", time.Until(expiration)),\n\t\t\t\t\tzap.Time(\"renewal_cutoff\", cutoff))\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\t// the normal check, in the absence of ARI, is to determine if we're near enough (or past)\n\t// the expiration date based on the configured remaining:lifetime ratio\n\tif currentlyInRenewalWindow(leaf.NotBefore, expiration, cfg.RenewalWindowRatio) {\n\t\tlogger.Info(\"certificate is in configured renewal window based on expiration date\",\n\t\t\tzap.Duration(\"remaining\", time.Until(expiration)))\n\t\treturn true\n\t}\n\n\t// finally, if the certificate is expiring imminently, always attempt a renewal;\n\t// we check both a (very low) lifetime ratio and also a strict difference between\n\t// the time until expiration and the interval at which we run the standard maintenance\n\t// routine to check for renewals, to accommodate both exceptionally long and short\n\t// cert lifetimes\n\tif currentlyInRenewalWindow(leaf.NotBefore, expiration, 1.0/50.0) ||\n\t\ttime.Until(expiration) < cfg.certCache.options.RenewCheckInterval*5 {\n\t\tlogger.Warn(\"certificate is in emergency renewal window; expiration imminent\",\n\t\t\tzap.Duration(\"remaining\", time.Until(expiration)))\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// Expired returns true if the certificate has expired.\nfunc (cert Certificate) Expired() bool {\n\tif cert.Leaf == nil {\n\t\t// ideally cert.Leaf would never be nil, but this can happen for\n\t\t// \"synthetic\" certs like those made to solve the TLS-ALPN challenge\n\t\t// which adds a special cert directly  to the cache, since\n\t\t// tls.X509KeyPair() discards the leaf; oh well\n\t\treturn false\n\t}\n\treturn time.Now().After(expiresAt(cert.Leaf))\n}\n\n// Lifetime returns the duration of the certificate's validity.\nfunc (cert Certificate) Lifetime() time.Duration {\n\tif cert.Leaf == nil || cert.Leaf.NotAfter.IsZero() {\n\t\treturn 0\n\t}\n\treturn expiresAt(cert.Leaf).Sub(cert.Leaf.NotBefore)\n}\n\n// currentlyInRenewalWindow returns true if the current time is within\n// (or after) the renewal window, according to the given start/end\n// dates and the ratio of the renewal window. If true is returned,\n// the certificate being considered is due for renewal. The ratio\n// is remaining:total time, i.e. 1/3 = 1/3 of lifetime remaining,\n// or 9/10 = 9/10 of time lifetime remaining.\nfunc currentlyInRenewalWindow(notBefore, notAfter time.Time, renewalWindowRatio float64) bool {\n\tif notAfter.IsZero() {\n\t\treturn false\n\t}\n\tlifetime := notAfter.Sub(notBefore)\n\tif renewalWindowRatio == 0 {\n\t\trenewalWindowRatio = DefaultRenewalWindowRatio\n\t}\n\trenewalWindow := time.Duration(float64(lifetime) * renewalWindowRatio)\n\trenewalWindowStart := notAfter.Add(-renewalWindow)\n\treturn time.Now().After(renewalWindowStart)\n}\n\n// HasTag returns true if cert.Tags has tag.\nfunc (cert Certificate) HasTag(tag string) bool {\n\tfor _, t := range cert.Tags {\n\t\tif t == tag {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// expiresAt return the time that a certificate expires. Account for the 1s\n// resolution of ASN.1 UTCTime/GeneralizedTime by including the extra fraction\n// of a second of certificate validity beyond the NotAfter value.\nfunc expiresAt(cert *x509.Certificate) time.Time {\n\tif cert == nil {\n\t\treturn time.Time{}\n\t}\n\treturn cert.NotAfter.Truncate(time.Second).Add(1 * time.Second)\n}\n\n// CacheManagedCertificate loads the certificate for domain into the\n// cache, from the TLS storage for managed certificates. It returns a\n// copy of the Certificate that was put into the cache.\n//\n// This is a lower-level method; normally you'll call Manage() instead.\n//\n// This method is safe for concurrent use.\nfunc (cfg *Config) CacheManagedCertificate(ctx context.Context, domain string) (Certificate, error) {\n\tdomain = cfg.transformSubject(ctx, nil, domain)\n\tcert, err := cfg.loadManagedCertificate(ctx, domain)\n\tif err != nil {\n\t\treturn cert, err\n\t}\n\tcfg.certCache.cacheCertificate(cert)\n\tcfg.emit(ctx, \"cached_managed_cert\", map[string]any{\"sans\": cert.Names})\n\treturn cert, nil\n}\n\n// loadManagedCertificate loads the managed certificate for domain from any\n// of the configured issuers' storage locations, but it does not add it to\n// the cache. It just loads from storage and returns it.\nfunc (cfg *Config) loadManagedCertificate(ctx context.Context, domain string) (Certificate, error) {\n\tcertRes, err := cfg.loadCertResourceAnyIssuer(ctx, domain)\n\tif err != nil {\n\t\treturn Certificate{}, err\n\t}\n\tcert, err := cfg.makeCertificateWithOCSP(ctx, certRes.CertificatePEM, certRes.PrivateKeyPEM)\n\tif err != nil {\n\t\treturn cert, err\n\t}\n\tcert.managed = true\n\tcert.issuerKey = certRes.issuerKey\n\tif ari, err := certRes.getARI(); err == nil && ari != nil {\n\t\tcert.ari = *ari\n\t}\n\treturn cert, nil\n}\n\n// getARI unpacks ACME Renewal Information from the issuer data, if available.\n// It is only an error if there is invalid JSON.\nfunc (certRes CertificateResource) getARI() (*acme.RenewalInfo, error) {\n\tacmeData, err := certRes.getACMEData()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn acmeData.RenewalInfo, nil\n}\n\n// getACMEData returns the ACME certificate metadata from the IssuerData, but\n// note that a non-ACME-issued certificate may return an empty value and nil\n// since the JSON may still decode successfully but just not match any or all\n// of the fields. Remember that the IssuerKey is used to store and access the\n// cert files in the first place (it is part of the path) so in theory if you\n// load a CertificateResource from an ACME issuer it should work as expected.\nfunc (certRes CertificateResource) getACMEData() (acme.Certificate, error) {\n\tif len(certRes.IssuerData) == 0 {\n\t\treturn acme.Certificate{}, nil\n\t}\n\tvar acmeCert acme.Certificate\n\terr := json.Unmarshal(certRes.IssuerData, &acmeCert)\n\treturn acmeCert, err\n}\n\n// CacheUnmanagedCertificatePEMFile loads a certificate for host using certFile\n// and keyFile, which must be in PEM format. It stores the certificate in\n// the in-memory cache and returns the hash, useful for removing from the cache.\n//\n// This method is safe for concurrent use.\nfunc (cfg *Config) CacheUnmanagedCertificatePEMFile(ctx context.Context, certFile, keyFile string, tags []string) (string, error) {\n\tcert, err := cfg.makeCertificateFromDiskWithOCSP(ctx, certFile, keyFile)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tcert.Tags = tags\n\tcfg.certCache.cacheCertificate(cert)\n\tcfg.emit(ctx, \"cached_unmanaged_cert\", map[string]any{\"sans\": cert.Names})\n\treturn cert.hash, nil\n}\n\n// CacheUnmanagedTLSCertificate adds tlsCert to the certificate cache\n//\n//\tand returns the hash, useful for removing from the cache.\n//\n// It staples OCSP if possible.\n//\n// This method is safe for concurrent use.\nfunc (cfg *Config) CacheUnmanagedTLSCertificate(ctx context.Context, tlsCert tls.Certificate, tags []string) (string, error) {\n\tvar cert Certificate\n\terr := fillCertFromLeaf(&cert, tlsCert)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif time.Now().After(cert.Leaf.NotAfter) {\n\t\tcfg.Logger.Warn(\"unmanaged certificate has expired\",\n\t\t\tzap.Time(\"not_after\", cert.Leaf.NotAfter),\n\t\t\tzap.Strings(\"sans\", cert.Names))\n\t} else if time.Until(cert.Leaf.NotAfter) < 24*time.Hour {\n\t\tcfg.Logger.Warn(\"unmanaged certificate expires within 1 day\",\n\t\t\tzap.Time(\"not_after\", cert.Leaf.NotAfter),\n\t\t\tzap.Strings(\"sans\", cert.Names))\n\t}\n\terr = stapleOCSP(ctx, cfg.OCSP, cfg.Storage, &cert, nil)\n\tif err != nil {\n\t\tcfg.Logger.Warn(\"stapling OCSP\", zap.Error(err))\n\t}\n\tcfg.emit(ctx, \"cached_unmanaged_cert\", map[string]any{\"sans\": cert.Names})\n\tcert.Tags = tags\n\tcfg.certCache.cacheCertificate(cert)\n\treturn cert.hash, nil\n}\n\n// CacheUnmanagedCertificatePEMBytes makes a certificate out of the PEM bytes\n// of the certificate and key, then caches it in memory,  and returns the hash,\n// which is useful for removing from the cache.\n//\n// This method is safe for concurrent use.\nfunc (cfg *Config) CacheUnmanagedCertificatePEMBytes(ctx context.Context, certBytes, keyBytes []byte, tags []string) (string, error) {\n\tcert, err := cfg.makeCertificateWithOCSP(ctx, certBytes, keyBytes)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tcert.Tags = tags\n\tcfg.certCache.cacheCertificate(cert)\n\tcfg.emit(ctx, \"cached_unmanaged_cert\", map[string]any{\"sans\": cert.Names})\n\treturn cert.hash, nil\n}\n\n// makeCertificateFromDiskWithOCSP makes a Certificate by loading the\n// certificate and key files. It fills out all the fields in\n// the certificate except for the Managed and OnDemand flags.\n// (It is up to the caller to set those.) It staples OCSP.\nfunc (cfg Config) makeCertificateFromDiskWithOCSP(ctx context.Context, certFile, keyFile string) (Certificate, error) {\n\tcertPEMBlock, err := os.ReadFile(certFile)\n\tif err != nil {\n\t\treturn Certificate{}, err\n\t}\n\tkeyPEMBlock, err := os.ReadFile(keyFile)\n\tif err != nil {\n\t\treturn Certificate{}, err\n\t}\n\treturn cfg.makeCertificateWithOCSP(ctx, certPEMBlock, keyPEMBlock)\n}\n\n// makeCertificateWithOCSP is the same as makeCertificate except that it also\n// staples OCSP to the certificate.\nfunc (cfg Config) makeCertificateWithOCSP(ctx context.Context, certPEMBlock, keyPEMBlock []byte) (Certificate, error) {\n\tcert, err := makeCertificate(certPEMBlock, keyPEMBlock)\n\tif err != nil {\n\t\treturn cert, err\n\t}\n\terr = stapleOCSP(ctx, cfg.OCSP, cfg.Storage, &cert, certPEMBlock)\n\tif err != nil {\n\t\tcfg.Logger.Warn(\"stapling OCSP\", zap.Error(err), zap.Strings(\"identifiers\", cert.Names))\n\t}\n\treturn cert, nil\n}\n\n// makeCertificate turns a certificate PEM bundle and a key PEM block into\n// a Certificate with necessary metadata from parsing its bytes filled into\n// its struct fields for convenience (except for the OnDemand and Managed\n// flags; it is up to the caller to set those properties!). This function\n// does NOT staple OCSP.\nfunc makeCertificate(certPEMBlock, keyPEMBlock []byte) (Certificate, error) {\n\tvar cert Certificate\n\n\t// Convert to a tls.Certificate\n\ttlsCert, err := tls.X509KeyPair(certPEMBlock, keyPEMBlock)\n\tif err != nil {\n\t\treturn cert, err\n\t}\n\n\t// Extract necessary metadata\n\terr = fillCertFromLeaf(&cert, tlsCert)\n\tif err != nil {\n\t\treturn cert, err\n\t}\n\n\treturn cert, nil\n}\n\n// fillCertFromLeaf populates cert from tlsCert. If it succeeds, it\n// guarantees that cert.Leaf is non-nil.\nfunc fillCertFromLeaf(cert *Certificate, tlsCert tls.Certificate) error {\n\tif len(tlsCert.Certificate) == 0 {\n\t\treturn fmt.Errorf(\"certificate is empty\")\n\t}\n\tcert.Certificate = tlsCert\n\n\t// the leaf cert should be the one for the site; we must set\n\t// the tls.Certificate.Leaf field so that TLS handshakes are\n\t// more efficient\n\tleaf := cert.Certificate.Leaf\n\tif leaf == nil {\n\t\tvar err error\n\t\tleaf, err = x509.ParseCertificate(tlsCert.Certificate[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcert.Certificate.Leaf = leaf\n\t}\n\n\t// for convenience, we do want to assemble all the\n\t// subjects on the certificate into one list\n\tif leaf.Subject.CommonName != \"\" { // TODO: CommonName is deprecated\n\t\tcert.Names = []string{strings.ToLower(leaf.Subject.CommonName)}\n\t}\n\tfor _, name := range leaf.DNSNames {\n\t\tif name != leaf.Subject.CommonName { // TODO: CommonName is deprecated\n\t\t\tcert.Names = append(cert.Names, strings.ToLower(name))\n\t\t}\n\t}\n\tfor _, ip := range leaf.IPAddresses {\n\t\tif ipStr := ip.String(); ipStr != leaf.Subject.CommonName { // TODO: CommonName is deprecated\n\t\t\tcert.Names = append(cert.Names, strings.ToLower(ipStr))\n\t\t}\n\t}\n\tfor _, email := range leaf.EmailAddresses {\n\t\tif email != leaf.Subject.CommonName { // TODO: CommonName is deprecated\n\t\t\tcert.Names = append(cert.Names, strings.ToLower(email))\n\t\t}\n\t}\n\tfor _, u := range leaf.URIs {\n\t\tif u.String() != leaf.Subject.CommonName { // TODO: CommonName is deprecated\n\t\t\tcert.Names = append(cert.Names, u.String())\n\t\t}\n\t}\n\tif len(cert.Names) == 0 {\n\t\treturn fmt.Errorf(\"certificate has no names\")\n\t}\n\n\tcert.hash = hashCertificateChain(cert.Certificate.Certificate)\n\n\treturn nil\n}\n\n// managedCertInStorageNeedsRenewal returns true if cert (being a\n// managed certificate) is expiring soon (according to cfg) or if\n// ACME Renewal Information (ARI) is available and says that it is\n// time to renew (it uses existing ARI; it does not update it).\n// It returns false if there was an error, the cert is not expiring\n// soon, and ARI window is still future. A certificate that is expiring\n// soon in our cache but is not expiring soon in storage probably\n// means that another instance renewed the certificate in the\n// meantime, and it would be a good idea to simply load the cert\n// into our cache rather than repeating the renewal process again.\nfunc (cfg *Config) managedCertInStorageNeedsRenewal(ctx context.Context, cert Certificate) (bool, error) {\n\tcertRes, err := cfg.loadCertResourceAnyIssuer(ctx, cert.Names[0])\n\tif err != nil {\n\t\treturn false, err\n\t}\n\t_, _, needsRenew := cfg.managedCertNeedsRenewal(certRes, false)\n\treturn needsRenew, nil\n}\n\n// reloadManagedCertificate reloads the certificate corresponding to the name(s)\n// on oldCert into the cache, from storage. This also replaces the old certificate\n// with the new one, so that all configurations that used the old cert now point\n// to the new cert. It assumes that the new certificate for oldCert.Names[0] is\n// already in storage. It returns the newly-loaded certificate if successful.\nfunc (cfg *Config) reloadManagedCertificate(ctx context.Context, oldCert Certificate) (Certificate, error) {\n\tcfg.Logger.Info(\"reloading managed certificate\", zap.Strings(\"identifiers\", oldCert.Names))\n\tnewCert, err := cfg.loadManagedCertificate(ctx, oldCert.Names[0])\n\tif err != nil {\n\t\treturn Certificate{}, fmt.Errorf(\"loading managed certificate for %v from storage: %v\", oldCert.Names, err)\n\t}\n\tcfg.certCache.replaceCertificate(oldCert, newCert)\n\treturn newCert, nil\n}\n\n// SubjectQualifiesForCert returns true if subj is a name which,\n// as a quick sanity check, looks like it could be the subject\n// of a certificate. Requirements are:\n// - must not be empty\n// - must not start or end with a dot (RFC 1034; RFC 6066 section 3)\n// - must not contain common accidental special characters\nfunc SubjectQualifiesForCert(subj string) bool {\n\t// must not be empty\n\treturn strings.TrimSpace(subj) != \"\" &&\n\n\t\t// must not start or end with a dot\n\t\t!strings.HasPrefix(subj, \".\") &&\n\t\t!strings.HasSuffix(subj, \".\") &&\n\n\t\t// if it has a wildcard, must be a left-most label (or exactly \"*\"\n\t\t// which won't be trusted by browsers but still technically works)\n\t\t(!strings.Contains(subj, \"*\") || strings.HasPrefix(subj, \"*.\") || subj == \"*\") &&\n\n\t\t// must not contain other common special characters\n\t\t!strings.ContainsAny(subj, \"()[]{}<> \\t\\n\\\"\\\\!@#$%^&|;'+=\")\n}\n\n// SubjectQualifiesForPublicCert returns true if the subject\n// name appears eligible for automagic TLS with a public\n// CA such as Let's Encrypt. For example: internal IP addresses\n// and localhost are not eligible because we cannot obtain certs\n// for those names with a public CA. Wildcard names are\n// allowed, as long as they conform to CABF requirements (only\n// one wildcard label, and it must be the left-most label).\nfunc SubjectQualifiesForPublicCert(subj string) bool {\n\t// must at least qualify for a certificate\n\treturn SubjectQualifiesForCert(subj) &&\n\n\t\t// loopback hosts and internal IPs are ineligible\n\t\t!SubjectIsInternal(subj) &&\n\n\t\t// only one wildcard label allowed, and it must be left-most, with 3+ labels\n\t\t(!strings.Contains(subj, \"*\") ||\n\t\t\t(strings.Count(subj, \"*\") == 1 &&\n\t\t\t\tstrings.Count(subj, \".\") > 1 &&\n\t\t\t\tlen(subj) > 2 &&\n\t\t\t\tstrings.HasPrefix(subj, \"*.\")))\n}\n\n// SubjectIsIP returns true if subj is an IP address.\nfunc SubjectIsIP(subj string) bool {\n\treturn net.ParseIP(subj) != nil\n}\n\n// SubjectIsInternal returns true if subj is an internal-facing\n// hostname or address, including localhost/loopback hosts.\n// Ports are ignored, if present.\nfunc SubjectIsInternal(subj string) bool {\n\tsubj = strings.ToLower(strings.TrimSuffix(hostOnly(subj), \".\"))\n\treturn subj == \"localhost\" ||\n\t\tstrings.HasSuffix(subj, \".localhost\") ||\n\t\tstrings.HasSuffix(subj, \".local\") ||\n\t\tstrings.HasSuffix(subj, \".internal\") ||\n\t\tstrings.HasSuffix(subj, \".home.arpa\") ||\n\t\tisInternalIP(subj)\n}\n\n// isInternalIP returns true if the IP of addr\n// belongs to a private network IP range. addr\n// must only be an IP or an IP:port combination.\nfunc isInternalIP(addr string) bool {\n\tprivateNetworks := []string{\n\t\t\"127.0.0.0/8\", // IPv4 loopback\n\t\t\"0.0.0.0/16\",\n\t\t\"10.0.0.0/8\",     // RFC1918\n\t\t\"172.16.0.0/12\",  // RFC1918\n\t\t\"192.168.0.0/16\", // RFC1918\n\t\t\"169.254.0.0/16\", // RFC3927 link-local\n\t\t\"::1/7\",          // IPv6 loopback\n\t\t\"fe80::/10\",      // IPv6 link-local\n\t\t\"fc00::/7\",       // IPv6 unique local addr\n\t}\n\thost := hostOnly(addr)\n\tip := net.ParseIP(host)\n\tif ip == nil {\n\t\treturn false\n\t}\n\tfor _, privateNetwork := range privateNetworks {\n\t\t_, ipnet, _ := net.ParseCIDR(privateNetwork)\n\t\tif ipnet.Contains(ip) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// hostOnly returns only the host portion of hostport.\n// If there is no port or if there is an error splitting\n// the port off, the whole input string is returned.\nfunc hostOnly(hostport string) string {\n\thost, _, err := net.SplitHostPort(hostport)\n\tif err != nil {\n\t\treturn hostport // OK; probably had no port to begin with\n\t}\n\treturn host\n}\n\n// MatchWildcard returns true if subject (a candidate DNS name)\n// matches wildcard (a reference DNS name), mostly according to\n// RFC 6125-compliant wildcard rules. See also RFC 2818 which\n// states that IP addresses must match exactly, but this function\n// does not attempt to distinguish IP addresses from internal or\n// external DNS names that happen to look like IP addresses.\n// It uses DNS wildcard matching logic and is case-insensitive.\n// https://tools.ietf.org/html/rfc2818#section-3.1\nfunc MatchWildcard(subject, wildcard string) bool {\n\tsubject, wildcard = strings.ToLower(subject), strings.ToLower(wildcard)\n\tif subject == wildcard {\n\t\treturn true\n\t}\n\tif !strings.Contains(wildcard, \"*\") {\n\t\treturn false\n\t}\n\tlabels := strings.Split(subject, \".\")\n\tfor i := range labels {\n\t\tif labels[i] == \"\" {\n\t\t\tcontinue // invalid label\n\t\t}\n\t\tlabels[i] = \"*\"\n\t\tcandidate := strings.Join(labels, \".\")\n\t\tif candidate == wildcard {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "certificates_test.go",
          "type": "blob",
          "size": 7.865234375,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestUnexportedGetCertificate(t *testing.T) {\n\tcertCache := &Cache{cache: make(map[string]Certificate), cacheIndex: make(map[string][]string), logger: defaultTestLogger}\n\tcfg := &Config{Logger: defaultTestLogger, certCache: certCache}\n\n\t// When cache is empty\n\tif _, matched, defaulted := cfg.getCertificateFromCache(&tls.ClientHelloInfo{ServerName: \"example.com\"}); matched || defaulted {\n\t\tt.Errorf(\"Got a certificate when cache was empty; matched=%v, defaulted=%v\", matched, defaulted)\n\t}\n\n\t// When cache has one certificate in it\n\tfirstCert := Certificate{Names: []string{\"example.com\"}}\n\tcertCache.cache[\"0xdeadbeef\"] = firstCert\n\tcertCache.cacheIndex[\"example.com\"] = []string{\"0xdeadbeef\"}\n\tif cert, matched, defaulted := cfg.getCertificateFromCache(&tls.ClientHelloInfo{ServerName: \"example.com\"}); !matched || defaulted || cert.Names[0] != \"example.com\" {\n\t\tt.Errorf(\"Didn't get a cert for 'example.com' or got the wrong one: %v, matched=%v, defaulted=%v\", cert, matched, defaulted)\n\t}\n\n\t// When retrieving wildcard certificate\n\tcertCache.cache[\"0xb01dface\"] = Certificate{Names: []string{\"*.example.com\"}}\n\tcertCache.cacheIndex[\"*.example.com\"] = []string{\"0xb01dface\"}\n\tif cert, matched, defaulted := cfg.getCertificateFromCache(&tls.ClientHelloInfo{ServerName: \"sub.example.com\"}); !matched || defaulted || cert.Names[0] != \"*.example.com\" {\n\t\tt.Errorf(\"Didn't get wildcard cert for 'sub.example.com' or got the wrong one: %v, matched=%v, defaulted=%v\", cert, matched, defaulted)\n\t}\n\n\t// When no certificate matches and SNI is provided, return no certificate (should be TLS alert)\n\tif cert, matched, defaulted := cfg.getCertificateFromCache(&tls.ClientHelloInfo{ServerName: \"nomatch\"}); matched || defaulted {\n\t\tt.Errorf(\"Expected matched=false, defaulted=false; but got matched=%v, defaulted=%v (cert: %v)\", matched, defaulted, cert)\n\t}\n}\n\nfunc TestCacheCertificate(t *testing.T) {\n\tcertCache := &Cache{cache: make(map[string]Certificate), cacheIndex: make(map[string][]string), logger: defaultTestLogger}\n\n\tcertCache.cacheCertificate(Certificate{Names: []string{\"example.com\", \"sub.example.com\"}, hash: \"foobar\", Certificate: tls.Certificate{Leaf: &x509.Certificate{NotAfter: time.Now()}}})\n\tif len(certCache.cache) != 1 {\n\t\tt.Errorf(\"Expected length of certificate cache to be 1\")\n\t}\n\tif _, ok := certCache.cache[\"foobar\"]; !ok {\n\t\tt.Error(\"Expected first cert to be cached by key 'foobar', but it wasn't\")\n\t}\n\tif _, ok := certCache.cacheIndex[\"example.com\"]; !ok {\n\t\tt.Error(\"Expected first cert to be keyed by 'example.com', but it wasn't\")\n\t}\n\tif _, ok := certCache.cacheIndex[\"sub.example.com\"]; !ok {\n\t\tt.Error(\"Expected first cert to be keyed by 'sub.example.com', but it wasn't\")\n\t}\n\n\t// using same cache; and has cert with overlapping name, but different hash\n\tcertCache.cacheCertificate(Certificate{Names: []string{\"example.com\"}, hash: \"barbaz\", Certificate: tls.Certificate{Leaf: &x509.Certificate{NotAfter: time.Now()}}})\n\tif _, ok := certCache.cache[\"barbaz\"]; !ok {\n\t\tt.Error(\"Expected second cert to be cached by key 'barbaz.com', but it wasn't\")\n\t}\n\tif hashes, ok := certCache.cacheIndex[\"example.com\"]; !ok {\n\t\tt.Error(\"Expected second cert to be keyed by 'example.com', but it wasn't\")\n\t} else if !reflect.DeepEqual(hashes, []string{\"foobar\", \"barbaz\"}) {\n\t\tt.Errorf(\"Expected second cert to map to 'barbaz' but it was %v instead\", hashes)\n\t}\n}\n\nfunc TestSubjectQualifiesForCert(t *testing.T) {\n\tfor i, test := range []struct {\n\t\thost   string\n\t\texpect bool\n\t}{\n\t\t{\"hostname\", true},\n\t\t{\"example.com\", true},\n\t\t{\"sub.example.com\", true},\n\t\t{\"Sub.Example.COM\", true},\n\t\t{\"127.0.0.1\", true},\n\t\t{\"127.0.1.5\", true},\n\t\t{\"69.123.43.94\", true},\n\t\t{\"::1\", true},\n\t\t{\"::\", true},\n\t\t{\"0.0.0.0\", true},\n\t\t{\"\", false},\n\t\t{\" \", false},\n\t\t{\"*.example.com\", true},\n\t\t{\"*.*.example.com\", true},\n\t\t{\"sub.*.example.com\", false},\n\t\t{\"*sub.example.com\", false},\n\t\t{\"**.tld\", false},\n\t\t{\"*\", true},\n\t\t{\"*.tld\", true},\n\t\t{\".tld\", false},\n\t\t{\"example.com.\", false},\n\t\t{\"localhost\", true},\n\t\t{\"foo.localhost\", true},\n\t\t{\"local\", true},\n\t\t{\"192.168.1.3\", true},\n\t\t{\"10.0.2.1\", true},\n\t\t{\"169.112.53.4\", true},\n\t\t{\"$hostname\", false},\n\t\t{\"%HOSTNAME%\", false},\n\t\t{\"{hostname}\", false},\n\t\t{\"hostname!\", false},\n\t\t{\"<hostname>\", false},\n\t\t{\"# hostname\", false},\n\t\t{\"// hostname\", false},\n\t\t{\"user@hostname\", false},\n\t\t{\"hostname;\", false},\n\t\t{`\"hostname\"`, false},\n\t} {\n\t\tactual := SubjectQualifiesForCert(test.host)\n\t\tif actual != test.expect {\n\t\t\tt.Errorf(\"Test %d: Expected SubjectQualifiesForCert(%s)=%v, but got %v\",\n\t\t\t\ti, test.host, test.expect, actual)\n\t\t}\n\t}\n}\n\nfunc TestSubjectQualifiesForPublicCert(t *testing.T) {\n\tfor i, test := range []struct {\n\t\thost   string\n\t\texpect bool\n\t}{\n\t\t{\"hostname\", true},\n\t\t{\"example.com\", true},\n\t\t{\"sub.example.com\", true},\n\t\t{\"Sub.Example.COM\", true},\n\t\t{\"127.0.0.1\", false},\n\t\t{\"127.0.1.5\", false},\n\t\t{\"1.2.3.4\", true},\n\t\t{\"69.123.43.94\", true},\n\t\t{\"::1\", false},\n\t\t{\"::\", false},\n\t\t{\"0.0.0.0\", false},\n\t\t{\"\", false},\n\t\t{\" \", false},\n\t\t{\"*.example.com\", true},\n\t\t{\"*.*.example.com\", false},\n\t\t{\"sub.*.example.com\", false},\n\t\t{\"*sub.example.com\", false},\n\t\t{\"*\", false},     // won't be trusted by browsers\n\t\t{\"*.tld\", false}, // won't be trusted by browsers\n\t\t{\".tld\", false},\n\t\t{\"example.com.\", false},\n\t\t{\"localhost\", false},\n\t\t{\"foo.localhost\", false},\n\t\t{\"local\", true},\n\t\t{\"foo.local\", false},\n\t\t{\"foo.bar.local\", false},\n\t\t{\"foo.internal\", false},\n\t\t{\"foo.bar.internal\", false},\n\t\t{\"foo.home.arpa\", false},\n\t\t{\"foo.bar.home.arpa\", false},\n\t\t{\"192.168.1.3\", false},\n\t\t{\"10.0.2.1\", false},\n\t\t{\"169.112.53.4\", true},\n\t\t{\"$hostname\", false},\n\t\t{\"%HOSTNAME%\", false},\n\t\t{\"{hostname}\", false},\n\t\t{\"hostname!\", false},\n\t\t{\"<hostname>\", false},\n\t\t{\"# hostname\", false},\n\t\t{\"// hostname\", false},\n\t\t{\"user@hostname\", false},\n\t\t{\"hostname;\", false},\n\t\t{`\"hostname\"`, false},\n\t} {\n\t\tactual := SubjectQualifiesForPublicCert(test.host)\n\t\tif actual != test.expect {\n\t\t\tt.Errorf(\"Test %d: Expected SubjectQualifiesForPublicCert(%s)=%v, but got %v\",\n\t\t\t\ti, test.host, test.expect, actual)\n\t\t}\n\t}\n}\n\nfunc TestMatchWildcard(t *testing.T) {\n\tfor i, test := range []struct {\n\t\tsubject, wildcard string\n\t\texpect            bool\n\t}{\n\t\t{\"hostname\", \"hostname\", true},\n\t\t{\"HOSTNAME\", \"hostname\", true},\n\t\t{\"hostname\", \"HOSTNAME\", true},\n\t\t{\"foo.localhost\", \"foo.localhost\", true},\n\t\t{\"foo.localhost\", \"bar.localhost\", false},\n\t\t{\"foo.localhost\", \"*.localhost\", true},\n\t\t{\"bar.localhost\", \"*.localhost\", true},\n\t\t{\"FOO.LocalHost\", \"*.localhost\", true},\n\t\t{\"Bar.localhost\", \"*.LOCALHOST\", true},\n\t\t{\"foo.bar.localhost\", \"*.localhost\", false},\n\t\t{\".localhost\", \"*.localhost\", false},\n\t\t{\"foo.localhost\", \"foo.*\", false},\n\t\t{\"foo.bar.local\", \"foo.*.local\", false},\n\t\t{\"foo.bar.local\", \"foo.bar.*\", false},\n\t\t{\"foo.bar.local\", \"*.bar.local\", true},\n\t\t{\"1.2.3.4.5.6\", \"*.2.3.4.5.6\", true},\n\t\t{\"1.2.3.4.5.6\", \"*.*.3.4.5.6\", true},\n\t\t{\"1.2.3.4.5.6\", \"*.*.*.4.5.6\", true},\n\t\t{\"1.2.3.4.5.6\", \"*.*.*.*.5.6\", true},\n\t\t{\"1.2.3.4.5.6\", \"*.*.*.*.*.6\", true},\n\t\t{\"1.2.3.4.5.6\", \"*.*.*.*.*.*\", true},\n\t\t{\"0.1.2.3.4.5.6\", \"*.*.*.*.*.*\", false},\n\t\t{\"1.2.3.4\", \"1.2.3.*\", false}, // https://tools.ietf.org/html/rfc2818#section-3.1\n\t} {\n\t\tactual := MatchWildcard(test.subject, test.wildcard)\n\t\tif actual != test.expect {\n\t\t\tt.Errorf(\"Test %d: Expected MatchWildcard(%s, %s)=%v, but got %v\",\n\t\t\t\ti, test.subject, test.wildcard, test.expect, actual)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "certmagic.go",
          "type": "blob",
          "size": 17.53125,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Package certmagic automates the obtaining and renewal of TLS certificates,\n// including TLS & HTTPS best practices such as robust OCSP stapling, caching,\n// HTTP->HTTPS redirects, and more.\n//\n// Its high-level API serves your HTTP handlers over HTTPS if you simply give\n// the domain name(s) and the http.Handler; CertMagic will create and run\n// the HTTPS server for you, fully managing certificates during the lifetime\n// of the server. Similarly, it can be used to start TLS listeners or return\n// a ready-to-use tls.Config -- whatever layer you need TLS for, CertMagic\n// makes it easy. See the HTTPS, Listen, and TLS functions for that.\n//\n// If you need more control, create a Cache using NewCache() and then make\n// a Config using New(). You can then call Manage() on the config. But if\n// you use this lower-level API, you'll have to be sure to solve the HTTP\n// and TLS-ALPN challenges yourself (unless you disabled them or use the\n// DNS challenge) by using the provided Config.GetCertificate function\n// in your tls.Config and/or Config.HTTPChallengeHandler in your HTTP\n// handler.\n//\n// See the package's README for more instruction.\npackage certmagic\n\nimport (\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"go.uber.org/zap\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// HTTPS serves mux for all domainNames using the HTTP\n// and HTTPS ports, redirecting all HTTP requests to HTTPS.\n// It uses the Default config and a background context.\n//\n// This high-level convenience function is opinionated and\n// applies sane defaults for production use, including\n// timeouts for HTTP requests and responses. To allow very\n// long-lived connections, you should make your own\n// http.Server values and use this package's Listen(), TLS(),\n// or Config.TLSConfig() functions to customize to your needs.\n// For example, servers which need to support large uploads or\n// downloads with slow clients may need to use longer timeouts,\n// thus this function is not suitable.\n//\n// Calling this function signifies your acceptance to\n// the CA's Subscriber Agreement and/or Terms of Service.\nfunc HTTPS(domainNames []string, mux http.Handler) error {\n\tctx := context.Background()\n\n\tif mux == nil {\n\t\tmux = http.DefaultServeMux\n\t}\n\n\tDefaultACME.Agreed = true\n\tcfg := NewDefault()\n\n\terr := cfg.ManageSync(ctx, domainNames)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\thttpWg.Add(1)\n\tdefer httpWg.Done()\n\n\t// if we haven't made listeners yet, do so now,\n\t// and clean them up when all servers are done\n\tlnMu.Lock()\n\tif httpLn == nil && httpsLn == nil {\n\t\thttpLn, err = net.Listen(\"tcp\", fmt.Sprintf(\":%d\", HTTPPort))\n\t\tif err != nil {\n\t\t\tlnMu.Unlock()\n\t\t\treturn err\n\t\t}\n\n\t\ttlsConfig := cfg.TLSConfig()\n\t\ttlsConfig.NextProtos = append([]string{\"h2\", \"http/1.1\"}, tlsConfig.NextProtos...)\n\n\t\thttpsLn, err = tls.Listen(\"tcp\", fmt.Sprintf(\":%d\", HTTPSPort), tlsConfig)\n\t\tif err != nil {\n\t\t\thttpLn.Close()\n\t\t\thttpLn = nil\n\t\t\tlnMu.Unlock()\n\t\t\treturn err\n\t\t}\n\n\t\tgo func() {\n\t\t\thttpWg.Wait()\n\t\t\tlnMu.Lock()\n\t\t\thttpLn.Close()\n\t\t\thttpsLn.Close()\n\t\t\tlnMu.Unlock()\n\t\t}()\n\t}\n\thln, hsln := httpLn, httpsLn\n\tlnMu.Unlock()\n\n\t// create HTTP/S servers that are configured\n\t// with sane default timeouts and appropriate\n\t// handlers (the HTTP server solves the HTTP\n\t// challenge and issues redirects to HTTPS,\n\t// while the HTTPS server simply serves the\n\t// user's handler)\n\thttpServer := &http.Server{\n\t\tReadHeaderTimeout: 5 * time.Second,\n\t\tReadTimeout:       5 * time.Second,\n\t\tWriteTimeout:      5 * time.Second,\n\t\tIdleTimeout:       5 * time.Second,\n\t\tBaseContext:       func(listener net.Listener) context.Context { return ctx },\n\t}\n\tif len(cfg.Issuers) > 0 {\n\t\tif am, ok := cfg.Issuers[0].(*ACMEIssuer); ok {\n\t\t\thttpServer.Handler = am.HTTPChallengeHandler(http.HandlerFunc(httpRedirectHandler))\n\t\t}\n\t}\n\thttpsServer := &http.Server{\n\t\tReadHeaderTimeout: 10 * time.Second,\n\t\tReadTimeout:       30 * time.Second,\n\t\tWriteTimeout:      2 * time.Minute,\n\t\tIdleTimeout:       5 * time.Minute,\n\t\tHandler:           mux,\n\t\tBaseContext:       func(listener net.Listener) context.Context { return ctx },\n\t}\n\n\tlog.Printf(\"%v Serving HTTP->HTTPS on %s and %s\",\n\t\tdomainNames, hln.Addr(), hsln.Addr())\n\n\tgo httpServer.Serve(hln)\n\treturn httpsServer.Serve(hsln)\n}\n\nfunc httpRedirectHandler(w http.ResponseWriter, r *http.Request) {\n\ttoURL := \"https://\"\n\n\t// since we redirect to the standard HTTPS port, we\n\t// do not need to include it in the redirect URL\n\trequestHost := hostOnly(r.Host)\n\n\ttoURL += requestHost\n\ttoURL += r.URL.RequestURI()\n\n\t// get rid of this disgusting unencrypted HTTP connection 🤢\n\tw.Header().Set(\"Connection\", \"close\")\n\n\thttp.Redirect(w, r, toURL, http.StatusMovedPermanently)\n}\n\n// TLS enables management of certificates for domainNames\n// and returns a valid tls.Config. It uses the Default\n// config.\n//\n// Because this is a convenience function that returns\n// only a tls.Config, it does not assume HTTP is being\n// served on the HTTP port, so the HTTP challenge is\n// disabled (no HTTPChallengeHandler is necessary). The\n// package variable Default is modified so that the\n// HTTP challenge is disabled.\n//\n// Calling this function signifies your acceptance to\n// the CA's Subscriber Agreement and/or Terms of Service.\nfunc TLS(domainNames []string) (*tls.Config, error) {\n\tDefaultACME.Agreed = true\n\tDefaultACME.DisableHTTPChallenge = true\n\tcfg := NewDefault()\n\treturn cfg.TLSConfig(), cfg.ManageSync(context.Background(), domainNames)\n}\n\n// Listen manages certificates for domainName and returns a\n// TLS listener. It uses the Default config.\n//\n// Because this convenience function returns only a TLS-enabled\n// listener and does not presume HTTP is also being served,\n// the HTTP challenge will be disabled. The package variable\n// Default is modified so that the HTTP challenge is disabled.\n//\n// Calling this function signifies your acceptance to\n// the CA's Subscriber Agreement and/or Terms of Service.\nfunc Listen(domainNames []string) (net.Listener, error) {\n\tDefaultACME.Agreed = true\n\tDefaultACME.DisableHTTPChallenge = true\n\tcfg := NewDefault()\n\terr := cfg.ManageSync(context.Background(), domainNames)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tls.Listen(\"tcp\", fmt.Sprintf(\":%d\", HTTPSPort), cfg.TLSConfig())\n}\n\n// ManageSync obtains certificates for domainNames and keeps them\n// renewed using the Default config.\n//\n// This is a slightly lower-level function; you will need to\n// wire up support for the ACME challenges yourself. You can\n// obtain a Config to help you do that by calling NewDefault().\n//\n// You will need to ensure that you use a TLS config that gets\n// certificates from this Config and that the HTTP and TLS-ALPN\n// challenges can be solved. The easiest way to do this is to\n// use NewDefault().TLSConfig() as your TLS config and to wrap\n// your HTTP handler with NewDefault().HTTPChallengeHandler().\n// If you don't have an HTTP server, you will need to disable\n// the HTTP challenge.\n//\n// If you already have a TLS config you want to use, you can\n// simply set its GetCertificate field to\n// NewDefault().GetCertificate.\n//\n// Calling this function signifies your acceptance to\n// the CA's Subscriber Agreement and/or Terms of Service.\nfunc ManageSync(ctx context.Context, domainNames []string) error {\n\tDefaultACME.Agreed = true\n\treturn NewDefault().ManageSync(ctx, domainNames)\n}\n\n// ManageAsync is the same as ManageSync, except that\n// certificates are managed asynchronously. This means\n// that the function will return before certificates\n// are ready, and errors that occur during certificate\n// obtain or renew operations are only logged. It is\n// vital that you monitor the logs if using this method,\n// which is only recommended for automated/non-interactive\n// environments.\nfunc ManageAsync(ctx context.Context, domainNames []string) error {\n\tDefaultACME.Agreed = true\n\treturn NewDefault().ManageAsync(ctx, domainNames)\n}\n\n// OnDemandConfig configures on-demand TLS (certificate\n// operations as-needed, like during TLS handshakes,\n// rather than immediately).\n//\n// When this package's high-level convenience functions\n// are used (HTTPS, Manage, etc., where the Default\n// config is used as a template), this struct regulates\n// certificate operations using an implicit whitelist\n// containing the names passed into those functions if\n// no DecisionFunc is set. This ensures some degree of\n// control by default to avoid certificate operations for\n// arbitrary domain names. To override this whitelist,\n// manually specify a DecisionFunc. To impose rate limits,\n// specify your own DecisionFunc.\ntype OnDemandConfig struct {\n\t// If set, this function will be called to determine\n\t// whether a certificate can be obtained or renewed\n\t// for the given name. If an error is returned, the\n\t// request will be denied.\n\tDecisionFunc func(ctx context.Context, name string) error\n\n\t// Sources for getting new, unmanaged certificates.\n\t// They will be invoked only during TLS handshakes\n\t// before on-demand certificate management occurs,\n\t// for certificates that are not already loaded into\n\t// the in-memory cache.\n\t//\n\t// TODO: EXPERIMENTAL: subject to change and/or removal.\n\tManagers []Manager\n\n\t// List of allowed hostnames (SNI values) for\n\t// deferred (on-demand) obtaining of certificates.\n\t// Used only by higher-level functions in this\n\t// package to persist the list of hostnames that\n\t// the config is supposed to manage. This is done\n\t// because it seems reasonable that if you say\n\t// \"Manage [domain names...]\", then only those\n\t// domain names should be able to have certs;\n\t// we don't NEED this feature, but it makes sense\n\t// for higher-level convenience functions to be\n\t// able to retain their convenience (alternative\n\t// is: the user manually creates a DecisionFunc\n\t// that allows the same names it already passed\n\t// into Manage) and without letting clients have\n\t// their run of any domain names they want.\n\t// Only enforced if len > 0. (This is a map to\n\t// avoid O(n^2) performance; when it was a slice,\n\t// we saw a 30s CPU profile for a config managing\n\t// 110K names where 29s was spent checking for\n\t// duplicates. Order is not important here.)\n\thostAllowlist map[string]struct{}\n}\n\n// PreChecker is an interface that can be optionally implemented by\n// Issuers. Pre-checks are performed before each call (or batch of\n// identical calls) to Issue(), giving the issuer the option to ensure\n// it has all the necessary information/state.\ntype PreChecker interface {\n\tPreCheck(ctx context.Context, names []string, interactive bool) error\n}\n\n// Issuer is a type that can issue certificates.\ntype Issuer interface {\n\t// Issue obtains a certificate for the given CSR. It\n\t// must honor context cancellation if it is long-running.\n\t// It can also use the context to find out if the current\n\t// call is part of a retry, via AttemptsCtxKey.\n\tIssue(ctx context.Context, request *x509.CertificateRequest) (*IssuedCertificate, error)\n\n\t// IssuerKey must return a string that uniquely identifies\n\t// this particular configuration of the Issuer such that\n\t// any certificates obtained by this Issuer will be treated\n\t// as identical if they have the same SANs.\n\t//\n\t// Certificates obtained from Issuers with the same IssuerKey\n\t// will overwrite others with the same SANs. For example, an\n\t// Issuer might be able to obtain certificates from different\n\t// CAs, say A and B. It is likely that the CAs have different\n\t// use cases and purposes (e.g. testing and production), so\n\t// their respective certificates should not overwrite eaach\n\t// other.\n\tIssuerKey() string\n}\n\n// Revoker can revoke certificates. Reason codes are defined\n// by RFC 5280 §5.3.1: https://tools.ietf.org/html/rfc5280#section-5.3.1\n// and are available as constants in our ACME library.\ntype Revoker interface {\n\tRevoke(ctx context.Context, cert CertificateResource, reason int) error\n}\n\n// Manager is a type that manages certificates (keeps them renewed) such\n// that we can get certificates during TLS handshakes to immediately serve\n// to clients.\n//\n// TODO: This is an EXPERIMENTAL API. It is subject to change/removal.\ntype Manager interface {\n\t// GetCertificate returns the certificate to use to complete the handshake.\n\t// Since this is called during every TLS handshake, it must be very fast and not block.\n\t// Returning any non-nil value indicates that this Manager manages a certificate\n\t// for the described handshake. Returning (nil, nil) is valid and is simply treated as\n\t// a no-op Return (nil, nil) when the Manager has no certificate for this handshake.\n\t// Return an error or a certificate only if the Manager is supposed to get a certificate\n\t// for this handshake. Returning (nil, nil) other Managers or Issuers to try to get\n\t// a certificate for the handshake.\n\tGetCertificate(context.Context, *tls.ClientHelloInfo) (*tls.Certificate, error)\n}\n\n// KeyGenerator can generate a private key.\ntype KeyGenerator interface {\n\t// GenerateKey generates a private key. The returned\n\t// PrivateKey must be able to expose its associated\n\t// public key.\n\tGenerateKey() (crypto.PrivateKey, error)\n}\n\n// IssuerPolicy is a type that enumerates how to\n// choose which issuer to use. EXPERIMENTAL and\n// subject to change.\ntype IssuerPolicy string\n\n// Supported issuer policies. These are subject to change.\nconst (\n\t// UseFirstIssuer uses the first issuer that\n\t// successfully returns a certificate.\n\tUseFirstIssuer = \"first\"\n\n\t// UseFirstRandomIssuer shuffles the list of\n\t// configured issuers, then uses the first one\n\t// that successfully returns a certificate.\n\tUseFirstRandomIssuer = \"first_random\"\n)\n\n// IssuedCertificate represents a certificate that was just issued.\ntype IssuedCertificate struct {\n\t// The PEM-encoding of DER-encoded ASN.1 data.\n\tCertificate []byte\n\n\t// Any extra information to serialize alongside the\n\t// certificate in storage. It MUST be serializable\n\t// as JSON in order to be preserved.\n\tMetadata any\n}\n\n// CertificateResource associates a certificate with its private\n// key and other useful information, for use in maintaining the\n// certificate.\ntype CertificateResource struct {\n\t// The list of names on the certificate;\n\t// for convenience only.\n\tSANs []string `json:\"sans,omitempty\"`\n\n\t// The PEM-encoding of DER-encoded ASN.1 data\n\t// for the cert or chain.\n\tCertificatePEM []byte `json:\"-\"`\n\n\t// The PEM-encoding of the certificate's private key.\n\tPrivateKeyPEM []byte `json:\"-\"`\n\n\t// Any extra information associated with the certificate,\n\t// usually provided by the issuer implementation.\n\tIssuerData json.RawMessage `json:\"issuer_data,omitempty\"`\n\n\t// The unique string identifying the issuer of the\n\t// certificate; internally useful for storage access.\n\tissuerKey string\n}\n\n// NamesKey returns the list of SANs as a single string,\n// truncated to some ridiculously long size limit. It\n// can act as a key for the set of names on the resource.\nfunc (cr *CertificateResource) NamesKey() string {\n\tsort.Strings(cr.SANs)\n\tresult := strings.Join(cr.SANs, \",\")\n\tif len(result) > 1024 {\n\t\tconst trunc = \"_trunc\"\n\t\tresult = result[:1024-len(trunc)] + trunc\n\t}\n\treturn result\n}\n\n// Default contains the package defaults for the\n// various Config fields. This is used as a template\n// when creating your own Configs with New() or\n// NewDefault(), and it is also used as the Config\n// by all the high-level functions in this package\n// that abstract away most configuration (HTTPS(),\n// TLS(), Listen(), etc).\n//\n// The fields of this value will be used for Config\n// fields which are unset. Feel free to modify these\n// defaults, but do not use this Config by itself: it\n// is only a template. Valid configurations can be\n// obtained by calling New() (if you have your own\n// certificate cache) or NewDefault() (if you only\n// need a single config and want to use the default\n// cache).\n//\n// Even if the Issuers or Storage fields are not set,\n// defaults will be applied in the call to New().\nvar Default = Config{\n\tRenewalWindowRatio: DefaultRenewalWindowRatio,\n\tStorage:            defaultFileStorage,\n\tKeySource:          DefaultKeyGenerator,\n\tLogger:             defaultLogger,\n}\n\n// defaultLogger is guaranteed to be a non-nil fallback logger.\nvar defaultLogger = zap.New(zapcore.NewCore(\n\tzapcore.NewConsoleEncoder(zap.NewProductionEncoderConfig()),\n\tos.Stderr,\n\tzap.InfoLevel,\n))\n\nconst (\n\t// HTTPChallengePort is the officially-designated port for\n\t// the HTTP challenge according to the ACME spec.\n\tHTTPChallengePort = 80\n\n\t// TLSALPNChallengePort is the officially-designated port for\n\t// the TLS-ALPN challenge according to the ACME spec.\n\tTLSALPNChallengePort = 443\n)\n\n// Port variables must remain their defaults unless you\n// forward packets from the defaults to whatever these\n// are set to; otherwise ACME challenges will fail.\nvar (\n\t// HTTPPort is the port on which to serve HTTP\n\t// and, as such, the HTTP challenge (unless\n\t// Default.AltHTTPPort is set).\n\tHTTPPort = 80\n\n\t// HTTPSPort is the port on which to serve HTTPS\n\t// and, as such, the TLS-ALPN challenge\n\t// (unless Default.AltTLSALPNPort is set).\n\tHTTPSPort = 443\n)\n\n// Variables for conveniently serving HTTPS.\nvar (\n\thttpLn, httpsLn net.Listener\n\tlnMu            sync.Mutex\n\thttpWg          sync.WaitGroup\n)\n\n// Maximum size for the stack trace when recovering from panics.\nconst stackTraceBufferSize = 1024 * 128\n"
        },
        {
          "name": "certmagic_test.go",
          "type": "blob",
          "size": 0.8076171875,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"os\"\n\n\t\"go.uber.org/zap\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// TODO\n\nvar defaultTestLogger = zap.New(zapcore.NewCore(\n\tzapcore.NewConsoleEncoder(zap.NewDevelopmentEncoderConfig()),\n\tos.Stderr,\n\tzap.DebugLevel,\n))\n"
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 45.4638671875,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/rand\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/asn1\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/fs\"\n\tweakrand \"math/rand\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/mholt/acmez/v3\"\n\t\"github.com/mholt/acmez/v3/acme\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/crypto/ocsp\"\n\t\"golang.org/x/net/idna\"\n)\n\n// Config configures a certificate manager instance.\n// An empty Config is not valid: use New() to obtain\n// a valid Config.\ntype Config struct {\n\t// How much of a certificate's lifetime becomes the\n\t// renewal window, which is the span of time at the\n\t// end of the certificate's validity period in which\n\t// it should be renewed; for most certificates, the\n\t// global default is good, but for extremely short-\n\t// lived certs, you may want to raise this to ~0.5.\n\t// Ratio is remaining:total lifetime.\n\tRenewalWindowRatio float64\n\n\t// An optional event callback clients can set\n\t// to subscribe to certain things happening\n\t// internally by this config; invocations are\n\t// synchronous, so make them return quickly!\n\t// Functions should honor context cancellation.\n\t//\n\t// An error should only be returned to advise\n\t// the emitter to abort or cancel an upcoming\n\t// event. Some events, especially those that have\n\t// already happened, cannot be aborted. For example,\n\t// cert_obtaining can be canceled, but\n\t// cert_obtained cannot. Emitters may choose to\n\t// ignore returned errors.\n\tOnEvent func(ctx context.Context, event string, data map[string]any) error\n\n\t// DefaultServerName specifies a server name\n\t// to use when choosing a certificate if the\n\t// ClientHello's ServerName field is empty.\n\tDefaultServerName string\n\n\t// FallbackServerName specifies a server name\n\t// to use when choosing a certificate if the\n\t// ClientHello's ServerName field doesn't match\n\t// any available certificate.\n\t// EXPERIMENTAL: Subject to change or removal.\n\tFallbackServerName string\n\n\t// The state needed to operate on-demand TLS;\n\t// if non-nil, on-demand TLS is enabled and\n\t// certificate operations are deferred to\n\t// TLS handshakes (or as-needed).\n\t// TODO: Can we call this feature \"Reactive/Lazy/Passive TLS\" instead?\n\tOnDemand *OnDemandConfig\n\n\t// Adds the must staple TLS extension to the CSR.\n\tMustStaple bool\n\n\t// Sources for getting new, managed certificates;\n\t// the default Issuer is ACMEIssuer. If multiple\n\t// issuers are specified, they will be tried in\n\t// turn until one succeeds.\n\tIssuers []Issuer\n\n\t// How to select which issuer to use.\n\t// Default: UseFirstIssuer (subject to change).\n\tIssuerPolicy IssuerPolicy\n\n\t// If true, private keys already existing in storage\n\t// will be reused. Otherwise, a new key will be\n\t// created for every new certificate to mitigate\n\t// pinning and reduce the scope of key compromise.\n\t// Default: false (do not reuse keys).\n\tReusePrivateKeys bool\n\n\t// The source of new private keys for certificates;\n\t// the default KeySource is StandardKeyGenerator.\n\tKeySource KeyGenerator\n\n\t// CertSelection chooses one of the certificates\n\t// with which the ClientHello will be completed;\n\t// if not set, DefaultCertificateSelector will\n\t// be used.\n\tCertSelection CertificateSelector\n\n\t// OCSP configures how OCSP is handled. By default,\n\t// OCSP responses are fetched for every certificate\n\t// with a responder URL, and cached on disk. Changing\n\t// these defaults is STRONGLY discouraged unless you\n\t// have a compelling reason to put clients at greater\n\t// risk and reduce their privacy.\n\tOCSP OCSPConfig\n\n\t// The storage to access when storing or loading\n\t// TLS assets. Default is the local file system.\n\tStorage Storage\n\n\t// CertMagic will verify the storage configuration\n\t// is acceptable before obtaining a certificate\n\t// to avoid information loss after an expensive\n\t// operation. If you are absolutely 100% sure your\n\t// storage is properly configured and has sufficient\n\t// space, you can disable this check to reduce I/O\n\t// if that is expensive for you.\n\t// EXPERIMENTAL: Subject to change or removal.\n\tDisableStorageCheck bool\n\n\t// SubjectTransformer is a hook that can transform the\n\t// subject (SAN) of a certificate being loaded or issued.\n\t// For example, a common use case is to replace the\n\t// left-most label with an asterisk (*) to become a\n\t// wildcard certificate.\n\t// EXPERIMENTAL: Subject to change or removal.\n\tSubjectTransformer func(ctx context.Context, domain string) string\n\n\t// Disables both ARI fetching and the use of ARI for renewal decisions.\n\t// TEMPORARY: Will likely be removed in the future.\n\tDisableARI bool\n\n\t// Set a logger to enable logging. If not set,\n\t// a default logger will be created.\n\tLogger *zap.Logger\n\n\t// required pointer to the in-memory cert cache\n\tcertCache *Cache\n}\n\n// NewDefault makes a valid config based on the package\n// Default config. Most users will call this function\n// instead of New() since most use cases require only a\n// single config for any and all certificates.\n//\n// If your requirements are more advanced (for example,\n// multiple configs depending on the certificate), then use\n// New() instead. (You will need to make your own Cache\n// first.) If you only need a single Config to manage your\n// certs (even if that config changes, as long as it is the\n// only one), customize the Default package variable before\n// calling NewDefault().\n//\n// All calls to NewDefault() will return configs that use the\n// same, default certificate cache. All configs returned\n// by NewDefault() are based on the values of the fields of\n// Default at the time it is called.\n//\n// This is the only way to get a config that uses the\n// default certificate cache.\nfunc NewDefault() *Config {\n\tdefaultCacheMu.Lock()\n\tif defaultCache == nil {\n\t\tdefaultCache = NewCache(CacheOptions{\n\t\t\t// the cache will likely need to renew certificates,\n\t\t\t// so it will need to know how to do that, which\n\t\t\t// depends on the certificate being managed and which\n\t\t\t// can change during the lifetime of the cache; this\n\t\t\t// callback makes it possible to get the latest and\n\t\t\t// correct config with which to manage the cert,\n\t\t\t// but if the user does not provide one, we can only\n\t\t\t// assume that we are to use the default config\n\t\t\tGetConfigForCert: func(Certificate) (*Config, error) {\n\t\t\t\treturn NewDefault(), nil\n\t\t\t},\n\t\t\tLogger: Default.Logger,\n\t\t})\n\t}\n\tcertCache := defaultCache\n\tdefaultCacheMu.Unlock()\n\n\treturn newWithCache(certCache, Default)\n}\n\n// New makes a new, valid config based on cfg and\n// uses the provided certificate cache. certCache\n// MUST NOT be nil or this function will panic.\n//\n// Use this method when you have an advanced use case\n// that requires a custom certificate cache and config\n// that may differ from the Default. For example, if\n// not all certificates are managed/renewed the same\n// way, you need to make your own Cache value with a\n// GetConfigForCert callback that returns the correct\n// configuration for each certificate. However, for\n// the vast majority of cases, there will be only a\n// single Config, thus the default cache (which always\n// uses the default Config) and default config will\n// suffice, and you should use NewDefault() instead.\nfunc New(certCache *Cache, cfg Config) *Config {\n\tif certCache == nil {\n\t\tpanic(\"a certificate cache is required\")\n\t}\n\tcertCache.optionsMu.RLock()\n\tgetConfigForCert := certCache.options.GetConfigForCert\n\tdefer certCache.optionsMu.RUnlock()\n\tif getConfigForCert == nil {\n\t\tpanic(\"cache must have GetConfigForCert set in its options\")\n\t}\n\treturn newWithCache(certCache, cfg)\n}\n\n// newWithCache ensures that cfg is a valid config by populating\n// zero-value fields from the Default Config. If certCache is\n// nil, this function panics.\nfunc newWithCache(certCache *Cache, cfg Config) *Config {\n\tif certCache == nil {\n\t\tpanic(\"cannot make a valid config without a pointer to a certificate cache\")\n\t}\n\n\tif cfg.OnDemand == nil {\n\t\tcfg.OnDemand = Default.OnDemand\n\t}\n\tif !cfg.MustStaple {\n\t\tcfg.MustStaple = Default.MustStaple\n\t}\n\tif cfg.Issuers == nil {\n\t\tcfg.Issuers = Default.Issuers\n\t\tif cfg.Issuers == nil {\n\t\t\t// at least one issuer is absolutely required if not nil\n\t\t\tcfg.Issuers = []Issuer{NewACMEIssuer(&cfg, DefaultACME)}\n\t\t}\n\t}\n\tif cfg.RenewalWindowRatio == 0 {\n\t\tcfg.RenewalWindowRatio = Default.RenewalWindowRatio\n\t}\n\tif cfg.OnEvent == nil {\n\t\tcfg.OnEvent = Default.OnEvent\n\t}\n\tif cfg.KeySource == nil {\n\t\tcfg.KeySource = Default.KeySource\n\t}\n\tif cfg.DefaultServerName == \"\" {\n\t\tcfg.DefaultServerName = Default.DefaultServerName\n\t}\n\tif cfg.FallbackServerName == \"\" {\n\t\tcfg.FallbackServerName = Default.FallbackServerName\n\t}\n\tif cfg.Storage == nil {\n\t\tcfg.Storage = Default.Storage\n\t}\n\tif cfg.Logger == nil {\n\t\tcfg.Logger = Default.Logger\n\t}\n\n\t// absolutely don't allow a nil storage,\n\t// because that would make almost anything\n\t// a config can do pointless\n\tif cfg.Storage == nil {\n\t\tcfg.Storage = defaultFileStorage\n\t}\n\n\t// absolutely don't allow a nil logger either,\n\t// because that would result in panics\n\tif cfg.Logger == nil {\n\t\tcfg.Logger = defaultLogger\n\t}\n\n\tcfg.certCache = certCache\n\n\treturn &cfg\n}\n\n// ManageSync causes the certificates for domainNames to be managed\n// according to cfg. If cfg.OnDemand is not nil, then this simply\n// allowlists the domain names and defers the certificate operations\n// to when they are needed. Otherwise, the certificates for each\n// name are loaded from storage or obtained from the CA if not already\n// in the cache associated with the Config. If loaded from storage,\n// they are renewed if they are expiring or expired. It then caches\n// the certificate in memory and is prepared to serve them up during\n// TLS handshakes. To change how an already-loaded certificate is\n// managed, update the cache options relating to getting a config for\n// a cert.\n//\n// Note that name allowlisting for on-demand management only takes\n// effect if cfg.OnDemand.DecisionFunc is not set (is nil); it will\n// not overwrite an existing DecisionFunc, nor will it overwrite\n// its decision; i.e. the implicit allowlist is only used if no\n// DecisionFunc is set.\n//\n// This method is synchronous, meaning that certificates for all\n// domainNames must be successfully obtained (or renewed) before\n// it returns. It returns immediately on the first error for any\n// of the given domainNames. This behavior is recommended for\n// interactive use (i.e. when an administrator is present) so\n// that errors can be reported and fixed immediately.\nfunc (cfg *Config) ManageSync(ctx context.Context, domainNames []string) error {\n\treturn cfg.manageAll(ctx, domainNames, false)\n}\n\n// ManageAsync is the same as ManageSync, except that ACME\n// operations are performed asynchronously (in the background).\n// This method returns before certificates are ready. It is\n// crucial that the administrator monitors the logs and is\n// notified of any errors so that corrective action can be\n// taken as soon as possible. Any errors returned from this\n// method occurred before ACME transactions started.\n//\n// As long as logs are monitored, this method is typically\n// recommended for non-interactive environments.\n//\n// If there are failures loading, obtaining, or renewing a\n// certificate, it will be retried with exponential backoff\n// for up to about 30 days, with a maximum interval of about\n// 24 hours. Cancelling ctx will cancel retries and shut down\n// any goroutines spawned by ManageAsync.\nfunc (cfg *Config) ManageAsync(ctx context.Context, domainNames []string) error {\n\treturn cfg.manageAll(ctx, domainNames, true)\n}\n\n// ClientCredentials returns a list of TLS client certificate chains for the given identifiers.\n// The return value can be used in a tls.Config to enable client authentication using managed certificates.\n// Any certificates that need to be obtained or renewed for these identifiers will be managed accordingly.\nfunc (cfg *Config) ClientCredentials(ctx context.Context, identifiers []string) ([]tls.Certificate, error) {\n\terr := cfg.manageAll(ctx, identifiers, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar chains []tls.Certificate\n\tfor _, id := range identifiers {\n\t\tcertRes, err := cfg.loadCertResourceAnyIssuer(ctx, id)\n\t\tif err != nil {\n\t\t\treturn chains, err\n\t\t}\n\t\tchain, err := tls.X509KeyPair(certRes.CertificatePEM, certRes.PrivateKeyPEM)\n\t\tif err != nil {\n\t\t\treturn chains, err\n\t\t}\n\t\tchains = append(chains, chain)\n\t}\n\treturn chains, nil\n}\n\nfunc (cfg *Config) manageAll(ctx context.Context, domainNames []string, async bool) error {\n\tif ctx == nil {\n\t\tctx = context.Background()\n\t}\n\tif cfg.OnDemand != nil && cfg.OnDemand.hostAllowlist == nil {\n\t\tcfg.OnDemand.hostAllowlist = make(map[string]struct{})\n\t}\n\n\tfor _, domainName := range domainNames {\n\t\tdomainName = normalizedName(domainName)\n\n\t\t// if on-demand is configured, defer obtain and renew operations\n\t\tif cfg.OnDemand != nil {\n\t\t\tcfg.OnDemand.hostAllowlist[domainName] = struct{}{}\n\t\t\tcontinue\n\t\t}\n\n\t\t// TODO: consider doing this in a goroutine if async, to utilize multiple cores while loading certs\n\t\t// otherwise, begin management immediately\n\t\terr := cfg.manageOne(ctx, domainName, async)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (cfg *Config) manageOne(ctx context.Context, domainName string, async bool) error {\n\t// if certificate is already being managed, nothing to do; maintenance will continue\n\tcerts := cfg.certCache.getAllMatchingCerts(domainName)\n\tfor _, cert := range certs {\n\t\tif cert.managed {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// first try loading existing certificate from storage\n\tcert, err := cfg.CacheManagedCertificate(ctx, domainName)\n\tif err != nil {\n\t\tif !errors.Is(err, fs.ErrNotExist) {\n\t\t\treturn fmt.Errorf(\"%s: caching certificate: %v\", domainName, err)\n\t\t}\n\t\t// if we don't have one in storage, obtain one\n\t\tobtain := func() error {\n\t\t\tvar err error\n\t\t\tif async {\n\t\t\t\terr = cfg.ObtainCertAsync(ctx, domainName)\n\t\t\t} else {\n\t\t\t\terr = cfg.ObtainCertSync(ctx, domainName)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"%s: obtaining certificate: %w\", domainName, err)\n\t\t\t}\n\t\t\tcert, err = cfg.CacheManagedCertificate(ctx, domainName)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"%s: caching certificate after obtaining it: %v\", domainName, err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tif async {\n\t\t\t// Leave the job name empty so as to allow duplicate 'obtain'\n\t\t\t// jobs; this is because Caddy calls ManageAsync() before the\n\t\t\t// previous config is stopped (and before its context is\n\t\t\t// canceled), which means that if an obtain job is still\n\t\t\t// running for the same domain, Submit() would not queue the\n\t\t\t// new one because it is still running, even though it is\n\t\t\t// (probably) about to be canceled (it might not if the new\n\t\t\t// config fails to finish loading, however). In any case, we\n\t\t\t// presume it is safe to enqueue a duplicate obtain job because\n\t\t\t// either the old one (or sometimes the new one) is about to be\n\t\t\t// canceled. This seems like reasonable logic for any consumer\n\t\t\t// of this lib. See https://github.com/caddyserver/caddy/issues/3202\n\t\t\tjm.Submit(cfg.Logger, \"\", obtain)\n\t\t\treturn nil\n\t\t}\n\t\treturn obtain()\n\t}\n\n\t// for an existing certificate, make sure it is renewed; or if it is revoked,\n\t// force a renewal even if it's not expiring\n\trenew := func() error {\n\t\t// first, ensure status is not revoked (it was just refreshed in CacheManagedCertificate above)\n\t\tif !cert.Expired() && cert.ocsp != nil && cert.ocsp.Status == ocsp.Revoked {\n\t\t\t_, err = cfg.forceRenew(ctx, cfg.Logger, cert)\n\t\t\treturn err\n\t\t}\n\n\t\t// ensure ARI is updated before we check whether the cert needs renewing\n\t\t// (we ignore the second return value because we already check if needs renewing anyway)\n\t\tif !cfg.DisableARI && cert.ari.NeedsRefresh() {\n\t\t\tcert, _, err = cfg.updateARI(ctx, cert, cfg.Logger)\n\t\t\tif err != nil {\n\t\t\t\tcfg.Logger.Error(\"updating ARI upon managing\", zap.Error(err))\n\t\t\t}\n\t\t}\n\n\t\t// otherwise, simply renew the certificate if needed\n\t\tif cert.NeedsRenewal(cfg) {\n\t\t\tvar err error\n\t\t\tif async {\n\t\t\t\terr = cfg.RenewCertAsync(ctx, domainName, false)\n\t\t\t} else {\n\t\t\t\terr = cfg.RenewCertSync(ctx, domainName, false)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"%s: renewing certificate: %w\", domainName, err)\n\t\t\t}\n\t\t\t// successful renewal, so update in-memory cache\n\t\t\t_, err = cfg.reloadManagedCertificate(ctx, cert)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"%s: reloading renewed certificate into memory: %v\", domainName, err)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tif async {\n\t\tjm.Submit(cfg.Logger, \"renew_\"+domainName, renew)\n\t\treturn nil\n\t}\n\treturn renew()\n}\n\n// ObtainCertSync generates a new private key and obtains a certificate for\n// name using cfg in the foreground; i.e. interactively and without retries.\n// It stows the renewed certificate and its assets in storage if successful.\n// It DOES NOT load the certificate into the in-memory cache. This method\n// is a no-op if storage already has a certificate for name.\nfunc (cfg *Config) ObtainCertSync(ctx context.Context, name string) error {\n\treturn cfg.obtainCert(ctx, name, true)\n}\n\n// ObtainCertAsync is the same as ObtainCertSync(), except it runs in the\n// background; i.e. non-interactively, and with retries if it fails.\nfunc (cfg *Config) ObtainCertAsync(ctx context.Context, name string) error {\n\treturn cfg.obtainCert(ctx, name, false)\n}\n\nfunc (cfg *Config) obtainCert(ctx context.Context, name string, interactive bool) error {\n\tif len(cfg.Issuers) == 0 {\n\t\treturn fmt.Errorf(\"no issuers configured; impossible to obtain or check for existing certificate in storage\")\n\t}\n\n\tlog := cfg.Logger.Named(\"obtain\")\n\n\tname = cfg.transformSubject(ctx, log, name)\n\n\t// if storage has all resources for this certificate, obtain is a no-op\n\tif cfg.storageHasCertResourcesAnyIssuer(ctx, name) {\n\t\treturn nil\n\t}\n\n\t// ensure storage is writeable and readable\n\t// TODO: this is not necessary every time; should only perform check once every so often for each storage, which may require some global state...\n\terr := cfg.checkStorage(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed storage check: %v - storage is probably misconfigured\", err)\n\t}\n\n\tlog.Info(\"acquiring lock\", zap.String(\"identifier\", name))\n\n\t// ensure idempotency of the obtain operation for this name\n\tlockKey := cfg.lockKey(certIssueLockOp, name)\n\terr = acquireLock(ctx, cfg.Storage, lockKey)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to acquire lock '%s': %v\", lockKey, err)\n\t}\n\tdefer func() {\n\t\tlog.Info(\"releasing lock\", zap.String(\"identifier\", name))\n\t\tif err := releaseLock(ctx, cfg.Storage, lockKey); err != nil {\n\t\t\tlog.Error(\"unable to unlock\",\n\t\t\t\tzap.String(\"identifier\", name),\n\t\t\t\tzap.String(\"lock_key\", lockKey),\n\t\t\t\tzap.Error(err))\n\t\t}\n\t}()\n\tlog.Info(\"lock acquired\", zap.String(\"identifier\", name))\n\n\tf := func(ctx context.Context) error {\n\t\t// check if obtain is still needed -- might have been obtained during lock\n\t\tif cfg.storageHasCertResourcesAnyIssuer(ctx, name) {\n\t\t\tlog.Info(\"certificate already exists in storage\", zap.String(\"identifier\", name))\n\t\t\treturn nil\n\t\t}\n\n\t\tlog.Info(\"obtaining certificate\", zap.String(\"identifier\", name))\n\n\t\tif err := cfg.emit(ctx, \"cert_obtaining\", map[string]any{\"identifier\": name}); err != nil {\n\t\t\treturn fmt.Errorf(\"obtaining certificate aborted by event handler: %w\", err)\n\t\t}\n\n\t\t// If storage has a private key already, use it; otherwise we'll generate our own.\n\t\t// Also create the slice of issuers we will try using according to any issuer\n\t\t// selection policy (it must be a copy of the slice so we don't mutate original).\n\t\tvar privKey crypto.PrivateKey\n\t\tvar privKeyPEM []byte\n\t\tvar issuers []Issuer\n\t\tif cfg.ReusePrivateKeys {\n\t\t\tprivKey, privKeyPEM, issuers, err = cfg.reusePrivateKey(ctx, name)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tissuers = make([]Issuer, len(cfg.Issuers))\n\t\t\tcopy(issuers, cfg.Issuers)\n\t\t}\n\t\tif cfg.IssuerPolicy == UseFirstRandomIssuer {\n\t\t\tweakrand.Shuffle(len(issuers), func(i, j int) {\n\t\t\t\tissuers[i], issuers[j] = issuers[j], issuers[i]\n\t\t\t})\n\t\t}\n\t\tif privKey == nil {\n\t\t\tprivKey, err = cfg.KeySource.GenerateKey()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tprivKeyPEM, err = PEMEncodePrivateKey(privKey)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tcsr, err := cfg.generateCSR(privKey, []string{name}, false)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// try to obtain from each issuer until we succeed\n\t\tvar issuedCert *IssuedCertificate\n\t\tvar issuerUsed Issuer\n\t\tvar issuerKeys []string\n\t\tfor i, issuer := range issuers {\n\t\t\tissuerKeys = append(issuerKeys, issuer.IssuerKey())\n\n\t\t\tlog.Debug(fmt.Sprintf(\"trying issuer %d/%d\", i+1, len(cfg.Issuers)),\n\t\t\t\tzap.String(\"issuer\", issuer.IssuerKey()))\n\n\t\t\tif prechecker, ok := issuer.(PreChecker); ok {\n\t\t\t\terr = prechecker.PreCheck(ctx, []string{name}, interactive)\n\t\t\t\tif err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO: ZeroSSL's API currently requires CommonName to be set, and requires it be\n\t\t\t// distinct from SANs. If this was a cert it would violate the BRs, but their certs\n\t\t\t// are compliant, so their CSR requirements just needlessly add friction, complexity,\n\t\t\t// and inefficiency for clients. CommonName has been deprecated for 25+ years.\n\t\t\tuseCSR := csr\n\t\t\tif issuer.IssuerKey() == zerosslIssuerKey {\n\t\t\t\tuseCSR, err = cfg.generateCSR(privKey, []string{name}, true)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tissuedCert, err = issuer.Issue(ctx, useCSR)\n\t\t\tif err == nil {\n\t\t\t\tissuerUsed = issuer\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// err is usually wrapped, which is nice for simply printing it, but\n\t\t\t// with our structured error logs we only need the problem string\n\t\t\terrToLog := err\n\t\t\tvar problem acme.Problem\n\t\t\tif errors.As(err, &problem) {\n\t\t\t\terrToLog = problem\n\t\t\t}\n\t\t\tlog.Error(\"could not get certificate from issuer\",\n\t\t\t\tzap.String(\"identifier\", name),\n\t\t\t\tzap.String(\"issuer\", issuer.IssuerKey()),\n\t\t\t\tzap.Error(errToLog))\n\t\t}\n\t\tif err != nil {\n\t\t\tcfg.emit(ctx, \"cert_failed\", map[string]any{\n\t\t\t\t\"renewal\":    false,\n\t\t\t\t\"identifier\": name,\n\t\t\t\t\"issuers\":    issuerKeys,\n\t\t\t\t\"error\":      err,\n\t\t\t})\n\n\t\t\t// only the error from the last issuer will be returned, but we logged the others\n\t\t\treturn fmt.Errorf(\"[%s] Obtain: %w\", name, err)\n\t\t}\n\t\tissuerKey := issuerUsed.IssuerKey()\n\n\t\t// success - immediately save the certificate resource\n\t\tmetaJSON, err := json.Marshal(issuedCert.Metadata)\n\t\tif err != nil {\n\t\t\tlog.Error(\"unable to encode certificate metadata\", zap.Error(err))\n\t\t}\n\t\tcertRes := CertificateResource{\n\t\t\tSANs:           namesFromCSR(csr),\n\t\t\tCertificatePEM: issuedCert.Certificate,\n\t\t\tPrivateKeyPEM:  privKeyPEM,\n\t\t\tIssuerData:     metaJSON,\n\t\t\tissuerKey:      issuerUsed.IssuerKey(),\n\t\t}\n\t\terr = cfg.saveCertResource(ctx, issuerUsed, certRes)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"[%s] Obtain: saving assets: %v\", name, err)\n\t\t}\n\n\t\tlog.Info(\"certificate obtained successfully\",\n\t\t\tzap.String(\"identifier\", name),\n\t\t\tzap.String(\"issuer\", issuerUsed.IssuerKey()))\n\n\t\tcertKey := certRes.NamesKey()\n\n\t\tcfg.emit(ctx, \"cert_obtained\", map[string]any{\n\t\t\t\"renewal\":          false,\n\t\t\t\"identifier\":       name,\n\t\t\t\"issuer\":           issuerUsed.IssuerKey(),\n\t\t\t\"storage_path\":     StorageKeys.CertsSitePrefix(issuerKey, certKey),\n\t\t\t\"private_key_path\": StorageKeys.SitePrivateKey(issuerKey, certKey),\n\t\t\t\"certificate_path\": StorageKeys.SiteCert(issuerKey, certKey),\n\t\t\t\"metadata_path\":    StorageKeys.SiteMeta(issuerKey, certKey),\n\t\t\t\"csr_pem\": pem.EncodeToMemory(&pem.Block{\n\t\t\t\tType:  \"CERTIFICATE REQUEST\",\n\t\t\t\tBytes: csr.Raw,\n\t\t\t}),\n\t\t})\n\n\t\treturn nil\n\t}\n\n\tif interactive {\n\t\terr = f(ctx)\n\t} else {\n\t\terr = doWithRetry(ctx, log, f)\n\t}\n\n\treturn err\n}\n\n// reusePrivateKey looks for a private key for domain in storage in the configured issuers\n// paths. For the first private key it finds, it returns that key both decoded and PEM-encoded,\n// as well as the reordered list of issuers to use instead of cfg.Issuers (because if a key\n// is found, that issuer should be tried first, so it is moved to the front in a copy of\n// cfg.Issuers).\nfunc (cfg *Config) reusePrivateKey(ctx context.Context, domain string) (privKey crypto.PrivateKey, privKeyPEM []byte, issuers []Issuer, err error) {\n\t// make a copy of cfg.Issuers so that if we have to reorder elements, we don't\n\t// inadvertently mutate the configured issuers (see append calls below)\n\tissuers = make([]Issuer, len(cfg.Issuers))\n\tcopy(issuers, cfg.Issuers)\n\n\tfor i, issuer := range issuers {\n\t\t// see if this issuer location in storage has a private key for the domain\n\t\tprivateKeyStorageKey := StorageKeys.SitePrivateKey(issuer.IssuerKey(), domain)\n\t\tprivKeyPEM, err = cfg.Storage.Load(ctx, privateKeyStorageKey)\n\t\tif errors.Is(err, fs.ErrNotExist) {\n\t\t\terr = nil // obviously, it's OK to not have a private key; so don't prevent obtaining a cert\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, fmt.Errorf(\"loading existing private key for reuse with issuer %s: %v\", issuer.IssuerKey(), err)\n\t\t}\n\n\t\t// we loaded a private key; try decoding it so we can use it\n\t\tprivKey, err = PEMDecodePrivateKey(privKeyPEM)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, err\n\t\t}\n\n\t\t// since the private key was found in storage for this issuer, move it\n\t\t// to the front of the list so we prefer this issuer first\n\t\tissuers = append([]Issuer{issuer}, append(issuers[:i], issuers[i+1:]...)...)\n\t\tbreak\n\t}\n\n\treturn\n}\n\n// storageHasCertResourcesAnyIssuer returns true if storage has all the\n// certificate resources in storage from any configured issuer. It checks\n// all configured issuers in order.\nfunc (cfg *Config) storageHasCertResourcesAnyIssuer(ctx context.Context, name string) bool {\n\tfor _, iss := range cfg.Issuers {\n\t\tif cfg.storageHasCertResources(ctx, iss, name) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// RenewCertSync renews the certificate for name using cfg in the foreground;\n// i.e. interactively and without retries. It stows the renewed certificate\n// and its assets in storage if successful. It DOES NOT update the in-memory\n// cache with the new certificate. The certificate will not be renewed if it\n// is not close to expiring unless force is true.\nfunc (cfg *Config) RenewCertSync(ctx context.Context, name string, force bool) error {\n\treturn cfg.renewCert(ctx, name, force, true)\n}\n\n// RenewCertAsync is the same as RenewCertSync(), except it runs in the\n// background; i.e. non-interactively, and with retries if it fails.\nfunc (cfg *Config) RenewCertAsync(ctx context.Context, name string, force bool) error {\n\treturn cfg.renewCert(ctx, name, force, false)\n}\n\nfunc (cfg *Config) renewCert(ctx context.Context, name string, force, interactive bool) error {\n\tif len(cfg.Issuers) == 0 {\n\t\treturn fmt.Errorf(\"no issuers configured; impossible to renew or check existing certificate in storage\")\n\t}\n\n\tlog := cfg.Logger.Named(\"renew\")\n\n\tname = cfg.transformSubject(ctx, log, name)\n\n\t// ensure storage is writeable and readable\n\t// TODO: this is not necessary every time; should only perform check once every so often for each storage, which may require some global state...\n\terr := cfg.checkStorage(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed storage check: %v - storage is probably misconfigured\", err)\n\t}\n\n\tlog.Info(\"acquiring lock\", zap.String(\"identifier\", name))\n\n\t// ensure idempotency of the renew operation for this name\n\tlockKey := cfg.lockKey(certIssueLockOp, name)\n\terr = acquireLock(ctx, cfg.Storage, lockKey)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to acquire lock '%s': %v\", lockKey, err)\n\t}\n\tdefer func() {\n\t\tlog.Info(\"releasing lock\", zap.String(\"identifier\", name))\n\n\t\tif err := releaseLock(ctx, cfg.Storage, lockKey); err != nil {\n\t\t\tlog.Error(\"unable to unlock\",\n\t\t\t\tzap.String(\"identifier\", name),\n\t\t\t\tzap.String(\"lock_key\", lockKey),\n\t\t\t\tzap.Error(err))\n\t\t}\n\t}()\n\tlog.Info(\"lock acquired\", zap.String(\"identifier\", name))\n\n\tf := func(ctx context.Context) error {\n\t\t// prepare for renewal (load PEM cert, key, and meta)\n\t\tcertRes, err := cfg.loadCertResourceAnyIssuer(ctx, name)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// check if renew is still needed - might have been renewed while waiting for lock\n\t\ttimeLeft, leaf, needsRenew := cfg.managedCertNeedsRenewal(certRes, false)\n\t\tif !needsRenew {\n\t\t\tif force {\n\t\t\t\tlog.Info(\"certificate does not need to be renewed, but renewal is being forced\",\n\t\t\t\t\tzap.String(\"identifier\", name),\n\t\t\t\t\tzap.Duration(\"remaining\", timeLeft))\n\t\t\t} else {\n\t\t\t\tlog.Info(\"certificate appears to have been renewed already\",\n\t\t\t\t\tzap.String(\"identifier\", name),\n\t\t\t\t\tzap.Duration(\"remaining\", timeLeft))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\tlog.Info(\"renewing certificate\",\n\t\t\tzap.String(\"identifier\", name),\n\t\t\tzap.Duration(\"remaining\", timeLeft))\n\n\t\tif err := cfg.emit(ctx, \"cert_obtaining\", map[string]any{\n\t\t\t\"renewal\":    true,\n\t\t\t\"identifier\": name,\n\t\t\t\"forced\":     force,\n\t\t\t\"remaining\":  timeLeft,\n\t\t\t\"issuer\":     certRes.issuerKey, // previous/current issuer\n\t\t}); err != nil {\n\t\t\treturn fmt.Errorf(\"renewing certificate aborted by event handler: %w\", err)\n\t\t}\n\n\t\t// reuse or generate new private key for CSR\n\t\tvar privateKey crypto.PrivateKey\n\t\tif cfg.ReusePrivateKeys {\n\t\t\tprivateKey, err = PEMDecodePrivateKey(certRes.PrivateKeyPEM)\n\t\t} else {\n\t\t\tprivateKey, err = cfg.KeySource.GenerateKey()\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// if we generated a new key, make sure to replace its PEM encoding too!\n\t\tif !cfg.ReusePrivateKeys {\n\t\t\tcertRes.PrivateKeyPEM, err = PEMEncodePrivateKey(privateKey)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tcsr, err := cfg.generateCSR(privateKey, []string{name}, false)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// try to obtain from each issuer until we succeed\n\t\tvar issuedCert *IssuedCertificate\n\t\tvar issuerUsed Issuer\n\t\tvar issuerKeys []string\n\t\tfor _, issuer := range cfg.Issuers {\n\t\t\t// TODO: ZeroSSL's API currently requires CommonName to be set, and requires it be\n\t\t\t// distinct from SANs. If this was a cert it would violate the BRs, but their certs\n\t\t\t// are compliant, so their CSR requirements just needlessly add friction, complexity,\n\t\t\t// and inefficiency for clients. CommonName has been deprecated for 25+ years.\n\t\t\tuseCSR := csr\n\t\t\tif issuer.IssuerKey() == \"zerossl\" {\n\t\t\t\tuseCSR, err = cfg.generateCSR(privateKey, []string{name}, true)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tissuerKeys = append(issuerKeys, issuer.IssuerKey())\n\t\t\tif prechecker, ok := issuer.(PreChecker); ok {\n\t\t\t\terr = prechecker.PreCheck(ctx, []string{name}, interactive)\n\t\t\t\tif err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if we're renewing with the same ACME CA as before, have the ACME\n\t\t\t// client tell the server we are replacing a certificate (but doing\n\t\t\t// this on the wrong CA, or when the CA doesn't recognize the certID,\n\t\t\t// can fail the order) -- TODO: change this check to whether we're using the same ACME account, not CA\n\t\t\tif !cfg.DisableARI {\n\t\t\t\tif acmeData, err := certRes.getACMEData(); err == nil && acmeData.CA != \"\" {\n\t\t\t\t\tif acmeIss, ok := issuer.(*ACMEIssuer); ok {\n\t\t\t\t\t\tif acmeIss.CA == acmeData.CA {\n\t\t\t\t\t\t\tctx = context.WithValue(ctx, ctxKeyARIReplaces, leaf)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tissuedCert, err = issuer.Issue(ctx, useCSR)\n\t\t\tif err == nil {\n\t\t\t\tissuerUsed = issuer\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// err is usually wrapped, which is nice for simply printing it, but\n\t\t\t// with our structured error logs we only need the problem string\n\t\t\terrToLog := err\n\t\t\tvar problem acme.Problem\n\t\t\tif errors.As(err, &problem) {\n\t\t\t\terrToLog = problem\n\t\t\t}\n\t\t\tlog.Error(\"could not get certificate from issuer\",\n\t\t\t\tzap.String(\"identifier\", name),\n\t\t\t\tzap.String(\"issuer\", issuer.IssuerKey()),\n\t\t\t\tzap.Error(errToLog))\n\t\t}\n\t\tif err != nil {\n\t\t\tcfg.emit(ctx, \"cert_failed\", map[string]any{\n\t\t\t\t\"renewal\":    true,\n\t\t\t\t\"identifier\": name,\n\t\t\t\t\"remaining\":  timeLeft,\n\t\t\t\t\"issuers\":    issuerKeys,\n\t\t\t\t\"error\":      err,\n\t\t\t})\n\n\t\t\t// only the error from the last issuer will be returned, but we logged the others\n\t\t\treturn fmt.Errorf(\"[%s] Renew: %w\", name, err)\n\t\t}\n\t\tissuerKey := issuerUsed.IssuerKey()\n\n\t\t// success - immediately save the renewed certificate resource\n\t\tmetaJSON, err := json.Marshal(issuedCert.Metadata)\n\t\tif err != nil {\n\t\t\tlog.Error(\"unable to encode certificate metadata\", zap.Error(err))\n\t\t}\n\t\tnewCertRes := CertificateResource{\n\t\t\tSANs:           namesFromCSR(csr),\n\t\t\tCertificatePEM: issuedCert.Certificate,\n\t\t\tPrivateKeyPEM:  certRes.PrivateKeyPEM,\n\t\t\tIssuerData:     metaJSON,\n\t\t\tissuerKey:      issuerKey,\n\t\t}\n\t\terr = cfg.saveCertResource(ctx, issuerUsed, newCertRes)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"[%s] Renew: saving assets: %v\", name, err)\n\t\t}\n\n\t\tlog.Info(\"certificate renewed successfully\",\n\t\t\tzap.String(\"identifier\", name),\n\t\t\tzap.String(\"issuer\", issuerKey))\n\n\t\tcertKey := newCertRes.NamesKey()\n\n\t\tcfg.emit(ctx, \"cert_obtained\", map[string]any{\n\t\t\t\"renewal\":          true,\n\t\t\t\"remaining\":        timeLeft,\n\t\t\t\"identifier\":       name,\n\t\t\t\"issuer\":           issuerKey,\n\t\t\t\"storage_path\":     StorageKeys.CertsSitePrefix(issuerKey, certKey),\n\t\t\t\"private_key_path\": StorageKeys.SitePrivateKey(issuerKey, certKey),\n\t\t\t\"certificate_path\": StorageKeys.SiteCert(issuerKey, certKey),\n\t\t\t\"metadata_path\":    StorageKeys.SiteMeta(issuerKey, certKey),\n\t\t\t\"csr_pem\": pem.EncodeToMemory(&pem.Block{\n\t\t\t\tType:  \"CERTIFICATE REQUEST\",\n\t\t\t\tBytes: csr.Raw,\n\t\t\t}),\n\t\t})\n\n\t\treturn nil\n\t}\n\n\tif interactive {\n\t\terr = f(ctx)\n\t} else {\n\t\terr = doWithRetry(ctx, log, f)\n\t}\n\n\treturn err\n}\n\n// generateCSR generates a CSR for the given SANs. If useCN is true, CommonName will get the first SAN (TODO: this is only a temporary hack for ZeroSSL API support).\nfunc (cfg *Config) generateCSR(privateKey crypto.PrivateKey, sans []string, useCN bool) (*x509.CertificateRequest, error) {\n\tcsrTemplate := new(x509.CertificateRequest)\n\n\tfor _, name := range sans {\n\t\t// identifiers should be converted to punycode before going into the CSR\n\t\t// (convert IDNs to ASCII according to RFC 5280 section 7)\n\t\tnormalizedName, err := idna.ToASCII(name)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"converting identifier '%s' to ASCII: %v\", name, err)\n\t\t}\n\n\t\t// TODO: This is a temporary hack to support ZeroSSL API...\n\t\tif useCN && csrTemplate.Subject.CommonName == \"\" && len(normalizedName) <= 64 {\n\t\t\tcsrTemplate.Subject.CommonName = normalizedName\n\t\t\tcontinue\n\t\t}\n\n\t\tif ip := net.ParseIP(normalizedName); ip != nil {\n\t\t\tcsrTemplate.IPAddresses = append(csrTemplate.IPAddresses, ip)\n\t\t} else if strings.Contains(normalizedName, \"@\") {\n\t\t\tcsrTemplate.EmailAddresses = append(csrTemplate.EmailAddresses, normalizedName)\n\t\t} else if u, err := url.Parse(normalizedName); err == nil && strings.Contains(normalizedName, \"/\") {\n\t\t\tcsrTemplate.URIs = append(csrTemplate.URIs, u)\n\t\t} else {\n\t\t\tcsrTemplate.DNSNames = append(csrTemplate.DNSNames, normalizedName)\n\t\t}\n\t}\n\n\tif cfg.MustStaple {\n\t\tcsrTemplate.ExtraExtensions = append(csrTemplate.ExtraExtensions, mustStapleExtension)\n\t}\n\n\t// IP addresses aren't printed here because I'm too lazy to marshal them as strings, but\n\t// we at least print the incoming SANs so it should be obvious what became IPs\n\tcfg.Logger.Debug(\"created CSR\",\n\t\tzap.Strings(\"identifiers\", sans),\n\t\tzap.Strings(\"san_dns_names\", csrTemplate.DNSNames),\n\t\tzap.Strings(\"san_emails\", csrTemplate.EmailAddresses),\n\t\tzap.String(\"common_name\", csrTemplate.Subject.CommonName),\n\t\tzap.Int(\"extra_extensions\", len(csrTemplate.ExtraExtensions)),\n\t)\n\n\tcsrDER, err := x509.CreateCertificateRequest(rand.Reader, csrTemplate, privateKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn x509.ParseCertificateRequest(csrDER)\n}\n\n// RevokeCert revokes the certificate for domain via ACME protocol. It requires\n// that cfg.Issuers is properly configured with the same issuer that issued the\n// certificate being revoked. See RFC 5280 §5.3.1 for reason codes.\n//\n// The certificate assets are deleted from storage after successful revocation\n// to prevent reuse.\nfunc (cfg *Config) RevokeCert(ctx context.Context, domain string, reason int, interactive bool) error {\n\tfor i, issuer := range cfg.Issuers {\n\t\tissuerKey := issuer.IssuerKey()\n\n\t\trev, ok := issuer.(Revoker)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"issuer %d (%s) is not a Revoker\", i, issuerKey)\n\t\t}\n\n\t\tcertRes, err := cfg.loadCertResource(ctx, issuer, domain)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !cfg.Storage.Exists(ctx, StorageKeys.SitePrivateKey(issuerKey, domain)) {\n\t\t\treturn fmt.Errorf(\"private key not found for %s\", certRes.SANs)\n\t\t}\n\n\t\terr = rev.Revoke(ctx, certRes, reason)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"issuer %d (%s): %v\", i, issuerKey, err)\n\t\t}\n\n\t\terr = cfg.deleteSiteAssets(ctx, issuerKey, domain)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"certificate revoked, but unable to fully clean up assets from issuer %s: %v\", issuerKey, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// TLSConfig is an opinionated method that returns a recommended, modern\n// TLS configuration that can be used to configure TLS listeners. Aside\n// from safe, modern defaults, this method sets two critical fields on the\n// TLS config which are required to enable automatic certificate\n// management: GetCertificate and NextProtos.\n//\n// The GetCertificate field is necessary to get certificates from memory\n// or storage, including both manual and automated certificates. You\n// should only change this field if you know what you are doing.\n//\n// The NextProtos field is pre-populated with a special value to enable\n// solving the TLS-ALPN ACME challenge. Because this method does not\n// assume any particular protocols after the TLS handshake is completed,\n// you will likely need to customize the NextProtos field by prepending\n// your application's protocols to the slice. For example, to serve\n// HTTP, you will need to prepend \"h2\" and \"http/1.1\" values. Be sure to\n// leave the acmez.ACMETLS1Protocol value intact, however, or TLS-ALPN\n// challenges will fail (which may be acceptable if you are not using\n// ACME, or specifically, the TLS-ALPN challenge).\n//\n// Unlike the package TLS() function, this method does not, by itself,\n// enable certificate management for any domain names.\nfunc (cfg *Config) TLSConfig() *tls.Config {\n\treturn &tls.Config{\n\t\t// these two fields necessary for TLS-ALPN challenge\n\t\tGetCertificate: cfg.GetCertificate,\n\t\tNextProtos:     []string{acmez.ACMETLS1Protocol},\n\n\t\t// the rest recommended for modern TLS servers\n\t\tMinVersion: tls.VersionTLS12,\n\t\tCurvePreferences: []tls.CurveID{\n\t\t\ttls.X25519,\n\t\t\ttls.CurveP256,\n\t\t},\n\t\tCipherSuites:             preferredDefaultCipherSuites(),\n\t\tPreferServerCipherSuites: true,\n\t}\n}\n\n// getChallengeInfo loads the challenge info from either the internal challenge memory\n// or the external storage (implying distributed solving). The second return value\n// indicates whether challenge info was loaded from external storage. If true, the\n// challenge is being solved in a distributed fashion; if false, from internal memory.\n// If no matching challenge information can be found, an error is returned.\nfunc (cfg *Config) getChallengeInfo(ctx context.Context, identifier string) (Challenge, bool, error) {\n\t// first, check if our process initiated this challenge; if so, just return it\n\tchalData, ok := GetACMEChallenge(identifier)\n\tif ok {\n\t\treturn chalData, false, nil\n\t}\n\n\t// otherwise, perhaps another instance in the cluster initiated it; check\n\t// the configured storage to retrieve challenge data\n\n\tvar chalInfo acme.Challenge\n\tvar chalInfoBytes []byte\n\tvar tokenKey string\n\tfor _, issuer := range cfg.Issuers {\n\t\tds := distributedSolver{\n\t\t\tstorage:                cfg.Storage,\n\t\t\tstorageKeyIssuerPrefix: storageKeyACMECAPrefix(issuer.IssuerKey()),\n\t\t}\n\t\ttokenKey = ds.challengeTokensKey(identifier)\n\t\tvar err error\n\t\tchalInfoBytes, err = cfg.Storage.Load(ctx, tokenKey)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif errors.Is(err, fs.ErrNotExist) {\n\t\t\tcontinue\n\t\t}\n\t\treturn Challenge{}, false, fmt.Errorf(\"opening distributed challenge token file %s: %v\", tokenKey, err)\n\t}\n\tif len(chalInfoBytes) == 0 {\n\t\treturn Challenge{}, false, fmt.Errorf(\"no information found to solve challenge for identifier: %s\", identifier)\n\t}\n\n\terr := json.Unmarshal(chalInfoBytes, &chalInfo)\n\tif err != nil {\n\t\treturn Challenge{}, false, fmt.Errorf(\"decoding challenge token file %s (corrupted?): %v\", tokenKey, err)\n\t}\n\n\treturn Challenge{Challenge: chalInfo}, true, nil\n}\n\nfunc (cfg *Config) transformSubject(ctx context.Context, logger *zap.Logger, name string) string {\n\tif cfg.SubjectTransformer == nil {\n\t\treturn name\n\t}\n\ttransformedName := cfg.SubjectTransformer(ctx, name)\n\tif logger != nil && transformedName != name {\n\t\tlogger.Debug(\"transformed subject name\",\n\t\t\tzap.String(\"original\", name),\n\t\t\tzap.String(\"transformed\", transformedName))\n\t}\n\treturn transformedName\n}\n\n// checkStorage tests the storage by writing random bytes\n// to a random key, and then loading those bytes and\n// comparing the loaded value. If this fails, the provided\n// cfg.Storage mechanism should not be used.\nfunc (cfg *Config) checkStorage(ctx context.Context) error {\n\tif cfg.DisableStorageCheck {\n\t\treturn nil\n\t}\n\tkey := fmt.Sprintf(\"rw_test_%d\", weakrand.Int())\n\tcontents := make([]byte, 1024*10) // size sufficient for one or two ACME resources\n\t_, err := weakrand.Read(contents)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = cfg.Storage.Store(ctx, key, contents)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tdeleteErr := cfg.Storage.Delete(ctx, key)\n\t\tif deleteErr != nil {\n\t\t\tcfg.Logger.Error(\"deleting test key from storage\",\n\t\t\t\tzap.String(\"key\", key), zap.Error(err))\n\t\t}\n\t\t// if there was no other error, make sure\n\t\t// to return any error returned from Delete\n\t\tif err == nil {\n\t\t\terr = deleteErr\n\t\t}\n\t}()\n\tloaded, err := cfg.Storage.Load(ctx, key)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !bytes.Equal(contents, loaded) {\n\t\treturn fmt.Errorf(\"load yielded different value than was stored; expected %d bytes, got %d bytes of differing elements\", len(contents), len(loaded))\n\t}\n\treturn nil\n}\n\n// storageHasCertResources returns true if the storage\n// associated with cfg's certificate cache has all the\n// resources related to the certificate for domain: the\n// certificate, the private key, and the metadata.\nfunc (cfg *Config) storageHasCertResources(ctx context.Context, issuer Issuer, domain string) bool {\n\tissuerKey := issuer.IssuerKey()\n\tcertKey := StorageKeys.SiteCert(issuerKey, domain)\n\tkeyKey := StorageKeys.SitePrivateKey(issuerKey, domain)\n\tmetaKey := StorageKeys.SiteMeta(issuerKey, domain)\n\treturn cfg.Storage.Exists(ctx, certKey) &&\n\t\tcfg.Storage.Exists(ctx, keyKey) &&\n\t\tcfg.Storage.Exists(ctx, metaKey)\n}\n\n// deleteSiteAssets deletes the folder in storage containing the\n// certificate, private key, and metadata file for domain from the\n// issuer with the given issuer key.\nfunc (cfg *Config) deleteSiteAssets(ctx context.Context, issuerKey, domain string) error {\n\terr := cfg.Storage.Delete(ctx, StorageKeys.SiteCert(issuerKey, domain))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"deleting certificate file: %v\", err)\n\t}\n\terr = cfg.Storage.Delete(ctx, StorageKeys.SitePrivateKey(issuerKey, domain))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"deleting private key: %v\", err)\n\t}\n\terr = cfg.Storage.Delete(ctx, StorageKeys.SiteMeta(issuerKey, domain))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"deleting metadata file: %v\", err)\n\t}\n\terr = cfg.Storage.Delete(ctx, StorageKeys.CertsSitePrefix(issuerKey, domain))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"deleting site asset folder: %v\", err)\n\t}\n\treturn nil\n}\n\n// lockKey returns a key for a lock that is specific to the operation\n// named op being performed related to domainName and this config's CA.\nfunc (cfg *Config) lockKey(op, domainName string) string {\n\treturn fmt.Sprintf(\"%s_%s\", op, domainName)\n}\n\n// managedCertNeedsRenewal returns true if certRes is expiring soon or already expired,\n// or if the process of decoding the cert and checking its expiration returned an error.\n// If there wasn't an error, the leaf cert is also returned, so it can be reused if\n// necessary, since we are parsing the PEM bundle anyway.\nfunc (cfg *Config) managedCertNeedsRenewal(certRes CertificateResource, emitLogs bool) (time.Duration, *x509.Certificate, bool) {\n\tcertChain, err := parseCertsFromPEMBundle(certRes.CertificatePEM)\n\tif err != nil || len(certChain) == 0 {\n\t\treturn 0, nil, true\n\t}\n\tvar ari acme.RenewalInfo\n\tif !cfg.DisableARI {\n\t\tif ariPtr, err := certRes.getARI(); err == nil && ariPtr != nil {\n\t\t\tari = *ariPtr\n\t\t}\n\t}\n\tremaining := time.Until(expiresAt(certChain[0]))\n\treturn remaining, certChain[0], cfg.certNeedsRenewal(certChain[0], ari, emitLogs)\n}\n\nfunc (cfg *Config) emit(ctx context.Context, eventName string, data map[string]any) error {\n\tif cfg.OnEvent == nil {\n\t\treturn nil\n\t}\n\treturn cfg.OnEvent(ctx, eventName, data)\n}\n\n// CertificateSelector is a type which can select a certificate to use given multiple choices.\ntype CertificateSelector interface {\n\tSelectCertificate(*tls.ClientHelloInfo, []Certificate) (Certificate, error)\n}\n\n// OCSPConfig configures how OCSP is handled.\ntype OCSPConfig struct {\n\t// Disable automatic OCSP stapling; strongly\n\t// discouraged unless you have a good reason.\n\t// Disabling this puts clients at greater risk\n\t// and reduces their privacy.\n\tDisableStapling bool\n\n\t// A map of OCSP responder domains to replacement\n\t// domains for querying OCSP servers. Used for\n\t// overriding the OCSP responder URL that is\n\t// embedded in certificates. Mapping to an empty\n\t// URL will disable OCSP from that responder.\n\tResponderOverrides map[string]string\n\n\t// Optionally specify a function that can return the URL\n\t// for an HTTP proxy to use for OCSP-related HTTP requests.\n\tHTTPProxy func(*http.Request) (*url.URL, error)\n}\n\n// certIssueLockOp is the name of the operation used\n// when naming a lock to make it mutually exclusive\n// with other certificate issuance operations for a\n// certain name.\nconst certIssueLockOp = \"issue_cert\"\n\n// Constants for PKIX MustStaple extension.\nvar (\n\ttlsFeatureExtensionOID = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 1, 24}\n\tocspMustStapleFeature  = []byte{0x30, 0x03, 0x02, 0x01, 0x05}\n\tmustStapleExtension    = pkix.Extension{\n\t\tId:    tlsFeatureExtensionOID,\n\t\tValue: ocspMustStapleFeature,\n\t}\n)\n"
        },
        {
          "name": "config_test.go",
          "type": "blob",
          "size": 2.4189453125,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"os\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/mholt/acmez/v3/acme\"\n)\n\nfunc TestSaveCertResource(t *testing.T) {\n\tctx := context.Background()\n\n\tam := &ACMEIssuer{CA: \"https://example.com/acme/directory\"}\n\ttestConfig := &Config{\n\t\tIssuers:   []Issuer{am},\n\t\tStorage:   &FileStorage{Path: \"./_testdata_tmp\"},\n\t\tLogger:    defaultTestLogger,\n\t\tcertCache: new(Cache),\n\t}\n\tam.config = testConfig\n\n\ttestStorageDir := testConfig.Storage.(*FileStorage).Path\n\tdefer func() {\n\t\terr := os.RemoveAll(testStorageDir)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not remove temporary storage directory (%s): %v\", testStorageDir, err)\n\t\t}\n\t}()\n\n\tdomain := \"example.com\"\n\tcertContents := \"certificate\"\n\tkeyContents := \"private key\"\n\n\tcert := CertificateResource{\n\t\tSANs:           []string{domain},\n\t\tPrivateKeyPEM:  []byte(keyContents),\n\t\tCertificatePEM: []byte(certContents),\n\t\tIssuerData: mustJSON(acme.Certificate{\n\t\t\tURL: \"https://example.com/cert\",\n\t\t}),\n\t\tissuerKey: am.IssuerKey(),\n\t}\n\n\terr := testConfig.saveCertResource(ctx, am, cert)\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got: %v\", err)\n\t}\n\n\tsiteData, err := testConfig.loadCertResource(ctx, am, domain)\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error reading site, got: %v\", err)\n\t}\n\tsiteData.IssuerData = bytes.ReplaceAll(siteData.IssuerData, []byte(\"\\t\"), []byte(\"\"))\n\tsiteData.IssuerData = bytes.ReplaceAll(siteData.IssuerData, []byte(\"\\n\"), []byte(\"\"))\n\tsiteData.IssuerData = bytes.ReplaceAll(siteData.IssuerData, []byte(\" \"), []byte(\"\"))\n\tif !reflect.DeepEqual(cert, siteData) {\n\t\tt.Errorf(\"Expected '%+v' to match '%+v'\\n%s\\n%s\", cert.IssuerData, siteData.IssuerData, string(cert.IssuerData), string(siteData.IssuerData))\n\t}\n}\n\nfunc mustJSON(val any) []byte {\n\tresult, err := json.Marshal(val)\n\tif err != nil {\n\t\tpanic(\"marshaling JSON: \" + err.Error())\n\t}\n\treturn result\n}\n"
        },
        {
          "name": "crypto.go",
          "type": "blob",
          "size": 11.408203125,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/ed25519\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash/fnv\"\n\t\"io/fs\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/klauspost/cpuid/v2\"\n\t\"github.com/zeebo/blake3\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/net/idna\"\n)\n\n// PEMEncodePrivateKey marshals a private key into a PEM-encoded block.\n// The private key must be one of *ecdsa.PrivateKey, *rsa.PrivateKey, or\n// *ed25519.PrivateKey.\nfunc PEMEncodePrivateKey(key crypto.PrivateKey) ([]byte, error) {\n\tvar pemType string\n\tvar keyBytes []byte\n\tswitch key := key.(type) {\n\tcase *ecdsa.PrivateKey:\n\t\tvar err error\n\t\tpemType = \"EC\"\n\t\tkeyBytes, err = x509.MarshalECPrivateKey(key)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tcase *rsa.PrivateKey:\n\t\tpemType = \"RSA\"\n\t\tkeyBytes = x509.MarshalPKCS1PrivateKey(key)\n\tcase ed25519.PrivateKey:\n\t\tvar err error\n\t\tpemType = \"ED25519\"\n\t\tkeyBytes, err = x509.MarshalPKCS8PrivateKey(key)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported key type: %T\", key)\n\t}\n\tpemKey := pem.Block{Type: pemType + \" PRIVATE KEY\", Bytes: keyBytes}\n\treturn pem.EncodeToMemory(&pemKey), nil\n}\n\n// PEMDecodePrivateKey loads a PEM-encoded ECC/RSA private key from an array of bytes.\n// Borrowed from Go standard library, to handle various private key and PEM block types.\nfunc PEMDecodePrivateKey(keyPEMBytes []byte) (crypto.Signer, error) {\n\t// Modified from original:\n\t// https://github.com/golang/go/blob/693748e9fa385f1e2c3b91ca9acbb6c0ad2d133d/src/crypto/tls/tls.go#L291-L308\n\t// https://github.com/golang/go/blob/693748e9fa385f1e2c3b91ca9acbb6c0ad2d133d/src/crypto/tls/tls.go#L238\n\n\tkeyBlockDER, _ := pem.Decode(keyPEMBytes)\n\n\tif keyBlockDER == nil {\n\t\treturn nil, fmt.Errorf(\"failed to decode PEM block containing private key\")\n\t}\n\n\tif keyBlockDER.Type != \"PRIVATE KEY\" && !strings.HasSuffix(keyBlockDER.Type, \" PRIVATE KEY\") {\n\t\treturn nil, fmt.Errorf(\"unknown PEM header %q\", keyBlockDER.Type)\n\t}\n\n\tif key, err := x509.ParsePKCS1PrivateKey(keyBlockDER.Bytes); err == nil {\n\t\treturn key, nil\n\t}\n\n\tif key, err := x509.ParsePKCS8PrivateKey(keyBlockDER.Bytes); err == nil {\n\t\tswitch key := key.(type) {\n\t\tcase *rsa.PrivateKey, *ecdsa.PrivateKey, ed25519.PrivateKey:\n\t\t\treturn key.(crypto.Signer), nil\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"found unknown private key type in PKCS#8 wrapping: %T\", key)\n\t\t}\n\t}\n\n\tif key, err := x509.ParseECPrivateKey(keyBlockDER.Bytes); err == nil {\n\t\treturn key, nil\n\t}\n\n\treturn nil, fmt.Errorf(\"unknown private key type\")\n}\n\n// parseCertsFromPEMBundle parses a certificate bundle from top to bottom and returns\n// a slice of x509 certificates. This function will error if no certificates are found.\nfunc parseCertsFromPEMBundle(bundle []byte) ([]*x509.Certificate, error) {\n\tvar certificates []*x509.Certificate\n\tvar certDERBlock *pem.Block\n\tfor {\n\t\tcertDERBlock, bundle = pem.Decode(bundle)\n\t\tif certDERBlock == nil {\n\t\t\tbreak\n\t\t}\n\t\tif certDERBlock.Type == \"CERTIFICATE\" {\n\t\t\tcert, err := x509.ParseCertificate(certDERBlock.Bytes)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tcertificates = append(certificates, cert)\n\t\t}\n\t}\n\tif len(certificates) == 0 {\n\t\treturn nil, fmt.Errorf(\"no certificates found in bundle\")\n\t}\n\treturn certificates, nil\n}\n\n// fastHash hashes input using a hashing algorithm that\n// is fast, and returns the hash as a hex-encoded string.\n// Do not use this for cryptographic purposes.\nfunc fastHash(input []byte) string {\n\th := fnv.New32a()\n\th.Write(input)\n\treturn fmt.Sprintf(\"%x\", h.Sum32())\n}\n\n// saveCertResource saves the certificate resource to disk. This\n// includes the certificate file itself, the private key, and the\n// metadata file.\nfunc (cfg *Config) saveCertResource(ctx context.Context, issuer Issuer, cert CertificateResource) error {\n\tmetaBytes, err := json.MarshalIndent(cert, \"\", \"\\t\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"encoding certificate metadata: %v\", err)\n\t}\n\n\tissuerKey := issuer.IssuerKey()\n\tcertKey := cert.NamesKey()\n\n\tall := []keyValue{\n\t\t{\n\t\t\tkey:   StorageKeys.SitePrivateKey(issuerKey, certKey),\n\t\t\tvalue: cert.PrivateKeyPEM,\n\t\t},\n\t\t{\n\t\t\tkey:   StorageKeys.SiteCert(issuerKey, certKey),\n\t\t\tvalue: cert.CertificatePEM,\n\t\t},\n\t\t{\n\t\t\tkey:   StorageKeys.SiteMeta(issuerKey, certKey),\n\t\t\tvalue: metaBytes,\n\t\t},\n\t}\n\n\treturn storeTx(ctx, cfg.Storage, all)\n}\n\n// loadCertResourceAnyIssuer loads and returns the certificate resource from any\n// of the configured issuers. If multiple are found (e.g. if there are 3 issuers\n// configured, and all 3 have a resource matching certNamesKey), then the newest\n// (latest NotBefore date) resource will be chosen.\nfunc (cfg *Config) loadCertResourceAnyIssuer(ctx context.Context, certNamesKey string) (CertificateResource, error) {\n\t// we can save some extra decoding steps if there's only one issuer, since\n\t// we don't need to compare potentially multiple available resources to\n\t// select the best one, when there's only one choice anyway\n\tif len(cfg.Issuers) == 1 {\n\t\treturn cfg.loadCertResource(ctx, cfg.Issuers[0], certNamesKey)\n\t}\n\n\ttype decodedCertResource struct {\n\t\tCertificateResource\n\t\tissuer  Issuer\n\t\tdecoded *x509.Certificate\n\t}\n\tvar certResources []decodedCertResource\n\tvar lastErr error\n\n\t// load and decode all certificate resources found with the\n\t// configured issuers so we can sort by newest\n\tfor _, issuer := range cfg.Issuers {\n\t\tcertRes, err := cfg.loadCertResource(ctx, issuer, certNamesKey)\n\t\tif err != nil {\n\t\t\tif errors.Is(err, fs.ErrNotExist) {\n\t\t\t\t// not a problem, but we need to remember the error\n\t\t\t\t// in case we end up not finding any cert resources\n\t\t\t\t// since we'll need an error to return in that case\n\t\t\t\tlastErr = err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn CertificateResource{}, err\n\t\t}\n\t\tcerts, err := parseCertsFromPEMBundle(certRes.CertificatePEM)\n\t\tif err != nil {\n\t\t\treturn CertificateResource{}, err\n\t\t}\n\t\tcertResources = append(certResources, decodedCertResource{\n\t\t\tCertificateResource: certRes,\n\t\t\tissuer:              issuer,\n\t\t\tdecoded:             certs[0],\n\t\t})\n\t}\n\tif len(certResources) == 0 {\n\t\tif lastErr == nil {\n\t\t\tlastErr = fmt.Errorf(\"no certificate resources found\") // just in case; e.g. no Issuers configured\n\t\t}\n\t\treturn CertificateResource{}, lastErr\n\t}\n\n\t// sort by date so the most recently issued comes first\n\tsort.Slice(certResources, func(i, j int) bool {\n\t\treturn certResources[j].decoded.NotBefore.Before(certResources[i].decoded.NotBefore)\n\t})\n\n\tcfg.Logger.Debug(\"loading managed certificate\",\n\t\tzap.String(\"domain\", certNamesKey),\n\t\tzap.Time(\"expiration\", expiresAt(certResources[0].decoded)),\n\t\tzap.String(\"issuer_key\", certResources[0].issuer.IssuerKey()),\n\t\tzap.Any(\"storage\", cfg.Storage),\n\t)\n\n\treturn certResources[0].CertificateResource, nil\n}\n\n// loadCertResource loads a certificate resource from the given issuer's storage location.\nfunc (cfg *Config) loadCertResource(ctx context.Context, issuer Issuer, certNamesKey string) (CertificateResource, error) {\n\tcertRes := CertificateResource{issuerKey: issuer.IssuerKey()}\n\n\tnormalizedName, err := idna.ToASCII(certNamesKey)\n\tif err != nil {\n\t\treturn CertificateResource{}, fmt.Errorf(\"converting '%s' to ASCII: %v\", certNamesKey, err)\n\t}\n\n\tkeyBytes, err := cfg.Storage.Load(ctx, StorageKeys.SitePrivateKey(certRes.issuerKey, normalizedName))\n\tif err != nil {\n\t\treturn CertificateResource{}, err\n\t}\n\tcertRes.PrivateKeyPEM = keyBytes\n\tcertBytes, err := cfg.Storage.Load(ctx, StorageKeys.SiteCert(certRes.issuerKey, normalizedName))\n\tif err != nil {\n\t\treturn CertificateResource{}, err\n\t}\n\tcertRes.CertificatePEM = certBytes\n\tmetaBytes, err := cfg.Storage.Load(ctx, StorageKeys.SiteMeta(certRes.issuerKey, normalizedName))\n\tif err != nil {\n\t\treturn CertificateResource{}, err\n\t}\n\terr = json.Unmarshal(metaBytes, &certRes)\n\tif err != nil {\n\t\treturn CertificateResource{}, fmt.Errorf(\"decoding certificate metadata: %v\", err)\n\t}\n\n\treturn certRes, nil\n}\n\n// hashCertificateChain computes the unique hash of certChain,\n// which is the chain of DER-encoded bytes. It returns the\n// hex encoding of the hash.\nfunc hashCertificateChain(certChain [][]byte) string {\n\th := blake3.New()\n\tfor _, certInChain := range certChain {\n\t\th.Write(certInChain)\n\t}\n\treturn fmt.Sprintf(\"%x\", h.Sum(nil))\n}\n\nfunc namesFromCSR(csr *x509.CertificateRequest) []string {\n\tvar nameSet []string\n\t// TODO: CommonName should not be used (it has been deprecated for 25+ years,\n\t// but ZeroSSL CA still requires it to be filled out and not overlap SANs...)\n\tif csr.Subject.CommonName != \"\" {\n\t\tnameSet = append(nameSet, csr.Subject.CommonName)\n\t}\n\tnameSet = append(nameSet, csr.DNSNames...)\n\tnameSet = append(nameSet, csr.EmailAddresses...)\n\tfor _, v := range csr.IPAddresses {\n\t\tnameSet = append(nameSet, v.String())\n\t}\n\tfor _, v := range csr.URIs {\n\t\tnameSet = append(nameSet, v.String())\n\t}\n\treturn nameSet\n}\n\n// preferredDefaultCipherSuites returns an appropriate\n// cipher suite to use depending on hardware support\n// for AES-NI.\n//\n// See https://github.com/mholt/caddy/issues/1674\nfunc preferredDefaultCipherSuites() []uint16 {\n\tif cpuid.CPU.Supports(cpuid.AESNI) {\n\t\treturn defaultCiphersPreferAES\n\t}\n\treturn defaultCiphersPreferChaCha\n}\n\nvar (\n\tdefaultCiphersPreferAES = []uint16{\n\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n\t\ttls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n\t\ttls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n\t\ttls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,\n\t\ttls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,\n\t}\n\tdefaultCiphersPreferChaCha = []uint16{\n\t\ttls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,\n\t\ttls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,\n\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n\t\ttls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n\t\ttls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n\t}\n)\n\n// StandardKeyGenerator is the standard, in-memory key source\n// that uses crypto/rand.\ntype StandardKeyGenerator struct {\n\t// The type of keys to generate.\n\tKeyType KeyType\n}\n\n// GenerateKey generates a new private key according to kg.KeyType.\nfunc (kg StandardKeyGenerator) GenerateKey() (crypto.PrivateKey, error) {\n\tswitch kg.KeyType {\n\tcase ED25519:\n\t\t_, priv, err := ed25519.GenerateKey(rand.Reader)\n\t\treturn priv, err\n\tcase \"\", P256:\n\t\treturn ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tcase P384:\n\t\treturn ecdsa.GenerateKey(elliptic.P384(), rand.Reader)\n\tcase RSA2048:\n\t\treturn rsa.GenerateKey(rand.Reader, 2048)\n\tcase RSA4096:\n\t\treturn rsa.GenerateKey(rand.Reader, 4096)\n\tcase RSA8192:\n\t\treturn rsa.GenerateKey(rand.Reader, 8192)\n\t}\n\treturn nil, fmt.Errorf(\"unrecognized or unsupported key type: %s\", kg.KeyType)\n}\n\n// DefaultKeyGenerator is the default key source.\nvar DefaultKeyGenerator = StandardKeyGenerator{KeyType: P256}\n\n// KeyType enumerates the known/supported key types.\ntype KeyType string\n\n// Constants for all key types we support.\nconst (\n\tED25519 = KeyType(\"ed25519\")\n\tP256    = KeyType(\"p256\")\n\tP384    = KeyType(\"p384\")\n\tRSA2048 = KeyType(\"rsa2048\")\n\tRSA4096 = KeyType(\"rsa4096\")\n\tRSA8192 = KeyType(\"rsa8192\")\n)\n"
        },
        {
          "name": "crypto_test.go",
          "type": "blob",
          "size": 2.5673828125,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"bytes\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/ed25519\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n\t\"testing\"\n)\n\nfunc TestEncodeDecodeRSAPrivateKey(t *testing.T) {\n\tprivateKey, err := rsa.GenerateKey(rand.Reader, 128) // make tests faster; small key size OK for testing\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// test save\n\tsavedBytes, err := PEMEncodePrivateKey(privateKey)\n\tif err != nil {\n\t\tt.Fatal(\"error saving private key:\", err)\n\t}\n\n\t// test load\n\tloadedKey, err := PEMDecodePrivateKey(savedBytes)\n\tif err != nil {\n\t\tt.Error(\"error loading private key:\", err)\n\t}\n\n\t// test load (should fail)\n\t_, err = PEMDecodePrivateKey(savedBytes[2:])\n\tif err == nil {\n\t\tt.Error(\"loading private key should have failed\")\n\t}\n\n\t// verify loaded key is correct\n\tif !privateKeysSame(privateKey, loadedKey) {\n\t\tt.Error(\"Expected key bytes to be the same, but they weren't\")\n\t}\n}\n\nfunc TestSaveAndLoadECCPrivateKey(t *testing.T) {\n\tprivateKey, err := ecdsa.GenerateKey(elliptic.P384(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// test save\n\tsavedBytes, err := PEMEncodePrivateKey(privateKey)\n\tif err != nil {\n\t\tt.Fatal(\"error saving private key:\", err)\n\t}\n\n\t// test load\n\tloadedKey, err := PEMDecodePrivateKey(savedBytes)\n\tif err != nil {\n\t\tt.Error(\"error loading private key:\", err)\n\t}\n\n\t// verify loaded key is correct\n\tif !privateKeysSame(privateKey, loadedKey) {\n\t\tt.Error(\"Expected key bytes to be the same, but they weren't\")\n\t}\n}\n\n// privateKeysSame compares the bytes of a and b and returns true if they are the same.\nfunc privateKeysSame(a, b crypto.PrivateKey) bool {\n\treturn bytes.Equal(privateKeyBytes(a), privateKeyBytes(b))\n}\n\n// privateKeyBytes returns the bytes of DER-encoded key.\nfunc privateKeyBytes(key crypto.PrivateKey) []byte {\n\tvar keyBytes []byte\n\tswitch key := key.(type) {\n\tcase *rsa.PrivateKey:\n\t\tkeyBytes = x509.MarshalPKCS1PrivateKey(key)\n\tcase *ecdsa.PrivateKey:\n\t\tkeyBytes, _ = x509.MarshalECPrivateKey(key)\n\tcase ed25519.PrivateKey:\n\t\treturn key\n\t}\n\treturn keyBytes\n}\n"
        },
        {
          "name": "dnsutil.go",
          "type": "blob",
          "size": 10.0244140625,
          "content": "package certmagic\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/miekg/dns\"\n\t\"go.uber.org/zap\"\n)\n\n// Code in this file adapted from go-acme/lego, July 2020:\n// https://github.com/go-acme/lego\n// by Ludovic Fernandez and Dominik Menke\n//\n// It has been modified.\n\n// findZoneByFQDN determines the zone apex for the given fqdn by recursing\n// up the domain labels until the nameserver returns a SOA record in the\n// answer section. The logger must be non-nil.\nfunc findZoneByFQDN(logger *zap.Logger, fqdn string, nameservers []string) (string, error) {\n\tif !strings.HasSuffix(fqdn, \".\") {\n\t\tfqdn += \".\"\n\t}\n\tsoa, err := lookupSoaByFqdn(logger, fqdn, nameservers)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn soa.zone, nil\n}\n\nfunc lookupSoaByFqdn(logger *zap.Logger, fqdn string, nameservers []string) (*soaCacheEntry, error) {\n\tlogger = logger.Named(\"soa_lookup\")\n\n\tif !strings.HasSuffix(fqdn, \".\") {\n\t\tfqdn += \".\"\n\t}\n\n\tfqdnSOACacheMu.Lock()\n\tdefer fqdnSOACacheMu.Unlock()\n\n\t// prefer cached version if fresh\n\tif ent := fqdnSOACache[fqdn]; ent != nil && !ent.isExpired() {\n\t\tlogger.Debug(\"using cached SOA result\", zap.String(\"entry\", ent.zone))\n\t\treturn ent, nil\n\t}\n\n\tent, err := fetchSoaByFqdn(logger, fqdn, nameservers)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// save result to cache, but don't allow\n\t// the cache to grow out of control\n\tif len(fqdnSOACache) >= 1000 {\n\t\tfor key := range fqdnSOACache {\n\t\t\tdelete(fqdnSOACache, key)\n\t\t\tbreak\n\t\t}\n\t}\n\tfqdnSOACache[fqdn] = ent\n\n\treturn ent, nil\n}\n\nfunc fetchSoaByFqdn(logger *zap.Logger, fqdn string, nameservers []string) (*soaCacheEntry, error) {\n\tvar err error\n\tvar in *dns.Msg\n\n\tlabelIndexes := dns.Split(fqdn)\n\tfor _, index := range labelIndexes {\n\t\tdomain := fqdn[index:]\n\n\t\tin, err = dnsQuery(domain, dns.TypeSOA, nameservers, true)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif in == nil {\n\t\t\tcontinue\n\t\t}\n\t\tlogger.Debug(\"fetched SOA\", zap.String(\"msg\", in.String()))\n\n\t\tswitch in.Rcode {\n\t\tcase dns.RcodeSuccess:\n\t\t\t// Check if we got a SOA RR in the answer section\n\t\t\tif len(in.Answer) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// CNAME records cannot/should not exist at the root of a zone.\n\t\t\t// So we skip a domain when a CNAME is found.\n\t\t\tif dnsMsgContainsCNAME(in) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor _, ans := range in.Answer {\n\t\t\t\tif soa, ok := ans.(*dns.SOA); ok {\n\t\t\t\t\treturn newSoaCacheEntry(soa), nil\n\t\t\t\t}\n\t\t\t}\n\t\tcase dns.RcodeNameError:\n\t\t\t// NXDOMAIN\n\t\tdefault:\n\t\t\t// Any response code other than NOERROR and NXDOMAIN is treated as error\n\t\t\treturn nil, fmt.Errorf(\"unexpected response code '%s' for %s\", dns.RcodeToString[in.Rcode], domain)\n\t\t}\n\t}\n\n\treturn nil, fmt.Errorf(\"could not find the start of authority for %s%s\", fqdn, formatDNSError(in, err))\n}\n\n// dnsMsgContainsCNAME checks for a CNAME answer in msg\nfunc dnsMsgContainsCNAME(msg *dns.Msg) bool {\n\tfor _, ans := range msg.Answer {\n\t\tif _, ok := ans.(*dns.CNAME); ok {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc dnsQuery(fqdn string, rtype uint16, nameservers []string, recursive bool) (*dns.Msg, error) {\n\tm := createDNSMsg(fqdn, rtype, recursive)\n\tvar in *dns.Msg\n\tvar err error\n\tfor _, ns := range nameservers {\n\t\tin, err = sendDNSQuery(m, ns)\n\t\tif err == nil && len(in.Answer) > 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn in, err\n}\n\nfunc createDNSMsg(fqdn string, rtype uint16, recursive bool) *dns.Msg {\n\tm := new(dns.Msg)\n\tm.SetQuestion(fqdn, rtype)\n\n\t// See: https://caddy.community/t/hard-time-getting-a-response-on-a-dns-01-challenge/15721/16\n\tm.SetEdns0(1232, false)\n\tif !recursive {\n\t\tm.RecursionDesired = false\n\t}\n\treturn m\n}\n\nfunc sendDNSQuery(m *dns.Msg, ns string) (*dns.Msg, error) {\n\tudp := &dns.Client{Net: \"udp\", Timeout: dnsTimeout}\n\tin, _, err := udp.Exchange(m, ns)\n\t// two kinds of errors we can handle by retrying with TCP:\n\t// truncation and timeout; see https://github.com/caddyserver/caddy/issues/3639\n\ttruncated := in != nil && in.Truncated\n\ttimeoutErr := err != nil && strings.Contains(err.Error(), \"timeout\")\n\tif truncated || timeoutErr {\n\t\ttcp := &dns.Client{Net: \"tcp\", Timeout: dnsTimeout}\n\t\tin, _, err = tcp.Exchange(m, ns)\n\t}\n\treturn in, err\n}\n\nfunc formatDNSError(msg *dns.Msg, err error) string {\n\tvar parts []string\n\tif msg != nil {\n\t\tparts = append(parts, dns.RcodeToString[msg.Rcode])\n\t}\n\tif err != nil {\n\t\tparts = append(parts, err.Error())\n\t}\n\tif len(parts) > 0 {\n\t\treturn \": \" + strings.Join(parts, \" \")\n\t}\n\treturn \"\"\n}\n\n// soaCacheEntry holds a cached SOA record (only selected fields)\ntype soaCacheEntry struct {\n\tzone      string    // zone apex (a domain name)\n\tprimaryNs string    // primary nameserver for the zone apex\n\texpires   time.Time // time when this cache entry should be evicted\n}\n\nfunc newSoaCacheEntry(soa *dns.SOA) *soaCacheEntry {\n\treturn &soaCacheEntry{\n\t\tzone:      soa.Hdr.Name,\n\t\tprimaryNs: soa.Ns,\n\t\texpires:   time.Now().Add(time.Duration(soa.Refresh) * time.Second),\n\t}\n}\n\n// isExpired checks whether a cache entry should be considered expired.\nfunc (cache *soaCacheEntry) isExpired() bool {\n\treturn time.Now().After(cache.expires)\n}\n\n// systemOrDefaultNameservers attempts to get system nameservers from the\n// resolv.conf file given by path before falling back to hard-coded defaults.\nfunc systemOrDefaultNameservers(path string, defaults []string) []string {\n\tconfig, err := dns.ClientConfigFromFile(path)\n\tif err != nil || len(config.Servers) == 0 {\n\t\treturn defaults\n\t}\n\treturn config.Servers\n}\n\n// populateNameserverPorts ensures that all nameservers have a port number.\nfunc populateNameserverPorts(servers []string) {\n\tfor i := range servers {\n\t\t_, port, _ := net.SplitHostPort(servers[i])\n\t\tif port == \"\" {\n\t\t\tservers[i] = net.JoinHostPort(servers[i], \"53\")\n\t\t}\n\t}\n}\n\n// checkDNSPropagation checks if the expected record has been propagated to all authoritative nameservers.\nfunc checkDNSPropagation(logger *zap.Logger, fqdn string, recType uint16, expectedValue string, checkAuthoritativeServers bool, resolvers []string) (bool, error) {\n\tlogger = logger.Named(\"propagation\")\n\n\tif !strings.HasSuffix(fqdn, \".\") {\n\t\tfqdn += \".\"\n\t}\n\n\t// Initial attempt to resolve at the recursive NS - but do not actually\n\t// dereference (follow) a CNAME record if we are targeting a CNAME record\n\t// itself\n\tif recType != dns.TypeCNAME {\n\t\tr, err := dnsQuery(fqdn, recType, resolvers, true)\n\t\tif err != nil {\n\t\t\treturn false, fmt.Errorf(\"CNAME dns query: %v\", err)\n\t\t}\n\t\tif r.Rcode == dns.RcodeSuccess {\n\t\t\tfqdn = updateDomainWithCName(r, fqdn)\n\t\t}\n\t}\n\n\tif checkAuthoritativeServers {\n\t\tauthoritativeServers, err := lookupNameservers(logger, fqdn, resolvers)\n\t\tif err != nil {\n\t\t\treturn false, fmt.Errorf(\"looking up authoritative nameservers: %v\", err)\n\t\t}\n\t\tpopulateNameserverPorts(authoritativeServers)\n\t\tresolvers = authoritativeServers\n\t}\n\tlogger.Debug(\"checking authoritative nameservers\", zap.Strings(\"resolvers\", resolvers))\n\n\treturn checkAuthoritativeNss(fqdn, recType, expectedValue, resolvers)\n}\n\n// checkAuthoritativeNss queries each of the given nameservers for the expected record.\nfunc checkAuthoritativeNss(fqdn string, recType uint16, expectedValue string, nameservers []string) (bool, error) {\n\tfor _, ns := range nameservers {\n\t\tr, err := dnsQuery(fqdn, recType, []string{ns}, true)\n\t\tif err != nil {\n\t\t\treturn false, fmt.Errorf(\"querying authoritative nameservers: %v\", err)\n\t\t}\n\n\t\tif r.Rcode != dns.RcodeSuccess {\n\t\t\tif r.Rcode == dns.RcodeNameError || r.Rcode == dns.RcodeServerFailure {\n\t\t\t\t// if Present() succeeded, then it must show up eventually, or else\n\t\t\t\t// something is really broken in the DNS provider or their API;\n\t\t\t\t// no need for error here, simply have the caller try again\n\t\t\t\treturn false, nil\n\t\t\t}\n\t\t\treturn false, fmt.Errorf(\"NS %s returned %s for %s\", ns, dns.RcodeToString[r.Rcode], fqdn)\n\t\t}\n\n\t\tfor _, rr := range r.Answer {\n\t\t\tswitch recType {\n\t\t\tcase dns.TypeTXT:\n\t\t\t\tif txt, ok := rr.(*dns.TXT); ok {\n\t\t\t\t\trecord := strings.Join(txt.Txt, \"\")\n\t\t\t\t\tif record == expectedValue {\n\t\t\t\t\t\treturn true, nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase dns.TypeCNAME:\n\t\t\t\tif cname, ok := rr.(*dns.CNAME); ok {\n\t\t\t\t\t// TODO: whether a DNS provider assumes a trailing dot or not varies, and we may have to standardize this in libdns packages\n\t\t\t\t\tif strings.TrimSuffix(cname.Target, \".\") == strings.TrimSuffix(expectedValue, \".\") {\n\t\t\t\t\t\treturn true, nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn false, fmt.Errorf(\"unsupported record type: %d\", recType)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n// lookupNameservers returns the authoritative nameservers for the given fqdn.\nfunc lookupNameservers(logger *zap.Logger, fqdn string, resolvers []string) ([]string, error) {\n\tvar authoritativeNss []string\n\n\tzone, err := findZoneByFQDN(logger, fqdn, resolvers)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not determine the zone for '%s': %w\", fqdn, err)\n\t}\n\n\tr, err := dnsQuery(zone, dns.TypeNS, resolvers, true)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"querying NS resolver for zone '%s' recursively: %v\", zone, err)\n\t}\n\n\tfor _, rr := range r.Answer {\n\t\tif ns, ok := rr.(*dns.NS); ok {\n\t\t\tauthoritativeNss = append(authoritativeNss, strings.ToLower(ns.Ns))\n\t\t}\n\t}\n\n\tif len(authoritativeNss) > 0 {\n\t\treturn authoritativeNss, nil\n\t}\n\treturn nil, errors.New(\"could not determine authoritative nameservers\")\n}\n\n// Update FQDN with CNAME if any\nfunc updateDomainWithCName(r *dns.Msg, fqdn string) string {\n\tfor _, rr := range r.Answer {\n\t\tif cn, ok := rr.(*dns.CNAME); ok {\n\t\t\tif cn.Hdr.Name == fqdn {\n\t\t\t\treturn cn.Target\n\t\t\t}\n\t\t}\n\t}\n\treturn fqdn\n}\n\n// recursiveNameservers are used to pre-check DNS propagation. It\n// picks user-configured nameservers (custom) OR the defaults\n// obtained from resolv.conf and defaultNameservers if none is\n// configured and ensures that all server addresses have a port value.\nfunc recursiveNameservers(custom []string) []string {\n\tvar servers []string\n\tif len(custom) == 0 {\n\t\tservers = systemOrDefaultNameservers(defaultResolvConf, defaultNameservers)\n\t} else {\n\t\tservers = make([]string, len(custom))\n\t\tcopy(servers, custom)\n\t}\n\tpopulateNameserverPorts(servers)\n\treturn servers\n}\n\nvar defaultNameservers = []string{\n\t\"8.8.8.8:53\",\n\t\"8.8.4.4:53\",\n\t\"1.1.1.1:53\",\n\t\"1.0.0.1:53\",\n}\n\nvar dnsTimeout = 10 * time.Second\n\nvar (\n\tfqdnSOACache   = map[string]*soaCacheEntry{}\n\tfqdnSOACacheMu sync.Mutex\n)\n\nconst defaultResolvConf = \"/etc/resolv.conf\"\n"
        },
        {
          "name": "dnsutil_test.go",
          "type": "blob",
          "size": 6.873046875,
          "content": "package certmagic\n\n// Code in this file adapted from go-acme/lego, July 2020:\n// https://github.com/go-acme/lego\n// by Ludovic Fernandez and Dominik Menke\n//\n// It has been modified.\n\nimport (\n\t\"net\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"go.uber.org/zap\"\n)\n\nfunc TestLookupNameserversOK(t *testing.T) {\n\ttestCases := []struct {\n\t\tfqdn string\n\t\tnss  []string\n\t}{\n\t\t{\n\t\t\tfqdn: \"physics.georgetown.edu.\",\n\t\t\tnss:  []string{\"ns4.georgetown.edu.\", \"ns5.georgetown.edu.\", \"ns6.georgetown.edu.\"},\n\t\t},\n\t}\n\n\tfor i, test := range testCases {\n\t\ttest := test\n\t\ti := i\n\t\tt.Run(test.fqdn, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tnss, err := lookupNameservers(zap.NewNop(), test.fqdn, recursiveNameservers(nil))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Expected no error, got: %v\", err)\n\t\t\t}\n\n\t\t\tsort.Strings(nss)\n\t\t\tsort.Strings(test.nss)\n\n\t\t\tif !reflect.DeepEqual(test.nss, nss) {\n\t\t\t\tt.Errorf(\"Test %d: expected %+v but got %+v\", i, test.nss, nss)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLookupNameserversErr(t *testing.T) {\n\ttestCases := []struct {\n\t\tdesc  string\n\t\tfqdn  string\n\t\terror string\n\t}{\n\t\t{\n\t\t\tdesc:  \"invalid tld\",\n\t\t\tfqdn:  \"_null.n0n0.\",\n\t\t\terror: \"could not determine the zone\",\n\t\t},\n\t}\n\n\tfor i, test := range testCases {\n\t\ttest := test\n\t\ti := i\n\t\tt.Run(test.desc, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t_, err := lookupNameservers(zap.NewNop(), test.fqdn, nil)\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"expected error, got none\")\n\t\t\t}\n\t\t\tif !strings.Contains(err.Error(), test.error) {\n\t\t\t\tt.Errorf(\"Test %d: Expected error to contain '%s' but got '%s'\", i, test.error, err.Error())\n\t\t\t}\n\t\t})\n\t}\n}\n\nvar findXByFqdnTestCases = []struct {\n\tdesc          string\n\tfqdn          string\n\tzone          string\n\tprimaryNs     string\n\tnameservers   []string\n\texpectedError string\n\tskipTest      bool\n}{\n\t{\n\t\tdesc:        \"domain is a CNAME\",\n\t\tfqdn:        \"scholar.google.com.\",\n\t\tzone:        \"google.com.\",\n\t\tprimaryNs:   \"ns1.google.com.\",\n\t\tnameservers: recursiveNameservers(nil),\n\t},\n\t{\n\t\tdesc:        \"domain is a non-existent subdomain\",\n\t\tfqdn:        \"foo.google.com.\",\n\t\tzone:        \"google.com.\",\n\t\tprimaryNs:   \"ns1.google.com.\",\n\t\tnameservers: recursiveNameservers(nil),\n\t},\n\t{\n\t\tdesc:        \"domain is a eTLD\",\n\t\tfqdn:        \"example.com.ac.\",\n\t\tzone:        \"ac.\",\n\t\tprimaryNs:   \"a0.nic.ac.\",\n\t\tnameservers: recursiveNameservers(nil),\n\t},\n\t{\n\t\tdesc:        \"domain is a cross-zone CNAME\",\n\t\tfqdn:        \"cross-zone-example.assets.sh.\",\n\t\tzone:        \"assets.sh.\",\n\t\tprimaryNs:   \"gina.ns.cloudflare.com.\",\n\t\tnameservers: recursiveNameservers(nil),\n\t},\n\t{\n\t\tdesc:          \"NXDOMAIN\",\n\t\tfqdn:          \"test.loho.jkl.\",\n\t\tzone:          \"loho.jkl.\",\n\t\tnameservers:   []string{\"1.1.1.1:53\"},\n\t\texpectedError: \"could not find the start of authority for test.loho.jkl.: NXDOMAIN\",\n\t},\n\t{\n\t\tdesc:        \"several non existent nameservers\",\n\t\tfqdn:        \"scholar.google.com.\",\n\t\tzone:        \"google.com.\",\n\t\tprimaryNs:   \"ns1.google.com.\",\n\t\tnameservers: []string{\":7053\", \":8053\", \"1.1.1.1:53\"},\n\t\t// Windows takes a super long time to timeout and this negatively impacts CI.\n\t\t// Essentially, we know this works, but Windows is just slow to give up.\n\t\tskipTest: runtime.GOOS == \"windows\",\n\t},\n\t{\n\t\tdesc:          \"only non existent nameservers\",\n\t\tfqdn:          \"scholar.google.com.\",\n\t\tzone:          \"google.com.\",\n\t\tnameservers:   []string{\":7053\", \":8053\", \":9053\"},\n\t\texpectedError: \"could not find the start of authority for scholar.google.com.:\",\n\t\t// Windows takes a super long time to timeout and this negatively impacts CI.\n\t\t// Essentially, we know this works, but Windows is just slow to give up.\n\t\tskipTest: runtime.GOOS == \"windows\",\n\t},\n\t{\n\t\tdesc:          \"no nameservers\",\n\t\tfqdn:          \"test.ldez.com.\",\n\t\tzone:          \"ldez.com.\",\n\t\tnameservers:   []string{},\n\t\texpectedError: \"could not find the start of authority for test.ldez.com.\",\n\t},\n}\n\nfunc TestFindZoneByFqdn(t *testing.T) {\n\tfor i, test := range findXByFqdnTestCases {\n\t\tt.Run(test.desc, func(t *testing.T) {\n\t\t\tif test.skipTest {\n\t\t\t\tt.Skip(\"skipping test\")\n\t\t\t}\n\t\t\tclearFqdnCache()\n\n\t\t\tzone, err := findZoneByFQDN(zap.NewNop(), test.fqdn, test.nameservers)\n\t\t\tif test.expectedError != \"\" {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"test %d: expected error, got none\", i)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !strings.Contains(err.Error(), test.expectedError) {\n\t\t\t\t\tt.Errorf(\"test %d: expected error to contain '%s' but got '%s'\", i, test.expectedError, err.Error())\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"test %d: expected no error, but got: %v\", i, err)\n\t\t\t\t}\n\t\t\t\tif zone != test.zone {\n\t\t\t\t\tt.Errorf(\"test %d: expected zone '%s' but got '%s'\", i, zone, test.zone)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestResolveConfServers(t *testing.T) {\n\tvar testCases = []struct {\n\t\tfixture  string\n\t\texpected []string\n\t\tdefaults []string\n\t}{\n\t\t{\n\t\t\tfixture:  \"testdata/resolv.conf.1\",\n\t\t\tdefaults: []string{\"127.0.0.1:53\"},\n\t\t\texpected: []string{\"10.200.3.249\", \"10.200.3.250:5353\", \"2001:4860:4860::8844\", \"[10.0.0.1]:5353\"},\n\t\t},\n\t\t{\n\t\t\tfixture:  \"testdata/resolv.conf.nonexistent\",\n\t\t\tdefaults: []string{\"127.0.0.1:53\"},\n\t\t\texpected: []string{\"127.0.0.1:53\"},\n\t\t},\n\t}\n\n\tfor i, test := range testCases {\n\t\tt.Run(test.fixture, func(t *testing.T) {\n\t\t\tresult := systemOrDefaultNameservers(test.fixture, test.defaults)\n\n\t\t\tsort.Strings(result)\n\t\t\tsort.Strings(test.expected)\n\n\t\t\tif !reflect.DeepEqual(test.expected, result) {\n\t\t\t\tt.Errorf(\"Test %d: Expected %v but got %v\", i, test.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRecursiveNameserversAddsPort(t *testing.T) {\n\ttype want struct {\n\t\tport string\n\t}\n\tcustom := []string{\"127.0.0.1\", \"ns1.google.com:43\"}\n\texpectations := []want{{port: \"53\"}, {port: \"43\"}}\n\tresults := recursiveNameservers(custom)\n\n\tif !reflect.DeepEqual(custom, []string{\"127.0.0.1\", \"ns1.google.com:43\"}) {\n\t\tt.Errorf(\"Expected custom nameservers to be unmodified. got %v\", custom)\n\t}\n\n\tif len(results) != len(expectations) {\n\t\tt.Errorf(\"%v wrong results length. got %d, want %d\", results, len(results), len(expectations))\n\t}\n\n\tvar hasCustom bool\n\tfor i, res := range results {\n\t\thasCustom = hasCustom || strings.HasPrefix(res, custom[0])\n\t\tif _, port, err := net.SplitHostPort(res); err != nil {\n\t\t\tt.Errorf(\"%v Error splitting result %d into host and port: %v\", results, i, err)\n\t\t} else {\n\t\t\tif port != expectations[i].port {\n\t\t\t\tt.Errorf(\"%v Expected result %d to have port %s but got %s\", results, i, expectations[i].port, port)\n\t\t\t}\n\t\t}\n\t}\n\tif !hasCustom {\n\t\tt.Errorf(\"%v Expected custom resolvers to be included, but they weren't: %v\", results, custom)\n\t}\n\n}\n\nfunc TestRecursiveNameserversDefaults(t *testing.T) {\n\tresults := recursiveNameservers(nil)\n\tif len(results) < 1 {\n\t\tt.Errorf(\"%v Expected at least 1 records as default when nil custom\", results)\n\t}\n\n\tresults = recursiveNameservers([]string{})\n\tif len(results) < 1 {\n\t\tt.Errorf(\"%v Expected at least 1 records as default when empty custom\", results)\n\t}\n}\n\nfunc clearFqdnCache() {\n\tfqdnSOACacheMu.Lock()\n\tfqdnSOACache = make(map[string]*soaCacheEntry)\n\tfqdnSOACacheMu.Unlock()\n}\n"
        },
        {
          "name": "doc_test.go",
          "type": "blob",
          "size": 1.0546875,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\n// This is the simplest way for HTTP servers to use this package.\n// Call HTTPS() with your domain names and your handler (or nil\n// for the http.DefaultMux), and CertMagic will do the rest.\nfunc ExampleHTTPS() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, HTTPS visitor!\")\n\t})\n\n\terr := HTTPS([]string{\"example.com\", \"www.example.com\"}, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"
        },
        {
          "name": "filestorage.go",
          "type": "blob",
          "size": 13.54296875,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"log\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"time\"\n\n\t\"github.com/caddyserver/certmagic/internal/atomicfile\"\n)\n\n// FileStorage facilitates forming file paths derived from a root\n// directory. It is used to get file paths in a consistent,\n// cross-platform way or persisting ACME assets on the file system.\n// The presence of a lock file for a given key indicates a lock\n// is held and is thus unavailable.\n//\n// Locks are created atomically by relying on the file system to\n// enforce the O_EXCL flag. Acquirers that are forcefully terminated\n// will not have a chance to clean up their locks before they exit,\n// so locks may become stale. That is why, while a lock is actively\n// held, the contents of the lockfile are updated with the current\n// timestamp periodically. If another instance tries to acquire the\n// lock but fails, it can see if the timestamp within is still fresh.\n// If so, it patiently waits by polling occasionally. Otherwise,\n// the stale lockfile is deleted, essentially forcing an unlock.\n//\n// While locking is atomic, unlocking is not perfectly atomic. File\n// systems offer native atomic operations when creating files, but\n// not necessarily when deleting them. It is theoretically possible\n// for two instances to discover the same stale lock and both proceed\n// to delete it, but if one instance is able to delete the lockfile\n// and create a new one before the other one calls delete, then the\n// new lock file created by the first instance will get deleted by\n// mistake. This does mean that mutual exclusion is not guaranteed\n// to be perfectly enforced in the presence of stale locks. One\n// alternative is to lock the unlock operation by using \".unlock\"\n// files; and we did this for some time, but those files themselves\n// may become stale, leading applications into infinite loops if\n// they always expect the unlock file to be deleted by the instance\n// that created it. We instead prefer the simpler solution that\n// implies imperfect mutual exclusion if locks become stale, but\n// that is probably less severe a consequence than infinite loops.\n//\n// See https://github.com/caddyserver/caddy/issues/4448 for discussion.\n// See commit 468bfd25e452196b140148928cdd1f1a2285ae4b for where we\n// switched away from using .unlock files.\ntype FileStorage struct {\n\tPath string\n}\n\n// Exists returns true if key exists in s.\nfunc (s *FileStorage) Exists(_ context.Context, key string) bool {\n\t_, err := os.Stat(s.Filename(key))\n\treturn !errors.Is(err, fs.ErrNotExist)\n}\n\n// Store saves value at key.\nfunc (s *FileStorage) Store(_ context.Context, key string, value []byte) error {\n\tfilename := s.Filename(key)\n\terr := os.MkdirAll(filepath.Dir(filename), 0700)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfp, err := atomicfile.New(filename, 0o600)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = fp.Write(value)\n\tif err != nil {\n\t\t// cancel the write\n\t\tfp.Cancel()\n\t\treturn err\n\t}\n\t// close, thereby flushing the write\n\treturn fp.Close()\n}\n\n// Load retrieves the value at key.\nfunc (s *FileStorage) Load(_ context.Context, key string) ([]byte, error) {\n\t// i believe it's possible for the read call to error but still return bytes, in event of something like a shortread?\n\t// therefore, i think it's appropriate to not return any bytes to avoid downstream users of the package erroniously believing that\n\t// bytes read + error is a valid response (it should not be)\n\txs, err := os.ReadFile(s.Filename(key))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn xs, nil\n}\n\n// Delete deletes the value at key.\nfunc (s *FileStorage) Delete(_ context.Context, key string) error {\n\treturn os.RemoveAll(s.Filename(key))\n}\n\n// List returns all keys that match prefix.\nfunc (s *FileStorage) List(ctx context.Context, prefix string, recursive bool) ([]string, error) {\n\tvar keys []string\n\twalkPrefix := s.Filename(prefix)\n\n\terr := filepath.Walk(walkPrefix, func(fpath string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info == nil {\n\t\t\treturn fmt.Errorf(\"%s: file info is nil\", fpath)\n\t\t}\n\t\tif fpath == walkPrefix {\n\t\t\treturn nil\n\t\t}\n\t\tif ctxErr := ctx.Err(); ctxErr != nil {\n\t\t\treturn ctxErr\n\t\t}\n\n\t\tsuffix, err := filepath.Rel(walkPrefix, fpath)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%s: could not make path relative: %v\", fpath, err)\n\t\t}\n\t\tkeys = append(keys, path.Join(prefix, suffix))\n\n\t\tif !recursive && info.IsDir() {\n\t\t\treturn filepath.SkipDir\n\t\t}\n\t\treturn nil\n\t})\n\n\treturn keys, err\n}\n\n// Stat returns information about key.\nfunc (s *FileStorage) Stat(_ context.Context, key string) (KeyInfo, error) {\n\tfi, err := os.Stat(s.Filename(key))\n\tif err != nil {\n\t\treturn KeyInfo{}, err\n\t}\n\treturn KeyInfo{\n\t\tKey:        key,\n\t\tModified:   fi.ModTime(),\n\t\tSize:       fi.Size(),\n\t\tIsTerminal: !fi.IsDir(),\n\t}, nil\n}\n\n// Filename returns the key as a path on the file\n// system prefixed by s.Path.\nfunc (s *FileStorage) Filename(key string) string {\n\treturn filepath.Join(s.Path, filepath.FromSlash(key))\n}\n\n// Lock obtains a lock named by the given name. It blocks\n// until the lock can be obtained or an error is returned.\nfunc (s *FileStorage) Lock(ctx context.Context, name string) error {\n\tfilename := s.lockFilename(name)\n\n\t// sometimes the lockfiles read as empty (size 0) - this is either a stale lock or it\n\t// is currently being written; we can retry a few times in this case, as it has been\n\t// shown to help (issue #232)\n\tvar emptyCount int\n\n\tfor {\n\t\terr := createLockfile(filename)\n\t\tif err == nil {\n\t\t\t// got the lock, yay\n\t\t\treturn nil\n\t\t}\n\t\tif !os.IsExist(err) {\n\t\t\t// unexpected error\n\t\t\treturn fmt.Errorf(\"creating lock file: %v\", err)\n\t\t}\n\n\t\t// lock file already exists\n\n\t\tvar meta lockMeta\n\t\tf, err := os.Open(filename)\n\t\tif err == nil {\n\t\t\terr2 := json.NewDecoder(f).Decode(&meta)\n\t\t\tf.Close()\n\t\t\tif errors.Is(err2, io.EOF) {\n\t\t\t\temptyCount++\n\t\t\t\tif emptyCount < 8 {\n\t\t\t\t\t// wait for brief time and retry; could be that the file is in the process\n\t\t\t\t\t// of being written or updated (which involves truncating) - see issue #232\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-time.After(250 * time.Millisecond):\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t\treturn ctx.Err()\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\t// lockfile is empty or truncated multiple times; I *think* we can assume\n\t\t\t\t\t// the previous acquirer either crashed or had some sort of failure that\n\t\t\t\t\t// caused them to be unable to fully acquire or retain the lock, therefore\n\t\t\t\t\t// we should treat it as if the lockfile did not exist\n\t\t\t\t\tlog.Printf(\"[INFO][%s] %s: Empty lockfile (%v) - likely previous process crashed or storage medium failure; treating as stale\", s, filename, err2)\n\t\t\t\t}\n\t\t\t} else if err2 != nil {\n\t\t\t\treturn fmt.Errorf(\"decoding lockfile contents: %w\", err2)\n\t\t\t}\n\t\t}\n\n\t\tswitch {\n\t\tcase os.IsNotExist(err):\n\t\t\t// must have just been removed; try again to create it\n\t\t\tcontinue\n\n\t\tcase err != nil:\n\t\t\t// unexpected error\n\t\t\treturn fmt.Errorf(\"accessing lock file: %v\", err)\n\n\t\tcase fileLockIsStale(meta):\n\t\t\t// lock file is stale - delete it and try again to obtain lock\n\t\t\t// (NOTE: locking becomes imperfect if lock files are stale; known solutions\n\t\t\t// either have potential to cause infinite loops, as in caddyserver/caddy#4448,\n\t\t\t// or must give up on perfect mutual exclusivity; however, these cases are rare,\n\t\t\t// so we prefer the simpler solution that avoids infinite loops)\n\t\t\tlog.Printf(\"[INFO][%s] Lock for '%s' is stale (created: %s, last update: %s); removing then retrying: %s\",\n\t\t\t\ts, name, meta.Created, meta.Updated, filename)\n\t\t\tif err = os.Remove(filename); err != nil { // hopefully we can replace the lock file quickly!\n\t\t\t\tif !errors.Is(err, fs.ErrNotExist) {\n\t\t\t\t\treturn fmt.Errorf(\"unable to delete stale lockfile; deadlocked: %w\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue\n\n\t\tdefault:\n\t\t\t// lockfile exists and is not stale;\n\t\t\t// just wait a moment and try again,\n\t\t\t// or return if context cancelled\n\t\t\tselect {\n\t\t\tcase <-time.After(fileLockPollInterval):\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn ctx.Err()\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Unlock releases the lock for name.\nfunc (s *FileStorage) Unlock(_ context.Context, name string) error {\n\treturn os.Remove(s.lockFilename(name))\n}\n\nfunc (s *FileStorage) String() string {\n\treturn \"FileStorage:\" + s.Path\n}\n\nfunc (s *FileStorage) lockFilename(name string) string {\n\treturn filepath.Join(s.lockDir(), StorageKeys.Safe(name)+\".lock\")\n}\n\nfunc (s *FileStorage) lockDir() string {\n\treturn filepath.Join(s.Path, \"locks\")\n}\n\nfunc fileLockIsStale(meta lockMeta) bool {\n\tref := meta.Updated\n\tif ref.IsZero() {\n\t\tref = meta.Created\n\t}\n\t// since updates are exactly every lockFreshnessInterval,\n\t// add a grace period for the actual file read+write to\n\t// take place\n\treturn time.Since(ref) > lockFreshnessInterval*2\n}\n\n// createLockfile atomically creates the lockfile\n// identified by filename. A successfully created\n// lockfile should be removed with removeLockfile.\nfunc createLockfile(filename string) error {\n\terr := atomicallyCreateFile(filename, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tgo keepLockfileFresh(filename)\n\n\treturn nil\n}\n\n// keepLockfileFresh continuously updates the lock file\n// at filename with the current timestamp. It stops\n// when the file disappears (happy path = lock released),\n// or when there is an error at any point. Since it polls\n// every lockFreshnessInterval, this function might\n// not terminate until up to lockFreshnessInterval after\n// the lock is released.\nfunc keepLockfileFresh(filename string) {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tbuf := make([]byte, stackTraceBufferSize)\n\t\t\tbuf = buf[:runtime.Stack(buf, false)]\n\t\t\tlog.Printf(\"panic: active locking: %v\\n%s\", err, buf)\n\t\t}\n\t}()\n\n\tfor {\n\t\ttime.Sleep(lockFreshnessInterval)\n\t\tdone, err := updateLockfileFreshness(filename)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[ERROR] Keeping lock file fresh: %v - terminating lock maintenance (lockfile: %s)\", err, filename)\n\t\t\treturn\n\t\t}\n\t\tif done {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// updateLockfileFreshness updates the lock file at filename\n// with the current timestamp. It returns true if the parent\n// loop can terminate (i.e. no more need to update the lock).\nfunc updateLockfileFreshness(filename string) (bool, error) {\n\tf, err := os.OpenFile(filename, os.O_RDWR, 0644)\n\tif os.IsNotExist(err) {\n\t\treturn true, nil // lock released\n\t}\n\tif err != nil {\n\t\treturn true, err\n\t}\n\tdefer f.Close()\n\n\t// read contents\n\tmetaBytes, err := io.ReadAll(io.LimitReader(f, 2048))\n\tif err != nil {\n\t\treturn true, err\n\t}\n\tvar meta lockMeta\n\tif err := json.Unmarshal(metaBytes, &meta); err != nil {\n\t\t// see issue #232: this can error if the file is empty,\n\t\t// which happens sometimes when the disk is REALLY slow\n\t\treturn true, err\n\t}\n\n\t// truncate file and reset I/O offset to beginning\n\tif err := f.Truncate(0); err != nil {\n\t\treturn true, err\n\t}\n\tif _, err := f.Seek(0, io.SeekStart); err != nil {\n\t\treturn true, err\n\t}\n\n\t// write updated timestamp\n\tmeta.Updated = time.Now()\n\tif err = json.NewEncoder(f).Encode(meta); err != nil {\n\t\treturn false, err\n\t}\n\n\t// sync to device; we suspect that sometimes file systems\n\t// (particularly AWS EFS) don't do this on their own,\n\t// leaving the file empty when we close it; see\n\t// https://github.com/caddyserver/caddy/issues/3954\n\treturn false, f.Sync()\n}\n\n// atomicallyCreateFile atomically creates the file\n// identified by filename if it doesn't already exist.\nfunc atomicallyCreateFile(filename string, writeLockInfo bool) error {\n\t// no need to check this error, we only really care about the file creation error\n\t_ = os.MkdirAll(filepath.Dir(filename), 0700)\n\tf, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_EXCL, 0644)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\tif writeLockInfo {\n\t\tnow := time.Now()\n\t\tmeta := lockMeta{\n\t\t\tCreated: now,\n\t\t\tUpdated: now,\n\t\t}\n\t\tif err := json.NewEncoder(f).Encode(meta); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// see https://github.com/caddyserver/caddy/issues/3954\n\t\tif err := f.Sync(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// homeDir returns the best guess of the current user's home\n// directory from environment variables. If unknown, \".\" (the\n// current directory) is returned instead.\nfunc homeDir() string {\n\thome := os.Getenv(\"HOME\")\n\tif home == \"\" && runtime.GOOS == \"windows\" {\n\t\tdrive := os.Getenv(\"HOMEDRIVE\")\n\t\tpath := os.Getenv(\"HOMEPATH\")\n\t\thome = drive + path\n\t\tif drive == \"\" || path == \"\" {\n\t\t\thome = os.Getenv(\"USERPROFILE\")\n\t\t}\n\t}\n\tif home == \"\" {\n\t\thome = \".\"\n\t}\n\treturn home\n}\n\nfunc dataDir() string {\n\tbaseDir := filepath.Join(homeDir(), \".local\", \"share\")\n\tif xdgData := os.Getenv(\"XDG_DATA_HOME\"); xdgData != \"\" {\n\t\tbaseDir = xdgData\n\t}\n\treturn filepath.Join(baseDir, \"certmagic\")\n}\n\n// lockMeta is written into a lock file.\ntype lockMeta struct {\n\tCreated time.Time `json:\"created,omitempty\"`\n\tUpdated time.Time `json:\"updated,omitempty\"`\n}\n\n// lockFreshnessInterval is how often to update\n// a lock's timestamp. Locks with a timestamp\n// more than this duration in the past (plus a\n// grace period for latency) can be considered\n// stale.\nconst lockFreshnessInterval = 5 * time.Second\n\n// fileLockPollInterval is how frequently\n// to check the existence of a lock file\nconst fileLockPollInterval = 1 * time.Second\n\n// Interface guard\nvar _ Storage = (*FileStorage)(nil)\n"
        },
        {
          "name": "filestorage_test.go",
          "type": "blob",
          "size": 1.998046875,
          "content": "package certmagic_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/caddyserver/certmagic\"\n\t\"github.com/caddyserver/certmagic/internal/testutil\"\n)\n\nfunc TestFileStorageStoreLoad(t *testing.T) {\n\tctx := context.Background()\n\ttmpDir, err := os.MkdirTemp(os.TempDir(), \"certmagic*\")\n\ttestutil.RequireNoError(t, err, \"allocating tmp dir\")\n\tdefer os.RemoveAll(tmpDir)\n\ts := &certmagic.FileStorage{\n\t\tPath: tmpDir,\n\t}\n\terr = s.Store(ctx, \"foo\", []byte(\"bar\"))\n\ttestutil.RequireNoError(t, err)\n\tdat, err := s.Load(ctx, \"foo\")\n\ttestutil.RequireNoError(t, err)\n\ttestutil.RequireEqualValues(t, dat, []byte(\"bar\"))\n}\n\nfunc TestFileStorageStoreLoadRace(t *testing.T) {\n\tctx := context.Background()\n\ttmpDir, err := os.MkdirTemp(os.TempDir(), \"certmagic*\")\n\ttestutil.RequireNoError(t, err, \"allocating tmp dir\")\n\tdefer os.RemoveAll(tmpDir)\n\ts := &certmagic.FileStorage{\n\t\tPath: tmpDir,\n\t}\n\ta := bytes.Repeat([]byte(\"a\"), 4096*1024)\n\tb := bytes.Repeat([]byte(\"b\"), 4096*1024)\n\terr = s.Store(ctx, \"foo\", a)\n\ttestutil.RequireNoError(t, err)\n\tdone := make(chan struct{})\n\tgo func() {\n\t\terr := s.Store(ctx, \"foo\", b)\n\t\ttestutil.RequireNoError(t, err)\n\t\tclose(done)\n\t}()\n\tdat, err := s.Load(ctx, \"foo\")\n\t<-done\n\ttestutil.RequireNoError(t, err)\n\ttestutil.RequireEqualValues(t, 4096*1024, len(dat))\n}\n\nfunc TestFileStorageWriteLock(t *testing.T) {\n\tctx := context.Background()\n\ttmpDir, err := os.MkdirTemp(os.TempDir(), \"certmagic*\")\n\ttestutil.RequireNoError(t, err, \"allocating tmp dir\")\n\tdefer os.RemoveAll(tmpDir)\n\ts := &certmagic.FileStorage{\n\t\tPath: tmpDir,\n\t}\n\t// cctx is a cancelled ctx. so if we can't immediately get the lock, it will fail\n\tcctx, cn := context.WithCancel(ctx)\n\tcn()\n\t// should success\n\terr = s.Lock(cctx, \"foo\")\n\ttestutil.RequireNoError(t, err)\n\t// should fail\n\terr = s.Lock(cctx, \"foo\")\n\ttestutil.RequireError(t, err)\n\n\terr = s.Unlock(cctx, \"foo\")\n\ttestutil.RequireNoError(t, err)\n\t// shouldn't fail\n\terr = s.Lock(cctx, \"foo\")\n\ttestutil.RequireNoError(t, err)\n\n\terr = s.Unlock(cctx, \"foo\")\n\ttestutil.RequireNoError(t, err)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.6318359375,
          "content": "module github.com/caddyserver/certmagic\n\ngo 1.21.0\n\ntoolchain go1.22.2\n\nrequire (\n\tgithub.com/caddyserver/zerossl v0.1.3\n\tgithub.com/klauspost/cpuid/v2 v2.2.9\n\tgithub.com/libdns/libdns v0.2.2\n\tgithub.com/mholt/acmez/v3 v3.0.1\n\tgithub.com/miekg/dns v1.1.62\n\tgithub.com/zeebo/blake3 v0.2.4\n\tgo.uber.org/zap v1.27.0\n\tgo.uber.org/zap/exp v0.3.0\n\tgolang.org/x/crypto v0.31.0\n\tgolang.org/x/net v0.33.0\n)\n\nrequire (\n\tgo.uber.org/multierr v1.11.0 // indirect\n\tgolang.org/x/mod v0.18.0 // indirect\n\tgolang.org/x/sync v0.10.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n\tgolang.org/x/tools v0.22.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 3.6357421875,
          "content": "github.com/caddyserver/zerossl v0.1.3 h1:onS+pxp3M8HnHpN5MMbOMyNjmTheJyWRaZYwn+YTAyA=\ngithub.com/caddyserver/zerossl v0.1.3/go.mod h1:CxA0acn7oEGO6//4rtrRjYgEoa4MFw/XofZnrYwGqG4=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/klauspost/cpuid/v2 v2.2.9 h1:66ze0taIn2H33fBvCkXuv9BmCwDfafmiIVpKV9kKGuY=\ngithub.com/klauspost/cpuid/v2 v2.2.9/go.mod h1:rqkxqrZ1EhYM9G+hXH7YdowN5R5RGN6NK4QwQ3WMXF8=\ngithub.com/libdns/libdns v0.2.2 h1:O6ws7bAfRPaBsgAYt8MDe2HcNBGC29hkZ9MX2eUSX3s=\ngithub.com/libdns/libdns v0.2.2/go.mod h1:4Bj9+5CQiNMVGf87wjX4CY3HQJypUHRuLvlsfsZqLWQ=\ngithub.com/mholt/acmez/v3 v3.0.1 h1:4PcjKjaySlgXK857aTfDuRbmnM5gb3Ruz3tvoSJAUp8=\ngithub.com/mholt/acmez/v3 v3.0.1/go.mod h1:L1wOU06KKvq7tswuMDwKdcHeKpFFgkppZy/y0DFxagQ=\ngithub.com/miekg/dns v1.1.62 h1:cN8OuEF1/x5Rq6Np+h1epln8OiyPWV+lROx9LxcGgIQ=\ngithub.com/miekg/dns v1.1.62/go.mod h1:mvDlcItzm+br7MToIKqkglaGhlFMHJ9DTNNWONWXbNQ=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/testify v1.8.1 h1:w7B6lhMri9wdJUVmEZPGGhZzrYTPvgJArz7wNPgYKsk=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/zeebo/assert v1.1.0 h1:hU1L1vLTHsnO8x8c9KAR5GmM5QscxHg5RNU5z5qbUWY=\ngithub.com/zeebo/assert v1.1.0/go.mod h1:Pq9JiuJQpG8JLJdtkwrJESF0Foym2/D9XMU5ciN/wJ0=\ngithub.com/zeebo/blake3 v0.2.4 h1:KYQPkhpRtcqh0ssGYcKLG1JYvddkEA8QwCM/yBqhaZI=\ngithub.com/zeebo/blake3 v0.2.4/go.mod h1:7eeQ6d2iXWRGF6npfaxl2CU+xy2Fjo2gxeyZGCRUjcE=\ngithub.com/zeebo/pcg v1.0.1 h1:lyqfGeWiv4ahac6ttHs+I5hwtH/+1mrhlCtVNQM2kHo=\ngithub.com/zeebo/pcg v1.0.1/go.mod h1:09F0S9iiKrwn9rlI5yjLkmrug154/YRW6KnnXVDM/l4=\ngo.uber.org/goleak v1.3.0 h1:2K3zAYmnTNqV73imy9J1T3WC+gmCePx2hEGkimedGto=\ngo.uber.org/goleak v1.3.0/go.mod h1:CoHD4mav9JJNrW/WLlf7HGZPjdw8EucARQHekz1X6bE=\ngo.uber.org/multierr v1.11.0 h1:blXXJkSxSSfBVBlC76pxqeO+LN3aDfLQo+309xJstO0=\ngo.uber.org/multierr v1.11.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=\ngo.uber.org/zap v1.27.0 h1:aJMhYGrd5QSmlpLMr2MftRKl7t8J8PTZPA732ud/XR8=\ngo.uber.org/zap v1.27.0/go.mod h1:GB2qFLM7cTU87MWRP2mPIjqfIDnGu+VIO4V/SdhGo2E=\ngo.uber.org/zap/exp v0.3.0 h1:6JYzdifzYkGmTdRR59oYH+Ng7k49H9qVpWwNSsGJj3U=\ngo.uber.org/zap/exp v0.3.0/go.mod h1:5I384qq7XGxYyByIhHm6jg5CHkGY0nsTfbDLgDDlgJQ=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/mod v0.18.0 h1:5+9lSbEzPSdWkH32vYPBwEpX8KwDbM52Ud9xBUvNlb0=\ngolang.org/x/mod v0.18.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/tools v0.22.0 h1:gqSGLZqv+AI9lIQzniJ0nZDRG5GBPsSi+DRNHWNz6yA=\ngolang.org/x/tools v0.22.0/go.mod h1:aCwcsjqvq7Yqt6TNyX7QMU2enbQ/Gt0bo6krSeEri+c=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "handshake.go",
          "type": "blob",
          "size": 36.9599609375,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/fs\"\n\t\"net\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/mholt/acmez/v3\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/crypto/ocsp\"\n)\n\n// GetCertificate gets a certificate to satisfy clientHello. In getting\n// the certificate, it abides the rules and settings defined in the Config\n// that matches clientHello.ServerName. It tries to get certificates in\n// this order:\n//\n// 1. Exact match in the in-memory cache\n// 2. Wildcard match in the in-memory cache\n// 3. Managers (if any)\n// 4. Storage (if on-demand is enabled)\n// 5. Issuers (if on-demand is enabled)\n//\n// This method is safe for use as a tls.Config.GetCertificate callback.\n//\n// GetCertificate will run in a new context, use GetCertificateWithContext to provide\n// a context.\nfunc (cfg *Config) GetCertificate(clientHello *tls.ClientHelloInfo) (*tls.Certificate, error) {\n\treturn cfg.GetCertificateWithContext(clientHello.Context(), clientHello)\n}\n\nfunc (cfg *Config) GetCertificateWithContext(ctx context.Context, clientHello *tls.ClientHelloInfo) (*tls.Certificate, error) {\n\tif err := cfg.emit(ctx, \"tls_get_certificate\", map[string]any{\"client_hello\": clientHelloWithoutConn(clientHello)}); err != nil {\n\t\tcfg.Logger.Error(\"TLS handshake aborted by event handler\",\n\t\t\tzap.String(\"server_name\", clientHello.ServerName),\n\t\t\tzap.String(\"remote\", clientHello.Conn.RemoteAddr().String()),\n\t\t\tzap.Error(err))\n\t\treturn nil, fmt.Errorf(\"handshake aborted by event handler: %w\", err)\n\t}\n\n\tif ctx == nil {\n\t\t// tests can't set context on a tls.ClientHelloInfo because it's unexported :(\n\t\tctx = context.Background()\n\t}\n\tctx = context.WithValue(ctx, ClientHelloInfoCtxKey, clientHello)\n\n\t// special case: serve up the certificate for a TLS-ALPN ACME challenge\n\t// (https://www.rfc-editor.org/rfc/rfc8737.html)\n\t// \"The ACME server MUST provide an ALPN extension with the single protocol\n\t// name \"acme-tls/1\" and an SNI extension containing only the domain name\n\t// being validated during the TLS handshake.\"\n\tif clientHello.ServerName != \"\" &&\n\t\tlen(clientHello.SupportedProtos) == 1 &&\n\t\tclientHello.SupportedProtos[0] == acmez.ACMETLS1Protocol {\n\t\tchallengeCert, distributed, err := cfg.getTLSALPNChallengeCert(clientHello)\n\t\tif err != nil {\n\t\t\tcfg.Logger.Error(\"tls-alpn challenge\",\n\t\t\t\tzap.String(\"remote_addr\", clientHello.Conn.RemoteAddr().String()),\n\t\t\t\tzap.String(\"server_name\", clientHello.ServerName),\n\t\t\t\tzap.Error(err))\n\t\t\treturn nil, err\n\t\t}\n\t\tcfg.Logger.Info(\"served key authentication certificate\",\n\t\t\tzap.String(\"server_name\", clientHello.ServerName),\n\t\t\tzap.String(\"challenge\", \"tls-alpn-01\"),\n\t\t\tzap.String(\"remote\", clientHello.Conn.RemoteAddr().String()),\n\t\t\tzap.Bool(\"distributed\", distributed))\n\t\treturn challengeCert, nil\n\t}\n\n\t// get the certificate and serve it up\n\tcert, err := cfg.getCertDuringHandshake(ctx, clientHello, true)\n\n\treturn &cert.Certificate, err\n}\n\n// getCertificateFromCache gets a certificate that matches name from the in-memory\n// cache, according to the lookup table associated with cfg. The lookup then\n// points to a certificate in the Instance certificate cache.\n//\n// The name is expected to already be normalized (e.g. lowercased).\n//\n// If there is no exact match for name, it will be checked against names of\n// the form '*.example.com' (wildcard certificates) according to RFC 6125.\n// If a match is found, matched will be true. If no matches are found, matched\n// will be false and a \"default\" certificate will be returned with defaulted\n// set to true. If defaulted is false, then no certificates were available.\n//\n// The logic in this function is adapted from the Go standard library,\n// which is by the Go Authors.\n//\n// This function is safe for concurrent use.\nfunc (cfg *Config) getCertificateFromCache(hello *tls.ClientHelloInfo) (cert Certificate, matched, defaulted bool) {\n\tname := normalizedName(hello.ServerName)\n\n\tif name == \"\" {\n\t\t// if SNI is empty, prefer matching IP address\n\t\tif hello.Conn != nil {\n\t\t\taddr := localIPFromConn(hello.Conn)\n\t\t\tcert, matched = cfg.selectCert(hello, addr)\n\t\t\tif matched {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// use a \"default\" certificate by name, if specified\n\t\tif cfg.DefaultServerName != \"\" {\n\t\t\tnormDefault := normalizedName(cfg.DefaultServerName)\n\t\t\tcert, defaulted = cfg.selectCert(hello, normDefault)\n\t\t\tif defaulted {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// if SNI is specified, try an exact match first\n\t\tcert, matched = cfg.selectCert(hello, name)\n\t\tif matched {\n\t\t\treturn\n\t\t}\n\n\t\t// try replacing labels in the name with\n\t\t// wildcards until we get a match\n\t\tlabels := strings.Split(name, \".\")\n\t\tfor i := range labels {\n\t\t\tlabels[i] = \"*\"\n\t\t\tcandidate := strings.Join(labels, \".\")\n\t\t\tcert, matched = cfg.selectCert(hello, candidate)\n\t\t\tif matched {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\t// a fallback server name can be tried in the very niche\n\t// case where a client sends one SNI value but expects or\n\t// accepts a different one in return (this is sometimes\n\t// the case with CDNs like Cloudflare that send the\n\t// downstream ServerName in the handshake but accept\n\t// the backend origin's true hostname in a cert).\n\tif cfg.FallbackServerName != \"\" {\n\t\tnormFallback := normalizedName(cfg.FallbackServerName)\n\t\tcert, defaulted = cfg.selectCert(hello, normFallback)\n\t\tif defaulted {\n\t\t\treturn\n\t\t}\n\t}\n\n\t// otherwise, we're bingo on ammo; see issues\n\t// caddyserver/caddy#2035 and caddyserver/caddy#1303 (any\n\t// change to certificate matching behavior must\n\t// account for hosts defined where the hostname\n\t// is empty or a catch-all, like \":443\" or\n\t// \"0.0.0.0:443\")\n\n\treturn\n}\n\n// selectCert uses hello to select a certificate from the\n// cache for name. If cfg.CertSelection is set, it will be\n// used to make the decision. Otherwise, the first matching\n// unexpired cert is returned. As a special case, if no\n// certificates match name and cfg.CertSelection is set,\n// then all certificates in the cache will be passed in\n// for the cfg.CertSelection to make the final decision.\nfunc (cfg *Config) selectCert(hello *tls.ClientHelloInfo, name string) (Certificate, bool) {\n\tlogger := cfg.Logger.Named(\"handshake\")\n\tchoices := cfg.certCache.getAllMatchingCerts(name)\n\n\tif len(choices) == 0 {\n\t\tif cfg.CertSelection == nil {\n\t\t\tlogger.Debug(\"no matching certificates and no custom selection logic\", zap.String(\"identifier\", name))\n\t\t\treturn Certificate{}, false\n\t\t}\n\t\tlogger.Debug(\"no matching certificate; will choose from all certificates\", zap.String(\"identifier\", name))\n\t\tchoices = cfg.certCache.getAllCerts()\n\t}\n\n\tlogger.Debug(\"choosing certificate\",\n\t\tzap.String(\"identifier\", name),\n\t\tzap.Int(\"num_choices\", len(choices)))\n\n\tif cfg.CertSelection == nil {\n\t\tcert, err := DefaultCertificateSelector(hello, choices)\n\t\tlogger.Debug(\"default certificate selection results\",\n\t\t\tzap.Error(err),\n\t\t\tzap.String(\"identifier\", name),\n\t\t\tzap.Strings(\"subjects\", cert.Names),\n\t\t\tzap.Bool(\"managed\", cert.managed),\n\t\t\tzap.String(\"issuer_key\", cert.issuerKey),\n\t\t\tzap.String(\"hash\", cert.hash))\n\t\treturn cert, err == nil\n\t}\n\n\tcert, err := cfg.CertSelection.SelectCertificate(hello, choices)\n\n\tlogger.Debug(\"custom certificate selection results\",\n\t\tzap.Error(err),\n\t\tzap.String(\"identifier\", name),\n\t\tzap.Strings(\"subjects\", cert.Names),\n\t\tzap.Bool(\"managed\", cert.managed),\n\t\tzap.String(\"issuer_key\", cert.issuerKey),\n\t\tzap.String(\"hash\", cert.hash))\n\n\treturn cert, err == nil\n}\n\n// DefaultCertificateSelector is the default certificate selection logic\n// given a choice of certificates. If there is at least one certificate in\n// choices, it always returns a certificate without error. It chooses the\n// first non-expired certificate that the client supports if possible,\n// otherwise it returns an expired certificate that the client supports,\n// otherwise it just returns the first certificate in the list of choices.\nfunc DefaultCertificateSelector(hello *tls.ClientHelloInfo, choices []Certificate) (Certificate, error) {\n\tif len(choices) == 1 {\n\t\t// Fast path: There's only one choice, so we would always return that one\n\t\t// regardless of whether it is expired or not compatible.\n\t\treturn choices[0], nil\n\t}\n\tif len(choices) == 0 {\n\t\treturn Certificate{}, fmt.Errorf(\"no certificates available\")\n\t}\n\n\t// Slow path: There are choices, so we need to check each of them.\n\tnow := time.Now()\n\tbest := choices[0]\n\tfor _, choice := range choices {\n\t\tif err := hello.SupportsCertificate(&choice.Certificate); err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tbest = choice // at least the client supports it...\n\t\tif now.After(choice.Leaf.NotBefore) && now.Before(expiresAt(choice.Leaf)) {\n\t\t\treturn choice, nil // ...and unexpired, great! \"Certificate, I choose you!\"\n\t\t}\n\t}\n\treturn best, nil // all matching certs are expired or incompatible, oh well\n}\n\n// getCertDuringHandshake will get a certificate for hello. It first tries\n// the in-memory cache. If no exact certificate for hello is in the cache, the\n// config most closely corresponding to hello (like a wildcard) will be loaded.\n// If none could be matched from the cache, it invokes the configured certificate\n// managers to get a certificate and uses the first one that returns a certificate.\n// If no certificate managers return a value, and if the config allows it\n// (OnDemand!=nil) and if loadIfNecessary == true, it goes to storage to load the\n// cert into the cache and serve it. If it's not on disk and if\n// obtainIfNecessary == true, the certificate will be obtained from the CA, cached,\n// and served. If obtainIfNecessary == true, then loadIfNecessary must also be == true.\n// An error will be returned if and only if no certificate is available.\n//\n// This function is safe for concurrent use.\nfunc (cfg *Config) getCertDuringHandshake(ctx context.Context, hello *tls.ClientHelloInfo, loadOrObtainIfNecessary bool) (Certificate, error) {\n\tlogger := logWithRemote(cfg.Logger.Named(\"handshake\"), hello)\n\n\t// First check our in-memory cache to see if we've already loaded it\n\tcert, matched, defaulted := cfg.getCertificateFromCache(hello)\n\tif matched {\n\t\tlogger.Debug(\"matched certificate in cache\",\n\t\t\tzap.Strings(\"subjects\", cert.Names),\n\t\t\tzap.Bool(\"managed\", cert.managed),\n\t\t\tzap.Time(\"expiration\", expiresAt(cert.Leaf)),\n\t\t\tzap.String(\"hash\", cert.hash))\n\t\tif cert.managed && cfg.OnDemand != nil && loadOrObtainIfNecessary {\n\t\t\t// On-demand certificates are maintained in the background, but\n\t\t\t// maintenance is triggered by handshakes instead of by a timer\n\t\t\t// as in maintain.go.\n\t\t\treturn cfg.optionalMaintenance(ctx, cfg.Logger.Named(\"on_demand\"), cert, hello)\n\t\t}\n\t\treturn cert, nil\n\t}\n\n\tname := cfg.getNameFromClientHello(hello)\n\n\t// By this point, we need to load or obtain a certificate. If a swarm of requests comes in for the same\n\t// domain, avoid pounding manager or storage thousands of times simultaneously. We use a similar sync\n\t// strategy for obtaining certificate during handshake.\n\tcertLoadWaitChansMu.Lock()\n\twait, ok := certLoadWaitChans[name]\n\tif ok {\n\t\t// another goroutine is already loading the cert; just wait and we'll get it from the in-memory cache\n\t\tcertLoadWaitChansMu.Unlock()\n\n\t\ttimeout := time.NewTimer(2 * time.Minute)\n\t\tselect {\n\t\tcase <-timeout.C:\n\t\t\treturn Certificate{}, fmt.Errorf(\"timed out waiting to load certificate for %s\", name)\n\t\tcase <-ctx.Done():\n\t\t\ttimeout.Stop()\n\t\t\treturn Certificate{}, ctx.Err()\n\t\tcase <-wait:\n\t\t\ttimeout.Stop()\n\t\t}\n\n\t\treturn cfg.getCertDuringHandshake(ctx, hello, false)\n\t} else {\n\t\t// no other goroutine is currently trying to load this cert\n\t\twait = make(chan struct{})\n\t\tcertLoadWaitChans[name] = wait\n\t\tcertLoadWaitChansMu.Unlock()\n\n\t\t// unblock others and clean up when we're done\n\t\tdefer func() {\n\t\t\tcertLoadWaitChansMu.Lock()\n\t\t\tclose(wait)\n\t\t\tdelete(certLoadWaitChans, name)\n\t\t\tcertLoadWaitChansMu.Unlock()\n\t\t}()\n\t}\n\n\t// If an external Manager is configured, try to get it from them.\n\t// Only continue to use our own logic if it returns empty+nil.\n\texternalCert, err := cfg.getCertFromAnyCertManager(ctx, hello, logger)\n\tif err != nil {\n\t\treturn Certificate{}, err\n\t}\n\tif !externalCert.Empty() {\n\t\treturn externalCert, nil\n\t}\n\n\t// Make sure a certificate is allowed for the given name. If not, it doesn't make sense\n\t// to try loading one from storage (issue #185) or obtaining one from an issuer.\n\tif err := cfg.checkIfCertShouldBeObtained(ctx, name, false); err != nil {\n\t\treturn Certificate{}, fmt.Errorf(\"certificate is not allowed for server name %s: %w\", name, err)\n\t}\n\n\t// We might be able to load or obtain a needed certificate. Load from\n\t// storage if OnDemand is enabled, or if there is the possibility that\n\t// a statically-managed cert was evicted from a full cache.\n\tcfg.certCache.mu.RLock()\n\tcacheSize := len(cfg.certCache.cache)\n\tcfg.certCache.mu.RUnlock()\n\n\t// A cert might have still been evicted from the cache even if the cache\n\t// is no longer completely full; this happens if the newly-loaded cert is\n\t// itself evicted (perhaps due to being expired or unmanaged at this point).\n\t// Hence, we use an \"almost full\" metric to allow for the cache to not be\n\t// perfectly full while still being able to load needed certs from storage.\n\t// See https://caddy.community/t/error-tls-alert-internal-error-592-again/13272\n\t// and caddyserver/caddy#4320.\n\tcfg.certCache.optionsMu.RLock()\n\tcacheCapacity := float64(cfg.certCache.options.Capacity)\n\tcfg.certCache.optionsMu.RUnlock()\n\tcacheAlmostFull := cacheCapacity > 0 && float64(cacheSize) >= cacheCapacity*.9\n\tloadDynamically := cfg.OnDemand != nil || cacheAlmostFull\n\n\tif loadDynamically && loadOrObtainIfNecessary {\n\t\t// Check to see if we have one on disk\n\t\tloadedCert, err := cfg.loadCertFromStorage(ctx, logger, hello)\n\t\tif err == nil {\n\t\t\treturn loadedCert, nil\n\t\t}\n\t\tlogger.Debug(\"did not load cert from storage\",\n\t\t\tzap.String(\"server_name\", hello.ServerName),\n\t\t\tzap.Error(err))\n\t\tif cfg.OnDemand != nil {\n\t\t\t// By this point, we need to ask the CA for a certificate\n\t\t\treturn cfg.obtainOnDemandCertificate(ctx, hello)\n\t\t}\n\t\treturn loadedCert, nil\n\t}\n\n\t// Fall back to another certificate if there is one (either DefaultServerName or FallbackServerName)\n\tif defaulted {\n\t\tlogger.Debug(\"fell back to default certificate\",\n\t\t\tzap.Strings(\"subjects\", cert.Names),\n\t\t\tzap.Bool(\"managed\", cert.managed),\n\t\t\tzap.Time(\"expiration\", expiresAt(cert.Leaf)),\n\t\t\tzap.String(\"hash\", cert.hash))\n\t\treturn cert, nil\n\t}\n\n\tlogger.Debug(\"no certificate matching TLS ClientHello\",\n\t\tzap.String(\"server_name\", hello.ServerName),\n\t\tzap.String(\"remote\", hello.Conn.RemoteAddr().String()),\n\t\tzap.String(\"identifier\", name),\n\t\tzap.Uint16s(\"cipher_suites\", hello.CipherSuites),\n\t\tzap.Float64(\"cert_cache_fill\", float64(cacheSize)/cacheCapacity), // may be approximate! because we are not within the lock\n\t\tzap.Bool(\"load_or_obtain_if_necessary\", loadOrObtainIfNecessary),\n\t\tzap.Bool(\"on_demand\", cfg.OnDemand != nil))\n\n\treturn Certificate{}, fmt.Errorf(\"no certificate available for '%s'\", name)\n}\n\n// loadCertFromStorage loads the certificate for name from storage and maintains it\n// (as this is only called with on-demand TLS enabled).\nfunc (cfg *Config) loadCertFromStorage(ctx context.Context, logger *zap.Logger, hello *tls.ClientHelloInfo) (Certificate, error) {\n\tname := cfg.getNameFromClientHello(hello)\n\tloadedCert, err := cfg.CacheManagedCertificate(ctx, name)\n\tif errors.Is(err, fs.ErrNotExist) {\n\t\t// If no exact match, try a wildcard variant, which is something we can still use\n\t\tlabels := strings.Split(name, \".\")\n\t\tlabels[0] = \"*\"\n\t\tloadedCert, err = cfg.CacheManagedCertificate(ctx, strings.Join(labels, \".\"))\n\t}\n\tif err != nil {\n\t\treturn Certificate{}, fmt.Errorf(\"no matching certificate to load for %s: %w\", name, err)\n\t}\n\tlogger.Debug(\"loaded certificate from storage\",\n\t\tzap.Strings(\"subjects\", loadedCert.Names),\n\t\tzap.Bool(\"managed\", loadedCert.managed),\n\t\tzap.Time(\"expiration\", expiresAt(loadedCert.Leaf)),\n\t\tzap.String(\"hash\", loadedCert.hash))\n\tloadedCert, err = cfg.handshakeMaintenance(ctx, hello, loadedCert)\n\tif err != nil {\n\t\tlogger.Error(\"maintaining newly-loaded certificate\",\n\t\t\tzap.String(\"server_name\", name),\n\t\t\tzap.Error(err))\n\t}\n\treturn loadedCert, nil\n}\n\n// optionalMaintenance will perform maintenance on the certificate (if necessary) and\n// will return the resulting certificate. This should only be done if the certificate\n// is managed, OnDemand is enabled, and the scope is allowed to obtain certificates.\nfunc (cfg *Config) optionalMaintenance(ctx context.Context, log *zap.Logger, cert Certificate, hello *tls.ClientHelloInfo) (Certificate, error) {\n\tnewCert, err := cfg.handshakeMaintenance(ctx, hello, cert)\n\tif err == nil {\n\t\treturn newCert, nil\n\t}\n\n\tlog.Error(\"renewing certificate on-demand failed\",\n\t\tzap.Strings(\"subjects\", cert.Names),\n\t\tzap.Time(\"not_after\", expiresAt(cert.Leaf)),\n\t\tzap.Error(err))\n\n\tif cert.Expired() {\n\t\treturn cert, err\n\t}\n\n\t// still has time remaining, so serve it anyway\n\treturn cert, nil\n}\n\n// checkIfCertShouldBeObtained checks to see if an on-demand TLS certificate\n// should be obtained for a given domain based upon the config settings. If\n// a non-nil error is returned, do not issue a new certificate for name.\nfunc (cfg *Config) checkIfCertShouldBeObtained(ctx context.Context, name string, requireOnDemand bool) error {\n\tif requireOnDemand && cfg.OnDemand == nil {\n\t\treturn fmt.Errorf(\"not configured for on-demand certificate issuance\")\n\t}\n\tif !SubjectQualifiesForCert(name) {\n\t\treturn fmt.Errorf(\"subject name does not qualify for certificate: %s\", name)\n\t}\n\tif cfg.OnDemand != nil {\n\t\tif cfg.OnDemand.DecisionFunc != nil {\n\t\t\tif err := cfg.OnDemand.DecisionFunc(ctx, name); err != nil {\n\t\t\t\treturn fmt.Errorf(\"decision func: %w\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tif len(cfg.OnDemand.hostAllowlist) > 0 {\n\t\t\tif _, ok := cfg.OnDemand.hostAllowlist[name]; !ok {\n\t\t\t\treturn fmt.Errorf(\"certificate for '%s' is not managed\", name)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// obtainOnDemandCertificate obtains a certificate for hello.\n// If another goroutine has already started obtaining a cert for\n// hello, it will wait and use what the other goroutine obtained.\n//\n// This function is safe for use by multiple concurrent goroutines.\nfunc (cfg *Config) obtainOnDemandCertificate(ctx context.Context, hello *tls.ClientHelloInfo) (Certificate, error) {\n\tlog := logWithRemote(cfg.Logger.Named(\"on_demand\"), hello)\n\n\tname := cfg.getNameFromClientHello(hello)\n\n\t// We must protect this process from happening concurrently, so synchronize.\n\tobtainCertWaitChansMu.Lock()\n\twait, ok := obtainCertWaitChans[name]\n\tif ok {\n\t\t// lucky us -- another goroutine is already obtaining the certificate.\n\t\t// wait for it to finish obtaining the cert and then we'll use it.\n\t\tobtainCertWaitChansMu.Unlock()\n\n\t\tlog.Debug(\"new certificate is needed, but is already being obtained; waiting for that issuance to complete\",\n\t\t\tzap.String(\"subject\", name))\n\n\t\t// TODO: see if we can get a proper context in here, for true cancellation\n\t\ttimeout := time.NewTimer(2 * time.Minute)\n\t\tselect {\n\t\tcase <-timeout.C:\n\t\t\treturn Certificate{}, fmt.Errorf(\"timed out waiting to obtain certificate for %s\", name)\n\t\tcase <-wait:\n\t\t\ttimeout.Stop()\n\t\t}\n\n\t\t// it should now be loaded in the cache, ready to go; if not,\n\t\t// the goroutine in charge of that probably had an error\n\t\treturn cfg.getCertDuringHandshake(ctx, hello, false)\n\t}\n\n\t// looks like it's up to us to do all the work and obtain the cert.\n\t// make a chan others can wait on if needed\n\twait = make(chan struct{})\n\tobtainCertWaitChans[name] = wait\n\tobtainCertWaitChansMu.Unlock()\n\n\tunblockWaiters := func() {\n\t\tobtainCertWaitChansMu.Lock()\n\t\tclose(wait)\n\t\tdelete(obtainCertWaitChans, name)\n\t\tobtainCertWaitChansMu.Unlock()\n\t}\n\n\tlog.Info(\"obtaining new certificate\", zap.String(\"server_name\", name))\n\n\t// set a timeout so we don't inadvertently hold a client handshake open too long\n\t// (timeout duration is based on https://caddy.community/t/zerossl-dns-challenge-failing-often-route53-plugin/13822/24?u=matt)\n\tvar cancel context.CancelFunc\n\tctx, cancel = context.WithTimeout(ctx, 180*time.Second)\n\tdefer cancel()\n\n\t// obtain the certificate (this puts it in storage) and if successful,\n\t// load it from storage so we and any other waiting goroutine can use it\n\tvar cert Certificate\n\terr := cfg.ObtainCertAsync(ctx, name)\n\tif err == nil {\n\t\t// load from storage while others wait to make the op as atomic as possible\n\t\tcert, err = cfg.loadCertFromStorage(ctx, log, hello)\n\t\tif err != nil {\n\t\t\tlog.Error(\"loading newly-obtained certificate from storage\", zap.String(\"server_name\", name), zap.Error(err))\n\t\t}\n\t}\n\n\t// immediately unblock anyone waiting for it\n\tunblockWaiters()\n\n\treturn cert, err\n}\n\n// handshakeMaintenance performs a check on cert for expiration and OCSP validity.\n// If necessary, it will renew the certificate and/or refresh the OCSP staple.\n// OCSP stapling errors are not returned, only logged.\n//\n// This function is safe for use by multiple concurrent goroutines.\nfunc (cfg *Config) handshakeMaintenance(ctx context.Context, hello *tls.ClientHelloInfo, cert Certificate) (Certificate, error) {\n\tlogger := cfg.Logger.Named(\"on_demand\").With(\n\t\tzap.Strings(\"identifiers\", cert.Names),\n\t\tzap.String(\"server_name\", hello.ServerName))\n\n\trenewIfNecessary := func(ctx context.Context, hello *tls.ClientHelloInfo, cert Certificate) (Certificate, error) {\n\t\tif cfg.certNeedsRenewal(cert.Leaf, cert.ari, true) {\n\t\t\t// Check if the certificate still exists on disk. If not, we need to obtain a new one.\n\t\t\t// This can happen if the certificate was cleaned up by the storage cleaner, but still\n\t\t\t// remains in the in-memory cache.\n\t\t\tif !cfg.storageHasCertResourcesAnyIssuer(ctx, cert.Names[0]) {\n\t\t\t\tlogger.Debug(\"certificate not found on disk; obtaining new certificate\")\n\t\t\t\treturn cfg.obtainOnDemandCertificate(ctx, hello)\n\t\t\t}\n\t\t\t// Otherwise, renew the certificate.\n\t\t\treturn cfg.renewDynamicCertificate(ctx, hello, cert)\n\t\t}\n\t\treturn cert, nil\n\t}\n\n\t// Check OCSP staple validity\n\tif cert.ocsp != nil && !freshOCSP(cert.ocsp) {\n\t\tlogger.Debug(\"OCSP response needs refreshing\",\n\t\t\tzap.Int(\"ocsp_status\", cert.ocsp.Status),\n\t\t\tzap.Time(\"this_update\", cert.ocsp.ThisUpdate),\n\t\t\tzap.Time(\"next_update\", cert.ocsp.NextUpdate))\n\n\t\terr := stapleOCSP(ctx, cfg.OCSP, cfg.Storage, &cert, nil)\n\t\tif err != nil {\n\t\t\t// An error with OCSP stapling is not the end of the world, and in fact, is\n\t\t\t// quite common considering not all certs have issuer URLs that support it.\n\t\t\tlogger.Warn(\"stapling OCSP\", zap.Error(err))\n\t\t} else {\n\t\t\tlogger.Debug(\"successfully stapled new OCSP response\",\n\t\t\t\tzap.Int(\"ocsp_status\", cert.ocsp.Status),\n\t\t\t\tzap.Time(\"this_update\", cert.ocsp.ThisUpdate),\n\t\t\t\tzap.Time(\"next_update\", cert.ocsp.NextUpdate))\n\t\t}\n\n\t\t// our copy of cert has the new OCSP staple, so replace it in the cache\n\t\tcfg.certCache.mu.Lock()\n\t\tcfg.certCache.cache[cert.hash] = cert\n\t\tcfg.certCache.mu.Unlock()\n\t}\n\n\t// Check ARI status, but it's only relevant if the certificate is not expired (otherwise, we already know it needs renewal!)\n\tif !cfg.DisableARI && cert.ari.NeedsRefresh() && time.Now().Before(cert.Leaf.NotAfter) {\n\t\t// update ARI in a goroutine to avoid blocking an active handshake, since the results of\n\t\t// this do not strictly affect the handshake; even though the cert may be updated with\n\t\t// the new ARI, it is also updated in the cache and in storage, so future handshakes\n\t\t// will utilize it\n\t\tgo func(hello *tls.ClientHelloInfo, cert Certificate, logger *zap.Logger) {\n\t\t\t// TODO: a different context that isn't tied to the handshake is probably better\n\t\t\t// than a generic background context; maybe a longer-lived server config context,\n\t\t\t// or something that the importing package sets on the Config struct; for example,\n\t\t\t// a Caddy config context could be good, so that ARI updates will continue after\n\t\t\t// the handshake goes away, but will be stopped if the underlying server is stopped\n\t\t\t// (for now, use an unusual timeout to help recognize it in log patterns, if needed)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), 8*time.Minute)\n\t\t\tdefer cancel()\n\n\t\t\tvar err error\n\t\t\t// we ignore the second return value here because we check renewal status below regardless\n\t\t\tcert, _, err = cfg.updateARI(ctx, cert, logger)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"updating ARI\", zap.Error(err))\n\t\t\t}\n\t\t\t_, err = renewIfNecessary(ctx, hello, cert)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"renewing certificate based on updated ARI\", zap.Error(err))\n\t\t\t}\n\t\t}(hello, cert, logger)\n\t}\n\n\t// We attempt to replace any certificates that were revoked.\n\t// Crucially, this happens OUTSIDE a lock on the certCache.\n\tif certShouldBeForceRenewed(cert) {\n\t\tlogger.Warn(\"on-demand certificate's OCSP status is REVOKED; will try to forcefully renew\",\n\t\t\tzap.Int(\"ocsp_status\", cert.ocsp.Status),\n\t\t\tzap.Time(\"revoked_at\", cert.ocsp.RevokedAt),\n\t\t\tzap.Time(\"this_update\", cert.ocsp.ThisUpdate),\n\t\t\tzap.Time(\"next_update\", cert.ocsp.NextUpdate))\n\t\treturn cfg.renewDynamicCertificate(ctx, hello, cert)\n\t}\n\n\t// Since renewal conditions may have changed, do a renewal if necessary\n\treturn renewIfNecessary(ctx, hello, cert)\n}\n\n// renewDynamicCertificate renews the certificate for name using cfg. It returns the\n// certificate to use and an error, if any. name should already be lower-cased before\n// calling this function. name is the name obtained directly from the handshake's\n// ClientHello. If the certificate hasn't yet expired, currentCert will be returned\n// and the renewal will happen in the background; otherwise this blocks until the\n// certificate has been renewed, and returns the renewed certificate.\n//\n// If the certificate's OCSP status (currentCert.ocsp) is Revoked, it will be forcefully\n// renewed even if it is not expiring.\n//\n// This function is safe for use by multiple concurrent goroutines.\nfunc (cfg *Config) renewDynamicCertificate(ctx context.Context, hello *tls.ClientHelloInfo, currentCert Certificate) (Certificate, error) {\n\tlogger := logWithRemote(cfg.Logger.Named(\"on_demand\"), hello)\n\n\tname := cfg.getNameFromClientHello(hello)\n\ttimeLeft := time.Until(expiresAt(currentCert.Leaf))\n\trevoked := currentCert.ocsp != nil && currentCert.ocsp.Status == ocsp.Revoked\n\n\t// see if another goroutine is already working on this certificate\n\tobtainCertWaitChansMu.Lock()\n\twait, ok := obtainCertWaitChans[name]\n\tif ok {\n\t\t// lucky us -- another goroutine is already renewing the certificate\n\t\tobtainCertWaitChansMu.Unlock()\n\n\t\t// the current certificate hasn't expired, and another goroutine is already\n\t\t// renewing it, so we might as well serve what we have without blocking, UNLESS\n\t\t// we're forcing renewal, in which case the current certificate is not usable\n\t\tif timeLeft > 0 && !revoked {\n\t\t\tlogger.Debug(\"certificate expires soon but is already being renewed; serving current certificate\",\n\t\t\t\tzap.Strings(\"subjects\", currentCert.Names),\n\t\t\t\tzap.Duration(\"remaining\", timeLeft))\n\t\t\treturn currentCert, nil\n\t\t}\n\n\t\t// otherwise, we'll have to wait for the renewal to finish so we don't serve\n\t\t// a revoked or expired certificate\n\n\t\tlogger.Debug(\"certificate has expired, but is already being renewed; waiting for renewal to complete\",\n\t\t\tzap.Strings(\"subjects\", currentCert.Names),\n\t\t\tzap.Time(\"expired\", expiresAt(currentCert.Leaf)),\n\t\t\tzap.Bool(\"revoked\", revoked))\n\n\t\t// TODO: see if we can get a proper context in here, for true cancellation\n\t\ttimeout := time.NewTimer(2 * time.Minute)\n\t\tselect {\n\t\tcase <-timeout.C:\n\t\t\treturn Certificate{}, fmt.Errorf(\"timed out waiting for certificate renewal of %s\", name)\n\t\tcase <-wait:\n\t\t\ttimeout.Stop()\n\t\t}\n\n\t\t// it should now be loaded in the cache, ready to go; if not,\n\t\t// the goroutine in charge of that probably had an error\n\t\treturn cfg.getCertDuringHandshake(ctx, hello, false)\n\t}\n\n\t// looks like it's up to us to do all the work and renew the cert\n\twait = make(chan struct{})\n\tobtainCertWaitChans[name] = wait\n\tobtainCertWaitChansMu.Unlock()\n\n\tunblockWaiters := func() {\n\t\tobtainCertWaitChansMu.Lock()\n\t\tclose(wait)\n\t\tdelete(obtainCertWaitChans, name)\n\t\tobtainCertWaitChansMu.Unlock()\n\t}\n\n\tlogger = logger.With(\n\t\tzap.String(\"server_name\", name),\n\t\tzap.Strings(\"subjects\", currentCert.Names),\n\t\tzap.Time(\"expiration\", expiresAt(currentCert.Leaf)),\n\t\tzap.Duration(\"remaining\", timeLeft),\n\t\tzap.Bool(\"revoked\", revoked),\n\t)\n\n\t// Renew and reload the certificate\n\trenewAndReload := func(ctx context.Context, cancel context.CancelFunc) (Certificate, error) {\n\t\tdefer cancel()\n\n\t\t// Make sure a certificate for this name should be renewed on-demand\n\t\terr := cfg.checkIfCertShouldBeObtained(ctx, name, true)\n\t\tif err != nil {\n\t\t\t// if not, remove from cache (it will be deleted from storage later)\n\t\t\tcfg.certCache.mu.Lock()\n\t\t\tcfg.certCache.removeCertificate(currentCert)\n\t\t\tcfg.certCache.mu.Unlock()\n\t\t\tunblockWaiters()\n\n\t\t\tif logger != nil {\n\t\t\t\tlogger.Error(\"certificate should not be obtained\", zap.Error(err))\n\t\t\t}\n\n\t\t\treturn Certificate{}, err\n\t\t}\n\n\t\tlogger.Info(\"attempting certificate renewal\")\n\n\t\t// otherwise, renew with issuer, etc.\n\t\tvar newCert Certificate\n\t\tif revoked {\n\t\t\tnewCert, err = cfg.forceRenew(ctx, logger, currentCert)\n\t\t} else {\n\t\t\terr = cfg.RenewCertAsync(ctx, name, false)\n\t\t\tif err == nil {\n\t\t\t\t// load from storage while in lock to make the replacement as atomic as possible\n\t\t\t\tnewCert, err = cfg.reloadManagedCertificate(ctx, currentCert)\n\t\t\t}\n\t\t}\n\n\t\t// immediately unblock anyone waiting for it; doing this in\n\t\t// a defer would risk deadlock because of the recursive call\n\t\t// to getCertDuringHandshake below when we return!\n\t\tunblockWaiters()\n\n\t\tif err != nil {\n\t\t\tlogger.Error(\"renewing and reloading certificate\", zap.String(\"server_name\", name), zap.Error(err))\n\t\t}\n\n\t\treturn newCert, err\n\t}\n\n\t// if the certificate hasn't expired, we can serve what we have and renew in the background\n\tif timeLeft > 0 {\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)\n\t\tgo renewAndReload(ctx, cancel)\n\t\treturn currentCert, nil\n\t}\n\n\t// otherwise, we have to block while we renew an expired certificate\n\tctx, cancel := context.WithTimeout(ctx, 90*time.Second)\n\treturn renewAndReload(ctx, cancel)\n}\n\n// getCertFromAnyCertManager gets a certificate from cfg's Managers. If there are no Managers defined, this is\n// a no-op that returns empty values. Otherwise, it gets a certificate for hello from the first Manager that\n// returns a certificate and no error.\nfunc (cfg *Config) getCertFromAnyCertManager(ctx context.Context, hello *tls.ClientHelloInfo, logger *zap.Logger) (Certificate, error) {\n\t// fast path if nothing to do\n\tif cfg.OnDemand == nil || len(cfg.OnDemand.Managers) == 0 {\n\t\treturn Certificate{}, nil\n\t}\n\n\t// try all the GetCertificate methods on external managers; use first one that returns a certificate\n\tvar upstreamCert *tls.Certificate\n\tvar err error\n\tfor i, certManager := range cfg.OnDemand.Managers {\n\t\tupstreamCert, err = certManager.GetCertificate(ctx, hello)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"external certificate manager\",\n\t\t\t\tzap.String(\"sni\", hello.ServerName),\n\t\t\t\tzap.String(\"cert_manager\", fmt.Sprintf(\"%T\", certManager)),\n\t\t\t\tzap.Int(\"cert_manager_idx\", i),\n\t\t\t\tzap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tif upstreamCert != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn Certificate{}, fmt.Errorf(\"external certificate manager indicated that it is unable to yield certificate: %v\", err)\n\t}\n\tif upstreamCert == nil {\n\t\tlogger.Debug(\"all external certificate managers yielded no certificates and no errors\", zap.String(\"sni\", hello.ServerName))\n\t\treturn Certificate{}, nil\n\t}\n\n\tvar cert Certificate\n\tif err = fillCertFromLeaf(&cert, *upstreamCert); err != nil {\n\t\treturn Certificate{}, fmt.Errorf(\"external certificate manager: %s: filling cert from leaf: %v\", hello.ServerName, err)\n\t}\n\n\tlogger.Debug(\"using externally-managed certificate\",\n\t\tzap.String(\"sni\", hello.ServerName),\n\t\tzap.Strings(\"names\", cert.Names),\n\t\tzap.Time(\"expiration\", expiresAt(cert.Leaf)))\n\n\treturn cert, nil\n}\n\n// getTLSALPNChallengeCert is to be called when the clientHello pertains to\n// a TLS-ALPN challenge and a certificate is required to solve it. This method gets\n// the relevant challenge info and then returns the associated certificate (if any)\n// or generates it anew if it's not available (as is the case when distributed\n// solving). True is returned if the challenge is being solved distributed (there\n// is no semantic difference with distributed solving; it is mainly for logging).\nfunc (cfg *Config) getTLSALPNChallengeCert(clientHello *tls.ClientHelloInfo) (*tls.Certificate, bool, error) {\n\tchalData, distributed, err := cfg.getChallengeInfo(clientHello.Context(), clientHello.ServerName)\n\tif err != nil {\n\t\treturn nil, distributed, err\n\t}\n\n\t// fast path: we already created the certificate (this avoids having to re-create\n\t// it at every handshake that tries to verify, e.g. multi-perspective validation)\n\tif chalData.data != nil {\n\t\treturn chalData.data.(*tls.Certificate), distributed, nil\n\t}\n\n\t// otherwise, we can re-create the solution certificate, but it takes a few cycles\n\tcert, err := acmez.TLSALPN01ChallengeCert(chalData.Challenge)\n\tif err != nil {\n\t\treturn nil, distributed, fmt.Errorf(\"making TLS-ALPN challenge certificate: %v\", err)\n\t}\n\tif cert == nil {\n\t\treturn nil, distributed, fmt.Errorf(\"got nil TLS-ALPN challenge certificate but no error\")\n\t}\n\n\treturn cert, distributed, nil\n}\n\n// getNameFromClientHello returns a normalized form of hello.ServerName.\n// If hello.ServerName is empty (i.e. client did not use SNI), then the\n// associated connection's local address is used to extract an IP address.\nfunc (cfg *Config) getNameFromClientHello(hello *tls.ClientHelloInfo) string {\n\tif name := normalizedName(hello.ServerName); name != \"\" {\n\t\treturn name\n\t}\n\tif cfg.DefaultServerName != \"\" {\n\t\treturn normalizedName(cfg.DefaultServerName)\n\t}\n\treturn localIPFromConn(hello.Conn)\n}\n\n// logWithRemote adds the remote host and port to the logger.\nfunc logWithRemote(l *zap.Logger, hello *tls.ClientHelloInfo) *zap.Logger {\n\tif hello.Conn == nil || l == nil {\n\t\treturn l\n\t}\n\taddr := hello.Conn.RemoteAddr().String()\n\tip, port, err := net.SplitHostPort(addr)\n\tif err != nil {\n\t\tip = addr\n\t\tport = \"\"\n\t}\n\treturn l.With(zap.String(\"remote_ip\", ip), zap.String(\"remote_port\", port))\n}\n\n// localIPFromConn returns the host portion of c's local address\n// and strips the scope ID if one exists (see RFC 4007).\nfunc localIPFromConn(c net.Conn) string {\n\tif c == nil {\n\t\treturn \"\"\n\t}\n\tlocalAddr := c.LocalAddr().String()\n\tip, _, err := net.SplitHostPort(localAddr)\n\tif err != nil {\n\t\t// OK; assume there was no port\n\t\tip = localAddr\n\t}\n\t// IPv6 addresses can have scope IDs, e.g. \"fe80::4c3:3cff:fe4f:7e0b%eth0\",\n\t// but for our purposes, these are useless (unless a valid use case proves\n\t// otherwise; see issue #3911)\n\tif scopeIDStart := strings.Index(ip, \"%\"); scopeIDStart > -1 {\n\t\tip = ip[:scopeIDStart]\n\t}\n\treturn ip\n}\n\n// normalizedName returns a cleaned form of serverName that is\n// used for consistency when referring to a SNI value.\nfunc normalizedName(serverName string) string {\n\treturn strings.ToLower(strings.TrimSpace(serverName))\n}\n\n// obtainCertWaitChans is used to coordinate obtaining certs for each hostname.\nvar (\n\tobtainCertWaitChans   = make(map[string]chan struct{})\n\tobtainCertWaitChansMu sync.Mutex\n)\n\n// TODO: this lockset should probably be per-cache\nvar (\n\tcertLoadWaitChans   = make(map[string]chan struct{})\n\tcertLoadWaitChansMu sync.Mutex\n)\n\ntype serializableClientHello struct {\n\tCipherSuites      []uint16\n\tServerName        string\n\tSupportedCurves   []tls.CurveID\n\tSupportedPoints   []uint8\n\tSignatureSchemes  []tls.SignatureScheme\n\tSupportedProtos   []string\n\tSupportedVersions []uint16\n\n\tRemoteAddr, LocalAddr net.Addr // values copied from the Conn as they are still useful/needed\n\tconn                  net.Conn // unexported so it's not serialized\n}\n\n// clientHelloWithoutConn returns the data from the ClientHelloInfo without the\n// pesky exported Conn field, which often causes an error when serializing because\n// the underlying type may be unserializable.\nfunc clientHelloWithoutConn(hello *tls.ClientHelloInfo) serializableClientHello {\n\tif hello == nil {\n\t\treturn serializableClientHello{}\n\t}\n\tvar remote, local net.Addr\n\tif hello.Conn != nil {\n\t\tremote = hello.Conn.RemoteAddr()\n\t\tlocal = hello.Conn.LocalAddr()\n\t}\n\treturn serializableClientHello{\n\t\tCipherSuites:      hello.CipherSuites,\n\t\tServerName:        hello.ServerName,\n\t\tSupportedCurves:   hello.SupportedCurves,\n\t\tSupportedPoints:   hello.SupportedPoints,\n\t\tSignatureSchemes:  hello.SignatureSchemes,\n\t\tSupportedProtos:   hello.SupportedProtos,\n\t\tSupportedVersions: hello.SupportedVersions,\n\t\tRemoteAddr:        remote,\n\t\tLocalAddr:         local,\n\t\tconn:              hello.Conn,\n\t}\n}\n\ntype helloInfoCtxKey string\n\n// ClientHelloInfoCtxKey is the key by which the ClientHelloInfo can be extracted from\n// a context.Context within a DecisionFunc. However, be advised that it is best practice\n// that the decision whether to obtain a certificate is be based solely on the name,\n// not other properties of the specific connection/client requesting the connection.\n// For example, it is not advisable to use a client's IP address to decide whether to\n// allow a certificate. Instead, the ClientHello can be useful for logging, etc.\nconst ClientHelloInfoCtxKey helloInfoCtxKey = \"certmagic:ClientHelloInfo\"\n"
        },
        {
          "name": "handshake_test.go",
          "type": "blob",
          "size": 4.255859375,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//\thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npackage certmagic\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"net\"\n\t\"testing\"\n)\n\nfunc TestGetCertificate(t *testing.T) {\n\tc := &Cache{\n\t\tcache:      make(map[string]Certificate),\n\t\tcacheIndex: make(map[string][]string),\n\t\tlogger:     defaultTestLogger,\n\t}\n\tcfg := &Config{Logger: defaultTestLogger, certCache: c}\n\n\t// create a test connection for conn.LocalAddr()\n\tl, _ := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tdefer l.Close()\n\tconn, _ := net.Dial(\"tcp\", l.Addr().String())\n\tif conn == nil {\n\t\tt.Errorf(\"failed to create a test connection\")\n\t}\n\tdefer conn.Close()\n\n\thello := &tls.ClientHelloInfo{ServerName: \"example.com\", Conn: conn}\n\thelloSub := &tls.ClientHelloInfo{ServerName: \"sub.example.com\", Conn: conn}\n\thelloNoSNI := &tls.ClientHelloInfo{Conn: conn}\n\thelloNoMatch := &tls.ClientHelloInfo{ServerName: \"nomatch\", Conn: conn}\n\n\t// When cache is empty\n\tif cert, err := cfg.GetCertificate(hello); err == nil {\n\t\tt.Errorf(\"GetCertificate should return error when cache is empty, got: %v\", cert)\n\t}\n\tif cert, err := cfg.GetCertificate(helloNoSNI); err == nil {\n\t\tt.Errorf(\"GetCertificate should return error when cache is empty even if server name is blank, got: %v\", cert)\n\t}\n\n\t// When cache has one certificate in it\n\tfirstCert := Certificate{Names: []string{\"example.com\"}, Certificate: tls.Certificate{Leaf: &x509.Certificate{DNSNames: []string{\"example.com\"}}}}\n\tc.cacheCertificate(firstCert)\n\tif cert, err := cfg.GetCertificate(hello); err != nil {\n\t\tt.Errorf(\"Got an error but shouldn't have, when cert exists in cache: %v\", err)\n\t} else if cert.Leaf.DNSNames[0] != \"example.com\" {\n\t\tt.Errorf(\"Got wrong certificate with exact match; expected 'example.com', got: %v\", cert)\n\t}\n\tif _, err := cfg.GetCertificate(helloNoSNI); err == nil {\n\t\tt.Errorf(\"Did not get an error with no SNI and no DefaultServerName, but should have: %v\", err)\n\t}\n\n\t// When retrieving wildcard certificate\n\twildcardCert := Certificate{\n\t\tNames:       []string{\"*.example.com\"},\n\t\tCertificate: tls.Certificate{Leaf: &x509.Certificate{DNSNames: []string{\"*.example.com\"}}},\n\t\thash:        \"(don't overwrite the first one)\",\n\t}\n\tc.cacheCertificate(wildcardCert)\n\tif cert, err := cfg.GetCertificate(helloSub); err != nil {\n\t\tt.Errorf(\"Didn't get wildcard cert, got: cert=%v, err=%v \", cert, err)\n\t} else if cert.Leaf.DNSNames[0] != \"*.example.com\" {\n\t\tt.Errorf(\"Got wrong certificate, expected wildcard: %v\", cert)\n\t}\n\n\t// When cache is NOT empty but there's no SNI\n\tif _, err := cfg.GetCertificate(helloNoSNI); err == nil {\n\t\tt.Errorf(\"Expected TLS allert when no SNI and no DefaultServerName, but got: %v\", err)\n\t}\n\n\t// When no certificate matches, raise an alert\n\tif _, err := cfg.GetCertificate(helloNoMatch); err == nil {\n\t\tt.Errorf(\"Expected an error when no certificate matched the SNI, got: %v\", err)\n\t}\n\n\t// When default SNI is set and SNI is missing, retrieve default cert\n\tcfg.DefaultServerName = \"example.com\"\n\tif cert, err := cfg.GetCertificate(helloNoSNI); err != nil {\n\t\tt.Errorf(\"Got an error with no SNI with DefaultServerName, but shouldn't have: %v\", err)\n\t} else if cert == nil || cert.Leaf.DNSNames[0] != \"example.com\" {\n\t\tt.Errorf(\"Expected default cert, got: %v\", cert)\n\t}\n\n\t// When default SNI is set and SNI is missing but IP address matches, retrieve IP cert\n\tipCert := Certificate{\n\t\tNames:       []string{\"127.0.0.1\"},\n\t\tCertificate: tls.Certificate{Leaf: &x509.Certificate{IPAddresses: []net.IP{net.ParseIP(\"127.0.0.1\")}}},\n\t\thash:        \"(don't overwrite the first or second one)\",\n\t}\n\tc.cacheCertificate(ipCert)\n\tif cert, err := cfg.GetCertificate(helloNoSNI); err != nil {\n\t\tt.Errorf(\"Got an error with no SNI but matching IP, but shouldn't have: %v\", err)\n\t} else if cert == nil || len(cert.Leaf.IPAddresses) == 0 {\n\t\tt.Errorf(\"Expected IP cert, got: %v\", cert)\n\t}\n}\n"
        },
        {
          "name": "httphandlers.go",
          "type": "blob",
          "size": 7.4599609375,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/mholt/acmez/v3/acme\"\n\t\"go.uber.org/zap\"\n)\n\n// HTTPChallengeHandler wraps h in a handler that can solve the ACME\n// HTTP challenge. cfg is required, and it must have a certificate\n// cache backed by a functional storage facility, since that is where\n// the challenge state is stored between initiation and solution.\n//\n// If a request is not an ACME HTTP challenge, h will be invoked.\nfunc (am *ACMEIssuer) HTTPChallengeHandler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif am.HandleHTTPChallenge(w, r) {\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t})\n}\n\n// HandleHTTPChallenge uses am to solve challenge requests from an ACME\n// server that were initiated by this instance or any other instance in\n// this cluster (being, any instances using the same storage am does).\n//\n// If the HTTP challenge is disabled, this function is a no-op.\n//\n// If am is nil or if am does not have a certificate cache backed by\n// usable storage, solving the HTTP challenge will fail.\n//\n// It returns true if it handled the request; if so, the response has\n// already been written. If false is returned, this call was a no-op and\n// the request has not been handled.\nfunc (am *ACMEIssuer) HandleHTTPChallenge(w http.ResponseWriter, r *http.Request) bool {\n\tif am == nil {\n\t\treturn false\n\t}\n\tif am.DisableHTTPChallenge {\n\t\treturn false\n\t}\n\tif !LooksLikeHTTPChallenge(r) {\n\t\treturn false\n\t}\n\treturn am.distributedHTTPChallengeSolver(w, r)\n}\n\n// distributedHTTPChallengeSolver checks to see if this challenge\n// request was initiated by this or another instance which uses the\n// same storage as am does, and attempts to complete the challenge for\n// it. It returns true if the request was handled; false otherwise.\nfunc (am *ACMEIssuer) distributedHTTPChallengeSolver(w http.ResponseWriter, r *http.Request) bool {\n\tif am == nil {\n\t\treturn false\n\t}\n\thost := hostOnly(r.Host)\n\tchalInfo, distributed, err := am.config.getChallengeInfo(r.Context(), host)\n\tif err != nil {\n\t\tam.Logger.Warn(\"looking up info for HTTP challenge\",\n\t\t\tzap.String(\"host\", host),\n\t\t\tzap.String(\"remote_addr\", r.RemoteAddr),\n\t\t\tzap.String(\"user_agent\", r.Header.Get(\"User-Agent\")),\n\t\t\tzap.Error(err))\n\t\treturn false\n\t}\n\treturn solveHTTPChallenge(am.Logger, w, r, chalInfo.Challenge, distributed)\n}\n\n// solveHTTPChallenge solves the HTTP challenge using the given challenge information.\n// If the challenge is being solved in a distributed fahsion, set distributed to true for logging purposes.\n// It returns true the properties of the request check out in relation to the HTTP challenge.\n// Most of this code borrowed from xenolf's built-in HTTP-01 challenge solver in March 2018.\nfunc solveHTTPChallenge(logger *zap.Logger, w http.ResponseWriter, r *http.Request, challenge acme.Challenge, distributed bool) bool {\n\tchallengeReqPath := challenge.HTTP01ResourcePath()\n\tif r.URL.Path == challengeReqPath &&\n\t\tstrings.EqualFold(hostOnly(r.Host), challenge.Identifier.Value) && // mitigate DNS rebinding attacks\n\t\tr.Method == http.MethodGet {\n\t\tw.Header().Add(\"Content-Type\", \"text/plain\")\n\t\tw.Write([]byte(challenge.KeyAuthorization))\n\t\tr.Close = true\n\t\tlogger.Info(\"served key authentication\",\n\t\t\tzap.String(\"identifier\", challenge.Identifier.Value),\n\t\t\tzap.String(\"challenge\", \"http-01\"),\n\t\t\tzap.String(\"remote\", r.RemoteAddr),\n\t\t\tzap.Bool(\"distributed\", distributed))\n\t\treturn true\n\t}\n\treturn false\n}\n\n// SolveHTTPChallenge solves the HTTP challenge. It should be used only on HTTP requests that are\n// from ACME servers trying to validate an identifier (i.e. LooksLikeHTTPChallenge() == true). It\n// returns true if the request criteria check out and it answered with key authentication, in which\n// case no further handling of the request is necessary.\nfunc SolveHTTPChallenge(logger *zap.Logger, w http.ResponseWriter, r *http.Request, challenge acme.Challenge) bool {\n\treturn solveHTTPChallenge(logger, w, r, challenge, false)\n}\n\n// LooksLikeHTTPChallenge returns true if r looks like an ACME\n// HTTP challenge request from an ACME server.\nfunc LooksLikeHTTPChallenge(r *http.Request) bool {\n\treturn r.Method == http.MethodGet &&\n\t\tstrings.HasPrefix(r.URL.Path, acmeHTTPChallengeBasePath)\n}\n\n// LooksLikeZeroSSLHTTPValidation returns true if the request appears to be\n// domain validation from a ZeroSSL/Sectigo CA. NOTE: This API is\n// non-standard and is subject to change.\nfunc LooksLikeZeroSSLHTTPValidation(r *http.Request) bool {\n\treturn r.Method == http.MethodGet &&\n\t\tstrings.HasPrefix(r.URL.Path, zerosslHTTPValidationBasePath)\n}\n\n// HTTPValidationHandler wraps the ZeroSSL HTTP validation handler such that\n// it can pass verification checks from ZeroSSL's API.\n//\n// If a request is not a ZeroSSL HTTP validation request, h will be invoked.\nfunc (iss *ZeroSSLIssuer) HTTPValidationHandler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif iss.HandleZeroSSLHTTPValidation(w, r) {\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t})\n}\n\n// HandleZeroSSLHTTPValidation is to ZeroSSL API HTTP validation requests like HandleHTTPChallenge\n// is to ACME HTTP challenge requests.\nfunc (iss *ZeroSSLIssuer) HandleZeroSSLHTTPValidation(w http.ResponseWriter, r *http.Request) bool {\n\tif iss == nil {\n\t\treturn false\n\t}\n\tif !LooksLikeZeroSSLHTTPValidation(r) {\n\t\treturn false\n\t}\n\treturn iss.distributedHTTPValidationAnswer(w, r)\n}\n\nfunc (iss *ZeroSSLIssuer) distributedHTTPValidationAnswer(w http.ResponseWriter, r *http.Request) bool {\n\tif iss == nil {\n\t\treturn false\n\t}\n\tlogger := iss.Logger\n\tif logger == nil {\n\t\tlogger = zap.NewNop()\n\t}\n\thost := hostOnly(r.Host)\n\tvalInfo, distributed, err := iss.getDistributedValidationInfo(r.Context(), host)\n\tif err != nil {\n\t\tlogger.Warn(\"looking up info for HTTP validation\",\n\t\t\tzap.String(\"host\", host),\n\t\t\tzap.String(\"remote_addr\", r.RemoteAddr),\n\t\t\tzap.String(\"user_agent\", r.Header.Get(\"User-Agent\")),\n\t\t\tzap.Error(err))\n\t\treturn false\n\t}\n\treturn answerHTTPValidation(logger, w, r, valInfo, distributed)\n}\n\nfunc answerHTTPValidation(logger *zap.Logger, rw http.ResponseWriter, req *http.Request, valInfo acme.Challenge, distributed bool) bool {\n\t// ensure URL matches\n\tvalidationURL, err := url.Parse(valInfo.URL)\n\tif err != nil {\n\t\tlogger.Error(\"got invalid URL from CA\",\n\t\t\tzap.String(\"file_validation_url\", valInfo.URL),\n\t\t\tzap.Error(err))\n\t\trw.WriteHeader(http.StatusInternalServerError)\n\t\treturn true\n\t}\n\tif req.URL.Path != validationURL.Path {\n\t\trw.WriteHeader(http.StatusNotFound)\n\t\treturn true\n\t}\n\n\trw.Header().Add(\"Content-Type\", \"text/plain\")\n\treq.Close = true\n\n\trw.Write([]byte(valInfo.Token))\n\n\tlogger.Info(\"served HTTP validation credential\",\n\t\tzap.String(\"validation_path\", valInfo.URL),\n\t\tzap.String(\"challenge\", \"http-01\"),\n\t\tzap.String(\"remote\", req.RemoteAddr),\n\t\tzap.Bool(\"distributed\", distributed))\n\n\treturn true\n}\n\nconst (\n\tacmeHTTPChallengeBasePath     = \"/.well-known/acme-challenge\"\n\tzerosslHTTPValidationBasePath = \"/.well-known/pki-validation/\"\n)\n"
        },
        {
          "name": "httphandlers_test.go",
          "type": "blob",
          "size": 1.7841796875,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestHTTPChallengeHandlerNoOp(t *testing.T) {\n\tam := &ACMEIssuer{CA: \"https://example.com/acme/directory\", Logger: defaultTestLogger}\n\ttestConfig := &Config{\n\t\tIssuers:   []Issuer{am},\n\t\tStorage:   &FileStorage{Path: \"./_testdata_tmp\"},\n\t\tLogger:    defaultTestLogger,\n\t\tcertCache: new(Cache),\n\t}\n\tam.config = testConfig\n\n\ttestStorageDir := testConfig.Storage.(*FileStorage).Path\n\tdefer func() {\n\t\terr := os.RemoveAll(testStorageDir)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not remove temporary storage directory (%s): %v\", testStorageDir, err)\n\t\t}\n\t}()\n\n\t// try base paths and host names that aren't\n\t// handled by this handler\n\tfor _, url := range []string{\n\t\t\"http://localhost/\",\n\t\t\"http://localhost/foo.html\",\n\t\t\"http://localhost/.git\",\n\t\t\"http://localhost/.well-known/\",\n\t\t\"http://localhost/.well-known/acme-challenging\",\n\t\t\"http://other/.well-known/acme-challenge/foo\",\n\t} {\n\t\treq, err := http.NewRequest(\"GET\", url, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not craft request, got error: %v\", err)\n\t\t}\n\t\trw := httptest.NewRecorder()\n\t\tif am.HandleHTTPChallenge(rw, req) {\n\t\t\tt.Errorf(\"Got true with this URL, but shouldn't have: %s\", url)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "maintain.go",
          "type": "blob",
          "size": 33.29296875,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"context\"\n\t\"crypto/x509\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/fs\"\n\t\"path\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/mholt/acmez/v3/acme\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/crypto/ocsp\"\n)\n\n// maintainAssets is a permanently-blocking function\n// that loops indefinitely and, on a regular schedule, checks\n// certificates for expiration and initiates a renewal of certs\n// that are expiring soon. It also updates OCSP stapling. It\n// should only be called once per cache. Panics are recovered,\n// and if panicCount < 10, the function is called recursively,\n// incrementing panicCount each time. Initial invocation should\n// start panicCount at 0.\nfunc (certCache *Cache) maintainAssets(panicCount int) {\n\tlog := certCache.logger.Named(\"maintenance\")\n\tlog = log.With(zap.String(\"cache\", fmt.Sprintf(\"%p\", certCache)))\n\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tbuf := make([]byte, stackTraceBufferSize)\n\t\t\tbuf = buf[:runtime.Stack(buf, false)]\n\t\t\tlog.Error(\"panic\", zap.Any(\"error\", err), zap.ByteString(\"stack\", buf))\n\t\t\tif panicCount < 10 {\n\t\t\t\tcertCache.maintainAssets(panicCount + 1)\n\t\t\t}\n\t\t}\n\t}()\n\n\tcertCache.optionsMu.RLock()\n\trenewalTicker := time.NewTicker(certCache.options.RenewCheckInterval)\n\tocspTicker := time.NewTicker(certCache.options.OCSPCheckInterval)\n\tcertCache.optionsMu.RUnlock()\n\n\tlog.Info(\"started background certificate maintenance\")\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tfor {\n\t\tselect {\n\t\tcase <-renewalTicker.C:\n\t\t\terr := certCache.RenewManagedCertificates(ctx)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"renewing managed certificates\", zap.Error(err))\n\t\t\t}\n\t\tcase <-ocspTicker.C:\n\t\t\tcertCache.updateOCSPStaples(ctx)\n\t\tcase <-certCache.stopChan:\n\t\t\trenewalTicker.Stop()\n\t\t\tocspTicker.Stop()\n\t\t\tlog.Info(\"stopped background certificate maintenance\")\n\t\t\tclose(certCache.doneChan)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// RenewManagedCertificates renews managed certificates,\n// including ones loaded on-demand. Note that this is done\n// automatically on a regular basis; normally you will not\n// need to call this. This method assumes non-interactive\n// mode (i.e. operating in the background).\nfunc (certCache *Cache) RenewManagedCertificates(ctx context.Context) error {\n\tlog := certCache.logger.Named(\"maintenance\")\n\n\t// configs will hold a map of certificate hash to the config\n\t// to use when managing that certificate\n\tconfigs := make(map[string]*Config)\n\n\t// we use the queues for a very important reason: to do any and all\n\t// operations that could require an exclusive write lock outside\n\t// of the read lock! otherwise we get a deadlock, yikes. in other\n\t// words, our first iteration through the certificate cache does NOT\n\t// perform any operations--only queues them--so that more fine-grained\n\t// write locks may be obtained during the actual operations.\n\tvar renewQueue, reloadQueue, deleteQueue, ariQueue certList\n\n\tcertCache.mu.RLock()\n\tfor certKey, cert := range certCache.cache {\n\t\tif !cert.managed {\n\t\t\tcontinue\n\t\t}\n\n\t\t// the list of names on this cert should never be empty... programmer error?\n\t\tif cert.Names == nil || len(cert.Names) == 0 {\n\t\t\tlog.Warn(\"certificate has no names; removing from cache\", zap.String(\"cert_key\", certKey))\n\t\t\tdeleteQueue = append(deleteQueue, cert)\n\t\t\tcontinue\n\t\t}\n\n\t\t// get the config associated with this certificate\n\t\tcfg, err := certCache.getConfig(cert)\n\t\tif err != nil {\n\t\t\tlog.Error(\"unable to get configuration to manage certificate; unable to renew\",\n\t\t\t\tzap.Strings(\"identifiers\", cert.Names),\n\t\t\t\tzap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tif cfg == nil {\n\t\t\t// this is bad if this happens, probably a programmer error (oops)\n\t\t\tlog.Error(\"no configuration associated with certificate; unable to manage\",\n\t\t\t\tzap.Strings(\"identifiers\", cert.Names))\n\t\t\tcontinue\n\t\t}\n\t\tif cfg.OnDemand != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// ACME-specific: see if if ACME Renewal Info (ARI) window needs refreshing\n\t\tif !cfg.DisableARI && cert.ari.NeedsRefresh() {\n\t\t\tconfigs[cert.hash] = cfg\n\t\t\tariQueue = append(ariQueue, cert)\n\t\t}\n\n\t\t// if time is up or expires soon, we need to try to renew it\n\t\tif cert.NeedsRenewal(cfg) {\n\t\t\tconfigs[cert.hash] = cfg\n\n\t\t\t// see if the certificate in storage has already been renewed, possibly by another\n\t\t\t// instance that didn't coordinate with this one; if so, just load it (this\n\t\t\t// might happen if another instance already renewed it - kinda sloppy but checking disk\n\t\t\t// first is a simple way to possibly drastically reduce rate limit problems)\n\t\t\tstoredCertNeedsRenew, err := cfg.managedCertInStorageNeedsRenewal(ctx, cert)\n\t\t\tif err != nil {\n\t\t\t\t// hmm, weird, but not a big deal, maybe it was deleted or something\n\t\t\t\tlog.Warn(\"error while checking if stored certificate is also expiring soon\",\n\t\t\t\t\tzap.Strings(\"identifiers\", cert.Names),\n\t\t\t\t\tzap.Error(err))\n\t\t\t} else if !storedCertNeedsRenew {\n\t\t\t\t// if the certificate does NOT need renewal and there was no error, then we\n\t\t\t\t// are good to just reload the certificate from storage instead of repeating\n\t\t\t\t// a likely-unnecessary renewal procedure\n\t\t\t\treloadQueue = append(reloadQueue, cert)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// the certificate in storage has not been renewed yet, so we will do it\n\t\t\t// NOTE: It is super-important to note that the TLS-ALPN challenge requires\n\t\t\t// a write lock on the cache in order to complete its challenge, so it is extra\n\t\t\t// vital that this renew operation does not happen inside our read lock!\n\t\t\trenewQueue.insert(cert)\n\t\t}\n\t}\n\tcertCache.mu.RUnlock()\n\n\t// Update ARI, and then for any certs where the ARI window changed,\n\t// be sure to queue them for renewal if necessary\n\tfor _, cert := range ariQueue {\n\t\tcfg := configs[cert.hash]\n\t\tcert, changed, err := cfg.updateARI(ctx, cert, log)\n\t\tif err != nil {\n\t\t\tlog.Error(\"updating ARI\", zap.Error(err))\n\t\t}\n\t\tif changed && cert.NeedsRenewal(cfg) {\n\t\t\t// it's theoretically possible that another instance already got the memo\n\t\t\t// on the changed ARI and even renewed the cert already, and thus doing it\n\t\t\t// here is wasteful, but I have never heard of this happening in reality,\n\t\t\t// so to save some cycles for now I think we'll just queue it for renewal\n\t\t\t// (notice how we use 'insert' to avoid duplicates, in case it was already\n\t\t\t// scheduled for renewal anyway)\n\t\t\trenewQueue.insert(cert)\n\t\t}\n\t}\n\n\t// Reload certificates that merely need to be updated in memory\n\tfor _, oldCert := range reloadQueue {\n\t\ttimeLeft := expiresAt(oldCert.Leaf).Sub(time.Now().UTC())\n\t\tlog.Info(\"certificate expires soon, but is already renewed in storage; reloading stored certificate\",\n\t\t\tzap.Strings(\"identifiers\", oldCert.Names),\n\t\t\tzap.Duration(\"remaining\", timeLeft))\n\n\t\tcfg := configs[oldCert.hash]\n\n\t\t// crucially, this happens OUTSIDE a lock on the certCache\n\t\t_, err := cfg.reloadManagedCertificate(ctx, oldCert)\n\t\tif err != nil {\n\t\t\tlog.Error(\"loading renewed certificate\",\n\t\t\t\tzap.Strings(\"identifiers\", oldCert.Names),\n\t\t\t\tzap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t}\n\n\t// Renewal queue\n\tfor _, oldCert := range renewQueue {\n\t\tcfg := configs[oldCert.hash]\n\t\terr := certCache.queueRenewalTask(ctx, oldCert, cfg)\n\t\tif err != nil {\n\t\t\tlog.Error(\"queueing renewal task\",\n\t\t\t\tzap.Strings(\"identifiers\", oldCert.Names),\n\t\t\t\tzap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t}\n\n\t// Deletion queue\n\tcertCache.mu.Lock()\n\tfor _, cert := range deleteQueue {\n\t\tcertCache.removeCertificate(cert)\n\t}\n\tcertCache.mu.Unlock()\n\n\treturn nil\n}\n\nfunc (certCache *Cache) queueRenewalTask(ctx context.Context, oldCert Certificate, cfg *Config) error {\n\tlog := certCache.logger.Named(\"maintenance\")\n\n\ttimeLeft := expiresAt(oldCert.Leaf).Sub(time.Now().UTC())\n\tlog.Info(\"certificate expires soon; queuing for renewal\",\n\t\tzap.Strings(\"identifiers\", oldCert.Names),\n\t\tzap.Duration(\"remaining\", timeLeft))\n\n\t// Get the name which we should use to renew this certificate;\n\t// we only support managing certificates with one name per cert,\n\t// so this should be easy.\n\trenewName := oldCert.Names[0]\n\n\t// queue up this renewal job (is a no-op if already active or queued)\n\tjm.Submit(cfg.Logger, \"renew_\"+renewName, func() error {\n\t\ttimeLeft := expiresAt(oldCert.Leaf).Sub(time.Now().UTC())\n\t\tlog.Info(\"attempting certificate renewal\",\n\t\t\tzap.Strings(\"identifiers\", oldCert.Names),\n\t\t\tzap.Duration(\"remaining\", timeLeft))\n\n\t\t// perform renewal - crucially, this happens OUTSIDE a lock on certCache\n\t\terr := cfg.RenewCertAsync(ctx, renewName, false)\n\t\tif err != nil {\n\t\t\tif cfg.OnDemand != nil {\n\t\t\t\t// loaded dynamically, remove dynamically\n\t\t\t\tcertCache.mu.Lock()\n\t\t\t\tcertCache.removeCertificate(oldCert)\n\t\t\t\tcertCache.mu.Unlock()\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"%v %v\", oldCert.Names, err)\n\t\t}\n\n\t\t// successful renewal, so update in-memory cache by loading\n\t\t// renewed certificate so it will be used with handshakes\n\t\t_, err = cfg.reloadManagedCertificate(ctx, oldCert)\n\t\tif err != nil {\n\t\t\treturn ErrNoRetry{fmt.Errorf(\"%v %v\", oldCert.Names, err)}\n\t\t}\n\t\treturn nil\n\t})\n\n\treturn nil\n}\n\n// updateOCSPStaples updates the OCSP stapling in all\n// eligible, cached certificates.\n//\n// OCSP maintenance strives to abide the relevant points on\n// Ryan Sleevi's recommendations for good OCSP support:\n// https://gist.github.com/sleevi/5efe9ef98961ecfb4da8\nfunc (certCache *Cache) updateOCSPStaples(ctx context.Context) {\n\tlogger := certCache.logger.Named(\"maintenance\")\n\n\t// temporary structures to store updates or tasks\n\t// so that we can keep our locks short-lived\n\ttype ocspUpdate struct {\n\t\trawBytes []byte\n\t\tparsed   *ocsp.Response\n\t}\n\ttype updateQueueEntry struct {\n\t\tcert           Certificate\n\t\tcertHash       string\n\t\tlastNextUpdate time.Time\n\t\tcfg            *Config\n\t}\n\ttype renewQueueEntry struct {\n\t\toldCert Certificate\n\t\tcfg     *Config\n\t}\n\tupdated := make(map[string]ocspUpdate)\n\tvar updateQueue []updateQueueEntry // certs that need a refreshed staple\n\tvar renewQueue []renewQueueEntry   // certs that need to be renewed (due to revocation)\n\n\t// obtain brief read lock during our scan to see which staples need updating\n\tcertCache.mu.RLock()\n\tfor certHash, cert := range certCache.cache {\n\t\t// no point in updating OCSP for expired or \"synthetic\" certificates\n\t\tif cert.Leaf == nil || cert.Expired() {\n\t\t\tcontinue\n\t\t}\n\t\tcfg, err := certCache.getConfig(cert)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"unable to get automation config for certificate; maintenance for this certificate will likely fail\",\n\t\t\t\tzap.Strings(\"identifiers\", cert.Names),\n\t\t\t\tzap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\t// always try to replace revoked certificates, even if OCSP response is still fresh\n\t\tif certShouldBeForceRenewed(cert) {\n\t\t\trenewQueue = append(renewQueue, renewQueueEntry{\n\t\t\t\toldCert: cert,\n\t\t\t\tcfg:     cfg,\n\t\t\t})\n\t\t\tcontinue\n\t\t}\n\t\t// if the status is not fresh, get a new one\n\t\tvar lastNextUpdate time.Time\n\t\tif cert.ocsp != nil {\n\t\t\tlastNextUpdate = cert.ocsp.NextUpdate\n\t\t\tif cert.ocsp.Status != ocsp.Unknown && freshOCSP(cert.ocsp) {\n\t\t\t\t// no need to update our staple if still fresh and not Unknown\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tupdateQueue = append(updateQueue, updateQueueEntry{cert, certHash, lastNextUpdate, cfg})\n\t}\n\tcertCache.mu.RUnlock()\n\n\t// perform updates outside of any lock on certCache\n\tfor _, qe := range updateQueue {\n\t\tcert := qe.cert\n\t\tcertHash := qe.certHash\n\t\tlastNextUpdate := qe.lastNextUpdate\n\n\t\tif qe.cfg == nil {\n\t\t\t// this is bad if this happens, probably a programmer error (oops)\n\t\t\tlogger.Error(\"no configuration associated with certificate; unable to manage OCSP staples\",\n\t\t\t\tzap.Strings(\"identifiers\", cert.Names))\n\t\t\tcontinue\n\t\t}\n\n\t\terr := stapleOCSP(ctx, qe.cfg.OCSP, qe.cfg.Storage, &cert, nil)\n\t\tif err != nil {\n\t\t\tif cert.ocsp != nil {\n\t\t\t\t// if there was no staple before, that's fine; otherwise we should log the error\n\t\t\t\tlogger.Error(\"stapling OCSP\",\n\t\t\t\t\tzap.Strings(\"identifiers\", cert.Names),\n\t\t\t\t\tzap.Error(err))\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// By this point, we've obtained the latest OCSP response.\n\t\t// If there was no staple before, or if the response is updated, make\n\t\t// sure we apply the update to all names on the certificate if\n\t\t// the status is still Good.\n\t\tif cert.ocsp != nil && cert.ocsp.Status == ocsp.Good && (lastNextUpdate.IsZero() || lastNextUpdate != cert.ocsp.NextUpdate) {\n\t\t\tlogger.Info(\"advancing OCSP staple\",\n\t\t\t\tzap.Strings(\"identifiers\", cert.Names),\n\t\t\t\tzap.Time(\"from\", lastNextUpdate),\n\t\t\t\tzap.Time(\"to\", cert.ocsp.NextUpdate))\n\t\t\tupdated[certHash] = ocspUpdate{rawBytes: cert.Certificate.OCSPStaple, parsed: cert.ocsp}\n\t\t}\n\n\t\t// If the updated staple shows that the certificate was revoked, we should immediately renew it\n\t\tif certShouldBeForceRenewed(cert) {\n\t\t\tqe.cfg.emit(ctx, \"cert_ocsp_revoked\", map[string]any{\n\t\t\t\t\"subjects\":    cert.Names,\n\t\t\t\t\"certificate\": cert,\n\t\t\t\t\"reason\":      cert.ocsp.RevocationReason,\n\t\t\t\t\"revoked_at\":  cert.ocsp.RevokedAt,\n\t\t\t})\n\n\t\t\trenewQueue = append(renewQueue, renewQueueEntry{\n\t\t\t\toldCert: cert,\n\t\t\t\tcfg:     qe.cfg,\n\t\t\t})\n\t\t}\n\t}\n\n\t// These write locks should be brief since we have all the info we need now.\n\tfor certKey, update := range updated {\n\t\tcertCache.mu.Lock()\n\t\tif cert, ok := certCache.cache[certKey]; ok {\n\t\t\tcert.ocsp = update.parsed\n\t\t\tcert.Certificate.OCSPStaple = update.rawBytes\n\t\t\tcertCache.cache[certKey] = cert\n\t\t}\n\t\tcertCache.mu.Unlock()\n\t}\n\n\t// We attempt to replace any certificates that were revoked.\n\t// Crucially, this happens OUTSIDE a lock on the certCache.\n\tfor _, renew := range renewQueue {\n\t\t_, err := renew.cfg.forceRenew(ctx, logger, renew.oldCert)\n\t\tif err != nil {\n\t\t\tlogger.Info(\"forcefully renewing certificate due to REVOKED status\",\n\t\t\t\tzap.Strings(\"identifiers\", renew.oldCert.Names),\n\t\t\t\tzap.Error(err))\n\t\t}\n\t}\n}\n\n// storageHasNewerARI returns true if the configured storage has ARI that is newer\n// than that of a certificate that is already loaded, along with the value from\n// storage.\nfunc (cfg *Config) storageHasNewerARI(ctx context.Context, cert Certificate) (bool, acme.RenewalInfo, error) {\n\tstoredCertData, err := cfg.loadStoredACMECertificateMetadata(ctx, cert)\n\tif err != nil || storedCertData.RenewalInfo == nil {\n\t\treturn false, acme.RenewalInfo{}, err\n\t}\n\t// prefer stored info if it has a window and the loaded one doesn't,\n\t// or if the one in storage has a later RetryAfter (though I suppose\n\t// it's not guaranteed, typically those will move forward in time)\n\tif (!cert.ari.HasWindow() && storedCertData.RenewalInfo.HasWindow()) ||\n\t\t(cert.ari.RetryAfter == nil || storedCertData.RenewalInfo.RetryAfter.After(*cert.ari.RetryAfter)) {\n\t\treturn true, *storedCertData.RenewalInfo, nil\n\t}\n\treturn false, acme.RenewalInfo{}, nil\n}\n\n// loadStoredACMECertificateMetadata loads the stored ACME certificate data\n// from the cert's sidecar JSON file.\nfunc (cfg *Config) loadStoredACMECertificateMetadata(ctx context.Context, cert Certificate) (acme.Certificate, error) {\n\tmetaBytes, err := cfg.Storage.Load(ctx, StorageKeys.SiteMeta(cert.issuerKey, cert.Names[0]))\n\tif err != nil {\n\t\treturn acme.Certificate{}, fmt.Errorf(\"loading cert metadata: %w\", err)\n\t}\n\n\tvar certRes CertificateResource\n\tif err = json.Unmarshal(metaBytes, &certRes); err != nil {\n\t\treturn acme.Certificate{}, fmt.Errorf(\"unmarshaling cert metadata: %w\", err)\n\t}\n\n\tvar acmeCert acme.Certificate\n\tif err = json.Unmarshal(certRes.IssuerData, &acmeCert); err != nil {\n\t\treturn acme.Certificate{}, fmt.Errorf(\"unmarshaling potential ACME issuer metadata: %v\", err)\n\t}\n\n\treturn acmeCert, nil\n}\n\n// updateARI updates the cert's ACME renewal info, first by checking storage for a newer\n// one, or getting it from the CA if needed. The updated info is stored in storage and\n// updated in the cache. The certificate with the updated ARI is returned. If true is\n// returned, the ARI window or selected time has changed, and the caller should check if\n// the cert needs to be renewed now, even if there is an error.\n//\n// This will always try to ARI without checking if it needs to be refreshed. Call\n// NeedsRefresh() on the RenewalInfo first, and only call this if that returns true.\nfunc (cfg *Config) updateARI(ctx context.Context, cert Certificate, logger *zap.Logger) (updatedCert Certificate, changed bool, err error) {\n\tlogger = logger.With(\n\t\tzap.Strings(\"identifiers\", cert.Names),\n\t\tzap.String(\"cert_hash\", cert.hash),\n\t\tzap.String(\"ari_unique_id\", cert.ari.UniqueIdentifier),\n\t\tzap.Time(\"cert_expiry\", cert.Leaf.NotAfter))\n\n\tupdatedCert = cert\n\toldARI := cert.ari\n\n\t// synchronize ARI fetching; see #297\n\tlockName := \"ari_\" + cert.ari.UniqueIdentifier\n\tif err := acquireLock(ctx, cfg.Storage, lockName); err != nil {\n\t\treturn cert, false, fmt.Errorf(\"unable to obtain ARI lock: %v\", err)\n\t}\n\tdefer func() {\n\t\tif err := releaseLock(ctx, cfg.Storage, lockName); err != nil {\n\t\t\tlogger.Error(\"unable to release ARI lock\", zap.Error(err))\n\t\t}\n\t}()\n\n\t// see if the stored value has been refreshed already by another instance\n\tgotNewARI, newARI, err := cfg.storageHasNewerARI(ctx, cert)\n\n\t// when we're all done, log if something about the schedule is different\n\t// (\"WARN\" level because ARI window changing may be a sign of external trouble\n\t// and we want to draw their attention to a potential explanation URL)\n\tdefer func() {\n\t\tchanged = !newARI.SameWindow(oldARI)\n\n\t\tif changed {\n\t\t\tlogger.Warn(\"ARI window or selected renewal time changed\",\n\t\t\t\tzap.Time(\"prev_start\", oldARI.SuggestedWindow.Start),\n\t\t\t\tzap.Time(\"next_start\", newARI.SuggestedWindow.Start),\n\t\t\t\tzap.Time(\"prev_end\", oldARI.SuggestedWindow.End),\n\t\t\t\tzap.Time(\"next_end\", newARI.SuggestedWindow.End),\n\t\t\t\tzap.Time(\"prev_selected_time\", oldARI.SelectedTime),\n\t\t\t\tzap.Time(\"next_selected_time\", newARI.SelectedTime),\n\t\t\t\tzap.String(\"explanation_url\", newARI.ExplanationURL))\n\t\t}\n\t}()\n\n\tif err == nil && gotNewARI {\n\t\t// great, storage has a newer one we can use\n\t\tcfg.certCache.mu.Lock()\n\t\tupdatedCert = cfg.certCache.cache[cert.hash]\n\t\tupdatedCert.ari = newARI\n\t\tcfg.certCache.cache[cert.hash] = updatedCert\n\t\tcfg.certCache.mu.Unlock()\n\t\tlogger.Info(\"reloaded ARI with newer one in storage\",\n\t\t\tzap.Timep(\"next_refresh\", newARI.RetryAfter),\n\t\t\tzap.Time(\"renewal_time\", newARI.SelectedTime))\n\t\treturn\n\t}\n\n\tif err != nil {\n\t\tlogger.Error(\"error while checking storage for updated ARI; updating ARI now\", zap.Error(err))\n\t}\n\n\t// of the issuers configured, hopefully one of them is the ACME CA we got the cert from\n\tfor _, iss := range cfg.Issuers {\n\t\tif ariGetter, ok := iss.(RenewalInfoGetter); ok && iss.IssuerKey() == cert.issuerKey {\n\t\t\tnewARI, err = ariGetter.GetRenewalInfo(ctx, cert) // be sure to use existing newARI variable so we can compare against old value in the defer\n\t\t\tif err != nil {\n\t\t\t\t// could be anything, but a common error might simply be the \"wrong\" ACME CA\n\t\t\t\t// (meaning, different from the one that issued the cert, thus the only one\n\t\t\t\t// that would have any ARI for it) if multiple ACME CAs are configured\n\t\t\t\tlogger.Error(\"failed updating renewal info from ACME CA\",\n\t\t\t\t\tzap.String(\"issuer\", iss.IssuerKey()),\n\t\t\t\t\tzap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// when we get the latest ARI, the acme package will select a time within the window\n\t\t\t// for us; of course, since it's random, it's likely different from the previously-\n\t\t\t// selected time; but if the window doesn't change, there's no need to change the\n\t\t\t// selected time (the acme package doesn't know the previous window to know better)\n\t\t\t// ... so if the window hasn't changed we'll just put back the selected time\n\t\t\tif newARI.SameWindow(oldARI) && !oldARI.SelectedTime.IsZero() {\n\t\t\t\tnewARI.SelectedTime = oldARI.SelectedTime\n\t\t\t}\n\n\t\t\t// then store the updated ARI (even if the window didn't change, the Retry-After\n\t\t\t// likely did) in cache and storage\n\n\t\t\t// be sure we get the cert from the cache while inside a lock to avoid logical races\n\t\t\tcfg.certCache.mu.Lock()\n\t\t\tupdatedCert = cfg.certCache.cache[cert.hash]\n\t\t\tupdatedCert.ari = newARI\n\t\t\tcfg.certCache.cache[cert.hash] = updatedCert\n\t\t\tcfg.certCache.mu.Unlock()\n\n\t\t\t// update the ARI value in storage\n\t\t\tvar certData acme.Certificate\n\t\t\tcertData, err = cfg.loadStoredACMECertificateMetadata(ctx, cert)\n\t\t\tif err != nil {\n\t\t\t\terr = fmt.Errorf(\"got new ARI from %s, but failed loading stored certificate metadata: %v\", iss.IssuerKey(), err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcertData.RenewalInfo = &newARI\n\t\t\tvar certDataBytes, certResBytes []byte\n\t\t\tcertDataBytes, err = json.Marshal(certData)\n\t\t\tif err != nil {\n\t\t\t\terr = fmt.Errorf(\"got new ARI from %s, but failed marshaling certificate ACME metadata: %v\", iss.IssuerKey(), err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcertResBytes, err = json.MarshalIndent(CertificateResource{\n\t\t\t\tSANs:       cert.Names,\n\t\t\t\tIssuerData: certDataBytes,\n\t\t\t}, \"\", \"\\t\")\n\t\t\tif err != nil {\n\t\t\t\terr = fmt.Errorf(\"got new ARI from %s, but could not re-encode certificate metadata: %v\", iss.IssuerKey(), err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err = cfg.Storage.Store(ctx, StorageKeys.SiteMeta(cert.issuerKey, cert.Names[0]), certResBytes); err != nil {\n\t\t\t\terr = fmt.Errorf(\"got new ARI from %s, but could not store it with certificate metadata: %v\", iss.IssuerKey(), err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlogger.Info(\"updated ACME renewal information\",\n\t\t\t\tzap.Time(\"selected_time\", newARI.SelectedTime),\n\t\t\t\tzap.Timep(\"next_update\", newARI.RetryAfter),\n\t\t\t\tzap.String(\"explanation_url\", newARI.ExplanationURL))\n\n\t\t\treturn\n\t\t}\n\t}\n\n\terr = fmt.Errorf(\"could not fully update ACME renewal info: either no issuer supporting ARI is configured for certificate, or all such failed (make sure the ACME CA that issued the certificate is configured)\")\n\treturn\n}\n\n// CleanStorageOptions specifies how to clean up a storage unit.\ntype CleanStorageOptions struct {\n\t// Optional custom logger.\n\tLogger *zap.Logger\n\n\t// Optional ID of the instance initiating the cleaning.\n\tInstanceID string\n\n\t// If set, cleaning will be skipped if it was performed\n\t// more recently than this interval.\n\tInterval time.Duration\n\n\t// Whether to clean cached OCSP staples.\n\tOCSPStaples bool\n\n\t// Whether to cleanup expired certificates, and if so,\n\t// how long to let them stay after they've expired.\n\tExpiredCerts           bool\n\tExpiredCertGracePeriod time.Duration\n}\n\n// CleanStorage removes assets which are no longer useful,\n// according to opts.\nfunc CleanStorage(ctx context.Context, storage Storage, opts CleanStorageOptions) error {\n\tconst (\n\t\tlockName   = \"storage_clean\"\n\t\tstorageKey = \"last_clean.json\"\n\t)\n\n\tif opts.Logger == nil {\n\t\topts.Logger = defaultLogger.Named(\"clean_storage\")\n\t}\n\topts.Logger = opts.Logger.With(zap.Any(\"storage\", storage))\n\n\t// storage cleaning should be globally exclusive\n\tif err := acquireLock(ctx, storage, lockName); err != nil {\n\t\treturn fmt.Errorf(\"unable to acquire %s lock: %v\", lockName, err)\n\t}\n\tdefer func() {\n\t\tif err := releaseLock(ctx, storage, lockName); err != nil {\n\t\t\topts.Logger.Error(\"unable to release lock\", zap.Error(err))\n\t\t\treturn\n\t\t}\n\t}()\n\n\t// cleaning should not happen more often than the interval\n\tif opts.Interval > 0 {\n\t\tlastCleanBytes, err := storage.Load(ctx, storageKey)\n\t\tif !errors.Is(err, fs.ErrNotExist) {\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"loading last clean timestamp: %v\", err)\n\t\t\t}\n\n\t\t\tvar lastClean lastCleanPayload\n\t\t\terr = json.Unmarshal(lastCleanBytes, &lastClean)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"decoding last clean data: %v\", err)\n\t\t\t}\n\n\t\t\tlastTLSClean := lastClean[\"tls\"]\n\t\t\tif time.Since(lastTLSClean.Timestamp) < opts.Interval {\n\t\t\t\tnextTime := time.Now().Add(opts.Interval)\n\t\t\t\topts.Logger.Info(\"storage cleaning happened too recently; skipping for now\",\n\t\t\t\t\tzap.String(\"instance\", lastTLSClean.InstanceID),\n\t\t\t\t\tzap.Time(\"try_again\", nextTime),\n\t\t\t\t\tzap.Duration(\"try_again_in\", time.Until(nextTime)),\n\t\t\t\t)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\n\topts.Logger.Info(\"cleaning storage unit\")\n\n\tif opts.OCSPStaples {\n\t\terr := deleteOldOCSPStaples(ctx, storage, opts.Logger)\n\t\tif err != nil {\n\t\t\topts.Logger.Error(\"deleting old OCSP staples\", zap.Error(err))\n\t\t}\n\t}\n\tif opts.ExpiredCerts {\n\t\terr := deleteExpiredCerts(ctx, storage, opts.Logger, opts.ExpiredCertGracePeriod)\n\t\tif err != nil {\n\t\t\topts.Logger.Error(\"deleting expired certificates staples\", zap.Error(err))\n\t\t}\n\t}\n\t// TODO: delete stale locks?\n\n\t// update the last-clean time\n\tlastCleanBytes, err := json.Marshal(lastCleanPayload{\n\t\t\"tls\": lastCleaned{\n\t\t\tTimestamp:  time.Now(),\n\t\t\tInstanceID: opts.InstanceID,\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"encoding last cleaned info: %v\", err)\n\t}\n\tif err := storage.Store(ctx, storageKey, lastCleanBytes); err != nil {\n\t\treturn fmt.Errorf(\"storing last clean info: %v\", err)\n\t}\n\n\treturn nil\n}\n\ntype lastCleanPayload map[string]lastCleaned\n\ntype lastCleaned struct {\n\tTimestamp  time.Time `json:\"timestamp\"`\n\tInstanceID string    `json:\"instance_id,omitempty\"`\n}\n\nfunc deleteOldOCSPStaples(ctx context.Context, storage Storage, logger *zap.Logger) error {\n\tocspKeys, err := storage.List(ctx, prefixOCSP, false)\n\tif err != nil {\n\t\t// maybe just hasn't been created yet; no big deal\n\t\treturn nil\n\t}\n\tfor _, key := range ocspKeys {\n\t\t// if context was cancelled, quit early; otherwise proceed\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\t\tocspBytes, err := storage.Load(ctx, key)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"while deleting old OCSP staples, unable to load staple file\", zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tresp, err := ocsp.ParseResponse(ocspBytes, nil)\n\t\tif err != nil {\n\t\t\t// contents are invalid; delete it\n\t\t\terr = storage.Delete(ctx, key)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"purging corrupt staple file\", zap.String(\"storage_key\", key), zap.Error(err))\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif time.Now().After(resp.NextUpdate) {\n\t\t\t// response has expired; delete it\n\t\t\terr = storage.Delete(ctx, key)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"purging expired staple file\", zap.String(\"storage_key\", key), zap.Error(err))\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc deleteExpiredCerts(ctx context.Context, storage Storage, logger *zap.Logger, gracePeriod time.Duration) error {\n\tissuerKeys, err := storage.List(ctx, prefixCerts, false)\n\tif err != nil {\n\t\t// maybe just hasn't been created yet; no big deal\n\t\treturn nil\n\t}\n\n\tfor _, issuerKey := range issuerKeys {\n\t\tsiteKeys, err := storage.List(ctx, issuerKey, false)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"listing contents\", zap.String(\"issuer_key\", issuerKey), zap.Error(err))\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, siteKey := range siteKeys {\n\t\t\t// if context was cancelled, quit early; otherwise proceed\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn ctx.Err()\n\t\t\tdefault:\n\t\t\t}\n\n\t\t\tsiteAssets, err := storage.List(ctx, siteKey, false)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"listing site contents\", zap.String(\"site_key\", siteKey), zap.Error(err))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor _, assetKey := range siteAssets {\n\t\t\t\tif path.Ext(assetKey) != \".crt\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tcertFile, err := storage.Load(ctx, assetKey)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"loading certificate file %s: %v\", assetKey, err)\n\t\t\t\t}\n\t\t\t\tblock, _ := pem.Decode(certFile)\n\t\t\t\tif block == nil || block.Type != \"CERTIFICATE\" {\n\t\t\t\t\treturn fmt.Errorf(\"certificate file %s does not contain PEM-encoded certificate\", assetKey)\n\t\t\t\t}\n\t\t\t\tcert, err := x509.ParseCertificate(block.Bytes)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"certificate file %s is malformed; error parsing PEM: %v\", assetKey, err)\n\t\t\t\t}\n\n\t\t\t\tif expiredTime := time.Since(expiresAt(cert)); expiredTime >= gracePeriod {\n\t\t\t\t\tlogger.Info(\"certificate expired beyond grace period; cleaning up\",\n\t\t\t\t\t\tzap.String(\"asset_key\", assetKey),\n\t\t\t\t\t\tzap.Duration(\"expired_for\", expiredTime),\n\t\t\t\t\t\tzap.Duration(\"grace_period\", gracePeriod))\n\t\t\t\t\tbaseName := strings.TrimSuffix(assetKey, \".crt\")\n\t\t\t\t\tfor _, relatedAsset := range []string{\n\t\t\t\t\t\tassetKey,\n\t\t\t\t\t\tbaseName + \".key\",\n\t\t\t\t\t\tbaseName + \".json\",\n\t\t\t\t\t} {\n\t\t\t\t\t\tlogger.Info(\"deleting asset because resource expired\", zap.String(\"asset_key\", relatedAsset))\n\t\t\t\t\t\terr := storage.Delete(ctx, relatedAsset)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tlogger.Error(\"could not clean up asset related to expired certificate\",\n\t\t\t\t\t\t\t\tzap.String(\"base_name\", baseName),\n\t\t\t\t\t\t\t\tzap.String(\"related_asset\", relatedAsset),\n\t\t\t\t\t\t\t\tzap.Error(err))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// update listing; if folder is empty, delete it\n\t\t\tsiteAssets, err = storage.List(ctx, siteKey, false)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif len(siteAssets) == 0 {\n\t\t\t\tlogger.Info(\"deleting site folder because key is empty\", zap.String(\"site_key\", siteKey))\n\t\t\t\terr := storage.Delete(ctx, siteKey)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"deleting empty site folder %s: %v\", siteKey, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// forceRenew forcefully renews cert and replaces it in the cache, and returns the new certificate. It is intended\n// for use primarily in the case of cert revocation. This MUST NOT be called within a lock on cfg.certCacheMu.\nfunc (cfg *Config) forceRenew(ctx context.Context, logger *zap.Logger, cert Certificate) (Certificate, error) {\n\tif cert.ocsp != nil && cert.ocsp.Status == ocsp.Revoked {\n\t\tlogger.Warn(\"OCSP status for managed certificate is REVOKED; attempting to replace with new certificate\",\n\t\t\tzap.Strings(\"identifiers\", cert.Names),\n\t\t\tzap.Time(\"expiration\", expiresAt(cert.Leaf)))\n\t} else {\n\t\tlogger.Warn(\"forcefully renewing certificate\",\n\t\t\tzap.Strings(\"identifiers\", cert.Names),\n\t\t\tzap.Time(\"expiration\", expiresAt(cert.Leaf)))\n\t}\n\n\trenewName := cert.Names[0]\n\n\t// if revoked for key compromise, we can't be sure whether the storage of\n\t// the key is still safe; however, we KNOW the old key is not safe, and we\n\t// can only hope by the time of revocation that storage has been secured;\n\t// key management is not something we want to get into, but in this case\n\t// it seems prudent to replace the key - and since renewal requires reuse\n\t// of a prior key, we can't do a \"renew\" to replace the cert if we need a\n\t// new key, so we'll have to do an obtain instead\n\tvar obtainInsteadOfRenew bool\n\tif cert.ocsp != nil && cert.ocsp.RevocationReason == acme.ReasonKeyCompromise {\n\t\terr := cfg.moveCompromisedPrivateKey(ctx, cert, logger)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"could not remove compromised private key from use\",\n\t\t\t\tzap.Strings(\"identifiers\", cert.Names),\n\t\t\t\tzap.String(\"issuer\", cert.issuerKey),\n\t\t\t\tzap.Error(err))\n\t\t}\n\t\tobtainInsteadOfRenew = true\n\t}\n\n\tvar err error\n\tif obtainInsteadOfRenew {\n\t\terr = cfg.ObtainCertAsync(ctx, renewName)\n\t} else {\n\t\t// notice that we force renewal; otherwise, it might see that the\n\t\t// certificate isn't close to expiring and return, but we really\n\t\t// need a replacement certificate! see issue #4191\n\t\terr = cfg.RenewCertAsync(ctx, renewName, true)\n\t}\n\tif err != nil {\n\t\tif cert.ocsp != nil && cert.ocsp.Status == ocsp.Revoked {\n\t\t\t// probably better to not serve a revoked certificate at all\n\t\t\tlogger.Error(\"unable to obtain new to certificate after OCSP status of REVOKED; removing from cache\",\n\t\t\t\tzap.Strings(\"identifiers\", cert.Names),\n\t\t\t\tzap.Error(err))\n\t\t\tcfg.certCache.mu.Lock()\n\t\t\tcfg.certCache.removeCertificate(cert)\n\t\t\tcfg.certCache.mu.Unlock()\n\t\t}\n\t\treturn cert, fmt.Errorf(\"unable to forcefully get new certificate for %v: %w\", cert.Names, err)\n\t}\n\n\treturn cfg.reloadManagedCertificate(ctx, cert)\n}\n\n// moveCompromisedPrivateKey moves the private key for cert to a \".compromised\" file\n// by copying the data to the new file, then deleting the old one.\nfunc (cfg *Config) moveCompromisedPrivateKey(ctx context.Context, cert Certificate, logger *zap.Logger) error {\n\tprivKeyStorageKey := StorageKeys.SitePrivateKey(cert.issuerKey, cert.Names[0])\n\n\tprivKeyPEM, err := cfg.Storage.Load(ctx, privKeyStorageKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcompromisedPrivKeyStorageKey := privKeyStorageKey + \".compromised\"\n\terr = cfg.Storage.Store(ctx, compromisedPrivKeyStorageKey, privKeyPEM)\n\tif err != nil {\n\t\t// better safe than sorry: as a last resort, try deleting the key so it won't be reused\n\t\tcfg.Storage.Delete(ctx, privKeyStorageKey)\n\t\treturn err\n\t}\n\n\terr = cfg.Storage.Delete(ctx, privKeyStorageKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogger.Info(\"removed certificate's compromised private key from use\",\n\t\tzap.String(\"storage_path\", compromisedPrivKeyStorageKey),\n\t\tzap.Strings(\"identifiers\", cert.Names),\n\t\tzap.String(\"issuer\", cert.issuerKey))\n\n\treturn nil\n}\n\n// certShouldBeForceRenewed returns true if cert should be forcefully renewed\n// (like if it is revoked according to its OCSP response).\nfunc certShouldBeForceRenewed(cert Certificate) bool {\n\treturn cert.managed &&\n\t\tlen(cert.Names) > 0 &&\n\t\tcert.ocsp != nil &&\n\t\tcert.ocsp.Status == ocsp.Revoked\n}\n\ntype certList []Certificate\n\n// insert appends cert to the list if it is not already in the list.\n// Efficiency: O(n)\nfunc (certs *certList) insert(cert Certificate) {\n\tfor _, c := range *certs {\n\t\tif c.hash == cert.hash {\n\t\t\treturn\n\t\t}\n\t}\n\t*certs = append(*certs, cert)\n}\n\nconst (\n\t// DefaultRenewCheckInterval is how often to check certificates for expiration.\n\t// Scans are very lightweight, so this can be semi-frequent. This default should\n\t// be smaller than <Minimum Cert Lifetime>*DefaultRenewalWindowRatio/3, which\n\t// gives certificates plenty of chance to be renewed on time.\n\tDefaultRenewCheckInterval = 10 * time.Minute\n\n\t// DefaultRenewalWindowRatio is how much of a certificate's lifetime becomes the\n\t// renewal window. The renewal window is the span of time at the end of the\n\t// certificate's validity period in which it should be renewed. A default value\n\t// of ~1/3 is pretty safe and recommended for most certificates.\n\tDefaultRenewalWindowRatio = 1.0 / 3.0\n\n\t// DefaultOCSPCheckInterval is how often to check if OCSP stapling needs updating.\n\tDefaultOCSPCheckInterval = 1 * time.Hour\n)\n"
        },
        {
          "name": "ocsp.go",
          "type": "blob",
          "size": 8.84375,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/x509\"\n\t\"encoding/pem\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"golang.org/x/crypto/ocsp\"\n)\n\n// ErrNoOCSPServerSpecified indicates that OCSP information could not be\n// stapled because the certificate does not support OCSP.\nvar ErrNoOCSPServerSpecified = errors.New(\"no OCSP server specified in certificate\")\n\n// stapleOCSP staples OCSP information to cert for hostname name.\n// If you have it handy, you should pass in the PEM-encoded certificate\n// bundle; otherwise the DER-encoded cert will have to be PEM-encoded.\n// If you don't have the PEM blocks already, just pass in nil.\n//\n// If successful, the OCSP response will be set to cert's ocsp field,\n// regardless of the OCSP status. It is only stapled, however, if the\n// status is Good.\n//\n// Errors here are not necessarily fatal, it could just be that the\n// certificate doesn't have an issuer URL.\nfunc stapleOCSP(ctx context.Context, ocspConfig OCSPConfig, storage Storage, cert *Certificate, pemBundle []byte) error {\n\tif ocspConfig.DisableStapling {\n\t\treturn nil\n\t}\n\n\tif pemBundle == nil {\n\t\t// we need a PEM encoding only for some function calls below\n\t\tbundle := new(bytes.Buffer)\n\t\tfor _, derBytes := range cert.Certificate.Certificate {\n\t\t\tpem.Encode(bundle, &pem.Block{Type: \"CERTIFICATE\", Bytes: derBytes})\n\t\t}\n\t\tpemBundle = bundle.Bytes()\n\t}\n\n\tvar ocspBytes []byte\n\tvar ocspResp *ocsp.Response\n\tvar ocspErr error\n\tvar gotNewOCSP bool\n\n\t// First try to load OCSP staple from storage and see if\n\t// we can still use it.\n\tocspStapleKey := StorageKeys.OCSPStaple(cert, pemBundle)\n\tcachedOCSP, err := storage.Load(ctx, ocspStapleKey)\n\tif err == nil {\n\t\tresp, err := ocsp.ParseResponse(cachedOCSP, nil)\n\t\tif err == nil {\n\t\t\tif freshOCSP(resp) {\n\t\t\t\t// staple is still fresh; use it\n\t\t\t\tocspBytes = cachedOCSP\n\t\t\t\tocspResp = resp\n\t\t\t}\n\t\t} else {\n\t\t\t// invalid contents; delete the file\n\t\t\t// (we do this independently of the maintenance routine because\n\t\t\t// in this case we know for sure this should be a staple file\n\t\t\t// because we loaded it by name, whereas the maintenance routine\n\t\t\t// just iterates the list of files, even if somehow a non-staple\n\t\t\t// file gets in the folder. in this case we are sure it is corrupt.)\n\t\t\terr := storage.Delete(ctx, ocspStapleKey)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"[WARNING] Unable to delete invalid OCSP staple file: %v\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we couldn't get a fresh staple by reading the cache,\n\t// then we need to request it from the OCSP responder\n\tif ocspResp == nil || len(ocspBytes) == 0 {\n\t\tocspBytes, ocspResp, ocspErr = getOCSPForCert(ocspConfig, pemBundle)\n\t\t// An error here is not a problem because a certificate\n\t\t// may simply not contain a link to an OCSP server.\n\t\tif ocspErr != nil {\n\t\t\t// For short-lived certificates, this is fine and we can ignore\n\t\t\t// logging because OCSP doesn't make much sense for them anyway.\n\t\t\tif cert.Lifetime() < 7*24*time.Hour {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\t// There's nothing else we can do to get OCSP for this certificate,\n\t\t\t// so we can return here with the error to warn about it.\n\t\t\treturn fmt.Errorf(\"no OCSP stapling for %v: %w\", cert.Names, ocspErr)\n\t\t}\n\t\tgotNewOCSP = true\n\t}\n\n\tif ocspResp.NextUpdate.After(expiresAt(cert.Leaf)) {\n\t\t// uh oh, this OCSP response expires AFTER the certificate does, that's kinda bogus.\n\t\t// it was the reason a lot of Symantec-validated sites (not Caddy) went down\n\t\t// in October 2017. https://twitter.com/mattiasgeniar/status/919432824708648961\n\t\treturn fmt.Errorf(\"invalid: OCSP response for %v valid after certificate expiration (%s)\",\n\t\t\tcert.Names, expiresAt(cert.Leaf).Sub(ocspResp.NextUpdate))\n\t}\n\n\t// Attach the latest OCSP response to the certificate; this is NOT the same\n\t// as stapling it, which we do below only if the status is Good, but it is\n\t// useful to keep with the cert in order to act on it later (like if Revoked).\n\tcert.ocsp = ocspResp\n\n\t// If the response is good, staple it to the certificate. If the OCSP\n\t// response was not loaded from storage, we persist it for next time.\n\tif ocspResp.Status == ocsp.Good {\n\t\tcert.Certificate.OCSPStaple = ocspBytes\n\t\tif gotNewOCSP {\n\t\t\terr := storage.Store(ctx, ocspStapleKey, ocspBytes)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"unable to write OCSP staple file for %v: %v\", cert.Names, err)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// getOCSPForCert takes a PEM encoded cert or cert bundle returning the raw OCSP response,\n// the parsed response, and an error, if any. The returned []byte can be passed directly\n// into the OCSPStaple property of a tls.Certificate. If the bundle only contains the\n// issued certificate, this function will try to get the issuer certificate from the\n// IssuingCertificateURL in the certificate. If the []byte and/or ocsp.Response return\n// values are nil, the OCSP status may be assumed OCSPUnknown.\n//\n// Borrowed from xenolf.\nfunc getOCSPForCert(ocspConfig OCSPConfig, bundle []byte) ([]byte, *ocsp.Response, error) {\n\t// TODO: Perhaps this should be synchronized too, with a Locker?\n\n\tcertificates, err := parseCertsFromPEMBundle(bundle)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// We expect the certificate slice to be ordered downwards the chain.\n\t// SRV CRT -> CA. We need to pull the leaf and issuer certs out of it,\n\t// which should always be the first two certificates. If there's no\n\t// OCSP server listed in the leaf cert, there's nothing to do. And if\n\t// we have only one certificate so far, we need to get the issuer cert.\n\tissuedCert := certificates[0]\n\tif len(issuedCert.OCSPServer) == 0 {\n\t\treturn nil, nil, ErrNoOCSPServerSpecified\n\t}\n\n\t// apply override for responder URL\n\trespURL := issuedCert.OCSPServer[0]\n\tif len(ocspConfig.ResponderOverrides) > 0 {\n\t\tif override, ok := ocspConfig.ResponderOverrides[respURL]; ok {\n\t\t\trespURL = override\n\t\t}\n\t}\n\tif respURL == \"\" {\n\t\treturn nil, nil, fmt.Errorf(\"override disables querying OCSP responder: %v\", issuedCert.OCSPServer[0])\n\t}\n\n\t// configure HTTP client if necessary\n\thttpClient := http.DefaultClient\n\tif ocspConfig.HTTPProxy != nil {\n\t\thttpClient = &http.Client{\n\t\t\tTransport: &http.Transport{\n\t\t\t\tProxy: ocspConfig.HTTPProxy,\n\t\t\t},\n\t\t\tTimeout: 30 * time.Second,\n\t\t}\n\t}\n\n\t// get issuer certificate if needed\n\tif len(certificates) == 1 {\n\t\tif len(issuedCert.IssuingCertificateURL) == 0 {\n\t\t\treturn nil, nil, fmt.Errorf(\"no URL to issuing certificate\")\n\t\t}\n\n\t\tresp, err := httpClient.Get(issuedCert.IssuingCertificateURL[0])\n\t\tif err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(\"getting issuer certificate: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tissuerBytes, err := io.ReadAll(io.LimitReader(resp.Body, 1024*1024))\n\t\tif err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(\"reading issuer certificate: %v\", err)\n\t\t}\n\n\t\tissuerCert, err := x509.ParseCertificate(issuerBytes)\n\t\tif err != nil {\n\t\t\treturn nil, nil, fmt.Errorf(\"parsing issuer certificate: %v\", err)\n\t\t}\n\n\t\t// insert it into the slice on position 0;\n\t\t// we want it ordered right SRV CRT -> CA\n\t\tcertificates = append(certificates, issuerCert)\n\t}\n\n\tissuerCert := certificates[1]\n\n\tocspReq, err := ocsp.CreateRequest(issuedCert, issuerCert, nil)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"creating OCSP request: %v\", err)\n\t}\n\n\treader := bytes.NewReader(ocspReq)\n\treq, err := httpClient.Post(respURL, \"application/ocsp-request\", reader)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"making OCSP request: %v\", err)\n\t}\n\tdefer req.Body.Close()\n\n\tocspResBytes, err := io.ReadAll(io.LimitReader(req.Body, 1024*1024))\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"reading OCSP response: %v\", err)\n\t}\n\n\tocspRes, err := ocsp.ParseResponse(ocspResBytes, issuerCert)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"parsing OCSP response: %v\", err)\n\t}\n\n\treturn ocspResBytes, ocspRes, nil\n}\n\n// freshOCSP returns true if resp is still fresh,\n// meaning that it is not expedient to get an\n// updated response from the OCSP server.\nfunc freshOCSP(resp *ocsp.Response) bool {\n\tnextUpdate := resp.NextUpdate\n\t// If there is an OCSP responder certificate, and it expires before the\n\t// OCSP response, use its expiration date as the end of the OCSP\n\t// response's validity period.\n\tif resp.Certificate != nil && resp.Certificate.NotAfter.Before(nextUpdate) {\n\t\tnextUpdate = resp.Certificate.NotAfter\n\t}\n\t// start checking OCSP staple about halfway through validity period for good measure\n\trefreshTime := resp.ThisUpdate.Add(nextUpdate.Sub(resp.ThisUpdate) / 2)\n\treturn time.Now().Before(refreshTime)\n}\n"
        },
        {
          "name": "ocsp_test.go",
          "type": "blob",
          "size": 6.1669921875,
          "content": "package certmagic\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"golang.org/x/crypto/ocsp\"\n)\n\nconst certWithOCSPServer = `-----BEGIN CERTIFICATE-----\nMIIBgjCCASegAwIBAgICIAAwCgYIKoZIzj0EAwIwEjEQMA4GA1UEAxMHVGVzdCBD\nQTAeFw0yMzAxMDExMjAwMDBaFw0yMzAyMDExMjAwMDBaMCAxHjAcBgNVBAMTFU9D\nU1AgVGVzdCBDZXJ0aWZpY2F0ZTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABIoe\nI/bjo34qony8LdRJD+Jhuk8/S8YHXRHl6rH9t5VFCFtX8lIPN/Ll1zCrQ2KB3Wlb\nfxSgiQyLrCpZyrdhVPSjXzBdMAwGA1UdEwEB/wQCMAAwHwYDVR0jBBgwFoAU+Eo3\n5sST4LRrwS4dueIdGBZ5d7IwLAYIKwYBBQUHAQEEIDAeMBwGCCsGAQUFBzABhhBv\nY3NwLmV4YW1wbGUuY29tMAoGCCqGSM49BAMCA0kAMEYCIQDg94xY/+/VepESdvTT\nykCwiWOS2aCpjyryrKpwMKkR0AIhAPc/+ZEz4W10OENxC1t+NUTvS8JbEGOwulkZ\nz9yfaLuD\n-----END CERTIFICATE-----`\n\nconst certWithoutOCSPServer = `-----BEGIN CERTIFICATE-----\nMIIBUzCB+aADAgECAgIgADAKBggqhkjOPQQDAjASMRAwDgYDVQQDEwdUZXN0IENB\nMB4XDTIzMDEwMTEyMDAwMFoXDTIzMDIwMTEyMDAwMFowIDEeMBwGA1UEAxMVT0NT\nUCBUZXN0IENlcnRpZmljYXRlMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEih4j\n9uOjfiqifLwt1EkP4mG6Tz9LxgddEeXqsf23lUUIW1fyUg838uXXMKtDYoHdaVt/\nFKCJDIusKlnKt2FU9KMxMC8wDAYDVR0TAQH/BAIwADAfBgNVHSMEGDAWgBT4Sjfm\nxJPgtGvBLh254h0YFnl3sjAKBggqhkjOPQQDAgNJADBGAiEA3rWetLGblfSuNZKf\n5CpZxhj3A0BjEocEh+2P+nAgIdUCIQDIgptabR1qTLQaF2u0hJsEX2IKuIUvYWH3\n6Lb92+zIHg==\n-----END CERTIFICATE-----`\n\n// certKey is the private key for both certWithOCSPServer and\n// certWithoutOCSPServer.\nconst certKey = `-----BEGIN EC PRIVATE KEY-----\nMHcCAQEEINnVcgrSNh4HlThWlZpegq14M8G/p9NVDtdVjZrseUGLoAoGCCqGSM49\nAwEHoUQDQgAEih4j9uOjfiqifLwt1EkP4mG6Tz9LxgddEeXqsf23lUUIW1fyUg83\n8uXXMKtDYoHdaVt/FKCJDIusKlnKt2FU9A==\n-----END EC PRIVATE KEY-----`\n\n// caCert is the issuing certificate for certWithOCSPServer and\n// certWithoutOCSPServer.\nconst caCert = `-----BEGIN CERTIFICATE-----\nMIIBazCCARGgAwIBAgICEAAwCgYIKoZIzj0EAwIwEjEQMA4GA1UEAxMHVGVzdCBD\nQTAeFw0yMzAxMDExMjAwMDBaFw0yMzAyMDExMjAwMDBaMBIxEDAOBgNVBAMTB1Rl\nc3QgQ0EwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASdKexSor/aeazDM57UHhAX\nrCkJxUeF2BWf0lZYCRxc3f0GdrEsVvjJW8+/E06eAzDCGSdM/08Nvun1nb6AmAlt\no1cwVTAOBgNVHQ8BAf8EBAMCAQYwEwYDVR0lBAwwCgYIKwYBBQUHAwkwDwYDVR0T\nAQH/BAUwAwEB/zAdBgNVHQ4EFgQU+Eo35sST4LRrwS4dueIdGBZ5d7IwCgYIKoZI\nzj0EAwIDSAAwRQIgGbA39+kETTB/YMLBFoC2fpZe1cDWfFB7TUdfINUqdH4CIQCR\nByUFC8A+hRNkK5YNH78bgjnKk/88zUQF5ONy4oPGdQ==\n-----END CERTIFICATE-----`\n\nconst caKey = `-----BEGIN EC PRIVATE KEY-----\nMHcCAQEEIDJ59ptjq3MzILH4zn5IKoH1sYn+zrUeq2kD8+DD2x+OoAoGCCqGSM49\nAwEHoUQDQgAEnSnsUqK/2nmswzOe1B4QF6wpCcVHhdgVn9JWWAkcXN39BnaxLFb4\nyVvPvxNOngMwwhknTP9PDb7p9Z2+gJgJbQ==\n-----END EC PRIVATE KEY-----`\n\nfunc TestStapleOCSP(t *testing.T) {\n\tctx := context.Background()\n\tstorage := &FileStorage{Path: t.TempDir()}\n\n\tt.Run(\"disabled\", func(t *testing.T) {\n\t\tcert := mustMakeCertificate(t, certWithOCSPServer, certKey)\n\t\tconfig := OCSPConfig{DisableStapling: true}\n\t\terr := stapleOCSP(ctx, config, storage, &cert, nil)\n\t\tif err != nil {\n\t\t\tt.Error(\"unexpected error:\", err)\n\t\t} else if cert.Certificate.OCSPStaple != nil {\n\t\t\tt.Error(\"unexpected OCSP staple\")\n\t\t}\n\t})\n\tt.Run(\"no OCSP server\", func(t *testing.T) {\n\t\tcert := mustMakeCertificate(t, certWithoutOCSPServer, certKey)\n\t\terr := stapleOCSP(ctx, OCSPConfig{}, storage, &cert, nil)\n\t\tif !errors.Is(err, ErrNoOCSPServerSpecified) {\n\t\t\tt.Error(\"expected ErrNoOCSPServerSpecified in error\", err)\n\t\t}\n\t})\n\n\t// Start an OCSP responder test server.\n\tresponses := make(map[string][]byte)\n\tresponder := startOCSPResponder(t, responses)\n\tt.Cleanup(responder.Close)\n\n\tca := mustMakeCertificate(t, caCert, caKey)\n\n\t// The certWithOCSPServer certificate has a bogus ocsp.example.com endpoint.\n\t// Use the ResponderOverrides option to point to the test server instead.\n\tconfig := OCSPConfig{\n\t\tResponderOverrides: map[string]string{\n\t\t\t\"ocsp.example.com\": responder.URL,\n\t\t},\n\t}\n\n\tt.Run(\"ok\", func(t *testing.T) {\n\t\tcert := mustMakeCertificate(t, certWithOCSPServer, certKey)\n\t\ttpl := ocsp.Response{\n\t\t\tStatus:       ocsp.Good,\n\t\t\tSerialNumber: cert.Leaf.SerialNumber,\n\t\t}\n\t\tr, err := ocsp.CreateResponse(\n\t\t\tca.Leaf, ca.Leaf, tpl, ca.PrivateKey.(crypto.Signer))\n\t\tif err != nil {\n\t\t\tt.Fatal(\"couldn't create OCSP response\", err)\n\t\t}\n\t\tresponses[cert.Leaf.SerialNumber.String()] = r\n\n\t\tbundle := []byte(certWithOCSPServer + \"\\n\" + caCert)\n\t\terr = stapleOCSP(ctx, config, storage, &cert, bundle)\n\t\tif err != nil {\n\t\t\tt.Error(\"unexpected error:\", err)\n\t\t} else if !bytes.Equal(cert.Certificate.OCSPStaple, r) {\n\t\t\tt.Error(\"expected OCSP response to be stapled to certificate\")\n\t\t}\n\t})\n\tt.Run(\"revoked\", func(t *testing.T) {\n\t\tcert := mustMakeCertificate(t, certWithOCSPServer, certKey)\n\t\ttpl := ocsp.Response{\n\t\t\tStatus:       ocsp.Revoked,\n\t\t\tSerialNumber: cert.Leaf.SerialNumber,\n\t\t}\n\t\tr, err := ocsp.CreateResponse(\n\t\t\tca.Leaf, ca.Leaf, tpl, ca.PrivateKey.(crypto.Signer))\n\t\tif err != nil {\n\t\t\tt.Fatal(\"couldn't create OCSP response\", err)\n\t\t}\n\t\tresponses[cert.Leaf.SerialNumber.String()] = r\n\n\t\tbundle := []byte(certWithOCSPServer + \"\\n\" + caCert)\n\t\terr = stapleOCSP(ctx, config, storage, &cert, bundle)\n\t\tif err != nil {\n\t\t\tt.Error(\"unexpected error:\", err)\n\t\t} else if cert.Certificate.OCSPStaple != nil {\n\t\t\tt.Error(\"revoked OCSP response should not be stapled\")\n\t\t}\n\t})\n\tt.Run(\"no issuing cert\", func(t *testing.T) {\n\t\tcert := mustMakeCertificate(t, certWithOCSPServer, certKey)\n\t\terr := stapleOCSP(ctx, config, storage, &cert, nil)\n\t\texpected := \"no OCSP stapling for [ocsp test certificate]: \" +\n\t\t\t\"no URL to issuing certificate\"\n\t\tif err == nil || err.Error() != expected {\n\t\t\tt.Errorf(\"expected error %q but got %q\", expected, err)\n\t\t}\n\t})\n}\n\nfunc mustMakeCertificate(t *testing.T, cert, key string) Certificate {\n\tt.Helper()\n\tc, err := makeCertificate([]byte(cert), []byte(key))\n\tif err != nil {\n\t\tt.Fatal(\"couldn't make certificate:\", err)\n\t}\n\treturn c\n}\n\nfunc startOCSPResponder(\n\tt *testing.T, responses map[string][]byte,\n) *httptest.Server {\n\th := func(w http.ResponseWriter, r *http.Request) {\n\t\tct := r.Header.Get(\"Content-Type\")\n\t\tif ct != \"application/ocsp-request\" {\n\t\t\tt.Errorf(\"unexpected request Content-Type %q\", ct)\n\t\t}\n\t\tb, _ := io.ReadAll(r.Body)\n\t\trequest, err := ocsp.ParseRequest(b)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", \"application/ocsp-response\")\n\t\tw.Write(responses[request.SerialNumber.String()])\n\t}\n\treturn httptest.NewServer(http.HandlerFunc(h))\n}\n"
        },
        {
          "name": "ratelimiter.go",
          "type": "blob",
          "size": 6.7001953125,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n)\n\n// NewRateLimiter returns a rate limiter that allows up to maxEvents\n// in a sliding window of size window. If maxEvents and window are\n// both 0, or if maxEvents is non-zero and window is 0, rate limiting\n// is disabled. This function panics if maxEvents is less than 0 or\n// if maxEvents is 0 and window is non-zero, which is considered to be\n// an invalid configuration, as it would never allow events.\nfunc NewRateLimiter(maxEvents int, window time.Duration) *RingBufferRateLimiter {\n\tif maxEvents < 0 {\n\t\tpanic(\"maxEvents cannot be less than zero\")\n\t}\n\tif maxEvents == 0 && window != 0 {\n\t\tpanic(\"NewRateLimiter: invalid configuration: maxEvents = 0 and window != 0 would not allow any events\")\n\t}\n\trbrl := &RingBufferRateLimiter{\n\t\twindow:  window,\n\t\tring:    make([]time.Time, maxEvents),\n\t\tstarted: make(chan struct{}),\n\t\tstopped: make(chan struct{}),\n\t\tticket:  make(chan struct{}),\n\t}\n\tgo rbrl.loop()\n\t<-rbrl.started // make sure loop is ready to receive before we return\n\treturn rbrl\n}\n\n// RingBufferRateLimiter uses a ring to enforce rate limits\n// consisting of a maximum number of events within a single\n// sliding window of a given duration. An empty value is\n// not valid; use NewRateLimiter to get one.\ntype RingBufferRateLimiter struct {\n\twindow  time.Duration\n\tring    []time.Time // maxEvents == len(ring)\n\tcursor  int         // always points to the oldest timestamp\n\tmu      sync.Mutex  // protects ring, cursor, and window\n\tstarted chan struct{}\n\tstopped chan struct{}\n\tticket  chan struct{}\n}\n\n// Stop cleans up r's scheduling goroutine.\nfunc (r *RingBufferRateLimiter) Stop() {\n\tclose(r.stopped)\n}\n\nfunc (r *RingBufferRateLimiter) loop() {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tbuf := make([]byte, stackTraceBufferSize)\n\t\t\tbuf = buf[:runtime.Stack(buf, false)]\n\t\t\tlog.Printf(\"panic: ring buffer rate limiter: %v\\n%s\", err, buf)\n\t\t}\n\t}()\n\n\tfor {\n\t\t// if we've been stopped, return\n\t\tselect {\n\t\tcase <-r.stopped:\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\tif len(r.ring) == 0 {\n\t\t\tif r.window == 0 {\n\t\t\t\t// rate limiting is disabled; always allow immediately\n\t\t\t\tr.permit()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tpanic(\"invalid configuration: maxEvents = 0 and window != 0 does not allow any events\")\n\t\t}\n\n\t\t// wait until next slot is available or until we've been stopped\n\t\tr.mu.Lock()\n\t\tthen := r.ring[r.cursor].Add(r.window)\n\t\tr.mu.Unlock()\n\t\twaitDuration := time.Until(then)\n\t\twaitTimer := time.NewTimer(waitDuration)\n\t\tselect {\n\t\tcase <-waitTimer.C:\n\t\t\tr.permit()\n\t\tcase <-r.stopped:\n\t\t\twaitTimer.Stop()\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// Allow returns true if the event is allowed to\n// happen right now. It does not wait. If the event\n// is allowed, a ticket is claimed.\nfunc (r *RingBufferRateLimiter) Allow() bool {\n\tselect {\n\tcase <-r.ticket:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// Wait blocks until the event is allowed to occur. It returns an\n// error if the context is cancelled.\nfunc (r *RingBufferRateLimiter) Wait(ctx context.Context) error {\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn context.Canceled\n\tcase <-r.ticket:\n\t\treturn nil\n\t}\n}\n\n// MaxEvents returns the maximum number of events that\n// are allowed within the sliding window.\nfunc (r *RingBufferRateLimiter) MaxEvents() int {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\treturn len(r.ring)\n}\n\n// SetMaxEvents changes the maximum number of events that are\n// allowed in the sliding window. If the new limit is lower,\n// the oldest events will be forgotten. If the new limit is\n// higher, the window will suddenly have capacity for new\n// reservations. It panics if maxEvents is 0 and window size\n// is not zero; if setting both the events limit and the\n// window size to 0, call SetWindow() first.\nfunc (r *RingBufferRateLimiter) SetMaxEvents(maxEvents int) {\n\tnewRing := make([]time.Time, maxEvents)\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif r.window != 0 && maxEvents == 0 {\n\t\tpanic(\"SetMaxEvents: invalid configuration: maxEvents = 0 and window != 0 would not allow any events\")\n\t}\n\n\t// only make the change if the new limit is different\n\tif maxEvents == len(r.ring) {\n\t\treturn\n\t}\n\n\t// the new ring may be smaller; fast-forward to the\n\t// oldest timestamp that will be kept in the new\n\t// ring so the oldest ones are forgotten and the\n\t// newest ones will be remembered\n\tsizeDiff := len(r.ring) - maxEvents\n\tfor i := 0; i < sizeDiff; i++ {\n\t\tr.advance()\n\t}\n\n\tif len(r.ring) > 0 {\n\t\t// copy timestamps into the new ring until we\n\t\t// have either copied all of them or have reached\n\t\t// the capacity of the new ring\n\t\tstartCursor := r.cursor\n\t\tfor i := 0; i < len(newRing); i++ {\n\t\t\tnewRing[i] = r.ring[r.cursor]\n\t\t\tr.advance()\n\t\t\tif r.cursor == startCursor {\n\t\t\t\t// new ring is larger than old one;\n\t\t\t\t// \"we've come full circle\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tr.ring = newRing\n\tr.cursor = 0\n}\n\n// Window returns the size of the sliding window.\nfunc (r *RingBufferRateLimiter) Window() time.Duration {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\treturn r.window\n}\n\n// SetWindow changes r's sliding window duration to window.\n// Goroutines that are already blocked on a call to Wait()\n// will not be affected. It panics if window is non-zero\n// but the max event limit is 0.\nfunc (r *RingBufferRateLimiter) SetWindow(window time.Duration) {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tif window != 0 && len(r.ring) == 0 {\n\t\tpanic(\"SetWindow: invalid configuration: maxEvents = 0 and window != 0 would not allow any events\")\n\t}\n\tr.window = window\n}\n\n// permit allows one event through the throttle. This method\n// blocks until a goroutine is waiting for a ticket or until\n// the rate limiter is stopped.\nfunc (r *RingBufferRateLimiter) permit() {\n\tfor {\n\t\tselect {\n\t\tcase r.started <- struct{}{}:\n\t\t\t// notify parent goroutine that we've started; should\n\t\t\t// only happen once, before constructor returns\n\t\t\tcontinue\n\t\tcase <-r.stopped:\n\t\t\treturn\n\t\tcase r.ticket <- struct{}{}:\n\t\t\tr.mu.Lock()\n\t\t\tdefer r.mu.Unlock()\n\t\t\tif len(r.ring) > 0 {\n\t\t\t\tr.ring[r.cursor] = time.Now()\n\t\t\t\tr.advance()\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// advance moves the cursor to the next position.\n// It is NOT safe for concurrent use, so it must\n// be called inside a lock on r.mu.\nfunc (r *RingBufferRateLimiter) advance() {\n\tr.cursor++\n\tif r.cursor >= len(r.ring) {\n\t\tr.cursor = 0\n\t}\n}\n"
        },
        {
          "name": "solvers.go",
          "type": "blob",
          "size": 27.41015625,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"path\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/libdns/libdns\"\n\t\"github.com/mholt/acmez/v3\"\n\t\"github.com/mholt/acmez/v3/acme\"\n\t\"github.com/miekg/dns\"\n\t\"go.uber.org/zap\"\n)\n\n// httpSolver solves the HTTP challenge. It must be\n// associated with a config and an address to use\n// for solving the challenge. If multiple httpSolvers\n// are initialized concurrently, the first one to\n// begin will start the server, and the last one to\n// finish will stop the server. This solver must be\n// wrapped by a distributedSolver to work properly,\n// because the only way the HTTP challenge handler\n// can access the keyAuth material is by loading it\n// from storage, which is done by distributedSolver.\ntype httpSolver struct {\n\tclosed  int32 // accessed atomically\n\thandler http.Handler\n\taddress string\n}\n\n// Present starts an HTTP server if none is already listening on s.address.\nfunc (s *httpSolver) Present(ctx context.Context, _ acme.Challenge) error {\n\tsolversMu.Lock()\n\tdefer solversMu.Unlock()\n\n\tsi := getSolverInfo(s.address)\n\tsi.count++\n\tif si.listener != nil {\n\t\treturn nil // already be served by us\n\t}\n\n\t// notice the unusual error handling here; we\n\t// only continue to start a challenge server if\n\t// we got a listener; in all other cases return\n\tln, err := robustTryListen(s.address)\n\tif ln == nil {\n\t\treturn err\n\t}\n\n\t// successfully bound socket, so save listener and start key auth HTTP server\n\tsi.listener = ln\n\tgo s.serve(ctx, si)\n\n\treturn nil\n}\n\n// serve is an HTTP server that serves only HTTP challenge responses.\nfunc (s *httpSolver) serve(ctx context.Context, si *solverInfo) {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tbuf := make([]byte, stackTraceBufferSize)\n\t\t\tbuf = buf[:runtime.Stack(buf, false)]\n\t\t\tlog.Printf(\"panic: http solver server: %v\\n%s\", err, buf)\n\t\t}\n\t}()\n\tdefer close(si.done)\n\thttpServer := &http.Server{\n\t\tHandler:     s.handler,\n\t\tBaseContext: func(listener net.Listener) context.Context { return ctx },\n\t}\n\thttpServer.SetKeepAlivesEnabled(false)\n\terr := httpServer.Serve(si.listener)\n\tif err != nil && atomic.LoadInt32(&s.closed) != 1 {\n\t\tlog.Printf(\"[ERROR] key auth HTTP server: %v\", err)\n\t}\n}\n\n// CleanUp cleans up the HTTP server if it is the last one to finish.\nfunc (s *httpSolver) CleanUp(_ context.Context, _ acme.Challenge) error {\n\tsolversMu.Lock()\n\tdefer solversMu.Unlock()\n\tsi := getSolverInfo(s.address)\n\tsi.count--\n\tif si.count == 0 {\n\t\t// last one out turns off the lights\n\t\tatomic.StoreInt32(&s.closed, 1)\n\t\tif si.listener != nil {\n\t\t\tsi.listener.Close()\n\t\t\t<-si.done\n\t\t}\n\t\tdelete(solvers, s.address)\n\t}\n\treturn nil\n}\n\n// tlsALPNSolver is a type that can solve TLS-ALPN challenges.\n// It must have an associated config and address on which to\n// serve the challenge.\ntype tlsALPNSolver struct {\n\tconfig  *Config\n\taddress string\n}\n\n// Present adds the certificate to the certificate cache and, if\n// needed, starts a TLS server for answering TLS-ALPN challenges.\nfunc (s *tlsALPNSolver) Present(ctx context.Context, chal acme.Challenge) error {\n\t// we pre-generate the certificate for efficiency with multi-perspective\n\t// validation, so it only has to be done once (at least, by this instance;\n\t// distributed solving does not have that luxury, oh well) - update the\n\t// challenge data in memory to be the generated certificate\n\tcert, err := acmez.TLSALPN01ChallengeCert(chal)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tkey := challengeKey(chal)\n\tactiveChallengesMu.Lock()\n\tchalData := activeChallenges[key]\n\tchalData.data = cert\n\tactiveChallenges[key] = chalData\n\tactiveChallengesMu.Unlock()\n\n\t// the rest of this function increments the\n\t// challenge count for the solver at this\n\t// listener address, and if necessary, starts\n\t// a simple TLS server\n\n\tsolversMu.Lock()\n\tdefer solversMu.Unlock()\n\n\tsi := getSolverInfo(s.address)\n\tsi.count++\n\tif si.listener != nil {\n\t\treturn nil // already be served by us\n\t}\n\n\t// notice the unusual error handling here; we\n\t// only continue to start a challenge server if\n\t// we got a listener; in all other cases return\n\tln, err := robustTryListen(s.address)\n\tif ln == nil {\n\t\treturn err\n\t}\n\n\t// we were able to bind the socket, so make it into a TLS\n\t// listener, store it with the solverInfo, and start the\n\t// challenge server\n\n\tsi.listener = tls.NewListener(ln, s.config.TLSConfig())\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tbuf := make([]byte, stackTraceBufferSize)\n\t\t\t\tbuf = buf[:runtime.Stack(buf, false)]\n\t\t\t\tlog.Printf(\"panic: tls-alpn solver server: %v\\n%s\", err, buf)\n\t\t\t}\n\t\t}()\n\t\tdefer close(si.done)\n\t\tfor {\n\t\t\tconn, err := si.listener.Accept()\n\t\t\tif err != nil {\n\t\t\t\tif atomic.LoadInt32(&si.closed) == 1 {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlog.Printf(\"[ERROR] TLS-ALPN challenge server: accept: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tgo s.handleConn(conn)\n\t\t}\n\t}()\n\n\treturn nil\n}\n\n// handleConn completes the TLS handshake and then closes conn.\nfunc (*tlsALPNSolver) handleConn(conn net.Conn) {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tbuf := make([]byte, stackTraceBufferSize)\n\t\t\tbuf = buf[:runtime.Stack(buf, false)]\n\t\t\tlog.Printf(\"panic: tls-alpn solver handler: %v\\n%s\", err, buf)\n\t\t}\n\t}()\n\tdefer conn.Close()\n\ttlsConn, ok := conn.(*tls.Conn)\n\tif !ok {\n\t\tlog.Printf(\"[ERROR] TLS-ALPN challenge server: expected tls.Conn but got %T: %#v\", conn, conn)\n\t\treturn\n\t}\n\terr := tlsConn.Handshake()\n\tif err != nil {\n\t\tlog.Printf(\"[ERROR] TLS-ALPN challenge server: handshake: %v\", err)\n\t\treturn\n\t}\n}\n\n// CleanUp removes the challenge certificate from the cache, and if\n// it is the last one to finish, stops the TLS server.\nfunc (s *tlsALPNSolver) CleanUp(_ context.Context, chal acme.Challenge) error {\n\tsolversMu.Lock()\n\tdefer solversMu.Unlock()\n\tsi := getSolverInfo(s.address)\n\tsi.count--\n\tif si.count == 0 {\n\t\t// last one out turns off the lights\n\t\tatomic.StoreInt32(&si.closed, 1)\n\t\tif si.listener != nil {\n\t\t\tsi.listener.Close()\n\t\t\t<-si.done\n\t\t}\n\t\tdelete(solvers, s.address)\n\t}\n\treturn nil\n}\n\n// DNS01Solver is a type that makes libdns providers usable as ACME dns-01\n// challenge solvers. See https://github.com/libdns/libdns\n//\n// Note that challenges may be solved concurrently by some clients (such as\n// acmez, which CertMagic uses), meaning that multiple TXT records may be\n// created in a DNS zone simultaneously, and in some cases distinct TXT records\n// may have the same name. For example, solving challenges for both example.com\n// and *.example.com create a TXT record named _acme_challenge.example.com,\n// but with different tokens as their values. This solver distinguishes\n// between different records with the same name by looking at their values.\n// DNS provider APIs and implementations of the libdns interfaces must also\n// support multiple same-named TXT records.\ntype DNS01Solver struct {\n\tDNSManager\n}\n\n// Present creates the DNS TXT record for the given ACME challenge.\nfunc (s *DNS01Solver) Present(ctx context.Context, challenge acme.Challenge) error {\n\tdnsName := challenge.DNS01TXTRecordName()\n\tif s.OverrideDomain != \"\" {\n\t\tdnsName = s.OverrideDomain\n\t}\n\tkeyAuth := challenge.DNS01KeyAuthorization()\n\n\tzrec, err := s.DNSManager.createRecord(ctx, dnsName, \"TXT\", keyAuth)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// remember the record and zone we got so we can clean up more efficiently\n\ts.saveDNSPresentMemory(dnsPresentMemory{\n\t\tdnsName: dnsName,\n\t\tzoneRec: zrec,\n\t})\n\n\treturn nil\n}\n\n// Wait blocks until the TXT record created in Present() appears in\n// authoritative lookups, i.e. until it has propagated, or until\n// timeout, whichever is first.\nfunc (s *DNS01Solver) Wait(ctx context.Context, challenge acme.Challenge) error {\n\t// prepare for the checks by determining what to look for\n\tdnsName := challenge.DNS01TXTRecordName()\n\tif s.OverrideDomain != \"\" {\n\t\tdnsName = s.OverrideDomain\n\t}\n\tkeyAuth := challenge.DNS01KeyAuthorization()\n\n\t// wait for the record to propagate\n\tmemory, err := s.getDNSPresentMemory(dnsName, \"TXT\", keyAuth)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn s.DNSManager.wait(ctx, memory.zoneRec)\n}\n\n// CleanUp deletes the DNS TXT record created in Present().\n//\n// We ignore the context because cleanup is often/likely performed after\n// a context cancellation, and properly-implemented DNS providers should\n// honor cancellation, which would result in cleanup being aborted.\n// Cleanup must always occur.\nfunc (s *DNS01Solver) CleanUp(ctx context.Context, challenge acme.Challenge) error {\n\tdnsName := challenge.DNS01TXTRecordName()\n\tif s.OverrideDomain != \"\" {\n\t\tdnsName = s.OverrideDomain\n\t}\n\tkeyAuth := challenge.DNS01KeyAuthorization()\n\n\t// always forget about the record so we don't leak memory\n\tdefer s.deleteDNSPresentMemory(dnsName, keyAuth)\n\n\t// recall the record we created and zone we looked up\n\tmemory, err := s.getDNSPresentMemory(dnsName, \"TXT\", keyAuth)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := s.DNSManager.cleanUpRecord(ctx, memory.zoneRec); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// DNSManager is a type that makes libdns providers usable for performing\n// DNS verification. See https://github.com/libdns/libdns\n//\n// Note that records may be manipulated concurrently by some clients (such as\n// acmez, which CertMagic uses), meaning that multiple records may be created\n// in a DNS zone simultaneously, and in some cases distinct records of the same\n// type may have the same name. For example, solving ACME challenges for both example.com\n// and *.example.com create a TXT record named _acme_challenge.example.com,\n// but with different tokens as their values. This solver distinguishes between\n// different records with the same type and name by looking at their values.\ntype DNSManager struct {\n\t// The implementation that interacts with the DNS\n\t// provider to set or delete records. (REQUIRED)\n\tDNSProvider DNSProvider\n\n\t// The TTL for the temporary challenge records.\n\tTTL time.Duration\n\n\t// How long to wait before starting propagation checks.\n\t// Default: 0 (no wait).\n\tPropagationDelay time.Duration\n\n\t// Maximum time to wait for temporary DNS record to appear.\n\t// Set to -1 to disable propagation checks.\n\t// Default: 2 minutes.\n\tPropagationTimeout time.Duration\n\n\t// Preferred DNS resolver(s) to use when doing DNS lookups.\n\tResolvers []string\n\n\t// Override the domain to set the TXT record on. This is\n\t// to delegate the challenge to a different domain. Note\n\t// that the solver doesn't follow CNAME/NS record.\n\tOverrideDomain string\n\n\t// An optional logger.\n\tLogger *zap.Logger\n\n\t// Remember DNS records while challenges are active; i.e.\n\t// records we have presented and not yet cleaned up.\n\t// This lets us clean them up quickly and efficiently.\n\t// Keyed by domain name (specifically the ACME DNS name).\n\t// The map value is a slice because there can be multiple\n\t// concurrent challenges for different domains that have\n\t// the same ACME DNS name, for example: example.com and\n\t// *.example.com. We distinguish individual memories by\n\t// the value of their TXT records, which should contain\n\t// unique challenge tokens.\n\t// See https://github.com/caddyserver/caddy/issues/3474.\n\trecords   map[string][]dnsPresentMemory\n\trecordsMu sync.Mutex\n}\n\nfunc (m *DNSManager) createRecord(ctx context.Context, dnsName, recordType, recordValue string) (zoneRecord, error) {\n\tlogger := m.logger()\n\n\tzone, err := findZoneByFQDN(logger, dnsName, recursiveNameservers(m.Resolvers))\n\tif err != nil {\n\t\treturn zoneRecord{}, fmt.Errorf(\"could not determine zone for domain %q: %v\", dnsName, err)\n\t}\n\trec := libdns.Record{\n\t\tType:  recordType,\n\t\tName:  libdns.RelativeName(dnsName+\".\", zone),\n\t\tValue: recordValue,\n\t\tTTL:   m.TTL,\n\t}\n\n\tlogger.Debug(\"creating DNS record\",\n\t\tzap.String(\"dns_name\", dnsName),\n\t\tzap.String(\"zone\", zone),\n\t\tzap.String(\"record_name\", rec.Name),\n\t\tzap.String(\"record_type\", rec.Type),\n\t\tzap.String(\"record_value\", rec.Value),\n\t\tzap.Duration(\"record_ttl\", rec.TTL))\n\n\tresults, err := m.DNSProvider.AppendRecords(ctx, zone, []libdns.Record{rec})\n\tif err != nil {\n\t\treturn zoneRecord{}, fmt.Errorf(\"adding temporary record for zone %q: %w\", zone, err)\n\t}\n\tif len(results) != 1 {\n\t\treturn zoneRecord{}, fmt.Errorf(\"expected one record, got %d: %v\", len(results), results)\n\t}\n\n\treturn zoneRecord{zone, results[0]}, nil\n}\n\n// wait blocks until the TXT record created in Present() appears in\n// authoritative lookups, i.e. until it has propagated, or until\n// timeout, whichever is first.\nfunc (m *DNSManager) wait(ctx context.Context, zrec zoneRecord) error {\n\tlogger := m.logger()\n\n\t// if configured to, pause before doing propagation checks\n\t// (even if they are disabled, the wait might be desirable on its own)\n\tif m.PropagationDelay > 0 {\n\t\tselect {\n\t\tcase <-time.After(m.PropagationDelay):\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\t}\n\t}\n\n\t// skip propagation checks if configured to do so\n\tif m.PropagationTimeout == -1 {\n\t\treturn nil\n\t}\n\n\t// timings\n\ttimeout := m.PropagationTimeout\n\tif timeout == 0 {\n\t\ttimeout = defaultDNSPropagationTimeout\n\t}\n\tconst interval = 2 * time.Second\n\n\t// how we'll do the checks\n\tcheckAuthoritativeServers := len(m.Resolvers) == 0\n\tresolvers := recursiveNameservers(m.Resolvers)\n\n\trecType := dns.TypeTXT\n\tif zrec.record.Type == \"CNAME\" {\n\t\trecType = dns.TypeCNAME\n\t}\n\n\tabsName := libdns.AbsoluteName(zrec.record.Name, zrec.zone)\n\n\tvar err error\n\tstart := time.Now()\n\tfor time.Since(start) < timeout {\n\t\tselect {\n\t\tcase <-time.After(interval):\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\tlogger.Debug(\"checking DNS propagation\",\n\t\t\tzap.String(\"fqdn\", absName),\n\t\t\tzap.String(\"record_type\", zrec.record.Type),\n\t\t\tzap.String(\"expected_value\", zrec.record.Value),\n\t\t\tzap.Strings(\"resolvers\", resolvers))\n\n\t\tvar ready bool\n\t\tready, err = checkDNSPropagation(logger, absName, recType, zrec.record.Value, checkAuthoritativeServers, resolvers)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"checking DNS propagation of %q (relative=%s zone=%s resolvers=%v): %w\", absName, zrec.record.Name, zrec.zone, resolvers, err)\n\t\t}\n\t\tif ready {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"timed out waiting for record to fully propagate; verify DNS provider configuration is correct - last error: %v\", err)\n}\n\ntype zoneRecord struct {\n\tzone   string\n\trecord libdns.Record\n}\n\n// CleanUp deletes the DNS TXT record created in Present().\n//\n// We ignore the context because cleanup is often/likely performed after\n// a context cancellation, and properly-implemented DNS providers should\n// honor cancellation, which would result in cleanup being aborted.\n// Cleanup must always occur.\nfunc (m *DNSManager) cleanUpRecord(_ context.Context, zrec zoneRecord) error {\n\tlogger := m.logger()\n\n\t// clean up the record - use a different context though, since\n\t// one common reason cleanup is performed is because a context\n\t// was canceled, and if so, any HTTP requests by this provider\n\t// should fail if the provider is properly implemented\n\t// (see issue #200)\n\ttimeout := m.PropagationTimeout\n\tif timeout <= 0 {\n\t\ttimeout = defaultDNSPropagationTimeout\n\t}\n\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\tdefer cancel()\n\n\tlogger.Debug(\"deleting DNS record\",\n\t\tzap.String(\"zone\", zrec.zone),\n\t\tzap.String(\"record_id\", zrec.record.ID),\n\t\tzap.String(\"record_name\", zrec.record.Name),\n\t\tzap.String(\"record_type\", zrec.record.Type),\n\t\tzap.String(\"record_value\", zrec.record.Value))\n\n\t_, err := m.DNSProvider.DeleteRecords(ctx, zrec.zone, []libdns.Record{zrec.record})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"deleting temporary record for name %q in zone %q: %w\", zrec.zone, zrec.record, err)\n\t}\n\treturn nil\n}\n\nfunc (m *DNSManager) logger() *zap.Logger {\n\tlogger := m.Logger\n\tif logger == nil {\n\t\tlogger = zap.NewNop()\n\t}\n\treturn logger.Named(\"dns_manager\")\n}\n\nconst defaultDNSPropagationTimeout = 2 * time.Minute\n\n// dnsPresentMemory associates a created DNS record with its zone\n// (since libdns Records are zone-relative and do not include zone).\ntype dnsPresentMemory struct {\n\tdnsName string\n\tzoneRec zoneRecord\n}\n\nfunc (s *DNSManager) saveDNSPresentMemory(mem dnsPresentMemory) {\n\ts.recordsMu.Lock()\n\tif s.records == nil {\n\t\ts.records = make(map[string][]dnsPresentMemory)\n\t}\n\ts.records[mem.dnsName] = append(s.records[mem.dnsName], mem)\n\ts.recordsMu.Unlock()\n}\n\nfunc (s *DNSManager) getDNSPresentMemory(dnsName, recType, value string) (dnsPresentMemory, error) {\n\ts.recordsMu.Lock()\n\tdefer s.recordsMu.Unlock()\n\n\tvar memory dnsPresentMemory\n\tvar found bool\n\tfor _, mem := range s.records[dnsName] {\n\t\tif mem.zoneRec.record.Type == recType && mem.zoneRec.record.Value == value {\n\t\t\tmemory = mem\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\treturn dnsPresentMemory{}, fmt.Errorf(\"no memory of presenting a DNS record for %q (usually OK if presenting also failed)\", dnsName)\n\t}\n\n\treturn memory, nil\n}\n\nfunc (s *DNSManager) deleteDNSPresentMemory(dnsName, keyAuth string) {\n\ts.recordsMu.Lock()\n\tdefer s.recordsMu.Unlock()\n\n\tfor i, mem := range s.records[dnsName] {\n\t\tif mem.zoneRec.record.Value == keyAuth {\n\t\t\ts.records[dnsName] = append(s.records[dnsName][:i], s.records[dnsName][i+1:]...)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// DNSProvider defines the set of operations required for\n// ACME challenges or other sorts of domain verification.\n// A DNS provider must be able to append and delete records\n// in order to solve ACME challenges. Find one you can use\n// at https://github.com/libdns. If your provider isn't\n// implemented yet, feel free to contribute!\ntype DNSProvider interface {\n\tlibdns.RecordAppender\n\tlibdns.RecordDeleter\n}\n\n// distributedSolver allows the ACME HTTP-01 and TLS-ALPN challenges\n// to be solved by an instance other than the one which initiated it.\n// This is useful behind load balancers or in other cluster/fleet\n// configurations. The only requirement is that the instance which\n// initiates the challenge shares the same storage and locker with\n// the others in the cluster. The storage backing the certificate\n// cache in distributedSolver.config is crucial.\n//\n// Obviously, the instance which completes the challenge must be\n// serving on the HTTPChallengePort for the HTTP-01 challenge or the\n// TLSALPNChallengePort for the TLS-ALPN-01 challenge (or have all\n// the packets port-forwarded) to receive and handle the request. The\n// server which receives the challenge must handle it by checking to\n// see if the challenge token exists in storage, and if so, decode it\n// and use it to serve up the correct response. HTTPChallengeHandler\n// in this package as well as the GetCertificate method implemented\n// by a Config support and even require this behavior.\n//\n// In short: the only two requirements for cluster operation are\n// sharing sync and storage, and using the facilities provided by\n// this package for solving the challenges.\ntype distributedSolver struct {\n\t// The storage backing the distributed solver. It must be\n\t// the same storage configuration as what is solving the\n\t// challenge in order to be effective.\n\tstorage Storage\n\n\t// The storage key prefix, associated with the issuer\n\t// that is solving the challenge.\n\tstorageKeyIssuerPrefix string\n\n\t// Since the distributedSolver is only a\n\t// wrapper over an actual solver, place\n\t// the actual solver here.\n\tsolver acmez.Solver\n}\n\n// Present invokes the underlying solver's Present method\n// and also stores domain, token, and keyAuth to the storage\n// backing the certificate cache of dhs.acmeIssuer.\nfunc (dhs distributedSolver) Present(ctx context.Context, chal acme.Challenge) error {\n\tinfoBytes, err := json.Marshal(chal)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = dhs.storage.Store(ctx, dhs.challengeTokensKey(challengeKey(chal)), infoBytes)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = dhs.solver.Present(ctx, chal)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"presenting with embedded solver: %v\", err)\n\t}\n\treturn nil\n}\n\n// Wait wraps the underlying solver's Wait() method, if any. Implements acmez.Waiter.\nfunc (dhs distributedSolver) Wait(ctx context.Context, challenge acme.Challenge) error {\n\tif waiter, ok := dhs.solver.(acmez.Waiter); ok {\n\t\treturn waiter.Wait(ctx, challenge)\n\t}\n\treturn nil\n}\n\n// CleanUp invokes the underlying solver's CleanUp method\n// and also cleans up any assets saved to storage.\nfunc (dhs distributedSolver) CleanUp(ctx context.Context, chal acme.Challenge) error {\n\terr := dhs.storage.Delete(ctx, dhs.challengeTokensKey(challengeKey(chal)))\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = dhs.solver.CleanUp(ctx, chal)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"cleaning up embedded provider: %v\", err)\n\t}\n\treturn nil\n}\n\n// challengeTokensPrefix returns the key prefix for challenge info.\nfunc (dhs distributedSolver) challengeTokensPrefix() string {\n\treturn path.Join(dhs.storageKeyIssuerPrefix, \"challenge_tokens\")\n}\n\n// challengeTokensKey returns the key to use to store and access\n// challenge info for domain.\nfunc (dhs distributedSolver) challengeTokensKey(domain string) string {\n\treturn path.Join(dhs.challengeTokensPrefix(), StorageKeys.Safe(domain)+\".json\")\n}\n\n// solverInfo associates a listener with the\n// number of challenges currently using it.\ntype solverInfo struct {\n\tclosed   int32 // accessed atomically\n\tcount    int\n\tlistener net.Listener\n\tdone     chan struct{} // used to signal when our own solver server is done\n}\n\n// getSolverInfo gets a valid solverInfo struct for address.\nfunc getSolverInfo(address string) *solverInfo {\n\tsi, ok := solvers[address]\n\tif !ok {\n\t\tsi = &solverInfo{done: make(chan struct{})}\n\t\tsolvers[address] = si\n\t}\n\treturn si\n}\n\n// robustTryListen calls net.Listen for a TCP socket at addr.\n// This function may return both a nil listener and a nil error!\n// If it was able to bind the socket, it returns the listener\n// and no error. If it wasn't able to bind the socket because\n// the socket is already in use, then it returns a nil listener\n// and nil error. If it had any other error, it returns the\n// error. The intended error handling logic for this function\n// is to proceed if the returned listener is not nil; otherwise\n// return err (which may also be nil). In other words, this\n// function ignores errors if the socket is already in use,\n// which is useful for our challenge servers, where we assume\n// that whatever is already listening can solve the challenges.\nfunc robustTryListen(addr string) (net.Listener, error) {\n\tvar listenErr error\n\tfor i := 0; i < 2; i++ {\n\t\t// doesn't hurt to sleep briefly before the second\n\t\t// attempt in case the OS has timing issues\n\t\tif i > 0 {\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t}\n\n\t\t// if we can bind the socket right away, great!\n\t\tvar ln net.Listener\n\t\tln, listenErr = net.Listen(\"tcp\", addr)\n\t\tif listenErr == nil {\n\t\t\treturn ln, nil\n\t\t}\n\n\t\t// if it failed just because the socket is already in use, we\n\t\t// have no choice but to assume that whatever is using the socket\n\t\t// can answer the challenge already, so we ignore the error\n\t\tconnectErr := dialTCPSocket(addr)\n\t\tif connectErr == nil {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\t// Hmm, we couldn't connect to the socket, so something else must\n\t\t// be wrong, right? wrong!! Apparently if a port is bound by another\n\t\t// listener with a specific host, i.e. 'x:1234', we cannot bind to\n\t\t// ':1234' -- it is considered a conflict, but 'y:1234' is not.\n\t\t// I guess we need to assume the conflicting listener is properly\n\t\t// configured and continue. But we should tell the user to specify\n\t\t// the correct ListenHost to avoid conflict or at least so we can\n\t\t// know that the user is intentional about that port and hopefully\n\t\t// has an ACME solver on it.\n\t\t//\n\t\t// History:\n\t\t// https://caddy.community/t/caddy-retry-error/7317\n\t\t// https://caddy.community/t/v2-upgrade-to-caddy2-failing-with-errors/7423\n\t\t// https://github.com/caddyserver/certmagic/issues/250\n\t\tif strings.Contains(listenErr.Error(), \"address already in use\") ||\n\t\t\tstrings.Contains(listenErr.Error(), \"one usage of each socket address\") {\n\t\t\tlog.Printf(\"[WARNING] %v - be sure to set the ACMEIssuer.ListenHost field; assuming conflicting listener is correctly configured and continuing\", listenErr)\n\t\t\treturn nil, nil\n\t\t}\n\t}\n\treturn nil, fmt.Errorf(\"could not start listener for challenge server at %s: %v\", addr, listenErr)\n}\n\n// dialTCPSocket connects to a TCP address just for the sake of\n// seeing if it is open. It returns a nil error if a TCP connection\n// can successfully be made to addr within a short timeout.\nfunc dialTCPSocket(addr string) error {\n\tconn, err := net.DialTimeout(\"tcp\", addr, 250*time.Millisecond)\n\tif err == nil {\n\t\tconn.Close()\n\t}\n\treturn err\n}\n\n// GetACMEChallenge returns an active ACME challenge for the given identifier,\n// or false if no active challenge for that identifier is known.\nfunc GetACMEChallenge(identifier string) (Challenge, bool) {\n\tactiveChallengesMu.Lock()\n\tchalData, ok := activeChallenges[identifier]\n\tactiveChallengesMu.Unlock()\n\treturn chalData, ok\n}\n\n// The active challenge solvers, keyed by listener address,\n// and protected by a mutex. Note that the creation of\n// solver listeners and the incrementing of their counts\n// are atomic operations guarded by this mutex.\nvar (\n\tsolvers   = make(map[string]*solverInfo)\n\tsolversMu sync.Mutex\n)\n\n// activeChallenges holds information about all known, currently-active\n// ACME challenges, keyed by identifier. CertMagic guarantees that\n// challenges for the same identifier do not overlap, by its locking\n// mechanisms; thus if a challenge comes in for a certain identifier,\n// we can be confident that if this process initiated the challenge,\n// the correct information to solve it is in this map. (It may have\n// alternatively been initiated by another instance in a cluster, in\n// which case the distributed solver will take care of that.)\nvar (\n\tactiveChallenges   = make(map[string]Challenge)\n\tactiveChallengesMu sync.Mutex\n)\n\n// Challenge is an ACME challenge, but optionally paired with\n// data that can make it easier or more efficient to solve.\ntype Challenge struct {\n\tacme.Challenge\n\tdata any\n}\n\n// challengeKey returns the map key for a given challenge; it is the identifier\n// unless it is an IP address using the TLS-ALPN challenge.\nfunc challengeKey(chal acme.Challenge) string {\n\tif chal.Type == acme.ChallengeTypeTLSALPN01 && chal.Identifier.Type == \"ip\" {\n\t\treversed, err := dns.ReverseAddr(chal.Identifier.Value)\n\t\tif err == nil {\n\t\t\treturn reversed[:len(reversed)-1] // strip off '.'\n\t\t}\n\t}\n\treturn chal.Identifier.Value\n}\n\n// solverWrapper should be used to wrap all challenge solvers so that\n// we can add the challenge info to memory; this makes challenges globally\n// solvable by a single HTTP or TLS server even if multiple servers with\n// different configurations/scopes need to get certificates.\ntype solverWrapper struct{ acmez.Solver }\n\nfunc (sw solverWrapper) Present(ctx context.Context, chal acme.Challenge) error {\n\tactiveChallengesMu.Lock()\n\tactiveChallenges[challengeKey(chal)] = Challenge{Challenge: chal}\n\tactiveChallengesMu.Unlock()\n\treturn sw.Solver.Present(ctx, chal)\n}\n\nfunc (sw solverWrapper) Wait(ctx context.Context, chal acme.Challenge) error {\n\tif waiter, ok := sw.Solver.(acmez.Waiter); ok {\n\t\treturn waiter.Wait(ctx, chal)\n\t}\n\treturn nil\n}\n\nfunc (sw solverWrapper) CleanUp(ctx context.Context, chal acme.Challenge) error {\n\tactiveChallengesMu.Lock()\n\tdelete(activeChallenges, challengeKey(chal))\n\tactiveChallengesMu.Unlock()\n\treturn sw.Solver.CleanUp(ctx, chal)\n}\n\n// Interface guards\nvar (\n\t_ acmez.Solver = (*solverWrapper)(nil)\n\t_ acmez.Waiter = (*solverWrapper)(nil)\n\t_ acmez.Waiter = (*distributedSolver)(nil)\n)\n"
        },
        {
          "name": "solvers_test.go",
          "type": "blob",
          "size": 3.2861328125,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"testing\"\n\n\t\"github.com/mholt/acmez/v3/acme\"\n)\n\nfunc Test_challengeKey(t *testing.T) {\n\ttype args struct {\n\t\tchal acme.Challenge\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\tname: \"ok/dns-dns\",\n\t\t\targs: args{\n\t\t\t\tchal: acme.Challenge{\n\t\t\t\t\tType: acme.ChallengeTypeDNS01,\n\t\t\t\t\tIdentifier: acme.Identifier{\n\t\t\t\t\t\tType:  \"dns\",\n\t\t\t\t\t\tValue: \"*.example.com\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \"*.example.com\",\n\t\t},\n\t\t{\n\t\t\tname: \"ok/http-dns\",\n\t\t\targs: args{\n\t\t\t\tchal: acme.Challenge{\n\t\t\t\t\tType: acme.ChallengeTypeHTTP01,\n\t\t\t\t\tIdentifier: acme.Identifier{\n\t\t\t\t\t\tType:  \"dns\",\n\t\t\t\t\t\tValue: \"*.example.com\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \"*.example.com\",\n\t\t},\n\t\t{\n\t\t\tname: \"ok/tls-dns\",\n\t\t\targs: args{\n\t\t\t\tchal: acme.Challenge{\n\t\t\t\t\tType: acme.ChallengeTypeTLSALPN01,\n\t\t\t\t\tIdentifier: acme.Identifier{\n\t\t\t\t\t\tType:  \"dns\",\n\t\t\t\t\t\tValue: \"*.example.com\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \"*.example.com\",\n\t\t},\n\t\t{\n\t\t\tname: \"ok/http-ipv4\",\n\t\t\targs: args{\n\t\t\t\tchal: acme.Challenge{\n\t\t\t\t\tType: acme.ChallengeTypeHTTP01,\n\t\t\t\t\tIdentifier: acme.Identifier{\n\t\t\t\t\t\tType:  \"ip\",\n\t\t\t\t\t\tValue: \"127.0.0.1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \"127.0.0.1\",\n\t\t},\n\t\t{\n\t\t\tname: \"ok/http-ipv6\",\n\t\t\targs: args{\n\t\t\t\tchal: acme.Challenge{\n\t\t\t\t\tType: acme.ChallengeTypeHTTP01,\n\t\t\t\t\tIdentifier: acme.Identifier{\n\t\t\t\t\t\tType:  \"ip\",\n\t\t\t\t\t\tValue: \"2001:db8::1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \"2001:db8::1\",\n\t\t},\n\t\t{\n\t\t\tname: \"ok/tls-ipv4\",\n\t\t\targs: args{\n\t\t\t\tchal: acme.Challenge{\n\t\t\t\t\tType: acme.ChallengeTypeTLSALPN01,\n\t\t\t\t\tIdentifier: acme.Identifier{\n\t\t\t\t\t\tType:  \"ip\",\n\t\t\t\t\t\tValue: \"127.0.0.1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \"1.0.0.127.in-addr.arpa\",\n\t\t},\n\t\t{\n\t\t\tname: \"ok/tls-ipv6\",\n\t\t\targs: args{\n\t\t\t\tchal: acme.Challenge{\n\t\t\t\t\tType: acme.ChallengeTypeTLSALPN01,\n\t\t\t\t\tIdentifier: acme.Identifier{\n\t\t\t\t\t\tType:  \"ip\",\n\t\t\t\t\t\tValue: \"2001:db8::1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa\",\n\t\t},\n\t\t{\n\t\t\tname: \"fail/tls-ipv4\",\n\t\t\targs: args{\n\t\t\t\tchal: acme.Challenge{\n\t\t\t\t\tType: acme.ChallengeTypeTLSALPN01,\n\t\t\t\t\tIdentifier: acme.Identifier{\n\t\t\t\t\t\tType:  \"ip\",\n\t\t\t\t\t\tValue: \"127.0.0.1000\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \"127.0.0.1000\", // reversing this fails; default to identifier value\n\t\t},\n\t\t{\n\t\t\tname: \"fail/tls-ipv6\",\n\t\t\targs: args{\n\t\t\t\tchal: acme.Challenge{\n\t\t\t\t\tType: acme.ChallengeTypeTLSALPN01,\n\t\t\t\t\tIdentifier: acme.Identifier{\n\t\t\t\t\t\tType:  \"ip\",\n\t\t\t\t\t\tValue: \"2001:db8::10000\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \"2001:db8::10000\", // reversing this fails; default to identifier value\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := challengeKey(tt.args.chal); got != tt.want {\n\t\t\t\tt.Errorf(\"challengeKey() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "storage.go",
          "type": "blob",
          "size": 11.158203125,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"context\"\n\t\"path\"\n\t\"regexp\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"go.uber.org/zap\"\n)\n\n// Storage is a type that implements a key-value store with\n// basic file system (folder path) semantics. Keys use the\n// forward slash '/' to separate path components and have no\n// leading or trailing slashes.\n//\n// A \"prefix\" of a key is defined on a component basis,\n// e.g. \"a\" is a prefix of \"a/b\" but not \"ab/c\".\n//\n// A \"file\" is a key with a value associated with it.\n//\n// A \"directory\" is a key with no value, but which may be\n// the prefix of other keys.\n//\n// Keys passed into Load and Store always have \"file\" semantics,\n// whereas \"directories\" are only implicit by leading up to the\n// file.\n//\n// The Load, Delete, List, and Stat methods should return\n// fs.ErrNotExist if the key does not exist.\n//\n// Processes running in a cluster should use the same Storage\n// value (with the same configuration) in order to share\n// certificates and other TLS resources with the cluster.\n//\n// Implementations of Storage MUST be safe for concurrent use\n// and honor context cancellations. Methods should block until\n// their operation is complete; that is, Load() should always\n// return the value from the last call to Store() for a given\n// key, and concurrent calls to Store() should not corrupt a\n// file.\n//\n// For simplicity, this is not a streaming API and is not\n// suitable for very large files.\ntype Storage interface {\n\t// Locker enables the storage backend to synchronize\n\t// operational units of work.\n\t//\n\t// The use of Locker is NOT employed around every\n\t// Storage method call (Store, Load, etc), as these\n\t// should already be thread-safe. Locker is used for\n\t// high-level jobs or transactions that need\n\t// synchronization across a cluster; it's a simple\n\t// distributed lock. For example, CertMagic uses the\n\t// Locker interface to coordinate the obtaining of\n\t// certificates.\n\tLocker\n\n\t// Store puts value at key. It creates the key if it does\n\t// not exist and overwrites any existing value at this key.\n\tStore(ctx context.Context, key string, value []byte) error\n\n\t// Load retrieves the value at key.\n\tLoad(ctx context.Context, key string) ([]byte, error)\n\n\t// Delete deletes the named key. If the name is a\n\t// directory (i.e. prefix of other keys), all keys\n\t// prefixed by this key should be deleted. An error\n\t// should be returned only if the key still exists\n\t// when the method returns.\n\tDelete(ctx context.Context, key string) error\n\n\t// Exists returns true if the key exists either as\n\t// a directory (prefix to other keys) or a file,\n\t// and there was no error checking.\n\tExists(ctx context.Context, key string) bool\n\n\t// List returns all keys in the given path.\n\t//\n\t// If recursive is true, non-terminal keys\n\t// will be enumerated (i.e. \"directories\"\n\t// should be walked); otherwise, only keys\n\t// prefixed exactly by prefix will be listed.\n\tList(ctx context.Context, path string, recursive bool) ([]string, error)\n\n\t// Stat returns information about key.\n\tStat(ctx context.Context, key string) (KeyInfo, error)\n}\n\n// Locker facilitates synchronization across machines and networks.\n// It essentially provides a distributed named-mutex service so\n// that multiple consumers can coordinate tasks and share resources.\n//\n// If possible, a Locker should implement a coordinated distributed\n// locking mechanism by generating fencing tokens (see\n// https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html).\n// This typically requires a central server or consensus algorithm\n// However, if that is not feasible, Lockers may implement an\n// alternative mechanism that uses timeouts to detect node or network\n// failures and avoid deadlocks. For example, the default FileStorage\n// writes a timestamp to the lock file every few seconds, and if another\n// node acquiring the lock sees that timestamp is too old, it may\n// assume the lock is stale.\n//\n// As not all Locker implementations use fencing tokens, code relying\n// upon Locker must be tolerant of some mis-synchronizations but can\n// expect them to be rare.\n//\n// This interface should only be used for coordinating expensive\n// operations across nodes in a cluster; not for internal, extremely\n// short-lived, or high-contention locks.\ntype Locker interface {\n\t// Lock acquires the lock for name, blocking until the lock\n\t// can be obtained or an error is returned. Only one lock\n\t// for the given name can exist at a time. A call to Lock for\n\t// a name which already exists blocks until the named lock\n\t// is released or becomes stale.\n\t//\n\t// If the named lock represents an idempotent operation, callers\n\t// should always check to make sure the work still needs to be\n\t// completed after acquiring the lock. You never know if another\n\t// process already completed the task while you were waiting to\n\t// acquire it.\n\t//\n\t// Implementations should honor context cancellation.\n\tLock(ctx context.Context, name string) error\n\n\t// Unlock releases named lock. This method must ONLY be called\n\t// after a successful call to Lock, and only after the critical\n\t// section is finished, even if it errored or timed out. Unlock\n\t// cleans up any resources allocated during Lock. Unlock should\n\t// only return an error if the lock was unable to be released.\n\tUnlock(ctx context.Context, name string) error\n}\n\n// KeyInfo holds information about a key in storage.\n// Key and IsTerminal are required; Modified and Size\n// are optional if the storage implementation is not\n// able to get that information. Setting them will\n// make certain operations more consistent or\n// predictable, but it is not crucial to basic\n// functionality.\ntype KeyInfo struct {\n\tKey        string\n\tModified   time.Time\n\tSize       int64\n\tIsTerminal bool // false for directories (keys that act as prefix for other keys)\n}\n\n// storeTx stores all the values or none at all.\nfunc storeTx(ctx context.Context, s Storage, all []keyValue) error {\n\tfor i, kv := range all {\n\t\terr := s.Store(ctx, kv.key, kv.value)\n\t\tif err != nil {\n\t\t\tfor j := i - 1; j >= 0; j-- {\n\t\t\t\ts.Delete(ctx, all[j].key)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// keyValue pairs a key and a value.\ntype keyValue struct {\n\tkey   string\n\tvalue []byte\n}\n\n// KeyBuilder provides a namespace for methods that\n// build keys and key prefixes, for addressing items\n// in a Storage implementation.\ntype KeyBuilder struct{}\n\n// CertsPrefix returns the storage key prefix for\n// the given certificate issuer.\nfunc (keys KeyBuilder) CertsPrefix(issuerKey string) string {\n\treturn path.Join(prefixCerts, keys.Safe(issuerKey))\n}\n\n// CertsSitePrefix returns a key prefix for items associated with\n// the site given by domain using the given issuer key.\nfunc (keys KeyBuilder) CertsSitePrefix(issuerKey, domain string) string {\n\treturn path.Join(keys.CertsPrefix(issuerKey), keys.Safe(domain))\n}\n\n// SiteCert returns the path to the certificate file for domain\n// that is associated with the issuer with the given issuerKey.\nfunc (keys KeyBuilder) SiteCert(issuerKey, domain string) string {\n\tsafeDomain := keys.Safe(domain)\n\treturn path.Join(keys.CertsSitePrefix(issuerKey, domain), safeDomain+\".crt\")\n}\n\n// SitePrivateKey returns the path to the private key file for domain\n// that is associated with the certificate from the given issuer with\n// the given issuerKey.\nfunc (keys KeyBuilder) SitePrivateKey(issuerKey, domain string) string {\n\tsafeDomain := keys.Safe(domain)\n\treturn path.Join(keys.CertsSitePrefix(issuerKey, domain), safeDomain+\".key\")\n}\n\n// SiteMeta returns the path to the metadata file for domain that\n// is associated with the certificate from the given issuer with\n// the given issuerKey.\nfunc (keys KeyBuilder) SiteMeta(issuerKey, domain string) string {\n\tsafeDomain := keys.Safe(domain)\n\treturn path.Join(keys.CertsSitePrefix(issuerKey, domain), safeDomain+\".json\")\n}\n\n// OCSPStaple returns a key for the OCSP staple associated\n// with the given certificate. If you have the PEM bundle\n// handy, pass that in to save an extra encoding step.\nfunc (keys KeyBuilder) OCSPStaple(cert *Certificate, pemBundle []byte) string {\n\tvar ocspFileName string\n\tif len(cert.Names) > 0 {\n\t\tfirstName := keys.Safe(cert.Names[0])\n\t\tocspFileName = firstName + \"-\"\n\t}\n\tocspFileName += fastHash(pemBundle)\n\treturn path.Join(prefixOCSP, ocspFileName)\n}\n\n// Safe standardizes and sanitizes str for use as\n// a single component of a storage key. This method\n// is idempotent.\nfunc (keys KeyBuilder) Safe(str string) string {\n\tstr = strings.ToLower(str)\n\tstr = strings.TrimSpace(str)\n\n\t// replace a few specific characters\n\trepl := strings.NewReplacer(\n\t\t\" \", \"_\",\n\t\t\"+\", \"_plus_\",\n\t\t\"*\", \"wildcard_\",\n\t\t\":\", \"-\",\n\t\t\"..\", \"\", // prevent directory traversal (regex allows single dots)\n\t)\n\tstr = repl.Replace(str)\n\n\t// finally remove all non-word characters\n\treturn safeKeyRE.ReplaceAllLiteralString(str, \"\")\n}\n\n// CleanUpOwnLocks immediately cleans up all\n// current locks obtained by this process. Since\n// this does not cancel the operations that\n// the locks are synchronizing, this should be\n// called only immediately before process exit.\n// Errors are only reported if a logger is given.\nfunc CleanUpOwnLocks(ctx context.Context, logger *zap.Logger) {\n\tlocksMu.Lock()\n\tdefer locksMu.Unlock()\n\tfor lockKey, storage := range locks {\n\t\tif err := storage.Unlock(ctx, lockKey); err != nil {\n\t\t\tlogger.Error(\"unable to clean up lock in storage backend\",\n\t\t\t\tzap.Any(\"storage\", storage),\n\t\t\t\tzap.String(\"lock_key\", lockKey),\n\t\t\t\tzap.Error(err))\n\t\t\tcontinue\n\t\t}\n\t\tdelete(locks, lockKey)\n\t}\n}\n\nfunc acquireLock(ctx context.Context, storage Storage, lockKey string) error {\n\terr := storage.Lock(ctx, lockKey)\n\tif err == nil {\n\t\tlocksMu.Lock()\n\t\tlocks[lockKey] = storage\n\t\tlocksMu.Unlock()\n\t}\n\treturn err\n}\n\nfunc releaseLock(ctx context.Context, storage Storage, lockKey string) error {\n\terr := storage.Unlock(context.WithoutCancel(ctx), lockKey)\n\tif err == nil {\n\t\tlocksMu.Lock()\n\t\tdelete(locks, lockKey)\n\t\tlocksMu.Unlock()\n\t}\n\treturn err\n}\n\n// locks stores a reference to all the current\n// locks obtained by this process.\nvar locks = make(map[string]Storage)\nvar locksMu sync.Mutex\n\n// StorageKeys provides methods for accessing\n// keys and key prefixes for items in a Storage.\n// Typically, you will not need to use this\n// because accessing storage is abstracted away\n// for most cases. Only use this if you need to\n// directly access TLS assets in your application.\nvar StorageKeys KeyBuilder\n\nconst (\n\tprefixCerts = \"certificates\"\n\tprefixOCSP  = \"ocsp\"\n)\n\n// safeKeyRE matches any undesirable characters in storage keys.\n// Note that this allows dots, so you'll have to strip \"..\" manually.\nvar safeKeyRE = regexp.MustCompile(`[^\\w@.-]`)\n\n// defaultFileStorage is a convenient, default storage\n// implementation using the local file system.\nvar defaultFileStorage = &FileStorage{Path: dataDir()}\n"
        },
        {
          "name": "storage_test.go",
          "type": "blob",
          "size": 2.8466796875,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"path\"\n\t\"testing\"\n)\n\nfunc TestPrefixAndKeyBuilders(t *testing.T) {\n\tam := &ACMEIssuer{CA: \"https://example.com/acme-ca/directory\"}\n\n\tbase := path.Join(\"certificates\", \"example.com-acme-ca-directory\")\n\n\tfor i, testcase := range []struct {\n\t\tin, folder, certFile, keyFile, metaFile string\n\t}{\n\t\t{\n\t\t\tin:       \"example.com\",\n\t\t\tfolder:   path.Join(base, \"example.com\"),\n\t\t\tcertFile: path.Join(base, \"example.com\", \"example.com.crt\"),\n\t\t\tkeyFile:  path.Join(base, \"example.com\", \"example.com.key\"),\n\t\t\tmetaFile: path.Join(base, \"example.com\", \"example.com.json\"),\n\t\t},\n\t\t{\n\t\t\tin:       \"*.example.com\",\n\t\t\tfolder:   path.Join(base, \"wildcard_.example.com\"),\n\t\t\tcertFile: path.Join(base, \"wildcard_.example.com\", \"wildcard_.example.com.crt\"),\n\t\t\tkeyFile:  path.Join(base, \"wildcard_.example.com\", \"wildcard_.example.com.key\"),\n\t\t\tmetaFile: path.Join(base, \"wildcard_.example.com\", \"wildcard_.example.com.json\"),\n\t\t},\n\t\t{\n\t\t\t// prevent directory traversal! very important, esp. with on-demand TLS\n\t\t\t// see issue #2092\n\t\t\tin:       \"a/../../../foo\",\n\t\t\tfolder:   path.Join(base, \"afoo\"),\n\t\t\tcertFile: path.Join(base, \"afoo\", \"afoo.crt\"),\n\t\t\tkeyFile:  path.Join(base, \"afoo\", \"afoo.key\"),\n\t\t\tmetaFile: path.Join(base, \"afoo\", \"afoo.json\"),\n\t\t},\n\t\t{\n\t\t\tin:       \"b\\\\..\\\\..\\\\..\\\\foo\",\n\t\t\tfolder:   path.Join(base, \"bfoo\"),\n\t\t\tcertFile: path.Join(base, \"bfoo\", \"bfoo.crt\"),\n\t\t\tkeyFile:  path.Join(base, \"bfoo\", \"bfoo.key\"),\n\t\t\tmetaFile: path.Join(base, \"bfoo\", \"bfoo.json\"),\n\t\t},\n\t\t{\n\t\t\tin:       \"c/foo\",\n\t\t\tfolder:   path.Join(base, \"cfoo\"),\n\t\t\tcertFile: path.Join(base, \"cfoo\", \"cfoo.crt\"),\n\t\t\tkeyFile:  path.Join(base, \"cfoo\", \"cfoo.key\"),\n\t\t\tmetaFile: path.Join(base, \"cfoo\", \"cfoo.json\"),\n\t\t},\n\t} {\n\t\tif actual := StorageKeys.SiteCert(am.IssuerKey(), testcase.in); actual != testcase.certFile {\n\t\t\tt.Errorf(\"Test %d: site cert file: Expected '%s' but got '%s'\", i, testcase.certFile, actual)\n\t\t}\n\t\tif actual := StorageKeys.SitePrivateKey(am.IssuerKey(), testcase.in); actual != testcase.keyFile {\n\t\t\tt.Errorf(\"Test %d: site key file: Expected '%s' but got '%s'\", i, testcase.keyFile, actual)\n\t\t}\n\t\tif actual := StorageKeys.SiteMeta(am.IssuerKey(), testcase.in); actual != testcase.metaFile {\n\t\t\tt.Errorf(\"Test %d: site meta file: Expected '%s' but got '%s'\", i, testcase.metaFile, actual)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "zerosslissuer.go",
          "type": "blob",
          "size": 9.6748046875,
          "content": "// Copyright 2015 Matthew Holt\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage certmagic\n\nimport (\n\t\"context\"\n\t\"crypto/x509\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/caddyserver/zerossl\"\n\t\"github.com/mholt/acmez/v3\"\n\t\"github.com/mholt/acmez/v3/acme\"\n\t\"go.uber.org/zap\"\n)\n\n// ZeroSSLIssuer can get certificates from ZeroSSL's API. (To use ZeroSSL's ACME\n// endpoint, use the ACMEIssuer instead.) Note that use of the API is restricted\n// by payment tier.\ntype ZeroSSLIssuer struct {\n\t// The API key (or \"access key\") for using the ZeroSSL API.\n\t// REQUIRED.\n\tAPIKey string\n\n\t// Where to store verification material temporarily.\n\t// All instances in a cluster should have the same\n\t// Storage value to enable distributed verification.\n\t// REQUIRED. (TODO: Make it optional for those not\n\t// operating in a cluster. For now, it's simpler to\n\t// put info in storage whether distributed or not.)\n\tStorage Storage\n\n\t// How many days the certificate should be valid for.\n\tValidityDays int\n\n\t// The host to bind to when opening a listener for\n\t// verifying domain names (or IPs).\n\tListenHost string\n\n\t// If HTTP is forwarded from port 80, specify the\n\t// forwarded port here.\n\tAltHTTPPort int\n\n\t// To use CNAME validation instead of HTTP\n\t// validation, set this field.\n\tCNAMEValidation *DNSManager\n\n\t// Delay between poll attempts.\n\tPollInterval time.Duration\n\n\t// An optional (but highly recommended) logger.\n\tLogger *zap.Logger\n}\n\n// Issue obtains a certificate for the given csr.\nfunc (iss *ZeroSSLIssuer) Issue(ctx context.Context, csr *x509.CertificateRequest) (*IssuedCertificate, error) {\n\tclient := iss.getClient()\n\n\tidentifiers := namesFromCSR(csr)\n\tif len(identifiers) == 0 {\n\t\treturn nil, fmt.Errorf(\"no identifiers on CSR\")\n\t}\n\n\tlogger := iss.Logger\n\tif logger == nil {\n\t\tlogger = zap.NewNop()\n\t}\n\tlogger = logger.With(zap.Strings(\"identifiers\", identifiers))\n\n\tlogger.Info(\"creating certificate\")\n\n\tcert, err := client.CreateCertificate(ctx, csr, iss.ValidityDays)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"creating certificate: %v\", err)\n\t}\n\n\tlogger = logger.With(zap.String(\"cert_id\", cert.ID))\n\tlogger.Info(\"created certificate\")\n\n\tdefer func(certID string) {\n\t\tif err != nil {\n\t\t\terr := client.CancelCertificate(context.WithoutCancel(ctx), certID)\n\t\t\tif err == nil {\n\t\t\t\tlogger.Info(\"canceled certificate\")\n\t\t\t} else {\n\t\t\t\tlogger.Error(\"unable to cancel certificate\", zap.Error(err))\n\t\t\t}\n\t\t}\n\t}(cert.ID)\n\n\tvar verificationMethod zerossl.VerificationMethod\n\n\tif iss.CNAMEValidation == nil {\n\t\tverificationMethod = zerossl.HTTPVerification\n\t\tlogger = logger.With(zap.String(\"verification_method\", string(verificationMethod)))\n\n\t\thttpVerifier := &httpSolver{\n\t\t\taddress: net.JoinHostPort(iss.ListenHost, strconv.Itoa(iss.getHTTPPort())),\n\t\t\thandler: iss.HTTPValidationHandler(http.NewServeMux()),\n\t\t}\n\n\t\tvar solver acmez.Solver = httpVerifier\n\t\tif iss.Storage != nil {\n\t\t\tsolver = distributedSolver{\n\t\t\t\tstorage:                iss.Storage,\n\t\t\t\tstorageKeyIssuerPrefix: iss.IssuerKey(),\n\t\t\t\tsolver:                 httpVerifier,\n\t\t\t}\n\t\t}\n\n\t\t// since the distributed solver was originally designed for ACME,\n\t\t// the API is geared around ACME challenges. ZeroSSL's HTTP validation\n\t\t// is very similar to the HTTP challenge, but not quite compatible,\n\t\t// so we kind of shim the ZeroSSL validation data into a Challenge\n\t\t// object... it is not a perfect use of this type but it's pretty close\n\t\tvalInfo := cert.Validation.OtherMethods[identifiers[0]]\n\t\tfakeChallenge := acme.Challenge{\n\t\t\tIdentifier: acme.Identifier{\n\t\t\t\tValue: identifiers[0], // used for storage key\n\t\t\t},\n\t\t\tURL:   valInfo.FileValidationURLHTTP,\n\t\t\tToken: strings.Join(cert.Validation.OtherMethods[identifiers[0]].FileValidationContent, \"\\n\"),\n\t\t}\n\t\tif err = solver.Present(ctx, fakeChallenge); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"presenting validation file for verification: %v\", err)\n\t\t}\n\t\tdefer solver.CleanUp(ctx, fakeChallenge)\n\t} else {\n\t\tverificationMethod = zerossl.CNAMEVerification\n\t\tlogger = logger.With(zap.String(\"verification_method\", string(verificationMethod)))\n\n\t\t// create the CNAME record(s)\n\t\trecords := make(map[string]zoneRecord, len(cert.Validation.OtherMethods))\n\t\tfor name, verifyInfo := range cert.Validation.OtherMethods {\n\t\t\tzr, err := iss.CNAMEValidation.createRecord(ctx, verifyInfo.CnameValidationP1, \"CNAME\", verifyInfo.CnameValidationP2+\".\") // see issue #304\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"creating CNAME record: %v\", err)\n\t\t\t}\n\t\t\tdefer func(name string, zr zoneRecord) {\n\t\t\t\tif err := iss.CNAMEValidation.cleanUpRecord(ctx, zr); err != nil {\n\t\t\t\t\tlogger.Warn(\"cleaning up temporary validation record failed\",\n\t\t\t\t\t\tzap.String(\"dns_name\", name),\n\t\t\t\t\t\tzap.Error(err))\n\t\t\t\t}\n\t\t\t}(name, zr)\n\t\t\trecords[name] = zr\n\t\t}\n\n\t\t// wait for them to propagate\n\t\tfor name, zr := range records {\n\t\t\tif err := iss.CNAMEValidation.wait(ctx, zr); err != nil {\n\t\t\t\t// allow it, since the CA will ultimately decide, but definitely log it\n\t\t\t\tlogger.Warn(\"failed CNAME record propagation check\", zap.String(\"domain\", name), zap.Error(err))\n\t\t\t}\n\t\t}\n\t}\n\n\tlogger.Info(\"validating identifiers\")\n\n\tcert, err = client.VerifyIdentifiers(ctx, cert.ID, verificationMethod, nil)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"verifying identifiers: %v\", err)\n\t}\n\n\tswitch cert.Status {\n\tcase \"pending_validation\":\n\t\tlogger.Info(\"validations succeeded; waiting for certificate to be issued\")\n\n\t\tcert, err = iss.waitForCertToBeIssued(ctx, client, cert)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"waiting for certificate to be issued: %v\", err)\n\t\t}\n\tcase \"issued\":\n\t\tlogger.Info(\"validations succeeded; downloading certificate bundle\")\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unexpected certificate status: %s\", cert.Status)\n\t}\n\n\tbundle, err := client.DownloadCertificate(ctx, cert.ID, false)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"downloading certificate: %v\", err)\n\t}\n\n\tlogger.Info(\"successfully downloaded issued certificate\")\n\n\treturn &IssuedCertificate{\n\t\tCertificate: []byte(bundle.CertificateCrt + bundle.CABundleCrt),\n\t\tMetadata:    cert,\n\t}, nil\n}\n\nfunc (iss *ZeroSSLIssuer) waitForCertToBeIssued(ctx context.Context, client zerossl.Client, cert zerossl.CertificateObject) (zerossl.CertificateObject, error) {\n\tticker := time.NewTicker(iss.pollInterval())\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn cert, ctx.Err()\n\t\tcase <-ticker.C:\n\t\t\tvar err error\n\t\t\tcert, err = client.GetCertificate(ctx, cert.ID)\n\t\t\tif err != nil {\n\t\t\t\treturn cert, err\n\t\t\t}\n\t\t\tif cert.Status == \"issued\" {\n\t\t\t\treturn cert, nil\n\t\t\t}\n\t\t\tif cert.Status != \"pending_validation\" {\n\t\t\t\treturn cert, fmt.Errorf(\"unexpected certificate status: %s\", cert.Status)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (iss *ZeroSSLIssuer) pollInterval() time.Duration {\n\tif iss.PollInterval == 0 {\n\t\treturn defaultPollInterval\n\t}\n\treturn iss.PollInterval\n}\n\nfunc (iss *ZeroSSLIssuer) getClient() zerossl.Client {\n\treturn zerossl.Client{AccessKey: iss.APIKey}\n}\n\nfunc (iss *ZeroSSLIssuer) getHTTPPort() int {\n\tuseHTTPPort := HTTPChallengePort\n\tif HTTPPort > 0 && HTTPPort != HTTPChallengePort {\n\t\tuseHTTPPort = HTTPPort\n\t}\n\tif iss.AltHTTPPort > 0 {\n\t\tuseHTTPPort = iss.AltHTTPPort\n\t}\n\treturn useHTTPPort\n}\n\n// IssuerKey returns the unique issuer key for ZeroSSL.\nfunc (iss *ZeroSSLIssuer) IssuerKey() string { return zerosslIssuerKey }\n\n// Revoke revokes the given certificate. Only do this if there is a security or trust\n// concern with the certificate.\nfunc (iss *ZeroSSLIssuer) Revoke(ctx context.Context, cert CertificateResource, reason int) error {\n\tr := zerossl.UnspecifiedReason\n\tswitch reason {\n\tcase acme.ReasonKeyCompromise:\n\t\tr = zerossl.KeyCompromise\n\tcase acme.ReasonAffiliationChanged:\n\t\tr = zerossl.AffiliationChanged\n\tcase acme.ReasonSuperseded:\n\t\tr = zerossl.Superseded\n\tcase acme.ReasonCessationOfOperation:\n\t\tr = zerossl.CessationOfOperation\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupported reason: %d\", reason)\n\t}\n\tvar certObj zerossl.CertificateObject\n\tif err := json.Unmarshal(cert.IssuerData, &certObj); err != nil {\n\t\treturn err\n\t}\n\treturn iss.getClient().RevokeCertificate(ctx, certObj.ID, r)\n}\n\nfunc (iss *ZeroSSLIssuer) getDistributedValidationInfo(ctx context.Context, identifier string) (acme.Challenge, bool, error) {\n\tif iss.Storage == nil {\n\t\treturn acme.Challenge{}, false, nil\n\t}\n\n\tds := distributedSolver{\n\t\tstorage:                iss.Storage,\n\t\tstorageKeyIssuerPrefix: StorageKeys.Safe(iss.IssuerKey()),\n\t}\n\ttokenKey := ds.challengeTokensKey(identifier)\n\n\tvalObjectBytes, err := iss.Storage.Load(ctx, tokenKey)\n\tif err != nil {\n\t\treturn acme.Challenge{}, false, fmt.Errorf(\"opening distributed challenge token file %s: %v\", tokenKey, err)\n\t}\n\n\tif len(valObjectBytes) == 0 {\n\t\treturn acme.Challenge{}, false, fmt.Errorf(\"no information found to solve challenge for identifier: %s\", identifier)\n\t}\n\n\t// since the distributed solver's API is geared around ACME challenges,\n\t// we crammed the validation info into a Challenge object\n\tvar chal acme.Challenge\n\tif err = json.Unmarshal(valObjectBytes, &chal); err != nil {\n\t\treturn acme.Challenge{}, false, fmt.Errorf(\"decoding HTTP validation token file %s (corrupted?): %v\", tokenKey, err)\n\t}\n\n\treturn chal, true, nil\n}\n\nconst (\n\tzerosslIssuerKey    = \"zerossl\"\n\tdefaultPollInterval = 5 * time.Second\n)\n\n// Interface guards\nvar (\n\t_ Issuer  = (*ZeroSSLIssuer)(nil)\n\t_ Revoker = (*ZeroSSLIssuer)(nil)\n)\n"
        }
      ]
    }
  ]
}