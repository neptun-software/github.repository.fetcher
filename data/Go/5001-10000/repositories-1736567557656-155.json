{
  "metadata": {
    "timestamp": 1736567557656,
    "page": 155,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "urfave/negroni",
      "stars": 7481,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.013671875,
          "content": "/coverage.txt\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.9169921875,
          "content": "language: go\n\nsudo: false\ndist: trusty\narch:\n  - AMD64\n  - ppc64le\n  \ngo:\n- 1.x\n- 1.2.x\n- 1.3.x\n- 1.4.x\n- 1.5.x\n- 1.6.x\n- 1.7.x\n- 1.8.x\n- 1.9.x\n- 1.10.x\n- 1.11.x\n- master\n\n# Disable version 1.x, 1.2.x, 1.3.x, 1.4.x, 1.5.x, 1.6.x, 1.7.x, 1.8.x, 1.9.x, 1.10.x \njobs: \n  exclude:\n    - arch: ppc64le\n      go: 1.x \n    - arch: ppc64le\n      go: 1.2.x\n    - arch: ppc64le\n      go: 1.3.x \n    - arch: ppc64le\n      go: 1.4.x\n    - arch: ppc64le\n      go: 1.5.x\n    - arch: ppc64le\n      go: 1.6.x\n    - arch: ppc64le\n      go: 1.7.x\n    - arch: ppc64le\n      go: 1.8.x\n    - arch: ppc64le\n      go: 1.9.x\n    - arch: ppc64le\n      go: 1.10.x\nbefore_install:\n- find \"${GOPATH%%:*}\" -name '*.a' -delete\n- rm -rf \"${GOPATH%%:*}/src/golang.org\"\n- go get golang.org/x/tools/cover\n- go get golang.org/x/tools/cmd/cover\n\nscript:\n- go test -race -coverprofile=coverage.txt -covermode=atomic\n\nafter_success:\n- bash <(curl -s \"https://codecov.io/bash\")\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 4.7734375,
          "content": "# Change Log\n\n**ATTN**: This project uses [semantic versioning](http://semver.org/).\n\n## [3.1.1] - [2024-06-04]\n\n### Fixed\n\n- Writing an HTTP 1xx status codes no longer results in a 200 being sent in\n  addition given the expectation is that a follow-up status code will be written\n  later. The exception is `101 Switching Protocols` since this is terminal. This\n  matches `net/http` behavior.\n\n## [3.1.0] - [2023-10-07]\n\n### Fixed\n\n- `WriteHeader` can again be used in the `ResponseWriter.Before` callback to\n  set HTTP status codes\n\n### Added\n\n- Satisfy `http.ResponseController` (Go 1.20+)\n\n## [3.0.0] - [2022-09-18]\n\n### Fixed\n\n- Replace multiple slashes at the beginning of a path with a single one to avoid\n  open redirects\n- Avoid updating `ResponseWriter.Status()` if the status has already been\n  written when `ResponseWriter.WriteHeader()` is called twice\n\n### Changed\n\n- `ResponseWriter` now only implements `http` interfaces (`Flusher`, `Hijacker`,\n  `CloseNotifier`) if the wrapped `http.ResponseWriter` does. This is a breaking\n  change to make `ResponseWriter`'s interface support more accurate\n\n### Added\n\n- `ResponseWriter` now implements `io.ReaderFrom` to more efficiently send\n  responses via `io.Copy`\n\n## [2.0.2] - 2020-07-17\n\n### Fixed\n\n- Fixed Go module name for v2\n\n## [2.0.1] - 2020-05-25\n\n### Fixed\n\n- Recovery middleware now checks that `Formatter` is not `nil` before calling\n\n## [2.0.0] - 2020-05-25\n\n### Changed\n\n- `Recovery.PrintStack`, when false, now also supresses the panic message in\n  addition to supressing the stack trace\n\n### Fixed\n\n- `Negroni.With()` now copies handlers to avoid mutating the original `Negroni`\n  instance if `Use` is called on the new `Negroni` instance\n\n### Added\n\n- `Recovery.LogStack` was added to control whether the stacktrace is logged for\n  panics\n\n### Changed\n\n## [1.0.0] - 2018-09-01\n\n### Fixed\n- `Logger` middleware now correctly handles paths containing a `%` instead of trying to treat it as a format specifier\n\n## [0.3.0] - 2017-11-11\n### Added\n- `With()` helper for building a new `Negroni` struct chaining handlers from\n  existing `Negroni` structs\n- Format log output in `Logger` middleware via a configurable `text/template`\n  string injectable via `.SetFormat`. Added `LoggerDefaultFormat` and\n  `LoggerDefaultDateFormat` to configure the default template and date format\n  used by the `Logger` middleware.\n- Support for HTTP/2 pusher support via `http.Pusher` interface for Go 1.8+.\n- `WrapFunc` to convert `http.HandlerFunc` into a `negroni.Handler`\n- `Formatter` field added to `Recovery` middleware to allow configuring how\n  `panic`s are output. Default of `TextFormatter` (how it was output in\n  `0.2.0`) used. `HTMLPanicFormatter` also added to allow easy outputing of\n  `panic`s as HTML.\n\n### Fixed\n- `Written()` correct returns `false` if no response header has been written\n- Only implement `http.CloseNotifier` with the `negroni.ResponseWriter` if the\n  underlying `http.ResponseWriter` implements it (previously would always\n  implement it and panic if the underlying `http.ResponseWriter` did not.\n\n### Changed\n- Set default status to `0` in the case that no handler writes status -- was\n  previously `200` (in 0.2.0, before that it was `0` so this reestablishes that\n  behavior)\n- Catch `panic`s thrown by callbacks provided to the `Recovery` handler\n- Recovery middleware will set `text/plain` content-type if none is set\n- `ALogger` interface to allow custom logger outputs to be used with the\n  `Logger` middleware. Changes embeded field in `negroni.Logger` from `Logger`\n  to `ALogger`.\n- Default `Logger` middleware output changed to be more structure and verbose\n  (also now configurable, see `Added`)\n- Automatically bind to port specified in `$PORT` in `.Run()` if an address is\n  not passed in. Fall back to binding to `:8080` if no address specified\n  (configuable via `DefaultAddress`).\n- `PanicHandlerFunc` added to `Recovery` middleware to enhance custom handling\n  of `panic`s by providing additional information to the handler including the\n  stack and the `http.Request`. `Recovery.ErrorHandlerFunc` was also added, but\n  deprecated in favor of the new `PanicHandlerFunc`.\n\n## [0.2.0] - 2016-05-10\n### Added\n- Support for variadic handlers in `New()`\n- Added `Negroni.Handlers()` to fetch all of the handlers for a given chain\n- Allowed size in `Recovery` handler was bumped to 8k\n- `Negroni.UseFunc` to push another handler onto the chain\n\n### Changed\n- Set the status before calling `beforeFuncs` so the information is available to them\n- Set default status to `200` in the case that no handler writes status -- was previously `0`\n- Panic if `nil` handler is given to `negroni.Use`\n\n## 0.1.0 - 2013-07-22\n### Added\n- Initial implementation.\n\n[Unreleased]: https://github.com/urfave/negroni/compare/v0.2.0...HEAD\n[0.2.0]: https://github.com/urfave/negroni/compare/v0.1.0...v0.2.0\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0537109375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2025 Jeremy Saenz\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 20.9951171875,
          "content": "# Negroni\n[![GoDoc](https://godoc.org/github.com/urfave/negroni?status.svg)](http://godoc.org/github.com/urfave/negroni)\n[![Build Status](https://travis-ci.org/urfave/negroni.svg?branch=master)](https://travis-ci.org/urfave/negroni)\n[![codebeat](https://codebeat.co/badges/47d320b1-209e-45e8-bd99-9094bc5111e2)](https://codebeat.co/projects/github-com-urfave-negroni)\n[![codecov](https://codecov.io/gh/urfave/negroni/branch/master/graph/badge.svg)](https://codecov.io/gh/urfave/negroni)\n\n**Notice:** This is the library formerly known as\n`github.com/codegangsta/negroni` -- Github will automatically redirect requests\nto this repository, but we recommend updating your references for clarity.\n\nNegroni is an idiomatic approach to web middleware in Go. It is tiny,\nnon-intrusive, and encourages use of `net/http` Handlers.\n\nIf you like the idea of [Martini](https://github.com/go-martini/martini), but\nyou think it contains too much magic, then Negroni is a great fit.\n\nLanguage Translations:\n* [Deutsch (de_DE)](translations/README_de_de.md)\n* [Português Brasileiro (pt_BR)](translations/README_pt_br.md)\n* [简体中文 (zh_CN)](translations/README_zh_CN.md)\n* [繁體中文 (zh_TW)](translations/README_zh_tw.md)\n* [日本語 (ja_JP)](translations/README_ja_JP.md)\n* [Français (fr_FR)](translations/README_fr_FR.md)\n* [한국어 (ko_KR)](translations/README_ko_KR.md)\n\n## Getting Started\n\nAfter installing Go and setting up your\n[GOPATH](http://golang.org/doc/code.html#GOPATH), create your first `.go` file.\nWe'll call it `server.go`.\n\n<!-- { \"interrupt\": true } -->\n``` go\npackage main\n\nimport (\n  \"fmt\"\n  \"net/http\"\n\n  \"github.com/urfave/negroni\"\n)\n\nfunc main() {\n  mux := http.NewServeMux()\n  mux.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n    fmt.Fprintf(w, \"Welcome to the home page!\")\n  })\n\n  n := negroni.Classic() // Includes some default middlewares\n  n.UseHandler(mux)\n\n  http.ListenAndServe(\":3000\", n)\n}\n```\n\nThen install the Negroni package (**NOTE**: &gt;= **go 1.1** is required):\n\n```\ngo get github.com/urfave/negroni\n```\n\nThen run your server:\n\n```\ngo run server.go\n```\n\nYou will now have a Go `net/http` webserver running on `localhost:3000`.\n\n### Packaging\n\nIf you are on Debian, `negroni` is also available as [a\npackage](https://packages.debian.org/sid/golang-github-urfave-negroni-dev) that\nyou can install via `apt install golang-github-urfave-negroni-dev` (at the time\nof writing, it is in the `sid` repositories).\n\n## Is Negroni a Framework?\n\nNegroni is **not** a framework. It is a middleware-focused library that is\ndesigned to work directly with `net/http`.\n\n## Routing?\n\nNegroni is BYOR (Bring your own Router). The Go community already has a number\nof great http routers available, and Negroni tries to play well with all of them\nby fully supporting `net/http`. For instance, integrating with [Gorilla Mux]\nlooks like so:\n\n``` go\nrouter := mux.NewRouter()\nrouter.HandleFunc(\"/\", HomeHandler)\n\nn := negroni.New(Middleware1, Middleware2)\n// Or use a middleware with the Use() function\nn.Use(Middleware3)\n// router goes last\nn.UseHandler(router)\n\nhttp.ListenAndServe(\":3001\", n)\n```\n\n## `negroni.Classic()`\n\n`negroni.Classic()` provides some default middleware that is useful for most\napplications:\n\n* [`negroni.Recovery`](#recovery) - Panic Recovery Middleware.\n* [`negroni.Logger`](#logger) - Request/Response Logger Middleware.\n* [`negroni.Static`](#static) - Static File serving under the \"public\"\n  directory.\n\nThis makes it really easy to get started with some useful features from Negroni.\n\n## Handlers\n\nNegroni provides a bidirectional middleware flow. This is done through the\n`negroni.Handler` interface:\n\n``` go\ntype Handler interface {\n  ServeHTTP(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc)\n}\n```\n\nIf a middleware hasn't already written to the `ResponseWriter`, it should call\nthe next `http.HandlerFunc` in the chain to yield to the next middleware\nhandler.  This can be used for great good:\n\n``` go\nfunc MyMiddleware(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n  // do some stuff before\n  next(rw, r)\n  // do some stuff after\n}\n```\n\nAnd you can map it to the handler chain with the `Use` function:\n\n``` go\nn := negroni.New()\nn.Use(negroni.HandlerFunc(MyMiddleware))\n```\n\nYou can also map plain old `http.Handler`s:\n\n``` go\nn := negroni.New()\n\nmux := http.NewServeMux()\n// map your routes\n\nn.UseHandler(mux)\n\nhttp.ListenAndServe(\":3000\", n)\n```\n\n## `With()`\n\nNegroni has a convenience function called `With`. `With` takes one or more\n`Handler` instances and returns a new `Negroni` with the combination of the\nreceiver's handlers and the new handlers.\n\n```go\n// middleware we want to reuse\ncommon := negroni.New()\ncommon.Use(MyMiddleware1)\ncommon.Use(MyMiddleware2)\n\n// `specific` is a new negroni with the handlers from `common` combined with the\n// the handlers passed in\nspecific := common.With(\n\tSpecificMiddleware1,\n\tSpecificMiddleware2\n)\n```\n\n## `Run()`\n\nNegroni has a convenience function called `Run`. `Run` takes an addr string\nidentical to [`http.ListenAndServe`](https://godoc.org/net/http#ListenAndServe).\n\n<!-- { \"interrupt\": true } -->\n``` go\npackage main\n\nimport (\n  \"github.com/urfave/negroni\"\n)\n\nfunc main() {\n  n := negroni.Classic()\n  n.Run(\":8080\")\n}\n```\n\nIf no address is provided, the `PORT` environment variable is used instead.\nIf the `PORT` environment variable is not defined, the default address will be used. \nSee [Run](https://godoc.org/github.com/urfave/negroni#Negroni.Run) for a complete description.\n\nIn general, you will want to use `net/http` methods and pass `negroni` as a\n`Handler`, as this is more flexible, e.g.:\n\n<!-- { \"interrupt\": true } -->\n``` go\npackage main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n  \"time\"\n\n  \"github.com/urfave/negroni\"\n)\n\nfunc main() {\n  mux := http.NewServeMux()\n  mux.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n    fmt.Fprintf(w, \"Welcome to the home page!\")\n  })\n\n  n := negroni.Classic() // Includes some default middlewares\n  n.UseHandler(mux)\n\n  s := &http.Server{\n    Addr:           \":8080\",\n    Handler:        n,\n    ReadTimeout:    10 * time.Second,\n    WriteTimeout:   10 * time.Second,\n    MaxHeaderBytes: 1 << 20,\n  }\n  log.Fatal(s.ListenAndServe())\n}\n```\n\n## Route Specific Middleware\n\nIf you have a route group of routes that need specific middleware to be\nexecuted, you can simply create a new Negroni instance and use it as your route\nhandler.\n\n``` go\nrouter := mux.NewRouter()\nadminRoutes := mux.NewRouter()\n// add admin routes here\n\n// Create a new negroni for the admin middleware\nrouter.PathPrefix(\"/admin\").Handler(negroni.New(\n  Middleware1,\n  Middleware2,\n  negroni.Wrap(adminRoutes),\n))\n```\n\nIf you are using [Gorilla Mux], here is an example using a subrouter:\n\n``` go\nrouter := mux.NewRouter()\nsubRouter := mux.NewRouter().PathPrefix(\"/subpath\").Subrouter().StrictSlash(true)\nsubRouter.HandleFunc(\"/\", someSubpathHandler) // \"/subpath/\"\nsubRouter.HandleFunc(\"/:id\", someSubpathHandler) // \"/subpath/:id\"\n\n// \"/subpath\" is necessary to ensure the subRouter and main router linkup\nrouter.PathPrefix(\"/subpath\").Handler(negroni.New(\n  Middleware1,\n  Middleware2,\n  negroni.Wrap(subRouter),\n))\n```\n\n`With()` can be used to eliminate redundancy for middlewares shared across\nroutes.\n\n``` go\nrouter := mux.NewRouter()\napiRoutes := mux.NewRouter()\n// add api routes here\nwebRoutes := mux.NewRouter()\n// add web routes here\n\n// create common middleware to be shared across routes\ncommon := negroni.New(\n\tMiddleware1,\n\tMiddleware2,\n)\n\n// create a new negroni for the api middleware\n// using the common middleware as a base\nrouter.PathPrefix(\"/api\").Handler(common.With(\n  APIMiddleware1,\n  negroni.Wrap(apiRoutes),\n))\n// create a new negroni for the web middleware\n// using the common middleware as a base\nrouter.PathPrefix(\"/web\").Handler(common.With(\n  WebMiddleware1,\n  negroni.Wrap(webRoutes),\n))\n```\n\n## Bundled Middleware\n\n### Static\n\nThis middleware will serve files on the filesystem. If the files do not exist,\nit proxies the request to the next middleware. If you want the requests for\nnon-existent files to return a `404 File Not Found` to the user you should look\nat using [http.FileServer](https://golang.org/pkg/net/http/#FileServer) as\na handler.\n\nExample:\n\n<!-- { \"interrupt\": true } -->\n``` go\npackage main\n\nimport (\n  \"fmt\"\n  \"net/http\"\n\n  \"github.com/urfave/negroni\"\n)\n\nfunc main() {\n  mux := http.NewServeMux()\n  mux.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n    fmt.Fprintf(w, \"Welcome to the home page!\")\n  })\n\n  // Example of using a http.FileServer if you want \"server-like\" rather than \"middleware\" behavior\n  // mux.Handle(\"/public\", http.FileServer(http.Dir(\"/home/public\")))\n\n  n := negroni.New()\n  n.Use(negroni.NewStatic(http.Dir(\"/tmp\")))\n  n.UseHandler(mux)\n\n  http.ListenAndServe(\":3002\", n)\n}\n```\n\nWill serve files from the `/tmp` directory first, but proxy calls to the next\nhandler if the request does not match a file on the filesystem.\n\n### Recovery\n\nThis middleware catches `panic`s and responds with a `500` response code. If\nany other middleware has written a response code or body, this middleware will\nfail to properly send a 500 to the client, as the client has already received\nthe HTTP response code. Additionally, an `PanicHandlerFunc` can be attached\nto report 500's to an error reporting service such as Sentry or Airbrake.\n\nExample:\n\n<!-- { \"interrupt\": true } -->\n``` go\npackage main\n\nimport (\n  \"net/http\"\n\n  \"github.com/urfave/negroni\"\n)\n\nfunc main() {\n  mux := http.NewServeMux()\n  mux.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n    panic(\"oh no\")\n  })\n\n  n := negroni.New()\n  n.Use(negroni.NewRecovery())\n  n.UseHandler(mux)\n\n  http.ListenAndServe(\":3003\", n)\n}\n```\n\nWill return a `500 Internal Server Error` to each request. It will also log the\nstack traces as well as print the stack trace to the requester if `PrintStack`\nis set to `true` (the default).\n\nExample with error handler:\n\n``` go\npackage main\n\nimport (\n  \"net/http\"\n\n  \"github.com/urfave/negroni\"\n)\n\nfunc main() {\n  mux := http.NewServeMux()\n  mux.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n    panic(\"oh no\")\n  })\n\n  n := negroni.New()\n  recovery := negroni.NewRecovery()\n  recovery.PanicHandlerFunc = reportToSentry\n  n.Use(recovery)\n  n.UseHandler(mux)\n\n  http.ListenAndServe(\":3003\", n)\n}\n\nfunc reportToSentry(info *negroni.PanicInformation) {\n    // write code here to report error to Sentry\n}\n```\n\nThe middleware simply output the informations on STDOUT by default.\nYou can customize the output process by using the `SetFormatter()` function.\n\nYou can use also the `HTMLPanicFormatter` to display a pretty HTML when a crash occurs.\n\n<!-- { \"interrupt\": true } -->\n``` go\npackage main\n\nimport (\n  \"net/http\"\n\n  \"github.com/urfave/negroni\"\n)\n\nfunc main() {\n  mux := http.NewServeMux()\n  mux.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n    panic(\"oh no\")\n  })\n\n  n := negroni.New()\n  recovery := negroni.NewRecovery()\n  recovery.Formatter = &negroni.HTMLPanicFormatter{}\n  n.Use(recovery)\n  n.UseHandler(mux)\n\n  http.ListenAndServe(\":3003\", n)\n}\n```\n\n## Logger\n\nThis middleware logs each incoming request and response.\n\nExample:\n\n<!-- { \"interrupt\": true } -->\n``` go\npackage main\n\nimport (\n  \"fmt\"\n  \"net/http\"\n\n  \"github.com/urfave/negroni\"\n)\n\nfunc main() {\n  mux := http.NewServeMux()\n  mux.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n    fmt.Fprintf(w, \"Welcome to the home page!\")\n  })\n\n  n := negroni.New()\n  n.Use(negroni.NewLogger())\n  n.UseHandler(mux)\n\n  http.ListenAndServe(\":3004\", n)\n}\n```\n\nWill print a log similar to:\n\n```\n[negroni] 2017-10-04T14:56:25+02:00 | 200 |      378µs | localhost:3004 | GET /\n```\n\non each request.\n\nYou can also set your own log format by calling the `SetFormat` function. The format is a template string with fields as mentioned in the `LoggerEntry` struct. So, as an example -\n\n```go\nl.SetFormat(\"[{{.Status}} {{.Duration}}] - {{.Request.UserAgent}}\")\n```\n\nwill show something like - `[200 18.263µs] - Go-User-Agent/1.1 `\n\n## Third Party Middleware\n\nHere is a current list of Negroni compatible middlware. Feel free to put up a PR\nlinking your middleware if you have built one:\n\n| Middleware                                                                   | Author                                               | Description                                                                                                                     |\n| ---------------------------------------------------------------------------- | ---------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |\n| [authz](https://github.com/casbin/negroni-authz)                             | [Yang Luo](https://github.com/hsluoyz)               | ACL, RBAC, ABAC Authorization middlware based on [Casbin](https://github.com/casbin/casbin)                                     |\n| [binding](https://github.com/mholt/binding)                                  | [Matt Holt](https://github.com/mholt)                | Data binding from HTTP requests into structs                                                                                    |\n| [cloudwatch](https://github.com/cvillecsteele/negroni-cloudwatch)            | [Colin Steele](https://github.com/cvillecsteele)     | AWS cloudwatch metrics middleware                                                                                               |\n| [cors](https://github.com/rs/cors)                                           | [Olivier Poitrey](https://github.com/rs)             | [Cross Origin Resource Sharing](http://www.w3.org/TR/cors/) (CORS) support                                                      |\n| [csp](https://github.com/awakenetworks/csp)                                  | [Awake Networks](https://github.com/awakenetworks)   | [Content Security Policy](https://www.w3.org/TR/CSP2/) (CSP) support                                                            |\n| [delay](https://github.com/jeffbmartinez/delay)                              | [Jeff Martinez](https://github.com/jeffbmartinez)    | Add delays/latency to endpoints. Useful when testing effects of high latency                                                    |\n| [New Relic Go Agent](https://github.com/yadvendar/negroni-newrelic-go-agent) | [Yadvendar Champawat](https://github.com/yadvendar)  | Official [New Relic Go Agent](https://github.com/newrelic/go-agent) (currently in beta)                                         |\n| [gorelic](https://github.com/jingweno/negroni-gorelic)                       | [Jingwen Owen Ou](https://github.com/jingweno)       | New Relic agent for Go runtime                                                                                                  |\n| [Graceful](https://github.com/tylerb/graceful)                               | [Tyler Bunnell](https://github.com/tylerb)           | Graceful HTTP Shutdown                                                                                                          |\n| [gzip](https://github.com/phyber/negroni-gzip)                               | [phyber](https://github.com/phyber)                  | GZIP response compression                                                                                                       |\n| [JWT Middleware](https://github.com/auth0/go-jwt-middleware)                 | [Auth0](https://github.com/auth0)                    | Middleware checks for a JWT on the `Authorization` header on incoming requests and decodes it                                   |\n| [JWT Middleware](https://github.com/mfuentesg/go-jwtmiddleware)              | [Marcelo Fuentes](https://github.com/mfuentesg)      | JWT middleware for golang                                                                                                       |\n| [logrus](https://github.com/meatballhat/negroni-logrus)                      | [Dan Buch](https://github.com/meatballhat)           | Logrus-based logger                                                                                                             |\n| [oauth2](https://github.com/goincremental/negroni-oauth2)                    | [David Bochenski](https://github.com/bochenski)      | oAuth2 middleware                                                                                                               |\n| [onthefly](https://github.com/xyproto/onthefly)                              | [Alexander Rødseth](https://github.com/xyproto)      | Generate TinySVG, HTML and CSS on the fly                                                                                       |\n| [permissions2](https://github.com/xyproto/permissions2)                      | [Alexander Rødseth](https://github.com/xyproto)      | Cookies, users and permissions                                                                                                  |\n| [prometheus](https://github.com/zbindenren/negroni-prometheus)               | [Rene Zbinden](https://github.com/zbindenren)        | Easily create metrics endpoint for the [prometheus](http://prometheus.io) instrumentation tool                                  |\n| [prometheus](https://github.com/slok/go-prometheus-middleware)               | [Xabier Larrakoetxea](https://github.com/slok)       | [Prometheus](http://prometheus.io) metrics with multiple options that follow standards and try to be measured in a efficient way |\n| [render](https://github.com/unrolled/render)                                 | [Cory Jacobsen](https://github.com/unrolled)         | Render JSON, XML and HTML templates                                                                                             |\n| [RestGate](https://github.com/pjebs/restgate)                                | [Prasanga Siripala](https://github.com/pjebs)        | Secure authentication for REST API endpoints                                                                                    |\n| [secure](https://github.com/unrolled/secure)                                 | [Cory Jacobsen](https://github.com/unrolled)         | Middleware that implements a few quick security wins                                                                            |\n| [sessions](https://github.com/goincremental/negroni-sessions)                | [David Bochenski](https://github.com/bochenski)      | Session Management                                                                                                              |\n| [stats](https://github.com/thoas/stats)                                      | [Florent Messa](https://github.com/thoas)            | Store information about your web application (response time, etc.)                                                              |\n| [VanGoH](https://github.com/auroratechnologies/vangoh)                       | [Taylor Wrobel](https://github.com/twrobel3)         | Configurable [AWS-Style](http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html) HMAC authentication middleware |\n| [xrequestid](https://github.com/pilu/xrequestid)                             | [Andrea Franz](https://github.com/pilu)              | Middleware that assigns a random X-Request-Id header to each request                                                            |\n| [mgo session](https://github.com/joeljames/nigroni-mgo-session)              | [Joel James](https://github.com/joeljames)           | Middleware that handles creating and closing mgo sessions per request                                                           |\n| [digits](https://github.com/bamarni/digits)                                  | [Bilal Amarni](https://github.com/bamarni)           | Middleware that handles [Twitter Digits](https://get.digits.com/) authentication                                                |\n| [stats](https://github.com/guptachirag/stats)                                | [Chirag Gupta](https://github.com/guptachirag/stats) | Middleware that manages qps and latency stats for your endpoints and asynchronously flushes them to influx db                   |\n| [Chaos](https://github.com/falzm/chaos)                                      | [Marc Falzon](https://github.com/falzm)              | Middleware for injecting chaotic behavior into application in a programmatic way                                                |\n\n## Examples\n\n[Alexander Rødseth](https://github.com/xyproto) created\n[mooseware](https://github.com/xyproto/mooseware), a skeleton for writing a\nNegroni middleware handler.\n\n[Prasanga Siripala](https://github.com/pjebs) created an effective skeleton structure for web-based Go/Negroni projects: [Go-Skeleton](https://github.com/pjebs/go-skeleton) \n\n## Live code reload?\n\n[gin](https://github.com/codegangsta/gin) and\n[fresh](https://github.com/pilu/fresh) both live reload negroni apps.\n\n## Essential Reading for Beginners of Go & Negroni\n\n* [Using a Context to pass information from middleware to end handler](http://elithrar.github.io/article/map-string-interface/)\n* [Understanding middleware](https://mattstauffer.co/blog/laravel-5.0-middleware-filter-style)\n\n## About\n\nNegroni is obsessively designed by none other than the [Code\nGangsta](https://codegangsta.io/)\n\n[Gorilla Mux]: https://github.com/gorilla/mux\n[`http.FileSystem`]: https://godoc.org/net/http#FileSystem\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.685546875,
          "content": "// Package negroni is an idiomatic approach to web middleware in Go. It is tiny, non-intrusive, and encourages use of net/http Handlers.\n//\n// If you like the idea of Martini, but you think it contains too much magic, then Negroni is a great fit.\n//\n// For a full guide visit http://github.com/urfave/negroni\n//\n//  package main\n//\n//  import (\n//    \"github.com/urfave/negroni\"\n//    \"net/http\"\n//    \"fmt\"\n//  )\n//\n//  func main() {\n//    mux := http.NewServeMux()\n//    mux.HandleFunc(\"/\", func(w http.ResponseWriter, req *http.Request) {\n//      fmt.Fprintf(w, \"Welcome to the home page!\")\n//    })\n//\n//    n := negroni.Classic()\n//    n.UseHandler(mux)\n//    n.Run(\":3000\")\n//  }\npackage negroni\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0439453125,
          "content": "module github.com/urfave/negroni/v3\n\ngo 1.17\n"
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 1.8720703125,
          "content": "package negroni\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"text/template\"\n\t\"time\"\n)\n\n// LoggerEntry is the structure passed to the template.\ntype LoggerEntry struct {\n\tStartTime string\n\tStatus    int\n\tDuration  time.Duration\n\tHostname  string\n\tMethod    string\n\tPath      string\n\tRequest   *http.Request\n}\n\n// LoggerDefaultFormat is the format logged used by the default Logger instance.\nvar LoggerDefaultFormat = \"{{.StartTime}} | {{.Status}} | \\t {{.Duration}} | {{.Hostname}} | {{.Method}} {{.Path}}\"\n\n// LoggerDefaultDateFormat is the format used for date by the default Logger instance.\nvar LoggerDefaultDateFormat = time.RFC3339\n\n// ALogger interface\ntype ALogger interface {\n\tPrintln(v ...interface{})\n\tPrintf(format string, v ...interface{})\n}\n\n// Logger is a middleware handler that logs the request as it goes in and the response as it goes out.\ntype Logger struct {\n\t// ALogger implements just enough log.Logger interface to be compatible with other implementations\n\tALogger\n\tdateFormat string\n\ttemplate   *template.Template\n}\n\n// NewLogger returns a new Logger instance\nfunc NewLogger() *Logger {\n\tlogger := &Logger{ALogger: log.New(os.Stdout, \"[negroni] \", 0), dateFormat: LoggerDefaultDateFormat}\n\tlogger.SetFormat(LoggerDefaultFormat)\n\treturn logger\n}\n\nfunc (l *Logger) SetFormat(format string) {\n\tl.template = template.Must(template.New(\"negroni_parser\").Parse(format))\n}\n\nfunc (l *Logger) SetDateFormat(format string) {\n\tl.dateFormat = format\n}\n\nfunc (l *Logger) ServeHTTP(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\tstart := time.Now()\n\n\tnext(rw, r)\n\n\tres := rw.(ResponseWriter)\n\tlog := LoggerEntry{\n\t\tStartTime: start.Format(l.dateFormat),\n\t\tStatus:    res.Status(),\n\t\tDuration:  time.Since(start),\n\t\tHostname:  r.Host,\n\t\tMethod:    r.Method,\n\t\tPath:      r.URL.Path,\n\t\tRequest:   r,\n\t}\n\n\tbuff := &bytes.Buffer{}\n\tl.template.Execute(buff, log)\n\tl.Println(buff.String())\n}\n"
        },
        {
          "name": "logger_test.go",
          "type": "blob",
          "size": 2.0517578125,
          "content": "package negroni\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc Test_Logger(t *testing.T) {\n\tvar buff bytes.Buffer\n\trecorder := httptest.NewRecorder()\n\n\tl := NewLogger()\n\tl.ALogger = log.New(&buff, \"[negroni] \", 0)\n\n\tn := New()\n\t// replace log for testing\n\tn.Use(l)\n\tn.UseHandler(http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {\n\t\trw.WriteHeader(http.StatusNotFound)\n\t}))\n\n\treq, err := http.NewRequest(\"GET\", \"http://localhost:3000/foobar\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tn.ServeHTTP(recorder, req)\n\texpect(t, recorder.Code, http.StatusNotFound)\n\trefute(t, len(buff.String()), 0)\n}\n\nfunc Test_LoggerURLEncodedString(t *testing.T) {\n\tvar buff bytes.Buffer\n\trecorder := httptest.NewRecorder()\n\n\tl := NewLogger()\n\tl.ALogger = log.New(&buff, \"[negroni] \", 0)\n\tl.SetFormat(\"{{.Path}}\")\n\n\tn := New()\n\t// replace log for testing\n\tn.Use(l)\n\tn.UseHandler(http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {\n\t\trw.WriteHeader(http.StatusOK)\n\t}))\n\n\t// Test reserved characters - !*'();:@&=+$,/?%#[]\n\treq, err := http.NewRequest(\"GET\", \"http://localhost:3000/%21%2A%27%28%29%3B%3A%40%26%3D%2B%24%2C%2F%3F%25%23%5B%5D\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tn.ServeHTTP(recorder, req)\n\texpect(t, recorder.Code, http.StatusOK)\n\texpect(t, strings.TrimSpace(buff.String()), \"[negroni] /!*'();:@&=+$,/?%#[]\")\n\trefute(t, len(buff.String()), 0)\n}\n\nfunc Test_LoggerCustomFormat(t *testing.T) {\n\tvar buff bytes.Buffer\n\trecorder := httptest.NewRecorder()\n\n\tl := NewLogger()\n\tl.ALogger = log.New(&buff, \"[negroni] \", 0)\n\tl.SetFormat(\"{{.Request.URL.Query.Get \\\"foo\\\"}} {{.Request.UserAgent}} - {{.Status}}\")\n\n\tn := New()\n\tn.Use(l)\n\tn.UseHandler(http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {\n\t\trw.Write([]byte(\"OK\"))\n\t}))\n\n\tuserAgent := \"Negroni-Test\"\n\treq, err := http.NewRequest(\"GET\", \"http://localhost:3000/foobar?foo=bar\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\treq.Header.Set(\"User-Agent\", userAgent)\n\n\tn.ServeHTTP(recorder, req)\n\texpect(t, strings.TrimSpace(buff.String()), \"[negroni] bar \"+userAgent+\" - 200\")\n}\n"
        },
        {
          "name": "negroni.go",
          "type": "blob",
          "size": 5.541015625,
          "content": "package negroni\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n)\n\nconst (\n\t// DefaultAddress is used if no other is specified.\n\tDefaultAddress = \":8080\"\n)\n\nfunc init() {\n\tinitFeaturePicker()\n}\n\n// Handler handler is an interface that objects can implement to be registered to serve as middleware\n// in the Negroni middleware stack.\n// ServeHTTP should yield to the next middleware in the chain by invoking the next http.HandlerFunc\n// passed in.\n//\n// If the Handler writes to the ResponseWriter, the next http.HandlerFunc should not be invoked.\ntype Handler interface {\n\tServeHTTP(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc)\n}\n\n// HandlerFunc is an adapter to allow the use of ordinary functions as Negroni handlers.\n// If f is a function with the appropriate signature, HandlerFunc(f) is a Handler object that calls f.\ntype HandlerFunc func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc)\n\nfunc (h HandlerFunc) ServeHTTP(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\th(rw, r, next)\n}\n\ntype middleware struct {\n\thandler Handler\n\n\t// nextfn stores the next.ServeHTTP to reduce memory allocate\n\tnextfn func(rw http.ResponseWriter, r *http.Request)\n}\n\nfunc newMiddleware(handler Handler, next *middleware) middleware {\n\treturn middleware{\n\t\thandler: handler,\n\t\tnextfn:  next.ServeHTTP,\n\t}\n}\n\nfunc (m middleware) ServeHTTP(rw http.ResponseWriter, r *http.Request) {\n\tm.handler.ServeHTTP(rw, r, m.nextfn)\n}\n\n// Wrap converts a http.Handler into a negroni.Handler so it can be used as a Negroni\n// middleware. The next http.HandlerFunc is automatically called after the Handler\n// is executed.\nfunc Wrap(handler http.Handler) Handler {\n\treturn HandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\t\thandler.ServeHTTP(rw, r)\n\t\tnext(rw, r)\n\t})\n}\n\n// WrapFunc converts a http.HandlerFunc into a negroni.Handler so it can be used as a Negroni\n// middleware. The next http.HandlerFunc is automatically called after the Handler\n// is executed.\nfunc WrapFunc(handlerFunc http.HandlerFunc) Handler {\n\treturn HandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\t\thandlerFunc(rw, r)\n\t\tnext(rw, r)\n\t})\n}\n\n// Negroni is a stack of Middleware Handlers that can be invoked as an http.Handler.\n// Negroni middleware is evaluated in the order that they are added to the stack using\n// the Use and UseHandler methods.\ntype Negroni struct {\n\tmiddleware middleware\n\thandlers   []Handler\n}\n\n// New returns a new Negroni instance with no middleware preconfigured.\nfunc New(handlers ...Handler) *Negroni {\n\treturn &Negroni{\n\t\thandlers:   handlers,\n\t\tmiddleware: build(handlers),\n\t}\n}\n\n// With returns a new Negroni instance that is a combination of the negroni\n// receiver's handlers and the provided handlers.\nfunc (n *Negroni) With(handlers ...Handler) *Negroni {\n\tcurrentHandlers := make([]Handler, len(n.handlers))\n\tcopy(currentHandlers, n.handlers)\n\treturn New(\n\t\tappend(currentHandlers, handlers...)...,\n\t)\n}\n\n// Classic returns a new Negroni instance with the default middleware already\n// in the stack.\n//\n// Recovery - Panic Recovery Middleware\n// Logger - Request/Response Logging\n// Static - Static File Serving\nfunc Classic() *Negroni {\n\treturn New(NewRecovery(), NewLogger(), NewStatic(http.Dir(\"public\")))\n}\n\nfunc (n *Negroni) ServeHTTP(rw http.ResponseWriter, r *http.Request) {\n\tn.middleware.ServeHTTP(NewResponseWriter(rw), r)\n}\n\n// Use adds a Handler onto the middleware stack. Handlers are invoked in the order they are added to a Negroni.\nfunc (n *Negroni) Use(handler Handler) {\n\tif handler == nil {\n\t\tpanic(\"handler cannot be nil\")\n\t}\n\n\tn.handlers = append(n.handlers, handler)\n\tn.middleware = build(n.handlers)\n}\n\n// UseFunc adds a Negroni-style handler function onto the middleware stack.\nfunc (n *Negroni) UseFunc(handlerFunc func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc)) {\n\tn.Use(HandlerFunc(handlerFunc))\n}\n\n// UseHandler adds a http.Handler onto the middleware stack. Handlers are invoked in the order they are added to a Negroni.\nfunc (n *Negroni) UseHandler(handler http.Handler) {\n\tn.Use(Wrap(handler))\n}\n\n// UseHandlerFunc adds a http.HandlerFunc-style handler function onto the middleware stack.\nfunc (n *Negroni) UseHandlerFunc(handlerFunc func(rw http.ResponseWriter, r *http.Request)) {\n\tn.UseHandler(http.HandlerFunc(handlerFunc))\n}\n\n// Run is a convenience function that runs the negroni stack as an HTTP\n// server. The addr string, if provided, takes the same format as http.ListenAndServe.\n// If no address is provided but the PORT environment variable is set, the PORT value is used.\n// If neither is provided, the address' value will equal the DefaultAddress constant.\nfunc (n *Negroni) Run(addr ...string) {\n\tl := log.New(os.Stdout, \"[negroni] \", 0)\n\tfinalAddr := detectAddress(addr...)\n\tl.Printf(\"listening on %s\", finalAddr)\n\tl.Fatal(http.ListenAndServe(finalAddr, n))\n}\n\nfunc detectAddress(addr ...string) string {\n\tif len(addr) > 0 {\n\t\treturn addr[0]\n\t}\n\tif port := os.Getenv(\"PORT\"); port != \"\" {\n\t\treturn \":\" + port\n\t}\n\treturn DefaultAddress\n}\n\n// Returns a list of all the handlers in the current Negroni middleware chain.\nfunc (n *Negroni) Handlers() []Handler {\n\treturn n.handlers\n}\n\nfunc build(handlers []Handler) middleware {\n\tvar next middleware\n\n\tswitch {\n\tcase len(handlers) == 0:\n\t\treturn voidMiddleware()\n\tcase len(handlers) > 1:\n\t\tnext = build(handlers[1:])\n\tdefault:\n\t\tnext = voidMiddleware()\n\t}\n\n\treturn newMiddleware(handlers[0], &next)\n}\n\nfunc voidMiddleware() middleware {\n\treturn newMiddleware(\n\t\tHandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {}),\n\t\t&middleware{},\n\t)\n}\n"
        },
        {
          "name": "negroni_bench_test.go",
          "type": "blob",
          "size": 0.5830078125,
          "content": "package negroni\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n)\n\ntype voidHandler struct{}\n\nfunc (vh *voidHandler) ServeHTTP(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\tnext(rw, r)\n}\n\nfunc BenchmarkNegroni(b *testing.B) {\n\th1 := &voidHandler{}\n\th2 := &voidHandler{}\n\th3 := &voidHandler{}\n\th4 := &voidHandler{}\n\th5 := &voidHandler{}\n\th6 := &voidHandler{}\n\th7 := &voidHandler{}\n\th8 := &voidHandler{}\n\th9 := &voidHandler{}\n\th10 := &voidHandler{}\n\n\tn := New(h1, h2, h3, h4, h5, h6, h7, h8, h9, h10)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tn.ServeHTTP(nil, nil)\n\t}\n}\n"
        },
        {
          "name": "negroni_test.go",
          "type": "blob",
          "size": 5.2685546875,
          "content": "package negroni\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"reflect\"\n\t\"testing\"\n)\n\n/* Test Helpers */\nfunc expect(t *testing.T, a interface{}, b interface{}) {\n\tif a != b {\n\t\tt.Errorf(\"Expected %v (type %v) - Got %v (type %v)\", b, reflect.TypeOf(b), a, reflect.TypeOf(a))\n\t}\n}\n\nfunc refute(t *testing.T, a interface{}, b interface{}) {\n\tif a == b {\n\t\tt.Errorf(\"Did not expect %v (type %v) - Got %v (type %v)\", b, reflect.TypeOf(b), a, reflect.TypeOf(a))\n\t}\n}\n\nfunc TestNegroniRun(t *testing.T) {\n\t// just test that Run doesn't bomb\n\tgo New().Run(\":3000\")\n}\n\nfunc TestNegroniWith(t *testing.T) {\n\tresult := \"\"\n\tresponse := httptest.NewRecorder()\n\n\tn1 := New()\n\tn1.Use(HandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\t\tresult = \"one\"\n\t\tnext(rw, r)\n\t}))\n\tn1.Use(HandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\t\tresult += \"two\"\n\t\tnext(rw, r)\n\t}))\n\n\tn1.ServeHTTP(response, (*http.Request)(nil))\n\texpect(t, 2, len(n1.Handlers()))\n\texpect(t, result, \"onetwo\")\n\n\tn2 := n1.With(HandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\t\tresult += \"three\"\n\t\tnext(rw, r)\n\t}))\n\n\t// Verify that n1 was left intact and not modified.\n\tn1.ServeHTTP(response, (*http.Request)(nil))\n\texpect(t, 2, len(n1.Handlers()))\n\texpect(t, result, \"onetwo\")\n\n\tn2.ServeHTTP(response, (*http.Request)(nil))\n\texpect(t, 3, len(n2.Handlers()))\n\texpect(t, result, \"onetwothree\")\n}\n\nfunc TestNegroniWith_doNotModifyOriginal(t *testing.T) {\n\tresult := \"\"\n\tresponse := httptest.NewRecorder()\n\n\tn1 := New()\n\tn1.handlers = make([]Handler, 0, 10) // enforce initial capacity\n\tn1.Use(HandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\t\tresult = \"one\"\n\t\tnext(rw, r)\n\t}))\n\n\tn1.ServeHTTP(response, (*http.Request)(nil))\n\texpect(t, 1, len(n1.Handlers()))\n\n\tn2 := n1.With(HandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\t\tresult += \"two\"\n\t\tnext(rw, r)\n\t}))\n\tn3 := n1.With(HandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\t\tresult += \"three\"\n\t\tnext(rw, r)\n\t}))\n\n\t// rebuilds middleware\n\tn2.UseHandlerFunc(func(rw http.ResponseWriter, r *http.Request) {})\n\tn3.UseHandlerFunc(func(rw http.ResponseWriter, r *http.Request) {})\n\n\tn1.ServeHTTP(response, (*http.Request)(nil))\n\texpect(t, 1, len(n1.Handlers()))\n\texpect(t, result, \"one\")\n\n\tn2.ServeHTTP(response, (*http.Request)(nil))\n\texpect(t, 3, len(n2.Handlers()))\n\texpect(t, result, \"onetwo\")\n\n\tn3.ServeHTTP(response, (*http.Request)(nil))\n\texpect(t, 3, len(n3.Handlers()))\n\texpect(t, result, \"onethree\")\n}\n\nfunc TestNegroniServeHTTP(t *testing.T) {\n\tresult := \"\"\n\tresponse := httptest.NewRecorder()\n\n\tn := New()\n\tn.Use(HandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\t\tresult += \"foo\"\n\t\tnext(rw, r)\n\t\tresult += \"ban\"\n\t}))\n\tn.Use(HandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\t\tresult += \"bar\"\n\t\tnext(rw, r)\n\t\tresult += \"baz\"\n\t}))\n\tn.Use(HandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\t\tresult += \"bat\"\n\t\trw.WriteHeader(http.StatusBadRequest)\n\t}))\n\n\tn.ServeHTTP(response, (*http.Request)(nil))\n\n\texpect(t, result, \"foobarbatbazban\")\n\texpect(t, response.Code, http.StatusBadRequest)\n}\n\n// Ensures that a Negroni middleware chain\n// can correctly return all of its handlers.\nfunc TestHandlers(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\tn := New()\n\thandlers := n.Handlers()\n\texpect(t, 0, len(handlers))\n\n\tn.Use(HandlerFunc(func(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\t\trw.WriteHeader(http.StatusOK)\n\t}))\n\n\t// Expects the length of handlers to be exactly 1\n\t// after adding exactly one handler to the middleware chain\n\thandlers = n.Handlers()\n\texpect(t, 1, len(handlers))\n\n\t// Ensures that the first handler that is in sequence behaves\n\t// exactly the same as the one that was registered earlier\n\thandlers[0].ServeHTTP(response, (*http.Request)(nil), nil)\n\texpect(t, response.Code, http.StatusOK)\n}\n\nfunc TestNegroni_Use_Nil(t *testing.T) {\n\tdefer func() {\n\t\terr := recover()\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Expected negroni.Use(nil) to panic, but it did not\")\n\t\t}\n\t}()\n\n\tn := New()\n\tn.Use(nil)\n}\n\nfunc TestDetectAddress(t *testing.T) {\n\tif detectAddress() != DefaultAddress {\n\t\tt.Error(\"Expected the DefaultAddress\")\n\t}\n\n\tif detectAddress(\":6060\") != \":6060\" {\n\t\tt.Error(\"Expected the provided address\")\n\t}\n\n\tos.Setenv(\"PORT\", \"8080\")\n\tif detectAddress() != \":8080\" {\n\t\tt.Error(\"Expected the PORT env var with a prefixed colon\")\n\t}\n}\n\nfunc voidHTTPHandlerFunc(rw http.ResponseWriter, r *http.Request) {\n\t// Do nothing\n}\n\n// Test for function Wrap\nfunc TestWrap(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\n\thandler := Wrap(http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {\n\t\trw.WriteHeader(http.StatusOK)\n\t}))\n\n\thandler.ServeHTTP(response, (*http.Request)(nil), voidHTTPHandlerFunc)\n\n\texpect(t, response.Code, http.StatusOK)\n}\n\n// Test for function WrapFunc\nfunc TestWrapFunc(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\n\t// WrapFunc(f) equals Wrap(http.HandlerFunc(f)), it's simpler and useful.\n\thandler := WrapFunc(func(rw http.ResponseWriter, r *http.Request) {\n\t\trw.WriteHeader(http.StatusOK)\n\t})\n\n\thandler.ServeHTTP(response, (*http.Request)(nil), voidHTTPHandlerFunc)\n\n\texpect(t, response.Code, http.StatusOK)\n}\n"
        },
        {
          "name": "recovery.go",
          "type": "blob",
          "size": 5.642578125,
          "content": "package negroni\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"runtime\"\n\t\"runtime/debug\"\n\t\"text/template\"\n)\n\nconst (\n\t// NoPrintStackBodyString is the body content returned when HTTP stack printing is suppressed\n\tNoPrintStackBodyString = \"500 Internal Server Error\"\n\n\tpanicText = \"PANIC: %s\\n%s\"\n\tpanicHTML = `<html>\n<head><title>PANIC: {{.RecoveredPanic}}</title></head>\n<style type=\"text/css\">\nhtml, body {\n\tfont-family: Helvetica, Arial, Sans;\n\tcolor: #333333;\n\tbackground-color: #ffffff;\n\tmargin: 0px;\n}\nh1 {\n\tcolor: #ffffff;\n\tbackground-color: #f14c4c;\n\tpadding: 20px;\n\tborder-bottom: 1px solid #2b3848;\n}\n.block {\n\tmargin: 2em;\n}\n.panic-interface {\n}\n\n.panic-stack-raw pre {\n\tpadding: 1em;\n\tbackground: #f6f8fa;\n\tborder: dashed 1px;\n}\n.panic-interface-title {\n\tfont-weight: bold;\n}\n</style>\n<body>\n<h1>Negroni - PANIC</h1>\n\n<div class=\"panic-interface block\">\n\t<h3>{{.RequestDescription}}</h3>\n\t<span class=\"panic-interface-title\">Runtime error:</span> <span class=\"panic-interface-element\">{{.RecoveredPanic}}</span>\n</div>\n\n{{ if .Stack }}\n<div class=\"panic-stack-raw block\">\n\t<h3>Runtime Stack</h3>\n\t<pre>{{.StackAsString}}</pre>\n</div>\n{{ end }}\n\n</body>\n</html>`\n\tnilRequestMessage = \"Request is nil\"\n)\n\nvar panicHTMLTemplate = template.Must(template.New(\"PanicPage\").Parse(panicHTML))\n\n// PanicInformation contains all\n// elements for printing stack informations.\ntype PanicInformation struct {\n\tRecoveredPanic interface{}\n\tStack          []byte\n\tRequest        *http.Request\n}\n\n// StackAsString returns a printable version of the stack\nfunc (p *PanicInformation) StackAsString() string {\n\treturn string(p.Stack)\n}\n\n// RequestDescription returns a printable description of the url\nfunc (p *PanicInformation) RequestDescription() string {\n\n\tif p.Request == nil {\n\t\treturn nilRequestMessage\n\t}\n\n\tvar queryOutput string\n\tif p.Request.URL.RawQuery != \"\" {\n\t\tqueryOutput = \"?\" + p.Request.URL.RawQuery\n\t}\n\treturn fmt.Sprintf(\"%s %s%s\", p.Request.Method, p.Request.URL.Path, queryOutput)\n}\n\n// PanicFormatter is an interface on object can implement\n// to be able to output the stack trace\ntype PanicFormatter interface {\n\t// FormatPanicError output the stack for a given answer/response.\n\t// In case the the middleware should not output the stack trace,\n\t// the field `Stack` of the passed `PanicInformation` instance equals `[]byte{}`.\n\tFormatPanicError(rw http.ResponseWriter, r *http.Request, infos *PanicInformation)\n}\n\n// TextPanicFormatter output the stack\n// as simple text on os.Stdout. If no `Content-Type` is set,\n// it will output the data as `text/plain; charset=utf-8`.\n// Otherwise, the origin `Content-Type` is kept.\ntype TextPanicFormatter struct{}\n\nfunc (t *TextPanicFormatter) FormatPanicError(rw http.ResponseWriter, r *http.Request, infos *PanicInformation) {\n\tif rw.Header().Get(\"Content-Type\") == \"\" {\n\t\trw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n\t}\n\tfmt.Fprintf(rw, panicText, infos.RecoveredPanic, infos.Stack)\n}\n\n// HTMLPanicFormatter output the stack inside\n// an HTML page. This has been largely inspired by\n// https://github.com/go-martini/martini/pull/156/commits.\ntype HTMLPanicFormatter struct{}\n\nfunc (t *HTMLPanicFormatter) FormatPanicError(rw http.ResponseWriter, r *http.Request, infos *PanicInformation) {\n\tif rw.Header().Get(\"Content-Type\") == \"\" {\n\t\trw.Header().Set(\"Content-Type\", \"text/html; charset=utf-8\")\n\t}\n\tpanicHTMLTemplate.Execute(rw, infos)\n}\n\n// Recovery is a Negroni middleware that recovers from any panics and writes a 500 if there was one.\ntype Recovery struct {\n\tLogger           ALogger\n\tPrintStack       bool\n\tLogStack         bool\n\tPanicHandlerFunc func(*PanicInformation)\n\tStackAll         bool\n\tStackSize        int\n\tFormatter        PanicFormatter\n\n\t// Deprecated: Use PanicHandlerFunc instead to receive panic\n\t// error with additional information (see PanicInformation)\n\tErrorHandlerFunc func(interface{})\n}\n\n// NewRecovery returns a new instance of Recovery\nfunc NewRecovery() *Recovery {\n\treturn &Recovery{\n\t\tLogger:     log.New(os.Stdout, \"[negroni] \", 0),\n\t\tPrintStack: true,\n\t\tLogStack:   true,\n\t\tStackAll:   false,\n\t\tStackSize:  1024 * 8,\n\t\tFormatter:  &TextPanicFormatter{},\n\t}\n}\n\nfunc (rec *Recovery) ServeHTTP(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\trw.WriteHeader(http.StatusInternalServerError)\n\n\t\t\tinfos := &PanicInformation{\n\t\t\t\tRecoveredPanic: err,\n\t\t\t\tRequest:        r,\n\t\t\t\tStack:          make([]byte, rec.StackSize),\n\t\t\t}\n\t\t\tinfos.Stack = infos.Stack[:runtime.Stack(infos.Stack, rec.StackAll)]\n\n\t\t\t// PrintStack will write stack trace info to the ResponseWriter if set to true!\n\t\t\t// If set to false it will respond with the standard response documented here https://httpstat.us/500\n\t\t\tif rec.PrintStack && rec.Formatter != nil {\n\t\t\t\trec.Formatter.FormatPanicError(rw, r, infos)\n\t\t\t} else {\n\t\t\t\tif rw.Header().Get(\"Content-Type\") == \"\" {\n\t\t\t\t\trw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n\t\t\t\t}\n\t\t\t\tfmt.Fprint(rw, NoPrintStackBodyString)\n\t\t\t}\n\n\t\t\tif rec.LogStack {\n\t\t\t\trec.Logger.Printf(panicText, err, infos.Stack)\n\t\t\t}\n\n\t\t\tif rec.ErrorHandlerFunc != nil {\n\t\t\t\tfunc() {\n\t\t\t\t\tdefer func() {\n\t\t\t\t\t\tif err := recover(); err != nil {\n\t\t\t\t\t\t\trec.Logger.Printf(\"provided ErrorHandlerFunc panic'd: %s, trace:\\n%s\", err, debug.Stack())\n\t\t\t\t\t\t\trec.Logger.Printf(\"%s\\n\", debug.Stack())\n\t\t\t\t\t\t}\n\t\t\t\t\t}()\n\t\t\t\t\trec.ErrorHandlerFunc(err)\n\t\t\t\t}()\n\t\t\t}\n\t\t\tif rec.PanicHandlerFunc != nil {\n\t\t\t\tfunc() {\n\t\t\t\t\tdefer func() {\n\t\t\t\t\t\tif err := recover(); err != nil {\n\t\t\t\t\t\t\trec.Logger.Printf(\"provided PanicHandlerFunc panic'd: %s, trace:\\n%s\", err, debug.Stack())\n\t\t\t\t\t\t\trec.Logger.Printf(\"%s\\n\", debug.Stack())\n\t\t\t\t\t\t}\n\t\t\t\t\t}()\n\t\t\t\t\trec.PanicHandlerFunc(infos)\n\t\t\t\t}()\n\t\t\t}\n\t\t}\n\t}()\n\n\tnext(rw, r)\n}\n"
        },
        {
          "name": "recovery_test.go",
          "type": "blob",
          "size": 4.892578125,
          "content": "package negroni\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestRecovery(t *testing.T) {\n\tbuff := bytes.NewBufferString(\"\")\n\trecorder := httptest.NewRecorder()\n\tpanicHandlerCalled := false\n\thandlerCalled := false\n\n\trec := NewRecovery()\n\trec.Logger = log.New(buff, \"[negroni] \", 0)\n\trec.ErrorHandlerFunc = func(i interface{}) {\n\t\thandlerCalled = true\n\t}\n\trec.PanicHandlerFunc = func(i *PanicInformation) {\n\t\tpanicHandlerCalled = (i != nil)\n\t}\n\n\tn := New()\n\t// replace log for testing\n\tn.Use(rec)\n\tn.UseHandler(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n\t\tpanic(\"here is a panic!\")\n\t}))\n\tn.ServeHTTP(recorder, (*http.Request)(nil))\n\texpect(t, recorder.Header().Get(\"Content-Type\"), \"text/plain; charset=utf-8\")\n\texpect(t, recorder.Code, http.StatusInternalServerError)\n\texpect(t, panicHandlerCalled, true)\n\texpect(t, handlerCalled, true)\n\trefute(t, recorder.Body.Len(), 0)\n\trefute(t, len(buff.String()), 0)\n}\n\nfunc TestRecovery_noContentTypeOverwrite(t *testing.T) {\n\trecorder := httptest.NewRecorder()\n\n\trec := NewRecovery()\n\trec.Logger = log.New(bytes.NewBuffer([]byte{}), \"[negroni] \", 0)\n\n\tn := New()\n\tn.Use(rec)\n\tn.UseHandler(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript; charset=utf-8\")\n\t\tpanic(\"here is a panic!\")\n\t}))\n\tn.ServeHTTP(recorder, (*http.Request)(nil))\n\texpect(t, recorder.Header().Get(\"Content-Type\"), \"application/javascript; charset=utf-8\")\n}\n\nfunc TestRecovery_callbackPanic(t *testing.T) {\n\tbuff := bytes.NewBufferString(\"\")\n\trecorder := httptest.NewRecorder()\n\n\trec := NewRecovery()\n\trec.Logger = log.New(buff, \"[negroni] \", 0)\n\trec.ErrorHandlerFunc = func(i interface{}) {\n\t\tpanic(\"callback panic\")\n\t}\n\n\tn := New()\n\tn.Use(rec)\n\tn.UseHandler(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n\t\tpanic(\"here is a panic!\")\n\t}))\n\tn.ServeHTTP(recorder, (*http.Request)(nil))\n\n\texpect(t, strings.Contains(buff.String(), \"callback panic\"), true)\n}\n\nfunc TestRecovery_handlerPanic(t *testing.T) {\n\tbuff := bytes.NewBufferString(\"\")\n\trecorder := httptest.NewRecorder()\n\n\trec := NewRecovery()\n\trec.Logger = log.New(buff, \"[negroni] \", 0)\n\trec.PanicHandlerFunc = func(i *PanicInformation) {\n\t\tpanic(\"panic handler panic\")\n\t}\n\n\tn := New()\n\tn.Use(rec)\n\tn.UseHandler(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n\t\tpanic(\"here is a panic!\")\n\t}))\n\tn.ServeHTTP(recorder, (*http.Request)(nil))\n\n\texpect(t, strings.Contains(buff.String(), \"panic handler panic\"), true)\n}\n\ntype testOutput struct {\n\t*bytes.Buffer\n}\n\nfunc newTestOutput() *testOutput {\n\tbuf := bytes.NewBufferString(\"\")\n\treturn &testOutput{buf}\n}\n\nfunc (t *testOutput) FormatPanicError(rw http.ResponseWriter, r *http.Request, infos *PanicInformation) {\n\tfmt.Fprintf(t, formatInfos(infos))\n}\n\nfunc formatInfos(infos *PanicInformation) string {\n\treturn fmt.Sprintf(\"%s %s\", infos.RequestDescription(), infos.RecoveredPanic)\n}\nfunc TestRecovery_formatter(t *testing.T) {\n\trecorder := httptest.NewRecorder()\n\tformatter := newTestOutput()\n\n\treq, _ := http.NewRequest(\"GET\", \"http://localhost:3003/somePath?element=true\", nil)\n\tvar element interface{} = \"here is a panic!\"\n\texpectedInfos := &PanicInformation{RecoveredPanic: element, Request: req}\n\n\trec := NewRecovery()\n\trec.Formatter = formatter\n\tn := New()\n\tn.Use(rec)\n\tn.UseHandler(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n\t\tpanic(element)\n\t}))\n\n\tn.ServeHTTP(recorder, req)\n\n\texpect(t, formatInfos(expectedInfos), formatter.String())\n}\n\nfunc TestRecovery_PanicInformation(t *testing.T) {\n\t// Request with query\n\treq, _ := http.NewRequest(\"GET\", \"http://localhost:3003/somePath?element=true\", nil)\n\tvar element interface{} = \"here is a panic!\"\n\texpectedInfos := &PanicInformation{RecoveredPanic: element, Request: req}\n\n\texpect(t, expectedInfos.RequestDescription(), \"GET /somePath?element=true\")\n\n\t// Request without Query\n\treq, _ = http.NewRequest(\"POST\", \"http://localhost:3003/somePath\", nil)\n\telement = \"here is a panic!\"\n\texpectedInfos = &PanicInformation{RecoveredPanic: element, Request: req}\n\n\texpect(t, expectedInfos.RequestDescription(), \"POST /somePath\")\n\n\t// Nil request\n\texpectedInfos = &PanicInformation{RecoveredPanic: element, Request: nil}\n\texpect(t, expectedInfos.RequestDescription(), nilRequestMessage)\n\n\t// Stack\n\tstackValue := \"Some Stack element\"\n\texpectedInfos = &PanicInformation{RecoveredPanic: element, Request: req, Stack: []byte(stackValue)}\n\texpect(t, expectedInfos.StackAsString(), stackValue)\n}\n\nfunc TestRecovery_HTMLFormatter(t *testing.T) {\n\trecorder := httptest.NewRecorder()\n\trec := NewRecovery()\n\trec.Formatter = &HTMLPanicFormatter{}\n\tn := New()\n\tn.Use(rec)\n\tn.UseHandler(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n\t\tpanic(\"some panic\")\n\t}))\n\n\tn.ServeHTTP(recorder, (*http.Request)(nil))\n\texpect(t, recorder.Header().Get(\"Content-Type\"), \"text/html; charset=utf-8\")\n\trefute(t, recorder.Body.Len(), 0)\n}\n"
        },
        {
          "name": "response_writer.go",
          "type": "blob",
          "size": 3.240234375,
          "content": "package negroni\n\nimport (\n\t\"io\"\n\t\"net/http\"\n)\n\n// ResponseWriter is a wrapper around http.ResponseWriter that provides extra information about\n// the response. It is recommended that middleware handlers use this construct to wrap a responsewriter\n// if the functionality calls for it.\ntype ResponseWriter interface {\n\thttp.ResponseWriter\n\n\t// Status returns the status code of the response or 0 if the response has\n\t// not been written\n\tStatus() int\n\t// Written returns whether or not the ResponseWriter has been written.\n\tWritten() bool\n\t// Size returns the size of the response body.\n\tSize() int\n\t// Before allows for a function to be called before the ResponseWriter has been written to. This is\n\t// useful for setting headers or any other operations that must happen before a response has been written.\n\tBefore(func(ResponseWriter))\n}\n\ntype beforeFunc func(ResponseWriter)\n\n// NewResponseWriter creates a ResponseWriter that wraps a http.ResponseWriter\nfunc NewResponseWriter(rw http.ResponseWriter) ResponseWriter {\n\tnrw := &responseWriter{\n\t\tResponseWriter: rw,\n\t}\n\n\treturn wrapFeature(nrw)\n}\n\ntype responseWriter struct {\n\thttp.ResponseWriter\n\tpendingStatus  int\n\tstatus         int\n\tsize           int\n\tbeforeFuncs    []beforeFunc\n\tcallingBefores bool\n}\n\nfunc (rw *responseWriter) WriteHeader(s int) {\n\tif rw.Written() {\n\t\treturn\n\t}\n\n\trw.pendingStatus = s\n\trw.callBefore()\n\n\t// Any of the rw.beforeFuncs may have written a header,\n\t// so check again to see if any work is necessary.\n\tif rw.Written() {\n\t\treturn\n\t}\n\n\trw.status = s\n\trw.ResponseWriter.WriteHeader(s)\n}\n\nfunc (rw *responseWriter) Write(b []byte) (int, error) {\n\tif !rw.Written() {\n\t\t// The status will be StatusOK if WriteHeader has not been called yet\n\t\trw.WriteHeader(http.StatusOK)\n\t}\n\tsize, err := rw.ResponseWriter.Write(b)\n\trw.size += size\n\treturn size, err\n}\n\n// ReadFrom exposes underlying http.ResponseWriter to io.Copy and if it implements\n// io.ReaderFrom, it can take advantage of optimizations such as sendfile, io.Copy\n// with sync.Pool's buffer which is in http.(*response).ReadFrom and so on.\nfunc (rw *responseWriter) ReadFrom(r io.Reader) (n int64, err error) {\n\tif !rw.Written() {\n\t\t// The status will be StatusOK if WriteHeader has not been called yet\n\t\trw.WriteHeader(http.StatusOK)\n\t}\n\tn, err = io.Copy(rw.ResponseWriter, r)\n\trw.size += int(n)\n\treturn\n}\n\n// Satisfy http.ResponseController support (Go 1.20+)\nfunc (rw *responseWriter) Unwrap() http.ResponseWriter {\n\treturn rw.ResponseWriter\n}\n\nfunc (rw *responseWriter) Status() int {\n\tif rw.Written() {\n\t\treturn rw.status\n\t}\n\n\treturn rw.pendingStatus\n}\n\nfunc (rw *responseWriter) Size() int {\n\treturn rw.size\n}\n\nfunc (rw *responseWriter) Written() bool {\n\treturn rw.status >= http.StatusOK || rw.status == http.StatusSwitchingProtocols // treat all 1xx codes aside from SwitchingProtocols as non-terminal\n}\n\nfunc (rw *responseWriter) Before(before func(ResponseWriter)) {\n\trw.beforeFuncs = append(rw.beforeFuncs, before)\n}\n\nfunc (rw *responseWriter) callBefore() {\n\t// Don't recursively call before() functions, to avoid infinite looping if\n\t// one of them calls rw.WriteHeader again.\n\tif rw.callingBefores {\n\t\treturn\n\t}\n\n\trw.callingBefores = true\n\tdefer func() { rw.callingBefores = false }()\n\n\tfor i := len(rw.beforeFuncs) - 1; i >= 0; i-- {\n\t\trw.beforeFuncs[i](rw)\n\t}\n}\n"
        },
        {
          "name": "response_writer_feature.go",
          "type": "blob",
          "size": 2.4951171875,
          "content": "package negroni\n\nimport (\n\t\"bufio\"\n\t\"net\"\n\t\"net/http\"\n)\n\nconst (\n\tflusher = 1 << iota\n\thijacker\n\tcloseNotifier\n)\n\ntype (\n\tflusherFeature       struct{ *responseWriter }\n\thijackerFeature      struct{ *responseWriter }\n\tcloseNotifierFeature struct{ *responseWriter }\n)\n\nfunc (f flusherFeature) Flush() {\n\tif !f.Written() {\n\t\t// The status will be StatusOK if WriteHeader has not been called yet\n\t\tf.WriteHeader(http.StatusOK)\n\t}\n\tf.ResponseWriter.(http.Flusher).Flush()\n}\n\nfunc (f hijackerFeature) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\treturn f.ResponseWriter.(http.Hijacker).Hijack()\n}\n\nfunc (f closeNotifierFeature) CloseNotify() <-chan bool {\n\treturn f.ResponseWriter.(http.CloseNotifier).CloseNotify()\n}\n\nvar featurePicker = make([]func(writer *responseWriter) ResponseWriter, 8)\n\nfunc initFeaturePicker() {\n\tfeaturePicker[0] = func(w *responseWriter) ResponseWriter {\n\t\treturn w\n\t}\n\tfeaturePicker[flusher] = func(w *responseWriter) ResponseWriter {\n\t\treturn struct {\n\t\t\t*responseWriter\n\t\t\thttp.Flusher\n\t\t}{w, flusherFeature{w}}\n\t}\n\tfeaturePicker[hijacker] = func(w *responseWriter) ResponseWriter {\n\t\treturn struct {\n\t\t\t*responseWriter\n\t\t\thttp.Hijacker\n\t\t}{w, hijackerFeature{w}}\n\t}\n\tfeaturePicker[closeNotifier] = func(w *responseWriter) ResponseWriter {\n\t\treturn struct {\n\t\t\t*responseWriter\n\t\t\thttp.Flusher\n\t\t}{w, flusherFeature{w}}\n\t}\n\tfeaturePicker[flusher|hijacker] = func(w *responseWriter) ResponseWriter {\n\t\treturn struct {\n\t\t\t*responseWriter\n\t\t\thttp.Flusher\n\t\t\thttp.Hijacker\n\t\t}{w, flusherFeature{w}, hijackerFeature{w}}\n\t}\n\tfeaturePicker[flusher|closeNotifier] = func(w *responseWriter) ResponseWriter {\n\t\treturn struct {\n\t\t\t*responseWriter\n\t\t\thttp.Flusher\n\t\t\thttp.CloseNotifier\n\t\t}{w, flusherFeature{w}, closeNotifierFeature{w}}\n\t}\n\tfeaturePicker[hijacker|closeNotifier] = func(w *responseWriter) ResponseWriter {\n\t\treturn struct {\n\t\t\t*responseWriter\n\t\t\thttp.Hijacker\n\t\t\thttp.CloseNotifier\n\t\t}{w, hijackerFeature{w}, closeNotifierFeature{w}}\n\t}\n\tfeaturePicker[flusher|hijacker|closeNotifier] = func(w *responseWriter) ResponseWriter {\n\t\treturn struct {\n\t\t\t*responseWriter\n\t\t\thttp.Flusher\n\t\t\thttp.Hijacker\n\t\t\thttp.CloseNotifier\n\t\t}{w, flusherFeature{w}, hijackerFeature{w}, closeNotifierFeature{w}}\n\t}\n}\n\nfunc wrapFeature(w *responseWriter) ResponseWriter {\n\trw := w.ResponseWriter\n\n\tfeature := 0\n\tif _, ok := rw.(http.Flusher); ok {\n\t\tfeature |= flusher\n\t}\n\tif _, ok := rw.(http.Hijacker); ok {\n\t\tfeature |= hijacker\n\t}\n\tif _, ok := rw.(http.CloseNotifier); ok {\n\t\tfeature |= closeNotifier\n\t}\n\n\treturn featurePicker[feature](w)\n}\n"
        },
        {
          "name": "response_writer_pusher.go",
          "type": "blob",
          "size": 0.3115234375,
          "content": "//+build go1.8\n\npackage negroni\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n)\n\nfunc (rw *responseWriter) Push(target string, opts *http.PushOptions) error {\n\tpusher, ok := rw.ResponseWriter.(http.Pusher)\n\tif ok {\n\t\treturn pusher.Push(target, opts)\n\t}\n\treturn errors.New(\"the ResponseWriter doesn't support the Pusher interface\")\n}\n"
        },
        {
          "name": "response_writer_pusher_test.go",
          "type": "blob",
          "size": 0.6328125,
          "content": "//+build go1.8\n\npackage negroni\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\ntype pusherRecorder struct {\n\t*httptest.ResponseRecorder\n\tpushed bool\n}\n\nfunc newPusherRecorder() *pusherRecorder {\n\treturn &pusherRecorder{ResponseRecorder: httptest.NewRecorder()}\n}\n\nfunc (c *pusherRecorder) Push(target string, opts *http.PushOptions) error {\n\tc.pushed = true\n\treturn nil\n}\n\nfunc TestResponseWriterPush(t *testing.T) {\n\tpushable := newPusherRecorder()\n\trw := NewResponseWriter(pushable)\n\tpusher, ok := rw.(http.Pusher)\n\texpect(t, ok, true)\n\terr := pusher.Push(\"\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\texpect(t, pushable.pushed, true)\n}\n"
        },
        {
          "name": "response_writer_test.go",
          "type": "blob",
          "size": 7.4921875,
          "content": "package negroni\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype closeNotifyingRecorder struct {\n\t*httptest.ResponseRecorder\n\tclosed chan bool\n}\n\nfunc newCloseNotifyingRecorder() *closeNotifyingRecorder {\n\treturn &closeNotifyingRecorder{\n\t\thttptest.NewRecorder(),\n\t\tmake(chan bool, 1),\n\t}\n}\n\nfunc (c *closeNotifyingRecorder) close() {\n\tc.closed <- true\n}\n\nfunc (c *closeNotifyingRecorder) CloseNotify() <-chan bool {\n\treturn c.closed\n}\n\ntype hijackableResponse struct {\n\tHijacked bool\n}\n\nfunc newHijackableResponse() *hijackableResponse {\n\treturn &hijackableResponse{}\n}\n\nfunc (h *hijackableResponse) Header() http.Header           { return nil }\nfunc (h *hijackableResponse) Write(buf []byte) (int, error) { return 0, nil }\nfunc (h *hijackableResponse) WriteHeader(code int)          {}\nfunc (h *hijackableResponse) Flush()                        {}\nfunc (h *hijackableResponse) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\th.Hijacked = true\n\treturn nil, nil, nil\n}\n\nfunc TestResponseWriterBeforeWrite(t *testing.T) {\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\n\texpect(t, rw.Status(), 0)\n\texpect(t, rw.Written(), false)\n}\n\nfunc TestResponseWriterBeforeFuncHasAccessToStatus(t *testing.T) {\n\tvar status int\n\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\n\trw.Before(func(w ResponseWriter) {\n\t\tstatus = w.Status()\n\t})\n\trw.WriteHeader(http.StatusCreated)\n\n\texpect(t, status, http.StatusCreated)\n}\n\nfunc TestResponseWriterBeforeFuncCanChangeStatus(t *testing.T) {\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\n\t// Always respond with 200.\n\trw.Before(func(w ResponseWriter) {\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n\n\trw.WriteHeader(http.StatusBadRequest)\n\texpect(t, rec.Code, http.StatusOK)\n}\n\nfunc TestResponseWriterBeforeFuncChangesStatusMultipleTimes(t *testing.T) {\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\n\trw.Before(func(w ResponseWriter) {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t})\n\trw.Before(func(w ResponseWriter) {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\trw.WriteHeader(http.StatusOK)\n\texpect(t, rec.Code, http.StatusNotFound)\n}\n\nfunc TestResponseWriterWritingString(t *testing.T) {\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\n\trw.Write([]byte(\"Hello world\"))\n\n\texpect(t, rec.Code, rw.Status())\n\texpect(t, rec.Body.String(), \"Hello world\")\n\texpect(t, rw.Status(), http.StatusOK)\n\texpect(t, rw.Size(), 11)\n\texpect(t, rw.Written(), true)\n}\n\nfunc TestResponseWriterWrittenStatusCode(t *testing.T) {\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\n\texpect(t, rw.Written(), false)\n\tfor status := http.StatusContinue; status <= http.StatusEarlyHints; status++ {\n\t\tif status == http.StatusSwitchingProtocols {\n\t\t\tcontinue\n\t\t}\n\t\trw.WriteHeader(status)\n\t\texpected := false\n\t\texpect(t, rw.Written(), expected)\n\t}\n\trw.WriteHeader(http.StatusCreated)\n\texpect(t, rw.Written(), true)\n\n\trw2 := NewResponseWriter(rec)\n\texpect(t, rw2.Written(), false)\n\trw2.WriteHeader(http.StatusSwitchingProtocols)\n\texpect(t, rw2.Written(), true)\n\n}\n\nfunc TestResponseWriterWritingStrings(t *testing.T) {\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\n\trw.Write([]byte(\"Hello world\"))\n\trw.Write([]byte(\"foo bar bat baz\"))\n\n\texpect(t, rec.Code, rw.Status())\n\texpect(t, rec.Body.String(), \"Hello worldfoo bar bat baz\")\n\texpect(t, rw.Status(), http.StatusOK)\n\texpect(t, rw.Size(), 26)\n}\n\nfunc TestResponseWriterWritingHeader(t *testing.T) {\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\n\trw.WriteHeader(http.StatusNotFound)\n\n\texpect(t, rec.Code, rw.Status())\n\texpect(t, rec.Body.String(), \"\")\n\texpect(t, rw.Status(), http.StatusNotFound)\n\texpect(t, rw.Size(), 0)\n}\n\nfunc TestResponseWriterWritingHeaderTwice(t *testing.T) {\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\n\trw.WriteHeader(http.StatusNotFound)\n\trw.WriteHeader(http.StatusInternalServerError)\n\n\texpect(t, rec.Code, rw.Status())\n\texpect(t, rec.Body.String(), \"\")\n\texpect(t, rw.Status(), http.StatusNotFound)\n\texpect(t, rw.Size(), 0)\n}\n\nfunc TestResponseWriterBefore(t *testing.T) {\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\tresult := \"\"\n\n\trw.Before(func(ResponseWriter) {\n\t\tresult += \"foo\"\n\t})\n\trw.Before(func(ResponseWriter) {\n\t\tresult += \"bar\"\n\t})\n\n\trw.WriteHeader(http.StatusNotFound)\n\n\texpect(t, rec.Code, rw.Status())\n\texpect(t, rec.Body.String(), \"\")\n\texpect(t, rw.Status(), http.StatusNotFound)\n\texpect(t, rw.Size(), 0)\n\texpect(t, result, \"barfoo\")\n}\n\nfunc TestResponseWriterUnwrap(t *testing.T) {\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\tswitch v := rw.(type) {\n\tcase interface{ Unwrap() http.ResponseWriter }:\n\t\texpect(t, v.Unwrap(), rec)\n\tdefault:\n\t\tt.Error(\"Does not implement Unwrap()\")\n\t}\n}\n\nfunc TestResponseWriterHijack(t *testing.T) {\n\thijackable := newHijackableResponse()\n\trw := NewResponseWriter(hijackable)\n\thijacker, ok := rw.(http.Hijacker)\n\texpect(t, ok, true)\n\t_, _, err := hijacker.Hijack()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\texpect(t, hijackable.Hijacked, true)\n}\n\nfunc TestResponseWriteHijackNotOK(t *testing.T) {\n\thijackable := new(http.ResponseWriter)\n\trw := NewResponseWriter(*hijackable)\n\t_, ok := rw.(http.Hijacker)\n\texpect(t, ok, false)\n}\n\nfunc TestResponseWriterCloseNotify(t *testing.T) {\n\trec := newCloseNotifyingRecorder()\n\trw := NewResponseWriter(rec)\n\tclosed := false\n\tnotifier := rw.(http.CloseNotifier).CloseNotify()\n\trec.close()\n\tselect {\n\tcase <-notifier:\n\t\tclosed = true\n\tcase <-time.After(time.Second):\n\t}\n\texpect(t, closed, true)\n}\n\nfunc TestResponseWriterNonCloseNotify(t *testing.T) {\n\trw := NewResponseWriter(httptest.NewRecorder())\n\t_, ok := rw.(http.CloseNotifier)\n\texpect(t, ok, false)\n}\n\nfunc TestResponseWriterFlusher(t *testing.T) {\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\n\t_, ok := rw.(http.Flusher)\n\texpect(t, ok, true)\n}\n\nfunc TestResponseWriter_Flush_marksWritten(t *testing.T) {\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\n\trw.(http.Flusher).Flush()\n\texpect(t, rw.Status(), http.StatusOK)\n\texpect(t, rw.Written(), true)\n}\n\n// mockReader only implements io.Reader without other methods like WriterTo\ntype mockReader struct {\n\treadStr string\n\teof     bool\n}\n\nfunc (r *mockReader) Read(p []byte) (n int, err error) {\n\tif r.eof {\n\t\treturn 0, io.EOF\n\t}\n\tcopy(p, []byte(r.readStr))\n\tr.eof = true\n\treturn len(r.readStr), nil\n}\n\nfunc TestResponseWriterWithoutReadFrom(t *testing.T) {\n\twriteString := \"Hello world\"\n\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\n\tn, err := io.Copy(rw, &mockReader{readStr: writeString})\n\texpect(t, err, nil)\n\texpect(t, rw.Status(), http.StatusOK)\n\texpect(t, rw.Written(), true)\n\texpect(t, rw.Size(), len(writeString))\n\texpect(t, int(n), len(writeString))\n\texpect(t, rec.Body.String(), writeString)\n}\n\ntype mockResponseWriterWithReadFrom struct {\n\t*httptest.ResponseRecorder\n\twrittenStr string\n}\n\nfunc (rw *mockResponseWriterWithReadFrom) ReadFrom(r io.Reader) (n int64, err error) {\n\tbytes, err := io.ReadAll(r)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\trw.writtenStr = string(bytes)\n\trw.ResponseRecorder.Write(bytes)\n\treturn int64(len(bytes)), nil\n}\n\nfunc TestResponseWriterWithReadFrom(t *testing.T) {\n\twriteString := \"Hello world\"\n\tmrw := &mockResponseWriterWithReadFrom{ResponseRecorder: httptest.NewRecorder()}\n\trw := NewResponseWriter(mrw)\n\tn, err := io.Copy(rw, &mockReader{readStr: writeString})\n\texpect(t, err, nil)\n\texpect(t, rw.Status(), http.StatusOK)\n\texpect(t, rw.Written(), true)\n\texpect(t, rw.Size(), len(writeString))\n\texpect(t, int(n), len(writeString))\n\texpect(t, mrw.Body.String(), writeString)\n\texpect(t, mrw.writtenStr, writeString)\n}\n"
        },
        {
          "name": "static.go",
          "type": "blob",
          "size": 2.0166015625,
          "content": "package negroni\n\nimport (\n\t\"net/http\"\n\t\"path\"\n\t\"strings\"\n)\n\n// Static is a middleware handler that serves static files in the given\n// directory/filesystem. If the file does not exist on the filesystem, it\n// passes along to the next middleware in the chain. If you desire \"fileserver\"\n// type behavior where it returns a 404 for unfound files, you should consider\n// using http.FileServer from the Go stdlib.\ntype Static struct {\n\t// Dir is the directory to serve static files from\n\tDir http.FileSystem\n\t// Prefix is the optional prefix used to serve the static directory content\n\tPrefix string\n\t// IndexFile defines which file to serve as index if it exists.\n\tIndexFile string\n}\n\n// NewStatic returns a new instance of Static\nfunc NewStatic(directory http.FileSystem) *Static {\n\treturn &Static{\n\t\tDir:       directory,\n\t\tPrefix:    \"\",\n\t\tIndexFile: \"index.html\",\n\t}\n}\n\nfunc (s *Static) ServeHTTP(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {\n\tif r.Method != \"GET\" && r.Method != \"HEAD\" {\n\t\tnext(rw, r)\n\t\treturn\n\t}\n\tfile := r.URL.Path\n\t// if we have a prefix, filter requests by stripping the prefix\n\tif s.Prefix != \"\" {\n\t\tif !strings.HasPrefix(file, s.Prefix) {\n\t\t\tnext(rw, r)\n\t\t\treturn\n\t\t}\n\t\tfile = file[len(s.Prefix):]\n\t\tif file != \"\" && file[0] != '/' {\n\t\t\tnext(rw, r)\n\t\t\treturn\n\t\t}\n\t}\n\tf, err := s.Dir.Open(file)\n\tif err != nil {\n\t\t// discard the error?\n\t\tnext(rw, r)\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\tfi, err := f.Stat()\n\tif err != nil {\n\t\tnext(rw, r)\n\t\treturn\n\t}\n\n\t// try to serve index file\n\tif fi.IsDir() {\n\t\t// redirect if missing trailing slash\n\t\tif !strings.HasSuffix(r.URL.Path, \"/\") {\n\t\t\tif strings.HasPrefix(r.URL.Path, \"//\") {\n\t\t\t\tr.URL.Path = \"/\" + strings.TrimLeft(r.URL.Path, \"/\")\n\t\t\t}\n\t\t\thttp.Redirect(rw, r, r.URL.Path+\"/\", http.StatusFound)\n\t\t\treturn\n\t\t}\n\n\t\tfile = path.Join(file, s.IndexFile)\n\t\tf, err = s.Dir.Open(file)\n\t\tif err != nil {\n\t\t\tnext(rw, r)\n\t\t\treturn\n\t\t}\n\t\tdefer f.Close()\n\n\t\tfi, err = f.Stat()\n\t\tif err != nil || fi.IsDir() {\n\t\t\tnext(rw, r)\n\t\t\treturn\n\t\t}\n\t}\n\n\thttp.ServeContent(rw, r, file, fi.ModTime(), f)\n}\n"
        },
        {
          "name": "static_test.go",
          "type": "blob",
          "size": 2.3408203125,
          "content": "package negroni\n\nimport (\n\t\"bytes\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\nfunc TestStatic(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\tresponse.Body = new(bytes.Buffer)\n\n\tn := New()\n\tn.Use(NewStatic(http.Dir(\".\")))\n\n\treq, err := http.NewRequest(\"GET\", \"http://localhost:3000/negroni.go\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tn.ServeHTTP(response, req)\n\texpect(t, response.Code, http.StatusOK)\n\texpect(t, response.Header().Get(\"Expires\"), \"\")\n\tif response.Body.Len() == 0 {\n\t\tt.Errorf(\"Got empty body for GET request\")\n\t}\n}\n\nfunc TestStaticHead(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\tresponse.Body = new(bytes.Buffer)\n\n\tn := New()\n\tn.Use(NewStatic(http.Dir(\".\")))\n\tn.UseHandler(http.NotFoundHandler())\n\n\treq, err := http.NewRequest(\"HEAD\", \"http://localhost:3000/negroni.go\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tn.ServeHTTP(response, req)\n\texpect(t, response.Code, http.StatusOK)\n\tif response.Body.Len() != 0 {\n\t\tt.Errorf(\"Got non-empty body for HEAD request\")\n\t}\n}\n\nfunc TestStaticAsPost(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\n\tn := New()\n\tn.Use(NewStatic(http.Dir(\".\")))\n\tn.UseHandler(http.NotFoundHandler())\n\n\treq, err := http.NewRequest(\"POST\", \"http://localhost:3000/negroni.go\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tn.ServeHTTP(response, req)\n\texpect(t, response.Code, http.StatusNotFound)\n}\n\nfunc TestStaticBadDir(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\n\tn := Classic()\n\tn.UseHandler(http.NotFoundHandler())\n\n\treq, err := http.NewRequest(\"GET\", \"http://localhost:3000/negroni.go\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tn.ServeHTTP(response, req)\n\trefute(t, response.Code, http.StatusOK)\n}\n\nfunc TestStaticOptionsServeIndex(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\n\tn := New()\n\ts := NewStatic(http.Dir(\".\"))\n\ts.IndexFile = \"negroni.go\"\n\tn.Use(s)\n\n\treq, err := http.NewRequest(\"GET\", \"http://localhost:3000/\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tn.ServeHTTP(response, req)\n\texpect(t, response.Code, http.StatusOK)\n}\n\nfunc TestStaticOptionsPrefix(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\n\tn := New()\n\ts := NewStatic(http.Dir(\".\"))\n\ts.Prefix = \"/public\"\n\tn.Use(s)\n\n\t// Check file content behaviour\n\treq, err := http.NewRequest(\"GET\", \"http://localhost:3000/public/negroni.go\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tn.ServeHTTP(response, req)\n\texpect(t, response.Code, http.StatusOK)\n}\n"
        },
        {
          "name": "translations",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}