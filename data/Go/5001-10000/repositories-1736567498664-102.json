{
  "metadata": {
    "timestamp": 1736567498664,
    "page": 102,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "pkg/errors",
      "stars": 8206,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.259765625,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.12109375,
          "content": "arch:\n  - amd64\n  \nlanguage: go\ngo_import_path: github.com/pkg/errors\ngo:\n  - 1.14\n  - 1.15\n  - tip\n\nscript:\n  - make check\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.28125,
          "content": "Copyright (c) 2015, Dave Cheney <dave@cheney.net>\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.8505859375,
          "content": "PKGS := github.com/pkg/errors\nSRCDIRS := $(shell go list -f '{{.Dir}}' $(PKGS))\nGO := go\n\ncheck: test vet gofmt misspell unconvert staticcheck ineffassign unparam\n\ntest: \n\t$(GO) test $(PKGS)\n\nvet: | test\n\t$(GO) vet $(PKGS)\n\nstaticcheck:\n\t$(GO) get honnef.co/go/tools/cmd/staticcheck\n\tstaticcheck -checks all $(PKGS)\n\nmisspell:\n\t$(GO) get github.com/client9/misspell/cmd/misspell\n\tmisspell \\\n\t\t-locale GB \\\n\t\t-error \\\n\t\t*.md *.go\n\nunconvert:\n\t$(GO) get github.com/mdempsky/unconvert\n\tunconvert -v $(PKGS)\n\nineffassign:\n\t$(GO) get github.com/gordonklaus/ineffassign\n\tfind $(SRCDIRS) -name '*.go' | xargs ineffassign\n\npedantic: check errcheck\n\nunparam:\n\t$(GO) get mvdan.cc/unparam\n\tunparam ./...\n\nerrcheck:\n\t$(GO) get github.com/kisielk/errcheck\n\terrcheck $(PKGS)\n\ngofmt:  \n\t@echo Checking code is gofmted\n\t@test -z \"$(shell gofmt -s -l -d -e $(SRCDIRS) | tee /dev/stderr)\"\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.6533203125,
          "content": "# errors [![Travis-CI](https://travis-ci.org/pkg/errors.svg)](https://travis-ci.org/pkg/errors) [![AppVeyor](https://ci.appveyor.com/api/projects/status/b98mptawhudj53ep/branch/master?svg=true)](https://ci.appveyor.com/project/davecheney/errors/branch/master) [![GoDoc](https://godoc.org/github.com/pkg/errors?status.svg)](http://godoc.org/github.com/pkg/errors) [![Report card](https://goreportcard.com/badge/github.com/pkg/errors)](https://goreportcard.com/report/github.com/pkg/errors) [![Sourcegraph](https://sourcegraph.com/github.com/pkg/errors/-/badge.svg)](https://sourcegraph.com/github.com/pkg/errors?badge)\n\nPackage errors provides simple error handling primitives.\n\n`go get github.com/pkg/errors`\n\nThe traditional error handling idiom in Go is roughly akin to\n```go\nif err != nil {\n        return err\n}\n```\nwhich applied recursively up the call stack results in error reports without context or debugging information. The errors package allows programmers to add context to the failure path in their code in a way that does not destroy the original value of the error.\n\n## Adding context to an error\n\nThe errors.Wrap function returns a new error that adds context to the original error. For example\n```go\n_, err := ioutil.ReadAll(r)\nif err != nil {\n        return errors.Wrap(err, \"read failed\")\n}\n```\n## Retrieving the cause of an error\n\nUsing `errors.Wrap` constructs a stack of errors, adding context to the preceding error. Depending on the nature of the error it may be necessary to reverse the operation of errors.Wrap to retrieve the original error for inspection. Any error value which implements this interface can be inspected by `errors.Cause`.\n```go\ntype causer interface {\n        Cause() error\n}\n```\n`errors.Cause` will recursively retrieve the topmost error which does not implement `causer`, which is assumed to be the original cause. For example:\n```go\nswitch err := errors.Cause(err).(type) {\ncase *MyError:\n        // handle specifically\ndefault:\n        // unknown error\n}\n```\n\n[Read the package documentation for more information](https://godoc.org/github.com/pkg/errors).\n\n## Roadmap\n\nWith the upcoming [Go2 error proposals](https://go.googlesource.com/proposal/+/master/design/go2draft.md) this package is moving into maintenance mode. The roadmap for a 1.0 release is as follows:\n\n- 0.9. Remove pre Go 1.9 and Go 1.10 support, address outstanding pull requests (if possible)\n- 1.0. Final release.\n\n## Contributing\n\nBecause of the Go2 errors changes, this package is not accepting proposals for new functionality. With that said, we welcome pull requests, bug fixes and issue reports. \n\nBefore sending a PR, please discuss your change by raising an issue.\n\n## License\n\nBSD-2-Clause\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 0.6240234375,
          "content": "version: build-{build}.{branch}\n\nclone_folder: C:\\gopath\\src\\github.com\\pkg\\errors\nshallow_clone: true # for startup speed\n\nenvironment:\n  GOPATH: C:\\gopath\n\nplatform:\n  - x64\n\n# http://www.appveyor.com/docs/installed-software\ninstall:\n  # some helpful output for debugging builds\n  - go version\n  - go env\n  # pre-installed MinGW at C:\\MinGW is 32bit only\n  # but MSYS2 at C:\\msys64 has mingw64\n  - set PATH=C:\\msys64\\mingw64\\bin;%PATH%\n  - gcc --version\n  - g++ --version\n\nbuild_script:\n  - go install -v ./...\n\ntest_script:\n  - set PATH=C:\\gopath\\bin;%PATH%\n  - go test -v ./...\n\n#artifacts:\n#  - path: '%GOPATH%\\bin\\*.exe'\ndeploy: off\n"
        },
        {
          "name": "bench_test.go",
          "type": "blob",
          "size": 1.9365234375,
          "content": "// +build go1.7\n\npackage errors\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\tstderrors \"errors\"\n)\n\nfunc noErrors(at, depth int) error {\n\tif at >= depth {\n\t\treturn stderrors.New(\"no error\")\n\t}\n\treturn noErrors(at+1, depth)\n}\n\nfunc yesErrors(at, depth int) error {\n\tif at >= depth {\n\t\treturn New(\"ye error\")\n\t}\n\treturn yesErrors(at+1, depth)\n}\n\n// GlobalE is an exported global to store the result of benchmark results,\n// preventing the compiler from optimising the benchmark functions away.\nvar GlobalE interface{}\n\nfunc BenchmarkErrors(b *testing.B) {\n\ttype run struct {\n\t\tstack int\n\t\tstd   bool\n\t}\n\truns := []run{\n\t\t{10, false},\n\t\t{10, true},\n\t\t{100, false},\n\t\t{100, true},\n\t\t{1000, false},\n\t\t{1000, true},\n\t}\n\tfor _, r := range runs {\n\t\tpart := \"pkg/errors\"\n\t\tif r.std {\n\t\t\tpart = \"errors\"\n\t\t}\n\t\tname := fmt.Sprintf(\"%s-stack-%d\", part, r.stack)\n\t\tb.Run(name, func(b *testing.B) {\n\t\t\tvar err error\n\t\t\tf := yesErrors\n\t\t\tif r.std {\n\t\t\t\tf = noErrors\n\t\t\t}\n\t\t\tb.ReportAllocs()\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\terr = f(0, r.stack)\n\t\t\t}\n\t\t\tb.StopTimer()\n\t\t\tGlobalE = err\n\t\t})\n\t}\n}\n\nfunc BenchmarkStackFormatting(b *testing.B) {\n\ttype run struct {\n\t\tstack  int\n\t\tformat string\n\t}\n\truns := []run{\n\t\t{10, \"%s\"},\n\t\t{10, \"%v\"},\n\t\t{10, \"%+v\"},\n\t\t{30, \"%s\"},\n\t\t{30, \"%v\"},\n\t\t{30, \"%+v\"},\n\t\t{60, \"%s\"},\n\t\t{60, \"%v\"},\n\t\t{60, \"%+v\"},\n\t}\n\n\tvar stackStr string\n\tfor _, r := range runs {\n\t\tname := fmt.Sprintf(\"%s-stack-%d\", r.format, r.stack)\n\t\tb.Run(name, func(b *testing.B) {\n\t\t\terr := yesErrors(0, r.stack)\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tstackStr = fmt.Sprintf(r.format, err)\n\t\t\t}\n\t\t\tb.StopTimer()\n\t\t})\n\t}\n\n\tfor _, r := range runs {\n\t\tname := fmt.Sprintf(\"%s-stacktrace-%d\", r.format, r.stack)\n\t\tb.Run(name, func(b *testing.B) {\n\t\t\terr := yesErrors(0, r.stack)\n\t\t\tst := err.(*fundamental).stack.StackTrace()\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tstackStr = fmt.Sprintf(r.format, st)\n\t\t\t}\n\t\t\tb.StopTimer()\n\t\t})\n\t}\n\tGlobalE = stackStr\n}\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 7.2646484375,
          "content": "// Package errors provides simple error handling primitives.\n//\n// The traditional error handling idiom in Go is roughly akin to\n//\n//     if err != nil {\n//             return err\n//     }\n//\n// which when applied recursively up the call stack results in error reports\n// without context or debugging information. The errors package allows\n// programmers to add context to the failure path in their code in a way\n// that does not destroy the original value of the error.\n//\n// Adding context to an error\n//\n// The errors.Wrap function returns a new error that adds context to the\n// original error by recording a stack trace at the point Wrap is called,\n// together with the supplied message. For example\n//\n//     _, err := ioutil.ReadAll(r)\n//     if err != nil {\n//             return errors.Wrap(err, \"read failed\")\n//     }\n//\n// If additional control is required, the errors.WithStack and\n// errors.WithMessage functions destructure errors.Wrap into its component\n// operations: annotating an error with a stack trace and with a message,\n// respectively.\n//\n// Retrieving the cause of an error\n//\n// Using errors.Wrap constructs a stack of errors, adding context to the\n// preceding error. Depending on the nature of the error it may be necessary\n// to reverse the operation of errors.Wrap to retrieve the original error\n// for inspection. Any error value which implements this interface\n//\n//     type causer interface {\n//             Cause() error\n//     }\n//\n// can be inspected by errors.Cause. errors.Cause will recursively retrieve\n// the topmost error that does not implement causer, which is assumed to be\n// the original cause. For example:\n//\n//     switch err := errors.Cause(err).(type) {\n//     case *MyError:\n//             // handle specifically\n//     default:\n//             // unknown error\n//     }\n//\n// Although the causer interface is not exported by this package, it is\n// considered a part of its stable public interface.\n//\n// Formatted printing of errors\n//\n// All error values returned from this package implement fmt.Formatter and can\n// be formatted by the fmt package. The following verbs are supported:\n//\n//     %s    print the error. If the error has a Cause it will be\n//           printed recursively.\n//     %v    see %s\n//     %+v   extended format. Each Frame of the error's StackTrace will\n//           be printed in detail.\n//\n// Retrieving the stack trace of an error or wrapper\n//\n// New, Errorf, Wrap, and Wrapf record a stack trace at the point they are\n// invoked. This information can be retrieved with the following interface:\n//\n//     type stackTracer interface {\n//             StackTrace() errors.StackTrace\n//     }\n//\n// The returned errors.StackTrace type is defined as\n//\n//     type StackTrace []Frame\n//\n// The Frame type represents a call site in the stack trace. Frame supports\n// the fmt.Formatter interface that can be used for printing information about\n// the stack trace of this error. For example:\n//\n//     if err, ok := err.(stackTracer); ok {\n//             for _, f := range err.StackTrace() {\n//                     fmt.Printf(\"%+s:%d\\n\", f, f)\n//             }\n//     }\n//\n// Although the stackTracer interface is not exported by this package, it is\n// considered a part of its stable public interface.\n//\n// See the documentation for Frame.Format for more details.\npackage errors\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n// New returns an error with the supplied message.\n// New also records the stack trace at the point it was called.\nfunc New(message string) error {\n\treturn &fundamental{\n\t\tmsg:   message,\n\t\tstack: callers(),\n\t}\n}\n\n// Errorf formats according to a format specifier and returns the string\n// as a value that satisfies error.\n// Errorf also records the stack trace at the point it was called.\nfunc Errorf(format string, args ...interface{}) error {\n\treturn &fundamental{\n\t\tmsg:   fmt.Sprintf(format, args...),\n\t\tstack: callers(),\n\t}\n}\n\n// fundamental is an error that has a message and a stack, but no caller.\ntype fundamental struct {\n\tmsg string\n\t*stack\n}\n\nfunc (f *fundamental) Error() string { return f.msg }\n\nfunc (f *fundamental) Format(s fmt.State, verb rune) {\n\tswitch verb {\n\tcase 'v':\n\t\tif s.Flag('+') {\n\t\t\tio.WriteString(s, f.msg)\n\t\t\tf.stack.Format(s, verb)\n\t\t\treturn\n\t\t}\n\t\tfallthrough\n\tcase 's':\n\t\tio.WriteString(s, f.msg)\n\tcase 'q':\n\t\tfmt.Fprintf(s, \"%q\", f.msg)\n\t}\n}\n\n// WithStack annotates err with a stack trace at the point WithStack was called.\n// If err is nil, WithStack returns nil.\nfunc WithStack(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\treturn &withStack{\n\t\terr,\n\t\tcallers(),\n\t}\n}\n\ntype withStack struct {\n\terror\n\t*stack\n}\n\nfunc (w *withStack) Cause() error { return w.error }\n\n// Unwrap provides compatibility for Go 1.13 error chains.\nfunc (w *withStack) Unwrap() error { return w.error }\n\nfunc (w *withStack) Format(s fmt.State, verb rune) {\n\tswitch verb {\n\tcase 'v':\n\t\tif s.Flag('+') {\n\t\t\tfmt.Fprintf(s, \"%+v\", w.Cause())\n\t\t\tw.stack.Format(s, verb)\n\t\t\treturn\n\t\t}\n\t\tfallthrough\n\tcase 's':\n\t\tio.WriteString(s, w.Error())\n\tcase 'q':\n\t\tfmt.Fprintf(s, \"%q\", w.Error())\n\t}\n}\n\n// Wrap returns an error annotating err with a stack trace\n// at the point Wrap is called, and the supplied message.\n// If err is nil, Wrap returns nil.\nfunc Wrap(err error, message string) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\terr = &withMessage{\n\t\tcause: err,\n\t\tmsg:   message,\n\t}\n\treturn &withStack{\n\t\terr,\n\t\tcallers(),\n\t}\n}\n\n// Wrapf returns an error annotating err with a stack trace\n// at the point Wrapf is called, and the format specifier.\n// If err is nil, Wrapf returns nil.\nfunc Wrapf(err error, format string, args ...interface{}) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\terr = &withMessage{\n\t\tcause: err,\n\t\tmsg:   fmt.Sprintf(format, args...),\n\t}\n\treturn &withStack{\n\t\terr,\n\t\tcallers(),\n\t}\n}\n\n// WithMessage annotates err with a new message.\n// If err is nil, WithMessage returns nil.\nfunc WithMessage(err error, message string) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\treturn &withMessage{\n\t\tcause: err,\n\t\tmsg:   message,\n\t}\n}\n\n// WithMessagef annotates err with the format specifier.\n// If err is nil, WithMessagef returns nil.\nfunc WithMessagef(err error, format string, args ...interface{}) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\treturn &withMessage{\n\t\tcause: err,\n\t\tmsg:   fmt.Sprintf(format, args...),\n\t}\n}\n\ntype withMessage struct {\n\tcause error\n\tmsg   string\n}\n\nfunc (w *withMessage) Error() string { return w.msg + \": \" + w.cause.Error() }\nfunc (w *withMessage) Cause() error  { return w.cause }\n\n// Unwrap provides compatibility for Go 1.13 error chains.\nfunc (w *withMessage) Unwrap() error { return w.cause }\n\nfunc (w *withMessage) Format(s fmt.State, verb rune) {\n\tswitch verb {\n\tcase 'v':\n\t\tif s.Flag('+') {\n\t\t\tfmt.Fprintf(s, \"%+v\\n\", w.Cause())\n\t\t\tio.WriteString(s, w.msg)\n\t\t\treturn\n\t\t}\n\t\tfallthrough\n\tcase 's', 'q':\n\t\tio.WriteString(s, w.Error())\n\t}\n}\n\n// Cause returns the underlying cause of the error, if possible.\n// An error value has a cause if it implements the following\n// interface:\n//\n//     type causer interface {\n//            Cause() error\n//     }\n//\n// If the error does not implement Cause, the original error will\n// be returned. If the error is nil, nil will be returned without further\n// investigation.\nfunc Cause(err error) error {\n\ttype causer interface {\n\t\tCause() error\n\t}\n\n\tfor err != nil {\n\t\tcause, ok := err.(causer)\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\terr = cause.Cause()\n\t}\n\treturn err\n}\n"
        },
        {
          "name": "errors_test.go",
          "type": "blob",
          "size": 5.5361328125,
          "content": "package errors\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestNew(t *testing.T) {\n\ttests := []struct {\n\t\terr  string\n\t\twant error\n\t}{\n\t\t{\"\", fmt.Errorf(\"\")},\n\t\t{\"foo\", fmt.Errorf(\"foo\")},\n\t\t{\"foo\", New(\"foo\")},\n\t\t{\"string with format specifiers: %v\", errors.New(\"string with format specifiers: %v\")},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := New(tt.err)\n\t\tif got.Error() != tt.want.Error() {\n\t\t\tt.Errorf(\"New.Error(): got: %q, want %q\", got, tt.want)\n\t\t}\n\t}\n}\n\nfunc TestWrapNil(t *testing.T) {\n\tgot := Wrap(nil, \"no error\")\n\tif got != nil {\n\t\tt.Errorf(\"Wrap(nil, \\\"no error\\\"): got %#v, expected nil\", got)\n\t}\n}\n\nfunc TestWrap(t *testing.T) {\n\ttests := []struct {\n\t\terr     error\n\t\tmessage string\n\t\twant    string\n\t}{\n\t\t{io.EOF, \"read error\", \"read error: EOF\"},\n\t\t{Wrap(io.EOF, \"read error\"), \"client error\", \"client error: read error: EOF\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Wrap(tt.err, tt.message).Error()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"Wrap(%v, %q): got: %v, want %v\", tt.err, tt.message, got, tt.want)\n\t\t}\n\t}\n}\n\ntype nilError struct{}\n\nfunc (nilError) Error() string { return \"nil error\" }\n\nfunc TestCause(t *testing.T) {\n\tx := New(\"error\")\n\ttests := []struct {\n\t\terr  error\n\t\twant error\n\t}{{\n\t\t// nil error is nil\n\t\terr:  nil,\n\t\twant: nil,\n\t}, {\n\t\t// explicit nil error is nil\n\t\terr:  (error)(nil),\n\t\twant: nil,\n\t}, {\n\t\t// typed nil is nil\n\t\terr:  (*nilError)(nil),\n\t\twant: (*nilError)(nil),\n\t}, {\n\t\t// uncaused error is unaffected\n\t\terr:  io.EOF,\n\t\twant: io.EOF,\n\t}, {\n\t\t// caused error returns cause\n\t\terr:  Wrap(io.EOF, \"ignored\"),\n\t\twant: io.EOF,\n\t}, {\n\t\terr:  x, // return from errors.New\n\t\twant: x,\n\t}, {\n\t\tWithMessage(nil, \"whoops\"),\n\t\tnil,\n\t}, {\n\t\tWithMessage(io.EOF, \"whoops\"),\n\t\tio.EOF,\n\t}, {\n\t\tWithStack(nil),\n\t\tnil,\n\t}, {\n\t\tWithStack(io.EOF),\n\t\tio.EOF,\n\t}}\n\n\tfor i, tt := range tests {\n\t\tgot := Cause(tt.err)\n\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\tt.Errorf(\"test %d: got %#v, want %#v\", i+1, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc TestWrapfNil(t *testing.T) {\n\tgot := Wrapf(nil, \"no error\")\n\tif got != nil {\n\t\tt.Errorf(\"Wrapf(nil, \\\"no error\\\"): got %#v, expected nil\", got)\n\t}\n}\n\nfunc TestWrapf(t *testing.T) {\n\ttests := []struct {\n\t\terr     error\n\t\tmessage string\n\t\twant    string\n\t}{\n\t\t{io.EOF, \"read error\", \"read error: EOF\"},\n\t\t{Wrapf(io.EOF, \"read error without format specifiers\"), \"client error\", \"client error: read error without format specifiers: EOF\"},\n\t\t{Wrapf(io.EOF, \"read error with %d format specifier\", 1), \"client error\", \"client error: read error with 1 format specifier: EOF\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := Wrapf(tt.err, tt.message).Error()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"Wrapf(%v, %q): got: %v, want %v\", tt.err, tt.message, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc TestErrorf(t *testing.T) {\n\ttests := []struct {\n\t\terr  error\n\t\twant string\n\t}{\n\t\t{Errorf(\"read error without format specifiers\"), \"read error without format specifiers\"},\n\t\t{Errorf(\"read error with %d format specifier\", 1), \"read error with 1 format specifier\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := tt.err.Error()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"Errorf(%v): got: %q, want %q\", tt.err, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc TestWithStackNil(t *testing.T) {\n\tgot := WithStack(nil)\n\tif got != nil {\n\t\tt.Errorf(\"WithStack(nil): got %#v, expected nil\", got)\n\t}\n}\n\nfunc TestWithStack(t *testing.T) {\n\ttests := []struct {\n\t\terr  error\n\t\twant string\n\t}{\n\t\t{io.EOF, \"EOF\"},\n\t\t{WithStack(io.EOF), \"EOF\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := WithStack(tt.err).Error()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"WithStack(%v): got: %v, want %v\", tt.err, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc TestWithMessageNil(t *testing.T) {\n\tgot := WithMessage(nil, \"no error\")\n\tif got != nil {\n\t\tt.Errorf(\"WithMessage(nil, \\\"no error\\\"): got %#v, expected nil\", got)\n\t}\n}\n\nfunc TestWithMessage(t *testing.T) {\n\ttests := []struct {\n\t\terr     error\n\t\tmessage string\n\t\twant    string\n\t}{\n\t\t{io.EOF, \"read error\", \"read error: EOF\"},\n\t\t{WithMessage(io.EOF, \"read error\"), \"client error\", \"client error: read error: EOF\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := WithMessage(tt.err, tt.message).Error()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"WithMessage(%v, %q): got: %q, want %q\", tt.err, tt.message, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc TestWithMessagefNil(t *testing.T) {\n\tgot := WithMessagef(nil, \"no error\")\n\tif got != nil {\n\t\tt.Errorf(\"WithMessage(nil, \\\"no error\\\"): got %#v, expected nil\", got)\n\t}\n}\n\nfunc TestWithMessagef(t *testing.T) {\n\ttests := []struct {\n\t\terr     error\n\t\tmessage string\n\t\twant    string\n\t}{\n\t\t{io.EOF, \"read error\", \"read error: EOF\"},\n\t\t{WithMessagef(io.EOF, \"read error without format specifier\"), \"client error\", \"client error: read error without format specifier: EOF\"},\n\t\t{WithMessagef(io.EOF, \"read error with %d format specifier\", 1), \"client error\", \"client error: read error with 1 format specifier: EOF\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := WithMessagef(tt.err, tt.message).Error()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"WithMessage(%v, %q): got: %q, want %q\", tt.err, tt.message, got, tt.want)\n\t\t}\n\t}\n}\n\n// errors.New, etc values are not expected to be compared by value\n// but the change in errors#27 made them incomparable. Assert that\n// various kinds of errors have a functional equality operator, even\n// if the result of that equality is always false.\nfunc TestErrorEquality(t *testing.T) {\n\tvals := []error{\n\t\tnil,\n\t\tio.EOF,\n\t\terrors.New(\"EOF\"),\n\t\tNew(\"EOF\"),\n\t\tErrorf(\"EOF\"),\n\t\tWrap(io.EOF, \"EOF\"),\n\t\tWrapf(io.EOF, \"EOF%d\", 2),\n\t\tWithMessage(nil, \"whoops\"),\n\t\tWithMessage(io.EOF, \"whoops\"),\n\t\tWithStack(io.EOF),\n\t\tWithStack(nil),\n\t}\n\n\tfor i := range vals {\n\t\tfor j := range vals {\n\t\t\t_ = vals[i] == vals[j] // mustn't panic\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 5.2880859375,
          "content": "package errors_test\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pkg/errors\"\n)\n\nfunc ExampleNew() {\n\terr := errors.New(\"whoops\")\n\tfmt.Println(err)\n\n\t// Output: whoops\n}\n\nfunc ExampleNew_printf() {\n\terr := errors.New(\"whoops\")\n\tfmt.Printf(\"%+v\", err)\n\n\t// Example output:\n\t// whoops\n\t// github.com/pkg/errors_test.ExampleNew_printf\n\t//         /home/dfc/src/github.com/pkg/errors/example_test.go:17\n\t// testing.runExample\n\t//         /home/dfc/go/src/testing/example.go:114\n\t// testing.RunExamples\n\t//         /home/dfc/go/src/testing/example.go:38\n\t// testing.(*M).Run\n\t//         /home/dfc/go/src/testing/testing.go:744\n\t// main.main\n\t//         /github.com/pkg/errors/_test/_testmain.go:106\n\t// runtime.main\n\t//         /home/dfc/go/src/runtime/proc.go:183\n\t// runtime.goexit\n\t//         /home/dfc/go/src/runtime/asm_amd64.s:2059\n}\n\nfunc ExampleWithMessage() {\n\tcause := errors.New(\"whoops\")\n\terr := errors.WithMessage(cause, \"oh noes\")\n\tfmt.Println(err)\n\n\t// Output: oh noes: whoops\n}\n\nfunc ExampleWithStack() {\n\tcause := errors.New(\"whoops\")\n\terr := errors.WithStack(cause)\n\tfmt.Println(err)\n\n\t// Output: whoops\n}\n\nfunc ExampleWithStack_printf() {\n\tcause := errors.New(\"whoops\")\n\terr := errors.WithStack(cause)\n\tfmt.Printf(\"%+v\", err)\n\n\t// Example Output:\n\t// whoops\n\t// github.com/pkg/errors_test.ExampleWithStack_printf\n\t//         /home/fabstu/go/src/github.com/pkg/errors/example_test.go:55\n\t// testing.runExample\n\t//         /usr/lib/go/src/testing/example.go:114\n\t// testing.RunExamples\n\t//         /usr/lib/go/src/testing/example.go:38\n\t// testing.(*M).Run\n\t//         /usr/lib/go/src/testing/testing.go:744\n\t// main.main\n\t//         github.com/pkg/errors/_test/_testmain.go:106\n\t// runtime.main\n\t//         /usr/lib/go/src/runtime/proc.go:183\n\t// runtime.goexit\n\t//         /usr/lib/go/src/runtime/asm_amd64.s:2086\n\t// github.com/pkg/errors_test.ExampleWithStack_printf\n\t//         /home/fabstu/go/src/github.com/pkg/errors/example_test.go:56\n\t// testing.runExample\n\t//         /usr/lib/go/src/testing/example.go:114\n\t// testing.RunExamples\n\t//         /usr/lib/go/src/testing/example.go:38\n\t// testing.(*M).Run\n\t//         /usr/lib/go/src/testing/testing.go:744\n\t// main.main\n\t//         github.com/pkg/errors/_test/_testmain.go:106\n\t// runtime.main\n\t//         /usr/lib/go/src/runtime/proc.go:183\n\t// runtime.goexit\n\t//         /usr/lib/go/src/runtime/asm_amd64.s:2086\n}\n\nfunc ExampleWrap() {\n\tcause := errors.New(\"whoops\")\n\terr := errors.Wrap(cause, \"oh noes\")\n\tfmt.Println(err)\n\n\t// Output: oh noes: whoops\n}\n\nfunc fn() error {\n\te1 := errors.New(\"error\")\n\te2 := errors.Wrap(e1, \"inner\")\n\te3 := errors.Wrap(e2, \"middle\")\n\treturn errors.Wrap(e3, \"outer\")\n}\n\nfunc ExampleCause() {\n\terr := fn()\n\tfmt.Println(err)\n\tfmt.Println(errors.Cause(err))\n\n\t// Output: outer: middle: inner: error\n\t// error\n}\n\nfunc ExampleWrap_extended() {\n\terr := fn()\n\tfmt.Printf(\"%+v\\n\", err)\n\n\t// Example output:\n\t// error\n\t// github.com/pkg/errors_test.fn\n\t//         /home/dfc/src/github.com/pkg/errors/example_test.go:47\n\t// github.com/pkg/errors_test.ExampleCause_printf\n\t//         /home/dfc/src/github.com/pkg/errors/example_test.go:63\n\t// testing.runExample\n\t//         /home/dfc/go/src/testing/example.go:114\n\t// testing.RunExamples\n\t//         /home/dfc/go/src/testing/example.go:38\n\t// testing.(*M).Run\n\t//         /home/dfc/go/src/testing/testing.go:744\n\t// main.main\n\t//         /github.com/pkg/errors/_test/_testmain.go:104\n\t// runtime.main\n\t//         /home/dfc/go/src/runtime/proc.go:183\n\t// runtime.goexit\n\t//         /home/dfc/go/src/runtime/asm_amd64.s:2059\n\t// github.com/pkg/errors_test.fn\n\t// \t  /home/dfc/src/github.com/pkg/errors/example_test.go:48: inner\n\t// github.com/pkg/errors_test.fn\n\t//        /home/dfc/src/github.com/pkg/errors/example_test.go:49: middle\n\t// github.com/pkg/errors_test.fn\n\t//      /home/dfc/src/github.com/pkg/errors/example_test.go:50: outer\n}\n\nfunc ExampleWrapf() {\n\tcause := errors.New(\"whoops\")\n\terr := errors.Wrapf(cause, \"oh noes #%d\", 2)\n\tfmt.Println(err)\n\n\t// Output: oh noes #2: whoops\n}\n\nfunc ExampleErrorf_extended() {\n\terr := errors.Errorf(\"whoops: %s\", \"foo\")\n\tfmt.Printf(\"%+v\", err)\n\n\t// Example output:\n\t// whoops: foo\n\t// github.com/pkg/errors_test.ExampleErrorf\n\t//         /home/dfc/src/github.com/pkg/errors/example_test.go:101\n\t// testing.runExample\n\t//         /home/dfc/go/src/testing/example.go:114\n\t// testing.RunExamples\n\t//         /home/dfc/go/src/testing/example.go:38\n\t// testing.(*M).Run\n\t//         /home/dfc/go/src/testing/testing.go:744\n\t// main.main\n\t//         /github.com/pkg/errors/_test/_testmain.go:102\n\t// runtime.main\n\t//         /home/dfc/go/src/runtime/proc.go:183\n\t// runtime.goexit\n\t//         /home/dfc/go/src/runtime/asm_amd64.s:2059\n}\n\nfunc Example_stackTrace() {\n\ttype stackTracer interface {\n\t\tStackTrace() errors.StackTrace\n\t}\n\n\terr, ok := errors.Cause(fn()).(stackTracer)\n\tif !ok {\n\t\tpanic(\"oops, err does not implement stackTracer\")\n\t}\n\n\tst := err.StackTrace()\n\tfmt.Printf(\"%+v\", st[0:2]) // top two frames\n\n\t// Example output:\n\t// github.com/pkg/errors_test.fn\n\t//\t/home/dfc/src/github.com/pkg/errors/example_test.go:47\n\t// github.com/pkg/errors_test.Example_stackTrace\n\t//\t/home/dfc/src/github.com/pkg/errors/example_test.go:127\n}\n\nfunc ExampleCause_printf() {\n\terr := errors.Wrap(func() error {\n\t\treturn func() error {\n\t\t\treturn errors.New(\"hello world\")\n\t\t}()\n\t}(), \"failed\")\n\n\tfmt.Printf(\"%v\", err)\n\n\t// Output: failed: hello world\n}\n"
        },
        {
          "name": "format_test.go",
          "type": "blob",
          "size": 13.05078125,
          "content": "package errors\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestFormatNew(t *testing.T) {\n\ttests := []struct {\n\t\terror\n\t\tformat string\n\t\twant   string\n\t}{{\n\t\tNew(\"error\"),\n\t\t\"%s\",\n\t\t\"error\",\n\t}, {\n\t\tNew(\"error\"),\n\t\t\"%v\",\n\t\t\"error\",\n\t}, {\n\t\tNew(\"error\"),\n\t\t\"%+v\",\n\t\t\"error\\n\" +\n\t\t\t\"github.com/pkg/errors.TestFormatNew\\n\" +\n\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:26\",\n\t}, {\n\t\tNew(\"error\"),\n\t\t\"%q\",\n\t\t`\"error\"`,\n\t}}\n\n\tfor i, tt := range tests {\n\t\ttestFormatRegexp(t, i, tt.error, tt.format, tt.want)\n\t}\n}\n\nfunc TestFormatErrorf(t *testing.T) {\n\ttests := []struct {\n\t\terror\n\t\tformat string\n\t\twant   string\n\t}{{\n\t\tErrorf(\"%s\", \"error\"),\n\t\t\"%s\",\n\t\t\"error\",\n\t}, {\n\t\tErrorf(\"%s\", \"error\"),\n\t\t\"%v\",\n\t\t\"error\",\n\t}, {\n\t\tErrorf(\"%s\", \"error\"),\n\t\t\"%+v\",\n\t\t\"error\\n\" +\n\t\t\t\"github.com/pkg/errors.TestFormatErrorf\\n\" +\n\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:56\",\n\t}}\n\n\tfor i, tt := range tests {\n\t\ttestFormatRegexp(t, i, tt.error, tt.format, tt.want)\n\t}\n}\n\nfunc TestFormatWrap(t *testing.T) {\n\ttests := []struct {\n\t\terror\n\t\tformat string\n\t\twant   string\n\t}{{\n\t\tWrap(New(\"error\"), \"error2\"),\n\t\t\"%s\",\n\t\t\"error2: error\",\n\t}, {\n\t\tWrap(New(\"error\"), \"error2\"),\n\t\t\"%v\",\n\t\t\"error2: error\",\n\t}, {\n\t\tWrap(New(\"error\"), \"error2\"),\n\t\t\"%+v\",\n\t\t\"error\\n\" +\n\t\t\t\"github.com/pkg/errors.TestFormatWrap\\n\" +\n\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:82\",\n\t}, {\n\t\tWrap(io.EOF, \"error\"),\n\t\t\"%s\",\n\t\t\"error: EOF\",\n\t}, {\n\t\tWrap(io.EOF, \"error\"),\n\t\t\"%v\",\n\t\t\"error: EOF\",\n\t}, {\n\t\tWrap(io.EOF, \"error\"),\n\t\t\"%+v\",\n\t\t\"EOF\\n\" +\n\t\t\t\"error\\n\" +\n\t\t\t\"github.com/pkg/errors.TestFormatWrap\\n\" +\n\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:96\",\n\t}, {\n\t\tWrap(Wrap(io.EOF, \"error1\"), \"error2\"),\n\t\t\"%+v\",\n\t\t\"EOF\\n\" +\n\t\t\t\"error1\\n\" +\n\t\t\t\"github.com/pkg/errors.TestFormatWrap\\n\" +\n\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:103\\n\",\n\t}, {\n\t\tWrap(New(\"error with space\"), \"context\"),\n\t\t\"%q\",\n\t\t`\"context: error with space\"`,\n\t}}\n\n\tfor i, tt := range tests {\n\t\ttestFormatRegexp(t, i, tt.error, tt.format, tt.want)\n\t}\n}\n\nfunc TestFormatWrapf(t *testing.T) {\n\ttests := []struct {\n\t\terror\n\t\tformat string\n\t\twant   string\n\t}{{\n\t\tWrapf(io.EOF, \"error%d\", 2),\n\t\t\"%s\",\n\t\t\"error2: EOF\",\n\t}, {\n\t\tWrapf(io.EOF, \"error%d\", 2),\n\t\t\"%v\",\n\t\t\"error2: EOF\",\n\t}, {\n\t\tWrapf(io.EOF, \"error%d\", 2),\n\t\t\"%+v\",\n\t\t\"EOF\\n\" +\n\t\t\t\"error2\\n\" +\n\t\t\t\"github.com/pkg/errors.TestFormatWrapf\\n\" +\n\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:134\",\n\t}, {\n\t\tWrapf(New(\"error\"), \"error%d\", 2),\n\t\t\"%s\",\n\t\t\"error2: error\",\n\t}, {\n\t\tWrapf(New(\"error\"), \"error%d\", 2),\n\t\t\"%v\",\n\t\t\"error2: error\",\n\t}, {\n\t\tWrapf(New(\"error\"), \"error%d\", 2),\n\t\t\"%+v\",\n\t\t\"error\\n\" +\n\t\t\t\"github.com/pkg/errors.TestFormatWrapf\\n\" +\n\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:149\",\n\t}}\n\n\tfor i, tt := range tests {\n\t\ttestFormatRegexp(t, i, tt.error, tt.format, tt.want)\n\t}\n}\n\nfunc TestFormatWithStack(t *testing.T) {\n\ttests := []struct {\n\t\terror\n\t\tformat string\n\t\twant   []string\n\t}{{\n\t\tWithStack(io.EOF),\n\t\t\"%s\",\n\t\t[]string{\"EOF\"},\n\t}, {\n\t\tWithStack(io.EOF),\n\t\t\"%v\",\n\t\t[]string{\"EOF\"},\n\t}, {\n\t\tWithStack(io.EOF),\n\t\t\"%+v\",\n\t\t[]string{\"EOF\",\n\t\t\t\"github.com/pkg/errors.TestFormatWithStack\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:175\"},\n\t}, {\n\t\tWithStack(New(\"error\")),\n\t\t\"%s\",\n\t\t[]string{\"error\"},\n\t}, {\n\t\tWithStack(New(\"error\")),\n\t\t\"%v\",\n\t\t[]string{\"error\"},\n\t}, {\n\t\tWithStack(New(\"error\")),\n\t\t\"%+v\",\n\t\t[]string{\"error\",\n\t\t\t\"github.com/pkg/errors.TestFormatWithStack\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:189\",\n\t\t\t\"github.com/pkg/errors.TestFormatWithStack\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:189\"},\n\t}, {\n\t\tWithStack(WithStack(io.EOF)),\n\t\t\"%+v\",\n\t\t[]string{\"EOF\",\n\t\t\t\"github.com/pkg/errors.TestFormatWithStack\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:197\",\n\t\t\t\"github.com/pkg/errors.TestFormatWithStack\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:197\"},\n\t}, {\n\t\tWithStack(WithStack(Wrapf(io.EOF, \"message\"))),\n\t\t\"%+v\",\n\t\t[]string{\"EOF\",\n\t\t\t\"message\",\n\t\t\t\"github.com/pkg/errors.TestFormatWithStack\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:205\",\n\t\t\t\"github.com/pkg/errors.TestFormatWithStack\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:205\",\n\t\t\t\"github.com/pkg/errors.TestFormatWithStack\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:205\"},\n\t}, {\n\t\tWithStack(Errorf(\"error%d\", 1)),\n\t\t\"%+v\",\n\t\t[]string{\"error1\",\n\t\t\t\"github.com/pkg/errors.TestFormatWithStack\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:216\",\n\t\t\t\"github.com/pkg/errors.TestFormatWithStack\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:216\"},\n\t}}\n\n\tfor i, tt := range tests {\n\t\ttestFormatCompleteCompare(t, i, tt.error, tt.format, tt.want, true)\n\t}\n}\n\nfunc TestFormatWithMessage(t *testing.T) {\n\ttests := []struct {\n\t\terror\n\t\tformat string\n\t\twant   []string\n\t}{{\n\t\tWithMessage(New(\"error\"), \"error2\"),\n\t\t\"%s\",\n\t\t[]string{\"error2: error\"},\n\t}, {\n\t\tWithMessage(New(\"error\"), \"error2\"),\n\t\t\"%v\",\n\t\t[]string{\"error2: error\"},\n\t}, {\n\t\tWithMessage(New(\"error\"), \"error2\"),\n\t\t\"%+v\",\n\t\t[]string{\n\t\t\t\"error\",\n\t\t\t\"github.com/pkg/errors.TestFormatWithMessage\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:244\",\n\t\t\t\"error2\"},\n\t}, {\n\t\tWithMessage(io.EOF, \"addition1\"),\n\t\t\"%s\",\n\t\t[]string{\"addition1: EOF\"},\n\t}, {\n\t\tWithMessage(io.EOF, \"addition1\"),\n\t\t\"%v\",\n\t\t[]string{\"addition1: EOF\"},\n\t}, {\n\t\tWithMessage(io.EOF, \"addition1\"),\n\t\t\"%+v\",\n\t\t[]string{\"EOF\", \"addition1\"},\n\t}, {\n\t\tWithMessage(WithMessage(io.EOF, \"addition1\"), \"addition2\"),\n\t\t\"%v\",\n\t\t[]string{\"addition2: addition1: EOF\"},\n\t}, {\n\t\tWithMessage(WithMessage(io.EOF, \"addition1\"), \"addition2\"),\n\t\t\"%+v\",\n\t\t[]string{\"EOF\", \"addition1\", \"addition2\"},\n\t}, {\n\t\tWrap(WithMessage(io.EOF, \"error1\"), \"error2\"),\n\t\t\"%+v\",\n\t\t[]string{\"EOF\", \"error1\", \"error2\",\n\t\t\t\"github.com/pkg/errors.TestFormatWithMessage\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:272\"},\n\t}, {\n\t\tWithMessage(Errorf(\"error%d\", 1), \"error2\"),\n\t\t\"%+v\",\n\t\t[]string{\"error1\",\n\t\t\t\"github.com/pkg/errors.TestFormatWithMessage\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:278\",\n\t\t\t\"error2\"},\n\t}, {\n\t\tWithMessage(WithStack(io.EOF), \"error\"),\n\t\t\"%+v\",\n\t\t[]string{\n\t\t\t\"EOF\",\n\t\t\t\"github.com/pkg/errors.TestFormatWithMessage\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:285\",\n\t\t\t\"error\"},\n\t}, {\n\t\tWithMessage(Wrap(WithStack(io.EOF), \"inside-error\"), \"outside-error\"),\n\t\t\"%+v\",\n\t\t[]string{\n\t\t\t\"EOF\",\n\t\t\t\"github.com/pkg/errors.TestFormatWithMessage\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:293\",\n\t\t\t\"inside-error\",\n\t\t\t\"github.com/pkg/errors.TestFormatWithMessage\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:293\",\n\t\t\t\"outside-error\"},\n\t}}\n\n\tfor i, tt := range tests {\n\t\ttestFormatCompleteCompare(t, i, tt.error, tt.format, tt.want, true)\n\t}\n}\n\nfunc TestFormatGeneric(t *testing.T) {\n\tstarts := []struct {\n\t\terr  error\n\t\twant []string\n\t}{\n\t\t{New(\"new-error\"), []string{\n\t\t\t\"new-error\",\n\t\t\t\"github.com/pkg/errors.TestFormatGeneric\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:315\"},\n\t\t}, {Errorf(\"errorf-error\"), []string{\n\t\t\t\"errorf-error\",\n\t\t\t\"github.com/pkg/errors.TestFormatGeneric\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:319\"},\n\t\t}, {errors.New(\"errors-new-error\"), []string{\n\t\t\t\"errors-new-error\"},\n\t\t},\n\t}\n\n\twrappers := []wrapper{\n\t\t{\n\t\t\tfunc(err error) error { return WithMessage(err, \"with-message\") },\n\t\t\t[]string{\"with-message\"},\n\t\t}, {\n\t\t\tfunc(err error) error { return WithStack(err) },\n\t\t\t[]string{\n\t\t\t\t\"github.com/pkg/errors.(func·002|TestFormatGeneric.func2)\\n\\t\" +\n\t\t\t\t\t\".+/github.com/pkg/errors/format_test.go:333\",\n\t\t\t},\n\t\t}, {\n\t\t\tfunc(err error) error { return Wrap(err, \"wrap-error\") },\n\t\t\t[]string{\n\t\t\t\t\"wrap-error\",\n\t\t\t\t\"github.com/pkg/errors.(func·003|TestFormatGeneric.func3)\\n\\t\" +\n\t\t\t\t\t\".+/github.com/pkg/errors/format_test.go:339\",\n\t\t\t},\n\t\t}, {\n\t\t\tfunc(err error) error { return Wrapf(err, \"wrapf-error%d\", 1) },\n\t\t\t[]string{\n\t\t\t\t\"wrapf-error1\",\n\t\t\t\t\"github.com/pkg/errors.(func·004|TestFormatGeneric.func4)\\n\\t\" +\n\t\t\t\t\t\".+/github.com/pkg/errors/format_test.go:346\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor s := range starts {\n\t\terr := starts[s].err\n\t\twant := starts[s].want\n\t\ttestFormatCompleteCompare(t, s, err, \"%+v\", want, false)\n\t\ttestGenericRecursive(t, err, want, wrappers, 3)\n\t}\n}\n\nfunc wrappedNew(message string) error { // This function will be mid-stack inlined in go 1.12+\n\treturn New(message)\n}\n\nfunc TestFormatWrappedNew(t *testing.T) {\n\ttests := []struct {\n\t\terror\n\t\tformat string\n\t\twant   string\n\t}{{\n\t\twrappedNew(\"error\"),\n\t\t\"%+v\",\n\t\t\"error\\n\" +\n\t\t\t\"github.com/pkg/errors.wrappedNew\\n\" +\n\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:364\\n\" +\n\t\t\t\"github.com/pkg/errors.TestFormatWrappedNew\\n\" +\n\t\t\t\"\\t.+/github.com/pkg/errors/format_test.go:373\",\n\t}}\n\n\tfor i, tt := range tests {\n\t\ttestFormatRegexp(t, i, tt.error, tt.format, tt.want)\n\t}\n}\n\nfunc testFormatRegexp(t *testing.T, n int, arg interface{}, format, want string) {\n\tt.Helper()\n\tgot := fmt.Sprintf(format, arg)\n\tgotLines := strings.SplitN(got, \"\\n\", -1)\n\twantLines := strings.SplitN(want, \"\\n\", -1)\n\n\tif len(wantLines) > len(gotLines) {\n\t\tt.Errorf(\"test %d: wantLines(%d) > gotLines(%d):\\n got: %q\\nwant: %q\", n+1, len(wantLines), len(gotLines), got, want)\n\t\treturn\n\t}\n\n\tfor i, w := range wantLines {\n\t\tmatch, err := regexp.MatchString(w, gotLines[i])\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !match {\n\t\t\tt.Errorf(\"test %d: line %d: fmt.Sprintf(%q, err):\\n got: %q\\nwant: %q\", n+1, i+1, format, got, want)\n\t\t}\n\t}\n}\n\nvar stackLineR = regexp.MustCompile(`\\.`)\n\n// parseBlocks parses input into a slice, where:\n//  - incase entry contains a newline, its a stacktrace\n//  - incase entry contains no newline, its a solo line.\n//\n// Detecting stack boundaries only works incase the WithStack-calls are\n// to be found on the same line, thats why it is optionally here.\n//\n// Example use:\n//\n// for _, e := range blocks {\n//   if strings.ContainsAny(e, \"\\n\") {\n//     // Match as stack\n//   } else {\n//     // Match as line\n//   }\n// }\n//\nfunc parseBlocks(input string, detectStackboundaries bool) ([]string, error) {\n\tvar blocks []string\n\n\tstack := \"\"\n\twasStack := false\n\tlines := map[string]bool{} // already found lines\n\n\tfor _, l := range strings.Split(input, \"\\n\") {\n\t\tisStackLine := stackLineR.MatchString(l)\n\n\t\tswitch {\n\t\tcase !isStackLine && wasStack:\n\t\t\tblocks = append(blocks, stack, l)\n\t\t\tstack = \"\"\n\t\t\tlines = map[string]bool{}\n\t\tcase isStackLine:\n\t\t\tif wasStack {\n\t\t\t\t// Detecting two stacks after another, possible cause lines match in\n\t\t\t\t// our tests due to WithStack(WithStack(io.EOF)) on same line.\n\t\t\t\tif detectStackboundaries {\n\t\t\t\t\tif lines[l] {\n\t\t\t\t\t\tif len(stack) == 0 {\n\t\t\t\t\t\t\treturn nil, errors.New(\"len of block must not be zero here\")\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tblocks = append(blocks, stack)\n\t\t\t\t\t\tstack = l\n\t\t\t\t\t\tlines = map[string]bool{l: true}\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstack = stack + \"\\n\" + l\n\t\t\t} else {\n\t\t\t\tstack = l\n\t\t\t}\n\t\t\tlines[l] = true\n\t\tcase !isStackLine && !wasStack:\n\t\t\tblocks = append(blocks, l)\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"must not happen\")\n\t\t}\n\n\t\twasStack = isStackLine\n\t}\n\n\t// Use up stack\n\tif stack != \"\" {\n\t\tblocks = append(blocks, stack)\n\t}\n\treturn blocks, nil\n}\n\nfunc testFormatCompleteCompare(t *testing.T, n int, arg interface{}, format string, want []string, detectStackBoundaries bool) {\n\tgotStr := fmt.Sprintf(format, arg)\n\n\tgot, err := parseBlocks(gotStr, detectStackBoundaries)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif len(got) != len(want) {\n\t\tt.Fatalf(\"test %d: fmt.Sprintf(%s, err) -> wrong number of blocks: got(%d) want(%d)\\n got: %s\\nwant: %s\\ngotStr: %q\",\n\t\t\tn+1, format, len(got), len(want), prettyBlocks(got), prettyBlocks(want), gotStr)\n\t}\n\n\tfor i := range got {\n\t\tif strings.ContainsAny(want[i], \"\\n\") {\n\t\t\t// Match as stack\n\t\t\tmatch, err := regexp.MatchString(want[i], got[i])\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif !match {\n\t\t\t\tt.Fatalf(\"test %d: block %d: fmt.Sprintf(%q, err):\\ngot:\\n%q\\nwant:\\n%q\\nall-got:\\n%s\\nall-want:\\n%s\\n\",\n\t\t\t\t\tn+1, i+1, format, got[i], want[i], prettyBlocks(got), prettyBlocks(want))\n\t\t\t}\n\t\t} else {\n\t\t\t// Match as message\n\t\t\tif got[i] != want[i] {\n\t\t\t\tt.Fatalf(\"test %d: fmt.Sprintf(%s, err) at block %d got != want:\\n got: %q\\nwant: %q\", n+1, format, i+1, got[i], want[i])\n\t\t\t}\n\t\t}\n\t}\n}\n\ntype wrapper struct {\n\twrap func(err error) error\n\twant []string\n}\n\nfunc prettyBlocks(blocks []string) string {\n\tvar out []string\n\n\tfor _, b := range blocks {\n\t\tout = append(out, fmt.Sprintf(\"%v\", b))\n\t}\n\n\treturn \"   \" + strings.Join(out, \"\\n   \")\n}\n\nfunc testGenericRecursive(t *testing.T, beforeErr error, beforeWant []string, list []wrapper, maxDepth int) {\n\tif len(beforeWant) == 0 {\n\t\tpanic(\"beforeWant must not be empty\")\n\t}\n\tfor _, w := range list {\n\t\tif len(w.want) == 0 {\n\t\t\tpanic(\"want must not be empty\")\n\t\t}\n\n\t\terr := w.wrap(beforeErr)\n\n\t\t// Copy required cause append(beforeWant, ..) modified beforeWant subtly.\n\t\tbeforeCopy := make([]string, len(beforeWant))\n\t\tcopy(beforeCopy, beforeWant)\n\n\t\tbeforeWant := beforeCopy\n\t\tlast := len(beforeWant) - 1\n\t\tvar want []string\n\n\t\t// Merge two stacks behind each other.\n\t\tif strings.ContainsAny(beforeWant[last], \"\\n\") && strings.ContainsAny(w.want[0], \"\\n\") {\n\t\t\twant = append(beforeWant[:last], append([]string{beforeWant[last] + \"((?s).*)\" + w.want[0]}, w.want[1:]...)...)\n\t\t} else {\n\t\t\twant = append(beforeWant, w.want...)\n\t\t}\n\n\t\ttestFormatCompleteCompare(t, maxDepth, err, \"%+v\", want, false)\n\t\tif maxDepth > 0 {\n\t\t\ttestGenericRecursive(t, err, want, list, maxDepth-1)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "go113.go",
          "type": "blob",
          "size": 1.4169921875,
          "content": "// +build go1.13\n\npackage errors\n\nimport (\n\tstderrors \"errors\"\n)\n\n// Is reports whether any error in err's chain matches target.\n//\n// The chain consists of err itself followed by the sequence of errors obtained by\n// repeatedly calling Unwrap.\n//\n// An error is considered to match a target if it is equal to that target or if\n// it implements a method Is(error) bool such that Is(target) returns true.\nfunc Is(err, target error) bool { return stderrors.Is(err, target) }\n\n// As finds the first error in err's chain that matches target, and if so, sets\n// target to that error value and returns true.\n//\n// The chain consists of err itself followed by the sequence of errors obtained by\n// repeatedly calling Unwrap.\n//\n// An error matches target if the error's concrete value is assignable to the value\n// pointed to by target, or if the error has a method As(interface{}) bool such that\n// As(target) returns true. In the latter case, the As method is responsible for\n// setting target.\n//\n// As will panic if target is not a non-nil pointer to either a type that implements\n// error, or to any interface type. As returns false if err is nil.\nfunc As(err error, target interface{}) bool { return stderrors.As(err, target) }\n\n// Unwrap returns the result of calling the Unwrap method on err, if err's\n// type contains an Unwrap method returning error.\n// Otherwise, Unwrap returns nil.\nfunc Unwrap(err error) error {\n\treturn stderrors.Unwrap(err)\n}\n"
        },
        {
          "name": "go113_test.go",
          "type": "blob",
          "size": 3.07421875,
          "content": "// +build go1.13\n\npackage errors\n\nimport (\n\tstderrors \"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestErrorChainCompat(t *testing.T) {\n\terr := stderrors.New(\"error that gets wrapped\")\n\twrapped := Wrap(err, \"wrapped up\")\n\tif !stderrors.Is(wrapped, err) {\n\t\tt.Errorf(\"Wrap does not support Go 1.13 error chains\")\n\t}\n}\n\nfunc TestIs(t *testing.T) {\n\terr := New(\"test\")\n\n\ttype args struct {\n\t\terr    error\n\t\ttarget error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"with stack\",\n\t\t\targs: args{\n\t\t\t\terr:    WithStack(err),\n\t\t\t\ttarget: err,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"with message\",\n\t\t\targs: args{\n\t\t\t\terr:    WithMessage(err, \"test\"),\n\t\t\t\ttarget: err,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"with message format\",\n\t\t\targs: args{\n\t\t\t\terr:    WithMessagef(err, \"%s\", \"test\"),\n\t\t\t\ttarget: err,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"std errors compatibility\",\n\t\t\targs: args{\n\t\t\t\terr:    fmt.Errorf(\"wrap it: %w\", err),\n\t\t\t\ttarget: err,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Is(tt.args.err, tt.args.target); got != tt.want {\n\t\t\t\tt.Errorf(\"Is() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype customErr struct {\n\tmsg string\n}\n\nfunc (c customErr) Error() string { return c.msg }\n\nfunc TestAs(t *testing.T) {\n\tvar err = customErr{msg: \"test message\"}\n\n\ttype args struct {\n\t\terr    error\n\t\ttarget interface{}\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"with stack\",\n\t\t\targs: args{\n\t\t\t\terr:    WithStack(err),\n\t\t\t\ttarget: new(customErr),\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"with message\",\n\t\t\targs: args{\n\t\t\t\terr:    WithMessage(err, \"test\"),\n\t\t\t\ttarget: new(customErr),\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"with message format\",\n\t\t\targs: args{\n\t\t\t\terr:    WithMessagef(err, \"%s\", \"test\"),\n\t\t\t\ttarget: new(customErr),\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"std errors compatibility\",\n\t\t\targs: args{\n\t\t\t\terr:    fmt.Errorf(\"wrap it: %w\", err),\n\t\t\t\ttarget: new(customErr),\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := As(tt.args.err, tt.args.target); got != tt.want {\n\t\t\t\tt.Errorf(\"As() = %v, want %v\", got, tt.want)\n\t\t\t}\n\n\t\t\tce := tt.args.target.(*customErr)\n\t\t\tif !reflect.DeepEqual(err, *ce) {\n\t\t\t\tt.Errorf(\"set target error failed, target error is %v\", *ce)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnwrap(t *testing.T) {\n\terr := New(\"test\")\n\n\ttype args struct {\n\t\terr error\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant error\n\t}{\n\t\t{\n\t\t\tname: \"with stack\",\n\t\t\targs: args{err: WithStack(err)},\n\t\t\twant: err,\n\t\t},\n\t\t{\n\t\t\tname: \"with message\",\n\t\t\targs: args{err: WithMessage(err, \"test\")},\n\t\t\twant: err,\n\t\t},\n\t\t{\n\t\t\tname: \"with message format\",\n\t\t\targs: args{err: WithMessagef(err, \"%s\", \"test\")},\n\t\t\twant: err,\n\t\t},\n\t\t{\n\t\t\tname: \"std errors compatibility\",\n\t\t\targs: args{err: fmt.Errorf(\"wrap: %w\", err)},\n\t\t\twant: err,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif err := Unwrap(tt.args.err); !reflect.DeepEqual(err, tt.want) {\n\t\t\t\tt.Errorf(\"Unwrap() error = %v, want %v\", err, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "json_test.go",
          "type": "blob",
          "size": 0.982421875,
          "content": "package errors\n\nimport (\n\t\"encoding/json\"\n\t\"regexp\"\n\t\"testing\"\n)\n\nfunc TestFrameMarshalText(t *testing.T) {\n\tvar tests = []struct {\n\t\tFrame\n\t\twant string\n\t}{{\n\t\tinitpc,\n\t\t`^github.com/pkg/errors\\.init(\\.ializers)? .+/github\\.com/pkg/errors/stack_test.go:\\d+$`,\n\t}, {\n\t\t0,\n\t\t`^unknown$`,\n\t}}\n\tfor i, tt := range tests {\n\t\tgot, err := tt.Frame.MarshalText()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !regexp.MustCompile(tt.want).Match(got) {\n\t\t\tt.Errorf(\"test %d: MarshalJSON:\\n got %q\\n want %q\", i+1, string(got), tt.want)\n\t\t}\n\t}\n}\n\nfunc TestFrameMarshalJSON(t *testing.T) {\n\tvar tests = []struct {\n\t\tFrame\n\t\twant string\n\t}{{\n\t\tinitpc,\n\t\t`^\"github\\.com/pkg/errors\\.init(\\.ializers)? .+/github\\.com/pkg/errors/stack_test.go:\\d+\"$`,\n\t}, {\n\t\t0,\n\t\t`^\"unknown\"$`,\n\t}}\n\tfor i, tt := range tests {\n\t\tgot, err := json.Marshal(tt.Frame)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !regexp.MustCompile(tt.want).Match(got) {\n\t\t\tt.Errorf(\"test %d: MarshalJSON:\\n got %q\\n want %q\", i+1, string(got), tt.want)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "stack.go",
          "type": "blob",
          "size": 4.1220703125,
          "content": "package errors\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"path\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Frame represents a program counter inside a stack frame.\n// For historical reasons if Frame is interpreted as a uintptr\n// its value represents the program counter + 1.\ntype Frame uintptr\n\n// pc returns the program counter for this frame;\n// multiple frames may have the same PC value.\nfunc (f Frame) pc() uintptr { return uintptr(f) - 1 }\n\n// file returns the full path to the file that contains the\n// function for this Frame's pc.\nfunc (f Frame) file() string {\n\tfn := runtime.FuncForPC(f.pc())\n\tif fn == nil {\n\t\treturn \"unknown\"\n\t}\n\tfile, _ := fn.FileLine(f.pc())\n\treturn file\n}\n\n// line returns the line number of source code of the\n// function for this Frame's pc.\nfunc (f Frame) line() int {\n\tfn := runtime.FuncForPC(f.pc())\n\tif fn == nil {\n\t\treturn 0\n\t}\n\t_, line := fn.FileLine(f.pc())\n\treturn line\n}\n\n// name returns the name of this function, if known.\nfunc (f Frame) name() string {\n\tfn := runtime.FuncForPC(f.pc())\n\tif fn == nil {\n\t\treturn \"unknown\"\n\t}\n\treturn fn.Name()\n}\n\n// Format formats the frame according to the fmt.Formatter interface.\n//\n//    %s    source file\n//    %d    source line\n//    %n    function name\n//    %v    equivalent to %s:%d\n//\n// Format accepts flags that alter the printing of some verbs, as follows:\n//\n//    %+s   function name and path of source file relative to the compile time\n//          GOPATH separated by \\n\\t (<funcname>\\n\\t<path>)\n//    %+v   equivalent to %+s:%d\nfunc (f Frame) Format(s fmt.State, verb rune) {\n\tswitch verb {\n\tcase 's':\n\t\tswitch {\n\t\tcase s.Flag('+'):\n\t\t\tio.WriteString(s, f.name())\n\t\t\tio.WriteString(s, \"\\n\\t\")\n\t\t\tio.WriteString(s, f.file())\n\t\tdefault:\n\t\t\tio.WriteString(s, path.Base(f.file()))\n\t\t}\n\tcase 'd':\n\t\tio.WriteString(s, strconv.Itoa(f.line()))\n\tcase 'n':\n\t\tio.WriteString(s, funcname(f.name()))\n\tcase 'v':\n\t\tf.Format(s, 's')\n\t\tio.WriteString(s, \":\")\n\t\tf.Format(s, 'd')\n\t}\n}\n\n// MarshalText formats a stacktrace Frame as a text string. The output is the\n// same as that of fmt.Sprintf(\"%+v\", f), but without newlines or tabs.\nfunc (f Frame) MarshalText() ([]byte, error) {\n\tname := f.name()\n\tif name == \"unknown\" {\n\t\treturn []byte(name), nil\n\t}\n\treturn []byte(fmt.Sprintf(\"%s %s:%d\", name, f.file(), f.line())), nil\n}\n\n// StackTrace is stack of Frames from innermost (newest) to outermost (oldest).\ntype StackTrace []Frame\n\n// Format formats the stack of Frames according to the fmt.Formatter interface.\n//\n//    %s\tlists source files for each Frame in the stack\n//    %v\tlists the source file and line number for each Frame in the stack\n//\n// Format accepts flags that alter the printing of some verbs, as follows:\n//\n//    %+v   Prints filename, function, and line number for each Frame in the stack.\nfunc (st StackTrace) Format(s fmt.State, verb rune) {\n\tswitch verb {\n\tcase 'v':\n\t\tswitch {\n\t\tcase s.Flag('+'):\n\t\t\tfor _, f := range st {\n\t\t\t\tio.WriteString(s, \"\\n\")\n\t\t\t\tf.Format(s, verb)\n\t\t\t}\n\t\tcase s.Flag('#'):\n\t\t\tfmt.Fprintf(s, \"%#v\", []Frame(st))\n\t\tdefault:\n\t\t\tst.formatSlice(s, verb)\n\t\t}\n\tcase 's':\n\t\tst.formatSlice(s, verb)\n\t}\n}\n\n// formatSlice will format this StackTrace into the given buffer as a slice of\n// Frame, only valid when called with '%s' or '%v'.\nfunc (st StackTrace) formatSlice(s fmt.State, verb rune) {\n\tio.WriteString(s, \"[\")\n\tfor i, f := range st {\n\t\tif i > 0 {\n\t\t\tio.WriteString(s, \" \")\n\t\t}\n\t\tf.Format(s, verb)\n\t}\n\tio.WriteString(s, \"]\")\n}\n\n// stack represents a stack of program counters.\ntype stack []uintptr\n\nfunc (s *stack) Format(st fmt.State, verb rune) {\n\tswitch verb {\n\tcase 'v':\n\t\tswitch {\n\t\tcase st.Flag('+'):\n\t\t\tfor _, pc := range *s {\n\t\t\t\tf := Frame(pc)\n\t\t\t\tfmt.Fprintf(st, \"\\n%+v\", f)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (s *stack) StackTrace() StackTrace {\n\tf := make([]Frame, len(*s))\n\tfor i := 0; i < len(f); i++ {\n\t\tf[i] = Frame((*s)[i])\n\t}\n\treturn f\n}\n\nfunc callers() *stack {\n\tconst depth = 32\n\tvar pcs [depth]uintptr\n\tn := runtime.Callers(3, pcs[:])\n\tvar st stack = pcs[0:n]\n\treturn &st\n}\n\n// funcname removes the path prefix component of a function's name reported by func.Name().\nfunc funcname(name string) string {\n\ti := strings.LastIndex(name, \"/\")\n\tname = name[i+1:]\n\ti = strings.Index(name, \".\")\n\treturn name[i+1:]\n}\n"
        },
        {
          "name": "stack_test.go",
          "type": "blob",
          "size": 4.7001953125,
          "content": "package errors\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n\t\"testing\"\n)\n\nvar initpc = caller()\n\ntype X struct{}\n\n// val returns a Frame pointing to itself.\nfunc (x X) val() Frame {\n\treturn caller()\n}\n\n// ptr returns a Frame pointing to itself.\nfunc (x *X) ptr() Frame {\n\treturn caller()\n}\n\nfunc TestFrameFormat(t *testing.T) {\n\tvar tests = []struct {\n\t\tFrame\n\t\tformat string\n\t\twant   string\n\t}{{\n\t\tinitpc,\n\t\t\"%s\",\n\t\t\"stack_test.go\",\n\t}, {\n\t\tinitpc,\n\t\t\"%+s\",\n\t\t\"github.com/pkg/errors.init\\n\" +\n\t\t\t\"\\t.+/github.com/pkg/errors/stack_test.go\",\n\t}, {\n\t\t0,\n\t\t\"%s\",\n\t\t\"unknown\",\n\t}, {\n\t\t0,\n\t\t\"%+s\",\n\t\t\"unknown\",\n\t}, {\n\t\tinitpc,\n\t\t\"%d\",\n\t\t\"9\",\n\t}, {\n\t\t0,\n\t\t\"%d\",\n\t\t\"0\",\n\t}, {\n\t\tinitpc,\n\t\t\"%n\",\n\t\t\"init\",\n\t}, {\n\t\tfunc() Frame {\n\t\t\tvar x X\n\t\t\treturn x.ptr()\n\t\t}(),\n\t\t\"%n\",\n\t\t`\\(\\*X\\).ptr`,\n\t}, {\n\t\tfunc() Frame {\n\t\t\tvar x X\n\t\t\treturn x.val()\n\t\t}(),\n\t\t\"%n\",\n\t\t\"X.val\",\n\t}, {\n\t\t0,\n\t\t\"%n\",\n\t\t\"\",\n\t}, {\n\t\tinitpc,\n\t\t\"%v\",\n\t\t\"stack_test.go:9\",\n\t}, {\n\t\tinitpc,\n\t\t\"%+v\",\n\t\t\"github.com/pkg/errors.init\\n\" +\n\t\t\t\"\\t.+/github.com/pkg/errors/stack_test.go:9\",\n\t}, {\n\t\t0,\n\t\t\"%v\",\n\t\t\"unknown:0\",\n\t}}\n\n\tfor i, tt := range tests {\n\t\ttestFormatRegexp(t, i, tt.Frame, tt.format, tt.want)\n\t}\n}\n\nfunc TestFuncname(t *testing.T) {\n\ttests := []struct {\n\t\tname, want string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"runtime.main\", \"main\"},\n\t\t{\"github.com/pkg/errors.funcname\", \"funcname\"},\n\t\t{\"funcname\", \"funcname\"},\n\t\t{\"io.copyBuffer\", \"copyBuffer\"},\n\t\t{\"main.(*R).Write\", \"(*R).Write\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tgot := funcname(tt.name)\n\t\twant := tt.want\n\t\tif got != want {\n\t\t\tt.Errorf(\"funcname(%q): want: %q, got %q\", tt.name, want, got)\n\t\t}\n\t}\n}\n\nfunc TestStackTrace(t *testing.T) {\n\ttests := []struct {\n\t\terr  error\n\t\twant []string\n\t}{{\n\t\tNew(\"ooh\"), []string{\n\t\t\t\"github.com/pkg/errors.TestStackTrace\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/stack_test.go:121\",\n\t\t},\n\t}, {\n\t\tWrap(New(\"ooh\"), \"ahh\"), []string{\n\t\t\t\"github.com/pkg/errors.TestStackTrace\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/stack_test.go:126\", // this is the stack of Wrap, not New\n\t\t},\n\t}, {\n\t\tCause(Wrap(New(\"ooh\"), \"ahh\")), []string{\n\t\t\t\"github.com/pkg/errors.TestStackTrace\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/stack_test.go:131\", // this is the stack of New\n\t\t},\n\t}, {\n\t\tfunc() error { return New(\"ooh\") }(), []string{\n\t\t\t`github.com/pkg/errors.TestStackTrace.func1` +\n\t\t\t\t\"\\n\\t.+/github.com/pkg/errors/stack_test.go:136\", // this is the stack of New\n\t\t\t\"github.com/pkg/errors.TestStackTrace\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/stack_test.go:136\", // this is the stack of New's caller\n\t\t},\n\t}, {\n\t\tCause(func() error {\n\t\t\treturn func() error {\n\t\t\t\treturn Errorf(\"hello %s\", fmt.Sprintf(\"world: %s\", \"ooh\"))\n\t\t\t}()\n\t\t}()), []string{\n\t\t\t`github.com/pkg/errors.TestStackTrace.func2.1` +\n\t\t\t\t\"\\n\\t.+/github.com/pkg/errors/stack_test.go:145\", // this is the stack of Errorf\n\t\t\t`github.com/pkg/errors.TestStackTrace.func2` +\n\t\t\t\t\"\\n\\t.+/github.com/pkg/errors/stack_test.go:146\", // this is the stack of Errorf's caller\n\t\t\t\"github.com/pkg/errors.TestStackTrace\\n\" +\n\t\t\t\t\"\\t.+/github.com/pkg/errors/stack_test.go:147\", // this is the stack of Errorf's caller's caller\n\t\t},\n\t}}\n\tfor i, tt := range tests {\n\t\tx, ok := tt.err.(interface {\n\t\t\tStackTrace() StackTrace\n\t\t})\n\t\tif !ok {\n\t\t\tt.Errorf(\"expected %#v to implement StackTrace() StackTrace\", tt.err)\n\t\t\tcontinue\n\t\t}\n\t\tst := x.StackTrace()\n\t\tfor j, want := range tt.want {\n\t\t\ttestFormatRegexp(t, i, st[j], \"%+v\", want)\n\t\t}\n\t}\n}\n\nfunc stackTrace() StackTrace {\n\tconst depth = 8\n\tvar pcs [depth]uintptr\n\tn := runtime.Callers(1, pcs[:])\n\tvar st stack = pcs[0:n]\n\treturn st.StackTrace()\n}\n\nfunc TestStackTraceFormat(t *testing.T) {\n\ttests := []struct {\n\t\tStackTrace\n\t\tformat string\n\t\twant   string\n\t}{{\n\t\tnil,\n\t\t\"%s\",\n\t\t`\\[\\]`,\n\t}, {\n\t\tnil,\n\t\t\"%v\",\n\t\t`\\[\\]`,\n\t}, {\n\t\tnil,\n\t\t\"%+v\",\n\t\t\"\",\n\t}, {\n\t\tnil,\n\t\t\"%#v\",\n\t\t`\\[\\]errors.Frame\\(nil\\)`,\n\t}, {\n\t\tmake(StackTrace, 0),\n\t\t\"%s\",\n\t\t`\\[\\]`,\n\t}, {\n\t\tmake(StackTrace, 0),\n\t\t\"%v\",\n\t\t`\\[\\]`,\n\t}, {\n\t\tmake(StackTrace, 0),\n\t\t\"%+v\",\n\t\t\"\",\n\t}, {\n\t\tmake(StackTrace, 0),\n\t\t\"%#v\",\n\t\t`\\[\\]errors.Frame{}`,\n\t}, {\n\t\tstackTrace()[:2],\n\t\t\"%s\",\n\t\t`\\[stack_test.go stack_test.go\\]`,\n\t}, {\n\t\tstackTrace()[:2],\n\t\t\"%v\",\n\t\t`\\[stack_test.go:174 stack_test.go:221\\]`,\n\t}, {\n\t\tstackTrace()[:2],\n\t\t\"%+v\",\n\t\t\"\\n\" +\n\t\t\t\"github.com/pkg/errors.stackTrace\\n\" +\n\t\t\t\"\\t.+/github.com/pkg/errors/stack_test.go:174\\n\" +\n\t\t\t\"github.com/pkg/errors.TestStackTraceFormat\\n\" +\n\t\t\t\"\\t.+/github.com/pkg/errors/stack_test.go:225\",\n\t}, {\n\t\tstackTrace()[:2],\n\t\t\"%#v\",\n\t\t`\\[\\]errors.Frame{stack_test.go:174, stack_test.go:233}`,\n\t}}\n\n\tfor i, tt := range tests {\n\t\ttestFormatRegexp(t, i, tt.StackTrace, tt.format, tt.want)\n\t}\n}\n\n// a version of runtime.Caller that returns a Frame, not a uintptr.\nfunc caller() Frame {\n\tvar pcs [3]uintptr\n\tn := runtime.Callers(2, pcs[:])\n\tframes := runtime.CallersFrames(pcs[:n])\n\tframe, _ := frames.Next()\n\treturn Frame(frame.PC)\n}\n"
        }
      ]
    }
  ]
}