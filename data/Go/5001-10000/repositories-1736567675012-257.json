{
  "metadata": {
    "timestamp": 1736567675012,
    "page": 257,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "gobwas/ws",
      "stars": 6182,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.037109375,
          "content": "bin/\nreports/\ncpu.out\nmem.out\nws.test\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.080078125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2017-2021 Sergey Kamardin <gobwas@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.580078125,
          "content": "BENCH     ?=.\nBENCH_BASE?=master\n\nclean:\n\trm -f bin/reporter\n\trm -fr autobahn/report/*\n\nbin/reporter:\n\tgo build -o bin/reporter ./autobahn\n\nbin/gocovmerge:\n\tgo build -o bin/gocovmerge github.com/wadey/gocovmerge\n\n.PHONY: autobahn\nautobahn: clean bin/reporter \n\t./autobahn/script/test.sh --build --follow-logs\n\tbin/reporter $(PWD)/autobahn/report/index.json\n\n.PHONY: autobahn/report\nautobahn/report: bin/reporter\n\t./bin/reporter -http localhost:5555 ./autobahn/report/index.json\n\ntest:\n\tgo test -coverprofile=ws.coverage .\n\tgo test -coverprofile=wsutil.coverage ./wsutil\n\tgo test -coverprofile=wsfalte.coverage ./wsflate\n\t# No statements to cover in ./tests (there are only tests).\n\tgo test ./tests\n\ncover: bin/gocovmerge test autobahn\n\tbin/gocovmerge ws.coverage wsutil.coverage wsflate.coverage autobahn/report/server.coverage > total.coverage\n\nbenchcmp: BENCH_BRANCH=$(shell git rev-parse --abbrev-ref HEAD)\nbenchcmp: BENCH_OLD:=$(shell mktemp -t old.XXXX)\nbenchcmp: BENCH_NEW:=$(shell mktemp -t new.XXXX)\nbenchcmp:\n\tif [ ! -z \"$(shell git status -s)\" ]; then\\\n\t\techo \"could not compare with $(BENCH_BASE) â€“ found unstaged changes\";\\\n\t\texit 1;\\\n\tfi;\\\n\tif [ \"$(BENCH_BRANCH)\" == \"$(BENCH_BASE)\" ]; then\\\n\t\techo \"comparing the same branches\";\\\n\t\texit 1;\\\n\tfi;\\\n\techo \"benchmarking $(BENCH_BRANCH)...\";\\\n\tgo test -run=none -bench=$(BENCH) -benchmem > $(BENCH_NEW);\\\n\techo \"benchmarking $(BENCH_BASE)...\";\\\n\tgit checkout -q $(BENCH_BASE);\\\n\tgo test -run=none -bench=$(BENCH) -benchmem > $(BENCH_OLD);\\\n\tgit checkout -q $(BENCH_BRANCH);\\\n\techo \"\\nresults:\";\\\n\techo \"========\\n\";\\\n\tbenchcmp $(BENCH_OLD) $(BENCH_NEW);\\\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.5439453125,
          "content": "# ws\n\n[![GoDoc][godoc-image]][godoc-url]\n[![CI][ci-badge]][ci-url]\n\n> [RFC6455][rfc-url] WebSocket implementation in Go.\n\n# Features\n\n- Zero-copy upgrade\n- No intermediate allocations during I/O\n- Low-level API which allows to build your own logic of packet handling and\n  buffers reuse\n- High-level wrappers and helpers around API in `wsutil` package, which allow\n  to start fast without digging the protocol internals\n\n# Documentation\n\n[GoDoc][godoc-url].\n\n# Why\n\nExisting WebSocket implementations do not allow users to reuse I/O buffers\nbetween connections in clear way. This library aims to export efficient\nlow-level interface for working with the protocol without forcing only one way\nit could be used.\n\nBy the way, if you want get the higher-level tools, you can use `wsutil`\npackage.\n\n# Status\n\nLibrary is tagged as `v1*` so its API must not be broken during some\nimprovements or refactoring.\n\nThis implementation of RFC6455 passes [Autobahn Test\nSuite](https://github.com/crossbario/autobahn-testsuite) and currently has\nabout 78% coverage.\n\n# Examples\n\nExample applications using `ws` are developed in separate repository\n[ws-examples](https://github.com/gobwas/ws-examples).\n\n# Usage\n\nThe higher-level example of WebSocket echo server:\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gobwas/ws\"\n\t\"github.com/gobwas/ws/wsutil\"\n)\n\nfunc main() {\n\thttp.ListenAndServe(\":8080\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tconn, _, _, err := ws.UpgradeHTTP(r, w)\n\t\tif err != nil {\n\t\t\t// handle error\n\t\t}\n\t\tgo func() {\n\t\t\tdefer conn.Close()\n\n\t\t\tfor {\n\t\t\t\tmsg, op, err := wsutil.ReadClientData(conn)\n\t\t\t\tif err != nil {\n\t\t\t\t\t// handle error\n\t\t\t\t}\n\t\t\t\terr = wsutil.WriteServerMessage(conn, op, msg)\n\t\t\t\tif err != nil {\n\t\t\t\t\t// handle error\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}))\n}\n```\n\nLower-level, but still high-level example:\n\n\n```go\nimport (\n\t\"net/http\"\n\t\"io\"\n\n\t\"github.com/gobwas/ws\"\n\t\"github.com/gobwas/ws/wsutil\"\n)\n\nfunc main() {\n\thttp.ListenAndServe(\":8080\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tconn, _, _, err := ws.UpgradeHTTP(r, w)\n\t\tif err != nil {\n\t\t\t// handle error\n\t\t}\n\t\tgo func() {\n\t\t\tdefer conn.Close()\n\n\t\t\tvar (\n\t\t\t\tstate  = ws.StateServerSide\n\t\t\t\treader = wsutil.NewReader(conn, state)\n\t\t\t\twriter = wsutil.NewWriter(conn, state, ws.OpText)\n\t\t\t)\n\t\t\tfor {\n\t\t\t\theader, err := reader.NextFrame()\n\t\t\t\tif err != nil {\n\t\t\t\t\t// handle error\n\t\t\t\t}\n\n\t\t\t\t// Reset writer to write frame with right operation code.\n\t\t\t\twriter.Reset(conn, state, header.OpCode)\n\n\t\t\t\tif _, err = io.Copy(writer, reader); err != nil {\n\t\t\t\t\t// handle error\n\t\t\t\t}\n\t\t\t\tif err = writer.Flush(); err != nil {\n\t\t\t\t\t// handle error\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}))\n}\n```\n\nWe can apply the same pattern to read and write structured responses through a JSON encoder and decoder.:\n\n```go\n\t...\n\tvar (\n\t\tr = wsutil.NewReader(conn, ws.StateServerSide)\n\t\tw = wsutil.NewWriter(conn, ws.StateServerSide, ws.OpText)\n\t\tdecoder = json.NewDecoder(r)\n\t\tencoder = json.NewEncoder(w)\n\t)\n\tfor {\n\t\thdr, err = r.NextFrame()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif hdr.OpCode == ws.OpClose {\n\t\t\treturn io.EOF\n\t\t}\n\t\tvar req Request\n\t\tif err := decoder.Decode(&req); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar resp Response\n\t\tif err := encoder.Encode(&resp); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = w.Flush(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t...\n```\n\nThe lower-level example without `wsutil`:\n\n```go\npackage main\n\nimport (\n\t\"net\"\n\t\"io\"\n\n\t\"github.com/gobwas/ws\"\n)\n\nfunc main() {\n\tln, err := net.Listen(\"tcp\", \"localhost:8080\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\t// handle error\n\t\t}\n\t\t_, err = ws.Upgrade(conn)\n\t\tif err != nil {\n\t\t\t// handle error\n\t\t}\n\n\t\tgo func() {\n\t\t\tdefer conn.Close()\n\n\t\t\tfor {\n\t\t\t\theader, err := ws.ReadHeader(conn)\n\t\t\t\tif err != nil {\n\t\t\t\t\t// handle error\n\t\t\t\t}\n\n\t\t\t\tpayload := make([]byte, header.Length)\n\t\t\t\t_, err = io.ReadFull(conn, payload)\n\t\t\t\tif err != nil {\n\t\t\t\t\t// handle error\n\t\t\t\t}\n\t\t\t\tif header.Masked {\n\t\t\t\t\tws.Cipher(payload, header.Mask, 0)\n\t\t\t\t}\n\n\t\t\t\t// Reset the Masked flag, server frames must not be masked as\n\t\t\t\t// RFC6455 says.\n\t\t\t\theader.Masked = false\n\n\t\t\t\tif err := ws.WriteHeader(conn, header); err != nil {\n\t\t\t\t\t// handle error\n\t\t\t\t}\n\t\t\t\tif _, err := conn.Write(payload); err != nil {\n\t\t\t\t\t// handle error\n\t\t\t\t}\n\n\t\t\t\tif header.OpCode == ws.OpClose {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n}\n```\n\n# Zero-copy upgrade\n\nZero-copy upgrade helps to avoid unnecessary allocations and copying while\nhandling HTTP Upgrade request.\n\nProcessing of all non-websocket headers is made in place with use of registered\nuser callbacks whose arguments are only valid until callback returns.\n\nThe simple example looks like this:\n\n```go\npackage main\n\nimport (\n\t\"net\"\n\t\"log\"\n\n\t\"github.com/gobwas/ws\"\n)\n\nfunc main() {\n\tln, err := net.Listen(\"tcp\", \"localhost:8080\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tu := ws.Upgrader{\n\t\tOnHeader: func(key, value []byte) (err error) {\n\t\t\tlog.Printf(\"non-websocket header: %q=%q\", key, value)\n\t\t\treturn\n\t\t},\n\t}\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\t// handle error\n\t\t}\n\n\t\t_, err = u.Upgrade(conn)\n\t\tif err != nil {\n\t\t\t// handle error\n\t\t}\n\t}\n}\n```\n\nUsage of `ws.Upgrader` here brings ability to control incoming connections on\ntcp level and simply not to accept them by some logic.\n\nZero-copy upgrade is for high-load services which have to control many\nresources such as connections buffers.\n\nThe real life example could be like this:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"runtime\"\n\n\t\"github.com/gobwas/httphead\"\n\t\"github.com/gobwas/ws\"\n)\n\nfunc main() {\n\tln, err := net.Listen(\"tcp\", \"localhost:8080\")\n\tif err != nil {\n\t\t// handle error\n\t}\n\n\t// Prepare handshake header writer from http.Header mapping.\n\theader := ws.HandshakeHeaderHTTP(http.Header{\n\t\t\"X-Go-Version\": []string{runtime.Version()},\n\t})\n\n\tu := ws.Upgrader{\n\t\tOnHost: func(host []byte) error {\n\t\t\tif string(host) == \"github.com\" {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn ws.RejectConnectionError(\n\t\t\t\tws.RejectionStatus(403),\n\t\t\t\tws.RejectionHeader(ws.HandshakeHeaderString(\n\t\t\t\t\t\"X-Want-Host: github.com\\r\\n\",\n\t\t\t\t)),\n\t\t\t)\n\t\t},\n\t\tOnHeader: func(key, value []byte) error {\n\t\t\tif string(key) != \"Cookie\" {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tok := httphead.ScanCookie(value, func(key, value []byte) bool {\n\t\t\t\t// Check session here or do some other stuff with cookies.\n\t\t\t\t// Maybe copy some values for future use.\n\t\t\t\treturn true\n\t\t\t})\n\t\t\tif ok {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn ws.RejectConnectionError(\n\t\t\t\tws.RejectionReason(\"bad cookie\"),\n\t\t\t\tws.RejectionStatus(400),\n\t\t\t)\n\t\t},\n\t\tOnBeforeUpgrade: func() (ws.HandshakeHeader, error) {\n\t\t\treturn header, nil\n\t\t},\n\t}\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\t_, err = u.Upgrade(conn)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"upgrade error: %s\", err)\n\t\t}\n\t}\n}\n```\n\n# Compression\n\nThere is a `ws/wsflate` package to support [Permessage-Deflate Compression\nExtension][rfc-pmce].\n\nIt provides minimalistic I/O wrappers to be used in conjunction with any\ndeflate implementation (for example, the standard library's\n[compress/flate][compress/flate]).\n\nIt is also compatible with `wsutil`'s reader and writer by providing\n`wsflate.MessageState` type, which implements `wsutil.SendExtension` and\n`wsutil.RecvExtension` interfaces.\n\n```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\t\"net\"\n\n\t\"github.com/gobwas/ws\"\n\t\"github.com/gobwas/ws/wsflate\"\n)\n\nfunc main() {\n\tln, err := net.Listen(\"tcp\", \"localhost:8080\")\n\tif err != nil {\n\t\t// handle error\n\t}\n\te := wsflate.Extension{\n\t\t// We are using default parameters here since we use\n\t\t// wsflate.{Compress,Decompress}Frame helpers below in the code.\n\t\t// This assumes that we use standard compress/flate package as flate\n\t\t// implementation.\n\t\tParameters: wsflate.DefaultParameters,\n\t}\n\tu := ws.Upgrader{\n\t\tNegotiate: e.Negotiate,\n\t}\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\t// Reset extension after previous upgrades.\n\t\te.Reset()\n\n\t\t_, err = u.Upgrade(conn)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"upgrade error: %s\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif _, ok := e.Accepted(); !ok {\n\t\t\tlog.Printf(\"didn't negotiate compression for %s\", conn.RemoteAddr())\n\t\t\tconn.Close()\n\t\t\tcontinue\n\t\t}\n\n\t\tgo func() {\n\t\t\tdefer conn.Close()\n\t\t\tfor {\n\t\t\t\tframe, err := ws.ReadFrame(conn)\n\t\t\t\tif err != nil {\n\t\t\t\t\t// Handle error.\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tframe = ws.UnmaskFrameInPlace(frame)\n\n\t\t\t\tif wsflate.IsCompressed(frame.Header) {\n\t\t\t\t\t// Note that even after successful negotiation of\n\t\t\t\t\t// compression extension, both sides are able to send\n\t\t\t\t\t// non-compressed messages.\n\t\t\t\t\tframe, err = wsflate.DecompressFrame(frame)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t// Handle error.\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Do something with frame...\n\n\t\t\t\tack := ws.NewTextFrame([]byte(\"this is an acknowledgement\"))\n\n\t\t\t\t// Compress response unconditionally.\n\t\t\t\tack, err = wsflate.CompressFrame(ack)\n\t\t\t\tif err != nil {\n\t\t\t\t\t// Handle error.\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err = ws.WriteFrame(conn, ack); err != nil {\n\t\t\t\t\t// Handle error.\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n}\n```\n\nYou can use compression with `wsutil` package this way:\n\n```go\n\t// Upgrade somehow and negotiate compression to get the conn...\n\n\t// Initialize flate reader. We are using nil as a source io.Reader because\n\t// we will Reset() it in the message i/o loop below.\n\tfr := wsflate.NewReader(nil, func(r io.Reader) wsflate.Decompressor {\n\t\treturn flate.NewReader(r)\n\t})\n\t// Initialize flate writer. We are using nil as a destination io.Writer\n\t// because we will Reset() it in the message i/o loop below.\n\tfw := wsflate.NewWriter(nil, func(w io.Writer) wsflate.Compressor {\n\t\tf, _ := flate.NewWriter(w, 9)\n\t\treturn f\n\t})\n\n\t// Declare compression message state variable.\n\t//\n\t// It has two goals:\n\t// - Allow users to check whether received message is compressed or not.\n\t// - Help wsutil.Reader and wsutil.Writer to set/unset appropriate\n\t//   WebSocket header bits while writing next frame to the wire (it\n\t//   implements wsutil.RecvExtension and wsutil.SendExtension).\n\tvar msg wsflate.MessageState\n\n\t// Initialize WebSocket reader as previously. \n\t// Please note the use of Reader.Extensions field as well as\n\t// of ws.StateExtended flag.\n\trd := &wsutil.Reader{\n\t\tSource:     conn,\n\t\tState:      ws.StateServerSide | ws.StateExtended,\n\t\tExtensions: []wsutil.RecvExtension{\n\t\t\t&msg, \n\t\t},\n\t}\n\n\t// Initialize WebSocket writer with ws.StateExtended flag as well.\n\twr := wsutil.NewWriter(conn, ws.StateServerSide|ws.StateExtended, 0)\n\t// Use the message state as wsutil.SendExtension.\n\twr.SetExtensions(&msg)\n\n\tfor {\n\t\th, err := rd.NextFrame()\n\t\tif err != nil {\n\t\t\t// handle error.\n\t\t}\n\t\tif h.OpCode.IsControl() {\n\t\t\t// handle control frame.\n\t\t}\n\t\tif !msg.IsCompressed() {\n\t\t\t// handle uncompressed frame (skipped for the sake of example\n\t\t\t// simplicity).\n\t\t}\n\n\t\t// Reset the writer to echo same op code.\n\t\twr.Reset(h.OpCode)\n\n\t\t// Reset both flate reader and writer to start the new round of i/o.\n\t\tfr.Reset(rd)\n\t\tfw.Reset(wr)\n\n\t\t// Copy whole message from reader to writer decompressing it and\n\t\t// compressing again.\n\t\tif _, err := io.Copy(fw, fr); err != nil {\n\t\t\t// handle error.\n\t\t}\n\t\t// Flush any remaining buffers from flate writer to WebSocket writer.\n\t\tif err := fw.Close(); err != nil {\n\t\t\t// handle error.\n\t\t}\n\t\t// Flush the whole WebSocket message to the wire.\n\t\tif err := wr.Flush(); err != nil {\n\t\t\t// handle error.\n\t\t}\n\t}\n```\n\n\n[rfc-url]: https://tools.ietf.org/html/rfc6455\n[rfc-pmce]: https://tools.ietf.org/html/rfc7692#section-7\n[godoc-image]: https://godoc.org/github.com/gobwas/ws?status.svg\n[godoc-url]: https://godoc.org/github.com/gobwas/ws\n[compress/flate]: https://golang.org/pkg/compress/flate/\n[ci-badge]:    https://github.com/gobwas/ws/workflows/CI/badge.svg\n[ci-url]:      https://github.com/gobwas/ws/actions?query=workflow%3ACI\n"
        },
        {
          "name": "autobahn",
          "type": "tree",
          "content": null
        },
        {
          "name": "check.go",
          "type": "blob",
          "size": 5.244140625,
          "content": "package ws\n\nimport \"unicode/utf8\"\n\n// State represents state of websocket endpoint.\n// It used by some functions to be more strict when checking compatibility with RFC6455.\ntype State uint8\n\nconst (\n\t// StateServerSide means that endpoint (caller) is a server.\n\tStateServerSide State = 0x1 << iota\n\t// StateClientSide means that endpoint (caller) is a client.\n\tStateClientSide\n\t// StateExtended means that extension was negotiated during handshake.\n\tStateExtended\n\t// StateFragmented means that endpoint (caller) has received fragmented\n\t// frame and waits for continuation parts.\n\tStateFragmented\n)\n\n// Is checks whether the s has v enabled.\nfunc (s State) Is(v State) bool {\n\treturn uint8(s)&uint8(v) != 0\n}\n\n// Set enables v state on s.\nfunc (s State) Set(v State) State {\n\treturn s | v\n}\n\n// Clear disables v state on s.\nfunc (s State) Clear(v State) State {\n\treturn s & (^v)\n}\n\n// ServerSide reports whether states represents server side.\nfunc (s State) ServerSide() bool { return s.Is(StateServerSide) }\n\n// ClientSide reports whether state represents client side.\nfunc (s State) ClientSide() bool { return s.Is(StateClientSide) }\n\n// Extended reports whether state is extended.\nfunc (s State) Extended() bool { return s.Is(StateExtended) }\n\n// Fragmented reports whether state is fragmented.\nfunc (s State) Fragmented() bool { return s.Is(StateFragmented) }\n\n// ProtocolError describes error during checking/parsing websocket frames or\n// headers.\ntype ProtocolError string\n\n// Error implements error interface.\nfunc (p ProtocolError) Error() string { return string(p) }\n\n// Errors used by the protocol checkers.\nvar (\n\tErrProtocolOpCodeReserved             = ProtocolError(\"use of reserved op code\")\n\tErrProtocolControlPayloadOverflow     = ProtocolError(\"control frame payload limit exceeded\")\n\tErrProtocolControlNotFinal            = ProtocolError(\"control frame is not final\")\n\tErrProtocolNonZeroRsv                 = ProtocolError(\"non-zero rsv bits with no extension negotiated\")\n\tErrProtocolMaskRequired               = ProtocolError(\"frames from client to server must be masked\")\n\tErrProtocolMaskUnexpected             = ProtocolError(\"frames from server to client must be not masked\")\n\tErrProtocolContinuationExpected       = ProtocolError(\"unexpected non-continuation data frame\")\n\tErrProtocolContinuationUnexpected     = ProtocolError(\"unexpected continuation data frame\")\n\tErrProtocolStatusCodeNotInUse         = ProtocolError(\"status code is not in use\")\n\tErrProtocolStatusCodeApplicationLevel = ProtocolError(\"status code is only application level\")\n\tErrProtocolStatusCodeNoMeaning        = ProtocolError(\"status code has no meaning yet\")\n\tErrProtocolStatusCodeUnknown          = ProtocolError(\"status code is not defined in spec\")\n\tErrProtocolInvalidUTF8                = ProtocolError(\"invalid utf8 sequence in close reason\")\n)\n\n// CheckHeader checks h to contain valid header data for given state s.\n//\n// Note that zero state (0) means that state is clean,\n// neither server or client side, nor fragmented, nor extended.\nfunc CheckHeader(h Header, s State) error {\n\tif h.OpCode.IsReserved() {\n\t\treturn ErrProtocolOpCodeReserved\n\t}\n\tif h.OpCode.IsControl() {\n\t\tif h.Length > MaxControlFramePayloadSize {\n\t\t\treturn ErrProtocolControlPayloadOverflow\n\t\t}\n\t\tif !h.Fin {\n\t\t\treturn ErrProtocolControlNotFinal\n\t\t}\n\t}\n\n\tswitch {\n\t// [RFC6455]: MUST be 0 unless an extension is negotiated that defines meanings for\n\t// non-zero values. If a nonzero value is received and none of the\n\t// negotiated extensions defines the meaning of such a nonzero value, the\n\t// receiving endpoint MUST _Fail the WebSocket Connection_.\n\tcase h.Rsv != 0 && !s.Extended():\n\t\treturn ErrProtocolNonZeroRsv\n\n\t// [RFC6455]: The server MUST close the connection upon receiving a frame that is not masked.\n\t// In this case, a server MAY send a Close frame with a status code of 1002 (protocol error)\n\t// as defined in Section 7.4.1. A server MUST NOT mask any frames that it sends to the client.\n\t// A client MUST close a connection if it detects a masked frame. In this case, it MAY use the\n\t// status code 1002 (protocol error) as defined in Section 7.4.1.\n\tcase s.ServerSide() && !h.Masked:\n\t\treturn ErrProtocolMaskRequired\n\tcase s.ClientSide() && h.Masked:\n\t\treturn ErrProtocolMaskUnexpected\n\n\t// [RFC6455]: See detailed explanation in 5.4 section.\n\tcase s.Fragmented() && !h.OpCode.IsControl() && h.OpCode != OpContinuation:\n\t\treturn ErrProtocolContinuationExpected\n\tcase !s.Fragmented() && h.OpCode == OpContinuation:\n\t\treturn ErrProtocolContinuationUnexpected\n\n\tdefault:\n\t\treturn nil\n\t}\n}\n\n// CheckCloseFrameData checks received close information\n// to be valid RFC6455 compatible close info.\n//\n// Note that code.Empty() or code.IsAppLevel() will raise error.\n//\n// If endpoint sends close frame without status code (with frame.Length = 0),\n// application should not check its payload.\nfunc CheckCloseFrameData(code StatusCode, reason string) error {\n\tswitch {\n\tcase code.IsNotUsed():\n\t\treturn ErrProtocolStatusCodeNotInUse\n\n\tcase code.IsProtocolReserved():\n\t\treturn ErrProtocolStatusCodeApplicationLevel\n\n\tcase code == StatusNoMeaningYet:\n\t\treturn ErrProtocolStatusCodeNoMeaning\n\n\tcase code.IsProtocolSpec() && !code.IsProtocolDefined():\n\t\treturn ErrProtocolStatusCodeUnknown\n\n\tcase !utf8.ValidString(reason):\n\t\treturn ErrProtocolInvalidUTF8\n\n\tdefault:\n\t\treturn nil\n\t}\n}\n"
        },
        {
          "name": "cipher.go",
          "type": "blob",
          "size": 1.865234375,
          "content": "package ws\n\nimport (\n\t\"encoding/binary\"\n)\n\n// Cipher applies XOR cipher to the payload using mask.\n// Offset is used to cipher chunked data (e.g. in io.Reader implementations).\n//\n// To convert masked data into unmasked data, or vice versa, the following\n// algorithm is applied.  The same algorithm applies regardless of the\n// direction of the translation, e.g., the same steps are applied to\n// mask the data as to unmask the data.\nfunc Cipher(payload []byte, mask [4]byte, offset int) {\n\tn := len(payload)\n\tif n < 8 {\n\t\tfor i := 0; i < n; i++ {\n\t\t\tpayload[i] ^= mask[(offset+i)%4]\n\t\t}\n\t\treturn\n\t}\n\n\t// Calculate position in mask due to previously processed bytes number.\n\tmpos := offset % 4\n\t// Count number of bytes will processed one by one from the beginning of payload.\n\tln := remain[mpos]\n\t// Count number of bytes will processed one by one from the end of payload.\n\t// This is done to process payload by 16 bytes in each iteration of main loop.\n\trn := (n - ln) % 16\n\n\tfor i := 0; i < ln; i++ {\n\t\tpayload[i] ^= mask[(mpos+i)%4]\n\t}\n\tfor i := n - rn; i < n; i++ {\n\t\tpayload[i] ^= mask[(mpos+i)%4]\n\t}\n\n\t// NOTE: we use here binary.LittleEndian regardless of what is real\n\t// endianness on machine is. To do so, we have to use binary.LittleEndian in\n\t// the masking loop below as well.\n\tvar (\n\t\tm  = binary.LittleEndian.Uint32(mask[:])\n\t\tm2 = uint64(m)<<32 | uint64(m)\n\t)\n\t// Skip already processed right part.\n\t// Get number of uint64 parts remaining to process.\n\tn = (n - ln - rn) >> 4\n\tj := ln\n\tfor i := 0; i < n; i++ {\n\t\tchunk := payload[j : j+16]\n\t\tp := binary.LittleEndian.Uint64(chunk) ^ m2\n\t\tp2 := binary.LittleEndian.Uint64(chunk[8:]) ^ m2\n\t\tbinary.LittleEndian.PutUint64(chunk, p)\n\t\tbinary.LittleEndian.PutUint64(chunk[8:], p2)\n\t\tj += 16\n\t}\n}\n\n// remain maps position in masking key [0,4) to number\n// of bytes that need to be processed manually inside Cipher().\nvar remain = [4]int{0, 3, 2, 1}\n"
        },
        {
          "name": "cipher_test.go",
          "type": "blob",
          "size": 3.611328125,
          "content": "package ws\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestCipher(t *testing.T) {\n\ttype test struct {\n\t\tname   string\n\t\tin     []byte\n\t\tmask   [4]byte\n\t\toffset int\n\t}\n\tcases := []test{\n\t\t{\n\t\t\tname: \"simple\",\n\t\t\tin:   []byte(\"Hello, XOR!\"),\n\t\t\tmask: [4]byte{1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\tname: \"simple\",\n\t\t\tin:   []byte(\"Hello, XOR!\"),\n\t\t\tmask: [4]byte{255, 255, 255, 255},\n\t\t},\n\t}\n\tfor offset := 0; offset < 4; offset++ {\n\t\tfor tail := 0; tail < 8; tail++ {\n\t\t\tfor b64 := 0; b64 < 3; b64++ {\n\t\t\t\tvar (\n\t\t\t\t\tln = remain[offset]\n\t\t\t\t\trn = tail\n\t\t\t\t\tn  = b64*8 + ln + rn\n\t\t\t\t)\n\n\t\t\t\tp := make([]byte, n)\n\t\t\t\trand.Read(p)\n\n\t\t\t\tvar m [4]byte\n\t\t\t\trand.Read(m[:])\n\n\t\t\t\tcases = append(cases, test{\n\t\t\t\t\tin:     p,\n\t\t\t\t\tmask:   m,\n\t\t\t\t\toffset: offset,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\tfor _, test := range cases {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t// naive implementation of xor-cipher\n\t\t\texp := cipherNaive(test.in, test.mask, test.offset)\n\n\t\t\tres := make([]byte, len(test.in))\n\t\t\tcopy(res, test.in)\n\t\t\tCipher(res, test.mask, test.offset)\n\n\t\t\tif !reflect.DeepEqual(res, exp) {\n\t\t\t\tt.Errorf(\"Cipher(%v, %v):\\nact:\\t%v\\nexp:\\t%v\\n\", test.in, test.mask, res, exp)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCipherChops(t *testing.T) {\n\tfor n := 2; n <= 1024; n <<= 1 {\n\t\tt.Run(fmt.Sprintf(\"%d\", n), func(t *testing.T) {\n\t\t\tp := make([]byte, n)\n\t\t\tb := make([]byte, n)\n\t\t\tvar m [4]byte\n\n\t\t\t_, err := rand.Read(p)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\t_, err = rand.Read(m[:])\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\texp := cipherNaive(p, m, 0)\n\n\t\t\tfor i := 1; i <= n; i <<= 1 {\n\t\t\t\tcopy(b, p)\n\t\t\t\ts := n / i\n\n\t\t\t\tfor j := s; j <= n; j += s {\n\t\t\t\t\tl, r := j-s, j\n\t\t\t\t\tCipher(b[l:r], m, l)\n\t\t\t\t\tif !reflect.DeepEqual(b[l:r], exp[l:r]) {\n\t\t\t\t\t\tt.Fatalf(\"unexpected Cipher([%d:%d]) = %x; want %x\", l, r, b[l:r], exp[l:r])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tl := 0\n\t\t\tcopy(b, p)\n\t\t\tfor l < n {\n\t\t\t\tr := rand.Intn(n-l) + l + 1\n\t\t\t\tCipher(b[l:r], m, l)\n\t\t\t\tif !reflect.DeepEqual(b[l:r], exp[l:r]) {\n\t\t\t\t\tt.Fatalf(\"unexpected Cipher([%d:%d]):\\nact:\\t%v\\nexp:\\t%v\\nact:\\t%#x\\nexp:\\t%#x\\n\\n\", l, r, b[l:r], exp[l:r], b[l:r], exp[l:r])\n\t\t\t\t}\n\t\t\t\tl = r\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc cipherNaive(p []byte, m [4]byte, pos int) []byte {\n\tr := make([]byte, len(p))\n\tcopy(r, p)\n\tcipherNaiveNoCp(r, m, pos)\n\treturn r\n}\n\nfunc cipherNaiveNoCp(p []byte, m [4]byte, pos int) []byte {\n\tfor i := 0; i < len(p); i++ {\n\t\tp[i] ^= m[(pos+i)%4]\n\t}\n\treturn p\n}\n\nfunc BenchmarkCipher(b *testing.B) {\n\tfor _, bench := range []struct {\n\t\tsize   int\n\t\toffset int\n\t}{\n\t\t{\n\t\t\tsize:   7,\n\t\t\toffset: 1,\n\t\t},\n\t\t{\n\t\t\tsize: 125,\n\t\t},\n\t\t{\n\t\t\tsize: 1024,\n\t\t},\n\t\t{\n\t\t\tsize: 4096,\n\t\t},\n\t\t{\n\t\t\tsize:   4100,\n\t\t\toffset: 4,\n\t\t},\n\t\t{\n\t\t\tsize:   4099,\n\t\t\toffset: 3,\n\t\t},\n\t\t{\n\t\t\tsize:   (1 << 15) + 7,\n\t\t\toffset: 49,\n\t\t},\n\t} {\n\t\tbts := make([]byte, bench.size)\n\t\t_, err := rand.Read(bts)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\n\t\tvar mask [4]byte\n\t\t_, err = rand.Read(mask[:])\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\n\t\tb.Run(fmt.Sprintf(\"naive_bytes=%d;offset=%d\", bench.size, bench.offset), func(b *testing.B) {\n\t\t\tvar sink int64\n\t\t\tb.SetBytes(int64(bench.size))\n\t\t\tb.ResetTimer()\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tr := cipherNaiveNoCp(bts, mask, bench.offset)\n\t\t\t\tsink += int64(len(r))\n\t\t\t}\n\t\t\tsinkValue(sink)\n\t\t})\n\t\tb.Run(fmt.Sprintf(\"bytes=%d;offset=%d\", bench.size, bench.offset), func(b *testing.B) {\n\t\t\tvar sink int64\n\t\t\tb.SetBytes(int64(bench.size))\n\t\t\tb.ResetTimer()\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tCipher(bts, mask, bench.offset)\n\t\t\t\tsink += int64(len(bts))\n\t\t\t}\n\t\t\tsinkValue(sink)\n\t\t})\n\t}\n}\n\n// sinkValue makes variable used and prevents dead code elimination.\nfunc sinkValue(v int64) {\n\tif r := rand.Float32(); r > 2 {\n\t\tpanic(fmt.Sprintf(\"impossible %g: %v\", r, v))\n\t}\n}\n"
        },
        {
          "name": "dialer.go",
          "type": "blob",
          "size": 17.8271484375,
          "content": "package ws\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gobwas/httphead\"\n\t\"github.com/gobwas/pool/pbufio\"\n)\n\n// Constants used by Dialer.\nconst (\n\tDefaultClientReadBufferSize  = 4096\n\tDefaultClientWriteBufferSize = 4096\n)\n\n// Handshake represents handshake result.\ntype Handshake struct {\n\t// Protocol is the subprotocol selected during handshake.\n\tProtocol string\n\n\t// Extensions is the list of negotiated extensions.\n\tExtensions []httphead.Option\n}\n\n// Errors used by the websocket client.\nvar (\n\tErrHandshakeBadStatus      = fmt.Errorf(\"unexpected http status\")\n\tErrHandshakeBadSubProtocol = fmt.Errorf(\"unexpected protocol in %q header\", headerSecProtocol)\n\tErrHandshakeBadExtensions  = fmt.Errorf(\"unexpected extensions in %q header\", headerSecProtocol)\n)\n\n// DefaultDialer is dialer that holds no options and is used by Dial function.\nvar DefaultDialer Dialer\n\n// Dial is like Dialer{}.Dial().\nfunc Dial(ctx context.Context, urlstr string) (net.Conn, *bufio.Reader, Handshake, error) {\n\treturn DefaultDialer.Dial(ctx, urlstr)\n}\n\n// Dialer contains options for establishing websocket connection to an url.\ntype Dialer struct {\n\t// ReadBufferSize and WriteBufferSize is an I/O buffer sizes.\n\t// They used to read and write http data while upgrading to WebSocket.\n\t// Allocated buffers are pooled with sync.Pool to avoid extra allocations.\n\t//\n\t// If a size is zero then default value is used.\n\tReadBufferSize, WriteBufferSize int\n\n\t// Timeout is the maximum amount of time a Dial() will wait for a connect\n\t// and an handshake to complete.\n\t//\n\t// The default is no timeout.\n\tTimeout time.Duration\n\n\t// Protocols is the list of subprotocols that the client wants to speak,\n\t// ordered by preference.\n\t//\n\t// See https://tools.ietf.org/html/rfc6455#section-4.1\n\tProtocols []string\n\n\t// Extensions is the list of extensions that client wants to speak.\n\t//\n\t// Note that if server decides to use some of this extensions, Dial() will\n\t// return Handshake struct containing a slice of items, which are the\n\t// shallow copies of the items from this list. That is, internals of\n\t// Extensions items are shared during Dial().\n\t//\n\t// See https://tools.ietf.org/html/rfc6455#section-4.1\n\t// See https://tools.ietf.org/html/rfc6455#section-9.1\n\tExtensions []httphead.Option\n\n\t// Header is an optional HandshakeHeader instance that could be used to\n\t// write additional headers to the handshake request.\n\t//\n\t// It used instead of any key-value mappings to avoid allocations in user\n\t// land.\n\tHeader HandshakeHeader\n\n\t// Host is an optional string that could be used to specify the host during\n\t// HTTP upgrade request by setting 'Host' header.\n\t//\n\t// Default value is an empty string, which results in setting 'Host' header\n\t// equal to the URL hostname given to Dialer.Dial().\n\tHost string\n\n\t// OnStatusError is the callback that will be called after receiving non\n\t// \"101 Continue\" HTTP response status. It receives an io.Reader object\n\t// representing server response bytes. That is, it gives ability to parse\n\t// HTTP response somehow (probably with http.ReadResponse call) and make a\n\t// decision of further logic.\n\t//\n\t// The arguments are only valid until the callback returns.\n\tOnStatusError func(status int, reason []byte, resp io.Reader)\n\n\t// OnHeader is the callback that will be called after successful parsing of\n\t// header, that is not used during WebSocket handshake procedure. That is,\n\t// it will be called with non-websocket headers, which could be relevant\n\t// for application-level logic.\n\t//\n\t// The arguments are only valid until the callback returns.\n\t//\n\t// Returned value could be used to prevent processing response.\n\tOnHeader func(key, value []byte) (err error)\n\n\t// NetDial is the function that is used to get plain tcp connection.\n\t// If it is not nil, then it is used instead of net.Dialer.\n\tNetDial func(ctx context.Context, network, addr string) (net.Conn, error)\n\n\t// TLSClient is the callback that will be called after successful dial with\n\t// received connection and its remote host name. If it is nil, then the\n\t// default tls.Client() will be used.\n\t// If it is not nil, then TLSConfig field is ignored.\n\tTLSClient func(conn net.Conn, hostname string) net.Conn\n\n\t// TLSConfig is passed to tls.Client() to start TLS over established\n\t// connection. If TLSClient is not nil, then it is ignored. If TLSConfig is\n\t// non-nil and its ServerName is empty, then for every Dial() it will be\n\t// cloned and appropriate ServerName will be set.\n\tTLSConfig *tls.Config\n\n\t// WrapConn is the optional callback that will be called when connection is\n\t// ready for an i/o. That is, it will be called after successful dial and\n\t// TLS initialization (for \"wss\" schemes). It may be helpful for different\n\t// user land purposes such as end to end encryption.\n\t//\n\t// Note that for debugging purposes of an http handshake (e.g. sent request\n\t// and received response), there is an wsutil.DebugDialer struct.\n\tWrapConn func(conn net.Conn) net.Conn\n}\n\n// Dial connects to the url host and upgrades connection to WebSocket.\n//\n// If server has sent frames right after successful handshake then returned\n// buffer will be non-nil. In other cases buffer is always nil. For better\n// memory efficiency received non-nil bufio.Reader should be returned to the\n// inner pool with PutReader() function after use.\n//\n// Note that Dialer does not implement IDNA (RFC5895) logic as net/http does.\n// If you want to dial non-ascii host name, take care of its name serialization\n// avoiding bad request issues. For more info see net/http Request.Write()\n// implementation, especially cleanHost() function.\nfunc (d Dialer) Dial(ctx context.Context, urlstr string) (conn net.Conn, br *bufio.Reader, hs Handshake, err error) {\n\tu, err := url.ParseRequestURI(urlstr)\n\tif err != nil {\n\t\treturn nil, nil, hs, err\n\t}\n\n\t// Prepare context to dial with. Initially it is the same as original, but\n\t// if d.Timeout is non-zero and points to time that is before ctx.Deadline,\n\t// we use more shorter context for dial.\n\tdialctx := ctx\n\n\tvar deadline time.Time\n\tif t := d.Timeout; t != 0 {\n\t\tdeadline = time.Now().Add(t)\n\t\tif d, ok := ctx.Deadline(); !ok || deadline.Before(d) {\n\t\t\tvar cancel context.CancelFunc\n\t\t\tdialctx, cancel = context.WithDeadline(ctx, deadline)\n\t\t\tdefer cancel()\n\t\t}\n\t}\n\tif conn, err = d.dial(dialctx, u); err != nil {\n\t\treturn conn, nil, hs, err\n\t}\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tconn.Close()\n\t\t}\n\t}()\n\tif ctx == context.Background() {\n\t\t// No need to start I/O interrupter goroutine which is not zero-cost.\n\t\tconn.SetDeadline(deadline)\n\t\tdefer conn.SetDeadline(noDeadline)\n\t} else {\n\t\t// Context could be canceled or its deadline could be exceeded.\n\t\t// Start the interrupter goroutine to handle context cancelation.\n\t\tdone := setupContextDeadliner(ctx, conn)\n\t\tdefer func() {\n\t\t\t// Map Upgrade() error to a possible context expiration error. That\n\t\t\t// is, even if Upgrade() err is nil, context could be already\n\t\t\t// expired and connection be \"poisoned\" by SetDeadline() call.\n\t\t\t// In that case we must not return ctx.Err() error.\n\t\t\tdone(&err)\n\t\t}()\n\t}\n\n\tbr, hs, err = d.Upgrade(conn, u)\n\n\treturn conn, br, hs, err\n}\n\nvar (\n\t// netEmptyDialer is a net.Dialer without options, used in Dialer.dial() if\n\t// Dialer.NetDial is not provided.\n\tnetEmptyDialer net.Dialer\n\t// tlsEmptyConfig is an empty tls.Config used as default one.\n\ttlsEmptyConfig tls.Config\n)\n\nfunc tlsDefaultConfig() *tls.Config {\n\treturn &tlsEmptyConfig\n}\n\nfunc hostport(host, defaultPort string) (hostname, addr string) {\n\tvar (\n\t\tcolon   = strings.LastIndexByte(host, ':')\n\t\tbracket = strings.IndexByte(host, ']')\n\t)\n\tif colon > bracket {\n\t\treturn host[:colon], host\n\t}\n\treturn host, host + defaultPort\n}\n\nfunc (d Dialer) dial(ctx context.Context, u *url.URL) (conn net.Conn, err error) {\n\tdial := d.NetDial\n\tif dial == nil {\n\t\tdial = netEmptyDialer.DialContext\n\t}\n\tswitch u.Scheme {\n\tcase \"ws\":\n\t\t_, addr := hostport(u.Host, \":80\")\n\t\tconn, err = dial(ctx, \"tcp\", addr)\n\tcase \"wss\":\n\t\thostname, addr := hostport(u.Host, \":443\")\n\t\tconn, err = dial(ctx, \"tcp\", addr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttlsClient := d.TLSClient\n\t\tif tlsClient == nil {\n\t\t\ttlsClient = d.tlsClient\n\t\t}\n\t\tconn = tlsClient(conn, hostname)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unexpected websocket scheme: %q\", u.Scheme)\n\t}\n\tif wrap := d.WrapConn; wrap != nil {\n\t\tconn = wrap(conn)\n\t}\n\treturn conn, err\n}\n\nfunc (d Dialer) tlsClient(conn net.Conn, hostname string) net.Conn {\n\tconfig := d.TLSConfig\n\tif config == nil {\n\t\tconfig = tlsDefaultConfig()\n\t}\n\tif config.ServerName == \"\" {\n\t\tconfig = tlsCloneConfig(config)\n\t\tconfig.ServerName = hostname\n\t}\n\t// Do not make conn.Handshake() here because downstairs we will prepare\n\t// i/o on this conn with proper context's timeout handling.\n\treturn tls.Client(conn, config)\n}\n\nvar (\n\t// This variables are set like in net/net.go.\n\t// noDeadline is just zero value for readability.\n\tnoDeadline = time.Time{}\n\t// aLongTimeAgo is a non-zero time, far in the past, used for immediate\n\t// cancelation of dials.\n\taLongTimeAgo = time.Unix(42, 0)\n)\n\n// Upgrade writes an upgrade request to the given io.ReadWriter conn at given\n// url u and reads a response from it.\n//\n// It is a caller responsibility to manage I/O deadlines on conn.\n//\n// It returns handshake info and some bytes which could be written by the peer\n// right after response and be caught by us during buffered read.\nfunc (d Dialer) Upgrade(conn io.ReadWriter, u *url.URL) (br *bufio.Reader, hs Handshake, err error) {\n\t// headerSeen constants helps to report whether or not some header was seen\n\t// during reading request bytes.\n\tconst (\n\t\theaderSeenUpgrade = 1 << iota\n\t\theaderSeenConnection\n\t\theaderSeenSecAccept\n\n\t\t// headerSeenAll is the value that we expect to receive at the end of\n\t\t// headers read/parse loop.\n\t\theaderSeenAll = 0 |\n\t\t\theaderSeenUpgrade |\n\t\t\theaderSeenConnection |\n\t\t\theaderSeenSecAccept\n\t)\n\n\tbr = pbufio.GetReader(conn,\n\t\tnonZero(d.ReadBufferSize, DefaultClientReadBufferSize),\n\t)\n\tbw := pbufio.GetWriter(conn,\n\t\tnonZero(d.WriteBufferSize, DefaultClientWriteBufferSize),\n\t)\n\tdefer func() {\n\t\tpbufio.PutWriter(bw)\n\t\tif br.Buffered() == 0 || err != nil {\n\t\t\t// Server does not wrote additional bytes to the connection or\n\t\t\t// error occurred. That is, no reason to return buffer.\n\t\t\tpbufio.PutReader(br)\n\t\t\tbr = nil\n\t\t}\n\t}()\n\n\tnonce := make([]byte, nonceSize)\n\tinitNonce(nonce)\n\n\thttpWriteUpgradeRequest(bw, u, nonce, d.Protocols, d.Extensions, d.Header, d.Host)\n\tif err := bw.Flush(); err != nil {\n\t\treturn br, hs, err\n\t}\n\n\t// Read HTTP status line like \"HTTP/1.1 101 Switching Protocols\".\n\tsl, err := readLine(br)\n\tif err != nil {\n\t\treturn br, hs, err\n\t}\n\t// Begin validation of the response.\n\t// See https://tools.ietf.org/html/rfc6455#section-4.2.2\n\t// Parse request line data like HTTP version, uri and method.\n\tresp, err := httpParseResponseLine(sl)\n\tif err != nil {\n\t\treturn br, hs, err\n\t}\n\t// Even if RFC says \"1.1 or higher\" without mentioning the part of the\n\t// version, we apply it only to minor part.\n\tif resp.major != 1 || resp.minor < 1 {\n\t\terr = ErrHandshakeBadProtocol\n\t\treturn br, hs, err\n\t}\n\tif resp.status != http.StatusSwitchingProtocols {\n\t\terr = StatusError(resp.status)\n\t\tif onStatusError := d.OnStatusError; onStatusError != nil {\n\t\t\t// Invoke callback with multireader of status-line bytes br.\n\t\t\tonStatusError(resp.status, resp.reason,\n\t\t\t\tio.MultiReader(\n\t\t\t\t\tbytes.NewReader(sl),\n\t\t\t\t\tstrings.NewReader(crlf),\n\t\t\t\t\tbr,\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\t\treturn br, hs, err\n\t}\n\t// If response status is 101 then we expect all technical headers to be\n\t// valid. If not, then we stop processing response without giving user\n\t// ability to read non-technical headers. That is, we do not distinguish\n\t// technical errors (such as parsing error) and protocol errors.\n\tvar headerSeen byte\n\tfor {\n\t\tline, e := readLine(br)\n\t\tif e != nil {\n\t\t\terr = e\n\t\t\treturn br, hs, err\n\t\t}\n\t\tif len(line) == 0 {\n\t\t\t// Blank line, no more lines to read.\n\t\t\tbreak\n\t\t}\n\n\t\tk, v, ok := httpParseHeaderLine(line)\n\t\tif !ok {\n\t\t\terr = ErrMalformedResponse\n\t\t\treturn br, hs, err\n\t\t}\n\n\t\tswitch btsToString(k) {\n\t\tcase headerUpgradeCanonical:\n\t\t\theaderSeen |= headerSeenUpgrade\n\t\t\tif !bytes.Equal(v, specHeaderValueUpgrade) && !bytes.EqualFold(v, specHeaderValueUpgrade) {\n\t\t\t\terr = ErrHandshakeBadUpgrade\n\t\t\t\treturn br, hs, err\n\t\t\t}\n\n\t\tcase headerConnectionCanonical:\n\t\t\theaderSeen |= headerSeenConnection\n\t\t\t// Note that as RFC6455 says:\n\t\t\t//   > A |Connection| header field with value \"Upgrade\".\n\t\t\t// That is, in server side, \"Connection\" header could contain\n\t\t\t// multiple token. But in response it must contains exactly one.\n\t\t\tif !bytes.Equal(v, specHeaderValueConnection) && !bytes.EqualFold(v, specHeaderValueConnection) {\n\t\t\t\terr = ErrHandshakeBadConnection\n\t\t\t\treturn br, hs, err\n\t\t\t}\n\n\t\tcase headerSecAcceptCanonical:\n\t\t\theaderSeen |= headerSeenSecAccept\n\t\t\tif !checkAcceptFromNonce(v, nonce) {\n\t\t\t\terr = ErrHandshakeBadSecAccept\n\t\t\t\treturn br, hs, err\n\t\t\t}\n\n\t\tcase headerSecProtocolCanonical:\n\t\t\t// RFC6455 1.3:\n\t\t\t//   \"The server selects one or none of the acceptable protocols\n\t\t\t//   and echoes that value in its handshake to indicate that it has\n\t\t\t//   selected that protocol.\"\n\t\t\tfor _, want := range d.Protocols {\n\t\t\t\tif string(v) == want {\n\t\t\t\t\ths.Protocol = want\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif hs.Protocol == \"\" {\n\t\t\t\t// Server echoed subprotocol that is not present in client\n\t\t\t\t// requested protocols.\n\t\t\t\terr = ErrHandshakeBadSubProtocol\n\t\t\t\treturn br, hs, err\n\t\t\t}\n\n\t\tcase headerSecExtensionsCanonical:\n\t\t\ths.Extensions, err = matchSelectedExtensions(v, d.Extensions, hs.Extensions)\n\t\t\tif err != nil {\n\t\t\t\treturn br, hs, err\n\t\t\t}\n\n\t\tdefault:\n\t\t\tif onHeader := d.OnHeader; onHeader != nil {\n\t\t\t\tif e := onHeader(k, v); e != nil {\n\t\t\t\t\terr = e\n\t\t\t\t\treturn br, hs, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif err == nil && headerSeen != headerSeenAll {\n\t\tswitch {\n\t\tcase headerSeen&headerSeenUpgrade == 0:\n\t\t\terr = ErrHandshakeBadUpgrade\n\t\tcase headerSeen&headerSeenConnection == 0:\n\t\t\terr = ErrHandshakeBadConnection\n\t\tcase headerSeen&headerSeenSecAccept == 0:\n\t\t\terr = ErrHandshakeBadSecAccept\n\t\tdefault:\n\t\t\tpanic(\"unknown headers state\")\n\t\t}\n\t}\n\treturn br, hs, err\n}\n\n// PutReader returns bufio.Reader instance to the inner reuse pool.\n// It is useful in rare cases, when Dialer.Dial() returns non-nil buffer which\n// contains unprocessed buffered data, that was sent by the server quickly\n// right after handshake.\nfunc PutReader(br *bufio.Reader) {\n\tpbufio.PutReader(br)\n}\n\n// StatusError contains an unexpected status-line code from the server.\ntype StatusError int\n\nfunc (s StatusError) Error() string {\n\treturn \"unexpected HTTP response status: \" + strconv.Itoa(int(s))\n}\n\nfunc isTimeoutError(err error) bool {\n\tt, ok := err.(net.Error)\n\treturn ok && t.Timeout()\n}\n\nfunc matchSelectedExtensions(selected []byte, wanted, received []httphead.Option) ([]httphead.Option, error) {\n\tif len(selected) == 0 {\n\t\treturn received, nil\n\t}\n\tvar (\n\t\tindex  int\n\t\toption httphead.Option\n\t\terr    error\n\t)\n\tindex = -1\n\tmatch := func() (ok bool) {\n\t\tfor _, want := range wanted {\n\t\t\t// A server accepts one or more extensions by including a\n\t\t\t// |Sec-WebSocket-Extensions| header field containing one or more\n\t\t\t// extensions that were requested by the client.\n\t\t\t//\n\t\t\t// The interpretation of any extension parameters, and what\n\t\t\t// constitutes a valid response by a server to a requested set of\n\t\t\t// parameters by a client, will be defined by each such extension.\n\t\t\tif bytes.Equal(option.Name, want.Name) {\n\t\t\t\t// Check parsed extension to be present in client\n\t\t\t\t// requested extensions. We move matched extension\n\t\t\t\t// from client list to avoid allocation of httphead.Option.Name,\n\t\t\t\t// httphead.Option.Parameters have to be copied from the header\n\t\t\t\twant.Parameters, _ = option.Parameters.Copy(make([]byte, option.Parameters.Size()))\n\t\t\t\treceived = append(received, want)\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\tok := httphead.ScanOptions(selected, func(i int, name, attr, val []byte) httphead.Control {\n\t\tif i != index {\n\t\t\t// Met next option.\n\t\t\tindex = i\n\t\t\tif i != 0 && !match() {\n\t\t\t\t// Server returned non-requested extension.\n\t\t\t\terr = ErrHandshakeBadExtensions\n\t\t\t\treturn httphead.ControlBreak\n\t\t\t}\n\t\t\toption = httphead.Option{Name: name}\n\t\t}\n\t\tif attr != nil {\n\t\t\toption.Parameters.Set(attr, val)\n\t\t}\n\t\treturn httphead.ControlContinue\n\t})\n\tif !ok {\n\t\terr = ErrMalformedResponse\n\t\treturn received, err\n\t}\n\tif !match() {\n\t\treturn received, ErrHandshakeBadExtensions\n\t}\n\treturn received, err\n}\n\n// setupContextDeadliner is a helper function that starts connection I/O\n// interrupter goroutine.\n//\n// Started goroutine calls SetDeadline() with long time ago value when context\n// become expired to make any I/O operations failed. It returns done function\n// that stops started goroutine and maps error received from conn I/O methods\n// to possible context expiration error.\n//\n// In concern with possible SetDeadline() call inside interrupter goroutine,\n// caller passes pointer to its I/O error (even if it is nil) to done(&err).\n// That is, even if I/O error is nil, context could be already expired and\n// connection \"poisoned\" by SetDeadline() call. In that case done(&err) will\n// store at *err ctx.Err() result. If err is caused not by timeout, it will\n// leaved untouched.\nfunc setupContextDeadliner(ctx context.Context, conn net.Conn) (done func(*error)) {\n\tvar (\n\t\tquit      = make(chan struct{})\n\t\tinterrupt = make(chan error, 1)\n\t)\n\tgo func() {\n\t\tselect {\n\t\tcase <-quit:\n\t\t\tinterrupt <- nil\n\t\tcase <-ctx.Done():\n\t\t\t// Cancel i/o immediately.\n\t\t\tconn.SetDeadline(aLongTimeAgo)\n\t\t\tinterrupt <- ctx.Err()\n\t\t}\n\t}()\n\treturn func(err *error) {\n\t\tclose(quit)\n\t\t// If ctx.Err() is non-nil and the original err is net.Error with\n\t\t// Timeout() == true, then it means that I/O was canceled by us by\n\t\t// SetDeadline(aLongTimeAgo) call, or by somebody else previously\n\t\t// by conn.SetDeadline(x).\n\t\t//\n\t\t// Even on race condition when both deadlines are expired\n\t\t// (SetDeadline() made not by us and context's), we prefer ctx.Err() to\n\t\t// be returned.\n\t\tif ctxErr := <-interrupt; ctxErr != nil && (*err == nil || isTimeoutError(*err)) {\n\t\t\t*err = ctxErr\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "dialer_test.go",
          "type": "blob",
          "size": 19.140625,
          "content": "package ws\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"math/rand\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/gobwas/httphead\"\n)\n\nfunc TestDialerRequest(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tdialer Dialer\n\t\turl    string\n\t\texp    *http.Request\n\t\terr    bool\n\t}{\n\t\t{\n\t\t\turl: \"wss://example.org/chat\",\n\t\t\texp: setProto(1, 1,\n\t\t\t\tmustMakeRequest(\"GET\", \"wss://example.org/chat\", http.Header{\n\t\t\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\t\t\theaderSecVersion: []string{\"13\"},\n\t\t\t\t\theaderSecKey:     []string{\"some key\"},\n\t\t\t\t}),\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\tdialer: Dialer{\n\t\t\t\tProtocols: []string{\"foo\", \"bar\"},\n\t\t\t\tExtensions: []httphead.Option{\n\t\t\t\t\thttphead.NewOption(\"foo\", map[string]string{\n\t\t\t\t\t\t\"bar\": \"1\",\n\t\t\t\t\t}),\n\t\t\t\t\thttphead.NewOption(\"baz\", nil),\n\t\t\t\t},\n\t\t\t\tHeader: HandshakeHeaderHTTP(http.Header{\n\t\t\t\t\t\"Origin\": []string{\"who knows\"},\n\t\t\t\t}),\n\t\t\t},\n\t\t\turl: \"wss://example.org/chat\",\n\t\t\texp: setProto(1, 1,\n\t\t\t\tmustMakeRequest(\"GET\", \"wss://example.org/chat\", http.Header{\n\t\t\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\t\t\theaderSecVersion: []string{\"13\"},\n\t\t\t\t\theaderSecKey:     []string{\"some key\"},\n\n\t\t\t\t\theaderSecProtocol:   []string{\"foo, bar\"},\n\t\t\t\t\theaderSecExtensions: []string{\"foo;bar=1,baz\"},\n\n\t\t\t\t\t\"Origin\": []string{\"who knows\"},\n\t\t\t\t}),\n\t\t\t),\n\t\t},\n\t} {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tu, err := url.ParseRequestURI(test.url)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tvar buf bytes.Buffer\n\t\t\tconn := struct {\n\t\t\t\tio.Reader\n\t\t\t\tio.Writer\n\t\t\t}{io.LimitReader(&buf, 0), &buf}\n\n\t\t\t_, _, err = test.dialer.Upgrade(&conn, u)\n\t\t\tif err == io.EOF {\n\t\t\t\terr = nil\n\t\t\t}\n\t\t\tif test.err && err == nil {\n\t\t\t\tt.Errorf(\"expected error; got nil\")\n\t\t\t}\n\t\t\tif !test.err && err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t\t}\n\t\t\tif test.err {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tact := buf.Bytes()\n\t\t\texp := dumpRequest(test.exp)\n\n\t\t\tact = sortHeaders(maskHeader(act, headerSecKey, \"<masked>\"))\n\t\t\texp = sortHeaders(maskHeader(exp, headerSecKey, \"<masked>\"))\n\n\t\t\tif !bytes.Equal(act, exp) {\n\t\t\t\tt.Errorf(\"unexpected request:\\nact:\\n%s\\nexp:\\n%s\\n\", act, exp)\n\t\t\t}\n\t\t\tif _, err := http.ReadRequest(bufio.NewReader(&buf)); err != nil {\n\t\t\t\tt.Fatalf(\"read request error: %s\", err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc makeAccept(nonce []byte) []byte {\n\taccept := make([]byte, acceptSize)\n\tinitAcceptFromNonce(accept, nonce)\n\treturn accept\n}\n\nfunc BenchmarkPutAccept(b *testing.B) {\n\tnonce := make([]byte, nonceSize)\n\t_, err := rand.Read(nonce)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tp := make([]byte, acceptSize)\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tinitAcceptFromNonce(p, nonce)\n\t}\n}\n\nfunc BenchmarkCheckNonce(b *testing.B) {\n\tnonce := make([]byte, nonceSize)\n\t_, err := rand.Read(nonce)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\taccept := makeAccept(nonce)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = checkAcceptFromNonce(nonce, accept)\n\t}\n}\n\nfunc TestDialerHandshake(t *testing.T) {\n\tconst (\n\t\tacceptNo = iota\n\t\tacceptInvalid\n\t\tacceptValid\n\t)\n\tfor _, test := range []struct {\n\t\tname       string\n\t\tdialer     Dialer\n\t\tres        *http.Response\n\t\tframes     []Frame\n\t\taccept     int\n\t\terr        error\n\t\twantBuffer bool\n\t}{\n\t\t{\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\tProtoMajor: 1,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\taccept: acceptValid,\n\t\t},\n\t\t{\n\t\t\tdialer: Dialer{\n\t\t\t\tProtocols: []string{\"xml\", \"json\", \"soap\"},\n\t\t\t},\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\tProtoMajor: 1,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\theaderConnection:  []string{\"Upgrade\"},\n\t\t\t\t\theaderUpgrade:     []string{\"websocket\"},\n\t\t\t\t\theaderSecProtocol: []string{\"json\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\taccept: acceptValid,\n\t\t},\n\t\t{\n\t\t\tdialer: Dialer{\n\t\t\t\tProtocols: []string{\"xml\", \"json\", \"soap\"},\n\t\t\t},\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\tProtoMajor: 1,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\taccept: acceptValid,\n\t\t},\n\t\t{\n\t\t\tdialer: Dialer{\n\t\t\t\tExtensions: []httphead.Option{\n\t\t\t\t\thttphead.NewOption(\"foo\", map[string]string{\n\t\t\t\t\t\t\"bar\": \"1\",\n\t\t\t\t\t}),\n\t\t\t\t\thttphead.NewOption(\"baz\", nil),\n\t\t\t\t},\n\t\t\t},\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\tProtoMajor: 1,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\theaderConnection:    []string{\"Upgrade\"},\n\t\t\t\t\theaderUpgrade:       []string{\"websocket\"},\n\t\t\t\t\theaderSecExtensions: []string{\"foo;bar=1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\taccept: acceptValid,\n\t\t},\n\t\t{\n\t\t\tdialer: Dialer{\n\t\t\t\tExtensions: []httphead.Option{\n\t\t\t\t\thttphead.NewOption(\"foo\", map[string]string{\n\t\t\t\t\t\t\"bar\": \"1\",\n\t\t\t\t\t}),\n\t\t\t\t\thttphead.NewOption(\"baz\", nil),\n\t\t\t\t},\n\t\t\t},\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\tProtoMajor: 1,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\taccept: acceptValid,\n\t\t},\n\t\t{\n\t\t\tdialer: Dialer{\n\t\t\t\tProtocols: []string{\"xml\", \"json\", \"soap\"},\n\t\t\t\tExtensions: []httphead.Option{\n\t\t\t\t\thttphead.NewOption(\"foo\", map[string]string{\n\t\t\t\t\t\t\"bar\": \"1\",\n\t\t\t\t\t}),\n\t\t\t\t\thttphead.NewOption(\"baz\", nil),\n\t\t\t\t},\n\t\t\t},\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\tProtoMajor: 1,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\theaderConnection:    []string{\"Upgrade\"},\n\t\t\t\t\theaderUpgrade:       []string{\"websocket\"},\n\t\t\t\t\theaderSecProtocol:   []string{\"json\"},\n\t\t\t\t\theaderSecExtensions: []string{\"foo;bar=1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\taccept: acceptValid,\n\t\t},\n\t\t{\n\t\t\tname: \"resp with frames\",\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\tProtoMajor: 1,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\taccept: acceptValid,\n\t\t\tframes: []Frame{\n\t\t\t\tNewTextFrame([]byte(\"hello, gopherizer!\")),\n\t\t\t},\n\t\t\twantBuffer: true,\n\t\t},\n\t\t{\n\t\t\tname: \"resp with body\",\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\tProtoMajor: 1,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\t\t},\n\t\t\t\tBody:          ioutil.NopCloser(bytes.NewReader([]byte(`hello, gopher!`))),\n\t\t\t\tContentLength: 14,\n\t\t\t},\n\t\t\taccept:     acceptValid,\n\t\t\twantBuffer: true,\n\t\t},\n\n\t\t// Error cases.\n\n\t\t{\n\t\t\tname: \"bad proto\",\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\tProtoMajor: 2,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader:     make(http.Header),\n\t\t\t},\n\t\t\terr: ErrHandshakeBadProtocol,\n\t\t},\n\t\t{\n\t\t\tname: \"bad status\",\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusBadRequest,\n\t\t\t\tProtoMajor: 1,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader:     make(http.Header),\n\t\t\t},\n\t\t\terr:        StatusError(400),\n\t\t\twantBuffer: false,\n\t\t},\n\t\t{\n\t\t\tname: \"bad status with body\",\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusBadRequest,\n\t\t\t\tProtoMajor: 1,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader:     make(http.Header),\n\t\t\t\tBody: ioutil.NopCloser(bytes.NewReader(\n\t\t\t\t\t[]byte(`<error description here>`),\n\t\t\t\t)),\n\t\t\t\tContentLength: 24,\n\t\t\t},\n\t\t\terr:        StatusError(400),\n\t\t\twantBuffer: false,\n\t\t},\n\t\t{\n\t\t\tname: \"bad upgrade\",\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\tProtoMajor: 1,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\taccept: acceptValid,\n\t\t\terr:    ErrHandshakeBadUpgrade,\n\t\t},\n\t\t{\n\t\t\tname: \"bad upgrade\",\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\tProtoMajor: 1,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\t\t\theaderUpgrade:    []string{\"oops\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\taccept: acceptValid,\n\t\t\terr:    ErrHandshakeBadUpgrade,\n\t\t},\n\t\t{\n\t\t\tname: \"bad connection\",\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\tProtoMajor: 1,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\theaderUpgrade: []string{\"websocket\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\taccept: acceptValid,\n\t\t\terr:    ErrHandshakeBadConnection,\n\t\t},\n\t\t{\n\t\t\tname: \"bad connection\",\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\tProtoMajor: 1,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\theaderConnection: []string{\"oops!\"},\n\t\t\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\taccept: acceptValid,\n\t\t\terr:    ErrHandshakeBadConnection,\n\t\t},\n\t\t{\n\t\t\tname: \"bad accept\",\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\tProtoMajor: 1,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\taccept: acceptInvalid,\n\t\t\terr:    ErrHandshakeBadSecAccept,\n\t\t},\n\t\t{\n\t\t\tname: \"bad accept\",\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\tProtoMajor: 1,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\taccept: acceptNo,\n\t\t\terr:    ErrHandshakeBadSecAccept,\n\t\t},\n\t\t{\n\t\t\tname: \"bad subprotocol\",\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\tProtoMajor: 1,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\theaderConnection:  []string{\"Upgrade\"},\n\t\t\t\t\theaderUpgrade:     []string{\"websocket\"},\n\t\t\t\t\theaderSecProtocol: []string{\"oops!\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\taccept: acceptValid,\n\t\t\terr:    ErrHandshakeBadSubProtocol,\n\t\t},\n\t\t{\n\t\t\tname: \"bad extensions\",\n\t\t\tres: &http.Response{\n\t\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\t\tProtoMajor: 1,\n\t\t\t\tProtoMinor: 1,\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\theaderConnection:    []string{\"Upgrade\"},\n\t\t\t\t\theaderUpgrade:       []string{\"websocket\"},\n\t\t\t\t\theaderSecExtensions: []string{\"foo,bar;baz=1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\taccept: acceptValid,\n\t\t\terr:    ErrHandshakeBadExtensions,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tclient, server := net.Pipe()\n\t\t\tgo func() {\n\t\t\t\t// This routine is our fake web-server. It reads request after\n\t\t\t\t// client wrote it. Then it optionally could send some frames\n\t\t\t\t// set in test case.\n\t\t\t\treq, err := http.ReadRequest(bufio.NewReader(client))\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\n\t\t\t\tswitch test.accept {\n\t\t\t\tcase acceptInvalid:\n\t\t\t\t\tk := make([]byte, nonceSize)\n\t\t\t\t\trand.Read(k)\n\t\t\t\t\tnonce := string(k)\n\t\t\t\t\taccept := makeAccept(strToBytes(nonce))\n\t\t\t\t\ttest.res.Header.Set(headerSecAccept, string(accept))\n\t\t\t\tcase acceptValid:\n\t\t\t\t\tnonce := req.Header.Get(headerSecKey)\n\t\t\t\t\taccept := makeAccept(strToBytes(nonce))\n\t\t\t\t\ttest.res.Header.Set(headerSecAccept, string(accept))\n\t\t\t\t}\n\n\t\t\t\ttest.res.Request = req\n\t\t\t\tbts := dumpResponse(test.res)\n\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\tfor _, f := range test.frames {\n\t\t\t\t\tif err := WriteFrame(&buf, f); err != nil {\n\t\t\t\t\t\tpanic(err)\n\t\t\t\t\t}\n\t\t\t\t\tbts = append(bts, buf.Bytes()...)\n\t\t\t\t\tbuf.Reset()\n\t\t\t\t}\n\n\t\t\t\tclient.Write(bts)\n\t\t\t\tclient.Close()\n\t\t\t}()\n\n\t\t\tconn := &stubConn{\n\t\t\t\tread: func(p []byte) (int, error) {\n\t\t\t\t\treturn server.Read(p)\n\t\t\t\t},\n\t\t\t\twrite: func(p []byte) (int, error) {\n\t\t\t\t\tn, err := server.Write(p)\n\t\t\t\t\treturn n, err\n\t\t\t\t},\n\t\t\t\tclose: func() error { return nil },\n\t\t\t}\n\n\t\t\ttest.dialer.NetDial = func(_ context.Context, _, _ string) (net.Conn, error) {\n\t\t\t\treturn conn, nil\n\t\t\t}\n\t\t\ttest.dialer.OnStatusError = func(status int, reason []byte, r io.Reader) {\n\t\t\t\tres, err := http.ReadResponse(\n\t\t\t\t\tbufio.NewReader(r),\n\t\t\t\t\tnil,\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"read response inside OnStatusError error: %v\", err)\n\t\t\t\t}\n\t\t\t\tif act, exp := dumpResponse(res), dumpResponse(test.res); !bytes.Equal(act, exp) {\n\t\t\t\t\tt.Errorf(\n\t\t\t\t\t\t\"unexpected response from OnStatusError:\\nact:\\n%s\\nexp:\\n%s\\n\",\n\t\t\t\t\t\tact, exp,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_, br, _, err := test.dialer.Dial(context.Background(), \"ws://gobwas.com\")\n\t\t\tif test.err != err {\n\t\t\t\tt.Fatalf(\"unexpected error: %v;\\n\\twant %v\", err, test.err)\n\t\t\t}\n\n\t\t\tif (test.wantBuffer || len(test.frames) > 0) && br == nil {\n\t\t\t\tt.Fatalf(\"Dial() returned empty bufio.Reader\")\n\t\t\t}\n\t\t\tif !test.wantBuffer && br != nil {\n\t\t\t\tt.Fatalf(\"Dial() returned non-empty bufio.Reader\")\n\t\t\t}\n\t\t\tfor i, exp := range test.frames {\n\t\t\t\tact, err := ReadFrame(br)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"can not read %d-th frame: %v\", i, err)\n\t\t\t\t}\n\t\t\t\tif act.Header != exp.Header {\n\t\t\t\t\tt.Fatalf(\n\t\t\t\t\t\t\"unexpected %d-th frame header: %v; want %v\",\n\t\t\t\t\t\ti, act.Header, exp.Header,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tif !bytes.Equal(act.Payload, exp.Payload) {\n\t\t\t\t\tt.Fatalf(\n\t\t\t\t\t\t\"unexpected %d-th frame payload:\\n%v\\nwant:\\n%v\",\n\t\t\t\t\t\ti, act.Payload, exp.Payload,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Used to emulate net.Error behavior, which is usually returned when\n// connection deadline exceeds.\ntype errTimeout struct {\n\terror\n}\n\nfunc (errTimeout) Timeout() bool   { return true }\nfunc (errTimeout) Temporary() bool { return false }\n\nfunc TestDialerCancelation(t *testing.T) {\n\tioErrDeadline := errTimeout{\n\t\tfmt.Errorf(\"stub: i/o timeout\"),\n\t}\n\n\tfor _, test := range []struct {\n\t\tname           string\n\t\tdialer         Dialer\n\t\tdialDelay      time.Duration\n\t\tctxTimeout     time.Duration\n\t\tctxCancelAfter time.Duration\n\t\terr            error\n\t}{\n\t\t{\n\t\t\tctxTimeout: time.Millisecond * 100,\n\t\t\terr:        context.DeadlineExceeded,\n\t\t},\n\t\t{\n\t\t\tctxCancelAfter: time.Millisecond * 100,\n\t\t\terr:            context.Canceled,\n\t\t},\n\t\t{\n\t\t\tdialer: Dialer{\n\t\t\t\tTimeout: time.Millisecond * 100,\n\t\t\t},\n\t\t\tctxTimeout: time.Millisecond * 150,\n\t\t\terr:        context.DeadlineExceeded,\n\t\t},\n\t\t{\n\t\t\tctxTimeout: time.Millisecond * 100,\n\t\t\tdialDelay:  time.Millisecond * 200,\n\t\t\terr:        context.DeadlineExceeded,\n\t\t},\n\t\t{\n\t\t\tctxCancelAfter: time.Millisecond * 100,\n\t\t\tdialDelay:      time.Millisecond * 200,\n\t\t\terr:            context.Canceled,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar timer *time.Timer\n\t\t\tdeadline := make(chan error, 10)\n\t\t\tconn := &stubConn{\n\t\t\t\tsetDeadline: func(t time.Time) error {\n\t\t\t\t\tif timer != nil {\n\t\t\t\t\t\ttimer.Stop()\n\t\t\t\t\t}\n\t\t\t\t\tif t.IsZero() {\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t\td := time.Until(t)\n\t\t\t\t\tif d < 0 {\n\t\t\t\t\t\tdeadline <- ioErrDeadline\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttimer = time.AfterFunc(d, func() {\n\t\t\t\t\t\t\tdeadline <- ioErrDeadline\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t\tread: func(p []byte) (int, error) {\n\t\t\t\t\tif err := <-deadline; err != nil {\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t}\n\t\t\t\t\treturn len(p), nil\n\t\t\t\t},\n\t\t\t\twrite: func(p []byte) (int, error) {\n\t\t\t\t\tif err := <-deadline; err != nil {\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t}\n\t\t\t\t\treturn len(p), nil\n\t\t\t\t},\n\t\t\t}\n\n\t\t\ttest.dialer.NetDial = func(ctx context.Context, _, _ string) (net.Conn, error) {\n\t\t\t\tif t := test.dialDelay; t != 0 {\n\t\t\t\t\tdelay := time.After(t)\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-delay:\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t\treturn nil, ctx.Err()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn conn, nil\n\t\t\t}\n\n\t\t\tctx := context.Background()\n\t\t\tif t := test.ctxTimeout; t != 0 {\n\t\t\t\tvar cancel context.CancelFunc\n\t\t\t\tctx, cancel = context.WithTimeout(ctx, t)\n\t\t\t\tdefer cancel()\n\t\t\t}\n\t\t\tif t := test.ctxCancelAfter; t != 0 {\n\t\t\t\tvar cancel context.CancelFunc\n\t\t\t\tctx, cancel = context.WithCancel(ctx)\n\t\t\t\ttime.AfterFunc(t, cancel)\n\t\t\t}\n\n\t\t\t_, _, _, err := test.dialer.Dial(ctx, \"ws://gobwas.com\")\n\t\t\tif err != test.err {\n\t\t\t\tt.Fatalf(\"unexpected error: %q; want %q\", err, test.err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkDialer(b *testing.B) {\n\tfor _, test := range []struct {\n\t\tdialer Dialer\n\t}{\n\t\t{\n\t\t\tdialer: DefaultDialer,\n\t\t},\n\t} {\n\t\t// We need to \"mock\" the rand.Read method used to generate nonce random\n\t\t// bytes for Sec-WebSocket-Key header.\n\t\trand.Seed(0)\n\t\tneed := b.N * nonceKeySize\n\t\tnonceBytes := make([]byte, need)\n\t\tn, err := rand.Read(nonceBytes)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tif n != need {\n\t\t\tb.Fatalf(\"not enough random nonce bytes: %d; want %d\", n, need)\n\t\t}\n\t\trand.Seed(0)\n\n\t\tresp := &http.Response{\n\t\t\tStatusCode: http.StatusSwitchingProtocols,\n\t\t\tProtoMajor: 1,\n\t\t\tProtoMinor: 1,\n\t\t\tHeader: http.Header{\n\t\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\t\theaderSecAccept:  []string{\"fill it later\"},\n\t\t\t},\n\t\t}\n\t\trs := make([][]byte, b.N)\n\t\tfor i := range rs {\n\t\t\tnonce := make([]byte, nonceSize)\n\t\t\tbase64.StdEncoding.Encode(\n\t\t\t\tnonce,\n\t\t\t\tnonceBytes[i*nonceKeySize:i*nonceKeySize+nonceKeySize],\n\t\t\t)\n\t\t\taccept := makeAccept(nonce)\n\t\t\tresp.Header[headerSecAccept] = []string{string(accept)}\n\t\t\trs[i] = dumpResponse(resp)\n\t\t}\n\n\t\tvar i int\n\t\tconn := stubConn{\n\t\t\tread: func(p []byte) (int, error) {\n\t\t\t\tbts := rs[i]\n\t\t\t\tif len(p) < len(bts) {\n\t\t\t\t\tb.Fatalf(\"short buffer\")\n\t\t\t\t}\n\t\t\t\treturn copy(p, bts), io.EOF\n\t\t\t},\n\t\t\twrite: func(p []byte) (int, error) {\n\t\t\t\treturn len(p), nil\n\t\t\t},\n\t\t}\n\t\tvar nc net.Conn = conn\n\t\ttest.dialer.NetDial = func(_ context.Context, net, addr string) (net.Conn, error) {\n\t\t\treturn nc, nil\n\t\t}\n\n\t\tb.ResetTimer()\n\t\tfor i = 0; i < b.N; i++ {\n\t\t\t_, _, _, err := test.dialer.Dial(context.Background(), \"ws://example.org\")\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestHostPort(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname string\n\t\thost string\n\t\tport string\n\n\t\texpHostname string\n\t\texpHostport string\n\t}{\n\t\t{\n\t\t\thost:        \"foo\",\n\t\t\tport:        \":80\",\n\t\t\texpHostname: \"foo\",\n\t\t\texpHostport: \"foo:80\",\n\t\t},\n\t\t{\n\t\t\thost:        \"foo:1234\",\n\t\t\tport:        \":80\",\n\t\t\texpHostname: \"foo\",\n\t\t\texpHostport: \"foo:1234\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ipv4\",\n\t\t\thost:        \"127.0.0.1\",\n\t\t\tport:        \":80\",\n\t\t\texpHostname: \"127.0.0.1\",\n\t\t\texpHostport: \"127.0.0.1:80\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ipv4\",\n\t\t\thost:        \"127.0.0.1:1234\",\n\t\t\tport:        \":80\",\n\t\t\texpHostname: \"127.0.0.1\",\n\t\t\texpHostport: \"127.0.0.1:1234\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ipv6\",\n\t\t\thost:        \"[0:0:0:0:0:0:0:1]\",\n\t\t\tport:        \":80\",\n\t\t\texpHostname: \"[0:0:0:0:0:0:0:1]\",\n\t\t\texpHostport: \"[0:0:0:0:0:0:0:1]:80\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ipv6\",\n\t\t\thost:        \"[0:0:0:0:0:0:0:1]:1234\",\n\t\t\tport:        \":80\",\n\t\t\texpHostname: \"[0:0:0:0:0:0:0:1]\",\n\t\t\texpHostport: \"[0:0:0:0:0:0:0:1]:1234\",\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tactHostname, actHostport := hostport(test.host, test.port)\n\t\t\tif actHostname != test.expHostname {\n\t\t\t\tt.Errorf(\n\t\t\t\t\t\"actual hostname = %q; want %q\",\n\t\t\t\t\tactHostname, test.expHostname,\n\t\t\t\t)\n\t\t\t}\n\t\t\tif actHostport != test.expHostport {\n\t\t\t\tt.Errorf(\n\t\t\t\t\t\"actual hostname = %q; want %q\",\n\t\t\t\t\tactHostport, test.expHostport,\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype stubConn struct {\n\tread             func([]byte) (int, error)\n\twrite            func([]byte) (int, error)\n\tclose            func() error\n\tsetDeadline      func(time.Time) error\n\tsetWriteDeadline func(time.Time) error\n\tsetReadDeadline  func(time.Time) error\n}\n\nfunc (s stubConn) Read(p []byte) (int, error)  { return s.read(p) }\nfunc (s stubConn) Write(p []byte) (int, error) { return s.write(p) }\nfunc (s stubConn) LocalAddr() net.Addr         { return nil }\nfunc (s stubConn) RemoteAddr() net.Addr        { return nil }\nfunc (s stubConn) Close() error {\n\tif s.close != nil {\n\t\treturn s.close()\n\t}\n\treturn nil\n}\n\nfunc (s stubConn) SetDeadline(t time.Time) error {\n\tif s.setDeadline != nil {\n\t\treturn s.setDeadline(t)\n\t}\n\treturn nil\n}\n\nfunc (s stubConn) SetReadDeadline(t time.Time) error {\n\tif s.setReadDeadline != nil {\n\t\treturn s.setReadDeadline(t)\n\t}\n\treturn nil\n}\n\nfunc (s stubConn) SetWriteDeadline(t time.Time) error {\n\tif s.setWriteDeadline != nil {\n\t\treturn s.setWriteDeadline(t)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "dialer_tls_go17.go",
          "type": "blob",
          "size": 1.3740234375,
          "content": "// +build !go1.8\n\npackage ws\n\nimport \"crypto/tls\"\n\nfunc tlsCloneConfig(c *tls.Config) *tls.Config {\n\t// NOTE: we copying SessionTicketsDisabled and SessionTicketKey here\n\t// without calling inner c.initOnceServer somehow because we only could get\n\t// here from the ws.Dialer code, which is obviously a client and makes\n\t// tls.Client() when it gets new net.Conn.\n\treturn &tls.Config{\n\t\tRand:                        c.Rand,\n\t\tTime:                        c.Time,\n\t\tCertificates:                c.Certificates,\n\t\tNameToCertificate:           c.NameToCertificate,\n\t\tGetCertificate:              c.GetCertificate,\n\t\tRootCAs:                     c.RootCAs,\n\t\tNextProtos:                  c.NextProtos,\n\t\tServerName:                  c.ServerName,\n\t\tClientAuth:                  c.ClientAuth,\n\t\tClientCAs:                   c.ClientCAs,\n\t\tInsecureSkipVerify:          c.InsecureSkipVerify,\n\t\tCipherSuites:                c.CipherSuites,\n\t\tPreferServerCipherSuites:    c.PreferServerCipherSuites,\n\t\tSessionTicketsDisabled:      c.SessionTicketsDisabled,\n\t\tSessionTicketKey:            c.SessionTicketKey,\n\t\tClientSessionCache:          c.ClientSessionCache,\n\t\tMinVersion:                  c.MinVersion,\n\t\tMaxVersion:                  c.MaxVersion,\n\t\tCurvePreferences:            c.CurvePreferences,\n\t\tDynamicRecordSizingDisabled: c.DynamicRecordSizingDisabled,\n\t\tRenegotiation:               c.Renegotiation,\n\t}\n}\n"
        },
        {
          "name": "dialer_tls_go18.go",
          "type": "blob",
          "size": 0.1328125,
          "content": "//go:build go1.8\n// +build go1.8\n\npackage ws\n\nimport \"crypto/tls\"\n\nfunc tlsCloneConfig(c *tls.Config) *tls.Config {\n\treturn c.Clone()\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 1.7001953125,
          "content": "/*\nPackage ws implements a client and server for the WebSocket protocol as\nspecified in RFC 6455.\n\nThe main purpose of this package is to provide simple low-level API for\nefficient work with protocol.\n\nOverview.\n\nUpgrade to WebSocket (or WebSocket handshake) can be done in two ways.\n\nThe first way is to use `net/http` server:\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tconn, _, _, err := ws.UpgradeHTTP(r, w)\n\t})\n\nThe second and much more efficient way is so-called \"zero-copy upgrade\". It\navoids redundant allocations and copying of not used headers or other request\ndata. User decides by himself which data should be copied.\n\n\tln, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\t// handle error\n\t}\n\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\t// handle error\n\t}\n\n\thandshake, err := ws.Upgrade(conn)\n\tif err != nil {\n\t\t// handle error\n\t}\n\nFor customization details see `ws.Upgrader` documentation.\n\nAfter WebSocket handshake you can work with connection in multiple ways.\nThat is, `ws` does not force the only one way of how to work with WebSocket:\n\n\theader, err := ws.ReadHeader(conn)\n\tif err != nil {\n\t\t// handle err\n\t}\n\n\tbuf := make([]byte, header.Length)\n\t_, err := io.ReadFull(conn, buf)\n\tif err != nil {\n\t\t// handle err\n\t}\n\n\tresp := ws.NewBinaryFrame([]byte(\"hello, world!\"))\n\tif err := ws.WriteFrame(conn, frame); err != nil {\n\t    // handle err\n\t}\n\nAs you can see, it stream friendly:\n\n\tconst N = 42\n\n\tws.WriteHeader(ws.Header{\n\t\tFin:    true,\n\t\tLength: N,\n\t\tOpCode: ws.OpBinary,\n\t})\n\n\tio.CopyN(conn, rand.Reader, N)\n\nOr:\n\n\theader, err := ws.ReadHeader(conn)\n\tif err != nil {\n\t\t// handle err\n\t}\n\n\tio.CopyN(ioutil.Discard, conn, header.Length)\n\nFor more info see the documentation.\n*/\npackage ws\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 1.537109375,
          "content": "package ws\n\n// RejectOption represents an option used to control the way connection is\n// rejected.\ntype RejectOption func(*ConnectionRejectedError)\n\n// RejectionReason returns an option that makes connection to be rejected with\n// given reason.\nfunc RejectionReason(reason string) RejectOption {\n\treturn func(err *ConnectionRejectedError) {\n\t\terr.reason = reason\n\t}\n}\n\n// RejectionStatus returns an option that makes connection to be rejected with\n// given HTTP status code.\nfunc RejectionStatus(code int) RejectOption {\n\treturn func(err *ConnectionRejectedError) {\n\t\terr.code = code\n\t}\n}\n\n// RejectionHeader returns an option that makes connection to be rejected with\n// given HTTP headers.\nfunc RejectionHeader(h HandshakeHeader) RejectOption {\n\treturn func(err *ConnectionRejectedError) {\n\t\terr.header = h\n\t}\n}\n\n// RejectConnectionError constructs an error that could be used to control the\n// way handshake is rejected by Upgrader.\nfunc RejectConnectionError(options ...RejectOption) error {\n\terr := new(ConnectionRejectedError)\n\tfor _, opt := range options {\n\t\topt(err)\n\t}\n\treturn err\n}\n\n// ConnectionRejectedError represents a rejection of connection during\n// WebSocket handshake error.\n//\n// It can be returned by Upgrader's On* hooks to indicate that WebSocket\n// handshake should be rejected.\ntype ConnectionRejectedError struct {\n\treason string\n\tcode   int\n\theader HandshakeHeader\n}\n\n// Error implements error interface.\nfunc (r *ConnectionRejectedError) Error() string {\n\treturn r.reason\n}\n\nfunc (r *ConnectionRejectedError) StatusCode() int {\n\treturn r.code\n}\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "frame.go",
          "type": "blob",
          "size": 13.166015625,
          "content": "package ws\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"math/rand\"\n)\n\n// Constants defined by specification.\nconst (\n\t// All control frames MUST have a payload length of 125 bytes or less and MUST NOT be fragmented.\n\tMaxControlFramePayloadSize = 125\n)\n\n// OpCode represents operation code.\ntype OpCode byte\n\n// Operation codes defined by specification.\n// See https://tools.ietf.org/html/rfc6455#section-5.2\nconst (\n\tOpContinuation OpCode = 0x0\n\tOpText         OpCode = 0x1\n\tOpBinary       OpCode = 0x2\n\tOpClose        OpCode = 0x8\n\tOpPing         OpCode = 0x9\n\tOpPong         OpCode = 0xa\n)\n\n// IsControl checks whether the c is control operation code.\n// See https://tools.ietf.org/html/rfc6455#section-5.5\nfunc (c OpCode) IsControl() bool {\n\t// RFC6455: Control frames are identified by opcodes where\n\t// the most significant bit of the opcode is 1.\n\t//\n\t// Note that OpCode is only 4 bit length.\n\treturn c&0x8 != 0\n}\n\n// IsData checks whether the c is data operation code.\n// See https://tools.ietf.org/html/rfc6455#section-5.6\nfunc (c OpCode) IsData() bool {\n\t// RFC6455: Data frames (e.g., non-control frames) are identified by opcodes\n\t// where the most significant bit of the opcode is 0.\n\t//\n\t// Note that OpCode is only 4 bit length.\n\treturn c&0x8 == 0\n}\n\n// IsReserved checks whether the c is reserved operation code.\n// See https://tools.ietf.org/html/rfc6455#section-5.2\nfunc (c OpCode) IsReserved() bool {\n\t// RFC6455:\n\t// %x3-7 are reserved for further non-control frames\n\t// %xB-F are reserved for further control frames\n\treturn (0x3 <= c && c <= 0x7) || (0xb <= c && c <= 0xf)\n}\n\n// StatusCode represents the encoded reason for closure of websocket connection.\n//\n// There are few helper methods on StatusCode that helps to define a range in\n// which given code is lay in. accordingly to ranges defined in specification.\n//\n// See https://tools.ietf.org/html/rfc6455#section-7.4\ntype StatusCode uint16\n\n// StatusCodeRange describes range of StatusCode values.\ntype StatusCodeRange struct {\n\tMin, Max StatusCode\n}\n\n// Status code ranges defined by specification.\n// See https://tools.ietf.org/html/rfc6455#section-7.4.2\nvar (\n\tStatusRangeNotInUse    = StatusCodeRange{0, 999}\n\tStatusRangeProtocol    = StatusCodeRange{1000, 2999}\n\tStatusRangeApplication = StatusCodeRange{3000, 3999}\n\tStatusRangePrivate     = StatusCodeRange{4000, 4999}\n)\n\n// Status codes defined by specification.\n// See https://tools.ietf.org/html/rfc6455#section-7.4.1\nconst (\n\tStatusNormalClosure           StatusCode = 1000\n\tStatusGoingAway               StatusCode = 1001\n\tStatusProtocolError           StatusCode = 1002\n\tStatusUnsupportedData         StatusCode = 1003\n\tStatusNoMeaningYet            StatusCode = 1004\n\tStatusInvalidFramePayloadData StatusCode = 1007\n\tStatusPolicyViolation         StatusCode = 1008\n\tStatusMessageTooBig           StatusCode = 1009\n\tStatusMandatoryExt            StatusCode = 1010\n\tStatusInternalServerError     StatusCode = 1011\n\tStatusTLSHandshake            StatusCode = 1015\n\n\t// StatusAbnormalClosure is a special code designated for use in\n\t// applications.\n\tStatusAbnormalClosure StatusCode = 1006\n\n\t// StatusNoStatusRcvd is a special code designated for use in applications.\n\tStatusNoStatusRcvd StatusCode = 1005\n)\n\n// In reports whether the code is defined in given range.\nfunc (s StatusCode) In(r StatusCodeRange) bool {\n\treturn r.Min <= s && s <= r.Max\n}\n\n// Empty reports whether the code is empty.\n// Empty code has no any meaning neither app level codes nor other.\n// This method is useful just to check that code is golang default value 0.\nfunc (s StatusCode) Empty() bool {\n\treturn s == 0\n}\n\n// IsNotUsed reports whether the code is predefined in not used range.\nfunc (s StatusCode) IsNotUsed() bool {\n\treturn s.In(StatusRangeNotInUse)\n}\n\n// IsApplicationSpec reports whether the code should be defined by\n// application, framework or libraries specification.\nfunc (s StatusCode) IsApplicationSpec() bool {\n\treturn s.In(StatusRangeApplication)\n}\n\n// IsPrivateSpec reports whether the code should be defined privately.\nfunc (s StatusCode) IsPrivateSpec() bool {\n\treturn s.In(StatusRangePrivate)\n}\n\n// IsProtocolSpec reports whether the code should be defined by protocol specification.\nfunc (s StatusCode) IsProtocolSpec() bool {\n\treturn s.In(StatusRangeProtocol)\n}\n\n// IsProtocolDefined reports whether the code is already defined by protocol specification.\nfunc (s StatusCode) IsProtocolDefined() bool {\n\tswitch s {\n\tcase StatusNormalClosure,\n\t\tStatusGoingAway,\n\t\tStatusProtocolError,\n\t\tStatusUnsupportedData,\n\t\tStatusInvalidFramePayloadData,\n\t\tStatusPolicyViolation,\n\t\tStatusMessageTooBig,\n\t\tStatusMandatoryExt,\n\t\tStatusInternalServerError,\n\t\tStatusNoStatusRcvd,\n\t\tStatusAbnormalClosure,\n\t\tStatusTLSHandshake:\n\t\treturn true\n\t}\n\treturn false\n}\n\n// IsProtocolReserved reports whether the code is defined by protocol specification\n// to be reserved only for application usage purpose.\nfunc (s StatusCode) IsProtocolReserved() bool {\n\tswitch s {\n\t// [RFC6455]: {1005,1006,1015} is a reserved value and MUST NOT be set as a status code in a\n\t// Close control frame by an endpoint.\n\tcase StatusNoStatusRcvd, StatusAbnormalClosure, StatusTLSHandshake:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// Compiled control frames for common use cases.\n// For construct-serialize optimizations.\nvar (\n\tCompiledPing  = MustCompileFrame(NewPingFrame(nil))\n\tCompiledPong  = MustCompileFrame(NewPongFrame(nil))\n\tCompiledClose = MustCompileFrame(NewCloseFrame(nil))\n\n\tCompiledCloseNormalClosure           = MustCompileFrame(closeFrameNormalClosure)\n\tCompiledCloseGoingAway               = MustCompileFrame(closeFrameGoingAway)\n\tCompiledCloseProtocolError           = MustCompileFrame(closeFrameProtocolError)\n\tCompiledCloseUnsupportedData         = MustCompileFrame(closeFrameUnsupportedData)\n\tCompiledCloseNoMeaningYet            = MustCompileFrame(closeFrameNoMeaningYet)\n\tCompiledCloseInvalidFramePayloadData = MustCompileFrame(closeFrameInvalidFramePayloadData)\n\tCompiledClosePolicyViolation         = MustCompileFrame(closeFramePolicyViolation)\n\tCompiledCloseMessageTooBig           = MustCompileFrame(closeFrameMessageTooBig)\n\tCompiledCloseMandatoryExt            = MustCompileFrame(closeFrameMandatoryExt)\n\tCompiledCloseInternalServerError     = MustCompileFrame(closeFrameInternalServerError)\n\tCompiledCloseTLSHandshake            = MustCompileFrame(closeFrameTLSHandshake)\n)\n\n// Header represents websocket frame header.\n// See https://tools.ietf.org/html/rfc6455#section-5.2\ntype Header struct {\n\tFin    bool\n\tRsv    byte\n\tOpCode OpCode\n\tMasked bool\n\tMask   [4]byte\n\tLength int64\n}\n\n// Rsv1 reports whether the header has first rsv bit set.\nfunc (h Header) Rsv1() bool { return h.Rsv&bit5 != 0 }\n\n// Rsv2 reports whether the header has second rsv bit set.\nfunc (h Header) Rsv2() bool { return h.Rsv&bit6 != 0 }\n\n// Rsv3 reports whether the header has third rsv bit set.\nfunc (h Header) Rsv3() bool { return h.Rsv&bit7 != 0 }\n\n// Rsv creates rsv byte representation from bits.\nfunc Rsv(r1, r2, r3 bool) (rsv byte) {\n\tif r1 {\n\t\trsv |= bit5\n\t}\n\tif r2 {\n\t\trsv |= bit6\n\t}\n\tif r3 {\n\t\trsv |= bit7\n\t}\n\treturn rsv\n}\n\n// RsvBits returns rsv bits from bytes representation.\nfunc RsvBits(rsv byte) (r1, r2, r3 bool) {\n\tr1 = rsv&bit5 != 0\n\tr2 = rsv&bit6 != 0\n\tr3 = rsv&bit7 != 0\n\treturn r1, r2, r3\n}\n\n// Frame represents websocket frame.\n// See https://tools.ietf.org/html/rfc6455#section-5.2\ntype Frame struct {\n\tHeader  Header\n\tPayload []byte\n}\n\n// NewFrame creates frame with given operation code,\n// flag of completeness and payload bytes.\nfunc NewFrame(op OpCode, fin bool, p []byte) Frame {\n\treturn Frame{\n\t\tHeader: Header{\n\t\t\tFin:    fin,\n\t\t\tOpCode: op,\n\t\t\tLength: int64(len(p)),\n\t\t},\n\t\tPayload: p,\n\t}\n}\n\n// NewTextFrame creates text frame with p as payload.\n// Note that p is not copied.\nfunc NewTextFrame(p []byte) Frame {\n\treturn NewFrame(OpText, true, p)\n}\n\n// NewBinaryFrame creates binary frame with p as payload.\n// Note that p is not copied.\nfunc NewBinaryFrame(p []byte) Frame {\n\treturn NewFrame(OpBinary, true, p)\n}\n\n// NewPingFrame creates ping frame with p as payload.\n// Note that p is not copied.\n// Note that p must have length of MaxControlFramePayloadSize bytes or less due\n// to RFC.\nfunc NewPingFrame(p []byte) Frame {\n\treturn NewFrame(OpPing, true, p)\n}\n\n// NewPongFrame creates pong frame with p as payload.\n// Note that p is not copied.\n// Note that p must have length of MaxControlFramePayloadSize bytes or less due\n// to RFC.\nfunc NewPongFrame(p []byte) Frame {\n\treturn NewFrame(OpPong, true, p)\n}\n\n// NewCloseFrame creates close frame with given close body.\n// Note that p is not copied.\n// Note that p must have length of MaxControlFramePayloadSize bytes or less due\n// to RFC.\nfunc NewCloseFrame(p []byte) Frame {\n\treturn NewFrame(OpClose, true, p)\n}\n\n// NewCloseFrameBody encodes a closure code and a reason into a binary\n// representation.\n//\n// It returns slice which is at most MaxControlFramePayloadSize bytes length.\n// If the reason is too big it will be cropped to fit the limit defined by the\n// spec.\n//\n// See https://tools.ietf.org/html/rfc6455#section-5.5\nfunc NewCloseFrameBody(code StatusCode, reason string) []byte {\n\tn := min(2+len(reason), MaxControlFramePayloadSize)\n\tp := make([]byte, n)\n\n\tcrop := min(MaxControlFramePayloadSize-2, len(reason))\n\tPutCloseFrameBody(p, code, reason[:crop])\n\n\treturn p\n}\n\n// PutCloseFrameBody encodes code and reason into buf.\n//\n// It will panic if the buffer is too small to accommodate a code or a reason.\n//\n// PutCloseFrameBody does not check buffer to be RFC compliant, but note that\n// by RFC it must be at most MaxControlFramePayloadSize.\nfunc PutCloseFrameBody(p []byte, code StatusCode, reason string) {\n\t_ = p[1+len(reason)]\n\tbinary.BigEndian.PutUint16(p, uint16(code))\n\tcopy(p[2:], reason)\n}\n\n// MaskFrame masks frame and returns frame with masked payload and Mask header's field set.\n// Note that it copies f payload to prevent collisions.\n// For less allocations you could use MaskFrameInPlace or construct frame manually.\nfunc MaskFrame(f Frame) Frame {\n\treturn MaskFrameWith(f, NewMask())\n}\n\n// MaskFrameWith masks frame with given mask and returns frame\n// with masked payload and Mask header's field set.\n// Note that it copies f payload to prevent collisions.\n// For less allocations you could use MaskFrameInPlaceWith or construct frame manually.\nfunc MaskFrameWith(f Frame, mask [4]byte) Frame {\n\t// TODO(gobwas): check CopyCipher ws copy() Cipher().\n\tp := make([]byte, len(f.Payload))\n\tcopy(p, f.Payload)\n\tf.Payload = p\n\treturn MaskFrameInPlaceWith(f, mask)\n}\n\n// MaskFrameInPlace masks frame and returns frame with masked payload and Mask\n// header's field set.\n// Note that it applies xor cipher to f.Payload without copying, that is, it\n// modifies f.Payload inplace.\nfunc MaskFrameInPlace(f Frame) Frame {\n\treturn MaskFrameInPlaceWith(f, NewMask())\n}\n\nvar zeroMask [4]byte\n\n// UnmaskFrame unmasks frame and returns frame with unmasked payload and Mask\n// header's field cleared.\n// Note that it copies f payload.\nfunc UnmaskFrame(f Frame) Frame {\n\tp := make([]byte, len(f.Payload))\n\tcopy(p, f.Payload)\n\tf.Payload = p\n\treturn UnmaskFrameInPlace(f)\n}\n\n// UnmaskFrameInPlace unmasks frame and returns frame with unmasked payload and\n// Mask header's field cleared.\n// Note that it applies xor cipher to f.Payload without copying, that is, it\n// modifies f.Payload inplace.\nfunc UnmaskFrameInPlace(f Frame) Frame {\n\tCipher(f.Payload, f.Header.Mask, 0)\n\tf.Header.Masked = false\n\tf.Header.Mask = zeroMask\n\treturn f\n}\n\n// MaskFrameInPlaceWith masks frame with given mask and returns frame\n// with masked payload and Mask header's field set.\n// Note that it applies xor cipher to f.Payload without copying, that is, it\n// modifies f.Payload inplace.\nfunc MaskFrameInPlaceWith(f Frame, m [4]byte) Frame {\n\tf.Header.Masked = true\n\tf.Header.Mask = m\n\tCipher(f.Payload, m, 0)\n\treturn f\n}\n\n// NewMask creates new random mask.\nfunc NewMask() (ret [4]byte) {\n\tbinary.BigEndian.PutUint32(ret[:], rand.Uint32())\n\treturn ret\n}\n\n// CompileFrame returns byte representation of given frame.\n// In terms of memory consumption it is useful to precompile static frames\n// which are often used.\nfunc CompileFrame(f Frame) (bts []byte, err error) {\n\tbuf := bytes.NewBuffer(make([]byte, 0, 16))\n\terr = WriteFrame(buf, f)\n\tbts = buf.Bytes()\n\treturn bts, err\n}\n\n// MustCompileFrame is like CompileFrame but panics if frame can not be\n// encoded.\nfunc MustCompileFrame(f Frame) []byte {\n\tbts, err := CompileFrame(f)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn bts\n}\n\nfunc makeCloseFrame(code StatusCode) Frame {\n\treturn NewCloseFrame(NewCloseFrameBody(code, \"\"))\n}\n\nvar (\n\tcloseFrameNormalClosure           = makeCloseFrame(StatusNormalClosure)\n\tcloseFrameGoingAway               = makeCloseFrame(StatusGoingAway)\n\tcloseFrameProtocolError           = makeCloseFrame(StatusProtocolError)\n\tcloseFrameUnsupportedData         = makeCloseFrame(StatusUnsupportedData)\n\tcloseFrameNoMeaningYet            = makeCloseFrame(StatusNoMeaningYet)\n\tcloseFrameInvalidFramePayloadData = makeCloseFrame(StatusInvalidFramePayloadData)\n\tcloseFramePolicyViolation         = makeCloseFrame(StatusPolicyViolation)\n\tcloseFrameMessageTooBig           = makeCloseFrame(StatusMessageTooBig)\n\tcloseFrameMandatoryExt            = makeCloseFrame(StatusMandatoryExt)\n\tcloseFrameInternalServerError     = makeCloseFrame(StatusInternalServerError)\n\tcloseFrameTLSHandshake            = makeCloseFrame(StatusTLSHandshake)\n)\n"
        },
        {
          "name": "frame_test.go",
          "type": "blob",
          "size": 0.44921875,
          "content": "package ws\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestOpCodeIsControl(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tcode OpCode\n\t\texp  bool\n\t}{\n\t\t{OpClose, true},\n\t\t{OpPing, true},\n\t\t{OpPong, true},\n\t\t{OpBinary, false},\n\t\t{OpText, false},\n\t\t{OpContinuation, false},\n\t} {\n\t\tt.Run(fmt.Sprintf(\"0x%02x\", test.code), func(t *testing.T) {\n\t\t\tif act := test.code.IsControl(); act != test.exp {\n\t\t\t\tt.Errorf(\"IsControl = %v; want %v\", act, test.exp)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1494140625,
          "content": "module github.com/gobwas/ws\n\ngo 1.16\n\nrequire (\n\tgithub.com/gobwas/httphead v0.1.0\n\tgithub.com/gobwas/pool v0.2.1\n\tgolang.org/x/sys v0.6.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.4736328125,
          "content": "github.com/gobwas/httphead v0.1.0 h1:exrUm0f4YX0L7EBwZHuCF4GDp8aJfVeBrlLQrs6NqWU=\ngithub.com/gobwas/httphead v0.1.0/go.mod h1:O/RXo79gxV8G+RqlR/otEwx4Q36zl9rqC5u12GKvMCM=\ngithub.com/gobwas/pool v0.2.1 h1:xfeeEhW7pwmX8nuLVlqbzVc7udMDrwetjEv+TZIz1og=\ngithub.com/gobwas/pool v0.2.1/go.mod h1:q8bcK0KcYlCgd9e7WYLm9LpyS+YeLd8JVDW6WezmKEw=\ngolang.org/x/sys v0.6.0 h1:MVltZSvRTcU2ljQOhs94SXPftV6DCNnZViHeQps87pQ=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n"
        },
        {
          "name": "hijack_go119.go",
          "type": "blob",
          "size": 0.2548828125,
          "content": "//go:build !go1.20\n// +build !go1.20\n\npackage ws\n\nimport (\n\t\"bufio\"\n\t\"net\"\n\t\"net/http\"\n)\n\nfunc hijack(w http.ResponseWriter) (net.Conn, *bufio.ReadWriter, error) {\n\thj, ok := w.(http.Hijacker)\n\tif ok {\n\t\treturn hj.Hijack()\n\t}\n\treturn nil, nil, ErrNotHijacker\n}\n"
        },
        {
          "name": "hijack_go120.go",
          "type": "blob",
          "size": 0.3251953125,
          "content": "//go:build go1.20\n// +build go1.20\n\npackage ws\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"net\"\n\t\"net/http\"\n)\n\nfunc hijack(w http.ResponseWriter) (net.Conn, *bufio.ReadWriter, error) {\n\tconn, rw, err := http.NewResponseController(w).Hijack()\n\tif errors.Is(err, http.ErrNotSupported) {\n\t\treturn nil, nil, ErrNotHijacker\n\t}\n\treturn conn, rw, err\n}\n"
        },
        {
          "name": "http.go",
          "type": "blob",
          "size": 13.216796875,
          "content": "package ws\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\n\t\"github.com/gobwas/httphead\"\n)\n\nconst (\n\tcrlf          = \"\\r\\n\"\n\tcolonAndSpace = \": \"\n\tcommaAndSpace = \", \"\n)\n\nconst (\n\ttextHeadUpgrade = \"HTTP/1.1 101 Switching Protocols\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\n\"\n)\n\nvar (\n\ttextHeadBadRequest          = statusText(http.StatusBadRequest)\n\ttextHeadInternalServerError = statusText(http.StatusInternalServerError)\n\ttextHeadUpgradeRequired     = statusText(http.StatusUpgradeRequired)\n\n\ttextTailErrHandshakeBadProtocol   = errorText(ErrHandshakeBadProtocol)\n\ttextTailErrHandshakeBadMethod     = errorText(ErrHandshakeBadMethod)\n\ttextTailErrHandshakeBadHost       = errorText(ErrHandshakeBadHost)\n\ttextTailErrHandshakeBadUpgrade    = errorText(ErrHandshakeBadUpgrade)\n\ttextTailErrHandshakeBadConnection = errorText(ErrHandshakeBadConnection)\n\ttextTailErrHandshakeBadSecAccept  = errorText(ErrHandshakeBadSecAccept)\n\ttextTailErrHandshakeBadSecKey     = errorText(ErrHandshakeBadSecKey)\n\ttextTailErrHandshakeBadSecVersion = errorText(ErrHandshakeBadSecVersion)\n\ttextTailErrUpgradeRequired        = errorText(ErrHandshakeUpgradeRequired)\n)\n\nconst (\n\t// Every new header must be added to TestHeaderNames test.\n\theaderHost          = \"Host\"\n\theaderUpgrade       = \"Upgrade\"\n\theaderConnection    = \"Connection\"\n\theaderSecVersion    = \"Sec-WebSocket-Version\"\n\theaderSecProtocol   = \"Sec-WebSocket-Protocol\"\n\theaderSecExtensions = \"Sec-WebSocket-Extensions\"\n\theaderSecKey        = \"Sec-WebSocket-Key\"\n\theaderSecAccept     = \"Sec-WebSocket-Accept\"\n\n\theaderHostCanonical          = headerHost\n\theaderUpgradeCanonical       = headerUpgrade\n\theaderConnectionCanonical    = headerConnection\n\theaderSecVersionCanonical    = \"Sec-Websocket-Version\"\n\theaderSecProtocolCanonical   = \"Sec-Websocket-Protocol\"\n\theaderSecExtensionsCanonical = \"Sec-Websocket-Extensions\"\n\theaderSecKeyCanonical        = \"Sec-Websocket-Key\"\n\theaderSecAcceptCanonical     = \"Sec-Websocket-Accept\"\n)\n\nvar (\n\tspecHeaderValueUpgrade         = []byte(\"websocket\")\n\tspecHeaderValueConnection      = []byte(\"Upgrade\")\n\tspecHeaderValueConnectionLower = []byte(\"upgrade\")\n\tspecHeaderValueSecVersion      = []byte(\"13\")\n)\n\nvar (\n\thttpVersion1_0    = []byte(\"HTTP/1.0\")\n\thttpVersion1_1    = []byte(\"HTTP/1.1\")\n\thttpVersionPrefix = []byte(\"HTTP/\")\n)\n\ntype httpRequestLine struct {\n\tmethod, uri  []byte\n\tmajor, minor int\n}\n\ntype httpResponseLine struct {\n\tmajor, minor int\n\tstatus       int\n\treason       []byte\n}\n\n// httpParseRequestLine parses http request line like \"GET / HTTP/1.0\".\nfunc httpParseRequestLine(line []byte) (req httpRequestLine, err error) {\n\tvar proto []byte\n\treq.method, req.uri, proto = bsplit3(line, ' ')\n\n\tvar ok bool\n\treq.major, req.minor, ok = httpParseVersion(proto)\n\tif !ok {\n\t\terr = ErrMalformedRequest\n\t}\n\treturn req, err\n}\n\nfunc httpParseResponseLine(line []byte) (resp httpResponseLine, err error) {\n\tvar (\n\t\tproto  []byte\n\t\tstatus []byte\n\t)\n\tproto, status, resp.reason = bsplit3(line, ' ')\n\n\tvar ok bool\n\tresp.major, resp.minor, ok = httpParseVersion(proto)\n\tif !ok {\n\t\treturn resp, ErrMalformedResponse\n\t}\n\n\tvar convErr error\n\tresp.status, convErr = asciiToInt(status)\n\tif convErr != nil {\n\t\treturn resp, ErrMalformedResponse\n\t}\n\n\treturn resp, nil\n}\n\n// httpParseVersion parses major and minor version of HTTP protocol. It returns\n// parsed values and true if parse is ok.\nfunc httpParseVersion(bts []byte) (major, minor int, ok bool) {\n\tswitch {\n\tcase bytes.Equal(bts, httpVersion1_0):\n\t\treturn 1, 0, true\n\tcase bytes.Equal(bts, httpVersion1_1):\n\t\treturn 1, 1, true\n\tcase len(bts) < 8:\n\t\treturn 0, 0, false\n\tcase !bytes.Equal(bts[:5], httpVersionPrefix):\n\t\treturn 0, 0, false\n\t}\n\n\tbts = bts[5:]\n\n\tdot := bytes.IndexByte(bts, '.')\n\tif dot == -1 {\n\t\treturn 0, 0, false\n\t}\n\tvar err error\n\tmajor, err = asciiToInt(bts[:dot])\n\tif err != nil {\n\t\treturn major, 0, false\n\t}\n\tminor, err = asciiToInt(bts[dot+1:])\n\tif err != nil {\n\t\treturn major, minor, false\n\t}\n\n\treturn major, minor, true\n}\n\n// httpParseHeaderLine parses HTTP header as key-value pair. It returns parsed\n// values and true if parse is ok.\nfunc httpParseHeaderLine(line []byte) (k, v []byte, ok bool) {\n\tcolon := bytes.IndexByte(line, ':')\n\tif colon == -1 {\n\t\treturn nil, nil, false\n\t}\n\n\tk = btrim(line[:colon])\n\t// TODO(gobwas): maybe use just lower here?\n\tcanonicalizeHeaderKey(k)\n\n\tv = btrim(line[colon+1:])\n\n\treturn k, v, true\n}\n\n// httpGetHeader is the same as textproto.MIMEHeader.Get, except the thing,\n// that key is already canonical. This helps to increase performance.\nfunc httpGetHeader(h http.Header, key string) string {\n\tif h == nil {\n\t\treturn \"\"\n\t}\n\tv := h[key]\n\tif len(v) == 0 {\n\t\treturn \"\"\n\t}\n\treturn v[0]\n}\n\n// The request MAY include a header field with the name\n// |Sec-WebSocket-Protocol|.  If present, this value indicates one or more\n// comma-separated subprotocol the client wishes to speak, ordered by\n// preference.  The elements that comprise this value MUST be non-empty strings\n// with characters in the range U+0021 to U+007E not including separator\n// characters as defined in [RFC2616] and MUST all be unique strings.  The ABNF\n// for the value of this header field is 1#token, where the definitions of\n// constructs and rules are as given in [RFC2616].\nfunc strSelectProtocol(h string, check func(string) bool) (ret string, ok bool) {\n\tok = httphead.ScanTokens(strToBytes(h), func(v []byte) bool {\n\t\tif check(btsToString(v)) {\n\t\t\tret = string(v)\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t})\n\treturn ret, ok\n}\n\nfunc btsSelectProtocol(h []byte, check func([]byte) bool) (ret string, ok bool) {\n\tvar selected []byte\n\tok = httphead.ScanTokens(h, func(v []byte) bool {\n\t\tif check(v) {\n\t\t\tselected = v\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t})\n\tif ok && selected != nil {\n\t\treturn string(selected), true\n\t}\n\treturn ret, ok\n}\n\nfunc btsSelectExtensions(h []byte, selected []httphead.Option, check func(httphead.Option) bool) ([]httphead.Option, bool) {\n\ts := httphead.OptionSelector{\n\t\tFlags: httphead.SelectCopy,\n\t\tCheck: check,\n\t}\n\treturn s.Select(h, selected)\n}\n\nfunc negotiateMaybe(in httphead.Option, dest []httphead.Option, f func(httphead.Option) (httphead.Option, error)) ([]httphead.Option, error) {\n\tif in.Size() == 0 {\n\t\treturn dest, nil\n\t}\n\topt, err := f(in)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif opt.Size() > 0 {\n\t\tdest = append(dest, opt)\n\t}\n\treturn dest, nil\n}\n\nfunc negotiateExtensions(\n\th []byte, dest []httphead.Option,\n\tf func(httphead.Option) (httphead.Option, error),\n) (_ []httphead.Option, err error) {\n\tindex := -1\n\tvar current httphead.Option\n\tok := httphead.ScanOptions(h, func(i int, name, attr, val []byte) httphead.Control {\n\t\tif i != index {\n\t\t\tdest, err = negotiateMaybe(current, dest, f)\n\t\t\tif err != nil {\n\t\t\t\treturn httphead.ControlBreak\n\t\t\t}\n\t\t\tindex = i\n\t\t\tcurrent = httphead.Option{Name: name}\n\t\t}\n\t\tif attr != nil {\n\t\t\tcurrent.Parameters.Set(attr, val)\n\t\t}\n\t\treturn httphead.ControlContinue\n\t})\n\tif !ok {\n\t\treturn nil, ErrMalformedRequest\n\t}\n\treturn negotiateMaybe(current, dest, f)\n}\n\nfunc httpWriteHeader(bw *bufio.Writer, key, value string) {\n\thttpWriteHeaderKey(bw, key)\n\tbw.WriteString(value)\n\tbw.WriteString(crlf)\n}\n\nfunc httpWriteHeaderBts(bw *bufio.Writer, key string, value []byte) {\n\thttpWriteHeaderKey(bw, key)\n\tbw.Write(value)\n\tbw.WriteString(crlf)\n}\n\nfunc httpWriteHeaderKey(bw *bufio.Writer, key string) {\n\tbw.WriteString(key)\n\tbw.WriteString(colonAndSpace)\n}\n\nfunc httpWriteUpgradeRequest(\n\tbw *bufio.Writer,\n\tu *url.URL,\n\tnonce []byte,\n\tprotocols []string,\n\textensions []httphead.Option,\n\theader HandshakeHeader,\n\thost string,\n) {\n\tbw.WriteString(\"GET \")\n\tbw.WriteString(u.RequestURI())\n\tbw.WriteString(\" HTTP/1.1\\r\\n\")\n\n\tif host == \"\" {\n\t\thost = u.Host\n\t}\n\thttpWriteHeader(bw, headerHost, host)\n\n\thttpWriteHeaderBts(bw, headerUpgrade, specHeaderValueUpgrade)\n\thttpWriteHeaderBts(bw, headerConnection, specHeaderValueConnection)\n\thttpWriteHeaderBts(bw, headerSecVersion, specHeaderValueSecVersion)\n\n\t// NOTE: write nonce bytes as a string to prevent heap allocation â€“\n\t// WriteString() copy given string into its inner buffer, unlike Write()\n\t// which may write p directly to the underlying io.Writer â€“ which in turn\n\t// will lead to p escape.\n\thttpWriteHeader(bw, headerSecKey, btsToString(nonce))\n\n\tif len(protocols) > 0 {\n\t\thttpWriteHeaderKey(bw, headerSecProtocol)\n\t\tfor i, p := range protocols {\n\t\t\tif i > 0 {\n\t\t\t\tbw.WriteString(commaAndSpace)\n\t\t\t}\n\t\t\tbw.WriteString(p)\n\t\t}\n\t\tbw.WriteString(crlf)\n\t}\n\n\tif len(extensions) > 0 {\n\t\thttpWriteHeaderKey(bw, headerSecExtensions)\n\t\thttphead.WriteOptions(bw, extensions)\n\t\tbw.WriteString(crlf)\n\t}\n\n\tif header != nil {\n\t\theader.WriteTo(bw)\n\t}\n\n\tbw.WriteString(crlf)\n}\n\nfunc httpWriteResponseUpgrade(bw *bufio.Writer, nonce []byte, hs Handshake, header HandshakeHeaderFunc) {\n\tbw.WriteString(textHeadUpgrade)\n\n\thttpWriteHeaderKey(bw, headerSecAccept)\n\twriteAccept(bw, nonce)\n\tbw.WriteString(crlf)\n\n\tif hs.Protocol != \"\" {\n\t\thttpWriteHeader(bw, headerSecProtocol, hs.Protocol)\n\t}\n\tif len(hs.Extensions) > 0 {\n\t\thttpWriteHeaderKey(bw, headerSecExtensions)\n\t\thttphead.WriteOptions(bw, hs.Extensions)\n\t\tbw.WriteString(crlf)\n\t}\n\tif header != nil {\n\t\theader(bw)\n\t}\n\n\tbw.WriteString(crlf)\n}\n\nfunc httpWriteResponseError(bw *bufio.Writer, err error, code int, header HandshakeHeaderFunc) {\n\tswitch code {\n\tcase http.StatusBadRequest:\n\t\tbw.WriteString(textHeadBadRequest)\n\tcase http.StatusInternalServerError:\n\t\tbw.WriteString(textHeadInternalServerError)\n\tcase http.StatusUpgradeRequired:\n\t\tbw.WriteString(textHeadUpgradeRequired)\n\tdefault:\n\t\twriteStatusText(bw, code)\n\t}\n\n\t// Write custom headers.\n\tif header != nil {\n\t\theader(bw)\n\t}\n\n\tswitch err {\n\tcase ErrHandshakeBadProtocol:\n\t\tbw.WriteString(textTailErrHandshakeBadProtocol)\n\tcase ErrHandshakeBadMethod:\n\t\tbw.WriteString(textTailErrHandshakeBadMethod)\n\tcase ErrHandshakeBadHost:\n\t\tbw.WriteString(textTailErrHandshakeBadHost)\n\tcase ErrHandshakeBadUpgrade:\n\t\tbw.WriteString(textTailErrHandshakeBadUpgrade)\n\tcase ErrHandshakeBadConnection:\n\t\tbw.WriteString(textTailErrHandshakeBadConnection)\n\tcase ErrHandshakeBadSecAccept:\n\t\tbw.WriteString(textTailErrHandshakeBadSecAccept)\n\tcase ErrHandshakeBadSecKey:\n\t\tbw.WriteString(textTailErrHandshakeBadSecKey)\n\tcase ErrHandshakeBadSecVersion:\n\t\tbw.WriteString(textTailErrHandshakeBadSecVersion)\n\tcase ErrHandshakeUpgradeRequired:\n\t\tbw.WriteString(textTailErrUpgradeRequired)\n\tcase nil:\n\t\tbw.WriteString(crlf)\n\tdefault:\n\t\twriteErrorText(bw, err)\n\t}\n}\n\nfunc writeStatusText(bw *bufio.Writer, code int) {\n\tbw.WriteString(\"HTTP/1.1 \")\n\tbw.WriteString(strconv.Itoa(code))\n\tbw.WriteByte(' ')\n\tbw.WriteString(http.StatusText(code))\n\tbw.WriteString(crlf)\n\tbw.WriteString(\"Content-Type: text/plain; charset=utf-8\")\n\tbw.WriteString(crlf)\n}\n\nfunc writeErrorText(bw *bufio.Writer, err error) {\n\tbody := err.Error()\n\tbw.WriteString(\"Content-Length: \")\n\tbw.WriteString(strconv.Itoa(len(body)))\n\tbw.WriteString(crlf)\n\tbw.WriteString(crlf)\n\tbw.WriteString(body)\n}\n\n// httpError is like the http.Error with WebSocket context exception.\nfunc httpError(w http.ResponseWriter, body string, code int) {\n\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(body)))\n\tw.WriteHeader(code)\n\tw.Write([]byte(body))\n}\n\n// statusText is a non-performant status text generator.\n// NOTE: Used only to generate constants.\nfunc statusText(code int) string {\n\tvar buf bytes.Buffer\n\tbw := bufio.NewWriter(&buf)\n\twriteStatusText(bw, code)\n\tbw.Flush()\n\treturn buf.String()\n}\n\n// errorText is a non-performant error text generator.\n// NOTE: Used only to generate constants.\nfunc errorText(err error) string {\n\tvar buf bytes.Buffer\n\tbw := bufio.NewWriter(&buf)\n\twriteErrorText(bw, err)\n\tbw.Flush()\n\treturn buf.String()\n}\n\n// HandshakeHeader is the interface that writes both upgrade request or\n// response headers into a given io.Writer.\ntype HandshakeHeader interface {\n\tio.WriterTo\n}\n\n// HandshakeHeaderString is an adapter to allow the use of headers represented\n// by ordinary string as HandshakeHeader.\ntype HandshakeHeaderString string\n\n// WriteTo implements HandshakeHeader (and io.WriterTo) interface.\nfunc (s HandshakeHeaderString) WriteTo(w io.Writer) (int64, error) {\n\tn, err := io.WriteString(w, string(s))\n\treturn int64(n), err\n}\n\n// HandshakeHeaderBytes is an adapter to allow the use of headers represented\n// by ordinary slice of bytes as HandshakeHeader.\ntype HandshakeHeaderBytes []byte\n\n// WriteTo implements HandshakeHeader (and io.WriterTo) interface.\nfunc (b HandshakeHeaderBytes) WriteTo(w io.Writer) (int64, error) {\n\tn, err := w.Write(b)\n\treturn int64(n), err\n}\n\n// HandshakeHeaderFunc is an adapter to allow the use of headers represented by\n// ordinary function as HandshakeHeader.\ntype HandshakeHeaderFunc func(io.Writer) (int64, error)\n\n// WriteTo implements HandshakeHeader (and io.WriterTo) interface.\nfunc (f HandshakeHeaderFunc) WriteTo(w io.Writer) (int64, error) {\n\treturn f(w)\n}\n\n// HandshakeHeaderHTTP is an adapter to allow the use of http.Header as\n// HandshakeHeader.\ntype HandshakeHeaderHTTP http.Header\n\n// WriteTo implements HandshakeHeader (and io.WriterTo) interface.\nfunc (h HandshakeHeaderHTTP) WriteTo(w io.Writer) (int64, error) {\n\twr := writer{w: w}\n\terr := http.Header(h).Write(&wr)\n\treturn wr.n, err\n}\n\ntype writer struct {\n\tn int64\n\tw io.Writer\n}\n\nfunc (w *writer) WriteString(s string) (int, error) {\n\tn, err := io.WriteString(w.w, s)\n\tw.n += int64(n)\n\treturn n, err\n}\n\nfunc (w *writer) Write(p []byte) (int, error) {\n\tn, err := w.w.Write(p)\n\tw.n += int64(n)\n\treturn n, err\n}\n"
        },
        {
          "name": "http_test.go",
          "type": "blob",
          "size": 2.6025390625,
          "content": "package ws\n\nimport (\n\t\"bufio\"\n\t\"io/ioutil\"\n\t\"net/textproto\"\n\t\"net/url\"\n\t\"testing\"\n\n\t\"github.com/gobwas/httphead\"\n)\n\ntype httpVersionCase struct {\n\tin    []byte\n\tmajor int\n\tminor int\n\tok    bool\n}\n\nvar httpVersionCases = []httpVersionCase{\n\t{[]byte(\"HTTP/1.1\"), 1, 1, true},\n\t{[]byte(\"HTTP/1.0\"), 1, 0, true},\n\t{[]byte(\"HTTP/1.2\"), 1, 2, true},\n\t{[]byte(\"HTTP/42.1092\"), 42, 1092, true},\n}\n\nfunc TestParseHttpVersion(t *testing.T) {\n\tfor _, c := range httpVersionCases {\n\t\tt.Run(string(c.in), func(t *testing.T) {\n\t\t\tmajor, minor, ok := httpParseVersion(c.in)\n\t\t\tif major != c.major || minor != c.minor || ok != c.ok {\n\t\t\t\tt.Errorf(\n\t\t\t\t\t\"parseHttpVersion([]byte(%q)) = %v, %v, %v; want %v, %v, %v\",\n\t\t\t\t\tstring(c.in), major, minor, ok, c.major, c.minor, c.ok,\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestHeaderNames(t *testing.T) {\n\ttestCases := []struct {\n\t\thave, want string\n\t}{\n\t\t{\n\t\t\thave: headerHost,\n\t\t\twant: headerHostCanonical,\n\t\t},\n\t\t{\n\t\t\thave: headerUpgrade,\n\t\t\twant: headerUpgradeCanonical,\n\t\t},\n\t\t{\n\t\t\thave: headerConnection,\n\t\t\twant: headerConnectionCanonical,\n\t\t},\n\t\t{\n\t\t\thave: headerSecVersion,\n\t\t\twant: headerSecVersionCanonical,\n\t\t},\n\t\t{\n\t\t\thave: headerSecProtocol,\n\t\t\twant: headerSecProtocolCanonical,\n\t\t},\n\t\t{\n\t\t\thave: headerSecExtensions,\n\t\t\twant: headerSecExtensionsCanonical,\n\t\t},\n\t\t{\n\t\t\thave: headerSecKey,\n\t\t\twant: headerSecKeyCanonical,\n\t\t},\n\t\t{\n\t\t\thave: headerSecAccept,\n\t\t\twant: headerSecAcceptCanonical,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif have := textproto.CanonicalMIMEHeaderKey(tc.have); have != tc.want {\n\t\t\tt.Errorf(\"have %q want %q,\", have, tc.want)\n\t\t}\n\t}\n}\n\nfunc BenchmarkParseHttpVersion(b *testing.B) {\n\tfor _, c := range httpVersionCases {\n\t\tb.Run(string(c.in), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_, _, _ = httpParseVersion(c.in)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkHttpWriteUpgradeRequest(b *testing.B) {\n\tfor _, test := range []struct {\n\t\turl        *url.URL\n\t\tprotocols  []string\n\t\textensions []httphead.Option\n\t\theaders    HandshakeHeaderFunc\n\t\thost       string\n\t}{\n\t\t{\n\t\t\turl: makeURL(\"ws://example.org\"),\n\t\t},\n\t\t{\n\t\t\turl:  makeURL(\"ws://example.org\"),\n\t\t\thost: \"test-host\",\n\t\t},\n\t} {\n\t\tbw := bufio.NewWriter(ioutil.Discard)\n\t\tnonce := make([]byte, nonceSize)\n\t\tinitNonce(nonce)\n\n\t\tvar headers HandshakeHeader\n\t\tif test.headers != nil {\n\t\t\theaders = test.headers\n\t\t}\n\n\t\tb.ResetTimer()\n\t\tb.Run(\"\", func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\thttpWriteUpgradeRequest(bw,\n\t\t\t\t\ttest.url,\n\t\t\t\t\tnonce,\n\t\t\t\t\ttest.protocols,\n\t\t\t\t\ttest.extensions,\n\t\t\t\t\theaders,\n\t\t\t\t\ttest.host,\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc makeURL(s string) *url.URL {\n\tret, err := url.Parse(s)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "nonce.go",
          "type": "blob",
          "size": 2.3994140625,
          "content": "package ws\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"crypto/sha1\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"math/rand\"\n)\n\nconst (\n\t// RFC6455: The value of this header field MUST be a nonce consisting of a\n\t// randomly selected 16-byte value that has been base64-encoded (see\n\t// Section 4 of [RFC4648]).  The nonce MUST be selected randomly for each\n\t// connection.\n\tnonceKeySize = 16\n\tnonceSize    = 24 // base64.StdEncoding.EncodedLen(nonceKeySize)\n\n\t// RFC6455: The value of this header field is constructed by concatenating\n\t// /key/, defined above in step 4 in Section 4.2.2, with the string\n\t// \"258EAFA5- E914-47DA-95CA-C5AB0DC85B11\", taking the SHA-1 hash of this\n\t// concatenated value to obtain a 20-byte value and base64- encoding (see\n\t// Section 4 of [RFC4648]) this 20-byte hash.\n\tacceptSize = 28 // base64.StdEncoding.EncodedLen(sha1.Size)\n)\n\n// initNonce fills given slice with random base64-encoded nonce bytes.\nfunc initNonce(dst []byte) {\n\t// NOTE: bts does not escape.\n\tbts := make([]byte, nonceKeySize)\n\tif _, err := rand.Read(bts); err != nil {\n\t\tpanic(fmt.Sprintf(\"rand read error: %s\", err))\n\t}\n\tbase64.StdEncoding.Encode(dst, bts)\n}\n\n// checkAcceptFromNonce reports whether given accept bytes are valid for given\n// nonce bytes.\nfunc checkAcceptFromNonce(accept, nonce []byte) bool {\n\tif len(accept) != acceptSize {\n\t\treturn false\n\t}\n\t// NOTE: expect does not escape.\n\texpect := make([]byte, acceptSize)\n\tinitAcceptFromNonce(expect, nonce)\n\treturn bytes.Equal(expect, accept)\n}\n\n// initAcceptFromNonce fills given slice with accept bytes generated from given\n// nonce bytes. Given buffer should be exactly acceptSize bytes.\nfunc initAcceptFromNonce(accept, nonce []byte) {\n\tconst magic = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"\n\n\tif len(accept) != acceptSize {\n\t\tpanic(\"accept buffer is invalid\")\n\t}\n\tif len(nonce) != nonceSize {\n\t\tpanic(\"nonce is invalid\")\n\t}\n\n\tp := make([]byte, nonceSize+len(magic))\n\tcopy(p[:nonceSize], nonce)\n\tcopy(p[nonceSize:], magic)\n\n\tsum := sha1.Sum(p)\n\tbase64.StdEncoding.Encode(accept, sum[:])\n}\n\nfunc writeAccept(bw *bufio.Writer, nonce []byte) (int, error) {\n\taccept := make([]byte, acceptSize)\n\tinitAcceptFromNonce(accept, nonce)\n\t// NOTE: write accept bytes as a string to prevent heap allocation â€“\n\t// WriteString() copy given string into its inner buffer, unlike Write()\n\t// which may write p directly to the underlying io.Writer â€“ which in turn\n\t// will lead to p escape.\n\treturn bw.WriteString(btsToString(accept))\n}\n"
        },
        {
          "name": "nonce_test.go",
          "type": "blob",
          "size": 0.201171875,
          "content": "package ws\n\nimport \"testing\"\n\nfunc BenchmarkInitAcceptFromNonce(b *testing.B) {\n\tdst := make([]byte, acceptSize)\n\tnonce := mustMakeNonce()\n\tfor i := 0; i < b.N; i++ {\n\t\tinitAcceptFromNonce(dst, nonce)\n\t}\n}\n"
        },
        {
          "name": "read.go",
          "type": "blob",
          "size": 3.587890625,
          "content": "package ws\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n)\n\n// Errors used by frame reader.\nvar (\n\tErrHeaderLengthMSB        = fmt.Errorf(\"header error: the most significant bit must be 0\")\n\tErrHeaderLengthUnexpected = fmt.Errorf(\"header error: unexpected payload length bits\")\n)\n\n// ReadHeader reads a frame header from r.\nfunc ReadHeader(r io.Reader) (h Header, err error) {\n\t// Make slice of bytes with capacity 12 that could hold any header.\n\t//\n\t// The maximum header size is 14, but due to the 2 hop reads,\n\t// after first hop that reads first 2 constant bytes, we could reuse 2 bytes.\n\t// So 14 - 2 = 12.\n\tbts := make([]byte, 2, MaxHeaderSize-2)\n\n\t// Prepare to hold first 2 bytes to choose size of next read.\n\t_, err = io.ReadFull(r, bts)\n\tif err != nil {\n\t\treturn h, err\n\t}\n\n\th.Fin = bts[0]&bit0 != 0\n\th.Rsv = (bts[0] & 0x70) >> 4\n\th.OpCode = OpCode(bts[0] & 0x0f)\n\n\tvar extra int\n\n\tif bts[1]&bit0 != 0 {\n\t\th.Masked = true\n\t\textra += 4\n\t}\n\n\tlength := bts[1] & 0x7f\n\tswitch {\n\tcase length < 126:\n\t\th.Length = int64(length)\n\n\tcase length == 126:\n\t\textra += 2\n\n\tcase length == 127:\n\t\textra += 8\n\n\tdefault:\n\t\terr = ErrHeaderLengthUnexpected\n\t\treturn h, err\n\t}\n\n\tif extra == 0 {\n\t\treturn h, err\n\t}\n\n\t// Increase len of bts to extra bytes need to read.\n\t// Overwrite first 2 bytes that was read before.\n\tbts = bts[:extra]\n\t_, err = io.ReadFull(r, bts)\n\tif err != nil {\n\t\treturn h, err\n\t}\n\n\tswitch {\n\tcase length == 126:\n\t\th.Length = int64(binary.BigEndian.Uint16(bts[:2]))\n\t\tbts = bts[2:]\n\n\tcase length == 127:\n\t\tif bts[0]&0x80 != 0 {\n\t\t\terr = ErrHeaderLengthMSB\n\t\t\treturn h, err\n\t\t}\n\t\th.Length = int64(binary.BigEndian.Uint64(bts[:8]))\n\t\tbts = bts[8:]\n\t}\n\n\tif h.Masked {\n\t\tcopy(h.Mask[:], bts)\n\t}\n\n\treturn h, nil\n}\n\n// ReadFrame reads a frame from r.\n// It is not designed for high optimized use case cause it makes allocation\n// for frame.Header.Length size inside to read frame payload into.\n//\n// Note that ReadFrame does not unmask payload.\nfunc ReadFrame(r io.Reader) (f Frame, err error) {\n\tf.Header, err = ReadHeader(r)\n\tif err != nil {\n\t\treturn f, err\n\t}\n\n\tif f.Header.Length > 0 {\n\t\t// int(f.Header.Length) is safe here cause we have\n\t\t// checked it for overflow above in ReadHeader.\n\t\tf.Payload = make([]byte, int(f.Header.Length))\n\t\t_, err = io.ReadFull(r, f.Payload)\n\t}\n\n\treturn f, err\n}\n\n// MustReadFrame is like ReadFrame but panics if frame can not be read.\nfunc MustReadFrame(r io.Reader) Frame {\n\tf, err := ReadFrame(r)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn f\n}\n\n// ParseCloseFrameData parses close frame status code and closure reason if any provided.\n// If there is no status code in the payload\n// the empty status code is returned (code.Empty()) with empty string as a reason.\nfunc ParseCloseFrameData(payload []byte) (code StatusCode, reason string) {\n\tif len(payload) < 2 {\n\t\t// We returning empty StatusCode here, preventing the situation\n\t\t// when endpoint really sent code 1005 and we should return ProtocolError on that.\n\t\t//\n\t\t// In other words, we ignoring this rule [RFC6455:7.1.5]:\n\t\t//   If this Close control frame contains no status code, _The WebSocket\n\t\t//   Connection Close Code_ is considered to be 1005.\n\t\treturn code, reason\n\t}\n\tcode = StatusCode(binary.BigEndian.Uint16(payload))\n\treason = string(payload[2:])\n\treturn code, reason\n}\n\n// ParseCloseFrameDataUnsafe is like ParseCloseFrameData except the thing\n// that it does not copies payload bytes into reason, but prepares unsafe cast.\nfunc ParseCloseFrameDataUnsafe(payload []byte) (code StatusCode, reason string) {\n\tif len(payload) < 2 {\n\t\treturn code, reason\n\t}\n\tcode = StatusCode(binary.BigEndian.Uint16(payload))\n\treason = btsToString(payload[2:])\n\treturn code, reason\n}\n"
        },
        {
          "name": "read_test.go",
          "type": "blob",
          "size": 1.4052734375,
          "content": "package ws\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestReadHeader(t *testing.T) {\n\tfor i, test := range append([]RWTestCase{\n\t\t{\n\t\t\tData: bits(\"0000 0000 0 1111111 10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\"),\n\t\t\t//                              _______________________________________________________________________\n\t\t\t//                                                                 |\n\t\t\t//                                                            Length value\n\t\t\tErr: true,\n\t\t},\n\t}, RWTestCases...) {\n\t\tt.Run(fmt.Sprintf(\"#%d\", i), func(t *testing.T) {\n\t\t\tr := bytes.NewReader(test.Data)\n\t\t\th, err := ReadHeader(r)\n\t\t\tif test.Err && err == nil {\n\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t}\n\t\t\tif !test.Err && err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t\t}\n\t\t\tif test.Err {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(h, test.Header) {\n\t\t\t\tt.Errorf(\"ReadHeader()\\nread:\\n\\t%#v\\nwant:\\n\\t%#v\", h, test.Header)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkReadHeader(b *testing.B) {\n\tfor i, bench := range RWBenchCases {\n\t\tb.Run(fmt.Sprintf(\"%s#%d\", bench.label, i), func(b *testing.B) {\n\t\t\tbts := MustCompileFrame(Frame{Header: bench.header})\n\t\t\trds := make([]io.Reader, b.N)\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\trds[i] = bytes.NewReader(bts)\n\t\t\t}\n\n\t\t\tb.ResetTimer()\n\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_, err := ReadHeader(rds[i])\n\t\t\t\tif err != nil {\n\t\t\t\t\tb.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "rw_test.go",
          "type": "blob",
          "size": 2.5478515625,
          "content": "package ws\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype RWTestCase struct {\n\tData   []byte\n\tHeader Header\n\tErr    bool\n}\n\ntype RWBenchCase struct {\n\tlabel  string\n\theader Header\n}\n\nvar RWBenchCases = []RWBenchCase{\n\t{\n\t\t\"no-mask\",\n\t\tHeader{\n\t\t\tOpCode: OpText,\n\t\t\tFin:    true,\n\t\t},\n\t},\n\t{\n\t\t\"mask\",\n\t\tHeader{\n\t\t\tOpCode: OpText,\n\t\t\tFin:    true,\n\t\t\tMasked: true,\n\t\t\tMask:   NewMask(),\n\t\t},\n\t},\n\t{\n\t\t\"mask-u16\",\n\t\tHeader{\n\t\t\tOpCode: OpText,\n\t\t\tFin:    true,\n\t\t\tLength: len16,\n\t\t\tMasked: true,\n\t\t\tMask:   NewMask(),\n\t\t},\n\t},\n\t{\n\t\t\"mask-u64\",\n\t\tHeader{\n\t\t\tOpCode: OpText,\n\t\t\tFin:    true,\n\t\t\tLength: len64,\n\t\t\tMasked: true,\n\t\t\tMask:   NewMask(),\n\t\t},\n\t},\n}\n\nvar RWTestCases = []RWTestCase{\n\t{\n\t\tData: bits(\"1 001 0001 0 1100100\"),\n\t\t//          _ ___ ____ _ _______\n\t\t//          |  |   |   |    |\n\t\t//         Fin |   |  Mask Length\n\t\t//            Rsv  |\n\t\t//             TextFrame\n\t\tHeader: Header{\n\t\t\tFin:    true,\n\t\t\tRsv:    Rsv(false, false, true),\n\t\t\tOpCode: OpText,\n\t\t\tLength: 100,\n\t\t},\n\t},\n\t{\n\t\tData: bits(\"1 001 0001 1 1100100 00000001 10001000 00000000 11111111\"),\n\t\t//          _ ___ ____ _ _______ ___________________________________\n\t\t//          |  |   |   |    |                     |\n\t\t//         Fin |   |  Mask Length             Mask value\n\t\t//            Rsv  |\n\t\t//             TextFrame\n\t\tHeader: Header{\n\t\t\tFin:    true,\n\t\t\tRsv:    Rsv(false, false, true),\n\t\t\tOpCode: OpText,\n\t\t\tLength: 100,\n\t\t\tMasked: true,\n\t\t\tMask:   [4]byte{0x01, 0x88, 0x00, 0xff},\n\t\t},\n\t},\n\t{\n\t\tData: bits(\"0 110 0010 0 1111110 00001111 11111111\"),\n\t\t//          _ ___ ____ _ _______ _________________\n\t\t//          |  |   |   |    |            |\n\t\t//         Fin |   |  Mask Length   Length value\n\t\t//            Rsv  |\n\t\t//             BinaryFrame\n\t\tHeader: Header{\n\t\t\tFin:    false,\n\t\t\tRsv:    Rsv(true, true, false),\n\t\t\tOpCode: OpBinary,\n\t\t\tLength: 0x0fff,\n\t\t},\n\t},\n\t{\n\t\tData: bits(\"1 000 1010 0 1111111 01111111 00000000 00000000 00000000 00000000 00000000 00000000 00000000\"),\n\t\t//          _ ___ ____ _ _______ _______________________________________________________________________\n\t\t//          |  |   |   |    |                                       |\n\t\t//         Fin |   |  Mask Length                              Length value\n\t\t//            Rsv  |\n\t\t//              PongFrame\n\t\tHeader: Header{\n\t\t\tFin:    true,\n\t\t\tRsv:    Rsv(false, false, false),\n\t\t\tOpCode: OpPong,\n\t\t\tLength: 0x7f00000000000000,\n\t\t},\n\t},\n}\n\nfunc bits(s string) []byte {\n\ts = strings.ReplaceAll(s, \" \", \"\")\n\tbts := make([]byte, len(s)/8)\n\n\tfor i, j := 0, 0; i < len(s); i, j = i+8, j+1 {\n\t\tfmt.Sscanf(s[i:], \"%08b\", &bts[j])\n\t}\n\n\treturn bts\n}\n"
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 22.7197265625,
          "content": "package ws\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gobwas/httphead\"\n\t\"github.com/gobwas/pool/pbufio\"\n)\n\n// Constants used by ConnUpgrader.\nconst (\n\tDefaultServerReadBufferSize  = 4096\n\tDefaultServerWriteBufferSize = 512\n)\n\n// Errors used by both client and server when preparing WebSocket handshake.\nvar (\n\tErrHandshakeBadProtocol = RejectConnectionError(\n\t\tRejectionStatus(http.StatusHTTPVersionNotSupported),\n\t\tRejectionReason(\"handshake error: bad HTTP protocol version\"),\n\t)\n\tErrHandshakeBadMethod = RejectConnectionError(\n\t\tRejectionStatus(http.StatusMethodNotAllowed),\n\t\tRejectionReason(\"handshake error: bad HTTP request method\"),\n\t)\n\tErrHandshakeBadHost = RejectConnectionError(\n\t\tRejectionStatus(http.StatusBadRequest),\n\t\tRejectionReason(fmt.Sprintf(\"handshake error: bad %q header\", headerHost)),\n\t)\n\tErrHandshakeBadUpgrade = RejectConnectionError(\n\t\tRejectionStatus(http.StatusBadRequest),\n\t\tRejectionReason(fmt.Sprintf(\"handshake error: bad %q header\", headerUpgrade)),\n\t)\n\tErrHandshakeBadConnection = RejectConnectionError(\n\t\tRejectionStatus(http.StatusBadRequest),\n\t\tRejectionReason(fmt.Sprintf(\"handshake error: bad %q header\", headerConnection)),\n\t)\n\tErrHandshakeBadSecAccept = RejectConnectionError(\n\t\tRejectionStatus(http.StatusBadRequest),\n\t\tRejectionReason(fmt.Sprintf(\"handshake error: bad %q header\", headerSecAccept)),\n\t)\n\tErrHandshakeBadSecKey = RejectConnectionError(\n\t\tRejectionStatus(http.StatusBadRequest),\n\t\tRejectionReason(fmt.Sprintf(\"handshake error: bad %q header\", headerSecKey)),\n\t)\n\tErrHandshakeBadSecVersion = RejectConnectionError(\n\t\tRejectionStatus(http.StatusBadRequest),\n\t\tRejectionReason(fmt.Sprintf(\"handshake error: bad %q header\", headerSecVersion)),\n\t)\n)\n\n// ErrMalformedResponse is returned by Dialer to indicate that server response\n// can not be parsed.\nvar ErrMalformedResponse = fmt.Errorf(\"malformed HTTP response\")\n\n// ErrMalformedRequest is returned when HTTP request can not be parsed.\nvar ErrMalformedRequest = RejectConnectionError(\n\tRejectionStatus(http.StatusBadRequest),\n\tRejectionReason(\"malformed HTTP request\"),\n)\n\n// ErrHandshakeUpgradeRequired is returned by Upgrader to indicate that\n// connection is rejected because given WebSocket version is malformed.\n//\n// According to RFC6455:\n// If this version does not match a version understood by the server, the\n// server MUST abort the WebSocket handshake described in this section and\n// instead send an appropriate HTTP error code (such as 426 Upgrade Required)\n// and a |Sec-WebSocket-Version| header field indicating the version(s) the\n// server is capable of understanding.\nvar ErrHandshakeUpgradeRequired = RejectConnectionError(\n\tRejectionStatus(http.StatusUpgradeRequired),\n\tRejectionHeader(HandshakeHeaderString(headerSecVersion+\": 13\\r\\n\")),\n\tRejectionReason(fmt.Sprintf(\"handshake error: bad %q header\", headerSecVersion)),\n)\n\n// ErrNotHijacker is an error returned when http.ResponseWriter does not\n// implement http.Hijacker interface.\nvar ErrNotHijacker = RejectConnectionError(\n\tRejectionStatus(http.StatusInternalServerError),\n\tRejectionReason(\"given http.ResponseWriter is not a http.Hijacker\"),\n)\n\n// DefaultHTTPUpgrader is an HTTPUpgrader that holds no options and is used by\n// UpgradeHTTP function.\nvar DefaultHTTPUpgrader HTTPUpgrader\n\n// UpgradeHTTP is like HTTPUpgrader{}.Upgrade().\nfunc UpgradeHTTP(r *http.Request, w http.ResponseWriter) (net.Conn, *bufio.ReadWriter, Handshake, error) {\n\treturn DefaultHTTPUpgrader.Upgrade(r, w)\n}\n\n// DefaultUpgrader is an Upgrader that holds no options and is used by Upgrade\n// function.\nvar DefaultUpgrader Upgrader\n\n// Upgrade is like Upgrader{}.Upgrade().\nfunc Upgrade(conn io.ReadWriter) (Handshake, error) {\n\treturn DefaultUpgrader.Upgrade(conn)\n}\n\n// HTTPUpgrader contains options for upgrading connection to websocket from\n// net/http Handler arguments.\ntype HTTPUpgrader struct {\n\t// Timeout is the maximum amount of time an Upgrade() will spent while\n\t// writing handshake response.\n\t//\n\t// The default is no timeout.\n\tTimeout time.Duration\n\n\t// Header is an optional http.Header mapping that could be used to\n\t// write additional headers to the handshake response.\n\t//\n\t// Note that if present, it will be written in any result of handshake.\n\tHeader http.Header\n\n\t// Protocol is the select function that is used to select subprotocol from\n\t// list requested by client. If this field is set, then the first matched\n\t// protocol is sent to a client as negotiated.\n\tProtocol func(string) bool\n\n\t// Extension is the select function that is used to select extensions from\n\t// list requested by client. If this field is set, then the all matched\n\t// extensions are sent to a client as negotiated.\n\t//\n\t// Deprecated: use Negotiate instead.\n\tExtension func(httphead.Option) bool\n\n\t// Negotiate is the callback that is used to negotiate extensions from\n\t// the client's offer. If this field is set, then the returned non-zero\n\t// extensions are sent to the client as accepted extensions in the\n\t// response.\n\t//\n\t// The argument is only valid until the Negotiate callback returns.\n\t//\n\t// If returned error is non-nil then connection is rejected and response is\n\t// sent with appropriate HTTP error code and body set to error message.\n\t//\n\t// RejectConnectionError could be used to get more control on response.\n\tNegotiate func(httphead.Option) (httphead.Option, error)\n}\n\n// Upgrade upgrades http connection to the websocket connection.\n//\n// It hijacks net.Conn from w and returns received net.Conn and\n// bufio.ReadWriter. On successful handshake it returns Handshake struct\n// describing handshake info.\nfunc (u HTTPUpgrader) Upgrade(r *http.Request, w http.ResponseWriter) (conn net.Conn, rw *bufio.ReadWriter, hs Handshake, err error) {\n\t// Hijack connection first to get the ability to write rejection errors the\n\t// same way as in Upgrader.\n\tconn, rw, err = hijack(w)\n\tif err != nil {\n\t\thttpError(w, err.Error(), http.StatusInternalServerError)\n\t\treturn conn, rw, hs, err\n\t}\n\n\t// See https://tools.ietf.org/html/rfc6455#section-4.1\n\t// The method of the request MUST be GET, and the HTTP version MUST be at least 1.1.\n\tvar nonce string\n\tif r.Method != http.MethodGet {\n\t\terr = ErrHandshakeBadMethod\n\t} else if r.ProtoMajor < 1 || (r.ProtoMajor == 1 && r.ProtoMinor < 1) {\n\t\terr = ErrHandshakeBadProtocol\n\t} else if r.Host == \"\" {\n\t\terr = ErrHandshakeBadHost\n\t} else if u := httpGetHeader(r.Header, headerUpgradeCanonical); u != \"websocket\" && !strings.EqualFold(u, \"websocket\") {\n\t\terr = ErrHandshakeBadUpgrade\n\t} else if c := httpGetHeader(r.Header, headerConnectionCanonical); c != \"Upgrade\" && !strHasToken(c, \"upgrade\") {\n\t\terr = ErrHandshakeBadConnection\n\t} else if nonce = httpGetHeader(r.Header, headerSecKeyCanonical); len(nonce) != nonceSize {\n\t\terr = ErrHandshakeBadSecKey\n\t} else if v := httpGetHeader(r.Header, headerSecVersionCanonical); v != \"13\" {\n\t\t// According to RFC6455:\n\t\t//\n\t\t// If this version does not match a version understood by the server,\n\t\t// the server MUST abort the WebSocket handshake described in this\n\t\t// section and instead send an appropriate HTTP error code (such as 426\n\t\t// Upgrade Required) and a |Sec-WebSocket-Version| header field\n\t\t// indicating the version(s) the server is capable of understanding.\n\t\t//\n\t\t// So we branching here cause empty or not present version does not\n\t\t// meet the ABNF rules of RFC6455:\n\t\t//\n\t\t// version = DIGIT | (NZDIGIT DIGIT) |\n\t\t// (\"1\" DIGIT DIGIT) | (\"2\" DIGIT DIGIT)\n\t\t// ; Limited to 0-255 range, with no leading zeros\n\t\t//\n\t\t// That is, if version is really invalid â€“ we sent 426 status, if it\n\t\t// not present or empty â€“ it is 400.\n\t\tif v != \"\" {\n\t\t\terr = ErrHandshakeUpgradeRequired\n\t\t} else {\n\t\t\terr = ErrHandshakeBadSecVersion\n\t\t}\n\t}\n\tif check := u.Protocol; err == nil && check != nil {\n\t\tps := r.Header[headerSecProtocolCanonical]\n\t\tfor i := 0; i < len(ps) && err == nil && hs.Protocol == \"\"; i++ {\n\t\t\tvar ok bool\n\t\t\ths.Protocol, ok = strSelectProtocol(ps[i], check)\n\t\t\tif !ok {\n\t\t\t\terr = ErrMalformedRequest\n\t\t\t}\n\t\t}\n\t}\n\tif f := u.Negotiate; err == nil && f != nil {\n\t\tfor _, h := range r.Header[headerSecExtensionsCanonical] {\n\t\t\ths.Extensions, err = negotiateExtensions(strToBytes(h), hs.Extensions, f)\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\t// DEPRECATED path.\n\tif check := u.Extension; err == nil && check != nil && u.Negotiate == nil {\n\t\txs := r.Header[headerSecExtensionsCanonical]\n\t\tfor i := 0; i < len(xs) && err == nil; i++ {\n\t\t\tvar ok bool\n\t\t\ths.Extensions, ok = btsSelectExtensions(strToBytes(xs[i]), hs.Extensions, check)\n\t\t\tif !ok {\n\t\t\t\terr = ErrMalformedRequest\n\t\t\t}\n\t\t}\n\t}\n\n\t// Clear deadlines set by server.\n\tconn.SetDeadline(noDeadline)\n\tif t := u.Timeout; t != 0 {\n\t\tconn.SetWriteDeadline(time.Now().Add(t))\n\t\tdefer conn.SetWriteDeadline(noDeadline)\n\t}\n\n\tvar header handshakeHeader\n\tif h := u.Header; h != nil {\n\t\theader[0] = HandshakeHeaderHTTP(h)\n\t}\n\tif err == nil {\n\t\thttpWriteResponseUpgrade(rw.Writer, strToBytes(nonce), hs, header.WriteTo)\n\t\terr = rw.Writer.Flush()\n\t} else {\n\t\tvar code int\n\t\tif rej, ok := err.(*ConnectionRejectedError); ok {\n\t\t\tcode = rej.code\n\t\t\theader[1] = rej.header\n\t\t}\n\t\tif code == 0 {\n\t\t\tcode = http.StatusInternalServerError\n\t\t}\n\t\thttpWriteResponseError(rw.Writer, err, code, header.WriteTo)\n\t\t// Do not store Flush() error to not override already existing one.\n\t\t_ = rw.Writer.Flush()\n\t}\n\treturn conn, rw, hs, err\n}\n\n// Upgrader contains options for upgrading connection to websocket.\ntype Upgrader struct {\n\t// ReadBufferSize and WriteBufferSize is an I/O buffer sizes.\n\t// They used to read and write http data while upgrading to WebSocket.\n\t// Allocated buffers are pooled with sync.Pool to avoid extra allocations.\n\t//\n\t// If a size is zero then default value is used.\n\t//\n\t// Usually it is useful to set read buffer size bigger than write buffer\n\t// size because incoming request could contain long header values, such as\n\t// Cookie. Response, in other way, could be big only if user write multiple\n\t// custom headers. Usually response takes less than 256 bytes.\n\tReadBufferSize, WriteBufferSize int\n\n\t// Protocol is a select function that is used to select subprotocol\n\t// from list requested by client. If this field is set, then the first matched\n\t// protocol is sent to a client as negotiated.\n\t//\n\t// The argument is only valid until the callback returns.\n\tProtocol func([]byte) bool\n\n\t// ProtocolCustrom allow user to parse Sec-WebSocket-Protocol header manually.\n\t// Note that returned bytes must be valid until Upgrade returns.\n\t// If ProtocolCustom is set, it used instead of Protocol function.\n\tProtocolCustom func([]byte) (string, bool)\n\n\t// Extension is a select function that is used to select extensions\n\t// from list requested by client. If this field is set, then the all matched\n\t// extensions are sent to a client as negotiated.\n\t//\n\t// Note that Extension may be called multiple times and implementations\n\t// must track uniqueness of accepted extensions manually.\n\t//\n\t// The argument is only valid until the callback returns.\n\t//\n\t// According to the RFC6455 order of extensions passed by a client is\n\t// significant. That is, returning true from this function means that no\n\t// other extension with the same name should be checked because server\n\t// accepted the most preferable extension right now:\n\t// \"Note that the order of extensions is significant.  Any interactions between\n\t// multiple extensions MAY be defined in the documents defining the extensions.\n\t// In the absence of such definitions, the interpretation is that the header\n\t// fields listed by the client in its request represent a preference of the\n\t// header fields it wishes to use, with the first options listed being most\n\t// preferable.\"\n\t//\n\t// Deprecated: use Negotiate instead.\n\tExtension func(httphead.Option) bool\n\n\t// ExtensionCustom allow user to parse Sec-WebSocket-Extensions header\n\t// manually.\n\t//\n\t// If ExtensionCustom() decides to accept received extension, it must\n\t// append appropriate option to the given slice of httphead.Option.\n\t// It returns results of append() to the given slice and a flag that\n\t// reports whether given header value is wellformed or not.\n\t//\n\t// Note that ExtensionCustom may be called multiple times and\n\t// implementations must track uniqueness of accepted extensions manually.\n\t//\n\t// Note that returned options should be valid until Upgrade returns.\n\t// If ExtensionCustom is set, it used instead of Extension function.\n\tExtensionCustom func([]byte, []httphead.Option) ([]httphead.Option, bool)\n\n\t// Negotiate is the callback that is used to negotiate extensions from\n\t// the client's offer. If this field is set, then the returned non-zero\n\t// extensions are sent to the client as accepted extensions in the\n\t// response.\n\t//\n\t// The argument is only valid until the Negotiate callback returns.\n\t//\n\t// If returned error is non-nil then connection is rejected and response is\n\t// sent with appropriate HTTP error code and body set to error message.\n\t//\n\t// RejectConnectionError could be used to get more control on response.\n\tNegotiate func(httphead.Option) (httphead.Option, error)\n\n\t// Header is an optional HandshakeHeader instance that could be used to\n\t// write additional headers to the handshake response.\n\t//\n\t// It used instead of any key-value mappings to avoid allocations in user\n\t// land.\n\t//\n\t// Note that if present, it will be written in any result of handshake.\n\tHeader HandshakeHeader\n\n\t// OnRequest is a callback that will be called after request line\n\t// successful parsing.\n\t//\n\t// The arguments are only valid until the callback returns.\n\t//\n\t// If returned error is non-nil then connection is rejected and response is\n\t// sent with appropriate HTTP error code and body set to error message.\n\t//\n\t// RejectConnectionError could be used to get more control on response.\n\tOnRequest func(uri []byte) error\n\n\t// OnHost is a callback that will be called after \"Host\" header successful\n\t// parsing.\n\t//\n\t// It is separated from OnHeader callback because the Host header must be\n\t// present in each request since HTTP/1.1. Thus Host header is non-optional\n\t// and required for every WebSocket handshake.\n\t//\n\t// The arguments are only valid until the callback returns.\n\t//\n\t// If returned error is non-nil then connection is rejected and response is\n\t// sent with appropriate HTTP error code and body set to error message.\n\t//\n\t// RejectConnectionError could be used to get more control on response.\n\tOnHost func(host []byte) error\n\n\t// OnHeader is a callback that will be called after successful parsing of\n\t// header, that is not used during WebSocket handshake procedure. That is,\n\t// it will be called with non-websocket headers, which could be relevant\n\t// for application-level logic.\n\t//\n\t// The arguments are only valid until the callback returns.\n\t//\n\t// If returned error is non-nil then connection is rejected and response is\n\t// sent with appropriate HTTP error code and body set to error message.\n\t//\n\t// RejectConnectionError could be used to get more control on response.\n\tOnHeader func(key, value []byte) error\n\n\t// OnBeforeUpgrade is a callback that will be called before sending\n\t// successful upgrade response.\n\t//\n\t// Setting OnBeforeUpgrade allows user to make final application-level\n\t// checks and decide whether this connection is allowed to successfully\n\t// upgrade to WebSocket.\n\t//\n\t// It must return non-nil either HandshakeHeader or error and never both.\n\t//\n\t// If returned error is non-nil then connection is rejected and response is\n\t// sent with appropriate HTTP error code and body set to error message.\n\t//\n\t// RejectConnectionError could be used to get more control on response.\n\tOnBeforeUpgrade func() (header HandshakeHeader, err error)\n}\n\n// Upgrade zero-copy upgrades connection to WebSocket. It interprets given conn\n// as connection with incoming HTTP Upgrade request.\n//\n// It is a caller responsibility to manage i/o timeouts on conn.\n//\n// Non-nil error means that request for the WebSocket upgrade is invalid or\n// malformed and usually connection should be closed.\n// Even when error is non-nil Upgrade will write appropriate response into\n// connection in compliance with RFC.\nfunc (u Upgrader) Upgrade(conn io.ReadWriter) (hs Handshake, err error) {\n\t// headerSeen constants helps to report whether or not some header was seen\n\t// during reading request bytes.\n\tconst (\n\t\theaderSeenHost = 1 << iota\n\t\theaderSeenUpgrade\n\t\theaderSeenConnection\n\t\theaderSeenSecVersion\n\t\theaderSeenSecKey\n\n\t\t// headerSeenAll is the value that we expect to receive at the end of\n\t\t// headers read/parse loop.\n\t\theaderSeenAll = 0 |\n\t\t\theaderSeenHost |\n\t\t\theaderSeenUpgrade |\n\t\t\theaderSeenConnection |\n\t\t\theaderSeenSecVersion |\n\t\t\theaderSeenSecKey\n\t)\n\n\t// Prepare I/O buffers.\n\t// TODO(gobwas): make it configurable.\n\tbr := pbufio.GetReader(conn,\n\t\tnonZero(u.ReadBufferSize, DefaultServerReadBufferSize),\n\t)\n\tbw := pbufio.GetWriter(conn,\n\t\tnonZero(u.WriteBufferSize, DefaultServerWriteBufferSize),\n\t)\n\tdefer func() {\n\t\tpbufio.PutReader(br)\n\t\tpbufio.PutWriter(bw)\n\t}()\n\n\t// Read HTTP request line like \"GET /ws HTTP/1.1\".\n\trl, err := readLine(br)\n\tif err != nil {\n\t\treturn hs, err\n\t}\n\t// Parse request line data like HTTP version, uri and method.\n\treq, err := httpParseRequestLine(rl)\n\tif err != nil {\n\t\treturn hs, err\n\t}\n\n\t// Prepare stack-based handshake header list.\n\theader := handshakeHeader{\n\t\t0: u.Header,\n\t}\n\n\t// Parse and check HTTP request.\n\t// As RFC6455 says:\n\t//   The client's opening handshake consists of the following parts. If the\n\t//   server, while reading the handshake, finds that the client did not\n\t//   send a handshake that matches the description below (note that as per\n\t//   [RFC2616], the order of the header fields is not important), including\n\t//   but not limited to any violations of the ABNF grammar specified for\n\t//   the components of the handshake, the server MUST stop processing the\n\t//   client's handshake and return an HTTP response with an appropriate\n\t//   error code (such as 400 Bad Request).\n\t//\n\t// See https://tools.ietf.org/html/rfc6455#section-4.2.1\n\n\t// An HTTP/1.1 or higher GET request, including a \"Request-URI\".\n\t//\n\t// Even if RFC says \"1.1 or higher\" without mentioning the part of the\n\t// version, we apply it only to minor part.\n\tswitch {\n\tcase req.major != 1 || req.minor < 1:\n\t\t// Abort processing the whole request because we do not even know how\n\t\t// to actually parse it.\n\t\terr = ErrHandshakeBadProtocol\n\n\tcase btsToString(req.method) != http.MethodGet:\n\t\terr = ErrHandshakeBadMethod\n\n\tdefault:\n\t\tif onRequest := u.OnRequest; onRequest != nil {\n\t\t\terr = onRequest(req.uri)\n\t\t}\n\t}\n\t// Start headers read/parse loop.\n\tvar (\n\t\t// headerSeen reports which header was seen by setting corresponding\n\t\t// bit on.\n\t\theaderSeen byte\n\n\t\tnonce = make([]byte, nonceSize)\n\t)\n\tfor err == nil {\n\t\tline, e := readLine(br)\n\t\tif e != nil {\n\t\t\treturn hs, e\n\t\t}\n\t\tif len(line) == 0 {\n\t\t\t// Blank line, no more lines to read.\n\t\t\tbreak\n\t\t}\n\n\t\tk, v, ok := httpParseHeaderLine(line)\n\t\tif !ok {\n\t\t\terr = ErrMalformedRequest\n\t\t\tbreak\n\t\t}\n\n\t\tswitch btsToString(k) {\n\t\tcase headerHostCanonical:\n\t\t\theaderSeen |= headerSeenHost\n\t\t\tif onHost := u.OnHost; onHost != nil {\n\t\t\t\terr = onHost(v)\n\t\t\t}\n\n\t\tcase headerUpgradeCanonical:\n\t\t\theaderSeen |= headerSeenUpgrade\n\t\t\tif !bytes.Equal(v, specHeaderValueUpgrade) && !bytes.EqualFold(v, specHeaderValueUpgrade) {\n\t\t\t\terr = ErrHandshakeBadUpgrade\n\t\t\t}\n\n\t\tcase headerConnectionCanonical:\n\t\t\theaderSeen |= headerSeenConnection\n\t\t\tif !bytes.Equal(v, specHeaderValueConnection) && !btsHasToken(v, specHeaderValueConnectionLower) {\n\t\t\t\terr = ErrHandshakeBadConnection\n\t\t\t}\n\n\t\tcase headerSecVersionCanonical:\n\t\t\theaderSeen |= headerSeenSecVersion\n\t\t\tif !bytes.Equal(v, specHeaderValueSecVersion) {\n\t\t\t\terr = ErrHandshakeUpgradeRequired\n\t\t\t}\n\n\t\tcase headerSecKeyCanonical:\n\t\t\theaderSeen |= headerSeenSecKey\n\t\t\tif len(v) != nonceSize {\n\t\t\t\terr = ErrHandshakeBadSecKey\n\t\t\t} else {\n\t\t\t\tcopy(nonce, v)\n\t\t\t}\n\n\t\tcase headerSecProtocolCanonical:\n\t\t\tif custom, check := u.ProtocolCustom, u.Protocol; hs.Protocol == \"\" && (custom != nil || check != nil) {\n\t\t\t\tvar ok bool\n\t\t\t\tif custom != nil {\n\t\t\t\t\ths.Protocol, ok = custom(v)\n\t\t\t\t} else {\n\t\t\t\t\ths.Protocol, ok = btsSelectProtocol(v, check)\n\t\t\t\t}\n\t\t\t\tif !ok {\n\t\t\t\t\terr = ErrMalformedRequest\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase headerSecExtensionsCanonical:\n\t\t\tif f := u.Negotiate; err == nil && f != nil {\n\t\t\t\ths.Extensions, err = negotiateExtensions(v, hs.Extensions, f)\n\t\t\t}\n\t\t\t// DEPRECATED path.\n\t\t\tif custom, check := u.ExtensionCustom, u.Extension; u.Negotiate == nil && (custom != nil || check != nil) {\n\t\t\t\tvar ok bool\n\t\t\t\tif custom != nil {\n\t\t\t\t\ths.Extensions, ok = custom(v, hs.Extensions)\n\t\t\t\t} else {\n\t\t\t\t\ths.Extensions, ok = btsSelectExtensions(v, hs.Extensions, check)\n\t\t\t\t}\n\t\t\t\tif !ok {\n\t\t\t\t\terr = ErrMalformedRequest\n\t\t\t\t}\n\t\t\t}\n\n\t\tdefault:\n\t\t\tif onHeader := u.OnHeader; onHeader != nil {\n\t\t\t\terr = onHeader(k, v)\n\t\t\t}\n\t\t}\n\t}\n\tswitch {\n\tcase err == nil && headerSeen != headerSeenAll:\n\t\tswitch {\n\t\tcase headerSeen&headerSeenHost == 0:\n\t\t\t// As RFC2616 says:\n\t\t\t//   A client MUST include a Host header field in all HTTP/1.1\n\t\t\t//   request messages. If the requested URI does not include an\n\t\t\t//   Internet host name for the service being requested, then the\n\t\t\t//   Host header field MUST be given with an empty value. An\n\t\t\t//   HTTP/1.1 proxy MUST ensure that any request message it\n\t\t\t//   forwards does contain an appropriate Host header field that\n\t\t\t//   identifies the service being requested by the proxy. All\n\t\t\t//   Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad\n\t\t\t//   Request) status code to any HTTP/1.1 request message which\n\t\t\t//   lacks a Host header field.\n\t\t\terr = ErrHandshakeBadHost\n\t\tcase headerSeen&headerSeenUpgrade == 0:\n\t\t\terr = ErrHandshakeBadUpgrade\n\t\tcase headerSeen&headerSeenConnection == 0:\n\t\t\terr = ErrHandshakeBadConnection\n\t\tcase headerSeen&headerSeenSecVersion == 0:\n\t\t\t// In case of empty or not present version we do not send 426 status,\n\t\t\t// because it does not meet the ABNF rules of RFC6455:\n\t\t\t//\n\t\t\t// version = DIGIT | (NZDIGIT DIGIT) |\n\t\t\t// (\"1\" DIGIT DIGIT) | (\"2\" DIGIT DIGIT)\n\t\t\t// ; Limited to 0-255 range, with no leading zeros\n\t\t\t//\n\t\t\t// That is, if version is really invalid â€“ we sent 426 status as above, if it\n\t\t\t// not present â€“ it is 400.\n\t\t\terr = ErrHandshakeBadSecVersion\n\t\tcase headerSeen&headerSeenSecKey == 0:\n\t\t\terr = ErrHandshakeBadSecKey\n\t\tdefault:\n\t\t\tpanic(\"unknown headers state\")\n\t\t}\n\n\tcase err == nil && u.OnBeforeUpgrade != nil:\n\t\theader[1], err = u.OnBeforeUpgrade()\n\t}\n\tif err != nil {\n\t\tvar code int\n\t\tif rej, ok := err.(*ConnectionRejectedError); ok {\n\t\t\tcode = rej.code\n\t\t\theader[1] = rej.header\n\t\t}\n\t\tif code == 0 {\n\t\t\tcode = http.StatusInternalServerError\n\t\t}\n\t\thttpWriteResponseError(bw, err, code, header.WriteTo)\n\t\t// Do not store Flush() error to not override already existing one.\n\t\t_ = bw.Flush()\n\t\treturn hs, err\n\t}\n\n\thttpWriteResponseUpgrade(bw, nonce, hs, header.WriteTo)\n\terr = bw.Flush()\n\n\treturn hs, err\n}\n\ntype handshakeHeader [2]HandshakeHeader\n\nfunc (hs handshakeHeader) WriteTo(w io.Writer) (n int64, err error) {\n\tfor i := 0; i < len(hs) && err == nil; i++ {\n\t\tif h := hs[i]; h != nil {\n\t\t\tvar m int64\n\t\t\tm, err = h.WriteTo(w)\n\t\t\tn += m\n\t\t}\n\t}\n\treturn n, err\n}\n"
        },
        {
          "name": "server_test.go",
          "type": "blob",
          "size": 21.021484375,
          "content": "package ws\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"math/rand\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/http/httputil\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"testing\"\n\n\t\"github.com/gobwas/httphead\"\n\t\"github.com/gobwas/pool/pbufio\"\n)\n\n// TODO(gobwas): upgradeGenericCase with methods like configureUpgrader,\n// configureHTTPUpgrader.\ntype upgradeCase struct {\n\tlabel string\n\n\tprotocol  func(string) bool\n\tnegotiate func(httphead.Option) (httphead.Option, error)\n\tonRequest func(u []byte) error\n\tonHost    func(h []byte) error\n\tonHeader  func(k, v []byte) error\n\n\tnonce        []byte\n\tremoveSecKey bool\n\tbadSecKey    bool\n\tsecKeyHeader string\n\n\treq *http.Request\n\tres *http.Response\n\ths  Handshake\n\terr error\n}\n\nvar upgradeCases = []upgradeCase{\n\t{\n\t\tlabel: \"base\",\n\t\tnonce: mustMakeNonce(),\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\theaderSecVersion: []string{\"13\"},\n\t\t}),\n\t\tres: mustMakeResponse(101, http.Header{\n\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t}),\n\t},\n\t{\n\t\tlabel:        \"base_canonical\",\n\t\tnonce:        mustMakeNonce(),\n\t\tsecKeyHeader: headerSecKeyCanonical,\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\theaderUpgrade:             []string{\"websocket\"},\n\t\t\theaderConnection:          []string{\"Upgrade\"},\n\t\t\theaderSecVersionCanonical: []string{\"13\"},\n\t\t}),\n\t\tres: mustMakeResponse(101, http.Header{\n\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t}),\n\t},\n\t{\n\t\tlabel:        \"lowercase_headers\",\n\t\tnonce:        mustMakeNonce(),\n\t\tsecKeyHeader: strings.ToLower(headerSecKey),\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\tstrings.ToLower(headerUpgrade):    []string{\"websocket\"},\n\t\t\tstrings.ToLower(headerConnection): []string{\"Upgrade\"},\n\t\t\tstrings.ToLower(headerSecVersion): []string{\"13\"},\n\t\t}),\n\t\tres: mustMakeResponse(101, http.Header{\n\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t}),\n\t},\n\t{\n\t\tlabel:    \"uppercase\",\n\t\tprotocol: func(sub string) bool { return true },\n\t\tnonce:    mustMakeNonce(),\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\theaderUpgrade:    []string{\"WEBSOCKET\"},\n\t\t\theaderConnection: []string{\"UPGRADE\"},\n\t\t\theaderSecVersion: []string{\"13\"},\n\t\t}),\n\t\tres: mustMakeResponse(101, http.Header{\n\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t}),\n\t},\n\t{\n\t\tlabel:    \"subproto\",\n\t\tprotocol: SelectFromSlice([]string{\"b\", \"d\"}),\n\t\tnonce:    mustMakeNonce(),\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\theaderUpgrade:     []string{\"websocket\"},\n\t\t\theaderConnection:  []string{\"Upgrade\"},\n\t\t\theaderSecVersion:  []string{\"13\"},\n\t\t\theaderSecProtocol: []string{\"a\", \"b\", \"c\", \"d\"},\n\t\t}),\n\t\tres: mustMakeResponse(101, http.Header{\n\t\t\theaderUpgrade:     []string{\"websocket\"},\n\t\t\theaderConnection:  []string{\"Upgrade\"},\n\t\t\theaderSecProtocol: []string{\"b\"},\n\t\t}),\n\t\ths: Handshake{Protocol: \"b\"},\n\t},\n\t{\n\t\tlabel:        \"subproto_lowercase_headers\",\n\t\tprotocol:     SelectFromSlice([]string{\"b\", \"d\"}),\n\t\tnonce:        mustMakeNonce(),\n\t\tsecKeyHeader: strings.ToLower(headerSecKey),\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\tstrings.ToLower(headerUpgrade):     []string{\"websocket\"},\n\t\t\tstrings.ToLower(headerConnection):  []string{\"Upgrade\"},\n\t\t\tstrings.ToLower(headerSecVersion):  []string{\"13\"},\n\t\t\tstrings.ToLower(headerSecProtocol): []string{\"a\", \"b\", \"c\", \"d\"},\n\t\t}),\n\t\tres: mustMakeResponse(101, http.Header{\n\t\t\theaderUpgrade:     []string{\"websocket\"},\n\t\t\theaderConnection:  []string{\"Upgrade\"},\n\t\t\theaderSecProtocol: []string{\"b\"},\n\t\t}),\n\t\ths: Handshake{Protocol: \"b\"},\n\t},\n\t{\n\t\tlabel:    \"subproto_comma\",\n\t\tprotocol: SelectFromSlice([]string{\"b\", \"d\"}),\n\t\tnonce:    mustMakeNonce(),\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\theaderUpgrade:     []string{\"websocket\"},\n\t\t\theaderConnection:  []string{\"Upgrade\"},\n\t\t\theaderSecVersion:  []string{\"13\"},\n\t\t\theaderSecProtocol: []string{\"a, b, c, d\"},\n\t\t}),\n\t\tres: mustMakeResponse(101, http.Header{\n\t\t\theaderUpgrade:     []string{\"websocket\"},\n\t\t\theaderConnection:  []string{\"Upgrade\"},\n\t\t\theaderSecProtocol: []string{\"b\"},\n\t\t}),\n\t\ths: Handshake{Protocol: \"b\"},\n\t},\n\t{\n\t\tnegotiate: func(opt httphead.Option) (ret httphead.Option, err error) {\n\t\t\tswitch string(opt.Name) {\n\t\t\tcase \"b\", \"d\":\n\t\t\t\treturn opt.Clone(), nil\n\t\t\tdefault:\n\t\t\t\treturn ret, nil\n\t\t\t}\n\t\t},\n\t\tnonce: mustMakeNonce(),\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\theaderUpgrade:       []string{\"websocket\"},\n\t\t\theaderConnection:    []string{\"Upgrade\"},\n\t\t\theaderSecVersion:    []string{\"13\"},\n\t\t\theaderSecExtensions: []string{\"a;foo=1\", \"b;bar=2\", \"c\", \"d;baz=3\"},\n\t\t}),\n\t\tres: mustMakeResponse(101, http.Header{\n\t\t\theaderUpgrade:       []string{\"websocket\"},\n\t\t\theaderConnection:    []string{\"Upgrade\"},\n\t\t\theaderSecExtensions: []string{\"b;bar=2,d;baz=3\"},\n\t\t}),\n\t\ths: Handshake{\n\t\t\tExtensions: []httphead.Option{\n\t\t\t\thttphead.NewOption(\"b\", map[string]string{\n\t\t\t\t\t\"bar\": \"2\",\n\t\t\t\t}),\n\t\t\t\thttphead.NewOption(\"d\", map[string]string{\n\t\t\t\t\t\"baz\": \"3\",\n\t\t\t\t}),\n\t\t\t},\n\t\t},\n\t},\n\n\t// Error cases.\n\t// ------------\n\n\t{\n\t\tlabel: \"bad_http_method\",\n\t\tnonce: mustMakeNonce(),\n\t\treq: mustMakeRequest(\"POST\", \"ws://example.org\", http.Header{\n\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\theaderSecVersion: []string{\"13\"},\n\t\t}),\n\t\tres: mustMakeErrResponse(405, ErrHandshakeBadMethod, nil),\n\t\terr: ErrHandshakeBadMethod,\n\t},\n\t{\n\t\tlabel: \"bad_http_proto\",\n\t\tnonce: mustMakeNonce(),\n\t\treq: setProto(1, 0, mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\theaderSecVersion: []string{\"13\"},\n\t\t})),\n\t\tres: mustMakeErrResponse(505, ErrHandshakeBadProtocol, nil),\n\t\terr: ErrHandshakeBadProtocol,\n\t},\n\t{\n\t\tlabel: \"bad_host\",\n\t\tnonce: mustMakeNonce(),\n\t\treq: withoutHeader(\"Host\", mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\theaderSecVersion: []string{\"13\"},\n\t\t})),\n\t\tres: mustMakeErrResponse(400, ErrHandshakeBadHost, nil),\n\t\terr: ErrHandshakeBadHost,\n\t},\n\t{\n\t\tlabel: \"bad_upgrade\",\n\t\tnonce: mustMakeNonce(),\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\theaderSecVersion: []string{\"13\"},\n\t\t}),\n\t\tres: mustMakeErrResponse(400, ErrHandshakeBadUpgrade, nil),\n\t\terr: ErrHandshakeBadUpgrade,\n\t},\n\t{\n\t\tlabel: \"bad_upgrade\",\n\t\tnonce: mustMakeNonce(),\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\t\"X-Custom-Header\": []string{\"value\"},\n\t\t\theaderConnection:  []string{\"Upgrade\"},\n\t\t\theaderSecVersion:  []string{\"13\"},\n\t\t}),\n\n\t\tonRequest: func([]byte) error { return nil },\n\t\tonHost:    func([]byte) error { return nil },\n\t\tonHeader:  func(k, v []byte) error { return nil },\n\n\t\tres: mustMakeErrResponse(400, ErrHandshakeBadUpgrade, nil),\n\t\terr: ErrHandshakeBadUpgrade,\n\t},\n\t{\n\t\tlabel: \"bad_upgrade\",\n\t\tnonce: mustMakeNonce(),\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\theaderUpgrade:    []string{\"not-websocket\"},\n\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\theaderSecVersion: []string{\"13\"},\n\t\t}),\n\t\tres: mustMakeErrResponse(400, ErrHandshakeBadUpgrade, nil),\n\t\terr: ErrHandshakeBadUpgrade,\n\t},\n\t{\n\t\tlabel: \"bad_connection\",\n\t\tnonce: mustMakeNonce(),\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\theaderSecVersion: []string{\"13\"},\n\t\t}),\n\t\tres: mustMakeErrResponse(400, ErrHandshakeBadConnection, nil),\n\t\terr: ErrHandshakeBadConnection,\n\t},\n\t{\n\t\tlabel: \"bad_connection\",\n\t\tnonce: mustMakeNonce(),\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\theaderConnection: []string{\"not-upgrade\"},\n\t\t\theaderSecVersion: []string{\"13\"},\n\t\t}),\n\t\tres: mustMakeErrResponse(400, ErrHandshakeBadConnection, nil),\n\t\terr: ErrHandshakeBadConnection,\n\t},\n\t{\n\t\tlabel: \"bad_sec_version_x\",\n\t\tnonce: mustMakeNonce(),\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t}),\n\t\tres: mustMakeErrResponse(400, ErrHandshakeBadSecVersion, nil),\n\t\terr: ErrHandshakeBadSecVersion,\n\t},\n\t{\n\t\tlabel: \"bad_sec_version\",\n\t\tnonce: mustMakeNonce(),\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\theaderConnection: []string{\"upgrade\"},\n\t\t\theaderSecVersion: []string{\"15\"},\n\t\t}),\n\t\tres: mustMakeErrResponse(426, ErrHandshakeBadSecVersion, http.Header{\n\t\t\theaderSecVersion: []string{\"13\"},\n\t\t}),\n\t\terr: ErrHandshakeUpgradeRequired,\n\t},\n\t{\n\t\tlabel:        \"bad_sec_key\",\n\t\tnonce:        mustMakeNonce(),\n\t\tremoveSecKey: true,\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\theaderSecVersion: []string{\"13\"},\n\t\t}),\n\t\tres: mustMakeErrResponse(400, ErrHandshakeBadSecKey, nil),\n\t\terr: ErrHandshakeBadSecKey,\n\t},\n\t{\n\t\tlabel:     \"bad_sec_key\",\n\t\tnonce:     mustMakeNonce(),\n\t\tbadSecKey: true,\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\theaderUpgrade:    []string{\"websocket\"},\n\t\t\theaderConnection: []string{\"Upgrade\"},\n\t\t\theaderSecVersion: []string{\"13\"},\n\t\t}),\n\t\tres: mustMakeErrResponse(400, ErrHandshakeBadSecKey, nil),\n\t\terr: ErrHandshakeBadSecKey,\n\t},\n\t{\n\t\tlabel: \"bad_ws_extension\",\n\t\tnonce: mustMakeNonce(),\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\theaderUpgrade:       []string{\"websocket\"},\n\t\t\theaderConnection:    []string{\"Upgrade\"},\n\t\t\theaderSecVersion:    []string{\"13\"},\n\t\t\theaderSecExtensions: []string{\"=[\"},\n\t\t}),\n\t\tnegotiate: func(opt httphead.Option) (ret httphead.Option, err error) {\n\t\t\treturn ret, nil\n\t\t},\n\t\tres: mustMakeErrResponse(400, ErrMalformedRequest, nil),\n\t\terr: ErrMalformedRequest,\n\t},\n\t{\n\t\tlabel: \"bad_subprotocol\",\n\t\tnonce: mustMakeNonce(),\n\t\treq: mustMakeRequest(\"GET\", \"ws://example.org\", http.Header{\n\t\t\theaderUpgrade:     []string{\"websocket\"},\n\t\t\theaderConnection:  []string{\"Upgrade\"},\n\t\t\theaderSecVersion:  []string{\"13\"},\n\t\t\theaderSecProtocol: []string{\"=[\"},\n\t\t}),\n\t\tprotocol: func(string) bool {\n\t\t\treturn false\n\t\t},\n\t\tres: mustMakeErrResponse(400, ErrMalformedRequest, nil),\n\t\terr: ErrMalformedRequest,\n\t},\n}\n\nfunc TestHTTPUpgrader(t *testing.T) {\n\tfor _, test := range upgradeCases {\n\t\tt.Run(test.label, func(t *testing.T) {\n\t\t\tif !test.removeSecKey {\n\t\t\t\tnonce := test.nonce\n\t\t\t\tif test.badSecKey {\n\t\t\t\t\tnonce = nonce[:nonceSize-1]\n\t\t\t\t}\n\t\t\t\tif test.secKeyHeader == \"\" {\n\t\t\t\t\ttest.secKeyHeader = headerSecKey\n\t\t\t\t}\n\t\t\t\ttest.req.Header[test.secKeyHeader] = []string{string(nonce)}\n\t\t\t}\n\t\t\tif test.err == nil {\n\t\t\t\ttest.res.Header[headerSecAccept] = []string{string(makeAccept(test.nonce))}\n\t\t\t}\n\n\t\t\t// Need to emulate http server read request for truth test.\n\t\t\t//\n\t\t\t// We use dumpRequest here because test.req.Write is always send\n\t\t\t// http/1.1 proto version, that does not fits all our testing\n\t\t\t// cases.\n\t\t\treqBytes := dumpRequest(test.req)\n\t\t\treq, err := http.ReadRequest(bufio.NewReader(bytes.NewReader(reqBytes)))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tres := newRecorder()\n\n\t\t\tu := HTTPUpgrader{\n\t\t\t\tProtocol:  test.protocol,\n\t\t\t\tNegotiate: test.negotiate,\n\t\t\t}\n\t\t\t_, _, hs, err := u.Upgrade(req, res)\n\t\t\tif test.err != err {\n\t\t\t\tt.Fatalf(\n\t\t\t\t\t\"expected error to be '%v', got '%v';\\non request:\\n====\\n%s\\n====\",\n\t\t\t\t\ttest.err, err, dumpRequest(req),\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tactRespBts := sortHeaders(res.Bytes())\n\t\t\texpRespBts := sortHeaders(dumpResponse(test.res))\n\t\t\tif !bytes.Equal(actRespBts, expRespBts) {\n\t\t\t\tt.Fatalf(\n\t\t\t\t\t\"unexpected http response:\\n---- act:\\n%s\\n---- want:\\n%s\\n==== on request:\\n%s\\n====\",\n\t\t\t\t\tactRespBts, expRespBts, dumpRequest(test.req),\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tif act, exp := hs.Protocol, test.hs.Protocol; act != exp {\n\t\t\t\tt.Errorf(\"handshake protocol is %q want %q\", act, exp)\n\t\t\t}\n\t\t\tif act, exp := len(hs.Extensions), len(test.hs.Extensions); act != exp {\n\t\t\t\tt.Errorf(\"handshake got %d extensions; want %d\", act, exp)\n\t\t\t} else {\n\t\t\t\tfor i := 0; i < act; i++ {\n\t\t\t\t\tif act, exp := hs.Extensions[i], test.hs.Extensions[i]; !act.Equal(exp) {\n\t\t\t\t\t\tt.Errorf(\"handshake %d-th extension is %s; want %s\", i, act, exp)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUpgrader(t *testing.T) {\n\tfor _, test := range upgradeCases {\n\t\tt.Run(test.label, func(t *testing.T) {\n\t\t\tif !test.removeSecKey {\n\t\t\t\tnonce := test.nonce[:]\n\t\t\t\tif test.badSecKey {\n\t\t\t\t\tnonce = nonce[:nonceSize-1]\n\t\t\t\t}\n\t\t\t\ttest.req.Header[headerSecKey] = []string{string(nonce)}\n\t\t\t}\n\t\t\tif test.err == nil {\n\t\t\t\ttest.res.Header[headerSecAccept] = []string{string(makeAccept(test.nonce))}\n\t\t\t}\n\n\t\t\tu := Upgrader{\n\t\t\t\tProtocol: func(p []byte) bool {\n\t\t\t\t\treturn test.protocol(string(p))\n\t\t\t\t},\n\t\t\t\tNegotiate: test.negotiate,\n\t\t\t\tOnHeader:  test.onHeader,\n\t\t\t\tOnRequest: test.onRequest,\n\t\t\t}\n\n\t\t\t// We use dumpRequest here because test.req.Write is always send\n\t\t\t// http/1.1 proto version, that does not fits all our testing\n\t\t\t// cases.\n\t\t\treqBytes := dumpRequest(test.req)\n\t\t\tconn := bytes.NewBuffer(reqBytes)\n\n\t\t\ths, err := u.Upgrade(conn)\n\t\t\tif test.err != err {\n\t\t\t\tt.Fatalf(\"expected error to be '%v', got '%v'\", test.err, err)\n\t\t\t}\n\n\t\t\tactRespBts := sortHeaders(conn.Bytes())\n\t\t\texpRespBts := sortHeaders(dumpResponse(test.res))\n\t\t\tif !bytes.Equal(actRespBts, expRespBts) {\n\t\t\t\tt.Fatalf(\n\t\t\t\t\t\"unexpected http response:\\n---- act:\\n%s\\n---- want:\\n%s\\n==== on request:\\n%s\\n====\",\n\t\t\t\t\tactRespBts, expRespBts, dumpRequest(test.req),\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tif act, exp := hs.Protocol, test.hs.Protocol; act != exp {\n\t\t\t\tt.Errorf(\"handshake protocol is %q want %q\", act, exp)\n\t\t\t}\n\t\t\tif act, exp := len(hs.Extensions), len(test.hs.Extensions); act != exp {\n\t\t\t\tt.Errorf(\"handshake got %d extensions; want %d\", act, exp)\n\t\t\t} else {\n\t\t\t\tfor i := 0; i < act; i++ {\n\t\t\t\t\tif act, exp := hs.Extensions[i], test.hs.Extensions[i]; !act.Equal(exp) {\n\t\t\t\t\t\tt.Errorf(\"handshake %d-th extension is %s; want %s\", i, act, exp)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkHTTPUpgrader(b *testing.B) {\n\tfor _, bench := range upgradeCases {\n\t\tbench.req.Header.Set(headerSecKey, string(bench.nonce[:]))\n\n\t\tu := HTTPUpgrader{\n\t\t\tProtocol:  bench.protocol,\n\t\t\tNegotiate: bench.negotiate,\n\t\t}\n\n\t\tb.Run(bench.label, func(b *testing.B) {\n\t\t\tres := make([]http.ResponseWriter, b.N)\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tres[i] = newRecorder()\n\t\t\t}\n\n\t\t\ti := new(int64)\n\n\t\t\tb.ResetTimer()\n\t\t\tb.ReportAllocs()\n\t\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\t\tfor pb.Next() {\n\t\t\t\t\tw := res[atomic.AddInt64(i, 1)-1]\n\t\t\t\t\tu.Upgrade(bench.req, w)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc BenchmarkUpgrader(b *testing.B) {\n\tfor _, bench := range upgradeCases {\n\t\tbench.req.Header.Set(headerSecKey, string(bench.nonce[:]))\n\n\t\tu := Upgrader{\n\t\t\tProtocol: func(p []byte) bool {\n\t\t\t\treturn bench.protocol(btsToString(p))\n\t\t\t},\n\t\t\tNegotiate: bench.negotiate,\n\t\t}\n\n\t\treqBytes := dumpRequest(bench.req)\n\n\t\ttype benchReadWriter struct {\n\t\t\tio.Reader\n\t\t\tio.Writer\n\t\t}\n\n\t\tb.Run(bench.label, func(b *testing.B) {\n\t\t\tconn := make([]io.ReadWriter, b.N)\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tconn[i] = benchReadWriter{bytes.NewReader(reqBytes), ioutil.Discard}\n\t\t\t}\n\n\t\t\ti := new(int64)\n\n\t\t\tb.ResetTimer()\n\t\t\tb.ReportAllocs()\n\t\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\t\tfor pb.Next() {\n\t\t\t\t\tc := conn[atomic.AddInt64(i, 1)-1]\n\t\t\t\t\tu.Upgrade(c)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestHttpStrSelectProtocol(t *testing.T) {\n\tfor i, test := range []struct {\n\t\theader string\n\t}{\n\t\t{\"jsonrpc, soap, grpc\"},\n\t} {\n\t\tt.Run(fmt.Sprintf(\"#%d\", i), func(t *testing.T) {\n\t\t\texp := strings.Split(test.header, \",\")\n\t\t\tfor i, p := range exp {\n\t\t\t\texp[i] = strings.TrimSpace(p)\n\t\t\t}\n\n\t\t\tvar calls []string\n\t\t\tstrSelectProtocol(test.header, func(s string) bool {\n\t\t\t\tcalls = append(calls, s)\n\t\t\t\treturn false\n\t\t\t})\n\n\t\t\tif !reflect.DeepEqual(calls, exp) {\n\t\t\t\tt.Errorf(\"selectProtocol(%q, fn); called fn with %v; want %v\", test.header, calls, exp)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkSelectProtocol(b *testing.B) {\n\tfor _, bench := range []struct {\n\t\tlabel     string\n\t\theader    string\n\t\tacceptStr func(string) bool\n\t\tacceptBts func([]byte) bool\n\t}{\n\t\t{\n\t\t\tlabel:  \"never accept\",\n\t\t\theader: \"jsonrpc, soap, grpc\",\n\t\t\tacceptStr: func(s string) bool {\n\t\t\t\treturn len(s)%2 == 2 // never ok\n\t\t\t},\n\t\t\tacceptBts: func(v []byte) bool {\n\t\t\t\treturn len(v)%2 == 2 // never ok\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tlabel:     \"from slice\",\n\t\t\theader:    \"a, b, c, d, e, f, g\",\n\t\t\tacceptStr: SelectFromSlice([]string{\"g\", \"f\", \"e\", \"d\"}),\n\t\t},\n\t\t{\n\t\t\tlabel:     \"uniq 1024 from slise\",\n\t\t\theader:    strings.Join(randProtocols(1024, 16), \", \"),\n\t\t\tacceptStr: SelectFromSlice(randProtocols(1024, 17)),\n\t\t},\n\t} {\n\t\tb.Run(fmt.Sprintf(\"String/%s\", bench.label), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tstrSelectProtocol(bench.header, bench.acceptStr)\n\t\t\t}\n\t\t})\n\t\tif bench.acceptBts != nil {\n\t\t\tb.Run(fmt.Sprintf(\"Bytes/%s\", bench.label), func(b *testing.B) {\n\t\t\t\th := []byte(bench.header)\n\t\t\t\tb.StartTimer()\n\n\t\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t\tbtsSelectProtocol(h, bench.acceptBts)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc randProtocols(n, m int) []string {\n\tret := make([]string, n)\n\tbts := make([]byte, m)\n\tuniq := map[string]bool{}\n\tfor i := 0; i < n; i++ {\n\t\tfor {\n\t\t\tfor j := 0; j < m; j++ {\n\t\t\t\tbts[j] = byte(rand.Intn('x'-'a') + 'a')\n\t\t\t}\n\t\t\tstr := string(bts)\n\t\t\tif _, has := uniq[str]; !has {\n\t\t\t\tret[i] = str\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn ret\n}\n\nfunc dumpRequest(req *http.Request) []byte {\n\tbts, err := httputil.DumpRequest(req, true)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn bts\n}\n\nfunc dumpResponse(res *http.Response) []byte {\n\tif !res.Close {\n\t\tfor _, v := range res.Header[headerConnection] {\n\t\t\tif v == \"close\" {\n\t\t\t\tres.Close = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tbts, err := httputil.DumpResponse(res, true)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif !res.Close {\n\t\tbts = bytes.ReplaceAll(bts, []byte(\"Connection: close\\r\\n\"), nil)\n\t}\n\n\treturn bts\n}\n\ntype headersBytes [][]byte\n\nfunc (h headersBytes) Len() int           { return len(h) }\nfunc (h headersBytes) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\nfunc (h headersBytes) Less(i, j int) bool { return bytes.Compare(h[i], h[j]) == -1 }\n\nfunc maskHeader(bts []byte, key, mask string) []byte {\n\tlines := bytes.Split(bts, []byte(\"\\r\\n\"))\n\tfor i, line := range lines {\n\t\tpair := bytes.Split(line, []byte(\": \"))\n\t\tif string(pair[0]) == key {\n\t\t\tlines[i] = []byte(key + \": \" + mask)\n\t\t}\n\t}\n\treturn bytes.Join(lines, []byte(\"\\r\\n\"))\n}\n\nfunc sortHeaders(bts []byte) []byte {\n\tlines := bytes.Split(bts, []byte(\"\\r\\n\"))\n\tif len(lines) <= 1 {\n\t\treturn bts\n\t}\n\tsort.Sort(headersBytes(lines[1 : len(lines)-2]))\n\treturn bytes.Join(lines, []byte(\"\\r\\n\"))\n}\n\ntype recorder struct {\n\t*httptest.ResponseRecorder\n\thijacked bool\n\tconn     func(*bytes.Buffer) net.Conn\n}\n\nfunc newRecorder() *recorder {\n\treturn &recorder{\n\t\tResponseRecorder: httptest.NewRecorder(),\n\t}\n}\n\nfunc (r *recorder) Bytes() []byte {\n\tif r.hijacked {\n\t\treturn r.ResponseRecorder.Body.Bytes()\n\t}\n\n\t// TODO(gobwas): remove this when support for go 1.7 will end.\n\tresp := r.Result()\n\tcs := strings.TrimSpace(resp.Header.Get(\"Content-Length\"))\n\tif n, err := strconv.ParseInt(cs, 10, 64); err == nil {\n\t\tresp.ContentLength = n\n\t} else {\n\t\tresp.ContentLength = -1\n\t}\n\n\treturn dumpResponse(resp)\n}\n\nfunc (r *recorder) Hijack() (conn net.Conn, brw *bufio.ReadWriter, err error) {\n\tif r.hijacked {\n\t\terr = fmt.Errorf(\"already hijacked\")\n\t\treturn conn, brw, err\n\t}\n\n\tr.hijacked = true\n\n\tvar buf *bytes.Buffer\n\tif r.ResponseRecorder != nil {\n\t\tbuf = r.ResponseRecorder.Body\n\t}\n\n\tif r.conn != nil {\n\t\tconn = r.conn(buf)\n\t} else {\n\t\tconn = stubConn{\n\t\t\tread:  buf.Read,\n\t\t\twrite: buf.Write,\n\t\t\tclose: func() error { return nil },\n\t\t}\n\t}\n\n\tbr := pbufio.GetReader(conn, DefaultClientReadBufferSize)\n\tbw := pbufio.GetWriter(conn, DefaultClientWriteBufferSize)\n\n\tbrw = bufio.NewReadWriter(br, bw)\n\n\treturn conn, brw, err\n}\n\nfunc mustMakeRequest(method, url string, headers http.Header) *http.Request {\n\treq, err := http.NewRequest(method, url, http.NoBody)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treq.Header = headers\n\treturn req\n}\n\nfunc setProto(major, minor int, req *http.Request) *http.Request {\n\treq.ProtoMajor = major\n\treq.ProtoMinor = minor\n\treturn req\n}\n\nfunc withoutHeader(header string, req *http.Request) *http.Request {\n\tif strings.EqualFold(header, \"Host\") {\n\t\treq.URL.Host = \"\"\n\t\treq.Host = \"\"\n\t} else {\n\t\tdelete(req.Header, header)\n\t}\n\treturn req\n}\n\nfunc mustMakeResponse(code int, headers http.Header) *http.Response {\n\tres := &http.Response{\n\t\tStatusCode:    code,\n\t\tStatus:        http.StatusText(code),\n\t\tHeader:        headers,\n\t\tProtoMajor:    1,\n\t\tProtoMinor:    1,\n\t\tContentLength: -1,\n\t}\n\treturn res\n}\n\nfunc mustMakeErrResponse(code int, err error, headers http.Header) *http.Response {\n\t// Body text.\n\tbody := err.Error()\n\n\tres := &http.Response{\n\t\tStatusCode: code,\n\t\tStatus:     http.StatusText(code),\n\t\tHeader: http.Header{\n\t\t\t\"Content-Type\": []string{\"text/plain; charset=utf-8\"},\n\t\t},\n\t\tProtoMajor:    1,\n\t\tProtoMinor:    1,\n\t\tContentLength: int64(len(body)),\n\t}\n\tres.Body = ioutil.NopCloser(\n\t\tstrings.NewReader(body),\n\t)\n\tfor k, v := range headers {\n\t\tres.Header[k] = v\n\t}\n\treturn res\n}\n\nfunc mustMakeNonce() (ret []byte) {\n\tret = make([]byte, nonceSize)\n\tinitNonce(ret)\n\treturn ret\n}\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 4.361328125,
          "content": "package ws\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\n\t\"github.com/gobwas/httphead\"\n)\n\n// SelectFromSlice creates accept function that could be used as Protocol/Extension\n// select during upgrade.\nfunc SelectFromSlice(accept []string) func(string) bool {\n\tif len(accept) > 16 {\n\t\tmp := make(map[string]struct{}, len(accept))\n\t\tfor _, p := range accept {\n\t\t\tmp[p] = struct{}{}\n\t\t}\n\t\treturn func(p string) bool {\n\t\t\t_, ok := mp[p]\n\t\t\treturn ok\n\t\t}\n\t}\n\treturn func(p string) bool {\n\t\tfor _, ok := range accept {\n\t\t\tif p == ok {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n}\n\n// SelectEqual creates accept function that could be used as Protocol/Extension\n// select during upgrade.\nfunc SelectEqual(v string) func(string) bool {\n\treturn func(p string) bool {\n\t\treturn v == p\n\t}\n}\n\n// asciiToInt converts bytes to int.\nfunc asciiToInt(bts []byte) (ret int, err error) {\n\t// ASCII numbers all start with the high-order bits 0011.\n\t// If you see that, and the next bits are 0-9 (0000 - 1001) you can grab those\n\t// bits and interpret them directly as an integer.\n\tvar n int\n\tif n = len(bts); n < 1 {\n\t\treturn 0, fmt.Errorf(\"converting empty bytes to int\")\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tif bts[i]&0xf0 != 0x30 {\n\t\t\treturn 0, fmt.Errorf(\"%s is not a numeric character\", string(bts[i]))\n\t\t}\n\t\tret += int(bts[i]&0xf) * pow(10, n-i-1)\n\t}\n\treturn ret, nil\n}\n\n// pow for integers implementation.\n// See Donald Knuth, The Art of Computer Programming, Volume 2, Section 4.6.3.\nfunc pow(a, b int) int {\n\tp := 1\n\tfor b > 0 {\n\t\tif b&1 != 0 {\n\t\t\tp *= a\n\t\t}\n\t\tb >>= 1\n\t\ta *= a\n\t}\n\treturn p\n}\n\nfunc bsplit3(bts []byte, sep byte) (b1, b2, b3 []byte) {\n\ta := bytes.IndexByte(bts, sep)\n\tb := bytes.IndexByte(bts[a+1:], sep)\n\tif a == -1 || b == -1 {\n\t\treturn bts, nil, nil\n\t}\n\tb += a + 1\n\treturn bts[:a], bts[a+1 : b], bts[b+1:]\n}\n\nfunc btrim(bts []byte) []byte {\n\tvar i, j int\n\tfor i = 0; i < len(bts) && (bts[i] == ' ' || bts[i] == '\\t'); {\n\t\ti++\n\t}\n\tfor j = len(bts); j > i && (bts[j-1] == ' ' || bts[j-1] == '\\t'); {\n\t\tj--\n\t}\n\treturn bts[i:j]\n}\n\nfunc strHasToken(header, token string) (has bool) {\n\treturn btsHasToken(strToBytes(header), strToBytes(token))\n}\n\nfunc btsHasToken(header, token []byte) (has bool) {\n\thttphead.ScanTokens(header, func(v []byte) bool {\n\t\thas = bytes.EqualFold(v, token)\n\t\treturn !has\n\t})\n\treturn has\n}\n\nconst (\n\ttoLower  = 'a' - 'A'      // for use with OR.\n\ttoUpper  = ^byte(toLower) // for use with AND.\n\ttoLower8 = uint64(toLower) |\n\t\tuint64(toLower)<<8 |\n\t\tuint64(toLower)<<16 |\n\t\tuint64(toLower)<<24 |\n\t\tuint64(toLower)<<32 |\n\t\tuint64(toLower)<<40 |\n\t\tuint64(toLower)<<48 |\n\t\tuint64(toLower)<<56\n)\n\n// Algorithm below is like standard textproto/CanonicalMIMEHeaderKey, except\n// that it operates with slice of bytes and modifies it inplace without copying.\nfunc canonicalizeHeaderKey(k []byte) {\n\tupper := true\n\tfor i, c := range k {\n\t\tif upper && 'a' <= c && c <= 'z' {\n\t\t\tk[i] &= toUpper\n\t\t} else if !upper && 'A' <= c && c <= 'Z' {\n\t\t\tk[i] |= toLower\n\t\t}\n\t\tupper = c == '-'\n\t}\n}\n\n// readLine reads line from br. It reads until '\\n' and returns bytes without\n// '\\n' or '\\r\\n' at the end.\n// It returns err if and only if line does not end in '\\n'. Note that read\n// bytes returned in any case of error.\n//\n// It is much like the textproto/Reader.ReadLine() except the thing that it\n// returns raw bytes, instead of string. That is, it avoids copying bytes read\n// from br.\n//\n// textproto/Reader.ReadLineBytes() is also makes copy of resulting bytes to be\n// safe with future I/O operations on br.\n//\n// We could control I/O operations on br and do not need to make additional\n// copy for safety.\n//\n// NOTE: it may return copied flag to notify that returned buffer is safe to\n// use.\nfunc readLine(br *bufio.Reader) ([]byte, error) {\n\tvar line []byte\n\tfor {\n\t\tbts, err := br.ReadSlice('\\n')\n\t\tif err == bufio.ErrBufferFull {\n\t\t\t// Copy bytes because next read will discard them.\n\t\t\tline = append(line, bts...)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Avoid copy of single read.\n\t\tif line == nil {\n\t\t\tline = bts\n\t\t} else {\n\t\t\tline = append(line, bts...)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn line, err\n\t\t}\n\n\t\t// Size of line is at least 1.\n\t\t// In other case bufio.ReadSlice() returns error.\n\t\tn := len(line)\n\n\t\t// Cut '\\n' or '\\r\\n'.\n\t\tif n > 1 && line[n-2] == '\\r' {\n\t\t\tline = line[:n-2]\n\t\t} else {\n\t\t\tline = line[:n-1]\n\t\t}\n\n\t\treturn line, nil\n\t}\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc nonZero(a, b int) int {\n\tif a != 0 {\n\t\treturn a\n\t}\n\treturn b\n}\n"
        },
        {
          "name": "util_purego.go",
          "type": "blob",
          "size": 0.17578125,
          "content": "//go:build purego\n// +build purego\n\npackage ws\n\nfunc strToBytes(str string) (bts []byte) {\n\treturn []byte(str)\n}\n\nfunc btsToString(bts []byte) (str string) {\n\treturn string(bts)\n}\n"
        },
        {
          "name": "util_test.go",
          "type": "blob",
          "size": 9.154296875,
          "content": "package ws\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/textproto\"\n\t\"reflect\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar readLineCases = []struct {\n\tlabel   string\n\tin      string\n\tline    []byte\n\terr     error\n\tbufSize int\n}{\n\t{\n\t\tlabel:   \"simple\",\n\t\tin:      \"hello, world!\",\n\t\tline:    []byte(\"hello, world!\"),\n\t\terr:     io.EOF,\n\t\tbufSize: 1024,\n\t},\n\t{\n\t\tlabel:   \"simple\",\n\t\tin:      \"hello, world!\\r\\n\",\n\t\tline:    []byte(\"hello, world!\"),\n\t\tbufSize: 1024,\n\t},\n\t{\n\t\tlabel:   \"simple\",\n\t\tin:      \"hello, world!\\n\",\n\t\tline:    []byte(\"hello, world!\"),\n\t\tbufSize: 1024,\n\t},\n\t{\n\t\t// The case where \"\\r\\n\" straddles the buffer.\n\t\tlabel:   \"straddle\",\n\t\tin:      \"hello, world!!!\\r\\n...\",\n\t\tline:    []byte(\"hello, world!!!\"),\n\t\tbufSize: 16,\n\t},\n\t{\n\t\tlabel:   \"chunked\",\n\t\tin:      \"hello, world! this is a long long line!\",\n\t\tline:    []byte(\"hello, world! this is a long long line!\"),\n\t\terr:     io.EOF,\n\t\tbufSize: 16,\n\t},\n\t{\n\t\tlabel:   \"chunked\",\n\t\tin:      \"hello, world! this is a long long line!\\r\\n\",\n\t\tline:    []byte(\"hello, world! this is a long long line!\"),\n\t\tbufSize: 16,\n\t},\n}\n\nfunc TestReadLine(t *testing.T) {\n\tfor _, test := range readLineCases {\n\t\tt.Run(test.label, func(t *testing.T) {\n\t\t\tbr := bufio.NewReaderSize(strings.NewReader(test.in), test.bufSize)\n\t\t\tbts, err := readLine(br)\n\t\t\tif err != test.err {\n\t\t\t\tt.Errorf(\"unexpected error: %v; want %v\", err, test.err)\n\t\t\t}\n\t\t\tif act, exp := bts, test.line; !bytes.Equal(act, exp) {\n\t\t\t\tt.Errorf(\"readLine() result is %#q; want %#q\", act, exp)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkReadLine(b *testing.B) {\n\tfor _, test := range readLineCases {\n\t\tsr := strings.NewReader(test.in)\n\t\tbr := bufio.NewReaderSize(sr, test.bufSize)\n\t\tb.Run(test.label, func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_, _ = readLine(br)\n\t\t\t\tsr.Reset(test.in)\n\t\t\t\tbr.Reset(sr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUpgradeSlowClient(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tlim *limitWriter\n\t}{\n\t\t{\n\t\t\tlim: &limitWriter{\n\t\t\t\tBandwidth: 100,\n\t\t\t\tPeriod:    time.Second,\n\t\t\t\tBurst:     10,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tlim: &limitWriter{\n\t\t\t\tBandwidth: 100,\n\t\t\t\tPeriod:    time.Second,\n\t\t\t\tBurst:     100,\n\t\t\t},\n\t\t},\n\t} {\n\t\tt.Run(\"\", func(t *testing.T) {\n\t\t\tclient, server, err := socketPair()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\ttest.lim.Dest = server\n\n\t\t\theader := http.Header{\n\t\t\t\t\"X-Websocket-Test-1\": []string{\"Yes\"},\n\t\t\t\t\"X-Websocket-Test-2\": []string{\"Yes\"},\n\t\t\t\t\"X-Websocket-Test-3\": []string{\"Yes\"},\n\t\t\t\t\"X-Websocket-Test-4\": []string{\"Yes\"},\n\t\t\t}\n\t\t\td := Dialer{\n\t\t\t\tNetDial: func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\t\t\t\treturn connWithWriter{server, test.lim}, nil\n\t\t\t\t},\n\t\t\t\tHeader: HandshakeHeaderHTTP(header),\n\t\t\t}\n\t\t\tvar (\n\t\t\t\texpHost = \"example.org\"\n\t\t\t\texpURI  = \"/path/to/ws\"\n\t\t\t)\n\t\t\treceivedHeader := http.Header{}\n\t\t\tu := Upgrader{\n\t\t\t\tOnRequest: func(uri []byte) error {\n\t\t\t\t\tif u := string(uri); u != expURI {\n\t\t\t\t\t\tt.Errorf(\n\t\t\t\t\t\t\t\"unexpected URI in OnRequest() callback: %q; want %q\",\n\t\t\t\t\t\t\tu, expURI,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t\tOnHost: func(host []byte) error {\n\t\t\t\t\tif h := string(host); h != expHost {\n\t\t\t\t\t\tt.Errorf(\n\t\t\t\t\t\t\t\"unexpected host in OnRequest() callback: %q; want %q\",\n\t\t\t\t\t\t\th, expHost,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t\tOnHeader: func(key, value []byte) error {\n\t\t\t\t\treceivedHeader.Add(string(key), string(value))\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t}\n\t\t\tupgrade := make(chan error, 1)\n\t\t\tgo func() {\n\t\t\t\t_, err := u.Upgrade(client)\n\t\t\t\tupgrade <- err\n\t\t\t}()\n\n\t\t\t_, _, _, err = d.Dial(context.Background(), \"ws://\"+expHost+expURI)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Dial() error: %v\", err)\n\t\t\t}\n\n\t\t\tif err := <-upgrade; err != nil {\n\t\t\t\tt.Errorf(\"Upgrade() error: %v\", err)\n\t\t\t}\n\t\t\tfor key, values := range header {\n\t\t\t\tact, has := receivedHeader[key]\n\t\t\t\tif !has {\n\t\t\t\t\tt.Errorf(\"OnHeader() was not called with %q header key\", key)\n\t\t\t\t}\n\t\t\t\tif !reflect.DeepEqual(act, values) {\n\t\t\t\t\tt.Errorf(\"OnHeader(%q) different values: %v; want %v\", key, act, values)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype connWithWriter struct {\n\tnet.Conn\n\tw io.Writer\n}\n\nfunc (w connWithWriter) Write(p []byte) (int, error) {\n\treturn w.w.Write(p)\n}\n\ntype limitWriter struct {\n\tDest      io.Writer\n\tBandwidth int\n\tBurst     int\n\tPeriod    time.Duration\n\n\tmu      sync.Mutex\n\tcond    sync.Cond\n\tonce    sync.Once\n\tdone    chan struct{}\n\ttickets int\n}\n\nfunc (w *limitWriter) init() {\n\tw.once.Do(func() {\n\t\tw.cond.L = &w.mu\n\t\tw.done = make(chan struct{})\n\n\t\ttick := w.Period / time.Duration(w.Bandwidth)\n\t\tgo func() {\n\t\t\tt := time.NewTicker(tick)\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-t.C:\n\t\t\t\t\tw.mu.Lock()\n\t\t\t\t\tw.tickets = w.Burst\n\t\t\t\t\tw.mu.Unlock()\n\t\t\t\t\tw.cond.Signal()\n\t\t\t\tcase <-w.done:\n\t\t\t\t\tt.Stop()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t})\n}\n\nfunc (w *limitWriter) allow(n int) (allowed int) {\n\tw.init()\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\tfor w.tickets == 0 {\n\t\tw.cond.Wait()\n\t}\n\tif w.tickets < 0 {\n\t\treturn -1\n\t}\n\tallowed = min(w.tickets, n)\n\tw.tickets -= allowed\n\treturn allowed\n}\n\nfunc (w *limitWriter) Close() error {\n\tw.init()\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\tif w.tickets < 0 {\n\t\treturn nil\n\t}\n\tw.tickets = -1\n\tclose(w.done)\n\tw.cond.Broadcast()\n\treturn nil\n}\n\nfunc (w *limitWriter) Write(p []byte) (n int, err error) {\n\tw.init()\n\tfor n < len(p) {\n\t\tm := w.allow(len(p))\n\t\tif m < 0 {\n\t\t\treturn 0, io.ErrClosedPipe\n\t\t}\n\t\tif _, err := w.Dest.Write(p[n : n+m]); err != nil {\n\t\t\treturn n, err\n\t\t}\n\t\tn += m\n\t}\n\treturn n, nil\n}\n\nfunc socketPair() (client, server net.Conn, err error) {\n\tln, err := net.Listen(\"tcp\", \"localhost:\")\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\ttype connAndError struct {\n\t\tconn net.Conn\n\t\terr  error\n\t}\n\tdial := make(chan connAndError, 1)\n\tgo func() {\n\t\tconn, err := net.Dial(\"tcp\", ln.Addr().String())\n\t\tdial <- connAndError{conn, err}\n\t}()\n\tserver, err = ln.Accept()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tce := <-dial\n\tif err := ce.err; err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn ce.conn, server, nil\n}\n\nfunc TestHasToken(t *testing.T) {\n\tfor i, test := range []struct {\n\t\theader string\n\t\ttoken  string\n\t\texp    bool\n\t}{\n\t\t{\"Keep-Alive, Close, Upgrade\", \"upgrade\", true},\n\t\t{\"Keep-Alive, Close, upgrade, hello\", \"upgrade\", true},\n\t\t{\"Keep-Alive, Close,  hello\", \"upgrade\", false},\n\t} {\n\t\tt.Run(fmt.Sprintf(\"#%d\", i), func(t *testing.T) {\n\t\t\tif has := strHasToken(test.header, test.token); has != test.exp {\n\t\t\t\tt.Errorf(\"hasToken(%q, %q) = %v; want %v\", test.header, test.token, has, test.exp)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkHasToken(b *testing.B) {\n\tfor i, bench := range []struct {\n\t\theader string\n\t\ttoken  string\n\t}{\n\t\t{\"Keep-Alive, Close, Upgrade\", \"upgrade\"},\n\t\t{\"Keep-Alive, Close, upgrade, hello\", \"upgrade\"},\n\t\t{\"Keep-Alive, Close,  hello\", \"upgrade\"},\n\t} {\n\t\tb.Run(fmt.Sprintf(\"#%d\", i), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = strHasToken(bench.header, bench.token)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAsciiToInt(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tbts []byte\n\t\texp int\n\t\terr bool\n\t}{\n\t\t{[]byte{'0'}, 0, false},\n\t\t{[]byte{'1'}, 1, false},\n\t\t{[]byte(\"42\"), 42, false},\n\t\t{[]byte(\"420\"), 420, false},\n\t\t{[]byte(\"010050042\"), 10050042, false},\n\t} {\n\t\tt.Run(string(test.bts), func(t *testing.T) {\n\t\t\tact, err := asciiToInt(test.bts)\n\t\t\tif (test.err && err == nil) || (!test.err && err != nil) {\n\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif act != test.exp {\n\t\t\t\tt.Errorf(\"asciiToInt(%v) = %v; want %v\", test.bts, act, test.exp)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBtrim(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tbts []byte\n\t\texp []byte\n\t}{\n\t\t{[]byte(\"abc\"), []byte(\"abc\")},\n\t\t{[]byte(\" abc\"), []byte(\"abc\")},\n\t\t{[]byte(\"abc \"), []byte(\"abc\")},\n\t\t{[]byte(\" abc \"), []byte(\"abc\")},\n\t} {\n\t\tt.Run(string(test.bts), func(t *testing.T) {\n\t\t\tif act := btrim(test.bts); !bytes.Equal(act, test.exp) {\n\t\t\t\tt.Errorf(\"btrim(%v) = %v; want %v\", test.bts, act, test.exp)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBSplit3(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tbts  []byte\n\t\tsep  byte\n\t\texp1 []byte\n\t\texp2 []byte\n\t\texp3 []byte\n\t}{\n\t\t{[]byte(\"\"), ' ', []byte{}, nil, nil},\n\t\t{[]byte(\"GET / HTTP/1.1\"), ' ', []byte(\"GET\"), []byte(\"/\"), []byte(\"HTTP/1.1\")},\n\t} {\n\t\tt.Run(string(test.bts), func(t *testing.T) {\n\t\t\tb1, b2, b3 := bsplit3(test.bts, test.sep)\n\t\t\tif !bytes.Equal(b1, test.exp1) || !bytes.Equal(b2, test.exp2) || !bytes.Equal(b3, test.exp3) {\n\t\t\t\tt.Errorf(\n\t\t\t\t\t\"bsplit3(%q) = %q, %q, %q; want %q, %q, %q\",\n\t\t\t\t\tstring(test.bts), string(b1), string(b2), string(b3),\n\t\t\t\t\tstring(test.exp1), string(test.exp2), string(test.exp3),\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t}\n}\n\nvar canonicalHeaderCases = [][]byte{\n\t[]byte(\"foo-\"),\n\t[]byte(\"-foo\"),\n\t[]byte(\"-\"),\n\t[]byte(\"foo----bar\"),\n\t[]byte(\"foo-bar\"),\n\t[]byte(\"FoO-BaR\"),\n\t[]byte(\"Foo-Bar\"),\n\t[]byte(\"sec-websocket-extensions\"),\n}\n\nfunc TestCanonicalizeHeaderKey(t *testing.T) {\n\tfor _, bts := range canonicalHeaderCases {\n\t\tt.Run(string(bts), func(t *testing.T) {\n\t\t\tact := append([]byte(nil), bts...)\n\t\t\tcanonicalizeHeaderKey(act)\n\n\t\t\texp := strToBytes(textproto.CanonicalMIMEHeaderKey(string(bts)))\n\n\t\t\tif !bytes.Equal(act, exp) {\n\t\t\t\tt.Errorf(\n\t\t\t\t\t\"canonicalizeHeaderKey(%v) = %v; want %v\",\n\t\t\t\t\tstring(bts), string(act), string(exp),\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkCanonicalizeHeaderKey(b *testing.B) {\n\tfor _, bts := range canonicalHeaderCases {\n\t\tb.Run(string(bts), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tcanonicalizeHeaderKey(bts)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "util_unsafe.go",
          "type": "blob",
          "size": 0.369140625,
          "content": "//go:build !purego\n// +build !purego\n\npackage ws\n\nimport (\n\t\"reflect\"\n\t\"unsafe\"\n)\n\nfunc strToBytes(str string) (bts []byte) {\n\ts := (*reflect.StringHeader)(unsafe.Pointer(&str))\n\tb := (*reflect.SliceHeader)(unsafe.Pointer(&bts))\n\tb.Data = s.Data\n\tb.Len = s.Len\n\tb.Cap = s.Len\n\treturn bts\n}\n\nfunc btsToString(bts []byte) (str string) {\n\treturn *(*string)(unsafe.Pointer(&bts))\n}\n"
        },
        {
          "name": "write.go",
          "type": "blob",
          "size": 1.771484375,
          "content": "package ws\n\nimport (\n\t\"encoding/binary\"\n\t\"io\"\n)\n\n// Header size length bounds in bytes.\nconst (\n\tMaxHeaderSize = 14\n\tMinHeaderSize = 2\n)\n\nconst (\n\tbit0 = 0x80\n\tbit1 = 0x40\n\tbit2 = 0x20\n\tbit3 = 0x10\n\tbit4 = 0x08\n\tbit5 = 0x04\n\tbit6 = 0x02\n\tbit7 = 0x01\n\n\tlen7  = int64(125)\n\tlen16 = int64(^(uint16(0)))\n\tlen64 = int64(^(uint64(0)) >> 1)\n)\n\n// HeaderSize returns number of bytes that are needed to encode given header.\n// It returns -1 if header is malformed.\nfunc HeaderSize(h Header) (n int) {\n\tswitch {\n\tcase h.Length < 126:\n\t\tn = 2\n\tcase h.Length <= len16:\n\t\tn = 4\n\tcase h.Length <= len64:\n\t\tn = 10\n\tdefault:\n\t\treturn -1\n\t}\n\tif h.Masked {\n\t\tn += len(h.Mask)\n\t}\n\treturn n\n}\n\n// WriteHeader writes header binary representation into w.\nfunc WriteHeader(w io.Writer, h Header) error {\n\t// Make slice of bytes with capacity 14 that could hold any header.\n\tbts := make([]byte, MaxHeaderSize)\n\n\tif h.Fin {\n\t\tbts[0] |= bit0\n\t}\n\tbts[0] |= h.Rsv << 4\n\tbts[0] |= byte(h.OpCode)\n\n\tvar n int\n\tswitch {\n\tcase h.Length <= len7:\n\t\tbts[1] = byte(h.Length)\n\t\tn = 2\n\n\tcase h.Length <= len16:\n\t\tbts[1] = 126\n\t\tbinary.BigEndian.PutUint16(bts[2:4], uint16(h.Length))\n\t\tn = 4\n\n\tcase h.Length <= len64:\n\t\tbts[1] = 127\n\t\tbinary.BigEndian.PutUint64(bts[2:10], uint64(h.Length))\n\t\tn = 10\n\n\tdefault:\n\t\treturn ErrHeaderLengthUnexpected\n\t}\n\n\tif h.Masked {\n\t\tbts[1] |= bit0\n\t\tn += copy(bts[n:], h.Mask[:])\n\t}\n\n\t_, err := w.Write(bts[:n])\n\n\treturn err\n}\n\n// WriteFrame writes frame binary representation into w.\nfunc WriteFrame(w io.Writer, f Frame) error {\n\terr := WriteHeader(w, f.Header)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = w.Write(f.Payload)\n\treturn err\n}\n\n// MustWriteFrame is like WriteFrame but panics if frame can not be read.\nfunc MustWriteFrame(w io.Writer, f Frame) {\n\tif err := WriteFrame(w, f); err != nil {\n\t\tpanic(err)\n\t}\n}\n"
        },
        {
          "name": "write_test.go",
          "type": "blob",
          "size": 0.833984375,
          "content": "package ws\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"testing\"\n)\n\nfunc TestWriteHeader(t *testing.T) {\n\tfor i, test := range RWTestCases {\n\t\tt.Run(fmt.Sprintf(\"#%d\", i), func(t *testing.T) {\n\t\t\tbuf := &bytes.Buffer{}\n\t\t\terr := WriteHeader(buf, test.Header)\n\t\t\tif test.Err && err == nil {\n\t\t\t\tt.Errorf(\"expected error, got nil\")\n\t\t\t}\n\t\t\tif !test.Err && err != nil {\n\t\t\t\tt.Errorf(\"unexpected error: %s\", err)\n\t\t\t}\n\t\t\tif test.Err {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif bts := buf.Bytes(); !bytes.Equal(bts, test.Data) {\n\t\t\t\tt.Errorf(\"WriteHeader()\\nwrote:\\n\\t%08b\\nwant:\\n\\t%08b\", bts, test.Data)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkWriteHeader(b *testing.B) {\n\tfor _, bench := range RWBenchCases {\n\t\tb.Run(bench.label, func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tif err := WriteHeader(ioutil.Discard, bench.header); err != nil {\n\t\t\t\t\tb.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "wsflate",
          "type": "tree",
          "content": null
        },
        {
          "name": "wsutil",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}