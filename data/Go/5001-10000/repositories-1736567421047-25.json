{
  "metadata": {
    "timestamp": 1736567421047,
    "page": 25,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sourcegraph/conc",
      "stars": 9549,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.154296875,
          "content": "linters:\n  disable-all: true\n  enable:\n    - errcheck\n    - godot\n    - gosimple\n    - govet\n    - ineffassign\n    - staticcheck\n    - typecheck\n    - unused\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "MIT License\n\nCopyright (c) 2023 Sourcegraph\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.7685546875,
          "content": ".DEFAULT_GOAL := help\n\nGO_BIN ?= $(shell go env GOPATH)/bin\n\n.PHONY: help\nhelp:\n\t@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = \":.*?## \"}; {printf \"\\033[36m%-30s\\033[0m %s\\n\", $$1, $$2}'\n\n$(GO_BIN)/golangci-lint:\n\t@echo \"==> Installing golangci-lint within \"${GO_BIN}\"\"\n\t@go install -v github.com/golangci/golangci-lint/cmd/golangci-lint@latest\n\n.PHONY: lint\nlint: $(GO_BIN)/golangci-lint ## Run linting on Go files\n\t@echo \"==> Linting Go source files\"\n\t@golangci-lint run -v --fix -c .golangci.yml ./...\n\n.PHONY: test\ntest: ## Run tests\n\tgo test -race -v ./... -coverprofile ./coverage.txt\n\n.PHONY: bench\nbench: ## Run benchmarks. See https://pkg.go.dev/cmd/go#hdr-Testing_flags\n\tgo test ./... -bench . -benchtime 5s -timeout 0 -run=XXX -cpu 1 -benchmem\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 13.6044921875,
          "content": "![conch](https://user-images.githubusercontent.com/12631702/210295964-785cc63d-d697-420c-99ff-f492eb81dec9.svg)\n\n# `conc`: better structured concurrency for go\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/sourcegraph/conc.svg)](https://pkg.go.dev/github.com/sourcegraph/conc)\n[![Sourcegraph](https://img.shields.io/badge/view%20on-sourcegraph-A112FE?logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAEZklEQVRoQ+2aXWgUZxSG3292sxtNN43BhBakFPyhxSujRSxiU1pr7SaGXqgUxOIEW0IFkeYighYUxAuLUlq0lrq2iCDpjWtmFVtoG6QVNOCFVShVLyxIk0DVjZLMxt3xTGTccd2ZOd/8JBHci0CY9zvnPPN+/7sCIXwKavOwAcy2QgngQiIztDSE0OwQlDPYR1ebiaH6J5kZChyfW12gRG4QVgGTBfMchMbFP9Sn5nlZL2D0JjLD6710lc+z0NfqSGTXQRQ4bX07Mq423yoBL3OSyHSvUxirMuaEvgbJWrdcvkHMoJwxYuq4INUhyuWvQa1jvdMGxAvCxJlyEC9XOBCWL04wwRzpbDoDQ7wfZJzIQLi5Eggk6DiRhZgWIAbE3NrM4A3LPT8Q7UgqAqLqTmLSHLGPkyzG/qXEczhd0q6RH+zaSBfaUoc4iQx19pIClIscrTkNZzG6gd7qMY6eC2Hqyo705ZfTf+eqJmhMzcSbYtQpOXc92ZsZjLVAL4YNUQbJ5Ttg4CQrQdGYj44Xr9m1XJCzmZusFDJOWNpHjmh5x624a2ZFtOKDVL+uNo2TuXE3bZQQZUf8gtgqP31uI94Z/rMqix+IGiRfWw3xN9dCgVx+L3WrHm4Dju6PXz/EkjuXJ6R+IGgyOE1TbZqTq9y1eo0EZo7oMo1ktPu3xjHvuiLT5AFNszUyDULtWpzE2/fEsey8O5TbWuGWwxrs5rS7nFNMWJrNh2No74s9Ec4vRNmRRzPXMP19fBMSVsGcOJ98G8N3Wl2gXcbTjbX7vUBxLaeASDQCm5Cu/0E2tvtb0Ea+BowtskFD0wvlc6Rf2M+Jx7dTu7ubFr2dnKDRaMQe2v/tcIrNB7FH0O50AcrBaApmRDVwFO31ql3pD8QW4dP0feNwl/Q+kFEtRyIGyaWXnpy1OO0qNJWHo1y6iCmAGkBb/Ru+HenDWIF2mo4r8G+tRRzoniSn2uqFLxANhe9LKHVyTbz6egk9+x5w5fK6ulSNNMhZ/Feno+GebLZV6isTTa6k5qNl5RnZ5u56Ib6SBvFzaWBBVFZzvnERWlt/Cg4l27XChLCqFyLekjhy6xJyoytgjPf7opIB8QPx7sYFiMXHPGt76m741MhCKMZfng0nBOIjmoJPsLqWHwgFpe6V6qtfcopxveR2Oy+J0ntIN/zCWkf8QNAJ7y6d8Bq4lxLc2/qJl5K7t432XwcqX5CrI34gzATWuYILQtdQPyePDK3iuOekCR3Efjhig1B1Uq5UoXEEoZX7d1q535J5S9VOeFyYyEBku5XTMXXKQTToX5Rg7OI44nbW5oKYeYK4EniMeF0YFNSmb+grhc84LyRCEP1/OurOcipCQbKxDeK2V5FcVyIDMQvsgz5gwFhcWWwKyRlvQ3gv29RwWoDYAbIofNyBxI9eDlQ+n3YgsgCWnr4MStGXQXmv9pF2La/k3OccV54JEBM4yp9EsXa/3LfO0dGPcYq0Y7DfZB8nJzZw2rppHgKgVHs8L5wvRwAAAABJRU5ErkJggg==)](https://sourcegraph.com/github.com/sourcegraph/conc)\n[![Go Report Card](https://goreportcard.com/badge/github.com/sourcegraph/conc)](https://goreportcard.com/report/github.com/sourcegraph/conc)\n[![codecov](https://codecov.io/gh/sourcegraph/conc/branch/main/graph/badge.svg?token=MQZTEA1QWT)](https://codecov.io/gh/sourcegraph/conc)\n[![Discord](https://img.shields.io/badge/discord-chat-%235765F2)](https://discord.gg/bvXQXmtRjN)\n\n`conc` is your toolbelt for structured concurrency in go, making common tasks\neasier and safer.\n\n```sh\ngo get github.com/sourcegraph/conc\n```\n\n# At a glance\n\n- Use [`conc.WaitGroup`](https://pkg.go.dev/github.com/sourcegraph/conc#WaitGroup) if you just want a safer version of `sync.WaitGroup`\n- Use [`pool.Pool`](https://pkg.go.dev/github.com/sourcegraph/conc/pool#Pool) if you want a concurrency-limited task runner\n- Use [`pool.ResultPool`](https://pkg.go.dev/github.com/sourcegraph/conc/pool#ResultPool) if you want a concurrent task runner that collects task results\n- Use [`pool.(Result)?ErrorPool`](https://pkg.go.dev/github.com/sourcegraph/conc/pool#ErrorPool) if your tasks are fallible\n- Use [`pool.(Result)?ContextPool`](https://pkg.go.dev/github.com/sourcegraph/conc/pool#ContextPool) if your tasks should be canceled on failure\n- Use [`stream.Stream`](https://pkg.go.dev/github.com/sourcegraph/conc/stream#Stream) if you want to process an ordered stream of tasks in parallel with serial callbacks\n- Use [`iter.Map`](https://pkg.go.dev/github.com/sourcegraph/conc/iter#Map) if you want to concurrently map a slice\n- Use [`iter.ForEach`](https://pkg.go.dev/github.com/sourcegraph/conc/iter#ForEach) if you want to concurrently iterate over a slice\n- Use [`panics.Catcher`](https://pkg.go.dev/github.com/sourcegraph/conc/panics#Catcher) if you want to catch panics in your own goroutines\n\nAll pools are created with\n[`pool.New()`](https://pkg.go.dev/github.com/sourcegraph/conc/pool#New)\nor\n[`pool.NewWithResults[T]()`](https://pkg.go.dev/github.com/sourcegraph/conc/pool#NewWithResults),\nthen configured with methods:\n\n- [`p.WithMaxGoroutines()`](https://pkg.go.dev/github.com/sourcegraph/conc/pool#Pool.MaxGoroutines) configures the maximum number of goroutines in the pool\n- [`p.WithErrors()`](https://pkg.go.dev/github.com/sourcegraph/conc/pool#Pool.WithErrors) configures the pool to run tasks that return errors\n- [`p.WithContext(ctx)`](https://pkg.go.dev/github.com/sourcegraph/conc/pool#Pool.WithContext) configures the pool to run tasks that should be canceled on first error\n- [`p.WithFirstError()`](https://pkg.go.dev/github.com/sourcegraph/conc/pool#ErrorPool.WithFirstError) configures error pools to only keep the first returned error rather than an aggregated error\n- [`p.WithCollectErrored()`](https://pkg.go.dev/github.com/sourcegraph/conc/pool#ResultContextPool.WithCollectErrored) configures result pools to collect results even when the task errored\n\n# Goals\n\nThe main goals of the package are:\n1) Make it harder to leak goroutines\n2) Handle panics gracefully\n3) Make concurrent code easier to read\n\n## Goal #1: Make it harder to leak goroutines\n\nA common pain point when working with goroutines is cleaning them up. It's\nreally easy to fire off a `go` statement and fail to properly wait for it to\ncomplete.\n\n`conc` takes the opinionated stance that all concurrency should be scoped.\nThat is, goroutines should have an owner and that owner should always\nensure that its owned goroutines exit properly.\n\nIn `conc`, the owner of a goroutine is always a `conc.WaitGroup`. Goroutines\nare spawned in a `WaitGroup` with `(*WaitGroup).Go()`, and\n`(*WaitGroup).Wait()` should always be called before the `WaitGroup` goes out\nof scope.\n\nIn some cases, you might want a spawned goroutine to outlast the scope of the\ncaller. In that case, you could pass a `WaitGroup` into the spawning function.\n\n```go\nfunc main() {\n    var wg conc.WaitGroup\n    defer wg.Wait()\n\n    startTheThing(&wg)\n}\n\nfunc startTheThing(wg *conc.WaitGroup) {\n    wg.Go(func() { ... })\n}\n```\n\nFor some more discussion on why scoped concurrency is nice, check out [this\nblog\npost](https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/).\n\n## Goal #2: Handle panics gracefully\n\nA frequent problem with goroutines in long-running applications is handling\npanics. A goroutine spawned without a panic handler will crash the whole process\non panic. This is usually undesirable.\n\nHowever, if you do add a panic handler to a goroutine, what do you do with the\npanic once you catch it? Some options:\n1) Ignore it\n2) Log it\n3) Turn it into an error and return that to the goroutine spawner\n4) Propagate the panic to the goroutine spawner\n\nIgnoring panics is a bad idea since panics usually mean there is actually\nsomething wrong and someone should fix it.\n\nJust logging panics isn't great either because then there is no indication to the spawner\nthat something bad happened, and it might just continue on as normal even though your\nprogram is in a really bad state.\n\nBoth (3) and (4) are reasonable options, but both require the goroutine to have\nan owner that can actually receive the message that something went wrong. This\nis generally not true with a goroutine spawned with `go`, but in the `conc`\npackage, all goroutines have an owner that must collect the spawned goroutine.\nIn the conc package, any call to `Wait()` will panic if any of the spawned goroutines\npanicked. Additionally, it decorates the panic value with a stacktrace from the child\ngoroutine so that you don't lose information about what caused the panic.\n\nDoing this all correctly every time you spawn something with `go` is not\ntrivial and it requires a lot of boilerplate that makes the important parts of\nthe code more difficult to read, so `conc` does this for you.\n\n<table>\n<tr>\n<th><code>stdlib</code></th>\n<th><code>conc</code></th>\n</tr>\n<tr>\n<td>\n\n```go\ntype caughtPanicError struct {\n    val   any\n    stack []byte\n}\n\nfunc (e *caughtPanicError) Error() string {\n    return fmt.Sprintf(\n        \"panic: %q\\n%s\",\n        e.val,\n        string(e.stack)\n    )\n}\n\nfunc main() {\n    done := make(chan error)\n    go func() {\n        defer func() {\n            if v := recover(); v != nil {\n                done <- &caughtPanicError{\n                    val: v,\n                    stack: debug.Stack()\n                }\n            } else {\n                done <- nil\n            }\n        }()\n        doSomethingThatMightPanic()\n    }()\n    err := <-done\n    if err != nil {\n        panic(err)\n    }\n}\n```\n</td>\n<td>\n\n```go\nfunc main() {\n    var wg conc.WaitGroup\n    wg.Go(doSomethingThatMightPanic)\n    // panics with a nice stacktrace\n    wg.Wait()\n}\n```\n</td>\n</tr>\n</table>\n\n## Goal #3: Make concurrent code easier to read\n\nDoing concurrency correctly is difficult. Doing it in a way that doesn't\nobfuscate what the code is actually doing is more difficult. The `conc` package\nattempts to make common operations easier by abstracting as much boilerplate\ncomplexity as possible.\n\nWant to run a set of concurrent tasks with a bounded set of goroutines? Use\n`pool.New()`. Want to process an ordered stream of results concurrently, but\nstill maintain order? Try `stream.New()`. What about a concurrent map over\na slice? Take a peek at `iter.Map()`.\n\nBrowse some examples below for some comparisons with doing these by hand.\n\n# Examples\n\nEach of these examples forgoes propagating panics for simplicity. To see\nwhat kind of complexity that would add, check out the \"Goal #2\" header above.\n\nSpawn a set of goroutines and waiting for them to finish:\n\n<table>\n<tr>\n<th><code>stdlib</code></th>\n<th><code>conc</code></th>\n</tr>\n<tr>\n<td>\n\n```go\nfunc main() {\n    var wg sync.WaitGroup\n    for i := 0; i < 10; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            // crashes on panic!\n            doSomething()\n        }()\n    }\n    wg.Wait()\n}\n```\n</td>\n<td>\n\n```go\nfunc main() {\n    var wg conc.WaitGroup\n    for i := 0; i < 10; i++ {\n        wg.Go(doSomething)\n    }\n    wg.Wait()\n}\n```\n</td>\n</tr>\n</table>\n\nProcess each element of a stream in a static pool of goroutines:\n\n<table>\n<tr>\n<th><code>stdlib</code></th>\n<th><code>conc</code></th>\n</tr>\n<tr>\n<td>\n\n```go\nfunc process(stream chan int) {\n    var wg sync.WaitGroup\n    for i := 0; i < 10; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            for elem := range stream {\n                handle(elem)\n            }\n        }()\n    }\n    wg.Wait()\n}\n```\n</td>\n<td>\n\n```go\nfunc process(stream chan int) {\n    p := pool.New().WithMaxGoroutines(10)\n    for elem := range stream {\n        elem := elem\n        p.Go(func() {\n            handle(elem)\n        })\n    }\n    p.Wait()\n}\n```\n</td>\n</tr>\n</table>\n\nProcess each element of a slice in a static pool of goroutines:\n\n<table>\n<tr>\n<th><code>stdlib</code></th>\n<th><code>conc</code></th>\n</tr>\n<tr>\n<td>\n\n```go\nfunc process(values []int) {\n    feeder := make(chan int, 8)\n\n    var wg sync.WaitGroup\n    for i := 0; i < 10; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            for elem := range feeder {\n                handle(elem)\n            }\n        }()\n    }\n\n    for _, value := range values {\n        feeder <- value\n    }\n    close(feeder)\n    wg.Wait()\n}\n```\n</td>\n<td>\n\n```go\nfunc process(values []int) {\n    iter.ForEach(values, handle)\n}\n```\n</td>\n</tr>\n</table>\n\nConcurrently map a slice:\n\n<table>\n<tr>\n<th><code>stdlib</code></th>\n<th><code>conc</code></th>\n</tr>\n<tr>\n<td>\n\n```go\nfunc concMap(\n    input []int,\n    f func(int) int,\n) []int {\n    res := make([]int, len(input))\n    var idx atomic.Int64\n\n    var wg sync.WaitGroup\n    for i := 0; i < 10; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n\n            for {\n                i := int(idx.Add(1) - 1)\n                if i >= len(input) {\n                    return\n                }\n\n                res[i] = f(input[i])\n            }\n        }()\n    }\n    wg.Wait()\n    return res\n}\n```\n</td>\n<td>\n\n```go\nfunc concMap(\n    input []int,\n    f func(*int) int,\n) []int {\n    return iter.Map(input, f)\n}\n```\n</td>\n</tr>\n</table>\n\nProcess an ordered stream concurrently:\n\n\n<table>\n<tr>\n<th><code>stdlib</code></th>\n<th><code>conc</code></th>\n</tr>\n<tr>\n<td>\n\n```go\nfunc mapStream(\n    in chan int,\n    out chan int,\n    f func(int) int,\n) {\n    tasks := make(chan func())\n    taskResults := make(chan chan int)\n\n    // Worker goroutines\n    var workerWg sync.WaitGroup\n    for i := 0; i < 10; i++ {\n        workerWg.Add(1)\n        go func() {\n            defer workerWg.Done()\n            for task := range tasks {\n                task()\n            }\n        }()\n    }\n\n    // Ordered reader goroutines\n    var readerWg sync.WaitGroup\n    readerWg.Add(1)\n    go func() {\n        defer readerWg.Done()\n        for result := range taskResults {\n            item := <-result\n            out <- item\n        }\n    }()\n\n    // Feed the workers with tasks\n    for elem := range in {\n        resultCh := make(chan int, 1)\n        taskResults <- resultCh\n        tasks <- func() {\n            resultCh <- f(elem)\n        }\n    }\n\n    // We've exhausted input.\n    // Wait for everything to finish\n    close(tasks)\n    workerWg.Wait()\n    close(taskResults)\n    readerWg.Wait()\n}\n```\n</td>\n<td>\n\n```go\nfunc mapStream(\n    in chan int,\n    out chan int,\n    f func(int) int,\n) {\n    s := stream.New().WithMaxGoroutines(10)\n    for elem := range in {\n        elem := elem\n        s.Go(func() stream.Callback {\n            res := f(elem)\n            return func() { out <- res }\n        })\n    }\n    s.Wait()\n}\n```\n</td>\n</tr>\n</table>\n\n# Status\n\nThis package is currently pre-1.0. There are likely to be minor breaking\nchanges before a 1.0 release as we stabilize the APIs and tweak defaults.\nPlease open an issue if you have questions, concerns, or requests that you'd\nlike addressed before the 1.0 release. Currently, a 1.0 is targeted for \nMarch 2023.\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.384765625,
          "content": "module github.com/sourcegraph/conc\n\ngo 1.20\n\nrequire github.com/stretchr/testify v1.8.1\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/kr/pretty v0.3.0 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/rogpeppe/go-internal v1.9.0 // indirect\n\tgopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.6669921875,
          "content": "github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pretty v0.3.0 h1:WgNl7dwNpEZ6jJ9k1snq4pZsg7DOEN8hP9Xw0Tsjwk0=\ngithub.com/kr/pretty v0.3.0/go.mod h1:640gp4NfQd8pI5XOwp5fnNeVWj67G7CFk/SaSQn7NBk=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rogpeppe/go-internal v1.6.1/go.mod h1:xXDCJY+GAPziupqXw64V24skbSoqbTEfhy4qGm1nDQc=\ngithub.com/rogpeppe/go-internal v1.9.0 h1:73kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=\ngithub.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.1 h1:w7B6lhMri9wdJUVmEZPGGhZzrYTPvgJArz7wNPgYKsk=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "iter",
          "type": "tree",
          "content": null
        },
        {
          "name": "panics",
          "type": "tree",
          "content": null
        },
        {
          "name": "pool",
          "type": "tree",
          "content": null
        },
        {
          "name": "stream",
          "type": "tree",
          "content": null
        },
        {
          "name": "waitgroup.go",
          "type": "blob",
          "size": 1.373046875,
          "content": "package conc\n\nimport (\n\t\"sync\"\n\n\t\"github.com/sourcegraph/conc/panics\"\n)\n\n// NewWaitGroup creates a new WaitGroup.\nfunc NewWaitGroup() *WaitGroup {\n\treturn &WaitGroup{}\n}\n\n// WaitGroup is the primary building block for scoped concurrency.\n// Goroutines can be spawned in the WaitGroup with the Go method,\n// and calling Wait() will ensure that each of those goroutines exits\n// before continuing. Any panics in a child goroutine will be caught\n// and propagated to the caller of Wait().\n//\n// The zero value of WaitGroup is usable, just like sync.WaitGroup.\n// Also like sync.WaitGroup, it must not be copied after first use.\ntype WaitGroup struct {\n\twg sync.WaitGroup\n\tpc panics.Catcher\n}\n\n// Go spawns a new goroutine in the WaitGroup.\nfunc (h *WaitGroup) Go(f func()) {\n\th.wg.Add(1)\n\tgo func() {\n\t\tdefer h.wg.Done()\n\t\th.pc.Try(f)\n\t}()\n}\n\n// Wait will block until all goroutines spawned with Go exit and will\n// propagate any panics spawned in a child goroutine.\nfunc (h *WaitGroup) Wait() {\n\th.wg.Wait()\n\n\t// Propagate a panic if we caught one from a child goroutine.\n\th.pc.Repanic()\n}\n\n// WaitAndRecover will block until all goroutines spawned with Go exit and\n// will return a *panics.Recovered if one of the child goroutines panics.\nfunc (h *WaitGroup) WaitAndRecover() *panics.Recovered {\n\th.wg.Wait()\n\n\t// Return a recovered panic if we caught one from a child goroutine.\n\treturn h.pc.Recovered()\n}\n"
        },
        {
          "name": "waitgroup_test.go",
          "type": "blob",
          "size": 2.8623046875,
          "content": "package conc_test\n\nimport (\n\t\"fmt\"\n\t\"sync/atomic\"\n\t\"testing\"\n\n\t\"github.com/sourcegraph/conc\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc ExampleWaitGroup() {\n\tvar count atomic.Int64\n\n\tvar wg conc.WaitGroup\n\tfor i := 0; i < 10; i++ {\n\t\twg.Go(func() {\n\t\t\tcount.Add(1)\n\t\t})\n\t}\n\twg.Wait()\n\n\tfmt.Println(count.Load())\n\t// Output:\n\t// 10\n}\n\nfunc ExampleWaitGroup_WaitAndRecover() {\n\tvar wg conc.WaitGroup\n\n\twg.Go(func() {\n\t\tpanic(\"super bad thing\")\n\t})\n\n\trecoveredPanic := wg.WaitAndRecover()\n\tfmt.Println(recoveredPanic.Value)\n\t// Output:\n\t// super bad thing\n}\n\nfunc TestWaitGroup(t *testing.T) {\n\tt.Parallel()\n\n\tt.Run(\"ctor\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\twg := conc.NewWaitGroup()\n\t\trequire.IsType(t, &conc.WaitGroup{}, wg)\n\t})\n\n\tt.Run(\"all spawned run\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tvar count atomic.Int64\n\t\tvar wg conc.WaitGroup\n\t\tfor i := 0; i < 100; i++ {\n\t\t\twg.Go(func() {\n\t\t\t\tcount.Add(1)\n\t\t\t})\n\t\t}\n\t\twg.Wait()\n\t\trequire.Equal(t, count.Load(), int64(100))\n\t})\n\n\tt.Run(\"panic\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tt.Run(\"is propagated\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tvar wg conc.WaitGroup\n\t\t\twg.Go(func() {\n\t\t\t\tpanic(\"super bad thing\")\n\t\t\t})\n\t\t\trequire.Panics(t, wg.Wait)\n\t\t})\n\n\t\tt.Run(\"one is propagated\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tvar wg conc.WaitGroup\n\t\t\twg.Go(func() {\n\t\t\t\tpanic(\"super bad thing\")\n\t\t\t})\n\t\t\twg.Go(func() {\n\t\t\t\tpanic(\"super badder thing\")\n\t\t\t})\n\t\t\trequire.Panics(t, wg.Wait)\n\t\t})\n\n\t\tt.Run(\"non-panics do not overwrite panic\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tvar wg conc.WaitGroup\n\t\t\twg.Go(func() {\n\t\t\t\tpanic(\"super bad thing\")\n\t\t\t})\n\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\twg.Go(func() {})\n\t\t\t}\n\t\t\trequire.Panics(t, wg.Wait)\n\t\t})\n\n\t\tt.Run(\"non-panics run successfully\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tvar wg conc.WaitGroup\n\t\t\tvar i atomic.Int64\n\t\t\twg.Go(func() {\n\t\t\t\ti.Add(1)\n\t\t\t})\n\t\t\twg.Go(func() {\n\t\t\t\tpanic(\"super bad thing\")\n\t\t\t})\n\t\t\twg.Go(func() {\n\t\t\t\ti.Add(1)\n\t\t\t})\n\t\t\trequire.Panics(t, wg.Wait)\n\t\t\trequire.Equal(t, int64(2), i.Load())\n\t\t})\n\n\t\tt.Run(\"is caught by waitandrecover\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tvar wg conc.WaitGroup\n\t\t\twg.Go(func() {\n\t\t\t\tpanic(\"super bad thing\")\n\t\t\t})\n\t\t\tp := wg.WaitAndRecover()\n\t\t\trequire.Equal(t, p.Value, \"super bad thing\")\n\t\t})\n\n\t\tt.Run(\"one is caught by waitandrecover\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tvar wg conc.WaitGroup\n\t\t\twg.Go(func() {\n\t\t\t\tpanic(\"super bad thing\")\n\t\t\t})\n\t\t\twg.Go(func() {\n\t\t\t\tpanic(\"super badder thing\")\n\t\t\t})\n\t\t\tp := wg.WaitAndRecover()\n\t\t\trequire.NotNil(t, p)\n\t\t})\n\n\t\tt.Run(\"nonpanics run successfully with waitandrecover\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tvar wg conc.WaitGroup\n\t\t\tvar i atomic.Int64\n\t\t\twg.Go(func() {\n\t\t\t\ti.Add(1)\n\t\t\t})\n\t\t\twg.Go(func() {\n\t\t\t\tpanic(\"super bad thing\")\n\t\t\t})\n\t\t\twg.Go(func() {\n\t\t\t\ti.Add(1)\n\t\t\t})\n\t\t\tp := wg.WaitAndRecover()\n\t\t\trequire.Equal(t, p.Value, \"super bad thing\")\n\t\t\trequire.Equal(t, int64(2), i.Load())\n\t\t})\n\t})\n}\n"
        }
      ]
    }
  ]
}