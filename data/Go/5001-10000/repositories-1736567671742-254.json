{
  "metadata": {
    "timestamp": 1736567671742,
    "page": 254,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "DATA-DOG/go-sqlmock",
      "stars": 6209,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0712890625,
          "content": "/examples/blog/blog\n/examples/orders/orders\n/examples/basic/basic\n.idea/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.466796875,
          "content": "language: go\n\ngo_import_path: github.com/DATA-DOG/go-sqlmock\n\ngo:\n  - 1.2.x\n  - 1.3.x\n  - 1.4 # has no cover tool for latest releases\n  - 1.5.x\n  - 1.6.x\n  - 1.7.x\n  - 1.8.x\n  - 1.9.x\n  - 1.10.x\n  - 1.11.x\n  - 1.12.x\n  - 1.13.x\n  - 1.14.x\n  - 1.15.x\n  - 1.16.x\n  - 1.17.x\n\nscript:\n  - go vet\n  - test -z \"$(go fmt ./...)\" # fail if not formatted properly\n  - go test -race -coverprofile=coverage.txt -covermode=atomic\n\nafter_success:\n  - bash <(curl -s https://codecov.io/bash)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4609375,
          "content": "The three clause BSD license (http://en.wikipedia.org/wiki/BSD_licenses)\n\nCopyright (c) 2013-2019, DATA-DOG team\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* The name DataDog.lt may not be used to endorse or promote products\n  derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,\nINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\nBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\nOF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\nEVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.1279296875,
          "content": "[![Build Status](https://travis-ci.org/DATA-DOG/go-sqlmock.svg)](https://travis-ci.org/DATA-DOG/go-sqlmock)\n[![GoDoc](https://godoc.org/github.com/DATA-DOG/go-sqlmock?status.svg)](https://godoc.org/github.com/DATA-DOG/go-sqlmock)\n[![Go Report Card](https://goreportcard.com/badge/github.com/DATA-DOG/go-sqlmock)](https://goreportcard.com/report/github.com/DATA-DOG/go-sqlmock)\n[![codecov.io](https://codecov.io/github/DATA-DOG/go-sqlmock/branch/master/graph/badge.svg)](https://codecov.io/github/DATA-DOG/go-sqlmock)\n\n# Sql driver mock for Golang\n\n**sqlmock** is a mock library implementing [sql/driver](https://godoc.org/database/sql/driver). Which has one and only\npurpose - to simulate any **sql** driver behavior in tests, without needing a real database connection. It helps to\nmaintain correct **TDD** workflow.\n\n- this library is now complete and stable. (you may not find new changes for this reason)\n- supports concurrency and multiple connections.\n- supports **go1.8** Context related feature mocking and Named sql parameters.\n- does not require any modifications to your source code.\n- the driver allows to mock any sql driver method behavior.\n- has strict by default expectation order matching.\n- has no third party dependencies.\n\n**NOTE:** in **v1.2.0** **sqlmock.Rows** has changed to struct from interface, if you were using any type references to that\ninterface, you will need to switch it to a pointer struct type. Also, **sqlmock.Rows** were used to implement **driver.Rows**\ninterface, which was not required or useful for mocking and was removed. Hope it will not cause issues.\n\n## Looking for maintainers\n\nI do not have much spare time for this library and willing to transfer the repository ownership\nto person or an organization motivated to maintain it. Open up a conversation if you are interested. See #230.\n\n## Install\n\n    go get github.com/DATA-DOG/go-sqlmock\n\n## Documentation and Examples\n\nVisit [godoc](http://godoc.org/github.com/DATA-DOG/go-sqlmock) for general examples and public api reference.\nSee **.travis.yml** for supported **go** versions.\nDifferent use case, is to functionally test with a real database - [go-txdb](https://github.com/DATA-DOG/go-txdb)\nall database related actions are isolated within a single transaction so the database can remain in the same state.\n\nSee implementation examples:\n\n- [blog API server](https://github.com/DATA-DOG/go-sqlmock/tree/master/examples/blog)\n- [the same orders example](https://github.com/DATA-DOG/go-sqlmock/tree/master/examples/orders)\n\n### Something you may want to test, assuming you use the [go-mysql-driver](https://github.com/go-sql-driver/mysql)\n\n``` go\npackage main\n\nimport (\n\t\"database/sql\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n)\n\nfunc recordStats(db *sql.DB, userID, productID int64) (err error) {\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\tswitch err {\n\t\tcase nil:\n\t\t\terr = tx.Commit()\n\t\tdefault:\n\t\t\ttx.Rollback()\n\t\t}\n\t}()\n\n\tif _, err = tx.Exec(\"UPDATE products SET views = views + 1\"); err != nil {\n\t\treturn\n\t}\n\tif _, err = tx.Exec(\"INSERT INTO product_viewers (user_id, product_id) VALUES (?, ?)\", userID, productID); err != nil {\n\t\treturn\n\t}\n\treturn\n}\n\nfunc main() {\n\t// @NOTE: the real connection is not required for tests\n\tdb, err := sql.Open(\"mysql\", \"root@/blog\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer db.Close()\n\n\tif err = recordStats(db, 1 /*some user id*/, 5 /*some product id*/); err != nil {\n\t\tpanic(err)\n\t}\n}\n```\n\n### Tests with sqlmock\n\n``` go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/DATA-DOG/go-sqlmock\"\n)\n\n// a successful case\nfunc TestShouldUpdateStats(t *testing.T) {\n\tdb, mock, err := sqlmock.New()\n\tif err != nil {\n\t\tt.Fatalf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectBegin()\n\tmock.ExpectExec(\"UPDATE products\").WillReturnResult(sqlmock.NewResult(1, 1))\n\tmock.ExpectExec(\"INSERT INTO product_viewers\").WithArgs(2, 3).WillReturnResult(sqlmock.NewResult(1, 1))\n\tmock.ExpectCommit()\n\n\t// now we execute our method\n\tif err = recordStats(db, 2, 3); err != nil {\n\t\tt.Errorf(\"error was not expected while updating stats: %s\", err)\n\t}\n\n\t// we make sure that all expectations were met\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\n// a failing test case\nfunc TestShouldRollbackStatUpdatesOnFailure(t *testing.T) {\n\tdb, mock, err := sqlmock.New()\n\tif err != nil {\n\t\tt.Fatalf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectBegin()\n\tmock.ExpectExec(\"UPDATE products\").WillReturnResult(sqlmock.NewResult(1, 1))\n\tmock.ExpectExec(\"INSERT INTO product_viewers\").\n\t\tWithArgs(2, 3).\n\t\tWillReturnError(fmt.Errorf(\"some error\"))\n\tmock.ExpectRollback()\n\n\t// now we execute our method\n\tif err = recordStats(db, 2, 3); err == nil {\n\t\tt.Errorf(\"was expecting an error, but there was none\")\n\t}\n\n\t// we make sure that all expectations were met\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n```\n\n## Customize SQL query matching\n\nThere were plenty of requests from users regarding SQL query string validation or different matching option.\nWe have now implemented the `QueryMatcher` interface, which can be passed through an option when calling\n`sqlmock.New` or `sqlmock.NewWithDSN`.\n\nThis now allows to include some library, which would allow for example to parse and validate `mysql` SQL AST.\nAnd create a custom QueryMatcher in order to validate SQL in sophisticated ways.\n\nBy default, **sqlmock** is preserving backward compatibility and default query matcher is `sqlmock.QueryMatcherRegexp`\nwhich uses expected SQL string as a regular expression to match incoming query string. There is an equality matcher:\n`QueryMatcherEqual` which will do a full case sensitive match.\n\nIn order to customize the QueryMatcher, use the following:\n\n``` go\n\tdb, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))\n```\n\nThe query matcher can be fully customized based on user needs. **sqlmock** will not\nprovide a standard sql parsing matchers, since various drivers may not follow the same SQL standard.\n\n## Matching arguments like time.Time\n\nThere may be arguments which are of `struct` type and cannot be compared easily by value like `time.Time`. In this case\n**sqlmock** provides an [Argument](https://godoc.org/github.com/DATA-DOG/go-sqlmock#Argument) interface which\ncan be used in more sophisticated matching. Here is a simple example of time argument matching:\n\n``` go\ntype AnyTime struct{}\n\n// Match satisfies sqlmock.Argument interface\nfunc (a AnyTime) Match(v driver.Value) bool {\n\t_, ok := v.(time.Time)\n\treturn ok\n}\n\nfunc TestAnyTimeArgument(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := sqlmock.New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectExec(\"INSERT INTO users\").\n\t\tWithArgs(\"john\", AnyTime{}).\n\t\tWillReturnResult(sqlmock.NewResult(1, 1))\n\n\t_, err = db.Exec(\"INSERT INTO users(name, created_at) VALUES (?, ?)\", \"john\", time.Now())\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected, while inserting a row\", err)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n```\n\nIt only asserts that argument is of `time.Time` type.\n\n## Run tests\n\n    go test -race\n\n## Change Log\n\n- **2019-04-06** - added functionality to mock a sql MetaData request\n- **2019-02-13** - added `go.mod` removed the references and suggestions using `gopkg.in`.\n- **2018-12-11** - added expectation of Rows to be closed, while mocking expected query.\n- **2018-12-11** - introduced an option to provide **QueryMatcher** in order to customize SQL query matching.\n- **2017-09-01** - it is now possible to expect that prepared statement will be closed,\n  using **ExpectedPrepare.WillBeClosed**.\n- **2017-02-09** - implemented support for **go1.8** features. **Rows** interface was changed to struct\n  but contains all methods as before and should maintain backwards compatibility. **ExpectedQuery.WillReturnRows** may now\n  accept multiple row sets.\n- **2016-11-02** - `db.Prepare()` was not validating expected prepare SQL\n  query. It should still be validated even if Exec or Query is not\n  executed on that prepared statement.\n- **2016-02-23** - added **sqlmock.AnyArg()** function to provide any kind\n  of argument matcher.\n- **2016-02-23** - convert expected arguments to driver.Value as natural\n  driver does, the change may affect time.Time comparison and will be\n  stricter. See [issue](https://github.com/DATA-DOG/go-sqlmock/issues/31).\n- **2015-08-27** - **v1** api change, concurrency support, all known issues fixed.\n- **2014-08-16** instead of **panic** during reflect type mismatch when comparing query arguments - now return error\n- **2014-08-14** added **sqlmock.NewErrorResult** which gives an option to return driver.Result with errors for\ninterface methods, see [issue](https://github.com/DATA-DOG/go-sqlmock/issues/5)\n- **2014-05-29** allow to match arguments in more sophisticated ways, by providing an **sqlmock.Argument** interface\n- **2014-04-21** introduce **sqlmock.New()** to open a mock database connection for tests. This method\ncalls sql.DB.Ping to ensure that connection is open, see [issue](https://github.com/DATA-DOG/go-sqlmock/issues/4).\nThis way on Close it will surely assert if all expectations are met, even if database was not triggered at all.\nThe old way is still available, but it is advisable to call db.Ping manually before asserting with db.Close.\n- **2014-02-14** RowsFromCSVString is now a part of Rows interface named as FromCSVString.\nIt has changed to allow more ways to construct rows and to easily extend this API in future.\nSee [issue 1](https://github.com/DATA-DOG/go-sqlmock/issues/1)\n**RowsFromCSVString** is deprecated and will be removed in future\n\n## Contributions\n\nFeel free to open a pull request. Note, if you wish to contribute an extension to public (exported methods or types) -\nplease open an issue before, to discuss whether these changes can be accepted. All backward incompatible changes are\nand will be treated cautiously\n\n## License\n\nThe [three clause BSD license](http://en.wikipedia.org/wiki/BSD_licenses)\n\n"
        },
        {
          "name": "argument.go",
          "type": "blob",
          "size": 0.4990234375,
          "content": "package sqlmock\n\nimport \"database/sql/driver\"\n\n// Argument interface allows to match\n// any argument in specific way when used with\n// ExpectedQuery and ExpectedExec expectations.\ntype Argument interface {\n\tMatch(driver.Value) bool\n}\n\n// AnyArg will return an Argument which can\n// match any kind of arguments.\n//\n// Useful for time.Time or similar kinds of arguments.\nfunc AnyArg() Argument {\n\treturn anyArgument{}\n}\n\ntype anyArgument struct{}\n\nfunc (a anyArgument) Match(_ driver.Value) bool {\n\treturn true\n}\n"
        },
        {
          "name": "argument_test.go",
          "type": "blob",
          "size": 1.4111328125,
          "content": "package sqlmock\n\nimport (\n\t\"database/sql/driver\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype AnyTime struct{}\n\n// Match satisfies sqlmock.Argument interface\nfunc (a AnyTime) Match(v driver.Value) bool {\n\t_, ok := v.(time.Time)\n\treturn ok\n}\n\nfunc TestAnyTimeArgument(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectExec(\"INSERT INTO users\").\n\t\tWithArgs(\"john\", AnyTime{}).\n\t\tWillReturnResult(NewResult(1, 1))\n\n\t_, err = db.Exec(\"INSERT INTO users(name, created_at) VALUES (?, ?)\", \"john\", time.Now())\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected, while inserting a row\", err)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestByteSliceArgument(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tusername := []byte(\"user\")\n\tmock.ExpectExec(\"INSERT INTO users\").WithArgs(username).WillReturnResult(NewResult(1, 1))\n\n\t_, err = db.Exec(\"INSERT INTO users(username) VALUES (?)\", username)\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected, while inserting a row\", err)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n"
        },
        {
          "name": "column.go",
          "type": "blob",
          "size": 1.568359375,
          "content": "package sqlmock\n\nimport \"reflect\"\n\n// Column is a mocked column Metadata for rows.ColumnTypes()\ntype Column struct {\n\tname       string\n\tdbType     string\n\tnullable   bool\n\tnullableOk bool\n\tlength     int64\n\tlengthOk   bool\n\tprecision  int64\n\tscale      int64\n\tpsOk       bool\n\tscanType   reflect.Type\n}\n\nfunc (c *Column) Name() string {\n\treturn c.name\n}\n\nfunc (c *Column) DbType() string {\n\treturn c.dbType\n}\n\nfunc (c *Column) IsNullable() (bool, bool) {\n\treturn c.nullable, c.nullableOk\n}\n\nfunc (c *Column) Length() (int64, bool) {\n\treturn c.length, c.lengthOk\n}\n\nfunc (c *Column) PrecisionScale() (int64, int64, bool) {\n\treturn c.precision, c.scale, c.psOk\n}\n\nfunc (c *Column) ScanType() reflect.Type {\n\treturn c.scanType\n}\n\n// NewColumn returns a Column with specified name\nfunc NewColumn(name string) *Column {\n\treturn &Column{\n\t\tname: name,\n\t}\n}\n\n// Nullable returns the column with nullable metadata set\nfunc (c *Column) Nullable(nullable bool) *Column {\n\tc.nullable = nullable\n\tc.nullableOk = true\n\treturn c\n}\n\n// OfType returns the column with type metadata set\nfunc (c *Column) OfType(dbType string, sampleValue interface{}) *Column {\n\tc.dbType = dbType\n\tc.scanType = reflect.TypeOf(sampleValue)\n\treturn c\n}\n\n// WithLength returns the column with length metadata set.\nfunc (c *Column) WithLength(length int64) *Column {\n\tc.length = length\n\tc.lengthOk = true\n\treturn c\n}\n\n// WithPrecisionAndScale returns the column with precision and scale metadata set.\nfunc (c *Column) WithPrecisionAndScale(precision, scale int64) *Column {\n\tc.precision = precision\n\tc.scale = scale\n\tc.psOk = true\n\treturn c\n}\n"
        },
        {
          "name": "column_test.go",
          "type": "blob",
          "size": 1.6826171875,
          "content": "package sqlmock\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestColumn(t *testing.T) {\n\tnow, _ := time.Parse(time.RFC3339, \"2020-06-20T22:08:41Z\")\n\tcolumn1 := NewColumn(\"test\").OfType(\"VARCHAR\", \"\").Nullable(true).WithLength(100)\n\tcolumn2 := NewColumn(\"number\").OfType(\"DECIMAL\", float64(0.0)).Nullable(false).WithPrecisionAndScale(10, 4)\n\tcolumn3 := NewColumn(\"when\").OfType(\"TIMESTAMP\", now)\n\n\tif column1.ScanType().Kind() != reflect.String {\n\t\tt.Errorf(\"string scanType mismatch: %v\", column1.ScanType())\n\t}\n\tif column2.ScanType().Kind() != reflect.Float64 {\n\t\tt.Errorf(\"float scanType mismatch: %v\", column2.ScanType())\n\t}\n\tif column3.ScanType() != reflect.TypeOf(time.Time{}) {\n\t\tt.Errorf(\"time scanType mismatch: %v\", column3.ScanType())\n\t}\n\n\tnullable, ok := column1.IsNullable()\n\tif !nullable || !ok {\n\t\tt.Errorf(\"'test' column should be nullable\")\n\t}\n\tnullable, ok = column2.IsNullable()\n\tif nullable || !ok {\n\t\tt.Errorf(\"'number' column should not be nullable\")\n\t}\n\tnullable, ok = column3.IsNullable()\n\tif ok {\n\t\tt.Errorf(\"'when' column nullability should be unknown\")\n\t}\n\n\tlength, ok := column1.Length()\n\tif length != 100 || !ok {\n\t\tt.Errorf(\"'test' column wrong length\")\n\t}\n\tlength, ok = column2.Length()\n\tif ok {\n\t\tt.Errorf(\"'number' column is not of variable length type\")\n\t}\n\tlength, ok = column3.Length()\n\tif ok {\n\t\tt.Errorf(\"'when' column is not of variable length type\")\n\t}\n\n\t_, _, ok = column1.PrecisionScale()\n\tif ok {\n\t\tt.Errorf(\"'test' column not applicable\")\n\t}\n\tprecision, scale, ok := column2.PrecisionScale()\n\tif precision != 10 || scale != 4 || !ok {\n\t\tt.Errorf(\"'number' column not applicable\")\n\t}\n\t_, _, ok = column3.PrecisionScale()\n\tif ok {\n\t\tt.Errorf(\"'when' column not applicable\")\n\t}\n}\n"
        },
        {
          "name": "driver.go",
          "type": "blob",
          "size": 1.9736328125,
          "content": "package sqlmock\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"fmt\"\n\t\"sync\"\n)\n\nvar pool *mockDriver\n\nfunc init() {\n\tpool = &mockDriver{\n\t\tconns: make(map[string]*sqlmock),\n\t}\n\tsql.Register(\"sqlmock\", pool)\n}\n\ntype mockDriver struct {\n\tsync.Mutex\n\tcounter int\n\tconns   map[string]*sqlmock\n}\n\nfunc (d *mockDriver) Open(dsn string) (driver.Conn, error) {\n\td.Lock()\n\tdefer d.Unlock()\n\n\tc, ok := d.conns[dsn]\n\tif !ok {\n\t\treturn c, fmt.Errorf(\"expected a connection to be available, but it is not\")\n\t}\n\n\tc.opened++\n\treturn c, nil\n}\n\n// New creates sqlmock database connection and a mock to manage expectations.\n// Accepts options, like ValueConverterOption, to use a ValueConverter from\n// a specific driver.\n// Pings db so that all expectations could be\n// asserted.\nfunc New(options ...SqlMockOption) (*sql.DB, Sqlmock, error) {\n\tpool.Lock()\n\tdsn := fmt.Sprintf(\"sqlmock_db_%d\", pool.counter)\n\tpool.counter++\n\n\tsmock := &sqlmock{dsn: dsn, drv: pool, ordered: true}\n\tpool.conns[dsn] = smock\n\tpool.Unlock()\n\n\treturn smock.open(options)\n}\n\n// NewWithDSN creates sqlmock database connection with a specific DSN\n// and a mock to manage expectations.\n// Accepts options, like ValueConverterOption, to use a ValueConverter from\n// a specific driver.\n// Pings db so that all expectations could be asserted.\n//\n// This method is introduced because of sql abstraction\n// libraries, which do not provide a way to initialize\n// with sql.DB instance. For example GORM library.\n//\n// Note, it will error if attempted to create with an\n// already used dsn\n//\n// It is not recommended to use this method, unless you\n// really need it and there is no other way around.\nfunc NewWithDSN(dsn string, options ...SqlMockOption) (*sql.DB, Sqlmock, error) {\n\tpool.Lock()\n\tif _, ok := pool.conns[dsn]; ok {\n\t\tpool.Unlock()\n\t\treturn nil, nil, fmt.Errorf(\"cannot create a new mock database with the same dsn: %s\", dsn)\n\t}\n\tsmock := &sqlmock{dsn: dsn, drv: pool, ordered: true}\n\tpool.conns[dsn] = smock\n\tpool.Unlock()\n\n\treturn smock.open(options)\n}\n"
        },
        {
          "name": "driver_test.go",
          "type": "blob",
          "size": 3.2255859375,
          "content": "package sqlmock\n\nimport (\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n)\n\ntype void struct{}\n\nfunc (void) Print(...interface{}) {}\n\ntype converter struct{}\n\nfunc (c *converter) ConvertValue(v interface{}) (driver.Value, error) {\n\treturn nil, errors.New(\"converter disabled\")\n}\n\nfunc ExampleNew() {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"expected no error, but got:\", err)\n\t\treturn\n\t}\n\tdefer db.Close()\n\t// now we can expect operations performed on db\n\tmock.ExpectBegin().WillReturnError(fmt.Errorf(\"an error will occur on db.Begin() call\"))\n}\n\nfunc TestShouldOpenConnectionIssue15(t *testing.T) {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"expected no error, but got: %s\", err)\n\t}\n\tif len(pool.conns) != 1 {\n\t\tt.Errorf(\"expected 1 connection in pool, but there is: %d\", len(pool.conns))\n\t}\n\n\tsmock, _ := mock.(*sqlmock)\n\tif smock.opened != 1 {\n\t\tt.Errorf(\"expected 1 connection on mock to be opened, but there is: %d\", smock.opened)\n\t}\n\n\t// defer so the rows gets closed first\n\tdefer func() {\n\t\tif smock.opened != 0 {\n\t\t\tt.Errorf(\"expected no connections on mock to be opened, but there is: %d\", smock.opened)\n\t\t}\n\t}()\n\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(NewRows([]string{\"one\", \"two\"}).AddRow(\"val1\", \"val2\"))\n\trows, err := db.Query(\"SELECT\")\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %s\", err)\n\t}\n\tdefer rows.Close()\n\n\tmock.ExpectExec(\"UPDATE\").WillReturnResult(NewResult(1, 1))\n\tif _, err = db.Exec(\"UPDATE\"); err != nil {\n\t\tt.Errorf(\"unexpected error: %s\", err)\n\t}\n\n\t// now there should be two connections open\n\tif smock.opened != 2 {\n\t\tt.Errorf(\"expected 2 connection on mock to be opened, but there is: %d\", smock.opened)\n\t}\n\n\tmock.ExpectClose()\n\tif err = db.Close(); err != nil {\n\t\tt.Errorf(\"expected no error on close, but got: %s\", err)\n\t}\n\n\t// one is still reserved for rows\n\tif smock.opened != 1 {\n\t\tt.Errorf(\"expected 1 connection on mock to be still reserved for rows, but there is: %d\", smock.opened)\n\t}\n}\n\nfunc TestTwoOpenConnectionsOnTheSameDSN(t *testing.T) {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"expected no error, but got: %s\", err)\n\t}\n\tdb2, mock2, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"expected no error, but got: %s\", err)\n\t}\n\tif len(pool.conns) != 2 {\n\t\tt.Errorf(\"expected 2 connection in pool, but there is: %d\", len(pool.conns))\n\t}\n\n\tif db == db2 {\n\t\tt.Errorf(\"expected not the same database instance, but it is the same\")\n\t}\n\tif mock == mock2 {\n\t\tt.Errorf(\"expected not the same mock instance, but it is the same\")\n\t}\n}\n\nfunc TestWithOptions(t *testing.T) {\n\tc := &converter{}\n\t_, mock, err := New(ValueConverterOption(c))\n\tif err != nil {\n\t\tt.Errorf(\"expected no error, but got: %s\", err)\n\t}\n\tsmock, _ := mock.(*sqlmock)\n\tif smock.converter.(*converter) != c {\n\t\tt.Errorf(\"expected a custom converter to be set\")\n\t}\n}\n\nfunc TestWrongDSN(t *testing.T) {\n\tt.Parallel()\n\tdb, _, _ := New()\n\tdefer db.Close()\n\tif _, err := db.Driver().Open(\"wrong_dsn\"); err == nil {\n\t\tt.Error(\"expected error on Open\")\n\t}\n}\n\nfunc TestNewDSN(t *testing.T) {\n\tif _, _, err := NewWithDSN(\"sqlmock_db_99\"); err != nil {\n\t\tt.Errorf(\"expected no error on NewWithDSN, but got: %s\", err)\n\t}\n}\n\nfunc TestDuplicateNewDSN(t *testing.T) {\n\tif _, _, err := NewWithDSN(\"sqlmock_db_1\"); err == nil {\n\t\tt.Error(\"expected error on NewWithDSN\")\n\t}\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "expectations.go",
          "type": "blob",
          "size": 11.5146484375,
          "content": "package sqlmock\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\n// an expectation interface\ntype expectation interface {\n\tfulfilled() bool\n\tLock()\n\tUnlock()\n\tString() string\n}\n\n// common expectation struct\n// satisfies the expectation interface\ntype commonExpectation struct {\n\tsync.Mutex\n\ttriggered bool\n\terr       error\n}\n\nfunc (e *commonExpectation) fulfilled() bool {\n\treturn e.triggered\n}\n\n// ExpectedClose is used to manage *sql.DB.Close expectation\n// returned by *Sqlmock.ExpectClose.\ntype ExpectedClose struct {\n\tcommonExpectation\n}\n\n// WillReturnError allows to set an error for *sql.DB.Close action\nfunc (e *ExpectedClose) WillReturnError(err error) *ExpectedClose {\n\te.err = err\n\treturn e\n}\n\n// String returns string representation\nfunc (e *ExpectedClose) String() string {\n\tmsg := \"ExpectedClose => expecting database Close\"\n\tif e.err != nil {\n\t\tmsg += fmt.Sprintf(\", which should return error: %s\", e.err)\n\t}\n\treturn msg\n}\n\n// ExpectedBegin is used to manage *sql.DB.Begin expectation\n// returned by *Sqlmock.ExpectBegin.\ntype ExpectedBegin struct {\n\tcommonExpectation\n\tdelay  time.Duration\n\ttxOpts *driver.TxOptions\n}\n\n// WillReturnError allows to set an error for *sql.DB.Begin action\nfunc (e *ExpectedBegin) WillReturnError(err error) *ExpectedBegin {\n\te.err = err\n\treturn e\n}\n\n// String returns string representation\nfunc (e *ExpectedBegin) String() string {\n\tmsg := \"ExpectedBegin => expecting database transaction Begin\"\n\tif e.txOpts != nil {\n\t\tmsg += fmt.Sprintf(\", with tx options: %+v\", e.txOpts)\n\t}\n\tif e.err != nil {\n\t\tmsg += fmt.Sprintf(\", which should return error: %s\", e.err)\n\t}\n\treturn msg\n}\n\n// WillDelayFor allows to specify duration for which it will delay\n// result. May be used together with Context\nfunc (e *ExpectedBegin) WillDelayFor(duration time.Duration) *ExpectedBegin {\n\te.delay = duration\n\treturn e\n}\n\n// WithTxOptions allows to set transaction options for *sql.DB.Begin action\nfunc (e *ExpectedBegin) WithTxOptions(opts sql.TxOptions) *ExpectedBegin {\n\te.txOpts = &driver.TxOptions{\n\t\tIsolation: driver.IsolationLevel(opts.Isolation),\n\t\tReadOnly:  opts.ReadOnly,\n\t}\n\treturn e\n}\n\n// ExpectedCommit is used to manage *sql.Tx.Commit expectation\n// returned by *Sqlmock.ExpectCommit.\ntype ExpectedCommit struct {\n\tcommonExpectation\n}\n\n// WillReturnError allows to set an error for *sql.Tx.Close action\nfunc (e *ExpectedCommit) WillReturnError(err error) *ExpectedCommit {\n\te.err = err\n\treturn e\n}\n\n// String returns string representation\nfunc (e *ExpectedCommit) String() string {\n\tmsg := \"ExpectedCommit => expecting transaction Commit\"\n\tif e.err != nil {\n\t\tmsg += fmt.Sprintf(\", which should return error: %s\", e.err)\n\t}\n\treturn msg\n}\n\n// ExpectedRollback is used to manage *sql.Tx.Rollback expectation\n// returned by *Sqlmock.ExpectRollback.\ntype ExpectedRollback struct {\n\tcommonExpectation\n}\n\n// WillReturnError allows to set an error for *sql.Tx.Rollback action\nfunc (e *ExpectedRollback) WillReturnError(err error) *ExpectedRollback {\n\te.err = err\n\treturn e\n}\n\n// String returns string representation\nfunc (e *ExpectedRollback) String() string {\n\tmsg := \"ExpectedRollback => expecting transaction Rollback\"\n\tif e.err != nil {\n\t\tmsg += fmt.Sprintf(\", which should return error: %s\", e.err)\n\t}\n\treturn msg\n}\n\n// ExpectedQuery is used to manage *sql.DB.Query, *dql.DB.QueryRow, *sql.Tx.Query,\n// *sql.Tx.QueryRow, *sql.Stmt.Query or *sql.Stmt.QueryRow expectations.\n// Returned by *Sqlmock.ExpectQuery.\ntype ExpectedQuery struct {\n\tqueryBasedExpectation\n\trows             driver.Rows\n\tdelay            time.Duration\n\trowsMustBeClosed bool\n\trowsWereClosed   bool\n}\n\n// WithArgs will match given expected args to actual database query arguments.\n// if at least one argument does not match, it will return an error. For specific\n// arguments an sqlmock.Argument interface can be used to match an argument.\n// Must not be used together with WithoutArgs()\nfunc (e *ExpectedQuery) WithArgs(args ...driver.Value) *ExpectedQuery {\n\tif e.noArgs {\n\t\tpanic(\"WithArgs() and WithoutArgs() must not be used together\")\n\t}\n\te.args = args\n\treturn e\n}\n\n// WithoutArgs will ensure that no arguments are passed for this query.\n// if at least one argument is passed, it will return an error. This allows\n// for stricter validation of the query arguments.\n// Must no be used together with WithArgs()\nfunc (e *ExpectedQuery) WithoutArgs() *ExpectedQuery {\n\tif len(e.args) > 0 {\n\t\tpanic(\"WithoutArgs() and WithArgs() must not be used together\")\n\t}\n\te.noArgs = true\n\treturn e\n}\n\n// RowsWillBeClosed expects this query rows to be closed.\nfunc (e *ExpectedQuery) RowsWillBeClosed() *ExpectedQuery {\n\te.rowsMustBeClosed = true\n\treturn e\n}\n\n// WillReturnError allows to set an error for expected database query\nfunc (e *ExpectedQuery) WillReturnError(err error) *ExpectedQuery {\n\te.err = err\n\treturn e\n}\n\n// WillDelayFor allows to specify duration for which it will delay\n// result. May be used together with Context\nfunc (e *ExpectedQuery) WillDelayFor(duration time.Duration) *ExpectedQuery {\n\te.delay = duration\n\treturn e\n}\n\n// String returns string representation\nfunc (e *ExpectedQuery) String() string {\n\tmsg := \"ExpectedQuery => expecting Query, QueryContext or QueryRow which:\"\n\tmsg += \"\\n  - matches sql: '\" + e.expectSQL + \"'\"\n\n\tif len(e.args) == 0 {\n\t\tmsg += \"\\n  - is without arguments\"\n\t} else {\n\t\tmsg += \"\\n  - is with arguments:\\n\"\n\t\tfor i, arg := range e.args {\n\t\t\tmsg += fmt.Sprintf(\"    %d - %+v\\n\", i, arg)\n\t\t}\n\t\tmsg = strings.TrimSpace(msg)\n\t}\n\n\tif e.rows != nil {\n\t\tmsg += fmt.Sprintf(\"\\n  - %s\", e.rows)\n\t}\n\n\tif e.err != nil {\n\t\tmsg += fmt.Sprintf(\"\\n  - should return error: %s\", e.err)\n\t}\n\n\treturn msg\n}\n\n// ExpectedExec is used to manage *sql.DB.Exec, *sql.Tx.Exec or *sql.Stmt.Exec expectations.\n// Returned by *Sqlmock.ExpectExec.\ntype ExpectedExec struct {\n\tqueryBasedExpectation\n\tresult driver.Result\n\tdelay  time.Duration\n}\n\n// WithArgs will match given expected args to actual database exec operation arguments.\n// if at least one argument does not match, it will return an error. For specific\n// arguments an sqlmock.Argument interface can be used to match an argument.\n// Must not be used together with WithoutArgs()\nfunc (e *ExpectedExec) WithArgs(args ...driver.Value) *ExpectedExec {\n\tif len(e.args) > 0 {\n\t\tpanic(\"WithArgs() and WithoutArgs() must not be used together\")\n\t}\n\te.args = args\n\treturn e\n}\n\n// WithoutArgs will ensure that no args are passed for this expected database exec action.\n// if at least one argument is passed, it will return an error. This allows for stricter\n// validation of the query arguments.\n// Must not be used together with WithArgs()\nfunc (e *ExpectedExec) WithoutArgs() *ExpectedExec {\n\tif len(e.args) > 0 {\n\t\tpanic(\"WithoutArgs() and WithArgs() must not be used together\")\n\t}\n\te.noArgs = true\n\treturn e\n}\n\n// WillReturnError allows to set an error for expected database exec action\nfunc (e *ExpectedExec) WillReturnError(err error) *ExpectedExec {\n\te.err = err\n\treturn e\n}\n\n// WillDelayFor allows to specify duration for which it will delay\n// result. May be used together with Context\nfunc (e *ExpectedExec) WillDelayFor(duration time.Duration) *ExpectedExec {\n\te.delay = duration\n\treturn e\n}\n\n// String returns string representation\nfunc (e *ExpectedExec) String() string {\n\tmsg := \"ExpectedExec => expecting Exec or ExecContext which:\"\n\tmsg += \"\\n  - matches sql: '\" + e.expectSQL + \"'\"\n\n\tif len(e.args) == 0 {\n\t\tmsg += \"\\n  - is without arguments\"\n\t} else {\n\t\tmsg += \"\\n  - is with arguments:\\n\"\n\t\tvar margs []string\n\t\tfor i, arg := range e.args {\n\t\t\tmargs = append(margs, fmt.Sprintf(\"    %d - %+v\", i, arg))\n\t\t}\n\t\tmsg += strings.Join(margs, \"\\n\")\n\t}\n\n\tif e.result != nil {\n\t\tif res, ok := e.result.(*result); ok {\n\t\t\tmsg += \"\\n  - should return Result having:\"\n\t\t\tmsg += fmt.Sprintf(\"\\n      LastInsertId: %d\", res.insertID)\n\t\t\tmsg += fmt.Sprintf(\"\\n      RowsAffected: %d\", res.rowsAffected)\n\t\t\tif res.err != nil {\n\t\t\t\tmsg += fmt.Sprintf(\"\\n      Error: %s\", res.err)\n\t\t\t}\n\t\t}\n\t}\n\n\tif e.err != nil {\n\t\tmsg += fmt.Sprintf(\"\\n  - should return error: %s\", e.err)\n\t}\n\n\treturn msg\n}\n\n// WillReturnResult arranges for an expected Exec() to return a particular\n// result, there is sqlmock.NewResult(lastInsertID int64, affectedRows int64) method\n// to build a corresponding result. Or if actions needs to be tested against errors\n// sqlmock.NewErrorResult(err error) to return a given error.\nfunc (e *ExpectedExec) WillReturnResult(result driver.Result) *ExpectedExec {\n\te.result = result\n\treturn e\n}\n\n// ExpectedPrepare is used to manage *sql.DB.Prepare or *sql.Tx.Prepare expectations.\n// Returned by *Sqlmock.ExpectPrepare.\ntype ExpectedPrepare struct {\n\tcommonExpectation\n\tmock         *sqlmock\n\texpectSQL    string\n\tstatement    driver.Stmt\n\tcloseErr     error\n\tmustBeClosed bool\n\twasClosed    bool\n\tdelay        time.Duration\n}\n\n// WillReturnError allows to set an error for the expected *sql.DB.Prepare or *sql.Tx.Prepare action.\nfunc (e *ExpectedPrepare) WillReturnError(err error) *ExpectedPrepare {\n\te.err = err\n\treturn e\n}\n\n// WillReturnCloseError allows to set an error for this prepared statement Close action\nfunc (e *ExpectedPrepare) WillReturnCloseError(err error) *ExpectedPrepare {\n\te.closeErr = err\n\treturn e\n}\n\n// WillDelayFor allows to specify duration for which it will delay\n// result. May be used together with Context\nfunc (e *ExpectedPrepare) WillDelayFor(duration time.Duration) *ExpectedPrepare {\n\te.delay = duration\n\treturn e\n}\n\n// WillBeClosed expects this prepared statement to\n// be closed.\nfunc (e *ExpectedPrepare) WillBeClosed() *ExpectedPrepare {\n\te.mustBeClosed = true\n\treturn e\n}\n\n// ExpectQuery allows to expect Query() or QueryRow() on this prepared statement.\n// This method is convenient in order to prevent duplicating sql query string matching.\nfunc (e *ExpectedPrepare) ExpectQuery() *ExpectedQuery {\n\teq := &ExpectedQuery{}\n\teq.expectSQL = e.expectSQL\n\teq.converter = e.mock.converter\n\te.mock.expected = append(e.mock.expected, eq)\n\treturn eq\n}\n\n// ExpectExec allows to expect Exec() on this prepared statement.\n// This method is convenient in order to prevent duplicating sql query string matching.\nfunc (e *ExpectedPrepare) ExpectExec() *ExpectedExec {\n\teq := &ExpectedExec{}\n\teq.expectSQL = e.expectSQL\n\teq.converter = e.mock.converter\n\te.mock.expected = append(e.mock.expected, eq)\n\treturn eq\n}\n\n// String returns string representation\nfunc (e *ExpectedPrepare) String() string {\n\tmsg := \"ExpectedPrepare => expecting Prepare statement which:\"\n\tmsg += \"\\n  - matches sql: '\" + e.expectSQL + \"'\"\n\n\tif e.err != nil {\n\t\tmsg += fmt.Sprintf(\"\\n  - should return error: %s\", e.err)\n\t}\n\n\tif e.closeErr != nil {\n\t\tmsg += fmt.Sprintf(\"\\n  - should return error on Close: %s\", e.closeErr)\n\t}\n\n\treturn msg\n}\n\n// query based expectation\n// adds a query matching logic\ntype queryBasedExpectation struct {\n\tcommonExpectation\n\texpectSQL string\n\tconverter driver.ValueConverter\n\targs      []driver.Value\n\tnoArgs    bool // ensure no args are passed\n}\n\n// ExpectedPing is used to manage *sql.DB.Ping expectations.\n// Returned by *Sqlmock.ExpectPing.\ntype ExpectedPing struct {\n\tcommonExpectation\n\tdelay time.Duration\n}\n\n// WillDelayFor allows to specify duration for which it will delay result. May\n// be used together with Context.\nfunc (e *ExpectedPing) WillDelayFor(duration time.Duration) *ExpectedPing {\n\te.delay = duration\n\treturn e\n}\n\n// WillReturnError allows to set an error for expected database ping\nfunc (e *ExpectedPing) WillReturnError(err error) *ExpectedPing {\n\te.err = err\n\treturn e\n}\n\n// String returns string representation\nfunc (e *ExpectedPing) String() string {\n\tmsg := \"ExpectedPing => expecting database Ping\"\n\tif e.err != nil {\n\t\tmsg += fmt.Sprintf(\", which should return error: %s\", e.err)\n\t}\n\treturn msg\n}\n"
        },
        {
          "name": "expectations_before_go18.go",
          "type": "blob",
          "size": 1.75390625,
          "content": "//go:build !go1.8\n// +build !go1.8\n\npackage sqlmock\n\nimport (\n\t\"database/sql/driver\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// WillReturnRows specifies the set of resulting rows that will be returned\n// by the triggered query\nfunc (e *ExpectedQuery) WillReturnRows(rows *Rows) *ExpectedQuery {\n\te.rows = &rowSets{sets: []*Rows{rows}, ex: e}\n\treturn e\n}\n\nfunc (e *queryBasedExpectation) argsMatches(args []namedValue) error {\n\tif nil == e.args {\n\t\tif e.noArgs && len(args) > 0 {\n\t\t\treturn fmt.Errorf(\"expected 0, but got %d arguments\", len(args))\n\t\t}\n\t\treturn nil\n\t}\n\tif len(args) != len(e.args) {\n\t\treturn fmt.Errorf(\"expected %d, but got %d arguments\", len(e.args), len(args))\n\t}\n\tfor k, v := range args {\n\t\t// custom argument matcher\n\t\tmatcher, ok := e.args[k].(Argument)\n\t\tif ok {\n\t\t\t// @TODO: does it make sense to pass value instead of named value?\n\t\t\tif !matcher.Match(v.Value) {\n\t\t\t\treturn fmt.Errorf(\"matcher %T could not match %d argument %T - %+v\", matcher, k, args[k], args[k])\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tdval := e.args[k]\n\t\t// convert to driver converter\n\t\tdarg, err := e.converter.ConvertValue(dval)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could not convert %d argument %T - %+v to driver value: %s\", k, e.args[k], e.args[k], err)\n\t\t}\n\n\t\tif !driver.IsValue(darg) {\n\t\t\treturn fmt.Errorf(\"argument %d: non-subset type %T returned from Value\", k, darg)\n\t\t}\n\n\t\tif !reflect.DeepEqual(darg, v.Value) {\n\t\t\treturn fmt.Errorf(\"argument %d expected [%T - %+v] does not match actual [%T - %+v]\", k, darg, darg, v.Value, v.Value)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (e *queryBasedExpectation) attemptArgMatch(args []namedValue) (err error) {\n\t// catch panic\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\t_, ok := e.(error)\n\t\t\tif !ok {\n\t\t\t\terr = fmt.Errorf(e.(string))\n\t\t\t}\n\t\t}\n\t}()\n\n\terr = e.argsMatches(args)\n\treturn\n}\n"
        },
        {
          "name": "expectations_before_go18_test.go",
          "type": "blob",
          "size": 3.552734375,
          "content": "//go:build !go1.8\n// +build !go1.8\n\npackage sqlmock\n\nimport (\n\t\"database/sql/driver\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestQueryExpectationArgComparison(t *testing.T) {\n\te := &queryBasedExpectation{converter: driver.DefaultParameterConverter, noArgs: true}\n\tagainst := []namedValue{{Value: int64(5), Ordinal: 1}}\n\tif err := e.argsMatches(against); err == nil {\n\t\tt.Error(\"arguments should not match, since argument was passed, but noArgs was set\")\n\t}\n\n\te.noArgs = false\n\tif err := e.argsMatches(against); err != nil {\n\t\tt.Error(\"arguments should match, since argument was passed, but no expected args or noArgs was set\")\n\t}\n\n\te.args = []driver.Value{5, \"str\"}\n\n\tagainst = []namedValue{{Value: int64(5), Ordinal: 1}}\n\tif err := e.argsMatches(against); err == nil {\n\t\tt.Error(\"arguments should not match, since the size is not the same\")\n\t}\n\n\tagainst = []namedValue{\n\t\t{Value: int64(3), Ordinal: 1},\n\t\t{Value: \"str\", Ordinal: 2},\n\t}\n\tif err := e.argsMatches(against); err == nil {\n\t\tt.Error(\"arguments should not match, since the first argument (int value) is different\")\n\t}\n\n\tagainst = []namedValue{\n\t\t{Value: int64(5), Ordinal: 1},\n\t\t{Value: \"st\", Ordinal: 2},\n\t}\n\tif err := e.argsMatches(against); err == nil {\n\t\tt.Error(\"arguments should not match, since the second argument (string value) is different\")\n\t}\n\n\tagainst = []namedValue{\n\t\t{Value: int64(5), Ordinal: 1},\n\t\t{Value: \"str\", Ordinal: 2},\n\t}\n\tif err := e.argsMatches(against); err != nil {\n\t\tt.Errorf(\"arguments should match, but it did not: %s\", err)\n\t}\n\n\tconst longForm = \"Jan 2, 2006 at 3:04pm (MST)\"\n\ttm, _ := time.Parse(longForm, \"Feb 3, 2013 at 7:54pm (PST)\")\n\te.args = []driver.Value{5, tm}\n\n\tagainst = []namedValue{\n\t\t{Value: int64(5), Ordinal: 1},\n\t\t{Value: tm, Ordinal: 2},\n\t}\n\tif err := e.argsMatches(against); err != nil {\n\t\tt.Error(\"arguments should match, but it did not\")\n\t}\n\n\te.args = []driver.Value{5, AnyArg()}\n\tif err := e.argsMatches(against); err != nil {\n\t\tt.Errorf(\"arguments should match, but it did not: %s\", err)\n\t}\n}\n\nfunc TestQueryExpectationArgComparisonBool(t *testing.T) {\n\tvar e *queryBasedExpectation\n\n\te = &queryBasedExpectation{args: []driver.Value{true}, converter: driver.DefaultParameterConverter}\n\tagainst := []namedValue{\n\t\t{Value: true, Ordinal: 1},\n\t}\n\tif err := e.argsMatches(against); err != nil {\n\t\tt.Error(\"arguments should match, since arguments are the same\")\n\t}\n\n\te = &queryBasedExpectation{args: []driver.Value{false}, converter: driver.DefaultParameterConverter}\n\tagainst = []namedValue{\n\t\t{Value: false, Ordinal: 1},\n\t}\n\tif err := e.argsMatches(against); err != nil {\n\t\tt.Error(\"arguments should match, since argument are the same\")\n\t}\n\n\te = &queryBasedExpectation{args: []driver.Value{true}, converter: driver.DefaultParameterConverter}\n\tagainst = []namedValue{\n\t\t{Value: false, Ordinal: 1},\n\t}\n\tif err := e.argsMatches(against); err == nil {\n\t\tt.Error(\"arguments should not match, since argument is different\")\n\t}\n\n\te = &queryBasedExpectation{args: []driver.Value{false}, converter: driver.DefaultParameterConverter}\n\tagainst = []namedValue{\n\t\t{Value: true, Ordinal: 1},\n\t}\n\tif err := e.argsMatches(against); err == nil {\n\t\tt.Error(\"arguments should not match, since argument is different\")\n\t}\n}\n\ntype panicConverter struct {\n}\n\nfunc (s panicConverter) ConvertValue(v interface{}) (driver.Value, error) {\n\tpanic(v)\n}\n\nfunc Test_queryBasedExpectation_attemptArgMatch(t *testing.T) {\n\te := &queryBasedExpectation{converter: new(panicConverter), args: []driver.Value{\"test\"}}\n\tvalues := []namedValue{\n\t\t{Ordinal: 1, Name: \"test\", Value: \"test\"},\n\t}\n\tif err := e.attemptArgMatch(values); err == nil {\n\t\tt.Errorf(\"error expected\")\n\t}\n}\n"
        },
        {
          "name": "expectations_go18.go",
          "type": "blob",
          "size": 2.25,
          "content": "//go:build go1.8\n// +build go1.8\n\npackage sqlmock\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// WillReturnRows specifies the set of resulting rows that will be returned\n// by the triggered query\nfunc (e *ExpectedQuery) WillReturnRows(rows ...*Rows) *ExpectedQuery {\n\tdefs := 0\n\tsets := make([]*Rows, len(rows))\n\tfor i, r := range rows {\n\t\tsets[i] = r\n\t\tif r != nil && r.def != nil {\n\t\t\tdefs++\n\t\t}\n\t}\n\tif defs > 0 && defs == len(sets) {\n\t\te.rows = &rowSetsWithDefinition{&rowSets{sets: sets, ex: e}}\n\t} else {\n\t\te.rows = &rowSets{sets: sets, ex: e}\n\t}\n\treturn e\n}\n\nfunc (e *queryBasedExpectation) argsMatches(args []driver.NamedValue) error {\n\tif nil == e.args {\n\t\tif e.noArgs && len(args) > 0 {\n\t\t\treturn fmt.Errorf(\"expected 0, but got %d arguments\", len(args))\n\t\t}\n\t\treturn nil\n\t}\n\tif len(args) != len(e.args) {\n\t\treturn fmt.Errorf(\"expected %d, but got %d arguments\", len(e.args), len(args))\n\t}\n\t// @TODO should we assert either all args are named or ordinal?\n\tfor k, v := range args {\n\t\t// custom argument matcher\n\t\tmatcher, ok := e.args[k].(Argument)\n\t\tif ok {\n\t\t\tif !matcher.Match(v.Value) {\n\t\t\t\treturn fmt.Errorf(\"matcher %T could not match %d argument %T - %+v\", matcher, k, args[k], args[k])\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tdval := e.args[k]\n\t\tif named, isNamed := dval.(sql.NamedArg); isNamed {\n\t\t\tdval = named.Value\n\t\t\tif v.Name != named.Name {\n\t\t\t\treturn fmt.Errorf(\"named argument %d: name: \\\"%s\\\" does not match expected: \\\"%s\\\"\", k, v.Name, named.Name)\n\t\t\t}\n\t\t} else if k+1 != v.Ordinal {\n\t\t\treturn fmt.Errorf(\"argument %d: ordinal position: %d does not match expected: %d\", k, k+1, v.Ordinal)\n\t\t}\n\n\t\t// convert to driver converter\n\t\tdarg, err := e.converter.ConvertValue(dval)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could not convert %d argument %T - %+v to driver value: %s\", k, e.args[k], e.args[k], err)\n\t\t}\n\n\t\tif !reflect.DeepEqual(darg, v.Value) {\n\t\t\treturn fmt.Errorf(\"argument %d expected [%T - %+v] does not match actual [%T - %+v]\", k, darg, darg, v.Value, v.Value)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (e *queryBasedExpectation) attemptArgMatch(args []driver.NamedValue) (err error) {\n\t// catch panic\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\t_, ok := e.(error)\n\t\t\tif !ok {\n\t\t\t\terr = fmt.Errorf(e.(string))\n\t\t\t}\n\t\t}\n\t}()\n\n\terr = e.argsMatches(args)\n\treturn\n}\n"
        },
        {
          "name": "expectations_go18_test.go",
          "type": "blob",
          "size": 5.2705078125,
          "content": "//go:build go1.8\n// +build go1.8\n\npackage sqlmock\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestQueryExpectationArgComparison(t *testing.T) {\n\te := &queryBasedExpectation{converter: driver.DefaultParameterConverter, noArgs: true}\n\tagainst := []driver.NamedValue{{Value: int64(5), Ordinal: 1}}\n\tif err := e.argsMatches(against); err == nil {\n\t\tt.Error(\"arguments should not match, since argument was passed, but noArgs was set\")\n\t}\n\n\te.noArgs = false\n\tif err := e.argsMatches(against); err != nil {\n\t\tt.Error(\"arguments should match, since argument was passed, but no expected args or noArgs was set\")\n\t}\n\n\te.args = []driver.Value{5, \"str\"}\n\n\tagainst = []driver.NamedValue{{Value: int64(5), Ordinal: 1}}\n\tif err := e.argsMatches(against); err == nil {\n\t\tt.Error(\"arguments should not match, since the size is not the same\")\n\t}\n\n\tagainst = []driver.NamedValue{\n\t\t{Value: int64(3), Ordinal: 1},\n\t\t{Value: \"str\", Ordinal: 2},\n\t}\n\tif err := e.argsMatches(against); err == nil {\n\t\tt.Error(\"arguments should not match, since the first argument (int value) is different\")\n\t}\n\n\tagainst = []driver.NamedValue{\n\t\t{Value: int64(5), Ordinal: 1},\n\t\t{Value: \"st\", Ordinal: 2},\n\t}\n\tif err := e.argsMatches(against); err == nil {\n\t\tt.Error(\"arguments should not match, since the second argument (string value) is different\")\n\t}\n\n\tagainst = []driver.NamedValue{\n\t\t{Value: int64(5), Ordinal: 1},\n\t\t{Value: \"str\", Ordinal: 2},\n\t}\n\tif err := e.argsMatches(against); err != nil {\n\t\tt.Errorf(\"arguments should match, but it did not: %s\", err)\n\t}\n\n\tconst longForm = \"Jan 2, 2006 at 3:04pm (MST)\"\n\ttm, _ := time.Parse(longForm, \"Feb 3, 2013 at 7:54pm (PST)\")\n\te.args = []driver.Value{5, tm}\n\n\tagainst = []driver.NamedValue{\n\t\t{Value: int64(5), Ordinal: 1},\n\t\t{Value: tm, Ordinal: 2},\n\t}\n\tif err := e.argsMatches(against); err != nil {\n\t\tt.Error(\"arguments should match, but it did not\")\n\t}\n\n\te.args = []driver.Value{5, AnyArg()}\n\tif err := e.argsMatches(against); err != nil {\n\t\tt.Errorf(\"arguments should match, but it did not: %s\", err)\n\t}\n}\n\nfunc TestQueryExpectationArgComparisonBool(t *testing.T) {\n\tvar e *queryBasedExpectation\n\n\te = &queryBasedExpectation{args: []driver.Value{true}, converter: driver.DefaultParameterConverter}\n\tagainst := []driver.NamedValue{\n\t\t{Value: true, Ordinal: 1},\n\t}\n\tif err := e.argsMatches(against); err != nil {\n\t\tt.Error(\"arguments should match, since arguments are the same\")\n\t}\n\n\te = &queryBasedExpectation{args: []driver.Value{false}, converter: driver.DefaultParameterConverter}\n\tagainst = []driver.NamedValue{\n\t\t{Value: false, Ordinal: 1},\n\t}\n\tif err := e.argsMatches(against); err != nil {\n\t\tt.Error(\"arguments should match, since argument are the same\")\n\t}\n\n\te = &queryBasedExpectation{args: []driver.Value{true}, converter: driver.DefaultParameterConverter}\n\tagainst = []driver.NamedValue{\n\t\t{Value: false, Ordinal: 1},\n\t}\n\tif err := e.argsMatches(against); err == nil {\n\t\tt.Error(\"arguments should not match, since argument is different\")\n\t}\n\n\te = &queryBasedExpectation{args: []driver.Value{false}, converter: driver.DefaultParameterConverter}\n\tagainst = []driver.NamedValue{\n\t\t{Value: true, Ordinal: 1},\n\t}\n\tif err := e.argsMatches(against); err == nil {\n\t\tt.Error(\"arguments should not match, since argument is different\")\n\t}\n}\n\nfunc TestQueryExpectationNamedArgComparison(t *testing.T) {\n\te := &queryBasedExpectation{converter: driver.DefaultParameterConverter, noArgs: true}\n\tagainst := []driver.NamedValue{{Value: int64(5), Name: \"id\"}}\n\tif err := e.argsMatches(against); err == nil {\n\t\tt.Error(\"arguments should not match, since argument was passed, but noArgs was set\")\n\t}\n\n\te.noArgs = false\n\tif err := e.argsMatches(against); err != nil {\n\t\tt.Error(\"arguments should match, since argument was passed, but no expected args or noArgs was set\")\n\t}\n\n\te.args = []driver.Value{\n\t\tsql.Named(\"id\", 5),\n\t\tsql.Named(\"s\", \"str\"),\n\t}\n\n\tif err := e.argsMatches(against); err == nil {\n\t\tt.Error(\"arguments should not match, since the size is not the same\")\n\t}\n\n\tagainst = []driver.NamedValue{\n\t\t{Value: int64(5), Name: \"id\"},\n\t\t{Value: \"str\", Name: \"s\"},\n\t}\n\n\tif err := e.argsMatches(against); err != nil {\n\t\tt.Errorf(\"arguments should have matched, but it did not: %v\", err)\n\t}\n\n\tagainst = []driver.NamedValue{\n\t\t{Value: int64(5), Name: \"id\"},\n\t\t{Value: \"str\", Name: \"username\"},\n\t}\n\n\tif err := e.argsMatches(against); err == nil {\n\t\tt.Error(\"arguments matched, but it should have not due to Name\")\n\t}\n\n\te.args = []driver.Value{int64(5), \"str\"}\n\n\tagainst = []driver.NamedValue{\n\t\t{Value: int64(5), Ordinal: 0},\n\t\t{Value: \"str\", Ordinal: 1},\n\t}\n\n\tif err := e.argsMatches(against); err == nil {\n\t\tt.Error(\"arguments matched, but it should have not due to wrong Ordinal position\")\n\t}\n\n\tagainst = []driver.NamedValue{\n\t\t{Value: int64(5), Ordinal: 1},\n\t\t{Value: \"str\", Ordinal: 2},\n\t}\n\n\tif err := e.argsMatches(against); err != nil {\n\t\tt.Errorf(\"arguments should have matched, but it did not: %v\", err)\n\t}\n}\n\ntype panicConverter struct {\n}\n\nfunc (s panicConverter) ConvertValue(v interface{}) (driver.Value, error) {\n\tpanic(v)\n}\n\nfunc Test_queryBasedExpectation_attemptArgMatch(t *testing.T) {\n\te := &queryBasedExpectation{converter: new(panicConverter), args: []driver.Value{\"test\"}}\n\tvalues := []driver.NamedValue{\n\t\t{Ordinal: 1, Name: \"test\", Value: \"test\"},\n\t}\n\tif err := e.attemptArgMatch(values); err == nil {\n\t\tt.Errorf(\"error expected\")\n\t}\n}\n"
        },
        {
          "name": "expectations_go19_test.go",
          "type": "blob",
          "size": 0.94140625,
          "content": "// +build go1.9\n\npackage sqlmock\n\nimport (\n\t\"context\"\n\t\"testing\"\n)\n\nfunc TestCustomValueConverterExec(t *testing.T) {\n\tdb, mock, _ := New(ValueConverterOption(CustomConverter{}))\n\texpectedQuery := \"INSERT INTO tags \\\\(name,email,age,hobbies\\\\) VALUES \\\\(\\\\?,\\\\?,\\\\?,\\\\?\\\\)\"\n\tquery := \"INSERT INTO tags (name,email,age,hobbies) VALUES (?,?,?,?)\"\n\tname := \"John\"\n\temail := \"j@jj.j\"\n\tage := 12\n\thobbies := []string{\"soccer\", \"netflix\"}\n\tmock.ExpectBegin()\n\tmock.ExpectPrepare(expectedQuery)\n\tmock.ExpectExec(expectedQuery).WithArgs(name, email, age, hobbies).WillReturnResult(NewResult(1, 1))\n\tmock.ExpectCommit()\n\n\tctx := context.Background()\n\ttx, e := db.BeginTx(ctx, nil)\n\tif e != nil {\n\t\tt.Error(e)\n\t\treturn\n\t}\n\tstmt, e := db.PrepareContext(ctx, query)\n\tif e != nil {\n\t\tt.Error(e)\n\t\treturn\n\t}\n\t_, e = stmt.Exec(name, email, age, hobbies)\n\tif e != nil {\n\t\tt.Error(e)\n\t\treturn\n\t}\n\ttx.Commit()\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Error(err)\n\t}\n}\n"
        },
        {
          "name": "expectations_test.go",
          "type": "blob",
          "size": 3.2294921875,
          "content": "package sqlmock\n\nimport (\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n)\n\ntype CustomConverter struct{}\n\nfunc (s CustomConverter) ConvertValue(v interface{}) (driver.Value, error) {\n\tswitch v.(type) {\n\tcase string:\n\t\treturn v.(string), nil\n\tcase []string:\n\t\treturn v.([]string), nil\n\tcase int:\n\t\treturn v.(int), nil\n\tdefault:\n\t\treturn nil, errors.New(fmt.Sprintf(\"cannot convert %T with value %v\", v, v))\n\t}\n}\n\nfunc ExampleExpectedExec() {\n\tdb, mock, _ := New()\n\tresult := NewErrorResult(fmt.Errorf(\"some error\"))\n\tmock.ExpectExec(\"^INSERT (.+)\").WillReturnResult(result)\n\tres, _ := db.Exec(\"INSERT something\")\n\t_, err := res.LastInsertId()\n\tfmt.Println(err)\n\t// Output: some error\n}\n\nfunc TestBuildQuery(t *testing.T) {\n\tdb, mock, _ := New()\n\tquery := `\n\t\tSELECT\n\t\t\tname,\n\t\t\temail,\n\t\t\taddress,\n\t\t\tanotherfield\n\t\tFROM user\n\t\twhere\n\t\t\tname    = 'John'\n\t\t\tand\n\t\t\taddress = 'Jakarta'\n\n\t`\n\n\tmock.ExpectQuery(query)\n\tmock.ExpectExec(query)\n\tmock.ExpectPrepare(query)\n\n\tdb.QueryRow(query)\n\tdb.Exec(query)\n\tdb.Prepare(query)\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestCustomValueConverterQueryScan(t *testing.T) {\n\tdb, mock, _ := New(ValueConverterOption(CustomConverter{}))\n\tquery := `\n\t\tSELECT\n\t\t\tname,\n\t\t\temail,\n\t\t\taddress,\n\t\t\tanotherfield\n\t\tFROM user\n\t\twhere\n\t\t\tname    = 'John'\n\t\t\tand\n\t\t\taddress = 'Jakarta'\n\n\t`\n\texpectedStringValue := \"ValueOne\"\n\texpectedIntValue := 2\n\texpectedArrayValue := []string{\"Three\", \"Four\"}\n\tmock.ExpectQuery(query).WillReturnRows(mock.NewRows([]string{\"One\", \"Two\", \"Three\"}).AddRow(expectedStringValue, expectedIntValue, []string{\"Three\", \"Four\"}))\n\trow := db.QueryRow(query)\n\tvar stringValue string\n\tvar intValue int\n\tvar arrayValue []string\n\tif e := row.Scan(&stringValue, &intValue, &arrayValue); e != nil {\n\t\tt.Error(e)\n\t}\n\tif stringValue != expectedStringValue {\n\t\tt.Errorf(\"Expectation %s does not met: %s\", expectedStringValue, stringValue)\n\t}\n\tif intValue != expectedIntValue {\n\t\tt.Errorf(\"Expectation %d does not met: %d\", expectedIntValue, intValue)\n\t}\n\tif !reflect.DeepEqual(expectedArrayValue, arrayValue) {\n\t\tt.Errorf(\"Expectation %v does not met: %v\", expectedArrayValue, arrayValue)\n\t}\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestQueryWithNoArgsAndWithArgsPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\treturn\n\t\t}\n\t\tt.Error(\"Expected panic for using WithArgs and ExpectNoArgs together\")\n\t}()\n\tmock := &sqlmock{}\n\tmock.ExpectQuery(\"SELECT (.+) FROM user\").WithArgs(\"John\").WithoutArgs()\n}\n\nfunc TestExecWithNoArgsAndWithArgsPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\treturn\n\t\t}\n\t\tt.Error(\"Expected panic for using WithArgs and ExpectNoArgs together\")\n\t}()\n\tmock := &sqlmock{}\n\tmock.ExpectExec(\"^INSERT INTO user\").WithArgs(\"John\").WithoutArgs()\n}\n\n\nfunc TestQueryWillReturnsNil(t *testing.T) {\n\tt.Parallel()\n\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}()\n\n\tmock.ExpectQuery(\"SELECT (.+) FROM users WHERE (.+)\").WithArgs(\"test\").WillReturnRows(nil)\n\tquery := \"SELECT name, email FROM users WHERE name = ?\"\n\t_, err = mock.(*sqlmock).Query(query, []driver.Value{\"test\"})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1171875,
          "content": "module github.com/DATA-DOG/go-sqlmock\n\ngo 1.15\n\nrequire github.com/kisielk/sqlstruct v0.0.0-20201105191214-5f3e10d3ab46\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.2255859375,
          "content": "github.com/kisielk/sqlstruct v0.0.0-20201105191214-5f3e10d3ab46 h1:veS9QfglfvqAw2e+eeNT/SbGySq8ajECXJ9e4fPoLhY=\ngithub.com/kisielk/sqlstruct v0.0.0-20201105191214-5f3e10d3ab46/go.mod h1:yyMNCyc/Ib3bDTKd379tNMpB/7/H5TjM2Y9QJ5THLbE=\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 1.3154296875,
          "content": "package sqlmock\n\nimport \"database/sql/driver\"\n\n// SqlMockOption is the type defining an option used to configure an SqlMock at creation\ntype SqlMockOption func(*sqlmock) error\n\n// ValueConverterOption allows to create a sqlmock connection\n// with a custom ValueConverter to support drivers with special data types.\nfunc ValueConverterOption(converter driver.ValueConverter) SqlMockOption {\n\treturn func(s *sqlmock) error {\n\t\ts.converter = converter\n\t\treturn nil\n\t}\n}\n\n// QueryMatcherOption allows to customize SQL query matcher\n// and match SQL query strings in more sophisticated ways.\n// The default QueryMatcher is QueryMatcherRegexp.\nfunc QueryMatcherOption(queryMatcher QueryMatcher) SqlMockOption {\n\treturn func(s *sqlmock) error {\n\t\ts.queryMatcher = queryMatcher\n\t\treturn nil\n\t}\n}\n\n// MonitorPingsOption determines whether calls to Ping on the driver should be\n// observed and mocked.\n//\n// If true is passed, we will check these calls were expected. Expectations can\n// be registered using the ExpectPing() method on the mock.\n//\n// If false is passed or this option is omitted, calls to Ping will not be\n// considered when determining expectations and calls to ExpectPing will have\n// no effect.\nfunc MonitorPingsOption(monitorPings bool) SqlMockOption {\n\treturn func(s *sqlmock) error {\n\t\ts.monitorPings = monitorPings\n\t\treturn nil\n\t}\n}\n"
        },
        {
          "name": "query.go",
          "type": "blob",
          "size": 2.2470703125,
          "content": "package sqlmock\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar re = regexp.MustCompile(\"\\\\s+\")\n\n// strip out new lines and trim spaces\nfunc stripQuery(q string) (s string) {\n\treturn strings.TrimSpace(re.ReplaceAllString(q, \" \"))\n}\n\n// QueryMatcher is an SQL query string matcher interface,\n// which can be used to customize validation of SQL query strings.\n// As an example, external library could be used to build\n// and validate SQL ast, columns selected.\n//\n// sqlmock can be customized to implement a different QueryMatcher\n// configured through an option when sqlmock.New or sqlmock.NewWithDSN\n// is called, default QueryMatcher is QueryMatcherRegexp.\ntype QueryMatcher interface {\n\n\t// Match expected SQL query string without whitespace to\n\t// actual SQL.\n\tMatch(expectedSQL, actualSQL string) error\n}\n\n// QueryMatcherFunc type is an adapter to allow the use of\n// ordinary functions as QueryMatcher. If f is a function\n// with the appropriate signature, QueryMatcherFunc(f) is a\n// QueryMatcher that calls f.\ntype QueryMatcherFunc func(expectedSQL, actualSQL string) error\n\n// Match implements the QueryMatcher\nfunc (f QueryMatcherFunc) Match(expectedSQL, actualSQL string) error {\n\treturn f(expectedSQL, actualSQL)\n}\n\n// QueryMatcherRegexp is the default SQL query matcher\n// used by sqlmock. It parses expectedSQL to a regular\n// expression and attempts to match actualSQL.\nvar QueryMatcherRegexp QueryMatcher = QueryMatcherFunc(func(expectedSQL, actualSQL string) error {\t\n\texpect := stripQuery(expectedSQL)\n\tactual := stripQuery(actualSQL)\n\tif actual != \"\" && expect == \"\" {\n\t\treturn fmt.Errorf(\"expectedSQL can't be empty\")\n\t}\n\tre, err := regexp.Compile(expect)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !re.MatchString(actual) {\n\t\treturn fmt.Errorf(`could not match actual sql: \"%s\" with expected regexp \"%s\"`, actual, re.String())\n\t}\n\treturn nil\n})\n\n// QueryMatcherEqual is the SQL query matcher\n// which simply tries a case sensitive match of\n// expected and actual SQL strings without whitespace.\nvar QueryMatcherEqual QueryMatcher = QueryMatcherFunc(func(expectedSQL, actualSQL string) error {\n\texpect := stripQuery(expectedSQL)\n\tactual := stripQuery(actualSQL)\n\tif actual != expect {\n\t\treturn fmt.Errorf(`actual sql: \"%s\" does not equal to expected \"%s\"`, actual, expect)\n\t}\n\treturn nil\n})\n"
        },
        {
          "name": "query_test.go",
          "type": "blob",
          "size": 3.3642578125,
          "content": "package sqlmock\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc ExampleQueryMatcher() {\n\t// configure to use case sensitive SQL query matcher\n\t// instead of default regular expression matcher\n\tdb, mock, err := New(QueryMatcherOption(QueryMatcherEqual))\n\tif err != nil {\n\t\tfmt.Println(\"failed to open sqlmock database:\", err)\n\t}\n\tdefer db.Close()\n\n\trows := NewRows([]string{\"id\", \"title\"}).\n\t\tAddRow(1, \"one\").\n\t\tAddRow(2, \"two\")\n\n\tmock.ExpectQuery(\"SELECT * FROM users\").WillReturnRows(rows)\n\n\trs, err := db.Query(\"SELECT * FROM users\")\n\tif err != nil {\n\t\tfmt.Println(\"failed to match expected query\")\n\t\treturn\n\t}\n\tdefer rs.Close()\n\n\tfor rs.Next() {\n\t\tvar id int\n\t\tvar title string\n\t\trs.Scan(&id, &title)\n\t\tfmt.Println(\"scanned id:\", id, \"and title:\", title)\n\t}\n\n\tif rs.Err() != nil {\n\t\tfmt.Println(\"got rows error:\", rs.Err())\n\t}\n\t// Output: scanned id: 1 and title: one\n\t// scanned id: 2 and title: two\n}\n\nfunc TestQueryStringStripping(t *testing.T) {\n\tassert := func(actual, expected string) {\n\t\tif res := stripQuery(actual); res != expected {\n\t\t\tt.Errorf(\"Expected '%s' to be '%s', but got '%s'\", actual, expected, res)\n\t\t}\n\t}\n\n\tassert(\" SELECT 1\", \"SELECT 1\")\n\tassert(\"SELECT   1 FROM   d\", \"SELECT 1 FROM d\")\n\tassert(`\n    SELECT c\n    FROM D\n`, \"SELECT c FROM D\")\n\tassert(\"UPDATE  (.+) SET  \", \"UPDATE (.+) SET\")\n}\n\nfunc TestQueryMatcherRegexp(t *testing.T) {\n\ttype testCase struct {\n\t\texpected string\n\t\tactual   string\n\t\terr      error\n\t}\n\n\tcases := []testCase{\n\t\t{\"?\\\\l\", \"SEL\", fmt.Errorf(\"error parsing regexp: missing argument to repetition operator: `?`\")},\n\t\t{\"SELECT (.+) FROM users\", \"SELECT name, email FROM users WHERE id = ?\", nil},\n\t\t{\"Select (.+) FROM users\", \"SELECT name, email FROM users WHERE id = ?\", fmt.Errorf(`could not match actual sql: \"SELECT name, email FROM users WHERE id = ?\" with expected regexp \"Select (.+) FROM users\"`)},\n\t\t{\"SELECT (.+) FROM\\nusers\", \"SELECT name, email\\n FROM users\\n WHERE id = ?\", nil},\n                {\"\",\"SELECT from table\", fmt.Errorf(`expectedSQL can't be empty`)},\n\t}\n\n\tfor i, c := range cases {\n\t\terr := QueryMatcherRegexp.Match(c.expected, c.actual)\n\t\tif err == nil && c.err != nil {\n\t\t\tt.Errorf(`got no error, but expected \"%v\" at %d case`, c.err, i)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil && c.err == nil {\n\t\t\tt.Errorf(`got unexpected error \"%v\" at %d case`, err, i)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err.Error() != c.err.Error() {\n\t\t\tt.Errorf(`expected error \"%v\", but got \"%v\" at %d case`, c.err, err, i)\n\t\t}\n\t}\n}\n\nfunc TestQueryMatcherEqual(t *testing.T) {\n\ttype testCase struct {\n\t\texpected string\n\t\tactual   string\n\t\terr      error\n\t}\n\n\tcases := []testCase{\n\t\t{\"SELECT name, email FROM users WHERE id = ?\", \"SELECT name, email\\n FROM users\\n WHERE id = ?\", nil},\n\t\t{\"SELECT\", \"Select\", fmt.Errorf(`actual sql: \"Select\" does not equal to expected \"SELECT\"`)},\n\t\t{\"SELECT from users\", \"SELECT from table\", fmt.Errorf(`actual sql: \"SELECT from table\" does not equal to expected \"SELECT from users\"`)},\n\t}\n\n\tfor i, c := range cases {\n\t\terr := QueryMatcherEqual.Match(c.expected, c.actual)\n\t\tif err == nil && c.err != nil {\n\t\t\tt.Errorf(`got no error, but expected \"%v\" at %d case`, c.err, i)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil && c.err == nil {\n\t\t\tt.Errorf(`got unexpected error \"%v\" at %d case`, err, i)\n\t\t\tcontinue\n\t\t}\n\t\tif err == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err.Error() != c.err.Error() {\n\t\t\tt.Errorf(`expected error \"%v\", but got \"%v\" at %d case`, c.err, err, i)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "result.go",
          "type": "blob",
          "size": 0.802734375,
          "content": "package sqlmock\n\nimport (\n\t\"database/sql/driver\"\n)\n\n// Result satisfies sql driver Result, which\n// holds last insert id and rows affected\n// by Exec queries\ntype result struct {\n\tinsertID     int64\n\trowsAffected int64\n\terr          error\n}\n\n// NewResult creates a new sql driver Result\n// for Exec based query mocks.\nfunc NewResult(lastInsertID int64, rowsAffected int64) driver.Result {\n\treturn &result{\n\t\tinsertID:     lastInsertID,\n\t\trowsAffected: rowsAffected,\n\t}\n}\n\n// NewErrorResult creates a new sql driver Result\n// which returns an error given for both interface methods\nfunc NewErrorResult(err error) driver.Result {\n\treturn &result{\n\t\terr: err,\n\t}\n}\n\nfunc (r *result) LastInsertId() (int64, error) {\n\treturn r.insertID, r.err\n}\n\nfunc (r *result) RowsAffected() (int64, error) {\n\treturn r.rowsAffected, r.err\n}\n"
        },
        {
          "name": "result_test.go",
          "type": "blob",
          "size": 1.5849609375,
          "content": "package sqlmock\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\n// used for examples\nvar mock = &sqlmock{}\n\nfunc ExampleNewErrorResult() {\n\tdb, mock, _ := New()\n\tresult := NewErrorResult(fmt.Errorf(\"some error\"))\n\tmock.ExpectExec(\"^INSERT (.+)\").WillReturnResult(result)\n\tres, _ := db.Exec(\"INSERT something\")\n\t_, err := res.LastInsertId()\n\tfmt.Println(err)\n\t// Output: some error\n}\n\nfunc ExampleNewResult() {\n\tvar lastInsertID, affected int64\n\tresult := NewResult(lastInsertID, affected)\n\tmock.ExpectExec(\"^INSERT (.+)\").WillReturnResult(result)\n\tfmt.Println(mock.ExpectationsWereMet())\n\t// Output: there is a remaining expectation which was not matched: ExpectedExec => expecting Exec or ExecContext which:\n\t//   - matches sql: '^INSERT (.+)'\n\t//   - is without arguments\n\t//   - should return Result having:\n\t//       LastInsertId: 0\n\t//       RowsAffected: 0\n}\n\nfunc TestShouldReturnValidSqlDriverResult(t *testing.T) {\n\tresult := NewResult(1, 2)\n\tid, err := result.LastInsertId()\n\tif 1 != id {\n\t\tt.Errorf(\"expected last insert id to be 1, but got: %d\", id)\n\t}\n\tif err != nil {\n\t\tt.Errorf(\"expected no error, but got: %s\", err)\n\t}\n\taffected, err := result.RowsAffected()\n\tif 2 != affected {\n\t\tt.Errorf(\"expected affected rows to be 2, but got: %d\", affected)\n\t}\n\tif err != nil {\n\t\tt.Errorf(\"expected no error, but got: %s\", err)\n\t}\n}\n\nfunc TestShouldReturnErrorSqlDriverResult(t *testing.T) {\n\tresult := NewErrorResult(fmt.Errorf(\"some error\"))\n\t_, err := result.LastInsertId()\n\tif err == nil {\n\t\tt.Error(\"expected error, but got none\")\n\t}\n\t_, err = result.RowsAffected()\n\tif err == nil {\n\t\tt.Error(\"expected error, but got none\")\n\t}\n}\n"
        },
        {
          "name": "rows.go",
          "type": "blob",
          "size": 5.380859375,
          "content": "package sqlmock\n\nimport (\n\t\"bytes\"\n\t\"database/sql/driver\"\n\t\"encoding/csv\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\nconst invalidate = \"☠☠☠ MEMORY OVERWRITTEN ☠☠☠ \"\n\n// CSVColumnParser is a function which converts trimmed csv\n// column string to a []byte representation. Currently\n// transforms NULL to nil\nvar CSVColumnParser = func(s string) interface{} {\n\tswitch {\n\tcase strings.ToLower(s) == \"null\":\n\t\treturn nil\n\t}\n\treturn []byte(s)\n}\n\ntype rowSets struct {\n\tsets []*Rows\n\tpos  int\n\tex   *ExpectedQuery\n\traw  [][]byte\n}\n\nfunc (rs *rowSets) Columns() []string {\n\treturn rs.sets[rs.pos].cols\n}\n\nfunc (rs *rowSets) Close() error {\n\trs.invalidateRaw()\n\trs.ex.rowsWereClosed = true\n\treturn rs.sets[rs.pos].closeErr\n}\n\n// advances to next row\nfunc (rs *rowSets) Next(dest []driver.Value) error {\n\tr := rs.sets[rs.pos]\n\tr.pos++\n\trs.invalidateRaw()\n\tif r.pos > len(r.rows) {\n\t\treturn io.EOF // per interface spec\n\t}\n\n\tfor i, col := range r.rows[r.pos-1] {\n\t\tif b, ok := rawBytes(col); ok {\n\t\t\trs.raw = append(rs.raw, b)\n\t\t\tdest[i] = b\n\t\t\tcontinue\n\t\t}\n\t\tdest[i] = col\n\t}\n\n\treturn r.nextErr[r.pos-1]\n}\n\n// transforms to debuggable printable string\nfunc (rs *rowSets) String() string {\n\tif rs.empty() {\n\t\treturn \"with empty rows\"\n\t}\n\n\tmsg := \"should return rows:\\n\"\n\tif len(rs.sets) == 1 {\n\t\tfor n, row := range rs.sets[0].rows {\n\t\t\tmsg += fmt.Sprintf(\"    row %d - %+v\\n\", n, row)\n\t\t}\n\t\treturn strings.TrimSpace(msg)\n\t}\n\tfor i, set := range rs.sets {\n\t\tmsg += fmt.Sprintf(\"    result set: %d\\n\", i)\n\t\tfor n, row := range set.rows {\n\t\t\tmsg += fmt.Sprintf(\"      row %d - %+v\\n\", n, row)\n\t\t}\n\t}\n\treturn strings.TrimSpace(msg)\n}\n\nfunc (rs *rowSets) empty() bool {\n\tfor _, set := range rs.sets {\n\t\tif len(set.rows) > 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc rawBytes(col driver.Value) (_ []byte, ok bool) {\n\tval, ok := col.([]byte)\n\tif !ok || len(val) == 0 {\n\t\treturn nil, false\n\t}\n\t// Copy the bytes from the mocked row into a shared raw buffer, which we'll replace the content of later\n\t// This allows scanning into sql.RawBytes to correctly become invalid on subsequent calls to Next(), Scan() or Close()\n\tb := make([]byte, len(val))\n\tcopy(b, val)\n\treturn b, true\n}\n\n// Bytes that could have been scanned as sql.RawBytes are only valid until the next call to Next, Scan or Close.\n// If those occur, we must replace their content to simulate the shared memory to expose misuse of sql.RawBytes\nfunc (rs *rowSets) invalidateRaw() {\n\t// Replace the content of slices previously returned\n\tb := []byte(invalidate)\n\tfor _, r := range rs.raw {\n\t\tcopy(r, bytes.Repeat(b, len(r)/len(b)+1))\n\t}\n\t// Start with new slices for the next scan\n\trs.raw = nil\n}\n\n// Rows is a mocked collection of rows to\n// return for Query result\ntype Rows struct {\n\tconverter driver.ValueConverter\n\tcols      []string\n\tdef       []*Column\n\trows      [][]driver.Value\n\tpos       int\n\tnextErr   map[int]error\n\tcloseErr  error\n}\n\n// NewRows allows Rows to be created from a\n// sql driver.Value slice or from the CSV string and\n// to be used as sql driver.Rows.\n// Use Sqlmock.NewRows instead if using a custom converter\nfunc NewRows(columns []string) *Rows {\n\treturn &Rows{\n\t\tcols:      columns,\n\t\tnextErr:   make(map[int]error),\n\t\tconverter: driver.DefaultParameterConverter,\n\t}\n}\n\n// CloseError allows to set an error\n// which will be returned by rows.Close\n// function.\n//\n// The close error will be triggered only in cases\n// when rows.Next() EOF was not yet reached, that is\n// a default sql library behavior\nfunc (r *Rows) CloseError(err error) *Rows {\n\tr.closeErr = err\n\treturn r\n}\n\n// RowError allows to set an error\n// which will be returned when a given\n// row number is read\nfunc (r *Rows) RowError(row int, err error) *Rows {\n\tr.nextErr[row] = err\n\treturn r\n}\n\n// AddRow composed from database driver.Value slice\n// return the same instance to perform subsequent actions.\n// Note that the number of values must match the number\n// of columns\nfunc (r *Rows) AddRow(values ...driver.Value) *Rows {\n\tif len(values) != len(r.cols) {\n\t\tpanic(fmt.Sprintf(\"Expected number of values to match number of columns: expected %d, actual %d\", len(values), len(r.cols)))\n\t}\n\n\trow := make([]driver.Value, len(r.cols))\n\tfor i, v := range values {\n\t\t// Convert user-friendly values (such as int or driver.Valuer)\n\t\t// to database/sql native value (driver.Value such as int64)\n\t\tvar err error\n\t\tv, err = r.converter.ConvertValue(v)\n\t\tif err != nil {\n\t\t\tpanic(fmt.Errorf(\n\t\t\t\t\"row #%d, column #%d (%q) type %T: %s\",\n\t\t\t\tlen(r.rows)+1, i, r.cols[i], values[i], err,\n\t\t\t))\n\t\t}\n\n\t\trow[i] = v\n\t}\n\n\tr.rows = append(r.rows, row)\n\treturn r\n}\n\n// AddRows adds multiple rows composed from database driver.Value slice and\n// returns the same instance to perform subsequent actions.\nfunc (r *Rows) AddRows(values ...[]driver.Value) *Rows {\n\tfor _, value := range values {\n\t\tr.AddRow(value...)\n\t}\n\n\treturn r\n}\n\n// FromCSVString build rows from csv string.\n// return the same instance to perform subsequent actions.\n// Note that the number of values must match the number\n// of columns\nfunc (r *Rows) FromCSVString(s string) *Rows {\n\tres := strings.NewReader(strings.TrimSpace(s))\n\tcsvReader := csv.NewReader(res)\n\n\tfor {\n\t\tres, err := csvReader.Read()\n\t\tif err != nil {\n\t\t\tif errors.Is(err, io.EOF) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tpanic(fmt.Sprintf(\"Parsing CSV string failed: %s\", err.Error()))\n\t\t}\n\n\t\trow := make([]driver.Value, len(r.cols))\n\t\tfor i, v := range res {\n\t\t\trow[i] = CSVColumnParser(strings.TrimSpace(v))\n\t\t}\n\t\tr.rows = append(r.rows, row)\n\t}\n\treturn r\n}\n"
        },
        {
          "name": "rows_go13_test.go",
          "type": "blob",
          "size": 0.9462890625,
          "content": "// +build go1.3\n\npackage sqlmock\n\nimport (\n\t\"database/sql\"\n\t\"testing\"\n)\n\nfunc TestQueryRowBytesNotInvalidatedByNext_stringIntoRawBytes(t *testing.T) {\n\tt.Parallel()\n\trows := NewRows([]string{\"raw\"}).\n\t\tAddRow(`one binary value with some text!`).\n\t\tAddRow(`two binary value with even more text than the first one`)\n\tscan := func(rs *sql.Rows) ([]byte, error) {\n\t\tvar raw sql.RawBytes\n\t\treturn raw, rs.Scan(&raw)\n\t}\n\twant := [][]byte{[]byte(`one binary value with some text!`), []byte(`two binary value with even more text than the first one`)}\n\tqueryRowBytesNotInvalidatedByNext(t, rows, scan, want)\n}\n\nfunc TestQueryRowBytesNotInvalidatedByClose_stringIntoRawBytes(t *testing.T) {\n\tt.Parallel()\n\trows := NewRows([]string{\"raw\"}).AddRow(`one binary value with some text!`)\n\tscan := func(rs *sql.Rows) ([]byte, error) {\n\t\tvar raw sql.RawBytes\n\t\treturn raw, rs.Scan(&raw)\n\t}\n\tqueryRowBytesNotInvalidatedByClose(t, rows, scan, []byte(`one binary value with some text!`))\n}\n"
        },
        {
          "name": "rows_go18.go",
          "type": "blob",
          "size": 1.9560546875,
          "content": "// +build go1.8\n\npackage sqlmock\n\nimport (\n\t\"database/sql/driver\"\n\t\"io\"\n\t\"reflect\"\n)\n\n// Implement the \"RowsNextResultSet\" interface\nfunc (rs *rowSets) HasNextResultSet() bool {\n\treturn rs.pos+1 < len(rs.sets)\n}\n\n// Implement the \"RowsNextResultSet\" interface\nfunc (rs *rowSets) NextResultSet() error {\n\tif !rs.HasNextResultSet() {\n\t\treturn io.EOF\n\t}\n\n\trs.pos++\n\treturn nil\n}\n\n// type for rows with columns definition created with sqlmock.NewRowsWithColumnDefinition\ntype rowSetsWithDefinition struct {\n\t*rowSets\n}\n\n// Implement the \"RowsColumnTypeDatabaseTypeName\" interface\nfunc (rs *rowSetsWithDefinition) ColumnTypeDatabaseTypeName(index int) string {\n\treturn rs.getDefinition(index).DbType()\n}\n\n// Implement the \"RowsColumnTypeLength\" interface\nfunc (rs *rowSetsWithDefinition) ColumnTypeLength(index int) (length int64, ok bool) {\n\treturn rs.getDefinition(index).Length()\n}\n\n// Implement the \"RowsColumnTypeNullable\" interface\nfunc (rs *rowSetsWithDefinition) ColumnTypeNullable(index int) (nullable, ok bool) {\n\treturn rs.getDefinition(index).IsNullable()\n}\n\n// Implement the \"RowsColumnTypePrecisionScale\" interface\nfunc (rs *rowSetsWithDefinition) ColumnTypePrecisionScale(index int) (precision, scale int64, ok bool) {\n\treturn rs.getDefinition(index).PrecisionScale()\n}\n\n// ColumnTypeScanType is defined from driver.RowsColumnTypeScanType\nfunc (rs *rowSetsWithDefinition) ColumnTypeScanType(index int) reflect.Type {\n\treturn rs.getDefinition(index).ScanType()\n}\n\n// return column definition from current set metadata\nfunc (rs *rowSetsWithDefinition) getDefinition(index int) *Column {\n\treturn rs.sets[rs.pos].def[index]\n}\n\n// NewRowsWithColumnDefinition return rows with columns metadata\nfunc NewRowsWithColumnDefinition(columns ...*Column) *Rows {\n\tcols := make([]string, len(columns))\n\tfor i, column := range columns {\n\t\tcols[i] = column.Name()\n\t}\n\n\treturn &Rows{\n\t\tcols:      cols,\n\t\tdef:       columns,\n\t\tnextErr:   make(map[int]error),\n\t\tconverter: driver.DefaultParameterConverter,\n\t}\n}\n"
        },
        {
          "name": "rows_go18_test.go",
          "type": "blob",
          "size": 12.98046875,
          "content": "// +build go1.8\n\npackage sqlmock\n\nimport (\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestQueryMultiRows(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\trs1 := NewRows([]string{\"id\", \"title\"}).AddRow(5, \"hello world\")\n\trs2 := NewRows([]string{\"name\"}).AddRow(\"gopher\").AddRow(\"john\").AddRow(\"jane\").RowError(2, fmt.Errorf(\"error\"))\n\n\tmock.ExpectQuery(\"SELECT (.+) FROM articles WHERE id = \\\\?;SELECT name FROM users\").\n\t\tWithArgs(5).\n\t\tWillReturnRows(rs1, rs2)\n\n\trows, err := db.Query(\"SELECT id, title FROM articles WHERE id = ?;SELECT name FROM users\", 5)\n\tif err != nil {\n\t\tt.Errorf(\"error was not expected, but got: %v\", err)\n\t}\n\tdefer rows.Close()\n\n\tif !rows.Next() {\n\t\tt.Error(\"expected a row to be available in first result set\")\n\t}\n\n\tvar id int\n\tvar name string\n\n\terr = rows.Scan(&id, &name)\n\tif err != nil {\n\t\tt.Errorf(\"error was not expected, but got: %v\", err)\n\t}\n\n\tif id != 5 || name != \"hello world\" {\n\t\tt.Errorf(\"unexpected row values id: %v name: %v\", id, name)\n\t}\n\n\tif rows.Next() {\n\t\tt.Error(\"was not expecting next row in first result set\")\n\t}\n\n\tif !rows.NextResultSet() {\n\t\tt.Error(\"had to have next result set\")\n\t}\n\n\tif !rows.Next() {\n\t\tt.Error(\"expected a row to be available in second result set\")\n\t}\n\n\terr = rows.Scan(&name)\n\tif err != nil {\n\t\tt.Errorf(\"error was not expected, but got: %v\", err)\n\t}\n\n\tif name != \"gopher\" {\n\t\tt.Errorf(\"unexpected row name: %v\", name)\n\t}\n\n\tif !rows.Next() {\n\t\tt.Error(\"expected a row to be available in second result set\")\n\t}\n\n\terr = rows.Scan(&name)\n\tif err != nil {\n\t\tt.Errorf(\"error was not expected, but got: %v\", err)\n\t}\n\n\tif name != \"john\" {\n\t\tt.Errorf(\"unexpected row name: %v\", name)\n\t}\n\n\tif rows.Next() {\n\t\tt.Error(\"expected next row to produce error\")\n\t}\n\n\tif rows.Err() == nil {\n\t\tt.Error(\"expected an error, but there was none\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestQueryRowBytesInvalidatedByNext_jsonRawMessageIntoRawBytes(t *testing.T) {\n\tt.Parallel()\n\treplace := []byte(invalid)\n\trows := NewRows([]string{\"raw\"}).\n\t\tAddRow(json.RawMessage(`{\"thing\": \"one\", \"thing2\": \"two\"}`)).\n\t\tAddRow(json.RawMessage(`{\"that\": \"foo\", \"this\": \"bar\"}`))\n\tscan := func(rs *sql.Rows) ([]byte, error) {\n\t\tvar raw sql.RawBytes\n\t\treturn raw, rs.Scan(&raw)\n\t}\n\twant := []struct {\n\t\tInitial  []byte\n\t\tReplaced []byte\n\t}{\n\t\t{Initial: []byte(`{\"thing\": \"one\", \"thing2\": \"two\"}`), Replaced: replace[:len(replace)-6]},\n\t\t{Initial: []byte(`{\"that\": \"foo\", \"this\": \"bar\"}`), Replaced: replace[:len(replace)-9]},\n\t}\n\tqueryRowBytesInvalidatedByNext(t, rows, scan, want)\n}\n\nfunc TestQueryRowBytesNotInvalidatedByNext_jsonRawMessageIntoBytes(t *testing.T) {\n\tt.Parallel()\n\trows := NewRows([]string{\"raw\"}).\n\t\tAddRow(json.RawMessage(`{\"thing\": \"one\", \"thing2\": \"two\"}`)).\n\t\tAddRow(json.RawMessage(`{\"that\": \"foo\", \"this\": \"bar\"}`))\n\tscan := func(rs *sql.Rows) ([]byte, error) {\n\t\tvar b []byte\n\t\treturn b, rs.Scan(&b)\n\t}\n\twant := [][]byte{[]byte(`{\"thing\": \"one\", \"thing2\": \"two\"}`), []byte(`{\"that\": \"foo\", \"this\": \"bar\"}`)}\n\tqueryRowBytesNotInvalidatedByNext(t, rows, scan, want)\n}\n\nfunc TestQueryRowBytesNotInvalidatedByNext_bytesIntoCustomBytes(t *testing.T) {\n\tt.Parallel()\n\trows := NewRows([]string{\"raw\"}).\n\t\tAddRow([]byte(`one binary value with some text!`)).\n\t\tAddRow([]byte(`two binary value with even more text than the first one`))\n\tscan := func(rs *sql.Rows) ([]byte, error) {\n\t\ttype customBytes []byte\n\t\tvar b customBytes\n\t\treturn b, rs.Scan(&b)\n\t}\n\twant := [][]byte{[]byte(`one binary value with some text!`), []byte(`two binary value with even more text than the first one`)}\n\tqueryRowBytesNotInvalidatedByNext(t, rows, scan, want)\n}\n\nfunc TestQueryRowBytesNotInvalidatedByNext_jsonRawMessageIntoCustomBytes(t *testing.T) {\n\tt.Parallel()\n\trows := NewRows([]string{\"raw\"}).\n\t\tAddRow(json.RawMessage(`{\"thing\": \"one\", \"thing2\": \"two\"}`)).\n\t\tAddRow(json.RawMessage(`{\"that\": \"foo\", \"this\": \"bar\"}`))\n\tscan := func(rs *sql.Rows) ([]byte, error) {\n\t\ttype customBytes []byte\n\t\tvar b customBytes\n\t\treturn b, rs.Scan(&b)\n\t}\n\twant := [][]byte{[]byte(`{\"thing\": \"one\", \"thing2\": \"two\"}`), []byte(`{\"that\": \"foo\", \"this\": \"bar\"}`)}\n\tqueryRowBytesNotInvalidatedByNext(t, rows, scan, want)\n}\n\nfunc TestQueryRowBytesNotInvalidatedByClose_bytesIntoCustomBytes(t *testing.T) {\n\tt.Parallel()\n\trows := NewRows([]string{\"raw\"}).AddRow([]byte(`one binary value with some text!`))\n\tscan := func(rs *sql.Rows) ([]byte, error) {\n\t\ttype customBytes []byte\n\t\tvar b customBytes\n\t\treturn b, rs.Scan(&b)\n\t}\n\tqueryRowBytesNotInvalidatedByClose(t, rows, scan, []byte(`one binary value with some text!`))\n}\n\nfunc TestQueryRowBytesInvalidatedByClose_jsonRawMessageIntoRawBytes(t *testing.T) {\n\tt.Parallel()\n\treplace := []byte(invalid)\n\trows := NewRows([]string{\"raw\"}).AddRow(json.RawMessage(`{\"thing\": \"one\", \"thing2\": \"two\"}`))\n\tscan := func(rs *sql.Rows) ([]byte, error) {\n\t\tvar raw sql.RawBytes\n\t\treturn raw, rs.Scan(&raw)\n\t}\n\twant := struct {\n\t\tInitial  []byte\n\t\tReplaced []byte\n\t}{\n\t\tInitial:  []byte(`{\"thing\": \"one\", \"thing2\": \"two\"}`),\n\t\tReplaced: replace[:len(replace)-6],\n\t}\n\tqueryRowBytesInvalidatedByClose(t, rows, scan, want)\n}\n\nfunc TestQueryRowBytesNotInvalidatedByClose_jsonRawMessageIntoBytes(t *testing.T) {\n\tt.Parallel()\n\trows := NewRows([]string{\"raw\"}).AddRow(json.RawMessage(`{\"thing\": \"one\", \"thing2\": \"two\"}`))\n\tscan := func(rs *sql.Rows) ([]byte, error) {\n\t\tvar b []byte\n\t\treturn b, rs.Scan(&b)\n\t}\n\tqueryRowBytesNotInvalidatedByClose(t, rows, scan, []byte(`{\"thing\": \"one\", \"thing2\": \"two\"}`))\n}\n\nfunc TestQueryRowBytesNotInvalidatedByClose_jsonRawMessageIntoCustomBytes(t *testing.T) {\n\tt.Parallel()\n\trows := NewRows([]string{\"raw\"}).AddRow(json.RawMessage(`{\"thing\": \"one\", \"thing2\": \"two\"}`))\n\tscan := func(rs *sql.Rows) ([]byte, error) {\n\t\ttype customBytes []byte\n\t\tvar b customBytes\n\t\treturn b, rs.Scan(&b)\n\t}\n\tqueryRowBytesNotInvalidatedByClose(t, rows, scan, []byte(`{\"thing\": \"one\", \"thing2\": \"two\"}`))\n}\n\nfunc TestNewColumnWithDefinition(t *testing.T) {\n\tnow, _ := time.Parse(time.RFC3339, \"2020-06-20T22:08:41Z\")\n\n\tt.Run(\"with one ResultSet\", func(t *testing.T) {\n\t\tdb, mock, _ := New()\n\t\tcolumn1 := mock.NewColumn(\"test\").OfType(\"VARCHAR\", \"\").Nullable(true).WithLength(100)\n\t\tcolumn2 := mock.NewColumn(\"number\").OfType(\"DECIMAL\", float64(0.0)).Nullable(false).WithPrecisionAndScale(10, 4)\n\t\tcolumn3 := mock.NewColumn(\"when\").OfType(\"TIMESTAMP\", now)\n\t\trows := mock.NewRowsWithColumnDefinition(column1, column2, column3)\n\t\trows.AddRow(\"foo.bar\", float64(10.123), now)\n\n\t\tmQuery := mock.ExpectQuery(\"SELECT test, number, when from dummy\")\n\t\tisQuery := mQuery.WillReturnRows(rows)\n\t\tisQueryClosed := mQuery.RowsWillBeClosed()\n\t\tisDbClosed := mock.ExpectClose()\n\n\t\tquery, _ := db.Query(\"SELECT test, number, when from dummy\")\n\n\t\tif false == isQuery.fulfilled() {\n\t\t\tt.Error(\"Query is not executed\")\n\t\t}\n\n\t\tif query.Next() {\n\t\t\tvar test string\n\t\t\tvar number float64\n\t\t\tvar when time.Time\n\n\t\t\tif queryError := query.Scan(&test, &number, &when); queryError != nil {\n\t\t\t\tt.Error(queryError)\n\t\t\t} else if test != \"foo.bar\" {\n\t\t\t\tt.Error(\"field test is not 'foo.bar'\")\n\t\t\t} else if number != float64(10.123) {\n\t\t\t\tt.Error(\"field number is not '10.123'\")\n\t\t\t} else if when != now {\n\t\t\t\tt.Errorf(\"field when is not %v\", now)\n\t\t\t}\n\n\t\t\tif columnTypes, colTypErr := query.ColumnTypes(); colTypErr != nil {\n\t\t\t\tt.Error(colTypErr)\n\t\t\t} else if len(columnTypes) != 3 {\n\t\t\t\tt.Error(\"number of columnTypes\")\n\t\t\t} else if name := columnTypes[0].Name(); name != \"test\" {\n\t\t\t\tt.Errorf(\"field 'test' has a wrong name '%s'\", name)\n\t\t\t} else if dbType := columnTypes[0].DatabaseTypeName(); dbType != \"VARCHAR\" {\n\t\t\t\tt.Errorf(\"field 'test' has a wrong db type '%s'\", dbType)\n\t\t\t} else if columnTypes[0].ScanType().Kind() != reflect.String {\n\t\t\t\tt.Error(\"field 'test' has a wrong scanType\")\n\t\t\t} else if _, _, ok := columnTypes[0].DecimalSize(); ok {\n\t\t\t\tt.Error(\"field 'test' should have not precision, scale\")\n\t\t\t} else if length, ok := columnTypes[0].Length(); length != 100 || !ok {\n\t\t\t\tt.Errorf(\"field 'test' has a wrong length '%d'\", length)\n\t\t\t} else if name := columnTypes[1].Name(); name != \"number\" {\n\t\t\t\tt.Errorf(\"field 'number' has a wrong name '%s'\", name)\n\t\t\t} else if dbType := columnTypes[1].DatabaseTypeName(); dbType != \"DECIMAL\" {\n\t\t\t\tt.Errorf(\"field 'number' has a wrong db type '%s'\", dbType)\n\t\t\t} else if columnTypes[1].ScanType().Kind() != reflect.Float64 {\n\t\t\t\tt.Error(\"field 'number' has a wrong scanType\")\n\t\t\t} else if precision, scale, ok := columnTypes[1].DecimalSize(); precision != int64(10) || scale != int64(4) || !ok {\n\t\t\t\tt.Error(\"field 'number' has a wrong precision, scale\")\n\t\t\t} else if _, ok := columnTypes[1].Length(); ok {\n\t\t\t\tt.Error(\"field 'number' is not variable length type\")\n\t\t\t} else if _, ok := columnTypes[2].Nullable(); ok {\n\t\t\t\tt.Error(\"field 'when' should have nullability unknown\")\n\t\t\t}\n\t\t} else {\n\t\t\tt.Error(\"no result set\")\n\t\t}\n\n\t\tquery.Close()\n\t\tif false == isQueryClosed.fulfilled() {\n\t\t\tt.Error(\"Query is not executed\")\n\t\t}\n\n\t\tdb.Close()\n\t\tif false == isDbClosed.fulfilled() {\n\t\t\tt.Error(\"Db is not closed\")\n\t\t}\n\t})\n\n\tt.Run(\"with more then one ResultSet\", func(t *testing.T) {\n\t\tdb, mock, _ := New()\n\t\tcolumn1 := mock.NewColumn(\"test\").OfType(\"VARCHAR\", \"\").Nullable(true).WithLength(100)\n\t\tcolumn2 := mock.NewColumn(\"number\").OfType(\"DECIMAL\", float64(0.0)).Nullable(false).WithPrecisionAndScale(10, 4)\n\t\tcolumn3 := mock.NewColumn(\"when\").OfType(\"TIMESTAMP\", now)\n\t\trows1 := mock.NewRowsWithColumnDefinition(column1, column2, column3)\n\t\trows1.AddRow(\"foo.bar\", float64(10.123), now)\n\t\trows2 := mock.NewRowsWithColumnDefinition(column1, column2, column3)\n\t\trows2.AddRow(\"bar.foo\", float64(123.10), now.Add(time.Second*10))\n\t\trows3 := mock.NewRowsWithColumnDefinition(column1, column2, column3)\n\t\trows3.AddRow(\"lollipop\", float64(10.321), now.Add(time.Second*20))\n\n\t\tmQuery := mock.ExpectQuery(\"SELECT test, number, when from dummy\")\n\t\tisQuery := mQuery.WillReturnRows(rows1, rows2, rows3)\n\t\tisQueryClosed := mQuery.RowsWillBeClosed()\n\t\tisDbClosed := mock.ExpectClose()\n\n\t\tquery, _ := db.Query(\"SELECT test, number, when from dummy\")\n\n\t\tif false == isQuery.fulfilled() {\n\t\t\tt.Error(\"Query is not executed\")\n\t\t}\n\n\t\trowsSi := 0\n\n\t\tfor query.Next() {\n\t\t\tvar test string\n\t\t\tvar number float64\n\t\t\tvar when time.Time\n\n\t\t\tif queryError := query.Scan(&test, &number, &when); queryError != nil {\n\t\t\t\tt.Error(queryError)\n\n\t\t\t} else if rowsSi == 0 && test != \"foo.bar\" {\n\t\t\t\tt.Error(\"field test is not 'foo.bar'\")\n\t\t\t} else if rowsSi == 0 && number != float64(10.123) {\n\t\t\t\tt.Error(\"field number is not '10.123'\")\n\t\t\t} else if rowsSi == 0 && when != now {\n\t\t\t\tt.Errorf(\"field when is not %v\", now)\n\n\t\t\t} else if rowsSi == 1 && test != \"bar.foo\" {\n\t\t\t\tt.Error(\"field test is not 'bar.bar'\")\n\t\t\t} else if rowsSi == 1 && number != float64(123.10) {\n\t\t\t\tt.Error(\"field number is not '123.10'\")\n\t\t\t} else if rowsSi == 1 && when != now.Add(time.Second*10) {\n\t\t\t\tt.Errorf(\"field when is not %v\", now)\n\n\t\t\t} else if rowsSi == 2 && test != \"lollipop\" {\n\t\t\t\tt.Error(\"field test is not 'lollipop'\")\n\t\t\t} else if rowsSi == 2 && number != float64(10.321) {\n\t\t\t\tt.Error(\"field number is not '10.321'\")\n\t\t\t} else if rowsSi == 2 && when != now.Add(time.Second*20) {\n\t\t\t\tt.Errorf(\"field when is not %v\", now)\n\t\t\t}\n\n\t\t\trowsSi++\n\n\t\t\tif columnTypes, colTypErr := query.ColumnTypes(); colTypErr != nil {\n\t\t\t\tt.Error(colTypErr)\n\t\t\t} else if len(columnTypes) != 3 {\n\t\t\t\tt.Error(\"number of columnTypes\")\n\t\t\t} else if name := columnTypes[0].Name(); name != \"test\" {\n\t\t\t\tt.Errorf(\"field 'test' has a wrong name '%s'\", name)\n\t\t\t} else if dbType := columnTypes[0].DatabaseTypeName(); dbType != \"VARCHAR\" {\n\t\t\t\tt.Errorf(\"field 'test' has a wrong db type '%s'\", dbType)\n\t\t\t} else if columnTypes[0].ScanType().Kind() != reflect.String {\n\t\t\t\tt.Error(\"field 'test' has a wrong scanType\")\n\t\t\t} else if _, _, ok := columnTypes[0].DecimalSize(); ok {\n\t\t\t\tt.Error(\"field 'test' should not have precision, scale\")\n\t\t\t} else if length, ok := columnTypes[0].Length(); length != 100 || !ok {\n\t\t\t\tt.Errorf(\"field 'test' has a wrong length '%d'\", length)\n\t\t\t} else if name := columnTypes[1].Name(); name != \"number\" {\n\t\t\t\tt.Errorf(\"field 'number' has a wrong name '%s'\", name)\n\t\t\t} else if dbType := columnTypes[1].DatabaseTypeName(); dbType != \"DECIMAL\" {\n\t\t\t\tt.Errorf(\"field 'number' has a wrong db type '%s'\", dbType)\n\t\t\t} else if columnTypes[1].ScanType().Kind() != reflect.Float64 {\n\t\t\t\tt.Error(\"field 'number' has a wrong scanType\")\n\t\t\t} else if precision, scale, ok := columnTypes[1].DecimalSize(); precision != int64(10) || scale != int64(4) || !ok {\n\t\t\t\tt.Error(\"field 'number' has a wrong precision, scale\")\n\t\t\t} else if _, ok := columnTypes[1].Length(); ok {\n\t\t\t\tt.Error(\"field 'number' is not variable length type\")\n\t\t\t} else if _, ok := columnTypes[2].Nullable(); ok {\n\t\t\t\tt.Error(\"field 'when' should have nullability unknown\")\n\t\t\t}\n\t\t}\n\t\tif rowsSi == 0 {\n\t\t\tt.Error(\"no result set\")\n\t\t}\n\n\t\tquery.Close()\n\t\tif false == isQueryClosed.fulfilled() {\n\t\t\tt.Error(\"Query is not executed\")\n\t\t}\n\n\t\tdb.Close()\n\t\tif false == isDbClosed.fulfilled() {\n\t\t\tt.Error(\"Db is not closed\")\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "rows_test.go",
          "type": "blob",
          "size": 19.904296875,
          "content": "package sqlmock\n\nimport (\n\t\"bytes\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nconst invalid = `☠☠☠ MEMORY OVERWRITTEN ☠☠☠ `\n\nfunc ExampleRows() {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"failed to open sqlmock database:\", err)\n\t}\n\tdefer db.Close()\n\n\trows := NewRows([]string{\"id\", \"title\"}).\n\t\tAddRow(1, \"one\").\n\t\tAddRow(2, \"two\")\n\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(rows)\n\n\trs, _ := db.Query(\"SELECT\")\n\tdefer rs.Close()\n\n\tfor rs.Next() {\n\t\tvar id int\n\t\tvar title string\n\t\trs.Scan(&id, &title)\n\t\tfmt.Println(\"scanned id:\", id, \"and title:\", title)\n\t}\n\n\tif rs.Err() != nil {\n\t\tfmt.Println(\"got rows error:\", rs.Err())\n\t}\n\t// Output: scanned id: 1 and title: one\n\t// scanned id: 2 and title: two\n}\n\nfunc ExampleRows_rowError() {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"failed to open sqlmock database:\", err)\n\t}\n\tdefer db.Close()\n\n\trows := NewRows([]string{\"id\", \"title\"}).\n\t\tAddRow(0, \"one\").\n\t\tAddRow(1, \"two\").\n\t\tRowError(1, fmt.Errorf(\"row error\"))\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(rows)\n\n\trs, _ := db.Query(\"SELECT\")\n\tdefer rs.Close()\n\n\tfor rs.Next() {\n\t\tvar id int\n\t\tvar title string\n\t\trs.Scan(&id, &title)\n\t\tfmt.Println(\"scanned id:\", id, \"and title:\", title)\n\t}\n\n\tif rs.Err() != nil {\n\t\tfmt.Println(\"got rows error:\", rs.Err())\n\t}\n\t// Output: scanned id: 0 and title: one\n\t// got rows error: row error\n}\n\nfunc ExampleRows_closeError() {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"failed to open sqlmock database:\", err)\n\t}\n\tdefer db.Close()\n\n\trows := NewRows([]string{\"id\", \"title\"}).CloseError(fmt.Errorf(\"close error\"))\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(rows)\n\n\trs, _ := db.Query(\"SELECT\")\n\n\t// Note: that close will return error only before rows EOF\n\t// that is a default sql package behavior. If you run rs.Next()\n\t// it will handle the error internally and return nil bellow\n\tif err := rs.Close(); err != nil {\n\t\tfmt.Println(\"got error:\", err)\n\t}\n\n\t// Output: got error: close error\n}\n\nfunc ExampleRows_rawBytes() {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"failed to open sqlmock database:\", err)\n\t}\n\tdefer db.Close()\n\n\trows := NewRows([]string{\"id\", \"binary\"}).\n\t\tAddRow(1, []byte(`one binary value with some text!`)).\n\t\tAddRow(2, []byte(`two binary value with even more text than the first one`))\n\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(rows)\n\n\trs, _ := db.Query(\"SELECT\")\n\tdefer rs.Close()\n\n\ttype scanned struct {\n\t\tid  int\n\t\traw sql.RawBytes\n\t}\n\tfmt.Println(\"initial read...\")\n\tvar ss []scanned\n\tfor rs.Next() {\n\t\tvar s scanned\n\t\trs.Scan(&s.id, &s.raw)\n\t\tss = append(ss, s)\n\t\tfmt.Println(\"scanned id:\", s.id, \"and raw:\", string(s.raw))\n\t}\n\n\tif rs.Err() != nil {\n\t\tfmt.Println(\"got rows error:\", rs.Err())\n\t}\n\n\tfmt.Println(\"after reading all...\")\n\tfor _, s := range ss {\n\t\tfmt.Println(\"scanned id:\", s.id, \"and raw:\", string(s.raw))\n\t}\n\t// Output:\n\t// initial read...\n\t// scanned id: 1 and raw: one binary value with some text!\n\t// scanned id: 2 and raw: two binary value with even more text than the first one\n\t// after reading all...\n\t// scanned id: 1 and raw: ☠☠☠ MEMORY OVERWRITTEN ☠\n\t// scanned id: 2 and raw: ☠☠☠ MEMORY OVERWRITTEN ☠☠☠ ☠☠☠ MEMORY\n}\n\nfunc ExampleRows_expectToBeClosed() {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"failed to open sqlmock database:\", err)\n\t}\n\tdefer db.Close()\n\n\trows := NewRows([]string{\"id\", \"title\"}).AddRow(1, \"john\")\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(rows).RowsWillBeClosed()\n\n\tdb.Query(\"SELECT\")\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tfmt.Println(\"got error:\", err)\n\t}\n\n\t// Output: got error: expected query rows to be closed, but it was not: ExpectedQuery => expecting Query, QueryContext or QueryRow which:\n\t//   - matches sql: 'SELECT'\n\t//   - is without arguments\n\t//   - should return rows:\n\t//     row 0 - [1 john]\n}\n\nfunc ExampleRows_customDriverValue() {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"failed to open sqlmock database:\", err)\n\t}\n\tdefer db.Close()\n\n\trows := NewRows([]string{\"id\", \"null_int\"}).\n\t\tAddRow(1, 7).\n\t\tAddRow(5, sql.NullInt64{Int64: 5, Valid: true}).\n\t\tAddRow(2, sql.NullInt64{})\n\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(rows)\n\n\trs, _ := db.Query(\"SELECT\")\n\tdefer rs.Close()\n\n\tfor rs.Next() {\n\t\tvar id int\n\t\tvar num sql.NullInt64\n\t\trs.Scan(&id, &num)\n\t\tfmt.Println(\"scanned id:\", id, \"and null int64:\", num)\n\t}\n\n\tif rs.Err() != nil {\n\t\tfmt.Println(\"got rows error:\", rs.Err())\n\t}\n\t// Output: scanned id: 1 and null int64: {7 true}\n\t// scanned id: 5 and null int64: {5 true}\n\t// scanned id: 2 and null int64: {0 false}\n}\n\nfunc TestAllowsToSetRowsErrors(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Fatalf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\trows := NewRows([]string{\"id\", \"title\"}).\n\t\tAddRow(0, \"one\").\n\t\tAddRow(1, \"two\").\n\t\tRowError(1, fmt.Errorf(\"error\"))\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(rows)\n\n\trs, err := db.Query(\"SELECT\")\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\tdefer rs.Close()\n\n\tif !rs.Next() {\n\t\tt.Fatal(\"expected the first row to be available\")\n\t}\n\tif rs.Err() != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", rs.Err())\n\t}\n\n\tif rs.Next() {\n\t\tt.Fatal(\"was not expecting the second row, since there should be an error\")\n\t}\n\tif rs.Err() == nil {\n\t\tt.Fatal(\"expected an error, but got none\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestRowsCloseError(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Fatalf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\trows := NewRows([]string{\"id\"}).CloseError(fmt.Errorf(\"close error\"))\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(rows)\n\n\trs, err := db.Query(\"SELECT\")\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\tif err := rs.Close(); err == nil {\n\t\tt.Fatal(\"expected a close error\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestRowsClosed(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Fatalf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\trows := NewRows([]string{\"id\"}).AddRow(1)\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(rows).RowsWillBeClosed()\n\n\trs, err := db.Query(\"SELECT\")\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\tif err := rs.Close(); err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestQuerySingleRow(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Fatalf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\trows := NewRows([]string{\"id\"}).\n\t\tAddRow(1).\n\t\tAddRow(2)\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(rows)\n\n\tvar id int\n\tif err := db.QueryRow(\"SELECT\").Scan(&id); err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(NewRows([]string{\"id\"}))\n\tif err := db.QueryRow(\"SELECT\").Scan(&id); err != sql.ErrNoRows {\n\t\tt.Fatal(\"expected sql no rows error\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestQueryRowBytesInvalidatedByNext_bytesIntoRawBytes(t *testing.T) {\n\tt.Parallel()\n\treplace := []byte(invalid)\n\trows := NewRows([]string{\"raw\"}).\n\t\tAddRow([]byte(`one binary value with some text!`)).\n\t\tAddRow([]byte(`two binary value with even more text than the first one`))\n\tscan := func(rs *sql.Rows) ([]byte, error) {\n\t\tvar raw sql.RawBytes\n\t\treturn raw, rs.Scan(&raw)\n\t}\n\twant := []struct {\n\t\tInitial  []byte\n\t\tReplaced []byte\n\t}{\n\t\t{Initial: []byte(`one binary value with some text!`), Replaced: replace[:len(replace)-7]},\n\t\t{Initial: []byte(`two binary value with even more text than the first one`), Replaced: bytes.Join([][]byte{replace, replace[:len(replace)-23]}, nil)},\n\t}\n\tqueryRowBytesInvalidatedByNext(t, rows, scan, want)\n}\n\nfunc TestQueryRowBytesNotInvalidatedByNext_bytesIntoBytes(t *testing.T) {\n\tt.Parallel()\n\trows := NewRows([]string{\"raw\"}).\n\t\tAddRow([]byte(`one binary value with some text!`)).\n\t\tAddRow([]byte(`two binary value with even more text than the first one`))\n\tscan := func(rs *sql.Rows) ([]byte, error) {\n\t\tvar b []byte\n\t\treturn b, rs.Scan(&b)\n\t}\n\twant := [][]byte{[]byte(`one binary value with some text!`), []byte(`two binary value with even more text than the first one`)}\n\tqueryRowBytesNotInvalidatedByNext(t, rows, scan, want)\n}\n\nfunc TestQueryRowBytesNotInvalidatedByNext_stringIntoBytes(t *testing.T) {\n\tt.Parallel()\n\trows := NewRows([]string{\"raw\"}).\n\t\tAddRow(`one binary value with some text!`).\n\t\tAddRow(`two binary value with even more text than the first one`)\n\tscan := func(rs *sql.Rows) ([]byte, error) {\n\t\tvar b []byte\n\t\treturn b, rs.Scan(&b)\n\t}\n\twant := [][]byte{[]byte(`one binary value with some text!`), []byte(`two binary value with even more text than the first one`)}\n\tqueryRowBytesNotInvalidatedByNext(t, rows, scan, want)\n}\n\nfunc TestQueryRowBytesInvalidatedByClose_bytesIntoRawBytes(t *testing.T) {\n\tt.Parallel()\n\treplace := []byte(invalid)\n\trows := NewRows([]string{\"raw\"}).AddRow([]byte(`one binary value with some text!`))\n\tscan := func(rs *sql.Rows) ([]byte, error) {\n\t\tvar raw sql.RawBytes\n\t\treturn raw, rs.Scan(&raw)\n\t}\n\twant := struct {\n\t\tInitial  []byte\n\t\tReplaced []byte\n\t}{\n\t\tInitial:  []byte(`one binary value with some text!`),\n\t\tReplaced: replace[:len(replace)-7],\n\t}\n\tqueryRowBytesInvalidatedByClose(t, rows, scan, want)\n}\n\nfunc TestQueryRowBytesNotInvalidatedByClose_bytesIntoBytes(t *testing.T) {\n\tt.Parallel()\n\trows := NewRows([]string{\"raw\"}).AddRow([]byte(`one binary value with some text!`))\n\tscan := func(rs *sql.Rows) ([]byte, error) {\n\t\tvar b []byte\n\t\treturn b, rs.Scan(&b)\n\t}\n\tqueryRowBytesNotInvalidatedByClose(t, rows, scan, []byte(`one binary value with some text!`))\n}\n\nfunc TestQueryRowBytesNotInvalidatedByClose_stringIntoBytes(t *testing.T) {\n\tt.Parallel()\n\trows := NewRows([]string{\"raw\"}).AddRow(`one binary value with some text!`)\n\tscan := func(rs *sql.Rows) ([]byte, error) {\n\t\tvar b []byte\n\t\treturn b, rs.Scan(&b)\n\t}\n\tqueryRowBytesNotInvalidatedByClose(t, rows, scan, []byte(`one binary value with some text!`))\n}\n\nfunc TestRowsScanError(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Fatalf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tr := NewRows([]string{\"col1\", \"col2\"}).AddRow(\"one\", \"two\").AddRow(\"one\", nil)\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(r)\n\n\trs, err := db.Query(\"SELECT\")\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\tdefer rs.Close()\n\n\tvar one, two string\n\tif !rs.Next() || rs.Err() != nil || rs.Scan(&one, &two) != nil {\n\t\tt.Fatal(\"unexpected error on first row scan\")\n\t}\n\n\tif !rs.Next() || rs.Err() != nil {\n\t\tt.Fatal(\"unexpected error on second row read\")\n\t}\n\n\terr = rs.Scan(&one, &two)\n\tif err == nil {\n\t\tt.Fatal(\"expected an error for scan, but got none\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestCSVRowParser(t *testing.T) {\n\tt.Parallel()\n\trs := NewRows([]string{\"col1\", \"col2\", \"col3\"}).FromCSVString(\"a,NULL,NULL\")\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Fatalf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(rs)\n\n\trw, err := db.Query(\"SELECT\")\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\tdefer rw.Close()\n\tvar col1 string\n\tvar col2 []byte\n\tvar col3 *string\n\n\trw.Next()\n\tif err = rw.Scan(&col1, &col2, &col3); err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\tif col1 != \"a\" {\n\t\tt.Fatalf(\"expected col1 to be 'a', but got [%T]:%+v\", col1, col1)\n\t}\n\tif col2 != nil {\n\t\tt.Fatalf(\"expected col2 to be nil, but got [%T]:%+v\", col2, col2)\n\t}\n\tif col3 != nil {\n\t\tt.Fatalf(\"expected col3 to be nil, but got [%T]:%+v\", col3, col3)\n\t}\n}\n\nfunc TestCSVParserInvalidInput(t *testing.T) {\n\tdefer func() {\n\t\trecover()\n\t}()\n\t_ = NewRows([]string{\"col1\", \"col2\"}).FromCSVString(\"a,\\\"NULL\\\"\\\"\")\n\t// shouldn't reach here\n\tt.Error(\"expected panic from parsing invalid CSV\")\n}\n\nfunc TestWrongNumberOfValues(t *testing.T) {\n\t// Open new mock database\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"error creating mock database\")\n\t\treturn\n\t}\n\tdefer db.Close()\n\tdefer func() {\n\t\trecover()\n\t}()\n\tmock.ExpectQuery(\"SELECT ID FROM TABLE\").WithArgs(101).WillReturnRows(NewRows([]string{\"ID\"}).AddRow(101, \"Hello\"))\n\tdb.Query(\"SELECT ID FROM TABLE\", 101)\n\t// shouldn't reach here\n\tt.Error(\"expected panic from query\")\n}\n\nfunc TestEmptyRowSets(t *testing.T) {\n\trs1 := NewRows([]string{\"a\"}).AddRow(\"a\")\n\trs2 := NewRows([]string{\"b\"})\n\trs3 := NewRows([]string{\"c\"})\n\n\tset1 := &rowSets{sets: []*Rows{rs1, rs2}}\n\tset2 := &rowSets{sets: []*Rows{rs3, rs2}}\n\tset3 := &rowSets{sets: []*Rows{rs2}}\n\n\tif set1.empty() {\n\t\tt.Fatalf(\"expected rowset 1, not to be empty, but it was\")\n\t}\n\tif !set2.empty() {\n\t\tt.Fatalf(\"expected rowset 2, to be empty, but it was not\")\n\t}\n\tif !set3.empty() {\n\t\tt.Fatalf(\"expected rowset 3, to be empty, but it was not\")\n\t}\n}\n\nfunc queryRowBytesInvalidatedByNext(t *testing.T, rows *Rows, scan func(*sql.Rows) ([]byte, error), want []struct {\n\tInitial  []byte\n\tReplaced []byte\n}) {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Fatalf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(rows)\n\n\trs, err := db.Query(\"SELECT\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to query rows: %s\", err)\n\t}\n\n\tif !rs.Next() || rs.Err() != nil {\n\t\tt.Fatal(\"unexpected error on first row retrieval\")\n\t}\n\tvar count int\n\tfor i := 0; ; i++ {\n\t\tcount++\n\t\tb, err := scan(rs)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error scanning row: %s\", err)\n\t\t}\n\t\tif exp := want[i].Initial; !bytes.Equal(b, exp) {\n\t\t\tt.Fatalf(\"expected raw value to be '%s' (len:%d), but got [%T]:%s (len:%d)\", exp, len(exp), b, b, len(b))\n\t\t}\n\t\tnext := rs.Next()\n\t\tif exp := want[i].Replaced; !bytes.Equal(b, exp) {\n\t\t\tt.Fatalf(\"expected raw value to be replaced with '%s' (len:%d) after calling Next(), but got [%T]:%s (len:%d)\", exp, len(exp), b, b, len(b))\n\t\t}\n\t\tif !next {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err := rs.Err(); err != nil {\n\t\tt.Fatalf(\"row iteration failed: %s\", err)\n\t}\n\tif exp := len(want); count != exp {\n\t\tt.Fatalf(\"incorrect number of rows exp: %d, but got %d\", exp, count)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc queryRowBytesNotInvalidatedByNext(t *testing.T, rows *Rows, scan func(*sql.Rows) ([]byte, error), want [][]byte) {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Fatalf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(rows)\n\n\trs, err := db.Query(\"SELECT\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to query rows: %s\", err)\n\t}\n\n\tif !rs.Next() || rs.Err() != nil {\n\t\tt.Fatal(\"unexpected error on first row retrieval\")\n\t}\n\tvar count int\n\tfor i := 0; ; i++ {\n\t\tcount++\n\t\tb, err := scan(rs)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error scanning row: %s\", err)\n\t\t}\n\t\tif exp := want[i]; !bytes.Equal(b, exp) {\n\t\t\tt.Fatalf(\"expected raw value to be '%s' (len:%d), but got [%T]:%s (len:%d)\", exp, len(exp), b, b, len(b))\n\t\t}\n\t\tnext := rs.Next()\n\t\tif exp := want[i]; !bytes.Equal(b, exp) {\n\t\t\tt.Fatalf(\"expected raw value to be replaced with '%s' (len:%d) after calling Next(), but got [%T]:%s (len:%d)\", exp, len(exp), b, b, len(b))\n\t\t}\n\t\tif !next {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err := rs.Err(); err != nil {\n\t\tt.Fatalf(\"row iteration failed: %s\", err)\n\t}\n\tif exp := len(want); count != exp {\n\t\tt.Fatalf(\"incorrect number of rows exp: %d, but got %d\", exp, count)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc queryRowBytesInvalidatedByClose(t *testing.T, rows *Rows, scan func(*sql.Rows) ([]byte, error), want struct {\n\tInitial  []byte\n\tReplaced []byte\n}) {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Fatalf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(rows)\n\n\trs, err := db.Query(\"SELECT\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to query rows: %s\", err)\n\t}\n\n\tif !rs.Next() || rs.Err() != nil {\n\t\tt.Fatal(\"unexpected error on first row retrieval\")\n\t}\n\tb, err := scan(rs)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error scanning row: %s\", err)\n\t}\n\tif !bytes.Equal(b, want.Initial) {\n\t\tt.Fatalf(\"expected raw value to be '%s' (len:%d), but got [%T]:%s (len:%d)\", want.Initial, len(want.Initial), b, b, len(b))\n\t}\n\tif err := rs.Close(); err != nil {\n\t\tt.Fatalf(\"unexpected error closing rows: %s\", err)\n\t}\n\tif !bytes.Equal(b, want.Replaced) {\n\t\tt.Fatalf(\"expected raw value to be replaced with '%s' (len:%d) after calling Next(), but got [%T]:%s (len:%d)\", want.Replaced, len(want.Replaced), b, b, len(b))\n\t}\n\tif err := rs.Err(); err != nil {\n\t\tt.Fatalf(\"row iteration failed: %s\", err)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc queryRowBytesNotInvalidatedByClose(t *testing.T, rows *Rows, scan func(*sql.Rows) ([]byte, error), want []byte) {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Fatalf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(rows)\n\n\trs, err := db.Query(\"SELECT\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to query rows: %s\", err)\n\t}\n\n\tif !rs.Next() || rs.Err() != nil {\n\t\tt.Fatal(\"unexpected error on first row retrieval\")\n\t}\n\tb, err := scan(rs)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error scanning row: %s\", err)\n\t}\n\tif !bytes.Equal(b, want) {\n\t\tt.Fatalf(\"expected raw value to be '%s' (len:%d), but got [%T]:%s (len:%d)\", want, len(want), b, b, len(b))\n\t}\n\tif err := rs.Close(); err != nil {\n\t\tt.Fatalf(\"unexpected error closing rows: %s\", err)\n\t}\n\tif !bytes.Equal(b, want) {\n\t\tt.Fatalf(\"expected raw value to be replaced with '%s' (len:%d) after calling Next(), but got [%T]:%s (len:%d)\", want, len(want), b, b, len(b))\n\t}\n\tif err := rs.Err(); err != nil {\n\t\tt.Fatalf(\"row iteration failed: %s\", err)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestAddRows(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Fatalf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tvalues := [][]driver.Value{\n\t\t{\n\t\t\t1, \"John\",\n\t\t},\n\t\t{\n\t\t\t2, \"Jane\",\n\t\t},\n\t\t{\n\t\t\t3, \"Peter\",\n\t\t},\n\t\t{\n\t\t\t4, \"Emily\",\n\t\t},\n\t}\n\n\trows := NewRows([]string{\"id\", \"name\"}).AddRows(values...)\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(rows).RowsWillBeClosed()\n\n\trs, _ := db.Query(\"SELECT\")\n\tdefer rs.Close()\n\n\tfor rs.Next() {\n\t\tvar id int\n\t\tvar name string\n\t\trs.Scan(&id, &name)\n\t\tfmt.Println(\"scanned id:\", id, \"and name:\", name)\n\t}\n\n\tif rs.Err() != nil {\n\t\tfmt.Println(\"got rows error:\", rs.Err())\n\t}\n\t// Output: scanned id: 1 and title: John\n\t// scanned id: 2 and title: Jane\n\t// scanned id: 3 and title: Peter\n\t// scanned id: 4 and title: Emily\n}\n\nfunc TestAddRowExpectPanic(t *testing.T) {\n\tt.Parallel()\n\n\tconst expectedPanic = \"Expected number of values to match number of columns: expected 1, actual 2\"\n\tvalues := []driver.Value{\n\t\t\"John\",\n\t\t\"Jane\",\n\t}\n\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tif r != expectedPanic {\n\t\t\t\tt.Fatalf(\"panic message did not match expected: expected '%s', actual '%s'\", r, expectedPanic)\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\t\tt.Fatalf(\"expected panic: %s\", expectedPanic)\n\t}()\n\n\trows := NewRows([]string{\"id\", \"name\"})\n\t// Note missing spread \"...\"\n\trows.AddRow(values)\n}\n\nfunc ExampleRows_AddRows() {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"failed to open sqlmock database:\", err)\n\t}\n\tdefer db.Close()\n\n\tvalues := [][]driver.Value{\n\t\t{\n\t\t\t1, \"one\",\n\t\t},\n\t\t{\n\t\t\t2, \"two\",\n\t\t},\n\t}\n\n\trows := NewRows([]string{\"id\", \"title\"}).AddRows(values...)\n\n\tmock.ExpectQuery(\"SELECT\").WillReturnRows(rows)\n\n\trs, _ := db.Query(\"SELECT\")\n\tdefer rs.Close()\n\n\tfor rs.Next() {\n\t\tvar id int\n\t\tvar title string\n\t\trs.Scan(&id, &title)\n\t\tfmt.Println(\"scanned id:\", id, \"and title:\", title)\n\t}\n\n\tif rs.Err() != nil {\n\t\tfmt.Println(\"got rows error:\", rs.Err())\n\t}\n\t// Output: scanned id: 1 and title: one\n\t// scanned id: 2 and title: two\n}\n"
        },
        {
          "name": "sqlmock.go",
          "type": "blob",
          "size": 11.310546875,
          "content": "/*\nPackage sqlmock is a mock library implementing sql driver. Which has one and only\npurpose - to simulate any sql driver behavior in tests, without needing a real\ndatabase connection. It helps to maintain correct **TDD** workflow.\n\nIt does not require any modifications to your source code in order to test\nand mock database operations. Supports concurrency and multiple database mocking.\n\nThe driver allows to mock any sql driver method behavior.\n*/\npackage sqlmock\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// Sqlmock interface serves to create expectations\n// for any kind of database action in order to mock\n// and test real database behavior.\ntype SqlmockCommon interface {\n\t// ExpectClose queues an expectation for this database\n\t// action to be triggered. the *ExpectedClose allows\n\t// to mock database response\n\tExpectClose() *ExpectedClose\n\n\t// ExpectationsWereMet checks whether all queued expectations\n\t// were met in order. If any of them was not met - an error is returned.\n\tExpectationsWereMet() error\n\n\t// ExpectPrepare expects Prepare() to be called with expectedSQL query.\n\t// the *ExpectedPrepare allows to mock database response.\n\t// Note that you may expect Query() or Exec() on the *ExpectedPrepare\n\t// statement to prevent repeating expectedSQL\n\tExpectPrepare(expectedSQL string) *ExpectedPrepare\n\n\t// ExpectQuery expects Query() or QueryRow() to be called with expectedSQL query.\n\t// the *ExpectedQuery allows to mock database response.\n\tExpectQuery(expectedSQL string) *ExpectedQuery\n\n\t// ExpectExec expects Exec() to be called with expectedSQL query.\n\t// the *ExpectedExec allows to mock database response\n\tExpectExec(expectedSQL string) *ExpectedExec\n\n\t// ExpectBegin expects *sql.DB.Begin to be called.\n\t// the *ExpectedBegin allows to mock database response\n\tExpectBegin() *ExpectedBegin\n\n\t// ExpectCommit expects *sql.Tx.Commit to be called.\n\t// the *ExpectedCommit allows to mock database response\n\tExpectCommit() *ExpectedCommit\n\n\t// ExpectRollback expects *sql.Tx.Rollback to be called.\n\t// the *ExpectedRollback allows to mock database response\n\tExpectRollback() *ExpectedRollback\n\n\t// ExpectPing expected *sql.DB.Ping to be called.\n\t// the *ExpectedPing allows to mock database response\n\t//\n\t// Ping support only exists in the SQL library in Go 1.8 and above.\n\t// ExpectPing in Go <=1.7 will return an ExpectedPing but not register\n\t// any expectations.\n\t//\n\t// You must enable pings using MonitorPingsOption for this to register\n\t// any expectations.\n\tExpectPing() *ExpectedPing\n\n\t// MatchExpectationsInOrder gives an option whether to match all\n\t// expectations in the order they were set or not.\n\t//\n\t// By default it is set to - true. But if you use goroutines\n\t// to parallelize your query executation, that option may\n\t// be handy.\n\t//\n\t// This option may be turned on anytime during tests. As soon\n\t// as it is switched to false, expectations will be matched\n\t// in any order. Or otherwise if switched to true, any unmatched\n\t// expectations will be expected in order\n\tMatchExpectationsInOrder(bool)\n\n\t// NewRows allows Rows to be created from a\n\t// sql driver.Value slice or from the CSV string and\n\t// to be used as sql driver.Rows.\n\tNewRows(columns []string) *Rows\n}\n\ntype sqlmock struct {\n\tordered      bool\n\tdsn          string\n\topened       int\n\tdrv          *mockDriver\n\tconverter    driver.ValueConverter\n\tqueryMatcher QueryMatcher\n\tmonitorPings bool\n\n\texpected []expectation\n}\n\nfunc (c *sqlmock) open(options []SqlMockOption) (*sql.DB, Sqlmock, error) {\n\tdb, err := sql.Open(\"sqlmock\", c.dsn)\n\tif err != nil {\n\t\treturn db, c, err\n\t}\n\tfor _, option := range options {\n\t\terr := option(c)\n\t\tif err != nil {\n\t\t\treturn db, c, err\n\t\t}\n\t}\n\tif c.converter == nil {\n\t\tc.converter = driver.DefaultParameterConverter\n\t}\n\tif c.queryMatcher == nil {\n\t\tc.queryMatcher = QueryMatcherRegexp\n\t}\n\n\tif c.monitorPings {\n\t\t// We call Ping on the driver shortly to verify startup assertions by\n\t\t// driving internal behaviour of the sql standard library. We don't\n\t\t// want this call to ping to be monitored for expectation purposes so\n\t\t// temporarily disable.\n\t\tc.monitorPings = false\n\t\tdefer func() { c.monitorPings = true }()\n\t}\n\treturn db, c, db.Ping()\n}\n\nfunc (c *sqlmock) ExpectClose() *ExpectedClose {\n\te := &ExpectedClose{}\n\tc.expected = append(c.expected, e)\n\treturn e\n}\n\nfunc (c *sqlmock) MatchExpectationsInOrder(b bool) {\n\tc.ordered = b\n}\n\n// Close a mock database driver connection. It may or may not\n// be called depending on the circumstances, but if it is called\n// there must be an *ExpectedClose expectation satisfied.\n// meets http://golang.org/pkg/database/sql/driver/#Conn interface\nfunc (c *sqlmock) Close() error {\n\tc.drv.Lock()\n\tdefer c.drv.Unlock()\n\n\tc.opened--\n\tif c.opened == 0 {\n\t\tdelete(c.drv.conns, c.dsn)\n\t}\n\n\tvar expected *ExpectedClose\n\tvar fulfilled int\n\tvar ok bool\n\tfor _, next := range c.expected {\n\t\tnext.Lock()\n\t\tif next.fulfilled() {\n\t\t\tnext.Unlock()\n\t\t\tfulfilled++\n\t\t\tcontinue\n\t\t}\n\n\t\tif expected, ok = next.(*ExpectedClose); ok {\n\t\t\tbreak\n\t\t}\n\n\t\tnext.Unlock()\n\t\tif c.ordered {\n\t\t\treturn fmt.Errorf(\"call to database Close, was not expected, next expectation is: %s\", next)\n\t\t}\n\t}\n\n\tif expected == nil {\n\t\tmsg := \"call to database Close was not expected\"\n\t\tif fulfilled == len(c.expected) {\n\t\t\tmsg = \"all expectations were already fulfilled, \" + msg\n\t\t}\n\t\treturn fmt.Errorf(msg)\n\t}\n\n\texpected.triggered = true\n\texpected.Unlock()\n\treturn expected.err\n}\n\nfunc (c *sqlmock) ExpectationsWereMet() error {\n\tfor _, e := range c.expected {\n\t\te.Lock()\n\t\tfulfilled := e.fulfilled()\n\t\te.Unlock()\n\n\t\tif !fulfilled {\n\t\t\treturn fmt.Errorf(\"there is a remaining expectation which was not matched: %s\", e)\n\t\t}\n\n\t\t// for expected prepared statement check whether it was closed if expected\n\t\tif prep, ok := e.(*ExpectedPrepare); ok {\n\t\t\tif prep.mustBeClosed && !prep.wasClosed {\n\t\t\t\treturn fmt.Errorf(\"expected prepared statement to be closed, but it was not: %s\", prep)\n\t\t\t}\n\t\t}\n\n\t\t// must check whether all expected queried rows are closed\n\t\tif query, ok := e.(*ExpectedQuery); ok {\n\t\t\tif query.rowsMustBeClosed && !query.rowsWereClosed {\n\t\t\t\treturn fmt.Errorf(\"expected query rows to be closed, but it was not: %s\", query)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Begin meets http://golang.org/pkg/database/sql/driver/#Conn interface\nfunc (c *sqlmock) Begin() (driver.Tx, error) {\n\tex, err := c.begin(driver.TxOptions{})\n\tif ex != nil {\n\t\ttime.Sleep(ex.delay)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn c, nil\n}\n\nfunc (c *sqlmock) begin(opts driver.TxOptions) (*ExpectedBegin, error) {\n\tvar expected *ExpectedBegin\n\tvar ok bool\n\tvar fulfilled int\n\tfor _, next := range c.expected {\n\t\tnext.Lock()\n\t\tif next.fulfilled() {\n\t\t\tnext.Unlock()\n\t\t\tfulfilled++\n\t\t\tcontinue\n\t\t}\n\n\t\tif expected, ok = next.(*ExpectedBegin); ok {\n\t\t\tbreak\n\t\t}\n\n\t\tnext.Unlock()\n\t\tif c.ordered {\n\t\t\treturn nil, fmt.Errorf(\"call to database transaction Begin, was not expected, next expectation is: %s\", next)\n\t\t}\n\t}\n\tif expected == nil {\n\t\tmsg := \"call to database transaction Begin was not expected\"\n\t\tif fulfilled == len(c.expected) {\n\t\t\tmsg = \"all expectations were already fulfilled, \" + msg\n\t\t}\n\t\treturn nil, fmt.Errorf(msg)\n\t}\n\tdefer expected.Unlock()\n\tif expected.txOpts != nil &&\n\t\texpected.txOpts.Isolation != opts.Isolation &&\n\t\texpected.txOpts.ReadOnly != opts.ReadOnly {\n\t\treturn nil, fmt.Errorf(\"expected transaction options do not match: %+v, got: %+v\", expected.txOpts, opts)\n\t}\n\n\texpected.triggered = true\n\n\treturn expected, expected.err\n}\n\nfunc (c *sqlmock) ExpectBegin() *ExpectedBegin {\n\te := &ExpectedBegin{}\n\tc.expected = append(c.expected, e)\n\treturn e\n}\n\nfunc (c *sqlmock) ExpectExec(expectedSQL string) *ExpectedExec {\n\te := &ExpectedExec{}\n\te.expectSQL = expectedSQL\n\te.converter = c.converter\n\tc.expected = append(c.expected, e)\n\treturn e\n}\n\n// Prepare meets http://golang.org/pkg/database/sql/driver/#Conn interface\nfunc (c *sqlmock) Prepare(query string) (driver.Stmt, error) {\n\tex, err := c.prepare(query)\n\tif ex != nil {\n\t\ttime.Sleep(ex.delay)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &statement{c, ex, query}, nil\n}\n\nfunc (c *sqlmock) prepare(query string) (*ExpectedPrepare, error) {\n\tvar expected *ExpectedPrepare\n\tvar fulfilled int\n\tvar ok bool\n\n\tfor _, next := range c.expected {\n\t\tnext.Lock()\n\t\tif next.fulfilled() {\n\t\t\tnext.Unlock()\n\t\t\tfulfilled++\n\t\t\tcontinue\n\t\t}\n\n\t\tif c.ordered {\n\t\t\tif expected, ok = next.(*ExpectedPrepare); ok {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tnext.Unlock()\n\t\t\treturn nil, fmt.Errorf(\"call to Prepare statement with query '%s', was not expected, next expectation is: %s\", query, next)\n\t\t}\n\n\t\tif pr, ok := next.(*ExpectedPrepare); ok {\n\t\t\tif err := c.queryMatcher.Match(pr.expectSQL, query); err == nil {\n\t\t\t\texpected = pr\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tnext.Unlock()\n\t}\n\n\tif expected == nil {\n\t\tmsg := \"call to Prepare '%s' query was not expected\"\n\t\tif fulfilled == len(c.expected) {\n\t\t\tmsg = \"all expectations were already fulfilled, \" + msg\n\t\t}\n\t\treturn nil, fmt.Errorf(msg, query)\n\t}\n\tdefer expected.Unlock()\n\tif err := c.queryMatcher.Match(expected.expectSQL, query); err != nil {\n\t\treturn nil, fmt.Errorf(\"Prepare: %v\", err)\n\t}\n\n\texpected.triggered = true\n\treturn expected, expected.err\n}\n\nfunc (c *sqlmock) ExpectPrepare(expectedSQL string) *ExpectedPrepare {\n\te := &ExpectedPrepare{expectSQL: expectedSQL, mock: c}\n\tc.expected = append(c.expected, e)\n\treturn e\n}\n\nfunc (c *sqlmock) ExpectQuery(expectedSQL string) *ExpectedQuery {\n\te := &ExpectedQuery{}\n\te.expectSQL = expectedSQL\n\te.converter = c.converter\n\tc.expected = append(c.expected, e)\n\treturn e\n}\n\nfunc (c *sqlmock) ExpectCommit() *ExpectedCommit {\n\te := &ExpectedCommit{}\n\tc.expected = append(c.expected, e)\n\treturn e\n}\n\nfunc (c *sqlmock) ExpectRollback() *ExpectedRollback {\n\te := &ExpectedRollback{}\n\tc.expected = append(c.expected, e)\n\treturn e\n}\n\n// Commit meets http://golang.org/pkg/database/sql/driver/#Tx\nfunc (c *sqlmock) Commit() error {\n\tvar expected *ExpectedCommit\n\tvar fulfilled int\n\tvar ok bool\n\tfor _, next := range c.expected {\n\t\tnext.Lock()\n\t\tif next.fulfilled() {\n\t\t\tnext.Unlock()\n\t\t\tfulfilled++\n\t\t\tcontinue\n\t\t}\n\n\t\tif expected, ok = next.(*ExpectedCommit); ok {\n\t\t\tbreak\n\t\t}\n\n\t\tnext.Unlock()\n\t\tif c.ordered {\n\t\t\treturn fmt.Errorf(\"call to Commit transaction, was not expected, next expectation is: %s\", next)\n\t\t}\n\t}\n\tif expected == nil {\n\t\tmsg := \"call to Commit transaction was not expected\"\n\t\tif fulfilled == len(c.expected) {\n\t\t\tmsg = \"all expectations were already fulfilled, \" + msg\n\t\t}\n\t\treturn fmt.Errorf(msg)\n\t}\n\n\texpected.triggered = true\n\texpected.Unlock()\n\treturn expected.err\n}\n\n// Rollback meets http://golang.org/pkg/database/sql/driver/#Tx\nfunc (c *sqlmock) Rollback() error {\n\tvar expected *ExpectedRollback\n\tvar fulfilled int\n\tvar ok bool\n\tfor _, next := range c.expected {\n\t\tnext.Lock()\n\t\tif next.fulfilled() {\n\t\t\tnext.Unlock()\n\t\t\tfulfilled++\n\t\t\tcontinue\n\t\t}\n\n\t\tif expected, ok = next.(*ExpectedRollback); ok {\n\t\t\tbreak\n\t\t}\n\n\t\tnext.Unlock()\n\t\tif c.ordered {\n\t\t\treturn fmt.Errorf(\"call to Rollback transaction, was not expected, next expectation is: %s\", next)\n\t\t}\n\t}\n\tif expected == nil {\n\t\tmsg := \"call to Rollback transaction was not expected\"\n\t\tif fulfilled == len(c.expected) {\n\t\t\tmsg = \"all expectations were already fulfilled, \" + msg\n\t\t}\n\t\treturn fmt.Errorf(msg)\n\t}\n\n\texpected.triggered = true\n\texpected.Unlock()\n\treturn expected.err\n}\n\n// NewRows allows Rows to be created from a\n// sql driver.Value slice or from the CSV string and\n// to be used as sql driver.Rows.\nfunc (c *sqlmock) NewRows(columns []string) *Rows {\n\tr := NewRows(columns)\n\tr.converter = c.converter\n\treturn r\n}\n"
        },
        {
          "name": "sqlmock_before_go18.go",
          "type": "blob",
          "size": 4.3974609375,
          "content": "// +build !go1.8\n\npackage sqlmock\n\nimport (\n\t\"database/sql/driver\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n)\n\n// Sqlmock interface for Go up to 1.7\ntype Sqlmock interface {\n\t// Embed common methods\n\tSqlmockCommon\n}\n\ntype namedValue struct {\n\tName    string\n\tOrdinal int\n\tValue   driver.Value\n}\n\nfunc (c *sqlmock) ExpectPing() *ExpectedPing {\n\tlog.Println(\"ExpectPing has no effect on Go 1.7 or below\")\n\treturn &ExpectedPing{}\n}\n\n// Query meets http://golang.org/pkg/database/sql/driver/#Queryer\nfunc (c *sqlmock) Query(query string, args []driver.Value) (driver.Rows, error) {\n\tnamedArgs := make([]namedValue, len(args))\n\tfor i, v := range args {\n\t\tnamedArgs[i] = namedValue{\n\t\t\tOrdinal: i + 1,\n\t\t\tValue:   v,\n\t\t}\n\t}\n\n\tex, err := c.query(query, namedArgs)\n\tif ex != nil {\n\t\ttime.Sleep(ex.delay)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn ex.rows, nil\n}\n\nfunc (c *sqlmock) query(query string, args []namedValue) (*ExpectedQuery, error) {\n\tvar expected *ExpectedQuery\n\tvar fulfilled int\n\tvar ok bool\n\tfor _, next := range c.expected {\n\t\tnext.Lock()\n\t\tif next.fulfilled() {\n\t\t\tnext.Unlock()\n\t\t\tfulfilled++\n\t\t\tcontinue\n\t\t}\n\n\t\tif c.ordered {\n\t\t\tif expected, ok = next.(*ExpectedQuery); ok {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnext.Unlock()\n\t\t\treturn nil, fmt.Errorf(\"call to Query '%s' with args %+v, was not expected, next expectation is: %s\", query, args, next)\n\t\t}\n\t\tif qr, ok := next.(*ExpectedQuery); ok {\n\t\t\tif err := c.queryMatcher.Match(qr.expectSQL, query); err != nil {\n\t\t\t\tnext.Unlock()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif err := qr.attemptArgMatch(args); err == nil {\n\t\t\t\texpected = qr\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tnext.Unlock()\n\t}\n\n\tif expected == nil {\n\t\tmsg := \"call to Query '%s' with args %+v was not expected\"\n\t\tif fulfilled == len(c.expected) {\n\t\t\tmsg = \"all expectations were already fulfilled, \" + msg\n\t\t}\n\t\treturn nil, fmt.Errorf(msg, query, args)\n\t}\n\n\tdefer expected.Unlock()\n\n\tif err := c.queryMatcher.Match(expected.expectSQL, query); err != nil {\n\t\treturn nil, fmt.Errorf(\"Query: %v\", err)\n\t}\n\n\tif err := expected.argsMatches(args); err != nil {\n\t\treturn nil, fmt.Errorf(\"Query '%s', arguments do not match: %s\", query, err)\n\t}\n\n\texpected.triggered = true\n\tif expected.err != nil {\n\t\treturn expected, expected.err // mocked to return error\n\t}\n\n\tif expected.rows == nil {\n\t\treturn nil, fmt.Errorf(\"Query '%s' with args %+v, must return a database/sql/driver.Rows, but it was not set for expectation %T as %+v\", query, args, expected, expected)\n\t}\n\treturn expected, nil\n}\n\n// Exec meets http://golang.org/pkg/database/sql/driver/#Execer\nfunc (c *sqlmock) Exec(query string, args []driver.Value) (driver.Result, error) {\n\tnamedArgs := make([]namedValue, len(args))\n\tfor i, v := range args {\n\t\tnamedArgs[i] = namedValue{\n\t\t\tOrdinal: i + 1,\n\t\t\tValue:   v,\n\t\t}\n\t}\n\n\tex, err := c.exec(query, namedArgs)\n\tif ex != nil {\n\t\ttime.Sleep(ex.delay)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn ex.result, nil\n}\n\nfunc (c *sqlmock) exec(query string, args []namedValue) (*ExpectedExec, error) {\n\tvar expected *ExpectedExec\n\tvar fulfilled int\n\tvar ok bool\n\tfor _, next := range c.expected {\n\t\tnext.Lock()\n\t\tif next.fulfilled() {\n\t\t\tnext.Unlock()\n\t\t\tfulfilled++\n\t\t\tcontinue\n\t\t}\n\n\t\tif c.ordered {\n\t\t\tif expected, ok = next.(*ExpectedExec); ok {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnext.Unlock()\n\t\t\treturn nil, fmt.Errorf(\"call to ExecQuery '%s' with args %+v, was not expected, next expectation is: %s\", query, args, next)\n\t\t}\n\t\tif exec, ok := next.(*ExpectedExec); ok {\n\t\t\tif err := c.queryMatcher.Match(exec.expectSQL, query); err != nil {\n\t\t\t\tnext.Unlock()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif err := exec.attemptArgMatch(args); err == nil {\n\t\t\t\texpected = exec\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tnext.Unlock()\n\t}\n\tif expected == nil {\n\t\tmsg := \"call to ExecQuery '%s' with args %+v was not expected\"\n\t\tif fulfilled == len(c.expected) {\n\t\t\tmsg = \"all expectations were already fulfilled, \" + msg\n\t\t}\n\t\treturn nil, fmt.Errorf(msg, query, args)\n\t}\n\tdefer expected.Unlock()\n\n\tif err := c.queryMatcher.Match(expected.expectSQL, query); err != nil {\n\t\treturn nil, fmt.Errorf(\"ExecQuery: %v\", err)\n\t}\n\n\tif err := expected.argsMatches(args); err != nil {\n\t\treturn nil, fmt.Errorf(\"ExecQuery '%s', arguments do not match: %s\", query, err)\n\t}\n\n\texpected.triggered = true\n\tif expected.err != nil {\n\t\treturn expected, expected.err // mocked to return error\n\t}\n\n\tif expected.result == nil {\n\t\treturn nil, fmt.Errorf(\"ExecQuery '%s' with args %+v, must return a database/sql/driver.Result, but it was not set for expectation %T as %+v\", query, args, expected, expected)\n\t}\n\n\treturn expected, nil\n}\n"
        },
        {
          "name": "sqlmock_before_go18_test.go",
          "type": "blob",
          "size": 0.52734375,
          "content": "// +build !go1.8\n\npackage sqlmock\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestSqlmockExpectPingHasNoEffect(t *testing.T) {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\te := mock.ExpectPing()\n\n\t// Methods on the expectation can be called\n\te.WillDelayFor(time.Hour).WillReturnError(fmt.Errorf(\"an error\"))\n\n\tif err = mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"expected no error to be returned, but got '%s'\", err)\n\t}\n}\n"
        },
        {
          "name": "sqlmock_go18.go",
          "type": "blob",
          "size": 8.560546875,
          "content": "//go:build go1.8\n// +build go1.8\n\npackage sqlmock\n\nimport (\n\t\"context\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n)\n\n// Sqlmock interface for Go 1.8+\ntype Sqlmock interface {\n\t// Embed common methods\n\tSqlmockCommon\n\n\t// NewRowsWithColumnDefinition allows Rows to be created from a\n\t// sql driver.Value slice with a definition of sql metadata\n\tNewRowsWithColumnDefinition(columns ...*Column) *Rows\n\n\t// New Column allows to create a Column\n\tNewColumn(name string) *Column\n}\n\n// ErrCancelled defines an error value, which can be expected in case of\n// such cancellation error.\nvar ErrCancelled = errors.New(\"canceling query due to user request\")\n\n// Implement the \"QueryerContext\" interface\nfunc (c *sqlmock) QueryContext(ctx context.Context, query string, args []driver.NamedValue) (driver.Rows, error) {\n\tex, err := c.query(query, args)\n\tif ex != nil {\n\t\tselect {\n\t\tcase <-time.After(ex.delay):\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn ex.rows, nil\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ErrCancelled\n\t\t}\n\t}\n\n\treturn nil, err\n}\n\n// Implement the \"ExecerContext\" interface\nfunc (c *sqlmock) ExecContext(ctx context.Context, query string, args []driver.NamedValue) (driver.Result, error) {\n\tex, err := c.exec(query, args)\n\tif ex != nil {\n\t\tselect {\n\t\tcase <-time.After(ex.delay):\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn ex.result, nil\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ErrCancelled\n\t\t}\n\t}\n\n\treturn nil, err\n}\n\n// Implement the \"ConnBeginTx\" interface\nfunc (c *sqlmock) BeginTx(ctx context.Context, opts driver.TxOptions) (driver.Tx, error) {\n\tex, err := c.begin(opts)\n\tif ex != nil {\n\t\tselect {\n\t\tcase <-time.After(ex.delay):\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn c, nil\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ErrCancelled\n\t\t}\n\t}\n\n\treturn nil, err\n}\n\n// Implement the \"ConnPrepareContext\" interface\nfunc (c *sqlmock) PrepareContext(ctx context.Context, query string) (driver.Stmt, error) {\n\tex, err := c.prepare(query)\n\tif ex != nil {\n\t\tselect {\n\t\tcase <-time.After(ex.delay):\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn &statement{c, ex, query}, nil\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ErrCancelled\n\t\t}\n\t}\n\n\treturn nil, err\n}\n\n// Implement the \"Pinger\" interface - the explicit DB driver ping was only added to database/sql in Go 1.8\nfunc (c *sqlmock) Ping(ctx context.Context) error {\n\tif !c.monitorPings {\n\t\treturn nil\n\t}\n\n\tex, err := c.ping()\n\tif ex != nil {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ErrCancelled\n\t\tcase <-time.After(ex.delay):\n\t\t}\n\t}\n\n\treturn err\n}\n\nfunc (c *sqlmock) ping() (*ExpectedPing, error) {\n\tvar expected *ExpectedPing\n\tvar fulfilled int\n\tvar ok bool\n\tfor _, next := range c.expected {\n\t\tnext.Lock()\n\t\tif next.fulfilled() {\n\t\t\tnext.Unlock()\n\t\t\tfulfilled++\n\t\t\tcontinue\n\t\t}\n\n\t\tif expected, ok = next.(*ExpectedPing); ok {\n\t\t\tbreak\n\t\t}\n\n\t\tnext.Unlock()\n\t\tif c.ordered {\n\t\t\treturn nil, fmt.Errorf(\"call to database Ping, was not expected, next expectation is: %s\", next)\n\t\t}\n\t}\n\n\tif expected == nil {\n\t\tmsg := \"call to database Ping was not expected\"\n\t\tif fulfilled == len(c.expected) {\n\t\t\tmsg = \"all expectations were already fulfilled, \" + msg\n\t\t}\n\t\treturn nil, fmt.Errorf(msg)\n\t}\n\n\texpected.triggered = true\n\texpected.Unlock()\n\treturn expected, expected.err\n}\n\n// Implement the \"StmtExecContext\" interface\nfunc (stmt *statement) ExecContext(ctx context.Context, args []driver.NamedValue) (driver.Result, error) {\n\treturn stmt.conn.ExecContext(ctx, stmt.query, args)\n}\n\n// Implement the \"StmtQueryContext\" interface\nfunc (stmt *statement) QueryContext(ctx context.Context, args []driver.NamedValue) (driver.Rows, error) {\n\treturn stmt.conn.QueryContext(ctx, stmt.query, args)\n}\n\nfunc (c *sqlmock) ExpectPing() *ExpectedPing {\n\tif !c.monitorPings {\n\t\tlog.Println(\"ExpectPing will have no effect as monitoring pings is disabled. Use MonitorPingsOption to enable.\")\n\t\treturn nil\n\t}\n\te := &ExpectedPing{}\n\tc.expected = append(c.expected, e)\n\treturn e\n}\n\n// Query meets http://golang.org/pkg/database/sql/driver/#Queryer\n// Deprecated: Drivers should implement QueryerContext instead.\nfunc (c *sqlmock) Query(query string, args []driver.Value) (driver.Rows, error) {\n\tnamedArgs := make([]driver.NamedValue, len(args))\n\tfor i, v := range args {\n\t\tnamedArgs[i] = driver.NamedValue{\n\t\t\tOrdinal: i + 1,\n\t\t\tValue:   v,\n\t\t}\n\t}\n\n\tex, err := c.query(query, namedArgs)\n\tif ex != nil {\n\t\ttime.Sleep(ex.delay)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn ex.rows, nil\n}\n\nfunc (c *sqlmock) query(query string, args []driver.NamedValue) (*ExpectedQuery, error) {\n\tvar expected *ExpectedQuery\n\tvar fulfilled int\n\tvar ok bool\n\tfor _, next := range c.expected {\n\t\tnext.Lock()\n\t\tif next.fulfilled() {\n\t\t\tnext.Unlock()\n\t\t\tfulfilled++\n\t\t\tcontinue\n\t\t}\n\n\t\tif c.ordered {\n\t\t\tif expected, ok = next.(*ExpectedQuery); ok {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnext.Unlock()\n\t\t\treturn nil, fmt.Errorf(\"call to Query '%s' with args %+v, was not expected, next expectation is: %s\", query, args, next)\n\t\t}\n\t\tif qr, ok := next.(*ExpectedQuery); ok {\n\t\t\tif err := c.queryMatcher.Match(qr.expectSQL, query); err != nil {\n\t\t\t\tnext.Unlock()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif err := qr.attemptArgMatch(args); err == nil {\n\t\t\t\texpected = qr\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tnext.Unlock()\n\t}\n\n\tif expected == nil {\n\t\tmsg := \"call to Query '%s' with args %+v was not expected\"\n\t\tif fulfilled == len(c.expected) {\n\t\t\tmsg = \"all expectations were already fulfilled, \" + msg\n\t\t}\n\t\treturn nil, fmt.Errorf(msg, query, args)\n\t}\n\n\tdefer expected.Unlock()\n\n\tif err := c.queryMatcher.Match(expected.expectSQL, query); err != nil {\n\t\treturn nil, fmt.Errorf(\"Query: %v\", err)\n\t}\n\n\tif err := expected.argsMatches(args); err != nil {\n\t\treturn nil, fmt.Errorf(\"Query '%s', arguments do not match: %s\", query, err)\n\t}\n\n\texpected.triggered = true\n\tif expected.err != nil {\n\t\treturn expected, expected.err // mocked to return error\n\t}\n\n\tif expected.rows == nil {\n\t\treturn nil, fmt.Errorf(\"Query '%s' with args %+v, must return a database/sql/driver.Rows, but it was not set for expectation %T as %+v\", query, args, expected, expected)\n\t}\n\treturn expected, nil\n}\n\n// Exec meets http://golang.org/pkg/database/sql/driver/#Execer\n// Deprecated: Drivers should implement ExecerContext instead.\nfunc (c *sqlmock) Exec(query string, args []driver.Value) (driver.Result, error) {\n\tnamedArgs := make([]driver.NamedValue, len(args))\n\tfor i, v := range args {\n\t\tnamedArgs[i] = driver.NamedValue{\n\t\t\tOrdinal: i + 1,\n\t\t\tValue:   v,\n\t\t}\n\t}\n\n\tex, err := c.exec(query, namedArgs)\n\tif ex != nil {\n\t\ttime.Sleep(ex.delay)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn ex.result, nil\n}\n\nfunc (c *sqlmock) exec(query string, args []driver.NamedValue) (*ExpectedExec, error) {\n\tvar expected *ExpectedExec\n\tvar fulfilled int\n\tvar ok bool\n\tfor _, next := range c.expected {\n\t\tnext.Lock()\n\t\tif next.fulfilled() {\n\t\t\tnext.Unlock()\n\t\t\tfulfilled++\n\t\t\tcontinue\n\t\t}\n\n\t\tif c.ordered {\n\t\t\tif expected, ok = next.(*ExpectedExec); ok {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnext.Unlock()\n\t\t\treturn nil, fmt.Errorf(\"call to ExecQuery '%s' with args %+v, was not expected, next expectation is: %s\", query, args, next)\n\t\t}\n\t\tif exec, ok := next.(*ExpectedExec); ok {\n\t\t\tif err := c.queryMatcher.Match(exec.expectSQL, query); err != nil {\n\t\t\t\tnext.Unlock()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif err := exec.attemptArgMatch(args); err == nil {\n\t\t\t\texpected = exec\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tnext.Unlock()\n\t}\n\tif expected == nil {\n\t\tmsg := \"call to ExecQuery '%s' with args %+v was not expected\"\n\t\tif fulfilled == len(c.expected) {\n\t\t\tmsg = \"all expectations were already fulfilled, \" + msg\n\t\t}\n\t\treturn nil, fmt.Errorf(msg, query, args)\n\t}\n\tdefer expected.Unlock()\n\n\tif err := c.queryMatcher.Match(expected.expectSQL, query); err != nil {\n\t\treturn nil, fmt.Errorf(\"ExecQuery: %v\", err)\n\t}\n\n\tif err := expected.argsMatches(args); err != nil {\n\t\treturn nil, fmt.Errorf(\"ExecQuery '%s', arguments do not match: %s\", query, err)\n\t}\n\n\texpected.triggered = true\n\tif expected.err != nil {\n\t\treturn expected, expected.err // mocked to return error\n\t}\n\n\tif expected.result == nil {\n\t\treturn nil, fmt.Errorf(\"ExecQuery '%s' with args %+v, must return a database/sql/driver.Result, but it was not set for expectation %T as %+v\", query, args, expected, expected)\n\t}\n\n\treturn expected, nil\n}\n\n// @TODO maybe add ExpectedBegin.WithOptions(driver.TxOptions)\n\n// NewRowsWithColumnDefinition allows Rows to be created from a\n// sql driver.Value slice with a definition of sql metadata\nfunc (c *sqlmock) NewRowsWithColumnDefinition(columns ...*Column) *Rows {\n\tr := NewRowsWithColumnDefinition(columns...)\n\tr.converter = c.converter\n\treturn r\n}\n\n// NewColumn allows to create a Column that can be enhanced with metadata\n// using OfType/Nullable/WithLength/WithPrecisionAndScale methods.\nfunc (c *sqlmock) NewColumn(name string) *Column {\n\treturn NewColumn(name)\n}\n"
        },
        {
          "name": "sqlmock_go18_19.go",
          "type": "blob",
          "size": 0.2880859375,
          "content": "// +build go1.8,!go1.9\n\npackage sqlmock\n\nimport \"database/sql/driver\"\n\n// CheckNamedValue meets https://golang.org/pkg/database/sql/driver/#NamedValueChecker\nfunc (c *sqlmock) CheckNamedValue(nv *driver.NamedValue) (err error) {\n\tnv.Value, err = c.converter.ConvertValue(nv.Value)\n\treturn err\n}\n"
        },
        {
          "name": "sqlmock_go18_test.go",
          "type": "blob",
          "size": 17.28125,
          "content": "//go:build go1.8\n// +build go1.8\n\npackage sqlmock\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestContextExecCancel(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectExec(\"DELETE FROM users\").\n\t\tWillDelayFor(time.Second).\n\t\tWillReturnResult(NewResult(1, 1))\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 10)\n\t\tcancel()\n\t}()\n\n\t_, err = db.ExecContext(ctx, \"DELETE FROM users\")\n\tif err == nil {\n\t\tt.Error(\"error was expected, but there was none\")\n\t}\n\n\tif err != ErrCancelled {\n\t\tt.Errorf(\"was expecting cancel error, but got: %v\", err)\n\t}\n\n\t_, err = db.ExecContext(ctx, \"DELETE FROM users\")\n\tif err != context.Canceled {\n\t\tt.Error(\"error was expected since context was already done, but there was none\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestPreparedStatementContextExecCancel(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectPrepare(\"DELETE FROM users\").\n\t\tExpectExec().\n\t\tWillDelayFor(time.Second).\n\t\tWillReturnResult(NewResult(1, 1))\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 10)\n\t\tcancel()\n\t}()\n\n\tstmt, err := db.Prepare(\"DELETE FROM users\")\n\tif err != nil {\n\t\tt.Errorf(\"error was not expected, but got: %v\", err)\n\t}\n\n\t_, err = stmt.ExecContext(ctx)\n\tif err == nil {\n\t\tt.Error(\"error was expected, but there was none\")\n\t}\n\n\tif err != ErrCancelled {\n\t\tt.Errorf(\"was expecting cancel error, but got: %v\", err)\n\t}\n\n\t_, err = stmt.ExecContext(ctx)\n\tif err != context.Canceled {\n\t\tt.Error(\"error was expected since context was already done, but there was none\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestContextExecWithNamedArg(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectExec(\"DELETE FROM users\").\n\t\tWithArgs(sql.Named(\"id\", 5)).\n\t\tWillDelayFor(time.Second).\n\t\tWillReturnResult(NewResult(1, 1))\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 10)\n\t\tcancel()\n\t}()\n\n\t_, err = db.ExecContext(ctx, \"DELETE FROM users WHERE id = :id\", sql.Named(\"id\", 5))\n\tif err == nil {\n\t\tt.Error(\"error was expected, but there was none\")\n\t}\n\n\tif err != ErrCancelled {\n\t\tt.Errorf(\"was expecting cancel error, but got: %v\", err)\n\t}\n\n\t_, err = db.ExecContext(ctx, \"DELETE FROM users WHERE id = :id\", sql.Named(\"id\", 5))\n\tif err != context.Canceled {\n\t\tt.Error(\"error was expected since context was already done, but there was none\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestContextExec(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectExec(\"DELETE FROM users\").\n\t\tWillReturnResult(NewResult(1, 1))\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 10)\n\t\tcancel()\n\t}()\n\n\tres, err := db.ExecContext(ctx, \"DELETE FROM users\")\n\tif err != nil {\n\t\tt.Errorf(\"error was not expected, but got: %v\", err)\n\t}\n\n\taffected, err := res.RowsAffected()\n\tif affected != 1 {\n\t\tt.Errorf(\"expected affected rows 1, but got %v\", affected)\n\t}\n\n\tif err != nil {\n\t\tt.Errorf(\"error was not expected, but got: %v\", err)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestContextQueryCancel(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\trs := NewRows([]string{\"id\", \"title\"}).AddRow(5, \"hello world\")\n\n\tmock.ExpectQuery(\"SELECT (.+) FROM articles WHERE id = ?\").\n\t\tWithArgs(5).\n\t\tWillDelayFor(time.Second).\n\t\tWillReturnRows(rs)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 10)\n\t\tcancel()\n\t}()\n\n\t_, err = db.QueryContext(ctx, \"SELECT id, title FROM articles WHERE id = ?\", 5)\n\tif err == nil {\n\t\tt.Error(\"error was expected, but there was none\")\n\t}\n\n\tif err != ErrCancelled {\n\t\tt.Errorf(\"was expecting cancel error, but got: %v\", err)\n\t}\n\n\t_, err = db.QueryContext(ctx, \"SELECT id, title FROM articles WHERE id = ?\", 5)\n\tif err != context.Canceled {\n\t\tt.Error(\"error was expected since context was already done, but there was none\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestPreparedStatementContextQueryCancel(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\trs := NewRows([]string{\"id\", \"title\"}).AddRow(5, \"hello world\")\n\n\tmock.ExpectPrepare(\"SELECT (.+) FROM articles WHERE id = ?\").\n\t\tExpectQuery().\n\t\tWithArgs(5).\n\t\tWillDelayFor(time.Second).\n\t\tWillReturnRows(rs)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 10)\n\t\tcancel()\n\t}()\n\n\tstmt, err := db.Prepare(\"SELECT id, title FROM articles WHERE id = ?\")\n\tif err != nil {\n\t\tt.Errorf(\"error was not expected, but got: %v\", err)\n\t}\n\n\t_, err = stmt.QueryContext(ctx, 5)\n\tif err == nil {\n\t\tt.Error(\"error was expected, but there was none\")\n\t}\n\n\tif err != ErrCancelled {\n\t\tt.Errorf(\"was expecting cancel error, but got: %v\", err)\n\t}\n\n\t_, err = stmt.QueryContext(ctx, 5)\n\tif err != context.Canceled {\n\t\tt.Error(\"error was expected since context was already done, but there was none\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestContextQuery(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\trs := NewRows([]string{\"id\", \"title\"}).AddRow(5, \"hello world\")\n\n\tmock.ExpectQuery(\"SELECT (.+) FROM articles WHERE id =\").\n\t\tWithArgs(sql.Named(\"id\", 5)).\n\t\tWillDelayFor(time.Millisecond * 3).\n\t\tWillReturnRows(rs)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 10)\n\t\tcancel()\n\t}()\n\n\trows, err := db.QueryContext(ctx, \"SELECT id, title FROM articles WHERE id = :id\", sql.Named(\"id\", 5))\n\tif err != nil {\n\t\tt.Errorf(\"error was not expected, but got: %v\", err)\n\t}\n\n\tif !rows.Next() {\n\t\tt.Error(\"expected one row, but there was none\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestContextBeginCancel(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectBegin().WillDelayFor(time.Second)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 10)\n\t\tcancel()\n\t}()\n\n\t_, err = db.BeginTx(ctx, nil)\n\tif err == nil {\n\t\tt.Error(\"error was expected, but there was none\")\n\t}\n\n\tif err != ErrCancelled {\n\t\tt.Errorf(\"was expecting cancel error, but got: %v\", err)\n\t}\n\n\t_, err = db.BeginTx(ctx, nil)\n\tif err != context.Canceled {\n\t\tt.Error(\"error was expected since context was already done, but there was none\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestContextBegin(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectBegin().WillDelayFor(time.Millisecond * 3)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 10)\n\t\tcancel()\n\t}()\n\n\ttx, err := db.BeginTx(ctx, nil)\n\tif err != nil {\n\t\tt.Errorf(\"error was not expected, but got: %v\", err)\n\t}\n\n\tif tx == nil {\n\t\tt.Error(\"expected tx, but there was nil\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestContextBeginWithTxOptions(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectBegin().WithTxOptions(sql.TxOptions{\n\t\tIsolation: sql.LevelReadCommitted,\n\t\tReadOnly:  true,\n\t})\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 10)\n\t\tcancel()\n\t}()\n\n\t_, err = db.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelReadCommitted, ReadOnly: false})\n\tif err != nil {\n\t\tt.Errorf(\"error was not expected, but got: %v\", err)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestContextBeginWithTxOptionsMismatch(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectBegin().WithTxOptions(sql.TxOptions{\n\t\tIsolation: sql.LevelReadCommitted,\n\t\tReadOnly:  true,\n\t})\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 10)\n\t\tcancel()\n\t}()\n\n\t_, err = db.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelDefault, ReadOnly: false})\n\tif err == nil {\n\t\tt.Error(\"error was expected, but there was none\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err == nil {\n\t\tt.Errorf(\"was expecting an error, as the tx options did not match, but there wasn't one\")\n\t}\n}\n\nfunc TestContextPrepareCancel(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectPrepare(\"SELECT\").WillDelayFor(time.Second)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 10)\n\t\tcancel()\n\t}()\n\n\t_, err = db.PrepareContext(ctx, \"SELECT\")\n\tif err == nil {\n\t\tt.Error(\"error was expected, but there was none\")\n\t}\n\n\tif err != ErrCancelled {\n\t\tt.Errorf(\"was expecting cancel error, but got: %v\", err)\n\t}\n\n\t_, err = db.PrepareContext(ctx, \"SELECT\")\n\tif err != context.Canceled {\n\t\tt.Error(\"error was expected since context was already done, but there was none\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestContextPrepare(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectPrepare(\"SELECT\").WillDelayFor(time.Millisecond * 3)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 10)\n\t\tcancel()\n\t}()\n\n\tstmt, err := db.PrepareContext(ctx, \"SELECT\")\n\tif err != nil {\n\t\tt.Errorf(\"error was not expected, but got: %v\", err)\n\t}\n\n\tif stmt == nil {\n\t\tt.Error(\"expected stmt, but there was nil\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestContextExecErrorDelay(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\t// test that return of error is delayed\n\tvar delay time.Duration = 100 * time.Millisecond\n\tmock.ExpectExec(\"^INSERT INTO articles\").\n\t\tWillReturnError(errors.New(\"slow fail\")).\n\t\tWillDelayFor(delay)\n\n\tstart := time.Now()\n\tres, err := db.ExecContext(context.Background(), \"INSERT INTO articles (title) VALUES (?)\", \"hello\")\n\tstop := time.Now()\n\n\tif res != nil {\n\t\tt.Errorf(\"result was not expected, was expecting nil\")\n\t}\n\n\tif err == nil {\n\t\tt.Errorf(\"error was expected, was not expecting nil\")\n\t}\n\n\tif err.Error() != \"slow fail\" {\n\t\tt.Errorf(\"error '%s' was not expected, was expecting '%s'\", err.Error(), \"slow fail\")\n\t}\n\n\telapsed := stop.Sub(start)\n\tif elapsed < delay {\n\t\tt.Errorf(\"expecting a delay of %v before error, actual delay was %v\", delay, elapsed)\n\t}\n\n\t// also test that return of error is not delayed\n\tmock.ExpectExec(\"^INSERT INTO articles\").WillReturnError(errors.New(\"fast fail\"))\n\n\tstart = time.Now()\n\tdb.ExecContext(context.Background(), \"INSERT INTO articles (title) VALUES (?)\", \"hello\")\n\tstop = time.Now()\n\n\telapsed = stop.Sub(start)\n\tif elapsed > delay {\n\t\tt.Errorf(\"expecting a delay of less than %v before error, actual delay was %v\", delay, elapsed)\n\t}\n}\n\n// TestMonitorPingsDisabled verifies backwards-compatibility with behaviour of the library in which\n// calls to Ping are not mocked out. It verifies this persists when the user does not enable the new\n// behaviour.\nfunc TestMonitorPingsDisabled(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\t// When monitoring of pings is not enabled in the mock, calling Ping should have no effect.\n\terr = db.Ping()\n\tif err != nil {\n\t\tt.Errorf(\"monitoring of pings is not enabled so did not expect error from Ping, got '%s'\", err)\n\t}\n\n\t// Calling ExpectPing should also not register any expectations in the mock. The return from\n\t// ExpectPing should be nil.\n\texpectation := mock.ExpectPing()\n\tif expectation != nil {\n\t\tt.Errorf(\"expected ExpectPing to return a nil pointer when monitoring of pings is not enabled\")\n\t}\n\n\terr = mock.ExpectationsWereMet()\n\tif err != nil {\n\t\tt.Errorf(\"monitoring of pings is not enabled so ExpectPing should not register an expectation, got '%s'\", err)\n\t}\n}\n\nfunc TestPingExpectations(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New(MonitorPingsOption(true))\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectPing()\n\tif err := db.Ping(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestPingExpectationsErrorDelay(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New(MonitorPingsOption(true))\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tvar delay time.Duration\n\tdelay = 100 * time.Millisecond\n\tmock.ExpectPing().\n\t\tWillReturnError(errors.New(\"slow fail\")).\n\t\tWillDelayFor(delay)\n\n\tstart := time.Now()\n\terr = db.Ping()\n\tstop := time.Now()\n\n\tif err == nil {\n\t\tt.Errorf(\"result was not expected, was not expecting nil error\")\n\t}\n\n\tif err.Error() != \"slow fail\" {\n\t\tt.Errorf(\"error '%s' was not expected, was expecting '%s'\", err.Error(), \"slow fail\")\n\t}\n\n\telapsed := stop.Sub(start)\n\tif elapsed < delay {\n\t\tt.Errorf(\"expecting a delay of %v before error, actual delay was %v\", delay, elapsed)\n\t}\n\n\tmock.ExpectPing().WillReturnError(errors.New(\"fast fail\"))\n\n\tstart = time.Now()\n\tdb.Ping()\n\tstop = time.Now()\n\n\telapsed = stop.Sub(start)\n\tif elapsed > delay {\n\t\tt.Errorf(\"expecting a delay of less than %v before error, actual delay was %v\", delay, elapsed)\n\t}\n}\n\nfunc TestPingExpectationsMissingPing(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New(MonitorPingsOption(true))\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectPing()\n\n\tif err = mock.ExpectationsWereMet(); err == nil {\n\t\tt.Fatalf(\"was expecting an error, but there wasn't one\")\n\t}\n}\n\nfunc TestPingExpectationsUnexpectedPing(t *testing.T) {\n\tt.Parallel()\n\tdb, _, err := New(MonitorPingsOption(true))\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tif err = db.Ping(); err == nil {\n\t\tt.Fatalf(\"was expecting an error, but there wasn't any\")\n\t}\n}\n\nfunc TestPingOrderedWrongOrder(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New(MonitorPingsOption(true))\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectBegin()\n\tmock.ExpectPing()\n\tmock.MatchExpectationsInOrder(true)\n\n\tif err = db.Ping(); err == nil {\n\t\tt.Fatalf(\"was expecting an error, but there wasn't any\")\n\t}\n}\n\nfunc TestPingExpectationsContextTimeout(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New(MonitorPingsOption(true))\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectPing().WillDelayFor(time.Hour)\n\n\tctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n\tdefer cancel()\n\n\tdoneCh := make(chan struct{})\n\tgo func() {\n\t\terr = db.PingContext(ctx)\n\t\tclose(doneCh)\n\t}()\n\n\tselect {\n\tcase <-doneCh:\n\t\tif err != ErrCancelled {\n\t\t\tt.Errorf(\"expected error '%s' to be returned from Ping, but got '%s'\", ErrCancelled, err)\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Errorf(\"expected Ping to return after context timeout, but it did not in a timely fashion\")\n\t}\n}\n"
        },
        {
          "name": "sqlmock_go19.go",
          "type": "blob",
          "size": 0.369140625,
          "content": "// +build go1.9\n\npackage sqlmock\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n)\n\n// CheckNamedValue meets https://golang.org/pkg/database/sql/driver/#NamedValueChecker\nfunc (c *sqlmock) CheckNamedValue(nv *driver.NamedValue) (err error) {\n\tswitch nv.Value.(type) {\n\tcase sql.Out:\n\t\treturn nil\n\tdefault:\n\t\tnv.Value, err = c.converter.ConvertValue(nv.Value)\n\t\treturn err\n\t}\n}\n"
        },
        {
          "name": "sqlmock_go19_test.go",
          "type": "blob",
          "size": 1.537109375,
          "content": "// +build go1.9\n\npackage sqlmock\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestStatementTX(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tprep := mock.ExpectPrepare(\"SELECT\")\n\tmock.ExpectBegin()\n\n\tprep.ExpectQuery().WithArgs(1).WillReturnError(errors.New(\"fast fail\"))\n\n\tstmt, err := db.Prepare(\"SELECT title, body FROM articles WHERE id = ?\")\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error on prepare: %v\", err)\n\t}\n\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error on begin: %v\", err)\n\t}\n\n\t// upgrade connection for statement\n\ttxStmt := tx.Stmt(stmt)\n\t_, err = txStmt.Query(1)\n\tif err == nil || err.Error() != \"fast fail\" {\n\t\tt.Fatalf(\"unexpected result: %v\", err)\n\t}\n}\n\nfunc Test_sqlmock_CheckNamedValue(t *testing.T) {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\ttests := []struct {\n\t\tname    string\n\t\targ     *driver.NamedValue\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\targ:     &driver.NamedValue{Name: \"test\", Value: \"test\"},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\targ:     &driver.NamedValue{Name: \"test\", Value: sql.Out{}},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif err := mock.(*sqlmock).CheckNamedValue(tt.arg); (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"CheckNamedValue() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "sqlmock_test.go",
          "type": "blob",
          "size": 35.455078125,
          "content": "package sqlmock\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc cancelOrder(db *sql.DB, orderID int) error {\n\ttx, _ := db.Begin()\n\t_, _ = tx.Query(\"SELECT * FROM orders {0} FOR UPDATE\", orderID)\n\terr := tx.Rollback()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc Example() {\n\t// Open new mock database\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"error creating mock database\")\n\t\treturn\n\t}\n\t// columns to be used for result\n\tcolumns := []string{\"id\", \"status\"}\n\t// expect transaction begin\n\tmock.ExpectBegin()\n\t// expect query to fetch order, match it with regexp\n\tmock.ExpectQuery(\"SELECT (.+) FROM orders (.+) FOR UPDATE\").\n\t\tWithArgs(1).\n\t\tWillReturnRows(NewRows(columns).AddRow(1, 1))\n\t// expect transaction rollback, since order status is \"cancelled\"\n\tmock.ExpectRollback()\n\n\t// run the cancel order function\n\tsomeOrderID := 1\n\t// call a function which executes expected database operations\n\terr = cancelOrder(db, someOrderID)\n\tif err != nil {\n\t\tfmt.Printf(\"unexpected error: %s\", err)\n\t\treturn\n\t}\n\n\t// ensure all expectations have been met\n\tif err = mock.ExpectationsWereMet(); err != nil {\n\t\tfmt.Printf(\"unmet expectation error: %s\", err)\n\t}\n\t// Output:\n}\n\nfunc TestIssue14EscapeSQL(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\tmock.ExpectExec(\"INSERT INTO mytable\\\\(a, b\\\\)\").\n\t\tWithArgs(\"A\", \"B\").\n\t\tWillReturnResult(NewResult(1, 1))\n\n\t_, err = db.Exec(\"INSERT INTO mytable(a, b) VALUES (?, ?)\", \"A\", \"B\")\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected, while inserting a row\", err)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\n// test the case when db is not triggered and expectations\n// are not asserted on close\nfunc TestIssue4(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectQuery(\"some sql query which will not be called\").\n\t\tWillReturnRows(NewRows([]string{\"id\"}))\n\n\tif err := mock.ExpectationsWereMet(); err == nil {\n\t\tt.Errorf(\"was expecting an error since query was not triggered\")\n\t}\n}\n\nfunc TestMockQuery(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\trs := NewRows([]string{\"id\", \"title\"}).FromCSVString(\"5,hello world\")\n\n\tmock.ExpectQuery(\"SELECT (.+) FROM articles WHERE id = ?\").\n\t\tWithArgs(5).\n\t\tWillReturnRows(rs)\n\n\trows, err := db.Query(\"SELECT (.+) FROM articles WHERE id = ?\", 5)\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected while retrieving mock rows\", err)\n\t}\n\n\tdefer func() {\n\t\tif er := rows.Close(); er != nil {\n\t\t\tt.Error(\"unexpected error while trying to close rows\")\n\t\t}\n\t}()\n\n\tif !rows.Next() {\n\t\tt.Error(\"it must have had one row as result, but got empty result set instead\")\n\t}\n\n\tvar id int\n\tvar title string\n\n\terr = rows.Scan(&id, &title)\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected while trying to scan row\", err)\n\t}\n\n\tif id != 5 {\n\t\tt.Errorf(\"expected mocked id to be 5, but got %d instead\", id)\n\t}\n\n\tif title != \"hello world\" {\n\t\tt.Errorf(\"expected mocked title to be 'hello world', but got '%s' instead\", title)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestMockQueryTypes(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tcolumns := []string{\"id\", \"timestamp\", \"sold\"}\n\n\ttimestamp := time.Now()\n\trs := NewRows(columns)\n\trs.AddRow(5, timestamp, true)\n\n\tmock.ExpectQuery(\"SELECT (.+) FROM sales WHERE id = ?\").\n\t\tWithArgs(5).\n\t\tWillReturnRows(rs)\n\n\trows, err := db.Query(\"SELECT (.+) FROM sales WHERE id = ?\", 5)\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected while retrieving mock rows\", err)\n\t}\n\tdefer func() {\n\t\tif er := rows.Close(); er != nil {\n\t\t\tt.Error(\"unexpected error while trying to close rows\")\n\t\t}\n\t}()\n\tif !rows.Next() {\n\t\tt.Error(\"it must have had one row as result, but got empty result set instead\")\n\t}\n\n\tvar id int\n\tvar time time.Time\n\tvar sold bool\n\n\terr = rows.Scan(&id, &time, &sold)\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected while trying to scan row\", err)\n\t}\n\n\tif id != 5 {\n\t\tt.Errorf(\"expected mocked id to be 5, but got %d instead\", id)\n\t}\n\n\tif time != timestamp {\n\t\tt.Errorf(\"expected mocked time to be %s, but got '%s' instead\", timestamp, time)\n\t}\n\n\tif sold != true {\n\t\tt.Errorf(\"expected mocked boolean to be true, but got %v instead\", sold)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestTransactionExpectations(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\t// begin and commit\n\tmock.ExpectBegin()\n\tmock.ExpectCommit()\n\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when beginning a transaction\", err)\n\t}\n\n\terr = tx.Commit()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when committing a transaction\", err)\n\t}\n\n\t// begin and rollback\n\tmock.ExpectBegin()\n\tmock.ExpectRollback()\n\n\ttx, err = db.Begin()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when beginning a transaction\", err)\n\t}\n\n\terr = tx.Rollback()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when rolling back a transaction\", err)\n\t}\n\n\t// begin with an error\n\tmock.ExpectBegin().WillReturnError(fmt.Errorf(\"some err\"))\n\n\ttx, err = db.Begin()\n\tif err == nil {\n\t\tt.Error(\"an error was expected when beginning a transaction, but got none\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestPrepareExpectations(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectPrepare(\"SELECT (.+) FROM articles WHERE id = ?\")\n\n\tstmt, err := db.Prepare(\"SELECT (.+) FROM articles WHERE id = ?\")\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected while creating a prepared statement\", err)\n\t}\n\tif stmt == nil {\n\t\tt.Errorf(\"stmt was expected while creating a prepared statement\")\n\t}\n\n\t// expect something else, w/o ExpectPrepare()\n\tvar id int\n\tvar title string\n\trs := NewRows([]string{\"id\", \"title\"}).FromCSVString(\"5,hello world\")\n\n\tmock.ExpectQuery(\"SELECT (.+) FROM articles WHERE id = ?\").\n\t\tWithArgs(5).\n\t\tWillReturnRows(rs)\n\n\terr = stmt.QueryRow(5).Scan(&id, &title)\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected while retrieving mock rows\", err)\n\t}\n\n\tmock.ExpectPrepare(\"SELECT (.+) FROM articles WHERE id = ?\").\n\t\tWillReturnError(fmt.Errorf(\"Some DB error occurred\"))\n\n\tstmt, err = db.Prepare(\"SELECT id FROM articles WHERE id = ?\")\n\tif err == nil {\n\t\tt.Error(\"error was expected while creating a prepared statement\")\n\t}\n\tif stmt != nil {\n\t\tt.Errorf(\"stmt was not expected while creating a prepared statement returning error\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestPreparedQueryExecutions(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectPrepare(\"SELECT (.+) FROM articles WHERE id = ?\")\n\n\trs1 := NewRows([]string{\"id\", \"title\"}).FromCSVString(\"5,hello world\")\n\tmock.ExpectQuery(\"SELECT (.+) FROM articles WHERE id = ?\").\n\t\tWithArgs(5).\n\t\tWillReturnRows(rs1)\n\n\trs2 := NewRows([]string{\"id\", \"title\"}).FromCSVString(\"2,whoop\")\n\tmock.ExpectQuery(\"SELECT (.+) FROM articles WHERE id = ?\").\n\t\tWithArgs(2).\n\t\tWillReturnRows(rs2)\n\n\tstmt, err := db.Prepare(\"SELECT id, title FROM articles WHERE id = ?\")\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected while creating a prepared statement\", err)\n\t}\n\n\tvar id int\n\tvar title string\n\terr = stmt.QueryRow(5).Scan(&id, &title)\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected querying row from statement and scanning\", err)\n\t}\n\n\tif id != 5 {\n\t\tt.Errorf(\"expected mocked id to be 5, but got %d instead\", id)\n\t}\n\n\tif title != \"hello world\" {\n\t\tt.Errorf(\"expected mocked title to be 'hello world', but got '%s' instead\", title)\n\t}\n\n\terr = stmt.QueryRow(2).Scan(&id, &title)\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected querying row from statement and scanning\", err)\n\t}\n\n\tif id != 2 {\n\t\tt.Errorf(\"expected mocked id to be 2, but got %d instead\", id)\n\t}\n\n\tif title != \"whoop\" {\n\t\tt.Errorf(\"expected mocked title to be 'whoop', but got '%s' instead\", title)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestUnorderedPreparedQueryExecutions(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.MatchExpectationsInOrder(false)\n\n\tmock.ExpectPrepare(\"SELECT (.+) FROM articles WHERE id = ?\").\n\t\tExpectQuery().\n\t\tWithArgs(5).\n\t\tWillReturnRows(NewRows([]string{\"id\", \"title\"}).FromCSVString(\"5,The quick brown fox\"))\n\tmock.ExpectPrepare(\"SELECT (.+) FROM authors WHERE id = ?\").\n\t\tExpectQuery().\n\t\tWithArgs(1).\n\t\tWillReturnRows(NewRows([]string{\"id\", \"title\"}).FromCSVString(\"1,Betty B.\"))\n\n\tvar id int\n\tvar name string\n\n\tstmt, err := db.Prepare(\"SELECT id, name FROM authors WHERE id = ?\")\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected while creating a prepared statement\", err)\n\t}\n\n\terr = stmt.QueryRow(1).Scan(&id, &name)\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected querying row from statement and scanning\", err)\n\t}\n\n\tif name != \"Betty B.\" {\n\t\tt.Errorf(\"expected mocked name to be 'Betty B.', but got '%s' instead\", name)\n\t}\n}\n\nfunc TestUnexpectedOperations(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectPrepare(\"SELECT (.+) FROM articles WHERE id = ?\")\n\tstmt, err := db.Prepare(\"SELECT id, title FROM articles WHERE id = ?\")\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected while creating a prepared statement\", err)\n\t}\n\n\tvar id int\n\tvar title string\n\n\terr = stmt.QueryRow(5).Scan(&id, &title)\n\tif err == nil {\n\t\tt.Error(\"error was expected querying row, since there was no such expectation\")\n\t}\n\n\tmock.ExpectRollback()\n\n\tif err := mock.ExpectationsWereMet(); err == nil {\n\t\tt.Errorf(\"was expecting an error since query was not triggered\")\n\t}\n}\n\nfunc TestWrongExpectations(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectBegin()\n\n\trs1 := NewRows([]string{\"id\", \"title\"}).FromCSVString(\"5,hello world\")\n\tmock.ExpectQuery(\"SELECT (.+) FROM articles WHERE id = ?\").\n\t\tWithArgs(5).\n\t\tWillReturnRows(rs1)\n\n\tmock.ExpectCommit().WillReturnError(fmt.Errorf(\"deadlock occurred\"))\n\tmock.ExpectRollback() // won't be triggered\n\n\tvar id int\n\tvar title string\n\n\terr = db.QueryRow(\"SELECT id, title FROM articles WHERE id = ? FOR UPDATE\", 5).Scan(&id, &title)\n\tif err == nil {\n\t\tt.Error(\"error was expected while querying row, since there begin transaction expectation is not fulfilled\")\n\t}\n\n\t// lets go around and start transaction\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when beginning a transaction\", err)\n\t}\n\n\terr = db.QueryRow(\"SELECT id, title FROM articles WHERE id = ? FOR UPDATE\", 5).Scan(&id, &title)\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected while querying row, since transaction was started\", err)\n\t}\n\n\terr = tx.Commit()\n\tif err == nil {\n\t\tt.Error(\"a deadlock error was expected when committing a transaction\", err)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err == nil {\n\t\tt.Errorf(\"was expecting an error since query was not triggered\")\n\t}\n}\n\nfunc TestExecExpectations(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tresult := NewResult(1, 1)\n\tmock.ExpectExec(\"^INSERT INTO articles\").\n\t\tWithArgs(\"hello\").\n\t\tWillReturnResult(result)\n\n\tres, err := db.Exec(\"INSERT INTO articles (title) VALUES (?)\", \"hello\")\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected, while inserting a row\", err)\n\t}\n\n\tid, err := res.LastInsertId()\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected, while getting a last insert id\", err)\n\t}\n\n\taffected, err := res.RowsAffected()\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected, while getting affected rows\", err)\n\t}\n\n\tif id != 1 {\n\t\tt.Errorf(\"expected last insert id to be 1, but got %d instead\", id)\n\t}\n\n\tif affected != 1 {\n\t\tt.Errorf(\"expected affected rows to be 1, but got %d instead\", affected)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestRowBuilderAndNilTypes(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\trs := NewRows([]string{\"id\", \"active\", \"created\", \"status\"}).\n\t\tAddRow(1, true, time.Now(), 5).\n\t\tAddRow(2, false, nil, nil)\n\n\tmock.ExpectQuery(\"SELECT (.+) FROM sales\").WillReturnRows(rs)\n\n\trows, err := db.Query(\"SELECT * FROM sales\")\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected while retrieving mock rows\", err)\n\t}\n\tdefer func() {\n\t\tif er := rows.Close(); er != nil {\n\t\t\tt.Error(\"Unexpected error while trying to close rows\")\n\t\t}\n\t}()\n\n\t// NullTime and NullInt are used from stubs_test.go\n\tvar (\n\t\tid      int\n\t\tactive  bool\n\t\tcreated NullTime\n\t\tstatus  NullInt\n\t)\n\n\tif !rows.Next() {\n\t\tt.Error(\"it must have had row in rows, but got empty result set instead\")\n\t}\n\n\terr = rows.Scan(&id, &active, &created, &status)\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected while trying to scan row\", err)\n\t}\n\n\tif id != 1 {\n\t\tt.Errorf(\"expected mocked id to be 1, but got %d instead\", id)\n\t}\n\n\tif !active {\n\t\tt.Errorf(\"expected 'active' to be 'true', but got '%v' instead\", active)\n\t}\n\n\tif !created.Valid {\n\t\tt.Errorf(\"expected 'created' to be valid, but it %+v is not\", created)\n\t}\n\n\tif !status.Valid {\n\t\tt.Errorf(\"expected 'status' to be valid, but it %+v is not\", status)\n\t}\n\n\tif status.Integer != 5 {\n\t\tt.Errorf(\"expected 'status' to be '5', but got '%d'\", status.Integer)\n\t}\n\n\t// test second row\n\tif !rows.Next() {\n\t\tt.Error(\"it must have had row in rows, but got empty result set instead\")\n\t}\n\n\terr = rows.Scan(&id, &active, &created, &status)\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected while trying to scan row\", err)\n\t}\n\n\tif id != 2 {\n\t\tt.Errorf(\"expected mocked id to be 2, but got %d instead\", id)\n\t}\n\n\tif active {\n\t\tt.Errorf(\"expected 'active' to be 'false', but got '%v' instead\", active)\n\t}\n\n\tif created.Valid {\n\t\tt.Errorf(\"expected 'created' to be invalid, but it %+v is not\", created)\n\t}\n\n\tif status.Valid {\n\t\tt.Errorf(\"expected 'status' to be invalid, but it %+v is not\", status)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestArgumentReflectValueTypeError(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\trs := NewRows([]string{\"id\"}).AddRow(1)\n\n\tmock.ExpectQuery(\"SELECT (.+) FROM sales\").WithArgs(5.5).WillReturnRows(rs)\n\n\t_, err = db.Query(\"SELECT * FROM sales WHERE x = ?\", 5)\n\tif err == nil {\n\t\tt.Error(\"expected error, but got none\")\n\t}\n}\n\nfunc TestGoroutineExecutionWithUnorderedExpectationMatching(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\t// note this line is important for unordered expectation matching\n\tmock.MatchExpectationsInOrder(false)\n\n\tresult := NewResult(1, 1)\n\n\tmock.ExpectExec(\"^UPDATE one\").WithArgs(\"one\").WillReturnResult(result)\n\tmock.ExpectExec(\"^UPDATE two\").WithArgs(\"one\", \"two\").WillReturnResult(result)\n\tmock.ExpectExec(\"^UPDATE three\").WithArgs(\"one\", \"two\", \"three\").WillReturnResult(result)\n\n\tvar wg sync.WaitGroup\n\tqueries := map[string][]interface{}{\n\t\t\"one\":   {\"one\"},\n\t\t\"two\":   {\"one\", \"two\"},\n\t\t\"three\": {\"one\", \"two\", \"three\"},\n\t}\n\n\twg.Add(len(queries))\n\tfor table, args := range queries {\n\t\tgo func(tbl string, a []interface{}) {\n\t\t\tif _, err := db.Exec(\"UPDATE \"+tbl, a...); err != nil {\n\t\t\t\tt.Errorf(\"error was not expected: %s\", err)\n\t\t\t}\n\t\t\twg.Done()\n\t\t}(table, args)\n\t}\n\n\twg.Wait()\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc ExampleSqlmock_goroutines() {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"failed to open sqlmock database:\", err)\n\t}\n\tdefer db.Close()\n\n\t// note this line is important for unordered expectation matching\n\tmock.MatchExpectationsInOrder(false)\n\n\tresult := NewResult(1, 1)\n\n\tmock.ExpectExec(\"^UPDATE one\").WithArgs(\"one\").WillReturnResult(result)\n\tmock.ExpectExec(\"^UPDATE two\").WithArgs(\"one\", \"two\").WillReturnResult(result)\n\tmock.ExpectExec(\"^UPDATE three\").WithArgs(\"one\", \"two\", \"three\").WillReturnResult(result)\n\n\tvar wg sync.WaitGroup\n\tqueries := map[string][]interface{}{\n\t\t\"one\":   {\"one\"},\n\t\t\"two\":   {\"one\", \"two\"},\n\t\t\"three\": {\"one\", \"two\", \"three\"},\n\t}\n\n\twg.Add(len(queries))\n\tfor table, args := range queries {\n\t\tgo func(tbl string, a []interface{}) {\n\t\t\tif _, err := db.Exec(\"UPDATE \"+tbl, a...); err != nil {\n\t\t\t\tfmt.Println(\"error was not expected:\", err)\n\t\t\t}\n\t\t\twg.Done()\n\t\t}(table, args)\n\t}\n\n\twg.Wait()\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tfmt.Println(\"there were unfulfilled expectations:\", err)\n\t}\n\t// Output:\n}\n\n// False Positive - passes despite mismatched Exec\n// see #37 issue\nfunc TestRunExecsWithOrderedShouldNotMeetAllExpectations(t *testing.T) {\n\tdb, dbmock, _ := New()\n\tdbmock.ExpectExec(\"THE FIRST EXEC\")\n\tdbmock.ExpectExec(\"THE SECOND EXEC\")\n\n\t_, _ = db.Exec(\"THE FIRST EXEC\")\n\t_, _ = db.Exec(\"THE WRONG EXEC\")\n\n\terr := dbmock.ExpectationsWereMet()\n\tif err == nil {\n\t\tt.Fatal(\"was expecting an error, but there wasn't any\")\n\t}\n}\n\n// False Positive - passes despite mismatched Exec\n// see #37 issue\nfunc TestRunQueriesWithOrderedShouldNotMeetAllExpectations(t *testing.T) {\n\tdb, dbmock, _ := New()\n\tdbmock.ExpectQuery(\"THE FIRST QUERY\")\n\tdbmock.ExpectQuery(\"THE SECOND QUERY\")\n\n\t_, _ = db.Query(\"THE FIRST QUERY\")\n\t_, _ = db.Query(\"THE WRONG QUERY\")\n\n\terr := dbmock.ExpectationsWereMet()\n\tif err == nil {\n\t\tt.Fatal(\"was expecting an error, but there wasn't any\")\n\t}\n}\n\nfunc TestRunExecsWithExpectedErrorMeetsExpectations(t *testing.T) {\n\tdb, dbmock, _ := New()\n\tdbmock.ExpectExec(\"THE FIRST EXEC\").WillReturnError(fmt.Errorf(\"big bad bug\"))\n\tdbmock.ExpectExec(\"THE SECOND EXEC\").WillReturnResult(NewResult(0, 0))\n\n\t_, _ = db.Exec(\"THE FIRST EXEC\")\n\t_, _ = db.Exec(\"THE SECOND EXEC\")\n\n\terr := dbmock.ExpectationsWereMet()\n\tif err != nil {\n\t\tt.Fatalf(\"all expectations should be met: %s\", err)\n\t}\n}\n\nfunc TestRunExecsWithNoArgsExpectedMeetsExpectations(t *testing.T) {\n\tdb, dbmock, _ := New()\n\tdbmock.ExpectExec(\"THE FIRST EXEC\").WithoutArgs().WillReturnResult(NewResult(0, 0))\n\n\t_, err := db.Exec(\"THE FIRST EXEC\", \"foobar\")\n\tif err == nil {\n\t\tt.Fatalf(\"expected error, but there wasn't any\")\n\t}\n}\n\nfunc TestRunQueryWithExpectedErrorMeetsExpectations(t *testing.T) {\n\tdb, dbmock, _ := New()\n\tdbmock.ExpectQuery(\"THE FIRST QUERY\").WillReturnError(fmt.Errorf(\"big bad bug\"))\n\tdbmock.ExpectQuery(\"THE SECOND QUERY\").WillReturnRows(NewRows([]string{\"col\"}).AddRow(1))\n\n\t_, _ = db.Query(\"THE FIRST QUERY\")\n\t_, _ = db.Query(\"THE SECOND QUERY\")\n\n\terr := dbmock.ExpectationsWereMet()\n\tif err != nil {\n\t\tt.Fatalf(\"all expectations should be met: %s\", err)\n\t}\n}\n\nfunc TestEmptyRowSet(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\trs := NewRows([]string{\"id\", \"title\"})\n\n\tmock.ExpectQuery(\"SELECT (.+) FROM articles WHERE id = ?\").\n\t\tWithArgs(5).\n\t\tWillReturnRows(rs)\n\n\trows, err := db.Query(\"SELECT (.+) FROM articles WHERE id = ?\", 5)\n\tif err != nil {\n\t\tt.Errorf(\"error '%s' was not expected while retrieving mock rows\", err)\n\t}\n\n\tdefer func() {\n\t\tif er := rows.Close(); er != nil {\n\t\t\tt.Error(\"unexpected error while trying to close rows\")\n\t\t}\n\t}()\n\n\tif rows.Next() {\n\t\tt.Error(\"expected no rows but got one\")\n\t}\n\n\terr = mock.ExpectationsWereMet()\n\tif err != nil {\n\t\tt.Fatalf(\"all expectations should be met: %s\", err)\n\t}\n}\n\n// Based on issue #50\nfunc TestPrepareExpectationNotFulfilled(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectPrepare(\"^BADSELECT$\")\n\n\tif _, err := db.Prepare(\"SELECT\"); err == nil {\n\t\tt.Fatal(\"prepare should not match expected query string\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err == nil {\n\t\tt.Errorf(\"was expecting an error, since prepared statement query does not match, but there was none\")\n\t}\n}\n\nfunc TestRollbackThrow(t *testing.T) {\n\t// Open new mock database\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"error creating mock database\")\n\t\treturn\n\t}\n\t// columns to be used for result\n\tcolumns := []string{\"id\", \"status\"}\n\t// expect transaction begin\n\tmock.ExpectBegin()\n\t// expect query to fetch order, match it with regexp\n\tmock.ExpectQuery(\"SELECT (.+) FROM orders (.+) FOR UPDATE\").\n\t\tWithArgs(1).\n\t\tWillReturnRows(NewRows(columns).AddRow(1, 1))\n\t// expect transaction rollback, since order status is \"cancelled\"\n\tmock.ExpectRollback().WillReturnError(fmt.Errorf(\"rollback failed\"))\n\n\t// run the cancel order function\n\tsomeOrderID := 1\n\t// call a function which executes expected database operations\n\terr = cancelOrder(db, someOrderID)\n\tif err == nil {\n\t\tt.Error(\"an error was expected when rolling back transaction, but got none\")\n\t}\n\n\t// ensure all expectations have been met\n\tif err = mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"unmet expectation error: %s\", err)\n\t}\n\t// Output:\n}\n\nfunc TestUnexpectedBegin(t *testing.T) {\n\t// Open new mock database\n\tdb, _, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"error creating mock database\")\n\t\treturn\n\t}\n\tif _, err := db.Begin(); err == nil {\n\t\tt.Error(\"an error was expected when calling begin, but got none\")\n\t}\n}\n\nfunc TestUnexpectedExec(t *testing.T) {\n\t// Open new mock database\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"error creating mock database\")\n\t\treturn\n\t}\n\tmock.ExpectBegin()\n\tdb.Begin()\n\tif _, err := db.Exec(\"SELECT 1\"); err == nil {\n\t\tt.Error(\"an error was expected when calling exec, but got none\")\n\t}\n}\n\nfunc TestUnexpectedCommit(t *testing.T) {\n\t// Open new mock database\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"error creating mock database\")\n\t\treturn\n\t}\n\tmock.ExpectBegin()\n\ttx, _ := db.Begin()\n\tif err := tx.Commit(); err == nil {\n\t\tt.Error(\"an error was expected when calling commit, but got none\")\n\t}\n}\n\nfunc TestUnexpectedCommitOrder(t *testing.T) {\n\t// Open new mock database\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"error creating mock database\")\n\t\treturn\n\t}\n\tmock.ExpectBegin()\n\tmock.ExpectRollback().WillReturnError(fmt.Errorf(\"Rollback failed\"))\n\ttx, _ := db.Begin()\n\tif err := tx.Commit(); err == nil {\n\t\tt.Error(\"an error was expected when calling commit, but got none\")\n\t}\n}\n\nfunc TestExpectedCommitOrder(t *testing.T) {\n\t// Open new mock database\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"error creating mock database\")\n\t\treturn\n\t}\n\tmock.ExpectCommit().WillReturnError(fmt.Errorf(\"Commit failed\"))\n\tif _, err := db.Begin(); err == nil {\n\t\tt.Error(\"an error was expected when calling begin, but got none\")\n\t}\n}\n\nfunc TestUnexpectedRollback(t *testing.T) {\n\t// Open new mock database\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"error creating mock database\")\n\t\treturn\n\t}\n\tmock.ExpectBegin()\n\ttx, _ := db.Begin()\n\tif err := tx.Rollback(); err == nil {\n\t\tt.Error(\"an error was expected when calling rollback, but got none\")\n\t}\n}\n\nfunc TestUnexpectedRollbackOrder(t *testing.T) {\n\t// Open new mock database\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"error creating mock database\")\n\t\treturn\n\t}\n\tmock.ExpectBegin()\n\n\ttx, _ := db.Begin()\n\tif err := tx.Rollback(); err == nil {\n\t\tt.Error(\"an error was expected when calling rollback, but got none\")\n\t}\n}\n\nfunc TestPrepareExec(t *testing.T) {\n\t// Open new mock database\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"error creating mock database\")\n\t\treturn\n\t}\n\tdefer db.Close()\n\tmock.ExpectBegin()\n\tep := mock.ExpectPrepare(\"INSERT INTO ORDERS\\\\(ID, STATUS\\\\) VALUES \\\\(\\\\?, \\\\?\\\\)\")\n\tfor i := 0; i < 3; i++ {\n\t\tep.ExpectExec().WillReturnResult(NewResult(1, 1))\n\t}\n\tmock.ExpectCommit()\n\ttx, _ := db.Begin()\n\tstmt, err := tx.Prepare(\"INSERT INTO ORDERS(ID, STATUS) VALUES (?, ?)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer stmt.Close()\n\tfor i := 0; i < 3; i++ {\n\t\t_, err := stmt.Exec(i, \"Hello\"+strconv.Itoa(i))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\ttx.Commit()\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestPrepareQuery(t *testing.T) {\n\t// Open new mock database\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"error creating mock database\")\n\t\treturn\n\t}\n\tdefer db.Close()\n\tmock.ExpectBegin()\n\tep := mock.ExpectPrepare(\"SELECT ID, STATUS FROM ORDERS WHERE ID = \\\\?\")\n\tep.ExpectQuery().WithArgs(101).WillReturnRows(NewRows([]string{\"ID\", \"STATUS\"}).AddRow(101, \"Hello\"))\n\tmock.ExpectCommit()\n\ttx, _ := db.Begin()\n\tstmt, err := tx.Prepare(\"SELECT ID, STATUS FROM ORDERS WHERE ID = ?\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer stmt.Close()\n\trows, err := stmt.Query(101)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer rows.Close()\n\tfor rows.Next() {\n\t\tvar (\n\t\t\tid     int\n\t\t\tstatus string\n\t\t)\n\t\tif rows.Scan(&id, &status); id != 101 || status != \"Hello\" {\n\t\t\tt.Fatal(\"wrong query results\")\n\t\t}\n\n\t}\n\ttx.Commit()\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestExpectedCloseError(t *testing.T) {\n\t// Open new mock database\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"error creating mock database\")\n\t\treturn\n\t}\n\tmock.ExpectClose().WillReturnError(fmt.Errorf(\"Close failed\"))\n\tif err := db.Close(); err == nil {\n\t\tt.Error(\"an error was expected when calling close, but got none\")\n\t}\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestExpectedCloseOrder(t *testing.T) {\n\t// Open new mock database\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"error creating mock database\")\n\t\treturn\n\t}\n\tdefer db.Close()\n\tmock.ExpectClose().WillReturnError(fmt.Errorf(\"Close failed\"))\n\tdb.Begin()\n\tif err := mock.ExpectationsWereMet(); err == nil {\n\t\tt.Error(\"expected error on ExpectationsWereMet\")\n\t}\n}\n\nfunc TestExpectedBeginOrder(t *testing.T) {\n\t// Open new mock database\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"error creating mock database\")\n\t\treturn\n\t}\n\tmock.ExpectBegin().WillReturnError(fmt.Errorf(\"Begin failed\"))\n\tif err := db.Close(); err == nil {\n\t\tt.Error(\"an error was expected when calling close, but got none\")\n\t}\n}\n\nfunc TestPreparedStatementCloseExpectation(t *testing.T) {\n\t// Open new mock database\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tfmt.Println(\"error creating mock database\")\n\t\treturn\n\t}\n\tdefer db.Close()\n\n\tep := mock.ExpectPrepare(\"INSERT INTO ORDERS\").WillBeClosed()\n\tep.ExpectExec().WillReturnResult(NewResult(1, 1))\n\n\tstmt, err := db.Prepare(\"INSERT INTO ORDERS(ID, STATUS) VALUES (?, ?)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif _, err := stmt.Exec(1, \"Hello\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := stmt.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc TestExecExpectationErrorDelay(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\t// test that return of error is delayed\n\tvar delay time.Duration = 100 * time.Millisecond\n\tmock.ExpectExec(\"^INSERT INTO articles\").\n\t\tWillReturnError(errors.New(\"slow fail\")).\n\t\tWillDelayFor(delay)\n\n\tstart := time.Now()\n\tres, err := db.Exec(\"INSERT INTO articles (title) VALUES (?)\", \"hello\")\n\tstop := time.Now()\n\n\tif res != nil {\n\t\tt.Errorf(\"result was not expected, was expecting nil\")\n\t}\n\n\tif err == nil {\n\t\tt.Errorf(\"error was expected, was not expecting nil\")\n\t}\n\n\tif err.Error() != \"slow fail\" {\n\t\tt.Errorf(\"error '%s' was not expected, was expecting '%s'\", err.Error(), \"slow fail\")\n\t}\n\n\telapsed := stop.Sub(start)\n\tif elapsed < delay {\n\t\tt.Errorf(\"expecting a delay of %v before error, actual delay was %v\", delay, elapsed)\n\t}\n\n\t// also test that return of error is not delayed\n\tmock.ExpectExec(\"^INSERT INTO articles\").WillReturnError(errors.New(\"fast fail\"))\n\n\tstart = time.Now()\n\tdb.Exec(\"INSERT INTO articles (title) VALUES (?)\", \"hello\")\n\tstop = time.Now()\n\n\telapsed = stop.Sub(start)\n\tif elapsed > delay {\n\t\tt.Errorf(\"expecting a delay of less than %v before error, actual delay was %v\", delay, elapsed)\n\t}\n}\n\nfunc TestOptionsFail(t *testing.T) {\n\tt.Parallel()\n\texpected := errors.New(\"failing option\")\n\toption := func(*sqlmock) error {\n\t\treturn expected\n\t}\n\tdb, _, err := New(option)\n\tdefer db.Close()\n\tif err == nil {\n\t\tt.Errorf(\"missing expecting error '%s' when opening a stub database connection\", expected)\n\t}\n}\n\nfunc TestNewRows(t *testing.T) {\n\tt.Parallel()\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\tcolumns := []string{\"col1\", \"col2\"}\n\n\tr := mock.NewRows(columns)\n\tif len(r.cols) != len(columns) || r.cols[0] != columns[0] || r.cols[1] != columns[1] {\n\t\tt.Errorf(\"expecting to create a row with columns %v, actual colmns are %v\", r.cols, columns)\n\t}\n}\n\n// This is actually a test of ExpectationsWereMet. Without a lock around e.fulfilled() inside\n// ExpectationWereMet, the race detector complains if e.triggered is being read while it is also\n// being written by the query running in another goroutine.\nfunc TestQueryWithTimeout(t *testing.T) {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\trs := NewRows([]string{\"id\", \"title\"}).FromCSVString(\"5,hello world\")\n\n\tmock.ExpectQuery(\"SELECT (.+) FROM articles WHERE id = ?\").\n\t\tWillDelayFor(15 * time.Millisecond). // Query will take longer than timeout\n\t\tWithArgs(5).\n\t\tWillReturnRows(rs)\n\n\t_, err = queryWithTimeout(10*time.Millisecond, db, \"SELECT (.+) FROM articles WHERE id = ?\", 5)\n\tif err == nil {\n\t\tt.Errorf(\"expecting query to time out\")\n\t}\n\n\tif err := mock.ExpectationsWereMet(); err != nil {\n\t\tt.Errorf(\"there were unfulfilled expectations: %s\", err)\n\t}\n}\n\nfunc queryWithTimeout(t time.Duration, db *sql.DB, query string, args ...interface{}) (*sql.Rows, error) {\n\trowsChan := make(chan *sql.Rows, 1)\n\terrChan := make(chan error, 1)\n\n\tgo func() {\n\t\trows, err := db.Query(query, args...)\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t\treturn\n\t\t}\n\t\trowsChan <- rows\n\t}()\n\n\tselect {\n\tcase rows := <-rowsChan:\n\t\treturn rows, nil\n\tcase err := <-errChan:\n\t\treturn nil, err\n\tcase <-time.After(t):\n\t\treturn nil, fmt.Errorf(\"query timed out after %v\", t)\n\t}\n}\n\nfunc Test_sqlmock_Prepare_and_Exec(t *testing.T) {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\tquery := \"SELECT name, email FROM users WHERE name = ?\"\n\n\tmock.ExpectPrepare(\"SELECT (.+) FROM users WHERE (.+)\")\n\texpected := NewResult(1, 1)\n\tmock.ExpectExec(\"SELECT (.+) FROM users WHERE (.+)\").\n\t\tWillReturnResult(expected)\n\texpectedRows := mock.NewRows([]string{\"id\", \"name\", \"email\"}).AddRow(1, \"test\", \"test@example.com\")\n\tmock.ExpectQuery(\"SELECT (.+) FROM users WHERE (.+)\").WillReturnRows(expectedRows)\n\n\tgot, err := mock.(*sqlmock).Prepare(query)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tif got == nil {\n\t\tt.Error(\"Prepare () stmt must not be nil\")\n\t\treturn\n\t}\n\tresult, err := got.Exec([]driver.Value{\"test\"})\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Results are not equal. Expected: %v, Actual: %v\", expected, result)\n\t\treturn\n\t}\n\trows, err := got.Query([]driver.Value{\"test\"})\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tdefer rows.Close()\n}\n\ntype failArgument struct{}\n\nfunc (f failArgument) Match(_ driver.Value) bool {\n\treturn false\n}\n\nfunc Test_sqlmock_Exec(t *testing.T) {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\n\tmock.ExpectBegin()\n\t_, err = mock.(*sqlmock).Exec(\"\", []driver.Value{})\n\tif err == nil {\n\t\tt.Errorf(\"error expected\")\n\t\treturn\n\t}\n\n\texpected := NewResult(1, 1)\n\tmock.ExpectExec(\"SELECT (.+) FROM users WHERE (.+)\").\n\t\tWillReturnResult(expected).\n\t\tWithArgs(\"test\")\n\n\tmatchErr := errors.New(\"matcher sqlmock.failArgument could not match 0 argument driver.NamedValue - {Name: Ordinal:1 Value:{}}\")\n\tmock.ExpectExec(\"SELECT (.+) FROM animals WHERE (.+)\").\n\t\tWillReturnError(matchErr).\n\t\tWithArgs(failArgument{})\n\n\tmock.ExpectExec(\"\").WithArgs(failArgument{})\n\n\tmock.(*sqlmock).expected = mock.(*sqlmock).expected[1:]\n\tquery := \"SELECT name, email FROM users WHERE name = ?\"\n\tresult, err := mock.(*sqlmock).Exec(query, []driver.Value{\"test\"})\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tif !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Results are not equal. Expected: %v, Actual: %v\", expected, result)\n\t\treturn\n\t}\n\n\tfailQuery := \"SELECT name, sex FROM animals WHERE sex = ?\"\n\t_, err = mock.(*sqlmock).Exec(failQuery, []driver.Value{failArgument{}})\n\tif err == nil {\n\t\tt.Errorf(\"error expected\")\n\t\treturn\n\t}\n\tmock.(*sqlmock).ordered = false\n\t_, err = mock.(*sqlmock).Exec(\"\", []driver.Value{failArgument{}})\n\tif err == nil {\n\t\tt.Errorf(\"error expected\")\n\t\treturn\n\t}\n}\n\nfunc Test_sqlmock_Query(t *testing.T) {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\texpectedRows := mock.NewRows([]string{\"id\", \"name\", \"email\"}).AddRow(1, \"test\", \"test@example.com\")\n\tmock.ExpectQuery(\"SELECT (.+) FROM users WHERE (.+)\").WillReturnRows(expectedRows)\n\tquery := \"SELECT name, email FROM users WHERE name = ?\"\n\trows, err := mock.(*sqlmock).Query(query, []driver.Value{\"test\"})\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tdefer rows.Close()\n\t_, err = mock.(*sqlmock).Query(query, []driver.Value{failArgument{}})\n\tif err == nil {\n\t\tt.Errorf(\"error expected\")\n\t\treturn\n\t}\n}\n\nfunc Test_sqlmock_QueryExpectWithoutArgs(t *testing.T) {\n\tdb, mock, err := New()\n\tif err != nil {\n\t\tt.Errorf(\"an error '%s' was not expected when opening a stub database connection\", err)\n\t}\n\tdefer db.Close()\n\texpectedRows := mock.NewRows([]string{\"id\", \"name\", \"email\"}).AddRow(1, \"test\", \"test@example.com\")\n\tmock.ExpectQuery(\"SELECT (.+) FROM users WHERE (.+)\").WillReturnRows(expectedRows).WithoutArgs()\n\tquery := \"SELECT name, email FROM users WHERE name = ?\"\n\t_, err = mock.(*sqlmock).Query(query, []driver.Value{\"test\"})\n\tif err == nil {\n\t\tt.Errorf(\"error expected\")\n\t\treturn\n\t}\n}\n"
        },
        {
          "name": "statement.go",
          "type": "blob",
          "size": 0.23828125,
          "content": "package sqlmock\n\ntype statement struct {\n\tconn  *sqlmock\n\tex    *ExpectedPrepare\n\tquery string\n}\n\nfunc (stmt *statement) Close() error {\n\tstmt.ex.wasClosed = true\n\treturn stmt.ex.closeErr\n}\n\nfunc (stmt *statement) NumInput() int {\n\treturn -1\n}\n"
        },
        {
          "name": "statement_before_go18.go",
          "type": "blob",
          "size": 0.44140625,
          "content": "// +build !go1.8\n\npackage sqlmock\n\nimport (\n\t\"database/sql/driver\"\n)\n\n// Deprecated: Drivers should implement ExecerContext instead.\nfunc (stmt *statement) Exec(args []driver.Value) (driver.Result, error) {\n\treturn stmt.conn.Exec(stmt.query, args)\n}\n\n// Deprecated: Drivers should implement StmtQueryContext instead (or additionally).\nfunc (stmt *statement) Query(args []driver.Value) (driver.Rows, error) {\n\treturn stmt.conn.Query(stmt.query, args)\n}\n"
        },
        {
          "name": "statement_go18.go",
          "type": "blob",
          "size": 0.7880859375,
          "content": "// +build go1.8\n\npackage sqlmock\n\nimport (\n\t\"context\"\n\t\"database/sql/driver\"\n)\n\n// Deprecated: Drivers should implement ExecerContext instead.\nfunc (stmt *statement) Exec(args []driver.Value) (driver.Result, error) {\n\treturn stmt.conn.ExecContext(context.Background(), stmt.query, convertValueToNamedValue(args))\n}\n\n// Deprecated: Drivers should implement StmtQueryContext instead (or additionally).\nfunc (stmt *statement) Query(args []driver.Value) (driver.Rows, error) {\n\treturn stmt.conn.QueryContext(context.Background(), stmt.query, convertValueToNamedValue(args))\n}\n\nfunc convertValueToNamedValue(args []driver.Value) []driver.NamedValue {\n\tnamedArgs := make([]driver.NamedValue, len(args))\n\tfor i, v := range args {\n\t\tnamedArgs[i] = driver.NamedValue{Ordinal: i + 1, Value: v}\n\t}\n\treturn namedArgs\n}\n"
        },
        {
          "name": "statement_test.go",
          "type": "blob",
          "size": 0.6416015625,
          "content": "// +build go1.6\n\npackage sqlmock\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestExpectedPreparedStatementCloseError(t *testing.T) {\n\tconn, mock, err := New()\n\tif err != nil {\n\t\tt.Fatal(\"failed to open sqlmock database:\", err)\n\t}\n\n\tmock.ExpectBegin()\n\twant := errors.New(\"STMT ERROR\")\n\tmock.ExpectPrepare(\"SELECT\").WillReturnCloseError(want)\n\n\ttxn, err := conn.Begin()\n\tif err != nil {\n\t\tt.Fatal(\"unexpected error while opening transaction:\", err)\n\t}\n\n\tstmt, err := txn.Prepare(\"SELECT\")\n\tif err != nil {\n\t\tt.Fatal(\"unexpected error while preparing a statement:\", err)\n\t}\n\n\tif err := stmt.Close(); err != want {\n\t\tt.Fatalf(\"got = %v, want = %v\", err, want)\n\t}\n}\n"
        },
        {
          "name": "stubs_test.go",
          "type": "blob",
          "size": 1.5068359375,
          "content": "package sqlmock\n\nimport (\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"time\"\n)\n\ntype NullTime struct {\n\tTime  time.Time\n\tValid bool // Valid is true if Time is not NULL\n}\n\ntype NullInt struct {\n\tInteger int\n\tValid   bool\n}\n\n// Satisfy sql.Scanner interface\nfunc (ni *NullInt) Scan(value interface{}) error {\n\tswitch v := value.(type) {\n\tcase nil:\n\t\tni.Integer, ni.Valid = 0, false\n\tcase int64:\n\t\tconst maxUint = ^uint(0)\n\t\tconst maxInt = int(maxUint >> 1)\n\t\tconst minInt = -maxInt - 1\n\n\t\tif v > int64(maxInt) || v < int64(minInt) {\n\t\t\treturn errors.New(\"value out of int range\")\n\t\t}\n\t\tni.Integer, ni.Valid = int(v), true\n\tcase []byte:\n\t\tn, err := strconv.Atoi(string(v))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tni.Integer, ni.Valid = n, true\n\tcase string:\n\t\tn, err := strconv.Atoi(v)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tni.Integer, ni.Valid = n, true\n\tdefault:\n\t\treturn fmt.Errorf(\"can't convert %T to integer\", value)\n\t}\n\treturn nil\n}\n\n// Satisfy sql.Valuer interface.\nfunc (ni NullInt) Value() (driver.Value, error) {\n\tif !ni.Valid {\n\t\treturn nil, nil\n\t}\n\treturn int64(ni.Integer), nil\n}\n\n// Satisfy sql.Scanner interface\nfunc (nt *NullTime) Scan(value interface{}) error {\n\tswitch v := value.(type) {\n\tcase nil:\n\t\tnt.Time, nt.Valid = time.Time{}, false\n\tcase time.Time:\n\t\tnt.Time, nt.Valid = v, true\n\tdefault:\n\t\treturn fmt.Errorf(\"can't convert %T to time.Time\", value)\n\t}\n\treturn nil\n}\n\n// Satisfy sql.Valuer interface.\nfunc (nt NullTime) Value() (driver.Value, error) {\n\tif !nt.Valid {\n\t\treturn nil, nil\n\t}\n\treturn nt.Time, nil\n}\n"
        }
      ]
    }
  ]
}