{
  "metadata": {
    "timestamp": 1736567819508,
    "page": 404,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "kelseyhightower/envconfig",
      "stars": 5108,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.1162109375,
          "content": "language: go\n\ngo:\n  - 1.4.x\n  - 1.5.x\n  - 1.6.x\n  - 1.7.x\n  - 1.8.x\n  - 1.9.x\n  - 1.10.x\n  - 1.11.x\n  - 1.12.x\n  - tip\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.03515625,
          "content": "Copyright (c) 2013 Kelsey Hightower\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "MAINTAINERS",
          "type": "blob",
          "size": 0.130859375,
          "content": "Kelsey Hightower kelsey.hightower@gmail.com github.com/kelseyhightower\nTravis Parker    travis.parker@gmail.com    github.com/teepark\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.791015625,
          "content": "# envconfig\n\n[![Build Status](https://travis-ci.org/kelseyhightower/envconfig.svg)](https://travis-ci.org/kelseyhightower/envconfig)\n\n```Go\nimport \"github.com/kelseyhightower/envconfig\"\n```\n\n## Documentation\n\nSee [godoc](http://godoc.org/github.com/kelseyhightower/envconfig)\n\n## Usage\n\nSet some environment variables:\n\n```Bash\nexport MYAPP_DEBUG=false\nexport MYAPP_PORT=8080\nexport MYAPP_USER=Kelsey\nexport MYAPP_RATE=\"0.5\"\nexport MYAPP_TIMEOUT=\"3m\"\nexport MYAPP_USERS=\"rob,ken,robert\"\nexport MYAPP_COLORCODES=\"red:1,green:2,blue:3\"\n```\n\nWrite some code:\n\n```Go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"time\"\n\n    \"github.com/kelseyhightower/envconfig\"\n)\n\ntype Specification struct {\n    Debug       bool\n    Port        int\n    User        string\n    Users       []string\n    Rate        float32\n    Timeout     time.Duration\n    ColorCodes  map[string]int\n}\n\nfunc main() {\n    var s Specification\n    err := envconfig.Process(\"myapp\", &s)\n    if err != nil {\n        log.Fatal(err.Error())\n    }\n    format := \"Debug: %v\\nPort: %d\\nUser: %s\\nRate: %f\\nTimeout: %s\\n\"\n    _, err = fmt.Printf(format, s.Debug, s.Port, s.User, s.Rate, s.Timeout)\n    if err != nil {\n        log.Fatal(err.Error())\n    }\n\n    fmt.Println(\"Users:\")\n    for _, u := range s.Users {\n        fmt.Printf(\"  %s\\n\", u)\n    }\n\n    fmt.Println(\"Color codes:\")\n    for k, v := range s.ColorCodes {\n        fmt.Printf(\"  %s: %d\\n\", k, v)\n    }\n}\n```\n\nResults:\n\n```Bash\nDebug: false\nPort: 8080\nUser: Kelsey\nRate: 0.500000\nTimeout: 3m0s\nUsers:\n  rob\n  ken\n  robert\nColor codes:\n  red: 1\n  green: 2\n  blue: 3\n```\n\n## Struct Tag Support\n\nEnvconfig supports the use of struct tags to specify alternate, default, and required\nenvironment variables.\n\nFor example, consider the following struct:\n\n```Go\ntype Specification struct {\n    ManualOverride1 string `envconfig:\"manual_override_1\"`\n    DefaultVar      string `default:\"foobar\"`\n    RequiredVar     string `required:\"true\"`\n    IgnoredVar      string `ignored:\"true\"`\n    AutoSplitVar    string `split_words:\"true\"`\n    RequiredAndAutoSplitVar    string `required:\"true\" split_words:\"true\"`\n}\n```\n\nEnvconfig has automatic support for CamelCased struct elements when the\n`split_words:\"true\"` tag is supplied. Without this tag, `AutoSplitVar` above\nwould look for an environment variable called `MYAPP_AUTOSPLITVAR`. With the\nsetting applied it will look for `MYAPP_AUTO_SPLIT_VAR`. Note that numbers\nwill get globbed into the previous word. If the setting does not do the\nright thing, you may use a manual override.\n\nEnvconfig will process value for `ManualOverride1` by populating it with the\nvalue for `MYAPP_MANUAL_OVERRIDE_1`. Without this struct tag, it would have\ninstead looked up `MYAPP_MANUALOVERRIDE1`. With the `split_words:\"true\"` tag\nit would have looked up `MYAPP_MANUAL_OVERRIDE1`.\n\n```Bash\nexport MYAPP_MANUAL_OVERRIDE_1=\"this will be the value\"\n\n# export MYAPP_MANUALOVERRIDE1=\"and this will not\"\n```\n\nIf envconfig can't find an environment variable value for `MYAPP_DEFAULTVAR`,\nit will populate it with \"foobar\" as a default value.\n\nIf envconfig can't find an environment variable value for `MYAPP_REQUIREDVAR`,\nit will return an error when asked to process the struct.  If\n`MYAPP_REQUIREDVAR` is present but empty, envconfig will not return an error.\n\nIf envconfig can't find an environment variable in the form `PREFIX_MYVAR`, and there\nis a struct tag defined, it will try to populate your variable with an environment\nvariable that directly matches the envconfig tag in your struct definition:\n\n```shell\nexport SERVICE_HOST=127.0.0.1\nexport MYAPP_DEBUG=true\n```\n```Go\ntype Specification struct {\n    ServiceHost string `envconfig:\"SERVICE_HOST\"`\n    Debug       bool\n}\n```\n\nEnvconfig won't process a field with the \"ignored\" tag set to \"true\", even if a corresponding\nenvironment variable is set.\n\n## Supported Struct Field Types\n\nenvconfig supports these struct field types:\n\n  * string\n  * int8, int16, int32, int64\n  * bool\n  * float32, float64\n  * slices of any supported type\n  * maps (keys and values of any supported type)\n  * [encoding.TextUnmarshaler](https://golang.org/pkg/encoding/#TextUnmarshaler)\n  * [encoding.BinaryUnmarshaler](https://golang.org/pkg/encoding/#BinaryUnmarshaler)\n  * [time.Duration](https://golang.org/pkg/time/#Duration)\n\nEmbedded structs using these fields are also supported.\n\n## Custom Decoders\n\nAny field whose type (or pointer-to-type) implements `envconfig.Decoder` can\ncontrol its own deserialization:\n\n```Bash\nexport DNS_SERVER=8.8.8.8\n```\n\n```Go\ntype IPDecoder net.IP\n\nfunc (ipd *IPDecoder) Decode(value string) error {\n    *ipd = IPDecoder(net.ParseIP(value))\n    return nil\n}\n\ntype DNSConfig struct {\n    Address IPDecoder `envconfig:\"DNS_SERVER\"`\n}\n```\n\nExample for decoding the environment variables into map[string][]structName type\n\n```Bash\nexport SMS_PROVIDER_WITH_WEIGHT= `IND=[{\"name\":\"SMSProvider1\",\"weight\":70},{\"name\":\"SMSProvider2\",\"weight\":30}];US=[{\"name\":\"SMSProvider1\",\"weight\":100}]`\n```\n\n```GO\ntype providerDetails struct {\n\tName   string\n\tWeight int\n}\n\ntype SMSProviderDecoder map[string][]providerDetails\n\nfunc (sd *SMSProviderDecoder) Decode(value string) error {\n\tsmsProvider := map[string][]providerDetails{}\n\tpairs := strings.Split(value, \";\")\n\tfor _, pair := range pairs {\n\t\tproviderdata := []providerDetails{}\n\t\tkvpair := strings.Split(pair, \"=\")\n\t\tif len(kvpair) != 2 {\n\t\t\treturn fmt.Errorf(\"invalid map item: %q\", pair)\n\t\t}\n\t\terr := json.Unmarshal([]byte(kvpair[1]), &providerdata)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid map json: %w\", err)\n\t\t}\n\t\tsmsProvider[kvpair[0]] = providerdata\n\n\t}\n\t*sd = SMSProviderDecoder(smsProvider)\n\treturn nil\n}\n\ntype SMSProviderConfig struct {\n    ProviderWithWeight SMSProviderDecoder `envconfig:\"SMS_PROVIDER_WITH_WEIGHT\"`\n}\n```\n\nAlso, envconfig will use a `Set(string) error` method like from the\n[flag.Value](https://godoc.org/flag#Value) interface if implemented.\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.35546875,
          "content": "// Copyright (c) 2013 Kelsey Hightower. All rights reserved.\n// Use of this source code is governed by the MIT License that can be found in\n// the LICENSE file.\n\n// Package envconfig implements decoding of environment variables based on a user\n// defined specification. A typical use is using environment variables for\n// configuration settings.\npackage envconfig\n"
        },
        {
          "name": "env_os.go",
          "type": "blob",
          "size": 0.0859375,
          "content": "// +build appengine go1.5\n\npackage envconfig\n\nimport \"os\"\n\nvar lookupEnv = os.LookupEnv\n"
        },
        {
          "name": "env_syscall.go",
          "type": "blob",
          "size": 0.0947265625,
          "content": "// +build !appengine,!go1.5\n\npackage envconfig\n\nimport \"syscall\"\n\nvar lookupEnv = syscall.Getenv\n"
        },
        {
          "name": "envconfig.go",
          "type": "blob",
          "size": 9.3076171875,
          "content": "// Copyright (c) 2013 Kelsey Hightower. All rights reserved.\n// Use of this source code is governed by the MIT License that can be found in\n// the LICENSE file.\n\npackage envconfig\n\nimport (\n\t\"encoding\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// ErrInvalidSpecification indicates that a specification is of the wrong type.\nvar ErrInvalidSpecification = errors.New(\"specification must be a struct pointer\")\n\nvar gatherRegexp = regexp.MustCompile(\"([^A-Z]+|[A-Z]+[^A-Z]+|[A-Z]+)\")\nvar acronymRegexp = regexp.MustCompile(\"([A-Z]+)([A-Z][^A-Z]+)\")\n\n// A ParseError occurs when an environment variable cannot be converted to\n// the type required by a struct field during assignment.\ntype ParseError struct {\n\tKeyName   string\n\tFieldName string\n\tTypeName  string\n\tValue     string\n\tErr       error\n}\n\n// Decoder has the same semantics as Setter, but takes higher precedence.\n// It is provided for historical compatibility.\ntype Decoder interface {\n\tDecode(value string) error\n}\n\n// Setter is implemented by types can self-deserialize values.\n// Any type that implements flag.Value also implements Setter.\ntype Setter interface {\n\tSet(value string) error\n}\n\nfunc (e *ParseError) Error() string {\n\treturn fmt.Sprintf(\"envconfig.Process: assigning %[1]s to %[2]s: converting '%[3]s' to type %[4]s. details: %[5]s\", e.KeyName, e.FieldName, e.Value, e.TypeName, e.Err)\n}\n\n// varInfo maintains information about the configuration variable\ntype varInfo struct {\n\tName  string\n\tAlt   string\n\tKey   string\n\tField reflect.Value\n\tTags  reflect.StructTag\n}\n\n// GatherInfo gathers information about the specified struct\nfunc gatherInfo(prefix string, spec interface{}) ([]varInfo, error) {\n\ts := reflect.ValueOf(spec)\n\n\tif s.Kind() != reflect.Ptr {\n\t\treturn nil, ErrInvalidSpecification\n\t}\n\ts = s.Elem()\n\tif s.Kind() != reflect.Struct {\n\t\treturn nil, ErrInvalidSpecification\n\t}\n\ttypeOfSpec := s.Type()\n\n\t// over allocate an info array, we will extend if needed later\n\tinfos := make([]varInfo, 0, s.NumField())\n\tfor i := 0; i < s.NumField(); i++ {\n\t\tf := s.Field(i)\n\t\tftype := typeOfSpec.Field(i)\n\t\tif !f.CanSet() || isTrue(ftype.Tag.Get(\"ignored\")) {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor f.Kind() == reflect.Ptr {\n\t\t\tif f.IsNil() {\n\t\t\t\tif f.Type().Elem().Kind() != reflect.Struct {\n\t\t\t\t\t// nil pointer to a non-struct: leave it alone\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\t// nil pointer to struct: create a zero instance\n\t\t\t\tf.Set(reflect.New(f.Type().Elem()))\n\t\t\t}\n\t\t\tf = f.Elem()\n\t\t}\n\n\t\t// Capture information about the config variable\n\t\tinfo := varInfo{\n\t\t\tName:  ftype.Name,\n\t\t\tField: f,\n\t\t\tTags:  ftype.Tag,\n\t\t\tAlt:   strings.ToUpper(ftype.Tag.Get(\"envconfig\")),\n\t\t}\n\n\t\t// Default to the field name as the env var name (will be upcased)\n\t\tinfo.Key = info.Name\n\n\t\t// Best effort to un-pick camel casing as separate words\n\t\tif isTrue(ftype.Tag.Get(\"split_words\")) {\n\t\t\twords := gatherRegexp.FindAllStringSubmatch(ftype.Name, -1)\n\t\t\tif len(words) > 0 {\n\t\t\t\tvar name []string\n\t\t\t\tfor _, words := range words {\n\t\t\t\t\tif m := acronymRegexp.FindStringSubmatch(words[0]); len(m) == 3 {\n\t\t\t\t\t\tname = append(name, m[1], m[2])\n\t\t\t\t\t} else {\n\t\t\t\t\t\tname = append(name, words[0])\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tinfo.Key = strings.Join(name, \"_\")\n\t\t\t}\n\t\t}\n\t\tif info.Alt != \"\" {\n\t\t\tinfo.Key = info.Alt\n\t\t}\n\t\tif prefix != \"\" {\n\t\t\tinfo.Key = fmt.Sprintf(\"%s_%s\", prefix, info.Key)\n\t\t}\n\t\tinfo.Key = strings.ToUpper(info.Key)\n\t\tinfos = append(infos, info)\n\n\t\tif f.Kind() == reflect.Struct {\n\t\t\t// honor Decode if present\n\t\t\tif decoderFrom(f) == nil && setterFrom(f) == nil && textUnmarshaler(f) == nil && binaryUnmarshaler(f) == nil {\n\t\t\t\tinnerPrefix := prefix\n\t\t\t\tif !ftype.Anonymous {\n\t\t\t\t\tinnerPrefix = info.Key\n\t\t\t\t}\n\n\t\t\t\tembeddedPtr := f.Addr().Interface()\n\t\t\t\tembeddedInfos, err := gatherInfo(innerPrefix, embeddedPtr)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tinfos = append(infos[:len(infos)-1], embeddedInfos...)\n\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n\treturn infos, nil\n}\n\n// CheckDisallowed checks that no environment variables with the prefix are set\n// that we don't know how or want to parse. This is likely only meaningful with\n// a non-empty prefix.\nfunc CheckDisallowed(prefix string, spec interface{}) error {\n\tinfos, err := gatherInfo(prefix, spec)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvars := make(map[string]struct{})\n\tfor _, info := range infos {\n\t\tvars[info.Key] = struct{}{}\n\t}\n\n\tif prefix != \"\" {\n\t\tprefix = strings.ToUpper(prefix) + \"_\"\n\t}\n\n\tfor _, env := range os.Environ() {\n\t\tif !strings.HasPrefix(env, prefix) {\n\t\t\tcontinue\n\t\t}\n\t\tv := strings.SplitN(env, \"=\", 2)[0]\n\t\tif _, found := vars[v]; !found {\n\t\t\treturn fmt.Errorf(\"unknown environment variable %s\", v)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Process populates the specified struct based on environment variables\nfunc Process(prefix string, spec interface{}) error {\n\tinfos, err := gatherInfo(prefix, spec)\n\n\tfor _, info := range infos {\n\n\t\t// `os.Getenv` cannot differentiate between an explicitly set empty value\n\t\t// and an unset value. `os.LookupEnv` is preferred to `syscall.Getenv`,\n\t\t// but it is only available in go1.5 or newer. We're using Go build tags\n\t\t// here to use os.LookupEnv for >=go1.5\n\t\tvalue, ok := lookupEnv(info.Key)\n\t\tif !ok && info.Alt != \"\" {\n\t\t\tvalue, ok = lookupEnv(info.Alt)\n\t\t}\n\n\t\tdef := info.Tags.Get(\"default\")\n\t\tif def != \"\" && !ok {\n\t\t\tvalue = def\n\t\t}\n\n\t\treq := info.Tags.Get(\"required\")\n\t\tif !ok && def == \"\" {\n\t\t\tif isTrue(req) {\n\t\t\t\tkey := info.Key\n\t\t\t\tif info.Alt != \"\" {\n\t\t\t\t\tkey = info.Alt\n\t\t\t\t}\n\t\t\t\treturn fmt.Errorf(\"required key %s missing value\", key)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\terr = processField(value, info.Field)\n\t\tif err != nil {\n\t\t\treturn &ParseError{\n\t\t\t\tKeyName:   info.Key,\n\t\t\t\tFieldName: info.Name,\n\t\t\t\tTypeName:  info.Field.Type().String(),\n\t\t\t\tValue:     value,\n\t\t\t\tErr:       err,\n\t\t\t}\n\t\t}\n\t}\n\n\treturn err\n}\n\n// MustProcess is the same as Process but panics if an error occurs\nfunc MustProcess(prefix string, spec interface{}) {\n\tif err := Process(prefix, spec); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc processField(value string, field reflect.Value) error {\n\ttyp := field.Type()\n\n\tdecoder := decoderFrom(field)\n\tif decoder != nil {\n\t\treturn decoder.Decode(value)\n\t}\n\t// look for Set method if Decode not defined\n\tsetter := setterFrom(field)\n\tif setter != nil {\n\t\treturn setter.Set(value)\n\t}\n\n\tif t := textUnmarshaler(field); t != nil {\n\t\treturn t.UnmarshalText([]byte(value))\n\t}\n\n\tif b := binaryUnmarshaler(field); b != nil {\n\t\treturn b.UnmarshalBinary([]byte(value))\n\t}\n\n\tif typ.Kind() == reflect.Ptr {\n\t\ttyp = typ.Elem()\n\t\tif field.IsNil() {\n\t\t\tfield.Set(reflect.New(typ))\n\t\t}\n\t\tfield = field.Elem()\n\t}\n\n\tswitch typ.Kind() {\n\tcase reflect.String:\n\t\tfield.SetString(value)\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tvar (\n\t\t\tval int64\n\t\t\terr error\n\t\t)\n\t\tif field.Kind() == reflect.Int64 && typ.PkgPath() == \"time\" && typ.Name() == \"Duration\" {\n\t\t\tvar d time.Duration\n\t\t\td, err = time.ParseDuration(value)\n\t\t\tval = int64(d)\n\t\t} else {\n\t\t\tval, err = strconv.ParseInt(value, 0, typ.Bits())\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfield.SetInt(val)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tval, err := strconv.ParseUint(value, 0, typ.Bits())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfield.SetUint(val)\n\tcase reflect.Bool:\n\t\tval, err := strconv.ParseBool(value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfield.SetBool(val)\n\tcase reflect.Float32, reflect.Float64:\n\t\tval, err := strconv.ParseFloat(value, typ.Bits())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfield.SetFloat(val)\n\tcase reflect.Slice:\n\t\tsl := reflect.MakeSlice(typ, 0, 0)\n\t\tif typ.Elem().Kind() == reflect.Uint8 {\n\t\t\tsl = reflect.ValueOf([]byte(value))\n\t\t} else if strings.TrimSpace(value) != \"\" {\n\t\t\tvals := strings.Split(value, \",\")\n\t\t\tsl = reflect.MakeSlice(typ, len(vals), len(vals))\n\t\t\tfor i, val := range vals {\n\t\t\t\terr := processField(val, sl.Index(i))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfield.Set(sl)\n\tcase reflect.Map:\n\t\tmp := reflect.MakeMap(typ)\n\t\tif strings.TrimSpace(value) != \"\" {\n\t\t\tpairs := strings.Split(value, \",\")\n\t\t\tfor _, pair := range pairs {\n\t\t\t\tkvpair := strings.Split(pair, \":\")\n\t\t\t\tif len(kvpair) != 2 {\n\t\t\t\t\treturn fmt.Errorf(\"invalid map item: %q\", pair)\n\t\t\t\t}\n\t\t\t\tk := reflect.New(typ.Key()).Elem()\n\t\t\t\terr := processField(kvpair[0], k)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tv := reflect.New(typ.Elem()).Elem()\n\t\t\t\terr = processField(kvpair[1], v)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tmp.SetMapIndex(k, v)\n\t\t\t}\n\t\t}\n\t\tfield.Set(mp)\n\t}\n\n\treturn nil\n}\n\nfunc interfaceFrom(field reflect.Value, fn func(interface{}, *bool)) {\n\t// it may be impossible for a struct field to fail this check\n\tif !field.CanInterface() {\n\t\treturn\n\t}\n\tvar ok bool\n\tfn(field.Interface(), &ok)\n\tif !ok && field.CanAddr() {\n\t\tfn(field.Addr().Interface(), &ok)\n\t}\n}\n\nfunc decoderFrom(field reflect.Value) (d Decoder) {\n\tinterfaceFrom(field, func(v interface{}, ok *bool) { d, *ok = v.(Decoder) })\n\treturn d\n}\n\nfunc setterFrom(field reflect.Value) (s Setter) {\n\tinterfaceFrom(field, func(v interface{}, ok *bool) { s, *ok = v.(Setter) })\n\treturn s\n}\n\nfunc textUnmarshaler(field reflect.Value) (t encoding.TextUnmarshaler) {\n\tinterfaceFrom(field, func(v interface{}, ok *bool) { t, *ok = v.(encoding.TextUnmarshaler) })\n\treturn t\n}\n\nfunc binaryUnmarshaler(field reflect.Value) (b encoding.BinaryUnmarshaler) {\n\tinterfaceFrom(field, func(v interface{}, ok *bool) { b, *ok = v.(encoding.BinaryUnmarshaler) })\n\treturn b\n}\n\nfunc isTrue(s string) bool {\n\tb, _ := strconv.ParseBool(s)\n\treturn b\n}\n"
        },
        {
          "name": "envconfig_1.8_test.go",
          "type": "blob",
          "size": 1.376953125,
          "content": "// +build go1.8\n\npackage envconfig\n\nimport (\n\t\"errors\"\n\t\"net/url\"\n\t\"os\"\n\t\"testing\"\n)\n\ntype SpecWithURL struct {\n\tUrlValue   url.URL\n\tUrlPointer *url.URL\n}\n\nfunc TestParseURL(t *testing.T) {\n\tvar s SpecWithURL\n\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_URLVALUE\", \"https://github.com/kelseyhightower/envconfig\")\n\tos.Setenv(\"ENV_CONFIG_URLPOINTER\", \"https://github.com/kelseyhightower/envconfig\")\n\n\terr := Process(\"env_config\", &s)\n\tif err != nil {\n\t\tt.Fatal(\"unexpected error:\", err)\n\t}\n\n\tu, err := url.Parse(\"https://github.com/kelseyhightower/envconfig\")\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\n\tif s.UrlValue != *u {\n\t\tt.Errorf(\"expected %q, got %q\", u, s.UrlValue.String())\n\t}\n\n\tif *s.UrlPointer != *u {\n\t\tt.Errorf(\"expected %q, got %q\", u, s.UrlPointer)\n\t}\n}\n\nfunc TestParseURLError(t *testing.T) {\n\tvar s SpecWithURL\n\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_URLPOINTER\", \"http_://foo\")\n\n\terr := Process(\"env_config\", &s)\n\n\tv, ok := err.(*ParseError)\n\tif !ok {\n\t\tt.Fatalf(\"expected ParseError, got %T %v\", err, err)\n\t}\n\tif v.FieldName != \"UrlPointer\" {\n\t\tt.Errorf(\"expected %s, got %v\", \"UrlPointer\", v.FieldName)\n\t}\n\n\texpectedUnerlyingError := url.Error{\n\t\tOp:  \"parse\",\n\t\tURL: \"http_://foo\",\n\t\tErr: errors.New(\"first path segment in URL cannot contain colon\"),\n\t}\n\n\tif v.Err.Error() != expectedUnerlyingError.Error() {\n\t\tt.Errorf(\"expected %q, got %q\", expectedUnerlyingError, v.Err)\n\t}\n}\n"
        },
        {
          "name": "envconfig_test.go",
          "type": "blob",
          "size": 23.240234375,
          "content": "// Copyright (c) 2013 Kelsey Hightower. All rights reserved.\n// Use of this source code is governed by the MIT License that can be found in\n// the LICENSE file.\n\npackage envconfig\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype HonorDecodeInStruct struct {\n\tValue string\n}\n\nfunc (h *HonorDecodeInStruct) Decode(env string) error {\n\th.Value = \"decoded\"\n\treturn nil\n}\n\ntype CustomURL struct {\n\tValue *url.URL\n}\n\nfunc (cu *CustomURL) UnmarshalBinary(data []byte) error {\n\tu, err := url.Parse(string(data))\n\tcu.Value = u\n\treturn err\n}\n\ntype Specification struct {\n\tEmbedded                     `desc:\"can we document a struct\"`\n\tEmbeddedButIgnored           `ignored:\"true\"`\n\tDebug                        bool\n\tPort                         int\n\tRate                         float32\n\tUser                         string\n\tTTL                          uint32\n\tTimeout                      time.Duration\n\tAdminUsers                   []string\n\tMagicNumbers                 []int\n\tEmptyNumbers                 []int\n\tByteSlice                    []byte\n\tColorCodes                   map[string]int\n\tMultiWordVar                 string\n\tMultiWordVarWithAutoSplit    uint32 `split_words:\"true\"`\n\tMultiWordACRWithAutoSplit    uint32 `split_words:\"true\"`\n\tSomePointer                  *string\n\tSomePointerWithDefault       *string `default:\"foo2baz\" desc:\"foorbar is the word\"`\n\tMultiWordVarWithAlt          string  `envconfig:\"MULTI_WORD_VAR_WITH_ALT\" desc:\"what alt\"`\n\tMultiWordVarWithLowerCaseAlt string  `envconfig:\"multi_word_var_with_lower_case_alt\"`\n\tNoPrefixWithAlt              string  `envconfig:\"SERVICE_HOST\"`\n\tDefaultVar                   string  `default:\"foobar\"`\n\tRequiredVar                  string  `required:\"True\"`\n\tNoPrefixDefault              string  `envconfig:\"BROKER\" default:\"127.0.0.1\"`\n\tRequiredDefault              string  `required:\"true\" default:\"foo2bar\"`\n\tIgnored                      string  `ignored:\"true\"`\n\tNestedSpecification          struct {\n\t\tProperty            string `envconfig:\"inner\"`\n\t\tPropertyWithDefault string `default:\"fuzzybydefault\"`\n\t} `envconfig:\"outer\"`\n\tAfterNested  string\n\tDecodeStruct HonorDecodeInStruct `envconfig:\"honor\"`\n\tDatetime     time.Time\n\tMapField     map[string]string `default:\"one:two,three:four\"`\n\tUrlValue     CustomURL\n\tUrlPointer   *CustomURL\n}\n\ntype Embedded struct {\n\tEnabled             bool `desc:\"some embedded value\"`\n\tEmbeddedPort        int\n\tMultiWordVar        string\n\tMultiWordVarWithAlt string `envconfig:\"MULTI_WITH_DIFFERENT_ALT\"`\n\tEmbeddedAlt         string `envconfig:\"EMBEDDED_WITH_ALT\"`\n\tEmbeddedIgnored     string `ignored:\"true\"`\n}\n\ntype EmbeddedButIgnored struct {\n\tFirstEmbeddedButIgnored  string\n\tSecondEmbeddedButIgnored string\n}\n\nfunc TestProcess(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_DEBUG\", \"true\")\n\tos.Setenv(\"ENV_CONFIG_PORT\", \"8080\")\n\tos.Setenv(\"ENV_CONFIG_RATE\", \"0.5\")\n\tos.Setenv(\"ENV_CONFIG_USER\", \"Kelsey\")\n\tos.Setenv(\"ENV_CONFIG_TIMEOUT\", \"2m\")\n\tos.Setenv(\"ENV_CONFIG_ADMINUSERS\", \"John,Adam,Will\")\n\tos.Setenv(\"ENV_CONFIG_MAGICNUMBERS\", \"5,10,20\")\n\tos.Setenv(\"ENV_CONFIG_EMPTYNUMBERS\", \"\")\n\tos.Setenv(\"ENV_CONFIG_BYTESLICE\", \"this is a test value\")\n\tos.Setenv(\"ENV_CONFIG_COLORCODES\", \"red:1,green:2,blue:3\")\n\tos.Setenv(\"SERVICE_HOST\", \"127.0.0.1\")\n\tos.Setenv(\"ENV_CONFIG_TTL\", \"30\")\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"foo\")\n\tos.Setenv(\"ENV_CONFIG_IGNORED\", \"was-not-ignored\")\n\tos.Setenv(\"ENV_CONFIG_OUTER_INNER\", \"iamnested\")\n\tos.Setenv(\"ENV_CONFIG_AFTERNESTED\", \"after\")\n\tos.Setenv(\"ENV_CONFIG_HONOR\", \"honor\")\n\tos.Setenv(\"ENV_CONFIG_DATETIME\", \"2016-08-16T18:57:05Z\")\n\tos.Setenv(\"ENV_CONFIG_MULTI_WORD_VAR_WITH_AUTO_SPLIT\", \"24\")\n\tos.Setenv(\"ENV_CONFIG_MULTI_WORD_ACR_WITH_AUTO_SPLIT\", \"25\")\n\tos.Setenv(\"ENV_CONFIG_URLVALUE\", \"https://github.com/kelseyhightower/envconfig\")\n\tos.Setenv(\"ENV_CONFIG_URLPOINTER\", \"https://github.com/kelseyhightower/envconfig\")\n\terr := Process(\"env_config\", &s)\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tif s.NoPrefixWithAlt != \"127.0.0.1\" {\n\t\tt.Errorf(\"expected %v, got %v\", \"127.0.0.1\", s.NoPrefixWithAlt)\n\t}\n\tif !s.Debug {\n\t\tt.Errorf(\"expected %v, got %v\", true, s.Debug)\n\t}\n\tif s.Port != 8080 {\n\t\tt.Errorf(\"expected %d, got %v\", 8080, s.Port)\n\t}\n\tif s.Rate != 0.5 {\n\t\tt.Errorf(\"expected %f, got %v\", 0.5, s.Rate)\n\t}\n\tif s.TTL != 30 {\n\t\tt.Errorf(\"expected %d, got %v\", 30, s.TTL)\n\t}\n\tif s.User != \"Kelsey\" {\n\t\tt.Errorf(\"expected %s, got %s\", \"Kelsey\", s.User)\n\t}\n\tif s.Timeout != 2*time.Minute {\n\t\tt.Errorf(\"expected %s, got %s\", 2*time.Minute, s.Timeout)\n\t}\n\tif s.RequiredVar != \"foo\" {\n\t\tt.Errorf(\"expected %s, got %s\", \"foo\", s.RequiredVar)\n\t}\n\tif len(s.AdminUsers) != 3 ||\n\t\ts.AdminUsers[0] != \"John\" ||\n\t\ts.AdminUsers[1] != \"Adam\" ||\n\t\ts.AdminUsers[2] != \"Will\" {\n\t\tt.Errorf(\"expected %#v, got %#v\", []string{\"John\", \"Adam\", \"Will\"}, s.AdminUsers)\n\t}\n\tif len(s.MagicNumbers) != 3 ||\n\t\ts.MagicNumbers[0] != 5 ||\n\t\ts.MagicNumbers[1] != 10 ||\n\t\ts.MagicNumbers[2] != 20 {\n\t\tt.Errorf(\"expected %#v, got %#v\", []int{5, 10, 20}, s.MagicNumbers)\n\t}\n\tif len(s.EmptyNumbers) != 0 {\n\t\tt.Errorf(\"expected %#v, got %#v\", []int{}, s.EmptyNumbers)\n\t}\n\texpected := \"this is a test value\"\n\tif string(s.ByteSlice) != expected {\n\t\tt.Errorf(\"expected %v, got %v\", expected, string(s.ByteSlice))\n\t}\n\tif s.Ignored != \"\" {\n\t\tt.Errorf(\"expected empty string, got %#v\", s.Ignored)\n\t}\n\n\tif len(s.ColorCodes) != 3 ||\n\t\ts.ColorCodes[\"red\"] != 1 ||\n\t\ts.ColorCodes[\"green\"] != 2 ||\n\t\ts.ColorCodes[\"blue\"] != 3 {\n\t\tt.Errorf(\n\t\t\t\"expected %#v, got %#v\",\n\t\t\tmap[string]int{\n\t\t\t\t\"red\":   1,\n\t\t\t\t\"green\": 2,\n\t\t\t\t\"blue\":  3,\n\t\t\t},\n\t\t\ts.ColorCodes,\n\t\t)\n\t}\n\n\tif s.NestedSpecification.Property != \"iamnested\" {\n\t\tt.Errorf(\"expected '%s' string, got %#v\", \"iamnested\", s.NestedSpecification.Property)\n\t}\n\n\tif s.NestedSpecification.PropertyWithDefault != \"fuzzybydefault\" {\n\t\tt.Errorf(\"expected default '%s' string, got %#v\", \"fuzzybydefault\", s.NestedSpecification.PropertyWithDefault)\n\t}\n\n\tif s.AfterNested != \"after\" {\n\t\tt.Errorf(\"expected default '%s' string, got %#v\", \"after\", s.AfterNested)\n\t}\n\n\tif s.DecodeStruct.Value != \"decoded\" {\n\t\tt.Errorf(\"expected default '%s' string, got %#v\", \"decoded\", s.DecodeStruct.Value)\n\t}\n\n\tif expected := time.Date(2016, 8, 16, 18, 57, 05, 0, time.UTC); !s.Datetime.Equal(expected) {\n\t\tt.Errorf(\"expected %s, got %s\", expected.Format(time.RFC3339), s.Datetime.Format(time.RFC3339))\n\t}\n\n\tif s.MultiWordVarWithAutoSplit != 24 {\n\t\tt.Errorf(\"expected %q, got %q\", 24, s.MultiWordVarWithAutoSplit)\n\t}\n\n\tif s.MultiWordACRWithAutoSplit != 25 {\n\t\tt.Errorf(\"expected %d, got %d\", 25, s.MultiWordACRWithAutoSplit)\n\t}\n\n\tu, err := url.Parse(\"https://github.com/kelseyhightower/envconfig\")\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\n\tif *s.UrlValue.Value != *u {\n\t\tt.Errorf(\"expected %q, got %q\", u, s.UrlValue.Value.String())\n\t}\n\n\tif *s.UrlPointer.Value != *u {\n\t\tt.Errorf(\"expected %q, got %q\", u, s.UrlPointer.Value.String())\n\t}\n}\n\nfunc TestParseErrorBool(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_DEBUG\", \"string\")\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"foo\")\n\terr := Process(\"env_config\", &s)\n\tv, ok := err.(*ParseError)\n\tif !ok {\n\t\tt.Errorf(\"expected ParseError, got %v\", v)\n\t}\n\tif v.FieldName != \"Debug\" {\n\t\tt.Errorf(\"expected %s, got %v\", \"Debug\", v.FieldName)\n\t}\n\tif s.Debug != false {\n\t\tt.Errorf(\"expected %v, got %v\", false, s.Debug)\n\t}\n}\n\nfunc TestParseErrorFloat32(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_RATE\", \"string\")\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"foo\")\n\terr := Process(\"env_config\", &s)\n\tv, ok := err.(*ParseError)\n\tif !ok {\n\t\tt.Errorf(\"expected ParseError, got %v\", v)\n\t}\n\tif v.FieldName != \"Rate\" {\n\t\tt.Errorf(\"expected %s, got %v\", \"Rate\", v.FieldName)\n\t}\n\tif s.Rate != 0 {\n\t\tt.Errorf(\"expected %v, got %v\", 0, s.Rate)\n\t}\n}\n\nfunc TestParseErrorInt(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_PORT\", \"string\")\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"foo\")\n\terr := Process(\"env_config\", &s)\n\tv, ok := err.(*ParseError)\n\tif !ok {\n\t\tt.Errorf(\"expected ParseError, got %v\", v)\n\t}\n\tif v.FieldName != \"Port\" {\n\t\tt.Errorf(\"expected %s, got %v\", \"Port\", v.FieldName)\n\t}\n\tif s.Port != 0 {\n\t\tt.Errorf(\"expected %v, got %v\", 0, s.Port)\n\t}\n}\n\nfunc TestParseErrorUint(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_TTL\", \"-30\")\n\terr := Process(\"env_config\", &s)\n\tv, ok := err.(*ParseError)\n\tif !ok {\n\t\tt.Errorf(\"expected ParseError, got %v\", v)\n\t}\n\tif v.FieldName != \"TTL\" {\n\t\tt.Errorf(\"expected %s, got %v\", \"TTL\", v.FieldName)\n\t}\n\tif s.TTL != 0 {\n\t\tt.Errorf(\"expected %v, got %v\", 0, s.TTL)\n\t}\n}\n\nfunc TestParseErrorSplitWords(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_MULTI_WORD_VAR_WITH_AUTO_SPLIT\", \"shakespeare\")\n\terr := Process(\"env_config\", &s)\n\tv, ok := err.(*ParseError)\n\tif !ok {\n\t\tt.Errorf(\"expected ParseError, got %v\", v)\n\t}\n\tif v.FieldName != \"MultiWordVarWithAutoSplit\" {\n\t\tt.Errorf(\"expected %s, got %v\", \"\", v.FieldName)\n\t}\n\tif s.MultiWordVarWithAutoSplit != 0 {\n\t\tt.Errorf(\"expected %v, got %v\", 0, s.MultiWordVarWithAutoSplit)\n\t}\n}\n\nfunc TestErrInvalidSpecification(t *testing.T) {\n\tm := make(map[string]string)\n\terr := Process(\"env_config\", &m)\n\tif err != ErrInvalidSpecification {\n\t\tt.Errorf(\"expected %v, got %v\", ErrInvalidSpecification, err)\n\t}\n}\n\nfunc TestUnsetVars(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"USER\", \"foo\")\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"foo\")\n\tif err := Process(\"env_config\", &s); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\t// If the var is not defined the non-prefixed version should not be used\n\t// unless the struct tag says so\n\tif s.User != \"\" {\n\t\tt.Errorf(\"expected %q, got %q\", \"\", s.User)\n\t}\n}\n\nfunc TestAlternateVarNames(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_MULTI_WORD_VAR\", \"foo\")\n\tos.Setenv(\"ENV_CONFIG_MULTI_WORD_VAR_WITH_ALT\", \"bar\")\n\tos.Setenv(\"ENV_CONFIG_MULTI_WORD_VAR_WITH_LOWER_CASE_ALT\", \"baz\")\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"foo\")\n\tif err := Process(\"env_config\", &s); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\t// Setting the alt version of the var in the environment has no effect if\n\t// the struct tag is not supplied\n\tif s.MultiWordVar != \"\" {\n\t\tt.Errorf(\"expected %q, got %q\", \"\", s.MultiWordVar)\n\t}\n\n\t// Setting the alt version of the var in the environment correctly sets\n\t// the value if the struct tag IS supplied\n\tif s.MultiWordVarWithAlt != \"bar\" {\n\t\tt.Errorf(\"expected %q, got %q\", \"bar\", s.MultiWordVarWithAlt)\n\t}\n\n\t// Alt value is not case sensitive and is treated as all uppercase\n\tif s.MultiWordVarWithLowerCaseAlt != \"baz\" {\n\t\tt.Errorf(\"expected %q, got %q\", \"baz\", s.MultiWordVarWithLowerCaseAlt)\n\t}\n}\n\nfunc TestRequiredVar(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"foobar\")\n\tif err := Process(\"env_config\", &s); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tif s.RequiredVar != \"foobar\" {\n\t\tt.Errorf(\"expected %s, got %s\", \"foobar\", s.RequiredVar)\n\t}\n}\n\nfunc TestRequiredMissing(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\n\terr := Process(\"env_config\", &s)\n\tif err == nil {\n\t\tt.Error(\"no failure when missing required variable\")\n\t}\n}\n\nfunc TestBlankDefaultVar(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"requiredvalue\")\n\tif err := Process(\"env_config\", &s); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tif s.DefaultVar != \"foobar\" {\n\t\tt.Errorf(\"expected %s, got %s\", \"foobar\", s.DefaultVar)\n\t}\n\n\tif *s.SomePointerWithDefault != \"foo2baz\" {\n\t\tt.Errorf(\"expected %s, got %s\", \"foo2baz\", *s.SomePointerWithDefault)\n\t}\n}\n\nfunc TestNonBlankDefaultVar(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_DEFAULTVAR\", \"nondefaultval\")\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"requiredvalue\")\n\tif err := Process(\"env_config\", &s); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tif s.DefaultVar != \"nondefaultval\" {\n\t\tt.Errorf(\"expected %s, got %s\", \"nondefaultval\", s.DefaultVar)\n\t}\n}\n\nfunc TestExplicitBlankDefaultVar(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_DEFAULTVAR\", \"\")\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"\")\n\n\tif err := Process(\"env_config\", &s); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tif s.DefaultVar != \"\" {\n\t\tt.Errorf(\"expected %s, got %s\", \"\\\"\\\"\", s.DefaultVar)\n\t}\n}\n\nfunc TestAlternateNameDefaultVar(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"BROKER\", \"betterbroker\")\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"foo\")\n\tif err := Process(\"env_config\", &s); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tif s.NoPrefixDefault != \"betterbroker\" {\n\t\tt.Errorf(\"expected %q, got %q\", \"betterbroker\", s.NoPrefixDefault)\n\t}\n\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"foo\")\n\tif err := Process(\"env_config\", &s); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tif s.NoPrefixDefault != \"127.0.0.1\" {\n\t\tt.Errorf(\"expected %q, got %q\", \"127.0.0.1\", s.NoPrefixDefault)\n\t}\n}\n\nfunc TestRequiredDefault(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"foo\")\n\tif err := Process(\"env_config\", &s); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tif s.RequiredDefault != \"foo2bar\" {\n\t\tt.Errorf(\"expected %q, got %q\", \"foo2bar\", s.RequiredDefault)\n\t}\n}\n\nfunc TestPointerFieldBlank(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"foo\")\n\tif err := Process(\"env_config\", &s); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tif s.SomePointer != nil {\n\t\tt.Errorf(\"expected <nil>, got %q\", *s.SomePointer)\n\t}\n}\n\nfunc TestEmptyMapFieldOverride(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"foo\")\n\tos.Setenv(\"ENV_CONFIG_MAPFIELD\", \"\")\n\tif err := Process(\"env_config\", &s); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tif s.MapField == nil {\n\t\tt.Error(\"expected empty map, got <nil>\")\n\t}\n\n\tif len(s.MapField) != 0 {\n\t\tt.Errorf(\"expected empty map, got map of size %d\", len(s.MapField))\n\t}\n}\n\nfunc TestMustProcess(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_DEBUG\", \"true\")\n\tos.Setenv(\"ENV_CONFIG_PORT\", \"8080\")\n\tos.Setenv(\"ENV_CONFIG_RATE\", \"0.5\")\n\tos.Setenv(\"ENV_CONFIG_USER\", \"Kelsey\")\n\tos.Setenv(\"SERVICE_HOST\", \"127.0.0.1\")\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"foo\")\n\tMustProcess(\"env_config\", &s)\n\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tt.Error(\"expected panic\")\n\t}()\n\tm := make(map[string]string)\n\tMustProcess(\"env_config\", &m)\n}\n\nfunc TestEmbeddedStruct(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"required\")\n\tos.Setenv(\"ENV_CONFIG_ENABLED\", \"true\")\n\tos.Setenv(\"ENV_CONFIG_EMBEDDEDPORT\", \"1234\")\n\tos.Setenv(\"ENV_CONFIG_MULTIWORDVAR\", \"foo\")\n\tos.Setenv(\"ENV_CONFIG_MULTI_WORD_VAR_WITH_ALT\", \"bar\")\n\tos.Setenv(\"ENV_CONFIG_MULTI_WITH_DIFFERENT_ALT\", \"baz\")\n\tos.Setenv(\"ENV_CONFIG_EMBEDDED_WITH_ALT\", \"foobar\")\n\tos.Setenv(\"ENV_CONFIG_SOMEPOINTER\", \"foobaz\")\n\tos.Setenv(\"ENV_CONFIG_EMBEDDED_IGNORED\", \"was-not-ignored\")\n\tif err := Process(\"env_config\", &s); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tif !s.Enabled {\n\t\tt.Errorf(\"expected %v, got %v\", true, s.Enabled)\n\t}\n\tif s.EmbeddedPort != 1234 {\n\t\tt.Errorf(\"expected %d, got %v\", 1234, s.EmbeddedPort)\n\t}\n\tif s.MultiWordVar != \"foo\" {\n\t\tt.Errorf(\"expected %s, got %s\", \"foo\", s.MultiWordVar)\n\t}\n\tif s.Embedded.MultiWordVar != \"foo\" {\n\t\tt.Errorf(\"expected %s, got %s\", \"foo\", s.Embedded.MultiWordVar)\n\t}\n\tif s.MultiWordVarWithAlt != \"bar\" {\n\t\tt.Errorf(\"expected %s, got %s\", \"bar\", s.MultiWordVarWithAlt)\n\t}\n\tif s.Embedded.MultiWordVarWithAlt != \"baz\" {\n\t\tt.Errorf(\"expected %s, got %s\", \"baz\", s.Embedded.MultiWordVarWithAlt)\n\t}\n\tif s.EmbeddedAlt != \"foobar\" {\n\t\tt.Errorf(\"expected %s, got %s\", \"foobar\", s.EmbeddedAlt)\n\t}\n\tif *s.SomePointer != \"foobaz\" {\n\t\tt.Errorf(\"expected %s, got %s\", \"foobaz\", *s.SomePointer)\n\t}\n\tif s.EmbeddedIgnored != \"\" {\n\t\tt.Errorf(\"expected empty string, got %#v\", s.Ignored)\n\t}\n}\n\nfunc TestEmbeddedButIgnoredStruct(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"required\")\n\tos.Setenv(\"ENV_CONFIG_FIRSTEMBEDDEDBUTIGNORED\", \"was-not-ignored\")\n\tos.Setenv(\"ENV_CONFIG_SECONDEMBEDDEDBUTIGNORED\", \"was-not-ignored\")\n\tif err := Process(\"env_config\", &s); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tif s.FirstEmbeddedButIgnored != \"\" {\n\t\tt.Errorf(\"expected empty string, got %#v\", s.Ignored)\n\t}\n\tif s.SecondEmbeddedButIgnored != \"\" {\n\t\tt.Errorf(\"expected empty string, got %#v\", s.Ignored)\n\t}\n}\n\nfunc TestNonPointerFailsProperly(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"snap\")\n\n\terr := Process(\"env_config\", s)\n\tif err != ErrInvalidSpecification {\n\t\tt.Errorf(\"non-pointer should fail with ErrInvalidSpecification, was instead %s\", err)\n\t}\n}\n\nfunc TestCustomValueFields(t *testing.T) {\n\tvar s struct {\n\t\tFoo    string\n\t\tBar    bracketed\n\t\tBaz    quoted\n\t\tStruct setterStruct\n\t}\n\n\t// Set would panic when the receiver is nil,\n\t// so make sure it has an initial value to replace.\n\ts.Baz = quoted{new(bracketed)}\n\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_FOO\", \"foo\")\n\tos.Setenv(\"ENV_CONFIG_BAR\", \"bar\")\n\tos.Setenv(\"ENV_CONFIG_BAZ\", \"baz\")\n\tos.Setenv(\"ENV_CONFIG_STRUCT\", \"inner\")\n\n\tif err := Process(\"env_config\", &s); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tif want := \"foo\"; s.Foo != want {\n\t\tt.Errorf(\"foo: got %#q, want %#q\", s.Foo, want)\n\t}\n\n\tif want := \"[bar]\"; s.Bar.String() != want {\n\t\tt.Errorf(\"bar: got %#q, want %#q\", s.Bar, want)\n\t}\n\n\tif want := `[\"baz\"]`; s.Baz.String() != want {\n\t\tt.Errorf(`baz: got %#q, want %#q`, s.Baz, want)\n\t}\n\n\tif want := `setterstruct{\"inner\"}`; s.Struct.Inner != want {\n\t\tt.Errorf(`Struct.Inner: got %#q, want %#q`, s.Struct.Inner, want)\n\t}\n}\n\nfunc TestCustomPointerFields(t *testing.T) {\n\tvar s struct {\n\t\tFoo    string\n\t\tBar    *bracketed\n\t\tBaz    *quoted\n\t\tStruct *setterStruct\n\t}\n\n\t// Set would panic when the receiver is nil,\n\t// so make sure they have initial values to replace.\n\ts.Bar = new(bracketed)\n\ts.Baz = &quoted{new(bracketed)}\n\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_FOO\", \"foo\")\n\tos.Setenv(\"ENV_CONFIG_BAR\", \"bar\")\n\tos.Setenv(\"ENV_CONFIG_BAZ\", \"baz\")\n\tos.Setenv(\"ENV_CONFIG_STRUCT\", \"inner\")\n\n\tif err := Process(\"env_config\", &s); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tif want := \"foo\"; s.Foo != want {\n\t\tt.Errorf(\"foo: got %#q, want %#q\", s.Foo, want)\n\t}\n\n\tif want := \"[bar]\"; s.Bar.String() != want {\n\t\tt.Errorf(\"bar: got %#q, want %#q\", s.Bar, want)\n\t}\n\n\tif want := `[\"baz\"]`; s.Baz.String() != want {\n\t\tt.Errorf(`baz: got %#q, want %#q`, s.Baz, want)\n\t}\n\n\tif want := `setterstruct{\"inner\"}`; s.Struct.Inner != want {\n\t\tt.Errorf(`Struct.Inner: got %#q, want %#q`, s.Struct.Inner, want)\n\t}\n}\n\nfunc TestEmptyPrefixUsesFieldNames(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"REQUIREDVAR\", \"foo\")\n\n\terr := Process(\"\", &s)\n\tif err != nil {\n\t\tt.Errorf(\"Process failed: %s\", err)\n\t}\n\n\tif s.RequiredVar != \"foo\" {\n\t\tt.Errorf(\n\t\t\t`RequiredVar not populated correctly: expected \"foo\", got %q`,\n\t\t\ts.RequiredVar,\n\t\t)\n\t}\n}\n\nfunc TestNestedStructVarName(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"required\")\n\tval := \"found with only short name\"\n\tos.Setenv(\"INNER\", val)\n\tif err := Process(\"env_config\", &s); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tif s.NestedSpecification.Property != val {\n\t\tt.Errorf(\"expected %s, got %s\", val, s.NestedSpecification.Property)\n\t}\n}\n\nfunc TestTextUnmarshalerError(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"foo\")\n\tos.Setenv(\"ENV_CONFIG_DATETIME\", \"I'M NOT A DATE\")\n\n\terr := Process(\"env_config\", &s)\n\n\tv, ok := err.(*ParseError)\n\tif !ok {\n\t\tt.Errorf(\"expected ParseError, got %v\", v)\n\t}\n\tif v.FieldName != \"Datetime\" {\n\t\tt.Errorf(\"expected %s, got %v\", \"Datetime\", v.FieldName)\n\t}\n\n\texpectedLowLevelError := time.ParseError{\n\t\tLayout:     time.RFC3339,\n\t\tValue:      \"I'M NOT A DATE\",\n\t\tLayoutElem: \"2006\",\n\t\tValueElem:  \"I'M NOT A DATE\",\n\t}\n\n\tif v.Err.Error() != expectedLowLevelError.Error() {\n\t\tt.Errorf(\"expected %s, got %s\", expectedLowLevelError, v.Err)\n\t}\n}\n\nfunc TestBinaryUnmarshalerError(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"foo\")\n\tos.Setenv(\"ENV_CONFIG_URLPOINTER\", \"http://%41:8080/\")\n\n\terr := Process(\"env_config\", &s)\n\n\tv, ok := err.(*ParseError)\n\tif !ok {\n\t\tt.Fatalf(\"expected ParseError, got %T %v\", err, err)\n\t}\n\tif v.FieldName != \"UrlPointer\" {\n\t\tt.Errorf(\"expected %s, got %v\", \"UrlPointer\", v.FieldName)\n\t}\n\n\t// To be compatible with go 1.5 and lower we should do a very basic check,\n\t// because underlying error message varies in go 1.5 and go 1.6+.\n\n\tue, ok := v.Err.(*url.Error)\n\tif !ok {\n\t\tt.Errorf(\"expected error type to be \\\"*url.Error\\\", got %T\", v.Err)\n\t}\n\n\tif ue.Op != \"parse\" {\n\t\tt.Errorf(\"expected error op to be \\\"parse\\\", got %q\", ue.Op)\n\t}\n}\n\nfunc TestCheckDisallowedOnlyAllowed(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_DEBUG\", \"true\")\n\tos.Setenv(\"UNRELATED_ENV_VAR\", \"true\")\n\terr := CheckDisallowed(\"env_config\", &s)\n\tif err != nil {\n\t\tt.Errorf(\"expected no error, got %s\", err)\n\t}\n}\n\nfunc TestCheckDisallowedMispelled(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_DEBUG\", \"true\")\n\tos.Setenv(\"ENV_CONFIG_ZEBUG\", \"false\")\n\terr := CheckDisallowed(\"env_config\", &s)\n\tif experr := \"unknown environment variable ENV_CONFIG_ZEBUG\"; err.Error() != experr {\n\t\tt.Errorf(\"expected %s, got %s\", experr, err)\n\t}\n}\n\nfunc TestCheckDisallowedIgnored(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_DEBUG\", \"true\")\n\tos.Setenv(\"ENV_CONFIG_IGNORED\", \"false\")\n\terr := CheckDisallowed(\"env_config\", &s)\n\tif experr := \"unknown environment variable ENV_CONFIG_IGNORED\"; err.Error() != experr {\n\t\tt.Errorf(\"expected %s, got %s\", experr, err)\n\t}\n}\n\nfunc TestErrorMessageForRequiredAltVar(t *testing.T) {\n\tvar s struct {\n\t\tFoo string `envconfig:\"BAR\" required:\"true\"`\n\t}\n\n\tos.Clearenv()\n\terr := Process(\"env_config\", &s)\n\n\tif err == nil {\n\t\tt.Error(\"no failure when missing required variable\")\n\t}\n\n\tif !strings.Contains(err.Error(), \" BAR \") {\n\t\tt.Errorf(\"expected error message to contain BAR, got \\\"%v\\\"\", err)\n\t}\n}\n\ntype bracketed string\n\nfunc (b *bracketed) Set(value string) error {\n\t*b = bracketed(\"[\" + value + \"]\")\n\treturn nil\n}\n\nfunc (b bracketed) String() string {\n\treturn string(b)\n}\n\n// quoted is used to test the precedence of Decode over Set.\n// The sole field is a flag.Value rather than a setter to validate that\n// all flag.Value implementations are also Setter implementations.\ntype quoted struct{ flag.Value }\n\nfunc (d quoted) Decode(value string) error {\n\treturn d.Set(`\"` + value + `\"`)\n}\n\ntype setterStruct struct {\n\tInner string\n}\n\nfunc (ss *setterStruct) Set(value string) error {\n\tss.Inner = fmt.Sprintf(\"setterstruct{%q}\", value)\n\treturn nil\n}\n\nfunc BenchmarkGatherInfo(b *testing.B) {\n\tos.Clearenv()\n\tos.Setenv(\"ENV_CONFIG_DEBUG\", \"true\")\n\tos.Setenv(\"ENV_CONFIG_PORT\", \"8080\")\n\tos.Setenv(\"ENV_CONFIG_RATE\", \"0.5\")\n\tos.Setenv(\"ENV_CONFIG_USER\", \"Kelsey\")\n\tos.Setenv(\"ENV_CONFIG_TIMEOUT\", \"2m\")\n\tos.Setenv(\"ENV_CONFIG_ADMINUSERS\", \"John,Adam,Will\")\n\tos.Setenv(\"ENV_CONFIG_MAGICNUMBERS\", \"5,10,20\")\n\tos.Setenv(\"ENV_CONFIG_COLORCODES\", \"red:1,green:2,blue:3\")\n\tos.Setenv(\"SERVICE_HOST\", \"127.0.0.1\")\n\tos.Setenv(\"ENV_CONFIG_TTL\", \"30\")\n\tos.Setenv(\"ENV_CONFIG_REQUIREDVAR\", \"foo\")\n\tos.Setenv(\"ENV_CONFIG_IGNORED\", \"was-not-ignored\")\n\tos.Setenv(\"ENV_CONFIG_OUTER_INNER\", \"iamnested\")\n\tos.Setenv(\"ENV_CONFIG_AFTERNESTED\", \"after\")\n\tos.Setenv(\"ENV_CONFIG_HONOR\", \"honor\")\n\tos.Setenv(\"ENV_CONFIG_DATETIME\", \"2016-08-16T18:57:05Z\")\n\tos.Setenv(\"ENV_CONFIG_MULTI_WORD_VAR_WITH_AUTO_SPLIT\", \"24\")\n\tfor i := 0; i < b.N; i++ {\n\t\tvar s Specification\n\t\tgatherInfo(\"env_config\", &s)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.04296875,
          "content": "module github.com/kelseyhightower/envconfig\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "usage.go",
          "type": "blob",
          "size": 4.771484375,
          "content": "// Copyright (c) 2016 Kelsey Hightower and others. All rights reserved.\n// Use of this source code is governed by the MIT License that can be found in\n// the LICENSE file.\n\npackage envconfig\n\nimport (\n\t\"encoding\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"text/tabwriter\"\n\t\"text/template\"\n)\n\nconst (\n\t// DefaultListFormat constant to use to display usage in a list format\n\tDefaultListFormat = `This application is configured via the environment. The following environment\nvariables can be used:\n{{range .}}\n{{usage_key .}}\n  [description] {{usage_description .}}\n  [type]        {{usage_type .}}\n  [default]     {{usage_default .}}\n  [required]    {{usage_required .}}{{end}}\n`\n\t// DefaultTableFormat constant to use to display usage in a tabular format\n\tDefaultTableFormat = `This application is configured via the environment. The following environment\nvariables can be used:\n\nKEY\tTYPE\tDEFAULT\tREQUIRED\tDESCRIPTION\n{{range .}}{{usage_key .}}\t{{usage_type .}}\t{{usage_default .}}\t{{usage_required .}}\t{{usage_description .}}\n{{end}}`\n)\n\nvar (\n\tdecoderType           = reflect.TypeOf((*Decoder)(nil)).Elem()\n\tsetterType            = reflect.TypeOf((*Setter)(nil)).Elem()\n\ttextUnmarshalerType   = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()\n\tbinaryUnmarshalerType = reflect.TypeOf((*encoding.BinaryUnmarshaler)(nil)).Elem()\n)\n\nfunc implementsInterface(t reflect.Type) bool {\n\treturn t.Implements(decoderType) ||\n\t\treflect.PtrTo(t).Implements(decoderType) ||\n\t\tt.Implements(setterType) ||\n\t\treflect.PtrTo(t).Implements(setterType) ||\n\t\tt.Implements(textUnmarshalerType) ||\n\t\treflect.PtrTo(t).Implements(textUnmarshalerType) ||\n\t\tt.Implements(binaryUnmarshalerType) ||\n\t\treflect.PtrTo(t).Implements(binaryUnmarshalerType)\n}\n\n// toTypeDescription converts Go types into a human readable description\nfunc toTypeDescription(t reflect.Type) string {\n\tswitch t.Kind() {\n\tcase reflect.Array, reflect.Slice:\n\t\tif t.Elem().Kind() == reflect.Uint8 {\n\t\t\treturn \"String\"\n\t\t}\n\t\treturn fmt.Sprintf(\"Comma-separated list of %s\", toTypeDescription(t.Elem()))\n\tcase reflect.Map:\n\t\treturn fmt.Sprintf(\n\t\t\t\"Comma-separated list of %s:%s pairs\",\n\t\t\ttoTypeDescription(t.Key()),\n\t\t\ttoTypeDescription(t.Elem()),\n\t\t)\n\tcase reflect.Ptr:\n\t\treturn toTypeDescription(t.Elem())\n\tcase reflect.Struct:\n\t\tif implementsInterface(t) && t.Name() != \"\" {\n\t\t\treturn t.Name()\n\t\t}\n\t\treturn \"\"\n\tcase reflect.String:\n\t\tname := t.Name()\n\t\tif name != \"\" && name != \"string\" {\n\t\t\treturn name\n\t\t}\n\t\treturn \"String\"\n\tcase reflect.Bool:\n\t\tname := t.Name()\n\t\tif name != \"\" && name != \"bool\" {\n\t\t\treturn name\n\t\t}\n\t\treturn \"True or False\"\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tname := t.Name()\n\t\tif name != \"\" && !strings.HasPrefix(name, \"int\") {\n\t\t\treturn name\n\t\t}\n\t\treturn \"Integer\"\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tname := t.Name()\n\t\tif name != \"\" && !strings.HasPrefix(name, \"uint\") {\n\t\t\treturn name\n\t\t}\n\t\treturn \"Unsigned Integer\"\n\tcase reflect.Float32, reflect.Float64:\n\t\tname := t.Name()\n\t\tif name != \"\" && !strings.HasPrefix(name, \"float\") {\n\t\t\treturn name\n\t\t}\n\t\treturn \"Float\"\n\t}\n\treturn fmt.Sprintf(\"%+v\", t)\n}\n\n// Usage writes usage information to stdout using the default header and table format\nfunc Usage(prefix string, spec interface{}) error {\n\t// The default is to output the usage information as a table\n\t// Create tabwriter instance to support table output\n\ttabs := tabwriter.NewWriter(os.Stdout, 1, 0, 4, ' ', 0)\n\n\terr := Usagef(prefix, spec, tabs, DefaultTableFormat)\n\ttabs.Flush()\n\treturn err\n}\n\n// Usagef writes usage information to the specified io.Writer using the specified template specification\nfunc Usagef(prefix string, spec interface{}, out io.Writer, format string) error {\n\n\t// Specify the default usage template functions\n\tfunctions := template.FuncMap{\n\t\t\"usage_key\":         func(v varInfo) string { return v.Key },\n\t\t\"usage_description\": func(v varInfo) string { return v.Tags.Get(\"desc\") },\n\t\t\"usage_type\":        func(v varInfo) string { return toTypeDescription(v.Field.Type()) },\n\t\t\"usage_default\":     func(v varInfo) string { return v.Tags.Get(\"default\") },\n\t\t\"usage_required\": func(v varInfo) (string, error) {\n\t\t\treq := v.Tags.Get(\"required\")\n\t\t\tif req != \"\" {\n\t\t\t\treqB, err := strconv.ParseBool(req)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn \"\", err\n\t\t\t\t}\n\t\t\t\tif reqB {\n\t\t\t\t\treq = \"true\"\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn req, nil\n\t\t},\n\t}\n\n\ttmpl, err := template.New(\"envconfig\").Funcs(functions).Parse(format)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn Usaget(prefix, spec, out, tmpl)\n}\n\n// Usaget writes usage information to the specified io.Writer using the specified template\nfunc Usaget(prefix string, spec interface{}, out io.Writer, tmpl *template.Template) error {\n\t// gather first\n\tinfos, err := gatherInfo(prefix, spec)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn tmpl.Execute(out, infos)\n}\n"
        },
        {
          "name": "usage_test.go",
          "type": "blob",
          "size": 3.705078125,
          "content": "// Copyright (c) 2016 Kelsey Hightower and others. All rights reserved.\n// Use of this source code is governed by the MIT License that can be found in\n// the LICENSE file.\n\npackage envconfig\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"text/tabwriter\"\n)\n\nvar testUsageTableResult, testUsageListResult, testUsageCustomResult, testUsageBadFormatResult string\n\nfunc TestMain(m *testing.M) {\n\n\t// Load the expected test results from a text file\n\tdata, err := ioutil.ReadFile(\"testdata/default_table.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\ttestUsageTableResult = string(data)\n\n\tdata, err = ioutil.ReadFile(\"testdata/default_list.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\ttestUsageListResult = string(data)\n\n\tdata, err = ioutil.ReadFile(\"testdata/custom.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\ttestUsageCustomResult = string(data)\n\n\tdata, err = ioutil.ReadFile(\"testdata/fault.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\ttestUsageBadFormatResult = string(data)\n\n\tretCode := m.Run()\n\tos.Exit(retCode)\n}\n\nfunc compareUsage(want, got string, t *testing.T) {\n\tgot = strings.ReplaceAll(got, \" \", \".\")\n\tif want != got {\n\t\tshortest := len(want)\n\t\tif len(got) < shortest {\n\t\t\tshortest = len(got)\n\t\t}\n\t\tif len(want) != len(got) {\n\t\t\tt.Errorf(\"expected result length of %d, found %d\", len(want), len(got))\n\t\t}\n\t\tfor i := 0; i < shortest; i++ {\n\t\t\tif want[i] != got[i] {\n\t\t\t\tt.Errorf(\"difference at index %d, expected '%c' (%v), found '%c' (%v)\\n\",\n\t\t\t\t\ti, want[i], want[i], got[i], got[i])\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tt.Errorf(\"Complete Expected:\\n'%s'\\nComplete Found:\\n'%s'\\n\", want, got)\n\t}\n}\n\nfunc TestUsageDefault(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tsave := os.Stdout\n\tr, w, _ := os.Pipe()\n\tos.Stdout = w\n\terr := Usage(\"env_config\", &s)\n\toutC := make(chan string)\n\t// copy the output in a separate goroutine so printing can't block indefinitely\n\tgo func() {\n\t\tvar buf bytes.Buffer\n\t\tio.Copy(&buf, r)\n\t\toutC <- buf.String()\n\t}()\n\tw.Close()\n\tos.Stdout = save // restoring the real stdout\n\tout := <-outC\n\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tcompareUsage(testUsageTableResult, out, t)\n}\n\nfunc TestUsageTable(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tbuf := new(bytes.Buffer)\n\ttabs := tabwriter.NewWriter(buf, 1, 0, 4, ' ', 0)\n\terr := Usagef(\"env_config\", &s, tabs, DefaultTableFormat)\n\ttabs.Flush()\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tcompareUsage(testUsageTableResult, buf.String(), t)\n}\n\nfunc TestUsageList(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tbuf := new(bytes.Buffer)\n\terr := Usagef(\"env_config\", &s, buf, DefaultListFormat)\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tcompareUsage(testUsageListResult, buf.String(), t)\n}\n\nfunc TestUsageCustomFormat(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\tbuf := new(bytes.Buffer)\n\terr := Usagef(\"env_config\", &s, buf, \"{{range .}}{{usage_key .}}={{usage_description .}}\\n{{end}}\")\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tcompareUsage(testUsageCustomResult, buf.String(), t)\n}\n\nfunc TestUsageUnknownKeyFormat(t *testing.T) {\n\tvar s Specification\n\tunknownError := \"template: envconfig:1:2: executing \\\"envconfig\\\" at <.UnknownKey>\"\n\tos.Clearenv()\n\tbuf := new(bytes.Buffer)\n\terr := Usagef(\"env_config\", &s, buf, \"{{.UnknownKey}}\")\n\tif err == nil {\n\t\tt.Errorf(\"expected 'unknown key' error, but got no error\")\n\t}\n\tif !strings.Contains(err.Error(), unknownError) {\n\t\tt.Errorf(\"expected '%s', but got '%s'\", unknownError, err.Error())\n\t}\n}\n\nfunc TestUsageBadFormat(t *testing.T) {\n\tvar s Specification\n\tos.Clearenv()\n\t// If you don't use two {{}} then you get a lieteral\n\tbuf := new(bytes.Buffer)\n\terr := Usagef(\"env_config\", &s, buf, \"{{range .}}{.Key}\\n{{end}}\")\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tcompareUsage(testUsageBadFormatResult, buf.String(), t)\n}\n"
        }
      ]
    }
  ]
}