{
  "metadata": {
    "timestamp": 1736567693942,
    "page": 276,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ondrajz/go-callvis",
      "stars": 6036,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.37890625,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Builds\n/.build/\ngo-callvis\n\n# IDE\n/.idea/\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0439453125,
          "content": "MIT License\n\nCopyright (c) 2017 Ondrej Fabry\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.9453125,
          "content": "SHELL := /usr/bin/env bash -o pipefail\n\nGIT_VERSION ?= $(shell git describe --always --tags --match 'v*' --dirty)\nCOMMIT     ?= $(shell git rev-parse HEAD)\nBRANCH     ?= $(shell git rev-parse --abbrev-ref HEAD)\nBUILD_DATE ?= $(shell date +%s)\nBUILD_HOST ?= $(shell hostname)\nBUILD_USER ?= $(shell id -un)\n\nPROJECT := go-callvis\nBUILD_DIR ?= .build\n\nGOOS ?= $(shell go env GOOS)\nGOARCH = amd64\nPLATFORMS := linux-$(GOARCH) darwin-$(GOARCH)\n\nGO_BUILD_TAGS ?= \"\"\nGO_LDFLAGS := \\\n\t-X main.commit=$(GIT_VERSION)\nGO_FILES := $(shell go list ./... | xargs go list -f '{{ range $$file := .GoFiles }} {{$$.Dir}}/{{$$file}}{{\"\\n\"}}{{end}}')\n\nifeq ($(NOSTRIP),)\nGO_LDFLAGS += -w -s\nendif\n\nifeq ($(NOTRIM),)\nGO_BUILD_ARGS += -trimpath\nendif\n\nifeq ($(V),1)\nGO_BUILD_ARGS += -v\nendif\n\nexport GO111MODULE=on\nexport DOCKER_BUILDKIT=1\n\nhelp:\n\t@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = \":.*?## \"}; {printf \"\\033[36m%-30s\\033[0m %s\\n\", $$1, $$2}'\n\nbuild:  ## Build go-callvis\n\tgo build -v -tags $(GO_BUILD_TAGS) -ldflags \"$(GO_LDFLAGS)\" $(GO_BUILD_ARGS)\n\ntest:  ## Run unit tests\n\tgo test -tags $(GO_BUILD_TAGS) -ldflags \"$(GO_LDFLAGS)\" $(GO_BUILD_ARGS) -short -race ./...\n\ninstall:  ## Install go-callvis\n\tgo install -tags $(GO_BUILD_TAGS) -ldflags \"$(GO_LDFLAGS)\" $(GO_BUILD_ARGS)\n\n$(BUILD_DIR)/$(PROJECT): $(BUILD_DIR)/$(PROJECT)-$(GOOS)-$(GOARCH)\n\tcp $(BUILD_DIR)/$(PROJECT)-$(GOOS)-$(GOARCH) $@\n\n$(BUILD_DIR)/$(PROJECT)-%-$(GOARCH): $(GO_FILES) $(BUILD_DIR)\n\tGOOS=$* GOARCH=$(GOARCH) go build -tags $(GO_BUILD_TAGS) -ldflags \"$(GO_LDFLAGS)\" -o $@ $(GO_BUILD_ARGS)\n\n%.sha256: %\n\tshasum -a 256 $< &> $@\n\n$(BUILD_DIR):\n\tmkdir -p $(BUILD_DIR)\n\n.PRECIOUS: $(foreach platform, $(PLATFORMS), $(BUILD_DIR)/$(PROJECT)-$(platform))\n\ncross: $(foreach platform, $(PLATFORMS), $(BUILD_DIR)/$(PROJECT)-$(platform).sha256)\n\nrelease: cross  ## Release go-callvis\n\tls -hl $(BUILD_DIR)\n\nclean:  ## Clean build directory\n\trm -vrf $(BUILD_DIR)\n\n.PHONY: help build test install cross release clean\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.982421875,
          "content": "<p align=\"center\"><img src=\"images/gopher.png\" alt=\"gopher\"></p>\n\n<h1 align=\"center\">go-callvis</h1>\n\n<p align=\"center\">\n  <a href=\"https://github.com/ondrajz/go-callvis/releases\"><img src=\"https://img.shields.io/github/release/ondrajz/go-callvis.svg?label=latest%20release&logo=github&sort=semver&color=blue\" alt=\"Github release\"></a>\n  <a href=\"https://github.com/ondrajz/go-callvis/actions\"><img src=\"https://github.com/ondrajz/go-callvis/actions/workflows/ci.yml/badge.svg\" alt=\"Build status\"></a>\n  <a href=\"https://github.com/nikolaydubina/go-recipes\"><img src=\"https://raw.githubusercontent.com/nikolaydubina/go-recipes/main/badge.svg?raw=true\" alt=\"go-recipes\"></a>\n  <a href=\"https://gophers.slack.com/archives/go-callvis\"><img src=\"https://img.shields.io/badge/gophers%20slack-%23go--callvis-ff69b4.svg\" alt=\"Slack channel\"></a>\n</p>\n\n<p align=\"center\"><b>go-callvis</b> is a development tool to help visualize call graph of a Go program using interactive view.</p>\n\n---\n\n## Introduction\n\nThe purpose of this tool is to provide developers with a visual overview of a Go program using data from call graph \nand its relations with packages and types. This is especially useful in larger projects where the complexity of \nthe code much higher or when you are just simply trying to understand code of somebody else.\n\n### Features\n\n- click on package to quickly switch the focus using [interactive viewer](#interactive-viewer)\n- focus specific package in the program\n- group functions by package\n- group methods by their receiver type\n- filter packages to specific import path prefixes\n- ignore calls to/from standard library\n- omit various types of function calls\n\n### Output preview\n\n[![main](images/main.png)](images/main.png)\n\n> Check out the [source code](examples/main) for the above image.\n\n### How it works\n\nIt runs [pointer analysis](https://godoc.org/golang.org/x/tools/go/pointer) to construct the call graph of the program and \nuses the data to generate output in [dot format](http://www.graphviz.org/content/dot-language), which can be rendered with Graphviz tools.\n\n## Quick start\n\n### Installation\n\n#### Requirements\n\n- [Go](https://golang.org/dl/) 1.19+\n- [Graphviz](http://www.graphviz.org/download/) (optional, required only with `-graphviz` flag)\n\nTo install go-callvis, run:\n\n```sh\n# Latest release\ngo install github.com/ofabry/go-callvis@latest\n\n# Development version\ngo install github.com/ofabry/go-callvis@master\n```\n\nAlternatively, clone the repository and compile the source code:\n\n```sh\n# Clone repository\ngit clone https://github.com/ofabry/go-callvis.git\ncd go-callvis\n\n# Compile and install\nmake install\n```\n\n### Usage\n\n#### Interactive viewer\n\nTo use the interactive view provided by a web server that serves SVG images of focused packages, you can simply run:\n\n`go-callvis <target package>` \n\nHTTP server is listening on [http://localhost:7878/](http://localhost:7878/) by default, use option `-http=\"ADDR:PORT\"` to change HTTP server address.\n\n#### Render static output\n\nTo generate a single output file use option `-file=<file path>` to choose output file destination.\n\nThe output format defaults to `svg`, use option `-format=<svg|png|jpg|...>` to pick a different output format.\n\n#### Options\n\n```\nUsage of go-callvis:\n  -debug\n    \tEnable verbose log.\n  -file string\n    \toutput filename - omit to use server mode\n  -cacheDir string\n    \tEnable caching to avoid unnecessary re-rendering.\n  -focus string\n    \tFocus specific package using name or import path. (default \"main\")\n  -format string\n    \toutput file format [svg | png | jpg | ...] (default \"svg\")\n  -graphviz\n    \tUse Graphviz's dot program to render images.\n  -group string\n    \tGrouping functions by packages and/or types [pkg, type] (separated by comma) (default \"pkg\")\n  -http string\n    \tHTTP service address. (default \":7878\")\n  -ignore string\n    \tIgnore package paths containing given prefixes (separated by comma)\n  -include string\n    \tInclude package paths with given prefixes (separated by comma)\n  -limit string\n    \tLimit package paths to given prefixes (separated by comma)\n  -minlen uint\n    \tMinimum edge length (for wider output). (default 2)\n  -nodesep float\n    \tMinimum space between two adjacent nodes in the same rank (for taller output). (default 0.35)\n  -nointer\n    \tOmit calls to unexported functions.\n  -nostd\n    \tOmit calls to/from packages in standard library.\n  -rankdir\n        Direction of graph layout [LR | RL | TB | BT] (default \"LR\")\n  -skipbrowser\n    \tSkip opening browser.\n  -tags build tags\n    \ta list of build tags to consider satisfied during the build. For more information about build tags, see the description of build constraints in the documentation for the go/build package\n  -tests\n    \tInclude test code.\n  -algo string\n        Use specific algorithm for package analyzer: static, cha or rta (default \"static\")\n  -version\n    \tShow version and exit.\n```\n\nRun `go-callvis -h` to list all supported options.\n\n## Reference guide\n\nHere you can find descriptions for various types of output.\n\n### Packages / Types\n\n|Represents  | Style|\n|----------: | :-------------|\n|`focused`   | **blue** color|\n|`stdlib`    | **green** color|\n|`other`     | **yellow** color|\n\n### Functions / Methods\n\n|Represents   | Style|\n|-----------: | :--------------|\n|`exported`   | **bold** border|\n|`unexported` | **normal** border|\n|`anonymous`  | **dotted** border|\n\n### Calls\n\n|Represents   | Style|\n|-----------: | :-------------|\n|`internal`   | **black** color|\n|`external`   | **brown** color|\n|`static`     | **solid** line|\n|`dynamic`    | **dashed** line|\n|`regular`    | **simple** arrow|\n|`concurrent` | arrow with **circle**|\n|`deferred`   | arrow with **diamond**|\n\n## Examples\n\nHere is an example for the project [syncthing](https://github.com/syncthing/syncthing).\n\n[![syncthing example](images/syncthing.png)](https://raw.githubusercontent.com/ondrajz/go-callvis/master/images/syncthing.png)\n\n> Check out [more examples](examples) and used command options.\n\n## Community\n\nJoin [#go-callvis](https://gophers.slack.com/archives/go-callvis) channel at [gophers.slack.com](http://gophers.slack.com). (*not a member yet?* [get invitation](https://gophersinvite.herokuapp.com))\n\n### How to help\n\nDid you find any bugs or have some suggestions?\n- Feel free to open [new issue](https://github.com/ondrajz/go-callvis/issues/new) or start discussion in the slack channel.\n\nDo you want to contribute to the project?\n- Fork the repository and open a pull request. [Here](https://github.com/ondrajz/go-callvis/projects/1) you can find TODO features.\n\n---\n\n#### Roadmap\n\n##### The *interactive tool* described below has been published as a *separate project* called [goexplorer](https://github.com/ondrajz/goexplorer)!\n\n> Ideal goal of this project is to make web app that would locally store the call graph data and then provide quick access of the call graphs for any package of your dependency tree. At first it would show an interactive map of overall dependencies between packages and then by selecting particular package it would show the call graph and provide various options to alter the output dynamically.\n"
        },
        {
          "name": "_config.yml",
          "type": "blob",
          "size": 0.0263671875,
          "content": "theme: jekyll-theme-minimal"
        },
        {
          "name": "analysis.go",
          "type": "blob",
          "size": 8.9140625,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"go/build\"\n\t\"go/types\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\t\"golang.org/x/tools/go/callgraph\"\n\t\"golang.org/x/tools/go/callgraph/cha\"\n\t\"golang.org/x/tools/go/callgraph/rta\"\n\t\"golang.org/x/tools/go/callgraph/static\"\n\n\t\"golang.org/x/tools/go/packages\"\n\t\"golang.org/x/tools/go/ssa\"\n\t\"golang.org/x/tools/go/ssa/ssautil\"\n)\n\ntype CallGraphType string\n\nconst (\n\tCallGraphTypeStatic CallGraphType = \"static\"\n\tCallGraphTypeCha    CallGraphType = \"cha\"\n\tCallGraphTypeRta    CallGraphType = \"rta\"\n)\n\n// ==[ type def/func: analysis   ]===============================================\ntype renderOpts struct {\n\tcacheDir string\n\tfocus    string\n\tgroup    []string\n\tignore   []string\n\tinclude  []string\n\tlimit    []string\n\tnointer  bool\n\trefresh  bool\n\tnostd    bool\n\talgo     CallGraphType\n}\n\n// mainPackages returns the main packages to analyze.\n// Each resulting package is named \"main\" and has a main function.\nfunc mainPackages(pkgs []*ssa.Package) ([]*ssa.Package, error) {\n\tvar mains []*ssa.Package\n\tfor _, p := range pkgs {\n\t\tif p != nil && p.Pkg.Name() == \"main\" && p.Func(\"main\") != nil {\n\t\t\tmains = append(mains, p)\n\t\t}\n\t}\n\tif len(mains) == 0 {\n\t\treturn nil, fmt.Errorf(\"no main packages\")\n\t}\n\treturn mains, nil\n}\n\n// initFuncs returns all package init functions\nfunc initFuncs(pkgs []*ssa.Package) ([]*ssa.Function, error) {\n\tvar inits []*ssa.Function\n\tfor _, p := range pkgs {\n\t\tif p == nil {\n\t\t\tcontinue\n\t\t}\n\t\tfor name, member := range p.Members {\n\t\t\tfun, ok := member.(*ssa.Function)\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif name == \"init\" || strings.HasPrefix(name, \"init#\") {\n\t\t\t\tinits = append(inits, fun)\n\t\t\t}\n\t\t}\n\t}\n\treturn inits, nil\n}\n\n// ==[ type def/func: analysis   ]===============================================\ntype analysis struct {\n\topts      *renderOpts\n\tprog      *ssa.Program\n\tpkgs      []*ssa.Package\n\tmainPkg   *ssa.Package\n\tcallgraph *callgraph.Graph\n}\n\nvar Analysis *analysis\n\nfunc (a *analysis) DoAnalysis(\n\talgo CallGraphType,\n\tdir string,\n\ttests bool,\n\targs []string,\n) error {\n\tlogf(\"begin analysis\")\n\tdefer logf(\"analysis done\")\n\n\tcfg := &packages.Config{\n\t\tMode:       packages.LoadAllSyntax,\n\t\tTests:      tests,\n\t\tDir:        dir,\n\t\tBuildFlags: getBuildFlags(),\n\t}\n\n\tlogf(\"loading packages\")\n\n\tinitial, err := packages.Load(cfg, args...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif packages.PrintErrors(initial) > 0 {\n\t\treturn fmt.Errorf(\"packages contain errors\")\n\t}\n\n\tlogf(\"loaded %d initial packages, building program\", len(initial))\n\n\t// Create and build SSA-form program representation.\n\tmode := ssa.InstantiateGenerics\n\tprog, pkgs := ssautil.AllPackages(initial, mode)\n\tprog.Build()\n\n\tlogf(\"build done, computing callgraph (algo: %v)\", algo)\n\n\tvar graph *callgraph.Graph\n\tvar mainPkg *ssa.Package\n\n\tswitch algo {\n\tcase CallGraphTypeStatic:\n\t\tgraph = static.CallGraph(prog)\n\tcase CallGraphTypeCha:\n\t\tgraph = cha.CallGraph(prog)\n\tcase CallGraphTypeRta:\n\t\tmains, err := mainPackages(prog.AllPackages())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar roots []*ssa.Function\n\t\tmainPkg = mains[0]\n\t\tfor _, main := range mains {\n\t\t\troots = append(roots, main.Func(\"main\"))\n\t\t}\n\n\t\tinits, err := initFuncs(prog.AllPackages())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor _, init := range inits {\n\t\t\troots = append(roots, init)\n\t\t}\n\n\t\tgraph = rta.Analyze(roots, true).CallGraph\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid call graph type: %s\", a.opts.algo)\n\t}\n\n\tlogf(\"callgraph resolved with %d nodes\", len(graph.Nodes))\n\n\ta.prog = prog\n\ta.pkgs = pkgs\n\ta.mainPkg = mainPkg\n\ta.callgraph = graph\n\treturn nil\n}\n\nfunc (a *analysis) OptsSetup() {\n\ta.opts = &renderOpts{\n\t\tcacheDir: *cacheDir,\n\t\tfocus:    *focusFlag,\n\t\tgroup:    []string{*groupFlag},\n\t\tignore:   []string{*ignoreFlag},\n\t\tinclude:  []string{*includeFlag},\n\t\tlimit:    []string{*limitFlag},\n\t\tnointer:  *nointerFlag,\n\t\tnostd:    *nostdFlag,\n\t}\n}\n\nfunc (a *analysis) ProcessListArgs() (e error) {\n\tvar groupBy []string\n\tvar ignorePaths []string\n\tvar includePaths []string\n\tvar limitPaths []string\n\n\tfor _, g := range strings.Split(a.opts.group[0], \",\") {\n\t\tg := strings.TrimSpace(g)\n\t\tif g == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tif g != \"pkg\" && g != \"type\" {\n\t\t\te = errors.New(\"invalid group option\")\n\t\t\treturn\n\t\t}\n\t\tgroupBy = append(groupBy, g)\n\t}\n\n\tfor _, p := range strings.Split(a.opts.ignore[0], \",\") {\n\t\tp = strings.TrimSpace(p)\n\t\tif p != \"\" {\n\t\t\tignorePaths = append(ignorePaths, p)\n\t\t}\n\t}\n\n\tfor _, p := range strings.Split(a.opts.include[0], \",\") {\n\t\tp = strings.TrimSpace(p)\n\t\tif p != \"\" {\n\t\t\tincludePaths = append(includePaths, p)\n\t\t}\n\t}\n\n\tfor _, p := range strings.Split(a.opts.limit[0], \",\") {\n\t\tp = strings.TrimSpace(p)\n\t\tif p != \"\" {\n\t\t\tlimitPaths = append(limitPaths, p)\n\t\t}\n\t}\n\n\ta.opts.group = groupBy\n\ta.opts.ignore = ignorePaths\n\ta.opts.include = includePaths\n\ta.opts.limit = limitPaths\n\n\treturn\n}\n\nfunc (a *analysis) OverrideByHTTP(r *http.Request) {\n\tif f := r.FormValue(\"f\"); f == \"all\" {\n\t\ta.opts.focus = \"\"\n\t} else if f != \"\" {\n\t\ta.opts.focus = f\n\t}\n\tif std := r.FormValue(\"std\"); std != \"\" {\n\t\ta.opts.nostd = false\n\t}\n\tif inter := r.FormValue(\"nointer\"); inter != \"\" {\n\t\ta.opts.nointer = true\n\t}\n\tif refresh := r.FormValue(\"refresh\"); refresh != \"\" {\n\t\ta.opts.refresh = true\n\t}\n\tif g := r.FormValue(\"group\"); g != \"\" {\n\t\ta.opts.group[0] = g\n\t}\n\tif l := r.FormValue(\"limit\"); l != \"\" {\n\t\ta.opts.limit[0] = l\n\t}\n\tif ign := r.FormValue(\"ignore\"); ign != \"\" {\n\t\ta.opts.ignore[0] = ign\n\t}\n\tif inc := r.FormValue(\"include\"); inc != \"\" {\n\t\ta.opts.include[0] = inc\n\t}\n\treturn\n}\n\n// basically do printOutput() with previously checking\n// focus option and respective package\nfunc (a *analysis) Render() ([]byte, error) {\n\tvar (\n\t\terr      error\n\t\tssaPkg   *ssa.Package\n\t\tfocusPkg *types.Package\n\t)\n\n\tstart := time.Now()\n\tlogf(\"begin rendering\")\n\n\tif a.opts.focus != \"\" {\n\t\tif ssaPkg = a.prog.ImportedPackage(a.opts.focus); ssaPkg == nil {\n\t\t\tif strings.Contains(a.opts.focus, \"/\") {\n\t\t\t\treturn nil, fmt.Errorf(\"focus failed: %v\", err)\n\t\t\t}\n\t\t\t// try to find package by name\n\t\t\tvar foundPaths []string\n\t\t\tfor _, p := range a.pkgs {\n\t\t\t\tif p.Pkg.Name() == a.opts.focus {\n\t\t\t\t\tfoundPaths = append(foundPaths, p.Pkg.Path())\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(foundPaths) == 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"focus failed, could not find package: %v\", a.opts.focus)\n\t\t\t} else if len(foundPaths) > 1 {\n\t\t\t\tfor _, p := range foundPaths {\n\t\t\t\t\tfmt.Fprintf(os.Stderr, \" - %s\\n\", p)\n\t\t\t\t}\n\t\t\t\treturn nil, fmt.Errorf(\"focus failed, found multiple packages with name: %v\", a.opts.focus)\n\t\t\t}\n\t\t\t// found single package\n\t\t\tif ssaPkg = a.prog.ImportedPackage(foundPaths[0]); ssaPkg == nil {\n\t\t\t\treturn nil, fmt.Errorf(\"focus failed: %v\", err)\n\t\t\t}\n\t\t}\n\t\tfocusPkg = ssaPkg.Pkg\n\t\tlogf(\"focusing package: %v (path: %v)\", focusPkg.Name(), focusPkg.Path())\n\t}\n\n\tdot, err := printOutput(\n\t\ta.prog,\n\t\ta.mainPkg,\n\t\ta.callgraph,\n\t\tfocusPkg,\n\t\ta.opts.limit,\n\t\ta.opts.ignore,\n\t\ta.opts.include,\n\t\ta.opts.group,\n\t\ta.opts.nostd,\n\t\ta.opts.nointer,\n\t)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"processing failed: %v\", err)\n\t}\n\n\tlogf(\"rendering done (took %v sec)\", time.Since(start).Round(time.Millisecond).Seconds())\n\n\treturn dot, nil\n}\n\nfunc (a *analysis) FindCachedImg() string {\n\tif a.opts.cacheDir == \"\" || a.opts.refresh {\n\t\treturn \"\"\n\t}\n\n\tfocus := a.opts.focus\n\tif focus == \"\" {\n\t\tfocus = \"all\"\n\t}\n\tfocusFilePath := focus + \".\" + *outputFormat\n\tabsFilePath := filepath.Join(a.opts.cacheDir, focusFilePath)\n\n\tif exists, err := pathExists(absFilePath); err != nil || !exists {\n\t\tlog.Println(\"not cached img:\", absFilePath)\n\t\treturn \"\"\n\t}\n\n\tlog.Println(\"hit cached img\")\n\treturn absFilePath\n}\n\nfunc (a *analysis) CacheImg(img string) error {\n\tif a.opts.cacheDir == \"\" || img == \"\" {\n\t\treturn nil\n\t}\n\n\tfocus := a.opts.focus\n\tif focus == \"\" {\n\t\tfocus = \"all\"\n\t}\n\tabsCacheDirPrefix := filepath.Join(a.opts.cacheDir, focus)\n\tabsCacheDirPath := strings.TrimRightFunc(absCacheDirPrefix, func(r rune) bool {\n\t\treturn r != '\\\\' && r != '/'\n\t})\n\terr := os.MkdirAll(absCacheDirPath, os.ModePerm)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tabsFilePath := absCacheDirPrefix + \".\" + *outputFormat\n\t_, err = copyFile(img, absFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc pathExists(path string) (bool, error) {\n\t_, err := os.Stat(path)\n\tif err == nil {\n\t\treturn true, nil\n\t}\n\tif os.IsNotExist(err) {\n\t\treturn false, nil\n\t}\n\treturn false, err\n}\n\nfunc copyFile(src, dst string) (int64, error) {\n\tsourceFileStat, err := os.Stat(src)\n\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tif !sourceFileStat.Mode().IsRegular() {\n\t\treturn 0, fmt.Errorf(\"%s is not a regular file\", src)\n\t}\n\n\tsource, err := os.Open(src)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer source.Close()\n\n\tdestination, err := os.Create(dst)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer destination.Close()\n\tnBytes, err := io.Copy(destination, source)\n\treturn nBytes, err\n}\n\nfunc getBuildFlags() []string {\n\tbuildFlagTags := getBuildFlagTags(build.Default.BuildTags)\n\tif len(buildFlagTags) == 0 {\n\t\treturn nil\n\t}\n\n\treturn []string{buildFlagTags}\n}\n\nfunc getBuildFlagTags(buildTags []string) string {\n\tif len(buildTags) > 0 {\n\t\treturn \"-tags=\" + strings.Join(buildTags, \",\")\n\t}\n\n\treturn \"\"\n}\n"
        },
        {
          "name": "dot.go",
          "type": "blob",
          "size": 4.1552734375,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"text/template\"\n)\n\nvar (\n\tminlen    uint\n\tnodesep   float64\n\tnodeshape string\n\tnodestyle string\n\trankdir   string\n)\n\nconst tmplCluster = `{{define \"cluster\" -}}\n    {{printf \"subgraph %q {\" .}}\n        {{printf \"%s\" .Attrs.Lines}}\n        {{range .Nodes}}\n        {{template \"node\" .}}\n        {{- end}}\n        {{range .Clusters}}\n        {{template \"cluster\" .}}\n        {{- end}}\n    {{println \"}\" }}\n{{- end}}`\n\nconst tmplNode = `{{define \"edge\" -}}\n    {{printf \"%q -> %q [ %s ]\" .From .To .Attrs}}\n{{- end}}`\n\nconst tmplEdge = `{{define \"node\" -}}\n    {{printf \"%q [ %s ]\" .ID .Attrs}}\n{{- end}}`\n\nconst tmplGraph = `digraph gocallvis {\n    label=\"{{.Title}}\";\n    labeljust=\"l\";\n    fontname=\"Arial\";\n    fontsize=\"14\";\n    rankdir=\"{{.Options.rankdir}}\";\n    bgcolor=\"lightgray\";\n    style=\"solid\";\n    penwidth=\"0.5\";\n    pad=\"0.0\";\n    nodesep=\"{{.Options.nodesep}}\";\n\n    node [shape=\"{{.Options.nodeshape}}\" style=\"{{.Options.nodestyle}}\" fillcolor=\"honeydew\" fontname=\"Verdana\" penwidth=\"1.0\" margin=\"0.16,0.0\"];\n    edge [minlen=\"{{.Options.minlen}}\"]\n\n    {{template \"cluster\" .Cluster}}\n\n    {{- range .Edges}}\n    {{template \"edge\" .}}\n    {{- end}}\n}\n`\n\n// ==[ type def/func: dotCluster ]===============================================\ntype dotCluster struct {\n\tID       string\n\tClusters map[string]*dotCluster\n\tNodes    []*dotNode\n\tAttrs    dotAttrs\n}\n\nfunc NewDotCluster(id string) *dotCluster {\n\treturn &dotCluster{\n\t\tID:       id,\n\t\tClusters: make(map[string]*dotCluster),\n\t\tAttrs:    make(dotAttrs),\n\t}\n}\n\nfunc (c *dotCluster) String() string {\n\treturn fmt.Sprintf(\"cluster_%s\", c.ID)\n}\n\n// ==[ type def/func: dotNode    ]===============================================\ntype dotNode struct {\n\tID    string\n\tAttrs dotAttrs\n}\n\nfunc (n *dotNode) String() string {\n\treturn n.ID\n}\n\n// ==[ type def/func: dotEdge    ]===============================================\ntype dotEdge struct {\n\tFrom  *dotNode\n\tTo    *dotNode\n\tAttrs dotAttrs\n}\n\n// ==[ type def/func: dotAttrs   ]===============================================\ntype dotAttrs map[string]string\n\nfunc (p dotAttrs) List() []string {\n\tl := []string{}\n\tfor k, v := range p {\n\t\tl = append(l, fmt.Sprintf(\"%s=%q\", k, v))\n\t}\n\treturn l\n}\n\nfunc (p dotAttrs) String() string {\n\treturn strings.Join(p.List(), \" \")\n}\n\nfunc (p dotAttrs) Lines() string {\n\treturn fmt.Sprintf(\"%s;\", strings.Join(p.List(), \";\\n\"))\n}\n\n// ==[ type def/func: dotGraph   ]===============================================\ntype dotGraph struct {\n\tTitle   string\n\tMinlen  uint\n\tAttrs   dotAttrs\n\tCluster *dotCluster\n\tNodes   []*dotNode\n\tEdges   []*dotEdge\n\tOptions map[string]string\n}\n\nfunc (g *dotGraph) WriteDot(w io.Writer) error {\n\tt := template.New(\"dot\")\n\tfor _, s := range []string{tmplCluster, tmplNode, tmplEdge, tmplGraph} {\n\t\tif _, err := t.Parse(s); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tvar buf bytes.Buffer\n\tif err := t.Execute(&buf, g); err != nil {\n\t\treturn err\n\t}\n\t_, err := buf.WriteTo(w)\n\treturn err\n}\n\nfunc dotToImage(outfname string, format string, dot []byte) (string, error) {\n\tif *graphvizFlag {\n\t\treturn runDotToImageCallSystemGraphviz(outfname, format, dot)\n\t}\n\n\treturn runDotToImage(outfname, format, dot)\n}\n\n// location of dot executable for converting from .dot to .svg\n// it's usually at: /usr/bin/dot\nvar dotSystemBinary string\n\n// runDotToImageCallSystemGraphviz generates a SVG using the 'dot' utility, returning the filepath\nfunc runDotToImageCallSystemGraphviz(outfname string, format string, dot []byte) (string, error) {\n\tif dotSystemBinary == \"\" {\n\t\tdot, err := exec.LookPath(\"dot\")\n\t\tif err != nil {\n\t\t\tlog.Fatalln(\"unable to find program 'dot', please install it or check your PATH\")\n\t\t}\n\t\tdotSystemBinary = dot\n\t}\n\n\tvar img string\n\tif outfname == \"\" {\n\t\timg = filepath.Join(os.TempDir(), fmt.Sprintf(\"go-callvis_export.%s\", format))\n\t} else {\n\t\timg = fmt.Sprintf(\"%s.%s\", outfname, format)\n\t}\n\tcmd := exec.Command(dotSystemBinary, fmt.Sprintf(\"-T%s\", format), \"-o\", img)\n\tcmd.Stdin = bytes.NewReader(dot)\n\tvar stderr bytes.Buffer\n\tcmd.Stderr = &stderr\n\tif err := cmd.Run(); err != nil {\n\t\treturn \"\", fmt.Errorf(\"command '%v': %v\\n%v\", cmd, err, stderr.String())\n\t}\n\treturn img, nil\n}\n"
        },
        {
          "name": "dot_cgo.go",
          "type": "blob",
          "size": 0.8994140625,
          "content": "//go:build cgo\n// +build cgo\n\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"path/filepath\"\n\n    \"github.com/goccy/go-graphviz\"\n)\n\nfunc runDotToImage(outfname string, format string, dot []byte) (string, error) {\n    g := graphviz.New()\n    graph, err := graphviz.ParseBytes(dot)\n    if err != nil {\n        return \"\", err\n    }\n    defer func() {\n        if err := graph.Close(); err != nil {\n            log.Printf(\"error closing graph: %v\", err)\n        }\n        if err := g.Close(); err != nil {\n            log.Printf(\"error closing graphviz: %v\", err)\n        }\n    }()\n    var img string\n    if outfname == \"\" {\n        img = filepath.Join(os.TempDir(), fmt.Sprintf(\"go-callvis_export.%s\", format))\n    } else {\n        img = fmt.Sprintf(\"%s.%s\", outfname, format)\n    }\n    if err := g.RenderFilename(graph, graphviz.Format(format), img); err != nil {\n        return \"\", err\n    }\n    return img, nil\n}\n"
        },
        {
          "name": "dot_nocgo.go",
          "type": "blob",
          "size": 0.1904296875,
          "content": "//go:build !cgo\n// +build !cgo\n\npackage main\n\nfunc runDotToImage(outfname string, format string, dot []byte) (string, error) {\n    return runDotToImageCallSystemGraphviz(outfname, format, dot)\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.51953125,
          "content": "module github.com/ofabry/go-callvis\n\ngo 1.22.0\n\ntoolchain go1.23.1\n\nrequire (\n\tgithub.com/goccy/go-graphviz v0.1.2\n\tgithub.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c\n\tgolang.org/x/tools v0.28.0\n)\n\nrequire (\n\tgithub.com/fogleman/gg v1.3.0 // indirect\n\tgithub.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0 // indirect\n\tgithub.com/pkg/errors v0.9.1 // indirect\n\tgolang.org/x/image v0.18.0 // indirect\n\tgolang.org/x/mod v0.22.0 // indirect\n\tgolang.org/x/sync v0.10.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.310546875,
          "content": "github.com/corona10/goimagehash v1.0.2 h1:pUfB0LnsJASMPGEZLj7tGY251vF+qLGqOgEP4rUs6kA=\ngithub.com/corona10/goimagehash v1.0.2/go.mod h1:/l9umBhvcHQXVtQO1V6Gp1yD20STawkhRnnX0D1bvVI=\ngithub.com/fogleman/gg v1.3.0 h1:/7zJX8F6AaYQc57WQCyN9cAIz+4bCJGO9B+dyW29am8=\ngithub.com/fogleman/gg v1.3.0/go.mod h1:R/bRT+9gY/C5z7JzPU0zXsXHKM4/ayA+zqcVNZzPa1k=\ngithub.com/goccy/go-graphviz v0.1.2 h1:sWSJ6w13BCm/ZOUTHDVrdvbsxqN8yyzaFcHrH/hQ9Yg=\ngithub.com/goccy/go-graphviz v0.1.2/go.mod h1:pMYpbAqJT10V8dzV1JN/g/wUlG/0imKPzn3ZsrchGCI=\ngithub.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0 h1:DACJavvAHhabrF08vX0COfcOBJRhZ8lUbR+ZWIs0Y5g=\ngithub.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0/go.mod h1:E/TSTwGwJL78qG/PmXZO1EjYhfJinVAhrmmHX6Z8B9k=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/nfnt/resize v0.0.0-20160724205520-891127d8d1b5 h1:BvoENQQU+fZ9uukda/RzCAL/191HHwJA5b13R6diVlY=\ngithub.com/nfnt/resize v0.0.0-20160724205520-891127d8d1b5/go.mod h1:jpp1/29i3P1S/RLdc7JQKbRpFeM1dOBd8T9ki5s+AY8=\ngithub.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c h1:+mdjkGKdHQG3305AYmdv1U2eRNDiU2ErMBj1gwrq8eQ=\ngithub.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c/go.mod h1:7rwL4CYBLnjLxUqIJNnCWiEdr3bn6IUYi15bNlnbCCU=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngolang.org/x/image v0.18.0 h1:jGzIakQa/ZXI1I0Fxvaa9W7yP25TqT6cHIHn+6CqvSQ=\ngolang.org/x/image v0.18.0/go.mod h1:4yyo5vMFQjVjUcVk4jEQcU9MGy/rulF5WvUILseCM2E=\ngolang.org/x/mod v0.22.0 h1:D4nJWe9zXqHOmWqj4VMOJhvzj7bEZg4wEYa759z1pH4=\ngolang.org/x/mod v0.22.0/go.mod h1:6SkKJ3Xj0I0BrPOZoBy3bdMptDDU9oJrpohJ3eWZ1fY=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/tools v0.28.0 h1:WuB6qZ4RPCQo5aP3WdKZS7i595EdWqWR8vqJTlwTVK8=\ngolang.org/x/tools v0.28.0/go.mod h1:dcIOrVd3mfQKTgrDVQHqCPMWy6lnhfhtX3hLXYVLfRw=\n"
        },
        {
          "name": "handler.go",
          "type": "blob",
          "size": 1.408203125,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tif r.URL.Path != \"/\" && !strings.HasSuffix(r.URL.Path, \".svg\") {\n\t\thttp.NotFound(w, r)\n\t\treturn\n\t}\n\n\tlogf(\"----------------------\")\n\tlogf(\" => handling request:  %v\", r.URL)\n\tlogf(\"----------------------\")\n\n\t// set up cmdline default for analysis\n\tAnalysis.OptsSetup()\n\n\t// .. and allow overriding by HTTP params\n\tAnalysis.OverrideByHTTP(r)\n\n\tvar img string\n\tif img = Analysis.FindCachedImg(); img != \"\" {\n\t\tlog.Println(\"serving cached file:\", img)\n\t\thttp.ServeFile(w, r, img)\n\t\treturn\n\t}\n\n\t// Convert list-style args to []string\n\tif e := Analysis.ProcessListArgs(); e != nil {\n\t\thttp.Error(w, \"invalid parameters\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\toutput, err := Analysis.Render()\n\tif err != nil {\n\t\thttp.Error(w, fmt.Sprintf(\"rendering failed: %v\", err.Error()), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif r.Form.Get(\"format\") == \"dot\" {\n\t\tlog.Println(\"writing dot output\")\n\t\tfmt.Fprint(w, string(output))\n\t\treturn\n\t}\n\n\tlog.Printf(\"converting dot to %s\\n\", *outputFormat)\n\n\timg, err = dotToImage(\"\", *outputFormat, output)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\terr = Analysis.CacheImg(img)\n\tif err != nil {\n\t\thttp.Error(w, \"cache img error: \"+err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tlog.Println(\"serving file:\", img)\n\thttp.ServeFile(w, r, img)\n}\n\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 4.6728515625,
          "content": "// go-callvis: a tool to help visualize the call graph of a Go program.\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"go/build\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/pkg/browser\"\n\t\"golang.org/x/tools/go/buildutil\"\n)\n\nconst Usage = `go-callvis: visualize call graph of a Go program.\n\nUsage:\n\n  go-callvis [flags] package\n\n  Package should be main package, otherwise -tests flag must be used.\n\nFlags:\n\n`\n\nvar (\n\tfocusFlag     = flag.String(\"focus\", \"main\", \"Focus specific package using name or import path.\")\n\tgroupFlag     = flag.String(\"group\", \"pkg\", \"Grouping functions by packages and/or types [pkg, type] (separated by comma)\")\n\tlimitFlag     = flag.String(\"limit\", \"\", \"Limit package paths to given prefixes (separated by comma)\")\n\tignoreFlag    = flag.String(\"ignore\", \"\", \"Ignore package paths containing given prefixes (separated by comma)\")\n\tincludeFlag   = flag.String(\"include\", \"\", \"Include package paths with given prefixes (separated by comma)\")\n\tnostdFlag     = flag.Bool(\"nostd\", false, \"Omit calls to/from packages in standard library.\")\n\tnointerFlag   = flag.Bool(\"nointer\", false, \"Omit calls to unexported functions.\")\n\ttestFlag      = flag.Bool(\"tests\", false, \"Include test code.\")\n\tgraphvizFlag  = flag.Bool(\"graphviz\", false, \"Use Graphviz's dot program to render images.\")\n\thttpFlag      = flag.String(\"http\", \":7878\", \"HTTP service address.\")\n\tskipBrowser   = flag.Bool(\"skipbrowser\", false, \"Skip opening browser.\")\n\toutputFile    = flag.String(\"file\", \"\", \"output filename - omit to use server mode\")\n\toutputFormat  = flag.String(\"format\", \"svg\", \"output file format [svg | png | jpg | ...]\")\n\tcacheDir      = flag.String(\"cacheDir\", \"\", \"Enable caching to avoid unnecessary re-rendering, you can force rendering by adding 'refresh=true' to the URL query or emptying the cache directory\")\n\tcallgraphAlgo = flag.String(\"algo\", string(CallGraphTypeStatic), fmt.Sprintf(\"The algorithm used to construct the call graph. Possible values inlcude: %q, %q, %q\",\n\t\tCallGraphTypeStatic, CallGraphTypeCha, CallGraphTypeRta))\n\n\tdebugFlag   = flag.Bool(\"debug\", false, \"Enable verbose log.\")\n\tversionFlag = flag.Bool(\"version\", false, \"Show version and exit.\")\n)\n\nfunc init() {\n\tflag.Var((*buildutil.TagsFlag)(&build.Default.BuildTags), \"tags\", buildutil.TagsFlagDoc)\n\t// Graphviz options\n\tflag.UintVar(&minlen, \"minlen\", 2, \"Minimum edge length (for wider output).\")\n\tflag.Float64Var(&nodesep, \"nodesep\", 0.35, \"Minimum space between two adjacent nodes in the same rank (for taller output).\")\n\tflag.StringVar(&nodeshape, \"nodeshape\", \"box\", \"graph node shape (see graphvis manpage for valid values)\")\n\tflag.StringVar(&nodestyle, \"nodestyle\", \"filled,rounded\", \"graph node style (see graphvis manpage for valid values)\")\n\tflag.StringVar(&rankdir, \"rankdir\", \"LR\", \"Direction of graph layout [LR | RL | TB | BT]\")\n}\n\nfunc logf(f string, a ...interface{}) {\n\tif *debugFlag {\n\t\tlog.Printf(f, a...)\n\t}\n}\n\nfunc parseHTTPAddr(addr string) string {\n\thost, port, _ := net.SplitHostPort(addr)\n\tif host == \"\" {\n\t\thost = \"localhost\"\n\t}\n\tif port == \"\" {\n\t\tport = \"80\"\n\t}\n\tu := url.URL{\n\t\tScheme: \"http\",\n\t\tHost:   fmt.Sprintf(\"%s:%s\", host, port),\n\t}\n\treturn u.String()\n}\n\nfunc openBrowser(url string) {\n\ttime.Sleep(time.Millisecond * 100)\n\tif err := browser.OpenURL(url); err != nil {\n\t\tlog.Printf(\"OpenURL error: %v\", err)\n\t}\n}\n\nfunc outputDot(fname string, outputFormat string) {\n\t// get cmdline default for analysis\n\tAnalysis.OptsSetup()\n\n\tif e := Analysis.ProcessListArgs(); e != nil {\n\t\tlog.Fatalf(\"%v\\n\", e)\n\t}\n\n\toutput, err := Analysis.Render()\n\tif err != nil {\n\t\tlog.Fatalf(\"%v\\n\", err)\n\t}\n\n\tlog.Println(\"writing dot output\")\n\n\twriteErr := os.WriteFile(fmt.Sprintf(\"%s.gv\", fname), output, 0755)\n\tif writeErr != nil {\n\t\tlog.Fatalf(\"%v\\n\", writeErr)\n\t}\n\n\tlog.Printf(\"converting dot to %s\\n\", outputFormat)\n\n\t_, err = dotToImage(fname, outputFormat, output)\n\tif err != nil {\n\t\tlog.Fatalf(\"%v\\n\", err)\n\t}\n}\n\n//noinspection GoUnhandledErrorResult\nfunc main() {\n\tflag.Parse()\n\n\tif *versionFlag {\n\t\tfmt.Fprintln(os.Stderr, Version())\n\t\tos.Exit(0)\n\t}\n\tif *debugFlag {\n\t\tlog.SetFlags(log.Lmicroseconds)\n\t}\n\n\tif flag.NArg() != 1 {\n\t\tfmt.Fprint(os.Stderr, Usage)\n\t\tflag.PrintDefaults()\n\t\tos.Exit(2)\n\t}\n\n\targs := flag.Args()\n\ttests := *testFlag\n\thttpAddr := *httpFlag\n\turlAddr := parseHTTPAddr(httpAddr)\n\n\tAnalysis = new(analysis)\n\tif err := Analysis.DoAnalysis(CallGraphType(*callgraphAlgo), \"\", tests, args); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\thttp.HandleFunc(\"/\", handler)\n\n\tif *outputFile == \"\" {\n\t\t*outputFile = \"output\"\n\t\tif !*skipBrowser {\n\t\t\tgo openBrowser(urlAddr)\n\t\t}\n\n\t\tlog.Printf(\"http serving at %s\", urlAddr)\n\n\t\tif err := http.ListenAndServe(httpAddr, nil); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t} else {\n\t\toutputDot(*outputFile, *outputFormat)\n\t}\n}\n"
        },
        {
          "name": "output.go",
          "type": "blob",
          "size": 10.7890625,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"go/build\"\n\t\"go/types\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"golang.org/x/tools/go/callgraph\"\n\t\"golang.org/x/tools/go/ssa\"\n)\n\nfunc isSynthetic(edge *callgraph.Edge) bool {\n\t// TODO: consider handling callee.Func.Pkg == nil\n\t// this could still generate a node for the call, might be useful\n\treturn edge.Caller.Func.Pkg == nil || edge.Callee.Func.Pkg == nil || edge.Callee.Func.Synthetic != \"\"\n}\n\nfunc inStd(node *callgraph.Node) bool {\n\t//pkg, _ := build.Import(node.Func.Pkg.Pkg.Path(), \"\", 0)\n\t//return pkg.Goroot\n\treturn isStdPkgPath(node.Func.Pkg.Pkg.Path())\n}\n\nfunc isStdPkgPath(path string) bool {\n\tif strings.Contains(path, \".\") {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc printOutput(\n\tprog *ssa.Program,\n\tmainPkg *ssa.Package,\n\tcg *callgraph.Graph,\n\tfocusPkg *types.Package,\n\tlimitPaths,\n\tignorePaths,\n\tincludePaths []string,\n\tgroupBy []string,\n\tnostd,\n\tnointer bool,\n) ([]byte, error) {\n\n\tlogf(\"printing output for: %v\", focusPkg)\n\tlogf(\"src dirs: %+v, default build context: %+v\", build.Default.SrcDirs(), build.Default)\n\n\tvar groupType, groupPkg bool\n\tfor _, g := range groupBy {\n\t\tswitch g {\n\t\tcase \"pkg\":\n\t\t\tgroupPkg = true\n\t\tcase \"type\":\n\t\t\tgroupType = true\n\t\t}\n\t}\n\n\tcluster := NewDotCluster(\"focus\")\n\tcluster.Attrs = dotAttrs{\n\t\t\"bgcolor\":   \"white\",\n\t\t\"label\":     \"\",\n\t\t\"labelloc\":  \"t\",\n\t\t\"labeljust\": \"c\",\n\t\t\"fontsize\":  \"18\",\n\t}\n\tif focusPkg != nil {\n\t\tcluster.Attrs[\"bgcolor\"] = \"#e6ecfa\"\n\t\tcluster.Attrs[\"label\"] = focusPkg.Name()\n\t}\n\n\tvar (\n\t\tnodes []*dotNode\n\t\tedges []*dotEdge\n\t)\n\n\tnodeMap := make(map[string]*dotNode)\n\tedgeMap := make(map[string]*dotEdge)\n\n\tcg.DeleteSyntheticNodes()\n\n\tlogf(\"%d limit prefixes: %v\", len(limitPaths), limitPaths)\n\tlogf(\"%d ignore prefixes: %v\", len(ignorePaths), ignorePaths)\n\tlogf(\"%d include prefixes: %v\", len(includePaths), includePaths)\n\tlogf(\"no std packages: %v\", nostd)\n\n\tvar isFocused = func(edge *callgraph.Edge) bool {\n\t\tcaller := edge.Caller\n\t\tcallee := edge.Callee\n\t\tif focusPkg != nil && (caller.Func.Pkg.Pkg.Path() == focusPkg.Path() || callee.Func.Pkg.Pkg.Path() == focusPkg.Path()) {\n\t\t\treturn true\n\t\t}\n\t\tfromFocused := false\n\t\tfor _, e := range caller.In {\n\t\t\tif !isSynthetic(e) && focusPkg != nil && e.Caller.Func.Pkg.Pkg.Path() == focusPkg.Path() {\n\t\t\t\tfromFocused = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\ttoFocused := false\n\t\tfor _, e := range callee.Out {\n\t\t\tif !isSynthetic(e) && focusPkg != nil && e.Callee.Func.Pkg.Pkg.Path() == focusPkg.Path() {\n\t\t\t\ttoFocused = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif fromFocused && toFocused {\n\t\t\tlogf(\"edge semi-focus: %s\", edge)\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tvar inIncludes = func(node *callgraph.Node) bool {\n\t\tpkgPath := node.Func.Pkg.Pkg.Path()\n\t\tfor _, p := range includePaths {\n\t\t\tif strings.HasPrefix(pkgPath, p) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tvar inLimits = func(node *callgraph.Node) bool {\n\t\tpkgPath := node.Func.Pkg.Pkg.Path()\n\t\tfor _, p := range limitPaths {\n\t\t\tif strings.HasPrefix(pkgPath, p) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tvar inIgnores = func(node *callgraph.Node) bool {\n\t\tpkgPath := node.Func.Pkg.Pkg.Path()\n\t\tfor _, p := range ignorePaths {\n\t\t\tif strings.HasPrefix(pkgPath, p) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tvar isInter = func(edge *callgraph.Edge) bool {\n\t\t//caller := edge.Caller\n\t\tcallee := edge.Callee\n\t\tif callee.Func.Object() != nil && !callee.Func.Object().Exported() {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tcount := 0\n\terr := callgraph.GraphVisitEdges(cg, func(edge *callgraph.Edge) error {\n\t\tcount++\n\n\t\tcaller := edge.Caller\n\t\tcallee := edge.Callee\n\n\t\tposCaller := prog.Fset.Position(caller.Func.Pos())\n\t\tposCallee := prog.Fset.Position(callee.Func.Pos())\n\t\tposEdge := prog.Fset.Position(edge.Pos())\n\t\t//fileCaller := fmt.Sprintf(\"%s:%d\", posCaller.Filename, posCaller.Line)\n\t\tfilenameCaller := filepath.Base(posCaller.Filename)\n\n\t\t// omit synthetic calls\n\t\tif isSynthetic(edge) {\n\t\t\treturn nil\n\t\t}\n\n\t\t//logf(\" - %s -> %s (%s -> %s) %v\\n\", caller.Func.Pkg, callee.Func.Pkg, caller, callee, filenameCaller)\n\n\t\tcallerPkg := caller.Func.Pkg.Pkg\n\t\tcalleePkg := callee.Func.Pkg.Pkg\n\n\t\t// focus specific pkg\n\t\tif focusPkg != nil &&\n\t\t\t!isFocused(edge) {\n\t\t\treturn nil\n\t\t}\n\n\t\t// omit std\n\t\tif nostd && (inStd(caller) || inStd(callee)) {\n\t\t\treturn nil\n\t\t}\n\n\t\t// omit inter\n\t\tif nointer && isInter(edge) {\n\t\t\treturn nil\n\t\t}\n\n\t\tinclude := false\n\t\t// include path prefixes\n\t\tif len(includePaths) > 0 &&\n\t\t\t(inIncludes(caller) || inIncludes(callee)) {\n\t\t\tlogf(\"include: %s -> %s\", caller, callee)\n\t\t\tinclude = true\n\t\t}\n\n\t\tif !include {\n\t\t\t// limit path prefixes\n\t\t\tif len(limitPaths) > 0 &&\n\t\t\t\t(!inLimits(caller) || !inLimits(callee)) {\n\t\t\t\tlogf(\"NOT in limit: %s -> %s\", caller, callee)\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// ignore path prefixes\n\t\t\tif len(ignorePaths) > 0 &&\n\t\t\t\t(inIgnores(caller) || inIgnores(callee)) {\n\t\t\t\tlogf(\"IS ignored: %s -> %s\", caller, callee)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\t//var buf bytes.Buffer\n\t\t//data, _ := json.MarshalIndent(caller.Func, \"\", \" \")\n\t\t//logf(\"call node: %s -> %s\\n %v\", caller, callee, string(data))\n\t\tlogf(\"call node: %s -> %s (%s -> %s) %v\\n\", caller.Func.Pkg, callee.Func.Pkg, caller, callee, filenameCaller)\n\n\t\tvar sprintNode = func(node *callgraph.Node, isCaller bool) *dotNode {\n\t\t\t// only once\n\t\t\tkey := node.Func.String()\n\t\t\tnodeTooltip := \"\"\n\n\t\t\tfileCaller := fmt.Sprintf(\"%s:%d\", filepath.Base(posCaller.Filename), posCaller.Line)\n\t\t\tfileCallee := fmt.Sprintf(\"%s:%d\", filepath.Base(posCallee.Filename), posCallee.Line)\n\n\t\t\tif isCaller {\n\t\t\t\tnodeTooltip = fmt.Sprintf(\"%s | defined in %s\", node.Func.String(), fileCaller)\n\t\t\t} else {\n\t\t\t\tnodeTooltip = fmt.Sprintf(\"%s | defined in %s\", node.Func.String(), fileCallee)\n\t\t\t}\n\n\t\t\tif n, ok := nodeMap[key]; ok {\n\t\t\t\treturn n\n\t\t\t}\n\n\t\t\t// is focused\n\t\t\tisFocused := focusPkg != nil &&\n\t\t\t\tnode.Func.Pkg.Pkg.Path() == focusPkg.Path()\n\t\t\tattrs := make(dotAttrs)\n\n\t\t\t// node label\n\t\t\tlabel := node.Func.RelString(node.Func.Pkg.Pkg)\n\n\t\t\t// func signature\n\t\t\tsign := node.Func.Signature\n\t\t\tif node.Func.Parent() != nil {\n\t\t\t\tsign = node.Func.Parent().Signature\n\t\t\t}\n\n\t\t\t// omit type from label\n\t\t\tif groupType && sign.Recv() != nil {\n\t\t\t\tparts := strings.Split(label, \".\")\n\t\t\t\tlabel = parts[len(parts)-1]\n\t\t\t}\n\n\t\t\tpkgPath := node.Func.Pkg.Pkg.Path()\n\t\t\tisStdPkg := isStdPkgPath(pkgPath)\n\n\t\t\t// set node color\n\t\t\tif isFocused {\n\t\t\t\tattrs[\"fillcolor\"] = \"lightblue\"\n\t\t\t} else if isStdPkg {\n\t\t\t\tattrs[\"fillcolor\"] = \"#adedad\"\n\t\t\t} else {\n\t\t\t\tattrs[\"fillcolor\"] = \"moccasin\"\n\t\t\t}\n\n\t\t\t// include pkg name\n\t\t\tif !groupPkg && !isFocused {\n\t\t\t\tlabel = fmt.Sprintf(\"%s\\n%s\", node.Func.Pkg.Pkg.Name(), label)\n\t\t\t}\n\n\t\t\tattrs[\"label\"] = label\n\n\t\t\t// func styles\n\t\t\tif node.Func.Parent() != nil {\n\t\t\t\tattrs[\"style\"] = \"dotted,filled\"\n\t\t\t} else if node.Func.Object() != nil && node.Func.Object().Exported() {\n\t\t\t\tattrs[\"penwidth\"] = \"1.5\"\n\t\t\t} else {\n\t\t\t\tattrs[\"penwidth\"] = \"0.5\"\n\t\t\t}\n\n\t\t\tc := cluster\n\n\t\t\t// group by pkg\n\t\t\tif groupPkg && !isFocused {\n\t\t\t\tlabel := node.Func.Pkg.Pkg.Name()\n\t\t\t\tif isStdPkg {\n\t\t\t\t\tlabel = node.Func.Pkg.Pkg.Path()\n\t\t\t\t}\n\t\t\t\tkey := node.Func.Pkg.Pkg.Path()\n\t\t\t\tif _, ok := c.Clusters[key]; !ok {\n\t\t\t\t\tc.Clusters[key] = &dotCluster{\n\t\t\t\t\t\tID:       key,\n\t\t\t\t\t\tClusters: make(map[string]*dotCluster),\n\t\t\t\t\t\tAttrs: dotAttrs{\n\t\t\t\t\t\t\t\"penwidth\":  \"0.8\",\n\t\t\t\t\t\t\t\"fontsize\":  \"16\",\n\t\t\t\t\t\t\t\"label\":     label,\n\t\t\t\t\t\t\t\"style\":     \"filled\",\n\t\t\t\t\t\t\t\"fillcolor\": \"lightyellow\",\n\t\t\t\t\t\t\t\"URL\":       fmt.Sprintf(\"/?f=%s\", key),\n\t\t\t\t\t\t\t\"fontname\":  \"Tahoma bold\",\n\t\t\t\t\t\t\t\"tooltip\":   fmt.Sprintf(\"package: %s\", key),\n\t\t\t\t\t\t\t\"rank\":      \"sink\",\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t\tif isStdPkg {\n\t\t\t\t\t\tc.Clusters[key].Attrs[\"fillcolor\"] = \"#E0FFE1\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc = c.Clusters[key]\n\t\t\t}\n\n\t\t\t// group by type\n\t\t\tif groupType && sign.Recv() != nil {\n\t\t\t\tlabel := strings.Split(node.Func.RelString(node.Func.Pkg.Pkg), \".\")[0]\n\t\t\t\tkey := sign.Recv().Type().String()\n\t\t\t\tif _, ok := c.Clusters[key]; !ok {\n\t\t\t\t\tc.Clusters[key] = &dotCluster{\n\t\t\t\t\t\tID:       key,\n\t\t\t\t\t\tClusters: make(map[string]*dotCluster),\n\t\t\t\t\t\tAttrs: dotAttrs{\n\t\t\t\t\t\t\t\"penwidth\":  \"0.5\",\n\t\t\t\t\t\t\t\"fontsize\":  \"15\",\n\t\t\t\t\t\t\t\"fontcolor\": \"#222222\",\n\t\t\t\t\t\t\t\"label\":     label,\n\t\t\t\t\t\t\t\"labelloc\":  \"b\",\n\t\t\t\t\t\t\t\"style\":     \"rounded,filled\",\n\t\t\t\t\t\t\t\"fillcolor\": \"wheat2\",\n\t\t\t\t\t\t\t\"tooltip\":   fmt.Sprintf(\"type: %s\", key),\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t\tif isFocused {\n\t\t\t\t\t\tc.Clusters[key].Attrs[\"fillcolor\"] = \"lightsteelblue\"\n\t\t\t\t\t} else if isStdPkg {\n\t\t\t\t\t\tc.Clusters[key].Attrs[\"fillcolor\"] = \"#c2e3c2\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc = c.Clusters[key]\n\t\t\t}\n\n\t\t\tattrs[\"tooltip\"] = nodeTooltip\n\n\t\t\tn := &dotNode{\n\t\t\t\tID:    node.Func.String(),\n\t\t\t\tAttrs: attrs,\n\t\t\t}\n\n\t\t\tif c != nil {\n\t\t\t\tc.Nodes = append(c.Nodes, n)\n\t\t\t} else {\n\t\t\t\tnodes = append(nodes, n)\n\t\t\t}\n\n\t\t\tnodeMap[key] = n\n\t\t\treturn n\n\t\t}\n\t\tcallerNode := sprintNode(edge.Caller, true)\n\t\tcalleeNode := sprintNode(edge.Callee, false)\n\n\t\t// edges\n\t\tattrs := make(dotAttrs)\n\n\t\t// dynamic call\n\t\tif edge.Site != nil && edge.Site.Common().StaticCallee() == nil {\n\t\t\tattrs[\"style\"] = \"dashed\"\n\t\t}\n\n\t\t// go & defer calls\n\t\tswitch edge.Site.(type) {\n\t\tcase *ssa.Go:\n\t\t\tattrs[\"arrowhead\"] = \"normalnoneodot\"\n\t\tcase *ssa.Defer:\n\t\t\tattrs[\"arrowhead\"] = \"normalnoneodiamond\"\n\t\t}\n\n\t\t// colorize calls outside focused pkg\n\t\tif focusPkg != nil &&\n\t\t\t(calleePkg.Path() != focusPkg.Path() || callerPkg.Path() != focusPkg.Path()) {\n\t\t\tattrs[\"color\"] = \"saddlebrown\"\n\t\t}\n\n\t\t// use position in file where callee is called as tooltip for the edge\n\t\tfileEdge := fmt.Sprintf(\n\t\t\t\"at %s:%d: calling [%s]\",\n\t\t\tfilepath.Base(posEdge.Filename),\n\t\t\tposEdge.Line,\n\t\t\tedge.Callee.Func.String(),\n\t\t)\n\n\t\t// omit duplicate calls, except for tooltip enhancements\n\t\tkey := fmt.Sprintf(\"%s = %s => %s\", caller.Func, edge.Description(), callee.Func)\n\t\tif _, ok := edgeMap[key]; !ok {\n\t\t\tattrs[\"tooltip\"] = fileEdge\n\t\t\te := &dotEdge{\n\t\t\t\tFrom:  callerNode,\n\t\t\t\tTo:    calleeNode,\n\t\t\t\tAttrs: attrs,\n\t\t\t}\n\t\t\tedgeMap[key] = e\n\t\t} else {\n\t\t\t// make sure, tooltip is created correctly\n\t\t\tif _, okk := edgeMap[key].Attrs[\"tooltip\"]; !okk {\n\t\t\t\tedgeMap[key].Attrs[\"tooltip\"] = fileEdge\n\t\t\t} else {\n\t\t\t\tedgeMap[key].Attrs[\"tooltip\"] = fmt.Sprintf(\n\t\t\t\t\t\"%s\\n%s\",\n\t\t\t\t\tedgeMap[key].Attrs[\"tooltip\"],\n\t\t\t\t\tfileEdge,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// get edges form edgeMap\n\tfor _, e := range edgeMap {\n\t\te.From.Attrs[\"tooltip\"] = fmt.Sprintf(\n\t\t\t\"%s\\n%s\",\n\t\t\te.From.Attrs[\"tooltip\"],\n\t\t\te.Attrs[\"tooltip\"],\n\t\t)\n\t\tedges = append(edges, e)\n\t}\n\n\tlogf(\"%d/%d nodes\", len(nodeMap), len(cg.Nodes))\n\tlogf(\"%d/%d edges\", len(edges), count)\n\n\ttitle := \"\"\n\tif mainPkg != nil && mainPkg.Pkg != nil {\n\t\ttitle = mainPkg.Pkg.Path()\n\t}\n\tdot := &dotGraph{\n\t\tTitle:   title,\n\t\tMinlen:  minlen,\n\t\tCluster: cluster,\n\t\tNodes:   nodes,\n\t\tEdges:   edges,\n\t\tOptions: map[string]string{\n\t\t\t\"minlen\":    fmt.Sprint(minlen),\n\t\t\t\"nodesep\":   fmt.Sprint(nodesep),\n\t\t\t\"nodeshape\": fmt.Sprint(nodeshape),\n\t\t\t\"nodestyle\": fmt.Sprint(nodestyle),\n\t\t\t\"rankdir\":   fmt.Sprint(rankdir),\n\t\t},\n\t}\n\n\tvar buf bytes.Buffer\n\tif err := dot.WriteDot(&buf); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn buf.Bytes(), nil\n}\n"
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.16796875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n)\n\nvar (\n\tversion = \"v0.7.1\"\n\tcommit  = \"(unknown)\"\n)\n\nfunc Version() string {\n\treturn fmt.Sprintf(\"%s built from git %s\", version, commit)\n}\n"
        }
      ]
    }
  ]
}