{
  "metadata": {
    "timestamp": 1736567636762,
    "page": 217,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "go-xorm/xorm",
      "stars": 6664,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".circleci",
          "type": "tree",
          "content": null
        },
        {
          "name": ".drone.yml",
          "type": "blob",
          "size": 22.17578125,
          "content": "---\nkind: pipeline\nname: matrix-1\n\nplatform:\n  os: linux\n  arch: amd64\n\nclone:\n  disable: true\n\nworkspace:\n  base: /go\n  path: src/github.com/go-xorm/xorm\n\nsteps:\n- name: git\n  pull: default\n  image: plugins/git:next\n  settings:\n    depth: 50\n    tags: true\n\n- name: init_postgres\n  pull: default\n  image: postgres:9.5\n  commands:\n  - \"until psql -U postgres -d xorm_test -h pgsql \\\\\\n -c \\\"SELECT 1;\\\" >/dev/null 2>&1; do sleep 1; done\\n\"\n  - \"psql -U postgres -d xorm_test -h pgsql \\\\\\n  -c \\\"create schema xorm;\\\"\\n\"\n\n- name: build\n  pull: default\n  image: golang:1.10\n  commands:\n  - go get -t -d -v ./...\n  - go get -u xorm.io/core\n  - go get -u xorm.io/builder\n  - go build -v\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-sqlite\n  pull: default\n  image: golang:1.10\n  commands:\n  - go get -u github.com/wadey/gocovmerge\n  - \"go test -v -race -db=\\\"sqlite3\\\" -conn_str=\\\"./test.db\\\" -coverprofile=coverage1-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"sqlite3\\\" -conn_str=\\\"./test.db\\\" -cache=true -coverprofile=coverage1-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-mysql\n  pull: default\n  image: golang:1.10\n  commands:\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(mysql)/xorm_test\\\" -coverprofile=coverage2-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(mysql)/xorm_test\\\" -cache=true -coverprofile=coverage2-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-mysql-utf8mb4\n  pull: default\n  image: golang:1.10\n  commands:\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(mysql)/xorm_test?charset=utf8mb4\\\" -coverprofile=coverage2.1-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(mysql)/xorm_test?charset=utf8mb4\\\" -cache=true -coverprofile=coverage2.1-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-mymysql\n  pull: default\n  image: golang:1.10\n  commands:\n  - \"go test -v -race -db=\\\"mymysql\\\" -conn_str=\\\"tcp:mysql:3306*xorm_test/root/\\\" -coverprofile=coverage3-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mymysql\\\" -conn_str=\\\"tcp:mysql:3306*xorm_test/root/\\\" -cache=true -coverprofile=coverage3-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-postgres\n  pull: default\n  image: golang:1.10\n  commands:\n  - \"go test -v -race -db=\\\"postgres\\\" -conn_str=\\\"postgres://postgres:@pgsql/xorm_test?sslmode=disable\\\" -coverprofile=coverage4-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"postgres\\\" -conn_str=\\\"postgres://postgres:@pgsql/xorm_test?sslmode=disable\\\" -cache=true -coverprofile=coverage4-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-postgres-schema\n  pull: default\n  image: golang:1.10\n  commands:\n  - \"go test -v -race -db=\\\"postgres\\\" -conn_str=\\\"postgres://postgres:@pgsql/xorm_test?sslmode=disable\\\" -schema=xorm -coverprofile=coverage5-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"postgres\\\" -conn_str=\\\"postgres://postgres:@pgsql/xorm_test?sslmode=disable\\\" -schema=xorm -cache=true -coverprofile=coverage5-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-mssql\n  pull: default\n  image: golang:1.10\n  commands:\n  - \"go test -v -race -db=\\\"mssql\\\" -conn_str=\\\"server=mssql;user id=sa;password=yourStrong(!)Password;database=xorm_test\\\" -coverprofile=coverage6-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mssql\\\" -conn_str=\\\"server=mssql;user id=sa;password=yourStrong(!)Password;database=xorm_test\\\" -cache=true -coverprofile=coverage6-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-tidb\n  pull: default\n  image: golang:1.10\n  commands:\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(tidb:4000)/xorm_test\\\" -ignore_select_update=true -coverprofile=coverage7-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(tidb:4000)/xorm_test\\\" -ignore_select_update=true -cache=true -coverprofile=coverage7-2.txt -covermode=atomic\"\n  - gocovmerge coverage1-1.txt coverage1-2.txt coverage2-1.txt coverage2-2.txt coverage2.1-1.txt coverage2.1-2.txt coverage3-1.txt coverage3-2.txt coverage4-1.txt coverage4-2.txt coverage5-1.txt coverage5-2.txt coverage6-1.txt coverage6-2.txt coverage7-1.txt coverage7-2.txt > coverage.txt\n  when:\n    event:\n    - push\n    - pull_request\n\nservices:\n- name: mysql\n  pull: default\n  image: mysql:5.7\n  environment:\n    MYSQL_ALLOW_EMPTY_PASSWORD: yes\n    MYSQL_DATABASE: xorm_test\n  when:\n    event:\n    - push\n    - tag\n    - pull_request\n\n- name: tidb\n  pull: default\n  image: pingcap/tidb:v3.0.3\n  when:\n    event:\n    - push\n    - tag\n    - pull_request\n\n- name: pgsql\n  pull: default\n  image: postgres:9.5\n  environment:\n    POSTGRES_DB: xorm_test\n    POSTGRES_USER: postgres\n  when:\n    event:\n    - push\n    - tag\n    - pull_request\n\n- name: mssql\n  pull: default\n  image: microsoft/mssql-server-linux:latest\n  environment:\n    ACCEPT_EULA: Y\n    SA_PASSWORD: yourStrong(!)Password\n    MSSQL_PID: Developer\n  when:\n    event:\n    - push\n    - tag\n    - pull_request\n\n---\nkind: pipeline\nname: matrix-2\n\nplatform:\n  os: linux\n  arch: amd64\n\nclone:\n  disable: true\n\nworkspace:\n  base: /go\n  path: src/github.com/go-xorm/xorm\n\nsteps:\n- name: git\n  pull: default\n  image: plugins/git:next\n  settings:\n    depth: 50\n    tags: true\n\n- name: init_postgres\n  pull: default\n  image: postgres:9.5\n  commands:\n  - \"until psql -U postgres -d xorm_test -h pgsql \\\\\\n -c \\\"SELECT 1;\\\" >/dev/null 2>&1; do sleep 1; done\\n\"\n  - \"psql -U postgres -d xorm_test -h pgsql \\\\\\n  -c \\\"create schema xorm;\\\"\\n\"\n\n- name: build\n  pull: default\n  image: golang:1.11\n  environment:\n    GO111MODULE: \"off\"\n  commands:\n    - go get -t -d -v ./...\t\n    - go get -u xorm.io/core\t\n    - go get -u xorm.io/builder\n    - go build -v\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: build-gomod\n  pull: default\n  image: golang:1.11\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n    - go build -v\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-sqlite\n  pull: default\n  image: golang:1.11\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"sqlite3\\\" -conn_str=\\\"./test.db\\\" -coverprofile=coverage1-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"sqlite3\\\" -conn_str=\\\"./test.db\\\" -cache=true -coverprofile=coverage1-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-mysql\n  pull: default\n  image: golang:1.11\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(mysql)/xorm_test\\\" -coverprofile=coverage2-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(mysql)/xorm_test\\\" -cache=true -coverprofile=coverage2-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-mysql-utf8mb4\n  pull: default\n  image: golang:1.11\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(mysql)/xorm_test?charset=utf8mb4\\\" -coverprofile=coverage2.1-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(mysql)/xorm_test?charset=utf8mb4\\\" -cache=true -coverprofile=coverage2.1-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-mymysql\n  pull: default\n  image: golang:1.11\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"mymysql\\\" -conn_str=\\\"tcp:mysql:3306*xorm_test/root/\\\" -coverprofile=coverage3-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mymysql\\\" -conn_str=\\\"tcp:mysql:3306*xorm_test/root/\\\" -cache=true -coverprofile=coverage3-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-postgres\n  pull: default\n  image: golang:1.11\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"postgres\\\" -conn_str=\\\"postgres://postgres:@pgsql/xorm_test?sslmode=disable\\\" -coverprofile=coverage4-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"postgres\\\" -conn_str=\\\"postgres://postgres:@pgsql/xorm_test?sslmode=disable\\\" -cache=true -coverprofile=coverage4-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-postgres-schema\n  pull: default\n  image: golang:1.11\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"postgres\\\" -conn_str=\\\"postgres://postgres:@pgsql/xorm_test?sslmode=disable\\\" -schema=xorm -coverprofile=coverage5-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"postgres\\\" -conn_str=\\\"postgres://postgres:@pgsql/xorm_test?sslmode=disable\\\" -schema=xorm -cache=true -coverprofile=coverage5-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-mssql\n  pull: default\n  image: golang:1.11\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"mssql\\\" -conn_str=\\\"server=mssql;user id=sa;password=yourStrong(!)Password;database=xorm_test\\\" -coverprofile=coverage6-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mssql\\\" -conn_str=\\\"server=mssql;user id=sa;password=yourStrong(!)Password;database=xorm_test\\\" -cache=true -coverprofile=coverage6-2.txt -covermode=atomic\"\n\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-tidb\n  pull: default\n  image: golang:1.11\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(tidb:4000)/xorm_test\\\" -ignore_select_update=true -coverprofile=coverage7-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(tidb:4000)/xorm_test\\\" -ignore_select_update=true -cache=true -coverprofile=coverage7-2.txt -covermode=atomic\"\n  - go get github.com/wadey/gocovmerge\n  - gocovmerge coverage1-1.txt coverage1-2.txt coverage2-1.txt coverage2-2.txt coverage2.1-1.txt coverage2.1-2.txt coverage3-1.txt coverage3-2.txt coverage4-1.txt coverage4-2.txt coverage5-1.txt coverage5-2.txt coverage6-1.txt coverage6-2.txt coverage7-1.txt coverage7-2.txt > coverage.txt\n  when:\n    event:\n    - push\n    - pull_request\n\nservices:\n- name: mysql\n  pull: default\n  image: mysql:5.7\n  environment:\n    MYSQL_ALLOW_EMPTY_PASSWORD: yes\n    MYSQL_DATABASE: xorm_test\n  when:\n    event:\n    - push\n    - tag\n    - pull_request\n\n- name: tidb\n  pull: default\n  image: pingcap/tidb:v3.0.3\n  when:\n    event:\n    - push\n    - tag\n    - pull_request\n\n- name: pgsql\n  pull: default\n  image: postgres:9.5\n  environment:\n    POSTGRES_DB: xorm_test\n    POSTGRES_USER: postgres\n  when:\n    event:\n    - push\n    - tag\n    - pull_request\n\n- name: mssql\n  pull: default\n  image: microsoft/mssql-server-linux:latest\n  environment:\n    ACCEPT_EULA: Y\n    SA_PASSWORD: yourStrong(!)Password\n    MSSQL_PID: Developer\n  when:\n    event:\n    - push\n    - tag\n    - pull_request\n\n---\nkind: pipeline\nname: matrix-3\n\nplatform:\n  os: linux\n  arch: amd64\n\nclone:\n  disable: true\n\nworkspace:\n  base: /go\n  path: src/github.com/go-xorm/xorm\n\nsteps:\n- name: git\n  pull: default\n  image: plugins/git:next\n  settings:\n    depth: 50\n    tags: true\n\n- name: build\n  pull: default\n  image: golang:1.12\n  environment:\n    GO111MODULE: \"off\"\n  commands:\n    - go get -t -d -v ./...\t\n    - go get -u xorm.io/core\t\n    - go get -u xorm.io/builder\n    - go build -v\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: build-gomod\n  pull: default\n  image: golang:1.12\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n    - go build -v\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-sqlite\n  pull: default\n  image: golang:1.12\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"sqlite3\\\" -conn_str=\\\"./test.db\\\" -coverprofile=coverage1-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"sqlite3\\\" -conn_str=\\\"./test.db\\\" -cache=true -coverprofile=coverage1-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-mysql\n  pull: default\n  image: golang:1.12\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(mysql)/xorm_test\\\" -coverprofile=coverage2-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(mysql)/xorm_test\\\" -cache=true -coverprofile=coverage2-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-mysql-utf8mb4\n  pull: default\n  image: golang:1.12\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(mysql)/xorm_test?charset=utf8mb4\\\" -coverprofile=coverage2.1-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(mysql)/xorm_test?charset=utf8mb4\\\" -cache=true -coverprofile=coverage2.1-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-mymysql\n  pull: default\n  image: golang:1.12\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"mymysql\\\" -conn_str=\\\"tcp:mysql:3306*xorm_test/root/\\\" -coverprofile=coverage3-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mymysql\\\" -conn_str=\\\"tcp:mysql:3306*xorm_test/root/\\\" -cache=true -coverprofile=coverage3-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-postgres\n  pull: default\n  image: golang:1.12\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"postgres\\\" -conn_str=\\\"postgres://postgres:@pgsql/xorm_test?sslmode=disable\\\" -coverprofile=coverage4-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"postgres\\\" -conn_str=\\\"postgres://postgres:@pgsql/xorm_test?sslmode=disable\\\" -cache=true -coverprofile=coverage4-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-postgres-schema\n  pull: default\n  image: golang:1.12\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"postgres\\\" -conn_str=\\\"postgres://postgres:@pgsql/xorm_test?sslmode=disable\\\" -schema=xorm -coverprofile=coverage5-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"postgres\\\" -conn_str=\\\"postgres://postgres:@pgsql/xorm_test?sslmode=disable\\\" -schema=xorm -cache=true -coverprofile=coverage5-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-mssql\n  pull: default\n  image: golang:1.12\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"mssql\\\" -conn_str=\\\"server=mssql;user id=sa;password=yourStrong(!)Password;database=xorm_test\\\" -coverprofile=coverage6-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mssql\\\" -conn_str=\\\"server=mssql;user id=sa;password=yourStrong(!)Password;database=xorm_test\\\" -cache=true -coverprofile=coverage6-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-tidb\n  pull: default\n  image: golang:1.12\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(tidb:4000)/xorm_test\\\" -ignore_select_update=true -coverprofile=coverage7-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(tidb:4000)/xorm_test\\\" -ignore_select_update=true -cache=true -coverprofile=coverage7-2.txt -covermode=atomic\"\n  - go get github.com/wadey/gocovmerge\n  - gocovmerge coverage1-1.txt coverage1-2.txt coverage2-1.txt coverage2-2.txt coverage2.1-1.txt coverage2.1-2.txt coverage3-1.txt coverage3-2.txt coverage4-1.txt coverage4-2.txt coverage5-1.txt coverage5-2.txt coverage6-1.txt coverage6-2.txt coverage7-1.txt coverage7-2.txt > coverage.txt\n  when:\n    event:\n    - push\n    - pull_request\n\nservices:\n- name: mysql\n  pull: default\n  image: mysql:5.7\n  environment:\n    MYSQL_ALLOW_EMPTY_PASSWORD: yes\n    MYSQL_DATABASE: xorm_test\n  when:\n    event:\n    - push\n    - tag\n    - pull_request\n\n- name: tidb\n  pull: default\n  image: pingcap/tidb:v3.0.3\n  when:\n    event:\n    - push\n    - tag\n    - pull_request\n\n- name: pgsql\n  pull: default\n  image: postgres:9.5\n  environment:\n    POSTGRES_DB: xorm_test\n    POSTGRES_USER: postgres\n  when:\n    event:\n    - push\n    - tag\n    - pull_request\n\n- name: mssql\n  pull: default\n  image: microsoft/mssql-server-linux:latest\n  environment:\n    ACCEPT_EULA: Y\n    SA_PASSWORD: yourStrong(!)Password\n    MSSQL_PID: Developer\n  when:\n    event:\n    - push\n    - tag\n    - pull_request\n\n---\nkind: pipeline\nname: go1.13\n\nplatform:\n  os: linux\n  arch: amd64\n\nclone:\n  disable: true\n\nworkspace:\n  base: /go\n  path: src/github.com/go-xorm/xorm\n\nsteps:\n- name: git\n  pull: default\n  image: plugins/git:next\n  settings:\n    depth: 50\n    tags: true\n\n- name: build\n  pull: default\n  image: golang:1.13\n  environment:\n    GO111MODULE: \"off\"\n  commands:\n    - go get -t -d -v ./...\t\n    - go get -u xorm.io/core\t\n    - go get -u xorm.io/builder\n    - go build -v\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: build-gomod\n  pull: default\n  image: golang:1.13\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n    - go build -v\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-sqlite\n  pull: default\n  image: golang:1.13\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"sqlite3\\\" -conn_str=\\\"./test.db\\\" -coverprofile=coverage1-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"sqlite3\\\" -conn_str=\\\"./test.db\\\" -cache=true -coverprofile=coverage1-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-mysql\n  pull: default\n  image: golang:1.13\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(mysql)/xorm_test\\\" -coverprofile=coverage2-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(mysql)/xorm_test\\\" -cache=true -coverprofile=coverage2-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-mysql-utf8mb4\n  pull: default\n  image: golang:1.13\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(mysql)/xorm_test?charset=utf8mb4\\\" -coverprofile=coverage2.1-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(mysql)/xorm_test?charset=utf8mb4\\\" -cache=true -coverprofile=coverage2.1-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-mymysql\n  pull: default\n  image: golang:1.13\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"mymysql\\\" -conn_str=\\\"tcp:mysql:3306*xorm_test/root/\\\" -coverprofile=coverage3-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mymysql\\\" -conn_str=\\\"tcp:mysql:3306*xorm_test/root/\\\" -cache=true -coverprofile=coverage3-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-postgres\n  pull: default\n  image: golang:1.13\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"postgres\\\" -conn_str=\\\"postgres://postgres:@pgsql/xorm_test?sslmode=disable\\\" -coverprofile=coverage4-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"postgres\\\" -conn_str=\\\"postgres://postgres:@pgsql/xorm_test?sslmode=disable\\\" -cache=true -coverprofile=coverage4-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-postgres-schema\n  pull: default\n  image: golang:1.13\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"postgres\\\" -conn_str=\\\"postgres://postgres:@pgsql/xorm_test?sslmode=disable\\\" -schema=xorm -coverprofile=coverage5-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"postgres\\\" -conn_str=\\\"postgres://postgres:@pgsql/xorm_test?sslmode=disable\\\" -schema=xorm -cache=true -coverprofile=coverage5-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-mssql\n  pull: default\n  image: golang:1.13\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"mssql\\\" -conn_str=\\\"server=mssql;user id=sa;password=yourStrong(!)Password;database=xorm_test\\\" -coverprofile=coverage6-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mssql\\\" -conn_str=\\\"server=mssql;user id=sa;password=yourStrong(!)Password;database=xorm_test\\\" -cache=true -coverprofile=coverage6-2.txt -covermode=atomic\"\n  when:\n    event:\n    - push\n    - pull_request\n\n- name: test-tidb\n  pull: default\n  image: golang:1.13\n  environment:\n    GO111MODULE: \"on\"\n    GOPROXY: \"https://goproxy.cn\"\n  commands:\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(tidb:4000)/xorm_test\\\" -ignore_select_update=true -coverprofile=coverage7-1.txt -covermode=atomic\"\n  - \"go test -v -race -db=\\\"mysql\\\" -conn_str=\\\"root:@tcp(tidb:4000)/xorm_test\\\" -ignore_select_update=true -cache=true -coverprofile=coverage7-2.txt -covermode=atomic\"\n  - go get github.com/wadey/gocovmerge\n  - gocovmerge coverage1-1.txt coverage1-2.txt coverage2-1.txt coverage2-2.txt coverage2.1-1.txt coverage2.1-2.txt coverage3-1.txt coverage3-2.txt coverage4-1.txt coverage4-2.txt coverage5-1.txt coverage5-2.txt coverage6-1.txt coverage6-2.txt coverage7-1.txt coverage7-2.txt > coverage.txt\n  when:\n    event:\n    - push\n    - pull_request\n\nservices:\n- name: mysql\n  pull: default\n  image: mysql:5.7\n  environment:\n    MYSQL_ALLOW_EMPTY_PASSWORD: yes\n    MYSQL_DATABASE: xorm_test\n  when:\n    event:\n    - push\n    - tag\n    - pull_request\n\n- name: tidb\n  pull: default\n  image: pingcap/tidb:v3.0.3\n  when:\n    event:\n    - push\n    - tag\n    - pull_request\n\n- name: pgsql\n  pull: default\n  image: postgres:9.5\n  environment:\n    POSTGRES_DB: xorm_test\n    POSTGRES_USER: postgres\n  when:\n    event:\n    - push\n    - tag\n    - pull_request\n\n- name: mssql\n  pull: default\n  image: microsoft/mssql-server-linux:latest\n  environment:\n    ACCEPT_EULA: Y\n    SA_PASSWORD: yourStrong(!)Password\n    MSSQL_PID: Developer\n  when:\n    event:\n    - push\n    - tag\n    - pull_request"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3251953125,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n*.db\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n\n*.log\n.vendor\ntemp_test.go\n.vscode\nxorm.test\n*.sqlite3\ntest.db.sql\n\n.idea/\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.884765625,
          "content": "## Contributing to xorm\n\n`xorm` has a backlog of [pull requests](https://help.github.com/articles/using-pull-requests), but contributions are still very\nmuch welcome. You can help with patch review, submitting bug reports,\nor adding new functionality. There is no formal style guide, but\nplease conform to the style of existing code and general Go formatting\nconventions when submitting patches.\n\n* [fork a repo](https://help.github.com/articles/fork-a-repo)\n* [creating a pull request ](https://help.github.com/articles/creating-a-pull-request)\n\n### Language\n\nSince `xorm` is a world-wide open source project, please describe your issues or code changes in English as soon as possible.\n\n### Sign your codes with comments\n```\n// !<you github id>! your comments\n\ne.g.,\n\n// !lunny! this is comments made by lunny\n```\n\n### Patch review\n\nHelp review existing open [pull requests](https://help.github.com/articles/using-pull-requests) by commenting on the code or\nproposed functionality.\n\n### Bug reports\n\nWe appreciate any bug reports, but especially ones with self-contained\n(doesn't depend on code outside of xorm), minimal (can't be simplified\nfurther) test cases. It's especially helpful if you can submit a pull\nrequest with just the failing test case(you can find some example test file like [session_get_test.go](https://github.com/go-xorm/xorm/blob/master/session_get_test.go)).\n\nIf you implements a new database interface, you maybe need to add a test_<databasename>.sh file.\nFor example, [mysql_test.go](https://github.com/go-xorm/xorm/blob/master/test_mysql.sh)\n\n### New functionality\n\nThere are a number of pending patches for new functionality, so\nadditional feature patches will take a while to merge. Still, patches\nare generally reviewed based on usefulness and complexity in addition\nto time-in-queue, so if you have a knockout idea, take a shot. Feel\nfree to open an issue discussion your proposed patch beforehand.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.462890625,
          "content": "Copyright (c) 2013 - 2015 The Xorm Authors\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of the {organization} nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.6279296875,
          "content": "# xorm HAS BEEN MOVED TO https://gitea.com/xorm/xorm . THIS REPOSITORY WILL NOT BE UPDATED ANY MORE.\n\n[中文](https://github.com/go-xorm/xorm/blob/master/README_CN.md)\n\nXorm is a simple and powerful ORM for Go.\n\n[![CircleCI](https://circleci.com/gh/go-xorm/xorm.svg?style=shield)](https://circleci.com/gh/go-xorm/xorm) [![codecov](https://codecov.io/gh/go-xorm/xorm/branch/master/graph/badge.svg)](https://codecov.io/gh/go-xorm/xorm)\n[![](https://goreportcard.com/badge/github.com/go-xorm/xorm)](https://goreportcard.com/report/github.com/go-xorm/xorm) \n[![Join the chat at https://img.shields.io/discord/323460943201959939.svg](https://img.shields.io/discord/323460943201959939.svg)](https://discord.gg/HuR2CF3)\n\n## Features\n\n* Struct <-> Table Mapping Support\n\n* Chainable APIs\n\n* Transaction Support\n\n* Both ORM and raw SQL operation Support\n\n* Sync database schema Support\n\n* Query Cache speed up\n\n* Database Reverse support, See [Xorm Tool README](https://github.com/go-xorm/cmd/blob/master/README.md)\n\n* Simple cascade loading support\n\n* Optimistic Locking support\n\n* SQL Builder support via [xorm.io/builder](https://xorm.io/builder)\n\n* Automatical Read/Write seperatelly\n\n* Postgres schema support\n\n* Context Cache support\n\n## Drivers Support\n\nDrivers for Go's sql package which currently support database/sql includes:\n\n* Mysql: [github.com/go-sql-driver/mysql](https://github.com/go-sql-driver/mysql)\n\n* MyMysql: [github.com/ziutek/mymysql/godrv](https://github.com/ziutek/mymysql/tree/master/godrv)\n\n* Postgres: [github.com/lib/pq](https://github.com/lib/pq)\n\n* Tidb: [github.com/pingcap/tidb](https://github.com/pingcap/tidb)\n\n* SQLite: [github.com/mattn/go-sqlite3](https://github.com/mattn/go-sqlite3)\n\n* MsSql: [github.com/denisenkom/go-mssqldb](https://github.com/denisenkom/go-mssqldb)\n\n* Oracle: [github.com/mattn/go-oci8](https://github.com/mattn/go-oci8) (experiment)\n\n## Installation\n\n\tgo get github.com/go-xorm/xorm\n\n## Documents\n\n* [Manual](http://xorm.io/docs)\n\n* [GoDoc](http://godoc.org/github.com/go-xorm/xorm)\n\n## Quick Start\n\n* Create Engine\n\n```Go\nengine, err := xorm.NewEngine(driverName, dataSourceName)\n```\n\n* Define a struct and Sync2 table struct to database\n\n```Go\ntype User struct {\n    Id int64\n    Name string\n    Salt string\n    Age int\n    Passwd string `xorm:\"varchar(200)\"`\n    Created time.Time `xorm:\"created\"`\n    Updated time.Time `xorm:\"updated\"`\n}\n\nerr := engine.Sync2(new(User))\n```\n\n* Create Engine Group\n\n```Go\ndataSourceNameSlice := []string{masterDataSourceName, slave1DataSourceName, slave2DataSourceName}\nengineGroup, err := xorm.NewEngineGroup(driverName, dataSourceNameSlice)\n```\n\n```Go\nmasterEngine, err := xorm.NewEngine(driverName, masterDataSourceName)\nslave1Engine, err := xorm.NewEngine(driverName, slave1DataSourceName)\nslave2Engine, err := xorm.NewEngine(driverName, slave2DataSourceName)\nengineGroup, err := xorm.NewEngineGroup(masterEngine, []*Engine{slave1Engine, slave2Engine})\n```\n\nThen all place where `engine` you can just use `engineGroup`.\n\n* `Query` runs a SQL string, the returned results is `[]map[string][]byte`, `QueryString` returns `[]map[string]string`, `QueryInterface` returns `[]map[string]interface{}`.\n\n```Go\nresults, err := engine.Query(\"select * from user\")\nresults, err := engine.Where(\"a = 1\").Query()\n\nresults, err := engine.QueryString(\"select * from user\")\nresults, err := engine.Where(\"a = 1\").QueryString()\n\nresults, err := engine.QueryInterface(\"select * from user\")\nresults, err := engine.Where(\"a = 1\").QueryInterface()\n```\n\n* `Exec` runs a SQL string, it returns `affected` and `error`\n\n```Go\naffected, err := engine.Exec(\"update user set age = ? where name = ?\", age, name)\n```\n\n* `Insert` one or multiple records to database\n\n```Go\naffected, err := engine.Insert(&user)\n// INSERT INTO struct () values ()\n\naffected, err := engine.Insert(&user1, &user2)\n// INSERT INTO struct1 () values ()\n// INSERT INTO struct2 () values ()\n\naffected, err := engine.Insert(&users)\n// INSERT INTO struct () values (),(),()\n\naffected, err := engine.Insert(&user1, &users)\n// INSERT INTO struct1 () values ()\n// INSERT INTO struct2 () values (),(),()\n```\n\n* `Get` query one record from database\n\n```Go\nhas, err := engine.Get(&user)\n// SELECT * FROM user LIMIT 1\n\nhas, err := engine.Where(\"name = ?\", name).Desc(\"id\").Get(&user)\n// SELECT * FROM user WHERE name = ? ORDER BY id DESC LIMIT 1\n\nvar name string\nhas, err := engine.Table(&user).Where(\"id = ?\", id).Cols(\"name\").Get(&name)\n// SELECT name FROM user WHERE id = ?\n\nvar id int64\nhas, err := engine.Table(&user).Where(\"name = ?\", name).Cols(\"id\").Get(&id)\nhas, err := engine.SQL(\"select id from user\").Get(&id)\n// SELECT id FROM user WHERE name = ?\n\nvar valuesMap = make(map[string]string)\nhas, err := engine.Table(&user).Where(\"id = ?\", id).Get(&valuesMap)\n// SELECT * FROM user WHERE id = ?\n\nvar valuesSlice = make([]interface{}, len(cols))\nhas, err := engine.Table(&user).Where(\"id = ?\", id).Cols(cols...).Get(&valuesSlice)\n// SELECT col1, col2, col3 FROM user WHERE id = ?\n```\n\n* `Exist` check if one record exist on table\n\n```Go\nhas, err := testEngine.Exist(new(RecordExist))\n// SELECT * FROM record_exist LIMIT 1\n\nhas, err = testEngine.Exist(&RecordExist{\n\t\tName: \"test1\",\n\t})\n// SELECT * FROM record_exist WHERE name = ? LIMIT 1\n\nhas, err = testEngine.Where(\"name = ?\", \"test1\").Exist(&RecordExist{})\n// SELECT * FROM record_exist WHERE name = ? LIMIT 1\n\nhas, err = testEngine.SQL(\"select * from record_exist where name = ?\", \"test1\").Exist()\n// select * from record_exist where name = ?\n\nhas, err = testEngine.Table(\"record_exist\").Exist()\n// SELECT * FROM record_exist LIMIT 1\n\nhas, err = testEngine.Table(\"record_exist\").Where(\"name = ?\", \"test1\").Exist()\n// SELECT * FROM record_exist WHERE name = ? LIMIT 1\n```\n\n* `Find` query multiple records from database, also you can use join and extends\n\n```Go\nvar users []User\nerr := engine.Where(\"name = ?\", name).And(\"age > 10\").Limit(10, 0).Find(&users)\n// SELECT * FROM user WHERE name = ? AND age > 10 limit 10 offset 0\n\ntype Detail struct {\n    Id int64\n    UserId int64 `xorm:\"index\"`\n}\n\ntype UserDetail struct {\n    User `xorm:\"extends\"`\n    Detail `xorm:\"extends\"`\n}\n\nvar users []UserDetail\nerr := engine.Table(\"user\").Select(\"user.*, detail.*\").\n    Join(\"INNER\", \"detail\", \"detail.user_id = user.id\").\n    Where(\"user.name = ?\", name).Limit(10, 0).\n    Find(&users)\n// SELECT user.*, detail.* FROM user INNER JOIN detail WHERE user.name = ? limit 10 offset 0\n```\n\n* `Iterate` and `Rows` query multiple records and record by record handle, there are two methods Iterate and Rows\n\n```Go\nerr := engine.Iterate(&User{Name:name}, func(idx int, bean interface{}) error {\n    user := bean.(*User)\n    return nil\n})\n// SELECT * FROM user\n\nerr := engine.BufferSize(100).Iterate(&User{Name:name}, func(idx int, bean interface{}) error {\n    user := bean.(*User)\n    return nil\n})\n// SELECT * FROM user Limit 0, 100\n// SELECT * FROM user Limit 101, 100\n\nrows, err := engine.Rows(&User{Name:name})\n// SELECT * FROM user\ndefer rows.Close()\nbean := new(Struct)\nfor rows.Next() {\n    err = rows.Scan(bean)\n}\n```\n\n* `Update` update one or more records, default will update non-empty and non-zero fields except when you use Cols, AllCols and so on.\n\n```Go\naffected, err := engine.ID(1).Update(&user)\n// UPDATE user SET ... Where id = ?\n\naffected, err := engine.Update(&user, &User{Name:name})\n// UPDATE user SET ... Where name = ?\n\nvar ids = []int64{1, 2, 3}\naffected, err := engine.In(\"id\", ids).Update(&user)\n// UPDATE user SET ... Where id IN (?, ?, ?)\n\n// force update indicated columns by Cols\naffected, err := engine.ID(1).Cols(\"age\").Update(&User{Name:name, Age: 12})\n// UPDATE user SET age = ?, updated=? Where id = ?\n\n// force NOT update indicated columns by Omit\naffected, err := engine.ID(1).Omit(\"name\").Update(&User{Name:name, Age: 12})\n// UPDATE user SET age = ?, updated=? Where id = ?\n\naffected, err := engine.ID(1).AllCols().Update(&user)\n// UPDATE user SET name=?,age=?,salt=?,passwd=?,updated=? Where id = ?\n```\n\n* `Delete` delete one or more records, Delete MUST have condition\n\n```Go\naffected, err := engine.Where(...).Delete(&user)\n// DELETE FROM user Where ...\n\naffected, err := engine.ID(2).Delete(&user)\n// DELETE FROM user Where id = ?\n```\n\n* `Count` count records\n\n```Go\ncounts, err := engine.Count(&user)\n// SELECT count(*) AS total FROM user\n```\n\n* `FindAndCount` combines function `Find` with `Count` which is usually used in query by page\n\n```Go\nvar users []User\ncounts, err := engine.FindAndCount(&users)\n```\n\n* `Sum` sum functions\n\n```Go\nagesFloat64, err := engine.Sum(&user, \"age\")\n// SELECT sum(age) AS total FROM user\n\nagesInt64, err := engine.SumInt(&user, \"age\")\n// SELECT sum(age) AS total FROM user\n\nsumFloat64Slice, err := engine.Sums(&user, \"age\", \"score\")\n// SELECT sum(age), sum(score) FROM user\n\nsumInt64Slice, err := engine.SumsInt(&user, \"age\", \"score\")\n// SELECT sum(age), sum(score) FROM user\n```\n\n* Query conditions builder\n\n```Go\nerr := engine.Where(builder.NotIn(\"a\", 1, 2).And(builder.In(\"b\", \"c\", \"d\", \"e\"))).Find(&users)\n// SELECT id, name ... FROM user WHERE a NOT IN (?, ?) AND b IN (?, ?, ?)\n```\n\n* Multiple operations in one go routine, no transation here but resue session memory\n\n```Go\nsession := engine.NewSession()\ndefer session.Close()\n\nuser1 := Userinfo{Username: \"xiaoxiao\", Departname: \"dev\", Alias: \"lunny\", Created: time.Now()}\nif _, err := session.Insert(&user1); err != nil {\n    return err\n}\n\nuser2 := Userinfo{Username: \"yyy\"}\nif _, err := session.Where(\"id = ?\", 2).Update(&user2); err != nil {\n    return err\n}\n\nif _, err := session.Exec(\"delete from userinfo where username = ?\", user2.Username); err != nil {\n    return err\n}\n\nreturn nil\n```\n\n* Transation should on one go routine. There is transaction and resue session memory\n\n```Go\nsession := engine.NewSession()\ndefer session.Close()\n\n// add Begin() before any action\nif err := session.Begin(); err != nil {\n    // if returned then will rollback automatically\n    return err\n}\n\nuser1 := Userinfo{Username: \"xiaoxiao\", Departname: \"dev\", Alias: \"lunny\", Created: time.Now()}\nif _, err := session.Insert(&user1); err != nil {\n    return err\n}\n\nuser2 := Userinfo{Username: \"yyy\"}\nif _, err := session.Where(\"id = ?\", 2).Update(&user2); err != nil {\n    return err\n}\n\nif _, err := session.Exec(\"delete from userinfo where username = ?\", user2.Username); err != nil {\n    return err\n}\n\n// add Commit() after all actions\nreturn session.Commit()\n```\n\n* Or you can use `Transaction` to replace above codes.\n\n```Go\nres, err := engine.Transaction(func(session *xorm.Session) (interface{}, error) {\n    user1 := Userinfo{Username: \"xiaoxiao\", Departname: \"dev\", Alias: \"lunny\", Created: time.Now()}\n    if _, err := session.Insert(&user1); err != nil {\n        return nil, err\n    }\n\n    user2 := Userinfo{Username: \"yyy\"}\n    if _, err := session.Where(\"id = ?\", 2).Update(&user2); err != nil {\n        return nil, err\n    }\n\n    if _, err := session.Exec(\"delete from userinfo where username = ?\", user2.Username); err != nil {\n        return nil, err\n    }\n    return nil, nil\n})\n```\n\n* Context Cache, if enabled, current query result will be cached on session and be used by next same statement on the same session.\n\n```Go\n\tsess := engine.NewSession()\n\tdefer sess.Close()\n\n\tvar context = xorm.NewMemoryContextCache()\n\n\tvar c2 ContextGetStruct\n\thas, err := sess.ID(1).ContextCache(context).Get(&c2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 1, c2.Id)\n\tassert.EqualValues(t, \"1\", c2.Name)\n\tsql, args := sess.LastSQL()\n\tassert.True(t, len(sql) > 0)\n\tassert.True(t, len(args) > 0)\n\n\tvar c3 ContextGetStruct\n\thas, err = sess.ID(1).ContextCache(context).Get(&c3)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 1, c3.Id)\n\tassert.EqualValues(t, \"1\", c3.Name)\n\tsql, args = sess.LastSQL()\n\tassert.True(t, len(sql) == 0)\n\tassert.True(t, len(args) == 0)\n```\n\n## Contributing\n\nIf you want to pull request, please see [CONTRIBUTING](https://github.com/go-xorm/xorm/blob/master/CONTRIBUTING.md). And we also provide [Xorm on Google Groups](https://groups.google.com/forum/#!forum/xorm) to discuss.\n\n## Credits\n\n### Contributors\n\nThis project exists thanks to all the people who contribute. [[Contribute](CONTRIBUTING.md)].\n<a href=\"graphs/contributors\"><img src=\"https://opencollective.com/xorm/contributors.svg?width=890&button=false\" /></a>\n\n### Backers\n\nThank you to all our backers! 🙏 [[Become a backer](https://opencollective.com/xorm#backer)]\n\n<a href=\"https://opencollective.com/xorm#backers\" target=\"_blank\"><img src=\"https://opencollective.com/xorm/backers.svg?width=890\"></a>\n\n### Sponsors\n\nSupport this project by becoming a sponsor. Your logo will show up here with a link to your website. [[Become a sponsor](https://opencollective.com/xorm#sponsor)]\n\n## Changelog\n\n* **v0.7.0**\n    * Some bugs fixed\n\n* **v0.6.6**\n    * Some bugs fixed\n\n* **v0.6.5**\n    * Postgres schema support\n    * vgo support\n    * Add FindAndCount\n    * Database special params support via NewEngineWithParams\n    * Some bugs fixed\n\n* **v0.6.4**\n    * Automatical Read/Write seperatelly\n    * Query/QueryString/QueryInterface and action with Where/And\n    * Get support non-struct variables\n    * BufferSize on Iterate\n    * fix some other bugs.\n\n[More changes ...](https://github.com/go-xorm/manual-en-US/tree/master/chapter-16)\n\n## Cases\n\n* [studygolang](http://studygolang.com/) - [github.com/studygolang/studygolang](https://github.com/studygolang/studygolang)\n\n* [Gitea](http://gitea.io) - [github.com/go-gitea/gitea](http://github.com/go-gitea/gitea)\n\n* [Gogs](http://try.gogits.org) - [github.com/gogits/gogs](http://github.com/gogits/gogs)\n\n* [grafana](https://grafana.com/) - [github.com/grafana/grafana](http://github.com/grafana/grafana)\n\n* [github.com/m3ng9i/qreader](https://github.com/m3ng9i/qreader)\n\n* [Wego](http://github.com/go-tango/wego)\n\n* [Docker.cn](https://docker.cn/)\n\n* [Xorm Adapter](https://github.com/casbin/xorm-adapter) for [Casbin](https://github.com/casbin/casbin) - [github.com/casbin/xorm-adapter](https://github.com/casbin/xorm-adapter)\n\n* [Gorevel](http://gorevel.cn/) - [github.com/goofcc/gorevel](http://github.com/goofcc/gorevel)\n\n* [Gowalker](http://gowalker.org) - [github.com/Unknwon/gowalker](http://github.com/Unknwon/gowalker)\n\n* [Gobuild.io](http://gobuild.io) - [github.com/shxsun/gobuild](http://github.com/shxsun/gobuild)\n\n* [Sudo China](http://sudochina.com) - [github.com/insionng/toropress](http://github.com/insionng/toropress)\n\n* [Godaily](http://godaily.org) - [github.com/govc/godaily](http://github.com/govc/godaily)\n\n* [YouGam](http://www.yougam.com/)\n\n* [GoCMS - github.com/zzboy/GoCMS](https://github.com/zzdboy/GoCMS)\n\n* [GoBBS - gobbs.domolo.com](http://gobbs.domolo.com/)\n\n* [go-blog](http://wangcheng.me) - [github.com/easykoo/go-blog](https://github.com/easykoo/go-blog)\n\n## LICENSE\n\nBSD License [http://creativecommons.org/licenses/BSD/](http://creativecommons.org/licenses/BSD/)\n"
        },
        {
          "name": "README_CN.md",
          "type": "blob",
          "size": 14.42578125,
          "content": "# xorm\n\n[English](https://github.com/go-xorm/xorm/blob/master/README.md)\n\nxorm是一个简单而强大的Go语言ORM库. 通过它可以使数据库操作非常简便。\n\n[![CircleCI](https://circleci.com/gh/go-xorm/xorm.svg?style=shield)](https://circleci.com/gh/go-xorm/xorm) [![codecov](https://codecov.io/gh/go-xorm/xorm/branch/master/graph/badge.svg)](https://codecov.io/gh/go-xorm/xorm)\n[![](https://goreportcard.com/badge/github.com/go-xorm/xorm)](https://goreportcard.com/report/github.com/go-xorm/xorm)\n[![Join the chat at https://img.shields.io/discord/323460943201959939.svg](https://img.shields.io/discord/323460943201959939.svg)](https://discord.gg/HuR2CF3)\n\n## 特性\n\n* 支持Struct和数据库表之间的灵活映射，并支持自动同步\n\n* 事务支持\n\n* 同时支持原始SQL语句和ORM操作的混合执行\n\n* 使用连写来简化调用\n\n* 支持使用Id, In, Where, Limit, Join, Having, Table, Sql, Cols等函数和结构体等方式作为条件\n\n* 支持级联加载Struct\n\n* Schema支持（仅Postgres）\n\n* 支持缓存\n\n* 支持根据数据库自动生成xorm的结构体\n\n* 支持记录版本（即乐观锁）\n\n* 内置SQL Builder支持\n\n* 上下文缓存支持\n\n## 驱动支持\n\n目前支持的Go数据库驱动和对应的数据库如下：\n\n* Mysql: [github.com/go-sql-driver/mysql](https://github.com/go-sql-driver/mysql)\n\n* MyMysql: [github.com/ziutek/mymysql/godrv](https://github.com/ziutek/mymysql/godrv)\n\n* Postgres: [github.com/lib/pq](https://github.com/lib/pq)\n\n* Tidb: [github.com/pingcap/tidb](https://github.com/pingcap/tidb)\n\n* SQLite: [github.com/mattn/go-sqlite3](https://github.com/mattn/go-sqlite3)\n\n* MsSql: [github.com/denisenkom/go-mssqldb](https://github.com/denisenkom/go-mssqldb)\n\n* MsSql: [github.com/lunny/godbc](https://github.com/lunny/godbc)\n\n* Oracle: [github.com/mattn/go-oci8](https://github.com/mattn/go-oci8) (试验性支持)\n\n## 安装\n\n\tgo get github.com/go-xorm/xorm\n\n## 文档\n\n* [操作指南](http://xorm.io/docs)\n\n* [GoWalker代码文档](http://gowalker.org/github.com/go-xorm/xorm)\n\n* [Godoc代码文档](http://godoc.org/github.com/go-xorm/xorm)\n\n# 快速开始\n\n* 第一步创建引擎，driverName, dataSourceName和database/sql接口相同\n\n```Go\nengine, err := xorm.NewEngine(driverName, dataSourceName)\n```\n\n* 定义一个和表同步的结构体，并且自动同步结构体到数据库\n\n```Go\ntype User struct {\n    Id int64\n    Name string\n    Salt string\n    Age int\n    Passwd string `xorm:\"varchar(200)\"`\n    Created time.Time `xorm:\"created\"`\n    Updated time.Time `xorm:\"updated\"`\n}\n\nerr := engine.Sync2(new(User))\n```\n\n* 创建Engine组\n\n```Go\ndataSourceNameSlice := []string{masterDataSourceName, slave1DataSourceName, slave2DataSourceName}\nengineGroup, err := xorm.NewEngineGroup(driverName, dataSourceNameSlice)\n```\n\n```Go\nmasterEngine, err := xorm.NewEngine(driverName, masterDataSourceName)\nslave1Engine, err := xorm.NewEngine(driverName, slave1DataSourceName)\nslave2Engine, err := xorm.NewEngine(driverName, slave2DataSourceName)\nengineGroup, err := xorm.NewEngineGroup(masterEngine, []*Engine{slave1Engine, slave2Engine})\n```\n\n所有使用 `engine` 都可以简单的用 `engineGroup` 来替换。\n\n* `Query` 最原始的也支持SQL语句查询，返回的结果类型为 []map[string][]byte。`QueryString` 返回 []map[string]string, `QueryInterface` 返回 `[]map[string]interface{}`.\n\n```Go\nresults, err := engine.Query(\"select * from user\")\nresults, err := engine.Where(\"a = 1\").Query()\n\nresults, err := engine.QueryString(\"select * from user\")\nresults, err := engine.Where(\"a = 1\").QueryString()\n\nresults, err := engine.QueryInterface(\"select * from user\")\nresults, err := engine.Where(\"a = 1\").QueryInterface()\n```\n\n* `Exec` 执行一个SQL语句\n\n```Go\naffected, err := engine.Exec(\"update user set age = ? where name = ?\", age, name)\n```\n\n* `Insert` 插入一条或者多条记录\n\n```Go\naffected, err := engine.Insert(&user)\n// INSERT INTO struct () values ()\n\naffected, err := engine.Insert(&user1, &user2)\n// INSERT INTO struct1 () values ()\n// INSERT INTO struct2 () values ()\n\naffected, err := engine.Insert(&users)\n// INSERT INTO struct () values (),(),()\n\naffected, err := engine.Insert(&user1, &users)\n// INSERT INTO struct1 () values ()\n// INSERT INTO struct2 () values (),(),()\n```\n\n* `Get` 查询单条记录\n\n```Go\nhas, err := engine.Get(&user)\n// SELECT * FROM user LIMIT 1\n\nhas, err := engine.Where(\"name = ?\", name).Desc(\"id\").Get(&user)\n// SELECT * FROM user WHERE name = ? ORDER BY id DESC LIMIT 1\n\nvar name string\nhas, err := engine.Table(&user).Where(\"id = ?\", id).Cols(\"name\").Get(&name)\n// SELECT name FROM user WHERE id = ?\n\nvar id int64\nhas, err := engine.Table(&user).Where(\"name = ?\", name).Cols(\"id\").Get(&id)\nhas, err := engine.SQL(\"select id from user\").Get(&id)\n// SELECT id FROM user WHERE name = ?\n\nvar valuesMap = make(map[string]string)\nhas, err := engine.Table(&user).Where(\"id = ?\", id).Get(&valuesMap)\n// SELECT * FROM user WHERE id = ?\n\nvar valuesSlice = make([]interface{}, len(cols))\nhas, err := engine.Table(&user).Where(\"id = ?\", id).Cols(cols...).Get(&valuesSlice)\n// SELECT col1, col2, col3 FROM user WHERE id = ?\n```\n\n* `Exist` 检测记录是否存在\n\n```Go\nhas, err := testEngine.Exist(new(RecordExist))\n// SELECT * FROM record_exist LIMIT 1\n\nhas, err = testEngine.Exist(&RecordExist{\n\t\tName: \"test1\",\n\t})\n// SELECT * FROM record_exist WHERE name = ? LIMIT 1\n\nhas, err = testEngine.Where(\"name = ?\", \"test1\").Exist(&RecordExist{})\n// SELECT * FROM record_exist WHERE name = ? LIMIT 1\n\nhas, err = testEngine.SQL(\"select * from record_exist where name = ?\", \"test1\").Exist()\n// select * from record_exist where name = ?\n\nhas, err = testEngine.Table(\"record_exist\").Exist()\n// SELECT * FROM record_exist LIMIT 1\n\nhas, err = testEngine.Table(\"record_exist\").Where(\"name = ?\", \"test1\").Exist()\n// SELECT * FROM record_exist WHERE name = ? LIMIT 1\n```\n\n* `Find` 查询多条记录，当然可以使用Join和extends来组合使用\n\n```Go\nvar users []User\nerr := engine.Where(\"name = ?\", name).And(\"age > 10\").Limit(10, 0).Find(&users)\n// SELECT * FROM user WHERE name = ? AND age > 10 limit 10 offset 0\n\ntype Detail struct {\n    Id int64\n    UserId int64 `xorm:\"index\"`\n}\n\ntype UserDetail struct {\n    User `xorm:\"extends\"`\n    Detail `xorm:\"extends\"`\n}\n\nvar users []UserDetail\nerr := engine.Table(\"user\").Select(\"user.*, detail.*\")\n    Join(\"INNER\", \"detail\", \"detail.user_id = user.id\").\n    Where(\"user.name = ?\", name).Limit(10, 0).\n    Find(&users)\n// SELECT user.*, detail.* FROM user INNER JOIN detail WHERE user.name = ? limit 10 offset 0\n```\n\n* `Iterate` 和 `Rows` 根据条件遍历数据库，可以有两种方式: Iterate and Rows\n\n```Go\nerr := engine.Iterate(&User{Name:name}, func(idx int, bean interface{}) error {\n    user := bean.(*User)\n    return nil\n})\n// SELECT * FROM user\n\nerr := engine.BufferSize(100).Iterate(&User{Name:name}, func(idx int, bean interface{}) error {\n    user := bean.(*User)\n    return nil\n})\n// SELECT * FROM user Limit 0, 100\n// SELECT * FROM user Limit 101, 100\n\nrows, err := engine.Rows(&User{Name:name})\n// SELECT * FROM user\ndefer rows.Close()\nbean := new(Struct)\nfor rows.Next() {\n    err = rows.Scan(bean)\n}\n```\n\n* `Update` 更新数据，除非使用Cols,AllCols函数指明，默认只更新非空和非0的字段\n\n```Go\naffected, err := engine.ID(1).Update(&user)\n// UPDATE user SET ... Where id = ?\n\naffected, err := engine.Update(&user, &User{Name:name})\n// UPDATE user SET ... Where name = ?\n\nvar ids = []int64{1, 2, 3}\naffected, err := engine.In(ids).Update(&user)\n// UPDATE user SET ... Where id IN (?, ?, ?)\n\n// force update indicated columns by Cols\naffected, err := engine.ID(1).Cols(\"age\").Update(&User{Name:name, Age: 12})\n// UPDATE user SET age = ?, updated=? Where id = ?\n\n// force NOT update indicated columns by Omit\naffected, err := engine.ID(1).Omit(\"name\").Update(&User{Name:name, Age: 12})\n// UPDATE user SET age = ?, updated=? Where id = ?\n\naffected, err := engine.ID(1).AllCols().Update(&user)\n// UPDATE user SET name=?,age=?,salt=?,passwd=?,updated=? Where id = ?\n```\n\n* `Delete` 删除记录，需要注意，删除必须至少有一个条件，否则会报错。要清空数据库可以用EmptyTable\n\n```Go\naffected, err := engine.Where(...).Delete(&user)\n// DELETE FROM user Where ...\n\naffected, err := engine.ID(2).Delete(&user)\n// DELETE FROM user Where id = ?\n```\n\n* `Count` 获取记录条数\n\n```Go\ncounts, err := engine.Count(&user)\n// SELECT count(*) AS total FROM user\n```\n\n* `Sum` 求和函数\n\n```Go\nagesFloat64, err := engine.Sum(&user, \"age\")\n// SELECT sum(age) AS total FROM user\n\nagesInt64, err := engine.SumInt(&user, \"age\")\n// SELECT sum(age) AS total FROM user\n\nsumFloat64Slice, err := engine.Sums(&user, \"age\", \"score\")\n// SELECT sum(age), sum(score) FROM user\n\nsumInt64Slice, err := engine.SumsInt(&user, \"age\", \"score\")\n// SELECT sum(age), sum(score) FROM user\n```\n\n* 条件编辑器\n\n```Go\nerr := engine.Where(builder.NotIn(\"a\", 1, 2).And(builder.In(\"b\", \"c\", \"d\", \"e\"))).Find(&users)\n// SELECT id, name ... FROM user WHERE a NOT IN (?, ?) AND b IN (?, ?, ?)\n```\n\n* 在一个Go程中多次操作数据库，但没有事务\n\n```Go\nsession := engine.NewSession()\ndefer session.Close()\n\nuser1 := Userinfo{Username: \"xiaoxiao\", Departname: \"dev\", Alias: \"lunny\", Created: time.Now()}\nif _, err := session.Insert(&user1); err != nil {\n    return err\n}\n\nuser2 := Userinfo{Username: \"yyy\"}\nif _, err := session.Where(\"id = ?\", 2).Update(&user2); err != nil {\n    return err\n}\n\nif _, err := session.Exec(\"delete from userinfo where username = ?\", user2.Username); err != nil {\n    return err\n}\n\nreturn nil\n```\n\n* 在一个Go程中有事务\n\n```Go\nsession := engine.NewSession()\ndefer session.Close()\n\n// add Begin() before any action\nif err := session.Begin(); err != nil {\n    // if returned then will rollback automatically\n    return err\n}\n\nuser1 := Userinfo{Username: \"xiaoxiao\", Departname: \"dev\", Alias: \"lunny\", Created: time.Now()}\nif _, err := session.Insert(&user1); err != nil {\n    return err\n}\n\nuser2 := Userinfo{Username: \"yyy\"}\nif _, err := session.Where(\"id = ?\", 2).Update(&user2); err != nil {\n    return err\n}\n\nif _, err := session.Exec(\"delete from userinfo where username = ?\", user2.Username); err != nil {\n    return err\n}\n\n// add Commit() after all actions\nreturn session.Commit()\n```\n\n* 事务的简写方法\n\n```Go\nres, err := engine.Transaction(func(session *xorm.Session) (interface{}, error) {\n    user1 := Userinfo{Username: \"xiaoxiao\", Departname: \"dev\", Alias: \"lunny\", Created: time.Now()}\n    if _, err := session.Insert(&user1); err != nil {\n        return nil, err\n    }\n\n    user2 := Userinfo{Username: \"yyy\"}\n    if _, err := session.Where(\"id = ?\", 2).Update(&user2); err != nil {\n        return nil, err\n    }\n\n    if _, err := session.Exec(\"delete from userinfo where username = ?\", user2.Username); err != nil {\n        return nil, err\n    }\n    return nil, nil\n})\n```\n\n* 上下文缓存，如果启用，那么针对单个对象的查询将会被缓存到系统中，可以被下一个查询使用。\n\n```Go\n\tsess := engine.NewSession()\n\tdefer sess.Close()\n\n\tvar context = xorm.NewMemoryContextCache()\n\n\tvar c2 ContextGetStruct\n\thas, err := sess.ID(1).ContextCache(context).Get(&c2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 1, c2.Id)\n\tassert.EqualValues(t, \"1\", c2.Name)\n\tsql, args := sess.LastSQL()\n\tassert.True(t, len(sql) > 0)\n\tassert.True(t, len(args) > 0)\n\n\tvar c3 ContextGetStruct\n\thas, err = sess.ID(1).ContextCache(context).Get(&c3)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 1, c3.Id)\n\tassert.EqualValues(t, \"1\", c3.Name)\n\tsql, args = sess.LastSQL()\n\tassert.True(t, len(sql) == 0)\n\tassert.True(t, len(args) == 0)\n```\n\n## 贡献\n\n如果您也想为Xorm贡献您的力量，请查看 [CONTRIBUTING](https://github.com/go-xorm/xorm/blob/master/CONTRIBUTING.md)。您也可以加入QQ群  技术帮助和讨论。\n群一：280360085 （已满）\n群二：795010183\n\n## Credits\n\n### Contributors\n\n感谢所有的贡献者. [[Contribute](CONTRIBUTING.md)].\n<a href=\"graphs/contributors\"><img src=\"https://opencollective.com/xorm/contributors.svg?width=890&button=false\" /></a>\n\n### Backers\n\n感谢我们所有的 backers! 🙏 [[成为 backer](https://opencollective.com/xorm#backer)]\n\n<a href=\"https://opencollective.com/xorm#backers\" target=\"_blank\"><img src=\"https://opencollective.com/xorm/backers.svg?width=890\"></a>\n\n### Sponsors\n\n成为 sponsor 来支持 xorm。您的 logo 将会被显示并被链接到您的网站。 [[成为 sponsor](https://opencollective.com/xorm#sponsor)]\n\n# 案例\n\n* [Go语言中文网](http://studygolang.com/) - [github.com/studygolang/studygolang](https://github.com/studygolang/studygolang)\n\n* [Gitea](http://gitea.io) - [github.com/go-gitea/gitea](http://github.com/go-gitea/gitea)\n\n* [Gogs](http://try.gogits.org) - [github.com/gogits/gogs](http://github.com/gogits/gogs)\n\n* [grafana](https://grafana.com/) - [github.com/grafana/grafana](http://github.com/grafana/grafana)\n\n* [github.com/m3ng9i/qreader](https://github.com/m3ng9i/qreader)\n\n* [Wego](http://github.com/go-tango/wego)\n\n* [Docker.cn](https://docker.cn/)\n\n* [Xorm Adapter](https://github.com/casbin/xorm-adapter) for [Casbin](https://github.com/casbin/casbin) - [github.com/casbin/xorm-adapter](https://github.com/casbin/xorm-adapter)\n\n* [Gowalker](http://gowalker.org) - [github.com/Unknwon/gowalker](http://github.com/Unknwon/gowalker)\n\n* [Gobuild.io](http://gobuild.io) - [github.com/shxsun/gobuild](http://github.com/shxsun/gobuild)\n\n* [Sudo China](http://sudochina.com) - [github.com/insionng/toropress](http://github.com/insionng/toropress)\n\n* [Godaily](http://godaily.org) - [github.com/govc/godaily](http://github.com/govc/godaily)\n\n* [YouGam](http://www.yougam.com/)\n\n* [GoCMS - github.com/zzboy/GoCMS](https://github.com/zzdboy/GoCMS)\n\n* [GoBBS - gobbs.domolo.com](http://gobbs.domolo.com/)\n\n* [go-blog](http://wangcheng.me) - [github.com/easykoo/go-blog](https://github.com/easykoo/go-blog)\n\n\n## 更新日志\n\n* **v0.7.0**\n    * 修正部分Bug\n\n* **v0.6.6**\n    * 修正部分Bug\n\n* **v0.6.5**\n    * 通过 engine.SetSchema 来支持 schema，当前仅支持Postgres\n    * vgo 支持\n    * 新增 `FindAndCount` 函数\n    * 通过 `NewEngineWithParams` 支持数据库特别参数\n    * 修正部分Bug\n\n* **v0.6.4**\n    * 自动读写分离支持\n    * Query/QueryString/QueryInterface 支持与 Where/And 合用\n    * `Get` 支持获取非结构体变量\n    * `Iterate` 支持 `BufferSize` \n    * 修正部分Bug\n\n[更多更新日志...](https://github.com/go-xorm/manual-zh-CN/tree/master/chapter-16)\n\n## LICENSE\n\nBSD License\n[http://creativecommons.org/licenses/BSD/](http://creativecommons.org/licenses/BSD/)\n"
        },
        {
          "name": "cache_lru.go",
          "type": "blob",
          "size": 6.947265625,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"container/list\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"xorm.io/core\"\n)\n\n// LRUCacher implments cache object facilities\ntype LRUCacher struct {\n\tidList         *list.List\n\tsqlList        *list.List\n\tidIndex        map[string]map[string]*list.Element\n\tsqlIndex       map[string]map[string]*list.Element\n\tstore          core.CacheStore\n\tmutex          sync.Mutex\n\tMaxElementSize int\n\tExpired        time.Duration\n\tGcInterval     time.Duration\n}\n\n// NewLRUCacher creates a cacher\nfunc NewLRUCacher(store core.CacheStore, maxElementSize int) *LRUCacher {\n\treturn NewLRUCacher2(store, 3600*time.Second, maxElementSize)\n}\n\n// NewLRUCacher2 creates a cache include different params\nfunc NewLRUCacher2(store core.CacheStore, expired time.Duration, maxElementSize int) *LRUCacher {\n\tcacher := &LRUCacher{store: store, idList: list.New(),\n\t\tsqlList: list.New(), Expired: expired,\n\t\tGcInterval: core.CacheGcInterval, MaxElementSize: maxElementSize,\n\t\tsqlIndex: make(map[string]map[string]*list.Element),\n\t\tidIndex:  make(map[string]map[string]*list.Element),\n\t}\n\tcacher.RunGC()\n\treturn cacher\n}\n\n// RunGC run once every m.GcInterval\nfunc (m *LRUCacher) RunGC() {\n\ttime.AfterFunc(m.GcInterval, func() {\n\t\tm.RunGC()\n\t\tm.GC()\n\t})\n}\n\n// GC check ids lit and sql list to remove all element expired\nfunc (m *LRUCacher) GC() {\n\tm.mutex.Lock()\n\tdefer m.mutex.Unlock()\n\tvar removedNum int\n\tfor e := m.idList.Front(); e != nil; {\n\t\tif removedNum <= core.CacheGcMaxRemoved &&\n\t\t\ttime.Now().Sub(e.Value.(*idNode).lastVisit) > m.Expired {\n\t\t\tremovedNum++\n\t\t\tnext := e.Next()\n\t\t\tnode := e.Value.(*idNode)\n\t\t\tm.delBean(node.tbName, node.id)\n\t\t\te = next\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tremovedNum = 0\n\tfor e := m.sqlList.Front(); e != nil; {\n\t\tif removedNum <= core.CacheGcMaxRemoved &&\n\t\t\ttime.Now().Sub(e.Value.(*sqlNode).lastVisit) > m.Expired {\n\t\t\tremovedNum++\n\t\t\tnext := e.Next()\n\t\t\tnode := e.Value.(*sqlNode)\n\t\t\tm.delIds(node.tbName, node.sql)\n\t\t\te = next\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// GetIds returns all bean's ids according to sql and parameter from cache\nfunc (m *LRUCacher) GetIds(tableName, sql string) interface{} {\n\tm.mutex.Lock()\n\tdefer m.mutex.Unlock()\n\tif _, ok := m.sqlIndex[tableName]; !ok {\n\t\tm.sqlIndex[tableName] = make(map[string]*list.Element)\n\t}\n\tif v, err := m.store.Get(sql); err == nil {\n\t\tif el, ok := m.sqlIndex[tableName][sql]; !ok {\n\t\t\tel = m.sqlList.PushBack(newSQLNode(tableName, sql))\n\t\t\tm.sqlIndex[tableName][sql] = el\n\t\t} else {\n\t\t\tlastTime := el.Value.(*sqlNode).lastVisit\n\t\t\t// if expired, remove the node and return nil\n\t\t\tif time.Now().Sub(lastTime) > m.Expired {\n\t\t\t\tm.delIds(tableName, sql)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tm.sqlList.MoveToBack(el)\n\t\t\tel.Value.(*sqlNode).lastVisit = time.Now()\n\t\t}\n\t\treturn v\n\t}\n\n\tm.delIds(tableName, sql)\n\treturn nil\n}\n\n// GetBean returns bean according tableName and id from cache\nfunc (m *LRUCacher) GetBean(tableName string, id string) interface{} {\n\tm.mutex.Lock()\n\tdefer m.mutex.Unlock()\n\tif _, ok := m.idIndex[tableName]; !ok {\n\t\tm.idIndex[tableName] = make(map[string]*list.Element)\n\t}\n\ttid := genID(tableName, id)\n\tif v, err := m.store.Get(tid); err == nil {\n\t\tif el, ok := m.idIndex[tableName][id]; ok {\n\t\t\tlastTime := el.Value.(*idNode).lastVisit\n\t\t\t// if expired, remove the node and return nil\n\t\t\tif time.Now().Sub(lastTime) > m.Expired {\n\t\t\t\tm.delBean(tableName, id)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tm.idList.MoveToBack(el)\n\t\t\tel.Value.(*idNode).lastVisit = time.Now()\n\t\t} else {\n\t\t\tel = m.idList.PushBack(newIDNode(tableName, id))\n\t\t\tm.idIndex[tableName][id] = el\n\t\t}\n\t\treturn v\n\t}\n\n\t// store bean is not exist, then remove memory's index\n\tm.delBean(tableName, id)\n\treturn nil\n}\n\n// clearIds clears all sql-ids mapping on table tableName from cache\nfunc (m *LRUCacher) clearIds(tableName string) {\n\tif tis, ok := m.sqlIndex[tableName]; ok {\n\t\tfor sql, v := range tis {\n\t\t\tm.sqlList.Remove(v)\n\t\t\tm.store.Del(sql)\n\t\t}\n\t}\n\tm.sqlIndex[tableName] = make(map[string]*list.Element)\n}\n\n// ClearIds clears all sql-ids mapping on table tableName from cache\nfunc (m *LRUCacher) ClearIds(tableName string) {\n\tm.mutex.Lock()\n\tm.clearIds(tableName)\n\tm.mutex.Unlock()\n}\n\nfunc (m *LRUCacher) clearBeans(tableName string) {\n\tif tis, ok := m.idIndex[tableName]; ok {\n\t\tfor id, v := range tis {\n\t\t\tm.idList.Remove(v)\n\t\t\ttid := genID(tableName, id)\n\t\t\tm.store.Del(tid)\n\t\t}\n\t}\n\tm.idIndex[tableName] = make(map[string]*list.Element)\n}\n\n// ClearBeans clears all beans in some table\nfunc (m *LRUCacher) ClearBeans(tableName string) {\n\tm.mutex.Lock()\n\tm.clearBeans(tableName)\n\tm.mutex.Unlock()\n}\n\n// PutIds pus ids into table\nfunc (m *LRUCacher) PutIds(tableName, sql string, ids interface{}) {\n\tm.mutex.Lock()\n\tif _, ok := m.sqlIndex[tableName]; !ok {\n\t\tm.sqlIndex[tableName] = make(map[string]*list.Element)\n\t}\n\tif el, ok := m.sqlIndex[tableName][sql]; !ok {\n\t\tel = m.sqlList.PushBack(newSQLNode(tableName, sql))\n\t\tm.sqlIndex[tableName][sql] = el\n\t} else {\n\t\tel.Value.(*sqlNode).lastVisit = time.Now()\n\t}\n\tm.store.Put(sql, ids)\n\tif m.sqlList.Len() > m.MaxElementSize {\n\t\te := m.sqlList.Front()\n\t\tnode := e.Value.(*sqlNode)\n\t\tm.delIds(node.tbName, node.sql)\n\t}\n\tm.mutex.Unlock()\n}\n\n// PutBean puts beans into table\nfunc (m *LRUCacher) PutBean(tableName string, id string, obj interface{}) {\n\tm.mutex.Lock()\n\tvar el *list.Element\n\tvar ok bool\n\n\tif el, ok = m.idIndex[tableName][id]; !ok {\n\t\tel = m.idList.PushBack(newIDNode(tableName, id))\n\t\tm.idIndex[tableName][id] = el\n\t} else {\n\t\tel.Value.(*idNode).lastVisit = time.Now()\n\t}\n\n\tm.store.Put(genID(tableName, id), obj)\n\tif m.idList.Len() > m.MaxElementSize {\n\t\te := m.idList.Front()\n\t\tnode := e.Value.(*idNode)\n\t\tm.delBean(node.tbName, node.id)\n\t}\n\tm.mutex.Unlock()\n}\n\nfunc (m *LRUCacher) delIds(tableName, sql string) {\n\tif _, ok := m.sqlIndex[tableName]; ok {\n\t\tif el, ok := m.sqlIndex[tableName][sql]; ok {\n\t\t\tdelete(m.sqlIndex[tableName], sql)\n\t\t\tm.sqlList.Remove(el)\n\t\t}\n\t}\n\tm.store.Del(sql)\n}\n\n// DelIds deletes ids\nfunc (m *LRUCacher) DelIds(tableName, sql string) {\n\tm.mutex.Lock()\n\tm.delIds(tableName, sql)\n\tm.mutex.Unlock()\n}\n\nfunc (m *LRUCacher) delBean(tableName string, id string) {\n\ttid := genID(tableName, id)\n\tif el, ok := m.idIndex[tableName][id]; ok {\n\t\tdelete(m.idIndex[tableName], id)\n\t\tm.idList.Remove(el)\n\t\tm.clearIds(tableName)\n\t}\n\tm.store.Del(tid)\n}\n\n// DelBean deletes beans in some table\nfunc (m *LRUCacher) DelBean(tableName string, id string) {\n\tm.mutex.Lock()\n\tm.delBean(tableName, id)\n\tm.mutex.Unlock()\n}\n\ntype idNode struct {\n\ttbName    string\n\tid        string\n\tlastVisit time.Time\n}\n\ntype sqlNode struct {\n\ttbName    string\n\tsql       string\n\tlastVisit time.Time\n}\n\nfunc genSQLKey(sql string, args interface{}) string {\n\treturn fmt.Sprintf(\"%v-%v\", sql, args)\n}\n\nfunc genID(prefix string, id string) string {\n\treturn fmt.Sprintf(\"%v-%v\", prefix, id)\n}\n\nfunc newIDNode(tbName string, id string) *idNode {\n\treturn &idNode{tbName, id, time.Now()}\n}\n\nfunc newSQLNode(tbName, sql string) *sqlNode {\n\treturn &sqlNode{tbName, sql, time.Now()}\n}\n"
        },
        {
          "name": "cache_lru_test.go",
          "type": "blob",
          "size": 1.1083984375,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"testing\"\n\n\t\"xorm.io/core\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestLRUCache(t *testing.T) {\n\ttype CacheObject1 struct {\n\t\tId int64\n\t}\n\n\tstore := NewMemoryStore()\n\tcacher := NewLRUCacher(store, 10000)\n\n\ttableName := \"cache_object1\"\n\tpks := []core.PK{\n\t\t{1},\n\t\t{2},\n\t}\n\n\tfor _, pk := range pks {\n\t\tsid, err := pk.ToString()\n\t\tassert.NoError(t, err)\n\n\t\tcacher.PutIds(tableName, \"select * from cache_object1\", sid)\n\t\tids := cacher.GetIds(tableName, \"select * from cache_object1\")\n\t\tassert.EqualValues(t, sid, ids)\n\n\t\tcacher.ClearIds(tableName)\n\t\tids2 := cacher.GetIds(tableName, \"select * from cache_object1\")\n\t\tassert.Nil(t, ids2)\n\n\t\tobj2 := cacher.GetBean(tableName, sid)\n\t\tassert.Nil(t, obj2)\n\n\t\tvar obj = new(CacheObject1)\n\t\tcacher.PutBean(tableName, sid, obj)\n\t\tobj3 := cacher.GetBean(tableName, sid)\n\t\tassert.EqualValues(t, obj, obj3)\n\n\t\tcacher.DelBean(tableName, sid)\n\t\tobj4 := cacher.GetBean(tableName, sid)\n\t\tassert.Nil(t, obj4)\n\t}\n}\n"
        },
        {
          "name": "cache_memory_store.go",
          "type": "blob",
          "size": 1.0361328125,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"sync\"\n\n\t\"xorm.io/core\"\n)\n\nvar _ core.CacheStore = NewMemoryStore()\n\n// MemoryStore represents in-memory store\ntype MemoryStore struct {\n\tstore map[interface{}]interface{}\n\tmutex sync.RWMutex\n}\n\n// NewMemoryStore creates a new store in memory\nfunc NewMemoryStore() *MemoryStore {\n\treturn &MemoryStore{store: make(map[interface{}]interface{})}\n}\n\n// Put puts object into store\nfunc (s *MemoryStore) Put(key string, value interface{}) error {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\ts.store[key] = value\n\treturn nil\n}\n\n// Get gets object from store\nfunc (s *MemoryStore) Get(key string) (interface{}, error) {\n\ts.mutex.RLock()\n\tdefer s.mutex.RUnlock()\n\tif v, ok := s.store[key]; ok {\n\t\treturn v, nil\n\t}\n\n\treturn nil, ErrNotExist\n}\n\n// Del deletes object\nfunc (s *MemoryStore) Del(key string) error {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\tdelete(s.store, key)\n\treturn nil\n}\n"
        },
        {
          "name": "cache_memory_store_test.go",
          "type": "blob",
          "size": 0.6875,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMemoryStore(t *testing.T) {\n\tstore := NewMemoryStore()\n\tvar kvs = map[string]interface{}{\n\t\t\"a\": \"b\",\n\t}\n\tfor k, v := range kvs {\n\t\tassert.NoError(t, store.Put(k, v))\n\t}\n\n\tfor k, v := range kvs {\n\t\tval, err := store.Get(k)\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, v, val)\n\t}\n\n\tfor k, _ := range kvs {\n\t\terr := store.Del(k)\n\t\tassert.NoError(t, err)\n\t}\n\n\tfor k, _ := range kvs {\n\t\t_, err := store.Get(k)\n\t\tassert.EqualValues(t, ErrNotExist, err)\n\t}\n}\n"
        },
        {
          "name": "cache_test.go",
          "type": "blob",
          "size": 4.3642578125,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestCacheFind(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype MailBox struct {\n\t\tId       int64 `xorm:\"pk\"`\n\t\tUsername string\n\t\tPassword string\n\t}\n\n\toldCacher := testEngine.GetDefaultCacher()\n\tcacher := NewLRUCacher2(NewMemoryStore(), time.Hour, 10000)\n\ttestEngine.SetDefaultCacher(cacher)\n\n\tassert.NoError(t, testEngine.Sync2(new(MailBox)))\n\n\tvar inserts = []*MailBox{\n\t\t{\n\t\t\tId:       0,\n\t\t\tUsername: \"user1\",\n\t\t\tPassword: \"pass1\",\n\t\t},\n\t\t{\n\t\t\tId:       1,\n\t\t\tUsername: \"user2\",\n\t\t\tPassword: \"pass2\",\n\t\t},\n\t}\n\t_, err := testEngine.Insert(inserts[0], inserts[1])\n\tassert.NoError(t, err)\n\n\tvar boxes []MailBox\n\tassert.NoError(t, testEngine.Find(&boxes))\n\tassert.EqualValues(t, 2, len(boxes))\n\tfor i, box := range boxes {\n\t\tassert.Equal(t, inserts[i].Id, box.Id)\n\t\tassert.Equal(t, inserts[i].Username, box.Username)\n\t\tassert.Equal(t, inserts[i].Password, box.Password)\n\t}\n\n\tboxes = make([]MailBox, 0, 2)\n\tassert.NoError(t, testEngine.Find(&boxes))\n\tassert.EqualValues(t, 2, len(boxes))\n\tfor i, box := range boxes {\n\t\tassert.Equal(t, inserts[i].Id, box.Id)\n\t\tassert.Equal(t, inserts[i].Username, box.Username)\n\t\tassert.Equal(t, inserts[i].Password, box.Password)\n\t}\n\n\tboxes = make([]MailBox, 0, 2)\n\tassert.NoError(t, testEngine.Alias(\"a\").Where(\"a.id > -1\").Asc(\"a.id\").Find(&boxes))\n\tassert.EqualValues(t, 2, len(boxes))\n\tfor i, box := range boxes {\n\t\tassert.Equal(t, inserts[i].Id, box.Id)\n\t\tassert.Equal(t, inserts[i].Username, box.Username)\n\t\tassert.Equal(t, inserts[i].Password, box.Password)\n\t}\n\n\ttype MailBox4 struct {\n\t\tId       int64\n\t\tUsername string\n\t\tPassword string\n\t}\n\n\tboxes2 := make([]MailBox4, 0, 2)\n\tassert.NoError(t, testEngine.Table(\"mail_box\").Where(\"mail_box.id > -1\").Asc(\"mail_box.id\").Find(&boxes2))\n\tassert.EqualValues(t, 2, len(boxes2))\n\tfor i, box := range boxes2 {\n\t\tassert.Equal(t, inserts[i].Id, box.Id)\n\t\tassert.Equal(t, inserts[i].Username, box.Username)\n\t\tassert.Equal(t, inserts[i].Password, box.Password)\n\t}\n\n\ttestEngine.SetDefaultCacher(oldCacher)\n}\n\nfunc TestCacheFind2(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype MailBox2 struct {\n\t\tId       uint64 `xorm:\"pk\"`\n\t\tUsername string\n\t\tPassword string\n\t}\n\n\toldCacher := testEngine.GetDefaultCacher()\n\tcacher := NewLRUCacher2(NewMemoryStore(), time.Hour, 10000)\n\ttestEngine.SetDefaultCacher(cacher)\n\n\tassert.NoError(t, testEngine.Sync2(new(MailBox2)))\n\n\tvar inserts = []*MailBox2{\n\t\t{\n\t\t\tId:       0,\n\t\t\tUsername: \"user1\",\n\t\t\tPassword: \"pass1\",\n\t\t},\n\t\t{\n\t\t\tId:       1,\n\t\t\tUsername: \"user2\",\n\t\t\tPassword: \"pass2\",\n\t\t},\n\t}\n\t_, err := testEngine.Insert(inserts[0], inserts[1])\n\tassert.NoError(t, err)\n\n\tvar boxes []MailBox2\n\tassert.NoError(t, testEngine.Find(&boxes))\n\tassert.EqualValues(t, 2, len(boxes))\n\tfor i, box := range boxes {\n\t\tassert.Equal(t, inserts[i].Id, box.Id)\n\t\tassert.Equal(t, inserts[i].Username, box.Username)\n\t\tassert.Equal(t, inserts[i].Password, box.Password)\n\t}\n\n\tboxes = make([]MailBox2, 0, 2)\n\tassert.NoError(t, testEngine.Find(&boxes))\n\tassert.EqualValues(t, 2, len(boxes))\n\tfor i, box := range boxes {\n\t\tassert.Equal(t, inserts[i].Id, box.Id)\n\t\tassert.Equal(t, inserts[i].Username, box.Username)\n\t\tassert.Equal(t, inserts[i].Password, box.Password)\n\t}\n\n\ttestEngine.SetDefaultCacher(oldCacher)\n}\n\nfunc TestCacheGet(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype MailBox3 struct {\n\t\tId       uint64\n\t\tUsername string\n\t\tPassword string\n\t}\n\n\toldCacher := testEngine.GetDefaultCacher()\n\tcacher := NewLRUCacher2(NewMemoryStore(), time.Hour, 10000)\n\ttestEngine.SetDefaultCacher(cacher)\n\n\tassert.NoError(t, testEngine.Sync2(new(MailBox3)))\n\n\tvar inserts = []*MailBox3{\n\t\t{\n\t\t\tUsername: \"user1\",\n\t\t\tPassword: \"pass1\",\n\t\t},\n\t}\n\t_, err := testEngine.Insert(inserts[0])\n\tassert.NoError(t, err)\n\n\tvar box1 MailBox3\n\thas, err := testEngine.Where(\"id = ?\", inserts[0].Id).Get(&box1)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, \"user1\", box1.Username)\n\tassert.EqualValues(t, \"pass1\", box1.Password)\n\n\tvar box2 MailBox3\n\thas, err = testEngine.Where(\"id = ?\", inserts[0].Id).Get(&box2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, \"user1\", box2.Username)\n\tassert.EqualValues(t, \"pass1\", box2.Password)\n\n\ttestEngine.SetDefaultCacher(oldCacher)\n}\n"
        },
        {
          "name": "context_cache.go",
          "type": "blob",
          "size": 0.8173828125,
          "content": "// Copyright 2018 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\n// ContextCache is the interface that operates the cache data.\ntype ContextCache interface {\n\t// Put puts value into cache with key.\n\tPut(key string, val interface{})\n\t// Get gets cached value by given key.\n\tGet(key string) interface{}\n}\n\ntype memoryContextCache map[string]interface{}\n\n// NewMemoryContextCache return memoryContextCache\nfunc NewMemoryContextCache() memoryContextCache {\n\treturn make(map[string]interface{})\n}\n\n// Put puts value into cache with key.\nfunc (m memoryContextCache) Put(key string, val interface{}) {\n\tm[key] = val\n}\n\n// Get gets cached value by given key.\nfunc (m memoryContextCache) Get(key string) interface{} {\n\treturn m[key]\n}\n"
        },
        {
          "name": "convert.go",
          "type": "blob",
          "size": 7.703125,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"time\"\n)\n\nvar errNilPtr = errors.New(\"destination pointer is nil\") // embedded in descriptive error\n\nfunc strconvErr(err error) error {\n\tif ne, ok := err.(*strconv.NumError); ok {\n\t\treturn ne.Err\n\t}\n\treturn err\n}\n\nfunc cloneBytes(b []byte) []byte {\n\tif b == nil {\n\t\treturn nil\n\t} else {\n\t\tc := make([]byte, len(b))\n\t\tcopy(c, b)\n\t\treturn c\n\t}\n}\n\nfunc asString(src interface{}) string {\n\tswitch v := src.(type) {\n\tcase string:\n\t\treturn v\n\tcase []byte:\n\t\treturn string(v)\n\t}\n\trv := reflect.ValueOf(src)\n\tswitch rv.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn strconv.FormatInt(rv.Int(), 10)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\treturn strconv.FormatUint(rv.Uint(), 10)\n\tcase reflect.Float64:\n\t\treturn strconv.FormatFloat(rv.Float(), 'g', -1, 64)\n\tcase reflect.Float32:\n\t\treturn strconv.FormatFloat(rv.Float(), 'g', -1, 32)\n\tcase reflect.Bool:\n\t\treturn strconv.FormatBool(rv.Bool())\n\t}\n\treturn fmt.Sprintf(\"%v\", src)\n}\n\nfunc asBytes(buf []byte, rv reflect.Value) (b []byte, ok bool) {\n\tswitch rv.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn strconv.AppendInt(buf, rv.Int(), 10), true\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\treturn strconv.AppendUint(buf, rv.Uint(), 10), true\n\tcase reflect.Float32:\n\t\treturn strconv.AppendFloat(buf, rv.Float(), 'g', -1, 32), true\n\tcase reflect.Float64:\n\t\treturn strconv.AppendFloat(buf, rv.Float(), 'g', -1, 64), true\n\tcase reflect.Bool:\n\t\treturn strconv.AppendBool(buf, rv.Bool()), true\n\tcase reflect.String:\n\t\ts := rv.String()\n\t\treturn append(buf, s...), true\n\t}\n\treturn\n}\n\n// convertAssign copies to dest the value in src, converting it if possible.\n// An error is returned if the copy would result in loss of information.\n// dest should be a pointer type.\nfunc convertAssign(dest, src interface{}) error {\n\t// Common cases, without reflect.\n\tswitch s := src.(type) {\n\tcase string:\n\t\tswitch d := dest.(type) {\n\t\tcase *string:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = s\n\t\t\treturn nil\n\t\tcase *[]byte:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = []byte(s)\n\t\t\treturn nil\n\t\t}\n\tcase []byte:\n\t\tswitch d := dest.(type) {\n\t\tcase *string:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = string(s)\n\t\t\treturn nil\n\t\tcase *interface{}:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = cloneBytes(s)\n\t\t\treturn nil\n\t\tcase *[]byte:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = cloneBytes(s)\n\t\t\treturn nil\n\t\t}\n\n\tcase time.Time:\n\t\tswitch d := dest.(type) {\n\t\tcase *string:\n\t\t\t*d = s.Format(time.RFC3339Nano)\n\t\t\treturn nil\n\t\tcase *[]byte:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = []byte(s.Format(time.RFC3339Nano))\n\t\t\treturn nil\n\t\t}\n\tcase nil:\n\t\tswitch d := dest.(type) {\n\t\tcase *interface{}:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = nil\n\t\t\treturn nil\n\t\tcase *[]byte:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = nil\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tvar sv reflect.Value\n\n\tswitch d := dest.(type) {\n\tcase *string:\n\t\tsv = reflect.ValueOf(src)\n\t\tswitch sv.Kind() {\n\t\tcase reflect.Bool,\n\t\t\treflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n\t\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,\n\t\t\treflect.Float32, reflect.Float64:\n\t\t\t*d = asString(src)\n\t\t\treturn nil\n\t\t}\n\tcase *[]byte:\n\t\tsv = reflect.ValueOf(src)\n\t\tif b, ok := asBytes(nil, sv); ok {\n\t\t\t*d = b\n\t\t\treturn nil\n\t\t}\n\tcase *bool:\n\t\tbv, err := driver.Bool.ConvertValue(src)\n\t\tif err == nil {\n\t\t\t*d = bv.(bool)\n\t\t}\n\t\treturn err\n\tcase *interface{}:\n\t\t*d = src\n\t\treturn nil\n\t}\n\n\tdpv := reflect.ValueOf(dest)\n\tif dpv.Kind() != reflect.Ptr {\n\t\treturn errors.New(\"destination not a pointer\")\n\t}\n\tif dpv.IsNil() {\n\t\treturn errNilPtr\n\t}\n\n\tif !sv.IsValid() {\n\t\tsv = reflect.ValueOf(src)\n\t}\n\n\tdv := reflect.Indirect(dpv)\n\tif sv.IsValid() && sv.Type().AssignableTo(dv.Type()) {\n\t\tswitch b := src.(type) {\n\t\tcase []byte:\n\t\t\tdv.Set(reflect.ValueOf(cloneBytes(b)))\n\t\tdefault:\n\t\t\tdv.Set(sv)\n\t\t}\n\t\treturn nil\n\t}\n\n\tif dv.Kind() == sv.Kind() && sv.Type().ConvertibleTo(dv.Type()) {\n\t\tdv.Set(sv.Convert(dv.Type()))\n\t\treturn nil\n\t}\n\n\tswitch dv.Kind() {\n\tcase reflect.Ptr:\n\t\tif src == nil {\n\t\t\tdv.Set(reflect.Zero(dv.Type()))\n\t\t\treturn nil\n\t\t}\n\n\t\tdv.Set(reflect.New(dv.Type().Elem()))\n\t\treturn convertAssign(dv.Interface(), src)\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\ts := asString(src)\n\t\ti64, err := strconv.ParseInt(s, 10, dv.Type().Bits())\n\t\tif err != nil {\n\t\t\terr = strconvErr(err)\n\t\t\treturn fmt.Errorf(\"converting driver.Value type %T (%q) to a %s: %v\", src, s, dv.Kind(), err)\n\t\t}\n\t\tdv.SetInt(i64)\n\t\treturn nil\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\ts := asString(src)\n\t\tu64, err := strconv.ParseUint(s, 10, dv.Type().Bits())\n\t\tif err != nil {\n\t\t\terr = strconvErr(err)\n\t\t\treturn fmt.Errorf(\"converting driver.Value type %T (%q) to a %s: %v\", src, s, dv.Kind(), err)\n\t\t}\n\t\tdv.SetUint(u64)\n\t\treturn nil\n\tcase reflect.Float32, reflect.Float64:\n\t\ts := asString(src)\n\t\tf64, err := strconv.ParseFloat(s, dv.Type().Bits())\n\t\tif err != nil {\n\t\t\terr = strconvErr(err)\n\t\t\treturn fmt.Errorf(\"converting driver.Value type %T (%q) to a %s: %v\", src, s, dv.Kind(), err)\n\t\t}\n\t\tdv.SetFloat(f64)\n\t\treturn nil\n\tcase reflect.String:\n\t\tdv.SetString(asString(src))\n\t\treturn nil\n\t}\n\n\treturn fmt.Errorf(\"unsupported Scan, storing driver.Value type %T into type %T\", src, dest)\n}\n\nfunc asKind(vv reflect.Value, tp reflect.Type) (interface{}, error) {\n\tswitch tp.Kind() {\n\tcase reflect.Int64:\n\t\treturn vv.Int(), nil\n\tcase reflect.Int:\n\t\treturn int(vv.Int()), nil\n\tcase reflect.Int32:\n\t\treturn int32(vv.Int()), nil\n\tcase reflect.Int16:\n\t\treturn int16(vv.Int()), nil\n\tcase reflect.Int8:\n\t\treturn int8(vv.Int()), nil\n\tcase reflect.Uint64:\n\t\treturn vv.Uint(), nil\n\tcase reflect.Uint:\n\t\treturn uint(vv.Uint()), nil\n\tcase reflect.Uint32:\n\t\treturn uint32(vv.Uint()), nil\n\tcase reflect.Uint16:\n\t\treturn uint16(vv.Uint()), nil\n\tcase reflect.Uint8:\n\t\treturn uint8(vv.Uint()), nil\n\tcase reflect.String:\n\t\treturn vv.String(), nil\n\tcase reflect.Slice:\n\t\tif tp.Elem().Kind() == reflect.Uint8 {\n\t\t\tv, err := strconv.ParseInt(string(vv.Interface().([]byte)), 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn v, nil\n\t\t}\n\n\t}\n\treturn nil, fmt.Errorf(\"unsupported primary key type: %v, %v\", tp, vv)\n}\n\nfunc convertFloat(v interface{}) (float64, error) {\n\tswitch v.(type) {\n\tcase float32:\n\t\treturn float64(v.(float32)), nil\n\tcase float64:\n\t\treturn v.(float64), nil\n\tcase string:\n\t\ti, err := strconv.ParseFloat(v.(string), 64)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn i, nil\n\tcase []byte:\n\t\ti, err := strconv.ParseFloat(string(v.([]byte)), 64)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn i, nil\n\t}\n\treturn 0, fmt.Errorf(\"unsupported type: %v\", v)\n}\n\nfunc convertInt(v interface{}) (int64, error) {\n\tswitch v.(type) {\n\tcase int:\n\t\treturn int64(v.(int)), nil\n\tcase int8:\n\t\treturn int64(v.(int8)), nil\n\tcase int16:\n\t\treturn int64(v.(int16)), nil\n\tcase int32:\n\t\treturn int64(v.(int32)), nil\n\tcase int64:\n\t\treturn v.(int64), nil\n\tcase []byte:\n\t\ti, err := strconv.ParseInt(string(v.([]byte)), 10, 64)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn i, nil\n\tcase string:\n\t\ti, err := strconv.ParseInt(v.(string), 10, 64)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn i, nil\n\t}\n\treturn 0, fmt.Errorf(\"unsupported type: %v\", v)\n}\n\nfunc asBool(bs []byte) (bool, error) {\n\tif len(bs) == 0 {\n\t\treturn false, nil\n\t}\n\tif bs[0] == 0x00 {\n\t\treturn false, nil\n\t} else if bs[0] == 0x01 {\n\t\treturn true, nil\n\t}\n\treturn strconv.ParseBool(string(bs))\n}\n"
        },
        {
          "name": "dialect_mssql.go",
          "type": "blob",
          "size": 17.04296875,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"xorm.io/core\"\n)\n\nvar (\n\tmssqlReservedWords = map[string]bool{\n\t\t\"ADD\":                            true,\n\t\t\"EXTERNAL\":                       true,\n\t\t\"PROCEDURE\":                      true,\n\t\t\"ALL\":                            true,\n\t\t\"FETCH\":                          true,\n\t\t\"PUBLIC\":                         true,\n\t\t\"ALTER\":                          true,\n\t\t\"FILE\":                           true,\n\t\t\"RAISERROR\":                      true,\n\t\t\"AND\":                            true,\n\t\t\"FILLFACTOR\":                     true,\n\t\t\"READ\":                           true,\n\t\t\"ANY\":                            true,\n\t\t\"FOR\":                            true,\n\t\t\"READTEXT\":                       true,\n\t\t\"AS\":                             true,\n\t\t\"FOREIGN\":                        true,\n\t\t\"RECONFIGURE\":                    true,\n\t\t\"ASC\":                            true,\n\t\t\"FREETEXT\":                       true,\n\t\t\"REFERENCES\":                     true,\n\t\t\"AUTHORIZATION\":                  true,\n\t\t\"FREETEXTTABLE\":                  true,\n\t\t\"REPLICATION\":                    true,\n\t\t\"BACKUP\":                         true,\n\t\t\"FROM\":                           true,\n\t\t\"RESTORE\":                        true,\n\t\t\"BEGIN\":                          true,\n\t\t\"FULL\":                           true,\n\t\t\"RESTRICT\":                       true,\n\t\t\"BETWEEN\":                        true,\n\t\t\"FUNCTION\":                       true,\n\t\t\"RETURN\":                         true,\n\t\t\"BREAK\":                          true,\n\t\t\"GOTO\":                           true,\n\t\t\"REVERT\":                         true,\n\t\t\"BROWSE\":                         true,\n\t\t\"GRANT\":                          true,\n\t\t\"REVOKE\":                         true,\n\t\t\"BULK\":                           true,\n\t\t\"GROUP\":                          true,\n\t\t\"RIGHT\":                          true,\n\t\t\"BY\":                             true,\n\t\t\"HAVING\":                         true,\n\t\t\"ROLLBACK\":                       true,\n\t\t\"CASCADE\":                        true,\n\t\t\"HOLDLOCK\":                       true,\n\t\t\"ROWCOUNT\":                       true,\n\t\t\"CASE\":                           true,\n\t\t\"IDENTITY\":                       true,\n\t\t\"ROWGUIDCOL\":                     true,\n\t\t\"CHECK\":                          true,\n\t\t\"IDENTITY_INSERT\":                true,\n\t\t\"RULE\":                           true,\n\t\t\"CHECKPOINT\":                     true,\n\t\t\"IDENTITYCOL\":                    true,\n\t\t\"SAVE\":                           true,\n\t\t\"CLOSE\":                          true,\n\t\t\"IF\":                             true,\n\t\t\"SCHEMA\":                         true,\n\t\t\"CLUSTERED\":                      true,\n\t\t\"IN\":                             true,\n\t\t\"SECURITYAUDIT\":                  true,\n\t\t\"COALESCE\":                       true,\n\t\t\"INDEX\":                          true,\n\t\t\"SELECT\":                         true,\n\t\t\"COLLATE\":                        true,\n\t\t\"INNER\":                          true,\n\t\t\"SEMANTICKEYPHRASETABLE\":         true,\n\t\t\"COLUMN\":                         true,\n\t\t\"INSERT\":                         true,\n\t\t\"SEMANTICSIMILARITYDETAILSTABLE\": true,\n\t\t\"COMMIT\":                         true,\n\t\t\"INTERSECT\":                      true,\n\t\t\"SEMANTICSIMILARITYTABLE\":        true,\n\t\t\"COMPUTE\":                        true,\n\t\t\"INTO\":                           true,\n\t\t\"SESSION_USER\":                   true,\n\t\t\"CONSTRAINT\":                     true,\n\t\t\"IS\":                             true,\n\t\t\"SET\":                            true,\n\t\t\"CONTAINS\":                       true,\n\t\t\"JOIN\":                           true,\n\t\t\"SETUSER\":                        true,\n\t\t\"CONTAINSTABLE\":                  true,\n\t\t\"KEY\":                            true,\n\t\t\"SHUTDOWN\":                       true,\n\t\t\"CONTINUE\":                       true,\n\t\t\"KILL\":                           true,\n\t\t\"SOME\":                           true,\n\t\t\"CONVERT\":                        true,\n\t\t\"LEFT\":                           true,\n\t\t\"STATISTICS\":                     true,\n\t\t\"CREATE\":                         true,\n\t\t\"LIKE\":                           true,\n\t\t\"SYSTEM_USER\":                    true,\n\t\t\"CROSS\":                          true,\n\t\t\"LINENO\":                         true,\n\t\t\"TABLE\":                          true,\n\t\t\"CURRENT\":                        true,\n\t\t\"LOAD\":                           true,\n\t\t\"TABLESAMPLE\":                    true,\n\t\t\"CURRENT_DATE\":                   true,\n\t\t\"MERGE\":                          true,\n\t\t\"TEXTSIZE\":                       true,\n\t\t\"CURRENT_TIME\":                   true,\n\t\t\"NATIONAL\":                       true,\n\t\t\"THEN\":                           true,\n\t\t\"CURRENT_TIMESTAMP\":              true,\n\t\t\"NOCHECK\":                        true,\n\t\t\"TO\":                             true,\n\t\t\"CURRENT_USER\":                   true,\n\t\t\"NONCLUSTERED\":                   true,\n\t\t\"TOP\":                            true,\n\t\t\"CURSOR\":                         true,\n\t\t\"NOT\":                            true,\n\t\t\"TRAN\":                           true,\n\t\t\"DATABASE\":                       true,\n\t\t\"NULL\":                           true,\n\t\t\"TRANSACTION\":                    true,\n\t\t\"DBCC\":                           true,\n\t\t\"NULLIF\":                         true,\n\t\t\"TRIGGER\":                        true,\n\t\t\"DEALLOCATE\":                     true,\n\t\t\"OF\":                             true,\n\t\t\"TRUNCATE\":                       true,\n\t\t\"DECLARE\":                        true,\n\t\t\"OFF\":                            true,\n\t\t\"TRY_CONVERT\":                    true,\n\t\t\"DEFAULT\":                        true,\n\t\t\"OFFSETS\":                        true,\n\t\t\"TSEQUAL\":                        true,\n\t\t\"DELETE\":                         true,\n\t\t\"ON\":                             true,\n\t\t\"UNION\":                          true,\n\t\t\"DENY\":                           true,\n\t\t\"OPEN\":                           true,\n\t\t\"UNIQUE\":                         true,\n\t\t\"DESC\":                           true,\n\t\t\"OPENDATASOURCE\":                 true,\n\t\t\"UNPIVOT\":                        true,\n\t\t\"DISK\":                           true,\n\t\t\"OPENQUERY\":                      true,\n\t\t\"UPDATE\":                         true,\n\t\t\"DISTINCT\":                       true,\n\t\t\"OPENROWSET\":                     true,\n\t\t\"UPDATETEXT\":                     true,\n\t\t\"DISTRIBUTED\":                    true,\n\t\t\"OPENXML\":                        true,\n\t\t\"USE\":                            true,\n\t\t\"DOUBLE\":                         true,\n\t\t\"OPTION\":                         true,\n\t\t\"USER\":                           true,\n\t\t\"DROP\":                           true,\n\t\t\"OR\":                             true,\n\t\t\"VALUES\":                         true,\n\t\t\"DUMP\":                           true,\n\t\t\"ORDER\":                          true,\n\t\t\"VARYING\":                        true,\n\t\t\"ELSE\":                           true,\n\t\t\"OUTER\":                          true,\n\t\t\"VIEW\":                           true,\n\t\t\"END\":                            true,\n\t\t\"OVER\":                           true,\n\t\t\"WAITFOR\":                        true,\n\t\t\"ERRLVL\":                         true,\n\t\t\"PERCENT\":                        true,\n\t\t\"WHEN\":                           true,\n\t\t\"ESCAPE\":                         true,\n\t\t\"PIVOT\":                          true,\n\t\t\"WHERE\":                          true,\n\t\t\"EXCEPT\":                         true,\n\t\t\"PLAN\":                           true,\n\t\t\"WHILE\":                          true,\n\t\t\"EXEC\":                           true,\n\t\t\"PRECISION\":                      true,\n\t\t\"WITH\":                           true,\n\t\t\"EXECUTE\":                        true,\n\t\t\"PRIMARY\":                        true,\n\t\t\"WITHIN\":                         true,\n\t\t\"EXISTS\":                         true,\n\t\t\"PRINT\":                          true,\n\t\t\"WRITETEXT\":                      true,\n\t\t\"EXIT\":                           true,\n\t\t\"PROC\":                           true,\n\t}\n)\n\ntype mssql struct {\n\tcore.Base\n}\n\nfunc (db *mssql) Init(d *core.DB, uri *core.Uri, drivername, dataSourceName string) error {\n\treturn db.Base.Init(d, db, uri, drivername, dataSourceName)\n}\n\nfunc (db *mssql) SqlType(c *core.Column) string {\n\tvar res string\n\tswitch t := c.SQLType.Name; t {\n\tcase core.Bool:\n\t\tres = core.Bit\n\t\tif strings.EqualFold(c.Default, \"true\") {\n\t\t\tc.Default = \"1\"\n\t\t} else if strings.EqualFold(c.Default, \"false\") {\n\t\t\tc.Default = \"0\"\n\t\t}\n\tcase core.Serial:\n\t\tc.IsAutoIncrement = true\n\t\tc.IsPrimaryKey = true\n\t\tc.Nullable = false\n\t\tres = core.Int\n\tcase core.BigSerial:\n\t\tc.IsAutoIncrement = true\n\t\tc.IsPrimaryKey = true\n\t\tc.Nullable = false\n\t\tres = core.BigInt\n\tcase core.Bytea, core.Blob, core.Binary, core.TinyBlob, core.MediumBlob, core.LongBlob:\n\t\tres = core.VarBinary\n\t\tif c.Length == 0 {\n\t\t\tc.Length = 50\n\t\t}\n\tcase core.TimeStamp:\n\t\tres = core.DateTime\n\tcase core.TimeStampz:\n\t\tres = \"DATETIMEOFFSET\"\n\t\tc.Length = 7\n\tcase core.MediumInt:\n\t\tres = core.Int\n\tcase core.Text, core.MediumText, core.TinyText, core.LongText, core.Json:\n\t\tres = core.Varchar + \"(MAX)\"\n\tcase core.Double:\n\t\tres = core.Real\n\tcase core.Uuid:\n\t\tres = core.Varchar\n\t\tc.Length = 40\n\tcase core.TinyInt:\n\t\tres = core.TinyInt\n\t\tc.Length = 0\n\tcase core.BigInt:\n\t\tres = core.BigInt\n\t\tc.Length = 0\n\tdefault:\n\t\tres = t\n\t}\n\n\tif res == core.Int {\n\t\treturn core.Int\n\t}\n\n\thasLen1 := (c.Length > 0)\n\thasLen2 := (c.Length2 > 0)\n\n\tif hasLen2 {\n\t\tres += \"(\" + strconv.Itoa(c.Length) + \",\" + strconv.Itoa(c.Length2) + \")\"\n\t} else if hasLen1 {\n\t\tres += \"(\" + strconv.Itoa(c.Length) + \")\"\n\t}\n\treturn res\n}\n\nfunc (db *mssql) SupportInsertMany() bool {\n\treturn true\n}\n\nfunc (db *mssql) IsReserved(name string) bool {\n\t_, ok := mssqlReservedWords[name]\n\treturn ok\n}\n\nfunc (db *mssql) Quote(name string) string {\n\treturn \"\\\"\" + name + \"\\\"\"\n}\n\nfunc (db *mssql) SupportEngine() bool {\n\treturn false\n}\n\nfunc (db *mssql) AutoIncrStr() string {\n\treturn \"IDENTITY\"\n}\n\nfunc (db *mssql) DropTableSql(tableName string) string {\n\treturn fmt.Sprintf(\"IF EXISTS (SELECT * FROM sysobjects WHERE id = \"+\n\t\t\"object_id(N'%s') and OBJECTPROPERTY(id, N'IsUserTable') = 1) \"+\n\t\t\"DROP TABLE \\\"%s\\\"\", tableName, tableName)\n}\n\nfunc (db *mssql) SupportCharset() bool {\n\treturn false\n}\n\nfunc (db *mssql) IndexOnTable() bool {\n\treturn true\n}\n\nfunc (db *mssql) IndexCheckSql(tableName, idxName string) (string, []interface{}) {\n\targs := []interface{}{idxName}\n\tsql := \"select name from sysindexes where id=object_id('\" + tableName + \"') and name=?\"\n\treturn sql, args\n}\n\n/*func (db *mssql) ColumnCheckSql(tableName, colName string) (string, []interface{}) {\n\targs := []interface{}{tableName, colName}\n\tsql := `SELECT \"COLUMN_NAME\" FROM \"INFORMATION_SCHEMA\".\"COLUMNS\" WHERE \"TABLE_NAME\" = ? AND \"COLUMN_NAME\" = ?`\n\treturn sql, args\n}*/\n\nfunc (db *mssql) IsColumnExist(tableName, colName string) (bool, error) {\n\tquery := `SELECT \"COLUMN_NAME\" FROM \"INFORMATION_SCHEMA\".\"COLUMNS\" WHERE \"TABLE_NAME\" = ? AND \"COLUMN_NAME\" = ?`\n\n\treturn db.HasRecords(query, tableName, colName)\n}\n\nfunc (db *mssql) TableCheckSql(tableName string) (string, []interface{}) {\n\targs := []interface{}{}\n\tsql := \"select * from sysobjects where id = object_id(N'\" + tableName + \"') and OBJECTPROPERTY(id, N'IsUserTable') = 1\"\n\treturn sql, args\n}\n\nfunc (db *mssql) GetColumns(tableName string) ([]string, map[string]*core.Column, error) {\n\targs := []interface{}{}\n\ts := `select a.name as name, b.name as ctype,a.max_length,a.precision,a.scale,a.is_nullable as nullable,\n\t\t  \"default_is_null\" = (CASE WHEN c.text is null THEN 1 ELSE 0 END),\n\t      replace(replace(isnull(c.text,''),'(',''),')','') as vdefault,\n\t\t  ISNULL(i.is_primary_key, 0), a.is_identity as is_identity\n          from sys.columns a \n\t\t  left join sys.types b on a.user_type_id=b.user_type_id\n          left join sys.syscomments c on a.default_object_id=c.id\n\t\t  LEFT OUTER JOIN \n    sys.index_columns ic ON ic.object_id = a.object_id AND ic.column_id = a.column_id\n\t\t  LEFT OUTER JOIN \n    sys.indexes i ON ic.object_id = i.object_id AND ic.index_id = i.index_id\n          where a.object_id=object_id('` + tableName + `')`\n\tdb.LogSQL(s, args)\n\n\trows, err := db.DB().Query(s, args...)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer rows.Close()\n\n\tcols := make(map[string]*core.Column)\n\tcolSeq := make([]string, 0)\n\tfor rows.Next() {\n\t\tvar name, ctype, vdefault string\n\t\tvar maxLen, precision, scale int\n\t\tvar nullable, isPK, defaultIsNull, isIncrement bool\n\t\terr = rows.Scan(&name, &ctype, &maxLen, &precision, &scale, &nullable, &defaultIsNull, &vdefault, &isPK, &isIncrement)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\tcol := new(core.Column)\n\t\tcol.Indexes = make(map[string]int)\n\t\tcol.Name = strings.Trim(name, \"` \")\n\t\tcol.Nullable = nullable\n\t\tcol.DefaultIsEmpty = defaultIsNull\n\t\tif !defaultIsNull {\n\t\t\tcol.Default = vdefault\n\t\t}\n\t\tcol.IsPrimaryKey = isPK\n\t\tcol.IsAutoIncrement = isIncrement\n\t\tct := strings.ToUpper(ctype)\n\t\tif ct == \"DECIMAL\" {\n\t\t\tcol.Length = precision\n\t\t\tcol.Length2 = scale\n\t\t} else {\n\t\t\tcol.Length = maxLen\n\t\t}\n\t\tswitch ct {\n\t\tcase \"DATETIMEOFFSET\":\n\t\t\tcol.SQLType = core.SQLType{Name: core.TimeStampz, DefaultLength: 0, DefaultLength2: 0}\n\t\tcase \"NVARCHAR\":\n\t\t\tcol.SQLType = core.SQLType{Name: core.NVarchar, DefaultLength: 0, DefaultLength2: 0}\n\t\tcase \"IMAGE\":\n\t\t\tcol.SQLType = core.SQLType{Name: core.VarBinary, DefaultLength: 0, DefaultLength2: 0}\n\t\tdefault:\n\t\t\tif _, ok := core.SqlTypes[ct]; ok {\n\t\t\t\tcol.SQLType = core.SQLType{Name: ct, DefaultLength: 0, DefaultLength2: 0}\n\t\t\t} else {\n\t\t\t\treturn nil, nil, fmt.Errorf(\"Unknown colType %v for %v - %v\", ct, tableName, col.Name)\n\t\t\t}\n\t\t}\n\n\t\tcols[col.Name] = col\n\t\tcolSeq = append(colSeq, col.Name)\n\t}\n\treturn colSeq, cols, nil\n}\n\nfunc (db *mssql) GetTables() ([]*core.Table, error) {\n\targs := []interface{}{}\n\ts := `select name from sysobjects where xtype ='U'`\n\tdb.LogSQL(s, args)\n\n\trows, err := db.DB().Query(s, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\ttables := make([]*core.Table, 0)\n\tfor rows.Next() {\n\t\ttable := core.NewEmptyTable()\n\t\tvar name string\n\t\terr = rows.Scan(&name)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttable.Name = strings.Trim(name, \"` \")\n\t\ttables = append(tables, table)\n\t}\n\treturn tables, nil\n}\n\nfunc (db *mssql) GetIndexes(tableName string) (map[string]*core.Index, error) {\n\targs := []interface{}{tableName}\n\ts := `SELECT\nIXS.NAME                    AS  [INDEX_NAME],\nC.NAME                      AS  [COLUMN_NAME],\nIXS.is_unique AS [IS_UNIQUE]\nFROM SYS.INDEXES IXS\nINNER JOIN SYS.INDEX_COLUMNS   IXCS\nON IXS.OBJECT_ID=IXCS.OBJECT_ID  AND IXS.INDEX_ID = IXCS.INDEX_ID\nINNER   JOIN SYS.COLUMNS C  ON IXS.OBJECT_ID=C.OBJECT_ID\nAND IXCS.COLUMN_ID=C.COLUMN_ID\nWHERE IXS.TYPE_DESC='NONCLUSTERED' and OBJECT_NAME(IXS.OBJECT_ID) =?\n`\n\tdb.LogSQL(s, args)\n\n\trows, err := db.DB().Query(s, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tindexes := make(map[string]*core.Index, 0)\n\tfor rows.Next() {\n\t\tvar indexType int\n\t\tvar indexName, colName, isUnique string\n\n\t\terr = rows.Scan(&indexName, &colName, &isUnique)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ti, err := strconv.ParseBool(isUnique)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif i {\n\t\t\tindexType = core.UniqueType\n\t\t} else {\n\t\t\tindexType = core.IndexType\n\t\t}\n\n\t\tcolName = strings.Trim(colName, \"` \")\n\t\tvar isRegular bool\n\t\tif strings.HasPrefix(indexName, \"IDX_\"+tableName) || strings.HasPrefix(indexName, \"UQE_\"+tableName) {\n\t\t\tindexName = indexName[5+len(tableName):]\n\t\t\tisRegular = true\n\t\t}\n\n\t\tvar index *core.Index\n\t\tvar ok bool\n\t\tif index, ok = indexes[indexName]; !ok {\n\t\t\tindex = new(core.Index)\n\t\t\tindex.Type = indexType\n\t\t\tindex.Name = indexName\n\t\t\tindex.IsRegular = isRegular\n\t\t\tindexes[indexName] = index\n\t\t}\n\t\tindex.AddColumn(colName)\n\t}\n\treturn indexes, nil\n}\n\nfunc (db *mssql) CreateTableSql(table *core.Table, tableName, storeEngine, charset string) string {\n\tvar sql string\n\tif tableName == \"\" {\n\t\ttableName = table.Name\n\t}\n\n\tsql = \"IF NOT EXISTS (SELECT [name] FROM sys.tables WHERE [name] = '\" + tableName + \"' ) CREATE TABLE \"\n\n\tsql += db.Quote(tableName) + \" (\"\n\n\tpkList := table.PrimaryKeys\n\n\tfor _, colName := range table.ColumnsSeq() {\n\t\tcol := table.GetColumn(colName)\n\t\tif col.IsPrimaryKey && len(pkList) == 1 {\n\t\t\tsql += col.String(db)\n\t\t} else {\n\t\t\tsql += col.StringNoPk(db)\n\t\t}\n\t\tsql = strings.TrimSpace(sql)\n\t\tsql += \", \"\n\t}\n\n\tif len(pkList) > 1 {\n\t\tsql += \"PRIMARY KEY ( \"\n\t\tsql += strings.Join(pkList, \",\")\n\t\tsql += \" ), \"\n\t}\n\n\tsql = sql[:len(sql)-2] + \")\"\n\tsql += \";\"\n\treturn sql\n}\n\nfunc (db *mssql) ForUpdateSql(query string) string {\n\treturn query\n}\n\nfunc (db *mssql) Filters() []core.Filter {\n\treturn []core.Filter{&core.IdFilter{}, &core.QuoteFilter{}}\n}\n\ntype odbcDriver struct {\n}\n\nfunc (p *odbcDriver) Parse(driverName, dataSourceName string) (*core.Uri, error) {\n\tvar dbName string\n\n\tif strings.HasPrefix(dataSourceName, \"sqlserver://\") {\n\t\tu, err := url.Parse(dataSourceName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdbName = u.Query().Get(\"database\")\n\t} else {\n\t\tkv := strings.Split(dataSourceName, \";\")\n\t\tfor _, c := range kv {\n\t\t\tvv := strings.Split(strings.TrimSpace(c), \"=\")\n\t\t\tif len(vv) == 2 {\n\t\t\t\tswitch strings.ToLower(vv[0]) {\n\t\t\t\tcase \"database\":\n\t\t\t\t\tdbName = vv[1]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif dbName == \"\" {\n\t\treturn nil, errors.New(\"no db name provided\")\n\t}\n\treturn &core.Uri{DbName: dbName, DbType: core.MSSQL}, nil\n}\n"
        },
        {
          "name": "dialect_mssql_test.go",
          "type": "blob",
          "size": 0.876953125,
          "content": "// Copyright 2019 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"xorm.io/core\"\n)\n\nfunc TestParseMSSQL(t *testing.T) {\n\ttests := []struct {\n\t\tin       string\n\t\texpected string\n\t\tvalid    bool\n\t}{\n\t\t{\"sqlserver://sa:yourStrong(!)Password@localhost:1433?database=db&connection+timeout=30\", \"db\", true},\n\t\t{\"server=localhost;user id=sa;password=yourStrong(!)Password;database=db\", \"db\", true},\n\t}\n\n\tdriver := core.QueryDriver(\"mssql\")\n\n\tfor _, test := range tests {\n\t\turi, err := driver.Parse(\"mssql\", test.in)\n\n\t\tif err != nil && test.valid {\n\t\t\tt.Errorf(\"%q got unexpected error: %s\", test.in, err)\n\t\t} else if err == nil && !reflect.DeepEqual(test.expected, uri.DbName) {\n\t\t\tt.Errorf(\"%q got: %#v want: %#v\", test.in, uri.DbName, test.expected)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "dialect_mysql.go",
          "type": "blob",
          "size": 16.7216796875,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"xorm.io/core\"\n)\n\nvar (\n\tmysqlReservedWords = map[string]bool{\n\t\t\"ADD\":               true,\n\t\t\"ALL\":               true,\n\t\t\"ALTER\":             true,\n\t\t\"ANALYZE\":           true,\n\t\t\"AND\":               true,\n\t\t\"AS\":                true,\n\t\t\"ASC\":               true,\n\t\t\"ASENSITIVE\":        true,\n\t\t\"BEFORE\":            true,\n\t\t\"BETWEEN\":           true,\n\t\t\"BIGINT\":            true,\n\t\t\"BINARY\":            true,\n\t\t\"BLOB\":              true,\n\t\t\"BOTH\":              true,\n\t\t\"BY\":                true,\n\t\t\"CALL\":              true,\n\t\t\"CASCADE\":           true,\n\t\t\"CASE\":              true,\n\t\t\"CHANGE\":            true,\n\t\t\"CHAR\":              true,\n\t\t\"CHARACTER\":         true,\n\t\t\"CHECK\":             true,\n\t\t\"COLLATE\":           true,\n\t\t\"COLUMN\":            true,\n\t\t\"CONDITION\":         true,\n\t\t\"CONNECTION\":        true,\n\t\t\"CONSTRAINT\":        true,\n\t\t\"CONTINUE\":          true,\n\t\t\"CONVERT\":           true,\n\t\t\"CREATE\":            true,\n\t\t\"CROSS\":             true,\n\t\t\"CURRENT_DATE\":      true,\n\t\t\"CURRENT_TIME\":      true,\n\t\t\"CURRENT_TIMESTAMP\": true,\n\t\t\"CURRENT_USER\":      true,\n\t\t\"CURSOR\":            true,\n\t\t\"DATABASE\":          true,\n\t\t\"DATABASES\":         true,\n\t\t\"DAY_HOUR\":          true,\n\t\t\"DAY_MICROSECOND\":   true,\n\t\t\"DAY_MINUTE\":        true,\n\t\t\"DAY_SECOND\":        true,\n\t\t\"DEC\":               true,\n\t\t\"DECIMAL\":           true,\n\t\t\"DECLARE\":           true,\n\t\t\"DEFAULT\":           true,\n\t\t\"DELAYED\":           true,\n\t\t\"DELETE\":            true,\n\t\t\"DESC\":              true,\n\t\t\"DESCRIBE\":          true,\n\t\t\"DETERMINISTIC\":     true,\n\t\t\"DISTINCT\":          true,\n\t\t\"DISTINCTROW\":       true,\n\t\t\"DIV\":               true,\n\t\t\"DOUBLE\":            true,\n\t\t\"DROP\":              true,\n\t\t\"DUAL\":              true,\n\t\t\"EACH\":              true,\n\t\t\"ELSE\":              true,\n\t\t\"ELSEIF\":            true,\n\t\t\"ENCLOSED\":          true,\n\t\t\"ESCAPED\":           true,\n\t\t\"EXISTS\":            true,\n\t\t\"EXIT\":              true,\n\t\t\"EXPLAIN\":           true,\n\t\t\"FALSE\":             true,\n\t\t\"FETCH\":             true,\n\t\t\"FLOAT\":             true,\n\t\t\"FLOAT4\":            true,\n\t\t\"FLOAT8\":            true,\n\t\t\"FOR\":               true,\n\t\t\"FORCE\":             true,\n\t\t\"FOREIGN\":           true,\n\t\t\"FROM\":              true,\n\t\t\"FULLTEXT\":          true,\n\t\t\"GOTO\":              true,\n\t\t\"GRANT\":             true,\n\t\t\"GROUP\":             true,\n\t\t\"HAVING\":            true,\n\t\t\"HIGH_PRIORITY\":     true,\n\t\t\"HOUR_MICROSECOND\":  true,\n\t\t\"HOUR_MINUTE\":       true,\n\t\t\"HOUR_SECOND\":       true,\n\t\t\"IF\":                true,\n\t\t\"IGNORE\":            true,\n\t\t\"IN\":                true, \"INDEX\": true,\n\t\t\"INFILE\": true, \"INNER\": true, \"INOUT\": true,\n\t\t\"INSENSITIVE\": true, \"INSERT\": true, \"INT\": true,\n\t\t\"INT1\": true, \"INT2\": true, \"INT3\": true,\n\t\t\"INT4\": true, \"INT8\": true, \"INTEGER\": true,\n\t\t\"INTERVAL\": true, \"INTO\": true, \"IS\": true,\n\t\t\"ITERATE\": true, \"JOIN\": true, \"KEY\": true,\n\t\t\"KEYS\": true, \"KILL\": true, \"LABEL\": true,\n\t\t\"LEADING\": true, \"LEAVE\": true, \"LEFT\": true,\n\t\t\"LIKE\": true, \"LIMIT\": true, \"LINEAR\": true,\n\t\t\"LINES\": true, \"LOAD\": true, \"LOCALTIME\": true,\n\t\t\"LOCALTIMESTAMP\": true, \"LOCK\": true, \"LONG\": true,\n\t\t\"LONGBLOB\": true, \"LONGTEXT\": true, \"LOOP\": true,\n\t\t\"LOW_PRIORITY\": true, \"MATCH\": true, \"MEDIUMBLOB\": true,\n\t\t\"MEDIUMINT\": true, \"MEDIUMTEXT\": true, \"MIDDLEINT\": true,\n\t\t\"MINUTE_MICROSECOND\": true, \"MINUTE_SECOND\": true, \"MOD\": true,\n\t\t\"MODIFIES\": true, \"NATURAL\": true, \"NOT\": true,\n\t\t\"NO_WRITE_TO_BINLOG\": true, \"NULL\": true, \"NUMERIC\": true,\n\t\t\"ON\tOPTIMIZE\": true, \"OPTION\": true,\n\t\t\"OPTIONALLY\": true, \"OR\": true, \"ORDER\": true,\n\t\t\"OUT\": true, \"OUTER\": true, \"OUTFILE\": true,\n\t\t\"PRECISION\": true, \"PRIMARY\": true, \"PROCEDURE\": true,\n\t\t\"PURGE\": true, \"RAID0\": true, \"RANGE\": true,\n\t\t\"READ\": true, \"READS\": true, \"REAL\": true,\n\t\t\"REFERENCES\": true, \"REGEXP\": true, \"RELEASE\": true,\n\t\t\"RENAME\": true, \"REPEAT\": true, \"REPLACE\": true,\n\t\t\"REQUIRE\": true, \"RESTRICT\": true, \"RETURN\": true,\n\t\t\"REVOKE\": true, \"RIGHT\": true, \"RLIKE\": true,\n\t\t\"SCHEMA\": true, \"SCHEMAS\": true, \"SECOND_MICROSECOND\": true,\n\t\t\"SELECT\": true, \"SENSITIVE\": true, \"SEPARATOR\": true,\n\t\t\"SET\": true, \"SHOW\": true, \"SMALLINT\": true,\n\t\t\"SPATIAL\": true, \"SPECIFIC\": true, \"SQL\": true,\n\t\t\"SQLEXCEPTION\": true, \"SQLSTATE\": true, \"SQLWARNING\": true,\n\t\t\"SQL_BIG_RESULT\": true, \"SQL_CALC_FOUND_ROWS\": true, \"SQL_SMALL_RESULT\": true,\n\t\t\"SSL\": true, \"STARTING\": true, \"STRAIGHT_JOIN\": true,\n\t\t\"TABLE\": true, \"TERMINATED\": true, \"THEN\": true,\n\t\t\"TINYBLOB\": true, \"TINYINT\": true, \"TINYTEXT\": true,\n\t\t\"TO\": true, \"TRAILING\": true, \"TRIGGER\": true,\n\t\t\"TRUE\": true, \"UNDO\": true, \"UNION\": true,\n\t\t\"UNIQUE\": true, \"UNLOCK\": true, \"UNSIGNED\": true,\n\t\t\"UPDATE\": true, \"USAGE\": true, \"USE\": true,\n\t\t\"USING\": true, \"UTC_DATE\": true, \"UTC_TIME\": true,\n\t\t\"UTC_TIMESTAMP\": true, \"VALUES\": true, \"VARBINARY\": true,\n\t\t\"VARCHAR\":      true,\n\t\t\"VARCHARACTER\": true,\n\t\t\"VARYING\":      true,\n\t\t\"WHEN\":         true,\n\t\t\"WHERE\":        true,\n\t\t\"WHILE\":        true,\n\t\t\"WITH\":         true,\n\t\t\"WRITE\":        true,\n\t\t\"X509\":         true,\n\t\t\"XOR\":          true,\n\t\t\"YEAR_MONTH\":   true,\n\t\t\"ZEROFILL\":     true,\n\t}\n)\n\ntype mysql struct {\n\tcore.Base\n\tnet               string\n\taddr              string\n\tparams            map[string]string\n\tloc               *time.Location\n\ttimeout           time.Duration\n\ttls               *tls.Config\n\tallowAllFiles     bool\n\tallowOldPasswords bool\n\tclientFoundRows   bool\n\trowFormat         string\n}\n\nfunc (db *mysql) Init(d *core.DB, uri *core.Uri, drivername, dataSourceName string) error {\n\treturn db.Base.Init(d, db, uri, drivername, dataSourceName)\n}\n\nfunc (db *mysql) SetParams(params map[string]string) {\n\trowFormat, ok := params[\"rowFormat\"]\n\tif ok {\n\t\tvar t = strings.ToUpper(rowFormat)\n\t\tswitch t {\n\t\tcase \"COMPACT\":\n\t\t\tfallthrough\n\t\tcase \"REDUNDANT\":\n\t\t\tfallthrough\n\t\tcase \"DYNAMIC\":\n\t\t\tfallthrough\n\t\tcase \"COMPRESSED\":\n\t\t\tdb.rowFormat = t\n\t\t\tbreak\n\t\tdefault:\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (db *mysql) SqlType(c *core.Column) string {\n\tvar res string\n\tswitch t := c.SQLType.Name; t {\n\tcase core.Bool:\n\t\tres = core.TinyInt\n\t\tc.Length = 1\n\tcase core.Serial:\n\t\tc.IsAutoIncrement = true\n\t\tc.IsPrimaryKey = true\n\t\tc.Nullable = false\n\t\tres = core.Int\n\tcase core.BigSerial:\n\t\tc.IsAutoIncrement = true\n\t\tc.IsPrimaryKey = true\n\t\tc.Nullable = false\n\t\tres = core.BigInt\n\tcase core.Bytea:\n\t\tres = core.Blob\n\tcase core.TimeStampz:\n\t\tres = core.Char\n\t\tc.Length = 64\n\tcase core.Enum: // mysql enum\n\t\tres = core.Enum\n\t\tres += \"(\"\n\t\topts := \"\"\n\t\tfor v := range c.EnumOptions {\n\t\t\topts += fmt.Sprintf(\",'%v'\", v)\n\t\t}\n\t\tres += strings.TrimLeft(opts, \",\")\n\t\tres += \")\"\n\tcase core.Set: // mysql set\n\t\tres = core.Set\n\t\tres += \"(\"\n\t\topts := \"\"\n\t\tfor v := range c.SetOptions {\n\t\t\topts += fmt.Sprintf(\",'%v'\", v)\n\t\t}\n\t\tres += strings.TrimLeft(opts, \",\")\n\t\tres += \")\"\n\tcase core.NVarchar:\n\t\tres = core.Varchar\n\tcase core.Uuid:\n\t\tres = core.Varchar\n\t\tc.Length = 40\n\tcase core.Json:\n\t\tres = core.Text\n\tdefault:\n\t\tres = t\n\t}\n\n\thasLen1 := (c.Length > 0)\n\thasLen2 := (c.Length2 > 0)\n\n\tif res == core.BigInt && !hasLen1 && !hasLen2 {\n\t\tc.Length = 20\n\t\thasLen1 = true\n\t}\n\n\tif hasLen2 {\n\t\tres += \"(\" + strconv.Itoa(c.Length) + \",\" + strconv.Itoa(c.Length2) + \")\"\n\t} else if hasLen1 {\n\t\tres += \"(\" + strconv.Itoa(c.Length) + \")\"\n\t}\n\treturn res\n}\n\nfunc (db *mysql) SupportInsertMany() bool {\n\treturn true\n}\n\nfunc (db *mysql) IsReserved(name string) bool {\n\t_, ok := mysqlReservedWords[name]\n\treturn ok\n}\n\nfunc (db *mysql) Quote(name string) string {\n\treturn \"`\" + name + \"`\"\n}\n\nfunc (db *mysql) SupportEngine() bool {\n\treturn true\n}\n\nfunc (db *mysql) AutoIncrStr() string {\n\treturn \"AUTO_INCREMENT\"\n}\n\nfunc (db *mysql) SupportCharset() bool {\n\treturn true\n}\n\nfunc (db *mysql) IndexOnTable() bool {\n\treturn true\n}\n\nfunc (db *mysql) IndexCheckSql(tableName, idxName string) (string, []interface{}) {\n\targs := []interface{}{db.DbName, tableName, idxName}\n\tsql := \"SELECT `INDEX_NAME` FROM `INFORMATION_SCHEMA`.`STATISTICS`\"\n\tsql += \" WHERE `TABLE_SCHEMA` = ? AND `TABLE_NAME` = ? AND `INDEX_NAME`=?\"\n\treturn sql, args\n}\n\n/*func (db *mysql) ColumnCheckSql(tableName, colName string) (string, []interface{}) {\n\targs := []interface{}{db.DbName, tableName, colName}\n\tsql := \"SELECT `COLUMN_NAME` FROM `INFORMATION_SCHEMA`.`COLUMNS` WHERE `TABLE_SCHEMA` = ? AND `TABLE_NAME` = ? AND `COLUMN_NAME` = ?\"\n\treturn sql, args\n}*/\n\nfunc (db *mysql) TableCheckSql(tableName string) (string, []interface{}) {\n\targs := []interface{}{db.DbName, tableName}\n\tsql := \"SELECT `TABLE_NAME` from `INFORMATION_SCHEMA`.`TABLES` WHERE `TABLE_SCHEMA`=? and `TABLE_NAME`=?\"\n\treturn sql, args\n}\n\nfunc (db *mysql) GetColumns(tableName string) ([]string, map[string]*core.Column, error) {\n\targs := []interface{}{db.DbName, tableName}\n\ts := \"SELECT `COLUMN_NAME`, `IS_NULLABLE`, `COLUMN_DEFAULT`, `COLUMN_TYPE`,\" +\n\t\t\" `COLUMN_KEY`, `EXTRA`,`COLUMN_COMMENT` FROM `INFORMATION_SCHEMA`.`COLUMNS` WHERE `TABLE_SCHEMA` = ? AND `TABLE_NAME` = ?\"\n\tdb.LogSQL(s, args)\n\n\trows, err := db.DB().Query(s, args...)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer rows.Close()\n\n\tcols := make(map[string]*core.Column)\n\tcolSeq := make([]string, 0)\n\tfor rows.Next() {\n\t\tcol := new(core.Column)\n\t\tcol.Indexes = make(map[string]int)\n\n\t\tvar columnName, isNullable, colType, colKey, extra, comment string\n\t\tvar colDefault *string\n\t\terr = rows.Scan(&columnName, &isNullable, &colDefault, &colType, &colKey, &extra, &comment)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tcol.Name = strings.Trim(columnName, \"` \")\n\t\tcol.Comment = comment\n\t\tif \"YES\" == isNullable {\n\t\t\tcol.Nullable = true\n\t\t}\n\n\t\tif colDefault != nil {\n\t\t\tcol.Default = *colDefault\n\t\t\tcol.DefaultIsEmpty = false\n\t\t} else {\n\t\t\tcol.DefaultIsEmpty = true\n\t\t}\n\n\t\tcts := strings.Split(colType, \"(\")\n\t\tcolName := cts[0]\n\t\tcolType = strings.ToUpper(colName)\n\t\tvar len1, len2 int\n\t\tif len(cts) == 2 {\n\t\t\tidx := strings.Index(cts[1], \")\")\n\t\t\tif colType == core.Enum && cts[1][0] == '\\'' { // enum\n\t\t\t\toptions := strings.Split(cts[1][0:idx], \",\")\n\t\t\t\tcol.EnumOptions = make(map[string]int)\n\t\t\t\tfor k, v := range options {\n\t\t\t\t\tv = strings.TrimSpace(v)\n\t\t\t\t\tv = strings.Trim(v, \"'\")\n\t\t\t\t\tcol.EnumOptions[v] = k\n\t\t\t\t}\n\t\t\t} else if colType == core.Set && cts[1][0] == '\\'' {\n\t\t\t\toptions := strings.Split(cts[1][0:idx], \",\")\n\t\t\t\tcol.SetOptions = make(map[string]int)\n\t\t\t\tfor k, v := range options {\n\t\t\t\t\tv = strings.TrimSpace(v)\n\t\t\t\t\tv = strings.Trim(v, \"'\")\n\t\t\t\t\tcol.SetOptions[v] = k\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlens := strings.Split(cts[1][0:idx], \",\")\n\t\t\t\tlen1, err = strconv.Atoi(strings.TrimSpace(lens[0]))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, nil, err\n\t\t\t\t}\n\t\t\t\tif len(lens) == 2 {\n\t\t\t\t\tlen2, err = strconv.Atoi(lens[1])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, nil, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif colType == \"FLOAT UNSIGNED\" {\n\t\t\tcolType = \"FLOAT\"\n\t\t}\n\t\tif colType == \"DOUBLE UNSIGNED\" {\n\t\t\tcolType = \"DOUBLE\"\n\t\t}\n\t\tcol.Length = len1\n\t\tcol.Length2 = len2\n\t\tif _, ok := core.SqlTypes[colType]; ok {\n\t\t\tcol.SQLType = core.SQLType{Name: colType, DefaultLength: len1, DefaultLength2: len2}\n\t\t} else {\n\t\t\treturn nil, nil, fmt.Errorf(\"Unknown colType %v\", colType)\n\t\t}\n\n\t\tif colKey == \"PRI\" {\n\t\t\tcol.IsPrimaryKey = true\n\t\t}\n\t\tif colKey == \"UNI\" {\n\t\t\t// col.is\n\t\t}\n\n\t\tif extra == \"auto_increment\" {\n\t\t\tcol.IsAutoIncrement = true\n\t\t}\n\n\t\tif !col.DefaultIsEmpty {\n\t\t\tif col.SQLType.IsText() {\n\t\t\t\tcol.Default = \"'\" + col.Default + \"'\"\n\t\t\t} else if col.SQLType.IsTime() && col.Default != \"CURRENT_TIMESTAMP\" {\n\t\t\t\tcol.Default = \"'\" + col.Default + \"'\"\n\t\t\t}\n\t\t}\n\t\tcols[col.Name] = col\n\t\tcolSeq = append(colSeq, col.Name)\n\t}\n\treturn colSeq, cols, nil\n}\n\nfunc (db *mysql) GetTables() ([]*core.Table, error) {\n\targs := []interface{}{db.DbName}\n\ts := \"SELECT `TABLE_NAME`, `ENGINE`, `TABLE_ROWS`, `AUTO_INCREMENT`, `TABLE_COMMENT` from \" +\n\t\t\"`INFORMATION_SCHEMA`.`TABLES` WHERE `TABLE_SCHEMA`=? AND (`ENGINE`='MyISAM' OR `ENGINE` = 'InnoDB' OR `ENGINE` = 'TokuDB')\"\n\tdb.LogSQL(s, args)\n\n\trows, err := db.DB().Query(s, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\ttables := make([]*core.Table, 0)\n\tfor rows.Next() {\n\t\ttable := core.NewEmptyTable()\n\t\tvar name, engine, tableRows, comment string\n\t\tvar autoIncr *string\n\t\terr = rows.Scan(&name, &engine, &tableRows, &autoIncr, &comment)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ttable.Name = name\n\t\ttable.Comment = comment\n\t\ttable.StoreEngine = engine\n\t\ttables = append(tables, table)\n\t}\n\treturn tables, nil\n}\n\nfunc (db *mysql) GetIndexes(tableName string) (map[string]*core.Index, error) {\n\targs := []interface{}{db.DbName, tableName}\n\ts := \"SELECT `INDEX_NAME`, `NON_UNIQUE`, `COLUMN_NAME` FROM `INFORMATION_SCHEMA`.`STATISTICS` WHERE `TABLE_SCHEMA` = ? AND `TABLE_NAME` = ?\"\n\tdb.LogSQL(s, args)\n\n\trows, err := db.DB().Query(s, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tindexes := make(map[string]*core.Index, 0)\n\tfor rows.Next() {\n\t\tvar indexType int\n\t\tvar indexName, colName, nonUnique string\n\t\terr = rows.Scan(&indexName, &nonUnique, &colName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif indexName == \"PRIMARY\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif \"YES\" == nonUnique || nonUnique == \"1\" {\n\t\t\tindexType = core.IndexType\n\t\t} else {\n\t\t\tindexType = core.UniqueType\n\t\t}\n\n\t\tcolName = strings.Trim(colName, \"` \")\n\t\tvar isRegular bool\n\t\tif strings.HasPrefix(indexName, \"IDX_\"+tableName) || strings.HasPrefix(indexName, \"UQE_\"+tableName) {\n\t\t\tindexName = indexName[5+len(tableName):]\n\t\t\tisRegular = true\n\t\t}\n\n\t\tvar index *core.Index\n\t\tvar ok bool\n\t\tif index, ok = indexes[indexName]; !ok {\n\t\t\tindex = new(core.Index)\n\t\t\tindex.IsRegular = isRegular\n\t\t\tindex.Type = indexType\n\t\t\tindex.Name = indexName\n\t\t\tindexes[indexName] = index\n\t\t}\n\t\tindex.AddColumn(colName)\n\t}\n\treturn indexes, nil\n}\n\nfunc (db *mysql) CreateTableSql(table *core.Table, tableName, storeEngine, charset string) string {\n\tvar sql string\n\tsql = \"CREATE TABLE IF NOT EXISTS \"\n\tif tableName == \"\" {\n\t\ttableName = table.Name\n\t}\n\n\tsql += db.Quote(tableName)\n\tsql += \" (\"\n\n\tif len(table.ColumnsSeq()) > 0 {\n\t\tpkList := table.PrimaryKeys\n\n\t\tfor _, colName := range table.ColumnsSeq() {\n\t\t\tcol := table.GetColumn(colName)\n\t\t\tif col.IsPrimaryKey && len(pkList) == 1 {\n\t\t\t\tsql += col.String(db)\n\t\t\t} else {\n\t\t\t\tsql += col.StringNoPk(db)\n\t\t\t}\n\t\t\tsql = strings.TrimSpace(sql)\n\t\t\tif len(col.Comment) > 0 {\n\t\t\t\tsql += \" COMMENT '\" + col.Comment + \"'\"\n\t\t\t}\n\t\t\tsql += \", \"\n\t\t}\n\n\t\tif len(pkList) > 1 {\n\t\t\tsql += \"PRIMARY KEY ( \"\n\t\t\tsql += db.Quote(strings.Join(pkList, db.Quote(\",\")))\n\t\t\tsql += \" ), \"\n\t\t}\n\n\t\tsql = sql[:len(sql)-2]\n\t}\n\tsql += \")\"\n\n\tif storeEngine != \"\" {\n\t\tsql += \" ENGINE=\" + storeEngine\n\t}\n\n\tif len(charset) == 0 {\n\t\tcharset = db.URI().Charset\n\t}\n\tif len(charset) != 0 {\n\t\tsql += \" DEFAULT CHARSET \" + charset\n\t}\n\n\tif db.rowFormat != \"\" {\n\t\tsql += \" ROW_FORMAT=\" + db.rowFormat\n\t}\n\treturn sql\n}\n\nfunc (db *mysql) Filters() []core.Filter {\n\treturn []core.Filter{&core.IdFilter{}}\n}\n\ntype mymysqlDriver struct {\n}\n\nfunc (p *mymysqlDriver) Parse(driverName, dataSourceName string) (*core.Uri, error) {\n\tdb := &core.Uri{DbType: core.MYSQL}\n\n\tpd := strings.SplitN(dataSourceName, \"*\", 2)\n\tif len(pd) == 2 {\n\t\t// Parse protocol part of URI\n\t\tp := strings.SplitN(pd[0], \":\", 2)\n\t\tif len(p) != 2 {\n\t\t\treturn nil, errors.New(\"Wrong protocol part of URI\")\n\t\t}\n\t\tdb.Proto = p[0]\n\t\toptions := strings.Split(p[1], \",\")\n\t\tdb.Raddr = options[0]\n\t\tfor _, o := range options[1:] {\n\t\t\tkv := strings.SplitN(o, \"=\", 2)\n\t\t\tvar k, v string\n\t\t\tif len(kv) == 2 {\n\t\t\t\tk, v = kv[0], kv[1]\n\t\t\t} else {\n\t\t\t\tk, v = o, \"true\"\n\t\t\t}\n\t\t\tswitch k {\n\t\t\tcase \"laddr\":\n\t\t\t\tdb.Laddr = v\n\t\t\tcase \"timeout\":\n\t\t\t\tto, err := time.ParseDuration(v)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tdb.Timeout = to\n\t\t\tdefault:\n\t\t\t\treturn nil, errors.New(\"Unknown option: \" + k)\n\t\t\t}\n\t\t}\n\t\t// Remove protocol part\n\t\tpd = pd[1:]\n\t}\n\t// Parse database part of URI\n\tdup := strings.SplitN(pd[0], \"/\", 3)\n\tif len(dup) != 3 {\n\t\treturn nil, errors.New(\"Wrong database part of URI\")\n\t}\n\tdb.DbName = dup[0]\n\tdb.User = dup[1]\n\tdb.Passwd = dup[2]\n\n\treturn db, nil\n}\n\ntype mysqlDriver struct {\n}\n\nfunc (p *mysqlDriver) Parse(driverName, dataSourceName string) (*core.Uri, error) {\n\tdsnPattern := regexp.MustCompile(\n\t\t`^(?:(?P<user>.*?)(?::(?P<passwd>.*))?@)?` + // [user[:password]@]\n\t\t\t`(?:(?P<net>[^\\(]*)(?:\\((?P<addr>[^\\)]*)\\))?)?` + // [net[(addr)]]\n\t\t\t`\\/(?P<dbname>.*?)` + // /dbname\n\t\t\t`(?:\\?(?P<params>[^\\?]*))?$`) // [?param1=value1&paramN=valueN]\n\tmatches := dsnPattern.FindStringSubmatch(dataSourceName)\n\t// tlsConfigRegister := make(map[string]*tls.Config)\n\tnames := dsnPattern.SubexpNames()\n\n\turi := &core.Uri{DbType: core.MYSQL}\n\n\tfor i, match := range matches {\n\t\tswitch names[i] {\n\t\tcase \"dbname\":\n\t\t\turi.DbName = match\n\t\tcase \"params\":\n\t\t\tif len(match) > 0 {\n\t\t\t\tkvs := strings.Split(match, \"&\")\n\t\t\t\tfor _, kv := range kvs {\n\t\t\t\t\tsplits := strings.Split(kv, \"=\")\n\t\t\t\t\tif len(splits) == 2 {\n\t\t\t\t\t\tswitch splits[0] {\n\t\t\t\t\t\tcase \"charset\":\n\t\t\t\t\t\t\turi.Charset = splits[1]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\treturn uri, nil\n}\n"
        },
        {
          "name": "dialect_oracle.go",
          "type": "blob",
          "size": 27.62109375,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"xorm.io/core\"\n)\n\nvar (\n\toracleReservedWords = map[string]bool{\n\t\t\"ACCESS\":                    true,\n\t\t\"ACCOUNT\":                   true,\n\t\t\"ACTIVATE\":                  true,\n\t\t\"ADD\":                       true,\n\t\t\"ADMIN\":                     true,\n\t\t\"ADVISE\":                    true,\n\t\t\"AFTER\":                     true,\n\t\t\"ALL\":                       true,\n\t\t\"ALL_ROWS\":                  true,\n\t\t\"ALLOCATE\":                  true,\n\t\t\"ALTER\":                     true,\n\t\t\"ANALYZE\":                   true,\n\t\t\"AND\":                       true,\n\t\t\"ANY\":                       true,\n\t\t\"ARCHIVE\":                   true,\n\t\t\"ARCHIVELOG\":                true,\n\t\t\"ARRAY\":                     true,\n\t\t\"AS\":                        true,\n\t\t\"ASC\":                       true,\n\t\t\"AT\":                        true,\n\t\t\"AUDIT\":                     true,\n\t\t\"AUTHENTICATED\":             true,\n\t\t\"AUTHORIZATION\":             true,\n\t\t\"AUTOEXTEND\":                true,\n\t\t\"AUTOMATIC\":                 true,\n\t\t\"BACKUP\":                    true,\n\t\t\"BECOME\":                    true,\n\t\t\"BEFORE\":                    true,\n\t\t\"BEGIN\":                     true,\n\t\t\"BETWEEN\":                   true,\n\t\t\"BFILE\":                     true,\n\t\t\"BITMAP\":                    true,\n\t\t\"BLOB\":                      true,\n\t\t\"BLOCK\":                     true,\n\t\t\"BODY\":                      true,\n\t\t\"BY\":                        true,\n\t\t\"CACHE\":                     true,\n\t\t\"CACHE_INSTANCES\":           true,\n\t\t\"CANCEL\":                    true,\n\t\t\"CASCADE\":                   true,\n\t\t\"CAST\":                      true,\n\t\t\"CFILE\":                     true,\n\t\t\"CHAINED\":                   true,\n\t\t\"CHANGE\":                    true,\n\t\t\"CHAR\":                      true,\n\t\t\"CHAR_CS\":                   true,\n\t\t\"CHARACTER\":                 true,\n\t\t\"CHECK\":                     true,\n\t\t\"CHECKPOINT\":                true,\n\t\t\"CHOOSE\":                    true,\n\t\t\"CHUNK\":                     true,\n\t\t\"CLEAR\":                     true,\n\t\t\"CLOB\":                      true,\n\t\t\"CLONE\":                     true,\n\t\t\"CLOSE\":                     true,\n\t\t\"CLOSE_CACHED_OPEN_CURSORS\": true,\n\t\t\"CLUSTER\":                   true,\n\t\t\"COALESCE\":                  true,\n\t\t\"COLUMN\":                    true,\n\t\t\"COLUMNS\":                   true,\n\t\t\"COMMENT\":                   true,\n\t\t\"COMMIT\":                    true,\n\t\t\"COMMITTED\":                 true,\n\t\t\"COMPATIBILITY\":             true,\n\t\t\"COMPILE\":                   true,\n\t\t\"COMPLETE\":                  true,\n\t\t\"COMPOSITE_LIMIT\":           true,\n\t\t\"COMPRESS\":                  true,\n\t\t\"COMPUTE\":                   true,\n\t\t\"CONNECT\":                   true,\n\t\t\"CONNECT_TIME\":              true,\n\t\t\"CONSTRAINT\":                true,\n\t\t\"CONSTRAINTS\":               true,\n\t\t\"CONTENTS\":                  true,\n\t\t\"CONTINUE\":                  true,\n\t\t\"CONTROLFILE\":               true,\n\t\t\"CONVERT\":                   true,\n\t\t\"COST\":                      true,\n\t\t\"CPU_PER_CALL\":              true,\n\t\t\"CPU_PER_SESSION\":           true,\n\t\t\"CREATE\":                    true,\n\t\t\"CURRENT\":                   true,\n\t\t\"CURRENT_SCHEMA\":            true,\n\t\t\"CURREN_USER\":               true,\n\t\t\"CURSOR\":                    true,\n\t\t\"CYCLE\":                     true,\n\t\t\"DANGLING\":                  true,\n\t\t\"DATABASE\":                  true,\n\t\t\"DATAFILE\":                  true,\n\t\t\"DATAFILES\":                 true,\n\t\t\"DATAOBJNO\":                 true,\n\t\t\"DATE\":                      true,\n\t\t\"DBA\":                       true,\n\t\t\"DBHIGH\":                    true,\n\t\t\"DBLOW\":                     true,\n\t\t\"DBMAC\":                     true,\n\t\t\"DEALLOCATE\":                true,\n\t\t\"DEBUG\":                     true,\n\t\t\"DEC\":                       true,\n\t\t\"DECIMAL\":                   true,\n\t\t\"DECLARE\":                   true,\n\t\t\"DEFAULT\":                   true,\n\t\t\"DEFERRABLE\":                true,\n\t\t\"DEFERRED\":                  true,\n\t\t\"DEGREE\":                    true,\n\t\t\"DELETE\":                    true,\n\t\t\"DEREF\":                     true,\n\t\t\"DESC\":                      true,\n\t\t\"DIRECTORY\":                 true,\n\t\t\"DISABLE\":                   true,\n\t\t\"DISCONNECT\":                true,\n\t\t\"DISMOUNT\":                  true,\n\t\t\"DISTINCT\":                  true,\n\t\t\"DISTRIBUTED\":               true,\n\t\t\"DML\":                       true,\n\t\t\"DOUBLE\":                    true,\n\t\t\"DROP\":                      true,\n\t\t\"DUMP\":                      true,\n\t\t\"EACH\":                      true,\n\t\t\"ELSE\":                      true,\n\t\t\"ENABLE\":                    true,\n\t\t\"END\":                       true,\n\t\t\"ENFORCE\":                   true,\n\t\t\"ENTRY\":                     true,\n\t\t\"ESCAPE\":                    true,\n\t\t\"EXCEPT\":                    true,\n\t\t\"EXCEPTIONS\":                true,\n\t\t\"EXCHANGE\":                  true,\n\t\t\"EXCLUDING\":                 true,\n\t\t\"EXCLUSIVE\":                 true,\n\t\t\"EXECUTE\":                   true,\n\t\t\"EXISTS\":                    true,\n\t\t\"EXPIRE\":                    true,\n\t\t\"EXPLAIN\":                   true,\n\t\t\"EXTENT\":                    true,\n\t\t\"EXTENTS\":                   true,\n\t\t\"EXTERNALLY\":                true,\n\t\t\"FAILED_LOGIN_ATTEMPTS\":     true,\n\t\t\"FALSE\":                     true,\n\t\t\"FAST\":                      true,\n\t\t\"FILE\":                      true,\n\t\t\"FIRST_ROWS\":                true,\n\t\t\"FLAGGER\":                   true,\n\t\t\"FLOAT\":                     true,\n\t\t\"FLOB\":                      true,\n\t\t\"FLUSH\":                     true,\n\t\t\"FOR\":                       true,\n\t\t\"FORCE\":                     true,\n\t\t\"FOREIGN\":                   true,\n\t\t\"FREELIST\":                  true,\n\t\t\"FREELISTS\":                 true,\n\t\t\"FROM\":                      true,\n\t\t\"FULL\":                      true,\n\t\t\"FUNCTION\":                  true,\n\t\t\"GLOBAL\":                    true,\n\t\t\"GLOBALLY\":                  true,\n\t\t\"GLOBAL_NAME\":               true,\n\t\t\"GRANT\":                     true,\n\t\t\"GROUP\":                     true,\n\t\t\"GROUPS\":                    true,\n\t\t\"HASH\":                      true,\n\t\t\"HASHKEYS\":                  true,\n\t\t\"HAVING\":                    true,\n\t\t\"HEADER\":                    true,\n\t\t\"HEAP\":                      true,\n\t\t\"IDENTIFIED\":                true,\n\t\t\"IDGENERATORS\":              true,\n\t\t\"IDLE_TIME\":                 true,\n\t\t\"IF\":                        true,\n\t\t\"IMMEDIATE\":                 true,\n\t\t\"IN\":                        true,\n\t\t\"INCLUDING\":                 true,\n\t\t\"INCREMENT\":                 true,\n\t\t\"INDEX\":                     true,\n\t\t\"INDEXED\":                   true,\n\t\t\"INDEXES\":                   true,\n\t\t\"INDICATOR\":                 true,\n\t\t\"IND_PARTITION\":             true,\n\t\t\"INITIAL\":                   true,\n\t\t\"INITIALLY\":                 true,\n\t\t\"INITRANS\":                  true,\n\t\t\"INSERT\":                    true,\n\t\t\"INSTANCE\":                  true,\n\t\t\"INSTANCES\":                 true,\n\t\t\"INSTEAD\":                   true,\n\t\t\"INT\":                       true,\n\t\t\"INTEGER\":                   true,\n\t\t\"INTERMEDIATE\":              true,\n\t\t\"INTERSECT\":                 true,\n\t\t\"INTO\":                      true,\n\t\t\"IS\":                        true,\n\t\t\"ISOLATION\":                 true,\n\t\t\"ISOLATION_LEVEL\":           true,\n\t\t\"KEEP\":                      true,\n\t\t\"KEY\":                       true,\n\t\t\"KILL\":                      true,\n\t\t\"LABEL\":                     true,\n\t\t\"LAYER\":                     true,\n\t\t\"LESS\":                      true,\n\t\t\"LEVEL\":                     true,\n\t\t\"LIBRARY\":                   true,\n\t\t\"LIKE\":                      true,\n\t\t\"LIMIT\":                     true,\n\t\t\"LINK\":                      true,\n\t\t\"LIST\":                      true,\n\t\t\"LOB\":                       true,\n\t\t\"LOCAL\":                     true,\n\t\t\"LOCK\":                      true,\n\t\t\"LOCKED\":                    true,\n\t\t\"LOG\":                       true,\n\t\t\"LOGFILE\":                   true,\n\t\t\"LOGGING\":                   true,\n\t\t\"LOGICAL_READS_PER_CALL\":    true,\n\t\t\"LOGICAL_READS_PER_SESSION\": true,\n\t\t\"LONG\":                      true,\n\t\t\"MANAGE\":                    true,\n\t\t\"MASTER\":                    true,\n\t\t\"MAX\":                       true,\n\t\t\"MAXARCHLOGS\":               true,\n\t\t\"MAXDATAFILES\":              true,\n\t\t\"MAXEXTENTS\":                true,\n\t\t\"MAXINSTANCES\":              true,\n\t\t\"MAXLOGFILES\":               true,\n\t\t\"MAXLOGHISTORY\":             true,\n\t\t\"MAXLOGMEMBERS\":             true,\n\t\t\"MAXSIZE\":                   true,\n\t\t\"MAXTRANS\":                  true,\n\t\t\"MAXVALUE\":                  true,\n\t\t\"MIN\":                       true,\n\t\t\"MEMBER\":                    true,\n\t\t\"MINIMUM\":                   true,\n\t\t\"MINEXTENTS\":                true,\n\t\t\"MINUS\":                     true,\n\t\t\"MINVALUE\":                  true,\n\t\t\"MLSLABEL\":                  true,\n\t\t\"MLS_LABEL_FORMAT\":          true,\n\t\t\"MODE\":                      true,\n\t\t\"MODIFY\":                    true,\n\t\t\"MOUNT\":                     true,\n\t\t\"MOVE\":                      true,\n\t\t\"MTS_DISPATCHERS\":           true,\n\t\t\"MULTISET\":                  true,\n\t\t\"NATIONAL\":                  true,\n\t\t\"NCHAR\":                     true,\n\t\t\"NCHAR_CS\":                  true,\n\t\t\"NCLOB\":                     true,\n\t\t\"NEEDED\":                    true,\n\t\t\"NESTED\":                    true,\n\t\t\"NETWORK\":                   true,\n\t\t\"NEW\":                       true,\n\t\t\"NEXT\":                      true,\n\t\t\"NOARCHIVELOG\":              true,\n\t\t\"NOAUDIT\":                   true,\n\t\t\"NOCACHE\":                   true,\n\t\t\"NOCOMPRESS\":                true,\n\t\t\"NOCYCLE\":                   true,\n\t\t\"NOFORCE\":                   true,\n\t\t\"NOLOGGING\":                 true,\n\t\t\"NOMAXVALUE\":                true,\n\t\t\"NOMINVALUE\":                true,\n\t\t\"NONE\":                      true,\n\t\t\"NOORDER\":                   true,\n\t\t\"NOOVERRIDE\":                true,\n\t\t\"NOPARALLEL\":                true,\n\t\t\"NOREVERSE\":                 true,\n\t\t\"NORMAL\":                    true,\n\t\t\"NOSORT\":                    true,\n\t\t\"NOT\":                       true,\n\t\t\"NOTHING\":                   true,\n\t\t\"NOWAIT\":                    true,\n\t\t\"NULL\":                      true,\n\t\t\"NUMBER\":                    true,\n\t\t\"NUMERIC\":                   true,\n\t\t\"NVARCHAR2\":                 true,\n\t\t\"OBJECT\":                    true,\n\t\t\"OBJNO\":                     true,\n\t\t\"OBJNO_REUSE\":               true,\n\t\t\"OF\":                        true,\n\t\t\"OFF\":                       true,\n\t\t\"OFFLINE\":                   true,\n\t\t\"OID\":                       true,\n\t\t\"OIDINDEX\":                  true,\n\t\t\"OLD\":                       true,\n\t\t\"ON\":                        true,\n\t\t\"ONLINE\":                    true,\n\t\t\"ONLY\":                      true,\n\t\t\"OPCODE\":                    true,\n\t\t\"OPEN\":                      true,\n\t\t\"OPTIMAL\":                   true,\n\t\t\"OPTIMIZER_GOAL\":            true,\n\t\t\"OPTION\":                    true,\n\t\t\"OR\":                        true,\n\t\t\"ORDER\":                     true,\n\t\t\"ORGANIZATION\":              true,\n\t\t\"OSLABEL\":                   true,\n\t\t\"OVERFLOW\":                  true,\n\t\t\"OWN\":                       true,\n\t\t\"PACKAGE\":                   true,\n\t\t\"PARALLEL\":                  true,\n\t\t\"PARTITION\":                 true,\n\t\t\"PASSWORD\":                  true,\n\t\t\"PASSWORD_GRACE_TIME\":       true,\n\t\t\"PASSWORD_LIFE_TIME\":        true,\n\t\t\"PASSWORD_LOCK_TIME\":        true,\n\t\t\"PASSWORD_REUSE_MAX\":        true,\n\t\t\"PASSWORD_REUSE_TIME\":       true,\n\t\t\"PASSWORD_VERIFY_FUNCTION\":  true,\n\t\t\"PCTFREE\":                   true,\n\t\t\"PCTINCREASE\":               true,\n\t\t\"PCTTHRESHOLD\":              true,\n\t\t\"PCTUSED\":                   true,\n\t\t\"PCTVERSION\":                true,\n\t\t\"PERCENT\":                   true,\n\t\t\"PERMANENT\":                 true,\n\t\t\"PLAN\":                      true,\n\t\t\"PLSQL_DEBUG\":               true,\n\t\t\"POST_TRANSACTION\":          true,\n\t\t\"PRECISION\":                 true,\n\t\t\"PRESERVE\":                  true,\n\t\t\"PRIMARY\":                   true,\n\t\t\"PRIOR\":                     true,\n\t\t\"PRIVATE\":                   true,\n\t\t\"PRIVATE_SGA\":               true,\n\t\t\"PRIVILEGE\":                 true,\n\t\t\"PRIVILEGES\":                true,\n\t\t\"PROCEDURE\":                 true,\n\t\t\"PROFILE\":                   true,\n\t\t\"PUBLIC\":                    true,\n\t\t\"PURGE\":                     true,\n\t\t\"QUEUE\":                     true,\n\t\t\"QUOTA\":                     true,\n\t\t\"RANGE\":                     true,\n\t\t\"RAW\":                       true,\n\t\t\"RBA\":                       true,\n\t\t\"READ\":                      true,\n\t\t\"READUP\":                    true,\n\t\t\"REAL\":                      true,\n\t\t\"REBUILD\":                   true,\n\t\t\"RECOVER\":                   true,\n\t\t\"RECOVERABLE\":               true,\n\t\t\"RECOVERY\":                  true,\n\t\t\"REF\":                       true,\n\t\t\"REFERENCES\":                true,\n\t\t\"REFERENCING\":               true,\n\t\t\"REFRESH\":                   true,\n\t\t\"RENAME\":                    true,\n\t\t\"REPLACE\":                   true,\n\t\t\"RESET\":                     true,\n\t\t\"RESETLOGS\":                 true,\n\t\t\"RESIZE\":                    true,\n\t\t\"RESOURCE\":                  true,\n\t\t\"RESTRICTED\":                true,\n\t\t\"RETURN\":                    true,\n\t\t\"RETURNING\":                 true,\n\t\t\"REUSE\":                     true,\n\t\t\"REVERSE\":                   true,\n\t\t\"REVOKE\":                    true,\n\t\t\"ROLE\":                      true,\n\t\t\"ROLES\":                     true,\n\t\t\"ROLLBACK\":                  true,\n\t\t\"ROW\":                       true,\n\t\t\"ROWID\":                     true,\n\t\t\"ROWNUM\":                    true,\n\t\t\"ROWS\":                      true,\n\t\t\"RULE\":                      true,\n\t\t\"SAMPLE\":                    true,\n\t\t\"SAVEPOINT\":                 true,\n\t\t\"SB4\":                       true,\n\t\t\"SCAN_INSTANCES\":            true,\n\t\t\"SCHEMA\":                    true,\n\t\t\"SCN\":                       true,\n\t\t\"SCOPE\":                     true,\n\t\t\"SD_ALL\":                    true,\n\t\t\"SD_INHIBIT\":                true,\n\t\t\"SD_SHOW\":                   true,\n\t\t\"SEGMENT\":                   true,\n\t\t\"SEG_BLOCK\":                 true,\n\t\t\"SEG_FILE\":                  true,\n\t\t\"SELECT\":                    true,\n\t\t\"SEQUENCE\":                  true,\n\t\t\"SERIALIZABLE\":              true,\n\t\t\"SESSION\":                   true,\n\t\t\"SESSION_CACHED_CURSORS\":    true,\n\t\t\"SESSIONS_PER_USER\":         true,\n\t\t\"SET\":                       true,\n\t\t\"SHARE\":                     true,\n\t\t\"SHARED\":                    true,\n\t\t\"SHARED_POOL\":               true,\n\t\t\"SHRINK\":                    true,\n\t\t\"SIZE\":                      true,\n\t\t\"SKIP\":                      true,\n\t\t\"SKIP_UNUSABLE_INDEXES\":     true,\n\t\t\"SMALLINT\":                  true,\n\t\t\"SNAPSHOT\":                  true,\n\t\t\"SOME\":                      true,\n\t\t\"SORT\":                      true,\n\t\t\"SPECIFICATION\":             true,\n\t\t\"SPLIT\":                     true,\n\t\t\"SQL_TRACE\":                 true,\n\t\t\"STANDBY\":                   true,\n\t\t\"START\":                     true,\n\t\t\"STATEMENT_ID\":              true,\n\t\t\"STATISTICS\":                true,\n\t\t\"STOP\":                      true,\n\t\t\"STORAGE\":                   true,\n\t\t\"STORE\":                     true,\n\t\t\"STRUCTURE\":                 true,\n\t\t\"SUCCESSFUL\":                true,\n\t\t\"SWITCH\":                    true,\n\t\t\"SYS_OP_ENFORCE_NOT_NULL$\":  true,\n\t\t\"SYS_OP_NTCIMG$\":            true,\n\t\t\"SYNONYM\":                   true,\n\t\t\"SYSDATE\":                   true,\n\t\t\"SYSDBA\":                    true,\n\t\t\"SYSOPER\":                   true,\n\t\t\"SYSTEM\":                    true,\n\t\t\"TABLE\":                     true,\n\t\t\"TABLES\":                    true,\n\t\t\"TABLESPACE\":                true,\n\t\t\"TABLESPACE_NO\":             true,\n\t\t\"TABNO\":                     true,\n\t\t\"TEMPORARY\":                 true,\n\t\t\"THAN\":                      true,\n\t\t\"THE\":                       true,\n\t\t\"THEN\":                      true,\n\t\t\"THREAD\":                    true,\n\t\t\"TIMESTAMP\":                 true,\n\t\t\"TIME\":                      true,\n\t\t\"TO\":                        true,\n\t\t\"TOPLEVEL\":                  true,\n\t\t\"TRACE\":                     true,\n\t\t\"TRACING\":                   true,\n\t\t\"TRANSACTION\":               true,\n\t\t\"TRANSITIONAL\":              true,\n\t\t\"TRIGGER\":                   true,\n\t\t\"TRIGGERS\":                  true,\n\t\t\"TRUE\":                      true,\n\t\t\"TRUNCATE\":                  true,\n\t\t\"TX\":                        true,\n\t\t\"TYPE\":                      true,\n\t\t\"UB2\":                       true,\n\t\t\"UBA\":                       true,\n\t\t\"UID\":                       true,\n\t\t\"UNARCHIVED\":                true,\n\t\t\"UNDO\":                      true,\n\t\t\"UNION\":                     true,\n\t\t\"UNIQUE\":                    true,\n\t\t\"UNLIMITED\":                 true,\n\t\t\"UNLOCK\":                    true,\n\t\t\"UNRECOVERABLE\":             true,\n\t\t\"UNTIL\":                     true,\n\t\t\"UNUSABLE\":                  true,\n\t\t\"UNUSED\":                    true,\n\t\t\"UPDATABLE\":                 true,\n\t\t\"UPDATE\":                    true,\n\t\t\"USAGE\":                     true,\n\t\t\"USE\":                       true,\n\t\t\"USER\":                      true,\n\t\t\"USING\":                     true,\n\t\t\"VALIDATE\":                  true,\n\t\t\"VALIDATION\":                true,\n\t\t\"VALUE\":                     true,\n\t\t\"VALUES\":                    true,\n\t\t\"VARCHAR\":                   true,\n\t\t\"VARCHAR2\":                  true,\n\t\t\"VARYING\":                   true,\n\t\t\"VIEW\":                      true,\n\t\t\"WHEN\":                      true,\n\t\t\"WHENEVER\":                  true,\n\t\t\"WHERE\":                     true,\n\t\t\"WITH\":                      true,\n\t\t\"WITHOUT\":                   true,\n\t\t\"WORK\":                      true,\n\t\t\"WRITE\":                     true,\n\t\t\"WRITEDOWN\":                 true,\n\t\t\"WRITEUP\":                   true,\n\t\t\"XID\":                       true,\n\t\t\"YEAR\":                      true,\n\t\t\"ZONE\":                      true,\n\t}\n)\n\ntype oracle struct {\n\tcore.Base\n}\n\nfunc (db *oracle) Init(d *core.DB, uri *core.Uri, drivername, dataSourceName string) error {\n\treturn db.Base.Init(d, db, uri, drivername, dataSourceName)\n}\n\nfunc (db *oracle) SqlType(c *core.Column) string {\n\tvar res string\n\tswitch t := c.SQLType.Name; t {\n\tcase core.Bit, core.TinyInt, core.SmallInt, core.MediumInt, core.Int, core.Integer, core.BigInt, core.Bool, core.Serial, core.BigSerial:\n\t\tres = \"NUMBER\"\n\tcase core.Binary, core.VarBinary, core.Blob, core.TinyBlob, core.MediumBlob, core.LongBlob, core.Bytea:\n\t\treturn core.Blob\n\tcase core.Time, core.DateTime, core.TimeStamp:\n\t\tres = core.TimeStamp\n\tcase core.TimeStampz:\n\t\tres = \"TIMESTAMP WITH TIME ZONE\"\n\tcase core.Float, core.Double, core.Numeric, core.Decimal:\n\t\tres = \"NUMBER\"\n\tcase core.Text, core.MediumText, core.LongText, core.Json:\n\t\tres = \"CLOB\"\n\tcase core.Char, core.Varchar, core.TinyText:\n\t\tres = \"VARCHAR2\"\n\tdefault:\n\t\tres = t\n\t}\n\n\thasLen1 := (c.Length > 0)\n\thasLen2 := (c.Length2 > 0)\n\n\tif hasLen2 {\n\t\tres += \"(\" + strconv.Itoa(c.Length) + \",\" + strconv.Itoa(c.Length2) + \")\"\n\t} else if hasLen1 {\n\t\tres += \"(\" + strconv.Itoa(c.Length) + \")\"\n\t}\n\treturn res\n}\n\nfunc (db *oracle) AutoIncrStr() string {\n\treturn \"AUTO_INCREMENT\"\n}\n\nfunc (db *oracle) SupportInsertMany() bool {\n\treturn true\n}\n\nfunc (db *oracle) IsReserved(name string) bool {\n\t_, ok := oracleReservedWords[name]\n\treturn ok\n}\n\nfunc (db *oracle) Quote(name string) string {\n\treturn \"[\" + name + \"]\"\n}\n\nfunc (db *oracle) SupportEngine() bool {\n\treturn false\n}\n\nfunc (db *oracle) SupportCharset() bool {\n\treturn false\n}\n\nfunc (db *oracle) SupportDropIfExists() bool {\n\treturn false\n}\n\nfunc (db *oracle) IndexOnTable() bool {\n\treturn false\n}\n\nfunc (db *oracle) DropTableSql(tableName string) string {\n\treturn fmt.Sprintf(\"DROP TABLE `%s`\", tableName)\n}\n\nfunc (db *oracle) CreateTableSql(table *core.Table, tableName, storeEngine, charset string) string {\n\tvar sql string\n\tsql = \"CREATE TABLE \"\n\tif tableName == \"\" {\n\t\ttableName = table.Name\n\t}\n\n\tsql += db.Quote(tableName) + \" (\"\n\n\tpkList := table.PrimaryKeys\n\n\tfor _, colName := range table.ColumnsSeq() {\n\t\tcol := table.GetColumn(colName)\n\t\t/*if col.IsPrimaryKey && len(pkList) == 1 {\n\t\t\tsql += col.String(b.dialect)\n\t\t} else {*/\n\t\tsql += col.StringNoPk(db)\n\t\t// }\n\t\tsql = strings.TrimSpace(sql)\n\t\tsql += \", \"\n\t}\n\n\tif len(pkList) > 0 {\n\t\tsql += \"PRIMARY KEY ( \"\n\t\tsql += db.Quote(strings.Join(pkList, db.Quote(\",\")))\n\t\tsql += \" ), \"\n\t}\n\n\tsql = sql[:len(sql)-2] + \")\"\n\tif db.SupportEngine() && storeEngine != \"\" {\n\t\tsql += \" ENGINE=\" + storeEngine\n\t}\n\tif db.SupportCharset() {\n\t\tif len(charset) == 0 {\n\t\t\tcharset = db.URI().Charset\n\t\t}\n\t\tif len(charset) > 0 {\n\t\t\tsql += \" DEFAULT CHARSET \" + charset\n\t\t}\n\t}\n\treturn sql\n}\n\nfunc (db *oracle) IndexCheckSql(tableName, idxName string) (string, []interface{}) {\n\targs := []interface{}{tableName, idxName}\n\treturn `SELECT INDEX_NAME FROM USER_INDEXES ` +\n\t\t`WHERE TABLE_NAME = :1 AND INDEX_NAME = :2`, args\n}\n\nfunc (db *oracle) TableCheckSql(tableName string) (string, []interface{}) {\n\targs := []interface{}{tableName}\n\treturn `SELECT table_name FROM user_tables WHERE table_name = :1`, args\n}\n\nfunc (db *oracle) MustDropTable(tableName string) error {\n\tsql, args := db.TableCheckSql(tableName)\n\tdb.LogSQL(sql, args)\n\n\trows, err := db.DB().Query(sql, args...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer rows.Close()\n\n\tif !rows.Next() {\n\t\treturn nil\n\t}\n\n\tsql = \"Drop Table \\\"\" + tableName + \"\\\"\"\n\tdb.LogSQL(sql, args)\n\n\t_, err = db.DB().Exec(sql)\n\treturn err\n}\n\n/*func (db *oracle) ColumnCheckSql(tableName, colName string) (string, []interface{}) {\n\targs := []interface{}{strings.ToUpper(tableName), strings.ToUpper(colName)}\n\treturn \"SELECT column_name FROM USER_TAB_COLUMNS WHERE table_name = ?\" +\n\t\t\" AND column_name = ?\", args\n}*/\n\nfunc (db *oracle) IsColumnExist(tableName, colName string) (bool, error) {\n\targs := []interface{}{tableName, colName}\n\tquery := \"SELECT column_name FROM USER_TAB_COLUMNS WHERE table_name = :1\" +\n\t\t\" AND column_name = :2\"\n\tdb.LogSQL(query, args)\n\n\trows, err := db.DB().Query(query, args...)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer rows.Close()\n\n\tif rows.Next() {\n\t\treturn true, nil\n\t}\n\treturn false, nil\n}\n\nfunc (db *oracle) GetColumns(tableName string) ([]string, map[string]*core.Column, error) {\n\targs := []interface{}{tableName}\n\ts := \"SELECT column_name,data_default,data_type,data_length,data_precision,data_scale,\" +\n\t\t\"nullable FROM USER_TAB_COLUMNS WHERE table_name = :1\"\n\tdb.LogSQL(s, args)\n\n\trows, err := db.DB().Query(s, args...)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer rows.Close()\n\n\tcols := make(map[string]*core.Column)\n\tcolSeq := make([]string, 0)\n\tfor rows.Next() {\n\t\tcol := new(core.Column)\n\t\tcol.Indexes = make(map[string]int)\n\n\t\tvar colName, colDefault, nullable, dataType, dataPrecision, dataScale *string\n\t\tvar dataLen int\n\n\t\terr = rows.Scan(&colName, &colDefault, &dataType, &dataLen, &dataPrecision,\n\t\t\t&dataScale, &nullable)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\tcol.Name = strings.Trim(*colName, `\" `)\n\t\tif colDefault != nil {\n\t\t\tcol.Default = *colDefault\n\t\t\tcol.DefaultIsEmpty = false\n\t\t}\n\n\t\tif *nullable == \"Y\" {\n\t\t\tcol.Nullable = true\n\t\t} else {\n\t\t\tcol.Nullable = false\n\t\t}\n\n\t\tvar ignore bool\n\n\t\tvar dt string\n\t\tvar len1, len2 int\n\t\tdts := strings.Split(*dataType, \"(\")\n\t\tdt = dts[0]\n\t\tif len(dts) > 1 {\n\t\t\tlens := strings.Split(dts[1][:len(dts[1])-1], \",\")\n\t\t\tif len(lens) > 1 {\n\t\t\t\tlen1, _ = strconv.Atoi(lens[0])\n\t\t\t\tlen2, _ = strconv.Atoi(lens[1])\n\t\t\t} else {\n\t\t\t\tlen1, _ = strconv.Atoi(lens[0])\n\t\t\t}\n\t\t}\n\n\t\tswitch dt {\n\t\tcase \"VARCHAR2\":\n\t\t\tcol.SQLType = core.SQLType{Name: core.Varchar, DefaultLength: len1, DefaultLength2: len2}\n\t\tcase \"NVARCHAR2\":\n\t\t\tcol.SQLType = core.SQLType{Name: core.NVarchar, DefaultLength: len1, DefaultLength2: len2}\n\t\tcase \"TIMESTAMP WITH TIME ZONE\":\n\t\t\tcol.SQLType = core.SQLType{Name: core.TimeStampz, DefaultLength: 0, DefaultLength2: 0}\n\t\tcase \"NUMBER\":\n\t\t\tcol.SQLType = core.SQLType{Name: core.Double, DefaultLength: len1, DefaultLength2: len2}\n\t\tcase \"LONG\", \"LONG RAW\":\n\t\t\tcol.SQLType = core.SQLType{Name: core.Text, DefaultLength: 0, DefaultLength2: 0}\n\t\tcase \"RAW\":\n\t\t\tcol.SQLType = core.SQLType{Name: core.Binary, DefaultLength: 0, DefaultLength2: 0}\n\t\tcase \"ROWID\":\n\t\t\tcol.SQLType = core.SQLType{Name: core.Varchar, DefaultLength: 18, DefaultLength2: 0}\n\t\tcase \"AQ$_SUBSCRIBERS\":\n\t\t\tignore = true\n\t\tdefault:\n\t\t\tcol.SQLType = core.SQLType{Name: strings.ToUpper(dt), DefaultLength: len1, DefaultLength2: len2}\n\t\t}\n\n\t\tif ignore {\n\t\t\tcontinue\n\t\t}\n\n\t\tif _, ok := core.SqlTypes[col.SQLType.Name]; !ok {\n\t\t\treturn nil, nil, fmt.Errorf(\"Unknown colType %v %v\", *dataType, col.SQLType)\n\t\t}\n\n\t\tcol.Length = dataLen\n\n\t\tif col.SQLType.IsText() || col.SQLType.IsTime() {\n\t\t\tif !col.DefaultIsEmpty {\n\t\t\t\tcol.Default = \"'\" + col.Default + \"'\"\n\t\t\t}\n\t\t}\n\t\tcols[col.Name] = col\n\t\tcolSeq = append(colSeq, col.Name)\n\t}\n\n\treturn colSeq, cols, nil\n}\n\nfunc (db *oracle) GetTables() ([]*core.Table, error) {\n\targs := []interface{}{}\n\ts := \"SELECT table_name FROM user_tables\"\n\tdb.LogSQL(s, args)\n\n\trows, err := db.DB().Query(s, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\ttables := make([]*core.Table, 0)\n\tfor rows.Next() {\n\t\ttable := core.NewEmptyTable()\n\t\terr = rows.Scan(&table.Name)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ttables = append(tables, table)\n\t}\n\treturn tables, nil\n}\n\nfunc (db *oracle) GetIndexes(tableName string) (map[string]*core.Index, error) {\n\targs := []interface{}{tableName}\n\ts := \"SELECT t.column_name,i.uniqueness,i.index_name FROM user_ind_columns t,user_indexes i \" +\n\t\t\"WHERE t.index_name = i.index_name and t.table_name = i.table_name and t.table_name =:1\"\n\tdb.LogSQL(s, args)\n\n\trows, err := db.DB().Query(s, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tindexes := make(map[string]*core.Index, 0)\n\tfor rows.Next() {\n\t\tvar indexType int\n\t\tvar indexName, colName, uniqueness string\n\n\t\terr = rows.Scan(&colName, &uniqueness, &indexName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tindexName = strings.Trim(indexName, `\" `)\n\n\t\tvar isRegular bool\n\t\tif strings.HasPrefix(indexName, \"IDX_\"+tableName) || strings.HasPrefix(indexName, \"UQE_\"+tableName) {\n\t\t\tindexName = indexName[5+len(tableName):]\n\t\t\tisRegular = true\n\t\t}\n\n\t\tif uniqueness == \"UNIQUE\" {\n\t\t\tindexType = core.UniqueType\n\t\t} else {\n\t\t\tindexType = core.IndexType\n\t\t}\n\n\t\tvar index *core.Index\n\t\tvar ok bool\n\t\tif index, ok = indexes[indexName]; !ok {\n\t\t\tindex = new(core.Index)\n\t\t\tindex.Type = indexType\n\t\t\tindex.Name = indexName\n\t\t\tindex.IsRegular = isRegular\n\t\t\tindexes[indexName] = index\n\t\t}\n\t\tindex.AddColumn(colName)\n\t}\n\treturn indexes, nil\n}\n\nfunc (db *oracle) Filters() []core.Filter {\n\treturn []core.Filter{&core.QuoteFilter{}, &core.SeqFilter{Prefix: \":\", Start: 1}, &core.IdFilter{}}\n}\n\ntype goracleDriver struct {\n}\n\nfunc (cfg *goracleDriver) Parse(driverName, dataSourceName string) (*core.Uri, error) {\n\tdb := &core.Uri{DbType: core.ORACLE}\n\tdsnPattern := regexp.MustCompile(\n\t\t`^(?:(?P<user>.*?)(?::(?P<passwd>.*))?@)?` + // [user[:password]@]\n\t\t\t`(?:(?P<net>[^\\(]*)(?:\\((?P<addr>[^\\)]*)\\))?)?` + // [net[(addr)]]\n\t\t\t`\\/(?P<dbname>.*?)` + // /dbname\n\t\t\t`(?:\\?(?P<params>[^\\?]*))?$`) // [?param1=value1&paramN=valueN]\n\tmatches := dsnPattern.FindStringSubmatch(dataSourceName)\n\t// tlsConfigRegister := make(map[string]*tls.Config)\n\tnames := dsnPattern.SubexpNames()\n\n\tfor i, match := range matches {\n\t\tswitch names[i] {\n\t\tcase \"dbname\":\n\t\t\tdb.DbName = match\n\t\t}\n\t}\n\tif db.DbName == \"\" {\n\t\treturn nil, errors.New(\"dbname is empty\")\n\t}\n\treturn db, nil\n}\n\ntype oci8Driver struct {\n}\n\n// dataSourceName=user/password@ipv4:port/dbname\n// dataSourceName=user/password@[ipv6]:port/dbname\nfunc (p *oci8Driver) Parse(driverName, dataSourceName string) (*core.Uri, error) {\n\tdb := &core.Uri{DbType: core.ORACLE}\n\tdsnPattern := regexp.MustCompile(\n\t\t`^(?P<user>.*)\\/(?P<password>.*)@` + // user:password@\n\t\t\t`(?P<net>.*)` + // ip:port\n\t\t\t`\\/(?P<dbname>.*)`) // dbname\n\tmatches := dsnPattern.FindStringSubmatch(dataSourceName)\n\tnames := dsnPattern.SubexpNames()\n\tfor i, match := range matches {\n\t\tswitch names[i] {\n\t\tcase \"dbname\":\n\t\t\tdb.DbName = match\n\t\t}\n\t}\n\tif db.DbName == \"\" {\n\t\treturn nil, errors.New(\"dbname is empty\")\n\t}\n\treturn db, nil\n}\n"
        },
        {
          "name": "dialect_postgres.go",
          "type": "blob",
          "size": 44.890625,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"xorm.io/core\"\n)\n\n// from http://www.postgresql.org/docs/current/static/sql-keywords-appendix.html\nvar (\n\tpostgresReservedWords = map[string]bool{\n\t\t\"A\":                                true,\n\t\t\"ABORT\":                            true,\n\t\t\"ABS\":                              true,\n\t\t\"ABSENT\":                           true,\n\t\t\"ABSOLUTE\":                         true,\n\t\t\"ACCESS\":                           true,\n\t\t\"ACCORDING\":                        true,\n\t\t\"ACTION\":                           true,\n\t\t\"ADA\":                              true,\n\t\t\"ADD\":                              true,\n\t\t\"ADMIN\":                            true,\n\t\t\"AFTER\":                            true,\n\t\t\"AGGREGATE\":                        true,\n\t\t\"ALL\":                              true,\n\t\t\"ALLOCATE\":                         true,\n\t\t\"ALSO\":                             true,\n\t\t\"ALTER\":                            true,\n\t\t\"ALWAYS\":                           true,\n\t\t\"ANALYSE\":                          true,\n\t\t\"ANALYZE\":                          true,\n\t\t\"AND\":                              true,\n\t\t\"ANY\":                              true,\n\t\t\"ARE\":                              true,\n\t\t\"ARRAY\":                            true,\n\t\t\"ARRAY_AGG\":                        true,\n\t\t\"ARRAY_MAX_CARDINALITY\":            true,\n\t\t\"AS\":                               true,\n\t\t\"ASC\":                              true,\n\t\t\"ASENSITIVE\":                       true,\n\t\t\"ASSERTION\":                        true,\n\t\t\"ASSIGNMENT\":                       true,\n\t\t\"ASYMMETRIC\":                       true,\n\t\t\"AT\":                               true,\n\t\t\"ATOMIC\":                           true,\n\t\t\"ATTRIBUTE\":                        true,\n\t\t\"ATTRIBUTES\":                       true,\n\t\t\"AUTHORIZATION\":                    true,\n\t\t\"AVG\":                              true,\n\t\t\"BACKWARD\":                         true,\n\t\t\"BASE64\":                           true,\n\t\t\"BEFORE\":                           true,\n\t\t\"BEGIN\":                            true,\n\t\t\"BEGIN_FRAME\":                      true,\n\t\t\"BEGIN_PARTITION\":                  true,\n\t\t\"BERNOULLI\":                        true,\n\t\t\"BETWEEN\":                          true,\n\t\t\"BIGINT\":                           true,\n\t\t\"BINARY\":                           true,\n\t\t\"BIT\":                              true,\n\t\t\"BIT_LENGTH\":                       true,\n\t\t\"BLOB\":                             true,\n\t\t\"BLOCKED\":                          true,\n\t\t\"BOM\":                              true,\n\t\t\"BOOLEAN\":                          true,\n\t\t\"BOTH\":                             true,\n\t\t\"BREADTH\":                          true,\n\t\t\"BY\":                               true,\n\t\t\"C\":                                true,\n\t\t\"CACHE\":                            true,\n\t\t\"CALL\":                             true,\n\t\t\"CALLED\":                           true,\n\t\t\"CARDINALITY\":                      true,\n\t\t\"CASCADE\":                          true,\n\t\t\"CASCADED\":                         true,\n\t\t\"CASE\":                             true,\n\t\t\"CAST\":                             true,\n\t\t\"CATALOG\":                          true,\n\t\t\"CATALOG_NAME\":                     true,\n\t\t\"CEIL\":                             true,\n\t\t\"CEILING\":                          true,\n\t\t\"CHAIN\":                            true,\n\t\t\"CHAR\":                             true,\n\t\t\"CHARACTER\":                        true,\n\t\t\"CHARACTERISTICS\":                  true,\n\t\t\"CHARACTERS\":                       true,\n\t\t\"CHARACTER_LENGTH\":                 true,\n\t\t\"CHARACTER_SET_CATALOG\":            true,\n\t\t\"CHARACTER_SET_NAME\":               true,\n\t\t\"CHARACTER_SET_SCHEMA\":             true,\n\t\t\"CHAR_LENGTH\":                      true,\n\t\t\"CHECK\":                            true,\n\t\t\"CHECKPOINT\":                       true,\n\t\t\"CLASS\":                            true,\n\t\t\"CLASS_ORIGIN\":                     true,\n\t\t\"CLOB\":                             true,\n\t\t\"CLOSE\":                            true,\n\t\t\"CLUSTER\":                          true,\n\t\t\"COALESCE\":                         true,\n\t\t\"COBOL\":                            true,\n\t\t\"COLLATE\":                          true,\n\t\t\"COLLATION\":                        true,\n\t\t\"COLLATION_CATALOG\":                true,\n\t\t\"COLLATION_NAME\":                   true,\n\t\t\"COLLATION_SCHEMA\":                 true,\n\t\t\"COLLECT\":                          true,\n\t\t\"COLUMN\":                           true,\n\t\t\"COLUMNS\":                          true,\n\t\t\"COLUMN_NAME\":                      true,\n\t\t\"COMMAND_FUNCTION\":                 true,\n\t\t\"COMMAND_FUNCTION_CODE\":            true,\n\t\t\"COMMENT\":                          true,\n\t\t\"COMMENTS\":                         true,\n\t\t\"COMMIT\":                           true,\n\t\t\"COMMITTED\":                        true,\n\t\t\"CONCURRENTLY\":                     true,\n\t\t\"CONDITION\":                        true,\n\t\t\"CONDITION_NUMBER\":                 true,\n\t\t\"CONFIGURATION\":                    true,\n\t\t\"CONNECT\":                          true,\n\t\t\"CONNECTION\":                       true,\n\t\t\"CONNECTION_NAME\":                  true,\n\t\t\"CONSTRAINT\":                       true,\n\t\t\"CONSTRAINTS\":                      true,\n\t\t\"CONSTRAINT_CATALOG\":               true,\n\t\t\"CONSTRAINT_NAME\":                  true,\n\t\t\"CONSTRAINT_SCHEMA\":                true,\n\t\t\"CONSTRUCTOR\":                      true,\n\t\t\"CONTAINS\":                         true,\n\t\t\"CONTENT\":                          true,\n\t\t\"CONTINUE\":                         true,\n\t\t\"CONTROL\":                          true,\n\t\t\"CONVERSION\":                       true,\n\t\t\"CONVERT\":                          true,\n\t\t\"COPY\":                             true,\n\t\t\"CORR\":                             true,\n\t\t\"CORRESPONDING\":                    true,\n\t\t\"COST\":                             true,\n\t\t\"COUNT\":                            true,\n\t\t\"COVAR_POP\":                        true,\n\t\t\"COVAR_SAMP\":                       true,\n\t\t\"CREATE\":                           true,\n\t\t\"CROSS\":                            true,\n\t\t\"CSV\":                              true,\n\t\t\"CUBE\":                             true,\n\t\t\"CUME_DIST\":                        true,\n\t\t\"CURRENT\":                          true,\n\t\t\"CURRENT_CATALOG\":                  true,\n\t\t\"CURRENT_DATE\":                     true,\n\t\t\"CURRENT_DEFAULT_TRANSFORM_GROUP\":  true,\n\t\t\"CURRENT_PATH\":                     true,\n\t\t\"CURRENT_ROLE\":                     true,\n\t\t\"CURRENT_ROW\":                      true,\n\t\t\"CURRENT_SCHEMA\":                   true,\n\t\t\"CURRENT_TIME\":                     true,\n\t\t\"CURRENT_TIMESTAMP\":                true,\n\t\t\"CURRENT_TRANSFORM_GROUP_FOR_TYPE\": true,\n\t\t\"CURRENT_USER\":                     true,\n\t\t\"CURSOR\":                           true,\n\t\t\"CURSOR_NAME\":                      true,\n\t\t\"CYCLE\":                            true,\n\t\t\"DATA\":                             true,\n\t\t\"DATABASE\":                         true,\n\t\t\"DATALINK\":                         true,\n\t\t\"DATE\":                             true,\n\t\t\"DATETIME_INTERVAL_CODE\":           true,\n\t\t\"DATETIME_INTERVAL_PRECISION\":      true,\n\t\t\"DAY\":                              true,\n\t\t\"DB\":                               true,\n\t\t\"DEALLOCATE\":                       true,\n\t\t\"DEC\":                              true,\n\t\t\"DECIMAL\":                          true,\n\t\t\"DECLARE\":                          true,\n\t\t\"DEFAULT\":                          true,\n\t\t\"DEFAULTS\":                         true,\n\t\t\"DEFERRABLE\":                       true,\n\t\t\"DEFERRED\":                         true,\n\t\t\"DEFINED\":                          true,\n\t\t\"DEFINER\":                          true,\n\t\t\"DEGREE\":                           true,\n\t\t\"DELETE\":                           true,\n\t\t\"DELIMITER\":                        true,\n\t\t\"DELIMITERS\":                       true,\n\t\t\"DENSE_RANK\":                       true,\n\t\t\"DEPTH\":                            true,\n\t\t\"DEREF\":                            true,\n\t\t\"DERIVED\":                          true,\n\t\t\"DESC\":                             true,\n\t\t\"DESCRIBE\":                         true,\n\t\t\"DESCRIPTOR\":                       true,\n\t\t\"DETERMINISTIC\":                    true,\n\t\t\"DIAGNOSTICS\":                      true,\n\t\t\"DICTIONARY\":                       true,\n\t\t\"DISABLE\":                          true,\n\t\t\"DISCARD\":                          true,\n\t\t\"DISCONNECT\":                       true,\n\t\t\"DISPATCH\":                         true,\n\t\t\"DISTINCT\":                         true,\n\t\t\"DLNEWCOPY\":                        true,\n\t\t\"DLPREVIOUSCOPY\":                   true,\n\t\t\"DLURLCOMPLETE\":                    true,\n\t\t\"DLURLCOMPLETEONLY\":                true,\n\t\t\"DLURLCOMPLETEWRITE\":               true,\n\t\t\"DLURLPATH\":                        true,\n\t\t\"DLURLPATHONLY\":                    true,\n\t\t\"DLURLPATHWRITE\":                   true,\n\t\t\"DLURLSCHEME\":                      true,\n\t\t\"DLURLSERVER\":                      true,\n\t\t\"DLVALUE\":                          true,\n\t\t\"DO\":                               true,\n\t\t\"DOCUMENT\":                         true,\n\t\t\"DOMAIN\":                           true,\n\t\t\"DOUBLE\":                           true,\n\t\t\"DROP\":                             true,\n\t\t\"DYNAMIC\":                          true,\n\t\t\"DYNAMIC_FUNCTION\":                 true,\n\t\t\"DYNAMIC_FUNCTION_CODE\":            true,\n\t\t\"EACH\":                             true,\n\t\t\"ELEMENT\":                          true,\n\t\t\"ELSE\":                             true,\n\t\t\"EMPTY\":                            true,\n\t\t\"ENABLE\":                           true,\n\t\t\"ENCODING\":                         true,\n\t\t\"ENCRYPTED\":                        true,\n\t\t\"END\":                              true,\n\t\t\"END-EXEC\":                         true,\n\t\t\"END_FRAME\":                        true,\n\t\t\"END_PARTITION\":                    true,\n\t\t\"ENFORCED\":                         true,\n\t\t\"ENUM\":                             true,\n\t\t\"EQUALS\":                           true,\n\t\t\"ESCAPE\":                           true,\n\t\t\"EVENT\":                            true,\n\t\t\"EVERY\":                            true,\n\t\t\"EXCEPT\":                           true,\n\t\t\"EXCEPTION\":                        true,\n\t\t\"EXCLUDE\":                          true,\n\t\t\"EXCLUDING\":                        true,\n\t\t\"EXCLUSIVE\":                        true,\n\t\t\"EXEC\":                             true,\n\t\t\"EXECUTE\":                          true,\n\t\t\"EXISTS\":                           true,\n\t\t\"EXP\":                              true,\n\t\t\"EXPLAIN\":                          true,\n\t\t\"EXPRESSION\":                       true,\n\t\t\"EXTENSION\":                        true,\n\t\t\"EXTERNAL\":                         true,\n\t\t\"EXTRACT\":                          true,\n\t\t\"FALSE\":                            true,\n\t\t\"FAMILY\":                           true,\n\t\t\"FETCH\":                            true,\n\t\t\"FILE\":                             true,\n\t\t\"FILTER\":                           true,\n\t\t\"FINAL\":                            true,\n\t\t\"FIRST\":                            true,\n\t\t\"FIRST_VALUE\":                      true,\n\t\t\"FLAG\":                             true,\n\t\t\"FLOAT\":                            true,\n\t\t\"FLOOR\":                            true,\n\t\t\"FOLLOWING\":                        true,\n\t\t\"FOR\":                              true,\n\t\t\"FORCE\":                            true,\n\t\t\"FOREIGN\":                          true,\n\t\t\"FORTRAN\":                          true,\n\t\t\"FORWARD\":                          true,\n\t\t\"FOUND\":                            true,\n\t\t\"FRAME_ROW\":                        true,\n\t\t\"FREE\":                             true,\n\t\t\"FREEZE\":                           true,\n\t\t\"FROM\":                             true,\n\t\t\"FS\":                               true,\n\t\t\"FULL\":                             true,\n\t\t\"FUNCTION\":                         true,\n\t\t\"FUNCTIONS\":                        true,\n\t\t\"FUSION\":                           true,\n\t\t\"G\":                                true,\n\t\t\"GENERAL\":                          true,\n\t\t\"GENERATED\":                        true,\n\t\t\"GET\":                              true,\n\t\t\"GLOBAL\":                           true,\n\t\t\"GO\":                               true,\n\t\t\"GOTO\":                             true,\n\t\t\"GRANT\":                            true,\n\t\t\"GRANTED\":                          true,\n\t\t\"GREATEST\":                         true,\n\t\t\"GROUP\":                            true,\n\t\t\"GROUPING\":                         true,\n\t\t\"GROUPS\":                           true,\n\t\t\"HANDLER\":                          true,\n\t\t\"HAVING\":                           true,\n\t\t\"HEADER\":                           true,\n\t\t\"HEX\":                              true,\n\t\t\"HIERARCHY\":                        true,\n\t\t\"HOLD\":                             true,\n\t\t\"HOUR\":                             true,\n\t\t\"ID\":                               true,\n\t\t\"IDENTITY\":                         true,\n\t\t\"IF\":                               true,\n\t\t\"IGNORE\":                           true,\n\t\t\"ILIKE\":                            true,\n\t\t\"IMMEDIATE\":                        true,\n\t\t\"IMMEDIATELY\":                      true,\n\t\t\"IMMUTABLE\":                        true,\n\t\t\"IMPLEMENTATION\":                   true,\n\t\t\"IMPLICIT\":                         true,\n\t\t\"IMPORT\":                           true,\n\t\t\"IN\":                               true,\n\t\t\"INCLUDING\":                        true,\n\t\t\"INCREMENT\":                        true,\n\t\t\"INDENT\":                           true,\n\t\t\"INDEX\":                            true,\n\t\t\"INDEXES\":                          true,\n\t\t\"INDICATOR\":                        true,\n\t\t\"INHERIT\":                          true,\n\t\t\"INHERITS\":                         true,\n\t\t\"INITIALLY\":                        true,\n\t\t\"INLINE\":                           true,\n\t\t\"INNER\":                            true,\n\t\t\"INOUT\":                            true,\n\t\t\"INPUT\":                            true,\n\t\t\"INSENSITIVE\":                      true,\n\t\t\"INSERT\":                           true,\n\t\t\"INSTANCE\":                         true,\n\t\t\"INSTANTIABLE\":                     true,\n\t\t\"INSTEAD\":                          true,\n\t\t\"INT\":                              true,\n\t\t\"INTEGER\":                          true,\n\t\t\"INTEGRITY\":                        true,\n\t\t\"INTERSECT\":                        true,\n\t\t\"INTERSECTION\":                     true,\n\t\t\"INTERVAL\":                         true,\n\t\t\"INTO\":                             true,\n\t\t\"INVOKER\":                          true,\n\t\t\"IS\":                               true,\n\t\t\"ISNULL\":                           true,\n\t\t\"ISOLATION\":                        true,\n\t\t\"JOIN\":                             true,\n\t\t\"K\":                                true,\n\t\t\"KEY\":                              true,\n\t\t\"KEY_MEMBER\":                       true,\n\t\t\"KEY_TYPE\":                         true,\n\t\t\"LABEL\":                            true,\n\t\t\"LAG\":                              true,\n\t\t\"LANGUAGE\":                         true,\n\t\t\"LARGE\":                            true,\n\t\t\"LAST\":                             true,\n\t\t\"LAST_VALUE\":                       true,\n\t\t\"LATERAL\":                          true,\n\t\t\"LC_COLLATE\":                       true,\n\t\t\"LC_CTYPE\":                         true,\n\t\t\"LEAD\":                             true,\n\t\t\"LEADING\":                          true,\n\t\t\"LEAKPROOF\":                        true,\n\t\t\"LEAST\":                            true,\n\t\t\"LEFT\":                             true,\n\t\t\"LENGTH\":                           true,\n\t\t\"LEVEL\":                            true,\n\t\t\"LIBRARY\":                          true,\n\t\t\"LIKE\":                             true,\n\t\t\"LIKE_REGEX\":                       true,\n\t\t\"LIMIT\":                            true,\n\t\t\"LINK\":                             true,\n\t\t\"LISTEN\":                           true,\n\t\t\"LN\":                               true,\n\t\t\"LOAD\":                             true,\n\t\t\"LOCAL\":                            true,\n\t\t\"LOCALTIME\":                        true,\n\t\t\"LOCALTIMESTAMP\":                   true,\n\t\t\"LOCATION\":                         true,\n\t\t\"LOCATOR\":                          true,\n\t\t\"LOCK\":                             true,\n\t\t\"LOWER\":                            true,\n\t\t\"M\":                                true,\n\t\t\"MAP\":                              true,\n\t\t\"MAPPING\":                          true,\n\t\t\"MATCH\":                            true,\n\t\t\"MATCHED\":                          true,\n\t\t\"MATERIALIZED\":                     true,\n\t\t\"MAX\":                              true,\n\t\t\"MAXVALUE\":                         true,\n\t\t\"MAX_CARDINALITY\":                  true,\n\t\t\"MEMBER\":                           true,\n\t\t\"MERGE\":                            true,\n\t\t\"MESSAGE_LENGTH\":                   true,\n\t\t\"MESSAGE_OCTET_LENGTH\":             true,\n\t\t\"MESSAGE_TEXT\":                     true,\n\t\t\"METHOD\":                           true,\n\t\t\"MIN\":                              true,\n\t\t\"MINUTE\":                           true,\n\t\t\"MINVALUE\":                         true,\n\t\t\"MOD\":                              true,\n\t\t\"MODE\":                             true,\n\t\t\"MODIFIES\":                         true,\n\t\t\"MODULE\":                           true,\n\t\t\"MONTH\":                            true,\n\t\t\"MORE\":                             true,\n\t\t\"MOVE\":                             true,\n\t\t\"MULTISET\":                         true,\n\t\t\"MUMPS\":                            true,\n\t\t\"NAME\":                             true,\n\t\t\"NAMES\":                            true,\n\t\t\"NAMESPACE\":                        true,\n\t\t\"NATIONAL\":                         true,\n\t\t\"NATURAL\":                          true,\n\t\t\"NCHAR\":                            true,\n\t\t\"NCLOB\":                            true,\n\t\t\"NESTING\":                          true,\n\t\t\"NEW\":                              true,\n\t\t\"NEXT\":                             true,\n\t\t\"NFC\":                              true,\n\t\t\"NFD\":                              true,\n\t\t\"NFKC\":                             true,\n\t\t\"NFKD\":                             true,\n\t\t\"NIL\":                              true,\n\t\t\"NO\":                               true,\n\t\t\"NONE\":                             true,\n\t\t\"NORMALIZE\":                        true,\n\t\t\"NORMALIZED\":                       true,\n\t\t\"NOT\":                              true,\n\t\t\"NOTHING\":                          true,\n\t\t\"NOTIFY\":                           true,\n\t\t\"NOTNULL\":                          true,\n\t\t\"NOWAIT\":                           true,\n\t\t\"NTH_VALUE\":                        true,\n\t\t\"NTILE\":                            true,\n\t\t\"NULL\":                             true,\n\t\t\"NULLABLE\":                         true,\n\t\t\"NULLIF\":                           true,\n\t\t\"NULLS\":                            true,\n\t\t\"NUMBER\":                           true,\n\t\t\"NUMERIC\":                          true,\n\t\t\"OBJECT\":                           true,\n\t\t\"OCCURRENCES_REGEX\":                true,\n\t\t\"OCTETS\":                           true,\n\t\t\"OCTET_LENGTH\":                     true,\n\t\t\"OF\":                               true,\n\t\t\"OFF\":                              true,\n\t\t\"OFFSET\":                           true,\n\t\t\"OIDS\":                             true,\n\t\t\"OLD\":                              true,\n\t\t\"ON\":                               true,\n\t\t\"ONLY\":                             true,\n\t\t\"OPEN\":                             true,\n\t\t\"OPERATOR\":                         true,\n\t\t\"OPTION\":                           true,\n\t\t\"OPTIONS\":                          true,\n\t\t\"OR\":                               true,\n\t\t\"ORDER\":                            true,\n\t\t\"ORDERING\":                         true,\n\t\t\"ORDINALITY\":                       true,\n\t\t\"OTHERS\":                           true,\n\t\t\"OUT\":                              true,\n\t\t\"OUTER\":                            true,\n\t\t\"OUTPUT\":                           true,\n\t\t\"OVER\":                             true,\n\t\t\"OVERLAPS\":                         true,\n\t\t\"OVERLAY\":                          true,\n\t\t\"OVERRIDING\":                       true,\n\t\t\"OWNED\":                            true,\n\t\t\"OWNER\":                            true,\n\t\t\"P\":                                true,\n\t\t\"PAD\":                              true,\n\t\t\"PARAMETER\":                        true,\n\t\t\"PARAMETER_MODE\":                   true,\n\t\t\"PARAMETER_NAME\":                   true,\n\t\t\"PARAMETER_ORDINAL_POSITION\":       true,\n\t\t\"PARAMETER_SPECIFIC_CATALOG\":       true,\n\t\t\"PARAMETER_SPECIFIC_NAME\":          true,\n\t\t\"PARAMETER_SPECIFIC_SCHEMA\":        true,\n\t\t\"PARSER\":                           true,\n\t\t\"PARTIAL\":                          true,\n\t\t\"PARTITION\":                        true,\n\t\t\"PASCAL\":                           true,\n\t\t\"PASSING\":                          true,\n\t\t\"PASSTHROUGH\":                      true,\n\t\t\"PASSWORD\":                         true,\n\t\t\"PATH\":                             true,\n\t\t\"PERCENT\":                          true,\n\t\t\"PERCENTILE_CONT\":                  true,\n\t\t\"PERCENTILE_DISC\":                  true,\n\t\t\"PERCENT_RANK\":                     true,\n\t\t\"PERIOD\":                           true,\n\t\t\"PERMISSION\":                       true,\n\t\t\"PLACING\":                          true,\n\t\t\"PLANS\":                            true,\n\t\t\"PLI\":                              true,\n\t\t\"PORTION\":                          true,\n\t\t\"POSITION\":                         true,\n\t\t\"POSITION_REGEX\":                   true,\n\t\t\"POWER\":                            true,\n\t\t\"PRECEDES\":                         true,\n\t\t\"PRECEDING\":                        true,\n\t\t\"PRECISION\":                        true,\n\t\t\"PREPARE\":                          true,\n\t\t\"PREPARED\":                         true,\n\t\t\"PRESERVE\":                         true,\n\t\t\"PRIMARY\":                          true,\n\t\t\"PRIOR\":                            true,\n\t\t\"PRIVILEGES\":                       true,\n\t\t\"PROCEDURAL\":                       true,\n\t\t\"PROCEDURE\":                        true,\n\t\t\"PROGRAM\":                          true,\n\t\t\"PUBLIC\":                           true,\n\t\t\"QUOTE\":                            true,\n\t\t\"RANGE\":                            true,\n\t\t\"RANK\":                             true,\n\t\t\"READ\":                             true,\n\t\t\"READS\":                            true,\n\t\t\"REAL\":                             true,\n\t\t\"REASSIGN\":                         true,\n\t\t\"RECHECK\":                          true,\n\t\t\"RECOVERY\":                         true,\n\t\t\"RECURSIVE\":                        true,\n\t\t\"REF\":                              true,\n\t\t\"REFERENCES\":                       true,\n\t\t\"REFERENCING\":                      true,\n\t\t\"REFRESH\":                          true,\n\t\t\"REGR_AVGX\":                        true,\n\t\t\"REGR_AVGY\":                        true,\n\t\t\"REGR_COUNT\":                       true,\n\t\t\"REGR_INTERCEPT\":                   true,\n\t\t\"REGR_R2\":                          true,\n\t\t\"REGR_SLOPE\":                       true,\n\t\t\"REGR_SXX\":                         true,\n\t\t\"REGR_SXY\":                         true,\n\t\t\"REGR_SYY\":                         true,\n\t\t\"REINDEX\":                          true,\n\t\t\"RELATIVE\":                         true,\n\t\t\"RELEASE\":                          true,\n\t\t\"RENAME\":                           true,\n\t\t\"REPEATABLE\":                       true,\n\t\t\"REPLACE\":                          true,\n\t\t\"REPLICA\":                          true,\n\t\t\"REQUIRING\":                        true,\n\t\t\"RESET\":                            true,\n\t\t\"RESPECT\":                          true,\n\t\t\"RESTART\":                          true,\n\t\t\"RESTORE\":                          true,\n\t\t\"RESTRICT\":                         true,\n\t\t\"RESULT\":                           true,\n\t\t\"RETURN\":                           true,\n\t\t\"RETURNED_CARDINALITY\":             true,\n\t\t\"RETURNED_LENGTH\":                  true,\n\t\t\"RETURNED_OCTET_LENGTH\":            true,\n\t\t\"RETURNED_SQLSTATE\":                true,\n\t\t\"RETURNING\":                        true,\n\t\t\"RETURNS\":                          true,\n\t\t\"REVOKE\":                           true,\n\t\t\"RIGHT\":                            true,\n\t\t\"ROLE\":                             true,\n\t\t\"ROLLBACK\":                         true,\n\t\t\"ROLLUP\":                           true,\n\t\t\"ROUTINE\":                          true,\n\t\t\"ROUTINE_CATALOG\":                  true,\n\t\t\"ROUTINE_NAME\":                     true,\n\t\t\"ROUTINE_SCHEMA\":                   true,\n\t\t\"ROW\":                              true,\n\t\t\"ROWS\":                             true,\n\t\t\"ROW_COUNT\":                        true,\n\t\t\"ROW_NUMBER\":                       true,\n\t\t\"RULE\":                             true,\n\t\t\"SAVEPOINT\":                        true,\n\t\t\"SCALE\":                            true,\n\t\t\"SCHEMA\":                           true,\n\t\t\"SCHEMA_NAME\":                      true,\n\t\t\"SCOPE\":                            true,\n\t\t\"SCOPE_CATALOG\":                    true,\n\t\t\"SCOPE_NAME\":                       true,\n\t\t\"SCOPE_SCHEMA\":                     true,\n\t\t\"SCROLL\":                           true,\n\t\t\"SEARCH\":                           true,\n\t\t\"SECOND\":                           true,\n\t\t\"SECTION\":                          true,\n\t\t\"SECURITY\":                         true,\n\t\t\"SELECT\":                           true,\n\t\t\"SELECTIVE\":                        true,\n\t\t\"SELF\":                             true,\n\t\t\"SENSITIVE\":                        true,\n\t\t\"SEQUENCE\":                         true,\n\t\t\"SEQUENCES\":                        true,\n\t\t\"SERIALIZABLE\":                     true,\n\t\t\"SERVER\":                           true,\n\t\t\"SERVER_NAME\":                      true,\n\t\t\"SESSION\":                          true,\n\t\t\"SESSION_USER\":                     true,\n\t\t\"SET\":                              true,\n\t\t\"SETOF\":                            true,\n\t\t\"SETS\":                             true,\n\t\t\"SHARE\":                            true,\n\t\t\"SHOW\":                             true,\n\t\t\"SIMILAR\":                          true,\n\t\t\"SIMPLE\":                           true,\n\t\t\"SIZE\":                             true,\n\t\t\"SMALLINT\":                         true,\n\t\t\"SNAPSHOT\":                         true,\n\t\t\"SOME\":                             true,\n\t\t\"SOURCE\":                           true,\n\t\t\"SPACE\":                            true,\n\t\t\"SPECIFIC\":                         true,\n\t\t\"SPECIFICTYPE\":                     true,\n\t\t\"SPECIFIC_NAME\":                    true,\n\t\t\"SQL\":                              true,\n\t\t\"SQLCODE\":                          true,\n\t\t\"SQLERROR\":                         true,\n\t\t\"SQLEXCEPTION\":                     true,\n\t\t\"SQLSTATE\":                         true,\n\t\t\"SQLWARNING\":                       true,\n\t\t\"SQRT\":                             true,\n\t\t\"STABLE\":                           true,\n\t\t\"STANDALONE\":                       true,\n\t\t\"START\":                            true,\n\t\t\"STATE\":                            true,\n\t\t\"STATEMENT\":                        true,\n\t\t\"STATIC\":                           true,\n\t\t\"STATISTICS\":                       true,\n\t\t\"STDDEV_POP\":                       true,\n\t\t\"STDDEV_SAMP\":                      true,\n\t\t\"STDIN\":                            true,\n\t\t\"STDOUT\":                           true,\n\t\t\"STORAGE\":                          true,\n\t\t\"STRICT\":                           true,\n\t\t\"STRIP\":                            true,\n\t\t\"STRUCTURE\":                        true,\n\t\t\"STYLE\":                            true,\n\t\t\"SUBCLASS_ORIGIN\":                  true,\n\t\t\"SUBMULTISET\":                      true,\n\t\t\"SUBSTRING\":                        true,\n\t\t\"SUBSTRING_REGEX\":                  true,\n\t\t\"SUCCEEDS\":                         true,\n\t\t\"SUM\":                              true,\n\t\t\"SYMMETRIC\":                        true,\n\t\t\"SYSID\":                            true,\n\t\t\"SYSTEM\":                           true,\n\t\t\"SYSTEM_TIME\":                      true,\n\t\t\"SYSTEM_USER\":                      true,\n\t\t\"T\":                                true,\n\t\t\"TABLE\":                            true,\n\t\t\"TABLES\":                           true,\n\t\t\"TABLESAMPLE\":                      true,\n\t\t\"TABLESPACE\":                       true,\n\t\t\"TABLE_NAME\":                       true,\n\t\t\"TEMP\":                             true,\n\t\t\"TEMPLATE\":                         true,\n\t\t\"TEMPORARY\":                        true,\n\t\t\"TEXT\":                             true,\n\t\t\"THEN\":                             true,\n\t\t\"TIES\":                             true,\n\t\t\"TIME\":                             true,\n\t\t\"TIMESTAMP\":                        true,\n\t\t\"TIMEZONE_HOUR\":                    true,\n\t\t\"TIMEZONE_MINUTE\":                  true,\n\t\t\"TO\":                               true,\n\t\t\"TOKEN\":                            true,\n\t\t\"TOP_LEVEL_COUNT\":                  true,\n\t\t\"TRAILING\":                         true,\n\t\t\"TRANSACTION\":                      true,\n\t\t\"TRANSACTIONS_COMMITTED\":           true,\n\t\t\"TRANSACTIONS_ROLLED_BACK\":         true,\n\t\t\"TRANSACTION_ACTIVE\":               true,\n\t\t\"TRANSFORM\":                        true,\n\t\t\"TRANSFORMS\":                       true,\n\t\t\"TRANSLATE\":                        true,\n\t\t\"TRANSLATE_REGEX\":                  true,\n\t\t\"TRANSLATION\":                      true,\n\t\t\"TREAT\":                            true,\n\t\t\"TRIGGER\":                          true,\n\t\t\"TRIGGER_CATALOG\":                  true,\n\t\t\"TRIGGER_NAME\":                     true,\n\t\t\"TRIGGER_SCHEMA\":                   true,\n\t\t\"TRIM\":                             true,\n\t\t\"TRIM_ARRAY\":                       true,\n\t\t\"TRUE\":                             true,\n\t\t\"TRUNCATE\":                         true,\n\t\t\"TRUSTED\":                          true,\n\t\t\"TYPE\":                             true,\n\t\t\"TYPES\":                            true,\n\t\t\"UESCAPE\":                          true,\n\t\t\"UNBOUNDED\":                        true,\n\t\t\"UNCOMMITTED\":                      true,\n\t\t\"UNDER\":                            true,\n\t\t\"UNENCRYPTED\":                      true,\n\t\t\"UNION\":                            true,\n\t\t\"UNIQUE\":                           true,\n\t\t\"UNKNOWN\":                          true,\n\t\t\"UNLINK\":                           true,\n\t\t\"UNLISTEN\":                         true,\n\t\t\"UNLOGGED\":                         true,\n\t\t\"UNNAMED\":                          true,\n\t\t\"UNNEST\":                           true,\n\t\t\"UNTIL\":                            true,\n\t\t\"UNTYPED\":                          true,\n\t\t\"UPDATE\":                           true,\n\t\t\"UPPER\":                            true,\n\t\t\"URI\":                              true,\n\t\t\"USAGE\":                            true,\n\t\t\"USER\":                             true,\n\t\t\"USER_DEFINED_TYPE_CATALOG\":        true,\n\t\t\"USER_DEFINED_TYPE_CODE\":           true,\n\t\t\"USER_DEFINED_TYPE_NAME\":           true,\n\t\t\"USER_DEFINED_TYPE_SCHEMA\":         true,\n\t\t\"USING\":                            true,\n\t\t\"VACUUM\":                           true,\n\t\t\"VALID\":                            true,\n\t\t\"VALIDATE\":                         true,\n\t\t\"VALIDATOR\":                        true,\n\t\t\"VALUE\":                            true,\n\t\t\"VALUES\":                           true,\n\t\t\"VALUE_OF\":                         true,\n\t\t\"VARBINARY\":                        true,\n\t\t\"VARCHAR\":                          true,\n\t\t\"VARIADIC\":                         true,\n\t\t\"VARYING\":                          true,\n\t\t\"VAR_POP\":                          true,\n\t\t\"VAR_SAMP\":                         true,\n\t\t\"VERBOSE\":                          true,\n\t\t\"VERSION\":                          true,\n\t\t\"VERSIONING\":                       true,\n\t\t\"VIEW\":                             true,\n\t\t\"VOLATILE\":                         true,\n\t\t\"WHEN\":                             true,\n\t\t\"WHENEVER\":                         true,\n\t\t\"WHERE\":                            true,\n\t\t\"WHITESPACE\":                       true,\n\t\t\"WIDTH_BUCKET\":                     true,\n\t\t\"WINDOW\":                           true,\n\t\t\"WITH\":                             true,\n\t\t\"WITHIN\":                           true,\n\t\t\"WITHOUT\":                          true,\n\t\t\"WORK\":                             true,\n\t\t\"WRAPPER\":                          true,\n\t\t\"WRITE\":                            true,\n\t\t\"XML\":                              true,\n\t\t\"XMLAGG\":                           true,\n\t\t\"XMLATTRIBUTES\":                    true,\n\t\t\"XMLBINARY\":                        true,\n\t\t\"XMLCAST\":                          true,\n\t\t\"XMLCOMMENT\":                       true,\n\t\t\"XMLCONCAT\":                        true,\n\t\t\"XMLDECLARATION\":                   true,\n\t\t\"XMLDOCUMENT\":                      true,\n\t\t\"XMLELEMENT\":                       true,\n\t\t\"XMLEXISTS\":                        true,\n\t\t\"XMLFOREST\":                        true,\n\t\t\"XMLITERATE\":                       true,\n\t\t\"XMLNAMESPACES\":                    true,\n\t\t\"XMLPARSE\":                         true,\n\t\t\"XMLPI\":                            true,\n\t\t\"XMLQUERY\":                         true,\n\t\t\"XMLROOT\":                          true,\n\t\t\"XMLSCHEMA\":                        true,\n\t\t\"XMLSERIALIZE\":                     true,\n\t\t\"XMLTABLE\":                         true,\n\t\t\"XMLTEXT\":                          true,\n\t\t\"XMLVALIDATE\":                      true,\n\t\t\"YEAR\":                             true,\n\t\t\"YES\":                              true,\n\t\t\"ZONE\":                             true,\n\t}\n\n\t// DefaultPostgresSchema default postgres schema\n\tDefaultPostgresSchema = \"public\"\n)\n\nconst postgresPublicSchema = \"public\"\n\ntype postgres struct {\n\tcore.Base\n}\n\nfunc (db *postgres) Init(d *core.DB, uri *core.Uri, drivername, dataSourceName string) error {\n\terr := db.Base.Init(d, db, uri, drivername, dataSourceName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif db.Schema == \"\" {\n\t\tdb.Schema = DefaultPostgresSchema\n\t}\n\treturn nil\n}\n\nfunc (db *postgres) SqlType(c *core.Column) string {\n\tvar res string\n\tswitch t := c.SQLType.Name; t {\n\tcase core.TinyInt:\n\t\tres = core.SmallInt\n\t\treturn res\n\tcase core.Bit:\n\t\tres = core.Boolean\n\t\treturn res\n\tcase core.MediumInt, core.Int, core.Integer:\n\t\tif c.IsAutoIncrement {\n\t\t\treturn core.Serial\n\t\t}\n\t\treturn core.Integer\n\tcase core.BigInt:\n\t\tif c.IsAutoIncrement {\n\t\t\treturn core.BigSerial\n\t\t}\n\t\treturn core.BigInt\n\tcase core.Serial, core.BigSerial:\n\t\tc.IsAutoIncrement = true\n\t\tc.Nullable = false\n\t\tres = t\n\tcase core.Binary, core.VarBinary:\n\t\treturn core.Bytea\n\tcase core.DateTime:\n\t\tres = core.TimeStamp\n\tcase core.TimeStampz:\n\t\treturn \"timestamp with time zone\"\n\tcase core.Float:\n\t\tres = core.Real\n\tcase core.TinyText, core.MediumText, core.LongText:\n\t\tres = core.Text\n\tcase core.NVarchar:\n\t\tres = core.Varchar\n\tcase core.Uuid:\n\t\treturn core.Uuid\n\tcase core.Blob, core.TinyBlob, core.MediumBlob, core.LongBlob:\n\t\treturn core.Bytea\n\tcase core.Double:\n\t\treturn \"DOUBLE PRECISION\"\n\tdefault:\n\t\tif c.IsAutoIncrement {\n\t\t\treturn core.Serial\n\t\t}\n\t\tres = t\n\t}\n\n\tif strings.EqualFold(res, \"bool\") {\n\t\t// for bool, we don't need length information\n\t\treturn res\n\t}\n\thasLen1 := (c.Length > 0)\n\thasLen2 := (c.Length2 > 0)\n\n\tif hasLen2 {\n\t\tres += \"(\" + strconv.Itoa(c.Length) + \",\" + strconv.Itoa(c.Length2) + \")\"\n\t} else if hasLen1 {\n\t\tres += \"(\" + strconv.Itoa(c.Length) + \")\"\n\t}\n\treturn res\n}\n\nfunc (db *postgres) SupportInsertMany() bool {\n\treturn true\n}\n\nfunc (db *postgres) IsReserved(name string) bool {\n\t_, ok := postgresReservedWords[name]\n\treturn ok\n}\n\nfunc (db *postgres) Quote(name string) string {\n\tname = strings.Replace(name, \".\", `\".\"`, -1)\n\treturn \"\\\"\" + name + \"\\\"\"\n}\n\nfunc (db *postgres) AutoIncrStr() string {\n\treturn \"\"\n}\n\nfunc (db *postgres) SupportEngine() bool {\n\treturn false\n}\n\nfunc (db *postgres) SupportCharset() bool {\n\treturn false\n}\n\nfunc (db *postgres) IndexOnTable() bool {\n\treturn false\n}\n\nfunc (db *postgres) IndexCheckSql(tableName, idxName string) (string, []interface{}) {\n\tif len(db.Schema) == 0 {\n\t\targs := []interface{}{tableName, idxName}\n\t\treturn `SELECT indexname FROM pg_indexes WHERE tablename = ? AND indexname = ?`, args\n\t}\n\n\targs := []interface{}{db.Schema, tableName, idxName}\n\treturn `SELECT indexname FROM pg_indexes ` +\n\t\t`WHERE schemaname = ? AND tablename = ? AND indexname = ?`, args\n}\n\nfunc (db *postgres) TableCheckSql(tableName string) (string, []interface{}) {\n\tif len(db.Schema) == 0 {\n\t\targs := []interface{}{tableName}\n\t\treturn `SELECT tablename FROM pg_tables WHERE tablename = ?`, args\n\t}\n\n\targs := []interface{}{db.Schema, tableName}\n\treturn `SELECT tablename FROM pg_tables WHERE schemaname = ? AND tablename = ?`, args\n}\n\nfunc (db *postgres) ModifyColumnSql(tableName string, col *core.Column) string {\n\tif len(db.Schema) == 0 {\n\t\treturn fmt.Sprintf(\"alter table %s ALTER COLUMN %s TYPE %s\",\n\t\t\ttableName, col.Name, db.SqlType(col))\n\t}\n\treturn fmt.Sprintf(\"alter table %s.%s ALTER COLUMN %s TYPE %s\",\n\t\tdb.Schema, tableName, col.Name, db.SqlType(col))\n}\n\nfunc (db *postgres) DropIndexSql(tableName string, index *core.Index) string {\n\tquote := db.Quote\n\tidxName := index.Name\n\n\ttableName = strings.Replace(tableName, `\"`, \"\", -1)\n\ttableName = strings.Replace(tableName, `.`, \"_\", -1)\n\n\tif !strings.HasPrefix(idxName, \"UQE_\") &&\n\t\t!strings.HasPrefix(idxName, \"IDX_\") {\n\t\tif index.Type == core.UniqueType {\n\t\t\tidxName = fmt.Sprintf(\"UQE_%v_%v\", tableName, index.Name)\n\t\t} else {\n\t\t\tidxName = fmt.Sprintf(\"IDX_%v_%v\", tableName, index.Name)\n\t\t}\n\t}\n\tif db.Uri.Schema != \"\" {\n\t\tidxName = db.Uri.Schema + \".\" + idxName\n\t}\n\treturn fmt.Sprintf(\"DROP INDEX %v\", quote(idxName))\n}\n\nfunc (db *postgres) IsColumnExist(tableName, colName string) (bool, error) {\n\targs := []interface{}{db.Schema, tableName, colName}\n\tquery := \"SELECT column_name FROM INFORMATION_SCHEMA.COLUMNS WHERE table_schema = $1 AND table_name = $2\" +\n\t\t\" AND column_name = $3\"\n\tif len(db.Schema) == 0 {\n\t\targs = []interface{}{tableName, colName}\n\t\tquery = \"SELECT column_name FROM INFORMATION_SCHEMA.COLUMNS WHERE table_name = $1\" +\n\t\t\t\" AND column_name = $2\"\n\t}\n\tdb.LogSQL(query, args)\n\n\trows, err := db.DB().Query(query, args...)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer rows.Close()\n\n\treturn rows.Next(), nil\n}\n\nfunc (db *postgres) GetColumns(tableName string) ([]string, map[string]*core.Column, error) {\n\targs := []interface{}{tableName}\n\ts := `SELECT column_name, column_default, is_nullable, data_type, character_maximum_length,\n    CASE WHEN p.contype = 'p' THEN true ELSE false END AS primarykey,\n    CASE WHEN p.contype = 'u' THEN true ELSE false END AS uniquekey\nFROM pg_attribute f\n    JOIN pg_class c ON c.oid = f.attrelid JOIN pg_type t ON t.oid = f.atttypid\n    LEFT JOIN pg_attrdef d ON d.adrelid = c.oid AND d.adnum = f.attnum\n    LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\n    LEFT JOIN pg_constraint p ON p.conrelid = c.oid AND f.attnum = ANY (p.conkey)\n    LEFT JOIN pg_class AS g ON p.confrelid = g.oid\n    LEFT JOIN INFORMATION_SCHEMA.COLUMNS s ON s.column_name=f.attname AND c.relname=s.table_name\nWHERE c.relkind = 'r'::char AND c.relname = $1%s AND f.attnum > 0 ORDER BY f.attnum;`\n\n\tvar f string\n\tif len(db.Schema) != 0 {\n\t\targs = append(args, db.Schema)\n\t\tf = \" AND s.table_schema = $2\"\n\t}\n\ts = fmt.Sprintf(s, f)\n\n\tdb.LogSQL(s, args)\n\n\trows, err := db.DB().Query(s, args...)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer rows.Close()\n\n\tcols := make(map[string]*core.Column)\n\tcolSeq := make([]string, 0)\n\n\tfor rows.Next() {\n\t\tcol := new(core.Column)\n\t\tcol.Indexes = make(map[string]int)\n\n\t\tvar colName, isNullable, dataType string\n\t\tvar maxLenStr, colDefault *string\n\t\tvar isPK, isUnique bool\n\t\terr = rows.Scan(&colName, &colDefault, &isNullable, &dataType, &maxLenStr, &isPK, &isUnique)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\t// fmt.Println(args, colName, isNullable, dataType, maxLenStr, colDefault, isPK, isUnique)\n\t\tvar maxLen int\n\t\tif maxLenStr != nil {\n\t\t\tmaxLen, err = strconv.Atoi(*maxLenStr)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t}\n\n\t\tcol.Name = strings.Trim(colName, `\" `)\n\n\t\tif colDefault != nil {\n\t\t\tcol.Default = *colDefault\n\t\t\tcol.DefaultIsEmpty = false\n\t\t\tif strings.HasPrefix(col.Default, \"nextval(\") {\n\t\t\t\tcol.IsAutoIncrement = true\n\t\t\t}\n\t\t} else {\n\t\t\tcol.DefaultIsEmpty = true\n\t\t}\n\n\t\tif isPK {\n\t\t\tcol.IsPrimaryKey = true\n\t\t}\n\n\t\tcol.Nullable = (isNullable == \"YES\")\n\n\t\tswitch dataType {\n\t\tcase \"character varying\", \"character\":\n\t\t\tcol.SQLType = core.SQLType{Name: core.Varchar, DefaultLength: 0, DefaultLength2: 0}\n\t\tcase \"timestamp without time zone\":\n\t\t\tcol.SQLType = core.SQLType{Name: core.DateTime, DefaultLength: 0, DefaultLength2: 0}\n\t\tcase \"timestamp with time zone\":\n\t\t\tcol.SQLType = core.SQLType{Name: core.TimeStampz, DefaultLength: 0, DefaultLength2: 0}\n\t\tcase \"double precision\":\n\t\t\tcol.SQLType = core.SQLType{Name: core.Double, DefaultLength: 0, DefaultLength2: 0}\n\t\tcase \"boolean\":\n\t\t\tcol.SQLType = core.SQLType{Name: core.Bool, DefaultLength: 0, DefaultLength2: 0}\n\t\tcase \"time without time zone\":\n\t\t\tcol.SQLType = core.SQLType{Name: core.Time, DefaultLength: 0, DefaultLength2: 0}\n\t\tcase \"oid\":\n\t\t\tcol.SQLType = core.SQLType{Name: core.BigInt, DefaultLength: 0, DefaultLength2: 0}\n\t\tdefault:\n\t\t\tcol.SQLType = core.SQLType{Name: strings.ToUpper(dataType), DefaultLength: 0, DefaultLength2: 0}\n\t\t}\n\t\tif _, ok := core.SqlTypes[col.SQLType.Name]; !ok {\n\t\t\treturn nil, nil, fmt.Errorf(\"Unknown colType: %v\", dataType)\n\t\t}\n\n\t\tcol.Length = maxLen\n\n\t\tif !col.DefaultIsEmpty {\n\t\t\tif col.SQLType.IsText() {\n\t\t\t\tif strings.HasSuffix(col.Default, \"::character varying\") {\n\t\t\t\t\tcol.Default = strings.TrimRight(col.Default, \"::character varying\")\n\t\t\t\t} else if !strings.HasPrefix(col.Default, \"'\") {\n\t\t\t\t\tcol.Default = \"'\" + col.Default + \"'\"\n\t\t\t\t}\n\t\t\t} else if col.SQLType.IsTime() {\n\t\t\t\tif strings.HasSuffix(col.Default, \"::timestamp without time zone\") {\n\t\t\t\t\tcol.Default = strings.TrimRight(col.Default, \"::timestamp without time zone\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcols[col.Name] = col\n\t\tcolSeq = append(colSeq, col.Name)\n\t}\n\n\treturn colSeq, cols, nil\n}\n\nfunc (db *postgres) GetTables() ([]*core.Table, error) {\n\targs := []interface{}{}\n\ts := \"SELECT tablename FROM pg_tables\"\n\tif len(db.Schema) != 0 {\n\t\targs = append(args, db.Schema)\n\t\ts = s + \" WHERE schemaname = $1\"\n\t}\n\n\tdb.LogSQL(s, args)\n\n\trows, err := db.DB().Query(s, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\ttables := make([]*core.Table, 0)\n\tfor rows.Next() {\n\t\ttable := core.NewEmptyTable()\n\t\tvar name string\n\t\terr = rows.Scan(&name)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttable.Name = name\n\t\ttables = append(tables, table)\n\t}\n\treturn tables, nil\n}\n\nfunc getIndexColName(indexdef string) []string {\n\tvar colNames []string\n\n\tcs := strings.Split(indexdef, \"(\")\n\tfor _, v := range strings.Split(strings.Split(cs[1], \")\")[0], \",\") {\n\t\tcolNames = append(colNames, strings.Split(strings.TrimLeft(v, \" \"), \" \")[0])\n\t}\n\n\treturn colNames\n}\n\nfunc (db *postgres) GetIndexes(tableName string) (map[string]*core.Index, error) {\n\targs := []interface{}{tableName}\n\ts := fmt.Sprintf(\"SELECT indexname, indexdef FROM pg_indexes WHERE tablename=$1\")\n\tif len(db.Schema) != 0 {\n\t\targs = append(args, db.Schema)\n\t\ts = s + \" AND schemaname=$2\"\n\t}\n\tdb.LogSQL(s, args)\n\n\trows, err := db.DB().Query(s, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tindexes := make(map[string]*core.Index, 0)\n\tfor rows.Next() {\n\t\tvar indexType int\n\t\tvar indexName, indexdef string\n\t\tvar colNames []string\n\t\terr = rows.Scan(&indexName, &indexdef)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tindexName = strings.Trim(indexName, `\" `)\n\t\tif strings.HasSuffix(indexName, \"_pkey\") {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.HasPrefix(indexdef, \"CREATE UNIQUE INDEX\") {\n\t\t\tindexType = core.UniqueType\n\t\t} else {\n\t\t\tindexType = core.IndexType\n\t\t}\n\t\tcolNames = getIndexColName(indexdef)\n\t\tvar isRegular bool\n\t\tif strings.HasPrefix(indexName, \"IDX_\"+tableName) || strings.HasPrefix(indexName, \"UQE_\"+tableName) {\n\t\t\tnewIdxName := indexName[5+len(tableName):]\n\t\t\tisRegular = true\n\t\t\tif newIdxName != \"\" {\n\t\t\t\tindexName = newIdxName\n\t\t\t}\n\t\t}\n\n\t\tindex := &core.Index{Name: indexName, Type: indexType, Cols: make([]string, 0)}\n\t\tfor _, colName := range colNames {\n\t\t\tindex.Cols = append(index.Cols, strings.Trim(colName, `\" `))\n\t\t}\n\t\tindex.IsRegular = isRegular\n\t\tindexes[index.Name] = index\n\t}\n\treturn indexes, nil\n}\n\nfunc (db *postgres) Filters() []core.Filter {\n\treturn []core.Filter{&core.IdFilter{}, &core.QuoteFilter{}, &core.SeqFilter{Prefix: \"$\", Start: 1}}\n}\n\ntype pqDriver struct {\n}\n\ntype values map[string]string\n\nfunc (vs values) Set(k, v string) {\n\tvs[k] = v\n}\n\nfunc (vs values) Get(k string) (v string) {\n\treturn vs[k]\n}\n\nfunc parseURL(connstr string) (string, error) {\n\tu, err := url.Parse(connstr)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif u.Scheme != \"postgresql\" && u.Scheme != \"postgres\" {\n\t\treturn \"\", fmt.Errorf(\"invalid connection protocol: %s\", u.Scheme)\n\t}\n\n\tescaper := strings.NewReplacer(` `, `\\ `, `'`, `\\'`, `\\`, `\\\\`)\n\n\tif u.Path != \"\" {\n\t\treturn escaper.Replace(u.Path[1:]), nil\n\t}\n\n\treturn \"\", nil\n}\n\nfunc parseOpts(name string, o values) error {\n\tif len(name) == 0 {\n\t\treturn fmt.Errorf(\"invalid options: %s\", name)\n\t}\n\n\tname = strings.TrimSpace(name)\n\n\tps := strings.Split(name, \" \")\n\tfor _, p := range ps {\n\t\tkv := strings.Split(p, \"=\")\n\t\tif len(kv) < 2 {\n\t\t\treturn fmt.Errorf(\"invalid option: %q\", p)\n\t\t}\n\t\to.Set(kv[0], kv[1])\n\t}\n\n\treturn nil\n}\n\nfunc (p *pqDriver) Parse(driverName, dataSourceName string) (*core.Uri, error) {\n\tdb := &core.Uri{DbType: core.POSTGRES}\n\tvar err error\n\n\tif strings.HasPrefix(dataSourceName, \"postgresql://\") || strings.HasPrefix(dataSourceName, \"postgres://\") {\n\t\tdb.DbName, err = parseURL(dataSourceName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\to := make(values)\n\t\terr = parseOpts(dataSourceName, o)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdb.DbName = o.Get(\"dbname\")\n\t}\n\n\tif db.DbName == \"\" {\n\t\treturn nil, errors.New(\"dbname is empty\")\n\t}\n\n\treturn db, nil\n}\n\ntype pqDriverPgx struct {\n\tpqDriver\n}\n\nfunc (pgx *pqDriverPgx) Parse(driverName, dataSourceName string) (*core.Uri, error) {\n\t// Remove the leading characters for driver to work\n\tif len(dataSourceName) >= 9 && dataSourceName[0] == 0 {\n\t\tdataSourceName = dataSourceName[9:]\n\t}\n\treturn pgx.pqDriver.Parse(driverName, dataSourceName)\n}\n"
        },
        {
          "name": "dialect_postgres_test.go",
          "type": "blob",
          "size": 4.0517578125,
          "content": "package xorm\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"xorm.io/core\"\n)\n\nfunc TestParsePostgres(t *testing.T) {\n\ttests := []struct {\n\t\tin       string\n\t\texpected string\n\t\tvalid    bool\n\t}{\n\t\t{\"postgres://auser:password@localhost:5432/db?sslmode=disable\", \"db\", true},\n\t\t{\"postgresql://auser:password@localhost:5432/db?sslmode=disable\", \"db\", true},\n\t\t{\"postg://auser:password@localhost:5432/db?sslmode=disable\", \"db\", false},\n\t\t//{\"postgres://auser:pass with space@localhost:5432/db?sslmode=disable\", \"db\", true},\n\t\t//{\"postgres:// auser : password@localhost:5432/db?sslmode=disable\", \"db\", true},\n\t\t{\"postgres://%20auser%20:pass%20with%20space@localhost:5432/db?sslmode=disable\", \"db\", true},\n\t\t//{\"postgres://auser:パスワード@localhost:5432/データベース?sslmode=disable\", \"データベース\", true},\n\t\t{\"dbname=db sslmode=disable\", \"db\", true},\n\t\t{\"user=auser password=password dbname=db sslmode=disable\", \"db\", true},\n\t\t{\"\", \"db\", false},\n\t\t{\"dbname=db =disable\", \"db\", false},\n\t}\n\n\tdriver := core.QueryDriver(\"postgres\")\n\n\tfor _, test := range tests {\n\t\turi, err := driver.Parse(\"postgres\", test.in)\n\n\t\tif err != nil && test.valid {\n\t\t\tt.Errorf(\"%q got unexpected error: %s\", test.in, err)\n\t\t} else if err == nil && !reflect.DeepEqual(test.expected, uri.DbName) {\n\t\t\tt.Errorf(\"%q got: %#v want: %#v\", test.in, uri.DbName, test.expected)\n\t\t}\n\t}\n}\n\nfunc TestParsePgx(t *testing.T) {\n\ttests := []struct {\n\t\tin       string\n\t\texpected string\n\t\tvalid    bool\n\t}{\n\t\t{\"postgres://auser:password@localhost:5432/db?sslmode=disable\", \"db\", true},\n\t\t{\"postgresql://auser:password@localhost:5432/db?sslmode=disable\", \"db\", true},\n\t\t{\"postg://auser:password@localhost:5432/db?sslmode=disable\", \"db\", false},\n\t\t//{\"postgres://auser:pass with space@localhost:5432/db?sslmode=disable\", \"db\", true},\n\t\t//{\"postgres:// auser : password@localhost:5432/db?sslmode=disable\", \"db\", true},\n\t\t{\"postgres://%20auser%20:pass%20with%20space@localhost:5432/db?sslmode=disable\", \"db\", true},\n\t\t//{\"postgres://auser:パスワード@localhost:5432/データベース?sslmode=disable\", \"データベース\", true},\n\t\t{\"dbname=db sslmode=disable\", \"db\", true},\n\t\t{\"user=auser password=password dbname=db sslmode=disable\", \"db\", true},\n\t\t{\"\", \"db\", false},\n\t\t{\"dbname=db =disable\", \"db\", false},\n\t}\n\n\tdriver := core.QueryDriver(\"pgx\")\n\n\tfor _, test := range tests {\n\t\turi, err := driver.Parse(\"pgx\", test.in)\n\n\t\tif err != nil && test.valid {\n\t\t\tt.Errorf(\"%q got unexpected error: %s\", test.in, err)\n\t\t} else if err == nil && !reflect.DeepEqual(test.expected, uri.DbName) {\n\t\t\tt.Errorf(\"%q got: %#v want: %#v\", test.in, uri.DbName, test.expected)\n\t\t}\n\n\t\t// Register DriverConfig\n\t\turi, err = driver.Parse(\"pgx\", test.in)\n\t\tif err != nil && test.valid {\n\t\t\tt.Errorf(\"%q got unexpected error: %s\", test.in, err)\n\t\t} else if err == nil && !reflect.DeepEqual(test.expected, uri.DbName) {\n\t\t\tt.Errorf(\"%q got: %#v want: %#v\", test.in, uri.DbName, test.expected)\n\t\t}\n\n\t}\n\n}\n\nfunc TestGetIndexColName(t *testing.T) {\n\tt.Run(\"Index\", func(t *testing.T) {\n\t\ts := \"CREATE INDEX test2_mm_idx ON test2 (major);\"\n\t\tcolNames := getIndexColName(s)\n\t\tassert.Equal(t, []string{\"major\"}, colNames)\n\t})\n\n\tt.Run(\"Multicolumn indexes\", func(t *testing.T) {\n\t\ts := \"CREATE INDEX test2_mm_idx ON test2 (major, minor);\"\n\t\tcolNames := getIndexColName(s)\n\t\tassert.Equal(t, []string{\"major\", \"minor\"}, colNames)\n\t})\n\n\tt.Run(\"Indexes and ORDER BY\", func(t *testing.T) {\n\t\ts := \"CREATE INDEX test2_mm_idx ON test2 (major  NULLS FIRST, minor DESC NULLS LAST);\"\n\t\tcolNames := getIndexColName(s)\n\t\tassert.Equal(t, []string{\"major\", \"minor\"}, colNames)\n\t})\n\n\tt.Run(\"Combining Multiple Indexes\", func(t *testing.T) {\n\t\ts := \"CREATE INDEX test2_mm_cm_idx ON public.test2 USING btree (major, minor) WHERE ((major <> 5) AND (minor <> 6))\"\n\t\tcolNames := getIndexColName(s)\n\t\tassert.Equal(t, []string{\"major\", \"minor\"}, colNames)\n\t})\n\n\tt.Run(\"unique\", func(t *testing.T) {\n\t\ts := \"CREATE UNIQUE INDEX test2_mm_uidx ON test2 (major);\"\n\t\tcolNames := getIndexColName(s)\n\t\tassert.Equal(t, []string{\"major\"}, colNames)\n\t})\n\n\tt.Run(\"Indexes on Expressions\", func(t *testing.T) {})\n}\n"
        },
        {
          "name": "dialect_sqlite3.go",
          "type": "blob",
          "size": 12.25,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"xorm.io/core\"\n)\n\nvar (\n\tsqlite3ReservedWords = map[string]bool{\n\t\t\"ABORT\":             true,\n\t\t\"ACTION\":            true,\n\t\t\"ADD\":               true,\n\t\t\"AFTER\":             true,\n\t\t\"ALL\":               true,\n\t\t\"ALTER\":             true,\n\t\t\"ANALYZE\":           true,\n\t\t\"AND\":               true,\n\t\t\"AS\":                true,\n\t\t\"ASC\":               true,\n\t\t\"ATTACH\":            true,\n\t\t\"AUTOINCREMENT\":     true,\n\t\t\"BEFORE\":            true,\n\t\t\"BEGIN\":             true,\n\t\t\"BETWEEN\":           true,\n\t\t\"BY\":                true,\n\t\t\"CASCADE\":           true,\n\t\t\"CASE\":              true,\n\t\t\"CAST\":              true,\n\t\t\"CHECK\":             true,\n\t\t\"COLLATE\":           true,\n\t\t\"COLUMN\":            true,\n\t\t\"COMMIT\":            true,\n\t\t\"CONFLICT\":          true,\n\t\t\"CONSTRAINT\":        true,\n\t\t\"CREATE\":            true,\n\t\t\"CROSS\":             true,\n\t\t\"CURRENT_DATE\":      true,\n\t\t\"CURRENT_TIME\":      true,\n\t\t\"CURRENT_TIMESTAMP\": true,\n\t\t\"DATABASE\":          true,\n\t\t\"DEFAULT\":           true,\n\t\t\"DEFERRABLE\":        true,\n\t\t\"DEFERRED\":          true,\n\t\t\"DELETE\":            true,\n\t\t\"DESC\":              true,\n\t\t\"DETACH\":            true,\n\t\t\"DISTINCT\":          true,\n\t\t\"DROP\":              true,\n\t\t\"EACH\":              true,\n\t\t\"ELSE\":              true,\n\t\t\"END\":               true,\n\t\t\"ESCAPE\":            true,\n\t\t\"EXCEPT\":            true,\n\t\t\"EXCLUSIVE\":         true,\n\t\t\"EXISTS\":            true,\n\t\t\"EXPLAIN\":           true,\n\t\t\"FAIL\":              true,\n\t\t\"FOR\":               true,\n\t\t\"FOREIGN\":           true,\n\t\t\"FROM\":              true,\n\t\t\"FULL\":              true,\n\t\t\"GLOB\":              true,\n\t\t\"GROUP\":             true,\n\t\t\"HAVING\":            true,\n\t\t\"IF\":                true,\n\t\t\"IGNORE\":            true,\n\t\t\"IMMEDIATE\":         true,\n\t\t\"IN\":                true,\n\t\t\"INDEX\":             true,\n\t\t\"INDEXED\":           true,\n\t\t\"INITIALLY\":         true,\n\t\t\"INNER\":             true,\n\t\t\"INSERT\":            true,\n\t\t\"INSTEAD\":           true,\n\t\t\"INTERSECT\":         true,\n\t\t\"INTO\":              true,\n\t\t\"IS\":                true,\n\t\t\"ISNULL\":            true,\n\t\t\"JOIN\":              true,\n\t\t\"KEY\":               true,\n\t\t\"LEFT\":              true,\n\t\t\"LIKE\":              true,\n\t\t\"LIMIT\":             true,\n\t\t\"MATCH\":             true,\n\t\t\"NATURAL\":           true,\n\t\t\"NO\":                true,\n\t\t\"NOT\":               true,\n\t\t\"NOTNULL\":           true,\n\t\t\"NULL\":              true,\n\t\t\"OF\":                true,\n\t\t\"OFFSET\":            true,\n\t\t\"ON\":                true,\n\t\t\"OR\":                true,\n\t\t\"ORDER\":             true,\n\t\t\"OUTER\":             true,\n\t\t\"PLAN\":              true,\n\t\t\"PRAGMA\":            true,\n\t\t\"PRIMARY\":           true,\n\t\t\"QUERY\":             true,\n\t\t\"RAISE\":             true,\n\t\t\"RECURSIVE\":         true,\n\t\t\"REFERENCES\":        true,\n\t\t\"REGEXP\":            true,\n\t\t\"REINDEX\":           true,\n\t\t\"RELEASE\":           true,\n\t\t\"RENAME\":            true,\n\t\t\"REPLACE\":           true,\n\t\t\"RESTRICT\":          true,\n\t\t\"RIGHT\":             true,\n\t\t\"ROLLBACK\":          true,\n\t\t\"ROW\":               true,\n\t\t\"SAVEPOINT\":         true,\n\t\t\"SELECT\":            true,\n\t\t\"SET\":               true,\n\t\t\"TABLE\":             true,\n\t\t\"TEMP\":              true,\n\t\t\"TEMPORARY\":         true,\n\t\t\"THEN\":              true,\n\t\t\"TO\":                true,\n\t\t\"TRANSACTI\":         true,\n\t\t\"TRIGGER\":           true,\n\t\t\"UNION\":             true,\n\t\t\"UNIQUE\":            true,\n\t\t\"UPDATE\":            true,\n\t\t\"USING\":             true,\n\t\t\"VACUUM\":            true,\n\t\t\"VALUES\":            true,\n\t\t\"VIEW\":              true,\n\t\t\"VIRTUAL\":           true,\n\t\t\"WHEN\":              true,\n\t\t\"WHERE\":             true,\n\t\t\"WITH\":              true,\n\t\t\"WITHOUT\":           true,\n\t}\n)\n\ntype sqlite3 struct {\n\tcore.Base\n}\n\nfunc (db *sqlite3) Init(d *core.DB, uri *core.Uri, drivername, dataSourceName string) error {\n\treturn db.Base.Init(d, db, uri, drivername, dataSourceName)\n}\n\nfunc (db *sqlite3) SqlType(c *core.Column) string {\n\tswitch t := c.SQLType.Name; t {\n\tcase core.Bool:\n\t\tif c.Default == \"true\" {\n\t\t\tc.Default = \"1\"\n\t\t} else if c.Default == \"false\" {\n\t\t\tc.Default = \"0\"\n\t\t}\n\t\treturn core.Integer\n\tcase core.Date, core.DateTime, core.TimeStamp, core.Time:\n\t\treturn core.DateTime\n\tcase core.TimeStampz:\n\t\treturn core.Text\n\tcase core.Char, core.Varchar, core.NVarchar, core.TinyText,\n\t\tcore.Text, core.MediumText, core.LongText, core.Json:\n\t\treturn core.Text\n\tcase core.Bit, core.TinyInt, core.SmallInt, core.MediumInt, core.Int, core.Integer, core.BigInt:\n\t\treturn core.Integer\n\tcase core.Float, core.Double, core.Real:\n\t\treturn core.Real\n\tcase core.Decimal, core.Numeric:\n\t\treturn core.Numeric\n\tcase core.TinyBlob, core.Blob, core.MediumBlob, core.LongBlob, core.Bytea, core.Binary, core.VarBinary:\n\t\treturn core.Blob\n\tcase core.Serial, core.BigSerial:\n\t\tc.IsPrimaryKey = true\n\t\tc.IsAutoIncrement = true\n\t\tc.Nullable = false\n\t\treturn core.Integer\n\tdefault:\n\t\treturn t\n\t}\n}\n\nfunc (db *sqlite3) FormatBytes(bs []byte) string {\n\treturn fmt.Sprintf(\"X'%x'\", bs)\n}\n\nfunc (db *sqlite3) SupportInsertMany() bool {\n\treturn true\n}\n\nfunc (db *sqlite3) IsReserved(name string) bool {\n\t_, ok := sqlite3ReservedWords[name]\n\treturn ok\n}\n\nfunc (db *sqlite3) Quote(name string) string {\n\treturn \"`\" + name + \"`\"\n}\n\nfunc (db *sqlite3) AutoIncrStr() string {\n\treturn \"AUTOINCREMENT\"\n}\n\nfunc (db *sqlite3) SupportEngine() bool {\n\treturn false\n}\n\nfunc (db *sqlite3) SupportCharset() bool {\n\treturn false\n}\n\nfunc (db *sqlite3) IndexOnTable() bool {\n\treturn false\n}\n\nfunc (db *sqlite3) IndexCheckSql(tableName, idxName string) (string, []interface{}) {\n\targs := []interface{}{idxName}\n\treturn \"SELECT name FROM sqlite_master WHERE type='index' and name = ?\", args\n}\n\nfunc (db *sqlite3) TableCheckSql(tableName string) (string, []interface{}) {\n\targs := []interface{}{tableName}\n\treturn \"SELECT name FROM sqlite_master WHERE type='table' and name = ?\", args\n}\n\nfunc (db *sqlite3) DropIndexSql(tableName string, index *core.Index) string {\n\t// var unique string\n\tquote := db.Quote\n\tidxName := index.Name\n\n\tif !strings.HasPrefix(idxName, \"UQE_\") &&\n\t\t!strings.HasPrefix(idxName, \"IDX_\") {\n\t\tif index.Type == core.UniqueType {\n\t\t\tidxName = fmt.Sprintf(\"UQE_%v_%v\", tableName, index.Name)\n\t\t} else {\n\t\t\tidxName = fmt.Sprintf(\"IDX_%v_%v\", tableName, index.Name)\n\t\t}\n\t}\n\treturn fmt.Sprintf(\"DROP INDEX %v\", quote(idxName))\n}\n\nfunc (db *sqlite3) ForUpdateSql(query string) string {\n\treturn query\n}\n\n/*func (db *sqlite3) ColumnCheckSql(tableName, colName string) (string, []interface{}) {\n\targs := []interface{}{tableName}\n\tsql := \"SELECT name FROM sqlite_master WHERE type='table' and name = ? and ((sql like '%`\" + colName + \"`%') or (sql like '%[\" + colName + \"]%'))\"\n\treturn sql, args\n}*/\n\nfunc (db *sqlite3) IsColumnExist(tableName, colName string) (bool, error) {\n\targs := []interface{}{tableName}\n\tquery := \"SELECT name FROM sqlite_master WHERE type='table' and name = ? and ((sql like '%`\" + colName + \"`%') or (sql like '%[\" + colName + \"]%'))\"\n\tdb.LogSQL(query, args)\n\trows, err := db.DB().Query(query, args...)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer rows.Close()\n\n\tif rows.Next() {\n\t\treturn true, nil\n\t}\n\treturn false, nil\n}\n\n// splitColStr splits a sqlite col strings as fields\nfunc splitColStr(colStr string) []string {\n\tcolStr = strings.TrimSpace(colStr)\n\tvar results = make([]string, 0, 10)\n\tvar lastIdx int\n\tvar hasC, hasQuote bool\n\tfor i, c := range colStr {\n\t\tif c == ' ' && !hasQuote {\n\t\t\tif hasC {\n\t\t\t\tresults = append(results, colStr[lastIdx:i])\n\t\t\t\thasC = false\n\t\t\t}\n\t\t} else {\n\t\t\tif c == '\\'' {\n\t\t\t\thasQuote = !hasQuote\n\t\t\t}\n\t\t\tif !hasC {\n\t\t\t\tlastIdx = i\n\t\t\t}\n\t\t\thasC = true\n\t\t\tif i == len(colStr)-1 {\n\t\t\t\tresults = append(results, colStr[lastIdx:i+1])\n\t\t\t}\n\t\t}\n\t}\n\treturn results\n}\n\nfunc parseString(colStr string) (*core.Column, error) {\n\tfields := splitColStr(colStr)\n\tcol := new(core.Column)\n\tcol.Indexes = make(map[string]int)\n\tcol.Nullable = true\n\tcol.DefaultIsEmpty = true\n\n\tfor idx, field := range fields {\n\t\tif idx == 0 {\n\t\t\tcol.Name = strings.Trim(strings.Trim(field, \"`[] \"), `\"`)\n\t\t\tcontinue\n\t\t} else if idx == 1 {\n\t\t\tcol.SQLType = core.SQLType{Name: field, DefaultLength: 0, DefaultLength2: 0}\n\t\t\tcontinue\n\t\t}\n\t\tswitch field {\n\t\tcase \"PRIMARY\":\n\t\t\tcol.IsPrimaryKey = true\n\t\tcase \"AUTOINCREMENT\":\n\t\t\tcol.IsAutoIncrement = true\n\t\tcase \"NULL\":\n\t\t\tif fields[idx-1] == \"NOT\" {\n\t\t\t\tcol.Nullable = false\n\t\t\t} else {\n\t\t\t\tcol.Nullable = true\n\t\t\t}\n\t\tcase \"DEFAULT\":\n\t\t\tcol.Default = fields[idx+1]\n\t\t\tcol.DefaultIsEmpty = false\n\t\t}\n\t}\n\treturn col, nil\n}\n\nfunc (db *sqlite3) GetColumns(tableName string) ([]string, map[string]*core.Column, error) {\n\targs := []interface{}{tableName}\n\ts := \"SELECT sql FROM sqlite_master WHERE type='table' and name = ?\"\n\tdb.LogSQL(s, args)\n\trows, err := db.DB().Query(s, args...)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar name string\n\tfor rows.Next() {\n\t\terr = rows.Scan(&name)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tbreak\n\t}\n\n\tif name == \"\" {\n\t\treturn nil, nil, errors.New(\"no table named \" + tableName)\n\t}\n\n\tnStart := strings.Index(name, \"(\")\n\tnEnd := strings.LastIndex(name, \")\")\n\treg := regexp.MustCompile(`[^\\(,\\)]*(\\([^\\(]*\\))?`)\n\tcolCreates := reg.FindAllString(name[nStart+1:nEnd], -1)\n\tcols := make(map[string]*core.Column)\n\tcolSeq := make([]string, 0)\n\n\tfor _, colStr := range colCreates {\n\t\treg = regexp.MustCompile(`,\\s`)\n\t\tcolStr = reg.ReplaceAllString(colStr, \",\")\n\t\tif strings.HasPrefix(strings.TrimSpace(colStr), \"PRIMARY KEY\") {\n\t\t\tparts := strings.Split(strings.TrimSpace(colStr), \"(\")\n\t\t\tif len(parts) == 2 {\n\t\t\t\tpkCols := strings.Split(strings.TrimRight(strings.TrimSpace(parts[1]), \")\"), \",\")\n\t\t\t\tfor _, pk := range pkCols {\n\t\t\t\t\tif col, ok := cols[strings.Trim(strings.TrimSpace(pk), \"`\")]; ok {\n\t\t\t\t\t\tcol.IsPrimaryKey = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tcol, err := parseString(colStr)\n\t\tif err != nil {\n\t\t\treturn colSeq, cols, err\n\t\t}\n\n\t\tcols[col.Name] = col\n\t\tcolSeq = append(colSeq, col.Name)\n\t}\n\treturn colSeq, cols, nil\n}\n\nfunc (db *sqlite3) GetTables() ([]*core.Table, error) {\n\targs := []interface{}{}\n\ts := \"SELECT name FROM sqlite_master WHERE type='table'\"\n\tdb.LogSQL(s, args)\n\n\trows, err := db.DB().Query(s, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\ttables := make([]*core.Table, 0)\n\tfor rows.Next() {\n\t\ttable := core.NewEmptyTable()\n\t\terr = rows.Scan(&table.Name)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif table.Name == \"sqlite_sequence\" {\n\t\t\tcontinue\n\t\t}\n\t\ttables = append(tables, table)\n\t}\n\treturn tables, nil\n}\n\nfunc (db *sqlite3) GetIndexes(tableName string) (map[string]*core.Index, error) {\n\targs := []interface{}{tableName}\n\ts := \"SELECT sql FROM sqlite_master WHERE type='index' and tbl_name = ?\"\n\tdb.LogSQL(s, args)\n\n\trows, err := db.DB().Query(s, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tindexes := make(map[string]*core.Index, 0)\n\tfor rows.Next() {\n\t\tvar tmpSQL sql.NullString\n\t\terr = rows.Scan(&tmpSQL)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif !tmpSQL.Valid {\n\t\t\tcontinue\n\t\t}\n\t\tsql := tmpSQL.String\n\n\t\tindex := new(core.Index)\n\t\tnNStart := strings.Index(sql, \"INDEX\")\n\t\tnNEnd := strings.Index(sql, \"ON\")\n\t\tif nNStart == -1 || nNEnd == -1 {\n\t\t\tcontinue\n\t\t}\n\n\t\tindexName := strings.Trim(sql[nNStart+6:nNEnd], \"` []\")\n\t\tvar isRegular bool\n\t\tif strings.HasPrefix(indexName, \"IDX_\"+tableName) || strings.HasPrefix(indexName, \"UQE_\"+tableName) {\n\t\t\tindex.Name = indexName[5+len(tableName):]\n\t\t\tisRegular = true\n\t\t} else {\n\t\t\tindex.Name = indexName\n\t\t}\n\n\t\tif strings.HasPrefix(sql, \"CREATE UNIQUE INDEX\") {\n\t\t\tindex.Type = core.UniqueType\n\t\t} else {\n\t\t\tindex.Type = core.IndexType\n\t\t}\n\n\t\tnStart := strings.Index(sql, \"(\")\n\t\tnEnd := strings.Index(sql, \")\")\n\t\tcolIndexes := strings.Split(sql[nStart+1:nEnd], \",\")\n\n\t\tindex.Cols = make([]string, 0)\n\t\tfor _, col := range colIndexes {\n\t\t\tindex.Cols = append(index.Cols, strings.Trim(col, \"` []\"))\n\t\t}\n\t\tindex.IsRegular = isRegular\n\t\tindexes[index.Name] = index\n\t}\n\n\treturn indexes, nil\n}\n\nfunc (db *sqlite3) Filters() []core.Filter {\n\treturn []core.Filter{&core.IdFilter{}}\n}\n\ntype sqlite3Driver struct {\n}\n\nfunc (p *sqlite3Driver) Parse(driverName, dataSourceName string) (*core.Uri, error) {\n\tif strings.Contains(dataSourceName, \"?\") {\n\t\tdataSourceName = dataSourceName[:strings.Index(dataSourceName, \"?\")]\n\t}\n\n\treturn &core.Uri{DbType: core.SQLITE, DbName: dataSourceName}, nil\n}\n"
        },
        {
          "name": "dialect_sqlite3_test.go",
          "type": "blob",
          "size": 0.7685546875,
          "content": "// Copyright 2019 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSplitColStr(t *testing.T) {\n\tvar kases = []struct {\n\t\tcolStr string\n\t\tfields []string\n\t}{\n\t\t{\n\t\t\tcolStr: \"`id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL\",\n\t\t\tfields: []string{\n\t\t\t\t\"`id`\", \"INTEGER\", \"PRIMARY\", \"KEY\", \"AUTOINCREMENT\", \"NOT\", \"NULL\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tcolStr: \"`created` DATETIME DEFAULT '2006-01-02 15:04:05' NULL\",\n\t\t\tfields: []string{\n\t\t\t\t\"`created`\", \"DATETIME\", \"DEFAULT\", \"'2006-01-02 15:04:05'\", \"NULL\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, kase := range kases {\n\t\tassert.EqualValues(t, kase.fields, splitColStr(kase.colStr))\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 5.08203125,
          "content": "// Copyright 2013 - 2016 The XORM Authors. All rights reserved.\n// Use of this source code is governed by a BSD\n// license that can be found in the LICENSE file.\n\n/*\n\nPackage xorm is a simple and powerful ORM for Go.\n\nInstallation\n\nMake sure you have installed Go 1.6+ and then:\n\n    go get github.com/go-xorm/xorm\n\nCreate Engine\n\nFirstly, we should new an engine for a database\n\n    engine, err := xorm.NewEngine(driverName, dataSourceName)\n\nMethod NewEngine's parameters is the same as sql.Open. It depends\ndrivers' implementation.\nGenerally, one engine for an application is enough. You can set it as package variable.\n\nRaw Methods\n\nXORM also support raw SQL execution:\n\n1. query a SQL string, the returned results is []map[string][]byte\n\n    results, err := engine.Query(\"select * from user\")\n\n2. execute a SQL string, the returned results\n\n    affected, err := engine.Exec(\"update user set .... where ...\")\n\nORM Methods\n\nThere are 8 major ORM methods and many helpful methods to use to operate database.\n\n1. Insert one or multiple records to database\n\n    affected, err := engine.Insert(&struct)\n    // INSERT INTO struct () values ()\n    affected, err := engine.Insert(&struct1, &struct2)\n    // INSERT INTO struct1 () values ()\n    // INSERT INTO struct2 () values ()\n    affected, err := engine.Insert(&sliceOfStruct)\n    // INSERT INTO struct () values (),(),()\n    affected, err := engine.Insert(&struct1, &sliceOfStruct2)\n    // INSERT INTO struct1 () values ()\n    // INSERT INTO struct2 () values (),(),()\n\n2. Query one record or one variable from database\n\n    has, err := engine.Get(&user)\n    // SELECT * FROM user LIMIT 1\n\n    var id int64\n    has, err := engine.Table(\"user\").Where(\"name = ?\", name).Get(&id)\n    // SELECT id FROM user WHERE name = ? LIMIT 1\n\n3. Query multiple records from database\n\n    var sliceOfStructs []Struct\n    err := engine.Find(&sliceOfStructs)\n    // SELECT * FROM user\n\n    var mapOfStructs = make(map[int64]Struct)\n    err := engine.Find(&mapOfStructs)\n    // SELECT * FROM user\n\n    var int64s []int64\n    err := engine.Table(\"user\").Cols(\"id\").Find(&int64s)\n    // SELECT id FROM user\n\n4. Query multiple records and record by record handle, there two methods, one is Iterate,\nanother is Rows\n\n    err := engine.Iterate(...)\n    // SELECT * FROM user\n\n    rows, err := engine.Rows(...)\n    // SELECT * FROM user\n    defer rows.Close()\n    bean := new(Struct)\n    for rows.Next() {\n        err = rows.Scan(bean)\n    }\n\n5. Update one or more records\n\n    affected, err := engine.ID(...).Update(&user)\n    // UPDATE user SET ...\n\n6. Delete one or more records, Delete MUST has condition\n\n    affected, err := engine.Where(...).Delete(&user)\n    // DELETE FROM user Where ...\n\n7. Count records\n\n    counts, err := engine.Count(&user)\n    // SELECT count(*) AS total FROM user\n\n    counts, err := engine.SQL(\"select count(*) FROM user\").Count()\n    // select count(*) FROM user\n\n8. Sum records\n\n    sumFloat64, err := engine.Sum(&user, \"id\")\n    // SELECT sum(id) from user\n\n    sumFloat64s, err := engine.Sums(&user, \"id1\", \"id2\")\n    // SELECT sum(id1), sum(id2) from user\n\n    sumInt64s, err := engine.SumsInt(&user, \"id1\", \"id2\")\n    // SELECT sum(id1), sum(id2) from user\n\nConditions\n\nThe above 8 methods could use with condition methods chainable.\nAttention: the above 8 methods should be the last chainable method.\n\n1. ID, In\n\n    engine.ID(1).Get(&user) // for single primary key\n    // SELECT * FROM user WHERE id = 1\n    engine.ID(core.PK{1, 2}).Get(&user) // for composite primary keys\n    // SELECT * FROM user WHERE id1 = 1 AND id2 = 2\n    engine.In(\"id\", 1, 2, 3).Find(&users)\n    // SELECT * FROM user WHERE id IN (1, 2, 3)\n    engine.In(\"id\", []int{1, 2, 3}).Find(&users)\n    // SELECT * FROM user WHERE id IN (1, 2, 3)\n\n2. Where, And, Or\n\n    engine.Where().And().Or().Find()\n    // SELECT * FROM user WHERE (.. AND ..) OR ...\n\n3. OrderBy, Asc, Desc\n\n    engine.Asc().Desc().Find()\n    // SELECT * FROM user ORDER BY .. ASC, .. DESC\n    engine.OrderBy().Find()\n    // SELECT * FROM user ORDER BY ..\n\n4. Limit, Top\n\n    engine.Limit().Find()\n    // SELECT * FROM user LIMIT .. OFFSET ..\n    engine.Top(5).Find()\n    // SELECT TOP 5 * FROM user // for mssql\n    // SELECT * FROM user LIMIT .. OFFSET 0 //for other databases\n\n5. SQL, let you custom SQL\n\n    var users []User\n    engine.SQL(\"select * from user\").Find(&users)\n\n6. Cols, Omit, Distinct\n\n    var users []*User\n    engine.Cols(\"col1, col2\").Find(&users)\n    // SELECT col1, col2 FROM user\n    engine.Cols(\"col1\", \"col2\").Where().Update(user)\n    // UPDATE user set col1 = ?, col2 = ? Where ...\n    engine.Omit(\"col1\").Find(&users)\n    // SELECT col2, col3 FROM user\n    engine.Omit(\"col1\").Insert(&user)\n    // INSERT INTO table (non-col1) VALUES ()\n    engine.Distinct(\"col1\").Find(&users)\n    // SELECT DISTINCT col1 FROM user\n\n7. Join, GroupBy, Having\n\n    engine.GroupBy(\"name\").Having(\"name='xlw'\").Find(&users)\n    //SELECT * FROM user GROUP BY name HAVING name='xlw'\n    engine.Join(\"LEFT\", \"userdetail\", \"user.id=userdetail.id\").Find(&users)\n    //SELECT * FROM user LEFT JOIN userdetail ON user.id=userdetail.id\n\nMore usage, please visit http://xorm.io/docs\n*/\npackage xorm\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "engine.go",
          "type": "blob",
          "size": 44.267578125,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"database/sql\"\n\t\"encoding/gob\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"xorm.io/builder\"\n\t\"xorm.io/core\"\n)\n\n// Engine is the major struct of xorm, it means a database manager.\n// Commonly, an application only need one engine\ntype Engine struct {\n\tdb      *core.DB\n\tdialect core.Dialect\n\n\tColumnMapper  core.IMapper\n\tTableMapper   core.IMapper\n\tTagIdentifier string\n\tTables        map[reflect.Type]*core.Table\n\n\tmutex  *sync.RWMutex\n\tCacher core.Cacher\n\n\tshowSQL      bool\n\tshowExecTime bool\n\n\tlogger     core.ILogger\n\tTZLocation *time.Location // The timezone of the application\n\tDatabaseTZ *time.Location // The timezone of the database\n\n\tdisableGlobalCache bool\n\n\ttagHandlers map[string]tagHandler\n\n\tengineGroup *EngineGroup\n\n\tcachers    map[string]core.Cacher\n\tcacherLock sync.RWMutex\n\n\tdefaultContext context.Context\n}\n\nfunc (engine *Engine) setCacher(tableName string, cacher core.Cacher) {\n\tengine.cacherLock.Lock()\n\tengine.cachers[tableName] = cacher\n\tengine.cacherLock.Unlock()\n}\n\nfunc (engine *Engine) SetCacher(tableName string, cacher core.Cacher) {\n\tengine.setCacher(tableName, cacher)\n}\n\nfunc (engine *Engine) getCacher(tableName string) core.Cacher {\n\tvar cacher core.Cacher\n\tvar ok bool\n\tengine.cacherLock.RLock()\n\tcacher, ok = engine.cachers[tableName]\n\tengine.cacherLock.RUnlock()\n\tif !ok && !engine.disableGlobalCache {\n\t\tcacher = engine.Cacher\n\t}\n\treturn cacher\n}\n\nfunc (engine *Engine) GetCacher(tableName string) core.Cacher {\n\treturn engine.getCacher(tableName)\n}\n\n// BufferSize sets buffer size for iterate\nfunc (engine *Engine) BufferSize(size int) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.BufferSize(size)\n}\n\n// CondDeleted returns the conditions whether a record is soft deleted.\nfunc (engine *Engine) CondDeleted(colName string) builder.Cond {\n\tif engine.dialect.DBType() == core.MSSQL {\n\t\treturn builder.IsNull{colName}\n\t}\n\treturn builder.IsNull{colName}.Or(builder.Eq{colName: zeroTime1})\n}\n\n// ShowSQL show SQL statement or not on logger if log level is great than INFO\nfunc (engine *Engine) ShowSQL(show ...bool) {\n\tengine.logger.ShowSQL(show...)\n\tif len(show) == 0 {\n\t\tengine.showSQL = true\n\t} else {\n\t\tengine.showSQL = show[0]\n\t}\n}\n\n// ShowExecTime show SQL statement and execute time or not on logger if log level is great than INFO\nfunc (engine *Engine) ShowExecTime(show ...bool) {\n\tif len(show) == 0 {\n\t\tengine.showExecTime = true\n\t} else {\n\t\tengine.showExecTime = show[0]\n\t}\n}\n\n// Logger return the logger interface\nfunc (engine *Engine) Logger() core.ILogger {\n\treturn engine.logger\n}\n\n// SetLogger set the new logger\nfunc (engine *Engine) SetLogger(logger core.ILogger) {\n\tengine.logger = logger\n\tengine.showSQL = logger.IsShowSQL()\n\tengine.dialect.SetLogger(logger)\n}\n\n// SetLogLevel sets the logger level\nfunc (engine *Engine) SetLogLevel(level core.LogLevel) {\n\tengine.logger.SetLevel(level)\n}\n\n// SetDisableGlobalCache disable global cache or not\nfunc (engine *Engine) SetDisableGlobalCache(disable bool) {\n\tif engine.disableGlobalCache != disable {\n\t\tengine.disableGlobalCache = disable\n\t}\n}\n\n// DriverName return the current sql driver's name\nfunc (engine *Engine) DriverName() string {\n\treturn engine.dialect.DriverName()\n}\n\n// DataSourceName return the current connection string\nfunc (engine *Engine) DataSourceName() string {\n\treturn engine.dialect.DataSourceName()\n}\n\n// SetMapper set the name mapping rules\nfunc (engine *Engine) SetMapper(mapper core.IMapper) {\n\tengine.SetTableMapper(mapper)\n\tengine.SetColumnMapper(mapper)\n}\n\n// SetTableMapper set the table name mapping rule\nfunc (engine *Engine) SetTableMapper(mapper core.IMapper) {\n\tengine.TableMapper = mapper\n}\n\n// SetColumnMapper set the column name mapping rule\nfunc (engine *Engine) SetColumnMapper(mapper core.IMapper) {\n\tengine.ColumnMapper = mapper\n}\n\n// SupportInsertMany If engine's database support batch insert records like\n// \"insert into user values (name, age), (name, age)\".\n// When the return is ture, then engine.Insert(&users) will\n// generate batch sql and exeute.\nfunc (engine *Engine) SupportInsertMany() bool {\n\treturn engine.dialect.SupportInsertMany()\n}\n\nfunc (engine *Engine) quoteColumns(columnStr string) string {\n\tcolumns := strings.Split(columnStr, \",\")\n\tfor i := 0; i < len(columns); i++ {\n\t\tcolumns[i] = engine.Quote(strings.TrimSpace(columns[i]))\n\t}\n\treturn strings.Join(columns, \",\")\n}\n\n// Quote Use QuoteStr quote the string sql\nfunc (engine *Engine) Quote(value string) string {\n\tvalue = strings.TrimSpace(value)\n\tif len(value) == 0 {\n\t\treturn value\n\t}\n\n\tbuf := strings.Builder{}\n\tengine.QuoteTo(&buf, value)\n\n\treturn buf.String()\n}\n\n// QuoteTo quotes string and writes into the buffer\nfunc (engine *Engine) QuoteTo(buf *strings.Builder, value string) {\n\tif buf == nil {\n\t\treturn\n\t}\n\n\tvalue = strings.TrimSpace(value)\n\tif value == \"\" {\n\t\treturn\n\t}\n\n\tquotePair := engine.dialect.Quote(\"\")\n\n\tif value[0] == '`' || len(quotePair) < 2 || value[0] == quotePair[0] { // no quote\n\t\t_, _ = buf.WriteString(value)\n\t\treturn\n\t} else {\n\t\tprefix, suffix := quotePair[0], quotePair[1]\n\n\t\t_ = buf.WriteByte(prefix)\n\t\tfor i := 0; i < len(value); i++ {\n\t\t\tif value[i] == '.' {\n\t\t\t\t_ = buf.WriteByte(suffix)\n\t\t\t\t_ = buf.WriteByte('.')\n\t\t\t\t_ = buf.WriteByte(prefix)\n\t\t\t} else {\n\t\t\t\t_ = buf.WriteByte(value[i])\n\t\t\t}\n\t\t}\n\t\t_ = buf.WriteByte(suffix)\n\t}\n}\n\nfunc (engine *Engine) quote(sql string) string {\n\treturn engine.dialect.Quote(sql)\n}\n\n// SqlType will be deprecated, please use SQLType instead\n//\n// Deprecated: use SQLType instead\nfunc (engine *Engine) SqlType(c *core.Column) string {\n\treturn engine.SQLType(c)\n}\n\n// SQLType A simple wrapper to dialect's core.SqlType method\nfunc (engine *Engine) SQLType(c *core.Column) string {\n\treturn engine.dialect.SqlType(c)\n}\n\n// AutoIncrStr Database's autoincrement statement\nfunc (engine *Engine) AutoIncrStr() string {\n\treturn engine.dialect.AutoIncrStr()\n}\n\n// SetConnMaxLifetime sets the maximum amount of time a connection may be reused.\nfunc (engine *Engine) SetConnMaxLifetime(d time.Duration) {\n\tengine.db.SetConnMaxLifetime(d)\n}\n\n// SetMaxOpenConns is only available for go 1.2+\nfunc (engine *Engine) SetMaxOpenConns(conns int) {\n\tengine.db.SetMaxOpenConns(conns)\n}\n\n// SetMaxIdleConns set the max idle connections on pool, default is 2\nfunc (engine *Engine) SetMaxIdleConns(conns int) {\n\tengine.db.SetMaxIdleConns(conns)\n}\n\n// SetDefaultCacher set the default cacher. Xorm's default not enable cacher.\nfunc (engine *Engine) SetDefaultCacher(cacher core.Cacher) {\n\tengine.Cacher = cacher\n}\n\n// GetDefaultCacher returns the default cacher\nfunc (engine *Engine) GetDefaultCacher() core.Cacher {\n\treturn engine.Cacher\n}\n\n// NoCache If you has set default cacher, and you want temporilly stop use cache,\n// you can use NoCache()\nfunc (engine *Engine) NoCache() *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.NoCache()\n}\n\n// NoCascade If you do not want to auto cascade load object\nfunc (engine *Engine) NoCascade() *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.NoCascade()\n}\n\n// MapCacher Set a table use a special cacher\nfunc (engine *Engine) MapCacher(bean interface{}, cacher core.Cacher) error {\n\tengine.setCacher(engine.TableName(bean, true), cacher)\n\treturn nil\n}\n\n// NewDB provides an interface to operate database directly\nfunc (engine *Engine) NewDB() (*core.DB, error) {\n\treturn core.OpenDialect(engine.dialect)\n}\n\n// DB return the wrapper of sql.DB\nfunc (engine *Engine) DB() *core.DB {\n\treturn engine.db\n}\n\n// Dialect return database dialect\nfunc (engine *Engine) Dialect() core.Dialect {\n\treturn engine.dialect\n}\n\n// NewSession New a session\nfunc (engine *Engine) NewSession() *Session {\n\tsession := &Session{engine: engine}\n\tsession.Init()\n\treturn session\n}\n\n// Close the engine\nfunc (engine *Engine) Close() error {\n\treturn engine.db.Close()\n}\n\n// Ping tests if database is alive\nfunc (engine *Engine) Ping() error {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.Ping()\n}\n\n// logging sql\nfunc (engine *Engine) logSQL(sqlStr string, sqlArgs ...interface{}) {\n\tif engine.showSQL && !engine.showExecTime {\n\t\tif len(sqlArgs) > 0 {\n\t\t\tengine.logger.Infof(\"[SQL] %v %#v\", sqlStr, sqlArgs)\n\t\t} else {\n\t\t\tengine.logger.Infof(\"[SQL] %v\", sqlStr)\n\t\t}\n\t}\n}\n\n// Sql provides raw sql input parameter. When you have a complex SQL statement\n// and cannot use Where, Id, In and etc. Methods to describe, you can use SQL.\n//\n// Deprecated: use SQL instead.\nfunc (engine *Engine) Sql(querystring string, args ...interface{}) *Session {\n\treturn engine.SQL(querystring, args...)\n}\n\n// SQL method let's you manually write raw SQL and operate\n// For example:\n//\n//         engine.SQL(\"select * from user\").Find(&users)\n//\n// This    code will execute \"select * from user\" and set the records to users\nfunc (engine *Engine) SQL(query interface{}, args ...interface{}) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.SQL(query, args...)\n}\n\n// NoAutoTime Default if your struct has \"created\" or \"updated\" filed tag, the fields\n// will automatically be filled with current time when Insert or Update\n// invoked. Call NoAutoTime if you dont' want to fill automatically.\nfunc (engine *Engine) NoAutoTime() *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.NoAutoTime()\n}\n\n// NoAutoCondition disable auto generate Where condition from bean or not\nfunc (engine *Engine) NoAutoCondition(no ...bool) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.NoAutoCondition(no...)\n}\n\nfunc (engine *Engine) loadTableInfo(table *core.Table) error {\n\tcolSeq, cols, err := engine.dialect.GetColumns(table.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, name := range colSeq {\n\t\ttable.AddColumn(cols[name])\n\t}\n\tindexes, err := engine.dialect.GetIndexes(table.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttable.Indexes = indexes\n\n\tfor _, index := range indexes {\n\t\tfor _, name := range index.Cols {\n\t\t\tif col := table.GetColumn(name); col != nil {\n\t\t\t\tcol.Indexes[index.Name] = index.Type\n\t\t\t} else {\n\t\t\t\treturn fmt.Errorf(\"Unknown col %s in index %v of table %v, columns %v\", name, index.Name, table.Name, table.ColumnsSeq())\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// DBMetas Retrieve all tables, columns, indexes' informations from database.\nfunc (engine *Engine) DBMetas() ([]*core.Table, error) {\n\ttables, err := engine.dialect.GetTables()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, table := range tables {\n\t\tif err = engine.loadTableInfo(table); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn tables, nil\n}\n\n// DumpAllToFile dump database all table structs and data to a file\nfunc (engine *Engine) DumpAllToFile(fp string, tp ...core.DbType) error {\n\tf, err := os.Create(fp)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\treturn engine.DumpAll(f, tp...)\n}\n\n// DumpAll dump database all table structs and data to w\nfunc (engine *Engine) DumpAll(w io.Writer, tp ...core.DbType) error {\n\ttables, err := engine.DBMetas()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn engine.DumpTables(tables, w, tp...)\n}\n\n// DumpTablesToFile dump specified tables to SQL file.\nfunc (engine *Engine) DumpTablesToFile(tables []*core.Table, fp string, tp ...core.DbType) error {\n\tf, err := os.Create(fp)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\treturn engine.DumpTables(tables, f, tp...)\n}\n\n// DumpTables dump specify tables to io.Writer\nfunc (engine *Engine) DumpTables(tables []*core.Table, w io.Writer, tp ...core.DbType) error {\n\treturn engine.dumpTables(tables, w, tp...)\n}\n\n// dumpTables dump database all table structs and data to w with specify db type\nfunc (engine *Engine) dumpTables(tables []*core.Table, w io.Writer, tp ...core.DbType) error {\n\tvar dialect core.Dialect\n\tvar distDBName string\n\tif len(tp) == 0 {\n\t\tdialect = engine.dialect\n\t\tdistDBName = string(engine.dialect.DBType())\n\t} else {\n\t\tdialect = core.QueryDialect(tp[0])\n\t\tif dialect == nil {\n\t\t\treturn errors.New(\"Unsupported database type\")\n\t\t}\n\t\tdialect.Init(nil, engine.dialect.URI(), \"\", \"\")\n\t\tdistDBName = string(tp[0])\n\t}\n\n\t_, err := io.WriteString(w, fmt.Sprintf(\"/*Generated by xorm v%s %s, from %s to %s*/\\n\\n\",\n\t\tVersion, time.Now().In(engine.TZLocation).Format(\"2006-01-02 15:04:05\"), engine.dialect.DBType(), strings.ToUpper(distDBName)))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor i, table := range tables {\n\t\tif i > 0 {\n\t\t\t_, err = io.WriteString(w, \"\\n\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\t_, err = io.WriteString(w, dialect.CreateTableSql(table, \"\", table.StoreEngine, \"\")+\";\\n\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor _, index := range table.Indexes {\n\t\t\t_, err = io.WriteString(w, dialect.CreateIndexSql(table.Name, index)+\";\\n\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tcols := table.ColumnsSeq()\n\t\tcolNames := engine.dialect.Quote(strings.Join(cols, engine.dialect.Quote(\", \")))\n\t\tdestColNames := dialect.Quote(strings.Join(cols, dialect.Quote(\", \")))\n\n\t\trows, err := engine.DB().Query(\"SELECT \" + colNames + \" FROM \" + engine.Quote(table.Name))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer rows.Close()\n\n\t\tfor rows.Next() {\n\t\t\tdest := make([]interface{}, len(cols))\n\t\t\terr = rows.ScanSlice(&dest)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t_, err = io.WriteString(w, \"INSERT INTO \"+dialect.Quote(table.Name)+\" (\"+destColNames+\") VALUES (\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tvar temp string\n\t\t\tfor i, d := range dest {\n\t\t\t\tcol := table.GetColumn(cols[i])\n\t\t\t\tif col == nil {\n\t\t\t\t\treturn errors.New(\"unknow column error\")\n\t\t\t\t}\n\n\t\t\t\tif d == nil {\n\t\t\t\t\ttemp += \", NULL\"\n\t\t\t\t} else if col.SQLType.IsText() || col.SQLType.IsTime() {\n\t\t\t\t\tvar v = fmt.Sprintf(\"%s\", d)\n\t\t\t\t\tif strings.HasSuffix(v, \" +0000 UTC\") {\n\t\t\t\t\t\ttemp += fmt.Sprintf(\", '%s'\", v[0:len(v)-len(\" +0000 UTC\")])\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttemp += \", '\" + strings.Replace(v, \"'\", \"''\", -1) + \"'\"\n\t\t\t\t\t}\n\t\t\t\t} else if col.SQLType.IsBlob() {\n\t\t\t\t\tif reflect.TypeOf(d).Kind() == reflect.Slice {\n\t\t\t\t\t\ttemp += fmt.Sprintf(\", %s\", dialect.FormatBytes(d.([]byte)))\n\t\t\t\t\t} else if reflect.TypeOf(d).Kind() == reflect.String {\n\t\t\t\t\t\ttemp += fmt.Sprintf(\", '%s'\", d.(string))\n\t\t\t\t\t}\n\t\t\t\t} else if col.SQLType.IsNumeric() {\n\t\t\t\t\tswitch reflect.TypeOf(d).Kind() {\n\t\t\t\t\tcase reflect.Slice:\n\t\t\t\t\t\tif col.SQLType.Name == core.Bool {\n\t\t\t\t\t\t\ttemp += fmt.Sprintf(\", %v\", strconv.FormatBool(d.([]byte)[0] != byte('0')))\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttemp += fmt.Sprintf(\", %s\", string(d.([]byte)))\n\t\t\t\t\t\t}\n\t\t\t\t\tcase reflect.Int16, reflect.Int8, reflect.Int32, reflect.Int64, reflect.Int:\n\t\t\t\t\t\tif col.SQLType.Name == core.Bool {\n\t\t\t\t\t\t\ttemp += fmt.Sprintf(\", %v\", strconv.FormatBool(reflect.ValueOf(d).Int() > 0))\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttemp += fmt.Sprintf(\", %v\", d)\n\t\t\t\t\t\t}\n\t\t\t\t\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\t\t\t\t\tif col.SQLType.Name == core.Bool {\n\t\t\t\t\t\t\ttemp += fmt.Sprintf(\", %v\", strconv.FormatBool(reflect.ValueOf(d).Uint() > 0))\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttemp += fmt.Sprintf(\", %v\", d)\n\t\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ttemp += fmt.Sprintf(\", %v\", d)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ts := fmt.Sprintf(\"%v\", d)\n\t\t\t\t\tif strings.Contains(s, \":\") || strings.Contains(s, \"-\") {\n\t\t\t\t\t\tif strings.HasSuffix(s, \" +0000 UTC\") {\n\t\t\t\t\t\t\ttemp += fmt.Sprintf(\", '%s'\", s[0:len(s)-len(\" +0000 UTC\")])\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttemp += fmt.Sprintf(\", '%s'\", s)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttemp += fmt.Sprintf(\", %s\", s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t_, err = io.WriteString(w, temp[2:]+\");\\n\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t// FIXME: Hack for postgres\n\t\tif string(dialect.DBType()) == core.POSTGRES && table.AutoIncrColumn() != nil {\n\t\t\t_, err = io.WriteString(w, \"SELECT setval('\"+table.Name+\"_id_seq', COALESCE((SELECT MAX(\"+table.AutoIncrColumn().Name+\") + 1 FROM \"+dialect.Quote(table.Name)+\"), 1), false);\\n\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Cascade use cascade or not\nfunc (engine *Engine) Cascade(trueOrFalse ...bool) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Cascade(trueOrFalse...)\n}\n\n// Where method provide a condition query\nfunc (engine *Engine) Where(query interface{}, args ...interface{}) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Where(query, args...)\n}\n\n// Id will be deprecated, please use ID instead\nfunc (engine *Engine) Id(id interface{}) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Id(id)\n}\n\n// ID method provoide a condition as (id) = ?\nfunc (engine *Engine) ID(id interface{}) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.ID(id)\n}\n\n// Before apply before Processor, affected bean is passed to closure arg\nfunc (engine *Engine) Before(closures func(interface{})) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Before(closures)\n}\n\n// After apply after insert Processor, affected bean is passed to closure arg\nfunc (engine *Engine) After(closures func(interface{})) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.After(closures)\n}\n\n// Charset set charset when create table, only support mysql now\nfunc (engine *Engine) Charset(charset string) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Charset(charset)\n}\n\n// StoreEngine set store engine when create table, only support mysql now\nfunc (engine *Engine) StoreEngine(storeEngine string) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.StoreEngine(storeEngine)\n}\n\n// Distinct use for distinct columns. Caution: when you are using cache,\n// distinct will not be cached because cache system need id,\n// but distinct will not provide id\nfunc (engine *Engine) Distinct(columns ...string) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Distinct(columns...)\n}\n\n// Select customerize your select columns or contents\nfunc (engine *Engine) Select(str string) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Select(str)\n}\n\n// Cols only use the parameters as select or update columns\nfunc (engine *Engine) Cols(columns ...string) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Cols(columns...)\n}\n\n// AllCols indicates that all columns should be use\nfunc (engine *Engine) AllCols() *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.AllCols()\n}\n\n// MustCols specify some columns must use even if they are empty\nfunc (engine *Engine) MustCols(columns ...string) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.MustCols(columns...)\n}\n\n// UseBool xorm automatically retrieve condition according struct, but\n// if struct has bool field, it will ignore them. So use UseBool\n// to tell system to do not ignore them.\n// If no parameters, it will use all the bool field of struct, or\n// it will use parameters's columns\nfunc (engine *Engine) UseBool(columns ...string) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.UseBool(columns...)\n}\n\n// Omit only not use the parameters as select or update columns\nfunc (engine *Engine) Omit(columns ...string) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Omit(columns...)\n}\n\n// Nullable set null when column is zero-value and nullable for update\nfunc (engine *Engine) Nullable(columns ...string) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Nullable(columns...)\n}\n\n// In will generate \"column IN (?, ?)\"\nfunc (engine *Engine) In(column string, args ...interface{}) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.In(column, args...)\n}\n\n// NotIn will generate \"column NOT IN (?, ?)\"\nfunc (engine *Engine) NotIn(column string, args ...interface{}) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.NotIn(column, args...)\n}\n\n// Incr provides a update string like \"column = column + ?\"\nfunc (engine *Engine) Incr(column string, arg ...interface{}) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Incr(column, arg...)\n}\n\n// Decr provides a update string like \"column = column - ?\"\nfunc (engine *Engine) Decr(column string, arg ...interface{}) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Decr(column, arg...)\n}\n\n// SetExpr provides a update string like \"column = {expression}\"\nfunc (engine *Engine) SetExpr(column string, expression interface{}) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.SetExpr(column, expression)\n}\n\n// Table temporarily change the Get, Find, Update's table\nfunc (engine *Engine) Table(tableNameOrBean interface{}) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Table(tableNameOrBean)\n}\n\n// Alias set the table alias\nfunc (engine *Engine) Alias(alias string) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Alias(alias)\n}\n\n// Limit will generate \"LIMIT start, limit\"\nfunc (engine *Engine) Limit(limit int, start ...int) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Limit(limit, start...)\n}\n\n// Desc will generate \"ORDER BY column1 DESC, column2 DESC\"\nfunc (engine *Engine) Desc(colNames ...string) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Desc(colNames...)\n}\n\n// Asc will generate \"ORDER BY column1,column2 Asc\"\n// This method can chainable use.\n//\n//        engine.Desc(\"name\").Asc(\"age\").Find(&users)\n//        // SELECT * FROM user ORDER BY name DESC, age ASC\n//\nfunc (engine *Engine) Asc(colNames ...string) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Asc(colNames...)\n}\n\n// OrderBy will generate \"ORDER BY order\"\nfunc (engine *Engine) OrderBy(order string) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.OrderBy(order)\n}\n\n// Prepare enables prepare statement\nfunc (engine *Engine) Prepare() *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Prepare()\n}\n\n// Join the join_operator should be one of INNER, LEFT OUTER, CROSS etc - this will be prepended to JOIN\nfunc (engine *Engine) Join(joinOperator string, tablename interface{}, condition string, args ...interface{}) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Join(joinOperator, tablename, condition, args...)\n}\n\n// GroupBy generate group by statement\nfunc (engine *Engine) GroupBy(keys string) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.GroupBy(keys)\n}\n\n// Having generate having statement\nfunc (engine *Engine) Having(conditions string) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Having(conditions)\n}\n\n// UnMapType removes the datbase mapper of a type\nfunc (engine *Engine) UnMapType(t reflect.Type) {\n\tengine.mutex.Lock()\n\tdefer engine.mutex.Unlock()\n\tdelete(engine.Tables, t)\n}\n\nfunc (engine *Engine) autoMapType(v reflect.Value) (*core.Table, error) {\n\tt := v.Type()\n\tengine.mutex.Lock()\n\tdefer engine.mutex.Unlock()\n\ttable, ok := engine.Tables[t]\n\tif !ok {\n\t\tvar err error\n\t\ttable, err = engine.mapType(v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tengine.Tables[t] = table\n\t\tif engine.Cacher != nil {\n\t\t\tif v.CanAddr() {\n\t\t\t\tengine.GobRegister(v.Addr().Interface())\n\t\t\t} else {\n\t\t\t\tengine.GobRegister(v.Interface())\n\t\t\t}\n\t\t}\n\t}\n\treturn table, nil\n}\n\n// GobRegister register one struct to gob for cache use\nfunc (engine *Engine) GobRegister(v interface{}) *Engine {\n\tgob.Register(v)\n\treturn engine\n}\n\n// Table table struct\ntype Table struct {\n\t*core.Table\n\tName string\n}\n\n// IsValid if table is valid\nfunc (t *Table) IsValid() bool {\n\treturn t.Table != nil && len(t.Name) > 0\n}\n\n// TableInfo get table info according to bean's content\nfunc (engine *Engine) TableInfo(bean interface{}) *Table {\n\tv := rValue(bean)\n\ttb, err := engine.autoMapType(v)\n\tif err != nil {\n\t\tengine.logger.Error(err)\n\t}\n\treturn &Table{tb, engine.TableName(bean)}\n}\n\nfunc addIndex(indexName string, table *core.Table, col *core.Column, indexType int) {\n\tif index, ok := table.Indexes[indexName]; ok {\n\t\tindex.AddColumn(col.Name)\n\t\tcol.Indexes[index.Name] = indexType\n\t} else {\n\t\tindex := core.NewIndex(indexName, indexType)\n\t\tindex.AddColumn(col.Name)\n\t\ttable.AddIndex(index)\n\t\tcol.Indexes[index.Name] = indexType\n\t}\n}\n\n// TableName table name interface to define customerize table name\ntype TableName interface {\n\tTableName() string\n}\n\nvar (\n\ttpTableName = reflect.TypeOf((*TableName)(nil)).Elem()\n)\n\nfunc (engine *Engine) mapType(v reflect.Value) (*core.Table, error) {\n\tt := v.Type()\n\ttable := core.NewEmptyTable()\n\ttable.Type = t\n\ttable.Name = engine.tbNameForMap(v)\n\n\tvar idFieldColName string\n\tvar hasCacheTag, hasNoCacheTag bool\n\n\tfor i := 0; i < t.NumField(); i++ {\n\t\ttag := t.Field(i).Tag\n\n\t\tormTagStr := tag.Get(engine.TagIdentifier)\n\t\tvar col *core.Column\n\t\tfieldValue := v.Field(i)\n\t\tfieldType := fieldValue.Type()\n\n\t\tif ormTagStr != \"\" {\n\t\t\tcol = &core.Column{\n\t\t\t\tFieldName:       t.Field(i).Name,\n\t\t\t\tNullable:        true,\n\t\t\t\tIsPrimaryKey:    false,\n\t\t\t\tIsAutoIncrement: false,\n\t\t\t\tMapType:         core.TWOSIDES,\n\t\t\t\tIndexes:         make(map[string]int),\n\t\t\t\tDefaultIsEmpty:  true,\n\t\t\t}\n\t\t\ttags := splitTag(ormTagStr)\n\n\t\t\tif len(tags) > 0 {\n\t\t\t\tif tags[0] == \"-\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tvar ctx = tagContext{\n\t\t\t\t\ttable:      table,\n\t\t\t\t\tcol:        col,\n\t\t\t\t\tfieldValue: fieldValue,\n\t\t\t\t\tindexNames: make(map[string]int),\n\t\t\t\t\tengine:     engine,\n\t\t\t\t}\n\n\t\t\t\tif strings.HasPrefix(strings.ToUpper(tags[0]), \"EXTENDS\") {\n\t\t\t\t\tpStart := strings.Index(tags[0], \"(\")\n\t\t\t\t\tif pStart > -1 && strings.HasSuffix(tags[0], \")\") {\n\t\t\t\t\t\tvar tagPrefix = strings.TrimFunc(tags[0][pStart+1:len(tags[0])-1], func(r rune) bool {\n\t\t\t\t\t\t\treturn r == '\\'' || r == '\"'\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tctx.params = []string{tagPrefix}\n\t\t\t\t\t}\n\n\t\t\t\t\tif err := ExtendsTagHandler(&ctx); err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor j, key := range tags {\n\t\t\t\t\tif ctx.ignoreNext {\n\t\t\t\t\t\tctx.ignoreNext = false\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tk := strings.ToUpper(key)\n\t\t\t\t\tctx.tagName = k\n\t\t\t\t\tctx.params = []string{}\n\n\t\t\t\t\tpStart := strings.Index(k, \"(\")\n\t\t\t\t\tif pStart == 0 {\n\t\t\t\t\t\treturn nil, errors.New(\"( could not be the first charactor\")\n\t\t\t\t\t}\n\t\t\t\t\tif pStart > -1 {\n\t\t\t\t\t\tif !strings.HasSuffix(k, \")\") {\n\t\t\t\t\t\t\treturn nil, fmt.Errorf(\"field %s tag %s cannot match ) charactor\", col.FieldName, key)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tctx.tagName = k[:pStart]\n\t\t\t\t\t\tctx.params = strings.Split(key[pStart+1:len(k)-1], \",\")\n\t\t\t\t\t}\n\n\t\t\t\t\tif j > 0 {\n\t\t\t\t\t\tctx.preTag = strings.ToUpper(tags[j-1])\n\t\t\t\t\t}\n\t\t\t\t\tif j < len(tags)-1 {\n\t\t\t\t\t\tctx.nextTag = tags[j+1]\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.nextTag = \"\"\n\t\t\t\t\t}\n\n\t\t\t\t\tif h, ok := engine.tagHandlers[ctx.tagName]; ok {\n\t\t\t\t\t\tif err := h(&ctx); err != nil {\n\t\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif strings.HasPrefix(key, \"'\") && strings.HasSuffix(key, \"'\") {\n\t\t\t\t\t\t\tcol.Name = key[1 : len(key)-1]\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcol.Name = key\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ctx.hasCacheTag {\n\t\t\t\t\t\thasCacheTag = true\n\t\t\t\t\t}\n\t\t\t\t\tif ctx.hasNoCacheTag {\n\t\t\t\t\t\thasNoCacheTag = true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif col.SQLType.Name == \"\" {\n\t\t\t\t\tcol.SQLType = core.Type2SQLType(fieldType)\n\t\t\t\t}\n\t\t\t\tengine.dialect.SqlType(col)\n\t\t\t\tif col.Length == 0 {\n\t\t\t\t\tcol.Length = col.SQLType.DefaultLength\n\t\t\t\t}\n\t\t\t\tif col.Length2 == 0 {\n\t\t\t\t\tcol.Length2 = col.SQLType.DefaultLength2\n\t\t\t\t}\n\t\t\t\tif col.Name == \"\" {\n\t\t\t\t\tcol.Name = engine.ColumnMapper.Obj2Table(t.Field(i).Name)\n\t\t\t\t}\n\n\t\t\t\tif ctx.isUnique {\n\t\t\t\t\tctx.indexNames[col.Name] = core.UniqueType\n\t\t\t\t} else if ctx.isIndex {\n\t\t\t\t\tctx.indexNames[col.Name] = core.IndexType\n\t\t\t\t}\n\n\t\t\t\tfor indexName, indexType := range ctx.indexNames {\n\t\t\t\t\taddIndex(indexName, table, col, indexType)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar sqlType core.SQLType\n\t\t\tif fieldValue.CanAddr() {\n\t\t\t\tif _, ok := fieldValue.Addr().Interface().(core.Conversion); ok {\n\t\t\t\t\tsqlType = core.SQLType{Name: core.Text}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, ok := fieldValue.Interface().(core.Conversion); ok {\n\t\t\t\tsqlType = core.SQLType{Name: core.Text}\n\t\t\t} else {\n\t\t\t\tsqlType = core.Type2SQLType(fieldType)\n\t\t\t}\n\t\t\tcol = core.NewColumn(engine.ColumnMapper.Obj2Table(t.Field(i).Name),\n\t\t\t\tt.Field(i).Name, sqlType, sqlType.DefaultLength,\n\t\t\t\tsqlType.DefaultLength2, true)\n\n\t\t\tif fieldType.Kind() == reflect.Int64 && (strings.ToUpper(col.FieldName) == \"ID\" || strings.HasSuffix(strings.ToUpper(col.FieldName), \".ID\")) {\n\t\t\t\tidFieldColName = col.Name\n\t\t\t}\n\t\t}\n\t\tif col.IsAutoIncrement {\n\t\t\tcol.Nullable = false\n\t\t}\n\n\t\ttable.AddColumn(col)\n\n\t} // end for\n\n\tif idFieldColName != \"\" && len(table.PrimaryKeys) == 0 {\n\t\tcol := table.GetColumn(idFieldColName)\n\t\tcol.IsPrimaryKey = true\n\t\tcol.IsAutoIncrement = true\n\t\tcol.Nullable = false\n\t\ttable.PrimaryKeys = append(table.PrimaryKeys, col.Name)\n\t\ttable.AutoIncrement = col.Name\n\t}\n\n\tif hasCacheTag {\n\t\tif engine.Cacher != nil { // !nash! use engine's cacher if provided\n\t\t\tengine.logger.Info(\"enable cache on table:\", table.Name)\n\t\t\tengine.setCacher(table.Name, engine.Cacher)\n\t\t} else {\n\t\t\tengine.logger.Info(\"enable LRU cache on table:\", table.Name)\n\t\t\tengine.setCacher(table.Name, NewLRUCacher2(NewMemoryStore(), time.Hour, 10000))\n\t\t}\n\t}\n\tif hasNoCacheTag {\n\t\tengine.logger.Info(\"disable cache on table:\", table.Name)\n\t\tengine.setCacher(table.Name, nil)\n\t}\n\n\treturn table, nil\n}\n\n// IsTableEmpty if a table has any reocrd\nfunc (engine *Engine) IsTableEmpty(bean interface{}) (bool, error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.IsTableEmpty(bean)\n}\n\n// IsTableExist if a table is exist\nfunc (engine *Engine) IsTableExist(beanOrTableName interface{}) (bool, error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.IsTableExist(beanOrTableName)\n}\n\n// IdOf get id from one struct\n//\n// Deprecated: use IDOf instead.\nfunc (engine *Engine) IdOf(bean interface{}) core.PK {\n\treturn engine.IDOf(bean)\n}\n\n// IDOf get id from one struct\nfunc (engine *Engine) IDOf(bean interface{}) core.PK {\n\treturn engine.IdOfV(reflect.ValueOf(bean))\n}\n\n// IdOfV get id from one value of struct\n//\n// Deprecated: use IDOfV instead.\nfunc (engine *Engine) IdOfV(rv reflect.Value) core.PK {\n\treturn engine.IDOfV(rv)\n}\n\n// IDOfV get id from one value of struct\nfunc (engine *Engine) IDOfV(rv reflect.Value) core.PK {\n\tpk, err := engine.idOfV(rv)\n\tif err != nil {\n\t\tengine.logger.Error(err)\n\t\treturn nil\n\t}\n\treturn pk\n}\n\nfunc (engine *Engine) idOfV(rv reflect.Value) (core.PK, error) {\n\tv := reflect.Indirect(rv)\n\ttable, err := engine.autoMapType(v)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpk := make([]interface{}, len(table.PrimaryKeys))\n\tfor i, col := range table.PKColumns() {\n\t\tvar err error\n\n\t\tfieldName := col.FieldName\n\t\tfor {\n\t\t\tparts := strings.SplitN(fieldName, \".\", 2)\n\t\t\tif len(parts) == 1 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tv = v.FieldByName(parts[0])\n\t\t\tif v.Kind() == reflect.Ptr {\n\t\t\t\tv = v.Elem()\n\t\t\t}\n\t\t\tif v.Kind() != reflect.Struct {\n\t\t\t\treturn nil, ErrUnSupportedType\n\t\t\t}\n\t\t\tfieldName = parts[1]\n\t\t}\n\n\t\tpkField := v.FieldByName(fieldName)\n\t\tswitch pkField.Kind() {\n\t\tcase reflect.String:\n\t\t\tpk[i], err = engine.idTypeAssertion(col, pkField.String())\n\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\t\tpk[i], err = engine.idTypeAssertion(col, strconv.FormatInt(pkField.Int(), 10))\n\t\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\t\t// id of uint will be converted to int64\n\t\t\tpk[i], err = engine.idTypeAssertion(col, strconv.FormatUint(pkField.Uint(), 10))\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn core.PK(pk), nil\n}\n\nfunc (engine *Engine) idTypeAssertion(col *core.Column, sid string) (interface{}, error) {\n\tif col.SQLType.IsNumeric() {\n\t\tn, err := strconv.ParseInt(sid, 10, 64)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn n, nil\n\t} else if col.SQLType.IsText() {\n\t\treturn sid, nil\n\t} else {\n\t\treturn nil, errors.New(\"not supported\")\n\t}\n}\n\n// CreateIndexes create indexes\nfunc (engine *Engine) CreateIndexes(bean interface{}) error {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.CreateIndexes(bean)\n}\n\n// CreateUniques create uniques\nfunc (engine *Engine) CreateUniques(bean interface{}) error {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.CreateUniques(bean)\n}\n\n// ClearCacheBean if enabled cache, clear the cache bean\nfunc (engine *Engine) ClearCacheBean(bean interface{}, id string) error {\n\ttableName := engine.TableName(bean)\n\tcacher := engine.getCacher(tableName)\n\tif cacher != nil {\n\t\tcacher.ClearIds(tableName)\n\t\tcacher.DelBean(tableName, id)\n\t}\n\treturn nil\n}\n\n// ClearCache if enabled cache, clear some tables' cache\nfunc (engine *Engine) ClearCache(beans ...interface{}) error {\n\tfor _, bean := range beans {\n\t\ttableName := engine.TableName(bean)\n\t\tcacher := engine.getCacher(tableName)\n\t\tif cacher != nil {\n\t\t\tcacher.ClearIds(tableName)\n\t\t\tcacher.ClearBeans(tableName)\n\t\t}\n\t}\n\treturn nil\n}\n\n// Sync the new struct changes to database, this method will automatically add\n// table, column, index, unique. but will not delete or change anything.\n// If you change some field, you should change the database manually.\nfunc (engine *Engine) Sync(beans ...interface{}) error {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\n\tfor _, bean := range beans {\n\t\tv := rValue(bean)\n\t\ttableNameNoSchema := engine.TableName(bean)\n\t\ttable, err := engine.autoMapType(v)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tisExist, err := session.Table(bean).isTableExist(tableNameNoSchema)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !isExist {\n\t\t\terr = session.createTable(bean)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\t/*isEmpty, err := engine.IsEmptyTable(bean)\n\t\t  if err != nil {\n\t\t      return err\n\t\t  }*/\n\t\tvar isEmpty bool\n\t\tif isEmpty {\n\t\t\terr = session.dropTable(bean)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\terr = session.createTable(bean)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tfor _, col := range table.Columns() {\n\t\t\t\tisExist, err := engine.dialect.IsColumnExist(tableNameNoSchema, col.Name)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif !isExist {\n\t\t\t\t\tif err := session.statement.setRefBean(bean); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\terr = session.addColumn(col.Name)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor name, index := range table.Indexes {\n\t\t\t\tif err := session.statement.setRefBean(bean); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif index.Type == core.UniqueType {\n\t\t\t\t\tisExist, err := session.isIndexExist2(tableNameNoSchema, index.Cols, true)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tif !isExist {\n\t\t\t\t\t\tif err := session.statement.setRefBean(bean); err != nil {\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\terr = session.addUnique(tableNameNoSchema, name)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if index.Type == core.IndexType {\n\t\t\t\t\tisExist, err := session.isIndexExist2(tableNameNoSchema, index.Cols, false)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tif !isExist {\n\t\t\t\t\t\tif err := session.statement.setRefBean(bean); err != nil {\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\terr = session.addIndex(tableNameNoSchema, name)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn errors.New(\"unknow index type\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Sync2 synchronize structs to database tables\nfunc (engine *Engine) Sync2(beans ...interface{}) error {\n\ts := engine.NewSession()\n\tdefer s.Close()\n\treturn s.Sync2(beans...)\n}\n\n// CreateTables create tabls according bean\nfunc (engine *Engine) CreateTables(beans ...interface{}) error {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\n\terr := session.Begin()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, bean := range beans {\n\t\terr = session.createTable(bean)\n\t\tif err != nil {\n\t\t\tsession.Rollback()\n\t\t\treturn err\n\t\t}\n\t}\n\treturn session.Commit()\n}\n\n// DropTables drop specify tables\nfunc (engine *Engine) DropTables(beans ...interface{}) error {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\n\terr := session.Begin()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, bean := range beans {\n\t\terr = session.dropTable(bean)\n\t\tif err != nil {\n\t\t\tsession.Rollback()\n\t\t\treturn err\n\t\t}\n\t}\n\treturn session.Commit()\n}\n\n// DropIndexes drop indexes of a table\nfunc (engine *Engine) DropIndexes(bean interface{}) error {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.DropIndexes(bean)\n}\n\n// Exec raw sql\nfunc (engine *Engine) Exec(sqlOrArgs ...interface{}) (sql.Result, error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.Exec(sqlOrArgs...)\n}\n\n// Query a raw sql and return records as []map[string][]byte\nfunc (engine *Engine) Query(sqlOrArgs ...interface{}) (resultsSlice []map[string][]byte, err error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.Query(sqlOrArgs...)\n}\n\n// QueryString runs a raw sql and return records as []map[string]string\nfunc (engine *Engine) QueryString(sqlOrArgs ...interface{}) ([]map[string]string, error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.QueryString(sqlOrArgs...)\n}\n\n// QueryInterface runs a raw sql and return records as []map[string]interface{}\nfunc (engine *Engine) QueryInterface(sqlOrArgs ...interface{}) ([]map[string]interface{}, error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.QueryInterface(sqlOrArgs...)\n}\n\n// Insert one or more records\nfunc (engine *Engine) Insert(beans ...interface{}) (int64, error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.Insert(beans...)\n}\n\n// InsertOne insert only one record\nfunc (engine *Engine) InsertOne(bean interface{}) (int64, error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.InsertOne(bean)\n}\n\n// Update records, bean's non-empty fields are updated contents,\n// condiBean' non-empty filds are conditions\n// CAUTION:\n//        1.bool will defaultly be updated content nor conditions\n//         You should call UseBool if you have bool to use.\n//        2.float32 & float64 may be not inexact as conditions\nfunc (engine *Engine) Update(bean interface{}, condiBeans ...interface{}) (int64, error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.Update(bean, condiBeans...)\n}\n\n// Delete records, bean's non-empty fields are conditions\nfunc (engine *Engine) Delete(bean interface{}) (int64, error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.Delete(bean)\n}\n\n// Get retrieve one record from table, bean's non-empty fields\n// are conditions\nfunc (engine *Engine) Get(bean interface{}) (bool, error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.Get(bean)\n}\n\n// Exist returns true if the record exist otherwise return false\nfunc (engine *Engine) Exist(bean ...interface{}) (bool, error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.Exist(bean...)\n}\n\n// Find retrieve records from table, condiBeans's non-empty fields\n// are conditions. beans could be []Struct, []*Struct, map[int64]Struct\n// map[int64]*Struct\nfunc (engine *Engine) Find(beans interface{}, condiBeans ...interface{}) error {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.Find(beans, condiBeans...)\n}\n\n// FindAndCount find the results and also return the counts\nfunc (engine *Engine) FindAndCount(rowsSlicePtr interface{}, condiBean ...interface{}) (int64, error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.FindAndCount(rowsSlicePtr, condiBean...)\n}\n\n// Iterate record by record handle records from table, bean's non-empty fields\n// are conditions.\nfunc (engine *Engine) Iterate(bean interface{}, fun IterFunc) error {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.Iterate(bean, fun)\n}\n\n// Rows return sql.Rows compatible Rows obj, as a forward Iterator object for iterating record by record, bean's non-empty fields\n// are conditions.\nfunc (engine *Engine) Rows(bean interface{}) (*Rows, error) {\n\tsession := engine.NewSession()\n\treturn session.Rows(bean)\n}\n\n// Count counts the records. bean's non-empty fields are conditions.\nfunc (engine *Engine) Count(bean ...interface{}) (int64, error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.Count(bean...)\n}\n\n// Sum sum the records by some column. bean's non-empty fields are conditions.\nfunc (engine *Engine) Sum(bean interface{}, colName string) (float64, error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.Sum(bean, colName)\n}\n\n// SumInt sum the records by some column. bean's non-empty fields are conditions.\nfunc (engine *Engine) SumInt(bean interface{}, colName string) (int64, error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.SumInt(bean, colName)\n}\n\n// Sums sum the records by some columns. bean's non-empty fields are conditions.\nfunc (engine *Engine) Sums(bean interface{}, colNames ...string) ([]float64, error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.Sums(bean, colNames...)\n}\n\n// SumsInt like Sums but return slice of int64 instead of float64.\nfunc (engine *Engine) SumsInt(bean interface{}, colNames ...string) ([]int64, error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.SumsInt(bean, colNames...)\n}\n\n// ImportFile SQL DDL file\nfunc (engine *Engine) ImportFile(ddlPath string) ([]sql.Result, error) {\n\tfile, err := os.Open(ddlPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\treturn engine.Import(file)\n}\n\n// Import SQL DDL from io.Reader\nfunc (engine *Engine) Import(r io.Reader) ([]sql.Result, error) {\n\tvar results []sql.Result\n\tvar lastError error\n\tscanner := bufio.NewScanner(r)\n\n\tsemiColSpliter := func(data []byte, atEOF bool) (advance int, token []byte, err error) {\n\t\tif atEOF && len(data) == 0 {\n\t\t\treturn 0, nil, nil\n\t\t}\n\t\tif i := bytes.IndexByte(data, ';'); i >= 0 {\n\t\t\treturn i + 1, data[0:i], nil\n\t\t}\n\t\t// If we're at EOF, we have a final, non-terminated line. Return it.\n\t\tif atEOF {\n\t\t\treturn len(data), data, nil\n\t\t}\n\t\t// Request more data.\n\t\treturn 0, nil, nil\n\t}\n\n\tscanner.Split(semiColSpliter)\n\n\tfor scanner.Scan() {\n\t\tquery := strings.Trim(scanner.Text(), \" \\t\\n\\r\")\n\t\tif len(query) > 0 {\n\t\t\tengine.logSQL(query)\n\t\t\tresult, err := engine.DB().Exec(query)\n\t\t\tresults = append(results, result)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn results, lastError\n}\n\n// nowTime return current time\nfunc (engine *Engine) nowTime(col *core.Column) (interface{}, time.Time) {\n\tt := time.Now()\n\tvar tz = engine.DatabaseTZ\n\tif !col.DisableTimeZone && col.TimeZone != nil {\n\t\ttz = col.TimeZone\n\t}\n\treturn engine.formatTime(col.SQLType.Name, t.In(tz)), t.In(engine.TZLocation)\n}\n\nfunc (engine *Engine) formatColTime(col *core.Column, t time.Time) (v interface{}) {\n\tif t.IsZero() {\n\t\tif col.Nullable {\n\t\t\treturn nil\n\t\t}\n\t\treturn \"\"\n\t}\n\n\tif col.TimeZone != nil {\n\t\treturn engine.formatTime(col.SQLType.Name, t.In(col.TimeZone))\n\t}\n\treturn engine.formatTime(col.SQLType.Name, t.In(engine.DatabaseTZ))\n}\n\n// formatTime format time as column type\nfunc (engine *Engine) formatTime(sqlTypeName string, t time.Time) (v interface{}) {\n\tswitch sqlTypeName {\n\tcase core.Time:\n\t\ts := t.Format(\"2006-01-02 15:04:05\") // time.RFC3339\n\t\tv = s[11:19]\n\tcase core.Date:\n\t\tv = t.Format(\"2006-01-02\")\n\tcase core.DateTime, core.TimeStamp:\n\t\tv = t.Format(\"2006-01-02 15:04:05\")\n\tcase core.TimeStampz:\n\t\tif engine.dialect.DBType() == core.MSSQL {\n\t\t\tv = t.Format(\"2006-01-02T15:04:05.9999999Z07:00\")\n\t\t} else {\n\t\t\tv = t.Format(time.RFC3339Nano)\n\t\t}\n\tcase core.BigInt, core.Int:\n\t\tv = t.Unix()\n\tdefault:\n\t\tv = t\n\t}\n\treturn\n}\n\n// GetColumnMapper returns the column name mapper\nfunc (engine *Engine) GetColumnMapper() core.IMapper {\n\treturn engine.ColumnMapper\n}\n\n// GetTableMapper returns the table name mapper\nfunc (engine *Engine) GetTableMapper() core.IMapper {\n\treturn engine.TableMapper\n}\n\n// GetTZLocation returns time zone of the application\nfunc (engine *Engine) GetTZLocation() *time.Location {\n\treturn engine.TZLocation\n}\n\n// SetTZLocation sets time zone of the application\nfunc (engine *Engine) SetTZLocation(tz *time.Location) {\n\tengine.TZLocation = tz\n}\n\n// GetTZDatabase returns time zone of the database\nfunc (engine *Engine) GetTZDatabase() *time.Location {\n\treturn engine.DatabaseTZ\n}\n\n// SetTZDatabase sets time zone of the database\nfunc (engine *Engine) SetTZDatabase(tz *time.Location) {\n\tengine.DatabaseTZ = tz\n}\n\n// SetSchema sets the schema of database\nfunc (engine *Engine) SetSchema(schema string) {\n\tengine.dialect.URI().Schema = schema\n}\n\n// Unscoped always disable struct tag \"deleted\"\nfunc (engine *Engine) Unscoped() *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Unscoped()\n}\n"
        },
        {
          "name": "engine_cond.go",
          "type": "blob",
          "size": 5.947265625,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"database/sql/driver\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n\n\t\"xorm.io/builder\"\n\t\"xorm.io/core\"\n)\n\nfunc (engine *Engine) buildConds(table *core.Table, bean interface{},\n\tincludeVersion bool, includeUpdated bool, includeNil bool,\n\tincludeAutoIncr bool, allUseBool bool, useAllCols bool, unscoped bool,\n\tmustColumnMap map[string]bool, tableName, aliasName string, addedTableName bool) (builder.Cond, error) {\n\tvar conds []builder.Cond\n\tfor _, col := range table.Columns() {\n\t\tif !includeVersion && col.IsVersion {\n\t\t\tcontinue\n\t\t}\n\t\tif !includeUpdated && col.IsUpdated {\n\t\t\tcontinue\n\t\t}\n\t\tif !includeAutoIncr && col.IsAutoIncrement {\n\t\t\tcontinue\n\t\t}\n\n\t\tif engine.dialect.DBType() == core.MSSQL && (col.SQLType.Name == core.Text || col.SQLType.IsBlob() || col.SQLType.Name == core.TimeStampz) {\n\t\t\tcontinue\n\t\t}\n\t\tif col.SQLType.IsJson() {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar colName string\n\t\tif addedTableName {\n\t\t\tvar nm = tableName\n\t\t\tif len(aliasName) > 0 {\n\t\t\t\tnm = aliasName\n\t\t\t}\n\t\t\tcolName = engine.Quote(nm) + \".\" + engine.Quote(col.Name)\n\t\t} else {\n\t\t\tcolName = engine.Quote(col.Name)\n\t\t}\n\n\t\tfieldValuePtr, err := col.ValueOf(bean)\n\t\tif err != nil {\n\t\t\tif !strings.Contains(err.Error(), \"is not valid\") {\n\t\t\t\tengine.logger.Warn(err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif col.IsDeleted && !unscoped { // tag \"deleted\" is enabled\n\t\t\tconds = append(conds, engine.CondDeleted(colName))\n\t\t}\n\n\t\tfieldValue := *fieldValuePtr\n\t\tif fieldValue.Interface() == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tfieldType := reflect.TypeOf(fieldValue.Interface())\n\t\trequiredField := useAllCols\n\n\t\tif b, ok := getFlagForColumn(mustColumnMap, col); ok {\n\t\t\tif b {\n\t\t\t\trequiredField = true\n\t\t\t} else {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif fieldType.Kind() == reflect.Ptr {\n\t\t\tif fieldValue.IsNil() {\n\t\t\t\tif includeNil {\n\t\t\t\t\tconds = append(conds, builder.Eq{colName: nil})\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t} else if !fieldValue.IsValid() {\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\t// dereference ptr type to instance type\n\t\t\t\tfieldValue = fieldValue.Elem()\n\t\t\t\tfieldType = reflect.TypeOf(fieldValue.Interface())\n\t\t\t\trequiredField = true\n\t\t\t}\n\t\t}\n\n\t\tvar val interface{}\n\t\tswitch fieldType.Kind() {\n\t\tcase reflect.Bool:\n\t\t\tif allUseBool || requiredField {\n\t\t\t\tval = fieldValue.Interface()\n\t\t\t} else {\n\t\t\t\t// if a bool in a struct, it will not be as a condition because it default is false,\n\t\t\t\t// please use Where() instead\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase reflect.String:\n\t\t\tif !requiredField && fieldValue.String() == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// for MyString, should convert to string or panic\n\t\t\tif fieldType.String() != reflect.String.String() {\n\t\t\t\tval = fieldValue.String()\n\t\t\t} else {\n\t\t\t\tval = fieldValue.Interface()\n\t\t\t}\n\t\tcase reflect.Int8, reflect.Int16, reflect.Int, reflect.Int32, reflect.Int64:\n\t\t\tif !requiredField && fieldValue.Int() == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tval = fieldValue.Interface()\n\t\tcase reflect.Float32, reflect.Float64:\n\t\t\tif !requiredField && fieldValue.Float() == 0.0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tval = fieldValue.Interface()\n\t\tcase reflect.Uint8, reflect.Uint16, reflect.Uint, reflect.Uint32, reflect.Uint64:\n\t\t\tif !requiredField && fieldValue.Uint() == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tt := int64(fieldValue.Uint())\n\t\t\tval = reflect.ValueOf(&t).Interface()\n\t\tcase reflect.Struct:\n\t\t\tif fieldType.ConvertibleTo(core.TimeType) {\n\t\t\t\tt := fieldValue.Convert(core.TimeType).Interface().(time.Time)\n\t\t\t\tif !requiredField && (t.IsZero() || !fieldValue.IsValid()) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tval = engine.formatColTime(col, t)\n\t\t\t} else if _, ok := reflect.New(fieldType).Interface().(core.Conversion); ok {\n\t\t\t\tcontinue\n\t\t\t} else if valNul, ok := fieldValue.Interface().(driver.Valuer); ok {\n\t\t\t\tval, _ = valNul.Value()\n\t\t\t\tif val == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif col.SQLType.IsJson() {\n\t\t\t\t\tif col.SQLType.IsText() {\n\t\t\t\t\t\tbytes, err := DefaultJSONHandler.Marshal(fieldValue.Interface())\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tengine.logger.Error(err)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tval = string(bytes)\n\t\t\t\t\t} else if col.SQLType.IsBlob() {\n\t\t\t\t\t\tvar bytes []byte\n\t\t\t\t\t\tvar err error\n\t\t\t\t\t\tbytes, err = DefaultJSONHandler.Marshal(fieldValue.Interface())\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tengine.logger.Error(err)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tval = bytes\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tengine.autoMapType(fieldValue)\n\t\t\t\t\tif table, ok := engine.Tables[fieldValue.Type()]; ok {\n\t\t\t\t\t\tif len(table.PrimaryKeys) == 1 {\n\t\t\t\t\t\t\tpkField := reflect.Indirect(fieldValue).FieldByName(table.PKColumns()[0].FieldName)\n\t\t\t\t\t\t\t// fix non-int pk issues\n\t\t\t\t\t\t\t//if pkField.Int() != 0 {\n\t\t\t\t\t\t\tif pkField.IsValid() && !isZero(pkField.Interface()) {\n\t\t\t\t\t\t\t\tval = pkField.Interface()\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//TODO: how to handler?\n\t\t\t\t\t\t\treturn nil, fmt.Errorf(\"not supported %v as %v\", fieldValue.Interface(), table.PrimaryKeys)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tval = fieldValue.Interface()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcase reflect.Array:\n\t\t\tcontinue\n\t\tcase reflect.Slice, reflect.Map:\n\t\t\tif fieldValue == reflect.Zero(fieldType) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif fieldValue.IsNil() || !fieldValue.IsValid() || fieldValue.Len() == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif col.SQLType.IsText() {\n\t\t\t\tbytes, err := DefaultJSONHandler.Marshal(fieldValue.Interface())\n\t\t\t\tif err != nil {\n\t\t\t\t\tengine.logger.Error(err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tval = string(bytes)\n\t\t\t} else if col.SQLType.IsBlob() {\n\t\t\t\tvar bytes []byte\n\t\t\t\tvar err error\n\t\t\t\tif (fieldType.Kind() == reflect.Array || fieldType.Kind() == reflect.Slice) &&\n\t\t\t\t\tfieldType.Elem().Kind() == reflect.Uint8 {\n\t\t\t\t\tif fieldValue.Len() > 0 {\n\t\t\t\t\t\tval = fieldValue.Bytes()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbytes, err = DefaultJSONHandler.Marshal(fieldValue.Interface())\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tengine.logger.Error(err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tval = bytes\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tdefault:\n\t\t\tval = fieldValue.Interface()\n\t\t}\n\n\t\tconds = append(conds, builder.Eq{colName: val})\n\t}\n\n\treturn builder.And(conds...), nil\n}\n"
        },
        {
          "name": "engine_context.go",
          "type": "blob",
          "size": 0.728515625,
          "content": "// Copyright 2019 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build go1.8\n\npackage xorm\n\nimport \"context\"\n\n// Context creates a session with the context\nfunc (engine *Engine) Context(ctx context.Context) *Session {\n\tsession := engine.NewSession()\n\tsession.isAutoClose = true\n\treturn session.Context(ctx)\n}\n\n// SetDefaultContext set the default context\nfunc (engine *Engine) SetDefaultContext(ctx context.Context) {\n\tengine.defaultContext = ctx\n}\n\n// PingContext tests if database is alive\nfunc (engine *Engine) PingContext(ctx context.Context) error {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\treturn session.PingContext(ctx)\n}\n"
        },
        {
          "name": "engine_context_test.go",
          "type": "blob",
          "size": 0.591796875,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build go1.8\n\npackage xorm\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestPingContext(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tctx, canceled := context.WithTimeout(context.Background(), time.Nanosecond)\n\tdefer canceled()\n\n\ttime.Sleep(time.Nanosecond)\n\n\terr := testEngine.(*Engine).PingContext(ctx)\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"context deadline exceeded\")\n}\n"
        },
        {
          "name": "engine_group.go",
          "type": "blob",
          "size": 5.048828125,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"xorm.io/core\"\n)\n\n// EngineGroup defines an engine group\ntype EngineGroup struct {\n\t*Engine\n\tslaves []*Engine\n\tpolicy GroupPolicy\n}\n\n// NewEngineGroup creates a new engine group\nfunc NewEngineGroup(args1 interface{}, args2 interface{}, policies ...GroupPolicy) (*EngineGroup, error) {\n\tvar eg EngineGroup\n\tif len(policies) > 0 {\n\t\teg.policy = policies[0]\n\t} else {\n\t\teg.policy = RoundRobinPolicy()\n\t}\n\n\tdriverName, ok1 := args1.(string)\n\tconns, ok2 := args2.([]string)\n\tif ok1 && ok2 {\n\t\tengines := make([]*Engine, len(conns))\n\t\tfor i, conn := range conns {\n\t\t\tengine, err := NewEngine(driverName, conn)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tengine.engineGroup = &eg\n\t\t\tengines[i] = engine\n\t\t}\n\n\t\teg.Engine = engines[0]\n\t\teg.slaves = engines[1:]\n\t\treturn &eg, nil\n\t}\n\n\tmaster, ok3 := args1.(*Engine)\n\tslaves, ok4 := args2.([]*Engine)\n\tif ok3 && ok4 {\n\t\tmaster.engineGroup = &eg\n\t\tfor i := 0; i < len(slaves); i++ {\n\t\t\tslaves[i].engineGroup = &eg\n\t\t}\n\t\teg.Engine = master\n\t\teg.slaves = slaves\n\t\treturn &eg, nil\n\t}\n\treturn nil, ErrParamsType\n}\n\n// Close the engine\nfunc (eg *EngineGroup) Close() error {\n\terr := eg.Engine.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor i := 0; i < len(eg.slaves); i++ {\n\t\terr := eg.slaves[i].Close()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Context returned a group session\nfunc (eg *EngineGroup) Context(ctx context.Context) *Session {\n\tsess := eg.NewSession()\n\tsess.isAutoClose = true\n\treturn sess.Context(ctx)\n}\n\n// NewSession returned a group session\nfunc (eg *EngineGroup) NewSession() *Session {\n\tsess := eg.Engine.NewSession()\n\tsess.sessionType = groupSession\n\treturn sess\n}\n\n// Master returns the master engine\nfunc (eg *EngineGroup) Master() *Engine {\n\treturn eg.Engine\n}\n\n// Ping tests if database is alive\nfunc (eg *EngineGroup) Ping() error {\n\tif err := eg.Engine.Ping(); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, slave := range eg.slaves {\n\t\tif err := slave.Ping(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// SetColumnMapper set the column name mapping rule\nfunc (eg *EngineGroup) SetColumnMapper(mapper core.IMapper) {\n\teg.Engine.ColumnMapper = mapper\n\tfor i := 0; i < len(eg.slaves); i++ {\n\t\teg.slaves[i].ColumnMapper = mapper\n\t}\n}\n\n// SetConnMaxLifetime sets the maximum amount of time a connection may be reused.\nfunc (eg *EngineGroup) SetConnMaxLifetime(d time.Duration) {\n\teg.Engine.SetConnMaxLifetime(d)\n\tfor i := 0; i < len(eg.slaves); i++ {\n\t\teg.slaves[i].SetConnMaxLifetime(d)\n\t}\n}\n\n// SetDefaultCacher set the default cacher\nfunc (eg *EngineGroup) SetDefaultCacher(cacher core.Cacher) {\n\teg.Engine.SetDefaultCacher(cacher)\n\tfor i := 0; i < len(eg.slaves); i++ {\n\t\teg.slaves[i].SetDefaultCacher(cacher)\n\t}\n}\n\n// SetLogger set the new logger\nfunc (eg *EngineGroup) SetLogger(logger core.ILogger) {\n\teg.Engine.SetLogger(logger)\n\tfor i := 0; i < len(eg.slaves); i++ {\n\t\teg.slaves[i].SetLogger(logger)\n\t}\n}\n\n// SetLogLevel sets the logger level\nfunc (eg *EngineGroup) SetLogLevel(level core.LogLevel) {\n\teg.Engine.SetLogLevel(level)\n\tfor i := 0; i < len(eg.slaves); i++ {\n\t\teg.slaves[i].SetLogLevel(level)\n\t}\n}\n\n// SetMapper set the name mapping rules\nfunc (eg *EngineGroup) SetMapper(mapper core.IMapper) {\n\teg.Engine.SetMapper(mapper)\n\tfor i := 0; i < len(eg.slaves); i++ {\n\t\teg.slaves[i].SetMapper(mapper)\n\t}\n}\n\n// SetMaxIdleConns set the max idle connections on pool, default is 2\nfunc (eg *EngineGroup) SetMaxIdleConns(conns int) {\n\teg.Engine.db.SetMaxIdleConns(conns)\n\tfor i := 0; i < len(eg.slaves); i++ {\n\t\teg.slaves[i].db.SetMaxIdleConns(conns)\n\t}\n}\n\n// SetMaxOpenConns is only available for go 1.2+\nfunc (eg *EngineGroup) SetMaxOpenConns(conns int) {\n\teg.Engine.db.SetMaxOpenConns(conns)\n\tfor i := 0; i < len(eg.slaves); i++ {\n\t\teg.slaves[i].db.SetMaxOpenConns(conns)\n\t}\n}\n\n// SetPolicy set the group policy\nfunc (eg *EngineGroup) SetPolicy(policy GroupPolicy) *EngineGroup {\n\teg.policy = policy\n\treturn eg\n}\n\n// SetTableMapper set the table name mapping rule\nfunc (eg *EngineGroup) SetTableMapper(mapper core.IMapper) {\n\teg.Engine.TableMapper = mapper\n\tfor i := 0; i < len(eg.slaves); i++ {\n\t\teg.slaves[i].TableMapper = mapper\n\t}\n}\n\n// ShowExecTime show SQL statement and execute time or not on logger if log level is great than INFO\nfunc (eg *EngineGroup) ShowExecTime(show ...bool) {\n\teg.Engine.ShowExecTime(show...)\n\tfor i := 0; i < len(eg.slaves); i++ {\n\t\teg.slaves[i].ShowExecTime(show...)\n\t}\n}\n\n// ShowSQL show SQL statement or not on logger if log level is great than INFO\nfunc (eg *EngineGroup) ShowSQL(show ...bool) {\n\teg.Engine.ShowSQL(show...)\n\tfor i := 0; i < len(eg.slaves); i++ {\n\t\teg.slaves[i].ShowSQL(show...)\n\t}\n}\n\n// Slave returns one of the physical databases which is a slave according the policy\nfunc (eg *EngineGroup) Slave() *Engine {\n\tswitch len(eg.slaves) {\n\tcase 0:\n\t\treturn eg.Engine\n\tcase 1:\n\t\treturn eg.slaves[0]\n\t}\n\treturn eg.policy.Slave(eg)\n}\n\n// Slaves returns all the slaves\nfunc (eg *EngineGroup) Slaves() []*Engine {\n\treturn eg.slaves\n}\n"
        },
        {
          "name": "engine_group_policy.go",
          "type": "blob",
          "size": 2.5693359375,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\n// GroupPolicy is be used by chosing the current slave from slaves\ntype GroupPolicy interface {\n\tSlave(*EngineGroup) *Engine\n}\n\n// GroupPolicyHandler should be used when a function is a GroupPolicy\ntype GroupPolicyHandler func(*EngineGroup) *Engine\n\n// Slave implements the chosen of slaves\nfunc (h GroupPolicyHandler) Slave(eg *EngineGroup) *Engine {\n\treturn h(eg)\n}\n\n// RandomPolicy implmentes randomly chose the slave of slaves\nfunc RandomPolicy() GroupPolicyHandler {\n\tvar r = rand.New(rand.NewSource(time.Now().UnixNano()))\n\treturn func(g *EngineGroup) *Engine {\n\t\treturn g.Slaves()[r.Intn(len(g.Slaves()))]\n\t}\n}\n\n// WeightRandomPolicy implmentes randomly chose the slave of slaves\nfunc WeightRandomPolicy(weights []int) GroupPolicyHandler {\n\tvar rands = make([]int, 0, len(weights))\n\tfor i := 0; i < len(weights); i++ {\n\t\tfor n := 0; n < weights[i]; n++ {\n\t\t\trands = append(rands, i)\n\t\t}\n\t}\n\tvar r = rand.New(rand.NewSource(time.Now().UnixNano()))\n\n\treturn func(g *EngineGroup) *Engine {\n\t\tvar slaves = g.Slaves()\n\t\tidx := rands[r.Intn(len(rands))]\n\t\tif idx >= len(slaves) {\n\t\t\tidx = len(slaves) - 1\n\t\t}\n\t\treturn slaves[idx]\n\t}\n}\n\nfunc RoundRobinPolicy() GroupPolicyHandler {\n\tvar pos = -1\n\tvar lock sync.Mutex\n\treturn func(g *EngineGroup) *Engine {\n\t\tvar slaves = g.Slaves()\n\n\t\tlock.Lock()\n\t\tdefer lock.Unlock()\n\t\tpos++\n\t\tif pos >= len(slaves) {\n\t\t\tpos = 0\n\t\t}\n\n\t\treturn slaves[pos]\n\t}\n}\n\nfunc WeightRoundRobinPolicy(weights []int) GroupPolicyHandler {\n\tvar rands = make([]int, 0, len(weights))\n\tfor i := 0; i < len(weights); i++ {\n\t\tfor n := 0; n < weights[i]; n++ {\n\t\t\trands = append(rands, i)\n\t\t}\n\t}\n\tvar pos = -1\n\tvar lock sync.Mutex\n\n\treturn func(g *EngineGroup) *Engine {\n\t\tvar slaves = g.Slaves()\n\t\tlock.Lock()\n\t\tdefer lock.Unlock()\n\t\tpos++\n\t\tif pos >= len(rands) {\n\t\t\tpos = 0\n\t\t}\n\n\t\tidx := rands[pos]\n\t\tif idx >= len(slaves) {\n\t\t\tidx = len(slaves) - 1\n\t\t}\n\t\treturn slaves[idx]\n\t}\n}\n\n// LeastConnPolicy implements GroupPolicy, every time will get the least connections slave\nfunc LeastConnPolicy() GroupPolicyHandler {\n\treturn func(g *EngineGroup) *Engine {\n\t\tvar slaves = g.Slaves()\n\t\tconnections := 0\n\t\tidx := 0\n\t\tfor i := 0; i < len(slaves); i++ {\n\t\t\topenConnections := slaves[i].DB().Stats().OpenConnections\n\t\t\tif i == 0 {\n\t\t\t\tconnections = openConnections\n\t\t\t\tidx = i\n\t\t\t} else if openConnections <= connections {\n\t\t\t\tconnections = openConnections\n\t\t\t\tidx = i\n\t\t\t}\n\t\t}\n\t\treturn slaves[idx]\n\t}\n}\n"
        },
        {
          "name": "engine_table.go",
          "type": "blob",
          "size": 2.7333984375,
          "content": "// Copyright 2018 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"xorm.io/core\"\n)\n\n// tbNameWithSchema will automatically add schema prefix on table name\nfunc (engine *Engine) tbNameWithSchema(v string) string {\n\t// Add schema name as prefix of table name.\n\t// Only for postgres database.\n\tif engine.dialect.DBType() == core.POSTGRES &&\n\t\tengine.dialect.URI().Schema != \"\" &&\n\t\tengine.dialect.URI().Schema != postgresPublicSchema &&\n\t\tstrings.Index(v, \".\") == -1 {\n\t\treturn engine.dialect.URI().Schema + \".\" + v\n\t}\n\treturn v\n}\n\n// TableName returns table name with schema prefix if has\nfunc (engine *Engine) TableName(bean interface{}, includeSchema ...bool) string {\n\ttbName := engine.tbNameNoSchema(bean)\n\tif len(includeSchema) > 0 && includeSchema[0] {\n\t\ttbName = engine.tbNameWithSchema(tbName)\n\t}\n\n\treturn tbName\n}\n\n// tbName get some table's table name\nfunc (session *Session) tbNameNoSchema(table *core.Table) string {\n\tif len(session.statement.AltTableName) > 0 {\n\t\treturn session.statement.AltTableName\n\t}\n\n\treturn table.Name\n}\n\nfunc (engine *Engine) tbNameForMap(v reflect.Value) string {\n\tif v.Type().Implements(tpTableName) {\n\t\treturn v.Interface().(TableName).TableName()\n\t}\n\tif v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t\tif v.Type().Implements(tpTableName) {\n\t\t\treturn v.Interface().(TableName).TableName()\n\t\t}\n\t}\n\n\treturn engine.TableMapper.Obj2Table(v.Type().Name())\n}\n\nfunc (engine *Engine) tbNameNoSchema(tablename interface{}) string {\n\tswitch tablename.(type) {\n\tcase []string:\n\t\tt := tablename.([]string)\n\t\tif len(t) > 1 {\n\t\t\treturn fmt.Sprintf(\"%v AS %v\", engine.Quote(t[0]), engine.Quote(t[1]))\n\t\t} else if len(t) == 1 {\n\t\t\treturn engine.Quote(t[0])\n\t\t}\n\tcase []interface{}:\n\t\tt := tablename.([]interface{})\n\t\tl := len(t)\n\t\tvar table string\n\t\tif l > 0 {\n\t\t\tf := t[0]\n\t\t\tswitch f.(type) {\n\t\t\tcase string:\n\t\t\t\ttable = f.(string)\n\t\t\tcase TableName:\n\t\t\t\ttable = f.(TableName).TableName()\n\t\t\tdefault:\n\t\t\t\tv := rValue(f)\n\t\t\t\tt := v.Type()\n\t\t\t\tif t.Kind() == reflect.Struct {\n\t\t\t\t\ttable = engine.tbNameForMap(v)\n\t\t\t\t} else {\n\t\t\t\t\ttable = engine.Quote(fmt.Sprintf(\"%v\", f))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif l > 1 {\n\t\t\treturn fmt.Sprintf(\"%v AS %v\", engine.Quote(table),\n\t\t\t\tengine.Quote(fmt.Sprintf(\"%v\", t[1])))\n\t\t} else if l == 1 {\n\t\t\treturn engine.Quote(table)\n\t\t}\n\tcase TableName:\n\t\treturn tablename.(TableName).TableName()\n\tcase string:\n\t\treturn tablename.(string)\n\tcase reflect.Value:\n\t\tv := tablename.(reflect.Value)\n\t\treturn engine.tbNameForMap(v)\n\tdefault:\n\t\tv := rValue(tablename)\n\t\tt := v.Type()\n\t\tif t.Kind() == reflect.Struct {\n\t\t\treturn engine.tbNameForMap(v)\n\t\t}\n\t\treturn engine.Quote(fmt.Sprintf(\"%v\", tablename))\n\t}\n\treturn \"\"\n}\n"
        },
        {
          "name": "engine_table_test.go",
          "type": "blob",
          "size": 0.6103515625,
          "content": "// Copyright 2018 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype MCC struct {\n\tID          int64  `xorm:\"pk 'id'\"`\n\tCode        string `xorm:\"'code'\"`\n\tDescription string `xorm:\"'description'\"`\n}\n\nfunc (mcc *MCC) TableName() string {\n\treturn \"mcc\"\n}\n\nfunc TestTableName1(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tassert.EqualValues(t, \"mcc\", testEngine.TableName(new(MCC)))\n\tassert.EqualValues(t, \"mcc\", testEngine.TableName(\"mcc\"))\n}\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 1.5703125,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nvar (\n\t// ErrParamsType params error\n\tErrParamsType = errors.New(\"Params type error\")\n\t// ErrTableNotFound table not found error\n\tErrTableNotFound = errors.New(\"Table not found\")\n\t// ErrUnSupportedType unsupported error\n\tErrUnSupportedType = errors.New(\"Unsupported type error\")\n\t// ErrNotExist record does not exist error\n\tErrNotExist = errors.New(\"Record does not exist\")\n\t// ErrCacheFailed cache failed error\n\tErrCacheFailed = errors.New(\"Cache failed\")\n\t// ErrNeedDeletedCond delete needs less one condition error\n\tErrNeedDeletedCond = errors.New(\"Delete action needs at least one condition\")\n\t// ErrNotImplemented not implemented\n\tErrNotImplemented = errors.New(\"Not implemented\")\n\t// ErrConditionType condition type unsupported\n\tErrConditionType = errors.New(\"Unsupported condition type\")\n\t// ErrUnSupportedSQLType parameter of SQL is not supported\n\tErrUnSupportedSQLType = errors.New(\"unsupported sql type\")\n)\n\n// ErrFieldIsNotExist columns does not exist\ntype ErrFieldIsNotExist struct {\n\tFieldName string\n\tTableName string\n}\n\nfunc (e ErrFieldIsNotExist) Error() string {\n\treturn fmt.Sprintf(\"field %s is not valid on table %s\", e.FieldName, e.TableName)\n}\n\n// ErrFieldIsNotValid is not valid\ntype ErrFieldIsNotValid struct {\n\tFieldName string\n\tTableName string\n}\n\nfunc (e ErrFieldIsNotValid) Error() string {\n\treturn fmt.Sprintf(\"field %s is not valid on table %s\", e.FieldName, e.TableName)\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "gen_reserved.sh",
          "type": "blob",
          "size": 0.12109375,
          "content": "#!/bin/bash\nif [ -f $1 ];then\n    cat $1| awk '{printf(\"\\\"\"$1\"\\\":true,\\n\")}' \nelse\n    echo \"argument $1 if not a file!\"\nfi\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.6865234375,
          "content": "module github.com/go-xorm/xorm\n\ngo 1.11\n\nrequire (\n\tgithub.com/cockroachdb/apd v1.1.0 // indirect\n\tgithub.com/denisenkom/go-mssqldb v0.0.0-20190707035753-2be1aa521ff4\n\tgithub.com/go-sql-driver/mysql v1.4.1\n\tgithub.com/gofrs/uuid v3.2.0+incompatible // indirect\n\tgithub.com/jackc/fake v0.0.0-20150926172116-812a484cc733 // indirect\n\tgithub.com/jackc/pgx v3.6.0+incompatible\n\tgithub.com/lib/pq v1.0.0\n\tgithub.com/mattn/go-sqlite3 v1.10.0\n\tgithub.com/pkg/errors v0.8.1 // indirect\n\tgithub.com/shopspring/decimal v0.0.0-20180709203117-cd690d0c9e24 // indirect\n\tgithub.com/stretchr/testify v1.4.0\n\tgithub.com/ziutek/mymysql v1.5.4\n\txorm.io/builder v0.3.6\n\txorm.io/core v0.7.2-0.20190928055935-90aeac8d08eb\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 16.462890625,
          "content": "cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.37.4 h1:glPeL3BQJsbF6aIIYfZizMwc5LTYz250bDMjttbBGAU=\ncloud.google.com/go v0.37.4/go.mod h1:NHPJ89PdicEuT9hdPXMROBD91xc5uRDxsMtSB16k7hw=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/Shopify/sarama v1.19.0/go.mod h1:FVkBWblsNy7DGZRfXLU0O9RCGt5g3g3yEuWXgklEdEo=\ngithub.com/Shopify/toxiproxy v2.1.4+incompatible/go.mod h1:OXgGpZ6Cli1/URJOF1DMxUHB2q5Ap20/P/eIdh4G0pI=\ngithub.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=\ngithub.com/apache/thrift v0.12.0/go.mod h1:cp2SuWMxlEZw2r+iP2GNCdIi4C1qmUzdZFSVb+bacwQ=\ngithub.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/cockroachdb/apd v1.1.0 h1:3LFP3629v+1aKXU5Q37mxmRxX/pIu1nijXydLShEq5I=\ngithub.com/cockroachdb/apd v1.1.0/go.mod h1:8Sl8LxpKi29FqWXR16WEFZRNSz3SoPzUzeMeY4+DwBQ=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/denisenkom/go-mssqldb v0.0.0-20190707035753-2be1aa521ff4 h1:YcpmyvADGYw5LqMnHqSkyIELsHCGF6PkrmM31V8rF7o=\ngithub.com/denisenkom/go-mssqldb v0.0.0-20190707035753-2be1aa521ff4/go.mod h1:zAg7JM8CkOJ43xKXIj7eRO9kmWm/TW578qo+oDO6tuM=\ngithub.com/eapache/go-resiliency v1.1.0/go.mod h1:kFI+JgMyC7bLPUVY133qvEBtVayf5mFgVsvEsIPBvNs=\ngithub.com/eapache/go-xerial-snappy v0.0.0-20180814174437-776d5712da21/go.mod h1:+020luEh2TKB4/GOp8oxxtq0Daoen/Cii55CzbTV6DU=\ngithub.com/eapache/queue v1.1.0/go.mod h1:6eCeP0CKFpHLu8blIFXhExK/dRa7WDZfr6jVFPTqq+I=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/go-kit/kit v0.8.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=\ngithub.com/go-logfmt/logfmt v0.3.0/go.mod h1:Qt1PoO58o5twSAckw1HlFXLmHsOX5/0LbT9GBnD5lWE=\ngithub.com/go-sql-driver/mysql v1.4.1 h1:g24URVg0OFbNUTx9qqY1IRZ9D9z3iPyi5zKhQZpNwpA=\ngithub.com/go-sql-driver/mysql v1.4.1/go.mod h1:zAC/RDZ24gD3HViQzih4MyKcchzm+sOG5ZlKdlhCg5w=\ngithub.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=\ngithub.com/go-xorm/sqlfiddle v0.0.0-20180821085327-62ce714f951a h1:9wScpmSP5A3Bk8V3XHWUcJmYTh+ZnlHVyc+A4oZYS3Y=\ngithub.com/go-xorm/sqlfiddle v0.0.0-20180821085327-62ce714f951a/go.mod h1:56xuuqnHyryaerycW3BfssRdxQstACi0Epw/yC5E2xM=\ngithub.com/gofrs/uuid v3.2.0+incompatible h1:y12jRkkFxsd7GpqdSZ+/KCs/fJbqpEXSGd4+jfEaewE=\ngithub.com/gofrs/uuid v3.2.0+incompatible/go.mod h1:b2aQJv3Z4Fp6yNu3cdSllBxTCLRxnplIgP/c0N/04lM=\ngithub.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/gogo/protobuf v1.2.0/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/snappy v0.0.0-20180518054509-2e65f85255db/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=\ngithub.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/go-cmp v0.2.0 h1:+dTQ8DZQJz0Mb/HjFlkptS1FeQ4cWSnN941F8aEG4SQ=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=\ngithub.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\ngithub.com/googleapis/gax-go/v2 v2.0.4/go.mod h1:0Wqv26UfaUD9n4G6kQubkQ+KchISgw+vpHVxEJEs9eg=\ngithub.com/gorilla/context v1.1.1/go.mod h1:kBGZzfjB9CEq2AlWe17Uuf7NDRt0dE0s8S51q0aT7Yg=\ngithub.com/gorilla/mux v1.6.2/go.mod h1:1lud6UwP+6orDFRuTfBEV8e9/aOM/c4fVVCaMa2zaAs=\ngithub.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=\ngithub.com/jackc/fake v0.0.0-20150926172116-812a484cc733 h1:vr3AYkKovP8uR8AvSGGUK1IDqRa5lAAvEkZG1LKaCRc=\ngithub.com/jackc/fake v0.0.0-20150926172116-812a484cc733/go.mod h1:WrMFNQdiFJ80sQsxDoMokWK1W5TQtxBFNpzWTD84ibQ=\ngithub.com/jackc/pgx v3.6.0+incompatible h1:bJeo4JdVbDAW8KB2m8XkFeo8CPipREoG37BwEoKGz+Q=\ngithub.com/jackc/pgx v3.6.0+incompatible/go.mod h1:0ZGrqGqkRlliWnWB4zKnWtjbSWbGkVEFm4TeybAXq+I=\ngithub.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=\ngithub.com/julienschmidt/httprouter v1.2.0/go.mod h1:SYymIcj16QtmaHHD7aYtjjsJG7VTCxuUUipMqKk8s4w=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFBFZlji/RkVcI2GknAs/DXo4wKdlNEc=\ngithub.com/lib/pq v1.0.0 h1:X5PMW56eZitiTeO7tKzZxFCSpbFZJtkMMooicw2us9A=\ngithub.com/lib/pq v1.0.0/go.mod h1:5WUZQaWbwv1U+lTReE5YruASi9Al49XbQIvNi/34Woo=\ngithub.com/mattn/go-sqlite3 v1.10.0 h1:jbhqpg7tQe4SupckyijYiy0mJJ/pRyHvXf7JdWK860o=\ngithub.com/mattn/go-sqlite3 v1.10.0/go.mod h1:FPy6KqzDD04eiIsT53CuJW3U88zkxoIYsOqkbpncsNc=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=\ngithub.com/mwitkow/go-conntrack v0.0.0-20161129095857-cc309e4a2223/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=\ngithub.com/onsi/ginkgo v1.6.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo v1.7.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/gomega v1.4.3/go.mod h1:ex+gbHU/CVuBBDIJjb2X0qEXbFg53c61hWP/1CpauHY=\ngithub.com/openzipkin/zipkin-go v0.1.6/go.mod h1:QgAqvLzwWbR/WpD4A3cGpPtJrZXNIiJc5AZX7/PBEpw=\ngithub.com/pierrec/lz4 v2.0.5+incompatible/go.mod h1:pdkljMzZIN41W+lC3N2tnIh5sFi+IEE17M5jbnwPHcY=\ngithub.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.8.1 h1:iURUrRGxPUNPdy5/HRSm+Yj6okJ6UtLINN0Q9M4+h3I=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_golang v0.9.1/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=\ngithub.com/prometheus/client_golang v0.9.3-0.20190127221311-3c4408c8b829/go.mod h1:p2iRAGwDERtqlqzRXnrOVns+ignqQo//hLXqYxZYVNs=\ngithub.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/client_model v0.0.0-20190115171406-56726106282f/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/common v0.2.0/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=\ngithub.com/prometheus/procfs v0.0.0-20181005140218-185b4288413d/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/prometheus/procfs v0.0.0-20190117184657-bf6a532e95b1/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/rcrowley/go-metrics v0.0.0-20181016184325-3113b8401b8a/go.mod h1:bCqnVzQkZxMG4s8nGwiZ5l3QUCyqpo9Y+/ZMZ9VjZe4=\ngithub.com/shopspring/decimal v0.0.0-20180709203117-cd690d0c9e24 h1:pntxY8Ary0t43dCZ5dqY4YTJCObLY1kIXl0uzMv+7DE=\ngithub.com/shopspring/decimal v0.0.0-20180709203117-cd690d0c9e24/go.mod h1:M+9NzErvs504Cn4c5DxATwIqPbtswREoFCre64PpcG4=\ngithub.com/sirupsen/logrus v1.2.0/go.mod h1:LxeOpSwHxABJmUn/MG1IvRgCAasNZTLOkJPxbbu5VWo=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.3.0 h1:TivCn/peBQ7UY8ooIcPgZFpTNSz0Q2U6UrFlUfqbe0Q=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.4.0 h1:2E4SXV/wtOkTonXsotYi4li6zVWxYlZuYNCXe9XRJyk=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/ziutek/mymysql v1.5.4 h1:GB0qdRGsTwQSBVYuVShFBKaXSnSnYYC2d9knnE1LHFs=\ngithub.com/ziutek/mymysql v1.5.4/go.mod h1:LMSpPZ6DbqWFxNCHW77HeMg9I646SAhApZ/wKdgO/C0=\ngo.opencensus.io v0.20.1/go.mod h1:6WKK9ahsWS3RSO+PY9ZHZUfv2irvY6gN279GOPZjmmk=\ngolang.org/x/crypto v0.0.0-20180904163835-0709b304e793/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190325154230-a5d413f7728c h1:Vj5n4GlwjmQteupaxJ9+0FNOmBrHfq7vN4btdGoDZgI=\ngolang.org/x/crypto v0.0.0-20190325154230-a5d413f7728c/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190605123033-f99c8df09eb5 h1:58fnuSXlxZmFdJyvtTFVmVhcMLU6v5fEb/ok4wyqtNU=\ngolang.org/x/crypto v0.0.0-20190605123033-f99c8df09eb5/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/lint v0.0.0-20190301231843-5614ed5bae6f/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190125091013-d26f9f9a57f3/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181122145206-62eef0e2fa9b/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190602015325-4c4f7f33c9ed/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.2 h1:tW2bmiBqwgJj/UpqtC8EpXEZVYOwU0yG4iWbprSVAcs=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/tools v0.0.0-20180828015842-6cd1fcedba52/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.0.0-20190312170243-e65039ee4138/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190606050223-4d9ae51c2468/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngoogle.golang.org/api v0.3.1/go.mod h1:6wY9I6uQWHQ8EM57III9mq/AjF+i8G65rmVagqKMtkk=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.6.0 h1:Tfd7cKwKbFRsI8RMAD3oqqw7JPFRrvFlOsfbgVkjOOw=\ngoogle.golang.org/appengine v1.6.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20190307195333-5fe7a883aa19/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190404172233-64821d5d2107/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/grpc v1.17.0/go.mod h1:6QZJwpn2B+Zp71q/5VxRsJ6NXXVCE5NRUHRo+f3cWCs=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=\ngopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\nhonnef.co/go/tools v0.0.0-20180728063816-88497007e858/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nxorm.io/builder v0.3.6 h1:ha28mQ2M+TFx96Hxo+iq6tQgnkC9IZkM6D8w9sKHHF8=\nxorm.io/builder v0.3.6/go.mod h1:LEFAPISnRzG+zxaxj2vPicRwz67BdhFreKg8yv8/TgU=\nxorm.io/core v0.7.0 h1:hKxuOKWZNeiFQsSuGet/KV8HZ788hclvAl+7azx3tkM=\nxorm.io/core v0.7.0/go.mod h1:TuOJjIVa7e3w/rN8tDcAvuLBMtwzdHPbyOzE6Gk1EUI=\nxorm.io/core v0.7.1 h1:I6x6Q6dYb67aDEoYFWr2t8UcKIYjJPyCHS+aXuj5V0Y=\nxorm.io/core v0.7.1/go.mod h1:jJfd0UAEzZ4t87nbQYtVjmqpIODugN6PD2D9E+dJvdM=\nxorm.io/core v0.7.2-0.20190928055935-90aeac8d08eb h1:msX3zG3BPl8Ti+LDzP33/9K7BzO/WqFXk610K1kYKfo=\nxorm.io/core v0.7.2-0.20190928055935-90aeac8d08eb/go.mod h1:jJfd0UAEzZ4t87nbQYtVjmqpIODugN6PD2D9E+dJvdM=\n"
        },
        {
          "name": "helpers.go",
          "type": "blob",
          "size": 6.8056640625,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"xorm.io/core\"\n)\n\n// str2PK convert string value to primary key value according to tp\nfunc str2PKValue(s string, tp reflect.Type) (reflect.Value, error) {\n\tvar err error\n\tvar result interface{}\n\tvar defReturn = reflect.Zero(tp)\n\n\tswitch tp.Kind() {\n\tcase reflect.Int:\n\t\tresult, err = strconv.Atoi(s)\n\t\tif err != nil {\n\t\t\treturn defReturn, fmt.Errorf(\"convert %s as int: %s\", s, err.Error())\n\t\t}\n\tcase reflect.Int8:\n\t\tx, err := strconv.Atoi(s)\n\t\tif err != nil {\n\t\t\treturn defReturn, fmt.Errorf(\"convert %s as int8: %s\", s, err.Error())\n\t\t}\n\t\tresult = int8(x)\n\tcase reflect.Int16:\n\t\tx, err := strconv.Atoi(s)\n\t\tif err != nil {\n\t\t\treturn defReturn, fmt.Errorf(\"convert %s as int16: %s\", s, err.Error())\n\t\t}\n\t\tresult = int16(x)\n\tcase reflect.Int32:\n\t\tx, err := strconv.Atoi(s)\n\t\tif err != nil {\n\t\t\treturn defReturn, fmt.Errorf(\"convert %s as int32: %s\", s, err.Error())\n\t\t}\n\t\tresult = int32(x)\n\tcase reflect.Int64:\n\t\tresult, err = strconv.ParseInt(s, 10, 64)\n\t\tif err != nil {\n\t\t\treturn defReturn, fmt.Errorf(\"convert %s as int64: %s\", s, err.Error())\n\t\t}\n\tcase reflect.Uint:\n\t\tx, err := strconv.ParseUint(s, 10, 64)\n\t\tif err != nil {\n\t\t\treturn defReturn, fmt.Errorf(\"convert %s as uint: %s\", s, err.Error())\n\t\t}\n\t\tresult = uint(x)\n\tcase reflect.Uint8:\n\t\tx, err := strconv.ParseUint(s, 10, 64)\n\t\tif err != nil {\n\t\t\treturn defReturn, fmt.Errorf(\"convert %s as uint8: %s\", s, err.Error())\n\t\t}\n\t\tresult = uint8(x)\n\tcase reflect.Uint16:\n\t\tx, err := strconv.ParseUint(s, 10, 64)\n\t\tif err != nil {\n\t\t\treturn defReturn, fmt.Errorf(\"convert %s as uint16: %s\", s, err.Error())\n\t\t}\n\t\tresult = uint16(x)\n\tcase reflect.Uint32:\n\t\tx, err := strconv.ParseUint(s, 10, 64)\n\t\tif err != nil {\n\t\t\treturn defReturn, fmt.Errorf(\"convert %s as uint32: %s\", s, err.Error())\n\t\t}\n\t\tresult = uint32(x)\n\tcase reflect.Uint64:\n\t\tresult, err = strconv.ParseUint(s, 10, 64)\n\t\tif err != nil {\n\t\t\treturn defReturn, fmt.Errorf(\"convert %s as uint64: %s\", s, err.Error())\n\t\t}\n\tcase reflect.String:\n\t\tresult = s\n\tdefault:\n\t\treturn defReturn, errors.New(\"unsupported convert type\")\n\t}\n\treturn reflect.ValueOf(result).Convert(tp), nil\n}\n\nfunc str2PK(s string, tp reflect.Type) (interface{}, error) {\n\tv, err := str2PKValue(s, tp)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn v.Interface(), nil\n}\n\nfunc splitTag(tag string) (tags []string) {\n\ttag = strings.TrimSpace(tag)\n\tvar hasQuote = false\n\tvar lastIdx = 0\n\tfor i, t := range tag {\n\t\tif t == '\\'' {\n\t\t\thasQuote = !hasQuote\n\t\t} else if t == ' ' {\n\t\t\tif lastIdx < i && !hasQuote {\n\t\t\t\ttags = append(tags, strings.TrimSpace(tag[lastIdx:i]))\n\t\t\t\tlastIdx = i + 1\n\t\t\t}\n\t\t}\n\t}\n\tif lastIdx < len(tag) {\n\t\ttags = append(tags, strings.TrimSpace(tag[lastIdx:]))\n\t}\n\treturn\n}\n\ntype zeroable interface {\n\tIsZero() bool\n}\n\nfunc isZero(k interface{}) bool {\n\tswitch k.(type) {\n\tcase int:\n\t\treturn k.(int) == 0\n\tcase int8:\n\t\treturn k.(int8) == 0\n\tcase int16:\n\t\treturn k.(int16) == 0\n\tcase int32:\n\t\treturn k.(int32) == 0\n\tcase int64:\n\t\treturn k.(int64) == 0\n\tcase uint:\n\t\treturn k.(uint) == 0\n\tcase uint8:\n\t\treturn k.(uint8) == 0\n\tcase uint16:\n\t\treturn k.(uint16) == 0\n\tcase uint32:\n\t\treturn k.(uint32) == 0\n\tcase uint64:\n\t\treturn k.(uint64) == 0\n\tcase float32:\n\t\treturn k.(float32) == 0\n\tcase float64:\n\t\treturn k.(float64) == 0\n\tcase bool:\n\t\treturn k.(bool) == false\n\tcase string:\n\t\treturn k.(string) == \"\"\n\tcase zeroable:\n\t\treturn k.(zeroable).IsZero()\n\t}\n\treturn false\n}\n\nfunc isStructZero(v reflect.Value) bool {\n\tif !v.IsValid() {\n\t\treturn true\n\t}\n\n\tfor i := 0; i < v.NumField(); i++ {\n\t\tfield := v.Field(i)\n\t\tswitch field.Kind() {\n\t\tcase reflect.Ptr:\n\t\t\tfield = field.Elem()\n\t\t\tfallthrough\n\t\tcase reflect.Struct:\n\t\t\tif !isStructZero(field) {\n\t\t\t\treturn false\n\t\t\t}\n\t\tdefault:\n\t\t\tif field.CanInterface() && !isZero(field.Interface()) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\nfunc isArrayValueZero(v reflect.Value) bool {\n\tif !v.IsValid() || v.Len() == 0 {\n\t\treturn true\n\t}\n\n\tfor i := 0; i < v.Len(); i++ {\n\t\tif !isZero(v.Index(i).Interface()) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc int64ToIntValue(id int64, tp reflect.Type) reflect.Value {\n\tvar v interface{}\n\tkind := tp.Kind()\n\n\tif kind == reflect.Ptr {\n\t\tkind = tp.Elem().Kind()\n\t}\n\n\tswitch kind {\n\tcase reflect.Int16:\n\t\ttemp := int16(id)\n\t\tv = &temp\n\tcase reflect.Int32:\n\t\ttemp := int32(id)\n\t\tv = &temp\n\tcase reflect.Int:\n\t\ttemp := int(id)\n\t\tv = &temp\n\tcase reflect.Int64:\n\t\ttemp := id\n\t\tv = &temp\n\tcase reflect.Uint16:\n\t\ttemp := uint16(id)\n\t\tv = &temp\n\tcase reflect.Uint32:\n\t\ttemp := uint32(id)\n\t\tv = &temp\n\tcase reflect.Uint64:\n\t\ttemp := uint64(id)\n\t\tv = &temp\n\tcase reflect.Uint:\n\t\ttemp := uint(id)\n\t\tv = &temp\n\t}\n\n\tif tp.Kind() == reflect.Ptr {\n\t\treturn reflect.ValueOf(v).Convert(tp)\n\t}\n\treturn reflect.ValueOf(v).Elem().Convert(tp)\n}\n\nfunc int64ToInt(id int64, tp reflect.Type) interface{} {\n\treturn int64ToIntValue(id, tp).Interface()\n}\n\nfunc isPKZero(pk core.PK) bool {\n\tfor _, k := range pk {\n\t\tif isZero(k) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc indexNoCase(s, sep string) int {\n\treturn strings.Index(strings.ToLower(s), strings.ToLower(sep))\n}\n\nfunc splitNoCase(s, sep string) []string {\n\tidx := indexNoCase(s, sep)\n\tif idx < 0 {\n\t\treturn []string{s}\n\t}\n\treturn strings.Split(s, s[idx:idx+len(sep)])\n}\n\nfunc splitNNoCase(s, sep string, n int) []string {\n\tidx := indexNoCase(s, sep)\n\tif idx < 0 {\n\t\treturn []string{s}\n\t}\n\treturn strings.SplitN(s, s[idx:idx+len(sep)], n)\n}\n\nfunc makeArray(elem string, count int) []string {\n\tres := make([]string, count)\n\tfor i := 0; i < count; i++ {\n\t\tres[i] = elem\n\t}\n\treturn res\n}\n\nfunc rValue(bean interface{}) reflect.Value {\n\treturn reflect.Indirect(reflect.ValueOf(bean))\n}\n\nfunc rType(bean interface{}) reflect.Type {\n\tsliceValue := reflect.Indirect(reflect.ValueOf(bean))\n\t// return reflect.TypeOf(sliceValue.Interface())\n\treturn sliceValue.Type()\n}\n\nfunc structName(v reflect.Type) string {\n\tfor v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\treturn v.Name()\n}\n\nfunc sliceEq(left, right []string) bool {\n\tif len(left) != len(right) {\n\t\treturn false\n\t}\n\tsort.Sort(sort.StringSlice(left))\n\tsort.Sort(sort.StringSlice(right))\n\tfor i := 0; i < len(left); i++ {\n\t\tif left[i] != right[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc indexName(tableName, idxName string) string {\n\treturn fmt.Sprintf(\"IDX_%v_%v\", tableName, idxName)\n}\n\nfunc eraseAny(value string, strToErase ...string) string {\n\tif len(strToErase) == 0 {\n\t\treturn value\n\t}\n\tvar replaceSeq []string\n\tfor _, s := range strToErase {\n\t\treplaceSeq = append(replaceSeq, s, \"\")\n\t}\n\n\treplacer := strings.NewReplacer(replaceSeq...)\n\n\treturn replacer.Replace(value)\n}\n\nfunc quoteColumns(cols []string, quoteFunc func(string) string, sep string) string {\n\tfor i := range cols {\n\t\tcols[i] = quoteFunc(cols[i])\n\t}\n\treturn strings.Join(cols, sep+\" \")\n}\n"
        },
        {
          "name": "helpers_test.go",
          "type": "blob",
          "size": 0.7392578125,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestEraseAny(t *testing.T) {\n\traw := \"SELECT * FROM `table`.[table_name]\"\n\tassert.EqualValues(t, raw, eraseAny(raw))\n\tassert.EqualValues(t, \"SELECT * FROM table.[table_name]\", eraseAny(raw, \"`\"))\n\tassert.EqualValues(t, \"SELECT * FROM table.table_name\", eraseAny(raw, \"`\", \"[\", \"]\"))\n}\n\nfunc TestQuoteColumns(t *testing.T) {\n\tcols := []string{\"f1\", \"f2\", \"f3\"}\n\tquoteFunc := func(value string) string {\n\t\treturn \"[\" + value + \"]\"\n\t}\n\n\tassert.EqualValues(t, \"[f1], [f2], [f3]\", quoteColumns(cols, quoteFunc, \",\"))\n}\n"
        },
        {
          "name": "helpler_time.go",
          "type": "blob",
          "size": 0.4609375,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport \"time\"\n\nconst (\n\tzeroTime0 = \"0000-00-00 00:00:00\"\n\tzeroTime1 = \"0001-01-01 00:00:00\"\n)\n\nfunc formatTime(t time.Time) string {\n\treturn t.Format(\"2006-01-02 15:04:05\")\n}\n\nfunc isTimeZero(t time.Time) bool {\n\treturn t.IsZero() || formatTime(t) == zeroTime0 ||\n\t\tformatTime(t) == zeroTime1\n}\n"
        },
        {
          "name": "interface.go",
          "type": "blob",
          "size": 3.8525390625,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"reflect\"\n\t\"time\"\n\n\t\"xorm.io/core\"\n)\n\n// Interface defines the interface which Engine, EngineGroup and Session will implementate.\ntype Interface interface {\n\tAllCols() *Session\n\tAlias(alias string) *Session\n\tAsc(colNames ...string) *Session\n\tBufferSize(size int) *Session\n\tCols(columns ...string) *Session\n\tCount(...interface{}) (int64, error)\n\tCreateIndexes(bean interface{}) error\n\tCreateUniques(bean interface{}) error\n\tDecr(column string, arg ...interface{}) *Session\n\tDesc(...string) *Session\n\tDelete(interface{}) (int64, error)\n\tDistinct(columns ...string) *Session\n\tDropIndexes(bean interface{}) error\n\tExec(sqlOrArgs ...interface{}) (sql.Result, error)\n\tExist(bean ...interface{}) (bool, error)\n\tFind(interface{}, ...interface{}) error\n\tFindAndCount(interface{}, ...interface{}) (int64, error)\n\tGet(interface{}) (bool, error)\n\tGroupBy(keys string) *Session\n\tID(interface{}) *Session\n\tIn(string, ...interface{}) *Session\n\tIncr(column string, arg ...interface{}) *Session\n\tInsert(...interface{}) (int64, error)\n\tInsertOne(interface{}) (int64, error)\n\tIsTableEmpty(bean interface{}) (bool, error)\n\tIsTableExist(beanOrTableName interface{}) (bool, error)\n\tIterate(interface{}, IterFunc) error\n\tLimit(int, ...int) *Session\n\tMustCols(columns ...string) *Session\n\tNoAutoCondition(...bool) *Session\n\tNotIn(string, ...interface{}) *Session\n\tJoin(joinOperator string, tablename interface{}, condition string, args ...interface{}) *Session\n\tOmit(columns ...string) *Session\n\tOrderBy(order string) *Session\n\tPing() error\n\tQuery(sqlOrArgs ...interface{}) (resultsSlice []map[string][]byte, err error)\n\tQueryInterface(sqlOrArgs ...interface{}) ([]map[string]interface{}, error)\n\tQueryString(sqlOrArgs ...interface{}) ([]map[string]string, error)\n\tRows(bean interface{}) (*Rows, error)\n\tSetExpr(string, interface{}) *Session\n\tSQL(interface{}, ...interface{}) *Session\n\tSum(bean interface{}, colName string) (float64, error)\n\tSumInt(bean interface{}, colName string) (int64, error)\n\tSums(bean interface{}, colNames ...string) ([]float64, error)\n\tSumsInt(bean interface{}, colNames ...string) ([]int64, error)\n\tTable(tableNameOrBean interface{}) *Session\n\tUnscoped() *Session\n\tUpdate(bean interface{}, condiBeans ...interface{}) (int64, error)\n\tUseBool(...string) *Session\n\tWhere(interface{}, ...interface{}) *Session\n}\n\n// EngineInterface defines the interface which Engine, EngineGroup will implementate.\ntype EngineInterface interface {\n\tInterface\n\n\tBefore(func(interface{})) *Session\n\tCharset(charset string) *Session\n\tClearCache(...interface{}) error\n\tContext(context.Context) *Session\n\tCreateTables(...interface{}) error\n\tDBMetas() ([]*core.Table, error)\n\tDialect() core.Dialect\n\tDropTables(...interface{}) error\n\tDumpAllToFile(fp string, tp ...core.DbType) error\n\tGetCacher(string) core.Cacher\n\tGetColumnMapper() core.IMapper\n\tGetDefaultCacher() core.Cacher\n\tGetTableMapper() core.IMapper\n\tGetTZDatabase() *time.Location\n\tGetTZLocation() *time.Location\n\tMapCacher(interface{}, core.Cacher) error\n\tNewSession() *Session\n\tNoAutoTime() *Session\n\tQuote(string) string\n\tSetCacher(string, core.Cacher)\n\tSetConnMaxLifetime(time.Duration)\n\tSetDefaultCacher(core.Cacher)\n\tSetLogger(logger core.ILogger)\n\tSetLogLevel(core.LogLevel)\n\tSetMapper(core.IMapper)\n\tSetMaxOpenConns(int)\n\tSetMaxIdleConns(int)\n\tSetSchema(string)\n\tSetTZDatabase(tz *time.Location)\n\tSetTZLocation(tz *time.Location)\n\tShowExecTime(...bool)\n\tShowSQL(show ...bool)\n\tSync(...interface{}) error\n\tSync2(...interface{}) error\n\tStoreEngine(storeEngine string) *Session\n\tTableInfo(bean interface{}) *Table\n\tTableName(interface{}, ...bool) string\n\tUnMapType(reflect.Type)\n}\n\nvar (\n\t_ Interface       = &Session{}\n\t_ EngineInterface = &Engine{}\n\t_ EngineInterface = &EngineGroup{}\n)\n"
        },
        {
          "name": "json.go",
          "type": "blob",
          "size": 0.7890625,
          "content": "// Copyright 2019 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport \"encoding/json\"\n\n// JSONInterface represents an interface to handle json data\ntype JSONInterface interface {\n\tMarshal(v interface{}) ([]byte, error)\n\tUnmarshal(data []byte, v interface{}) error\n}\n\nvar (\n\t// DefaultJSONHandler default json handler\n\tDefaultJSONHandler JSONInterface = StdJSON{}\n)\n\n// StdJSON implements JSONInterface via encoding/json\ntype StdJSON struct{}\n\n// Marshal implements JSONInterface\nfunc (StdJSON) Marshal(v interface{}) ([]byte, error) {\n\treturn json.Marshal(v)\n}\n\n// Unmarshal implements JSONInterface\nfunc (StdJSON) Unmarshal(data []byte, v interface{}) error {\n\treturn json.Unmarshal(data, v)\n}\n"
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 4.431640625,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\n\t\"xorm.io/core\"\n)\n\n// default log options\nconst (\n\tDEFAULT_LOG_PREFIX = \"[xorm]\"\n\tDEFAULT_LOG_FLAG   = log.Ldate | log.Lmicroseconds\n\tDEFAULT_LOG_LEVEL  = core.LOG_DEBUG\n)\n\nvar _ core.ILogger = DiscardLogger{}\n\n// DiscardLogger don't log implementation for core.ILogger\ntype DiscardLogger struct{}\n\n// Debug empty implementation\nfunc (DiscardLogger) Debug(v ...interface{}) {}\n\n// Debugf empty implementation\nfunc (DiscardLogger) Debugf(format string, v ...interface{}) {}\n\n// Error empty implementation\nfunc (DiscardLogger) Error(v ...interface{}) {}\n\n// Errorf empty implementation\nfunc (DiscardLogger) Errorf(format string, v ...interface{}) {}\n\n// Info empty implementation\nfunc (DiscardLogger) Info(v ...interface{}) {}\n\n// Infof empty implementation\nfunc (DiscardLogger) Infof(format string, v ...interface{}) {}\n\n// Warn empty implementation\nfunc (DiscardLogger) Warn(v ...interface{}) {}\n\n// Warnf empty implementation\nfunc (DiscardLogger) Warnf(format string, v ...interface{}) {}\n\n// Level empty implementation\nfunc (DiscardLogger) Level() core.LogLevel {\n\treturn core.LOG_UNKNOWN\n}\n\n// SetLevel empty implementation\nfunc (DiscardLogger) SetLevel(l core.LogLevel) {}\n\n// ShowSQL empty implementation\nfunc (DiscardLogger) ShowSQL(show ...bool) {}\n\n// IsShowSQL empty implementation\nfunc (DiscardLogger) IsShowSQL() bool {\n\treturn false\n}\n\n// SimpleLogger is the default implment of core.ILogger\ntype SimpleLogger struct {\n\tDEBUG   *log.Logger\n\tERR     *log.Logger\n\tINFO    *log.Logger\n\tWARN    *log.Logger\n\tlevel   core.LogLevel\n\tshowSQL bool\n}\n\nvar _ core.ILogger = &SimpleLogger{}\n\n// NewSimpleLogger use a special io.Writer as logger output\nfunc NewSimpleLogger(out io.Writer) *SimpleLogger {\n\treturn NewSimpleLogger2(out, DEFAULT_LOG_PREFIX, DEFAULT_LOG_FLAG)\n}\n\n// NewSimpleLogger2 let you customrize your logger prefix and flag\nfunc NewSimpleLogger2(out io.Writer, prefix string, flag int) *SimpleLogger {\n\treturn NewSimpleLogger3(out, prefix, flag, DEFAULT_LOG_LEVEL)\n}\n\n// NewSimpleLogger3 let you customrize your logger prefix and flag and logLevel\nfunc NewSimpleLogger3(out io.Writer, prefix string, flag int, l core.LogLevel) *SimpleLogger {\n\treturn &SimpleLogger{\n\t\tDEBUG: log.New(out, fmt.Sprintf(\"%s [debug] \", prefix), flag),\n\t\tERR:   log.New(out, fmt.Sprintf(\"%s [error] \", prefix), flag),\n\t\tINFO:  log.New(out, fmt.Sprintf(\"%s [info]  \", prefix), flag),\n\t\tWARN:  log.New(out, fmt.Sprintf(\"%s [warn]  \", prefix), flag),\n\t\tlevel: l,\n\t}\n}\n\n// Error implement core.ILogger\nfunc (s *SimpleLogger) Error(v ...interface{}) {\n\tif s.level <= core.LOG_ERR {\n\t\ts.ERR.Output(2, fmt.Sprint(v...))\n\t}\n\treturn\n}\n\n// Errorf implement core.ILogger\nfunc (s *SimpleLogger) Errorf(format string, v ...interface{}) {\n\tif s.level <= core.LOG_ERR {\n\t\ts.ERR.Output(2, fmt.Sprintf(format, v...))\n\t}\n\treturn\n}\n\n// Debug implement core.ILogger\nfunc (s *SimpleLogger) Debug(v ...interface{}) {\n\tif s.level <= core.LOG_DEBUG {\n\t\ts.DEBUG.Output(2, fmt.Sprint(v...))\n\t}\n\treturn\n}\n\n// Debugf implement core.ILogger\nfunc (s *SimpleLogger) Debugf(format string, v ...interface{}) {\n\tif s.level <= core.LOG_DEBUG {\n\t\ts.DEBUG.Output(2, fmt.Sprintf(format, v...))\n\t}\n\treturn\n}\n\n// Info implement core.ILogger\nfunc (s *SimpleLogger) Info(v ...interface{}) {\n\tif s.level <= core.LOG_INFO {\n\t\ts.INFO.Output(2, fmt.Sprint(v...))\n\t}\n\treturn\n}\n\n// Infof implement core.ILogger\nfunc (s *SimpleLogger) Infof(format string, v ...interface{}) {\n\tif s.level <= core.LOG_INFO {\n\t\ts.INFO.Output(2, fmt.Sprintf(format, v...))\n\t}\n\treturn\n}\n\n// Warn implement core.ILogger\nfunc (s *SimpleLogger) Warn(v ...interface{}) {\n\tif s.level <= core.LOG_WARNING {\n\t\ts.WARN.Output(2, fmt.Sprint(v...))\n\t}\n\treturn\n}\n\n// Warnf implement core.ILogger\nfunc (s *SimpleLogger) Warnf(format string, v ...interface{}) {\n\tif s.level <= core.LOG_WARNING {\n\t\ts.WARN.Output(2, fmt.Sprintf(format, v...))\n\t}\n\treturn\n}\n\n// Level implement core.ILogger\nfunc (s *SimpleLogger) Level() core.LogLevel {\n\treturn s.level\n}\n\n// SetLevel implement core.ILogger\nfunc (s *SimpleLogger) SetLevel(l core.LogLevel) {\n\ts.level = l\n\treturn\n}\n\n// ShowSQL implement core.ILogger\nfunc (s *SimpleLogger) ShowSQL(show ...bool) {\n\tif len(show) == 0 {\n\t\ts.showSQL = true\n\t\treturn\n\t}\n\ts.showSQL = show[0]\n}\n\n// IsShowSQL implement core.ILogger\nfunc (s *SimpleLogger) IsShowSQL() bool {\n\treturn s.showSQL\n}\n"
        },
        {
          "name": "migrate",
          "type": "tree",
          "content": null
        },
        {
          "name": "pg_reserved.txt",
          "type": "blob",
          "size": 30.6513671875,
          "content": "A\t \tnon-reserved\tnon-reserved\t \nABORT\tnon-reserved\t \t \t \nABS\t \treserved\treserved\t \nABSENT\t \tnon-reserved\tnon-reserved\t \nABSOLUTE\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nACCESS\tnon-reserved\t \t \t \nACCORDING\t \tnon-reserved\tnon-reserved\t \nACTION\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nADA\t \tnon-reserved\tnon-reserved\tnon-reserved\nADD\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nADMIN\tnon-reserved\tnon-reserved\tnon-reserved\t \nAFTER\tnon-reserved\tnon-reserved\tnon-reserved\t \nAGGREGATE\tnon-reserved\t \t \t \nALL\treserved\treserved\treserved\treserved\nALLOCATE\t \treserved\treserved\treserved\nALSO\tnon-reserved\t \t \t \nALTER\tnon-reserved\treserved\treserved\treserved\nALWAYS\tnon-reserved\tnon-reserved\tnon-reserved\t \nANALYSE\treserved\t \t \t \nANALYZE\treserved\t \t \t \nAND\treserved\treserved\treserved\treserved\nANY\treserved\treserved\treserved\treserved\nARE\t \treserved\treserved\treserved\nARRAY\treserved\treserved\treserved\t \nARRAY_AGG\t \treserved\treserved\t \nARRAY_MAX_CARDINALITY\t \treserved\t \t \nAS\treserved\treserved\treserved\treserved\nASC\treserved\tnon-reserved\tnon-reserved\treserved\nASENSITIVE\t \treserved\treserved\t \nASSERTION\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nASSIGNMENT\tnon-reserved\tnon-reserved\tnon-reserved\t \nASYMMETRIC\treserved\treserved\treserved\t \nAT\tnon-reserved\treserved\treserved\treserved\nATOMIC\t \treserved\treserved\t \nATTRIBUTE\tnon-reserved\tnon-reserved\tnon-reserved\t \nATTRIBUTES\t \tnon-reserved\tnon-reserved\t \nAUTHORIZATION\treserved (can be function or type)\treserved\treserved\treserved\nAVG\t \treserved\treserved\treserved\nBACKWARD\tnon-reserved\t \t \t \nBASE64\t \tnon-reserved\tnon-reserved\t \nBEFORE\tnon-reserved\tnon-reserved\tnon-reserved\t \nBEGIN\tnon-reserved\treserved\treserved\treserved\nBEGIN_FRAME\t \treserved\t \t \nBEGIN_PARTITION\t \treserved\t \t \nBERNOULLI\t \tnon-reserved\tnon-reserved\t \nBETWEEN\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nBIGINT\tnon-reserved (cannot be function or type)\treserved\treserved\t \nBINARY\treserved (can be function or type)\treserved\treserved\t \nBIT\tnon-reserved (cannot be function or type)\t \t \treserved\nBIT_LENGTH\t \t \t \treserved\nBLOB\t \treserved\treserved\t \nBLOCKED\t \tnon-reserved\tnon-reserved\t \nBOM\t \tnon-reserved\tnon-reserved\t \nBOOLEAN\tnon-reserved (cannot be function or type)\treserved\treserved\t \nBOTH\treserved\treserved\treserved\treserved\nBREADTH\t \tnon-reserved\tnon-reserved\t \nBY\tnon-reserved\treserved\treserved\treserved\nC\t \tnon-reserved\tnon-reserved\tnon-reserved\nCACHE\tnon-reserved\t \t \t \nCALL\t \treserved\treserved\t \nCALLED\tnon-reserved\treserved\treserved\t \nCARDINALITY\t \treserved\treserved\t \nCASCADE\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nCASCADED\tnon-reserved\treserved\treserved\treserved\nCASE\treserved\treserved\treserved\treserved\nCAST\treserved\treserved\treserved\treserved\nCATALOG\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nCATALOG_NAME\t \tnon-reserved\tnon-reserved\tnon-reserved\nCEIL\t \treserved\treserved\t \nCEILING\t \treserved\treserved\t \nCHAIN\tnon-reserved\tnon-reserved\tnon-reserved\t \nCHAR\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nCHARACTER\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nCHARACTERISTICS\tnon-reserved\tnon-reserved\tnon-reserved\t \nCHARACTERS\t \tnon-reserved\tnon-reserved\t \nCHARACTER_LENGTH\t \treserved\treserved\treserved\nCHARACTER_SET_CATALOG\t \tnon-reserved\tnon-reserved\tnon-reserved\nCHARACTER_SET_NAME\t \tnon-reserved\tnon-reserved\tnon-reserved\nCHARACTER_SET_SCHEMA\t \tnon-reserved\tnon-reserved\tnon-reserved\nCHAR_LENGTH\t \treserved\treserved\treserved\nCHECK\treserved\treserved\treserved\treserved\nCHECKPOINT\tnon-reserved\t \t \t \nCLASS\tnon-reserved\t \t \t \nCLASS_ORIGIN\t \tnon-reserved\tnon-reserved\tnon-reserved\nCLOB\t \treserved\treserved\t \nCLOSE\tnon-reserved\treserved\treserved\treserved\nCLUSTER\tnon-reserved\t \t \t \nCOALESCE\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nCOBOL\t \tnon-reserved\tnon-reserved\tnon-reserved\nCOLLATE\treserved\treserved\treserved\treserved\nCOLLATION\treserved (can be function or type)\tnon-reserved\tnon-reserved\treserved\nCOLLATION_CATALOG\t \tnon-reserved\tnon-reserved\tnon-reserved\nCOLLATION_NAME\t \tnon-reserved\tnon-reserved\tnon-reserved\nCOLLATION_SCHEMA\t \tnon-reserved\tnon-reserved\tnon-reserved\nCOLLECT\t \treserved\treserved\t \nCOLUMN\treserved\treserved\treserved\treserved\nCOLUMNS\t \tnon-reserved\tnon-reserved\t \nCOLUMN_NAME\t \tnon-reserved\tnon-reserved\tnon-reserved\nCOMMAND_FUNCTION\t \tnon-reserved\tnon-reserved\tnon-reserved\nCOMMAND_FUNCTION_CODE\t \tnon-reserved\tnon-reserved\t \nCOMMENT\tnon-reserved\t \t \t \nCOMMENTS\tnon-reserved\t \t \t \nCOMMIT\tnon-reserved\treserved\treserved\treserved\nCOMMITTED\tnon-reserved\tnon-reserved\tnon-reserved\tnon-reserved\nCONCURRENTLY\treserved (can be function or type)\t \t \t \nCONDITION\t \treserved\treserved\t \nCONDITION_NUMBER\t \tnon-reserved\tnon-reserved\tnon-reserved\nCONFIGURATION\tnon-reserved\t \t \t \nCONNECT\t \treserved\treserved\treserved\nCONNECTION\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nCONNECTION_NAME\t \tnon-reserved\tnon-reserved\tnon-reserved\nCONSTRAINT\treserved\treserved\treserved\treserved\nCONSTRAINTS\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nCONSTRAINT_CATALOG\t \tnon-reserved\tnon-reserved\tnon-reserved\nCONSTRAINT_NAME\t \tnon-reserved\tnon-reserved\tnon-reserved\nCONSTRAINT_SCHEMA\t \tnon-reserved\tnon-reserved\tnon-reserved\nCONSTRUCTOR\t \tnon-reserved\tnon-reserved\t \nCONTAINS\t \treserved\tnon-reserved\t \nCONTENT\tnon-reserved\tnon-reserved\tnon-reserved\t \nCONTINUE\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nCONTROL\t \tnon-reserved\tnon-reserved\t \nCONVERSION\tnon-reserved\t \t \t \nCONVERT\t \treserved\treserved\treserved\nCOPY\tnon-reserved\t \t \t \nCORR\t \treserved\treserved\t \nCORRESPONDING\t \treserved\treserved\treserved\nCOST\tnon-reserved\t \t \t \nCOUNT\t \treserved\treserved\treserved\nCOVAR_POP\t \treserved\treserved\t \nCOVAR_SAMP\t \treserved\treserved\t \nCREATE\treserved\treserved\treserved\treserved\nCROSS\treserved (can be function or type)\treserved\treserved\treserved\nCSV\tnon-reserved\t \t \t \nCUBE\t \treserved\treserved\t \nCUME_DIST\t \treserved\treserved\t \nCURRENT\tnon-reserved\treserved\treserved\treserved\nCURRENT_CATALOG\treserved\treserved\treserved\t \nCURRENT_DATE\treserved\treserved\treserved\treserved\nCURRENT_DEFAULT_TRANSFORM_GROUP\t \treserved\treserved\t \nCURRENT_PATH\t \treserved\treserved\t \nCURRENT_ROLE\treserved\treserved\treserved\t \nCURRENT_ROW\t \treserved\t \t \nCURRENT_SCHEMA\treserved (can be function or type)\treserved\treserved\t \nCURRENT_TIME\treserved\treserved\treserved\treserved\nCURRENT_TIMESTAMP\treserved\treserved\treserved\treserved\nCURRENT_TRANSFORM_GROUP_FOR_TYPE\t \treserved\treserved\t \nCURRENT_USER\treserved\treserved\treserved\treserved\nCURSOR\tnon-reserved\treserved\treserved\treserved\nCURSOR_NAME\t \tnon-reserved\tnon-reserved\tnon-reserved\nCYCLE\tnon-reserved\treserved\treserved\t \nDATA\tnon-reserved\tnon-reserved\tnon-reserved\tnon-reserved\nDATABASE\tnon-reserved\t \t \t \nDATALINK\t \treserved\treserved\t \nDATE\t \treserved\treserved\treserved\nDATETIME_INTERVAL_CODE\t \tnon-reserved\tnon-reserved\tnon-reserved\nDATETIME_INTERVAL_PRECISION\t \tnon-reserved\tnon-reserved\tnon-reserved\nDAY\tnon-reserved\treserved\treserved\treserved\nDB\t \tnon-reserved\tnon-reserved\t \nDEALLOCATE\tnon-reserved\treserved\treserved\treserved\nDEC\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nDECIMAL\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nDECLARE\tnon-reserved\treserved\treserved\treserved\nDEFAULT\treserved\treserved\treserved\treserved\nDEFAULTS\tnon-reserved\tnon-reserved\tnon-reserved\t \nDEFERRABLE\treserved\tnon-reserved\tnon-reserved\treserved\nDEFERRED\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nDEFINED\t \tnon-reserved\tnon-reserved\t \nDEFINER\tnon-reserved\tnon-reserved\tnon-reserved\t \nDEGREE\t \tnon-reserved\tnon-reserved\t \nDELETE\tnon-reserved\treserved\treserved\treserved\nDELIMITER\tnon-reserved\t \t \t \nDELIMITERS\tnon-reserved\t \t \t \nDENSE_RANK\t \treserved\treserved\t \nDEPTH\t \tnon-reserved\tnon-reserved\t \nDEREF\t \treserved\treserved\t \nDERIVED\t \tnon-reserved\tnon-reserved\t \nDESC\treserved\tnon-reserved\tnon-reserved\treserved\nDESCRIBE\t \treserved\treserved\treserved\nDESCRIPTOR\t \tnon-reserved\tnon-reserved\treserved\nDETERMINISTIC\t \treserved\treserved\t \nDIAGNOSTICS\t \tnon-reserved\tnon-reserved\treserved\nDICTIONARY\tnon-reserved\t \t \t \nDISABLE\tnon-reserved\t \t \t \nDISCARD\tnon-reserved\t \t \t \nDISCONNECT\t \treserved\treserved\treserved\nDISPATCH\t \tnon-reserved\tnon-reserved\t \nDISTINCT\treserved\treserved\treserved\treserved\nDLNEWCOPY\t \treserved\treserved\t \nDLPREVIOUSCOPY\t \treserved\treserved\t \nDLURLCOMPLETE\t \treserved\treserved\t \nDLURLCOMPLETEONLY\t \treserved\treserved\t \nDLURLCOMPLETEWRITE\t \treserved\treserved\t \nDLURLPATH\t \treserved\treserved\t \nDLURLPATHONLY\t \treserved\treserved\t \nDLURLPATHWRITE\t \treserved\treserved\t \nDLURLSCHEME\t \treserved\treserved\t \nDLURLSERVER\t \treserved\treserved\t \nDLVALUE\t \treserved\treserved\t \nDO\treserved\t \t \t \nDOCUMENT\tnon-reserved\tnon-reserved\tnon-reserved\t \nDOMAIN\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nDOUBLE\tnon-reserved\treserved\treserved\treserved\nDROP\tnon-reserved\treserved\treserved\treserved\nDYNAMIC\t \treserved\treserved\t \nDYNAMIC_FUNCTION\t \tnon-reserved\tnon-reserved\tnon-reserved\nDYNAMIC_FUNCTION_CODE\t \tnon-reserved\tnon-reserved\t \nEACH\tnon-reserved\treserved\treserved\t \nELEMENT\t \treserved\treserved\t \nELSE\treserved\treserved\treserved\treserved\nEMPTY\t \tnon-reserved\tnon-reserved\t \nENABLE\tnon-reserved\t \t \t \nENCODING\tnon-reserved\tnon-reserved\tnon-reserved\t \nENCRYPTED\tnon-reserved\t \t \t \nEND\treserved\treserved\treserved\treserved\nEND-EXEC\t \treserved\treserved\treserved\nEND_FRAME\t \treserved\t \t \nEND_PARTITION\t \treserved\t \t \nENFORCED\t \tnon-reserved\t \t \nENUM\tnon-reserved\t \t \t \nEQUALS\t \treserved\tnon-reserved\t \nESCAPE\tnon-reserved\treserved\treserved\treserved\nEVENT\tnon-reserved\t \t \t \nEVERY\t \treserved\treserved\t \nEXCEPT\treserved\treserved\treserved\treserved\nEXCEPTION\t \t \t \treserved\nEXCLUDE\tnon-reserved\tnon-reserved\tnon-reserved\t \nEXCLUDING\tnon-reserved\tnon-reserved\tnon-reserved\t \nEXCLUSIVE\tnon-reserved\t \t \t \nEXEC\t \treserved\treserved\treserved\nEXECUTE\tnon-reserved\treserved\treserved\treserved\nEXISTS\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nEXP\t \treserved\treserved\t \nEXPLAIN\tnon-reserved\t \t \t \nEXPRESSION\t \tnon-reserved\t \t \nEXTENSION\tnon-reserved\t \t \t \nEXTERNAL\tnon-reserved\treserved\treserved\treserved\nEXTRACT\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nFALSE\treserved\treserved\treserved\treserved\nFAMILY\tnon-reserved\t \t \t \nFETCH\treserved\treserved\treserved\treserved\nFILE\t \tnon-reserved\tnon-reserved\t \nFILTER\t \treserved\treserved\t \nFINAL\t \tnon-reserved\tnon-reserved\t \nFIRST\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nFIRST_VALUE\t \treserved\treserved\t \nFLAG\t \tnon-reserved\tnon-reserved\t \nFLOAT\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nFLOOR\t \treserved\treserved\t \nFOLLOWING\tnon-reserved\tnon-reserved\tnon-reserved\t \nFOR\treserved\treserved\treserved\treserved\nFORCE\tnon-reserved\t \t \t \nFOREIGN\treserved\treserved\treserved\treserved\nFORTRAN\t \tnon-reserved\tnon-reserved\tnon-reserved\nFORWARD\tnon-reserved\t \t \t \nFOUND\t \tnon-reserved\tnon-reserved\treserved\nFRAME_ROW\t \treserved\t \t \nFREE\t \treserved\treserved\t \nFREEZE\treserved (can be function or type)\t \t \t \nFROM\treserved\treserved\treserved\treserved\nFS\t \tnon-reserved\tnon-reserved\t \nFULL\treserved (can be function or type)\treserved\treserved\treserved\nFUNCTION\tnon-reserved\treserved\treserved\t \nFUNCTIONS\tnon-reserved\t \t \t \nFUSION\t \treserved\treserved\t \nG\t \tnon-reserved\tnon-reserved\t \nGENERAL\t \tnon-reserved\tnon-reserved\t \nGENERATED\t \tnon-reserved\tnon-reserved\t \nGET\t \treserved\treserved\treserved\nGLOBAL\tnon-reserved\treserved\treserved\treserved\nGO\t \tnon-reserved\tnon-reserved\treserved\nGOTO\t \tnon-reserved\tnon-reserved\treserved\nGRANT\treserved\treserved\treserved\treserved\nGRANTED\tnon-reserved\tnon-reserved\tnon-reserved\t \nGREATEST\tnon-reserved (cannot be function or type)\t \t \t \nGROUP\treserved\treserved\treserved\treserved\nGROUPING\t \treserved\treserved\t \nGROUPS\t \treserved\t \t \nHANDLER\tnon-reserved\t \t \t \nHAVING\treserved\treserved\treserved\treserved\nHEADER\tnon-reserved\t \t \t \nHEX\t \tnon-reserved\tnon-reserved\t \nHIERARCHY\t \tnon-reserved\tnon-reserved\t \nHOLD\tnon-reserved\treserved\treserved\t \nHOUR\tnon-reserved\treserved\treserved\treserved\nID\t \tnon-reserved\tnon-reserved\t \nIDENTITY\tnon-reserved\treserved\treserved\treserved\nIF\tnon-reserved\t \t \t \nIGNORE\t \tnon-reserved\tnon-reserved\t \nILIKE\treserved (can be function or type)\t \t \t \nIMMEDIATE\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nIMMEDIATELY\t \tnon-reserved\t \t \nIMMUTABLE\tnon-reserved\t \t \t \nIMPLEMENTATION\t \tnon-reserved\tnon-reserved\t \nIMPLICIT\tnon-reserved\t \t \t \nIMPORT\t \treserved\treserved\t \nIN\treserved\treserved\treserved\treserved\nINCLUDING\tnon-reserved\tnon-reserved\tnon-reserved\t \nINCREMENT\tnon-reserved\tnon-reserved\tnon-reserved\t \nINDENT\t \tnon-reserved\tnon-reserved\t \nINDEX\tnon-reserved\t \t \t \nINDEXES\tnon-reserved\t \t \t \nINDICATOR\t \treserved\treserved\treserved\nINHERIT\tnon-reserved\t \t \t \nINHERITS\tnon-reserved\t \t \t \nINITIALLY\treserved\tnon-reserved\tnon-reserved\treserved\nINLINE\tnon-reserved\t \t \t \nINNER\treserved (can be function or type)\treserved\treserved\treserved\nINOUT\tnon-reserved (cannot be function or type)\treserved\treserved\t \nINPUT\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nINSENSITIVE\tnon-reserved\treserved\treserved\treserved\nINSERT\tnon-reserved\treserved\treserved\treserved\nINSTANCE\t \tnon-reserved\tnon-reserved\t \nINSTANTIABLE\t \tnon-reserved\tnon-reserved\t \nINSTEAD\tnon-reserved\tnon-reserved\tnon-reserved\t \nINT\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nINTEGER\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nINTEGRITY\t \tnon-reserved\tnon-reserved\t \nINTERSECT\treserved\treserved\treserved\treserved\nINTERSECTION\t \treserved\treserved\t \nINTERVAL\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nINTO\treserved\treserved\treserved\treserved\nINVOKER\tnon-reserved\tnon-reserved\tnon-reserved\t \nIS\treserved (can be function or type)\treserved\treserved\treserved\nISNULL\treserved (can be function or type)\t \t \t \nISOLATION\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nJOIN\treserved (can be function or type)\treserved\treserved\treserved\nK\t \tnon-reserved\tnon-reserved\t \nKEY\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nKEY_MEMBER\t \tnon-reserved\tnon-reserved\t \nKEY_TYPE\t \tnon-reserved\tnon-reserved\t \nLABEL\tnon-reserved\t \t \t \nLAG\t \treserved\treserved\t \nLANGUAGE\tnon-reserved\treserved\treserved\treserved\nLARGE\tnon-reserved\treserved\treserved\t \nLAST\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nLAST_VALUE\t \treserved\treserved\t \nLATERAL\treserved\treserved\treserved\t \nLC_COLLATE\tnon-reserved\t \t \t \nLC_CTYPE\tnon-reserved\t \t \t \nLEAD\t \treserved\treserved\t \nLEADING\treserved\treserved\treserved\treserved\nLEAKPROOF\tnon-reserved\t \t \t \nLEAST\tnon-reserved (cannot be function or type)\t \t \t \nLEFT\treserved (can be function or type)\treserved\treserved\treserved\nLENGTH\t \tnon-reserved\tnon-reserved\tnon-reserved\nLEVEL\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nLIBRARY\t \tnon-reserved\tnon-reserved\t \nLIKE\treserved (can be function or type)\treserved\treserved\treserved\nLIKE_REGEX\t \treserved\treserved\t \nLIMIT\treserved\tnon-reserved\tnon-reserved\t \nLINK\t \tnon-reserved\tnon-reserved\t \nLISTEN\tnon-reserved\t \t \t \nLN\t \treserved\treserved\t \nLOAD\tnon-reserved\t \t \t \nLOCAL\tnon-reserved\treserved\treserved\treserved\nLOCALTIME\treserved\treserved\treserved\t \nLOCALTIMESTAMP\treserved\treserved\treserved\t \nLOCATION\tnon-reserved\tnon-reserved\tnon-reserved\t \nLOCATOR\t \tnon-reserved\tnon-reserved\t \nLOCK\tnon-reserved\t \t \t \nLOWER\t \treserved\treserved\treserved\nM\t \tnon-reserved\tnon-reserved\t \nMAP\t \tnon-reserved\tnon-reserved\t \nMAPPING\tnon-reserved\tnon-reserved\tnon-reserved\t \nMATCH\tnon-reserved\treserved\treserved\treserved\nMATCHED\t \tnon-reserved\tnon-reserved\t \nMATERIALIZED\tnon-reserved\t \t \t \nMAX\t \treserved\treserved\treserved\nMAXVALUE\tnon-reserved\tnon-reserved\tnon-reserved\t \nMAX_CARDINALITY\t \t \treserved\t \nMEMBER\t \treserved\treserved\t \nMERGE\t \treserved\treserved\t \nMESSAGE_LENGTH\t \tnon-reserved\tnon-reserved\tnon-reserved\nMESSAGE_OCTET_LENGTH\t \tnon-reserved\tnon-reserved\tnon-reserved\nMESSAGE_TEXT\t \tnon-reserved\tnon-reserved\tnon-reserved\nMETHOD\t \treserved\treserved\t \nMIN\t \treserved\treserved\treserved\nMINUTE\tnon-reserved\treserved\treserved\treserved\nMINVALUE\tnon-reserved\tnon-reserved\tnon-reserved\t \nMOD\t \treserved\treserved\t \nMODE\tnon-reserved\t \t \t \nMODIFIES\t \treserved\treserved\t \nMODULE\t \treserved\treserved\treserved\nMONTH\tnon-reserved\treserved\treserved\treserved\nMORE\t \tnon-reserved\tnon-reserved\tnon-reserved\nMOVE\tnon-reserved\t \t \t \nMULTISET\t \treserved\treserved\t \nMUMPS\t \tnon-reserved\tnon-reserved\tnon-reserved\nNAME\tnon-reserved\tnon-reserved\tnon-reserved\tnon-reserved\nNAMES\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nNAMESPACE\t \tnon-reserved\tnon-reserved\t \nNATIONAL\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nNATURAL\treserved (can be function or type)\treserved\treserved\treserved\nNCHAR\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nNCLOB\t \treserved\treserved\t \nNESTING\t \tnon-reserved\tnon-reserved\t \nNEW\t \treserved\treserved\t \nNEXT\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nNFC\t \tnon-reserved\tnon-reserved\t \nNFD\t \tnon-reserved\tnon-reserved\t \nNFKC\t \tnon-reserved\tnon-reserved\t \nNFKD\t \tnon-reserved\tnon-reserved\t \nNIL\t \tnon-reserved\tnon-reserved\t \nNO\tnon-reserved\treserved\treserved\treserved\nNONE\tnon-reserved (cannot be function or type)\treserved\treserved\t \nNORMALIZE\t \treserved\treserved\t \nNORMALIZED\t \tnon-reserved\tnon-reserved\t \nNOT\treserved\treserved\treserved\treserved\nNOTHING\tnon-reserved\t \t \t \nNOTIFY\tnon-reserved\t \t \t \nNOTNULL\treserved (can be function or type)\t \t \t \nNOWAIT\tnon-reserved\t \t \t \nNTH_VALUE\t \treserved\treserved\t \nNTILE\t \treserved\treserved\t \nNULL\treserved\treserved\treserved\treserved\nNULLABLE\t \tnon-reserved\tnon-reserved\tnon-reserved\nNULLIF\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nNULLS\tnon-reserved\tnon-reserved\tnon-reserved\t \nNUMBER\t \tnon-reserved\tnon-reserved\tnon-reserved\nNUMERIC\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nOBJECT\tnon-reserved\tnon-reserved\tnon-reserved\t \nOCCURRENCES_REGEX\t \treserved\treserved\t \nOCTETS\t \tnon-reserved\tnon-reserved\t \nOCTET_LENGTH\t \treserved\treserved\treserved\nOF\tnon-reserved\treserved\treserved\treserved\nOFF\tnon-reserved\tnon-reserved\tnon-reserved\t \nOFFSET\treserved\treserved\treserved\t \nOIDS\tnon-reserved\t \t \t \nOLD\t \treserved\treserved\t \nON\treserved\treserved\treserved\treserved\nONLY\treserved\treserved\treserved\treserved\nOPEN\t \treserved\treserved\treserved\nOPERATOR\tnon-reserved\t \t \t \nOPTION\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nOPTIONS\tnon-reserved\tnon-reserved\tnon-reserved\t \nOR\treserved\treserved\treserved\treserved\nORDER\treserved\treserved\treserved\treserved\nORDERING\t \tnon-reserved\tnon-reserved\t \nORDINALITY\t \tnon-reserved\tnon-reserved\t \nOTHERS\t \tnon-reserved\tnon-reserved\t \nOUT\tnon-reserved (cannot be function or type)\treserved\treserved\t \nOUTER\treserved (can be function or type)\treserved\treserved\treserved\nOUTPUT\t \tnon-reserved\tnon-reserved\treserved\nOVER\treserved (can be function or type)\treserved\treserved\t \nOVERLAPS\treserved (can be function or type)\treserved\treserved\treserved\nOVERLAY\tnon-reserved (cannot be function or type)\treserved\treserved\t \nOVERRIDING\t \tnon-reserved\tnon-reserved\t \nOWNED\tnon-reserved\t \t \t \nOWNER\tnon-reserved\t \t \t \nP\t \tnon-reserved\tnon-reserved\t \nPAD\t \tnon-reserved\tnon-reserved\treserved\nPARAMETER\t \treserved\treserved\t \nPARAMETER_MODE\t \tnon-reserved\tnon-reserved\t \nPARAMETER_NAME\t \tnon-reserved\tnon-reserved\t \nPARAMETER_ORDINAL_POSITION\t \tnon-reserved\tnon-reserved\t \nPARAMETER_SPECIFIC_CATALOG\t \tnon-reserved\tnon-reserved\t \nPARAMETER_SPECIFIC_NAME\t \tnon-reserved\tnon-reserved\t \nPARAMETER_SPECIFIC_SCHEMA\t \tnon-reserved\tnon-reserved\t \nPARSER\tnon-reserved\t \t \t \nPARTIAL\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nPARTITION\tnon-reserved\treserved\treserved\t \nPASCAL\t \tnon-reserved\tnon-reserved\tnon-reserved\nPASSING\tnon-reserved\tnon-reserved\tnon-reserved\t \nPASSTHROUGH\t \tnon-reserved\tnon-reserved\t \nPASSWORD\tnon-reserved\t \t \t \nPATH\t \tnon-reserved\tnon-reserved\t \nPERCENT\t \treserved\t \t \nPERCENTILE_CONT\t \treserved\treserved\t \nPERCENTILE_DISC\t \treserved\treserved\t \nPERCENT_RANK\t \treserved\treserved\t \nPERIOD\t \treserved\t \t \nPERMISSION\t \tnon-reserved\tnon-reserved\t \nPLACING\treserved\tnon-reserved\tnon-reserved\t \nPLANS\tnon-reserved\t \t \t \nPLI\t \tnon-reserved\tnon-reserved\tnon-reserved\nPORTION\t \treserved\t \t \nPOSITION\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nPOSITION_REGEX\t \treserved\treserved\t \nPOWER\t \treserved\treserved\t \nPRECEDES\t \treserved\t \t \nPRECEDING\tnon-reserved\tnon-reserved\tnon-reserved\t \nPRECISION\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nPREPARE\tnon-reserved\treserved\treserved\treserved\nPREPARED\tnon-reserved\t \t \t \nPRESERVE\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nPRIMARY\treserved\treserved\treserved\treserved\nPRIOR\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nPRIVILEGES\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nPROCEDURAL\tnon-reserved\t \t \t \nPROCEDURE\tnon-reserved\treserved\treserved\treserved\nPROGRAM\tnon-reserved\t \t \t \nPUBLIC\t \tnon-reserved\tnon-reserved\treserved\nQUOTE\tnon-reserved\t \t \t \nRANGE\tnon-reserved\treserved\treserved\t \nRANK\t \treserved\treserved\t \nREAD\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nREADS\t \treserved\treserved\t \nREAL\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nREASSIGN\tnon-reserved\t \t \t \nRECHECK\tnon-reserved\t \t \t \nRECOVERY\t \tnon-reserved\tnon-reserved\t \nRECURSIVE\tnon-reserved\treserved\treserved\t \nREF\tnon-reserved\treserved\treserved\t \nREFERENCES\treserved\treserved\treserved\treserved\nREFERENCING\t \treserved\treserved\t \nREFRESH\tnon-reserved\t \t \t \nREGR_AVGX\t \treserved\treserved\t \nREGR_AVGY\t \treserved\treserved\t \nREGR_COUNT\t \treserved\treserved\t \nREGR_INTERCEPT\t \treserved\treserved\t \nREGR_R2\t \treserved\treserved\t \nREGR_SLOPE\t \treserved\treserved\t \nREGR_SXX\t \treserved\treserved\t \nREGR_SXY\t \treserved\treserved\t \nREGR_SYY\t \treserved\treserved\t \nREINDEX\tnon-reserved\t \t \t \nRELATIVE\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nRELEASE\tnon-reserved\treserved\treserved\t \nRENAME\tnon-reserved\t \t \t \nREPEATABLE\tnon-reserved\tnon-reserved\tnon-reserved\tnon-reserved\nREPLACE\tnon-reserved\t \t \t \nREPLICA\tnon-reserved\t \t \t \nREQUIRING\t \tnon-reserved\tnon-reserved\t \nRESET\tnon-reserved\t \t \t \nRESPECT\t \tnon-reserved\tnon-reserved\t \nRESTART\tnon-reserved\tnon-reserved\tnon-reserved\t \nRESTORE\t \tnon-reserved\tnon-reserved\t \nRESTRICT\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nRESULT\t \treserved\treserved\t \nRETURN\t \treserved\treserved\t \nRETURNED_CARDINALITY\t \tnon-reserved\tnon-reserved\t \nRETURNED_LENGTH\t \tnon-reserved\tnon-reserved\tnon-reserved\nRETURNED_OCTET_LENGTH\t \tnon-reserved\tnon-reserved\tnon-reserved\nRETURNED_SQLSTATE\t \tnon-reserved\tnon-reserved\tnon-reserved\nRETURNING\treserved\tnon-reserved\tnon-reserved\t \nRETURNS\tnon-reserved\treserved\treserved\t \nREVOKE\tnon-reserved\treserved\treserved\treserved\nRIGHT\treserved (can be function or type)\treserved\treserved\treserved\nROLE\tnon-reserved\tnon-reserved\tnon-reserved\t \nROLLBACK\tnon-reserved\treserved\treserved\treserved\nROLLUP\t \treserved\treserved\t \nROUTINE\t \tnon-reserved\tnon-reserved\t \nROUTINE_CATALOG\t \tnon-reserved\tnon-reserved\t \nROUTINE_NAME\t \tnon-reserved\tnon-reserved\t \nROUTINE_SCHEMA\t \tnon-reserved\tnon-reserved\t \nROW\tnon-reserved (cannot be function or type)\treserved\treserved\t \nROWS\tnon-reserved\treserved\treserved\treserved\nROW_COUNT\t \tnon-reserved\tnon-reserved\tnon-reserved\nROW_NUMBER\t \treserved\treserved\t \nRULE\tnon-reserved\t \t \t \nSAVEPOINT\tnon-reserved\treserved\treserved\t \nSCALE\t \tnon-reserved\tnon-reserved\tnon-reserved\nSCHEMA\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nSCHEMA_NAME\t \tnon-reserved\tnon-reserved\tnon-reserved\nSCOPE\t \treserved\treserved\t \nSCOPE_CATALOG\t \tnon-reserved\tnon-reserved\t \nSCOPE_NAME\t \tnon-reserved\tnon-reserved\t \nSCOPE_SCHEMA\t \tnon-reserved\tnon-reserved\t \nSCROLL\tnon-reserved\treserved\treserved\treserved\nSEARCH\tnon-reserved\treserved\treserved\t \nSECOND\tnon-reserved\treserved\treserved\treserved\nSECTION\t \tnon-reserved\tnon-reserved\treserved\nSECURITY\tnon-reserved\tnon-reserved\tnon-reserved\t \nSELECT\treserved\treserved\treserved\treserved\nSELECTIVE\t \tnon-reserved\tnon-reserved\t \nSELF\t \tnon-reserved\tnon-reserved\t \nSENSITIVE\t \treserved\treserved\t \nSEQUENCE\tnon-reserved\tnon-reserved\tnon-reserved\t \nSEQUENCES\tnon-reserved\t \t \t \nSERIALIZABLE\tnon-reserved\tnon-reserved\tnon-reserved\tnon-reserved\nSERVER\tnon-reserved\tnon-reserved\tnon-reserved\t \nSERVER_NAME\t \tnon-reserved\tnon-reserved\tnon-reserved\nSESSION\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nSESSION_USER\treserved\treserved\treserved\treserved\nSET\tnon-reserved\treserved\treserved\treserved\nSETOF\tnon-reserved (cannot be function or type)\t \t \t \nSETS\t \tnon-reserved\tnon-reserved\t \nSHARE\tnon-reserved\t \t \t \nSHOW\tnon-reserved\t \t \t \nSIMILAR\treserved (can be function or type)\treserved\treserved\t \nSIMPLE\tnon-reserved\tnon-reserved\tnon-reserved\t \nSIZE\t \tnon-reserved\tnon-reserved\treserved\nSMALLINT\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nSNAPSHOT\tnon-reserved\t \t \t \nSOME\treserved\treserved\treserved\treserved\nSOURCE\t \tnon-reserved\tnon-reserved\t \nSPACE\t \tnon-reserved\tnon-reserved\treserved\nSPECIFIC\t \treserved\treserved\t \nSPECIFICTYPE\t \treserved\treserved\t \nSPECIFIC_NAME\t \tnon-reserved\tnon-reserved\t \nSQL\t \treserved\treserved\treserved\nSQLCODE\t \t \t \treserved\nSQLERROR\t \t \t \treserved\nSQLEXCEPTION\t \treserved\treserved\t \nSQLSTATE\t \treserved\treserved\treserved\nSQLWARNING\t \treserved\treserved\t \nSQRT\t \treserved\treserved\t \nSTABLE\tnon-reserved\t \t \t \nSTANDALONE\tnon-reserved\tnon-reserved\tnon-reserved\t \nSTART\tnon-reserved\treserved\treserved\t \nSTATE\t \tnon-reserved\tnon-reserved\t \nSTATEMENT\tnon-reserved\tnon-reserved\tnon-reserved\t \nSTATIC\t \treserved\treserved\t \nSTATISTICS\tnon-reserved\t \t \t \nSTDDEV_POP\t \treserved\treserved\t \nSTDDEV_SAMP\t \treserved\treserved\t \nSTDIN\tnon-reserved\t \t \t \nSTDOUT\tnon-reserved\t \t \t \nSTORAGE\tnon-reserved\t \t \t \nSTRICT\tnon-reserved\t \t \t \nSTRIP\tnon-reserved\tnon-reserved\tnon-reserved\t \nSTRUCTURE\t \tnon-reserved\tnon-reserved\t \nSTYLE\t \tnon-reserved\tnon-reserved\t \nSUBCLASS_ORIGIN\t \tnon-reserved\tnon-reserved\tnon-reserved\nSUBMULTISET\t \treserved\treserved\t \nSUBSTRING\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nSUBSTRING_REGEX\t \treserved\treserved\t \nSUCCEEDS\t \treserved\t \t \nSUM\t \treserved\treserved\treserved\nSYMMETRIC\treserved\treserved\treserved\t \nSYSID\tnon-reserved\t \t \t \nSYSTEM\tnon-reserved\treserved\treserved\t \nSYSTEM_TIME\t \treserved\t \t \nSYSTEM_USER\t \treserved\treserved\treserved\nT\t \tnon-reserved\tnon-reserved\t \nTABLE\treserved\treserved\treserved\treserved\nTABLES\tnon-reserved\t \t \t \nTABLESAMPLE\t \treserved\treserved\t \nTABLESPACE\tnon-reserved\t \t \t \nTABLE_NAME\t \tnon-reserved\tnon-reserved\tnon-reserved\nTEMP\tnon-reserved\t \t \t \nTEMPLATE\tnon-reserved\t \t \t \nTEMPORARY\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nTEXT\tnon-reserved\t \t \t \nTHEN\treserved\treserved\treserved\treserved\nTIES\t \tnon-reserved\tnon-reserved\t \nTIME\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nTIMESTAMP\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nTIMEZONE_HOUR\t \treserved\treserved\treserved\nTIMEZONE_MINUTE\t \treserved\treserved\treserved\nTO\treserved\treserved\treserved\treserved\nTOKEN\t \tnon-reserved\tnon-reserved\t \nTOP_LEVEL_COUNT\t \tnon-reserved\tnon-reserved\t \nTRAILING\treserved\treserved\treserved\treserved\nTRANSACTION\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nTRANSACTIONS_COMMITTED\t \tnon-reserved\tnon-reserved\t \nTRANSACTIONS_ROLLED_BACK\t \tnon-reserved\tnon-reserved\t \nTRANSACTION_ACTIVE\t \tnon-reserved\tnon-reserved\t \nTRANSFORM\t \tnon-reserved\tnon-reserved\t \nTRANSFORMS\t \tnon-reserved\tnon-reserved\t \nTRANSLATE\t \treserved\treserved\treserved\nTRANSLATE_REGEX\t \treserved\treserved\t \nTRANSLATION\t \treserved\treserved\treserved\nTREAT\tnon-reserved (cannot be function or type)\treserved\treserved\t \nTRIGGER\tnon-reserved\treserved\treserved\t \nTRIGGER_CATALOG\t \tnon-reserved\tnon-reserved\t \nTRIGGER_NAME\t \tnon-reserved\tnon-reserved\t \nTRIGGER_SCHEMA\t \tnon-reserved\tnon-reserved\t \nTRIM\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nTRIM_ARRAY\t \treserved\treserved\t \nTRUE\treserved\treserved\treserved\treserved\nTRUNCATE\tnon-reserved\treserved\treserved\t \nTRUSTED\tnon-reserved\t \t \t \nTYPE\tnon-reserved\tnon-reserved\tnon-reserved\tnon-reserved\nTYPES\tnon-reserved\t \t \t \nUESCAPE\t \treserved\treserved\t \nUNBOUNDED\tnon-reserved\tnon-reserved\tnon-reserved\t \nUNCOMMITTED\tnon-reserved\tnon-reserved\tnon-reserved\tnon-reserved\nUNDER\t \tnon-reserved\tnon-reserved\t \nUNENCRYPTED\tnon-reserved\t \t \t \nUNION\treserved\treserved\treserved\treserved\nUNIQUE\treserved\treserved\treserved\treserved\nUNKNOWN\tnon-reserved\treserved\treserved\treserved\nUNLINK\t \tnon-reserved\tnon-reserved\t \nUNLISTEN\tnon-reserved\t \t \t \nUNLOGGED\tnon-reserved\t \t \t \nUNNAMED\t \tnon-reserved\tnon-reserved\tnon-reserved\nUNNEST\t \treserved\treserved\t \nUNTIL\tnon-reserved\t \t \t \nUNTYPED\t \tnon-reserved\tnon-reserved\t \nUPDATE\tnon-reserved\treserved\treserved\treserved\nUPPER\t \treserved\treserved\treserved\nURI\t \tnon-reserved\tnon-reserved\t \nUSAGE\t \tnon-reserved\tnon-reserved\treserved\nUSER\treserved\treserved\treserved\treserved\nUSER_DEFINED_TYPE_CATALOG\t \tnon-reserved\tnon-reserved\t \nUSER_DEFINED_TYPE_CODE\t \tnon-reserved\tnon-reserved\t \nUSER_DEFINED_TYPE_NAME\t \tnon-reserved\tnon-reserved\t \nUSER_DEFINED_TYPE_SCHEMA\t \tnon-reserved\tnon-reserved\t \nUSING\treserved\treserved\treserved\treserved\nVACUUM\tnon-reserved\t \t \t \nVALID\tnon-reserved\tnon-reserved\tnon-reserved\t \nVALIDATE\tnon-reserved\t \t \t \nVALIDATOR\tnon-reserved\t \t \t \nVALUE\tnon-reserved\treserved\treserved\treserved\nVALUES\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nVALUE_OF\t \treserved\t \t \nVARBINARY\t \treserved\treserved\t \nVARCHAR\tnon-reserved (cannot be function or type)\treserved\treserved\treserved\nVARIADIC\treserved\t \t \t \nVARYING\tnon-reserved\treserved\treserved\treserved\nVAR_POP\t \treserved\treserved\t \nVAR_SAMP\t \treserved\treserved\t \nVERBOSE\treserved (can be function or type)\t \t \t \nVERSION\tnon-reserved\tnon-reserved\tnon-reserved\t \nVERSIONING\t \treserved\t \t \nVIEW\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nVOLATILE\tnon-reserved\t \t \t \nWHEN\treserved\treserved\treserved\treserved\nWHENEVER\t \treserved\treserved\treserved\nWHERE\treserved\treserved\treserved\treserved\nWHITESPACE\tnon-reserved\tnon-reserved\tnon-reserved\t \nWIDTH_BUCKET\t \treserved\treserved\t \nWINDOW\treserved\treserved\treserved\t \nWITH\treserved\treserved\treserved\treserved\nWITHIN\t \treserved\treserved\t \nWITHOUT\tnon-reserved\treserved\treserved\t \nWORK\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nWRAPPER\tnon-reserved\tnon-reserved\tnon-reserved\t \nWRITE\tnon-reserved\tnon-reserved\tnon-reserved\treserved\nXML\tnon-reserved\treserved\treserved\t \nXMLAGG\t \treserved\treserved\t \nXMLATTRIBUTES\tnon-reserved (cannot be function or type)\treserved\treserved\t \nXMLBINARY\t \treserved\treserved\t \nXMLCAST\t \treserved\treserved\t \nXMLCOMMENT\t \treserved\treserved\t \nXMLCONCAT\tnon-reserved (cannot be function or type)\treserved\treserved\t \nXMLDECLARATION\t \tnon-reserved\tnon-reserved\t \nXMLDOCUMENT\t \treserved\treserved\t \nXMLELEMENT\tnon-reserved (cannot be function or type)\treserved\treserved\t \nXMLEXISTS\tnon-reserved (cannot be function or type)\treserved\treserved\t \nXMLFOREST\tnon-reserved (cannot be function or type)\treserved\treserved\t \nXMLITERATE\t \treserved\treserved\t \nXMLNAMESPACES\t \treserved\treserved\t \nXMLPARSE\tnon-reserved (cannot be function or type)\treserved\treserved\t \nXMLPI\tnon-reserved (cannot be function or type)\treserved\treserved\t \nXMLQUERY\t \treserved\treserved\t \nXMLROOT\tnon-reserved (cannot be function or type)\t \t \t \nXMLSCHEMA\t \tnon-reserved\tnon-reserved\t \nXMLSERIALIZE\tnon-reserved (cannot be function or type)\treserved\treserved\t \nXMLTABLE\t \treserved\treserved\t \nXMLTEXT\t \treserved\treserved\t \nXMLVALIDATE\t \treserved\treserved\t \nYEAR\tnon-reserved\treserved\treserved\treserved\nYES\tnon-reserved\tnon-reserved\tnon-reserved\t \nZONE\tnon-reserved\tnon-reserved\tnon-reserved\treserved"
        },
        {
          "name": "processors.go",
          "type": "blob",
          "size": 2.001953125,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\n// BeforeInsertProcessor executed before an object is initially persisted to the database\ntype BeforeInsertProcessor interface {\n\tBeforeInsert()\n}\n\n// BeforeUpdateProcessor executed before an object is updated\ntype BeforeUpdateProcessor interface {\n\tBeforeUpdate()\n}\n\n// BeforeDeleteProcessor executed before an object is deleted\ntype BeforeDeleteProcessor interface {\n\tBeforeDelete()\n}\n\n// BeforeSetProcessor executed before data set to the struct fields\ntype BeforeSetProcessor interface {\n\tBeforeSet(string, Cell)\n}\n\n// AfterSetProcessor executed after data set to the struct fields\ntype AfterSetProcessor interface {\n\tAfterSet(string, Cell)\n}\n\n// AfterInsertProcessor executed after an object is persisted to the database\ntype AfterInsertProcessor interface {\n\tAfterInsert()\n}\n\n// AfterUpdateProcessor executed after an object has been updated\ntype AfterUpdateProcessor interface {\n\tAfterUpdate()\n}\n\n// AfterDeleteProcessor executed after an object has been deleted\ntype AfterDeleteProcessor interface {\n\tAfterDelete()\n}\n\n// AfterLoadProcessor executed after an ojbect has been loaded from database\ntype AfterLoadProcessor interface {\n\tAfterLoad()\n}\n\n// AfterLoadSessionProcessor executed after an ojbect has been loaded from database with session parameter\ntype AfterLoadSessionProcessor interface {\n\tAfterLoad(*Session)\n}\n\ntype executedProcessorFunc func(*Session, interface{}) error\n\ntype executedProcessor struct {\n\tfun     executedProcessorFunc\n\tsession *Session\n\tbean    interface{}\n}\n\nfunc (executor *executedProcessor) execute() error {\n\treturn executor.fun(executor.session, executor.bean)\n}\n\nfunc (session *Session) executeProcessors() error {\n\tprocessors := session.afterProcessors\n\tsession.afterProcessors = make([]executedProcessor, 0)\n\tfor _, processor := range processors {\n\t\tif err := processor.execute(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "processors_test.go",
          "type": "blob",
          "size": 21.9375,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestBefore_Get(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype BeforeTable struct {\n\t\tId   int64\n\t\tName string\n\t\tVal  string `xorm:\"-\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(BeforeTable)))\n\n\tcnt, err := testEngine.Insert(&BeforeTable{\n\t\tName: \"test\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar be BeforeTable\n\thas, err := testEngine.Before(func(bean interface{}) {\n\t\tbean.(*BeforeTable).Val = \"val\"\n\t}).Get(&be)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.Equal(t, \"val\", be.Val)\n\tassert.Equal(t, \"test\", be.Name)\n}\n\nfunc TestBefore_Find(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype BeforeTable2 struct {\n\t\tId   int64\n\t\tName string\n\t\tVal  string `xorm:\"-\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(BeforeTable2)))\n\n\tcnt, err := testEngine.Insert([]BeforeTable2{\n\t\t{Name: \"test1\"},\n\t\t{Name: \"test2\"},\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, cnt)\n\n\tvar be []BeforeTable2\n\terr = testEngine.Before(func(bean interface{}) {\n\t\tbean.(*BeforeTable2).Val = \"val\"\n\t}).Find(&be)\n\tassert.NoError(t, err)\n\tassert.Equal(t, 2, len(be))\n\tassert.Equal(t, \"val\", be[0].Val)\n\tassert.Equal(t, \"test1\", be[0].Name)\n\tassert.Equal(t, \"val\", be[1].Val)\n\tassert.Equal(t, \"test2\", be[1].Name)\n}\n\ntype ProcessorsStruct struct {\n\tId int64\n\n\tB4InsertFlag      int\n\tAfterInsertedFlag int\n\tB4UpdateFlag      int\n\tAfterUpdatedFlag  int\n\tB4DeleteFlag      int `xorm:\"-\"`\n\tAfterDeletedFlag  int `xorm:\"-\"`\n\tBeforeSetFlag     int `xorm:\"-\"`\n\n\tB4InsertViaExt      int\n\tAfterInsertedViaExt int\n\tB4UpdateViaExt      int\n\tAfterUpdatedViaExt  int\n\tB4DeleteViaExt      int `xorm:\"-\"`\n\tAfterDeletedViaExt  int `xorm:\"-\"`\n\tAfterSetFlag        int `xorm:\"-\"`\n}\n\nfunc (p *ProcessorsStruct) BeforeInsert() {\n\tp.B4InsertFlag = 1\n}\n\nfunc (p *ProcessorsStruct) BeforeUpdate() {\n\tp.B4UpdateFlag = 1\n}\n\nfunc (p *ProcessorsStruct) BeforeDelete() {\n\tp.B4DeleteFlag = 1\n}\n\nfunc (p *ProcessorsStruct) BeforeSet(col string, cell Cell) {\n\tp.BeforeSetFlag = p.BeforeSetFlag + 1\n}\n\nfunc (p *ProcessorsStruct) AfterInsert() {\n\tp.AfterInsertedFlag = 1\n}\n\nfunc (p *ProcessorsStruct) AfterUpdate() {\n\tp.AfterUpdatedFlag = 1\n}\n\nfunc (p *ProcessorsStruct) AfterDelete() {\n\tp.AfterDeletedFlag = 1\n}\n\nfunc (p *ProcessorsStruct) AfterSet(col string, cell Cell) {\n\tp.AfterSetFlag = p.AfterSetFlag + 1\n}\n\nfunc TestProcessors(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&ProcessorsStruct{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tp := &ProcessorsStruct{}\n\n\terr = testEngine.CreateTables(&ProcessorsStruct{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tb4InsertFunc := func(bean interface{}) {\n\t\tif v, ok := (bean).(*ProcessorsStruct); ok {\n\t\t\tv.B4InsertViaExt = 1\n\t\t} else {\n\t\t\tt.Error(errors.New(\"cast to ProcessorsStruct failed, how can this be!?\"))\n\t\t}\n\t}\n\n\tafterInsertFunc := func(bean interface{}) {\n\t\tif v, ok := (bean).(*ProcessorsStruct); ok {\n\t\t\tv.AfterInsertedViaExt = 1\n\t\t} else {\n\t\t\tt.Error(errors.New(\"cast to ProcessorsStruct failed, how can this be!?\"))\n\t\t}\n\t}\n\n\t_, err = testEngine.Before(b4InsertFunc).After(afterInsertFunc).Insert(p)\n\tassert.NoError(t, err)\n\tassert.True(t, p.Id > 0, \"Inserted ID not set\")\n\tassert.True(t, p.B4InsertFlag > 0, \"B4InsertFlag not set\")\n\tassert.True(t, p.AfterInsertedFlag > 0, \"B4InsertFlag not set\")\n\tassert.True(t, p.B4InsertViaExt > 0, \"B4InsertFlag not set\")\n\tassert.True(t, p.AfterInsertedViaExt > 0, \"AfterInsertedViaExt not set\")\n\n\tp2 := &ProcessorsStruct{}\n\thas, err := testEngine.ID(p.Id).Get(p2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.True(t, p2.B4InsertFlag > 0, \"B4InsertFlag not set\")\n\tassert.True(t, p2.AfterInsertedFlag == 0, \"AfterInsertedFlag is set\")\n\tassert.True(t, p2.B4InsertViaExt > 0, \"B4InsertViaExt not set\")\n\tassert.True(t, p2.AfterInsertedViaExt == 0, \"AfterInsertedViaExt is set\")\n\tassert.True(t, p2.BeforeSetFlag == 9, fmt.Sprintf(\"BeforeSetFlag is %d not 9\", p2.BeforeSetFlag))\n\tassert.True(t, p2.AfterSetFlag == 9, fmt.Sprintf(\"AfterSetFlag is %d not 9\", p2.BeforeSetFlag))\n\t// --\n\n\t// test find processors\n\tvar p2Find []*ProcessorsStruct\n\terr = testEngine.Find(&p2Find)\n\tassert.NoError(t, err)\n\n\tif len(p2Find) != 1 {\n\t\terr = errors.New(\"Should get 1\")\n\t\tt.Error(err)\n\t}\n\tp21 := p2Find[0]\n\tif p21.B4InsertFlag == 0 {\n\t\tt.Error(errors.New(\"B4InsertFlag not set\"))\n\t}\n\tif p21.AfterInsertedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterInsertedFlag is set\"))\n\t}\n\tif p21.B4InsertViaExt == 0 {\n\t\tt.Error(errors.New(\"B4InsertViaExt not set\"))\n\t}\n\tif p21.AfterInsertedViaExt != 0 {\n\t\tt.Error(errors.New(\"AfterInsertedViaExt is set\"))\n\t}\n\tif p21.BeforeSetFlag != 9 {\n\t\tt.Error(fmt.Errorf(\"BeforeSetFlag is %d not 9\", p21.BeforeSetFlag))\n\t}\n\tif p21.AfterSetFlag != 9 {\n\t\tt.Error(fmt.Errorf(\"AfterSetFlag is %d not 9\", p21.BeforeSetFlag))\n\t}\n\t// --\n\n\t// test find map processors\n\tvar p2FindMap = make(map[int64]*ProcessorsStruct)\n\terr = testEngine.Find(&p2FindMap)\n\tassert.NoError(t, err)\n\n\tif len(p2FindMap) != 1 {\n\t\terr = errors.New(\"Should get 1\")\n\t\tt.Error(err)\n\t}\n\tvar p22 *ProcessorsStruct\n\tfor _, v := range p2FindMap {\n\t\tp22 = v\n\t}\n\n\tif p22.B4InsertFlag == 0 {\n\t\tt.Error(errors.New(\"B4InsertFlag not set\"))\n\t}\n\tif p22.AfterInsertedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterInsertedFlag is set\"))\n\t}\n\tif p22.B4InsertViaExt == 0 {\n\t\tt.Error(errors.New(\"B4InsertViaExt not set\"))\n\t}\n\tif p22.AfterInsertedViaExt != 0 {\n\t\tt.Error(errors.New(\"AfterInsertedViaExt is set\"))\n\t}\n\tif p22.BeforeSetFlag != 9 {\n\t\tt.Error(fmt.Errorf(\"BeforeSetFlag is %d not 9\", p22.BeforeSetFlag))\n\t}\n\tif p22.AfterSetFlag != 9 {\n\t\tt.Error(fmt.Errorf(\"AfterSetFlag is %d not 9\", p22.BeforeSetFlag))\n\t}\n\t// --\n\n\t// test update processors\n\tb4UpdateFunc := func(bean interface{}) {\n\t\tif v, ok := (bean).(*ProcessorsStruct); ok {\n\t\t\tv.B4UpdateViaExt = 1\n\t\t} else {\n\t\t\tt.Error(errors.New(\"cast to ProcessorsStruct failed, how can this be!?\"))\n\t\t}\n\t}\n\n\tafterUpdateFunc := func(bean interface{}) {\n\t\tif v, ok := (bean).(*ProcessorsStruct); ok {\n\t\t\tv.AfterUpdatedViaExt = 1\n\t\t} else {\n\t\t\tt.Error(errors.New(\"cast to ProcessorsStruct failed, how can this be!?\"))\n\t\t}\n\t}\n\n\tp = p2 // reset\n\n\t_, err = testEngine.Before(b4UpdateFunc).After(afterUpdateFunc).Update(p)\n\tassert.NoError(t, err)\n\n\tif p.B4UpdateFlag == 0 {\n\t\tt.Error(errors.New(\"B4UpdateFlag not set\"))\n\t}\n\tif p.AfterUpdatedFlag == 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedFlag not set\"))\n\t}\n\tif p.B4UpdateViaExt == 0 {\n\t\tt.Error(errors.New(\"B4UpdateViaExt not set\"))\n\t}\n\tif p.AfterUpdatedViaExt == 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedViaExt not set\"))\n\t}\n\n\tp2 = &ProcessorsStruct{}\n\thas, err = testEngine.ID(p.Id).Get(p2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\tif p2.B4UpdateFlag == 0 {\n\t\tt.Error(errors.New(\"B4UpdateFlag not set\"))\n\t}\n\tif p2.AfterUpdatedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedFlag is set: \" + string(p.AfterUpdatedFlag)))\n\t}\n\tif p2.B4UpdateViaExt == 0 {\n\t\tt.Error(errors.New(\"B4UpdateViaExt not set\"))\n\t}\n\tif p2.AfterUpdatedViaExt != 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedViaExt is set: \" + string(p.AfterUpdatedViaExt)))\n\t}\n\tif p2.BeforeSetFlag != 9 {\n\t\tt.Error(fmt.Errorf(\"BeforeSetFlag is %d not 9\", p2.BeforeSetFlag))\n\t}\n\tif p2.AfterSetFlag != 9 {\n\t\tt.Error(fmt.Errorf(\"AfterSetFlag is %d not 9\", p2.BeforeSetFlag))\n\t}\n\t// --\n\n\t// test delete processors\n\tb4DeleteFunc := func(bean interface{}) {\n\t\tif v, ok := (bean).(*ProcessorsStruct); ok {\n\t\t\tv.B4DeleteViaExt = 1\n\t\t} else {\n\t\t\tt.Error(errors.New(\"cast to ProcessorsStruct failed, how can this be!?\"))\n\t\t}\n\t}\n\n\tafterDeleteFunc := func(bean interface{}) {\n\t\tif v, ok := (bean).(*ProcessorsStruct); ok {\n\t\t\tv.AfterDeletedViaExt = 1\n\t\t} else {\n\t\t\tt.Error(errors.New(\"cast to ProcessorsStruct failed, how can this be!?\"))\n\t\t}\n\t}\n\n\tp = p2 // reset\n\t_, err = testEngine.Before(b4DeleteFunc).After(afterDeleteFunc).Delete(p)\n\tassert.NoError(t, err)\n\tif p.B4DeleteFlag == 0 {\n\t\tt.Error(errors.New(\"B4DeleteFlag not set\"))\n\t}\n\tif p.AfterDeletedFlag == 0 {\n\t\tt.Error(errors.New(\"AfterDeletedFlag not set\"))\n\t}\n\tif p.B4DeleteViaExt == 0 {\n\t\tt.Error(errors.New(\"B4DeleteViaExt not set\"))\n\t}\n\tif p.AfterDeletedViaExt == 0 {\n\t\tt.Error(errors.New(\"AfterDeletedViaExt not set\"))\n\t}\n\t// --\n\n\t// test insert multi\n\tpslice := make([]*ProcessorsStruct, 0)\n\tpslice = append(pslice, &ProcessorsStruct{})\n\tpslice = append(pslice, &ProcessorsStruct{})\n\tcnt, err := testEngine.Before(b4InsertFunc).After(afterInsertFunc).Insert(&pslice)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, cnt, \"incorrect insert count\")\n\n\tfor _, elem := range pslice {\n\t\tif elem.B4InsertFlag == 0 {\n\t\t\tt.Error(errors.New(\"B4InsertFlag not set\"))\n\t\t}\n\t\tif elem.AfterInsertedFlag == 0 {\n\t\t\tt.Error(errors.New(\"B4InsertFlag not set\"))\n\t\t}\n\t\tif elem.B4InsertViaExt == 0 {\n\t\t\tt.Error(errors.New(\"B4InsertFlag not set\"))\n\t\t}\n\t\tif elem.AfterInsertedViaExt == 0 {\n\t\t\tt.Error(errors.New(\"AfterInsertedViaExt not set\"))\n\t\t}\n\t}\n\n\tfor _, elem := range pslice {\n\t\tp = &ProcessorsStruct{}\n\t\t_, err = testEngine.ID(elem.Id).Get(p)\n\t\tassert.NoError(t, err)\n\n\t\tif p2.B4InsertFlag == 0 {\n\t\t\tt.Error(errors.New(\"B4InsertFlag not set\"))\n\t\t}\n\t\tif p2.AfterInsertedFlag != 0 {\n\t\t\tt.Error(errors.New(\"AfterInsertedFlag is set\"))\n\t\t}\n\t\tif p2.B4InsertViaExt == 0 {\n\t\t\tt.Error(errors.New(\"B4InsertViaExt not set\"))\n\t\t}\n\t\tif p2.AfterInsertedViaExt != 0 {\n\t\t\tt.Error(errors.New(\"AfterInsertedViaExt is set\"))\n\t\t}\n\t\tif p2.BeforeSetFlag != 9 {\n\t\t\tt.Error(fmt.Errorf(\"BeforeSetFlag is %d not 9\", p2.BeforeSetFlag))\n\t\t}\n\t\tif p2.AfterSetFlag != 9 {\n\t\t\tt.Error(fmt.Errorf(\"AfterSetFlag is %d not 9\", p2.BeforeSetFlag))\n\t\t}\n\t}\n\t// --\n}\n\nfunc TestProcessorsTx(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&ProcessorsStruct{})\n\tassert.NoError(t, err)\n\n\terr = testEngine.CreateTables(&ProcessorsStruct{})\n\tassert.NoError(t, err)\n\n\t// test insert processors with tx rollback\n\tsession := testEngine.NewSession()\n\tdefer session.Close()\n\n\terr = session.Begin()\n\tassert.NoError(t, err)\n\n\tp := &ProcessorsStruct{}\n\tb4InsertFunc := func(bean interface{}) {\n\t\tif v, ok := (bean).(*ProcessorsStruct); ok {\n\t\t\tv.B4InsertViaExt = 1\n\t\t} else {\n\t\t\tt.Error(errors.New(\"cast to ProcessorsStruct failed, how can this be!?\"))\n\t\t}\n\t}\n\n\tafterInsertFunc := func(bean interface{}) {\n\t\tif v, ok := (bean).(*ProcessorsStruct); ok {\n\t\t\tv.AfterInsertedViaExt = 1\n\t\t} else {\n\t\t\tt.Error(errors.New(\"cast to ProcessorsStruct failed, how can this be!?\"))\n\t\t}\n\t}\n\t_, err = session.Before(b4InsertFunc).After(afterInsertFunc).Insert(p)\n\tassert.NoError(t, err)\n\n\tif p.B4InsertFlag == 0 {\n\t\tt.Error(errors.New(\"B4InsertFlag not set\"))\n\t}\n\tif p.AfterInsertedFlag != 0 {\n\t\tt.Error(errors.New(\"B4InsertFlag is set\"))\n\t}\n\tif p.B4InsertViaExt == 0 {\n\t\tt.Error(errors.New(\"B4InsertViaExt not set\"))\n\t}\n\tif p.AfterInsertedViaExt != 0 {\n\t\tt.Error(errors.New(\"AfterInsertedViaExt is set\"))\n\t}\n\n\terr = session.Rollback()\n\tassert.NoError(t, err)\n\n\tif p.B4InsertFlag == 0 {\n\t\tt.Error(errors.New(\"B4InsertFlag not set\"))\n\t}\n\tif p.AfterInsertedFlag != 0 {\n\t\tt.Error(errors.New(\"B4InsertFlag is set\"))\n\t}\n\tif p.B4InsertViaExt == 0 {\n\t\tt.Error(errors.New(\"B4InsertViaExt not set\"))\n\t}\n\tif p.AfterInsertedViaExt != 0 {\n\t\tt.Error(errors.New(\"AfterInsertedViaExt is set\"))\n\t}\n\n\tsession.Close()\n\n\tp2 := &ProcessorsStruct{}\n\t_, err = testEngine.ID(p.Id).Get(p2)\n\tassert.NoError(t, err)\n\n\tif p2.Id > 0 {\n\t\terr = errors.New(\"tx got committed upon insert!?\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\t// --\n\n\t// test insert processors with tx commit\n\tsession = testEngine.NewSession()\n\tdefer session.Close()\n\n\terr = session.Begin()\n\tassert.NoError(t, err)\n\n\tp = &ProcessorsStruct{}\n\t_, err = session.Before(b4InsertFunc).After(afterInsertFunc).Insert(p)\n\tassert.NoError(t, err)\n\n\tif p.B4InsertFlag == 0 {\n\t\tt.Error(errors.New(\"B4InsertFlag not set\"))\n\t}\n\tif p.AfterInsertedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterInsertedFlag is set\"))\n\t}\n\tif p.B4InsertViaExt == 0 {\n\t\tt.Error(errors.New(\"B4InsertViaExt not set\"))\n\t}\n\tif p.AfterInsertedViaExt != 0 {\n\t\tt.Error(errors.New(\"AfterInsertedViaExt is set\"))\n\t}\n\n\terr = session.Commit()\n\tassert.NoError(t, err)\n\n\tif p.B4InsertFlag == 0 {\n\t\tt.Error(errors.New(\"B4InsertFlag not set\"))\n\t}\n\tif p.AfterInsertedFlag == 0 {\n\t\tt.Error(errors.New(\"AfterInsertedFlag not set\"))\n\t}\n\tif p.B4InsertViaExt == 0 {\n\t\tt.Error(errors.New(\"B4InsertViaExt not set\"))\n\t}\n\tif p.AfterInsertedViaExt == 0 {\n\t\tt.Error(errors.New(\"AfterInsertedViaExt not set\"))\n\t}\n\n\tsession.Close()\n\tp2 = &ProcessorsStruct{}\n\t_, err = testEngine.ID(p.Id).Get(p2)\n\tassert.NoError(t, err)\n\n\tif p2.B4InsertFlag == 0 {\n\t\tt.Error(errors.New(\"B4InsertFlag not set\"))\n\t}\n\tif p2.AfterInsertedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterInsertedFlag is set\"))\n\t}\n\tif p2.B4InsertViaExt == 0 {\n\t\tt.Error(errors.New(\"B4InsertViaExt not set\"))\n\t}\n\tif p2.AfterInsertedViaExt != 0 {\n\t\tt.Error(errors.New(\"AfterInsertedViaExt is set\"))\n\t}\n\n\tinsertedId := p2.Id\n\t// --\n\n\t// test update processors with tx rollback\n\tsession = testEngine.NewSession()\n\tdefer session.Close()\n\n\terr = session.Begin()\n\tassert.NoError(t, err)\n\n\tb4UpdateFunc := func(bean interface{}) {\n\t\tif v, ok := (bean).(*ProcessorsStruct); ok {\n\t\t\tv.B4UpdateViaExt = 1\n\t\t} else {\n\t\t\tt.Error(errors.New(\"cast to ProcessorsStruct failed, how can this be!?\"))\n\t\t}\n\t}\n\n\tafterUpdateFunc := func(bean interface{}) {\n\t\tif v, ok := (bean).(*ProcessorsStruct); ok {\n\t\t\tv.AfterUpdatedViaExt = 1\n\t\t} else {\n\t\t\tt.Error(errors.New(\"cast to ProcessorsStruct failed, how can this be!?\"))\n\t\t}\n\t}\n\n\tp = p2 // reset\n\n\t_, err = session.ID(insertedId).Before(b4UpdateFunc).After(afterUpdateFunc).Update(p)\n\tassert.NoError(t, err)\n\n\tif p.B4UpdateFlag == 0 {\n\t\tt.Error(errors.New(\"B4UpdateFlag not set\"))\n\t}\n\tif p.AfterUpdatedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedFlag is set\"))\n\t}\n\tif p.B4UpdateViaExt == 0 {\n\t\tt.Error(errors.New(\"B4UpdateViaExt not set\"))\n\t}\n\tif p.AfterUpdatedViaExt != 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedViaExt is set\"))\n\t}\n\n\terr = session.Rollback()\n\tassert.NoError(t, err)\n\n\tif p.B4UpdateFlag == 0 {\n\t\tt.Error(errors.New(\"B4UpdateFlag not set\"))\n\t}\n\tif p.AfterUpdatedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedFlag is set\"))\n\t}\n\tif p.B4UpdateViaExt == 0 {\n\t\tt.Error(errors.New(\"B4UpdateViaExt not set\"))\n\t}\n\tif p.AfterUpdatedViaExt != 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedViaExt is set\"))\n\t}\n\n\tsession.Close()\n\n\tp2 = &ProcessorsStruct{}\n\t_, err = testEngine.ID(insertedId).Get(p2)\n\tassert.NoError(t, err)\n\n\tif p2.B4UpdateFlag != 0 {\n\t\tt.Error(errors.New(\"B4UpdateFlag is set\"))\n\t}\n\tif p2.AfterUpdatedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedFlag is set\"))\n\t}\n\tif p2.B4UpdateViaExt != 0 {\n\t\tt.Error(errors.New(\"B4UpdateViaExt not set\"))\n\t}\n\tif p2.AfterUpdatedViaExt != 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedViaExt is set\"))\n\t}\n\t// --\n\n\t// test update processors with tx rollback\n\tsession = testEngine.NewSession()\n\tdefer session.Close()\n\n\terr = session.Begin()\n\tassert.NoError(t, err)\n\n\tp = &ProcessorsStruct{Id: insertedId}\n\n\t_, err = session.Update(p)\n\tassert.NoError(t, err)\n\n\tif p.B4UpdateFlag == 0 {\n\t\tt.Error(errors.New(\"B4UpdateFlag not set\"))\n\t}\n\tif p.AfterUpdatedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedFlag is set\"))\n\t}\n\n\terr = session.Commit()\n\tassert.NoError(t, err)\n\n\tif p.B4UpdateFlag == 0 {\n\t\tt.Error(errors.New(\"B4UpdateFlag not set\"))\n\t}\n\tif p.AfterUpdatedFlag == 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedFlag not set\"))\n\t}\n\tif p.AfterDeletedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterDeletedFlag set\"))\n\t}\n\tif p.AfterInsertedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterInsertedFlag set\"))\n\t}\n\n\tsession.Close()\n\n\t// test update processors with tx commit\n\tsession = testEngine.NewSession()\n\tdefer session.Close()\n\n\terr = session.Begin()\n\tassert.NoError(t, err)\n\n\tp = &ProcessorsStruct{}\n\n\t_, err = session.ID(insertedId).Before(b4UpdateFunc).After(afterUpdateFunc).Update(p)\n\tassert.NoError(t, err)\n\n\tif p.B4UpdateFlag == 0 {\n\t\tt.Error(errors.New(\"B4UpdateFlag not set\"))\n\t}\n\tif p.AfterUpdatedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedFlag is set\"))\n\t}\n\tif p.B4UpdateViaExt == 0 {\n\t\tt.Error(errors.New(\"B4UpdateViaExt not set\"))\n\t}\n\tif p.AfterUpdatedViaExt != 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedViaExt is set\"))\n\t}\n\n\terr = session.Commit()\n\tassert.NoError(t, err)\n\n\tif p.B4UpdateFlag == 0 {\n\t\tt.Error(errors.New(\"B4UpdateFlag not set\"))\n\t}\n\tif p.AfterUpdatedFlag == 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedFlag not set\"))\n\t}\n\tif p.B4UpdateViaExt == 0 {\n\t\tt.Error(errors.New(\"B4UpdateViaExt not set\"))\n\t}\n\tif p.AfterUpdatedViaExt == 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedViaExt not set\"))\n\t}\n\n\tsession.Close()\n\tp2 = &ProcessorsStruct{}\n\t_, err = testEngine.ID(insertedId).Get(p2)\n\tassert.NoError(t, err)\n\n\tif p.B4UpdateFlag == 0 {\n\t\tt.Error(errors.New(\"B4UpdateFlag not set\"))\n\t}\n\tif p.AfterUpdatedFlag == 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedFlag not set\"))\n\t}\n\tif p.B4UpdateViaExt == 0 {\n\t\tt.Error(errors.New(\"B4UpdateViaExt not set\"))\n\t}\n\tif p.AfterUpdatedViaExt == 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedViaExt not set\"))\n\t}\n\t// --\n\n\t// test delete processors with tx rollback\n\tsession = testEngine.NewSession()\n\tdefer session.Close()\n\n\terr = session.Begin()\n\tassert.NoError(t, err)\n\n\tb4DeleteFunc := func(bean interface{}) {\n\t\tif v, ok := (bean).(*ProcessorsStruct); ok {\n\t\t\tv.B4DeleteViaExt = 1\n\t\t} else {\n\t\t\tt.Error(errors.New(\"cast to ProcessorsStruct failed, how can this be!?\"))\n\t\t}\n\t}\n\n\tafterDeleteFunc := func(bean interface{}) {\n\t\tif v, ok := (bean).(*ProcessorsStruct); ok {\n\t\t\tv.AfterDeletedViaExt = 1\n\t\t} else {\n\t\t\tt.Error(errors.New(\"cast to ProcessorsStruct failed, how can this be!?\"))\n\t\t}\n\t}\n\n\tp = &ProcessorsStruct{} // reset\n\n\t_, err = session.ID(insertedId).Before(b4DeleteFunc).After(afterDeleteFunc).Delete(p)\n\tassert.NoError(t, err)\n\n\tif p.B4DeleteFlag == 0 {\n\t\tt.Error(errors.New(\"B4DeleteFlag not set\"))\n\t}\n\tif p.AfterDeletedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterDeletedFlag is set\"))\n\t}\n\tif p.B4DeleteViaExt == 0 {\n\t\tt.Error(errors.New(\"B4DeleteViaExt not set\"))\n\t}\n\tif p.AfterDeletedViaExt != 0 {\n\t\tt.Error(errors.New(\"AfterDeletedViaExt is set\"))\n\t}\n\n\terr = session.Rollback()\n\tassert.NoError(t, err)\n\tif p.B4DeleteFlag == 0 {\n\t\tt.Error(errors.New(\"B4DeleteFlag not set\"))\n\t}\n\tif p.AfterDeletedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterDeletedFlag is set\"))\n\t}\n\tif p.B4DeleteViaExt == 0 {\n\t\tt.Error(errors.New(\"B4DeleteViaExt not set\"))\n\t}\n\tif p.AfterDeletedViaExt != 0 {\n\t\tt.Error(errors.New(\"AfterDeletedViaExt is set\"))\n\t}\n\n\tsession.Close()\n\n\tp2 = &ProcessorsStruct{}\n\t_, err = testEngine.ID(insertedId).Get(p2)\n\tassert.NoError(t, err)\n\n\tif p2.B4DeleteFlag != 0 {\n\t\tt.Error(errors.New(\"B4DeleteFlag is set\"))\n\t}\n\tif p2.AfterDeletedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterDeletedFlag is set\"))\n\t}\n\tif p2.B4DeleteViaExt != 0 {\n\t\tt.Error(errors.New(\"B4DeleteViaExt is set\"))\n\t}\n\tif p2.AfterDeletedViaExt != 0 {\n\t\tt.Error(errors.New(\"AfterDeletedViaExt is set\"))\n\t}\n\t// --\n\n\t// test delete processors with tx commit\n\tsession = testEngine.NewSession()\n\tdefer session.Close()\n\n\terr = session.Begin()\n\tassert.NoError(t, err)\n\n\tp = &ProcessorsStruct{}\n\n\t_, err = session.ID(insertedId).Before(b4DeleteFunc).After(afterDeleteFunc).Delete(p)\n\tassert.NoError(t, err)\n\n\tif p.B4DeleteFlag == 0 {\n\t\tt.Error(errors.New(\"B4DeleteFlag not set\"))\n\t}\n\tif p.AfterDeletedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterDeletedFlag is set\"))\n\t}\n\tif p.B4DeleteViaExt == 0 {\n\t\tt.Error(errors.New(\"B4DeleteViaExt not set\"))\n\t}\n\tif p.AfterDeletedViaExt != 0 {\n\t\tt.Error(errors.New(\"AfterDeletedViaExt is set\"))\n\t}\n\n\terr = session.Commit()\n\tassert.NoError(t, err)\n\n\tif p.B4DeleteFlag == 0 {\n\t\tt.Error(errors.New(\"B4DeleteFlag not set\"))\n\t}\n\tif p.AfterDeletedFlag == 0 {\n\t\tt.Error(errors.New(\"AfterDeletedFlag not set\"))\n\t}\n\tif p.B4DeleteViaExt == 0 {\n\t\tt.Error(errors.New(\"B4DeleteViaExt not set\"))\n\t}\n\tif p.AfterDeletedViaExt == 0 {\n\t\tt.Error(errors.New(\"AfterDeletedViaExt not set\"))\n\t}\n\n\tsession.Close()\n\n\t// test delete processors with tx commit\n\tsession = testEngine.NewSession()\n\tdefer session.Close()\n\n\terr = session.Begin()\n\tassert.NoError(t, err)\n\n\tp = &ProcessorsStruct{Id: insertedId}\n\t_, err = session.Delete(p)\n\tassert.NoError(t, err)\n\n\tif p.B4DeleteFlag == 0 {\n\t\tt.Error(errors.New(\"B4DeleteFlag not set\"))\n\t}\n\tif p.AfterDeletedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterDeletedFlag is set\"))\n\t}\n\n\terr = session.Commit()\n\tassert.NoError(t, err)\n\n\tif p.B4DeleteFlag == 0 {\n\t\tt.Error(errors.New(\"B4DeleteFlag not set\"))\n\t}\n\tif p.AfterDeletedFlag == 0 {\n\t\tt.Error(errors.New(\"AfterDeletedFlag not set\"))\n\t}\n\tif p.AfterInsertedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterInsertedFlag set\"))\n\t}\n\tif p.AfterUpdatedFlag != 0 {\n\t\tt.Error(errors.New(\"AfterUpdatedFlag set\"))\n\t}\n\tsession.Close()\n\t// --\n}\n\ntype AfterLoadStructA struct {\n\tId      int64\n\tContent string\n}\n\ntype AfterLoadStructB struct {\n\tId      int64\n\tContent string\n\tAId     int64\n\tA       AfterLoadStructA `xorm:\"-\"`\n\tErr     error            `xorm:\"-\"`\n}\n\nfunc (s *AfterLoadStructB) AfterLoad(session *Session) {\n\thas, err := session.ID(s.AId).NoAutoCondition().Get(&s.A)\n\tif err != nil {\n\t\ts.Err = err\n\t\treturn\n\t}\n\tif !has {\n\t\ts.Err = ErrNotExist\n\t}\n}\n\nfunc TestAfterLoadProcessor(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tassertSync(t, new(AfterLoadStructA), new(AfterLoadStructB))\n\n\tvar a = AfterLoadStructA{\n\t\tContent: \"testa\",\n\t}\n\t_, err := testEngine.Insert(&a)\n\tassert.NoError(t, err)\n\n\tvar b = AfterLoadStructB{\n\t\tContent: \"testb\",\n\t\tAId:     a.Id,\n\t}\n\t_, err = testEngine.Insert(&b)\n\tassert.NoError(t, err)\n\n\tvar b2 AfterLoadStructB\n\thas, err := testEngine.ID(b.Id).Get(&b2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, a.Id, b2.A.Id)\n\tassert.EqualValues(t, a.Content, b2.A.Content)\n\tassert.NoError(t, b2.Err)\n\n\tb.Id = 0\n\t_, err = testEngine.Insert(&b)\n\tassert.NoError(t, err)\n\n\tvar bs []AfterLoadStructB\n\terr = testEngine.Find(&bs)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, len(bs))\n\tfor i := 0; i < len(bs); i++ {\n\t\tassert.EqualValues(t, a.Id, bs[i].A.Id)\n\t\tassert.EqualValues(t, a.Content, bs[i].A.Content)\n\t\tassert.NoError(t, bs[i].Err)\n\t}\n}\n\ntype AfterInsertStruct struct {\n\tId int64\n}\n\nfunc (a *AfterInsertStruct) AfterInsert() {\n\tif a.Id == 0 {\n\t\tpanic(\"a.Id\")\n\t}\n}\n\nfunc TestAfterInsert(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tassertSync(t, new(AfterInsertStruct))\n\n\t_, err := testEngine.Insert(&AfterInsertStruct{})\n\tassert.NoError(t, err)\n}\n"
        },
        {
          "name": "rows.go",
          "type": "blob",
          "size": 2.5849609375,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"xorm.io/core\"\n)\n\n// Rows rows wrapper a rows to\ntype Rows struct {\n\tsession   *Session\n\trows      *core.Rows\n\tbeanType  reflect.Type\n\tlastError error\n}\n\nfunc newRows(session *Session, bean interface{}) (*Rows, error) {\n\trows := new(Rows)\n\trows.session = session\n\trows.beanType = reflect.Indirect(reflect.ValueOf(bean)).Type()\n\n\tvar sqlStr string\n\tvar args []interface{}\n\tvar err error\n\n\tif err = rows.session.statement.setRefBean(bean); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(session.statement.TableName()) <= 0 {\n\t\treturn nil, ErrTableNotFound\n\t}\n\n\tif rows.session.statement.RawSQL == \"\" {\n\t\tsqlStr, args, err = rows.session.statement.genGetSQL(bean)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tsqlStr = rows.session.statement.RawSQL\n\t\targs = rows.session.statement.RawParams\n\t}\n\n\trows.rows, err = rows.session.queryRows(sqlStr, args...)\n\tif err != nil {\n\t\trows.lastError = err\n\t\trows.Close()\n\t\treturn nil, err\n\t}\n\n\treturn rows, nil\n}\n\n// Next move cursor to next record, return false if end has reached\nfunc (rows *Rows) Next() bool {\n\tif rows.lastError == nil && rows.rows != nil {\n\t\thasNext := rows.rows.Next()\n\t\tif !hasNext {\n\t\t\trows.lastError = sql.ErrNoRows\n\t\t}\n\t\treturn hasNext\n\t}\n\treturn false\n}\n\n// Err returns the error, if any, that was encountered during iteration. Err may be called after an explicit or implicit Close.\nfunc (rows *Rows) Err() error {\n\treturn rows.lastError\n}\n\n// Scan row record to bean properties\nfunc (rows *Rows) Scan(bean interface{}) error {\n\tif rows.lastError != nil {\n\t\treturn rows.lastError\n\t}\n\n\tif reflect.Indirect(reflect.ValueOf(bean)).Type() != rows.beanType {\n\t\treturn fmt.Errorf(\"scan arg is incompatible type to [%v]\", rows.beanType)\n\t}\n\n\tif err := rows.session.statement.setRefBean(bean); err != nil {\n\t\treturn err\n\t}\n\n\tfields, err := rows.rows.Columns()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tscanResults, err := rows.session.row2Slice(rows.rows, fields, bean)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdataStruct := rValue(bean)\n\t_, err = rows.session.slice2Bean(scanResults, fields, bean, &dataStruct, rows.session.statement.RefTable)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn rows.session.executeProcessors()\n}\n\n// Close session if session.IsAutoClose is true, and claimed any opened resources\nfunc (rows *Rows) Close() error {\n\tif rows.session.isAutoClose {\n\t\tdefer rows.session.Close()\n\t}\n\n\tif rows.rows != nil {\n\t\treturn rows.rows.Close()\n\t}\n\n\treturn rows.lastError\n}\n"
        },
        {
          "name": "rows_test.go",
          "type": "blob",
          "size": 2.955078125,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestRows(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UserRows struct {\n\t\tId    int64\n\t\tIsMan bool\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(UserRows)))\n\n\tcnt, err := testEngine.Insert(&UserRows{\n\t\tIsMan: true,\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\trows, err := testEngine.Rows(new(UserRows))\n\tassert.NoError(t, err)\n\tdefer rows.Close()\n\n\tcnt = 0\n\tuser := new(UserRows)\n\tfor rows.Next() {\n\t\terr = rows.Scan(user)\n\t\tassert.NoError(t, err)\n\t\tcnt++\n\t}\n\tassert.EqualValues(t, 1, cnt)\n\tassert.False(t, rows.Next())\n\tassert.NoError(t, rows.Close())\n\n\trows0, err := testEngine.Where(\"1>1\").Rows(new(UserRows))\n\tassert.NoError(t, err)\n\tdefer rows0.Close()\n\n\tcnt = 0\n\tuser0 := new(UserRows)\n\tfor rows0.Next() {\n\t\terr = rows0.Scan(user0)\n\t\tassert.NoError(t, err)\n\t\tcnt++\n\t}\n\tassert.EqualValues(t, 0, cnt)\n\tassert.NoError(t, rows0.Close())\n\n\tsess := testEngine.NewSession()\n\tdefer sess.Close()\n\n\trows1, err := sess.Prepare().Rows(new(UserRows))\n\tassert.NoError(t, err)\n\tdefer rows1.Close()\n\n\tcnt = 0\n\tfor rows1.Next() {\n\t\terr = rows1.Scan(user)\n\t\tassert.NoError(t, err)\n\t\tcnt++\n\t}\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar tbName = testEngine.Quote(testEngine.TableName(user, true))\n\trows2, err := testEngine.SQL(\"SELECT * FROM \" + tbName).Rows(new(UserRows))\n\tassert.NoError(t, err)\n\tdefer rows2.Close()\n\n\tcnt = 0\n\tfor rows2.Next() {\n\t\terr = rows2.Scan(user)\n\t\tassert.NoError(t, err)\n\t\tcnt++\n\t}\n\tassert.EqualValues(t, 1, cnt)\n}\n\nfunc TestRowsMyTableName(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UserRowsMyTable struct {\n\t\tId    int64\n\t\tIsMan bool\n\t}\n\n\tvar tableName = \"user_rows_my_table_name\"\n\n\tassert.NoError(t, testEngine.Table(tableName).Sync2(new(UserRowsMyTable)))\n\n\tcnt, err := testEngine.Table(tableName).Insert(&UserRowsMyTable{\n\t\tIsMan: true,\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\trows, err := testEngine.Table(tableName).Rows(new(UserRowsMyTable))\n\tassert.NoError(t, err)\n\tdefer rows.Close()\n\n\tcnt = 0\n\tuser := new(UserRowsMyTable)\n\tfor rows.Next() {\n\t\terr = rows.Scan(user)\n\t\tassert.NoError(t, err)\n\t\tcnt++\n\t}\n\tassert.EqualValues(t, 1, cnt)\n}\n\ntype UserRowsSpecTable struct {\n\tId    int64\n\tIsMan bool\n}\n\nfunc (UserRowsSpecTable) TableName() string {\n\treturn \"user_rows_my_table_name\"\n}\n\nfunc TestRowsSpecTableName(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassert.NoError(t, testEngine.Sync2(new(UserRowsSpecTable)))\n\n\tcnt, err := testEngine.Insert(&UserRowsSpecTable{\n\t\tIsMan: true,\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\trows, err := testEngine.Rows(new(UserRowsSpecTable))\n\tassert.NoError(t, err)\n\tdefer rows.Close()\n\n\tcnt = 0\n\tuser := new(UserRowsSpecTable)\n\tfor rows.Next() {\n\t\terr = rows.Scan(user)\n\t\tassert.NoError(t, err)\n\t\tcnt++\n\t}\n\tassert.EqualValues(t, 1, cnt)\n}\n"
        },
        {
          "name": "session.go",
          "type": "blob",
          "size": 24.1220703125,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash/crc32\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n\n\t\"xorm.io/core\"\n)\n\ntype sessionType int\n\nconst (\n\tengineSession sessionType = iota\n\tgroupSession\n)\n\n// Session keep a pointer to sql.DB and provides all execution of all\n// kind of database operations.\ntype Session struct {\n\tdb                     *core.DB\n\tengine                 *Engine\n\ttx                     *core.Tx\n\tstatement              Statement\n\tisAutoCommit           bool\n\tisCommitedOrRollbacked bool\n\tisAutoClose            bool\n\n\t// Automatically reset the statement after operations that execute a SQL\n\t// query such as Count(), Find(), Get(), ...\n\tautoResetStatement bool\n\n\t// !nashtsai! storing these beans due to yet committed tx\n\tafterInsertBeans map[interface{}]*[]func(interface{})\n\tafterUpdateBeans map[interface{}]*[]func(interface{})\n\tafterDeleteBeans map[interface{}]*[]func(interface{})\n\t// --\n\n\tbeforeClosures []func(interface{})\n\tafterClosures  []func(interface{})\n\n\tafterProcessors []executedProcessor\n\n\tprepareStmt bool\n\tstmtCache   map[uint32]*core.Stmt //key: hash.Hash32 of (queryStr, len(queryStr))\n\n\t// !evalphobia! stored the last executed query on this session\n\t//beforeSQLExec func(string, ...interface{})\n\tlastSQL     string\n\tlastSQLArgs []interface{}\n\n\tctx         context.Context\n\tsessionType sessionType\n}\n\n// Clone copy all the session's content and return a new session\nfunc (session *Session) Clone() *Session {\n\tvar sess = *session\n\treturn &sess\n}\n\n// Init reset the session as the init status.\nfunc (session *Session) Init() {\n\tsession.statement.Init()\n\tsession.statement.Engine = session.engine\n\tsession.isAutoCommit = true\n\tsession.isCommitedOrRollbacked = false\n\tsession.isAutoClose = false\n\tsession.autoResetStatement = true\n\tsession.prepareStmt = false\n\n\t// !nashtsai! is lazy init better?\n\tsession.afterInsertBeans = make(map[interface{}]*[]func(interface{}), 0)\n\tsession.afterUpdateBeans = make(map[interface{}]*[]func(interface{}), 0)\n\tsession.afterDeleteBeans = make(map[interface{}]*[]func(interface{}), 0)\n\tsession.beforeClosures = make([]func(interface{}), 0)\n\tsession.afterClosures = make([]func(interface{}), 0)\n\tsession.stmtCache = make(map[uint32]*core.Stmt)\n\n\tsession.afterProcessors = make([]executedProcessor, 0)\n\n\tsession.lastSQL = \"\"\n\tsession.lastSQLArgs = []interface{}{}\n\n\tsession.ctx = session.engine.defaultContext\n}\n\n// Close release the connection from pool\nfunc (session *Session) Close() {\n\tfor _, v := range session.stmtCache {\n\t\tv.Close()\n\t}\n\n\tif session.db != nil {\n\t\t// When Close be called, if session is a transaction and do not call\n\t\t// Commit or Rollback, then call Rollback.\n\t\tif session.tx != nil && !session.isCommitedOrRollbacked {\n\t\t\tsession.Rollback()\n\t\t}\n\t\tsession.tx = nil\n\t\tsession.stmtCache = nil\n\t\tsession.db = nil\n\t}\n}\n\n// ContextCache enable context cache or not\nfunc (session *Session) ContextCache(context ContextCache) *Session {\n\tsession.statement.context = context\n\treturn session\n}\n\n// IsClosed returns if session is closed\nfunc (session *Session) IsClosed() bool {\n\treturn session.db == nil\n}\n\nfunc (session *Session) resetStatement() {\n\tif session.autoResetStatement {\n\t\tsession.statement.Init()\n\t}\n}\n\n// Prepare set a flag to session that should be prepare statement before execute query\nfunc (session *Session) Prepare() *Session {\n\tsession.prepareStmt = true\n\treturn session\n}\n\n// Before Apply before Processor, affected bean is passed to closure arg\nfunc (session *Session) Before(closures func(interface{})) *Session {\n\tif closures != nil {\n\t\tsession.beforeClosures = append(session.beforeClosures, closures)\n\t}\n\treturn session\n}\n\n// After Apply after Processor, affected bean is passed to closure arg\nfunc (session *Session) After(closures func(interface{})) *Session {\n\tif closures != nil {\n\t\tsession.afterClosures = append(session.afterClosures, closures)\n\t}\n\treturn session\n}\n\n// Table can input a string or pointer to struct for special a table to operate.\nfunc (session *Session) Table(tableNameOrBean interface{}) *Session {\n\tsession.statement.Table(tableNameOrBean)\n\treturn session\n}\n\n// Alias set the table alias\nfunc (session *Session) Alias(alias string) *Session {\n\tsession.statement.Alias(alias)\n\treturn session\n}\n\n// NoCascade indicate that no cascade load child object\nfunc (session *Session) NoCascade() *Session {\n\tsession.statement.UseCascade = false\n\treturn session\n}\n\n// ForUpdate Set Read/Write locking for UPDATE\nfunc (session *Session) ForUpdate() *Session {\n\tsession.statement.IsForUpdate = true\n\treturn session\n}\n\n// NoAutoCondition disable generate SQL condition from beans\nfunc (session *Session) NoAutoCondition(no ...bool) *Session {\n\tsession.statement.NoAutoCondition(no...)\n\treturn session\n}\n\n// Limit provide limit and offset query condition\nfunc (session *Session) Limit(limit int, start ...int) *Session {\n\tsession.statement.Limit(limit, start...)\n\treturn session\n}\n\n// OrderBy provide order by query condition, the input parameter is the content\n// after order by on a sql statement.\nfunc (session *Session) OrderBy(order string) *Session {\n\tsession.statement.OrderBy(order)\n\treturn session\n}\n\n// Desc provide desc order by query condition, the input parameters are columns.\nfunc (session *Session) Desc(colNames ...string) *Session {\n\tsession.statement.Desc(colNames...)\n\treturn session\n}\n\n// Asc provide asc order by query condition, the input parameters are columns.\nfunc (session *Session) Asc(colNames ...string) *Session {\n\tsession.statement.Asc(colNames...)\n\treturn session\n}\n\n// StoreEngine is only avialble mysql dialect currently\nfunc (session *Session) StoreEngine(storeEngine string) *Session {\n\tsession.statement.StoreEngine = storeEngine\n\treturn session\n}\n\n// Charset is only avialble mysql dialect currently\nfunc (session *Session) Charset(charset string) *Session {\n\tsession.statement.Charset = charset\n\treturn session\n}\n\n// Cascade indicates if loading sub Struct\nfunc (session *Session) Cascade(trueOrFalse ...bool) *Session {\n\tif len(trueOrFalse) >= 1 {\n\t\tsession.statement.UseCascade = trueOrFalse[0]\n\t}\n\treturn session\n}\n\n// NoCache ask this session do not retrieve data from cache system and\n// get data from database directly.\nfunc (session *Session) NoCache() *Session {\n\tsession.statement.UseCache = false\n\treturn session\n}\n\n// Join join_operator should be one of INNER, LEFT OUTER, CROSS etc - this will be prepended to JOIN\nfunc (session *Session) Join(joinOperator string, tablename interface{}, condition string, args ...interface{}) *Session {\n\tsession.statement.Join(joinOperator, tablename, condition, args...)\n\treturn session\n}\n\n// GroupBy Generate Group By statement\nfunc (session *Session) GroupBy(keys string) *Session {\n\tsession.statement.GroupBy(keys)\n\treturn session\n}\n\n// Having Generate Having statement\nfunc (session *Session) Having(conditions string) *Session {\n\tsession.statement.Having(conditions)\n\treturn session\n}\n\n// DB db return the wrapper of sql.DB\nfunc (session *Session) DB() *core.DB {\n\tif session.db == nil {\n\t\tsession.db = session.engine.db\n\t\tsession.stmtCache = make(map[uint32]*core.Stmt, 0)\n\t}\n\treturn session.db\n}\n\nfunc cleanupProcessorsClosures(slices *[]func(interface{})) {\n\tif len(*slices) > 0 {\n\t\t*slices = make([]func(interface{}), 0)\n\t}\n}\n\nfunc (session *Session) canCache() bool {\n\tif session.statement.RefTable == nil ||\n\t\tsession.statement.JoinStr != \"\" ||\n\t\tsession.statement.RawSQL != \"\" ||\n\t\t!session.statement.UseCache ||\n\t\tsession.statement.IsForUpdate ||\n\t\tsession.tx != nil ||\n\t\tlen(session.statement.selectStr) > 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (session *Session) doPrepare(db *core.DB, sqlStr string) (stmt *core.Stmt, err error) {\n\tcrc := crc32.ChecksumIEEE([]byte(sqlStr))\n\t// TODO try hash(sqlStr+len(sqlStr))\n\tvar has bool\n\tstmt, has = session.stmtCache[crc]\n\tif !has {\n\t\tstmt, err = db.PrepareContext(session.ctx, sqlStr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tsession.stmtCache[crc] = stmt\n\t}\n\treturn\n}\n\nfunc (session *Session) getField(dataStruct *reflect.Value, key string, table *core.Table, idx int) (*reflect.Value, error) {\n\tvar col *core.Column\n\tif col = table.GetColumnIdx(key, idx); col == nil {\n\t\treturn nil, ErrFieldIsNotExist{key, table.Name}\n\t}\n\n\tfieldValue, err := col.ValueOfV(dataStruct)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !fieldValue.IsValid() || !fieldValue.CanSet() {\n\t\treturn nil, ErrFieldIsNotValid{key, table.Name}\n\t}\n\n\treturn fieldValue, nil\n}\n\n// Cell cell is a result of one column field\ntype Cell *interface{}\n\nfunc (session *Session) rows2Beans(rows *core.Rows, fields []string,\n\ttable *core.Table, newElemFunc func([]string) reflect.Value,\n\tsliceValueSetFunc func(*reflect.Value, core.PK) error) error {\n\tfor rows.Next() {\n\t\tvar newValue = newElemFunc(fields)\n\t\tbean := newValue.Interface()\n\t\tdataStruct := newValue.Elem()\n\n\t\t// handle beforeClosures\n\t\tscanResults, err := session.row2Slice(rows, fields, bean)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpk, err := session.slice2Bean(scanResults, fields, bean, &dataStruct, table)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsession.afterProcessors = append(session.afterProcessors, executedProcessor{\n\t\t\tfun: func(*Session, interface{}) error {\n\t\t\t\treturn sliceValueSetFunc(&newValue, pk)\n\t\t\t},\n\t\t\tsession: session,\n\t\t\tbean:    bean,\n\t\t})\n\t}\n\treturn nil\n}\n\nfunc (session *Session) row2Slice(rows *core.Rows, fields []string, bean interface{}) ([]interface{}, error) {\n\tfor _, closure := range session.beforeClosures {\n\t\tclosure(bean)\n\t}\n\n\tscanResults := make([]interface{}, len(fields))\n\tfor i := 0; i < len(fields); i++ {\n\t\tvar cell interface{}\n\t\tscanResults[i] = &cell\n\t}\n\tif err := rows.Scan(scanResults...); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif b, hasBeforeSet := bean.(BeforeSetProcessor); hasBeforeSet {\n\t\tfor ii, key := range fields {\n\t\t\tb.BeforeSet(key, Cell(scanResults[ii].(*interface{})))\n\t\t}\n\t}\n\treturn scanResults, nil\n}\n\nfunc (session *Session) slice2Bean(scanResults []interface{}, fields []string, bean interface{}, dataStruct *reflect.Value, table *core.Table) (core.PK, error) {\n\tdefer func() {\n\t\tif b, hasAfterSet := bean.(AfterSetProcessor); hasAfterSet {\n\t\t\tfor ii, key := range fields {\n\t\t\t\tb.AfterSet(key, Cell(scanResults[ii].(*interface{})))\n\t\t\t}\n\t\t}\n\t}()\n\n\t// handle afterClosures\n\tfor _, closure := range session.afterClosures {\n\t\tsession.afterProcessors = append(session.afterProcessors, executedProcessor{\n\t\t\tfun: func(sess *Session, bean interface{}) error {\n\t\t\t\tclosure(bean)\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tsession: session,\n\t\t\tbean:    bean,\n\t\t})\n\t}\n\n\tif a, has := bean.(AfterLoadProcessor); has {\n\t\tsession.afterProcessors = append(session.afterProcessors, executedProcessor{\n\t\t\tfun: func(sess *Session, bean interface{}) error {\n\t\t\t\ta.AfterLoad()\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tsession: session,\n\t\t\tbean:    bean,\n\t\t})\n\t}\n\n\tif a, has := bean.(AfterLoadSessionProcessor); has {\n\t\tsession.afterProcessors = append(session.afterProcessors, executedProcessor{\n\t\t\tfun: func(sess *Session, bean interface{}) error {\n\t\t\t\ta.AfterLoad(sess)\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tsession: session,\n\t\t\tbean:    bean,\n\t\t})\n\t}\n\n\tvar tempMap = make(map[string]int)\n\tvar pk core.PK\n\tfor ii, key := range fields {\n\t\tvar idx int\n\t\tvar ok bool\n\t\tvar lKey = strings.ToLower(key)\n\t\tif idx, ok = tempMap[lKey]; !ok {\n\t\t\tidx = 0\n\t\t} else {\n\t\t\tidx = idx + 1\n\t\t}\n\t\ttempMap[lKey] = idx\n\n\t\tfieldValue, err := session.getField(dataStruct, key, table, idx)\n\t\tif err != nil {\n\t\t\tif !strings.Contains(err.Error(), \"is not valid\") {\n\t\t\t\tsession.engine.logger.Warn(err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif fieldValue == nil {\n\t\t\tcontinue\n\t\t}\n\t\trawValue := reflect.Indirect(reflect.ValueOf(scanResults[ii]))\n\n\t\t// if row is null then ignore\n\t\tif rawValue.Interface() == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif fieldValue.CanAddr() {\n\t\t\tif structConvert, ok := fieldValue.Addr().Interface().(core.Conversion); ok {\n\t\t\t\tif data, err := value2Bytes(&rawValue); err == nil {\n\t\t\t\t\tif err := structConvert.FromDB(data); err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif _, ok := fieldValue.Interface().(core.Conversion); ok {\n\t\t\tif data, err := value2Bytes(&rawValue); err == nil {\n\t\t\t\tif fieldValue.Kind() == reflect.Ptr && fieldValue.IsNil() {\n\t\t\t\t\tfieldValue.Set(reflect.New(fieldValue.Type().Elem()))\n\t\t\t\t}\n\t\t\t\tfieldValue.Interface().(core.Conversion).FromDB(data)\n\t\t\t} else {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\trawValueType := reflect.TypeOf(rawValue.Interface())\n\t\tvv := reflect.ValueOf(rawValue.Interface())\n\t\tcol := table.GetColumnIdx(key, idx)\n\t\tif col.IsPrimaryKey {\n\t\t\tpk = append(pk, rawValue.Interface())\n\t\t}\n\t\tfieldType := fieldValue.Type()\n\t\thasAssigned := false\n\n\t\tif col.SQLType.IsJson() {\n\t\t\tvar bs []byte\n\t\t\tif rawValueType.Kind() == reflect.String {\n\t\t\t\tbs = []byte(vv.String())\n\t\t\t} else if rawValueType.ConvertibleTo(core.BytesType) {\n\t\t\t\tbs = vv.Bytes()\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"unsupported database data type: %s %v\", key, rawValueType.Kind())\n\t\t\t}\n\n\t\t\thasAssigned = true\n\n\t\t\tif len(bs) > 0 {\n\t\t\t\tif fieldType.Kind() == reflect.String {\n\t\t\t\t\tfieldValue.SetString(string(bs))\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif fieldValue.CanAddr() {\n\t\t\t\t\terr := DefaultJSONHandler.Unmarshal(bs, fieldValue.Addr().Interface())\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tx := reflect.New(fieldType)\n\t\t\t\t\terr := DefaultJSONHandler.Unmarshal(bs, x.Interface())\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\tfieldValue.Set(x.Elem())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch fieldType.Kind() {\n\t\tcase reflect.Complex64, reflect.Complex128:\n\t\t\t// TODO: reimplement this\n\t\t\tvar bs []byte\n\t\t\tif rawValueType.Kind() == reflect.String {\n\t\t\t\tbs = []byte(vv.String())\n\t\t\t} else if rawValueType.ConvertibleTo(core.BytesType) {\n\t\t\t\tbs = vv.Bytes()\n\t\t\t}\n\n\t\t\thasAssigned = true\n\t\t\tif len(bs) > 0 {\n\t\t\t\tif fieldValue.CanAddr() {\n\t\t\t\t\terr := DefaultJSONHandler.Unmarshal(bs, fieldValue.Addr().Interface())\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tx := reflect.New(fieldType)\n\t\t\t\t\terr := DefaultJSONHandler.Unmarshal(bs, x.Interface())\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\tfieldValue.Set(x.Elem())\n\t\t\t\t}\n\t\t\t}\n\t\tcase reflect.Slice, reflect.Array:\n\t\t\tswitch rawValueType.Kind() {\n\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\tswitch rawValueType.Elem().Kind() {\n\t\t\t\tcase reflect.Uint8:\n\t\t\t\t\tif fieldType.Elem().Kind() == reflect.Uint8 {\n\t\t\t\t\t\thasAssigned = true\n\t\t\t\t\t\tif col.SQLType.IsText() {\n\t\t\t\t\t\t\tx := reflect.New(fieldType)\n\t\t\t\t\t\t\terr := DefaultJSONHandler.Unmarshal(vv.Bytes(), x.Interface())\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfieldValue.Set(x.Elem())\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif fieldValue.Len() > 0 {\n\t\t\t\t\t\t\t\tfor i := 0; i < fieldValue.Len(); i++ {\n\t\t\t\t\t\t\t\t\tif i < vv.Len() {\n\t\t\t\t\t\t\t\t\t\tfieldValue.Index(i).Set(vv.Index(i))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor i := 0; i < vv.Len(); i++ {\n\t\t\t\t\t\t\t\t\tfieldValue.Set(reflect.Append(*fieldValue, vv.Index(i)))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcase reflect.String:\n\t\t\tif rawValueType.Kind() == reflect.String {\n\t\t\t\thasAssigned = true\n\t\t\t\tfieldValue.SetString(vv.String())\n\t\t\t}\n\t\tcase reflect.Bool:\n\t\t\tif rawValueType.Kind() == reflect.Bool {\n\t\t\t\thasAssigned = true\n\t\t\t\tfieldValue.SetBool(vv.Bool())\n\t\t\t}\n\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\t\tswitch rawValueType.Kind() {\n\t\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\t\t\thasAssigned = true\n\t\t\t\tfieldValue.SetInt(vv.Int())\n\t\t\t}\n\t\tcase reflect.Float32, reflect.Float64:\n\t\t\tswitch rawValueType.Kind() {\n\t\t\tcase reflect.Float32, reflect.Float64:\n\t\t\t\thasAssigned = true\n\t\t\t\tfieldValue.SetFloat(vv.Float())\n\t\t\t}\n\t\tcase reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:\n\t\t\tswitch rawValueType.Kind() {\n\t\t\tcase reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:\n\t\t\t\thasAssigned = true\n\t\t\t\tfieldValue.SetUint(vv.Uint())\n\t\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\t\t\thasAssigned = true\n\t\t\t\tfieldValue.SetUint(uint64(vv.Int()))\n\t\t\t}\n\t\tcase reflect.Struct:\n\t\t\tif fieldType.ConvertibleTo(core.TimeType) {\n\t\t\t\tdbTZ := session.engine.DatabaseTZ\n\t\t\t\tif col.TimeZone != nil {\n\t\t\t\t\tdbTZ = col.TimeZone\n\t\t\t\t}\n\n\t\t\t\tif rawValueType == core.TimeType {\n\t\t\t\t\thasAssigned = true\n\n\t\t\t\t\tt := vv.Convert(core.TimeType).Interface().(time.Time)\n\n\t\t\t\t\tz, _ := t.Zone()\n\t\t\t\t\t// set new location if database don't save timezone or give an incorrect timezone\n\t\t\t\t\tif len(z) == 0 || t.Year() == 0 || t.Location().String() != dbTZ.String() { // !nashtsai! HACK tmp work around for lib/pq doesn't properly time with location\n\t\t\t\t\t\tsession.engine.logger.Debugf(\"empty zone key[%v] : %v | zone: %v | location: %+v\\n\", key, t, z, *t.Location())\n\t\t\t\t\t\tt = time.Date(t.Year(), t.Month(), t.Day(), t.Hour(),\n\t\t\t\t\t\t\tt.Minute(), t.Second(), t.Nanosecond(), dbTZ)\n\t\t\t\t\t}\n\n\t\t\t\t\tt = t.In(session.engine.TZLocation)\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(t).Convert(fieldType))\n\t\t\t\t} else if rawValueType == core.IntType || rawValueType == core.Int64Type ||\n\t\t\t\t\trawValueType == core.Int32Type {\n\t\t\t\t\thasAssigned = true\n\n\t\t\t\t\tt := time.Unix(vv.Int(), 0).In(session.engine.TZLocation)\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(t).Convert(fieldType))\n\t\t\t\t} else {\n\t\t\t\t\tif d, ok := vv.Interface().([]uint8); ok {\n\t\t\t\t\t\thasAssigned = true\n\t\t\t\t\t\tt, err := session.byte2Time(col, d)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tsession.engine.logger.Error(\"byte2Time error:\", err.Error())\n\t\t\t\t\t\t\thasAssigned = false\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfieldValue.Set(reflect.ValueOf(t).Convert(fieldType))\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if d, ok := vv.Interface().(string); ok {\n\t\t\t\t\t\thasAssigned = true\n\t\t\t\t\t\tt, err := session.str2Time(col, d)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tsession.engine.logger.Error(\"byte2Time error:\", err.Error())\n\t\t\t\t\t\t\thasAssigned = false\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfieldValue.Set(reflect.ValueOf(t).Convert(fieldType))\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn nil, fmt.Errorf(\"rawValueType is %v, value is %v\", rawValueType, vv.Interface())\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if nulVal, ok := fieldValue.Addr().Interface().(sql.Scanner); ok {\n\t\t\t\t// !<winxxp>! 增加支持sql.Scanner接口的结构，如sql.NullString\n\t\t\t\thasAssigned = true\n\t\t\t\tif err := nulVal.Scan(vv.Interface()); err != nil {\n\t\t\t\t\tsession.engine.logger.Error(\"sql.Sanner error:\", err.Error())\n\t\t\t\t\thasAssigned = false\n\t\t\t\t}\n\t\t\t} else if col.SQLType.IsJson() {\n\t\t\t\tif rawValueType.Kind() == reflect.String {\n\t\t\t\t\thasAssigned = true\n\t\t\t\t\tx := reflect.New(fieldType)\n\t\t\t\t\tif len([]byte(vv.String())) > 0 {\n\t\t\t\t\t\terr := DefaultJSONHandler.Unmarshal([]byte(vv.String()), x.Interface())\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfieldValue.Set(x.Elem())\n\t\t\t\t\t}\n\t\t\t\t} else if rawValueType.Kind() == reflect.Slice {\n\t\t\t\t\thasAssigned = true\n\t\t\t\t\tx := reflect.New(fieldType)\n\t\t\t\t\tif len(vv.Bytes()) > 0 {\n\t\t\t\t\t\terr := DefaultJSONHandler.Unmarshal(vv.Bytes(), x.Interface())\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfieldValue.Set(x.Elem())\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if session.statement.UseCascade {\n\t\t\t\ttable, err := session.engine.autoMapType(*fieldValue)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\thasAssigned = true\n\t\t\t\tif len(table.PrimaryKeys) != 1 {\n\t\t\t\t\treturn nil, errors.New(\"unsupported non or composited primary key cascade\")\n\t\t\t\t}\n\t\t\t\tvar pk = make(core.PK, len(table.PrimaryKeys))\n\t\t\t\tpk[0], err = asKind(vv, rawValueType)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tif !isPKZero(pk) {\n\t\t\t\t\t// !nashtsai! TODO for hasOne relationship, it's preferred to use join query for eager fetch\n\t\t\t\t\t// however, also need to consider adding a 'lazy' attribute to xorm tag which allow hasOne\n\t\t\t\t\t// property to be fetched lazily\n\t\t\t\t\tstructInter := reflect.New(fieldValue.Type())\n\t\t\t\t\thas, err := session.ID(pk).NoCascade().get(structInter.Interface())\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\tif has {\n\t\t\t\t\t\tfieldValue.Set(structInter.Elem())\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn nil, errors.New(\"cascade obj is not exist\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcase reflect.Ptr:\n\t\t\t// !nashtsai! TODO merge duplicated codes above\n\t\t\tswitch fieldType {\n\t\t\t// following types case matching ptr's native type, therefore assign ptr directly\n\t\t\tcase core.PtrStringType:\n\t\t\t\tif rawValueType.Kind() == reflect.String {\n\t\t\t\t\tx := vv.String()\n\t\t\t\t\thasAssigned = true\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(&x))\n\t\t\t\t}\n\t\t\tcase core.PtrBoolType:\n\t\t\t\tif rawValueType.Kind() == reflect.Bool {\n\t\t\t\t\tx := vv.Bool()\n\t\t\t\t\thasAssigned = true\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(&x))\n\t\t\t\t}\n\t\t\tcase core.PtrTimeType:\n\t\t\t\tif rawValueType == core.PtrTimeType {\n\t\t\t\t\thasAssigned = true\n\t\t\t\t\tvar x = rawValue.Interface().(time.Time)\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(&x))\n\t\t\t\t}\n\t\t\tcase core.PtrFloat64Type:\n\t\t\t\tif rawValueType.Kind() == reflect.Float64 {\n\t\t\t\t\tx := vv.Float()\n\t\t\t\t\thasAssigned = true\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(&x))\n\t\t\t\t}\n\t\t\tcase core.PtrUint64Type:\n\t\t\t\tif rawValueType.Kind() == reflect.Int64 {\n\t\t\t\t\tvar x = uint64(vv.Int())\n\t\t\t\t\thasAssigned = true\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(&x))\n\t\t\t\t}\n\t\t\tcase core.PtrInt64Type:\n\t\t\t\tif rawValueType.Kind() == reflect.Int64 {\n\t\t\t\t\tx := vv.Int()\n\t\t\t\t\thasAssigned = true\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(&x))\n\t\t\t\t}\n\t\t\tcase core.PtrFloat32Type:\n\t\t\t\tif rawValueType.Kind() == reflect.Float64 {\n\t\t\t\t\tvar x = float32(vv.Float())\n\t\t\t\t\thasAssigned = true\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(&x))\n\t\t\t\t}\n\t\t\tcase core.PtrIntType:\n\t\t\t\tif rawValueType.Kind() == reflect.Int64 {\n\t\t\t\t\tvar x = int(vv.Int())\n\t\t\t\t\thasAssigned = true\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(&x))\n\t\t\t\t}\n\t\t\tcase core.PtrInt32Type:\n\t\t\t\tif rawValueType.Kind() == reflect.Int64 {\n\t\t\t\t\tvar x = int32(vv.Int())\n\t\t\t\t\thasAssigned = true\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(&x))\n\t\t\t\t}\n\t\t\tcase core.PtrInt8Type:\n\t\t\t\tif rawValueType.Kind() == reflect.Int64 {\n\t\t\t\t\tvar x = int8(vv.Int())\n\t\t\t\t\thasAssigned = true\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(&x))\n\t\t\t\t}\n\t\t\tcase core.PtrInt16Type:\n\t\t\t\tif rawValueType.Kind() == reflect.Int64 {\n\t\t\t\t\tvar x = int16(vv.Int())\n\t\t\t\t\thasAssigned = true\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(&x))\n\t\t\t\t}\n\t\t\tcase core.PtrUintType:\n\t\t\t\tif rawValueType.Kind() == reflect.Int64 {\n\t\t\t\t\tvar x = uint(vv.Int())\n\t\t\t\t\thasAssigned = true\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(&x))\n\t\t\t\t}\n\t\t\tcase core.PtrUint32Type:\n\t\t\t\tif rawValueType.Kind() == reflect.Int64 {\n\t\t\t\t\tvar x = uint32(vv.Int())\n\t\t\t\t\thasAssigned = true\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(&x))\n\t\t\t\t}\n\t\t\tcase core.Uint8Type:\n\t\t\t\tif rawValueType.Kind() == reflect.Int64 {\n\t\t\t\t\tvar x = uint8(vv.Int())\n\t\t\t\t\thasAssigned = true\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(&x))\n\t\t\t\t}\n\t\t\tcase core.Uint16Type:\n\t\t\t\tif rawValueType.Kind() == reflect.Int64 {\n\t\t\t\t\tvar x = uint16(vv.Int())\n\t\t\t\t\thasAssigned = true\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(&x))\n\t\t\t\t}\n\t\t\tcase core.Complex64Type:\n\t\t\t\tvar x complex64\n\t\t\t\tif len([]byte(vv.String())) > 0 {\n\t\t\t\t\terr := DefaultJSONHandler.Unmarshal([]byte(vv.String()), &x)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(&x))\n\t\t\t\t}\n\t\t\t\thasAssigned = true\n\t\t\tcase core.Complex128Type:\n\t\t\t\tvar x complex128\n\t\t\t\tif len([]byte(vv.String())) > 0 {\n\t\t\t\t\terr := DefaultJSONHandler.Unmarshal([]byte(vv.String()), &x)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\tfieldValue.Set(reflect.ValueOf(&x))\n\t\t\t\t}\n\t\t\t\thasAssigned = true\n\t\t\t} // switch fieldType\n\t\t} // switch fieldType.Kind()\n\n\t\t// !nashtsai! for value can't be assigned directly fallback to convert to []byte then back to value\n\t\tif !hasAssigned {\n\t\t\tdata, err := value2Bytes(&rawValue)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif err = session.bytes2Value(col, fieldValue, data); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\treturn pk, nil\n}\n\n// saveLastSQL stores executed query information\nfunc (session *Session) saveLastSQL(sql string, args ...interface{}) {\n\tsession.lastSQL = sql\n\tsession.lastSQLArgs = args\n\tsession.engine.logSQL(sql, args...)\n}\n\n// LastSQL returns last query information\nfunc (session *Session) LastSQL() (string, []interface{}) {\n\treturn session.lastSQL, session.lastSQLArgs\n}\n\n// Unscoped always disable struct tag \"deleted\"\nfunc (session *Session) Unscoped() *Session {\n\tsession.statement.Unscoped()\n\treturn session\n}\n\nfunc (session *Session) incrVersionFieldValue(fieldValue *reflect.Value) {\n\tswitch fieldValue.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tfieldValue.SetInt(fieldValue.Int() + 1)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tfieldValue.SetUint(fieldValue.Uint() + 1)\n\t}\n}\n"
        },
        {
          "name": "session_cols.go",
          "type": "blob",
          "size": 4.0185546875,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n\n\t\"xorm.io/core\"\n)\n\nfunc setColumnInt(bean interface{}, col *core.Column, t int64) {\n\tv, err := col.ValueOf(bean)\n\tif err != nil {\n\t\treturn\n\t}\n\tif v.CanSet() {\n\t\tswitch v.Type().Kind() {\n\t\tcase reflect.Int, reflect.Int64, reflect.Int32:\n\t\t\tv.SetInt(t)\n\t\tcase reflect.Uint, reflect.Uint64, reflect.Uint32:\n\t\t\tv.SetUint(uint64(t))\n\t\t}\n\t}\n}\n\nfunc setColumnTime(bean interface{}, col *core.Column, t time.Time) {\n\tv, err := col.ValueOf(bean)\n\tif err != nil {\n\t\treturn\n\t}\n\tif v.CanSet() {\n\t\tswitch v.Type().Kind() {\n\t\tcase reflect.Struct:\n\t\t\tv.Set(reflect.ValueOf(t).Convert(v.Type()))\n\t\tcase reflect.Int, reflect.Int64, reflect.Int32:\n\t\t\tv.SetInt(t.Unix())\n\t\tcase reflect.Uint, reflect.Uint64, reflect.Uint32:\n\t\t\tv.SetUint(uint64(t.Unix()))\n\t\t}\n\t}\n}\n\nfunc getFlagForColumn(m map[string]bool, col *core.Column) (val bool, has bool) {\n\tif len(m) == 0 {\n\t\treturn false, false\n\t}\n\n\tn := len(col.Name)\n\n\tfor mk := range m {\n\t\tif len(mk) != n {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.EqualFold(mk, col.Name) {\n\t\t\treturn m[mk], true\n\t\t}\n\t}\n\n\treturn false, false\n}\n\nfunc col2NewCols(columns ...string) []string {\n\tnewColumns := make([]string, 0, len(columns))\n\tfor _, col := range columns {\n\t\tcol = strings.Replace(col, \"`\", \"\", -1)\n\t\tcol = strings.Replace(col, `\"`, \"\", -1)\n\t\tccols := strings.Split(col, \",\")\n\t\tfor _, c := range ccols {\n\t\t\tnewColumns = append(newColumns, strings.TrimSpace(c))\n\t\t}\n\t}\n\treturn newColumns\n}\n\n// Incr provides a query string like \"count = count + 1\"\nfunc (session *Session) Incr(column string, arg ...interface{}) *Session {\n\tsession.statement.Incr(column, arg...)\n\treturn session\n}\n\n// Decr provides a query string like \"count = count - 1\"\nfunc (session *Session) Decr(column string, arg ...interface{}) *Session {\n\tsession.statement.Decr(column, arg...)\n\treturn session\n}\n\n// SetExpr provides a query string like \"column = {expression}\"\nfunc (session *Session) SetExpr(column string, expression interface{}) *Session {\n\tsession.statement.SetExpr(column, expression)\n\treturn session\n}\n\n// Select provides some columns to special\nfunc (session *Session) Select(str string) *Session {\n\tsession.statement.Select(str)\n\treturn session\n}\n\n// Cols provides some columns to special\nfunc (session *Session) Cols(columns ...string) *Session {\n\tsession.statement.Cols(columns...)\n\treturn session\n}\n\n// AllCols ask all columns\nfunc (session *Session) AllCols() *Session {\n\tsession.statement.AllCols()\n\treturn session\n}\n\n// MustCols specify some columns must use even if they are empty\nfunc (session *Session) MustCols(columns ...string) *Session {\n\tsession.statement.MustCols(columns...)\n\treturn session\n}\n\n// UseBool automatically retrieve condition according struct, but\n// if struct has bool field, it will ignore them. So use UseBool\n// to tell system to do not ignore them.\n// If no parameters, it will use all the bool field of struct, or\n// it will use parameters's columns\nfunc (session *Session) UseBool(columns ...string) *Session {\n\tsession.statement.UseBool(columns...)\n\treturn session\n}\n\n// Distinct use for distinct columns. Caution: when you are using cache,\n// distinct will not be cached because cache system need id,\n// but distinct will not provide id\nfunc (session *Session) Distinct(columns ...string) *Session {\n\tsession.statement.Distinct(columns...)\n\treturn session\n}\n\n// Omit Only not use the parameters as select or update columns\nfunc (session *Session) Omit(columns ...string) *Session {\n\tsession.statement.Omit(columns...)\n\treturn session\n}\n\n// Nullable Set null when column is zero-value and nullable for update\nfunc (session *Session) Nullable(columns ...string) *Session {\n\tsession.statement.Nullable(columns...)\n\treturn session\n}\n\n// NoAutoTime means do not automatically give created field and updated field\n// the current time on the current session temporarily\nfunc (session *Session) NoAutoTime() *Session {\n\tsession.statement.UseAutoTime = false\n\treturn session\n}\n"
        },
        {
          "name": "session_cols_test.go",
          "type": "blob",
          "size": 3.31640625,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"xorm.io/builder\"\n\t\"xorm.io/core\"\n)\n\nfunc TestSetExpr(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UserExprIssue struct {\n\t\tId    int64\n\t\tTitle string\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(UserExprIssue)))\n\n\tvar issue = UserExprIssue{\n\t\tTitle: \"my issue\",\n\t}\n\tcnt, err := testEngine.Insert(&issue)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\tassert.EqualValues(t, 1, issue.Id)\n\n\ttype UserExpr struct {\n\t\tId      int64\n\t\tIssueId int64 `xorm:\"index\"`\n\t\tShow    bool\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(UserExpr)))\n\n\tcnt, err = testEngine.Insert(&UserExpr{\n\t\tShow: true,\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar not = \"NOT\"\n\tif testEngine.Dialect().DBType() == core.MSSQL {\n\t\tnot = \"~\"\n\t}\n\tcnt, err = testEngine.SetExpr(\"show\", not+\" `show`\").ID(1).Update(new(UserExpr))\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\ttableName := testEngine.TableName(new(UserExprIssue), true)\n\tcnt, err = testEngine.SetExpr(\"issue_id\",\n\t\tbuilder.Select(\"id\").\n\t\t\tFrom(tableName).\n\t\t\tWhere(builder.Eq{\"id\": issue.Id})).\n\t\tID(1).\n\t\tUpdate(new(UserExpr))\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n}\n\nfunc TestCols(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype ColsTable struct {\n\t\tId   int64\n\t\tCol1 string\n\t\tCol2 string\n\t}\n\n\tassertSync(t, new(ColsTable))\n\n\t_, err := testEngine.Insert(&ColsTable{\n\t\tCol1: \"1\",\n\t\tCol2: \"2\",\n\t})\n\tassert.NoError(t, err)\n\n\tsess := testEngine.ID(1)\n\t_, err = sess.Cols(\"col1\").Cols(\"col2\").Update(&ColsTable{\n\t\tCol1: \"\",\n\t\tCol2: \"\",\n\t})\n\tassert.NoError(t, err)\n\n\tvar tb ColsTable\n\thas, err := testEngine.ID(1).Get(&tb)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, \"\", tb.Col1)\n\tassert.EqualValues(t, \"\", tb.Col2)\n}\n\nfunc TestMustCol(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype CustomerUpdate struct {\n\t\tId        int64  `form:\"id\" json:\"id\"`\n\t\tUsername  string `form:\"username\" json:\"username\" binding:\"required\"`\n\t\tEmail     string `form:\"email\" json:\"email\"`\n\t\tSex       int    `form:\"sex\" json:\"sex\"`\n\t\tName      string `form:\"name\" json:\"name\" binding:\"required\"`\n\t\tTelephone string `form:\"telephone\" json:\"telephone\"`\n\t\tType      int    `form:\"type\" json:\"type\" binding:\"required\"`\n\t\tParentId  int64  `form:\"parent_id\" json:\"parent_id\" xorm:\"int null\"`\n\t\tRemark    string `form:\"remark\" json:\"remark\"`\n\t\tStatus    int    `form:\"status\" json:\"status\" binding:\"required\"`\n\t\tAge       int    `form:\"age\" json:\"age\"`\n\t\tCreatedAt int64  `xorm:\"created\" form:\"created_at\" json:\"created_at\"`\n\t\tUpdatedAt int64  `xorm:\"updated\" form:\"updated_at\" json:\"updated_at\"`\n\t\tBirthDate int64  `form:\"birth_date\" json:\"birth_date\"`\n\t\tPassword  string `xorm:\"varchar(200)\" form:\"password\" json:\"password\"`\n\t}\n\n\tassertSync(t, new(CustomerUpdate))\n\n\tvar customer = CustomerUpdate{\n\t\tParentId: 1,\n\t}\n\tcnt, err := testEngine.Insert(&customer)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\ttype CustomerOnlyId struct {\n\t\tId int64\n\t}\n\n\tcustomer.ParentId = 0\n\taffected, err := testEngine.MustCols(\"parent_id\").Update(&customer, &CustomerOnlyId{Id: customer.Id})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, affected)\n}\n"
        },
        {
          "name": "session_cond.go",
          "type": "blob",
          "size": 2.126953125,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport \"xorm.io/builder\"\n\n// Sql provides raw sql input parameter. When you have a complex SQL statement\n// and cannot use Where, Id, In and etc. Methods to describe, you can use SQL.\n//\n// Deprecated: use SQL instead.\nfunc (session *Session) Sql(query string, args ...interface{}) *Session {\n\treturn session.SQL(query, args...)\n}\n\n// SQL provides raw sql input parameter. When you have a complex SQL statement\n// and cannot use Where, Id, In and etc. Methods to describe, you can use SQL.\nfunc (session *Session) SQL(query interface{}, args ...interface{}) *Session {\n\tsession.statement.SQL(query, args...)\n\treturn session\n}\n\n// Where provides custom query condition.\nfunc (session *Session) Where(query interface{}, args ...interface{}) *Session {\n\tsession.statement.Where(query, args...)\n\treturn session\n}\n\n// And provides custom query condition.\nfunc (session *Session) And(query interface{}, args ...interface{}) *Session {\n\tsession.statement.And(query, args...)\n\treturn session\n}\n\n// Or provides custom query condition.\nfunc (session *Session) Or(query interface{}, args ...interface{}) *Session {\n\tsession.statement.Or(query, args...)\n\treturn session\n}\n\n// Id provides converting id as a query condition\n//\n// Deprecated: use ID instead\nfunc (session *Session) Id(id interface{}) *Session {\n\treturn session.ID(id)\n}\n\n// ID provides converting id as a query condition\nfunc (session *Session) ID(id interface{}) *Session {\n\tsession.statement.ID(id)\n\treturn session\n}\n\n// In provides a query string like \"id in (1, 2, 3)\"\nfunc (session *Session) In(column string, args ...interface{}) *Session {\n\tsession.statement.In(column, args...)\n\treturn session\n}\n\n// NotIn provides a query string like \"id in (1, 2, 3)\"\nfunc (session *Session) NotIn(column string, args ...interface{}) *Session {\n\tsession.statement.NotIn(column, args...)\n\treturn session\n}\n\n// Conds returns session query conditions except auto bean conditions\nfunc (session *Session) Conds() builder.Cond {\n\treturn session.statement.cond\n}\n"
        },
        {
          "name": "session_cond_test.go",
          "type": "blob",
          "size": 5.9287109375,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"xorm.io/builder\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestBuilder(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tconst (\n\t\tOpEqual int = iota\n\t\tOpGreatThan\n\t\tOpLessThan\n\t)\n\n\ttype Condition struct {\n\t\tId        int64\n\t\tTableName string\n\t\tColName   string\n\t\tOp        int\n\t\tValue     string\n\t}\n\n\terr := testEngine.CreateTables(&Condition{})\n\tassert.NoError(t, err)\n\n\t_, err = testEngine.Insert(&Condition{TableName: \"table1\", ColName: \"col1\", Op: OpEqual, Value: \"1\"})\n\tassert.NoError(t, err)\n\n\tvar cond Condition\n\thas, err := testEngine.Where(builder.Eq{\"col_name\": \"col1\"}).Get(&cond)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has, \"records should exist\")\n\n\thas, err = testEngine.Where(builder.Eq{\"col_name\": \"col1\"}.\n\t\tAnd(builder.Eq{\"op\": OpEqual})).\n\t\tNoAutoCondition().\n\t\tGet(&cond)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has, \"records should exist\")\n\n\thas, err = testEngine.Where(builder.Eq{\"col_name\": \"col1\", \"op\": OpEqual, \"value\": \"1\"}).\n\t\tNoAutoCondition().\n\t\tGet(&cond)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has, \"records should exist\")\n\n\thas, err = testEngine.Where(builder.Eq{\"col_name\": \"col1\"}.\n\t\tAnd(builder.Neq{\"op\": OpEqual})).\n\t\tNoAutoCondition().\n\t\tGet(&cond)\n\tassert.NoError(t, err)\n\tassert.Equal(t, false, has, \"records should not exist\")\n\n\tvar conds []Condition\n\terr = testEngine.Where(builder.Eq{\"col_name\": \"col1\"}.\n\t\tAnd(builder.Eq{\"op\": OpEqual})).\n\t\tFind(&conds)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(conds), \"records should exist\")\n\n\tconds = make([]Condition, 0)\n\terr = testEngine.Where(builder.Like{\"col_name\", \"col\"}).Find(&conds)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(conds), \"records should exist\")\n\n\tconds = make([]Condition, 0)\n\terr = testEngine.Where(builder.Expr(\"col_name = ?\", \"col1\")).Find(&conds)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(conds), \"records should exist\")\n\n\tconds = make([]Condition, 0)\n\terr = testEngine.Where(builder.In(\"col_name\", \"col1\", \"col2\")).Find(&conds)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(conds), \"records should exist\")\n\n\tconds = make([]Condition, 0)\n\terr = testEngine.NotIn(\"col_name\", \"col1\", \"col2\").Find(&conds)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 0, len(conds), \"records should not exist\")\n\n\t// complex condtions\n\tvar where = builder.NewCond()\n\tif true {\n\t\twhere = where.And(builder.Eq{\"col_name\": \"col1\"})\n\t\twhere = where.Or(builder.And(builder.In(\"col_name\", \"col1\", \"col2\"), builder.Expr(\"col_name = ?\", \"col1\")))\n\t}\n\n\tconds = make([]Condition, 0)\n\terr = testEngine.Where(where).Find(&conds)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(conds), \"records should exist\")\n}\n\nfunc TestIn(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassert.NoError(t, testEngine.Sync2(new(Userinfo)))\n\n\tcnt, err := testEngine.Insert([]Userinfo{\n\t\t{\n\t\t\tUsername:   \"user1\",\n\t\t\tDepartname: \"dev\",\n\t\t},\n\t\t{\n\t\t\tUsername:   \"user2\",\n\t\t\tDepartname: \"dev\",\n\t\t},\n\t\t{\n\t\t\tUsername:   \"user3\",\n\t\t\tDepartname: \"dev\",\n\t\t},\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 3, cnt)\n\n\tdepartment := \"`\" + testEngine.GetColumnMapper().Obj2Table(\"Departname\") + \"`\"\n\tvar usrs []Userinfo\n\terr = testEngine.Where(department+\" = ?\", \"dev\").Limit(3).Find(&usrs)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 3, len(usrs))\n\n\tvar ids []int64\n\tvar idsStr string\n\tfor _, u := range usrs {\n\t\tids = append(ids, u.Uid)\n\t\tidsStr = fmt.Sprintf(\"%d,\", u.Uid)\n\t}\n\tidsStr = idsStr[:len(idsStr)-1]\n\n\tusers := make([]Userinfo, 0)\n\terr = testEngine.In(\"(id)\", ids[0], ids[1], ids[2]).Find(&users)\n\tassert.NoError(t, err)\n\tfmt.Println(users)\n\tassert.EqualValues(t, 3, len(users))\n\n\tusers = make([]Userinfo, 0)\n\terr = testEngine.In(\"(id)\", ids).Find(&users)\n\tassert.NoError(t, err)\n\tfmt.Println(users)\n\tassert.EqualValues(t, 3, len(users))\n\n\tfor _, user := range users {\n\t\tif user.Uid != ids[0] && user.Uid != ids[1] && user.Uid != ids[2] {\n\t\t\terr = errors.New(\"in uses should be \" + idsStr + \" total 3\")\n\t\t\tassert.NoError(t, err)\n\t\t}\n\t}\n\n\tusers = make([]Userinfo, 0)\n\tvar idsInterface []interface{}\n\tfor _, id := range ids {\n\t\tidsInterface = append(idsInterface, id)\n\t}\n\n\terr = testEngine.Where(department+\" = ?\", \"dev\").In(\"(id)\", idsInterface...).Find(&users)\n\tassert.NoError(t, err)\n\tfmt.Println(users)\n\tassert.EqualValues(t, 3, len(users))\n\n\tfor _, user := range users {\n\t\tif user.Uid != ids[0] && user.Uid != ids[1] && user.Uid != ids[2] {\n\t\t\terr = errors.New(\"in uses should be \" + idsStr + \" total 3\")\n\t\t\tassert.NoError(t, err)\n\t\t}\n\t}\n\n\tdev := testEngine.GetColumnMapper().Obj2Table(\"Dev\")\n\n\terr = testEngine.In(\"(id)\", 1).In(\"(id)\", 2).In(department, dev).Find(&users)\n\tassert.NoError(t, err)\n\tfmt.Println(users)\n\n\tcnt, err = testEngine.In(\"(id)\", ids[0]).Update(&Userinfo{Departname: \"dev-\"})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tuser := new(Userinfo)\n\thas, err := testEngine.ID(ids[0]).Get(user)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, \"dev-\", user.Departname)\n\n\tcnt, err = testEngine.In(\"(id)\", ids[0]).Update(&Userinfo{Departname: \"dev\"})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tcnt, err = testEngine.In(\"(id)\", ids[1]).Delete(&Userinfo{})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n}\n\nfunc TestFindAndCount(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype FindAndCount struct {\n\t\tId   int64\n\t\tName string\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(FindAndCount)))\n\n\t_, err := testEngine.Insert([]FindAndCount{\n\t\t{\n\t\t\tName: \"test1\",\n\t\t},\n\t\t{\n\t\t\tName: \"test2\",\n\t\t},\n\t})\n\tassert.NoError(t, err)\n\n\tvar results []FindAndCount\n\tsess := testEngine.Where(\"name = ?\", \"test1\")\n\tconds := sess.Conds()\n\terr = sess.Find(&results)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(results))\n\n\ttotal, err := testEngine.Where(conds).Count(new(FindAndCount))\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, total)\n}\n"
        },
        {
          "name": "session_context.go",
          "type": "blob",
          "size": 0.6005859375,
          "content": "// Copyright 2019 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport \"context\"\n\n// Context sets the context on this session\nfunc (session *Session) Context(ctx context.Context) *Session {\n\tsession.ctx = ctx\n\treturn session\n}\n\n// PingContext test if database is ok\nfunc (session *Session) PingContext(ctx context.Context) error {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\tsession.engine.logger.Infof(\"PING DATABASE %v\", session.engine.DriverName())\n\treturn session.DB().PingContext(ctx)\n}\n"
        },
        {
          "name": "session_context_test.go",
          "type": "blob",
          "size": 0.80859375,
          "content": "// Copyright 2019 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestQueryContext(t *testing.T) {\n\ttype ContextQueryStruct struct {\n\t\tId   int64\n\t\tName string\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(ContextQueryStruct))\n\n\t_, err := testEngine.Insert(&ContextQueryStruct{Name: \"1\"})\n\tassert.NoError(t, err)\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Nanosecond)\n\tdefer cancel()\n\n\ttime.Sleep(time.Nanosecond)\n\n\thas, err := testEngine.Context(ctx).Exist(&ContextQueryStruct{Name: \"1\"})\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"context deadline exceeded\")\n\tassert.False(t, has)\n}\n"
        },
        {
          "name": "session_convert.go",
          "type": "blob",
          "size": 19.6220703125,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"xorm.io/core\"\n)\n\nfunc (session *Session) str2Time(col *core.Column, data string) (outTime time.Time, outErr error) {\n\tsdata := strings.TrimSpace(data)\n\tvar x time.Time\n\tvar err error\n\n\tvar parseLoc = session.engine.DatabaseTZ\n\tif col.TimeZone != nil {\n\t\tparseLoc = col.TimeZone\n\t}\n\n\tif sdata == zeroTime0 || sdata == zeroTime1 {\n\t} else if !strings.ContainsAny(sdata, \"- :\") { // !nashtsai! has only found that mymysql driver is using this for time type column\n\t\t// time stamp\n\t\tsd, err := strconv.ParseInt(sdata, 10, 64)\n\t\tif err == nil {\n\t\t\tx = time.Unix(sd, 0)\n\t\t\t//session.engine.logger.Debugf(\"time(0) key[%v]: %+v | sdata: [%v]\\n\", col.FieldName, x, sdata)\n\t\t} else {\n\t\t\t//session.engine.logger.Debugf(\"time(0) err key[%v]: %+v | sdata: [%v]\\n\", col.FieldName, x, sdata)\n\t\t}\n\t} else if len(sdata) > 19 && strings.Contains(sdata, \"-\") {\n\t\tx, err = time.ParseInLocation(time.RFC3339Nano, sdata, parseLoc)\n\t\tsession.engine.logger.Debugf(\"time(1) key[%v]: %+v | sdata: [%v]\\n\", col.FieldName, x, sdata)\n\t\tif err != nil {\n\t\t\tx, err = time.ParseInLocation(\"2006-01-02 15:04:05.999999999\", sdata, parseLoc)\n\t\t\t//session.engine.logger.Debugf(\"time(2) key[%v]: %+v | sdata: [%v]\\n\", col.FieldName, x, sdata)\n\t\t}\n\t\tif err != nil {\n\t\t\tx, err = time.ParseInLocation(\"2006-01-02 15:04:05.9999999 Z07:00\", sdata, parseLoc)\n\t\t\t//session.engine.logger.Debugf(\"time(3) key[%v]: %+v | sdata: [%v]\\n\", col.FieldName, x, sdata)\n\t\t}\n\t} else if len(sdata) == 19 && strings.Contains(sdata, \"-\") {\n\t\tx, err = time.ParseInLocation(\"2006-01-02 15:04:05\", sdata, parseLoc)\n\t\t//session.engine.logger.Debugf(\"time(4) key[%v]: %+v | sdata: [%v]\\n\", col.FieldName, x, sdata)\n\t} else if len(sdata) == 10 && sdata[4] == '-' && sdata[7] == '-' {\n\t\tx, err = time.ParseInLocation(\"2006-01-02\", sdata, parseLoc)\n\t\t//session.engine.logger.Debugf(\"time(5) key[%v]: %+v | sdata: [%v]\\n\", col.FieldName, x, sdata)\n\t} else if col.SQLType.Name == core.Time {\n\t\tif strings.Contains(sdata, \" \") {\n\t\t\tssd := strings.Split(sdata, \" \")\n\t\t\tsdata = ssd[1]\n\t\t}\n\n\t\tsdata = strings.TrimSpace(sdata)\n\t\tif session.engine.dialect.DBType() == core.MYSQL && len(sdata) > 8 {\n\t\t\tsdata = sdata[len(sdata)-8:]\n\t\t}\n\n\t\tst := fmt.Sprintf(\"2006-01-02 %v\", sdata)\n\t\tx, err = time.ParseInLocation(\"2006-01-02 15:04:05\", st, parseLoc)\n\t\t//session.engine.logger.Debugf(\"time(6) key[%v]: %+v | sdata: [%v]\\n\", col.FieldName, x, sdata)\n\t} else {\n\t\toutErr = fmt.Errorf(\"unsupported time format %v\", sdata)\n\t\treturn\n\t}\n\tif err != nil {\n\t\toutErr = fmt.Errorf(\"unsupported time format %v: %v\", sdata, err)\n\t\treturn\n\t}\n\toutTime = x.In(session.engine.TZLocation)\n\treturn\n}\n\nfunc (session *Session) byte2Time(col *core.Column, data []byte) (outTime time.Time, outErr error) {\n\treturn session.str2Time(col, string(data))\n}\n\nvar (\n\tnullFloatType = reflect.TypeOf(sql.NullFloat64{})\n)\n\n// convert a db data([]byte) to a field value\nfunc (session *Session) bytes2Value(col *core.Column, fieldValue *reflect.Value, data []byte) error {\n\tif structConvert, ok := fieldValue.Addr().Interface().(core.Conversion); ok {\n\t\treturn structConvert.FromDB(data)\n\t}\n\n\tif structConvert, ok := fieldValue.Interface().(core.Conversion); ok {\n\t\treturn structConvert.FromDB(data)\n\t}\n\n\tvar v interface{}\n\tkey := col.Name\n\tfieldType := fieldValue.Type()\n\n\tswitch fieldType.Kind() {\n\tcase reflect.Complex64, reflect.Complex128:\n\t\tx := reflect.New(fieldType)\n\t\tif len(data) > 0 {\n\t\t\terr := DefaultJSONHandler.Unmarshal(data, x.Interface())\n\t\t\tif err != nil {\n\t\t\t\tsession.engine.logger.Error(err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfieldValue.Set(x.Elem())\n\t\t}\n\tcase reflect.Slice, reflect.Array, reflect.Map:\n\t\tv = data\n\t\tt := fieldType.Elem()\n\t\tk := t.Kind()\n\t\tif col.SQLType.IsText() {\n\t\t\tx := reflect.New(fieldType)\n\t\t\tif len(data) > 0 {\n\t\t\t\terr := DefaultJSONHandler.Unmarshal(data, x.Interface())\n\t\t\t\tif err != nil {\n\t\t\t\t\tsession.engine.logger.Error(err)\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tfieldValue.Set(x.Elem())\n\t\t\t}\n\t\t} else if col.SQLType.IsBlob() {\n\t\t\tif k == reflect.Uint8 {\n\t\t\t\tfieldValue.Set(reflect.ValueOf(v))\n\t\t\t} else {\n\t\t\t\tx := reflect.New(fieldType)\n\t\t\t\tif len(data) > 0 {\n\t\t\t\t\terr := DefaultJSONHandler.Unmarshal(data, x.Interface())\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tsession.engine.logger.Error(err)\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tfieldValue.Set(x.Elem())\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn ErrUnSupportedType\n\t\t}\n\tcase reflect.String:\n\t\tfieldValue.SetString(string(data))\n\tcase reflect.Bool:\n\t\tv, err := asBool(data)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"arg %v as bool: %s\", key, err.Error())\n\t\t}\n\t\tfieldValue.Set(reflect.ValueOf(v))\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tsdata := string(data)\n\t\tvar x int64\n\t\tvar err error\n\t\t// for mysql, when use bit, it returned \\x01\n\t\tif col.SQLType.Name == core.Bit &&\n\t\t\tsession.engine.dialect.DBType() == core.MYSQL { // !nashtsai! TODO dialect needs to provide conversion interface API\n\t\t\tif len(data) == 1 {\n\t\t\t\tx = int64(data[0])\n\t\t\t} else {\n\t\t\t\tx = 0\n\t\t\t}\n\t\t} else if strings.HasPrefix(sdata, \"0x\") {\n\t\t\tx, err = strconv.ParseInt(sdata, 16, 64)\n\t\t} else if strings.HasPrefix(sdata, \"0\") {\n\t\t\tx, err = strconv.ParseInt(sdata, 8, 64)\n\t\t} else if strings.EqualFold(sdata, \"true\") {\n\t\t\tx = 1\n\t\t} else if strings.EqualFold(sdata, \"false\") {\n\t\t\tx = 0\n\t\t} else {\n\t\t\tx, err = strconv.ParseInt(sdata, 10, 64)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"arg %v as int: %s\", key, err.Error())\n\t\t}\n\t\tfieldValue.SetInt(x)\n\tcase reflect.Float32, reflect.Float64:\n\t\tx, err := strconv.ParseFloat(string(data), 64)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"arg %v as float64: %s\", key, err.Error())\n\t\t}\n\t\tfieldValue.SetFloat(x)\n\tcase reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:\n\t\tx, err := strconv.ParseUint(string(data), 10, 64)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"arg %v as int: %s\", key, err.Error())\n\t\t}\n\t\tfieldValue.SetUint(x)\n\t//Currently only support Time type\n\tcase reflect.Struct:\n\t\t// !<winxxp>! 增加支持sql.Scanner接口的结构，如sql.NullString\n\t\tif nulVal, ok := fieldValue.Addr().Interface().(sql.Scanner); ok {\n\t\t\tif err := nulVal.Scan(data); err != nil {\n\t\t\t\treturn fmt.Errorf(\"sql.Scan(%v) failed: %s \", data, err.Error())\n\t\t\t}\n\t\t} else {\n\t\t\tif fieldType.ConvertibleTo(core.TimeType) {\n\t\t\t\tx, err := session.byte2Time(col, data)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tv = x\n\t\t\t\tfieldValue.Set(reflect.ValueOf(v).Convert(fieldType))\n\t\t\t} else if session.statement.UseCascade {\n\t\t\t\ttable, err := session.engine.autoMapType(*fieldValue)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\t// TODO: current only support 1 primary key\n\t\t\t\tif len(table.PrimaryKeys) > 1 {\n\t\t\t\t\treturn errors.New(\"unsupported composited primary key cascade\")\n\t\t\t\t}\n\n\t\t\t\tvar pk = make(core.PK, len(table.PrimaryKeys))\n\t\t\t\trawValueType := table.ColumnType(table.PKColumns()[0].FieldName)\n\t\t\t\tpk[0], err = str2PK(string(data), rawValueType)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif !isPKZero(pk) {\n\t\t\t\t\t// !nashtsai! TODO for hasOne relationship, it's preferred to use join query for eager fetch\n\t\t\t\t\t// however, also need to consider adding a 'lazy' attribute to xorm tag which allow hasOne\n\t\t\t\t\t// property to be fetched lazily\n\t\t\t\t\tstructInter := reflect.New(fieldValue.Type())\n\t\t\t\t\thas, err := session.ID(pk).NoCascade().get(structInter.Interface())\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tif has {\n\t\t\t\t\t\tv = structInter.Elem().Interface()\n\t\t\t\t\t\tfieldValue.Set(reflect.ValueOf(v))\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn errors.New(\"cascade obj is not exist\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcase reflect.Ptr:\n\t\t// !nashtsai! TODO merge duplicated codes above\n\t\t//typeStr := fieldType.String()\n\t\tswitch fieldType.Elem().Kind() {\n\t\t// case \"*string\":\n\t\tcase core.StringType.Kind():\n\t\t\tx := string(data)\n\t\t\tfieldValue.Set(reflect.ValueOf(&x).Convert(fieldType))\n\t\t// case \"*bool\":\n\t\tcase core.BoolType.Kind():\n\t\t\td := string(data)\n\t\t\tv, err := strconv.ParseBool(d)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"arg %v as bool: %s\", key, err.Error())\n\t\t\t}\n\t\t\tfieldValue.Set(reflect.ValueOf(&v).Convert(fieldType))\n\t\t// case \"*complex64\":\n\t\tcase core.Complex64Type.Kind():\n\t\t\tvar x complex64\n\t\t\tif len(data) > 0 {\n\t\t\t\terr := DefaultJSONHandler.Unmarshal(data, &x)\n\t\t\t\tif err != nil {\n\t\t\t\t\tsession.engine.logger.Error(err)\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tfieldValue.Set(reflect.ValueOf(&x).Convert(fieldType))\n\t\t\t}\n\t\t// case \"*complex128\":\n\t\tcase core.Complex128Type.Kind():\n\t\t\tvar x complex128\n\t\t\tif len(data) > 0 {\n\t\t\t\terr := DefaultJSONHandler.Unmarshal(data, &x)\n\t\t\t\tif err != nil {\n\t\t\t\t\tsession.engine.logger.Error(err)\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tfieldValue.Set(reflect.ValueOf(&x).Convert(fieldType))\n\t\t\t}\n\t\t// case \"*float64\":\n\t\tcase core.Float64Type.Kind():\n\t\t\tx, err := strconv.ParseFloat(string(data), 64)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"arg %v as float64: %s\", key, err.Error())\n\t\t\t}\n\t\t\tfieldValue.Set(reflect.ValueOf(&x).Convert(fieldType))\n\t\t// case \"*float32\":\n\t\tcase core.Float32Type.Kind():\n\t\t\tvar x float32\n\t\t\tx1, err := strconv.ParseFloat(string(data), 32)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"arg %v as float32: %s\", key, err.Error())\n\t\t\t}\n\t\t\tx = float32(x1)\n\t\t\tfieldValue.Set(reflect.ValueOf(&x).Convert(fieldType))\n\t\t// case \"*uint64\":\n\t\tcase core.Uint64Type.Kind():\n\t\t\tvar x uint64\n\t\t\tx, err := strconv.ParseUint(string(data), 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"arg %v as int: %s\", key, err.Error())\n\t\t\t}\n\t\t\tfieldValue.Set(reflect.ValueOf(&x).Convert(fieldType))\n\t\t// case \"*uint\":\n\t\tcase core.UintType.Kind():\n\t\t\tvar x uint\n\t\t\tx1, err := strconv.ParseUint(string(data), 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"arg %v as int: %s\", key, err.Error())\n\t\t\t}\n\t\t\tx = uint(x1)\n\t\t\tfieldValue.Set(reflect.ValueOf(&x).Convert(fieldType))\n\t\t// case \"*uint32\":\n\t\tcase core.Uint32Type.Kind():\n\t\t\tvar x uint32\n\t\t\tx1, err := strconv.ParseUint(string(data), 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"arg %v as int: %s\", key, err.Error())\n\t\t\t}\n\t\t\tx = uint32(x1)\n\t\t\tfieldValue.Set(reflect.ValueOf(&x).Convert(fieldType))\n\t\t// case \"*uint8\":\n\t\tcase core.Uint8Type.Kind():\n\t\t\tvar x uint8\n\t\t\tx1, err := strconv.ParseUint(string(data), 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"arg %v as int: %s\", key, err.Error())\n\t\t\t}\n\t\t\tx = uint8(x1)\n\t\t\tfieldValue.Set(reflect.ValueOf(&x).Convert(fieldType))\n\t\t// case \"*uint16\":\n\t\tcase core.Uint16Type.Kind():\n\t\t\tvar x uint16\n\t\t\tx1, err := strconv.ParseUint(string(data), 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"arg %v as int: %s\", key, err.Error())\n\t\t\t}\n\t\t\tx = uint16(x1)\n\t\t\tfieldValue.Set(reflect.ValueOf(&x).Convert(fieldType))\n\t\t// case \"*int64\":\n\t\tcase core.Int64Type.Kind():\n\t\t\tsdata := string(data)\n\t\t\tvar x int64\n\t\t\tvar err error\n\t\t\t// for mysql, when use bit, it returned \\x01\n\t\t\tif col.SQLType.Name == core.Bit &&\n\t\t\t\tstrings.Contains(session.engine.DriverName(), \"mysql\") {\n\t\t\t\tif len(data) == 1 {\n\t\t\t\t\tx = int64(data[0])\n\t\t\t\t} else {\n\t\t\t\t\tx = 0\n\t\t\t\t}\n\t\t\t} else if strings.HasPrefix(sdata, \"0x\") {\n\t\t\t\tx, err = strconv.ParseInt(sdata, 16, 64)\n\t\t\t} else if strings.HasPrefix(sdata, \"0\") {\n\t\t\t\tx, err = strconv.ParseInt(sdata, 8, 64)\n\t\t\t} else {\n\t\t\t\tx, err = strconv.ParseInt(sdata, 10, 64)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"arg %v as int: %s\", key, err.Error())\n\t\t\t}\n\t\t\tfieldValue.Set(reflect.ValueOf(&x).Convert(fieldType))\n\t\t// case \"*int\":\n\t\tcase core.IntType.Kind():\n\t\t\tsdata := string(data)\n\t\t\tvar x int\n\t\t\tvar x1 int64\n\t\t\tvar err error\n\t\t\t// for mysql, when use bit, it returned \\x01\n\t\t\tif col.SQLType.Name == core.Bit &&\n\t\t\t\tstrings.Contains(session.engine.DriverName(), \"mysql\") {\n\t\t\t\tif len(data) == 1 {\n\t\t\t\t\tx = int(data[0])\n\t\t\t\t} else {\n\t\t\t\t\tx = 0\n\t\t\t\t}\n\t\t\t} else if strings.HasPrefix(sdata, \"0x\") {\n\t\t\t\tx1, err = strconv.ParseInt(sdata, 16, 64)\n\t\t\t\tx = int(x1)\n\t\t\t} else if strings.HasPrefix(sdata, \"0\") {\n\t\t\t\tx1, err = strconv.ParseInt(sdata, 8, 64)\n\t\t\t\tx = int(x1)\n\t\t\t} else {\n\t\t\t\tx1, err = strconv.ParseInt(sdata, 10, 64)\n\t\t\t\tx = int(x1)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"arg %v as int: %s\", key, err.Error())\n\t\t\t}\n\t\t\tfieldValue.Set(reflect.ValueOf(&x).Convert(fieldType))\n\t\t// case \"*int32\":\n\t\tcase core.Int32Type.Kind():\n\t\t\tsdata := string(data)\n\t\t\tvar x int32\n\t\t\tvar x1 int64\n\t\t\tvar err error\n\t\t\t// for mysql, when use bit, it returned \\x01\n\t\t\tif col.SQLType.Name == core.Bit &&\n\t\t\t\tsession.engine.dialect.DBType() == core.MYSQL {\n\t\t\t\tif len(data) == 1 {\n\t\t\t\t\tx = int32(data[0])\n\t\t\t\t} else {\n\t\t\t\t\tx = 0\n\t\t\t\t}\n\t\t\t} else if strings.HasPrefix(sdata, \"0x\") {\n\t\t\t\tx1, err = strconv.ParseInt(sdata, 16, 64)\n\t\t\t\tx = int32(x1)\n\t\t\t} else if strings.HasPrefix(sdata, \"0\") {\n\t\t\t\tx1, err = strconv.ParseInt(sdata, 8, 64)\n\t\t\t\tx = int32(x1)\n\t\t\t} else {\n\t\t\t\tx1, err = strconv.ParseInt(sdata, 10, 64)\n\t\t\t\tx = int32(x1)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"arg %v as int: %s\", key, err.Error())\n\t\t\t}\n\t\t\tfieldValue.Set(reflect.ValueOf(&x).Convert(fieldType))\n\t\t// case \"*int8\":\n\t\tcase core.Int8Type.Kind():\n\t\t\tsdata := string(data)\n\t\t\tvar x int8\n\t\t\tvar x1 int64\n\t\t\tvar err error\n\t\t\t// for mysql, when use bit, it returned \\x01\n\t\t\tif col.SQLType.Name == core.Bit &&\n\t\t\t\tstrings.Contains(session.engine.DriverName(), \"mysql\") {\n\t\t\t\tif len(data) == 1 {\n\t\t\t\t\tx = int8(data[0])\n\t\t\t\t} else {\n\t\t\t\t\tx = 0\n\t\t\t\t}\n\t\t\t} else if strings.HasPrefix(sdata, \"0x\") {\n\t\t\t\tx1, err = strconv.ParseInt(sdata, 16, 64)\n\t\t\t\tx = int8(x1)\n\t\t\t} else if strings.HasPrefix(sdata, \"0\") {\n\t\t\t\tx1, err = strconv.ParseInt(sdata, 8, 64)\n\t\t\t\tx = int8(x1)\n\t\t\t} else {\n\t\t\t\tx1, err = strconv.ParseInt(sdata, 10, 64)\n\t\t\t\tx = int8(x1)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"arg %v as int: %s\", key, err.Error())\n\t\t\t}\n\t\t\tfieldValue.Set(reflect.ValueOf(&x).Convert(fieldType))\n\t\t// case \"*int16\":\n\t\tcase core.Int16Type.Kind():\n\t\t\tsdata := string(data)\n\t\t\tvar x int16\n\t\t\tvar x1 int64\n\t\t\tvar err error\n\t\t\t// for mysql, when use bit, it returned \\x01\n\t\t\tif col.SQLType.Name == core.Bit &&\n\t\t\t\tstrings.Contains(session.engine.DriverName(), \"mysql\") {\n\t\t\t\tif len(data) == 1 {\n\t\t\t\t\tx = int16(data[0])\n\t\t\t\t} else {\n\t\t\t\t\tx = 0\n\t\t\t\t}\n\t\t\t} else if strings.HasPrefix(sdata, \"0x\") {\n\t\t\t\tx1, err = strconv.ParseInt(sdata, 16, 64)\n\t\t\t\tx = int16(x1)\n\t\t\t} else if strings.HasPrefix(sdata, \"0\") {\n\t\t\t\tx1, err = strconv.ParseInt(sdata, 8, 64)\n\t\t\t\tx = int16(x1)\n\t\t\t} else {\n\t\t\t\tx1, err = strconv.ParseInt(sdata, 10, 64)\n\t\t\t\tx = int16(x1)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"arg %v as int: %s\", key, err.Error())\n\t\t\t}\n\t\t\tfieldValue.Set(reflect.ValueOf(&x).Convert(fieldType))\n\t\t// case \"*SomeStruct\":\n\t\tcase reflect.Struct:\n\t\t\tswitch fieldType {\n\t\t\t// case \"*.time.Time\":\n\t\t\tcase core.PtrTimeType:\n\t\t\t\tx, err := session.byte2Time(col, data)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tv = x\n\t\t\t\tfieldValue.Set(reflect.ValueOf(&x))\n\t\t\tdefault:\n\t\t\t\tif session.statement.UseCascade {\n\t\t\t\t\tstructInter := reflect.New(fieldType.Elem())\n\t\t\t\t\ttable, err := session.engine.autoMapType(structInter.Elem())\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\n\t\t\t\t\tif len(table.PrimaryKeys) > 1 {\n\t\t\t\t\t\treturn errors.New(\"unsupported composited primary key cascade\")\n\t\t\t\t\t}\n\n\t\t\t\t\tvar pk = make(core.PK, len(table.PrimaryKeys))\n\t\t\t\t\trawValueType := table.ColumnType(table.PKColumns()[0].FieldName)\n\t\t\t\t\tpk[0], err = str2PK(string(data), rawValueType)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\n\t\t\t\t\tif !isPKZero(pk) {\n\t\t\t\t\t\t// !nashtsai! TODO for hasOne relationship, it's preferred to use join query for eager fetch\n\t\t\t\t\t\t// however, also need to consider adding a 'lazy' attribute to xorm tag which allow hasOne\n\t\t\t\t\t\t// property to be fetched lazily\n\t\t\t\t\t\thas, err := session.ID(pk).NoCascade().get(structInter.Interface())\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif has {\n\t\t\t\t\t\t\tv = structInter.Interface()\n\t\t\t\t\t\t\tfieldValue.Set(reflect.ValueOf(v))\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn errors.New(\"cascade obj is not exist\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn fmt.Errorf(\"unsupported struct type in Scan: %s\", fieldValue.Type().String())\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unsupported type in Scan: %s\", fieldValue.Type().String())\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupported type in Scan: %s\", fieldValue.Type().String())\n\t}\n\n\treturn nil\n}\n\n// convert a field value of a struct to interface for put into db\nfunc (session *Session) value2Interface(col *core.Column, fieldValue reflect.Value) (interface{}, error) {\n\tif fieldValue.CanAddr() {\n\t\tif fieldConvert, ok := fieldValue.Addr().Interface().(core.Conversion); ok {\n\t\t\tdata, err := fieldConvert.ToDB()\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tif col.SQLType.IsBlob() {\n\t\t\t\treturn data, nil\n\t\t\t}\n\t\t\treturn string(data), nil\n\t\t}\n\t}\n\n\tif fieldConvert, ok := fieldValue.Interface().(core.Conversion); ok {\n\t\tdata, err := fieldConvert.ToDB()\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tif col.SQLType.IsBlob() {\n\t\t\treturn data, nil\n\t\t}\n\t\treturn string(data), nil\n\t}\n\n\tfieldType := fieldValue.Type()\n\tk := fieldType.Kind()\n\tif k == reflect.Ptr {\n\t\tif fieldValue.IsNil() {\n\t\t\treturn nil, nil\n\t\t} else if !fieldValue.IsValid() {\n\t\t\tsession.engine.logger.Warn(\"the field[\", col.FieldName, \"] is invalid\")\n\t\t\treturn nil, nil\n\t\t} else {\n\t\t\t// !nashtsai! deference pointer type to instance type\n\t\t\tfieldValue = fieldValue.Elem()\n\t\t\tfieldType = fieldValue.Type()\n\t\t\tk = fieldType.Kind()\n\t\t}\n\t}\n\n\tswitch k {\n\tcase reflect.Bool:\n\t\treturn fieldValue.Bool(), nil\n\tcase reflect.String:\n\t\treturn fieldValue.String(), nil\n\tcase reflect.Struct:\n\t\tif fieldType.ConvertibleTo(core.TimeType) {\n\t\t\tt := fieldValue.Convert(core.TimeType).Interface().(time.Time)\n\t\t\ttf := session.engine.formatColTime(col, t)\n\t\t\treturn tf, nil\n\t\t} else if fieldType.ConvertibleTo(nullFloatType) {\n\t\t\tt := fieldValue.Convert(nullFloatType).Interface().(sql.NullFloat64)\n\t\t\tif !t.Valid {\n\t\t\t\treturn nil, nil\n\t\t\t}\n\t\t\treturn t.Float64, nil\n\t\t}\n\n\t\tif !col.SQLType.IsJson() {\n\t\t\t// !<winxxp>! 增加支持driver.Valuer接口的结构，如sql.NullString\n\t\t\tif v, ok := fieldValue.Interface().(driver.Valuer); ok {\n\t\t\t\treturn v.Value()\n\t\t\t}\n\n\t\t\tfieldTable, err := session.engine.autoMapType(fieldValue)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif len(fieldTable.PrimaryKeys) == 1 {\n\t\t\t\tpkField := reflect.Indirect(fieldValue).FieldByName(fieldTable.PKColumns()[0].FieldName)\n\t\t\t\treturn pkField.Interface(), nil\n\t\t\t}\n\t\t\treturn 0, fmt.Errorf(\"no primary key for col %v\", col.Name)\n\t\t}\n\n\t\tif col.SQLType.IsText() {\n\t\t\tbytes, err := DefaultJSONHandler.Marshal(fieldValue.Interface())\n\t\t\tif err != nil {\n\t\t\t\tsession.engine.logger.Error(err)\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\treturn string(bytes), nil\n\t\t} else if col.SQLType.IsBlob() {\n\t\t\tbytes, err := DefaultJSONHandler.Marshal(fieldValue.Interface())\n\t\t\tif err != nil {\n\t\t\t\tsession.engine.logger.Error(err)\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"Unsupported type %v\", fieldValue.Type())\n\tcase reflect.Complex64, reflect.Complex128:\n\t\tbytes, err := DefaultJSONHandler.Marshal(fieldValue.Interface())\n\t\tif err != nil {\n\t\t\tsession.engine.logger.Error(err)\n\t\t\treturn 0, err\n\t\t}\n\t\treturn string(bytes), nil\n\tcase reflect.Array, reflect.Slice, reflect.Map:\n\t\tif !fieldValue.IsValid() {\n\t\t\treturn fieldValue.Interface(), nil\n\t\t}\n\n\t\tif col.SQLType.IsText() {\n\t\t\tbytes, err := DefaultJSONHandler.Marshal(fieldValue.Interface())\n\t\t\tif err != nil {\n\t\t\t\tsession.engine.logger.Error(err)\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\treturn string(bytes), nil\n\t\t} else if col.SQLType.IsBlob() {\n\t\t\tvar bytes []byte\n\t\t\tvar err error\n\t\t\tif (k == reflect.Slice) &&\n\t\t\t\t(fieldValue.Type().Elem().Kind() == reflect.Uint8) {\n\t\t\t\tbytes = fieldValue.Bytes()\n\t\t\t} else {\n\t\t\t\tbytes, err = DefaultJSONHandler.Marshal(fieldValue.Interface())\n\t\t\t\tif err != nil {\n\t\t\t\t\tsession.engine.logger.Error(err)\n\t\t\t\t\treturn 0, err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn bytes, nil\n\t\t}\n\t\treturn nil, ErrUnSupportedType\n\tcase reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:\n\t\treturn int64(fieldValue.Uint()), nil\n\tdefault:\n\t\treturn fieldValue.Interface(), nil\n\t}\n}\n"
        },
        {
          "name": "session_delete.go",
          "type": "blob",
          "size": 6.609375,
          "content": "// Copyright 2016 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n\n\t\"xorm.io/core\"\n)\n\nfunc (session *Session) cacheDelete(table *core.Table, tableName, sqlStr string, args ...interface{}) error {\n\tif table == nil ||\n\t\tsession.tx != nil {\n\t\treturn ErrCacheFailed\n\t}\n\n\tfor _, filter := range session.engine.dialect.Filters() {\n\t\tsqlStr = filter.Do(sqlStr, session.engine.dialect, table)\n\t}\n\n\tnewsql := session.statement.convertIDSQL(sqlStr)\n\tif newsql == \"\" {\n\t\treturn ErrCacheFailed\n\t}\n\n\tcacher := session.engine.getCacher(tableName)\n\tpkColumns := table.PKColumns()\n\tids, err := core.GetCacheSql(cacher, tableName, newsql, args)\n\tif err != nil {\n\t\tresultsSlice, err := session.queryBytes(newsql, args...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tids = make([]core.PK, 0)\n\t\tif len(resultsSlice) > 0 {\n\t\t\tfor _, data := range resultsSlice {\n\t\t\t\tvar id int64\n\t\t\t\tvar pk core.PK = make([]interface{}, 0)\n\t\t\t\tfor _, col := range pkColumns {\n\t\t\t\t\tif v, ok := data[col.Name]; !ok {\n\t\t\t\t\t\treturn errors.New(\"no id\")\n\t\t\t\t\t} else if col.SQLType.IsText() {\n\t\t\t\t\t\tpk = append(pk, string(v))\n\t\t\t\t\t} else if col.SQLType.IsNumeric() {\n\t\t\t\t\t\tid, err = strconv.ParseInt(string(v), 10, 64)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpk = append(pk, id)\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn errors.New(\"not supported primary key type\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tids = append(ids, pk)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, id := range ids {\n\t\tsession.engine.logger.Debug(\"[cacheDelete] delete cache obj:\", tableName, id)\n\t\tsid, err := id.ToString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcacher.DelBean(tableName, sid)\n\t}\n\tsession.engine.logger.Debug(\"[cacheDelete] clear cache table:\", tableName)\n\tcacher.ClearIds(tableName)\n\treturn nil\n}\n\n// Delete records, bean's non-empty fields are conditions\nfunc (session *Session) Delete(bean interface{}) (int64, error) {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\tif session.statement.lastError != nil {\n\t\treturn 0, session.statement.lastError\n\t}\n\n\tif err := session.statement.setRefBean(bean); err != nil {\n\t\treturn 0, err\n\t}\n\n\t// handle before delete processors\n\tfor _, closure := range session.beforeClosures {\n\t\tclosure(bean)\n\t}\n\tcleanupProcessorsClosures(&session.beforeClosures)\n\n\tif processor, ok := interface{}(bean).(BeforeDeleteProcessor); ok {\n\t\tprocessor.BeforeDelete()\n\t}\n\n\tcondSQL, condArgs, err := session.statement.genConds(bean)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif len(condSQL) == 0 && session.statement.LimitN == 0 {\n\t\treturn 0, ErrNeedDeletedCond\n\t}\n\n\tvar tableNameNoQuote = session.statement.TableName()\n\tvar tableName = session.engine.Quote(tableNameNoQuote)\n\tvar table = session.statement.RefTable\n\tvar deleteSQL string\n\tif len(condSQL) > 0 {\n\t\tdeleteSQL = fmt.Sprintf(\"DELETE FROM %v WHERE %v\", tableName, condSQL)\n\t} else {\n\t\tdeleteSQL = fmt.Sprintf(\"DELETE FROM %v\", tableName)\n\t}\n\n\tvar orderSQL string\n\tif len(session.statement.OrderStr) > 0 {\n\t\torderSQL += fmt.Sprintf(\" ORDER BY %s\", session.statement.OrderStr)\n\t}\n\tif session.statement.LimitN > 0 {\n\t\torderSQL += fmt.Sprintf(\" LIMIT %d\", session.statement.LimitN)\n\t}\n\n\tif len(orderSQL) > 0 {\n\t\tswitch session.engine.dialect.DBType() {\n\t\tcase core.POSTGRES:\n\t\t\tinSQL := fmt.Sprintf(\"ctid IN (SELECT ctid FROM %s%s)\", tableName, orderSQL)\n\t\t\tif len(condSQL) > 0 {\n\t\t\t\tdeleteSQL += \" AND \" + inSQL\n\t\t\t} else {\n\t\t\t\tdeleteSQL += \" WHERE \" + inSQL\n\t\t\t}\n\t\tcase core.SQLITE:\n\t\t\tinSQL := fmt.Sprintf(\"rowid IN (SELECT rowid FROM %s%s)\", tableName, orderSQL)\n\t\t\tif len(condSQL) > 0 {\n\t\t\t\tdeleteSQL += \" AND \" + inSQL\n\t\t\t} else {\n\t\t\t\tdeleteSQL += \" WHERE \" + inSQL\n\t\t\t}\n\t\t// TODO: how to handle delete limit on mssql?\n\t\tcase core.MSSQL:\n\t\t\treturn 0, ErrNotImplemented\n\t\tdefault:\n\t\t\tdeleteSQL += orderSQL\n\t\t}\n\t}\n\n\tvar realSQL string\n\targsForCache := make([]interface{}, 0, len(condArgs)*2)\n\tif session.statement.unscoped || table.DeletedColumn() == nil { // tag \"deleted\" is disabled\n\t\trealSQL = deleteSQL\n\t\tcopy(argsForCache, condArgs)\n\t\targsForCache = append(condArgs, argsForCache...)\n\t} else {\n\t\t// !oinume! sqlStrForCache and argsForCache is needed to behave as executing \"DELETE FROM ...\" for cache.\n\t\tcopy(argsForCache, condArgs)\n\t\targsForCache = append(condArgs, argsForCache...)\n\n\t\tdeletedColumn := table.DeletedColumn()\n\t\trealSQL = fmt.Sprintf(\"UPDATE %v SET %v = ? WHERE %v\",\n\t\t\tsession.engine.Quote(session.statement.TableName()),\n\t\t\tsession.engine.Quote(deletedColumn.Name),\n\t\t\tcondSQL)\n\n\t\tif len(orderSQL) > 0 {\n\t\t\tswitch session.engine.dialect.DBType() {\n\t\t\tcase core.POSTGRES:\n\t\t\t\tinSQL := fmt.Sprintf(\"ctid IN (SELECT ctid FROM %s%s)\", tableName, orderSQL)\n\t\t\t\tif len(condSQL) > 0 {\n\t\t\t\t\trealSQL += \" AND \" + inSQL\n\t\t\t\t} else {\n\t\t\t\t\trealSQL += \" WHERE \" + inSQL\n\t\t\t\t}\n\t\t\tcase core.SQLITE:\n\t\t\t\tinSQL := fmt.Sprintf(\"rowid IN (SELECT rowid FROM %s%s)\", tableName, orderSQL)\n\t\t\t\tif len(condSQL) > 0 {\n\t\t\t\t\trealSQL += \" AND \" + inSQL\n\t\t\t\t} else {\n\t\t\t\t\trealSQL += \" WHERE \" + inSQL\n\t\t\t\t}\n\t\t\t// TODO: how to handle delete limit on mssql?\n\t\t\tcase core.MSSQL:\n\t\t\t\treturn 0, ErrNotImplemented\n\t\t\tdefault:\n\t\t\t\trealSQL += orderSQL\n\t\t\t}\n\t\t}\n\n\t\t// !oinume! Insert nowTime to the head of session.statement.Params\n\t\tcondArgs = append(condArgs, \"\")\n\t\tparamsLen := len(condArgs)\n\t\tcopy(condArgs[1:paramsLen], condArgs[0:paramsLen-1])\n\n\t\tval, t := session.engine.nowTime(deletedColumn)\n\t\tcondArgs[0] = val\n\n\t\tvar colName = deletedColumn.Name\n\t\tsession.afterClosures = append(session.afterClosures, func(bean interface{}) {\n\t\t\tcol := table.GetColumn(colName)\n\t\t\tsetColumnTime(bean, col, t)\n\t\t})\n\t}\n\n\tif cacher := session.engine.getCacher(tableNameNoQuote); cacher != nil && session.statement.UseCache {\n\t\tsession.cacheDelete(table, tableNameNoQuote, deleteSQL, argsForCache...)\n\t}\n\n\tsession.statement.RefTable = table\n\tres, err := session.exec(realSQL, condArgs...)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// handle after delete processors\n\tif session.isAutoCommit {\n\t\tfor _, closure := range session.afterClosures {\n\t\t\tclosure(bean)\n\t\t}\n\t\tif processor, ok := interface{}(bean).(AfterDeleteProcessor); ok {\n\t\t\tprocessor.AfterDelete()\n\t\t}\n\t} else {\n\t\tlenAfterClosures := len(session.afterClosures)\n\t\tif lenAfterClosures > 0 {\n\t\t\tif value, has := session.afterDeleteBeans[bean]; has && value != nil {\n\t\t\t\t*value = append(*value, session.afterClosures...)\n\t\t\t} else {\n\t\t\t\tafterClosures := make([]func(interface{}), lenAfterClosures)\n\t\t\t\tcopy(afterClosures, session.afterClosures)\n\t\t\t\tsession.afterDeleteBeans[bean] = &afterClosures\n\t\t\t}\n\t\t} else {\n\t\t\tif _, ok := interface{}(bean).(AfterDeleteProcessor); ok {\n\t\t\t\tsession.afterDeleteBeans[bean] = nil\n\t\t\t}\n\t\t}\n\t}\n\tcleanupProcessorsClosures(&session.afterClosures)\n\t// --\n\n\treturn res.RowsAffected()\n}\n"
        },
        {
          "name": "session_delete_test.go",
          "type": "blob",
          "size": 6.2294921875,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"xorm.io/core\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDelete(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UserinfoDelete struct {\n\t\tUid   int64 `xorm:\"id pk not null autoincr\"`\n\t\tIsMan bool\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(UserinfoDelete)))\n\n\tsession := testEngine.NewSession()\n\tdefer session.Close()\n\n\tvar err error\n\tif testEngine.Dialect().DBType() == core.MSSQL {\n\t\terr = session.Begin()\n\t\tassert.NoError(t, err)\n\t\t_, err = session.Exec(\"SET IDENTITY_INSERT userinfo_delete ON\")\n\t\tassert.NoError(t, err)\n\t}\n\n\tuser := UserinfoDelete{Uid: 1}\n\tcnt, err := session.Insert(&user)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tif testEngine.Dialect().DBType() == core.MSSQL {\n\t\terr = session.Commit()\n\t\tassert.NoError(t, err)\n\t}\n\n\tcnt, err = testEngine.Delete(&UserinfoDelete{Uid: user.Uid})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tuser.Uid = 0\n\tuser.IsMan = true\n\thas, err := testEngine.ID(1).Get(&user)\n\tassert.NoError(t, err)\n\tassert.False(t, has)\n\n\tcnt, err = testEngine.Insert(&user)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tcnt, err = testEngine.Where(\"`id`=?\", user.Uid).Delete(&UserinfoDelete{})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tuser.Uid = 0\n\tuser.IsMan = true\n\thas, err = testEngine.ID(2).Get(&user)\n\tassert.NoError(t, err)\n\tassert.False(t, has)\n}\n\nfunc TestDeleted(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype Deleted struct {\n\t\tId        int64 `xorm:\"pk\"`\n\t\tName      string\n\t\tDeletedAt time.Time `xorm:\"deleted\"`\n\t}\n\n\terr := testEngine.DropTables(&Deleted{})\n\tassert.NoError(t, err)\n\n\terr = testEngine.CreateTables(&Deleted{})\n\tassert.NoError(t, err)\n\n\t_, err = testEngine.InsertOne(&Deleted{Id: 1, Name: \"11111\"})\n\tassert.NoError(t, err)\n\n\t_, err = testEngine.InsertOne(&Deleted{Id: 2, Name: \"22222\"})\n\tassert.NoError(t, err)\n\n\t_, err = testEngine.InsertOne(&Deleted{Id: 3, Name: \"33333\"})\n\tassert.NoError(t, err)\n\n\t// Test normal Find()\n\tvar records1 []Deleted\n\terr = testEngine.Where(\"`\"+testEngine.GetColumnMapper().Obj2Table(\"Id\")+\"` > 0\").Find(&records1, &Deleted{})\n\tassert.EqualValues(t, 3, len(records1))\n\n\t// Test normal Get()\n\trecord1 := &Deleted{}\n\thas, err := testEngine.ID(1).Get(record1)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\t// Test Delete() with deleted\n\taffected, err := testEngine.ID(1).Delete(&Deleted{})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, affected)\n\n\thas, err = testEngine.ID(1).Get(&Deleted{})\n\tassert.NoError(t, err)\n\tassert.False(t, has)\n\n\tvar records2 []Deleted\n\terr = testEngine.Where(\"`\" + testEngine.GetColumnMapper().Obj2Table(\"Id\") + \"` > 0\").Find(&records2)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, len(records2))\n\n\t// Test no rows affected after Delete() again.\n\taffected, err = testEngine.ID(1).Delete(&Deleted{})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 0, affected)\n\n\t// Deleted.DeletedAt must not be updated.\n\taffected, err = testEngine.ID(2).Update(&Deleted{Name: \"2\", DeletedAt: time.Now()})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, affected)\n\n\trecord2 := &Deleted{}\n\thas, err = testEngine.ID(2).Get(record2)\n\tassert.NoError(t, err)\n\tassert.True(t, record2.DeletedAt.IsZero())\n\n\t// Test find all records whatever `deleted`.\n\tvar unscopedRecords1 []Deleted\n\terr = testEngine.Unscoped().Where(\"`\"+testEngine.GetColumnMapper().Obj2Table(\"Id\")+\"` > 0\").Find(&unscopedRecords1, &Deleted{})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 3, len(unscopedRecords1))\n\n\t// Delete() must really delete a record with Unscoped()\n\taffected, err = testEngine.Unscoped().ID(1).Delete(&Deleted{})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, affected)\n\n\tvar unscopedRecords2 []Deleted\n\terr = testEngine.Unscoped().Where(\"`\"+testEngine.GetColumnMapper().Obj2Table(\"Id\")+\"` > 0\").Find(&unscopedRecords2, &Deleted{})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, len(unscopedRecords2))\n\n\tvar records3 []Deleted\n\terr = testEngine.Where(\"`\"+testEngine.GetColumnMapper().Obj2Table(\"Id\")+\"` > 0\").And(\"`\"+testEngine.GetColumnMapper().Obj2Table(\"Id\")+\"`> 1\").\n\t\tOr(\"`\"+testEngine.GetColumnMapper().Obj2Table(\"Id\")+\"` = ?\", 3).Find(&records3)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, len(records3))\n}\n\nfunc TestCacheDelete(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\toldCacher := testEngine.GetDefaultCacher()\n\tcacher := NewLRUCacher(NewMemoryStore(), 1000)\n\ttestEngine.SetDefaultCacher(cacher)\n\n\ttype CacheDeleteStruct struct {\n\t\tId int64\n\t}\n\n\terr := testEngine.CreateTables(&CacheDeleteStruct{})\n\tassert.NoError(t, err)\n\n\t_, err = testEngine.Insert(&CacheDeleteStruct{})\n\tassert.NoError(t, err)\n\n\taff, err := testEngine.Delete(&CacheDeleteStruct{\n\t\tId: 1,\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, aff, 1)\n\n\taff, err = testEngine.Unscoped().Delete(&CacheDeleteStruct{\n\t\tId: 1,\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, aff, 0)\n\n\ttestEngine.SetDefaultCacher(oldCacher)\n}\n\nfunc TestUnscopeDelete(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UnscopeDeleteStruct struct {\n\t\tId        int64\n\t\tName      string\n\t\tDeletedAt time.Time `xorm:\"deleted\"`\n\t}\n\n\tassertSync(t, new(UnscopeDeleteStruct))\n\n\tcnt, err := testEngine.Insert(&UnscopeDeleteStruct{\n\t\tName: \"test\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar nowUnix = time.Now().Unix()\n\tvar s UnscopeDeleteStruct\n\tcnt, err = testEngine.ID(1).Delete(&s)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\tassert.EqualValues(t, nowUnix, s.DeletedAt.Unix())\n\n\tvar s1 UnscopeDeleteStruct\n\thas, err := testEngine.ID(1).Get(&s1)\n\tassert.NoError(t, err)\n\tassert.False(t, has)\n\n\tvar s2 UnscopeDeleteStruct\n\thas, err = testEngine.ID(1).Unscoped().Get(&s2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, \"test\", s2.Name)\n\tassert.EqualValues(t, nowUnix, s2.DeletedAt.Unix())\n\n\tcnt, err = testEngine.ID(1).Unscoped().Delete(new(UnscopeDeleteStruct))\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar s3 UnscopeDeleteStruct\n\thas, err = testEngine.ID(1).Get(&s3)\n\tassert.NoError(t, err)\n\tassert.False(t, has)\n\n\tvar s4 UnscopeDeleteStruct\n\thas, err = testEngine.ID(1).Unscoped().Get(&s4)\n\tassert.NoError(t, err)\n\tassert.False(t, has)\n}\n"
        },
        {
          "name": "session_exist.go",
          "type": "blob",
          "size": 2.4599609375,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"xorm.io/builder\"\n\t\"xorm.io/core\"\n)\n\n// Exist returns true if the record exist otherwise return false\nfunc (session *Session) Exist(bean ...interface{}) (bool, error) {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\tif session.statement.lastError != nil {\n\t\treturn false, session.statement.lastError\n\t}\n\n\tvar sqlStr string\n\tvar args []interface{}\n\tvar err error\n\n\tif session.statement.RawSQL == \"\" {\n\t\tif len(bean) == 0 {\n\t\t\ttableName := session.statement.TableName()\n\t\t\tif len(tableName) <= 0 {\n\t\t\t\treturn false, ErrTableNotFound\n\t\t\t}\n\n\t\t\ttableName = session.statement.Engine.Quote(tableName)\n\n\t\t\tif session.statement.cond.IsValid() {\n\t\t\t\tcondSQL, condArgs, err := builder.ToSQL(session.statement.cond)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn false, err\n\t\t\t\t}\n\n\t\t\t\tif session.engine.dialect.DBType() == core.MSSQL {\n\t\t\t\t\tsqlStr = fmt.Sprintf(\"SELECT TOP 1 * FROM %s WHERE %s\", tableName, condSQL)\n\t\t\t\t} else if session.engine.dialect.DBType() == core.ORACLE {\n\t\t\t\t\tsqlStr = fmt.Sprintf(\"SELECT * FROM %s WHERE (%s) AND ROWNUM=1\", tableName, condSQL)\n\t\t\t\t} else {\n\t\t\t\t\tsqlStr = fmt.Sprintf(\"SELECT * FROM %s WHERE %s LIMIT 1\", tableName, condSQL)\n\t\t\t\t}\n\t\t\t\targs = condArgs\n\t\t\t} else {\n\t\t\t\tif session.engine.dialect.DBType() == core.MSSQL {\n\t\t\t\t\tsqlStr = fmt.Sprintf(\"SELECT TOP 1 * FROM %s\", tableName)\n\t\t\t\t} else if session.engine.dialect.DBType() == core.ORACLE {\n\t\t\t\t\tsqlStr = fmt.Sprintf(\"SELECT * FROM  %s WHERE ROWNUM=1\", tableName)\n\t\t\t\t} else {\n\t\t\t\t\tsqlStr = fmt.Sprintf(\"SELECT * FROM %s LIMIT 1\", tableName)\n\t\t\t\t}\n\t\t\t\targs = []interface{}{}\n\t\t\t}\n\t\t} else {\n\t\t\tbeanValue := reflect.ValueOf(bean[0])\n\t\t\tif beanValue.Kind() != reflect.Ptr {\n\t\t\t\treturn false, errors.New(\"needs a pointer\")\n\t\t\t}\n\n\t\t\tif beanValue.Elem().Kind() == reflect.Struct {\n\t\t\t\tif err := session.statement.setRefBean(bean[0]); err != nil {\n\t\t\t\t\treturn false, err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(session.statement.TableName()) <= 0 {\n\t\t\t\treturn false, ErrTableNotFound\n\t\t\t}\n\t\t\tsession.statement.Limit(1)\n\t\t\tsqlStr, args, err = session.statement.genGetSQL(bean[0])\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsqlStr = session.statement.RawSQL\n\t\targs = session.statement.RawParams\n\t}\n\n\trows, err := session.queryRows(sqlStr, args...)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer rows.Close()\n\n\treturn rows.Next(), nil\n}\n"
        },
        {
          "name": "session_exist_test.go",
          "type": "blob",
          "size": 1.8203125,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestExistStruct(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype RecordExist struct {\n\t\tId   int64\n\t\tName string\n\t}\n\n\tassertSync(t, new(RecordExist))\n\n\thas, err := testEngine.Exist(new(RecordExist))\n\tassert.NoError(t, err)\n\tassert.False(t, has)\n\n\tcnt, err := testEngine.Insert(&RecordExist{\n\t\tName: \"test1\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\thas, err = testEngine.Exist(new(RecordExist))\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\thas, err = testEngine.Exist(&RecordExist{\n\t\tName: \"test1\",\n\t})\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\thas, err = testEngine.Exist(&RecordExist{\n\t\tName: \"test2\",\n\t})\n\tassert.NoError(t, err)\n\tassert.False(t, has)\n\n\thas, err = testEngine.Where(\"name = ?\", \"test1\").Exist(&RecordExist{})\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\thas, err = testEngine.Where(\"name = ?\", \"test2\").Exist(&RecordExist{})\n\tassert.NoError(t, err)\n\tassert.False(t, has)\n\n\thas, err = testEngine.SQL(\"select * from \"+testEngine.TableName(\"record_exist\", true)+\" where name = ?\", \"test1\").Exist()\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\thas, err = testEngine.SQL(\"select * from \"+testEngine.TableName(\"record_exist\", true)+\" where name = ?\", \"test2\").Exist()\n\tassert.NoError(t, err)\n\tassert.False(t, has)\n\n\thas, err = testEngine.Table(\"record_exist\").Exist()\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\thas, err = testEngine.Table(\"record_exist\").Where(\"name = ?\", \"test1\").Exist()\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\thas, err = testEngine.Table(\"record_exist\").Where(\"name = ?\", \"test2\").Exist()\n\tassert.NoError(t, err)\n\tassert.False(t, has)\n}\n"
        },
        {
          "name": "session_find.go",
          "type": "blob",
          "size": 12.9794921875,
          "content": "// Copyright 2016 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"xorm.io/builder\"\n\t\"xorm.io/core\"\n)\n\nconst (\n\ttpStruct = iota\n\ttpNonStruct\n)\n\n// Find retrieve records from table, condiBeans's non-empty fields\n// are conditions. beans could be []Struct, []*Struct, map[int64]Struct\n// map[int64]*Struct\nfunc (session *Session) Find(rowsSlicePtr interface{}, condiBean ...interface{}) error {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\treturn session.find(rowsSlicePtr, condiBean...)\n}\n\n// FindAndCount find the results and also return the counts\nfunc (session *Session) FindAndCount(rowsSlicePtr interface{}, condiBean ...interface{}) (int64, error) {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\tsession.autoResetStatement = false\n\terr := session.find(rowsSlicePtr, condiBean...)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tsliceValue := reflect.Indirect(reflect.ValueOf(rowsSlicePtr))\n\tif sliceValue.Kind() != reflect.Slice && sliceValue.Kind() != reflect.Map {\n\t\treturn 0, errors.New(\"needs a pointer to a slice or a map\")\n\t}\n\n\tsliceElementType := sliceValue.Type().Elem()\n\tif sliceElementType.Kind() == reflect.Ptr {\n\t\tsliceElementType = sliceElementType.Elem()\n\t}\n\tsession.autoResetStatement = true\n\n\tif session.statement.selectStr != \"\" {\n\t\tsession.statement.selectStr = \"\"\n\t}\n\tif session.statement.OrderStr != \"\" {\n\t\tsession.statement.OrderStr = \"\"\n\t}\n\n\treturn session.Count(reflect.New(sliceElementType).Interface())\n}\n\nfunc (session *Session) find(rowsSlicePtr interface{}, condiBean ...interface{}) error {\n\tdefer session.resetStatement()\n\n\tif session.statement.lastError != nil {\n\t\treturn session.statement.lastError\n\t}\n\n\tsliceValue := reflect.Indirect(reflect.ValueOf(rowsSlicePtr))\n\tif sliceValue.Kind() != reflect.Slice && sliceValue.Kind() != reflect.Map {\n\t\treturn errors.New(\"needs a pointer to a slice or a map\")\n\t}\n\n\tsliceElementType := sliceValue.Type().Elem()\n\n\tvar tp = tpStruct\n\tif session.statement.RefTable == nil {\n\t\tif sliceElementType.Kind() == reflect.Ptr {\n\t\t\tif sliceElementType.Elem().Kind() == reflect.Struct {\n\t\t\t\tpv := reflect.New(sliceElementType.Elem())\n\t\t\t\tif err := session.statement.setRefValue(pv); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttp = tpNonStruct\n\t\t\t}\n\t\t} else if sliceElementType.Kind() == reflect.Struct {\n\t\t\tpv := reflect.New(sliceElementType)\n\t\t\tif err := session.statement.setRefValue(pv); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\ttp = tpNonStruct\n\t\t}\n\t}\n\n\tvar table = session.statement.RefTable\n\n\tvar addedTableName = (len(session.statement.JoinStr) > 0)\n\tvar autoCond builder.Cond\n\tif tp == tpStruct {\n\t\tif !session.statement.noAutoCondition && len(condiBean) > 0 {\n\t\t\tvar err error\n\t\t\tautoCond, err = session.statement.buildConds(table, condiBean[0], true, true, false, true, addedTableName)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\t// !oinume! Add \"<col> IS NULL\" to WHERE whatever condiBean is given.\n\t\t\t// See https://github.com/go-xorm/xorm/issues/179\n\t\t\tif col := table.DeletedColumn(); col != nil && !session.statement.unscoped { // tag \"deleted\" is enabled\n\t\t\t\tvar colName = session.engine.Quote(col.Name)\n\t\t\t\tif addedTableName {\n\t\t\t\t\tvar nm = session.statement.TableName()\n\t\t\t\t\tif len(session.statement.TableAlias) > 0 {\n\t\t\t\t\t\tnm = session.statement.TableAlias\n\t\t\t\t\t}\n\t\t\t\t\tcolName = session.engine.Quote(nm) + \".\" + colName\n\t\t\t\t}\n\n\t\t\t\tautoCond = session.engine.CondDeleted(colName)\n\t\t\t}\n\t\t}\n\t}\n\n\tvar sqlStr string\n\tvar args []interface{}\n\tvar err error\n\tif session.statement.RawSQL == \"\" {\n\t\tif len(session.statement.TableName()) <= 0 {\n\t\t\treturn ErrTableNotFound\n\t\t}\n\n\t\tvar columnStr = session.statement.ColumnStr\n\t\tif len(session.statement.selectStr) > 0 {\n\t\t\tcolumnStr = session.statement.selectStr\n\t\t} else {\n\t\t\tif session.statement.JoinStr == \"\" {\n\t\t\t\tif columnStr == \"\" {\n\t\t\t\t\tif session.statement.GroupByStr != \"\" {\n\t\t\t\t\t\tcolumnStr = session.engine.quoteColumns(session.statement.GroupByStr)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumnStr = session.statement.genColumnStr()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif columnStr == \"\" {\n\t\t\t\t\tif session.statement.GroupByStr != \"\" {\n\t\t\t\t\t\tcolumnStr = session.engine.quoteColumns(session.statement.GroupByStr)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumnStr = \"*\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif columnStr == \"\" {\n\t\t\t\tcolumnStr = \"*\"\n\t\t\t}\n\t\t}\n\n\t\tsession.statement.cond = session.statement.cond.And(autoCond)\n\t\tcondSQL, condArgs, err := builder.ToSQL(session.statement.cond)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\targs = append(session.statement.joinArgs, condArgs...)\n\t\tsqlStr, err = session.statement.genSelectSQL(columnStr, condSQL, true, true)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// for mssql and use limit\n\t\tqs := strings.Count(sqlStr, \"?\")\n\t\tif len(args)*2 == qs {\n\t\t\targs = append(args, args...)\n\t\t}\n\t} else {\n\t\tsqlStr = session.statement.RawSQL\n\t\targs = session.statement.RawParams\n\t}\n\n\tif session.canCache() {\n\t\tif cacher := session.engine.getCacher(session.statement.TableName()); cacher != nil &&\n\t\t\t!session.statement.IsDistinct &&\n\t\t\t!session.statement.unscoped {\n\t\t\terr = session.cacheFind(sliceElementType, sqlStr, rowsSlicePtr, args...)\n\t\t\tif err != ErrCacheFailed {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\terr = nil // !nashtsai! reset err to nil for ErrCacheFailed\n\t\t\tsession.engine.logger.Warn(\"Cache Find Failed\")\n\t\t}\n\t}\n\n\treturn session.noCacheFind(table, sliceValue, sqlStr, args...)\n}\n\nfunc (session *Session) noCacheFind(table *core.Table, containerValue reflect.Value, sqlStr string, args ...interface{}) error {\n\trows, err := session.queryRows(sqlStr, args...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer rows.Close()\n\n\tfields, err := rows.Columns()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar newElemFunc func(fields []string) reflect.Value\n\telemType := containerValue.Type().Elem()\n\tvar isPointer bool\n\tif elemType.Kind() == reflect.Ptr {\n\t\tisPointer = true\n\t\telemType = elemType.Elem()\n\t}\n\tif elemType.Kind() == reflect.Ptr {\n\t\treturn errors.New(\"pointer to pointer is not supported\")\n\t}\n\n\tnewElemFunc = func(fields []string) reflect.Value {\n\t\tswitch elemType.Kind() {\n\t\tcase reflect.Slice:\n\t\t\tslice := reflect.MakeSlice(elemType, len(fields), len(fields))\n\t\t\tx := reflect.New(slice.Type())\n\t\t\tx.Elem().Set(slice)\n\t\t\treturn x\n\t\tcase reflect.Map:\n\t\t\tmp := reflect.MakeMap(elemType)\n\t\t\tx := reflect.New(mp.Type())\n\t\t\tx.Elem().Set(mp)\n\t\t\treturn x\n\t\t}\n\t\treturn reflect.New(elemType)\n\t}\n\n\tvar containerValueSetFunc func(*reflect.Value, core.PK) error\n\n\tif containerValue.Kind() == reflect.Slice {\n\t\tcontainerValueSetFunc = func(newValue *reflect.Value, pk core.PK) error {\n\t\t\tif isPointer {\n\t\t\t\tcontainerValue.Set(reflect.Append(containerValue, newValue.Elem().Addr()))\n\t\t\t} else {\n\t\t\t\tcontainerValue.Set(reflect.Append(containerValue, newValue.Elem()))\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t} else {\n\t\tkeyType := containerValue.Type().Key()\n\t\tif len(table.PrimaryKeys) == 0 {\n\t\t\treturn errors.New(\"don't support multiple primary key's map has non-slice key type\")\n\t\t}\n\t\tif len(table.PrimaryKeys) > 1 && keyType.Kind() != reflect.Slice {\n\t\t\treturn errors.New(\"don't support multiple primary key's map has non-slice key type\")\n\t\t}\n\n\t\tcontainerValueSetFunc = func(newValue *reflect.Value, pk core.PK) error {\n\t\t\tkeyValue := reflect.New(keyType)\n\t\t\terr := convertPKToValue(table, keyValue.Interface(), pk)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif isPointer {\n\t\t\t\tcontainerValue.SetMapIndex(keyValue.Elem(), newValue.Elem().Addr())\n\t\t\t} else {\n\t\t\t\tcontainerValue.SetMapIndex(keyValue.Elem(), newValue.Elem())\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif elemType.Kind() == reflect.Struct {\n\t\tvar newValue = newElemFunc(fields)\n\t\tdataStruct := rValue(newValue.Interface())\n\t\ttb, err := session.engine.autoMapType(dataStruct)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = session.rows2Beans(rows, fields, tb, newElemFunc, containerValueSetFunc)\n\t\trows.Close()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn session.executeProcessors()\n\t}\n\n\tfor rows.Next() {\n\t\tvar newValue = newElemFunc(fields)\n\t\tbean := newValue.Interface()\n\n\t\tswitch elemType.Kind() {\n\t\tcase reflect.Slice:\n\t\t\terr = rows.ScanSlice(bean)\n\t\tcase reflect.Map:\n\t\t\terr = rows.ScanMap(bean)\n\t\tdefault:\n\t\t\terr = rows.Scan(bean)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := containerValueSetFunc(&newValue, nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc convertPKToValue(table *core.Table, dst interface{}, pk core.PK) error {\n\tcols := table.PKColumns()\n\tif len(cols) == 1 {\n\t\treturn convertAssign(dst, pk[0])\n\t}\n\n\tdst = pk\n\treturn nil\n}\n\nfunc (session *Session) cacheFind(t reflect.Type, sqlStr string, rowsSlicePtr interface{}, args ...interface{}) (err error) {\n\tif !session.canCache() ||\n\t\tindexNoCase(sqlStr, \"having\") != -1 ||\n\t\tindexNoCase(sqlStr, \"group by\") != -1 {\n\t\treturn ErrCacheFailed\n\t}\n\n\ttableName := session.statement.TableName()\n\tcacher := session.engine.getCacher(tableName)\n\tif cacher == nil {\n\t\treturn nil\n\t}\n\n\tfor _, filter := range session.engine.dialect.Filters() {\n\t\tsqlStr = filter.Do(sqlStr, session.engine.dialect, session.statement.RefTable)\n\t}\n\n\tnewsql := session.statement.convertIDSQL(sqlStr)\n\tif newsql == \"\" {\n\t\treturn ErrCacheFailed\n\t}\n\n\ttable := session.statement.RefTable\n\tids, err := core.GetCacheSql(cacher, tableName, newsql, args)\n\tif err != nil {\n\t\trows, err := session.queryRows(newsql, args...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer rows.Close()\n\n\t\tvar i int\n\t\tids = make([]core.PK, 0)\n\t\tfor rows.Next() {\n\t\t\ti++\n\t\t\tif i > 500 {\n\t\t\t\tsession.engine.logger.Debug(\"[cacheFind] ids length > 500, no cache\")\n\t\t\t\treturn ErrCacheFailed\n\t\t\t}\n\t\t\tvar res = make([]string, len(table.PrimaryKeys))\n\t\t\terr = rows.ScanSlice(&res)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tvar pk core.PK = make([]interface{}, len(table.PrimaryKeys))\n\t\t\tfor i, col := range table.PKColumns() {\n\t\t\t\tpk[i], err = session.engine.idTypeAssertion(col, res[i])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tids = append(ids, pk)\n\t\t}\n\n\t\tsession.engine.logger.Debug(\"[cacheFind] cache sql:\", ids, tableName, sqlStr, newsql, args)\n\t\terr = core.PutCacheSql(cacher, ids, tableName, newsql, args)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tsession.engine.logger.Debug(\"[cacheFind] cache hit sql:\", tableName, sqlStr, newsql, args)\n\t}\n\n\tsliceValue := reflect.Indirect(reflect.ValueOf(rowsSlicePtr))\n\n\tididxes := make(map[string]int)\n\tvar ides []core.PK\n\tvar temps = make([]interface{}, len(ids))\n\n\tfor idx, id := range ids {\n\t\tsid, err := id.ToString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbean := cacher.GetBean(tableName, sid)\n\t\tif bean == nil || reflect.ValueOf(bean).Elem().Type() != t {\n\t\t\tides = append(ides, id)\n\t\t\tididxes[sid] = idx\n\t\t} else {\n\t\t\tsession.engine.logger.Debug(\"[cacheFind] cache hit bean:\", tableName, id, bean)\n\n\t\t\tpk := session.engine.IdOf(bean)\n\t\t\txid, err := pk.ToString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif sid != xid {\n\t\t\t\tsession.engine.logger.Error(\"[cacheFind] error cache\", xid, sid, bean)\n\t\t\t\treturn ErrCacheFailed\n\t\t\t}\n\t\t\ttemps[idx] = bean\n\t\t}\n\t}\n\n\tif len(ides) > 0 {\n\t\tslices := reflect.New(reflect.SliceOf(t))\n\t\tbeans := slices.Interface()\n\n\t\tif len(table.PrimaryKeys) == 1 {\n\t\t\tff := make([]interface{}, 0, len(ides))\n\t\t\tfor _, ie := range ides {\n\t\t\t\tff = append(ff, ie[0])\n\t\t\t}\n\n\t\t\tsession.In(\"`\"+table.PrimaryKeys[0]+\"`\", ff...)\n\t\t} else {\n\t\t\tfor _, ie := range ides {\n\t\t\t\tcond := builder.NewCond()\n\t\t\t\tfor i, name := range table.PrimaryKeys {\n\t\t\t\t\tcond = cond.And(builder.Eq{\"`\" + name + \"`\": ie[i]})\n\t\t\t\t}\n\t\t\t\tsession.Or(cond)\n\t\t\t}\n\t\t}\n\n\t\terr = session.NoCache().Table(tableName).find(beans)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvs := reflect.Indirect(reflect.ValueOf(beans))\n\t\tfor i := 0; i < vs.Len(); i++ {\n\t\t\trv := vs.Index(i)\n\t\t\tif rv.Kind() != reflect.Ptr {\n\t\t\t\trv = rv.Addr()\n\t\t\t}\n\t\t\tid, err := session.engine.idOfV(rv)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsid, err := id.ToString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tbean := rv.Interface()\n\t\t\ttemps[ididxes[sid]] = bean\n\t\t\tsession.engine.logger.Debug(\"[cacheFind] cache bean:\", tableName, id, bean, temps)\n\t\t\tcacher.PutBean(tableName, sid, bean)\n\t\t}\n\t}\n\n\tfor j := 0; j < len(temps); j++ {\n\t\tbean := temps[j]\n\t\tif bean == nil {\n\t\t\tsession.engine.logger.Warn(\"[cacheFind] cache no hit:\", tableName, ids[j], temps)\n\t\t\t// return errors.New(\"cache error\") // !nashtsai! no need to return error, but continue instead\n\t\t\tcontinue\n\t\t}\n\t\tif sliceValue.Kind() == reflect.Slice {\n\t\t\tif t.Kind() == reflect.Ptr {\n\t\t\t\tsliceValue.Set(reflect.Append(sliceValue, reflect.ValueOf(bean)))\n\t\t\t} else {\n\t\t\t\tsliceValue.Set(reflect.Append(sliceValue, reflect.Indirect(reflect.ValueOf(bean))))\n\t\t\t}\n\t\t} else if sliceValue.Kind() == reflect.Map {\n\t\t\tvar key = ids[j]\n\t\t\tkeyType := sliceValue.Type().Key()\n\t\t\tvar ikey interface{}\n\t\t\tif len(key) == 1 {\n\t\t\t\tikey, err = str2PK(fmt.Sprintf(\"%v\", key[0]), keyType)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif keyType.Kind() != reflect.Slice {\n\t\t\t\t\treturn errors.New(\"table have multiple primary keys, key is not core.PK or slice\")\n\t\t\t\t}\n\t\t\t\tikey = key\n\t\t\t}\n\n\t\t\tif t.Kind() == reflect.Ptr {\n\t\t\t\tsliceValue.SetMapIndex(reflect.ValueOf(ikey), reflect.ValueOf(bean))\n\t\t\t} else {\n\t\t\t\tsliceValue.SetMapIndex(reflect.ValueOf(ikey), reflect.Indirect(reflect.ValueOf(bean)))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "session_find_test.go",
          "type": "blob",
          "size": 18.0615234375,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"xorm.io/core\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestJoinLimit(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype Salary struct {\n\t\tId  int64\n\t\tLid int64\n\t}\n\n\ttype CheckList struct {\n\t\tId  int64\n\t\tEid int64\n\t}\n\n\ttype Empsetting struct {\n\t\tId   int64\n\t\tName string\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(Salary), new(CheckList), new(Empsetting)))\n\n\tvar emp Empsetting\n\tcnt, err := testEngine.Insert(&emp)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar checklist = CheckList{\n\t\tEid: emp.Id,\n\t}\n\tcnt, err = testEngine.Insert(&checklist)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar salary = Salary{\n\t\tLid: checklist.Id,\n\t}\n\tcnt, err = testEngine.Insert(&salary)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar salaries []Salary\n\terr = testEngine.Table(\"salary\").\n\t\tJoin(\"INNER\", \"check_list\", \"check_list.id = salary.lid\").\n\t\tJoin(\"LEFT\", \"empsetting\", \"empsetting.id = check_list.eid\").\n\t\tLimit(10, 0).\n\t\tFind(&salaries)\n\tassert.NoError(t, err)\n}\n\nfunc assertSync(t *testing.T, beans ...interface{}) {\n\tfor _, bean := range beans {\n\t\tassert.NoError(t, testEngine.DropTables(bean))\n\t\tassert.NoError(t, testEngine.Sync2(bean))\n\t}\n}\n\nfunc TestWhere(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tassertSync(t, new(Userinfo))\n\n\tusers := make([]Userinfo, 0)\n\terr := testEngine.Where(\"(id) > ?\", 2).Find(&users)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tfmt.Println(users)\n\n\terr = testEngine.Where(\"(id) > ?\", 2).And(\"(id) < ?\", 10).Find(&users)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tfmt.Println(users)\n}\n\nfunc TestFind(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\tusers := make([]Userinfo, 0)\n\n\terr := testEngine.Find(&users)\n\tassert.NoError(t, err)\n\tfor _, user := range users {\n\t\tfmt.Println(user)\n\t}\n\n\tusers2 := make([]Userinfo, 0)\n\tvar tbName = testEngine.Quote(testEngine.TableName(new(Userinfo), true))\n\terr = testEngine.SQL(\"select * from \" + tbName).Find(&users2)\n\tassert.NoError(t, err)\n}\n\nfunc TestFind2(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tusers := make([]*Userinfo, 0)\n\n\tassertSync(t, new(Userinfo))\n\n\terr := testEngine.Find(&users)\n\tassert.NoError(t, err)\n\n\tfor _, user := range users {\n\t\tfmt.Println(user)\n\t}\n}\n\ntype Team struct {\n\tId int64\n}\n\ntype TeamUser struct {\n\tOrgId  int64\n\tUid    int64\n\tTeamId int64\n}\n\nfunc (TeamUser) TableName() string {\n\treturn \"team_user\"\n}\n\nfunc TestFind3(t *testing.T) {\n\tvar teamUser = new(TeamUser)\n\tassert.NoError(t, prepareEngine())\n\terr := testEngine.Sync2(new(Team), teamUser)\n\tassert.NoError(t, err)\n\n\tvar teams []Team\n\terr = testEngine.Cols(\"`team`.id\").\n\t\tWhere(\"`team_user`.org_id=?\", 1).\n\t\tAnd(\"`team_user`.uid=?\", 2).\n\t\tJoin(\"INNER\", \"`team_user`\", \"`team_user`.team_id=`team`.id\").\n\t\tFind(&teams)\n\tassert.NoError(t, err)\n\n\tteams = make([]Team, 0)\n\terr = testEngine.Cols(\"`team`.id\").\n\t\tWhere(\"`team_user`.org_id=?\", 1).\n\t\tAnd(\"`team_user`.uid=?\", 2).\n\t\tJoin(\"INNER\", teamUser, \"`team_user`.team_id=`team`.id\").\n\t\tFind(&teams)\n\tassert.NoError(t, err)\n\n\tteams = make([]Team, 0)\n\terr = testEngine.Cols(\"`team`.id\").\n\t\tWhere(\"`team_user`.org_id=?\", 1).\n\t\tAnd(\"`team_user`.uid=?\", 2).\n\t\tJoin(\"INNER\", []interface{}{teamUser}, \"`team_user`.team_id=`team`.id\").\n\t\tFind(&teams)\n\tassert.NoError(t, err)\n\n\tteams = make([]Team, 0)\n\terr = testEngine.Cols(\"`team`.id\").\n\t\tWhere(\"`tu`.org_id=?\", 1).\n\t\tAnd(\"`tu`.uid=?\", 2).\n\t\tJoin(\"INNER\", []string{\"team_user\", \"tu\"}, \"`tu`.team_id=`team`.id\").\n\t\tFind(&teams)\n\tassert.NoError(t, err)\n\n\tteams = make([]Team, 0)\n\terr = testEngine.Cols(\"`team`.id\").\n\t\tWhere(\"`tu`.org_id=?\", 1).\n\t\tAnd(\"`tu`.uid=?\", 2).\n\t\tJoin(\"INNER\", []interface{}{\"team_user\", \"tu\"}, \"`tu`.team_id=`team`.id\").\n\t\tFind(&teams)\n\tassert.NoError(t, err)\n\n\tteams = make([]Team, 0)\n\terr = testEngine.Cols(\"`team`.id\").\n\t\tWhere(\"`tu`.org_id=?\", 1).\n\t\tAnd(\"`tu`.uid=?\", 2).\n\t\tJoin(\"INNER\", []interface{}{teamUser, \"tu\"}, \"`tu`.team_id=`team`.id\").\n\t\tFind(&teams)\n\tassert.NoError(t, err)\n}\n\nfunc TestFindMap(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\tusers := make(map[int64]Userinfo)\n\terr := testEngine.Find(&users)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tfor _, user := range users {\n\t\tfmt.Println(user)\n\t}\n}\n\nfunc TestFindMap2(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\tusers := make(map[int64]*Userinfo)\n\terr := testEngine.Find(&users)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tfor id, user := range users {\n\t\tfmt.Println(id, user)\n\t}\n}\n\nfunc TestDistinct(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\t_, err := testEngine.Insert(&Userinfo{\n\t\tUsername: \"lunny\",\n\t})\n\tassert.NoError(t, err)\n\n\tusers := make([]Userinfo, 0)\n\tdepartname := testEngine.GetTableMapper().Obj2Table(\"Departname\")\n\terr = testEngine.Distinct(departname).Find(&users)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(users))\n\n\tfmt.Println(users)\n\n\ttype Depart struct {\n\t\tDepartname string\n\t}\n\n\tusers2 := make([]Depart, 0)\n\terr = testEngine.Distinct(departname).Table(new(Userinfo)).Find(&users2)\n\tassert.NoError(t, err)\n\tif len(users2) != 1 {\n\t\tfmt.Println(len(users2))\n\t\tt.Error(err)\n\t\tpanic(errors.New(\"should be one record\"))\n\t}\n\tfmt.Println(users2)\n}\n\nfunc TestOrder(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\tusers := make([]Userinfo, 0)\n\terr := testEngine.OrderBy(\"id desc\").Find(&users)\n\tassert.NoError(t, err)\n\tfmt.Println(users)\n\n\tusers2 := make([]Userinfo, 0)\n\terr = testEngine.Asc(\"id\", \"username\").Desc(\"height\").Find(&users2)\n\tassert.NoError(t, err)\n\tfmt.Println(users2)\n}\n\nfunc TestGroupBy(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\tusers := make([]Userinfo, 0)\n\terr := testEngine.GroupBy(\"id, username\").Find(&users)\n\tassert.NoError(t, err)\n}\n\nfunc TestHaving(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\tusers := make([]Userinfo, 0)\n\terr := testEngine.GroupBy(\"username\").Having(\"username='xlw'\").Find(&users)\n\tassert.NoError(t, err)\n\tfmt.Println(users)\n\n\t/*users = make([]Userinfo, 0)\n\terr = testEngine.Cols(\"id, username\").GroupBy(\"username\").Having(\"username='xlw'\").Find(&users)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tfmt.Println(users)*/\n}\n\nfunc TestOrderSameMapper(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\ttestEngine.UnMapType(rValue(new(Userinfo)).Type())\n\n\tmapper := testEngine.GetTableMapper()\n\ttestEngine.SetMapper(core.SameMapper{})\n\n\tdefer func() {\n\t\ttestEngine.UnMapType(rValue(new(Userinfo)).Type())\n\t\ttestEngine.SetMapper(mapper)\n\t}()\n\n\tassertSync(t, new(Userinfo))\n\n\tusers := make([]Userinfo, 0)\n\terr := testEngine.OrderBy(\"(id) desc\").Find(&users)\n\tassert.NoError(t, err)\n\tfmt.Println(users)\n\n\tusers2 := make([]Userinfo, 0)\n\terr = testEngine.Asc(\"(id)\", \"Username\").Desc(\"Height\").Find(&users2)\n\tassert.NoError(t, err)\n\tfmt.Println(users2)\n}\n\nfunc TestHavingSameMapper(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\ttestEngine.UnMapType(rValue(new(Userinfo)).Type())\n\n\tmapper := testEngine.GetTableMapper()\n\ttestEngine.SetMapper(core.SameMapper{})\n\tdefer func() {\n\t\ttestEngine.UnMapType(rValue(new(Userinfo)).Type())\n\t\ttestEngine.SetMapper(mapper)\n\t}()\n\tassertSync(t, new(Userinfo))\n\n\tusers := make([]Userinfo, 0)\n\terr := testEngine.GroupBy(\"`Username`\").Having(\"`Username`='xlw'\").Find(&users)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfmt.Println(users)\n}\n\nfunc TestFindInts(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\tuserinfo := testEngine.GetTableMapper().Obj2Table(\"Userinfo\")\n\tvar idsInt64 []int64\n\terr := testEngine.Table(userinfo).Cols(\"id\").Desc(\"id\").Find(&idsInt64)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfmt.Println(idsInt64)\n\n\tvar idsInt32 []int32\n\terr = testEngine.Table(userinfo).Cols(\"id\").Desc(\"id\").Find(&idsInt32)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfmt.Println(idsInt32)\n\n\tvar idsInt []int\n\terr = testEngine.Table(userinfo).Cols(\"id\").Desc(\"id\").Find(&idsInt)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfmt.Println(idsInt)\n\n\tvar idsUint []uint\n\terr = testEngine.Table(userinfo).Cols(\"id\").Desc(\"id\").Find(&idsUint)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfmt.Println(idsUint)\n\n\ttype MyInt int\n\tvar idsMyInt []MyInt\n\terr = testEngine.Table(userinfo).Cols(\"id\").Desc(\"id\").Find(&idsMyInt)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfmt.Println(idsMyInt)\n}\n\nfunc TestFindStrings(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\tuserinfo := testEngine.GetTableMapper().Obj2Table(\"Userinfo\")\n\tusername := testEngine.GetColumnMapper().Obj2Table(\"Username\")\n\tvar idsString []string\n\terr := testEngine.Table(userinfo).Cols(username).Desc(\"id\").Find(&idsString)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfmt.Println(idsString)\n}\n\nfunc TestFindMyString(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\tuserinfo := testEngine.GetTableMapper().Obj2Table(\"Userinfo\")\n\tusername := testEngine.GetColumnMapper().Obj2Table(\"Username\")\n\n\tvar idsMyString []MyString\n\terr := testEngine.Table(userinfo).Cols(username).Desc(\"id\").Find(&idsMyString)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfmt.Println(idsMyString)\n}\n\nfunc TestFindInterface(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\tuserinfo := testEngine.GetTableMapper().Obj2Table(\"Userinfo\")\n\tusername := testEngine.GetColumnMapper().Obj2Table(\"Username\")\n\tvar idsInterface []interface{}\n\terr := testEngine.Table(userinfo).Cols(username).Desc(\"id\").Find(&idsInterface)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfmt.Println(idsInterface)\n}\n\nfunc TestFindSliceBytes(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\tuserinfo := testEngine.GetTableMapper().Obj2Table(\"Userinfo\")\n\tvar ids [][][]byte\n\terr := testEngine.Table(userinfo).Desc(\"id\").Find(&ids)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor _, record := range ids {\n\t\tfmt.Println(record)\n\t}\n}\n\nfunc TestFindSlicePtrString(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\tuserinfo := testEngine.GetTableMapper().Obj2Table(\"Userinfo\")\n\tvar ids [][]*string\n\terr := testEngine.Table(userinfo).Desc(\"id\").Find(&ids)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor _, record := range ids {\n\t\tfmt.Println(record)\n\t}\n}\n\nfunc TestFindMapBytes(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\tuserinfo := testEngine.GetTableMapper().Obj2Table(\"Userinfo\")\n\tvar ids []map[string][]byte\n\terr := testEngine.Table(userinfo).Desc(\"id\").Find(&ids)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor _, record := range ids {\n\t\tfmt.Println(record)\n\t}\n}\n\nfunc TestFindMapPtrString(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\tuserinfo := testEngine.GetTableMapper().Obj2Table(\"Userinfo\")\n\tvar ids []map[string]*string\n\terr := testEngine.Table(userinfo).Desc(\"id\").Find(&ids)\n\tassert.NoError(t, err)\n\tfor _, record := range ids {\n\t\tfmt.Println(record)\n\t}\n}\n\nfunc TestFindBit(t *testing.T) {\n\ttype FindBitStruct struct {\n\t\tId  int64\n\t\tMsg bool `xorm:\"bit\"`\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(FindBitStruct))\n\n\tcnt, err := testEngine.Insert([]FindBitStruct{\n\t\t{\n\t\t\tMsg: false,\n\t\t},\n\t\t{\n\t\t\tMsg: true,\n\t\t},\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, cnt)\n\n\tvar results = make([]FindBitStruct, 0, 2)\n\terr = testEngine.Find(&results)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, len(results))\n}\n\nfunc TestFindMark(t *testing.T) {\n\n\ttype Mark struct {\n\t\tMark1 string `xorm:\"VARCHAR(1)\"`\n\t\tMark2 string `xorm:\"VARCHAR(1)\"`\n\t\tMarkA string `xorm:\"VARCHAR(1)\"`\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Mark))\n\n\tcnt, err := testEngine.Insert([]Mark{\n\t\t{\n\t\t\tMark1: \"1\",\n\t\t\tMark2: \"2\",\n\t\t\tMarkA: \"A\",\n\t\t},\n\t\t{\n\t\t\tMark1: \"1\",\n\t\t\tMark2: \"2\",\n\t\t\tMarkA: \"A\",\n\t\t},\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, cnt)\n\n\tvar results = make([]Mark, 0, 2)\n\terr = testEngine.Find(&results)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, len(results))\n}\n\nfunc TestFindAndCountOneFunc(t *testing.T) {\n\ttype FindAndCountStruct struct {\n\t\tId      int64\n\t\tContent string\n\t\tMsg     bool `xorm:\"bit\"`\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(FindAndCountStruct))\n\n\tcnt, err := testEngine.Insert([]FindAndCountStruct{\n\t\t{\n\t\t\tContent: \"111\",\n\t\t\tMsg:     false,\n\t\t},\n\t\t{\n\t\t\tContent: \"222\",\n\t\t\tMsg:     true,\n\t\t},\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, cnt)\n\n\tvar results = make([]FindAndCountStruct, 0, 2)\n\tcnt, err = testEngine.FindAndCount(&results)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, len(results))\n\tassert.EqualValues(t, 2, cnt)\n\n\tresults = make([]FindAndCountStruct, 0, 1)\n\tcnt, err = testEngine.Where(\"msg = ?\", true).FindAndCount(&results)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(results))\n\tassert.EqualValues(t, 1, cnt)\n\n\tresults = make([]FindAndCountStruct, 0, 1)\n\tcnt, err = testEngine.Where(\"msg = ?\", true).Limit(1).FindAndCount(&results)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(results))\n\tassert.EqualValues(t, 1, cnt)\n\n\tresults = make([]FindAndCountStruct, 0, 1)\n\tcnt, err = testEngine.Where(\"msg = ?\", true).Select(\"id, content, msg\").\n\t\tLimit(1).FindAndCount(&results)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(results))\n\tassert.EqualValues(t, 1, cnt)\n\n\tresults = make([]FindAndCountStruct, 0, 1)\n\tcnt, err = testEngine.Where(\"msg = ?\", true).Desc(\"id\").\n\t\tLimit(1).FindAndCount(&results)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(results))\n\tassert.EqualValues(t, 1, cnt)\n}\n\ntype FindMapDevice struct {\n\tDeviceid string `xorm:\"pk\"`\n\tStatus   int\n}\n\nfunc (device *FindMapDevice) TableName() string {\n\treturn \"devices\"\n}\n\nfunc TestFindMapStringId(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(FindMapDevice))\n\n\tcnt, err := testEngine.Insert(&FindMapDevice{\n\t\tDeviceid: \"1\",\n\t\tStatus:   1,\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tdeviceIDs := []string{\"1\"}\n\n\tdeviceMaps := make(map[string]*FindMapDevice, len(deviceIDs))\n\terr = testEngine.\n\t\tWhere(\"status = ?\", 1).\n\t\tIn(\"deviceid\", deviceIDs).\n\t\tFind(&deviceMaps)\n\tassert.NoError(t, err)\n\n\tdeviceMaps2 := make(map[string]FindMapDevice, len(deviceIDs))\n\terr = testEngine.\n\t\tWhere(\"status = ?\", 1).\n\t\tIn(\"deviceid\", deviceIDs).\n\t\tFind(&deviceMaps2)\n\tassert.NoError(t, err)\n\n\tdevices := make([]*FindMapDevice, 0, len(deviceIDs))\n\terr = testEngine.Find(&devices)\n\tassert.NoError(t, err)\n\n\tdevices2 := make([]FindMapDevice, 0, len(deviceIDs))\n\terr = testEngine.Find(&devices2)\n\tassert.NoError(t, err)\n\n\tvar device FindMapDevice\n\thas, err := testEngine.Get(&device)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\thas, err = testEngine.Exist(&FindMapDevice{})\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\tcnt, err = testEngine.Count(new(FindMapDevice))\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tcnt, err = testEngine.ID(\"1\").Update(&FindMapDevice{\n\t\tStatus: 2,\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tsum, err := testEngine.SumInt(new(FindMapDevice), \"status\")\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, sum)\n\n\tcnt, err = testEngine.ID(\"1\").Delete(new(FindMapDevice))\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n}\n\nfunc TestFindExtends(t *testing.T) {\n\ttype FindExtendsB struct {\n\t\tID int64\n\t}\n\n\ttype FindExtendsA struct {\n\t\tFindExtendsB `xorm:\"extends\"`\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(FindExtendsA))\n\n\tcnt, err := testEngine.Insert(&FindExtendsA{\n\t\tFindExtendsB: FindExtendsB{},\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tcnt, err = testEngine.Insert(&FindExtendsA{\n\t\tFindExtendsB: FindExtendsB{},\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar results []FindExtendsA\n\terr = testEngine.Find(&results)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, len(results))\n}\n\nfunc TestFindExtends3(t *testing.T) {\n\ttype FindExtendsCC struct {\n\t\tID   int64\n\t\tName string\n\t}\n\n\ttype FindExtendsBB struct {\n\t\tFindExtendsCC `xorm:\"extends\"`\n\t}\n\n\ttype FindExtendsAA struct {\n\t\tFindExtendsBB `xorm:\"extends\"`\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(FindExtendsAA))\n\n\tcnt, err := testEngine.Insert(&FindExtendsAA{\n\t\tFindExtendsBB: FindExtendsBB{\n\t\t\tFindExtendsCC: FindExtendsCC{\n\t\t\t\tName: \"cc1\",\n\t\t\t},\n\t\t},\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tcnt, err = testEngine.Insert(&FindExtendsAA{\n\t\tFindExtendsBB: FindExtendsBB{\n\t\t\tFindExtendsCC: FindExtendsCC{\n\t\t\t\tName: \"cc2\",\n\t\t\t},\n\t\t},\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar results []FindExtendsAA\n\terr = testEngine.Find(&results)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, len(results))\n}\n\nfunc TestFindCacheLimit(t *testing.T) {\n\ttype InviteCode struct {\n\t\tID      int64     `xorm:\"pk autoincr 'id'\"`\n\t\tCode    string    `xorm:\"unique\"`\n\t\tCreated time.Time `xorm:\"created\"`\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(InviteCode))\n\n\tcnt, err := testEngine.Insert(&InviteCode{\n\t\tCode: \"123456\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tcnt, err = testEngine.Insert(&InviteCode{\n\t\tCode: \"234567\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tfor i := 0; i < 8; i++ {\n\t\tvar beans []InviteCode\n\t\terr = testEngine.Limit(1, 0).Find(&beans)\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, 1, len(beans))\n\t}\n\n\tfor i := 0; i < 8; i++ {\n\t\tvar beans2 []*InviteCode\n\t\terr = testEngine.Limit(1, 0).Find(&beans2)\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, 1, len(beans2))\n\t}\n}\n\nfunc TestFindJoin(t *testing.T) {\n\ttype SceneItem struct {\n\t\tType     int\n\t\tDeviceId int64\n\t}\n\n\ttype DeviceUserPrivrels struct {\n\t\tUserId   int64\n\t\tDeviceId int64\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(SceneItem), new(DeviceUserPrivrels))\n\n\tvar scenes []SceneItem\n\terr := testEngine.Join(\"LEFT OUTER\", \"device_user_privrels\", \"device_user_privrels.device_id=scene_item.device_id\").\n\t\tWhere(\"scene_item.type=?\", 3).Or(\"device_user_privrels.user_id=?\", 339).Find(&scenes)\n\tassert.NoError(t, err)\n\n\tscenes = make([]SceneItem, 0)\n\terr = testEngine.Join(\"LEFT OUTER\", new(DeviceUserPrivrels), \"device_user_privrels.device_id=scene_item.device_id\").\n\t\tWhere(\"scene_item.type=?\", 3).Or(\"device_user_privrels.user_id=?\", 339).Find(&scenes)\n\tassert.NoError(t, err)\n}\n"
        },
        {
          "name": "session_get.go",
          "type": "blob",
          "size": 8.408203125,
          "content": "// Copyright 2016 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\n\t\"xorm.io/core\"\n)\n\n// Get retrieve one record from database, bean's non-empty fields\n// will be as conditions\nfunc (session *Session) Get(bean interface{}) (bool, error) {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\treturn session.get(bean)\n}\n\nfunc (session *Session) get(bean interface{}) (bool, error) {\n\tdefer session.resetStatement()\n\n\tif session.statement.lastError != nil {\n\t\treturn false, session.statement.lastError\n\t}\n\n\tbeanValue := reflect.ValueOf(bean)\n\tif beanValue.Kind() != reflect.Ptr {\n\t\treturn false, errors.New(\"needs a pointer to a value\")\n\t} else if beanValue.Elem().Kind() == reflect.Ptr {\n\t\treturn false, errors.New(\"a pointer to a pointer is not allowed\")\n\t}\n\n\tif beanValue.Elem().Kind() == reflect.Struct {\n\t\tif err := session.statement.setRefBean(bean); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\tvar sqlStr string\n\tvar args []interface{}\n\tvar err error\n\n\tif session.statement.RawSQL == \"\" {\n\t\tif len(session.statement.TableName()) <= 0 {\n\t\t\treturn false, ErrTableNotFound\n\t\t}\n\t\tsession.statement.Limit(1)\n\t\tsqlStr, args, err = session.statement.genGetSQL(bean)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t} else {\n\t\tsqlStr = session.statement.RawSQL\n\t\targs = session.statement.RawParams\n\t}\n\n\ttable := session.statement.RefTable\n\n\tif session.canCache() && beanValue.Elem().Kind() == reflect.Struct {\n\t\tif cacher := session.engine.getCacher(session.statement.TableName()); cacher != nil &&\n\t\t\t!session.statement.unscoped {\n\t\t\thas, err := session.cacheGet(bean, sqlStr, args...)\n\t\t\tif err != ErrCacheFailed {\n\t\t\t\treturn has, err\n\t\t\t}\n\t\t}\n\t}\n\n\tcontext := session.statement.context\n\tif context != nil {\n\t\tres := context.Get(fmt.Sprintf(\"%v-%v\", sqlStr, args))\n\t\tif res != nil {\n\t\t\tsession.engine.logger.Debug(\"hit context cache\", sqlStr)\n\n\t\t\tstructValue := reflect.Indirect(reflect.ValueOf(bean))\n\t\t\tstructValue.Set(reflect.Indirect(reflect.ValueOf(res)))\n\t\t\tsession.lastSQL = \"\"\n\t\t\tsession.lastSQLArgs = nil\n\t\t\treturn true, nil\n\t\t}\n\t}\n\n\thas, err := session.nocacheGet(beanValue.Elem().Kind(), table, bean, sqlStr, args...)\n\tif err != nil || !has {\n\t\treturn has, err\n\t}\n\n\tif context != nil {\n\t\tcontext.Put(fmt.Sprintf(\"%v-%v\", sqlStr, args), bean)\n\t}\n\n\treturn true, nil\n}\n\nfunc (session *Session) nocacheGet(beanKind reflect.Kind, table *core.Table, bean interface{}, sqlStr string, args ...interface{}) (bool, error) {\n\trows, err := session.queryRows(sqlStr, args...)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer rows.Close()\n\n\tif !rows.Next() {\n\t\tif rows.Err() != nil {\n\t\t\treturn false, rows.Err()\n\t\t}\n\t\treturn false, nil\n\t}\n\n\tswitch bean.(type) {\n\tcase sql.NullInt64, sql.NullBool, sql.NullFloat64, sql.NullString:\n\t\treturn true, rows.Scan(&bean)\n\tcase *sql.NullInt64, *sql.NullBool, *sql.NullFloat64, *sql.NullString:\n\t\treturn true, rows.Scan(bean)\n\tcase *string:\n\t\tvar res sql.NullString\n\t\tif err := rows.Scan(&res); err != nil {\n\t\t\treturn true, err\n\t\t}\n\t\tif res.Valid {\n\t\t\t*(bean.(*string)) = res.String\n\t\t}\n\t\treturn true, nil\n\tcase *int:\n\t\tvar res sql.NullInt64\n\t\tif err := rows.Scan(&res); err != nil {\n\t\t\treturn true, err\n\t\t}\n\t\tif res.Valid {\n\t\t\t*(bean.(*int)) = int(res.Int64)\n\t\t}\n\t\treturn true, nil\n\tcase *int8:\n\t\tvar res sql.NullInt64\n\t\tif err := rows.Scan(&res); err != nil {\n\t\t\treturn true, err\n\t\t}\n\t\tif res.Valid {\n\t\t\t*(bean.(*int8)) = int8(res.Int64)\n\t\t}\n\t\treturn true, nil\n\tcase *int16:\n\t\tvar res sql.NullInt64\n\t\tif err := rows.Scan(&res); err != nil {\n\t\t\treturn true, err\n\t\t}\n\t\tif res.Valid {\n\t\t\t*(bean.(*int16)) = int16(res.Int64)\n\t\t}\n\t\treturn true, nil\n\tcase *int32:\n\t\tvar res sql.NullInt64\n\t\tif err := rows.Scan(&res); err != nil {\n\t\t\treturn true, err\n\t\t}\n\t\tif res.Valid {\n\t\t\t*(bean.(*int32)) = int32(res.Int64)\n\t\t}\n\t\treturn true, nil\n\tcase *int64:\n\t\tvar res sql.NullInt64\n\t\tif err := rows.Scan(&res); err != nil {\n\t\t\treturn true, err\n\t\t}\n\t\tif res.Valid {\n\t\t\t*(bean.(*int64)) = int64(res.Int64)\n\t\t}\n\t\treturn true, nil\n\tcase *uint:\n\t\tvar res sql.NullInt64\n\t\tif err := rows.Scan(&res); err != nil {\n\t\t\treturn true, err\n\t\t}\n\t\tif res.Valid {\n\t\t\t*(bean.(*uint)) = uint(res.Int64)\n\t\t}\n\t\treturn true, nil\n\tcase *uint8:\n\t\tvar res sql.NullInt64\n\t\tif err := rows.Scan(&res); err != nil {\n\t\t\treturn true, err\n\t\t}\n\t\tif res.Valid {\n\t\t\t*(bean.(*uint8)) = uint8(res.Int64)\n\t\t}\n\t\treturn true, nil\n\tcase *uint16:\n\t\tvar res sql.NullInt64\n\t\tif err := rows.Scan(&res); err != nil {\n\t\t\treturn true, err\n\t\t}\n\t\tif res.Valid {\n\t\t\t*(bean.(*uint16)) = uint16(res.Int64)\n\t\t}\n\t\treturn true, nil\n\tcase *uint32:\n\t\tvar res sql.NullInt64\n\t\tif err := rows.Scan(&res); err != nil {\n\t\t\treturn true, err\n\t\t}\n\t\tif res.Valid {\n\t\t\t*(bean.(*uint32)) = uint32(res.Int64)\n\t\t}\n\t\treturn true, nil\n\tcase *uint64:\n\t\tvar res sql.NullInt64\n\t\tif err := rows.Scan(&res); err != nil {\n\t\t\treturn true, err\n\t\t}\n\t\tif res.Valid {\n\t\t\t*(bean.(*uint64)) = uint64(res.Int64)\n\t\t}\n\t\treturn true, nil\n\tcase *bool:\n\t\tvar res sql.NullBool\n\t\tif err := rows.Scan(&res); err != nil {\n\t\t\treturn true, err\n\t\t}\n\t\tif res.Valid {\n\t\t\t*(bean.(*bool)) = res.Bool\n\t\t}\n\t\treturn true, nil\n\t}\n\n\tswitch beanKind {\n\tcase reflect.Struct:\n\t\tfields, err := rows.Columns()\n\t\tif err != nil {\n\t\t\t// WARN: Alougth rows return true, but get fields failed\n\t\t\treturn true, err\n\t\t}\n\n\t\tscanResults, err := session.row2Slice(rows, fields, bean)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\t// close it before covert data\n\t\trows.Close()\n\n\t\tdataStruct := rValue(bean)\n\t\t_, err = session.slice2Bean(scanResults, fields, bean, &dataStruct, table)\n\t\tif err != nil {\n\t\t\treturn true, err\n\t\t}\n\n\t\treturn true, session.executeProcessors()\n\tcase reflect.Slice:\n\t\terr = rows.ScanSlice(bean)\n\tcase reflect.Map:\n\t\terr = rows.ScanMap(bean)\n\tcase reflect.String, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\terr = rows.Scan(bean)\n\tdefault:\n\t\terr = rows.Scan(bean)\n\t}\n\n\treturn true, err\n}\n\nfunc (session *Session) cacheGet(bean interface{}, sqlStr string, args ...interface{}) (has bool, err error) {\n\t// if has no reftable, then don't use cache currently\n\tif !session.canCache() {\n\t\treturn false, ErrCacheFailed\n\t}\n\n\tfor _, filter := range session.engine.dialect.Filters() {\n\t\tsqlStr = filter.Do(sqlStr, session.engine.dialect, session.statement.RefTable)\n\t}\n\tnewsql := session.statement.convertIDSQL(sqlStr)\n\tif newsql == \"\" {\n\t\treturn false, ErrCacheFailed\n\t}\n\n\ttableName := session.statement.TableName()\n\tcacher := session.engine.getCacher(tableName)\n\n\tsession.engine.logger.Debug(\"[cacheGet] find sql:\", newsql, args)\n\ttable := session.statement.RefTable\n\tids, err := core.GetCacheSql(cacher, tableName, newsql, args)\n\tif err != nil {\n\t\tvar res = make([]string, len(table.PrimaryKeys))\n\t\trows, err := session.NoCache().queryRows(newsql, args...)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tdefer rows.Close()\n\n\t\tif rows.Next() {\n\t\t\terr = rows.ScanSlice(&res)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t} else {\n\t\t\treturn false, ErrCacheFailed\n\t\t}\n\n\t\tvar pk core.PK = make([]interface{}, len(table.PrimaryKeys))\n\t\tfor i, col := range table.PKColumns() {\n\t\t\tif col.SQLType.IsText() {\n\t\t\t\tpk[i] = res[i]\n\t\t\t} else if col.SQLType.IsNumeric() {\n\t\t\t\tn, err := strconv.ParseInt(res[i], 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn false, err\n\t\t\t\t}\n\t\t\t\tpk[i] = n\n\t\t\t} else {\n\t\t\t\treturn false, errors.New(\"unsupported\")\n\t\t\t}\n\t\t}\n\n\t\tids = []core.PK{pk}\n\t\tsession.engine.logger.Debug(\"[cacheGet] cache ids:\", newsql, ids)\n\t\terr = core.PutCacheSql(cacher, ids, tableName, newsql, args)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t} else {\n\t\tsession.engine.logger.Debug(\"[cacheGet] cache hit sql:\", newsql, ids)\n\t}\n\n\tif len(ids) > 0 {\n\t\tstructValue := reflect.Indirect(reflect.ValueOf(bean))\n\t\tid := ids[0]\n\t\tsession.engine.logger.Debug(\"[cacheGet] get bean:\", tableName, id)\n\t\tsid, err := id.ToString()\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tcacheBean := cacher.GetBean(tableName, sid)\n\t\tif cacheBean == nil {\n\t\t\tcacheBean = bean\n\t\t\thas, err = session.nocacheGet(reflect.Struct, table, cacheBean, sqlStr, args...)\n\t\t\tif err != nil || !has {\n\t\t\t\treturn has, err\n\t\t\t}\n\n\t\t\tsession.engine.logger.Debug(\"[cacheGet] cache bean:\", tableName, id, cacheBean)\n\t\t\tcacher.PutBean(tableName, sid, cacheBean)\n\t\t} else {\n\t\t\tsession.engine.logger.Debug(\"[cacheGet] cache hit bean:\", tableName, id, cacheBean)\n\t\t\thas = true\n\t\t}\n\t\tstructValue.Set(reflect.Indirect(reflect.ValueOf(cacheBean)))\n\n\t\treturn has, nil\n\t}\n\treturn false, nil\n}\n"
        },
        {
          "name": "session_get_test.go",
          "type": "blob",
          "size": 16.43359375,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"xorm.io/core\"\n)\n\nfunc TestGetVar(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype GetVar struct {\n\t\tId      int64  `xorm:\"autoincr pk\"`\n\t\tMsg     string `xorm:\"varchar(255)\"`\n\t\tAge     int\n\t\tMoney   float32\n\t\tCreated time.Time `xorm:\"created\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(GetVar)))\n\n\tvar data = GetVar{\n\t\tMsg:   \"hi\",\n\t\tAge:   28,\n\t\tMoney: 1.5,\n\t}\n\t_, err := testEngine.InsertOne(&data)\n\tassert.NoError(t, err)\n\n\tvar msg string\n\thas, err := testEngine.Table(\"get_var\").Cols(\"msg\").Get(&msg)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.Equal(t, \"hi\", msg)\n\n\tvar age int\n\thas, err = testEngine.Table(\"get_var\").Cols(\"age\").Get(&age)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.Equal(t, 28, age)\n\n\tvar ageMax int\n\thas, err = testEngine.SQL(\"SELECT max(age) FROM \"+testEngine.TableName(\"get_var\", true)+\" WHERE `id` = ?\", data.Id).Get(&ageMax)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.Equal(t, 28, ageMax)\n\n\tvar age2 int64\n\thas, err = testEngine.Table(\"get_var\").Cols(\"age\").\n\t\tWhere(\"age > ?\", 20).\n\t\tAnd(\"age < ?\", 30).\n\t\tGet(&age2)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.EqualValues(t, 28, age2)\n\n\tvar age3 int8\n\thas, err = testEngine.Table(\"get_var\").Cols(\"age\").Get(&age3)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.EqualValues(t, 28, age3)\n\n\tvar age4 int16\n\thas, err = testEngine.Table(\"get_var\").Cols(\"age\").\n\t\tWhere(\"age > ?\", 20).\n\t\tAnd(\"age < ?\", 30).\n\t\tGet(&age4)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.EqualValues(t, 28, age4)\n\n\tvar age5 int32\n\thas, err = testEngine.Table(\"get_var\").Cols(\"age\").\n\t\tWhere(\"age > ?\", 20).\n\t\tAnd(\"age < ?\", 30).\n\t\tGet(&age5)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.EqualValues(t, 28, age5)\n\n\tvar age6 int\n\thas, err = testEngine.Table(\"get_var\").Cols(\"age\").Get(&age6)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.EqualValues(t, 28, age6)\n\n\tvar age7 int64\n\thas, err = testEngine.Table(\"get_var\").Cols(\"age\").\n\t\tWhere(\"age > ?\", 20).\n\t\tAnd(\"age < ?\", 30).\n\t\tGet(&age7)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.EqualValues(t, 28, age7)\n\n\tvar age8 int8\n\thas, err = testEngine.Table(\"get_var\").Cols(\"age\").Get(&age8)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.EqualValues(t, 28, age8)\n\n\tvar age9 int16\n\thas, err = testEngine.Table(\"get_var\").Cols(\"age\").\n\t\tWhere(\"age > ?\", 20).\n\t\tAnd(\"age < ?\", 30).\n\t\tGet(&age9)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.EqualValues(t, 28, age9)\n\n\tvar age10 int32\n\thas, err = testEngine.Table(\"get_var\").Cols(\"age\").\n\t\tWhere(\"age > ?\", 20).\n\t\tAnd(\"age < ?\", 30).\n\t\tGet(&age10)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.EqualValues(t, 28, age10)\n\n\tvar id sql.NullInt64\n\thas, err = testEngine.Table(\"get_var\").Cols(\"id\").Get(&id)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.Equal(t, true, id.Valid)\n\tassert.EqualValues(t, data.Id, id.Int64)\n\n\tvar msgNull sql.NullString\n\thas, err = testEngine.Table(\"get_var\").Cols(\"msg\").Get(&msgNull)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.Equal(t, true, msgNull.Valid)\n\tassert.EqualValues(t, data.Msg, msgNull.String)\n\n\tvar nullMoney sql.NullFloat64\n\thas, err = testEngine.Table(\"get_var\").Cols(\"money\").Get(&nullMoney)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.Equal(t, true, nullMoney.Valid)\n\tassert.EqualValues(t, data.Money, nullMoney.Float64)\n\n\tvar money float64\n\thas, err = testEngine.Table(\"get_var\").Cols(\"money\").Get(&money)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.Equal(t, \"1.5\", fmt.Sprintf(\"%.1f\", money))\n\n\tvar money2 float64\n\tif testEngine.Dialect().DBType() == core.MSSQL {\n\t\thas, err = testEngine.SQL(\"SELECT TOP 1 money FROM \" + testEngine.TableName(\"get_var\", true)).Get(&money2)\n\t} else {\n\t\thas, err = testEngine.SQL(\"SELECT money FROM \" + testEngine.TableName(\"get_var\", true) + \" LIMIT 1\").Get(&money2)\n\t}\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.Equal(t, \"1.5\", fmt.Sprintf(\"%.1f\", money2))\n\n\tvar money3 float64\n\thas, err = testEngine.SQL(\"SELECT money FROM \" + testEngine.TableName(\"get_var\", true) + \" WHERE money > 20\").Get(&money3)\n\tassert.NoError(t, err)\n\tassert.Equal(t, false, has)\n\n\tvar valuesString = make(map[string]string)\n\thas, err = testEngine.Table(\"get_var\").Get(&valuesString)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.Equal(t, 5, len(valuesString))\n\tassert.Equal(t, \"1\", valuesString[\"id\"])\n\tassert.Equal(t, \"hi\", valuesString[\"msg\"])\n\tassert.Equal(t, \"28\", valuesString[\"age\"])\n\tassert.Equal(t, \"1.5\", valuesString[\"money\"])\n\n\t// for mymysql driver, interface{} will be []byte, so ignore it currently\n\tif testEngine.Dialect().DriverName() != \"mymysql\" {\n\t\tvar valuesInter = make(map[string]interface{})\n\t\thas, err = testEngine.Table(\"get_var\").Where(\"id = ?\", 1).Select(\"*\").Get(&valuesInter)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, true, has)\n\t\tassert.Equal(t, 5, len(valuesInter))\n\t\tassert.EqualValues(t, 1, valuesInter[\"id\"])\n\t\tassert.Equal(t, \"hi\", fmt.Sprintf(\"%s\", valuesInter[\"msg\"]))\n\t\tassert.EqualValues(t, 28, valuesInter[\"age\"])\n\t\tassert.Equal(t, \"1.5\", fmt.Sprintf(\"%v\", valuesInter[\"money\"]))\n\t}\n\n\tvar valuesSliceString = make([]string, 5)\n\thas, err = testEngine.Table(\"get_var\").Get(&valuesSliceString)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.Equal(t, \"1\", valuesSliceString[0])\n\tassert.Equal(t, \"hi\", valuesSliceString[1])\n\tassert.Equal(t, \"28\", valuesSliceString[2])\n\tassert.Equal(t, \"1.5\", valuesSliceString[3])\n\n\tvar valuesSliceInter = make([]interface{}, 5)\n\thas, err = testEngine.Table(\"get_var\").Get(&valuesSliceInter)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\n\tv1, err := convertInt(valuesSliceInter[0])\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, v1)\n\n\tassert.Equal(t, \"hi\", fmt.Sprintf(\"%s\", valuesSliceInter[1]))\n\n\tv3, err := convertInt(valuesSliceInter[2])\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 28, v3)\n\n\tv4, err := convertFloat(valuesSliceInter[3])\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"1.5\", fmt.Sprintf(\"%v\", v4))\n}\n\nfunc TestGetStruct(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UserinfoGet struct {\n\t\tUid   int `xorm:\"pk autoincr\"`\n\t\tIsMan bool\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(UserinfoGet)))\n\n\tsession := testEngine.NewSession()\n\tdefer session.Close()\n\n\tvar err error\n\tif testEngine.Dialect().DBType() == core.MSSQL {\n\t\terr = session.Begin()\n\t\tassert.NoError(t, err)\n\t\t_, err = session.Exec(\"SET IDENTITY_INSERT userinfo_get ON\")\n\t\tassert.NoError(t, err)\n\t}\n\tcnt, err := session.Insert(&UserinfoGet{Uid: 2})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\tif testEngine.Dialect().DBType() == core.MSSQL {\n\t\terr = session.Commit()\n\t\tassert.NoError(t, err)\n\t}\n\n\tuser := UserinfoGet{Uid: 2}\n\thas, err := testEngine.Get(&user)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\ttype NoIdUser struct {\n\t\tUser   string `xorm:\"unique\"`\n\t\tRemain int64\n\t\tTotal  int64\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(&NoIdUser{}))\n\n\tuserCol := testEngine.GetColumnMapper().Obj2Table(\"User\")\n\t_, err = testEngine.Where(\"`\"+userCol+\"` = ?\", \"xlw\").Delete(&NoIdUser{})\n\tassert.NoError(t, err)\n\n\tcnt, err = testEngine.Insert(&NoIdUser{\"xlw\", 20, 100})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tnoIdUser := new(NoIdUser)\n\thas, err = testEngine.Where(\"`\"+userCol+\"` = ?\", \"xlw\").Get(noIdUser)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n}\n\nfunc TestGetSlice(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UserinfoSlice struct {\n\t\tUid   int `xorm:\"pk autoincr\"`\n\t\tIsMan bool\n\t}\n\n\tassertSync(t, new(UserinfoSlice))\n\n\tvar users []UserinfoSlice\n\thas, err := testEngine.Get(&users)\n\tassert.False(t, has)\n\tassert.Error(t, err)\n}\n\nfunc TestGetError(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype GetError struct {\n\t\tUid   int `xorm:\"pk autoincr\"`\n\t\tIsMan bool\n\t}\n\n\tassertSync(t, new(GetError))\n\n\tvar info = new(GetError)\n\thas, err := testEngine.Get(&info)\n\tassert.False(t, has)\n\tassert.Error(t, err)\n\n\thas, err = testEngine.Get(info)\n\tassert.False(t, has)\n\tassert.NoError(t, err)\n}\n\nfunc TestJSONString(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype JsonString struct {\n\t\tId      int64\n\t\tContent string `xorm:\"json\"`\n\t}\n\ttype JsonJson struct {\n\t\tId      int64\n\t\tContent []string `xorm:\"json\"`\n\t}\n\n\tassertSync(t, new(JsonJson))\n\n\t_, err := testEngine.Insert(&JsonJson{\n\t\tContent: []string{\"1\", \"2\"},\n\t})\n\tassert.NoError(t, err)\n\n\tvar js JsonString\n\thas, err := testEngine.Table(\"json_json\").Get(&js)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 1, js.Id)\n\tassert.EqualValues(t, `[\"1\",\"2\"]`, js.Content)\n\n\tvar jss []JsonString\n\terr = testEngine.Table(\"json_json\").Find(&jss)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(jss))\n\tassert.EqualValues(t, `[\"1\",\"2\"]`, jss[0].Content)\n}\n\nfunc TestGetActionMapping(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype ActionMapping struct {\n\t\tActionId    string `xorm:\"pk\"`\n\t\tActionName  string `xorm:\"index\"`\n\t\tScriptId    string `xorm:\"unique\"`\n\t\tRollbackId  string `xorm:\"unique\"`\n\t\tEnv         string\n\t\tTags        string\n\t\tDescription string\n\t\tUpdateTime  time.Time `xorm:\"updated\"`\n\t\tDeleteTime  time.Time `xorm:\"deleted\"`\n\t}\n\n\tassertSync(t, new(ActionMapping))\n\n\t_, err := testEngine.Insert(&ActionMapping{\n\t\tActionId: \"1\",\n\t\tScriptId: \"2\",\n\t})\n\tassert.NoError(t, err)\n\n\tvar valuesSlice = make([]string, 2)\n\thas, err := testEngine.Table(new(ActionMapping)).\n\t\tCols(\"script_id\", \"rollback_id\").\n\t\tID(\"1\").Get(&valuesSlice)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, \"2\", valuesSlice[0])\n\tassert.EqualValues(t, \"\", valuesSlice[1])\n}\n\nfunc TestGetStructId(t *testing.T) {\n\ttype TestGetStruct struct {\n\t\tId int64\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(TestGetStruct))\n\n\t_, err := testEngine.Insert(&TestGetStruct{})\n\tassert.NoError(t, err)\n\t_, err = testEngine.Insert(&TestGetStruct{})\n\tassert.NoError(t, err)\n\n\ttype maxidst struct {\n\t\tId int64\n\t}\n\n\t//var id int64\n\tvar maxid maxidst\n\tsql := \"select max(id) as id from \" + testEngine.TableName(&TestGetStruct{}, true)\n\thas, err := testEngine.SQL(sql).Get(&maxid)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 2, maxid.Id)\n}\n\nfunc TestContextGet(t *testing.T) {\n\ttype ContextGetStruct struct {\n\t\tId   int64\n\t\tName string\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(ContextGetStruct))\n\n\t_, err := testEngine.Insert(&ContextGetStruct{Name: \"1\"})\n\tassert.NoError(t, err)\n\n\tsess := testEngine.NewSession()\n\tdefer sess.Close()\n\n\tcontext := NewMemoryContextCache()\n\n\tvar c2 ContextGetStruct\n\thas, err := sess.ID(1).NoCache().ContextCache(context).Get(&c2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 1, c2.Id)\n\tassert.EqualValues(t, \"1\", c2.Name)\n\tsql, args := sess.LastSQL()\n\tassert.True(t, len(sql) > 0)\n\tassert.True(t, len(args) > 0)\n\n\tvar c3 ContextGetStruct\n\thas, err = sess.ID(1).NoCache().ContextCache(context).Get(&c3)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 1, c3.Id)\n\tassert.EqualValues(t, \"1\", c3.Name)\n\tsql, args = sess.LastSQL()\n\tassert.True(t, len(sql) == 0)\n\tassert.True(t, len(args) == 0)\n}\n\nfunc TestContextGet2(t *testing.T) {\n\ttype ContextGetStruct2 struct {\n\t\tId   int64\n\t\tName string\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(ContextGetStruct2))\n\n\t_, err := testEngine.Insert(&ContextGetStruct2{Name: \"1\"})\n\tassert.NoError(t, err)\n\n\tcontext := NewMemoryContextCache()\n\n\tvar c2 ContextGetStruct2\n\thas, err := testEngine.ID(1).NoCache().ContextCache(context).Get(&c2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 1, c2.Id)\n\tassert.EqualValues(t, \"1\", c2.Name)\n\n\tvar c3 ContextGetStruct2\n\thas, err = testEngine.ID(1).NoCache().ContextCache(context).Get(&c3)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 1, c3.Id)\n\tassert.EqualValues(t, \"1\", c3.Name)\n}\n\ntype GetCustomTableInterface interface {\n\tTableName() string\n}\n\ntype MyGetCustomTableImpletation struct {\n\tId   int64  `json:\"id\"`\n\tName string `json:\"name\"`\n}\n\nconst getCustomTableName = \"GetCustomTableInterface\"\n\nfunc (m *MyGetCustomTableImpletation) TableName() string {\n\treturn getCustomTableName\n}\n\nfunc TestGetCustomTableInterface(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassert.NoError(t, testEngine.Table(getCustomTableName).Sync2(new(MyGetCustomTableImpletation)))\n\n\texist, err := testEngine.IsTableExist(getCustomTableName)\n\tassert.NoError(t, err)\n\tassert.True(t, exist)\n\n\t_, err = testEngine.Insert(&MyGetCustomTableImpletation{\n\t\tName: \"xlw\",\n\t})\n\tassert.NoError(t, err)\n\n\tvar c GetCustomTableInterface = new(MyGetCustomTableImpletation)\n\thas, err := testEngine.Get(c)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n}\n\nfunc TestGetNullVar(t *testing.T) {\n\ttype TestGetNullVarStruct struct {\n\t\tId   int64\n\t\tName string\n\t\tAge  int\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(TestGetNullVarStruct))\n\n\taffected, err := testEngine.Exec(\"insert into \" + testEngine.TableName(new(TestGetNullVarStruct), true) + \" (name,age) values (null,null)\")\n\tassert.NoError(t, err)\n\ta, _ := affected.RowsAffected()\n\tassert.EqualValues(t, 1, a)\n\n\tvar name string\n\thas, err := testEngine.Table(new(TestGetNullVarStruct)).Where(\"id = ?\", 1).Cols(\"name\").Get(&name)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, \"\", name)\n\n\tvar age int\n\thas, err = testEngine.Table(new(TestGetNullVarStruct)).Where(\"id = ?\", 1).Cols(\"age\").Get(&age)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 0, age)\n\n\tvar age2 int8\n\thas, err = testEngine.Table(new(TestGetNullVarStruct)).Where(\"id = ?\", 1).Cols(\"age\").Get(&age2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 0, age2)\n\n\tvar age3 int16\n\thas, err = testEngine.Table(new(TestGetNullVarStruct)).Where(\"id = ?\", 1).Cols(\"age\").Get(&age3)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 0, age3)\n\n\tvar age4 int32\n\thas, err = testEngine.Table(new(TestGetNullVarStruct)).Where(\"id = ?\", 1).Cols(\"age\").Get(&age4)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 0, age4)\n\n\tvar age5 int64\n\thas, err = testEngine.Table(new(TestGetNullVarStruct)).Where(\"id = ?\", 1).Cols(\"age\").Get(&age5)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 0, age5)\n\n\tvar age6 uint\n\thas, err = testEngine.Table(new(TestGetNullVarStruct)).Where(\"id = ?\", 1).Cols(\"age\").Get(&age6)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 0, age6)\n\n\tvar age7 uint8\n\thas, err = testEngine.Table(new(TestGetNullVarStruct)).Where(\"id = ?\", 1).Cols(\"age\").Get(&age7)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 0, age7)\n\n\tvar age8 int16\n\thas, err = testEngine.Table(new(TestGetNullVarStruct)).Where(\"id = ?\", 1).Cols(\"age\").Get(&age8)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 0, age8)\n\n\tvar age9 int32\n\thas, err = testEngine.Table(new(TestGetNullVarStruct)).Where(\"id = ?\", 1).Cols(\"age\").Get(&age9)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 0, age9)\n\n\tvar age10 int64\n\thas, err = testEngine.Table(new(TestGetNullVarStruct)).Where(\"id = ?\", 1).Cols(\"age\").Get(&age10)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 0, age10)\n}\n\nfunc TestCustomTypes(t *testing.T) {\n\ttype MyInt int\n\ttype MyString string\n\n\ttype TestCustomizeStruct struct {\n\t\tId   int64\n\t\tName MyString\n\t\tAge  MyInt\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(TestCustomizeStruct))\n\n\tvar s = TestCustomizeStruct{\n\t\tName: \"test\",\n\t\tAge:  32,\n\t}\n\t_, err := testEngine.Insert(&s)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, s.Id)\n\n\tvar name MyString\n\thas, err := testEngine.Table(new(TestCustomizeStruct)).ID(s.Id).Cols(\"name\").Get(&name)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, \"test\", name)\n\n\tvar age MyInt\n\thas, err = testEngine.Table(new(TestCustomizeStruct)).ID(s.Id).Select(\"age\").Get(&age)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 32, age)\n}\n\nfunc TestGetViaMapCond(t *testing.T) {\n\ttype GetViaMapCond struct {\n\t\tId       int64\n\t\tPlatform int\n\t\tIndex    int\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(GetViaMapCond))\n\n\tvar (\n\t\tr           GetViaMapCond\n\t\tplatformStr = colMapper.Obj2Table(\"Platform\")\n\t\tindexStr    = colMapper.Obj2Table(\"Index\")\n\t\tquery       = map[string]interface{}{\n\t\t\tplatformStr: 1,\n\t\t\tindexStr:    1,\n\t\t}\n\t)\n\n\thas, err := testEngine.Where(query).Get(&r)\n\tassert.NoError(t, err)\n\tassert.False(t, has)\n}\n"
        },
        {
          "name": "session_insert.go",
          "type": "blob",
          "size": 22.01171875,
          "content": "// Copyright 2016 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"xorm.io/builder\"\n\t\"xorm.io/core\"\n)\n\n// Insert insert one or more beans\nfunc (session *Session) Insert(beans ...interface{}) (int64, error) {\n\tvar affected int64\n\tvar err error\n\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\tsession.autoResetStatement = false\n\tdefer func() {\n\t\tsession.autoResetStatement = true\n\t\tsession.resetStatement()\n\t}()\n\n\tfor _, bean := range beans {\n\t\tswitch bean.(type) {\n\t\tcase map[string]interface{}:\n\t\t\tcnt, err := session.insertMapInterface(bean.(map[string]interface{}))\n\t\t\tif err != nil {\n\t\t\t\treturn affected, err\n\t\t\t}\n\t\t\taffected += cnt\n\t\tcase []map[string]interface{}:\n\t\t\ts := bean.([]map[string]interface{})\n\t\t\tfor i := 0; i < len(s); i++ {\n\t\t\t\tcnt, err := session.insertMapInterface(s[i])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn affected, err\n\t\t\t\t}\n\t\t\t\taffected += cnt\n\t\t\t}\n\t\tcase map[string]string:\n\t\t\tcnt, err := session.insertMapString(bean.(map[string]string))\n\t\t\tif err != nil {\n\t\t\t\treturn affected, err\n\t\t\t}\n\t\t\taffected += cnt\n\t\tcase []map[string]string:\n\t\t\ts := bean.([]map[string]string)\n\t\t\tfor i := 0; i < len(s); i++ {\n\t\t\t\tcnt, err := session.insertMapString(s[i])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn affected, err\n\t\t\t\t}\n\t\t\t\taffected += cnt\n\t\t\t}\n\t\tdefault:\n\t\t\tsliceValue := reflect.Indirect(reflect.ValueOf(bean))\n\t\t\tif sliceValue.Kind() == reflect.Slice {\n\t\t\t\tsize := sliceValue.Len()\n\t\t\t\tif size > 0 {\n\t\t\t\t\tif session.engine.SupportInsertMany() {\n\t\t\t\t\t\tcnt, err := session.innerInsertMulti(bean)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn affected, err\n\t\t\t\t\t\t}\n\t\t\t\t\t\taffected += cnt\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor i := 0; i < size; i++ {\n\t\t\t\t\t\t\tcnt, err := session.innerInsert(sliceValue.Index(i).Interface())\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\treturn affected, err\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\taffected += cnt\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcnt, err := session.innerInsert(bean)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn affected, err\n\t\t\t\t}\n\t\t\t\taffected += cnt\n\t\t\t}\n\t\t}\n\t}\n\n\treturn affected, err\n}\n\nfunc (session *Session) innerInsertMulti(rowsSlicePtr interface{}) (int64, error) {\n\tsliceValue := reflect.Indirect(reflect.ValueOf(rowsSlicePtr))\n\tif sliceValue.Kind() != reflect.Slice {\n\t\treturn 0, errors.New(\"needs a pointer to a slice\")\n\t}\n\n\tif sliceValue.Len() <= 0 {\n\t\treturn 0, errors.New(\"could not insert a empty slice\")\n\t}\n\n\tif err := session.statement.setRefBean(sliceValue.Index(0).Interface()); err != nil {\n\t\treturn 0, err\n\t}\n\n\ttableName := session.statement.TableName()\n\tif len(tableName) <= 0 {\n\t\treturn 0, ErrTableNotFound\n\t}\n\n\ttable := session.statement.RefTable\n\tsize := sliceValue.Len()\n\n\tvar colNames []string\n\tvar colMultiPlaces []string\n\tvar args []interface{}\n\tvar cols []*core.Column\n\n\tfor i := 0; i < size; i++ {\n\t\tv := sliceValue.Index(i)\n\t\tvv := reflect.Indirect(v)\n\t\telemValue := v.Interface()\n\t\tvar colPlaces []string\n\n\t\t// handle BeforeInsertProcessor\n\t\t// !nashtsai! does user expect it's same slice to passed closure when using Before()/After() when insert multi??\n\t\tfor _, closure := range session.beforeClosures {\n\t\t\tclosure(elemValue)\n\t\t}\n\n\t\tif processor, ok := interface{}(elemValue).(BeforeInsertProcessor); ok {\n\t\t\tprocessor.BeforeInsert()\n\t\t}\n\t\t// --\n\n\t\tif i == 0 {\n\t\t\tfor _, col := range table.Columns() {\n\t\t\t\tptrFieldValue, err := col.ValueOfV(&vv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn 0, err\n\t\t\t\t}\n\t\t\t\tfieldValue := *ptrFieldValue\n\t\t\t\tif col.IsAutoIncrement && isZero(fieldValue.Interface()) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif col.MapType == core.ONLYFROMDB {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif col.IsDeleted {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif session.statement.omitColumnMap.contain(col.Name) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif len(session.statement.columnMap) > 0 && !session.statement.columnMap.contain(col.Name) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif (col.IsCreated || col.IsUpdated) && session.statement.UseAutoTime {\n\t\t\t\t\tval, t := session.engine.nowTime(col)\n\t\t\t\t\targs = append(args, val)\n\n\t\t\t\t\tvar colName = col.Name\n\t\t\t\t\tsession.afterClosures = append(session.afterClosures, func(bean interface{}) {\n\t\t\t\t\t\tcol := table.GetColumn(colName)\n\t\t\t\t\t\tsetColumnTime(bean, col, t)\n\t\t\t\t\t})\n\t\t\t\t} else if col.IsVersion && session.statement.checkVersion {\n\t\t\t\t\targs = append(args, 1)\n\t\t\t\t\tvar colName = col.Name\n\t\t\t\t\tsession.afterClosures = append(session.afterClosures, func(bean interface{}) {\n\t\t\t\t\t\tcol := table.GetColumn(colName)\n\t\t\t\t\t\tsetColumnInt(bean, col, 1)\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\targ, err := session.value2Interface(col, fieldValue)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t}\n\t\t\t\t\targs = append(args, arg)\n\t\t\t\t}\n\n\t\t\t\tcolNames = append(colNames, col.Name)\n\t\t\t\tcols = append(cols, col)\n\t\t\t\tcolPlaces = append(colPlaces, \"?\")\n\t\t\t}\n\t\t} else {\n\t\t\tfor _, col := range cols {\n\t\t\t\tptrFieldValue, err := col.ValueOfV(&vv)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn 0, err\n\t\t\t\t}\n\t\t\t\tfieldValue := *ptrFieldValue\n\n\t\t\t\tif col.IsAutoIncrement && isZero(fieldValue.Interface()) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif col.MapType == core.ONLYFROMDB {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif col.IsDeleted {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif session.statement.omitColumnMap.contain(col.Name) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif len(session.statement.columnMap) > 0 && !session.statement.columnMap.contain(col.Name) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif (col.IsCreated || col.IsUpdated) && session.statement.UseAutoTime {\n\t\t\t\t\tval, t := session.engine.nowTime(col)\n\t\t\t\t\targs = append(args, val)\n\n\t\t\t\t\tvar colName = col.Name\n\t\t\t\t\tsession.afterClosures = append(session.afterClosures, func(bean interface{}) {\n\t\t\t\t\t\tcol := table.GetColumn(colName)\n\t\t\t\t\t\tsetColumnTime(bean, col, t)\n\t\t\t\t\t})\n\t\t\t\t} else if col.IsVersion && session.statement.checkVersion {\n\t\t\t\t\targs = append(args, 1)\n\t\t\t\t\tvar colName = col.Name\n\t\t\t\t\tsession.afterClosures = append(session.afterClosures, func(bean interface{}) {\n\t\t\t\t\t\tcol := table.GetColumn(colName)\n\t\t\t\t\t\tsetColumnInt(bean, col, 1)\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\targ, err := session.value2Interface(col, fieldValue)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t}\n\t\t\t\t\targs = append(args, arg)\n\t\t\t\t}\n\n\t\t\t\tcolPlaces = append(colPlaces, \"?\")\n\t\t\t}\n\t\t}\n\t\tcolMultiPlaces = append(colMultiPlaces, strings.Join(colPlaces, \", \"))\n\t}\n\tcleanupProcessorsClosures(&session.beforeClosures)\n\n\tvar sql string\n\tif session.engine.dialect.DBType() == core.ORACLE {\n\t\ttemp := fmt.Sprintf(\") INTO %s (%v) VALUES (\",\n\t\t\tsession.engine.Quote(tableName),\n\t\t\tquoteColumns(colNames, session.engine.Quote, \",\"))\n\t\tsql = fmt.Sprintf(\"INSERT ALL INTO %s (%v) VALUES (%v) SELECT 1 FROM DUAL\",\n\t\t\tsession.engine.Quote(tableName),\n\t\t\tquoteColumns(colNames, session.engine.Quote, \",\"),\n\t\t\tstrings.Join(colMultiPlaces, temp))\n\t} else {\n\t\tsql = fmt.Sprintf(\"INSERT INTO %s (%v) VALUES (%v)\",\n\t\t\tsession.engine.Quote(tableName),\n\t\t\tquoteColumns(colNames, session.engine.Quote, \",\"),\n\t\t\tstrings.Join(colMultiPlaces, \"),(\"))\n\t}\n\tres, err := session.exec(sql, args...)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tsession.cacheInsert(tableName)\n\n\tlenAfterClosures := len(session.afterClosures)\n\tfor i := 0; i < size; i++ {\n\t\telemValue := reflect.Indirect(sliceValue.Index(i)).Addr().Interface()\n\n\t\t// handle AfterInsertProcessor\n\t\tif session.isAutoCommit {\n\t\t\t// !nashtsai! does user expect it's same slice to passed closure when using Before()/After() when insert multi??\n\t\t\tfor _, closure := range session.afterClosures {\n\t\t\t\tclosure(elemValue)\n\t\t\t}\n\t\t\tif processor, ok := interface{}(elemValue).(AfterInsertProcessor); ok {\n\t\t\t\tprocessor.AfterInsert()\n\t\t\t}\n\t\t} else {\n\t\t\tif lenAfterClosures > 0 {\n\t\t\t\tif value, has := session.afterInsertBeans[elemValue]; has && value != nil {\n\t\t\t\t\t*value = append(*value, session.afterClosures...)\n\t\t\t\t} else {\n\t\t\t\t\tafterClosures := make([]func(interface{}), lenAfterClosures)\n\t\t\t\t\tcopy(afterClosures, session.afterClosures)\n\t\t\t\t\tsession.afterInsertBeans[elemValue] = &afterClosures\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif _, ok := interface{}(elemValue).(AfterInsertProcessor); ok {\n\t\t\t\t\tsession.afterInsertBeans[elemValue] = nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcleanupProcessorsClosures(&session.afterClosures)\n\treturn res.RowsAffected()\n}\n\n// InsertMulti insert multiple records\nfunc (session *Session) InsertMulti(rowsSlicePtr interface{}) (int64, error) {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\tsliceValue := reflect.Indirect(reflect.ValueOf(rowsSlicePtr))\n\tif sliceValue.Kind() != reflect.Slice {\n\t\treturn 0, ErrParamsType\n\n\t}\n\n\tif sliceValue.Len() <= 0 {\n\t\treturn 0, nil\n\t}\n\n\treturn session.innerInsertMulti(rowsSlicePtr)\n}\n\nfunc (session *Session) innerInsert(bean interface{}) (int64, error) {\n\tif err := session.statement.setRefBean(bean); err != nil {\n\t\treturn 0, err\n\t}\n\tif len(session.statement.TableName()) <= 0 {\n\t\treturn 0, ErrTableNotFound\n\t}\n\n\ttable := session.statement.RefTable\n\n\t// handle BeforeInsertProcessor\n\tfor _, closure := range session.beforeClosures {\n\t\tclosure(bean)\n\t}\n\tcleanupProcessorsClosures(&session.beforeClosures) // cleanup after used\n\n\tif processor, ok := interface{}(bean).(BeforeInsertProcessor); ok {\n\t\tprocessor.BeforeInsert()\n\t}\n\n\tcolNames, args, err := session.genInsertColumns(bean)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\texprs := session.statement.exprColumns\n\tcolPlaces := strings.Repeat(\"?, \", len(colNames))\n\tif exprs.Len() <= 0 && len(colPlaces) > 0 {\n\t\tcolPlaces = colPlaces[0 : len(colPlaces)-2]\n\t}\n\n\tvar tableName = session.statement.TableName()\n\tvar output string\n\tif session.engine.dialect.DBType() == core.MSSQL && len(table.AutoIncrement) > 0 {\n\t\toutput = fmt.Sprintf(\" OUTPUT Inserted.%s\", table.AutoIncrement)\n\t}\n\n\tvar buf = builder.NewWriter()\n\tif _, err := buf.WriteString(fmt.Sprintf(\"INSERT INTO %s\", session.engine.Quote(tableName))); err != nil {\n\t\treturn 0, err\n\t}\n\n\tif len(colPlaces) <= 0 {\n\t\tif session.engine.dialect.DBType() == core.MYSQL {\n\t\t\tif _, err := buf.WriteString(\" VALUES ()\"); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t} else {\n\t\t\tif _, err := buf.WriteString(fmt.Sprintf(\"%s DEFAULT VALUES\", output)); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif _, err := buf.WriteString(\" (\"); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif err := writeStrings(buf, append(colNames, exprs.colNames...), \"`\", \"`\"); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif session.statement.cond.IsValid() {\n\t\t\tif _, err := buf.WriteString(fmt.Sprintf(\")%s SELECT \", output)); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\n\t\t\tif err := session.statement.writeArgs(buf, args); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\n\t\t\tif len(exprs.args) > 0 {\n\t\t\t\tif _, err := buf.WriteString(\",\"); err != nil {\n\t\t\t\t\treturn 0, err\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := exprs.writeArgs(buf); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\n\t\t\tif _, err := buf.WriteString(fmt.Sprintf(\" FROM %v WHERE \", session.engine.Quote(tableName))); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\n\t\t\tif err := session.statement.cond.WriteTo(buf); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t} else {\n\t\t\tbuf.Append(args...)\n\n\t\t\tif _, err := buf.WriteString(fmt.Sprintf(\")%s VALUES (%v\",\n\t\t\t\toutput,\n\t\t\t\tcolPlaces)); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\n\t\t\tif err := exprs.writeArgs(buf); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\n\t\t\tif _, err := buf.WriteString(\")\"); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(table.AutoIncrement) > 0 && session.engine.dialect.DBType() == core.POSTGRES {\n\t\tif _, err := buf.WriteString(\" RETURNING \" + session.engine.Quote(table.AutoIncrement)); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\tsqlStr := buf.String()\n\targs = buf.Args()\n\n\thandleAfterInsertProcessorFunc := func(bean interface{}) {\n\t\tif session.isAutoCommit {\n\t\t\tfor _, closure := range session.afterClosures {\n\t\t\t\tclosure(bean)\n\t\t\t}\n\t\t\tif processor, ok := interface{}(bean).(AfterInsertProcessor); ok {\n\t\t\t\tprocessor.AfterInsert()\n\t\t\t}\n\t\t} else {\n\t\t\tlenAfterClosures := len(session.afterClosures)\n\t\t\tif lenAfterClosures > 0 {\n\t\t\t\tif value, has := session.afterInsertBeans[bean]; has && value != nil {\n\t\t\t\t\t*value = append(*value, session.afterClosures...)\n\t\t\t\t} else {\n\t\t\t\t\tafterClosures := make([]func(interface{}), lenAfterClosures)\n\t\t\t\t\tcopy(afterClosures, session.afterClosures)\n\t\t\t\t\tsession.afterInsertBeans[bean] = &afterClosures\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tif _, ok := interface{}(bean).(AfterInsertProcessor); ok {\n\t\t\t\t\tsession.afterInsertBeans[bean] = nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcleanupProcessorsClosures(&session.afterClosures) // cleanup after used\n\t}\n\n\t// for postgres, many of them didn't implement lastInsertId, so we should\n\t// implemented it ourself.\n\tif session.engine.dialect.DBType() == core.ORACLE && len(table.AutoIncrement) > 0 {\n\t\tres, err := session.queryBytes(\"select seq_atable.currval from dual\", args...)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tdefer handleAfterInsertProcessorFunc(bean)\n\n\t\tsession.cacheInsert(tableName)\n\n\t\tif table.Version != \"\" && session.statement.checkVersion {\n\t\t\tverValue, err := table.VersionColumn().ValueOf(bean)\n\t\t\tif err != nil {\n\t\t\t\tsession.engine.logger.Error(err)\n\t\t\t} else if verValue.IsValid() && verValue.CanSet() {\n\t\t\t\tsession.incrVersionFieldValue(verValue)\n\t\t\t}\n\t\t}\n\n\t\tif len(res) < 1 {\n\t\t\treturn 0, errors.New(\"insert no error but not returned id\")\n\t\t}\n\n\t\tidByte := res[0][table.AutoIncrement]\n\t\tid, err := strconv.ParseInt(string(idByte), 10, 64)\n\t\tif err != nil || id <= 0 {\n\t\t\treturn 1, err\n\t\t}\n\n\t\taiValue, err := table.AutoIncrColumn().ValueOf(bean)\n\t\tif err != nil {\n\t\t\tsession.engine.logger.Error(err)\n\t\t}\n\n\t\tif aiValue == nil || !aiValue.IsValid() || !aiValue.CanSet() {\n\t\t\treturn 1, nil\n\t\t}\n\n\t\taiValue.Set(int64ToIntValue(id, aiValue.Type()))\n\n\t\treturn 1, nil\n\t} else if len(table.AutoIncrement) > 0 && (session.engine.dialect.DBType() == core.POSTGRES || session.engine.dialect.DBType() == core.MSSQL) {\n\t\tres, err := session.queryBytes(sqlStr, args...)\n\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tdefer handleAfterInsertProcessorFunc(bean)\n\n\t\tsession.cacheInsert(tableName)\n\n\t\tif table.Version != \"\" && session.statement.checkVersion {\n\t\t\tverValue, err := table.VersionColumn().ValueOf(bean)\n\t\t\tif err != nil {\n\t\t\t\tsession.engine.logger.Error(err)\n\t\t\t} else if verValue.IsValid() && verValue.CanSet() {\n\t\t\t\tsession.incrVersionFieldValue(verValue)\n\t\t\t}\n\t\t}\n\n\t\tif len(res) < 1 {\n\t\t\treturn 0, errors.New(\"insert successfully but not returned id\")\n\t\t}\n\n\t\tidByte := res[0][table.AutoIncrement]\n\t\tid, err := strconv.ParseInt(string(idByte), 10, 64)\n\t\tif err != nil || id <= 0 {\n\t\t\treturn 1, err\n\t\t}\n\n\t\taiValue, err := table.AutoIncrColumn().ValueOf(bean)\n\t\tif err != nil {\n\t\t\tsession.engine.logger.Error(err)\n\t\t}\n\n\t\tif aiValue == nil || !aiValue.IsValid() || !aiValue.CanSet() {\n\t\t\treturn 1, nil\n\t\t}\n\n\t\taiValue.Set(int64ToIntValue(id, aiValue.Type()))\n\n\t\treturn 1, nil\n\t} else {\n\t\tres, err := session.exec(sqlStr, args...)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tdefer handleAfterInsertProcessorFunc(bean)\n\n\t\tsession.cacheInsert(tableName)\n\n\t\tif table.Version != \"\" && session.statement.checkVersion {\n\t\t\tverValue, err := table.VersionColumn().ValueOf(bean)\n\t\t\tif err != nil {\n\t\t\t\tsession.engine.logger.Error(err)\n\t\t\t} else if verValue.IsValid() && verValue.CanSet() {\n\t\t\t\tsession.incrVersionFieldValue(verValue)\n\t\t\t}\n\t\t}\n\n\t\tif table.AutoIncrement == \"\" {\n\t\t\treturn res.RowsAffected()\n\t\t}\n\n\t\tvar id int64\n\t\tid, err = res.LastInsertId()\n\t\tif err != nil || id <= 0 {\n\t\t\treturn res.RowsAffected()\n\t\t}\n\n\t\taiValue, err := table.AutoIncrColumn().ValueOf(bean)\n\t\tif err != nil {\n\t\t\tsession.engine.logger.Error(err)\n\t\t}\n\n\t\tif aiValue == nil || !aiValue.IsValid() || !aiValue.CanSet() {\n\t\t\treturn res.RowsAffected()\n\t\t}\n\n\t\taiValue.Set(int64ToIntValue(id, aiValue.Type()))\n\n\t\treturn res.RowsAffected()\n\t}\n}\n\n// InsertOne insert only one struct into database as a record.\n// The in parameter bean must a struct or a point to struct. The return\n// parameter is inserted and error\nfunc (session *Session) InsertOne(bean interface{}) (int64, error) {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\treturn session.innerInsert(bean)\n}\n\nfunc (session *Session) cacheInsert(table string) error {\n\tif !session.statement.UseCache {\n\t\treturn nil\n\t}\n\tcacher := session.engine.getCacher(table)\n\tif cacher == nil {\n\t\treturn nil\n\t}\n\tsession.engine.logger.Debug(\"[cache] clear sql:\", table)\n\tcacher.ClearIds(table)\n\treturn nil\n}\n\n// genInsertColumns generates insert needed columns\nfunc (session *Session) genInsertColumns(bean interface{}) ([]string, []interface{}, error) {\n\ttable := session.statement.RefTable\n\tcolNames := make([]string, 0, len(table.ColumnsSeq()))\n\targs := make([]interface{}, 0, len(table.ColumnsSeq()))\n\n\tfor _, col := range table.Columns() {\n\t\tif col.MapType == core.ONLYFROMDB {\n\t\t\tcontinue\n\t\t}\n\n\t\tif col.IsDeleted {\n\t\t\tcontinue\n\t\t}\n\n\t\tif session.statement.omitColumnMap.contain(col.Name) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(session.statement.columnMap) > 0 && !session.statement.columnMap.contain(col.Name) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif session.statement.incrColumns.isColExist(col.Name) {\n\t\t\tcontinue\n\t\t} else if session.statement.decrColumns.isColExist(col.Name) {\n\t\t\tcontinue\n\t\t} else if session.statement.exprColumns.isColExist(col.Name) {\n\t\t\tcontinue\n\t\t}\n\n\t\tfieldValuePtr, err := col.ValueOf(bean)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tfieldValue := *fieldValuePtr\n\n\t\tif col.IsAutoIncrement {\n\t\t\tswitch fieldValue.Type().Kind() {\n\t\t\tcase reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int, reflect.Int64:\n\t\t\t\tif fieldValue.Int() == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\tcase reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint, reflect.Uint64:\n\t\t\t\tif fieldValue.Uint() == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\tcase reflect.String:\n\t\t\t\tif len(fieldValue.String()) == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\tcase reflect.Ptr:\n\t\t\t\tif fieldValue.Pointer() == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// !evalphobia! set fieldValue as nil when column is nullable and zero-value\n\t\tif _, ok := getFlagForColumn(session.statement.nullableMap, col); ok {\n\t\t\tif col.Nullable && isZero(fieldValue.Interface()) {\n\t\t\t\tvar nilValue *int\n\t\t\t\tfieldValue = reflect.ValueOf(nilValue)\n\t\t\t}\n\t\t}\n\n\t\tif (col.IsCreated || col.IsUpdated) && session.statement.UseAutoTime /*&& isZero(fieldValue.Interface())*/ {\n\t\t\t// if time is non-empty, then set to auto time\n\t\t\tval, t := session.engine.nowTime(col)\n\t\t\targs = append(args, val)\n\n\t\t\tvar colName = col.Name\n\t\t\tsession.afterClosures = append(session.afterClosures, func(bean interface{}) {\n\t\t\t\tcol := table.GetColumn(colName)\n\t\t\t\tsetColumnTime(bean, col, t)\n\t\t\t})\n\t\t} else if col.IsVersion && session.statement.checkVersion {\n\t\t\targs = append(args, 1)\n\t\t} else {\n\t\t\targ, err := session.value2Interface(col, fieldValue)\n\t\t\tif err != nil {\n\t\t\t\treturn colNames, args, err\n\t\t\t}\n\t\t\targs = append(args, arg)\n\t\t}\n\n\t\tcolNames = append(colNames, col.Name)\n\t}\n\treturn colNames, args, nil\n}\n\nfunc (session *Session) insertMapInterface(m map[string]interface{}) (int64, error) {\n\tif len(m) == 0 {\n\t\treturn 0, ErrParamsType\n\t}\n\n\ttableName := session.statement.TableName()\n\tif len(tableName) <= 0 {\n\t\treturn 0, ErrTableNotFound\n\t}\n\n\tvar columns = make([]string, 0, len(m))\n\texprs := session.statement.exprColumns\n\tfor k := range m {\n\t\tif !exprs.isColExist(k) {\n\t\t\tcolumns = append(columns, k)\n\t\t}\n\t}\n\tsort.Strings(columns)\n\n\tvar args = make([]interface{}, 0, len(m))\n\tfor _, colName := range columns {\n\t\targs = append(args, m[colName])\n\t}\n\n\tw := builder.NewWriter()\n\tif session.statement.cond.IsValid() {\n\t\tif _, err := w.WriteString(fmt.Sprintf(\"INSERT INTO %s (\", session.engine.Quote(tableName))); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif err := writeStrings(w, append(columns, exprs.colNames...), \"`\", \"`\"); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif _, err := w.WriteString(\") SELECT \"); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif err := session.statement.writeArgs(w, args); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif len(exprs.args) > 0 {\n\t\t\tif _, err := w.WriteString(\",\"); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tif err := exprs.writeArgs(w); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t}\n\n\t\tif _, err := w.WriteString(fmt.Sprintf(\" FROM %s WHERE \", session.engine.Quote(tableName))); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif err := session.statement.cond.WriteTo(w); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t} else {\n\t\tqm := strings.Repeat(\"?,\", len(columns))\n\t\tqm = qm[:len(qm)-1]\n\n\t\tif _, err := w.WriteString(fmt.Sprintf(\"INSERT INTO %s (`%s`) VALUES (%s)\", session.engine.Quote(tableName), strings.Join(columns, \"`,`\"), qm)); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tw.Append(args...)\n\t}\n\n\tsql := w.String()\n\targs = w.Args()\n\n\tif err := session.cacheInsert(tableName); err != nil {\n\t\treturn 0, err\n\t}\n\n\tres, err := session.exec(sql, args...)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\taffected, err := res.RowsAffected()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn affected, nil\n}\n\nfunc (session *Session) insertMapString(m map[string]string) (int64, error) {\n\tif len(m) == 0 {\n\t\treturn 0, ErrParamsType\n\t}\n\n\ttableName := session.statement.TableName()\n\tif len(tableName) <= 0 {\n\t\treturn 0, ErrTableNotFound\n\t}\n\n\tvar columns = make([]string, 0, len(m))\n\texprs := session.statement.exprColumns\n\tfor k := range m {\n\t\tif !exprs.isColExist(k) {\n\t\t\tcolumns = append(columns, k)\n\t\t}\n\t}\n\tsort.Strings(columns)\n\n\tvar args = make([]interface{}, 0, len(m))\n\tfor _, colName := range columns {\n\t\targs = append(args, m[colName])\n\t}\n\n\tw := builder.NewWriter()\n\tif session.statement.cond.IsValid() {\n\t\tif _, err := w.WriteString(fmt.Sprintf(\"INSERT INTO %s (\", session.engine.Quote(tableName))); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif err := writeStrings(w, append(columns, exprs.colNames...), \"`\", \"`\"); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif _, err := w.WriteString(\") SELECT \"); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif err := session.statement.writeArgs(w, args); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif len(exprs.args) > 0 {\n\t\t\tif _, err := w.WriteString(\",\"); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tif err := exprs.writeArgs(w); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t}\n\n\t\tif _, err := w.WriteString(fmt.Sprintf(\" FROM %s WHERE \", session.engine.Quote(tableName))); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif err := session.statement.cond.WriteTo(w); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t} else {\n\t\tqm := strings.Repeat(\"?,\", len(columns))\n\t\tqm = qm[:len(qm)-1]\n\n\t\tif _, err := w.WriteString(fmt.Sprintf(\"INSERT INTO %s (`%s`) VALUES (%s)\", session.engine.Quote(tableName), strings.Join(columns, \"`,`\"), qm)); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tw.Append(args...)\n\t}\n\n\tsql := w.String()\n\targs = w.Args()\n\n\tif err := session.cacheInsert(tableName); err != nil {\n\t\treturn 0, err\n\t}\n\n\tres, err := session.exec(sql, args...)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\taffected, err := res.RowsAffected()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn affected, nil\n}\n"
        },
        {
          "name": "session_insert_test.go",
          "type": "blob",
          "size": 24.388671875,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestInsertOne(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype Test struct {\n\t\tId      int64     `xorm:\"autoincr pk\"`\n\t\tMsg     string    `xorm:\"varchar(255)\"`\n\t\tCreated time.Time `xorm:\"created\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(Test)))\n\n\tdata := Test{Msg: \"hi\"}\n\t_, err := testEngine.InsertOne(data)\n\tassert.NoError(t, err)\n}\n\nfunc TestInsertMulti(t *testing.T) {\n\n\tassert.NoError(t, prepareEngine())\n\ttype TestMulti struct {\n\t\tId   int64  `xorm:\"int(11) pk\"`\n\t\tName string `xorm:\"varchar(255)\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(TestMulti)))\n\n\tnum, err := insertMultiDatas(1,\n\t\tappend([]TestMulti{}, TestMulti{1, \"test1\"}, TestMulti{2, \"test2\"}, TestMulti{3, \"test3\"}))\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 3, num)\n}\n\nfunc insertMultiDatas(step int, datas interface{}) (num int64, err error) {\n\tsliceValue := reflect.Indirect(reflect.ValueOf(datas))\n\tvar iLen int64\n\tif sliceValue.Kind() != reflect.Slice {\n\t\treturn 0, fmt.Errorf(\"not silce\")\n\t}\n\tiLen = int64(sliceValue.Len())\n\tif iLen == 0 {\n\t\treturn\n\t}\n\n\tsession := testEngine.NewSession()\n\tdefer session.Close()\n\n\tif err = callbackLooper(datas, step,\n\t\tfunc(innerDatas interface{}) error {\n\t\t\tn, e := session.InsertMulti(innerDatas)\n\t\t\tif e != nil {\n\t\t\t\treturn e\n\t\t\t}\n\t\t\tnum += n\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\treturn 0, err\n\t} else if num != iLen {\n\t\treturn 0, fmt.Errorf(\"num error: %d - %d\", num, iLen)\n\t}\n\treturn\n}\n\nfunc callbackLooper(datas interface{}, step int, actionFunc func(interface{}) error) (err error) {\n\n\tsliceValue := reflect.Indirect(reflect.ValueOf(datas))\n\tif sliceValue.Kind() != reflect.Slice {\n\t\treturn fmt.Errorf(\"not slice\")\n\t}\n\tif sliceValue.Len() <= 0 {\n\t\treturn\n\t}\n\n\ttempLen := 0\n\tprocessedLen := sliceValue.Len()\n\tfor i := 0; i < sliceValue.Len(); i += step {\n\t\tif processedLen > step {\n\t\t\ttempLen = i + step\n\t\t} else {\n\t\t\ttempLen = sliceValue.Len()\n\t\t}\n\t\tvar tempInterface []interface{}\n\t\tfor j := i; j < tempLen; j++ {\n\t\t\ttempInterface = append(tempInterface, sliceValue.Index(j).Interface())\n\t\t}\n\t\tif err = actionFunc(tempInterface); err != nil {\n\t\t\treturn\n\t\t}\n\t\tprocessedLen = processedLen - step\n\t}\n\treturn\n}\n\nfunc TestInsertOneIfPkIsPoint(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype TestPoint struct {\n\t\tId      *int64     `xorm:\"autoincr pk notnull 'id'\"`\n\t\tMsg     *string    `xorm:\"varchar(255)\"`\n\t\tCreated *time.Time `xorm:\"created\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(TestPoint)))\n\tmsg := \"hi\"\n\tdata := TestPoint{Msg: &msg}\n\t_, err := testEngine.InsertOne(&data)\n\tassert.NoError(t, err)\n}\n\nfunc TestInsertOneIfPkIsPointRename(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\ttype ID *int64\n\ttype TestPoint2 struct {\n\t\tId      ID         `xorm:\"autoincr pk notnull 'id'\"`\n\t\tMsg     *string    `xorm:\"varchar(255)\"`\n\t\tCreated *time.Time `xorm:\"created\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(TestPoint2)))\n\tmsg := \"hi\"\n\tdata := TestPoint2{Msg: &msg}\n\t_, err := testEngine.InsertOne(&data)\n\tassert.NoError(t, err)\n}\n\nfunc TestInsert(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\tuser := Userinfo{0, \"xiaolunwen\", \"dev\", \"lunny\", time.Now(),\n\t\tUserdetail{Id: 1}, 1.78, []byte{1, 2, 3}, true}\n\tcnt, err := testEngine.Insert(&user)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt, \"insert not returned 1\")\n\tassert.True(t, user.Uid > 0, \"not return id error\")\n\n\tuser.Uid = 0\n\tcnt, err = testEngine.Insert(&user)\n\t// Username is unique, so this should return error\n\tassert.Error(t, err, \"insert should fail but no error returned\")\n\tassert.EqualValues(t, 0, cnt, \"insert not returned 1\")\n\tif err == nil {\n\t\tpanic(\"should return err\")\n\t}\n}\n\nfunc TestInsertAutoIncr(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\t// auto increment insert\n\tuser := Userinfo{Username: \"xiaolunwen2\", Departname: \"dev\", Alias: \"lunny\", Created: time.Now(),\n\t\tDetail: Userdetail{Id: 1}, Height: 1.78, Avatar: []byte{1, 2, 3}, IsMan: true}\n\tcnt, err := testEngine.Insert(&user)\n\tfmt.Println(user.Uid)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert not returned 1\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif user.Uid <= 0 {\n\t\tt.Error(errors.New(\"not return id error\"))\n\t}\n}\n\ntype DefaultInsert struct {\n\tId      int64\n\tStatus  int `xorm:\"default -1\"`\n\tName    string\n\tCreated time.Time `xorm:\"created\"`\n\tUpdated time.Time `xorm:\"updated\"`\n}\n\nfunc TestInsertDefault(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tdi := new(DefaultInsert)\n\terr := testEngine.Sync2(di)\n\tassert.NoError(t, err)\n\n\tvar di2 = DefaultInsert{Name: \"test\"}\n\t_, err = testEngine.Omit(testEngine.GetColumnMapper().Obj2Table(\"Status\")).Insert(&di2)\n\tassert.NoError(t, err)\n\n\thas, err := testEngine.Desc(\"(id)\").Get(di)\n\tassert.NoError(t, err)\n\tif !has {\n\t\terr = errors.New(\"error with no data\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif di.Status != -1 {\n\t\terr = errors.New(\"inserted error data\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif di2.Updated.Unix() != di.Updated.Unix() {\n\t\terr = errors.New(\"updated should equal\")\n\t\tt.Error(err, di.Updated, di2.Updated)\n\t\tpanic(err)\n\t}\n\tif di2.Created.Unix() != di.Created.Unix() {\n\t\terr = errors.New(\"created should equal\")\n\t\tt.Error(err, di.Created, di2.Created)\n\t\tpanic(err)\n\t}\n}\n\ntype DefaultInsert2 struct {\n\tId        int64\n\tName      string\n\tUrl       string    `xorm:\"text\"`\n\tCheckTime time.Time `xorm:\"not null default '2000-01-01 00:00:00' TIMESTAMP\"`\n}\n\nfunc TestInsertDefault2(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tdi := new(DefaultInsert2)\n\terr := testEngine.Sync2(di)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tvar di2 = DefaultInsert2{Name: \"test\"}\n\t_, err = testEngine.Omit(testEngine.GetColumnMapper().Obj2Table(\"CheckTime\")).Insert(&di2)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\thas, err := testEngine.Desc(\"(id)\").Get(di)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !has {\n\t\terr = errors.New(\"error with no data\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\thas, err = testEngine.NoAutoCondition().Desc(\"(id)\").Get(&di2)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif !has {\n\t\terr = errors.New(\"error with no data\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif *di != di2 {\n\t\terr = fmt.Errorf(\"%v is not equal to %v\", di, di2)\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\t/*if di2.Updated.Unix() != di.Updated.Unix() {\n\t\terr = errors.New(\"updated should equal\")\n\t\tt.Error(err, di.Updated, di2.Updated)\n\t\tpanic(err)\n\t}\n\tif di2.Created.Unix() != di.Created.Unix() {\n\t\terr = errors.New(\"created should equal\")\n\t\tt.Error(err, di.Created, di2.Created)\n\t\tpanic(err)\n\t}*/\n}\n\ntype CreatedInsert struct {\n\tId      int64\n\tCreated time.Time `xorm:\"created\"`\n}\n\ntype CreatedInsert2 struct {\n\tId      int64\n\tCreated int64 `xorm:\"created\"`\n}\n\ntype CreatedInsert3 struct {\n\tId      int64\n\tCreated int `xorm:\"created bigint\"`\n}\n\ntype CreatedInsert4 struct {\n\tId      int64\n\tCreated int `xorm:\"created\"`\n}\n\ntype CreatedInsert5 struct {\n\tId      int64\n\tCreated time.Time `xorm:\"created bigint\"`\n}\n\ntype CreatedInsert6 struct {\n\tId      int64\n\tCreated time.Time `xorm:\"created bigint\"`\n}\n\nfunc TestInsertCreated(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tdi := new(CreatedInsert)\n\terr := testEngine.Sync2(di)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tci := &CreatedInsert{}\n\t_, err = testEngine.Insert(ci)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\thas, err := testEngine.Desc(\"(id)\").Get(di)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !has {\n\t\tt.Fatal(ErrNotExist)\n\t}\n\tif ci.Created.Unix() != di.Created.Unix() {\n\t\tt.Fatal(\"should equal:\", ci, di)\n\t}\n\tfmt.Println(\"ci:\", ci, \"di:\", di)\n\n\tdi2 := new(CreatedInsert2)\n\terr = testEngine.Sync2(di2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tci2 := &CreatedInsert2{}\n\t_, err = testEngine.Insert(ci2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\thas, err = testEngine.Desc(\"(id)\").Get(di2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !has {\n\t\tt.Fatal(ErrNotExist)\n\t}\n\tif ci2.Created != di2.Created {\n\t\tt.Fatal(\"should equal:\", ci2, di2)\n\t}\n\tfmt.Println(\"ci2:\", ci2, \"di2:\", di2)\n\n\tdi3 := new(CreatedInsert3)\n\terr = testEngine.Sync2(di3)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tci3 := &CreatedInsert3{}\n\t_, err = testEngine.Insert(ci3)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\thas, err = testEngine.Desc(\"(id)\").Get(di3)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !has {\n\t\tt.Fatal(ErrNotExist)\n\t}\n\tif ci3.Created != di3.Created {\n\t\tt.Fatal(\"should equal:\", ci3, di3)\n\t}\n\tfmt.Println(\"ci3:\", ci3, \"di3:\", di3)\n\n\tdi4 := new(CreatedInsert4)\n\terr = testEngine.Sync2(di4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tci4 := &CreatedInsert4{}\n\t_, err = testEngine.Insert(ci4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\thas, err = testEngine.Desc(\"(id)\").Get(di4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !has {\n\t\tt.Fatal(ErrNotExist)\n\t}\n\tif ci4.Created != di4.Created {\n\t\tt.Fatal(\"should equal:\", ci4, di4)\n\t}\n\tfmt.Println(\"ci4:\", ci4, \"di4:\", di4)\n\n\tdi5 := new(CreatedInsert5)\n\terr = testEngine.Sync2(di5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tci5 := &CreatedInsert5{}\n\t_, err = testEngine.Insert(ci5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\thas, err = testEngine.Desc(\"(id)\").Get(di5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !has {\n\t\tt.Fatal(ErrNotExist)\n\t}\n\tif ci5.Created.Unix() != di5.Created.Unix() {\n\t\tt.Fatal(\"should equal:\", ci5, di5)\n\t}\n\tfmt.Println(\"ci5:\", ci5, \"di5:\", di5)\n\n\tdi6 := new(CreatedInsert6)\n\terr = testEngine.Sync2(di6)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\toldTime := time.Now().Add(-time.Hour)\n\tci6 := &CreatedInsert6{Created: oldTime}\n\t_, err = testEngine.Insert(ci6)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\thas, err = testEngine.Desc(\"(id)\").Get(di6)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !has {\n\t\tt.Fatal(ErrNotExist)\n\t}\n\tif ci6.Created.Unix() != di6.Created.Unix() {\n\t\tt.Fatal(\"should equal:\", ci6, di6)\n\t}\n\tfmt.Println(\"ci6:\", ci6, \"di6:\", di6)\n}\n\ntype JsonTime time.Time\n\nfunc (j JsonTime) format() string {\n\tt := time.Time(j)\n\tif t.IsZero() {\n\t\treturn \"\"\n\t}\n\n\treturn t.Format(\"2006-01-02\")\n}\n\nfunc (j JsonTime) MarshalText() ([]byte, error) {\n\treturn []byte(j.format()), nil\n}\n\nfunc (j JsonTime) MarshalJSON() ([]byte, error) {\n\treturn []byte(`\"` + j.format() + `\"`), nil\n}\n\nfunc TestDefaultTime3(t *testing.T) {\n\ttype PrepareTask struct {\n\t\tId int `xorm:\"not null pk autoincr INT(11)\" json:\"id\"`\n\t\t// ...\n\t\tStartTime JsonTime `xorm:\"not null default '2006-01-02 15:04:05' TIMESTAMP index\" json:\"start_time\"`\n\t\tEndTime   JsonTime `xorm:\"not null default '2006-01-02 15:04:05' TIMESTAMP\" json:\"end_time\"`\n\t\tCuser     string   `xorm:\"not null default '' VARCHAR(64) index\" json:\"cuser\"`\n\t\tMuser     string   `xorm:\"not null default '' VARCHAR(64)\" json:\"muser\"`\n\t\tCtime     JsonTime `xorm:\"not null default CURRENT_TIMESTAMP TIMESTAMP created\" json:\"ctime\"`\n\t\tMtime     JsonTime `xorm:\"not null default CURRENT_TIMESTAMP TIMESTAMP updated\" json:\"mtime\"`\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(PrepareTask))\n\n\tprepareTask := &PrepareTask{\n\t\tStartTime: JsonTime(time.Now()),\n\t\tCuser:     \"userId\",\n\t\tMuser:     \"userId\",\n\t}\n\tcnt, err := testEngine.Omit(\"end_time\").InsertOne(prepareTask)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n}\n\ntype MyJsonTime struct {\n\tId      int64    `json:\"id\"`\n\tCreated JsonTime `xorm:\"created\" json:\"created_at\"`\n}\n\nfunc TestCreatedJsonTime(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tdi5 := new(MyJsonTime)\n\terr := testEngine.Sync2(di5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tci5 := &MyJsonTime{}\n\t_, err = testEngine.Insert(ci5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\thas, err := testEngine.Desc(\"(id)\").Get(di5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !has {\n\t\tt.Fatal(ErrNotExist)\n\t}\n\tif time.Time(ci5.Created).Unix() != time.Time(di5.Created).Unix() {\n\t\tt.Fatal(\"should equal:\", time.Time(ci5.Created).Unix(), time.Time(di5.Created).Unix())\n\t}\n\tfmt.Println(\"ci5:\", ci5, \"di5:\", di5)\n\n\tvar dis = make([]MyJsonTime, 0)\n\terr = testEngine.Find(&dis)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestInsertMulti2(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tassertSync(t, new(Userinfo))\n\n\tusers := []Userinfo{\n\t\t{Username: \"xlw\", Departname: \"dev\", Alias: \"lunny2\", Created: time.Now()},\n\t\t{Username: \"xlw2\", Departname: \"dev\", Alias: \"lunny3\", Created: time.Now()},\n\t\t{Username: \"xlw11\", Departname: \"dev\", Alias: \"lunny2\", Created: time.Now()},\n\t\t{Username: \"xlw22\", Departname: \"dev\", Alias: \"lunny3\", Created: time.Now()},\n\t}\n\tcnt, err := testEngine.Insert(&users)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif cnt != int64(len(users)) {\n\t\terr = errors.New(\"insert not returned 1\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t\treturn\n\t}\n\n\tusers2 := []*Userinfo{\n\t\t&Userinfo{Username: \"1xlw\", Departname: \"dev\", Alias: \"lunny2\", Created: time.Now()},\n\t\t&Userinfo{Username: \"1xlw2\", Departname: \"dev\", Alias: \"lunny3\", Created: time.Now()},\n\t\t&Userinfo{Username: \"1xlw11\", Departname: \"dev\", Alias: \"lunny2\", Created: time.Now()},\n\t\t&Userinfo{Username: \"1xlw22\", Departname: \"dev\", Alias: \"lunny3\", Created: time.Now()},\n\t}\n\n\tcnt, err = testEngine.Insert(&users2)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif cnt != int64(len(users2)) {\n\t\terr = errors.New(fmt.Sprintf(\"insert not returned %v\", len(users2)))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestInsertTwoTable(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tassertSync(t, new(Userinfo), new(Userdetail))\n\n\tuserdetail := Userdetail{ /*Id: 1, */ Intro: \"I'm a very beautiful women.\", Profile: \"sfsaf\"}\n\tuserinfo := Userinfo{Username: \"xlw3\", Departname: \"dev\", Alias: \"lunny4\", Created: time.Now(), Detail: userdetail}\n\n\tcnt, err := testEngine.Insert(&userinfo, &userdetail)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif userinfo.Uid <= 0 {\n\t\terr = errors.New(\"not return id error\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif userdetail.Id <= 0 {\n\t\terr = errors.New(\"not return id error\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif cnt != 2 {\n\t\terr = errors.New(\"insert not returned 2\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestInsertCreatedInt64(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype TestCreatedInt64 struct {\n\t\tId      int64  `xorm:\"autoincr pk\"`\n\t\tMsg     string `xorm:\"varchar(255)\"`\n\t\tCreated int64  `xorm:\"created\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(TestCreatedInt64)))\n\n\tdata := TestCreatedInt64{Msg: \"hi\"}\n\tnow := time.Now()\n\tcnt, err := testEngine.Insert(&data)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\tassert.True(t, now.Unix() <= data.Created)\n\n\tvar data2 TestCreatedInt64\n\thas, err := testEngine.Get(&data2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\tassert.EqualValues(t, data.Created, data2.Created)\n}\n\ntype MyUserinfo Userinfo\n\nfunc (MyUserinfo) TableName() string {\n\treturn \"user_info\"\n}\n\nfunc TestInsertMulti3(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttestEngine.ShowSQL(true)\n\tassertSync(t, new(MyUserinfo))\n\n\tusers := []MyUserinfo{\n\t\t{Username: \"xlw\", Departname: \"dev\", Alias: \"lunny2\", Created: time.Now()},\n\t\t{Username: \"xlw2\", Departname: \"dev\", Alias: \"lunny3\", Created: time.Now()},\n\t\t{Username: \"xlw11\", Departname: \"dev\", Alias: \"lunny2\", Created: time.Now()},\n\t\t{Username: \"xlw22\", Departname: \"dev\", Alias: \"lunny3\", Created: time.Now()},\n\t}\n\tcnt, err := testEngine.Insert(&users)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, len(users), cnt)\n\n\tusers2 := []*MyUserinfo{\n\t\t&MyUserinfo{Username: \"1xlw\", Departname: \"dev\", Alias: \"lunny2\", Created: time.Now()},\n\t\t&MyUserinfo{Username: \"1xlw2\", Departname: \"dev\", Alias: \"lunny3\", Created: time.Now()},\n\t\t&MyUserinfo{Username: \"1xlw11\", Departname: \"dev\", Alias: \"lunny2\", Created: time.Now()},\n\t\t&MyUserinfo{Username: \"1xlw22\", Departname: \"dev\", Alias: \"lunny3\", Created: time.Now()},\n\t}\n\n\tcnt, err = testEngine.Insert(&users2)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, len(users), cnt)\n}\n\ntype MyUserinfo2 struct {\n\tUid        int64  `xorm:\"id pk not null autoincr\"`\n\tUsername   string `xorm:\"unique\"`\n\tDepartname string\n\tAlias      string `xorm:\"-\"`\n\tCreated    time.Time\n\tDetail     Userdetail `xorm:\"detail_id int(11)\"`\n\tHeight     float64\n\tAvatar     []byte\n\tIsMan      bool\n}\n\nfunc (MyUserinfo2) TableName() string {\n\treturn \"user_info\"\n}\n\nfunc TestInsertMulti4(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttestEngine.ShowSQL(false)\n\tassertSync(t, new(MyUserinfo2))\n\ttestEngine.ShowSQL(true)\n\n\tusers := []MyUserinfo2{\n\t\t{Username: \"xlw\", Departname: \"dev\", Alias: \"lunny2\", Created: time.Now()},\n\t\t{Username: \"xlw2\", Departname: \"dev\", Alias: \"lunny3\", Created: time.Now()},\n\t\t{Username: \"xlw11\", Departname: \"dev\", Alias: \"lunny2\", Created: time.Now()},\n\t\t{Username: \"xlw22\", Departname: \"dev\", Alias: \"lunny3\", Created: time.Now()},\n\t}\n\tcnt, err := testEngine.Insert(&users)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, len(users), cnt)\n\n\tusers2 := []*MyUserinfo2{\n\t\t&MyUserinfo2{Username: \"1xlw\", Departname: \"dev\", Alias: \"lunny2\", Created: time.Now()},\n\t\t&MyUserinfo2{Username: \"1xlw2\", Departname: \"dev\", Alias: \"lunny3\", Created: time.Now()},\n\t\t&MyUserinfo2{Username: \"1xlw11\", Departname: \"dev\", Alias: \"lunny2\", Created: time.Now()},\n\t\t&MyUserinfo2{Username: \"1xlw22\", Departname: \"dev\", Alias: \"lunny3\", Created: time.Now()},\n\t}\n\n\tcnt, err = testEngine.Insert(&users2)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, len(users), cnt)\n}\n\nfunc TestAnonymousStruct(t *testing.T) {\n\ttype PlainObject struct {\n\t\tID   uint64 `json:\"id,string\" xorm:\"'ID' pk autoincr\"`\n\t\tDesc string `json:\"desc\" xorm:\"'DESC' notnull\"`\n\t}\n\n\ttype PlainFoo struct {\n\t\tPlainObject `xorm:\"extends\"` // primary key defined in extends struct\n\n\t\tWidth  uint32 `json:\"width\" xorm:\"'WIDTH' notnull\"`\n\t\tHeight uint32 `json:\"height\" xorm:\"'HEIGHT' notnull\"`\n\n\t\tExt struct {\n\t\t\tF1 uint32 `json:\"f1,omitempty\"`\n\t\t\tF2 uint32 `json:\"f2,omitempty\"`\n\t\t} `json:\"ext\" xorm:\"'EXT' json notnull\"`\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(PlainFoo))\n\n\t_, err := testEngine.Insert(&PlainFoo{\n\t\tPlainObject: PlainObject{\n\t\t\tDesc: \"test\",\n\t\t},\n\t\tWidth:  10,\n\t\tHeight: 20,\n\n\t\tExt: struct {\n\t\t\tF1 uint32 `json:\"f1,omitempty\"`\n\t\t\tF2 uint32 `json:\"f2,omitempty\"`\n\t\t}{\n\t\t\tF1: 11,\n\t\t\tF2: 12,\n\t\t},\n\t})\n\tassert.NoError(t, err)\n}\n\nfunc TestInsertMap(t *testing.T) {\n\ttype InsertMap struct {\n\t\tId     int64\n\t\tWidth  uint32\n\t\tHeight uint32\n\t\tName   string\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(InsertMap))\n\n\tcnt, err := testEngine.Table(new(InsertMap)).Insert(map[string]interface{}{\n\t\t\"width\":  20,\n\t\t\"height\": 10,\n\t\t\"name\":   \"lunny\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar im InsertMap\n\thas, err := testEngine.Get(&im)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 20, im.Width)\n\tassert.EqualValues(t, 10, im.Height)\n\tassert.EqualValues(t, \"lunny\", im.Name)\n\n\tcnt, err = testEngine.Table(\"insert_map\").Insert(map[string]interface{}{\n\t\t\"width\":  30,\n\t\t\"height\": 10,\n\t\t\"name\":   \"lunny\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar ims []InsertMap\n\terr = testEngine.Find(&ims)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, len(ims))\n\tassert.EqualValues(t, 20, ims[0].Width)\n\tassert.EqualValues(t, 10, ims[0].Height)\n\tassert.EqualValues(t, \"lunny\", ims[0].Name)\n\tassert.EqualValues(t, 30, ims[1].Width)\n\tassert.EqualValues(t, 10, ims[1].Height)\n\tassert.EqualValues(t, \"lunny\", ims[1].Name)\n\n\tcnt, err = testEngine.Table(\"insert_map\").Insert([]map[string]interface{}{\n\t\t{\n\t\t\t\"width\":  40,\n\t\t\t\"height\": 10,\n\t\t\t\"name\":   \"lunny\",\n\t\t},\n\t\t{\n\t\t\t\"width\":  50,\n\t\t\t\"height\": 10,\n\t\t\t\"name\":   \"lunny\",\n\t\t},\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, cnt)\n\n\tims = make([]InsertMap, 0, 4)\n\terr = testEngine.Find(&ims)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 4, len(ims))\n\tassert.EqualValues(t, 20, ims[0].Width)\n\tassert.EqualValues(t, 10, ims[0].Height)\n\tassert.EqualValues(t, \"lunny\", ims[1].Name)\n\tassert.EqualValues(t, 30, ims[1].Width)\n\tassert.EqualValues(t, 10, ims[1].Height)\n\tassert.EqualValues(t, \"lunny\", ims[1].Name)\n\tassert.EqualValues(t, 40, ims[2].Width)\n\tassert.EqualValues(t, 10, ims[2].Height)\n\tassert.EqualValues(t, \"lunny\", ims[2].Name)\n\tassert.EqualValues(t, 50, ims[3].Width)\n\tassert.EqualValues(t, 10, ims[3].Height)\n\tassert.EqualValues(t, \"lunny\", ims[3].Name)\n}\n\n/*INSERT INTO `issue` (`repo_id`, `poster_id`, ... ,`name`, `content`, ... ,`index`)\nSELECT $1, $2, ..., $14, $15, ..., MAX(`index`) + 1 FROM `issue` WHERE `repo_id` = $1;\n*/\nfunc TestInsertWhere(t *testing.T) {\n\ttype InsertWhere struct {\n\t\tId     int64\n\t\tIndex  int   `xorm:\"unique(s) notnull\"`\n\t\tRepoId int64 `xorm:\"unique(s)\"`\n\t\tWidth  uint32\n\t\tHeight uint32\n\t\tName   string\n\t\tIsTrue bool\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(InsertWhere))\n\n\tvar i = InsertWhere{\n\t\tRepoId: 1,\n\t\tWidth:  10,\n\t\tHeight: 20,\n\t\tName:   \"trest\",\n\t}\n\n\tinserted, err := testEngine.SetExpr(\"`index`\", \"coalesce(MAX(`index`),0)+1\").\n\t\tWhere(\"repo_id=?\", 1).\n\t\tInsert(&i)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, inserted)\n\tassert.EqualValues(t, 1, i.Id)\n\n\tvar j InsertWhere\n\thas, err := testEngine.ID(i.Id).Get(&j)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\ti.Index = 1\n\tassert.EqualValues(t, i, j)\n\n\tinserted, err = testEngine.Table(new(InsertWhere)).Where(\"repo_id=?\", 1).\n\t\tSetExpr(\"`index`\", \"coalesce(MAX(`index`),0)+1\").\n\t\tInsert(map[string]interface{}{\n\t\t\t\"repo_id\": 1,\n\t\t\t\"width\":   20,\n\t\t\t\"height\":  40,\n\t\t\t\"name\":    \"trest2\",\n\t\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, inserted)\n\n\tvar j2 InsertWhere\n\thas, err = testEngine.ID(2).Get(&j2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 1, j2.RepoId)\n\tassert.EqualValues(t, 20, j2.Width)\n\tassert.EqualValues(t, 40, j2.Height)\n\tassert.EqualValues(t, \"trest2\", j2.Name)\n\tassert.EqualValues(t, 2, j2.Index)\n\n\tinserted, err = testEngine.Table(new(InsertWhere)).Where(\"repo_id=?\", 1).\n\t\tSetExpr(\"`index`\", \"coalesce(MAX(`index`),0)+1\").\n\t\tSetExpr(\"repo_id\", \"1\").\n\t\tInsert(map[string]string{\n\t\t\t\"name\": \"trest3\",\n\t\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, inserted)\n\n\tvar j3 InsertWhere\n\thas, err = testEngine.ID(3).Get(&j3)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, \"trest3\", j3.Name)\n\tassert.EqualValues(t, 3, j3.Index)\n\n\tinserted, err = testEngine.Table(new(InsertWhere)).Where(\"repo_id=?\", 1).\n\t\tSetExpr(\"`index`\", \"coalesce(MAX(`index`),0)+1\").\n\t\tInsert(map[string]interface{}{\n\t\t\t\"repo_id\": 1,\n\t\t\t\"name\":    \"10';delete * from insert_where; --\",\n\t\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, inserted)\n\n\tvar j4 InsertWhere\n\thas, err = testEngine.ID(4).Get(&j4)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, \"10';delete * from insert_where; --\", j4.Name)\n\tassert.EqualValues(t, 4, j4.Index)\n\n\tinserted, err = testEngine.Table(new(InsertWhere)).Where(\"repo_id=?\", 1).\n\t\tSetExpr(\"`index`\", \"coalesce(MAX(`index`),0)+1\").\n\t\tInsert(map[string]interface{}{\n\t\t\t\"repo_id\": 1,\n\t\t\t\"name\":    \"10\\\\';delete * from insert_where; --\",\n\t\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, inserted)\n\n\tvar j5 InsertWhere\n\thas, err = testEngine.ID(5).Get(&j5)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, \"10\\\\';delete * from insert_where; --\", j5.Name)\n\tassert.EqualValues(t, 5, j5.Index)\n}\n\ntype NightlyRate struct {\n\tID int64 `xorm:\"'id' not null pk BIGINT(20)\" json:\"id\"`\n}\n\nfunc (NightlyRate) TableName() string {\n\treturn \"prd_nightly_rate\"\n}\n\nfunc TestMultipleInsertTableName(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttableName := `prd_nightly_rate_16`\n\tassert.NoError(t, testEngine.Table(tableName).Sync2(new(NightlyRate)))\n\n\ttrans := testEngine.NewSession()\n\tdefer trans.Close()\n\terr := trans.Begin()\n\tassert.NoError(t, err)\n\n\trtArr := []interface{}{\n\t\t[]*NightlyRate{\n\t\t\t{ID: 1},\n\t\t\t{ID: 2},\n\t\t},\n\t\t[]*NightlyRate{\n\t\t\t{ID: 3},\n\t\t\t{ID: 4},\n\t\t},\n\t\t[]*NightlyRate{\n\t\t\t{ID: 5},\n\t\t},\n\t}\n\n\t_, err = trans.Table(tableName).Insert(rtArr...)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, trans.Commit())\n}\n\nfunc TestInsertMultiWithOmit(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype TestMultiOmit struct {\n\t\tId      int64  `xorm:\"int(11) pk\"`\n\t\tName    string `xorm:\"varchar(255)\"`\n\t\tOmitted string `xorm:\"varchar(255) 'omitted'\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(TestMultiOmit)))\n\n\tl := []interface{}{\n\t\tTestMultiOmit{Id: 1, Name: \"1\", Omitted: \"1\"},\n\t\tTestMultiOmit{Id: 2, Name: \"1\", Omitted: \"2\"},\n\t\tTestMultiOmit{Id: 3, Name: \"1\", Omitted: \"3\"},\n\t}\n\n\tcheck := func() {\n\t\tvar ls []TestMultiOmit\n\t\terr := testEngine.Find(&ls)\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, 3, len(ls))\n\n\t\tfor e := range ls {\n\t\t\tassert.EqualValues(t, \"\", ls[e].Omitted)\n\t\t}\n\t}\n\n\tnum, err := testEngine.Omit(\"omitted\").Insert(l...)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 3, num)\n\tcheck()\n\n\tnum, err = testEngine.Delete(TestMultiOmit{Name: \"1\"})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 3, num)\n\n\tnum, err = testEngine.Omit(\"omitted\").Insert(l)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 3, num)\n\tcheck()\n}\n"
        },
        {
          "name": "session_iterate.go",
          "type": "blob",
          "size": 2.3056640625,
          "content": "// Copyright 2016 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport \"reflect\"\n\n// IterFunc only use by Iterate\ntype IterFunc func(idx int, bean interface{}) error\n\n// Rows return sql.Rows compatible Rows obj, as a forward Iterator object for iterating record by record, bean's non-empty fields\n// are conditions.\nfunc (session *Session) Rows(bean interface{}) (*Rows, error) {\n\treturn newRows(session, bean)\n}\n\n// Iterate record by record handle records from table, condiBeans's non-empty fields\n// are conditions. beans could be []Struct, []*Struct, map[int64]Struct\n// map[int64]*Struct\nfunc (session *Session) Iterate(bean interface{}, fun IterFunc) error {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\tif session.statement.lastError != nil {\n\t\treturn session.statement.lastError\n\t}\n\n\tif session.statement.bufferSize > 0 {\n\t\treturn session.bufferIterate(bean, fun)\n\t}\n\n\trows, err := session.Rows(bean)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer rows.Close()\n\n\ti := 0\n\tfor rows.Next() {\n\t\tb := reflect.New(rows.beanType).Interface()\n\t\terr = rows.Scan(b)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = fun(i, b)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ti++\n\t}\n\treturn err\n}\n\n// BufferSize sets the buffersize for iterate\nfunc (session *Session) BufferSize(size int) *Session {\n\tsession.statement.bufferSize = size\n\treturn session\n}\n\nfunc (session *Session) bufferIterate(bean interface{}, fun IterFunc) error {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\tvar bufferSize = session.statement.bufferSize\n\tvar limit = session.statement.LimitN\n\tif limit > 0 && bufferSize > limit {\n\t\tbufferSize = limit\n\t}\n\tvar start = session.statement.Start\n\tv := rValue(bean)\n\tsliceType := reflect.SliceOf(v.Type())\n\tvar idx = 0\n\tfor {\n\t\tslice := reflect.New(sliceType)\n\t\tif err := session.Limit(bufferSize, start).find(slice.Interface(), bean); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor i := 0; i < slice.Elem().Len(); i++ {\n\t\t\tif err := fun(idx, slice.Elem().Index(i).Addr().Interface()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tidx++\n\t\t}\n\n\t\tstart = start + slice.Elem().Len()\n\t\tif limit > 0 && idx+bufferSize > limit {\n\t\t\tbufferSize = limit - idx\n\t\t}\n\n\t\tif bufferSize <= 0 || slice.Elem().Len() < bufferSize || idx == limit {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "session_iterate_test.go",
          "type": "blob",
          "size": 2.1142578125,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestIterate(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UserIterate struct {\n\t\tId    int64\n\t\tIsMan bool\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(UserIterate)))\n\n\tcnt, err := testEngine.Insert(&UserIterate{\n\t\tIsMan: true,\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tcnt = 0\n\terr = testEngine.Iterate(new(UserIterate), func(i int, bean interface{}) error {\n\t\tuser := bean.(*UserIterate)\n\t\tassert.EqualValues(t, 1, user.Id)\n\t\tassert.EqualValues(t, true, user.IsMan)\n\t\tcnt++\n\t\treturn nil\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n}\n\nfunc TestBufferIterate(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UserBufferIterate struct {\n\t\tId    int64\n\t\tIsMan bool\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(UserBufferIterate)))\n\n\tvar size = 20\n\tfor i := 0; i < size; i++ {\n\t\tcnt, err := testEngine.Insert(&UserBufferIterate{\n\t\t\tIsMan: true,\n\t\t})\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, 1, cnt)\n\t}\n\n\tvar cnt = 0\n\terr := testEngine.BufferSize(9).Iterate(new(UserBufferIterate), func(i int, bean interface{}) error {\n\t\tuser := bean.(*UserBufferIterate)\n\t\tassert.EqualValues(t, cnt+1, user.Id)\n\t\tassert.EqualValues(t, true, user.IsMan)\n\t\tcnt++\n\t\treturn nil\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, size, cnt)\n\n\tcnt = 0\n\terr = testEngine.Limit(20).BufferSize(9).Iterate(new(UserBufferIterate), func(i int, bean interface{}) error {\n\t\tuser := bean.(*UserBufferIterate)\n\t\tassert.EqualValues(t, cnt+1, user.Id)\n\t\tassert.EqualValues(t, true, user.IsMan)\n\t\tcnt++\n\t\treturn nil\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, size, cnt)\n\n\tcnt = 0\n\terr = testEngine.Limit(7).BufferSize(9).Iterate(new(UserBufferIterate), func(i int, bean interface{}) error {\n\t\tuser := bean.(*UserBufferIterate)\n\t\tassert.EqualValues(t, cnt+1, user.Id)\n\t\tassert.EqualValues(t, true, user.IsMan)\n\t\tcnt++\n\t\treturn nil\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 7, cnt)\n}\n"
        },
        {
          "name": "session_pk_test.go",
          "type": "blob",
          "size": 21.7958984375,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n\n\t\"xorm.io/core\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype IntId struct {\n\tId   int `xorm:\"pk autoincr\"`\n\tName string\n}\n\ntype Int16Id struct {\n\tId   int16 `xorm:\"pk autoincr\"`\n\tName string\n}\n\ntype Int32Id struct {\n\tId   int32 `xorm:\"pk autoincr\"`\n\tName string\n}\n\ntype UintId struct {\n\tId   uint `xorm:\"pk autoincr\"`\n\tName string\n}\n\ntype Uint16Id struct {\n\tId   uint16 `xorm:\"pk autoincr\"`\n\tName string\n}\n\ntype Uint32Id struct {\n\tId   uint32 `xorm:\"pk autoincr\"`\n\tName string\n}\n\ntype Uint64Id struct {\n\tId   uint64 `xorm:\"pk autoincr\"`\n\tName string\n}\n\ntype StringPK struct {\n\tId   string `xorm:\"pk notnull\"`\n\tName string\n}\n\ntype ID int64\ntype MyIntPK struct {\n\tID   ID `xorm:\"pk autoincr\"`\n\tName string\n}\n\ntype StrID string\ntype MyStringPK struct {\n\tID   StrID `xorm:\"pk notnull\"`\n\tName string\n}\n\nfunc TestIntId(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&IntId{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(&IntId{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err := testEngine.Insert(&IntId{Name: \"test\"})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbean := new(IntId)\n\thas, err := testEngine.Get(bean)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif !has {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbeans := make([]IntId, 0)\n\terr = testEngine.Find(&beans)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans) != 1 {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbeans2 := make(map[int]IntId)\n\terr = testEngine.Find(&beans2)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans2) != 1 {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err = testEngine.ID(bean.Id).Delete(&IntId{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestInt16Id(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&Int16Id{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(&Int16Id{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err := testEngine.Insert(&Int16Id{Name: \"test\"})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbean := new(Int16Id)\n\thas, err := testEngine.Get(bean)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif !has {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbeans := make([]Int16Id, 0)\n\terr = testEngine.Find(&beans)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans) != 1 {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbeans2 := make(map[int16]Int16Id, 0)\n\terr = testEngine.Find(&beans2)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans2) != 1 {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err = testEngine.ID(bean.Id).Delete(&Int16Id{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestInt32Id(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&Int32Id{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(&Int32Id{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err := testEngine.Insert(&Int32Id{Name: \"test\"})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbean := new(Int32Id)\n\thas, err := testEngine.Get(bean)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif !has {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbeans := make([]Int32Id, 0)\n\terr = testEngine.Find(&beans)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans) != 1 {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbeans2 := make(map[int32]Int32Id, 0)\n\terr = testEngine.Find(&beans2)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans2) != 1 {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err = testEngine.ID(bean.Id).Delete(&Int32Id{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestUintId(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&UintId{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(&UintId{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err := testEngine.Insert(&UintId{Name: \"test\"})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tvar inserts = []UintId{\n\t\t{Name: \"test1\"},\n\t\t{Name: \"test2\"},\n\t}\n\tcnt, err = testEngine.Insert(&inserts)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif cnt != 2 {\n\t\terr = errors.New(\"insert count should be two\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbean := new(UintId)\n\thas, err := testEngine.Get(bean)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif !has {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbeans := make([]UintId, 0)\n\terr = testEngine.Find(&beans)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans) != 3 {\n\t\terr = errors.New(\"get count should be three\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbeans2 := make(map[uint]UintId, 0)\n\terr = testEngine.Find(&beans2)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans2) != 3 {\n\t\terr = errors.New(\"get count should be three\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err = testEngine.ID(bean.Id).Delete(&UintId{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestUint16Id(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&Uint16Id{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(&Uint16Id{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err := testEngine.Insert(&Uint16Id{Name: \"test\"})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbean := new(Uint16Id)\n\thas, err := testEngine.Get(bean)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif !has {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbeans := make([]Uint16Id, 0)\n\terr = testEngine.Find(&beans)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans) != 1 {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbeans2 := make(map[uint16]Uint16Id, 0)\n\terr = testEngine.Find(&beans2)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans2) != 1 {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err = testEngine.ID(bean.Id).Delete(&Uint16Id{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestUint32Id(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&Uint32Id{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(&Uint32Id{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err := testEngine.Insert(&Uint32Id{Name: \"test\"})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbean := new(Uint32Id)\n\thas, err := testEngine.Get(bean)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif !has {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbeans := make([]Uint32Id, 0)\n\terr = testEngine.Find(&beans)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans) != 1 {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbeans2 := make(map[uint32]Uint32Id, 0)\n\terr = testEngine.Find(&beans2)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans2) != 1 {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err = testEngine.ID(bean.Id).Delete(&Uint32Id{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestUint64Id(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&Uint64Id{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(&Uint64Id{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tidbean := &Uint64Id{Name: \"test\"}\n\tcnt, err := testEngine.Insert(idbean)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbean := new(Uint64Id)\n\thas, err := testEngine.Get(bean)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif !has {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif bean.Id != idbean.Id {\n\t\tpanic(errors.New(\"should be equal\"))\n\t}\n\n\tbeans := make([]Uint64Id, 0)\n\terr = testEngine.Find(&beans)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans) != 1 {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif *bean != beans[0] {\n\t\tpanic(errors.New(\"should be equal\"))\n\t}\n\n\tbeans2 := make(map[uint64]Uint64Id, 0)\n\terr = testEngine.Find(&beans2)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans2) != 1 {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif *bean != beans2[bean.Id] {\n\t\tpanic(errors.New(\"should be equal\"))\n\t}\n\n\tcnt, err = testEngine.ID(bean.Id).Delete(&Uint64Id{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestStringPK(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&StringPK{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(&StringPK{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err := testEngine.Insert(&StringPK{Id: \"1-1-2\", Name: \"test\"})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbean := new(StringPK)\n\thas, err := testEngine.Get(bean)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif !has {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbeans := make([]StringPK, 0)\n\terr = testEngine.Find(&beans)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans) != 1 {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbeans2 := make(map[string]StringPK)\n\terr = testEngine.Find(&beans2)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans2) != 1 {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err = testEngine.ID(bean.Id).Delete(&StringPK{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\ntype CompositeKey struct {\n\tId1       int64 `xorm:\"id1 pk\"`\n\tId2       int64 `xorm:\"id2 pk\"`\n\tUpdateStr string\n}\n\nfunc TestCompositeKey(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&CompositeKey{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(&CompositeKey{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err := testEngine.Insert(&CompositeKey{11, 22, \"\"})\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if cnt != 1 {\n\t\tt.Error(errors.New(\"failed to insert CompositeKey{11, 22}\"))\n\t}\n\n\tcnt, err = testEngine.Insert(&CompositeKey{11, 22, \"\"})\n\tif err == nil || cnt == 1 {\n\t\tt.Error(errors.New(\"inserted CompositeKey{11, 22}\"))\n\t}\n\n\tvar compositeKeyVal CompositeKey\n\thas, err := testEngine.ID(core.PK{11, 22}).Get(&compositeKeyVal)\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if !has {\n\t\tt.Error(errors.New(\"can't get CompositeKey{11, 22}\"))\n\t}\n\n\tvar compositeKeyVal2 CompositeKey\n\t// test passing PK ptr, this test seem failed withCache\n\thas, err = testEngine.ID(&core.PK{11, 22}).Get(&compositeKeyVal2)\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if !has {\n\t\tt.Error(errors.New(\"can't get CompositeKey{11, 22}\"))\n\t}\n\n\tif compositeKeyVal != compositeKeyVal2 {\n\t\tt.Error(errors.New(\"should be equal\"))\n\t}\n\n\tvar cps = make([]CompositeKey, 0)\n\terr = testEngine.Find(&cps)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif len(cps) != 1 {\n\t\tt.Error(errors.New(\"should has one record\"))\n\t}\n\tif cps[0] != compositeKeyVal {\n\t\tt.Error(errors.New(\"should be equal\"))\n\t}\n\n\tcnt, err = testEngine.Insert(&CompositeKey{22, 22, \"\"})\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if cnt != 1 {\n\t\tt.Error(errors.New(\"failed to insert CompositeKey{22, 22}\"))\n\t}\n\n\tcps = make([]CompositeKey, 0)\n\terr = testEngine.Find(&cps)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, len(cps), \"should has two record\")\n\tassert.EqualValues(t, compositeKeyVal, cps[0], \"should be equeal\")\n\n\tcompositeKeyVal = CompositeKey{UpdateStr: \"test1\"}\n\tcnt, err = testEngine.ID(core.PK{11, 22}).Update(&compositeKeyVal)\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if cnt != 1 {\n\t\tt.Error(errors.New(\"can't update CompositeKey{11, 22}\"))\n\t}\n\n\tcnt, err = testEngine.ID(core.PK{11, 22}).Delete(&CompositeKey{})\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if cnt != 1 {\n\t\tt.Error(errors.New(\"can't delete CompositeKey{11, 22}\"))\n\t}\n}\n\nfunc TestCompositeKey2(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype User struct {\n\t\tUserId   string `xorm:\"varchar(19) not null pk\"`\n\t\tNickName string `xorm:\"varchar(19) not null\"`\n\t\tGameId   uint32 `xorm:\"integer pk\"`\n\t\tScore    int32  `xorm:\"integer\"`\n\t}\n\n\terr := testEngine.DropTables(&User{})\n\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(&User{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err := testEngine.Insert(&User{\"11\", \"nick\", 22, 5})\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if cnt != 1 {\n\t\tt.Error(errors.New(\"failed to insert User{11, 22}\"))\n\t}\n\n\tcnt, err = testEngine.Insert(&User{\"11\", \"nick\", 22, 6})\n\tif err == nil || cnt == 1 {\n\t\tt.Error(errors.New(\"inserted User{11, 22}\"))\n\t}\n\n\tvar user User\n\thas, err := testEngine.ID(core.PK{\"11\", 22}).Get(&user)\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if !has {\n\t\tt.Error(errors.New(\"can't get User{11, 22}\"))\n\t}\n\n\t// test passing PK ptr, this test seem failed withCache\n\thas, err = testEngine.ID(&core.PK{\"11\", 22}).Get(&user)\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if !has {\n\t\tt.Error(errors.New(\"can't get User{11, 22}\"))\n\t}\n\n\tuser = User{NickName: \"test1\"}\n\tcnt, err = testEngine.ID(core.PK{\"11\", 22}).Update(&user)\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if cnt != 1 {\n\t\tt.Error(errors.New(\"can't update User{11, 22}\"))\n\t}\n\n\tcnt, err = testEngine.ID(core.PK{\"11\", 22}).Delete(&User{})\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if cnt != 1 {\n\t\tt.Error(errors.New(\"can't delete CompositeKey{11, 22}\"))\n\t}\n}\n\ntype MyString string\ntype UserPK2 struct {\n\tUserId   MyString `xorm:\"varchar(19) not null pk\"`\n\tNickName string   `xorm:\"varchar(19) not null\"`\n\tGameId   uint32   `xorm:\"integer pk\"`\n\tScore    int32    `xorm:\"integer\"`\n}\n\nfunc TestCompositeKey3(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&UserPK2{})\n\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(&UserPK2{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err := testEngine.Insert(&UserPK2{\"11\", \"nick\", 22, 5})\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if cnt != 1 {\n\t\tt.Error(errors.New(\"failed to insert User{11, 22}\"))\n\t}\n\n\tcnt, err = testEngine.Insert(&UserPK2{\"11\", \"nick\", 22, 6})\n\tif err == nil || cnt == 1 {\n\t\tt.Error(errors.New(\"inserted User{11, 22}\"))\n\t}\n\n\tvar user UserPK2\n\thas, err := testEngine.ID(core.PK{\"11\", 22}).Get(&user)\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if !has {\n\t\tt.Error(errors.New(\"can't get User{11, 22}\"))\n\t}\n\n\t// test passing PK ptr, this test seem failed withCache\n\thas, err = testEngine.ID(&core.PK{\"11\", 22}).Get(&user)\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if !has {\n\t\tt.Error(errors.New(\"can't get User{11, 22}\"))\n\t}\n\n\tuser = UserPK2{NickName: \"test1\"}\n\tcnt, err = testEngine.ID(core.PK{\"11\", 22}).Update(&user)\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if cnt != 1 {\n\t\tt.Error(errors.New(\"can't update User{11, 22}\"))\n\t}\n\n\tcnt, err = testEngine.ID(core.PK{\"11\", 22}).Delete(&UserPK2{})\n\tif err != nil {\n\t\tt.Error(err)\n\t} else if cnt != 1 {\n\t\tt.Error(errors.New(\"can't delete CompositeKey{11, 22}\"))\n\t}\n}\n\nfunc TestMyIntId(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&MyIntPK{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(&MyIntPK{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tidbean := &MyIntPK{Name: \"test\"}\n\tcnt, err := testEngine.Insert(idbean)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbean := new(MyIntPK)\n\thas, err := testEngine.Get(bean)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif !has {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif bean.ID != idbean.ID {\n\t\tpanic(errors.New(\"should be equal\"))\n\t}\n\n\tvar beans []MyIntPK\n\terr = testEngine.Find(&beans)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans) != 1 {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif *bean != beans[0] {\n\t\tpanic(errors.New(\"should be equal\"))\n\t}\n\n\tbeans2 := make(map[ID]MyIntPK, 0)\n\terr = testEngine.Find(&beans2)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans2) != 1 {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif *bean != beans2[bean.ID] {\n\t\tpanic(errors.New(\"should be equal\"))\n\t}\n\n\tcnt, err = testEngine.ID(bean.ID).Delete(&MyIntPK{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestMyStringId(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&MyStringPK{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(&MyStringPK{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tidbean := &MyStringPK{ID: \"1111\", Name: \"test\"}\n\tcnt, err := testEngine.Insert(idbean)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tbean := new(MyStringPK)\n\thas, err := testEngine.Get(bean)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif !has {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif bean.ID != idbean.ID {\n\t\tpanic(errors.New(\"should be equal\"))\n\t}\n\n\tvar beans []MyStringPK\n\terr = testEngine.Find(&beans)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans) != 1 {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif *bean != beans[0] {\n\t\tpanic(errors.New(\"should be equal\"))\n\t}\n\n\tbeans2 := make(map[StrID]MyStringPK, 0)\n\terr = testEngine.Find(&beans2)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif len(beans2) != 1 {\n\t\terr = errors.New(\"get count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif *bean != beans2[bean.ID] {\n\t\tpanic(errors.New(\"should be equal\"))\n\t}\n\n\tcnt, err = testEngine.ID(bean.ID).Delete(&MyStringPK{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif cnt != 1 {\n\t\terr = errors.New(\"insert count should be one\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestSingleAutoIncrColumn(t *testing.T) {\n\ttype Account struct {\n\t\tId int64 `xorm:\"pk autoincr\"`\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Account))\n\n\t_, err := testEngine.Insert(&Account{})\n\tassert.NoError(t, err)\n}\n\nfunc TestCompositePK(t *testing.T) {\n\ttype TaskSolution struct {\n\t\tUID     string    `xorm:\"notnull pk UUID 'uid'\"`\n\t\tTID     string    `xorm:\"notnull pk UUID 'tid'\"`\n\t\tCreated time.Time `xorm:\"created\"`\n\t\tUpdated time.Time `xorm:\"updated\"`\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\n\ttables1, err := testEngine.DBMetas()\n\tassert.NoError(t, err)\n\n\tassertSync(t, new(TaskSolution))\n\tassert.NoError(t, testEngine.Sync2(new(TaskSolution)))\n\n\ttables2, err := testEngine.DBMetas()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1+len(tables1), len(tables2))\n\n\tvar table *core.Table\n\tfor _, t := range tables2 {\n\t\tif t.Name == testEngine.GetTableMapper().Obj2Table(\"TaskSolution\") {\n\t\t\ttable = t\n\t\t\tbreak\n\t\t}\n\t}\n\n\tassert.NotEqual(t, nil, table)\n\n\tpkCols := table.PKColumns()\n\tassert.EqualValues(t, 2, len(pkCols))\n\tassert.EqualValues(t, \"uid\", pkCols[0].Name)\n\tassert.EqualValues(t, \"tid\", pkCols[1].Name)\n}\n\nfunc TestNoPKIdQueryUpdate(t *testing.T) {\n\ttype NoPKTable struct {\n\t\tUsername string\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(NoPKTable))\n\n\tcnt, err := testEngine.Insert(&NoPKTable{\n\t\tUsername: \"test\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar res NoPKTable\n\thas, err := testEngine.ID(\"test\").Get(&res)\n\tassert.Error(t, err)\n\tassert.False(t, has)\n\n\tcnt, err = testEngine.ID(\"test\").Update(&NoPKTable{\n\t\tUsername: \"test1\",\n\t})\n\tassert.Error(t, err)\n\tassert.EqualValues(t, 0, cnt)\n\n\ttype UnvalidPKTable struct {\n\t\tID       int `xorm:\"id\"`\n\t\tUsername string\n\t}\n\n\tassertSync(t, new(UnvalidPKTable))\n\n\tcnt, err = testEngine.Insert(&UnvalidPKTable{\n\t\tID:       1,\n\t\tUsername: \"test\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar res2 UnvalidPKTable\n\thas, err = testEngine.ID(1).Get(&res2)\n\tassert.Error(t, err)\n\tassert.False(t, has)\n\n\tcnt, err = testEngine.ID(1).Update(&UnvalidPKTable{\n\t\tUsername: \"test1\",\n\t})\n\tassert.Error(t, err)\n\tassert.EqualValues(t, 0, cnt)\n}\n"
        },
        {
          "name": "session_query.go",
          "type": "blob",
          "size": 7.935546875,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"xorm.io/builder\"\n\t\"xorm.io/core\"\n)\n\nfunc (session *Session) genQuerySQL(sqlOrArgs ...interface{}) (string, []interface{}, error) {\n\tif len(sqlOrArgs) > 0 {\n\t\treturn convertSQLOrArgs(sqlOrArgs...)\n\t}\n\n\tif session.statement.RawSQL != \"\" {\n\t\treturn session.statement.RawSQL, session.statement.RawParams, nil\n\t}\n\n\tif len(session.statement.TableName()) <= 0 {\n\t\treturn \"\", nil, ErrTableNotFound\n\t}\n\n\tvar columnStr = session.statement.ColumnStr\n\tif len(session.statement.selectStr) > 0 {\n\t\tcolumnStr = session.statement.selectStr\n\t} else {\n\t\tif session.statement.JoinStr == \"\" {\n\t\t\tif columnStr == \"\" {\n\t\t\t\tif session.statement.GroupByStr != \"\" {\n\t\t\t\t\tcolumnStr = session.engine.quoteColumns(session.statement.GroupByStr)\n\t\t\t\t} else {\n\t\t\t\t\tcolumnStr = session.statement.genColumnStr()\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif columnStr == \"\" {\n\t\t\t\tif session.statement.GroupByStr != \"\" {\n\t\t\t\t\tcolumnStr = session.engine.quoteColumns(session.statement.GroupByStr)\n\t\t\t\t} else {\n\t\t\t\t\tcolumnStr = \"*\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif columnStr == \"\" {\n\t\t\tcolumnStr = \"*\"\n\t\t}\n\t}\n\n\tif err := session.statement.processIDParam(); err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\tcondSQL, condArgs, err := builder.ToSQL(session.statement.cond)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\targs := append(session.statement.joinArgs, condArgs...)\n\tsqlStr, err := session.statement.genSelectSQL(columnStr, condSQL, true, true)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\t// for mssql and use limit\n\tqs := strings.Count(sqlStr, \"?\")\n\tif len(args)*2 == qs {\n\t\targs = append(args, args...)\n\t}\n\n\treturn sqlStr, args, nil\n}\n\n// Query runs a raw sql and return records as []map[string][]byte\nfunc (session *Session) Query(sqlOrArgs ...interface{}) ([]map[string][]byte, error) {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\tsqlStr, args, err := session.genQuerySQL(sqlOrArgs...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn session.queryBytes(sqlStr, args...)\n}\n\nfunc value2String(rawValue *reflect.Value) (str string, err error) {\n\taa := reflect.TypeOf((*rawValue).Interface())\n\tvv := reflect.ValueOf((*rawValue).Interface())\n\tswitch aa.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tstr = strconv.FormatInt(vv.Int(), 10)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tstr = strconv.FormatUint(vv.Uint(), 10)\n\tcase reflect.Float32, reflect.Float64:\n\t\tstr = strconv.FormatFloat(vv.Float(), 'f', -1, 64)\n\tcase reflect.String:\n\t\tstr = vv.String()\n\tcase reflect.Array, reflect.Slice:\n\t\tswitch aa.Elem().Kind() {\n\t\tcase reflect.Uint8:\n\t\t\tdata := rawValue.Interface().([]byte)\n\t\t\tstr = string(data)\n\t\t\tif str == \"\\x00\" {\n\t\t\t\tstr = \"0\"\n\t\t\t}\n\t\tdefault:\n\t\t\terr = fmt.Errorf(\"Unsupported struct type %v\", vv.Type().Name())\n\t\t}\n\t// time type\n\tcase reflect.Struct:\n\t\tif aa.ConvertibleTo(core.TimeType) {\n\t\t\tstr = vv.Convert(core.TimeType).Interface().(time.Time).Format(time.RFC3339Nano)\n\t\t} else {\n\t\t\terr = fmt.Errorf(\"Unsupported struct type %v\", vv.Type().Name())\n\t\t}\n\tcase reflect.Bool:\n\t\tstr = strconv.FormatBool(vv.Bool())\n\tcase reflect.Complex128, reflect.Complex64:\n\t\tstr = fmt.Sprintf(\"%v\", vv.Complex())\n\t/* TODO: unsupported types below\n\t   case reflect.Map:\n\t   case reflect.Ptr:\n\t   case reflect.Uintptr:\n\t   case reflect.UnsafePointer:\n\t   case reflect.Chan, reflect.Func, reflect.Interface:\n\t*/\n\tdefault:\n\t\terr = fmt.Errorf(\"Unsupported struct type %v\", vv.Type().Name())\n\t}\n\treturn\n}\n\nfunc row2mapStr(rows *core.Rows, fields []string) (resultsMap map[string]string, err error) {\n\tresult := make(map[string]string)\n\tscanResultContainers := make([]interface{}, len(fields))\n\tfor i := 0; i < len(fields); i++ {\n\t\tvar scanResultContainer interface{}\n\t\tscanResultContainers[i] = &scanResultContainer\n\t}\n\tif err := rows.Scan(scanResultContainers...); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor ii, key := range fields {\n\t\trawValue := reflect.Indirect(reflect.ValueOf(scanResultContainers[ii]))\n\t\t// if row is null then as empty string\n\t\tif rawValue.Interface() == nil {\n\t\t\tresult[key] = \"\"\n\t\t\tcontinue\n\t\t}\n\n\t\tif data, err := value2String(&rawValue); err == nil {\n\t\t\tresult[key] = data\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn result, nil\n}\n\nfunc row2sliceStr(rows *core.Rows, fields []string) (results []string, err error) {\n\tresult := make([]string, 0, len(fields))\n\tscanResultContainers := make([]interface{}, len(fields))\n\tfor i := 0; i < len(fields); i++ {\n\t\tvar scanResultContainer interface{}\n\t\tscanResultContainers[i] = &scanResultContainer\n\t}\n\tif err := rows.Scan(scanResultContainers...); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor i := 0; i < len(fields); i++ {\n\t\trawValue := reflect.Indirect(reflect.ValueOf(scanResultContainers[i]))\n\t\t// if row is null then as empty string\n\t\tif rawValue.Interface() == nil {\n\t\t\tresult = append(result, \"\")\n\t\t\tcontinue\n\t\t}\n\n\t\tif data, err := value2String(&rawValue); err == nil {\n\t\t\tresult = append(result, data)\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn result, nil\n}\n\nfunc rows2Strings(rows *core.Rows) (resultsSlice []map[string]string, err error) {\n\tfields, err := rows.Columns()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor rows.Next() {\n\t\tresult, err := row2mapStr(rows, fields)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresultsSlice = append(resultsSlice, result)\n\t}\n\n\treturn resultsSlice, nil\n}\n\nfunc rows2SliceString(rows *core.Rows) (resultsSlice [][]string, err error) {\n\tfields, err := rows.Columns()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor rows.Next() {\n\t\trecord, err := row2sliceStr(rows, fields)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresultsSlice = append(resultsSlice, record)\n\t}\n\n\treturn resultsSlice, nil\n}\n\n// QueryString runs a raw sql and return records as []map[string]string\nfunc (session *Session) QueryString(sqlOrArgs ...interface{}) ([]map[string]string, error) {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\tsqlStr, args, err := session.genQuerySQL(sqlOrArgs...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trows, err := session.queryRows(sqlStr, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\treturn rows2Strings(rows)\n}\n\n// QuerySliceString runs a raw sql and return records as [][]string\nfunc (session *Session) QuerySliceString(sqlOrArgs ...interface{}) ([][]string, error) {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\tsqlStr, args, err := session.genQuerySQL(sqlOrArgs...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trows, err := session.queryRows(sqlStr, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\treturn rows2SliceString(rows)\n}\n\nfunc row2mapInterface(rows *core.Rows, fields []string) (resultsMap map[string]interface{}, err error) {\n\tresultsMap = make(map[string]interface{}, len(fields))\n\tscanResultContainers := make([]interface{}, len(fields))\n\tfor i := 0; i < len(fields); i++ {\n\t\tvar scanResultContainer interface{}\n\t\tscanResultContainers[i] = &scanResultContainer\n\t}\n\tif err := rows.Scan(scanResultContainers...); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor ii, key := range fields {\n\t\tresultsMap[key] = reflect.Indirect(reflect.ValueOf(scanResultContainers[ii])).Interface()\n\t}\n\treturn\n}\n\nfunc rows2Interfaces(rows *core.Rows) (resultsSlice []map[string]interface{}, err error) {\n\tfields, err := rows.Columns()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor rows.Next() {\n\t\tresult, err := row2mapInterface(rows, fields)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresultsSlice = append(resultsSlice, result)\n\t}\n\n\treturn resultsSlice, nil\n}\n\n// QueryInterface runs a raw sql and return records as []map[string]interface{}\nfunc (session *Session) QueryInterface(sqlOrArgs ...interface{}) ([]map[string]interface{}, error) {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\tsqlStr, args, err := session.genQuerySQL(sqlOrArgs...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trows, err := session.queryRows(sqlStr, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\treturn rows2Interfaces(rows)\n}\n"
        },
        {
          "name": "session_query_test.go",
          "type": "blob",
          "size": 9.7099609375,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"xorm.io/builder\"\n\t\"xorm.io/core\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestQueryString(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype GetVar2 struct {\n\t\tId      int64  `xorm:\"autoincr pk\"`\n\t\tMsg     string `xorm:\"varchar(255)\"`\n\t\tAge     int\n\t\tMoney   float32\n\t\tCreated time.Time `xorm:\"created\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(GetVar2)))\n\n\tvar data = GetVar2{\n\t\tMsg:   \"hi\",\n\t\tAge:   28,\n\t\tMoney: 1.5,\n\t}\n\t_, err := testEngine.InsertOne(data)\n\tassert.NoError(t, err)\n\n\trecords, err := testEngine.QueryString(\"select * from \" + testEngine.TableName(\"get_var2\", true))\n\tassert.NoError(t, err)\n\tassert.Equal(t, 1, len(records))\n\tassert.Equal(t, 5, len(records[0]))\n\tassert.Equal(t, \"1\", records[0][\"id\"])\n\tassert.Equal(t, \"hi\", records[0][\"msg\"])\n\tassert.Equal(t, \"28\", records[0][\"age\"])\n\tassert.Equal(t, \"1.5\", records[0][\"money\"])\n}\n\nfunc TestQueryString2(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype GetVar3 struct {\n\t\tId  int64 `xorm:\"autoincr pk\"`\n\t\tMsg bool  `xorm:\"bit\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(GetVar3)))\n\n\tvar data = GetVar3{\n\t\tMsg: false,\n\t}\n\t_, err := testEngine.Insert(data)\n\tassert.NoError(t, err)\n\n\trecords, err := testEngine.QueryString(\"select * from \" + testEngine.TableName(\"get_var3\", true))\n\tassert.NoError(t, err)\n\tassert.Equal(t, 1, len(records))\n\tassert.Equal(t, 2, len(records[0]))\n\tassert.Equal(t, \"1\", records[0][\"id\"])\n\tassert.True(t, \"0\" == records[0][\"msg\"] || \"false\" == records[0][\"msg\"])\n}\n\nfunc toString(i interface{}) string {\n\tswitch i.(type) {\n\tcase []byte:\n\t\treturn string(i.([]byte))\n\tcase string:\n\t\treturn i.(string)\n\t}\n\treturn fmt.Sprintf(\"%v\", i)\n}\n\nfunc toInt64(i interface{}) int64 {\n\tswitch i.(type) {\n\tcase []byte:\n\t\tn, _ := strconv.ParseInt(string(i.([]byte)), 10, 64)\n\t\treturn n\n\tcase int:\n\t\treturn int64(i.(int))\n\tcase int64:\n\t\treturn i.(int64)\n\t}\n\treturn 0\n}\n\nfunc toFloat64(i interface{}) float64 {\n\tswitch i.(type) {\n\tcase []byte:\n\t\tn, _ := strconv.ParseFloat(string(i.([]byte)), 64)\n\t\treturn n\n\tcase float64:\n\t\treturn i.(float64)\n\tcase float32:\n\t\treturn float64(i.(float32))\n\t}\n\treturn 0\n}\n\nfunc TestQueryInterface(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype GetVarInterface struct {\n\t\tId      int64  `xorm:\"autoincr pk\"`\n\t\tMsg     string `xorm:\"varchar(255)\"`\n\t\tAge     int\n\t\tMoney   float32\n\t\tCreated time.Time `xorm:\"created\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(GetVarInterface)))\n\n\tvar data = GetVarInterface{\n\t\tMsg:   \"hi\",\n\t\tAge:   28,\n\t\tMoney: 1.5,\n\t}\n\t_, err := testEngine.InsertOne(data)\n\tassert.NoError(t, err)\n\n\trecords, err := testEngine.QueryInterface(\"select * from \" + testEngine.TableName(\"get_var_interface\", true))\n\tassert.NoError(t, err)\n\tassert.Equal(t, 1, len(records))\n\tassert.Equal(t, 5, len(records[0]))\n\tassert.EqualValues(t, 1, toInt64(records[0][\"id\"]))\n\tassert.Equal(t, \"hi\", toString(records[0][\"msg\"]))\n\tassert.EqualValues(t, 28, toInt64(records[0][\"age\"]))\n\tassert.EqualValues(t, 1.5, toFloat64(records[0][\"money\"]))\n}\n\nfunc TestQueryNoParams(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype QueryNoParams struct {\n\t\tId      int64  `xorm:\"autoincr pk\"`\n\t\tMsg     string `xorm:\"varchar(255)\"`\n\t\tAge     int\n\t\tMoney   float32\n\t\tCreated time.Time `xorm:\"created\"`\n\t}\n\n\ttestEngine.ShowSQL(true)\n\n\tassert.NoError(t, testEngine.Sync2(new(QueryNoParams)))\n\n\tvar q = QueryNoParams{\n\t\tMsg:   \"message\",\n\t\tAge:   20,\n\t\tMoney: 3000,\n\t}\n\tcnt, err := testEngine.Insert(&q)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tassertResult := func(t *testing.T, results []map[string][]byte) {\n\t\tassert.EqualValues(t, 1, len(results))\n\t\tid, err := strconv.ParseInt(string(results[0][\"id\"]), 10, 64)\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, 1, id)\n\t\tassert.Equal(t, \"message\", string(results[0][\"msg\"]))\n\n\t\tage, err := strconv.Atoi(string(results[0][\"age\"]))\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, 20, age)\n\n\t\tmoney, err := strconv.ParseFloat(string(results[0][\"money\"]), 32)\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, 3000, money)\n\t}\n\n\tresults, err := testEngine.Table(\"query_no_params\").Limit(10).Query()\n\tassert.NoError(t, err)\n\tassertResult(t, results)\n\n\tresults, err = testEngine.SQL(\"select * from \" + testEngine.TableName(\"query_no_params\", true)).Query()\n\tassert.NoError(t, err)\n\tassertResult(t, results)\n}\n\nfunc TestQueryStringNoParam(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype GetVar4 struct {\n\t\tId  int64 `xorm:\"autoincr pk\"`\n\t\tMsg bool  `xorm:\"bit\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(GetVar4)))\n\n\tvar data = GetVar4{\n\t\tMsg: false,\n\t}\n\t_, err := testEngine.Insert(data)\n\tassert.NoError(t, err)\n\n\trecords, err := testEngine.Table(\"get_var4\").Limit(1).QueryString()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(records))\n\tassert.EqualValues(t, \"1\", records[0][\"id\"])\n\tif testEngine.Dialect().DBType() == core.POSTGRES || testEngine.Dialect().DBType() == core.MSSQL {\n\t\tassert.EqualValues(t, \"false\", records[0][\"msg\"])\n\t} else {\n\t\tassert.EqualValues(t, \"0\", records[0][\"msg\"])\n\t}\n\n\trecords, err = testEngine.Table(\"get_var4\").Where(builder.Eq{\"id\": 1}).QueryString()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(records))\n\tassert.EqualValues(t, \"1\", records[0][\"id\"])\n\tif testEngine.Dialect().DBType() == core.POSTGRES || testEngine.Dialect().DBType() == core.MSSQL {\n\t\tassert.EqualValues(t, \"false\", records[0][\"msg\"])\n\t} else {\n\t\tassert.EqualValues(t, \"0\", records[0][\"msg\"])\n\t}\n}\n\nfunc TestQuerySliceStringNoParam(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype GetVar6 struct {\n\t\tId  int64 `xorm:\"autoincr pk\"`\n\t\tMsg bool  `xorm:\"bit\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(GetVar6)))\n\n\tvar data = GetVar6{\n\t\tMsg: false,\n\t}\n\t_, err := testEngine.Insert(data)\n\tassert.NoError(t, err)\n\n\trecords, err := testEngine.Table(\"get_var6\").Limit(1).QuerySliceString()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(records))\n\tassert.EqualValues(t, \"1\", records[0][0])\n\tif testEngine.Dialect().DBType() == core.POSTGRES || testEngine.Dialect().DBType() == core.MSSQL {\n\t\tassert.EqualValues(t, \"false\", records[0][1])\n\t} else {\n\t\tassert.EqualValues(t, \"0\", records[0][1])\n\t}\n\n\trecords, err = testEngine.Table(\"get_var6\").Where(builder.Eq{\"id\": 1}).QuerySliceString()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(records))\n\tassert.EqualValues(t, \"1\", records[0][0])\n\tif testEngine.Dialect().DBType() == core.POSTGRES || testEngine.Dialect().DBType() == core.MSSQL {\n\t\tassert.EqualValues(t, \"false\", records[0][1])\n\t} else {\n\t\tassert.EqualValues(t, \"0\", records[0][1])\n\t}\n}\n\nfunc TestQueryInterfaceNoParam(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype GetVar5 struct {\n\t\tId  int64 `xorm:\"autoincr pk\"`\n\t\tMsg bool  `xorm:\"bit\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(GetVar5)))\n\n\tvar data = GetVar5{\n\t\tMsg: false,\n\t}\n\t_, err := testEngine.Insert(data)\n\tassert.NoError(t, err)\n\n\trecords, err := testEngine.Table(\"get_var5\").Limit(1).QueryInterface()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(records))\n\tassert.EqualValues(t, 1, toInt64(records[0][\"id\"]))\n\tassert.EqualValues(t, 0, toInt64(records[0][\"msg\"]))\n\n\trecords, err = testEngine.Table(\"get_var5\").Where(builder.Eq{\"id\": 1}).QueryInterface()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(records))\n\tassert.EqualValues(t, 1, toInt64(records[0][\"id\"]))\n\tassert.EqualValues(t, 0, toInt64(records[0][\"msg\"]))\n}\n\nfunc TestQueryWithBuilder(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype QueryWithBuilder struct {\n\t\tId      int64  `xorm:\"autoincr pk\"`\n\t\tMsg     string `xorm:\"varchar(255)\"`\n\t\tAge     int\n\t\tMoney   float32\n\t\tCreated time.Time `xorm:\"created\"`\n\t}\n\n\ttestEngine.ShowSQL(true)\n\n\tassert.NoError(t, testEngine.Sync2(new(QueryWithBuilder)))\n\n\tvar q = QueryWithBuilder{\n\t\tMsg:   \"message\",\n\t\tAge:   20,\n\t\tMoney: 3000,\n\t}\n\tcnt, err := testEngine.Insert(&q)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tassertResult := func(t *testing.T, results []map[string][]byte) {\n\t\tassert.EqualValues(t, 1, len(results))\n\t\tid, err := strconv.ParseInt(string(results[0][\"id\"]), 10, 64)\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, 1, id)\n\t\tassert.Equal(t, \"message\", string(results[0][\"msg\"]))\n\n\t\tage, err := strconv.Atoi(string(results[0][\"age\"]))\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, 20, age)\n\n\t\tmoney, err := strconv.ParseFloat(string(results[0][\"money\"]), 32)\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, 3000, money)\n\t}\n\n\tresults, err := testEngine.Query(builder.Select(\"*\").From(testEngine.TableName(\"query_with_builder\", true)))\n\tassert.NoError(t, err)\n\tassertResult(t, results)\n}\n\nfunc TestJoinWithSubQuery(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype JoinWithSubQuery1 struct {\n\t\tId       int64  `xorm:\"autoincr pk\"`\n\t\tMsg      string `xorm:\"varchar(255)\"`\n\t\tDepartId int64\n\t\tMoney    float32\n\t}\n\n\ttype JoinWithSubQueryDepart struct {\n\t\tId   int64 `xorm:\"autoincr pk\"`\n\t\tName string\n\t}\n\n\ttestEngine.ShowSQL(true)\n\n\tassert.NoError(t, testEngine.Sync2(new(JoinWithSubQuery1), new(JoinWithSubQueryDepart)))\n\n\tvar depart = JoinWithSubQueryDepart{\n\t\tName: \"depart1\",\n\t}\n\tcnt, err := testEngine.Insert(&depart)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar q = JoinWithSubQuery1{\n\t\tMsg:      \"message\",\n\t\tDepartId: depart.Id,\n\t\tMoney:    3000,\n\t}\n\n\tcnt, err = testEngine.Insert(&q)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar querys []JoinWithSubQuery1\n\terr = testEngine.Join(\"INNER\", builder.Select(\"id\").From(testEngine.Quote(testEngine.TableName(\"join_with_sub_query_depart\", true))),\n\t\t\"join_with_sub_query_depart.id = join_with_sub_query1.depart_id\").Find(&querys)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(querys))\n\tassert.EqualValues(t, q, querys[0])\n}\n"
        },
        {
          "name": "session_raw.go",
          "type": "blob",
          "size": 5.3388671875,
          "content": "// Copyright 2016 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"database/sql\"\n\t\"reflect\"\n\t\"time\"\n\n\t\"xorm.io/builder\"\n\t\"xorm.io/core\"\n)\n\nfunc (session *Session) queryPreprocess(sqlStr *string, paramStr ...interface{}) {\n\tfor _, filter := range session.engine.dialect.Filters() {\n\t\t*sqlStr = filter.Do(*sqlStr, session.engine.dialect, session.statement.RefTable)\n\t}\n\n\tsession.lastSQL = *sqlStr\n\tsession.lastSQLArgs = paramStr\n}\n\nfunc (session *Session) queryRows(sqlStr string, args ...interface{}) (*core.Rows, error) {\n\tdefer session.resetStatement()\n\n\tsession.queryPreprocess(&sqlStr, args...)\n\n\tif session.engine.showSQL {\n\t\tif session.engine.showExecTime {\n\t\t\tb4ExecTime := time.Now()\n\t\t\tdefer func() {\n\t\t\t\texecDuration := time.Since(b4ExecTime)\n\t\t\t\tif len(args) > 0 {\n\t\t\t\t\tsession.engine.logger.Infof(\"[SQL] %s %#v - took: %v\", sqlStr, args, execDuration)\n\t\t\t\t} else {\n\t\t\t\t\tsession.engine.logger.Infof(\"[SQL] %s - took: %v\", sqlStr, execDuration)\n\t\t\t\t}\n\t\t\t}()\n\t\t} else {\n\t\t\tif len(args) > 0 {\n\t\t\t\tsession.engine.logger.Infof(\"[SQL] %v %#v\", sqlStr, args)\n\t\t\t} else {\n\t\t\t\tsession.engine.logger.Infof(\"[SQL] %v\", sqlStr)\n\t\t\t}\n\t\t}\n\t}\n\n\tif session.isAutoCommit {\n\t\tvar db *core.DB\n\t\tif session.sessionType == groupSession {\n\t\t\tdb = session.engine.engineGroup.Slave().DB()\n\t\t} else {\n\t\t\tdb = session.DB()\n\t\t}\n\n\t\tif session.prepareStmt {\n\t\t\t// don't clear stmt since session will cache them\n\t\t\tstmt, err := session.doPrepare(db, sqlStr)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\trows, err := stmt.QueryContext(session.ctx, args...)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn rows, nil\n\t\t}\n\n\t\trows, err := db.QueryContext(session.ctx, sqlStr, args...)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn rows, nil\n\t}\n\n\trows, err := session.tx.QueryContext(session.ctx, sqlStr, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn rows, nil\n}\n\nfunc (session *Session) queryRow(sqlStr string, args ...interface{}) *core.Row {\n\treturn core.NewRow(session.queryRows(sqlStr, args...))\n}\n\nfunc value2Bytes(rawValue *reflect.Value) ([]byte, error) {\n\tstr, err := value2String(rawValue)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn []byte(str), nil\n}\n\nfunc row2map(rows *core.Rows, fields []string) (resultsMap map[string][]byte, err error) {\n\tresult := make(map[string][]byte)\n\tscanResultContainers := make([]interface{}, len(fields))\n\tfor i := 0; i < len(fields); i++ {\n\t\tvar scanResultContainer interface{}\n\t\tscanResultContainers[i] = &scanResultContainer\n\t}\n\tif err := rows.Scan(scanResultContainers...); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor ii, key := range fields {\n\t\trawValue := reflect.Indirect(reflect.ValueOf(scanResultContainers[ii]))\n\t\t//if row is null then ignore\n\t\tif rawValue.Interface() == nil {\n\t\t\tresult[key] = []byte{}\n\t\t\tcontinue\n\t\t}\n\n\t\tif data, err := value2Bytes(&rawValue); err == nil {\n\t\t\tresult[key] = data\n\t\t} else {\n\t\t\treturn nil, err // !nashtsai! REVIEW, should return err or just error log?\n\t\t}\n\t}\n\treturn result, nil\n}\n\nfunc rows2maps(rows *core.Rows) (resultsSlice []map[string][]byte, err error) {\n\tfields, err := rows.Columns()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor rows.Next() {\n\t\tresult, err := row2map(rows, fields)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresultsSlice = append(resultsSlice, result)\n\t}\n\n\treturn resultsSlice, nil\n}\n\nfunc (session *Session) queryBytes(sqlStr string, args ...interface{}) ([]map[string][]byte, error) {\n\trows, err := session.queryRows(sqlStr, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\treturn rows2maps(rows)\n}\n\nfunc (session *Session) exec(sqlStr string, args ...interface{}) (sql.Result, error) {\n\tdefer session.resetStatement()\n\n\tsession.queryPreprocess(&sqlStr, args...)\n\n\tif session.engine.showSQL {\n\t\tif session.engine.showExecTime {\n\t\t\tb4ExecTime := time.Now()\n\t\t\tdefer func() {\n\t\t\t\texecDuration := time.Since(b4ExecTime)\n\t\t\t\tif len(args) > 0 {\n\t\t\t\t\tsession.engine.logger.Infof(\"[SQL] %s %#v - took: %v\", sqlStr, args, execDuration)\n\t\t\t\t} else {\n\t\t\t\t\tsession.engine.logger.Infof(\"[SQL] %s - took: %v\", sqlStr, execDuration)\n\t\t\t\t}\n\t\t\t}()\n\t\t} else {\n\t\t\tif len(args) > 0 {\n\t\t\t\tsession.engine.logger.Infof(\"[SQL] %v %#v\", sqlStr, args)\n\t\t\t} else {\n\t\t\t\tsession.engine.logger.Infof(\"[SQL] %v\", sqlStr)\n\t\t\t}\n\t\t}\n\t}\n\n\tif !session.isAutoCommit {\n\t\treturn session.tx.ExecContext(session.ctx, sqlStr, args...)\n\t}\n\n\tif session.prepareStmt {\n\t\tstmt, err := session.doPrepare(session.DB(), sqlStr)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres, err := stmt.ExecContext(session.ctx, args...)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn res, nil\n\t}\n\n\treturn session.DB().ExecContext(session.ctx, sqlStr, args...)\n}\n\nfunc convertSQLOrArgs(sqlOrArgs ...interface{}) (string, []interface{}, error) {\n\tswitch sqlOrArgs[0].(type) {\n\tcase string:\n\t\treturn sqlOrArgs[0].(string), sqlOrArgs[1:], nil\n\tcase *builder.Builder:\n\t\treturn sqlOrArgs[0].(*builder.Builder).ToSQL()\n\tcase builder.Builder:\n\t\tbd := sqlOrArgs[0].(builder.Builder)\n\t\treturn bd.ToSQL()\n\t}\n\n\treturn \"\", nil, ErrUnSupportedType\n}\n\n// Exec raw sql\nfunc (session *Session) Exec(sqlOrArgs ...interface{}) (sql.Result, error) {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\tif len(sqlOrArgs) == 0 {\n\t\treturn nil, ErrUnSupportedType\n\t}\n\n\tsqlStr, args, err := convertSQLOrArgs(sqlOrArgs...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn session.exec(sqlStr, args...)\n}\n"
        },
        {
          "name": "session_raw_test.go",
          "type": "blob",
          "size": 0.984375,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestExecAndQuery(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UserinfoQuery struct {\n\t\tUid  int\n\t\tName string\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(UserinfoQuery)))\n\n\tres, err := testEngine.Exec(\"INSERT INTO \"+testEngine.TableName(\"`userinfo_query`\", true)+\" (uid, name) VALUES (?, ?)\", 1, \"user\")\n\tassert.NoError(t, err)\n\tcnt, err := res.RowsAffected()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tresults, err := testEngine.Query(\"select * from \" + testEngine.TableName(\"userinfo_query\", true))\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(results))\n\tid, err := strconv.Atoi(string(results[0][\"uid\"]))\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, id)\n\tassert.Equal(t, \"user\", string(results[0][\"name\"]))\n}\n"
        },
        {
          "name": "session_schema.go",
          "type": "blob",
          "size": 11.16796875,
          "content": "// Copyright 2016 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"xorm.io/core\"\n)\n\n// Ping test if database is ok\nfunc (session *Session) Ping() error {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\tsession.engine.logger.Infof(\"PING DATABASE %v\", session.engine.DriverName())\n\treturn session.DB().PingContext(session.ctx)\n}\n\n// CreateTable create a table according a bean\nfunc (session *Session) CreateTable(bean interface{}) error {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\treturn session.createTable(bean)\n}\n\nfunc (session *Session) createTable(bean interface{}) error {\n\tif err := session.statement.setRefBean(bean); err != nil {\n\t\treturn err\n\t}\n\n\tsqlStr := session.statement.genCreateTableSQL()\n\t_, err := session.exec(sqlStr)\n\treturn err\n}\n\n// CreateIndexes create indexes\nfunc (session *Session) CreateIndexes(bean interface{}) error {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\treturn session.createIndexes(bean)\n}\n\nfunc (session *Session) createIndexes(bean interface{}) error {\n\tif err := session.statement.setRefBean(bean); err != nil {\n\t\treturn err\n\t}\n\n\tsqls := session.statement.genIndexSQL()\n\tfor _, sqlStr := range sqls {\n\t\t_, err := session.exec(sqlStr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// CreateUniques create uniques\nfunc (session *Session) CreateUniques(bean interface{}) error {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\treturn session.createUniques(bean)\n}\n\nfunc (session *Session) createUniques(bean interface{}) error {\n\tif err := session.statement.setRefBean(bean); err != nil {\n\t\treturn err\n\t}\n\n\tsqls := session.statement.genUniqueSQL()\n\tfor _, sqlStr := range sqls {\n\t\t_, err := session.exec(sqlStr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// DropIndexes drop indexes\nfunc (session *Session) DropIndexes(bean interface{}) error {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\treturn session.dropIndexes(bean)\n}\n\nfunc (session *Session) dropIndexes(bean interface{}) error {\n\tif err := session.statement.setRefBean(bean); err != nil {\n\t\treturn err\n\t}\n\n\tsqls := session.statement.genDelIndexSQL()\n\tfor _, sqlStr := range sqls {\n\t\t_, err := session.exec(sqlStr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// DropTable drop table will drop table if exist, if drop failed, it will return error\nfunc (session *Session) DropTable(beanOrTableName interface{}) error {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\treturn session.dropTable(beanOrTableName)\n}\n\nfunc (session *Session) dropTable(beanOrTableName interface{}) error {\n\ttableName := session.engine.TableName(beanOrTableName)\n\tvar needDrop = true\n\tif !session.engine.dialect.SupportDropIfExists() {\n\t\tsqlStr, args := session.engine.dialect.TableCheckSql(tableName)\n\t\tresults, err := session.queryBytes(sqlStr, args...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tneedDrop = len(results) > 0\n\t}\n\n\tif needDrop {\n\t\tsqlStr := session.engine.Dialect().DropTableSql(session.engine.TableName(tableName, true))\n\t\t_, err := session.exec(sqlStr)\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// IsTableExist if a table is exist\nfunc (session *Session) IsTableExist(beanOrTableName interface{}) (bool, error) {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\ttableName := session.engine.TableName(beanOrTableName)\n\n\treturn session.isTableExist(tableName)\n}\n\nfunc (session *Session) isTableExist(tableName string) (bool, error) {\n\tsqlStr, args := session.engine.dialect.TableCheckSql(tableName)\n\tresults, err := session.queryBytes(sqlStr, args...)\n\treturn len(results) > 0, err\n}\n\n// IsTableEmpty if table have any records\nfunc (session *Session) IsTableEmpty(bean interface{}) (bool, error) {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\treturn session.isTableEmpty(session.engine.TableName(bean))\n}\n\nfunc (session *Session) isTableEmpty(tableName string) (bool, error) {\n\tvar total int64\n\tsqlStr := fmt.Sprintf(\"select count(*) from %s\", session.engine.Quote(session.engine.TableName(tableName, true)))\n\terr := session.queryRow(sqlStr).Scan(&total)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\terr = nil\n\t\t}\n\t\treturn true, err\n\t}\n\n\treturn total == 0, nil\n}\n\n// find if index is exist according cols\nfunc (session *Session) isIndexExist2(tableName string, cols []string, unique bool) (bool, error) {\n\tindexes, err := session.engine.dialect.GetIndexes(tableName)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tfor _, index := range indexes {\n\t\tif sliceEq(index.Cols, cols) {\n\t\t\tif unique {\n\t\t\t\treturn index.Type == core.UniqueType, nil\n\t\t\t}\n\t\t\treturn index.Type == core.IndexType, nil\n\t\t}\n\t}\n\treturn false, nil\n}\n\nfunc (session *Session) addColumn(colName string) error {\n\tcol := session.statement.RefTable.GetColumn(colName)\n\tsql, args := session.statement.genAddColumnStr(col)\n\t_, err := session.exec(sql, args...)\n\treturn err\n}\n\nfunc (session *Session) addIndex(tableName, idxName string) error {\n\tindex := session.statement.RefTable.Indexes[idxName]\n\tsqlStr := session.engine.dialect.CreateIndexSql(tableName, index)\n\t_, err := session.exec(sqlStr)\n\treturn err\n}\n\nfunc (session *Session) addUnique(tableName, uqeName string) error {\n\tindex := session.statement.RefTable.Indexes[uqeName]\n\tsqlStr := session.engine.dialect.CreateIndexSql(tableName, index)\n\t_, err := session.exec(sqlStr)\n\treturn err\n}\n\n// Sync2 synchronize structs to database tables\nfunc (session *Session) Sync2(beans ...interface{}) error {\n\tengine := session.engine\n\n\tif session.isAutoClose {\n\t\tsession.isAutoClose = false\n\t\tdefer session.Close()\n\t}\n\n\ttables, err := engine.dialect.GetTables()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsession.autoResetStatement = false\n\tdefer func() {\n\t\tsession.autoResetStatement = true\n\t\tsession.resetStatement()\n\t}()\n\n\tfor _, bean := range beans {\n\t\tv := rValue(bean)\n\t\ttable, err := engine.mapType(v)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar tbName string\n\t\tif len(session.statement.AltTableName) > 0 {\n\t\t\ttbName = session.statement.AltTableName\n\t\t} else {\n\t\t\ttbName = engine.TableName(bean)\n\t\t}\n\t\ttbNameWithSchema := engine.tbNameWithSchema(tbName)\n\n\t\tvar oriTable *core.Table\n\t\tfor _, tb := range tables {\n\t\t\tif strings.EqualFold(engine.tbNameWithSchema(tb.Name), engine.tbNameWithSchema(tbName)) {\n\t\t\t\toriTable = tb\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// this is a new table\n\t\tif oriTable == nil {\n\t\t\terr = session.StoreEngine(session.statement.StoreEngine).createTable(bean)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\terr = session.createUniques(bean)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\terr = session.createIndexes(bean)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// this will modify an old table\n\t\tif err = engine.loadTableInfo(oriTable); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// check columns\n\t\tfor _, col := range table.Columns() {\n\t\t\tvar oriCol *core.Column\n\t\t\tfor _, col2 := range oriTable.Columns() {\n\t\t\t\tif strings.EqualFold(col.Name, col2.Name) {\n\t\t\t\t\toriCol = col2\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// column is not exist on table\n\t\t\tif oriCol == nil {\n\t\t\t\tsession.statement.RefTable = table\n\t\t\t\tsession.statement.tableName = tbNameWithSchema\n\t\t\t\tif err = session.addColumn(col.Name); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\terr = nil\n\t\t\texpectedType := engine.dialect.SqlType(col)\n\t\t\tcurType := engine.dialect.SqlType(oriCol)\n\t\t\tif expectedType != curType {\n\t\t\t\tif expectedType == core.Text &&\n\t\t\t\t\tstrings.HasPrefix(curType, core.Varchar) {\n\t\t\t\t\t// currently only support mysql & postgres\n\t\t\t\t\tif engine.dialect.DBType() == core.MYSQL ||\n\t\t\t\t\t\tengine.dialect.DBType() == core.POSTGRES {\n\t\t\t\t\t\tengine.logger.Infof(\"Table %s column %s change type from %s to %s\\n\",\n\t\t\t\t\t\t\ttbNameWithSchema, col.Name, curType, expectedType)\n\t\t\t\t\t\t_, err = session.exec(engine.dialect.ModifyColumnSql(tbNameWithSchema, col))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tengine.logger.Warnf(\"Table %s column %s db type is %s, struct type is %s\\n\",\n\t\t\t\t\t\t\ttbNameWithSchema, col.Name, curType, expectedType)\n\t\t\t\t\t}\n\t\t\t\t} else if strings.HasPrefix(curType, core.Varchar) && strings.HasPrefix(expectedType, core.Varchar) {\n\t\t\t\t\tif engine.dialect.DBType() == core.MYSQL {\n\t\t\t\t\t\tif oriCol.Length < col.Length {\n\t\t\t\t\t\t\tengine.logger.Infof(\"Table %s column %s change type from varchar(%d) to varchar(%d)\\n\",\n\t\t\t\t\t\t\t\ttbNameWithSchema, col.Name, oriCol.Length, col.Length)\n\t\t\t\t\t\t\t_, err = session.exec(engine.dialect.ModifyColumnSql(tbNameWithSchema, col))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif !(strings.HasPrefix(curType, expectedType) && curType[len(expectedType)] == '(') {\n\t\t\t\t\t\tengine.logger.Warnf(\"Table %s column %s db type is %s, struct type is %s\",\n\t\t\t\t\t\t\ttbNameWithSchema, col.Name, curType, expectedType)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if expectedType == core.Varchar {\n\t\t\t\tif engine.dialect.DBType() == core.MYSQL {\n\t\t\t\t\tif oriCol.Length < col.Length {\n\t\t\t\t\t\tengine.logger.Infof(\"Table %s column %s change type from varchar(%d) to varchar(%d)\\n\",\n\t\t\t\t\t\t\ttbNameWithSchema, col.Name, oriCol.Length, col.Length)\n\t\t\t\t\t\t_, err = session.exec(engine.dialect.ModifyColumnSql(tbNameWithSchema, col))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif col.Default != oriCol.Default {\n\t\t\t\tif (col.SQLType.Name == core.Bool || col.SQLType.Name == core.Boolean) &&\n\t\t\t\t\t((strings.EqualFold(col.Default, \"true\") && oriCol.Default == \"1\") ||\n\t\t\t\t\t\t(strings.EqualFold(col.Default, \"false\") && oriCol.Default == \"0\")) {\n\t\t\t\t} else {\n\t\t\t\t\tengine.logger.Warnf(\"Table %s Column %s db default is %s, struct default is %s\",\n\t\t\t\t\t\ttbName, col.Name, oriCol.Default, col.Default)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif col.Nullable != oriCol.Nullable {\n\t\t\t\tengine.logger.Warnf(\"Table %s Column %s db nullable is %v, struct nullable is %v\",\n\t\t\t\t\ttbName, col.Name, oriCol.Nullable, col.Nullable)\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tvar foundIndexNames = make(map[string]bool)\n\t\tvar addedNames = make(map[string]*core.Index)\n\n\t\tfor name, index := range table.Indexes {\n\t\t\tvar oriIndex *core.Index\n\t\t\tfor name2, index2 := range oriTable.Indexes {\n\t\t\t\tif index.Equal(index2) {\n\t\t\t\t\toriIndex = index2\n\t\t\t\t\tfoundIndexNames[name2] = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif oriIndex != nil {\n\t\t\t\tif oriIndex.Type != index.Type {\n\t\t\t\t\tsql := engine.dialect.DropIndexSql(tbNameWithSchema, oriIndex)\n\t\t\t\t\t_, err = session.exec(sql)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\toriIndex = nil\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif oriIndex == nil {\n\t\t\t\taddedNames[name] = index\n\t\t\t}\n\t\t}\n\n\t\tfor name2, index2 := range oriTable.Indexes {\n\t\t\tif _, ok := foundIndexNames[name2]; !ok {\n\t\t\t\tsql := engine.dialect.DropIndexSql(tbNameWithSchema, index2)\n\t\t\t\t_, err = session.exec(sql)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor name, index := range addedNames {\n\t\t\tif index.Type == core.UniqueType {\n\t\t\t\tsession.statement.RefTable = table\n\t\t\t\tsession.statement.tableName = tbNameWithSchema\n\t\t\t\terr = session.addUnique(tbNameWithSchema, name)\n\t\t\t} else if index.Type == core.IndexType {\n\t\t\t\tsession.statement.RefTable = table\n\t\t\t\tsession.statement.tableName = tbNameWithSchema\n\t\t\t\terr = session.addIndex(tbNameWithSchema, name)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t// check all the columns which removed from struct fields but left on database tables.\n\t\tfor _, colName := range oriTable.ColumnsSeq() {\n\t\t\tif table.GetColumn(colName) == nil {\n\t\t\t\tengine.logger.Warnf(\"Table %s has column %s but struct has not related field\", engine.TableName(oriTable.Name, true), colName)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "session_schema_test.go",
          "type": "blob",
          "size": 8.361328125,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestStoreEngine(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tassert.NoError(t, testEngine.DropTables(\"user_store_engine\"))\n\n\ttype UserinfoStoreEngine struct {\n\t\tId   int64\n\t\tName string\n\t}\n\n\tassert.NoError(t, testEngine.StoreEngine(\"InnoDB\").Table(\"user_store_engine\").CreateTable(&UserinfoStoreEngine{}))\n}\n\nfunc TestCreateTable(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tassert.NoError(t, testEngine.DropTables(\"user_user\"))\n\n\ttype UserinfoCreateTable struct {\n\t\tId   int64\n\t\tName string\n\t}\n\n\tassert.NoError(t, testEngine.Table(\"user_user\").CreateTable(&UserinfoCreateTable{}))\n}\n\nfunc TestCreateMultiTables(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tsession := testEngine.NewSession()\n\tdefer session.Close()\n\n\ttype UserinfoMultiTable struct {\n\t\tId   int64\n\t\tName string\n\t}\n\n\tuser := &UserinfoMultiTable{}\n\tassert.NoError(t, session.Begin())\n\n\tfor i := 0; i < 10; i++ {\n\t\ttableName := fmt.Sprintf(\"user_%v\", i)\n\n\t\tassert.NoError(t, session.DropTable(tableName))\n\n\t\tassert.NoError(t, session.Table(tableName).CreateTable(user))\n\t}\n\n\tassert.NoError(t, session.Commit())\n}\n\ntype SyncTable1 struct {\n\tId   int64\n\tName string\n\tDev  int `xorm:\"index\"`\n}\n\ntype SyncTable2 struct {\n\tId     int64\n\tName   string `xorm:\"unique\"`\n\tNumber string `xorm:\"index\"`\n\tDev    int\n\tAge    int\n}\n\nfunc (SyncTable2) TableName() string {\n\treturn \"sync_table1\"\n}\n\ntype SyncTable3 struct {\n\tId     int64\n\tName   string `xorm:\"unique\"`\n\tNumber string `xorm:\"index\"`\n\tDev    int\n\tAge    int\n}\n\nfunc (s *SyncTable3) TableName() string {\n\treturn \"sync_table1\"\n}\n\nfunc TestSyncTable(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tassert.NoError(t, testEngine.Sync2(new(SyncTable1)))\n\n\ttables, err := testEngine.DBMetas()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(tables))\n\tassert.EqualValues(t, \"sync_table1\", tables[0].Name)\n\n\tassert.NoError(t, testEngine.Sync2(new(SyncTable2)))\n\n\ttables, err = testEngine.DBMetas()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(tables))\n\tassert.EqualValues(t, \"sync_table1\", tables[0].Name)\n\n\tassert.NoError(t, testEngine.Sync2(new(SyncTable3)))\n\n\ttables, err = testEngine.DBMetas()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(tables))\n\tassert.EqualValues(t, \"sync_table1\", tables[0].Name)\n}\n\nfunc TestSyncTable2(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tassert.NoError(t, testEngine.Table(\"sync_tablex\").Sync2(new(SyncTable1)))\n\n\ttables, err := testEngine.DBMetas()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(tables))\n\tassert.EqualValues(t, \"sync_tablex\", tables[0].Name)\n\tassert.EqualValues(t, 3, len(tables[0].Columns()))\n\n\ttype SyncTable4 struct {\n\t\tSyncTable1 `xorm:\"extends\"`\n\t\tNewCol     string\n\t}\n\n\tassert.NoError(t, testEngine.Table(\"sync_tablex\").Sync2(new(SyncTable4)))\n\ttables, err = testEngine.DBMetas()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(tables))\n\tassert.EqualValues(t, \"sync_tablex\", tables[0].Name)\n\tassert.EqualValues(t, 4, len(tables[0].Columns()))\n\tassert.EqualValues(t, colMapper.Obj2Table(\"NewCol\"), tables[0].Columns()[3].Name)\n}\n\nfunc TestIsTableExist(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\texist, err := testEngine.IsTableExist(new(CustomTableName))\n\tassert.NoError(t, err)\n\tassert.False(t, exist)\n\n\tassert.NoError(t, testEngine.CreateTables(new(CustomTableName)))\n\n\texist, err = testEngine.IsTableExist(new(CustomTableName))\n\tassert.NoError(t, err)\n\tassert.True(t, exist)\n}\n\nfunc TestIsTableEmpty(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype NumericEmpty struct {\n\t\tNumeric float64 `xorm:\"numeric(26,2)\"`\n\t}\n\n\ttype PictureEmpty struct {\n\t\tId          int64\n\t\tUrl         string `xorm:\"unique\"` //image's url\n\t\tTitle       string\n\t\tDescription string\n\t\tCreated     time.Time `xorm:\"created\"`\n\t\tILike       int\n\t\tPageView    int\n\t\tFrom_url    string\n\t\tPre_url     string `xorm:\"unique\"` //pre view image's url\n\t\tUid         int64\n\t}\n\n\tassert.NoError(t, testEngine.DropTables(&PictureEmpty{}, &NumericEmpty{}))\n\n\tassert.NoError(t, testEngine.Sync2(new(PictureEmpty), new(NumericEmpty)))\n\n\tisEmpty, err := testEngine.IsTableEmpty(&PictureEmpty{})\n\tassert.NoError(t, err)\n\tassert.True(t, isEmpty)\n\n\ttbName := testEngine.GetTableMapper().Obj2Table(\"PictureEmpty\")\n\tisEmpty, err = testEngine.IsTableEmpty(tbName)\n\tassert.NoError(t, err)\n\tassert.True(t, isEmpty)\n}\n\ntype CustomTableName struct {\n\tId   int64\n\tName string\n}\n\nfunc (c *CustomTableName) TableName() string {\n\treturn \"customtablename\"\n}\n\nfunc TestCustomTableName(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tc := new(CustomTableName)\n\tassert.NoError(t, testEngine.DropTables(c))\n\n\tassert.NoError(t, testEngine.CreateTables(c))\n}\n\nfunc TestDump(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tfp := testEngine.Dialect().URI().DbName + \".sql\"\n\tos.Remove(fp)\n\tassert.NoError(t, testEngine.DumpAllToFile(fp))\n}\n\ntype IndexOrUnique struct {\n\tId        int64\n\tIndex     int `xorm:\"index\"`\n\tUnique    int `xorm:\"unique\"`\n\tGroup1    int `xorm:\"index(ttt)\"`\n\tGroup2    int `xorm:\"index(ttt)\"`\n\tUniGroup1 int `xorm:\"unique(lll)\"`\n\tUniGroup2 int `xorm:\"unique(lll)\"`\n}\n\nfunc TestIndexAndUnique(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tassert.NoError(t, testEngine.CreateTables(&IndexOrUnique{}))\n\n\tassert.NoError(t, testEngine.DropTables(&IndexOrUnique{}))\n\n\tassert.NoError(t, testEngine.CreateTables(&IndexOrUnique{}))\n\n\tassert.NoError(t, testEngine.CreateIndexes(&IndexOrUnique{}))\n\n\tassert.NoError(t, testEngine.CreateUniques(&IndexOrUnique{}))\n\n\tassert.NoError(t, testEngine.DropIndexes(&IndexOrUnique{}))\n}\n\nfunc TestMetaInfo(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassert.NoError(t, testEngine.Sync2(new(CustomTableName), new(IndexOrUnique)))\n\n\ttables, err := testEngine.DBMetas()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, len(tables))\n\ttableNames := []string{tables[0].Name, tables[1].Name}\n\tassert.Contains(t, tableNames, \"customtablename\")\n\tassert.Contains(t, tableNames, \"index_or_unique\")\n}\n\nfunc TestCharst(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(\"user_charset\")\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.Charset(\"utf8\").Table(\"user_charset\").CreateTable(&Userinfo{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestSync2_1(t *testing.T) {\n\ttype WxTest struct {\n\t\tId                 int   `xorm:\"not null pk autoincr INT(64)`\n\t\tPassport_user_type int16 `xorm:\"null int\"`\n\t\tId_delete          int8  `xorm:\"null int default 1\"`\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\n\tassert.NoError(t, testEngine.DropTables(\"wx_test\"))\n\tassert.NoError(t, testEngine.Sync2(new(WxTest)))\n\tassert.NoError(t, testEngine.Sync2(new(WxTest)))\n}\n\nfunc TestUnique_1(t *testing.T) {\n\ttype UserUnique struct {\n\t\tId        int64\n\t\tUserName  string    `xorm:\"unique varchar(25) not null\"`\n\t\tPassword  string    `xorm:\"varchar(255) not null\"`\n\t\tAdmin     bool      `xorm:\"not null\"`\n\t\tCreatedAt time.Time `xorm:\"created\"`\n\t\tUpdatedAt time.Time `xorm:\"updated\"`\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\n\tassert.NoError(t, testEngine.DropTables(\"user_unique\"))\n\tassert.NoError(t, testEngine.Sync2(new(UserUnique)))\n\n\tassert.NoError(t, testEngine.DropTables(\"user_unique\"))\n\tassert.NoError(t, testEngine.CreateTables(new(UserUnique)))\n\tassert.NoError(t, testEngine.CreateUniques(new(UserUnique)))\n}\n\nfunc TestSync2_2(t *testing.T) {\n\ttype TestSync2Index struct {\n\t\tId     int64\n\t\tUserId int64 `xorm:\"index\"`\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\n\tvar tableNames = make(map[string]bool)\n\tfor i := 0; i < 10; i++ {\n\t\ttableName := fmt.Sprintf(\"test_sync2_index_%d\", i)\n\t\ttableNames[tableName] = true\n\t\tassert.NoError(t, testEngine.Table(tableName).Sync2(new(TestSync2Index)))\n\n\t\texist, err := testEngine.IsTableExist(tableName)\n\t\tassert.NoError(t, err)\n\t\tassert.True(t, exist)\n\t}\n\n\ttables, err := testEngine.DBMetas()\n\tassert.NoError(t, err)\n\n\tfor _, table := range tables {\n\t\tassert.True(t, tableNames[table.Name])\n\t}\n}\n\nfunc TestSync2_Default(t *testing.T) {\n\ttype TestSync2Default struct {\n\t\tId       int64\n\t\tUserId   int64  `xorm:\"default(1)\"`\n\t\tIsMember bool   `xorm:\"default(true)\"`\n\t\tName     string `xorm:\"default('my_name')\"`\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(TestSync2Default))\n\tassert.NoError(t, testEngine.Sync2(new(TestSync2Default)))\n}\n"
        },
        {
          "name": "session_stats.go",
          "type": "blob",
          "size": 2.6640625,
          "content": "// Copyright 2016 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"reflect\"\n)\n\n// Count counts the records. bean's non-empty fields\n// are conditions.\nfunc (session *Session) Count(bean ...interface{}) (int64, error) {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\tvar sqlStr string\n\tvar args []interface{}\n\tvar err error\n\tif session.statement.RawSQL == \"\" {\n\t\tsqlStr, args, err = session.statement.genCountSQL(bean...)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t} else {\n\t\tsqlStr = session.statement.RawSQL\n\t\targs = session.statement.RawParams\n\t}\n\n\tvar total int64\n\terr = session.queryRow(sqlStr, args...).Scan(&total)\n\tif err == sql.ErrNoRows || err == nil {\n\t\treturn total, nil\n\t}\n\n\treturn 0, err\n}\n\n// sum call sum some column. bean's non-empty fields are conditions.\nfunc (session *Session) sum(res interface{}, bean interface{}, columnNames ...string) error {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\tv := reflect.ValueOf(res)\n\tif v.Kind() != reflect.Ptr {\n\t\treturn errors.New(\"need a pointer to a variable\")\n\t}\n\n\tvar isSlice = v.Elem().Kind() == reflect.Slice\n\tvar sqlStr string\n\tvar args []interface{}\n\tvar err error\n\tif len(session.statement.RawSQL) == 0 {\n\t\tsqlStr, args, err = session.statement.genSumSQL(bean, columnNames...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tsqlStr = session.statement.RawSQL\n\t\targs = session.statement.RawParams\n\t}\n\n\tif isSlice {\n\t\terr = session.queryRow(sqlStr, args...).ScanSlice(res)\n\t} else {\n\t\terr = session.queryRow(sqlStr, args...).Scan(res)\n\t}\n\tif err == sql.ErrNoRows || err == nil {\n\t\treturn nil\n\t}\n\treturn err\n}\n\n// Sum call sum some column. bean's non-empty fields are conditions.\nfunc (session *Session) Sum(bean interface{}, columnName string) (res float64, err error) {\n\treturn res, session.sum(&res, bean, columnName)\n}\n\n// SumInt call sum some column. bean's non-empty fields are conditions.\nfunc (session *Session) SumInt(bean interface{}, columnName string) (res int64, err error) {\n\treturn res, session.sum(&res, bean, columnName)\n}\n\n// Sums call sum some columns. bean's non-empty fields are conditions.\nfunc (session *Session) Sums(bean interface{}, columnNames ...string) ([]float64, error) {\n\tvar res = make([]float64, len(columnNames), len(columnNames))\n\treturn res, session.sum(&res, bean, columnNames...)\n}\n\n// SumsInt sum specify columns and return as []int64 instead of []float64\nfunc (session *Session) SumsInt(bean interface{}, columnNames ...string) ([]int64, error) {\n\tvar res = make([]int64, len(columnNames), len(columnNames))\n\treturn res, session.sum(&res, bean, columnNames...)\n}\n"
        },
        {
          "name": "session_stats_test.go",
          "type": "blob",
          "size": 6.1337890625,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"testing\"\n\n\t\"xorm.io/builder\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc isFloatEq(i, j float64, precision int) bool {\n\treturn fmt.Sprintf(\"%.\"+strconv.Itoa(precision)+\"f\", i) == fmt.Sprintf(\"%.\"+strconv.Itoa(precision)+\"f\", j)\n}\n\nfunc TestSum(t *testing.T) {\n\ttype SumStruct struct {\n\t\tInt   int\n\t\tFloat float32\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassert.NoError(t, testEngine.Sync2(new(SumStruct)))\n\n\tvar (\n\t\tcases = []SumStruct{\n\t\t\t{1, 6.2},\n\t\t\t{2, 5.3},\n\t\t\t{92, -0.2},\n\t\t}\n\t)\n\n\tvar i int\n\tvar f float32\n\tfor _, v := range cases {\n\t\ti += v.Int\n\t\tf += v.Float\n\t}\n\n\tcnt, err := testEngine.Insert(cases)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 3, cnt)\n\n\tcolInt := testEngine.GetColumnMapper().Obj2Table(\"Int\")\n\tcolFloat := testEngine.GetColumnMapper().Obj2Table(\"Float\")\n\n\tsumInt, err := testEngine.Sum(new(SumStruct), colInt)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, int(sumInt), i)\n\n\tsumFloat, err := testEngine.Sum(new(SumStruct), colFloat)\n\tassert.NoError(t, err)\n\tassert.Condition(t, func() bool {\n\t\treturn isFloatEq(sumFloat, float64(f), 2)\n\t})\n\n\tsums, err := testEngine.Sums(new(SumStruct), colInt, colFloat)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, len(sums))\n\tassert.EqualValues(t, i, int(sums[0]))\n\tassert.Condition(t, func() bool {\n\t\treturn isFloatEq(sums[1], float64(f), 2)\n\t})\n\n\tsumsInt, err := testEngine.SumsInt(new(SumStruct), colInt)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(sumsInt))\n\tassert.EqualValues(t, i, int(sumsInt[0]))\n}\n\ntype SumStructWithTableName struct {\n\tInt   int\n\tFloat float32\n}\n\nfunc (s SumStructWithTableName) TableName() string {\n\treturn \"sum_struct_with_table_name_1\"\n}\n\nfunc TestSumWithTableName(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassert.NoError(t, testEngine.Sync2(new(SumStructWithTableName)))\n\n\tvar (\n\t\tcases = []SumStructWithTableName{\n\t\t\t{1, 6.2},\n\t\t\t{2, 5.3},\n\t\t\t{92, -0.2},\n\t\t}\n\t)\n\n\tvar i int\n\tvar f float32\n\tfor _, v := range cases {\n\t\ti += v.Int\n\t\tf += v.Float\n\t}\n\n\tcnt, err := testEngine.Insert(cases)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 3, cnt)\n\n\tcolInt := testEngine.GetColumnMapper().Obj2Table(\"Int\")\n\tcolFloat := testEngine.GetColumnMapper().Obj2Table(\"Float\")\n\n\tsumInt, err := testEngine.Sum(new(SumStructWithTableName), colInt)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, int(sumInt), i)\n\n\tsumFloat, err := testEngine.Sum(new(SumStructWithTableName), colFloat)\n\tassert.NoError(t, err)\n\tassert.Condition(t, func() bool {\n\t\treturn isFloatEq(sumFloat, float64(f), 2)\n\t})\n\n\tsums, err := testEngine.Sums(new(SumStructWithTableName), colInt, colFloat)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, len(sums))\n\tassert.EqualValues(t, i, int(sums[0]))\n\tassert.Condition(t, func() bool {\n\t\treturn isFloatEq(sums[1], float64(f), 2)\n\t})\n\n\tsumsInt, err := testEngine.SumsInt(new(SumStructWithTableName), colInt)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(sumsInt))\n\tassert.EqualValues(t, i, int(sumsInt[0]))\n}\n\nfunc TestSumCustomColumn(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype SumStruct2 struct {\n\t\tInt   int\n\t\tFloat float32\n\t}\n\n\tvar (\n\t\tcases = []SumStruct2{\n\t\t\t{1, 6.2},\n\t\t\t{2, 5.3},\n\t\t\t{92, -0.2},\n\t\t}\n\t)\n\n\tassert.NoError(t, testEngine.Sync2(new(SumStruct2)))\n\n\tcnt, err := testEngine.Insert(cases)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 3, cnt)\n\n\tsumInt, err := testEngine.Sum(new(SumStruct2),\n\t\t\"CASE WHEN `int` <= 2 THEN `int` ELSE 0 END\")\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 3, int(sumInt))\n}\n\nfunc TestCount(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UserinfoCount struct {\n\t\tDepartname string\n\t}\n\tassert.NoError(t, testEngine.Sync2(new(UserinfoCount)))\n\n\tcolName := testEngine.GetColumnMapper().Obj2Table(\"Departname\")\n\tvar cond builder.Cond = builder.Eq{\n\t\t\"`\" + colName + \"`\": \"dev\",\n\t}\n\n\ttotal, err := testEngine.Where(cond).Count(new(UserinfoCount))\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 0, total)\n\n\tcnt, err := testEngine.Insert(&UserinfoCount{\n\t\tDepartname: \"dev\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\ttotal, err = testEngine.Where(cond).Count(new(UserinfoCount))\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, total)\n\n\ttotal, err = testEngine.Where(cond).Table(\"userinfo_count\").Count()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, total)\n\n\ttotal, err = testEngine.Table(\"userinfo_count\").Count()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, total)\n}\n\nfunc TestSQLCount(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UserinfoCount2 struct {\n\t\tId         int64\n\t\tDepartname string\n\t}\n\n\ttype UserinfoBooks struct {\n\t\tId     int64\n\t\tPid    int64\n\t\tIsOpen bool\n\t}\n\n\tassertSync(t, new(UserinfoCount2), new(UserinfoBooks))\n\n\ttotal, err := testEngine.SQL(\"SELECT count(id) FROM \" + testEngine.TableName(\"userinfo_count2\", true)).\n\t\tCount()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 0, total)\n}\n\nfunc TestCountWithOthers(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype CountWithOthers struct {\n\t\tId   int64\n\t\tName string\n\t}\n\n\tassertSync(t, new(CountWithOthers))\n\n\t_, err := testEngine.Insert(&CountWithOthers{\n\t\tName: \"orderby\",\n\t})\n\tassert.NoError(t, err)\n\n\t_, err = testEngine.Insert(&CountWithOthers{\n\t\tName: \"limit\",\n\t})\n\tassert.NoError(t, err)\n\n\ttotal, err := testEngine.OrderBy(\"id desc\").Limit(1).Count(new(CountWithOthers))\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, total)\n}\n\ntype CountWithTableName struct {\n\tId   int64\n\tName string\n}\n\nfunc (CountWithTableName) TableName() string {\n\treturn \"count_with_table_name1\"\n}\n\nfunc TestWithTableName(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tassertSync(t, new(CountWithTableName))\n\n\t_, err := testEngine.Insert(&CountWithTableName{\n\t\tName: \"orderby\",\n\t})\n\tassert.NoError(t, err)\n\n\t_, err = testEngine.Insert(CountWithTableName{\n\t\tName: \"limit\",\n\t})\n\tassert.NoError(t, err)\n\n\ttotal, err := testEngine.OrderBy(\"id desc\").Count(new(CountWithTableName))\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, total)\n\n\ttotal, err = testEngine.OrderBy(\"id desc\").Count(CountWithTableName{})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, total)\n}\n"
        },
        {
          "name": "session_test.go",
          "type": "blob",
          "size": 0.9091796875,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"database/sql\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestClose(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tsess1 := testEngine.NewSession()\n\tsess1.Close()\n\tassert.True(t, sess1.IsClosed())\n\n\tsess2 := testEngine.Where(\"a = ?\", 1)\n\tsess2.Close()\n\tassert.True(t, sess2.IsClosed())\n}\n\nfunc TestNullFloatStruct(t *testing.T) {\n\ttype MyNullFloat64 sql.NullFloat64\n\n\ttype MyNullFloatStruct struct {\n\t\tUuid   string\n\t\tAmount MyNullFloat64\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassert.NoError(t, testEngine.Sync2(new(MyNullFloatStruct)))\n\n\t_, err := testEngine.Insert(&MyNullFloatStruct{\n\t\tUuid: \"111111\",\n\t\tAmount: MyNullFloat64(sql.NullFloat64{\n\t\t\tFloat64: 0.1111,\n\t\t\tValid:   true,\n\t\t}),\n\t})\n\tassert.NoError(t, err)\n}\n"
        },
        {
          "name": "session_tx.go",
          "type": "blob",
          "size": 2.3359375,
          "content": "// Copyright 2016 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\n// Begin a transaction\nfunc (session *Session) Begin() error {\n\tif session.isAutoCommit {\n\t\ttx, err := session.DB().BeginTx(session.ctx, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsession.isAutoCommit = false\n\t\tsession.isCommitedOrRollbacked = false\n\t\tsession.tx = tx\n\t\tsession.saveLastSQL(\"BEGIN TRANSACTION\")\n\t}\n\treturn nil\n}\n\n// Rollback When using transaction, you can rollback if any error\nfunc (session *Session) Rollback() error {\n\tif !session.isAutoCommit && !session.isCommitedOrRollbacked {\n\t\tsession.saveLastSQL(session.engine.dialect.RollBackStr())\n\t\tsession.isCommitedOrRollbacked = true\n\t\tsession.isAutoCommit = true\n\t\treturn session.tx.Rollback()\n\t}\n\treturn nil\n}\n\n// Commit When using transaction, Commit will commit all operations.\nfunc (session *Session) Commit() error {\n\tif !session.isAutoCommit && !session.isCommitedOrRollbacked {\n\t\tsession.saveLastSQL(\"COMMIT\")\n\t\tsession.isCommitedOrRollbacked = true\n\t\tsession.isAutoCommit = true\n\t\tvar err error\n\t\tif err = session.tx.Commit(); err == nil {\n\t\t\t// handle processors after tx committed\n\t\t\tclosureCallFunc := func(closuresPtr *[]func(interface{}), bean interface{}) {\n\t\t\t\tif closuresPtr != nil {\n\t\t\t\t\tfor _, closure := range *closuresPtr {\n\t\t\t\t\t\tclosure(bean)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor bean, closuresPtr := range session.afterInsertBeans {\n\t\t\t\tclosureCallFunc(closuresPtr, bean)\n\n\t\t\t\tif processor, ok := interface{}(bean).(AfterInsertProcessor); ok {\n\t\t\t\t\tprocessor.AfterInsert()\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor bean, closuresPtr := range session.afterUpdateBeans {\n\t\t\t\tclosureCallFunc(closuresPtr, bean)\n\n\t\t\t\tif processor, ok := interface{}(bean).(AfterUpdateProcessor); ok {\n\t\t\t\t\tprocessor.AfterUpdate()\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor bean, closuresPtr := range session.afterDeleteBeans {\n\t\t\t\tclosureCallFunc(closuresPtr, bean)\n\n\t\t\t\tif processor, ok := interface{}(bean).(AfterDeleteProcessor); ok {\n\t\t\t\t\tprocessor.AfterDelete()\n\t\t\t\t}\n\t\t\t}\n\t\t\tcleanUpFunc := func(slices *map[interface{}]*[]func(interface{})) {\n\t\t\t\tif len(*slices) > 0 {\n\t\t\t\t\t*slices = make(map[interface{}]*[]func(interface{}), 0)\n\t\t\t\t}\n\t\t\t}\n\t\t\tcleanUpFunc(&session.afterInsertBeans)\n\t\t\tcleanUpFunc(&session.afterUpdateBeans)\n\t\t\tcleanUpFunc(&session.afterDeleteBeans)\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "session_tx_test.go",
          "type": "blob",
          "size": 4.2646484375,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"xorm.io/core\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestTransaction(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\tcounter := func() {\n\t\ttotal, err := testEngine.Count(&Userinfo{})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tfmt.Printf(\"----now total %v records\\n\", total)\n\t}\n\n\tcounter()\n\t//defer counter()\n\n\tsession := testEngine.NewSession()\n\tdefer session.Close()\n\n\terr := session.Begin()\n\tassert.NoError(t, err)\n\n\tuser1 := Userinfo{Username: \"xiaoxiao\", Departname: \"dev\", Alias: \"lunny\", Created: time.Now()}\n\t_, err = session.Insert(&user1)\n\tassert.NoError(t, err)\n\n\tuser2 := Userinfo{Username: \"yyy\"}\n\t_, err = session.Where(\"(id) = ?\", 0).Update(&user2)\n\tassert.NoError(t, err)\n\n\t_, err = session.Delete(&user2)\n\tassert.NoError(t, err)\n\n\terr = session.Commit()\n\tassert.NoError(t, err)\n}\n\nfunc TestCombineTransaction(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\tcounter := func() {\n\t\ttotal, err := testEngine.Count(&Userinfo{})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tfmt.Printf(\"----now total %v records\\n\", total)\n\t}\n\n\tcounter()\n\t//defer counter()\n\tsession := testEngine.NewSession()\n\tdefer session.Close()\n\n\terr := session.Begin()\n\tassert.NoError(t, err)\n\n\tuser1 := Userinfo{Username: \"xiaoxiao2\", Departname: \"dev\", Alias: \"lunny\", Created: time.Now()}\n\t_, err = session.Insert(&user1)\n\tassert.NoError(t, err)\n\n\tuser2 := Userinfo{Username: \"zzz\"}\n\t_, err = session.Where(\"id = ?\", 0).Update(&user2)\n\tassert.NoError(t, err)\n\n\t_, err = session.Exec(\"delete from \"+testEngine.TableName(\"userinfo\", true)+\" where username = ?\", user2.Username)\n\tassert.NoError(t, err)\n\n\terr = session.Commit()\n\tassert.NoError(t, err)\n}\n\nfunc TestCombineTransactionSameMapper(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\toldMapper := testEngine.GetColumnMapper()\n\ttestEngine.UnMapType(rValue(new(Userinfo)).Type())\n\ttestEngine.SetMapper(core.SameMapper{})\n\tdefer func() {\n\t\ttestEngine.UnMapType(rValue(new(Userinfo)).Type())\n\t\ttestEngine.SetMapper(oldMapper)\n\t}()\n\n\tassertSync(t, new(Userinfo))\n\n\tcounter := func() {\n\t\ttotal, err := testEngine.Count(&Userinfo{})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tfmt.Printf(\"----now total %v records\\n\", total)\n\t}\n\n\tcounter()\n\tdefer counter()\n\n\tsession := testEngine.NewSession()\n\tdefer session.Close()\n\n\terr := session.Begin()\n\tassert.NoError(t, err)\n\n\tuser1 := Userinfo{Username: \"xiaoxiao2\", Departname: \"dev\", Alias: \"lunny\", Created: time.Now()}\n\t_, err = session.Insert(&user1)\n\tassert.NoError(t, err)\n\n\tuser2 := Userinfo{Username: \"zzz\"}\n\t_, err = session.Where(\"(id) = ?\", 0).Update(&user2)\n\tassert.NoError(t, err)\n\n\t_, err = session.Exec(\"delete from  \"+testEngine.TableName(\"`Userinfo`\", true)+\" where `Username` = ?\", user2.Username)\n\tassert.NoError(t, err)\n\n\terr = session.Commit()\n\tassert.NoError(t, err)\n}\n\nfunc TestMultipleTransaction(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype MultipleTransaction struct {\n\t\tId   int64\n\t\tName string\n\t}\n\n\tassertSync(t, new(MultipleTransaction))\n\n\tsession := testEngine.NewSession()\n\tdefer session.Close()\n\n\terr := session.Begin()\n\tassert.NoError(t, err)\n\n\tm1 := MultipleTransaction{Name: \"xiaoxiao2\"}\n\t_, err = session.Insert(&m1)\n\tassert.NoError(t, err)\n\n\tuser2 := MultipleTransaction{Name: \"zzz\"}\n\t_, err = session.Where(\"id = ?\", 0).Update(&user2)\n\tassert.NoError(t, err)\n\n\terr = session.Commit()\n\tassert.NoError(t, err)\n\n\tvar ms []MultipleTransaction\n\terr = session.Find(&ms)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(ms))\n\n\terr = session.Begin()\n\tassert.NoError(t, err)\n\n\t_, err = session.Where(\"id=?\", m1.Id).Delete(new(MultipleTransaction))\n\tassert.NoError(t, err)\n\n\terr = session.Commit()\n\tassert.NoError(t, err)\n\n\tms = make([]MultipleTransaction, 0)\n\terr = session.Find(&ms)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 0, len(ms))\n\n\terr = session.Begin()\n\tassert.NoError(t, err)\n\n\t_, err = session.Insert(&MultipleTransaction{\n\t\tName: \"ssss\",\n\t})\n\tassert.NoError(t, err)\n\n\terr = session.Rollback()\n\tassert.NoError(t, err)\n\n\tms = make([]MultipleTransaction, 0)\n\terr = session.Find(&ms)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 0, len(ms))\n}\n"
        },
        {
          "name": "session_update.go",
          "type": "blob",
          "size": 14.9873046875,
          "content": "// Copyright 2016 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"xorm.io/builder\"\n\t\"xorm.io/core\"\n)\n\nfunc (session *Session) cacheUpdate(table *core.Table, tableName, sqlStr string, args ...interface{}) error {\n\tif table == nil ||\n\t\tsession.tx != nil {\n\t\treturn ErrCacheFailed\n\t}\n\n\toldhead, newsql := session.statement.convertUpdateSQL(sqlStr)\n\tif newsql == \"\" {\n\t\treturn ErrCacheFailed\n\t}\n\tfor _, filter := range session.engine.dialect.Filters() {\n\t\tnewsql = filter.Do(newsql, session.engine.dialect, table)\n\t}\n\tsession.engine.logger.Debug(\"[cacheUpdate] new sql\", oldhead, newsql)\n\n\tvar nStart int\n\tif len(args) > 0 {\n\t\tif strings.Index(sqlStr, \"?\") > -1 {\n\t\t\tnStart = strings.Count(oldhead, \"?\")\n\t\t} else {\n\t\t\t// only for pq, TODO: if any other databse?\n\t\t\tnStart = strings.Count(oldhead, \"$\")\n\t\t}\n\t}\n\n\tcacher := session.engine.getCacher(tableName)\n\tsession.engine.logger.Debug(\"[cacheUpdate] get cache sql\", newsql, args[nStart:])\n\tids, err := core.GetCacheSql(cacher, tableName, newsql, args[nStart:])\n\tif err != nil {\n\t\trows, err := session.NoCache().queryRows(newsql, args[nStart:]...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer rows.Close()\n\n\t\tids = make([]core.PK, 0)\n\t\tfor rows.Next() {\n\t\t\tvar res = make([]string, len(table.PrimaryKeys))\n\t\t\terr = rows.ScanSlice(&res)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tvar pk core.PK = make([]interface{}, len(table.PrimaryKeys))\n\t\t\tfor i, col := range table.PKColumns() {\n\t\t\t\tif col.SQLType.IsNumeric() {\n\t\t\t\t\tn, err := strconv.ParseInt(res[i], 10, 64)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tpk[i] = n\n\t\t\t\t} else if col.SQLType.IsText() {\n\t\t\t\t\tpk[i] = res[i]\n\t\t\t\t} else {\n\t\t\t\t\treturn errors.New(\"not supported\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tids = append(ids, pk)\n\t\t}\n\t\tsession.engine.logger.Debug(\"[cacheUpdate] find updated id\", ids)\n\t} /*else {\n\t    session.engine.LogDebug(\"[xorm:cacheUpdate] del cached sql:\", tableName, newsql, args)\n\t    cacher.DelIds(tableName, genSqlKey(newsql, args))\n\t}*/\n\n\tfor _, id := range ids {\n\t\tsid, err := id.ToString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif bean := cacher.GetBean(tableName, sid); bean != nil {\n\t\t\tsqls := splitNNoCase(sqlStr, \"where\", 2)\n\t\t\tif len(sqls) == 0 || len(sqls) > 2 {\n\t\t\t\treturn ErrCacheFailed\n\t\t\t}\n\n\t\t\tsqls = splitNNoCase(sqls[0], \"set\", 2)\n\t\t\tif len(sqls) != 2 {\n\t\t\t\treturn ErrCacheFailed\n\t\t\t}\n\t\t\tkvs := strings.Split(strings.TrimSpace(sqls[1]), \",\")\n\n\t\t\tfor idx, kv := range kvs {\n\t\t\t\tsps := strings.SplitN(kv, \"=\", 2)\n\t\t\t\tsps2 := strings.Split(sps[0], \".\")\n\t\t\t\tcolName := sps2[len(sps2)-1]\n\t\t\t\t// treat quote prefix, suffix and '`' as quotes\n\t\t\t\tquotes := append(strings.Split(session.engine.Quote(\"\"), \"\"), \"`\")\n\t\t\t\tif strings.ContainsAny(colName, strings.Join(quotes, \"\")) {\n\t\t\t\t\tcolName = strings.TrimSpace(eraseAny(colName, quotes...))\n\t\t\t\t} else {\n\t\t\t\t\tsession.engine.logger.Debug(\"[cacheUpdate] cannot find column\", tableName, colName)\n\t\t\t\t\treturn ErrCacheFailed\n\t\t\t\t}\n\n\t\t\t\tif col := table.GetColumn(colName); col != nil {\n\t\t\t\t\tfieldValue, err := col.ValueOf(bean)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tsession.engine.logger.Error(err)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsession.engine.logger.Debug(\"[cacheUpdate] set bean field\", bean, colName, fieldValue.Interface())\n\t\t\t\t\t\tif col.IsVersion && session.statement.checkVersion {\n\t\t\t\t\t\t\tsession.incrVersionFieldValue(fieldValue)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfieldValue.Set(reflect.ValueOf(args[idx]))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsession.engine.logger.Errorf(\"[cacheUpdate] ERROR: column %v is not table %v's\",\n\t\t\t\t\t\tcolName, table.Name)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsession.engine.logger.Debug(\"[cacheUpdate] update cache\", tableName, id, bean)\n\t\t\tcacher.PutBean(tableName, sid, bean)\n\t\t}\n\t}\n\tsession.engine.logger.Debug(\"[cacheUpdate] clear cached table sql:\", tableName)\n\tcacher.ClearIds(tableName)\n\treturn nil\n}\n\n// Update records, bean's non-empty fields are updated contents,\n// condiBean' non-empty filds are conditions\n// CAUTION:\n//        1.bool will defaultly be updated content nor conditions\n//         You should call UseBool if you have bool to use.\n//        2.float32 & float64 may be not inexact as conditions\nfunc (session *Session) Update(bean interface{}, condiBean ...interface{}) (int64, error) {\n\tif session.isAutoClose {\n\t\tdefer session.Close()\n\t}\n\n\tif session.statement.lastError != nil {\n\t\treturn 0, session.statement.lastError\n\t}\n\n\tv := rValue(bean)\n\tt := v.Type()\n\n\tvar colNames []string\n\tvar args []interface{}\n\n\t// handle before update processors\n\tfor _, closure := range session.beforeClosures {\n\t\tclosure(bean)\n\t}\n\tcleanupProcessorsClosures(&session.beforeClosures) // cleanup after used\n\tif processor, ok := interface{}(bean).(BeforeUpdateProcessor); ok {\n\t\tprocessor.BeforeUpdate()\n\t}\n\t// --\n\n\tvar err error\n\tvar isMap = t.Kind() == reflect.Map\n\tvar isStruct = t.Kind() == reflect.Struct\n\tif isStruct {\n\t\tif err := session.statement.setRefBean(bean); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif len(session.statement.TableName()) <= 0 {\n\t\t\treturn 0, ErrTableNotFound\n\t\t}\n\n\t\tif session.statement.ColumnStr == \"\" {\n\t\t\tcolNames, args = session.statement.buildUpdates(bean, false, false,\n\t\t\t\tfalse, false, true)\n\t\t} else {\n\t\t\tcolNames, args, err = session.genUpdateColumns(bean)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t}\n\t} else if isMap {\n\t\tcolNames = make([]string, 0)\n\t\targs = make([]interface{}, 0)\n\t\tbValue := reflect.Indirect(reflect.ValueOf(bean))\n\n\t\tfor _, v := range bValue.MapKeys() {\n\t\t\tcolNames = append(colNames, session.engine.Quote(v.String())+\" = ?\")\n\t\t\targs = append(args, bValue.MapIndex(v).Interface())\n\t\t}\n\t} else {\n\t\treturn 0, ErrParamsType\n\t}\n\n\ttable := session.statement.RefTable\n\n\tif session.statement.UseAutoTime && table != nil && table.Updated != \"\" {\n\t\tif !session.statement.columnMap.contain(table.Updated) &&\n\t\t\t!session.statement.omitColumnMap.contain(table.Updated) {\n\t\t\tcolNames = append(colNames, session.engine.Quote(table.Updated)+\" = ?\")\n\t\t\tcol := table.UpdatedColumn()\n\t\t\tval, t := session.engine.nowTime(col)\n\t\t\targs = append(args, val)\n\n\t\t\tvar colName = col.Name\n\t\t\tif isStruct {\n\t\t\t\tsession.afterClosures = append(session.afterClosures, func(bean interface{}) {\n\t\t\t\t\tcol := table.GetColumn(colName)\n\t\t\t\t\tsetColumnTime(bean, col, t)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\t// for update action to like \"column = column + ?\"\n\tincColumns := session.statement.incrColumns\n\tfor i, colName := range incColumns.colNames {\n\t\tcolNames = append(colNames, session.engine.Quote(colName)+\" = \"+session.engine.Quote(colName)+\" + ?\")\n\t\targs = append(args, incColumns.args[i])\n\t}\n\t// for update action to like \"column = column - ?\"\n\tdecColumns := session.statement.decrColumns\n\tfor i, colName := range decColumns.colNames {\n\t\tcolNames = append(colNames, session.engine.Quote(colName)+\" = \"+session.engine.Quote(colName)+\" - ?\")\n\t\targs = append(args, decColumns.args[i])\n\t}\n\t// for update action to like \"column = expression\"\n\texprColumns := session.statement.exprColumns\n\tfor i, colName := range exprColumns.colNames {\n\t\tswitch tp := exprColumns.args[i].(type) {\n\t\tcase string:\n\t\t\tcolNames = append(colNames, session.engine.Quote(colName)+\" = \"+tp)\n\t\tcase *builder.Builder:\n\t\t\tsubQuery, subArgs, err := builder.ToSQL(tp)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tcolNames = append(colNames, session.engine.Quote(colName)+\" = (\"+subQuery+\")\")\n\t\t\targs = append(args, subArgs...)\n\t\t}\n\t}\n\n\tif err = session.statement.processIDParam(); err != nil {\n\t\treturn 0, err\n\t}\n\n\tvar autoCond builder.Cond\n\tif !session.statement.noAutoCondition {\n\t\tcondBeanIsStruct := false\n\t\tif len(condiBean) > 0 {\n\t\t\tif c, ok := condiBean[0].(map[string]interface{}); ok {\n\t\t\t\tautoCond = builder.Eq(c)\n\t\t\t} else {\n\t\t\t\tct := reflect.TypeOf(condiBean[0])\n\t\t\t\tk := ct.Kind()\n\t\t\t\tif k == reflect.Ptr {\n\t\t\t\t\tk = ct.Elem().Kind()\n\t\t\t\t}\n\t\t\t\tif k == reflect.Struct {\n\t\t\t\t\tvar err error\n\t\t\t\t\tautoCond, err = session.statement.buildConds(session.statement.RefTable, condiBean[0], true, true, false, true, false)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t}\n\t\t\t\t\tcondBeanIsStruct = true\n\t\t\t\t} else {\n\t\t\t\t\treturn 0, ErrConditionType\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !condBeanIsStruct && table != nil {\n\t\t\tif col := table.DeletedColumn(); col != nil && !session.statement.unscoped { // tag \"deleted\" is enabled\n\t\t\t\tautoCond1 := session.engine.CondDeleted(session.engine.Quote(col.Name))\n\n\t\t\t\tif autoCond == nil {\n\t\t\t\t\tautoCond = autoCond1\n\t\t\t\t} else {\n\t\t\t\t\tautoCond = autoCond.And(autoCond1)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tst := &session.statement\n\n\tvar sqlStr string\n\tvar condArgs []interface{}\n\tvar condSQL string\n\tcond := session.statement.cond.And(autoCond)\n\n\tvar doIncVer = (table != nil && table.Version != \"\" && session.statement.checkVersion)\n\tvar verValue *reflect.Value\n\tif doIncVer {\n\t\tverValue, err = table.VersionColumn().ValueOf(bean)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tcond = cond.And(builder.Eq{session.engine.Quote(table.Version): verValue.Interface()})\n\t\tcolNames = append(colNames, session.engine.Quote(table.Version)+\" = \"+session.engine.Quote(table.Version)+\" + 1\")\n\t}\n\n\tcondSQL, condArgs, err = builder.ToSQL(cond)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tif len(condSQL) > 0 {\n\t\tcondSQL = \"WHERE \" + condSQL\n\t}\n\n\tif st.OrderStr != \"\" {\n\t\tcondSQL = condSQL + fmt.Sprintf(\" ORDER BY %v\", st.OrderStr)\n\t}\n\n\tvar tableName = session.statement.TableName()\n\t// TODO: Oracle support needed\n\tvar top string\n\tif st.LimitN > 0 {\n\t\tif st.Engine.dialect.DBType() == core.MYSQL {\n\t\t\tcondSQL = condSQL + fmt.Sprintf(\" LIMIT %d\", st.LimitN)\n\t\t} else if st.Engine.dialect.DBType() == core.SQLITE {\n\t\t\ttempCondSQL := condSQL + fmt.Sprintf(\" LIMIT %d\", st.LimitN)\n\t\t\tcond = cond.And(builder.Expr(fmt.Sprintf(\"rowid IN (SELECT rowid FROM %v %v)\",\n\t\t\t\tsession.engine.Quote(tableName), tempCondSQL), condArgs...))\n\t\t\tcondSQL, condArgs, err = builder.ToSQL(cond)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tif len(condSQL) > 0 {\n\t\t\t\tcondSQL = \"WHERE \" + condSQL\n\t\t\t}\n\t\t} else if st.Engine.dialect.DBType() == core.POSTGRES {\n\t\t\ttempCondSQL := condSQL + fmt.Sprintf(\" LIMIT %d\", st.LimitN)\n\t\t\tcond = cond.And(builder.Expr(fmt.Sprintf(\"CTID IN (SELECT CTID FROM %v %v)\",\n\t\t\t\tsession.engine.Quote(tableName), tempCondSQL), condArgs...))\n\t\t\tcondSQL, condArgs, err = builder.ToSQL(cond)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\n\t\t\tif len(condSQL) > 0 {\n\t\t\t\tcondSQL = \"WHERE \" + condSQL\n\t\t\t}\n\t\t} else if st.Engine.dialect.DBType() == core.MSSQL {\n\t\t\tif st.OrderStr != \"\" && st.Engine.dialect.DBType() == core.MSSQL &&\n\t\t\t\ttable != nil && len(table.PrimaryKeys) == 1 {\n\t\t\t\tcond = builder.Expr(fmt.Sprintf(\"%s IN (SELECT TOP (%d) %s FROM %v%v)\",\n\t\t\t\t\ttable.PrimaryKeys[0], st.LimitN, table.PrimaryKeys[0],\n\t\t\t\t\tsession.engine.Quote(tableName), condSQL), condArgs...)\n\n\t\t\t\tcondSQL, condArgs, err = builder.ToSQL(cond)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn 0, err\n\t\t\t\t}\n\t\t\t\tif len(condSQL) > 0 {\n\t\t\t\t\tcondSQL = \"WHERE \" + condSQL\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttop = fmt.Sprintf(\"TOP (%d) \", st.LimitN)\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(colNames) <= 0 {\n\t\treturn 0, errors.New(\"No content found to be updated\")\n\t}\n\n\tsqlStr = fmt.Sprintf(\"UPDATE %v%v SET %v %v\",\n\t\ttop,\n\t\tsession.engine.Quote(tableName),\n\t\tstrings.Join(colNames, \", \"),\n\t\tcondSQL)\n\n\tres, err := session.exec(sqlStr, append(args, condArgs...)...)\n\tif err != nil {\n\t\treturn 0, err\n\t} else if doIncVer {\n\t\tif verValue != nil && verValue.IsValid() && verValue.CanSet() {\n\t\t\tsession.incrVersionFieldValue(verValue)\n\t\t}\n\t}\n\n\tif cacher := session.engine.getCacher(tableName); cacher != nil && session.statement.UseCache {\n\t\t// session.cacheUpdate(table, tableName, sqlStr, args...)\n\t\tsession.engine.logger.Debug(\"[cacheUpdate] clear table \", tableName)\n\t\tcacher.ClearIds(tableName)\n\t\tcacher.ClearBeans(tableName)\n\t}\n\n\t// handle after update processors\n\tif session.isAutoCommit {\n\t\tfor _, closure := range session.afterClosures {\n\t\t\tclosure(bean)\n\t\t}\n\t\tif processor, ok := interface{}(bean).(AfterUpdateProcessor); ok {\n\t\t\tsession.engine.logger.Debug(\"[event]\", tableName, \" has after update processor\")\n\t\t\tprocessor.AfterUpdate()\n\t\t}\n\t} else {\n\t\tlenAfterClosures := len(session.afterClosures)\n\t\tif lenAfterClosures > 0 {\n\t\t\tif value, has := session.afterUpdateBeans[bean]; has && value != nil {\n\t\t\t\t*value = append(*value, session.afterClosures...)\n\t\t\t} else {\n\t\t\t\tafterClosures := make([]func(interface{}), lenAfterClosures)\n\t\t\t\tcopy(afterClosures, session.afterClosures)\n\t\t\t\t// FIXME: if bean is a map type, it will panic because map cannot be as map key\n\t\t\t\tsession.afterUpdateBeans[bean] = &afterClosures\n\t\t\t}\n\n\t\t} else {\n\t\t\tif _, ok := interface{}(bean).(AfterUpdateProcessor); ok {\n\t\t\t\tsession.afterUpdateBeans[bean] = nil\n\t\t\t}\n\t\t}\n\t}\n\tcleanupProcessorsClosures(&session.afterClosures) // cleanup after used\n\t// --\n\n\treturn res.RowsAffected()\n}\n\nfunc (session *Session) genUpdateColumns(bean interface{}) ([]string, []interface{}, error) {\n\ttable := session.statement.RefTable\n\tcolNames := make([]string, 0, len(table.ColumnsSeq()))\n\targs := make([]interface{}, 0, len(table.ColumnsSeq()))\n\n\tfor _, col := range table.Columns() {\n\t\tif !col.IsVersion && !col.IsCreated && !col.IsUpdated {\n\t\t\tif session.statement.omitColumnMap.contain(col.Name) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif col.MapType == core.ONLYFROMDB {\n\t\t\tcontinue\n\t\t}\n\n\t\tfieldValuePtr, err := col.ValueOf(bean)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tfieldValue := *fieldValuePtr\n\n\t\tif col.IsAutoIncrement {\n\t\t\tswitch fieldValue.Type().Kind() {\n\t\t\tcase reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int, reflect.Int64:\n\t\t\t\tif fieldValue.Int() == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\tcase reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint, reflect.Uint64:\n\t\t\t\tif fieldValue.Uint() == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\tcase reflect.String:\n\t\t\t\tif len(fieldValue.String()) == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\tcase reflect.Ptr:\n\t\t\t\tif fieldValue.Pointer() == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (col.IsDeleted && !session.statement.unscoped) || col.IsCreated {\n\t\t\tcontinue\n\t\t}\n\n\t\t// if only update specify columns\n\t\tif len(session.statement.columnMap) > 0 && !session.statement.columnMap.contain(col.Name) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif session.statement.incrColumns.isColExist(col.Name) {\n\t\t\tcontinue\n\t\t} else if session.statement.decrColumns.isColExist(col.Name) {\n\t\t\tcontinue\n\t\t} else if session.statement.exprColumns.isColExist(col.Name) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// !evalphobia! set fieldValue as nil when column is nullable and zero-value\n\t\tif _, ok := getFlagForColumn(session.statement.nullableMap, col); ok {\n\t\t\tif col.Nullable && isZero(fieldValue.Interface()) {\n\t\t\t\tvar nilValue *int\n\t\t\t\tfieldValue = reflect.ValueOf(nilValue)\n\t\t\t}\n\t\t}\n\n\t\tif col.IsUpdated && session.statement.UseAutoTime /*&& isZero(fieldValue.Interface())*/ {\n\t\t\t// if time is non-empty, then set to auto time\n\t\t\tval, t := session.engine.nowTime(col)\n\t\t\targs = append(args, val)\n\n\t\t\tvar colName = col.Name\n\t\t\tsession.afterClosures = append(session.afterClosures, func(bean interface{}) {\n\t\t\t\tcol := table.GetColumn(colName)\n\t\t\t\tsetColumnTime(bean, col, t)\n\t\t\t})\n\t\t} else if col.IsVersion && session.statement.checkVersion {\n\t\t\targs = append(args, 1)\n\t\t} else {\n\t\t\targ, err := session.value2Interface(col, fieldValue)\n\t\t\tif err != nil {\n\t\t\t\treturn colNames, args, err\n\t\t\t}\n\t\t\targs = append(args, arg)\n\t\t}\n\n\t\tcolNames = append(colNames, session.engine.Quote(col.Name)+\" = ?\")\n\t}\n\treturn colNames, args, nil\n}\n"
        },
        {
          "name": "session_update_test.go",
          "type": "blob",
          "size": 29.337890625,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"xorm.io/core\"\n)\n\nfunc TestUpdateMap(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UpdateTable struct {\n\t\tId   int64\n\t\tName string\n\t\tAge  int\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(UpdateTable)))\n\tvar tb = UpdateTable{\n\t\tName: \"test\",\n\t\tAge:  35,\n\t}\n\t_, err := testEngine.Insert(&tb)\n\tassert.NoError(t, err)\n\n\tcnt, err := testEngine.Table(\"update_table\").Where(\"id = ?\", tb.Id).Update(map[string]interface{}{\n\t\t\"name\": \"test2\",\n\t\t\"age\":  36,\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n}\n\nfunc TestUpdateLimit(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UpdateTable2 struct {\n\t\tId   int64\n\t\tName string\n\t\tAge  int\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(UpdateTable2)))\n\tvar tb = UpdateTable2{\n\t\tName: \"test1\",\n\t\tAge:  35,\n\t}\n\tcnt, err := testEngine.Insert(&tb)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\ttb.Name = \"test2\"\n\ttb.Id = 0\n\tcnt, err = testEngine.Insert(&tb)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tcnt, err = testEngine.OrderBy(\"name desc\").Limit(1).Update(&UpdateTable2{\n\t\tAge: 30,\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar uts []UpdateTable2\n\terr = testEngine.Find(&uts)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 2, len(uts))\n\tassert.EqualValues(t, 35, uts[0].Age)\n\tassert.EqualValues(t, 30, uts[1].Age)\n}\n\ntype ForUpdate struct {\n\tId   int64 `xorm:\"pk\"`\n\tName string\n}\n\nfunc setupForUpdate(engine EngineInterface) error {\n\tv := new(ForUpdate)\n\terr := testEngine.DropTables(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = testEngine.CreateTables(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlist := []ForUpdate{\n\t\t{1, \"data1\"},\n\t\t{2, \"data2\"},\n\t\t{3, \"data3\"},\n\t}\n\n\tfor _, f := range list {\n\t\t_, err = testEngine.Insert(f)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc TestForUpdate(t *testing.T) {\n\tif *ignoreSelectUpdate {\n\t\treturn\n\t}\n\n\terr := setupForUpdate(testEngine)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tsession1 := testEngine.NewSession()\n\tsession2 := testEngine.NewSession()\n\tsession3 := testEngine.NewSession()\n\tdefer session1.Close()\n\tdefer session2.Close()\n\tdefer session3.Close()\n\n\t// start transaction\n\terr = session1.Begin()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\t// use lock\n\tfList := make([]ForUpdate, 0)\n\tsession1.ForUpdate()\n\tsession1.Where(\"(id) = ?\", 1)\n\terr = session1.Find(&fList)\n\tswitch {\n\tcase err != nil:\n\t\tt.Error(err)\n\t\treturn\n\tcase len(fList) != 1:\n\t\tt.Errorf(\"find not returned single row\")\n\t\treturn\n\tcase fList[0].Name != \"data1\":\n\t\tt.Errorf(\"for_update.name must be `data1`\")\n\t\treturn\n\t}\n\n\t// wait for lock\n\twg := &sync.WaitGroup{}\n\n\t// lock is used\n\twg.Add(1)\n\tgo func() {\n\t\tf2 := new(ForUpdate)\n\t\tsession2.Where(\"(id) = ?\", 1).ForUpdate()\n\t\thas, err := session2.Get(f2) // wait release lock\n\t\tswitch {\n\t\tcase err != nil:\n\t\t\tt.Error(err)\n\t\tcase !has:\n\t\t\tt.Errorf(\"cannot find target row. for_update.id = 1\")\n\t\tcase f2.Name != \"updated by session1\":\n\t\t\tt.Errorf(\"read lock failed\")\n\t\t}\n\t\twg.Done()\n\t}()\n\n\t// lock is NOT used\n\twg.Add(1)\n\tgo func() {\n\t\tf3 := new(ForUpdate)\n\t\tsession3.Where(\"(id) = ?\", 1)\n\t\thas, err := session3.Get(f3) // wait release lock\n\t\tswitch {\n\t\tcase err != nil:\n\t\t\tt.Error(err)\n\t\tcase !has:\n\t\t\tt.Errorf(\"cannot find target row. for_update.id = 1\")\n\t\tcase f3.Name != \"data1\":\n\t\t\tt.Errorf(\"read lock failed\")\n\t\t}\n\t\twg.Done()\n\t}()\n\n\t// wait for go rountines\n\ttime.Sleep(50 * time.Millisecond)\n\n\tf := new(ForUpdate)\n\tf.Name = \"updated by session1\"\n\tsession1.Where(\"(id) = ?\", 1)\n\tsession1.Update(f)\n\n\t// release lock\n\terr = session1.Commit()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\twg.Wait()\n}\n\nfunc TestWithIn(t *testing.T) {\n\ttype temp3 struct {\n\t\tId   int64  `xorm:\"Id pk autoincr\"`\n\t\tName string `xorm:\"Name\"`\n\t\tTest bool   `xorm:\"Test\"`\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassert.NoError(t, testEngine.Sync(new(temp3)))\n\n\ttestEngine.Insert(&[]temp3{\n\t\t{\n\t\t\tName: \"user1\",\n\t\t},\n\t\t{\n\t\t\tName: \"user1\",\n\t\t},\n\t\t{\n\t\t\tName: \"user1\",\n\t\t},\n\t})\n\n\tcnt, err := testEngine.In(\"Id\", 1, 2, 3, 4).Update(&temp3{Name: \"aa\"}, &temp3{Name: \"user1\"})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 3, cnt)\n}\n\ntype Condi map[string]interface{}\n\ntype UpdateAllCols struct {\n\tId     int64\n\tBool   bool\n\tString string\n\tPtr    *string\n}\n\ntype UpdateMustCols struct {\n\tId     int64\n\tBool   bool\n\tString string\n}\n\ntype UpdateIncr struct {\n\tId   int64\n\tCnt  int\n\tName string\n}\n\ntype Article struct {\n\tId      int32  `xorm:\"pk INT autoincr\"`\n\tName    string `xorm:\"VARCHAR(45)\"`\n\tImg     string `xorm:\"VARCHAR(100)\"`\n\tAside   string `xorm:\"VARCHAR(200)\"`\n\tDesc    string `xorm:\"VARCHAR(200)\"`\n\tContent string `xorm:\"TEXT\"`\n\tStatus  int8   `xorm:\"TINYINT(4)\"`\n}\n\nfunc TestUpdateMap2(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(UpdateMustCols))\n\n\t_, err := testEngine.Table(\"update_must_cols\").Where(\"id =?\", 1).Update(map[string]interface{}{\n\t\t\"bool\": true,\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestUpdate1(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\t_, err := testEngine.Insert(&Userinfo{\n\t\tUsername: \"user1\",\n\t})\n\n\tvar ori Userinfo\n\thas, err := testEngine.Get(&ori)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif !has {\n\t\tt.Error(errors.New(\"not exist\"))\n\t\tpanic(errors.New(\"not exist\"))\n\t}\n\n\t// update by id\n\tuser := Userinfo{Username: \"xxx\", Height: 1.2}\n\tcnt, err := testEngine.ID(ori.Uid).Update(&user)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif cnt != 1 {\n\t\terr = errors.New(\"update not returned 1\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t\treturn\n\t}\n\n\tcondi := Condi{\"username\": \"zzz\", \"departname\": \"\"}\n\tcnt, err = testEngine.Table(&user).ID(ori.Uid).Update(&condi)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif cnt != 1 {\n\t\terr = errors.New(\"update not returned 1\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t\treturn\n\t}\n\n\tcnt, err = testEngine.Update(&Userinfo{Username: \"yyy\"}, &user)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\ttotal, err := testEngine.Count(&user)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif cnt != total {\n\t\terr = errors.New(\"insert not returned 1\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t\treturn\n\t}\n\n\t// nullable update\n\t{\n\t\tuser := &Userinfo{Username: \"not null data\", Height: 180.5}\n\t\t_, err := testEngine.Insert(user)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t\tuserID := user.Uid\n\n\t\thas, err := testEngine.ID(userID).\n\t\t\tAnd(\"username = ?\", user.Username).\n\t\t\tAnd(\"height = ?\", user.Height).\n\t\t\tAnd(\"departname = ?\", \"\").\n\t\t\tAnd(\"detail_id = ?\", 0).\n\t\t\tAnd(\"is_man = ?\", 0).\n\t\t\tGet(&Userinfo{})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t\tif !has {\n\t\t\terr = errors.New(\"cannot insert properly\")\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\n\t\tupdatedUser := &Userinfo{Username: \"null data\"}\n\t\tcnt, err = testEngine.ID(userID).\n\t\t\tNullable(\"height\", \"departname\", \"is_man\", \"created\").\n\t\t\tUpdate(updatedUser)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t\tif cnt != 1 {\n\t\t\terr = errors.New(\"update not returned 1\")\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\n\t\thas, err = testEngine.ID(userID).\n\t\t\tAnd(\"username = ?\", updatedUser.Username).\n\t\t\tAnd(\"height IS NULL\").\n\t\t\tAnd(\"departname IS NULL\").\n\t\t\tAnd(\"is_man IS NULL\").\n\t\t\tAnd(\"created IS NULL\").\n\t\t\tAnd(\"detail_id = ?\", 0).\n\t\t\tGet(&Userinfo{})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t\tif !has {\n\t\t\terr = errors.New(\"cannot update with null properly\")\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\n\t\tcnt, err = testEngine.ID(userID).Delete(&Userinfo{})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t\tif cnt != 1 {\n\t\t\terr = errors.New(\"delete not returned 1\")\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\terr = testEngine.StoreEngine(\"Innodb\").Sync2(&Article{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tdefer func() {\n\t\terr = testEngine.DropTables(&Article{})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\ta := &Article{0, \"1\", \"2\", \"3\", \"4\", \"5\", 2}\n\tcnt, err = testEngine.Insert(a)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif cnt != 1 {\n\t\terr = errors.New(fmt.Sprintf(\"insert not returned 1 but %d\", cnt))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif a.Id == 0 {\n\t\terr = errors.New(\"insert returned id is 0\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err = testEngine.ID(a.Id).Update(&Article{Name: \"6\"})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif cnt != 1 {\n\t\terr = errors.New(fmt.Sprintf(\"insert not returned 1 but %d\", cnt))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t\treturn\n\t}\n\n\tvar s = \"test\"\n\n\tcol1 := &UpdateAllCols{Ptr: &s}\n\terr = testEngine.Sync(col1)\n\tassert.NoError(t, err)\n\n\t_, err = testEngine.Insert(col1)\n\tassert.NoError(t, err)\n\n\tcol2 := &UpdateAllCols{col1.Id, true, \"\", nil}\n\t_, err = testEngine.ID(col2.Id).AllCols().Update(col2)\n\tassert.NoError(t, err)\n\n\tcol3 := &UpdateAllCols{}\n\thas, err = testEngine.ID(col2.Id).Get(col3)\n\tassert.NoError(t, err)\n\n\tif !has {\n\t\terr = errors.New(fmt.Sprintf(\"cannot get id %d\", col2.Id))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t\treturn\n\t}\n\n\tif *col2 != *col3 {\n\t\terr = errors.New(fmt.Sprintf(\"col2 should eq col3\"))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t\treturn\n\t}\n\n\t{\n\n\t\tcol1 := &UpdateMustCols{}\n\t\terr = testEngine.Sync(col1)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\n\t\t_, err = testEngine.Insert(col1)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\n\t\tcol2 := &UpdateMustCols{col1.Id, true, \"\"}\n\t\tboolStr := testEngine.GetColumnMapper().Obj2Table(\"Bool\")\n\t\tstringStr := testEngine.GetColumnMapper().Obj2Table(\"String\")\n\t\t_, err = testEngine.ID(col2.Id).MustCols(boolStr, stringStr).Update(col2)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\n\t\tcol3 := &UpdateMustCols{}\n\t\thas, err := testEngine.ID(col2.Id).Get(col3)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\n\t\tif !has {\n\t\t\terr = errors.New(fmt.Sprintf(\"cannot get id %d\", col2.Id))\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t\treturn\n\t\t}\n\n\t\tif *col2 != *col3 {\n\t\t\terr = errors.New(fmt.Sprintf(\"col2 should eq col3\"))\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc TestUpdateIncrDecr(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tcol1 := &UpdateIncr{\n\t\tName: \"test\",\n\t}\n\tassert.NoError(t, testEngine.Sync(col1))\n\n\t_, err := testEngine.Insert(col1)\n\tassert.NoError(t, err)\n\n\tcolName := testEngine.GetColumnMapper().Obj2Table(\"Cnt\")\n\n\tcnt, err := testEngine.ID(col1.Id).Incr(colName).Update(col1)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tnewCol := new(UpdateIncr)\n\thas, err := testEngine.ID(col1.Id).Get(newCol)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 1, newCol.Cnt)\n\n\tcnt, err = testEngine.ID(col1.Id).Decr(colName).Update(col1)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tnewCol = new(UpdateIncr)\n\thas, err = testEngine.ID(col1.Id).Get(newCol)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 0, newCol.Cnt)\n\n\tcnt, err = testEngine.ID(col1.Id).Cols(colName).Incr(colName).Update(col1)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n}\n\ntype UpdatedUpdate struct {\n\tId      int64\n\tUpdated time.Time `xorm:\"updated\"`\n}\n\ntype UpdatedUpdate2 struct {\n\tId      int64\n\tUpdated int64 `xorm:\"updated\"`\n}\n\ntype UpdatedUpdate3 struct {\n\tId      int64\n\tUpdated int `xorm:\"updated bigint\"`\n}\n\ntype UpdatedUpdate4 struct {\n\tId      int64\n\tUpdated int `xorm:\"updated\"`\n}\n\ntype UpdatedUpdate5 struct {\n\tId      int64\n\tUpdated time.Time `xorm:\"updated bigint\"`\n}\n\nfunc TestUpdateUpdated(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tdi := new(UpdatedUpdate)\n\terr := testEngine.Sync2(di)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = testEngine.Insert(&UpdatedUpdate{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tci := &UpdatedUpdate{}\n\t_, err = testEngine.ID(1).Update(ci)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\thas, err := testEngine.ID(1).Get(di)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !has {\n\t\tt.Fatal(ErrNotExist)\n\t}\n\tif ci.Updated.Unix() != di.Updated.Unix() {\n\t\tt.Fatal(\"should equal:\", ci, di)\n\t}\n\tfmt.Println(\"ci:\", ci, \"di:\", di)\n\n\tdi2 := new(UpdatedUpdate2)\n\terr = testEngine.Sync2(di2)\n\tassert.NoError(t, err)\n\n\tnow := time.Now()\n\tvar di20 UpdatedUpdate2\n\tcnt, err := testEngine.Insert(&di20)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\tassert.True(t, now.Unix() <= di20.Updated)\n\n\tvar di21 UpdatedUpdate2\n\thas, err = testEngine.ID(di20.Id).Get(&di21)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, di20.Updated, di21.Updated)\n\n\tci2 := &UpdatedUpdate2{}\n\t_, err = testEngine.ID(1).Update(ci2)\n\tassert.NoError(t, err)\n\n\thas, err = testEngine.ID(1).Get(di2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, ci2.Updated, di2.Updated)\n\tassert.True(t, ci2.Updated >= di21.Updated)\n\n\tdi3 := new(UpdatedUpdate3)\n\terr = testEngine.Sync2(di3)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = testEngine.Insert(&UpdatedUpdate3{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tci3 := &UpdatedUpdate3{}\n\t_, err = testEngine.ID(1).Update(ci3)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\thas, err = testEngine.ID(1).Get(di3)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !has {\n\t\tt.Fatal(ErrNotExist)\n\t}\n\tif ci3.Updated != di3.Updated {\n\t\tt.Fatal(\"should equal:\", ci3, di3)\n\t}\n\tfmt.Println(\"ci3:\", ci3, \"di3:\", di3)\n\n\tdi4 := new(UpdatedUpdate4)\n\terr = testEngine.Sync2(di4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = testEngine.Insert(&UpdatedUpdate4{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tci4 := &UpdatedUpdate4{}\n\t_, err = testEngine.ID(1).Update(ci4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\thas, err = testEngine.ID(1).Get(di4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !has {\n\t\tt.Fatal(ErrNotExist)\n\t}\n\tif ci4.Updated != di4.Updated {\n\t\tt.Fatal(\"should equal:\", ci4, di4)\n\t}\n\tfmt.Println(\"ci4:\", ci4, \"di4:\", di4)\n\n\tdi5 := new(UpdatedUpdate5)\n\terr = testEngine.Sync2(di5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = testEngine.Insert(&UpdatedUpdate5{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tci5 := &UpdatedUpdate5{}\n\t_, err = testEngine.ID(1).Update(ci5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\thas, err = testEngine.ID(1).Get(di5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !has {\n\t\tt.Fatal(ErrNotExist)\n\t}\n\tif ci5.Updated.Unix() != di5.Updated.Unix() {\n\t\tt.Fatal(\"should equal:\", ci5, di5)\n\t}\n\tfmt.Println(\"ci5:\", ci5, \"di5:\", di5)\n}\n\nfunc TestUpdateSameMapper(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\toldMapper := testEngine.GetTableMapper()\n\ttestEngine.UnMapType(rValue(new(Userinfo)).Type())\n\ttestEngine.UnMapType(rValue(new(Condi)).Type())\n\ttestEngine.UnMapType(rValue(new(Article)).Type())\n\ttestEngine.UnMapType(rValue(new(UpdateAllCols)).Type())\n\ttestEngine.UnMapType(rValue(new(UpdateMustCols)).Type())\n\ttestEngine.UnMapType(rValue(new(UpdateIncr)).Type())\n\ttestEngine.SetMapper(core.SameMapper{})\n\tdefer func() {\n\t\ttestEngine.UnMapType(rValue(new(Userinfo)).Type())\n\t\ttestEngine.UnMapType(rValue(new(Condi)).Type())\n\t\ttestEngine.UnMapType(rValue(new(Article)).Type())\n\t\ttestEngine.UnMapType(rValue(new(UpdateAllCols)).Type())\n\t\ttestEngine.UnMapType(rValue(new(UpdateMustCols)).Type())\n\t\ttestEngine.UnMapType(rValue(new(UpdateIncr)).Type())\n\t\ttestEngine.SetMapper(oldMapper)\n\t}()\n\n\tassertSync(t, new(Userinfo))\n\n\t_, err := testEngine.Insert(&Userinfo{\n\t\tUsername: \"user1\",\n\t})\n\tassert.NoError(t, err)\n\n\tvar ori Userinfo\n\thas, err := testEngine.Get(&ori)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\t// update by id\n\tuser := Userinfo{Username: \"xxx\", Height: 1.2}\n\tcnt, err := testEngine.ID(ori.Uid).Update(&user)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tcondi := Condi{\"Username\": \"zzz\", \"Departname\": \"\"}\n\tcnt, err = testEngine.Table(&user).ID(ori.Uid).Update(&condi)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tcnt, err = testEngine.Update(&Userinfo{Username: \"yyy\"}, &user)\n\tassert.NoError(t, err)\n\n\ttotal, err := testEngine.Count(&user)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, cnt, total)\n\n\terr = testEngine.Sync(&Article{})\n\tassert.NoError(t, err)\n\n\tdefer func() {\n\t\terr = testEngine.DropTables(&Article{})\n\t\tassert.NoError(t, err)\n\t}()\n\n\ta := &Article{0, \"1\", \"2\", \"3\", \"4\", \"5\", 2}\n\tcnt, err = testEngine.Insert(a)\n\tassert.NoError(t, err)\n\n\tif cnt != 1 {\n\t\terr = errors.New(fmt.Sprintf(\"insert not returned 1 but %d\", cnt))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif a.Id == 0 {\n\t\terr = errors.New(\"insert returned id is 0\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tcnt, err = testEngine.ID(a.Id).Update(&Article{Name: \"6\"})\n\tassert.NoError(t, err)\n\n\tif cnt != 1 {\n\t\terr = errors.New(fmt.Sprintf(\"insert not returned 1 but %d\", cnt))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t\treturn\n\t}\n\n\tcol1 := &UpdateAllCols{}\n\terr = testEngine.Sync(col1)\n\tassert.NoError(t, err)\n\n\t_, err = testEngine.Insert(col1)\n\tassert.NoError(t, err)\n\n\tcol2 := &UpdateAllCols{col1.Id, true, \"\", nil}\n\t_, err = testEngine.ID(col2.Id).AllCols().Update(col2)\n\tassert.NoError(t, err)\n\n\tcol3 := &UpdateAllCols{}\n\thas, err = testEngine.ID(col2.Id).Get(col3)\n\tassert.NoError(t, err)\n\n\tif !has {\n\t\terr = errors.New(fmt.Sprintf(\"cannot get id %d\", col2.Id))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t\treturn\n\t}\n\n\tif *col2 != *col3 {\n\t\terr = errors.New(fmt.Sprintf(\"col2 should eq col3\"))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t\treturn\n\t}\n\n\t{\n\t\tcol1 := &UpdateMustCols{}\n\t\terr = testEngine.Sync(col1)\n\t\tassert.NoError(t, err)\n\n\t\t_, err = testEngine.Insert(col1)\n\t\tassert.NoError(t, err)\n\n\t\tcol2 := &UpdateMustCols{col1.Id, true, \"\"}\n\t\tboolStr := testEngine.GetColumnMapper().Obj2Table(\"Bool\")\n\t\tstringStr := testEngine.GetColumnMapper().Obj2Table(\"String\")\n\t\t_, err = testEngine.ID(col2.Id).MustCols(boolStr, stringStr).Update(col2)\n\t\tassert.NoError(t, err)\n\n\t\tcol3 := &UpdateMustCols{}\n\t\thas, err := testEngine.ID(col2.Id).Get(col3)\n\t\tassert.NoError(t, err)\n\n\t\tif !has {\n\t\t\terr = errors.New(fmt.Sprintf(\"cannot get id %d\", col2.Id))\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t\treturn\n\t\t}\n\n\t\tif *col2 != *col3 {\n\t\t\terr = errors.New(fmt.Sprintf(\"col2 should eq col3\"))\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t{\n\t\tcol1 := &UpdateIncr{}\n\t\terr = testEngine.Sync(col1)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\n\t\t_, err = testEngine.Insert(col1)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\n\t\tcnt, err := testEngine.ID(col1.Id).Incr(\"`Cnt`\").Update(col1)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t\tif cnt != 1 {\n\t\t\terr = errors.New(\"update incr failed\")\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\n\t\tnewCol := new(UpdateIncr)\n\t\thas, err := testEngine.ID(col1.Id).Get(newCol)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t\tif !has {\n\t\t\terr = errors.New(\"has incr failed\")\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t\tif 1 != newCol.Cnt {\n\t\t\terr = errors.New(\"incr failed\")\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\nfunc TestUseBool(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\tcnt1, err := testEngine.Count(&Userinfo{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tusers := make([]Userinfo, 0)\n\terr = testEngine.Find(&users)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tvar fNumber int64\n\tfor _, u := range users {\n\t\tif u.IsMan == false {\n\t\t\tfNumber += 1\n\t\t}\n\t}\n\n\tcnt2, err := testEngine.UseBool().Update(&Userinfo{IsMan: true})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif fNumber != cnt2 {\n\t\tfmt.Println(\"cnt1\", cnt1, \"fNumber\", fNumber, \"cnt2\", cnt2)\n\t\t/*err = errors.New(\"Updated number is not corrected.\")\n\t\t  t.Error(err)\n\t\t  panic(err)*/\n\t}\n\n\t_, err = testEngine.Update(&Userinfo{IsMan: true})\n\tif err == nil {\n\t\terr = errors.New(\"error condition\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestBool(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(Userinfo))\n\n\t_, err := testEngine.UseBool().Update(&Userinfo{IsMan: true})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tusers := make([]Userinfo, 0)\n\terr = testEngine.Find(&users)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tfor _, user := range users {\n\t\tif !user.IsMan {\n\t\t\terr = errors.New(\"update bool or find bool error\")\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\t_, err = testEngine.UseBool().Update(&Userinfo{IsMan: false})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tusers = make([]Userinfo, 0)\n\terr = testEngine.Find(&users)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tfor _, user := range users {\n\t\tif user.IsMan {\n\t\t\terr = errors.New(\"update bool or find bool error\")\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\nfunc TestNoUpdate(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype NoUpdate struct {\n\t\tId      int64\n\t\tContent string\n\t}\n\n\tassertSync(t, new(NoUpdate))\n\n\tcnt, err := testEngine.Insert(&NoUpdate{\n\t\tContent: \"test\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\t_, err = testEngine.ID(1).Update(&NoUpdate{})\n\tassert.Error(t, err)\n\tassert.EqualValues(t, \"No content found to be updated\", err.Error())\n}\n\nfunc TestNewUpdate(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype TbUserInfo struct {\n\t\tId       int64       `xorm:\"pk autoincr unique BIGINT\" json:\"id\"`\n\t\tPhone    string      `xorm:\"not null unique VARCHAR(20)\" json:\"phone\"`\n\t\tUserName string      `xorm:\"VARCHAR(20)\" json:\"user_name\"`\n\t\tGender   int         `xorm:\"default 0 INTEGER\" json:\"gender\"`\n\t\tPw       string      `xorm:\"VARCHAR(100)\" json:\"pw\"`\n\t\tToken    string      `xorm:\"TEXT\" json:\"token\"`\n\t\tAvatar   string      `xorm:\"TEXT\" json:\"avatar\"`\n\t\tExtras   interface{} `xorm:\"JSON\" json:\"extras\"`\n\t\tCreated  time.Time   `xorm:\"DATETIME created\"`\n\t\tUpdated  time.Time   `xorm:\"DATETIME updated\"`\n\t\tDeleted  time.Time   `xorm:\"DATETIME deleted\"`\n\t}\n\n\tassertSync(t, new(TbUserInfo))\n\n\ttargetUsr := TbUserInfo{Phone: \"13126564922\"}\n\tchangeUsr := TbUserInfo{Token: \"ABCDEFG\"}\n\taf, err := testEngine.Update(&changeUsr, &targetUsr)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 0, af)\n\n\taf, err = testEngine.Table(new(TbUserInfo)).Where(\"phone=?\", 13126564922).Update(&changeUsr)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 0, af)\n}\n\nfunc TestUpdateUpdate(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype PublicKeyUpdate struct {\n\t\tId          int64\n\t\tUpdatedUnix int64 `xorm:\"updated\"`\n\t}\n\n\tassertSync(t, new(PublicKeyUpdate))\n\n\tcnt, err := testEngine.ID(1).Cols(\"updated_unix\").Update(&PublicKeyUpdate{\n\t\tUpdatedUnix: time.Now().Unix(),\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 0, cnt)\n}\n\nfunc TestCreatedUpdated2(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype CreatedUpdatedStruct struct {\n\t\tId       int64\n\t\tName     string\n\t\tCreateAt time.Time `xorm:\"created\" json:\"create_at\"`\n\t\tUpdateAt time.Time `xorm:\"updated\" json:\"update_at\"`\n\t}\n\n\tassertSync(t, new(CreatedUpdatedStruct))\n\n\tvar s = CreatedUpdatedStruct{\n\t\tName: \"test\",\n\t}\n\tcnt, err := testEngine.Insert(&s)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\tassert.EqualValues(t, s.UpdateAt.Unix(), s.CreateAt.Unix())\n\n\ttime.Sleep(time.Second)\n\n\tvar s1 = CreatedUpdatedStruct{\n\t\tName:     \"test1\",\n\t\tCreateAt: s.CreateAt,\n\t\tUpdateAt: s.UpdateAt,\n\t}\n\n\tcnt, err = testEngine.ID(1).Update(&s1)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\tassert.EqualValues(t, s.CreateAt.Unix(), s1.CreateAt.Unix())\n\tassert.True(t, s1.UpdateAt.Unix() > s.UpdateAt.Unix())\n\n\tvar s2 CreatedUpdatedStruct\n\thas, err := testEngine.ID(1).Get(&s2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\tassert.EqualValues(t, s.CreateAt.Unix(), s2.CreateAt.Unix())\n\tassert.True(t, s2.UpdateAt.Unix() > s.UpdateAt.Unix())\n\tassert.True(t, s2.UpdateAt.Unix() > s2.CreateAt.Unix())\n}\n\nfunc TestDeletedUpdate(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype DeletedUpdatedStruct struct {\n\t\tId        int64\n\t\tName      string\n\t\tDeletedAt time.Time `xorm:\"deleted\"`\n\t}\n\n\tassertSync(t, new(DeletedUpdatedStruct))\n\n\tvar s = DeletedUpdatedStruct{\n\t\tName: \"test\",\n\t}\n\tcnt, err := testEngine.Insert(&s)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tcnt, err = testEngine.ID(s.Id).Delete(&DeletedUpdatedStruct{})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\ts.DeletedAt = time.Time{}\n\tcnt, err = testEngine.Unscoped().Nullable(\"deleted_at\").Update(&s)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar s1 DeletedUpdatedStruct\n\thas, err := testEngine.ID(s.Id).Get(&s1)\n\tassert.EqualValues(t, true, has)\n\n\tcnt, err = testEngine.ID(s.Id).Delete(&DeletedUpdatedStruct{})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tcnt, err = testEngine.ID(s.Id).Cols(\"deleted_at\").Update(&DeletedUpdatedStruct{})\n\tassert.EqualValues(t, \"No content found to be updated\", err.Error())\n\tassert.EqualValues(t, 0, cnt)\n\n\tcnt, err = testEngine.ID(s.Id).Unscoped().Cols(\"deleted_at\").Update(&DeletedUpdatedStruct{})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar s2 DeletedUpdatedStruct\n\thas, err = testEngine.ID(s.Id).Get(&s2)\n\tassert.EqualValues(t, true, has)\n}\n\nfunc TestUpdateMapCondition(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UpdateMapCondition struct {\n\t\tId     int64\n\t\tString string\n\t}\n\n\tassertSync(t, new(UpdateMapCondition))\n\n\tvar c = UpdateMapCondition{\n\t\tString: \"string\",\n\t}\n\t_, err := testEngine.Insert(&c)\n\tassert.NoError(t, err)\n\n\tcnt, err := testEngine.Update(&UpdateMapCondition{\n\t\tString: \"string1\",\n\t}, map[string]interface{}{\n\t\t\"id\": c.Id,\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar c2 UpdateMapCondition\n\thas, err := testEngine.ID(c.Id).Get(&c2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, \"string1\", c2.String)\n}\n\nfunc TestUpdateMapContent(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UpdateMapContent struct {\n\t\tId     int64\n\t\tName   string\n\t\tIsMan  bool\n\t\tAge    int\n\t\tGender int // 1 is man, 2 is woman\n\t}\n\n\tassertSync(t, new(UpdateMapContent))\n\n\tvar c = UpdateMapContent{\n\t\tName:   \"lunny\",\n\t\tIsMan:  true,\n\t\tGender: 1,\n\t\tAge:    18,\n\t}\n\t_, err := testEngine.Insert(&c)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 18, c.Age)\n\n\tcnt, err := testEngine.Table(new(UpdateMapContent)).ID(c.Id).Update(map[string]interface{}{\"age\": 0})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar c1 UpdateMapContent\n\thas, err := testEngine.ID(c.Id).Get(&c1)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 0, c1.Age)\n\n\tcnt, err = testEngine.Table(new(UpdateMapContent)).ID(c.Id).Update(map[string]interface{}{\n\t\t\"age\":    16,\n\t\t\"is_man\": false,\n\t\t\"gender\": 2,\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar c2 UpdateMapContent\n\thas, err = testEngine.ID(c.Id).Get(&c2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 16, c2.Age)\n\tassert.EqualValues(t, false, c2.IsMan)\n\tassert.EqualValues(t, 2, c2.Gender)\n\n\tcnt, err = testEngine.Table(testEngine.TableName(new(UpdateMapContent))).ID(c.Id).Update(map[string]interface{}{\n\t\t\"age\":    15,\n\t\t\"is_man\": true,\n\t\t\"gender\": 1,\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar c3 UpdateMapContent\n\thas, err = testEngine.ID(c.Id).Get(&c3)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 15, c3.Age)\n\tassert.EqualValues(t, true, c3.IsMan)\n\tassert.EqualValues(t, 1, c3.Gender)\n}\n\nfunc TestUpdateCondiBean(t *testing.T) {\n\ttype NeedUpdateBean struct {\n\t\tId   int64\n\t\tName string\n\t}\n\n\ttype NeedUpdateCondiBean struct {\n\t\tName string\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(NeedUpdateBean))\n\n\tcnt, err := testEngine.Insert(&NeedUpdateBean{\n\t\tName: \"name1\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\thas, err := testEngine.Exist(&NeedUpdateBean{\n\t\tName: \"name1\",\n\t})\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\tcnt, err = testEngine.Update(&NeedUpdateBean{\n\t\tName: \"name2\",\n\t}, &NeedUpdateCondiBean{\n\t\tName: \"name1\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\thas, err = testEngine.Exist(&NeedUpdateBean{\n\t\tName: \"name2\",\n\t})\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\tcnt, err = testEngine.Update(&NeedUpdateBean{\n\t\tName: \"name1\",\n\t}, NeedUpdateCondiBean{\n\t\tName: \"name2\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\thas, err = testEngine.Exist(&NeedUpdateBean{\n\t\tName: \"name1\",\n\t})\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n}\n\nfunc TestWhereCondErrorWhenUpdate(t *testing.T) {\n\ttype AuthRequestError struct {\n\t\tChallengeToken string\n\t\tRequestToken   string\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(AuthRequestError))\n\n\t_, err := testEngine.Cols(\"challenge_token\", \"request_token\", \"challenge_agent\", \"status\").\n\t\tWhere(&AuthRequestError{ChallengeToken: \"1\"}).\n\t\tUpdate(&AuthRequestError{\n\t\t\tChallengeToken: \"2\",\n\t\t})\n\tassert.Error(t, err)\n\tassert.EqualValues(t, ErrConditionType, err)\n}\n\nfunc TestUpdateDeleted(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UpdateDeletedStruct struct {\n\t\tId        int64\n\t\tName      string\n\t\tDeletedAt time.Time `xorm:\"deleted\"`\n\t}\n\n\tassertSync(t, new(UpdateDeletedStruct))\n\n\tvar s = UpdateDeletedStruct{\n\t\tName: \"test\",\n\t}\n\tcnt, err := testEngine.Insert(&s)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tcnt, err = testEngine.ID(s.Id).Delete(&UpdateDeletedStruct{})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tcnt, err = testEngine.ID(s.Id).Update(&UpdateDeletedStruct{\n\t\tName: \"test1\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 0, cnt)\n\n\tcnt, err = testEngine.Table(&UpdateDeletedStruct{}).ID(s.Id).Update(map[string]interface{}{\n\t\t\"name\": \"test1\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 0, cnt)\n\n\tcnt, err = testEngine.ID(s.Id).Unscoped().Update(&UpdateDeletedStruct{\n\t\tName: \"test1\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n}\n\nfunc TestUpdateExprs(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UpdateExprs struct {\n\t\tId        int64\n\t\tNumIssues int\n\t\tName      string\n\t}\n\n\tassertSync(t, new(UpdateExprs))\n\n\t_, err := testEngine.Insert(&UpdateExprs{\n\t\tNumIssues: 1,\n\t\tName:      \"lunny\",\n\t})\n\tassert.NoError(t, err)\n\n\t_, err = testEngine.SetExpr(\"num_issues\", \"num_issues+1\").AllCols().Update(&UpdateExprs{\n\t\tNumIssues: 3,\n\t\tName:      \"lunny xiao\",\n\t})\n\tassert.NoError(t, err)\n\n\tvar ue UpdateExprs\n\thas, err := testEngine.Get(&ue)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 2, ue.NumIssues)\n\tassert.EqualValues(t, \"lunny xiao\", ue.Name)\n}\n"
        },
        {
          "name": "statement.go",
          "type": "blob",
          "size": 34.3525390625,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"database/sql/driver\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n\n\t\"xorm.io/builder\"\n\t\"xorm.io/core\"\n)\n\n// Statement save all the sql info for executing SQL\ntype Statement struct {\n\tRefTable        *core.Table\n\tEngine          *Engine\n\tStart           int\n\tLimitN          int\n\tidParam         *core.PK\n\tOrderStr        string\n\tJoinStr         string\n\tjoinArgs        []interface{}\n\tGroupByStr      string\n\tHavingStr       string\n\tColumnStr       string\n\tselectStr       string\n\tuseAllCols      bool\n\tOmitStr         string\n\tAltTableName    string\n\ttableName       string\n\tRawSQL          string\n\tRawParams       []interface{}\n\tUseCascade      bool\n\tUseAutoJoin     bool\n\tStoreEngine     string\n\tCharset         string\n\tUseCache        bool\n\tUseAutoTime     bool\n\tnoAutoCondition bool\n\tIsDistinct      bool\n\tIsForUpdate     bool\n\tTableAlias      string\n\tallUseBool      bool\n\tcheckVersion    bool\n\tunscoped        bool\n\tcolumnMap       columnMap\n\tomitColumnMap   columnMap\n\tmustColumnMap   map[string]bool\n\tnullableMap     map[string]bool\n\tincrColumns     exprParams\n\tdecrColumns     exprParams\n\texprColumns     exprParams\n\tcond            builder.Cond\n\tbufferSize      int\n\tcontext         ContextCache\n\tlastError       error\n}\n\n// Init reset all the statement's fields\nfunc (statement *Statement) Init() {\n\tstatement.RefTable = nil\n\tstatement.Start = 0\n\tstatement.LimitN = 0\n\tstatement.OrderStr = \"\"\n\tstatement.UseCascade = true\n\tstatement.JoinStr = \"\"\n\tstatement.joinArgs = make([]interface{}, 0)\n\tstatement.GroupByStr = \"\"\n\tstatement.HavingStr = \"\"\n\tstatement.ColumnStr = \"\"\n\tstatement.OmitStr = \"\"\n\tstatement.columnMap = columnMap{}\n\tstatement.omitColumnMap = columnMap{}\n\tstatement.AltTableName = \"\"\n\tstatement.tableName = \"\"\n\tstatement.idParam = nil\n\tstatement.RawSQL = \"\"\n\tstatement.RawParams = make([]interface{}, 0)\n\tstatement.UseCache = true\n\tstatement.UseAutoTime = true\n\tstatement.noAutoCondition = false\n\tstatement.IsDistinct = false\n\tstatement.IsForUpdate = false\n\tstatement.TableAlias = \"\"\n\tstatement.selectStr = \"\"\n\tstatement.allUseBool = false\n\tstatement.useAllCols = false\n\tstatement.mustColumnMap = make(map[string]bool)\n\tstatement.nullableMap = make(map[string]bool)\n\tstatement.checkVersion = true\n\tstatement.unscoped = false\n\tstatement.incrColumns = exprParams{}\n\tstatement.decrColumns = exprParams{}\n\tstatement.exprColumns = exprParams{}\n\tstatement.cond = builder.NewCond()\n\tstatement.bufferSize = 0\n\tstatement.context = nil\n\tstatement.lastError = nil\n}\n\n// NoAutoCondition if you do not want convert bean's field as query condition, then use this function\nfunc (statement *Statement) NoAutoCondition(no ...bool) *Statement {\n\tstatement.noAutoCondition = true\n\tif len(no) > 0 {\n\t\tstatement.noAutoCondition = no[0]\n\t}\n\treturn statement\n}\n\n// Alias set the table alias\nfunc (statement *Statement) Alias(alias string) *Statement {\n\tstatement.TableAlias = alias\n\treturn statement\n}\n\n// SQL adds raw sql statement\nfunc (statement *Statement) SQL(query interface{}, args ...interface{}) *Statement {\n\tswitch query.(type) {\n\tcase (*builder.Builder):\n\t\tvar err error\n\t\tstatement.RawSQL, statement.RawParams, err = query.(*builder.Builder).ToSQL()\n\t\tif err != nil {\n\t\t\tstatement.lastError = err\n\t\t}\n\tcase string:\n\t\tstatement.RawSQL = query.(string)\n\t\tstatement.RawParams = args\n\tdefault:\n\t\tstatement.lastError = ErrUnSupportedSQLType\n\t}\n\n\treturn statement\n}\n\n// Where add Where statement\nfunc (statement *Statement) Where(query interface{}, args ...interface{}) *Statement {\n\treturn statement.And(query, args...)\n}\n\n// And add Where & and statement\nfunc (statement *Statement) And(query interface{}, args ...interface{}) *Statement {\n\tswitch query.(type) {\n\tcase string:\n\t\tcond := builder.Expr(query.(string), args...)\n\t\tstatement.cond = statement.cond.And(cond)\n\tcase map[string]interface{}:\n\t\tqueryMap := query.(map[string]interface{})\n\t\tnewMap := make(map[string]interface{})\n\t\tfor k, v := range queryMap {\n\t\t\tnewMap[statement.Engine.Quote(k)] = v\n\t\t}\n\t\tstatement.cond = statement.cond.And(builder.Eq(newMap))\n\tcase builder.Cond:\n\t\tcond := query.(builder.Cond)\n\t\tstatement.cond = statement.cond.And(cond)\n\t\tfor _, v := range args {\n\t\t\tif vv, ok := v.(builder.Cond); ok {\n\t\t\t\tstatement.cond = statement.cond.And(vv)\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tstatement.lastError = ErrConditionType\n\t}\n\n\treturn statement\n}\n\n// Or add Where & Or statement\nfunc (statement *Statement) Or(query interface{}, args ...interface{}) *Statement {\n\tswitch query.(type) {\n\tcase string:\n\t\tcond := builder.Expr(query.(string), args...)\n\t\tstatement.cond = statement.cond.Or(cond)\n\tcase map[string]interface{}:\n\t\tcond := builder.Eq(query.(map[string]interface{}))\n\t\tstatement.cond = statement.cond.Or(cond)\n\tcase builder.Cond:\n\t\tcond := query.(builder.Cond)\n\t\tstatement.cond = statement.cond.Or(cond)\n\t\tfor _, v := range args {\n\t\t\tif vv, ok := v.(builder.Cond); ok {\n\t\t\t\tstatement.cond = statement.cond.Or(vv)\n\t\t\t}\n\t\t}\n\tdefault:\n\t\t// TODO: not support condition type\n\t}\n\treturn statement\n}\n\n// In generate \"Where column IN (?) \" statement\nfunc (statement *Statement) In(column string, args ...interface{}) *Statement {\n\tin := builder.In(statement.Engine.Quote(column), args...)\n\tstatement.cond = statement.cond.And(in)\n\treturn statement\n}\n\n// NotIn generate \"Where column NOT IN (?) \" statement\nfunc (statement *Statement) NotIn(column string, args ...interface{}) *Statement {\n\tnotIn := builder.NotIn(statement.Engine.Quote(column), args...)\n\tstatement.cond = statement.cond.And(notIn)\n\treturn statement\n}\n\nfunc (statement *Statement) setRefValue(v reflect.Value) error {\n\tvar err error\n\tstatement.RefTable, err = statement.Engine.autoMapType(reflect.Indirect(v))\n\tif err != nil {\n\t\treturn err\n\t}\n\tstatement.tableName = statement.Engine.TableName(v, true)\n\treturn nil\n}\n\nfunc (statement *Statement) setRefBean(bean interface{}) error {\n\tvar err error\n\tstatement.RefTable, err = statement.Engine.autoMapType(rValue(bean))\n\tif err != nil {\n\t\treturn err\n\t}\n\tstatement.tableName = statement.Engine.TableName(bean, true)\n\treturn nil\n}\n\n// Auto generating update columnes and values according a struct\nfunc (statement *Statement) buildUpdates(bean interface{},\n\tincludeVersion, includeUpdated, includeNil,\n\tincludeAutoIncr, update bool) ([]string, []interface{}) {\n\tengine := statement.Engine\n\ttable := statement.RefTable\n\tallUseBool := statement.allUseBool\n\tuseAllCols := statement.useAllCols\n\tmustColumnMap := statement.mustColumnMap\n\tnullableMap := statement.nullableMap\n\tcolumnMap := statement.columnMap\n\tomitColumnMap := statement.omitColumnMap\n\tunscoped := statement.unscoped\n\n\tvar colNames = make([]string, 0)\n\tvar args = make([]interface{}, 0)\n\tfor _, col := range table.Columns() {\n\t\tif !includeVersion && col.IsVersion {\n\t\t\tcontinue\n\t\t}\n\t\tif col.IsCreated {\n\t\t\tcontinue\n\t\t}\n\t\tif !includeUpdated && col.IsUpdated {\n\t\t\tcontinue\n\t\t}\n\t\tif !includeAutoIncr && col.IsAutoIncrement {\n\t\t\tcontinue\n\t\t}\n\t\tif col.IsDeleted && !unscoped {\n\t\t\tcontinue\n\t\t}\n\t\tif omitColumnMap.contain(col.Name) {\n\t\t\tcontinue\n\t\t}\n\t\tif len(columnMap) > 0 && !columnMap.contain(col.Name) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif col.MapType == core.ONLYFROMDB {\n\t\t\tcontinue\n\t\t}\n\n\t\tif statement.incrColumns.isColExist(col.Name) {\n\t\t\tcontinue\n\t\t} else if statement.decrColumns.isColExist(col.Name) {\n\t\t\tcontinue\n\t\t} else if statement.exprColumns.isColExist(col.Name) {\n\t\t\tcontinue\n\t\t}\n\n\t\tfieldValuePtr, err := col.ValueOf(bean)\n\t\tif err != nil {\n\t\t\tengine.logger.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tfieldValue := *fieldValuePtr\n\t\tfieldType := reflect.TypeOf(fieldValue.Interface())\n\t\tif fieldType == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\trequiredField := useAllCols\n\t\tincludeNil := useAllCols\n\n\t\tif b, ok := getFlagForColumn(mustColumnMap, col); ok {\n\t\t\tif b {\n\t\t\t\trequiredField = true\n\t\t\t} else {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// !evalphobia! set fieldValue as nil when column is nullable and zero-value\n\t\tif b, ok := getFlagForColumn(nullableMap, col); ok {\n\t\t\tif b && col.Nullable && isZero(fieldValue.Interface()) {\n\t\t\t\tvar nilValue *int\n\t\t\t\tfieldValue = reflect.ValueOf(nilValue)\n\t\t\t\tfieldType = reflect.TypeOf(fieldValue.Interface())\n\t\t\t\tincludeNil = true\n\t\t\t}\n\t\t}\n\n\t\tvar val interface{}\n\n\t\tif fieldValue.CanAddr() {\n\t\t\tif structConvert, ok := fieldValue.Addr().Interface().(core.Conversion); ok {\n\t\t\t\tdata, err := structConvert.ToDB()\n\t\t\t\tif err != nil {\n\t\t\t\t\tengine.logger.Error(err)\n\t\t\t\t} else {\n\t\t\t\t\tval = data\n\t\t\t\t}\n\t\t\t\tgoto APPEND\n\t\t\t}\n\t\t}\n\n\t\tif structConvert, ok := fieldValue.Interface().(core.Conversion); ok {\n\t\t\tdata, err := structConvert.ToDB()\n\t\t\tif err != nil {\n\t\t\t\tengine.logger.Error(err)\n\t\t\t} else {\n\t\t\t\tval = data\n\t\t\t}\n\t\t\tgoto APPEND\n\t\t}\n\n\t\tif fieldType.Kind() == reflect.Ptr {\n\t\t\tif fieldValue.IsNil() {\n\t\t\t\tif includeNil {\n\t\t\t\t\targs = append(args, nil)\n\t\t\t\t\tcolNames = append(colNames, fmt.Sprintf(\"%v=?\", engine.Quote(col.Name)))\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t} else if !fieldValue.IsValid() {\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\t// dereference ptr type to instance type\n\t\t\t\tfieldValue = fieldValue.Elem()\n\t\t\t\tfieldType = reflect.TypeOf(fieldValue.Interface())\n\t\t\t\trequiredField = true\n\t\t\t}\n\t\t}\n\n\t\tswitch fieldType.Kind() {\n\t\tcase reflect.Bool:\n\t\t\tif allUseBool || requiredField {\n\t\t\t\tval = fieldValue.Interface()\n\t\t\t} else {\n\t\t\t\t// if a bool in a struct, it will not be as a condition because it default is false,\n\t\t\t\t// please use Where() instead\n\t\t\t\tcontinue\n\t\t\t}\n\t\tcase reflect.String:\n\t\t\tif !requiredField && fieldValue.String() == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// for MyString, should convert to string or panic\n\t\t\tif fieldType.String() != reflect.String.String() {\n\t\t\t\tval = fieldValue.String()\n\t\t\t} else {\n\t\t\t\tval = fieldValue.Interface()\n\t\t\t}\n\t\tcase reflect.Int8, reflect.Int16, reflect.Int, reflect.Int32, reflect.Int64:\n\t\t\tif !requiredField && fieldValue.Int() == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tval = fieldValue.Interface()\n\t\tcase reflect.Float32, reflect.Float64:\n\t\t\tif !requiredField && fieldValue.Float() == 0.0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tval = fieldValue.Interface()\n\t\tcase reflect.Uint8, reflect.Uint16, reflect.Uint, reflect.Uint32, reflect.Uint64:\n\t\t\tif !requiredField && fieldValue.Uint() == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tt := int64(fieldValue.Uint())\n\t\t\tval = reflect.ValueOf(&t).Interface()\n\t\tcase reflect.Struct:\n\t\t\tif fieldType.ConvertibleTo(core.TimeType) {\n\t\t\t\tt := fieldValue.Convert(core.TimeType).Interface().(time.Time)\n\t\t\t\tif !requiredField && (t.IsZero() || !fieldValue.IsValid()) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tval = engine.formatColTime(col, t)\n\t\t\t} else if nulType, ok := fieldValue.Interface().(driver.Valuer); ok {\n\t\t\t\tval, _ = nulType.Value()\n\t\t\t} else {\n\t\t\t\tif !col.SQLType.IsJson() {\n\t\t\t\t\tengine.autoMapType(fieldValue)\n\t\t\t\t\tif table, ok := engine.Tables[fieldValue.Type()]; ok {\n\t\t\t\t\t\tif len(table.PrimaryKeys) == 1 {\n\t\t\t\t\t\t\tpkField := reflect.Indirect(fieldValue).FieldByName(table.PKColumns()[0].FieldName)\n\t\t\t\t\t\t\t// fix non-int pk issues\n\t\t\t\t\t\t\tif pkField.IsValid() && (!requiredField && !isZero(pkField.Interface())) {\n\t\t\t\t\t\t\t\tval = pkField.Interface()\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// TODO: how to handler?\n\t\t\t\t\t\t\tpanic(\"not supported\")\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tval = fieldValue.Interface()\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Blank struct could not be as update data\n\t\t\t\t\tif requiredField || !isStructZero(fieldValue) {\n\t\t\t\t\t\tbytes, err := DefaultJSONHandler.Marshal(fieldValue.Interface())\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tpanic(fmt.Sprintf(\"mashal %v failed\", fieldValue.Interface()))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif col.SQLType.IsText() {\n\t\t\t\t\t\t\tval = string(bytes)\n\t\t\t\t\t\t} else if col.SQLType.IsBlob() {\n\t\t\t\t\t\t\tval = bytes\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcase reflect.Array, reflect.Slice, reflect.Map:\n\t\t\tif !requiredField {\n\t\t\t\tif fieldValue == reflect.Zero(fieldType) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif fieldType.Kind() == reflect.Array {\n\t\t\t\t\tif isArrayValueZero(fieldValue) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t} else if fieldValue.IsNil() || !fieldValue.IsValid() || fieldValue.Len() == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif col.SQLType.IsText() {\n\t\t\t\tbytes, err := DefaultJSONHandler.Marshal(fieldValue.Interface())\n\t\t\t\tif err != nil {\n\t\t\t\t\tengine.logger.Error(err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tval = string(bytes)\n\t\t\t} else if col.SQLType.IsBlob() {\n\t\t\t\tvar bytes []byte\n\t\t\t\tvar err error\n\t\t\t\tif fieldType.Kind() == reflect.Slice &&\n\t\t\t\t\tfieldType.Elem().Kind() == reflect.Uint8 {\n\t\t\t\t\tif fieldValue.Len() > 0 {\n\t\t\t\t\t\tval = fieldValue.Bytes()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t} else if fieldType.Kind() == reflect.Array &&\n\t\t\t\t\tfieldType.Elem().Kind() == reflect.Uint8 {\n\t\t\t\t\tval = fieldValue.Slice(0, 0).Interface()\n\t\t\t\t} else {\n\t\t\t\t\tbytes, err = DefaultJSONHandler.Marshal(fieldValue.Interface())\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tengine.logger.Error(err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tval = bytes\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontinue\n\t\t\t}\n\t\tdefault:\n\t\t\tval = fieldValue.Interface()\n\t\t}\n\n\tAPPEND:\n\t\targs = append(args, val)\n\t\tif col.IsPrimaryKey && engine.dialect.DBType() == \"ql\" {\n\t\t\tcontinue\n\t\t}\n\t\tcolNames = append(colNames, fmt.Sprintf(\"%v = ?\", engine.Quote(col.Name)))\n\t}\n\n\treturn colNames, args\n}\n\nfunc (statement *Statement) needTableName() bool {\n\treturn len(statement.JoinStr) > 0\n}\n\nfunc (statement *Statement) colName(col *core.Column, tableName string) string {\n\tif statement.needTableName() {\n\t\tvar nm = tableName\n\t\tif len(statement.TableAlias) > 0 {\n\t\t\tnm = statement.TableAlias\n\t\t}\n\t\treturn statement.Engine.Quote(nm) + \".\" + statement.Engine.Quote(col.Name)\n\t}\n\treturn statement.Engine.Quote(col.Name)\n}\n\n// TableName return current tableName\nfunc (statement *Statement) TableName() string {\n\tif statement.AltTableName != \"\" {\n\t\treturn statement.AltTableName\n\t}\n\n\treturn statement.tableName\n}\n\n// ID generate \"where id = ? \" statement or for composite key \"where key1 = ? and key2 = ?\"\nfunc (statement *Statement) ID(id interface{}) *Statement {\n\tidValue := reflect.ValueOf(id)\n\tidType := reflect.TypeOf(idValue.Interface())\n\n\tswitch idType {\n\tcase ptrPkType:\n\t\tif pkPtr, ok := (id).(*core.PK); ok {\n\t\t\tstatement.idParam = pkPtr\n\t\t\treturn statement\n\t\t}\n\tcase pkType:\n\t\tif pk, ok := (id).(core.PK); ok {\n\t\t\tstatement.idParam = &pk\n\t\t\treturn statement\n\t\t}\n\t}\n\n\tswitch idType.Kind() {\n\tcase reflect.String:\n\t\tstatement.idParam = &core.PK{idValue.Convert(reflect.TypeOf(\"\")).Interface()}\n\t\treturn statement\n\t}\n\n\tstatement.idParam = &core.PK{id}\n\treturn statement\n}\n\n// Incr Generate  \"Update ... Set column = column + arg\" statement\nfunc (statement *Statement) Incr(column string, arg ...interface{}) *Statement {\n\tif len(arg) > 0 {\n\t\tstatement.incrColumns.addParam(column, arg[0])\n\t} else {\n\t\tstatement.incrColumns.addParam(column, 1)\n\t}\n\treturn statement\n}\n\n// Decr Generate  \"Update ... Set column = column - arg\" statement\nfunc (statement *Statement) Decr(column string, arg ...interface{}) *Statement {\n\tif len(arg) > 0 {\n\t\tstatement.decrColumns.addParam(column, arg[0])\n\t} else {\n\t\tstatement.decrColumns.addParam(column, 1)\n\t}\n\treturn statement\n}\n\n// SetExpr Generate  \"Update ... Set column = {expression}\" statement\nfunc (statement *Statement) SetExpr(column string, expression interface{}) *Statement {\n\tstatement.exprColumns.addParam(column, expression)\n\treturn statement\n}\n\nfunc (statement *Statement) col2NewColsWithQuote(columns ...string) []string {\n\tnewColumns := make([]string, 0)\n\tquotes := append(strings.Split(statement.Engine.Quote(\"\"), \"\"), \"`\")\n\tfor _, col := range columns {\n\t\tnewColumns = append(newColumns, statement.Engine.Quote(eraseAny(col, quotes...)))\n\t}\n\treturn newColumns\n}\n\nfunc (statement *Statement) colmap2NewColsWithQuote() []string {\n\tnewColumns := make([]string, len(statement.columnMap), len(statement.columnMap))\n\tcopy(newColumns, statement.columnMap)\n\tfor i := 0; i < len(statement.columnMap); i++ {\n\t\tnewColumns[i] = statement.Engine.Quote(newColumns[i])\n\t}\n\treturn newColumns\n}\n\n// Distinct generates \"DISTINCT col1, col2 \" statement\nfunc (statement *Statement) Distinct(columns ...string) *Statement {\n\tstatement.IsDistinct = true\n\tstatement.Cols(columns...)\n\treturn statement\n}\n\n// ForUpdate generates \"SELECT ... FOR UPDATE\" statement\nfunc (statement *Statement) ForUpdate() *Statement {\n\tstatement.IsForUpdate = true\n\treturn statement\n}\n\n// Select replace select\nfunc (statement *Statement) Select(str string) *Statement {\n\tstatement.selectStr = str\n\treturn statement\n}\n\n// Cols generate \"col1, col2\" statement\nfunc (statement *Statement) Cols(columns ...string) *Statement {\n\tcols := col2NewCols(columns...)\n\tfor _, nc := range cols {\n\t\tstatement.columnMap.add(nc)\n\t}\n\n\tnewColumns := statement.colmap2NewColsWithQuote()\n\n\tstatement.ColumnStr = strings.Join(newColumns, \", \")\n\tstatement.ColumnStr = strings.Replace(statement.ColumnStr, statement.Engine.quote(\"*\"), \"*\", -1)\n\treturn statement\n}\n\n// AllCols update use only: update all columns\nfunc (statement *Statement) AllCols() *Statement {\n\tstatement.useAllCols = true\n\treturn statement\n}\n\n// MustCols update use only: must update columns\nfunc (statement *Statement) MustCols(columns ...string) *Statement {\n\tnewColumns := col2NewCols(columns...)\n\tfor _, nc := range newColumns {\n\t\tstatement.mustColumnMap[strings.ToLower(nc)] = true\n\t}\n\treturn statement\n}\n\n// UseBool indicates that use bool fields as update contents and query contiditions\nfunc (statement *Statement) UseBool(columns ...string) *Statement {\n\tif len(columns) > 0 {\n\t\tstatement.MustCols(columns...)\n\t} else {\n\t\tstatement.allUseBool = true\n\t}\n\treturn statement\n}\n\n// Omit do not use the columns\nfunc (statement *Statement) Omit(columns ...string) {\n\tnewColumns := col2NewCols(columns...)\n\tfor _, nc := range newColumns {\n\t\tstatement.omitColumnMap = append(statement.omitColumnMap, nc)\n\t}\n\tstatement.OmitStr = statement.Engine.Quote(strings.Join(newColumns, statement.Engine.Quote(\", \")))\n}\n\n// Nullable Update use only: update columns to null when value is nullable and zero-value\nfunc (statement *Statement) Nullable(columns ...string) {\n\tnewColumns := col2NewCols(columns...)\n\tfor _, nc := range newColumns {\n\t\tstatement.nullableMap[strings.ToLower(nc)] = true\n\t}\n}\n\n// Top generate LIMIT limit statement\nfunc (statement *Statement) Top(limit int) *Statement {\n\tstatement.Limit(limit)\n\treturn statement\n}\n\n// Limit generate LIMIT start, limit statement\nfunc (statement *Statement) Limit(limit int, start ...int) *Statement {\n\tstatement.LimitN = limit\n\tif len(start) > 0 {\n\t\tstatement.Start = start[0]\n\t}\n\treturn statement\n}\n\n// OrderBy generate \"Order By order\" statement\nfunc (statement *Statement) OrderBy(order string) *Statement {\n\tif len(statement.OrderStr) > 0 {\n\t\tstatement.OrderStr += \", \"\n\t}\n\tstatement.OrderStr += order\n\treturn statement\n}\n\n// Desc generate `ORDER BY xx DESC`\nfunc (statement *Statement) Desc(colNames ...string) *Statement {\n\tvar buf strings.Builder\n\tif len(statement.OrderStr) > 0 {\n\t\tfmt.Fprint(&buf, statement.OrderStr, \", \")\n\t}\n\tnewColNames := statement.col2NewColsWithQuote(colNames...)\n\tfmt.Fprintf(&buf, \"%v DESC\", strings.Join(newColNames, \" DESC, \"))\n\tstatement.OrderStr = buf.String()\n\treturn statement\n}\n\n// Asc provide asc order by query condition, the input parameters are columns.\nfunc (statement *Statement) Asc(colNames ...string) *Statement {\n\tvar buf strings.Builder\n\tif len(statement.OrderStr) > 0 {\n\t\tfmt.Fprint(&buf, statement.OrderStr, \", \")\n\t}\n\tnewColNames := statement.col2NewColsWithQuote(colNames...)\n\tfmt.Fprintf(&buf, \"%v ASC\", strings.Join(newColNames, \" ASC, \"))\n\tstatement.OrderStr = buf.String()\n\treturn statement\n}\n\n// Table tempororily set table name, the parameter could be a string or a pointer of struct\nfunc (statement *Statement) Table(tableNameOrBean interface{}) *Statement {\n\tv := rValue(tableNameOrBean)\n\tt := v.Type()\n\tif t.Kind() == reflect.Struct {\n\t\tvar err error\n\t\tstatement.RefTable, err = statement.Engine.autoMapType(v)\n\t\tif err != nil {\n\t\t\tstatement.Engine.logger.Error(err)\n\t\t\treturn statement\n\t\t}\n\t}\n\n\tstatement.AltTableName = statement.Engine.TableName(tableNameOrBean, true)\n\treturn statement\n}\n\n// Join The joinOP should be one of INNER, LEFT OUTER, CROSS etc - this will be prepended to JOIN\nfunc (statement *Statement) Join(joinOP string, tablename interface{}, condition string, args ...interface{}) *Statement {\n\tvar buf strings.Builder\n\tif len(statement.JoinStr) > 0 {\n\t\tfmt.Fprintf(&buf, \"%v %v JOIN \", statement.JoinStr, joinOP)\n\t} else {\n\t\tfmt.Fprintf(&buf, \"%v JOIN \", joinOP)\n\t}\n\n\tswitch tp := tablename.(type) {\n\tcase builder.Builder:\n\t\tsubSQL, subQueryArgs, err := tp.ToSQL()\n\t\tif err != nil {\n\t\t\tstatement.lastError = err\n\t\t\treturn statement\n\t\t}\n\t\ttbs := strings.Split(tp.TableName(), \".\")\n\t\tquotes := append(strings.Split(statement.Engine.Quote(\"\"), \"\"), \"`\")\n\n\t\tvar aliasName = strings.Trim(tbs[len(tbs)-1], strings.Join(quotes, \"\"))\n\t\tfmt.Fprintf(&buf, \"(%s) %s ON %v\", subSQL, aliasName, condition)\n\t\tstatement.joinArgs = append(statement.joinArgs, subQueryArgs...)\n\tcase *builder.Builder:\n\t\tsubSQL, subQueryArgs, err := tp.ToSQL()\n\t\tif err != nil {\n\t\t\tstatement.lastError = err\n\t\t\treturn statement\n\t\t}\n\t\ttbs := strings.Split(tp.TableName(), \".\")\n\t\tquotes := append(strings.Split(statement.Engine.Quote(\"\"), \"\"), \"`\")\n\n\t\tvar aliasName = strings.Trim(tbs[len(tbs)-1], strings.Join(quotes, \"\"))\n\t\tfmt.Fprintf(&buf, \"(%s) %s ON %v\", subSQL, aliasName, condition)\n\t\tstatement.joinArgs = append(statement.joinArgs, subQueryArgs...)\n\tdefault:\n\t\ttbName := statement.Engine.TableName(tablename, true)\n\t\tfmt.Fprintf(&buf, \"%s ON %v\", tbName, condition)\n\t}\n\n\tstatement.JoinStr = buf.String()\n\tstatement.joinArgs = append(statement.joinArgs, args...)\n\treturn statement\n}\n\n// GroupBy generate \"Group By keys\" statement\nfunc (statement *Statement) GroupBy(keys string) *Statement {\n\tstatement.GroupByStr = keys\n\treturn statement\n}\n\n// Having generate \"Having conditions\" statement\nfunc (statement *Statement) Having(conditions string) *Statement {\n\tstatement.HavingStr = fmt.Sprintf(\"HAVING %v\", conditions)\n\treturn statement\n}\n\n// Unscoped always disable struct tag \"deleted\"\nfunc (statement *Statement) Unscoped() *Statement {\n\tstatement.unscoped = true\n\treturn statement\n}\n\nfunc (statement *Statement) genColumnStr() string {\n\tif statement.RefTable == nil {\n\t\treturn \"\"\n\t}\n\n\tvar buf strings.Builder\n\tcolumns := statement.RefTable.Columns()\n\n\tfor _, col := range columns {\n\t\tif statement.omitColumnMap.contain(col.Name) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(statement.columnMap) > 0 && !statement.columnMap.contain(col.Name) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif col.MapType == core.ONLYTODB {\n\t\t\tcontinue\n\t\t}\n\n\t\tif buf.Len() != 0 {\n\t\t\tbuf.WriteString(\", \")\n\t\t}\n\n\t\tif statement.JoinStr != \"\" {\n\t\t\tif statement.TableAlias != \"\" {\n\t\t\t\tbuf.WriteString(statement.TableAlias)\n\t\t\t} else {\n\t\t\t\tbuf.WriteString(statement.TableName())\n\t\t\t}\n\n\t\t\tbuf.WriteString(\".\")\n\t\t}\n\n\t\tstatement.Engine.QuoteTo(&buf, col.Name)\n\t}\n\n\treturn buf.String()\n}\n\nfunc (statement *Statement) genCreateTableSQL() string {\n\treturn statement.Engine.dialect.CreateTableSql(statement.RefTable, statement.TableName(),\n\t\tstatement.StoreEngine, statement.Charset)\n}\n\nfunc (statement *Statement) genIndexSQL() []string {\n\tvar sqls []string\n\ttbName := statement.TableName()\n\tfor _, index := range statement.RefTable.Indexes {\n\t\tif index.Type == core.IndexType {\n\t\t\tsql := statement.Engine.dialect.CreateIndexSql(tbName, index)\n\t\t\t/*idxTBName := strings.Replace(tbName, \".\", \"_\", -1)\n\t\t\tidxTBName = strings.Replace(idxTBName, `\"`, \"\", -1)\n\t\t\tsql := fmt.Sprintf(\"CREATE INDEX %v ON %v (%v);\", quote(indexName(idxTBName, idxName)),\n\t\t\t\tquote(tbName), quote(strings.Join(index.Cols, quote(\",\"))))*/\n\t\t\tsqls = append(sqls, sql)\n\t\t}\n\t}\n\treturn sqls\n}\n\nfunc uniqueName(tableName, uqeName string) string {\n\treturn fmt.Sprintf(\"UQE_%v_%v\", tableName, uqeName)\n}\n\nfunc (statement *Statement) genUniqueSQL() []string {\n\tvar sqls []string\n\ttbName := statement.TableName()\n\tfor _, index := range statement.RefTable.Indexes {\n\t\tif index.Type == core.UniqueType {\n\t\t\tsql := statement.Engine.dialect.CreateIndexSql(tbName, index)\n\t\t\tsqls = append(sqls, sql)\n\t\t}\n\t}\n\treturn sqls\n}\n\nfunc (statement *Statement) genDelIndexSQL() []string {\n\tvar sqls []string\n\ttbName := statement.TableName()\n\tidxPrefixName := strings.Replace(tbName, `\"`, \"\", -1)\n\tidxPrefixName = strings.Replace(idxPrefixName, `.`, \"_\", -1)\n\tfor idxName, index := range statement.RefTable.Indexes {\n\t\tvar rIdxName string\n\t\tif index.Type == core.UniqueType {\n\t\t\trIdxName = uniqueName(idxPrefixName, idxName)\n\t\t} else if index.Type == core.IndexType {\n\t\t\trIdxName = indexName(idxPrefixName, idxName)\n\t\t}\n\t\tsql := fmt.Sprintf(\"DROP INDEX %v\", statement.Engine.Quote(statement.Engine.TableName(rIdxName, true)))\n\t\tif statement.Engine.dialect.IndexOnTable() {\n\t\t\tsql += fmt.Sprintf(\" ON %v\", statement.Engine.Quote(tbName))\n\t\t}\n\t\tsqls = append(sqls, sql)\n\t}\n\treturn sqls\n}\n\nfunc (statement *Statement) genAddColumnStr(col *core.Column) (string, []interface{}) {\n\tquote := statement.Engine.Quote\n\tsql := fmt.Sprintf(\"ALTER TABLE %v ADD %v\", quote(statement.TableName()),\n\t\tcol.String(statement.Engine.dialect))\n\tif statement.Engine.dialect.DBType() == core.MYSQL && len(col.Comment) > 0 {\n\t\tsql += \" COMMENT '\" + col.Comment + \"'\"\n\t}\n\tsql += \";\"\n\treturn sql, []interface{}{}\n}\n\nfunc (statement *Statement) buildConds(table *core.Table, bean interface{}, includeVersion bool, includeUpdated bool, includeNil bool, includeAutoIncr bool, addedTableName bool) (builder.Cond, error) {\n\treturn statement.Engine.buildConds(table, bean, includeVersion, includeUpdated, includeNil, includeAutoIncr, statement.allUseBool, statement.useAllCols,\n\t\tstatement.unscoped, statement.mustColumnMap, statement.TableName(), statement.TableAlias, addedTableName)\n}\n\nfunc (statement *Statement) mergeConds(bean interface{}) error {\n\tif !statement.noAutoCondition {\n\t\tvar addedTableName = (len(statement.JoinStr) > 0)\n\t\tautoCond, err := statement.buildConds(statement.RefTable, bean, true, true, false, true, addedTableName)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tstatement.cond = statement.cond.And(autoCond)\n\t}\n\n\tif err := statement.processIDParam(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (statement *Statement) genConds(bean interface{}) (string, []interface{}, error) {\n\tif err := statement.mergeConds(bean); err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\treturn builder.ToSQL(statement.cond)\n}\n\nfunc (statement *Statement) genGetSQL(bean interface{}) (string, []interface{}, error) {\n\tv := rValue(bean)\n\tisStruct := v.Kind() == reflect.Struct\n\tif isStruct {\n\t\tstatement.setRefBean(bean)\n\t}\n\n\tvar columnStr = statement.ColumnStr\n\tif len(statement.selectStr) > 0 {\n\t\tcolumnStr = statement.selectStr\n\t} else {\n\t\t// TODO: always generate column names, not use * even if join\n\t\tif len(statement.JoinStr) == 0 {\n\t\t\tif len(columnStr) == 0 {\n\t\t\t\tif len(statement.GroupByStr) > 0 {\n\t\t\t\t\tcolumnStr = statement.Engine.quoteColumns(statement.GroupByStr)\n\t\t\t\t} else {\n\t\t\t\t\tcolumnStr = statement.genColumnStr()\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif len(columnStr) == 0 {\n\t\t\t\tif len(statement.GroupByStr) > 0 {\n\t\t\t\t\tcolumnStr = statement.Engine.quoteColumns(statement.GroupByStr)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(columnStr) == 0 {\n\t\tcolumnStr = \"*\"\n\t}\n\n\tif isStruct {\n\t\tif err := statement.mergeConds(bean); err != nil {\n\t\t\treturn \"\", nil, err\n\t\t}\n\t} else {\n\t\tif err := statement.processIDParam(); err != nil {\n\t\t\treturn \"\", nil, err\n\t\t}\n\t}\n\tcondSQL, condArgs, err := builder.ToSQL(statement.cond)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\tsqlStr, err := statement.genSelectSQL(columnStr, condSQL, true, true)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\treturn sqlStr, append(statement.joinArgs, condArgs...), nil\n}\n\nfunc (statement *Statement) genCountSQL(beans ...interface{}) (string, []interface{}, error) {\n\tvar condSQL string\n\tvar condArgs []interface{}\n\tvar err error\n\tif len(beans) > 0 {\n\t\tstatement.setRefBean(beans[0])\n\t\tcondSQL, condArgs, err = statement.genConds(beans[0])\n\t} else {\n\t\tcondSQL, condArgs, err = builder.ToSQL(statement.cond)\n\t}\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\tvar selectSQL = statement.selectStr\n\tif len(selectSQL) <= 0 {\n\t\tif statement.IsDistinct {\n\t\t\tselectSQL = fmt.Sprintf(\"count(DISTINCT %s)\", statement.ColumnStr)\n\t\t} else {\n\t\t\tselectSQL = \"count(*)\"\n\t\t}\n\t}\n\tsqlStr, err := statement.genSelectSQL(selectSQL, condSQL, false, false)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\treturn sqlStr, append(statement.joinArgs, condArgs...), nil\n}\n\nfunc (statement *Statement) genSumSQL(bean interface{}, columns ...string) (string, []interface{}, error) {\n\tstatement.setRefBean(bean)\n\n\tvar sumStrs = make([]string, 0, len(columns))\n\tfor _, colName := range columns {\n\t\tif !strings.Contains(colName, \" \") && !strings.Contains(colName, \"(\") {\n\t\t\tcolName = statement.Engine.Quote(colName)\n\t\t}\n\t\tsumStrs = append(sumStrs, fmt.Sprintf(\"COALESCE(sum(%s),0)\", colName))\n\t}\n\tsumSelect := strings.Join(sumStrs, \", \")\n\n\tcondSQL, condArgs, err := statement.genConds(bean)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\tsqlStr, err := statement.genSelectSQL(sumSelect, condSQL, true, true)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\treturn sqlStr, append(statement.joinArgs, condArgs...), nil\n}\n\nfunc (statement *Statement) genSelectSQL(columnStr, condSQL string, needLimit, needOrderBy bool) (string, error) {\n\tvar (\n\t\tdistinct                  string\n\t\tdialect                   = statement.Engine.Dialect()\n\t\tquote                     = statement.Engine.Quote\n\t\tfromStr                   = \" FROM \"\n\t\ttop, mssqlCondi, whereStr string\n\t)\n\tif statement.IsDistinct && !strings.HasPrefix(columnStr, \"count\") {\n\t\tdistinct = \"DISTINCT \"\n\t}\n\tif len(condSQL) > 0 {\n\t\twhereStr = \" WHERE \" + condSQL\n\t}\n\n\tif dialect.DBType() == core.MSSQL && strings.Contains(statement.TableName(), \"..\") {\n\t\tfromStr += statement.TableName()\n\t} else {\n\t\tfromStr += quote(statement.TableName())\n\t}\n\n\tif statement.TableAlias != \"\" {\n\t\tif dialect.DBType() == core.ORACLE {\n\t\t\tfromStr += \" \" + quote(statement.TableAlias)\n\t\t} else {\n\t\t\tfromStr += \" AS \" + quote(statement.TableAlias)\n\t\t}\n\t}\n\tif statement.JoinStr != \"\" {\n\t\tfromStr = fmt.Sprintf(\"%v %v\", fromStr, statement.JoinStr)\n\t}\n\n\tif dialect.DBType() == core.MSSQL {\n\t\tif statement.LimitN > 0 {\n\t\t\ttop = fmt.Sprintf(\"TOP %d \", statement.LimitN)\n\t\t}\n\t\tif statement.Start > 0 {\n\t\t\tvar column string\n\t\t\tif len(statement.RefTable.PKColumns()) == 0 {\n\t\t\t\tfor _, index := range statement.RefTable.Indexes {\n\t\t\t\t\tif len(index.Cols) == 1 {\n\t\t\t\t\t\tcolumn = index.Cols[0]\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif len(column) == 0 {\n\t\t\t\t\tcolumn = statement.RefTable.ColumnsSeq()[0]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcolumn = statement.RefTable.PKColumns()[0].Name\n\t\t\t}\n\t\t\tif statement.needTableName() {\n\t\t\t\tif len(statement.TableAlias) > 0 {\n\t\t\t\t\tcolumn = statement.TableAlias + \".\" + column\n\t\t\t\t} else {\n\t\t\t\t\tcolumn = statement.TableName() + \".\" + column\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar orderStr string\n\t\t\tif needOrderBy && len(statement.OrderStr) > 0 {\n\t\t\t\torderStr = \" ORDER BY \" + statement.OrderStr\n\t\t\t}\n\n\t\t\tvar groupStr string\n\t\t\tif len(statement.GroupByStr) > 0 {\n\t\t\t\tgroupStr = \" GROUP BY \" + statement.GroupByStr\n\t\t\t}\n\t\t\tmssqlCondi = fmt.Sprintf(\"(%s NOT IN (SELECT TOP %d %s%s%s%s%s))\",\n\t\t\t\tcolumn, statement.Start, column, fromStr, whereStr, orderStr, groupStr)\n\t\t}\n\t}\n\n\tvar buf strings.Builder\n\tfmt.Fprintf(&buf, \"SELECT %v%v%v%v%v\", distinct, top, columnStr, fromStr, whereStr)\n\tif len(mssqlCondi) > 0 {\n\t\tif len(whereStr) > 0 {\n\t\t\tfmt.Fprint(&buf, \" AND \", mssqlCondi)\n\t\t} else {\n\t\t\tfmt.Fprint(&buf, \" WHERE \", mssqlCondi)\n\t\t}\n\t}\n\n\tif statement.GroupByStr != \"\" {\n\t\tfmt.Fprint(&buf, \" GROUP BY \", statement.GroupByStr)\n\t}\n\tif statement.HavingStr != \"\" {\n\t\tfmt.Fprint(&buf, \" \", statement.HavingStr)\n\t}\n\tif needOrderBy && statement.OrderStr != \"\" {\n\t\tfmt.Fprint(&buf, \" ORDER BY \", statement.OrderStr)\n\t}\n\tif needLimit {\n\t\tif dialect.DBType() != core.MSSQL && dialect.DBType() != core.ORACLE {\n\t\t\tif statement.Start > 0 {\n\t\t\t\tfmt.Fprintf(&buf, \" LIMIT %v OFFSET %v\", statement.LimitN, statement.Start)\n\t\t\t} else if statement.LimitN > 0 {\n\t\t\t\tfmt.Fprint(&buf, \" LIMIT \", statement.LimitN)\n\t\t\t}\n\t\t} else if dialect.DBType() == core.ORACLE {\n\t\t\tif statement.Start != 0 || statement.LimitN != 0 {\n\t\t\t\toldString := buf.String()\n\t\t\t\tbuf.Reset()\n\t\t\t\trawColStr := columnStr\n\t\t\t\tif rawColStr == \"*\" {\n\t\t\t\t\trawColStr = \"at.*\"\n\t\t\t\t}\n\t\t\t\tfmt.Fprintf(&buf, \"SELECT %v FROM (SELECT %v,ROWNUM RN FROM (%v) at WHERE ROWNUM <= %d) aat WHERE RN > %d\",\n\t\t\t\t\tcolumnStr, rawColStr, oldString, statement.Start+statement.LimitN, statement.Start)\n\t\t\t}\n\t\t}\n\t}\n\tif statement.IsForUpdate {\n\t\treturn dialect.ForUpdateSql(buf.String()), nil\n\t}\n\n\treturn buf.String(), nil\n}\n\nfunc (statement *Statement) processIDParam() error {\n\tif statement.idParam == nil || statement.RefTable == nil {\n\t\treturn nil\n\t}\n\n\tif len(statement.RefTable.PrimaryKeys) != len(*statement.idParam) {\n\t\treturn fmt.Errorf(\"ID condition is error, expect %d primarykeys, there are %d\",\n\t\t\tlen(statement.RefTable.PrimaryKeys),\n\t\t\tlen(*statement.idParam),\n\t\t)\n\t}\n\n\tfor i, col := range statement.RefTable.PKColumns() {\n\t\tvar colName = statement.colName(col, statement.TableName())\n\t\tstatement.cond = statement.cond.And(builder.Eq{colName: (*(statement.idParam))[i]})\n\t}\n\treturn nil\n}\n\nfunc (statement *Statement) joinColumns(cols []*core.Column, includeTableName bool) string {\n\tvar colnames = make([]string, len(cols))\n\tfor i, col := range cols {\n\t\tif includeTableName {\n\t\t\tcolnames[i] = statement.Engine.Quote(statement.TableName()) +\n\t\t\t\t\".\" + statement.Engine.Quote(col.Name)\n\t\t} else {\n\t\t\tcolnames[i] = statement.Engine.Quote(col.Name)\n\t\t}\n\t}\n\treturn strings.Join(colnames, \", \")\n}\n\nfunc (statement *Statement) convertIDSQL(sqlStr string) string {\n\tif statement.RefTable != nil {\n\t\tcols := statement.RefTable.PKColumns()\n\t\tif len(cols) == 0 {\n\t\t\treturn \"\"\n\t\t}\n\n\t\tcolstrs := statement.joinColumns(cols, false)\n\t\tsqls := splitNNoCase(sqlStr, \" from \", 2)\n\t\tif len(sqls) != 2 {\n\t\t\treturn \"\"\n\t\t}\n\n\t\tvar top string\n\t\tif statement.LimitN > 0 && statement.Engine.dialect.DBType() == core.MSSQL {\n\t\t\ttop = fmt.Sprintf(\"TOP %d \", statement.LimitN)\n\t\t}\n\n\t\tnewsql := fmt.Sprintf(\"SELECT %s%s FROM %v\", top, colstrs, sqls[1])\n\t\treturn newsql\n\t}\n\treturn \"\"\n}\n\nfunc (statement *Statement) convertUpdateSQL(sqlStr string) (string, string) {\n\tif statement.RefTable == nil || len(statement.RefTable.PrimaryKeys) != 1 {\n\t\treturn \"\", \"\"\n\t}\n\n\tcolstrs := statement.joinColumns(statement.RefTable.PKColumns(), true)\n\tsqls := splitNNoCase(sqlStr, \"where\", 2)\n\tif len(sqls) != 2 {\n\t\tif len(sqls) == 1 {\n\t\t\treturn sqls[0], fmt.Sprintf(\"SELECT %v FROM %v\",\n\t\t\t\tcolstrs, statement.Engine.Quote(statement.TableName()))\n\t\t}\n\t\treturn \"\", \"\"\n\t}\n\n\tvar whereStr = sqls[1]\n\n\t// TODO: for postgres only, if any other database?\n\tvar paraStr string\n\tif statement.Engine.dialect.DBType() == core.POSTGRES {\n\t\tparaStr = \"$\"\n\t} else if statement.Engine.dialect.DBType() == core.MSSQL {\n\t\tparaStr = \":\"\n\t}\n\n\tif paraStr != \"\" {\n\t\tif strings.Contains(sqls[1], paraStr) {\n\t\t\tdollers := strings.Split(sqls[1], paraStr)\n\t\t\twhereStr = dollers[0]\n\t\t\tfor i, c := range dollers[1:] {\n\t\t\t\tccs := strings.SplitN(c, \" \", 2)\n\t\t\t\twhereStr += fmt.Sprintf(paraStr+\"%v %v\", i+1, ccs[1])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sqls[0], fmt.Sprintf(\"SELECT %v FROM %v WHERE %v\",\n\t\tcolstrs, statement.Engine.Quote(statement.TableName()),\n\t\twhereStr)\n}\n"
        },
        {
          "name": "statement_args.go",
          "type": "blob",
          "size": 3.5400390625,
          "content": "// Copyright 2019 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n\n\t\"xorm.io/builder\"\n\t\"xorm.io/core\"\n)\n\nfunc quoteNeeded(a interface{}) bool {\n\tswitch a.(type) {\n\tcase int, int8, int16, int32, int64:\n\t\treturn false\n\tcase uint, uint8, uint16, uint32, uint64:\n\t\treturn false\n\tcase float32, float64:\n\t\treturn false\n\tcase bool:\n\t\treturn false\n\tcase string:\n\t\treturn true\n\tcase time.Time, *time.Time:\n\t\treturn true\n\tcase builder.Builder, *builder.Builder:\n\t\treturn false\n\t}\n\n\tt := reflect.TypeOf(a)\n\tswitch t.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn false\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\treturn false\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn false\n\tcase reflect.Bool:\n\t\treturn false\n\tcase reflect.String:\n\t\treturn true\n\t}\n\n\treturn true\n}\n\nfunc convertStringSingleQuote(arg string) string {\n\treturn \"'\" + strings.Replace(arg, \"'\", \"''\", -1) + \"'\"\n}\n\nfunc convertString(arg string) string {\n\tvar buf strings.Builder\n\tbuf.WriteRune('\\'')\n\tfor _, c := range arg {\n\t\tif c == '\\\\' || c == '\\'' {\n\t\t\tbuf.WriteRune('\\\\')\n\t\t}\n\t\tbuf.WriteRune(c)\n\t}\n\tbuf.WriteRune('\\'')\n\treturn buf.String()\n}\n\nfunc convertArg(arg interface{}, convertFunc func(string) string) string {\n\tif quoteNeeded(arg) {\n\t\targv := fmt.Sprintf(\"%v\", arg)\n\t\treturn convertFunc(argv)\n\t}\n\n\treturn fmt.Sprintf(\"%v\", arg)\n}\n\nconst insertSelectPlaceHolder = true\n\nfunc (statement *Statement) writeArg(w *builder.BytesWriter, arg interface{}) error {\n\tswitch argv := arg.(type) {\n\tcase bool:\n\t\tif statement.Engine.dialect.DBType() == core.MSSQL {\n\t\t\tif argv {\n\t\t\t\tif _, err := w.WriteString(\"1\"); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif _, err := w.WriteString(\"0\"); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif argv {\n\t\t\t\tif _, err := w.WriteString(\"true\"); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif _, err := w.WriteString(\"false\"); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcase *builder.Builder:\n\t\tif _, err := w.WriteString(\"(\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := argv.WriteTo(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := w.WriteString(\")\"); err != nil {\n\t\t\treturn err\n\t\t}\n\tdefault:\n\t\tif insertSelectPlaceHolder {\n\t\t\tif err := w.WriteByte('?'); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tw.Append(arg)\n\t\t} else {\n\t\t\tvar convertFunc = convertStringSingleQuote\n\t\t\tif statement.Engine.dialect.DBType() == core.MYSQL {\n\t\t\t\tconvertFunc = convertString\n\t\t\t}\n\t\t\tif _, err := w.WriteString(convertArg(arg, convertFunc)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (statement *Statement) writeArgs(w *builder.BytesWriter, args []interface{}) error {\n\tfor i, arg := range args {\n\t\tif err := statement.writeArg(w, arg); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif i+1 != len(args) {\n\t\t\tif _, err := w.WriteString(\",\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc writeStrings(w *builder.BytesWriter, cols []string, leftQuote, rightQuote string) error {\n\tfor i, colName := range cols {\n\t\tif len(leftQuote) > 0 && colName[0] != '`' {\n\t\t\tif _, err := w.WriteString(leftQuote); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif _, err := w.WriteString(colName); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(rightQuote) > 0 && colName[len(colName)-1] != '`' {\n\t\t\tif _, err := w.WriteString(rightQuote); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif i+1 != len(cols) {\n\t\t\tif _, err := w.WriteString(\",\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "statement_columnmap.go",
          "type": "blob",
          "size": 0.580078125,
          "content": "// Copyright 2019 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport \"strings\"\n\ntype columnMap []string\n\nfunc (m columnMap) contain(colName string) bool {\n\tif len(m) == 0 {\n\t\treturn false\n\t}\n\n\tn := len(colName)\n\tfor _, mk := range m {\n\t\tif len(mk) != n {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.EqualFold(mk, colName) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (m *columnMap) add(colName string) bool {\n\tif m.contain(colName) {\n\t\treturn false\n\t}\n\t*m = append(*m, colName)\n\treturn true\n}\n"
        },
        {
          "name": "statement_exprparam.go",
          "type": "blob",
          "size": 2.39453125,
          "content": "// Copyright 2019 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"xorm.io/builder\"\n)\n\ntype ErrUnsupportedExprType struct {\n\ttp string\n}\n\nfunc (err ErrUnsupportedExprType) Error() string {\n\treturn fmt.Sprintf(\"Unsupported expression type: %v\", err.tp)\n}\n\ntype exprParam struct {\n\tcolName string\n\targ     interface{}\n}\n\ntype exprParams struct {\n\tcolNames []string\n\targs     []interface{}\n}\n\nfunc (exprs *exprParams) Len() int {\n\treturn len(exprs.colNames)\n}\n\nfunc (exprs *exprParams) addParam(colName string, arg interface{}) {\n\texprs.colNames = append(exprs.colNames, colName)\n\texprs.args = append(exprs.args, arg)\n}\n\nfunc (exprs *exprParams) isColExist(colName string) bool {\n\tfor _, name := range exprs.colNames {\n\t\tif strings.EqualFold(trimQuote(name), trimQuote(colName)) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (exprs *exprParams) getByName(colName string) (exprParam, bool) {\n\tfor i, name := range exprs.colNames {\n\t\tif strings.EqualFold(name, colName) {\n\t\t\treturn exprParam{name, exprs.args[i]}, true\n\t\t}\n\t}\n\treturn exprParam{}, false\n}\n\nfunc (exprs *exprParams) writeArgs(w *builder.BytesWriter) error {\n\tfor i, expr := range exprs.args {\n\t\tswitch arg := expr.(type) {\n\t\tcase *builder.Builder:\n\t\t\tif _, err := w.WriteString(\"(\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := arg.WriteTo(w); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif _, err := w.WriteString(\")\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\tif _, err := w.WriteString(fmt.Sprintf(\"%v\", arg)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif i != len(exprs.args)-1 {\n\t\t\tif _, err := w.WriteString(\",\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (exprs *exprParams) writeNameArgs(w *builder.BytesWriter) error {\n\tfor i, colName := range exprs.colNames {\n\t\tif _, err := w.WriteString(colName); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := w.WriteString(\"=\"); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch arg := exprs.args[i].(type) {\n\t\tcase *builder.Builder:\n\t\t\tif _, err := w.WriteString(\"(\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := arg.WriteTo(w); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif _, err := w.WriteString(\"(\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\tw.Append(exprs.args[i])\n\t\t}\n\n\t\tif i+1 != len(exprs.colNames) {\n\t\t\tif _, err := w.WriteString(\",\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "statement_quote.go",
          "type": "blob",
          "size": 0.34375,
          "content": "// Copyright 2019 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nfunc trimQuote(s string) string {\n\tif len(s) == 0 {\n\t\treturn s\n\t}\n\n\tif s[0] == '`' {\n\t\ts = s[1:]\n\t}\n\tif len(s) > 0 && s[len(s)-1] == '`' {\n\t\treturn s[:len(s)-1]\n\t}\n\treturn s\n}\n"
        },
        {
          "name": "statement_test.go",
          "type": "blob",
          "size": 5.869140625,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"xorm.io/core\"\n)\n\nvar colStrTests = []struct {\n\tomitColumn        string\n\tonlyToDBColumnNdx int\n\texpected          string\n}{\n\t{\"\", -1, \"`ID`, `IsDeleted`, `Caption`, `Code1`, `Code2`, `Code3`, `ParentID`, `Latitude`, `Longitude`\"},\n\t{\"Code2\", -1, \"`ID`, `IsDeleted`, `Caption`, `Code1`, `Code3`, `ParentID`, `Latitude`, `Longitude`\"},\n\t{\"\", 1, \"`ID`, `Caption`, `Code1`, `Code2`, `Code3`, `ParentID`, `Latitude`, `Longitude`\"},\n\t{\"Code3\", 1, \"`ID`, `Caption`, `Code1`, `Code2`, `ParentID`, `Latitude`, `Longitude`\"},\n\t{\"Longitude\", 1, \"`ID`, `Caption`, `Code1`, `Code2`, `Code3`, `ParentID`, `Latitude`\"},\n\t{\"\", 8, \"`ID`, `IsDeleted`, `Caption`, `Code1`, `Code2`, `Code3`, `ParentID`, `Latitude`\"},\n}\n\nfunc TestColumnsStringGeneration(t *testing.T) {\n\tif dbType == \"postgres\" || dbType == \"mssql\" {\n\t\treturn\n\t}\n\n\tvar statement *Statement\n\n\tfor ndx, testCase := range colStrTests {\n\t\tstatement = createTestStatement()\n\n\t\tif testCase.omitColumn != \"\" {\n\t\t\tstatement.Omit(testCase.omitColumn)\n\t\t}\n\n\t\tcolumns := statement.RefTable.Columns()\n\t\tif testCase.onlyToDBColumnNdx >= 0 {\n\t\t\tcolumns[testCase.onlyToDBColumnNdx].MapType = core.ONLYTODB\n\t\t}\n\n\t\tactual := statement.genColumnStr()\n\n\t\tif actual != testCase.expected {\n\t\t\tt.Errorf(\"[test #%d] Unexpected columns string:\\nwant:\\t%s\\nhave:\\t%s\", ndx, testCase.expected, actual)\n\t\t}\n\t\tif testCase.onlyToDBColumnNdx >= 0 {\n\t\t\tcolumns[testCase.onlyToDBColumnNdx].MapType = core.TWOSIDES\n\t\t}\n\t}\n}\n\nfunc BenchmarkColumnsStringGeneration(b *testing.B) {\n\tb.StopTimer()\n\n\tstatement := createTestStatement()\n\n\ttestCase := colStrTests[0]\n\n\tif testCase.omitColumn != \"\" {\n\t\tstatement.Omit(testCase.omitColumn) // !nemec784! Column must be skipped\n\t}\n\n\tif testCase.onlyToDBColumnNdx >= 0 {\n\t\tcolumns := statement.RefTable.Columns()\n\t\tcolumns[testCase.onlyToDBColumnNdx].MapType = core.ONLYTODB // !nemec784! Column must be skipped\n\t}\n\n\tb.StartTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tactual := statement.genColumnStr()\n\n\t\tif actual != testCase.expected {\n\t\t\tb.Errorf(\"Unexpected columns string:\\nwant:\\t%s\\nhave:\\t%s\", testCase.expected, actual)\n\t\t}\n\t}\n}\n\nfunc BenchmarkGetFlagForColumnWithICKey_ContainsKey(b *testing.B) {\n\n\tb.StopTimer()\n\n\tmapCols := make(map[string]bool)\n\tcols := []*core.Column{\n\t\t{Name: `ID`},\n\t\t{Name: `IsDeleted`},\n\t\t{Name: `Caption`},\n\t\t{Name: `Code1`},\n\t\t{Name: `Code2`},\n\t\t{Name: `Code3`},\n\t\t{Name: `ParentID`},\n\t\t{Name: `Latitude`},\n\t\t{Name: `Longitude`},\n\t}\n\n\tfor _, col := range cols {\n\t\tmapCols[strings.ToLower(col.Name)] = true\n\t}\n\n\tb.StartTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\n\t\tfor _, col := range cols {\n\n\t\t\tif _, ok := getFlagForColumn(mapCols, col); !ok {\n\t\t\t\tb.Fatal(\"Unexpected result\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc BenchmarkGetFlagForColumnWithICKey_EmptyMap(b *testing.B) {\n\n\tb.StopTimer()\n\n\tmapCols := make(map[string]bool)\n\tcols := []*core.Column{\n\t\t{Name: `ID`},\n\t\t{Name: `IsDeleted`},\n\t\t{Name: `Caption`},\n\t\t{Name: `Code1`},\n\t\t{Name: `Code2`},\n\t\t{Name: `Code3`},\n\t\t{Name: `ParentID`},\n\t\t{Name: `Latitude`},\n\t\t{Name: `Longitude`},\n\t}\n\n\tb.StartTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\n\t\tfor _, col := range cols {\n\n\t\t\tif _, ok := getFlagForColumn(mapCols, col); ok {\n\t\t\t\tb.Fatal(\"Unexpected result\")\n\t\t\t}\n\t\t}\n\t}\n}\n\ntype TestType struct {\n\tID        int64   `xorm:\"ID PK\"`\n\tIsDeleted bool    `xorm:\"IsDeleted\"`\n\tCaption   string  `xorm:\"Caption\"`\n\tCode1     string  `xorm:\"Code1\"`\n\tCode2     string  `xorm:\"Code2\"`\n\tCode3     string  `xorm:\"Code3\"`\n\tParentID  int64   `xorm:\"ParentID\"`\n\tLatitude  float64 `xorm:\"Latitude\"`\n\tLongitude float64 `xorm:\"Longitude\"`\n}\n\nfunc (TestType) TableName() string {\n\treturn \"TestTable\"\n}\n\nfunc createTestStatement() *Statement {\n\tif engine, ok := testEngine.(*Engine); ok {\n\t\tstatement := &Statement{}\n\t\tstatement.Init()\n\t\tstatement.Engine = engine\n\t\tstatement.setRefValue(reflect.ValueOf(TestType{}))\n\n\t\treturn statement\n\t} else if eg, ok := testEngine.(*EngineGroup); ok {\n\t\tstatement := &Statement{}\n\t\tstatement.Init()\n\t\tstatement.Engine = eg.Engine\n\t\tstatement.setRefValue(reflect.ValueOf(TestType{}))\n\n\t\treturn statement\n\t}\n\treturn nil\n}\n\nfunc TestDistinctAndCols(t *testing.T) {\n\ttype DistinctAndCols struct {\n\t\tId   int64\n\t\tName string\n\t}\n\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(DistinctAndCols))\n\n\tcnt, err := testEngine.Insert(&DistinctAndCols{\n\t\tName: \"test\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar names []string\n\terr = testEngine.Table(\"distinct_and_cols\").Cols(\"name\").Distinct(\"name\").Find(&names)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(names))\n\tassert.EqualValues(t, \"test\", names[0])\n}\n\nfunc TestUpdateIgnoreOnlyFromDBFields(t *testing.T) {\n\ttype TestOnlyFromDBField struct {\n\t\tId              int64  `xorm:\"PK\"`\n\t\tOnlyFromDBField string `xorm:\"<-\"`\n\t\tOnlyToDBField   string `xorm:\"->\"`\n\t\tIngoreField     string `xorm:\"-\"`\n\t}\n\n\tassertGetRecord := func() *TestOnlyFromDBField {\n\t\tvar record TestOnlyFromDBField\n\t\thas, err := testEngine.Where(\"id = ?\", 1).Get(&record)\n\t\tassert.NoError(t, err)\n\t\tassert.EqualValues(t, true, has)\n\t\tassert.EqualValues(t, \"\", record.OnlyFromDBField)\n\t\treturn &record\n\n\t}\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(TestOnlyFromDBField))\n\n\t_, err := testEngine.Insert(&TestOnlyFromDBField{\n\t\tId:              1,\n\t\tOnlyFromDBField: \"a\",\n\t\tOnlyToDBField:   \"b\",\n\t\tIngoreField:     \"c\",\n\t})\n\tassert.NoError(t, err)\n\n\trecord := assertGetRecord()\n\trecord.OnlyFromDBField = \"test\"\n\ttestEngine.Update(record)\n\tassertGetRecord()\n}\n\nfunc TestCol2NewColsWithQuote(t *testing.T) {\n\tcols := []string{\"f1\", \"f2\", \"t3.f3\"}\n\n\tstatement := createTestStatement()\n\n\tquotedCols := statement.col2NewColsWithQuote(cols...)\n\tassert.EqualValues(t, []string{statement.Engine.Quote(\"f1\"), statement.Engine.Quote(\"f2\"), statement.Engine.Quote(\"t3.f3\")}, quotedCols)\n}\n"
        },
        {
          "name": "syslogger.go",
          "type": "blob",
          "size": 2.0283203125,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build !windows,!nacl,!plan9\n\npackage xorm\n\nimport (\n\t\"fmt\"\n\t\"log/syslog\"\n\n\t\"xorm.io/core\"\n)\n\nvar _ core.ILogger = &SyslogLogger{}\n\n// SyslogLogger will be depricated\ntype SyslogLogger struct {\n\tw       *syslog.Writer\n\tshowSQL bool\n}\n\n// NewSyslogLogger implements core.ILogger\nfunc NewSyslogLogger(w *syslog.Writer) *SyslogLogger {\n\treturn &SyslogLogger{w: w}\n}\n\n// Debug log content as Debug\nfunc (s *SyslogLogger) Debug(v ...interface{}) {\n\ts.w.Debug(fmt.Sprint(v...))\n}\n\n// Debugf log content as Debug and format\nfunc (s *SyslogLogger) Debugf(format string, v ...interface{}) {\n\ts.w.Debug(fmt.Sprintf(format, v...))\n}\n\n// Error log content as Error\nfunc (s *SyslogLogger) Error(v ...interface{}) {\n\ts.w.Err(fmt.Sprint(v...))\n}\n\n// Errorf log content as Errorf and format\nfunc (s *SyslogLogger) Errorf(format string, v ...interface{}) {\n\ts.w.Err(fmt.Sprintf(format, v...))\n}\n\n// Info log content as Info\nfunc (s *SyslogLogger) Info(v ...interface{}) {\n\ts.w.Info(fmt.Sprint(v...))\n}\n\n// Infof log content as Infof and format\nfunc (s *SyslogLogger) Infof(format string, v ...interface{}) {\n\ts.w.Info(fmt.Sprintf(format, v...))\n}\n\n// Warn log content as Warn\nfunc (s *SyslogLogger) Warn(v ...interface{}) {\n\ts.w.Warning(fmt.Sprint(v...))\n}\n\n// Warnf log content as Warnf and format\nfunc (s *SyslogLogger) Warnf(format string, v ...interface{}) {\n\ts.w.Warning(fmt.Sprintf(format, v...))\n}\n\n// Level shows log level\nfunc (s *SyslogLogger) Level() core.LogLevel {\n\treturn core.LOG_UNKNOWN\n}\n\n// SetLevel always return error, as current log/syslog package doesn't allow to set priority level after syslog.Writer created\nfunc (s *SyslogLogger) SetLevel(l core.LogLevel) {}\n\n// ShowSQL set if logging SQL\nfunc (s *SyslogLogger) ShowSQL(show ...bool) {\n\tif len(show) == 0 {\n\t\ts.showSQL = true\n\t\treturn\n\t}\n\ts.showSQL = show[0]\n}\n\n// IsShowSQL if logging SQL\nfunc (s *SyslogLogger) IsShowSQL() bool {\n\treturn s.showSQL\n}\n"
        },
        {
          "name": "tag.go",
          "type": "blob",
          "size": 7.1044921875,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"xorm.io/core\"\n)\n\ntype tagContext struct {\n\ttagName         string\n\tparams          []string\n\tpreTag, nextTag string\n\ttable           *core.Table\n\tcol             *core.Column\n\tfieldValue      reflect.Value\n\tisIndex         bool\n\tisUnique        bool\n\tindexNames      map[string]int\n\tengine          *Engine\n\thasCacheTag     bool\n\thasNoCacheTag   bool\n\tignoreNext      bool\n}\n\n// tagHandler describes tag handler for XORM\ntype tagHandler func(ctx *tagContext) error\n\nvar (\n\t// defaultTagHandlers enumerates all the default tag handler\n\tdefaultTagHandlers = map[string]tagHandler{\n\t\t\"<-\":       OnlyFromDBTagHandler,\n\t\t\"->\":       OnlyToDBTagHandler,\n\t\t\"PK\":       PKTagHandler,\n\t\t\"NULL\":     NULLTagHandler,\n\t\t\"NOT\":      IgnoreTagHandler,\n\t\t\"AUTOINCR\": AutoIncrTagHandler,\n\t\t\"DEFAULT\":  DefaultTagHandler,\n\t\t\"CREATED\":  CreatedTagHandler,\n\t\t\"UPDATED\":  UpdatedTagHandler,\n\t\t\"DELETED\":  DeletedTagHandler,\n\t\t\"VERSION\":  VersionTagHandler,\n\t\t\"UTC\":      UTCTagHandler,\n\t\t\"LOCAL\":    LocalTagHandler,\n\t\t\"NOTNULL\":  NotNullTagHandler,\n\t\t\"INDEX\":    IndexTagHandler,\n\t\t\"UNIQUE\":   UniqueTagHandler,\n\t\t\"CACHE\":    CacheTagHandler,\n\t\t\"NOCACHE\":  NoCacheTagHandler,\n\t\t\"COMMENT\":  CommentTagHandler,\n\t}\n)\n\nfunc init() {\n\tfor k := range core.SqlTypes {\n\t\tdefaultTagHandlers[k] = SQLTypeTagHandler\n\t}\n}\n\n// IgnoreTagHandler describes ignored tag handler\nfunc IgnoreTagHandler(ctx *tagContext) error {\n\treturn nil\n}\n\n// OnlyFromDBTagHandler describes mapping direction tag handler\nfunc OnlyFromDBTagHandler(ctx *tagContext) error {\n\tctx.col.MapType = core.ONLYFROMDB\n\treturn nil\n}\n\n// OnlyToDBTagHandler describes mapping direction tag handler\nfunc OnlyToDBTagHandler(ctx *tagContext) error {\n\tctx.col.MapType = core.ONLYTODB\n\treturn nil\n}\n\n// PKTagHandler decribes primary key tag handler\nfunc PKTagHandler(ctx *tagContext) error {\n\tctx.col.IsPrimaryKey = true\n\tctx.col.Nullable = false\n\treturn nil\n}\n\n// NULLTagHandler describes null tag handler\nfunc NULLTagHandler(ctx *tagContext) error {\n\tctx.col.Nullable = (strings.ToUpper(ctx.preTag) != \"NOT\")\n\treturn nil\n}\n\n// NotNullTagHandler describes notnull tag handler\nfunc NotNullTagHandler(ctx *tagContext) error {\n\tctx.col.Nullable = false\n\treturn nil\n}\n\n// AutoIncrTagHandler describes autoincr tag handler\nfunc AutoIncrTagHandler(ctx *tagContext) error {\n\tctx.col.IsAutoIncrement = true\n\t/*\n\t\tif len(ctx.params) > 0 {\n\t\t\tautoStartInt, err := strconv.Atoi(ctx.params[0])\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tctx.col.AutoIncrStart = autoStartInt\n\t\t} else {\n\t\t\tctx.col.AutoIncrStart = 1\n\t\t}\n\t*/\n\treturn nil\n}\n\n// DefaultTagHandler describes default tag handler\nfunc DefaultTagHandler(ctx *tagContext) error {\n\tif len(ctx.params) > 0 {\n\t\tctx.col.Default = ctx.params[0]\n\t} else {\n\t\tctx.col.Default = ctx.nextTag\n\t\tctx.ignoreNext = true\n\t}\n\tctx.col.DefaultIsEmpty = false\n\treturn nil\n}\n\n// CreatedTagHandler describes created tag handler\nfunc CreatedTagHandler(ctx *tagContext) error {\n\tctx.col.IsCreated = true\n\treturn nil\n}\n\n// VersionTagHandler describes version tag handler\nfunc VersionTagHandler(ctx *tagContext) error {\n\tctx.col.IsVersion = true\n\tctx.col.Default = \"1\"\n\treturn nil\n}\n\n// UTCTagHandler describes utc tag handler\nfunc UTCTagHandler(ctx *tagContext) error {\n\tctx.col.TimeZone = time.UTC\n\treturn nil\n}\n\n// LocalTagHandler describes local tag handler\nfunc LocalTagHandler(ctx *tagContext) error {\n\tif len(ctx.params) == 0 {\n\t\tctx.col.TimeZone = time.Local\n\t} else {\n\t\tvar err error\n\t\tctx.col.TimeZone, err = time.LoadLocation(ctx.params[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// UpdatedTagHandler describes updated tag handler\nfunc UpdatedTagHandler(ctx *tagContext) error {\n\tctx.col.IsUpdated = true\n\treturn nil\n}\n\n// DeletedTagHandler describes deleted tag handler\nfunc DeletedTagHandler(ctx *tagContext) error {\n\tctx.col.IsDeleted = true\n\treturn nil\n}\n\n// IndexTagHandler describes index tag handler\nfunc IndexTagHandler(ctx *tagContext) error {\n\tif len(ctx.params) > 0 {\n\t\tctx.indexNames[ctx.params[0]] = core.IndexType\n\t} else {\n\t\tctx.isIndex = true\n\t}\n\treturn nil\n}\n\n// UniqueTagHandler describes unique tag handler\nfunc UniqueTagHandler(ctx *tagContext) error {\n\tif len(ctx.params) > 0 {\n\t\tctx.indexNames[ctx.params[0]] = core.UniqueType\n\t} else {\n\t\tctx.isUnique = true\n\t}\n\treturn nil\n}\n\n// CommentTagHandler add comment to column\nfunc CommentTagHandler(ctx *tagContext) error {\n\tif len(ctx.params) > 0 {\n\t\tctx.col.Comment = strings.Trim(ctx.params[0], \"' \")\n\t}\n\treturn nil\n}\n\n// SQLTypeTagHandler describes SQL Type tag handler\nfunc SQLTypeTagHandler(ctx *tagContext) error {\n\tctx.col.SQLType = core.SQLType{Name: ctx.tagName}\n\tif len(ctx.params) > 0 {\n\t\tif ctx.tagName == core.Enum {\n\t\t\tctx.col.EnumOptions = make(map[string]int)\n\t\t\tfor k, v := range ctx.params {\n\t\t\t\tv = strings.TrimSpace(v)\n\t\t\t\tv = strings.Trim(v, \"'\")\n\t\t\t\tctx.col.EnumOptions[v] = k\n\t\t\t}\n\t\t} else if ctx.tagName == core.Set {\n\t\t\tctx.col.SetOptions = make(map[string]int)\n\t\t\tfor k, v := range ctx.params {\n\t\t\t\tv = strings.TrimSpace(v)\n\t\t\t\tv = strings.Trim(v, \"'\")\n\t\t\t\tctx.col.SetOptions[v] = k\n\t\t\t}\n\t\t} else {\n\t\t\tvar err error\n\t\t\tif len(ctx.params) == 2 {\n\t\t\t\tctx.col.Length, err = strconv.Atoi(ctx.params[0])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tctx.col.Length2, err = strconv.Atoi(ctx.params[1])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else if len(ctx.params) == 1 {\n\t\t\t\tctx.col.Length, err = strconv.Atoi(ctx.params[0])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// ExtendsTagHandler describes extends tag handler\nfunc ExtendsTagHandler(ctx *tagContext) error {\n\tvar fieldValue = ctx.fieldValue\n\tvar isPtr = false\n\tswitch fieldValue.Kind() {\n\tcase reflect.Ptr:\n\t\tf := fieldValue.Type().Elem()\n\t\tif f.Kind() == reflect.Struct {\n\t\t\tfieldPtr := fieldValue\n\t\t\tfieldValue = fieldValue.Elem()\n\t\t\tif !fieldValue.IsValid() || fieldPtr.IsNil() {\n\t\t\t\tfieldValue = reflect.New(f).Elem()\n\t\t\t}\n\t\t}\n\t\tisPtr = true\n\t\tfallthrough\n\tcase reflect.Struct:\n\t\tparentTable, err := ctx.engine.mapType(fieldValue)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor _, col := range parentTable.Columns() {\n\t\t\tcol.FieldName = fmt.Sprintf(\"%v.%v\", ctx.col.FieldName, col.FieldName)\n\n\t\t\tvar tagPrefix = ctx.col.FieldName\n\t\t\tif len(ctx.params) > 0 {\n\t\t\t\tcol.Nullable = isPtr\n\t\t\t\ttagPrefix = ctx.params[0]\n\t\t\t\tif col.IsPrimaryKey {\n\t\t\t\t\tcol.Name = ctx.col.FieldName\n\t\t\t\t\tcol.IsPrimaryKey = false\n\t\t\t\t} else {\n\t\t\t\t\tcol.Name = fmt.Sprintf(\"%v%v\", tagPrefix, col.Name)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif col.Nullable {\n\t\t\t\tcol.IsAutoIncrement = false\n\t\t\t\tcol.IsPrimaryKey = false\n\t\t\t}\n\n\t\t\tctx.table.AddColumn(col)\n\t\t\tfor indexName, indexType := range col.Indexes {\n\t\t\t\taddIndex(indexName, ctx.table, col, indexType)\n\t\t\t}\n\t\t}\n\tdefault:\n\t\t//TODO: warning\n\t}\n\treturn nil\n}\n\n// CacheTagHandler describes cache tag handler\nfunc CacheTagHandler(ctx *tagContext) error {\n\tif !ctx.hasCacheTag {\n\t\tctx.hasCacheTag = true\n\t}\n\treturn nil\n}\n\n// NoCacheTagHandler describes nocache tag handler\nfunc NoCacheTagHandler(ctx *tagContext) error {\n\tif !ctx.hasNoCacheTag {\n\t\tctx.hasNoCacheTag = true\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "tag_cache_test.go",
          "type": "blob",
          "size": 0.8134765625,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestCacheTag(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype CacheDomain struct {\n\t\tId   int64 `xorm:\"pk cache\"`\n\t\tName string\n\t}\n\n\tassert.NoError(t, testEngine.CreateTables(&CacheDomain{}))\n\tassert.True(t, testEngine.GetCacher(testEngine.TableName(&CacheDomain{})) != nil)\n}\n\nfunc TestNoCacheTag(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype NoCacheDomain struct {\n\t\tId   int64 `xorm:\"pk nocache\"`\n\t\tName string\n\t}\n\n\tassert.NoError(t, testEngine.CreateTables(&NoCacheDomain{}))\n\tassert.True(t, testEngine.GetCacher(testEngine.TableName(&NoCacheDomain{})) == nil)\n}\n"
        },
        {
          "name": "tag_extends_test.go",
          "type": "blob",
          "size": 15.3984375,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"xorm.io/core\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype tempUser struct {\n\tId       int64\n\tUsername string\n}\n\ntype tempUser2 struct {\n\tTempUser   tempUser `xorm:\"extends\"`\n\tDepartname string\n}\n\ntype tempUser3 struct {\n\tTemp       *tempUser `xorm:\"extends\"`\n\tDepartname string\n}\n\ntype tempUser4 struct {\n\tTempUser2 tempUser2 `xorm:\"extends\"`\n}\n\ntype Userinfo struct {\n\tUid        int64  `xorm:\"id pk not null autoincr\"`\n\tUsername   string `xorm:\"unique\"`\n\tDepartname string\n\tAlias      string `xorm:\"-\"`\n\tCreated    time.Time\n\tDetail     Userdetail `xorm:\"detail_id int(11)\"`\n\tHeight     float64\n\tAvatar     []byte\n\tIsMan      bool\n}\n\ntype Userdetail struct {\n\tId      int64\n\tIntro   string `xorm:\"text\"`\n\tProfile string `xorm:\"varchar(2000)\"`\n}\n\ntype UserAndDetail struct {\n\tUserinfo   `xorm:\"extends\"`\n\tUserdetail `xorm:\"extends\"`\n}\n\nfunc TestExtends(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&tempUser2{})\n\tassert.NoError(t, err)\n\n\terr = testEngine.CreateTables(&tempUser2{})\n\tassert.NoError(t, err)\n\n\ttu := &tempUser2{tempUser{0, \"extends\"}, \"dev depart\"}\n\t_, err = testEngine.Insert(tu)\n\tassert.NoError(t, err)\n\n\ttu2 := &tempUser2{}\n\t_, err = testEngine.Get(tu2)\n\tassert.NoError(t, err)\n\n\ttu3 := &tempUser2{tempUser{0, \"extends update\"}, \"\"}\n\t_, err = testEngine.ID(tu2.TempUser.Id).Update(tu3)\n\tassert.NoError(t, err)\n\n\terr = testEngine.DropTables(&tempUser4{})\n\tassert.NoError(t, err)\n\n\terr = testEngine.CreateTables(&tempUser4{})\n\tassert.NoError(t, err)\n\n\ttu8 := &tempUser4{tempUser2{tempUser{0, \"extends\"}, \"dev depart\"}}\n\t_, err = testEngine.Insert(tu8)\n\tassert.NoError(t, err)\n\n\ttu9 := &tempUser4{}\n\t_, err = testEngine.Get(tu9)\n\tassert.NoError(t, err)\n\n\tif tu9.TempUser2.TempUser.Username != tu8.TempUser2.TempUser.Username || tu9.TempUser2.Departname != tu8.TempUser2.Departname {\n\t\terr = errors.New(fmt.Sprintln(\"not equal for\", tu8, tu9))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\ttu10 := &tempUser4{tempUser2{tempUser{0, \"extends update\"}, \"\"}}\n\t_, err = testEngine.ID(tu9.TempUser2.TempUser.Id).Update(tu10)\n\tassert.NoError(t, err)\n\n\terr = testEngine.DropTables(&tempUser3{})\n\tassert.NoError(t, err)\n\n\terr = testEngine.CreateTables(&tempUser3{})\n\tassert.NoError(t, err)\n\n\ttu4 := &tempUser3{&tempUser{0, \"extends\"}, \"dev depart\"}\n\t_, err = testEngine.Insert(tu4)\n\tassert.NoError(t, err)\n\n\ttu5 := &tempUser3{}\n\t_, err = testEngine.Get(tu5)\n\tassert.NoError(t, err)\n\n\tif tu5.Temp == nil {\n\t\terr = errors.New(\"error get data extends\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif tu5.Temp.Id != 1 || tu5.Temp.Username != \"extends\" ||\n\t\ttu5.Departname != \"dev depart\" {\n\t\terr = errors.New(\"error get data extends\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\ttu6 := &tempUser3{&tempUser{0, \"extends update\"}, \"\"}\n\t_, err = testEngine.ID(tu5.Temp.Id).Update(tu6)\n\tassert.NoError(t, err)\n\n\tusers := make([]tempUser3, 0)\n\terr = testEngine.Find(&users)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(users), \"error get data not 1\")\n\n\tassertSync(t, new(Userinfo), new(Userdetail))\n\n\tdetail := Userdetail{\n\t\tIntro: \"I'm in China\",\n\t}\n\t_, err = testEngine.Insert(&detail)\n\tassert.NoError(t, err)\n\n\t_, err = testEngine.Insert(&Userinfo{\n\t\tUsername: \"lunny\",\n\t\tDetail:   detail,\n\t})\n\tassert.NoError(t, err)\n\n\tvar info UserAndDetail\n\tqt := testEngine.Quote\n\tui := testEngine.TableName(new(Userinfo), true)\n\tud := testEngine.TableName(&detail, true)\n\tuiid := testEngine.GetColumnMapper().Obj2Table(\"Id\")\n\tudid := \"detail_id\"\n\tsql := fmt.Sprintf(\"select * from %s, %s where %s.%s = %s.%s\",\n\t\tqt(ui), qt(ud), qt(ui), qt(udid), qt(ud), qt(uiid))\n\tb, err := testEngine.SQL(sql).NoCascade().Get(&info)\n\tassert.NoError(t, err)\n\tif !b {\n\t\terr = errors.New(\"should has lest one record\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tfmt.Println(info)\n\tif info.Userinfo.Uid == 0 || info.Userdetail.Id == 0 {\n\t\terr = errors.New(\"all of the id should has value\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(\"----join--info2\")\n\tvar info2 UserAndDetail\n\tb, err = testEngine.Table(&Userinfo{}).\n\t\tJoin(\"LEFT\", qt(ud), qt(ui)+\".\"+qt(\"detail_id\")+\" = \"+qt(ud)+\".\"+qt(uiid)).\n\t\tNoCascade().Get(&info2)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif !b {\n\t\terr = errors.New(\"should has lest one record\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif info2.Userinfo.Uid == 0 || info2.Userdetail.Id == 0 {\n\t\terr = errors.New(\"all of the id should has value\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tfmt.Println(info2)\n\n\tfmt.Println(\"----join--infos2\")\n\tvar infos2 = make([]UserAndDetail, 0)\n\terr = testEngine.Table(&Userinfo{}).\n\t\tJoin(\"LEFT\", qt(ud), qt(ui)+\".\"+qt(\"detail_id\")+\" = \"+qt(ud)+\".\"+qt(uiid)).\n\t\tNoCascade().\n\t\tFind(&infos2)\n\tassert.NoError(t, err)\n\tfmt.Println(infos2)\n}\n\ntype MessageBase struct {\n\tId     int64 `xorm:\"int(11) pk autoincr\"`\n\tTypeId int64 `xorm:\"int(11) notnull\"`\n}\n\ntype Message struct {\n\tMessageBase `xorm:\"extends\"`\n\tTitle       string    `xorm:\"varchar(100) notnull\"`\n\tContent     string    `xorm:\"text notnull\"`\n\tUid         int64     `xorm:\"int(11) notnull\"`\n\tToUid       int64     `xorm:\"int(11) notnull\"`\n\tCreateTime  time.Time `xorm:\"datetime notnull created\"`\n}\n\ntype MessageUser struct {\n\tId   int64\n\tName string\n}\n\ntype MessageType struct {\n\tId   int64\n\tName string\n}\n\ntype MessageExtend3 struct {\n\tMessage  `xorm:\"extends\"`\n\tSender   MessageUser `xorm:\"extends\"`\n\tReceiver MessageUser `xorm:\"extends\"`\n\tType     MessageType `xorm:\"extends\"`\n}\n\ntype MessageExtend4 struct {\n\tMessage     `xorm:\"extends\"`\n\tMessageUser `xorm:\"extends\"`\n\tMessageType `xorm:\"extends\"`\n}\n\nfunc TestExtends2(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&Message{}, &MessageUser{}, &MessageType{})\n\tassert.NoError(t, err)\n\n\terr = testEngine.CreateTables(&Message{}, &MessageUser{}, &MessageType{})\n\tassert.NoError(t, err)\n\n\tvar sender = MessageUser{Name: \"sender\"}\n\tvar receiver = MessageUser{Name: \"receiver\"}\n\tvar msgtype = MessageType{Name: \"type\"}\n\t_, err = testEngine.Insert(&sender, &receiver, &msgtype)\n\tassert.NoError(t, err)\n\n\tmsg := Message{\n\t\tMessageBase: MessageBase{\n\t\t\tId: msgtype.Id,\n\t\t},\n\t\tTitle:   \"test\",\n\t\tContent: \"test\",\n\t\tUid:     sender.Id,\n\t\tToUid:   receiver.Id,\n\t}\n\n\tsession := testEngine.NewSession()\n\tdefer session.Close()\n\n\t// MSSQL deny insert identity column excep declare as below\n\tif testEngine.Dialect().DBType() == core.MSSQL {\n\t\terr = session.Begin()\n\t\tassert.NoError(t, err)\n\t\t_, err = session.Exec(\"SET IDENTITY_INSERT message ON\")\n\t\tassert.NoError(t, err)\n\t}\n\tcnt, err := session.Insert(&msg)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tif testEngine.Dialect().DBType() == core.MSSQL {\n\t\terr = session.Commit()\n\t\tassert.NoError(t, err)\n\t}\n\n\tvar mapper = testEngine.GetTableMapper().Obj2Table\n\tvar quote = testEngine.Quote\n\tuserTableName := quote(testEngine.TableName(mapper(\"MessageUser\"), true))\n\ttypeTableName := quote(testEngine.TableName(mapper(\"MessageType\"), true))\n\tmsgTableName := quote(testEngine.TableName(mapper(\"Message\"), true))\n\n\tlist := make([]Message, 0)\n\terr = session.Table(msgTableName).Join(\"LEFT\", []string{userTableName, \"sender\"}, \"`sender`.`\"+mapper(\"Id\")+\"`=\"+msgTableName+\".`\"+mapper(\"Uid\")+\"`\").\n\t\tJoin(\"LEFT\", []string{userTableName, \"receiver\"}, \"`receiver`.`\"+mapper(\"Id\")+\"`=\"+msgTableName+\".`\"+mapper(\"ToUid\")+\"`\").\n\t\tJoin(\"LEFT\", []string{typeTableName, \"type\"}, \"`type`.`\"+mapper(\"Id\")+\"`=\"+msgTableName+\".`\"+mapper(\"Id\")+\"`\").\n\t\tFind(&list)\n\tassert.NoError(t, err)\n\n\tassert.EqualValues(t, 1, len(list), fmt.Sprintln(\"should have 1 message, got\", len(list)))\n\tassert.EqualValues(t, msg.Id, list[0].Id, fmt.Sprintln(\"should message equal\", list[0], msg))\n}\n\nfunc TestExtends3(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&Message{}, &MessageUser{}, &MessageType{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(&Message{}, &MessageUser{}, &MessageType{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tvar sender = MessageUser{Name: \"sender\"}\n\tvar receiver = MessageUser{Name: \"receiver\"}\n\tvar msgtype = MessageType{Name: \"type\"}\n\t_, err = testEngine.Insert(&sender, &receiver, &msgtype)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tmsg := Message{\n\t\tMessageBase: MessageBase{\n\t\t\tId: msgtype.Id,\n\t\t},\n\t\tTitle:   \"test\",\n\t\tContent: \"test\",\n\t\tUid:     sender.Id,\n\t\tToUid:   receiver.Id,\n\t}\n\n\tsession := testEngine.NewSession()\n\tdefer session.Close()\n\n\t// MSSQL deny insert identity column excep declare as below\n\tif testEngine.Dialect().DBType() == core.MSSQL {\n\t\terr = session.Begin()\n\t\tassert.NoError(t, err)\n\t\t_, err = session.Exec(\"SET IDENTITY_INSERT message ON\")\n\t\tassert.NoError(t, err)\n\t}\n\t_, err = session.Insert(&msg)\n\tassert.NoError(t, err)\n\n\tif testEngine.Dialect().DBType() == core.MSSQL {\n\t\terr = session.Commit()\n\t\tassert.NoError(t, err)\n\t}\n\n\tvar mapper = testEngine.GetTableMapper().Obj2Table\n\tvar quote = testEngine.Quote\n\tuserTableName := quote(testEngine.TableName(mapper(\"MessageUser\"), true))\n\ttypeTableName := quote(testEngine.TableName(mapper(\"MessageType\"), true))\n\tmsgTableName := quote(testEngine.TableName(mapper(\"Message\"), true))\n\n\tlist := make([]MessageExtend3, 0)\n\terr = session.Table(msgTableName).Join(\"LEFT\", []string{userTableName, \"sender\"}, \"`sender`.`\"+mapper(\"Id\")+\"`=\"+msgTableName+\".`\"+mapper(\"Uid\")+\"`\").\n\t\tJoin(\"LEFT\", []string{userTableName, \"receiver\"}, \"`receiver`.`\"+mapper(\"Id\")+\"`=\"+msgTableName+\".`\"+mapper(\"ToUid\")+\"`\").\n\t\tJoin(\"LEFT\", []string{typeTableName, \"type\"}, \"`type`.`\"+mapper(\"Id\")+\"`=\"+msgTableName+\".`\"+mapper(\"Id\")+\"`\").\n\t\tFind(&list)\n\tassert.NoError(t, err)\n\n\tif len(list) != 1 {\n\t\terr = errors.New(fmt.Sprintln(\"should have 1 message, got\", len(list)))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif list[0].Message.Id != msg.Id {\n\t\terr = errors.New(fmt.Sprintln(\"should message equal\", list[0].Message, msg))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif list[0].Sender.Id != sender.Id || list[0].Sender.Name != sender.Name {\n\t\terr = errors.New(fmt.Sprintln(\"should sender equal\", list[0].Sender, sender))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif list[0].Receiver.Id != receiver.Id || list[0].Receiver.Name != receiver.Name {\n\t\terr = errors.New(fmt.Sprintln(\"should receiver equal\", list[0].Receiver, receiver))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif list[0].Type.Id != msgtype.Id || list[0].Type.Name != msgtype.Name {\n\t\terr = errors.New(fmt.Sprintln(\"should msgtype equal\", list[0].Type, msgtype))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestExtends4(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&Message{}, &MessageUser{}, &MessageType{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(&Message{}, &MessageUser{}, &MessageType{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tvar sender = MessageUser{Name: \"sender\"}\n\tvar msgtype = MessageType{Name: \"type\"}\n\t_, err = testEngine.Insert(&sender, &msgtype)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tmsg := Message{\n\t\tMessageBase: MessageBase{\n\t\t\tId: msgtype.Id,\n\t\t},\n\t\tTitle:   \"test\",\n\t\tContent: \"test\",\n\t\tUid:     sender.Id,\n\t}\n\n\tsession := testEngine.NewSession()\n\tdefer session.Close()\n\n\t// MSSQL deny insert identity column excep declare as below\n\tif testEngine.Dialect().DBType() == core.MSSQL {\n\t\terr = session.Begin()\n\t\tassert.NoError(t, err)\n\t\t_, err = session.Exec(\"SET IDENTITY_INSERT message ON\")\n\t\tassert.NoError(t, err)\n\t}\n\t_, err = session.Insert(&msg)\n\tassert.NoError(t, err)\n\n\tif testEngine.Dialect().DBType() == core.MSSQL {\n\t\terr = session.Commit()\n\t\tassert.NoError(t, err)\n\t}\n\n\tvar mapper = testEngine.GetTableMapper().Obj2Table\n\tvar quote = testEngine.Quote\n\tuserTableName := quote(testEngine.TableName(mapper(\"MessageUser\"), true))\n\ttypeTableName := quote(testEngine.TableName(mapper(\"MessageType\"), true))\n\tmsgTableName := quote(testEngine.TableName(mapper(\"Message\"), true))\n\n\tlist := make([]MessageExtend4, 0)\n\terr = session.Table(msgTableName).Join(\"LEFT\", userTableName, userTableName+\".`\"+mapper(\"Id\")+\"`=\"+msgTableName+\".`\"+mapper(\"Uid\")+\"`\").\n\t\tJoin(\"LEFT\", typeTableName, typeTableName+\".`\"+mapper(\"Id\")+\"`=\"+msgTableName+\".`\"+mapper(\"Id\")+\"`\").\n\t\tFind(&list)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif len(list) != 1 {\n\t\terr = errors.New(fmt.Sprintln(\"should have 1 message, got\", len(list)))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif list[0].Message.Id != msg.Id {\n\t\terr = errors.New(fmt.Sprintln(\"should message equal\", list[0].Message, msg))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif list[0].MessageUser.Id != sender.Id || list[0].MessageUser.Name != sender.Name {\n\t\terr = errors.New(fmt.Sprintln(\"should sender equal\", list[0].MessageUser, sender))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif list[0].MessageType.Id != msgtype.Id || list[0].MessageType.Name != msgtype.Name {\n\t\terr = errors.New(fmt.Sprintln(\"should msgtype equal\", list[0].MessageType, msgtype))\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\ntype Size struct {\n\tID     int64   `xorm:\"int(4) 'id' pk autoincr\"`\n\tWidth  float32 `json:\"width\" xorm:\"float 'Width'\"`\n\tHeight float32 `json:\"height\" xorm:\"float 'Height'\"`\n}\n\ntype Book struct {\n\tID         int64 `xorm:\"int(4) 'id' pk autoincr\"`\n\tSizeOpen   *Size `xorm:\"extends('Open')\"`\n\tSizeClosed *Size `xorm:\"extends('Closed')\"`\n\tSize       *Size `xorm:\"extends('')\"`\n}\n\nfunc TestExtends5(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\terr := testEngine.DropTables(&Book{}, &Size{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(&Size{}, &Book{})\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tvar sc = Size{Width: 0.2, Height: 0.4}\n\tvar so = Size{Width: 0.2, Height: 0.8}\n\tvar s = Size{Width: 0.15, Height: 1.5}\n\tvar bk1 = Book{\n\t\tSizeOpen:   &so,\n\t\tSizeClosed: &sc,\n\t\tSize:       &s,\n\t}\n\tvar bk2 = Book{\n\t\tSizeOpen: &so,\n\t}\n\tvar bk3 = Book{\n\t\tSizeClosed: &sc,\n\t\tSize:       &s,\n\t}\n\tvar bk4 = Book{}\n\tvar bk5 = Book{Size: &s}\n\t_, err = testEngine.Insert(&sc, &so, &s, &bk1, &bk2, &bk3, &bk4, &bk5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar books = map[int64]Book{\n\t\tbk1.ID: bk1,\n\t\tbk2.ID: bk2,\n\t\tbk3.ID: bk3,\n\t\tbk4.ID: bk4,\n\t\tbk5.ID: bk5,\n\t}\n\n\tsession := testEngine.NewSession()\n\tdefer session.Close()\n\n\tvar mapper = testEngine.GetTableMapper().Obj2Table\n\tvar quote = testEngine.Quote\n\tbookTableName := quote(testEngine.TableName(mapper(\"Book\"), true))\n\tsizeTableName := quote(testEngine.TableName(mapper(\"Size\"), true))\n\n\tlist := make([]Book, 0)\n\terr = session.\n\t\tSelect(fmt.Sprintf(\n\t\t\t\"%s.%s, sc.%s AS %s, sc.%s AS %s, s.%s, s.%s\",\n\t\t\tquote(bookTableName),\n\t\t\tquote(\"id\"),\n\t\t\tquote(\"Width\"),\n\t\t\tquote(\"ClosedWidth\"),\n\t\t\tquote(\"Height\"),\n\t\t\tquote(\"ClosedHeight\"),\n\t\t\tquote(\"Width\"),\n\t\t\tquote(\"Height\"),\n\t\t)).\n\t\tTable(bookTableName).\n\t\tJoin(\n\t\t\t\"LEFT\",\n\t\t\tsizeTableName+\" AS `sc`\",\n\t\t\tbookTableName+\".`SizeClosed`=sc.`id`\",\n\t\t).\n\t\tJoin(\n\t\t\t\"LEFT\",\n\t\t\tsizeTableName+\" AS `s`\",\n\t\t\tbookTableName+\".`Size`=s.`id`\",\n\t\t).\n\t\tFind(&list)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tfor _, book := range list {\n\t\tif ok := assert.Equal(t, books[book.ID].SizeClosed.Width, book.SizeClosed.Width); !ok {\n\t\t\tt.Error(\"Not bounded size closed\")\n\t\t\tpanic(\"Not bounded size closed\")\n\t\t}\n\n\t\tif ok := assert.Equal(t, books[book.ID].SizeClosed.Height, book.SizeClosed.Height); !ok {\n\t\t\tt.Error(\"Not bounded size closed\")\n\t\t\tpanic(\"Not bounded size closed\")\n\t\t}\n\n\t\tif books[book.ID].Size != nil || book.Size != nil {\n\t\t\tif ok := assert.Equal(t, books[book.ID].Size.Width, book.Size.Width); !ok {\n\t\t\t\tt.Error(\"Not bounded size\")\n\t\t\t\tpanic(\"Not bounded size\")\n\t\t\t}\n\n\t\t\tif ok := assert.Equal(t, books[book.ID].Size.Height, book.Size.Height); !ok {\n\t\t\t\tt.Error(\"Not bounded size\")\n\t\t\t\tpanic(\"Not bounded size\")\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "tag_id_test.go",
          "type": "blob",
          "size": 1.693359375,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"testing\"\n\n\t\"xorm.io/core\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype IDGonicMapper struct {\n\tID int64\n}\n\nfunc TestGonicMapperID(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\toldMapper := testEngine.GetColumnMapper()\n\ttestEngine.UnMapType(rValue(new(IDGonicMapper)).Type())\n\ttestEngine.SetMapper(core.LintGonicMapper)\n\tdefer func() {\n\t\ttestEngine.UnMapType(rValue(new(IDGonicMapper)).Type())\n\t\ttestEngine.SetMapper(oldMapper)\n\t}()\n\n\terr := testEngine.CreateTables(new(IDGonicMapper))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttables, err := testEngine.DBMetas()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor _, tb := range tables {\n\t\tif tb.Name == \"id_gonic_mapper\" {\n\t\t\tif len(tb.PKColumns()) != 1 || tb.PKColumns()[0].Name != \"id\" {\n\t\t\t\tt.Fatal(tb)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\n\tt.Fatal(\"not table id_gonic_mapper\")\n}\n\ntype IDSameMapper struct {\n\tID int64\n}\n\nfunc TestSameMapperID(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\toldMapper := testEngine.GetColumnMapper()\n\ttestEngine.UnMapType(rValue(new(IDSameMapper)).Type())\n\ttestEngine.SetMapper(core.SameMapper{})\n\tdefer func() {\n\t\ttestEngine.UnMapType(rValue(new(IDSameMapper)).Type())\n\t\ttestEngine.SetMapper(oldMapper)\n\t}()\n\n\terr := testEngine.CreateTables(new(IDSameMapper))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttables, err := testEngine.DBMetas()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor _, tb := range tables {\n\t\tif tb.Name == \"IDSameMapper\" {\n\t\t\tif len(tb.PKColumns()) != 1 || tb.PKColumns()[0].Name != \"ID\" {\n\t\t\t\tt.Fatal(tb)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\tt.Fatal(\"not table IDSameMapper\")\n}\n"
        },
        {
          "name": "tag_test.go",
          "type": "blob",
          "size": 14.01171875,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"xorm.io/core\"\n)\n\ntype UserCU struct {\n\tId      int64\n\tName    string\n\tCreated time.Time `xorm:\"created\"`\n\tUpdated time.Time `xorm:\"updated\"`\n}\n\nfunc TestCreatedAndUpdated(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tu := new(UserCU)\n\terr := testEngine.DropTables(u)\n\tassert.NoError(t, err)\n\n\terr = testEngine.CreateTables(u)\n\tassert.NoError(t, err)\n\n\tu.Name = \"sss\"\n\tcnt, err := testEngine.Insert(u)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tu.Name = \"xxx\"\n\tcnt, err = testEngine.ID(u.Id).Update(u)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tu.Id = 0\n\tu.Created = time.Now().Add(-time.Hour * 24 * 365)\n\tu.Updated = u.Created\n\tcnt, err = testEngine.NoAutoTime().Insert(u)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n}\n\ntype StrangeName struct {\n\tId_t int64 `xorm:\"pk autoincr\"`\n\tName string\n}\n\nfunc TestStrangeName(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(new(StrangeName))\n\tassert.NoError(t, err)\n\n\terr = testEngine.CreateTables(new(StrangeName))\n\tassert.NoError(t, err)\n\n\t_, err = testEngine.Insert(&StrangeName{Name: \"sfsfdsfds\"})\n\tassert.NoError(t, err)\n\n\tbeans := make([]StrangeName, 0)\n\terr = testEngine.Find(&beans)\n\tassert.NoError(t, err)\n}\n\nfunc TestCreatedUpdated(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype CreatedUpdated struct {\n\t\tId       int64\n\t\tName     string\n\t\tValue    float64   `xorm:\"numeric\"`\n\t\tCreated  time.Time `xorm:\"created\"`\n\t\tCreated2 time.Time `xorm:\"created\"`\n\t\tUpdated  time.Time `xorm:\"updated\"`\n\t}\n\n\terr := testEngine.Sync2(&CreatedUpdated{})\n\tassert.NoError(t, err)\n\n\tc := &CreatedUpdated{Name: \"test\"}\n\t_, err = testEngine.Insert(c)\n\tassert.NoError(t, err)\n\n\tc2 := new(CreatedUpdated)\n\thas, err := testEngine.ID(c.Id).Get(c2)\n\tassert.NoError(t, err)\n\n\tassert.True(t, has)\n\n\tc2.Value -= 1\n\t_, err = testEngine.ID(c2.Id).Update(c2)\n\tassert.NoError(t, err)\n}\n\nfunc TestCreatedUpdatedInt64(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype CreatedUpdatedInt64 struct {\n\t\tId       int64\n\t\tName     string\n\t\tValue    float64 `xorm:\"numeric\"`\n\t\tCreated  int64   `xorm:\"created\"`\n\t\tCreated2 int64   `xorm:\"created\"`\n\t\tUpdated  int64   `xorm:\"updated\"`\n\t}\n\n\tassertSync(t, &CreatedUpdatedInt64{})\n\n\tc := &CreatedUpdatedInt64{Name: \"test\"}\n\t_, err := testEngine.Insert(c)\n\tassert.NoError(t, err)\n\n\tc2 := new(CreatedUpdatedInt64)\n\thas, err := testEngine.ID(c.Id).Get(c2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\tc2.Value -= 1\n\t_, err = testEngine.ID(c2.Id).Update(c2)\n\tassert.NoError(t, err)\n}\n\ntype Lowercase struct {\n\tId    int64\n\tName  string\n\tended int64 `xorm:\"-\"`\n}\n\nfunc TestLowerCase(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.Sync2(&Lowercase{})\n\tassert.NoError(t, err)\n\t_, err = testEngine.Where(\"id > 0\").Delete(&Lowercase{})\n\tassert.NoError(t, err)\n\n\t_, err = testEngine.Insert(&Lowercase{ended: 1})\n\tassert.NoError(t, err)\n\n\tls := make([]Lowercase, 0)\n\terr = testEngine.Find(&ls)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(ls))\n}\n\nfunc TestAutoIncrTag(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype TestAutoIncr1 struct {\n\t\tId int64\n\t}\n\n\ttb := testEngine.TableInfo(new(TestAutoIncr1))\n\tcols := tb.Columns()\n\tassert.EqualValues(t, 1, len(cols))\n\tassert.True(t, cols[0].IsAutoIncrement)\n\tassert.True(t, cols[0].IsPrimaryKey)\n\tassert.Equal(t, \"id\", cols[0].Name)\n\n\ttype TestAutoIncr2 struct {\n\t\tId int64 `xorm:\"id\"`\n\t}\n\n\ttb = testEngine.TableInfo(new(TestAutoIncr2))\n\tcols = tb.Columns()\n\tassert.EqualValues(t, 1, len(cols))\n\tassert.False(t, cols[0].IsAutoIncrement)\n\tassert.False(t, cols[0].IsPrimaryKey)\n\tassert.Equal(t, \"id\", cols[0].Name)\n\n\ttype TestAutoIncr3 struct {\n\t\tId int64 `xorm:\"'ID'\"`\n\t}\n\n\ttb = testEngine.TableInfo(new(TestAutoIncr3))\n\tcols = tb.Columns()\n\tassert.EqualValues(t, 1, len(cols))\n\tassert.False(t, cols[0].IsAutoIncrement)\n\tassert.False(t, cols[0].IsPrimaryKey)\n\tassert.Equal(t, \"ID\", cols[0].Name)\n\n\ttype TestAutoIncr4 struct {\n\t\tId int64 `xorm:\"pk\"`\n\t}\n\n\ttb = testEngine.TableInfo(new(TestAutoIncr4))\n\tcols = tb.Columns()\n\tassert.EqualValues(t, 1, len(cols))\n\tassert.False(t, cols[0].IsAutoIncrement)\n\tassert.True(t, cols[0].IsPrimaryKey)\n\tassert.Equal(t, \"id\", cols[0].Name)\n}\n\nfunc TestTagComment(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\t// FIXME: only support mysql\n\tif testEngine.Dialect().DriverName() != core.MYSQL {\n\t\treturn\n\t}\n\n\ttype TestComment1 struct {\n\t\tId int64 `xorm:\"comment(主键)\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(TestComment1)))\n\n\ttables, err := testEngine.DBMetas()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(tables))\n\tassert.EqualValues(t, 1, len(tables[0].Columns()))\n\tassert.EqualValues(t, \"主键\", tables[0].Columns()[0].Comment)\n\n\tassert.NoError(t, testEngine.DropTables(new(TestComment1)))\n\n\ttype TestComment2 struct {\n\t\tId int64 `xorm:\"comment('主键')\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(TestComment2)))\n\n\ttables, err = testEngine.DBMetas()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(tables))\n\tassert.EqualValues(t, 1, len(tables[0].Columns()))\n\tassert.EqualValues(t, \"主键\", tables[0].Columns()[0].Comment)\n}\n\nfunc TestTagDefault(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype DefaultStruct struct {\n\t\tId   int64\n\t\tName string\n\t\tAge  int `xorm:\"default(10)\"`\n\t}\n\n\tassertSync(t, new(DefaultStruct))\n\n\ttables, err := testEngine.DBMetas()\n\tassert.NoError(t, err)\n\n\tvar defaultVal string\n\tvar isDefaultExist bool\n\ttableName := testEngine.GetColumnMapper().Obj2Table(\"DefaultStruct\")\n\tfor _, table := range tables {\n\t\tif table.Name == tableName {\n\t\t\tcol := table.GetColumn(\"age\")\n\t\t\tassert.NotNil(t, col)\n\t\t\tdefaultVal = col.Default\n\t\t\tisDefaultExist = !col.DefaultIsEmpty\n\t\t\tbreak\n\t\t}\n\t}\n\tassert.True(t, isDefaultExist)\n\tassert.EqualValues(t, \"10\", defaultVal)\n\n\tcnt, err := testEngine.Omit(\"age\").Insert(&DefaultStruct{\n\t\tName: \"test\",\n\t\tAge:  20,\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar s DefaultStruct\n\thas, err := testEngine.ID(1).Get(&s)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, 10, s.Age)\n\tassert.EqualValues(t, \"test\", s.Name)\n}\n\nfunc TestTagDefault2(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype DefaultStruct2 struct {\n\t\tId   int64\n\t\tName string\n\t}\n\n\tassertSync(t, new(DefaultStruct2))\n\n\ttables, err := testEngine.DBMetas()\n\tassert.NoError(t, err)\n\n\tvar defaultVal string\n\tvar isDefaultExist bool\n\ttableName := testEngine.GetColumnMapper().Obj2Table(\"DefaultStruct2\")\n\tfor _, table := range tables {\n\t\tif table.Name == tableName {\n\t\t\tcol := table.GetColumn(\"name\")\n\t\t\tassert.NotNil(t, col)\n\t\t\tdefaultVal = col.Default\n\t\t\tisDefaultExist = !col.DefaultIsEmpty\n\t\t\tbreak\n\t\t}\n\t}\n\tassert.False(t, isDefaultExist, fmt.Sprintf(\"default value is --%v--\", defaultVal))\n\tassert.EqualValues(t, \"\", defaultVal)\n}\n\nfunc TestTagDefault3(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype DefaultStruct3 struct {\n\t\tId   int64\n\t\tName string `xorm:\"default('myname')\"`\n\t}\n\n\tassertSync(t, new(DefaultStruct3))\n\n\ttables, err := testEngine.DBMetas()\n\tassert.NoError(t, err)\n\n\tvar defaultVal string\n\tvar isDefaultExist bool\n\ttableName := testEngine.GetColumnMapper().Obj2Table(\"DefaultStruct3\")\n\tfor _, table := range tables {\n\t\tif table.Name == tableName {\n\t\t\tcol := table.GetColumn(\"name\")\n\t\t\tassert.NotNil(t, col)\n\t\t\tdefaultVal = col.Default\n\t\t\tisDefaultExist = !col.DefaultIsEmpty\n\t\t\tbreak\n\t\t}\n\t}\n\tassert.True(t, isDefaultExist)\n\tassert.EqualValues(t, \"'myname'\", defaultVal)\n}\n\nfunc TestTagDefault4(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype DefaultStruct4 struct {\n\t\tId      int64\n\t\tCreated time.Time `xorm:\"default(CURRENT_TIMESTAMP)\"`\n\t}\n\n\tassertSync(t, new(DefaultStruct4))\n\n\ttables, err := testEngine.DBMetas()\n\tassert.NoError(t, err)\n\n\tvar defaultVal string\n\tvar isDefaultExist bool\n\ttableName := testEngine.GetColumnMapper().Obj2Table(\"DefaultStruct4\")\n\tfor _, table := range tables {\n\t\tif table.Name == tableName {\n\t\t\tcol := table.GetColumn(\"created\")\n\t\t\tassert.NotNil(t, col)\n\t\t\tdefaultVal = col.Default\n\t\t\tisDefaultExist = !col.DefaultIsEmpty\n\t\t\tbreak\n\t\t}\n\t}\n\tassert.True(t, isDefaultExist)\n\tassert.True(t, \"CURRENT_TIMESTAMP\" == defaultVal ||\n\t\t\"now()\" == defaultVal ||\n\t\t\"getdate\" == defaultVal, defaultVal)\n}\n\nfunc TestTagDefault5(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype DefaultStruct5 struct {\n\t\tId      int64\n\t\tCreated time.Time `xorm:\"default('2006-01-02 15:04:05')\"`\n\t}\n\n\tassertSync(t, new(DefaultStruct5))\n\ttable := testEngine.TableInfo(new(DefaultStruct5))\n\tcreatedCol := table.GetColumn(\"created\")\n\tassert.NotNil(t, createdCol)\n\tassert.EqualValues(t, \"'2006-01-02 15:04:05'\", createdCol.Default)\n\tassert.False(t, createdCol.DefaultIsEmpty)\n\n\ttables, err := testEngine.DBMetas()\n\tassert.NoError(t, err)\n\n\tvar defaultVal string\n\tvar isDefaultExist bool\n\ttableName := testEngine.GetColumnMapper().Obj2Table(\"DefaultStruct5\")\n\tfor _, table := range tables {\n\t\tif table.Name == tableName {\n\t\t\tcol := table.GetColumn(\"created\")\n\t\t\tassert.NotNil(t, col)\n\t\t\tdefaultVal = col.Default\n\t\t\tisDefaultExist = !col.DefaultIsEmpty\n\t\t\tbreak\n\t\t}\n\t}\n\tassert.True(t, isDefaultExist)\n\tassert.EqualValues(t, \"'2006-01-02 15:04:05'\", defaultVal)\n}\n\nfunc TestTagDefault6(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype DefaultStruct6 struct {\n\t\tId    int64\n\t\tIsMan bool `xorm:\"default(true)\"`\n\t}\n\n\tassertSync(t, new(DefaultStruct6))\n\n\ttables, err := testEngine.DBMetas()\n\tassert.NoError(t, err)\n\n\tvar defaultVal string\n\tvar isDefaultExist bool\n\ttableName := testEngine.GetColumnMapper().Obj2Table(\"DefaultStruct6\")\n\tfor _, table := range tables {\n\t\tif table.Name == tableName {\n\t\t\tcol := table.GetColumn(\"is_man\")\n\t\t\tassert.NotNil(t, col)\n\t\t\tdefaultVal = col.Default\n\t\t\tisDefaultExist = !col.DefaultIsEmpty\n\t\t\tbreak\n\t\t}\n\t}\n\tassert.True(t, isDefaultExist)\n\tif defaultVal == \"1\" {\n\t\tdefaultVal = \"true\"\n\t} else if defaultVal == \"0\" {\n\t\tdefaultVal = \"false\"\n\t}\n\tassert.EqualValues(t, \"true\", defaultVal)\n}\n\nfunc TestTagsDirection(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype OnlyFromDBStruct struct {\n\t\tId   int64\n\t\tName string\n\t\tUuid string `xorm:\"<- default '1'\"`\n\t}\n\n\tassertSync(t, new(OnlyFromDBStruct))\n\n\tcnt, err := testEngine.Insert(&OnlyFromDBStruct{\n\t\tName: \"test\",\n\t\tUuid: \"2\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar s OnlyFromDBStruct\n\thas, err := testEngine.ID(1).Get(&s)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, \"1\", s.Uuid)\n\tassert.EqualValues(t, \"test\", s.Name)\n\n\tcnt, err = testEngine.ID(1).Update(&OnlyFromDBStruct{\n\t\tUuid: \"3\",\n\t\tName: \"test1\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar s3 OnlyFromDBStruct\n\thas, err = testEngine.ID(1).Get(&s3)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, \"1\", s3.Uuid)\n\tassert.EqualValues(t, \"test1\", s3.Name)\n\n\ttype OnlyToDBStruct struct {\n\t\tId   int64\n\t\tName string\n\t\tUuid string `xorm:\"->\"`\n\t}\n\n\tassertSync(t, new(OnlyToDBStruct))\n\n\tcnt, err = testEngine.Insert(&OnlyToDBStruct{\n\t\tName: \"test\",\n\t\tUuid: \"2\",\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar s2 OnlyToDBStruct\n\thas, err = testEngine.ID(1).Get(&s2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, \"\", s2.Uuid)\n\tassert.EqualValues(t, \"test\", s2.Name)\n}\n\nfunc TestTagTime(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype TagUTCStruct struct {\n\t\tId      int64\n\t\tName    string\n\t\tCreated time.Time `xorm:\"created utc\"`\n\t}\n\n\tassertSync(t, new(TagUTCStruct))\n\n\tassert.EqualValues(t, time.Local.String(), testEngine.GetTZLocation().String())\n\n\ts := TagUTCStruct{\n\t\tName: \"utc\",\n\t}\n\tcnt, err := testEngine.Insert(&s)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar u TagUTCStruct\n\thas, err := testEngine.ID(1).Get(&u)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, s.Created.Format(\"2006-01-02 15:04:05\"), u.Created.Format(\"2006-01-02 15:04:05\"))\n\n\tvar tm string\n\thas, err = testEngine.Table(\"tag_u_t_c_struct\").Cols(\"created\").Get(&tm)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, s.Created.UTC().Format(\"2006-01-02 15:04:05\"),\n\t\tstrings.Replace(strings.Replace(tm, \"T\", \" \", -1), \"Z\", \"\", -1))\n}\n\nfunc TestSplitTag(t *testing.T) {\n\tvar cases = []struct {\n\t\ttag  string\n\t\ttags []string\n\t}{\n\t\t{\"not null default '2000-01-01 00:00:00' TIMESTAMP\", []string{\"not\", \"null\", \"default\", \"'2000-01-01 00:00:00'\", \"TIMESTAMP\"}},\n\t\t{\"TEXT\", []string{\"TEXT\"}},\n\t\t{\"default('2000-01-01 00:00:00')\", []string{\"default('2000-01-01 00:00:00')\"}},\n\t\t{\"json  binary\", []string{\"json\", \"binary\"}},\n\t}\n\n\tfor _, kase := range cases {\n\t\ttags := splitTag(kase.tag)\n\t\tif !sliceEq(tags, kase.tags) {\n\t\t\tt.Fatalf(\"[%d]%v is not equal [%d]%v\", len(tags), tags, len(kase.tags), kase.tags)\n\t\t}\n\t}\n}\n\nfunc TestTagAutoIncr(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype TagAutoIncr struct {\n\t\tId   int64\n\t\tName string\n\t}\n\n\tassertSync(t, new(TagAutoIncr))\n\n\ttables, err := testEngine.DBMetas()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(tables))\n\tassert.EqualValues(t, tableMapper.Obj2Table(\"TagAutoIncr\"), tables[0].Name)\n\tcol := tables[0].GetColumn(colMapper.Obj2Table(\"Id\"))\n\tassert.NotNil(t, col)\n\tassert.True(t, col.IsPrimaryKey)\n\tassert.True(t, col.IsAutoIncrement)\n\n\tcol2 := tables[0].GetColumn(colMapper.Obj2Table(\"Name\"))\n\tassert.NotNil(t, col2)\n\tassert.False(t, col2.IsPrimaryKey)\n\tassert.False(t, col2.IsAutoIncrement)\n}\n\nfunc TestTagPrimarykey(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\ttype TagPrimaryKey struct {\n\t\tId   int64  `xorm:\"pk\"`\n\t\tName string `xorm:\"VARCHAR(20) pk\"`\n\t}\n\n\tassertSync(t, new(TagPrimaryKey))\n\n\ttables, err := testEngine.DBMetas()\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(tables))\n\tassert.EqualValues(t, tableMapper.Obj2Table(\"TagPrimaryKey\"), tables[0].Name)\n\tcol := tables[0].GetColumn(colMapper.Obj2Table(\"Id\"))\n\tassert.NotNil(t, col)\n\tassert.True(t, col.IsPrimaryKey)\n\tassert.False(t, col.IsAutoIncrement)\n\n\tcol2 := tables[0].GetColumn(colMapper.Obj2Table(\"Name\"))\n\tassert.NotNil(t, col2)\n\tassert.True(t, col2.IsPrimaryKey)\n\tassert.False(t, col2.IsAutoIncrement)\n}\n"
        },
        {
          "name": "tag_version_test.go",
          "type": "blob",
          "size": 4.09765625,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype VersionS struct {\n\tId      int64\n\tName    string\n\tVer     int       `xorm:\"version\"`\n\tCreated time.Time `xorm:\"created\"`\n}\n\nfunc TestVersion1(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(new(VersionS))\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(new(VersionS))\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tver := &VersionS{Name: \"sfsfdsfds\"}\n\t_, err = testEngine.Insert(ver)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tfmt.Println(ver)\n\tif ver.Ver != 1 {\n\t\terr = errors.New(\"insert error\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tnewVer := new(VersionS)\n\thas, err := testEngine.ID(ver.Id).Get(newVer)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif !has {\n\t\tt.Error(errors.New(fmt.Sprintf(\"no version id is %v\", ver.Id)))\n\t\tpanic(err)\n\t}\n\tfmt.Println(newVer)\n\tif newVer.Ver != 1 {\n\t\terr = errors.New(\"insert error\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tnewVer.Name = \"-------\"\n\t_, err = testEngine.ID(ver.Id).Update(newVer)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif newVer.Ver != 2 {\n\t\terr = errors.New(\"update should set version back to struct\")\n\t\tt.Error(err)\n\t}\n\n\tnewVer = new(VersionS)\n\thas, err = testEngine.ID(ver.Id).Get(newVer)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tfmt.Println(newVer)\n\tif newVer.Ver != 2 {\n\t\terr = errors.New(\"update error\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestVersion2(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(new(VersionS))\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(new(VersionS))\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tvar vers = []VersionS{\n\t\t{Name: \"sfsfdsfds\"},\n\t\t{Name: \"xxxxx\"},\n\t}\n\t_, err = testEngine.Insert(vers)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(vers)\n\n\tfor _, v := range vers {\n\t\tif v.Ver != 1 {\n\t\t\terr := errors.New(\"version should be 1\")\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\ntype VersionUintS struct {\n\tId      int64\n\tName    string\n\tVer     uint      `xorm:\"version\"`\n\tCreated time.Time `xorm:\"created\"`\n}\n\nfunc TestVersion3(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(new(VersionUintS))\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(new(VersionUintS))\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tver := &VersionUintS{Name: \"sfsfdsfds\"}\n\t_, err = testEngine.Insert(ver)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tfmt.Println(ver)\n\tif ver.Ver != 1 {\n\t\terr = errors.New(\"insert error\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tnewVer := new(VersionUintS)\n\thas, err := testEngine.ID(ver.Id).Get(newVer)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tif !has {\n\t\tt.Error(errors.New(fmt.Sprintf(\"no version id is %v\", ver.Id)))\n\t\tpanic(err)\n\t}\n\tfmt.Println(newVer)\n\tif newVer.Ver != 1 {\n\t\terr = errors.New(\"insert error\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tnewVer.Name = \"-------\"\n\t_, err = testEngine.ID(ver.Id).Update(newVer)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tif newVer.Ver != 2 {\n\t\terr = errors.New(\"update should set version back to struct\")\n\t\tt.Error(err)\n\t}\n\n\tnewVer = new(VersionUintS)\n\thas, err = testEngine.ID(ver.Id).Get(newVer)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tfmt.Println(newVer)\n\tif newVer.Ver != 2 {\n\t\terr = errors.New(\"update error\")\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestVersion4(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(new(VersionUintS))\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\terr = testEngine.CreateTables(new(VersionUintS))\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tvar vers = []VersionUintS{\n\t\t{Name: \"sfsfdsfds\"},\n\t\t{Name: \"xxxxx\"},\n\t}\n\t_, err = testEngine.Insert(vers)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(vers)\n\n\tfor _, v := range vers {\n\t\tif v.Ver != 1 {\n\t\t\terr := errors.New(\"version should be 1\")\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "test_mssql.sh",
          "type": "blob",
          "size": 0.1044921875,
          "content": "go test -db=mssql -conn_str=\"server=localhost;user id=sa;password=yourStrong(!)Password;database=xorm_test\""
        },
        {
          "name": "test_mssql_cache.sh",
          "type": "blob",
          "size": 0.1044921875,
          "content": "go test -db=mssql -conn_str=\"server=192.168.1.58;user id=sa;password=123456;database=xorm_test\" -cache=true"
        },
        {
          "name": "test_mymysql.sh",
          "type": "blob",
          "size": 0.0458984375,
          "content": "go test -db=mymysql -conn_str=\"xorm_test/root/\""
        },
        {
          "name": "test_mymysql_cache.sh",
          "type": "blob",
          "size": 0.0576171875,
          "content": "go test -db=mymysql -conn_str=\"xorm_test/root/\" -cache=true"
        },
        {
          "name": "test_mysql.sh",
          "type": "blob",
          "size": 0.044921875,
          "content": "go test -db=mysql -conn_str=\"root:@/xorm_test\""
        },
        {
          "name": "test_mysql_cache.sh",
          "type": "blob",
          "size": 0.056640625,
          "content": "go test -db=mysql -conn_str=\"root:@/xorm_test\" -cache=true"
        },
        {
          "name": "test_postgres.sh",
          "type": "blob",
          "size": 0.0634765625,
          "content": "go test -db=postgres -conn_str=\"dbname=xorm_test sslmode=disable\""
        },
        {
          "name": "test_postgres_cache.sh",
          "type": "blob",
          "size": 0.0751953125,
          "content": "go test -db=postgres -conn_str=\"dbname=xorm_test sslmode=disable\" -cache=true"
        },
        {
          "name": "test_sqlite.sh",
          "type": "blob",
          "size": 0.0615234375,
          "content": "go test -db=sqlite3 -conn_str=\"./test.db?cache=shared&mode=rwc\""
        },
        {
          "name": "test_sqlite_cache.sh",
          "type": "blob",
          "size": 0.0732421875,
          "content": "go test -db=sqlite3 -conn_str=\"./test.db?cache=shared&mode=rwc\" -cache=true"
        },
        {
          "name": "test_tidb.sh",
          "type": "blob",
          "size": 0.08984375,
          "content": "go test -db=mysql -conn_str=\"root:@tcp(localhost:4000)/xorm_test\" -ignore_select_update=true"
        },
        {
          "name": "time_test.go",
          "type": "blob",
          "size": 13.6728515625,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestTimeUserTime(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype TimeUser struct {\n\t\tId       string\n\t\tOperTime time.Time\n\t}\n\n\tassertSync(t, new(TimeUser))\n\n\tvar user = TimeUser{\n\t\tId:       \"lunny\",\n\t\tOperTime: time.Now(),\n\t}\n\n\tfmt.Println(\"user\", user.OperTime)\n\n\tcnt, err := testEngine.Insert(&user)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar user2 TimeUser\n\thas, err := testEngine.Get(&user2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, user.OperTime.Unix(), user2.OperTime.Unix())\n\tassert.EqualValues(t, formatTime(user.OperTime), formatTime(user2.OperTime))\n\tfmt.Println(\"user2\", user2.OperTime)\n}\n\nfunc TestTimeUserTimeDiffLoc(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tloc, err := time.LoadLocation(\"Asia/Shanghai\")\n\tassert.NoError(t, err)\n\ttestEngine.SetTZLocation(loc)\n\tdbLoc, err := time.LoadLocation(\"America/New_York\")\n\tassert.NoError(t, err)\n\ttestEngine.SetTZDatabase(dbLoc)\n\n\ttype TimeUser2 struct {\n\t\tId       string\n\t\tOperTime time.Time\n\t}\n\n\tassertSync(t, new(TimeUser2))\n\n\tvar user = TimeUser2{\n\t\tId:       \"lunny\",\n\t\tOperTime: time.Now(),\n\t}\n\n\tfmt.Println(\"user\", user.OperTime)\n\n\tcnt, err := testEngine.Insert(&user)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar user2 TimeUser2\n\thas, err := testEngine.Get(&user2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, user.OperTime.Unix(), user2.OperTime.Unix())\n\tassert.EqualValues(t, formatTime(user.OperTime.In(loc)), formatTime(user2.OperTime))\n\tfmt.Println(\"user2\", user2.OperTime)\n}\n\nfunc TestTimeUserCreated(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UserCreated struct {\n\t\tId        string\n\t\tCreatedAt time.Time `xorm:\"created\"`\n\t}\n\n\tassertSync(t, new(UserCreated))\n\n\tvar user = UserCreated{\n\t\tId: \"lunny\",\n\t}\n\n\tfmt.Println(\"user\", user.CreatedAt)\n\n\tcnt, err := testEngine.Insert(&user)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar user2 UserCreated\n\thas, err := testEngine.Get(&user2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, user.CreatedAt.Unix(), user2.CreatedAt.Unix())\n\tassert.EqualValues(t, formatTime(user.CreatedAt), formatTime(user2.CreatedAt))\n\tfmt.Println(\"user2\", user2.CreatedAt)\n}\n\nfunc TestTimeUserCreatedDiffLoc(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tloc, err := time.LoadLocation(\"Asia/Shanghai\")\n\tassert.NoError(t, err)\n\ttestEngine.SetTZLocation(loc)\n\tdbLoc, err := time.LoadLocation(\"America/New_York\")\n\tassert.NoError(t, err)\n\ttestEngine.SetTZDatabase(dbLoc)\n\n\ttype UserCreated2 struct {\n\t\tId        string\n\t\tCreatedAt time.Time `xorm:\"created\"`\n\t}\n\n\tassertSync(t, new(UserCreated2))\n\n\tvar user = UserCreated2{\n\t\tId: \"lunny\",\n\t}\n\n\tfmt.Println(\"user\", user.CreatedAt)\n\n\tcnt, err := testEngine.Insert(&user)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar user2 UserCreated2\n\thas, err := testEngine.Get(&user2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, user.CreatedAt.Unix(), user2.CreatedAt.Unix())\n\tassert.EqualValues(t, formatTime(user.CreatedAt), formatTime(user2.CreatedAt))\n\tfmt.Println(\"user2\", user2.CreatedAt)\n}\n\nfunc TestTimeUserUpdated(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UserUpdated struct {\n\t\tId        string\n\t\tCreatedAt time.Time `xorm:\"created\"`\n\t\tUpdatedAt time.Time `xorm:\"updated\"`\n\t}\n\n\tassertSync(t, new(UserUpdated))\n\n\tvar user = UserUpdated{\n\t\tId: \"lunny\",\n\t}\n\n\tfmt.Println(\"user\", user.CreatedAt, user.UpdatedAt)\n\n\tcnt, err := testEngine.Insert(&user)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar user2 UserUpdated\n\thas, err := testEngine.Get(&user2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, user.CreatedAt.Unix(), user2.CreatedAt.Unix())\n\tassert.EqualValues(t, formatTime(user.CreatedAt), formatTime(user2.CreatedAt))\n\tassert.EqualValues(t, user.UpdatedAt.Unix(), user2.UpdatedAt.Unix())\n\tassert.EqualValues(t, formatTime(user.UpdatedAt), formatTime(user2.UpdatedAt))\n\tfmt.Println(\"user2\", user2.CreatedAt, user2.UpdatedAt)\n\n\tvar user3 = UserUpdated{\n\t\tId: \"lunny2\",\n\t}\n\n\tcnt, err = testEngine.Update(&user3)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\tassert.True(t, user.UpdatedAt.Unix() <= user3.UpdatedAt.Unix())\n\n\tvar user4 UserUpdated\n\thas, err = testEngine.Get(&user4)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, user.CreatedAt.Unix(), user4.CreatedAt.Unix())\n\tassert.EqualValues(t, formatTime(user.CreatedAt), formatTime(user4.CreatedAt))\n\tassert.EqualValues(t, user3.UpdatedAt.Unix(), user4.UpdatedAt.Unix())\n\tassert.EqualValues(t, formatTime(user3.UpdatedAt), formatTime(user4.UpdatedAt))\n\tfmt.Println(\"user3\", user.CreatedAt, user4.UpdatedAt)\n}\n\nfunc TestTimeUserUpdatedDiffLoc(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tloc, err := time.LoadLocation(\"Asia/Shanghai\")\n\tassert.NoError(t, err)\n\ttestEngine.SetTZLocation(loc)\n\tdbLoc, err := time.LoadLocation(\"America/New_York\")\n\tassert.NoError(t, err)\n\ttestEngine.SetTZDatabase(dbLoc)\n\n\ttype UserUpdated2 struct {\n\t\tId        string\n\t\tCreatedAt time.Time `xorm:\"created\"`\n\t\tUpdatedAt time.Time `xorm:\"updated\"`\n\t}\n\n\tassertSync(t, new(UserUpdated2))\n\n\tvar user = UserUpdated2{\n\t\tId: \"lunny\",\n\t}\n\n\tfmt.Println(\"user\", user.CreatedAt, user.UpdatedAt)\n\n\tcnt, err := testEngine.Insert(&user)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar user2 UserUpdated2\n\thas, err := testEngine.Get(&user2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, user.CreatedAt.Unix(), user2.CreatedAt.Unix())\n\tassert.EqualValues(t, formatTime(user.CreatedAt), formatTime(user2.CreatedAt))\n\tassert.EqualValues(t, user.UpdatedAt.Unix(), user2.UpdatedAt.Unix())\n\tassert.EqualValues(t, formatTime(user.UpdatedAt), formatTime(user2.UpdatedAt))\n\tfmt.Println(\"user2\", user2.CreatedAt, user2.UpdatedAt)\n\n\tvar user3 = UserUpdated2{\n\t\tId: \"lunny2\",\n\t}\n\n\tcnt, err = testEngine.Update(&user3)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\tassert.True(t, user.UpdatedAt.Unix() <= user3.UpdatedAt.Unix())\n\n\tvar user4 UserUpdated2\n\thas, err = testEngine.Get(&user4)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, user.CreatedAt.Unix(), user4.CreatedAt.Unix())\n\tassert.EqualValues(t, formatTime(user.CreatedAt), formatTime(user4.CreatedAt))\n\tassert.EqualValues(t, user3.UpdatedAt.Unix(), user4.UpdatedAt.Unix())\n\tassert.EqualValues(t, formatTime(user3.UpdatedAt), formatTime(user4.UpdatedAt))\n\tfmt.Println(\"user3\", user.CreatedAt, user4.UpdatedAt)\n}\n\nfunc TestTimeUserDeleted(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UserDeleted struct {\n\t\tId        string\n\t\tCreatedAt time.Time `xorm:\"created\"`\n\t\tUpdatedAt time.Time `xorm:\"updated\"`\n\t\tDeletedAt time.Time `xorm:\"deleted\"`\n\t}\n\n\tassertSync(t, new(UserDeleted))\n\n\tvar user = UserDeleted{\n\t\tId: \"lunny\",\n\t}\n\n\tcnt, err := testEngine.Insert(&user)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\tfmt.Println(\"user\", user.CreatedAt, user.UpdatedAt, user.DeletedAt)\n\n\tvar user2 UserDeleted\n\thas, err := testEngine.Get(&user2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, user.CreatedAt.Unix(), user2.CreatedAt.Unix())\n\tassert.EqualValues(t, formatTime(user.CreatedAt), formatTime(user2.CreatedAt))\n\tassert.EqualValues(t, user.UpdatedAt.Unix(), user2.UpdatedAt.Unix())\n\tassert.EqualValues(t, formatTime(user.UpdatedAt), formatTime(user2.UpdatedAt))\n\tassert.True(t, isTimeZero(user2.DeletedAt))\n\tfmt.Println(\"user2\", user2.CreatedAt, user2.UpdatedAt, user2.DeletedAt)\n\n\tvar user3 UserDeleted\n\tcnt, err = testEngine.Where(\"id = ?\", \"lunny\").Delete(&user3)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\tassert.True(t, !isTimeZero(user3.DeletedAt))\n\n\tvar user4 UserDeleted\n\thas, err = testEngine.Unscoped().Get(&user4)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, user3.DeletedAt.Unix(), user4.DeletedAt.Unix())\n\tassert.EqualValues(t, formatTime(user3.DeletedAt), formatTime(user4.DeletedAt))\n\tfmt.Println(\"user3\", user3.DeletedAt, user4.DeletedAt)\n}\n\nfunc TestTimeUserDeletedDiffLoc(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tloc, err := time.LoadLocation(\"Asia/Shanghai\")\n\tassert.NoError(t, err)\n\ttestEngine.SetTZLocation(loc)\n\tdbLoc, err := time.LoadLocation(\"America/New_York\")\n\tassert.NoError(t, err)\n\ttestEngine.SetTZDatabase(dbLoc)\n\n\ttype UserDeleted2 struct {\n\t\tId        string\n\t\tCreatedAt time.Time `xorm:\"created\"`\n\t\tUpdatedAt time.Time `xorm:\"updated\"`\n\t\tDeletedAt time.Time `xorm:\"deleted\"`\n\t}\n\n\tassertSync(t, new(UserDeleted2))\n\n\tvar user = UserDeleted2{\n\t\tId: \"lunny\",\n\t}\n\n\tcnt, err := testEngine.Insert(&user)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\tfmt.Println(\"user\", user.CreatedAt, user.UpdatedAt, user.DeletedAt)\n\n\tvar user2 UserDeleted2\n\thas, err := testEngine.Get(&user2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, user.CreatedAt.Unix(), user2.CreatedAt.Unix())\n\tassert.EqualValues(t, formatTime(user.CreatedAt), formatTime(user2.CreatedAt))\n\tassert.EqualValues(t, user.UpdatedAt.Unix(), user2.UpdatedAt.Unix())\n\tassert.EqualValues(t, formatTime(user.UpdatedAt), formatTime(user2.UpdatedAt))\n\tassert.True(t, isTimeZero(user2.DeletedAt))\n\tfmt.Println(\"user2\", user2.CreatedAt, user2.UpdatedAt, user2.DeletedAt)\n\n\tvar user3 UserDeleted2\n\tcnt, err = testEngine.Where(\"id = ?\", \"lunny\").Delete(&user3)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\tassert.True(t, !isTimeZero(user3.DeletedAt))\n\n\tvar user4 UserDeleted2\n\thas, err = testEngine.Unscoped().Get(&user4)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, user3.DeletedAt.Unix(), user4.DeletedAt.Unix())\n\tassert.EqualValues(t, formatTime(user3.DeletedAt), formatTime(user4.DeletedAt))\n\tfmt.Println(\"user3\", user3.DeletedAt, user4.DeletedAt)\n}\n\ntype JsonDate time.Time\n\nfunc (j JsonDate) MarshalJSON() ([]byte, error) {\n\tif time.Time(j).IsZero() {\n\t\treturn []byte(`\"\"`), nil\n\t}\n\treturn []byte(`\"` + time.Time(j).Format(\"2006-01-02 15:04:05\") + `\"`), nil\n}\n\nfunc (j *JsonDate) UnmarshalJSON(value []byte) error {\n\tvar v = strings.TrimSpace(strings.Trim(string(value), \"\\\"\"))\n\n\tt, err := time.ParseInLocation(\"2006-01-02 15:04:05\", v, time.Local)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*j = JsonDate(t)\n\treturn nil\n}\n\nfunc (j *JsonDate) Unix() int64 {\n\treturn (*time.Time)(j).Unix()\n}\n\nfunc TestCustomTimeUserDeleted(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype UserDeleted3 struct {\n\t\tId        string\n\t\tCreatedAt JsonDate `xorm:\"created\"`\n\t\tUpdatedAt JsonDate `xorm:\"updated\"`\n\t\tDeletedAt JsonDate `xorm:\"deleted\"`\n\t}\n\n\tassertSync(t, new(UserDeleted3))\n\n\tvar user = UserDeleted3{\n\t\tId: \"lunny\",\n\t}\n\n\tcnt, err := testEngine.Insert(&user)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\tfmt.Println(\"user\", user.CreatedAt, user.UpdatedAt, user.DeletedAt)\n\n\tvar user2 UserDeleted3\n\thas, err := testEngine.Get(&user2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, user.CreatedAt.Unix(), user2.CreatedAt.Unix())\n\tassert.EqualValues(t, formatTime(time.Time(user.CreatedAt)), formatTime(time.Time(user2.CreatedAt)))\n\tassert.EqualValues(t, user.UpdatedAt.Unix(), user2.UpdatedAt.Unix())\n\tassert.EqualValues(t, formatTime(time.Time(user.UpdatedAt)), formatTime(time.Time(user2.UpdatedAt)))\n\tassert.True(t, isTimeZero(time.Time(user2.DeletedAt)))\n\tfmt.Println(\"user2\", user2.CreatedAt, user2.UpdatedAt, user2.DeletedAt)\n\n\tvar user3 UserDeleted3\n\tcnt, err = testEngine.Where(\"id = ?\", \"lunny\").Delete(&user3)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\tassert.True(t, !isTimeZero(time.Time(user3.DeletedAt)))\n\n\tvar user4 UserDeleted3\n\thas, err = testEngine.Unscoped().Get(&user4)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, user3.DeletedAt.Unix(), user4.DeletedAt.Unix())\n\tassert.EqualValues(t, formatTime(time.Time(user3.DeletedAt)), formatTime(time.Time(user4.DeletedAt)))\n\tfmt.Println(\"user3\", user3.DeletedAt, user4.DeletedAt)\n}\n\nfunc TestCustomTimeUserDeletedDiffLoc(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tloc, err := time.LoadLocation(\"Asia/Shanghai\")\n\tassert.NoError(t, err)\n\ttestEngine.SetTZLocation(loc)\n\tdbLoc, err := time.LoadLocation(\"America/New_York\")\n\tassert.NoError(t, err)\n\ttestEngine.SetTZDatabase(dbLoc)\n\n\ttype UserDeleted4 struct {\n\t\tId        string\n\t\tCreatedAt JsonDate `xorm:\"created\"`\n\t\tUpdatedAt JsonDate `xorm:\"updated\"`\n\t\tDeletedAt JsonDate `xorm:\"deleted\"`\n\t}\n\n\tassertSync(t, new(UserDeleted4))\n\n\tvar user = UserDeleted4{\n\t\tId: \"lunny\",\n\t}\n\n\tcnt, err := testEngine.Insert(&user)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\tfmt.Println(\"user\", user.CreatedAt, user.UpdatedAt, user.DeletedAt)\n\n\tvar user2 UserDeleted4\n\thas, err := testEngine.Get(&user2)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, user.CreatedAt.Unix(), user2.CreatedAt.Unix())\n\tassert.EqualValues(t, formatTime(time.Time(user.CreatedAt)), formatTime(time.Time(user2.CreatedAt)))\n\tassert.EqualValues(t, user.UpdatedAt.Unix(), user2.UpdatedAt.Unix())\n\tassert.EqualValues(t, formatTime(time.Time(user.UpdatedAt)), formatTime(time.Time(user2.UpdatedAt)))\n\tassert.True(t, isTimeZero(time.Time(user2.DeletedAt)))\n\tfmt.Println(\"user2\", user2.CreatedAt, user2.UpdatedAt, user2.DeletedAt)\n\n\tvar user3 UserDeleted4\n\tcnt, err = testEngine.Where(\"id = ?\", \"lunny\").Delete(&user3)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\tassert.True(t, !isTimeZero(time.Time(user3.DeletedAt)))\n\n\tvar user4 UserDeleted4\n\thas, err = testEngine.Unscoped().Get(&user4)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, user3.DeletedAt.Unix(), user4.DeletedAt.Unix())\n\tassert.EqualValues(t, formatTime(time.Time(user3.DeletedAt)), formatTime(time.Time(user4.DeletedAt)))\n\tfmt.Println(\"user3\", user3.DeletedAt, user4.DeletedAt)\n}\n"
        },
        {
          "name": "transaction.go",
          "type": "blob",
          "size": 0.6396484375,
          "content": "// Copyright 2018 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\n// Transaction Execute sql wrapped in a transaction(abbr as tx), tx will automatic commit if no errors occurred\nfunc (engine *Engine) Transaction(f func(*Session) (interface{}, error)) (interface{}, error) {\n\tsession := engine.NewSession()\n\tdefer session.Close()\n\n\tif err := session.Begin(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tresult, err := f(session)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := session.Commit(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, nil\n}\n"
        },
        {
          "name": "transancation_test.go",
          "type": "blob",
          "size": 1.1572265625,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAutoTransaction(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype TestTx struct {\n\t\tId      int64     `xorm:\"autoincr pk\"`\n\t\tMsg     string    `xorm:\"varchar(255)\"`\n\t\tCreated time.Time `xorm:\"created\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(TestTx)))\n\n\tengine := testEngine.(*Engine)\n\n\t// will success\n\tengine.Transaction(func(session *Session) (interface{}, error) {\n\t\t_, err := session.Insert(TestTx{Msg: \"hi\"})\n\t\tassert.NoError(t, err)\n\n\t\treturn nil, nil\n\t})\n\n\thas, err := engine.Exist(&TestTx{Msg: \"hi\"})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, true, has)\n\n\t// will rollback\n\t_, err = engine.Transaction(func(session *Session) (interface{}, error) {\n\t\t_, err := session.Insert(TestTx{Msg: \"hello\"})\n\t\tassert.NoError(t, err)\n\n\t\treturn nil, fmt.Errorf(\"rollback\")\n\t})\n\tassert.Error(t, err)\n\n\thas, err = engine.Exist(&TestTx{Msg: \"hello\"})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, false, has)\n}\n"
        },
        {
          "name": "types.go",
          "type": "blob",
          "size": 0.2958984375,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"reflect\"\n\n\t\"xorm.io/core\"\n)\n\nvar (\n\tptrPkType = reflect.TypeOf(&core.PK{})\n\tpkType    = reflect.TypeOf(core.PK{})\n)\n"
        },
        {
          "name": "types_null_test.go",
          "type": "blob",
          "size": 7.328125,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype NullType struct {\n\tId           int `xorm:\"pk autoincr\"`\n\tName         sql.NullString\n\tAge          sql.NullInt64\n\tHeight       sql.NullFloat64\n\tIsMan        sql.NullBool `xorm:\"null\"`\n\tCustomStruct CustomStruct `xorm:\"valchar(64) null\"`\n}\n\ntype CustomStruct struct {\n\tYear  int\n\tMonth int\n\tDay   int\n}\n\nfunc (CustomStruct) String() string {\n\treturn \"CustomStruct\"\n}\n\nfunc (m *CustomStruct) Scan(value interface{}) error {\n\tif value == nil {\n\t\tm.Year, m.Month, m.Day = 0, 0, 0\n\t\treturn nil\n\t}\n\n\tif s, ok := value.([]byte); ok {\n\t\tseps := strings.Split(string(s), \"/\")\n\t\tm.Year, _ = strconv.Atoi(seps[0])\n\t\tm.Month, _ = strconv.Atoi(seps[1])\n\t\tm.Day, _ = strconv.Atoi(seps[2])\n\t\treturn nil\n\t}\n\n\treturn errors.New(\"scan data not fit []byte\")\n}\n\nfunc (m CustomStruct) Value() (driver.Value, error) {\n\treturn fmt.Sprintf(\"%d/%d/%d\", m.Year, m.Month, m.Day), nil\n}\n\nfunc TestCreateNullStructTable(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.CreateTables(new(NullType))\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestDropNullStructTable(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(new(NullType))\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n\nfunc TestNullStructInsert(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(NullType))\n\n\tif true {\n\t\titem := new(NullType)\n\t\t_, err := testEngine.Insert(item)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(item)\n\t\tif item.Id != 1 {\n\t\t\terr = errors.New(\"insert error\")\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tif true {\n\t\titem := NullType{\n\t\t\tName:   sql.NullString{\"haolei\", true},\n\t\t\tAge:    sql.NullInt64{34, true},\n\t\t\tHeight: sql.NullFloat64{1.72, true},\n\t\t\tIsMan:  sql.NullBool{true, true},\n\t\t}\n\t\t_, err := testEngine.Insert(&item)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(item)\n\t\tif item.Id != 2 {\n\t\t\terr = errors.New(\"insert error\")\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tif true {\n\t\titems := []NullType{}\n\n\t\tfor i := 0; i < 5; i++ {\n\t\t\titem := NullType{\n\t\t\t\tName:         sql.NullString{\"haolei_\" + fmt.Sprint(i+1), true},\n\t\t\t\tAge:          sql.NullInt64{30 + int64(i), true},\n\t\t\t\tHeight:       sql.NullFloat64{1.5 + 1.1*float64(i), true},\n\t\t\t\tIsMan:        sql.NullBool{true, true},\n\t\t\t\tCustomStruct: CustomStruct{i, i + 1, i + 2},\n\t\t\t}\n\n\t\t\titems = append(items, item)\n\t\t}\n\n\t\t_, err := testEngine.Insert(&items)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(items)\n\t}\n}\n\nfunc TestNullStructUpdate(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(NullType))\n\n\t_, err := testEngine.Insert([]NullType{\n\t\t{\n\t\t\tName: sql.NullString{\n\t\t\t\tString: \"name1\",\n\t\t\t\tValid:  true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: sql.NullString{\n\t\t\t\tString: \"name2\",\n\t\t\t\tValid:  true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: sql.NullString{\n\t\t\t\tString: \"name3\",\n\t\t\t\tValid:  true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: sql.NullString{\n\t\t\t\tString: \"name4\",\n\t\t\t\tValid:  true,\n\t\t\t},\n\t\t},\n\t})\n\tassert.NoError(t, err)\n\n\tif true { // 测试可插入NULL\n\t\titem := new(NullType)\n\t\titem.Age = sql.NullInt64{23, true}\n\t\titem.Height = sql.NullFloat64{0, false} // update to NULL\n\n\t\taffected, err := testEngine.ID(2).Cols(\"age\", \"height\", \"is_man\").Update(item)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t\tif affected != 1 {\n\t\t\terr := errors.New(\"update failed\")\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tif true { // 测试In update\n\t\titem := new(NullType)\n\t\titem.Age = sql.NullInt64{23, true}\n\t\taffected, err := testEngine.In(\"id\", 3, 4).Cols(\"age\", \"height\", \"is_man\").Update(item)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t\tif affected != 2 {\n\t\t\terr := errors.New(\"update failed\")\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tif true { // 测试where\n\t\titem := new(NullType)\n\t\titem.Name = sql.NullString{\"nullname\", true}\n\t\titem.IsMan = sql.NullBool{true, true}\n\t\titem.Age = sql.NullInt64{34, true}\n\n\t\t_, err := testEngine.Where(\"age > ?\", 34).Update(item)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tif true { // 修改全部时，插入空值\n\t\titem := &NullType{\n\t\t\tName:   sql.NullString{\"winxxp\", true},\n\t\t\tAge:    sql.NullInt64{30, true},\n\t\t\tHeight: sql.NullFloat64{1.72, true},\n\t\t\t// IsMan:  sql.NullBool{true, true},\n\t\t}\n\n\t\t_, err := testEngine.AllCols().ID(6).Update(item)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(item)\n\t}\n\n}\n\nfunc TestNullStructFind(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(NullType))\n\n\t_, err := testEngine.Insert([]NullType{\n\t\t{\n\t\t\tName: sql.NullString{\n\t\t\t\tString: \"name1\",\n\t\t\t\tValid:  false,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: sql.NullString{\n\t\t\t\tString: \"name2\",\n\t\t\t\tValid:  true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: sql.NullString{\n\t\t\t\tString: \"name3\",\n\t\t\t\tValid:  true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: sql.NullString{\n\t\t\t\tString: \"name4\",\n\t\t\t\tValid:  true,\n\t\t\t},\n\t\t},\n\t})\n\tassert.NoError(t, err)\n\n\tif true {\n\t\titem := new(NullType)\n\t\thas, err := testEngine.ID(1).Get(item)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t\tif !has {\n\t\t\tt.Error(errors.New(\"no find id 1\"))\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(item)\n\t\tif item.Id != 1 || item.Name.Valid || item.Age.Valid || item.Height.Valid ||\n\t\t\titem.IsMan.Valid {\n\t\t\terr = errors.New(\"insert error\")\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tif true {\n\t\titem := new(NullType)\n\t\titem.Id = 2\n\n\t\thas, err := testEngine.Get(item)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t\tif !has {\n\t\t\tt.Error(errors.New(\"no find id 2\"))\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(item)\n\t}\n\n\tif true {\n\t\titem := make([]NullType, 0)\n\n\t\terr := testEngine.ID(2).Find(&item)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\n\t\tfmt.Println(item)\n\t}\n\n\tif true {\n\t\titem := make([]NullType, 0)\n\n\t\terr := testEngine.Asc(\"age\").Find(&item)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\n\t\tfor k, v := range item {\n\t\t\tfmt.Println(k, v)\n\t\t}\n\t}\n}\n\nfunc TestNullStructIterate(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(NullType))\n\n\tif true {\n\t\terr := testEngine.Where(\"age IS NOT NULL\").OrderBy(\"age\").Iterate(new(NullType),\n\t\t\tfunc(i int, bean interface{}) error {\n\t\t\t\tnultype := bean.(*NullType)\n\t\t\t\tfmt.Println(i, nultype)\n\t\t\t\treturn nil\n\t\t\t})\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\nfunc TestNullStructCount(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(NullType))\n\n\tif true {\n\t\titem := new(NullType)\n\t\ttotal, err := testEngine.Where(\"age IS NOT NULL\").Count(item)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(total)\n\t}\n}\n\nfunc TestNullStructRows(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(NullType))\n\n\titem := new(NullType)\n\trows, err := testEngine.Where(\"id > ?\", 1).Rows(item)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\terr = rows.Scan(item)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(item)\n\t}\n}\n\nfunc TestNullStructDelete(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\tassertSync(t, new(NullType))\n\n\titem := new(NullType)\n\n\t_, err := testEngine.ID(1).Delete(item)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n\n\t_, err = testEngine.Where(\"id > ?\", 1).Delete(item)\n\tif err != nil {\n\t\tt.Error(err)\n\t\tpanic(err)\n\t}\n}\n"
        },
        {
          "name": "types_test.go",
          "type": "blob",
          "size": 7.4423828125,
          "content": "// Copyright 2017 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"xorm.io/core\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestArrayField(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype ArrayStruct struct {\n\t\tId   int64\n\t\tName [20]byte `xorm:\"char(80)\"`\n\t}\n\n\tassert.NoError(t, testEngine.Sync2(new(ArrayStruct)))\n\n\tvar as = ArrayStruct{\n\t\tName: [20]byte{\n\t\t\t96, 96, 96, 96, 96,\n\t\t\t96, 96, 96, 96, 96,\n\t\t\t96, 96, 96, 96, 96,\n\t\t\t96, 96, 96, 96, 96,\n\t\t},\n\t}\n\tcnt, err := testEngine.Insert(&as)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar arr ArrayStruct\n\thas, err := testEngine.ID(1).Get(&arr)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.Equal(t, as.Name, arr.Name)\n\n\tvar arrs []ArrayStruct\n\terr = testEngine.Find(&arrs)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(arrs))\n\tassert.Equal(t, as.Name, arrs[0].Name)\n\n\tvar newName = [20]byte{\n\t\t90, 96, 96, 96, 96,\n\t\t96, 96, 96, 96, 96,\n\t\t96, 96, 96, 96, 96,\n\t\t96, 96, 96, 96, 96,\n\t}\n\n\tcnt, err = testEngine.ID(1).Update(&ArrayStruct{\n\t\tName: newName,\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar newArr ArrayStruct\n\thas, err = testEngine.ID(1).Get(&newArr)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.Equal(t, newName, newArr.Name)\n\n\tcnt, err = testEngine.ID(1).Delete(new(ArrayStruct))\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar cfgArr ArrayStruct\n\thas, err = testEngine.ID(1).Get(&cfgArr)\n\tassert.NoError(t, err)\n\tassert.Equal(t, false, has)\n}\n\nfunc TestGetBytes(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\ttype Varbinary struct {\n\t\tData []byte `xorm:\"VARBINARY(250)\"`\n\t}\n\n\terr := testEngine.Sync2(new(Varbinary))\n\tassert.NoError(t, err)\n\n\tcnt, err := testEngine.Insert(&Varbinary{\n\t\tData: []byte(\"test\"),\n\t})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tvar b Varbinary\n\thas, err := testEngine.Get(&b)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, has)\n\tassert.Equal(t, \"test\", string(b.Data))\n}\n\ntype ConvString string\n\nfunc (s *ConvString) FromDB(data []byte) error {\n\t*s = ConvString(\"prefix---\" + string(data))\n\treturn nil\n}\n\nfunc (s *ConvString) ToDB() ([]byte, error) {\n\treturn []byte(string(*s)), nil\n}\n\ntype ConvConfig struct {\n\tName string\n\tId   int64\n}\n\nfunc (s *ConvConfig) FromDB(data []byte) error {\n\treturn DefaultJSONHandler.Unmarshal(data, s)\n}\n\nfunc (s *ConvConfig) ToDB() ([]byte, error) {\n\treturn DefaultJSONHandler.Marshal(s)\n}\n\ntype SliceType []*ConvConfig\n\nfunc (s *SliceType) FromDB(data []byte) error {\n\treturn DefaultJSONHandler.Unmarshal(data, s)\n}\n\nfunc (s *SliceType) ToDB() ([]byte, error) {\n\treturn DefaultJSONHandler.Marshal(s)\n}\n\ntype ConvStruct struct {\n\tConv  ConvString\n\tConv2 *ConvString\n\tCfg1  ConvConfig\n\tCfg2  *ConvConfig     `xorm:\"TEXT\"`\n\tCfg3  core.Conversion `xorm:\"BLOB\"`\n\tSlice SliceType\n}\n\nfunc (c *ConvStruct) BeforeSet(name string, cell Cell) {\n\tif name == \"cfg3\" || name == \"Cfg3\" {\n\t\tc.Cfg3 = new(ConvConfig)\n\t}\n}\n\nfunc TestConversion(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tc := new(ConvStruct)\n\tassert.NoError(t, testEngine.DropTables(c))\n\tassert.NoError(t, testEngine.Sync2(c))\n\n\tvar s ConvString = \"sssss\"\n\tc.Conv = \"tttt\"\n\tc.Conv2 = &s\n\tc.Cfg1 = ConvConfig{\"mm\", 1}\n\tc.Cfg2 = &ConvConfig{\"xx\", 2}\n\tc.Cfg3 = &ConvConfig{\"zz\", 3}\n\tc.Slice = []*ConvConfig{{\"yy\", 4}, {\"ff\", 5}}\n\n\t_, err := testEngine.Insert(c)\n\tassert.NoError(t, err)\n\n\tc1 := new(ConvStruct)\n\thas, err := testEngine.Get(c1)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\tassert.EqualValues(t, \"prefix---tttt\", string(c1.Conv))\n\tassert.NotNil(t, c1.Conv2)\n\tassert.EqualValues(t, \"prefix---\"+s, *c1.Conv2)\n\tassert.EqualValues(t, c.Cfg1, c1.Cfg1)\n\tassert.NotNil(t, c1.Cfg2)\n\tassert.EqualValues(t, *c.Cfg2, *c1.Cfg2)\n\tassert.NotNil(t, c1.Cfg3)\n\tassert.EqualValues(t, *c.Cfg3.(*ConvConfig), *c1.Cfg3.(*ConvConfig))\n\tassert.EqualValues(t, 2, len(c1.Slice))\n\tassert.EqualValues(t, *c.Slice[0], *c1.Slice[0])\n\tassert.EqualValues(t, *c.Slice[1], *c1.Slice[1])\n}\n\ntype MyInt int\ntype MyUInt uint\ntype MyFloat float64\n\ntype MyStruct struct {\n\tType      MyInt\n\tU         MyUInt\n\tF         MyFloat\n\tS         MyString\n\tIA        []MyInt\n\tUA        []MyUInt\n\tFA        []MyFloat\n\tSA        []MyString\n\tNameArray []string\n\tName      string\n\tUIA       []uint\n\tUIA8      []uint8\n\tUIA16     []uint16\n\tUIA32     []uint32\n\tUIA64     []uint64\n\tUI        uint\n\t//C64       complex64\n\tMSS map[string]string\n}\n\nfunc TestCustomType1(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\terr := testEngine.DropTables(&MyStruct{})\n\tassert.NoError(t, err)\n\n\terr = testEngine.CreateTables(&MyStruct{})\n\tassert.NoError(t, err)\n\n\ti := MyStruct{Name: \"Test\", Type: MyInt(1)}\n\ti.U = 23\n\ti.F = 1.34\n\ti.S = \"fafdsafdsaf\"\n\ti.UI = 2\n\ti.IA = []MyInt{1, 3, 5}\n\ti.UIA = []uint{1, 3}\n\ti.UIA16 = []uint16{2}\n\ti.UIA32 = []uint32{4, 5}\n\ti.UIA64 = []uint64{6, 7, 9}\n\ti.UIA8 = []uint8{1, 2, 3, 4}\n\ti.NameArray = []string{\"ssss\", \"fsdf\", \"lllll, ss\"}\n\ti.MSS = map[string]string{\"s\": \"sfds,ss\", \"x\": \"lfjljsl\"}\n\n\tcnt, err := testEngine.Insert(&i)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tfmt.Println(i)\n\ti.NameArray = []string{}\n\ti.MSS = map[string]string{}\n\ti.F = 0\n\thas, err := testEngine.Get(&i)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\tss := []MyStruct{}\n\terr = testEngine.Find(&ss)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(ss))\n\tassert.EqualValues(t, i, ss[0])\n\n\tsss := MyStruct{}\n\thas, err = testEngine.Get(&sss)\n\tassert.NoError(t, err)\n\tassert.True(t, has)\n\n\tsss.NameArray = []string{}\n\tsss.MSS = map[string]string{}\n\tcnt, err = testEngine.Delete(&sss)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n}\n\ntype Status struct {\n\tName  string\n\tColor string\n}\n\nvar (\n\t_        core.Conversion   = &Status{}\n\tRegisted Status            = Status{\"Registed\", \"white\"}\n\tApproved Status            = Status{\"Approved\", \"green\"}\n\tRemoved  Status            = Status{\"Removed\", \"red\"}\n\tStatuses map[string]Status = map[string]Status{\n\t\tRegisted.Name: Registed,\n\t\tApproved.Name: Approved,\n\t\tRemoved.Name:  Removed,\n\t}\n)\n\nfunc (s *Status) FromDB(bytes []byte) error {\n\tif r, ok := Statuses[string(bytes)]; ok {\n\t\t*s = r\n\t\treturn nil\n\t} else {\n\t\treturn errors.New(\"no this data\")\n\t}\n}\n\nfunc (s *Status) ToDB() ([]byte, error) {\n\treturn []byte(s.Name), nil\n}\n\ntype UserCus struct {\n\tId     int64\n\tName   string\n\tStatus Status `xorm:\"varchar(40)\"`\n}\n\nfunc TestCustomType2(t *testing.T) {\n\tassert.NoError(t, prepareEngine())\n\n\tvar uc UserCus\n\terr := testEngine.CreateTables(&uc)\n\tassert.NoError(t, err)\n\n\ttableName := testEngine.TableName(&uc, true)\n\t_, err = testEngine.Exec(\"delete from \" + testEngine.Quote(tableName))\n\tassert.NoError(t, err)\n\n\tsession := testEngine.NewSession()\n\tdefer session.Close()\n\n\tif testEngine.Dialect().DBType() == core.MSSQL {\n\t\terr = session.Begin()\n\t\tassert.NoError(t, err)\n\t\t_, err = session.Exec(\"set IDENTITY_INSERT \" + tableName + \" on\")\n\t\tassert.NoError(t, err)\n\t}\n\n\tcnt, err := session.Insert(&UserCus{1, \"xlw\", Registed})\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, cnt)\n\n\tif testEngine.Dialect().DBType() == core.MSSQL {\n\t\terr = session.Commit()\n\t\tassert.NoError(t, err)\n\t}\n\n\tuser := UserCus{}\n\texist, err := testEngine.ID(1).Get(&user)\n\tassert.NoError(t, err)\n\tassert.True(t, exist)\n\n\tfmt.Println(user)\n\n\tusers := make([]UserCus, 0)\n\terr = testEngine.Where(\"`\"+testEngine.GetColumnMapper().Obj2Table(\"Status\")+\"` = ?\", \"Registed\").Find(&users)\n\tassert.NoError(t, err)\n\tassert.EqualValues(t, 1, len(users))\n\n\tfmt.Println(users)\n}\n"
        },
        {
          "name": "xorm.go",
          "type": "blob",
          "size": 3.6943359375,
          "content": "// Copyright 2015 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build go1.8\n\npackage xorm\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n\n\t\"xorm.io/core\"\n)\n\nconst (\n\t// Version show the xorm's version\n\tVersion string = \"0.7.0.0504\"\n)\n\nfunc regDrvsNDialects() bool {\n\tprovidedDrvsNDialects := map[string]struct {\n\t\tdbType     core.DbType\n\t\tgetDriver  func() core.Driver\n\t\tgetDialect func() core.Dialect\n\t}{\n\t\t\"mssql\":    {\"mssql\", func() core.Driver { return &odbcDriver{} }, func() core.Dialect { return &mssql{} }},\n\t\t\"odbc\":     {\"mssql\", func() core.Driver { return &odbcDriver{} }, func() core.Dialect { return &mssql{} }}, // !nashtsai! TODO change this when supporting MS Access\n\t\t\"mysql\":    {\"mysql\", func() core.Driver { return &mysqlDriver{} }, func() core.Dialect { return &mysql{} }},\n\t\t\"mymysql\":  {\"mysql\", func() core.Driver { return &mymysqlDriver{} }, func() core.Dialect { return &mysql{} }},\n\t\t\"postgres\": {\"postgres\", func() core.Driver { return &pqDriver{} }, func() core.Dialect { return &postgres{} }},\n\t\t\"pgx\":      {\"postgres\", func() core.Driver { return &pqDriverPgx{} }, func() core.Dialect { return &postgres{} }},\n\t\t\"sqlite3\":  {\"sqlite3\", func() core.Driver { return &sqlite3Driver{} }, func() core.Dialect { return &sqlite3{} }},\n\t\t\"oci8\":     {\"oracle\", func() core.Driver { return &oci8Driver{} }, func() core.Dialect { return &oracle{} }},\n\t\t\"goracle\":  {\"oracle\", func() core.Driver { return &goracleDriver{} }, func() core.Dialect { return &oracle{} }},\n\t}\n\n\tfor driverName, v := range providedDrvsNDialects {\n\t\tif driver := core.QueryDriver(driverName); driver == nil {\n\t\t\tcore.RegisterDriver(driverName, v.getDriver())\n\t\t\tcore.RegisterDialect(v.dbType, v.getDialect)\n\t\t}\n\t}\n\treturn true\n}\n\nfunc close(engine *Engine) {\n\tengine.Close()\n}\n\nfunc init() {\n\tregDrvsNDialects()\n}\n\n// NewEngine new a db manager according to the parameter. Currently support four\n// drivers\nfunc NewEngine(driverName string, dataSourceName string) (*Engine, error) {\n\tdriver := core.QueryDriver(driverName)\n\tif driver == nil {\n\t\treturn nil, fmt.Errorf(\"Unsupported driver name: %v\", driverName)\n\t}\n\n\turi, err := driver.Parse(driverName, dataSourceName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdialect := core.QueryDialect(uri.DbType)\n\tif dialect == nil {\n\t\treturn nil, fmt.Errorf(\"Unsupported dialect type: %v\", uri.DbType)\n\t}\n\n\tdb, err := core.Open(driverName, dataSourceName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = dialect.Init(db, uri, driverName, dataSourceName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tengine := &Engine{\n\t\tdb:             db,\n\t\tdialect:        dialect,\n\t\tTables:         make(map[reflect.Type]*core.Table),\n\t\tmutex:          &sync.RWMutex{},\n\t\tTagIdentifier:  \"xorm\",\n\t\tTZLocation:     time.Local,\n\t\ttagHandlers:    defaultTagHandlers,\n\t\tcachers:        make(map[string]core.Cacher),\n\t\tdefaultContext: context.Background(),\n\t}\n\n\tif uri.DbType == core.SQLITE {\n\t\tengine.DatabaseTZ = time.UTC\n\t} else {\n\t\tengine.DatabaseTZ = time.Local\n\t}\n\n\tlogger := NewSimpleLogger(os.Stdout)\n\tlogger.SetLevel(core.LOG_INFO)\n\tengine.SetLogger(logger)\n\tengine.SetMapper(core.NewCacheMapper(new(core.SnakeMapper)))\n\n\truntime.SetFinalizer(engine, close)\n\n\treturn engine, nil\n}\n\n// NewEngineWithParams new a db manager with params. The params will be passed to dialect.\nfunc NewEngineWithParams(driverName string, dataSourceName string, params map[string]string) (*Engine, error) {\n\tengine, err := NewEngine(driverName, dataSourceName)\n\tengine.dialect.SetParams(params)\n\treturn engine, err\n}\n\n// Clone clone an engine\nfunc (engine *Engine) Clone() (*Engine, error) {\n\treturn NewEngine(engine.DriverName(), engine.DataSourceName())\n}\n"
        },
        {
          "name": "xorm_test.go",
          "type": "blob",
          "size": 4.736328125,
          "content": "// Copyright 2018 The Xorm Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage xorm\n\nimport (\n\t\"database/sql\"\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\n\t_ \"github.com/denisenkom/go-mssqldb\"\n\t_ \"github.com/go-sql-driver/mysql\"\n\t_ \"github.com/lib/pq\"\n\t_ \"github.com/mattn/go-sqlite3\"\n\t_ \"github.com/ziutek/mymysql/godrv\"\n\t\"xorm.io/core\"\n)\n\nvar (\n\ttestEngine EngineInterface\n\tdbType     string\n\tconnString string\n\n\tdb                 = flag.String(\"db\", \"sqlite3\", \"the tested database\")\n\tshowSQL            = flag.Bool(\"show_sql\", true, \"show generated SQLs\")\n\tptrConnStr         = flag.String(\"conn_str\", \"./test.db?cache=shared&mode=rwc\", \"test database connection string\")\n\tmapType            = flag.String(\"map_type\", \"snake\", \"indicate the name mapping\")\n\tcache              = flag.Bool(\"cache\", false, \"if enable cache\")\n\tcluster            = flag.Bool(\"cluster\", false, \"if this is a cluster\")\n\tsplitter           = flag.String(\"splitter\", \";\", \"the splitter on connstr for cluster\")\n\tschema             = flag.String(\"schema\", \"\", \"specify the schema\")\n\tignoreSelectUpdate = flag.Bool(\"ignore_select_update\", false, \"ignore select update if implementation difference, only for tidb\")\n\n\ttableMapper core.IMapper\n\tcolMapper   core.IMapper\n)\n\nfunc createEngine(dbType, connStr string) error {\n\tif testEngine == nil {\n\t\tvar err error\n\n\t\tif !*cluster {\n\t\t\tswitch strings.ToLower(dbType) {\n\t\t\tcase core.MSSQL:\n\t\t\t\tdb, err := sql.Open(dbType, strings.Replace(connStr, \"xorm_test\", \"master\", -1))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif _, err = db.Exec(\"If(db_id(N'xorm_test') IS NULL) BEGIN CREATE DATABASE xorm_test; END;\"); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"db.Exec: %v\", err)\n\t\t\t\t}\n\t\t\t\tdb.Close()\n\t\t\t\t*ignoreSelectUpdate = true\n\t\t\tcase core.POSTGRES:\n\t\t\t\tdb, err := sql.Open(dbType, connStr)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\trows, err := db.Query(fmt.Sprintf(\"SELECT 1 FROM pg_database WHERE datname = 'xorm_test'\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"db.Query: %v\", err)\n\t\t\t\t}\n\t\t\t\tdefer rows.Close()\n\n\t\t\t\tif !rows.Next() {\n\t\t\t\t\tif _, err = db.Exec(\"CREATE DATABASE xorm_test\"); err != nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"CREATE DATABASE: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif *schema != \"\" {\n\t\t\t\t\tif _, err = db.Exec(\"CREATE SCHEMA IF NOT EXISTS \" + *schema); err != nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"CREATE SCHEMA: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdb.Close()\n\t\t\t\t*ignoreSelectUpdate = true\n\t\t\tcase core.MYSQL:\n\t\t\t\tdb, err := sql.Open(dbType, strings.Replace(connStr, \"xorm_test\", \"mysql\", -1))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif _, err = db.Exec(\"CREATE DATABASE IF NOT EXISTS xorm_test\"); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"db.Exec: %v\", err)\n\t\t\t\t}\n\t\t\t\tdb.Close()\n\t\t\tdefault:\n\t\t\t\t*ignoreSelectUpdate = true\n\t\t\t}\n\n\t\t\ttestEngine, err = NewEngine(dbType, connStr)\n\t\t} else {\n\t\t\ttestEngine, err = NewEngineGroup(dbType, strings.Split(connStr, *splitter))\n\t\t\tif dbType != \"mysql\" && dbType != \"mymysql\" {\n\t\t\t\t*ignoreSelectUpdate = true\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif *schema != \"\" {\n\t\t\ttestEngine.SetSchema(*schema)\n\t\t}\n\t\ttestEngine.ShowSQL(*showSQL)\n\t\ttestEngine.SetLogLevel(core.LOG_DEBUG)\n\t\tif *cache {\n\t\t\tcacher := NewLRUCacher(NewMemoryStore(), 100000)\n\t\t\ttestEngine.SetDefaultCacher(cacher)\n\t\t}\n\n\t\tif len(*mapType) > 0 {\n\t\t\tswitch *mapType {\n\t\t\tcase \"snake\":\n\t\t\t\ttestEngine.SetMapper(core.SnakeMapper{})\n\t\t\tcase \"same\":\n\t\t\t\ttestEngine.SetMapper(core.SameMapper{})\n\t\t\tcase \"gonic\":\n\t\t\t\ttestEngine.SetMapper(core.LintGonicMapper)\n\t\t\t}\n\t\t}\n\t}\n\n\ttableMapper = testEngine.GetTableMapper()\n\tcolMapper = testEngine.GetColumnMapper()\n\n\ttables, err := testEngine.DBMetas()\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar tableNames = make([]interface{}, 0, len(tables))\n\tfor _, table := range tables {\n\t\ttableNames = append(tableNames, table.Name)\n\t}\n\tif err = testEngine.DropTables(tableNames...); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc prepareEngine() error {\n\treturn createEngine(dbType, connString)\n}\n\nfunc TestMain(m *testing.M) {\n\tflag.Parse()\n\n\tdbType = *db\n\tif *db == \"sqlite3\" {\n\t\tif ptrConnStr == nil {\n\t\t\tconnString = \"./test.db?cache=shared&mode=rwc\"\n\t\t} else {\n\t\t\tconnString = *ptrConnStr\n\t\t}\n\t} else {\n\t\tif ptrConnStr == nil {\n\t\t\tlog.Fatal(\"you should indicate conn string\")\n\t\t\treturn\n\t\t}\n\t\tconnString = *ptrConnStr\n\t}\n\n\tdbs := strings.Split(*db, \"::\")\n\tconns := strings.Split(connString, \"::\")\n\n\tvar res int\n\tfor i := 0; i < len(dbs); i++ {\n\t\tdbType = dbs[i]\n\t\tconnString = conns[i]\n\t\ttestEngine = nil\n\t\tfmt.Println(\"testing\", dbType, connString)\n\n\t\tif err := prepareEngine(); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t\treturn\n\t\t}\n\n\t\tcode := m.Run()\n\t\tif code > 0 {\n\t\t\tres = code\n\t\t}\n\t}\n\n\tos.Exit(res)\n}\n\nfunc TestPing(t *testing.T) {\n\tif err := testEngine.Ping(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n"
        }
      ]
    }
  ]
}