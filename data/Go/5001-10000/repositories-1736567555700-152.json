{
  "metadata": {
    "timestamp": 1736567555700,
    "page": 152,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "containers/buildah",
      "stars": 7555,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".cirrus.yml",
          "type": "blob",
          "size": 10.5849609375,
          "content": "---\n\n# Main collection of env. vars to set for all tasks and scripts.\nenv:\n    ####\n    #### Global variables used for all tasks\n    ####\n    # Name of the ultimate destination branch for this CI run, PR or post-merge.\n    DEST_BRANCH: \"main\"\n    GOPATH: \"/var/tmp/go\"\n    GOSRC: \"${GOPATH}/src/github.com/containers/buildah\"\n    GOCACHE: \"/tmp/go-build\"\n    # Overrides default location (/tmp/cirrus) for repo clone\n    CIRRUS_WORKING_DIR: \"${GOSRC}\"\n    # Shell used to execute all script commands\n    CIRRUS_SHELL: \"/bin/bash\"\n    # Automation script path relative to $CIRRUS_WORKING_DIR)\n    SCRIPT_BASE: \"./contrib/cirrus\"\n    # No need to go crazy, but grab enough to cover most PRs\n    CIRRUS_CLONE_DEPTH: 50\n    # Unless set by in_podman.sh, default to operating outside of a podman container\n    IN_PODMAN: 'false'\n    # root or rootless\n    PRIV_NAME: root\n\n    ####\n    #### Cache-image names to test with\n    ####\n    # GCE project where images live\n    IMAGE_PROJECT: \"libpod-218412\"\n    FEDORA_NAME: \"fedora-41\"\n    PRIOR_FEDORA_NAME: \"fedora-40\"\n    DEBIAN_NAME: \"debian-13\"\n\n    # Image identifiers\n    IMAGE_SUFFIX: \"c20250107t132430z-f41f40d13\"\n    FEDORA_CACHE_IMAGE_NAME: \"fedora-${IMAGE_SUFFIX}\"\n    PRIOR_FEDORA_CACHE_IMAGE_NAME: \"prior-fedora-${IMAGE_SUFFIX}\"\n    DEBIAN_CACHE_IMAGE_NAME: \"debian-${IMAGE_SUFFIX}\"\n\n    IN_PODMAN_IMAGE: \"quay.io/libpod/fedora_podman:${IMAGE_SUFFIX}\"\n\n    ####\n    #### Command variables to help avoid duplication\n    ####\n    # Command to prefix every output line with a timestamp\n    # (can't do inline awk script, Cirrus-CI or YAML mangles quoting)\n    _TIMESTAMP: 'awk -f ${CIRRUS_WORKING_DIR}/${SCRIPT_BASE}/timestamp.awk'\n\ngcp_credentials: ENCRYPTED[ae0bf7370f0b6e446bc61d0865a2c55d3e166b3fab9466eb0393e38e1c66a31ca4c71ddc7e0139d47d075c36dd6d3fd7]\n\n# Default timeout for each task\ntimeout_in: 120m\n\n# Default VM to use unless set or modified by task\ngce_instance: &standardvm\n    image_project: \"${IMAGE_PROJECT}\"\n    zone: \"us-central1-c\"  # Required by Cirrus for the time being\n    cpu: 2\n    memory: \"4G\"\n    disk: 200  # Gigabytes, do not set less than 200 per obscure GCE docs re: I/O performance\n    image_name: \"${FEDORA_CACHE_IMAGE_NAME}\"\n\n\n# Update metadata on VM images referenced by this repository state\nmeta_task:\n    name: \"VM img. keepalive\"\n    alias: meta\n\n    container:\n        image: \"quay.io/libpod/imgts:latest\"\n        cpu: 1\n        memory: \"1G\"\n\n    env:\n        # Space-separated list of images used by this repository state\n        IMGNAMES: |-\n            ${FEDORA_CACHE_IMAGE_NAME}\n            ${PRIOR_FEDORA_CACHE_IMAGE_NAME}\n            ${DEBIAN_CACHE_IMAGE_NAME}\n            build-push-${IMAGE_SUFFIX}\n        BUILDID: \"${CIRRUS_BUILD_ID}\"\n        REPOREF: \"${CIRRUS_CHANGE_IN_REPO}\"\n        GCPJSON: ENCRYPTED[d3614d6f5cc0e66be89d4252b3365fd84f14eee0259d4eb47e25fc0bc2842c7937f5ee8c882b7e547b4c5ec4b6733b14]\n        GCPNAME: ENCRYPTED[8509e6a681b859479ce6aa275bd3c4ac82de5beec6df6057925afc4cd85b7ef2e879066ae8baaa2d453b82958e434578]\n        GCPPROJECT: ENCRYPTED[cc09b62d0ec6746a3df685e663ad25d9d5af95ef5fd843c96f3d0ec9d7f065dc63216b9c685c9f43a776a1d403991494]\n\n    clone_script: 'true'\n    script: '/usr/local/bin/entrypoint.sh'\n\n\nsmoke_task:\n    alias: 'smoke'\n    name: \"Smoke Test\"\n\n    gce_instance:\n        memory: \"12G\"\n        cpu: 4\n\n    # Don't bother running on branches (including cron), or for tags.\n    skip: $CIRRUS_PR == ''\n\n    timeout_in: 30m\n\n    setup_script: '${SCRIPT_BASE}/setup.sh |& ${_TIMESTAMP}'\n    build_script: '${SCRIPT_BASE}/build.sh |& ${_TIMESTAMP}'\n    validate_test_script: '${SCRIPT_BASE}/test.sh validate |& ${_TIMESTAMP}'\n\n    binary_artifacts:\n        path: ./bin/*\n\n# Check that all included go modules from other sources match\n# # what is expected in `vendor/modules.txt` vs `go.mod`.\nvendor_task:\n    name: \"Test Vendoring\"\n    alias: vendor\n\n    env:\n        CIRRUS_WORKING_DIR: \"/var/tmp/go/src/github.com/containers/buildah\"\n        GOPATH: \"/var/tmp/go\"\n        GOSRC: \"/var/tmp/go/src/github.com/containers/buildah\"\n\n    # Runs within Cirrus's \"community cluster\"\n    container:\n        image: docker.io/library/golang:1.22\n        cpu: 1\n        memory: 1\n\n    timeout_in: 5m\n\n    vendor_script:\n        - './hack/check_vendor_toolchain.sh Try updating the image used by the vendor_task in .cirrus.yml.'\n        - 'make vendor'\n        - './hack/tree_status.sh'\n\n\n# Confirm cross-compile ALL architectures on a Mac OS-X VM.\ncross_build_task:\n    name: \"Cross Compile\"\n    gce_instance:\n        cpu: 8\n        memory: \"24G\"\n    alias: cross_build\n    skip: >-\n        $CIRRUS_CHANGE_TITLE =~ '.*CI:DOCS.*'\n    env:\n        HOME: /root\n    script:\n        - go version\n        - make -j cross CGO_ENABLED=0\n    binary_artifacts:\n        path: ./bin/*\n\n\nunit_task:\n    name: 'Unit tests w/ $STORAGE_DRIVER'\n    alias: unit\n    skip: &not_build_docs >-\n        $CIRRUS_CHANGE_TITLE =~ '.*CI:DOCS.*' ||\n        $CIRRUS_CHANGE_TITLE =~ '.*CI:BUILD.*'\n    depends_on: &smoke_vendor\n      - smoke\n      - vendor\n\n    timeout_in: 90m\n\n    matrix:\n        - env:\n              STORAGE_DRIVER: 'vfs'\n        - env:\n              STORAGE_DRIVER: 'overlay'\n\n    setup_script: '${SCRIPT_BASE}/setup.sh |& ${_TIMESTAMP}'\n    unit_test_script: '${SCRIPT_BASE}/test.sh unit |& ${_TIMESTAMP}'\n\n\nconformance_task:\n    name: 'Debian Conformance w/ $STORAGE_DRIVER'\n    alias: conformance\n    skip: *not_build_docs\n    depends_on: *smoke_vendor\n\n    gce_instance:\n        image_name: \"${DEBIAN_CACHE_IMAGE_NAME}\"\n\n    timeout_in: 65m\n\n    matrix:\n        - env:\n            STORAGE_DRIVER: 'vfs'\n            TMPDIR: '/var/tmp'\n        - env:\n            STORAGE_DRIVER: 'overlay'\n\n    setup_script: '${SCRIPT_BASE}/setup.sh conformance |& ${_TIMESTAMP}'\n    conformance_test_script: '${SCRIPT_BASE}/test.sh conformance |& ${_TIMESTAMP}'\n\n\nintegration_task:\n    name: \"Integration $DISTRO_NV w/ $STORAGE_DRIVER\"\n    alias: integration\n    skip: *not_build_docs\n    depends_on: *smoke_vendor\n\n    matrix:\n        # VFS\n        - env:\n            DISTRO_NV: \"${FEDORA_NAME}\"\n            IMAGE_NAME: \"${FEDORA_CACHE_IMAGE_NAME}\"\n            STORAGE_DRIVER: 'vfs'\n        # Disabled until we update to f40/41 as f39 does not have go 1.22\n        # - env:\n        #     DISTRO_NV: \"${PRIOR_FEDORA_NAME}\"\n        #     IMAGE_NAME: \"${PRIOR_FEDORA_CACHE_IMAGE_NAME}\"\n        #     STORAGE_DRIVER: 'vfs'\n        - env:\n            DISTRO_NV: \"${DEBIAN_NAME}\"\n            IMAGE_NAME: \"${DEBIAN_CACHE_IMAGE_NAME}\"\n            STORAGE_DRIVER: 'vfs'\n        # OVERLAY\n        - env:\n            DISTRO_NV: \"${FEDORA_NAME}\"\n            IMAGE_NAME: \"${FEDORA_CACHE_IMAGE_NAME}\"\n            STORAGE_DRIVER: 'overlay'\n        # Disabled until we update to f40/41 as f39 does not have go 1.22\n        # - env:\n        #     DISTRO_NV: \"${PRIOR_FEDORA_NAME}\"\n        #     IMAGE_NAME: \"${PRIOR_FEDORA_CACHE_IMAGE_NAME}\"\n        #     STORAGE_DRIVER: 'overlay'\n        - env:\n            DISTRO_NV: \"${DEBIAN_NAME}\"\n            IMAGE_NAME: \"${DEBIAN_CACHE_IMAGE_NAME}\"\n            STORAGE_DRIVER: 'overlay'\n\n    gce_instance:\n        image_name: \"$IMAGE_NAME\"\n\n    # Separate scripts for separate outputs, makes debugging easier.\n    setup_script: '${SCRIPT_BASE}/setup.sh |& ${_TIMESTAMP}'\n    build_script: '${SCRIPT_BASE}/build.sh |& ${_TIMESTAMP}'\n    integration_test_script: '${SCRIPT_BASE}/test.sh integration |& ${_TIMESTAMP}'\n\n    binary_artifacts:\n        path: ./bin/*\n\n    always: &standardlogs\n        audit_log_script: '$GOSRC/$SCRIPT_BASE/logcollector.sh audit'\n        df_script: '$GOSRC/$SCRIPT_BASE/logcollector.sh df'\n        journal_script: '$GOSRC/$SCRIPT_BASE/logcollector.sh journal'\n        podman_system_info_script: '$GOSRC/$SCRIPT_BASE/logcollector.sh podman'\n        buildah_version_script: '$GOSRC/$SCRIPT_BASE/logcollector.sh buildah_version'\n        buildah_info_script: '$GOSRC/$SCRIPT_BASE/logcollector.sh buildah_info'\n        package_versions_script: '$GOSRC/$SCRIPT_BASE/logcollector.sh packages'\n        golang_version_script: '$GOSRC/$SCRIPT_BASE/logcollector.sh golang'\n\nintegration_rootless_task:\n    name: \"Integration rootless $DISTRO_NV w/ $STORAGE_DRIVER\"\n    alias: integration_rootless\n    skip: *not_build_docs\n    depends_on: *smoke_vendor\n\n    matrix:\n        # Running rootless tests on overlay\n        # OVERLAY\n        - env:\n            DISTRO_NV: \"${FEDORA_NAME}\"\n            IMAGE_NAME: \"${FEDORA_CACHE_IMAGE_NAME}\"\n            STORAGE_DRIVER: 'overlay'\n            PRIV_NAME: rootless\n        # Disabled until we update to f40/41 as f39 does not have go 1.22\n        # - env:\n        #     DISTRO_NV: \"${PRIOR_FEDORA_NAME}\"\n        #     IMAGE_NAME: \"${PRIOR_FEDORA_CACHE_IMAGE_NAME}\"\n        #     STORAGE_DRIVER: 'overlay'\n        #     PRIV_NAME: rootless\n        - env:\n            DISTRO_NV: \"${DEBIAN_NAME}\"\n            IMAGE_NAME: \"${DEBIAN_CACHE_IMAGE_NAME}\"\n            STORAGE_DRIVER: 'overlay'\n            PRIV_NAME: rootless\n\n    gce_instance:\n        image_name: \"$IMAGE_NAME\"\n\n    # Separate scripts for separate outputs, makes debugging easier.\n    setup_script: '${SCRIPT_BASE}/setup.sh |& ${_TIMESTAMP}'\n    build_script: '${SCRIPT_BASE}/build.sh |& ${_TIMESTAMP}'\n    integration_test_script: '${SCRIPT_BASE}/test.sh integration |& ${_TIMESTAMP}'\n\n    binary_artifacts:\n        path: ./bin/*\n\n    always:\n        <<: *standardlogs\n\nin_podman_task:\n    name: \"Containerized Integration\"\n    alias: in_podman\n    skip: *not_build_docs\n    depends_on: *smoke_vendor\n\n    env:\n        # This is key, cause the scripts to re-execute themselves inside a container.\n        IN_PODMAN: 'true'\n        BUILDAH_ISOLATION: 'chroot'\n        STORAGE_DRIVER: 'vfs'\n\n    # Separate scripts for separate outputs, makes debugging easier.\n    setup_script: '${SCRIPT_BASE}/setup.sh |& ${_TIMESTAMP}'\n    build_script: '${SCRIPT_BASE}/build.sh |& ${_TIMESTAMP}'\n    integration_test_script: '${SCRIPT_BASE}/test.sh integration |& ${_TIMESTAMP}'\n\n    binary_artifacts:\n        path: ./bin/*\n\n    always:\n        <<: *standardlogs\n\n\n# Status aggregator for all tests.  This task simply ensures a defined\n# set of tasks all passed, and allows confirming that based on the status\n# of this task.\nsuccess_task:\n    # N/B: The prow merge-bot (tide) is sensitized to this exact name, DO NOT CHANGE IT.\n    # Ref: https://github.com/openshift/release/pull/48909\n    name: \"Total Success\"\n    alias: success\n\n    depends_on:\n      - meta\n      - smoke\n      - unit\n      - conformance\n      - vendor\n      - cross_build\n      - integration\n      - in_podman\n\n    container:\n        image: \"quay.io/libpod/alpine:latest\"\n        cpu: 1\n        memory: 1\n\n    env:\n        CIRRUS_SHELL: direct  # execute command directly\n\n    clone_script: mkdir -p $CIRRUS_WORKING_DIR\n    script: /bin/true\n"
        },
        {
          "name": ".codespellrc",
          "type": "blob",
          "size": 0.201171875,
          "content": "[codespell]\nskip = ./vendor,./.git,./go.sum,./docs/*.1,./docker/AUTHORS,./CHANGELOG.md,./changelog.txt,./tests/tools/vendor,./tests/tools/go.mod,./tests/tools/go.sum\nignore-words-list = fo,passt,secon,erro\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2333984375,
          "content": "docs/buildah*.1\ndocs/*.5\n/bin\n/buildah\n/imgtype\n/build/\n/tests/tools/build\nDockerfile*\n!/tests/bud/*/Dockerfile*\n!/tests/conformance/**/Dockerfile*\n*.swp\n/result/\ninternal/mkcw/embed/entrypoint_amd64.o\ninternal/mkcw/embed/entrypoint_amd64\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.2490234375,
          "content": "---\nrun:\n  build-tags:\n    - apparmor\n    - seccomp\n    - selinux\n  # Don't exceed number of threads available when running under CI\n  concurrency: 4\nlinters:\n  enable:\n    - gofmt\n    - gofumpt\n    - revive\n    - unconvert\n    - unparam\n    - whitespace\n"
        },
        {
          "name": ".packit.yaml",
          "type": "blob",
          "size": 2.46484375,
          "content": "---\n# See the documentation for more information:\n# https://packit.dev/docs/configuration/\n\ndownstream_package_name: buildah\nupstream_tag_template: v{version}\n\npackages:\n  buildah-fedora:\n    pkg_tool: fedpkg\n    specfile_path: rpm/buildah.spec\n  buildah-centos:\n    pkg_tool: centpkg\n    specfile_path: rpm/buildah.spec\n  buildah-eln:\n    specfile_path: rpm/buildah.spec\n\nsrpm_build_deps:\n  - make\n\njobs:\n  - job: copr_build\n    trigger: pull_request\n    packages: [buildah-fedora]\n    notifications: &copr_build_failure_notification\n      failure_comment:\n        message: \"Ephemeral COPR build failed. @containers/packit-build please check.\"\n    targets:\n      - fedora-all-x86_64\n      - fedora-all-aarch64\n    enable_net: true\n\n  - job: copr_build\n    trigger: pull_request\n    packages: [buildah-eln]\n    notifications: *copr_build_failure_notification\n    targets:\n      fedora-eln-x86_64:\n        additional_repos:\n          - \"https://kojipkgs.fedoraproject.org/repos/eln-build/latest/x86_64/\"\n      fedora-eln-aarch64:\n        additional_repos:\n          - \"https://kojipkgs.fedoraproject.org/repos/eln-build/latest/aarch64/\"\n    enable_net: true\n\n  - job: copr_build\n    trigger: pull_request\n    packages: [buildah-centos]\n    notifications: *copr_build_failure_notification\n    targets:\n      - centos-stream-9-x86_64\n      - centos-stream-9-aarch64\n      - centos-stream-10-x86_64\n      - centos-stream-10-aarch64\n    enable_net: true\n\n  # Run on commit to main branch\n  - job: copr_build\n    trigger: commit\n    packages: [buildah-fedora]\n    notifications:\n      failure_comment:\n        message: \"podman-next COPR build failed. @containers/packit-build please check.\"\n    branch: main\n    owner: rhcontainerbot\n    project: podman-next\n    enable_net: true\n\n  # Sync to Fedora\n  - job: propose_downstream\n    trigger: release\n    packages: [buildah-fedora]\n    update_release: false\n    dist_git_branches: &fedora_targets\n      - fedora-all\n\n  # Sync to CentOS Stream\n  - job: propose_downstream\n    trigger: release\n    packages: [buildah-centos]\n    update_release: false\n    dist_git_branches:\n      - c10s\n\n  # Fedora Koji build\n  - job: koji_build\n    trigger: commit\n    packages: [buildah-fedora]\n    sidetag_group: podman-releases\n    # Dependents are not rpm dependencies, but the package whose bodhi update\n    # should include this package.\n    # Ref: https://packit.dev/docs/fedora-releases-guide/releasing-multiple-packages\n    dependents:\n      - podman\n    dist_git_branches: *fedora_targets\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 161.6123046875,
          "content": "![buildah logo](https://cdn.rawgit.com/containers/buildah/main/logos/buildah-logo_large.png)\n\n# Changelog\n\n## v1.38.0 (2024-11-08)\n\n    Bump to c/common v0.61.0, c/image v5.33.0, c/storage v1.56.0\n    fix(deps): update module golang.org/x/crypto to v0.29.0\n    fix(deps): update module github.com/moby/buildkit to v0.17.1\n    fix(deps): update module github.com/containers/storage to v1.56.0\n    tests: skip two ulimit tests\n    CI VMs: bump f40 -> f41\n    tests/tools: rebuild tools when we change versions\n    tests/tools: update golangci-lint to v1.61.0\n    fix(deps): update module github.com/moby/buildkit to v0.17.0\n    Handle RUN --mount with relative targets and no configured workdir\n    tests: bud: make parallel-safe\n    fix(deps): update module github.com/opencontainers/runc to v1.2.1\n    fix(deps): update golang.org/x/exp digest to f66d83c\n    fix(deps): update github.com/opencontainers/runtime-tools digest to 6c9570a\n    tests: blobcache: use unique image name\n    tests: sbom: never write to cwd\n    tests: mkcw: bug fixes, refactor\n    deps: bump runc to v1.2.0\n    deps: switch to moby/sys/userns\n    tests/test_runner.sh: remove some redundancies\n    Integration tests: run git daemon on a random-but-bind()able port\n    fix(deps): update module github.com/opencontainers/selinux to v1.11.1\n    go.mod: remove unnecessary replace\n    Document more buildah build --secret options\n    Add support for COPY --exclude and ADD --exclude options\n    fix(deps): update github.com/containers/luksy digest to e2530d6\n    chore(deps): update dependency containers/automation_images to v20241010\n    fix(deps): update module github.com/cyphar/filepath-securejoin to v0.3.4\n    Properly validate cache IDs and sources\n    [skip-ci] Packit: constrain koji job to fedora package to avoid dupes\n    Audit and tidy OWNERS\n    fix(deps): update module golang.org/x/crypto to v0.28.0\n    tests: add quotes to names\n    vendor: update c/common to latest\n    CVE-2024-9407: validate \"bind-propagation\" flag settings\n    vendor: switch to moby/sys/capability\n    Don't set ambient capabilities\n    Document that zstd:chunked is downgraded to zstd when encrypting\n    fix(deps): update module github.com/cyphar/filepath-securejoin to v0.3.3\n    buildah-manifest-create.1: Fix manpage section\n    chore(deps): update dependency ubuntu to v24\n    Make `buildah manifest push --all` true by default\n    chroot: add newlines at the end of printed error messages\n    Do not error on trying to write IMA xattr as rootless\n    fix: remove duplicate conditions\n    fix(deps): update module github.com/moby/buildkit to v0.16.0\n    fix(deps): update module github.com/cyphar/filepath-securejoin to v0.3.2\n    Document how entrypoint is configured in buildah config\n    In a container, try to register binfmt_misc\n    imagebuildah.StageExecutor: clean up volumes/volumeCache\n    build: fall back to parsing a TARGETPLATFORM build-arg\n    `manifest add --artifact`: handle multiple values\n    Packit: split out ELN jobs and reuse fedora downstream targets\n    Packit: Enable sidetags for bodhi updates\n    fix(deps): update module github.com/docker/docker to v27.2.1+incompatible\n    tests/bud.bats: add git source\n    add: add support for git source\n    Add support for the new c/common pasta options\n    vendor latest c/common\n    fix(deps): update module golang.org/x/term to v0.24.0\n    fix(deps): update module github.com/fsouza/go-dockerclient to v1.12.0\n    packit: update fedora and epel targets\n    cirrus: disable f39 testing\n    cirrus: fix fedora names\n    update to go 1.22\n    Vendor c/common:9d025e4cb348\n    copier: handle globbing with \"**\" path components\n    fix(deps): update golang.org/x/exp digest to 9b4947d\n    fix(deps): update github.com/containers/luksy digest to 2e7307c\n    imagebuildah: make scratch config handling toggleable\n    fix(deps): update module github.com/docker/docker to v27.2.0+incompatible\n    Add a validation script for Makefile $(SOURCES)\n    fix(deps): update module github.com/openshift/imagebuilder to v1.2.15\n    New VMs\n    Update some godocs, use 0o to prefix an octal in a comment\n    buildah-build.1.md: expand the --layer-label description\n    fix(deps): update module github.com/containers/common to v0.60.2\n    run: fix a nil pointer dereference on FreeBSD\n    CI: enable the whitespace linter\n    Fix some govet linter warnings\n    Commit(): retry committing to local storage on storage.LayerUnknown\n    CI: enable the gofumpt linter\n    conformance: move weirdly-named files out of the repository\n    fix(deps): update module github.com/docker/docker to v27.1.2+incompatible\n    fix(deps): update module github.com/containers/common to v0.60.1\n    *: use gofmt -s, add gofmt linter\n    *: fix build tags\n    fix(deps): update module github.com/containers/image/v5 to v5.32.1\n    Add(): re-escape any globbed items that included escapes\n    conformance tests: use mirror.gcr.io for most images\n    unit tests: use test-specific policy.json and registries.conf\n    fix(deps): update module golang.org/x/sys to v0.24.0\n    Update to spun-out \"github.com/containerd/platforms\"\n    Bump github.com/containerd/containerd\n    test/tools/Makefile: duplicate the vendor-in-container target\n    linters: unchecked error\n    linters: don't end loop iterations with \"else\" when \"then\" would\n    linters: unused arguments shouldn't have names\n    linters: rename checkIdsGreaterThan5() to checkIDsGreaterThan5()\n    linters: don't name variables \"cap\"\n    `make lint`: use --timeout instead of --deadline\n    Drop the e2e test suite\n    fix(deps): update module golang.org/x/crypto to v0.26.0\n    fix(deps): update module github.com/onsi/gomega to v1.34.1\n    `make vendor-in-container`: use the caller's Go cache if it exists\n    fix(deps): fix test/tools ginkgo typo\n    fix(deps): update module github.com/onsi/ginkgo/v2 to v2.19.1\n    Update to keep up with API changes in storage\n    fix(deps): update github.com/containers/luksy digest to 1f482a9\n    install: On Debian/Ubuntu, add installation of libbtrfs-dev\n    fix(deps): update module golang.org/x/sys to v0.23.0\n    fix(deps): update golang.org/x/exp digest to 8a7402a\n    fix(deps): update module github.com/fsouza/go-dockerclient to v1.11.2\n    Use Epoch: 2 and respect the epoch in dependencies.\n    Bump to Buildah v1.38.0-dev\n    AddAndCopyOptions: add CertPath, InsecureSkipTLSVerify, Retry fields\n    Add PrependedLinkedLayers/AppendedLinkedLayers to CommitOptions\n    integration tests: teach starthttpd() about TLS and pid files\n\n## vv1.37.0 (2024-07-26)\n\n    Bump c/storage, c/image, c/common for v1.37.0\n    \"build with basename resolving user arg\" tests: correct ARG use\n    bud-multiple-platform-no-run test: correct ARG use\n    imagebuildah: always have default values for $TARGET... args ready\n    bump github.com/openshift/imagebuilder to v1.2.14\n    fix(deps): update module github.com/docker/docker to v27.1.1+incompatible\n    fix(deps): update module github.com/cyphar/filepath-securejoin to v0.3.1\n    fix(deps): update module github.com/docker/docker to v27.1.0+incompatible\n    CI: use local registry, part 2 of 2\n    CI: use local registry, part 1 of 2\n    fix(deps): update module github.com/fsouza/go-dockerclient to v1.11.1\n    Revert \"fix(deps): update github.com/containers/image/v5 to v5.31.1\"\n    Replace libimage.LookupReferenceFunc with the manifests version\n    conformance tests: enable testing CompatVolumes\n    conformance tests: add a test that tries to chown a volume\n    imagebuildah: make traditional volume handling not the default\n    StageExecutor.prepare(): mark base image volumes for preservation\n    fix(deps): update module github.com/containers/image/v5 to v5.31.1\n    Vendor in latest containers/(common, storage, image)\n    fix(deps): update module golang.org/x/term to v0.22.0\n    fix(deps): update module golang.org/x/sys to v0.22.0\n    fix(deps): update golang.org/x/exp digest to 7f521ea\n    fix(deps): update github.com/containers/luksy digest to a8846e2\n    imagebuildah.StageExecutor.Copy(): reject new flags for now\n    bump github.com/openshift/imagebuilder to v1.2.11\n    Rework parsing of --pull flags\n    fix(deps): update module github.com/containers/image/v5 to v5.31.1\n    imagebuildah.StageExecutor.prepare(): log the --platform flag\n    CI VMs: bump\n    buildah copy: preserve owner info with --from= a container or image\n    conformance tests: enable testing CompatSetParent\n    containerImageRef.NewImageSource(): move the FROM comment to first\n    commit: set \"parent\" for docker format only when requested\n    Update godoc for Builder.EnsureContainerPathAs\n    fix(deps): update module github.com/spf13/cobra to v1.8.1\n    fix(deps): update module github.com/containernetworking/cni to v1.2.0\n    fix(deps): update module github.com/opencontainers/runc to v1.1.13\n    Change default for podman build to --pull missing\n    fix(deps): update module github.com/containers/common to v0.59.1\n    Clarify definition of --pull options\n    buildah: fix a nil pointer reference on FreeBSD\n    Use /var/tmp for $TMPDIR for vfs conformance jobs\n    Cirrus: run `df` during job setup\n    conformance: use quay.io/libpod/centos:7 instead of centos:8\n    Stop setting \"parent\" in docker format\n    conformance: check if workdir trims path separator suffixes\n    push integration test: pass password to docker login via stdin\n    Re-enable the \"copy with chown\" conformance test\n    healthcheck: Add support for `--start-interval`\n    fix(deps): update module github.com/docker/docker to v26.1.4+incompatible\n    fix(deps): update module github.com/containerd/containerd to v1.7.18\n    tests: set _CONTAINERS_USERNS_CONFIGURED=done for libnetwork\n    Cross-build on Fedora\n    Drop copyStringSlice() and copyStringStringMap()\n    fix(deps): update module golang.org/x/crypto to v0.24.0\n    fix(deps): update module github.com/openshift/imagebuilder to v1.2.10\n    Provide an uptime_netbsd.go\n    Spell unix as \"!windows\"\n    Add netbsd to lists-of-OSes\n    fix(deps): update golang.org/x/exp digest to fd00a4e\n    [skip-ci] Packit: enable c10s downstream sync\n    CI VMs: bump, to debian with cgroups v2\n    Document when BlobDirectory is overridden\n    fix secret mounts for env vars when using chroot isolation\n    Change to take a types.ImageReference arg\n    imagebuildah: Support custom image reference lookup for cache push/pull\n    fix(deps): update module github.com/onsi/ginkgo/v2 to v2.19.0\n    Bump to v1.37.0-dev\n    CI: Clarify Debian use for conformance tests\n\n## v1.36.0 (2024-05-23)\n\n    build: be more selective about specifying the default OS\n    Bump to c/common v0.59.0\n    Fix buildah prune --help showing the same example twice\n    fix(deps): update module github.com/onsi/ginkgo/v2 to v2.18.0\n    fix(deps): update module github.com/containers/image/v5 to v5.31.0\n    bud tests: fix breakage when vendoring into podman\n    Integration tests: fake up a replacement for nixery.dev/shell\n    copierWithSubprocess(): try to capture stderr on io.ErrClosedPipe\n    Don't expand RUN heredocs ourselves, let the shell do it\n    Don't leak temp files on failures\n    Add release note template to split dependency chores\n    fix CentOS/RHEL build - no BATS there\n    fix(deps): update module github.com/containers/luksy to v0.0.0-20240506205542-84b50f50f3ee\n    Address CVE-2024-3727\n    chore(deps): update module github.com/opencontainers/runtime-spec to v1.2.0\n    Builder.cdiSetupDevicesInSpecdefConfig(): use configured CDI dirs\n    Setting --arch should set the TARGETARCH build arg\n    fix(deps): update module golang.org/x/exp to v0.0.0-20240416160154-fe59bbe5cc7f\n    [CI:DOCS] Add link to Buildah image page to README.md\n    Don't set GOTOOLCHAIN=local\n    fix(deps): update module github.com/cyphar/filepath-securejoin to v0.2.5\n    Makefile: set GOTOOLCHAIN=local\n    Integration tests: switch some base images\n    containerImageRef.NewImageSource: merge the tar filters\n    fix(deps): update module github.com/onsi/ginkgo/v2 to v2.17.2\n    fix(deps): update module github.com/containers/luksy to v0.0.0-20240408185936-afd8e7619947\n    Disable packit builds for centos-stream+epel-next-8\n    Makefile: add missing files to $(SOURCES)\n    CI VMs: bump to new versions with tmpfs /tmp\n    chore(deps): update module golang.org/x/net to v0.23.0 [security]\n    integration test: handle new labels in \"bud and test --unsetlabel\"\n    Switch packit configuration to use epel-9-$arch ...\n    Give unit tests a bit more time\n    Integration tests: remove a couple of duplicated tests\n    Integration tests: whitespace tweaks\n    Integration tests: don't remove images at start or end of test\n    Integration tests: use cached images more\n    Integration tests _prefetch: use registry configs\n    internal: use fileutils.(Le|E)xists\n    pkg/parse: use fileutils.(Le|E)xists\n    buildah: use fileutils.(Le|E)xists\n    chroot: use fileutils.(Le|E)xists\n    vendor: update containers/(common|storage)\n    Fix issue/pr lock workflow\n    [CI:DOCS] Add golang 1.21 update warning\n    heredoc: honor inline COPY irrespective of ignorefiles\n    Update install.md\n    source-push: add support for --digestfile\n    Fix caching when mounting a cached stage with COPY/ADD\n    fix(deps): update github.com/containers/luksy digest to 3d2cf0e\n    Makefile: softcode `strip`, use it from env var\n    Man page updates\n    Add support for passing CDI specs to --device\n    Update comments on some API objects\n    pkg/parse.DeviceFromPath(): dereference src symlinks\n    fix(deps): update module github.com/onsi/ginkgo/v2 to v2.17.1\n\n## v1.35.0 (2024-03-06)\n\n    fix(deps): update module github.com/stretchr/testify to v1.9.0\n    cgroups: reuse version check from c/common\n    Update vendor of containers/(common,image)\n    fix(deps): update github.com/containers/storage digest to eadc620\n    fix(deps): update github.com/containers/luksy digest to ceb12d4\n    fix(deps): update github.com/containers/image/v5 digest to cdc6802\n    manifest add: complain if we get artifact flags without --artifact\n    Use retry logic from containers/common\n    Vendor in containers/(storage,image,common)\n    Update module golang.org/x/crypto to v0.20.0\n    Add comment re: Total Success task name\n    tests: skip_if_no_unshare(): check for --setuid\n    Properly handle build --pull=false\n    [skip-ci] Update tim-actions/get-pr-commits action to v1.3.1\n    Update module go.etcd.io/bbolt to v1.3.9\n    Revert \"Reduce official image size\"\n    Update module github.com/opencontainers/image-spec to v1.1.0\n    Reduce official image size\n    Build with CNI support on FreeBSD\n    build --all-platforms: skip some base \"image\" platforms\n    Bump main to v1.35.0-dev\n    Vendor in latest containers/(storage,image,common)\n    Split up error messages for missing --sbom related flags\n    `buildah manifest`: add artifact-related options\n    cmd/buildah/manifest.go: lock lists before adding/annotating/pushing\n    cmd/buildah/manifest.go: don't make struct declarations aliases\n    Use golang.org/x/exp/slices.Contains\n    Disable loong64 again\n    Fix a couple of typos in one-line comments\n    egrep is obsolescent; use grep -E\n    Try Cirrus with a newer VM version\n    Set CONTAINERS_CONF in the chroot-mount-flags integration test\n    Update to match dependency API update\n    Update github.com/openshift/imagebuilder and containers/common\n    docs: correct default authfile path\n    fix(deps): update module github.com/containerd/containerd to v1.7.13\n    tests: retrofit test for heredoc summary\n    build, heredoc: show heredoc summary in build output\n    manifest, push: add support for --retry and --retry-delay\n    fix(deps): update github.com/openshift/imagebuilder digest to b767bc3\n    imagebuildah: fix crash with empty RUN\n    fix(deps): update github.com/containers/luksy digest to b62d551\n    fix(deps): update module github.com/opencontainers/runc to v1.1.12 [security]\n    fix(deps): update module github.com/moby/buildkit to v0.12.5 [security]\n    Make buildah match podman for handling of ulimits\n    docs: move footnotes to where they're applicable\n    Allow users to specify no-dereference\n    Run codespell on code\n    Fix FreeBSD version parsing\n    Fix a build break on FreeBSD\n    Remove a bad FROM line\n    fix(deps): update module github.com/onsi/gomega to v1.31.1\n    fix(deps): update module github.com/opencontainers/image-spec to v1.1.0-rc6\n    docs: use reversed logo for dark theme in README\n    build,commit: add --sbom to scan and produce SBOMs when committing\n    commit: force omitHistory if the parent has layers but no history\n    docs: fix a couple of typos\n    internal/mkcw.Archive(): handle extra image content\n    stage_executor,heredoc: honor interpreter in heredoc\n    stage_executor,layers: burst cache if heredoc content is changed\n    fix(deps): update module golang.org/x/crypto to v0.18.0\n    Replace map[K]bool with map[K]struct{} where it makes sense\n    fix(deps): update module golang.org/x/sync to v0.6.0\n    fix(deps): update module golang.org/x/term to v0.16.0\n    Bump CI VMs\n    Replace strings.SplitN with strings.Cut\n    fix(deps): update github.com/containers/storage digest to ef81e9b\n    fix(deps): update github.com/containers/image/v5 digest to 1b221d4\n    fix(deps): update module github.com/fsouza/go-dockerclient to v1.10.1\n    Document use of containers-transports values in buildah\n    fix(deps): update module golang.org/x/crypto to v0.17.0 [security]\n    chore(deps): update dependency containers/automation_images to v20231208\n    manifest: addCompression use default from containers.conf\n    commit: add a --add-file flag\n    mkcw: populate the rootfs using an overlay\n    chore(deps): update dependency containers/automation_images to v20230517\n    [skip-ci] Update actions/stale action to v9\n    fix(deps): update module github.com/containernetworking/plugins to v1.4.0\n    fix(deps): update github.com/containers/image/v5 digest to 7a40fee\n    Bump to v1.34.1-dev\n    Ignore errors if label.Relabel returns ENOSUP\n\n## v1.34.0 (2023-12-11)\n\n    vendor: update c/{common,image,storage}\n    run: Allow using just one jail per container on FreeBSD\n    Remove makefile targets entrypoint{,.gz} for non x86_64\n\n## v1.33.2 (2023-11-22)\n\n    Update minimum to golang 1.20\n    fix(deps): update module github.com/fsouza/go-dockerclient to v1.10.0\n    fix(deps): update module github.com/moby/buildkit to v0.12.3\n    Bump to v1.33.2-dev\n\n## v1.33.1 (2023-11-18)\n\n    fix(deps): update module github.com/moby/buildkit to v0.11.4 [security]\n    test,heredoc: use fedora instead of docker.io/library/python:latest\n    Bump to v1.33.1-dev\n\n## v1.33.0 (2023-11-17)\n\n    Never omit layers for emptyLayer instructions when squashing/cwing\n    Add OverrideChanges and OverrideConfig to CommitOptions\n    buildah: add heredoc support for RUN, COPY and ADD\n    vendor: bump imagebuilder to v1.2.6-0.20231110114814-35a50d57f722\n    conformance tests: archive the context directory as 0:0 (#5171)\n    blobcacheinfo,test: blobs must be resued when pushing across registry\n    Bump c/storage v1.51.0, c/image v5.29.0, c/common v0.57.0\n    pkg/util.MirrorToTempFileIfPathIsDescriptor(): don't leak an fd\n    StageExecutor.Execute: force a commit for --unsetenv, too\n    Increase a copier+chroot test timeout\n    Add support for --compat-auth-file in login/logout\n    Update existing tests for error message change\n    Update c/image and c/common to latest\n    fix(deps): update module github.com/containerd/containerd to v1.7.9\n    build: downgrade to go 1.20\n    Add godoc for pkg/parse.GetTempDir\n    conformance tests: use go-dockerclient for BuildKit builds\n    Make TEE types case-insensitive\n    fix(deps): update module golang.org/x/crypto to v0.15.0\n    Tweak some help descriptions\n    Stop using DefaultNetworkSysctl and use containers.conf only\n    Implement ADD checksum flag #5135\n    vendor of openshift/imagebuilder #5135\n    Pass secrets from the host down to internal podman containers\n    Update cirrus and version of golang\n    image: replace GetStoreImage with ResolveReference\n    vendor: bump c/image to 373c52a9466f\n    pkg/parse.Platform(): minor simplification\n    createConfigsAndManifests: clear history before cw-specific logic\n    Use a constant definition instead of \"scratch\"\n    conformance: use require.NoErrorf() more\n    fix(deps): update module golang.org/x/term to v0.14.0\n    fix(deps): update module golang.org/x/sync to v0.5.0\n    fix(deps): update module github.com/spf13/cobra to v1.8.0\n    fix(deps): update module golang.org/x/sys to v0.14.0\n    fix(deps): update github.com/containers/common digest to 8354404\n    fix(deps): update module github.com/opencontainers/runc to v1.1.10\n    fix(deps): update github.com/containers/luksy digest to b5a7f79\n    Log the platform for build errors during multi-platform builds\n    Use mask definitions from containers/common\n    Vendor in latest containers/common\n    fix(deps): update module github.com/containerd/containerd to v1.7.8\n    fix(deps): update module go.etcd.io/bbolt to v1.3.8\n    container.conf: support attributed string slices\n    fix(deps): update module sigs.k8s.io/yaml to v1.4.0\n    Use cutil.StringInSlice rather then contains\n    Add --no-hostname option to buildah containers\n    vendor c/common: appendable containers.conf strings, Part 1\n    fix(deps): update module github.com/onsi/gomega to v1.28.1\n    chroot.setupChrootBindMounts: pay more attention to flags\n    chore(deps): update dependency containers/automation_images to v20231004\n    Vendor containers/common\n    chore(deps): update module golang.org/x/net to v0.17.0 [security]\n    run: use internal.GetTempDir with os.MkdirTemp\n    fix(deps): update module github.com/containerd/containerd to v1.7.7\n    imagebuildah,multi-stage: do not remove base images\n    gitignore: add mkcw binary\n    mkcw: remove entrypoint binaries\n    fix(deps): update module golang.org/x/crypto to v0.14.0\n    fix(deps): update module golang.org/x/sys to v0.13.0\n    fix(deps): update module golang.org/x/sync to v0.4.0\n    Update some comments related to confidential workload\n    Use the parent's image ID in the config that we pass to imagebuilder\n    fix(deps): update github.com/containers/common digest to 8892536\n    fix(deps): update github.com/containers/luksy digest to 6df88cb\n    bug: Ensure the mount type is always BindMount by default\n    Protocol can be specified with --port. Ex. --port 514/udp\n    fix(deps): update module github.com/onsi/gomega to v1.28.0\n    build,config: add support for --unsetlabel\n    tests/bud: add tests\n    [CI:BUILD] Packit: tag @containers/packit-build on copr build failures\n    stage_executor: allow images without layers\n    vendor of containers/common\n    Removing selinux_tag.sh as no longer needed after 580356f [NO NEW TESTS NEEDED]\n    add/copy: make sure we handle relative path names correctly\n    fix(deps): update module github.com/opencontainers/image-spec to v1.1.0-rc5\n    Bump to v1.33.0-dev\n    imagebuildah: consider ignorefile with --build-context\n\n## v1.32.0 (2023-09-14)\n\n    GetTmpDir is not using ImageCopyTmpdir correctly\n    Run codespell on code\n    Bump vendor containers/(common, storage, image)\n    Cirrus: Remove multi-arch buildah image builds\n    fix(deps): update module github.com/containerd/containerd to v1.7.6\n    Split GetTempDir from internal/util\n    Move most of internal/parse to internal/volumes\n    copier: remove libimage dependency via util package\n    Add some docs for `build --cw`, `commit --cw`, and `mkcw`\n    Add `buildah mkcw`, add `--cw` to `buildah commit` and `buildah build`\n    Make sure that pathnames picked up from the environment are absolute\n    fix(deps): update module github.com/cyphar/filepath-securejoin to v0.2.4\n    fix(deps): update module github.com/docker/docker to v24.0.6+incompatible\n    Don't try to look up names when committing images\n    fix(deps): update module golang.org/x/crypto to v0.13.0\n    docs: use valid github repo\n    fix(deps): update module golang.org/x/sys to v0.12.0\n    vendor containers/common@12405381ff45\n    push: --force-compression should be true with --compression-format\n    Update module github.com/containerd/containerd to v1.7.5\n    [skip-ci] Update tim-actions/commit-message-checker-with-regex action to v0.3.2\n    docs: add reference to oci-hooks\n    Support passing of ULimits as -1 to mean max\n    GHA: Attempt to fix discussion_lock workflow\n    Fixing the owner of the storage.conf.\n    pkg/chrootuser: Ignore comments when parsing /etc/group on FreeBSD\n    Use buildah repo rather then podman repo\n    GHA: Closed issue/PR comment-lock test\n    fix(deps): update module github.com/containers/storage to v1.49.0\n    chore(deps): update dependency containers/automation_images to v20230816\n    Replace troff code with markdown in buildah-{copy,add}.1.md\n    [CI:BUILD] rpm: spdx compatible license field\n    executor: build-arg warnings must honor global args\n    fix(deps): update module github.com/containers/ocicrypt to v1.1.8\n    chroot: `setSeccomp` add support for `ArchPARISC(64)` and `ArchRISCV64`\n    make,cross: restore loong64\n    Clear CommonBuildOpts when loading Builder status\n    buildah/push/manifest-push: add support for --force-compression\n    vendor: bump c/common to v0.55.1-0.20230811093040-524b4d5c12f9\n    chore(deps): update dependency containers/automation_images to v20230809\n    [CI:BUILD] RPM: fix buildtags\n    fix(deps): update module github.com/opencontainers/runc to v1.1.9\n    chore(deps): update dependency ubuntu to v22\n    chore(deps): update dependency containers/automation_images to v20230807\n    [CI:BUILD] Packit: add fedora-eln targets\n    [CI:BUILD] RPM: build docs with vendored go-md2man\n    packit: Build PRs into default packit COPRs\n    Update install.md\n    Update install.md changes current Debian stable version name\n    fix(deps): update module golang.org/x/term to v0.11.0\n    fix(deps): update module golang.org/x/crypto to v0.12.0\n    tests: fix layer-label tests\n    buildah: add --layer-label for setting labels on layers\n    Cirrus: container/rootless env. var. passthrough\n    Cirrus: Remove duplicate env. var. definitions\n    fix(deps): update github.com/containers/storage digest to c3da76f\n    Add a missing .Close() call on an ImageSource\n    Create only a reference when that's all we need\n    Add a missing .Close() call on an ImageDestination\n    CI:BUILD] RPM: define gobuild macro for rhel/centos stream\n    manifest/push: add support for --add-compression\n    manifest/inspect: add support for tls-verify and authfile\n    vendor: bump c/common to v0.55.1-0.20230727095721-647ed1d4d79a\n    vendor: bump c/image to v5.26.1-0.20230726142307-8c387a14f4ac\n    fix(deps): update module github.com/containerd/containerd to v1.7.3\n    fix(deps): update module github.com/onsi/gomega to v1.27.10\n    fix(deps): update module github.com/docker/docker to v24.0.5+incompatible\n    fix(deps): update module github.com/containers/image/v5 to v5.26.1\n    fix(deps): update module github.com/opencontainers/runtime-spec to v1.1.0\n    Update vendor of containers/(storage,image,common)\n    fix(deps): update module github.com/opencontainers/runc to v1.1.8\n    [CI:BUILD] Packit: remove pre-sync action\n    fix(deps): update module github.com/containers/common to v0.55.2\n    [CI:BUILD] Packit: downstream task script needs GOPATH\n    Vendor in containers/(common, image, storage)\n    fix(deps): update module golang.org/x/term to v0.10.0\n    [CI:BUILD] Packit: fix pre-sync action for downstream tasks\n    contrib/buildahimage: set config correctly for rootless build user\n    fix(deps): update module github.com/opencontainers/image-spec to v1.1.0-rc4\n    Bump to v1.32.0-dev\n    Update debian install instructions\n    pkg/overlay: add limited support for FreeBSD\n\n## v1.31.0 (2023-06-30)\n\n    Bump c/common to 0.55.1 and c/image to 5.26.1\n    Bump c/image to 5.26.0 and c/common to 0.54.0\n    vendor: update c/{common,image,storage} to latest\n    chore: pkg imported more than once\n    buildah: add pasta(1) support\n    use slirp4netns package from c/common\n    update c/common to latest\n    add hostname to /etc/hosts when running with host network\n    vendor: update c/common to latest\n    [CI:BUILD] Packit: add jobs for downstream Fedora package builds\n    fix(deps): update module golang.org/x/sync to v0.3.0\n    fix(deps): update module golang.org/x/crypto to v0.10.0\n    Add smoke tests for encryption CLI helpers\n    fix(deps): update module golang.org/x/term to v0.9.0\n    fix(deps): update module github.com/opencontainers/runtime-spec to v1.1.0-rc.3\n    Remove device mapper support\n    Remove use of deprecated tar.TypeRegA\n    Update tooling to support newer golangci-lint\n    Make cli.EncryptConfig,DecryptConfig, GetFormat public\n    Don't decrypt images by default\n    fix(deps): update module github.com/onsi/gomega to v1.27.8\n    fix(deps): update github.com/containers/storage digest to 3f3fb2f\n    Renovate: Don't touch fragile test stuffs\n    [CI:DOCS] Update comment to remove ambiguity\n    fix(deps): update github.com/containers/image/v5 digest to abe5133\n    fix(deps): update module github.com/sirupsen/logrus to v1.9.3\n    fix(deps): update module github.com/containerd/containerd to v1.7.2\n    Explicitly ref. quay images for CI\n    At startup, log the effective capabilities for debugging\n    parse: use GetTempDir from internal utils\n    GetTmpDir: honor image_copy_tmp_dir from containers.conf\n    docs/Makefile: don't show sed invocations\n    CI: Support testing w/ podman-next COPR packages\n    intermediate-images inherit-label test: make it debuggable\n    fix(deps): update github.com/containers/common digest to 462ccdd\n    Add a warning to `--secret` docs\n    vendor: bump c/storage to v1.46.2-0.20230526114421-55ee2d19292f\n    executor: apply label to only final stage\n    remove registry.centos.org\n    Go back to setting SysProcAttr.Pdeathsig for child processes\n    Fix auth.json path (validated on Fedora 38) wq Signed-off-by: Andreas Mack <andreas.mack@gmail.com>\n    fix(deps): update module github.com/stretchr/testify to v1.8.3\n    CI: fix test broken by renovatebot\n    chore(deps): update quay.io/libpod/testimage docker tag to v20221018\n    fix(deps): update module github.com/onsi/gomega to v1.27.7\n    test: use debian instead of docker.io/library/debian:testing-slim\n    vendor: bump logrus to 1.9.2\n    [skip-ci] Update tim-actions/get-pr-commits action to v1.3.0\n    Revert \"Proof of concept: nightly dependency treadmill\"\n    fix(deps): update module github.com/sirupsen/logrus to v1.9.1\n    vendor in containers/(common,storage,image)\n    fix(deps): update module github.com/docker/distribution to v2.8.2+incompatible\n    run: drop Pdeathsig\n    chroot: lock thread before setPdeathsig\n    tests: add a case for required=false\n    fix(deps): update module github.com/openshift/imagebuilder to v1.2.5\n    build: validate volumes on backend\n    secret: accept required flag w/o value\n    fix(deps): update module github.com/containerd/containerd to v1.7.1\n    fix(deps): update module golang.org/x/crypto to v0.9.0\n    Update the demos README file to fix minor typos\n    fix(deps): update module golang.org/x/sync to v0.2.0\n    fix(deps): update module golang.org/x/term to v0.8.0\n    manifest, push: use source as destination if not specified\n    run,mount: remove path only if they didnt pre-exist\n    Cirrus: Fix meta task failing to find commit\n    parse: filter edge-case for podman-remote\n    fix(deps): update module github.com/opencontainers/runc to v1.1.7\n    fix(deps): update module github.com/docker/docker to v23.0.5+incompatible\n    build: --platform must accept only arch\n    fix(deps): update module github.com/containers/common to v0.53.0\n    makefile: increase conformance timeout\n    Cap suffixDigitsModulo to a 9-digits suffix.\n    Rename conflict to suffixDigitsModulo\n    fix(deps): update module github.com/opencontainers/runtime-spec to v1.1.0-rc.2\n    fix(deps): update module github.com/opencontainers/runc to v1.1.6\n    chore(deps): update centos docker tag to v8\n    Clarify the need for qemu-user-static package\n    chore(deps): update quay.io/centos/centos docker tag to v8\n    Renovate: Ensure test/tools/go.mod is managed\n    Revert \"buildah image should not enable fuse-overlayfs for rootful mode\"\n    Bump to v1.31.0-dev\n    parse: add support for relabel bind mount option\n\n## v1.30.0 (2023-04-06)\n\n    fix(deps): update module github.com/opencontainers/runc to v1.1.5\n    fix(deps): update module github.com/fsouza/go-dockerclient to v1.9.7\n    buildah image should not enable fuse-overlayfs for rootful mode\n    stage_executor: inline network add default string\n    fix(deps): update module github.com/containers/common to v0.51.2\n    chore(deps): update dependency containers/automation_images to v20230330\n    fix(deps): update module github.com/docker/docker to v23.0.2+incompatible\n    chore(deps): update dependency containers/automation_images to v20230320\n    fix(deps): update module github.com/onsi/gomega to v1.27.6\n    fix(deps): update github.com/opencontainers/runtime-tools digest to e931285\n    [skip-ci] Update actions/stale action to v8\n    test: don't allow to override io.buildah.version\n    executor: only apply label on the final stage\n    Update docs/buildah-build.1.md\n    update build instruction for Ubuntu\n    code review\n    build: accept arguments from file with --build-arg-file\n    run_linux: Update heuristic for mounting /sys\n    [CI:BUILD] Packit: Enable Copr builds on PR and commit to main\n    fix(deps): update module github.com/fsouza/go-dockerclient to v1.9.6\n    Update to Go 1.18\n    Disable dependabot in favor of renovate\n    chore(deps): update dependency containers/automation_images to v20230314\n    Fix requiring tests on Makefile changes\n    Vendor in latest containers/(storage, common, image)\n    imagebuildah: set len(short_image_id) to 12\n    Re-enable conformance tests\n    Skip conformance test failures with Docker 23.0.1\n    Cirrus: Replace Ubuntu -> Debian SID\n    run: add support for inline --network in RUN stmt\n    vendor: bump imagebuilder to a3c3f8358ca31b1e4daa6\n    stage_executor: attempt to push cache only when cacheKey is valid\n    Add \"ifnewer\" as option in help message for pull command\n    build: document behaviour of buildah's distributed cache\n    fix(deps): update module golang.org/x/term to v0.6.0\n    Add default list of capabilities required to run buildah in a container\n    executor,copy: honor default ARG value while eval stage\n    sshagent: use ExtendedAgent instead of Agent\n    tests/bud: remove unwated test\n    executor: do not warn on builtin default args\n    executor: don't warn about unused TARGETARCH,TARGETOS,TARGETPLATFORM\n    Fix tutorial for rootless mode\n    Vendor in latest containers/(common, storage, image)\n    Ignore the base image's base image annotations\n    fix(deps): update module github.com/fsouza/go-dockerclient to v1.9.5\n    build(deps): bump github.com/containers/storage from 1.45.3 to 1.45.4\n    Vendor in latest containers/common\n    docs/tutorials/04: add defaults for Run()\n    imagebuildah.StageExecutor: suppress bogus \"Pushing cache []:...\"\n    executor: also add stage with no children to cleanupStages\n    [CI:BUILD] copr: fix el8 builds\n    Fix documentation on which Capabilities are allowed by default\n    Skip subject-length validation for renovate PRs\n    Temporarily hard-skip bud-multiple-platform-values test\n    fix(deps): update github.com/openshift/imagebuilder digest to 86828bf\n    build(deps): bump github.com/containerd/containerd from 1.6.16 to 1.6.17\n    build(deps): bump tim-actions/get-pr-commits from 1.1.0 to 1.2.0\n    build(deps): bump github.com/containers/image/v5 from 5.24.0 to 5.24.1\n    [skip-ci] Update tim-actions/get-pr-commits digest to 55b867b\n    build(deps): bump github.com/opencontainers/selinux\n    build(deps): bump golang.org/x/crypto from 0.5.0 to 0.6.0\n    Add renovate configuration\n    Run codespell on codebase\n    login: support interspersed args for password\n    conformance: use scratch for minimal test\n    pkg/parse: expose public CleanCacheMount API\n    build(deps): bump go.etcd.io/bbolt from 1.3.6 to 1.3.7\n    build(deps): bump github.com/containerd/containerd from 1.6.15 to 1.6.16\n    docs: specify order preference for FROM\n    Bump to v1.30.0-dev\n\n## v1.29.0 (2023-01-25)\n\n    tests: improve build-with-network-test\n    Bump c/storagev1.45.3, c/imagev5.24.0, c/commonv0.51.0\n    build(deps): bump github.com/onsi/gomega from 1.25.0 to 1.26.0\n    Flake 3710 has been closed. Reenable the test.\n    [CI:DOCS] Fix two diversity issues in a tutorial\n    build(deps): bump github.com/fsouza/go-dockerclient from 1.9.2 to 1.9.3\n    vendor in latests containers/(storage, common, image)\n    fix bud-multiple-platform-with-base-as-default-arg flake\n    stage_executor: while mounting stages use freshly built stage\n    build(deps): bump github.com/fsouza/go-dockerclient from 1.9.0 to 1.9.2\n    build(deps): bump github.com/onsi/gomega from 1.24.2 to 1.25.0\n    vendor in latests containers/(storage, common, image, ocicyrpt)\n    [Itests: change the runtime-flag test for crun\n    [CI:DOCS] README: drop sudo\n    Fix multi-arch manifest-list build timeouts\n    Cirrus: Update VM Images\n    bud: Consolidate multiple synthetic LABEL instructions\n    build, secret: allow realtive mountpoints wrt to work dir\n    fixed squash documentation\n    build(deps): bump github.com/containerd/containerd from 1.6.14 to 1.6.15\n    Correct minor comment\n    Vendor in latest containers/(common, image, storage)\n    system tests: remove unhelpful assertions\n    buildah: add prune command and expose CleanCacheMount API\n    vendor: bump c/storage to a747b27\n    Add support for --group-add to buildah from\n    build(deps): bump actions/stale from 6 to 7\n    Add documentation for buildah build --pull=missing\n    build(deps): bump github.com/containerd/containerd from 1.6.12 to 1.6.14\n    build(deps): bump github.com/docker/docker\n    parse: default ignorefile must not point to symlink outside context\n    buildah: wrap network setup errors\n    build, mount: allow realtive mountpoints wrt to work dir\n    Update to F37 CI VM Images, re-enable prior-fedora\n    Update vendor or containers/(image, storage, common)\n    build(deps): bump golang.org/x/crypto from 0.3.0 to 0.4.0\n    Update contact information\n    build(deps): bump golang.org/x/term from 0.2.0 to 0.3.0\n    Replace io/ioutil calls with os calls\n    [skip-ci] GHA/Cirrus-cron: Fix execution order\n    Vendor in containers/common\n    build(deps): bump golang.org/x/sys from 0.2.0 to 0.3.0\n    remote-cache: support multiple sources and destinations\n    Update c/storage after https://github.com/containers/storage/pull/1436\n    util.SortMounts(): make the returned order more stable\n    version: Bump to 1.29.0-dev\n    [CI:BUILD] Cirrus: Migrate OSX task to M1\n    Update vendor of containers/(common, storage, image)\n    mount=type=cache: seperate cache parent on host for each user\n    Fix installation instructions for Gentoo Linux\n    build(deps): bump github.com/containerd/containerd from 1.6.9 to 1.6.10\n    GHA: Reuse both cirrus rerun and check workflows\n    Vendor in latest containers/(common,image,storage)\n    build(deps): bump github.com/onsi/gomega from 1.24.0 to 1.24.1\n    copier.Put(): clear up os/syscall mode bit confusion\n    build(deps): bump golang.org/x/sys from 0.1.0 to 0.2.0\n    Use TypeBind consistently to name bind/nullfs mounts\n    Add no-new-privileges flag\n    Update vendor of containers/(common, image, storage)\n    imagebuildah:build with --all-platforms must honor args for base images\n    codespell code\n    Expand args and env when using --all-platforms\n    build(deps): bump github.com/onsi/gomega from 1.23.0 to 1.24.0\n    GHA: Simplify Cirrus-Cron check slightly\n    Stop using ubi8\n    remove unnecessary (hence misleading) rmi\n    chroot: fix mounting of ro bind mounts\n    executor: honor default ARG value while eval base name\n    userns: add arbitrary steps/stage to --userns=auto test\n    Don't set allow.mount in the vnet jail on Freebsd\n    copier: Preserve file flags when copying archives on FreeBSD\n    Remove quiet flag, so that it works in podman-remote\n    test: fix preserve rootfs with --mount for podman-remote\n    test: fix prune logic for cache-from after adding content summary\n    vendor in latest containers/(storage, common, image)\n    Fix RUN --mount=type=bind,from=<stage> not preserving rootfs of stage\n    Define and use a safe, reliable test image\n    Fix word missing in Container Tools Guide\n    Makefile: Use $(MAKE) to start sub-makes in install.tools\n    imagebuildah: pull cache from remote repo after adding content summary\n    Makefile: Fix install on FreeBSD\n    Ensure the cache volume locks are unlocked on all paths\n    Vendor in latest containers/(common,storage)\n    Simplify the interface of GetCacheMount and getCacheMount\n    Fix cache locks with multiple mounts\n    Remove calls to Lockfile.Locked()\n    Maintain cache mount locks as lock objects instead of paths\n    test: cleaning cache must not clean lockfiles\n    run: honor lockfiles for multiple --mount instruction\n    mount,cache: lockfiles must not be part of users cache content\n    Update vendor containers/(common,image,storage)\n    [CI:BUILD] copr: buildah rpm should depend on containers-common-extra\n    pr-should-include-tests: allow specfile, golangci\n    build(deps): bump dawidd6/action-send-mail from 3.7.0 to 3.7.1\n    build(deps): bump github.com/docker/docker\n    build(deps): bump github.com/fsouza/go-dockerclient from 1.8.3 to 1.9.0\n    Update vendor containers/(common,image,storage)\n    build(deps): bump actions/upload-artifact from 2 to 3\n    build(deps): bump actions/checkout from 2 to 3\n    build(deps): bump actions/stale from 1 to 6\n    build(deps): bump dawidd6/action-send-mail from 2.2.2 to 3.7.0\n    build(deps): bump tim-actions/get-pr-commits from 1.1.0 to 1.2.0\n    sshagent: LockOSThread before setting SocketLabel\n    Update tests for error message changes\n    Update c/image after https://github.com/containers/image/pull/1299\n    Fix ident for dependabot gha block\n    build(deps): bump github.com/containers/ocicrypt from 1.1.5 to 1.1.6\n    Fix man pages to match latest cobra settings\n    build(deps): bump github.com/spf13/cobra from 1.5.0 to 1.6.0\n    build(deps): bump github.com/onsi/gomega from 1.20.2 to 1.22.1\n    test: retrofit 'bud with undefined build arg directory'\n    imagebuildah: warnOnUnsetBuildArgs while processing stages from executor\n    Update contrib/buildahimage/Containerfile\n    Cirrus CI add flavor parameter\n    Correction - `FLAVOR` not `FLAVOUR`\n    Changed build argument from `RELEASE` to `FLAVOUR`\n    Combine buildahimage Containerfiles\n    bud.bats refactoring: $TEST_SCRATCH_DIR, part 2 of 2\n    bud.bats refactoring: $TEST_SCRATCH_DIR, part 1 of 2\n    System test cleanup: document, clarify, fix\n    test: removing unneeded/expensive COPY\n    test: warning behaviour for unset/set TARGETOS,TARGETARCH,TARGETPLATFORM\n    Bump to v1.28.1-dev\n\n## v1.28.0 (2022-09-30)\n\n    Update vendor containers/(common,image)\n    [CI:DOCS] Add quay-description update reminder\n    vendor: bump c/common to v0.49.2-0.20220929111928-2d1b45ae2423\n    build(deps): bump github.com/opencontainers/selinux\n    Vendor in latest containers/storage\n    Changing shell list operators from `;` to `&&`\n    Fix buildahimage container.conf permissions regression\n    Set sysctls from containers.conf\n    refactor: stop using Normalize directly from containerd package\n    config,builder: process variant while populating image spec\n    Proof of concept: nightly dependency treadmill\n    Run codespell on code\n    Check for unset build args after TARGET args\n    pkg/cli: improve completion test\n    vendor in latest containers/(common,storage,image)\n    copier: work around freebsd bug for \"mkdir /\"\n    vendor: update c/image\n    test: run in the host cgroup namespace\n    vendor: update c/storage\n    vendor: update c/common\n    cmd: check for user UID instead of privileges\n    run,build: conflict --isolation=chroot and --network\n    Fix broken dns test (from merge collision)\n    Fix stutters\n    Fix broken command completion\n    buildah bud --network=none should have no network\n    build: support --skip-unused-stages for multi-stage builds\n    Prevent use of --dns* options with --net=none\n    buildah: make --cache-ttl=0s equivalent to --no-cache\n    parse: make processing flags in --mount order agnostic\n    Minor test fix for podman-remote\n    build: honor <Containerfile>.containerignore as ignore file\n    Update install.md: Debian 11 (Bullseye) is stable\n    build(deps): bump github.com/docker/docker\n    Use constants from containers/common for finding seccomp.json\n    Don't call os.Exit(1) from manifest exist\n    manifest: add support for buildah manifest exists\n    Buildah should ignore /etc/crio/seccomp.json\n    chroot: Fix cross build break\n    chroot: Move isDevNull to run_common.go\n    chroot: Fix setRlimit build on FreeBSD\n    chroot: Move parseRLimits and setRlimits to run_common.go\n    chroot: Fix runUsingChrootExecMain on FreeBSD\n    chroot: Move runUsingChrootExecMain to run_common.go\n    chroot: Factor out Linux-specific unshare options from runUsingChroot\n    chroot: Move runUsingChroot to run_common.go\n    chroot: Move RunUsingChroot and runUsingChrootMain to run_common.go\n    chroot: Factor out /dev/ptmx pty implementation\n    chroot: Add FreeBSD support for run with chroot isolation\n    build(deps): bump github.com/docker/go-units from 0.4.0 to 0.5.0\n    Replace k8s.gcr.io/pause in tests with registry.k8s.io/pause\n    build(deps): bump github.com/onsi/gomega from 1.20.0 to 1.20.1\n    Cirrus: use image with fewer downloaded dependencies\n    build(deps): bump github.com/opencontainers/runc from 1.1.3 to 1.1.4\n    run: add container gid to additional groups\n    buildah: support for --retry and --retry-delay for push/pull failures\n    Makefile: always call $(GO) instead of `go`\n    build(deps): bump github.com/fsouza/go-dockerclient from 1.8.2 to 1.8.3\n    test: use `T.TempDir` to create temporary test directory\n    mount,cache: enable SElinux shared content label option by default\n    commit: use race-free RemoveNames instead of SetNames\n    Drop util/util.Cause()\n    cmd/buildah: add \"manifest create --amend\"\n    build(deps): bump github.com/fsouza/go-dockerclient from 1.8.1 to 1.8.2\n    docs: specify git protocol is not supported for github hosted repo\n    Scrub user and group names from layer diffs\n    build(deps): bump github.com/containerd/containerd from 1.6.6 to 1.6.8\n    version: bump to 1.28.0-dev\n\n## v1.27.0 (2022-08-01)\n\n    build: support filtering cache by duration using `--cache-ttl`.\n    build: support building from commit when using git repo as build context.\n    build: clean up git repos correctly when using subdirs.\n    build: add support for distributing cache to remote sources using `--cache-to` and `--cache-from`.\n    imagebuildah: optimize cache hits for `COPY` and `ADD` instructions.\n    build: support OCI hooks for ephemeral build containers.\n    build: add support for `--userns=auto`.\n    copier: add NoOverwriteNonDirDir option .\n    add initial support for building images using Buildah on FreeBSD.\n    multistage: this now skips the computing of unwanted stages to improve performance.\n    multiarch: support splitting build logs for `--platform` using `--logsplit`.\n    build: add support for building images where the base image has no history.\n    commit: allow disabling image history with `--omit-history`.\n    build: add support for renaming a device in rootless setups.\n    build: now supports additionalBuildContext in builds via the `--build-context` option.\n    build: `--output` produces artifacts even if the build container is not committed.\n    build: now accepts `-cpp-flag`, allowing users to pass in CPP flags when processing a Containerfile with C Preprocessor-like syntax.\n    build: now accepts a branch and a subdirectory when the build context is a git repository.\n    build: output now shows a progress bar while pushing and pulling images\n    build: now errors out if the path to Containerfile is a directory.\n    build: support building container images on environments that are rootless and without any valid login sessions.\n    fix: `--output` now generates artifacts even if the entire build is cached.\n    fix: `--output` generates artifacts only for the target stage in multi-stage builds.\n    fix,add: now fails on a bad HTTP response instead of writing to container\n    fix,squash: never use build cache when computing the last step of the last stage\n    fix,build,run: allow reusing secret more than once in different RUN steps\n    fix: compatibility with Docker build by making its --label and --annotate options set empty labels and annotations when given a name but no `=` or label value.\n\n## v1.26.0 (2022-05-04)\n\n    imagebuildah,build: move deepcopy of args before we spawn goroutine\n    Vendor in containers/storage v1.40.2\n    buildah.BuilderOptions.DefaultEnv is ignored, so mark it as deprecated\n    help output: get more consistent about option usage text\n    Handle OS version and features flags\n    buildah build: --annotation and --label should remove values\n    buildah build: add a --env\n    buildah: deep copy options.Args before performing concurrent build/stage\n    test: inline platform and builtinargs behaviour\n    vendor: bump imagebuilder to master/009dbc6\n    build: automatically set correct TARGETPLATFORM where expected\n    build(deps): bump github.com/fsouza/go-dockerclient\n    Vendor in containers/(common, storage, image)\n    imagebuildah, executor: process arg variables while populating baseMap\n    buildkit: add support for custom build output with --output\n    Cirrus: Update CI VMs to F36\n    fix staticcheck linter warning for deprecated function\n    Fix docs build on FreeBSD\n    build(deps): bump github.com/containernetworking/cni from 1.0.1 to 1.1.0\n    copier.unwrapError(): update for Go 1.16\n    copier.PutOptions: add StripSetuidBit/StripSetgidBit/StripStickyBit\n    copier.Put(): write to read-only directories\n    build(deps): bump github.com/cpuguy83/go-md2man/v2 in /tests/tools\n    Rename $TESTSDIR (the plural one), step 4 of 3\n    Rename $TESTSDIR (the plural one), step 3 of 3\n    Rename $TESTSDIR (the plural one), step 2 of 3\n    Rename $TESTSDIR (the plural one), step 1 of 3\n    build(deps): bump github.com/containerd/containerd from 1.6.2 to 1.6.3\n    Ed's periodic test cleanup\n    using consistent lowercase 'invalid' word in returned err msg\n    Update vendor of containers/(common,storage,image)\n    use etchosts package from c/common\n    run: set actual hostname in /etc/hostname to match docker parity\n    update c/common to latest main\n    Update vendor of containers/(common,storage,image)\n    Stop littering\n    manifest-create: allow creating manifest list from local image\n    Update vendor of storage,common,image\n    Bump golang.org/x/crypto to 7b82a4e\n    Initialize network backend before first pull\n    oci spec: change special mount points for namespaces\n    tests/helpers.bash: assert handle corner cases correctly\n    buildah: actually use containers.conf settings\n    integration tests: learn to start a dummy registry\n    Fix error check to work on Podman\n    buildah build should accept at most one arg\n    tests: reduce concurrency for flaky bud-multiple-platform-no-run\n    vendor in latest containers/common,image,storage\n    manifest-add: allow override arch,variant while adding image\n    Remove a stray `\\` from .containerenv\n    Vendor in latest opencontainers/selinux v1.10.1\n    build, commit: allow removing default identity labels\n    Create shorter names for containers based on image IDs\n    test: skip rootless on cgroupv2 in root env\n    fix hang when oci runtime fails\n    Set permissions for GitHub actions\n    copier test: use correct UID/GID in test archives\n    run: set parent-death signals and forward SIGHUP/SIGINT/SIGTERM\n    Bump back to v1.26.0-dev\n    build(deps): bump github.com/opencontainers/runc from 1.1.0 to 1.1.1\n    Included the URL to check the SHA\n\n## v1.25.1 (2022-03-30)\n\n    buildah: create WORKDIR with USER permissions\n    vendor: update github.com/openshift/imagebuilder\n    copier: attempt to open the dir before adding it\n    Updated dependabot to get updates for GitHub actions.\n    Switch most calls to filepath.Walk to filepath.WalkDir\n    build: allow --no-cache and --layers so build cache can be overrided\n    build(deps): bump github.com/onsi/gomega from 1.18.1 to 1.19.0\n    Bump to v1.26.0-dev\n    build(deps): bump github.com/golangci/golangci-lint in /tests/tools\n\n## v1.25.0 (2022-03-25)\n\n    install: drop RHEL/CentOS 7 doc\n    build(deps): bump github.com/containers/common from 0.47.4 to 0.47.5\n    Bump c/storage to v1.39.0 in main\n    Add a test for CVE-2022-27651\n    build(deps): bump github.com/docker/docker\n    Bump github.com/prometheus/client_golang to v1.11.1\n    [CI:DOCS] man pages: sort flags, and keep them that way\n    build(deps): bump github.com/containerd/containerd from 1.6.1 to 1.6.2\n    Don't pollute\n    network setup: increase timeout to 4 minutes\n    do not set the inheritable capabilities\n    build(deps): bump github.com/golangci/golangci-lint in /tests/tools\n    build(deps): bump github.com/containers/ocicrypt from 1.1.2 to 1.1.3\n    parse: convert exposed GetVolumes to internal only\n    buildkit: mount=type=cache support locking external cache store\n    .in support: improve error message when cpp is not installed\n    buildah image: install cpp\n    build(deps): bump github.com/stretchr/testify from 1.7.0 to 1.7.1\n    build(deps): bump github.com/spf13/cobra from 1.3.0 to 1.4.0\n    build(deps): bump github.com/docker/docker\n    Add --no-hosts flag to eliminate use of /etc/hosts within containers\n    test: remove skips for rootless users\n    test: unshare mount/umount if test is_rootless\n    tests/copy: read correct containers.conf\n    build(deps): bump github.com/docker/distribution\n    cirrus: add seperate task and matrix for rootless\n    tests: skip tests for rootless which need unshare\n    buildah: test rootless integration\n    vendor: bump c/storage to main/93ce26691863\n    build(deps): bump github.com/fsouza/go-dockerclient from 1.7.9 to 1.7.10\n    tests/copy: initialize the network, too\n    [CI:DOCS] remove references to Kubic for CentOS and Ubuntu\n    build(deps): bump github.com/containerd/containerd from 1.6.0 to 1.6.1\n    use c/image/pkg/blobcache\n    vendor c/image/v5@v5.20.0\n    add: ensure the context directory is an absolute path\n    executor: docker builds must inherit healthconfig from base if any\n    docs: Remove Containerfile and containeringore\n    build(deps): bump github.com/fsouza/go-dockerclient from 1.7.8 to 1.7.9\n    helpers.bash: Use correct syntax\n    speed up combination-namespaces test\n    build(deps): bump github.com/golangci/golangci-lint in /tests/tools\n    Bump back to 1.25.0-dev\n    build(deps): bump github.com/containerd/containerd from 1.5.9 to 1.6.0\n\n## v1.24.2 (2022-02-16)\n\n    Increase subuid/subgid to 65535\n    history: only add proxy vars to history if specified\n    run_linux: use --systemd-cgroup\n    buildah: new global option --cgroup-manager\n    Makefile: build with systemd when available\n    build(deps): bump github.com/fsouza/go-dockerclient from 1.7.7 to 1.7.8\n    Bump c/common to v0.47.4\n    Cirrus: Use updated VM images\n    conformance: add a few \"replace-directory-with-symlink\" tests\n    Bump back to v1.25.0-dev\n\n## v1.24.1 (2022-02-03)\n\n    executor: Add support for inline --platform within Dockerfile\n    caps: fix buildah run --cap-add=all\n    Update vendor of openshift/imagebuilder\n    Bump version of containers/image and containers/common\n    Update vendor of containers/common\n    System tests: fix accidental vandalism of source dir\n    build(deps): bump github.com/containers/storage from 1.38.1 to 1.38.2\n    imagebuildah.BuildDockerfiles(): create the jobs semaphore\n    build(deps): bump github.com/onsi/gomega from 1.18.0 to 1.18.1\n    overlay: always honor mountProgram\n    overlay: move mount program invocation to separate function\n    overlay: move mount program lookup to separate function\n    Bump to v1.25.0-dev [NO TESTS NEEDED]\n\n## v1.24.0 (2022-01-26)\n\n    Update vendor of containers/common\n    build(deps): bump github.com/golangci/golangci-lint in /tests/tools\n    Github-workflow: Report both failures and errors.\n    build(deps): bump github.com/containers/image/v5 from 5.18.0 to 5.19.0\n    Update docs/buildah-build.1.md\n    [CI:DOCS] Fix typos and improve language\n    buildah bud --network add support for custom networks\n    Make pull commands be consistent\n    docs/buildah-build.1.md: don't imply that -v isn't just a RUN thing\n    build(deps): bump github.com/onsi/gomega from 1.17.0 to 1.18.0\n    Vendor in latest containers/image\n    Run codespell on code\n    .github/dependabot.yml: add tests/tools go.mod\n    CI: rm git-validation, add GHA job to validate PRs\n    tests/tools: bump go-md2man to v2.0.1\n    tests/tools/Makefile: simplify\n    tests/tools: bump onsi/ginkgo to v1.16.5\n    vendor: bump c/common and others\n    mount: add support for custom upper and workdir with overlay mounts\n    linux: fix lookup for runtime\n    overlay: add MountWithOptions to API which extends support for advanced overlay\n    Allow processing of SystemContext from FlagSet\n    .golangci.yml: enable unparam linter\n    util/resolveName: rm bool return\n    tests/tools: bump golangci-lint\n    .gitignore: fixups\n    all: fix capabilities.NewPid deprecation warnings\n    bind/mount.go: fix linter comment\n    all: fix gosimple warning S1039\n    tests/e2e/buildah_suite_test.go: fix gosimple warnings\n    imagebuildah/executor.go: fix gosimple warning\n    util.go: fix gosimple warning\n    build(deps): bump github.com/opencontainers/runc from 1.0.3 to 1.1.0\n    Enable git-daemon tests\n    Allow processing of id options from FlagSet\n    Cirrus: Re-order tasks for more parallelism\n    Cirrus: Freshen VM images\n    Fix platform handling for empty os/arch values\n    Allow processing of network options from FlagSet\n    Fix permissions on  secrets directory\n    Update containers/image and containers/common\n    bud.bats: use a local git daemon for the git protocol test\n    Allow processing of common options from FlagSet\n    Cirrus: Run int. tests in parallel with unit\n    vendor c/common\n    Fix default CNI paths\n    build(deps): bump github.com/fsouza/go-dockerclient from 1.7.6 to 1.7.7\n    multi-stage: enable mounting stages across each other with selinux enabled\n    executor: Share selinux label of first stage with other stages in a build\n    buildkit: add from field to bind and cache mounts so images can be used as source\n    Use config.ProxyEnv from containers/common\n    use libnetwork from c/common for networking\n    setup the netns in the buildah parent process\n    build(deps): bump github.com/containerd/containerd from 1.5.8 to 1.5.9\n    build(deps): bump github.com/fsouza/go-dockerclient from 1.7.4 to 1.7.6\n    build: fix libsubid test\n    Allow callers to replace the ContainerSuffix\n    parse: allow parsing anomaly non-human value for memory control group\n    .cirrus: remove static_build from ci\n    stage_executor: re-use all possible layers from cache for squashed builds\n    build(deps): bump github.com/spf13/cobra from 1.2.1 to 1.3.0\n    Allow rootless buildah to set resource limits on cgroup V2\n    build(deps): bump github.com/docker/docker\n    tests: move buildkit mount tests files from TESTSDIR to TESTDIR before modification\n    build(deps): bump github.com/opencontainers/runc from 1.0.2 to 1.0.3\n    Wire logger through to config\n    copier.Put: check for is-not-a-directory using lstat, not stat\n    Turn on rootless cgroupv2 tests\n    Grab all of the containers.conf settings for namespaces.\n    image: set MediaType in OCI manifests\n    copier: RemoveAll possibly-directories\n    Simple README fix\n    images: accept multiple filter with logical AND\n    build(deps): bump github.com/containernetworking/cni from 0.8.1 to 1.0.1\n    UPdate vendor of container/storage\n    build(deps): bump github.com/onsi/gomega from 1.16.0 to 1.17.0\n    build(deps): bump github.com/containers/image/v5 from 5.16.1 to 5.17.0\n    Make LocalIP public function so Podman can use it\n    Fix UnsetEnv for buildah bud\n    Tests should rely only on static/unchanging images\n    run: ensure that stdio pipes are labeled correctly\n    build(deps): bump github.com/docker/docker\n    Cirrus: Bump up to Fedora 35 & Ubuntu 21.10\n    chroot: don't use the generate default seccomp filter for unit tests\n    build(deps): bump github.com/containerd/containerd from 1.5.7 to 1.5.8\n    ssh-agent: Increase timeout before we explicitly close connection\n    docs/tutorials: update\n    Clarify that manifest defaults to localhost as the registry name\n    \"config\": remove a stray bit of debug output\n    \"commit\": fix a flag typo\n    Fix an error message: unlocking vs locking\n    Expand the godoc for CommonBuildOptions.Secrets\n    chroot: accept an \"rw\" option\n    Add --unsetenv option to buildah commit and build\n    define.TempDirForURL(): show CombinedOutput when a command fails\n    config: support the variant field\n    rootless: do not bind mount /sys if not needed\n    Fix tutorial to specify command on buildah run line\n    build: history should not contain ARG values\n    docs: Use guaranteed path for go-md2man\n    run: honor --network=none from builder if nothing specified\n    networkpolicy: Should be enabled instead of default when explictly set\n    Add support for env var secret sources\n    build(deps): bump github.com/docker/docker\n    fix: another non-portable shebang\n    Rootless containers users should use additional groups\n    Support overlayfs path contains colon\n    Report ignorefile location when no content added\n    Add support for host.containers.internal in the /etc/hosts\n    build(deps): bump github.com/onsi/ginkgo from 1.16.4 to 1.16.5\n    imagebuildah: fix nil deref\n    buildkit: add support for mount=type=cache\n    Default secret mode to 400\n    [CI:DOCS] Include manifest example usage\n    docs: update buildah-from, buildah-pull 'platform' option compatibility notes\n    docs: update buildah-build 'platform' option compatibility notes\n    De-dockerize the man page as much as possible\n    [CI:DOCS] Touch up Containerfile man page to show ARG can be 1st\n    docs: Fix and Update Containerfile man page with supported mount types\n    mount: add tmpcopyup to tmpfs mount option\n    buildkit: Add support for --mount=type=tmpfs\n    build(deps): bump github.com/opencontainers/selinux from 1.8.5 to 1.9.1\n    Fix command doc links in README.md\n    build(deps): bump github.com/containers/image/v5 from 5.16.0 to 5.16.1\n    build: Add support for buildkit like --mount=type=bind\n    Bump containerd to v1.5.7\n    build(deps): bump github.com/docker/docker\n    tests: stop pulling php, composer\n    Fix .containerignore link file\n    Cirrus: Fix defunct package metadata breaking cache\n    build(deps): bump github.com/containers/storage from 1.36.0 to 1.37.0\n    buildah build: add --all-platforms\n    Add man page for Containerfile and .containerignore\n    Plumb the remote logger throughut Buildah\n    Replace fmt.Sprintf(\"%d\", x) with strconv.Itoa(x)\n    Run: Cleanup run directory after every RUN step\n    build(deps): bump github.com/containers/common from 0.45.0 to 0.46.0\n    Makefile: adjust -ldflags/-gcflags/-gccgoflags depending on the go implementation\n    Makefile: check for `-race` using `-mod=vendor`\n    imagebuildah: fix an attempt to write to a nil map\n    push: support to specify the compression format\n    conformance: allow test cases to specify dockerUseBuildKit\n    build(deps): bump github.com/containers/common from 0.44.1 to 0.45.0\n    build(deps): bump github.com/containers/common from 0.44.0 to 0.44.1\n    unmarshalConvertedConfig(): handle zstd compression\n    tests/copy/copy: wire up compression options\n    Update to github.com/vbauerster/mpb v7.1.5\n    Add flouthoc to OWNERS\n    build: Add additional step nodes when labels are modified\n    Makefile: turn on race detection whenever it's available\n    conformance: add more tests for exclusion short-circuiting\n    Update VM Images + Drop prior-ubuntu testing\n    Bump to v1.24.0-dev\n\n## v1.23.0 (2021-09-13)\n\n    Vendor in containers/common v0.44.0\n    build(deps): bump github.com/containers/storage from 1.35.0 to 1.36.0\n    Update 05-openshift-rootless-build.md\n    build(deps): bump github.com/opencontainers/selinux from 1.8.4 to 1.8.5\n    .cirrus.yml: run cross_build_task on Big Sur\n    Makefile: update cross targets\n    Add support for rootless overlay mounts\n    Cirrus: Increase unit-test timeout\n    Docs: Clarify rmi w/ manifest/index use\n    build: mirror --authfile to filesystem if pointing to FD instead of file\n    Fix build with .git url with branch\n    manifest: rm should remove only manifests not referenced images.\n    vendor: bump c/common to v0.43.3-0.20210902095222-a7acc160fb25\n    Avoid rehashing and noop compression writer\n    corrected man page section; .conf file to mention its man page\n    copy: add --max-parallel-downloads to tune that copy option\n    copier.Get(): try to avoid descending into directories\n    tag: Support tagging manifest list instead of resolving to images\n    Install new manpages to correct sections\n    conformance: tighten up exception specifications\n    Add support for libsubid\n    Add epoch time field to buildah images\n    Fix ownership of /home/build/.local/share/containers\n    build(deps): bump github.com/containers/image/v5 from 5.15.2 to 5.16.0\n    Rename bud to build, while keeping an alias for to bud.\n    Replace golang.org/x/crypto/ssh/terminal with golang.org/x/term\n    build(deps): bump github.com/opencontainers/runc from 1.0.1 to 1.0.2\n    build(deps): bump github.com/onsi/gomega from 1.15.0 to 1.16.0\n    build(deps): bump github.com/fsouza/go-dockerclient from 1.7.3 to 1.7.4\n    build(deps): bump github.com/containers/common from 0.43.1 to 0.43.2\n    Move DiscoverContainerfile to pkg/util directory\n    build(deps): bump github.com/containers/image/v5 from 5.15.1 to 5.15.2\n    Remove some references to Docker\n    build(deps): bump github.com/containers/image/v5 from 5.15.0 to 5.15.1\n    imagebuildah: handle --manifest directly\n    build(deps): bump github.com/containers/common from 0.42.1 to 0.43.1\n    build(deps): bump github.com/opencontainers/selinux from 1.8.3 to 1.8.4\n    executor: make sure imageMap is updated with terminatedStage\n    tests/serve/serve.go: use a kernel-assigned port\n    Bump go for vendor-in-container from 1.13 to 1.16\n    imagebuildah: move multiple-platform building internal\n    Adds GenerateStructure helper function to support rootfs-overlay.\n    Run codespell to fix spelling\n    Implement SSH RUN mount\n    build(deps): bump github.com/onsi/gomega from 1.14.0 to 1.15.0\n    Fix resolv.conf content with run --net=private\n    run: fix nil deref using the option's logger\n    build(deps): bump github.com/containerd/containerd from 1.5.1 to 1.5.5\n    make vendor-in-container\n    bud: teach --platform to take a list\n    set base-image annotations\n    build(deps): bump github.com/opencontainers/selinux from 1.8.2 to 1.8.3\n    [CI:DOCS] Fix CHANGELOG.md\n    Bump to v1.23.0-dev [NO TESTS NEEDED]\n    Accept repositories on login/logout\n\n## v1.22.0 (2021-08-02)\n    c/image, c/storage, c/common vendor before Podman 3.3 release\n    WIP: tests: new assert()\n    Proposed patch for 3399 (shadowutils)\n    Fix handling of --restore shadow-utils\n    build(deps): bump github.com/containers/image/v5 from 5.13.2 to 5.14.0\n    runtime-flag (debug) test: handle old & new runc\n    build(deps): bump github.com/containers/storage from 1.32.6 to 1.33.0\n    Allow dst and destination for target in secret mounts\n    Multi-arch: Always push updated version-tagged img\n    Add a few tests on cgroups V2\n    imagebuildah.stageExecutor.prepare(): remove pseudonym check\n    refine dangling filter\n    Chown with environment variables not set should fail\n    Just restore protections of shadow-utils\n    build(deps): bump github.com/opencontainers/runc from 1.0.0 to 1.0.1\n    Remove specific kernel version number requirement from install.md\n    Multi-arch image workflow: Make steps generic\n    chroot: fix environment value leakage to intermediate processes\n    Update nix pin with `make nixpkgs`\n    buildah source - create and manage source images\n    Update cirrus-cron notification GH workflow\n    Reuse code from containers/common/pkg/parse\n    Cirrus: Freshen VM images\n    build(deps): bump github.com/containers/storage from 1.32.5 to 1.32.6\n    Fix excludes exception begining with / or ./\n    Fix syntax for --manifest example\n    build(deps): bump github.com/onsi/gomega from 1.13.0 to 1.14.0\n    vendor containers/common@main\n    Cirrus: Drop dependence on fedora-minimal\n    Adjust conformance-test error-message regex\n    Workaround appearance of differing debug messages\n    Cirrus: Install docker from package cache\n    build(deps): bump github.com/containers/ocicrypt from 1.1.1 to 1.1.2\n    Switch rusagelogfile to use options.Out\n    build(deps): bump github.com/containers/storage from 1.32.4 to 1.32.5\n    Turn stdio back to blocking when command finishes\n    Add support for default network creation\n    Cirrus: Updates for master->main rename\n    Change references from master to main\n    Add `--env` and `--workingdir` flags to run command\n    build(deps): bump github.com/opencontainers/runc\n    [CI:DOCS] buildah bud: spelling --ignore-file requires parameter\n    [CI:DOCS] push/pull: clarify supported transports\n    Remove unused function arguments\n    Create mountOptions for mount command flags\n    Extract version command implementation to function\n    Add --json flags to `mount` and `version` commands\n    build(deps): bump github.com/containers/storage from 1.32.2 to 1.32.3\n    build(deps): bump github.com/containers/common from 0.40.0 to 0.40.1\n    copier.Put(): set xattrs after ownership\n    buildah add/copy: spelling\n    build(deps): bump github.com/containers/common from 0.39.0 to 0.40.0\n    buildah copy and buildah add should support .containerignore\n    Remove unused util.StartsWithValidTransport\n    Fix documentation of the --format option of buildah push\n    Don't use alltransports.ParseImageName with known transports\n    build(deps): bump github.com/containers/image/v5 from 5.13.0 to 5.13.1\n    man pages: clarify `rmi` removes dangling parents\n    tests: make it easer to override the location of the copy helper\n    build(deps): bump github.com/containers/image/v5 from 5.12.0 to 5.13.0\n    [CI:DOCS] Fix links to c/image master branch\n    imagebuildah: use the specified logger for logging preprocessing warnings\n    Fix copy into workdir for a single file\n    Fix docs links due to branch rename\n    Update nix pin with `make nixpkgs`\n    build(deps): bump github.com/fsouza/go-dockerclient from 1.7.2 to 1.7.3\n    build(deps): bump github.com/opencontainers/selinux from 1.8.1 to 1.8.2\n    build(deps): bump go.etcd.io/bbolt from 1.3.5 to 1.3.6\n    build(deps): bump github.com/containers/storage from 1.32.1 to 1.32.2\n    build(deps): bump github.com/mattn/go-shellwords from 1.0.11 to 1.0.12\n    build(deps): bump github.com/onsi/ginkgo from 1.16.3 to 1.16.4\n    fix(docs): typo\n    Move to v1.22.0-dev\n    Fix handling of auth.json file while in a user namespace\n    Add rusage-logfile flag to optionally send rusage to a file\n    imagebuildah: redo step logging\n    build(deps): bump github.com/onsi/ginkgo from 1.16.2 to 1.16.3\n    build(deps): bump github.com/containers/storage from 1.32.0 to 1.32.1\n    Add volumes to make running buildah within a container easier\n    build(deps): bump github.com/onsi/gomega from 1.12.0 to 1.13.0\n    Add and use a \"copy\" helper instead of podman load/save\n    Bump github.com/containers/common from 0.38.4 to 0.39.0\n    containerImageRef/containerImageSource: don't buffer uncompressed layers\n    containerImageRef(): squashed images have no parent images\n    Sync. workflow across skopeo, buildah, and podman\n    Bump github.com/containers/storage from 1.31.1 to 1.31.2\n    Bump github.com/opencontainers/runc from 1.0.0-rc94 to 1.0.0-rc95\n    Bump to v1.21.1-dev [NO TESTS NEEDED]\n\n## v1.21.0 (2021-05-19)\n    Don't blow up if cpp detects errors\n    Vendor in containers/common v0.38.4\n    Remove 'buildah run --security-opt' from completion\n    update c/common\n    Fix handling of --default-mounts-file\n    update vendor of containers/storage v1.31.1\n    Bump github.com/containers/storage from 1.30.3 to 1.31.0\n    Send logrus messages back to caller when building\n    github: Fix bad repo. ref in workflow config\n    Check earlier for bad image tags name\n    buildah bud: fix containers/podman/issues/10307\n    Bump github.com/containers/storage from 1.30.1 to 1.30.3\n    Cirrus: Support [CI:DOCS] test skipping\n    Notification email for cirrus-cron build failures\n    Bump github.com/opencontainers/runc from 1.0.0-rc93 to 1.0.0-rc94\n    Fix race condition\n    Fix copy race while walking paths\n    Preserve ownership of lower directory when doing an overlay mount\n    Bump github.com/onsi/gomega from 1.11.0 to 1.12.0\n    Update nix pin with `make nixpkgs`\n    codespell cleanup\n    Multi-arch github-action workflow unification\n    Bump github.com/containers/image/v5 from 5.11.1 to 5.12.0\n    Bump github.com/onsi/ginkgo from 1.16.1 to 1.16.2\n    imagebuildah: ignore signatures when tagging images\n    update to latest libimage\n    Bump github.com/containers/common from 0.37.0 to 0.37.1\n    Bump github.com/containers/storage from 1.30.0 to 1.30.1\n    Upgrade to GitHub-native Dependabot\n    Document location of auth.json file if XDG_RUNTIME_DIR is not set\n    run.bats: fix flake in run-user test\n    Cirrus: Update F34beta -> F34\n    pr-should-include-tests: try to make work in buildah\n    runUsingRuntime: when relaying error from the runtime, mention that\n    Run(): avoid Mkdir() into the rootfs\n    imagebuildah: replace archive with chrootarchive\n    imagebuildah.StageExecutor.volumeCacheSaveVFS(): set up bind mounts\n    conformance: use :Z with transient mounts when SELinux is enabled\n    bud.bats: fix a bats warning\n    imagebuildah: create volume directories when using overlays\n    imagebuildah: drop resolveSymlink()\n    namespaces test - refactoring and cleanup\n    Refactor 'idmapping' system test\n    Cirrus: Update Ubuntu images to 21.04\n    Tiny fixes in bud system tests\n    Add compabitility wrappers for removed packages\n    Fix expected message at pulling image\n    Fix system tests of 'bud' subcommand\n    [CI:DOCS] Update steps for CentOS runc users\n    Add support for secret mounts\n    Add buildah manifest rm command\n    restore push/pull and util API\n    [CI:DOCS] Remove older distro docs\n    Rename rhel secrets to subscriptions\n    vendor in openshift/imagebuilder\n    Remove buildah bud --loglevel ...\n    use new containers/common/libimage package\n    Fix copier when using globs\n    Test namespace flags of 'bud' subcommand\n    Add system test of 'bud' subcommand\n    Output names of multiple tags in buildah bud\n    push to docker test: don't get fooled by podman\n    copier: add Remove()\n    build(deps): bump github.com/containers/image/v5 from 5.10.5 to 5.11.1\n    Restore log timestamps\n    Add system test of 'buildah help' with a tiny fix\n    tests: copy.bats: fix infinite hang\n    Do not force hard code to crun in rootless mode\n    build(deps): bump github.com/openshift/imagebuilder from 1.2.0 to 1.2.1\n    build(deps): bump github.com/containers/ocicrypt from 1.1.0 to 1.1.1\n    build(deps): bump github.com/containers/common from 0.35.4 to 0.36.0\n    Fix arg missing warning in bud\n    Check without flag in 'from --cgroup-parent' test\n    Minor fixes to Buildah as a library tutorial documentation\n    Add system test of 'buildah version' for packaged buildah\n    Add a few system tests of 'buildah from'\n    Log the final error with %+v at logging level \"trace\"\n    copier: add GetOptions.NoCrossDevice\n    Update nix pin with `make nixpkgs`\n    Bump to v1.20.2-dev\n\n## v1.20.1 (2021-04-13)\n    Run container with isolation type set at 'from'\n    bats helpers.bash - minor refactoring\n    Bump containers/storage vendor to v1.29.0\n    build(deps): bump github.com/onsi/ginkgo from 1.16.0 to 1.16.1\n    Cirrus: Update VMs w/ F34beta\n    CLI add/copy: add a --from option\n    build(deps): bump github.com/onsi/ginkgo from 1.15.2 to 1.16.0\n    Add authentication system tests for 'commit' and 'bud'\n    fix local image lookup for custom platform\n    Double-check existence of OCI runtimes\n    Cirrus: Make use of shared get_ci_vm container\n    Add system tests of \"buildah run\"\n    Update nix pin with `make nixpkgs`\n    Remove some stuttering on returns errors\n    Setup alias for --tty to --terminal\n    Add conformance tests for COPY /...\n    Put a few more minutes on the clock for the CI conformance test\n    Add a conformance test for COPY --from $symlink\n    Add conformance tests for COPY \"\"\n    Check for symlink in builtin volume\n    Sort all mounts by destination directory\n    System-test cleanup\n    Export parse.Platform string to be used by podman-remote\n    blobcache: fix sequencing error\n    build(deps): bump github.com/containers/common from 0.35.3 to 0.35.4\n    Fix URL in demos/buildah_multi_stage.sh\n    Add a few system tests\n    [NO TESTS NEEDED] Use --recurse-modules when building git context\n    Bump to v1.20.1-dev\n\n## v1.20.0 (2021-03-25)\n  * vendor in containers/storage v1.28.1\n  * build(deps): bump github.com/containers/common from 0.35.2 to 0.35.3\n  * tests: prefetch: use buildah, not podman, for pulls\n  * Use faster way to check image tag existence during multi-arch build\n  * Add information about multi-arch images to the Readme\n  * COPY --chown: expand the conformance test\n  * pkg/chrootuser: use a bufio.Scanner\n  * [CI:DOCS] Fix rootful typo in docs\n  * build(deps): bump github.com/onsi/ginkgo from 1.15.1 to 1.15.2\n  * Add documentation and testing for .containerignore\n  * build(deps): bump github.com/sirupsen/logrus from 1.8.0 to 1.8.1\n  * build(deps): bump github.com/hashicorp/go-multierror from 1.1.0 to 1.1.1\n  * Lookup Containerfile if user specifies a directory\n  * Add Tag format placeholder to docs\n  * copier: ignore sockets\n  * image: propagate errors from extractRootfs\n  * Remove system test of 'buildah containers -a'\n  * Clarify userns options are usable only as root in man pages\n  * Fix system test of 'containers -a'\n  * Remove duplicated code in addcopy\n  * build(deps): bump github.com/onsi/ginkgo from 1.15.0 to 1.15.1\n  * build(deps): bump github.com/onsi/gomega from 1.10.5 to 1.11.0\n  * build(deps): bump github.com/fsouza/go-dockerclient from 1.7.1 to 1.7.2\n  * Update multi-arch buildah build setup with new logic\n  * Update nix pin with `make nixpkgs`\n  * overlay.bats: fix the \"overlay source permissions\" test\n  * imagebuildah: use overlay for volumes when using overlay\n  * Make PolicyMap and PullPolicy names align\n  * copier: add GetOptions.IgnoreUnreadable\n  * Check local image to match system context\n  * fix: Containerfiles - smaller set of userns u/gids\n  * Set upperdir permissions based on source\n  * Shrink the vendoring size of pkc/cli\n  * Clarify image name match failure message\n  * ADD/COPY: create the destination directory first, chroot to it\n  * copier.GetOptions: add NoDerefSymLinks\n  * copier: add an Eval function\n  * Update system test for 'from --cap-add/drop'\n  * copier: fix a renaming bug\n  * copier: return child process stderr if we can't JSON decode the response\n  * Add some system tests\n  * build(deps): bump github.com/containers/storage from 1.26.0 to 1.27.0\n  * complement add/copy --chmod documentation\n  * buildah login and logout, do not need to enter user namespace\n  * Add multi-arch image build\n  * chmod/chown added/fixed in bash completions\n  * OWNERS: add @lsm5\n  * buildah add/copy --chmod dockerfile implementation\n  * bump github.com/openshift/imagebuilder from 1.1.8 to 1.2.0\n  * buildah add/copy --chmod cli implementation for files and urls\n  * Make sure we set the buildah version label\n  * Isolation strings, should match user input\n  * [CI:DOCS] buildah-from.md: remove dup arch,os\n  * build(deps): bump github.com/containers/image/v5 from 5.10.2 to 5.10.3\n  * Cirrus: Temp. disable prior-fedora (F32) testing\n  * pr-should-include-tests: recognized \"renamed\" tests\n  * build(deps): bump github.com/sirupsen/logrus from 1.7.0 to 1.8.0\n  * build(deps): bump github.com/fsouza/go-dockerclient from 1.7.0 to 1.7.1\n  * build(deps): bump github.com/containers/common from 0.34.2 to 0.35.0\n  * Fix reaping of stages with no instructions\n  * add stale bot\n  * Add base image name to comment\n  * build(deps): bump github.com/spf13/cobra from 1.1.1 to 1.1.3\n  * Don't fail copy to emptydir\n  * buildah: use volatile containers\n  * vendor: update containers/storage\n  * Eliminate the use of containers/building import in pkg subdirs\n  * Add more support for removing config\n  * Improve messages about --cache-from not being supported\n  * Revert patch to allow COPY/ADD of empty dirs.\n  * Don't fail copy to emptydir\n  * Fix tutorial for rootless mode\n  * Fix caching layers with build args\n  * Vendor in containers/image v5.10.2\n  * build(deps): bump github.com/containers/common from 0.34.0 to 0.34.2\n  * build(deps): bump github.com/onsi/ginkgo from 1.14.2 to 1.15.0\n  * 'make validate': require PRs to include tests\n  * build(deps): bump github.com/onsi/gomega from 1.10.4 to 1.10.5\n  * build(deps): bump github.com/containers/storage from 1.24.5 to 1.25.0\n  * Use chown function for U volume flag from containers/common repository\n  * --iidfile: print hash prefix\n  * bump containernetworking/cni to v0.8.1 - fix for CVE-2021-20206\n  * run: fix check for host pid namespace\n  * Finish plumbing for buildah bud --manifest\n  * buildah manifest add localimage should work\n  * Stop testing directory permissions with latest docker\n  * Fix build arg check\n  * build(deps): bump github.com/containers/ocicrypt from 1.0.3 to 1.1.0\n  * [ci:docs] Fix man page for buildah push\n  * Update nix pin with `make nixpkgs`\n  * Bump to containers/image v5.10.1\n  * Rebuild layer if a change in ARG is detected\n  * Bump golang.org/x/crypto to the latest\n  * Add Ashley and Urvashi to Approvers\n  * local image lookup by digest\n  * Use build-arg ENV val from local environment if set\n  * Pick default OCI Runtime from containers.conf\n  * Added required devel packages\n  * Cirrus: Native OSX Build\n  * Cirrus: Two minor cleanup items\n  * Workaround for RHEL gating test failure\n  * build(deps): bump github.com/stretchr/testify from 1.6.1 to 1.7.0\n  * build(deps): bump github.com/mattn/go-shellwords from 1.0.10 to 1.0.11\n  * Reset upstream branch to dev version\n  * If destination does not exists, do not throw error\n\n## v1.19.0 (2021-01-08)\n    Update vendor of containers/storage and containers/common\n    Buildah inspect should be able to inspect manifests\n    Make buildah push support pushing manifests lists and digests\n    Fix handling of TMPDIR environment variable\n    Add support for --manifest flags\n    Upper directory should match mode of destination directory\n    Only grab the OS, Arch if the user actually specified them\n    Use --arch and --os and --variant options to select architecture and os\n    Cirrus: Track libseccomp and golang version\n    copier.PutOptions: add an \"IgnoreDevices\" flag\n    fix: `rmi --prune` when parent image is in store.\n    build(deps): bump github.com/containers/storage from 1.24.3 to 1.24.4\n    build(deps): bump github.com/containers/common from 0.31.1 to 0.31.2\n    Allow users to specify stdin into containers\n    Drop log message on failure to mount on /sys file systems to info\n    Spelling\n    SELinux no longer requires a tag.\n    build(deps): bump github.com/opencontainers/selinux from 1.6.0 to 1.8.0\n    build(deps): bump github.com/containers/common from 0.31.0 to 0.31.1\n    Update nix pin with `make nixpkgs`\n    Switch references of /var/run -> /run\n    Allow FROM to be overriden with from option\n    copier: don't assume we can chroot() on Unixy systems\n    copier: add PutOptions.NoOverwriteDirNonDir, Get/PutOptions.Rename\n    copier: handle replacing directories with not-directories\n    copier: Put: skip entries with zero-length names\n    build(deps): bump github.com/containers/storage from 1.24.2 to 1.24.3\n    Add U volume flag to chown source volumes\n    Turn off PRIOR_UBUNTU Test until vm is updated\n    pkg, cli: rootless uses correct isolation\n    build(deps): bump github.com/onsi/gomega from 1.10.3 to 1.10.4\n    update installation doc to reflect current status\n    Move away from using docker.io\n    enable short-name aliasing\n    build(deps): bump github.com/containers/storage from 1.24.1 to 1.24.2\n    build(deps): bump github.com/containers/common from 0.30.0 to 0.31.0\n    Throw errors when using bogus --network flags\n    pkg/supplemented test: replace our null blobinfocache\n    build(deps): bump github.com/containers/common from 0.29.0 to 0.30.0\n    inserts forgotten quotation mark\n    Not prefer use local image create/add manifest\n    Add container information to .containerenv\n    Add --ignorefile flag to use alternate .dockerignore flags\n    Add a source debug build\n    Fix crash on invalid filter commands\n    build(deps): bump github.com/containers/common from 0.27.0 to 0.29.0\n    Switch to using containers/common pkg's\n    fix: non-portable shebang #2812\n    Remove copy/paste errors that leaked `Podman` into man pages.\n    Add suggests cpp to spec file\n    Apply suggestions from code review\n    update docs for debian testing and unstable\n    imagebuildah: disable pseudo-terminals for RUN\n    Compute diffID for mapped-layer at creating image source\n    intermediateImageExists: ignore images whose history we can't read\n    Bump to v1.19.0-dev\n    build(deps): bump github.com/containers/common from 0.26.3 to 0.27.0\n\n## v1.18.0 (2020-11-16)\n    Fix testing error caused by simultanious merge\n    Vendor in containers/storage v1.24.0\n    short-names aliasing\n    Add --policy flag to buildah pull\n    Stop overwrapping and stuttering\n    copier.Get(): ignore ENOTSUP/ENOSYS when listing xattrs\n    Run: don't forcibly disable UTS namespaces in rootless mode\n    test: ensure non-directory in a Dockerfile path is handled correctly\n    Add a few tests for `pull` command\n    Fix buildah config --cmd to handle array\n    build(deps): bump github.com/containers/storage from 1.23.8 to 1.23.9\n    Fix NPE when Dockerfile path contains non-directory entries\n    Update buildah bud man page from podman build man page\n    Move declaration of decryption-keys to common cli\n    Run: correctly call copier.Mkdir\n    util: digging UID/GID out of os.FileInfo should work on Unix\n    imagebuildah.getImageTypeAndHistoryAndDiffIDs: cache results\n    Verify userns-uid-map and userns-gid-map input\n    Use CPP, CC and flags in dep check scripts\n    Avoid overriding LDFLAGS in Makefile\n    ADD: handle --chown on URLs\n    Update nix pin with `make nixpkgs`\n    (*Builder).Run: MkdirAll: handle EEXIST error\n    copier: try to force loading of nsswitch modules before chroot()\n    fix MkdirAll usage\n    build(deps): bump github.com/containers/common from 0.26.2 to 0.26.3\n    build(deps): bump github.com/containers/storage from 1.23.7 to 1.23.8\n    Use osusergo build tag for static build\n    imagebuildah: cache should take image format into account\n    Bump to v1.18.0-dev\n\n## v1.17.0 (2020-10-29)\n    Handle cases where other tools mount/unmount containers\n    overlay.MountReadOnly: support RO overlay mounts\n    overlay: use fusermount for rootless umounts\n    overlay: fix umount\n    Switch default log level of Buildah to Warn. Users need to see these messages\n    Drop error messages about OCI/Docker format to Warning level\n    build(deps): bump github.com/containers/common from 0.26.0 to 0.26.2\n    tests/testreport: adjust for API break in storage v1.23.6\n    build(deps): bump github.com/containers/storage from 1.23.5 to 1.23.7\n    build(deps): bump github.com/fsouza/go-dockerclient from 1.6.5 to 1.6.6\n    copier: put: ignore Typeflag=\"g\"\n    Use curl to get repo file (fix #2714)\n    build(deps): bump github.com/containers/common from 0.25.0 to 0.26.0\n    build(deps): bump github.com/spf13/cobra from 1.0.0 to 1.1.1\n    Remove docs that refer to bors, since we're not using it\n    Buildah bud should not use stdin by default\n    bump containerd, docker, and golang.org/x/sys\n    Makefile: cross: remove windows.386 target\n    copier.copierHandlerPut: don't check length when there are errors\n    Stop excessive wrapping\n    CI: require that conformance tests pass\n    bump(github.com/openshift/imagebuilder) to v1.1.8\n    Skip tlsVerify insecure BUILD_REGISTRY_SOURCES\n    Fix build path wrong https://github.com/containers/podman/issues/7993\n    refactor pullpolicy to avoid deps\n    build(deps): bump github.com/containers/common from 0.24.0 to 0.25.0\n    CI: run gating tasks with a lot more memory\n    ADD and COPY: descend into excluded directories, sometimes\n    copier: add more context to a couple of error messages\n    copier: check an error earlier\n    copier: log stderr output as debug on success\n    Update nix pin with `make nixpkgs`\n    Set directory ownership when copied with ID mapping\n    build(deps): bump github.com/sirupsen/logrus from 1.6.0 to 1.7.0\n    build(deps): bump github.com/containers/common from 0.23.0 to 0.24.0\n    Cirrus: Remove bors artifacts\n    Sort build flag definitions alphabetically\n    ADD: only expand archives at the right time\n    Remove configuration for bors\n    Shell Completion for podman build flags\n    Bump c/common to v0.24.0\n    New CI check: xref --help vs man pages\n    CI: re-enable several linters\n    Move --userns-uid-map/--userns-gid-map  description into buildah man page\n    add: preserve ownerships and permissions on ADDed archives\n    Makefile: tweak the cross-compile target\n    Bump containers/common to v0.23.0\n    chroot: create bind mount targets 0755 instead of 0700\n    Change call to Split() to safer SplitN()\n    chroot: fix handling of errno seccomp rules\n    build(deps): bump github.com/containers/image/v5 from 5.5.2 to 5.6.0\n    Add In Progress section to contributing\n    integration tests: make sure tests run in ${topdir}/tests\n    Run(): ignore containers.conf's environment configuration\n    Warn when setting healthcheck in OCI format\n    Cirrus: Skip git-validate on branches\n    tools: update git-validation to the latest commit\n    tools: update golangci-lint to v1.18.0\n    Add a few tests of push command\n    Add(): fix handling of relative paths with no ContextDir\n    build(deps): bump github.com/containers/common from 0.21.0 to 0.22.0\n    Lint: Use same linters as podman\n    Validate: reference HEAD\n    Fix buildah mount to display container names not ids\n    Update nix pin with `make nixpkgs`\n    Add missing --format option in buildah from man page\n    Fix up code based on codespell\n    build(deps): bump github.com/openshift/imagebuilder from 1.1.6 to 1.1.7\n    build(deps): bump github.com/containers/storage from 1.23.4 to 1.23.5\n    Improve buildah completions\n    Cirrus: Fix validate commit epoch\n    Fix bash completion of manifest flags\n    Uniform some man pages\n    Update Buildah Tutorial to address BZ1867426\n    Update bash completion of `manifest add` sub command\n    copier.Get(): hard link targets shouldn't be relative paths\n    build(deps): bump github.com/onsi/gomega from 1.10.1 to 1.10.2\n    Pass timestamp down to history lines\n    Timestamp gets updated everytime you inspect an image\n    bud.bats: use absolute paths in newly-added tests\n    contrib/cirrus/lib.sh: don't use CN for the hostname\n    tests: Add some tests\n    Update `manifest add` man page\n    Extend flags of `manifest add`\n    build(deps): bump github.com/containers/storage from 1.23.3 to 1.23.4\n    build(deps): bump github.com/onsi/ginkgo from 1.14.0 to 1.14.1\n    Bump to v1.17.0-dev\n    CI: expand cross-compile checks\n\n## v1.16.0 (2020-09-03)\n    fix build on 32bit arches\n    containerImageRef.NewImageSource(): don't always force timestamps\n    Add fuse module warning to image readme\n    Heed our retry delay option values when retrying commit/pull/push\n    Switch to containers/common for seccomp\n    Use --timestamp rather then --omit-timestamp\n    docs: remove outdated notice\n    docs: remove outdated notice\n    build-using-dockerfile: add a hidden --log-rusage flag\n    build(deps): bump github.com/containers/image/v5 from 5.5.1 to 5.5.2\n    Discard ReportWriter if user sets options.Quiet\n    build(deps): bump github.com/containers/common from 0.19.0 to 0.20.3\n    Fix ownership of content copied using COPY --from\n    newTarDigester: zero out timestamps in tar headers\n    Update nix pin with `make nixpkgs`\n    bud.bats: correct .dockerignore integration tests\n    Use pipes for copying\n    run: include stdout in error message\n    run: use the correct error for errors.Wrapf\n    copier: un-export internal types\n    copier: add Mkdir()\n    in_podman: don't get tripped up by $CIRRUS_CHANGE_TITLE\n    docs/buildah-commit.md: tweak some wording, add a --rm example\n    imagebuildah: don’t blank out destination names when COPYing\n    Replace retry functions with common/pkg/retry\n    StageExecutor.historyMatches: compare timestamps using .Equal\n    Update vendor of containers/common\n    Fix errors found in coverity scan\n    Change namespace handling flags to better match podman commands\n    conformance testing: ignore buildah.BuilderIdentityAnnotation labels\n    Vendor in containers/storage v1.23.0\n    Add buildah.IsContainer interface\n    Avoid feeding run_buildah to pipe\n    fix(buildahimage): add xz dependency in buildah image\n    Bump github.com/containers/common from 0.15.2 to 0.18.0\n    Howto for rootless image building from OpenShift\n    Add --omit-timestamp flag to buildah bud\n    Update nix pin with `make nixpkgs`\n    Shutdown storage on failures\n    Handle COPY --from when an argument is used\n    Bump github.com/seccomp/containers-golang from 0.5.0 to 0.6.0\n    Cirrus: Use newly built VM images\n    Bump github.com/opencontainers/runc from 1.0.0-rc91 to 1.0.0-rc92\n    Enhance the .dockerignore man pages\n    conformance: add a test for COPY from subdirectory\n    fix  bug manifest inspct\n    Add documentation for .dockerignore\n    Add BuilderIdentityAnnotation to identify buildah version\n    DOC: Add quay.io/containers/buildah image to README.md\n    Update buildahimages readme\n    fix spelling mistake in \"info\" command result display\n    Don't bind /etc/host and /etc/resolv.conf if network is not present\n    blobcache: avoid an unnecessary NewImage()\n    Build static binary with `buildGoModule`\n    copier: split StripSetidBits into StripSetuidBit/StripSetgidBit/StripStickyBit\n    tarFilterer: handle multiple archives\n    Fix a race we hit during conformance tests\n    Rework conformance testing\n    Update 02-registries-repositories.md\n    test-unit: invoke cmd/buildah tests with --flags\n    parse: fix a type mismatch in a test\n    Fix compilation of tests/testreport/testreport\n    build.sh: log the version of Go that we're using\n    test-unit: increase the test timeout to 40/45 minutes\n    Add the \"copier\" package\n    Fix & add notes regarding problematic language in codebase\n    Add dependency on github.com/stretchr/testify/require\n    CompositeDigester: add the ability to filter tar streams\n    BATS tests: make more robust\n    vendor golang.org/x/text@v0.3.3\n    Switch golang 1.12 to golang 1.13\n    imagebuildah: wait for stages that might not have even started yet\n    chroot, run: not fail on bind mounts from /sys\n    chroot: do not use setgroups if it is blocked\n    Set engine env from containers.conf\n    imagebuildah: return the right stage's image as the \"final\" image\n    Fix a help string\n    Deduplicate environment variables\n    switch containers/libpod to containers/podman\n    Bump github.com/containers/ocicrypt from 1.0.2 to 1.0.3\n    Bump github.com/opencontainers/selinux from 1.5.2 to 1.6.0\n    Mask out /sys/dev to prevent information leak\n    linux: skip errors from the runtime kill\n    Mask over the /sys/fs/selinux in mask branch\n    Add VFS additional image store to container\n    tests: add auth tests\n    Allow \"readonly\" as alias to \"ro\" in mount options\n    Ignore OS X specific consistency mount option\n    Bump github.com/onsi/ginkgo from 1.13.0 to 1.14.0\n    Bump github.com/containers/common from 0.14.0 to 0.15.2\n    Rootless Buildah should default to IsolationOCIRootless\n    imagebuildah: fix inheriting multi-stage builds\n    Make imagebuildah.BuildOptions.Architecture/OS optional\n    Make imagebuildah.BuildOptions.Jobs optional\n    Resolve a possible race in imagebuildah.Executor.startStage()\n    Switch scripts to use containers.conf\n    Bump openshift/imagebuilder to v1.1.6\n    Bump go.etcd.io/bbolt from 1.3.4 to 1.3.5\n    buildah, bud: support --jobs=N for parallel execution\n    executor: refactor build code inside new function\n    Add bud regression tests\n    Cirrus: Fix missing htpasswd in registry img\n    docs: clarify the 'triples' format\n    CHANGELOG.md: Fix markdown formatting\n    Add nix derivation for static builds\n    Bump to v1.16.0-dev\n    version centos7 for compatible\n\n## v1.15.0 (2020-06-17)\n    Bump github.com/containers/common from 0.12.0 to 0.13.1\n    Bump github.com/containers/storage from 1.20.1 to 1.20.2\n    Bump github.com/seccomp/containers-golang from 0.4.1 to 0.5.0\n    Bump github.com/stretchr/testify from 1.6.0 to 1.6.1\n    Bump github.com/opencontainers/runc from 1.0.0-rc9 to 1.0.0-rc90\n    Add CVE-2020-10696 to CHANGELOG.md and changelog.txt\n    Bump github.com/stretchr/testify from 1.5.1 to 1.6.0\n    Bump github.com/onsi/ginkgo from 1.12.2 to 1.12.3\n    Vendor in containers/common v0.12.0\n    fix lighttpd example\n    Vendor in new go.etcd.io/bbolt\n    Bump github.com/onsi/ginkgo from 1.12.1 to 1.12.2\n    Bump imagebuilder for ARG fix\n    Bump github.com/containers/common from 0.11.2 to 0.11.4\n    remove dependency on openshift struct\n    Warn on unset build arguments\n    vendor: update seccomp/containers-golang to v0.4.1\n    Ammended docs\n    Updated docs\n    clean up comments\n    update exit code for tests\n    Implement commit for encryption\n    implementation of encrypt/decrypt push/pull/bud/from\n    fix resolve docker image name as transport\n    Bump github.com/opencontainers/go-digest from 1.0.0-rc1 to 1.0.0\n    Bump github.com/onsi/ginkgo from 1.12.0 to 1.12.1\n    Bump github.com/containers/storage from 1.19.1 to 1.19.2\n    Bump github.com/containers/image/v5 from 5.4.3 to 5.4.4\n    Add preliminary profiling support to the CLI\n    Bump github.com/containers/common from 0.10.0 to 0.11.2\n    Evaluate symlinks in build context directory\n    fix error info about get signatures for containerImageSource\n    Add Security Policy\n    Cirrus: Fixes from review feedback\n    Bump github.com/containers/storage from 1.19.0 to 1.19.1\n    Bump github.com/sirupsen/logrus from 1.5.0 to 1.6.0\n    imagebuildah: stages shouldn't count as their base images\n    Update containers/common v0.10.0\n    Bump github.com/fsouza/go-dockerclient from 1.6.4 to 1.6.5\n    Add registry to buildahimage Dockerfiles\n    Cirrus: Use pre-installed VM packages + F32\n    Cirrus: Re-enable all distro versions\n    Cirrus: Update to F31 + Use cache images\n    golangci-lint: Disable gosimple\n    Lower number of golangci-lint threads\n    Fix permissions on containers.conf\n    Don't force tests to use runc\n    Bump github.com/containers/common from 0.9.1 to 0.9.5\n    Return exit code from failed containers\n    Bump github.com/containers/storage from 1.18.2 to 1.19.0\n    Bump github.com/containers/common from 0.9.0 to 0.9.1\n    cgroup_manager should be under [engine]\n    Use c/common/pkg/auth in login/logout\n    Cirrus: Temporarily disable Ubuntu 19 testing\n    Add containers.conf to stablebyhand build\n    Update gitignore to exclude test Dockerfiles\n    Bump github.com/fsouza/go-dockerclient from 1.6.3 to 1.6.4\n    Bump github.com/containers/common from 0.8.1 to 0.9.0\n    Bump back to v1.15.0-dev\n    Remove warning for systemd inside of container\n\n## v1.14.8 (2020-04-09)\n    Run (make vendor)\n    Run (make -C tests/tools vendor)\n    Run (go mod tidy) before (go mod vendor) again\n    Fix (make vendor)\n    Bump validation\n    Bump back to v1.15.0-dev\n\n## v1.14.7 (2020-04-07)\n    Bump github.com/containers/image/v5 from 5.3.1 to 5.4.3\n    make vendor: run `tidy` after `vendor`\n    Do not skip the directory when the ignore pattern matches\n    Bump github.com/containers/common from 0.7.0 to 0.8.1\n    Downgrade siruspen/logrus from 1.4.2\n    Fix errorf conventions\n    dockerignore tests : remove symlinks, rework\n    Bump back to v1.15.0-dev\n\n## v1.14.6 (2020-04-02)\n    bud.bats - cleanup, refactoring\n    vendor in latest containers/storage 1.18.0 and containers/common v0.7.0\n    Bump github.com/spf13/cobra from 0.0.6 to 0.0.7\n    Bump github.com/containers/storage from 1.16.5 to 1.17.0\n    Bump github.com/containers/image/v5 from 5.2.1 to 5.3.1\n    Fix Amazon install step\n    Bump back to v1.15.0-dev\n    Fix bud-build-arg-cache test\n    Make image history work correctly with new args handling\n    Don't add args to the RUN environment from the Builder\n    Update github.com/openshift/imagebuilder to v1.1.4\n    Add .swp files to .gitignore\n\n## v1.14.5 (2020-03-26)\n    revert #2246 FIPS mode change\n    Bump back to v1.15.0-dev\n    image with dup layers: we now have one on quay\n    digest test : make more robust\n\n## v1.14.4 (2020-03-25)\n    Fix fips-mode check for RHEL8 boxes\n    Fix potential CVE in tarfile w/ symlink (Edit 02-Jun-2020: Addresses CVE-2020-10696)\n    Fix .dockerignore with globs and ! commands\n    update install steps for Amazon Linux 2\n    Bump github.com/openshift/imagebuilder from 1.1.2 to 1.1.3\n    Add comment for RUN command in volume ownership test\n    Run stat command directly for volume ownership test\n    vendor in containers/common v0.6.1\n    Cleanup go.sum\n    Bump back to v1.15.0-dev\n\n## v1.14.3 (2020-03-17)\n    Update containers/storage to v1.16.5\n    Bump github.com/containers/storage from 1.16.2 to 1.16.4\n    Bump github.com/openshift/imagebuilder from 1.1.1 to 1.1.2\n    Update github.com/openshift/imagebuilder vendoring\n    Update unshare man page to fix script example\n    Fix compilation errors on non linux platforms\n    Bump containers/common and opencontainers/selinux versions\n    Add tests for volume ownership\n    Preserve volume uid and gid through subsequent commands\n    Fix FORWARD_NULL errors found by Coverity\n    Bump github.com/containers/storage from 1.16.1 to 1.16.2\n    Fix errors found by codespell\n    Bump back to v1.15.0-dev\n    Add Pull Request Template\n\n## v1.14.2 (2020-03-03)\n    Add Buildah pull request template\n    Bump to containers/storage v1.16.1\n    run_linux: fix tight loop if file is not pollable\n    Bump github.com/opencontainers/selinux from 1.3.2 to 1.3.3\n    Bump github.com/containers/common from 0.4.1 to 0.4.2\n    Bump back to v1.15.0-dev\n    Add Containerfile to build a versioned stable image on quay.io\n\n## v1.14.1 (2020-02-27)\n    Search for local runtime per values in containers.conf\n    Set correct ownership on working directory\n    BATS : in teardown, umount stale mounts\n    Bump github.com/spf13/cobra from 0.0.5 to 0.0.6\n    Bump github.com/fsouza/go-dockerclient from 1.6.1 to 1.6.3\n    Bump github.com/stretchr/testify from 1.4.0 to 1.5.1\n    Replace unix with syscall to allow vendoring into libpod\n    Update to containers/common v0.4.1\n    Improve remote manifest retrieval\n    Fix minor spelling errors in containertools README\n    Clear the right variable in buildahimage\n    Correct a couple of incorrect format specifiers\n    Update to containers/common v0.3.0\n    manifest push --format: force an image type, not a list type\n    run: adjust the order in which elements are added to $PATH\n    getDateAndDigestAndSize(): handle creation time not being set\n    Bump github.com/containers/common from 0.2.0 to 0.2.1\n    include installation steps for CentOS 8 and Stream\n    include installation steps for CentOS7 and forks\n    Adjust Ubuntu install info to also work on Pop!_OS\n    Make the commit id clear like Docker\n    Show error on copied file above context directory in build\n    Bump github.com/containers/image/v5 from 5.2.0 to 5.2.1\n    pull/from/commit/push: retry on most failures\n    Makefile: fix install.cni.sudo\n    Repair buildah so it can use containers.conf on the server side\n    Bump github.com/mattn/go-shellwords from 1.0.9 to 1.0.10\n    Bump github.com/fsouza/go-dockerclient from 1.6.0 to 1.6.1\n    Fixing formatting & build instructions\n    Add Code of Conduct\n    Bors: Fix no. req. github reviews\n    Cirrus+Bors: Simplify temp branch skipping\n    Bors-ng: Add documentation and status-icon\n    Bump github.com/onsi/ginkgo from 1.11.0 to 1.12.0\n    fix XDG_RUNTIME_DIR for authfile\n    Cirrus: Disable F29 testing\n    Cirrus: Add jq package\n    Cirrus: Fix lint + validation using wrong epoch\n    Stop using fedorproject registry\n    Bors: Workaround ineffective required statuses\n    Bors: Enable app + Disable Travis\n    Cirrus: Add standardized log-collection\n    Cirrus: Improve automated lint + validation\n    Allow passing options to golangci-lint\n    Cirrus: Fixes from review feedback\n    Cirrus: Temporarily ignore VM testing failures\n    Cirrus: Migrate off papr + implement VM testing\n    Cirrus: Update packages + fixes for get_ci_vm.sh\n    Show validation command-line\n    Skip overlay test w/ vfs driver\n    use alpine, not centos, for various tests\n    Flake handling: cache and prefetch images\n    Bump to v1.15.0-dev\n\n## v1.14.0 (2020-02-05)\n    bump github.com/mtrmac/gpgme\n    Update containers/common to v0.1.4\n    manifest push: add --format option\n    Bump github.com/onsi/gomega from 1.8.1 to 1.9.0\n    vendor github.com/containers/image/v5@v5.2.0\n    info test: deal with random key order\n    Bump back to v1.14.0-dev\n\n## v1.13.2 (2020-01-29)\n    sign.bats: set GPG_TTY=/dev/null\n    Fix parse_unsupported.go\n    getDateAndDigestAndSize(): use manifest.Digest\n    Bump github.com/opencontainers/selinux from 1.3.0 to 1.3.1\n    Bump github.com/containers/common from 0.1.0 to 0.1.2\n    Touch up os/arch doc\n    chroot: handle slightly broken seccomp defaults\n    buildahimage: specify fuse-overlayfs mount options\n    Bump github.com/mattn/go-shellwords from 1.0.7 to 1.0.9\n    copy.bats: make sure we detect failures due to missing source\n    parse: don't complain about not being able to rename something to itself\n    Makefile: use a $(GO_TEST) macro, fix a typo\n    manifests: unit test fix\n    Fix build for 32bit platforms\n    Allow users to set OS and architecture on bud\n    Fix COPY in containerfile with envvar\n    Bump c/storage to v1.15.7\n    add --sign-by to bud/commit/push, --remove-signatures for pull/push\n    Remove cut/paste error in CHANGELOG.md\n    Update vendor of containers/common to v0.1.0\n    update install instructions for Debian, Raspbian and Ubuntu\n    Add support for containers.conf\n    Bump back to v1.14.0-dev\n\n## v1.13.1 (2020-01-14)\n    Bump github.com/containers/common from 0.0.5 to 0.0.7\n    Bump github.com/onsi/ginkgo from 1.10.3 to 1.11.0\n    Bump github.com/pkg/errors from 0.8.1 to 0.9.0\n    Bump github.com/onsi/gomega from 1.7.1 to 1.8.1\n    Add codespell support\n    copyFileWithTar: close source files at the right time\n    copy: don't digest files that we ignore\n    Check for .dockerignore specifically\n    Travis: rm go 1.12.x\n    Don't setup excludes, if their is only one pattern to match\n    set HOME env to /root on chroot-isolation by default\n    docs: fix references to containers-*.5\n    update openshift/api\n    fix bug Add check .dockerignore COPY file\n    buildah bud --volume: run from tmpdir, not source dir\n    Fix imageNamePrefix to give consistent names in buildah-from\n    cpp: use -traditional and -undef flags\n    Fix image reference in tutorial 4\n    discard outputs coming from onbuild command on buildah-from --quiet\n    make --format columnizing consistent with buildah images\n    Bump to v1.14.0-dev\n\n## v1.13.0 (2019-12-27)\n    Bump to c/storage v1.15.5\n    Update container/storage to v1.15.4\n    Fix option handling for volumes in build\n    Rework overlay pkg for use with libpod\n    Fix buildahimage builds for buildah\n    Add support for FIPS-Mode backends\n    Set the TMPDIR for pulling/pushing image to $TMPDIR\n    WIP: safer test for pull --all-tags\n    BATS major cleanup: blobcache.bats: refactor\n    BATS major cleanup: part 4: manual stuff\n    BATS major cleanup, step 3: yet more run_buildah\n    BATS major cleanup, part 2: use more run_buildah\n    BATS major cleanup, part 1: log-level\n    Bump github.com/containers/image/v5 from 5.0.0 to 5.1.0\n    Bump github.com/containers/common from 0.0.3 to 0.0.5\n    Bump to v1.13.0-dev\n\n## v1.12.0 (2019-12-13)\n    Allow ADD to use http src\n    Bump to c/storage v.1.15.3\n    install.md: update golang dependency\n    imgtype: reset storage opts if driver overridden\n    Start using containers/common\n    overlay.bats typo: fuse-overlays should be fuse-overlayfs\n    chroot: Unmount with MNT_DETACH instead of UnmountMountpoints()\n    bind: don't complain about missing mountpoints\n    imgtype: check earlier for expected manifest type\n    Vendor containers/storage fix\n    Vendor containers/storage v1.15.1\n    Add history names support\n    PR takeover of #1966\n    Tests: Add inspect test check steps\n    Tests: Add container name and id check in containers test steps\n    Test: Get permission in add test\n    Tests: Add a test for tag by id\n    Tests: Add test cases for push test\n    Tests: Add image digest test\n    Tests: Add some buildah from tests\n    Tests: Add two commit test\n    Tests: Add buildah bud with --quiet test\n    Tests: Add two test for buildah add\n    Bump back to v1.12.0-dev\n\n## v1.11.6 (2019-12-03)\n    Handle missing equal sign in --from and --chown flags for COPY/ADD\n    bud COPY does not download URL\n    Bump github.com/onsi/gomega from 1.7.0 to 1.7.1\n    Fix .dockerignore exclude regression\n    Ran buildah through codespell\n    commit(docker): always set ContainerID and ContainerConfig\n    Touch up commit man page image parameter\n    Add builder identity annotations.\n    info: use util.Runtime()\n    Bump github.com/onsi/ginkgo from 1.10.2 to 1.10.3\n    Bump back to v1.12.0-dev\n\n## v1.11.5 (2019-11-11)\n    Enhance error on unsafe symbolic link targets\n    Add OCIRuntime to info\n    Check nonexsit authfile\n    Only output image id if running buildah bud --quiet\n    Fix --pull=true||false and add --pull-never to bud and from (retry)\n    cgroups v2: tweak or skip tests\n    Prepwork: new 'skip' helpers for tests\n    Handle configuration blobs for manifest lists\n    unmarshalConvertedConfig: avoid using the updated image's ref\n    Add completions for Manifest commands\n    Add disableFips option to secrets pkg\n    Update bud.bats test archive test\n    Add test for caching based on content digest\n    Builder.untarPath(): always evaluate b.ContentDigester.Hash()\n    Bump github.com/onsi/ginkgo from 1.10.1 to 1.10.2\n    Fix another broken test: copy-url-mtime\n    yet more fixes\n    Actual bug fix for 'add' test: fix the expected mode\n    BATS tests - lots of mostly minor cleanup\n    build: drop support for ostree\n    Add support for make vendor-in-container\n    imgtype: exit with error if storage fails\n    remove XDG_RUNTIME_DIR from default authfile path\n    fix troubleshooting redirect instructions\n    Bump back to v1.12.0-dev\n\n## v1.11.4 (2019-10-28)\n    buildah: add a \"manifest\" command\n    manifests: add the module\n    pkg/supplemented: add a package for grouping images together\n    pkg/manifests: add a manifest list build/manipulation API\n    Update for ErrUnauthorizedForCredentials API change in containers/image\n    Update for manifest-lists API changes in containers/image\n    version: also note the version of containers/image\n    Move to containers/image v5.0.0\n    Enable --device directory as src device\n    Fix git build with branch specified\n    Bump github.com/openshift/imagebuilder from 1.1.0 to 1.1.1\n    Bump github.com/fsouza/go-dockerclient from 1.4.4 to 1.5.0\n    Add clarification to the Tutorial for new users\n    Silence \"using cache\" to ensure -q is fully quiet\n    Add OWNERS File to Buildah\n    Bump github.com/containers/storage from 1.13.4 to 1.13.5\n    Move runtime flag to bud from common\n    Commit: check for storage.ErrImageUnknown using errors.Cause()\n    Fix crash when invalid COPY --from flag is specified.\n    Bump back to v1.12.0-dev\n\n## v1.11.3 (2019-10-04)\n    Update c/image to v4.0.1\n    Bump github.com/spf13/pflag from 1.0.3 to 1.0.5\n    Fix --build-args handling\n    Bump github.com/spf13/cobra from 0.0.3 to 0.0.5\n    Bump github.com/cyphar/filepath-securejoin from 0.2.1 to 0.2.2\n    Bump github.com/onsi/ginkgo from 1.8.0 to 1.10.1\n    Bump github.com/fsouza/go-dockerclient from 1.3.0 to 1.4.4\n    Add support for retrieving context from stdin \"-\"\n    Ensure bud remote context cleans up on error\n    info: add cgroups2\n    Bump github.com/seccomp/libseccomp-golang from 0.9.0 to 0.9.1\n    Bump github.com/mattn/go-shellwords from 1.0.5 to 1.0.6\n    Bump github.com/stretchr/testify from 1.3.0 to 1.4.0\n    Bump github.com/opencontainers/selinux from 1.2.2 to 1.3.0\n    Bump github.com/etcd-io/bbolt from 1.3.2 to 1.3.3\n    Bump github.com/onsi/gomega from 1.5.0 to 1.7.0\n    update c/storage to v1.13.4\n    Print build 'STEP' line to stdout, not stderr\n    Fix travis-ci on forks\n    Vendor c/storage v1.13.3\n    Use Containerfile by default\n    Added tutorial on how to include Buildah as library\n    util/util: Fix \"configuraitno\" -> \"configuration\" log typo\n    Bump back to v1.12.0-dev\n\n## v1.11.2 (2019-09-13)\n    Add some cleanup code\n    Move devices code to unit specific directory.\n    Bump back to v1.12.0-dev\n\n## v1.11.1 (2019-09-11)\n    Add --devices flag to bud and from\n    Downgrade .papr to highest atomic verion\n    Add support for /run/.containerenv\n    Truncate output of too long image names\n    Preserve file and directory mount permissions\n    Bump fedora version from 28 to 30\n    makeImageRef: ignore EmptyLayer if Squash is set\n    Set TMPDIR to /var/tmp by default\n    replace --debug=false with --log-level=error\n    Allow mounts.conf entries for equal source and destination paths\n    fix label and annotation for 1-line Dockerfiles\n    Enable interfacer linter and fix lints\n    install.md: mention goproxy\n    Makefile: use go proxy\n    Bump to v1.12.0-dev\n\n## v1.11.0 (2019-08-29)\n    tests/bud.bats: add --signature-policy to some tests\n    Vendor github.com/openshift/api\n    pull/commit/push: pay attention to $BUILD_REGISTRY_SOURCES\n    Add `--log-level` command line option and deprecate `--debug`\n    add support for cgroupsV2\n    Correctly detect ExitError values from Run()\n    Disable empty logrus timestamps to reduce logger noise\n    Remove outdated deps Makefile target\n    Remove gofmt.sh in favor of golangci-lint\n    Remove govet.sh in favor of golangci-lint\n    Allow to override build date with SOURCE_DATE_EPOCH\n    Update shebangs to take env into consideration\n    Fix directory pull image names\n    Add --digestfile and Re-add push statement as debug\n    README: mention that Podman uses Buildah's API\n    Use content digests in ADD/COPY history entries\n    add: add a DryRun flag to AddAndCopyOptions\n    Fix possible runtime panic on bud\n    Add security-related volume options to validator\n    use correct path for ginkgo\n    Add bud 'without arguments' integration tests\n    Update documentation about bud\n    add: handle hard links when copying with .dockerignore\n    add: teach copyFileWithTar() about symlinks and directories\n    Allow buildah bud to be called without arguments\n    imagebuilder: fix detection of referenced stage roots\n    Touch up go mod instructions in install\n    run_linux: fix mounting /sys in a userns\n    Vendor Storage v1.13.2\n    Cirrus: Update VM images\n    Fix handling of /dev/null masked devices\n    Update `bud`/`from` help to contain indicator for `--dns=none`\n    Bump back to v1.11.0-dev\n\n## v1.10.1 (2019-08-08)\n    Bump containers/image to v3.0.2 to fix keyring issue\n    Bug fix for volume minus syntax\n    Bump container/storage v1.13.1 and containers/image v3.0.1\n    bump github.com/containernetworking/cni to v0.7.1\n    Add overlayfs to fuse-overlayfs tip\n    Add automatic apparmor tag discovery\n    Fix bug whereby --get-login has no effect\n    Bump to v1.11.0-dev\n\n## v1.10.0 (2019-08-02)\n    vendor github.com/containers/image@v3.0.0\n    Remove GO111MODULE in favor of `-mod=vendor`\n    Vendor in containers/storage v1.12.16\n    Add '-' minus syntax for removal of config values\n    tests: enable overlay tests for rootless\n    rootless, overlay: use fuse-overlayfs\n    vendor github.com/containers/image@v2.0.1\n    Added '-' syntax to remove volume config option\n    delete `successfully pushed` message\n    Add golint linter and apply fixes\n    vendor github.com/containers/storage@v1.12.15\n    Change wait to sleep in buildahimage readme\n    Handle ReadOnly images when deleting images\n    Add support for listing read/only images\n\n## v1.9.2 (2019-07-19)\n    from/import: record the base image's digest, if it has one\n    Fix CNI version retrieval to not require network connection\n    Add misspell linter and apply fixes\n    Add goimports linter and apply fixes\n    Add stylecheck linter and apply fixes\n    Add unconvert linter and apply fixes\n    image: make sure we don't try to use zstd compression\n    run.bats: skip the \"z\" flag when testing --mount\n    Update to runc v1.0.0-rc8\n    Update to match updated runtime-tools API\n    bump github.com/opencontainers/runtime-tools to v0.9.0\n    Build e2e tests using the proper build tags\n    Add unparam linter and apply fixes\n    Run: correct a typo in the --cap-add help text\n    unshare: add a --mount flag\n    fix push check image name is not empty\n    Bump to v1.9.2-dev\n\n## v1.9.1 (2019-07-12)\n    add: fix slow copy with no excludes\n    Add errcheck linter and fix missing error check\n    Improve tests/tools/Makefile parallelism and abstraction\n    Fix response body not closed resource leak\n    Switch to golangci-lint\n    Add gomod instructions and mailing list links\n    On Masked path, check if /dev/null already mounted before mounting\n    Update to containers/storage v1.12.13\n    Refactor code in package imagebuildah\n    Add rootless podman with NFS issue in documentation\n    Add --mount  for buildah run\n    import method ValidateVolumeOpts from libpod\n    Fix typo\n    Makefile: set GO111MODULE=off\n    rootless: add the built-in slirp DNS server\n    Update docker/libnetwork to get rid of outdated sctp package\n    Update buildah-login.md\n    migrate to go modules\n    install.md: mention go modules\n    tests/tools: go module for test binaries\n    fix --volume splits comma delimited option\n    Add bud test for RUN with a priv'd command\n    vendor logrus v1.4.2\n    pkg/cli: panic when flags can't be hidden\n    pkg/unshare: check all errors\n    pull: check error during report write\n    run_linux.go: ignore unchecked errors\n    conformance test: catch copy error\n    chroot/run_test.go: export funcs to actually be executed\n    tests/imgtype: ignore error when shutting down the store\n    testreport: check json error\n    bind/util.go: remove unused func\n    rm chroot/util.go\n    imagebuildah: remove unused `dedupeStringSlice`\n    StageExecutor: EnsureContainerPath: catch error from SecureJoin()\n    imagebuildah/build.go: return <expr> instead of branching\n    rmi: avoid redundant branching\n    conformance tests: nilness: allocate map\n    imagebuildah/build.go: avoid redundant `filepath.Join()`\n    imagebuildah/build.go: avoid redundant `os.Stat()`\n    imagebuildah: omit comparison to bool\n    fix \"ineffectual assignment\" lint errors\n    docker: ignore \"repeats json tag\" lint error\n    pkg/unshare: use `...` instead of iterating a slice\n    conformance: bud test: use raw strings for regexes\n    conformance suite: remove unused func/var\n    buildah test suite: remove unused vars/funcs\n    testreport: fix golangci-lint errors\n    util: remove redundant `return` statement\n    chroot: only log clean-up errors\n    images_test: ignore golangci-lint error\n    blobcache: log error when draining the pipe\n    imagebuildah: check errors in deferred calls\n    chroot: fix error handling in deferred funcs\n    cmd: check all errors\n    chroot/run_test.go: check errors\n    chroot/run.go: check errors in deferred calls\n    imagebuildah.Executor: remove unused onbuild field\n    docker/types.go: remove unused struct fields\n    util: use strings.ContainsRune instead of index check\n    Cirrus: Initial implementation\n    Bump to v1.9.1-dev\n\n## v1.9.0 (2019-06-15)\n    buildah-run: fix-out-of-range panic (2)\n    Bump back to v1.9.0-dev\n\n\n\n## v1.8.4 (2019-06-13)\n    Update containers/image to v2.0.0\n    run: fix hang with run and --isolation=chroot\n    run: fix hang when using run\n    chroot: drop unused function call\n    remove --> before imgageID on build\n    Always close stdin pipe\n    Write deny to setgroups when doing single user mapping\n    Avoid including linux/memfd.h\n    Add a test for the symlink pointing to a directory\n    Add missing continue\n    Fix the handling of symlinks to absolute paths\n    Only set default network sysctls if not rootless\n    Support --dns=none like podman\n    fix bug --cpu-shares parsing typo\n    Fix validate complaint\n    Update vendor on containers/storage to v1.12.10\n    Create directory paths for COPY thereby ensuring correct perms\n    imagebuildah: use a stable sort for comparing build args\n    imagebuildah: tighten up cache checking\n    bud.bats: add a test verying the order of --build-args\n    add -t to podman run\n    imagebuildah: simplify screening by top layers\n    imagebuildah: handle ID mappings for COPY --from\n    imagebuildah: apply additionalTags ourselves\n    bud.bats: test additional tags with cached images\n    bud.bats: add a test for WORKDIR and COPY with absolute destinations\n    Cleanup Overlay Mounts content\n\n## v1.8.3 (2019-06-04)\n    Add support for file secret mounts\n    Add ability to skip secrets in mounts file\n    allow 32bit builds\n    fix tutorial instructions\n    imagebuilder: pass the right contextDir to Add()\n    add: use fileutils.PatternMatcher for .dockerignore\n    bud.bats: add another .dockerignore test\n    unshare: fallback to single usermapping\n    addHelperSymlink: clear the destination on os.IsExist errors\n    bud.bats: test replacing symbolic links\n    imagebuildah: fix handling of destinations that end with '/'\n    bud.bats: test COPY with a final \"/\" in the destination\n    linux: add check for sysctl before using it\n    unshare: set _CONTAINERS_ROOTLESS_GID\n    Rework buildahimamges\n    build context: support https git repos\n    Add a test for ENV special chars behaviour\n    Check in new Dockerfiles\n    Apply custom SHELL during build time\n    config: expand variables only at the command line\n    SetEnv: we only need to expand v once\n    Add default /root if empty on chroot iso\n    Add support for Overlay volumes into the container.\n    Export buildah validate volume functions so it can share code with libpod\n    Bump baseline test to F30\n    Fix rootless handling of /dev/shm size\n    Avoid fmt.Printf() in the library\n    imagebuildah: tighten cache checking back up\n    Handle WORKDIR with dangling target\n    Default Authfile to proper path\n    Make buildah run --isolation follow BUILDAH_ISOLATION environment\n    Vendor in latest containers/storage and containers/image\n    getParent/getChildren: handle layerless images\n    imagebuildah: recognize cache images for layerless images\n    bud.bats: test scratch images with --layers caching\n    Get CHANGELOG.md updates\n    Add some symlinks to test our .dockerignore logic\n    imagebuildah: addHelper: handle symbolic links\n    commit/push: use an everything-allowed policy\n    Correct manpage formatting in files section\n    Remove must be root statement from buildah doc\n    Change image names to stable, testing and upstream\n    Bump back to v1.9.0-dev\n\n## v1.8.2 (2019-05-02)\n    Vendor Storage 1.12.6\n    Create scratch file in TESTDIR\n    Test bud-copy-dot with --layers picks up changed file\n    Bump back to 1.9.0-dev\n\n## v1.8.1 (2019-05-01)\n    Don't create directory on container\n    Replace kubernetes/pause in tests with k8s.gcr.io/pause\n    imagebuildah: don't remove intermediate images if we need them\n    Rework buildahimagegit to buildahimageupstream\n    Fix Transient Mounts\n    Handle WORKDIRs that are symlinks\n    allow podman to build a client for windows\n    Touch up 1.9-dev to 1.9.0-dev\n    Bump to 1.9-dev\n\n## v1.8.0 (2019-04-26)\n    Resolve symlink when checking container path\n    commit: commit on every instruction, but not always with layers\n    CommitOptions: drop the unused OnBuild field\n    makeImageRef: pass in the whole CommitOptions structure\n    cmd: API cleanup: stores before images\n    run: check if SELinux is enabled\n    Fix buildahimages Dockerfiles to include support for additionalimages mounted from host.\n    Detect changes in rootdir\n    Fix typo in buildah-pull(1)\n    Vendor in latest containers/storage\n    Keep track of any build-args used during buildah bud --layers\n    commit: always set a parent ID\n    imagebuildah: rework unused-argument detection\n    fix bug dest path when COPY .dockerignore\n    Move Host IDMAppings code from util to unshare\n    Add BUILDAH_ISOLATION rootless back\n    Travis CI: fail fast, upon error in any step\n    imagebuildah: only commit images for intermediate stages if we have to\n    Use errors.Cause() when checking for IsNotExist errors\n    auto pass http_proxy to container\n    Bump back to 1.8-dev\n\n## v1.7.3 (2019-04-16)\n    imagebuildah: don't leak image structs\n    Add Dockerfiles for buildahimages\n    Bump to Replace golang 1.10 with 1.12\n    add --dns* flags to buildah bud\n    Add hack/build_speed.sh test speeds on building container images\n    Create buildahimage Dockerfile for Quay\n    rename 'is' to 'expect_output'\n    squash.bats: test squashing in multi-layered builds\n    bud.bats: test COPY --from in a Dockerfile while using the cache\n    commit: make target image names optional\n    Fix bud-args to allow comma separation\n    oops, missed some tests in commit.bats\n    new helper: expect_line_count\n    New tests for #1467 (string slices in cmdline opts)\n    Workarounds for dealing with travis; review feedback\n    BATS tests - extensive but minor cleanup\n    imagebuildah: defer pulling images for COPY --from\n    imagebuildah: centralize COMMIT and image ID output\n    Travis: do not use traviswait\n    imagebuildah: only initialize imagebuilder configuration once per stage\n    Make cleaner error on Dockerfile build errors\n    unshare: move to pkg/\n    unshare: move some code from cmd/buildah/unshare\n    Fix handling of Slices versus Arrays\n    imagebuildah: reorganize stage and per-stage logic\n    imagebuildah: add empty layers for instructions\n    Add missing step in installing into Ubuntu\n    fix bug in .dockerignore support\n    imagebuildah: deduplicate prepended \"FROM\" instructions\n    Touch up intro\n    commit: set created-by to the shell if it isn't set\n    commit: check that we always set a \"created-by\"\n    docs/buildah.md: add \"containers-\" prefixes under \"SEE ALSO\"\n    Bump back to 1.8-dev\n\n## v1.7.2 (2019-03-28)\n    mount: do not create automatically a namespace\n    buildah: correctly create the userns if euid!=0\n    imagebuildah.Build: consolidate cleanup logic\n    CommitOptions: drop the redundant Store field\n    Move pkg/chrootuser from libpod to buildah.\n    imagebuildah: record image IDs and references more often\n    vendor imagebuilder v1.1.0\n    imagebuildah: fix requiresStart/noRunsRemaining confusion\n    imagebuildah: check for unused args across stages\n    bump github.com/containernetworking/cni to v0.7.0-rc2\n    imagebuildah: use \"useCache\" instead of \"noCache\"\n    imagebuildah.resolveNameToImageRef(): take name as a parameter\n    Export fields of the DokcerIgnore struct\n    imagebuildah: drop the duplicate containerIDs list\n    rootless: by default use the host network namespace\n    imagebuildah: split Executor and per-stage execution\n    imagebuildah: move some fields around\n    golint: make golint happy\n    docs: 01-intro.md: add missing . in Dockerfile examples\n    fix bug using .dockerignore\n    Do not create empty mounts.conf file\n    images: suppress a spurious blank line with no images\n    from: distinguish between ADD and COPY\n    fix bug to not separate each --label value with comma\n    buildah-bud.md: correct a typo, note a default\n    Remove mistaken code that got merged in other PR\n    add sample registries.conf to docs\n    escape shell variables in README example\n    slirp4netns: set mtu to 65520\n    images: imageReposToMap() already adds <none>:<none>\n    imagebuildah.ReposToMap: move to cmd\n    Build: resolve copyFrom references earlier\n    Allow rootless users to use the cache directory in homedir\n    bud.bats: use the per-test temp directory\n    bud.bats: log output before counting length\n    Simplify checks for leftover args\n    Print commitID with --layers\n    fix bug images use the template to print results\n    rootless: honor --net host\n    onsi/gomeage add missing files\n    vendor latest openshift/imagebuilder\n    Remove noop from squash help\n    Prepend a comment to files setup in container\n    imagebuildah resolveSymlink: fix handling of relative links\n    Errors should be printed to stderr\n    Add recommends for slirp4netns and fuse-overlay\n    Update pull and pull-always flags\n    Hide from users command options that we don't want them to use.\n    Update secrets fipsmode patch to work on rootless containers\n    fix unshare option handling and documentation\n    Vendor in latest containers/storage\n    Hard-code docker.Transport use in pull --all-tags\n    Use a types.ImageReference instead of (transport, name) strings in pullImage etc.\n    Move the computation of srcRef before first pullAndFindImage\n    Don't throw away user-specified tag for pull --all-tags\n    CHANGES BEHAVIOR: Remove the string format input to localImageNameForReference\n    Don't try to parse imageName as transport:image in pullImage\n    Use reference.WithTag instead of manual string manipulation in Pull\n    Don't pass image = transport:repo:tag, transport=transport to pullImage\n    Fix confusing variable naming in Pull\n    Don't try to parse image name as a transport:image\n    Fix error reporting when parsing trans+image\n    Remove 'transport == \"\"' handling from the pull path\n    Clean up \"pulls\" of local image IDs / ID prefixes\n    Simplify ExpandNames\n    Document the semantics of transport+name returned by ResolveName\n    UPdate gitvalidation epoch\n    Bump back to 1.8-dev\n\n## v1.7.1 (2019-02-26)\n    vendor containers/image v1.5\n    Move secrets code from libpod into buildah\n    Update CHANGELOG.md with the past changes\n    README.md: fix typo\n    Fix a few issues found by tests/validate/gometalinter.sh\n    Neutralize buildah/unshare on non-Linux platforms\n    Explicitly specify a directory to find(1)\n    README.md: rephrase Buildah description\n    Stop printing default twice in cli --help\n    install.md: add section about vendoring\n    Bump to 1.8-dev\n\n## v1.7 (2019-02-21)\n    vendor containers/image v1.4\n    Make \"images --all\" faster\n    Remove a misleading comment\n    Remove quiet option from pull options\n    Make sure buildah pull --all-tags only works with docker transport\n    Support oci layout format\n    Fix pulling of images within buildah\n    Fix tls-verify polarity\n    Travis: execute make vendor and hack/tree_status.sh\n    vendor.conf: remove unused dependencies\n    add missing vendor/github.com/containers/libpod/vendor.conf\n    vendor.conf: remove github.com/inconshreveable/mousetrap\n    make vendor: always fetch the latest vndr\n    add hack/tree_status.sh script\n    Bump c/Storage to 1.10\n    Add --all-tags test to pull\n    mount: make error clearer\n    Remove global flags from cli help\n    Set --disable-compression to true as documented\n    Help document using buildah mount in rootless mode\n    healthcheck start-period: update documentation\n    Vendor in latest c/storage and c/image\n    dumpbolt: handle nested buckets\n    Fix buildah commit compress by default\n    Test on xenial, not trusty\n    unshare: reexec using a memfd copy instead of the binary\n    Add --target to bud command\n    Fix example for setting multiple environment variables\n    main: fix rootless mode\n    buildah: force umask 022\n    pull.bats: specify registry config when using registries\n    pull.bats: use the temporary directory, not /tmp\n    unshare: do not set rootless mode if euid=0\n    Touch up cli help examples and a few nits\n    Add an undocumented dumpbolt command\n    Move tar commands into containers/storage\n    Fix bud issue with 2 line Dockerfile\n    Add package install descriptions\n    Note configuration file requirements\n    Replace urfave/cli with cobra\n    cleanup vendor.conf\n    Vendor in latest containers/storage\n    Add Quiet to PullOptions and PushOptions\n    cmd/commit: add flag omit-timestamp to allow for deterministic builds\n    Add options for empty-layer history entries\n    Make CLI help descriptions and usage a bit more consistent\n    vndr opencontainers/selinux\n    Bump baseline test Fedora to 29\n    Bump to v1.7-dev-1\n    Bump to v1.6-1\n    Add support for ADD --chown\n    imagebuildah: make EnsureContainerPath() check/create the right one\n    Bump 1.7-dev\n    Fix contrib/rpm/bulidah.spec changelog date\n\n## v1.6-1 (2019-01-18)\n    Add support for ADD --chown\n    imagebuildah: make EnsureContainerPath() check/create the right one\n    Fix contrib/rpm/bulidah.spec changelog date\n    Vendor in latest containers/storage\n    Revendor everything\n    Revendor in latest code by release\n    unshare: do not set USER=root\n    run: ignore EIO when flushing at the end, avoid double log\n    build-using-dockerfile,commit: disable compression by default\n    Update some comments\n    Make rootless work under no_pivot_root\n    Add CreatedAtRaw date field for use with Format\n    Properly format images JSON output\n    pull: add all-tags option\n    Fix support for multiple Short options\n    pkg/blobcache: add synchronization\n    Skip empty files in file check of conformance test\n    Use NoPivot also for RUN, not only for run\n    Remove no longer used isReferenceInsecure / isRegistryInsecure\n    Do not set OCIInsecureSkipTLSVerify based on registries.conf\n    Remove duplicate entries from images JSON output\n    vendor parallel-copy from containers/image\n    blobcache.bats: adjust explicit push tests\n    Handle one line Dockerfile with layers\n    We should only warn if user actually requests Hostname be set in image\n    Fix compiler Warning about comparing different size types\n    imagebuildah: don't walk if rootdir and path are equal\n    Add aliases for buildah containers, so buildah list, ls and ps work\n    vendor: use faster version instead compress/gzip\n    vendor: update libpod\n    Properly handle Hostname inside of RUN command\n    docs: mention how to mount in rootless mode\n    tests: use fully qualified name for centos image\n    travis.yml: use the fully qualified name for alpine\n    mount: allow mount only when using vfs\n    Add some tests for buildah pull\n    Touch up images -q processing\n    Refactor: Use library shared idtools.ParseIDMap() instead of bundling it\n    bump GITVALIDATE_EPOCH\n    cli.BudFlags: add `--platform` nop\n    Makefile: allow packagers to more easily add tags\n    Makefile: soften the requirement on git\n    tests: add containers json test\n    Inline blobCache.putBlob into blobCacheDestination.PutBlob\n    Move saveStream and putBlob near blobCacheDestination.PutBlob\n    Remove BlobCache.PutBlob\n    Update for API changes\n    Vendor c/image after merging c/image#536\n    Handle 'COPY --from' in Dockerfile\n    Vendor in latest content from github.com/containers/storage\n    Clarify docker.io default in push with docker-daemon\n    Test blob caching\n    Wire in a hidden --blob-cache option\n    Use a blob cache when we're asked to use one\n    Add --disable-compression to 'build-using-dockerfile'\n    Add a blob cache implementation\n    vendor: update containers/storage\n    Update for sysregistriesv2 API changes\n    Update containers/image to 63a1cbdc5e6537056695cf0d627c0a33b334df53\n    clean up makefile variables\n    Fix file permission\n    Complete the instructions for the command\n    Show warning when a build arg not used\n    Assume user 0 group 0, if /etc/passwd file in container.\n    Add buildah info command\n    Enable -q when --filter is used for images command\n    Add v1.5 Release Announcement\n    Fix dangling filter for images command\n    Fix completions to print Names as well as IDs\n    tests: Fix file permissions\n    Bump 1.6-dev\n\n## v1.5-1 (2018-11-21)\n    Bump min go to 1.10 in install.md\n    vendor: update ostree-go\n    Update docker build command line in conformance test\n    Print command in SystemExec as debug information\n    Add some skip word for inspect check in conformance test\n    Update regex for multi stage base test\n    Sort CLI flags\n    vendor: update containers/storage\n    Add note to install about non-root on RHEL/CentOS\n    Update imagebuild depdency to support heading ARGs in Dockerfile\n    rootless: do not specify --rootless to the OCI runtime\n    Export resolvesymlink function\n    Exclude --force-rm from common bud cli flags\n    run: bind mount /etc/hosts and /etc/resolv.conf if not in a volume\n    rootless: use slirp4netns to setup the network namespace\n    Instructions for completing the pull command\n    Fix travis to not run environment variable patch\n    rootless: only discard network configuration names\n    run: only set up /etc/hosts or /etc/resolv.conf with network\n    common: getFormat: match entire string not only the prefix\n    vendor: update libpod\n    Change validation EPOCH\n    Fixing broken link for container-registries.conf\n    Restore rootless isolation test for from volume ro test\n    ostree: fix tag for build constraint\n    Handle directories better in bud -f\n    vndr in latest containers/storage\n    Fix unshare gofmt issue\n    runSetupBuiltinVolumes(): break up volume setup\n    common: support a per-user registries conf file\n    unshare: do not override the configuration\n    common: honor the rootless configuration file\n    unshare: create a new mount namespace\n    unshare: support libpod rootless pkg\n    Use libpod GetDefaultStorage to report proper storage config\n    Allow container storage to manage the SELinux labels\n    Resolve image names with default transport in from command\n    run: When the value of isolation is set, use the set value instead of the default value.\n    Vendor in latest containers/storage and opencontainers/selinux\n    Remove no longer valid todo\n    Check for empty buildTime in version\n    Change gofmt so it runs on all but 1.10\n    Run gofmt only on Go 1.11\n    Walk symlinks when checking cached images for copied/added files\n    ReserveSELinuxLabels(): handle wrapped errors from OpenBuilder\n    Set WorkingDir to empty, not / for conformance\n    Update calls in e2e to addres 1101\n    imagebuilder.BuildDockerfiles: return the image ID\n    Update for changes in the containers/image API\n    bump(github.com/containers/image)\n    Allow setting --no-pivot default with an env var\n    Add man page and bash completion, for --no-pivot\n    Add the --no-pivot flag to the run command\n    Improve reporting about individual pull failures\n    Move the \"short name but no search registries\" error handling to resolveImage\n    Return a \"search registries were needed but empty\" indication in util.ResolveName\n    Simplify handling of the \"tried to pull an image but found nothing\" case in newBuilder\n    Don't even invoke the pull loop if options.FromImage == \"\"\n    Eliminate the long-running ref and img variables in resolveImage\n    In resolveImage, return immediately on success\n    Fix From As in Dockerfile\n    Vendor latest containers/image\n    Vendor in latest libpod\n    Sort CLI flags of buildah bud\n    Change from testing with golang 1.9 to 1.11.\n    unshare: detect when unprivileged userns are disabled\n    Optimize redundant code\n    fix missing format param\n    chroot: fix the args check\n    imagebuildah: make ResolveSymLink public\n    Update copy chown test\n    buildah: use the same logic for XDG_RUNTIME_DIR as podman\n    V1.4 Release Announcement\n    Podman  --privileged selinux is broken\n    papr: mount source at gopath\n    parse: Modify the return value\n    parse: modify the verification of the isolation value\n    Make sure we log or return every error\n    pullImage(): when completing an image name, try docker://\n    Fix up Tutorial 3 to account for format\n    Vendor in latest containers/storage and containers/image\n    docs/tutorials/01-intro.md: enhanced installation instructions\n    Enforce \"blocked\" for registries for the \"docker\" transport\n    Correctly set DockerInsecureSkipTLSVerify when pulling images\n    chroot: set up seccomp and capabilities after supplemental groups\n    chroot: fix capabilities list setup and application\n    .papr.yml: log the podman version\n    namespaces.bats: fix handling of uidmap/gidmap options in pairs\n    chroot: only create user namespaces when we know we need them\n    Check /proc/sys/user/max_user_namespaces on unshare(NEWUSERNS)\n    bash/buildah: add isolation option to the from command\n\n## v1.4 (2018-10-02)\n    from: fix isolation option\n    Touchup pull manpage\n    Export buildah ReserveSELinuxLables so podman can use it\n    Add buildah.io to README.md and doc fixes\n    Update rmi man for prune changes\n    Ignore file not found removal error in bud\n    bump(github.com/containers/{storage,image})\n    NewImageSource(): only create one Diff() at a time\n    Copy ExposedPorts from base image into the config\n    tests: run conformance test suite in Travis\n    Change rmi --prune to not accept an imageID\n    Clear intermediate container IDs after each stage\n    Request podman version for build issues\n    unshare: keep the additional groups of the user\n    Builtin volumes should be owned by the UID/GID of the container\n    Get rid of dangling whitespace in markdown files\n    Move buildah from projecatatomic/buildah to containers/buildah\n    nitpick: parse.validateFlags loop in bud cli\n    bash: Completion options\n    Add signature policy to push tests\n    vendor in latest containers/image\n    Fix grammar in Container Tools Guide\n    Don't build btrfs if it is not installed\n    new: Return image-pulling errors from resolveImage\n    pull: Return image-pulling errors from pullImage\n    Add more volume mount tests\n    chroot: create missing parent directories for volume mounts\n    Push: Allow an empty destination\n    Add Podman relationship to readme, create container tools guide\n    Fix arg usage in buildah-tag\n    Add flags/arguments order verification to other commands\n    Handle ErrDuplicateName errors from store.CreateContainer()\n    Evaluate symbolic links on Add/Copy Commands\n    Vendor in latest containers/image and containers/storage\n    Retain bounding set when running containers as non root\n    run container-diff tests in Travis\n    buildah-images.md: Fix option contents\n    push: show image digest after push succeed\n    Vendor in latest containers/storage,image,libpod and runc\n    Change references to cri-o to point at new repository\n    Exclude --layers from the common bug cli flags\n    demos: Increase the executable permissions\n    run: clear default seccomp filter if not enabled\n    Bump maximum cyclomatic complexity to 45\n    stdin: on HUP, read everything\n    nitpick: use tabs in tests/helpers.bash\n    Add flags/arguments order verification to one arg commands\n    nitpick: decrease cognitive complexity in buildah-bud\n    rename: Avoid renaming the same name as other containers\n    chroot isolation: chroot() before setting up seccomp\n    Small nitpick at the \"if\" condition in tag.go\n    cmd/images: Modify json option\n    cmd/images: Disallow the input of image when using the -a option\n    Fix examples to include context directory\n    Update containers/image to fix commit layer issue\n    cmd/containers: End loop early when using the json option\n    Make buildah-from error message clear when flags are after arg\n    Touch up README.md for conformance tests\n    Update container/storage for lock fix\n    cmd/rm: restore the correct containerID display\n    Remove debug lines\n    Remove docker build image after each test\n    Add README for conformance test\n    Update the MakeOptions to accept all command options for buildah\n    Update regrex to fit the docker output in test \"run with JSON\"\n    cmd/buildah: Remove redundant variable declarations\n    Warn about using Commands in Dockerfile that are not supported by OCI.\n    Add buildah bud conformance test\n    Fix rename to also change container name in builder\n    Makefile: use $(GO) env-var everywhere\n    Cleanup code to more closely match Docker Build images\n    Document BUILDAH_* environment variables in buildah bud --help output\n    Return error immediately if error occurs in Prepare step\n    Fix --layers ADD from url issue\n    Add \"Sign your PRs\" TOC item to contributing.md.\n    Display the correct ID after deleting image\n    rmi: Modify the handling of errors\n    Let util.ResolveName() return parsing errors\n    Explain Open Container Initiative (OCI) acronym, add link\n    Update vendor for urfave/cli back to master\n    Handle COPY --chown in Dockerfile\n    Switch to Recommends container-selinux\n    Update vendor for containernetworking, imagebuildah and podman\n    Document STORAGE_DRIVER and STORAGE_OPTS environment variable\n    Change references to projectatomic/libpod to containers/libpod\n    Add container PATH retrieval example\n    Expand variables names for --env\n    imagebuildah: provide a way to provide stdin for RUN\n    Remove an unused srcRef.NewImageSource in pullImage\n    chroot: correct a comment\n    chroot: bind mount an empty directory for masking\n    Don't bother with --no-pivot for rootless isolation\n    CentOS need EPEL repo\n    Export a Pull() function\n    Remove stream options, since docker build does not have it\n    release v1.3: mention openSUSE\n    Add Release Announcements directory\n    Bump to v1.4-dev\n\n## 1.3 (2018-08-4)\n    Revert pull error handling from 881\n    bud should not search context directory for Dockerfile\n    Set BUILDAH_ISOLATION=rootless when running unprivileged\n    .papr.sh: Also test with BUILDAH_ISOLATION=rootless\n    Skip certain tests when we're using \"rootless\" isolation\n    .travis.yml: run integration tests with BUILDAH_ISOLATION=chroot\n    Add and implement IsolationOCIRootless\n    Add a value for IsolationOCIRootless\n    Fix rmi to remove intermediate images associated with an image\n    Return policy error on pull\n    Update containers/image to 216acb1bcd2c1abef736ee322e17147ee2b7d76c\n    Switch to github.com/containers/image/pkg/sysregistriesv2\n    unshare: make adjusting the OOM score optional\n    Add flags validation\n    chroot: handle raising process limits\n    chroot: make the resource limits name map module-global\n    Remove rpm.bats, we need to run this manually\n    Set the default ulimits to match Docker\n    buildah: no args is out of bounds\n    unshare: error message missed the pid\n    preprocess \".in\" suffixed Dockerfiles\n    Fix the the in buildah-config man page\n    Only test rpmbuild on latest fedora\n    Add support for multiple Short options\n    Update to latest urvave/cli\n    Add additional SELinux tests\n    Vendor in latest github.com/containers/{image;storage}\n    Stop testing with golang 1.8\n    Fix volume cache issue with buildah bud --layers\n    Create buildah pull command\n    Increase the deadline for gometalinter during 'make validate'\n    .papr.sh: Also test with BUILDAH_ISOLATION=chroot\n    .travis.yml: run integration tests with BUILDAH_ISOLATION=chroot\n    Add a Dockerfile\n    Set BUILDAH_ISOLATION=chroot when running unprivileged\n    Add and implement IsolationChroot\n    Update github.com/opencontainers/runc\n    maybeReexecUsingUserNamespace: add a default for root\n    Allow ping command without NET_RAW Capabilities\n    rmi.storageImageID: fix Wrapf format warning\n    Allow Dockerfile content to come from stdin\n    Vendor latest container/storage to fix overlay mountopt\n    userns: assign additional IDs sequentially\n    Remove default dev/pts\n    Add OnBuild test to baseline test\n    tests/run.bats(volumes): use :z when SELinux is enabled\n    Avoid a stall in runCollectOutput()\n    Use manifest from container/image\n    Vendor in latest containers/image and containers/storage\n    add rename command\n    Completion command\n    Update CHANGELOG.md\n    Update vendor for runc to fix 32 bit builds\n    bash completion: remove shebang\n    Update vendor for runc to fix 32 bit builds\n\n## 1.2 (2018-07-14)\n    Vendor in lates containers/image\n    build-using-dockerfile: let -t include transports again\n    Block use of /proc/acpi and /proc/keys from inside containers\n    Fix handling of --registries-conf\n    Fix becoming a maintainer link\n    add optional CI test fo darwin\n    Don't pass a nil error to errors.Wrapf()\n    image filter test: use kubernetes/pause as a \"since\"\n    Add --cidfile option to from\n    vendor: update containers/storage\n    Contributors need to find the CONTRIBUTOR.md file easier\n    Add a --loglevel option to build-with-dockerfile\n    Create Development plan\n    cmd: Code improvement\n    allow buildah cross compile for a darwin target\n    Add unused function param lint check\n    docs: Follow man-pages(7) suggestions for SYNOPSIS\n    Start using github.com/seccomp/containers-golang\n    umount: add all option to umount all mounted containers\n    runConfigureNetwork(): remove an unused parameter\n    Update github.com/opencontainers/selinux\n    Fix buildah bud --layers\n    Force ownership of /etc/hosts and /etc/resolv.conf to 0:0\n    main: if unprivileged, reexec in a user namespace\n    Vendor in latest imagebuilder\n    Reduce the complexity of the buildah.Run function\n    mount: output it before replacing lastError\n    Vendor in latest selinux-go code\n    Implement basic recognition of the \"--isolation\" option\n    Run(): try to resolve non-absolute paths using $PATH\n    Run(): don't include any default environment variables\n    build without seccomp\n    vendor in latest runtime-tools\n    bind/mount_unsupported.go: remove import errors\n    Update github.com/opencontainers/runc\n    Add Capabilities lists to BuilderInfo\n    Tweaks for commit tests\n    commit: recognize committing to second storage locations\n    Fix ARGS parsing for run commands\n    Add info on registries.conf to from manpage\n    Switch from using docker to podman for testing in .papr\n    buildah: set the HTTP User-Agent\n    ONBUILD tutorial\n    Add information about the configuration files to the install docs\n    Makefile: add uninstall\n    Add tilde info for push to troubleshooting\n    mount: support multiple inputs\n    Use the right formatting when adding entries to /etc/hosts\n    Vendor in latest go-selinux bindings\n    Allow --userns-uid-map/--userns-gid-map to be global options\n    bind: factor out UnmountMountpoints\n    Run(): simplify runCopyStdio()\n    Run(): handle POLLNVAL results\n    Run(): tweak terminal mode handling\n    Run(): rename 'copyStdio' to 'copyPipes'\n    Run(): don't set a Pdeathsig for the runtime\n    Run(): add options for adding and removing capabilities\n    Run(): don't use a callback when a slice will do\n    setupSeccomp(): refactor\n    Change RunOptions.Stdin/Stdout/Stderr to just be Reader/Writers\n    Escape use of '_' in .md docs\n    Break out getProcIDMappings()\n    Break out SetupIntermediateMountNamespace()\n    Add Multi From Demo\n    Use the c/image conversion code instead of converting configs manually\n    Don't throw away the manifest MIME type and guess again\n    Consolidate loading manifest and config in initConfig\n    Pass a types.Image to Builder.initConfig\n    Require an image ID in importBuilderDataFromImage\n    Use c/image/manifest.GuessMIMEType instead of a custom heuristic\n    Do not ignore any parsing errors in initConfig\n    Explicitly handle \"from scratch\" images in Builder.initConfig\n    Fix parsing of OCI images\n    Simplify dead but dangerous-looking error handling\n    Don't ignore v2s1 history if docker_version is not set\n    Add --rm and --force-rm to buildah bud\n    Add --all,-a flag to buildah images\n    Separate stdio buffering from writing\n    Remove tty check from images --format\n    Add environment variable BUILDAH_RUNTIME\n    Add --layers and --no-cache to buildah bud\n    Touch up images man\n    version.md: fix DESCRIPTION\n    tests: add containers test\n    tests: add images test\n    images: fix usage\n    fix make clean error\n    Change 'registries' to 'container registries' in man\n    add commit test\n    Add(): learn to record hashes of what we add\n    Minor update to buildah config documentation for entrypoint\n    Bump to v1.2-dev\n    Add registries.conf link to a few man pages\n\n## 1.1 (2018-06-08)\n    Drop capabilities if running container processes as non root\n    Print Warning message if cmd will not be used based on entrypoint\n    Update 01-intro.md\n    Shouldn't add insecure registries to list of search registries\n    Report errors on bad transports specification when pushing images\n    Move parsing code out of common for namespaces and into pkg/parse.go\n    Add disable-content-trust noop flag to bud\n    Change freenode chan to buildah\n    runCopyStdio(): don't close stdin unless we saw POLLHUP\n    Add registry errors for pull\n    runCollectOutput(): just read until the pipes are closed on us\n    Run(): provide redirection for stdio\n    rmi, rm: add test\n    add mount test\n    Add parameter judgment for commands that do not require parameters\n    Add context dir to bud command in baseline test\n    run.bats: check that we can run with symlinks in the bundle path\n    Give better messages to users when image can not be found\n    use absolute path for bundlePath\n    Add environment variable to buildah --format\n    rm: add validation to args and all option\n    Accept json array input for config entrypoint\n    Run(): process RunOptions.Mounts, and its flags\n    Run(): only collect error output from stdio pipes if we created some\n    Add OnBuild support for Dockerfiles\n    Quick fix on demo readme\n    run: fix validate flags\n    buildah bud should require a context directory or URL\n    Touchup tutorial for run changes\n    Validate common bud and from flags\n    images: Error if the specified imagename does not exist\n    inspect: Increase err judgments to avoid panic\n    add test to inspect\n    buildah bud picks up ENV from base image\n    Extend the amount of time travis_wait should wait\n    Add a make target for Installing CNI plugins\n    Add tests for namespace control flags\n    copy.bats: check ownerships in the container\n    Fix SELinux test errors when SELinux is enabled\n    Add example CNI configurations\n    Run: set supplemental group IDs\n    Run: use a temporary mount namespace\n    Use CNI to configure container networks\n    add/secrets/commit: Use mappings when setting permissions on added content\n    Add CLI options for specifying namespace and cgroup setup\n    Always set mappings when using user namespaces\n    Run(): break out creation of stdio pipe descriptors\n    Read UID/GID mapping information from containers and images\n    Additional bud CI tests\n    Run integration tests under travis_wait in Travis\n    build-using-dockerfile: add --annotation\n    Implement --squash for build-using-dockerfile and commit\n    Vendor in latest container/storage for devicemapper support\n    add test to inspect\n    Vendor github.com/onsi/ginkgo and github.com/onsi/gomega\n    Test with Go 1.10, too\n    Add console syntax highlighting to troubleshooting page\n    bud.bats: print \"$output\" before checking its contents\n    Manage \"Run\" containers more closely\n    Break Builder.Run()'s \"run runc\" bits out\n    util.ResolveName(): handle completion for tagged/digested image names\n    Handle /etc/hosts and /etc/resolv.conf properly in container\n    Documentation fixes\n    Make it easier to parse our temporary directory as an image name\n    Makefile: list new pkg/ subdirectoris as dependencies for buildah\n    containerImageSource: return more-correct errors\n    API cleanup: PullPolicy and TerminalPolicy should be types\n    Make \"run --terminal\" and \"run -t\" aliases for \"run --tty\"\n    Vendor github.com/containernetworking/cni v0.6.0\n    Update github.com/containers/storage\n    Update github.com/containers/libpod\n    Add support for buildah bud --label\n    buildah push/from can push and pull images with no reference\n    Vendor in latest containers/image\n    Update gometalinter to fix install.tools error\n    Update troubleshooting with new run workaround\n    Added a bud demo and tidied up\n    Attempt to download file from url, if fails assume Dockerfile\n    Add buildah bud CI tests for ENV variables\n    Re-enable rpm .spec version check and new commit test\n    Update buildah scratch demo to support el7\n    Added Docker compatibility demo\n    Update to F28 and new run format in baseline test\n    Touchup man page short options across man pages\n    Added demo dir and a demo. chged distrorlease\n    builder-inspect: fix format option\n    Add cpu-shares short flag (-c) and cpu-shares CI tests\n    Minor fixes to formatting in rpm spec changelog\n    Fix rpm .spec changelog formatting\n    CI tests and minor fix for cache related noop flags\n    buildah-from: add effective value to mount propagation\n\n## 1.0 (2018-05-06)\n    Declare Buildah 1.0\n    Add cache-from and no-cache noops, and fix doco\n    Update option and documentation for --force-rm\n    Adding noop for --force-rm to match --rm\n    Add buildah bud ENTRYPOINT,CMD,RUN tests\n    Adding buildah bud RUN test scenarios\n    Extend tests for empty buildah run command\n    Fix formatting error in run.go\n    Update buildah run to make command required\n    Expanding buildah run cmd/entrypoint tests\n    Update test cases for buildah run behaviour\n    Remove buildah run cmd and entrypoint execution\n    Add Files section with registries.conf to pertinent man pages\n    tests/config: perfect test\n    tests/from: add name test\n    Do not print directly to stdout in Commit()\n    Touch up auth test commands\n    Force \"localhost\" as a default registry\n    Drop util.GetLocalTime()\n    Vendor in latest containers/image\n    Validate host and container paths passed to --volume\n    test/from: add add-host test\n    Add --compress, --rm, --squash flags as a noop for bud\n    Add FIPS mode secret to buildah run and bud\n    Add config --comment/--domainname/--history-comment/--hostname\n    'buildah config': stop replacing Created-By whenever it's not specified\n    Modify man pages so they compile correctly in mandb\n    Add description on how to do --isolation to buildah-bud man page\n    Add support for --iidfile to bud and commit\n    Refactor buildah bud for vendoring\n    Fail if date or git not installed\n    Revert update of entrypoint behaviour to match docker\n    Vendor in latest imagebuilder code to fix multiple stage builds\n    Add /bin/sh -c to entrypoint in config\n    image_test: Improve the test\n    Fix README example of buildah config\n    buildah-image: add validation to 'format'\n    Simple changes to allow buildah to pass make validate\n    Clarify the use of buildah config options\n    containers_test: Perfect testing\n    buildah images and podman images are listing different sizes\n    buildah-containers: add tests and example to the man page\n    buildah-containers: add validation to 'format'\n    Clarify the use of buildah config options\n    Minor fix for lighttpd example in README\n    Add tls-verification to troubleshooting\n    Modify buildah rmi to account for changes in containers/storage\n    Vendor in latest containers/image and containers/storage\n    addcopy: add src validation\n    Remove tarball as an option from buildah push --help\n    Fix secrets patch\n    Update entrypoint behaviour to match docker\n    Display imageId after commit\n    config: add support for StopSignal\n    Fix docker login issue in travis.yml\n    Allow referencing stages as index and names\n    Add multi-stage builds tests\n    Add multi-stage builds support\n    Add accessor functions for comment and stop signal\n    Vendor in latest imagebuilder, to get mixed case AS support\n    Allow umount to have multi-containers\n    Update buildah push doc\n    buildah bud walks symlinks\n    Imagename is required for commit atm, update manpage\n\n## 0.16.0 (2018-04-08)\n    Bump to v0.16.0\n    Remove requires for ostree-lib in rpm spec file\n    Add support for shell\n    buildah.spec should require ostree-libs\n    Vendor in latest containers/image\n    bash: prefer options\n    Change image time to locale, add troubleshooting.md, add logo to other mds\n    buildah-run.md: fix error SYNOPSIS\n    docs: fix error example\n    Allow --cmd parameter to have commands as values\n    Touchup README to re-enable logo\n    Clean up README.md\n    Make default-mounts-file a hidden option\n    Document the mounts.conf file\n    Fix man pages to format correctly\n    Add various transport support to buildah from\n    Add unit tests to run.go\n    If the user overrides the storage driver, the options should be dropped\n    Show Config/Manifest as JSON string in inspect when format is not set\n    Switch which for that in README.md\n    Remove COPR\n    Fix wrong order of parameters\n    Vendor in latest containers/image\n    Remove shallowCopy(), which shouldn't be saving us time any more\n    shallowCopy: avoid a second read of the container's layer\n\n## 0.5 - 2017-11-07\n    Add secrets patch to buildah\n    Add proper SELinux labeling to buildah run\n    Add tls-verify to bud command\n    Make filtering by date use the image's date\n    images: don't list unnamed images twice\n    Fix timeout issue\n    Add further tty verbiage to buildah run\n    Make inspect try an image on failure if type not specified\n    Add support for `buildah run --hostname`\n    Tons of bug fixes and code cleanup\n\n## 0.4 - 2017-09-22\n### Added\n    Update buildah spec file to match new version\n    Bump to version 0.4\n    Add default transport to push if not provided\n    Add authentication to commit and push\n    Remove --transport flag\n    Run: don't complain about missing volume locations\n    Add credentials to buildah from\n    Remove export command\n    Bump containers/storage and containers/image\n\n## 0.3 - 2017-07-20\n## 0.2 - 2017-07-18\n### Added\n    Vendor in latest containers/image and containers/storage\n    Update image-spec and runtime-spec to v1.0.0\n    Add support for -- ending options parsing to buildah run\n    Add/Copy need to support glob syntax\n    Add flag to remove containers on commit\n    Add buildah export support\n    update 'buildah images' and 'buildah rmi' commands\n    buildah containers/image: Add JSON output option\n    Add 'buildah version' command\n    Handle \"run\" without an explicit command correctly\n    Ensure volume points get created, and with perms\n    Add a -a/--all option to \"buildah containers\"\n\n## 0.1 - 2017-06-14\n### Added\n    Vendor in latest container/storage container/image\n    Add a \"push\" command\n    Add an option to specify a Create date for images\n    Allow building a source image from another image\n    Improve buildah commit performance\n    Add a --volume flag to \"buildah run\"\n    Fix inspect/tag-by-truncated-image-ID\n    Include image-spec and runtime-spec versions\n    buildah mount command should list mounts when no arguments are given.\n    Make the output image format selectable\n    commit images in multiple formats\n    Also import configurations from V2S1 images\n    Add a \"tag\" command\n    Add an \"inspect\" command\n    Update reference comments for docker types origins\n    Improve configuration preservation in imagebuildah\n    Report pull/commit progress by default\n    Contribute buildah.spec\n    Remove --mount from buildah-from\n    Add a build-using-dockerfile command (alias: bud)\n    Create manpages for the buildah project\n    Add installation for buildah and bash completions\n    Rename \"list\"/\"delete\" to \"containers\"/\"rm\"\n    Switch `buildah list quiet` option to only list container id's\n    buildah delete should be able to delete multiple containers\n    Correctly set tags on the names of pulled images\n    Don't mix \"config\" in with \"run\" and \"commit\"\n    Add a \"list\" command, for listing active builders\n    Add \"add\" and \"copy\" commands\n    Add a \"run\" command, using runc\n    Massive refactoring\n    Make a note to distinguish compression of layers\n\n## 0.0 - 2017-01-26\n### Added\n    Initial version, needs work\n"
        },
        {
          "name": "CODE-OF-CONDUCT.md",
          "type": "blob",
          "size": 0.1845703125,
          "content": "## The Buildah Project Community Code of Conduct\n\nThe Buildah Project follows the [Containers Community Code of Conduct](https://github.com/containers/common/blob/main/CODE-OF-CONDUCT.md).\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 7.4228515625,
          "content": "![buildah logo](https://cdn.rawgit.com/containers/buildah/main/logos/buildah-logo_large.png)\n\n# Contributing to Buildah\n\nWe'd love to have you join the community! Below summarizes the processes\nthat we follow.\n\n## Topics\n\n* [Reporting Issues](#reporting-issues)\n* [Working On Issues](#working-on-issues)\n* [Submitting Pull Requests](#submitting-pull-requests)\n* [Sign your PRs](#sign-your-prs)\n* [Merge bot interaction](#merge-bot-interaction)\n* [Communications](#communications)\n* [Becoming a Maintainer](#becoming-a-maintainer)\n\n## Reporting Issues\n\nBefore reporting an issue, check our backlog of\n[open issues](https://github.com/containers/buildah/issues)\nto see if someone else has already reported it. If so, feel free to add\nyour scenario, or additional information, to the discussion. Or simply\n\"subscribe\" to it to be notified when it is updated.\n\nIf you find a new issue with the project we'd love to hear about it! The most\nimportant aspect of a bug report is that it includes enough information for\nus to reproduce it. So, please include as much detail as possible and try\nto remove the extra stuff that doesn't really relate to the issue itself.\nThe easier it is for us to reproduce it, the faster it'll be fixed!\n\nPlease don't include any private/sensitive information in your issue!\n\n## Working On Issues\n\nOnce you have decided to contribute to Buildah by working on an issue, check our\nbacklog of [open issues](https://github.com/containers/buildah/issues) looking\nfor any that do not have an \"In Progress\" label attached to it.  Often issues\nwill be assigned to someone, to be worked on at a later time.  If you have the\ntime to work on the issue now, add yourself as an assignee, and set the\n\"In Progress\" label if you’re a member of the “Containers” GitHub organization.\nIf you can not set the label, just  add a quick comment in the issue asking that\nthe “In Progress” label be set and a member will do so for you.\n\n## Submitting Pull Requests\n\nNo Pull Request (PR) is too small! Typos, additional comments in the code,\nnew testcases, bug fixes, new features, more documentation, ... it's all\nwelcome!\n\nWhile bug fixes can first be identified via an \"issue\", that is not required.\nIt's ok to just open up a PR with the fix, but make sure you include the same\ninformation you would have included in an issue - like how to reproduce it.\n\nPRs for new features should include some background on what use cases the\nnew code is trying to address. When possible and when it makes sense, try to break-up\nlarger PRs into smaller ones - it's easier to review smaller\ncode changes. But only if those smaller ones make sense as stand-alone PRs.\n\nRegardless of the type of PR, all PRs should include:\n* well documented code changes\n* additional testcases. Ideally, they should fail w/o your code change applied\n* documentation changes\n\nSquash your commits into logical pieces of work that might want to be reviewed\nseparate from the rest of the PRs. But, squashing down to just one commit is ok\ntoo since in the end the entire PR will be reviewed anyway. When in doubt,\nsquash.\n\nPRs that fix issues should include a reference like `Closes #XXXX` in the\ncommit message so that github will automatically close the referenced issue\nwhen the PR is merged.\n\n<!--\nAll PRs require at least two LGTMs (Looks Good To Me) from maintainers.\n-->\n\n### Sign your PRs\n\nThe sign-off is a line at the end of the explanation for the patch. Your\nsignature certifies that you wrote the patch or otherwise have the right to pass\nit on as an open-source patch. The rules are simple: if you can certify\nthe below (from [developercertificate.org](http://developercertificate.org/)):\n\n```\nDeveloper Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n660 York Street, Suite 102,\nSan Francisco, CA 94110 USA\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.\n```\n\nThen you just add a line to every git commit message:\n\n    Signed-off-by: Joe Smith <joe.smith@email.com>\n\nUse your real name (sorry, no pseudonyms or anonymous contributions.)\n\nIf you set your `user.name` and `user.email` git configs, you can sign your\ncommit automatically with `git commit -s`.\n\n## Merge bot interaction\n\nMaintainers should never merge anything directly into upstream\nbranches.  Instead, interact with the [openshift-ci-robot](https://github.com/openshift-ci-robot/)\nthrough PR comments as summarized [here](https://prow.ci.openshift.org/command-help?repo=containers%2Fbuildah).\nThis ensures all upstream\nbranches contain commits in a predictable order, and that every commit\nhas passed automated testing at some point in the past. A\n[Maintainer portal](https://prow.ci.openshift.org/pr?query=is%3Apr%20state%3Aopen%20repo%3Acontainers%2Fbuildah)\nis available, showing all PRs awaiting review and approval.\n\n## Communications\n\nFor general questions or discussions, please use the\nIRC channel `#podman` on `irc.libera.chat`. If you are unfamiliar with IRC you can start a web client at https://web.libera.chat/#podman.\n\nAlternatively, [\\[matrix\\]](https://matrix.org) can be used to access the same channel via federation at https://matrix.to/#/#podman:chat.fedoraproject.org.\n\n### For discussions around issues/bugs and features:\n\n#### GitHub\nYou can also use GitHub\n[issues](https://github.com/containers/buildah/issues)\nand\n[PRs](https://github.com/containers/buildah/pulls)\ntracking system.\n\n#### Buildah Mailing List\n\n\nYou can join the Buildah mailing list by sending an email to `buildah-join@lists.buildah.io` with the word `subscribe` in the subject.  You can also go to this [page](https://lists.podman.io/admin/lists/buildah.lists.buildah.io/), then scroll down to the bottom of the page and enter your email and optionally name, then click on the \"Subscribe\" button.\n\n## Becoming a Maintainer\n\nTo become a maintainer you must first be nominated by an existing maintainer.\nIf a majority (>50%) of maintainers agree then the proposal is adopted and\nyou will be added to the list.\n\nRemoving a maintainer requires at least 75% of the remaining maintainers\napproval, or if the person requests to be removed then it is automatic.\nNormally, a maintainer will only be removed if they are considered to be\ninactive for a long period of time or are viewed as disruptive to the community.\n\nThe current list of maintainers can be found in the\n[MAINTAINERS](MAINTAINERS) file.\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "MAINTAINERS",
          "type": "blob",
          "size": 0.1865234375,
          "content": "Dan Walsh <dwalsh@redhat.com> (@rhatdan)\nNalin Dahyabhai <nalin@redhat.com> (@nalind)\nTom Sweeney <tsweeney@redhat.com> (@tomsweeneyredhat)\nUrvashi Mohnani <umohnani@redhat.com> (@umohnani8)\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 7.8505859375,
          "content": "export GOPROXY=https://proxy.golang.org\n\nAPPARMORTAG := $(shell hack/apparmor_tag.sh)\nSTORAGETAGS := $(shell ./btrfs_tag.sh) $(shell ./btrfs_installed_tag.sh) $(shell ./hack/libsubid_tag.sh)\nSECURITYTAGS ?= seccomp $(APPARMORTAG)\nTAGS ?= $(SECURITYTAGS) $(STORAGETAGS) $(shell ./hack/systemd_tag.sh)\nifeq ($(shell uname -s),FreeBSD)\n# FreeBSD needs CNI until netavark is supported\nTAGS += cni\nendif\nBUILDTAGS += $(TAGS)\nPREFIX := /usr/local\nBINDIR := $(PREFIX)/bin\nBASHINSTALLDIR = $(PREFIX)/share/bash-completion/completions\nBUILDFLAGS := -tags \"$(BUILDTAGS)\"\nBUILDAH := buildah\nSELINUXOPT ?= $(shell test -x /usr/sbin/selinuxenabled && selinuxenabled && echo -Z)\nSELINUXTYPE=container_runtime_exec_t\nAS ?= as\nSTRIP ?= strip\n\nGO := go\nGO_LDFLAGS := $(shell if $(GO) version|grep -q gccgo; then echo \"-gccgoflags\"; else echo \"-ldflags\"; fi)\nGO_GCFLAGS := $(shell if $(GO) version|grep -q gccgo; then echo \"-gccgoflags\"; else echo \"-gcflags\"; fi)\nexport GO_BUILD=$(GO) build\nexport GO_TEST=$(GO) test\nRACEFLAGS := $(shell $(GO_TEST) -race ./pkg/dummy > /dev/null 2>&1 && echo -race)\n\nCOMMIT_NO ?= $(shell git rev-parse HEAD 2> /dev/null || true)\nGIT_COMMIT ?= $(if $(shell git status --porcelain --untracked-files=no),${COMMIT_NO}-dirty,${COMMIT_NO})\nSOURCE_DATE_EPOCH ?= $(if $(shell date +%s),$(shell date +%s),$(error \"date failed\"))\n\n# we get GNU make 3.x in MacOS build envs, which wants # to be escaped in\n# strings, while the 4.x we have on Linux doesn't. this is the documented\n# workaround\nCOMMENT := \\#\nCNI_COMMIT := $(shell sed -n 's;^$(COMMENT) github.com/containernetworking/cni \\([^ \\n]*\\).*$$;\\1;p' vendor/modules.txt)\n\nEXTRA_LDFLAGS ?=\nBUILDAH_LDFLAGS := $(GO_LDFLAGS) '-X main.GitCommit=$(GIT_COMMIT) -X main.buildInfo=$(SOURCE_DATE_EPOCH) -X main.cniVersion=$(CNI_COMMIT) $(EXTRA_LDFLAGS)'\n\n# This isn't what we actually build; it's a superset, used for target\n# dependencies. Basically: all *.go and *.c files, except *_test.go,\n# and except anything in a dot subdirectory. If any of these files is\n# newer than our target (bin/buildah), a rebuild is triggered.\nSOURCES=$(shell find . -path './.*' -prune -o \\( \\( -name '*.go' -o -name '*.c' \\) -a ! -name '*_test.go' \\) -print)\n\nLINTFLAGS ?=\n\nifeq ($(BUILDDEBUG), 1)\n  override GOGCFLAGS += -N -l\nendif\n\n#   make all BUILDDEBUG=1\n#     Note: Uses the -N -l go compiler options to disable compiler optimizations\n#           and inlining. Using these build options allows you to subsequently\n#           use source debugging tools like delve.\nall: bin/buildah bin/imgtype bin/copy bin/inet bin/tutorial docs\n\n# Update nix/nixpkgs.json its latest stable commit\n.PHONY: nixpkgs\nnixpkgs:\n\t@nix run \\\n\t\t-f channel:nixos-20.09 nix-prefetch-git \\\n\t\t-c nix-prefetch-git \\\n\t\t--no-deepClone \\\n\t\thttps://github.com/nixos/nixpkgs refs/heads/nixos-20.09 > nix/nixpkgs.json\n\n# Build statically linked binary\n.PHONY: static\nstatic:\n\t@nix build -f nix/\n\tmkdir -p ./bin\n\tcp -rfp ./result/bin/* ./bin/\n\nbin/buildah: $(SOURCES) internal/mkcw/embed/entrypoint_amd64.gz\n\t$(GO_BUILD) $(BUILDAH_LDFLAGS) $(GO_GCFLAGS) \"$(GOGCFLAGS)\" -o $@ $(BUILDFLAGS) ./cmd/buildah\n\ttest -z \"${SELINUXOPT}\" || chcon --verbose -t $(SELINUXTYPE) $@\n\nifneq ($(shell $(AS) --version | grep x86_64),)\ninternal/mkcw/embed/entrypoint_amd64.gz: internal/mkcw/embed/entrypoint_amd64\n\tgzip -k9nf $^\n\ninternal/mkcw/embed/entrypoint_amd64: internal/mkcw/embed/entrypoint_amd64.s\n\t$(AS) -o $(patsubst %.s,%.o,$^) $^\n\t$(LD) -o $@ $(patsubst %.s,%.o,$^)\n\t$(STRIP) $@\nendif\n\n\n.PHONY: buildah\nbuildah: bin/buildah\n\nALL_CROSS_TARGETS := $(addprefix bin/buildah.,$(subst /,.,$(shell $(GO) tool dist list)))\nLINUX_CROSS_TARGETS := $(filter-out %.loong64,$(filter bin/buildah.linux.%,$(ALL_CROSS_TARGETS)))\nDARWIN_CROSS_TARGETS := $(filter bin/buildah.darwin.%,$(ALL_CROSS_TARGETS))\nWINDOWS_CROSS_TARGETS := $(addsuffix .exe,$(filter bin/buildah.windows.%,$(ALL_CROSS_TARGETS)))\nFREEBSD_CROSS_TARGETS := $(filter bin/buildah.freebsd.%,$(ALL_CROSS_TARGETS))\n.PHONY: cross\ncross: $(LINUX_CROSS_TARGETS) $(DARWIN_CROSS_TARGETS) $(WINDOWS_CROSS_TARGETS) $(FREEBSD_CROSS_TARGETS)\n\nbin/buildah.%: $(SOURCES)\n\tmkdir -p ./bin\n\tGOOS=$(word 2,$(subst ., ,$@)) GOARCH=$(word 3,$(subst ., ,$@)) $(GO_BUILD) $(BUILDAH_LDFLAGS) -o $@ -tags \"containers_image_openpgp\" ./cmd/buildah\n\nbin/imgtype: $(SOURCES)\n\t$(GO_BUILD) $(BUILDAH_LDFLAGS) -o $@ $(BUILDFLAGS) ./tests/imgtype/imgtype.go\n\nbin/copy: $(SOURCES)\n\t$(GO_BUILD) $(BUILDAH_LDFLAGS) -o $@ $(BUILDFLAGS) ./tests/copy/copy.go\n\nbin/tutorial: $(SOURCES)\n\t$(GO_BUILD) $(BUILDAH_LDFLAGS) -o $@ $(BUILDFLAGS) ./tests/tutorial/tutorial.go\n\nbin/inet: tests/inet/inet.go\n\t$(GO_BUILD) $(BUILDAH_LDFLAGS) -o $@ $(BUILDFLAGS) ./tests/inet/inet.go\n\n.PHONY: clean\nclean:\n\t$(RM) -r bin tests/testreport/testreport\n\t$(MAKE) -C docs clean\n\n.PHONY: docs\ndocs: install.tools ## build the docs on the host\n\t$(MAKE) -C docs\n\ncodespell:\n\tcodespell -w\n\n.PHONY: validate\nvalidate: install.tools\n\t./tests/validate/whitespace.sh\n\t./hack/xref-helpmsgs-manpages\n\t./tests/validate/pr-should-include-tests\n\n.PHONY: install.tools\ninstall.tools:\n\t$(MAKE) -C tests/tools\n\n.PHONY: install\ninstall:\n\tinstall -d -m 755 $(DESTDIR)/$(BINDIR)\n\tinstall -m 755 bin/buildah $(DESTDIR)/$(BINDIR)/buildah\n\t$(MAKE) -C docs install\n\n.PHONY: uninstall\nuninstall:\n\trm -f $(DESTDIR)/$(BINDIR)/buildah\n\trm -f $(PREFIX)/share/man/man1/buildah*.1\n\trm -f $(DESTDIR)/$(BASHINSTALLDIR)/buildah\n\n.PHONY: install.completions\ninstall.completions:\n\tinstall -m 755 -d $(DESTDIR)/$(BASHINSTALLDIR)\n\tinstall -m 644 contrib/completions/bash/buildah $(DESTDIR)/$(BASHINSTALLDIR)/buildah\n\n.PHONY: test-conformance\ntest-conformance:\n\t$(GO_TEST) -v -tags \"$(STORAGETAGS) $(SECURITYTAGS)\" -cover -timeout 60m ./tests/conformance\n\n.PHONY: test-integration\ntest-integration: install.tools\n\tcd tests; ./test_runner.sh\n\ntests/testreport/testreport: tests/testreport/testreport.go\n\t$(GO_BUILD) $(GO_LDFLAGS) \"-linkmode external -extldflags -static\" -tags \"$(STORAGETAGS) $(SECURITYTAGS)\" -o tests/testreport/testreport ./tests/testreport/testreport.go\n\n.PHONY: test-unit\ntest-unit: tests/testreport/testreport\n\t$(GO_TEST) -v -tags \"$(STORAGETAGS) $(SECURITYTAGS)\" -cover $(RACEFLAGS) $(shell $(GO) list ./... | grep -v vendor | grep -v tests | grep -v cmd | grep -v chroot | grep -v copier) -timeout 45m\n\t$(GO_TEST) -v -tags \"$(STORAGETAGS) $(SECURITYTAGS)\"        $(RACEFLAGS) ./chroot ./copier -timeout 60m\n\ttmp=$(shell mktemp -d) ; \\\n\tmkdir -p $$tmp/root $$tmp/runroot; \\\n\t$(GO_TEST) -v -tags \"$(STORAGETAGS) $(SECURITYTAGS)\" -cover $(RACEFLAGS) ./cmd/buildah -args --root $$tmp/root --runroot $$tmp/runroot --storage-driver vfs --signature-policy $(shell pwd)/tests/policy.json --registries-conf $(shell pwd)/tests/registries.conf\n\nvendor-in-container:\n\tgoversion=$(shell sed -e '/^go /!d' -e '/^go /s,.* ,,g' go.mod) ; \\\n\tif test -d `go env GOCACHE` && test -w `go env GOCACHE` ; then \\\n\t\tpodman run --privileged --rm --env HOME=/root -v `go env GOCACHE`:/root/.cache/go-build --env GOCACHE=/root/.cache/go-build -v `pwd`:/src -w /src docker.io/library/golang:$$goversion make vendor ; \\\n\telse \\\n\t\tpodman run --privileged --rm --env HOME=/root -v `pwd`:/src -w /src docker.io/library/golang:$$goversion make vendor ; \\\n\tfi\n\n.PHONY: vendor\nvendor:\n\t$(GO) mod tidy\n\t$(GO) mod vendor\n\t$(GO) mod verify\n\tif test -n \"$(strip $(shell go env GOTOOLCHAIN))\"; then go mod edit -toolchain none ; fi\n\n.PHONY: lint\nlint: install.tools\n\t./tests/tools/build/golangci-lint run $(LINTFLAGS)\n\n# CAUTION: This is not a replacement for RPMs provided by your distro.\n# Only intended to build and test the latest unreleased changes.\n.PHONY: rpm\nrpm:  ## Build rpm packages\n\t$(MAKE) -C rpm\n\n# Remember that rpms install exec to /usr/bin/buildah while a `make install`\n# installs them to /usr/local/bin/buildah which is likely before. Always use\n# a full path to test installed buildah or you risk to call another executable.\n.PHONY: rpm-install\nrpm-install: package  ## Install rpm packages\n\t$(call err_if_empty,PKG_MANAGER) -y install rpm/RPMS/*/*.rpm\n\t/usr/bin/buildah version\n"
        },
        {
          "name": "OWNERS",
          "type": "blob",
          "size": 0.185546875,
          "content": "approvers:\n  - TomSweeneyRedHat\n  - lsm5\n  - nalind\n  - rhatdan\n  - umohnani8\nreviewers:\n  - ashley-cui\n  - baude\n  - edsantiago\n  - flouthoc\n  - giuseppe\n  - Honny1\n  - mheon\n  - vrothberg\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.3369140625,
          "content": "![buildah logo (light)](logos/buildah-logo_large.png#gh-light-mode-only)\n![buildah logo (dark)](logos/buildah-logo_reverse_large.png#gh-dark-mode-only)\n\n# [Buildah](https://www.youtube.com/embed/YVk5NgSiUw8) - a tool that facilitates building [Open Container Initiative (OCI)](https://www.opencontainers.org/) container images\n\n[![Go Report Card](https://goreportcard.com/badge/github.com/containers/buildah)](https://goreportcard.com/report/github.com/containers/buildah)\n\n\nThe Buildah package provides a command line tool that can be used to\n* create a working container, either from scratch or using an image as a starting point\n* create an image, either from a working container or via the instructions in a Dockerfile\n* images can be built in either the OCI image format or the traditional upstream docker image format\n* mount a working container's root filesystem for manipulation\n* unmount a working container's root filesystem\n* use the updated contents of a container's root filesystem as a filesystem layer to create a new image\n* delete a working container or an image\n* rename a local container\n\n## Buildah Information for Developers\n\nFor blogs, release announcements and more, please checkout the [buildah.io](https://buildah.io) website!\n\n**[Buildah Container Images](https://github.com/containers/image_build/blob/main/buildah/README.md)**\n\n**[Buildah Demos](demos)**\n\n**[Changelog](CHANGELOG.md)**\n\n**[Contributing](CONTRIBUTING.md)**\n\n**[Development Plan](developmentplan.md)**\n\n**[Installation notes](install.md)**\n\n**[Troubleshooting Guide](troubleshooting.md)**\n\n**[Tutorials](docs/tutorials)**\n\n## Buildah and Podman relationship\n\nBuildah and Podman are two complementary open-source projects that are\navailable on most Linux platforms and both projects reside at\n[GitHub.com](https://github.com) with Buildah\n[here](https://github.com/containers/buildah) and Podman\n[here](https://github.com/containers/podman).  Both, Buildah and Podman are\ncommand line tools that work on Open Container Initiative (OCI) images and\ncontainers.  The two projects differentiate in their specialization.\n\nBuildah specializes in building OCI images.  Buildah's commands replicate all\nof the commands that are found in a Dockerfile.  This allows building images\nwith and without Dockerfiles while not requiring any root privileges.\nBuildah’s ultimate goal is to provide a lower-level coreutils interface to\nbuild images.  The flexibility of building images without Dockerfiles allows\nfor the integration of other scripting languages into the build process.\nBuildah follows a simple fork-exec model and does not run as a daemon\nbut it is based on a comprehensive API in golang, which can be vendored\ninto other tools.\n\nPodman specializes in all of the commands and functions that help you to maintain and modify\nOCI images, such as pulling and tagging.  It also allows you to create, run, and maintain those containers\ncreated from those images.  For building container images via Dockerfiles, Podman uses Buildah's\ngolang API and can be installed independently from Buildah.\n\nA major difference between Podman and Buildah is their concept of a container.  Podman\nallows users to create \"traditional containers\" where the intent of these containers is\nto be long lived.  While Buildah containers are really just created to allow content\nto be added back to the container image.  An easy way to think of it is the\n`buildah run` command emulates the RUN command in a Dockerfile while the `podman run`\ncommand emulates the `docker run` command in functionality.  Because of this and their underlying\nstorage differences, you can not see Podman containers from within Buildah or vice versa.\n\nIn short, Buildah is an efficient way to create OCI images while Podman allows\nyou to manage and maintain those images and containers in a production environment using\nfamiliar container cli commands.  For more details, see the\n[Container Tools Guide](https://github.com/containers/buildah/tree/main/docs/containertools).\n\n## Example\n\nFrom [`./examples/lighttpd.sh`](examples/lighttpd.sh):\n\n```bash\n$ cat > lighttpd.sh <<\"EOF\"\n#!/usr/bin/env bash\n\nset -x\n\nctr1=$(buildah from \"${1:-fedora}\")\n\n## Get all updates and install our minimal httpd server\nbuildah run \"$ctr1\" -- dnf update -y\nbuildah run \"$ctr1\" -- dnf install -y lighttpd\n\n## Include some buildtime annotations\nbuildah config --annotation \"com.example.build.host=$(uname -n)\" \"$ctr1\"\n\n## Run our server and expose the port\nbuildah config --cmd \"/usr/sbin/lighttpd -D -f /etc/lighttpd/lighttpd.conf\" \"$ctr1\"\nbuildah config --port 80 \"$ctr1\"\n\n## Commit this container to an image name\nbuildah commit \"$ctr1\" \"${2:-$USER/lighttpd}\"\nEOF\n\n$ chmod +x lighttpd.sh\n$ ./lighttpd.sh\n```\n\n## Commands\n| Command                                              | Description                                                                                          |\n| ---------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |\n| [buildah-add(1)](/docs/buildah-add.1.md)               | Add the contents of a file, URL, or a directory to the container.                                    |\n| [buildah-build(1)](/docs/buildah-build.1.md)           | Build an image using instructions from Containerfiles or Dockerfiles.                                |\n| [buildah-commit(1)](/docs/buildah-commit.1.md)         | Create an image from a working container.                                                            |\n| [buildah-config(1)](/docs/buildah-config.1.md)         | Update image configuration settings.                                                                 |\n| [buildah-containers(1)](/docs/buildah-containers.1.md) | List the working containers and their base images.                                                   |\n| [buildah-copy(1)](/docs/buildah-copy.1.md)             | Copies the contents of a file, URL, or directory into a container's working directory.               |\n| [buildah-from(1)](/docs/buildah-from.1.md)             | Creates a new working container, either from scratch or using a specified image as a starting point. |\n| [buildah-images(1)](/docs/buildah-images.1.md)         | List images in local storage.                                                                        |\n| [buildah-info(1)](/docs/buildah-info.1.md)             | Display Buildah system information.                                                                  |\n| [buildah-inspect(1)](/docs/buildah-inspect.1.md)       | Inspects the configuration of a container or image.                                                  |\n| [buildah-mount(1)](/docs/buildah-mount.1.md)           | Mount the working container's root filesystem.                                                       |\n| [buildah-pull(1)](/docs/buildah-pull.1.md)             | Pull an image from the specified location.                                                           |\n| [buildah-push(1)](/docs/buildah-push.1.md)             | Push an image from local storage to elsewhere.                                                       |\n| [buildah-rename(1)](/docs/buildah-rename.1.md)         | Rename a local container.                                                                            |\n| [buildah-rm(1)](/docs/buildah-rm.1.md)                 | Removes one or more working containers.                                                              |\n| [buildah-rmi(1)](/docs/buildah-rmi.1.md)               | Removes one or more images.                                                                          |\n| [buildah-run(1)](/docs/buildah-run.1.md)               | Run a command inside of the container.                                                               |\n| [buildah-tag(1)](/docs/buildah-tag.1.md)               | Add an additional name to a local image.                                                             |\n| [buildah-umount(1)](/docs/buildah-umount.1.md)         | Unmount a working container's root file system.                                                      |\n| [buildah-unshare(1)](/docs/buildah-unshare.1.md)       | Launch a command in a user namespace with modified ID mappings.                                      |\n| [buildah-version(1)](/docs/buildah-version.1.md)       | Display the Buildah Version Information                                                              |\n\n**Future goals include:**\n* more CI tests\n* additional CLI commands (?)\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.2314453125,
          "content": "## Security and Disclosure Information Policy for the Buildah Project\n\nThe Buildah Project follows the [Security and Disclosure Information Policy](https://github.com/containers/common/blob/main/SECURITY.md) for the Containers Projects.\n"
        },
        {
          "name": "add.go",
          "type": "blob",
          "size": 27.208984375,
          "content": "package buildah\n\nimport (\n\t\"archive/tar\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/containers/buildah/copier\"\n\t\"github.com/containers/buildah/define\"\n\t\"github.com/containers/buildah/internal/tmpdir\"\n\t\"github.com/containers/buildah/pkg/chrootuser\"\n\t\"github.com/containers/common/pkg/retry\"\n\t\"github.com/containers/image/v5/pkg/tlsclientconfig\"\n\t\"github.com/containers/image/v5/types\"\n\t\"github.com/containers/storage/pkg/fileutils\"\n\t\"github.com/containers/storage/pkg/idtools\"\n\t\"github.com/containers/storage/pkg/regexp\"\n\t\"github.com/docker/go-connections/tlsconfig\"\n\t\"github.com/hashicorp/go-multierror\"\n\t\"github.com/moby/sys/userns\"\n\tdigest \"github.com/opencontainers/go-digest\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/sirupsen/logrus\"\n)\n\n// AddAndCopyOptions holds options for add and copy commands.\ntype AddAndCopyOptions struct {\n\t// Chmod sets the access permissions of the destination content.\n\tChmod string\n\t// Chown is a spec for the user who should be given ownership over the\n\t// newly-added content, potentially overriding permissions which would\n\t// otherwise be set to 0:0.\n\tChown string\n\t// Checksum is a standard container digest string (e.g. <algorithm>:<digest>)\n\t// and is the expected hash of the content being copied.\n\tChecksum string\n\t// PreserveOwnership, if Chown is not set, tells us to avoid setting\n\t// ownership of copied items to 0:0, instead using whatever ownership\n\t// information is already set.  Not meaningful for remote sources or\n\t// local archives that we extract.\n\tPreserveOwnership bool\n\t// All of the data being copied will pass through Hasher, if set.\n\t// If the sources are URLs or files, their contents will be passed to\n\t// Hasher.\n\t// If the sources include directory trees, Hasher will be passed\n\t// tar-format archives of the directory trees.\n\tHasher io.Writer\n\t// Excludes is the contents of the .containerignore file.\n\tExcludes []string\n\t// IgnoreFile is the path to the .containerignore file.\n\tIgnoreFile string\n\t// ContextDir is the base directory for content being copied and\n\t// Excludes patterns.\n\tContextDir string\n\t// ID mapping options to use when contents to be copied are part of\n\t// another container, and need ownerships to be mapped from the host to\n\t// that container's values before copying them into the container.\n\tIDMappingOptions *define.IDMappingOptions\n\t// DryRun indicates that the content should be digested, but not actually\n\t// copied into the container.\n\tDryRun bool\n\t// Clear the setuid bit on items being copied.  Has no effect on\n\t// archives being extracted, where the bit is always preserved.\n\tStripSetuidBit bool\n\t// Clear the setgid bit on items being copied.  Has no effect on\n\t// archives being extracted, where the bit is always preserved.\n\tStripSetgidBit bool\n\t// Clear the sticky bit on items being copied.  Has no effect on\n\t// archives being extracted, where the bit is always preserved.\n\tStripStickyBit bool\n\t// If not \"\", a directory containing a CA certificate (ending with\n\t// \".crt\"), a client certificate (ending with \".cert\") and a client\n\t// certificate key (ending with \".key\") used when downloading sources\n\t// from locations protected with TLS.\n\tCertPath string\n\t// Allow downloading sources from HTTPS where TLS verification fails.\n\tInsecureSkipTLSVerify types.OptionalBool\n\t// MaxRetries is the maximum number of attempts we'll make to retrieve\n\t// contents from a remote location.\n\tMaxRetries int\n\t// RetryDelay is how long to wait before retrying attempts to retrieve\n\t// remote contents.\n\tRetryDelay time.Duration\n}\n\n// gitURLFragmentSuffix matches fragments to use as Git reference and build\n// context from the Git repository e.g.\n//\n//\tgithub.com/containers/buildah.git\n//\tgithub.com/containers/buildah.git#main\n//\tgithub.com/containers/buildah.git#v1.35.0\nvar gitURLFragmentSuffix = regexp.Delayed(`\\.git(?:#.+)?$`)\n\n// sourceIsGit returns true if \"source\" is a git location.\nfunc sourceIsGit(source string) bool {\n\treturn isURL(source) && gitURLFragmentSuffix.MatchString(source)\n}\n\nfunc isURL(url string) bool {\n\treturn strings.HasPrefix(url, \"http://\") || strings.HasPrefix(url, \"https://\")\n}\n\n// sourceIsRemote returns true if \"source\" is a remote location\n// and *not* a git repo. Certain github urls such as raw.github.* are allowed.\nfunc sourceIsRemote(source string) bool {\n\treturn isURL(source) && !gitURLFragmentSuffix.MatchString(source)\n}\n\n// getURL writes a tar archive containing the named content\nfunc getURL(src string, chown *idtools.IDPair, mountpoint, renameTarget string, writer io.Writer, chmod *os.FileMode, srcDigest digest.Digest, certPath string, insecureSkipTLSVerify types.OptionalBool) error {\n\turl, err := url.Parse(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttlsClientConfig := &tls.Config{\n\t\tCipherSuites: tlsconfig.DefaultServerAcceptedCiphers,\n\t}\n\tif err := tlsclientconfig.SetupCertificates(certPath, tlsClientConfig); err != nil {\n\t\treturn err\n\t}\n\ttlsClientConfig.InsecureSkipVerify = insecureSkipTLSVerify == types.OptionalBoolTrue\n\n\ttr := &http.Transport{TLSClientConfig: tlsClientConfig}\n\thttpClient := &http.Client{Transport: tr}\n\tresponse, err := httpClient.Get(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer response.Body.Close()\n\n\tif response.StatusCode < http.StatusOK || response.StatusCode >= http.StatusBadRequest {\n\t\treturn fmt.Errorf(\"invalid response status %d\", response.StatusCode)\n\t}\n\n\t// Figure out what to name the new content.\n\tname := renameTarget\n\tif name == \"\" {\n\t\tname = path.Base(url.Path)\n\t}\n\t// If there's a date on the content, use it.  If not, use the Unix epoch\n\t// for compatibility.\n\tdate := time.Unix(0, 0).UTC()\n\tlastModified := response.Header.Get(\"Last-Modified\")\n\tif lastModified != \"\" {\n\t\td, err := time.Parse(time.RFC1123, lastModified)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"parsing last-modified time: %w\", err)\n\t\t}\n\t\tdate = d\n\t}\n\t// Figure out the size of the content.\n\tsize := response.ContentLength\n\tvar responseBody io.Reader = response.Body\n\tif size < 0 {\n\t\t// Create a temporary file and copy the content to it, so that\n\t\t// we can figure out how much content there is.\n\t\tf, err := os.CreateTemp(mountpoint, \"download\")\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"creating temporary file to hold %q: %w\", src, err)\n\t\t}\n\t\tdefer os.Remove(f.Name())\n\t\tdefer f.Close()\n\t\tsize, err = io.Copy(f, response.Body)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"writing %q to temporary file %q: %w\", src, f.Name(), err)\n\t\t}\n\t\t_, err = f.Seek(0, io.SeekStart)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"setting up to read %q from temporary file %q: %w\", src, f.Name(), err)\n\t\t}\n\t\tresponseBody = f\n\t}\n\tvar digester digest.Digester\n\tif srcDigest != \"\" {\n\t\tdigester = srcDigest.Algorithm().Digester()\n\t\tresponseBody = io.TeeReader(responseBody, digester.Hash())\n\t}\n\t// Write the output archive.  Set permissions for compatibility.\n\ttw := tar.NewWriter(writer)\n\tdefer tw.Close()\n\tuid := 0\n\tgid := 0\n\tif chown != nil {\n\t\tuid = chown.UID\n\t\tgid = chown.GID\n\t}\n\tvar mode int64 = 0o600\n\tif chmod != nil {\n\t\tmode = int64(*chmod)\n\t}\n\thdr := tar.Header{\n\t\tTypeflag: tar.TypeReg,\n\t\tName:     name,\n\t\tSize:     size,\n\t\tUid:      uid,\n\t\tGid:      gid,\n\t\tMode:     mode,\n\t\tModTime:  date,\n\t}\n\terr = tw.WriteHeader(&hdr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"writing header: %w\", err)\n\t}\n\n\tif _, err := io.Copy(tw, responseBody); err != nil {\n\t\treturn fmt.Errorf(\"writing content from %q to tar stream: %w\", src, err)\n\t}\n\n\tif digester != nil {\n\t\tif responseDigest := digester.Digest(); responseDigest != srcDigest {\n\t\t\treturn fmt.Errorf(\"unexpected response digest for %q: %s, want %s\", src, responseDigest, srcDigest)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// includeDirectoryAnyway returns true if \"path\" is a prefix for an exception\n// known to \"pm\".  If \"path\" is a directory that \"pm\" claims matches its list\n// of patterns, but \"pm\"'s list of exclusions contains a pattern for which\n// \"path\" is a prefix, then IncludeDirectoryAnyway() will return true.\n// This is not always correct, because it relies on the directory part of any\n// exception paths to be specified without wildcards.\nfunc includeDirectoryAnyway(path string, pm *fileutils.PatternMatcher) bool {\n\tif !pm.Exclusions() {\n\t\treturn false\n\t}\n\tprefix := strings.TrimPrefix(path, string(os.PathSeparator)) + string(os.PathSeparator)\n\tfor _, pattern := range pm.Patterns() {\n\t\tif !pattern.Exclusion() {\n\t\t\tcontinue\n\t\t}\n\t\tspec := strings.TrimPrefix(pattern.String(), string(os.PathSeparator))\n\t\tif strings.HasPrefix(spec, prefix) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// globbedToGlobbable takes a pathname which might include the '[', *, or ?\n// characters, and converts it into a glob pattern that matches itself by\n// marking the '[' characters as _not_ the beginning of match ranges and\n// escaping the * and ? characters.\nfunc globbedToGlobbable(glob string) string {\n\tresult := glob\n\tresult = strings.ReplaceAll(result, \"[\", \"[[]\")\n\tresult = strings.ReplaceAll(result, \"?\", \"\\\\?\")\n\tresult = strings.ReplaceAll(result, \"*\", \"\\\\*\")\n\treturn result\n}\n\n// Add copies the contents of the specified sources into the container's root\n// filesystem, optionally extracting contents of local files that look like\n// non-empty archives.\nfunc (b *Builder) Add(destination string, extract bool, options AddAndCopyOptions, sources ...string) error {\n\tmountPoint, err := b.Mount(b.MountLabel)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif err2 := b.Unmount(); err2 != nil {\n\t\t\tlogrus.Errorf(\"error unmounting container: %v\", err2)\n\t\t}\n\t}()\n\n\tcontextDir := options.ContextDir\n\tcurrentDir := options.ContextDir\n\tif options.ContextDir == \"\" {\n\t\tcontextDir = string(os.PathSeparator)\n\t\tcurrentDir, err = os.Getwd()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"determining current working directory: %w\", err)\n\t\t}\n\t} else {\n\t\tif !filepath.IsAbs(options.ContextDir) {\n\t\t\tcontextDir, err = filepath.Abs(options.ContextDir)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"converting context directory path %q to an absolute path: %w\", options.ContextDir, err)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Figure out what sorts of sources we have.\n\tvar localSources, remoteSources, gitSources []string\n\tfor i, src := range sources {\n\t\tif src == \"\" {\n\t\t\treturn errors.New(\"empty source location\")\n\t\t}\n\t\tif sourceIsRemote(src) {\n\t\t\tremoteSources = append(remoteSources, src)\n\t\t\tcontinue\n\t\t}\n\t\tif sourceIsGit(src) {\n\t\t\tgitSources = append(gitSources, src)\n\t\t\tcontinue\n\t\t}\n\t\tif !filepath.IsAbs(src) && options.ContextDir == \"\" {\n\t\t\tsources[i] = filepath.Join(currentDir, src)\n\t\t}\n\t\tlocalSources = append(localSources, sources[i])\n\t}\n\n\t// Treat git sources as a subset of remote sources\n\t// differentiating only in how we fetch the two later on.\n\tif len(gitSources) > 0 {\n\t\tremoteSources = append(remoteSources, gitSources...)\n\t}\n\n\t// Check how many items our local source specs matched.  Each spec\n\t// should have matched at least one item, otherwise we consider it an\n\t// error.\n\tvar localSourceStats []*copier.StatsForGlob\n\tif len(localSources) > 0 {\n\t\tstatOptions := copier.StatOptions{\n\t\t\tCheckForArchives: extract,\n\t\t}\n\t\tlocalSourceStats, err = copier.Stat(contextDir, contextDir, statOptions, localSources)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"checking on sources under %q: %w\", contextDir, err)\n\t\t}\n\t}\n\tnumLocalSourceItems := 0\n\tfor _, localSourceStat := range localSourceStats {\n\t\tif localSourceStat.Error != \"\" {\n\t\t\terrorText := localSourceStat.Error\n\t\t\trel, err := filepath.Rel(contextDir, localSourceStat.Glob)\n\t\t\tif err != nil {\n\t\t\t\terrorText = fmt.Sprintf(\"%v; %s\", err, errorText)\n\t\t\t}\n\t\t\tif strings.HasPrefix(rel, \"..\"+string(os.PathSeparator)) {\n\t\t\t\terrorText = fmt.Sprintf(\"possible escaping context directory error: %s\", errorText)\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"checking on sources under %q: %v\", contextDir, errorText)\n\t\t}\n\t\tif len(localSourceStat.Globbed) == 0 {\n\t\t\treturn fmt.Errorf(\"checking source under %q: no glob matches: %w\", contextDir, syscall.ENOENT)\n\t\t}\n\t\tnumLocalSourceItems += len(localSourceStat.Globbed)\n\t}\n\tif numLocalSourceItems+len(remoteSources)+len(gitSources) == 0 {\n\t\treturn fmt.Errorf(\"no sources %v found: %w\", sources, syscall.ENOENT)\n\t}\n\n\t// Find out which user (and group) the destination should belong to.\n\tvar chownDirs, chownFiles *idtools.IDPair\n\tvar userUID, userGID uint32\n\tif options.Chown != \"\" {\n\t\tuserUID, userGID, err = b.userForCopy(mountPoint, options.Chown)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"looking up UID/GID for %q: %w\", options.Chown, err)\n\t\t}\n\t}\n\tvar chmodDirsFiles *os.FileMode\n\tif options.Chmod != \"\" {\n\t\tp, err := strconv.ParseUint(options.Chmod, 8, 32)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"parsing chmod %q: %w\", options.Chmod, err)\n\t\t}\n\t\tperm := os.FileMode(p)\n\t\tchmodDirsFiles = &perm\n\t}\n\n\tchownDirs = &idtools.IDPair{UID: int(userUID), GID: int(userGID)}\n\tchownFiles = &idtools.IDPair{UID: int(userUID), GID: int(userGID)}\n\tif options.Chown == \"\" && options.PreserveOwnership {\n\t\tchownDirs = nil\n\t\tchownFiles = nil\n\t}\n\n\t// If we have a single source archive to extract, or more than one\n\t// source item, or the destination has a path separator at the end of\n\t// it, and it's not a remote URL, the destination needs to be a\n\t// directory.\n\tif destination == \"\" || !filepath.IsAbs(destination) {\n\t\ttmpDestination := filepath.Join(string(os.PathSeparator)+b.WorkDir(), destination)\n\t\tif destination == \"\" || strings.HasSuffix(destination, string(os.PathSeparator)) {\n\t\t\tdestination = tmpDestination + string(os.PathSeparator)\n\t\t} else {\n\t\t\tdestination = tmpDestination\n\t\t}\n\t}\n\tdestMustBeDirectory := (len(sources) > 1) || strings.HasSuffix(destination, string(os.PathSeparator)) || destination == b.WorkDir()\n\tdestCanBeFile := false\n\tif len(sources) == 1 {\n\t\tif len(remoteSources) == 1 {\n\t\t\tdestCanBeFile = sourceIsRemote(sources[0])\n\t\t}\n\t\tif len(localSources) == 1 {\n\t\t\titem := localSourceStats[0].Results[localSourceStats[0].Globbed[0]]\n\t\t\tif item.IsDir || (item.IsArchive && extract) {\n\t\t\t\tdestMustBeDirectory = true\n\t\t\t}\n\t\t\tif item.IsRegular {\n\t\t\t\tdestCanBeFile = true\n\t\t\t}\n\t\t}\n\t\tif len(gitSources) > 0 {\n\t\t\tdestMustBeDirectory = true\n\t\t}\n\t}\n\n\t// We care if the destination either doesn't exist, or exists and is a\n\t// file.  If the source can be a single file, for those cases we treat\n\t// the destination as a file rather than as a directory tree.\n\trenameTarget := \"\"\n\textractDirectory := filepath.Join(mountPoint, destination)\n\tstatOptions := copier.StatOptions{\n\t\tCheckForArchives: extract,\n\t}\n\tdestStats, err := copier.Stat(mountPoint, filepath.Join(mountPoint, b.WorkDir()), statOptions, []string{extractDirectory})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"checking on destination %v: %w\", extractDirectory, err)\n\t}\n\tif (len(destStats) == 0 || len(destStats[0].Globbed) == 0) && !destMustBeDirectory && destCanBeFile {\n\t\t// destination doesn't exist - extract to parent and rename the incoming file to the destination's name\n\t\trenameTarget = filepath.Base(extractDirectory)\n\t\textractDirectory = filepath.Dir(extractDirectory)\n\t}\n\n\t// if the destination is a directory that doesn't yet exist, let's copy it.\n\tnewDestDirFound := false\n\tif (len(destStats) == 1 || len(destStats[0].Globbed) == 0) && destMustBeDirectory && !destCanBeFile {\n\t\tnewDestDirFound = true\n\t}\n\n\tif len(destStats) == 1 && len(destStats[0].Globbed) == 1 && destStats[0].Results[destStats[0].Globbed[0]].IsRegular {\n\t\tif destMustBeDirectory {\n\t\t\treturn fmt.Errorf(\"destination %v already exists but is not a directory\", destination)\n\t\t}\n\t\t// destination exists - it's a file, we need to extract to parent and rename the incoming file to the destination's name\n\t\trenameTarget = filepath.Base(extractDirectory)\n\t\textractDirectory = filepath.Dir(extractDirectory)\n\t}\n\n\tpm, err := fileutils.NewPatternMatcher(options.Excludes)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"processing excludes list %v: %w\", options.Excludes, err)\n\t}\n\n\t// Make sure that, if it's a symlink, we'll chroot to the target of the link;\n\t// knowing that target requires that we resolve it within the chroot.\n\tevalOptions := copier.EvalOptions{}\n\tevaluated, err := copier.Eval(mountPoint, extractDirectory, evalOptions)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"checking on destination %v: %w\", extractDirectory, err)\n\t}\n\textractDirectory = evaluated\n\n\t// Set up ID maps.\n\tvar srcUIDMap, srcGIDMap []idtools.IDMap\n\tif options.IDMappingOptions != nil {\n\t\tsrcUIDMap, srcGIDMap = convertRuntimeIDMaps(options.IDMappingOptions.UIDMap, options.IDMappingOptions.GIDMap)\n\t}\n\tdestUIDMap, destGIDMap := convertRuntimeIDMaps(b.IDMappingOptions.UIDMap, b.IDMappingOptions.GIDMap)\n\n\t// Create the target directory if it doesn't exist yet.\n\tmkdirOptions := copier.MkdirOptions{\n\t\tUIDMap:   destUIDMap,\n\t\tGIDMap:   destGIDMap,\n\t\tChownNew: chownDirs,\n\t}\n\tif err := copier.Mkdir(mountPoint, extractDirectory, mkdirOptions); err != nil {\n\t\treturn fmt.Errorf(\"ensuring target directory exists: %w\", err)\n\t}\n\n\t// Copy each source in turn.\n\tfor _, src := range sources {\n\t\tvar multiErr *multierror.Error\n\t\tvar getErr, closeErr, renameErr, putErr error\n\t\tvar wg sync.WaitGroup\n\t\tif sourceIsRemote(src) || sourceIsGit(src) {\n\t\t\tpipeReader, pipeWriter := io.Pipe()\n\t\t\tvar srcDigest digest.Digest\n\t\t\tif options.Checksum != \"\" {\n\t\t\t\tsrcDigest, err = digest.Parse(options.Checksum)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"invalid checksum flag: %w\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twg.Add(1)\n\t\t\tif sourceIsGit(src) {\n\t\t\t\tgo func() {\n\t\t\t\t\tvar cloneDir string\n\t\t\t\t\tcloneDir, _, getErr = define.TempDirForURL(tmpdir.GetTempDir(), \"\", src)\n\t\t\t\t\tgetOptions := copier.GetOptions{\n\t\t\t\t\t\tUIDMap:         srcUIDMap,\n\t\t\t\t\t\tGIDMap:         srcGIDMap,\n\t\t\t\t\t\tExcludes:       options.Excludes,\n\t\t\t\t\t\tExpandArchives: extract,\n\t\t\t\t\t\tChownDirs:      chownDirs,\n\t\t\t\t\t\tChmodDirs:      chmodDirsFiles,\n\t\t\t\t\t\tChownFiles:     chownFiles,\n\t\t\t\t\t\tChmodFiles:     chmodDirsFiles,\n\t\t\t\t\t\tStripSetuidBit: options.StripSetuidBit,\n\t\t\t\t\t\tStripSetgidBit: options.StripSetgidBit,\n\t\t\t\t\t\tStripStickyBit: options.StripStickyBit,\n\t\t\t\t\t}\n\t\t\t\t\twriter := io.WriteCloser(pipeWriter)\n\t\t\t\t\tgetErr = copier.Get(cloneDir, cloneDir, getOptions, []string{\".\"}, writer)\n\t\t\t\t\tpipeWriter.Close()\n\t\t\t\t\twg.Done()\n\t\t\t\t}()\n\t\t\t} else {\n\t\t\t\tgo func() {\n\t\t\t\t\tgetErr = retry.IfNecessary(context.TODO(), func() error {\n\t\t\t\t\t\treturn getURL(src, chownFiles, mountPoint, renameTarget, pipeWriter, chmodDirsFiles, srcDigest, options.CertPath, options.InsecureSkipTLSVerify)\n\t\t\t\t\t}, &retry.Options{\n\t\t\t\t\t\tMaxRetry: options.MaxRetries,\n\t\t\t\t\t\tDelay:    options.RetryDelay,\n\t\t\t\t\t})\n\t\t\t\t\tpipeWriter.Close()\n\t\t\t\t\twg.Done()\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tb.ContentDigester.Start(\"\")\n\t\t\t\thashCloser := b.ContentDigester.Hash()\n\t\t\t\thasher := io.Writer(hashCloser)\n\t\t\t\tif options.Hasher != nil {\n\t\t\t\t\thasher = io.MultiWriter(hasher, options.Hasher)\n\t\t\t\t}\n\t\t\t\tif options.DryRun {\n\t\t\t\t\t_, putErr = io.Copy(hasher, pipeReader)\n\t\t\t\t} else {\n\t\t\t\t\tputOptions := copier.PutOptions{\n\t\t\t\t\t\tUIDMap:        destUIDMap,\n\t\t\t\t\t\tGIDMap:        destGIDMap,\n\t\t\t\t\t\tChownDirs:     nil,\n\t\t\t\t\t\tChmodDirs:     nil,\n\t\t\t\t\t\tChownFiles:    nil,\n\t\t\t\t\t\tChmodFiles:    nil,\n\t\t\t\t\t\tIgnoreDevices: userns.RunningInUserNS(),\n\t\t\t\t\t}\n\t\t\t\t\tputErr = copier.Put(extractDirectory, extractDirectory, putOptions, io.TeeReader(pipeReader, hasher))\n\t\t\t\t}\n\t\t\t\thashCloser.Close()\n\t\t\t\tpipeReader.Close()\n\t\t\t\twg.Done()\n\t\t\t}()\n\t\t\twg.Wait()\n\t\t\tif getErr != nil {\n\t\t\t\tgetErr = fmt.Errorf(\"reading %q: %w\", src, getErr)\n\t\t\t}\n\t\t\tif putErr != nil {\n\t\t\t\tputErr = fmt.Errorf(\"storing %q: %w\", src, putErr)\n\t\t\t}\n\t\t\tmultiErr = multierror.Append(getErr, putErr)\n\t\t\tif multiErr != nil && multiErr.ErrorOrNil() != nil {\n\t\t\t\tif len(multiErr.Errors) > 1 {\n\t\t\t\t\treturn multiErr.ErrorOrNil()\n\t\t\t\t}\n\t\t\t\treturn multiErr.Errors[0]\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif options.Checksum != \"\" {\n\t\t\treturn fmt.Errorf(\"checksum flag is not supported for local sources\")\n\t\t}\n\n\t\t// Dig out the result of running glob+stat on this source spec.\n\t\tvar localSourceStat *copier.StatsForGlob\n\t\tfor _, st := range localSourceStats {\n\t\t\tif st.Glob == src {\n\t\t\t\tlocalSourceStat = st\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif localSourceStat == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Iterate through every item that matched the glob.\n\t\titemsCopied := 0\n\t\tfor _, globbed := range localSourceStat.Globbed {\n\t\t\trel := globbed\n\t\t\tif filepath.IsAbs(globbed) {\n\t\t\t\tif rel, err = filepath.Rel(contextDir, globbed); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"computing path of %q relative to %q: %w\", globbed, contextDir, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif strings.HasPrefix(rel, \"..\"+string(os.PathSeparator)) {\n\t\t\t\treturn fmt.Errorf(\"possible escaping context directory error: %q is outside of %q\", globbed, contextDir)\n\t\t\t}\n\t\t\t// Check for dockerignore-style exclusion of this item.\n\t\t\tif rel != \".\" {\n\t\t\t\texcluded, err := pm.Matches(filepath.ToSlash(rel)) // nolint:staticcheck\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"checking if %q(%q) is excluded: %w\", globbed, rel, err)\n\t\t\t\t}\n\t\t\t\tif excluded {\n\t\t\t\t\t// non-directories that are excluded are excluded, no question, but\n\t\t\t\t\t// directories can only be skipped if we don't have to allow for the\n\t\t\t\t\t// possibility of finding things to include under them\n\t\t\t\t\tglobInfo := localSourceStat.Results[globbed]\n\t\t\t\t\tif !globInfo.IsDir || !includeDirectoryAnyway(rel, pm) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// if the destination is a directory that doesn't yet exist, and is not excluded, let's copy it.\n\t\t\t\t\tif newDestDirFound {\n\t\t\t\t\t\titemsCopied++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Make sure we don't trigger a \"copied nothing\" error for an empty context\n\t\t\t\t// directory if we were told to copy the context directory itself.  We won't\n\t\t\t\t// actually copy it, but we need to make sure that we don't produce an error\n\t\t\t\t// due to potentially not having anything in the tarstream that we passed.\n\t\t\t\titemsCopied++\n\t\t\t}\n\t\t\tst := localSourceStat.Results[globbed]\n\t\t\tpipeReader, pipeWriter := io.Pipe()\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\trenamedItems := 0\n\t\t\t\twriter := io.WriteCloser(pipeWriter)\n\t\t\t\tif renameTarget != \"\" {\n\t\t\t\t\twriter = newTarFilterer(writer, func(hdr *tar.Header) (bool, bool, io.Reader) {\n\t\t\t\t\t\thdr.Name = renameTarget\n\t\t\t\t\t\trenamedItems++\n\t\t\t\t\t\treturn false, false, nil\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\twriter = newTarFilterer(writer, func(_ *tar.Header) (bool, bool, io.Reader) {\n\t\t\t\t\titemsCopied++\n\t\t\t\t\treturn false, false, nil\n\t\t\t\t})\n\t\t\t\tgetOptions := copier.GetOptions{\n\t\t\t\t\tUIDMap:         srcUIDMap,\n\t\t\t\t\tGIDMap:         srcGIDMap,\n\t\t\t\t\tExcludes:       options.Excludes,\n\t\t\t\t\tExpandArchives: extract,\n\t\t\t\t\tChownDirs:      chownDirs,\n\t\t\t\t\tChmodDirs:      chmodDirsFiles,\n\t\t\t\t\tChownFiles:     chownFiles,\n\t\t\t\t\tChmodFiles:     chmodDirsFiles,\n\t\t\t\t\tStripSetuidBit: options.StripSetuidBit,\n\t\t\t\t\tStripSetgidBit: options.StripSetgidBit,\n\t\t\t\t\tStripStickyBit: options.StripStickyBit,\n\t\t\t\t}\n\t\t\t\tgetErr = copier.Get(contextDir, contextDir, getOptions, []string{globbedToGlobbable(globbed)}, writer)\n\t\t\t\tcloseErr = writer.Close()\n\t\t\t\tif renameTarget != \"\" && renamedItems > 1 {\n\t\t\t\t\trenameErr = fmt.Errorf(\"internal error: renamed %d items when we expected to only rename 1\", renamedItems)\n\t\t\t\t}\n\t\t\t\twg.Done()\n\t\t\t}()\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tif st.IsDir {\n\t\t\t\t\tb.ContentDigester.Start(\"dir\")\n\t\t\t\t} else {\n\t\t\t\t\tb.ContentDigester.Start(\"file\")\n\t\t\t\t}\n\t\t\t\thashCloser := b.ContentDigester.Hash()\n\t\t\t\thasher := io.Writer(hashCloser)\n\t\t\t\tif options.Hasher != nil {\n\t\t\t\t\thasher = io.MultiWriter(hasher, options.Hasher)\n\t\t\t\t}\n\t\t\t\tif options.DryRun {\n\t\t\t\t\t_, putErr = io.Copy(hasher, pipeReader)\n\t\t\t\t} else {\n\t\t\t\t\tputOptions := copier.PutOptions{\n\t\t\t\t\t\tUIDMap:          destUIDMap,\n\t\t\t\t\t\tGIDMap:          destGIDMap,\n\t\t\t\t\t\tDefaultDirOwner: chownDirs,\n\t\t\t\t\t\tDefaultDirMode:  nil,\n\t\t\t\t\t\tChownDirs:       nil,\n\t\t\t\t\t\tChmodDirs:       nil,\n\t\t\t\t\t\tChownFiles:      nil,\n\t\t\t\t\t\tChmodFiles:      nil,\n\t\t\t\t\t\tIgnoreDevices:   userns.RunningInUserNS(),\n\t\t\t\t\t}\n\t\t\t\t\tputErr = copier.Put(extractDirectory, extractDirectory, putOptions, io.TeeReader(pipeReader, hasher))\n\t\t\t\t}\n\t\t\t\thashCloser.Close()\n\t\t\t\tpipeReader.Close()\n\t\t\t\twg.Done()\n\t\t\t}()\n\t\t\twg.Wait()\n\t\t\tif getErr != nil {\n\t\t\t\tgetErr = fmt.Errorf(\"reading %q: %w\", src, getErr)\n\t\t\t}\n\t\t\tif closeErr != nil {\n\t\t\t\tcloseErr = fmt.Errorf(\"closing %q: %w\", src, closeErr)\n\t\t\t}\n\t\t\tif renameErr != nil {\n\t\t\t\trenameErr = fmt.Errorf(\"renaming %q: %w\", src, renameErr)\n\t\t\t}\n\t\t\tif putErr != nil {\n\t\t\t\tputErr = fmt.Errorf(\"storing %q: %w\", src, putErr)\n\t\t\t}\n\t\t\tmultiErr = multierror.Append(getErr, closeErr, renameErr, putErr)\n\t\t\tif multiErr != nil && multiErr.ErrorOrNil() != nil {\n\t\t\t\tif len(multiErr.Errors) > 1 {\n\t\t\t\t\treturn multiErr.ErrorOrNil()\n\t\t\t\t}\n\t\t\t\treturn multiErr.Errors[0]\n\t\t\t}\n\t\t}\n\t\tif itemsCopied == 0 {\n\t\t\texcludesFile := \"\"\n\t\t\tif options.IgnoreFile != \"\" {\n\t\t\t\texcludesFile = \" using \" + options.IgnoreFile\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"no items matching glob %q copied (%d filtered out%s): %w\", localSourceStat.Glob, len(localSourceStat.Globbed), excludesFile, syscall.ENOENT)\n\t\t}\n\t}\n\treturn nil\n}\n\n// userForRun returns the user (and group) information which we should use for\n// running commands\nfunc (b *Builder) userForRun(mountPoint string, userspec string) (specs.User, string, error) {\n\tif userspec == \"\" {\n\t\tuserspec = b.User()\n\t}\n\n\tuid, gid, homeDir, err := chrootuser.GetUser(mountPoint, userspec)\n\tu := specs.User{\n\t\tUID:      uid,\n\t\tGID:      gid,\n\t\tUsername: userspec,\n\t}\n\tif !strings.Contains(userspec, \":\") {\n\t\tgroups, err2 := chrootuser.GetAdditionalGroupsForUser(mountPoint, uint64(u.UID))\n\t\tif err2 != nil {\n\t\t\tif !errors.Is(err2, chrootuser.ErrNoSuchUser) && err == nil {\n\t\t\t\terr = err2\n\t\t\t}\n\t\t} else {\n\t\t\tu.AdditionalGids = groups\n\t\t}\n\t}\n\treturn u, homeDir, err\n}\n\n// userForCopy returns the user (and group) information which we should use for\n// setting ownership of contents being copied.  It's just like what\n// userForRun() does, except for the case where we're passed a single numeric\n// value, where we need to use that value for both the UID and the GID.\nfunc (b *Builder) userForCopy(mountPoint string, userspec string) (uint32, uint32, error) {\n\tvar (\n\t\tuser, group string\n\t\tuid, gid    uint64\n\t\terr         error\n\t)\n\n\tsplit := strings.SplitN(userspec, \":\", 2)\n\tuser = split[0]\n\tif len(split) > 1 {\n\t\tgroup = split[1]\n\t}\n\n\t// If userspec did not specify any values for user or group, then fail\n\tif user == \"\" && group == \"\" {\n\t\treturn 0, 0, fmt.Errorf(\"can't find uid for user %s\", userspec)\n\t}\n\n\t// If userspec specifies values for user or group, check for numeric values\n\t// and return early.  If not, then translate username/groupname\n\tif user != \"\" {\n\t\tuid, err = strconv.ParseUint(user, 10, 32)\n\t}\n\tif err == nil {\n\t\t// default gid to uid\n\t\tgid = uid\n\t\tif group != \"\" {\n\t\t\tgid, err = strconv.ParseUint(group, 10, 32)\n\t\t}\n\t}\n\t// If err != nil, then user or group not numeric, check filesystem\n\tif err == nil {\n\t\treturn uint32(uid), uint32(gid), nil\n\t}\n\n\towner, _, err := b.userForRun(mountPoint, userspec)\n\tif err != nil {\n\t\treturn 0xffffffff, 0xffffffff, err\n\t}\n\treturn owner.UID, owner.GID, nil\n}\n\n// EnsureContainerPathAs creates the specified directory if it doesn't exist,\n// setting a newly-created directory's owner to USER and its permissions to MODE.\nfunc (b *Builder) EnsureContainerPathAs(path, user string, mode *os.FileMode) error {\n\tmountPoint, err := b.Mount(b.MountLabel)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif err2 := b.Unmount(); err2 != nil {\n\t\t\tlogrus.Errorf(\"error unmounting container: %v\", err2)\n\t\t}\n\t}()\n\n\tuid, gid := uint32(0), uint32(0)\n\tif user != \"\" {\n\t\tif uidForCopy, gidForCopy, err := b.userForCopy(mountPoint, user); err == nil {\n\t\t\tuid = uidForCopy\n\t\t\tgid = gidForCopy\n\t\t}\n\t}\n\n\tdestUIDMap, destGIDMap := convertRuntimeIDMaps(b.IDMappingOptions.UIDMap, b.IDMappingOptions.GIDMap)\n\n\tidPair := &idtools.IDPair{UID: int(uid), GID: int(gid)}\n\topts := copier.MkdirOptions{\n\t\tChmodNew: mode,\n\t\tChownNew: idPair,\n\t\tUIDMap:   destUIDMap,\n\t\tGIDMap:   destGIDMap,\n\t}\n\treturn copier.Mkdir(mountPoint, filepath.Join(mountPoint, path), opts)\n}\n"
        },
        {
          "name": "bind",
          "type": "tree",
          "content": null
        },
        {
          "name": "btrfs_installed_tag.sh",
          "type": "blob",
          "size": 0.1708984375,
          "content": "#!/usr/bin/env bash\n${CPP:-${CC:-cc} -E} ${CPPFLAGS} - > /dev/null 2> /dev/null << EOF\n#include <btrfs/ioctl.h>\nEOF\nif test $? -ne 0 ; then\n\techo exclude_graphdriver_btrfs\nfi\n"
        },
        {
          "name": "btrfs_tag.sh",
          "type": "blob",
          "size": 0.1630859375,
          "content": "#!/usr/bin/env bash\n${CPP:-${CC:-cc} -E} ${CPPFLAGS} - > /dev/null 2> /dev/null << EOF\n#include <btrfs/version.h>\nEOF\nif test $? -ne 0 ; then\n\techo btrfs_noversion\nfi\n"
        },
        {
          "name": "buildah.go",
          "type": "blob",
          "size": 23.8916015625,
          "content": "package buildah\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"time\"\n\n\t\"github.com/containers/buildah/define\"\n\t\"github.com/containers/buildah/docker\"\n\tnettypes \"github.com/containers/common/libnetwork/types\"\n\t\"github.com/containers/image/v5/types\"\n\tencconfig \"github.com/containers/ocicrypt/config\"\n\t\"github.com/containers/storage\"\n\t\"github.com/containers/storage/pkg/ioutils\"\n\tv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/sirupsen/logrus\"\n)\n\nconst (\n\t// Package is the name of this package, used in help output and to\n\t// identify working containers.\n\tPackage = define.Package\n\t// Version for the Package.\n\tVersion = define.Version\n\t// The value we use to identify what type of information, currently a\n\t// serialized Builder structure, we are using as per-container state.\n\t// This should only be changed when we make incompatible changes to\n\t// that data structure, as it's used to distinguish containers which\n\t// are \"ours\" from ones that aren't.\n\tcontainerType = Package + \" 0.0.1\"\n\t// The file in the per-container directory which we use to store our\n\t// per-container state.  If it isn't there, then the container isn't\n\t// one of our build containers.\n\tstateFile = Package + \".json\"\n)\n\n// PullPolicy takes the value PullIfMissing, PullAlways, PullIfNewer, or PullNever.\ntype PullPolicy = define.PullPolicy\n\nconst (\n\t// PullIfMissing is one of the values that BuilderOptions.PullPolicy\n\t// can take, signalling that the source image should be pulled from a\n\t// registry if a local copy of it is not already present.\n\tPullIfMissing = define.PullIfMissing\n\t// PullAlways is one of the values that BuilderOptions.PullPolicy can\n\t// take, signalling that a fresh, possibly updated, copy of the image\n\t// should be pulled from a registry before the build proceeds.\n\tPullAlways = define.PullAlways\n\t// PullIfNewer is one of the values that BuilderOptions.PullPolicy\n\t// can take, signalling that the source image should only be pulled\n\t// from a registry if a local copy is not already present or if a\n\t// newer version the image is present on the repository.\n\tPullIfNewer = define.PullIfNewer\n\t// PullNever is one of the values that BuilderOptions.PullPolicy can\n\t// take, signalling that the source image should not be pulled from a\n\t// registry if a local copy of it is not already present.\n\tPullNever = define.PullNever\n)\n\n// NetworkConfigurationPolicy takes the value NetworkDefault, NetworkDisabled,\n// or NetworkEnabled.\ntype NetworkConfigurationPolicy = define.NetworkConfigurationPolicy\n\nconst (\n\t// NetworkDefault is one of the values that BuilderOptions.ConfigureNetwork\n\t// can take, signalling that the default behavior should be used.\n\tNetworkDefault = define.NetworkDefault\n\t// NetworkDisabled is one of the values that BuilderOptions.ConfigureNetwork\n\t// can take, signalling that network interfaces should NOT be configured for\n\t// newly-created network namespaces.\n\tNetworkDisabled = define.NetworkDisabled\n\t// NetworkEnabled is one of the values that BuilderOptions.ConfigureNetwork\n\t// can take, signalling that network interfaces should be configured for\n\t// newly-created network namespaces.\n\tNetworkEnabled = define.NetworkEnabled\n)\n\n// Builder objects are used to represent containers which are being used to\n// build images.  They also carry potential updates which will be applied to\n// the image's configuration when the container's contents are used to build an\n// image.\ntype Builder struct {\n\tstore storage.Store\n\n\t// Logger is the logrus logger to write log messages with\n\tLogger *logrus.Logger `json:\"-\"`\n\n\t// Args define variables that users can pass at build-time to the builder.\n\tArgs map[string]string\n\t// Type is used to help identify a build container's metadata.  It\n\t// should not be modified.\n\tType string `json:\"type\"`\n\t// FromImage is the name of the source image which was used to create\n\t// the container, if one was used.  It should not be modified.\n\tFromImage string `json:\"image,omitempty\"`\n\t// FromImageID is the ID of the source image which was used to create\n\t// the container, if one was used.  It should not be modified.\n\tFromImageID string `json:\"image-id\"`\n\t// FromImageDigest is the digest of the source image which was used to\n\t// create the container, if one was used.  It should not be modified.\n\tFromImageDigest string `json:\"image-digest\"`\n\t// Config is the source image's configuration.  It should not be\n\t// modified.\n\tConfig []byte `json:\"config,omitempty\"`\n\t// Manifest is the source image's manifest.  It should not be modified.\n\tManifest []byte `json:\"manifest,omitempty\"`\n\n\t// Container is the name of the build container.  It should not be modified.\n\tContainer string `json:\"container-name,omitempty\"`\n\t// ContainerID is the ID of the build container.  It should not be modified.\n\tContainerID string `json:\"container-id,omitempty\"`\n\t// MountPoint is the last location where the container's root\n\t// filesystem was mounted.  It should not be modified.\n\tMountPoint string `json:\"mountpoint,omitempty\"`\n\t// ProcessLabel is the SELinux process label to use during subsequent Run() calls.\n\tProcessLabel string `json:\"process-label,omitempty\"`\n\t// MountLabel is the SELinux mount label associated with the container\n\tMountLabel string `json:\"mount-label,omitempty\"`\n\n\t// ImageAnnotations is a set of key-value pairs which is stored in the\n\t// image's manifest.\n\tImageAnnotations map[string]string `json:\"annotations,omitempty\"`\n\t// ImageCreatedBy is a description of how this container was built.\n\tImageCreatedBy string `json:\"created-by,omitempty\"`\n\t// ImageHistoryComment is a description of how our added layers were built.\n\tImageHistoryComment string `json:\"history-comment,omitempty\"`\n\n\t// Image metadata and runtime settings, in multiple formats.\n\tOCIv1  v1.Image       `json:\"ociv1,omitempty\"`\n\tDocker docker.V2Image `json:\"docker,omitempty\"`\n\t// DefaultMountsFilePath is the file path holding the mounts to be mounted in \"host-path:container-path\" format.\n\tDefaultMountsFilePath string `json:\"defaultMountsFilePath,omitempty\"`\n\n\t// Isolation controls how we handle \"RUN\" statements and the Run() method.\n\tIsolation define.Isolation\n\t// NamespaceOptions controls how we set up the namespaces for processes that we Run().\n\tNamespaceOptions define.NamespaceOptions\n\t// ConfigureNetwork controls whether or not network interfaces and\n\t// routing are configured for a new network namespace (i.e., when not\n\t// joining another's namespace and not just using the host's\n\t// namespace), effectively deciding whether or not the process has a\n\t// usable network.\n\tConfigureNetwork define.NetworkConfigurationPolicy\n\t// CNIPluginPath is the location of CNI plugin helpers, if they should be\n\t// run from a location other than the default location.\n\tCNIPluginPath string\n\t// CNIConfigDir is the location of CNI configuration files, if the files in\n\t// the default configuration directory shouldn't be used.\n\tCNIConfigDir string\n\n\t// NetworkInterface is the libnetwork network interface used to setup CNI or netavark networks.\n\tNetworkInterface nettypes.ContainerNetwork `json:\"-\"`\n\n\t// GroupAdd is a list of groups to add to the primary process when Run() is\n\t// called. The magic 'keep-groups' value indicates that the process should\n\t// be allowed to inherit the current set of supplementary groups.\n\tGroupAdd []string\n\t// ID mapping options to use when running processes with non-host user namespaces.\n\tIDMappingOptions define.IDMappingOptions\n\t// Capabilities is a list of capabilities to use when running commands in the container.\n\tCapabilities []string\n\t// PrependedEmptyLayers are history entries that we'll add to a\n\t// committed image, after any history items that we inherit from a base\n\t// image, but before the history item for the layer that we're\n\t// committing.\n\tPrependedEmptyLayers []v1.History\n\t// AppendedEmptyLayers are history entries that we'll add to a\n\t// committed image after the history item for the layer that we're\n\t// committing.\n\tAppendedEmptyLayers []v1.History\n\tCommonBuildOpts     *define.CommonBuildOptions\n\t// TopLayer is the top layer of the image\n\tTopLayer string\n\t// Format to use for a container image we eventually commit, when we do.\n\tFormat string\n\t// TempVolumes are temporary mount points created during Run() calls.\n\tTempVolumes map[string]bool\n\t// ContentDigester counts the digest of all Add()ed content since it was\n\t// last restarted.\n\tContentDigester CompositeDigester\n\t// Devices are parsed additional devices to provide to Run() calls.\n\tDevices define.ContainerDevices\n\t// DeviceSpecs are unparsed additional devices to provide to Run() calls.\n\tDeviceSpecs []string\n\t// CDIConfigDir is the location of CDI configuration files, if the files in\n\t// the default configuration locations shouldn't be used.\n\tCDIConfigDir string\n\t// PrependedLinkedLayers and AppendedLinkedLayers are combinations of\n\t// history entries and locations of either directory trees (if\n\t// directories, per os.Stat()) or uncompressed layer blobs which should\n\t// be added to the image at commit-time.  The order of these relative\n\t// to PrependedEmptyLayers and AppendedEmptyLayers in the committed\n\t// image is not guaranteed.\n\tPrependedLinkedLayers, AppendedLinkedLayers []LinkedLayer\n}\n\n// BuilderInfo are used as objects to display container information\ntype BuilderInfo struct {\n\tType                  string\n\tFromImage             string\n\tFromImageID           string\n\tFromImageDigest       string\n\tGroupAdd              []string\n\tConfig                string\n\tManifest              string\n\tContainer             string\n\tContainerID           string\n\tMountPoint            string\n\tProcessLabel          string\n\tMountLabel            string\n\tImageAnnotations      map[string]string\n\tImageCreatedBy        string\n\tOCIv1                 v1.Image\n\tDocker                docker.V2Image\n\tDefaultMountsFilePath string\n\tIsolation             string\n\tNamespaceOptions      define.NamespaceOptions\n\tCapabilities          []string\n\tConfigureNetwork      string\n\tCNIPluginPath         string\n\tCNIConfigDir          string\n\tIDMappingOptions      define.IDMappingOptions\n\tHistory               []v1.History\n\tDevices               define.ContainerDevices\n\tDeviceSpecs           []string\n\tCDIConfigDir          string\n}\n\n// GetBuildInfo gets a pointer to a Builder object and returns a BuilderInfo object from it.\n// This is used in the inspect command to display Manifest and Config as string and not []byte.\nfunc GetBuildInfo(b *Builder) BuilderInfo {\n\thistory := copyHistory(b.OCIv1.History)\n\thistory = append(history, copyHistory(b.PrependedEmptyLayers)...)\n\thistory = append(history, copyHistory(b.AppendedEmptyLayers)...)\n\tsort.Strings(b.Capabilities)\n\treturn BuilderInfo{\n\t\tType:                  b.Type,\n\t\tFromImage:             b.FromImage,\n\t\tFromImageID:           b.FromImageID,\n\t\tFromImageDigest:       b.FromImageDigest,\n\t\tConfig:                string(b.Config),\n\t\tManifest:              string(b.Manifest),\n\t\tContainer:             b.Container,\n\t\tContainerID:           b.ContainerID,\n\t\tGroupAdd:              b.GroupAdd,\n\t\tMountPoint:            b.MountPoint,\n\t\tProcessLabel:          b.ProcessLabel,\n\t\tMountLabel:            b.MountLabel,\n\t\tImageAnnotations:      b.ImageAnnotations,\n\t\tImageCreatedBy:        b.ImageCreatedBy,\n\t\tOCIv1:                 b.OCIv1,\n\t\tDocker:                b.Docker,\n\t\tDefaultMountsFilePath: b.DefaultMountsFilePath,\n\t\tIsolation:             b.Isolation.String(),\n\t\tNamespaceOptions:      b.NamespaceOptions,\n\t\tConfigureNetwork:      fmt.Sprintf(\"%v\", b.ConfigureNetwork),\n\t\tCNIPluginPath:         b.CNIPluginPath,\n\t\tCNIConfigDir:          b.CNIConfigDir,\n\t\tIDMappingOptions:      b.IDMappingOptions,\n\t\tCapabilities:          b.Capabilities,\n\t\tHistory:               history,\n\t\tDevices:               b.Devices,\n\t\tDeviceSpecs:           b.DeviceSpecs,\n\t\tCDIConfigDir:          b.CDIConfigDir,\n\t}\n}\n\n// CommonBuildOptions are resources that can be defined by flags for both buildah from and build\ntype CommonBuildOptions = define.CommonBuildOptions\n\n// BuilderOptions are used to initialize a new Builder.\ntype BuilderOptions struct {\n\t// Args define variables that users can pass at build-time to the builder\n\tArgs map[string]string\n\t// FromImage is the name of the image which should be used as the\n\t// starting point for the container.  It can be set to an empty value\n\t// or \"scratch\" to indicate that the container should not be based on\n\t// an image.\n\tFromImage string\n\t// ContainerSuffix is the suffix to add for generated container names\n\tContainerSuffix string\n\t// Container is a desired name for the build container.\n\tContainer string\n\t// PullPolicy decides whether or not we should pull the image that\n\t// we're using as a base image.  It should be PullIfMissing,\n\t// PullAlways, or PullNever.\n\tPullPolicy define.PullPolicy\n\t// Registry is a value which is prepended to the image's name, if it\n\t// needs to be pulled and the image name alone can not be resolved to a\n\t// reference to a source image.  No separator is implicitly added.\n\tRegistry string\n\t// BlobDirectory is the name of a directory in which we'll attempt\n\t// to store copies of layer blobs that we pull down, if any.  It should\n\t// already exist.\n\tBlobDirectory string\n\tGroupAdd      []string\n\t// Logger is the logrus logger to write log messages with\n\tLogger *logrus.Logger `json:\"-\"`\n\t// Mount signals to NewBuilder() that the container should be mounted\n\t// immediately.\n\tMount bool\n\t// SignaturePolicyPath specifies an override location for the signature\n\t// policy which should be used for verifying the new image as it is\n\t// being written.  Except in specific circumstances, no value should be\n\t// specified, indicating that the shared, system-wide default policy\n\t// should be used.\n\tSignaturePolicyPath string\n\t// ReportWriter is an io.Writer which will be used to log the reading\n\t// of the source image from a registry, if we end up pulling the image.\n\tReportWriter io.Writer\n\t// github.com/containers/image/types SystemContext to hold credentials\n\t// and other authentication/authorization information.\n\tSystemContext *types.SystemContext\n\t// DefaultMountsFilePath is the file path holding the mounts to be\n\t// mounted in \"host-path:container-path\" format\n\tDefaultMountsFilePath string\n\t// Isolation controls how we handle \"RUN\" statements and the Run()\n\t// method.\n\tIsolation define.Isolation\n\t// NamespaceOptions controls how we set up namespaces for processes that\n\t// we might need to run using the container's root filesystem.\n\tNamespaceOptions define.NamespaceOptions\n\t// ConfigureNetwork controls whether or not network interfaces and\n\t// routing are configured for a new network namespace (i.e., when not\n\t// joining another's namespace and not just using the host's\n\t// namespace), effectively deciding whether or not the process has a\n\t// usable network.\n\tConfigureNetwork define.NetworkConfigurationPolicy\n\t// CNIPluginPath is the location of CNI plugin helpers, if they should be\n\t// run from a location other than the default location.\n\tCNIPluginPath string\n\t// CNIConfigDir is the location of CNI configuration files, if the files in\n\t// the default configuration directory shouldn't be used.\n\tCNIConfigDir string\n\n\t// NetworkInterface is the libnetwork network interface used to setup CNI or netavark networks.\n\tNetworkInterface nettypes.ContainerNetwork `json:\"-\"`\n\n\t// ID mapping options to use if we're setting up our own user namespace.\n\tIDMappingOptions *define.IDMappingOptions\n\t// Capabilities is a list of capabilities to use when\n\t// running commands for Run().\n\tCapabilities    []string\n\tCommonBuildOpts *define.CommonBuildOptions\n\t// Format to use for a container image we eventually commit, when we do.\n\tFormat string\n\t// Devices are additional parsed devices to provide for Run() calls.\n\tDevices define.ContainerDevices\n\t// DeviceSpecs are additional unparsed devices to provide for Run() calls.\n\tDeviceSpecs []string\n\t// DefaultEnv is deprecated and ignored.\n\tDefaultEnv []string\n\t// MaxPullRetries is the maximum number of attempts we'll make to pull\n\t// any one image from the external registry if the first attempt fails.\n\tMaxPullRetries int\n\t// PullRetryDelay is how long to wait before retrying a pull attempt.\n\tPullRetryDelay time.Duration\n\t// OciDecryptConfig contains the config that can be used to decrypt an image if it is\n\t// encrypted if non-nil. If nil, it does not attempt to decrypt an image.\n\tOciDecryptConfig *encconfig.DecryptConfig\n\t// ProcessLabel is the SELinux process label associated with commands we Run()\n\tProcessLabel string\n\t// MountLabel is the SELinux mount label associated with the working container\n\tMountLabel string\n\t// PreserveBaseImageAnns indicates that we should preserve base\n\t// image information (Annotations) that are present in our base image,\n\t// rather than overwriting them with information about the base image\n\t// itself. Useful as an internal implementation detail of multistage\n\t// builds, and does not need to be set by most callers.\n\tPreserveBaseImageAnns bool\n\t// CDIConfigDir is the location of CDI configuration files, if the files in\n\t// the default configuration locations shouldn't be used.\n\tCDIConfigDir string\n\t// CompatScratchConfig controls whether a \"scratch\" image is created\n\t// with a truly empty configuration, as would have happened in the past\n\t// (when set to true), or with a minimal initial configuration which\n\t// has a working directory set in it.\n\tCompatScratchConfig types.OptionalBool\n}\n\n// ImportOptions are used to initialize a Builder from an existing container\n// which was created elsewhere.\ntype ImportOptions struct {\n\t// Container is the name of the build container.\n\tContainer string\n\t// SignaturePolicyPath specifies an override location for the signature\n\t// policy which should be used for verifying the new image as it is\n\t// being written.  Except in specific circumstances, no value should be\n\t// specified, indicating that the shared, system-wide default policy\n\t// should be used.\n\tSignaturePolicyPath string\n}\n\n// ImportFromImageOptions are used to initialize a Builder from an image.\ntype ImportFromImageOptions struct {\n\t// Image is the name or ID of the image we'd like to examine.\n\tImage string\n\t// SignaturePolicyPath specifies an override location for the signature\n\t// policy which should be used for verifying the new image as it is\n\t// being written.  Except in specific circumstances, no value should be\n\t// specified, indicating that the shared, system-wide default policy\n\t// should be used.\n\tSignaturePolicyPath string\n\t// github.com/containers/image/types SystemContext to hold information\n\t// about which registries we should check for completing image names\n\t// that don't include a domain portion.\n\tSystemContext *types.SystemContext\n}\n\n// ConfidentialWorkloadOptions encapsulates options which control whether or not\n// we output an image whose rootfs contains a LUKS-compatibly-encrypted disk image\n// instead of the usual rootfs contents.\ntype ConfidentialWorkloadOptions = define.ConfidentialWorkloadOptions\n\n// SBOMScanOptions encapsulates options which control whether or not we run a\n// scanner on the rootfs that we're about to commit, and how.\ntype SBOMScanOptions = define.SBOMScanOptions\n\n// NewBuilder creates a new build container.\nfunc NewBuilder(ctx context.Context, store storage.Store, options BuilderOptions) (*Builder, error) {\n\tif options.CommonBuildOpts == nil {\n\t\toptions.CommonBuildOpts = &CommonBuildOptions{}\n\t}\n\treturn newBuilder(ctx, store, options)\n}\n\n// ImportBuilder creates a new build configuration using an already-present\n// container.\nfunc ImportBuilder(ctx context.Context, store storage.Store, options ImportOptions) (*Builder, error) {\n\treturn importBuilder(ctx, store, options)\n}\n\n// ImportBuilderFromImage creates a new builder configuration using an image.\n// The returned object can be modified and examined, but it can not be saved\n// or committed because it is not associated with a working container.\nfunc ImportBuilderFromImage(ctx context.Context, store storage.Store, options ImportFromImageOptions) (*Builder, error) {\n\treturn importBuilderFromImage(ctx, store, options)\n}\n\n// OpenBuilder loads information about a build container given its name or ID.\nfunc OpenBuilder(store storage.Store, container string) (*Builder, error) {\n\tcdir, err := store.ContainerDirectory(container)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbuildstate, err := os.ReadFile(filepath.Join(cdir, stateFile))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tb := &Builder{}\n\tif err = json.Unmarshal(buildstate, &b); err != nil {\n\t\treturn nil, fmt.Errorf(\"parsing %q, read from %q: %w\", string(buildstate), filepath.Join(cdir, stateFile), err)\n\t}\n\tif b.Type != containerType {\n\t\treturn nil, fmt.Errorf(\"container %q is not a %s container (is a %q container)\", container, define.Package, b.Type)\n\t}\n\n\tnetInt, err := getNetworkInterface(store, b.CNIConfigDir, b.CNIPluginPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tb.NetworkInterface = netInt\n\tb.store = store\n\tb.fixupConfig(nil)\n\tb.setupLogger()\n\tif b.CommonBuildOpts == nil {\n\t\tb.CommonBuildOpts = &CommonBuildOptions{}\n\t}\n\treturn b, nil\n}\n\n// OpenBuilderByPath loads information about a build container given a\n// path to the container's root filesystem\nfunc OpenBuilderByPath(store storage.Store, path string) (*Builder, error) {\n\tcontainers, err := store.Containers()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tabs, err := filepath.Abs(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbuilderMatchesPath := func(b *Builder, path string) bool {\n\t\treturn (b.MountPoint == path)\n\t}\n\tfor _, container := range containers {\n\t\tcdir, err := store.ContainerDirectory(container.ID)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tbuildstate, err := os.ReadFile(filepath.Join(cdir, stateFile))\n\t\tif err != nil {\n\t\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\t\tlogrus.Debugf(\"error reading %q: %v, ignoring container %q\", filepath.Join(cdir, stateFile), err, container.ID)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tb := &Builder{}\n\t\terr = json.Unmarshal(buildstate, &b)\n\t\tif err == nil && b.Type == containerType && builderMatchesPath(b, abs) {\n\t\t\tb.store = store\n\t\t\tb.fixupConfig(nil)\n\t\t\tb.setupLogger()\n\t\t\tif b.CommonBuildOpts == nil {\n\t\t\t\tb.CommonBuildOpts = &CommonBuildOptions{}\n\t\t\t}\n\t\t\treturn b, nil\n\t\t}\n\t\tif err != nil {\n\t\t\tlogrus.Debugf(\"error parsing %q, read from %q: %v\", string(buildstate), filepath.Join(cdir, stateFile), err)\n\t\t} else if b.Type != containerType {\n\t\t\tlogrus.Debugf(\"container %q is not a %s container (is a %q container)\", container.ID, define.Package, b.Type)\n\t\t}\n\t}\n\treturn nil, storage.ErrContainerUnknown\n}\n\n// OpenAllBuilders loads all containers which have a state file that we use in\n// their data directory, typically so that they can be listed.\nfunc OpenAllBuilders(store storage.Store) (builders []*Builder, err error) {\n\tcontainers, err := store.Containers()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, container := range containers {\n\t\tcdir, err := store.ContainerDirectory(container.ID)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tbuildstate, err := os.ReadFile(filepath.Join(cdir, stateFile))\n\t\tif err != nil {\n\t\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\t\tlogrus.Debugf(\"%v, ignoring container %q\", err, container.ID)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tb := &Builder{}\n\t\terr = json.Unmarshal(buildstate, &b)\n\t\tif err == nil && b.Type == containerType {\n\t\t\tb.store = store\n\t\t\tb.setupLogger()\n\t\t\tb.fixupConfig(nil)\n\t\t\tif b.CommonBuildOpts == nil {\n\t\t\t\tb.CommonBuildOpts = &CommonBuildOptions{}\n\t\t\t}\n\t\t\tbuilders = append(builders, b)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\tlogrus.Debugf(\"error parsing %q, read from %q: %v\", string(buildstate), filepath.Join(cdir, stateFile), err)\n\t\t} else if b.Type != containerType {\n\t\t\tlogrus.Debugf(\"container %q is not a %s container (is a %q container)\", container.ID, define.Package, b.Type)\n\t\t}\n\t}\n\treturn builders, nil\n}\n\n// Save saves the builder's current state to the build container's metadata.\n// This should not need to be called directly, as other methods of the Builder\n// object take care of saving their state.\nfunc (b *Builder) Save() error {\n\tbuildstate, err := json.Marshal(b)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcdir, err := b.store.ContainerDirectory(b.ContainerID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err = ioutils.AtomicWriteFile(filepath.Join(cdir, stateFile), buildstate, 0o600); err != nil {\n\t\treturn fmt.Errorf(\"saving builder state to %q: %w\", filepath.Join(cdir, stateFile), err)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "buildah_test.go",
          "type": "blob",
          "size": 2.2763671875,
          "content": "package buildah\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"os\"\n\t\"testing\"\n\n\timagetypes \"github.com/containers/image/v5/types\"\n\t\"github.com/containers/storage\"\n\t\"github.com/containers/storage/types\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar testSystemContext = imagetypes.SystemContext{\n\tSignaturePolicyPath:      \"tests/policy.json\",\n\tSystemRegistriesConfPath: \"tests/registries.conf\",\n}\n\nfunc TestMain(m *testing.M) {\n\tvar logLevel string\n\tdebug := false\n\tif InitReexec() {\n\t\treturn\n\t}\n\tflag.BoolVar(&debug, \"debug\", false, \"turn on debug logging\")\n\tflag.StringVar(&logLevel, \"log-level\", \"error\", \"log level\")\n\tflag.Parse()\n\tlevel, err := logrus.ParseLevel(logLevel)\n\tif err != nil {\n\t\tlogrus.Fatalf(\"error parsing log level %q: %v\", logLevel, err)\n\t}\n\tif debug && level < logrus.DebugLevel {\n\t\tlevel = logrus.DebugLevel\n\t}\n\tlogrus.SetLevel(level)\n\tos.Exit(m.Run())\n}\n\nfunc TestOpenBuilderCommonBuildOpts(t *testing.T) {\n\tctx := context.TODO()\n\tstore, err := storage.GetStore(types.StoreOptions{\n\t\tRunRoot:         t.TempDir(),\n\t\tGraphRoot:       t.TempDir(),\n\t\tGraphDriverName: \"vfs\",\n\t})\n\trequire.NoError(t, err)\n\tt.Cleanup(func() { _, err := store.Shutdown(true); assert.NoError(t, err) })\n\tb, err := NewBuilder(ctx, store, BuilderOptions{})\n\trequire.NoError(t, err)\n\trequire.NotNil(t, b.CommonBuildOpts)\n\tb.CommonBuildOpts = nil\n\tbuilderContainerID := b.ContainerID\n\terr = b.Save()\n\trequire.NoError(t, err)\n\tb, err = OpenBuilder(store, builderContainerID)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, b.CommonBuildOpts)\n\tbuilders, err := OpenAllBuilders(store)\n\trequire.NoError(t, err)\n\tfor _, b := range builders {\n\t\trequire.NotNil(t, b.CommonBuildOpts)\n\t}\n\timageID, _, _, err := b.Commit(ctx, nil, CommitOptions{})\n\trequire.NoError(t, err)\n\tb, err = ImportBuilderFromImage(ctx, store, ImportFromImageOptions{\n\t\tImage: imageID,\n\t})\n\trequire.NoError(t, err)\n\trequire.NotNil(t, b.CommonBuildOpts)\n\tcontainer, err := store.CreateContainer(\"\", nil, imageID, \"\", \"\", &storage.ContainerOptions{})\n\trequire.NoError(t, err)\n\trequire.NotNil(t, container)\n\tb, err = ImportBuilder(ctx, store, ImportOptions{\n\t\tContainer:           container.ID,\n\t\tSignaturePolicyPath: testSystemContext.SignaturePolicyPath,\n\t})\n\trequire.NoError(t, err)\n\trequire.NotNil(t, b.CommonBuildOpts)\n}\n"
        },
        {
          "name": "changelog.txt",
          "type": "blob",
          "size": 159.453125,
          "content": "- Changelog for v1.38.0 (2024-11-08)\n  * Bump to c/common v0.61.0, c/image v5.33.0, c/storage v1.56.0\n  * fix(deps): update module golang.org/x/crypto to v0.29.0\n  * fix(deps): update module github.com/moby/buildkit to v0.17.1\n  * fix(deps): update module github.com/containers/storage to v1.56.0\n  * tests: skip two ulimit tests\n  * CI VMs: bump f40 -> f41\n  * tests/tools: rebuild tools when we change versions\n  * tests/tools: update golangci-lint to v1.61.0\n  * fix(deps): update module github.com/moby/buildkit to v0.17.0\n  * Handle RUN --mount with relative targets and no configured workdir\n  * tests: bud: make parallel-safe\n  * fix(deps): update module github.com/opencontainers/runc to v1.2.1\n  * fix(deps): update golang.org/x/exp digest to f66d83c\n  * fix(deps): update github.com/opencontainers/runtime-tools digest to 6c9570a\n  * tests: blobcache: use unique image name\n  * tests: sbom: never write to cwd\n  * tests: mkcw: bug fixes, refactor\n  * deps: bump runc to v1.2.0\n  * deps: switch to moby/sys/userns\n  * tests/test_runner.sh: remove some redundancies\n  * Integration tests: run git daemon on a random-but-bind()able port\n  * fix(deps): update module github.com/opencontainers/selinux to v1.11.1\n  * go.mod: remove unnecessary replace\n  * Document more buildah build --secret options\n  * Add support for COPY --exclude and ADD --exclude options\n  * fix(deps): update github.com/containers/luksy digest to e2530d6\n  * chore(deps): update dependency containers/automation_images to v20241010\n  * fix(deps): update module github.com/cyphar/filepath-securejoin to v0.3.4\n  * Properly validate cache IDs and sources\n  * [skip-ci] Packit: constrain koji job to fedora package to avoid dupes\n  * Audit and tidy OWNERS\n  * fix(deps): update module golang.org/x/crypto to v0.28.0\n  * tests: add quotes to names\n  * vendor: update c/common to latest\n  * CVE-2024-9407: validate \"bind-propagation\" flag settings\n  * vendor: switch to moby/sys/capability\n  * Don't set ambient capabilities\n  * Document that zstd:chunked is downgraded to zstd when encrypting\n  * fix(deps): update module github.com/cyphar/filepath-securejoin to v0.3.3\n  * buildah-manifest-create.1: Fix manpage section\n  * chore(deps): update dependency ubuntu to v24\n  * Make `buildah manifest push --all` true by default\n  * chroot: add newlines at the end of printed error messages\n  * Do not error on trying to write IMA xattr as rootless\n  * fix: remove duplicate conditions\n  * fix(deps): update module github.com/moby/buildkit to v0.16.0\n  * fix(deps): update module github.com/cyphar/filepath-securejoin to v0.3.2\n  * Document how entrypoint is configured in buildah config\n  * In a container, try to register binfmt_misc\n  * imagebuildah.StageExecutor: clean up volumes/volumeCache\n  * build: fall back to parsing a TARGETPLATFORM build-arg\n  * `manifest add --artifact`: handle multiple values\n  * Packit: split out ELN jobs and reuse fedora downstream targets\n  * Packit: Enable sidetags for bodhi updates\n  * fix(deps): update module github.com/docker/docker to v27.2.1+incompatible\n  * tests/bud.bats: add git source\n  * add: add support for git source\n  * Add support for the new c/common pasta options\n  * vendor latest c/common\n  * fix(deps): update module golang.org/x/term to v0.24.0\n  * fix(deps): update module github.com/fsouza/go-dockerclient to v1.12.0\n  * packit: update fedora and epel targets\n  * cirrus: disable f39 testing\n  * cirrus: fix fedora names\n  * update to go 1.22\n  * Vendor c/common:9d025e4cb348\n  * copier: handle globbing with \"**\" path components\n  * fix(deps): update golang.org/x/exp digest to 9b4947d\n  * fix(deps): update github.com/containers/luksy digest to 2e7307c\n  * imagebuildah: make scratch config handling toggleable\n  * fix(deps): update module github.com/docker/docker to v27.2.0+incompatible\n  * Add a validation script for Makefile $(SOURCES)\n  * fix(deps): update module github.com/openshift/imagebuilder to v1.2.15\n  * New VMs\n  * Update some godocs, use 0o to prefix an octal in a comment\n  * buildah-build.1.md: expand the --layer-label description\n  * fix(deps): update module github.com/containers/common to v0.60.2\n  * run: fix a nil pointer dereference on FreeBSD\n  * CI: enable the whitespace linter\n  * Fix some govet linter warnings\n  * Commit(): retry committing to local storage on storage.LayerUnknown\n  * CI: enable the gofumpt linter\n  * conformance: move weirdly-named files out of the repository\n  * fix(deps): update module github.com/docker/docker to v27.1.2+incompatible\n  * fix(deps): update module github.com/containers/common to v0.60.1\n  * *: use gofmt -s, add gofmt linter\n  * *: fix build tags\n  * fix(deps): update module github.com/containers/image/v5 to v5.32.1\n  * Add(): re-escape any globbed items that included escapes\n  * conformance tests: use mirror.gcr.io for most images\n  * unit tests: use test-specific policy.json and registries.conf\n  * fix(deps): update module golang.org/x/sys to v0.24.0\n  * Update to spun-out \"github.com/containerd/platforms\"\n  * Bump github.com/containerd/containerd\n  * test/tools/Makefile: duplicate the vendor-in-container target\n  * linters: unchecked error\n  * linters: don't end loop iterations with \"else\" when \"then\" would\n  * linters: unused arguments shouldn't have names\n  * linters: rename checkIdsGreaterThan5() to checkIDsGreaterThan5()\n  * linters: don't name variables \"cap\"\n  * `make lint`: use --timeout instead of --deadline\n  * Drop the e2e test suite\n  * fix(deps): update module golang.org/x/crypto to v0.26.0\n  * fix(deps): update module github.com/onsi/gomega to v1.34.1\n  * `make vendor-in-container`: use the caller's Go cache if it exists\n  * fix(deps): fix test/tools ginkgo typo\n  * fix(deps): update module github.com/onsi/ginkgo/v2 to v2.19.1\n  * Update to keep up with API changes in storage\n  * fix(deps): update github.com/containers/luksy digest to 1f482a9\n  * install: On Debian/Ubuntu, add installation of libbtrfs-dev\n  * fix(deps): update module golang.org/x/sys to v0.23.0\n  * fix(deps): update golang.org/x/exp digest to 8a7402a\n  * fix(deps): update module github.com/fsouza/go-dockerclient to v1.11.2\n  * Use Epoch: 2 and respect the epoch in dependencies.\n  * Bump to Buildah v1.38.0-dev\n  * AddAndCopyOptions: add CertPath, InsecureSkipTLSVerify, Retry fields\n  * Add PrependedLinkedLayers/AppendedLinkedLayers to CommitOptions\n  * integration tests: teach starthttpd() about TLS and pid files\n\n- Changelog for vv1.37.0 (2024-07-26)\n  * Bump c/storage, c/image, c/common for v1.37.0\n  * \"build with basename resolving user arg\" tests: correct ARG use\n  * bud-multiple-platform-no-run test: correct ARG use\n  * imagebuildah: always have default values for $TARGET... args ready\n  * bump github.com/openshift/imagebuilder to v1.2.14\n  * fix(deps): update module github.com/docker/docker to v27.1.1+incompatible\n  * fix(deps): update module github.com/cyphar/filepath-securejoin to v0.3.1\n  * fix(deps): update module github.com/docker/docker to v27.1.0+incompatible\n  * CI: use local registry, part 2 of 2\n  * CI: use local registry, part 1 of 2\n  * fix(deps): update module github.com/fsouza/go-dockerclient to v1.11.1\n  * Revert \"fix(deps): update github.com/containers/image/v5 to v5.31.1\"\n  * Replace libimage.LookupReferenceFunc with the manifests version\n  * conformance tests: enable testing CompatVolumes\n  * conformance tests: add a test that tries to chown a volume\n  * imagebuildah: make traditional volume handling not the default\n  * StageExecutor.prepare(): mark base image volumes for preservation\n  * fix(deps): update module github.com/containers/image/v5 to v5.31.1\n  * Vendor in latest containers/(common, storage, image)\n  * fix(deps): update module golang.org/x/term to v0.22.0\n  * fix(deps): update module golang.org/x/sys to v0.22.0\n  * fix(deps): update golang.org/x/exp digest to 7f521ea\n  * fix(deps): update github.com/containers/luksy digest to a8846e2\n  * imagebuildah.StageExecutor.Copy(): reject new flags for now\n  * bump github.com/openshift/imagebuilder to v1.2.11\n  * Rework parsing of --pull flags\n  * fix(deps): update module github.com/containers/image/v5 to v5.31.1\n  * imagebuildah.StageExecutor.prepare(): log the --platform flag\n  * CI VMs: bump\n  * buildah copy: preserve owner info with --from= a container or image\n  * conformance tests: enable testing CompatSetParent\n  * containerImageRef.NewImageSource(): move the FROM comment to first\n  * commit: set \"parent\" for docker format only when requested\n  * Update godoc for Builder.EnsureContainerPathAs\n  * fix(deps): update module github.com/spf13/cobra to v1.8.1\n  * fix(deps): update module github.com/containernetworking/cni to v1.2.0\n  * fix(deps): update module github.com/opencontainers/runc to v1.1.13\n  * Change default for podman build to --pull missing\n  * fix(deps): update module github.com/containers/common to v0.59.1\n  * Clarify definition of --pull options\n  * buildah: fix a nil pointer reference on FreeBSD\n  * Use /var/tmp for $TMPDIR for vfs conformance jobs\n  * Cirrus: run `df` during job setup\n  * conformance: use quay.io/libpod/centos:7 instead of centos:8\n  * Stop setting \"parent\" in docker format\n  * conformance: check if workdir trims path separator suffixes\n  * push integration test: pass password to docker login via stdin\n  * Re-enable the \"copy with chown\" conformance test\n  * healthcheck: Add support for `--start-interval`\n  * fix(deps): update module github.com/docker/docker to v26.1.4+incompatible\n  * fix(deps): update module github.com/containerd/containerd to v1.7.18\n  * tests: set _CONTAINERS_USERNS_CONFIGURED=done for libnetwork\n  * Cross-build on Fedora\n  * Drop copyStringSlice() and copyStringStringMap()\n  * fix(deps): update module golang.org/x/crypto to v0.24.0\n  * fix(deps): update module github.com/openshift/imagebuilder to v1.2.10\n  * Provide an uptime_netbsd.go\n  * Spell unix as \"!windows\"\n  * Add netbsd to lists-of-OSes\n  * fix(deps): update golang.org/x/exp digest to fd00a4e\n  * [skip-ci] Packit: enable c10s downstream sync\n  * CI VMs: bump, to debian with cgroups v2\n  * Document when BlobDirectory is overridden\n  * fix secret mounts for env vars when using chroot isolation\n  * Change to take a types.ImageReference arg\n  * imagebuildah: Support custom image reference lookup for cache push/pull\n  * fix(deps): update module github.com/onsi/ginkgo/v2 to v2.19.0\n  * Bump to v1.37.0-dev\n  * CI: Clarify Debian use for conformance tests\n\n- Changelog for v1.36.0 (2024-05-23)\n  * build: be more selective about specifying the default OS\n  * Bump to c/common v0.59.0\n  * Fix buildah prune --help showing the same example twice\n  * fix(deps): update module github.com/onsi/ginkgo/v2 to v2.18.0\n  * fix(deps): update module github.com/containers/image/v5 to v5.31.0\n  * bud tests: fix breakage when vendoring into podman\n  * Integration tests: fake up a replacement for nixery.dev/shell\n  * copierWithSubprocess(): try to capture stderr on io.ErrClosedPipe\n  * Don't expand RUN heredocs ourselves, let the shell do it\n  * Don't leak temp files on failures\n  * Add release note template to split dependency chores\n  * fix CentOS/RHEL build - no BATS there\n  * fix(deps): update module github.com/containers/luksy to v0.0.0-20240506205542-84b50f50f3ee\n  * Address CVE-2024-3727\n  * chore(deps): update module github.com/opencontainers/runtime-spec to v1.2.0\n  * Builder.cdiSetupDevicesInSpecdefConfig(): use configured CDI dirs\n  * Setting --arch should set the TARGETARCH build arg\n  * fix(deps): update module golang.org/x/exp to v0.0.0-20240416160154-fe59bbe5cc7f\n  * [CI:DOCS] Add link to Buildah image page to README.md\n  * Don't set GOTOOLCHAIN=local\n  * fix(deps): update module github.com/cyphar/filepath-securejoin to v0.2.5\n  * Makefile: set GOTOOLCHAIN=local\n  * Integration tests: switch some base images\n  * containerImageRef.NewImageSource: merge the tar filters\n  * fix(deps): update module github.com/onsi/ginkgo/v2 to v2.17.2\n  * fix(deps): update module github.com/containers/luksy to v0.0.0-20240408185936-afd8e7619947\n  * Disable packit builds for centos-stream+epel-next-8\n  * Makefile: add missing files to $(SOURCES)\n  * CI VMs: bump to new versions with tmpfs /tmp\n  * chore(deps): update module golang.org/x/net to v0.23.0 [security]\n  * integration test: handle new labels in \"bud and test --unsetlabel\"\n  * Switch packit configuration to use epel-9-$arch ...\n  * Give unit tests a bit more time\n  * Integration tests: remove a couple of duplicated tests\n  * Integration tests: whitespace tweaks\n  * Integration tests: don't remove images at start or end of test\n  * Integration tests: use cached images more\n  * Integration tests _prefetch: use registry configs\n  * internal: use fileutils.(Le|E)xists\n  * pkg/parse: use fileutils.(Le|E)xists\n  * buildah: use fileutils.(Le|E)xists\n  * chroot: use fileutils.(Le|E)xists\n  * vendor: update containers/(common|storage)\n  * Fix issue/pr lock workflow\n  * [CI:DOCS] Add golang 1.21 update warning\n  * heredoc: honor inline COPY irrespective of ignorefiles\n  * Update install.md\n  * source-push: add support for --digestfile\n  * Fix caching when mounting a cached stage with COPY/ADD\n  * fix(deps): update github.com/containers/luksy digest to 3d2cf0e\n  * Makefile: softcode `strip`, use it from env var\n  * Man page updates\n  * Add support for passing CDI specs to --device\n  * Update comments on some API objects\n  * pkg/parse.DeviceFromPath(): dereference src symlinks\n  * fix(deps): update module github.com/onsi/ginkgo/v2 to v2.17.1\n\n- Changelog for v1.35.0 (2024-03-06)\n  * fix(deps): update module github.com/stretchr/testify to v1.9.0\n  * cgroups: reuse version check from c/common\n  * Update vendor of containers/(common,image)\n  * fix(deps): update github.com/containers/storage digest to eadc620\n  * fix(deps): update github.com/containers/luksy digest to ceb12d4\n  * fix(deps): update github.com/containers/image/v5 digest to cdc6802\n  * manifest add: complain if we get artifact flags without --artifact\n  * Use retry logic from containers/common\n  * Vendor in containers/(storage,image,common)\n  * Update module golang.org/x/crypto to v0.20.0\n  * Add comment re: Total Success task name\n  * tests: skip_if_no_unshare(): check for --setuid\n  * Properly handle build --pull=false\n  * [skip-ci] Update tim-actions/get-pr-commits action to v1.3.1\n  * Update module go.etcd.io/bbolt to v1.3.9\n  * Revert \"Reduce official image size\"\n  * Update module github.com/opencontainers/image-spec to v1.1.0\n  * Reduce official image size\n  * Build with CNI support on FreeBSD\n  * build --all-platforms: skip some base \"image\" platforms\n  * Bump main to v1.35.0-dev\n  * Vendor in latest containers/(storage,image,common)\n  * Split up error messages for missing --sbom related flags\n  * `buildah manifest`: add artifact-related options\n  * cmd/buildah/manifest.go: lock lists before adding/annotating/pushing\n  * cmd/buildah/manifest.go: don't make struct declarations aliases\n  * Use golang.org/x/exp/slices.Contains\n  * Disable loong64 again\n  * Fix a couple of typos in one-line comments\n  * egrep is obsolescent; use grep -E\n  * Try Cirrus with a newer VM version\n  * Set CONTAINERS_CONF in the chroot-mount-flags integration test\n  * Update to match dependency API update\n  * Update github.com/openshift/imagebuilder and containers/common\n  * docs: correct default authfile path\n  * fix(deps): update module github.com/containerd/containerd to v1.7.13\n  * tests: retrofit test for heredoc summary\n  * build, heredoc: show heredoc summary in build output\n  * manifest, push: add support for --retry and --retry-delay\n  * fix(deps): update github.com/openshift/imagebuilder digest to b767bc3\n  * imagebuildah: fix crash with empty RUN\n  * fix(deps): update github.com/containers/luksy digest to b62d551\n  * fix(deps): update module github.com/opencontainers/runc to v1.1.12 [security]\n  * fix(deps): update module github.com/moby/buildkit to v0.12.5 [security]\n  * Make buildah match podman for handling of ulimits\n  * docs: move footnotes to where they're applicable\n  * Allow users to specify no-dereference\n  * Run codespell on code\n  * Fix FreeBSD version parsing\n  * Fix a build break on FreeBSD\n  * Remove a bad FROM line\n  * fix(deps): update module github.com/onsi/gomega to v1.31.1\n  * fix(deps): update module github.com/opencontainers/image-spec to v1.1.0-rc6\n  * docs: use reversed logo for dark theme in README\n  * build,commit: add --sbom to scan and produce SBOMs when committing\n  * commit: force omitHistory if the parent has layers but no history\n  * docs: fix a couple of typos\n  * internal/mkcw.Archive(): handle extra image content\n  * stage_executor,heredoc: honor interpreter in heredoc\n  * stage_executor,layers: burst cache if heredoc content is changed\n  * fix(deps): update module golang.org/x/crypto to v0.18.0\n  * Replace map[K]bool with map[K]struct{} where it makes sense\n  * fix(deps): update module golang.org/x/sync to v0.6.0\n  * fix(deps): update module golang.org/x/term to v0.16.0\n  * Bump CI VMs\n  * Replace strings.SplitN with strings.Cut\n  * fix(deps): update github.com/containers/storage digest to ef81e9b\n  * fix(deps): update github.com/containers/image/v5 digest to 1b221d4\n  * fix(deps): update module github.com/fsouza/go-dockerclient to v1.10.1\n  * Document use of containers-transports values in buildah\n  * fix(deps): update module golang.org/x/crypto to v0.17.0 [security]\n  * chore(deps): update dependency containers/automation_images to v20231208\n  * manifest: addCompression use default from containers.conf\n  * commit: add a --add-file flag\n  * mkcw: populate the rootfs using an overlay\n  * chore(deps): update dependency containers/automation_images to v20230517\n  * [skip-ci] Update actions/stale action to v9\n  * fix(deps): update module github.com/containernetworking/plugins to v1.4.0\n  * fix(deps): update github.com/containers/image/v5 digest to 7a40fee\n  * Bump to v1.34.1-dev\n  * Ignore errors if label.Relabel returns ENOSUP\n\n- Changelog for v1.34.0 (2023-12-11)\n  * vendor: update c/{common,image,storage}\n  * run: Allow using just one jail per container on FreeBSD\n  * Remove makefile targets entrypoint{,.gz} for non x86_64\n\n- Changelog for v1.33.2 (2023-11-22)\n  * Update minimum to golang 1.20\n  * fix(deps): update module github.com/fsouza/go-dockerclient to v1.10.0\n  * fix(deps): update module github.com/moby/buildkit to v0.12.3\n  * Bump to v1.33.2-dev\n\n- Changelog for v1.33.1 (2023-11-18)\n  * fix(deps): update module github.com/moby/buildkit to v0.11.4 [security]\n  * test,heredoc: use fedora instead of docker.io/library/python:latest\n  * Bump to v1.33.1-dev\n\n- Changelog for v1.33.0 (2023-11-17)\n  * Never omit layers for emptyLayer instructions when squashing/cwing\n  * Add OverrideChanges and OverrideConfig to CommitOptions\n  * buildah: add heredoc support for RUN, COPY and ADD\n  * vendor: bump imagebuilder to v1.2.6-0.20231110114814-35a50d57f722\n  * conformance tests: archive the context directory as 0:0 (#5171)\n  * blobcacheinfo,test: blobs must be resued when pushing across registry\n  * Bump c/storage v1.51.0, c/image v5.29.0, c/common v0.57.0\n  * pkg/util.MirrorToTempFileIfPathIsDescriptor(): don't leak an fd\n  * StageExecutor.Execute: force a commit for --unsetenv, too\n  * Increase a copier+chroot test timeout\n  * Add support for --compat-auth-file in login/logout\n  * Update existing tests for error message change\n  * Update c/image and c/common to latest\n  * fix(deps): update module github.com/containerd/containerd to v1.7.9\n  * build: downgrade to go 1.20\n  * Add godoc for pkg/parse.GetTempDir\n  * conformance tests: use go-dockerclient for BuildKit builds\n  * Make TEE types case-insensitive\n  * fix(deps): update module golang.org/x/crypto to v0.15.0\n  * Tweak some help descriptions\n  * Stop using DefaultNetworkSysctl and use containers.conf only\n  * Implement ADD checksum flag #5135\n  * vendor of openshift/imagebuilder #5135\n  * Pass secrets from the host down to internal podman containers\n  * Update cirrus and version of golang\n  * image: replace GetStoreImage with ResolveReference\n  * vendor: bump c/image to 373c52a9466f\n  * pkg/parse.Platform(): minor simplification\n  * createConfigsAndManifests: clear history before cw-specific logic\n  * Use a constant definition instead of \"scratch\"\n  * conformance: use require.NoErrorf() more\n  * fix(deps): update module golang.org/x/term to v0.14.0\n  * fix(deps): update module golang.org/x/sync to v0.5.0\n  * fix(deps): update module github.com/spf13/cobra to v1.8.0\n  * fix(deps): update module golang.org/x/sys to v0.14.0\n  * fix(deps): update github.com/containers/common digest to 8354404\n  * fix(deps): update module github.com/opencontainers/runc to v1.1.10\n  * fix(deps): update github.com/containers/luksy digest to b5a7f79\n  * Log the platform for build errors during multi-platform builds\n  * Use mask definitions from containers/common\n  * Vendor in latest containers/common\n  * fix(deps): update module github.com/containerd/containerd to v1.7.8\n  * fix(deps): update module go.etcd.io/bbolt to v1.3.8\n  * container.conf: support attributed string slices\n  * fix(deps): update module sigs.k8s.io/yaml to v1.4.0\n  * Use cutil.StringInSlice rather then contains\n  * Add --no-hostname option to buildah containers\n  * vendor c/common: appendable containers.conf strings, Part 1\n  * fix(deps): update module github.com/onsi/gomega to v1.28.1\n  * chroot.setupChrootBindMounts: pay more attention to flags\n  * chore(deps): update dependency containers/automation_images to v20231004\n  * Vendor containers/common\n  * chore(deps): update module golang.org/x/net to v0.17.0 [security]\n  * run: use internal.GetTempDir with os.MkdirTemp\n  * fix(deps): update module github.com/containerd/containerd to v1.7.7\n  * imagebuildah,multi-stage: do not remove base images\n  * gitignore: add mkcw binary\n  * mkcw: remove entrypoint binaries\n  * fix(deps): update module golang.org/x/crypto to v0.14.0\n  * fix(deps): update module golang.org/x/sys to v0.13.0\n  * fix(deps): update module golang.org/x/sync to v0.4.0\n  * Update some comments related to confidential workload\n  * Use the parent's image ID in the config that we pass to imagebuilder\n  * fix(deps): update github.com/containers/common digest to 8892536\n  * fix(deps): update github.com/containers/luksy digest to 6df88cb\n  * bug: Ensure the mount type is always BindMount by default\n  * Protocol can be specified with --port. Ex. --port 514/udp\n  * fix(deps): update module github.com/onsi/gomega to v1.28.0\n  * build,config: add support for --unsetlabel\n  * tests/bud: add tests\n  * [CI:BUILD] Packit: tag @containers/packit-build on copr build failures\n  * stage_executor: allow images without layers\n  * vendor of containers/common\n  * Removing selinux_tag.sh as no longer needed after 580356f [NO NEW TESTS NEEDED]\n  * add/copy: make sure we handle relative path names correctly\n  * fix(deps): update module github.com/opencontainers/image-spec to v1.1.0-rc5\n  * Bump to v1.33.0-dev\n  * imagebuildah: consider ignorefile with --build-context\n\n- Changelog for v1.32.0 (2023-09-14)\n  * GetTmpDir is not using ImageCopyTmpdir correctly\n  * Run codespell on code\n  * Bump vendor containers/(common, storage, image)\n  * Cirrus: Remove multi-arch buildah image builds\n  * fix(deps): update module github.com/containerd/containerd to v1.7.6\n  * Split GetTempDir from internal/util\n  * Move most of internal/parse to internal/volumes\n  * copier: remove libimage dependency via util package\n  * Add some docs for `build --cw`, `commit --cw`, and `mkcw`\n  * Add `buildah mkcw`, add `--cw` to `buildah commit` and `buildah build`\n  * Make sure that pathnames picked up from the environment are absolute\n  * fix(deps): update module github.com/cyphar/filepath-securejoin to v0.2.4\n  * fix(deps): update module github.com/docker/docker to v24.0.6+incompatible\n  * Don't try to look up names when committing images\n  * fix(deps): update module golang.org/x/crypto to v0.13.0\n  * docs: use valid github repo\n  * fix(deps): update module golang.org/x/sys to v0.12.0\n  * vendor containers/common@12405381ff45\n  * push: --force-compression should be true with --compression-format\n  * Update module github.com/containerd/containerd to v1.7.5\n  * [skip-ci] Update tim-actions/commit-message-checker-with-regex action to v0.3.2\n  * docs: add reference to oci-hooks\n  * Support passing of ULimits as -1 to mean max\n  * GHA: Attempt to fix discussion_lock workflow\n  * Fixing the owner of the storage.conf.\n  * pkg/chrootuser: Ignore comments when parsing /etc/group on FreeBSD\n  * Use buildah repo rather then podman repo\n  * GHA: Closed issue/PR comment-lock test\n  * fix(deps): update module github.com/containers/storage to v1.49.0\n  * chore(deps): update dependency containers/automation_images to v20230816\n  * Replace troff code with markdown in buildah-{copy,add}.1.md\n  * [CI:BUILD] rpm: spdx compatible license field\n  * executor: build-arg warnings must honor global args\n  * fix(deps): update module github.com/containers/ocicrypt to v1.1.8\n  * chroot: `setSeccomp` add support for `ArchPARISC(64)` and `ArchRISCV64`\n  * make,cross: restore loong64\n  * Clear CommonBuildOpts when loading Builder status\n  * buildah/push/manifest-push: add support for --force-compression\n  * vendor: bump c/common to v0.55.1-0.20230811093040-524b4d5c12f9\n  * chore(deps): update dependency containers/automation_images to v20230809\n  * [CI:BUILD] RPM: fix buildtags\n  * fix(deps): update module github.com/opencontainers/runc to v1.1.9\n  * chore(deps): update dependency ubuntu to v22\n  * chore(deps): update dependency containers/automation_images to v20230807\n  * [CI:BUILD] Packit: add fedora-eln targets\n  * [CI:BUILD] RPM: build docs with vendored go-md2man\n  * packit: Build PRs into default packit COPRs\n  * Update install.md\n  * Update install.md changes current Debian stable version name\n  * fix(deps): update module golang.org/x/term to v0.11.0\n  * fix(deps): update module golang.org/x/crypto to v0.12.0\n  * tests: fix layer-label tests\n  * buildah: add --layer-label for setting labels on layers\n  * Cirrus: container/rootless env. var. passthrough\n  * Cirrus: Remove duplicate env. var. definitions\n  * fix(deps): update github.com/containers/storage digest to c3da76f\n  * Add a missing .Close() call on an ImageSource\n  * Create only a reference when that's all we need\n  * Add a missing .Close() call on an ImageDestination\n  * CI:BUILD] RPM: define gobuild macro for rhel/centos stream\n  * manifest/push: add support for --add-compression\n  * manifest/inspect: add support for tls-verify and authfile\n  * vendor: bump c/common to v0.55.1-0.20230727095721-647ed1d4d79a\n  * vendor: bump c/image to v5.26.1-0.20230726142307-8c387a14f4ac\n  * fix(deps): update module github.com/containerd/containerd to v1.7.3\n  * fix(deps): update module github.com/onsi/gomega to v1.27.10\n  * fix(deps): update module github.com/docker/docker to v24.0.5+incompatible\n  * fix(deps): update module github.com/containers/image/v5 to v5.26.1\n  * fix(deps): update module github.com/opencontainers/runtime-spec to v1.1.0\n  * Update vendor of containers/(storage,image,common)\n  * fix(deps): update module github.com/opencontainers/runc to v1.1.8\n  * [CI:BUILD] Packit: remove pre-sync action\n  * fix(deps): update module github.com/containers/common to v0.55.2\n  * [CI:BUILD] Packit: downstream task script needs GOPATH\n  * Vendor in containers/(common, image, storage)\n  * fix(deps): update module golang.org/x/term to v0.10.0\n  * [CI:BUILD] Packit: fix pre-sync action for downstream tasks\n  * contrib/buildahimage: set config correctly for rootless build user\n  * fix(deps): update module github.com/opencontainers/image-spec to v1.1.0-rc4\n  * Bump to v1.32.0-dev\n  * Update debian install instructions\n  * pkg/overlay: add limited support for FreeBSD\n\n- Changelog for v1.31.0 (2023-06-30)\n  * Bump c/common to 0.55.1 and c/image to 5.26.1\n  * Bump c/image to 5.26.0 and c/common to 0.54.0\n  * vendor: update c/{common,image,storage} to latest\n  * chore: pkg imported more than once\n  * buildah: add pasta(1) support\n  * use slirp4netns package from c/common\n  * update c/common to latest\n  * add hostname to /etc/hosts when running with host network\n  * vendor: update c/common to latest\n  * [CI:BUILD] Packit: add jobs for downstream Fedora package builds\n  * fix(deps): update module golang.org/x/sync to v0.3.0\n  * fix(deps): update module golang.org/x/crypto to v0.10.0\n  * Add smoke tests for encryption CLI helpers\n  * fix(deps): update module golang.org/x/term to v0.9.0\n  * fix(deps): update module github.com/opencontainers/runtime-spec to v1.1.0-rc.3\n  * Remove device mapper support\n  * Remove use of deprecated tar.TypeRegA\n  * Update tooling to support newer golangci-lint\n  * Make cli.EncryptConfig,DecryptConfig, GetFormat public\n  * Don't decrypt images by default\n  * fix(deps): update module github.com/onsi/gomega to v1.27.8\n  * fix(deps): update github.com/containers/storage digest to 3f3fb2f\n  * Renovate: Don't touch fragile test stuffs\n  * [CI:DOCS] Update comment to remove ambiguity\n  * fix(deps): update github.com/containers/image/v5 digest to abe5133\n  * fix(deps): update module github.com/sirupsen/logrus to v1.9.3\n  * fix(deps): update module github.com/containerd/containerd to v1.7.2\n  * Explicitly ref. quay images for CI\n  * At startup, log the effective capabilities for debugging\n  * parse: use GetTempDir from internal utils\n  * GetTmpDir: honor image_copy_tmp_dir from containers.conf\n  * docs/Makefile: don't show sed invocations\n  * CI: Support testing w/ podman-next COPR packages\n  * intermediate-images inherit-label test: make it debuggable\n  * fix(deps): update github.com/containers/common digest to 462ccdd\n  * Add a warning to `--secret` docs\n  * vendor: bump c/storage to v1.46.2-0.20230526114421-55ee2d19292f\n  * executor: apply label to only final stage\n  * remove registry.centos.org\n  * Go back to setting SysProcAttr.Pdeathsig for child processes\n  * Fix auth.json path (validated on Fedora 38) wq Signed-off-by: Andreas Mack <andreas.mack@gmail.com>\n  * fix(deps): update module github.com/stretchr/testify to v1.8.3\n  * CI: fix test broken by renovatebot\n  * chore(deps): update quay.io/libpod/testimage docker tag to v20221018\n  * fix(deps): update module github.com/onsi/gomega to v1.27.7\n  * test: use debian instead of docker.io/library/debian:testing-slim\n  * vendor: bump logrus to 1.9.2\n  * [skip-ci] Update tim-actions/get-pr-commits action to v1.3.0\n  * Revert \"Proof of concept: nightly dependency treadmill\"\n  * fix(deps): update module github.com/sirupsen/logrus to v1.9.1\n  * vendor in containers/(common,storage,image)\n  * fix(deps): update module github.com/docker/distribution to v2.8.2+incompatible\n  * run: drop Pdeathsig\n  * chroot: lock thread before setPdeathsig\n  * tests: add a case for required=false\n  * fix(deps): update module github.com/openshift/imagebuilder to v1.2.5\n  * build: validate volumes on backend\n  * secret: accept required flag w/o value\n  * fix(deps): update module github.com/containerd/containerd to v1.7.1\n  * fix(deps): update module golang.org/x/crypto to v0.9.0\n  * Update the demos README file to fix minor typos\n  * fix(deps): update module golang.org/x/sync to v0.2.0\n  * fix(deps): update module golang.org/x/term to v0.8.0\n  * manifest, push: use source as destination if not specified\n  * run,mount: remove path only if they didnt pre-exist\n  * Cirrus: Fix meta task failing to find commit\n  * parse: filter edge-case for podman-remote\n  * fix(deps): update module github.com/opencontainers/runc to v1.1.7\n  * fix(deps): update module github.com/docker/docker to v23.0.5+incompatible\n  * build: --platform must accept only arch\n  * fix(deps): update module github.com/containers/common to v0.53.0\n  * makefile: increase conformance timeout\n  * Cap suffixDigitsModulo to a 9-digits suffix.\n  * Rename conflict to suffixDigitsModulo\n  * fix(deps): update module github.com/opencontainers/runtime-spec to v1.1.0-rc.2\n  * fix(deps): update module github.com/opencontainers/runc to v1.1.6\n  * chore(deps): update centos docker tag to v8\n  * Clarify the need for qemu-user-static package\n  * chore(deps): update quay.io/centos/centos docker tag to v8\n  * Renovate: Ensure test/tools/go.mod is managed\n  * Revert \"buildah image should not enable fuse-overlayfs for rootful mode\"\n  * Bump to v1.31.0-dev\n  * parse: add support for relabel bind mount option\n\n- Changelog for v1.30.0 (2023-04-06)\n  * fix(deps): update module github.com/opencontainers/runc to v1.1.5\n  * fix(deps): update module github.com/fsouza/go-dockerclient to v1.9.7\n  * buildah image should not enable fuse-overlayfs for rootful mode\n  * stage_executor: inline network add default string\n  * fix(deps): update module github.com/containers/common to v0.51.2\n  * chore(deps): update dependency containers/automation_images to v20230330\n  * fix(deps): update module github.com/docker/docker to v23.0.2+incompatible\n  * chore(deps): update dependency containers/automation_images to v20230320\n  * fix(deps): update module github.com/onsi/gomega to v1.27.6\n  * fix(deps): update github.com/opencontainers/runtime-tools digest to e931285\n  * [skip-ci] Update actions/stale action to v8\n  * test: don't allow to override io.buildah.version\n  * executor: only apply label on the final stage\n  * Update docs/buildah-build.1.md\n  * update build instruction for Ubuntu\n  * code review\n  * build: accept arguments from file with --build-arg-file\n  * run_linux: Update heuristic for mounting /sys\n  * [CI:BUILD] Packit: Enable Copr builds on PR and commit to main\n  * fix(deps): update module github.com/fsouza/go-dockerclient to v1.9.6\n  * Update to Go 1.18\n  * Disable dependabot in favor of renovate\n  * chore(deps): update dependency containers/automation_images to v20230314\n  * Fix requiring tests on Makefile changes\n  * Vendor in latest containers/(storage, common, image)\n  * imagebuildah: set len(short_image_id) to 12\n  * Re-enable conformance tests\n  * Skip conformance test failures with Docker 23.0.1\n  * Cirrus: Replace Ubuntu -> Debian SID\n  * run: add support for inline --network in RUN stmt\n  * vendor: bump imagebuilder to a3c3f8358ca31b1e4daa6\n  * stage_executor: attempt to push cache only when cacheKey is valid\n  * Add \"ifnewer\" as option in help message for pull command\n  * build: document behaviour of buildah's distributed cache\n  * fix(deps): update module golang.org/x/term to v0.6.0\n  * Add default list of capabilities required to run buildah in a container\n  * executor,copy: honor default ARG value while eval stage\n  * sshagent: use ExtendedAgent instead of Agent\n  * tests/bud: remove unwated test\n  * executor: do not warn on builtin default args\n  * executor: don't warn about unused TARGETARCH,TARGETOS,TARGETPLATFORM\n  * Fix tutorial for rootless mode\n  * Vendor in latest containers/(common, storage, image)\n  * Ignore the base image's base image annotations\n  * fix(deps): update module github.com/fsouza/go-dockerclient to v1.9.5\n  * build(deps): bump github.com/containers/storage from 1.45.3 to 1.45.4\n  * Vendor in latest containers/common\n  * docs/tutorials/04: add defaults for Run()\n  * imagebuildah.StageExecutor: suppress bogus \"Pushing cache []:...\"\n  * executor: also add stage with no children to cleanupStages\n  * [CI:BUILD] copr: fix el8 builds\n  * Fix documentation on which Capabilities are allowed by default\n  * Skip subject-length validation for renovate PRs\n  * Temporarily hard-skip bud-multiple-platform-values test\n  * fix(deps): update github.com/openshift/imagebuilder digest to 86828bf\n  * build(deps): bump github.com/containerd/containerd from 1.6.16 to 1.6.17\n  * build(deps): bump tim-actions/get-pr-commits from 1.1.0 to 1.2.0\n  * build(deps): bump github.com/containers/image/v5 from 5.24.0 to 5.24.1\n  * [skip-ci] Update tim-actions/get-pr-commits digest to 55b867b\n  * build(deps): bump github.com/opencontainers/selinux\n  * build(deps): bump golang.org/x/crypto from 0.5.0 to 0.6.0\n  * Add renovate configuration\n  * Run codespell on codebase\n  * login: support interspersed args for password\n  * conformance: use scratch for minimal test\n  * pkg/parse: expose public CleanCacheMount API\n  * build(deps): bump go.etcd.io/bbolt from 1.3.6 to 1.3.7\n  * build(deps): bump github.com/containerd/containerd from 1.6.15 to 1.6.16\n  * docs: specify order preference for FROM\n  * Bump to v1.30.0-dev\n\n- Changelog for v1.29.0 (2023-01-25)\n  * tests: improve build-with-network-test\n  * Bump c/storagev1.45.3, c/imagev5.24.0, c/commonv0.51.0\n  * build(deps): bump github.com/onsi/gomega from 1.25.0 to 1.26.0\n  * Flake 3710 has been closed. Reenable the test.\n  * [CI:DOCS] Fix two diversity issues in a tutorial\n  * build(deps): bump github.com/fsouza/go-dockerclient from 1.9.2 to 1.9.3\n  * vendor in latests containers/(storage, common, image)\n  * fix bud-multiple-platform-with-base-as-default-arg flake\n  * stage_executor: while mounting stages use freshly built stage\n  * build(deps): bump github.com/fsouza/go-dockerclient from 1.9.0 to 1.9.2\n  * build(deps): bump github.com/onsi/gomega from 1.24.2 to 1.25.0\n  * vendor in latests containers/(storage, common, image, ocicyrpt)\n  * [Itests: change the runtime-flag test for crun\n  * [CI:DOCS] README: drop sudo\n  * Fix multi-arch manifest-list build timeouts\n  * Cirrus: Update VM Images\n  * bud: Consolidate multiple synthetic LABEL instructions\n  * build, secret: allow realtive mountpoints wrt to work dir\n  * fixed squash documentation\n  * build(deps): bump github.com/containerd/containerd from 1.6.14 to 1.6.15\n  * Correct minor comment\n  * Vendor in latest containers/(common, image, storage)\n  * system tests: remove unhelpful assertions\n  * buildah: add prune command and expose CleanCacheMount API\n  * vendor: bump c/storage to a747b27\n  * Add support for --group-add to buildah from\n  * build(deps): bump actions/stale from 6 to 7\n  * Add documentation for buildah build --pull=missing\n  * build(deps): bump github.com/containerd/containerd from 1.6.12 to 1.6.14\n  * build(deps): bump github.com/docker/docker\n  * parse: default ignorefile must not point to symlink outside context\n  * buildah: wrap network setup errors\n  * build, mount: allow realtive mountpoints wrt to work dir\n  * Update to F37 CI VM Images, re-enable prior-fedora\n  * Update vendor or containers/(image, storage, common)\n  * build(deps): bump golang.org/x/crypto from 0.3.0 to 0.4.0\n  * Update contact information\n  * build(deps): bump golang.org/x/term from 0.2.0 to 0.3.0\n  * Replace io/ioutil calls with os calls\n  * [skip-ci] GHA/Cirrus-cron: Fix execution order\n  * Vendor in containers/common\n  * build(deps): bump golang.org/x/sys from 0.2.0 to 0.3.0\n  * remote-cache: support multiple sources and destinations\n  * Update c/storage after https://github.com/containers/storage/pull/1436\n  * util.SortMounts(): make the returned order more stable\n  * version: Bump to 1.29.0-dev\n  * [CI:BUILD] Cirrus: Migrate OSX task to M1\n  * Update vendor of containers/(common, storage, image)\n  * mount=type=cache: seperate cache parent on host for each user\n  * Fix installation instructions for Gentoo Linux\n  * build(deps): bump github.com/containerd/containerd from 1.6.9 to 1.6.10\n  * GHA: Reuse both cirrus rerun and check workflows\n  * Vendor in latest containers/(common,image,storage)\n  * build(deps): bump github.com/onsi/gomega from 1.24.0 to 1.24.1\n  * copier.Put(): clear up os/syscall mode bit confusion\n  * build(deps): bump golang.org/x/sys from 0.1.0 to 0.2.0\n  * Use TypeBind consistently to name bind/nullfs mounts\n  * Add no-new-privileges flag\n  * Update vendor of containers/(common, image, storage)\n  * imagebuildah:build with --all-platforms must honor args for base images\n  * codespell code\n  * Expand args and env when using --all-platforms\n  * build(deps): bump github.com/onsi/gomega from 1.23.0 to 1.24.0\n  * GHA: Simplify Cirrus-Cron check slightly\n  * Stop using ubi8\n  * remove unnecessary (hence misleading) rmi\n  * chroot: fix mounting of ro bind mounts\n  * executor: honor default ARG value while eval base name\n  * userns: add arbitrary steps/stage to --userns=auto test\n  * Don't set allow.mount in the vnet jail on Freebsd\n  * copier: Preserve file flags when copying archives on FreeBSD\n  * Remove quiet flag, so that it works in podman-remote\n  * test: fix preserve rootfs with --mount for podman-remote\n  * test: fix prune logic for cache-from after adding content summary\n  * vendor in latest containers/(storage, common, image)\n  * Fix RUN --mount=type=bind,from=<stage> not preserving rootfs of stage\n  * Define and use a safe, reliable test image\n  * Fix word missing in Container Tools Guide\n  * Makefile: Use $(MAKE) to start sub-makes in install.tools\n  * imagebuildah: pull cache from remote repo after adding content summary\n  * Makefile: Fix install on FreeBSD\n  * Ensure the cache volume locks are unlocked on all paths\n  * Vendor in latest containers/(common,storage)\n  * Simplify the interface of GetCacheMount and getCacheMount\n  * Fix cache locks with multiple mounts\n  * Remove calls to Lockfile.Locked()\n  * Maintain cache mount locks as lock objects instead of paths\n  * test: cleaning cache must not clean lockfiles\n  * run: honor lockfiles for multiple --mount instruction\n  * mount,cache: lockfiles must not be part of users cache content\n  * Update vendor containers/(common,image,storage)\n  * [CI:BUILD] copr: buildah rpm should depend on containers-common-extra\n  * pr-should-include-tests: allow specfile, golangci\n  * build(deps): bump dawidd6/action-send-mail from 3.7.0 to 3.7.1\n  * build(deps): bump github.com/docker/docker\n  * build(deps): bump github.com/fsouza/go-dockerclient from 1.8.3 to 1.9.0\n  * Update vendor containers/(common,image,storage)\n  * build(deps): bump actions/upload-artifact from 2 to 3\n  * build(deps): bump actions/checkout from 2 to 3\n  * build(deps): bump actions/stale from 1 to 6\n  * build(deps): bump dawidd6/action-send-mail from 2.2.2 to 3.7.0\n  * build(deps): bump tim-actions/get-pr-commits from 1.1.0 to 1.2.0\n  * sshagent: LockOSThread before setting SocketLabel\n  * Update tests for error message changes\n  * Update c/image after https://github.com/containers/image/pull/1299\n  * Fix ident for dependabot gha block\n  * build(deps): bump github.com/containers/ocicrypt from 1.1.5 to 1.1.6\n  * Fix man pages to match latest cobra settings\n  * build(deps): bump github.com/spf13/cobra from 1.5.0 to 1.6.0\n  * build(deps): bump github.com/onsi/gomega from 1.20.2 to 1.22.1\n  * test: retrofit 'bud with undefined build arg directory'\n  * imagebuildah: warnOnUnsetBuildArgs while processing stages from executor\n  * Update contrib/buildahimage/Containerfile\n  * Cirrus CI add flavor parameter\n  * Correction - `FLAVOR` not `FLAVOUR`\n  * Changed build argument from `RELEASE` to `FLAVOUR`\n  * Combine buildahimage Containerfiles\n  * bud.bats refactoring: $TEST_SCRATCH_DIR, part 2 of 2\n  * bud.bats refactoring: $TEST_SCRATCH_DIR, part 1 of 2\n  * System test cleanup: document, clarify, fix\n  * test: removing unneeded/expensive COPY\n  * test: warning behaviour for unset/set TARGETOS,TARGETARCH,TARGETPLATFORM\n  * Bump to v1.28.1-dev\n\n- Changelog for v1.28.0 (2022-09-30)\n  * Update vendor containers/(common,image)\n  * [CI:DOCS] Add quay-description update reminder\n  * vendor: bump c/common to v0.49.2-0.20220929111928-2d1b45ae2423\n  * build(deps): bump github.com/opencontainers/selinux\n  * Vendor in latest containers/storage\n  * Changing shell list operators from `;` to `&&`\n  * Fix buildahimage container.conf permissions regression\n  * Set sysctls from containers.conf\n  * refactor: stop using Normalize directly from containerd package\n  * config,builder: process variant while populating image spec\n  * Proof of concept: nightly dependency treadmill\n  * Run codespell on code\n  * Check for unset build args after TARGET args\n  * pkg/cli: improve completion test\n  * vendor in latest containers/(common,storage,image)\n  * copier: work around freebsd bug for \"mkdir /\"\n  * vendor: update c/image\n  * test: run in the host cgroup namespace\n  * vendor: update c/storage\n  * vendor: update c/common\n  * cmd: check for user UID instead of privileges\n  * run,build: conflict --isolation=chroot and --network\n  * Fix broken dns test (from merge collision)\n  * Fix stutters\n  * Fix broken command completion\n  * buildah bud --network=none should have no network\n  * build: support --skip-unused-stages for multi-stage builds\n  * Prevent use of --dns* options with --net=none\n  * buildah: make --cache-ttl=0s equivalent to --no-cache\n  * parse: make processing flags in --mount order agnostic\n  * Minor test fix for podman-remote\n  * build: honor <Containerfile>.containerignore as ignore file\n  * Update install.md: Debian 11 (Bullseye) is stable\n  * build(deps): bump github.com/docker/docker\n  * Use constants from containers/common for finding seccomp.json\n  * Don't call os.Exit(1) from manifest exist\n  * manifest: add support for buildah manifest exists\n  * Buildah should ignore /etc/crio/seccomp.json\n  * chroot: Fix cross build break\n  * chroot: Move isDevNull to run_common.go\n  * chroot: Fix setRlimit build on FreeBSD\n  * chroot: Move parseRLimits and setRlimits to run_common.go\n  * chroot: Fix runUsingChrootExecMain on FreeBSD\n  * chroot: Move runUsingChrootExecMain to run_common.go\n  * chroot: Factor out Linux-specific unshare options from runUsingChroot\n  * chroot: Move runUsingChroot to run_common.go\n  * chroot: Move RunUsingChroot and runUsingChrootMain to run_common.go\n  * chroot: Factor out /dev/ptmx pty implementation\n  * chroot: Add FreeBSD support for run with chroot isolation\n  * build(deps): bump github.com/docker/go-units from 0.4.0 to 0.5.0\n  * Replace k8s.gcr.io/pause in tests with registry.k8s.io/pause\n  * build(deps): bump github.com/onsi/gomega from 1.20.0 to 1.20.1\n  * Cirrus: use image with fewer downloaded dependencies\n  * build(deps): bump github.com/opencontainers/runc from 1.1.3 to 1.1.4\n  * run: add container gid to additional groups\n  * buildah: support for --retry and --retry-delay for push/pull failures\n  * Makefile: always call $(GO) instead of `go`\n  * build(deps): bump github.com/fsouza/go-dockerclient from 1.8.2 to 1.8.3\n  * test: use `T.TempDir` to create temporary test directory\n  * mount,cache: enable SElinux shared content label option by default\n  * commit: use race-free RemoveNames instead of SetNames\n  * Drop util/util.Cause()\n  * cmd/buildah: add \"manifest create --amend\"\n  * build(deps): bump github.com/fsouza/go-dockerclient from 1.8.1 to 1.8.2\n  * docs: specify git protocol is not supported for github hosted repo\n  * Scrub user and group names from layer diffs\n  * build(deps): bump github.com/containerd/containerd from 1.6.6 to 1.6.8\n  * version: bump to 1.28.0-dev\n\n- Changelog for v1.27.0 (2022-08-01)\n  * build: support filtering cache by duration using `--cache-ttl`.\n  * build: support building from commit when using git repo as build context.\n  * build: clean up git repos correctly when using subdirs.\n  * build: add support for distributing cache to remote sources using `--cache-to` and `--cache-from`.\n  * imagebuildah: optimize cache hits for `COPY` and `ADD` instructions.\n  * build: support OCI hooks for ephemeral build containers.\n  * build: add support for `--userns=auto`.\n  * copier: add NoOverwriteNonDirDir option .\n  * add initial support for building images using Buildah on FreeBSD.\n  * multistage: this now skips the computing of unwanted stages to improve performance.\n  * multiarch: support splitting build logs for `--platform` using `--logsplit`.\n  * build: add support for building images where the base image has no history.\n  * commit: allow disabling image history with `--omit-history`.\n  * build: add support for renaming a device in rootless setups.\n  * build: now supports additionalBuildContext in builds via the `--build-context` option.\n  * build: `--output` produces artifacts even if the build container is not committed.\n  * build: now accepts `-cpp-flag`, allowing users to pass in CPP flags when processing a Containerfile with C Preprocessor-like syntax.\n  * build: now accepts a branch and a subdirectory when the build context is a git repository.\n  * build: output now shows a progress bar while pushing and pulling images\n  * build: now errors out if the path to Containerfile is a directory.\n  * build: support building container images on environments that are rootless and without any valid login sessions.\n  * fix: `--output` now generates artifacts even if the entire build is cached.\n  * fix: `--output` generates artifacts only for the target stage in multi-stage builds.\n  * fix,add: now fails on a bad HTTP response instead of writing to container\n  * fix,squash: never use build cache when computing the last step of the last stage\n  * fix,build,run: allow reusing secret more than once in different RUN steps\n  * fix: compatibility with Docker build by making its --label and --annotate options set empty labels and annotations when given a name but no `=` or label value.\n\n- Changelog for v1.26.0 (2022-05-04)\n  * imagebuildah,build: move deepcopy of args before we spawn goroutine\n  * Vendor in containers/storage v1.40.2\n  * buildah.BuilderOptions.DefaultEnv is ignored, so mark it as deprecated\n  * help output: get more consistent about option usage text\n  * Handle OS version and features flags\n  * buildah build: --annotation and --label should remove values\n  * buildah build: add a --env\n  * buildah: deep copy options.Args before performing concurrent build/stage\n  * test: inline platform and builtinargs behaviour\n  * vendor: bump imagebuilder to master/009dbc6\n  * build: automatically set correct TARGETPLATFORM where expected\n  * build(deps): bump github.com/fsouza/go-dockerclient\n  * Vendor in containers/(common, storage, image)\n  * imagebuildah, executor: process arg variables while populating baseMap\n  * buildkit: add support for custom build output with --output\n  * Cirrus: Update CI VMs to F36\n  * fix staticcheck linter warning for deprecated function\n  * Fix docs build on FreeBSD\n  * build(deps): bump github.com/containernetworking/cni from 1.0.1 to 1.1.0\n  * copier.unwrapError(): update for Go 1.16\n  * copier.PutOptions: add StripSetuidBit/StripSetgidBit/StripStickyBit\n  * copier.Put(): write to read-only directories\n  * build(deps): bump github.com/cpuguy83/go-md2man/v2 in /tests/tools\n  * Rename $TESTSDIR (the plural one), step 4 of 3\n  * Rename $TESTSDIR (the plural one), step 3 of 3\n  * Rename $TESTSDIR (the plural one), step 2 of 3\n  * Rename $TESTSDIR (the plural one), step 1 of 3\n  * build(deps): bump github.com/containerd/containerd from 1.6.2 to 1.6.3\n  * Ed's periodic test cleanup\n  * using consistent lowercase 'invalid' word in returned err msg\n  * Update vendor of containers/(common,storage,image)\n  * use etchosts package from c/common\n  * run: set actual hostname in /etc/hostname to match docker parity\n  * update c/common to latest main\n  * Update vendor of containers/(common,storage,image)\n  * Stop littering\n  * manifest-create: allow creating manifest list from local image\n  * Update vendor of storage,common,image\n  * Bump golang.org/x/crypto to 7b82a4e\n  * Initialize network backend before first pull\n  * oci spec: change special mount points for namespaces\n  * tests/helpers.bash: assert handle corner cases correctly\n  * buildah: actually use containers.conf settings\n  * integration tests: learn to start a dummy registry\n  * Fix error check to work on Podman\n  * buildah build should accept at most one arg\n  * tests: reduce concurrency for flaky bud-multiple-platform-no-run\n  * vendor in latest containers/common,image,storage\n  * manifest-add: allow override arch,variant while adding image\n  * Remove a stray `\\` from .containerenv\n  * Vendor in latest opencontainers/selinux v1.10.1\n  * build, commit: allow removing default identity labels\n  * Create shorter names for containers based on image IDs\n  * test: skip rootless on cgroupv2 in root env\n  * fix hang when oci runtime fails\n  * Set permissions for GitHub actions\n  * copier test: use correct UID/GID in test archives\n  * run: set parent-death signals and forward SIGHUP/SIGINT/SIGTERM\n  * Bump back to v1.26.0-dev\n  * build(deps): bump github.com/opencontainers/runc from 1.1.0 to 1.1.1\n  * Included the URL to check the SHA\n\n- Changelog for v1.25.1 (2022-03-30)\n  * buildah: create WORKDIR with USER permissions\n  * vendor: update github.com/openshift/imagebuilder\n  * copier: attempt to open the dir before adding it\n  * Updated dependabot to get updates for GitHub actions.\n  * Switch most calls to filepath.Walk to filepath.WalkDir\n  * build: allow --no-cache and --layers so build cache can be overrided\n  * build(deps): bump github.com/onsi/gomega from 1.18.1 to 1.19.0\n  * Bump to v1.26.0-dev\n  * build(deps): bump github.com/golangci/golangci-lint in /tests/tools\n\n- Changelog for v1.25.0 (2022-03-25)\n  * install: drop RHEL/CentOS 7 doc\n  * build(deps): bump github.com/containers/common from 0.47.4 to 0.47.5\n  * Bump c/storage to v1.39.0 in main\n  * Add a test for CVE-2022-27651\n  * build(deps): bump github.com/docker/docker\n  * Bump github.com/prometheus/client_golang to v1.11.1\n  * [CI:DOCS] man pages: sort flags, and keep them that way\n  * build(deps): bump github.com/containerd/containerd from 1.6.1 to 1.6.2\n  * Don't pollute\n  * network setup: increase timeout to 4 minutes\n  * do not set the inheritable capabilities\n  * build(deps): bump github.com/golangci/golangci-lint in /tests/tools\n  * build(deps): bump github.com/containers/ocicrypt from 1.1.2 to 1.1.3\n  * parse: convert exposed GetVolumes to internal only\n  * buildkit: mount=type=cache support locking external cache store\n  * .in support: improve error message when cpp is not installed\n  * buildah image: install cpp\n  * build(deps): bump github.com/stretchr/testify from 1.7.0 to 1.7.1\n  * build(deps): bump github.com/spf13/cobra from 1.3.0 to 1.4.0\n  * build(deps): bump github.com/docker/docker\n  * Add --no-hosts flag to eliminate use of /etc/hosts within containers\n  * test: remove skips for rootless users\n  * test: unshare mount/umount if test is_rootless\n  * tests/copy: read correct containers.conf\n  * build(deps): bump github.com/docker/distribution\n  * cirrus: add seperate task and matrix for rootless\n  * tests: skip tests for rootless which need unshare\n  * buildah: test rootless integration\n  * vendor: bump c/storage to main/93ce26691863\n  * build(deps): bump github.com/fsouza/go-dockerclient from 1.7.9 to 1.7.10\n  * tests/copy: initialize the network, too\n  * [CI:DOCS] remove references to Kubic for CentOS and Ubuntu\n  * build(deps): bump github.com/containerd/containerd from 1.6.0 to 1.6.1\n  * use c/image/pkg/blobcache\n  * vendor c/image/v5@v5.20.0\n  * add: ensure the context directory is an absolute path\n  * executor: docker builds must inherit healthconfig from base if any\n  * docs: Remove Containerfile and containeringore\n  * build(deps): bump github.com/fsouza/go-dockerclient from 1.7.8 to 1.7.9\n  * helpers.bash: Use correct syntax\n  * speed up combination-namespaces test\n  * build(deps): bump github.com/golangci/golangci-lint in /tests/tools\n  * Bump back to 1.25.0-dev\n  * build(deps): bump github.com/containerd/containerd from 1.5.9 to 1.6.0\n\n- Changelog for v1.24.2 (2022-02-16)\n  * Increase subuid/subgid to 65535\n  * history: only add proxy vars to history if specified\n  * run_linux: use --systemd-cgroup\n  * buildah: new global option --cgroup-manager\n  * Makefile: build with systemd when available\n  * build(deps): bump github.com/fsouza/go-dockerclient from 1.7.7 to 1.7.8\n  * Bump c/common to v0.47.4\n  * Cirrus: Use updated VM images\n  * conformance: add a few \"replace-directory-with-symlink\" tests\n  * Bump back to v1.25.0-dev\n\n- Changelog for v1.24.1 (2022-02-03)\n  * executor: Add support for inline --platform within Dockerfile\n  * caps: fix buildah run --cap-add=all\n  * Update vendor of openshift/imagebuilder\n  * Bump version of containers/image and containers/common\n  * Update vendor of containers/common\n  * System tests: fix accidental vandalism of source dir\n  * build(deps): bump github.com/containers/storage from 1.38.1 to 1.38.2\n  * imagebuildah.BuildDockerfiles(): create the jobs semaphore\n  * build(deps): bump github.com/onsi/gomega from 1.18.0 to 1.18.1\n  * overlay: always honor mountProgram\n  * overlay: move mount program invocation to separate function\n  * overlay: move mount program lookup to separate function\n  * Bump to v1.25.0-dev [NO TESTS NEEDED]\n\n- Changelog for v1.24.0 (2022-01-26)\n  * Update vendor of containers/common\n  * build(deps): bump github.com/golangci/golangci-lint in /tests/tools\n  * Github-workflow: Report both failures and errors.\n  * build(deps): bump github.com/containers/image/v5 from 5.18.0 to 5.19.0\n  * Update docs/buildah-build.1.md\n  * [CI:DOCS] Fix typos and improve language\n  * buildah bud --network add support for custom networks\n  * Make pull commands be consistent\n  * docs/buildah-build.1.md: don't imply that -v isn't just a RUN thing\n  * build(deps): bump github.com/onsi/gomega from 1.17.0 to 1.18.0\n  * Vendor in latest containers/image\n  * Run codespell on code\n  * .github/dependabot.yml: add tests/tools go.mod\n  * CI: rm git-validation, add GHA job to validate PRs\n  * tests/tools: bump go-md2man to v2.0.1\n  * tests/tools/Makefile: simplify\n  * tests/tools: bump onsi/ginkgo to v1.16.5\n  * vendor: bump c/common and others\n  * mount: add support for custom upper and workdir with overlay mounts\n  * linux: fix lookup for runtime\n  * overlay: add MountWithOptions to API which extends support for advanced overlay\n  * Allow processing of SystemContext from FlagSet\n  * .golangci.yml: enable unparam linter\n  * util/resolveName: rm bool return\n  * tests/tools: bump golangci-lint\n  * .gitignore: fixups\n  * all: fix capabilities.NewPid deprecation warnings\n  * bind/mount.go: fix linter comment\n  * all: fix gosimple warning S1039\n  * tests/e2e/buildah_suite_test.go: fix gosimple warnings\n  * imagebuildah/executor.go: fix gosimple warning\n  * util.go: fix gosimple warning\n  * build(deps): bump github.com/opencontainers/runc from 1.0.3 to 1.1.0\n  * Enable git-daemon tests\n  * Allow processing of id options from FlagSet\n  * Cirrus: Re-order tasks for more parallelism\n  * Cirrus: Freshen VM images\n  * Fix platform handling for empty os/arch values\n  * Allow processing of network options from FlagSet\n  * Fix permissions on  secrets directory\n  * Update containers/image and containers/common\n  * bud.bats: use a local git daemon for the git protocol test\n  * Allow processing of common options from FlagSet\n  * Cirrus: Run int. tests in parallel with unit\n  * vendor c/common\n  * Fix default CNI paths\n  * build(deps): bump github.com/fsouza/go-dockerclient from 1.7.6 to 1.7.7\n  * multi-stage: enable mounting stages across each other with selinux enabled\n  * executor: Share selinux label of first stage with other stages in a build\n  * buildkit: add from field to bind and cache mounts so images can be used as source\n  * Use config.ProxyEnv from containers/common\n  * use libnetwork from c/common for networking\n  * setup the netns in the buildah parent process\n  * build(deps): bump github.com/containerd/containerd from 1.5.8 to 1.5.9\n  * build(deps): bump github.com/fsouza/go-dockerclient from 1.7.4 to 1.7.6\n  * build: fix libsubid test\n  * Allow callers to replace the ContainerSuffix\n  * parse: allow parsing anomaly non-human value for memory control group\n  * .cirrus: remove static_build from ci\n  * stage_executor: re-use all possible layers from cache for squashed builds\n  * build(deps): bump github.com/spf13/cobra from 1.2.1 to 1.3.0\n  * Allow rootless buildah to set resource limits on cgroup V2\n  * build(deps): bump github.com/docker/docker\n  * tests: move buildkit mount tests files from TESTSDIR to TESTDIR before modification\n  * build(deps): bump github.com/opencontainers/runc from 1.0.2 to 1.0.3\n  * Wire logger through to config\n  * copier.Put: check for is-not-a-directory using lstat, not stat\n  * Turn on rootless cgroupv2 tests\n  * Grab all of the containers.conf settings for namespaces.\n  * image: set MediaType in OCI manifests\n  * copier: RemoveAll possibly-directories\n  * Simple README fix\n  * images: accept multiple filter with logical AND\n  * build(deps): bump github.com/containernetworking/cni from 0.8.1 to 1.0.1\n  * UPdate vendor of container/storage\n  * build(deps): bump github.com/onsi/gomega from 1.16.0 to 1.17.0\n  * build(deps): bump github.com/containers/image/v5 from 5.16.1 to 5.17.0\n  * Make LocalIP public function so Podman can use it\n  * Fix UnsetEnv for buildah bud\n  * Tests should rely only on static/unchanging images\n  * run: ensure that stdio pipes are labeled correctly\n  * build(deps): bump github.com/docker/docker\n  * Cirrus: Bump up to Fedora 35 & Ubuntu 21.10\n  * chroot: don't use the generate default seccomp filter for unit tests\n  * build(deps): bump github.com/containerd/containerd from 1.5.7 to 1.5.8\n  * ssh-agent: Increase timeout before we explicitly close connection\n  * docs/tutorials: update\n  * Clarify that manifest defaults to localhost as the registry name\n  * \"config\": remove a stray bit of debug output\n  * \"commit\": fix a flag typo\n  * Fix an error message: unlocking vs locking\n  * Expand the godoc for CommonBuildOptions.Secrets\n  * chroot: accept an \"rw\" option\n  * Add --unsetenv option to buildah commit and build\n  * define.TempDirForURL(): show CombinedOutput when a command fails\n  * config: support the variant field\n  * rootless: do not bind mount /sys if not needed\n  * Fix tutorial to specify command on buildah run line\n  * build: history should not contain ARG values\n  * docs: Use guaranteed path for go-md2man\n  * run: honor --network=none from builder if nothing specified\n  * networkpolicy: Should be enabled instead of default when explictly set\n  * Add support for env var secret sources\n  * build(deps): bump github.com/docker/docker\n  * fix: another non-portable shebang\n  * Rootless containers users should use additional groups\n  * Support overlayfs path contains colon\n  * Report ignorefile location when no content added\n  * Add support for host.containers.internal in the /etc/hosts\n  * build(deps): bump github.com/onsi/ginkgo from 1.16.4 to 1.16.5\n  * imagebuildah: fix nil deref\n  * buildkit: add support for mount=type=cache\n  * Default secret mode to 400\n  * [CI:DOCS] Include manifest example usage\n  * docs: update buildah-from, buildah-pull 'platform' option compatibility notes\n  * docs: update buildah-build 'platform' option compatibility notes\n  * De-dockerize the man page as much as possible\n  * [CI:DOCS] Touch up Containerfile man page to show ARG can be 1st\n  * docs: Fix and Update Containerfile man page with supported mount types\n  * mount: add tmpcopyup to tmpfs mount option\n  * buildkit: Add support for --mount=type=tmpfs\n  * build(deps): bump github.com/opencontainers/selinux from 1.8.5 to 1.9.1\n  * Fix command doc links in README.md\n  * build(deps): bump github.com/containers/image/v5 from 5.16.0 to 5.16.1\n  * build: Add support for buildkit like --mount=type=bind\n  * Bump containerd to v1.5.7\n  * build(deps): bump github.com/docker/docker\n  * tests: stop pulling php, composer\n  * Fix .containerignore link file\n  * Cirrus: Fix defunct package metadata breaking cache\n  * build(deps): bump github.com/containers/storage from 1.36.0 to 1.37.0\n  * buildah build: add --all-platforms\n  * Add man page for Containerfile and .containerignore\n  * Plumb the remote logger throughut Buildah\n  * Replace fmt.Sprintf(\"%d\", x) with strconv.Itoa(x)\n  * Run: Cleanup run directory after every RUN step\n  * build(deps): bump github.com/containers/common from 0.45.0 to 0.46.0\n  * Makefile: adjust -ldflags/-gcflags/-gccgoflags depending on the go implementation\n  * Makefile: check for `-race` using `-mod=vendor`\n  * imagebuildah: fix an attempt to write to a nil map\n  * push: support to specify the compression format\n  * conformance: allow test cases to specify dockerUseBuildKit\n  * build(deps): bump github.com/containers/common from 0.44.1 to 0.45.0\n  * build(deps): bump github.com/containers/common from 0.44.0 to 0.44.1\n  * unmarshalConvertedConfig(): handle zstd compression\n  * tests/copy/copy: wire up compression options\n  * Update to github.com/vbauerster/mpb v7.1.5\n  * Add flouthoc to OWNERS\n  * build: Add additional step nodes when labels are modified\n  * Makefile: turn on race detection whenever it's available\n  * conformance: add more tests for exclusion short-circuiting\n  * Update VM Images + Drop prior-ubuntu testing\n  * Bump to v1.24.0-dev\n\n- Changelog for v1.23.0 (2021-09-13)\n  * Vendor in containers/common v0.44.0\n  * build(deps): bump github.com/containers/storage from 1.35.0 to 1.36.0\n  * Update 05-openshift-rootless-build.md\n  * build(deps): bump github.com/opencontainers/selinux from 1.8.4 to 1.8.5\n  * .cirrus.yml: run cross_build_task on Big Sur\n  * Makefile: update cross targets\n  * Add support for rootless overlay mounts\n  * Cirrus: Increase unit-test timeout\n  * Docs: Clarify rmi w/ manifest/index use\n  * build: mirror --authfile to filesystem if pointing to FD instead of file\n  * Fix build with .git url with branch\n  * manifest: rm should remove only manifests not referenced images.\n  * vendor: bump c/common to v0.43.3-0.20210902095222-a7acc160fb25\n  * Avoid rehashing and noop compression writer\n  * corrected man page section; .conf file to mention its man page\n  * copy: add --max-parallel-downloads to tune that copy option\n  * copier.Get(): try to avoid descending into directories\n  * tag: Support tagging manifest list instead of resolving to images\n  * Install new manpages to correct sections\n  * conformance: tighten up exception specifications\n  * Add support for libsubid\n  * Add epoch time field to buildah images\n  * Fix ownership of /home/build/.local/share/containers\n  * build(deps): bump github.com/containers/image/v5 from 5.15.2 to 5.16.0\n  * Rename bud to build, while keeping an alias for to bud.\n  * Replace golang.org/x/crypto/ssh/terminal with golang.org/x/term\n  * build(deps): bump github.com/opencontainers/runc from 1.0.1 to 1.0.2\n  * build(deps): bump github.com/onsi/gomega from 1.15.0 to 1.16.0\n  * build(deps): bump github.com/fsouza/go-dockerclient from 1.7.3 to 1.7.4\n  * build(deps): bump github.com/containers/common from 0.43.1 to 0.43.2\n  * Move DiscoverContainerfile to pkg/util directory\n  * build(deps): bump github.com/containers/image/v5 from 5.15.1 to 5.15.2\n  * Remove some references to Docker\n  * build(deps): bump github.com/containers/image/v5 from 5.15.0 to 5.15.1\n  * imagebuildah: handle --manifest directly\n  * build(deps): bump github.com/containers/common from 0.42.1 to 0.43.1\n  * build(deps): bump github.com/opencontainers/selinux from 1.8.3 to 1.8.4\n  * executor: make sure imageMap is updated with terminatedStage\n  * tests/serve/serve.go: use a kernel-assigned port\n  * Bump go for vendor-in-container from 1.13 to 1.16\n  * imagebuildah: move multiple-platform building internal\n  * Adds GenerateStructure helper function to support rootfs-overlay.\n  * Run codespell to fix spelling\n  * Implement SSH RUN mount\n  * build(deps): bump github.com/onsi/gomega from 1.14.0 to 1.15.0\n  * Fix resolv.conf content with run --net=private\n  * run: fix nil deref using the option's logger\n  * build(deps): bump github.com/containerd/containerd from 1.5.1 to 1.5.5\n  * make vendor-in-container\n  * bud: teach --platform to take a list\n  * set base-image annotations\n  * build(deps): bump github.com/opencontainers/selinux from 1.8.2 to 1.8.3\n  * [CI:DOCS] Fix CHANGELOG.md\n  * Bump to v1.23.0-dev [NO TESTS NEEDED]\n  * Accept repositories on login/logout\n\n- Changelog for v1.22.0 (2021-08-02)\n  * c/image, c/storage, c/common vendor before Podman 3.3 release\n  * WIP: tests: new assert()\n  * Proposed patch for 3399 (shadowutils)\n  * Fix handling of --restore shadow-utils\n  * build(deps): bump github.com/containers/image/v5 from 5.13.2 to 5.14.0\n  * runtime-flag (debug) test: handle old & new runc\n  * build(deps): bump github.com/containers/storage from 1.32.6 to 1.33.0\n  * Allow dst and destination for target in secret mounts\n  * Multi-arch: Always push updated version-tagged img\n  * Add a few tests on cgroups V2\n  * imagebuildah.stageExecutor.prepare(): remove pseudonym check\n  * refine dangling filter\n  * Chown with environment variables not set should fail\n  * Just restore protections of shadow-utils\n  * build(deps): bump github.com/opencontainers/runc from 1.0.0 to 1.0.1\n  * Remove specific kernel version number requirement from install.md\n  * Multi-arch image workflow: Make steps generic\n  * chroot: fix environment value leakage to intermediate processes\n  * Update nix pin with `make nixpkgs`\n  * buildah source - create and manage source images\n  * Update cirrus-cron notification GH workflow\n  * Reuse code from containers/common/pkg/parse\n  * Cirrus: Freshen VM images\n  * build(deps): bump github.com/containers/storage from 1.32.5 to 1.32.6\n  * Fix excludes exception begining with / or ./\n  * Fix syntax for --manifest example\n  * build(deps): bump github.com/onsi/gomega from 1.13.0 to 1.14.0\n  * vendor containers/common@main\n  * Cirrus: Drop dependence on fedora-minimal\n  * Adjust conformance-test error-message regex\n  * Workaround appearance of differing debug messages\n  * Cirrus: Install docker from package cache\n  * build(deps): bump github.com/containers/ocicrypt from 1.1.1 to 1.1.2\n  * Switch rusagelogfile to use options.Out\n  * build(deps): bump github.com/containers/storage from 1.32.4 to 1.32.5\n  * Turn stdio back to blocking when command finishes\n  * Add support for default network creation\n  * Cirrus: Updates for master->main rename\n  * Change references from master to main\n  * Add `--env` and `--workingdir` flags to run command\n  * build(deps): bump github.com/opencontainers/runc\n  * [CI:DOCS] buildah bud: spelling --ignore-file requires parameter\n  * [CI:DOCS] push/pull: clarify supported transports\n  * Remove unused function arguments\n  * Create mountOptions for mount command flags\n  * Extract version command implementation to function\n  * Add --json flags to `mount` and `version` commands\n  * build(deps): bump github.com/containers/storage from 1.32.2 to 1.32.3\n  * build(deps): bump github.com/containers/common from 0.40.0 to 0.40.1\n  * copier.Put(): set xattrs after ownership\n  * buildah add/copy: spelling\n  * build(deps): bump github.com/containers/common from 0.39.0 to 0.40.0\n  * buildah copy and buildah add should support .containerignore\n  * Remove unused util.StartsWithValidTransport\n  * Fix documentation of the --format option of buildah push\n  * Don't use alltransports.ParseImageName with known transports\n  * build(deps): bump github.com/containers/image/v5 from 5.13.0 to 5.13.1\n  * man pages: clarify `rmi` removes dangling parents\n  * tests: make it easer to override the location of the copy helper\n  * build(deps): bump github.com/containers/image/v5 from 5.12.0 to 5.13.0\n  * [CI:DOCS] Fix links to c/image master branch\n  * imagebuildah: use the specified logger for logging preprocessing warnings\n  * Fix copy into workdir for a single file\n  * Fix docs links due to branch rename\n  * Update nix pin with `make nixpkgs`\n  * build(deps): bump github.com/fsouza/go-dockerclient from 1.7.2 to 1.7.3\n  * build(deps): bump github.com/opencontainers/selinux from 1.8.1 to 1.8.2\n  * build(deps): bump go.etcd.io/bbolt from 1.3.5 to 1.3.6\n  * build(deps): bump github.com/containers/storage from 1.32.1 to 1.32.2\n  * build(deps): bump github.com/mattn/go-shellwords from 1.0.11 to 1.0.12\n  * build(deps): bump github.com/onsi/ginkgo from 1.16.3 to 1.16.4\n  * fix(docs): typo\n  * Move to v1.22.0-dev\n  * Fix handling of auth.json file while in a user namespace\n  * Add rusage-logfile flag to optionally send rusage to a file\n  * imagebuildah: redo step logging\n  * build(deps): bump github.com/onsi/ginkgo from 1.16.2 to 1.16.3\n  * build(deps): bump github.com/containers/storage from 1.32.0 to 1.32.1\n  * Add volumes to make running buildah within a container easier\n  * build(deps): bump github.com/onsi/gomega from 1.12.0 to 1.13.0\n  * Add and use a \"copy\" helper instead of podman load/save\n  * Bump github.com/containers/common from 0.38.4 to 0.39.0\n  * containerImageRef/containerImageSource: don't buffer uncompressed layers\n  * containerImageRef(): squashed images have no parent images\n  * Sync. workflow across skopeo, buildah, and podman\n  * Bump github.com/containers/storage from 1.31.1 to 1.31.2\n  * Bump github.com/opencontainers/runc from 1.0.0-rc94 to 1.0.0-rc95\n  * Bump to v1.21.1-dev [NO TESTS NEEDED]\n\n- Changelog for v1.21.0 (2021-05-19)\n  * Don't blow up if cpp detects errors\n  * Vendor in containers/common v0.38.4\n  * Remove 'buildah run --security-opt' from completion\n  * update c/common\n  * Fix handling of --default-mounts-file\n  * update vendor of containers/storage v1.31.1\n  * Bump github.com/containers/storage from 1.30.3 to 1.31.0\n  * Send logrus messages back to caller when building\n  * github: Fix bad repo. ref in workflow config\n  * Check earlier for bad image tags name\n  * buildah bud: fix containers/podman/issues/10307\n  * Bump github.com/containers/storage from 1.30.1 to 1.30.3\n  * Cirrus: Support [CI:DOCS] test skipping\n  * Notification email for cirrus-cron build failures\n  * Bump github.com/opencontainers/runc from 1.0.0-rc93 to 1.0.0-rc94\n  * Fix race condition\n  * Fix copy race while walking paths\n  * Preserve ownership of lower directory when doing an overlay mount\n  * Bump github.com/onsi/gomega from 1.11.0 to 1.12.0\n  * Update nix pin with `make nixpkgs`\n  * codespell cleanup\n  * Multi-arch github-action workflow unification\n  * Bump github.com/containers/image/v5 from 5.11.1 to 5.12.0\n  * Bump github.com/onsi/ginkgo from 1.16.1 to 1.16.2\n  * imagebuildah: ignore signatures when tagging images\n  * update to latest libimage\n  * Bump github.com/containers/common from 0.37.0 to 0.37.1\n  * Bump github.com/containers/storage from 1.30.0 to 1.30.1\n  * Upgrade to GitHub-native Dependabot\n  * Document location of auth.json file if XDG_RUNTIME_DIR is not set\n  * run.bats: fix flake in run-user test\n  * Cirrus: Update F34beta -> F34\n  * pr-should-include-tests: try to make work in buildah\n  * runUsingRuntime: when relaying error from the runtime, mention that\n  * Run(): avoid Mkdir() into the rootfs\n  * imagebuildah: replace archive with chrootarchive\n  * imagebuildah.StageExecutor.volumeCacheSaveVFS(): set up bind mounts\n  * conformance: use :Z with transient mounts when SELinux is enabled\n  * bud.bats: fix a bats warning\n  * imagebuildah: create volume directories when using overlays\n  * imagebuildah: drop resolveSymlink()\n  * namespaces test - refactoring and cleanup\n  * Refactor 'idmapping' system test\n  * Cirrus: Update Ubuntu images to 21.04\n  * Tiny fixes in bud system tests\n  * Add compabitility wrappers for removed packages\n  * Fix expected message at pulling image\n  * Fix system tests of 'bud' subcommand\n  * [CI:DOCS] Update steps for CentOS runc users\n  * Add support for secret mounts\n  * Add buildah manifest rm command\n  * restore push/pull and util API\n  * [CI:DOCS] Remove older distro docs\n  * Rename rhel secrets to subscriptions\n  * vendor in openshift/imagebuilder\n  * Remove buildah bud --loglevel ...\n  * use new containers/common/libimage package\n  * Fix copier when using globs\n  * Test namespace flags of 'bud' subcommand\n  * Add system test of 'bud' subcommand\n  * Output names of multiple tags in buildah bud\n  * push to docker test: don't get fooled by podman\n  * copier: add Remove()\n  * build(deps): bump github.com/containers/image/v5 from 5.10.5 to 5.11.1\n  * Restore log timestamps\n  * Add system test of 'buildah help' with a tiny fix\n  * tests: copy.bats: fix infinite hang\n  * Do not force hard code to crun in rootless mode\n  * build(deps): bump github.com/openshift/imagebuilder from 1.2.0 to 1.2.1\n  * build(deps): bump github.com/containers/ocicrypt from 1.1.0 to 1.1.1\n  * build(deps): bump github.com/containers/common from 0.35.4 to 0.36.0\n  * Fix arg missing warning in bud\n  * Check without flag in 'from --cgroup-parent' test\n  * Minor fixes to Buildah as a library tutorial documentation\n  * Add system test of 'buildah version' for packaged buildah\n  * Add a few system tests of 'buildah from'\n  * Log the final error with %+v at logging level \"trace\"\n  * copier: add GetOptions.NoCrossDevice\n  * Update nix pin with `make nixpkgs`\n  * Bump to v1.20.2-dev\n\n- Changelog for v1.20.1 (2021-04-13)\n  * Run container with isolation type set at 'from'\n  * bats helpers.bash - minor refactoring\n  * Bump containers/storage vendor to v1.29.0\n  * build(deps): bump github.com/onsi/ginkgo from 1.16.0 to 1.16.1\n  * Cirrus: Update VMs w/ F34beta\n  * CLI add/copy: add a --from option\n  * build(deps): bump github.com/onsi/ginkgo from 1.15.2 to 1.16.0\n  * Add authentication system tests for 'commit' and 'bud'\n  * fix local image lookup for custom platform\n  * Double-check existence of OCI runtimes\n  * Cirrus: Make use of shared get_ci_vm container\n  * Add system tests of \"buildah run\"\n  * Update nix pin with `make nixpkgs`\n  * Remove some stuttering on returns errors\n  * Setup alias for --tty to --terminal\n  * Add conformance tests for COPY /...\n  * Put a few more minutes on the clock for the CI conformance test\n  * Add a conformance test for COPY --from $symlink\n  * Add conformance tests for COPY \"\"\n  * Check for symlink in builtin volume\n  * Sort all mounts by destination directory\n  * System-test cleanup\n  * Export parse.Platform string to be used by podman-remote\n  * blobcache: fix sequencing error\n  * build(deps): bump github.com/containers/common from 0.35.3 to 0.35.4\n  * Fix URL in demos/buildah_multi_stage.sh\n  * Add a few system tests\n  * [NO TESTS NEEDED] Use --recurse-modules when building git context\n  * Bump to v1.20.1-dev\n\n- Changelog for v1.20.0 (2021-03-25)\n  * vendor in containers/storage v1.28.1\n  * build(deps): bump github.com/containers/common from 0.35.2 to 0.35.3\n  * tests: prefetch: use buildah, not podman, for pulls\n  * Use faster way to check image tag existence during multi-arch build\n  * Add information about multi-arch images to the Readme\n  * COPY --chown: expand the conformance test\n  * pkg/chrootuser: use a bufio.Scanner\n  * [CI:DOCS] Fix rootful typo in docs\n  * build(deps): bump github.com/onsi/ginkgo from 1.15.1 to 1.15.2\n  * Add documentation and testing for .containerignore\n  * build(deps): bump github.com/sirupsen/logrus from 1.8.0 to 1.8.1\n  * build(deps): bump github.com/hashicorp/go-multierror from 1.1.0 to 1.1.1\n  * Lookup Containerfile if user specifies a directory\n  * Add Tag format placeholder to docs\n  * copier: ignore sockets\n  * image: propagate errors from extractRootfs\n  * Remove system test of 'buildah containers -a'\n  * Clarify userns options are usable only as root in man pages\n  * Fix system test of 'containers -a'\n  * Remove duplicated code in addcopy\n  * build(deps): bump github.com/onsi/ginkgo from 1.15.0 to 1.15.1\n  * build(deps): bump github.com/onsi/gomega from 1.10.5 to 1.11.0\n  * build(deps): bump github.com/fsouza/go-dockerclient from 1.7.1 to 1.7.2\n  * Update multi-arch buildah build setup with new logic\n  * Update nix pin with `make nixpkgs`\n  * overlay.bats: fix the \"overlay source permissions\" test\n  * imagebuildah: use overlay for volumes when using overlay\n  * Make PolicyMap and PullPolicy names align\n  * copier: add GetOptions.IgnoreUnreadable\n  * Check local image to match system context\n  * fix: Containerfiles - smaller set of userns u/gids\n  * Set upperdir permissions based on source\n  * Shrink the vendoring size of pkc/cli\n  * Clarify image name match failure message\n  * ADD/COPY: create the destination directory first, chroot to it\n  * copier.GetOptions: add NoDerefSymLinks\n  * copier: add an Eval function\n  * Update system test for 'from --cap-add/drop'\n  * copier: fix a renaming bug\n  * copier: return child process stderr if we can't JSON decode the response\n  * Add some system tests\n  * build(deps): bump github.com/containers/storage from 1.26.0 to 1.27.0\n  * complement add/copy --chmod documentation\n  * buildah login and logout, do not need to enter user namespace\n  * Add multi-arch image build\n  * chmod/chown added/fixed in bash completions\n  * OWNERS: add @lsm5\n  * buildah add/copy --chmod dockerfile implementation\n  * bump github.com/openshift/imagebuilder from 1.1.8 to 1.2.0\n  * buildah add/copy --chmod cli implementation for files and urls\n  * Make sure we set the buildah version label\n  * Isolation strings, should match user input\n  * [CI:DOCS] buildah-from.md: remove dup arch,os\n  * build(deps): bump github.com/containers/image/v5 from 5.10.2 to 5.10.3\n  * Cirrus: Temp. disable prior-fedora (F32) testing\n  * pr-should-include-tests: recognized \"renamed\" tests\n  * build(deps): bump github.com/sirupsen/logrus from 1.7.0 to 1.8.0\n  * build(deps): bump github.com/fsouza/go-dockerclient from 1.7.0 to 1.7.1\n  * build(deps): bump github.com/containers/common from 0.34.2 to 0.35.0\n  * Fix reaping of stages with no instructions\n  * add stale bot\n  * Add base image name to comment\n  * build(deps): bump github.com/spf13/cobra from 1.1.1 to 1.1.3\n  * Don't fail copy to emptydir\n  * buildah: use volatile containers\n  * vendor: update containers/storage\n  * Eliminate the use of containers/building import in pkg subdirs\n  * Add more support for removing config\n  * Improve messages about --cache-from not being supported\n  * Revert patch to allow COPY/ADD of empty dirs.\n  * Don't fail copy to emptydir\n  * Fix tutorial for rootless mode\n  * Fix caching layers with build args\n  * Vendor in containers/image v5.10.2\n  * build(deps): bump github.com/containers/common from 0.34.0 to 0.34.2\n  * build(deps): bump github.com/onsi/ginkgo from 1.14.2 to 1.15.0\n  * 'make validate': require PRs to include tests\n  * build(deps): bump github.com/onsi/gomega from 1.10.4 to 1.10.5\n  * build(deps): bump github.com/containers/storage from 1.24.5 to 1.25.0\n  * Use chown function for U volume flag from containers/common repository\n  * --iidfile: print hash prefix\n  * bump containernetworking/cni to v0.8.1 - fix for CVE-2021-20206\n  * run: fix check for host pid namespace\n  * Finish plumbing for buildah bud --manifest\n  * buildah manifest add localimage should work\n  * Stop testing directory permissions with latest docker\n  * Fix build arg check\n  * build(deps): bump github.com/containers/ocicrypt from 1.0.3 to 1.1.0\n  * [ci:docs] Fix man page for buildah push\n  * Update nix pin with `make nixpkgs`\n  * Bump to containers/image v5.10.1\n  * Rebuild layer if a change in ARG is detected\n  * Bump golang.org/x/crypto to the latest\n  * Add Ashley and Urvashi to Approvers\n  * local image lookup by digest\n  * Use build-arg ENV val from local environment if set\n  * Pick default OCI Runtime from containers.conf\n  * Added required devel packages\n  * Cirrus: Native OSX Build\n  * Cirrus: Two minor cleanup items\n  * Workaround for RHEL gating test failure\n  * build(deps): bump github.com/stretchr/testify from 1.6.1 to 1.7.0\n  * build(deps): bump github.com/mattn/go-shellwords from 1.0.10 to 1.0.11\n  * Reset upstream branch to dev version\n  * If destination does not exists, do not throw error\n\n- Changelog for v1.19.0 (2021-01-08)\n  * Update vendor of containers/storage and containers/common\n  * Buildah inspect should be able to inspect manifests\n  * Make buildah push support pushing manifests lists and digests\n  * Fix handling of TMPDIR environment variable\n  * Add support for --manifest flags\n  * Upper directory should match mode of destination directory\n  * Only grab the OS, Arch if the user actually specified them\n  * Use --arch and --os and --variant options to select architecture and os\n  * Cirrus: Track libseccomp and golang version\n  * copier.PutOptions: add an \"IgnoreDevices\" flag\n  * fix: `rmi --prune` when parent image is in store.\n  * build(deps): bump github.com/containers/storage from 1.24.3 to 1.24.4\n  * build(deps): bump github.com/containers/common from 0.31.1 to 0.31.2\n  * Allow users to specify stdin into containers\n  * Drop log message on failure to mount on /sys file systems to info\n  * Spelling\n  * SELinux no longer requires a tag.\n  * build(deps): bump github.com/opencontainers/selinux from 1.6.0 to 1.8.0\n  * build(deps): bump github.com/containers/common from 0.31.0 to 0.31.1\n  * Update nix pin with `make nixpkgs`\n  * Switch references of /var/run -> /run\n  * Allow FROM to be overriden with from option\n  * copier: don't assume we can chroot() on Unixy systems\n  * copier: add PutOptions.NoOverwriteDirNonDir, Get/PutOptions.Rename\n  * copier: handle replacing directories with not-directories\n  * copier: Put: skip entries with zero-length names\n  * build(deps): bump github.com/containers/storage from 1.24.2 to 1.24.3\n  * Add U volume flag to chown source volumes\n  * Turn off PRIOR_UBUNTU Test until vm is updated\n  * pkg, cli: rootless uses correct isolation\n  * build(deps): bump github.com/onsi/gomega from 1.10.3 to 1.10.4\n  * update installation doc to reflect current status\n  * Move away from using docker.io\n  * enable short-name aliasing\n  * build(deps): bump github.com/containers/storage from 1.24.1 to 1.24.2\n  * build(deps): bump github.com/containers/common from 0.30.0 to 0.31.0\n  * Throw errors when using bogus --network flags\n  * pkg/supplemented test: replace our null blobinfocache\n  * build(deps): bump github.com/containers/common from 0.29.0 to 0.30.0\n  * inserts forgotten quotation mark\n  * Not prefer use local image create/add manifest\n  * Add container information to .containerenv\n  * Add --ignorefile flag to use alternate .dockerignore flags\n  * Add a source debug build\n  * Fix crash on invalid filter commands\n  * build(deps): bump github.com/containers/common from 0.27.0 to 0.29.0\n  * Switch to using containers/common pkg's\n  * fix: non-portable shebang #2812\n  * Remove copy/paste errors that leaked `Podman` into man pages.\n  * Add suggests cpp to spec file\n  * Apply suggestions from code review\n  * update docs for debian testing and unstable\n  * imagebuildah: disable pseudo-terminals for RUN\n  * Compute diffID for mapped-layer at creating image source\n  * intermediateImageExists: ignore images whose history we can't read\n  * Bump to v1.19.0-dev\n  * build(deps): bump github.com/containers/common from 0.26.3 to 0.27.0\n\n- Changelog for v1.18.0 (2020-11-16)\n  * Fix testing error caused by simultanious merge\n  * Vendor in containers/storage v1.24.0\n  * short-names aliasing\n  * Add --policy flag to buildah pull\n  * Stop overwrapping and stuttering\n  * copier.Get(): ignore ENOTSUP/ENOSYS when listing xattrs\n  * Run: don't forcibly disable UTS namespaces in rootless mode\n  * test: ensure non-directory in a Dockerfile path is handled correctly\n  * Add a few tests for `pull` command\n  * Fix buildah config --cmd to handle array\n  * build(deps): bump github.com/containers/storage from 1.23.8 to 1.23.9\n  * Fix NPE when Dockerfile path contains non-directory entries\n  * Update buildah bud man page from podman build man page\n  * Move declaration of decryption-keys to common cli\n  * Run: correctly call copier.Mkdir\n  * util: digging UID/GID out of os.FileInfo should work on Unix\n  * imagebuildah.getImageTypeAndHistoryAndDiffIDs: cache results\n  * Verify userns-uid-map and userns-gid-map input\n  * Use CPP, CC and flags in dep check scripts\n  * Avoid overriding LDFLAGS in Makefile\n  * ADD: handle --chown on URLs\n  * Update nix pin with `make nixpkgs`\n  * (*Builder).Run: MkdirAll: handle EEXIST error\n  * copier: try to force loading of nsswitch modules before chroot()\n  * fix MkdirAll usage\n  * build(deps): bump github.com/containers/common from 0.26.2 to 0.26.3\n  * build(deps): bump github.com/containers/storage from 1.23.7 to 1.23.8\n  * Use osusergo build tag for static build\n  * imagebuildah: cache should take image format into account\n  * Bump to v1.18.0-dev\n\n- Changelog for v1.17.0 (2020-10-29)\n  * Handle cases where other tools mount/unmount containers\n  * overlay.MountReadOnly: support RO overlay mounts\n  * overlay: use fusermount for rootless umounts\n  * overlay: fix umount\n  * Switch default log level of Buildah to Warn. Users need to see these messages\n  * Drop error messages about OCI/Docker format to Warning level\n  * build(deps): bump github.com/containers/common from 0.26.0 to 0.26.2\n  * tests/testreport: adjust for API break in storage v1.23.6\n  * build(deps): bump github.com/containers/storage from 1.23.5 to 1.23.7\n  * build(deps): bump github.com/fsouza/go-dockerclient from 1.6.5 to 1.6.6\n  * copier: put: ignore Typeflag=\"g\"\n  * Use curl to get repo file (fix #2714)\n  * build(deps): bump github.com/containers/common from 0.25.0 to 0.26.0\n  * build(deps): bump github.com/spf13/cobra from 1.0.0 to 1.1.1\n  * Remove docs that refer to bors, since we're not using it\n  * Buildah bud should not use stdin by default\n  * bump containerd, docker, and golang.org/x/sys\n  * Makefile: cross: remove windows.386 target\n  * copier.copierHandlerPut: don't check length when there are errors\n  * Stop excessive wrapping\n  * CI: require that conformance tests pass\n  * bump(github.com/openshift/imagebuilder) to v1.1.8\n  * Skip tlsVerify insecure BUILD_REGISTRY_SOURCES\n  * Fix build path wrong https://github.com/containers/podman/issues/7993\n  * refactor pullpolicy to avoid deps\n  * build(deps): bump github.com/containers/common from 0.24.0 to 0.25.0\n  * CI: run gating tasks with a lot more memory\n  * ADD and COPY: descend into excluded directories, sometimes\n  * copier: add more context to a couple of error messages\n  * copier: check an error earlier\n  * copier: log stderr output as debug on success\n  * Update nix pin with `make nixpkgs`\n  * Set directory ownership when copied with ID mapping\n  * build(deps): bump github.com/sirupsen/logrus from 1.6.0 to 1.7.0\n  * build(deps): bump github.com/containers/common from 0.23.0 to 0.24.0\n  * Cirrus: Remove bors artifacts\n  * Sort build flag definitions alphabetically\n  * ADD: only expand archives at the right time\n  * Remove configuration for bors\n  * Shell Completion for podman build flags\n  * Bump c/common to v0.24.0\n  * New CI check: xref --help vs man pages\n  * CI: re-enable several linters\n  * Move --userns-uid-map/--userns-gid-map  description into buildah man page\n  * add: preserve ownerships and permissions on ADDed archives\n  * Makefile: tweak the cross-compile target\n  * Bump containers/common to v0.23.0\n  * chroot: create bind mount targets 0755 instead of 0700\n  * Change call to Split() to safer SplitN()\n  * chroot: fix handling of errno seccomp rules\n  * build(deps): bump github.com/containers/image/v5 from 5.5.2 to 5.6.0\n  * Add In Progress section to contributing\n  * integration tests: make sure tests run in ${topdir}/tests\n  * Run(): ignore containers.conf's environment configuration\n  * Warn when setting healthcheck in OCI format\n  * Cirrus: Skip git-validate on branches\n  * tools: update git-validation to the latest commit\n  * tools: update golangci-lint to v1.18.0\n  * Add a few tests of push command\n  * Add(): fix handling of relative paths with no ContextDir\n  * build(deps): bump github.com/containers/common from 0.21.0 to 0.22.0\n  * Lint: Use same linters as podman\n  * Validate: reference HEAD\n  * Fix buildah mount to display container names not ids\n  * Update nix pin with `make nixpkgs`\n  * Add missing --format option in buildah from man page\n  * Fix up code based on codespell\n  * build(deps): bump github.com/openshift/imagebuilder from 1.1.6 to 1.1.7\n  * build(deps): bump github.com/containers/storage from 1.23.4 to 1.23.5\n  * Improve buildah completions\n  * Cirrus: Fix validate commit epoch\n  * Fix bash completion of manifest flags\n  * Uniform some man pages\n  * Update Buildah Tutorial to address BZ1867426\n  * Update bash completion of `manifest add` sub command\n  * copier.Get(): hard link targets shouldn't be relative paths\n  * build(deps): bump github.com/onsi/gomega from 1.10.1 to 1.10.2\n  * Pass timestamp down to history lines\n  * Timestamp gets updated everytime you inspect an image\n  * bud.bats: use absolute paths in newly-added tests\n  * contrib/cirrus/lib.sh: don't use CN for the hostname\n  * tests: Add some tests\n  * Update `manifest add` man page\n  * Extend flags of `manifest add`\n  * build(deps): bump github.com/containers/storage from 1.23.3 to 1.23.4\n  * build(deps): bump github.com/onsi/ginkgo from 1.14.0 to 1.14.1\n  * Bump to v1.17.0-dev\n  * CI: expand cross-compile checks\n\n- Changelog for v1.16.0 (2020-09-03)\n  * fix build on 32bit arches\n  * containerImageRef.NewImageSource(): don't always force timestamps\n  * Add fuse module warning to image readme\n  * Heed our retry delay option values when retrying commit/pull/push\n  * Switch to containers/common for seccomp\n  * Use --timestamp rather then --omit-timestamp\n  * docs: remove outdated notice\n  * docs: remove outdated notice\n  * build-using-dockerfile: add a hidden --log-rusage flag\n  * build(deps): bump github.com/containers/image/v5 from 5.5.1 to 5.5.2\n  * Discard ReportWriter if user sets options.Quiet\n  * build(deps): bump github.com/containers/common from 0.19.0 to 0.20.3\n  * Fix ownership of content copied using COPY --from\n  * newTarDigester: zero out timestamps in tar headers\n  * Update nix pin with `make nixpkgs`\n  * bud.bats: correct .dockerignore integration tests\n  * Use pipes for copying\n  * run: include stdout in error message\n  * run: use the correct error for errors.Wrapf\n  * copier: un-export internal types\n  * copier: add Mkdir()\n  * in_podman: don't get tripped up by $CIRRUS_CHANGE_TITLE\n  * docs/buildah-commit.md: tweak some wording, add a --rm example\n  * imagebuildah: don’t blank out destination names when COPYing\n  * Replace retry functions with common/pkg/retry\n  * StageExecutor.historyMatches: compare timestamps using .Equal\n  * Update vendor of containers/common\n  * Fix errors found in coverity scan\n  * Change namespace handling flags to better match podman commands\n  * conformance testing: ignore buildah.BuilderIdentityAnnotation labels\n  * Vendor in containers/storage v1.23.0\n  * Add buildah.IsContainer interface\n  * Avoid feeding run_buildah to pipe\n  * fix(buildahimage): add xz dependency in buildah image\n  * Bump github.com/containers/common from 0.15.2 to 0.18.0\n  * Howto for rootless image building from OpenShift\n  * Add --omit-timestamp flag to buildah bud\n  * Update nix pin with `make nixpkgs`\n  * Shutdown storage on failures\n  * Handle COPY --from when an argument is used\n  * Bump github.com/seccomp/containers-golang from 0.5.0 to 0.6.0\n  * Cirrus: Use newly built VM images\n  * Bump github.com/opencontainers/runc from 1.0.0-rc91 to 1.0.0-rc92\n  * Enhance the .dockerignore man pages\n  * conformance: add a test for COPY from subdirectory\n  * fix  bug manifest inspct\n  * Add documentation for .dockerignore\n  * Add BuilderIdentityAnnotation to identify buildah version\n  * DOC: Add quay.io/containers/buildah image to README.md\n  * Update buildahimages readme\n  * fix spelling mistake in \"info\" command result display\n  * Don't bind /etc/host and /etc/resolv.conf if network is not present\n  * blobcache: avoid an unnecessary NewImage()\n  * Build static binary with `buildGoModule`\n  * copier: split StripSetidBits into StripSetuidBit/StripSetgidBit/StripStickyBit\n  * tarFilterer: handle multiple archives\n  * Fix a race we hit during conformance tests\n  * Rework conformance testing\n  * Update 02-registries-repositories.md\n  * test-unit: invoke cmd/buildah tests with --flags\n  * parse: fix a type mismatch in a test\n  * Fix compilation of tests/testreport/testreport\n  * build.sh: log the version of Go that we're using\n  * test-unit: increase the test timeout to 40/45 minutes\n  * Add the \"copier\" package\n  * Fix & add notes regarding problematic language in codebase\n  * Add dependency on github.com/stretchr/testify/require\n  * CompositeDigester: add the ability to filter tar streams\n  * BATS tests: make more robust\n  * vendor golang.org/x/text@v0.3.3\n  * Switch golang 1.12 to golang 1.13\n  * imagebuildah: wait for stages that might not have even started yet\n  * chroot, run: not fail on bind mounts from /sys\n  * chroot: do not use setgroups if it is blocked\n  * Set engine env from containers.conf\n  * imagebuildah: return the right stage's image as the \"final\" image\n  * Fix a help string\n  * Deduplicate environment variables\n  * switch containers/libpod to containers/podman\n  * Bump github.com/containers/ocicrypt from 1.0.2 to 1.0.3\n  * Bump github.com/opencontainers/selinux from 1.5.2 to 1.6.0\n  * Mask out /sys/dev to prevent information leak\n  * linux: skip errors from the runtime kill\n  * Mask over the /sys/fs/selinux in mask branch\n  * Add VFS additional image store to container\n  * tests: add auth tests\n  * Allow \"readonly\" as alias to \"ro\" in mount options\n  * Ignore OS X specific consistency mount option\n  * Bump github.com/onsi/ginkgo from 1.13.0 to 1.14.0\n  * Bump github.com/containers/common from 0.14.0 to 0.15.2\n  * Rootless Buildah should default to IsolationOCIRootless\n  * imagebuildah: fix inheriting multi-stage builds\n  * Make imagebuildah.BuildOptions.Architecture/OS optional\n  * Make imagebuildah.BuildOptions.Jobs optional\n  * Resolve a possible race in imagebuildah.Executor.startStage()\n  * Switch scripts to use containers.conf\n  * Bump openshift/imagebuilder to v1.1.6\n  * Bump go.etcd.io/bbolt from 1.3.4 to 1.3.5\n  * buildah, bud: support --jobs=N for parallel execution\n  * executor: refactor build code inside new function\n  * Add bud regression tests\n  * Cirrus: Fix missing htpasswd in registry img\n  * docs: clarify the 'triples' format\n  * CHANGELOG.md: Fix markdown formatting\n  * Add nix derivation for static builds\n  * Bump to v1.16.0-dev\n  * add version centos7 for compatible\n\n- Changelog for v1.15.0 (2020-06-17)\n  * Bump github.com/containers/common from 0.12.0 to 0.13.1\n  * Bump github.com/containers/storage from 1.20.1 to 1.20.2\n  * Bump github.com/seccomp/containers-golang from 0.4.1 to 0.5.0\n  * Bump github.com/stretchr/testify from 1.6.0 to 1.6.1\n  * Bump github.com/opencontainers/runc from 1.0.0-rc9 to 1.0.0-rc90\n  * Add CVE-2020-10696 to CHANGELOG.md and changelog.txt\n  * Bump github.com/stretchr/testify from 1.5.1 to 1.6.0\n  * Bump github.com/onsi/ginkgo from 1.12.2 to 1.12.3\n  * Vendor in containers/common v0.12.0\n  * fix lighttpd example\n  * Vendor in new go.etcd.io/bbolt\n  * Bump github.com/onsi/ginkgo from 1.12.1 to 1.12.2\n  * Bump imagebuilder for ARG fix\n  * Bump github.com/containers/common from 0.11.2 to 0.11.4\n  * remove dependency on openshift struct\n  * Warn on unset build arguments\n  * vendor: update seccomp/containers-golang to v0.4.1\n  * Ammended docs\n  * Updated docs\n  * clean up comments\n  * update exit code for tests\n  * Implement commit for encryption\n  * implementation of encrypt/decrypt push/pull/bud/from\n  * fix resolve docker image name as transport\n  * Bump github.com/opencontainers/go-digest from 1.0.0-rc1 to 1.0.0\n  * Bump github.com/onsi/ginkgo from 1.12.0 to 1.12.1\n  * Bump github.com/containers/storage from 1.19.1 to 1.19.2\n  * Bump github.com/containers/image/v5 from 5.4.3 to 5.4.4\n  * Add preliminary profiling support to the CLI\n  * Bump github.com/containers/common from 0.10.0 to 0.11.2\n  * Evaluate symlinks in build context directory\n  * fix error info about get signatures for containerImageSource\n  * Add Security Policy\n  * Cirrus: Fixes from review feedback\n  * Bump github.com/containers/storage from 1.19.0 to 1.19.1\n  * Bump github.com/sirupsen/logrus from 1.5.0 to 1.6.0\n  * imagebuildah: stages shouldn't count as their base images\n  * Update containers/common v0.10.0\n  * Bump github.com/fsouza/go-dockerclient from 1.6.4 to 1.6.5\n  * Add registry to buildahimage Dockerfiles\n  * Cirrus: Use pre-installed VM packages + F32\n  * Cirrus: Re-enable all distro versions\n  * Cirrus: Update to F31 + Use cache images\n  * golangci-lint: Disable gosimple\n  * Lower number of golangci-lint threads\n  * Fix permissions on containers.conf\n  * Don't force tests to use runc\n  * Bump github.com/containers/common from 0.9.1 to 0.9.5\n  * Return exit code from failed containers\n  * Bump github.com/containers/storage from 1.18.2 to 1.19.0\n  * Bump github.com/containers/common from 0.9.0 to 0.9.1\n  * cgroup_manager should be under [engine]\n  * Use c/common/pkg/auth in login/logout\n  * Cirrus: Temporarily disable Ubuntu 19 testing\n  * Add containers.conf to stablebyhand build\n  * Update gitignore to exclude test Dockerfiles\n  * Bump github.com/fsouza/go-dockerclient from 1.6.3 to 1.6.4\n  * Bump github.com/containers/common from 0.8.1 to 0.9.0\n  * Bump back to v1.15.0-dev\n  * Remove warning for systemd inside of container\n\n- Changelog for v1.14.8 (2020-04-09)\n  * Run (make vendor)\n  * Run (make -C tests/tools vendor)\n  * Run (go mod tidy) before (go mod vendor) again\n  * Fix (make vendor)\n  * Bump validation\n  * Bump back to v1.15.0-dev\n\n- Changelog for v1.14.7 (2020-04-07)\n  * Bump github.com/containers/image/v5 from 5.3.1 to 5.4.3\n  * make vendor: run `tidy` after `vendor`\n  * Do not skip the directory when the ignore pattern matches\n  * Bump github.com/containers/common from 0.7.0 to 0.8.1\n  * Downgrade siruspen/logrus from 1.4.2\n  * Fix errorf conventions\n  * dockerignore tests : remove symlinks, rework\n  * Bump back to v1.15.0-dev\n\n- Changelog for v1.14.6 (2020-04-02)\n  * bud.bats - cleanup, refactoring\n  * vendor in latest containers/storage 1.18.0 and containers/common v0.7.0\n  * Bump github.com/spf13/cobra from 0.0.6 to 0.0.7\n  * Bump github.com/containers/storage from 1.16.5 to 1.17.0\n  * Bump github.com/containers/image/v5 from 5.2.1 to 5.3.1\n  * Fix Amazon install step\n  * Bump back to v1.15.0-dev\n  * Fix bud-build-arg-cache test\n  * Make image history work correctly with new args handling\n  * Don't add args to the RUN environment from the Builder\n  * Update github.com/openshift/imagebuilder to v1.1.4\n  * Add .swp files to .gitignore\n\n- Changelog for v1.14.5 (2020-03-26)\n  * revert #2246 FIPS mode change\n  * Bump back to v1.15.0-dev\n  * image with dup layers: we now have one on quay\n  * digest test : make more robust\n\n- Changelog for v1.14.4 (2020-03-25)\n  * Fix fips-mode check for RHEL8 boxes\n  * Fix potential CVE in tarfile w/ symlink (Edit 02-Jun-2020: Addresses CVE-2020-10696)\n  * Fix .dockerignore with globs and ! commands\n  * update install steps for Amazon Linux 2\n  * Bump github.com/openshift/imagebuilder from 1.1.2 to 1.1.3\n  * Add comment for RUN command in volume ownership test\n  * Run stat command directly for volume ownership test\n  * vendor in containers/common v0.6.1\n  * Cleanup go.sum\n  * Bump back to v1.15.0-dev\n\n- Changelog for v1.14.3 (2020-03-17)\n  * Update containers/storage to v1.16.5\n  * Bump github.com/containers/storage from 1.16.2 to 1.16.4\n  * Bump github.com/openshift/imagebuilder from 1.1.1 to 1.1.2\n  * Update github.com/openshift/imagebuilder vendoring\n  * Update unshare man page to fix script example\n  * Fix compilation errors on non linux platforms\n  * Bump containers/common and opencontainers/selinux versions\n  * Add tests for volume ownership\n  * Preserve volume uid and gid through subsequent commands\n  * Fix FORWARD_NULL errors found by Coverity\n  * Bump github.com/containers/storage from 1.16.1 to 1.16.2\n  * Fix errors found by codespell\n  * Bump back to v1.15.0-dev\n  * Add Pull Request Template\n\n- Changelog for v1.14.2 (2020-03-03)\n  * Add Buildah pull request template\n  * Bump to containers/storage v1.16.1\n  * run_linux: fix tight loop if file is not pollable\n  * Bump github.com/opencontainers/selinux from 1.3.2 to 1.3.3\n  * Bump github.com/containers/common from 0.4.1 to 0.4.2\n  * Bump back to v1.15.0-dev\n  * Add Containerfile to build a versioned stable image on quay.io\n\n- Changelog for v1.14.1 (2020-02-27)\n  * Search for local runtime per values in containers.conf\n  * Set correct ownership on working directory\n  * BATS : in teardown, umount stale mounts\n  * Bump github.com/spf13/cobra from 0.0.5 to 0.0.6\n  * Bump github.com/fsouza/go-dockerclient from 1.6.1 to 1.6.3\n  * Bump github.com/stretchr/testify from 1.4.0 to 1.5.1\n  * Replace unix with syscall to allow vendoring into libpod\n  * Update to containers/common v0.4.1\n  * Improve remote manifest retrieval\n  * Fix minor spelling errors in containertools README\n  * Clear the right variable in buildahimage\n  * Correct a couple of incorrect format specifiers\n  * Update to containers/common v0.3.0\n  * manifest push --format: force an image type, not a list type\n  * run: adjust the order in which elements are added to $PATH\n  * getDateAndDigestAndSize(): handle creation time not being set\n  * Bump github.com/containers/common from 0.2.0 to 0.2.1\n  * include installation steps for CentOS 8 and Stream\n  * include installation steps for CentOS7 and forks\n  * Adjust Ubuntu install info to also work on Pop!_OS\n  * Make the commit id clear like Docker\n  * Show error on copied file above context directory in build\n  * Bump github.com/containers/image/v5 from 5.2.0 to 5.2.1\n  * pull/from/commit/push: retry on most failures\n  * Makefile: fix install.cni.sudo\n  * Repair buildah so it can use containers.conf on the server side\n  * Bump github.com/mattn/go-shellwords from 1.0.9 to 1.0.10\n  * Bump github.com/fsouza/go-dockerclient from 1.6.0 to 1.6.1\n  * Fixing formatting & build instructions\n  * Add Code of Conduct\n  * Bors: Fix no. req. github reviews\n  * Cirrus+Bors: Simplify temp branch skipping\n  * Bors-ng: Add documentation and status-icon\n  * Bump github.com/onsi/ginkgo from 1.11.0 to 1.12.0\n  * fix XDG_RUNTIME_DIR for authfile\n  * Cirrus: Disable F29 testing\n  * Cirrus: Add jq package\n  * Cirrus: Fix lint + validation using wrong epoch\n  * Stop using fedorproject registry\n  * Bors: Workaround ineffective required statuses\n  * Bors: Enable app + Disable Travis\n  * Cirrus: Add standardized log-collection\n  * Cirrus: Improve automated lint + validation\n  * Allow passing options to golangci-lint\n  * Cirrus: Fixes from review feedback\n  * Cirrus: Temporarily ignore VM testing failures\n  * Cirrus: Migrate off papr + implement VM testing\n  * Cirrus: Update packages + fixes for get_ci_vm.sh\n  * Show validation command-line\n  * Skip overlay test w/ vfs driver\n  * use alpine, not centos, for various tests\n  * Flake handling: cache and prefetch images\n  * Bump to v1.15.0-dev\n\n- Changelog for v1.14.0 (2020-02-05)\n  * bump github.com/mtrmac/gpgme\n  * Update containers/common to v0.1.4\n  * manifest push: add --format option\n  * Bump github.com/onsi/gomega from 1.8.1 to 1.9.0\n  * vendor github.com/containers/image/v5@v5.2.0\n  * info test: deal with random key order\n  * Bump back to v1.14.0-dev\n\n- Changelog for v1.13.2 (2020-01-29)\n  * sign.bats: set GPG_TTY=/dev/null\n  * Fix parse_unsupported.go\n  * getDateAndDigestAndSize(): use manifest.Digest\n  * Bump github.com/opencontainers/selinux from 1.3.0 to 1.3.1\n  * Bump github.com/containers/common from 0.1.0 to 0.1.2\n  * Touch up os/arch doc\n  * chroot: handle slightly broken seccomp defaults\n  * buildahimage: specify fuse-overlayfs mount options\n  * Bump github.com/mattn/go-shellwords from 1.0.7 to 1.0.9\n  * copy.bats: make sure we detect failures due to missing source\n  * parse: don't complain about not being able to rename something to itself\n  * Makefile: use a $(GO_TEST) macro, fix a typo\n  * manifests: unit test fix\n  * Fix build for 32bit platforms\n  * Allow users to set OS and architecture on bud\n  * Fix COPY in containerfile with envvar\n  * Bump c/storage to v1.15.7\n  * add --sign-by to bud/commit/push, --remove-signatures for pull/push\n  * Remove cut/paste error in CHANGELOG.md\n  * Update vendor of containers/common to v0.1.0\n  * update install instructions for Debian, Raspbian and Ubuntu\n  * Add support for containers.conf\n  * Bump back to v1.14.0-dev\n\n- Changelog for v1.13.1 (2020-01-14)\n  * Bump github.com/containers/common from 0.0.5 to 0.0.7\n  * Bump github.com/onsi/ginkgo from 1.10.3 to 1.11.0\n  * Bump github.com/pkg/errors from 0.8.1 to 0.9.0\n  * Bump github.com/onsi/gomega from 1.7.1 to 1.8.1\n  * Add codespell support\n  * copyFileWithTar: close source files at the right time\n  * copy: don't digest files that we ignore\n  * Check for .dockerignore specifically\n  * Travis: rm go 1.12.x\n  * Don't setup excludes, if their is only one pattern to match\n  * set HOME env to /root on chroot-isolation by default\n  * docs: fix references to containers-*.5\n  * update openshift/api\n  * fix bug Add check .dockerignore COPY file\n  * buildah bud --volume: run from tmpdir, not source dir\n  * Fix imageNamePrefix to give consistent names in buildah-from\n  * cpp: use -traditional and -undef flags\n  * Fix image reference in tutorial 4\n  * discard outputs coming from onbuild command on buildah-from --quiet\n  * make --format columnizing consistent with buildah images\n  * Bump to v1.14.0-dev\n\n- Changelog for v1.13.0 (2019-12-27)\n  * Bump to c/storage v1.15.5\n  * Update container/storage to v1.15.4\n  * Fix option handling for volumes in build\n  * Rework overlay pkg for use with libpod\n  * Fix buildahimage builds for buildah\n  * Add support for FIPS-Mode backends\n  * Set the TMPDIR for pulling/pushing image to $TMPDIR\n  * WIP: safer test for pull --all-tags\n  * BATS major cleanup: blobcache.bats: refactor\n  * BATS major cleanup: part 4: manual stuff\n  * BATS major cleanup, step 3: yet more run_buildah\n  * BATS major cleanup, part 2: use more run_buildah\n  * BATS major cleanup, part 1: log-level\n  * Bump github.com/containers/image/v5 from 5.0.0 to 5.1.0\n  * Bump github.com/containers/common from 0.0.3 to 0.0.5\n  * Bump to v1.13.0-dev\n\n- Changelog for v1.12.0 (2019-12-13)\n  * Allow ADD to use http src\n  * Bump to c/storage v.1.15.3\n  * install.md: update golang dependency\n  * imgtype: reset storage opts if driver overridden\n  * Start using containers/common\n  * overlay.bats typo: fuse-overlays should be fuse-overlayfs\n  * chroot: Unmount with MNT_DETACH instead of UnmountMountpoints()\n  * bind: don't complain about missing mountpoints\n  * imgtype: check earlier for expected manifest type\n  * Vendor containers/storage fix\n  * Vendor containers/storage v1.15.1\n  * Add history names support\n  * PR takeover of #1966\n  * Tests: Add inspect test check steps\n  * Tests: Add container name and id check in containers test steps\n  * Test: Get permission in add test\n  * Tests: Add a test for tag by id\n  * Tests: Add test cases for push test\n  * Tests: Add image digest test\n  * Tests: Add some buildah from tests\n  * Tests: Add two commit test\n  * Tests: Add buildah bud with --quiet test\n  * Tests: Add two test for buildah add\n  * Bump back to v1.12.0-dev\n\n- Changelog for v1.11.6 (2019-12-03)\n  * Handle missing equal sign in --from and --chown flags for COPY/ADD\n  * bud COPY does not download URL\n  * Bump github.com/onsi/gomega from 1.7.0 to 1.7.1\n  * Fix .dockerignore exclude regression\n  * Ran buildah through codespell\n  * commit(docker): always set ContainerID and ContainerConfig\n  * Touch up commit man page image parameter\n  * Add builder identity annotations.\n  * info: use util.Runtime()\n  * Bump github.com/onsi/ginkgo from 1.10.2 to 1.10.3\n  * Bump back to v1.12.0-dev\n\n- Changelog for v1.11.5 (2019-11-11)\n  * Enhance error on unsafe symbolic link targets\n  * Add OCIRuntime to info\n  * Check nonexsit authfile\n  * Only output image id if running buildah bud --quiet\n  * Fix --pull=true||false and add --pull-never to bud and from (retry)\n  * cgroups v2: tweak or skip tests\n  * Prepwork: new 'skip' helpers for tests\n  * Handle configuration blobs for manifest lists\n  * unmarshalConvertedConfig: avoid using the updated image's ref\n  * Add completions for Manifest commands\n  * Add disableFips option to secrets pkg\n  * Update bud.bats test archive test\n  * Add test for caching based on content digest\n  * Builder.untarPath(): always evaluate b.ContentDigester.Hash()\n  * Bump github.com/onsi/ginkgo from 1.10.1 to 1.10.2\n  * Fix another broken test: copy-url-mtime\n  * yet more fixes\n  * Actual bug fix for 'add' test: fix the expected mode\n  * BATS tests - lots of mostly minor cleanup\n  * build: drop support for ostree\n  * Add support for make vendor-in-container\n  * imgtype: exit with error if storage fails\n  * remove XDG_RUNTIME_DIR from default authfile path\n  * fix troubleshooting redirect instructions\n  * Bump back to v1.12.0-dev\n\n- Changelog for v1.11.4 (2019-10-28)\n  * buildah: add a \"manifest\" command\n  * manifests: add the module\n  * pkg/supplemented: add a package for grouping images together\n  * pkg/manifests: add a manifest list build/manipulation API\n  * Update for ErrUnauthorizedForCredentials API change in containers/image\n  * Update for manifest-lists API changes in containers/image\n  * version: also note the version of containers/image\n  * Move to containers/image v5.0.0\n  * Enable --device directory as src device\n  * Fix git build with branch specified\n  * Bump github.com/openshift/imagebuilder from 1.1.0 to 1.1.1\n  * Bump github.com/fsouza/go-dockerclient from 1.4.4 to 1.5.0\n  * Add clarification to the Tutorial for new users\n  * Silence \"using cache\" to ensure -q is fully quiet\n  * Add OWNERS File to Buildah\n  * Bump github.com/containers/storage from 1.13.4 to 1.13.5\n  * Move runtime flag to bud from common\n  * Commit: check for storage.ErrImageUnknown using errors.Cause()\n  * Fix crash when invalid COPY --from flag is specified.\n  * Bump back to v1.12.0-dev\n\n- Changelog for v1.11.3 (2019-10-04)\n  * Update c/image to v4.0.1\n  * Bump github.com/spf13/pflag from 1.0.3 to 1.0.5\n  * Fix --build-args handling\n  * Bump github.com/spf13/cobra from 0.0.3 to 0.0.5\n  * Bump github.com/cyphar/filepath-securejoin from 0.2.1 to 0.2.2\n  * Bump github.com/onsi/ginkgo from 1.8.0 to 1.10.1\n  * Bump github.com/fsouza/go-dockerclient from 1.3.0 to 1.4.4\n  * Add support for retrieving context from stdin \"-\"\n  * Ensure bud remote context cleans up on error\n  * info: add cgroups2\n  * Bump github.com/seccomp/libseccomp-golang from 0.9.0 to 0.9.1\n  * Bump github.com/mattn/go-shellwords from 1.0.5 to 1.0.6\n  * Bump github.com/stretchr/testify from 1.3.0 to 1.4.0\n  * Bump github.com/opencontainers/selinux from 1.2.2 to 1.3.0\n  * Bump github.com/etcd-io/bbolt from 1.3.2 to 1.3.3\n  * Bump github.com/onsi/gomega from 1.5.0 to 1.7.0\n  * update c/storage to v1.13.4\n  * Print build 'STEP' line to stdout, not stderr\n  * Fix travis-ci on forks\n  * Vendor c/storage v1.13.3\n  * Use Containerfile by default\n  * Added tutorial on how to include Buildah as library\n  * util/util: Fix \"configuraitno\" -> \"configuration\" log typo\n  * Bump back to v1.12.0-dev\n\n- Changelog for v1.11.2 (2019-09-13)\n  * Add some cleanup code\n  * Move devices code to unit specific directory.\n  * Bump back to v1.12.0-dev\n\n- Changelog for v1.11.1 (2019-09-11)\n  * Add --devices flag to bud and from\n  * Downgrade .papr to highest atomic verion\n  * Add support for /run/.containerenv\n  * Truncate output of too long image names\n  * Preserve file and directory mount permissions\n  * Bump fedora version from 28 to 30\n  * makeImageRef: ignore EmptyLayer if Squash is set\n  * Set TMPDIR to /var/tmp by default\n  * replace --debug=false with --log-level=error\n  * Allow mounts.conf entries for equal source and destination paths\n  * fix label and annotation for 1-line Dockerfiles\n  * Enable interfacer linter and fix lints\n  * install.md: mention goproxy\n  * Makefile: use go proxy\n  * Bump to v1.12.0-dev\n\n- Changelog for v1.11.0 (2019-08-29)\n  * tests/bud.bats: add --signature-policy to some tests\n  * Vendor github.com/openshift/api\n  * pull/commit/push: pay attention to $BUILD_REGISTRY_SOURCES\n  * Add `--log-level` command line option and deprecate `--debug`\n  * add support for cgroupsV2\n  * Correctly detect ExitError values from Run()\n  * Disable empty logrus timestamps to reduce logger noise\n  * Remove outdated deps Makefile target\n  * Remove gofmt.sh in favor of golangci-lint\n  * Remove govet.sh in favor of golangci-lint\n  * Allow to override build date with SOURCE_DATE_EPOCH\n  * Update shebangs to take env into consideration\n  * Fix directory pull image names\n  * Add --digestfile and Re-add push statement as debug\n  * README: mention that Podman uses Buildah's API\n  * Use content digests in ADD/COPY history entries\n  * add: add a DryRun flag to AddAndCopyOptions\n  * Fix possible runtime panic on bud\n  * Add security-related volume options to validator\n  * use correct path for ginkgo\n  * Add bud 'without arguments' integration tests\n  * Update documentation about bud\n  * add: handle hard links when copying with .dockerignore\n  * add: teach copyFileWithTar() about symlinks and directories\n  * Allow buildah bud to be called without arguments\n  * imagebuilder: fix detection of referenced stage roots\n  * Touch up go mod instructions in install\n  * run_linux: fix mounting /sys in a userns\n  * Vendor Storage v1.13.2\n  * Cirrus: Update VM images\n  * Fix handling of /dev/null masked devices\n  * Update `bud`/`from` help to contain indicator for `--dns=none`\n  * Bump back to v1.11.0-dev\n\n- Changelog for v1.10.1 (2019-08-08)\n  * Bump containers/image to v3.0.2 to fix keyring issue\n  * Bug fix for volume minus syntax\n  * Bump container/storage v1.13.1 and containers/image v3.0.1\n  * bump github.com/containernetworking/cni to v0.7.1\n  * Add overlayfs to fuse-overlayfs tip\n  * Add automatic apparmor tag discovery\n  * Fix bug whereby --get-login has no effect\n  * Bump to v1.11.0-dev\n\n- Changelog for v1.10.0 (2019-08-02)\n  * vendor github.com/containers/image@v3.0.0\n  * Remove GO111MODULE in favor of `-mod=vendor`\n  * Vendor in containers/storage v1.12.16\n  * Add '-' minus syntax for removal of config values\n  * tests: enable overlay tests for rootless\n  * rootless, overlay: use fuse-overlayfs\n  * vendor github.com/containers/image@v2.0.1\n  * Added '-' syntax to remove volume config option\n  * delete `successfully pushed` message\n  * Add golint linter and apply fixes\n  * vendor github.com/containers/storage@v1.12.15\n  * Change wait to sleep in buildahimage readme\n  * Handle ReadOnly images when deleting images\n  * Add support for listing read/only images\n\n- Changelog for v1.9.2 (2019-07-19)\n  * from/import: record the base image's digest, if it has one\n  * Fix CNI version retrieval to not require network connection\n  * Add misspell linter and apply fixes\n  * Add goimports linter and apply fixes\n  * Add stylecheck linter and apply fixes\n  * Add unconvert linter and apply fixes\n  * image: make sure we don't try to use zstd compression\n  * run.bats: skip the \"z\" flag when testing --mount\n  * Update to runc v1.0.0-rc8\n  * Update to match updated runtime-tools API\n  * bump github.com/opencontainers/runtime-tools to v0.9.0\n  * Build e2e tests using the proper build tags\n  * Add unparam linter and apply fixes\n  * Run: correct a typo in the --cap-add help text\n  * unshare: add a --mount flag\n  * fix push check image name is not empty\n  * Bump to v1.9.2-dev\n\n- Changelog for v1.9.1 (2019-07-12)\n  * add: fix slow copy with no excludes\n  * Add errcheck linter and fix missing error check\n  * Improve tests/tools/Makefile parallelism and abstraction\n  * Fix response body not closed resource leak\n  * Switch to golangci-lint\n  * Add gomod instructions and mailing list links\n  * On Masked path, check if /dev/null already mounted before mounting\n  * Update to containers/storage v1.12.13\n  * Refactor code in package imagebuildah\n  * Add rootless podman with NFS issue in documentation\n  * Add --mount  for buildah run\n  * import method ValidateVolumeOpts from libpod\n  * Fix typo\n  * Makefile: set GO111MODULE=off\n  * rootless: add the built-in slirp DNS server\n  * Update docker/libnetwork to get rid of outdated sctp package\n  * Update buildah-login.md\n  * migrate to go modules\n  * install.md: mention go modules\n  * tests/tools: go module for test binaries\n  * fix --volume splits comma delimited option\n  * Add bud test for RUN with a priv'd command\n  * vendor logrus v1.4.2\n  * pkg/cli: panic when flags can't be hidden\n  * pkg/unshare: check all errors\n  * pull: check error during report write\n  * run_linux.go: ignore unchecked errors\n  * conformance test: catch copy error\n  * chroot/run_test.go: export funcs to actually be executed\n  * tests/imgtype: ignore error when shutting down the store\n  * testreport: check json error\n  * bind/util.go: remove unused func\n  * rm chroot/util.go\n  * imagebuildah: remove unused `dedupeStringSlice`\n  * StageExecutor: EnsureContainerPath: catch error from SecureJoin()\n  * imagebuildah/build.go: return <expr> instead of branching\n  * rmi: avoid redundant branching\n  * conformance tests: nilness: allocate map\n  * imagebuildah/build.go: avoid redundant `filepath.Join()`\n  * imagebuildah/build.go: avoid redundant `os.Stat()`\n  * imagebuildah: omit comparison to bool\n  * fix \"ineffectual assignment\" lint errors\n  * docker: ignore \"repeats json tag\" lint error\n  * pkg/unshare: use `...` instead of iterating a slice\n  * conformance: bud test: use raw strings for regexes\n  * conformance suite: remove unused func/var\n  * buildah test suite: remove unused vars/funcs\n  * testreport: fix golangci-lint errors\n  * util: remove redundant `return` statement\n  * chroot: only log clean-up errors\n  * images_test: ignore golangci-lint error\n  * blobcache: log error when draining the pipe\n  * imagebuildah: check errors in deferred calls\n  * chroot: fix error handling in deferred funcs\n  * cmd: check all errors\n  * chroot/run_test.go: check errors\n  * chroot/run.go: check errors in deferred calls\n  * imagebuildah.Executor: remove unused onbuild field\n  * docker/types.go: remove unused struct fields\n  * util: use strings.ContainsRune instead of index check\n  * Cirrus: Initial implementation\n  * Bump to v1.9.1-dev\n\n- Changelog for v1.9.0 (2019-06-15)\n  * buildah-run: fix-out-of-range panic (2)\n  * Bump back to v1.9.0-dev\n\n- Changelog for v1.8.4 (2019-06-13)\n    Update containers/image to v2.0.0\n    run: fix hang with run and --isolation=chroot\n    run: fix hang when using run\n    chroot: drop unused function call\n    remove --> before imgageID on build\n    Always close stdin pipe\n    Write deny to setgroups when doing single user mapping\n    Avoid including linux/memfd.h\n    Add a test for the symlink pointing to a directory\n    Add missing continue\n    Fix the handling of symlinks to absolute paths\n    Only set default network sysctls if not rootless\n    Support --dns=none like podman\n    fix bug --cpu-shares parsing typo\n    Fix validate complaint\n    Update vendor on containers/storage to v1.12.10\n    Create directory paths for COPY thereby ensuring correct perms\n    imagebuildah: use a stable sort for comparing build args\n    imagebuildah: tighten up cache checking\n    bud.bats: add a test verying the order of --build-args\n    add -t to podman run\n    imagebuildah: simplify screening by top layers\n    imagebuildah: handle ID mappings for COPY --from\n    imagebuildah: apply additionalTags ourselves\n    bud.bats: test additional tags with cached images\n    bud.bats: add a test for WORKDIR and COPY with absolute destinations\n    Cleanup Overlay Mounts content\n\n- Changelog for v1.8.3 (2019-06-04)\n  * Add support for file secret mounts\n  * Add ability to skip secrets in mounts file\n  * allow 32bit builds\n  * fix tutorial instructions\n  * imagebuilder: pass the right contextDir to Add()\n  * add: use fileutils.PatternMatcher for .dockerignore\n  * bud.bats: add another .dockerignore test\n  * unshare: fallback to single usermapping\n  * addHelperSymlink: clear the destination on os.IsExist errors\n  * bud.bats: test replacing symbolic links\n  * imagebuildah: fix handling of destinations that end with '/'\n  * bud.bats: test COPY with a final \"/\" in the destination\n  * linux: add check for sysctl before using it\n  * unshare: set _CONTAINERS_ROOTLESS_GID\n  * Rework buildahimamges\n  * build context: support https git repos\n  * Add a test for ENV special chars behaviour\n  * Check in new Dockerfiles\n  * Apply custom SHELL during build time\n  * config: expand variables only at the command line\n  * SetEnv: we only need to expand v once\n  * Add default /root if empty on chroot iso\n  * Add support for Overlay volumes into the container.\n  * Export buildah validate volume functions so it can share code with libpod\n  * Bump baseline test to F30\n  * Fix rootless handling of /dev/shm size\n  * Avoid fmt.Printf() in the library\n  * imagebuildah: tighten cache checking back up\n  * Handle WORKDIR with dangling target\n  * Default Authfile to proper path\n  * Make buildah run --isolation follow BUILDAH_ISOLATION environment\n  * Vendor in latest containers/storage and containers/image\n  * getParent/getChildren: handle layerless images\n  * imagebuildah: recognize cache images for layerless images\n  * bud.bats: test scratch images with --layers caching\n  * Get CHANGELOG.md updates\n  * Add some symlinks to test our .dockerignore logic\n  * imagebuildah: addHelper: handle symbolic links\n  * commit/push: use an everything-allowed policy\n  * Correct manpage formatting in files section\n  * Remove must be root statement from buildah doc\n  * Change image names to stable, testing and upstream\n  * Bump back to v1.9.0-dev\n\n- Changelog for v1.8.2 (2019-05-02)\n  * Vendor Storage 1.12.6\n  * Create scratch file in TESTDIR\n  * Test bud-copy-dot with --layers picks up changed file\n  * Bump back to 1.9.0-dev\n\n- Changelog for v1.8.1 (2019-05-01)\n  * Don't create directory on container\n  * Replace kubernetes/pause in tests with k8s.gcr.io/pause\n  * imagebuildah: don't remove intermediate images if we need them\n  * Rework buildahimagegit to buildahimageupstream\n  * Fix Transient Mounts\n  * Handle WORKDIRs that are symlinks\n  * allow podman to build a client for windows\n  * Touch up 1.9-dev to 1.9.0-dev\n  * Bump to 1.9-dev\n\n- Changelog for v1.8.0 (2019-04-26)\n  * Resolve symlink when checking container path\n  * commit: commit on every instruction, but not always with layers\n  * CommitOptions: drop the unused OnBuild field\n  * makeImageRef: pass in the whole CommitOptions structure\n  * cmd: API cleanup: stores before images\n  * run: check if SELinux is enabled\n  * Fix buildahimages Dockerfiles to include support for additionalimages mounted from host.\n  * Detect changes in rootdir\n  * Fix typo in buildah-pull(1)\n  * Vendor in latest containers/storage\n  * Keep track of any build-args used during buildah bud --layers\n  * commit: always set a parent ID\n  * imagebuildah: rework unused-argument detection\n  * fix bug dest path when COPY .dockerignore\n  * Move Host IDMAppings code from util to unshare\n  * Add BUILDAH_ISOLATION rootless back\n  * Travis CI: fail fast, upon error in any step\n  * imagebuildah: only commit images for intermediate stages if we have to\n  * Use errors.Cause() when checking for IsNotExist errors\n  * auto pass http_proxy to container\n  * Bump back to 1.8-dev\n\n- Changelog for v1.7.3 (2019-04-16)\n  * imagebuildah: don't leak image structs\n  * Add Dockerfiles for buildahimages\n  * Bump to Replace golang 1.10 with 1.12\n  * add --dns* flags to buildah bud\n  * Add hack/build_speed.sh  test speeds on building container images\n  * Create buildahimage Dockerfile for Quay\n  * rename 'is' to 'expect_output'\n  * squash.bats: test squashing in multi-layered builds\n  * bud.bats: test COPY --from in a Dockerfile while using the cache\n  * commit: make target image names optional\n  * Fix bud-args to allow comma separation\n  * oops, missed some tests in commit.bats\n  * new helper: expect_line_count\n  * New tests for #1467 (string slices in cmdline opts)\n  * Workarounds for dealing with travis; review feedback\n  * BATS tests - extensive but minor cleanup\n  * imagebuildah: defer pulling images for COPY --from\n  * imagebuildah: centralize COMMIT and image ID output\n  * Travis: do not use traviswait\n  * imagebuildah: only initialize imagebuilder configuration once per stage\n  * Make cleaner error on Dockerfile build errors\n  * unshare: move to pkg/\n  * unshare: move some code from cmd/buildah/unshare\n  * Fix handling of Slices versus Arrays\n  * imagebuildah: reorganize stage and per-stage logic\n  * imagebuildah: add empty layers for instructions\n  * Add missing step in installing into Ubuntu\n  * fix bug in .dockerignore support\n  * imagebuildah: deduplicate prepended \"FROM\" instructions\n  * Touch up intro\n  * commit: set created-by to the shell if it isn't set\n  * commit: check that we always set a \"created-by\"\n  * docs/buildah.md: add \"containers-\" prefixes under \"SEE ALSO\"\n  * Bump back to 1.8-dev\n\n- Changelog for v1.7.2 (2019-03-28)\n  * mount: do not create automatically a namespace\n  * buildah: correctly create the userns if euid!=0\n  * imagebuildah.Build: consolidate cleanup logic\n  * CommitOptions: drop the redundant Store field\n  * Move pkg/chrootuser from libpod to buildah.\n  * imagebuildah: record image IDs and references more often\n  * vendor imagebuilder v1.1.0\n  * imagebuildah: fix requiresStart/noRunsRemaining confusion\n  * imagebuildah: check for unused args across stages\n  * bump github.com/containernetworking/cni to v0.7.0-rc2\n  * imagebuildah: use \"useCache\" instead of \"noCache\"\n  * imagebuildah.resolveNameToImageRef(): take name as a parameter\n  * Export fields of the DokcerIgnore struct\n  * imagebuildah: drop the duplicate containerIDs list\n  * rootless: by default use the host network namespace\n  * imagebuildah: split Executor and per-stage execution\n  * imagebuildah: move some fields around\n  * golint: make golint happy\n  * docs: 01-intro.md: add missing . in Dockerfile examples\n  * fix bug using .dockerignore\n  * Do not create empty mounts.conf file\n  * images: suppress a spurious blank line with no images\n  * from: distinguish between ADD and COPY\n  * fix bug to not separate each --label value with comma\n  * buildah-bud.md: correct a typo, note a default\n  * Remove mistaken code that got merged in other PR\n  * add sample registries.conf to docs\n  * escape shell variables in README example\n  * slirp4netns: set mtu to 65520\n  * images: imageReposToMap() already adds <none>:<none>\n  * imagebuildah.ReposToMap: move to cmd\n  * Build: resolve copyFrom references earlier\n  * Allow rootless users to use the cache directory in homedir\n  * bud.bats: use the per-test temp directory\n  * bud.bats: log output before counting length\n  * Simplify checks for leftover args\n  * Print commitID with --layers\n  * fix bug images use the template to print results\n  * rootless: honor --net host\n  * onsi/gomeage add missing files\n  * vendor latest openshift/imagebuilder\n  * Remove noop from squash help\n  * Prepend a comment to files setup in container\n  * imagebuildah resolveSymlink: fix handling of relative links\n  * Errors should be printed to stderr\n  * Add recommends for slirp4netns and fuse-overlay\n  * Update pull and pull-always flags\n  * Hide from users command options that we don't want them to use.\n  * Update secrets fipsmode patch to work on rootless containers\n  * fix unshare option handling and documentation\n  * Vendor in latest containers/storage\n  * Hard-code docker.Transport use in pull --all-tags\n  * Use a types.ImageReference instead of (transport, name) strings in pullImage etc.\n  * Move the computation of srcRef before first pullAndFindImage\n  * Don't throw away user-specified tag for pull --all-tags\n  * CHANGES BEHAVIOR: Remove the string format input to localImageNameForReference\n  * Don't try to parse imageName as transport:image in pullImage\n  * Use reference.WithTag instead of manual string manipulation in Pull\n  * Don't pass image = transport:repo:tag, transport=transport to pullImage\n  * Fix confusing variable naming in Pull\n  * Don't try to parse image name as a transport:image\n  * Fix error reporting when parsing trans+image\n  * Remove 'transport == \"\"' handling from the pull path\n  * Clean up \"pulls\" of local image IDs / ID prefixes\n  * Simplify ExpandNames\n  * Document the semantics of transport+name returned by ResolveName\n  * UPdate gitvalidation epoch\n  * Bump back to 1.8-dev\n\n- Changelog for v1.7.1 (2019-02-26)\n  * vendor containers/image v1.5\n  * Move secrets code from libpod into buildah\n  * Update CHANGELOG.md with the past changes\n  * README.md: fix typo\n  * Fix a few issues found by tests/validate/gometalinter.sh\n  * Neutralize buildah/unshare on non-Linux platforms\n  * Explicitly specify a directory to find(1)\n  * README.md: rephrase Buildah description\n  * Stop printing default twice in cli --help\n  * install.md: add section about vendoring\n  * Bump to 1.8-dev\n\n- Changelog for v1.7 (2019-02-21)\n  * vendor containers/image v1.4\n  * Make \"images --all\" faster\n  * Remove a misleading comment\n  * Remove quiet option from pull options\n  * Make sure buildah pull --all-tags only works with docker transport\n  * Support oci layout format\n  * Fix pulling of images within buildah\n  * Fix tls-verify polarity\n  * Travis: execute make vendor and hack/tree_status.sh\n  * vendor.conf: remove unused dependencies\n  * add missing vendor/github.com/containers/libpod/vendor.conf\n  * vendor.conf: remove github.com/inconshreveable/mousetrap\n  * make vendor: always fetch the latest vndr\n  * add hack/tree_status.sh script\n  * Bump c/Storage to 1.10\n  * Add --all-tags test to pull\n  * mount: make error clearer\n  * Remove global flags from cli help\n  * Set --disable-compression to true as documented\n  * Help document using buildah mount in rootless mode\n  * healthcheck start-period: update documentation\n  * Vendor in latest c/storage and c/image\n  * dumpbolt: handle nested buckets\n  * Fix buildah commit compress by default\n  * Test on xenial, not trusty\n  * unshare: reexec using a memfd copy instead of the binary\n  * Add --target to bud command\n  * Fix example for setting multiple environment variables\n  * main: fix rootless mode\n  * buildah: force umask 022\n  * pull.bats: specify registry config when using registries\n  * pull.bats: use the temporary directory, not /tmp\n  * unshare: do not set rootless mode if euid=0\n  * Touch up cli help examples and a few nits\n  * Add an undocumented dumpbolt command\n  * Move tar commands into containers/storage\n  * Fix bud issue with 2 line Dockerfile\n  * Add package install descriptions\n  * Note configuration file requirements\n  * Replace urfave/cli with cobra\n  * cleanup vendor.conf\n  * Vendor in latest containers/storage\n  * Add Quiet to PullOptions and PushOptions\n  * cmd/commit: add flag omit-timestamp to allow for deterministic builds\n  * Add options for empty-layer history entries\n  * Make CLI help descriptions and usage a bit more consistent\n  * vndr opencontainers/selinux\n  * Bump baseline test Fedora to 29\n  * Bump to v1.7-dev-1\n  * Bump to v1.6-1\n  * Add support for ADD --chown\n  * imagebuildah: make EnsureContainerPath() check/create the right one\n  * Bump 1.7-dev\n  * Fix contrib/rpm/bulidah.spec changelog date\n\n- Changelog for v1.6-1 (2019-01-18)\n  * Add support for ADD --chown\n  * imagebuildah: make EnsureContainerPath() check/create the right one\n  * Fix contrib/rpm/bulidah.spec changelog date\n  * Vendor in latest containers/storage\n  * Revendor everything\n  * Revendor in latest code by release\n  * unshare: do not set USER=root\n  * run: ignore EIO when flushing at the end, avoid double log\n  * build-using-dockerfile,commit: disable compression by default\n  * Update some comments\n  * Make rootless work under no_pivot_root\n  * Add CreatedAtRaw date field for use with Format\n  * Properly format images JSON output\n  * pull: add all-tags option\n  * Fix support for multiple Short options\n  * pkg/blobcache: add synchronization\n  * Skip empty files in file check of conformance test\n  * Use NoPivot also for RUN, not only for run\n  * Remove no longer used isReferenceInsecure / isRegistryInsecure\n  * Do not set OCIInsecureSkipTLSVerify based on registries.conf\n  * Remove duplicate entries from images JSON output\n  * vendor parallel-copy from containers/image\n  * blobcache.bats: adjust explicit push tests\n  * Handle one line Dockerfile with layers\n  * We should only warn if user actually requests Hostname be set in image\n  * Fix compiler Warning about comparing different size types\n  * imagebuildah: don't walk if rootdir and path are equal\n  * Add aliases for buildah containers, so buildah list, ls and ps work\n  * vendor: use faster version instead compress/gzip\n  * vendor: update libpod\n  * Properly handle Hostname inside of RUN command\n  * docs: mention how to mount in rootless mode\n  * tests: use fully qualified name for centos image\n  * travis.yml: use the fully qualified name for alpine\n  * mount: allow mount only when using vfs\n  * Add some tests for buildah pull\n  * Touch up images -q processing\n  * Refactor: Use library shared idtools.ParseIDMap() instead of bundling it\n  * bump GITVALIDATE_EPOCH\n  * cli.BudFlags: add `--platform` nop\n  * Makefile: allow packagers to more easily add tags\n  * Makefile: soften the requirement on git\n  * tests: add containers json test\n  * Inline blobCache.putBlob into blobCacheDestination.PutBlob\n  * Move saveStream and putBlob near blobCacheDestination.PutBlob\n  * Remove BlobCache.PutBlob\n  * Update for API changes\n  * Vendor c/image after merging c/image#536\n  * Handle 'COPY --from' in Dockerfile\n  * Vendor in latest content from github.com/containers/storage\n  * Clarify docker.io default in push with docker-daemon\n  * Test blob caching\n  * Wire in a hidden --blob-cache option\n  * Use a blob cache when we're asked to use one\n  * Add --disable-compression to 'build-using-dockerfile'\n  * Add a blob cache implementation\n  * vendor: update containers/storage\n  * Update for sysregistriesv2 API changes\n  * Update containers/image to 63a1cbdc5e6537056695cf0d627c0a33b334df53\n  * clean up makefile variables\n  * Fix file permission\n  * Complete the instructions for the command\n  * Show warning when a build arg not used\n  * Assume user 0 group 0, if /etc/passwd file in container.\n  * Add buildah info command\n  * Enable -q when --filter is used for images command\n  * Add v1.5 Release Announcement\n  * Fix dangling filter for images command\n  * Fix completions to print Names as well as IDs\n  * tests: Fix file permissions\n  * Bump 1.6-dev\n\n- Changelog for v1.5-1 (2018-11-21)\n  * Bump min go to 1.10 in install.md\n  * vendor: update ostree-go\n  * Update docker build command line in conformance test\n  * Print command in SystemExec as debug information\n  * Add some skip word for inspect check in conformance test\n  * Update regex for multi stage base test\n  * Sort CLI flags\n  * vendor: update containers/storage\n  * Add note to install about non-root on RHEL/CentOS\n  * Update imagebuild depdency to support heading ARGs in Dockerfile\n  * rootless: do not specify --rootless to the OCI runtime\n  * Export resolvesymlink function\n  * Exclude --force-rm from common bud cli flags\n  * run: bind mount /etc/hosts and /etc/resolv.conf if not in a volume\n  * rootless: use slirp4netns to setup the network namespace\n  * Instructions for completing the pull command\n  * Fix travis to not run environment variable patch\n  * rootless: only discard network configuration names\n  * run: only set up /etc/hosts or /etc/resolv.conf with network\n  * common: getFormat: match entire string not only the prefix\n  * vendor: update libpod\n  * Change validation EPOCH\n  * Fixing broken link for container-registries.conf\n  * Restore rootless isolation test for from volume ro test\n  * ostree: fix tag for build constraint\n  * Handle directories better in bud -f\n  * vndr in latest containers/storage\n  * Fix unshare gofmt issue\n  * runSetupBuiltinVolumes(): break up volume setup\n  * common: support a per-user registries conf file\n  * unshare: do not override the configuration\n  * common: honor the rootless configuration file\n  * unshare: create a new mount namespace\n  * unshare: support libpod rootless pkg\n  * Use libpod GetDefaultStorage to report proper storage config\n  * Allow container storage to manage the SELinux labels\n  * Resolve image names with default transport in from command\n  * run: When the value of isolation is set, use the set value instead of the default value.\n  * Vendor in latest containers/storage and opencontainers/selinux\n  * Remove no longer valid todo\n  * Check for empty buildTime in version\n  * Change gofmt so it runs on all but 1.10\n  * Run gofmt only on Go 1.11\n  * Walk symlinks when checking cached images for copied/added files\n  * ReserveSELinuxLabels(): handle wrapped errors from OpenBuilder\n  * Set WorkingDir to empty, not / for conformance\n  * Update calls in e2e to addres 1101\n  * imagebuilder.BuildDockerfiles: return the image ID\n  * Update for changes in the containers/image API\n  * bump(github.com/containers/image)\n  * Allow setting --no-pivot default with an env var\n  * Add man page and bash completion, for --no-pivot\n  * Add the --no-pivot flag to the run command\n  * Improve reporting about individual pull failures\n  * Move the \"short name but no search registries\" error handling to resolveImage\n  * Return a \"search registries were needed but empty\" indication in util.ResolveName\n  * Simplify handling of the \"tried to pull an image but found nothing\" case in newBuilder\n  * Don't even invoke the pull loop if options.FromImage == \"\"\n  * Eliminate the long-running ref and img variables in resolveImage\n  * In resolveImage, return immediately on success\n  * Fix From As in Dockerfile\n  * Vendor latest containers/image\n  * Vendor in latest libpod\n  * Sort CLI flags of buildah bud\n  * Change from testing with golang 1.9 to 1.11.\n  * unshare: detect when unprivileged userns are disabled\n  * Optimize redundant code\n  * fix missing format param\n  * chroot: fix the args check\n  * imagebuildah: make ResolveSymLink public\n  * Update copy chown test\n  * buildah: use the same logic for XDG_RUNTIME_DIR as podman\n  * V1.4 Release Announcement\n  * Podman  --privileged selinux is broken\n  * papr: mount source at gopath\n  * parse: Modify the return value\n  * parse: modify the verification of the isolation value\n  * Make sure we log or return every error\n  * pullImage(): when completing an image name, try docker://\n  * Fix up Tutorial 3 to account for format\n  * Vendor in latest containers/storage and containers/image\n  * docs/tutorials/01-intro.md: enhanced installation instructions\n  * Enforce \"blocked\" for registries for the \"docker\" transport\n  * Correctly set DockerInsecureSkipTLSVerify when pulling images\n  * chroot: set up seccomp and capabilities after supplemental groups\n  * chroot: fix capabilities list setup and application\n  * .papr.yml: log the podman version\n  * namespaces.bats: fix handling of uidmap/gidmap options in pairs\n  * chroot: only create user namespaces when we know we need them\n  * Check /proc/sys/user/max_user_namespaces on unshare(NEWUSERNS)\n  * bash/buildah: add isolation option to the from command\n\n- Changelog for v1.4 (2018-10-02)\n  * from: fix isolation option\n  * Touchup pull manpage\n  * Export buildah ReserveSELinuxLables so podman can use it\n  * Add buildah.io to README.md and doc fixes\n  * Update rmi man for prune changes\n  * Ignore file not found removal error in bud\n  * bump(github.com/containers/{storage,image})\n  * NewImageSource(): only create one Diff() at a time\n  * Copy ExposedPorts from base image into the config\n  * tests: run conformance test suite in Travis\n  * Change rmi --prune to not accept an imageID\n  * Clear intermediate container IDs after each stage\n  * Request podman version for build issues\n  * unshare: keep the additional groups of the user\n  * Builtin volumes should be owned by the UID/GID of the container\n  * Get rid of dangling whitespace in markdown files\n  * Move buildah from projecatatomic/buildah to containers/buildah\n  * nitpick: parse.validateFlags loop in bud cli\n  * bash: Completion options\n  * Add signature policy to push tests\n  * vendor in latest containers/image\n  * Fix grammar in Container Tools Guide\n  * Don't build btrfs if it is not installed\n  * new: Return image-pulling errors from resolveImage\n  * pull: Return image-pulling errors from pullImage\n  * Add more volume mount tests\n  * chroot: create missing parent directories for volume mounts\n  * Push: Allow an empty destination\n  * Add Podman relationship to readme, create container tools guide\n  * Fix arg usage in buildah-tag\n  * Add flags/arguments order verification to other commands\n  * Handle ErrDuplicateName errors from store.CreateContainer()\n  * Evaluate symbolic links on Add/Copy Commands\n  * Vendor in latest containers/image and containers/storage\n  * Retain bounding set when running containers as non root\n  * run container-diff tests in Travis\n  * buildah-images.md: Fix option contents\n  * push: show image digest after push succeed\n  * Vendor in latest containers/storage,image,libpod and runc\n  * Change references to cri-o to point at new repository\n  * Exclude --layers from the common bug cli flags\n  * demos: Increase the executable permissions\n  * run: clear default seccomp filter if not enabled\n  * Bump maximum cyclomatic complexity to 45\n  * stdin: on HUP, read everything\n  * nitpick: use tabs in tests/helpers.bash\n  * Add flags/arguments order verification to one arg commands\n  * nitpick: decrease cognitive complexity in buildah-bud\n  * rename: Avoid renaming the same name as other containers\n  * chroot isolation: chroot() before setting up seccomp\n  * Small nitpick at the \"if\" condition in tag.go\n  * cmd/images: Modify json option\n  * cmd/images: Disallow the input of image when using the -a option\n  * Fix examples to include context directory\n  * Update containers/image to fix commit layer issue\n  * cmd/containers: End loop early when using the json option\n  * Make buildah-from error message clear when flags are after arg\n  * Touch up README.md for conformance tests\n  * Update container/storage for lock fix\n  * cmd/rm: restore the correct containerID display\n  * Remove debug lines\n  * Remove docker build image after each test\n  * Add README for conformance test\n  * Update the MakeOptions to accept all command options for buildah\n  * Update regrex to fit the docker output in test \"run with JSON\"\n  * cmd/buildah: Remove redundant variable declarations\n  * Warn about using Commands in Dockerfile that are not supported by OCI.\n  * Add buildah bud conformance test\n  * Fix rename to also change container name in builder\n  * Makefile: use $(GO) env-var everywhere\n  * Cleanup code to more closely match Docker Build images\n  * Document BUILDAH_* environment variables in buildah bud --help output\n  * Return error immediately if error occurs in Prepare step\n  * Fix --layers ADD from url issue\n  * Add \"Sign your PRs\" TOC item to contributing.md.\n  * Display the correct ID after deleting image\n  * rmi: Modify the handling of errors\n  * Let util.ResolveName() return parsing errors\n  * Explain Open Container Initiative (OCI) acronym, add link\n  * Update vendor for urfave/cli back to master\n  * Handle COPY --chown in Dockerfile\n  * Switch to Recommends container-selinux\n  * Update vendor for containernetworking, imagebuildah and podman\n  * Document STORAGE_DRIVER and STORAGE_OPTS environment variable\n  * Change references to projectatomic/libpod to containers/libpod\n  * Add container PATH retrieval example\n  * Expand variables names for --env\n  * imagebuildah: provide a way to provide stdin for RUN\n  * Remove an unused srcRef.NewImageSource in pullImage\n  * chroot: correct a comment\n  * chroot: bind mount an empty directory for masking\n  * Don't bother with --no-pivot for rootless isolation\n  * CentOS need EPEL repo\n  * Export a Pull() function\n  * Remove stream options, since docker build does not have it\n  * release v1.3: mention openSUSE\n  * Add Release Announcements directory\n  * Bump to v1.4-dev\n\n- Changelog for v1.3 (2018-08-04)\n  * Revert pull error handling from 881\n  * bud should not search context directory for Dockerfile\n  * Set BUILDAH_ISOLATION=rootless when running unprivileged\n  * .papr.sh: Also test with BUILDAH_ISOLATION=rootless\n  * Skip certain tests when we're using \"rootless\" isolation\n  * .travis.yml: run integration tests with BUILDAH_ISOLATION=chroot\n  * Add and implement IsolationOCIRootless\n  * Add a value for IsolationOCIRootless\n  * Fix rmi to remove intermediate images associated with an image\n  * Return policy error on pull\n  * Update containers/image to 216acb1bcd2c1abef736ee322e17147ee2b7d76c\n  * Switch to github.com/containers/image/pkg/sysregistriesv2\n  * unshare: make adjusting the OOM score optional\n  * Add flags validation\n  * chroot: handle raising process limits\n  * chroot: make the resource limits name map module-global\n  * Remove rpm.bats, we need to run this manually\n  * Set the default ulimits to match Docker\n  * buildah: no args is out of bounds\n  * unshare: error message missed the pid\n  * preprocess \".in\" suffixed Dockerfiles\n  * Fix the the in buildah-config man page\n  * Only test rpmbuild on latest fedora\n  * Add support for multiple Short options\n  * Update to latest urvave/cli\n  * Add additional SELinux tests\n  * Vendor in latest github.com/containers/{image;storage}\n  * Stop testing with golang 1.8\n  * Fix volume cache issue with buildah bud --layers\n  * Create buildah pull command\n  * Increase the deadline for gometalinter during 'make validate'\n  * .papr.sh: Also test with BUILDAH_ISOLATION=chroot\n  * .travis.yml: run integration tests with BUILDAH_ISOLATION=chroot\n  * Add a Dockerfile\n  * Set BUILDAH_ISOLATION=chroot when running unprivileged\n  * Add and implement IsolationChroot\n  * Update github.com/opencontainers/runc\n  * maybeReexecUsingUserNamespace: add a default for root\n  * Allow ping command without NET_RAW Capabilities\n  * rmi.storageImageID: fix Wrapf format warning\n  * Allow Dockerfile content to come from stdin\n  * Vendor latest container/storage to fix overlay mountopt\n  * userns: assign additional IDs sequentially\n  * Remove default dev/pts\n  * Add OnBuild test to baseline test\n  * tests/run.bats(volumes): use :z when SELinux is enabled\n  * Avoid a stall in runCollectOutput()\n  * Use manifest from container/image\n  * Vendor in latest containers/image and containers/storage\n  * add rename command\n  * Completion command\n  * Update CHANGELOG.md\n  * Update vendor for runc to fix 32 bit builds\n  * bash completion: remove shebang\n  * Update vendor for runc to fix 32 bit builds\n\n- Changelog for v1.2 (2018-07-14)\n  * Vendor in lates containers/image\n  * build-using-dockerfile: let -t include transports again\n  * Block use of /proc/acpi and /proc/keys from inside containers\n  * Fix handling of --registries-conf\n  * Fix becoming a maintainer link\n  * add optional CI test fo darwin\n  * Don't pass a nil error to errors.Wrapf()\n  * image filter test: use kubernetes/pause as a \"since\"\n  * Add --cidfile option to from\n  * vendor: update containers/storage\n  * Contributors need to find the CONTRIBUTOR.md file easier\n  * Add a --loglevel option to build-with-dockerfile\n  * Create Development plan\n  * cmd: Code improvement\n  * allow buildah cross compile for a darwin target\n  * Add unused function param lint check\n  * docs: Follow man-pages(7) suggestions for SYNOPSIS\n  * Start using github.com/seccomp/containers-golang\n  * umount: add all option to umount all mounted containers\n  * runConfigureNetwork(): remove an unused parameter\n  * Update github.com/opencontainers/selinux\n  * Fix buildah bud --layers\n  * Force ownership of /etc/hosts and /etc/resolv.conf to 0:0\n  * main: if unprivileged, reexec in a user namespace\n  * Vendor in latest imagebuilder\n  * Reduce the complexity of the buildah.Run function\n  * mount: output it before replacing lastError\n  * Vendor in latest selinux-go code\n  * Implement basic recognition of the \"--isolation\" option\n  * Run(): try to resolve non-absolute paths using $PATH\n  * Run(): don't include any default environment variables\n  * build without seccomp\n  * vendor in latest runtime-tools\n  * bind/mount_unsupported.go: remove import errors\n  * Update github.com/opencontainers/runc\n  * Add Capabilities lists to BuilderInfo\n  * Tweaks for commit tests\n  * commit: recognize committing to second storage locations\n  * Fix ARGS parsing for run commands\n  * Add info on registries.conf to from manpage\n  * Switch from using docker to podman for testing in .papr\n  * buildah: set the HTTP User-Agent\n  * ONBUILD tutorial\n  * Add information about the configuration files to the install docs\n  * Makefile: add uninstall\n  * Add tilde info for push to troubleshooting\n  * mount: support multiple inputs\n  * Use the right formatting when adding entries to /etc/hosts\n  * Vendor in latest go-selinux bindings\n  * Allow --userns-uid-map/--userns-gid-map to be global options\n  * bind: factor out UnmountMountpoints\n  * Run(): simplify runCopyStdio()\n  * Run(): handle POLLNVAL results\n  * Run(): tweak terminal mode handling\n  * Run(): rename 'copyStdio' to 'copyPipes'\n  * Run(): don't set a Pdeathsig for the runtime\n  * Run(): add options for adding and removing capabilities\n  * Run(): don't use a callback when a slice will do\n  * setupSeccomp(): refactor\n  * Change RunOptions.Stdin/Stdout/Stderr to just be Reader/Writers\n  * Escape use of '_' in .md docs\n  * Break out getProcIDMappings()\n  * Break out SetupIntermediateMountNamespace()\n  * Add Multi From Demo\n  * Use the c/image conversion code instead of converting configs manually\n  * Don't throw away the manifest MIME type and guess again\n  * Consolidate loading manifest and config in initConfig\n  * Pass a types.Image to Builder.initConfig\n  * Require an image ID in importBuilderDataFromImage\n  * Use c/image/manifest.GuessMIMEType instead of a custom heuristic\n  * Do not ignore any parsing errors in initConfig\n  * Explicitly handle \"from scratch\" images in Builder.initConfig\n  * Fix parsing of OCI images\n  * Simplify dead but dangerous-looking error handling\n  * Don't ignore v2s1 history if docker_version is not set\n  * Add --rm and --force-rm to buildah bud\n  * Add --all,-a flag to buildah images\n  * Separate stdio buffering from writing\n  * Remove tty check from images --format\n  * Add environment variable BUILDAH_RUNTIME\n  * Add --layers and --no-cache to buildah bud\n  * Touch up images man\n  * version.md: fix DESCRIPTION\n  * tests: add containers test\n  * tests: add images test\n  * images: fix usage\n  * fix make clean error\n  * Change 'registries' to 'container registries' in man\n  * add commit test\n  * Add(): learn to record hashes of what we add\n  * Minor update to buildah config documentation for entrypoint\n  * Bump to v1.2-dev\n  * Add registries.conf link to a few man pages\n\n- Changelog for v1.1 (2018-06-08)\n  * Drop capabilities if running container processes as non root\n  * Print Warning message if cmd will not be used based on entrypoint\n  * Update 01-intro.md\n  * Shouldn't add insecure registries to list of search registries\n  * Report errors on bad transports specification when pushing images\n  * Move parsing code out of common for namespaces and into pkg/parse.go\n  * Add disable-content-trust noop flag to bud\n  * Change freenode chan to buildah\n  * runCopyStdio(): don't close stdin unless we saw POLLHUP\n  * Add registry errors for pull\n  * runCollectOutput(): just read until the pipes are closed on us\n  * Run(): provide redirection for stdio\n  * rmi, rm: add test\n  * add mount test\n  * Add parameter judgment for commands that do not require parameters\n  * Add context dir to bud command in baseline test\n  * run.bats: check that we can run with symlinks in the bundle path\n  * Give better messages to users when image can not be found\n  * use absolute path for bundlePath\n  * Add environment variable to buildah --format\n  * rm: add validation to args and all option\n  * Accept json array input for config entrypoint\n  * Run(): process RunOptions.Mounts, and its flags\n  * Run(): only collect error output from stdio pipes if we created some\n  * Add OnBuild support for Dockerfiles\n  * Quick fix on demo readme\n  * run: fix validate flags\n  * buildah bud should require a context directory or URL\n  * Touchup tutorial for run changes\n  * Validate common bud and from flags\n  * images: Error if the specified imagename does not exist\n  * inspect: Increase err judgments to avoid panic\n  * add test to inspect\n  * buildah bud picks up ENV from base image\n  * Extend the amount of time travis_wait should wait\n  * Add a make target for Installing CNI plugins\n  * Add tests for namespace control flags\n  * copy.bats: check ownerships in the container\n  * Fix SELinux test errors when SELinux is enabled\n  * Add example CNI configurations\n  * Run: set supplemental group IDs\n  * Run: use a temporary mount namespace\n  * Use CNI to configure container networks\n  * add/secrets/commit: Use mappings when setting permissions on added content\n  * Add CLI options for specifying namespace and cgroup setup\n  * Always set mappings when using user namespaces\n  * Run(): break out creation of stdio pipe descriptors\n  * Read UID/GID mapping information from containers and images\n  * Additional bud CI tests\n  * Run integration tests under travis_wait in Travis\n  * build-using-dockerfile: add --annotation\n  * Implement --squash for build-using-dockerfile and commit\n  * Vendor in latest container/storage for devicemapper support\n  * add test to inspect\n  * Vendor github.com/onsi/ginkgo and github.com/onsi/gomega\n  * Test with Go 1.10, too\n  * Add console syntax highlighting to troubleshooting page\n  * bud.bats: print \"$output\" before checking its contents\n  * Manage \"Run\" containers more closely\n  * Break Builder.Run()'s \"run runc\" bits out\n  * util.ResolveName(): handle completion for tagged/digested image names\n  * Handle /etc/hosts and /etc/resolv.conf properly in container\n  * Documentation fixes\n  * Make it easier to parse our temporary directory as an image name\n  * Makefile: list new pkg/ subdirectoris as dependencies for buildah\n  * containerImageSource: return more-correct errors\n  * API cleanup: PullPolicy and TerminalPolicy should be types\n  * Make \"run --terminal\" and \"run -t\" aliases for \"run --tty\"\n  * Vendor github.com/containernetworking/cni v0.6.0\n  * Update github.com/containers/storage\n  * Update github.com/projectatomic/libpod\n  * Add support for buildah bud --label\n  * buildah push/from can push and pull images with no reference\n  * Vendor in latest containers/image\n  * Update gometalinter to fix install.tools error\n  * Update troubleshooting with new run workaround\n  * Added a bud demo and tidied up\n  * Attempt to download file from url, if fails assume Dockerfile\n  * Add buildah bud CI tests for ENV variables\n  * Re-enable rpm .spec version check and new commit test\n  * Update buildah scratch demo to support el7\n  * Added Docker compatibility demo\n  * Update to F28 and new run format in baseline test\n  * Touchup man page short options across man pages\n  * Added demo dir and a demo. chged distrorlease\n  * builder-inspect: fix format option\n  * Add cpu-shares short flag (-c) and cpu-shares CI tests\n  * Minor fixes to formatting in rpm spec changelog\n  * Fix rpm .spec changelog formatting\n  * CI tests and minor fix for cache related noop flags\n  * buildah-from: add effective value to mount propagation\n\n- Changelog for v1.0 (2018-05-06)\n  * Declare Buildah 1.0\n  * Add cache-from and no-cache noops, and fix doco\n  * Update option and documentation for --force-rm\n  * Adding noop for --force-rm to match --rm\n  * Add buildah bud ENTRYPOINT,CMD,RUN tests\n  * Adding buildah bud RUN test scenarios\n  * Extend tests for empty buildah run command\n  * Fix formatting error in run.go\n  * Update buildah run to make command required\n  * Expanding buildah run cmd/entrypoint tests\n  * Update test cases for buildah run behaviour\n  * Remove buildah run cmd and entrypoint execution\n  * Add Files section with registries.conf to pertinent man pages\n  * tests/config: perfect test\n  * tests/from: add name test\n  * Do not print directly to stdout in Commit()\n  * Touch up auth test commands\n  * Force \"localhost\" as a default registry\n  * Drop util.GetLocalTime()\n  * Vendor in latest containers/image\n  * Validate host and container paths passed to --volume\n  * test/from: add add-host test\n  * Add --compress, --rm, --squash flags as a noop for bud\n  * Add FIPS mode secret to buildah run and bud\n  * Add config --comment/--domainname/--history-comment/--hostname\n  * 'buildah config': stop replacing Created-By whenever it's not specified\n  * Modify man pages so they compile correctly in mandb\n  * Add description on how to do --isolation to buildah-bud man page\n  * Add support for --iidfile to bud and commit\n  * Refactor buildah bud for vendoring\n  * Fail if date or git not installed\n  * Revert update of entrypoint behaviour to match docker\n  * Vendor in latest imagebuilder code to fix multiple stage builds\n  * Add /bin/sh -c to entrypoint in config\n  * image_test: Improve the test\n  * Fix README example of buildah config\n  * buildah-image: add validation to 'format'\n  * Simple changes to allow buildah to pass make validate\n  * Clarify the use of buildah config options\n  * containers_test: Perfect testing\n  * buildah images and podman images are listing different sizes\n  * buildah-containers: add tests and example to the man page\n  * buildah-containers: add validation to 'format'\n  * Clarify the use of buildah config options\n  * Minor fix for lighttpd example in README\n  * Add tls-verification to troubleshooting\n  * Modify buildah rmi to account for changes in containers/storage\n  * Vendor in latest containers/image and containers/storage\n  * addcopy: add src validation\n  * Remove tarball as an option from buildah push --help\n  * Fix secrets patch\n  * Update entrypoint behaviour to match docker\n  * Display imageId after commit\n  * config: add support for StopSignal\n  * Fix docker login issue in travis.yml\n  * Allow referencing stages as index and names\n  * Add multi-stage builds tests\n  * Add multi-stage builds support\n  * Add accessor functions for comment and stop signal\n  * Vendor in latest imagebuilder, to get mixed case AS support\n  * Allow umount to have multi-containers\n  * Update buildah push doc\n  * buildah bud walks symlinks\n  * Imagename is required for commit atm, update manpage\n\n- Changelog for v0.16.0 (2018-04-08)\n  * Bump to v0.16.0\n  * Remove requires for ostree-lib in rpm spec file\n  * Add support for shell\n  * buildah.spec should require ostree-libs\n  * Vendor in latest containers/image\n  * bash: prefer options\n  * Change image time to locale, add troubleshooting.md, add logo to other mds\n  * buildah-run.md: fix error SYNOPSIS\n  * docs: fix error example\n  * Allow --cmd parameter to have commands as values\n  * Touchup README to re-enable logo\n  * Clean up README.md\n  * Make default-mounts-file a hidden option\n  * Document the mounts.conf file\n  * Fix man pages to format correctly\n  * Add various transport support to buildah from\n  * Add unit tests to run.go\n  * If the user overrides the storage driver, the options should be dropped\n  * Show Config/Manifest as JSON string in inspect when format is not set\n  * Switch which for that in README.md\n  * Remove COPR\n  * Fix wrong order of parameters\n  * Vendor in latest containers/image\n  * Remove shallowCopy(), which shouldn't be saving us time any more\n  * shallowCopy: avoid a second read of the container's layer\n"
        },
        {
          "name": "chroot",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "commit.go",
          "type": "blob",
          "size": 20.0107421875,
          "content": "package buildah\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/containers/buildah/pkg/blobcache\"\n\t\"github.com/containers/buildah/util\"\n\t\"github.com/containers/common/libimage\"\n\t\"github.com/containers/common/libimage/manifests\"\n\t\"github.com/containers/image/v5/docker\"\n\t\"github.com/containers/image/v5/docker/reference\"\n\t\"github.com/containers/image/v5/manifest\"\n\t\"github.com/containers/image/v5/signature\"\n\tis \"github.com/containers/image/v5/storage\"\n\t\"github.com/containers/image/v5/transports\"\n\t\"github.com/containers/image/v5/types\"\n\tencconfig \"github.com/containers/ocicrypt/config\"\n\t\"github.com/containers/storage/pkg/archive\"\n\t\"github.com/containers/storage/pkg/stringid\"\n\tdigest \"github.com/opencontainers/go-digest\"\n\tv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/exp/maps\"\n)\n\nconst (\n\t// BuilderIdentityAnnotation is the name of the annotation key containing\n\t// the name and version of the producer of the image stored as an\n\t// annotation on commit.\n\tBuilderIdentityAnnotation = \"io.buildah.version\"\n)\n\n// CommitOptions can be used to alter how an image is committed.\ntype CommitOptions struct {\n\t// PreferredManifestType is the preferred type of image manifest.  The\n\t// image configuration format will be of a compatible type.\n\tPreferredManifestType string\n\t// Compression specifies the type of compression which is applied to\n\t// layer blobs.  The default is to not use compression, but\n\t// archive.Gzip is recommended.\n\tCompression archive.Compression\n\t// SignaturePolicyPath specifies an override location for the signature\n\t// policy which should be used for verifying the new image as it is\n\t// being written.  Except in specific circumstances, no value should be\n\t// specified, indicating that the shared, system-wide default policy\n\t// should be used.\n\tSignaturePolicyPath string\n\t// AdditionalTags is a list of additional names to add to the image, if\n\t// the transport to which we're writing the image gives us a way to add\n\t// them.\n\tAdditionalTags []string\n\t// ReportWriter is an io.Writer which will be used to log the writing\n\t// of the new image.\n\tReportWriter io.Writer\n\t// HistoryTimestamp is the timestamp used when creating new items in the\n\t// image's history.  If unset, the current time will be used.\n\tHistoryTimestamp *time.Time\n\t// github.com/containers/image/types SystemContext to hold credentials\n\t// and other authentication/authorization information.\n\tSystemContext *types.SystemContext\n\t// IIDFile tells the builder to write the image ID to the specified file\n\tIIDFile string\n\t// Squash tells the builder to produce an image with a single layer\n\t// instead of with possibly more than one layer.\n\tSquash bool\n\t// OmitHistory tells the builder to ignore the history of build layers and\n\t// base while preparing image-spec, setting this to true will ensure no history\n\t// is added to the image-spec. (default false)\n\tOmitHistory bool\n\t// BlobDirectory is the name of a directory in which we'll look for\n\t// prebuilt copies of layer blobs that we might otherwise need to\n\t// regenerate from on-disk layers.  If blobs are available, the\n\t// manifest of the new image will reference the blobs rather than\n\t// on-disk layers.\n\tBlobDirectory string\n\t// EmptyLayer tells the builder to omit the diff for the working\n\t// container.\n\tEmptyLayer bool\n\t// OmitTimestamp forces epoch 0 as created timestamp to allow for\n\t// deterministic, content-addressable builds.\n\t// Deprecated use HistoryTimestamp instead.\n\tOmitTimestamp bool\n\t// SignBy is the fingerprint of a GPG key to use for signing the image.\n\tSignBy string\n\t// Manifest list to add the image to.\n\tManifest string\n\t// MaxRetries is the maximum number of attempts we'll make to commit\n\t// the image to an external registry if the first attempt fails.\n\tMaxRetries int\n\t// RetryDelay is how long to wait before retrying a commit attempt to a\n\t// registry.\n\tRetryDelay time.Duration\n\t// OciEncryptConfig when non-nil indicates that an image should be encrypted.\n\t// The encryption options is derived from the construction of EncryptConfig object.\n\tOciEncryptConfig *encconfig.EncryptConfig\n\t// OciEncryptLayers represents the list of layers to encrypt.\n\t// If nil, don't encrypt any layers.\n\t// If non-nil and len==0, denotes encrypt all layers.\n\t// integers in the slice represent 0-indexed layer indices, with support for negative\n\t// indexing. i.e. 0 is the first layer, -1 is the last (top-most) layer.\n\tOciEncryptLayers *[]int\n\t// ConfidentialWorkloadOptions is used to force the output image's rootfs to contain a\n\t// LUKS-compatibly encrypted disk image (for use with krun) instead of the usual\n\t// contents of a rootfs.\n\tConfidentialWorkloadOptions ConfidentialWorkloadOptions\n\t// UnsetEnvs is a list of environments to not add to final image.\n\t// Deprecated: use UnsetEnv() before committing instead.\n\tUnsetEnvs []string\n\t// OverrideConfig is an optional Schema2Config which can override parts\n\t// of the working container's configuration for the image that is being\n\t// committed.\n\tOverrideConfig *manifest.Schema2Config\n\t// OverrideChanges is a slice of Dockerfile-style instructions to make\n\t// to the configuration of the image that is being committed, after\n\t// OverrideConfig is applied.\n\tOverrideChanges []string\n\t// ExtraImageContent is a map which describes additional content to add\n\t// to the new layer in the committed image.  The map's keys are\n\t// filesystem paths in the image and the corresponding values are the\n\t// paths of files whose contents will be used in their place.  The\n\t// contents will be owned by 0:0 and have mode 0o644.  Currently only\n\t// accepts regular files.\n\tExtraImageContent map[string]string\n\t// SBOMScanOptions encapsulates options which control whether or not we\n\t// run scanners on the rootfs that we're about to commit, and how.\n\tSBOMScanOptions []SBOMScanOptions\n\t// CompatSetParent causes the \"parent\" field to be set when committing\n\t// the image in Docker format.  Newer BuildKit-based builds don't set\n\t// this field.\n\tCompatSetParent types.OptionalBool\n\t// PrependedLinkedLayers and AppendedLinkedLayers are combinations of\n\t// history entries and locations of either directory trees (if\n\t// directories, per os.Stat()) or uncompressed layer blobs which should\n\t// be added to the image at commit-time.  The order of these relative\n\t// to PrependedEmptyLayers and AppendedEmptyLayers, and relative to the\n\t// corresponding members in the Builder object, in the committed image\n\t// is not guaranteed.\n\tPrependedLinkedLayers, AppendedLinkedLayers []LinkedLayer\n}\n\n// LinkedLayer combines a history entry with the location of either a directory\n// tree (if it's a directory, per os.Stat()) or an uncompressed layer blob\n// which should be added to the image at commit-time.  The BlobPath and\n// History.EmptyLayer fields should be considered mutually-exclusive.\ntype LinkedLayer struct {\n\tHistory  v1.History // history entry to add\n\tBlobPath string     // corresponding uncompressed blob file (layer as a tar archive), or directory tree to archive\n}\n\n// storageAllowedPolicyScopes overrides the policy for local storage\n// to ensure that we can read images from it.\nvar storageAllowedPolicyScopes = signature.PolicyTransportScopes{\n\t\"\": []signature.PolicyRequirement{\n\t\tsignature.NewPRInsecureAcceptAnything(),\n\t},\n}\n\n// checkRegistrySourcesAllows checks the $BUILD_REGISTRY_SOURCES environment\n// variable, if it's set.  The contents are expected to be a JSON-encoded\n// github.com/openshift/api/config/v1.Image, set by an OpenShift build\n// controller that arranged for us to be run in a container.\nfunc checkRegistrySourcesAllows(forWhat string, dest types.ImageReference) (insecure bool, err error) {\n\ttransport := dest.Transport()\n\tif transport == nil {\n\t\treturn false, nil\n\t}\n\tif transport.Name() != docker.Transport.Name() {\n\t\treturn false, nil\n\t}\n\tdref := dest.DockerReference()\n\tif dref == nil || reference.Domain(dref) == \"\" {\n\t\treturn false, nil\n\t}\n\n\tif registrySources, ok := os.LookupEnv(\"BUILD_REGISTRY_SOURCES\"); ok && len(registrySources) > 0 {\n\t\t// Use local struct instead of github.com/openshift/api/config/v1 RegistrySources\n\t\tvar sources struct {\n\t\t\tInsecureRegistries []string `json:\"insecureRegistries,omitempty\"`\n\t\t\tBlockedRegistries  []string `json:\"blockedRegistries,omitempty\"`\n\t\t\tAllowedRegistries  []string `json:\"allowedRegistries,omitempty\"`\n\t\t}\n\t\tif err := json.Unmarshal([]byte(registrySources), &sources); err != nil {\n\t\t\treturn false, fmt.Errorf(\"parsing $BUILD_REGISTRY_SOURCES (%q) as JSON: %w\", registrySources, err)\n\t\t}\n\t\tblocked := false\n\t\tif len(sources.BlockedRegistries) > 0 {\n\t\t\tfor _, blockedDomain := range sources.BlockedRegistries {\n\t\t\t\tif blockedDomain == reference.Domain(dref) {\n\t\t\t\t\tblocked = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif blocked {\n\t\t\treturn false, fmt.Errorf(\"%s registry at %q denied by policy: it is in the blocked registries list\", forWhat, reference.Domain(dref))\n\t\t}\n\t\tallowed := true\n\t\tif len(sources.AllowedRegistries) > 0 {\n\t\t\tallowed = false\n\t\t\tfor _, allowedDomain := range sources.AllowedRegistries {\n\t\t\t\tif allowedDomain == reference.Domain(dref) {\n\t\t\t\t\tallowed = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif !allowed {\n\t\t\treturn false, fmt.Errorf(\"%s registry at %q denied by policy: not in allowed registries list\", forWhat, reference.Domain(dref))\n\t\t}\n\t\tif len(sources.InsecureRegistries) > 0 {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\treturn false, nil\n}\n\nfunc (b *Builder) addManifest(ctx context.Context, manifestName string, imageSpec string) (string, error) {\n\tvar create bool\n\tsystemContext := &types.SystemContext{}\n\tvar list manifests.List\n\truntime, err := libimage.RuntimeFromStore(b.store, &libimage.RuntimeOptions{SystemContext: systemContext})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tmanifestList, err := runtime.LookupManifestList(manifestName)\n\tif err != nil {\n\t\tcreate = true\n\t\tlist = manifests.Create()\n\t} else {\n\t\tlocker, err := manifests.LockerForImage(b.store, manifestList.ID())\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tlocker.Lock()\n\t\tdefer locker.Unlock()\n\t\t_, list, err = manifests.LoadFromImage(b.store, manifestList.ID())\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\tnames, err := util.ExpandNames([]string{manifestName}, systemContext, b.store)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"encountered while expanding manifest list name %q: %w\", manifestName, err)\n\t}\n\n\tref, err := util.VerifyTagName(imageSpec)\n\tif err != nil {\n\t\t// check if the local image exists\n\t\tif ref, _, err = util.FindImage(b.store, \"\", systemContext, imageSpec); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\tif _, err = list.Add(ctx, systemContext, ref, true); err != nil {\n\t\treturn \"\", err\n\t}\n\tvar imageID string\n\tif create {\n\t\timageID, err = list.SaveToImage(b.store, \"\", names, manifest.DockerV2ListMediaType)\n\t} else {\n\t\timageID, err = list.SaveToImage(b.store, manifestList.ID(), nil, \"\")\n\t}\n\treturn imageID, err\n}\n\n// Commit writes the contents of the container, along with its updated\n// configuration, to a new image in the specified location, and if we know how,\n// add any additional tags that were specified. Returns the ID of the new image\n// if commit was successful and the image destination was local.\nfunc (b *Builder) Commit(ctx context.Context, dest types.ImageReference, options CommitOptions) (string, reference.Canonical, digest.Digest, error) {\n\tvar (\n\t\timgID string\n\t\tsrc   types.ImageReference\n\t)\n\n\t// If we weren't given a name, build a destination reference using a\n\t// temporary name that we'll remove later.  The correct thing to do\n\t// would be to read the manifest and configuration blob, and ask the\n\t// manifest for the ID that we'd give the image, but that computation\n\t// requires that we know the digests of the layer blobs, which we don't\n\t// want to compute here because we'll have to do it again when\n\t// cp.Image() instantiates a source image, and we don't want to do the\n\t// work twice.\n\tif options.OmitTimestamp {\n\t\tif options.HistoryTimestamp != nil {\n\t\t\treturn imgID, nil, \"\", fmt.Errorf(\"OmitTimestamp ahd HistoryTimestamp can not be used together\")\n\t\t}\n\t\ttimestamp := time.Unix(0, 0).UTC()\n\t\toptions.HistoryTimestamp = &timestamp\n\t}\n\tnameToRemove := \"\"\n\tif dest == nil {\n\t\tnameToRemove = stringid.GenerateRandomID() + \"-tmp\"\n\t\tdest2, err := is.Transport.ParseStoreReference(b.store, nameToRemove)\n\t\tif err != nil {\n\t\t\treturn imgID, nil, \"\", fmt.Errorf(\"creating temporary destination reference for image: %w\", err)\n\t\t}\n\t\tdest = dest2\n\t}\n\n\tsystemContext := getSystemContext(b.store, options.SystemContext, options.SignaturePolicyPath)\n\n\tblocked, err := isReferenceBlocked(dest, systemContext)\n\tif err != nil {\n\t\treturn \"\", nil, \"\", fmt.Errorf(\"checking if committing to registry for %q is blocked: %w\", transports.ImageName(dest), err)\n\t}\n\tif blocked {\n\t\treturn \"\", nil, \"\", fmt.Errorf(\"commit access to registry for %q is blocked by configuration\", transports.ImageName(dest))\n\t}\n\n\t// Load the system signing policy.\n\tcommitPolicy, err := signature.DefaultPolicy(systemContext)\n\tif err != nil {\n\t\treturn \"\", nil, \"\", fmt.Errorf(\"obtaining default signature policy: %w\", err)\n\t}\n\t// Override the settings for local storage to make sure that we can always read the source \"image\".\n\tcommitPolicy.Transports[is.Transport.Name()] = storageAllowedPolicyScopes\n\n\tpolicyContext, err := signature.NewPolicyContext(commitPolicy)\n\tif err != nil {\n\t\treturn imgID, nil, \"\", fmt.Errorf(\"creating new signature policy context: %w\", err)\n\t}\n\tdefer func() {\n\t\tif err2 := policyContext.Destroy(); err2 != nil {\n\t\t\tlogrus.Debugf(\"error destroying signature policy context: %v\", err2)\n\t\t}\n\t}()\n\n\t// Check if the commit is blocked by $BUILDER_REGISTRY_SOURCES.\n\tinsecure, err := checkRegistrySourcesAllows(\"commit to\", dest)\n\tif err != nil {\n\t\treturn imgID, nil, \"\", err\n\t}\n\tif insecure {\n\t\tif systemContext.DockerInsecureSkipTLSVerify == types.OptionalBoolFalse {\n\t\t\treturn imgID, nil, \"\", fmt.Errorf(\"can't require tls verification on an insecured registry\")\n\t\t}\n\t\tsystemContext.DockerInsecureSkipTLSVerify = types.OptionalBoolTrue\n\t\tsystemContext.OCIInsecureSkipTLSVerify = true\n\t\tsystemContext.DockerDaemonInsecureSkipTLSVerify = true\n\t}\n\tlogrus.Debugf(\"committing image with reference %q is allowed by policy\", transports.ImageName(dest))\n\n\t// If we need to scan the rootfs, do it now.\n\toptions.ExtraImageContent = maps.Clone(options.ExtraImageContent)\n\tvar extraImageContent, extraLocalContent map[string]string\n\tif len(options.SBOMScanOptions) != 0 {\n\t\tvar scansDirectory string\n\t\tif extraImageContent, extraLocalContent, scansDirectory, err = b.sbomScan(ctx, options); err != nil {\n\t\t\treturn imgID, nil, \"\", fmt.Errorf(\"scanning rootfs to generate SBOM for container %q: %w\", b.ContainerID, err)\n\t\t}\n\t\tif scansDirectory != \"\" {\n\t\t\tdefer func() {\n\t\t\t\tif err := os.RemoveAll(scansDirectory); err != nil {\n\t\t\t\t\tlogrus.Warnf(\"removing temporary directory %q: %v\", scansDirectory, err)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tif len(extraImageContent) > 0 {\n\t\t\tif options.ExtraImageContent == nil {\n\t\t\t\toptions.ExtraImageContent = make(map[string]string, len(extraImageContent))\n\t\t\t}\n\t\t\t// merge in the scanner-generated content\n\t\t\tfor k, v := range extraImageContent {\n\t\t\t\tif _, set := options.ExtraImageContent[k]; !set {\n\t\t\t\t\toptions.ExtraImageContent[k] = v\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Build an image reference from which we can copy the finished image.\n\tsrc, err = b.makeContainerImageRef(options)\n\tif err != nil {\n\t\treturn imgID, nil, \"\", fmt.Errorf(\"computing layer digests and building metadata for container %q: %w\", b.ContainerID, err)\n\t}\n\t// In case we're using caching, decide how to handle compression for a cache.\n\t// If we're using blob caching, set it up for the source.\n\tmaybeCachedSrc := src\n\tmaybeCachedDest := dest\n\tif options.BlobDirectory != \"\" {\n\t\tcompress := types.PreserveOriginal\n\t\tif options.Compression != archive.Uncompressed {\n\t\t\tcompress = types.Compress\n\t\t}\n\t\tcache, err := blobcache.NewBlobCache(src, options.BlobDirectory, compress)\n\t\tif err != nil {\n\t\t\treturn imgID, nil, \"\", fmt.Errorf(\"wrapping image reference %q in blob cache at %q: %w\", transports.ImageName(src), options.BlobDirectory, err)\n\t\t}\n\t\tmaybeCachedSrc = cache\n\t\tcache, err = blobcache.NewBlobCache(dest, options.BlobDirectory, compress)\n\t\tif err != nil {\n\t\t\treturn imgID, nil, \"\", fmt.Errorf(\"wrapping image reference %q in blob cache at %q: %w\", transports.ImageName(dest), options.BlobDirectory, err)\n\t\t}\n\t\tmaybeCachedDest = cache\n\t}\n\t// \"Copy\" our image to where it needs to be.\n\tswitch options.Compression {\n\tcase archive.Uncompressed:\n\t\tsystemContext.OCIAcceptUncompressedLayers = true\n\tcase archive.Gzip:\n\t\tsystemContext.DirForceCompress = true\n\t}\n\n\tif systemContext.ArchitectureChoice != b.Architecture() {\n\t\tsystemContext.ArchitectureChoice = b.Architecture()\n\t}\n\tif systemContext.OSChoice != b.OS() {\n\t\tsystemContext.OSChoice = b.OS()\n\t}\n\n\tvar manifestBytes []byte\n\tif manifestBytes, err = retryCopyImage(ctx, policyContext, maybeCachedDest, maybeCachedSrc, dest, getCopyOptions(b.store, options.ReportWriter, nil, systemContext, \"\", false, options.SignBy, options.OciEncryptLayers, options.OciEncryptConfig, nil), options.MaxRetries, options.RetryDelay); err != nil {\n\t\treturn imgID, nil, \"\", fmt.Errorf(\"copying layers and metadata for container %q: %w\", b.ContainerID, err)\n\t}\n\t// If we've got more names to attach, and we know how to do that for\n\t// the transport that we're writing the new image to, add them now.\n\tif len(options.AdditionalTags) > 0 {\n\t\tswitch dest.Transport().Name() {\n\t\tcase is.Transport.Name():\n\t\t\t_, img, err := is.ResolveReference(dest)\n\t\t\tif err != nil {\n\t\t\t\treturn imgID, nil, \"\", fmt.Errorf(\"locating just-written image %q: %w\", transports.ImageName(dest), err)\n\t\t\t}\n\t\t\tif err = util.AddImageNames(b.store, \"\", systemContext, img, options.AdditionalTags); err != nil {\n\t\t\t\treturn imgID, nil, \"\", fmt.Errorf(\"setting image names to %v: %w\", append(img.Names, options.AdditionalTags...), err)\n\t\t\t}\n\t\t\tlogrus.Debugf(\"assigned names %v to image %q\", img.Names, img.ID)\n\t\tdefault:\n\t\t\tlogrus.Warnf(\"don't know how to add tags to images stored in %q transport\", dest.Transport().Name())\n\t\t}\n\t}\n\n\tif dest.Transport().Name() == is.Transport.Name() {\n\t\tdest2, img, err := is.ResolveReference(dest)\n\t\tif err != nil {\n\t\t\treturn imgID, nil, \"\", fmt.Errorf(\"locating image %q in local storage: %w\", transports.ImageName(dest), err)\n\t\t}\n\t\tdest = dest2\n\t\timgID = img.ID\n\t\ttoPruneNames := make([]string, 0, len(img.Names))\n\t\tfor _, name := range img.Names {\n\t\t\tif nameToRemove != \"\" && strings.Contains(name, nameToRemove) {\n\t\t\t\ttoPruneNames = append(toPruneNames, name)\n\t\t\t}\n\t\t}\n\t\tif len(toPruneNames) > 0 {\n\t\t\tif err = b.store.RemoveNames(imgID, toPruneNames); err != nil {\n\t\t\t\treturn imgID, nil, \"\", fmt.Errorf(\"failed to remove temporary name from image %q: %w\", imgID, err)\n\t\t\t}\n\t\t\tlogrus.Debugf(\"removing %v from assigned names to image %q\", nameToRemove, img.ID)\n\t\t}\n\t\tif options.IIDFile != \"\" {\n\t\t\tif err = os.WriteFile(options.IIDFile, []byte(\"sha256:\"+img.ID), 0o644); err != nil {\n\t\t\t\treturn imgID, nil, \"\", err\n\t\t\t}\n\t\t}\n\t}\n\t// If we're supposed to store SBOM or PURL information in local files, write them now.\n\tfor filename, content := range extraLocalContent {\n\t\terr := func() error {\n\t\t\toutput, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0o644)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer output.Close()\n\t\t\tinput, err := os.Open(content)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer input.Close()\n\t\t\tif _, err := io.Copy(output, input); err != nil {\n\t\t\t\treturn fmt.Errorf(\"copying from %q to %q: %w\", content, filename, err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}()\n\t\tif err != nil {\n\t\t\treturn imgID, nil, \"\", err\n\t\t}\n\t}\n\n\t// Calculate the as-written digest of the image's manifest and build the digested\n\t// reference for the image.\n\tmanifestDigest, err := manifest.Digest(manifestBytes)\n\tif err != nil {\n\t\treturn imgID, nil, \"\", fmt.Errorf(\"computing digest of manifest of new image %q: %w\", transports.ImageName(dest), err)\n\t}\n\n\tvar ref reference.Canonical\n\tif name := dest.DockerReference(); name != nil {\n\t\tref, err = reference.WithDigest(name, manifestDigest)\n\t\tif err != nil {\n\t\t\tlogrus.Warnf(\"error generating canonical reference with name %q and digest %s: %v\", name, manifestDigest.String(), err)\n\t\t}\n\t}\n\n\tif options.Manifest != \"\" {\n\t\tmanifestID, err := b.addManifest(ctx, options.Manifest, imgID)\n\t\tif err != nil {\n\t\t\treturn imgID, nil, \"\", err\n\t\t}\n\t\tlogrus.Debugf(\"added imgID %s to manifestID %s\", imgID, manifestID)\n\t}\n\treturn imgID, ref, manifestDigest, nil\n}\n"
        },
        {
          "name": "commit_test.go",
          "type": "blob",
          "size": 7.7822265625,
          "content": "package buildah\n\nimport (\n\t\"archive/tar\"\n\t\"context\"\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\timageStorage \"github.com/containers/image/v5/storage\"\n\t\"github.com/containers/storage\"\n\tstorageTypes \"github.com/containers/storage/types\"\n\tv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n\trspec \"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestCommitLinkedLayers(t *testing.T) {\n\tctx := context.TODO()\n\tnow := time.Now()\n\n\tgraphDriverName := os.Getenv(\"STORAGE_DRIVER\")\n\tif graphDriverName == \"\" {\n\t\tgraphDriverName = \"vfs\"\n\t}\n\tstore, err := storage.GetStore(storageTypes.StoreOptions{\n\t\tRunRoot:         t.TempDir(),\n\t\tGraphRoot:       t.TempDir(),\n\t\tGraphDriverName: graphDriverName,\n\t})\n\trequire.NoError(t, err, \"initializing storage\")\n\tt.Cleanup(func() { _, err := store.Shutdown(true); assert.NoError(t, err) })\n\n\timageName := func(i int) string { return fmt.Sprintf(\"image%d\", i) }\n\tmakeFile := func(base string, size int64) string {\n\t\tt.Helper()\n\t\tfn := filepath.Join(t.TempDir(), base)\n\t\tf, err := os.Create(fn)\n\t\trequire.NoError(t, err)\n\t\tdefer f.Close()\n\t\tif size == 0 {\n\t\t\tsize = 512\n\t\t}\n\t\t_, err = io.CopyN(f, rand.Reader, size)\n\t\trequire.NoErrorf(t, err, \"writing payload file %d\", base)\n\t\treturn f.Name()\n\t}\n\tmakeArchive := func(base string, size int64) string {\n\t\tt.Helper()\n\t\tfile := makeFile(base, size)\n\t\tarchiveDir := t.TempDir()\n\t\tst, err := os.Stat(file)\n\t\trequire.NoError(t, err)\n\t\tarchiveName := filepath.Join(archiveDir, filepath.Base(file))\n\t\tf, err := os.Create(archiveName)\n\t\trequire.NoError(t, err)\n\t\tdefer f.Close()\n\t\ttw := tar.NewWriter(f)\n\t\tdefer tw.Close()\n\t\thdr, err := tar.FileInfoHeader(st, \"\")\n\t\trequire.NoErrorf(t, err, \"building tar header for %s\", file)\n\t\terr = tw.WriteHeader(hdr)\n\t\trequire.NoErrorf(t, err, \"writing tar header for %s\", file)\n\t\tf, err = os.Open(file)\n\t\trequire.NoError(t, err)\n\t\tdefer f.Close()\n\t\t_, err = io.Copy(tw, f)\n\t\trequire.NoErrorf(t, err, \"writing tar payload for %s\", file)\n\t\treturn archiveName\n\t}\n\tlayerNumber := 0\n\n\t// Build a from-scratch image with one layer.\n\tbuilderOptions := BuilderOptions{\n\t\tFromImage: \"scratch\",\n\t\tNamespaceOptions: []NamespaceOption{{\n\t\t\tName: string(rspec.NetworkNamespace),\n\t\t\tHost: true,\n\t\t}},\n\t\tSystemContext: &testSystemContext,\n\t}\n\tb, err := NewBuilder(ctx, store, builderOptions)\n\trequire.NoError(t, err, \"creating builder\")\n\tb.SetCreatedBy(imageName(layerNumber))\n\tfirstFile := makeFile(\"file0\", 0)\n\terr = b.Add(\"/\", false, AddAndCopyOptions{}, firstFile)\n\trequire.NoError(t, err, \"adding\", firstFile)\n\tcommitOptions := CommitOptions{\n\t\tSystemContext: &testSystemContext,\n\t}\n\tref, err := imageStorage.Transport.ParseStoreReference(store, imageName(layerNumber))\n\trequire.NoError(t, err, \"parsing reference for to-be-committed image\", imageName(layerNumber))\n\t_, _, _, err = b.Commit(ctx, ref, commitOptions)\n\trequire.NoError(t, err, \"committing\", imageName(layerNumber))\n\n\t// Build another image based on the first with not much in its layer.\n\tbuilderOptions.FromImage = imageName(layerNumber)\n\tlayerNumber++\n\tb, err = NewBuilder(ctx, store, builderOptions)\n\trequire.NoError(t, err, \"creating builder\")\n\tb.SetCreatedBy(imageName(layerNumber))\n\tsecondFile := makeFile(\"file1\", 0)\n\terr = b.Add(\"/\", false, AddAndCopyOptions{}, secondFile)\n\trequire.NoError(t, err, \"adding\", secondFile)\n\tcommitOptions = CommitOptions{\n\t\tSystemContext: &testSystemContext,\n\t}\n\tref, err = imageStorage.Transport.ParseStoreReference(store, imageName(layerNumber))\n\trequire.NoError(t, err, \"parsing reference for to-be-committed image\", imageName(layerNumber))\n\t_, _, _, err = b.Commit(ctx, ref, commitOptions)\n\trequire.NoError(t, err, \"committing\", imageName(layerNumber))\n\n\t// Build a third image with two layers on either side of its read-write layer.\n\tbuilderOptions.FromImage = imageName(layerNumber)\n\tlayerNumber++\n\tb, err = NewBuilder(ctx, store, builderOptions)\n\trequire.NoError(t, err, \"creating builder\")\n\tthirdFile := makeFile(\"file2\", 0)\n\tfourthArchiveFile := makeArchive(\"file3\", 0)\n\tfifthFile := makeFile(\"file4\", 0)\n\tsixthFile := makeFile(\"file5\", 0)\n\tseventhArchiveFile := makeArchive(\"file6\", 0)\n\teighthFile := makeFile(\"file7\", 0)\n\tninthArchiveFile := makeArchive(\"file8\", 0)\n\terr = b.Add(\"/\", false, AddAndCopyOptions{}, sixthFile)\n\trequire.NoError(t, err, \"adding\", sixthFile)\n\tb.SetCreatedBy(imageName(layerNumber + 3))\n\tb.AddPrependedLinkedLayer(nil, imageName(layerNumber), \"\", \"\", filepath.Dir(thirdFile))\n\tcommitOptions = CommitOptions{\n\t\tPrependedLinkedLayers: []LinkedLayer{\n\t\t\t{\n\t\t\t\tBlobPath: fourthArchiveFile,\n\t\t\t\tHistory: v1.History{\n\t\t\t\t\tCreated:   &now,\n\t\t\t\t\tCreatedBy: imageName(layerNumber + 1),\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tBlobPath: filepath.Dir(fifthFile),\n\t\t\t\tHistory: v1.History{\n\t\t\t\t\tCreated:   &now,\n\t\t\t\t\tCreatedBy: imageName(layerNumber + 2),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tAppendedLinkedLayers: []LinkedLayer{\n\t\t\t{\n\t\t\t\tBlobPath: seventhArchiveFile,\n\t\t\t\tHistory: v1.History{\n\t\t\t\t\tCreated:   &now,\n\t\t\t\t\tCreatedBy: imageName(layerNumber + 4),\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tBlobPath: filepath.Dir(eighthFile),\n\t\t\t\tHistory: v1.History{\n\t\t\t\t\tCreated:   &now,\n\t\t\t\t\tCreatedBy: imageName(layerNumber + 5),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tSystemContext: &testSystemContext,\n\t}\n\tb.AddAppendedLinkedLayer(nil, imageName(layerNumber+6), \"\", \"\", ninthArchiveFile)\n\tref, err = imageStorage.Transport.ParseStoreReference(store, imageName(layerNumber))\n\trequire.NoError(t, err, \"parsing reference for to-be-committed image\", imageName(layerNumber))\n\t_, _, _, err = b.Commit(ctx, ref, commitOptions)\n\trequire.NoError(t, err, \"committing\", imageName(layerNumber))\n\n\t// Build one last image based on the previous one.\n\tbuilderOptions.FromImage = imageName(layerNumber)\n\tlayerNumber += 7\n\tb, err = NewBuilder(ctx, store, builderOptions)\n\trequire.NoError(t, err, \"creating builder\")\n\tb.SetCreatedBy(imageName(layerNumber))\n\ttenthFile := makeFile(\"file9\", 0)\n\terr = b.Add(\"/\", false, AddAndCopyOptions{}, tenthFile)\n\trequire.NoError(t, err, \"adding\", tenthFile)\n\tcommitOptions = CommitOptions{\n\t\tSystemContext: &testSystemContext,\n\t}\n\tref, err = imageStorage.Transport.ParseStoreReference(store, imageName(layerNumber))\n\trequire.NoError(t, err, \"parsing reference for to-be-committed image\", imageName(layerNumber))\n\t_, _, _, err = b.Commit(ctx, ref, commitOptions)\n\trequire.NoError(t, err, \"committing\", imageName(layerNumber))\n\n\t// Get set to examine this image.  At this point, each history entry\n\t// should just have \"image%d\" as its CreatedBy field, and each layer\n\t// should have the corresponding file (and nothing else) in it.\n\tsrc, err := ref.NewImageSource(ctx, &testSystemContext)\n\trequire.NoError(t, err, \"opening image source\")\n\tdefer src.Close()\n\timg, err := ref.NewImage(ctx, &testSystemContext)\n\trequire.NoError(t, err, \"opening image\")\n\tdefer img.Close()\n\tconfig, err := img.OCIConfig(ctx)\n\trequire.NoError(t, err, \"reading config in OCI format\")\n\trequire.Len(t, config.History, 10, \"history length\")\n\tfor i := range config.History {\n\t\trequire.Equal(t, fmt.Sprintf(\"image%d\", i), config.History[i].CreatedBy, \"history createdBy is off\")\n\t}\n\trequire.Len(t, config.RootFS.DiffIDs, 10, \"diffID list\")\n\n\tlayerContents := func(archive io.ReadCloser) []string {\n\t\tvar contents []string\n\t\tdefer archive.Close()\n\t\ttr := tar.NewReader(archive)\n\t\tentry, err := tr.Next()\n\t\tfor entry != nil {\n\t\t\tcontents = append(contents, entry.Name)\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tentry, err = tr.Next()\n\t\t}\n\t\trequire.ErrorIs(t, err, io.EOF)\n\t\treturn contents\n\t}\n\tinfos, err := img.LayerInfosForCopy(ctx)\n\trequire.NoError(t, err, \"getting layer infos\")\n\trequire.Len(t, infos, 10)\n\tfor i, blobInfo := range infos {\n\t\tfunc() {\n\t\t\tt.Helper()\n\t\t\trc, _, err := src.GetBlob(ctx, blobInfo, nil)\n\t\t\trequire.NoError(t, err, \"getting blob\", i)\n\t\t\tdefer rc.Close()\n\t\t\tcontents := layerContents(rc)\n\t\t\trequire.Len(t, contents, 1)\n\t\t\trequire.Equal(t, fmt.Sprintf(\"file%d\", i), contents[0])\n\t\t}()\n\t}\n}\n"
        },
        {
          "name": "common.go",
          "type": "blob",
          "size": 3.720703125,
          "content": "package buildah\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"path/filepath\"\n\t\"time\"\n\n\t\"github.com/containers/buildah/define\"\n\t\"github.com/containers/common/pkg/retry\"\n\tcp \"github.com/containers/image/v5/copy\"\n\t\"github.com/containers/image/v5/docker\"\n\t\"github.com/containers/image/v5/signature\"\n\tis \"github.com/containers/image/v5/storage\"\n\t\"github.com/containers/image/v5/types\"\n\tencconfig \"github.com/containers/ocicrypt/config\"\n\t\"github.com/containers/storage\"\n\t\"github.com/containers/storage/pkg/fileutils\"\n\t\"github.com/containers/storage/pkg/unshare\"\n)\n\nconst (\n\t// OCI used to define the \"oci\" image format\n\tOCI = define.OCI\n\t// DOCKER used to define the \"docker\" image format\n\tDOCKER = define.DOCKER\n)\n\nfunc getCopyOptions(store storage.Store, reportWriter io.Writer, sourceSystemContext *types.SystemContext, destinationSystemContext *types.SystemContext, manifestType string, removeSignatures bool, addSigner string, ociEncryptLayers *[]int, ociEncryptConfig *encconfig.EncryptConfig, ociDecryptConfig *encconfig.DecryptConfig) *cp.Options {\n\tsourceCtx := getSystemContext(store, nil, \"\")\n\tif sourceSystemContext != nil {\n\t\t*sourceCtx = *sourceSystemContext\n\t}\n\n\tdestinationCtx := getSystemContext(store, nil, \"\")\n\tif destinationSystemContext != nil {\n\t\t*destinationCtx = *destinationSystemContext\n\t}\n\treturn &cp.Options{\n\t\tReportWriter:          reportWriter,\n\t\tSourceCtx:             sourceCtx,\n\t\tDestinationCtx:        destinationCtx,\n\t\tForceManifestMIMEType: manifestType,\n\t\tRemoveSignatures:      removeSignatures,\n\t\tSignBy:                addSigner,\n\t\tOciEncryptConfig:      ociEncryptConfig,\n\t\tOciDecryptConfig:      ociDecryptConfig,\n\t\tOciEncryptLayers:      ociEncryptLayers,\n\t}\n}\n\nfunc getSystemContext(store storage.Store, defaults *types.SystemContext, signaturePolicyPath string) *types.SystemContext {\n\tsc := &types.SystemContext{}\n\tif defaults != nil {\n\t\t*sc = *defaults\n\t}\n\tif signaturePolicyPath != \"\" {\n\t\tsc.SignaturePolicyPath = signaturePolicyPath\n\t}\n\tif store != nil {\n\t\tif sc.SystemRegistriesConfPath == \"\" && unshare.IsRootless() {\n\t\t\tuserRegistriesFile := filepath.Join(store.GraphRoot(), \"registries.conf\")\n\t\t\tif err := fileutils.Exists(userRegistriesFile); err == nil {\n\t\t\t\tsc.SystemRegistriesConfPath = userRegistriesFile\n\t\t\t}\n\t\t}\n\t}\n\treturn sc\n}\n\nfunc retryCopyImage(ctx context.Context, policyContext *signature.PolicyContext, maybeWrappedDest, maybeWrappedSrc, directDest types.ImageReference, copyOptions *cp.Options, maxRetries int, retryDelay time.Duration) ([]byte, error) {\n\treturn retryCopyImageWithOptions(ctx, policyContext, maybeWrappedDest, maybeWrappedSrc, directDest, copyOptions, maxRetries, retryDelay, true)\n}\n\nfunc retryCopyImageWithOptions(ctx context.Context, policyContext *signature.PolicyContext, maybeWrappedDest, maybeWrappedSrc, directDest types.ImageReference, copyOptions *cp.Options, maxRetries int, retryDelay time.Duration, retryOnLayerUnknown bool) ([]byte, error) {\n\tvar (\n\t\tmanifestBytes []byte\n\t\terr           error\n\t)\n\terr = retry.IfNecessary(ctx, func() error {\n\t\tmanifestBytes, err = cp.Image(ctx, policyContext, maybeWrappedDest, maybeWrappedSrc, copyOptions)\n\t\treturn err\n\t}, &retry.RetryOptions{MaxRetry: maxRetries, Delay: retryDelay, IsErrorRetryable: func(err error) bool {\n\t\tif retryOnLayerUnknown && directDest.Transport().Name() == is.Transport.Name() && errors.Is(err, storage.ErrLayerUnknown) {\n\t\t\t// we were trying to reuse a layer that belonged to an\n\t\t\t// image that was deleted at just the right (worst\n\t\t\t// possible) time? yeah, try again\n\t\t\treturn true\n\t\t}\n\t\tif directDest.Transport().Name() != docker.Transport.Name() {\n\t\t\t// if we're not talking to a registry, then nah\n\t\t\treturn false\n\t\t}\n\t\t// hand it off to the default should-this-be-retried logic\n\t\treturn retry.IsErrorRetryable(err)\n\t}})\n\treturn manifestBytes, err\n}\n"
        },
        {
          "name": "common_test.go",
          "type": "blob",
          "size": 6.3349609375,
          "content": "package buildah\n\nimport (\n\t\"archive/tar\"\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\tcp \"github.com/containers/image/v5/copy\"\n\t\"github.com/containers/image/v5/signature\"\n\timageStorage \"github.com/containers/image/v5/storage\"\n\t\"github.com/containers/image/v5/transports/alltransports\"\n\t\"github.com/containers/storage\"\n\tstorageTypes \"github.com/containers/storage/types\"\n\tdigest \"github.com/opencontainers/go-digest\"\n\tispec \"github.com/opencontainers/image-spec/specs-go\"\n\tv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype testRetryCopyImageWrappedStore struct {\n\tphantomImageID string\n\tstorage.Store\n}\n\nfunc (ts *testRetryCopyImageWrappedStore) CreateImage(id string, names []string, layer, metadata string, options *storage.ImageOptions) (*storage.Image, error) {\n\tif id == ts.phantomImageID {\n\t\tif img, err := ts.Store.Image(id); img != nil && err == nil {\n\t\t\t// i'm another thread somewhere\n\t\t\tif _, err := ts.Store.DeleteImage(id, true); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\treturn ts.Store.CreateImage(id, names, layer, metadata, options)\n}\n\nfunc TestRetryCopyImage(t *testing.T) {\n\tctx := context.TODO()\n\n\tgraphDriverName := os.Getenv(\"STORAGE_DRIVER\")\n\tif graphDriverName == \"\" {\n\t\tgraphDriverName = \"vfs\"\n\t}\n\tstore, err := storage.GetStore(storageTypes.StoreOptions{\n\t\tRunRoot:         t.TempDir(),\n\t\tGraphRoot:       t.TempDir(),\n\t\tGraphDriverName: graphDriverName,\n\t})\n\trequire.NoError(t, err, \"initializing storage\")\n\tt.Cleanup(func() { _, err := store.Shutdown(true); assert.NoError(t, err) })\n\n\t// construct an \"image\" that can be pulled into local storage\n\tvar layerBuffer bytes.Buffer\n\ttw := tar.NewWriter(&layerBuffer)\n\terr = tw.WriteHeader(&tar.Header{\n\t\tName:     \"rootfile\",\n\t\tTypeflag: tar.TypeReg,\n\t\tSize:     1234,\n\t})\n\trequire.NoError(t, err, \"writing header for archive\")\n\t_, err = tw.Write(make([]byte, 1234))\n\trequire.NoError(t, err, \"writing empty file to archive\")\n\trequire.NoError(t, tw.Close(), \"finishing layer\")\n\tlayerDigest := digest.Canonical.FromBytes(layerBuffer.Bytes())\n\timageConfig := v1.Image{\n\t\tRootFS: v1.RootFS{\n\t\t\tType:    \"layers\",\n\t\t\tDiffIDs: []digest.Digest{layerDigest},\n\t\t},\n\t}\n\timageConfigBytes, err := json.Marshal(&imageConfig)\n\trequire.NoError(t, err, \"marshalling image configuration blob\")\n\timageConfigDigest := digest.Canonical.FromBytes(imageConfigBytes)\n\timageManifest := v1.Manifest{\n\t\tVersioned: ispec.Versioned{\n\t\t\tSchemaVersion: 2,\n\t\t},\n\t\tMediaType: v1.MediaTypeImageManifest,\n\t\tConfig: v1.Descriptor{\n\t\t\tMediaType: v1.MediaTypeImageConfig,\n\t\t\tSize:      int64(len(imageConfigBytes)),\n\t\t\tDigest:    digest.FromBytes(imageConfigBytes),\n\t\t},\n\t\tLayers: []v1.Descriptor{\n\t\t\t{\n\t\t\t\tMediaType: v1.MediaTypeImageLayer,\n\t\t\t\tSize:      int64(layerBuffer.Len()),\n\t\t\t\tDigest:    layerDigest,\n\t\t\t},\n\t\t},\n\t}\n\timageManifestBytes, err := json.Marshal(&imageManifest)\n\trequire.NoError(t, err, \"marshalling image manifest\")\n\timageManifestDigest := digest.Canonical.FromBytes(imageManifestBytes)\n\n\t// write it to an oci layout\n\tociDir := t.TempDir()\n\tblobbyDir := filepath.Join(ociDir, \"blobs\")\n\trequire.NoError(t, os.Mkdir(blobbyDir, 0o700))\n\tblobDir := filepath.Join(blobbyDir, layerDigest.Algorithm().String())\n\trequire.NoError(t, os.Mkdir(blobDir, 0o700))\n\trequire.NoError(t, os.WriteFile(filepath.Join(blobDir, layerDigest.Encoded()), layerBuffer.Bytes(), 0o600), \"writing layer\")\n\trequire.NoError(t, os.WriteFile(filepath.Join(blobDir, imageConfigDigest.Encoded()), imageConfigBytes, 0o600), \"writing image config\")\n\trequire.NoError(t, os.WriteFile(filepath.Join(blobDir, imageManifestDigest.Encoded()), imageManifestBytes, 0o600), \"writing manifest\")\n\timageIndex := v1.Index{\n\t\tVersioned: ispec.Versioned{\n\t\t\tSchemaVersion: 2,\n\t\t},\n\t\tMediaType: v1.MediaTypeImageIndex,\n\t\tManifests: []v1.Descriptor{\n\t\t\t{\n\t\t\t\tMediaType: v1.MediaTypeImageManifest,\n\t\t\t\tDigest:    imageManifestDigest,\n\t\t\t\tSize:      int64(len(imageManifestBytes)),\n\t\t\t},\n\t\t},\n\t}\n\timageIndexBytes, err := json.Marshal(&imageIndex)\n\trequire.NoError(t, err, \"marshalling image index\")\n\trequire.NoError(t, os.WriteFile(filepath.Join(ociDir, v1.ImageIndexFile), imageIndexBytes, 0o600), \"writing image index\")\n\timageLayout := v1.ImageLayout{\n\t\tVersion: v1.ImageLayoutVersion,\n\t}\n\timageLayoutBytes, err := json.Marshal(&imageLayout)\n\trequire.NoError(t, err, \"marshalling image layout\")\n\trequire.NoError(t, os.WriteFile(filepath.Join(ociDir, v1.ImageLayoutFile), imageLayoutBytes, 0o600), \"writing image layout\")\n\n\t// pull the image, twice, just to make sure nothing weird happens\n\tsrcRef, err := alltransports.ParseImageName(\"oci:\" + ociDir)\n\trequire.NoError(t, err, \"building reference to image layout\")\n\tdestRef, err := imageStorage.Transport.NewStoreReference(store, nil, imageConfigDigest.Encoded())\n\trequire.NoError(t, err, \"building reference to image in store\")\n\tpolicy, err := signature.NewPolicyFromFile(\"tests/policy.json\")\n\trequire.NoError(t, err, \"reading signature policy\")\n\tpolicyContext, err := signature.NewPolicyContext(policy)\n\trequire.NoError(t, err, \"building policy context\")\n\tt.Cleanup(func() {\n\t\trequire.NoError(t, policyContext.Destroy(), \"destroying policy context\")\n\t})\n\t_, err = retryCopyImage(ctx, policyContext, destRef, srcRef, destRef, &cp.Options{}, 3, 1*time.Second)\n\trequire.NoError(t, err, \"copying image\")\n\t_, err = retryCopyImage(ctx, policyContext, destRef, srcRef, destRef, &cp.Options{}, 3, 1*time.Second)\n\trequire.NoError(t, err, \"copying image\")\n\n\t// now make something weird happen\n\twrappedStore := &testRetryCopyImageWrappedStore{\n\t\tphantomImageID: imageConfigDigest.Encoded(),\n\t\tStore:          store,\n\t}\n\twrappedDestRef, err := imageStorage.Transport.NewStoreReference(wrappedStore, nil, imageConfigDigest.Encoded())\n\trequire.NoError(t, err, \"building wrapped reference\")\n\n\t// copy with retry-on-storage-layer-unknown = false: expect an error\n\t// (if it succeeds, either the test is broken, or we can remove this\n\t// case from the retry function)\n\t_, err = retryCopyImageWithOptions(ctx, policyContext, wrappedDestRef, srcRef, wrappedDestRef, &cp.Options{}, 3, 1*time.Second, false)\n\trequire.ErrorIs(t, err, storage.ErrLayerUnknown, \"copying image\")\n\n\t// copy with retry-on-storage-layer-unknown = true: expect no error\n\t_, err = retryCopyImageWithOptions(ctx, policyContext, wrappedDestRef, srcRef, wrappedDestRef, &cp.Options{}, 3, 1*time.Second, true)\n\trequire.NoError(t, err, \"copying image\")\n}\n"
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 28.7001953125,
          "content": "package buildah\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/containers/buildah/define\"\n\t\"github.com/containers/buildah/docker\"\n\tinternalUtil \"github.com/containers/buildah/internal/util\"\n\t\"github.com/containers/image/v5/manifest\"\n\t\"github.com/containers/image/v5/pkg/compression\"\n\t\"github.com/containers/image/v5/transports\"\n\t\"github.com/containers/image/v5/types\"\n\t\"github.com/containers/storage/pkg/stringid\"\n\tociv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/exp/maps\"\n\t\"golang.org/x/exp/slices\"\n)\n\n// unmarshalConvertedConfig obtains the config blob of img valid for the wantedManifestMIMEType format\n// (either as it exists, or converting the image if necessary), and unmarshals it into dest.\n// NOTE: The MIME type is of the _manifest_, not of the _config_ that is returned.\nfunc unmarshalConvertedConfig(ctx context.Context, dest interface{}, img types.Image, wantedManifestMIMEType string) error {\n\t_, actualManifestMIMEType, err := img.Manifest(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"getting manifest MIME type for %q: %w\", transports.ImageName(img.Reference()), err)\n\t}\n\tif wantedManifestMIMEType != actualManifestMIMEType {\n\t\tlayerInfos := img.LayerInfos()\n\t\tfor i := range layerInfos { // force the \"compression\" to gzip, which is supported by all of the formats we care about\n\t\t\tlayerInfos[i].CompressionOperation = types.Compress\n\t\t\tlayerInfos[i].CompressionAlgorithm = &compression.Gzip\n\t\t}\n\t\tupdatedImg, err := img.UpdatedImage(ctx, types.ManifestUpdateOptions{\n\t\t\tLayerInfos: layerInfos,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"resetting recorded compression for %q: %w\", transports.ImageName(img.Reference()), err)\n\t\t}\n\t\tsecondUpdatedImg, err := updatedImg.UpdatedImage(ctx, types.ManifestUpdateOptions{\n\t\t\tManifestMIMEType: wantedManifestMIMEType,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"converting image %q from %q to %q: %w\", transports.ImageName(img.Reference()), actualManifestMIMEType, wantedManifestMIMEType, err)\n\t\t}\n\t\timg = secondUpdatedImg\n\t}\n\tconfig, err := img.ConfigBlob(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"reading %s config from %q: %w\", wantedManifestMIMEType, transports.ImageName(img.Reference()), err)\n\t}\n\tif err := json.Unmarshal(config, dest); err != nil {\n\t\treturn fmt.Errorf(\"parsing %s configuration %q from %q: %w\", wantedManifestMIMEType, string(config), transports.ImageName(img.Reference()), err)\n\t}\n\treturn nil\n}\n\nfunc (b *Builder) initConfig(ctx context.Context, sys *types.SystemContext, img types.Image, options *BuilderOptions) error {\n\tif img != nil { // A pre-existing image, as opposed to a \"FROM scratch\" new one.\n\t\trawManifest, manifestMIMEType, err := img.Manifest(ctx)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading image manifest for %q: %w\", transports.ImageName(img.Reference()), err)\n\t\t}\n\t\trawConfig, err := img.ConfigBlob(ctx)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading image configuration for %q: %w\", transports.ImageName(img.Reference()), err)\n\t\t}\n\t\tb.Manifest = rawManifest\n\t\tb.Config = rawConfig\n\n\t\tdimage := docker.V2Image{}\n\t\tif err := unmarshalConvertedConfig(ctx, &dimage, img, manifest.DockerV2Schema2MediaType); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tb.Docker = dimage\n\n\t\toimage := ociv1.Image{}\n\t\tif err := unmarshalConvertedConfig(ctx, &oimage, img, ociv1.MediaTypeImageManifest); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tb.OCIv1 = oimage\n\n\t\tif manifestMIMEType == ociv1.MediaTypeImageManifest {\n\t\t\t// Attempt to recover format-specific data from the manifest.\n\t\t\tv1Manifest := ociv1.Manifest{}\n\t\t\tif err := json.Unmarshal(b.Manifest, &v1Manifest); err != nil {\n\t\t\t\treturn fmt.Errorf(\"parsing OCI manifest %q: %w\", string(b.Manifest), err)\n\t\t\t}\n\t\t\tif len(v1Manifest.Annotations) > 0 {\n\t\t\t\tif b.ImageAnnotations == nil {\n\t\t\t\t\tb.ImageAnnotations = make(map[string]string, len(v1Manifest.Annotations))\n\t\t\t\t}\n\t\t\t\tfor k, v := range v1Manifest.Annotations {\n\t\t\t\t\tb.ImageAnnotations[k] = v\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif options == nil || options.CompatScratchConfig != types.OptionalBoolTrue {\n\t\t\tb.Docker = docker.V2Image{\n\t\t\t\tV1Image: docker.V1Image{\n\t\t\t\t\tConfig: &docker.Config{\n\t\t\t\t\t\tWorkingDir: \"/\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\tb.OCIv1 = ociv1.Image{\n\t\t\t\tConfig: ociv1.ImageConfig{\n\t\t\t\t\tWorkingDir: \"/\",\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tb.setupLogger()\n\tb.fixupConfig(sys)\n\treturn nil\n}\n\nfunc (b *Builder) fixupConfig(sys *types.SystemContext) {\n\tif b.Docker.Config != nil {\n\t\t// Prefer image-level settings over those from the container it was built from.\n\t\tb.Docker.ContainerConfig = *b.Docker.Config\n\t}\n\tb.Docker.Config = &b.Docker.ContainerConfig\n\tb.Docker.DockerVersion = \"\"\n\tnow := time.Now().UTC()\n\tif b.Docker.Created.IsZero() {\n\t\tb.Docker.Created = now\n\t}\n\tif b.OCIv1.Created == nil || b.OCIv1.Created.IsZero() {\n\t\tb.OCIv1.Created = &now\n\t}\n\tif b.OS() == \"\" {\n\t\tif sys != nil && sys.OSChoice != \"\" {\n\t\t\tb.SetOS(sys.OSChoice)\n\t\t} else {\n\t\t\tb.SetOS(runtime.GOOS)\n\t\t}\n\t}\n\tif b.Architecture() == \"\" {\n\t\tif sys != nil && sys.ArchitectureChoice != \"\" {\n\t\t\tb.SetArchitecture(sys.ArchitectureChoice)\n\t\t} else {\n\t\t\tb.SetArchitecture(runtime.GOARCH)\n\t\t}\n\t\t// in case the arch string we started with was shorthand for a known arch+variant pair, normalize it\n\t\tps := internalUtil.NormalizePlatform(ociv1.Platform{OS: b.OS(), Architecture: b.Architecture(), Variant: b.Variant()})\n\t\tb.SetArchitecture(ps.Architecture)\n\t\tb.SetVariant(ps.Variant)\n\t}\n\tif b.Variant() == \"\" {\n\t\tif sys != nil && sys.VariantChoice != \"\" {\n\t\t\tb.SetVariant(sys.VariantChoice)\n\t\t}\n\t\t// in case the arch string we started with was shorthand for a known arch+variant pair, normalize it\n\t\tps := internalUtil.NormalizePlatform(ociv1.Platform{OS: b.OS(), Architecture: b.Architecture(), Variant: b.Variant()})\n\t\tb.SetArchitecture(ps.Architecture)\n\t\tb.SetVariant(ps.Variant)\n\t}\n\tif b.Format == define.Dockerv2ImageManifest && b.Hostname() == \"\" {\n\t\tb.SetHostname(stringid.TruncateID(stringid.GenerateRandomID()))\n\t}\n}\n\nfunc (b *Builder) setupLogger() {\n\tif b.Logger == nil {\n\t\tb.Logger = logrus.New()\n\t\tb.Logger.SetOutput(os.Stderr)\n\t\tb.Logger.SetLevel(logrus.GetLevel())\n\t}\n}\n\n// Annotations returns a set of key-value pairs from the image's manifest.\nfunc (b *Builder) Annotations() map[string]string {\n\treturn maps.Clone(b.ImageAnnotations)\n}\n\n// SetAnnotation adds or overwrites a key's value from the image's manifest.\n// Note: this setting is not present in the Docker v2 image format, so it is\n// discarded when writing images using Docker v2 formats.\nfunc (b *Builder) SetAnnotation(key, value string) {\n\tif b.ImageAnnotations == nil {\n\t\tb.ImageAnnotations = map[string]string{}\n\t}\n\tb.ImageAnnotations[key] = value\n}\n\n// UnsetAnnotation removes a key and its value from the image's manifest, if\n// it's present.\nfunc (b *Builder) UnsetAnnotation(key string) {\n\tdelete(b.ImageAnnotations, key)\n}\n\n// ClearAnnotations removes all keys and their values from the image's\n// manifest.\nfunc (b *Builder) ClearAnnotations() {\n\tb.ImageAnnotations = nil\n}\n\n// CreatedBy returns a description of how this image was built.\nfunc (b *Builder) CreatedBy() string {\n\treturn b.ImageCreatedBy\n}\n\n// SetCreatedBy sets the description of how this image was built.\nfunc (b *Builder) SetCreatedBy(how string) {\n\tb.ImageCreatedBy = how\n}\n\n// OS returns a name of the OS on which the container, or a container built\n// using an image built from this container, is intended to be run.\nfunc (b *Builder) OS() string {\n\treturn b.OCIv1.OS\n}\n\n// SetOS sets the name of the OS on which the container, or a container built\n// using an image built from this container, is intended to be run.\nfunc (b *Builder) SetOS(os string) {\n\tb.OCIv1.OS = os\n\tb.Docker.OS = os\n}\n\n// OSVersion returns a version of the OS on which the container, or a container\n// built using an image built from this container, is intended to be run.\nfunc (b *Builder) OSVersion() string {\n\treturn b.OCIv1.OSVersion\n}\n\n// SetOSVersion sets the version of the OS on which the container, or a\n// container built using an image built from this container, is intended to be\n// run.\nfunc (b *Builder) SetOSVersion(version string) {\n\tb.OCIv1.OSVersion = version\n\tb.Docker.OSVersion = version\n}\n\n// OSFeatures returns a list of OS features which the container, or a container\n// built using an image built from this container, depends on the OS supplying.\nfunc (b *Builder) OSFeatures() []string {\n\treturn slices.Clone(b.OCIv1.OSFeatures)\n}\n\n// SetOSFeature adds a feature of the OS which the container, or a container\n// built using an image built from this container, depends on the OS supplying.\nfunc (b *Builder) SetOSFeature(feature string) {\n\tif !slices.Contains(b.OCIv1.OSFeatures, feature) {\n\t\tb.OCIv1.OSFeatures = append(b.OCIv1.OSFeatures, feature)\n\t}\n\tif !slices.Contains(b.Docker.OSFeatures, feature) {\n\t\tb.Docker.OSFeatures = append(b.Docker.OSFeatures, feature)\n\t}\n}\n\n// UnsetOSFeature removes a feature of the OS which the container, or a\n// container built using an image built from this container, depends on the OS\n// supplying.\nfunc (b *Builder) UnsetOSFeature(feature string) {\n\tif slices.Contains(b.OCIv1.OSFeatures, feature) {\n\t\tfeatures := make([]string, 0, len(b.OCIv1.OSFeatures))\n\t\tfor _, f := range b.OCIv1.OSFeatures {\n\t\t\tif f != feature {\n\t\t\t\tfeatures = append(features, f)\n\t\t\t}\n\t\t}\n\t\tb.OCIv1.OSFeatures = features\n\t}\n\tif slices.Contains(b.Docker.OSFeatures, feature) {\n\t\tfeatures := make([]string, 0, len(b.Docker.OSFeatures))\n\t\tfor _, f := range b.Docker.OSFeatures {\n\t\t\tif f != feature {\n\t\t\t\tfeatures = append(features, f)\n\t\t\t}\n\t\t}\n\t\tb.Docker.OSFeatures = features\n\t}\n}\n\n// ClearOSFeatures clears the list of features of the OS which the container,\n// or a container built using an image built from this container, depends on\n// the OS supplying.\nfunc (b *Builder) ClearOSFeatures() {\n\tb.OCIv1.OSFeatures = []string{}\n\tb.Docker.OSFeatures = []string{}\n}\n\n// Architecture returns a name of the architecture on which the container, or a\n// container built using an image built from this container, is intended to be\n// run.\nfunc (b *Builder) Architecture() string {\n\treturn b.OCIv1.Architecture\n}\n\n// SetArchitecture sets the name of the architecture on which the container, or\n// a container built using an image built from this container, is intended to\n// be run.\nfunc (b *Builder) SetArchitecture(arch string) {\n\tb.OCIv1.Architecture = arch\n\tb.Docker.Architecture = arch\n}\n\n// Variant returns a name of the architecture variant on which the container,\n// or a container built using an image built from this container, is intended\n// to be run.\nfunc (b *Builder) Variant() string {\n\treturn b.OCIv1.Variant\n}\n\n// SetVariant sets the name of the architecture variant on which the container,\n// or a container built using an image built from this container, is intended\n// to be run.\nfunc (b *Builder) SetVariant(variant string) {\n\tb.Docker.Variant = variant\n\tb.OCIv1.Variant = variant\n}\n\n// Maintainer returns contact information for the person who built the image.\nfunc (b *Builder) Maintainer() string {\n\treturn b.OCIv1.Author\n}\n\n// SetMaintainer sets contact information for the person who built the image.\nfunc (b *Builder) SetMaintainer(who string) {\n\tb.OCIv1.Author = who\n\tb.Docker.Author = who\n}\n\n// User returns information about the user as whom the container, or a\n// container built using an image built from this container, should be run.\nfunc (b *Builder) User() string {\n\treturn b.OCIv1.Config.User\n}\n\n// SetUser sets information about the user as whom the container, or a\n// container built using an image built from this container, should be run.\n// Acceptable forms are a user name or ID, optionally followed by a colon and a\n// group name or ID.\nfunc (b *Builder) SetUser(spec string) {\n\tb.OCIv1.Config.User = spec\n\tb.Docker.Config.User = spec\n}\n\n// OnBuild returns the OnBuild value from the container.\nfunc (b *Builder) OnBuild() []string {\n\treturn slices.Clone(b.Docker.Config.OnBuild)\n}\n\n// ClearOnBuild removes all values from the OnBuild structure\nfunc (b *Builder) ClearOnBuild() {\n\tb.Docker.Config.OnBuild = []string{}\n}\n\n// SetOnBuild sets a trigger instruction to be executed when the image is used\n// as the base of another image.\n// Note: this setting is not present in the OCIv1 image format, so it is\n// discarded when writing images using OCIv1 formats.\nfunc (b *Builder) SetOnBuild(onBuild string) {\n\tif onBuild != \"\" && b.Format != define.Dockerv2ImageManifest {\n\t\tb.Logger.Warnf(\"ONBUILD is not supported for OCI image format, %s will be ignored. Must use `docker` format\", onBuild)\n\t}\n\tb.Docker.Config.OnBuild = append(b.Docker.Config.OnBuild, onBuild)\n}\n\n// WorkDir returns the default working directory for running commands in the\n// container, or in a container built using an image built from this container.\nfunc (b *Builder) WorkDir() string {\n\treturn b.OCIv1.Config.WorkingDir\n}\n\n// SetWorkDir sets the location of the default working directory for running\n// commands in the container, or in a container built using an image built from\n// this container.\nfunc (b *Builder) SetWorkDir(there string) {\n\tb.OCIv1.Config.WorkingDir = there\n\tb.Docker.Config.WorkingDir = there\n}\n\n// Shell returns the default shell for running commands in the\n// container, or in a container built using an image built from this container.\nfunc (b *Builder) Shell() []string {\n\treturn slices.Clone(b.Docker.Config.Shell)\n}\n\n// SetShell sets the default shell for running\n// commands in the container, or in a container built using an image built from\n// this container.\n// Note: this setting is not present in the OCIv1 image format, so it is\n// discarded when writing images using OCIv1 formats.\nfunc (b *Builder) SetShell(shell []string) {\n\tif len(shell) > 0 && b.Format != define.Dockerv2ImageManifest {\n\t\tb.Logger.Warnf(\"SHELL is not supported for OCI image format, %s will be ignored. Must use `docker` format\", shell)\n\t}\n\n\tb.Docker.Config.Shell = slices.Clone(shell)\n}\n\n// Env returns a list of key-value pairs to be set when running commands in the\n// container, or in a container built using an image built from this container.\nfunc (b *Builder) Env() []string {\n\treturn slices.Clone(b.OCIv1.Config.Env)\n}\n\n// SetEnv adds or overwrites a value to the set of environment strings which\n// should be set when running commands in the container, or in a container\n// built using an image built from this container.\nfunc (b *Builder) SetEnv(k string, v string) {\n\treset := func(s *[]string) {\n\t\tn := []string{}\n\t\tfor i := range *s {\n\t\t\tif !strings.HasPrefix((*s)[i], k+\"=\") {\n\t\t\t\tn = append(n, (*s)[i])\n\t\t\t}\n\t\t}\n\t\tn = append(n, k+\"=\"+v)\n\t\t*s = n\n\t}\n\treset(&b.OCIv1.Config.Env)\n\treset(&b.Docker.Config.Env)\n}\n\n// UnsetEnv removes a value from the set of environment strings which should be\n// set when running commands in this container, or in a container built using\n// an image built from this container.\nfunc (b *Builder) UnsetEnv(k string) {\n\tunset := func(s *[]string) {\n\t\tn := []string{}\n\t\tfor i := range *s {\n\t\t\tif !strings.HasPrefix((*s)[i], k+\"=\") {\n\t\t\t\tn = append(n, (*s)[i])\n\t\t\t}\n\t\t}\n\t\t*s = n\n\t}\n\tunset(&b.OCIv1.Config.Env)\n\tunset(&b.Docker.Config.Env)\n}\n\n// ClearEnv removes all values from the set of environment strings which should\n// be set when running commands in this container, or in a container built\n// using an image built from this container.\nfunc (b *Builder) ClearEnv() {\n\tb.OCIv1.Config.Env = []string{}\n\tb.Docker.Config.Env = []string{}\n}\n\n// Cmd returns the default command, or command parameters if an Entrypoint is\n// set, to use when running a container built from an image built from this\n// container.\nfunc (b *Builder) Cmd() []string {\n\treturn slices.Clone(b.OCIv1.Config.Cmd)\n}\n\n// SetCmd sets the default command, or command parameters if an Entrypoint is\n// set, to use when running a container built from an image built from this\n// container.\nfunc (b *Builder) SetCmd(cmd []string) {\n\tb.OCIv1.Config.Cmd = slices.Clone(cmd)\n\tb.Docker.Config.Cmd = slices.Clone(cmd)\n}\n\n// Entrypoint returns the command to be run for containers built from images\n// built from this container.\nfunc (b *Builder) Entrypoint() []string {\n\tif len(b.OCIv1.Config.Entrypoint) > 0 {\n\t\treturn slices.Clone(b.OCIv1.Config.Entrypoint)\n\t}\n\treturn nil\n}\n\n// SetEntrypoint sets the command to be run for in containers built from images\n// built from this container.\nfunc (b *Builder) SetEntrypoint(ep []string) {\n\tb.OCIv1.Config.Entrypoint = slices.Clone(ep)\n\tb.Docker.Config.Entrypoint = slices.Clone(ep)\n}\n\n// Labels returns a set of key-value pairs from the image's runtime\n// configuration.\nfunc (b *Builder) Labels() map[string]string {\n\treturn maps.Clone(b.OCIv1.Config.Labels)\n}\n\n// SetLabel adds or overwrites a key's value from the image's runtime\n// configuration.\nfunc (b *Builder) SetLabel(k string, v string) {\n\tif b.OCIv1.Config.Labels == nil {\n\t\tb.OCIv1.Config.Labels = map[string]string{}\n\t}\n\tb.OCIv1.Config.Labels[k] = v\n\tif b.Docker.Config.Labels == nil {\n\t\tb.Docker.Config.Labels = map[string]string{}\n\t}\n\tb.Docker.Config.Labels[k] = v\n}\n\n// UnsetLabel removes a key and its value from the image's runtime\n// configuration, if it's present.\nfunc (b *Builder) UnsetLabel(k string) {\n\tdelete(b.OCIv1.Config.Labels, k)\n\tdelete(b.Docker.Config.Labels, k)\n}\n\n// ClearLabels removes all keys and their values from the image's runtime\n// configuration.\nfunc (b *Builder) ClearLabels() {\n\tb.OCIv1.Config.Labels = map[string]string{}\n\tb.Docker.Config.Labels = map[string]string{}\n}\n\n// Ports returns the set of ports which should be exposed when a container\n// based on an image built from this container is run.\nfunc (b *Builder) Ports() []string {\n\tp := []string{}\n\tfor k := range b.OCIv1.Config.ExposedPorts {\n\t\tp = append(p, k)\n\t}\n\treturn p\n}\n\n// SetPort adds or overwrites an exported port in the set of ports which should\n// be exposed when a container based on an image built from this container is\n// run.\nfunc (b *Builder) SetPort(p string) {\n\tif b.OCIv1.Config.ExposedPorts == nil {\n\t\tb.OCIv1.Config.ExposedPorts = map[string]struct{}{}\n\t}\n\tb.OCIv1.Config.ExposedPorts[p] = struct{}{}\n\tif b.Docker.Config.ExposedPorts == nil {\n\t\tb.Docker.Config.ExposedPorts = make(docker.PortSet)\n\t}\n\tb.Docker.Config.ExposedPorts[docker.Port(p)] = struct{}{}\n}\n\n// UnsetPort removes an exposed port from the set of ports which should be\n// exposed when a container based on an image built from this container is run.\nfunc (b *Builder) UnsetPort(p string) {\n\tdelete(b.OCIv1.Config.ExposedPorts, p)\n\tdelete(b.Docker.Config.ExposedPorts, docker.Port(p))\n}\n\n// ClearPorts empties the set of ports which should be exposed when a container\n// based on an image built from this container is run.\nfunc (b *Builder) ClearPorts() {\n\tb.OCIv1.Config.ExposedPorts = map[string]struct{}{}\n\tb.Docker.Config.ExposedPorts = docker.PortSet{}\n}\n\n// Volumes returns a list of filesystem locations which should be mounted from\n// outside of the container when a container built from an image built from\n// this container is run.\nfunc (b *Builder) Volumes() []string {\n\tv := []string{}\n\tfor k := range b.OCIv1.Config.Volumes {\n\t\tv = append(v, k)\n\t}\n\tif len(v) > 0 {\n\t\treturn v\n\t}\n\treturn nil\n}\n\n// CheckVolume returns True if the location exists in the image's list of locations\n// which should be mounted from outside of the container when a container\n// based on an image built from this container is run\n\nfunc (b *Builder) CheckVolume(v string) bool {\n\t_, OCIv1Volume := b.OCIv1.Config.Volumes[v]\n\t_, DockerVolume := b.Docker.Config.Volumes[v]\n\treturn OCIv1Volume || DockerVolume\n}\n\n// AddVolume adds a location to the image's list of locations which should be\n// mounted from outside of the container when a container based on an image\n// built from this container is run.\nfunc (b *Builder) AddVolume(v string) {\n\tif b.OCIv1.Config.Volumes == nil {\n\t\tb.OCIv1.Config.Volumes = map[string]struct{}{}\n\t}\n\tb.OCIv1.Config.Volumes[v] = struct{}{}\n\tif b.Docker.Config.Volumes == nil {\n\t\tb.Docker.Config.Volumes = map[string]struct{}{}\n\t}\n\tb.Docker.Config.Volumes[v] = struct{}{}\n}\n\n// RemoveVolume removes a location from the list of locations which should be\n// mounted from outside of the container when a container based on an image\n// built from this container is run.\nfunc (b *Builder) RemoveVolume(v string) {\n\tdelete(b.OCIv1.Config.Volumes, v)\n\tdelete(b.Docker.Config.Volumes, v)\n}\n\n// ClearVolumes removes all locations from the image's list of locations which\n// should be mounted from outside of the container when a container based on an\n// image built from this container is run.\nfunc (b *Builder) ClearVolumes() {\n\tb.OCIv1.Config.Volumes = map[string]struct{}{}\n\tb.Docker.Config.Volumes = map[string]struct{}{}\n}\n\n// Hostname returns the hostname which will be set in the container and in\n// containers built using images built from the container.\nfunc (b *Builder) Hostname() string {\n\treturn b.Docker.Config.Hostname\n}\n\n// SetHostname sets the hostname which will be set in the container and in\n// containers built using images built from the container.\n// Note: this setting is not present in the OCIv1 image format, so it is\n// discarded when writing images using OCIv1 formats.\nfunc (b *Builder) SetHostname(name string) {\n\tb.Docker.Config.Hostname = name\n}\n\n// Domainname returns the domainname which will be set in the container and in\n// containers built using images built from the container.\nfunc (b *Builder) Domainname() string {\n\treturn b.Docker.Config.Domainname\n}\n\n// SetDomainname sets the domainname which will be set in the container and in\n// containers built using images built from the container.\n// Note: this setting is not present in the OCIv1 image format, so it is\n// discarded when writing images using OCIv1 formats.\nfunc (b *Builder) SetDomainname(name string) {\n\tif name != \"\" && b.Format != define.Dockerv2ImageManifest {\n\t\tb.Logger.Warnf(\"DOMAINNAME is not supported for OCI image format, domainname %s will be ignored. Must use `docker` format\", name)\n\t}\n\tb.Docker.Config.Domainname = name\n}\n\n// SetDefaultMountsFilePath sets the mounts file path for testing purposes\nfunc (b *Builder) SetDefaultMountsFilePath(path string) {\n\tb.DefaultMountsFilePath = path\n}\n\n// Comment returns the comment which will be set in the container and in\n// containers built using images built from the container\nfunc (b *Builder) Comment() string {\n\treturn b.Docker.Comment\n}\n\n// SetComment sets the comment which will be set in the container and in\n// containers built using images built from the container.\n// Note: this setting is not present in the OCIv1 image format, so it is\n// discarded when writing images using OCIv1 formats.\nfunc (b *Builder) SetComment(comment string) {\n\tif comment != \"\" && b.Format != define.Dockerv2ImageManifest {\n\t\tlogrus.Warnf(\"COMMENT is not supported for OCI image format, comment %s will be ignored. Must use `docker` format\", comment)\n\t}\n\tb.Docker.Comment = comment\n}\n\n// HistoryComment returns the comment which will be used in the history item\n// which will describe the latest layer when we commit an image.\nfunc (b *Builder) HistoryComment() string {\n\treturn b.ImageHistoryComment\n}\n\n// SetHistoryComment sets the comment which will be used in the history item\n// which will describe the latest layer when we commit an image.\nfunc (b *Builder) SetHistoryComment(comment string) {\n\tb.ImageHistoryComment = comment\n}\n\n// StopSignal returns the signal which will be set in the container and in\n// containers built using images built from the container\nfunc (b *Builder) StopSignal() string {\n\treturn b.Docker.Config.StopSignal\n}\n\n// SetStopSignal sets the signal which will be set in the container and in\n// containers built using images built from the container.\nfunc (b *Builder) SetStopSignal(stopSignal string) {\n\tb.OCIv1.Config.StopSignal = stopSignal\n\tb.Docker.Config.StopSignal = stopSignal\n}\n\n// Healthcheck returns information that recommends how a container engine\n// should check if a running container is \"healthy\".\nfunc (b *Builder) Healthcheck() *docker.HealthConfig {\n\tif b.Docker.Config.Healthcheck == nil {\n\t\treturn nil\n\t}\n\treturn &docker.HealthConfig{\n\t\tTest:          slices.Clone(b.Docker.Config.Healthcheck.Test),\n\t\tInterval:      b.Docker.Config.Healthcheck.Interval,\n\t\tTimeout:       b.Docker.Config.Healthcheck.Timeout,\n\t\tStartPeriod:   b.Docker.Config.Healthcheck.StartPeriod,\n\t\tStartInterval: b.Docker.Config.Healthcheck.StartInterval,\n\t\tRetries:       b.Docker.Config.Healthcheck.Retries,\n\t}\n}\n\n// SetHealthcheck sets recommended commands to run in order to verify that a\n// running container based on this image is \"healthy\", along with information\n// specifying how often that test should be run, and how many times the test\n// should fail before the container should be considered unhealthy.\n// Note: this setting is not present in the OCIv1 image format, so it is\n// discarded when writing images using OCIv1 formats.\nfunc (b *Builder) SetHealthcheck(config *docker.HealthConfig) {\n\tb.Docker.Config.Healthcheck = nil\n\tif config != nil {\n\t\tif b.Format != define.Dockerv2ImageManifest {\n\t\t\tb.Logger.Warnf(\"HEALTHCHECK is not supported for OCI image format and will be ignored. Must use `docker` format\")\n\t\t}\n\t\tb.Docker.Config.Healthcheck = &docker.HealthConfig{\n\t\t\tTest:          slices.Clone(config.Test),\n\t\t\tInterval:      config.Interval,\n\t\t\tTimeout:       config.Timeout,\n\t\t\tStartPeriod:   config.StartPeriod,\n\t\t\tStartInterval: config.StartInterval,\n\t\t\tRetries:       config.Retries,\n\t\t}\n\t}\n}\n\n// AddPrependedEmptyLayer adds an item to the history that we'll create when\n// committing the image, after any history we inherit from the base image, but\n// before the history item that we'll use to describe the new layer that we're\n// adding.\nfunc (b *Builder) AddPrependedEmptyLayer(created *time.Time, createdBy, author, comment string) {\n\tif created != nil {\n\t\tcopiedTimestamp := *created\n\t\tcreated = &copiedTimestamp\n\t}\n\tb.PrependedEmptyLayers = append(b.PrependedEmptyLayers, ociv1.History{\n\t\tCreated:    created,\n\t\tCreatedBy:  createdBy,\n\t\tAuthor:     author,\n\t\tComment:    comment,\n\t\tEmptyLayer: true,\n\t})\n}\n\n// ClearPrependedEmptyLayers clears the list of history entries that we'll add\n// to the committed image before the entry for the layer that we're adding.\nfunc (b *Builder) ClearPrependedEmptyLayers() {\n\tb.PrependedEmptyLayers = nil\n}\n\n// AddAppendedEmptyLayer adds an item to the history that we'll create when\n// committing the image, after the history item that we'll use to describe the\n// new layer that we're adding.\nfunc (b *Builder) AddAppendedEmptyLayer(created *time.Time, createdBy, author, comment string) {\n\tif created != nil {\n\t\tcopiedTimestamp := *created\n\t\tcreated = &copiedTimestamp\n\t}\n\tb.AppendedEmptyLayers = append(b.AppendedEmptyLayers, ociv1.History{\n\t\tCreated:    created,\n\t\tCreatedBy:  createdBy,\n\t\tAuthor:     author,\n\t\tComment:    comment,\n\t\tEmptyLayer: true,\n\t})\n}\n\n// ClearAppendedEmptyLayers clears the list of history entries that we'll add\n// to the committed image after the entry for the layer that we're adding.\nfunc (b *Builder) ClearAppendedEmptyLayers() {\n\tb.AppendedEmptyLayers = nil\n}\n\n// AddPrependedLinkedLayer adds an item to the history that we'll create when\n// committing the image, optionally with a layer, after any history we inherit\n// from the base image, but before the history item that we'll use to describe\n// the new layer that we're adding.\n// The blobPath can be either the location of an uncompressed archive, or a\n// directory whose contents will be archived to use as a layer blob.  Leaving\n// blobPath empty is functionally similar to calling AddPrependedEmptyLayer().\nfunc (b *Builder) AddPrependedLinkedLayer(created *time.Time, createdBy, author, comment, blobPath string) {\n\tif created != nil {\n\t\tcopiedTimestamp := *created\n\t\tcreated = &copiedTimestamp\n\t}\n\tb.PrependedLinkedLayers = append(b.PrependedLinkedLayers, LinkedLayer{\n\t\tBlobPath: blobPath,\n\t\tHistory: ociv1.History{\n\t\t\tCreated:    created,\n\t\t\tCreatedBy:  createdBy,\n\t\t\tAuthor:     author,\n\t\t\tComment:    comment,\n\t\t\tEmptyLayer: blobPath == \"\",\n\t\t},\n\t})\n}\n\n// ClearPrependedLinkedLayers clears the list of history entries that we'll add\n// the committed image before the layer that we're adding (if we're adding it).\nfunc (b *Builder) ClearPrependedLinkedLayers() {\n\tb.PrependedLinkedLayers = nil\n}\n\n// AddAppendedLinkedLayer adds an item to the history that we'll create when\n// committing the image, optionally with a layer, after the history item that\n// we'll use to describe the new layer that we're adding.\n// The blobPath can be either the location of an uncompressed archive, or a\n// directory whose contents will be archived to use as a layer blob.  Leaving\n// blobPath empty is functionally similar to calling AddAppendedEmptyLayer().\nfunc (b *Builder) AddAppendedLinkedLayer(created *time.Time, createdBy, author, comment, blobPath string) {\n\tif created != nil {\n\t\tcopiedTimestamp := *created\n\t\tcreated = &copiedTimestamp\n\t}\n\tb.AppendedLinkedLayers = append(b.AppendedLinkedLayers, LinkedLayer{\n\t\tBlobPath: blobPath,\n\t\tHistory: ociv1.History{\n\t\t\tCreated:    created,\n\t\t\tCreatedBy:  createdBy,\n\t\t\tAuthor:     author,\n\t\t\tComment:    comment,\n\t\t\tEmptyLayer: blobPath == \"\",\n\t\t},\n\t})\n}\n\n// ClearAppendedLinkedLayers clears the list of linked layers that we'll add to\n// the committed image after the layer that we're adding (if we're adding it).\nfunc (b *Builder) ClearAppendedLinkedLayers() {\n\tb.AppendedLinkedLayers = nil\n}\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "convertcw.go",
          "type": "blob",
          "size": 7.640625,
          "content": "package buildah\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"time\"\n\n\t\"github.com/containers/buildah/define\"\n\t\"github.com/containers/buildah/internal/mkcw\"\n\t\"github.com/containers/image/v5/docker/reference\"\n\t\"github.com/containers/image/v5/types\"\n\tencconfig \"github.com/containers/ocicrypt/config\"\n\t\"github.com/containers/storage\"\n\t\"github.com/containers/storage/pkg/archive\"\n\t\"github.com/opencontainers/go-digest\"\n\t\"github.com/sirupsen/logrus\"\n)\n\n// CWConvertImageOptions provides both required and optional bits of\n// configuration for CWConvertImage().\ntype CWConvertImageOptions struct {\n\t// Required parameters.\n\tInputImage string\n\n\t// If supplied, we'll tag the resulting image with the specified name.\n\tTag         string\n\tOutputImage types.ImageReference\n\n\t// If supplied, we'll register the workload with this server.\n\t// Practically necessary if DiskEncryptionPassphrase is not set, in\n\t// which case we'll generate one and throw it away after.\n\tAttestationURL string\n\n\t// Used to measure the environment.  If left unset (0), defaults will be applied.\n\tCPUs   int\n\tMemory int\n\n\t// Can be manually set.  If left unset (\"\", false, nil), reasonable values will be used.\n\tTeeType                  define.TeeType\n\tIgnoreAttestationErrors  bool\n\tWorkloadID               string\n\tDiskEncryptionPassphrase string\n\tSlop                     string\n\tFirmwareLibrary          string\n\tBaseImage                string\n\tLogger                   *logrus.Logger\n\tExtraImageContent        map[string]string\n\n\t// Passed through to BuilderOptions. Most settings won't make\n\t// sense to be made available here because we don't launch a process.\n\tContainerSuffix     string\n\tPullPolicy          PullPolicy\n\tBlobDirectory       string\n\tSignaturePolicyPath string\n\tReportWriter        io.Writer\n\tIDMappingOptions    *IDMappingOptions\n\tFormat              string\n\tMaxPullRetries      int\n\tPullRetryDelay      time.Duration\n\tOciDecryptConfig    *encconfig.DecryptConfig\n\tMountLabel          string\n}\n\n// CWConvertImage takes the rootfs and configuration from one image, generates a\n// LUKS-encrypted disk image that more or less includes them both, and puts the\n// result into a new container image.\n// Returns the new image's ID and digest on success, along with a canonical\n// reference for it if a repository name was specified.\nfunc CWConvertImage(ctx context.Context, systemContext *types.SystemContext, store storage.Store, options CWConvertImageOptions) (string, reference.Canonical, digest.Digest, error) {\n\t// Apply our defaults if some options aren't set.\n\tlogger := options.Logger\n\tif logger == nil {\n\t\tlogger = logrus.StandardLogger()\n\t}\n\n\t// Now create the target working container, pulling the base image if\n\t// there is one and it isn't present.\n\tbuilderOptions := BuilderOptions{\n\t\tFromImage:     options.BaseImage,\n\t\tSystemContext: systemContext,\n\t\tLogger:        logger,\n\n\t\tContainerSuffix:     options.ContainerSuffix,\n\t\tPullPolicy:          options.PullPolicy,\n\t\tBlobDirectory:       options.BlobDirectory,\n\t\tSignaturePolicyPath: options.SignaturePolicyPath,\n\t\tReportWriter:        options.ReportWriter,\n\t\tIDMappingOptions:    options.IDMappingOptions,\n\t\tFormat:              options.Format,\n\t\tMaxPullRetries:      options.MaxPullRetries,\n\t\tPullRetryDelay:      options.PullRetryDelay,\n\t\tOciDecryptConfig:    options.OciDecryptConfig,\n\t\tMountLabel:          options.MountLabel,\n\t}\n\ttarget, err := NewBuilder(ctx, store, builderOptions)\n\tif err != nil {\n\t\treturn \"\", nil, \"\", fmt.Errorf(\"creating container from target image: %w\", err)\n\t}\n\tdefer func() {\n\t\tif err := target.Delete(); err != nil {\n\t\t\tlogrus.Warnf(\"deleting target container: %v\", err)\n\t\t}\n\t}()\n\ttargetDir, err := target.Mount(\"\")\n\tif err != nil {\n\t\treturn \"\", nil, \"\", fmt.Errorf(\"mounting target container: %w\", err)\n\t}\n\tdefer func() {\n\t\tif err := target.Unmount(); err != nil {\n\t\t\tlogrus.Warnf(\"unmounting target container: %v\", err)\n\t\t}\n\t}()\n\n\t// Mount the source image, pulling it first if necessary.\n\tbuilderOptions = BuilderOptions{\n\t\tFromImage:     options.InputImage,\n\t\tSystemContext: systemContext,\n\t\tLogger:        logger,\n\n\t\tContainerSuffix:     options.ContainerSuffix,\n\t\tPullPolicy:          options.PullPolicy,\n\t\tBlobDirectory:       options.BlobDirectory,\n\t\tSignaturePolicyPath: options.SignaturePolicyPath,\n\t\tReportWriter:        options.ReportWriter,\n\t\tIDMappingOptions:    options.IDMappingOptions,\n\t\tFormat:              options.Format,\n\t\tMaxPullRetries:      options.MaxPullRetries,\n\t\tPullRetryDelay:      options.PullRetryDelay,\n\t\tOciDecryptConfig:    options.OciDecryptConfig,\n\t\tMountLabel:          options.MountLabel,\n\t}\n\tsource, err := NewBuilder(ctx, store, builderOptions)\n\tif err != nil {\n\t\treturn \"\", nil, \"\", fmt.Errorf(\"creating container from source image: %w\", err)\n\t}\n\tdefer func() {\n\t\tif err := source.Delete(); err != nil {\n\t\t\tlogrus.Warnf(\"deleting source container: %v\", err)\n\t\t}\n\t}()\n\tsourceInfo := GetBuildInfo(source)\n\tif err != nil {\n\t\treturn \"\", nil, \"\", fmt.Errorf(\"retrieving info about source image: %w\", err)\n\t}\n\tsourceImageID := sourceInfo.FromImageID\n\tsourceSize, err := store.ImageSize(sourceImageID)\n\tif err != nil {\n\t\treturn \"\", nil, \"\", fmt.Errorf(\"computing size of source image: %w\", err)\n\t}\n\tsourceDir, err := source.Mount(\"\")\n\tif err != nil {\n\t\treturn \"\", nil, \"\", fmt.Errorf(\"mounting source container: %w\", err)\n\t}\n\tdefer func() {\n\t\tif err := source.Unmount(); err != nil {\n\t\t\tlogrus.Warnf(\"unmounting source container: %v\", err)\n\t\t}\n\t}()\n\n\t// Generate the image contents.\n\tarchiveOptions := mkcw.ArchiveOptions{\n\t\tAttestationURL:           options.AttestationURL,\n\t\tCPUs:                     options.CPUs,\n\t\tMemory:                   options.Memory,\n\t\tTempDir:                  targetDir,\n\t\tTeeType:                  options.TeeType,\n\t\tIgnoreAttestationErrors:  options.IgnoreAttestationErrors,\n\t\tImageSize:                sourceSize,\n\t\tWorkloadID:               options.WorkloadID,\n\t\tDiskEncryptionPassphrase: options.DiskEncryptionPassphrase,\n\t\tSlop:                     options.Slop,\n\t\tFirmwareLibrary:          options.FirmwareLibrary,\n\t\tLogger:                   logger,\n\t\tGraphOptions:             store.GraphOptions(),\n\t\tExtraImageContent:        options.ExtraImageContent,\n\t}\n\trc, workloadConfig, err := mkcw.Archive(sourceDir, &source.OCIv1, archiveOptions)\n\tif err != nil {\n\t\treturn \"\", nil, \"\", fmt.Errorf(\"generating encrypted image content: %w\", err)\n\t}\n\tif err = archive.Untar(rc, targetDir, &archive.TarOptions{}); err != nil {\n\t\tif err = rc.Close(); err != nil {\n\t\t\tlogger.Warnf(\"cleaning up: %v\", err)\n\t\t}\n\t\treturn \"\", nil, \"\", fmt.Errorf(\"saving encrypted image content: %w\", err)\n\t}\n\tif err = rc.Close(); err != nil {\n\t\treturn \"\", nil, \"\", fmt.Errorf(\"cleaning up: %w\", err)\n\t}\n\n\t// Commit the image.  Clear out most of the configuration (if there is any — we default\n\t// to scratch as a base) so that an engine that doesn't or can't set up a TEE will just\n\t// run the static entrypoint.  The rest of the configuration which the runtime consults\n\t// is in the .krun_config.json file in the encrypted filesystem.\n\tlogger.Log(logrus.DebugLevel, \"committing disk image\")\n\ttarget.ClearAnnotations()\n\ttarget.ClearEnv()\n\ttarget.ClearLabels()\n\ttarget.ClearOnBuild()\n\ttarget.ClearPorts()\n\ttarget.ClearVolumes()\n\ttarget.SetCmd(nil)\n\ttarget.SetCreatedBy(fmt.Sprintf(\": convert %q for use with %q\", sourceImageID, workloadConfig.Type))\n\ttarget.SetDomainname(\"\")\n\ttarget.SetEntrypoint([]string{\"/entrypoint\"})\n\ttarget.SetHealthcheck(nil)\n\ttarget.SetHostname(\"\")\n\ttarget.SetMaintainer(\"\")\n\ttarget.SetShell(nil)\n\ttarget.SetUser(\"\")\n\ttarget.SetWorkDir(\"\")\n\tcommitOptions := CommitOptions{\n\t\tSystemContext: systemContext,\n\t}\n\tif options.Tag != \"\" {\n\t\tcommitOptions.AdditionalTags = append(commitOptions.AdditionalTags, options.Tag)\n\t}\n\treturn target.Commit(ctx, options.OutputImage, commitOptions)\n}\n"
        },
        {
          "name": "convertcw_test.go",
          "type": "blob",
          "size": 5.376953125,
          "content": "package buildah\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/containers/buildah/internal/mkcw\"\n\tmkcwtypes \"github.com/containers/buildah/internal/mkcw/types\"\n\t\"github.com/containers/storage\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\n// dummyAttestationHandler replies with a fixed response code to requests to\n// the right path, and caches passphrases indexed by workload ID\ntype dummyAttestationHandler struct {\n\tt               *testing.T\n\tstatus          int\n\tpassphrases     map[string]string\n\tpassphrasesLock sync.Mutex\n}\n\nfunc (d *dummyAttestationHandler) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tvar body bytes.Buffer\n\tif req.Body != nil {\n\t\tif _, err := io.Copy(&body, req.Body); err != nil {\n\t\t\td.t.Logf(\"reading request body: %v\", err)\n\t\t\treturn\n\t\t}\n\t\treq.Body.Close()\n\t}\n\tif req.URL != nil && req.URL.Path == \"/kbs/v0/register_workload\" {\n\t\tvar registrationRequest mkcwtypes.RegistrationRequest\n\t\t// if we can't decode the client request, bail\n\t\tif err := json.Unmarshal(body.Bytes(), &registrationRequest); err != nil {\n\t\t\trw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\t// cache the passphrase\n\t\td.passphrasesLock.Lock()\n\t\tif d.passphrases == nil {\n\t\t\td.passphrases = make(map[string]string)\n\t\t}\n\t\td.passphrases[registrationRequest.WorkloadID] = registrationRequest.Passphrase\n\t\td.passphrasesLock.Unlock()\n\t\t// return the predetermined status\n\t\tstatus := d.status\n\t\tif status == 0 {\n\t\t\tstatus = http.StatusOK\n\t\t}\n\t\trw.WriteHeader(status)\n\t\treturn\n\t}\n\t// no such handler\n\trw.WriteHeader(http.StatusInternalServerError)\n}\n\nfunc TestCWConvertImage(t *testing.T) {\n\tctx := context.TODO()\n\tfor _, status := range []int{http.StatusOK, http.StatusInternalServerError} {\n\t\tfor _, ignoreChainRetrievalErrors := range []bool{false, true} {\n\t\t\tfor _, ignoreAttestationErrors := range []bool{false, true} {\n\t\t\t\tt.Run(fmt.Sprintf(\"status~%d~ignoreChainRetrievalErrors~%v~ignoreAttestationErrors~%v\", status, ignoreChainRetrievalErrors, ignoreAttestationErrors), func(t *testing.T) {\n\t\t\t\t\t// create a per-test Store object\n\t\t\t\t\tstoreOptions := storage.StoreOptions{\n\t\t\t\t\t\tGraphRoot:       t.TempDir(),\n\t\t\t\t\t\tRunRoot:         t.TempDir(),\n\t\t\t\t\t\tGraphDriverName: \"vfs\",\n\t\t\t\t\t}\n\t\t\t\t\tstore, err := storage.GetStore(storeOptions)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tt.Cleanup(func() {\n\t\t\t\t\t\tif _, err := store.Shutdown(true); err != nil {\n\t\t\t\t\t\t\tt.Logf(\"store.Shutdown(%q): %v\", t.Name(), err)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t// listen on a system-assigned port\n\t\t\t\t\tlistener, err := net.Listen(\"tcp\", \":0\")\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\t// keep track of our listener address\n\t\t\t\t\taddr := listener.Addr()\n\t\t\t\t\t// serve requests on that listener\n\t\t\t\t\thandler := &dummyAttestationHandler{t: t, status: status}\n\t\t\t\t\tserver := http.Server{\n\t\t\t\t\t\tHandler: handler,\n\t\t\t\t\t}\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tif err := server.Serve(listener); err != nil && !errors.Is(err, http.ErrServerClosed) {\n\t\t\t\t\t\t\tt.Logf(\"serve: %v\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}()\n\t\t\t\t\t// clean up at the end of this test\n\t\t\t\t\tt.Cleanup(func() { assert.NoError(t, server.Close()) })\n\t\t\t\t\t// convert an image\n\t\t\t\t\toptions := CWConvertImageOptions{\n\t\t\t\t\t\tInputImage:              \"docker.io/library/busybox\",\n\t\t\t\t\t\tTag:                     \"localhost/busybox:encrypted\",\n\t\t\t\t\t\tAttestationURL:          \"http://\" + addr.String(),\n\t\t\t\t\t\tIgnoreAttestationErrors: ignoreAttestationErrors,\n\t\t\t\t\t\tSlop:                    \"16MB\",\n\t\t\t\t\t\tSignaturePolicyPath:     testSystemContext.SignaturePolicyPath,\n\t\t\t\t\t}\n\t\t\t\t\tid, _, _, err := CWConvertImage(ctx, &testSystemContext, store, options)\n\t\t\t\t\tif status != http.StatusOK && !ignoreAttestationErrors {\n\t\t\t\t\t\tassert.Error(t, err)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif ignoreChainRetrievalErrors && ignoreAttestationErrors {\n\t\t\t\t\t\tassert.NoError(t, err)\n\t\t\t\t\t}\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Skipf(\"%s: %v\", t.Name(), err)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\t// mount the image\n\t\t\t\t\tpath, err := store.MountImage(id, nil, \"\")\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tt.Cleanup(func() {\n\t\t\t\t\t\tif _, err := store.UnmountImage(id, true); err != nil {\n\t\t\t\t\t\t\tt.Logf(\"store.UnmountImage(%q): %v\", t.Name(), err)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t// check that the image's contents look like what we expect: disk\n\t\t\t\t\tdisk := filepath.Join(path, \"disk.img\")\n\t\t\t\t\trequire.FileExists(t, disk)\n\t\t\t\t\tworkloadConfig, err := mkcw.ReadWorkloadConfigFromImage(disk)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\thandler.passphrasesLock.Lock()\n\t\t\t\t\tdecryptionPassphrase := handler.passphrases[workloadConfig.WorkloadID]\n\t\t\t\t\thandler.passphrasesLock.Unlock()\n\t\t\t\t\terr = mkcw.CheckLUKSPassphrase(disk, decryptionPassphrase)\n\t\t\t\t\tassert.NoError(t, err)\n\t\t\t\t\t// check that the image's contents look like what we expect: config file\n\t\t\t\t\tconfig := filepath.Join(path, \"krun-sev.json\")\n\t\t\t\t\trequire.FileExists(t, config)\n\t\t\t\t\tworkloadConfigBytes, err := os.ReadFile(config)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tvar workloadConfigTwo mkcwtypes.WorkloadConfig\n\t\t\t\t\terr = json.Unmarshal(workloadConfigBytes, &workloadConfigTwo)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tassert.Equal(t, workloadConfig, workloadConfigTwo)\n\t\t\t\t\t// check that the image's contents look like what we expect: an executable entry point\n\t\t\t\t\tentrypoint := filepath.Join(path, \"entrypoint\")\n\t\t\t\t\trequire.FileExists(t, entrypoint)\n\t\t\t\t\tst, err := os.Stat(entrypoint)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tassert.Equal(t, st.Mode().Type(), os.FileMode(0)) // regular file\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "copier",
          "type": "tree",
          "content": null
        },
        {
          "name": "define",
          "type": "tree",
          "content": null
        },
        {
          "name": "delete.go",
          "type": "blob",
          "size": 0.3896484375,
          "content": "package buildah\n\nimport \"fmt\"\n\n// Delete removes the working container.  The buildah.Builder object should not\n// be used after this method is called.\nfunc (b *Builder) Delete() error {\n\tif err := b.store.DeleteContainer(b.ContainerID); err != nil {\n\t\treturn fmt.Errorf(\"deleting build container %q: %w\", b.ContainerID, err)\n\t}\n\tb.MountPoint = \"\"\n\tb.Container = \"\"\n\tb.ContainerID = \"\"\n\treturn nil\n}\n"
        },
        {
          "name": "demos",
          "type": "tree",
          "content": null
        },
        {
          "name": "developmentplan.md",
          "type": "blob",
          "size": 0.9130859375,
          "content": "![buildah logo](https://cdn.rawgit.com/containers/buildah/main/logos/buildah-logo_large.png)\n\n# Development Plan\n\n## Development goals for Buildah\n\n *  Integration into Kubernetes and potentially other tools.  The biggest requirement for this is to be able run Buildah within a standard linux container without SYS_ADMIN privileges.  This would allow Buildah to run non-privileged containers inside of Kubernetes, so you could distribute your container workloads.\n\n * Integration with User Namespace, Podman has this already and the goal is to get `buildah build` and `buildah run` to be able to run its containers in a usernamespace to give the builder better security isolation from the host.\n\n * Buildah `buildah build` command's goal is to have feature parity with other OCI image and container build systems.\n\n * Addressing issues from the community as reported in the [Issues](https://github.com/containers/buildah/issues) page.\n"
        },
        {
          "name": "digester.go",
          "type": "blob",
          "size": 6.615234375,
          "content": "package buildah\n\nimport (\n\t\"archive/tar\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n\t\"sync\"\n\t\"time\"\n\n\tdigest \"github.com/opencontainers/go-digest\"\n)\n\ntype digester interface {\n\tio.WriteCloser\n\tContentType() string\n\tDigest() digest.Digest\n}\n\n// A simple digester just digests its content as-is.\ntype simpleDigester struct {\n\tdigester    digest.Digester\n\thasher      hash.Hash\n\tcontentType string\n}\n\nfunc newSimpleDigester(contentType string) digester {\n\tfinalDigester := digest.Canonical.Digester()\n\treturn &simpleDigester{\n\t\tdigester:    finalDigester,\n\t\thasher:      finalDigester.Hash(),\n\t\tcontentType: contentType,\n\t}\n}\n\nfunc (s *simpleDigester) ContentType() string {\n\treturn s.contentType\n}\n\nfunc (s *simpleDigester) Write(p []byte) (int, error) {\n\treturn s.hasher.Write(p)\n}\n\nfunc (s *simpleDigester) Close() error {\n\treturn nil\n}\n\nfunc (s *simpleDigester) Digest() digest.Digest {\n\treturn s.digester.Digest()\n}\n\n// A tarFilterer passes a tarball through to an io.WriteCloser, potentially\n// modifying headers as it goes.\ntype tarFilterer struct {\n\twg         sync.WaitGroup\n\tpipeWriter *io.PipeWriter\n\tclosedLock sync.Mutex\n\tclosed     bool\n\terr        error\n}\n\nfunc (t *tarFilterer) Write(p []byte) (int, error) {\n\treturn t.pipeWriter.Write(p)\n}\n\nfunc (t *tarFilterer) Close() error {\n\tt.closedLock.Lock()\n\tif t.closed {\n\t\tt.closedLock.Unlock()\n\t\treturn errors.New(\"tar filter is already closed\")\n\t}\n\tt.closed = true\n\tt.closedLock.Unlock()\n\terr := t.pipeWriter.Close()\n\tt.wg.Wait()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"closing filter pipe: %w\", err)\n\t}\n\treturn t.err\n}\n\n// newTarFilterer passes one or more tar archives through to an io.WriteCloser\n// as a single archive, potentially calling filter to modify headers and\n// contents as it goes.\n//\n// Note: if \"filter\" indicates that a given item should be skipped, there is no\n// guarantee that there will not be a subsequent item of type TypeLink, which\n// is a hard link, which points to the skipped item as the link target.\nfunc newTarFilterer(writeCloser io.WriteCloser, filter func(hdr *tar.Header) (skip, replaceContents bool, replacementContents io.Reader)) io.WriteCloser {\n\tpipeReader, pipeWriter := io.Pipe()\n\ttarWriter := tar.NewWriter(writeCloser)\n\tfilterer := &tarFilterer{\n\t\tpipeWriter: pipeWriter,\n\t}\n\tfilterer.wg.Add(1)\n\tgo func() {\n\t\tfilterer.closedLock.Lock()\n\t\tclosed := filterer.closed\n\t\tfilterer.closedLock.Unlock()\n\t\tfor !closed {\n\t\t\ttarReader := tar.NewReader(pipeReader)\n\t\t\thdr, err := tarReader.Next()\n\t\t\tfor err == nil {\n\t\t\t\tvar skip, replaceContents bool\n\t\t\t\tvar replacementContents io.Reader\n\t\t\t\tif filter != nil {\n\t\t\t\t\tskip, replaceContents, replacementContents = filter(hdr)\n\t\t\t\t}\n\t\t\t\tif !skip {\n\t\t\t\t\terr = tarWriter.WriteHeader(hdr)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\terr = fmt.Errorf(\"filtering tar header for %q: %w\", hdr.Name, err)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tif hdr.Size != 0 {\n\t\t\t\t\t\tvar n int64\n\t\t\t\t\t\tvar copyErr error\n\t\t\t\t\t\tif replaceContents {\n\t\t\t\t\t\t\tn, copyErr = io.CopyN(tarWriter, replacementContents, hdr.Size)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tn, copyErr = io.Copy(tarWriter, tarReader)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif copyErr != nil {\n\t\t\t\t\t\t\terr = fmt.Errorf(\"copying content for %q: %w\", hdr.Name, copyErr)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif n != hdr.Size {\n\t\t\t\t\t\t\terr = fmt.Errorf(\"filtering content for %q: expected %d bytes, got %d bytes\", hdr.Name, hdr.Size, n)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\thdr, err = tarReader.Next()\n\t\t\t}\n\t\t\tif err != io.EOF {\n\t\t\t\tfilterer.err = fmt.Errorf(\"reading tar archive: %w\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfilterer.closedLock.Lock()\n\t\t\tclosed = filterer.closed\n\t\t\tfilterer.closedLock.Unlock()\n\t\t}\n\t\terr1 := tarWriter.Close()\n\t\terr := writeCloser.Close()\n\t\tif err == nil {\n\t\t\terr = err1\n\t\t}\n\t\tpipeReader.CloseWithError(err)\n\t\tfilterer.wg.Done()\n\t}()\n\treturn filterer\n}\n\n// A tar digester digests an archive, modifying the headers it digests by\n// calling a specified function to potentially modify the header that it's\n// about to write.\ntype tarDigester struct {\n\tisOpen      bool\n\tnested      digester\n\ttarFilterer io.WriteCloser\n}\n\nfunc modifyTarHeaderForDigesting(hdr *tar.Header) (skip, replaceContents bool, replacementContents io.Reader) {\n\tzeroTime := time.Time{}\n\thdr.ModTime = zeroTime\n\thdr.AccessTime = zeroTime\n\thdr.ChangeTime = zeroTime\n\treturn false, false, nil\n}\n\nfunc newTarDigester(contentType string) digester {\n\tnested := newSimpleDigester(contentType)\n\tdigester := &tarDigester{\n\t\tisOpen:      true,\n\t\tnested:      nested,\n\t\ttarFilterer: newTarFilterer(nested, modifyTarHeaderForDigesting),\n\t}\n\treturn digester\n}\n\nfunc (t *tarDigester) ContentType() string {\n\treturn t.nested.ContentType()\n}\n\nfunc (t *tarDigester) Digest() digest.Digest {\n\treturn t.nested.Digest()\n}\n\nfunc (t *tarDigester) Write(p []byte) (int, error) {\n\treturn t.tarFilterer.Write(p)\n}\n\nfunc (t *tarDigester) Close() error {\n\tif t.isOpen {\n\t\tt.isOpen = false\n\t\treturn t.tarFilterer.Close()\n\t}\n\treturn nil\n}\n\n// CompositeDigester can compute a digest over multiple items.\ntype CompositeDigester struct {\n\tdigesters []digester\n\tcloser    io.Closer\n}\n\n// closeOpenDigester closes an open sub-digester, if we have one.\nfunc (c *CompositeDigester) closeOpenDigester() {\n\tif c.closer != nil {\n\t\tc.closer.Close()\n\t\tc.closer = nil\n\t}\n}\n\n// Restart clears all state, so that the composite digester can start over.\nfunc (c *CompositeDigester) Restart() {\n\tc.closeOpenDigester()\n\tc.digesters = nil\n}\n\n// Start starts recording the digest for a new item (\"\", \"file\", or \"dir\").\n// The caller should call Hash() immediately after to retrieve the new\n// io.WriteCloser.\nfunc (c *CompositeDigester) Start(contentType string) {\n\tc.closeOpenDigester()\n\tswitch contentType {\n\tcase \"\":\n\t\tc.digesters = append(c.digesters, newSimpleDigester(\"\"))\n\tcase \"file\", \"dir\":\n\t\tdigester := newTarDigester(contentType)\n\t\tc.closer = digester\n\t\tc.digesters = append(c.digesters, digester)\n\tdefault:\n\t\tpanic(fmt.Sprintf(`unrecognized content type: expected \"\", \"file\", or \"dir\", got %q`, contentType))\n\t}\n}\n\n// Hash returns the hasher for the current item.\nfunc (c *CompositeDigester) Hash() io.WriteCloser {\n\tnum := len(c.digesters)\n\tif num == 0 {\n\t\treturn nil\n\t}\n\treturn c.digesters[num-1]\n}\n\n// Digest returns the content type and a composite digest over everything\n// that's been digested.\nfunc (c *CompositeDigester) Digest() (string, digest.Digest) {\n\tc.closeOpenDigester()\n\tnum := len(c.digesters)\n\tswitch num {\n\tcase 0:\n\t\treturn \"\", \"\"\n\tcase 1:\n\t\treturn c.digesters[0].ContentType(), c.digesters[0].Digest()\n\tdefault:\n\t\tcontent := \"\"\n\t\tfor i, digester := range c.digesters {\n\t\t\tif i > 0 {\n\t\t\t\tcontent += \",\"\n\t\t\t}\n\t\t\tcontentType := digester.ContentType()\n\t\t\tif contentType != \"\" {\n\t\t\t\tcontentType += \":\"\n\t\t\t}\n\t\t\tcontent += contentType + digester.Digest().Encoded()\n\t\t}\n\t\treturn \"multi\", digest.Canonical.FromString(content)\n\t}\n}\n"
        },
        {
          "name": "digester_test.go",
          "type": "blob",
          "size": 9.0166015625,
          "content": "package buildah\n\nimport (\n\t\"archive/tar\"\n\t\"bytes\"\n\t\"io\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\tdigest \"github.com/opencontainers/go-digest\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (c *CompositeDigester) isOpen() bool {\n\tfor _, digester := range c.digesters {\n\t\tif tarDigester, ok := digester.(*tarDigester); ok {\n\t\t\tif tarDigester.isOpen {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc TestCompositeDigester(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\titemTypes  []string\n\t\tresultType string\n\t}{\n\t\t{\n\t\t\tname:       \"download\",\n\t\t\titemTypes:  []string{\"\"},\n\t\t\tresultType: \"\",\n\t\t},\n\t\t{\n\t\t\tname:       \"file\",\n\t\t\titemTypes:  []string{\"file\"},\n\t\t\tresultType: \"file\",\n\t\t},\n\t\t{\n\t\t\tname:       \"dir\",\n\t\t\titemTypes:  []string{\"dir\"},\n\t\t\tresultType: \"dir\",\n\t\t},\n\t\t{\n\t\t\tname:       \"multiple-1\",\n\t\t\titemTypes:  []string{\"file\", \"dir\"},\n\t\t\tresultType: \"multi\",\n\t\t},\n\t\t{\n\t\t\tname:       \"multiple-2\",\n\t\t\titemTypes:  []string{\"dir\", \"file\"},\n\t\t\tresultType: \"multi\",\n\t\t},\n\t\t{\n\t\t\tname:       \"multiple-3\",\n\t\t\titemTypes:  []string{\"\", \"dir\"},\n\t\t\tresultType: \"multi\",\n\t\t},\n\t\t{\n\t\t\tname:       \"multiple-4\",\n\t\t\titemTypes:  []string{\"\", \"file\"},\n\t\t\tresultType: \"multi\",\n\t\t},\n\t\t{\n\t\t\tname:       \"multiple-5\",\n\t\t\titemTypes:  []string{\"dir\", \"\"},\n\t\t\tresultType: \"multi\",\n\t\t},\n\t\t{\n\t\t\tname:       \"multiple-6\",\n\t\t\titemTypes:  []string{\"file\", \"\"},\n\t\t\tresultType: \"multi\",\n\t\t},\n\t}\n\tvar digester CompositeDigester\n\tvar i int\n\tvar buf bytes.Buffer\n\tzero := time.Unix(0, 0)\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tfor _, filtered := range []bool{false, true} {\n\t\t\t\tdesc := \"unfiltered\"\n\t\t\t\tif filtered {\n\t\t\t\t\tdesc = \"filter\"\n\t\t\t\t}\n\t\t\t\tt.Run(desc, func(t *testing.T) {\n\t\t\t\t\tif i > 0 {\n\t\t\t\t\t\t// restart only after it's been used some, to make sure it's not necessary otherwise\n\t\t\t\t\t\tdigester.Restart()\n\t\t\t\t\t}\n\t\t\t\t\ti++\n\t\t\t\t\tsize := int64(i * 32) // items for this archive will be bigger than the last one\n\t\t\t\t\tfor _, itemType := range test.itemTypes {\n\t\t\t\t\t\tfor int64(buf.Len()) < size {\n\t\t\t\t\t\t\terr := buf.WriteByte(byte(buf.Len() % 256))\n\t\t\t\t\t\t\trequire.Nil(t, err, \"error padding content buffer: %v\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// feed it content that it will treat either as raw data (\"\") or expect to\n\t\t\t\t\t\t// look like a tarball (\"file\"/\"dir\")\n\t\t\t\t\t\tdigester.Start(itemType)\n\t\t\t\t\t\thasher := digester.Hash() // returns an io.WriteCloser\n\t\t\t\t\t\trequire.NotNil(t, hasher, \"digester returned a null hasher?\")\n\t\t\t\t\t\tif itemType == \"\" {\n\t\t\t\t\t\t\t// write something that isn't an archive\n\t\t\t\t\t\t\tn, err := io.Copy(hasher, &buf)\n\t\t\t\t\t\t\trequire.Nil(t, err, \"error writing tar content to digester: %v\", err)\n\t\t\t\t\t\t\trequire.Equal(t, size, n, \"short write writing tar content to digester\")\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// write an archive\n\t\t\t\t\t\tvar written bytes.Buffer // a copy of the archive we're generating and digesting\n\t\t\t\t\t\thasher = &struct {\n\t\t\t\t\t\t\tio.Writer\n\t\t\t\t\t\t\tio.Closer\n\t\t\t\t\t\t}{\n\t\t\t\t\t\t\tWriter: io.MultiWriter(hasher, &written), // splice into the writer\n\t\t\t\t\t\t\tCloser: hasher,\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif filtered {\n\t\t\t\t\t\t\t// wrap the WriteCloser in another WriteCloser\n\t\t\t\t\t\t\thasher = newTarFilterer(hasher, func(hdr *tar.Header) (bool, bool, io.Reader) {\n\t\t\t\t\t\t\t\thdr.ModTime = zero\n\t\t\t\t\t\t\t\treturn false, false, nil\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\trequire.NotNil(t, hasher, \"newTarFilterer returned a null WriteCloser?\")\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// write this item as an archive\n\t\t\t\t\t\ttw := tar.NewWriter(hasher)\n\t\t\t\t\t\thdr := &tar.Header{\n\t\t\t\t\t\t\tName:     \"content\",\n\t\t\t\t\t\t\tSize:     size,\n\t\t\t\t\t\t\tMode:     0o640,\n\t\t\t\t\t\t\tModTime:  time.Now(),\n\t\t\t\t\t\t\tTypeflag: tar.TypeReg,\n\t\t\t\t\t\t}\n\t\t\t\t\t\terr := tw.WriteHeader(hdr)\n\t\t\t\t\t\trequire.Nil(t, err, \"error writing tar header to digester: %v\", err)\n\t\t\t\t\t\tn, err := io.Copy(tw, &buf)\n\t\t\t\t\t\trequire.Nil(t, err, \"error writing tar content to digester: %v\", err)\n\t\t\t\t\t\trequire.Equal(t, size, n, \"short write writing tar content to digester\")\n\t\t\t\t\t\terr = tw.Flush()\n\t\t\t\t\t\trequire.Nil(t, err, \"error flushing tar content to digester: %v\", err)\n\t\t\t\t\t\terr = tw.Close()\n\t\t\t\t\t\trequire.Nil(t, err, \"error closing tar archive being written digester: %v\", err)\n\t\t\t\t\t\tif filtered {\n\t\t\t\t\t\t\t// the ContentDigester can close its own if we don't explicitly ask it to,\n\t\t\t\t\t\t\t// but if we wrapped it in a filter, we have to close the filter to clean\n\t\t\t\t\t\t\t// up the filter, so we can't skip it to exercise that logic; we have to\n\t\t\t\t\t\t\t// leave that for the corresponding unfiltered case to try\n\t\t\t\t\t\t\thasher.Close()\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// now read the archive back\n\t\t\t\t\t\ttr := tar.NewReader(&written)\n\t\t\t\t\t\trequire.NotNil(t, tr, \"unable to read byte buffer?\")\n\t\t\t\t\t\thdr, err = tr.Next()\n\t\t\t\t\t\tfor err == nil {\n\t\t\t\t\t\t\tvar n int64\n\t\t\t\t\t\t\tif filtered {\n\t\t\t\t\t\t\t\t// the filter should have set the modtime to unix 0\n\t\t\t\t\t\t\t\trequire.Equal(t, zero, hdr.ModTime, \"timestamp for entry should have been zero\")\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// the filter should have left modtime to \"roughly now\"\n\t\t\t\t\t\t\t\trequire.NotEqual(t, zero, hdr.ModTime, \"timestamp for entry should not have been zero\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tn, err = io.Copy(io.Discard, tr)\n\t\t\t\t\t\t\trequire.Nil(t, err, \"error reading tar content from buffer: %v\", err)\n\t\t\t\t\t\t\trequire.Equal(t, hdr.Size, n, \"short read reading tar content\")\n\t\t\t\t\t\t\thdr, err = tr.Next()\n\t\t\t\t\t\t}\n\t\t\t\t\t\trequire.Equal(t, io.EOF, err, \"finished reading archive with %v, not EOF\", err)\n\t\t\t\t\t}\n\t\t\t\t\t// check the composite digest type matches expectations and the value is not just the\n\t\t\t\t\t// digest of zero-length data, which is absolutely not what we wrote\n\t\t\t\t\tdigestType, digestValue := digester.Digest()\n\t\t\t\t\trequire.Equal(t, test.resultType, digestType, \"expected to get a %q digest back for %v, got %q\", test.resultType, test.itemTypes, digestType)\n\t\t\t\t\trequire.NotEqual(t, digest.Canonical.FromBytes([]byte{}), digestValue, \"digester wasn't fed any data\")\n\t\t\t\t\trequire.False(t, digester.isOpen(), \"expected digester to have been closed with this usage pattern\")\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestTarFilterer(t *testing.T) {\n\ttests := []struct {\n\t\tname          string\n\t\tinput, output map[string]string\n\t\tbreakAfter    int\n\t\tfilter        func(*tar.Header) (bool, bool, io.Reader)\n\t}{\n\t\t{\n\t\t\tname: \"none\",\n\t\t\tinput: map[string]string{\n\t\t\t\t\"file a\": \"content a\",\n\t\t\t\t\"file b\": \"content b\",\n\t\t\t},\n\t\t\toutput: map[string]string{\n\t\t\t\t\"file a\": \"content a\",\n\t\t\t\t\"file b\": \"content b\",\n\t\t\t},\n\t\t\tfilter: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"plain\",\n\t\t\tinput: map[string]string{\n\t\t\t\t\"file a\": \"content a\",\n\t\t\t\t\"file b\": \"content b\",\n\t\t\t},\n\t\t\toutput: map[string]string{\n\t\t\t\t\"file a\": \"content a\",\n\t\t\t\t\"file b\": \"content b\",\n\t\t\t},\n\t\t\tfilter: func(*tar.Header) (bool, bool, io.Reader) { return false, false, nil },\n\t\t},\n\t\t{\n\t\t\tname: \"skip\",\n\t\t\tinput: map[string]string{\n\t\t\t\t\"file a\": \"content a\",\n\t\t\t\t\"file b\": \"content b\",\n\t\t\t},\n\t\t\toutput: map[string]string{\n\t\t\t\t\"file a\": \"content a\",\n\t\t\t},\n\t\t\tfilter: func(hdr *tar.Header) (bool, bool, io.Reader) { return hdr.Name == \"file b\", false, nil },\n\t\t},\n\t\t{\n\t\t\tname: \"replace\",\n\t\t\tinput: map[string]string{\n\t\t\t\t\"file a\": \"content a\",\n\t\t\t\t\"file b\": \"content b\",\n\t\t\t\t\"file c\": \"content c\",\n\t\t\t},\n\t\t\toutput: map[string]string{\n\t\t\t\t\"file a\": \"content a\",\n\t\t\t\t\"file b\": \"content b+c\",\n\t\t\t\t\"file c\": \"content c\",\n\t\t\t},\n\t\t\tbreakAfter: 2,\n\t\t\tfilter: func(hdr *tar.Header) (bool, bool, io.Reader) {\n\t\t\t\tif hdr.Name == \"file b\" {\n\t\t\t\t\tcontent := \"content b+c\"\n\t\t\t\t\thdr.Size = int64(len(content))\n\t\t\t\t\treturn false, true, strings.NewReader(content)\n\t\t\t\t}\n\t\t\t\treturn false, false, nil\n\t\t\t},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar buffer bytes.Buffer\n\t\t\ttw := tar.NewWriter(&buffer)\n\t\t\tfiles := 0\n\t\t\tfor filename, contents := range test.input {\n\t\t\t\thdr := tar.Header{\n\t\t\t\t\tName:     filename,\n\t\t\t\t\tSize:     int64(len(contents)),\n\t\t\t\t\tTypeflag: tar.TypeReg,\n\t\t\t\t}\n\t\t\t\terr := tw.WriteHeader(&hdr)\n\t\t\t\trequire.Nil(t, err, \"unexpected error from TarWriter.WriteHeader\")\n\t\t\t\tn, err := io.CopyN(tw, strings.NewReader(contents), int64(len(contents)))\n\t\t\t\trequire.Nil(t, err, \"unexpected error copying to tar writer\")\n\t\t\t\trequire.Equal(t, int64(len(contents)), n, \"unexpected write length\")\n\t\t\t\tfiles++\n\t\t\t\tif test.breakAfter != 0 && files%test.breakAfter == 0 {\n\t\t\t\t\t// this test may have us writing multiple archives to the buffer\n\t\t\t\t\t// they should still read back as a single archive\n\t\t\t\t\ttw.Close()\n\t\t\t\t\ttw = tar.NewWriter(&buffer)\n\t\t\t\t}\n\t\t\t}\n\t\t\ttw.Close()\n\t\t\toutput := make(map[string]string)\n\t\t\tpipeReader, pipeWriter := io.Pipe()\n\t\t\tvar wg sync.WaitGroup\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\ttr := tar.NewReader(pipeReader)\n\t\t\t\thdr, err := tr.Next()\n\t\t\t\tfor err == nil {\n\t\t\t\t\tvar buffer bytes.Buffer\n\t\t\t\t\tvar n int64\n\t\t\t\t\tn, err = io.Copy(&buffer, tr)\n\t\t\t\t\trequire.Nil(t, err, \"unexpected error copying from tar reader\")\n\t\t\t\t\trequire.Equal(t, hdr.Size, n, \"unexpected read length\")\n\t\t\t\t\toutput[hdr.Name] = buffer.String()\n\t\t\t\t\thdr, err = tr.Next()\n\t\t\t\t}\n\t\t\t\trequire.Equal(t, io.EOF, err, \"unexpected error ended our tarstream read\")\n\t\t\t\tpipeReader.Close()\n\t\t\t\twg.Done()\n\t\t\t}()\n\t\t\tfilterer := newTarFilterer(pipeWriter, test.filter)\n\t\t\t_, err := io.Copy(filterer, &buffer)\n\t\t\trequire.Nil(t, err, \"unexpected error copying archive through filter to reader\")\n\t\t\tfilterer.Close()\n\t\t\twg.Wait()\n\t\t\trequire.Equal(t, test.output, output, \"got unexpected results\")\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "docker",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 7.3955078125,
          "content": "module github.com/containers/buildah\n\n// Warning: Ensure the \"go\" and \"toolchain\" versions match exactly to prevent unwanted auto-updates\n\ngo 1.22.6\n\nrequire (\n\tgithub.com/containerd/platforms v0.2.1\n\tgithub.com/containernetworking/cni v1.2.3\n\tgithub.com/containers/common v0.61.0\n\tgithub.com/containers/image/v5 v5.33.0\n\tgithub.com/containers/luksy v0.0.0-20250106202729-a3a812db5b72\n\tgithub.com/containers/ocicrypt v1.2.1\n\tgithub.com/containers/storage v1.56.0\n\tgithub.com/cyphar/filepath-securejoin v0.3.6\n\tgithub.com/docker/distribution v2.8.3+incompatible\n\tgithub.com/docker/docker v27.4.1+incompatible\n\tgithub.com/docker/go-connections v0.5.0\n\tgithub.com/docker/go-units v0.5.0\n\tgithub.com/fsouza/go-dockerclient v1.12.0\n\tgithub.com/hashicorp/go-multierror v1.1.1\n\tgithub.com/mattn/go-shellwords v1.0.12\n\tgithub.com/moby/buildkit v0.18.2\n\tgithub.com/moby/sys/capability v0.4.0\n\tgithub.com/moby/sys/userns v0.1.0\n\tgithub.com/opencontainers/go-digest v1.0.0\n\tgithub.com/opencontainers/image-spec v1.1.0\n\tgithub.com/opencontainers/runc v1.2.4\n\tgithub.com/opencontainers/runtime-spec v1.2.0\n\tgithub.com/opencontainers/runtime-tools v0.9.1-0.20241108202711-f7e3563b0271\n\tgithub.com/opencontainers/selinux v1.11.1\n\tgithub.com/openshift/imagebuilder v1.2.15\n\tgithub.com/seccomp/libseccomp-golang v0.10.0\n\tgithub.com/sirupsen/logrus v1.9.3\n\tgithub.com/spf13/cobra v1.8.1\n\tgithub.com/spf13/pflag v1.0.5\n\tgithub.com/stretchr/testify v1.10.0\n\tgo.etcd.io/bbolt v1.3.11\n\tgolang.org/x/crypto v0.32.0\n\tgolang.org/x/exp v0.0.0-20241108190413-2d47ceb2692f\n\tgolang.org/x/sync v0.10.0\n\tgolang.org/x/sys v0.29.0\n\tgolang.org/x/term v0.28.0\n\tsigs.k8s.io/yaml v1.4.0\n\ttags.cncf.io/container-device-interface v0.8.0\n)\n\nrequire (\n\tdario.cat/mergo v1.0.1 // indirect\n\tgithub.com/Azure/go-ansiterm v0.0.0-20230124172434-306776ec8161 // indirect\n\tgithub.com/BurntSushi/toml v1.4.0 // indirect\n\tgithub.com/Microsoft/go-winio v0.6.2 // indirect\n\tgithub.com/Microsoft/hcsshim v0.12.9 // indirect\n\tgithub.com/VividCortex/ewma v1.2.0 // indirect\n\tgithub.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d // indirect\n\tgithub.com/aead/serpent v0.0.0-20160714141033-fba169763ea6 // indirect\n\tgithub.com/asaskevich/govalidator v0.0.0-20230301143203-a9d515a09cc2 // indirect\n\tgithub.com/chzyer/readline v1.5.1 // indirect\n\tgithub.com/containerd/cgroups/v3 v3.0.3 // indirect\n\tgithub.com/containerd/errdefs v0.3.0 // indirect\n\tgithub.com/containerd/errdefs/pkg v0.3.0 // indirect\n\tgithub.com/containerd/log v0.1.0 // indirect\n\tgithub.com/containerd/stargz-snapshotter/estargz v0.15.1 // indirect\n\tgithub.com/containerd/typeurl/v2 v2.2.3 // indirect\n\tgithub.com/containernetworking/plugins v1.5.1 // indirect\n\tgithub.com/containers/libtrust v0.0.0-20230121012942-c1716e8a8d01 // indirect\n\tgithub.com/coreos/go-systemd/v22 v22.5.0 // indirect\n\tgithub.com/cyberphone/json-canonicalization v0.0.0-20231217050601-ba74d44ecf5f // indirect\n\tgithub.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc // indirect\n\tgithub.com/disiqueira/gotree/v3 v3.0.2 // indirect\n\tgithub.com/distribution/reference v0.6.0 // indirect\n\tgithub.com/docker/docker-credential-helpers v0.8.2 // indirect\n\tgithub.com/felixge/httpsnoop v1.0.4 // indirect\n\tgithub.com/fsnotify/fsnotify v1.8.0 // indirect\n\tgithub.com/go-jose/go-jose/v4 v4.0.4 // indirect\n\tgithub.com/go-logr/logr v1.4.2 // indirect\n\tgithub.com/go-logr/stdr v1.2.2 // indirect\n\tgithub.com/go-openapi/analysis v0.23.0 // indirect\n\tgithub.com/go-openapi/errors v0.22.0 // indirect\n\tgithub.com/go-openapi/jsonpointer v0.21.0 // indirect\n\tgithub.com/go-openapi/jsonreference v0.21.0 // indirect\n\tgithub.com/go-openapi/loads v0.22.0 // indirect\n\tgithub.com/go-openapi/runtime v0.28.0 // indirect\n\tgithub.com/go-openapi/spec v0.21.0 // indirect\n\tgithub.com/go-openapi/strfmt v0.23.0 // indirect\n\tgithub.com/go-openapi/swag v0.23.0 // indirect\n\tgithub.com/go-openapi/validate v0.24.0 // indirect\n\tgithub.com/godbus/dbus/v5 v5.1.0 // indirect\n\tgithub.com/gogo/protobuf v1.3.2 // indirect\n\tgithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect\n\tgithub.com/golang/protobuf v1.5.4 // indirect\n\tgithub.com/google/go-containerregistry v0.20.2 // indirect\n\tgithub.com/google/go-intervals v0.0.2 // indirect\n\tgithub.com/google/uuid v1.6.0 // indirect\n\tgithub.com/gorilla/mux v1.8.1 // indirect\n\tgithub.com/hashicorp/errwrap v1.1.0 // indirect\n\tgithub.com/inconshreveable/mousetrap v1.1.0 // indirect\n\tgithub.com/jinzhu/copier v0.4.0 // indirect\n\tgithub.com/josharian/intern v1.0.0 // indirect\n\tgithub.com/json-iterator/go v1.1.12 // indirect\n\tgithub.com/klauspost/compress v1.17.11 // indirect\n\tgithub.com/klauspost/pgzip v1.2.6 // indirect\n\tgithub.com/letsencrypt/boulder v0.0.0-20240620165639-de9c06129bec // indirect\n\tgithub.com/mailru/easyjson v0.7.7 // indirect\n\tgithub.com/manifoldco/promptui v0.9.0 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.16 // indirect\n\tgithub.com/mattn/go-sqlite3 v1.14.24 // indirect\n\tgithub.com/miekg/pkcs11 v1.1.1 // indirect\n\tgithub.com/mistifyio/go-zfs/v3 v3.0.1 // indirect\n\tgithub.com/mitchellh/mapstructure v1.5.0 // indirect\n\tgithub.com/moby/docker-image-spec v1.3.1 // indirect\n\tgithub.com/moby/patternmatcher v0.6.0 // indirect\n\tgithub.com/moby/sys/mountinfo v0.7.2 // indirect\n\tgithub.com/moby/sys/sequential v0.6.0 // indirect\n\tgithub.com/moby/sys/user v0.3.0 // indirect\n\tgithub.com/moby/term v0.5.0 // indirect\n\tgithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect\n\tgithub.com/modern-go/reflect2 v1.0.2 // indirect\n\tgithub.com/morikuni/aec v1.0.0 // indirect\n\tgithub.com/oklog/ulid v1.3.1 // indirect\n\tgithub.com/ostreedev/ostree-go v0.0.0-20210805093236-719684c64e4f // indirect\n\tgithub.com/pkg/errors v0.9.1 // indirect\n\tgithub.com/planetscale/vtprotobuf v0.6.1-0.20240319094008-0393e58bdf10 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 // indirect\n\tgithub.com/proglottis/gpgme v0.1.3 // indirect\n\tgithub.com/rivo/uniseg v0.4.7 // indirect\n\tgithub.com/secure-systems-lab/go-securesystemslib v0.8.0 // indirect\n\tgithub.com/sigstore/fulcio v1.6.4 // indirect\n\tgithub.com/sigstore/rekor v1.3.6 // indirect\n\tgithub.com/sigstore/sigstore v1.8.9 // indirect\n\tgithub.com/smallstep/pkcs7 v0.1.1 // indirect\n\tgithub.com/stefanberger/go-pkcs11uri v0.0.0-20230803200340-78284954bff6 // indirect\n\tgithub.com/sylabs/sif/v2 v2.19.1 // indirect\n\tgithub.com/syndtr/gocapability v0.0.0-20200815063812-42c35b437635 // indirect\n\tgithub.com/tchap/go-patricia/v2 v2.3.1 // indirect\n\tgithub.com/titanous/rocacheck v0.0.0-20171023193734-afe73141d399 // indirect\n\tgithub.com/ulikunitz/xz v0.5.12 // indirect\n\tgithub.com/vbatts/tar-split v0.11.6 // indirect\n\tgithub.com/vbauerster/mpb/v8 v8.8.3 // indirect\n\tgithub.com/vishvananda/netlink v1.3.0 // indirect\n\tgithub.com/vishvananda/netns v0.0.4 // indirect\n\tgo.mongodb.org/mongo-driver v1.14.0 // indirect\n\tgo.opencensus.io v0.24.0 // indirect\n\tgo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.53.0 // indirect\n\tgo.opentelemetry.io/otel v1.28.0 // indirect\n\tgo.opentelemetry.io/otel/metric v1.28.0 // indirect\n\tgo.opentelemetry.io/otel/trace v1.28.0 // indirect\n\tgolang.org/x/mod v0.22.0 // indirect\n\tgolang.org/x/net v0.33.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n\tgoogle.golang.org/genproto/googleapis/rpc v0.0.0-20240903143218-8af14fe29dc1 // indirect\n\tgoogle.golang.org/grpc v1.68.1 // indirect\n\tgoogle.golang.org/protobuf v1.35.1 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n\tk8s.io/klog v1.0.0 // indirect\n\ttags.cncf.io/container-device-interface/specs-go v0.8.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 51.4072265625,
          "content": "cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ndario.cat/mergo v1.0.1 h1:Ra4+bf83h2ztPIQYNP99R6m+Y7KfnARDfID+a+vLl4s=\ndario.cat/mergo v1.0.1/go.mod h1:uNxQE+84aUszobStD9th8a29P2fMDhsBdgRYvZOxGmk=\ngithub.com/14rcole/gopopulate v0.0.0-20180821133914-b175b219e774 h1:SCbEWT58NSt7d2mcFdvxC9uyrdcTfvBbPLThhkDmXzg=\ngithub.com/14rcole/gopopulate v0.0.0-20180821133914-b175b219e774/go.mod h1:6/0dYRLLXyJjbkIPeeGyoJ/eKOSI0eU6eTlCBYibgd0=\ngithub.com/AdaLogics/go-fuzz-headers v0.0.0-20230811130428-ced1acdcaa24 h1:bvDV9vkmnHYOMsOr4WLk+Vo07yKIzd94sVoIqshQ4bU=\ngithub.com/AdaLogics/go-fuzz-headers v0.0.0-20230811130428-ced1acdcaa24/go.mod h1:8o94RPi1/7XTJvwPpRSzSUedZrtlirdB3r9Z20bi2f8=\ngithub.com/Azure/go-ansiterm v0.0.0-20230124172434-306776ec8161 h1:L/gRVlceqvL25UVaW/CKtUDjefjrs0SPonmDGUVOYP0=\ngithub.com/Azure/go-ansiterm v0.0.0-20230124172434-306776ec8161/go.mod h1:xomTg63KZ2rFqZQzSB4Vz2SUXa1BpHTVz9L5PTmPC4E=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/BurntSushi/toml v1.4.0 h1:kuoIxZQy2WRRk1pttg9asf+WVv6tWQuBNVmK8+nqPr0=\ngithub.com/BurntSushi/toml v1.4.0/go.mod h1:ukJfTF/6rtPPRCnwkur4qwRxa8vTRFBF0uk2lLoLwho=\ngithub.com/Microsoft/go-winio v0.6.2 h1:F2VQgta7ecxGYO8k3ZZz3RS8fVIXVxONVUPlNERoyfY=\ngithub.com/Microsoft/go-winio v0.6.2/go.mod h1:yd8OoFMLzJbo9gZq8j5qaps8bJ9aShtEA8Ipt1oGCvU=\ngithub.com/Microsoft/hcsshim v0.12.9 h1:2zJy5KA+l0loz1HzEGqyNnjd3fyZA31ZBCGKacp6lLg=\ngithub.com/Microsoft/hcsshim v0.12.9/go.mod h1:fJ0gkFAna6ukt0bLdKB8djt4XIJhF/vEPuoIWYVvZ8Y=\ngithub.com/VividCortex/ewma v1.2.0 h1:f58SaIzcDXrSy3kWaHNvuJgJ3Nmz59Zji6XoJR/q1ow=\ngithub.com/VividCortex/ewma v1.2.0/go.mod h1:nz4BbCtbLyFDeC9SUHbtcT5644juEuWfUAUnGx7j5l4=\ngithub.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d h1:licZJFw2RwpHMqeKTCYkitsPqHNxTmd4SNR5r94FGM8=\ngithub.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d/go.mod h1:asat636LX7Bqt5lYEZ27JNDcqxfjdBQuJ/MM4CN/Lzo=\ngithub.com/aead/serpent v0.0.0-20160714141033-fba169763ea6 h1:5L8Mj9Co9sJVgW3TpYk2gxGJnDjsYuboNTcRmbtGKGs=\ngithub.com/aead/serpent v0.0.0-20160714141033-fba169763ea6/go.mod h1:3HgLJ9d18kXMLQlJvIY3+FszZYMxCz8WfE2MQ7hDY0w=\ngithub.com/asaskevich/govalidator v0.0.0-20230301143203-a9d515a09cc2 h1:DklsrG3dyBCFEj5IhUbnKptjxatkF07cF2ak3yi77so=\ngithub.com/asaskevich/govalidator v0.0.0-20230301143203-a9d515a09cc2/go.mod h1:WaHUgvxTVq04UNunO+XhnAqY/wQc+bxr74GqbsZ/Jqw=\ngithub.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=\ngithub.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=\ngithub.com/blang/semver v3.5.1+incompatible h1:cQNTCjp13qL8KC3Nbxr/y2Bqb63oX6wdnnjpJbkM4JQ=\ngithub.com/blang/semver/v4 v4.0.0 h1:1PFHFE6yCCTv8C1TeyNNarDzntLi7wMI5i/pzqYIsAM=\ngithub.com/blang/semver/v4 v4.0.0/go.mod h1:IbckMUScFkM3pff0VJDNKRiT6TG/YpiHIM2yvyW5YoQ=\ngithub.com/cenkalti/backoff/v4 v4.3.0 h1:MyRJ/UdXutAwSAT+s3wNd7MfTIcy71VQueUuFK343L8=\ngithub.com/cenkalti/backoff/v4 v4.3.0/go.mod h1:Y3VNntkOUPxTVeUxJ/G5vcM//AlwfmyYozVcomhLiZE=\ngithub.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=\ngithub.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=\ngithub.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=\ngithub.com/chzyer/logex v1.2.1 h1:XHDu3E6q+gdHgsdTPH6ImJMIp436vR6MPtH8gP05QzM=\ngithub.com/chzyer/logex v1.2.1/go.mod h1:JLbx6lG2kDbNRFnfkgvh4eRJRPX1QCoOIWomwysCBrQ=\ngithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=\ngithub.com/chzyer/readline v1.5.1 h1:upd/6fQk4src78LMRzh5vItIt361/o4uq553V8B5sGI=\ngithub.com/chzyer/readline v1.5.1/go.mod h1:Eh+b79XXUwfKfcPLepksvw2tcLE/Ct21YObkaSkeBlk=\ngithub.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=\ngithub.com/chzyer/test v1.0.0 h1:p3BQDXSxOhOG0P9z6/hGnII4LGiEPOYBhs8asl/fC04=\ngithub.com/chzyer/test v1.0.0/go.mod h1:2JlltgoNkt4TW/z9V/IzDdFaMTM2JPIi26O1pF38GC8=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=\ngithub.com/containerd/cgroups/v3 v3.0.3 h1:S5ByHZ/h9PMe5IOQoN7E+nMc2UcLEM/V48DGDJ9kip0=\ngithub.com/containerd/cgroups/v3 v3.0.3/go.mod h1:8HBe7V3aWGLFPd/k03swSIsGjZhHI2WzJmticMgVuz0=\ngithub.com/containerd/containerd v1.7.24 h1:zxszGrGjrra1yYJW/6rhm9cJ1ZQ8rkKBR48brqsa7nA=\ngithub.com/containerd/containerd v1.7.24/go.mod h1:7QUzfURqZWCZV7RLNEn1XjUCQLEf0bkaK4GjUaZehxw=\ngithub.com/containerd/errdefs v0.3.0 h1:FSZgGOeK4yuT/+DnF07/Olde/q4KBoMsaamhXxIMDp4=\ngithub.com/containerd/errdefs v0.3.0/go.mod h1:+YBYIdtsnF4Iw6nWZhJcqGSg/dwvV7tyJ/kCkyJ2k+M=\ngithub.com/containerd/errdefs/pkg v0.3.0 h1:9IKJ06FvyNlexW690DXuQNx2KA2cUJXx151Xdx3ZPPE=\ngithub.com/containerd/errdefs/pkg v0.3.0/go.mod h1:NJw6s9HwNuRhnjJhM7pylWwMyAkmCQvQ4GpJHEqRLVk=\ngithub.com/containerd/log v0.1.0 h1:TCJt7ioM2cr/tfR8GPbGf9/VRAX8D2B4PjzCpfX540I=\ngithub.com/containerd/log v0.1.0/go.mod h1:VRRf09a7mHDIRezVKTRCrOq78v577GXq3bSa3EhrzVo=\ngithub.com/containerd/platforms v0.2.1 h1:zvwtM3rz2YHPQsF2CHYM8+KtB5dvhISiXh5ZpSBQv6A=\ngithub.com/containerd/platforms v0.2.1/go.mod h1:XHCb+2/hzowdiut9rkudds9bE5yJ7npe7dG/wG+uFPw=\ngithub.com/containerd/stargz-snapshotter/estargz v0.15.1 h1:eXJjw9RbkLFgioVaTG+G/ZW/0kEe2oEKCdS/ZxIyoCU=\ngithub.com/containerd/stargz-snapshotter/estargz v0.15.1/go.mod h1:gr2RNwukQ/S9Nv33Lt6UC7xEx58C+LHRdoqbEKjz1Kk=\ngithub.com/containerd/typeurl/v2 v2.2.3 h1:yNA/94zxWdvYACdYO8zofhrTVuQY73fFU1y++dYSw40=\ngithub.com/containerd/typeurl/v2 v2.2.3/go.mod h1:95ljDnPfD3bAbDJRugOiShd/DlAAsxGtUBhJxIn7SCk=\ngithub.com/containernetworking/cni v1.2.3 h1:hhOcjNVUQTnzdRJ6alC5XF+wd9mfGIUaj8FuJbEslXM=\ngithub.com/containernetworking/cni v1.2.3/go.mod h1:DuLgF+aPd3DzcTQTtp/Nvl1Kim23oFKdm2okJzBQA5M=\ngithub.com/containernetworking/plugins v1.5.1 h1:T5ji+LPYjjgW0QM+KyrigZbLsZ8jaX+E5J/EcKOE4gQ=\ngithub.com/containernetworking/plugins v1.5.1/go.mod h1:MIQfgMayGuHYs0XdNudf31cLLAC+i242hNm6KuDGqCM=\ngithub.com/containers/common v0.61.0 h1:j/84PTqZIKKYy42OEJsZmjZ4g4Kq2ERuC3tqp2yWdh4=\ngithub.com/containers/common v0.61.0/go.mod h1:NGRISq2vTFPSbhNqj6MLwyes4tWSlCnqbJg7R77B8xc=\ngithub.com/containers/image/v5 v5.33.0 h1:6oPEFwTurf7pDTGw7TghqGs8K0+OvPtY/UyzU0B2DfE=\ngithub.com/containers/image/v5 v5.33.0/go.mod h1:T7HpASmvnp2H1u4cyckMvCzLuYgpD18dSmabSw0AcHk=\ngithub.com/containers/libtrust v0.0.0-20230121012942-c1716e8a8d01 h1:Qzk5C6cYglewc+UyGf6lc8Mj2UaPTHy/iF2De0/77CA=\ngithub.com/containers/libtrust v0.0.0-20230121012942-c1716e8a8d01/go.mod h1:9rfv8iPl1ZP7aqh9YA68wnZv2NUDbXdcdPHVz0pFbPY=\ngithub.com/containers/luksy v0.0.0-20250106202729-a3a812db5b72 h1:hdBIFaml6hO+Bal8CdQSQPTF305gwsJfubs4NoOV53A=\ngithub.com/containers/luksy v0.0.0-20250106202729-a3a812db5b72/go.mod h1:UpMgEjd9XelIA/iK+qD3hWIrZY/M3eaepn+gm5U8OYE=\ngithub.com/containers/ocicrypt v1.2.1 h1:0qIOTT9DoYwcKmxSt8QJt+VzMY18onl9jUXsxpVhSmM=\ngithub.com/containers/ocicrypt v1.2.1/go.mod h1:aD0AAqfMp0MtwqWgHM1bUwe1anx0VazI108CRrSKINQ=\ngithub.com/containers/storage v1.56.0 h1:DZ9KSkj6M2tvj/4bBoaJu3QDHRl35BwsZ4kmLJS97ZI=\ngithub.com/containers/storage v1.56.0/go.mod h1:c6WKowcAlED/DkWGNuL9bvGYqIWCVy7isRMdCSKWNjk=\ngithub.com/coreos/go-systemd/v22 v22.5.0 h1:RrqgGjYQKalulkV8NGVIfkXQf6YYmOyiJKk8iXXhfZs=\ngithub.com/coreos/go-systemd/v22 v22.5.0/go.mod h1:Y58oyj3AT4RCenI/lSvhwexgC+NSVTIJ3seZv2GcEnc=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.4/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=\ngithub.com/creack/pty v1.1.18 h1:n56/Zwd5o6whRC5PMGretI4IdRLlmBXYNjScPaBgsbY=\ngithub.com/creack/pty v1.1.18/go.mod h1:MOBLtS5ELjhRRrroQr9kyvTxUAFNvYEK993ew/Vr4O4=\ngithub.com/cyberphone/json-canonicalization v0.0.0-20231217050601-ba74d44ecf5f h1:eHnXnuK47UlSTOQexbzxAZfekVz6i+LKRdj1CU5DPaM=\ngithub.com/cyberphone/json-canonicalization v0.0.0-20231217050601-ba74d44ecf5f/go.mod h1:uzvlm1mxhHkdfqitSA92i7Se+S9ksOn3a3qmv/kyOCw=\ngithub.com/cyphar/filepath-securejoin v0.3.6 h1:4d9N5ykBnSp5Xn2JkhocYDkOpURL/18CYMpo6xB9uWM=\ngithub.com/cyphar/filepath-securejoin v0.3.6/go.mod h1:Sdj7gXlvMcPZsbhwhQ33GguGLDGQL7h7bg04C/+u9jI=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc h1:U9qPSI2PIWSS1VwoXQT9A3Wy9MM3WgvqSxFWenqJduM=\ngithub.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/disiqueira/gotree/v3 v3.0.2 h1:ik5iuLQQoufZBNPY518dXhiO5056hyNBIK9lWhkNRq8=\ngithub.com/disiqueira/gotree/v3 v3.0.2/go.mod h1:ZuyjE4+mUQZlbpkI24AmruZKhg3VHEgPLDY8Qk+uUu8=\ngithub.com/distribution/reference v0.6.0 h1:0IXCQ5g4/QMHHkarYzh5l+u8T3t73zM5QvfrDyIgxBk=\ngithub.com/distribution/reference v0.6.0/go.mod h1:BbU0aIcezP1/5jX/8MP0YiH4SdvB5Y4f/wlDRiLyi3E=\ngithub.com/docker/cli v27.4.0-rc.2+incompatible h1:A0GZwegDlt2wdt3tpmrUzkVOZmbhvd7i05wPSf7Oo74=\ngithub.com/docker/cli v27.4.0-rc.2+incompatible/go.mod h1:JLrzqnKDaYBop7H2jaqPtU4hHvMKP+vjCwu2uszcLI8=\ngithub.com/docker/distribution v2.8.3+incompatible h1:AtKxIZ36LoNK51+Z6RpzLpddBirtxJnzDrHLEKxTAYk=\ngithub.com/docker/distribution v2.8.3+incompatible/go.mod h1:J2gT2udsDAN96Uj4KfcMRqY0/ypR+oyYUYmja8H+y+w=\ngithub.com/docker/docker v27.4.1+incompatible h1:ZJvcY7gfwHn1JF48PfbyXg7Jyt9ZCWDW+GGXOIxEwp4=\ngithub.com/docker/docker v27.4.1+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=\ngithub.com/docker/docker-credential-helpers v0.8.2 h1:bX3YxiGzFP5sOXWc3bTPEXdEaZSeVMrFgOr3T+zrFAo=\ngithub.com/docker/docker-credential-helpers v0.8.2/go.mod h1:P3ci7E3lwkZg6XiHdRKft1KckHiO9a2rNtyFbZ/ry9M=\ngithub.com/docker/go-connections v0.5.0 h1:USnMq7hx7gwdVZq1L49hLXaFtUdTADjXGp+uj1Br63c=\ngithub.com/docker/go-connections v0.5.0/go.mod h1:ov60Kzw0kKElRwhNs9UlUHAE/F9Fe6GLaXnqyDdmEXc=\ngithub.com/docker/go-metrics v0.0.1 h1:AgB/0SvBxihN0X8OR4SjsblXkbMvalQ8cjmtKQ2rQV8=\ngithub.com/docker/go-metrics v0.0.1/go.mod h1:cG1hvH2utMXtqgqqYE9plW6lDxS3/5ayHzueweSI3Vw=\ngithub.com/docker/go-units v0.5.0 h1:69rxXcBk27SvSaaxTtLh/8llcHD8vYHT7WSdRZ/jvr4=\ngithub.com/docker/go-units v0.5.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=\ngithub.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=\ngithub.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=\ngithub.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=\ngithub.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=\ngithub.com/fsnotify/fsnotify v1.8.0 h1:dAwr6QBTBZIkG8roQaJjGof0pp0EeF+tNV7YBP3F/8M=\ngithub.com/fsnotify/fsnotify v1.8.0/go.mod h1:8jBTzvmWwFyi3Pb8djgCCO5IBqzKJ/Jwo8TRcHyHii0=\ngithub.com/fsouza/go-dockerclient v1.12.0 h1:S2f2crEUbBNCFiF06kR/GvioEB8EMsb3Td/bpawD+aU=\ngithub.com/fsouza/go-dockerclient v1.12.0/go.mod h1:YWUtjg8japrqD/80L98nTtCoxQFp5B5wrSsnyeB5lFo=\ngithub.com/go-jose/go-jose/v4 v4.0.4 h1:VsjPI33J0SB9vQM6PLmNjoHqMQNGPiZ0rHL7Ni7Q6/E=\ngithub.com/go-jose/go-jose/v4 v4.0.4/go.mod h1:NKb5HO1EZccyMpiZNbdUw/14tiXNyUJh188dfnMCAfc=\ngithub.com/go-logr/logr v0.1.0/go.mod h1:ixOQHD9gLJUVQQ2ZOR7zLEifBX6tGkNJF4QyIY7sIas=\ngithub.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=\ngithub.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=\ngithub.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=\ngithub.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=\ngithub.com/go-openapi/analysis v0.23.0 h1:aGday7OWupfMs+LbmLZG4k0MYXIANxcuBTYUC03zFCU=\ngithub.com/go-openapi/analysis v0.23.0/go.mod h1:9mz9ZWaSlV8TvjQHLl2mUW2PbZtemkE8yA5v22ohupo=\ngithub.com/go-openapi/errors v0.22.0 h1:c4xY/OLxUBSTiepAg3j/MHuAv5mJhnf53LLMWFB+u/w=\ngithub.com/go-openapi/errors v0.22.0/go.mod h1:J3DmZScxCDufmIMsdOuDHxJbdOGC0xtUynjIx092vXE=\ngithub.com/go-openapi/jsonpointer v0.21.0 h1:YgdVicSA9vH5RiHs9TZW5oyafXZFc6+2Vc1rr/O9oNQ=\ngithub.com/go-openapi/jsonpointer v0.21.0/go.mod h1:IUyH9l/+uyhIYQ/PXVA41Rexl+kOkAPDdXEYns6fzUY=\ngithub.com/go-openapi/jsonreference v0.21.0 h1:Rs+Y7hSXT83Jacb7kFyjn4ijOuVGSvOdF2+tg1TRrwQ=\ngithub.com/go-openapi/jsonreference v0.21.0/go.mod h1:LmZmgsrTkVg9LG4EaHeY8cBDslNPMo06cago5JNLkm4=\ngithub.com/go-openapi/loads v0.22.0 h1:ECPGd4jX1U6NApCGG1We+uEozOAvXvJSF4nnwHZ8Aco=\ngithub.com/go-openapi/loads v0.22.0/go.mod h1:yLsaTCS92mnSAZX5WWoxszLj0u+Ojl+Zs5Stn1oF+rs=\ngithub.com/go-openapi/runtime v0.28.0 h1:gpPPmWSNGo214l6n8hzdXYhPuJcGtziTOgUpvsFWGIQ=\ngithub.com/go-openapi/runtime v0.28.0/go.mod h1:QN7OzcS+XuYmkQLw05akXk0jRH/eZ3kb18+1KwW9gyc=\ngithub.com/go-openapi/spec v0.21.0 h1:LTVzPc3p/RzRnkQqLRndbAzjY0d0BCL72A6j3CdL9ZY=\ngithub.com/go-openapi/spec v0.21.0/go.mod h1:78u6VdPw81XU44qEWGhtr982gJ5BWg2c0I5XwVMotYk=\ngithub.com/go-openapi/strfmt v0.23.0 h1:nlUS6BCqcnAk0pyhi9Y+kdDVZdZMHfEKQiS4HaMgO/c=\ngithub.com/go-openapi/strfmt v0.23.0/go.mod h1:NrtIpfKtWIygRkKVsxh7XQMDQW5HKQl6S5ik2elW+K4=\ngithub.com/go-openapi/swag v0.23.0 h1:vsEVJDUo2hPJ2tu0/Xc+4noaxyEffXNIs3cOULZ+GrE=\ngithub.com/go-openapi/swag v0.23.0/go.mod h1:esZ8ITTYEsH1V2trKHjAN8Ai7xHb8RV+YSZ577vPjgQ=\ngithub.com/go-openapi/validate v0.24.0 h1:LdfDKwNbpB6Vn40xhTdNZAnfLECL81w+VX3BumrGD58=\ngithub.com/go-openapi/validate v0.24.0/go.mod h1:iyeX1sEufmv3nPbBdX3ieNviWnOZaJ1+zquzJEf2BAQ=\ngithub.com/go-task/slim-sprig/v3 v3.0.0 h1:sUs3vkvUymDpBKi3qH1YSqBQk9+9D/8M2mN1vB6EwHI=\ngithub.com/go-task/slim-sprig/v3 v3.0.0/go.mod h1:W848ghGpv3Qj3dhTPRyJypKRiqCdHZiAzKg9hl15HA8=\ngithub.com/go-test/deep v1.1.1 h1:0r/53hagsehfO4bzD2Pgr/+RgHqhmf+k1Bpse2cTu1U=\ngithub.com/go-test/deep v1.1.1/go.mod h1:5C2ZWiW0ErCdrYzpqxLbTX7MG14M9iiw8DgHncVwcsE=\ngithub.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=\ngithub.com/godbus/dbus/v5 v5.1.0 h1:4KLkAxT3aOY8Li4FRJe/KvhoNFFxo0m6fNuFUO8QJUk=\ngithub.com/godbus/dbus/v5 v5.1.0/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=\ngithub.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=\ngithub.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da h1:oI5xCqsCo564l8iNU+DwB5epxmsaqB+rhGL0m5jtYqE=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=\ngithub.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=\ngithub.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=\ngithub.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=\ngithub.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=\ngithub.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=\ngithub.com/golang/protobuf v1.4.3/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=\ngithub.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.3/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/go-containerregistry v0.20.2 h1:B1wPJ1SN/S7pB+ZAimcciVD+r+yV/l/DSArMxlbwseo=\ngithub.com/google/go-containerregistry v0.20.2/go.mod h1:z38EKdKh4h7IP2gSfUUqEvalZBqs6AoLeWfUy34nQC8=\ngithub.com/google/go-intervals v0.0.2 h1:FGrVEiUnTRKR8yE04qzXYaJMtnIYqobR5QbblK3ixcM=\ngithub.com/google/go-intervals v0.0.2/go.mod h1:MkaR3LNRfeKLPmqgJYs4E66z5InYjmCjbbr4TQlcT6Y=\ngithub.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/google/pprof v0.0.0-20241029153458-d1b30febd7db h1:097atOisP2aRj7vFgYQBbFN4U4JNXUNYpxael3UzMyo=\ngithub.com/google/pprof v0.0.0-20241029153458-d1b30febd7db/go.mod h1:vavhavw2zAxS5dIdcRluK6cSGGPlZynqzFM8NdvU144=\ngithub.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/google/uuid v1.2.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/gorilla/mux v1.8.1 h1:TuBL49tXwgrFYWhqrNgrUNEY92u81SPhu7sTdzQEiWY=\ngithub.com/gorilla/mux v1.8.1/go.mod h1:AKf9I4AEqPTmMytcMc0KkNouC66V3BtZ4qD5fmWSiMQ=\ngithub.com/grpc-ecosystem/grpc-gateway/v2 v2.22.0 h1:asbCHRVmodnJTuQ3qamDwqVOIjwqUPTYmYuemVOx+Ys=\ngithub.com/grpc-ecosystem/grpc-gateway/v2 v2.22.0/go.mod h1:ggCgvZ2r7uOoQjOyu2Y1NhHmEPPzzuhWgcza5M1Ji1I=\ngithub.com/hashicorp/errwrap v1.0.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=\ngithub.com/hashicorp/errwrap v1.1.0 h1:OxrOeh75EUXMY8TBjag2fzXGZ40LB6IKw45YeGUDY2I=\ngithub.com/hashicorp/errwrap v1.1.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=\ngithub.com/hashicorp/go-multierror v1.1.1 h1:H5DkEtf6CXdFp0N0Em5UCwQpXMWke8IA0+lD48awMYo=\ngithub.com/hashicorp/go-multierror v1.1.1/go.mod h1:iw975J/qwKPdAO1clOe2L8331t/9/fmwbPZ6JB6eMoM=\ngithub.com/inconshreveable/mousetrap v1.1.0 h1:wN+x4NVGpMsO7ErUn/mUI3vEoE6Jt13X2s0bqwp9tc8=\ngithub.com/inconshreveable/mousetrap v1.1.0/go.mod h1:vpF70FUmC8bwa3OWnCshd2FqLfsEA9PFc4w1p2J65bw=\ngithub.com/jinzhu/copier v0.4.0 h1:w3ciUoD19shMCRargcpm0cm91ytaBhDvuRpz1ODO/U8=\ngithub.com/jinzhu/copier v0.4.0/go.mod h1:DfbEm0FYsaqBcKcFuvmOZb218JkPGtvSHsKg8S8hyyg=\ngithub.com/jmhodges/clock v1.2.0 h1:eq4kys+NI0PLngzaHEe7AmPT90XMGIEySD1JfV1PDIs=\ngithub.com/jmhodges/clock v1.2.0/go.mod h1:qKjhA7x7u/lQpPB1XAqX1b1lCI/w3/fNuYpI/ZjLynI=\ngithub.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=\ngithub.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=\ngithub.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=\ngithub.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=\ngithub.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/klauspost/compress v1.17.11 h1:In6xLpyWOi1+C7tXUUWv2ot1QvBjxevKAaI6IXrJmUc=\ngithub.com/klauspost/compress v1.17.11/go.mod h1:pMDklpSncoRMuLFrf1W9Ss9KT+0rH90U12bZKk7uwG0=\ngithub.com/klauspost/pgzip v1.2.6 h1:8RXeL5crjEUFnR2/Sn6GJNWtSQ3Dk8pq4CL3jvdDyjU=\ngithub.com/klauspost/pgzip v1.2.6/go.mod h1:Ch1tH69qFZu15pkjo5kYi6mth2Zzwzt50oCQKQE9RUs=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/letsencrypt/boulder v0.0.0-20240620165639-de9c06129bec h1:2tTW6cDth2TSgRbAhD7yjZzTQmcN25sDRPEeinR51yQ=\ngithub.com/letsencrypt/boulder v0.0.0-20240620165639-de9c06129bec/go.mod h1:TmwEoGCwIti7BCeJ9hescZgRtatxRE+A72pCoPfmcfk=\ngithub.com/mailru/easyjson v0.7.7 h1:UGYAvKxe3sBsEDzO8ZeWOSlIQfWFlxbzLZe7hwFURr0=\ngithub.com/mailru/easyjson v0.7.7/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=\ngithub.com/manifoldco/promptui v0.9.0 h1:3V4HzJk1TtXW1MTZMP7mdlwbBpIinw3HztaIlYthEiA=\ngithub.com/manifoldco/promptui v0.9.0/go.mod h1:ka04sppxSGFAtxX0qhlYQjISsg9mR4GWtQEhdbn6Pgg=\ngithub.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=\ngithub.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/mattn/go-shellwords v1.0.12 h1:M2zGm7EW6UQJvDeQxo4T51eKPurbeFbe8WtebGE2xrk=\ngithub.com/mattn/go-shellwords v1.0.12/go.mod h1:EZzvwXDESEeg03EKmM+RmDnNOPKG4lLtQsUlTZDWQ8Y=\ngithub.com/mattn/go-sqlite3 v1.14.24 h1:tpSp2G2KyMnnQu99ngJ47EIkWVmliIizyZBfPrBWDRM=\ngithub.com/mattn/go-sqlite3 v1.14.24/go.mod h1:Uh1q+B4BYcTPb+yiD3kU8Ct7aC0hY9fxUwlHK0RXw+Y=\ngithub.com/miekg/pkcs11 v1.1.1 h1:Ugu9pdy6vAYku5DEpVWVFPYnzV+bxB+iRdbuFSu7TvU=\ngithub.com/miekg/pkcs11 v1.1.1/go.mod h1:XsNlhZGX73bx86s2hdc/FuaLm2CPZJemRLMA+WTFxgs=\ngithub.com/mistifyio/go-zfs/v3 v3.0.1 h1:YaoXgBePoMA12+S1u/ddkv+QqxcfiZK4prI6HPnkFiU=\ngithub.com/mistifyio/go-zfs/v3 v3.0.1/go.mod h1:CzVgeB0RvF2EGzQnytKVvVSDwmKJXxkOTUGbNrTja/k=\ngithub.com/mitchellh/mapstructure v1.5.0 h1:jeMsZIYE/09sWLaz43PL7Gy6RuMjD2eJVyuac5Z2hdY=\ngithub.com/mitchellh/mapstructure v1.5.0/go.mod h1:bFUtVrKA4DC2yAKiSyO/QUcy7e+RRV2QTWOzhPopBRo=\ngithub.com/moby/buildkit v0.18.2 h1:l86uBvxh4ntNoUUg3Y0eGTbKg1PbUh6tawJ4Xt75SpQ=\ngithub.com/moby/buildkit v0.18.2/go.mod h1:vCR5CX8NGsPTthTg681+9kdmfvkvqJBXEv71GZe5msU=\ngithub.com/moby/docker-image-spec v1.3.1 h1:jMKff3w6PgbfSa69GfNg+zN/XLhfXJGnEx3Nl2EsFP0=\ngithub.com/moby/docker-image-spec v1.3.1/go.mod h1:eKmb5VW8vQEh/BAr2yvVNvuiJuY6UIocYsFu/DxxRpo=\ngithub.com/moby/patternmatcher v0.6.0 h1:GmP9lR19aU5GqSSFko+5pRqHi+Ohk1O69aFiKkVGiPk=\ngithub.com/moby/patternmatcher v0.6.0/go.mod h1:hDPoyOpDY7OrrMDLaYoY3hf52gNCR/YOUYxkhApJIxc=\ngithub.com/moby/sys/capability v0.4.0 h1:4D4mI6KlNtWMCM1Z/K0i7RV1FkX+DBDHKVJpCndZoHk=\ngithub.com/moby/sys/capability v0.4.0/go.mod h1:4g9IK291rVkms3LKCDOoYlnV8xKwoDTpIrNEE35Wq0I=\ngithub.com/moby/sys/mountinfo v0.7.2 h1:1shs6aH5s4o5H2zQLn796ADW1wMrIwHsyJ2v9KouLrg=\ngithub.com/moby/sys/mountinfo v0.7.2/go.mod h1:1YOa8w8Ih7uW0wALDUgT1dTTSBrZ+HiBLGws92L2RU4=\ngithub.com/moby/sys/sequential v0.6.0 h1:qrx7XFUd/5DxtqcoH1h438hF5TmOvzC/lspjy7zgvCU=\ngithub.com/moby/sys/sequential v0.6.0/go.mod h1:uyv8EUTrca5PnDsdMGXhZe6CCe8U/UiTWd+lL+7b/Ko=\ngithub.com/moby/sys/user v0.3.0 h1:9ni5DlcW5an3SvRSx4MouotOygvzaXbaSrc/wGDFWPo=\ngithub.com/moby/sys/user v0.3.0/go.mod h1:bG+tYYYJgaMtRKgEmuueC0hJEAZWwtIbZTB+85uoHjs=\ngithub.com/moby/sys/userns v0.1.0 h1:tVLXkFOxVu9A64/yh59slHVv9ahO9UIev4JZusOLG/g=\ngithub.com/moby/sys/userns v0.1.0/go.mod h1:IHUYgu/kao6N8YZlp9Cf444ySSvCmDlmzUcYfDHOl28=\ngithub.com/moby/term v0.5.0 h1:xt8Q1nalod/v7BqbG21f8mQPqH+xAaC9C3N3wfWbVP0=\ngithub.com/moby/term v0.5.0/go.mod h1:8FzsFHVUBGZdbDsJw/ot+X+d5HLUbvklYLJ9uGfcI3Y=\ngithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=\ngithub.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=\ngithub.com/morikuni/aec v1.0.0 h1:nP9CBfwrvYnBRgY6qfDQkygYDmYwOilePFkwzv4dU8A=\ngithub.com/morikuni/aec v1.0.0/go.mod h1:BbKIizmSmc5MMPqRYbxO4ZU0S0+P200+tUnFx7PXmsc=\ngithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 h1:C3w9PqII01/Oq1c1nUAm88MOHcQC9l5mIlSMApZMrHA=\ngithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822/go.mod h1:+n7T8mK8HuQTcFwEeznm/DIxMOiR9yIdICNftLE1DvQ=\ngithub.com/oklog/ulid v1.3.1 h1:EGfNDEx6MqHz8B3uNV6QAib1UR2Lm97sHi3ocA6ESJ4=\ngithub.com/oklog/ulid v1.3.1/go.mod h1:CirwcVhetQ6Lv90oh/F+FBtV6XMibvdAFo93nm5qn4U=\ngithub.com/onsi/ginkgo/v2 v2.21.0 h1:7rg/4f3rB88pb5obDgNZrNHrQ4e6WpjonchcpuBRnZM=\ngithub.com/onsi/ginkgo/v2 v2.21.0/go.mod h1:7Du3c42kxCUegi0IImZ1wUQzMBVecgIHjR1C+NkhLQo=\ngithub.com/onsi/gomega v1.35.1 h1:Cwbd75ZBPxFSuZ6T+rN/WCb/gOc6YgFBXLlZLhC7Ds4=\ngithub.com/onsi/gomega v1.35.1/go.mod h1:PvZbdDc8J6XJEpDK4HCuRBm8a6Fzp9/DmhC9C7yFlog=\ngithub.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=\ngithub.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=\ngithub.com/opencontainers/image-spec v1.1.0 h1:8SG7/vwALn54lVB/0yZ/MMwhFrPYtpEHQb2IpWsCzug=\ngithub.com/opencontainers/image-spec v1.1.0/go.mod h1:W4s4sFTMaBeK1BQLXbG4AdM2szdn85PY75RI83NrTrM=\ngithub.com/opencontainers/runc v1.2.4 h1:yWFgLkghp71D76Fa0l349yAl5g4Gse7DPYNlvkQ9Eiw=\ngithub.com/opencontainers/runc v1.2.4/go.mod h1:nSxcWUydXrsBZVYNSkTjoQ/N6rcyTtn+1SD5D4+kRIM=\ngithub.com/opencontainers/runtime-spec v1.2.0 h1:z97+pHb3uELt/yiAWD691HNHQIF07bE7dzrbT927iTk=\ngithub.com/opencontainers/runtime-spec v1.2.0/go.mod h1:jwyrGlmzljRJv/Fgzds9SsS/C5hL+LL3ko9hs6T5lQ0=\ngithub.com/opencontainers/runtime-tools v0.9.1-0.20241108202711-f7e3563b0271 h1:TPj0pMLCTy1CKwmrat3hqTxoZfqOuTy0asG0ccpGk8Q=\ngithub.com/opencontainers/runtime-tools v0.9.1-0.20241108202711-f7e3563b0271/go.mod h1:oIH6VwKkaDOO+SIYZpdwrC/0wKYqrfO6E1sG1j3UVws=\ngithub.com/opencontainers/selinux v1.11.1 h1:nHFvthhM0qY8/m+vfhJylliSshm8G1jJ2jDMcgULaH8=\ngithub.com/opencontainers/selinux v1.11.1/go.mod h1:E5dMC3VPuVvVHDYmi78qvhJp8+M586T4DlDRYpFkyec=\ngithub.com/openshift/imagebuilder v1.2.15 h1:MNn1OztEE/l8pSEDPYAQ71Ys6rpXA2P00UFhdY9p/yk=\ngithub.com/openshift/imagebuilder v1.2.15/go.mod h1:cK6MLyBl1IHmIYGLY/2SLOG6p0PtEDUOC7khxsFYUXE=\ngithub.com/ostreedev/ostree-go v0.0.0-20210805093236-719684c64e4f h1:/UDgs8FGMqwnHagNDPGOlts35QkhAZ8by3DR7nMih7M=\ngithub.com/ostreedev/ostree-go v0.0.0-20210805093236-719684c64e4f/go.mod h1:J6OG6YJVEWopen4avK3VNQSnALmmjvniMmni/YFYAwc=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/planetscale/vtprotobuf v0.6.1-0.20240319094008-0393e58bdf10 h1:GFCKgmp0tecUJ0sJuv4pzYCqS9+RGSn52M3FUwPs+uo=\ngithub.com/planetscale/vtprotobuf v0.6.1-0.20240319094008-0393e58bdf10/go.mod h1:t/avpk3KcrXxUnYOhZhMXJlSEyie6gQbtLq5NM3loB8=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 h1:Jamvg5psRIccs7FGNTlIRMkT8wgtp5eCXdBlqhYGL6U=\ngithub.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/proglottis/gpgme v0.1.3 h1:Crxx0oz4LKB3QXc5Ea0J19K/3ICfy3ftr5exgUK1AU0=\ngithub.com/proglottis/gpgme v0.1.3/go.mod h1:fPbW/EZ0LvwQtH8Hy7eixhp1eF3G39dtx7GUN+0Gmy0=\ngithub.com/prometheus/client_golang v1.20.2 h1:5ctymQzZlyOON1666svgwn3s6IKWgfbjsejTMiXIyjg=\ngithub.com/prometheus/client_golang v1.20.2/go.mod h1:PIEt8X02hGcP8JWbeHyeZ53Y/jReSnHgO035n//V5WE=\ngithub.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/client_model v0.6.1 h1:ZKSh/rekM+n3CeS952MLRAdFwIKqeY8b62p8ais2e9E=\ngithub.com/prometheus/client_model v0.6.1/go.mod h1:OrxVMOVHjw3lKMa8+x6HeMGkHMQyHDk9E3jmP2AmGiY=\ngithub.com/prometheus/common v0.57.0 h1:Ro/rKjwdq9mZn1K5QPctzh+MA4Lp0BuYk5ZZEVhoNcY=\ngithub.com/prometheus/common v0.57.0/go.mod h1:7uRPFSUTbfZWsJ7MHY56sqt7hLQu3bxXHDnNhl8E9qI=\ngithub.com/prometheus/procfs v0.15.1 h1:YagwOFzUgYfKKHX6Dr+sHT7km/hxC76UB0learggepc=\ngithub.com/prometheus/procfs v0.15.1/go.mod h1:fB45yRUv8NstnjriLhBQLuOUt+WW4BsoGhij/e3PBqk=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=\ngithub.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/rogpeppe/go-internal v1.12.0 h1:exVL4IDcn6na9z1rAb56Vxr+CgyK3nn3O+epU5NdKM8=\ngithub.com/rogpeppe/go-internal v1.12.0/go.mod h1:E+RYuTGaKKdloAfM02xzb0FW3Paa99yedzYV+kq4uf4=\ngithub.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/sebdah/goldie/v2 v2.5.5 h1:rx1mwF95RxZ3/83sdS4Yp7t2C5TCokvWP4TBRbAyEWY=\ngithub.com/sebdah/goldie/v2 v2.5.5/go.mod h1:oZ9fp0+se1eapSRjfYbsV/0Hqhbuu3bJVvKI/NNtssI=\ngithub.com/seccomp/libseccomp-golang v0.10.0 h1:aA4bp+/Zzi0BnWZ2F1wgNBs5gTpm+na2rWM6M9YjLpY=\ngithub.com/seccomp/libseccomp-golang v0.10.0/go.mod h1:JA8cRccbGaA1s33RQf7Y1+q9gHmZX1yB/z9WDN1C6fg=\ngithub.com/secure-systems-lab/go-securesystemslib v0.8.0 h1:mr5An6X45Kb2nddcFlbmfHkLguCE9laoZCUzEEpIZXA=\ngithub.com/secure-systems-lab/go-securesystemslib v0.8.0/go.mod h1:UH2VZVuJfCYR8WgMlCU1uFsOUU+KeyrTWcSS73NBOzU=\ngithub.com/sergi/go-diff v1.3.1 h1:xkr+Oxo4BOQKmkn/B9eMK0g5Kg/983T9DqqPHwYqD+8=\ngithub.com/sergi/go-diff v1.3.1/go.mod h1:aMJSSKb2lpPvRNec0+w3fl7LP9IOFzdc9Pa4NFbPK1I=\ngithub.com/sigstore/fulcio v1.6.4 h1:d86obfxUAG3Y6CYwOx1pdwCZwKmROB6w6927pKOVIRY=\ngithub.com/sigstore/fulcio v1.6.4/go.mod h1:Y6bn3i3KGhXpaHsAtYP3Z4Np0+VzCo1fLv8Ci6mbPDs=\ngithub.com/sigstore/rekor v1.3.6 h1:QvpMMJVWAp69a3CHzdrLelqEqpTM3ByQRt5B5Kspbi8=\ngithub.com/sigstore/rekor v1.3.6/go.mod h1:JDTSNNMdQ/PxdsS49DJkJ+pRJCO/83nbR5p3aZQteXc=\ngithub.com/sigstore/sigstore v1.8.9 h1:NiUZIVWywgYuVTxXmRoTT4O4QAGiTEKup4N1wdxFadk=\ngithub.com/sigstore/sigstore v1.8.9/go.mod h1:d9ZAbNDs8JJfxJrYmulaTazU3Pwr8uLL9+mii4BNR3w=\ngithub.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=\ngithub.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=\ngithub.com/smallstep/pkcs7 v0.1.1 h1:x+rPdt2W088V9Vkjho4KtoggyktZJlMduZAtRHm68LU=\ngithub.com/smallstep/pkcs7 v0.1.1/go.mod h1:dL6j5AIz9GHjVEBTXtW+QliALcgM19RtXaTeyxI+AfA=\ngithub.com/spf13/cobra v1.8.1 h1:e5/vxKd/rZsfSJMUX1agtjeTDf+qv1/JdBF8gg5k9ZM=\ngithub.com/spf13/cobra v1.8.1/go.mod h1:wHxEcudfqmLYa8iTfL+OuZPbBZkmvliBWKIezN3kD9Y=\ngithub.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=\ngithub.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngithub.com/stefanberger/go-pkcs11uri v0.0.0-20230803200340-78284954bff6 h1:pnnLyeX7o/5aX8qUQ69P/mLojDqwda8hFOCBTmP/6hw=\ngithub.com/stefanberger/go-pkcs11uri v0.0.0-20230803200340-78284954bff6/go.mod h1:39R/xuhNgVhi+K0/zst4TLrJrVmbm6LVgl4A0+ZFS5M=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/sylabs/sif/v2 v2.19.1 h1:1eeMmFc8elqJe60ZiWwXgL3gMheb0IP4GmNZ4q0IEA0=\ngithub.com/sylabs/sif/v2 v2.19.1/go.mod h1:U1SUhvl8X1JIxAylC0DYz1fa/Xba6EMZD1dGPGBH83E=\ngithub.com/syndtr/gocapability v0.0.0-20200815063812-42c35b437635 h1:kdXcSzyDtseVEc4yCz2qF8ZrQvIDBJLl4S1c3GCXmoI=\ngithub.com/syndtr/gocapability v0.0.0-20200815063812-42c35b437635/go.mod h1:hkRG7XYTFWNJGYcbNJQlaLq0fg1yr4J4t/NcTQtrfww=\ngithub.com/tchap/go-patricia/v2 v2.3.1 h1:6rQp39lgIYZ+MHmdEq4xzuk1t7OdC35z/xm0BGhTkes=\ngithub.com/tchap/go-patricia/v2 v2.3.1/go.mod h1:VZRHKAb53DLaG+nA9EaYYiaEx6YztwDlLElMsnSHD4k=\ngithub.com/titanous/rocacheck v0.0.0-20171023193734-afe73141d399 h1:e/5i7d4oYZ+C1wj2THlRK+oAhjeS/TRQwMfkIuet3w0=\ngithub.com/titanous/rocacheck v0.0.0-20171023193734-afe73141d399/go.mod h1:LdwHTNJT99C5fTAzDz0ud328OgXz+gierycbcIx2fRs=\ngithub.com/ulikunitz/xz v0.5.12 h1:37Nm15o69RwBkXM0J6A5OlE67RZTfzUxTj8fB3dfcsc=\ngithub.com/ulikunitz/xz v0.5.12/go.mod h1:nbz6k7qbPmH4IRqmfOplQw/tblSgqTqBwxkY0oWt/14=\ngithub.com/vbatts/tar-split v0.11.6 h1:4SjTW5+PU11n6fZenf2IPoV8/tz3AaYHMWjf23envGs=\ngithub.com/vbatts/tar-split v0.11.6/go.mod h1:dqKNtesIOr2j2Qv3W/cHjnvk9I8+G7oAkFDFN6TCBEI=\ngithub.com/vbauerster/mpb/v8 v8.8.3 h1:dTOByGoqwaTJYPubhVz3lO5O6MK553XVgUo33LdnNsQ=\ngithub.com/vbauerster/mpb/v8 v8.8.3/go.mod h1:JfCCrtcMsJwP6ZwMn9e5LMnNyp3TVNpUWWkN+nd4EWk=\ngithub.com/vishvananda/netlink v1.3.0 h1:X7l42GfcV4S6E4vHTsw48qbrV+9PVojNfIhZcwQdrZk=\ngithub.com/vishvananda/netlink v1.3.0/go.mod h1:i6NetklAujEcC6fK0JPjT8qSwWyO0HLn4UKG+hGqeJs=\ngithub.com/vishvananda/netns v0.0.4 h1:Oeaw1EM2JMxD51g9uhtC0D7erkIjgmj8+JZc26m1YX8=\ngithub.com/vishvananda/netns v0.0.4/go.mod h1:SpkAiCQRtJ6TvvxPnOSyH3BMl6unz3xZlaprSwhNNJM=\ngithub.com/xeipuuv/gojsonpointer v0.0.0-20190905194746-02993c407bfb h1:zGWFAtiMcyryUHoUjUJX0/lt1H2+i2Ka2n+D3DImSNo=\ngithub.com/xeipuuv/gojsonpointer v0.0.0-20190905194746-02993c407bfb/go.mod h1:N2zxlSyiKSe5eX1tZViRH5QA0qijqEDrYZiPEAiq3wU=\ngithub.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 h1:EzJWgHovont7NscjpAxXsDA8S8BMYve8Y5+7cuRE7R0=\ngithub.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415/go.mod h1:GwrjFmJcFw6At/Gs6z4yjiIwzuJ1/+UwLxMQDVQXShQ=\ngithub.com/xeipuuv/gojsonschema v1.2.0 h1:LhYJRs+L4fBtjZUfuSZIKGeVu0QRy8e5Xi7D17UxZ74=\ngithub.com/xeipuuv/gojsonschema v1.2.0/go.mod h1:anYRn/JVcOK2ZgGU+IjEV4nwlhoK5sQluxsYJ78Id3Y=\ngithub.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngo.etcd.io/bbolt v1.3.11 h1:yGEzV1wPz2yVCLsD8ZAiGHhHVlczyC9d1rP43/VCRJ0=\ngo.etcd.io/bbolt v1.3.11/go.mod h1:dksAq7YMXoljX0xu6VF5DMZGbhYYoLUalEiSySYAS4I=\ngo.mongodb.org/mongo-driver v1.14.0 h1:P98w8egYRjYe3XDjxhYJagTokP/H6HzlsnojRgZRd80=\ngo.mongodb.org/mongo-driver v1.14.0/go.mod h1:Vzb0Mk/pa7e6cWw85R4F/endUC3u0U9jGcNU603k65c=\ngo.opencensus.io v0.24.0 h1:y73uSU6J157QMP2kn2r30vwW1A2W2WFwSCGnAVxeaD0=\ngo.opencensus.io v0.24.0/go.mod h1:vNK8G9p7aAivkbmorf4v+7Hgx+Zs0yY+0fOtgBfjQKo=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.53.0 h1:4K4tsIXefpVJtvA/8srF4V4y0akAoPHkIslgAkjixJA=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.53.0/go.mod h1:jjdQuTGVsXV4vSs+CJ2qYDeDPf9yIJV23qlIzBm73Vg=\ngo.opentelemetry.io/otel v1.28.0 h1:/SqNcYk+idO0CxKEUOtKQClMK/MimZihKYMruSMViUo=\ngo.opentelemetry.io/otel v1.28.0/go.mod h1:q68ijF8Fc8CnMHKyzqL6akLO46ePnjkgfIMIjUIX9z4=\ngo.opentelemetry.io/otel/exporters/otlp/otlptrace v1.28.0 h1:3Q/xZUyC1BBkualc9ROb4G8qkH90LXEIICcs5zv1OYY=\ngo.opentelemetry.io/otel/exporters/otlp/otlptrace v1.28.0/go.mod h1:s75jGIWA9OfCMzF0xr+ZgfrB5FEbbV7UuYo32ahUiFI=\ngo.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.28.0 h1:j9+03ymgYhPKmeXGk5Zu+cIZOlVzd9Zv7QIiyItjFBU=\ngo.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.28.0/go.mod h1:Y5+XiUG4Emn1hTfciPzGPJaSI+RpDts6BnCIir0SLqk=\ngo.opentelemetry.io/otel/metric v1.28.0 h1:f0HGvSl1KRAU1DLgLGFjrwVyismPlnuU6JD6bOeuA5Q=\ngo.opentelemetry.io/otel/metric v1.28.0/go.mod h1:Fb1eVBFZmLVTMb6PPohq3TO9IIhUisDsbJoL/+uQW4s=\ngo.opentelemetry.io/otel/sdk v1.28.0 h1:b9d7hIry8yZsgtbmM0DKyPWMMUMlK9NEKuIG4aBqWyE=\ngo.opentelemetry.io/otel/sdk v1.28.0/go.mod h1:oYj7ClPUA7Iw3m+r7GeEjz0qckQRJK2B8zjcZEfu7Pg=\ngo.opentelemetry.io/otel/trace v1.28.0 h1:GhQ9cUuQGmNDd5BTCP2dAvv75RdMxEfTmYejp+lkx9g=\ngo.opentelemetry.io/otel/trace v1.28.0/go.mod h1:jPyXzNPg6da9+38HEwElrQiHlVMTnVfM3/yv2OlIHaI=\ngo.opentelemetry.io/proto/otlp v1.3.1 h1:TrMUixzpM0yuc/znrFTP9MMRh8trP93mkCiDVeXrui0=\ngo.opentelemetry.io/proto/otlp v1.3.1/go.mod h1:0X1WI4de4ZsLrrJNLAQbFeLCm3T7yBkR0XqQ7niQU+8=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.13.0/go.mod h1:y6Z2r+Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliYc=\ngolang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=\ngolang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR+mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=\ngolang.org/x/crypto v0.30.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/crypto v0.32.0 h1:euUpcYgM8WcP71gNpTqQCn6rC2t6ULUPiOzfWaXVVfc=\ngolang.org/x/crypto v0.32.0/go.mod h1:ZnnJkOaASj8g0AjIduWNlq2NRxL0PlBrbKVyZ6V/Ugc=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20241108190413-2d47ceb2692f h1:XdNn9LlyWAhLVp6P/i8QYBW+hlyhrhei9uErw2B5GJo=\ngolang.org/x/exp v0.0.0-20241108190413-2d47ceb2692f/go.mod h1:D5SMRVC3C2/4+F/DB1wZsLRnSNimn2Sp/NPsCrsv8ak=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.15.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/mod v0.22.0 h1:D4nJWe9zXqHOmWqj4VMOJhvzj7bEZg4wEYa759z1pH4=\ngolang.org/x/mod v0.22.0/go.mod h1:6SkKJ3Xj0I0BrPOZoBy3bdMptDDU9oJrpohJ3eWZ1fY=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20201110031124-69a78807bb2b/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=\ngolang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=\ngolang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=\ngolang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=\ngolang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181122145206-62eef0e2fa9b/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210616094352-59db8d763f22/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220310020820-b874c991c1a5/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.10.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=\ngolang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/telemetry v0.0.0-20240228155512-f48c80bd79b2/go.mod h1:TeRTkGYfJXctD9OcfyVLyj2J3IxLnKwHJR8f4D8a3YE=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=\ngolang.org/x/term v0.12.0/go.mod h1:owVbMEjm3cBLCHdkQu9b1opXd4ETQWc3BhuQGKgXgvU=\ngolang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=\ngolang.org/x/term v0.20.0/go.mod h1:8UkIAJTvZgivsXaD6/pH6U9ecQzZ45awqEOzuCvwpFY=\ngolang.org/x/term v0.27.0/go.mod h1:iMsnZpn0cago0GOrHO2+Y7u7JPn5AylBrcoWkElMTSM=\ngolang.org/x/term v0.28.0 h1:/Ts8HFuMR2E6IP/jlo7QVLZHggjKQbhu/7H0LJFr3Gg=\ngolang.org/x/term v0.28.0/go.mod h1:Sw/lC2IAUZ92udQNf3WodGtn4k/XoLyZoh8v/8uiwek=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/time v0.6.0 h1:eTDhh4ZXt5Qf0augr54TN6suAUudPcawVZeIAPU7D4U=\ngolang.org/x/time v0.6.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=\ngolang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=\ngolang.org/x/tools v0.27.0 h1:qEKojBykQkQ4EynWy4S8Weg69NumxKdn40Fce3uc/8o=\ngolang.org/x/tools v0.27.0/go.mod h1:sUi0ZgbwW9ZPAq26Ekut+weQPR5eIM6GQLQ1Yjm1H0Q=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=\ngoogle.golang.org/genproto v0.0.0-20240823204242-4ba0660f739c h1:TYOEhrQMrNDTAd2rX9m+WgGr8Ku6YNuj1D7OX6rWSok=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20240903143218-8af14fe29dc1 h1:hjSy6tcFQZ171igDaN5QHOw2n6vx40juYbC/x67CEhc=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20240903143218-8af14fe29dc1/go.mod h1:qpvKtACPCQhAdu3PyQgV4l3LMXZEtft7y8QcarRsp9I=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20240903143218-8af14fe29dc1 h1:pPJltXNxVzT4pK9yD8vR9X75DaWYYmLGMsEvBfFQZzQ=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20240903143218-8af14fe29dc1/go.mod h1:UqMtugtsSgubUsoxbuAoiCXvqvErP7Gf0so0mK9tHxU=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=\ngoogle.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=\ngoogle.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=\ngoogle.golang.org/grpc v1.33.2/go.mod h1:JMHMWHQWaTccqQQlmk3MJZS+GWXOdAesneDmEnv2fbc=\ngoogle.golang.org/grpc v1.68.1 h1:oI5oTa11+ng8r8XMMN7jAOmWfPZWbYpCFaMUTACxkM0=\ngoogle.golang.org/grpc v1.68.1/go.mod h1:+q1XYFJjShcqn0QZHvCyeR4CXPA+llXIeUIfIe00waw=\ngoogle.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=\ngoogle.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=\ngoogle.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=\ngoogle.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=\ngoogle.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=\ngoogle.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=\ngoogle.golang.org/protobuf v1.35.1 h1:m3LfL6/Ca+fqnjnlqQXNpFPABW1UD7mjh8KO2mKFytA=\ngoogle.golang.org/protobuf v1.35.1/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngotest.tools v2.2.0+incompatible h1:VsBPFP1AI068pPrMxtb/S8Zkgf9xEmTLJjfM+P5UIEo=\ngotest.tools v2.2.0+incompatible/go.mod h1:DsYFclhRJ6vuDpmuTbkuFWG+y2sxOXAzmJt81HFBacw=\ngotest.tools/v3 v3.5.1 h1:EENdUnS3pdur5nybKYIh2Vfgc8IUNBjxDPSjtiJcOzU=\ngotest.tools/v3 v3.5.1/go.mod h1:isy3WKz7GK6uNw/sbHzfKBLvlvXwUyV06n6brMxxopU=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nk8s.io/klog v1.0.0 h1:Pt+yjF5aB1xDSVbau4VsWe+dQNzA0qv1LlXdC2dF6Q8=\nk8s.io/klog v1.0.0/go.mod h1:4Bi6QPql/J/LkTDqv7R/cd3hPo4k2DG6Ptcz060Ez5I=\nsigs.k8s.io/yaml v1.4.0 h1:Mk1wCc2gy/F0THH0TAp1QYyJNzRm2KCLy3o5ASXVI5E=\nsigs.k8s.io/yaml v1.4.0/go.mod h1:Ejl7/uTz7PSA4eKMyQCUTnhZYNmLIl+5c2lQPGR2BPY=\ntags.cncf.io/container-device-interface v0.8.0 h1:8bCFo/g9WODjWx3m6EYl3GfUG31eKJbaggyBDxEldRc=\ntags.cncf.io/container-device-interface v0.8.0/go.mod h1:Apb7N4VdILW0EVdEMRYXIDVRZfNJZ+kmEUss2kRRQ6Y=\ntags.cncf.io/container-device-interface/specs-go v0.8.0 h1:QYGFzGxvYK/ZLMrjhvY0RjpUavIn4KcmRmVP/JjdBTA=\ntags.cncf.io/container-device-interface/specs-go v0.8.0/go.mod h1:BhJIkjjPh4qpys+qm4DAYtUyryaTDg9zris+AczXyws=\n"
        },
        {
          "name": "hack",
          "type": "tree",
          "content": null
        },
        {
          "name": "image.go",
          "type": "blob",
          "size": 45.583984375,
          "content": "package buildah\n\nimport (\n\t\"archive/tar\"\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/containers/buildah/copier\"\n\t\"github.com/containers/buildah/define\"\n\t\"github.com/containers/buildah/docker\"\n\t\"github.com/containers/buildah/internal/config\"\n\t\"github.com/containers/buildah/internal/mkcw\"\n\t\"github.com/containers/buildah/internal/tmpdir\"\n\t\"github.com/containers/image/v5/docker/reference\"\n\t\"github.com/containers/image/v5/image\"\n\t\"github.com/containers/image/v5/manifest\"\n\tis \"github.com/containers/image/v5/storage\"\n\t\"github.com/containers/image/v5/types\"\n\t\"github.com/containers/storage\"\n\t\"github.com/containers/storage/pkg/archive\"\n\t\"github.com/containers/storage/pkg/chrootarchive\"\n\t\"github.com/containers/storage/pkg/idtools\"\n\t\"github.com/containers/storage/pkg/ioutils\"\n\tdigest \"github.com/opencontainers/go-digest\"\n\tspecs \"github.com/opencontainers/image-spec/specs-go\"\n\tv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/exp/maps\"\n\t\"golang.org/x/exp/slices\"\n)\n\nconst (\n\t// OCIv1ImageManifest is the MIME type of an OCIv1 image manifest,\n\t// suitable for specifying as a value of the PreferredManifestType\n\t// member of a CommitOptions structure.  It is also the default.\n\tOCIv1ImageManifest = define.OCIv1ImageManifest\n\t// Dockerv2ImageManifest is the MIME type of a Docker v2s2 image\n\t// manifest, suitable for specifying as a value of the\n\t// PreferredManifestType member of a CommitOptions structure.\n\tDockerv2ImageManifest = define.Dockerv2ImageManifest\n)\n\n// ExtractRootfsOptions is consumed by ExtractRootfs() which allows users to\n// control whether various information like the like setuid and setgid bits and\n// xattrs are preserved when extracting file system objects.\ntype ExtractRootfsOptions struct {\n\tStripSetuidBit bool // strip the setuid bit off of items being extracted.\n\tStripSetgidBit bool // strip the setgid bit off of items being extracted.\n\tStripXattrs    bool // don't record extended attributes of items being extracted.\n}\n\ntype containerImageRef struct {\n\tfromImageName         string\n\tfromImageID           string\n\tstore                 storage.Store\n\tcompression           archive.Compression\n\tname                  reference.Named\n\tnames                 []string\n\tcontainerID           string\n\tmountLabel            string\n\tlayerID               string\n\toconfig               []byte\n\tdconfig               []byte\n\tcreated               *time.Time\n\tcreatedBy             string\n\thistoryComment        string\n\tannotations           map[string]string\n\tpreferredManifestType string\n\tsquash                bool\n\tconfidentialWorkload  ConfidentialWorkloadOptions\n\tomitHistory           bool\n\temptyLayer            bool\n\tidMappingOptions      *define.IDMappingOptions\n\tparent                string\n\tblobDirectory         string\n\tpreEmptyLayers        []v1.History\n\tpreLayers             []commitLinkedLayerInfo\n\tpostEmptyLayers       []v1.History\n\tpostLayers            []commitLinkedLayerInfo\n\toverrideChanges       []string\n\toverrideConfig        *manifest.Schema2Config\n\textraImageContent     map[string]string\n\tcompatSetParent       types.OptionalBool\n}\n\ntype blobLayerInfo struct {\n\tID   string\n\tSize int64\n}\n\ntype commitLinkedLayerInfo struct {\n\tlayerID            string // more like layer \"ID\"\n\tlinkedLayer        LinkedLayer\n\tuncompressedDigest digest.Digest\n\tsize               int64\n}\n\ntype containerImageSource struct {\n\tpath          string\n\tref           *containerImageRef\n\tstore         storage.Store\n\tcontainerID   string\n\tmountLabel    string\n\tlayerID       string\n\tnames         []string\n\tcompression   archive.Compression\n\tconfig        []byte\n\tconfigDigest  digest.Digest\n\tmanifest      []byte\n\tmanifestType  string\n\tblobDirectory string\n\tblobLayers    map[digest.Digest]blobLayerInfo\n}\n\nfunc (i *containerImageRef) NewImage(ctx context.Context, sc *types.SystemContext) (types.ImageCloser, error) {\n\tsrc, err := i.NewImageSource(ctx, sc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn image.FromSource(ctx, sc, src)\n}\n\nfunc expectedOCIDiffIDs(image v1.Image) int {\n\texpected := 0\n\tfor _, history := range image.History {\n\t\tif !history.EmptyLayer {\n\t\t\texpected = expected + 1\n\t\t}\n\t}\n\treturn expected\n}\n\nfunc expectedDockerDiffIDs(image docker.V2Image) int {\n\texpected := 0\n\tfor _, history := range image.History {\n\t\tif !history.EmptyLayer {\n\t\t\texpected = expected + 1\n\t\t}\n\t}\n\treturn expected\n}\n\n// Compute the media types which we need to attach to a layer, given the type of\n// compression that we'll be applying.\nfunc computeLayerMIMEType(what string, layerCompression archive.Compression) (omediaType, dmediaType string, err error) {\n\tomediaType = v1.MediaTypeImageLayer\n\tdmediaType = docker.V2S2MediaTypeUncompressedLayer\n\tif layerCompression != archive.Uncompressed {\n\t\tswitch layerCompression {\n\t\tcase archive.Gzip:\n\t\t\tomediaType = v1.MediaTypeImageLayerGzip\n\t\t\tdmediaType = manifest.DockerV2Schema2LayerMediaType\n\t\t\tlogrus.Debugf(\"compressing %s with gzip\", what)\n\t\tcase archive.Bzip2:\n\t\t\t// Until the image specs define a media type for bzip2-compressed layers, even if we know\n\t\t\t// how to decompress them, we can't try to compress layers with bzip2.\n\t\t\treturn \"\", \"\", errors.New(\"media type for bzip2-compressed layers is not defined\")\n\t\tcase archive.Xz:\n\t\t\t// Until the image specs define a media type for xz-compressed layers, even if we know\n\t\t\t// how to decompress them, we can't try to compress layers with xz.\n\t\t\treturn \"\", \"\", errors.New(\"media type for xz-compressed layers is not defined\")\n\t\tcase archive.Zstd:\n\t\t\t// Until the image specs define a media type for zstd-compressed layers, even if we know\n\t\t\t// how to decompress them, we can't try to compress layers with zstd.\n\t\t\treturn \"\", \"\", errors.New(\"media type for zstd-compressed layers is not defined\")\n\t\tdefault:\n\t\t\tlogrus.Debugf(\"compressing %s with unknown compressor(?)\", what)\n\t\t}\n\t}\n\treturn omediaType, dmediaType, nil\n}\n\n// Extract the container's whole filesystem as a filesystem image, wrapped\n// in LUKS-compatible encryption.\nfunc (i *containerImageRef) extractConfidentialWorkloadFS(options ConfidentialWorkloadOptions) (io.ReadCloser, error) {\n\tvar image v1.Image\n\tif err := json.Unmarshal(i.oconfig, &image); err != nil {\n\t\treturn nil, fmt.Errorf(\"recreating OCI configuration for %q: %w\", i.containerID, err)\n\t}\n\tif options.TempDir == \"\" {\n\t\tcdir, err := i.store.ContainerDirectory(i.containerID)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"getting the per-container data directory for %q: %w\", i.containerID, err)\n\t\t}\n\t\ttempdir, err := os.MkdirTemp(cdir, \"buildah-rootfs\")\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"creating a temporary data directory to hold a rootfs image for %q: %w\", i.containerID, err)\n\t\t}\n\t\tdefer func() {\n\t\t\tif err := os.RemoveAll(tempdir); err != nil {\n\t\t\t\tlogrus.Warnf(\"removing temporary directory %q: %v\", tempdir, err)\n\t\t\t}\n\t\t}()\n\t\toptions.TempDir = tempdir\n\t}\n\tmountPoint, err := i.store.Mount(i.containerID, i.mountLabel)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"mounting container %q: %w\", i.containerID, err)\n\t}\n\tarchiveOptions := mkcw.ArchiveOptions{\n\t\tAttestationURL:           options.AttestationURL,\n\t\tCPUs:                     options.CPUs,\n\t\tMemory:                   options.Memory,\n\t\tTempDir:                  options.TempDir,\n\t\tTeeType:                  options.TeeType,\n\t\tIgnoreAttestationErrors:  options.IgnoreAttestationErrors,\n\t\tWorkloadID:               options.WorkloadID,\n\t\tDiskEncryptionPassphrase: options.DiskEncryptionPassphrase,\n\t\tSlop:                     options.Slop,\n\t\tFirmwareLibrary:          options.FirmwareLibrary,\n\t\tGraphOptions:             i.store.GraphOptions(),\n\t\tExtraImageContent:        i.extraImageContent,\n\t}\n\trc, _, err := mkcw.Archive(mountPoint, &image, archiveOptions)\n\tif err != nil {\n\t\tif _, err2 := i.store.Unmount(i.containerID, false); err2 != nil {\n\t\t\tlogrus.Debugf(\"unmounting container %q: %v\", i.containerID, err2)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"converting rootfs %q: %w\", i.containerID, err)\n\t}\n\treturn ioutils.NewReadCloserWrapper(rc, func() error {\n\t\tif err = rc.Close(); err != nil {\n\t\t\terr = fmt.Errorf(\"closing tar archive of container %q: %w\", i.containerID, err)\n\t\t}\n\t\tif _, err2 := i.store.Unmount(i.containerID, false); err == nil {\n\t\t\tif err2 != nil {\n\t\t\t\terr2 = fmt.Errorf(\"unmounting container %q: %w\", i.containerID, err2)\n\t\t\t}\n\t\t\terr = err2\n\t\t} else {\n\t\t\tlogrus.Debugf(\"unmounting container %q: %v\", i.containerID, err2)\n\t\t}\n\t\treturn err\n\t}), nil\n}\n\n// Extract the container's whole filesystem as if it were a single layer.\n// The ExtractRootfsOptions control whether or not to preserve setuid and\n// setgid bits and extended attributes on contents.\nfunc (i *containerImageRef) extractRootfs(opts ExtractRootfsOptions) (io.ReadCloser, chan error, error) {\n\tvar uidMap, gidMap []idtools.IDMap\n\tmountPoint, err := i.store.Mount(i.containerID, i.mountLabel)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"mounting container %q: %w\", i.containerID, err)\n\t}\n\tpipeReader, pipeWriter := io.Pipe()\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\tdefer close(errChan)\n\t\tif len(i.extraImageContent) > 0 {\n\t\t\t// Abuse the tar format and _prepend_ the synthesized\n\t\t\t// data items to the archive we'll get from\n\t\t\t// copier.Get(), in a way that looks right to a reader\n\t\t\t// as long as we DON'T Close() the tar Writer.\n\t\t\tfilename, _, _, err := i.makeExtraImageContentDiff(false)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfile, err := os.Open(filename)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer file.Close()\n\t\t\tif _, err = io.Copy(pipeWriter, file); err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif i.idMappingOptions != nil {\n\t\t\tuidMap, gidMap = convertRuntimeIDMaps(i.idMappingOptions.UIDMap, i.idMappingOptions.GIDMap)\n\t\t}\n\t\tcopierOptions := copier.GetOptions{\n\t\t\tUIDMap:         uidMap,\n\t\t\tGIDMap:         gidMap,\n\t\t\tStripSetuidBit: opts.StripSetuidBit,\n\t\t\tStripSetgidBit: opts.StripSetgidBit,\n\t\t\tStripXattrs:    opts.StripXattrs,\n\t\t}\n\t\terr := copier.Get(mountPoint, mountPoint, copierOptions, []string{\".\"}, pipeWriter)\n\t\terrChan <- err\n\t\tpipeWriter.Close()\n\t}()\n\treturn ioutils.NewReadCloserWrapper(pipeReader, func() error {\n\t\tif err = pipeReader.Close(); err != nil {\n\t\t\terr = fmt.Errorf(\"closing tar archive of container %q: %w\", i.containerID, err)\n\t\t}\n\t\tif _, err2 := i.store.Unmount(i.containerID, false); err == nil {\n\t\t\tif err2 != nil {\n\t\t\t\terr2 = fmt.Errorf(\"unmounting container %q: %w\", i.containerID, err2)\n\t\t\t}\n\t\t\terr = err2\n\t\t}\n\t\treturn err\n\t}), errChan, nil\n}\n\n// Build fresh copies of the container configuration structures so that we can edit them\n// without making unintended changes to the original Builder.\nfunc (i *containerImageRef) createConfigsAndManifests() (v1.Image, v1.Manifest, docker.V2Image, docker.V2S2Manifest, error) {\n\tcreated := time.Now().UTC()\n\tif i.created != nil {\n\t\tcreated = *i.created\n\t}\n\n\t// Build an empty image, and then decode over it.\n\toimage := v1.Image{}\n\tif err := json.Unmarshal(i.oconfig, &oimage); err != nil {\n\t\treturn v1.Image{}, v1.Manifest{}, docker.V2Image{}, docker.V2S2Manifest{}, err\n\t}\n\t// Always replace this value, since we're newer than our base image.\n\toimage.Created = &created\n\t// Clear the list of diffIDs, since we always repopulate it.\n\toimage.RootFS.Type = docker.TypeLayers\n\toimage.RootFS.DiffIDs = []digest.Digest{}\n\t// Only clear the history if we're squashing, otherwise leave it be so that we can append\n\t// entries to it.\n\tif i.confidentialWorkload.Convert || i.squash || i.omitHistory {\n\t\toimage.History = []v1.History{}\n\t}\n\n\t// Build an empty image, and then decode over it.\n\tdimage := docker.V2Image{}\n\tif err := json.Unmarshal(i.dconfig, &dimage); err != nil {\n\t\treturn v1.Image{}, v1.Manifest{}, docker.V2Image{}, docker.V2S2Manifest{}, err\n\t}\n\t// Set the parent, but only if we want to be compatible with \"classic\" docker build.\n\tif i.compatSetParent == types.OptionalBoolTrue {\n\t\tdimage.Parent = docker.ID(i.parent)\n\t}\n\t// Set the container ID and containerConfig in the docker format.\n\tdimage.Container = i.containerID\n\tif dimage.Config != nil {\n\t\tdimage.ContainerConfig = *dimage.Config\n\t}\n\t// Always replace this value, since we're newer than our base image.\n\tdimage.Created = created\n\t// Clear the list of diffIDs, since we always repopulate it.\n\tdimage.RootFS = &docker.V2S2RootFS{}\n\tdimage.RootFS.Type = docker.TypeLayers\n\tdimage.RootFS.DiffIDs = []digest.Digest{}\n\t// Only clear the history if we're squashing, otherwise leave it be so\n\t// that we can append entries to it.  Clear the parent, too, to reflect\n\t// that we no longer include its layers and history.\n\tif i.confidentialWorkload.Convert || i.squash || i.omitHistory {\n\t\tdimage.Parent = \"\"\n\t\tdimage.History = []docker.V2S2History{}\n\t}\n\n\t// If we were supplied with a configuration, copy fields from it to\n\t// matching fields in both formats.\n\tif err := config.Override(dimage.Config, &oimage.Config, i.overrideChanges, i.overrideConfig); err != nil {\n\t\treturn v1.Image{}, v1.Manifest{}, docker.V2Image{}, docker.V2S2Manifest{}, fmt.Errorf(\"applying changes: %w\", err)\n\t}\n\n\t// If we're producing a confidential workload, override the command and\n\t// assorted other settings that aren't expected to work correctly.\n\tif i.confidentialWorkload.Convert {\n\t\tdimage.Config.Entrypoint = []string{\"/entrypoint\"}\n\t\toimage.Config.Entrypoint = []string{\"/entrypoint\"}\n\t\tdimage.Config.Cmd = nil\n\t\toimage.Config.Cmd = nil\n\t\tdimage.Config.User = \"\"\n\t\toimage.Config.User = \"\"\n\t\tdimage.Config.WorkingDir = \"\"\n\t\toimage.Config.WorkingDir = \"\"\n\t\tdimage.Config.Healthcheck = nil\n\t\tdimage.Config.Shell = nil\n\t\tdimage.Config.Volumes = nil\n\t\toimage.Config.Volumes = nil\n\t\tdimage.Config.ExposedPorts = nil\n\t\toimage.Config.ExposedPorts = nil\n\t}\n\n\t// Build empty manifests.  The Layers lists will be populated later.\n\tomanifest := v1.Manifest{\n\t\tVersioned: specs.Versioned{\n\t\t\tSchemaVersion: 2,\n\t\t},\n\t\tMediaType: v1.MediaTypeImageManifest,\n\t\tConfig: v1.Descriptor{\n\t\t\tMediaType: v1.MediaTypeImageConfig,\n\t\t},\n\t\tLayers:      []v1.Descriptor{},\n\t\tAnnotations: i.annotations,\n\t}\n\n\tdmanifest := docker.V2S2Manifest{\n\t\tV2Versioned: docker.V2Versioned{\n\t\t\tSchemaVersion: 2,\n\t\t\tMediaType:     manifest.DockerV2Schema2MediaType,\n\t\t},\n\t\tConfig: docker.V2S2Descriptor{\n\t\t\tMediaType: manifest.DockerV2Schema2ConfigMediaType,\n\t\t},\n\t\tLayers: []docker.V2S2Descriptor{},\n\t}\n\n\treturn oimage, omanifest, dimage, dmanifest, nil\n}\n\nfunc (i *containerImageRef) NewImageSource(_ context.Context, _ *types.SystemContext) (src types.ImageSource, err error) {\n\t// Decide which type of manifest and configuration output we're going to provide.\n\tmanifestType := i.preferredManifestType\n\t// If it's not a format we support, return an error.\n\tif manifestType != v1.MediaTypeImageManifest && manifestType != manifest.DockerV2Schema2MediaType {\n\t\treturn nil, fmt.Errorf(\"no supported manifest types (attempted to use %q, only know %q and %q)\",\n\t\t\tmanifestType, v1.MediaTypeImageManifest, manifest.DockerV2Schema2MediaType)\n\t}\n\t// These maps will let us check if a layer ID is part of one group or another.\n\tparentLayerIDs := make(map[string]bool)\n\tapiLayerIDs := make(map[string]bool)\n\t// Start building the list of layers with any prepended layers.\n\tlayers := []string{}\n\tfor _, preLayer := range i.preLayers {\n\t\tlayers = append(layers, preLayer.layerID)\n\t\tapiLayerIDs[preLayer.layerID] = true\n\t}\n\t// Now look at the read-write layer, and prepare to work our way back\n\t// through all of its parent layers.\n\tlayerID := i.layerID\n\tlayer, err := i.store.Layer(layerID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to read layer %q: %w\", layerID, err)\n\t}\n\t// Walk the list of parent layers, prepending each as we go.  If we're squashing\n\t// or making a confidential workload, we're only producing one layer, so stop at\n\t// the layer ID of the top layer, which we won't really be using anyway.\n\tfor layer != nil {\n\t\tif layerID == i.layerID {\n\t\t\t// append the layer for this container to the list,\n\t\t\t// whether it's first or after some prepended layers\n\t\t\tlayers = append(layers, layerID)\n\t\t} else {\n\t\t\t// prepend this parent layer to the list\n\t\t\tlayers = append(append([]string{}, layerID), layers...)\n\t\t\tparentLayerIDs[layerID] = true\n\t\t}\n\t\tlayerID = layer.Parent\n\t\tif layerID == \"\" || i.confidentialWorkload.Convert || i.squash {\n\t\t\terr = nil\n\t\t\tbreak\n\t\t}\n\t\tlayer, err = i.store.Layer(layerID)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to read layer %q: %w\", layerID, err)\n\t\t}\n\t}\n\tlayer = nil\n\n\t// If we're slipping in a synthesized layer to hold some files, we need\n\t// to add a placeholder for it to the list just after the read-write\n\t// layer.  Confidential workloads and squashed images will just inline\n\t// the files, so we don't need to create a layer in those cases.\n\tconst synthesizedLayerID = \"(synthesized layer)\"\n\tif len(i.extraImageContent) > 0 && !i.confidentialWorkload.Convert && !i.squash {\n\t\tlayers = append(layers, synthesizedLayerID)\n\t}\n\t// Now add any API-supplied layers we have to append.\n\tfor _, postLayer := range i.postLayers {\n\t\tlayers = append(layers, postLayer.layerID)\n\t\tapiLayerIDs[postLayer.layerID] = true\n\t}\n\tlogrus.Debugf(\"layer list: %q\", layers)\n\n\t// It's simpler from here on to keep track of these as a group.\n\tapiLayers := append(slices.Clone(i.preLayers), slices.Clone(i.postLayers)...)\n\n\t// Make a temporary directory to hold blobs.\n\tpath, err := os.MkdirTemp(tmpdir.GetTempDir(), define.Package)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"creating temporary directory to hold layer blobs: %w\", err)\n\t}\n\tlogrus.Debugf(\"using %q to hold temporary data\", path)\n\tdefer func() {\n\t\tif src == nil {\n\t\t\terr2 := os.RemoveAll(path)\n\t\t\tif err2 != nil {\n\t\t\t\tlogrus.Errorf(\"error removing layer blob directory: %v\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Build fresh copies of the configurations and manifest so that we don't mess with any\n\t// values in the Builder object itself.\n\toimage, omanifest, dimage, dmanifest, err := i.createConfigsAndManifests()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Extract each layer and compute its digests, both compressed (if requested) and uncompressed.\n\tvar extraImageContentDiff string\n\tvar extraImageContentDiffDigest digest.Digest\n\tblobLayers := make(map[digest.Digest]blobLayerInfo)\n\tfor _, layerID := range layers {\n\t\twhat := fmt.Sprintf(\"layer %q\", layerID)\n\t\tif i.confidentialWorkload.Convert || i.squash {\n\t\t\twhat = fmt.Sprintf(\"container %q\", i.containerID)\n\t\t}\n\t\tif layerID == synthesizedLayerID {\n\t\t\twhat = synthesizedLayerID\n\t\t}\n\t\tif apiLayerIDs[layerID] {\n\t\t\twhat = layerID\n\t\t}\n\t\t// The default layer media type assumes no compression.\n\t\tomediaType := v1.MediaTypeImageLayer\n\t\tdmediaType := docker.V2S2MediaTypeUncompressedLayer\n\t\t// Look up this layer.\n\t\tvar layerUncompressedDigest digest.Digest\n\t\tvar layerUncompressedSize int64\n\t\tlinkedLayerHasLayerID := func(l commitLinkedLayerInfo) bool { return l.layerID == layerID }\n\t\tif apiLayerIDs[layerID] {\n\t\t\t// API-provided prepended or appended layer\n\t\t\tapiLayerIndex := slices.IndexFunc(apiLayers, linkedLayerHasLayerID)\n\t\t\tlayerUncompressedDigest = apiLayers[apiLayerIndex].uncompressedDigest\n\t\t\tlayerUncompressedSize = apiLayers[apiLayerIndex].size\n\t\t} else if layerID == synthesizedLayerID {\n\t\t\t// layer diff consisting of extra files to synthesize into a layer\n\t\t\tdiffFilename, digest, size, err := i.makeExtraImageContentDiff(true)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"unable to generate layer for additional content: %w\", err)\n\t\t\t}\n\t\t\textraImageContentDiff = diffFilename\n\t\t\textraImageContentDiffDigest = digest\n\t\t\tlayerUncompressedDigest = digest\n\t\t\tlayerUncompressedSize = size\n\t\t} else {\n\t\t\t// \"normal\" layer\n\t\t\tlayer, err := i.store.Layer(layerID)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"unable to locate layer %q: %w\", layerID, err)\n\t\t\t}\n\t\t\tlayerID = layer.ID\n\t\t\tlayerUncompressedDigest = layer.UncompressedDigest\n\t\t\tlayerUncompressedSize = layer.UncompressedSize\n\t\t}\n\t\t// We already know the digest of the contents of parent layers,\n\t\t// so if this is a parent layer, and we know its digest, reuse\n\t\t// its blobsum, diff ID, and size.\n\t\tif !i.confidentialWorkload.Convert && !i.squash && parentLayerIDs[layerID] && layerUncompressedDigest != \"\" {\n\t\t\tlayerBlobSum := layerUncompressedDigest\n\t\t\tlayerBlobSize := layerUncompressedSize\n\t\t\tdiffID := layerUncompressedDigest\n\t\t\t// Note this layer in the manifest, using the appropriate blobsum.\n\t\t\tolayerDescriptor := v1.Descriptor{\n\t\t\t\tMediaType: omediaType,\n\t\t\t\tDigest:    layerBlobSum,\n\t\t\t\tSize:      layerBlobSize,\n\t\t\t}\n\t\t\tomanifest.Layers = append(omanifest.Layers, olayerDescriptor)\n\t\t\tdlayerDescriptor := docker.V2S2Descriptor{\n\t\t\t\tMediaType: dmediaType,\n\t\t\t\tDigest:    layerBlobSum,\n\t\t\t\tSize:      layerBlobSize,\n\t\t\t}\n\t\t\tdmanifest.Layers = append(dmanifest.Layers, dlayerDescriptor)\n\t\t\t// Note this layer in the list of diffIDs, again using the uncompressed digest.\n\t\t\toimage.RootFS.DiffIDs = append(oimage.RootFS.DiffIDs, diffID)\n\t\t\tdimage.RootFS.DiffIDs = append(dimage.RootFS.DiffIDs, diffID)\n\t\t\tblobLayers[diffID] = blobLayerInfo{\n\t\t\t\tID:   layerID,\n\t\t\t\tSize: layerBlobSize,\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\t// Figure out if we need to change the media type, in case we've changed the compression.\n\t\tomediaType, dmediaType, err = computeLayerMIMEType(what, i.compression)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// Start reading either the layer or the whole container rootfs.\n\t\tnoCompression := archive.Uncompressed\n\t\tdiffOptions := &storage.DiffOptions{\n\t\t\tCompression: &noCompression,\n\t\t}\n\t\tvar rc io.ReadCloser\n\t\tvar errChan chan error\n\t\tif i.confidentialWorkload.Convert {\n\t\t\t// Convert the root filesystem into an encrypted disk image.\n\t\t\trc, err = i.extractConfidentialWorkloadFS(i.confidentialWorkload)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else if i.squash {\n\t\t\t// Extract the root filesystem as a single layer.\n\t\t\trc, errChan, err = i.extractRootfs(ExtractRootfsOptions{})\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tif apiLayerIDs[layerID] {\n\t\t\t\t// We're reading an API-supplied blob.\n\t\t\t\tapiLayerIndex := slices.IndexFunc(apiLayers, linkedLayerHasLayerID)\n\t\t\t\tf, err := os.Open(apiLayers[apiLayerIndex].linkedLayer.BlobPath)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"opening layer blob for %s: %w\", layerID, err)\n\t\t\t\t}\n\t\t\t\trc = f\n\t\t\t} else if layerID == synthesizedLayerID {\n\t\t\t\t// Slip in additional content as an additional layer.\n\t\t\t\tif rc, err = os.Open(extraImageContentDiff); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If we're up to the final layer, but we don't want to\n\t\t\t\t// include a diff for it, we're done.\n\t\t\t\tif i.emptyLayer && layerID == i.layerID {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\t// Extract this layer, one of possibly many.\n\t\t\t\trc, err = i.store.Diff(\"\", layerID, diffOptions)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"extracting %s: %w\", what, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsrcHasher := digest.Canonical.Digester()\n\t\t// Set up to write the possibly-recompressed blob.\n\t\tlayerFile, err := os.OpenFile(filepath.Join(path, \"layer\"), os.O_CREATE|os.O_WRONLY, 0o600)\n\t\tif err != nil {\n\t\t\trc.Close()\n\t\t\treturn nil, fmt.Errorf(\"opening file for %s: %w\", what, err)\n\t\t}\n\n\t\tcounter := ioutils.NewWriteCounter(layerFile)\n\t\tvar destHasher digest.Digester\n\t\tvar multiWriter io.Writer\n\t\t// Avoid rehashing when we do not compress.\n\t\tif i.compression != archive.Uncompressed {\n\t\t\tdestHasher = digest.Canonical.Digester()\n\t\t\tmultiWriter = io.MultiWriter(counter, destHasher.Hash())\n\t\t} else {\n\t\t\tdestHasher = srcHasher\n\t\t\tmultiWriter = counter\n\t\t}\n\t\t// Compress the layer, if we're recompressing it.\n\t\twriteCloser, err := archive.CompressStream(multiWriter, i.compression)\n\t\tif err != nil {\n\t\t\tlayerFile.Close()\n\t\t\trc.Close()\n\t\t\treturn nil, fmt.Errorf(\"compressing %s: %w\", what, err)\n\t\t}\n\t\twriter := io.MultiWriter(writeCloser, srcHasher.Hash())\n\t\t{\n\t\t\t// Tweak the contents of layers we're creating.\n\t\t\tnestedWriteCloser := ioutils.NewWriteCloserWrapper(writer, writeCloser.Close)\n\t\t\twriteCloser = newTarFilterer(nestedWriteCloser, func(hdr *tar.Header) (bool, bool, io.Reader) {\n\t\t\t\t// Scrub any local user names that might correspond to UIDs or GIDs of\n\t\t\t\t// files in this layer.\n\t\t\t\thdr.Uname, hdr.Gname = \"\", \"\"\n\t\t\t\t// Use specified timestamps in the layer, if we're doing that for history\n\t\t\t\t// entries.\n\t\t\t\tif i.created != nil {\n\t\t\t\t\t// Changing a zeroed field to a non-zero field can affect the\n\t\t\t\t\t// format that the library uses for writing the header, so only\n\t\t\t\t\t// change fields that are already set to avoid changing the\n\t\t\t\t\t// format (and as a result, changing the length) of the header\n\t\t\t\t\t// that we write.\n\t\t\t\t\tif !hdr.ModTime.IsZero() {\n\t\t\t\t\t\thdr.ModTime = *i.created\n\t\t\t\t\t}\n\t\t\t\t\tif !hdr.AccessTime.IsZero() {\n\t\t\t\t\t\thdr.AccessTime = *i.created\n\t\t\t\t\t}\n\t\t\t\t\tif !hdr.ChangeTime.IsZero() {\n\t\t\t\t\t\thdr.ChangeTime = *i.created\n\t\t\t\t\t}\n\t\t\t\t\treturn false, false, nil\n\t\t\t\t}\n\t\t\t\treturn false, false, nil\n\t\t\t})\n\t\t\twriter = io.Writer(writeCloser)\n\t\t}\n\t\t// Okay, copy from the raw diff through the filter, compressor, and counter and\n\t\t// digesters.\n\t\tsize, err := io.Copy(writer, rc)\n\t\tif err := writeCloser.Close(); err != nil {\n\t\t\tlayerFile.Close()\n\t\t\trc.Close()\n\t\t\treturn nil, fmt.Errorf(\"storing %s to file: %w on pipe close\", what, err)\n\t\t}\n\t\tif err := layerFile.Close(); err != nil {\n\t\t\trc.Close()\n\t\t\treturn nil, fmt.Errorf(\"storing %s to file: %w on file close\", what, err)\n\t\t}\n\t\trc.Close()\n\n\t\tif errChan != nil {\n\t\t\terr = <-errChan\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"extracting container rootfs: %w\", err)\n\t\t\t}\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"storing %s to file: %w\", what, err)\n\t\t}\n\t\tif i.compression == archive.Uncompressed {\n\t\t\tif size != counter.Count {\n\t\t\t\treturn nil, fmt.Errorf(\"storing %s to file: inconsistent layer size (copied %d, wrote %d)\", what, size, counter.Count)\n\t\t\t}\n\t\t} else {\n\t\t\tsize = counter.Count\n\t\t}\n\t\tlogrus.Debugf(\"%s size is %d bytes, uncompressed digest %s, possibly-compressed digest %s\", what, size, srcHasher.Digest().String(), destHasher.Digest().String())\n\t\t// Rename the layer so that we can more easily find it by digest later.\n\t\tfinalBlobName := filepath.Join(path, destHasher.Digest().String())\n\t\tif err = os.Rename(filepath.Join(path, \"layer\"), finalBlobName); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"storing %s to file while renaming %q to %q: %w\", what, filepath.Join(path, \"layer\"), finalBlobName, err)\n\t\t}\n\t\t// Add a note in the manifest about the layer.  The blobs are identified by their possibly-\n\t\t// compressed blob digests.\n\t\tolayerDescriptor := v1.Descriptor{\n\t\t\tMediaType: omediaType,\n\t\t\tDigest:    destHasher.Digest(),\n\t\t\tSize:      size,\n\t\t}\n\t\tomanifest.Layers = append(omanifest.Layers, olayerDescriptor)\n\t\tdlayerDescriptor := docker.V2S2Descriptor{\n\t\t\tMediaType: dmediaType,\n\t\t\tDigest:    destHasher.Digest(),\n\t\t\tSize:      size,\n\t\t}\n\t\tdmanifest.Layers = append(dmanifest.Layers, dlayerDescriptor)\n\t\t// Add a note about the diffID, which is always the layer's uncompressed digest.\n\t\toimage.RootFS.DiffIDs = append(oimage.RootFS.DiffIDs, srcHasher.Digest())\n\t\tdimage.RootFS.DiffIDs = append(dimage.RootFS.DiffIDs, srcHasher.Digest())\n\t}\n\n\t// Build history notes in the image configurations.\n\tappendHistory := func(history []v1.History, empty bool) {\n\t\tfor i := range history {\n\t\t\tvar created *time.Time\n\t\t\tif history[i].Created != nil {\n\t\t\t\tcopiedTimestamp := *history[i].Created\n\t\t\t\tcreated = &copiedTimestamp\n\t\t\t}\n\t\t\tonews := v1.History{\n\t\t\t\tCreated:    created,\n\t\t\t\tCreatedBy:  history[i].CreatedBy,\n\t\t\t\tAuthor:     history[i].Author,\n\t\t\t\tComment:    history[i].Comment,\n\t\t\t\tEmptyLayer: empty,\n\t\t\t}\n\t\t\toimage.History = append(oimage.History, onews)\n\t\t\tif created == nil {\n\t\t\t\tcreated = &time.Time{}\n\t\t\t}\n\t\t\tdnews := docker.V2S2History{\n\t\t\t\tCreated:    *created,\n\t\t\t\tCreatedBy:  history[i].CreatedBy,\n\t\t\t\tAuthor:     history[i].Author,\n\t\t\t\tComment:    history[i].Comment,\n\t\t\t\tEmptyLayer: empty,\n\t\t\t}\n\t\t\tdimage.History = append(dimage.History, dnews)\n\t\t}\n\t}\n\n\t// Only attempt to append history if history was not disabled explicitly.\n\tif !i.omitHistory {\n\t\t// Keep track of how many entries the base image's history had\n\t\t// before we started adding to it.\n\t\tbaseImageHistoryLen := len(oimage.History)\n\n\t\t// Add history entries for prepended empty layers.\n\t\tappendHistory(i.preEmptyLayers, true)\n\t\t// Add history entries for prepended API-supplied layers.\n\t\tfor _, h := range i.preLayers {\n\t\t\tappendHistory([]v1.History{h.linkedLayer.History}, h.linkedLayer.History.EmptyLayer)\n\t\t}\n\t\t// Add a history entry for this layer, empty or not.\n\t\tcreated := time.Now().UTC()\n\t\tif i.created != nil {\n\t\t\tcreated = (*i.created).UTC()\n\t\t}\n\t\tonews := v1.History{\n\t\t\tCreated:    &created,\n\t\t\tCreatedBy:  i.createdBy,\n\t\t\tAuthor:     oimage.Author,\n\t\t\tEmptyLayer: i.emptyLayer,\n\t\t\tComment:    i.historyComment,\n\t\t}\n\t\toimage.History = append(oimage.History, onews)\n\t\tdnews := docker.V2S2History{\n\t\t\tCreated:    created,\n\t\t\tCreatedBy:  i.createdBy,\n\t\t\tAuthor:     dimage.Author,\n\t\t\tEmptyLayer: i.emptyLayer,\n\t\t\tComment:    i.historyComment,\n\t\t}\n\t\tdimage.History = append(dimage.History, dnews)\n\t\t// Add a history entry for the extra image content if we added a layer for it.\n\t\t// This diff was added to the list of layers before API-supplied layers that\n\t\t// needed to be appended, and we need to keep the order of history entries for\n\t\t// not-empty layers consistent with that.\n\t\tif extraImageContentDiff != \"\" {\n\t\t\tcreatedBy := fmt.Sprintf(`/bin/sh -c #(nop) ADD dir:%s in /\",`, extraImageContentDiffDigest.Encoded())\n\t\t\tonews := v1.History{\n\t\t\t\tCreated:   &created,\n\t\t\t\tCreatedBy: createdBy,\n\t\t\t}\n\t\t\toimage.History = append(oimage.History, onews)\n\t\t\tdnews := docker.V2S2History{\n\t\t\t\tCreated:   created,\n\t\t\t\tCreatedBy: createdBy,\n\t\t\t}\n\t\t\tdimage.History = append(dimage.History, dnews)\n\t\t}\n\t\t// Add history entries for appended empty layers.\n\t\tappendHistory(i.postEmptyLayers, true)\n\t\t// Add history entries for appended API-supplied layers.\n\t\tfor _, h := range i.postLayers {\n\t\t\tappendHistory([]v1.History{h.linkedLayer.History}, h.linkedLayer.History.EmptyLayer)\n\t\t}\n\n\t\t// Assemble a comment indicating which base image was used, if it wasn't\n\t\t// just an image ID, and add it to the first history entry we added.\n\t\tvar fromComment string\n\t\tif strings.Contains(i.parent, i.fromImageID) && i.fromImageName != \"\" && !strings.HasPrefix(i.fromImageID, i.fromImageName) {\n\t\t\tif oimage.History[baseImageHistoryLen].Comment != \"\" {\n\t\t\t\tfromComment = \" \"\n\t\t\t}\n\t\t\tfromComment += \"FROM \" + i.fromImageName\n\t\t}\n\t\toimage.History[baseImageHistoryLen].Comment += fromComment\n\t\tdimage.History[baseImageHistoryLen].Comment += fromComment\n\n\t\t// Confidence check that we didn't just create a mismatch between non-empty layers in the\n\t\t// history and the number of diffIDs.  Only applicable if the base image (if there was\n\t\t// one) provided us at least one entry to use as a starting point.\n\t\tif baseImageHistoryLen != 0 {\n\t\t\texpectedDiffIDs := expectedOCIDiffIDs(oimage)\n\t\t\tif len(oimage.RootFS.DiffIDs) != expectedDiffIDs {\n\t\t\t\treturn nil, fmt.Errorf(\"internal error: history lists %d non-empty layers, but we have %d layers on disk\", expectedDiffIDs, len(oimage.RootFS.DiffIDs))\n\t\t\t}\n\t\t\texpectedDiffIDs = expectedDockerDiffIDs(dimage)\n\t\t\tif len(dimage.RootFS.DiffIDs) != expectedDiffIDs {\n\t\t\t\treturn nil, fmt.Errorf(\"internal error: history lists %d non-empty layers, but we have %d layers on disk\", expectedDiffIDs, len(dimage.RootFS.DiffIDs))\n\t\t\t}\n\t\t}\n\t}\n\n\t// Encode the image configuration blob.\n\toconfig, err := json.Marshal(&oimage)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"encoding %#v as json: %w\", oimage, err)\n\t}\n\tlogrus.Debugf(\"OCIv1 config = %s\", oconfig)\n\n\t// Add the configuration blob to the manifest.\n\tomanifest.Config.Digest = digest.Canonical.FromBytes(oconfig)\n\tomanifest.Config.Size = int64(len(oconfig))\n\tomanifest.Config.MediaType = v1.MediaTypeImageConfig\n\n\t// Encode the manifest.\n\tomanifestbytes, err := json.Marshal(&omanifest)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"encoding %#v as json: %w\", omanifest, err)\n\t}\n\tlogrus.Debugf(\"OCIv1 manifest = %s\", omanifestbytes)\n\n\t// Encode the image configuration blob.\n\tdconfig, err := json.Marshal(&dimage)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"encoding %#v as json: %w\", dimage, err)\n\t}\n\tlogrus.Debugf(\"Docker v2s2 config = %s\", dconfig)\n\n\t// Add the configuration blob to the manifest.\n\tdmanifest.Config.Digest = digest.Canonical.FromBytes(dconfig)\n\tdmanifest.Config.Size = int64(len(dconfig))\n\tdmanifest.Config.MediaType = manifest.DockerV2Schema2ConfigMediaType\n\n\t// Encode the manifest.\n\tdmanifestbytes, err := json.Marshal(&dmanifest)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"encoding %#v as json: %w\", dmanifest, err)\n\t}\n\tlogrus.Debugf(\"Docker v2s2 manifest = %s\", dmanifestbytes)\n\n\t// Decide which manifest and configuration blobs we'll actually output.\n\tvar config []byte\n\tvar imageManifest []byte\n\tswitch manifestType {\n\tcase v1.MediaTypeImageManifest:\n\t\timageManifest = omanifestbytes\n\t\tconfig = oconfig\n\tcase manifest.DockerV2Schema2MediaType:\n\t\timageManifest = dmanifestbytes\n\t\tconfig = dconfig\n\tdefault:\n\t\tpanic(\"unreachable code: unsupported manifest type\")\n\t}\n\tsrc = &containerImageSource{\n\t\tpath:          path,\n\t\tref:           i,\n\t\tstore:         i.store,\n\t\tcontainerID:   i.containerID,\n\t\tmountLabel:    i.mountLabel,\n\t\tlayerID:       i.layerID,\n\t\tnames:         i.names,\n\t\tcompression:   i.compression,\n\t\tconfig:        config,\n\t\tconfigDigest:  digest.Canonical.FromBytes(config),\n\t\tmanifest:      imageManifest,\n\t\tmanifestType:  manifestType,\n\t\tblobDirectory: i.blobDirectory,\n\t\tblobLayers:    blobLayers,\n\t}\n\treturn src, nil\n}\n\nfunc (i *containerImageRef) NewImageDestination(_ context.Context, _ *types.SystemContext) (types.ImageDestination, error) {\n\treturn nil, errors.New(\"can't write to a container\")\n}\n\nfunc (i *containerImageRef) DockerReference() reference.Named {\n\treturn i.name\n}\n\nfunc (i *containerImageRef) StringWithinTransport() string {\n\tif len(i.names) > 0 {\n\t\treturn i.names[0]\n\t}\n\treturn \"\"\n}\n\nfunc (i *containerImageRef) DeleteImage(context.Context, *types.SystemContext) error {\n\t// we were never here\n\treturn nil\n}\n\nfunc (i *containerImageRef) PolicyConfigurationIdentity() string {\n\treturn \"\"\n}\n\nfunc (i *containerImageRef) PolicyConfigurationNamespaces() []string {\n\treturn nil\n}\n\nfunc (i *containerImageRef) Transport() types.ImageTransport {\n\treturn is.Transport\n}\n\nfunc (i *containerImageSource) Close() error {\n\terr := os.RemoveAll(i.path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"removing layer blob directory: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (i *containerImageSource) Reference() types.ImageReference {\n\treturn i.ref\n}\n\nfunc (i *containerImageSource) GetSignatures(_ context.Context, _ *digest.Digest) ([][]byte, error) {\n\treturn nil, nil\n}\n\nfunc (i *containerImageSource) GetManifest(_ context.Context, _ *digest.Digest) ([]byte, string, error) {\n\treturn i.manifest, i.manifestType, nil\n}\n\nfunc (i *containerImageSource) LayerInfosForCopy(_ context.Context, _ *digest.Digest) ([]types.BlobInfo, error) {\n\treturn nil, nil\n}\n\nfunc (i *containerImageSource) HasThreadSafeGetBlob() bool {\n\treturn false\n}\n\nfunc (i *containerImageSource) GetBlob(_ context.Context, blob types.BlobInfo, _ types.BlobInfoCache) (reader io.ReadCloser, size int64, err error) {\n\tif blob.Digest == i.configDigest {\n\t\tlogrus.Debugf(\"start reading config\")\n\t\treader := bytes.NewReader(i.config)\n\t\tcloser := func() error {\n\t\t\tlogrus.Debugf(\"finished reading config\")\n\t\t\treturn nil\n\t\t}\n\t\treturn ioutils.NewReadCloserWrapper(reader, closer), reader.Size(), nil\n\t}\n\tvar layerReadCloser io.ReadCloser\n\tsize = -1\n\tif blobLayerInfo, ok := i.blobLayers[blob.Digest]; ok {\n\t\tnoCompression := archive.Uncompressed\n\t\tdiffOptions := &storage.DiffOptions{\n\t\t\tCompression: &noCompression,\n\t\t}\n\t\tlayerReadCloser, err = i.store.Diff(\"\", blobLayerInfo.ID, diffOptions)\n\t\tsize = blobLayerInfo.Size\n\t} else {\n\t\tfor _, blobDir := range []string{i.blobDirectory, i.path} {\n\t\t\tvar layerFile *os.File\n\t\t\tlayerFile, err = os.OpenFile(filepath.Join(blobDir, blob.Digest.String()), os.O_RDONLY, 0o600)\n\t\t\tif err == nil {\n\t\t\t\tst, err := layerFile.Stat()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogrus.Warnf(\"error reading size of layer file %q: %v\", blob.Digest.String(), err)\n\t\t\t\t} else {\n\t\t\t\t\tsize = st.Size()\n\t\t\t\t\tlayerReadCloser = layerFile\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tlayerFile.Close()\n\t\t\t}\n\t\t\tif !errors.Is(err, os.ErrNotExist) {\n\t\t\t\tlogrus.Debugf(\"error checking for layer %q in %q: %v\", blob.Digest.String(), blobDir, err)\n\t\t\t}\n\t\t}\n\t}\n\tif err != nil || layerReadCloser == nil || size == -1 {\n\t\tlogrus.Debugf(\"error reading layer %q: %v\", blob.Digest.String(), err)\n\t\treturn nil, -1, fmt.Errorf(\"opening layer blob: %w\", err)\n\t}\n\tlogrus.Debugf(\"reading layer %q\", blob.Digest.String())\n\tcloser := func() error {\n\t\tlogrus.Debugf(\"finished reading layer %q\", blob.Digest.String())\n\t\tif err := layerReadCloser.Close(); err != nil {\n\t\t\treturn fmt.Errorf(\"closing layer %q after reading: %w\", blob.Digest.String(), err)\n\t\t}\n\t\treturn nil\n\t}\n\treturn ioutils.NewReadCloserWrapper(layerReadCloser, closer), size, nil\n}\n\n// makeExtraImageContentDiff creates an archive file containing the contents of\n// files named in i.extraImageContent.  The footer that marks the end of the\n// archive may be omitted.\nfunc (i *containerImageRef) makeExtraImageContentDiff(includeFooter bool) (_ string, _ digest.Digest, _ int64, retErr error) {\n\tcdir, err := i.store.ContainerDirectory(i.containerID)\n\tif err != nil {\n\t\treturn \"\", \"\", -1, err\n\t}\n\tdiff, err := os.CreateTemp(cdir, \"extradiff\")\n\tif err != nil {\n\t\treturn \"\", \"\", -1, err\n\t}\n\tdefer diff.Close()\n\tdefer func() {\n\t\tif retErr != nil {\n\t\t\tos.Remove(diff.Name())\n\t\t}\n\t}()\n\tdigester := digest.Canonical.Digester()\n\tcounter := ioutils.NewWriteCounter(digester.Hash())\n\ttw := tar.NewWriter(io.MultiWriter(diff, counter))\n\tcreated := time.Now()\n\tif i.created != nil {\n\t\tcreated = *i.created\n\t}\n\tfor path, contents := range i.extraImageContent {\n\t\tif err := func() error {\n\t\t\tcontent, err := os.Open(contents)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer content.Close()\n\t\t\tst, err := content.Stat()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := tw.WriteHeader(&tar.Header{\n\t\t\t\tName:     path,\n\t\t\t\tTypeflag: tar.TypeReg,\n\t\t\t\tMode:     0o644,\n\t\t\t\tModTime:  created,\n\t\t\t\tSize:     st.Size(),\n\t\t\t}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif _, err := io.Copy(tw, content); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := tw.Flush(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}(); err != nil {\n\t\t\treturn \"\", \"\", -1, err\n\t\t}\n\t}\n\tif !includeFooter {\n\t\treturn diff.Name(), \"\", -1, nil\n\t}\n\ttw.Close()\n\treturn diff.Name(), digester.Digest(), counter.Count, nil\n}\n\n// makeLinkedLayerInfos calculates the size and digest information for a layer\n// we intend to add to the image that we're committing.\nfunc (b *Builder) makeLinkedLayerInfos(layers []LinkedLayer, layerType string) ([]commitLinkedLayerInfo, error) {\n\tif layers == nil {\n\t\treturn nil, nil\n\t}\n\tinfos := make([]commitLinkedLayerInfo, 0, len(layers))\n\tfor i, layer := range layers {\n\t\t// complain if EmptyLayer and \"is the BlobPath empty\" don't agree\n\t\tif layer.History.EmptyLayer != (layer.BlobPath == \"\") {\n\t\t\treturn nil, fmt.Errorf(\"internal error: layer-is-empty = %v, but content path is %q\", layer.History.EmptyLayer, layer.BlobPath)\n\t\t}\n\t\t// if there's no layer contents, we're done with this one\n\t\tif layer.History.EmptyLayer {\n\t\t\tcontinue\n\t\t}\n\t\t// check if it's a directory or a non-directory\n\t\tst, err := os.Stat(layer.BlobPath)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"checking if layer content %s is a directory: %w\", layer.BlobPath, err)\n\t\t}\n\t\tinfo := commitLinkedLayerInfo{\n\t\t\tlayerID:     fmt.Sprintf(\"(%s %d)\", layerType, i+1),\n\t\t\tlinkedLayer: layer,\n\t\t}\n\t\tif err = func() error {\n\t\t\tif st.IsDir() {\n\t\t\t\t// if it's a directory, archive it and digest the archive while we're storing a copy somewhere\n\t\t\t\tcdir, err := b.store.ContainerDirectory(b.ContainerID)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"determining directory for working container: %w\", err)\n\t\t\t\t}\n\t\t\t\tf, err := os.CreateTemp(cdir, \"\")\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"creating temporary file to hold blob for %q: %w\", info.linkedLayer.BlobPath, err)\n\t\t\t\t}\n\t\t\t\tdefer f.Close()\n\t\t\t\trc, err := chrootarchive.Tar(info.linkedLayer.BlobPath, nil, info.linkedLayer.BlobPath)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"generating a layer blob from %q: %w\", info.linkedLayer.BlobPath, err)\n\t\t\t\t}\n\t\t\t\tdigester := digest.Canonical.Digester()\n\t\t\t\tsizeCounter := ioutils.NewWriteCounter(digester.Hash())\n\t\t\t\t_, copyErr := io.Copy(f, io.TeeReader(rc, sizeCounter))\n\t\t\t\tif err := rc.Close(); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"storing a copy of %q: %w\", info.linkedLayer.BlobPath, err)\n\t\t\t\t}\n\t\t\t\tif copyErr != nil {\n\t\t\t\t\treturn fmt.Errorf(\"storing a copy of %q: %w\", info.linkedLayer.BlobPath, copyErr)\n\t\t\t\t}\n\t\t\t\tinfo.uncompressedDigest = digester.Digest()\n\t\t\t\tinfo.size = sizeCounter.Count\n\t\t\t\tinfo.linkedLayer.BlobPath = f.Name()\n\t\t\t} else {\n\t\t\t\t// if it's not a directory, just digest it\n\t\t\t\tf, err := os.Open(info.linkedLayer.BlobPath)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tdefer f.Close()\n\t\t\t\tsizeCounter := ioutils.NewWriteCounter(io.Discard)\n\t\t\t\tuncompressedDigest, err := digest.Canonical.FromReader(io.TeeReader(f, sizeCounter))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tinfo.uncompressedDigest = uncompressedDigest\n\t\t\t\tinfo.size = sizeCounter.Count\n\t\t\t}\n\t\t\treturn nil\n\t\t}(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tinfos = append(infos, info)\n\t}\n\treturn infos, nil\n}\n\n// makeContainerImageRef creates a containers/image/v5/types.ImageReference\n// which is mainly used for representing the working container as a source\n// image that can be copied, which is how we commit the container to create the\n// image.\nfunc (b *Builder) makeContainerImageRef(options CommitOptions) (*containerImageRef, error) {\n\tif (len(options.PrependedLinkedLayers) > 0 || len(options.AppendedLinkedLayers) > 0) &&\n\t\t(options.ConfidentialWorkloadOptions.Convert || options.Squash) {\n\t\treturn nil, errors.New(\"can't add prebuilt layers and produce an image with only one layer, at the same time\")\n\t}\n\tvar name reference.Named\n\tcontainer, err := b.store.Container(b.ContainerID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"locating container %q: %w\", b.ContainerID, err)\n\t}\n\tif len(container.Names) > 0 {\n\t\tif parsed, err2 := reference.ParseNamed(container.Names[0]); err2 == nil {\n\t\t\tname = parsed\n\t\t}\n\t}\n\tmanifestType := options.PreferredManifestType\n\tif manifestType == \"\" {\n\t\tmanifestType = define.OCIv1ImageManifest\n\t}\n\n\tfor _, u := range options.UnsetEnvs {\n\t\tb.UnsetEnv(u)\n\t}\n\toconfig, err := json.Marshal(&b.OCIv1)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"encoding OCI-format image configuration %#v: %w\", b.OCIv1, err)\n\t}\n\tdconfig, err := json.Marshal(&b.Docker)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"encoding docker-format image configuration %#v: %w\", b.Docker, err)\n\t}\n\tvar created *time.Time\n\tif options.HistoryTimestamp != nil {\n\t\thistoryTimestampUTC := options.HistoryTimestamp.UTC()\n\t\tcreated = &historyTimestampUTC\n\t}\n\tcreatedBy := b.CreatedBy()\n\tif createdBy == \"\" {\n\t\tcreatedBy = strings.Join(b.Shell(), \" \")\n\t\tif createdBy == \"\" {\n\t\t\tcreatedBy = \"/bin/sh\"\n\t\t}\n\t}\n\n\tparent := \"\"\n\tforceOmitHistory := false\n\tif b.FromImageID != \"\" {\n\t\tparentDigest := digest.NewDigestFromEncoded(digest.Canonical, b.FromImageID)\n\t\tif parentDigest.Validate() == nil {\n\t\t\tparent = parentDigest.String()\n\t\t}\n\t\tif !options.OmitHistory && len(b.OCIv1.History) == 0 && len(b.OCIv1.RootFS.DiffIDs) != 0 {\n\t\t\t// Parent had layers, but no history.  We shouldn't confuse\n\t\t\t// our own confidence checks by adding history for layers\n\t\t\t// that we're adding, creating an image with multiple layers,\n\t\t\t// only some of which have history entries, which would be\n\t\t\t// broken in confusing ways.\n\t\t\tb.Logger.Debugf(\"parent image %q had no history but had %d layers, assuming OmitHistory\", b.FromImageID, len(b.OCIv1.RootFS.DiffIDs))\n\t\t\tforceOmitHistory = true\n\t\t}\n\t}\n\n\tpreLayerInfos, err := b.makeLinkedLayerInfos(append(slices.Clone(b.PrependedLinkedLayers), slices.Clone(options.PrependedLinkedLayers)...), \"prepended layer\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpostLayerInfos, err := b.makeLinkedLayerInfos(append(slices.Clone(options.AppendedLinkedLayers), slices.Clone(b.AppendedLinkedLayers)...), \"appended layer\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tref := &containerImageRef{\n\t\tfromImageName:         b.FromImage,\n\t\tfromImageID:           b.FromImageID,\n\t\tstore:                 b.store,\n\t\tcompression:           options.Compression,\n\t\tname:                  name,\n\t\tnames:                 container.Names,\n\t\tcontainerID:           container.ID,\n\t\tmountLabel:            b.MountLabel,\n\t\tlayerID:               container.LayerID,\n\t\toconfig:               oconfig,\n\t\tdconfig:               dconfig,\n\t\tcreated:               created,\n\t\tcreatedBy:             createdBy,\n\t\thistoryComment:        b.HistoryComment(),\n\t\tannotations:           b.Annotations(),\n\t\tpreferredManifestType: manifestType,\n\t\tsquash:                options.Squash,\n\t\tconfidentialWorkload:  options.ConfidentialWorkloadOptions,\n\t\tomitHistory:           options.OmitHistory || forceOmitHistory,\n\t\temptyLayer:            options.EmptyLayer && !options.Squash && !options.ConfidentialWorkloadOptions.Convert,\n\t\tidMappingOptions:      &b.IDMappingOptions,\n\t\tparent:                parent,\n\t\tblobDirectory:         options.BlobDirectory,\n\t\tpreEmptyLayers:        slices.Clone(b.PrependedEmptyLayers),\n\t\tpreLayers:             preLayerInfos,\n\t\tpostEmptyLayers:       slices.Clone(b.AppendedEmptyLayers),\n\t\tpostLayers:            postLayerInfos,\n\t\toverrideChanges:       options.OverrideChanges,\n\t\toverrideConfig:        options.OverrideConfig,\n\t\textraImageContent:     maps.Clone(options.ExtraImageContent),\n\t\tcompatSetParent:       options.CompatSetParent,\n\t}\n\tif ref.created != nil {\n\t\tfor i := range ref.preEmptyLayers {\n\t\t\tref.preEmptyLayers[i].Created = ref.created\n\t\t}\n\t\tfor i := range ref.preLayers {\n\t\t\tref.preLayers[i].linkedLayer.History.Created = ref.created\n\t\t}\n\t\tfor i := range ref.postEmptyLayers {\n\t\t\tref.postEmptyLayers[i].Created = ref.created\n\t\t}\n\t\tfor i := range ref.postLayers {\n\t\t\tref.postLayers[i].linkedLayer.History.Created = ref.created\n\t\t}\n\t}\n\treturn ref, nil\n}\n\n// Extract the container's whole filesystem as if it were a single layer from current builder instance\nfunc (b *Builder) ExtractRootfs(options CommitOptions, opts ExtractRootfsOptions) (io.ReadCloser, chan error, error) {\n\tsrc, err := b.makeContainerImageRef(options)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"creating image reference for container %q to extract its contents: %w\", b.ContainerID, err)\n\t}\n\treturn src.extractRootfs(opts)\n}\n"
        },
        {
          "name": "imagebuildah",
          "type": "tree",
          "content": null
        },
        {
          "name": "import.go",
          "type": "blob",
          "size": 5.2763671875,
          "content": "package buildah\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/containers/buildah/define\"\n\t\"github.com/containers/buildah/docker\"\n\t\"github.com/containers/buildah/util\"\n\t\"github.com/containers/image/v5/image\"\n\t\"github.com/containers/image/v5/manifest\"\n\tis \"github.com/containers/image/v5/storage\"\n\t\"github.com/containers/image/v5/transports\"\n\t\"github.com/containers/image/v5/types\"\n\t\"github.com/containers/storage\"\n\tdigest \"github.com/opencontainers/go-digest\"\n)\n\nfunc importBuilderDataFromImage(ctx context.Context, store storage.Store, systemContext *types.SystemContext, imageID, containerName, containerID string) (*Builder, error) {\n\tif imageID == \"\" {\n\t\treturn nil, errors.New(\"Internal error: imageID is empty in importBuilderDataFromImage\")\n\t}\n\n\tstoreopts, err := storage.DefaultStoreOptions()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tuidmap, gidmap := convertStorageIDMaps(storeopts.UIDMap, storeopts.GIDMap)\n\n\tref, err := is.Transport.ParseStoreReference(store, imageID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"no such image %q: %w\", imageID, err)\n\t}\n\tsrc, err := ref.NewImageSource(ctx, systemContext)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"instantiating image source: %w\", err)\n\t}\n\tdefer src.Close()\n\n\timageDigest := \"\"\n\tmanifestBytes, manifestType, err := src.GetManifest(ctx, nil)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"loading image manifest for %q: %w\", transports.ImageName(ref), err)\n\t}\n\tif manifestDigest, err := manifest.Digest(manifestBytes); err == nil {\n\t\timageDigest = manifestDigest.String()\n\t}\n\n\tvar instanceDigest *digest.Digest\n\tif manifest.MIMETypeIsMultiImage(manifestType) {\n\t\tlist, err := manifest.ListFromBlob(manifestBytes, manifestType)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"parsing image manifest for %q as list: %w\", transports.ImageName(ref), err)\n\t\t}\n\t\tinstance, err := list.ChooseInstance(systemContext)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"finding an appropriate image in manifest list %q: %w\", transports.ImageName(ref), err)\n\t\t}\n\t\tinstanceDigest = &instance\n\t}\n\n\timage, err := image.FromUnparsedImage(ctx, systemContext, image.UnparsedInstance(src, instanceDigest))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"instantiating image for %q instance %q: %w\", transports.ImageName(ref), instanceDigest, err)\n\t}\n\n\timageName := \"\"\n\tif img, err3 := store.Image(imageID); err3 == nil {\n\t\tif len(img.Names) > 0 {\n\t\t\timageName = img.Names[0]\n\t\t}\n\t\tif img.TopLayer != \"\" {\n\t\t\tlayer, err4 := store.Layer(img.TopLayer)\n\t\t\tif err4 != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"reading information about image's top layer: %w\", err4)\n\t\t\t}\n\t\t\tuidmap, gidmap = convertStorageIDMaps(layer.UIDMap, layer.GIDMap)\n\t\t}\n\t}\n\n\tdefaultNamespaceOptions, err := DefaultNamespaceOptions()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tnetInt, err := getNetworkInterface(store, \"\", \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbuilder := &Builder{\n\t\tstore:            store,\n\t\tType:             containerType,\n\t\tFromImage:        imageName,\n\t\tFromImageID:      imageID,\n\t\tFromImageDigest:  imageDigest,\n\t\tContainer:        containerName,\n\t\tContainerID:      containerID,\n\t\tImageCreatedBy:   \"\",\n\t\tNamespaceOptions: defaultNamespaceOptions,\n\t\tIDMappingOptions: define.IDMappingOptions{\n\t\t\tHostUIDMapping: len(uidmap) == 0,\n\t\t\tHostGIDMapping: len(uidmap) == 0,\n\t\t\tUIDMap:         uidmap,\n\t\t\tGIDMap:         gidmap,\n\t\t},\n\t\tNetworkInterface: netInt,\n\t\tCommonBuildOpts:  &CommonBuildOptions{},\n\t}\n\n\tif err := builder.initConfig(ctx, systemContext, image, nil); err != nil {\n\t\treturn nil, fmt.Errorf(\"preparing image configuration: %w\", err)\n\t}\n\n\treturn builder, nil\n}\n\nfunc importBuilder(ctx context.Context, store storage.Store, options ImportOptions) (*Builder, error) {\n\tif options.Container == \"\" {\n\t\treturn nil, errors.New(\"container name must be specified\")\n\t}\n\n\tc, err := store.Container(options.Container)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsystemContext := getSystemContext(store, &types.SystemContext{}, options.SignaturePolicyPath)\n\n\tbuilder, err := importBuilderDataFromImage(ctx, store, systemContext, c.ImageID, options.Container, c.ID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif builder.FromImageID != \"\" {\n\t\tif d, err2 := digest.Parse(builder.FromImageID); err2 == nil {\n\t\t\tbuilder.Docker.Parent = docker.ID(d)\n\t\t} else {\n\t\t\tbuilder.Docker.Parent = docker.ID(digest.NewDigestFromHex(digest.Canonical.String(), builder.FromImageID))\n\t\t}\n\t}\n\tif builder.FromImage != \"\" {\n\t\tbuilder.Docker.ContainerConfig.Image = builder.FromImage\n\t}\n\tbuilder.IDMappingOptions.UIDMap, builder.IDMappingOptions.GIDMap = convertStorageIDMaps(c.UIDMap, c.GIDMap)\n\n\terr = builder.Save()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"saving builder state: %w\", err)\n\t}\n\n\treturn builder, nil\n}\n\nfunc importBuilderFromImage(ctx context.Context, store storage.Store, options ImportFromImageOptions) (*Builder, error) {\n\tif options.Image == \"\" {\n\t\treturn nil, errors.New(\"image name must be specified\")\n\t}\n\n\tsystemContext := getSystemContext(store, options.SystemContext, options.SignaturePolicyPath)\n\n\t_, img, err := util.FindImage(store, \"\", systemContext, options.Image)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"importing settings: %w\", err)\n\t}\n\n\tbuilder, err := importBuilderDataFromImage(ctx, store, systemContext, img.ID, \"\", \"\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"importing build settings from image %q: %w\", options.Image, err)\n\t}\n\n\tbuilder.setupLogger()\n\treturn builder, nil\n}\n"
        },
        {
          "name": "info.go",
          "type": "blob",
          "size": 4.7626953125,
          "content": "package buildah\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\n\tinternalUtil \"github.com/containers/buildah/internal/util\"\n\tputil \"github.com/containers/buildah/pkg/util\"\n\t\"github.com/containers/buildah/util\"\n\t\"github.com/containers/common/pkg/cgroups\"\n\t\"github.com/containers/storage\"\n\t\"github.com/containers/storage/pkg/system\"\n\t\"github.com/containers/storage/pkg/unshare\"\n\tv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/sirupsen/logrus\"\n)\n\n// InfoData holds the info type, i.e store, host etc and the data for each type\ntype InfoData struct {\n\tType string\n\tData map[string]interface{}\n}\n\n// Info returns the store and host information\nfunc Info(store storage.Store) ([]InfoData, error) {\n\tinfo := []InfoData{}\n\t// get host information\n\thostInfo := hostInfo()\n\tinfo = append(info, InfoData{Type: \"host\", Data: hostInfo})\n\n\t// get store information\n\tstoreInfo, err := storeInfo(store)\n\tif err != nil {\n\t\tlogrus.Error(err, \"error getting store info\")\n\t}\n\tinfo = append(info, InfoData{Type: \"store\", Data: storeInfo})\n\treturn info, nil\n}\n\nfunc hostInfo() map[string]interface{} {\n\tinfo := map[string]interface{}{}\n\tps := internalUtil.NormalizePlatform(v1.Platform{OS: runtime.GOOS, Architecture: runtime.GOARCH})\n\tinfo[\"os\"] = ps.OS\n\tinfo[\"arch\"] = ps.Architecture\n\tinfo[\"variant\"] = ps.Variant\n\tinfo[\"cpus\"] = runtime.NumCPU()\n\tinfo[\"rootless\"] = unshare.IsRootless()\n\n\tunified, err := cgroups.IsCgroup2UnifiedMode()\n\tif err != nil {\n\t\tlogrus.Error(err, \"err reading cgroups mode\")\n\t}\n\tcgroupVersion := \"v1\"\n\tociruntime := util.Runtime()\n\tif unified {\n\t\tcgroupVersion = \"v2\"\n\t}\n\tinfo[\"CgroupVersion\"] = cgroupVersion\n\tinfo[\"OCIRuntime\"] = ociruntime\n\n\tmi, err := system.ReadMemInfo()\n\tif err != nil {\n\t\tlogrus.Error(err, \"err reading memory info\")\n\t\tinfo[\"MemTotal\"] = \"\"\n\t\tinfo[\"MemFree\"] = \"\"\n\t\tinfo[\"SwapTotal\"] = \"\"\n\t\tinfo[\"SwapFree\"] = \"\"\n\t} else {\n\t\tinfo[\"MemTotal\"] = mi.MemTotal\n\t\tinfo[\"MemFree\"] = mi.MemFree\n\t\tinfo[\"SwapTotal\"] = mi.SwapTotal\n\t\tinfo[\"SwapFree\"] = mi.SwapFree\n\t}\n\thostDistributionInfo := getHostDistributionInfo()\n\tinfo[\"Distribution\"] = map[string]interface{}{\n\t\t\"distribution\": hostDistributionInfo[\"Distribution\"],\n\t\t\"version\":      hostDistributionInfo[\"Version\"],\n\t}\n\n\tkv, err := putil.ReadKernelVersion()\n\tif err != nil {\n\t\tlogrus.Error(err, \"error reading kernel version\")\n\t}\n\tinfo[\"kernel\"] = kv\n\n\tupDuration, err := putil.ReadUptime()\n\tif err != nil {\n\t\tlogrus.Error(err, \"error reading up time\")\n\t}\n\n\thoursFound := false\n\tvar timeBuffer bytes.Buffer\n\tvar hoursBuffer bytes.Buffer\n\tfor _, elem := range upDuration.String() {\n\t\ttimeBuffer.WriteRune(elem)\n\t\tif elem == 'h' || elem == 'm' {\n\t\t\ttimeBuffer.WriteRune(' ')\n\t\t\tif elem == 'h' {\n\t\t\t\thoursFound = true\n\t\t\t}\n\t\t}\n\t\tif !hoursFound {\n\t\t\thoursBuffer.WriteRune(elem)\n\t\t}\n\t}\n\n\tinfo[\"uptime\"] = timeBuffer.String()\n\tif hoursFound {\n\t\thours, err := strconv.ParseFloat(hoursBuffer.String(), 64)\n\t\tif err == nil {\n\t\t\tdays := hours / 24\n\t\t\tinfo[\"uptime\"] = fmt.Sprintf(\"%s (Approximately %.2f days)\", info[\"uptime\"], days)\n\t\t}\n\t}\n\n\thost, err := os.Hostname()\n\tif err != nil {\n\t\tlogrus.Error(err, \"error getting hostname\")\n\t}\n\tinfo[\"hostname\"] = host\n\n\treturn info\n}\n\n// top-level \"store\" info\nfunc storeInfo(store storage.Store) (map[string]interface{}, error) {\n\t// lets say storage driver in use, number of images, number of containers\n\tinfo := map[string]interface{}{}\n\tinfo[\"GraphRoot\"] = store.GraphRoot()\n\tinfo[\"RunRoot\"] = store.RunRoot()\n\tinfo[\"GraphDriverName\"] = store.GraphDriverName()\n\tinfo[\"GraphOptions\"] = store.GraphOptions()\n\tstatusPairs, err := store.Status()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstatus := map[string]string{}\n\tfor _, pair := range statusPairs {\n\t\tstatus[pair[0]] = pair[1]\n\t}\n\tinfo[\"GraphStatus\"] = status\n\timages, err := store.Images()\n\tif err != nil {\n\t\tlogrus.Error(err, \"error getting number of images\")\n\t}\n\tinfo[\"ImageStore\"] = map[string]interface{}{\n\t\t\"number\": len(images),\n\t}\n\n\tcontainers, err := store.Containers()\n\tif err != nil {\n\t\tlogrus.Error(err, \"error getting number of containers\")\n\t}\n\tinfo[\"ContainerStore\"] = map[string]interface{}{\n\t\t\"number\": len(containers),\n\t}\n\n\treturn info, nil\n}\n\n// getHostDistributionInfo returns a map containing the host's distribution and version\nfunc getHostDistributionInfo() map[string]string {\n\tdist := make(map[string]string)\n\n\t// Populate values in case we cannot find the values\n\t// or the file\n\tdist[\"Distribution\"] = \"unknown\"\n\tdist[\"Version\"] = \"unknown\"\n\n\tf, err := os.Open(\"/etc/os-release\")\n\tif err != nil {\n\t\treturn dist\n\t}\n\tdefer f.Close()\n\n\tl := bufio.NewScanner(f)\n\tfor l.Scan() {\n\t\tif strings.HasPrefix(l.Text(), \"ID=\") {\n\t\t\tdist[\"Distribution\"] = strings.TrimPrefix(l.Text(), \"ID=\")\n\t\t}\n\t\tif strings.HasPrefix(l.Text(), \"VERSION_ID=\") {\n\t\t\tdist[\"Version\"] = strings.Trim(strings.TrimPrefix(l.Text(), \"VERSION_ID=\"), \"\\\"\")\n\t\t}\n\t}\n\treturn dist\n}\n"
        },
        {
          "name": "install.md",
          "type": "blob",
          "size": 12.609375,
          "content": "![buildah logo](https://cdn.rawgit.com/containers/buildah/main/logos/buildah-logo_large.png)\n\n# Installation Instructions\n\n## Installing packaged versions of buildah\n\n### [Arch Linux](https://www.archlinux.org)\n\n```bash\nsudo pacman -S buildah\n```\n\n### [CentOS](https://www.centos.org)\n\nBuildah is available in the default Extras repos for CentOS 7 and in\nthe AppStream repo for CentOS 8 and Stream, however the available version often\nlags the upstream release.\n\n```bash\nsudo yum -y install buildah\n```\n\n### [Debian](https://debian.org)\n\nThe buildah package is available in\nthe [Bookworm](https://packages.debian.org/bookworm/buildah), which\nis the current stable release (Debian 12), as well as Debian Unstable/Sid.\n\n```bash\n# Debian Stable/Bookworm or Unstable/Sid\nsudo apt-get update\nsudo apt-get -y install buildah\n```\n\n\n### [Fedora](https://www.fedoraproject.org)\n\n```bash\nsudo dnf -y install buildah\n```\n\n### [Fedora SilverBlue](https://silverblue.fedoraproject.org)\n\nInstalled by default\n\n### [Fedora CoreOS](https://coreos.fedoraproject.org)\n\nNot Available.  Must be installed via package layering.\n\nrpm-ostree install buildah\n\nNote: [`podman`](https://podman.io) build is available by default.\n\n### [Gentoo](https://www.gentoo.org)\n[app-containers/buildah](https://packages.gentoo.org/packages/app-containers/buildah)\n```bash\nsudo emerge app-containers/buildah\n```\n\n### [openSUSE](https://www.opensuse.org)\n\n```bash\nsudo zypper install buildah\n```\n\n### [openSUSE Kubic](https://kubic.opensuse.org)\n\ntransactional-update pkg in buildah\n\n### [RHEL7](https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux)\n\nSubscribe, then enable Extras channel and install buildah.\n\n```bash\nsudo subscription-manager repos --enable=rhel-7-server-extras-rpms\nsudo yum -y install buildah\n```\n\n#### [Raspberry Pi OS arm64 (beta)](https://downloads.raspberrypi.org/raspios_arm64/images/)\n\nRaspberry Pi OS use the standard Debian's repositories,\nso it is fully compatible with Debian's arm64 repository.\nYou can simply follow the [steps for Debian](#debian) to install buildah.\n\n\n### [RHEL8 Beta](https://www.redhat.com/en/blog/powering-its-future-while-preserving-present-introducing-red-hat-enterprise-linux-8-beta?intcmp=701f2000001Cz6OAAS)\n\n```bash\nsudo yum module enable -y container-tools:1.0\nsudo yum module install -y buildah\n```\n\n### [Ubuntu](https://www.ubuntu.com)\n\nThe buildah package is available in the official repositories for Ubuntu 20.10\nand newer.\n\n```bash\n# Ubuntu 20.10 and newer\nsudo apt-get -y update\nsudo apt-get -y install buildah\n```\n\n# Building from scratch\n\n## System Requirements\n\n### Kernel Version Requirements\nTo run Buildah on Red Hat Enterprise Linux or CentOS, version 7.4 or higher is required.\nOn other Linux distributions Buildah requires a kernel version that supports the OverlayFS and/or fuse-overlayfs filesystem -- you'll need to consult your distribution's documentation to determine a minimum version number.\n\n### runc Requirement\n\nBuildah uses `runc` to run commands when `buildah run` is used, or when `buildah build`\nencounters a `RUN` instruction, so you'll also need to build and install a compatible version of\n[runc](https://github.com/opencontainers/runc) for Buildah to call for those cases.  If Buildah is installed\nvia a package manager such as yum, dnf or apt-get, runc will be installed as part of that process.\n\n### CNI Requirement\n\nWhen Buildah uses `runc` to run commands, it defaults to running those commands\nin the host's network namespace.  If the command is being run in a separate\nuser namespace, though, for example when ID mapping is used, then the command\nwill also be run in a separate network namespace.\n\nA newly-created network namespace starts with no network interfaces, so\ncommands which are run in that namespace are effectively disconnected from the\nnetwork unless additional setup is done.  Buildah relies on the CNI\n[library](https://github.com/containernetworking/cni) and\n[plugins](https://github.com/containernetworking/plugins) to set up interfaces\nand routing for network namespaces.\n\nIf Buildah is installed via a package manager such as yum, dnf or apt-get, a\npackage containing CNI plugins may be available (in Fedora, the package is\nnamed `containernetworking-cni`).  If not, they will need to be installed,\nfor example using:\n```\n  git clone https://github.com/containernetworking/plugins\n  ( cd ./plugins; ./build_linux.sh )\n  sudo mkdir -p /opt/cni/bin\n  sudo install -v ./plugins/bin/* /opt/cni/bin\n```\n\nThe CNI library needs to be configured so that it will know which plugins to\ncall to set up namespaces.  Usually, this configuration takes the form of one\nor more configuration files in the `/etc/cni/net.d` directory.  A set of example\nconfiguration files is included in the\n[`docs/cni-examples`](https://github.com/containers/buildah/tree/main/docs/cni-examples)\ndirectory of this source tree.\n\n## Package Installation\n\nBuildah is available on several software repositories and can be installed via a package manager such\nas yum, dnf or apt-get on a number of Linux distributions.\n\n## Installation from GitHub\n\nPrior to installing Buildah, install the following packages on your Linux distro:\n* make\n* golang (Requires version 1.13 or higher.)\n* bats\n* btrfs-progs-devel\n* bzip2\n* git\n* go-md2man\n* gpgme-devel\n* glib2-devel\n* libassuan-devel\n* libseccomp-devel\n* runc (Requires version 1.0 RC4 or higher.)\n* containers-common\n\n### Fedora\n\nIn Fedora, you can use this command:\n\n```\n dnf -y install \\\n    make \\\n    golang \\\n    bats \\\n    btrfs-progs-devel \\\n    glib2-devel \\\n    gpgme-devel \\\n    libassuan-devel \\\n    libseccomp-devel \\\n    git \\\n    bzip2 \\\n    go-md2man \\\n    runc \\\n    containers-common\n```\n\nThen to install Buildah on Fedora follow the steps in this example:\n\n```\n  git clone https://github.com/containers/buildah\n  cd buildah\n  make\n  sudo make install\n  buildah --help\n```\n\n### RHEL, CentOS\n\nIn RHEL and CentOS, run this command to install the build dependencies:\n\n```\n yum -y install \\\n    make \\\n    golang \\\n    bats \\\n    btrfs-progs-devel \\\n    glib2-devel \\\n    gpgme-devel \\\n    libassuan-devel \\\n    libseccomp-devel \\\n    git \\\n    bzip2 \\\n    go-md2man \\\n    runc \\\n    skopeo-containers\n```\n\nThe build steps for Buildah on RHEL or CentOS are the same as for Fedora, above.\n\n### openSUSE\n\nOn openSUSE Tumbleweed, install go via `zypper in go`, then run this command:\n\n```\n zypper in make \\\n    git \\\n    golang \\\n    runc \\\n    bzip2 \\\n    libgpgme-devel \\\n    libseccomp-devel \\\n    libbtrfs-devel \\\n    go-md2man\n```\n\nThe build steps for Buildah on SUSE / openSUSE are the same as for Fedora, above.\n\n\n### Ubuntu/Debian\n\nIn Ubuntu 22.10 (Karmic) or Debian 12 (Bookworm) you can use these commands:\n\n```\n  sudo apt-get -y -qq update\n  sudo apt-get -y install bats btrfs-progs git go-md2man golang libapparmor-dev libglib2.0-dev libgpgme11-dev libseccomp-dev libselinux1-dev make runc skopeo libbtrfs-dev\n```\n\nThe build steps for Buildah on Debian or Ubuntu are the same as for Fedora, above.\n\n## Vendoring - Dependency Management\n\nThis project is using [go modules](https://github.com/golang/go/wiki/Modules) for dependency management.  If the CI is complaining about a pull request leaving behind an unclean state, it is very likely right about it.  After changing dependencies, make sure to run `make vendor-in-container` to synchronize the code with the go module and repopulate the `./vendor` directory.\n\n## Configuration files\n\nThe following configuration files are required in order for Buildah to run appropriately.  The\nmajority of these files are commonly contained in the `containers-common` package.\n\n### [registries.conf](https://github.com/containers/buildah/blob/main/docs/samples/registries.conf)\n\n#### Man Page: [registries.conf.5](https://github.com/containers/image/blob/main/docs/containers-registries.conf.5.md)\n\n`/etc/containers/registries.conf`\n\nregistries.conf is the configuration file which specifies which container registries should be consulted when completing image names which do not include a registry or domain portion.\n\n#### Example from the Fedora `containers-common` package\n\n```\ncat /etc/containers/registries.conf\n# This is a system-wide configuration file used to\n# keep track of registries for various container backends.\n# It adheres to TOML format and does not support recursive\n# lists of registries.\n\n# The default location for this configuration file is /etc/containers/registries.conf.\n\n# The only valid categories are: 'registries.search', 'registries.insecure',\n# and 'registries.block'.\n\n[registries.search]\nregistries = ['docker.io', 'registry.fedoraproject.org', 'quay.io', 'registry.access.redhat.com']\n\n# If you need to access insecure registries, add the registry's fully-qualified name.\n# An insecure registry is one that does not have a valid SSL certificate or only does HTTP.\n[registries.insecure]\nregistries = []\n\n\n# If you need to block pull access from a registry, uncomment the section below\n# and add the registries fully-qualified name.\n#\n# Docker only\n[registries.block]\nregistries = []\n```\n\n### [mounts.conf](https://src.fedoraproject.org/rpms/skopeo/blob/main/f/mounts.conf)\n\n`/usr/share/containers/mounts.conf` and optionally `/etc/containers/mounts.conf`\n\nThe mounts.conf files specify volume mount files or directories that are automatically mounted inside containers when executing the `buildah run` or `buildah build` commands.  Container processes can then use this content.  The volume mount content does not get committed to the final image.  This file is usually provided by the containers-common package.\n\nUsually these directories are used for passing secrets or credentials required by the package software to access remote package repositories.\n\nFor example, a mounts.conf with the line \"`/usr/share/rhel/secrets:/run/secrets`\", the content of `/usr/share/rhel/secrets` directory is mounted on `/run/secrets` inside the container.  This mountpoint allows Red Hat Enterprise Linux subscriptions from the host to be used within the container.  It is also possible to omit the destination if it's equal to the source path.  For example, specifying `/var/lib/secrets` will mount the directory into the same container destination path `/var/lib/secrets`.\n\nNote this is not a volume mount. The content of the volumes is copied into container storage, not bind mounted directly from the host.\n\n#### Example from the Fedora `containers-common` package:\n\n```\ncat /usr/share/containers/mounts.conf\n/usr/share/rhel/secrets:/run/secrets\n```\n\n### [seccomp.json](https://src.fedoraproject.org/rpms/skopeo/blob/main/f/seccomp.json)\n\n`/usr/share/containers/seccomp.json`\n\nseccomp.json contains the list of seccomp rules to be allowed inside of\ncontainers.  This file is usually provided by the containers-common package.\n\nThe link above takes you to the seccomp.json\n\n### [policy.json](https://github.com/containers/skopeo/blob/main/default-policy.json)\n\n`/etc/containers/policy.json`\n\n#### Man Page: [policy.json.5](https://github.com/containers/image/blob/main/docs/policy.json.md)\n\n\n#### Example from the Fedora `containers-common` package:\n\n```\ncat /etc/containers/policy.json\n{\n    \"default\": [\n\t{\n\t    \"type\": \"insecureAcceptAnything\"\n\t}\n    ],\n    \"transports\":\n\t{\n\t    \"docker-daemon\":\n\t\t{\n\t\t    \"\": [{\"type\":\"insecureAcceptAnything\"}]\n\t\t}\n\t}\n}\n```\n\n## Debug with Delve and the like\n\nTo make a source debug build without optimizations use `BUILDDEBUG=1`, like:\n```\nmake all BUILDDEBUG=1\n```\n\n## Vendoring\n\nBuildah uses Go Modules for vendoring purposes.  If you need to update or add a vendored package into Buildah, please follow this procedure:\n * Enter into your sandbox `src/github.com/containers/buildah` and ensure that the GOPATH variable is set to the directory prior as noted above.\n * `export GO111MODULE=on`\n * `go get` the needed version:\n     * Assuming you want to 'bump' the `github.com/containers/storage` package to version 1.12.13, use this command: `go get github.com/containers/storage@v1.12.13`\n     *  Assuming that you want to 'bump' the `github.com/containers/storage` package to a particular commit, use this command: `go get github.com/containers/storage@e307568568533c4afccdf7b56df7b4493e4e9a7b`\n * `make vendor-in-container`\n * `make`\n * `make install`\n * Then add any updated or added files with `git add` then do a `git commit` and create a PR.\n\n### Vendor from your own fork\n\nIf you wish to vendor in your personal fork to try changes out (assuming containers/storage in the below example):\n\n * `go mod edit -replace github.com/containers/storage=github.com/{mygithub_username}/storage@YOUR_BRANCH`\n * `make vendor-in-container`\n\nTo revert\n * `go mod edit -dropreplace github.com/containers/storage`\n * `make vendor-in-container`\n\nTo speed up fetching dependencies, you can use a [Go Module Proxy](https://proxy.golang.org) by setting `GOPROXY=https://proxy.golang.org`.\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "logos",
          "type": "tree",
          "content": null
        },
        {
          "name": "manifests",
          "type": "tree",
          "content": null
        },
        {
          "name": "mount.go",
          "type": "blob",
          "size": 1.607421875,
          "content": "package buildah\n\nimport \"fmt\"\n\n// Mount mounts a container's root filesystem in a location which can be\n// accessed from the host, and returns the location.\nfunc (b *Builder) Mount(label string) (string, error) {\n\tmountpoint, err := b.store.Mount(b.ContainerID, label)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"mounting build container %q: %w\", b.ContainerID, err)\n\t}\n\tb.MountPoint = mountpoint\n\n\terr = b.Save()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"saving updated state for build container %q: %w\", b.ContainerID, err)\n\t}\n\treturn mountpoint, nil\n}\n\nfunc (b *Builder) setMountPoint(mountPoint string) error {\n\tb.MountPoint = mountPoint\n\tif err := b.Save(); err != nil {\n\t\treturn fmt.Errorf(\"saving updated state for build container %q: %w\", b.ContainerID, err)\n\t}\n\treturn nil\n}\n\n// Mounted returns whether the container is mounted or not\nfunc (b *Builder) Mounted() (bool, error) {\n\tmountCnt, err := b.store.Mounted(b.ContainerID)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"determining if mounting build container %q is mounted: %w\", b.ContainerID, err)\n\t}\n\tmounted := mountCnt > 0\n\tif mounted && b.MountPoint == \"\" {\n\t\tctr, err := b.store.Container(b.ContainerID)\n\t\tif err != nil {\n\t\t\treturn mountCnt > 0, fmt.Errorf(\"determining if mounting build container %q is mounted: %w\", b.ContainerID, err)\n\t\t}\n\t\tlayer, err := b.store.Layer(ctr.LayerID)\n\t\tif err != nil {\n\t\t\treturn mountCnt > 0, fmt.Errorf(\"determining if mounting build container %q is mounted: %w\", b.ContainerID, err)\n\t\t}\n\t\treturn mounted, b.setMountPoint(layer.MountPoint)\n\t}\n\tif !mounted && b.MountPoint != \"\" {\n\t\treturn mounted, b.setMountPoint(\"\")\n\t}\n\treturn mounted, nil\n}\n"
        },
        {
          "name": "new.go",
          "type": "blob",
          "size": 10.693359375,
          "content": "package buildah\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"strings\"\n\n\t\"github.com/containers/buildah/define\"\n\t\"github.com/containers/common/libimage\"\n\t\"github.com/containers/common/pkg/config\"\n\t\"github.com/containers/image/v5/image\"\n\t\"github.com/containers/image/v5/manifest\"\n\t\"github.com/containers/image/v5/pkg/shortnames\"\n\t\"github.com/containers/image/v5/transports\"\n\t\"github.com/containers/image/v5/types\"\n\t\"github.com/containers/storage\"\n\t\"github.com/containers/storage/pkg/stringid\"\n\tdigest \"github.com/opencontainers/go-digest\"\n\tv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/openshift/imagebuilder\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/exp/maps\"\n\t\"golang.org/x/exp/slices\"\n)\n\nconst (\n\t// BaseImageFakeName is the \"name\" of a source image which we interpret\n\t// as \"no image\".\n\tBaseImageFakeName = imagebuilder.NoBaseImageSpecifier\n)\n\nfunc getImageName(name string, img *storage.Image) string {\n\timageName := name\n\tif len(img.Names) > 0 {\n\t\timageName = img.Names[0]\n\t\t// When the image used by the container is a tagged image\n\t\t// the container name might be set to the original image instead of\n\t\t// the image given in the \"from\" command line.\n\t\t// This loop is supposed to fix this.\n\t\tfor _, n := range img.Names {\n\t\t\tif strings.Contains(n, name) {\n\t\t\t\timageName = n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn imageName\n}\n\nfunc imageNamePrefix(imageName string) string {\n\tprefix := imageName\n\tif d, err := digest.Parse(imageName); err == nil {\n\t\tprefix = d.Encoded()\n\t\tif len(prefix) > 12 {\n\t\t\tprefix = prefix[:12]\n\t\t}\n\t}\n\tif stringid.ValidateID(prefix) == nil {\n\t\tprefix = stringid.TruncateID(prefix)\n\t}\n\ts := strings.Split(prefix, \":\")\n\tif len(s) > 0 {\n\t\tprefix = s[0]\n\t}\n\ts = strings.Split(prefix, \"/\")\n\tif len(s) > 0 {\n\t\tprefix = s[len(s)-1]\n\t}\n\ts = strings.Split(prefix, \"@\")\n\tif len(s) > 0 {\n\t\tprefix = s[0]\n\t}\n\treturn prefix\n}\n\nfunc newContainerIDMappingOptions(idmapOptions *define.IDMappingOptions) storage.IDMappingOptions {\n\tvar options storage.IDMappingOptions\n\tif idmapOptions != nil {\n\t\tif idmapOptions.AutoUserNs {\n\t\t\toptions.AutoUserNs = true\n\t\t\toptions.AutoUserNsOpts = idmapOptions.AutoUserNsOpts\n\t\t} else {\n\t\t\toptions.HostUIDMapping = idmapOptions.HostUIDMapping\n\t\t\toptions.HostGIDMapping = idmapOptions.HostGIDMapping\n\t\t\tuidmap, gidmap := convertRuntimeIDMaps(idmapOptions.UIDMap, idmapOptions.GIDMap)\n\t\t\tif len(uidmap) > 0 && len(gidmap) > 0 {\n\t\t\t\toptions.UIDMap = uidmap\n\t\t\t\toptions.GIDMap = gidmap\n\t\t\t} else {\n\t\t\t\toptions.HostUIDMapping = true\n\t\t\t\toptions.HostGIDMapping = true\n\t\t\t}\n\t\t}\n\t}\n\treturn options\n}\n\nfunc containerNameExist(name string, containers []storage.Container) bool {\n\tfor _, container := range containers {\n\t\tfor _, cname := range container.Names {\n\t\t\tif cname == name {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc findUnusedContainer(name string, containers []storage.Container) string {\n\tsuffix := 1\n\ttmpName := name\n\tfor containerNameExist(tmpName, containers) {\n\t\ttmpName = fmt.Sprintf(\"%s-%d\", name, suffix)\n\t\tsuffix++\n\t}\n\treturn tmpName\n}\n\nfunc newBuilder(ctx context.Context, store storage.Store, options BuilderOptions) (*Builder, error) {\n\tvar (\n\t\tref types.ImageReference\n\t\timg *storage.Image\n\t\terr error\n\t)\n\n\tif options.FromImage == BaseImageFakeName {\n\t\toptions.FromImage = \"\"\n\t}\n\n\tif options.NetworkInterface == nil {\n\t\t// create the network interface\n\t\t// Note: It is important to do this before we pull any images/create containers.\n\t\t// The default backend detection logic needs an empty store to correctly detect\n\t\t// that we can use netavark, if the store was not empty it will use CNI to not break existing installs.\n\t\toptions.NetworkInterface, err = getNetworkInterface(store, options.CNIConfigDir, options.CNIPluginPath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tsystemContext := getSystemContext(store, options.SystemContext, options.SignaturePolicyPath)\n\n\tif options.FromImage != \"\" && options.FromImage != BaseImageFakeName {\n\t\timageRuntime, err := libimage.RuntimeFromStore(store, &libimage.RuntimeOptions{SystemContext: systemContext})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpullPolicy, err := config.ParsePullPolicy(options.PullPolicy.String())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Note: options.Format does *not* relate to the image we're\n\t\t// about to pull (see tests/digests.bats).  So we're not\n\t\t// forcing a MIMEType in the pullOptions below.\n\t\tpullOptions := libimage.PullOptions{}\n\t\tpullOptions.RetryDelay = &options.PullRetryDelay\n\t\tpullOptions.OciDecryptConfig = options.OciDecryptConfig\n\t\tpullOptions.SignaturePolicyPath = options.SignaturePolicyPath\n\t\tpullOptions.Writer = options.ReportWriter\n\t\tpullOptions.DestinationLookupReferenceFunc = cacheLookupReferenceFunc(options.BlobDirectory, types.PreserveOriginal)\n\n\t\tmaxRetries := uint(options.MaxPullRetries)\n\t\tpullOptions.MaxRetries = &maxRetries\n\n\t\tpulledImages, err := imageRuntime.Pull(ctx, options.FromImage, pullPolicy, &pullOptions)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif len(pulledImages) > 0 {\n\t\t\timg = pulledImages[0].StorageImage()\n\t\t\tref, err = pulledImages[0].StorageReference()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\timageSpec := options.FromImage\n\timageID := \"\"\n\timageDigest := \"\"\n\ttopLayer := \"\"\n\tif img != nil {\n\t\timageSpec = getImageName(imageNamePrefix(imageSpec), img)\n\t\timageID = img.ID\n\t\ttopLayer = img.TopLayer\n\t}\n\tvar src types.Image\n\tif ref != nil {\n\t\tsrcSrc, err := ref.NewImageSource(ctx, systemContext)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"instantiating image for %q: %w\", transports.ImageName(ref), err)\n\t\t}\n\t\tdefer srcSrc.Close()\n\t\tmanifestBytes, manifestType, err := srcSrc.GetManifest(ctx, nil)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"loading image manifest for %q: %w\", transports.ImageName(ref), err)\n\t\t}\n\t\tif manifestDigest, err := manifest.Digest(manifestBytes); err == nil {\n\t\t\timageDigest = manifestDigest.String()\n\t\t}\n\t\tvar instanceDigest *digest.Digest\n\t\tif manifest.MIMETypeIsMultiImage(manifestType) {\n\t\t\tlist, err := manifest.ListFromBlob(manifestBytes, manifestType)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"parsing image manifest for %q as list: %w\", transports.ImageName(ref), err)\n\t\t\t}\n\t\t\tinstance, err := list.ChooseInstance(systemContext)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"finding an appropriate image in manifest list %q: %w\", transports.ImageName(ref), err)\n\t\t\t}\n\t\t\tinstanceDigest = &instance\n\t\t}\n\t\tsrc, err = image.FromUnparsedImage(ctx, systemContext, image.UnparsedInstance(srcSrc, instanceDigest))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"instantiating image for %q instance %q: %w\", transports.ImageName(ref), instanceDigest, err)\n\t\t}\n\t}\n\n\tname := \"working-container\"\n\tif options.ContainerSuffix != \"\" {\n\t\tname = options.ContainerSuffix\n\t}\n\tif options.Container != \"\" {\n\t\tname = options.Container\n\t} else {\n\t\tif imageSpec != \"\" {\n\t\t\tname = imageNamePrefix(imageSpec) + \"-\" + name\n\t\t}\n\t}\n\tvar container *storage.Container\n\ttmpName := name\n\tif options.Container == \"\" {\n\t\tcontainers, err := store.Containers()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to check for container names: %w\", err)\n\t\t}\n\t\ttmpName = findUnusedContainer(tmpName, containers)\n\t}\n\n\tsuffixDigitsModulo := 100\n\tfor {\n\t\tvar flags map[string]interface{}\n\t\t// check if we have predefined ProcessLabel and MountLabel\n\t\t// this could be true if this is another stage in a build\n\t\tif options.ProcessLabel != \"\" && options.MountLabel != \"\" {\n\t\t\tflags = map[string]interface{}{\n\t\t\t\t\"ProcessLabel\": options.ProcessLabel,\n\t\t\t\t\"MountLabel\":   options.MountLabel,\n\t\t\t}\n\t\t}\n\t\tcoptions := storage.ContainerOptions{\n\t\t\tLabelOpts:        options.CommonBuildOpts.LabelOpts,\n\t\t\tIDMappingOptions: newContainerIDMappingOptions(options.IDMappingOptions),\n\t\t\tFlags:            flags,\n\t\t\tVolatile:         true,\n\t\t}\n\t\tcontainer, err = store.CreateContainer(\"\", []string{tmpName}, imageID, \"\", \"\", &coptions)\n\t\tif err == nil {\n\t\t\tname = tmpName\n\t\t\tbreak\n\t\t}\n\t\tif !errors.Is(err, storage.ErrDuplicateName) || options.Container != \"\" {\n\t\t\treturn nil, fmt.Errorf(\"creating container: %w\", err)\n\t\t}\n\t\ttmpName = fmt.Sprintf(\"%s-%d\", name, rand.Int()%suffixDigitsModulo)\n\t\tif suffixDigitsModulo < 1_000_000_000 {\n\t\t\tsuffixDigitsModulo *= 10\n\t\t}\n\t}\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tif err2 := store.DeleteContainer(container.ID); err2 != nil {\n\t\t\t\tlogrus.Errorf(\"error deleting container %q: %v\", container.ID, err2)\n\t\t\t}\n\t\t}\n\t}()\n\n\tuidmap, gidmap := convertStorageIDMaps(container.UIDMap, container.GIDMap)\n\n\tdefaultNamespaceOptions, err := DefaultNamespaceOptions()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tnamespaceOptions := defaultNamespaceOptions\n\tnamespaceOptions.AddOrReplace(options.NamespaceOptions...)\n\n\tbuilder := &Builder{\n\t\tstore:                 store,\n\t\tType:                  containerType,\n\t\tFromImage:             imageSpec,\n\t\tFromImageID:           imageID,\n\t\tFromImageDigest:       imageDigest,\n\t\tGroupAdd:              options.GroupAdd,\n\t\tContainer:             name,\n\t\tContainerID:           container.ID,\n\t\tImageAnnotations:      map[string]string{},\n\t\tImageCreatedBy:        \"\",\n\t\tProcessLabel:          container.ProcessLabel(),\n\t\tMountLabel:            container.MountLabel(),\n\t\tDefaultMountsFilePath: options.DefaultMountsFilePath,\n\t\tIsolation:             options.Isolation,\n\t\tNamespaceOptions:      namespaceOptions,\n\t\tConfigureNetwork:      options.ConfigureNetwork,\n\t\tCNIPluginPath:         options.CNIPluginPath,\n\t\tCNIConfigDir:          options.CNIConfigDir,\n\t\tIDMappingOptions: define.IDMappingOptions{\n\t\t\tHostUIDMapping: len(uidmap) == 0,\n\t\t\tHostGIDMapping: len(uidmap) == 0,\n\t\t\tUIDMap:         uidmap,\n\t\t\tGIDMap:         gidmap,\n\t\t},\n\t\tCapabilities:     slices.Clone(options.Capabilities),\n\t\tCommonBuildOpts:  options.CommonBuildOpts,\n\t\tTopLayer:         topLayer,\n\t\tArgs:             maps.Clone(options.Args),\n\t\tFormat:           options.Format,\n\t\tTempVolumes:      map[string]bool{},\n\t\tDevices:          options.Devices,\n\t\tDeviceSpecs:      options.DeviceSpecs,\n\t\tLogger:           options.Logger,\n\t\tNetworkInterface: options.NetworkInterface,\n\t\tCDIConfigDir:     options.CDIConfigDir,\n\t}\n\n\tif options.Mount {\n\t\t_, err = builder.Mount(container.MountLabel())\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"mounting build container %q: %w\", builder.ContainerID, err)\n\t\t}\n\t}\n\n\tif err := builder.initConfig(ctx, systemContext, src, &options); err != nil {\n\t\treturn nil, fmt.Errorf(\"preparing image configuration: %w\", err)\n\t}\n\n\tif !options.PreserveBaseImageAnns {\n\t\tbuilder.SetAnnotation(v1.AnnotationBaseImageDigest, imageDigest)\n\t\tif !shortnames.IsShortName(imageSpec) {\n\t\t\t// If the base image was specified as a fully-qualified\n\t\t\t// image name, let's set it.\n\t\t\tbuilder.SetAnnotation(v1.AnnotationBaseImageName, imageSpec)\n\t\t} else {\n\t\t\tbuilder.UnsetAnnotation(v1.AnnotationBaseImageName)\n\t\t}\n\t}\n\n\terr = builder.Save()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"saving builder state for container %q: %w\", builder.ContainerID, err)\n\t}\n\n\treturn builder, nil\n}\n"
        },
        {
          "name": "new_test.go",
          "type": "blob",
          "size": 1.0859375,
          "content": "package buildah\n\nimport (\n\t\"testing\"\n\n\t\"github.com/containers/storage\"\n\t\"github.com/openshift/imagebuilder\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestGetImageName(t *testing.T) {\n\ttt := []struct {\n\t\tcaseName string\n\t\tname     string\n\t\tnames    []string\n\t\texpected string\n\t}{\n\t\t{\"tagged image\", \"busybox1\", []string{\"docker.io/library/busybox:latest\", \"docker.io/library/busybox1:latest\"}, \"docker.io/library/busybox1:latest\"},\n\t\t{\"image name not in the resolved image names\", \"image1\", []string{\"docker.io/library/busybox:latest\", \"docker.io/library/busybox1:latest\"}, \"docker.io/library/busybox:latest\"},\n\t\t{\"resolved image with empty name list\", \"image1\", []string{}, \"image1\"},\n\t}\n\n\tfor _, tc := range tt {\n\t\timg := &storage.Image{Names: tc.names}\n\t\tres := getImageName(tc.name, img)\n\t\tif res != tc.expected {\n\t\t\tt.Errorf(\"test case '%s' failed: expected %#v but got %#v\", tc.caseName, tc.expected, res)\n\t\t}\n\t}\n}\n\nfunc TestNoBaseImageSpecifierIsScratch(t *testing.T) {\n\tassert.Equal(t, \"scratch\", imagebuilder.NoBaseImageSpecifier) // juuuuust in case\n\tassert.Equal(t, \"scratch\", BaseImageFakeName)\n}\n"
        },
        {
          "name": "nix",
          "type": "tree",
          "content": null
        },
        {
          "name": "pkg",
          "type": "tree",
          "content": null
        },
        {
          "name": "pull.go",
          "type": "blob",
          "size": 4.4208984375,
          "content": "package buildah\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"time\"\n\n\t\"github.com/containers/buildah/define\"\n\t\"github.com/containers/common/libimage\"\n\t\"github.com/containers/common/pkg/config\"\n\t\"github.com/containers/image/v5/types\"\n\tencconfig \"github.com/containers/ocicrypt/config\"\n\t\"github.com/containers/storage\"\n)\n\n// PullOptions can be used to alter how an image is copied in from somewhere.\ntype PullOptions struct {\n\t// SignaturePolicyPath specifies an override location for the signature\n\t// policy which should be used for verifying the new image as it is\n\t// being written.  Except in specific circumstances, no value should be\n\t// specified, indicating that the shared, system-wide default policy\n\t// should be used.\n\tSignaturePolicyPath string\n\t// ReportWriter is an io.Writer which will be used to log the writing\n\t// of the new image.\n\tReportWriter io.Writer\n\t// Store is the local storage store which holds the source image.\n\tStore storage.Store\n\t// github.com/containers/image/types SystemContext to hold credentials\n\t// and other authentication/authorization information.\n\tSystemContext *types.SystemContext\n\t// BlobDirectory is the name of a directory in which we'll attempt to\n\t// store copies of layer blobs that we pull down, if any.  It should\n\t// already exist.\n\t//\n\t// Not applicable if DestinationLookupReferenceFunc is set.\n\tBlobDirectory string\n\t// AllTags is a boolean value that determines if all tagged images\n\t// will be downloaded from the repository. The default is false.\n\tAllTags bool\n\t// RemoveSignatures causes any existing signatures for the image to be\n\t// discarded when pulling it.\n\tRemoveSignatures bool\n\t// MaxRetries is the maximum number of attempts we'll make to pull any\n\t// one image from the external registry if the first attempt fails.\n\tMaxRetries int\n\t// RetryDelay is how long to wait before retrying a pull attempt.\n\tRetryDelay time.Duration\n\t// OciDecryptConfig contains the config that can be used to decrypt an image if it is\n\t// encrypted if non-nil. If nil, it does not attempt to decrypt an image.\n\tOciDecryptConfig *encconfig.DecryptConfig\n\t// PullPolicy takes the value PullIfMissing, PullAlways, PullIfNewer, or PullNever.\n\tPullPolicy define.PullPolicy\n\t// SourceLookupReference provides a function to look up source\n\t// references.\n\tSourceLookupReferenceFunc libimage.LookupReferenceFunc\n\t// DestinationLookupReference provides a function to look up destination\n\t// references. Overrides BlobDirectory, if set.\n\tDestinationLookupReferenceFunc libimage.LookupReferenceFunc\n}\n\n// Pull copies the contents of the image from somewhere else to local storage.  Returns the\n// ID of the local image or an error.\nfunc Pull(_ context.Context, imageName string, options PullOptions) (imageID string, err error) {\n\tlibimageOptions := &libimage.PullOptions{}\n\tlibimageOptions.SignaturePolicyPath = options.SignaturePolicyPath\n\tlibimageOptions.Writer = options.ReportWriter\n\tlibimageOptions.RemoveSignatures = options.RemoveSignatures\n\tlibimageOptions.OciDecryptConfig = options.OciDecryptConfig\n\tlibimageOptions.AllTags = options.AllTags\n\tlibimageOptions.RetryDelay = &options.RetryDelay\n\tlibimageOptions.SourceLookupReferenceFunc = options.SourceLookupReferenceFunc\n\tif options.DestinationLookupReferenceFunc != nil {\n\t\tlibimageOptions.DestinationLookupReferenceFunc = options.DestinationLookupReferenceFunc\n\t} else {\n\t\tlibimageOptions.DestinationLookupReferenceFunc = cacheLookupReferenceFunc(options.BlobDirectory, types.PreserveOriginal)\n\t}\n\n\tif options.MaxRetries > 0 {\n\t\tretries := uint(options.MaxRetries)\n\t\tlibimageOptions.MaxRetries = &retries\n\t}\n\n\tpullPolicy, err := config.ParsePullPolicy(options.PullPolicy.String())\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Note: It is important to do this before we pull any images/create containers.\n\t// The default backend detection logic needs an empty store to correctly detect\n\t// that we can use netavark, if the store was not empty it will use CNI to not break existing installs.\n\t_, err = getNetworkInterface(options.Store, \"\", \"\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\truntime, err := libimage.RuntimeFromStore(options.Store, &libimage.RuntimeOptions{SystemContext: options.SystemContext})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tpulledImages, err := runtime.Pull(context.Background(), imageName, pullPolicy, libimageOptions)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif len(pulledImages) == 0 {\n\t\treturn \"\", fmt.Errorf(\"internal error pulling %s: no image pulled and no error\", imageName)\n\t}\n\n\treturn pulledImages[0].ID(), nil\n}\n"
        },
        {
          "name": "push.go",
          "type": "blob",
          "size": 6.7978515625,
          "content": "package buildah\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"time\"\n\n\t\"github.com/containers/buildah/pkg/blobcache\"\n\t\"github.com/containers/common/libimage\"\n\t\"github.com/containers/image/v5/docker/reference\"\n\t\"github.com/containers/image/v5/manifest\"\n\t\"github.com/containers/image/v5/pkg/compression\"\n\t\"github.com/containers/image/v5/transports\"\n\t\"github.com/containers/image/v5/types\"\n\tencconfig \"github.com/containers/ocicrypt/config\"\n\t\"github.com/containers/storage\"\n\t\"github.com/containers/storage/pkg/archive\"\n\tdigest \"github.com/opencontainers/go-digest\"\n\t\"github.com/sirupsen/logrus\"\n)\n\n// cacheLookupReferenceFunc wraps a BlobCache into a\n// libimage.LookupReferenceFunc to allow for using a BlobCache during\n// image-copy operations.\nfunc cacheLookupReferenceFunc(directory string, compress types.LayerCompression) libimage.LookupReferenceFunc {\n\t// Using a closure here allows us to reference a BlobCache without\n\t// having to explicitly maintain it in the libimage API.\n\treturn func(ref types.ImageReference) (types.ImageReference, error) {\n\t\tif directory == \"\" {\n\t\t\treturn ref, nil\n\t\t}\n\t\tref, err := blobcache.NewBlobCache(ref, directory, compress)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"using blobcache %q: %w\", directory, err)\n\t\t}\n\t\treturn ref, nil\n\t}\n}\n\n// PushOptions can be used to alter how an image is copied somewhere.\ntype PushOptions struct {\n\t// Compression specifies the type of compression which is applied to\n\t// layer blobs.  The default is to not use compression, but\n\t// archive.Gzip is recommended.\n\t// OBSOLETE: Use CompressionFormat instead.\n\tCompression archive.Compression\n\t// SignaturePolicyPath specifies an override location for the signature\n\t// policy which should be used for verifying the new image as it is\n\t// being written.  Except in specific circumstances, no value should be\n\t// specified, indicating that the shared, system-wide default policy\n\t// should be used.\n\tSignaturePolicyPath string\n\t// ReportWriter is an io.Writer which will be used to log the writing\n\t// of the new image.\n\tReportWriter io.Writer\n\t// Store is the local storage store which holds the source image.\n\tStore storage.Store\n\t// github.com/containers/image/types SystemContext to hold credentials\n\t// and other authentication/authorization information.\n\tSystemContext *types.SystemContext\n\t// ManifestType is the format to use\n\t// possible options are oci, v2s1, and v2s2\n\tManifestType string\n\t// BlobDirectory is the name of a directory in which we'll look for\n\t// prebuilt copies of layer blobs that we might otherwise need to\n\t// regenerate from on-disk layers, substituting them in the list of\n\t// blobs to copy whenever possible.\n\t//\n\t// Not applicable if SourceLookupReferenceFunc is set.\n\tBlobDirectory string\n\t// Quiet is a boolean value that determines if minimal output to\n\t// the user will be displayed, this is best used for logging.\n\t// The default is false.\n\tQuiet bool\n\t// SignBy is the fingerprint of a GPG key to use for signing the image.\n\tSignBy string\n\t// RemoveSignatures causes any existing signatures for the image to be\n\t// discarded for the pushed copy.\n\tRemoveSignatures bool\n\t// MaxRetries is the maximum number of attempts we'll make to push any\n\t// one image to the external registry if the first attempt fails.\n\tMaxRetries int\n\t// RetryDelay is how long to wait before retrying a push attempt.\n\tRetryDelay time.Duration\n\t// OciEncryptConfig when non-nil indicates that an image should be encrypted.\n\t// The encryption options is derived from the construction of EncryptConfig object.\n\tOciEncryptConfig *encconfig.EncryptConfig\n\t// OciEncryptLayers represents the list of layers to encrypt.\n\t// If nil, don't encrypt any layers.\n\t// If non-nil and len==0, denotes encrypt all layers.\n\t// integers in the slice represent 0-indexed layer indices, with support for negative\n\t// indexing. i.e. 0 is the first layer, -1 is the last (top-most) layer.\n\tOciEncryptLayers *[]int\n\t// SourceLookupReference provides a function to look up source\n\t// references. Overrides BlobDirectory, if set.\n\tSourceLookupReferenceFunc libimage.LookupReferenceFunc\n\t// DestinationLookupReference provides a function to look up destination\n\t// references.\n\tDestinationLookupReferenceFunc libimage.LookupReferenceFunc\n\n\t// CompressionFormat is the format to use for the compression of the blobs\n\tCompressionFormat *compression.Algorithm\n\t// CompressionLevel specifies what compression level is used\n\tCompressionLevel *int\n\t// ForceCompressionFormat ensures that the compression algorithm set in\n\t// CompressionFormat is used exclusively, and blobs of other compression\n\t// algorithms are not reused.\n\tForceCompressionFormat bool\n}\n\n// Push copies the contents of the image to a new location.\nfunc Push(ctx context.Context, image string, dest types.ImageReference, options PushOptions) (reference.Canonical, digest.Digest, error) {\n\tlibimageOptions := &libimage.PushOptions{}\n\tlibimageOptions.SignaturePolicyPath = options.SignaturePolicyPath\n\tlibimageOptions.Writer = options.ReportWriter\n\tlibimageOptions.ManifestMIMEType = options.ManifestType\n\tlibimageOptions.SignBy = options.SignBy\n\tlibimageOptions.RemoveSignatures = options.RemoveSignatures\n\tlibimageOptions.RetryDelay = &options.RetryDelay\n\tlibimageOptions.OciEncryptConfig = options.OciEncryptConfig\n\tlibimageOptions.OciEncryptLayers = options.OciEncryptLayers\n\tlibimageOptions.CompressionFormat = options.CompressionFormat\n\tlibimageOptions.CompressionLevel = options.CompressionLevel\n\tlibimageOptions.ForceCompressionFormat = options.ForceCompressionFormat\n\tlibimageOptions.PolicyAllowStorage = true\n\n\tif options.Quiet {\n\t\tlibimageOptions.Writer = nil\n\t}\n\n\tcompress := types.PreserveOriginal\n\tif options.Compression == archive.Gzip {\n\t\tcompress = types.Compress\n\t}\n\tif options.SourceLookupReferenceFunc != nil {\n\t\tlibimageOptions.SourceLookupReferenceFunc = options.SourceLookupReferenceFunc\n\t} else {\n\t\tlibimageOptions.SourceLookupReferenceFunc = cacheLookupReferenceFunc(options.BlobDirectory, compress)\n\t}\n\tlibimageOptions.DestinationLookupReferenceFunc = options.DestinationLookupReferenceFunc\n\n\truntime, err := libimage.RuntimeFromStore(options.Store, &libimage.RuntimeOptions{SystemContext: options.SystemContext})\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tdestString := fmt.Sprintf(\"%s:%s\", dest.Transport().Name(), dest.StringWithinTransport())\n\tmanifestBytes, err := runtime.Push(ctx, image, destString, libimageOptions)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tmanifestDigest, err := manifest.Digest(manifestBytes)\n\tif err != nil {\n\t\treturn nil, \"\", fmt.Errorf(\"computing digest of manifest of new image %q: %w\", transports.ImageName(dest), err)\n\t}\n\n\tvar ref reference.Canonical\n\tif name := dest.DockerReference(); name != nil {\n\t\tref, err = reference.WithDigest(name, manifestDigest)\n\t\tif err != nil {\n\t\t\tlogrus.Warnf(\"error generating canonical reference with name %q and digest %s: %v\", name, manifestDigest.String(), err)\n\t\t}\n\t}\n\n\treturn ref, manifestDigest, nil\n}\n"
        },
        {
          "name": "release.sh",
          "type": "blob",
          "size": 1.6240234375,
          "content": "#!/bin/sh\n#\n# Cut a buildah release.  Usage:\n#\n#   $ hack/release.sh <version> <next-version>\n#\n# For example:\n#\n#   $ hack/release.sh 1.2.3 1.3.0\n#\n# for \"I'm cutting 1.2.3, and want to use 1.3.0-dev for future work\".\n\nVERSION=\"$1\"\nNEXT_VERSION=\"$2\"\nDATE=$(date '+%Y-%m-%d')\nLAST_TAG=$(git describe --tags --abbrev=0)\n\nwrite_go_version()\n{\n\tLOCAL_VERSION=\"$1\"\n\tsed -i \"s/^\\(.*Version = \\\"\\).*/\\1${LOCAL_VERSION}\\\"/\" define/types.go\n}\n\nwrite_makefile_epoch()\n{\n\tLOCAL_EPOCH=\"$1\"\n\tsed -i \"s/^\\(EPOCH_TEST_COMMIT ?= \\).*/\\1${LOCAL_EPOCH}/\" Makefile\n}\n\nwrite_changelog()\n{\n\techo \"- Changelog for v${VERSION} (${DATE})\" >.changelog.txt &&\n\tgit log --no-merges --format='  * %s' \"${LAST_TAG}..HEAD\" >>.changelog.txt &&\n\techo >>.changelog.txt &&\n\tcat changelog.txt >>.changelog.txt &&\n\tmv -f .changelog.txt changelog.txt\n\n\techo \"\n## v${VERSION} (${DATE})\n\" >.CHANGELOG.md &&\n\tgit log --no-merges --format='    %s' \"${LAST_TAG}..HEAD\" >>.CHANGELOG.md &&\n\tsed -i -e '/# Changelog/r .CHANGELOG.md'  CHANGELOG.md &&\n\trm -f .CHANGELOG.md\n}\n\nrelease_commit()\n{\n\twrite_go_version \"${VERSION}\" &&\n\twrite_changelog &&\n\tgit commit -asm \"Bump to v${VERSION}\n\n[NO TESTS NEEDED]\n\"\n}\n\ndev_version_commit()\n{\n\twrite_go_version \"${NEXT_VERSION}-dev\" &&\n\tgit commit -asm \"Bump to v${NEXT_VERSION}-dev\n\n[NO TESTS NEEDED]\n\"\n}\n\nepoch_commit()\n{\n\tLOCAL_EPOCH=\"$1\"\n\twrite_makefile_epoch \"${LOCAL_EPOCH}\" &&\n\tgit commit -asm 'Bump gitvalidation epoch\n\n\t[NO TESTS NEEDED]\n'\n}\n\ngit fetch origin &&\ngit checkout -b \"bump-${VERSION}\" origin/main &&\nEPOCH=$(git rev-parse HEAD) &&\nrelease_commit &&\ngit tag -s -m \"version ${VERSION}\" \"v${VERSION}\" &&\ndev_version_commit &&\nepoch_commit \"${EPOCH}\"\n"
        },
        {
          "name": "rpm",
          "type": "tree",
          "content": null
        },
        {
          "name": "run.go",
          "type": "blob",
          "size": 8.7412109375,
          "content": "package buildah\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\n\t\"github.com/containers/buildah/define\"\n\t\"github.com/containers/buildah/internal\"\n\t\"github.com/containers/buildah/pkg/sshagent\"\n\t\"github.com/containers/common/libnetwork/etchosts\"\n\t\"github.com/containers/image/v5/types\"\n\t\"github.com/containers/storage/pkg/lockfile\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/sirupsen/logrus\"\n)\n\nconst (\n\t// runUsingRuntimeCommand is a command we use as a key for reexec\n\trunUsingRuntimeCommand = define.Package + \"-oci-runtime\"\n)\n\n// TerminalPolicy takes the value DefaultTerminal, WithoutTerminal, or WithTerminal.\ntype TerminalPolicy int\n\nconst (\n\t// DefaultTerminal indicates that this Run invocation should be\n\t// connected to a pseudoterminal if we're connected to a terminal.\n\tDefaultTerminal TerminalPolicy = iota\n\t// WithoutTerminal indicates that this Run invocation should NOT be\n\t// connected to a pseudoterminal.\n\tWithoutTerminal\n\t// WithTerminal indicates that this Run invocation should be connected\n\t// to a pseudoterminal.\n\tWithTerminal\n)\n\n// String converts a TerminalPolicy into a string.\nfunc (t TerminalPolicy) String() string {\n\tswitch t {\n\tcase DefaultTerminal:\n\t\treturn \"DefaultTerminal\"\n\tcase WithoutTerminal:\n\t\treturn \"WithoutTerminal\"\n\tcase WithTerminal:\n\t\treturn \"WithTerminal\"\n\t}\n\treturn fmt.Sprintf(\"unrecognized terminal setting %d\", t)\n}\n\n// NamespaceOption controls how we set up a namespace when launching processes.\ntype NamespaceOption = define.NamespaceOption\n\n// NamespaceOptions provides some helper methods for a slice of NamespaceOption\n// structs.\ntype NamespaceOptions = define.NamespaceOptions\n\n// IDMappingOptions controls how we set up UID/GID mapping when we set up a\n// user namespace.\ntype IDMappingOptions = define.IDMappingOptions\n\n// Isolation provides a way to specify whether we're supposed to use a proper\n// OCI runtime, or some other method for running commands.\ntype Isolation = define.Isolation\n\nconst (\n\t// IsolationDefault is whatever we think will work best.\n\tIsolationDefault = define.IsolationDefault\n\t// IsolationOCI is a proper OCI runtime.\n\tIsolationOCI = define.IsolationOCI\n\t// IsolationChroot is a more chroot-like environment: less isolation,\n\t// but with fewer requirements.\n\tIsolationChroot = define.IsolationChroot\n\t// IsolationOCIRootless is a proper OCI runtime in rootless mode.\n\tIsolationOCIRootless = define.IsolationOCIRootless\n)\n\n// RunOptions can be used to alter how a command is run in the container.\ntype RunOptions struct {\n\t// Logger is the logrus logger to write log messages with\n\tLogger *logrus.Logger `json:\"-\"`\n\t// Hostname is the hostname we set for the running container.\n\tHostname string\n\t// Isolation is either IsolationDefault, IsolationOCI, IsolationChroot, or IsolationOCIRootless.\n\tIsolation define.Isolation\n\t// Runtime is the name of the runtime to run.  It should accept the\n\t// same arguments that runc does, and produce similar output.\n\tRuntime string\n\t// Args adds global arguments for the runtime.\n\tArgs []string\n\t// NoHostname won't create new /etc/hostname file\n\tNoHostname bool\n\t// NoHosts won't create new /etc/hosts file\n\tNoHosts bool\n\t// NoPivot adds the --no-pivot runtime flag.\n\tNoPivot bool\n\t// Mounts are additional mount points which we want to provide.\n\tMounts []specs.Mount\n\t// Env is additional environment variables to set.\n\tEnv []string\n\t// User is the user as whom to run the command.\n\tUser string\n\t// WorkingDir is an override for the working directory.\n\tWorkingDir string\n\t// ContextDir is used as the root directory for the source location for mounts that are of type \"bind\".\n\tContextDir string\n\t// Shell is default shell to run in a container.\n\tShell string\n\t// Cmd is an override for the configured default command.\n\tCmd []string\n\t// Entrypoint is an override for the configured entry point.\n\tEntrypoint []string\n\t// NamespaceOptions controls how we set up the namespaces for the process.\n\tNamespaceOptions define.NamespaceOptions\n\t// ConfigureNetwork controls whether or not network interfaces and\n\t// routing are configured for a new network namespace (i.e., when not\n\t// joining another's namespace and not just using the host's\n\t// namespace), effectively deciding whether or not the process has a\n\t// usable network.\n\tConfigureNetwork define.NetworkConfigurationPolicy\n\t// CNIPluginPath is the location of CNI plugin helpers, if they should be\n\t// run from a location other than the default location.\n\tCNIPluginPath string\n\t// CNIConfigDir is the location of CNI configuration files, if the files in\n\t// the default configuration directory shouldn't be used.\n\tCNIConfigDir string\n\t// Terminal provides a way to specify whether or not the command should\n\t// be run with a pseudoterminal.  By default (DefaultTerminal), a\n\t// terminal is used if os.Stdout is connected to a terminal, but that\n\t// decision can be overridden by specifying either WithTerminal or\n\t// WithoutTerminal.\n\tTerminal TerminalPolicy\n\t// TerminalSize provides a way to set the number of rows and columns in\n\t// a pseudo-terminal, if we create one, and Stdin/Stdout/Stderr aren't\n\t// connected to a terminal.\n\tTerminalSize *specs.Box\n\t// The stdin/stdout/stderr descriptors to use.  If set to nil, the\n\t// corresponding files in the \"os\" package are used as defaults.\n\tStdin  io.Reader `json:\"-\"`\n\tStdout io.Writer `json:\"-\"`\n\tStderr io.Writer `json:\"-\"`\n\t// Quiet tells the run to turn off output to stdout.\n\tQuiet bool\n\t// AddCapabilities is a list of capabilities to add to the default set.\n\tAddCapabilities []string\n\t// DropCapabilities is a list of capabilities to remove from the default set,\n\t// after processing the AddCapabilities set.  If a capability appears in both\n\t// lists, it will be dropped.\n\tDropCapabilities []string\n\t// Devices are parsed additional devices to add\n\tDevices define.ContainerDevices\n\t// DeviceSpecs are unparsed additional devices to add\n\tDeviceSpecs []string\n\t// Secrets are the available secrets to use\n\tSecrets map[string]define.Secret\n\t// SSHSources is the available ssh agents to use\n\tSSHSources map[string]*sshagent.Source `json:\"-\"`\n\t// RunMounts are unparsed mounts to be added for this run\n\tRunMounts []string\n\t// Map of stages and container mountpoint if any from stage executor\n\tStageMountPoints map[string]internal.StageMountDetails\n\t// External Image mounts to be cleaned up.\n\t// Buildah run --mount could mount image before RUN calls, RUN could cleanup\n\t// them up as well\n\tExternalImageMounts []string\n\t// System context of current build\n\tSystemContext *types.SystemContext\n\t// CgroupManager to use for running OCI containers\n\tCgroupManager string\n\t// CDIConfigDir is the location of CDI configuration files, if the files in\n\t// the default configuration locations shouldn't be used.\n\tCDIConfigDir string\n\t// CompatBuiltinVolumes causes the contents of locations marked as\n\t// volumes in the container's configuration to be set up as bind mounts to\n\t// directories which are not in the container's rootfs, hiding changes\n\t// made to contents of those changes when the container is subsequently\n\t// committed.\n\tCompatBuiltinVolumes types.OptionalBool\n}\n\n// RunMountArtifacts are the artifacts created when using a run mount.\ntype runMountArtifacts struct {\n\t// RunMountTargets are the run mount targets inside the container\n\tRunMountTargets []string\n\t// TmpFiles are artifacts that need to be removed outside the container\n\tTmpFiles []string\n\t// Any external images which were mounted inside container\n\tMountedImages []string\n\t// Agents are the ssh agents started\n\tAgents []*sshagent.AgentServer\n\t// SSHAuthSock is the path to the ssh auth sock inside the container\n\tSSHAuthSock string\n\t// TargetLocks to be unlocked if there are any.\n\tTargetLocks []*lockfile.LockFile\n}\n\n// RunMountInfo are the available run mounts for this run\ntype runMountInfo struct {\n\t// WorkDir is the current working directory inside the container.\n\tWorkDir string\n\t// ContextDir is the root directory for the source location for bind mounts.\n\tContextDir string\n\t// Secrets are the available secrets to use in a RUN\n\tSecrets map[string]define.Secret\n\t// SSHSources is the available ssh agents to use in a RUN\n\tSSHSources map[string]*sshagent.Source `json:\"-\"`\n\t// Map of stages and container mountpoint if any from stage executor\n\tStageMountPoints map[string]internal.StageMountDetails\n\t// System context of current build\n\tSystemContext *types.SystemContext\n}\n\n// IDMaps are the UIDs, GID, and maps for the run\ntype IDMaps struct {\n\tuidmap     []specs.LinuxIDMapping\n\tgidmap     []specs.LinuxIDMapping\n\trootUID    int\n\trootGID    int\n\tprocessUID int\n\tprocessGID int\n}\n\n// netResult type to hold network info for hosts/resolv.conf\ntype netResult struct {\n\tentries                           etchosts.HostEntries\n\tdnsServers                        []string\n\texcludeIPs                        []net.IP\n\tipv6                              bool\n\tkeepHostResolvers                 bool\n\tpreferredHostContainersInternalIP string\n}\n"
        },
        {
          "name": "run_common.go",
          "type": "blob",
          "size": 62.783203125,
          "content": "//go:build linux || freebsd\n\npackage buildah\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/containers/buildah/bind\"\n\t\"github.com/containers/buildah/copier\"\n\t\"github.com/containers/buildah/define\"\n\t\"github.com/containers/buildah/internal\"\n\t\"github.com/containers/buildah/internal/tmpdir\"\n\tinternalUtil \"github.com/containers/buildah/internal/util\"\n\t\"github.com/containers/buildah/internal/volumes\"\n\t\"github.com/containers/buildah/pkg/overlay\"\n\t\"github.com/containers/buildah/pkg/sshagent\"\n\t\"github.com/containers/buildah/util\"\n\t\"github.com/containers/common/libnetwork/etchosts\"\n\t\"github.com/containers/common/libnetwork/network\"\n\t\"github.com/containers/common/libnetwork/resolvconf\"\n\tnetTypes \"github.com/containers/common/libnetwork/types\"\n\tnetUtil \"github.com/containers/common/libnetwork/util\"\n\t\"github.com/containers/common/pkg/config\"\n\t\"github.com/containers/common/pkg/subscriptions\"\n\t\"github.com/containers/image/v5/types\"\n\timageTypes \"github.com/containers/image/v5/types\"\n\t\"github.com/containers/storage\"\n\t\"github.com/containers/storage/pkg/fileutils\"\n\t\"github.com/containers/storage/pkg/idtools\"\n\t\"github.com/containers/storage/pkg/ioutils\"\n\t\"github.com/containers/storage/pkg/lockfile\"\n\t\"github.com/containers/storage/pkg/reexec\"\n\t\"github.com/containers/storage/pkg/unshare\"\n\tstorageTypes \"github.com/containers/storage/types\"\n\t\"github.com/opencontainers/go-digest\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/runtime-tools/generate\"\n\t\"github.com/opencontainers/selinux/go-selinux/label\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/exp/slices\"\n\t\"golang.org/x/sys/unix\"\n\t\"golang.org/x/term\"\n)\n\nfunc (b *Builder) createResolvConf(rdir string, chownOpts *idtools.IDPair) (string, error) {\n\tcfile := filepath.Join(rdir, \"resolv.conf\")\n\tf, err := os.Create(cfile)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer f.Close()\n\n\tuid := 0\n\tgid := 0\n\tif chownOpts != nil {\n\t\tuid = chownOpts.UID\n\t\tgid = chownOpts.GID\n\t}\n\tif err = f.Chown(uid, gid); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif err := relabel(cfile, b.MountLabel, false); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn cfile, nil\n}\n\n// addResolvConf copies files from host and sets them up to bind mount into container\nfunc (b *Builder) addResolvConfEntries(file string, networkNameServer []string,\n\tspec *specs.Spec, keepHostServers, ipv6 bool,\n) error {\n\tdefaultConfig, err := config.Default()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get config: %w\", err)\n\t}\n\n\tvar namespaces []specs.LinuxNamespace\n\tif spec.Linux != nil {\n\t\tnamespaces = spec.Linux.Namespaces\n\t}\n\n\tdnsServers, dnsSearch, dnsOptions := b.CommonBuildOpts.DNSServers, b.CommonBuildOpts.DNSSearch, b.CommonBuildOpts.DNSOptions\n\tnameservers := make([]string, 0, len(defaultConfig.Containers.DNSServers.Get())+len(dnsServers))\n\tnameservers = append(nameservers, defaultConfig.Containers.DNSServers.Get()...)\n\tnameservers = append(nameservers, dnsServers...)\n\n\tsearches := make([]string, 0, len(defaultConfig.Containers.DNSSearches.Get())+len(dnsSearch))\n\tsearches = append(searches, defaultConfig.Containers.DNSSearches.Get()...)\n\tsearches = append(searches, dnsSearch...)\n\n\toptions := make([]string, 0, len(defaultConfig.Containers.DNSOptions.Get())+len(dnsOptions))\n\toptions = append(options, defaultConfig.Containers.DNSOptions.Get()...)\n\toptions = append(options, dnsOptions...)\n\n\tif len(nameservers) == 0 {\n\t\tnameservers = networkNameServer\n\t}\n\n\tif err := resolvconf.New(&resolvconf.Params{\n\t\tPath:            file,\n\t\tNamespaces:      namespaces,\n\t\tIPv6Enabled:     ipv6,\n\t\tKeepHostServers: keepHostServers,\n\t\tNameservers:     nameservers,\n\t\tSearches:        searches,\n\t\tOptions:         options,\n\t}); err != nil {\n\t\treturn fmt.Errorf(\"building resolv.conf for container %s: %w\", b.ContainerID, err)\n\t}\n\n\treturn nil\n}\n\n// createHostsFile creates a containers hosts file\nfunc (b *Builder) createHostsFile(rdir string, chownOpts *idtools.IDPair) (string, error) {\n\ttargetfile := filepath.Join(rdir, \"hosts\")\n\tf, err := os.Create(targetfile)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer f.Close()\n\tuid := 0\n\tgid := 0\n\tif chownOpts != nil {\n\t\tuid = chownOpts.UID\n\t\tgid = chownOpts.GID\n\t}\n\tif err := f.Chown(uid, gid); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := relabel(targetfile, b.MountLabel, false); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn targetfile, nil\n}\n\nfunc (b *Builder) addHostsEntries(file, imageRoot string, entries etchosts.HostEntries, exclude []net.IP, preferIP string) error {\n\tconf, err := config.Default()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbase, err := etchosts.GetBaseHostFile(conf.Containers.BaseHostsFile, imageRoot)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn etchosts.New(&etchosts.Params{\n\t\tBaseFile:   base,\n\t\tExtraHosts: b.CommonBuildOpts.AddHost,\n\t\tHostContainersInternalIP: etchosts.GetHostContainersInternalIP(etchosts.HostContainersInternalOptions{\n\t\t\tConf:     conf,\n\t\t\tExclude:  exclude,\n\t\t\tPreferIP: preferIP,\n\t\t}),\n\t\tTargetFile:   file,\n\t\tContainerIPs: entries,\n\t})\n}\n\n// generateHostname creates a containers /etc/hostname file\nfunc (b *Builder) generateHostname(rdir, hostname string, chownOpts *idtools.IDPair) (string, error) {\n\tvar err error\n\thostnamePath := \"/etc/hostname\"\n\n\tvar hostnameBuffer bytes.Buffer\n\thostnameBuffer.Write([]byte(fmt.Sprintf(\"%s\\n\", hostname)))\n\n\tcfile := filepath.Join(rdir, filepath.Base(hostnamePath))\n\tif err = ioutils.AtomicWriteFile(cfile, hostnameBuffer.Bytes(), 0o644); err != nil {\n\t\treturn \"\", fmt.Errorf(\"writing /etc/hostname into the container: %w\", err)\n\t}\n\n\tuid := 0\n\tgid := 0\n\tif chownOpts != nil {\n\t\tuid = chownOpts.UID\n\t\tgid = chownOpts.GID\n\t}\n\tif err = os.Chown(cfile, uid, gid); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := relabel(cfile, b.MountLabel, false); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn cfile, nil\n}\n\nfunc setupTerminal(g *generate.Generator, terminalPolicy TerminalPolicy, terminalSize *specs.Box) {\n\tswitch terminalPolicy {\n\tcase DefaultTerminal:\n\t\tonTerminal := term.IsTerminal(unix.Stdin) && term.IsTerminal(unix.Stdout) && term.IsTerminal(unix.Stderr)\n\t\tif onTerminal {\n\t\t\tlogrus.Debugf(\"stdio is a terminal, defaulting to using a terminal\")\n\t\t} else {\n\t\t\tlogrus.Debugf(\"stdio is not a terminal, defaulting to not using a terminal\")\n\t\t}\n\t\tg.SetProcessTerminal(onTerminal)\n\tcase WithTerminal:\n\t\tg.SetProcessTerminal(true)\n\tcase WithoutTerminal:\n\t\tg.SetProcessTerminal(false)\n\t}\n\tif terminalSize != nil {\n\t\tg.SetProcessConsoleSize(terminalSize.Width, terminalSize.Height)\n\t}\n}\n\n// Search for a command that isn't given as an absolute path using the $PATH\n// under the rootfs.  We can't resolve absolute symbolic links without\n// chroot()ing, which we may not be able to do, so just accept a link as a\n// valid resolution.\nfunc runLookupPath(g *generate.Generator, command []string) []string {\n\t// Look for the configured $PATH.\n\tspec := g.Config\n\tenvPath := \"\"\n\tfor i := range spec.Process.Env {\n\t\tif strings.HasPrefix(spec.Process.Env[i], \"PATH=\") {\n\t\t\tenvPath = spec.Process.Env[i]\n\t\t}\n\t}\n\t// If there is no configured $PATH, supply one.\n\tif envPath == \"\" {\n\t\tdefaultPath := \"/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin\"\n\t\tenvPath = \"PATH=\" + defaultPath\n\t\tg.AddProcessEnv(\"PATH\", defaultPath)\n\t}\n\t// No command, nothing to do.\n\tif len(command) == 0 {\n\t\treturn command\n\t}\n\t// Command is already an absolute path, use it as-is.\n\tif filepath.IsAbs(command[0]) {\n\t\treturn command\n\t}\n\t// For each element in the PATH,\n\tfor _, pathEntry := range filepath.SplitList(envPath[5:]) {\n\t\t// if it's the empty string, it's \".\", which is the Cwd,\n\t\tif pathEntry == \"\" {\n\t\t\tpathEntry = spec.Process.Cwd\n\t\t}\n\t\t// build the absolute path which it might be,\n\t\tcandidate := filepath.Join(pathEntry, command[0])\n\t\t// check if it's there,\n\t\tif fi, err := os.Lstat(filepath.Join(spec.Root.Path, candidate)); fi != nil && err == nil {\n\t\t\t// and if it's not a directory, and either a symlink or executable,\n\t\t\tif !fi.IsDir() && ((fi.Mode()&os.ModeSymlink != 0) || (fi.Mode()&0o111 != 0)) {\n\t\t\t\t// use that.\n\t\t\t\treturn append([]string{candidate}, command[1:]...)\n\t\t\t}\n\t\t}\n\t}\n\treturn command\n}\n\nfunc (b *Builder) configureUIDGID(g *generate.Generator, mountPoint string, options RunOptions) (string, error) {\n\t// Set the user UID/GID/supplemental group list/capabilities lists.\n\tuser, homeDir, err := b.userForRun(mountPoint, options.User)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := setupCapabilities(g, b.Capabilities, options.AddCapabilities, options.DropCapabilities); err != nil {\n\t\treturn \"\", err\n\t}\n\tg.SetProcessUID(user.UID)\n\tg.SetProcessGID(user.GID)\n\tg.AddProcessAdditionalGid(user.GID)\n\tfor _, gid := range user.AdditionalGids {\n\t\tg.AddProcessAdditionalGid(gid)\n\t}\n\tfor _, group := range b.GroupAdd {\n\t\tif group == \"keep-groups\" {\n\t\t\tif len(b.GroupAdd) > 1 {\n\t\t\t\treturn \"\", errors.New(\"the '--group-add keep-groups' option is not allowed with any other --group-add options\")\n\t\t\t}\n\t\t\tg.AddAnnotation(\"run.oci.keep_original_groups\", \"1\")\n\t\t\tcontinue\n\t\t}\n\t\tgid, err := strconv.ParseUint(group, 10, 32)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tg.AddProcessAdditionalGid(uint32(gid))\n\t}\n\n\t// Remove capabilities if not running as root except Bounding set\n\tif user.UID != 0 && g.Config.Process.Capabilities != nil {\n\t\tbounding := g.Config.Process.Capabilities.Bounding\n\t\tg.ClearProcessCapabilities()\n\t\tg.Config.Process.Capabilities.Bounding = bounding\n\t}\n\n\treturn homeDir, nil\n}\n\nfunc (b *Builder) configureEnvironment(g *generate.Generator, options RunOptions, defaultEnv []string) {\n\tg.ClearProcessEnv()\n\n\tif b.CommonBuildOpts.HTTPProxy {\n\t\tfor _, envSpec := range config.ProxyEnv {\n\t\t\tif envVal, ok := os.LookupEnv(envSpec); ok {\n\t\t\t\tg.AddProcessEnv(envSpec, envVal)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, envSpec := range util.MergeEnv(util.MergeEnv(defaultEnv, b.Env()), options.Env) {\n\t\tenv := strings.SplitN(envSpec, \"=\", 2)\n\t\tif len(env) > 1 {\n\t\t\tg.AddProcessEnv(env[0], env[1])\n\t\t}\n\t}\n}\n\n// getNetworkInterface creates the network interface\nfunc getNetworkInterface(store storage.Store, cniConfDir, cniPluginPath string) (netTypes.ContainerNetwork, error) {\n\tconf, err := config.Default()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// copy the config to not modify the default by accident\n\tnewconf := *conf\n\tif len(cniConfDir) > 0 {\n\t\tnewconf.Network.NetworkConfigDir = cniConfDir\n\t}\n\tif len(cniPluginPath) > 0 {\n\t\tplugins := strings.Split(cniPluginPath, string(os.PathListSeparator))\n\t\tnewconf.Network.CNIPluginDirs.Set(plugins)\n\t}\n\n\t_, netInt, err := network.NetworkBackend(store, &newconf, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn netInt, nil\n}\n\nfunc netStatusToNetResult(netStatus map[string]netTypes.StatusBlock, hostnames []string) *netResult {\n\tresult := &netResult{\n\t\tkeepHostResolvers: false,\n\t}\n\tfor _, status := range netStatus {\n\t\tfor _, dns := range status.DNSServerIPs {\n\t\t\tresult.dnsServers = append(result.dnsServers, dns.String())\n\t\t}\n\t\tfor _, netInt := range status.Interfaces {\n\t\t\tfor _, netAddress := range netInt.Subnets {\n\t\t\t\te := etchosts.HostEntry{IP: netAddress.IPNet.IP.String(), Names: hostnames}\n\t\t\t\tresult.entries = append(result.entries, e)\n\t\t\t\tif !result.ipv6 && netUtil.IsIPv6(netAddress.IPNet.IP) {\n\t\t\t\t\tresult.ipv6 = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\n// DefaultNamespaceOptions returns the default namespace settings from the\n// runtime-tools generator library.\nfunc DefaultNamespaceOptions() (define.NamespaceOptions, error) {\n\tcfg, err := config.Default()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get container config: %w\", err)\n\t}\n\toptions := define.NamespaceOptions{\n\t\t{Name: string(specs.CgroupNamespace), Host: cfg.CgroupNS() == \"host\"},\n\t\t{Name: string(specs.IPCNamespace), Host: cfg.IPCNS() == \"host\"},\n\t\t{Name: string(specs.MountNamespace), Host: false},\n\t\t{Name: string(specs.NetworkNamespace), Host: cfg.NetNS() == \"host\"},\n\t\t{Name: string(specs.PIDNamespace), Host: cfg.PidNS() == \"host\"},\n\t\t{Name: string(specs.UserNamespace), Host: cfg.Containers.UserNS == \"\" || cfg.Containers.UserNS == \"host\"},\n\t\t{Name: string(specs.UTSNamespace), Host: cfg.UTSNS() == \"host\"},\n\t}\n\treturn options, nil\n}\n\nfunc checkAndOverrideIsolationOptions(isolation define.Isolation, options *RunOptions) error {\n\tswitch isolation {\n\tcase IsolationOCIRootless:\n\t\t// only change the netns if the caller did not set it\n\t\tif ns := options.NamespaceOptions.Find(string(specs.NetworkNamespace)); ns == nil {\n\t\t\tif _, err := exec.LookPath(\"slirp4netns\"); err != nil {\n\t\t\t\t// if slirp4netns is not installed we have to use the hosts net namespace\n\t\t\t\toptions.NamespaceOptions.AddOrReplace(define.NamespaceOption{Name: string(specs.NetworkNamespace), Host: true})\n\t\t\t}\n\t\t}\n\t\tfallthrough\n\tcase IsolationOCI:\n\t\tpidns := options.NamespaceOptions.Find(string(specs.PIDNamespace))\n\t\tuserns := options.NamespaceOptions.Find(string(specs.UserNamespace))\n\t\tif (pidns != nil && pidns.Host) && (userns != nil && !userns.Host) {\n\t\t\treturn fmt.Errorf(\"not allowed to mix host PID namespace with container user namespace\")\n\t\t}\n\tcase IsolationChroot:\n\t\tlogrus.Info(\"network namespace isolation not supported with chroot isolation, forcing host network\")\n\t\toptions.NamespaceOptions.AddOrReplace(define.NamespaceOption{Name: string(specs.NetworkNamespace), Host: true})\n\t}\n\treturn nil\n}\n\n// fileCloser is a helper struct to prevent closing the file twice in the code\n// users must call (fileCloser).Close() and not fileCloser.File.Close()\ntype fileCloser struct {\n\tfile   *os.File\n\tclosed bool\n}\n\nfunc (f *fileCloser) Close() {\n\tif !f.closed {\n\t\tif err := f.file.Close(); err != nil {\n\t\t\tlogrus.Errorf(\"failed to close file: %v\", err)\n\t\t}\n\t\tf.closed = true\n\t}\n}\n\n// waitForSync waits for a maximum of 4 minutes to read something from the file\nfunc waitForSync(pipeR *os.File) error {\n\tif err := pipeR.SetDeadline(time.Now().Add(4 * time.Minute)); err != nil {\n\t\treturn err\n\t}\n\tb := make([]byte, 16)\n\t_, err := pipeR.Read(b)\n\treturn err\n}\n\nfunc runUsingRuntime(options RunOptions, configureNetwork bool, moreCreateArgs []string, spec *specs.Spec, bundlePath, containerName string,\n\tcontainerCreateW io.WriteCloser, containerStartR io.ReadCloser,\n) (wstatus unix.WaitStatus, err error) {\n\tif options.Logger == nil {\n\t\toptions.Logger = logrus.StandardLogger()\n\t}\n\n\t// Lock the caller to a single OS-level thread.\n\truntime.LockOSThread()\n\n\t// Set up bind mounts for things that a namespaced user might not be able to get to directly.\n\tunmountAll, err := bind.SetupIntermediateMountNamespace(spec, bundlePath)\n\tif unmountAll != nil {\n\t\tdefer func() {\n\t\t\tif err := unmountAll(); err != nil {\n\t\t\t\toptions.Logger.Error(err)\n\t\t\t}\n\t\t}()\n\t}\n\tif err != nil {\n\t\treturn 1, err\n\t}\n\n\t// Write the runtime configuration.\n\tspecbytes, err := json.Marshal(spec)\n\tif err != nil {\n\t\treturn 1, fmt.Errorf(\"encoding configuration %#v as json: %w\", spec, err)\n\t}\n\tif err = ioutils.AtomicWriteFile(filepath.Join(bundlePath, \"config.json\"), specbytes, 0o600); err != nil {\n\t\treturn 1, fmt.Errorf(\"storing runtime configuration: %w\", err)\n\t}\n\n\tlogrus.Debugf(\"config = %v\", string(specbytes))\n\n\t// Decide which runtime to use.\n\truntime := options.Runtime\n\tif runtime == \"\" {\n\t\truntime = util.Runtime()\n\t}\n\tlocalRuntime := util.FindLocalRuntime(runtime)\n\tif localRuntime != \"\" {\n\t\truntime = localRuntime\n\t}\n\n\t// Default to just passing down our stdio.\n\tgetCreateStdio := func() (io.ReadCloser, io.WriteCloser, io.WriteCloser) {\n\t\treturn os.Stdin, os.Stdout, os.Stderr\n\t}\n\n\t// Figure out how we're doing stdio handling, and create pipes and sockets.\n\tvar stdio sync.WaitGroup\n\tvar consoleListener *net.UnixListener\n\tvar errorFds, closeBeforeReadingErrorFds []int\n\tstdioPipe := make([][]int, 3)\n\tcopyConsole := false\n\tcopyPipes := false\n\tfinishCopy := make([]int, 2)\n\tif err = unix.Pipe(finishCopy); err != nil {\n\t\treturn 1, fmt.Errorf(\"creating pipe for notifying to stop stdio: %w\", err)\n\t}\n\tfinishedCopy := make(chan struct{}, 1)\n\tvar pargs []string\n\tif spec.Process != nil {\n\t\tpargs = spec.Process.Args\n\t\tif spec.Process.Terminal {\n\t\t\tcopyConsole = true\n\t\t\t// Create a listening socket for accepting the container's terminal's PTY master.\n\t\t\tsocketPath := filepath.Join(bundlePath, \"console.sock\")\n\t\t\tconsoleListener, err = net.ListenUnix(\"unix\", &net.UnixAddr{Name: socketPath, Net: \"unix\"})\n\t\t\tif err != nil {\n\t\t\t\treturn 1, fmt.Errorf(\"creating socket %q to receive terminal descriptor: %w\", consoleListener.Addr(), err)\n\t\t\t}\n\t\t\t// Add console socket arguments.\n\t\t\tmoreCreateArgs = append(moreCreateArgs, \"--console-socket\", socketPath)\n\t\t} else {\n\t\t\tcopyPipes = true\n\t\t\t// Figure out who should own the pipes.\n\t\t\tuid, gid, err := util.GetHostRootIDs(spec)\n\t\t\tif err != nil {\n\t\t\t\treturn 1, err\n\t\t\t}\n\t\t\t// Create stdio pipes.\n\t\t\tif stdioPipe, err = runMakeStdioPipe(int(uid), int(gid)); err != nil {\n\t\t\t\treturn 1, err\n\t\t\t}\n\t\t\tif spec.Linux != nil {\n\t\t\t\tif err = runLabelStdioPipes(stdioPipe, spec.Process.SelinuxLabel, spec.Linux.MountLabel); err != nil {\n\t\t\t\t\treturn 1, err\n\t\t\t\t}\n\t\t\t}\n\t\t\terrorFds = []int{stdioPipe[unix.Stdout][0], stdioPipe[unix.Stderr][0]}\n\t\t\tcloseBeforeReadingErrorFds = []int{stdioPipe[unix.Stdout][1], stdioPipe[unix.Stderr][1]}\n\t\t\t// Set stdio to our pipes.\n\t\t\tgetCreateStdio = func() (io.ReadCloser, io.WriteCloser, io.WriteCloser) {\n\t\t\t\tstdin := os.NewFile(uintptr(stdioPipe[unix.Stdin][0]), \"/dev/stdin\")\n\t\t\t\tstdout := os.NewFile(uintptr(stdioPipe[unix.Stdout][1]), \"/dev/stdout\")\n\t\t\t\tstderr := os.NewFile(uintptr(stdioPipe[unix.Stderr][1]), \"/dev/stderr\")\n\t\t\t\treturn stdin, stdout, stderr\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif options.Quiet {\n\t\t\t// Discard stdout.\n\t\t\tgetCreateStdio = func() (io.ReadCloser, io.WriteCloser, io.WriteCloser) {\n\t\t\t\treturn os.Stdin, nil, os.Stderr\n\t\t\t}\n\t\t}\n\t}\n\n\truntimeArgs := slices.Clone(options.Args)\n\tif options.CgroupManager == config.SystemdCgroupsManager {\n\t\truntimeArgs = append(runtimeArgs, \"--systemd-cgroup\")\n\t}\n\n\t// Build the commands that we'll execute.\n\tpidFile := filepath.Join(bundlePath, \"pid\")\n\targs := append(append(append(runtimeArgs, \"create\", \"--bundle\", bundlePath, \"--pid-file\", pidFile), moreCreateArgs...), containerName)\n\tcreate := exec.Command(runtime, args...)\n\tsetPdeathsig(create)\n\tcreate.Dir = bundlePath\n\tstdin, stdout, stderr := getCreateStdio()\n\tcreate.Stdin, create.Stdout, create.Stderr = stdin, stdout, stderr\n\n\targs = append(options.Args, \"start\", containerName)\n\tstart := exec.Command(runtime, args...)\n\tsetPdeathsig(start)\n\tstart.Dir = bundlePath\n\tstart.Stderr = os.Stderr\n\n\tkill := func(signal string) *exec.Cmd {\n\t\targs := append(options.Args, \"kill\", containerName)\n\t\tif signal != \"\" {\n\t\t\targs = append(args, signal)\n\t\t}\n\t\tkill := exec.Command(runtime, args...)\n\t\tkill.Dir = bundlePath\n\t\tkill.Stderr = os.Stderr\n\t\treturn kill\n\t}\n\n\targs = append(options.Args, \"delete\", containerName)\n\tdel := exec.Command(runtime, args...)\n\tdel.Dir = bundlePath\n\tdel.Stderr = os.Stderr\n\n\t// Actually create the container.\n\tlogrus.Debugf(\"Running %q\", create.Args)\n\terr = create.Run()\n\tif err != nil {\n\t\treturn 1, fmt.Errorf(\"from %s creating container for %v: %s: %w\", runtime, pargs, runCollectOutput(options.Logger, errorFds, closeBeforeReadingErrorFds), err)\n\t}\n\tdefer func() {\n\t\terr2 := del.Run()\n\t\tif err2 != nil {\n\t\t\tif err == nil {\n\t\t\t\terr = fmt.Errorf(\"deleting container: %w\", err2)\n\t\t\t} else {\n\t\t\t\toptions.Logger.Infof(\"error from %s deleting container: %v\", runtime, err2)\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Make sure we read the container's exit status when it exits.\n\tpidValue, err := os.ReadFile(pidFile)\n\tif err != nil {\n\t\treturn 1, err\n\t}\n\tpid, err := strconv.Atoi(strings.TrimSpace(string(pidValue)))\n\tif err != nil {\n\t\treturn 1, fmt.Errorf(\"parsing pid %s as a number: %w\", string(pidValue), err)\n\t}\n\tvar stopped uint32\n\tvar reaping sync.WaitGroup\n\treaping.Add(1)\n\tgo func() {\n\t\tdefer reaping.Done()\n\t\tvar err error\n\t\t_, err = unix.Wait4(pid, &wstatus, 0, nil)\n\t\tif err != nil {\n\t\t\twstatus = 0\n\t\t\toptions.Logger.Errorf(\"error waiting for container child process %d: %v\\n\", pid, err)\n\t\t}\n\t\tatomic.StoreUint32(&stopped, 1)\n\t}()\n\n\tif configureNetwork {\n\t\tif _, err := containerCreateW.Write([]byte{1}); err != nil {\n\t\t\treturn 1, err\n\t\t}\n\t\tcontainerCreateW.Close()\n\t\tlogrus.Debug(\"waiting for parent start message\")\n\t\tb := make([]byte, 1)\n\t\tif _, err := containerStartR.Read(b); err != nil {\n\t\t\treturn 1, fmt.Errorf(\"did not get container start message from parent: %w\", err)\n\t\t}\n\t\tcontainerStartR.Close()\n\t}\n\n\tif copyPipes {\n\t\t// We don't need the ends of the pipes that belong to the container.\n\t\tstdin.Close()\n\t\tif stdout != nil {\n\t\t\tstdout.Close()\n\t\t}\n\t\tstderr.Close()\n\t}\n\n\t// Handle stdio for the container in the background.\n\tstdio.Add(1)\n\tgo runCopyStdio(options.Logger, &stdio, copyPipes, stdioPipe, copyConsole, consoleListener, finishCopy, finishedCopy, spec)\n\n\t// Start the container.\n\tlogrus.Debugf(\"Running %q\", start.Args)\n\terr = start.Run()\n\tif err != nil {\n\t\treturn 1, fmt.Errorf(\"from %s starting container: %w\", runtime, err)\n\t}\n\tdefer func() {\n\t\tif atomic.LoadUint32(&stopped) == 0 {\n\t\t\tif err := kill(\"\").Run(); err != nil {\n\t\t\t\toptions.Logger.Infof(\"error from %s stopping container: %v\", runtime, err)\n\t\t\t}\n\t\t\tatomic.StoreUint32(&stopped, 1)\n\t\t}\n\t}()\n\n\t// Wait for the container to exit.\n\tinterrupted := make(chan os.Signal, 100)\n\tgo func() {\n\t\tfor range interrupted {\n\t\t\tif err := kill(\"SIGKILL\").Run(); err != nil {\n\t\t\t\tlogrus.Errorf(\"%v sending SIGKILL\", err)\n\t\t\t}\n\t\t}\n\t}()\n\tsignal.Notify(interrupted, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM)\n\tfor {\n\t\tnow := time.Now()\n\t\tvar state specs.State\n\t\targs = append(options.Args, \"state\", containerName)\n\t\tstat := exec.Command(runtime, args...)\n\t\tstat.Dir = bundlePath\n\t\tstat.Stderr = os.Stderr\n\t\tstateOutput, err := stat.Output()\n\t\tif err != nil {\n\t\t\tif atomic.LoadUint32(&stopped) != 0 {\n\t\t\t\t// container exited\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn 1, fmt.Errorf(\"reading container state from %s (got output: %q): %w\", runtime, string(stateOutput), err)\n\t\t}\n\t\tif err = json.Unmarshal(stateOutput, &state); err != nil {\n\t\t\treturn 1, fmt.Errorf(\"parsing container state %q from %s: %w\", string(stateOutput), runtime, err)\n\t\t}\n\t\tswitch state.Status {\n\t\tcase \"running\":\n\t\tcase \"stopped\":\n\t\t\tatomic.StoreUint32(&stopped, 1)\n\t\tdefault:\n\t\t\treturn 1, fmt.Errorf(\"container status unexpectedly changed to %q\", state.Status)\n\t\t}\n\t\tif atomic.LoadUint32(&stopped) != 0 {\n\t\t\tbreak\n\t\t}\n\t\tselect {\n\t\tcase <-finishedCopy:\n\t\t\tatomic.StoreUint32(&stopped, 1)\n\t\tcase <-time.After(time.Until(now.Add(100 * time.Millisecond))):\n\t\t\tcontinue\n\t\t}\n\t\tif atomic.LoadUint32(&stopped) != 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\tsignal.Stop(interrupted)\n\tclose(interrupted)\n\n\t// Close the writing end of the stop-handling-stdio notification pipe.\n\tunix.Close(finishCopy[1])\n\t// Wait for the stdio copy goroutine to flush.\n\tstdio.Wait()\n\t// Wait until we finish reading the exit status.\n\treaping.Wait()\n\n\treturn wstatus, nil\n}\n\nfunc runCollectOutput(logger *logrus.Logger, fds, closeBeforeReadingFds []int) string { //nolint:interfacer\n\tfor _, fd := range closeBeforeReadingFds {\n\t\tunix.Close(fd)\n\t}\n\tvar b bytes.Buffer\n\tbuf := make([]byte, 8192)\n\tfor _, fd := range fds {\n\t\tnread, err := unix.Read(fd, buf)\n\t\tif err != nil {\n\t\t\tif errno, isErrno := err.(syscall.Errno); isErrno {\n\t\t\t\tswitch errno {\n\t\t\t\tdefault:\n\t\t\t\t\tlogger.Errorf(\"error reading from pipe %d: %v\", fd, err)\n\t\t\t\tcase syscall.EINTR, syscall.EAGAIN:\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.Errorf(\"unable to wait for data from pipe %d: %v\", fd, err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tfor nread > 0 {\n\t\t\tr := buf[:nread]\n\t\t\tif nwritten, err := b.Write(r); err != nil || nwritten != len(r) {\n\t\t\t\tif nwritten != len(r) {\n\t\t\t\t\tlogger.Errorf(\"error buffering data from pipe %d: %v\", fd, err)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tnread, err = unix.Read(fd, buf)\n\t\t\tif err != nil {\n\t\t\t\tif errno, isErrno := err.(syscall.Errno); isErrno {\n\t\t\t\t\tswitch errno {\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tlogger.Errorf(\"error reading from pipe %d: %v\", fd, err)\n\t\t\t\t\tcase syscall.EINTR, syscall.EAGAIN:\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlogger.Errorf(\"unable to wait for data from pipe %d: %v\", fd, err)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn b.String()\n}\n\nfunc setNonblock(logger *logrus.Logger, fd int, description string, nonblocking bool) (bool, error) { //nolint:interfacer\n\tmask, err := unix.FcntlInt(uintptr(fd), unix.F_GETFL, 0)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tblocked := mask&unix.O_NONBLOCK == 0\n\n\tif err := unix.SetNonblock(fd, nonblocking); err != nil {\n\t\tif nonblocking {\n\t\t\tlogger.Errorf(\"error setting %s to nonblocking: %v\", description, err)\n\t\t} else {\n\t\t\tlogger.Errorf(\"error setting descriptor %s blocking: %v\", description, err)\n\t\t}\n\t}\n\treturn blocked, err\n}\n\nfunc runCopyStdio(logger *logrus.Logger, stdio *sync.WaitGroup, copyPipes bool, stdioPipe [][]int, copyConsole bool, consoleListener *net.UnixListener, finishCopy []int, finishedCopy chan struct{}, spec *specs.Spec) {\n\tdefer func() {\n\t\tunix.Close(finishCopy[0])\n\t\tif copyPipes {\n\t\t\tunix.Close(stdioPipe[unix.Stdin][1])\n\t\t\tunix.Close(stdioPipe[unix.Stdout][0])\n\t\t\tunix.Close(stdioPipe[unix.Stderr][0])\n\t\t}\n\t\tstdio.Done()\n\t\tfinishedCopy <- struct{}{}\n\t\tclose(finishedCopy)\n\t}()\n\t// Map describing where data on an incoming descriptor should go.\n\trelayMap := make(map[int]int)\n\t// Map describing incoming and outgoing descriptors.\n\treadDesc := make(map[int]string)\n\twriteDesc := make(map[int]string)\n\t// Buffers.\n\trelayBuffer := make(map[int]*bytes.Buffer)\n\t// Set up the terminal descriptor or pipes for polling.\n\tif copyConsole {\n\t\t// Accept a connection over our listening socket.\n\t\tfd, err := runAcceptTerminal(logger, consoleListener, spec.Process.ConsoleSize)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"%v\", err)\n\t\t\treturn\n\t\t}\n\t\tterminalFD := fd\n\t\t// Input from our stdin, output from the terminal descriptor.\n\t\trelayMap[unix.Stdin] = terminalFD\n\t\treadDesc[unix.Stdin] = \"stdin\"\n\t\trelayBuffer[terminalFD] = new(bytes.Buffer)\n\t\twriteDesc[terminalFD] = \"container terminal input\"\n\t\trelayMap[terminalFD] = unix.Stdout\n\t\treadDesc[terminalFD] = \"container terminal output\"\n\t\trelayBuffer[unix.Stdout] = new(bytes.Buffer)\n\t\twriteDesc[unix.Stdout] = \"output\"\n\t\t// Set our terminal's mode to raw, to pass handling of special\n\t\t// terminal input to the terminal in the container.\n\t\tif term.IsTerminal(unix.Stdin) {\n\t\t\tif state, err := term.MakeRaw(unix.Stdin); err != nil {\n\t\t\t\tlogger.Warnf(\"error setting terminal state: %v\", err)\n\t\t\t} else {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif err = term.Restore(unix.Stdin, state); err != nil {\n\t\t\t\t\t\tlogger.Errorf(\"unable to restore terminal state: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t}\n\t}\n\tif copyPipes {\n\t\t// Input from our stdin, output from the stdout and stderr pipes.\n\t\trelayMap[unix.Stdin] = stdioPipe[unix.Stdin][1]\n\t\treadDesc[unix.Stdin] = \"stdin\"\n\t\trelayBuffer[stdioPipe[unix.Stdin][1]] = new(bytes.Buffer)\n\t\twriteDesc[stdioPipe[unix.Stdin][1]] = \"container stdin\"\n\t\trelayMap[stdioPipe[unix.Stdout][0]] = unix.Stdout\n\t\treadDesc[stdioPipe[unix.Stdout][0]] = \"container stdout\"\n\t\trelayBuffer[unix.Stdout] = new(bytes.Buffer)\n\t\twriteDesc[unix.Stdout] = \"stdout\"\n\t\trelayMap[stdioPipe[unix.Stderr][0]] = unix.Stderr\n\t\treadDesc[stdioPipe[unix.Stderr][0]] = \"container stderr\"\n\t\trelayBuffer[unix.Stderr] = new(bytes.Buffer)\n\t\twriteDesc[unix.Stderr] = \"stderr\"\n\t}\n\t// Set our reading descriptors to non-blocking.\n\tfor rfd, wfd := range relayMap {\n\t\tblocked, err := setNonblock(logger, rfd, readDesc[rfd], true)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif blocked {\n\t\t\tdefer setNonblock(logger, rfd, readDesc[rfd], false) // nolint:errcheck\n\t\t}\n\t\tsetNonblock(logger, wfd, writeDesc[wfd], false) // nolint:errcheck\n\t}\n\n\tif copyPipes {\n\t\tsetNonblock(logger, stdioPipe[unix.Stdin][1], writeDesc[stdioPipe[unix.Stdin][1]], true) // nolint:errcheck\n\t}\n\n\trunCopyStdioPassData(copyPipes, stdioPipe, finishCopy, relayMap, relayBuffer, readDesc, writeDesc)\n}\n\nfunc canRetry(err error) bool {\n\tif errno, isErrno := err.(syscall.Errno); isErrno {\n\t\treturn errno == syscall.EINTR || errno == syscall.EAGAIN\n\t}\n\treturn false\n}\n\nfunc runCopyStdioPassData(copyPipes bool, stdioPipe [][]int, finishCopy []int, relayMap map[int]int, relayBuffer map[int]*bytes.Buffer, readDesc map[int]string, writeDesc map[int]string) {\n\tcloseStdin := false\n\n\t// Pass data back and forth.\n\tpollTimeout := -1\n\tfor len(relayMap) > 0 {\n\t\t// Start building the list of descriptors to poll.\n\t\tpollFds := make([]unix.PollFd, 0, len(relayMap)+1)\n\t\t// Poll for a notification that we should stop handling stdio.\n\t\tpollFds = append(pollFds, unix.PollFd{Fd: int32(finishCopy[0]), Events: unix.POLLIN | unix.POLLHUP})\n\t\t// Poll on our reading descriptors.\n\t\tfor rfd := range relayMap {\n\t\t\tpollFds = append(pollFds, unix.PollFd{Fd: int32(rfd), Events: unix.POLLIN | unix.POLLHUP})\n\t\t}\n\t\tbuf := make([]byte, 8192)\n\t\t// Wait for new data from any input descriptor, or a notification that we're done.\n\t\t_, err := unix.Poll(pollFds, pollTimeout)\n\t\tif !util.LogIfNotRetryable(err, fmt.Sprintf(\"error waiting for stdio/terminal data to relay: %v\", err)) {\n\t\t\treturn\n\t\t}\n\t\tremoves := make(map[int]struct{})\n\t\tfor _, pollFd := range pollFds {\n\t\t\t// If this descriptor's just been closed from the other end, mark it for\n\t\t\t// removal from the set that we're checking for.\n\t\t\tif pollFd.Revents&unix.POLLHUP == unix.POLLHUP {\n\t\t\t\tremoves[int(pollFd.Fd)] = struct{}{}\n\t\t\t}\n\t\t\t// If the descriptor was closed elsewhere, remove it from our list.\n\t\t\tif pollFd.Revents&unix.POLLNVAL != 0 {\n\t\t\t\tlogrus.Debugf(\"error polling descriptor %s: closed?\", readDesc[int(pollFd.Fd)])\n\t\t\t\tremoves[int(pollFd.Fd)] = struct{}{}\n\t\t\t}\n\t\t\t// If the POLLIN flag isn't set, then there's no data to be read from this descriptor.\n\t\t\tif pollFd.Revents&unix.POLLIN == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Read whatever there is to be read.\n\t\t\treadFD := int(pollFd.Fd)\n\t\t\twriteFD, needToRelay := relayMap[readFD]\n\t\t\tif needToRelay {\n\t\t\t\tn, err := unix.Read(readFD, buf)\n\t\t\t\tif !util.LogIfNotRetryable(err, fmt.Sprintf(\"unable to read %s data: %v\", readDesc[readFD], err)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t// If it's zero-length on our stdin and we're\n\t\t\t\t// using pipes, it's an EOF, so close the stdin\n\t\t\t\t// pipe's writing end.\n\t\t\t\tif n == 0 && !canRetry(err) && int(pollFd.Fd) == unix.Stdin {\n\t\t\t\t\tremoves[int(pollFd.Fd)] = struct{}{}\n\t\t\t\t} else if n > 0 {\n\t\t\t\t\t// Buffer the data in case we get blocked on where they need to go.\n\t\t\t\t\tnwritten, err := relayBuffer[writeFD].Write(buf[:n])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlogrus.Debugf(\"buffer: %v\", err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif nwritten != n {\n\t\t\t\t\t\tlogrus.Debugf(\"buffer: expected to buffer %d bytes, wrote %d\", n, nwritten)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t// If this is the last of the data we'll be able to read from this\n\t\t\t\t\t// descriptor, read all that there is to read.\n\t\t\t\t\tfor pollFd.Revents&unix.POLLHUP == unix.POLLHUP {\n\t\t\t\t\t\tnr, err := unix.Read(readFD, buf)\n\t\t\t\t\t\tutil.LogIfUnexpectedWhileDraining(err, fmt.Sprintf(\"read %s: %v\", readDesc[readFD], err))\n\t\t\t\t\t\tif nr <= 0 {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnwritten, err := relayBuffer[writeFD].Write(buf[:nr])\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tlogrus.Debugf(\"buffer: %v\", err)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif nwritten != nr {\n\t\t\t\t\t\t\tlogrus.Debugf(\"buffer: expected to buffer %d bytes, wrote %d\", nr, nwritten)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Try to drain the output buffers.  Set the default timeout\n\t\t// for the next poll() to 100ms if we still have data to write.\n\t\tpollTimeout = -1\n\t\tfor writeFD := range relayBuffer {\n\t\t\tif relayBuffer[writeFD].Len() > 0 {\n\t\t\t\tn, err := unix.Write(writeFD, relayBuffer[writeFD].Bytes())\n\t\t\t\tif !util.LogIfNotRetryable(err, fmt.Sprintf(\"unable to write %s data: %v\", writeDesc[writeFD], err)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif n > 0 {\n\t\t\t\t\trelayBuffer[writeFD].Next(n)\n\t\t\t\t}\n\t\t\t\tif closeStdin && writeFD == stdioPipe[unix.Stdin][1] && stdioPipe[unix.Stdin][1] >= 0 && relayBuffer[stdioPipe[unix.Stdin][1]].Len() == 0 {\n\t\t\t\t\tlogrus.Debugf(\"closing stdin\")\n\t\t\t\t\tunix.Close(stdioPipe[unix.Stdin][1])\n\t\t\t\t\tstdioPipe[unix.Stdin][1] = -1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif relayBuffer[writeFD].Len() > 0 {\n\t\t\t\tpollTimeout = 100\n\t\t\t}\n\t\t}\n\t\t// Remove any descriptors which we don't need to poll any more from the poll descriptor list.\n\t\tfor remove := range removes {\n\t\t\tif copyPipes && remove == unix.Stdin {\n\t\t\t\tcloseStdin = true\n\t\t\t\tif relayBuffer[stdioPipe[unix.Stdin][1]].Len() == 0 {\n\t\t\t\t\tlogrus.Debugf(\"closing stdin\")\n\t\t\t\t\tunix.Close(stdioPipe[unix.Stdin][1])\n\t\t\t\t\tstdioPipe[unix.Stdin][1] = -1\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete(relayMap, remove)\n\t\t}\n\t\t// If the we-can-return pipe had anything for us, we're done.\n\t\tfor _, pollFd := range pollFds {\n\t\t\tif int(pollFd.Fd) == finishCopy[0] && pollFd.Revents != 0 {\n\t\t\t\t// The pipe is closed, indicating that we can stop now.\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc runAcceptTerminal(logger *logrus.Logger, consoleListener *net.UnixListener, terminalSize *specs.Box) (int, error) {\n\tdefer consoleListener.Close()\n\tc, err := consoleListener.AcceptUnix()\n\tif err != nil {\n\t\treturn -1, fmt.Errorf(\"accepting socket descriptor connection: %w\", err)\n\t}\n\tdefer c.Close()\n\t// Expect a control message over our new connection.\n\tb := make([]byte, 8192)\n\toob := make([]byte, 8192)\n\tn, oobn, _, _, err := c.ReadMsgUnix(b, oob)\n\tif err != nil {\n\t\treturn -1, fmt.Errorf(\"reading socket descriptor: %w\", err)\n\t}\n\tif n > 0 {\n\t\tlogrus.Debugf(\"socket descriptor is for %q\", string(b[:n]))\n\t}\n\tif oobn > len(oob) {\n\t\treturn -1, fmt.Errorf(\"too much out-of-bounds data (%d bytes)\", oobn)\n\t}\n\t// Parse the control message.\n\tscm, err := unix.ParseSocketControlMessage(oob[:oobn])\n\tif err != nil {\n\t\treturn -1, fmt.Errorf(\"parsing out-of-bound data as a socket control message: %w\", err)\n\t}\n\tlogrus.Debugf(\"control messages: %v\", scm)\n\t// Expect to get a descriptor.\n\tterminalFD := -1\n\tfor i := range scm {\n\t\tfds, err := unix.ParseUnixRights(&scm[i])\n\t\tif err != nil {\n\t\t\treturn -1, fmt.Errorf(\"parsing unix rights control message: %v: %w\", &scm[i], err)\n\t\t}\n\t\tlogrus.Debugf(\"fds: %v\", fds)\n\t\tif len(fds) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tterminalFD = fds[0]\n\t\tbreak\n\t}\n\tif terminalFD == -1 {\n\t\treturn -1, fmt.Errorf(\"unable to read terminal descriptor\")\n\t}\n\t// Set the pseudoterminal's size to the configured size, or our own.\n\twinsize := &unix.Winsize{}\n\tif terminalSize != nil {\n\t\t// Use configured sizes.\n\t\twinsize.Row = uint16(terminalSize.Height)\n\t\twinsize.Col = uint16(terminalSize.Width)\n\t} else {\n\t\tif term.IsTerminal(unix.Stdin) {\n\t\t\t// Use the size of our terminal.\n\t\t\tif winsize, err = unix.IoctlGetWinsize(unix.Stdin, unix.TIOCGWINSZ); err != nil {\n\t\t\t\tlogger.Warnf(\"error reading size of controlling terminal: %v\", err)\n\t\t\t\twinsize.Row = 0\n\t\t\t\twinsize.Col = 0\n\t\t\t}\n\t\t}\n\t}\n\tif winsize.Row != 0 && winsize.Col != 0 {\n\t\tif err = unix.IoctlSetWinsize(terminalFD, unix.TIOCSWINSZ, winsize); err != nil {\n\t\t\tlogger.Warnf(\"error setting size of container pseudoterminal: %v\", err)\n\t\t}\n\t\t// FIXME - if we're connected to a terminal, we should\n\t\t// be passing the updated terminal size down when we\n\t\t// receive a SIGWINCH.\n\t}\n\treturn terminalFD, nil\n}\n\nfunc runUsingRuntimeMain() {\n\tvar options runUsingRuntimeSubprocOptions\n\t// Set logging.\n\tif level := os.Getenv(\"LOGLEVEL\"); level != \"\" {\n\t\tif ll, err := strconv.Atoi(level); err == nil {\n\t\t\tlogrus.SetLevel(logrus.Level(ll))\n\t\t}\n\t}\n\t// Unpack our configuration.\n\tconfPipe := os.NewFile(3, \"confpipe\")\n\tif confPipe == nil {\n\t\tfmt.Fprintf(os.Stderr, \"error reading options pipe\\n\")\n\t\tos.Exit(1)\n\t}\n\tdefer confPipe.Close()\n\tif err := json.NewDecoder(confPipe).Decode(&options); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error decoding options: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\t// Set ourselves up to read the container's exit status.  We're doing this in a child process\n\t// so that we won't mess with the setting in a caller of the library.\n\tif err := setChildProcess(); err != nil {\n\t\tos.Exit(1)\n\t}\n\tospec := options.Spec\n\tif ospec == nil {\n\t\tfmt.Fprintf(os.Stderr, \"options spec not specified\\n\")\n\t\tos.Exit(1)\n\t}\n\n\t// open the pipes used to communicate with the parent process\n\tvar containerCreateW *os.File\n\tvar containerStartR *os.File\n\tif options.ConfigureNetwork {\n\t\tcontainerCreateW = os.NewFile(4, \"containercreatepipe\")\n\t\tif containerCreateW == nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"could not open fd 4\\n\")\n\t\t\tos.Exit(1)\n\t\t}\n\t\tcontainerStartR = os.NewFile(5, \"containerstartpipe\")\n\t\tif containerStartR == nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"could not open fd 5\\n\")\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n\n\t// Run the container, start to finish.\n\tstatus, err := runUsingRuntime(options.Options, options.ConfigureNetwork, options.MoreCreateArgs, ospec, options.BundlePath, options.ContainerName, containerCreateW, containerStartR)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error running container: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\t// Pass the container's exit status back to the caller by exiting with the same status.\n\tif status.Exited() {\n\t\tos.Exit(status.ExitStatus())\n\t} else if status.Signaled() {\n\t\tfmt.Fprintf(os.Stderr, \"container exited on %s\\n\", status.Signal())\n\t\tos.Exit(1)\n\t}\n\tos.Exit(1)\n}\n\nfunc (b *Builder) runUsingRuntimeSubproc(isolation define.Isolation, options RunOptions, configureNetwork bool, networkString string,\n\tmoreCreateArgs []string, spec *specs.Spec, rootPath, bundlePath, containerName, buildContainerName, hostsFile, resolvFile string,\n) (err error) {\n\t// Lock the caller to a single OS-level thread.\n\truntime.LockOSThread()\n\tdefer runtime.UnlockOSThread()\n\n\tvar confwg sync.WaitGroup\n\tconfig, conferr := json.Marshal(runUsingRuntimeSubprocOptions{\n\t\tOptions:          options,\n\t\tSpec:             spec,\n\t\tRootPath:         rootPath,\n\t\tBundlePath:       bundlePath,\n\t\tConfigureNetwork: configureNetwork,\n\t\tMoreCreateArgs:   moreCreateArgs,\n\t\tContainerName:    containerName,\n\t\tIsolation:        isolation,\n\t})\n\tif conferr != nil {\n\t\treturn fmt.Errorf(\"encoding configuration for %q: %w\", runUsingRuntimeCommand, conferr)\n\t}\n\tcmd := reexec.Command(runUsingRuntimeCommand)\n\tsetPdeathsig(cmd)\n\tcmd.Dir = bundlePath\n\tcmd.Stdin = options.Stdin\n\tif cmd.Stdin == nil {\n\t\tcmd.Stdin = os.Stdin\n\t}\n\tcmd.Stdout = options.Stdout\n\tif cmd.Stdout == nil {\n\t\tcmd.Stdout = os.Stdout\n\t}\n\tcmd.Stderr = options.Stderr\n\tif cmd.Stderr == nil {\n\t\tcmd.Stderr = os.Stderr\n\t}\n\tcmd.Env = util.MergeEnv(os.Environ(), []string{fmt.Sprintf(\"LOGLEVEL=%d\", logrus.GetLevel())})\n\tpreader, pwriter, err := os.Pipe()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"creating configuration pipe: %w\", err)\n\t}\n\tconfwg.Add(1)\n\tgo func() {\n\t\t_, conferr = io.Copy(pwriter, bytes.NewReader(config))\n\t\tif conferr != nil {\n\t\t\tconferr = fmt.Errorf(\"while copying configuration down pipe to child process: %w\", conferr)\n\t\t}\n\t\tconfwg.Done()\n\t}()\n\n\t// create network configuration pipes\n\tvar containerCreateR, containerCreateW fileCloser\n\tvar containerStartR, containerStartW fileCloser\n\tif configureNetwork {\n\t\tcontainerCreateR.file, containerCreateW.file, err = os.Pipe()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"creating container create pipe: %w\", err)\n\t\t}\n\t\tdefer containerCreateR.Close()\n\t\tdefer containerCreateW.Close()\n\n\t\tcontainerStartR.file, containerStartW.file, err = os.Pipe()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"creating container start pipe: %w\", err)\n\t\t}\n\t\tdefer containerStartR.Close()\n\t\tdefer containerStartW.Close()\n\t\tcmd.ExtraFiles = []*os.File{containerCreateW.file, containerStartR.file}\n\t}\n\n\tcmd.ExtraFiles = append([]*os.File{preader}, cmd.ExtraFiles...)\n\tdefer preader.Close()\n\tdefer pwriter.Close()\n\tif err := cmd.Start(); err != nil {\n\t\treturn fmt.Errorf(\"while starting runtime: %w\", err)\n\t}\n\n\tinterrupted := make(chan os.Signal, 100)\n\tgo func() {\n\t\tfor receivedSignal := range interrupted {\n\t\t\tif err := cmd.Process.Signal(receivedSignal); err != nil {\n\t\t\t\tlogrus.Infof(\"%v while attempting to forward %v to child process\", err, receivedSignal)\n\t\t\t}\n\t\t}\n\t}()\n\tsignal.Notify(interrupted, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM)\n\n\tif configureNetwork {\n\t\t// we already passed the fd to the child, now close the writer so we do not hang if the child closes it\n\t\tcontainerCreateW.Close()\n\t\tif err := waitForSync(containerCreateR.file); err != nil {\n\t\t\t// we do not want to return here since we want to capture the exit code from the child via cmd.Wait()\n\t\t\t// close the pipes here so that the child will not hang forever\n\t\t\tcontainerCreateR.Close()\n\t\t\tcontainerStartW.Close()\n\t\t\tlogrus.Errorf(\"did not get container create message from subprocess: %v\", err)\n\t\t} else {\n\t\t\tpidFile := filepath.Join(bundlePath, \"pid\")\n\t\t\tpidValue, err := os.ReadFile(pidFile)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tpid, err := strconv.Atoi(strings.TrimSpace(string(pidValue)))\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"parsing pid %s as a number: %w\", string(pidValue), err)\n\t\t\t}\n\n\t\t\tteardown, netResult, err := b.runConfigureNetwork(pid, isolation, options, networkString, containerName, []string{spec.Hostname, buildContainerName})\n\t\t\tif teardown != nil {\n\t\t\t\tdefer teardown()\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"setup network: %w\", err)\n\t\t\t}\n\n\t\t\t// only add hosts if we manage the hosts file\n\t\t\tif hostsFile != \"\" {\n\t\t\t\terr = b.addHostsEntries(hostsFile, rootPath, netResult.entries, netResult.excludeIPs, netResult.preferredHostContainersInternalIP)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif resolvFile != \"\" {\n\t\t\t\terr = b.addResolvConfEntries(resolvFile, netResult.dnsServers, spec, netResult.keepHostResolvers, netResult.ipv6)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogrus.Debug(\"network namespace successfully setup, send start message to child\")\n\t\t\t_, err = containerStartW.file.Write([]byte{1})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif err := cmd.Wait(); err != nil {\n\t\treturn fmt.Errorf(\"while running runtime: %w\", err)\n\t}\n\tconfwg.Wait()\n\tsignal.Stop(interrupted)\n\tclose(interrupted)\n\tif err == nil {\n\t\treturn conferr\n\t}\n\tif conferr != nil {\n\t\tlogrus.Debugf(\"%v\", conferr)\n\t}\n\treturn err\n}\n\ntype runUsingRuntimeSubprocOptions struct {\n\tOptions          RunOptions\n\tSpec             *specs.Spec\n\tRootPath         string\n\tBundlePath       string\n\tConfigureNetwork bool\n\tMoreCreateArgs   []string\n\tContainerName    string\n\tIsolation        define.Isolation\n}\n\nfunc init() {\n\treexec.Register(runUsingRuntimeCommand, runUsingRuntimeMain)\n}\n\n// If this succeeds, the caller must call cleanupMounts().\nfunc (b *Builder) setupMounts(mountPoint string, spec *specs.Spec, bundlePath string, optionMounts []specs.Mount, bindFiles map[string]string, builtinVolumes []string, compatBuiltinVolumes types.OptionalBool, volumeMounts []string, runFileMounts []string, runMountInfo runMountInfo) (*runMountArtifacts, error) {\n\t// Start building a new list of mounts.\n\tvar mounts []specs.Mount\n\thaveMount := func(destination string) bool {\n\t\tfor _, mount := range mounts {\n\t\t\tif mount.Destination == destination {\n\t\t\t\t// Already have something to mount there.\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tspecMounts, err := setupSpecialMountSpecChanges(spec, b.CommonBuildOpts.ShmSize)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Get the list of files we need to bind into the container.\n\tbindFileMounts := runSetupBoundFiles(bundlePath, bindFiles)\n\n\t// After this point we need to know the per-container persistent storage directory.\n\tcdir, err := b.store.ContainerDirectory(b.ContainerID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"determining work directory for container %q: %w\", b.ContainerID, err)\n\t}\n\n\t// Figure out which UID and GID to tell the subscriptions package to use\n\t// for files that it creates.\n\trootUID, rootGID, err := util.GetHostRootIDs(spec)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Get host UID and GID of the container process.\n\tuidMap := []specs.LinuxIDMapping{}\n\tgidMap := []specs.LinuxIDMapping{}\n\tif spec.Linux != nil {\n\t\tuidMap = spec.Linux.UIDMappings\n\t\tgidMap = spec.Linux.GIDMappings\n\t}\n\tprocessUID, processGID, err := util.GetHostIDs(uidMap, gidMap, spec.Process.User.UID, spec.Process.User.GID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Get the list of subscriptions mounts.\n\tsubscriptionMounts := subscriptions.MountsWithUIDGID(b.MountLabel, cdir, b.DefaultMountsFilePath, mountPoint, int(rootUID), int(rootGID), unshare.IsRootless(), false)\n\n\tidMaps := IDMaps{\n\t\tuidmap:     uidMap,\n\t\tgidmap:     gidMap,\n\t\trootUID:    int(rootUID),\n\t\trootGID:    int(rootGID),\n\t\tprocessUID: int(processUID),\n\t\tprocessGID: int(processGID),\n\t}\n\t// Get the list of mounts that are just for this Run() call.\n\trunMounts, mountArtifacts, err := b.runSetupRunMounts(mountPoint, runFileMounts, runMountInfo, idMaps)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsucceeded := false\n\tdefer func() {\n\t\tif !succeeded {\n\t\t\tvolumes.UnlockLockArray(mountArtifacts.TargetLocks)\n\t\t}\n\t}()\n\t// Add temporary copies of the contents of volume locations at the\n\t// volume locations, unless we already have something there.\n\tbuiltins, err := runSetupBuiltinVolumes(b.MountLabel, mountPoint, cdir, builtinVolumes, compatBuiltinVolumes, int(rootUID), int(rootGID))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Get the list of explicitly-specified volume mounts.\n\tmountLabel := \"\"\n\tif spec.Linux != nil {\n\t\tmountLabel = spec.Linux.MountLabel\n\t}\n\tvolumes, err := b.runSetupVolumeMounts(mountLabel, volumeMounts, optionMounts, idMaps)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// prepare list of mount destinations which can be cleaned up safely.\n\t// we can clean bindFiles, subscriptionMounts and specMounts\n\t// everything other than these might have users content\n\tmountArtifacts.RunMountTargets = append(append(append(mountArtifacts.RunMountTargets, cleanableDestinationListFromMounts(bindFileMounts)...), cleanableDestinationListFromMounts(subscriptionMounts)...), cleanableDestinationListFromMounts(specMounts)...)\n\n\tallMounts := util.SortMounts(append(append(append(append(append(volumes, builtins...), runMounts...), subscriptionMounts...), bindFileMounts...), specMounts...))\n\t// Add them all, in the preferred order, except where they conflict with something that was previously added.\n\tfor _, mount := range allMounts {\n\t\tif haveMount(mount.Destination) {\n\t\t\t// Already mounting something there, no need to bother with this one.\n\t\t\tcontinue\n\t\t}\n\t\t// Add the mount.\n\t\tmounts = append(mounts, mount)\n\t}\n\n\t// Set the list in the spec.\n\tspec.Mounts = mounts\n\tsucceeded = true\n\treturn mountArtifacts, nil\n}\n\nfunc runSetupBuiltinVolumes(mountLabel, mountPoint, containerDir string, builtinVolumes []string, compatBuiltinVolumes types.OptionalBool, rootUID, rootGID int) ([]specs.Mount, error) {\n\tvar mounts []specs.Mount\n\thostOwner := idtools.IDPair{UID: rootUID, GID: rootGID}\n\t// Add temporary copies of the contents of volume locations at the\n\t// volume locations, unless we already have something there.\n\tfor _, volume := range builtinVolumes {\n\t\t// Make sure the volume exists in the rootfs.\n\t\tcreateDirPerms := os.FileMode(0o755)\n\t\terr := copier.Mkdir(mountPoint, filepath.Join(mountPoint, volume), copier.MkdirOptions{\n\t\t\tChownNew: &hostOwner,\n\t\t\tChmodNew: &createDirPerms,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"ensuring volume path %q: %w\", filepath.Join(mountPoint, volume), err)\n\t\t}\n\t\t// If we're not being asked to bind mount anonymous volumes\n\t\t// onto the volume paths, we're done here.\n\t\tif compatBuiltinVolumes != types.OptionalBoolTrue {\n\t\t\tcontinue\n\t\t}\n\t\t// If we need to, create the directory that we'll use to hold\n\t\t// the volume contents.  If we do need to create it, then we'll\n\t\t// need to populate it, too, so make a note of that.\n\t\tvolumePath := filepath.Join(containerDir, \"buildah-volumes\", digest.Canonical.FromString(volume).Hex())\n\t\tinitializeVolume := false\n\t\tif err := fileutils.Exists(volumePath); err != nil {\n\t\t\tif !errors.Is(err, fs.ErrNotExist) {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tlogrus.Debugf(\"setting up built-in volume path at %q for %q\", volumePath, volume)\n\t\t\tif err = os.MkdirAll(volumePath, 0o755); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif err = relabel(volumePath, mountLabel, false); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tinitializeVolume = true\n\t\t}\n\t\t// Read the attributes of the volume's location in the rootfs.\n\t\tsrcPath, err := copier.Eval(mountPoint, filepath.Join(mountPoint, volume), copier.EvalOptions{})\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"evaluating path %q: %w\", srcPath, err)\n\t\t}\n\t\tstat, err := os.Stat(srcPath)\n\t\tif err != nil && !errors.Is(err, os.ErrNotExist) {\n\t\t\treturn nil, err\n\t\t}\n\t\t// If we need to populate the mounted volume's contents with\n\t\t// content from the rootfs, set it up now.\n\t\tif initializeVolume {\n\t\t\tif err = os.Chmod(volumePath, stat.Mode().Perm()); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif err = os.Chown(volumePath, int(stat.Sys().(*syscall.Stat_t).Uid), int(stat.Sys().(*syscall.Stat_t).Gid)); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tlogrus.Debugf(\"populating directory %q for volume %q using contents of %q\", volumePath, volume, srcPath)\n\t\t\tif err = extractWithTar(mountPoint, srcPath, volumePath); err != nil && !errors.Is(err, os.ErrNotExist) {\n\t\t\t\treturn nil, fmt.Errorf(\"populating directory %q for volume %q using contents of %q: %w\", volumePath, volume, srcPath, err)\n\t\t\t}\n\t\t}\n\t\t// Add the bind mount.\n\t\tmounts = append(mounts, specs.Mount{\n\t\t\tSource:      volumePath,\n\t\t\tDestination: volume,\n\t\t\tType:        define.TypeBind,\n\t\t\tOptions:     define.BindOptions,\n\t\t})\n\t}\n\treturn mounts, nil\n}\n\n// Destinations which can be cleaned up after every RUN\nfunc cleanableDestinationListFromMounts(mounts []specs.Mount) []string {\n\tmountDest := []string{}\n\tfor _, mount := range mounts {\n\t\t// Add all destination to mountArtifacts so that they can be cleaned up later\n\t\tif mount.Destination != \"\" {\n\t\t\tcleanPath := true\n\t\t\tfor _, prefix := range nonCleanablePrefixes {\n\t\t\t\tif strings.HasPrefix(mount.Destination, prefix) {\n\t\t\t\t\tcleanPath = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif cleanPath {\n\t\t\t\tmountDest = append(mountDest, mount.Destination)\n\t\t\t}\n\t\t}\n\t}\n\treturn mountDest\n}\n\nfunc checkIfMountDestinationPreExists(root string, dest string) (bool, error) {\n\tstatResults, err := copier.Stat(root, \"\", copier.StatOptions{}, []string{dest})\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif len(statResults) > 0 {\n\t\t// We created exact path for globbing so it will\n\t\t// return only one result.\n\t\tif statResults[0].Error != \"\" && len(statResults[0].Globbed) == 0 {\n\t\t\t// Path do not exist.\n\t\t\treturn false, nil\n\t\t}\n\t\t// Path exists.\n\t\treturn true, nil\n\t}\n\treturn false, nil\n}\n\n// runSetupRunMounts sets up mounts that exist only in this RUN, not in subsequent runs\n//\n// If this function succeeds, the caller must unlock runMountArtifacts.TargetLocks (when??)\nfunc (b *Builder) runSetupRunMounts(mountPoint string, mounts []string, sources runMountInfo, idMaps IDMaps) ([]specs.Mount, *runMountArtifacts, error) {\n\tmountTargets := make([]string, 0, 10)\n\ttmpFiles := make([]string, 0, len(mounts))\n\tmountImages := make([]string, 0, 10)\n\tfinalMounts := make([]specs.Mount, 0, len(mounts))\n\tagents := make([]*sshagent.AgentServer, 0, len(mounts))\n\tsshCount := 0\n\tdefaultSSHSock := \"\"\n\ttargetLocks := []*lockfile.LockFile{}\n\tsucceeded := false\n\tdefer func() {\n\t\tif !succeeded {\n\t\t\tvolumes.UnlockLockArray(targetLocks)\n\t\t}\n\t}()\n\tfor _, mount := range mounts {\n\t\tvar mountSpec *specs.Mount\n\t\tvar err error\n\t\tvar envFile, image string\n\t\tvar agent *sshagent.AgentServer\n\t\tvar tl *lockfile.LockFile\n\t\ttokens := strings.Split(mount, \",\")\n\n\t\t// If `type` is not set default to TypeBind\n\t\tmountType := define.TypeBind\n\n\t\tfor _, field := range tokens {\n\t\t\tif strings.HasPrefix(field, \"type=\") {\n\t\t\t\tkv := strings.Split(field, \"=\")\n\t\t\t\tif len(kv) != 2 {\n\t\t\t\t\treturn nil, nil, errors.New(\"invalid mount type\")\n\t\t\t\t}\n\t\t\t\tmountType = kv[1]\n\t\t\t}\n\t\t}\n\t\tswitch mountType {\n\t\tcase \"secret\":\n\t\t\tmountSpec, envFile, err = b.getSecretMount(tokens, sources.Secrets, idMaps, sources.WorkDir)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tif mountSpec != nil {\n\t\t\t\tfinalMounts = append(finalMounts, *mountSpec)\n\t\t\t\tif envFile != \"\" {\n\t\t\t\t\ttmpFiles = append(tmpFiles, envFile)\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"ssh\":\n\t\t\tmountSpec, agent, err = b.getSSHMount(tokens, sshCount, sources.SSHSources, idMaps)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tif mountSpec != nil {\n\t\t\t\tfinalMounts = append(finalMounts, *mountSpec)\n\t\t\t\tagents = append(agents, agent)\n\t\t\t\tif sshCount == 0 {\n\t\t\t\t\tdefaultSSHSock = mountSpec.Destination\n\t\t\t\t}\n\t\t\t\t// Count is needed as the default destination of the ssh sock inside the container is  /run/buildkit/ssh_agent.{i}\n\t\t\t\tsshCount++\n\t\t\t}\n\t\tcase define.TypeBind:\n\t\t\tmountSpec, image, err = b.getBindMount(tokens, sources.SystemContext, sources.ContextDir, sources.StageMountPoints, idMaps, sources.WorkDir)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tfinalMounts = append(finalMounts, *mountSpec)\n\t\t\t// only perform cleanup if image was mounted ignore everything else\n\t\t\tif image != \"\" {\n\t\t\t\tmountImages = append(mountImages, image)\n\t\t\t}\n\t\tcase \"tmpfs\":\n\t\t\tmountSpec, err = b.getTmpfsMount(tokens, idMaps, sources.WorkDir)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tfinalMounts = append(finalMounts, *mountSpec)\n\t\tcase \"cache\":\n\t\t\tmountSpec, tl, err = b.getCacheMount(tokens, sources.StageMountPoints, idMaps, sources.WorkDir)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tfinalMounts = append(finalMounts, *mountSpec)\n\t\t\tif tl != nil {\n\t\t\t\ttargetLocks = append(targetLocks, tl)\n\t\t\t}\n\t\tdefault:\n\t\t\treturn nil, nil, fmt.Errorf(\"invalid mount type %q\", mountType)\n\t\t}\n\n\t\tif mountSpec != nil {\n\t\t\tpathPreExists, err := checkIfMountDestinationPreExists(mountPoint, mountSpec.Destination)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t\tif !pathPreExists {\n\t\t\t\t// In such case it means that the path did not exists before\n\t\t\t\t// creating any new mounts therefore we must clean the newly\n\t\t\t\t// created directory after this step.\n\t\t\t\tmountTargets = append(mountTargets, mountSpec.Destination)\n\t\t\t}\n\t\t}\n\t}\n\tsucceeded = true\n\tartifacts := &runMountArtifacts{\n\t\tRunMountTargets: mountTargets,\n\t\tTmpFiles:        tmpFiles,\n\t\tAgents:          agents,\n\t\tMountedImages:   mountImages,\n\t\tSSHAuthSock:     defaultSSHSock,\n\t\tTargetLocks:     targetLocks,\n\t}\n\treturn finalMounts, artifacts, nil\n}\n\nfunc (b *Builder) getBindMount(tokens []string, context *imageTypes.SystemContext, contextDir string, stageMountPoints map[string]internal.StageMountDetails, idMaps IDMaps, workDir string) (*specs.Mount, string, error) {\n\tif contextDir == \"\" {\n\t\treturn nil, \"\", errors.New(\"Context Directory for current run invocation is not configured\")\n\t}\n\tvar optionMounts []specs.Mount\n\tmount, image, err := volumes.GetBindMount(context, tokens, contextDir, b.store, b.MountLabel, stageMountPoints, workDir)\n\tif err != nil {\n\t\treturn nil, image, err\n\t}\n\toptionMounts = append(optionMounts, mount)\n\tvolumes, err := b.runSetupVolumeMounts(b.MountLabel, nil, optionMounts, idMaps)\n\tif err != nil {\n\t\treturn nil, image, err\n\t}\n\treturn &volumes[0], image, nil\n}\n\nfunc (b *Builder) getTmpfsMount(tokens []string, idMaps IDMaps, workDir string) (*specs.Mount, error) {\n\tvar optionMounts []specs.Mount\n\tmount, err := volumes.GetTmpfsMount(tokens, workDir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\toptionMounts = append(optionMounts, mount)\n\tvolumes, err := b.runSetupVolumeMounts(b.MountLabel, nil, optionMounts, idMaps)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &volumes[0], nil\n}\n\nfunc (b *Builder) getSecretMount(tokens []string, secrets map[string]define.Secret, idMaps IDMaps, workdir string) (_ *specs.Mount, _ string, retErr error) {\n\terrInvalidSyntax := errors.New(\"secret should have syntax id=id[,target=path,required=bool,mode=uint,uid=uint,gid=uint\")\n\tif len(tokens) == 0 {\n\t\treturn nil, \"\", errInvalidSyntax\n\t}\n\tvar err error\n\tvar id, target string\n\tvar required bool\n\tvar uid, gid uint32\n\tvar mode uint32 = 0o400\n\tfor _, val := range tokens {\n\t\tkv := strings.SplitN(val, \"=\", 2)\n\t\tswitch kv[0] {\n\t\tcase \"type\":\n\t\t\t// This is already processed\n\t\t\tcontinue\n\t\tcase \"id\":\n\t\t\tid = kv[1]\n\t\tcase \"target\", \"dst\", \"destination\":\n\t\t\ttarget = kv[1]\n\t\t\tif !filepath.IsAbs(target) {\n\t\t\t\ttarget = filepath.Join(workdir, target)\n\t\t\t}\n\t\tcase \"required\":\n\t\t\trequired = true\n\t\t\tif len(kv) > 1 {\n\t\t\t\trequired, err = strconv.ParseBool(kv[1])\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, \"\", errInvalidSyntax\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"mode\":\n\t\t\tmode64, err := strconv.ParseUint(kv[1], 8, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, \"\", errInvalidSyntax\n\t\t\t}\n\t\t\tmode = uint32(mode64)\n\t\tcase \"uid\":\n\t\t\tuid64, err := strconv.ParseUint(kv[1], 10, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, \"\", errInvalidSyntax\n\t\t\t}\n\t\t\tuid = uint32(uid64)\n\t\tcase \"gid\":\n\t\t\tgid64, err := strconv.ParseUint(kv[1], 10, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, \"\", errInvalidSyntax\n\t\t\t}\n\t\t\tgid = uint32(gid64)\n\t\tdefault:\n\t\t\treturn nil, \"\", errInvalidSyntax\n\t\t}\n\t}\n\n\tif id == \"\" {\n\t\treturn nil, \"\", errInvalidSyntax\n\t}\n\t// Default location for secrets is /run/secrets/id\n\tif target == \"\" {\n\t\ttarget = \"/run/secrets/\" + id\n\t}\n\n\tsecr, ok := secrets[id]\n\tif !ok {\n\t\tif required {\n\t\t\treturn nil, \"\", fmt.Errorf(\"secret required but no secret with id %q found\", id)\n\t\t}\n\t\treturn nil, \"\", nil\n\t}\n\tvar data []byte\n\tvar envFile string\n\tvar ctrFileOnHost string\n\n\tswitch secr.SourceType {\n\tcase \"env\":\n\t\tdata = []byte(os.Getenv(secr.Source))\n\t\ttmpFile, err := os.CreateTemp(tmpdir.GetTempDir(), \"buildah*\")\n\t\tif err != nil {\n\t\t\treturn nil, \"\", err\n\t\t}\n\t\tdefer func() {\n\t\t\tif retErr != nil {\n\t\t\t\tos.Remove(tmpFile.Name())\n\t\t\t}\n\t\t}()\n\t\tenvFile = tmpFile.Name()\n\t\tctrFileOnHost = tmpFile.Name()\n\tcase \"file\":\n\t\tcontainerWorkingDir, err := b.store.ContainerDirectory(b.ContainerID)\n\t\tif err != nil {\n\t\t\treturn nil, \"\", err\n\t\t}\n\t\tdata, err = os.ReadFile(secr.Source)\n\t\tif err != nil {\n\t\t\treturn nil, \"\", err\n\t\t}\n\t\tctrFileOnHost = filepath.Join(containerWorkingDir, \"secrets\", digest.FromString(id).Encoded()[:16])\n\tdefault:\n\t\treturn nil, \"\", errors.New(\"invalid source secret type\")\n\t}\n\n\t// Copy secrets to container working dir (or tmp dir if it's an env), since we need to chmod,\n\t// chown and relabel it for the container user and we don't want to mess with the original file\n\tif err := os.MkdirAll(filepath.Dir(ctrFileOnHost), 0o755); err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tif err := os.WriteFile(ctrFileOnHost, data, 0o644); err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\tif err := relabel(ctrFileOnHost, b.MountLabel, false); err != nil {\n\t\treturn nil, \"\", err\n\t}\n\thostUID, hostGID, err := util.GetHostIDs(idMaps.uidmap, idMaps.gidmap, uid, gid)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tif err := os.Lchown(ctrFileOnHost, int(hostUID), int(hostGID)); err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tif err := os.Chmod(ctrFileOnHost, os.FileMode(mode)); err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tnewMount := specs.Mount{\n\t\tDestination: target,\n\t\tType:        define.TypeBind,\n\t\tSource:      ctrFileOnHost,\n\t\tOptions:     append(define.BindOptions, \"rprivate\", \"ro\"),\n\t}\n\treturn &newMount, envFile, nil\n}\n\n// getSSHMount parses the --mount type=ssh flag in the Containerfile, checks if there's an ssh source provided, and creates and starts an ssh-agent to be forwarded into the container\nfunc (b *Builder) getSSHMount(tokens []string, count int, sshsources map[string]*sshagent.Source, idMaps IDMaps) (*specs.Mount, *sshagent.AgentServer, error) {\n\terrInvalidSyntax := errors.New(\"ssh should have syntax id=id[,target=path,required=bool,mode=uint,uid=uint,gid=uint\")\n\n\tvar err error\n\tvar id, target string\n\tvar required bool\n\tvar uid, gid uint32\n\tvar mode uint32 = 0o600\n\tfor _, val := range tokens {\n\t\tkv := strings.SplitN(val, \"=\", 2)\n\t\tif len(kv) < 2 {\n\t\t\treturn nil, nil, errInvalidSyntax\n\t\t}\n\t\tswitch kv[0] {\n\t\tcase \"type\":\n\t\t\t// This is already processed\n\t\t\tcontinue\n\t\tcase \"id\":\n\t\t\tid = kv[1]\n\t\tcase \"target\", \"dst\", \"destination\":\n\t\t\ttarget = kv[1]\n\t\tcase \"required\":\n\t\t\trequired, err = strconv.ParseBool(kv[1])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, errInvalidSyntax\n\t\t\t}\n\t\tcase \"mode\":\n\t\t\tmode64, err := strconv.ParseUint(kv[1], 8, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, errInvalidSyntax\n\t\t\t}\n\t\t\tmode = uint32(mode64)\n\t\tcase \"uid\":\n\t\t\tuid64, err := strconv.ParseUint(kv[1], 10, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, errInvalidSyntax\n\t\t\t}\n\t\t\tuid = uint32(uid64)\n\t\tcase \"gid\":\n\t\t\tgid64, err := strconv.ParseUint(kv[1], 10, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, errInvalidSyntax\n\t\t\t}\n\t\t\tgid = uint32(gid64)\n\t\tdefault:\n\t\t\treturn nil, nil, errInvalidSyntax\n\t\t}\n\t}\n\n\tif id == \"\" {\n\t\tid = \"default\"\n\t}\n\t// Default location for secrets is /run/buildkit/ssh_agent.{i}\n\tif target == \"\" {\n\t\ttarget = fmt.Sprintf(\"/run/buildkit/ssh_agent.%d\", count)\n\t}\n\n\tsshsource, ok := sshsources[id]\n\tif !ok {\n\t\tif required {\n\t\t\treturn nil, nil, fmt.Errorf(\"ssh required but no ssh with id %s found\", id)\n\t\t}\n\t\treturn nil, nil, nil\n\t}\n\t// Create new agent from keys or socket\n\tfwdAgent, err := sshagent.NewAgentServer(sshsource)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\t// Start ssh server, and get the host sock we're mounting in the container\n\thostSock, err := fwdAgent.Serve(b.ProcessLabel)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tif err := relabel(filepath.Dir(hostSock), b.MountLabel, false); err != nil {\n\t\tif shutdownErr := fwdAgent.Shutdown(); shutdownErr != nil {\n\t\t\tb.Logger.Errorf(\"error shutting down agent: %v\", shutdownErr)\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\tif err := relabel(hostSock, b.MountLabel, false); err != nil {\n\t\tif shutdownErr := fwdAgent.Shutdown(); shutdownErr != nil {\n\t\t\tb.Logger.Errorf(\"error shutting down agent: %v\", shutdownErr)\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\thostUID, hostGID, err := util.GetHostIDs(idMaps.uidmap, idMaps.gidmap, uid, gid)\n\tif err != nil {\n\t\tif shutdownErr := fwdAgent.Shutdown(); shutdownErr != nil {\n\t\t\tb.Logger.Errorf(\"error shutting down agent: %v\", shutdownErr)\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\tif err := os.Lchown(hostSock, int(hostUID), int(hostGID)); err != nil {\n\t\tif shutdownErr := fwdAgent.Shutdown(); shutdownErr != nil {\n\t\t\tb.Logger.Errorf(\"error shutting down agent: %v\", shutdownErr)\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\tif err := os.Chmod(hostSock, os.FileMode(mode)); err != nil {\n\t\tif shutdownErr := fwdAgent.Shutdown(); shutdownErr != nil {\n\t\t\tb.Logger.Errorf(\"error shutting down agent: %v\", shutdownErr)\n\t\t}\n\t\treturn nil, nil, err\n\t}\n\tnewMount := specs.Mount{\n\t\tDestination: target,\n\t\tType:        define.TypeBind,\n\t\tSource:      hostSock,\n\t\tOptions:     append(define.BindOptions, \"rprivate\", \"ro\"),\n\t}\n\treturn &newMount, fwdAgent, nil\n}\n\nfunc (b *Builder) cleanupTempVolumes() {\n\tfor tempVolume, val := range b.TempVolumes {\n\t\tif val {\n\t\t\tif err := overlay.RemoveTemp(tempVolume); err != nil {\n\t\t\t\tb.Logger.Error(err.Error())\n\t\t\t}\n\t\t\tb.TempVolumes[tempVolume] = false\n\t\t}\n\t}\n}\n\n// cleanupRunMounts cleans up run mounts so they only appear in this run.\nfunc (b *Builder) cleanupRunMounts(context *imageTypes.SystemContext, mountpoint string, artifacts *runMountArtifacts) error {\n\tfor _, agent := range artifacts.Agents {\n\t\terr := agent.Shutdown()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// cleanup any mounted images for this run\n\tfor _, image := range artifacts.MountedImages {\n\t\tif image != \"\" {\n\t\t\t// if flow hits here some image was mounted for this run\n\t\t\ti, err := internalUtil.LookupImage(context, b.store, image)\n\t\t\tif err == nil {\n\t\t\t\t// silently try to unmount and do nothing\n\t\t\t\t// if image is being used by something else\n\t\t\t\t_ = i.Unmount(false)\n\t\t\t}\n\t\t\tif errors.Is(err, storageTypes.ErrImageUnknown) {\n\t\t\t\t// Ignore only if ErrImageUnknown\n\t\t\t\t// Reason: Image is already unmounted do nothing\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\topts := copier.RemoveOptions{\n\t\tAll: true,\n\t}\n\tfor _, path := range artifacts.RunMountTargets {\n\t\terr := copier.Remove(mountpoint, path, opts)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tvar prevErr error\n\tfor _, path := range artifacts.TmpFiles {\n\t\terr := os.Remove(path)\n\t\tif !errors.Is(err, os.ErrNotExist) {\n\t\t\tif prevErr != nil {\n\t\t\t\tlogrus.Error(prevErr)\n\t\t\t}\n\t\t\tprevErr = err\n\t\t}\n\t}\n\t// unlock if any locked files from this RUN statement\n\tvolumes.UnlockLockArray(artifacts.TargetLocks)\n\treturn prevErr\n}\n\n// setPdeathsig sets a parent-death signal for the process\n// the goroutine that starts the child process should lock itself to\n// a native thread using runtime.LockOSThread() until the child exits\nfunc setPdeathsig(cmd *exec.Cmd) {\n\tif cmd.SysProcAttr == nil {\n\t\tcmd.SysProcAttr = &syscall.SysProcAttr{}\n\t}\n\tcmd.SysProcAttr.Pdeathsig = syscall.SIGKILL\n}\n\nfunc relabel(path, mountLabel string, recurse bool) error {\n\tif err := label.Relabel(path, mountLabel, recurse); err != nil {\n\t\tif !errors.Is(err, syscall.ENOTSUP) {\n\t\t\treturn err\n\t\t}\n\t\tlogrus.Debugf(\"Labeling not supported on %q\", path)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "run_freebsd.go",
          "type": "blob",
          "size": 19.1083984375,
          "content": "//go:build freebsd\n\npackage buildah\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"unsafe\"\n\n\t\"github.com/containers/buildah/bind\"\n\t\"github.com/containers/buildah/chroot\"\n\t\"github.com/containers/buildah/copier\"\n\t\"github.com/containers/buildah/define\"\n\t\"github.com/containers/buildah/internal\"\n\t\"github.com/containers/buildah/internal/tmpdir\"\n\t\"github.com/containers/buildah/pkg/jail\"\n\t\"github.com/containers/buildah/pkg/overlay\"\n\t\"github.com/containers/buildah/pkg/parse\"\n\tbutil \"github.com/containers/buildah/pkg/util\"\n\t\"github.com/containers/buildah/util\"\n\t\"github.com/containers/common/libnetwork/etchosts\"\n\t\"github.com/containers/common/libnetwork/resolvconf\"\n\tnettypes \"github.com/containers/common/libnetwork/types\"\n\tnetUtil \"github.com/containers/common/libnetwork/util\"\n\t\"github.com/containers/common/pkg/config\"\n\t\"github.com/containers/storage/pkg/idtools\"\n\t\"github.com/containers/storage/pkg/lockfile\"\n\t\"github.com/containers/storage/pkg/stringid\"\n\t\"github.com/docker/go-units\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\tspec \"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/runtime-tools/generate\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/exp/slices\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst (\n\tP_PID             = 0\n\tP_PGID            = 2\n\tPROC_REAP_ACQUIRE = 2\n\tPROC_REAP_RELEASE = 3\n)\n\n// We dont want to remove destinations with /etc, /dev as\n// rootfs already contains these files and unionfs will create\n// a `whiteout` i.e `.wh` files on removal of overlapping\n// files from these directories.  everything other than these\n// will be cleaned up\nvar nonCleanablePrefixes = []string{\n\t\"/etc\", \"/dev\",\n}\n\nfunc procctl(idtype int, id int, cmd int, arg *byte) error {\n\t_, _, e1 := unix.Syscall6(\n\t\tunix.SYS_PROCCTL, uintptr(idtype), uintptr(id),\n\t\tuintptr(cmd), uintptr(unsafe.Pointer(arg)), 0, 0)\n\tif e1 != 0 {\n\t\treturn unix.Errno(e1)\n\t}\n\treturn nil\n}\n\nfunc setChildProcess() error {\n\tif err := procctl(P_PID, unix.Getpid(), PROC_REAP_ACQUIRE, nil); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"procctl(PROC_REAP_ACQUIRE): %v\\n\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (b *Builder) Run(command []string, options RunOptions) error {\n\tp, err := os.MkdirTemp(tmpdir.GetTempDir(), define.Package)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// On some hosts like AH, /tmp is a symlink and we need an\n\t// absolute path.\n\tpath, err := filepath.EvalSymlinks(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogrus.Debugf(\"using %q to hold bundle data\", path)\n\tdefer func() {\n\t\tif err2 := os.RemoveAll(path); err2 != nil {\n\t\t\tlogrus.Errorf(\"error removing %q: %v\", path, err2)\n\t\t}\n\t}()\n\n\tgp, err := generate.New(\"freebsd\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"generating new 'freebsd' runtime spec: %w\", err)\n\t}\n\tg := &gp\n\n\tisolation := options.Isolation\n\tif isolation == IsolationDefault {\n\t\tisolation = b.Isolation\n\t\tif isolation == IsolationDefault {\n\t\t\tisolation, err = parse.IsolationOption(\"\")\n\t\t\tif err != nil {\n\t\t\t\tlogrus.Debugf(\"got %v while trying to determine default isolation, guessing OCI\", err)\n\t\t\t\tisolation = IsolationOCI\n\t\t\t} else if isolation == IsolationDefault {\n\t\t\t\tisolation = IsolationOCI\n\t\t\t}\n\t\t}\n\t}\n\tif err := checkAndOverrideIsolationOptions(isolation, &options); err != nil {\n\t\treturn err\n\t}\n\n\t// hardwire the environment to match docker build to avoid subtle and hard-to-debug differences due to containers.conf\n\tb.configureEnvironment(g, options, []string{\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\"})\n\n\tif b.CommonBuildOpts == nil {\n\t\treturn fmt.Errorf(\"invalid format on container you must recreate the container\")\n\t}\n\n\tif err := addCommonOptsToSpec(b.CommonBuildOpts, g); err != nil {\n\t\treturn err\n\t}\n\n\tworkDir := b.WorkDir()\n\tif options.WorkingDir != \"\" {\n\t\tg.SetProcessCwd(options.WorkingDir)\n\t\tworkDir = options.WorkingDir\n\t} else if b.WorkDir() != \"\" {\n\t\tg.SetProcessCwd(b.WorkDir())\n\t\tworkDir = b.WorkDir()\n\t}\n\tif workDir == \"\" {\n\t\tworkDir = string(os.PathSeparator)\n\t}\n\tmountPoint, err := b.Mount(b.MountLabel)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"mounting container %q: %w\", b.ContainerID, err)\n\t}\n\tdefer func() {\n\t\tif err := b.Unmount(); err != nil {\n\t\t\tlogrus.Errorf(\"error unmounting container: %v\", err)\n\t\t}\n\t}()\n\tg.SetRootPath(mountPoint)\n\tif len(command) > 0 {\n\t\tcommand = runLookupPath(g, command)\n\t\tg.SetProcessArgs(command)\n\t} else {\n\t\tg.SetProcessArgs(nil)\n\t}\n\n\tsetupTerminal(g, options.Terminal, options.TerminalSize)\n\n\tconfigureNetwork, networkString, err := b.configureNamespaces(g, &options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcontainerName := Package + \"-\" + filepath.Base(path)\n\tif configureNetwork {\n\t\tif jail.NeedVnetJail() {\n\t\t\tg.AddAnnotation(\"org.freebsd.parentJail\", containerName+\"-vnet\")\n\t\t} else {\n\t\t\tg.AddAnnotation(\"org.freebsd.jail.vnet\", \"new\")\n\t\t}\n\t}\n\n\thomeDir, err := b.configureUIDGID(g, mountPoint, options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Now grab the spec from the generator.  Set the generator to nil so that future contributors\n\t// will quickly be able to tell that they're supposed to be modifying the spec directly from here.\n\tspec := g.Config\n\tg = nil\n\n\t// Set the seccomp configuration using the specified profile name.  Some syscalls are\n\t// allowed if certain capabilities are to be granted (example: CAP_SYS_CHROOT and chroot),\n\t// so we sorted out the capabilities lists first.\n\tif err = setupSeccomp(spec, b.CommonBuildOpts.SeccompProfilePath); err != nil {\n\t\treturn err\n\t}\n\n\tuid, gid := spec.Process.User.UID, spec.Process.User.GID\n\tidPair := &idtools.IDPair{UID: int(uid), GID: int(gid)}\n\n\tmode := os.FileMode(0o755)\n\tcoptions := copier.MkdirOptions{\n\t\tChownNew: idPair,\n\t\tChmodNew: &mode,\n\t}\n\tif err := copier.Mkdir(mountPoint, filepath.Join(mountPoint, spec.Process.Cwd), coptions); err != nil {\n\t\treturn err\n\t}\n\n\tbindFiles := make(map[string]string)\n\tvolumes := b.Volumes()\n\n\t// Figure out who owns files that will appear to be owned by UID/GID 0 in the container.\n\trootUID, rootGID, err := util.GetHostRootIDs(spec)\n\tif err != nil {\n\t\treturn err\n\t}\n\trootIDPair := &idtools.IDPair{UID: int(rootUID), GID: int(rootGID)}\n\n\thostsFile := \"\"\n\tif !options.NoHosts && !slices.Contains(volumes, config.DefaultHostsFile) && options.ConfigureNetwork != define.NetworkDisabled {\n\t\thostsFile, err = b.createHostsFile(path, rootIDPair)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbindFiles[config.DefaultHostsFile] = hostsFile\n\n\t\t// Only add entries here if we do not have to setup network,\n\t\t// if we do we have to do it much later after the network setup.\n\t\tif !configureNetwork {\n\t\t\tvar entries etchosts.HostEntries\n\t\t\t// add host entry for local ip when running in host network\n\t\t\tif spec.Hostname != \"\" {\n\t\t\t\tip := netUtil.GetLocalIP()\n\t\t\t\tif ip != \"\" {\n\t\t\t\t\tentries = append(entries, etchosts.HostEntry{\n\t\t\t\t\t\tNames: []string{spec.Hostname},\n\t\t\t\t\t\tIP:    ip,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = b.addHostsEntries(hostsFile, mountPoint, entries, nil, \"\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tresolvFile := \"\"\n\tif !slices.Contains(volumes, resolvconf.DefaultResolvConf) && options.ConfigureNetwork != define.NetworkDisabled && !(len(b.CommonBuildOpts.DNSServers) == 1 && strings.ToLower(b.CommonBuildOpts.DNSServers[0]) == \"none\") {\n\t\tresolvFile, err = b.createResolvConf(path, rootIDPair)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbindFiles[resolvconf.DefaultResolvConf] = resolvFile\n\n\t\t// Only add entries here if we do not have to do setup network,\n\t\t// if we do we have to do it much later after the network setup.\n\t\tif !configureNetwork {\n\t\t\terr = b.addResolvConfEntries(resolvFile, nil, spec, false, true)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\trunMountInfo := runMountInfo{\n\t\tWorkDir:          workDir,\n\t\tContextDir:       options.ContextDir,\n\t\tSecrets:          options.Secrets,\n\t\tSSHSources:       options.SSHSources,\n\t\tStageMountPoints: options.StageMountPoints,\n\t\tSystemContext:    options.SystemContext,\n\t}\n\n\trunArtifacts, err := b.setupMounts(mountPoint, spec, path, options.Mounts, bindFiles, volumes, options.CompatBuiltinVolumes, b.CommonBuildOpts.Volumes, options.RunMounts, runMountInfo)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"resolving mountpoints for container %q: %w\", b.ContainerID, err)\n\t}\n\tif runArtifacts.SSHAuthSock != \"\" {\n\t\tsshenv := \"SSH_AUTH_SOCK=\" + runArtifacts.SSHAuthSock\n\t\tspec.Process.Env = append(spec.Process.Env, sshenv)\n\t}\n\n\t// following run was called from `buildah run`\n\t// and some images were mounted for this run\n\t// add them to cleanup artifacts\n\tif len(options.ExternalImageMounts) > 0 {\n\t\trunArtifacts.MountedImages = append(runArtifacts.MountedImages, options.ExternalImageMounts...)\n\t}\n\n\tdefer func() {\n\t\tif err := b.cleanupRunMounts(options.SystemContext, mountPoint, runArtifacts); err != nil {\n\t\t\toptions.Logger.Errorf(\"unable to cleanup run mounts %v\", err)\n\t\t}\n\t}()\n\n\tdefer b.cleanupTempVolumes()\n\n\t// If we are creating a network, make the vnet here so that we can\n\t// execute the OCI runtime inside it. For FreeBSD-13.3 and later, we can\n\t// configure the container network settings from outside the jail, which\n\t// removes the need for a separate jail to manage the vnet.\n\tif configureNetwork && jail.NeedVnetJail() {\n\t\tmynetns := containerName + \"-vnet\"\n\n\t\tjconf := jail.NewConfig()\n\t\tjconf.Set(\"name\", mynetns)\n\t\tjconf.Set(\"vnet\", jail.NEW)\n\t\tjconf.Set(\"children.max\", 1)\n\t\tjconf.Set(\"persist\", true)\n\t\tjconf.Set(\"enforce_statfs\", 0)\n\t\tjconf.Set(\"devfs_ruleset\", 4)\n\t\tjconf.Set(\"allow.raw_sockets\", true)\n\t\tjconf.Set(\"allow.chflags\", true)\n\t\tjconf.Set(\"securelevel\", -1)\n\t\tnetjail, err := jail.Create(jconf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer func() {\n\t\t\tjconf := jail.NewConfig()\n\t\t\tjconf.Set(\"persist\", false)\n\t\t\terr2 := netjail.Set(jconf)\n\t\t\tif err2 != nil {\n\t\t\t\tlogrus.Errorf(\"error releasing vnet jail %q: %v\", mynetns, err2)\n\t\t\t}\n\t\t}()\n\t}\n\n\tswitch isolation {\n\tcase IsolationOCI:\n\t\tvar moreCreateArgs []string\n\t\tif options.NoPivot {\n\t\t\tmoreCreateArgs = []string{\"--no-pivot\"}\n\t\t} else {\n\t\t\tmoreCreateArgs = nil\n\t\t}\n\t\terr = b.runUsingRuntimeSubproc(isolation, options, configureNetwork, networkString, moreCreateArgs, spec, mountPoint, path, containerName, b.Container, hostsFile, resolvFile)\n\tcase IsolationChroot:\n\t\terr = chroot.RunUsingChroot(spec, path, homeDir, options.Stdin, options.Stdout, options.Stderr, options.NoPivot)\n\tdefault:\n\t\terr = errors.New(\"don't know how to run this command\")\n\t}\n\treturn err\n}\n\nfunc addCommonOptsToSpec(commonOpts *define.CommonBuildOptions, g *generate.Generator) error {\n\tdefaultContainerConfig, err := config.Default()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get container config: %w\", err)\n\t}\n\t// Other process resource limits\n\tif err := addRlimits(commonOpts.Ulimit, g, defaultContainerConfig.Containers.DefaultUlimits.Get()); err != nil {\n\t\treturn err\n\t}\n\n\tlogrus.Debugf(\"Resources: %#v\", commonOpts)\n\treturn nil\n}\n\n// setupSpecialMountSpecChanges creates special mounts for depending\n// on the namespaces - nothing yet for freebsd\nfunc setupSpecialMountSpecChanges(spec *spec.Spec, shmSize string) ([]specs.Mount, error) {\n\treturn spec.Mounts, nil\n}\n\n// If this function succeeds and returns a non-nil *lockfile.LockFile, the caller must unlock it (when??).\nfunc (b *Builder) getCacheMount(tokens []string, stageMountPoints map[string]internal.StageMountDetails, idMaps IDMaps, workDir string) (*spec.Mount, *lockfile.LockFile, error) {\n\treturn nil, nil, errors.New(\"cache mounts not supported on freebsd\")\n}\n\nfunc (b *Builder) runSetupVolumeMounts(mountLabel string, volumeMounts []string, optionMounts []specs.Mount, idMaps IDMaps) (mounts []specs.Mount, Err error) {\n\t// Make sure the overlay directory is clean before running\n\t_, err := b.store.ContainerDirectory(b.ContainerID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"looking up container directory for %s: %w\", b.ContainerID, err)\n\t}\n\n\tparseMount := func(mountType, host, container string, options []string) (specs.Mount, error) {\n\t\tvar foundrw, foundro, foundO bool\n\t\tvar upperDir string\n\t\tfor _, opt := range options {\n\t\t\tswitch opt {\n\t\t\tcase \"rw\":\n\t\t\t\tfoundrw = true\n\t\t\tcase \"ro\":\n\t\t\t\tfoundro = true\n\t\t\tcase \"O\":\n\t\t\t\tfoundO = true\n\t\t\t}\n\t\t\tif strings.HasPrefix(opt, \"upperdir\") {\n\t\t\t\tsplitOpt := strings.SplitN(opt, \"=\", 2)\n\t\t\t\tif len(splitOpt) > 1 {\n\t\t\t\t\tupperDir = splitOpt[1]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif !foundrw && !foundro {\n\t\t\toptions = append(options, \"rw\")\n\t\t}\n\t\tif mountType == \"bind\" || mountType == \"rbind\" {\n\t\t\tmountType = \"nullfs\"\n\t\t}\n\t\tif foundO {\n\t\t\tcontainerDir, err := b.store.ContainerDirectory(b.ContainerID)\n\t\t\tif err != nil {\n\t\t\t\treturn specs.Mount{}, err\n\t\t\t}\n\n\t\t\tcontentDir, err := overlay.TempDir(containerDir, idMaps.rootUID, idMaps.rootGID)\n\t\t\tif err != nil {\n\t\t\t\treturn specs.Mount{}, fmt.Errorf(\"failed to create TempDir in the %s directory: %w\", containerDir, err)\n\t\t\t}\n\n\t\t\toverlayOpts := overlay.Options{\n\t\t\t\tRootUID:                idMaps.rootUID,\n\t\t\t\tRootGID:                idMaps.rootGID,\n\t\t\t\tUpperDirOptionFragment: upperDir,\n\t\t\t\tGraphOpts:              b.store.GraphOptions(),\n\t\t\t}\n\n\t\t\toverlayMount, err := overlay.MountWithOptions(contentDir, host, container, &overlayOpts)\n\t\t\tif err == nil {\n\t\t\t\tb.TempVolumes[contentDir] = true\n\t\t\t}\n\t\t\treturn overlayMount, err\n\t\t}\n\t\treturn specs.Mount{\n\t\t\tDestination: container,\n\t\t\tType:        mountType,\n\t\t\tSource:      host,\n\t\t\tOptions:     options,\n\t\t}, nil\n\t}\n\n\t// Bind mount volumes specified for this particular Run() invocation\n\tfor _, i := range optionMounts {\n\t\tlogrus.Debugf(\"setting up mounted volume at %q\", i.Destination)\n\t\tmount, err := parseMount(i.Type, i.Source, i.Destination, i.Options)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmounts = append(mounts, mount)\n\t}\n\t// Bind mount volumes given by the user when the container was created\n\tfor _, i := range volumeMounts {\n\t\tvar options []string\n\t\tspliti := strings.Split(i, \":\")\n\t\tif len(spliti) > 2 {\n\t\t\toptions = strings.Split(spliti[2], \",\")\n\t\t}\n\t\tmount, err := parseMount(\"nullfs\", spliti[0], spliti[1], options)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmounts = append(mounts, mount)\n\t}\n\treturn mounts, nil\n}\n\nfunc setupCapabilities(g *generate.Generator, defaultCapabilities, adds, drops []string) error {\n\treturn nil\n}\n\nfunc (b *Builder) runConfigureNetwork(pid int, isolation define.Isolation, options RunOptions, networkString string, containerName string, hostnames []string) (func(), *netResult, error) {\n\t//if isolation == IsolationOCIRootless {\n\t//return setupRootlessNetwork(pid)\n\t//}\n\n\tvar configureNetworks []string\n\tif len(networkString) > 0 {\n\t\tconfigureNetworks = strings.Split(networkString, \",\")\n\t}\n\n\tif len(configureNetworks) == 0 {\n\t\tconfigureNetworks = []string{b.NetworkInterface.DefaultNetworkName()}\n\t}\n\tlogrus.Debugf(\"configureNetworks: %v\", configureNetworks)\n\n\tvar mynetns string\n\tif jail.NeedVnetJail() {\n\t\tmynetns = containerName + \"-vnet\"\n\t} else {\n\t\tmynetns = containerName\n\t}\n\n\tnetworks := make(map[string]nettypes.PerNetworkOptions, len(configureNetworks))\n\tfor i, network := range configureNetworks {\n\t\tnetworks[network] = nettypes.PerNetworkOptions{\n\t\t\tInterfaceName: fmt.Sprintf(\"eth%d\", i),\n\t\t}\n\t}\n\n\topts := nettypes.NetworkOptions{\n\t\tContainerID:   containerName,\n\t\tContainerName: containerName,\n\t\tNetworks:      networks,\n\t}\n\tnetStatus, err := b.NetworkInterface.Setup(mynetns, nettypes.SetupOptions{NetworkOptions: opts})\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tteardown := func() {\n\t\terr := b.NetworkInterface.Teardown(mynetns, nettypes.TeardownOptions{NetworkOptions: opts})\n\t\tif err != nil {\n\t\t\tlogrus.Errorf(\"failed to cleanup network: %v\", err)\n\t\t}\n\t}\n\n\treturn teardown, netStatusToNetResult(netStatus, hostnames), nil\n}\n\nfunc setupNamespaces(logger *logrus.Logger, g *generate.Generator, namespaceOptions define.NamespaceOptions, idmapOptions define.IDMappingOptions, policy define.NetworkConfigurationPolicy) (configureNetwork bool, networkString string, configureUTS bool, err error) {\n\t// Set namespace options in the container configuration.\n\tfor _, namespaceOption := range namespaceOptions {\n\t\tswitch namespaceOption.Name {\n\t\tcase string(specs.NetworkNamespace):\n\t\t\tconfigureNetwork = false\n\t\t\tif !namespaceOption.Host && (namespaceOption.Path == \"\" || !filepath.IsAbs(namespaceOption.Path)) {\n\t\t\t\tif namespaceOption.Path != \"\" && !filepath.IsAbs(namespaceOption.Path) {\n\t\t\t\t\tnetworkString = namespaceOption.Path\n\t\t\t\t\tnamespaceOption.Path = \"\"\n\t\t\t\t}\n\t\t\t\tconfigureNetwork = (policy != define.NetworkDisabled)\n\t\t\t}\n\t\tcase string(specs.UTSNamespace):\n\t\t\tconfigureUTS = false\n\t\t\tif !namespaceOption.Host && namespaceOption.Path == \"\" {\n\t\t\t\tconfigureUTS = true\n\t\t\t}\n\t\t}\n\t\t// TODO: re-visit this when there is consensus on a\n\t\t// FreeBSD runtime-spec. FreeBSD jails have rough\n\t\t// equivalents for UTS and and network namespaces.\n\t}\n\n\treturn configureNetwork, networkString, configureUTS, nil\n}\n\nfunc (b *Builder) configureNamespaces(g *generate.Generator, options *RunOptions) (bool, string, error) {\n\tdefaultNamespaceOptions, err := DefaultNamespaceOptions()\n\tif err != nil {\n\t\treturn false, \"\", err\n\t}\n\n\tnamespaceOptions := defaultNamespaceOptions\n\tnamespaceOptions.AddOrReplace(b.NamespaceOptions...)\n\tnamespaceOptions.AddOrReplace(options.NamespaceOptions...)\n\n\tnetworkPolicy := options.ConfigureNetwork\n\t// Nothing was specified explicitly so network policy should be inherited from builder\n\tif networkPolicy == NetworkDefault {\n\t\tnetworkPolicy = b.ConfigureNetwork\n\n\t\t// If builder policy was NetworkDisabled and\n\t\t// we want to disable network for this run.\n\t\t// reset options.ConfigureNetwork to NetworkDisabled\n\t\t// since it will be treated as source of truth later.\n\t\tif networkPolicy == NetworkDisabled {\n\t\t\toptions.ConfigureNetwork = networkPolicy\n\t\t}\n\t}\n\n\tconfigureNetwork, networkString, configureUTS, err := setupNamespaces(options.Logger, g, namespaceOptions, b.IDMappingOptions, networkPolicy)\n\tif err != nil {\n\t\treturn false, \"\", err\n\t}\n\n\tif configureUTS {\n\t\tif options.Hostname != \"\" {\n\t\t\tg.SetHostname(options.Hostname)\n\t\t} else if b.Hostname() != \"\" {\n\t\t\tg.SetHostname(b.Hostname())\n\t\t} else {\n\t\t\tg.SetHostname(stringid.TruncateID(b.ContainerID))\n\t\t}\n\t} else {\n\t\tg.SetHostname(\"\")\n\t}\n\n\tfound := false\n\tspec := g.Config\n\tfor i := range spec.Process.Env {\n\t\tif strings.HasPrefix(spec.Process.Env[i], \"HOSTNAME=\") {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\tspec.Process.Env = append(spec.Process.Env, fmt.Sprintf(\"HOSTNAME=%s\", spec.Hostname))\n\t}\n\n\treturn configureNetwork, networkString, nil\n}\n\nfunc runSetupBoundFiles(bundlePath string, bindFiles map[string]string) (mounts []specs.Mount) {\n\tfor dest, src := range bindFiles {\n\t\toptions := []string{}\n\t\tif strings.HasPrefix(src, bundlePath) {\n\t\t\toptions = append(options, bind.NoBindOption)\n\t\t}\n\t\tmounts = append(mounts, specs.Mount{\n\t\t\tSource:      src,\n\t\t\tDestination: dest,\n\t\t\tType:        \"nullfs\",\n\t\t\tOptions:     options,\n\t\t})\n\t}\n\treturn mounts\n}\n\nfunc addRlimits(ulimit []string, g *generate.Generator, defaultUlimits []string) error {\n\tvar (\n\t\tul  *units.Ulimit\n\t\terr error\n\t)\n\n\tulimit = append(defaultUlimits, ulimit...)\n\tfor _, u := range ulimit {\n\t\tif ul, err = butil.ParseUlimit(u); err != nil {\n\t\t\treturn fmt.Errorf(\"ulimit option %q requires name=SOFT:HARD, failed to be parsed: %w\", u, err)\n\t\t}\n\n\t\tg.AddProcessRlimits(\"RLIMIT_\"+strings.ToUpper(ul.Name), uint64(ul.Hard), uint64(ul.Soft))\n\t}\n\treturn nil\n}\n\n// Create pipes to use for relaying stdio.\nfunc runMakeStdioPipe(uid, gid int) ([][]int, error) {\n\tstdioPipe := make([][]int, 3)\n\tfor i := range stdioPipe {\n\t\tstdioPipe[i] = make([]int, 2)\n\t\tif err := unix.Pipe(stdioPipe[i]); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"creating pipe for container FD %d: %w\", i, err)\n\t\t}\n\t}\n\treturn stdioPipe, nil\n}\n"
        },
        {
          "name": "run_linux.go",
          "type": "blob",
          "size": 44.4462890625,
          "content": "//go:build linux\n\npackage buildah\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\n\t\"github.com/containers/buildah/bind\"\n\t\"github.com/containers/buildah/chroot\"\n\t\"github.com/containers/buildah/copier\"\n\t\"github.com/containers/buildah/define\"\n\t\"github.com/containers/buildah/internal\"\n\t\"github.com/containers/buildah/internal/tmpdir\"\n\t\"github.com/containers/buildah/internal/volumes\"\n\t\"github.com/containers/buildah/pkg/binfmt\"\n\t\"github.com/containers/buildah/pkg/overlay\"\n\t\"github.com/containers/buildah/pkg/parse\"\n\tbutil \"github.com/containers/buildah/pkg/util\"\n\t\"github.com/containers/buildah/util\"\n\t\"github.com/containers/common/libnetwork/etchosts\"\n\t\"github.com/containers/common/libnetwork/pasta\"\n\t\"github.com/containers/common/libnetwork/resolvconf\"\n\t\"github.com/containers/common/libnetwork/slirp4netns\"\n\tnettypes \"github.com/containers/common/libnetwork/types\"\n\tnetUtil \"github.com/containers/common/libnetwork/util\"\n\t\"github.com/containers/common/pkg/capabilities\"\n\t\"github.com/containers/common/pkg/chown\"\n\t\"github.com/containers/common/pkg/config\"\n\t\"github.com/containers/common/pkg/hooks\"\n\thooksExec \"github.com/containers/common/pkg/hooks/exec\"\n\t\"github.com/containers/storage/pkg/fileutils\"\n\t\"github.com/containers/storage/pkg/idtools\"\n\t\"github.com/containers/storage/pkg/ioutils\"\n\t\"github.com/containers/storage/pkg/lockfile\"\n\t\"github.com/containers/storage/pkg/stringid\"\n\t\"github.com/containers/storage/pkg/unshare\"\n\t\"github.com/docker/go-units\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/runtime-tools/generate\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/exp/slices\"\n\t\"golang.org/x/sys/unix\"\n\t\"tags.cncf.io/container-device-interface/pkg/cdi\"\n\t\"tags.cncf.io/container-device-interface/pkg/parser\"\n)\n\nvar (\n\t// We dont want to remove destinations with /etc, /dev, /sys,\n\t// /proc as rootfs already contains these files and unionfs\n\t// will create a `whiteout` i.e `.wh` files on removal of\n\t// overlapping files from these directories.  everything other\n\t// than these will be cleaned up\n\tnonCleanablePrefixes = []string{\n\t\t\"/etc\", \"/dev\", \"/sys\", \"/proc\",\n\t}\n\t// binfmtRegistered makes sure we only try to register binfmt_misc\n\t// interpreters once, the first time we handle a RUN instruction.\n\tbinfmtRegistered sync.Once\n)\n\nfunc setChildProcess() error {\n\tif err := unix.Prctl(unix.PR_SET_CHILD_SUBREAPER, uintptr(1), 0, 0, 0); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"prctl(PR_SET_CHILD_SUBREAPER, 1): %v\\n\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (b *Builder) cdiSetupDevicesInSpec(deviceSpecs []string, configDir string, spec *specs.Spec) ([]string, error) {\n\tvar configDirs []string\n\tdefConfig, err := config.Default()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get container config: %w\", err)\n\t}\n\t// The CDI cache prioritizes entries from directories that are later in\n\t// the list of ones it scans, so start with our general config, then\n\t// append values passed to us through API layers.\n\tconfigDirs = slices.Clone(defConfig.Engine.CdiSpecDirs.Get())\n\tif b.CDIConfigDir != \"\" {\n\t\tconfigDirs = append(configDirs, b.CDIConfigDir)\n\t}\n\tif configDir != \"\" {\n\t\tconfigDirs = append(configDirs, configDir)\n\t}\n\tif len(configDirs) == 0 {\n\t\t// No directories to scan for CDI configuration means that CDI\n\t\t// won't have any details for setting up any devices, so we\n\t\t// don't need to be doing anything here.\n\t\treturn deviceSpecs, nil\n\t}\n\tvar qualifiedDeviceSpecs, unqualifiedDeviceSpecs []string\n\tfor _, deviceSpec := range deviceSpecs {\n\t\tif parser.IsQualifiedName(deviceSpec) {\n\t\t\tqualifiedDeviceSpecs = append(qualifiedDeviceSpecs, deviceSpec)\n\t\t} else {\n\t\t\tunqualifiedDeviceSpecs = append(unqualifiedDeviceSpecs, deviceSpec)\n\t\t}\n\t}\n\tif len(qualifiedDeviceSpecs) == 0 {\n\t\t// None of the specified devices were in the form that would be\n\t\t// handled by CDI, so we don't need to do anything here.\n\t\treturn deviceSpecs, nil\n\t}\n\tif err := cdi.Configure(cdi.WithSpecDirs(configDirs...)); err != nil {\n\t\treturn nil, fmt.Errorf(\"CDI default registry ignored configured directories %v: %w\", configDirs, err)\n\t}\n\tleftoverDevices := slices.Clone(deviceSpecs)\n\tif err := cdi.Refresh(); err != nil {\n\t\tlogrus.Warnf(\"CDI default registry refresh: %v\", err)\n\t} else {\n\t\tleftoverDevices, err = cdi.InjectDevices(spec, qualifiedDeviceSpecs...)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"CDI device injection (leftover devices: %v): %w\", leftoverDevices, err)\n\t\t}\n\t}\n\tremoved := slices.DeleteFunc(slices.Clone(deviceSpecs), func(t string) bool { return slices.Contains(leftoverDevices, t) })\n\tlogrus.Debugf(\"CDI taking care of devices %v, leaving devices %v, skipped %v\", removed, leftoverDevices, unqualifiedDeviceSpecs)\n\treturn append(leftoverDevices, unqualifiedDeviceSpecs...), nil\n}\n\n// Extract the device list so that we can still try to make it work if\n// we're running rootless and can't just mknod() the device nodes.\nfunc separateDevicesFromRuntimeSpec(g *generate.Generator) define.ContainerDevices {\n\tvar result define.ContainerDevices\n\tif g.Config != nil && g.Config.Linux != nil {\n\t\tfor _, device := range g.Config.Linux.Devices {\n\t\t\tvar bDevice define.BuildahDevice\n\t\t\tbDevice.Path = device.Path\n\t\t\tswitch device.Type {\n\t\t\tcase \"b\":\n\t\t\t\tbDevice.Type = 'b'\n\t\t\tcase \"c\":\n\t\t\t\tbDevice.Type = 'c'\n\t\t\tcase \"u\":\n\t\t\t\tbDevice.Type = 'u'\n\t\t\tcase \"p\":\n\t\t\t\tbDevice.Type = 'p'\n\t\t\t}\n\t\t\tbDevice.Major = device.Major\n\t\t\tbDevice.Minor = device.Minor\n\t\t\tif device.FileMode != nil {\n\t\t\t\tbDevice.FileMode = *device.FileMode\n\t\t\t}\n\t\t\tif device.UID != nil {\n\t\t\t\tbDevice.Uid = *device.UID\n\t\t\t}\n\t\t\tif device.GID != nil {\n\t\t\t\tbDevice.Gid = *device.GID\n\t\t\t}\n\t\t\tbDevice.Source = device.Path\n\t\t\tbDevice.Destination = device.Path\n\t\t\tresult = append(result, bDevice)\n\t\t}\n\t}\n\tg.ClearLinuxDevices()\n\treturn result\n}\n\n// Run runs the specified command in the container's root filesystem.\nfunc (b *Builder) Run(command []string, options RunOptions) error {\n\tif os.Getenv(\"container\") != \"\" {\n\t\tos, arch, variant, err := parse.Platform(\"\")\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"reading the current default platform\")\n\t\t}\n\t\tplatform := b.OCIv1.Platform\n\t\tif os != platform.OS || arch != platform.Architecture || variant != platform.Variant {\n\t\t\tbinfmtRegistered.Do(func() {\n\t\t\t\tif err := binfmt.Register(nil); err != nil {\n\t\t\t\t\tlogrus.Warnf(\"registering binfmt_misc interpreters: %v\", err)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tp, err := os.MkdirTemp(tmpdir.GetTempDir(), define.Package)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// On some hosts like AH, /tmp is a symlink and we need an\n\t// absolute path.\n\tpath, err := filepath.EvalSymlinks(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlogrus.Debugf(\"using %q to hold bundle data\", path)\n\tdefer func() {\n\t\tif err2 := os.RemoveAll(path); err2 != nil {\n\t\t\toptions.Logger.Error(err2)\n\t\t}\n\t}()\n\n\tgp, err := generate.New(\"linux\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"generating new 'linux' runtime spec: %w\", err)\n\t}\n\tg := &gp\n\n\tisolation := options.Isolation\n\tif isolation == define.IsolationDefault {\n\t\tisolation = b.Isolation\n\t\tif isolation == define.IsolationDefault {\n\t\t\tisolation, err = parse.IsolationOption(\"\")\n\t\t\tif err != nil {\n\t\t\t\tlogrus.Debugf(\"got %v while trying to determine default isolation, guessing OCI\", err)\n\t\t\t\tisolation = IsolationOCI\n\t\t\t} else if isolation == IsolationDefault {\n\t\t\t\tisolation = IsolationOCI\n\t\t\t}\n\t\t}\n\t}\n\tif err := checkAndOverrideIsolationOptions(isolation, &options); err != nil {\n\t\treturn err\n\t}\n\n\t// hardwire the environment to match docker build to avoid subtle and hard-to-debug differences due to containers.conf\n\tb.configureEnvironment(g, options, []string{\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\"})\n\n\tif b.CommonBuildOpts == nil {\n\t\treturn fmt.Errorf(\"invalid format on container you must recreate the container\")\n\t}\n\n\tif err := addCommonOptsToSpec(b.CommonBuildOpts, g); err != nil {\n\t\treturn err\n\t}\n\n\tworkDir := b.WorkDir()\n\tif options.WorkingDir != \"\" {\n\t\tg.SetProcessCwd(options.WorkingDir)\n\t\tworkDir = options.WorkingDir\n\t} else if b.WorkDir() != \"\" {\n\t\tg.SetProcessCwd(b.WorkDir())\n\t\tworkDir = b.WorkDir()\n\t}\n\tif workDir == \"\" {\n\t\tworkDir = string(os.PathSeparator)\n\t}\n\tsetupSelinux(g, b.ProcessLabel, b.MountLabel)\n\tmountPoint, err := b.Mount(b.MountLabel)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"mounting container %q: %w\", b.ContainerID, err)\n\t}\n\tdefer func() {\n\t\tif err := b.Unmount(); err != nil {\n\t\t\toptions.Logger.Errorf(\"error unmounting container: %v\", err)\n\t\t}\n\t}()\n\tg.SetRootPath(mountPoint)\n\tif len(command) > 0 {\n\t\tcommand = runLookupPath(g, command)\n\t\tg.SetProcessArgs(command)\n\t} else {\n\t\tg.SetProcessArgs(nil)\n\t}\n\n\t// Combine the working container's set of devices with the ones for just this run.\n\tdeviceSpecs := append(append([]string{}, options.DeviceSpecs...), b.DeviceSpecs...)\n\tdeviceSpecs, err = b.cdiSetupDevicesInSpec(deviceSpecs, options.CDIConfigDir, g.Config) // makes changes to more than just the device list\n\tif err != nil {\n\t\treturn err\n\t}\n\tdevices := separateDevicesFromRuntimeSpec(g)\n\tfor _, deviceSpec := range deviceSpecs {\n\t\tdevice, err := parse.DeviceFromPath(deviceSpec)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"setting up device %q: %w\", deviceSpec, err)\n\t\t}\n\t\tdevices = append(devices, device...)\n\t}\n\tdevices = append(append(devices, options.Devices...), b.Devices...)\n\n\t// Mount devices, if any, and if we're rootless attempt to work around not\n\t// being able to create device nodes by bind-mounting them from the host, like podman does.\n\tif unshare.IsRootless() {\n\t\t// We are going to create bind mounts for devices\n\t\t// but we need to make sure that we don't override\n\t\t// anything which is already in OCI spec.\n\t\tmounts := make(map[string]interface{})\n\t\tfor _, m := range g.Mounts() {\n\t\t\tmounts[m.Destination] = true\n\t\t}\n\t\tnewMounts := []specs.Mount{}\n\t\tfor _, d := range devices {\n\t\t\t// Default permission is read-only.\n\t\t\tperm := \"ro\"\n\t\t\t// Get permission configured for this device but only process `write`\n\t\t\t// permission in rootless since `mknod` is not supported anyways.\n\t\t\tif strings.Contains(string(d.Rule.Permissions), \"w\") {\n\t\t\t\tperm = \"rw\"\n\t\t\t}\n\t\t\tdevMnt := specs.Mount{\n\t\t\t\tDestination: d.Destination,\n\t\t\t\tType:        parse.TypeBind,\n\t\t\t\tSource:      d.Source,\n\t\t\t\tOptions:     []string{\"slave\", \"nosuid\", \"noexec\", perm, \"rbind\"},\n\t\t\t}\n\t\t\t// Podman parity: podman skips these two devices hence we do the same.\n\t\t\tif d.Path == \"/dev/ptmx\" || strings.HasPrefix(d.Path, \"/dev/tty\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Device is already in OCI spec do not re-mount.\n\t\t\tif _, found := mounts[d.Path]; found {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnewMounts = append(newMounts, devMnt)\n\t\t}\n\t\tg.Config.Mounts = append(newMounts, g.Config.Mounts...)\n\t} else {\n\t\tfor _, d := range devices {\n\t\t\tsDev := specs.LinuxDevice{\n\t\t\t\tType:     string(d.Type),\n\t\t\t\tPath:     d.Path,\n\t\t\t\tMajor:    d.Major,\n\t\t\t\tMinor:    d.Minor,\n\t\t\t\tFileMode: &d.FileMode,\n\t\t\t\tUID:      &d.Uid,\n\t\t\t\tGID:      &d.Gid,\n\t\t\t}\n\t\t\tg.AddDevice(sDev)\n\t\t\tg.AddLinuxResourcesDevice(true, string(d.Type), &d.Major, &d.Minor, string(d.Permissions))\n\t\t}\n\t}\n\n\tsetupMaskedPaths(g, b.CommonBuildOpts)\n\tsetupReadOnlyPaths(g)\n\n\tsetupTerminal(g, options.Terminal, options.TerminalSize)\n\n\tconfigureNetwork, networkString, err := b.configureNamespaces(g, &options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\thomeDir, err := b.configureUIDGID(g, mountPoint, options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tg.SetProcessNoNewPrivileges(b.CommonBuildOpts.NoNewPrivileges)\n\n\tg.SetProcessApparmorProfile(b.CommonBuildOpts.ApparmorProfile)\n\n\t// Now grab the spec from the generator.  Set the generator to nil so that future contributors\n\t// will quickly be able to tell that they're supposed to be modifying the spec directly from here.\n\tspec := g.Config\n\tg = nil\n\n\t// Set the seccomp configuration using the specified profile name.  Some syscalls are\n\t// allowed if certain capabilities are to be granted (example: CAP_SYS_CHROOT and chroot),\n\t// so we sorted out the capabilities lists first.\n\tif err = setupSeccomp(spec, b.CommonBuildOpts.SeccompProfilePath); err != nil {\n\t\treturn err\n\t}\n\n\tuid, gid := spec.Process.User.UID, spec.Process.User.GID\n\tif spec.Linux != nil {\n\t\tuid, gid, err = util.GetHostIDs(spec.Linux.UIDMappings, spec.Linux.GIDMappings, uid, gid)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tidPair := &idtools.IDPair{UID: int(uid), GID: int(gid)}\n\n\tmode := os.FileMode(0o755)\n\tcoptions := copier.MkdirOptions{\n\t\tChownNew: idPair,\n\t\tChmodNew: &mode,\n\t}\n\tif err := copier.Mkdir(mountPoint, filepath.Join(mountPoint, spec.Process.Cwd), coptions); err != nil {\n\t\treturn err\n\t}\n\n\tbindFiles := make(map[string]string)\n\tvolumes := b.Volumes()\n\n\t// Figure out who owns files that will appear to be owned by UID/GID 0 in the container.\n\trootUID, rootGID, err := util.GetHostRootIDs(spec)\n\tif err != nil {\n\t\treturn err\n\t}\n\trootIDPair := &idtools.IDPair{UID: int(rootUID), GID: int(rootGID)}\n\n\thostsFile := \"\"\n\tif !options.NoHosts && !slices.Contains(volumes, config.DefaultHostsFile) && options.ConfigureNetwork != define.NetworkDisabled {\n\t\thostsFile, err = b.createHostsFile(path, rootIDPair)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbindFiles[config.DefaultHostsFile] = hostsFile\n\n\t\t// Only add entries here if we do not have to do setup network,\n\t\t// if we do we have to do it much later after the network setup.\n\t\tif !configureNetwork {\n\t\t\tvar entries etchosts.HostEntries\n\t\t\tisHost := true\n\t\t\tif spec.Linux != nil {\n\t\t\t\tfor _, ns := range spec.Linux.Namespaces {\n\t\t\t\t\tif ns.Type == specs.NetworkNamespace {\n\t\t\t\t\t\tisHost = false\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// add host entry for local ip when running in host network\n\t\t\tif spec.Hostname != \"\" && isHost {\n\t\t\t\tip := netUtil.GetLocalIP()\n\t\t\t\tif ip != \"\" {\n\t\t\t\t\tentries = append(entries, etchosts.HostEntry{\n\t\t\t\t\t\tNames: []string{spec.Hostname},\n\t\t\t\t\t\tIP:    ip,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = b.addHostsEntries(hostsFile, mountPoint, entries, nil, \"\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif !options.NoHostname && !(slices.Contains(volumes, \"/etc/hostname\")) {\n\t\thostnameFile, err := b.generateHostname(path, spec.Hostname, rootIDPair)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Bind /etc/hostname\n\t\tbindFiles[\"/etc/hostname\"] = hostnameFile\n\t}\n\n\tresolvFile := \"\"\n\tif !slices.Contains(volumes, resolvconf.DefaultResolvConf) && options.ConfigureNetwork != define.NetworkDisabled && !(len(b.CommonBuildOpts.DNSServers) == 1 && strings.ToLower(b.CommonBuildOpts.DNSServers[0]) == \"none\") {\n\t\tresolvFile, err = b.createResolvConf(path, rootIDPair)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbindFiles[resolvconf.DefaultResolvConf] = resolvFile\n\n\t\t// Only add entries here if we do not have to do setup network,\n\t\t// if we do we have to do it much later after the network setup.\n\t\tif !configureNetwork {\n\t\t\terr = b.addResolvConfEntries(resolvFile, nil, spec, false, true)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\t// Empty file, so no need to recreate if it exists\n\tif _, ok := bindFiles[\"/run/.containerenv\"]; !ok {\n\t\tcontainerenvPath := filepath.Join(path, \"/run/.containerenv\")\n\t\tif err = os.MkdirAll(filepath.Dir(containerenvPath), 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\trootless := 0\n\t\tif unshare.IsRootless() {\n\t\t\trootless = 1\n\t\t}\n\t\t// Populate the .containerenv with container information\n\t\tcontainerenv := fmt.Sprintf(`\nengine=\"buildah-%s\"\nname=%q\nid=%q\nimage=%q\nimageid=%q\nrootless=%d\n`, define.Version, b.Container, b.ContainerID, b.FromImage, b.FromImageID, rootless)\n\n\t\tif err = ioutils.AtomicWriteFile(containerenvPath, []byte(containerenv), 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := relabel(containerenvPath, b.MountLabel, false); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tbindFiles[\"/run/.containerenv\"] = containerenvPath\n\t}\n\n\t// Setup OCI hooks\n\t_, err = b.setupOCIHooks(spec, (len(options.Mounts) > 0 || len(volumes) > 0))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to setup OCI hooks: %w\", err)\n\t}\n\n\trunMountInfo := runMountInfo{\n\t\tWorkDir:          workDir,\n\t\tContextDir:       options.ContextDir,\n\t\tSecrets:          options.Secrets,\n\t\tSSHSources:       options.SSHSources,\n\t\tStageMountPoints: options.StageMountPoints,\n\t\tSystemContext:    options.SystemContext,\n\t}\n\n\trunArtifacts, err := b.setupMounts(mountPoint, spec, path, options.Mounts, bindFiles, volumes, options.CompatBuiltinVolumes, b.CommonBuildOpts.Volumes, options.RunMounts, runMountInfo)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"resolving mountpoints for container %q: %w\", b.ContainerID, err)\n\t}\n\tif runArtifacts.SSHAuthSock != \"\" {\n\t\tsshenv := \"SSH_AUTH_SOCK=\" + runArtifacts.SSHAuthSock\n\t\tspec.Process.Env = append(spec.Process.Env, sshenv)\n\t}\n\n\t// following run was called from `buildah run`\n\t// and some images were mounted for this run\n\t// add them to cleanup artifacts\n\tif len(options.ExternalImageMounts) > 0 {\n\t\trunArtifacts.MountedImages = append(runArtifacts.MountedImages, options.ExternalImageMounts...)\n\t}\n\n\tdefer func() {\n\t\tif err := b.cleanupRunMounts(options.SystemContext, mountPoint, runArtifacts); err != nil {\n\t\t\toptions.Logger.Errorf(\"unable to cleanup run mounts %v\", err)\n\t\t}\n\t}()\n\n\tdefer b.cleanupTempVolumes()\n\n\tswitch isolation {\n\tcase define.IsolationOCI:\n\t\tvar moreCreateArgs []string\n\t\tif options.NoPivot {\n\t\t\tmoreCreateArgs = append(moreCreateArgs, \"--no-pivot\")\n\t\t}\n\t\terr = b.runUsingRuntimeSubproc(isolation, options, configureNetwork, networkString, moreCreateArgs, spec,\n\t\t\tmountPoint, path, define.Package+\"-\"+filepath.Base(path), b.Container, hostsFile, resolvFile)\n\tcase IsolationChroot:\n\t\terr = chroot.RunUsingChroot(spec, path, homeDir, options.Stdin, options.Stdout, options.Stderr, options.NoPivot)\n\tcase IsolationOCIRootless:\n\t\tmoreCreateArgs := []string{\"--no-new-keyring\"}\n\t\tif options.NoPivot {\n\t\t\tmoreCreateArgs = append(moreCreateArgs, \"--no-pivot\")\n\t\t}\n\t\terr = b.runUsingRuntimeSubproc(isolation, options, configureNetwork, networkString, moreCreateArgs, spec,\n\t\t\tmountPoint, path, define.Package+\"-\"+filepath.Base(path), b.Container, hostsFile, resolvFile)\n\tdefault:\n\t\terr = errors.New(\"don't know how to run this command\")\n\t}\n\treturn err\n}\n\nfunc (b *Builder) setupOCIHooks(config *specs.Spec, hasVolumes bool) (map[string][]specs.Hook, error) {\n\tallHooks := make(map[string][]specs.Hook)\n\tif len(b.CommonBuildOpts.OCIHooksDir) == 0 {\n\t\tif unshare.IsRootless() {\n\t\t\treturn nil, nil\n\t\t}\n\t\tfor _, hDir := range []string{hooks.DefaultDir, hooks.OverrideDir} {\n\t\t\tmanager, err := hooks.New(context.Background(), []string{hDir}, []string{})\n\t\t\tif err != nil {\n\t\t\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tociHooks, err := manager.Hooks(config, b.ImageAnnotations, hasVolumes)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif len(ociHooks) > 0 || config.Hooks != nil {\n\t\t\t\tlogrus.Warnf(\"Implicit hook directories are deprecated; set --hooks-dir=%q explicitly to continue to load ociHooks from this directory\", hDir)\n\t\t\t}\n\t\t\tfor i, hook := range ociHooks {\n\t\t\t\tallHooks[i] = hook\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmanager, err := hooks.New(context.Background(), b.CommonBuildOpts.OCIHooksDir, []string{})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tallHooks, err = manager.Hooks(config, b.ImageAnnotations, hasVolumes)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\thookErr, err := hooksExec.RuntimeConfigFilter(context.Background(), allHooks[\"precreate\"], config, hooksExec.DefaultPostKillTimeout) //nolint:staticcheck\n\tif err != nil {\n\t\tlogrus.Warnf(\"Container: precreate hook: %v\", err)\n\t\tif hookErr != nil && hookErr != err {\n\t\t\tlogrus.Debugf(\"container: precreate hook (hook error): %v\", hookErr)\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn allHooks, nil\n}\n\nfunc addCommonOptsToSpec(commonOpts *define.CommonBuildOptions, g *generate.Generator) error {\n\t// Resources - CPU\n\tif commonOpts.CPUPeriod != 0 {\n\t\tg.SetLinuxResourcesCPUPeriod(commonOpts.CPUPeriod)\n\t}\n\tif commonOpts.CPUQuota != 0 {\n\t\tg.SetLinuxResourcesCPUQuota(commonOpts.CPUQuota)\n\t}\n\tif commonOpts.CPUShares != 0 {\n\t\tg.SetLinuxResourcesCPUShares(commonOpts.CPUShares)\n\t}\n\tif commonOpts.CPUSetCPUs != \"\" {\n\t\tg.SetLinuxResourcesCPUCpus(commonOpts.CPUSetCPUs)\n\t}\n\tif commonOpts.CPUSetMems != \"\" {\n\t\tg.SetLinuxResourcesCPUMems(commonOpts.CPUSetMems)\n\t}\n\n\t// Resources - Memory\n\tif commonOpts.Memory != 0 {\n\t\tg.SetLinuxResourcesMemoryLimit(commonOpts.Memory)\n\t}\n\tif commonOpts.MemorySwap != 0 {\n\t\tg.SetLinuxResourcesMemorySwap(commonOpts.MemorySwap)\n\t}\n\n\t// cgroup membership\n\tif commonOpts.CgroupParent != \"\" {\n\t\tg.SetLinuxCgroupsPath(commonOpts.CgroupParent)\n\t}\n\n\tdefaultContainerConfig, err := config.Default()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to get container config: %w\", err)\n\t}\n\t// Other process resource limits\n\tif err := addRlimits(commonOpts.Ulimit, g, defaultContainerConfig.Containers.DefaultUlimits.Get()); err != nil {\n\t\treturn err\n\t}\n\n\tlogrus.Debugf(\"Resources: %#v\", commonOpts)\n\treturn nil\n}\n\nfunc setupSlirp4netnsNetwork(config *config.Config, netns, cid string, options, hostnames []string) (func(), *netResult, error) {\n\t// we need the TmpDir for the slirp4netns code\n\tif err := os.MkdirAll(config.Engine.TmpDir, 0o751); err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to create tempdir: %w\", err)\n\t}\n\tres, err := slirp4netns.Setup(&slirp4netns.SetupOptions{\n\t\tConfig:       config,\n\t\tContainerID:  cid,\n\t\tNetns:        netns,\n\t\tExtraOptions: options,\n\t\tPdeathsig:    syscall.SIGKILL,\n\t})\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tip, err := slirp4netns.GetIP(res.Subnet)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"get slirp4netns ip: %w\", err)\n\t}\n\n\tdns, err := slirp4netns.GetDNS(res.Subnet)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"get slirp4netns dns ip: %w\", err)\n\t}\n\n\tresult := &netResult{\n\t\tentries:           etchosts.HostEntries{{IP: ip.String(), Names: hostnames}},\n\t\tdnsServers:        []string{dns.String()},\n\t\tipv6:              res.IPv6,\n\t\tkeepHostResolvers: true,\n\t}\n\n\treturn func() {\n\t\tsyscall.Kill(res.Pid, syscall.SIGKILL) // nolint:errcheck\n\t\tvar status syscall.WaitStatus\n\t\tsyscall.Wait4(res.Pid, &status, 0, nil) // nolint:errcheck\n\t}, result, nil\n}\n\nfunc setupPasta(config *config.Config, netns string, options, hostnames []string) (func(), *netResult, error) {\n\tres, err := pasta.Setup(&pasta.SetupOptions{\n\t\tConfig:       config,\n\t\tNetns:        netns,\n\t\tExtraOptions: options,\n\t})\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar entries etchosts.HostEntries\n\tif len(res.IPAddresses) > 0 {\n\t\tentries = etchosts.HostEntries{{IP: res.IPAddresses[0].String(), Names: hostnames}}\n\t}\n\n\tmappedIP := \"\"\n\tif len(res.MapGuestAddrIPs) > 0 {\n\t\tmappedIP = res.MapGuestAddrIPs[0]\n\t}\n\n\tresult := &netResult{\n\t\tentries:                           entries,\n\t\tdnsServers:                        res.DNSForwardIPs,\n\t\texcludeIPs:                        res.IPAddresses,\n\t\tipv6:                              res.IPv6,\n\t\tkeepHostResolvers:                 true,\n\t\tpreferredHostContainersInternalIP: mappedIP,\n\t}\n\n\treturn nil, result, nil\n}\n\nfunc (b *Builder) runConfigureNetwork(pid int, isolation define.Isolation, options RunOptions, network, containerName string, hostnames []string) (func(), *netResult, error) {\n\tnetns := fmt.Sprintf(\"/proc/%d/ns/net\", pid)\n\tvar configureNetworks []string\n\tdefConfig, err := config.Default()\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to get container config: %w\", err)\n\t}\n\n\tname, networkOpts, hasOpts := strings.Cut(network, \":\")\n\tvar netOpts []string\n\tif hasOpts {\n\t\tnetOpts = strings.Split(networkOpts, \",\")\n\t}\n\tif isolation == IsolationOCIRootless && name == \"\" {\n\t\tswitch defConfig.Network.DefaultRootlessNetworkCmd {\n\t\tcase slirp4netns.BinaryName, \"\":\n\t\t\tname = slirp4netns.BinaryName\n\t\tcase pasta.BinaryName:\n\t\t\tname = pasta.BinaryName\n\t\tdefault:\n\t\t\treturn nil, nil, fmt.Errorf(\"invalid default_rootless_network_cmd option %q\",\n\t\t\t\tdefConfig.Network.DefaultRootlessNetworkCmd)\n\t\t}\n\t}\n\n\tswitch {\n\tcase name == slirp4netns.BinaryName:\n\t\treturn setupSlirp4netnsNetwork(defConfig, netns, containerName, netOpts, hostnames)\n\tcase name == pasta.BinaryName:\n\t\treturn setupPasta(defConfig, netns, netOpts, hostnames)\n\n\t// Basically default case except we make sure to not split an empty\n\t// name as this would return a slice with one empty string which is\n\t// not a valid network name.\n\tcase len(network) > 0:\n\t\t// old syntax allow comma separated network names\n\t\tconfigureNetworks = strings.Split(network, \",\")\n\t}\n\n\tif isolation == IsolationOCIRootless {\n\t\treturn nil, nil, errors.New(\"cannot use networks as rootless\")\n\t}\n\n\tif len(configureNetworks) == 0 {\n\t\tconfigureNetworks = []string{b.NetworkInterface.DefaultNetworkName()}\n\t}\n\n\t// Make sure we can access the container's network namespace,\n\t// even after it exits, to successfully tear down the\n\t// interfaces.  Ensure this by opening a handle to the network\n\t// namespace, and using our copy to both configure and\n\t// deconfigure it.\n\tnetFD, err := unix.Open(netns, unix.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"opening network namespace: %w\", err)\n\t}\n\tmynetns := fmt.Sprintf(\"/proc/%d/fd/%d\", unix.Getpid(), netFD)\n\n\tnetworks := make(map[string]nettypes.PerNetworkOptions, len(configureNetworks))\n\tfor i, network := range configureNetworks {\n\t\tnetworks[network] = nettypes.PerNetworkOptions{\n\t\t\tInterfaceName: fmt.Sprintf(\"eth%d\", i),\n\t\t}\n\t}\n\n\topts := nettypes.NetworkOptions{\n\t\tContainerID:   containerName,\n\t\tContainerName: containerName,\n\t\tNetworks:      networks,\n\t}\n\tnetStatus, err := b.NetworkInterface.Setup(mynetns, nettypes.SetupOptions{NetworkOptions: opts})\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tteardown := func() {\n\t\terr := b.NetworkInterface.Teardown(mynetns, nettypes.TeardownOptions{NetworkOptions: opts})\n\t\tif err != nil {\n\t\t\toptions.Logger.Errorf(\"failed to cleanup network: %v\", err)\n\t\t}\n\t}\n\n\treturn teardown, netStatusToNetResult(netStatus, hostnames), nil\n}\n\n// Create pipes to use for relaying stdio.\nfunc runMakeStdioPipe(uid, gid int) ([][]int, error) {\n\tstdioPipe := make([][]int, 3)\n\tfor i := range stdioPipe {\n\t\tstdioPipe[i] = make([]int, 2)\n\t\tif err := unix.Pipe(stdioPipe[i]); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"creating pipe for container FD %d: %w\", i, err)\n\t\t}\n\t}\n\tif err := unix.Fchown(stdioPipe[unix.Stdin][0], uid, gid); err != nil {\n\t\treturn nil, fmt.Errorf(\"setting owner of stdin pipe descriptor: %w\", err)\n\t}\n\tif err := unix.Fchown(stdioPipe[unix.Stdout][1], uid, gid); err != nil {\n\t\treturn nil, fmt.Errorf(\"setting owner of stdout pipe descriptor: %w\", err)\n\t}\n\tif err := unix.Fchown(stdioPipe[unix.Stderr][1], uid, gid); err != nil {\n\t\treturn nil, fmt.Errorf(\"setting owner of stderr pipe descriptor: %w\", err)\n\t}\n\treturn stdioPipe, nil\n}\n\nfunc setupNamespaces(_ *logrus.Logger, g *generate.Generator, namespaceOptions define.NamespaceOptions, idmapOptions define.IDMappingOptions, policy define.NetworkConfigurationPolicy) (configureNetwork bool, networkString string, configureUTS bool, err error) {\n\tdefaultContainerConfig, err := config.Default()\n\tif err != nil {\n\t\treturn false, \"\", false, fmt.Errorf(\"failed to get container config: %w\", err)\n\t}\n\n\taddSysctl := func(prefixes []string) error {\n\t\tfor _, sysctl := range defaultContainerConfig.Sysctls() {\n\t\t\tsplitn := strings.SplitN(sysctl, \"=\", 2)\n\t\t\tif len(splitn) > 2 {\n\t\t\t\treturn fmt.Errorf(\"sysctl %q defined in containers.conf must be formatted name=value\", sysctl)\n\t\t\t}\n\t\t\tfor _, prefix := range prefixes {\n\t\t\t\tif strings.HasPrefix(splitn[0], prefix) {\n\t\t\t\t\tg.AddLinuxSysctl(splitn[0], splitn[1])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Set namespace options in the container configuration.\n\tconfigureUserns := false\n\tspecifiedNetwork := false\n\tfor _, namespaceOption := range namespaceOptions {\n\t\tswitch namespaceOption.Name {\n\t\tcase string(specs.IPCNamespace):\n\t\t\tif !namespaceOption.Host {\n\t\t\t\tif err := addSysctl([]string{\"fs.mqueue\"}); err != nil {\n\t\t\t\t\treturn false, \"\", false, err\n\t\t\t\t}\n\t\t\t}\n\t\tcase string(specs.UserNamespace):\n\t\t\tconfigureUserns = false\n\t\t\tif !namespaceOption.Host && namespaceOption.Path == \"\" {\n\t\t\t\tconfigureUserns = true\n\t\t\t}\n\t\tcase string(specs.NetworkNamespace):\n\t\t\tspecifiedNetwork = true\n\t\t\tconfigureNetwork = false\n\t\t\tif !namespaceOption.Host && (namespaceOption.Path == \"\" || !filepath.IsAbs(namespaceOption.Path)) {\n\t\t\t\tif namespaceOption.Path != \"\" && !filepath.IsAbs(namespaceOption.Path) {\n\t\t\t\t\tnetworkString = namespaceOption.Path\n\t\t\t\t\tnamespaceOption.Path = \"\"\n\t\t\t\t}\n\t\t\t\tconfigureNetwork = (policy != define.NetworkDisabled)\n\t\t\t}\n\t\tcase string(specs.UTSNamespace):\n\t\t\tconfigureUTS = false\n\t\t\tif !namespaceOption.Host {\n\t\t\t\tif namespaceOption.Path == \"\" {\n\t\t\t\t\tconfigureUTS = true\n\t\t\t\t}\n\t\t\t\tif err := addSysctl([]string{\"kernel.hostname\", \"kernel.domainame\"}); err != nil {\n\t\t\t\t\treturn false, \"\", false, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif namespaceOption.Host {\n\t\t\tif err := g.RemoveLinuxNamespace(namespaceOption.Name); err != nil {\n\t\t\t\treturn false, \"\", false, fmt.Errorf(\"removing %q namespace for run: %w\", namespaceOption.Name, err)\n\t\t\t}\n\t\t} else if err := g.AddOrReplaceLinuxNamespace(namespaceOption.Name, namespaceOption.Path); err != nil {\n\t\t\tif namespaceOption.Path == \"\" {\n\t\t\t\treturn false, \"\", false, fmt.Errorf(\"adding new %q namespace for run: %w\", namespaceOption.Name, err)\n\t\t\t}\n\t\t\treturn false, \"\", false, fmt.Errorf(\"adding %q namespace %q for run: %w\", namespaceOption.Name, namespaceOption.Path, err)\n\t\t}\n\t}\n\n\t// If we've got mappings, we're going to have to create a user namespace.\n\tif len(idmapOptions.UIDMap) > 0 || len(idmapOptions.GIDMap) > 0 || configureUserns {\n\t\tif err := g.AddOrReplaceLinuxNamespace(string(specs.UserNamespace), \"\"); err != nil {\n\t\t\treturn false, \"\", false, fmt.Errorf(\"adding new %q namespace for run: %w\", string(specs.UserNamespace), err)\n\t\t}\n\t\thostUidmap, hostGidmap, err := unshare.GetHostIDMappings(\"\")\n\t\tif err != nil {\n\t\t\treturn false, \"\", false, err\n\t\t}\n\t\tfor _, m := range idmapOptions.UIDMap {\n\t\t\tg.AddLinuxUIDMapping(m.HostID, m.ContainerID, m.Size)\n\t\t}\n\t\tif len(idmapOptions.UIDMap) == 0 {\n\t\t\tfor _, m := range hostUidmap {\n\t\t\t\tg.AddLinuxUIDMapping(m.ContainerID, m.ContainerID, m.Size)\n\t\t\t}\n\t\t}\n\t\tfor _, m := range idmapOptions.GIDMap {\n\t\t\tg.AddLinuxGIDMapping(m.HostID, m.ContainerID, m.Size)\n\t\t}\n\t\tif len(idmapOptions.GIDMap) == 0 {\n\t\t\tfor _, m := range hostGidmap {\n\t\t\t\tg.AddLinuxGIDMapping(m.ContainerID, m.ContainerID, m.Size)\n\t\t\t}\n\t\t}\n\t\tif !specifiedNetwork {\n\t\t\tif err := g.AddOrReplaceLinuxNamespace(string(specs.NetworkNamespace), \"\"); err != nil {\n\t\t\t\treturn false, \"\", false, fmt.Errorf(\"adding new %q namespace for run: %w\", string(specs.NetworkNamespace), err)\n\t\t\t}\n\t\t\tconfigureNetwork = (policy != define.NetworkDisabled)\n\t\t}\n\t} else {\n\t\tif err := g.RemoveLinuxNamespace(string(specs.UserNamespace)); err != nil {\n\t\t\treturn false, \"\", false, fmt.Errorf(\"removing %q namespace for run: %w\", string(specs.UserNamespace), err)\n\t\t}\n\t\tif !specifiedNetwork {\n\t\t\tif err := g.RemoveLinuxNamespace(string(specs.NetworkNamespace)); err != nil {\n\t\t\t\treturn false, \"\", false, fmt.Errorf(\"removing %q namespace for run: %w\", string(specs.NetworkNamespace), err)\n\t\t\t}\n\t\t}\n\t}\n\tif configureNetwork {\n\t\tif err := addSysctl([]string{\"net\"}); err != nil {\n\t\t\treturn false, \"\", false, err\n\t\t}\n\t}\n\treturn configureNetwork, networkString, configureUTS, nil\n}\n\nfunc (b *Builder) configureNamespaces(g *generate.Generator, options *RunOptions) (bool, string, error) {\n\tdefaultNamespaceOptions, err := DefaultNamespaceOptions()\n\tif err != nil {\n\t\treturn false, \"\", err\n\t}\n\n\tnamespaceOptions := defaultNamespaceOptions\n\tnamespaceOptions.AddOrReplace(b.NamespaceOptions...)\n\tnamespaceOptions.AddOrReplace(options.NamespaceOptions...)\n\n\tnetworkPolicy := options.ConfigureNetwork\n\t// Nothing was specified explicitly so network policy should be inherited from builder\n\tif networkPolicy == NetworkDefault {\n\t\tnetworkPolicy = b.ConfigureNetwork\n\n\t\t// If builder policy was NetworkDisabled and\n\t\t// we want to disable network for this run.\n\t\t// reset options.ConfigureNetwork to NetworkDisabled\n\t\t// since it will be treated as source of truth later.\n\t\tif networkPolicy == NetworkDisabled {\n\t\t\toptions.ConfigureNetwork = networkPolicy\n\t\t}\n\t}\n\tif networkPolicy == NetworkDisabled {\n\t\tnamespaceOptions.AddOrReplace(define.NamespaceOptions{{Name: string(specs.NetworkNamespace), Host: false}}...)\n\t}\n\tconfigureNetwork, networkString, configureUTS, err := setupNamespaces(options.Logger, g, namespaceOptions, b.IDMappingOptions, networkPolicy)\n\tif err != nil {\n\t\treturn false, \"\", err\n\t}\n\n\tif configureUTS {\n\t\tif options.Hostname != \"\" {\n\t\t\tg.SetHostname(options.Hostname)\n\t\t} else if b.Hostname() != \"\" {\n\t\t\tg.SetHostname(b.Hostname())\n\t\t} else {\n\t\t\tg.SetHostname(stringid.TruncateID(b.ContainerID))\n\t\t}\n\t} else {\n\t\tg.SetHostname(\"\")\n\t}\n\n\tfound := false\n\tspec := g.Config\n\tfor i := range spec.Process.Env {\n\t\tif strings.HasPrefix(spec.Process.Env[i], \"HOSTNAME=\") {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\tspec.Process.Env = append(spec.Process.Env, fmt.Sprintf(\"HOSTNAME=%s\", spec.Hostname))\n\t}\n\n\treturn configureNetwork, networkString, nil\n}\n\nfunc runSetupBoundFiles(bundlePath string, bindFiles map[string]string) (mounts []specs.Mount) {\n\tfor dest, src := range bindFiles {\n\t\toptions := []string{\"rbind\"}\n\t\tif strings.HasPrefix(src, bundlePath) {\n\t\t\toptions = append(options, bind.NoBindOption)\n\t\t}\n\t\tmounts = append(mounts, specs.Mount{\n\t\t\tSource:      src,\n\t\t\tDestination: dest,\n\t\t\tType:        \"bind\",\n\t\t\tOptions:     options,\n\t\t})\n\t}\n\treturn mounts\n}\n\nfunc addRlimits(ulimit []string, g *generate.Generator, defaultUlimits []string) error {\n\tvar (\n\t\tul  *units.Ulimit\n\t\terr error\n\t\t// setup rlimits\n\t\tnofileSet bool\n\t\tnprocSet  bool\n\t)\n\n\tulimit = append(defaultUlimits, ulimit...)\n\tfor _, u := range ulimit {\n\t\tif ul, err = butil.ParseUlimit(u); err != nil {\n\t\t\treturn fmt.Errorf(\"ulimit option %q requires name=SOFT:HARD, failed to be parsed: %w\", u, err)\n\t\t}\n\n\t\tif strings.ToUpper(ul.Name) == \"NOFILE\" {\n\t\t\tnofileSet = true\n\t\t}\n\t\tif strings.ToUpper(ul.Name) == \"NPROC\" {\n\t\t\tnprocSet = true\n\t\t}\n\t\tg.AddProcessRlimits(\"RLIMIT_\"+strings.ToUpper(ul.Name), uint64(ul.Hard), uint64(ul.Soft))\n\t}\n\tif !nofileSet {\n\t\tmax := define.RLimitDefaultValue\n\t\tvar rlimit unix.Rlimit\n\t\tif err := unix.Getrlimit(unix.RLIMIT_NOFILE, &rlimit); err == nil {\n\t\t\tif max < rlimit.Max || unshare.IsRootless() {\n\t\t\t\tmax = rlimit.Max\n\t\t\t}\n\t\t} else {\n\t\t\tlogrus.Warnf(\"Failed to return RLIMIT_NOFILE ulimit %q\", err)\n\t\t}\n\t\tg.AddProcessRlimits(\"RLIMIT_NOFILE\", max, max)\n\t}\n\tif !nprocSet {\n\t\tmax := define.RLimitDefaultValue\n\t\tvar rlimit unix.Rlimit\n\t\tif err := unix.Getrlimit(unix.RLIMIT_NPROC, &rlimit); err == nil {\n\t\t\tif max < rlimit.Max || unshare.IsRootless() {\n\t\t\t\tmax = rlimit.Max\n\t\t\t}\n\t\t} else {\n\t\t\tlogrus.Warnf(\"Failed to return RLIMIT_NPROC ulimit %q\", err)\n\t\t}\n\t\tg.AddProcessRlimits(\"RLIMIT_NPROC\", max, max)\n\t}\n\n\treturn nil\n}\n\nfunc (b *Builder) runSetupVolumeMounts(mountLabel string, volumeMounts []string, optionMounts []specs.Mount, idMaps IDMaps) (mounts []specs.Mount, Err error) {\n\t// Make sure the overlay directory is clean before running\n\tcontainerDir, err := b.store.ContainerDirectory(b.ContainerID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"looking up container directory for %s: %w\", b.ContainerID, err)\n\t}\n\tif err := overlay.CleanupContent(containerDir); err != nil {\n\t\treturn nil, fmt.Errorf(\"cleaning up overlay content for %s: %w\", b.ContainerID, err)\n\t}\n\n\tparseMount := func(mountType, host, container string, options []string) (specs.Mount, error) {\n\t\tvar foundrw, foundro, foundz, foundZ, foundO, foundU bool\n\t\tvar rootProp, upperDir, workDir string\n\t\tfor _, opt := range options {\n\t\t\tswitch opt {\n\t\t\tcase \"rw\":\n\t\t\t\tfoundrw = true\n\t\t\tcase \"ro\":\n\t\t\t\tfoundro = true\n\t\t\tcase \"z\":\n\t\t\t\tfoundz = true\n\t\t\tcase \"Z\":\n\t\t\t\tfoundZ = true\n\t\t\tcase \"O\":\n\t\t\t\tfoundO = true\n\t\t\tcase \"U\":\n\t\t\t\tfoundU = true\n\t\t\tcase \"private\", \"rprivate\", \"slave\", \"rslave\", \"shared\", \"rshared\":\n\t\t\t\trootProp = opt\n\t\t\t}\n\n\t\t\tif strings.HasPrefix(opt, \"upperdir\") {\n\t\t\t\tsplitOpt := strings.SplitN(opt, \"=\", 2)\n\t\t\t\tif len(splitOpt) > 1 {\n\t\t\t\t\tupperDir = splitOpt[1]\n\t\t\t\t}\n\t\t\t}\n\t\t\tif strings.HasPrefix(opt, \"workdir\") {\n\t\t\t\tsplitOpt := strings.SplitN(opt, \"=\", 2)\n\t\t\t\tif len(splitOpt) > 1 {\n\t\t\t\t\tworkDir = splitOpt[1]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif !foundrw && !foundro {\n\t\t\toptions = append(options, \"rw\")\n\t\t}\n\t\tif foundz {\n\t\t\tif err := relabel(host, mountLabel, true); err != nil {\n\t\t\t\treturn specs.Mount{}, err\n\t\t\t}\n\t\t}\n\t\tif foundZ {\n\t\t\tif err := relabel(host, mountLabel, false); err != nil {\n\t\t\t\treturn specs.Mount{}, err\n\t\t\t}\n\t\t}\n\t\tif foundU {\n\t\t\tif err := chown.ChangeHostPathOwnership(host, true, idMaps.processUID, idMaps.processGID); err != nil {\n\t\t\t\treturn specs.Mount{}, err\n\t\t\t}\n\t\t}\n\t\tif foundO {\n\t\t\tif (upperDir != \"\" && workDir == \"\") || (workDir != \"\" && upperDir == \"\") {\n\t\t\t\treturn specs.Mount{}, errors.New(\"if specifying upperdir then workdir must be specified or vice versa\")\n\t\t\t}\n\n\t\t\tcontainerDir, err := b.store.ContainerDirectory(b.ContainerID)\n\t\t\tif err != nil {\n\t\t\t\treturn specs.Mount{}, err\n\t\t\t}\n\n\t\t\tcontentDir, err := overlay.TempDir(containerDir, idMaps.rootUID, idMaps.rootGID)\n\t\t\tif err != nil {\n\t\t\t\treturn specs.Mount{}, fmt.Errorf(\"failed to create TempDir in the %s directory: %w\", containerDir, err)\n\t\t\t}\n\n\t\t\toverlayOpts := overlay.Options{\n\t\t\t\tRootUID:                idMaps.rootUID,\n\t\t\t\tRootGID:                idMaps.rootGID,\n\t\t\t\tUpperDirOptionFragment: upperDir,\n\t\t\t\tWorkDirOptionFragment:  workDir,\n\t\t\t\tGraphOpts:              b.store.GraphOptions(),\n\t\t\t}\n\n\t\t\toverlayMount, err := overlay.MountWithOptions(contentDir, host, container, &overlayOpts)\n\t\t\tif err == nil {\n\t\t\t\tb.TempVolumes[contentDir] = true\n\t\t\t}\n\n\t\t\t// If chown true, add correct ownership to the overlay temp directories.\n\t\t\tif foundU {\n\t\t\t\tif err := chown.ChangeHostPathOwnership(contentDir, true, idMaps.processUID, idMaps.processGID); err != nil {\n\t\t\t\t\treturn specs.Mount{}, err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn overlayMount, err\n\t\t}\n\t\tif rootProp == \"\" {\n\t\t\toptions = append(options, \"private\")\n\t\t}\n\t\tif mountType != \"tmpfs\" {\n\t\t\tmountType = \"bind\"\n\t\t\toptions = append(options, \"rbind\")\n\t\t}\n\t\treturn specs.Mount{\n\t\t\tDestination: container,\n\t\t\tType:        mountType,\n\t\t\tSource:      host,\n\t\t\tOptions:     options,\n\t\t}, nil\n\t}\n\n\t// Bind mount volumes specified for this particular Run() invocation\n\tfor _, i := range optionMounts {\n\t\tlogrus.Debugf(\"setting up mounted volume at %q\", i.Destination)\n\t\tmount, err := parseMount(i.Type, i.Source, i.Destination, i.Options)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmounts = append(mounts, mount)\n\t}\n\t// Bind mount volumes given by the user when the container was created\n\tfor _, i := range volumeMounts {\n\t\tvar options []string\n\t\tspliti := parse.SplitStringWithColonEscape(i)\n\t\tif len(spliti) > 2 {\n\t\t\toptions = strings.Split(spliti[2], \",\")\n\t\t}\n\t\toptions = append(options, \"rbind\")\n\t\tmount, err := parseMount(\"bind\", spliti[0], spliti[1], options)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmounts = append(mounts, mount)\n\t}\n\treturn mounts, nil\n}\n\nfunc setupMaskedPaths(g *generate.Generator, opts *define.CommonBuildOptions) {\n\tif slices.Contains(opts.Unmasks, \"all\") {\n\t\treturn\n\t}\n\tfor _, mp := range append(config.DefaultMaskedPaths, opts.Masks...) {\n\t\tif slices.Contains(opts.Unmasks, mp) {\n\t\t\tcontinue\n\t\t}\n\t\tg.AddLinuxMaskedPaths(mp)\n\t}\n}\n\nfunc setupReadOnlyPaths(g *generate.Generator) {\n\tfor _, rp := range config.DefaultReadOnlyPaths {\n\t\tg.AddLinuxReadonlyPaths(rp)\n\t}\n}\n\nfunc setupCapAdd(g *generate.Generator, caps ...string) error {\n\tfor _, cap := range caps {\n\t\tif err := g.AddProcessCapabilityBounding(cap); err != nil {\n\t\t\treturn fmt.Errorf(\"adding %q to the bounding capability set: %w\", cap, err)\n\t\t}\n\t\tif err := g.AddProcessCapabilityEffective(cap); err != nil {\n\t\t\treturn fmt.Errorf(\"adding %q to the effective capability set: %w\", cap, err)\n\t\t}\n\t\tif err := g.AddProcessCapabilityPermitted(cap); err != nil {\n\t\t\treturn fmt.Errorf(\"adding %q to the permitted capability set: %w\", cap, err)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupCapDrop(g *generate.Generator, caps ...string) error {\n\tfor _, cap := range caps {\n\t\tif err := g.DropProcessCapabilityBounding(cap); err != nil {\n\t\t\treturn fmt.Errorf(\"removing %q from the bounding capability set: %w\", cap, err)\n\t\t}\n\t\tif err := g.DropProcessCapabilityEffective(cap); err != nil {\n\t\t\treturn fmt.Errorf(\"removing %q from the effective capability set: %w\", cap, err)\n\t\t}\n\t\tif err := g.DropProcessCapabilityPermitted(cap); err != nil {\n\t\t\treturn fmt.Errorf(\"removing %q from the permitted capability set: %w\", cap, err)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupCapabilities(g *generate.Generator, defaultCapabilities, adds, drops []string) error {\n\tg.ClearProcessCapabilities()\n\tif err := setupCapAdd(g, defaultCapabilities...); err != nil {\n\t\treturn err\n\t}\n\tfor _, c := range adds {\n\t\tif strings.ToLower(c) == \"all\" {\n\t\t\tadds = capabilities.AllCapabilities()\n\t\t\tbreak\n\t\t}\n\t}\n\tfor _, c := range drops {\n\t\tif strings.ToLower(c) == \"all\" {\n\t\t\tg.ClearProcessCapabilities()\n\t\t\treturn nil\n\t\t}\n\t}\n\tif err := setupCapAdd(g, adds...); err != nil {\n\t\treturn err\n\t}\n\treturn setupCapDrop(g, drops...)\n}\n\nfunc addOrReplaceMount(mounts []specs.Mount, mount specs.Mount) []specs.Mount {\n\tfor i := range mounts {\n\t\tif mounts[i].Destination == mount.Destination {\n\t\t\tmounts[i] = mount\n\t\t\treturn mounts\n\t\t}\n\t}\n\treturn append(mounts, mount)\n}\n\n// setupSpecialMountSpecChanges creates special mounts for depending on the namespaces\n// logic taken from podman and adapted for buildah\n// https://github.com/containers/podman/blob/4ba71f955a944790edda6e007e6d074009d437a7/pkg/specgen/generate/oci.go#L178\nfunc setupSpecialMountSpecChanges(spec *specs.Spec, shmSize string) ([]specs.Mount, error) {\n\tmounts := spec.Mounts\n\tisRootless := unshare.IsRootless()\n\tisNewUserns := false\n\tisNetns := false\n\tisPidns := false\n\tisIpcns := false\n\n\tfor _, namespace := range spec.Linux.Namespaces {\n\t\tswitch namespace.Type {\n\t\tcase specs.NetworkNamespace:\n\t\t\tisNetns = true\n\t\tcase specs.UserNamespace:\n\t\t\tisNewUserns = true\n\t\tcase specs.PIDNamespace:\n\t\t\tisPidns = true\n\t\tcase specs.IPCNamespace:\n\t\t\tisIpcns = true\n\t\t}\n\t}\n\n\taddCgroup := true\n\t// mount sys when root and no userns or when a new netns is created\n\tcanMountSys := (!isRootless && !isNewUserns) || isNetns\n\tif !canMountSys {\n\t\taddCgroup = false\n\t\tsys := \"/sys\"\n\t\tsysMnt := specs.Mount{\n\t\t\tDestination: sys,\n\t\t\tType:        \"bind\",\n\t\t\tSource:      sys,\n\t\t\tOptions:     []string{bind.NoBindOption, \"rprivate\", \"nosuid\", \"noexec\", \"nodev\", \"ro\", \"rbind\"},\n\t\t}\n\t\tmounts = addOrReplaceMount(mounts, sysMnt)\n\t}\n\n\tgid5Available := true\n\tif isRootless {\n\t\t_, gids, err := unshare.GetHostIDMappings(\"\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tgid5Available = checkIDsGreaterThan5(gids)\n\t}\n\tif gid5Available && len(spec.Linux.GIDMappings) > 0 {\n\t\tgid5Available = checkIDsGreaterThan5(spec.Linux.GIDMappings)\n\t}\n\tif !gid5Available {\n\t\t// If we have no GID mappings, the gid=5 default option would fail, so drop it.\n\t\tdevPts := specs.Mount{\n\t\t\tDestination: \"/dev/pts\",\n\t\t\tType:        \"devpts\",\n\t\t\tSource:      \"devpts\",\n\t\t\tOptions:     []string{\"rprivate\", \"nosuid\", \"noexec\", \"newinstance\", \"ptmxmode=0666\", \"mode=0620\"},\n\t\t}\n\t\tmounts = addOrReplaceMount(mounts, devPts)\n\t}\n\n\tisUserns := isNewUserns || isRootless\n\n\tif isUserns && !isIpcns {\n\t\tdevMqueue := \"/dev/mqueue\"\n\t\tdevMqueueMnt := specs.Mount{\n\t\t\tDestination: devMqueue,\n\t\t\tType:        \"bind\",\n\t\t\tSource:      devMqueue,\n\t\t\tOptions:     []string{bind.NoBindOption, \"bind\", \"nosuid\", \"noexec\", \"nodev\"},\n\t\t}\n\t\tmounts = addOrReplaceMount(mounts, devMqueueMnt)\n\t}\n\tif isUserns && !isPidns {\n\t\tproc := \"/proc\"\n\t\tprocMount := specs.Mount{\n\t\t\tDestination: proc,\n\t\t\tType:        \"bind\",\n\t\t\tSource:      proc,\n\t\t\tOptions:     []string{bind.NoBindOption, \"rbind\", \"nosuid\", \"noexec\", \"nodev\"},\n\t\t}\n\t\tmounts = addOrReplaceMount(mounts, procMount)\n\t}\n\n\tif addCgroup {\n\t\tcgroupMnt := specs.Mount{\n\t\t\tDestination: \"/sys/fs/cgroup\",\n\t\t\tType:        \"cgroup\",\n\t\t\tSource:      \"cgroup\",\n\t\t\tOptions:     []string{\"rprivate\", \"nosuid\", \"noexec\", \"nodev\", \"relatime\", \"rw\"},\n\t\t}\n\t\tmounts = addOrReplaceMount(mounts, cgroupMnt)\n\t}\n\n\t// if userns and host ipc bind mount shm\n\tif isUserns && !isIpcns {\n\t\t// bind mount /dev/shm when it exists\n\t\tif err := fileutils.Exists(\"/dev/shm\"); err == nil {\n\t\t\tshmMount := specs.Mount{\n\t\t\t\tSource:      \"/dev/shm\",\n\t\t\t\tType:        \"bind\",\n\t\t\t\tDestination: \"/dev/shm\",\n\t\t\t\tOptions:     []string{bind.NoBindOption, \"rbind\", \"nosuid\", \"noexec\", \"nodev\"},\n\t\t\t}\n\t\t\tmounts = addOrReplaceMount(mounts, shmMount)\n\t\t}\n\t} else if shmSize != \"\" {\n\t\tshmMount := specs.Mount{\n\t\t\tSource:      \"shm\",\n\t\t\tDestination: \"/dev/shm\",\n\t\t\tType:        \"tmpfs\",\n\t\t\tOptions:     []string{\"private\", \"nodev\", \"noexec\", \"nosuid\", \"mode=1777\", \"size=\" + shmSize},\n\t\t}\n\t\tmounts = addOrReplaceMount(mounts, shmMount)\n\t}\n\n\treturn mounts, nil\n}\n\nfunc checkIDsGreaterThan5(ids []specs.LinuxIDMapping) bool {\n\tfor _, r := range ids {\n\t\tif r.ContainerID <= 5 && 5 < r.ContainerID+r.Size {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// If this function succeeds and returns a non-nil *lockfile.LockFile, the caller must unlock it (when??).\nfunc (b *Builder) getCacheMount(tokens []string, stageMountPoints map[string]internal.StageMountDetails, idMaps IDMaps, workDir string) (*specs.Mount, *lockfile.LockFile, error) {\n\tvar optionMounts []specs.Mount\n\tmount, targetLock, err := volumes.GetCacheMount(tokens, b.store, b.MountLabel, stageMountPoints, workDir)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tsucceeded := false\n\tdefer func() {\n\t\tif !succeeded && targetLock != nil {\n\t\t\ttargetLock.Unlock()\n\t\t}\n\t}()\n\toptionMounts = append(optionMounts, mount)\n\tvolumes, err := b.runSetupVolumeMounts(b.MountLabel, nil, optionMounts, idMaps)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tsucceeded = true\n\treturn &volumes[0], targetLock, nil\n}\n"
        },
        {
          "name": "run_test.go",
          "type": "blob",
          "size": 2.10546875,
          "content": "package buildah\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/opencontainers/runtime-tools/generate\"\n)\n\nfunc TestAddRlimits(t *testing.T) {\n\ttt := []struct {\n\t\tname   string\n\t\tulimit []string\n\t\ttest   func(error, *generate.Generator) error\n\t}{\n\t\t{\n\t\t\tname:   \"empty ulimit\",\n\t\t\tulimit: []string{},\n\t\t\ttest: func(e error, _ *generate.Generator) error {\n\t\t\t\treturn e\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"invalid ulimit argument\",\n\t\t\tulimit: []string{\"bla\"},\n\t\t\ttest: func(e error, _ *generate.Generator) error {\n\t\t\t\tif e == nil {\n\t\t\t\t\treturn errors.New(\"expected to receive an error but got nil\")\n\t\t\t\t}\n\t\t\t\terrMsg := \"invalid ulimit argument\"\n\t\t\t\tif !strings.Contains(e.Error(), errMsg) {\n\t\t\t\t\treturn fmt.Errorf(\"expected error message to include %#v in %#v\", errMsg, e.Error())\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"invalid ulimit type\",\n\t\t\tulimit: []string{\"bla=hard\"},\n\t\t\ttest: func(e error, _ *generate.Generator) error {\n\t\t\t\tif e == nil {\n\t\t\t\t\treturn errors.New(\"expected to receive an error but got nil\")\n\t\t\t\t}\n\t\t\t\terrMsg := \"invalid ulimit type\"\n\t\t\t\tif !strings.Contains(e.Error(), errMsg) {\n\t\t\t\t\treturn fmt.Errorf(\"expected error message to include %#v in %#v\", errMsg, e.Error())\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"valid ulimit\",\n\t\t\tulimit: []string{\"fsize=1024:4096\"},\n\t\t\ttest: func(e error, g *generate.Generator) error {\n\t\t\t\tif e != nil {\n\t\t\t\t\treturn e\n\t\t\t\t}\n\t\t\t\trlimits := g.Config.Process.Rlimits\n\t\t\t\tfor _, rlimit := range rlimits {\n\t\t\t\t\tif rlimit.Type == \"RLIMIT_FSIZE\" {\n\t\t\t\t\t\tif rlimit.Hard != 4096 {\n\t\t\t\t\t\t\treturn fmt.Errorf(\"expected spec to have %#v hard limit set to %v but got %v\", rlimit.Type, 4096, rlimit.Hard)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif rlimit.Soft != 1024 {\n\t\t\t\t\t\t\treturn fmt.Errorf(\"expected spec to have %#v hard limit set to %v but got %v\", rlimit.Type, 1024, rlimit.Soft)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn errors.New(\"expected spec to have RLIMIT_FSIZE\")\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tst := range tt {\n\t\tg, _ := generate.New(\"linux\")\n\t\terr := addRlimits(tst.ulimit, &g, []string{})\n\t\tif testErr := tst.test(err, &g); testErr != nil {\n\t\t\tt.Errorf(\"test %#v failed: %v\", tst.name, testErr)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "run_unix.go",
          "type": "blob",
          "size": 1.314453125,
          "content": "//go:build darwin\n\npackage buildah\n\nimport (\n\t\"errors\"\n\n\t\"github.com/containers/buildah/define\"\n\tnettypes \"github.com/containers/common/libnetwork/types\"\n\t\"github.com/containers/storage\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n)\n\n// ContainerDevices is an alias for a slice of github.com/opencontainers/runc/libcontainer/configs.Device structures.\ntype ContainerDevices define.ContainerDevices\n\nfunc setChildProcess() error {\n\treturn errors.New(\"function not supported on non-linux systems\")\n}\n\nfunc runUsingRuntimeMain() {}\n\nfunc (b *Builder) Run(command []string, options RunOptions) error {\n\treturn errors.New(\"function not supported on non-linux systems\")\n}\n\nfunc DefaultNamespaceOptions() (NamespaceOptions, error) {\n\toptions := NamespaceOptions{\n\t\t{Name: string(specs.CgroupNamespace), Host: false},\n\t\t{Name: string(specs.IPCNamespace), Host: false},\n\t\t{Name: string(specs.MountNamespace), Host: false},\n\t\t{Name: string(specs.NetworkNamespace), Host: false},\n\t\t{Name: string(specs.PIDNamespace), Host: false},\n\t\t{Name: string(specs.UserNamespace), Host: false},\n\t\t{Name: string(specs.UTSNamespace), Host: false},\n\t}\n\treturn options, nil\n}\n\n// getNetworkInterface creates the network interface\nfunc getNetworkInterface(store storage.Store, cniConfDir, cniPluginPath string) (nettypes.ContainerNetwork, error) {\n\treturn nil, nil\n}\n"
        },
        {
          "name": "run_unsupported.go",
          "type": "blob",
          "size": 0.8125,
          "content": "//go:build !linux && !darwin && !freebsd\n\npackage buildah\n\nimport (\n\t\"errors\"\n\n\tnettypes \"github.com/containers/common/libnetwork/types\"\n\t\"github.com/containers/storage\"\n)\n\nfunc setChildProcess() error {\n\treturn errors.New(\"function not supported on non-linux systems\")\n}\n\nfunc runUsingRuntimeMain() {}\n\nfunc (b *Builder) Run(command []string, options RunOptions) error {\n\treturn errors.New(\"function not supported on non-linux systems\")\n}\n\nfunc DefaultNamespaceOptions() (NamespaceOptions, error) {\n\treturn NamespaceOptions{}, errors.New(\"function not supported on non-linux systems\")\n}\n\n// getNetworkInterface creates the network interface\nfunc getNetworkInterface(store storage.Store, cniConfDir, cniPluginPath string) (nettypes.ContainerNetwork, error) {\n\treturn nil, errors.New(\"function not supported on non-linux systems\")\n}\n"
        },
        {
          "name": "scan.go",
          "type": "blob",
          "size": 10.1640625,
          "content": "package buildah\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/containers/buildah/define\"\n\t\"github.com/containers/buildah/internal/sbom\"\n\t\"github.com/mattn/go-shellwords\"\n\trspec \"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/exp/slices\"\n)\n\nfunc stringSliceReplaceAll(slice []string, replacements map[string]string, important []string) (built []string, replacedAnImportantValue bool) {\n\tbuilt = make([]string, 0, len(slice))\n\tfor i := range slice {\n\t\telement := slice[i]\n\t\tfor from, to := range replacements {\n\t\t\tprevious := element\n\t\t\tif element = strings.ReplaceAll(previous, from, to); element != previous {\n\t\t\t\tif len(important) == 0 || slices.Contains(important, from) {\n\t\t\t\t\treplacedAnImportantValue = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbuilt = append(built, element)\n\t}\n\treturn built, replacedAnImportantValue\n}\n\n// sbomScan iterates through the scanning configuration settings, generating\n// SBOM files and storing them either in the rootfs or in a local file path.\nfunc (b *Builder) sbomScan(ctx context.Context, options CommitOptions) (imageFiles, localFiles map[string]string, scansDir string, err error) {\n\t// We'll use a temporary per-container directory for this one.\n\tcdir, err := b.store.ContainerDirectory(b.ContainerID)\n\tif err != nil {\n\t\treturn nil, nil, \"\", err\n\t}\n\tscansDir, err = os.MkdirTemp(cdir, \"buildah-scan\")\n\tif err != nil {\n\t\treturn nil, nil, \"\", err\n\t}\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tif err := os.RemoveAll(scansDir); err != nil {\n\t\t\t\tlogrus.Warnf(\"removing temporary directory %q: %v\", scansDir, err)\n\t\t\t}\n\t\t}\n\t}()\n\n\t// We may be producing sets of outputs using temporary containers, and\n\t// there's no need to create more than one container for any one\n\t// specific scanner image.\n\tscanners := make(map[string]*Builder)\n\tdefer func() {\n\t\tfor _, scanner := range scanners {\n\t\t\tscannerID := scanner.ContainerID\n\t\t\tif err := scanner.Delete(); err != nil {\n\t\t\t\tlogrus.Warnf(\"removing temporary scanner container %q: %v\", scannerID, err)\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Just assume that every scanning method will be looking at the rootfs.\n\trootfs, err := b.Mount(b.MountLabel)\n\tif err != nil {\n\t\treturn nil, nil, \"\", err\n\t}\n\tdefer func(b *Builder) {\n\t\tif err := b.Unmount(); err != nil {\n\t\t\tlogrus.Warnf(\"unmounting temporary scanner container %q: %v\", b.ContainerID, err)\n\t\t}\n\t}(b)\n\n\t// Iterate through all of the scanning strategies.\n\tfor _, scanSpec := range options.SBOMScanOptions {\n\t\t// Pull the image and create a container we can run the scanner\n\t\t// in, unless we've done that already for this scanner image.\n\t\tscanBuilder, ok := scanners[scanSpec.Image]\n\t\tif !ok {\n\t\t\tbuilderOptions := BuilderOptions{\n\t\t\t\tFromImage:        scanSpec.Image,\n\t\t\t\tContainerSuffix:  \"scanner\",\n\t\t\t\tPullPolicy:       scanSpec.PullPolicy,\n\t\t\t\tBlobDirectory:    options.BlobDirectory,\n\t\t\t\tLogger:           b.Logger,\n\t\t\t\tSystemContext:    options.SystemContext,\n\t\t\t\tMountLabel:       b.MountLabel,\n\t\t\t\tProcessLabel:     b.ProcessLabel,\n\t\t\t\tIDMappingOptions: &b.IDMappingOptions,\n\t\t\t}\n\t\t\tif scanBuilder, err = NewBuilder(ctx, b.store, builderOptions); err != nil {\n\t\t\t\treturn nil, nil, \"\", fmt.Errorf(\"creating temporary working container to run scanner: %w\", err)\n\t\t\t}\n\t\t\tscanners[scanSpec.Image] = scanBuilder\n\t\t}\n\t\t// Now figure out which commands we need to run.  First, try to\n\t\t// parse a command ourselves, because syft's image (at least)\n\t\t// doesn't include a shell.  Build a slice of command slices.\n\t\tvar commands [][]string\n\t\tfor _, commandSpec := range scanSpec.Commands {\n\t\t\t// Start by assuming it's shell -c $whatever.\n\t\t\tparsedCommand := []string{\"/bin/sh\", \"-c\", commandSpec}\n\t\t\tif shell := scanBuilder.Shell(); len(shell) != 0 {\n\t\t\t\tparsedCommand = append(append([]string{}, shell...), commandSpec)\n\t\t\t}\n\t\t\tif !strings.ContainsAny(commandSpec, \"<>|\") { // An imperfect check for shell redirection being used.\n\t\t\t\t// If we can parse it ourselves, though, prefer to use that result,\n\t\t\t\t// in case the scanner image doesn't include a shell.\n\t\t\t\tif parsed, err := shellwords.Parse(commandSpec); err == nil {\n\t\t\t\t\tparsedCommand = parsed\n\t\t\t\t}\n\t\t\t}\n\t\t\tcommands = append(commands, parsedCommand)\n\t\t}\n\t\t// Set up a list of mounts for the rootfs and whichever context\n\t\t// directories we're told were used.\n\t\tconst rootfsTargetDir = \"/.rootfs\"\n\t\tconst scansTargetDir = \"/.scans\"\n\t\tconst contextsTargetDirPrefix = \"/.context\"\n\t\trunMounts := []rspec.Mount{\n\t\t\t// Our temporary directory, read-write.\n\t\t\t{\n\t\t\t\tType:        define.TypeBind,\n\t\t\t\tSource:      scansDir,\n\t\t\t\tDestination: scansTargetDir,\n\t\t\t\tOptions:     []string{\"rw\", \"z\"},\n\t\t\t},\n\t\t\t// The rootfs, read-only.\n\t\t\t{\n\t\t\t\tType:        define.TypeBind,\n\t\t\t\tSource:      rootfs,\n\t\t\t\tDestination: rootfsTargetDir,\n\t\t\t\tOptions:     []string{\"ro\"},\n\t\t\t},\n\t\t}\n\t\t// Each context directory, also read-only.\n\t\tfor i := range scanSpec.ContextDir {\n\t\t\tcontextMount := rspec.Mount{\n\t\t\t\tType:        define.TypeBind,\n\t\t\t\tSource:      scanSpec.ContextDir[i],\n\t\t\t\tDestination: fmt.Sprintf(\"%s%d\", contextsTargetDirPrefix, i),\n\t\t\t\tOptions:     []string{\"ro\"},\n\t\t\t}\n\t\t\trunMounts = append(runMounts, contextMount)\n\t\t}\n\t\t// Set up run options and mounts one time, and reuse it.\n\t\trunOptions := RunOptions{\n\t\t\tLogger:        b.Logger,\n\t\t\tIsolation:     b.Isolation,\n\t\t\tSystemContext: options.SystemContext,\n\t\t\tMounts:        runMounts,\n\t\t}\n\t\t// We'll have to do some text substitutions so that we run the\n\t\t// right commands, in the right order, pointing at the right\n\t\t// mount points.\n\t\tvar resolvedCommands [][]string\n\t\tvar resultFiles []string\n\t\tfor _, command := range commands {\n\t\t\t// Each command gets to produce its own file that we'll\n\t\t\t// combine later if there's more than one of them.\n\t\t\tcontextDirScans := 0\n\t\t\tfor i := range scanSpec.ContextDir {\n\t\t\t\tresultFile := filepath.Join(scansTargetDir, fmt.Sprintf(\"scan%d.json\", len(resultFiles)))\n\t\t\t\t// If the command mentions {CONTEXT}...\n\t\t\t\tresolvedCommand, scansContext := stringSliceReplaceAll(command,\n\t\t\t\t\tmap[string]string{\n\t\t\t\t\t\t\"{CONTEXT}\": fmt.Sprintf(\"%s%d\", contextsTargetDirPrefix, i),\n\t\t\t\t\t\t\"{OUTPUT}\":  resultFile,\n\t\t\t\t\t},\n\t\t\t\t\t[]string{\"{CONTEXT}\"},\n\t\t\t\t)\n\t\t\t\tif !scansContext {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\t// ... resolve the path references and add it to the list of commands.\n\t\t\t\tresolvedCommands = append(resolvedCommands, resolvedCommand)\n\t\t\t\tresultFiles = append(resultFiles, resultFile)\n\t\t\t\tcontextDirScans++\n\t\t\t}\n\t\t\tif contextDirScans == 0 {\n\t\t\t\tresultFile := filepath.Join(scansTargetDir, fmt.Sprintf(\"scan%d.json\", len(resultFiles)))\n\t\t\t\t// If the command didn't mention {CONTEXT}, but does mention {ROOTFS}...\n\t\t\t\tresolvedCommand, scansRootfs := stringSliceReplaceAll(command,\n\t\t\t\t\tmap[string]string{\n\t\t\t\t\t\t\"{ROOTFS}\": rootfsTargetDir,\n\t\t\t\t\t\t\"{OUTPUT}\": resultFile,\n\t\t\t\t\t},\n\t\t\t\t\t[]string{\"{ROOTFS}\"},\n\t\t\t\t)\n\t\t\t\t// ... resolve the path references and add that to the list of commands.\n\t\t\t\tif scansRootfs {\n\t\t\t\t\tresolvedCommands = append(resolvedCommands, resolvedCommand)\n\t\t\t\t\tresultFiles = append(resultFiles, resultFile)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Run all of the commands, one after the other, producing one\n\t\t// or more files named \"scan%d.json\" in our temporary directory.\n\t\tfor _, resolvedCommand := range resolvedCommands {\n\t\t\tlogrus.Debugf(\"Running scan command %q\", resolvedCommand)\n\t\t\tif err = scanBuilder.Run(resolvedCommand, runOptions); err != nil {\n\t\t\t\treturn nil, nil, \"\", fmt.Errorf(\"running scanning command %v: %w\", resolvedCommand, err)\n\t\t\t}\n\t\t}\n\t\t// Produce the combined output files that we need to create, if there are any.\n\t\tvar sbomResult, purlResult string\n\t\tswitch {\n\t\tcase scanSpec.ImageSBOMOutput != \"\":\n\t\t\tsbomResult = filepath.Join(scansDir, filepath.Base(scanSpec.ImageSBOMOutput))\n\t\tcase scanSpec.SBOMOutput != \"\":\n\t\t\tsbomResult = filepath.Join(scansDir, filepath.Base(scanSpec.SBOMOutput))\n\t\tdefault:\n\t\t\tsbomResult = filepath.Join(scansDir, \"sbom-result\")\n\t\t}\n\t\tswitch {\n\t\tcase scanSpec.ImagePURLOutput != \"\":\n\t\t\tpurlResult = filepath.Join(scansDir, filepath.Base(scanSpec.ImagePURLOutput))\n\t\tcase scanSpec.PURLOutput != \"\":\n\t\t\tpurlResult = filepath.Join(scansDir, filepath.Base(scanSpec.PURLOutput))\n\t\tdefault:\n\t\t\tpurlResult = filepath.Join(scansDir, \"purl-result\")\n\t\t}\n\t\tcopyFile := func(destination, source string) error {\n\t\t\tdst, err := os.Create(destination)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer dst.Close()\n\t\t\tsrc, err := os.Open(source)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer src.Close()\n\t\t\tif _, err = io.Copy(dst, src); err != nil {\n\t\t\t\treturn fmt.Errorf(\"copying %q to %q: %w\", source, destination, err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\terr = func() error {\n\t\t\tfor i := range resultFiles {\n\t\t\t\tthisResultFile := filepath.Join(scansDir, filepath.Base(resultFiles[i]))\n\t\t\t\tswitch i {\n\t\t\t\tcase 0:\n\t\t\t\t\t// Straight-up copy to create the first version of the final output.\n\t\t\t\t\tif err = copyFile(sbomResult, thisResultFile); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\t// This shouldn't change any contents, but lets us generate the purl file.\n\t\t\t\t\terr = sbom.Merge(scanSpec.MergeStrategy, thisResultFile, sbomResult, purlResult)\n\t\t\t\tdefault:\n\t\t\t\t\t// Hopefully we know how to merge information from the new one into the final output.\n\t\t\t\t\terr = sbom.Merge(scanSpec.MergeStrategy, sbomResult, thisResultFile, purlResult)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn err\n\t\t}()\n\t\tif err != nil {\n\t\t\treturn nil, nil, \"\", err\n\t\t}\n\t\t// If these files are supposed to be written to the local filesystem, add\n\t\t// their contents to the map of files we expect our caller to write.\n\t\tif scanSpec.SBOMOutput != \"\" || scanSpec.PURLOutput != \"\" {\n\t\t\tif localFiles == nil {\n\t\t\t\tlocalFiles = make(map[string]string)\n\t\t\t}\n\t\t\tif scanSpec.SBOMOutput != \"\" {\n\t\t\t\tlocalFiles[scanSpec.SBOMOutput] = sbomResult\n\t\t\t}\n\t\t\tif scanSpec.PURLOutput != \"\" {\n\t\t\t\tlocalFiles[scanSpec.PURLOutput] = purlResult\n\t\t\t}\n\t\t}\n\t\t// If these files are supposed to be written to the image, create a map of\n\t\t// their contents so that we can either create a layer diff for them (or\n\t\t// slipstream them into a squashed layer diff) later.\n\t\tif scanSpec.ImageSBOMOutput != \"\" || scanSpec.ImagePURLOutput != \"\" {\n\t\t\tif imageFiles == nil {\n\t\t\t\timageFiles = make(map[string]string)\n\t\t\t}\n\t\t\tif scanSpec.ImageSBOMOutput != \"\" {\n\t\t\t\timageFiles[scanSpec.ImageSBOMOutput] = sbomResult\n\t\t\t}\n\t\t\tif scanSpec.ImagePURLOutput != \"\" {\n\t\t\t\timageFiles[scanSpec.ImagePURLOutput] = purlResult\n\t\t\t}\n\t\t}\n\t}\n\treturn imageFiles, localFiles, scansDir, nil\n}\n"
        },
        {
          "name": "seccomp.go",
          "type": "blob",
          "size": 0.8818359375,
          "content": "//go:build seccomp && linux\n\npackage buildah\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/containers/common/pkg/seccomp\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n)\n\nfunc setupSeccomp(spec *specs.Spec, seccompProfilePath string) error {\n\tswitch seccompProfilePath {\n\tcase \"unconfined\":\n\t\tspec.Linux.Seccomp = nil\n\tcase \"\":\n\t\tseccompConfig, err := seccomp.GetDefaultProfile(spec)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"loading default seccomp profile failed: %w\", err)\n\t\t}\n\t\tspec.Linux.Seccomp = seccompConfig\n\tdefault:\n\t\tseccompProfile, err := os.ReadFile(seccompProfilePath)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"opening seccomp profile failed: %w\", err)\n\t\t}\n\t\tseccompConfig, err := seccomp.LoadProfile(string(seccompProfile), spec)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"loading seccomp profile (%s) failed: %w\", seccompProfilePath, err)\n\t\t}\n\t\tspec.Linux.Seccomp = seccompConfig\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "seccomp_unsupported.go",
          "type": "blob",
          "size": 0.3046875,
          "content": "//go:build !seccomp || !linux\n\npackage buildah\n\nimport (\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n)\n\nfunc setupSeccomp(spec *specs.Spec, seccompProfilePath string) error {\n\tif spec.Linux != nil {\n\t\t// runtime-tools may have supplied us with a default filter\n\t\tspec.Linux.Seccomp = nil\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "selinux.go",
          "type": "blob",
          "size": 1.1513671875,
          "content": "//go:build linux\n\npackage buildah\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/opencontainers/runtime-tools/generate\"\n\tselinux \"github.com/opencontainers/selinux/go-selinux\"\n)\n\nfunc selinuxGetEnabled() bool {\n\treturn selinux.GetEnabled()\n}\n\nfunc setupSelinux(g *generate.Generator, processLabel, mountLabel string) {\n\tif processLabel != \"\" && selinux.GetEnabled() {\n\t\tg.SetProcessSelinuxLabel(processLabel)\n\t\tg.SetLinuxMountLabel(mountLabel)\n\t}\n}\n\nfunc runLabelStdioPipes(stdioPipe [][]int, processLabel, mountLabel string) error {\n\tif !selinuxGetEnabled() || processLabel == \"\" || mountLabel == \"\" {\n\t\t// SELinux is completely disabled, or we're not doing anything at all with labeling\n\t\treturn nil\n\t}\n\tpipeContext, err := selinux.ComputeCreateContext(processLabel, mountLabel, \"fifo_file\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"computing file creation context for pipes: %w\", err)\n\t}\n\tfor i := range stdioPipe {\n\t\tpipeFdName := fmt.Sprintf(\"/proc/self/fd/%d\", stdioPipe[i][0])\n\t\tif err := selinux.SetFileLabel(pipeFdName, pipeContext); err != nil && !errors.Is(err, os.ErrNotExist) {\n\t\t\treturn fmt.Errorf(\"setting file label on %q: %w\", pipeFdName, err)\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "selinux_unsupported.go",
          "type": "blob",
          "size": 0.318359375,
          "content": "//go:build !linux\n\npackage buildah\n\nimport (\n\t\"github.com/opencontainers/runtime-tools/generate\"\n)\n\nfunc selinuxGetEnabled() bool {\n\treturn false\n}\n\nfunc setupSelinux(g *generate.Generator, processLabel, mountLabel string) {\n}\n\nfunc runLabelStdioPipes(stdioPipe [][]int, processLabel, mountLabel string) error {\n\treturn nil\n}\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "troubleshooting.md",
          "type": "blob",
          "size": 7.6650390625,
          "content": "![buildah logo](https://cdn.rawgit.com/containers/buildah/main/logos/buildah-logo_large.png)\n\n# Troubleshooting\n\n## A list of common issues and solutions for Buildah\n\n---\n### 1) No such image\n\nWhen doing a `buildah pull` or `buildah build` command and a \"common\" image can not be pulled,\nit is likely that the `/etc/containers/registries.conf` file is either not installed or possibly\nmisconfigured.  This issue might also indicate that other required files as listed in the\n[Configuration Files](https://github.com/containers/buildah/blob/main/install.md#configuration-files)\nsection of the Installation Instructions are also not installed.\n\n#### Symptom\n```console\n$ sudo buildah build -f Dockerfile .\nSTEP 1: FROM alpine\nerror creating build container: 2 errors occurred:\n\n* Error determining manifest MIME type for docker://localhost/alpine:latest: pinging docker registry returned: Get https://localhost/v2/: dial tcp [::1]:443: connect: connection refused\n* Error determining manifest MIME type for docker://registry.access.redhat.com/alpine:latest: Error reading manifest latest in registry.access.redhat.com/alpine: unknown: Not Found\nerror building: error creating build container: no such image \"alpine\" in registry: image not known\n```\n\n#### Solution\n\n  * Verify that the `/etc/containers/registries.conf` file exists.  If not, verify that the containers-common package is installed.\n  * Verify that the entries in the `[registries.search]` section of the /etc/containers/registries file are valid and reachable.\n  * Verify that the image you requested is either fully qualified, or that it exists on one of your search registries.\n  * Verify that the image is public or that you have logged in to at least one search registry which contains the private image.\n  * Verify that the other required [Configuration Files](https://github.com/containers/buildah/blob/main/install.md#configuration-files) are installed.\n\n---\n### 2) http: server gave HTTP response to HTTPS client\n\nWhen doing a Buildah command such as `build`, `commit`, `from`, or `push` to a registry,\ntls verification is turned on by default.  If authentication is not used with\nthose commands, this error can occur.\n\n#### Symptom\n```console\n# buildah push alpine docker://localhost:5000/myalpine:latest\nGetting image source signatures\nGet https://localhost:5000/v2/: http: server gave HTTP response to HTTPS client\n```\n\n#### Solution\n\nBy default tls verification is turned on when communicating to registries from\nBuildah.  If the registry does not require authentication the Buildah commands\nsuch as `build`, `commit`, `from` and `pull` will fail unless tls verification is turned\noff using the `--tls-verify` option.  **NOTE:** It is not at all recommended to\ncommunicate with a registry and not use tls verification.\n\n  * Turn off tls verification by passing false to the tls-verification option.\n  * I.e. `buildah push --tls-verify=false alpine docker://localhost:5000/myalpine:latest`\n\n---\n### 3) `buildah run` command fails with pipe or output redirection\n\nWhen doing a `buildah run` command while using a pipe ('|') or output redirection ('>>'),\nthe command will fail, often times with a `command not found` type of error.\n\n#### Symptom\nWhen executing a `buildah run` command with a pipe or output redirection such as the\nfollowing commands:\n\n```console\n# buildah run $whalecontainer /usr/games/fortune -a | cowsay\n# buildah run $newcontainer echo \"daemon off;\" >> /etc/nginx/nginx.conf\n# buildah run $newcontainer echo \"nginx on Fedora\" > /usr/share/nginx/html/index.html\n```\nthe `buildah run` command will not complete and an error will be raised.\n\n#### Solution\nThere are two solutions to this problem.  The\n[`podman run`](https://github.com/containers/podman/blob/main/docs/podman-run.1.md)\ncommand can be used in place of `buildah run`.  To still use `buildah run`, surround\nthe command with single quotes and use `bash -c`.  The previous examples would be\nchanged to:\n\n```console\n# buildah run $whalecontainer bash -c '/usr/games/fortune -a | cowsay'\n# buildah run $newcontainer bash -c 'echo \"daemon off;\" >> /etc/nginx/nginx.conf'\n# buildah run $newcontainer bash -c 'echo \"nginx on Fedora\" > /usr/share/nginx/html/index.html'\n```\n\n---\n### 4) `buildah push alpine oci:~/myalpine:latest` fails with lstat error\n\nWhen doing a `buildah push` command and the target image has a tilde (`~`) character\nin it, an lstat error will be raised stating there is no such file or directory.\nThis is expected behavior for shell expansion of the tilde character as it is only\nexpanded at the start of a word.  This behavior is documented\n[here](https://www.gnu.org/software/libc/manual/html_node/Tilde-Expansion.html).\n\n#### Symptom\n```console\n$ sudo pull alpine\n$ sudo buildah push alpine oci:~/myalpine:latest\nlstat /home/myusername/~: no such file or directory\n```\n\n#### Solution\n\n  * Replace `~` with `$HOME` or the fully specified directory `/home/myusername`.\n    * `$ sudo buildah push alpine oci:${HOME}/myalpine:latest`\n\n\n---\n### 5) Rootless buildah build fails EPERM on NFS:\n\nNFS enforces file creation on different UIDs on the server side and does not understand user namespace, which rootless Podman requires.  When a container root process like YUM attempts to create a file owned by a different UID, NFS Server denies the creation.  NFS is also a problem for the file locks when the storage is on it.  Other distributed file systems (for example: Lustre, Spectrum Scale, the General Parallel File System (GPFS)) are also not supported when running in rootless mode as these file systems do not understand user namespace.\n\n#### Symptom\n```console\n$ buildah build .\nERRO[0014] Error while applying layer: ApplyLayer exit status 1 stdout:  stderr: open /root/.bash_logout: permission denied\nerror creating build container: Error committing the finished image: error adding layer with blob \"sha256:a02a4930cb5d36f3290eb84f4bfa30668ef2e9fe3a1fb73ec015fc58b9958b17\": ApplyLayer exit status 1 stdout:  stderr: open /root/.bash_logout: permission denied\n```\n\n#### Solution\nChoose one of the following:\n  * Setup containers/storage in a different directory, not on an NFS share.\n  * Otherwise just run buildah as root, via `sudo buildah`\n---\n### 6) Rootless buildah build fails when using OverlayFS:\n\nThe Overlay file system (OverlayFS) requires the ability to call the `mknod` command when creating whiteout files\nwhen extracting an image.  However, a rootless user does not have the privileges to use `mknod` in this capacity.\n\n#### Symptom\n```console\nbuildah build --storage-driver overlay .\nSTEP 1: FROM docker.io/ubuntu:xenial\nGetting image source signatures\nCopying blob edf72af6d627 done\nCopying blob 3e4f86211d23 done\nCopying blob 8d3eac894db4 done\nCopying blob f7277927d38a done\nCopying config 5e13f8dd4c done\nWriting manifest to image destination\nStoring signatures\nError: error creating build container: Error committing the finished image: error adding layer with blob \"sha256:8d3eac894db4dc4154377ad28643dfe6625ff0e54bcfa63e0d04921f1a8ef7f8\": Error processing tar file(exit status 1): operation not permitted\n$ buildah build .\nERRO[0014] Error while applying layer: ApplyLayer exit status 1 stdout:  stderr: open /root/.bash_logout: permission denied\nerror creating build container: Error committing the finished image: error adding layer with blob \"sha256:a02a4930cb5d36f3290eb84f4bfa30668ef2e9fe3a1fb73ec015fc58b9958b17\": ApplyLayer exit status 1 stdout:  stderr: open /root/.bash_logout: permission denied\n```\n\n#### Solution\nChoose one of the following:\n  * Complete the build operation as a privileged user.\n  * Install and configure fuse-overlayfs.\n    * Install the fuse-overlayfs package for your Linux Distribution.\n    * Add `mount_program = \"/usr/bin/fuse-overlayfs\"` under `[storage.options]` in your `~/.config/containers/storage.conf` file.\n---\n"
        },
        {
          "name": "unmount.go",
          "type": "blob",
          "size": 0.40234375,
          "content": "package buildah\n\nimport \"fmt\"\n\n// Unmount unmounts a build container.\nfunc (b *Builder) Unmount() error {\n\t_, err := b.store.Unmount(b.ContainerID, false)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unmounting build container %q: %w\", b.ContainerID, err)\n\t}\n\tb.MountPoint = \"\"\n\terr = b.Save()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"saving updated state for build container %q: %w\", b.ContainerID, err)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 6.1943359375,
          "content": "package buildah\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync\"\n\n\t\"github.com/containers/buildah/copier\"\n\t\"github.com/containers/image/v5/docker/reference\"\n\t\"github.com/containers/image/v5/pkg/sysregistriesv2\"\n\t\"github.com/containers/image/v5/types\"\n\t\"github.com/containers/storage\"\n\t\"github.com/containers/storage/pkg/idtools\"\n\t\"github.com/containers/storage/pkg/reexec\"\n\tv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n\trspec \"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/selinux/go-selinux/label\"\n\t\"github.com/sirupsen/logrus\"\n)\n\n// InitReexec is a wrapper for reexec.Init().  It should be called at\n// the start of main(), and if it returns true, main() should return\n// immediately.\nfunc InitReexec() bool {\n\treturn reexec.Init()\n}\n\nfunc copyHistory(history []v1.History) []v1.History {\n\tif len(history) == 0 {\n\t\treturn nil\n\t}\n\th := make([]v1.History, 0, len(history))\n\tfor _, entry := range history {\n\t\tcreated := entry.Created\n\t\tif created != nil {\n\t\t\ttimestamp := *created\n\t\t\tcreated = &timestamp\n\t\t}\n\t\th = append(h, v1.History{\n\t\t\tCreated:    created,\n\t\t\tCreatedBy:  entry.CreatedBy,\n\t\t\tAuthor:     entry.Author,\n\t\t\tComment:    entry.Comment,\n\t\t\tEmptyLayer: entry.EmptyLayer,\n\t\t})\n\t}\n\treturn h\n}\n\nfunc convertStorageIDMaps(UIDMap, GIDMap []idtools.IDMap) ([]rspec.LinuxIDMapping, []rspec.LinuxIDMapping) {\n\tuidmap := make([]rspec.LinuxIDMapping, 0, len(UIDMap))\n\tgidmap := make([]rspec.LinuxIDMapping, 0, len(GIDMap))\n\tfor _, m := range UIDMap {\n\t\tuidmap = append(uidmap, rspec.LinuxIDMapping{\n\t\t\tHostID:      uint32(m.HostID),\n\t\t\tContainerID: uint32(m.ContainerID),\n\t\t\tSize:        uint32(m.Size),\n\t\t})\n\t}\n\tfor _, m := range GIDMap {\n\t\tgidmap = append(gidmap, rspec.LinuxIDMapping{\n\t\t\tHostID:      uint32(m.HostID),\n\t\t\tContainerID: uint32(m.ContainerID),\n\t\t\tSize:        uint32(m.Size),\n\t\t})\n\t}\n\treturn uidmap, gidmap\n}\n\nfunc convertRuntimeIDMaps(UIDMap, GIDMap []rspec.LinuxIDMapping) ([]idtools.IDMap, []idtools.IDMap) {\n\tuidmap := make([]idtools.IDMap, 0, len(UIDMap))\n\tgidmap := make([]idtools.IDMap, 0, len(GIDMap))\n\tfor _, m := range UIDMap {\n\t\tuidmap = append(uidmap, idtools.IDMap{\n\t\t\tHostID:      int(m.HostID),\n\t\t\tContainerID: int(m.ContainerID),\n\t\t\tSize:        int(m.Size),\n\t\t})\n\t}\n\tfor _, m := range GIDMap {\n\t\tgidmap = append(gidmap, idtools.IDMap{\n\t\t\tHostID:      int(m.HostID),\n\t\t\tContainerID: int(m.ContainerID),\n\t\t\tSize:        int(m.Size),\n\t\t})\n\t}\n\treturn uidmap, gidmap\n}\n\n// isRegistryBlocked checks if the named registry is marked as blocked\nfunc isRegistryBlocked(registry string, sc *types.SystemContext) (bool, error) {\n\treginfo, err := sysregistriesv2.FindRegistry(sc, registry)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"unable to parse the registries configuration (%s): %w\", sysregistriesv2.ConfigPath(sc), err)\n\t}\n\tif reginfo != nil {\n\t\tif reginfo.Blocked {\n\t\t\tlogrus.Debugf(\"registry %q is marked as blocked in registries configuration %q\", registry, sysregistriesv2.ConfigPath(sc))\n\t\t} else {\n\t\t\tlogrus.Debugf(\"registry %q is not marked as blocked in registries configuration %q\", registry, sysregistriesv2.ConfigPath(sc))\n\t\t}\n\t\treturn reginfo.Blocked, nil\n\t}\n\tlogrus.Debugf(\"registry %q is not listed in registries configuration %q, assuming it's not blocked\", registry, sysregistriesv2.ConfigPath(sc))\n\treturn false, nil\n}\n\n// isReferenceSomething checks if the registry part of a reference is insecure or blocked\nfunc isReferenceSomething(ref types.ImageReference, sc *types.SystemContext, what func(string, *types.SystemContext) (bool, error)) (bool, error) {\n\tif ref != nil {\n\t\tif named := ref.DockerReference(); named != nil {\n\t\t\tif domain := reference.Domain(named); domain != \"\" {\n\t\t\t\treturn what(domain, sc)\n\t\t\t}\n\t\t}\n\t}\n\treturn false, nil\n}\n\n// isReferenceBlocked checks if the registry part of a reference is blocked\nfunc isReferenceBlocked(ref types.ImageReference, sc *types.SystemContext) (bool, error) {\n\tif ref != nil && ref.Transport() != nil {\n\t\tswitch ref.Transport().Name() {\n\t\tcase \"docker\":\n\t\t\treturn isReferenceSomething(ref, sc, isRegistryBlocked)\n\t\t}\n\t}\n\treturn false, nil\n}\n\n// ReserveSELinuxLabels reads containers storage and reserves SELinux contexts\n// which are already being used by buildah containers.\nfunc ReserveSELinuxLabels(store storage.Store, id string) error {\n\tif selinuxGetEnabled() {\n\t\tcontainers, err := store.Containers()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"getting list of containers: %w\", err)\n\t\t}\n\n\t\tfor _, c := range containers {\n\t\t\tif id == c.ID {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tb, err := OpenBuilder(store, c.ID)\n\t\t\tif err != nil {\n\t\t\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\t\t\t// Ignore not exist errors since containers probably created by other tool\n\t\t\t\t\t// TODO, we need to read other containers json data to reserve their SELinux labels\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// Prevent different containers from using same MCS label\n\t\t\tif err := label.ReserveLabel(b.ProcessLabel); err != nil {\n\t\t\t\treturn fmt.Errorf(\"reserving SELinux label %q: %w\", b.ProcessLabel, err)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// IsContainer identifies if the specified container id is a buildah container\n// in the specified store.\nfunc IsContainer(id string, store storage.Store) (bool, error) {\n\tcdir, err := store.ContainerDirectory(id)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\t// Assuming that if the stateFile exists, that this is a Buildah\n\t// container.\n\tif _, err = os.Stat(filepath.Join(cdir, stateFile)); err != nil {\n\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\treturn false, nil\n\t\t}\n\t\treturn false, err\n\t}\n\treturn true, nil\n}\n\n// Copy content from the directory \"src\" to the directory \"dest\", ensuring that\n// content from outside of \"root\" (which is a parent of \"src\" or \"src\" itself)\n// isn't read.\nfunc extractWithTar(root, src, dest string) error {\n\tvar getErr, putErr error\n\tvar wg sync.WaitGroup\n\n\tpipeReader, pipeWriter := io.Pipe()\n\n\twg.Add(1)\n\tgo func() {\n\t\tgetErr = copier.Get(root, src, copier.GetOptions{}, []string{\".\"}, pipeWriter)\n\t\tpipeWriter.Close()\n\t\twg.Done()\n\t}()\n\twg.Add(1)\n\tgo func() {\n\t\tputErr = copier.Put(dest, dest, copier.PutOptions{}, pipeReader)\n\t\tpipeReader.Close()\n\t\twg.Done()\n\t}()\n\twg.Wait()\n\n\tif getErr != nil {\n\t\treturn fmt.Errorf(\"reading %q: %w\", src, getErr)\n\t}\n\tif putErr != nil {\n\t\treturn fmt.Errorf(\"copying contents of %q to %q: %w\", src, dest, putErr)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}