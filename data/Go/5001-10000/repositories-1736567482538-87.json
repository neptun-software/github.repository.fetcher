{
  "metadata": {
    "timestamp": 1736567482538,
    "page": 87,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "charmbracelet/lipgloss",
      "stars": 8416,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0263671875,
          "content": "ssh_example_ed25519*\ndist/\n"
        },
        {
          "name": ".golangci-soft.yml",
          "type": "blob",
          "size": 0.57421875,
          "content": "run:\n  tests: false\n  issues-exit-code: 0\n\nissues:\n  include:\n    - EXC0001\n    - EXC0005\n    - EXC0011\n    - EXC0012\n    - EXC0013\n\n  max-issues-per-linter: 0\n  max-same-issues: 0\n\nlinters:\n  enable:\n    - exhaustive\n    - goconst\n    - godot\n    - godox\n    - mnd\n    - gomoddirectives\n    - goprintffuncname\n    - misspell\n    - nakedret\n    - nestif\n    - noctx\n    - nolintlint\n    - prealloc\n    - wrapcheck\n\n  # disable default linters, they are already enabled in .golangci.yml\n  disable:\n    - errcheck\n    - gosimple\n    - govet\n    - ineffassign\n    - staticcheck\n    - unused\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.3564453125,
          "content": "run:\n  tests: false\n\nissues:\n  include:\n    - EXC0001\n    - EXC0005\n    - EXC0011\n    - EXC0012\n    - EXC0013\n\n  max-issues-per-linter: 0\n  max-same-issues: 0\n\nlinters:\n  enable:\n    - bodyclose\n    - gofumpt\n    - goimports\n    - gosec\n    - nilerr\n    - revive\n    - rowserrcheck\n    - sqlclosecheck\n    - tparallel\n    - unconvert\n    - unparam\n    - whitespace\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 0.1640625,
          "content": "# yaml-language-server: $schema=https://goreleaser.com/static/schema-pro.json\nversion: 2\nincludes:\n  - from_url:\n      url: charmbracelet/meta/main/goreleaser-lib.yaml\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0546875,
          "content": "MIT License\n\nCopyright (c) 2021-2023 Charmbracelet, Inc\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 20.0634765625,
          "content": "# Lip Gloss\n\n<p>\n    <a href=\"https://stuff.charm.sh/lipgloss/lipgloss-mascot-2k.png\"><img width=\"340\" alt=\"Lip Gloss title treatment\" src=\"https://github.com/charmbracelet/lipgloss/assets/25087/147cadb1-4254-43ec-ae6b-8d6ca7b029a1\"></a><br>\n    <a href=\"https://github.com/charmbracelet/lipgloss/releases\"><img src=\"https://img.shields.io/github/release/charmbracelet/lipgloss.svg\" alt=\"Latest Release\"></a>\n    <a href=\"https://pkg.go.dev/github.com/charmbracelet/lipgloss?tab=doc\"><img src=\"https://godoc.org/github.com/golang/gddo?status.svg\" alt=\"GoDoc\"></a>\n    <a href=\"https://github.com/charmbracelet/lipgloss/actions\"><img src=\"https://github.com/charmbracelet/lipgloss/workflows/build/badge.svg\" alt=\"Build Status\"></a>\n    <a href=\"https://www.phorm.ai/query?projectId=a0e324b6-b706-4546-b951-6671ea60c13f\"><img src=\"https://stuff.charm.sh/misc/phorm-badge.svg\" alt=\"phorm.ai\"></a>\n</p>\n\nStyle definitions for nice terminal layouts. Built with TUIs in mind.\n\n![Lip Gloss example](https://github.com/user-attachments/assets/7950b1c1-e0e3-427e-8e7d-6f7f6ad17ca7)\n\nLip Gloss takes an expressive, declarative approach to terminal rendering.\nUsers familiar with CSS will feel at home with Lip Gloss.\n\n```go\n\nimport \"github.com/charmbracelet/lipgloss\"\n\nvar style = lipgloss.NewStyle().\n    Bold(true).\n    Foreground(lipgloss.Color(\"#FAFAFA\")).\n    Background(lipgloss.Color(\"#7D56F4\")).\n    PaddingTop(2).\n    PaddingLeft(4).\n    Width(22)\n\nfmt.Println(style.Render(\"Hello, kitty\"))\n```\n\n## Colors\n\nLip Gloss supports the following color profiles:\n\n### ANSI 16 colors (4-bit)\n\n```go\nlipgloss.Color(\"5\")  // magenta\nlipgloss.Color(\"9\")  // red\nlipgloss.Color(\"12\") // light blue\n```\n\n### ANSI 256 Colors (8-bit)\n\n```go\nlipgloss.Color(\"86\")  // aqua\nlipgloss.Color(\"201\") // hot pink\nlipgloss.Color(\"202\") // orange\n```\n\n### True Color (16,777,216 colors; 24-bit)\n\n```go\nlipgloss.Color(\"#0000FF\") // good ol' 100% blue\nlipgloss.Color(\"#04B575\") // a green\nlipgloss.Color(\"#3C3C3C\") // a dark gray\n```\n\n...as well as a 1-bit ASCII profile, which is black and white only.\n\nThe terminal's color profile will be automatically detected, and colors outside\nthe gamut of the current palette will be automatically coerced to their closest\navailable value.\n\n### Adaptive Colors\n\nYou can also specify color options for light and dark backgrounds:\n\n```go\nlipgloss.AdaptiveColor{Light: \"236\", Dark: \"248\"}\n```\n\nThe terminal's background color will automatically be detected and the\nappropriate color will be chosen at runtime.\n\n### Complete Colors\n\nCompleteColor specifies exact values for True Color, ANSI256, and ANSI color\nprofiles.\n\n```go\nlipgloss.CompleteColor{TrueColor: \"#0000FF\", ANSI256: \"86\", ANSI: \"5\"}\n```\n\nAutomatic color degradation will not be performed in this case and it will be\nbased on the color specified.\n\n### Complete Adaptive Colors\n\nYou can use `CompleteColor` with `AdaptiveColor` to specify the exact values for\nlight and dark backgrounds without automatic color degradation.\n\n```go\nlipgloss.CompleteAdaptiveColor{\n    Light: CompleteColor{TrueColor: \"#d7ffae\", ANSI256: \"193\", ANSI: \"11\"},\n    Dark:  CompleteColor{TrueColor: \"#d75fee\", ANSI256: \"163\", ANSI: \"5\"},\n}\n```\n\n## Inline Formatting\n\nLip Gloss supports the usual ANSI text formatting options:\n\n```go\nvar style = lipgloss.NewStyle().\n    Bold(true).\n    Italic(true).\n    Faint(true).\n    Blink(true).\n    Strikethrough(true).\n    Underline(true).\n    Reverse(true)\n```\n\n## Block-Level Formatting\n\nLip Gloss also supports rules for block-level formatting:\n\n```go\n// Padding\nvar style = lipgloss.NewStyle().\n    PaddingTop(2).\n    PaddingRight(4).\n    PaddingBottom(2).\n    PaddingLeft(4)\n\n// Margins\nvar style = lipgloss.NewStyle().\n    MarginTop(2).\n    MarginRight(4).\n    MarginBottom(2).\n    MarginLeft(4)\n```\n\nThere is also shorthand syntax for margins and padding, which follows the same\nformat as CSS:\n\n```go\n// 2 cells on all sides\nlipgloss.NewStyle().Padding(2)\n\n// 2 cells on the top and bottom, 4 cells on the left and right\nlipgloss.NewStyle().Margin(2, 4)\n\n// 1 cell on the top, 4 cells on the sides, 2 cells on the bottom\nlipgloss.NewStyle().Padding(1, 4, 2)\n\n// Clockwise, starting from the top: 2 cells on the top, 4 on the right, 3 on\n// the bottom, and 1 on the left\nlipgloss.NewStyle().Margin(2, 4, 3, 1)\n```\n\n## Aligning Text\n\nYou can align paragraphs of text to the left, right, or center.\n\n```go\nvar style = lipgloss.NewStyle().\n    Width(24).\n    Align(lipgloss.Left).  // align it left\n    Align(lipgloss.Right). // no wait, align it right\n    Align(lipgloss.Center) // just kidding, align it in the center\n```\n\n## Width and Height\n\nSetting a minimum width and height is simple and straightforward.\n\n```go\nvar style = lipgloss.NewStyle().\n    SetString(\"What’s for lunch?\").\n    Width(24).\n    Height(32).\n    Foreground(lipgloss.Color(\"63\"))\n```\n\n## Borders\n\nAdding borders is easy:\n\n```go\n// Add a purple, rectangular border\nvar style = lipgloss.NewStyle().\n    BorderStyle(lipgloss.NormalBorder()).\n    BorderForeground(lipgloss.Color(\"63\"))\n\n// Set a rounded, yellow-on-purple border to the top and left\nvar anotherStyle = lipgloss.NewStyle().\n    BorderStyle(lipgloss.RoundedBorder()).\n    BorderForeground(lipgloss.Color(\"228\")).\n    BorderBackground(lipgloss.Color(\"63\")).\n    BorderTop(true).\n    BorderLeft(true)\n\n// Make your own border\nvar myCuteBorder = lipgloss.Border{\n    Top:         \"._.:*:\",\n    Bottom:      \"._.:*:\",\n    Left:        \"|*\",\n    Right:       \"|*\",\n    TopLeft:     \"*\",\n    TopRight:    \"*\",\n    BottomLeft:  \"*\",\n    BottomRight: \"*\",\n}\n```\n\nThere are also shorthand functions for defining borders, which follow a similar\npattern to the margin and padding shorthand functions.\n\n```go\n// Add a thick border to the top and bottom\nlipgloss.NewStyle().\n    Border(lipgloss.ThickBorder(), true, false)\n\n// Add a double border to the top and left sides. Rules are set clockwise\n// from top.\nlipgloss.NewStyle().\n    Border(lipgloss.DoubleBorder(), true, false, false, true)\n```\n\nFor more on borders see [the docs][docs].\n\n## Copying Styles\n\nJust use assignment:\n\n```go\nstyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"219\"))\n\ncopiedStyle := style // this is a true copy\n\nwildStyle := style.Blink(true) // this is also true copy, with blink added\n\n```\n\nSince `Style` data structures contains only primitive types, assigning a style\nto another effectively creates a new copy of the style without mutating the\noriginal.\n\n## Inheritance\n\nStyles can inherit rules from other styles. When inheriting, only unset rules\non the receiver are inherited.\n\n```go\nvar styleA = lipgloss.NewStyle().\n    Foreground(lipgloss.Color(\"229\")).\n    Background(lipgloss.Color(\"63\"))\n\n// Only the background color will be inherited here, because the foreground\n// color will have been already set:\nvar styleB = lipgloss.NewStyle().\n    Foreground(lipgloss.Color(\"201\")).\n    Inherit(styleA)\n```\n\n## Unsetting Rules\n\nAll rules can be unset:\n\n```go\nvar style = lipgloss.NewStyle().\n    Bold(true).                        // make it bold\n    UnsetBold().                       // jk don't make it bold\n    Background(lipgloss.Color(\"227\")). // yellow background\n    UnsetBackground()                  // never mind\n```\n\nWhen a rule is unset, it won't be inherited or copied.\n\n## Enforcing Rules\n\nSometimes, such as when developing a component, you want to make sure style\ndefinitions respect their intended purpose in the UI. This is where `Inline`\nand `MaxWidth`, and `MaxHeight` come in:\n\n```go\n// Force rendering onto a single line, ignoring margins, padding, and borders.\nsomeStyle.Inline(true).Render(\"yadda yadda\")\n\n// Also limit rendering to five cells\nsomeStyle.Inline(true).MaxWidth(5).Render(\"yadda yadda\")\n\n// Limit rendering to a 5x5 cell block\nsomeStyle.MaxWidth(5).MaxHeight(5).Render(\"yadda yadda\")\n```\n\n## Tabs\n\nThe tab character (`\\t`) is rendered differently in different terminals (often\nas 8 spaces, sometimes 4). Because of this inconsistency, Lip Gloss converts\ntabs to 4 spaces at render time. This behavior can be changed on a per-style\nbasis, however:\n\n```go\nstyle := lipgloss.NewStyle() // tabs will render as 4 spaces, the default\nstyle = style.TabWidth(2)    // render tabs as 2 spaces\nstyle = style.TabWidth(0)    // remove tabs entirely\nstyle = style.TabWidth(lipgloss.NoTabConversion) // leave tabs intact\n```\n\n## Rendering\n\nGenerally, you just call the `Render(string...)` method on a `lipgloss.Style`:\n\n```go\nstyle := lipgloss.NewStyle().Bold(true).SetString(\"Hello,\")\nfmt.Println(style.Render(\"kitty.\")) // Hello, kitty.\nfmt.Println(style.Render(\"puppy.\")) // Hello, puppy.\n```\n\nBut you could also use the Stringer interface:\n\n```go\nvar style = lipgloss.NewStyle().SetString(\"你好，猫咪。\").Bold(true)\nfmt.Println(style) // 你好，猫咪。\n```\n\n### Custom Renderers\n\nCustom renderers allow you to render to a specific outputs. This is\nparticularly important when you want to render to different outputs and\ncorrectly detect the color profile and dark background status for each, such as\nin a server-client situation.\n\n```go\nfunc myLittleHandler(sess ssh.Session) {\n    // Create a renderer for the client.\n    renderer := lipgloss.NewRenderer(sess)\n\n    // Create a new style on the renderer.\n    style := renderer.NewStyle().Background(lipgloss.AdaptiveColor{Light: \"63\", Dark: \"228\"})\n\n    // Render. The color profile and dark background state will be correctly detected.\n    io.WriteString(sess, style.Render(\"Heyyyyyyy\"))\n}\n```\n\nFor an example on using a custom renderer over SSH with [Wish][wish] see the\n[SSH example][ssh-example].\n\n## Utilities\n\nIn addition to pure styling, Lip Gloss also ships with some utilities to help\nassemble your layouts.\n\n### Joining Paragraphs\n\nHorizontally and vertically joining paragraphs is a cinch.\n\n```go\n// Horizontally join three paragraphs along their bottom edges\nlipgloss.JoinHorizontal(lipgloss.Bottom, paragraphA, paragraphB, paragraphC)\n\n// Vertically join two paragraphs along their center axes\nlipgloss.JoinVertical(lipgloss.Center, paragraphA, paragraphB)\n\n// Horizontally join three paragraphs, with the shorter ones aligning 20%\n// from the top of the tallest\nlipgloss.JoinHorizontal(0.2, paragraphA, paragraphB, paragraphC)\n```\n\n### Measuring Width and Height\n\nSometimes you’ll want to know the width and height of text blocks when building\nyour layouts.\n\n```go\n// Render a block of text.\nvar style = lipgloss.NewStyle().\n    Width(40).\n    Padding(2)\nvar block string = style.Render(someLongString)\n\n// Get the actual, physical dimensions of the text block.\nwidth := lipgloss.Width(block)\nheight := lipgloss.Height(block)\n\n// Here's a shorthand function.\nw, h := lipgloss.Size(block)\n```\n\n### Placing Text in Whitespace\n\nSometimes you’ll simply want to place a block of text in whitespace.\n\n```go\n// Center a paragraph horizontally in a space 80 cells wide. The height of\n// the block returned will be as tall as the input paragraph.\nblock := lipgloss.PlaceHorizontal(80, lipgloss.Center, fancyStyledParagraph)\n\n// Place a paragraph at the bottom of a space 30 cells tall. The width of\n// the text block returned will be as wide as the input paragraph.\nblock := lipgloss.PlaceVertical(30, lipgloss.Bottom, fancyStyledParagraph)\n\n// Place a paragraph in the bottom right corner of a 30x80 cell space.\nblock := lipgloss.Place(30, 80, lipgloss.Right, lipgloss.Bottom, fancyStyledParagraph)\n```\n\nYou can also style the whitespace. For details, see [the docs][docs].\n\n## Rendering Tables\n\nLip Gloss ships with a table rendering sub-package.\n\n```go\nimport \"github.com/charmbracelet/lipgloss/table\"\n```\n\nDefine some rows of data.\n\n```go\nrows := [][]string{\n    {\"Chinese\", \"您好\", \"你好\"},\n    {\"Japanese\", \"こんにちは\", \"やあ\"},\n    {\"Arabic\", \"أهلين\", \"أهلا\"},\n    {\"Russian\", \"Здравствуйте\", \"Привет\"},\n    {\"Spanish\", \"Hola\", \"¿Qué tal?\"},\n}\n```\n\nUse the table package to style and render the table.\n\n```go\nt := table.New().\n    Border(lipgloss.NormalBorder()).\n    BorderStyle(lipgloss.NewStyle().Foreground(lipgloss.Color(\"99\"))).\n    StyleFunc(func(row, col int) lipgloss.Style {\n        switch {\n        case row == 0:\n            return HeaderStyle\n        case row%2 == 0:\n            return EvenRowStyle\n        default:\n            return OddRowStyle\n        }\n    }).\n    Headers(\"LANGUAGE\", \"FORMAL\", \"INFORMAL\").\n    Rows(rows...)\n\n// You can also add tables row-by-row\nt.Row(\"English\", \"You look absolutely fabulous.\", \"How's it going?\")\n```\n\nPrint the table.\n\n```go\nfmt.Println(t)\n```\n\n![Table Example](https://github.com/charmbracelet/lipgloss/assets/42545625/6e4b70c4-f494-45da-a467-bdd27df30d5d)\n\n> [!WARNING]\n> Table `Rows` need to be declared before `Offset` otherwise it does nothing.\n\nFor more on tables see [the docs](https://pkg.go.dev/github.com/charmbracelet/lipgloss?tab=doc) and [examples](https://github.com/charmbracelet/lipgloss/tree/master/examples/table).\n\n## Rendering Lists\n\nLip Gloss ships with a list rendering sub-package.\n\n```go\nimport \"github.com/charmbracelet/lipgloss/list\"\n```\n\nDefine a new list.\n\n```go\nl := list.New(\"A\", \"B\", \"C\")\n```\n\nPrint the list.\n\n```go\nfmt.Println(l)\n\n// • A\n// • B\n// • C\n```\n\nLists have the ability to nest.\n\n```go\nl := list.New(\n    \"A\", list.New(\"Artichoke\"),\n    \"B\", list.New(\"Baking Flour\", \"Bananas\", \"Barley\", \"Bean Sprouts\"),\n    \"C\", list.New(\"Cashew Apple\", \"Cashews\", \"Coconut Milk\", \"Curry Paste\", \"Currywurst\"),\n    \"D\", list.New(\"Dill\", \"Dragonfruit\", \"Dried Shrimp\"),\n    \"E\", list.New(\"Eggs\"),\n    \"F\", list.New(\"Fish Cake\", \"Furikake\"),\n    \"J\", list.New(\"Jicama\"),\n    \"K\", list.New(\"Kohlrabi\"),\n    \"L\", list.New(\"Leeks\", \"Lentils\", \"Licorice Root\"),\n)\n```\n\nPrint the list.\n\n```go\nfmt.Println(l)\n```\n\n<p align=\"center\">\n<img width=\"600\" alt=\"image\" src=\"https://github.com/charmbracelet/lipgloss/assets/42545625/0dc9f440-0748-4151-a3b0-7dcf29dfcdb0\">\n</p>\n\nLists can be customized via their enumeration function as well as using\n`lipgloss.Style`s.\n\n```go\nenumeratorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"99\")).MarginRight(1)\nitemStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"212\")).MarginRight(1)\n\nl := list.New(\n    \"Glossier\",\n    \"Claire’s Boutique\",\n    \"Nyx\",\n    \"Mac\",\n    \"Milk\",\n    ).\n    Enumerator(list.Roman).\n    EnumeratorStyle(enumeratorStyle).\n    ItemStyle(itemStyle)\n```\n\nPrint the list.\n\n<p align=\"center\">\n<img width=\"600\" alt=\"List example\" src=\"https://github.com/charmbracelet/lipgloss/assets/42545625/360494f1-57fb-4e13-bc19-0006efe01561\">\n</p>\n\nIn addition to the predefined enumerators (`Arabic`, `Alphabet`, `Roman`, `Bullet`, `Tree`),\nyou may also define your own custom enumerator:\n\n```go\nl := list.New(\"Duck\", \"Duck\", \"Duck\", \"Duck\", \"Goose\", \"Duck\", \"Duck\")\n\nfunc DuckDuckGooseEnumerator(l list.Items, i int) string {\n    if l.At(i).Value() == \"Goose\" {\n        return \"Honk →\"\n    }\n    return \"\"\n}\n\nl = l.Enumerator(DuckDuckGooseEnumerator)\n```\n\nPrint the list:\n\n<p align=\"center\">\n<img width=\"600\" alt=\"image\" src=\"https://github.com/charmbracelet/lipgloss/assets/42545625/157aaf30-140d-4948-9bb4-dfba46e5b87e\">\n</p>\n\nIf you need, you can also build lists incrementally:\n\n```go\nl := list.New()\n\nfor i := 0; i < repeat; i++ {\n    l.Item(\"Lip Gloss\")\n}\n```\n\n## Rendering Trees\n\nLip Gloss ships with a tree rendering sub-package.\n\n```go\nimport \"github.com/charmbracelet/lipgloss/tree\"\n```\n\nDefine a new tree.\n\n```go\nt := tree.Root(\".\").\n    Child(\"A\", \"B\", \"C\")\n```\n\nPrint the tree.\n\n```go\nfmt.Println(t)\n\n// .\n// ├── A\n// ├── B\n// └── C\n```\n\nTrees have the ability to nest.\n\n```go\nt := tree.Root(\".\").\n    Child(\"macOS\").\n    Child(\n        tree.New().\n            Root(\"Linux\").\n            Child(\"NixOS\").\n            Child(\"Arch Linux (btw)\").\n            Child(\"Void Linux\"),\n        ).\n    Child(\n        tree.New().\n            Root(\"BSD\").\n            Child(\"FreeBSD\").\n            Child(\"OpenBSD\"),\n    )\n```\n\nPrint the tree.\n\n```go\nfmt.Println(t)\n```\n\n<p align=\"center\">\n<img width=\"663\" alt=\"Tree Example (simple)\" src=\"https://github.com/user-attachments/assets/5ef14eb8-a5d4-4f94-8834-e15d1e714f89\">\n</p>\n\nTrees can be customized via their enumeration function as well as using\n`lipgloss.Style`s.\n\n```go\nenumeratorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"63\")).MarginRight(1)\nrootStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"35\"))\nitemStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"212\"))\n\nt := tree.\n    Root(\"⁜ Makeup\").\n    Child(\n        \"Glossier\",\n        \"Fenty Beauty\",\n        tree.New().Child(\n            \"Gloss Bomb Universal Lip Luminizer\",\n            \"Hot Cheeks Velour Blushlighter\",\n        ),\n        \"Nyx\",\n        \"Mac\",\n        \"Milk\",\n    ).\n    Enumerator(tree.RoundedEnumerator).\n    EnumeratorStyle(enumeratorStyle).\n    RootStyle(rootStyle).\n    ItemStyle(itemStyle)\n```\n\nPrint the tree.\n\n<p align=\"center\">\n<img width=\"663\" alt=\"Tree Example (makeup)\" src=\"https://github.com/user-attachments/assets/06d12d87-744a-4c89-bd98-45de9094a97e\">\n</p>\n\nThe predefined enumerators for trees are `DefaultEnumerator` and `RoundedEnumerator`.\n\nIf you need, you can also build trees incrementally:\n\n```go\nt := tree.New()\n\nfor i := 0; i < repeat; i++ {\n    t.Child(\"Lip Gloss\")\n}\n```\n\n---\n\n## FAQ\n\n<details>\n<summary>\nWhy are things misaligning? Why are borders at the wrong widths?\n</summary>\n<p>This is most likely due to your locale and encoding, particularly with\nregard to Chinese, Japanese, and Korean (for example, <code>zh_CN.UTF-8</code>\nor <code>ja_JP.UTF-8</code>). The most direct way to fix this is to set\n<code>RUNEWIDTH_EASTASIAN=0</code> in your environment.</p>\n\n<p>For details see <a href=\"https://github.com/charmbracelet/lipgloss/issues/40\">https://github.com/charmbracelet/lipgloss/issues/40.</a></p>\n</details>\n\n<details>\n<summary>\nWhy isn't Lip Gloss displaying colors?\n</summary>\n<p>Lip Gloss automatically degrades colors to the best available option in the\ngiven terminal, and if output's not a TTY it will remove color output entirely.\nThis is common when running tests, CI, or when piping output elsewhere.</p>\n\n<p>If necessary, you can force a color profile in your tests with\n<a href=\"https://pkg.go.dev/github.com/charmbracelet/lipgloss#SetColorProfile\"><code>SetColorProfile</code></a>.</p>\n\n```go\nimport (\n    \"github.com/charmbracelet/lipgloss\"\n    \"github.com/muesli/termenv\"\n)\n\nlipgloss.SetColorProfile(termenv.TrueColor)\n```\n\n_Note:_ this option limits the flexibility of your application and can cause\nANSI escape codes to be output in cases where that might not be desired. Take\ncareful note of your use case and environment before choosing to force a color\nprofile.\n\n</details>\n\n## What about [Bubble Tea][tea]?\n\nLip Gloss doesn’t replace Bubble Tea. Rather, it is an excellent Bubble Tea\ncompanion. It was designed to make assembling terminal user interface views as\nsimple and fun as possible so that you can focus on building your application\ninstead of concerning yourself with low-level layout details.\n\nIn simple terms, you can use Lip Gloss to help build your Bubble Tea views.\n\n[tea]: https://github.com/charmbracelet/tea\n\n## Under the Hood\n\nLip Gloss is built on the excellent [Termenv][termenv] and [Reflow][reflow]\nlibraries which deal with color and ANSI-aware text operations, respectively.\nFor many use cases Termenv and Reflow will be sufficient for your needs.\n\n[termenv]: https://github.com/muesli/termenv\n[reflow]: https://github.com/muesli/reflow\n\n## Rendering Markdown\n\nFor a more document-centric rendering solution with support for things like\nlists, tables, and syntax-highlighted code have a look at [Glamour][glamour],\nthe stylesheet-based Markdown renderer.\n\n[glamour]: https://github.com/charmbracelet/glamour\n\n## Contributing\n\nSee [contributing][contribute].\n\n[contribute]: https://github.com/charmbracelet/lipgloss/contribute\n\n## Feedback\n\nWe’d love to hear your thoughts on this project. Feel free to drop us a note!\n\n- [Twitter](https://twitter.com/charmcli)\n- [The Fediverse](https://mastodon.social/@charmcli)\n- [Discord](https://charm.sh/chat)\n\n## License\n\n[MIT](https://github.com/charmbracelet/lipgloss/raw/master/LICENSE)\n\n---\n\nPart of [Charm](https://charm.sh).\n\n<a href=\"https://charm.sh/\"><img alt=\"The Charm logo\" src=\"https://stuff.charm.sh/charm-badge.jpg\" width=\"400\"></a>\n\nCharm热爱开源 • Charm loves open source\n\n[docs]: https://pkg.go.dev/github.com/charmbracelet/lipgloss?tab=doc\n[wish]: https://github.com/charmbracelet/wish\n[ssh-example]: examples/ssh\n"
        },
        {
          "name": "align.go",
          "type": "blob",
          "size": 2.1435546875,
          "content": "package lipgloss\n\nimport (\n\t\"strings\"\n\n\t\"github.com/charmbracelet/x/ansi\"\n\t\"github.com/muesli/termenv\"\n)\n\n// Perform text alignment. If the string is multi-lined, we also make all lines\n// the same width by padding them with spaces. If a termenv style is passed,\n// use that to style the spaces added.\nfunc alignTextHorizontal(str string, pos Position, width int, style *termenv.Style) string {\n\tlines, widestLine := getLines(str)\n\tvar b strings.Builder\n\n\tfor i, l := range lines {\n\t\tlineWidth := ansi.StringWidth(l)\n\n\t\tshortAmount := widestLine - lineWidth                // difference from the widest line\n\t\tshortAmount += max(0, width-(shortAmount+lineWidth)) // difference from the total width, if set\n\n\t\tif shortAmount > 0 {\n\t\t\tswitch pos { //nolint:exhaustive\n\t\t\tcase Right:\n\t\t\t\ts := strings.Repeat(\" \", shortAmount)\n\t\t\t\tif style != nil {\n\t\t\t\t\ts = style.Styled(s)\n\t\t\t\t}\n\t\t\t\tl = s + l\n\t\t\tcase Center:\n\t\t\t\t// Note: remainder goes on the right.\n\t\t\t\tleft := shortAmount / 2       //nolint:gomnd\n\t\t\t\tright := left + shortAmount%2 //nolint:gomnd\n\n\t\t\t\tleftSpaces := strings.Repeat(\" \", left)\n\t\t\t\trightSpaces := strings.Repeat(\" \", right)\n\n\t\t\t\tif style != nil {\n\t\t\t\t\tleftSpaces = style.Styled(leftSpaces)\n\t\t\t\t\trightSpaces = style.Styled(rightSpaces)\n\t\t\t\t}\n\t\t\t\tl = leftSpaces + l + rightSpaces\n\t\t\tdefault: // Left\n\t\t\t\ts := strings.Repeat(\" \", shortAmount)\n\t\t\t\tif style != nil {\n\t\t\t\t\ts = style.Styled(s)\n\t\t\t\t}\n\t\t\t\tl += s\n\t\t\t}\n\t\t}\n\n\t\tb.WriteString(l)\n\t\tif i < len(lines)-1 {\n\t\t\tb.WriteRune('\\n')\n\t\t}\n\t}\n\n\treturn b.String()\n}\n\nfunc alignTextVertical(str string, pos Position, height int, _ *termenv.Style) string {\n\tstrHeight := strings.Count(str, \"\\n\") + 1\n\tif height < strHeight {\n\t\treturn str\n\t}\n\n\tswitch pos {\n\tcase Top:\n\t\treturn str + strings.Repeat(\"\\n\", height-strHeight)\n\tcase Center:\n\t\ttopPadding, bottomPadding := (height-strHeight)/2, (height-strHeight)/2 //nolint:gomnd\n\t\tif strHeight+topPadding+bottomPadding > height {\n\t\t\ttopPadding--\n\t\t} else if strHeight+topPadding+bottomPadding < height {\n\t\t\tbottomPadding++\n\t\t}\n\t\treturn strings.Repeat(\"\\n\", topPadding) + str + strings.Repeat(\"\\n\", bottomPadding)\n\tcase Bottom:\n\t\treturn strings.Repeat(\"\\n\", height-strHeight) + str\n\t}\n\treturn str\n}\n"
        },
        {
          "name": "align_test.go",
          "type": "blob",
          "size": 1.5185546875,
          "content": "package lipgloss\n\nimport \"testing\"\n\nfunc TestAlignTextVertical(t *testing.T) {\n\ttests := []struct {\n\t\tstr    string\n\t\tpos    Position\n\t\theight int\n\t\twant   string\n\t}{\n\t\t{str: \"Foo\", pos: Top, height: 2, want: \"Foo\\n\"},\n\t\t{str: \"Foo\", pos: Center, height: 5, want: \"\\n\\nFoo\\n\\n\"},\n\t\t{str: \"Foo\", pos: Bottom, height: 5, want: \"\\n\\n\\n\\nFoo\"},\n\n\t\t{str: \"Foo\\nBar\", pos: Bottom, height: 5, want: \"\\n\\n\\nFoo\\nBar\"},\n\t\t{str: \"Foo\\nBar\", pos: Center, height: 5, want: \"\\nFoo\\nBar\\n\\n\"},\n\t\t{str: \"Foo\\nBar\", pos: Top, height: 5, want: \"Foo\\nBar\\n\\n\\n\"},\n\n\t\t{str: \"Foo\\nBar\\nBaz\", pos: Bottom, height: 5, want: \"\\n\\nFoo\\nBar\\nBaz\"},\n\t\t{str: \"Foo\\nBar\\nBaz\", pos: Center, height: 5, want: \"\\nFoo\\nBar\\nBaz\\n\"},\n\n\t\t{str: \"Foo\\nBar\\nBaz\", pos: Bottom, height: 3, want: \"Foo\\nBar\\nBaz\"},\n\t\t{str: \"Foo\\nBar\\nBaz\", pos: Center, height: 3, want: \"Foo\\nBar\\nBaz\"},\n\t\t{str: \"Foo\\nBar\\nBaz\", pos: Top, height: 3, want: \"Foo\\nBar\\nBaz\"},\n\n\t\t{str: \"Foo\\n\\n\\n\\nBar\", pos: Bottom, height: 5, want: \"Foo\\n\\n\\n\\nBar\"},\n\t\t{str: \"Foo\\n\\n\\n\\nBar\", pos: Center, height: 5, want: \"Foo\\n\\n\\n\\nBar\"},\n\t\t{str: \"Foo\\n\\n\\n\\nBar\", pos: Top, height: 5, want: \"Foo\\n\\n\\n\\nBar\"},\n\n\t\t{str: \"Foo\\nBar\\nBaz\", pos: Center, height: 9, want: \"\\n\\n\\nFoo\\nBar\\nBaz\\n\\n\\n\"},\n\t\t{str: \"Foo\\nBar\\nBaz\", pos: Center, height: 10, want: \"\\n\\n\\nFoo\\nBar\\nBaz\\n\\n\\n\\n\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := alignTextVertical(test.str, test.pos, test.height, nil)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"alignTextVertical(%q, %v, %d) = %q, want %q\", test.str, test.pos, test.height, got, test.want)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "ansi_unix.go",
          "type": "blob",
          "size": 0.142578125,
          "content": "//go:build !windows\n// +build !windows\n\npackage lipgloss\n\n// enableLegacyWindowsANSI is only needed on Windows.\nfunc enableLegacyWindowsANSI() {}\n"
        },
        {
          "name": "ansi_windows.go",
          "type": "blob",
          "size": 0.4736328125,
          "content": "//go:build windows\n// +build windows\n\npackage lipgloss\n\nimport (\n\t\"sync\"\n\n\t\"github.com/muesli/termenv\"\n)\n\nvar enableANSI sync.Once\n\n// enableANSIColors enables support for ANSI color sequences in the Windows\n// default console (cmd.exe and the PowerShell application). Note that this\n// only works with Windows 10. Also note that Windows Terminal supports colors\n// by default.\nfunc enableLegacyWindowsANSI() {\n\tenableANSI.Do(func() {\n\t\t_, _ = termenv.EnableWindowsANSIConsole()\n\t})\n}\n"
        },
        {
          "name": "borders.go",
          "type": "blob",
          "size": 9.9375,
          "content": "package lipgloss\n\nimport (\n\t\"strings\"\n\n\t\"github.com/charmbracelet/x/ansi\"\n\t\"github.com/muesli/termenv\"\n\t\"github.com/rivo/uniseg\"\n)\n\n// Border contains a series of values which comprise the various parts of a\n// border.\ntype Border struct {\n\tTop          string\n\tBottom       string\n\tLeft         string\n\tRight        string\n\tTopLeft      string\n\tTopRight     string\n\tBottomLeft   string\n\tBottomRight  string\n\tMiddleLeft   string\n\tMiddleRight  string\n\tMiddle       string\n\tMiddleTop    string\n\tMiddleBottom string\n}\n\n// GetTopSize returns the width of the top border. If borders contain runes of\n// varying widths, the widest rune is returned. If no border exists on the top\n// edge, 0 is returned.\nfunc (b Border) GetTopSize() int {\n\treturn getBorderEdgeWidth(b.TopLeft, b.Top, b.TopRight)\n}\n\n// GetRightSize returns the width of the right border. If borders contain\n// runes of varying widths, the widest rune is returned. If no border exists on\n// the right edge, 0 is returned.\nfunc (b Border) GetRightSize() int {\n\treturn getBorderEdgeWidth(b.TopRight, b.Right, b.BottomRight)\n}\n\n// GetBottomSize returns the width of the bottom border. If borders contain\n// runes of varying widths, the widest rune is returned. If no border exists on\n// the bottom edge, 0 is returned.\nfunc (b Border) GetBottomSize() int {\n\treturn getBorderEdgeWidth(b.BottomLeft, b.Bottom, b.BottomRight)\n}\n\n// GetLeftSize returns the width of the left border. If borders contain runes\n// of varying widths, the widest rune is returned. If no border exists on the\n// left edge, 0 is returned.\nfunc (b Border) GetLeftSize() int {\n\treturn getBorderEdgeWidth(b.TopLeft, b.Left, b.BottomLeft)\n}\n\nfunc getBorderEdgeWidth(borderParts ...string) (maxWidth int) {\n\tfor _, piece := range borderParts {\n\t\tw := maxRuneWidth(piece)\n\t\tif w > maxWidth {\n\t\t\tmaxWidth = w\n\t\t}\n\t}\n\treturn maxWidth\n}\n\nvar (\n\tnoBorder = Border{}\n\n\tnormalBorder = Border{\n\t\tTop:          \"─\",\n\t\tBottom:       \"─\",\n\t\tLeft:         \"│\",\n\t\tRight:        \"│\",\n\t\tTopLeft:      \"┌\",\n\t\tTopRight:     \"┐\",\n\t\tBottomLeft:   \"└\",\n\t\tBottomRight:  \"┘\",\n\t\tMiddleLeft:   \"├\",\n\t\tMiddleRight:  \"┤\",\n\t\tMiddle:       \"┼\",\n\t\tMiddleTop:    \"┬\",\n\t\tMiddleBottom: \"┴\",\n\t}\n\n\troundedBorder = Border{\n\t\tTop:          \"─\",\n\t\tBottom:       \"─\",\n\t\tLeft:         \"│\",\n\t\tRight:        \"│\",\n\t\tTopLeft:      \"╭\",\n\t\tTopRight:     \"╮\",\n\t\tBottomLeft:   \"╰\",\n\t\tBottomRight:  \"╯\",\n\t\tMiddleLeft:   \"├\",\n\t\tMiddleRight:  \"┤\",\n\t\tMiddle:       \"┼\",\n\t\tMiddleTop:    \"┬\",\n\t\tMiddleBottom: \"┴\",\n\t}\n\n\tblockBorder = Border{\n\t\tTop:         \"█\",\n\t\tBottom:      \"█\",\n\t\tLeft:        \"█\",\n\t\tRight:       \"█\",\n\t\tTopLeft:     \"█\",\n\t\tTopRight:    \"█\",\n\t\tBottomLeft:  \"█\",\n\t\tBottomRight: \"█\",\n\t}\n\n\touterHalfBlockBorder = Border{\n\t\tTop:         \"▀\",\n\t\tBottom:      \"▄\",\n\t\tLeft:        \"▌\",\n\t\tRight:       \"▐\",\n\t\tTopLeft:     \"▛\",\n\t\tTopRight:    \"▜\",\n\t\tBottomLeft:  \"▙\",\n\t\tBottomRight: \"▟\",\n\t}\n\n\tinnerHalfBlockBorder = Border{\n\t\tTop:         \"▄\",\n\t\tBottom:      \"▀\",\n\t\tLeft:        \"▐\",\n\t\tRight:       \"▌\",\n\t\tTopLeft:     \"▗\",\n\t\tTopRight:    \"▖\",\n\t\tBottomLeft:  \"▝\",\n\t\tBottomRight: \"▘\",\n\t}\n\n\tthickBorder = Border{\n\t\tTop:          \"━\",\n\t\tBottom:       \"━\",\n\t\tLeft:         \"┃\",\n\t\tRight:        \"┃\",\n\t\tTopLeft:      \"┏\",\n\t\tTopRight:     \"┓\",\n\t\tBottomLeft:   \"┗\",\n\t\tBottomRight:  \"┛\",\n\t\tMiddleLeft:   \"┣\",\n\t\tMiddleRight:  \"┫\",\n\t\tMiddle:       \"╋\",\n\t\tMiddleTop:    \"┳\",\n\t\tMiddleBottom: \"┻\",\n\t}\n\n\tdoubleBorder = Border{\n\t\tTop:          \"═\",\n\t\tBottom:       \"═\",\n\t\tLeft:         \"║\",\n\t\tRight:        \"║\",\n\t\tTopLeft:      \"╔\",\n\t\tTopRight:     \"╗\",\n\t\tBottomLeft:   \"╚\",\n\t\tBottomRight:  \"╝\",\n\t\tMiddleLeft:   \"╠\",\n\t\tMiddleRight:  \"╣\",\n\t\tMiddle:       \"╬\",\n\t\tMiddleTop:    \"╦\",\n\t\tMiddleBottom: \"╩\",\n\t}\n\n\thiddenBorder = Border{\n\t\tTop:          \" \",\n\t\tBottom:       \" \",\n\t\tLeft:         \" \",\n\t\tRight:        \" \",\n\t\tTopLeft:      \" \",\n\t\tTopRight:     \" \",\n\t\tBottomLeft:   \" \",\n\t\tBottomRight:  \" \",\n\t\tMiddleLeft:   \" \",\n\t\tMiddleRight:  \" \",\n\t\tMiddle:       \" \",\n\t\tMiddleTop:    \" \",\n\t\tMiddleBottom: \" \",\n\t}\n)\n\n// NormalBorder returns a standard-type border with a normal weight and 90\n// degree corners.\nfunc NormalBorder() Border {\n\treturn normalBorder\n}\n\n// RoundedBorder returns a border with rounded corners.\nfunc RoundedBorder() Border {\n\treturn roundedBorder\n}\n\n// BlockBorder returns a border that takes the whole block.\nfunc BlockBorder() Border {\n\treturn blockBorder\n}\n\n// OuterHalfBlockBorder returns a half-block border that sits outside the frame.\nfunc OuterHalfBlockBorder() Border {\n\treturn outerHalfBlockBorder\n}\n\n// InnerHalfBlockBorder returns a half-block border that sits inside the frame.\nfunc InnerHalfBlockBorder() Border {\n\treturn innerHalfBlockBorder\n}\n\n// ThickBorder returns a border that's thicker than the one returned by\n// NormalBorder.\nfunc ThickBorder() Border {\n\treturn thickBorder\n}\n\n// DoubleBorder returns a border comprised of two thin strokes.\nfunc DoubleBorder() Border {\n\treturn doubleBorder\n}\n\n// HiddenBorder returns a border that renders as a series of single-cell\n// spaces. It's useful for cases when you want to remove a standard border but\n// maintain layout positioning. This said, you can still apply a background\n// color to a hidden border.\nfunc HiddenBorder() Border {\n\treturn hiddenBorder\n}\n\nfunc (s Style) applyBorder(str string) string {\n\tvar (\n\t\tborder    = s.getBorderStyle()\n\t\thasTop    = s.getAsBool(borderTopKey, false)\n\t\thasRight  = s.getAsBool(borderRightKey, false)\n\t\thasBottom = s.getAsBool(borderBottomKey, false)\n\t\thasLeft   = s.getAsBool(borderLeftKey, false)\n\n\t\ttopFG    = s.getAsColor(borderTopForegroundKey)\n\t\trightFG  = s.getAsColor(borderRightForegroundKey)\n\t\tbottomFG = s.getAsColor(borderBottomForegroundKey)\n\t\tleftFG   = s.getAsColor(borderLeftForegroundKey)\n\n\t\ttopBG    = s.getAsColor(borderTopBackgroundKey)\n\t\trightBG  = s.getAsColor(borderRightBackgroundKey)\n\t\tbottomBG = s.getAsColor(borderBottomBackgroundKey)\n\t\tleftBG   = s.getAsColor(borderLeftBackgroundKey)\n\t)\n\n\t// If a border is set and no sides have been specifically turned on or off\n\t// render borders on all sides.\n\tif s.implicitBorders() {\n\t\thasTop = true\n\t\thasRight = true\n\t\thasBottom = true\n\t\thasLeft = true\n\t}\n\n\t// If no border is set or all borders are been disabled, abort.\n\tif border == noBorder || (!hasTop && !hasRight && !hasBottom && !hasLeft) {\n\t\treturn str\n\t}\n\n\tlines, width := getLines(str)\n\n\tif hasLeft {\n\t\tif border.Left == \"\" {\n\t\t\tborder.Left = \" \"\n\t\t}\n\t\twidth += maxRuneWidth(border.Left)\n\t}\n\n\tif hasRight && border.Right == \"\" {\n\t\tborder.Right = \" \"\n\t}\n\n\t// If corners should be rendered but are set with the empty string, fill them\n\t// with a single space.\n\tif hasTop && hasLeft && border.TopLeft == \"\" {\n\t\tborder.TopLeft = \" \"\n\t}\n\tif hasTop && hasRight && border.TopRight == \"\" {\n\t\tborder.TopRight = \" \"\n\t}\n\tif hasBottom && hasLeft && border.BottomLeft == \"\" {\n\t\tborder.BottomLeft = \" \"\n\t}\n\tif hasBottom && hasRight && border.BottomRight == \"\" {\n\t\tborder.BottomRight = \" \"\n\t}\n\n\t// Figure out which corners we should actually be using based on which\n\t// sides are set to show.\n\tif hasTop {\n\t\tswitch {\n\t\tcase !hasLeft && !hasRight:\n\t\t\tborder.TopLeft = \"\"\n\t\t\tborder.TopRight = \"\"\n\t\tcase !hasLeft:\n\t\t\tborder.TopLeft = \"\"\n\t\tcase !hasRight:\n\t\t\tborder.TopRight = \"\"\n\t\t}\n\t}\n\tif hasBottom {\n\t\tswitch {\n\t\tcase !hasLeft && !hasRight:\n\t\t\tborder.BottomLeft = \"\"\n\t\t\tborder.BottomRight = \"\"\n\t\tcase !hasLeft:\n\t\t\tborder.BottomLeft = \"\"\n\t\tcase !hasRight:\n\t\t\tborder.BottomRight = \"\"\n\t\t}\n\t}\n\n\t// For now, limit corners to one rune.\n\tborder.TopLeft = getFirstRuneAsString(border.TopLeft)\n\tborder.TopRight = getFirstRuneAsString(border.TopRight)\n\tborder.BottomRight = getFirstRuneAsString(border.BottomRight)\n\tborder.BottomLeft = getFirstRuneAsString(border.BottomLeft)\n\n\tvar out strings.Builder\n\n\t// Render top\n\tif hasTop {\n\t\ttop := renderHorizontalEdge(border.TopLeft, border.Top, border.TopRight, width)\n\t\ttop = s.styleBorder(top, topFG, topBG)\n\t\tout.WriteString(top)\n\t\tout.WriteRune('\\n')\n\t}\n\n\tleftRunes := []rune(border.Left)\n\tleftIndex := 0\n\n\trightRunes := []rune(border.Right)\n\trightIndex := 0\n\n\t// Render sides\n\tfor i, l := range lines {\n\t\tif hasLeft {\n\t\t\tr := string(leftRunes[leftIndex])\n\t\t\tleftIndex++\n\t\t\tif leftIndex >= len(leftRunes) {\n\t\t\t\tleftIndex = 0\n\t\t\t}\n\t\t\tout.WriteString(s.styleBorder(r, leftFG, leftBG))\n\t\t}\n\t\tout.WriteString(l)\n\t\tif hasRight {\n\t\t\tr := string(rightRunes[rightIndex])\n\t\t\trightIndex++\n\t\t\tif rightIndex >= len(rightRunes) {\n\t\t\t\trightIndex = 0\n\t\t\t}\n\t\t\tout.WriteString(s.styleBorder(r, rightFG, rightBG))\n\t\t}\n\t\tif i < len(lines)-1 {\n\t\t\tout.WriteRune('\\n')\n\t\t}\n\t}\n\n\t// Render bottom\n\tif hasBottom {\n\t\tbottom := renderHorizontalEdge(border.BottomLeft, border.Bottom, border.BottomRight, width)\n\t\tbottom = s.styleBorder(bottom, bottomFG, bottomBG)\n\t\tout.WriteRune('\\n')\n\t\tout.WriteString(bottom)\n\t}\n\n\treturn out.String()\n}\n\n// Render the horizontal (top or bottom) portion of a border.\nfunc renderHorizontalEdge(left, middle, right string, width int) string {\n\tif middle == \"\" {\n\t\tmiddle = \" \"\n\t}\n\n\tleftWidth := ansi.StringWidth(left)\n\trightWidth := ansi.StringWidth(right)\n\n\trunes := []rune(middle)\n\tj := 0\n\n\tout := strings.Builder{}\n\tout.WriteString(left)\n\tfor i := leftWidth + rightWidth; i < width+rightWidth; {\n\t\tout.WriteRune(runes[j])\n\t\tj++\n\t\tif j >= len(runes) {\n\t\t\tj = 0\n\t\t}\n\t\ti += ansi.StringWidth(string(runes[j]))\n\t}\n\tout.WriteString(right)\n\n\treturn out.String()\n}\n\n// Apply foreground and background styling to a border.\nfunc (s Style) styleBorder(border string, fg, bg TerminalColor) string {\n\tif fg == noColor && bg == noColor {\n\t\treturn border\n\t}\n\n\tstyle := termenv.Style{}\n\n\tif fg != noColor {\n\t\tstyle = style.Foreground(fg.color(s.r))\n\t}\n\tif bg != noColor {\n\t\tstyle = style.Background(bg.color(s.r))\n\t}\n\n\treturn style.Styled(border)\n}\n\nfunc maxRuneWidth(str string) int {\n\tvar width int\n\n\tstate := -1\n\tfor len(str) > 0 {\n\t\tvar w int\n\t\t_, str, w, state = uniseg.FirstGraphemeClusterInString(str, state)\n\t\tif w > width {\n\t\t\twidth = w\n\t\t}\n\t}\n\n\treturn width\n}\n\nfunc getFirstRuneAsString(str string) string {\n\tif str == \"\" {\n\t\treturn str\n\t}\n\tr := []rune(str)\n\treturn string(r[0])\n}\n"
        },
        {
          "name": "borders_test.go",
          "type": "blob",
          "size": 2.2587890625,
          "content": "package lipgloss\n\nimport \"testing\"\n\nfunc TestStyle_GetBorderSizes(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tstyle Style\n\t\twantX int\n\t\twantY int\n\t}{\n\t\t{\n\t\t\tname:  \"Default style\",\n\t\t\tstyle: NewStyle(),\n\t\t\twantX: 0,\n\t\t\twantY: 0,\n\t\t},\n\t\t{\n\t\t\tname:  \"Border(NormalBorder())\",\n\t\t\tstyle: NewStyle().Border(NormalBorder()),\n\t\t\twantX: 2,\n\t\t\twantY: 2,\n\t\t},\n\t\t{\n\t\t\tname:  \"Border(NormalBorder(), true)\",\n\t\t\tstyle: NewStyle().Border(NormalBorder(), true),\n\t\t\twantX: 2,\n\t\t\twantY: 2,\n\t\t},\n\t\t{\n\t\t\tname:  \"Border(NormalBorder(), true, false)\",\n\t\t\tstyle: NewStyle().Border(NormalBorder(), true, false),\n\t\t\twantX: 0,\n\t\t\twantY: 2,\n\t\t},\n\t\t{\n\t\t\tname:  \"Border(NormalBorder(), true, true, false)\",\n\t\t\tstyle: NewStyle().Border(NormalBorder(), true, true, false),\n\t\t\twantX: 2,\n\t\t\twantY: 1,\n\t\t},\n\t\t{\n\t\t\tname:  \"Border(NormalBorder(), true, true, false, false)\",\n\t\t\tstyle: NewStyle().Border(NormalBorder(), true, true, false, false),\n\t\t\twantX: 1,\n\t\t\twantY: 1,\n\t\t},\n\t\t{\n\t\t\tname:  \"BorderTop(true).BorderStyle(NormalBorder())\",\n\t\t\tstyle: NewStyle().BorderTop(true).BorderStyle(NormalBorder()),\n\t\t\twantX: 0,\n\t\t\twantY: 1,\n\t\t},\n\t\t{\n\t\t\tname:  \"BorderStyle(NormalBorder())\",\n\t\t\tstyle: NewStyle().BorderStyle(NormalBorder()),\n\t\t\twantX: 2,\n\t\t\twantY: 2,\n\t\t},\n\t\t{\n\t\t\tname:  \"Custom BorderStyle\",\n\t\t\tstyle: NewStyle().BorderStyle(Border{Left: \"123456789\"}),\n\t\t\twantX: 1, // left and right borders are laid out vertically, one rune per row\n\t\t\twantY: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotX := tt.style.GetHorizontalBorderSize()\n\t\t\tif gotX != tt.wantX {\n\t\t\t\tt.Errorf(\"Style.GetHorizontalBorderSize() got %d, want %d\", gotX, tt.wantX)\n\t\t\t}\n\n\t\t\tgotY := tt.style.GetVerticalBorderSize()\n\t\t\tif gotY != tt.wantY {\n\t\t\t\tt.Errorf(\"Style.GetVerticalBorderSize() got %d, want %d\", gotY, tt.wantY)\n\t\t\t}\n\n\t\t\tgotX = tt.style.GetHorizontalFrameSize()\n\t\t\tif gotX != tt.wantX {\n\t\t\t\tt.Errorf(\"Style.GetHorizontalFrameSize() got %d, want %d\", gotX, tt.wantX)\n\t\t\t}\n\n\t\t\tgotY = tt.style.GetVerticalFrameSize()\n\t\t\tif gotY != tt.wantY {\n\t\t\t\tt.Errorf(\"Style.GetVerticalFrameSize() got %d, want %d\", gotY, tt.wantY)\n\t\t\t}\n\n\t\t\tgotX, gotY = tt.style.GetFrameSize()\n\t\t\tif gotX != tt.wantX || gotY != tt.wantY {\n\t\t\t\tt.Errorf(\"Style.GetFrameSize() got (%d, %d), want (%d, %d)\", gotX, gotY, tt.wantX, tt.wantY)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "color.go",
          "type": "blob",
          "size": 4.791015625,
          "content": "package lipgloss\n\nimport (\n\t\"strconv\"\n\n\t\"github.com/muesli/termenv\"\n)\n\n// TerminalColor is a color intended to be rendered in the terminal.\ntype TerminalColor interface {\n\tcolor(*Renderer) termenv.Color\n\tRGBA() (r, g, b, a uint32)\n}\n\nvar noColor = NoColor{}\n\n// NoColor is used to specify the absence of color styling. When this is active\n// foreground colors will be rendered with the terminal's default text color,\n// and background colors will not be drawn at all.\n//\n// Example usage:\n//\n//\tvar style = someStyle.Background(lipgloss.NoColor{})\ntype NoColor struct{}\n\nfunc (NoColor) color(*Renderer) termenv.Color {\n\treturn termenv.NoColor{}\n}\n\n// RGBA returns the RGBA value of this color. Because we have to return\n// something, despite this color being the absence of color, we're returning\n// black with 100% opacity.\n//\n// Red: 0x0, Green: 0x0, Blue: 0x0, Alpha: 0xFFFF.\n//\n// Deprecated.\nfunc (n NoColor) RGBA() (r, g, b, a uint32) {\n\treturn 0x0, 0x0, 0x0, 0xFFFF //nolint:gomnd\n}\n\n// Color specifies a color by hex or ANSI value. For example:\n//\n//\tansiColor := lipgloss.Color(\"21\")\n//\thexColor := lipgloss.Color(\"#0000ff\")\ntype Color string\n\nfunc (c Color) color(r *Renderer) termenv.Color {\n\treturn r.ColorProfile().Color(string(c))\n}\n\n// RGBA returns the RGBA value of this color. This satisfies the Go Color\n// interface. Note that on error we return black with 100% opacity, or:\n//\n// Red: 0x0, Green: 0x0, Blue: 0x0, Alpha: 0xFFFF.\n//\n// Deprecated.\nfunc (c Color) RGBA() (r, g, b, a uint32) {\n\treturn termenv.ConvertToRGB(c.color(renderer)).RGBA()\n}\n\n// ANSIColor is a color specified by an ANSI color value. It's merely syntactic\n// sugar for the more general Color function. Invalid colors will render as\n// black.\n//\n// Example usage:\n//\n//\t// These two statements are equivalent.\n//\tcolorA := lipgloss.ANSIColor(21)\n//\tcolorB := lipgloss.Color(\"21\")\ntype ANSIColor uint\n\nfunc (ac ANSIColor) color(r *Renderer) termenv.Color {\n\treturn Color(strconv.FormatUint(uint64(ac), 10)).color(r)\n}\n\n// RGBA returns the RGBA value of this color. This satisfies the Go Color\n// interface. Note that on error we return black with 100% opacity, or:\n//\n// Red: 0x0, Green: 0x0, Blue: 0x0, Alpha: 0xFFFF.\n//\n// Deprecated.\nfunc (ac ANSIColor) RGBA() (r, g, b, a uint32) {\n\tcf := Color(strconv.FormatUint(uint64(ac), 10))\n\treturn cf.RGBA()\n}\n\n// AdaptiveColor provides color options for light and dark backgrounds. The\n// appropriate color will be returned at runtime based on the darkness of the\n// terminal background color.\n//\n// Example usage:\n//\n//\tcolor := lipgloss.AdaptiveColor{Light: \"#0000ff\", Dark: \"#000099\"}\ntype AdaptiveColor struct {\n\tLight string\n\tDark  string\n}\n\nfunc (ac AdaptiveColor) color(r *Renderer) termenv.Color {\n\tif r.HasDarkBackground() {\n\t\treturn Color(ac.Dark).color(r)\n\t}\n\treturn Color(ac.Light).color(r)\n}\n\n// RGBA returns the RGBA value of this color. This satisfies the Go Color\n// interface. Note that on error we return black with 100% opacity, or:\n//\n// Red: 0x0, Green: 0x0, Blue: 0x0, Alpha: 0xFFFF.\n//\n// Deprecated.\nfunc (ac AdaptiveColor) RGBA() (r, g, b, a uint32) {\n\treturn termenv.ConvertToRGB(ac.color(renderer)).RGBA()\n}\n\n// CompleteColor specifies exact values for truecolor, ANSI256, and ANSI color\n// profiles. Automatic color degradation will not be performed.\ntype CompleteColor struct {\n\tTrueColor string\n\tANSI256   string\n\tANSI      string\n}\n\nfunc (c CompleteColor) color(r *Renderer) termenv.Color {\n\tp := r.ColorProfile()\n\tswitch p { //nolint:exhaustive\n\tcase termenv.TrueColor:\n\t\treturn p.Color(c.TrueColor)\n\tcase termenv.ANSI256:\n\t\treturn p.Color(c.ANSI256)\n\tcase termenv.ANSI:\n\t\treturn p.Color(c.ANSI)\n\tdefault:\n\t\treturn termenv.NoColor{}\n\t}\n}\n\n// RGBA returns the RGBA value of this color. This satisfies the Go Color\n// interface. Note that on error we return black with 100% opacity, or:\n//\n// Red: 0x0, Green: 0x0, Blue: 0x0, Alpha: 0xFFFF.\n// CompleteAdaptiveColor specifies exact values for truecolor, ANSI256, and ANSI color\n//\n// Deprecated.\nfunc (c CompleteColor) RGBA() (r, g, b, a uint32) {\n\treturn termenv.ConvertToRGB(c.color(renderer)).RGBA()\n}\n\n// CompleteAdaptiveColor specifies exact values for truecolor, ANSI256, and ANSI color\n// profiles, with separate options for light and dark backgrounds. Automatic\n// color degradation will not be performed.\ntype CompleteAdaptiveColor struct {\n\tLight CompleteColor\n\tDark  CompleteColor\n}\n\nfunc (cac CompleteAdaptiveColor) color(r *Renderer) termenv.Color {\n\tif r.HasDarkBackground() {\n\t\treturn cac.Dark.color(r)\n\t}\n\treturn cac.Light.color(r)\n}\n\n// RGBA returns the RGBA value of this color. This satisfies the Go Color\n// interface. Note that on error we return black with 100% opacity, or:\n//\n// Red: 0x0, Green: 0x0, Blue: 0x0, Alpha: 0xFFFF.\n//\n// Deprecated.\nfunc (cac CompleteAdaptiveColor) RGBA() (r, g, b, a uint32) {\n\treturn termenv.ConvertToRGB(cac.color(renderer)).RGBA()\n}\n"
        },
        {
          "name": "color_test.go",
          "type": "blob",
          "size": 5.3447265625,
          "content": "package lipgloss\n\nimport (\n\t\"image/color\"\n\t\"testing\"\n\n\t\"github.com/muesli/termenv\"\n)\n\nfunc TestSetColorProfile(t *testing.T) {\n\tr := renderer\n\tinput := \"hello\"\n\n\ttt := []struct {\n\t\tname     string\n\t\tprofile  termenv.Profile\n\t\texpected string\n\t}{\n\t\t{\n\t\t\t\"ascii\",\n\t\t\ttermenv.Ascii,\n\t\t\t\"hello\",\n\t\t},\n\t\t{\n\t\t\t\"ansi\",\n\t\t\ttermenv.ANSI,\n\t\t\t\"\\x1b[94mhello\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\t\"ansi256\",\n\t\t\ttermenv.ANSI256,\n\t\t\t\"\\x1b[38;5;62mhello\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\t\"truecolor\",\n\t\t\ttermenv.TrueColor,\n\t\t\t\"\\x1b[38;2;89;86;224mhello\\x1b[0m\",\n\t\t},\n\t}\n\n\tfor _, tc := range tt {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tr.SetColorProfile(tc.profile)\n\t\t\tstyle := NewStyle().Foreground(Color(\"#5A56E0\"))\n\t\t\tres := style.Render(input)\n\n\t\t\tif res != tc.expected {\n\t\t\t\tt.Errorf(\"Expected:\\n\\n`%s`\\n`%s`\\n\\nActual output:\\n\\n`%s`\\n`%s`\\n\\n\",\n\t\t\t\t\ttc.expected, formatEscapes(tc.expected),\n\t\t\t\t\tres, formatEscapes(res))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestHexToColor(t *testing.T) {\n\tt.Parallel()\n\n\ttt := []struct {\n\t\tinput    string\n\t\texpected uint\n\t}{\n\t\t{\n\t\t\t\"#FF0000\",\n\t\t\t0xFF0000,\n\t\t},\n\t\t{\n\t\t\t\"#00F\",\n\t\t\t0x0000FF,\n\t\t},\n\t\t{\n\t\t\t\"#6B50FF\",\n\t\t\t0x6B50FF,\n\t\t},\n\t\t{\n\t\t\t\"invalid color\",\n\t\t\t0x0,\n\t\t},\n\t}\n\n\tfor i, tc := range tt {\n\t\th := hexToColor(tc.input)\n\t\to := uint(h.R)<<16 + uint(h.G)<<8 + uint(h.B)\n\t\tif o != tc.expected {\n\t\t\tt.Errorf(\"expected %X, got %X (test #%d)\", tc.expected, o, i+1)\n\t\t}\n\t}\n}\n\nfunc TestRGBA(t *testing.T) {\n\ttt := []struct {\n\t\tprofile  termenv.Profile\n\t\tdarkBg   bool\n\t\tinput    TerminalColor\n\t\texpected uint\n\t}{\n\t\t// lipgloss.Color\n\t\t{\n\t\t\ttermenv.TrueColor,\n\t\t\ttrue,\n\t\t\tColor(\"#FF0000\"),\n\t\t\t0xFF0000,\n\t\t},\n\t\t{\n\t\t\ttermenv.TrueColor,\n\t\t\ttrue,\n\t\t\tColor(\"9\"),\n\t\t\t0xFF0000,\n\t\t},\n\t\t{\n\t\t\ttermenv.TrueColor,\n\t\t\ttrue,\n\t\t\tColor(\"21\"),\n\t\t\t0x0000FF,\n\t\t},\n\t\t// lipgloss.AdaptiveColor\n\t\t{\n\t\t\ttermenv.TrueColor,\n\t\t\ttrue,\n\t\t\tAdaptiveColor{Light: \"#0000FF\", Dark: \"#FF0000\"},\n\t\t\t0xFF0000,\n\t\t},\n\t\t{\n\t\t\ttermenv.TrueColor,\n\t\t\tfalse,\n\t\t\tAdaptiveColor{Light: \"#0000FF\", Dark: \"#FF0000\"},\n\t\t\t0x0000FF,\n\t\t},\n\t\t{\n\t\t\ttermenv.TrueColor,\n\t\t\ttrue,\n\t\t\tAdaptiveColor{Light: \"21\", Dark: \"9\"},\n\t\t\t0xFF0000,\n\t\t},\n\t\t{\n\t\t\ttermenv.TrueColor,\n\t\t\tfalse,\n\t\t\tAdaptiveColor{Light: \"21\", Dark: \"9\"},\n\t\t\t0x0000FF,\n\t\t},\n\t\t// lipgloss.CompleteColor\n\t\t{\n\t\t\ttermenv.TrueColor,\n\t\t\ttrue,\n\t\t\tCompleteColor{TrueColor: \"#FF0000\", ANSI256: \"231\", ANSI: \"12\"},\n\t\t\t0xFF0000,\n\t\t},\n\t\t{\n\t\t\ttermenv.ANSI256,\n\t\t\ttrue,\n\t\t\tCompleteColor{TrueColor: \"#FF0000\", ANSI256: \"231\", ANSI: \"12\"},\n\t\t\t0xFFFFFF,\n\t\t},\n\t\t{\n\t\t\ttermenv.ANSI,\n\t\t\ttrue,\n\t\t\tCompleteColor{TrueColor: \"#FF0000\", ANSI256: \"231\", ANSI: \"12\"},\n\t\t\t0x0000FF,\n\t\t},\n\t\t{\n\t\t\ttermenv.TrueColor,\n\t\t\ttrue,\n\t\t\tCompleteColor{TrueColor: \"\", ANSI256: \"231\", ANSI: \"12\"},\n\t\t\t0x000000,\n\t\t},\n\t\t// lipgloss.CompleteAdaptiveColor\n\t\t// dark\n\t\t{\n\t\t\ttermenv.TrueColor,\n\t\t\ttrue,\n\t\t\tCompleteAdaptiveColor{\n\t\t\t\tLight: CompleteColor{TrueColor: \"#0000FF\", ANSI256: \"231\", ANSI: \"12\"},\n\t\t\t\tDark:  CompleteColor{TrueColor: \"#FF0000\", ANSI256: \"231\", ANSI: \"12\"},\n\t\t\t},\n\t\t\t0xFF0000,\n\t\t},\n\t\t{\n\t\t\ttermenv.ANSI256,\n\t\t\ttrue,\n\t\t\tCompleteAdaptiveColor{\n\t\t\t\tLight: CompleteColor{TrueColor: \"#FF0000\", ANSI256: \"21\", ANSI: \"12\"},\n\t\t\t\tDark:  CompleteColor{TrueColor: \"#FF0000\", ANSI256: \"231\", ANSI: \"12\"},\n\t\t\t},\n\t\t\t0xFFFFFF,\n\t\t},\n\t\t{\n\t\t\ttermenv.ANSI,\n\t\t\ttrue,\n\t\t\tCompleteAdaptiveColor{\n\t\t\t\tLight: CompleteColor{TrueColor: \"#FF0000\", ANSI256: \"231\", ANSI: \"9\"},\n\t\t\t\tDark:  CompleteColor{TrueColor: \"#FF0000\", ANSI256: \"231\", ANSI: \"12\"},\n\t\t\t},\n\t\t\t0x0000FF,\n\t\t},\n\t\t// light\n\t\t{\n\t\t\ttermenv.TrueColor,\n\t\t\tfalse,\n\t\t\tCompleteAdaptiveColor{\n\t\t\t\tLight: CompleteColor{TrueColor: \"#0000FF\", ANSI256: \"231\", ANSI: \"12\"},\n\t\t\t\tDark:  CompleteColor{TrueColor: \"#FF0000\", ANSI256: \"231\", ANSI: \"12\"},\n\t\t\t},\n\t\t\t0x0000FF,\n\t\t},\n\t\t{\n\t\t\ttermenv.ANSI256,\n\t\t\tfalse,\n\t\t\tCompleteAdaptiveColor{\n\t\t\t\tLight: CompleteColor{TrueColor: \"#FF0000\", ANSI256: \"21\", ANSI: \"12\"},\n\t\t\t\tDark:  CompleteColor{TrueColor: \"#FF0000\", ANSI256: \"231\", ANSI: \"12\"},\n\t\t\t},\n\t\t\t0x0000FF,\n\t\t},\n\t\t{\n\t\t\ttermenv.ANSI,\n\t\t\tfalse,\n\t\t\tCompleteAdaptiveColor{\n\t\t\t\tLight: CompleteColor{TrueColor: \"#FF0000\", ANSI256: \"231\", ANSI: \"9\"},\n\t\t\t\tDark:  CompleteColor{TrueColor: \"#FF0000\", ANSI256: \"231\", ANSI: \"12\"},\n\t\t\t},\n\t\t\t0xFF0000,\n\t\t},\n\t}\n\n\tr := DefaultRenderer()\n\tfor i, tc := range tt {\n\t\tr.SetColorProfile(tc.profile)\n\t\tr.SetHasDarkBackground(tc.darkBg)\n\n\t\tr, g, b, _ := tc.input.RGBA()\n\t\to := uint(r/256)<<16 + uint(g/256)<<8 + uint(b/256)\n\n\t\tif o != tc.expected {\n\t\t\tt.Errorf(\"expected %X, got %X (test #%d)\", tc.expected, o, i+1)\n\t\t}\n\t}\n}\n\n// hexToColor translates a hex color string (#RRGGBB or #RGB) into a color.RGB,\n// which satisfies the color.Color interface. If an invalid string is passed\n// black with 100% opacity will be returned: or, in hex format, 0x000000FF.\nfunc hexToColor(hex string) (c color.RGBA) {\n\tc.A = 0xFF\n\n\tif hex == \"\" || hex[0] != '#' {\n\t\treturn c\n\t}\n\n\tconst (\n\t\tfullFormat  = 7 // #RRGGBB\n\t\tshortFormat = 4 // #RGB\n\t)\n\n\tswitch len(hex) {\n\tcase fullFormat:\n\t\tconst offset = 4\n\t\tc.R = hexToByte(hex[1])<<offset + hexToByte(hex[2])\n\t\tc.G = hexToByte(hex[3])<<offset + hexToByte(hex[4])\n\t\tc.B = hexToByte(hex[5])<<offset + hexToByte(hex[6])\n\tcase shortFormat:\n\t\tconst offset = 0x11\n\t\tc.R = hexToByte(hex[1]) * offset\n\t\tc.G = hexToByte(hex[2]) * offset\n\t\tc.B = hexToByte(hex[3]) * offset\n\t}\n\n\treturn c\n}\n\nfunc hexToByte(b byte) byte {\n\tconst offset = 10\n\tswitch {\n\tcase b >= '0' && b <= '9':\n\t\treturn b - '0'\n\tcase b >= 'a' && b <= 'f':\n\t\treturn b - 'a' + offset\n\tcase b >= 'A' && b <= 'F':\n\t\treturn b - 'A' + offset\n\t}\n\t// Invalid, but just return 0.\n\treturn 0\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "get.go",
          "type": "blob",
          "size": 16.0849609375,
          "content": "package lipgloss\n\nimport (\n\t\"strings\"\n\n\t\"github.com/charmbracelet/x/ansi\"\n)\n\n// GetBold returns the style's bold value. If no value is set false is returned.\nfunc (s Style) GetBold() bool {\n\treturn s.getAsBool(boldKey, false)\n}\n\n// GetItalic returns the style's italic value. If no value is set false is\n// returned.\nfunc (s Style) GetItalic() bool {\n\treturn s.getAsBool(italicKey, false)\n}\n\n// GetUnderline returns the style's underline value. If no value is set false is\n// returned.\nfunc (s Style) GetUnderline() bool {\n\treturn s.getAsBool(underlineKey, false)\n}\n\n// GetStrikethrough returns the style's strikethrough value. If no value is set false\n// is returned.\nfunc (s Style) GetStrikethrough() bool {\n\treturn s.getAsBool(strikethroughKey, false)\n}\n\n// GetReverse returns the style's reverse value. If no value is set false is\n// returned.\nfunc (s Style) GetReverse() bool {\n\treturn s.getAsBool(reverseKey, false)\n}\n\n// GetBlink returns the style's blink value. If no value is set false is\n// returned.\nfunc (s Style) GetBlink() bool {\n\treturn s.getAsBool(blinkKey, false)\n}\n\n// GetFaint returns the style's faint value. If no value is set false is\n// returned.\nfunc (s Style) GetFaint() bool {\n\treturn s.getAsBool(faintKey, false)\n}\n\n// GetForeground returns the style's foreground color. If no value is set\n// NoColor{} is returned.\nfunc (s Style) GetForeground() TerminalColor {\n\treturn s.getAsColor(foregroundKey)\n}\n\n// GetBackground returns the style's background color. If no value is set\n// NoColor{} is returned.\nfunc (s Style) GetBackground() TerminalColor {\n\treturn s.getAsColor(backgroundKey)\n}\n\n// GetWidth returns the style's width setting. If no width is set 0 is\n// returned.\nfunc (s Style) GetWidth() int {\n\treturn s.getAsInt(widthKey)\n}\n\n// GetHeight returns the style's height setting. If no height is set 0 is\n// returned.\nfunc (s Style) GetHeight() int {\n\treturn s.getAsInt(heightKey)\n}\n\n// GetAlign returns the style's implicit horizontal alignment setting.\n// If no alignment is set Position.Left is returned.\nfunc (s Style) GetAlign() Position {\n\tv := s.getAsPosition(alignHorizontalKey)\n\tif v == Position(0) {\n\t\treturn Left\n\t}\n\treturn v\n}\n\n// GetAlignHorizontal returns the style's implicit horizontal alignment setting.\n// If no alignment is set Position.Left is returned.\nfunc (s Style) GetAlignHorizontal() Position {\n\tv := s.getAsPosition(alignHorizontalKey)\n\tif v == Position(0) {\n\t\treturn Left\n\t}\n\treturn v\n}\n\n// GetAlignVertical returns the style's implicit vertical alignment setting.\n// If no alignment is set Position.Top is returned.\nfunc (s Style) GetAlignVertical() Position {\n\tv := s.getAsPosition(alignVerticalKey)\n\tif v == Position(0) {\n\t\treturn Top\n\t}\n\treturn v\n}\n\n// GetPadding returns the style's top, right, bottom, and left padding values,\n// in that order. 0 is returned for unset values.\nfunc (s Style) GetPadding() (top, right, bottom, left int) {\n\treturn s.getAsInt(paddingTopKey),\n\t\ts.getAsInt(paddingRightKey),\n\t\ts.getAsInt(paddingBottomKey),\n\t\ts.getAsInt(paddingLeftKey)\n}\n\n// GetPaddingTop returns the style's top padding. If no value is set 0 is\n// returned.\nfunc (s Style) GetPaddingTop() int {\n\treturn s.getAsInt(paddingTopKey)\n}\n\n// GetPaddingRight returns the style's right padding. If no value is set 0 is\n// returned.\nfunc (s Style) GetPaddingRight() int {\n\treturn s.getAsInt(paddingRightKey)\n}\n\n// GetPaddingBottom returns the style's bottom padding. If no value is set 0 is\n// returned.\nfunc (s Style) GetPaddingBottom() int {\n\treturn s.getAsInt(paddingBottomKey)\n}\n\n// GetPaddingLeft returns the style's left padding. If no value is set 0 is\n// returned.\nfunc (s Style) GetPaddingLeft() int {\n\treturn s.getAsInt(paddingLeftKey)\n}\n\n// GetHorizontalPadding returns the style's left and right padding. Unset\n// values are measured as 0.\nfunc (s Style) GetHorizontalPadding() int {\n\treturn s.getAsInt(paddingLeftKey) + s.getAsInt(paddingRightKey)\n}\n\n// GetVerticalPadding returns the style's top and bottom padding. Unset values\n// are measured as 0.\nfunc (s Style) GetVerticalPadding() int {\n\treturn s.getAsInt(paddingTopKey) + s.getAsInt(paddingBottomKey)\n}\n\n// GetColorWhitespace returns the style's whitespace coloring setting. If no\n// value is set false is returned.\nfunc (s Style) GetColorWhitespace() bool {\n\treturn s.getAsBool(colorWhitespaceKey, false)\n}\n\n// GetMargin returns the style's top, right, bottom, and left margins, in that\n// order. 0 is returned for unset values.\nfunc (s Style) GetMargin() (top, right, bottom, left int) {\n\treturn s.getAsInt(marginTopKey),\n\t\ts.getAsInt(marginRightKey),\n\t\ts.getAsInt(marginBottomKey),\n\t\ts.getAsInt(marginLeftKey)\n}\n\n// GetMarginTop returns the style's top margin. If no value is set 0 is\n// returned.\nfunc (s Style) GetMarginTop() int {\n\treturn s.getAsInt(marginTopKey)\n}\n\n// GetMarginRight returns the style's right margin. If no value is set 0 is\n// returned.\nfunc (s Style) GetMarginRight() int {\n\treturn s.getAsInt(marginRightKey)\n}\n\n// GetMarginBottom returns the style's bottom margin. If no value is set 0 is\n// returned.\nfunc (s Style) GetMarginBottom() int {\n\treturn s.getAsInt(marginBottomKey)\n}\n\n// GetMarginLeft returns the style's left margin. If no value is set 0 is\n// returned.\nfunc (s Style) GetMarginLeft() int {\n\treturn s.getAsInt(marginLeftKey)\n}\n\n// GetHorizontalMargins returns the style's left and right margins. Unset\n// values are measured as 0.\nfunc (s Style) GetHorizontalMargins() int {\n\treturn s.getAsInt(marginLeftKey) + s.getAsInt(marginRightKey)\n}\n\n// GetVerticalMargins returns the style's top and bottom margins. Unset values\n// are measured as 0.\nfunc (s Style) GetVerticalMargins() int {\n\treturn s.getAsInt(marginTopKey) + s.getAsInt(marginBottomKey)\n}\n\n// GetBorder returns the style's border style (type Border) and value for the\n// top, right, bottom, and left in that order. If no value is set for the\n// border style, Border{} is returned. For all other unset values false is\n// returned.\nfunc (s Style) GetBorder() (b Border, top, right, bottom, left bool) {\n\treturn s.getBorderStyle(),\n\t\ts.getAsBool(borderTopKey, false),\n\t\ts.getAsBool(borderRightKey, false),\n\t\ts.getAsBool(borderBottomKey, false),\n\t\ts.getAsBool(borderLeftKey, false)\n}\n\n// GetBorderStyle returns the style's border style (type Border). If no value\n// is set Border{} is returned.\nfunc (s Style) GetBorderStyle() Border {\n\treturn s.getBorderStyle()\n}\n\n// GetBorderTop returns the style's top border setting. If no value is set\n// false is returned.\nfunc (s Style) GetBorderTop() bool {\n\treturn s.getAsBool(borderTopKey, false)\n}\n\n// GetBorderRight returns the style's right border setting. If no value is set\n// false is returned.\nfunc (s Style) GetBorderRight() bool {\n\treturn s.getAsBool(borderRightKey, false)\n}\n\n// GetBorderBottom returns the style's bottom border setting. If no value is\n// set false is returned.\nfunc (s Style) GetBorderBottom() bool {\n\treturn s.getAsBool(borderBottomKey, false)\n}\n\n// GetBorderLeft returns the style's left border setting. If no value is\n// set false is returned.\nfunc (s Style) GetBorderLeft() bool {\n\treturn s.getAsBool(borderLeftKey, false)\n}\n\n// GetBorderTopForeground returns the style's border top foreground color. If\n// no value is set NoColor{} is returned.\nfunc (s Style) GetBorderTopForeground() TerminalColor {\n\treturn s.getAsColor(borderTopForegroundKey)\n}\n\n// GetBorderRightForeground returns the style's border right foreground color.\n// If no value is set NoColor{} is returned.\nfunc (s Style) GetBorderRightForeground() TerminalColor {\n\treturn s.getAsColor(borderRightForegroundKey)\n}\n\n// GetBorderBottomForeground returns the style's border bottom foreground\n// color.  If no value is set NoColor{} is returned.\nfunc (s Style) GetBorderBottomForeground() TerminalColor {\n\treturn s.getAsColor(borderBottomForegroundKey)\n}\n\n// GetBorderLeftForeground returns the style's border left foreground\n// color.  If no value is set NoColor{} is returned.\nfunc (s Style) GetBorderLeftForeground() TerminalColor {\n\treturn s.getAsColor(borderLeftForegroundKey)\n}\n\n// GetBorderTopBackground returns the style's border top background color. If\n// no value is set NoColor{} is returned.\nfunc (s Style) GetBorderTopBackground() TerminalColor {\n\treturn s.getAsColor(borderTopBackgroundKey)\n}\n\n// GetBorderRightBackground returns the style's border right background color.\n// If no value is set NoColor{} is returned.\nfunc (s Style) GetBorderRightBackground() TerminalColor {\n\treturn s.getAsColor(borderRightBackgroundKey)\n}\n\n// GetBorderBottomBackground returns the style's border bottom background\n// color.  If no value is set NoColor{} is returned.\nfunc (s Style) GetBorderBottomBackground() TerminalColor {\n\treturn s.getAsColor(borderBottomBackgroundKey)\n}\n\n// GetBorderLeftBackground returns the style's border left background\n// color.  If no value is set NoColor{} is returned.\nfunc (s Style) GetBorderLeftBackground() TerminalColor {\n\treturn s.getAsColor(borderLeftBackgroundKey)\n}\n\n// GetBorderTopWidth returns the width of the top border. If borders contain\n// runes of varying widths, the widest rune is returned. If no border exists on\n// the top edge, 0 is returned.\n//\n// Deprecated: This function simply calls Style.GetBorderTopSize.\nfunc (s Style) GetBorderTopWidth() int {\n\treturn s.GetBorderTopSize()\n}\n\n// GetBorderTopSize returns the width of the top border. If borders contain\n// runes of varying widths, the widest rune is returned. If no border exists on\n// the top edge, 0 is returned.\nfunc (s Style) GetBorderTopSize() int {\n\tif !s.getAsBool(borderTopKey, false) && !s.implicitBorders() {\n\t\treturn 0\n\t}\n\treturn s.getBorderStyle().GetTopSize()\n}\n\n// GetBorderLeftSize returns the width of the left border. If borders contain\n// runes of varying widths, the widest rune is returned. If no border exists on\n// the left edge, 0 is returned.\nfunc (s Style) GetBorderLeftSize() int {\n\tif !s.getAsBool(borderLeftKey, false) && !s.implicitBorders() {\n\t\treturn 0\n\t}\n\treturn s.getBorderStyle().GetLeftSize()\n}\n\n// GetBorderBottomSize returns the width of the bottom border. If borders\n// contain runes of varying widths, the widest rune is returned. If no border\n// exists on the left edge, 0 is returned.\nfunc (s Style) GetBorderBottomSize() int {\n\tif !s.getAsBool(borderBottomKey, false) && !s.implicitBorders() {\n\t\treturn 0\n\t}\n\treturn s.getBorderStyle().GetBottomSize()\n}\n\n// GetBorderRightSize returns the width of the right border. If borders\n// contain runes of varying widths, the widest rune is returned. If no border\n// exists on the right edge, 0 is returned.\nfunc (s Style) GetBorderRightSize() int {\n\tif !s.getAsBool(borderRightKey, false) && !s.implicitBorders() {\n\t\treturn 0\n\t}\n\treturn s.getBorderStyle().GetRightSize()\n}\n\n// GetHorizontalBorderSize returns the width of the horizontal borders. If\n// borders contain runes of varying widths, the widest rune is returned. If no\n// border exists on the horizontal edges, 0 is returned.\nfunc (s Style) GetHorizontalBorderSize() int {\n\treturn s.GetBorderLeftSize() + s.GetBorderRightSize()\n}\n\n// GetVerticalBorderSize returns the width of the vertical borders. If\n// borders contain runes of varying widths, the widest rune is returned. If no\n// border exists on the vertical edges, 0 is returned.\nfunc (s Style) GetVerticalBorderSize() int {\n\treturn s.GetBorderTopSize() + s.GetBorderBottomSize()\n}\n\n// GetInline returns the style's inline setting. If no value is set false is\n// returned.\nfunc (s Style) GetInline() bool {\n\treturn s.getAsBool(inlineKey, false)\n}\n\n// GetMaxWidth returns the style's max width setting. If no value is set 0 is\n// returned.\nfunc (s Style) GetMaxWidth() int {\n\treturn s.getAsInt(maxWidthKey)\n}\n\n// GetMaxHeight returns the style's max height setting. If no value is set 0 is\n// returned.\nfunc (s Style) GetMaxHeight() int {\n\treturn s.getAsInt(maxHeightKey)\n}\n\n// GetTabWidth returns the style's tab width setting. If no value is set 4 is\n// returned which is the implicit default.\nfunc (s Style) GetTabWidth() int {\n\treturn s.getAsInt(tabWidthKey)\n}\n\n// GetUnderlineSpaces returns whether or not the style is set to underline\n// spaces. If not value is set false is returned.\nfunc (s Style) GetUnderlineSpaces() bool {\n\treturn s.getAsBool(underlineSpacesKey, false)\n}\n\n// GetStrikethroughSpaces returns whether or not the style is set to strikethrough\n// spaces. If not value is set false is returned.\nfunc (s Style) GetStrikethroughSpaces() bool {\n\treturn s.getAsBool(strikethroughSpacesKey, false)\n}\n\n// GetHorizontalFrameSize returns the sum of the style's horizontal margins, padding\n// and border widths.\n//\n// Provisional: this method may be renamed.\nfunc (s Style) GetHorizontalFrameSize() int {\n\treturn s.GetHorizontalMargins() + s.GetHorizontalPadding() + s.GetHorizontalBorderSize()\n}\n\n// GetVerticalFrameSize returns the sum of the style's vertical margins, padding\n// and border widths.\n//\n// Provisional: this method may be renamed.\nfunc (s Style) GetVerticalFrameSize() int {\n\treturn s.GetVerticalMargins() + s.GetVerticalPadding() + s.GetVerticalBorderSize()\n}\n\n// GetFrameSize returns the sum of the margins, padding and border width for\n// both the horizontal and vertical margins.\nfunc (s Style) GetFrameSize() (x, y int) {\n\treturn s.GetHorizontalFrameSize(), s.GetVerticalFrameSize()\n}\n\n// GetTransform returns the transform set on the style. If no transform is set\n// nil is returned.\nfunc (s Style) GetTransform() func(string) string {\n\treturn s.getAsTransform(transformKey)\n}\n\n// Returns whether or not the given property is set.\nfunc (s Style) isSet(k propKey) bool {\n\treturn s.props.has(k)\n}\n\nfunc (s Style) getAsBool(k propKey, defaultVal bool) bool {\n\tif !s.isSet(k) {\n\t\treturn defaultVal\n\t}\n\treturn s.attrs&int(k) != 0\n}\n\nfunc (s Style) getAsColor(k propKey) TerminalColor {\n\tif !s.isSet(k) {\n\t\treturn noColor\n\t}\n\n\tvar c TerminalColor\n\tswitch k { //nolint:exhaustive\n\tcase foregroundKey:\n\t\tc = s.fgColor\n\tcase backgroundKey:\n\t\tc = s.bgColor\n\tcase marginBackgroundKey:\n\t\tc = s.marginBgColor\n\tcase borderTopForegroundKey:\n\t\tc = s.borderTopFgColor\n\tcase borderRightForegroundKey:\n\t\tc = s.borderRightFgColor\n\tcase borderBottomForegroundKey:\n\t\tc = s.borderBottomFgColor\n\tcase borderLeftForegroundKey:\n\t\tc = s.borderLeftFgColor\n\tcase borderTopBackgroundKey:\n\t\tc = s.borderTopBgColor\n\tcase borderRightBackgroundKey:\n\t\tc = s.borderRightBgColor\n\tcase borderBottomBackgroundKey:\n\t\tc = s.borderBottomBgColor\n\tcase borderLeftBackgroundKey:\n\t\tc = s.borderLeftBgColor\n\t}\n\n\tif c != nil {\n\t\treturn c\n\t}\n\n\treturn noColor\n}\n\nfunc (s Style) getAsInt(k propKey) int {\n\tif !s.isSet(k) {\n\t\treturn 0\n\t}\n\tswitch k { //nolint:exhaustive\n\tcase widthKey:\n\t\treturn s.width\n\tcase heightKey:\n\t\treturn s.height\n\tcase paddingTopKey:\n\t\treturn s.paddingTop\n\tcase paddingRightKey:\n\t\treturn s.paddingRight\n\tcase paddingBottomKey:\n\t\treturn s.paddingBottom\n\tcase paddingLeftKey:\n\t\treturn s.paddingLeft\n\tcase marginTopKey:\n\t\treturn s.marginTop\n\tcase marginRightKey:\n\t\treturn s.marginRight\n\tcase marginBottomKey:\n\t\treturn s.marginBottom\n\tcase marginLeftKey:\n\t\treturn s.marginLeft\n\tcase maxWidthKey:\n\t\treturn s.maxWidth\n\tcase maxHeightKey:\n\t\treturn s.maxHeight\n\tcase tabWidthKey:\n\t\treturn s.tabWidth\n\t}\n\treturn 0\n}\n\nfunc (s Style) getAsPosition(k propKey) Position {\n\tif !s.isSet(k) {\n\t\treturn Position(0)\n\t}\n\tswitch k { //nolint:exhaustive\n\tcase alignHorizontalKey:\n\t\treturn s.alignHorizontal\n\tcase alignVerticalKey:\n\t\treturn s.alignVertical\n\t}\n\treturn Position(0)\n}\n\nfunc (s Style) getBorderStyle() Border {\n\tif !s.isSet(borderStyleKey) {\n\t\treturn noBorder\n\t}\n\treturn s.borderStyle\n}\n\n// Returns whether or not the style has implicit borders. This happens when\n// a border style has been set but no border sides have been explicitly turned\n// on or off.\nfunc (s Style) implicitBorders() bool {\n\tvar (\n\t\tborderStyle = s.getBorderStyle()\n\t\ttopSet      = s.isSet(borderTopKey)\n\t\trightSet    = s.isSet(borderRightKey)\n\t\tbottomSet   = s.isSet(borderBottomKey)\n\t\tleftSet     = s.isSet(borderLeftKey)\n\t)\n\treturn borderStyle != noBorder && !(topSet || rightSet || bottomSet || leftSet)\n}\n\nfunc (s Style) getAsTransform(propKey) func(string) string {\n\tif !s.isSet(transformKey) {\n\t\treturn nil\n\t}\n\treturn s.transform\n}\n\n// Split a string into lines, additionally returning the size of the widest\n// line.\nfunc getLines(s string) (lines []string, widest int) {\n\tlines = strings.Split(s, \"\\n\")\n\n\tfor _, l := range lines {\n\t\tw := ansi.StringWidth(l)\n\t\tif widest < w {\n\t\t\twidest = w\n\t\t}\n\t}\n\n\treturn lines, widest\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.7490234375,
          "content": "module github.com/charmbracelet/lipgloss\n\nretract v0.7.0 // v0.7.0 introduces a bug that causes some apps to freeze.\n\nretract v0.11.1 // v0.11.1 uses a broken version of x/ansi StringWidth that causes some lines to wrap incorrectly.\n\ngo 1.18\n\nrequire (\n\tgithub.com/aymanbagabas/go-udiff v0.2.0\n\tgithub.com/charmbracelet/x/ansi v0.6.1-0.20250107110353-48b574af22a5\n\tgithub.com/charmbracelet/x/exp/golden v0.0.0-20240806155701-69247e0abc2a\n\tgithub.com/muesli/termenv v0.15.2\n\tgithub.com/rivo/uniseg v0.4.7\n)\n\nrequire (\n\tgithub.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect\n\tgithub.com/lucasb-eyer/go-colorful v1.2.0 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.15 // indirect\n\tgolang.org/x/sys v0.19.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.00390625,
          "content": "github.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=\ngithub.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=\ngithub.com/aymanbagabas/go-udiff v0.2.0 h1:TK0fH4MteXUDspT88n8CKzvK0X9O2xu9yQjWpi6yML8=\ngithub.com/aymanbagabas/go-udiff v0.2.0/go.mod h1:RE4Ex0qsGkTAJoQdQQCA0uG+nAzJO/pI/QwceO5fgrA=\ngithub.com/charmbracelet/x/ansi v0.6.1-0.20250107110353-48b574af22a5 h1:TSjbA80sXnABV/Vxhnb67Ho7p8bEYqz6NIdhLAx+1yg=\ngithub.com/charmbracelet/x/ansi v0.6.1-0.20250107110353-48b574af22a5/go.mod h1:KBUFw1la39nl0dLl10l5ORDAqGXaeurTQmwyyVKse/Q=\ngithub.com/charmbracelet/x/exp/golden v0.0.0-20240806155701-69247e0abc2a h1:G99klV19u0QnhiizODirwVksQB91TJKV/UaTnACcG30=\ngithub.com/charmbracelet/x/exp/golden v0.0.0-20240806155701-69247e0abc2a/go.mod h1:wDlXFlCrmJ8J+swcL/MnGUuYnqgQdW9rhSD61oNMb6U=\ngithub.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=\ngithub.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-runewidth v0.0.15 h1:UNAjwbU9l54TA3KzvqLGxwWjHmMgBUVhBiTjelZgg3U=\ngithub.com/mattn/go-runewidth v0.0.15/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/muesli/termenv v0.15.2 h1:GohcuySI0QmI3wN8Ok9PtKGkgkFIk7y6Vpb5PvrY+Wo=\ngithub.com/muesli/termenv v0.15.2/go.mod h1:Epx+iuz8sNs7mNKhxzH4fWXGNpZwUaJKRS1noLXviQ8=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=\ngithub.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.19.0 h1:q5f1RH2jigJ1MoAWp2KTp3gm5zAGFUTarQZ5U386+4o=\ngolang.org/x/sys v0.19.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n"
        },
        {
          "name": "join.go",
          "type": "blob",
          "size": 4.03125,
          "content": "package lipgloss\n\nimport (\n\t\"math\"\n\t\"strings\"\n\n\t\"github.com/charmbracelet/x/ansi\"\n)\n\n// JoinHorizontal is a utility function for horizontally joining two\n// potentially multi-lined strings along a vertical axis. The first argument is\n// the position, with 0 being all the way at the top and 1 being all the way\n// at the bottom.\n//\n// If you just want to align to the top, center or bottom you may as well just\n// use the helper constants Top, Center, and Bottom.\n//\n// Example:\n//\n//\tblockB := \"...\\n...\\n...\"\n//\tblockA := \"...\\n...\\n...\\n...\\n...\"\n//\n//\t// Join 20% from the top\n//\tstr := lipgloss.JoinHorizontal(0.2, blockA, blockB)\n//\n//\t// Join on the top edge\n//\tstr := lipgloss.JoinHorizontal(lipgloss.Top, blockA, blockB)\nfunc JoinHorizontal(pos Position, strs ...string) string {\n\tif len(strs) == 0 {\n\t\treturn \"\"\n\t}\n\tif len(strs) == 1 {\n\t\treturn strs[0]\n\t}\n\n\tvar (\n\t\t// Groups of strings broken into multiple lines\n\t\tblocks = make([][]string, len(strs))\n\n\t\t// Max line widths for the above text blocks\n\t\tmaxWidths = make([]int, len(strs))\n\n\t\t// Height of the tallest block\n\t\tmaxHeight int\n\t)\n\n\t// Break text blocks into lines and get max widths for each text block\n\tfor i, str := range strs {\n\t\tblocks[i], maxWidths[i] = getLines(str)\n\t\tif len(blocks[i]) > maxHeight {\n\t\t\tmaxHeight = len(blocks[i])\n\t\t}\n\t}\n\n\t// Add extra lines to make each side the same height\n\tfor i := range blocks {\n\t\tif len(blocks[i]) >= maxHeight {\n\t\t\tcontinue\n\t\t}\n\n\t\textraLines := make([]string, maxHeight-len(blocks[i]))\n\n\t\tswitch pos { //nolint:exhaustive\n\t\tcase Top:\n\t\t\tblocks[i] = append(blocks[i], extraLines...)\n\n\t\tcase Bottom:\n\t\t\tblocks[i] = append(extraLines, blocks[i]...)\n\n\t\tdefault: // Somewhere in the middle\n\t\t\tn := len(extraLines)\n\t\t\tsplit := int(math.Round(float64(n) * pos.value()))\n\t\t\ttop := n - split\n\t\t\tbottom := n - top\n\n\t\t\tblocks[i] = append(extraLines[top:], blocks[i]...)\n\t\t\tblocks[i] = append(blocks[i], extraLines[bottom:]...)\n\t\t}\n\t}\n\n\t// Merge lines\n\tvar b strings.Builder\n\tfor i := range blocks[0] { // remember, all blocks have the same number of members now\n\t\tfor j, block := range blocks {\n\t\t\tb.WriteString(block[i])\n\n\t\t\t// Also make lines the same length\n\t\t\tb.WriteString(strings.Repeat(\" \", maxWidths[j]-ansi.StringWidth(block[i])))\n\t\t}\n\t\tif i < len(blocks[0])-1 {\n\t\t\tb.WriteRune('\\n')\n\t\t}\n\t}\n\n\treturn b.String()\n}\n\n// JoinVertical is a utility function for vertically joining two potentially\n// multi-lined strings along a horizontal axis. The first argument is the\n// position, with 0 being all the way to the left and 1 being all the way to\n// the right.\n//\n// If you just want to align to the left, right or center you may as well just\n// use the helper constants Left, Center, and Right.\n//\n// Example:\n//\n//\tblockB := \"...\\n...\\n...\"\n//\tblockA := \"...\\n...\\n...\\n...\\n...\"\n//\n//\t// Join 20% from the top\n//\tstr := lipgloss.JoinVertical(0.2, blockA, blockB)\n//\n//\t// Join on the right edge\n//\tstr := lipgloss.JoinVertical(lipgloss.Right, blockA, blockB)\nfunc JoinVertical(pos Position, strs ...string) string {\n\tif len(strs) == 0 {\n\t\treturn \"\"\n\t}\n\tif len(strs) == 1 {\n\t\treturn strs[0]\n\t}\n\n\tvar (\n\t\tblocks   = make([][]string, len(strs))\n\t\tmaxWidth int\n\t)\n\n\tfor i := range strs {\n\t\tvar w int\n\t\tblocks[i], w = getLines(strs[i])\n\t\tif w > maxWidth {\n\t\t\tmaxWidth = w\n\t\t}\n\t}\n\n\tvar b strings.Builder\n\tfor i, block := range blocks {\n\t\tfor j, line := range block {\n\t\t\tw := maxWidth - ansi.StringWidth(line)\n\n\t\t\tswitch pos { //nolint:exhaustive\n\t\t\tcase Left:\n\t\t\t\tb.WriteString(line)\n\t\t\t\tb.WriteString(strings.Repeat(\" \", w))\n\n\t\t\tcase Right:\n\t\t\t\tb.WriteString(strings.Repeat(\" \", w))\n\t\t\t\tb.WriteString(line)\n\n\t\t\tdefault: // Somewhere in the middle\n\t\t\t\tif w < 1 {\n\t\t\t\t\tb.WriteString(line)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tsplit := int(math.Round(float64(w) * pos.value()))\n\t\t\t\tright := w - split\n\t\t\t\tleft := w - right\n\n\t\t\t\tb.WriteString(strings.Repeat(\" \", left))\n\t\t\t\tb.WriteString(line)\n\t\t\t\tb.WriteString(strings.Repeat(\" \", right))\n\t\t\t}\n\n\t\t\t// Write a newline as long as we're not on the last line of the\n\t\t\t// last block.\n\t\t\tif !(i == len(blocks)-1 && j == len(block)-1) {\n\t\t\t\tb.WriteRune('\\n')\n\t\t\t}\n\t\t}\n\t}\n\n\treturn b.String()\n}\n"
        },
        {
          "name": "join_test.go",
          "type": "blob",
          "size": 1.0732421875,
          "content": "package lipgloss\n\nimport \"testing\"\n\nfunc TestJoinVertical(t *testing.T) {\n\ttype test struct {\n\t\tname     string\n\t\tresult   string\n\t\texpected string\n\t}\n\ttests := []test{\n\t\t{\"pos0\", JoinVertical(Left, \"A\", \"BBBB\"), \"A   \\nBBBB\"},\n\t\t{\"pos1\", JoinVertical(Right, \"A\", \"BBBB\"), \"   A\\nBBBB\"},\n\t\t{\"pos0.25\", JoinVertical(0.25, \"A\", \"BBBB\"), \" A  \\nBBBB\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tif test.result != test.expected {\n\t\t\t\tt.Errorf(\"Got \\n%s\\n, expected \\n%s\\n\", test.result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestJoinHorizontal(t *testing.T) {\n\ttype test struct {\n\t\tname     string\n\t\tresult   string\n\t\texpected string\n\t}\n\ttests := []test{\n\t\t{\"pos0\", JoinHorizontal(Top, \"A\", \"B\\nB\\nB\\nB\"), \"AB\\n B\\n B\\n B\"},\n\t\t{\"pos1\", JoinHorizontal(Bottom, \"A\", \"B\\nB\\nB\\nB\"), \" B\\n B\\n B\\nAB\"},\n\t\t{\"pos0.25\", JoinHorizontal(0.25, \"A\", \"B\\nB\\nB\\nB\"), \" B\\nAB\\n B\\n B\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tif test.result != test.expected {\n\t\t\t\tt.Errorf(\"Got \\n%s\\n, expected \\n%s\\n\", test.result, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "list",
          "type": "tree",
          "content": null
        },
        {
          "name": "position.go",
          "type": "blob",
          "size": 4.291015625,
          "content": "package lipgloss\n\nimport (\n\t\"math\"\n\t\"strings\"\n\n\t\"github.com/charmbracelet/x/ansi\"\n)\n\n// Position represents a position along a horizontal or vertical axis. It's in\n// situations where an axis is involved, like alignment, joining, placement and\n// so on.\n//\n// A value of 0 represents the start (the left or top) and 1 represents the end\n// (the right or bottom). 0.5 represents the center.\n//\n// There are constants Top, Bottom, Center, Left and Right in this package that\n// can be used to aid readability.\ntype Position float64\n\nfunc (p Position) value() float64 {\n\treturn math.Min(1, math.Max(0, float64(p)))\n}\n\n// Position aliases.\nconst (\n\tTop    Position = 0.0\n\tBottom Position = 1.0\n\tCenter Position = 0.5\n\tLeft   Position = 0.0\n\tRight  Position = 1.0\n)\n\n// Place places a string or text block vertically in an unstyled box of a given\n// width or height.\nfunc Place(width, height int, hPos, vPos Position, str string, opts ...WhitespaceOption) string {\n\treturn renderer.Place(width, height, hPos, vPos, str, opts...)\n}\n\n// Place places a string or text block vertically in an unstyled box of a given\n// width or height.\nfunc (r *Renderer) Place(width, height int, hPos, vPos Position, str string, opts ...WhitespaceOption) string {\n\treturn r.PlaceVertical(height, vPos, r.PlaceHorizontal(width, hPos, str, opts...), opts...)\n}\n\n// PlaceHorizontal places a string or text block horizontally in an unstyled\n// block of a given width. If the given width is shorter than the max width of\n// the string (measured by its longest line) this will be a noop.\nfunc PlaceHorizontal(width int, pos Position, str string, opts ...WhitespaceOption) string {\n\treturn renderer.PlaceHorizontal(width, pos, str, opts...)\n}\n\n// PlaceHorizontal places a string or text block horizontally in an unstyled\n// block of a given width. If the given width is shorter than the max width of\n// the string (measured by its longest line) this will be a noöp.\nfunc (r *Renderer) PlaceHorizontal(width int, pos Position, str string, opts ...WhitespaceOption) string {\n\tlines, contentWidth := getLines(str)\n\tgap := width - contentWidth\n\n\tif gap <= 0 {\n\t\treturn str\n\t}\n\n\tws := newWhitespace(r, opts...)\n\n\tvar b strings.Builder\n\tfor i, l := range lines {\n\t\t// Is this line shorter than the longest line?\n\t\tshort := max(0, contentWidth-ansi.StringWidth(l))\n\n\t\tswitch pos { //nolint:exhaustive\n\t\tcase Left:\n\t\t\tb.WriteString(l)\n\t\t\tb.WriteString(ws.render(gap + short))\n\n\t\tcase Right:\n\t\t\tb.WriteString(ws.render(gap + short))\n\t\t\tb.WriteString(l)\n\n\t\tdefault: // somewhere in the middle\n\t\t\ttotalGap := gap + short\n\n\t\t\tsplit := int(math.Round(float64(totalGap) * pos.value()))\n\t\t\tleft := totalGap - split\n\t\t\tright := totalGap - left\n\n\t\t\tb.WriteString(ws.render(left))\n\t\t\tb.WriteString(l)\n\t\t\tb.WriteString(ws.render(right))\n\t\t}\n\n\t\tif i < len(lines)-1 {\n\t\t\tb.WriteRune('\\n')\n\t\t}\n\t}\n\n\treturn b.String()\n}\n\n// PlaceVertical places a string or text block vertically in an unstyled block\n// of a given height. If the given height is shorter than the height of the\n// string (measured by its newlines) then this will be a noop.\nfunc PlaceVertical(height int, pos Position, str string, opts ...WhitespaceOption) string {\n\treturn renderer.PlaceVertical(height, pos, str, opts...)\n}\n\n// PlaceVertical places a string or text block vertically in an unstyled block\n// of a given height. If the given height is shorter than the height of the\n// string (measured by its newlines) then this will be a noöp.\nfunc (r *Renderer) PlaceVertical(height int, pos Position, str string, opts ...WhitespaceOption) string {\n\tcontentHeight := strings.Count(str, \"\\n\") + 1\n\tgap := height - contentHeight\n\n\tif gap <= 0 {\n\t\treturn str\n\t}\n\n\tws := newWhitespace(r, opts...)\n\n\t_, width := getLines(str)\n\temptyLine := ws.render(width)\n\tb := strings.Builder{}\n\n\tswitch pos { //nolint:exhaustive\n\tcase Top:\n\t\tb.WriteString(str)\n\t\tb.WriteRune('\\n')\n\t\tfor i := 0; i < gap; i++ {\n\t\t\tb.WriteString(emptyLine)\n\t\t\tif i < gap-1 {\n\t\t\t\tb.WriteRune('\\n')\n\t\t\t}\n\t\t}\n\n\tcase Bottom:\n\t\tb.WriteString(strings.Repeat(emptyLine+\"\\n\", gap))\n\t\tb.WriteString(str)\n\n\tdefault: // Somewhere in the middle\n\t\tsplit := int(math.Round(float64(gap) * pos.value()))\n\t\ttop := gap - split\n\t\tbottom := gap - top\n\n\t\tb.WriteString(strings.Repeat(emptyLine+\"\\n\", top))\n\t\tb.WriteString(str)\n\n\t\tfor i := 0; i < bottom; i++ {\n\t\t\tb.WriteRune('\\n')\n\t\t\tb.WriteString(emptyLine)\n\t\t}\n\t}\n\n\treturn b.String()\n}\n"
        },
        {
          "name": "ranges.go",
          "type": "blob",
          "size": 1.1455078125,
          "content": "package lipgloss\n\nimport (\n\t\"strings\"\n\n\t\"github.com/charmbracelet/x/ansi\"\n)\n\n// StyleRanges allows to, given a string, style ranges of it differently.\n// The function will take into account existing styles.\n// Ranges should not overlap.\nfunc StyleRanges(s string, ranges ...Range) string {\n\tif len(ranges) == 0 {\n\t\treturn s\n\t}\n\n\tvar buf strings.Builder\n\tlastIdx := 0\n\tstripped := ansi.Strip(s)\n\n\t// Use Truncate and TruncateLeft to style match.MatchedIndexes without\n\t// losing the original option style:\n\tfor _, rng := range ranges {\n\t\t// Add the text before this match\n\t\tif rng.Start > lastIdx {\n\t\t\tbuf.WriteString(ansi.Cut(s, lastIdx, rng.Start))\n\t\t}\n\t\t// Add the matched range with its highlight\n\t\tbuf.WriteString(rng.Style.Render(ansi.Cut(stripped, rng.Start, rng.End)))\n\t\tlastIdx = rng.End\n\t}\n\n\t// Add any remaining text after the last match\n\tbuf.WriteString(ansi.TruncateLeft(s, lastIdx, \"\"))\n\n\treturn buf.String()\n}\n\n// NewRange returns a range that can be used with [StyleRanges].\nfunc NewRange(start, end int, style Style) Range {\n\treturn Range{start, end, style}\n}\n\n// Range to be used with [StyleRanges].\ntype Range struct {\n\tStart, End int\n\tStyle      Style\n}\n"
        },
        {
          "name": "ranges_test.go",
          "type": "blob",
          "size": 2.37890625,
          "content": "package lipgloss\n\nimport (\n\t\"testing\"\n\n\t\"github.com/muesli/termenv\"\n)\n\nfunc TestStyleRanges(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    string\n\t\tranges   []Range\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty ranges\",\n\t\t\tinput:    \"hello world\",\n\t\t\tranges:   []Range{},\n\t\t\texpected: \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname:  \"single range in middle\",\n\t\t\tinput: \"hello world\",\n\t\t\tranges: []Range{\n\t\t\t\tNewRange(6, 11, NewStyle().Bold(true)),\n\t\t\t},\n\t\t\texpected: \"hello \\x1b[1mworld\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tname:  \"multiple ranges\",\n\t\t\tinput: \"hello world\",\n\t\t\tranges: []Range{\n\t\t\t\tNewRange(0, 5, NewStyle().Bold(true)),\n\t\t\t\tNewRange(6, 11, NewStyle().Italic(true)),\n\t\t\t},\n\t\t\texpected: \"\\x1b[1mhello\\x1b[0m \\x1b[3mworld\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tname:  \"overlapping with existing ANSI\",\n\t\t\tinput: \"hello \\x1b[32mworld\\x1b[0m\",\n\t\t\tranges: []Range{\n\t\t\t\tNewRange(0, 5, NewStyle().Bold(true)),\n\t\t\t},\n\t\t\texpected: \"\\x1b[1mhello\\x1b[0m \\x1b[32mworld\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tname:  \"style at start\",\n\t\t\tinput: \"hello world\",\n\t\t\tranges: []Range{\n\t\t\t\tNewRange(0, 5, NewStyle().Bold(true)),\n\t\t\t},\n\t\t\texpected: \"\\x1b[1mhello\\x1b[0m world\",\n\t\t},\n\t\t{\n\t\t\tname:  \"style at end\",\n\t\t\tinput: \"hello world\",\n\t\t\tranges: []Range{\n\t\t\t\tNewRange(6, 11, NewStyle().Bold(true)),\n\t\t\t},\n\t\t\texpected: \"hello \\x1b[1mworld\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tname:  \"multiple styles with gap\",\n\t\t\tinput: \"hello beautiful world\",\n\t\t\tranges: []Range{\n\t\t\t\tNewRange(0, 5, NewStyle().Bold(true)),\n\t\t\t\tNewRange(16, 23, NewStyle().Italic(true)),\n\t\t\t},\n\t\t\texpected: \"\\x1b[1mhello\\x1b[0m beautiful \\x1b[3mworld\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tname:  \"adjacent ranges\",\n\t\t\tinput: \"hello world\",\n\t\t\tranges: []Range{\n\t\t\t\tNewRange(0, 5, NewStyle().Bold(true)),\n\t\t\t\tNewRange(6, 11, NewStyle().Italic(true)),\n\t\t\t},\n\t\t\texpected: \"\\x1b[1mhello\\x1b[0m \\x1b[3mworld\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tname:  \"wide-width characters\",\n\t\t\tinput: \"Hello 你好 世界\",\n\t\t\tranges: []Range{\n\t\t\t\tNewRange(0, 5, NewStyle().Bold(true)),    // \"Hello\"\n\t\t\t\tNewRange(7, 10, NewStyle().Italic(true)), // \"你好\"\n\t\t\t\tNewRange(11, 50, NewStyle().Bold(true)),  // \"世界\"\n\t\t\t},\n\t\t\texpected: \"\\x1b[1mHello\\x1b[0m \\x1b[3m你好\\x1b[0m \\x1b[1m世界\\x1b[0m\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\trenderer.SetColorProfile(termenv.ANSI)\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := StyleRanges(tt.input, tt.ranges...)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"StyleRanges()\\n got = %q\\nwant = %q\\n\", result, tt.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "renderer.go",
          "type": "blob",
          "size": 5.0048828125,
          "content": "package lipgloss\n\nimport (\n\t\"io\"\n\t\"sync\"\n\n\t\"github.com/muesli/termenv\"\n)\n\n// We're manually creating the struct here to avoid initializing the output and\n// query the terminal multiple times.\nvar renderer = &Renderer{\n\toutput: termenv.DefaultOutput(),\n}\n\n// Renderer is a lipgloss terminal renderer.\ntype Renderer struct {\n\toutput            *termenv.Output\n\tcolorProfile      termenv.Profile\n\thasDarkBackground bool\n\n\tgetColorProfile      sync.Once\n\texplicitColorProfile bool\n\n\tgetBackgroundColor      sync.Once\n\texplicitBackgroundColor bool\n\n\tmtx sync.RWMutex\n}\n\n// DefaultRenderer returns the default renderer.\nfunc DefaultRenderer() *Renderer {\n\treturn renderer\n}\n\n// SetDefaultRenderer sets the default global renderer.\nfunc SetDefaultRenderer(r *Renderer) {\n\trenderer = r\n}\n\n// NewRenderer creates a new Renderer.\n//\n// w will be used to determine the terminal's color capabilities.\nfunc NewRenderer(w io.Writer, opts ...termenv.OutputOption) *Renderer {\n\tr := &Renderer{\n\t\toutput: termenv.NewOutput(w, opts...),\n\t}\n\treturn r\n}\n\n// Output returns the termenv output.\nfunc (r *Renderer) Output() *termenv.Output {\n\tr.mtx.RLock()\n\tdefer r.mtx.RUnlock()\n\treturn r.output\n}\n\n// SetOutput sets the termenv output.\nfunc (r *Renderer) SetOutput(o *termenv.Output) {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\tr.output = o\n}\n\n// ColorProfile returns the detected termenv color profile.\nfunc (r *Renderer) ColorProfile() termenv.Profile {\n\tr.mtx.RLock()\n\tdefer r.mtx.RUnlock()\n\n\tif !r.explicitColorProfile {\n\t\tr.getColorProfile.Do(func() {\n\t\t\t// NOTE: we don't need to lock here because sync.Once provides its\n\t\t\t// own locking mechanism.\n\t\t\tr.colorProfile = r.output.EnvColorProfile()\n\t\t})\n\t}\n\n\treturn r.colorProfile\n}\n\n// ColorProfile returns the detected termenv color profile.\nfunc ColorProfile() termenv.Profile {\n\treturn renderer.ColorProfile()\n}\n\n// SetColorProfile sets the color profile on the renderer. This function exists\n// mostly for testing purposes so that you can assure you're testing against\n// a specific profile.\n//\n// Outside of testing you likely won't want to use this function as the color\n// profile will detect and cache the terminal's color capabilities and choose\n// the best available profile.\n//\n// Available color profiles are:\n//\n//\ttermenv.Ascii     // no color, 1-bit\n//\ttermenv.ANSI      //16 colors, 4-bit\n//\ttermenv.ANSI256   // 256 colors, 8-bit\n//\ttermenv.TrueColor // 16,777,216 colors, 24-bit\n//\n// This function is thread-safe.\nfunc (r *Renderer) SetColorProfile(p termenv.Profile) {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tr.colorProfile = p\n\tr.explicitColorProfile = true\n}\n\n// SetColorProfile sets the color profile on the default renderer. This\n// function exists mostly for testing purposes so that you can assure you're\n// testing against a specific profile.\n//\n// Outside of testing you likely won't want to use this function as the color\n// profile will detect and cache the terminal's color capabilities and choose\n// the best available profile.\n//\n// Available color profiles are:\n//\n//\ttermenv.Ascii     // no color, 1-bit\n//\ttermenv.ANSI      //16 colors, 4-bit\n//\ttermenv.ANSI256   // 256 colors, 8-bit\n//\ttermenv.TrueColor // 16,777,216 colors, 24-bit\n//\n// This function is thread-safe.\nfunc SetColorProfile(p termenv.Profile) {\n\trenderer.SetColorProfile(p)\n}\n\n// HasDarkBackground returns whether or not the terminal has a dark background.\nfunc HasDarkBackground() bool {\n\treturn renderer.HasDarkBackground()\n}\n\n// HasDarkBackground returns whether or not the renderer will render to a dark\n// background. A dark background can either be auto-detected, or set explicitly\n// on the renderer.\nfunc (r *Renderer) HasDarkBackground() bool {\n\tr.mtx.RLock()\n\tdefer r.mtx.RUnlock()\n\n\tif !r.explicitBackgroundColor {\n\t\tr.getBackgroundColor.Do(func() {\n\t\t\t// NOTE: we don't need to lock here because sync.Once provides its\n\t\t\t// own locking mechanism.\n\t\t\tr.hasDarkBackground = r.output.HasDarkBackground()\n\t\t})\n\t}\n\n\treturn r.hasDarkBackground\n}\n\n// SetHasDarkBackground sets the background color detection value for the\n// default renderer. This function exists mostly for testing purposes so that\n// you can assure you're testing against a specific background color setting.\n//\n// Outside of testing you likely won't want to use this function as the\n// backgrounds value will be automatically detected and cached against the\n// terminal's current background color setting.\n//\n// This function is thread-safe.\nfunc SetHasDarkBackground(b bool) {\n\trenderer.SetHasDarkBackground(b)\n}\n\n// SetHasDarkBackground sets the background color detection value on the\n// renderer. This function exists mostly for testing purposes so that you can\n// assure you're testing against a specific background color setting.\n//\n// Outside of testing you likely won't want to use this function as the\n// backgrounds value will be automatically detected and cached against the\n// terminal's current background color setting.\n//\n// This function is thread-safe.\nfunc (r *Renderer) SetHasDarkBackground(b bool) {\n\tr.mtx.Lock()\n\tdefer r.mtx.Unlock()\n\n\tr.hasDarkBackground = b\n\tr.explicitBackgroundColor = true\n}\n"
        },
        {
          "name": "renderer_test.go",
          "type": "blob",
          "size": 1.0625,
          "content": "package lipgloss\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/muesli/termenv\"\n)\n\nfunc TestRendererHasDarkBackground(t *testing.T) {\n\tr1 := NewRenderer(os.Stdout)\n\tr1.SetHasDarkBackground(false)\n\tif r1.HasDarkBackground() {\n\t\tt.Error(\"Expected renderer to have light background\")\n\t}\n\tr2 := NewRenderer(os.Stdout)\n\tr2.SetHasDarkBackground(true)\n\tif !r2.HasDarkBackground() {\n\t\tt.Error(\"Expected renderer to have dark background\")\n\t}\n}\n\nfunc TestRendererWithOutput(t *testing.T) {\n\tf, err := os.Create(t.Name())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer f.Close()\n\tdefer os.Remove(f.Name())\n\tr := NewRenderer(f)\n\tr.SetColorProfile(termenv.TrueColor)\n\tif r.ColorProfile() != termenv.TrueColor {\n\t\tt.Error(\"Expected renderer to use true color\")\n\t}\n}\n\nfunc TestRace(t *testing.T) {\n\tr := NewRenderer(io.Discard)\n\to := r.Output()\n\n\tfor i := 0; i < 100; i++ {\n\t\tt.Run(\"SetColorProfile\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tr.SetHasDarkBackground(false)\n\t\t\tr.HasDarkBackground()\n\t\t\tr.SetOutput(o)\n\t\t\tr.SetColorProfile(termenv.ANSI256)\n\t\t\tr.SetHasDarkBackground(true)\n\t\t\tr.Output()\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "runes.go",
          "type": "blob",
          "size": 0.8701171875,
          "content": "package lipgloss\n\nimport (\n\t\"strings\"\n)\n\n// StyleRunes apply a given style to runes at the given indices in the string.\n// Note that you must provide styling options for both matched and unmatched\n// runes. Indices out of bounds will be ignored.\nfunc StyleRunes(str string, indices []int, matched, unmatched Style) string {\n\t// Convert slice of indices to a map for easier lookups\n\tm := make(map[int]struct{})\n\tfor _, i := range indices {\n\t\tm[i] = struct{}{}\n\t}\n\n\tvar (\n\t\tout   strings.Builder\n\t\tgroup strings.Builder\n\t\tstyle Style\n\t\trunes = []rune(str)\n\t)\n\n\tfor i, r := range runes {\n\t\tgroup.WriteRune(r)\n\n\t\t_, matches := m[i]\n\t\t_, nextMatches := m[i+1]\n\n\t\tif matches != nextMatches || i == len(runes)-1 {\n\t\t\t// Flush\n\t\t\tif matches {\n\t\t\t\tstyle = matched\n\t\t\t} else {\n\t\t\t\tstyle = unmatched\n\t\t\t}\n\t\t\tout.WriteString(style.Render(group.String()))\n\t\t\tgroup.Reset()\n\t\t}\n\t}\n\n\treturn out.String()\n}\n"
        },
        {
          "name": "runes_test.go",
          "type": "blob",
          "size": 1.15625,
          "content": "package lipgloss\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestStyleRunes(t *testing.T) {\n\tmatchedStyle := NewStyle().Reverse(true)\n\tunmatchedStyle := NewStyle()\n\n\ttt := []struct {\n\t\tname     string\n\t\tinput    string\n\t\tindices  []int\n\t\texpected string\n\t}{\n\t\t{\n\t\t\t\"hello 0\",\n\t\t\t\"hello\",\n\t\t\t[]int{0},\n\t\t\t\"\\x1b[7mh\\x1b[0mello\",\n\t\t},\n\t\t{\n\t\t\t\"你好 1\",\n\t\t\t\"你好\",\n\t\t\t[]int{1},\n\t\t\t\"你\\x1b[7m好\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\t\"hello 你好 6,7\",\n\t\t\t\"hello 你好\",\n\t\t\t[]int{6, 7},\n\t\t\t\"hello \\x1b[7m你好\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\t\"hello 1,3\",\n\t\t\t\"hello\",\n\t\t\t[]int{1, 3},\n\t\t\t\"h\\x1b[7me\\x1b[0ml\\x1b[7ml\\x1b[0mo\",\n\t\t},\n\t\t{\n\t\t\t\"你好 0,1\",\n\t\t\t\"你好\",\n\t\t\t[]int{0, 1},\n\t\t\t\"\\x1b[7m你好\\x1b[0m\",\n\t\t},\n\t}\n\n\tfn := func(str string, indices []int) string {\n\t\treturn StyleRunes(str, indices, matchedStyle, unmatchedStyle)\n\t}\n\n\tfor _, tc := range tt {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tres := fn(tc.input, tc.indices)\n\t\t\tif res != tc.expected {\n\t\t\t\tt.Errorf(\"Expected:\\n\\n`%s`\\n`%s`\\n\\nActual Output:\\n\\n`%s`\\n`%s`\\n\\n\",\n\t\t\t\t\ttc.expected, formatEscapes(tc.expected),\n\t\t\t\t\tres, formatEscapes(res))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc formatEscapes(str string) string {\n\treturn strings.ReplaceAll(str, \"\\x1b\", \"\\\\x1b\")\n}\n"
        },
        {
          "name": "set.go",
          "type": "blob",
          "size": 22.0537109375,
          "content": "package lipgloss\n\n// Set a value on the underlying rules map.\nfunc (s *Style) set(key propKey, value interface{}) {\n\t// We don't allow negative integers on any of our other values, so just keep\n\t// them at zero or above. We could use uints instead, but the\n\t// conversions are a little tedious, so we're sticking with ints for\n\t// sake of usability.\n\tswitch key { //nolint:exhaustive\n\tcase foregroundKey:\n\t\ts.fgColor = colorOrNil(value)\n\tcase backgroundKey:\n\t\ts.bgColor = colorOrNil(value)\n\tcase widthKey:\n\t\ts.width = max(0, value.(int))\n\tcase heightKey:\n\t\ts.height = max(0, value.(int))\n\tcase alignHorizontalKey:\n\t\ts.alignHorizontal = value.(Position)\n\tcase alignVerticalKey:\n\t\ts.alignVertical = value.(Position)\n\tcase paddingTopKey:\n\t\ts.paddingTop = max(0, value.(int))\n\tcase paddingRightKey:\n\t\ts.paddingRight = max(0, value.(int))\n\tcase paddingBottomKey:\n\t\ts.paddingBottom = max(0, value.(int))\n\tcase paddingLeftKey:\n\t\ts.paddingLeft = max(0, value.(int))\n\tcase marginTopKey:\n\t\ts.marginTop = max(0, value.(int))\n\tcase marginRightKey:\n\t\ts.marginRight = max(0, value.(int))\n\tcase marginBottomKey:\n\t\ts.marginBottom = max(0, value.(int))\n\tcase marginLeftKey:\n\t\ts.marginLeft = max(0, value.(int))\n\tcase marginBackgroundKey:\n\t\ts.marginBgColor = colorOrNil(value)\n\tcase borderStyleKey:\n\t\ts.borderStyle = value.(Border)\n\tcase borderTopForegroundKey:\n\t\ts.borderTopFgColor = colorOrNil(value)\n\tcase borderRightForegroundKey:\n\t\ts.borderRightFgColor = colorOrNil(value)\n\tcase borderBottomForegroundKey:\n\t\ts.borderBottomFgColor = colorOrNil(value)\n\tcase borderLeftForegroundKey:\n\t\ts.borderLeftFgColor = colorOrNil(value)\n\tcase borderTopBackgroundKey:\n\t\ts.borderTopBgColor = colorOrNil(value)\n\tcase borderRightBackgroundKey:\n\t\ts.borderRightBgColor = colorOrNil(value)\n\tcase borderBottomBackgroundKey:\n\t\ts.borderBottomBgColor = colorOrNil(value)\n\tcase borderLeftBackgroundKey:\n\t\ts.borderLeftBgColor = colorOrNil(value)\n\tcase maxWidthKey:\n\t\ts.maxWidth = max(0, value.(int))\n\tcase maxHeightKey:\n\t\ts.maxHeight = max(0, value.(int))\n\tcase tabWidthKey:\n\t\t// TabWidth is the only property that may have a negative value (and\n\t\t// that negative value can be no less than -1).\n\t\ts.tabWidth = value.(int)\n\tcase transformKey:\n\t\ts.transform = value.(func(string) string)\n\tdefault:\n\t\tif v, ok := value.(bool); ok { //nolint:nestif\n\t\t\tif v {\n\t\t\t\ts.attrs |= int(key)\n\t\t\t} else {\n\t\t\t\ts.attrs &^= int(key)\n\t\t\t}\n\t\t} else if attrs, ok := value.(int); ok {\n\t\t\t// bool attrs\n\t\t\tif attrs&int(key) != 0 {\n\t\t\t\ts.attrs |= int(key)\n\t\t\t} else {\n\t\t\t\ts.attrs &^= int(key)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the prop on\n\ts.props = s.props.set(key)\n}\n\n// setFrom sets the property from another style.\nfunc (s *Style) setFrom(key propKey, i Style) {\n\tswitch key { //nolint:exhaustive\n\tcase foregroundKey:\n\t\ts.set(foregroundKey, i.fgColor)\n\tcase backgroundKey:\n\t\ts.set(backgroundKey, i.bgColor)\n\tcase widthKey:\n\t\ts.set(widthKey, i.width)\n\tcase heightKey:\n\t\ts.set(heightKey, i.height)\n\tcase alignHorizontalKey:\n\t\ts.set(alignHorizontalKey, i.alignHorizontal)\n\tcase alignVerticalKey:\n\t\ts.set(alignVerticalKey, i.alignVertical)\n\tcase paddingTopKey:\n\t\ts.set(paddingTopKey, i.paddingTop)\n\tcase paddingRightKey:\n\t\ts.set(paddingRightKey, i.paddingRight)\n\tcase paddingBottomKey:\n\t\ts.set(paddingBottomKey, i.paddingBottom)\n\tcase paddingLeftKey:\n\t\ts.set(paddingLeftKey, i.paddingLeft)\n\tcase marginTopKey:\n\t\ts.set(marginTopKey, i.marginTop)\n\tcase marginRightKey:\n\t\ts.set(marginRightKey, i.marginRight)\n\tcase marginBottomKey:\n\t\ts.set(marginBottomKey, i.marginBottom)\n\tcase marginLeftKey:\n\t\ts.set(marginLeftKey, i.marginLeft)\n\tcase marginBackgroundKey:\n\t\ts.set(marginBackgroundKey, i.marginBgColor)\n\tcase borderStyleKey:\n\t\ts.set(borderStyleKey, i.borderStyle)\n\tcase borderTopForegroundKey:\n\t\ts.set(borderTopForegroundKey, i.borderTopFgColor)\n\tcase borderRightForegroundKey:\n\t\ts.set(borderRightForegroundKey, i.borderRightFgColor)\n\tcase borderBottomForegroundKey:\n\t\ts.set(borderBottomForegroundKey, i.borderBottomFgColor)\n\tcase borderLeftForegroundKey:\n\t\ts.set(borderLeftForegroundKey, i.borderLeftFgColor)\n\tcase borderTopBackgroundKey:\n\t\ts.set(borderTopBackgroundKey, i.borderTopBgColor)\n\tcase borderRightBackgroundKey:\n\t\ts.set(borderRightBackgroundKey, i.borderRightBgColor)\n\tcase borderBottomBackgroundKey:\n\t\ts.set(borderBottomBackgroundKey, i.borderBottomBgColor)\n\tcase borderLeftBackgroundKey:\n\t\ts.set(borderLeftBackgroundKey, i.borderLeftBgColor)\n\tcase maxWidthKey:\n\t\ts.set(maxWidthKey, i.maxWidth)\n\tcase maxHeightKey:\n\t\ts.set(maxHeightKey, i.maxHeight)\n\tcase tabWidthKey:\n\t\ts.set(tabWidthKey, i.tabWidth)\n\tcase transformKey:\n\t\ts.set(transformKey, i.transform)\n\tdefault:\n\t\t// Set attributes for set bool properties\n\t\ts.set(key, i.attrs)\n\t}\n}\n\nfunc colorOrNil(c interface{}) TerminalColor {\n\tif c, ok := c.(TerminalColor); ok {\n\t\treturn c\n\t}\n\treturn nil\n}\n\n// Bold sets a bold formatting rule.\nfunc (s Style) Bold(v bool) Style {\n\ts.set(boldKey, v)\n\treturn s\n}\n\n// Italic sets an italic formatting rule. In some terminal emulators this will\n// render with \"reverse\" coloring if not italic font variant is available.\nfunc (s Style) Italic(v bool) Style {\n\ts.set(italicKey, v)\n\treturn s\n}\n\n// Underline sets an underline rule. By default, underlines will not be drawn on\n// whitespace like margins and padding. To change this behavior set\n// UnderlineSpaces.\nfunc (s Style) Underline(v bool) Style {\n\ts.set(underlineKey, v)\n\treturn s\n}\n\n// Strikethrough sets a strikethrough rule. By default, strikes will not be\n// drawn on whitespace like margins and padding. To change this behavior set\n// StrikethroughSpaces.\nfunc (s Style) Strikethrough(v bool) Style {\n\ts.set(strikethroughKey, v)\n\treturn s\n}\n\n// Reverse sets a rule for inverting foreground and background colors.\nfunc (s Style) Reverse(v bool) Style {\n\ts.set(reverseKey, v)\n\treturn s\n}\n\n// Blink sets a rule for blinking foreground text.\nfunc (s Style) Blink(v bool) Style {\n\ts.set(blinkKey, v)\n\treturn s\n}\n\n// Faint sets a rule for rendering the foreground color in a dimmer shade.\nfunc (s Style) Faint(v bool) Style {\n\ts.set(faintKey, v)\n\treturn s\n}\n\n// Foreground sets a foreground color.\n//\n//\t// Sets the foreground to blue\n//\ts := lipgloss.NewStyle().Foreground(lipgloss.Color(\"#0000ff\"))\n//\n//\t// Removes the foreground color\n//\ts.Foreground(lipgloss.NoColor)\nfunc (s Style) Foreground(c TerminalColor) Style {\n\ts.set(foregroundKey, c)\n\treturn s\n}\n\n// Background sets a background color.\nfunc (s Style) Background(c TerminalColor) Style {\n\ts.set(backgroundKey, c)\n\treturn s\n}\n\n// Width sets the width of the block before applying margins. The width, if\n// set, also determines where text will wrap.\nfunc (s Style) Width(i int) Style {\n\ts.set(widthKey, i)\n\treturn s\n}\n\n// Height sets the height of the block before applying margins. If the height of\n// the text block is less than this value after applying padding (or not), the\n// block will be set to this height.\nfunc (s Style) Height(i int) Style {\n\ts.set(heightKey, i)\n\treturn s\n}\n\n// Align is a shorthand method for setting horizontal and vertical alignment.\n//\n// With one argument, the position value is applied to the horizontal alignment.\n//\n// With two arguments, the value is applied to the horizontal and vertical\n// alignments, in that order.\nfunc (s Style) Align(p ...Position) Style {\n\tif len(p) > 0 {\n\t\ts.set(alignHorizontalKey, p[0])\n\t}\n\tif len(p) > 1 {\n\t\ts.set(alignVerticalKey, p[1])\n\t}\n\treturn s\n}\n\n// AlignHorizontal sets a horizontal text alignment rule.\nfunc (s Style) AlignHorizontal(p Position) Style {\n\ts.set(alignHorizontalKey, p)\n\treturn s\n}\n\n// AlignVertical sets a vertical text alignment rule.\nfunc (s Style) AlignVertical(p Position) Style {\n\ts.set(alignVerticalKey, p)\n\treturn s\n}\n\n// Padding is a shorthand method for setting padding on all sides at once.\n//\n// With one argument, the value is applied to all sides.\n//\n// With two arguments, the value is applied to the vertical and horizontal\n// sides, in that order.\n//\n// With three arguments, the value is applied to the top side, the horizontal\n// sides, and the bottom side, in that order.\n//\n// With four arguments, the value is applied clockwise starting from the top\n// side, followed by the right side, then the bottom, and finally the left.\n//\n// With more than four arguments no padding will be added.\nfunc (s Style) Padding(i ...int) Style {\n\ttop, right, bottom, left, ok := whichSidesInt(i...)\n\tif !ok {\n\t\treturn s\n\t}\n\n\ts.set(paddingTopKey, top)\n\ts.set(paddingRightKey, right)\n\ts.set(paddingBottomKey, bottom)\n\ts.set(paddingLeftKey, left)\n\treturn s\n}\n\n// PaddingLeft adds padding on the left.\nfunc (s Style) PaddingLeft(i int) Style {\n\ts.set(paddingLeftKey, i)\n\treturn s\n}\n\n// PaddingRight adds padding on the right.\nfunc (s Style) PaddingRight(i int) Style {\n\ts.set(paddingRightKey, i)\n\treturn s\n}\n\n// PaddingTop adds padding to the top of the block.\nfunc (s Style) PaddingTop(i int) Style {\n\ts.set(paddingTopKey, i)\n\treturn s\n}\n\n// PaddingBottom adds padding to the bottom of the block.\nfunc (s Style) PaddingBottom(i int) Style {\n\ts.set(paddingBottomKey, i)\n\treturn s\n}\n\n// ColorWhitespace determines whether or not the background color should be\n// applied to the padding. This is true by default as it's more than likely the\n// desired and expected behavior, but it can be disabled for certain graphic\n// effects.\n//\n// Deprecated: Just use margins and padding.\nfunc (s Style) ColorWhitespace(v bool) Style {\n\ts.set(colorWhitespaceKey, v)\n\treturn s\n}\n\n// Margin is a shorthand method for setting margins on all sides at once.\n//\n// With one argument, the value is applied to all sides.\n//\n// With two arguments, the value is applied to the vertical and horizontal\n// sides, in that order.\n//\n// With three arguments, the value is applied to the top side, the horizontal\n// sides, and the bottom side, in that order.\n//\n// With four arguments, the value is applied clockwise starting from the top\n// side, followed by the right side, then the bottom, and finally the left.\n//\n// With more than four arguments no margin will be added.\nfunc (s Style) Margin(i ...int) Style {\n\ttop, right, bottom, left, ok := whichSidesInt(i...)\n\tif !ok {\n\t\treturn s\n\t}\n\n\ts.set(marginTopKey, top)\n\ts.set(marginRightKey, right)\n\ts.set(marginBottomKey, bottom)\n\ts.set(marginLeftKey, left)\n\treturn s\n}\n\n// MarginLeft sets the value of the left margin.\nfunc (s Style) MarginLeft(i int) Style {\n\ts.set(marginLeftKey, i)\n\treturn s\n}\n\n// MarginRight sets the value of the right margin.\nfunc (s Style) MarginRight(i int) Style {\n\ts.set(marginRightKey, i)\n\treturn s\n}\n\n// MarginTop sets the value of the top margin.\nfunc (s Style) MarginTop(i int) Style {\n\ts.set(marginTopKey, i)\n\treturn s\n}\n\n// MarginBottom sets the value of the bottom margin.\nfunc (s Style) MarginBottom(i int) Style {\n\ts.set(marginBottomKey, i)\n\treturn s\n}\n\n// MarginBackground sets the background color of the margin. Note that this is\n// also set when inheriting from a style with a background color. In that case\n// the background color on that style will set the margin color on this style.\nfunc (s Style) MarginBackground(c TerminalColor) Style {\n\ts.set(marginBackgroundKey, c)\n\treturn s\n}\n\n// Border is shorthand for setting the border style and which sides should\n// have a border at once. The variadic argument sides works as follows:\n//\n// With one value, the value is applied to all sides.\n//\n// With two values, the values are applied to the vertical and horizontal\n// sides, in that order.\n//\n// With three values, the values are applied to the top side, the horizontal\n// sides, and the bottom side, in that order.\n//\n// With four values, the values are applied clockwise starting from the top\n// side, followed by the right side, then the bottom, and finally the left.\n//\n// With more than four arguments the border will be applied to all sides.\n//\n// Examples:\n//\n//\t// Applies borders to the top and bottom only\n//\tlipgloss.NewStyle().Border(lipgloss.NormalBorder(), true, false)\n//\n//\t// Applies rounded borders to the right and bottom only\n//\tlipgloss.NewStyle().Border(lipgloss.RoundedBorder(), false, true, true, false)\nfunc (s Style) Border(b Border, sides ...bool) Style {\n\ts.set(borderStyleKey, b)\n\n\ttop, right, bottom, left, ok := whichSidesBool(sides...)\n\tif !ok {\n\t\ttop = true\n\t\tright = true\n\t\tbottom = true\n\t\tleft = true\n\t}\n\n\ts.set(borderTopKey, top)\n\ts.set(borderRightKey, right)\n\ts.set(borderBottomKey, bottom)\n\ts.set(borderLeftKey, left)\n\n\treturn s\n}\n\n// BorderStyle defines the Border on a style. A Border contains a series of\n// definitions for the sides and corners of a border.\n//\n// Note that if border visibility has not been set for any sides when setting\n// the border style, the border will be enabled for all sides during rendering.\n//\n// You can define border characters as you'd like, though several default\n// styles are included: NormalBorder(), RoundedBorder(), BlockBorder(),\n// OuterHalfBlockBorder(), InnerHalfBlockBorder(), ThickBorder(),\n// and DoubleBorder().\n//\n// Example:\n//\n//\tlipgloss.NewStyle().BorderStyle(lipgloss.ThickBorder())\nfunc (s Style) BorderStyle(b Border) Style {\n\ts.set(borderStyleKey, b)\n\treturn s\n}\n\n// BorderTop determines whether or not to draw a top border.\nfunc (s Style) BorderTop(v bool) Style {\n\ts.set(borderTopKey, v)\n\treturn s\n}\n\n// BorderRight determines whether or not to draw a right border.\nfunc (s Style) BorderRight(v bool) Style {\n\ts.set(borderRightKey, v)\n\treturn s\n}\n\n// BorderBottom determines whether or not to draw a bottom border.\nfunc (s Style) BorderBottom(v bool) Style {\n\ts.set(borderBottomKey, v)\n\treturn s\n}\n\n// BorderLeft determines whether or not to draw a left border.\nfunc (s Style) BorderLeft(v bool) Style {\n\ts.set(borderLeftKey, v)\n\treturn s\n}\n\n// BorderForeground is a shorthand function for setting all of the\n// foreground colors of the borders at once. The arguments work as follows:\n//\n// With one argument, the argument is applied to all sides.\n//\n// With two arguments, the arguments are applied to the vertical and horizontal\n// sides, in that order.\n//\n// With three arguments, the arguments are applied to the top side, the\n// horizontal sides, and the bottom side, in that order.\n//\n// With four arguments, the arguments are applied clockwise starting from the\n// top side, followed by the right side, then the bottom, and finally the left.\n//\n// With more than four arguments nothing will be set.\nfunc (s Style) BorderForeground(c ...TerminalColor) Style {\n\tif len(c) == 0 {\n\t\treturn s\n\t}\n\n\ttop, right, bottom, left, ok := whichSidesColor(c...)\n\tif !ok {\n\t\treturn s\n\t}\n\n\ts.set(borderTopForegroundKey, top)\n\ts.set(borderRightForegroundKey, right)\n\ts.set(borderBottomForegroundKey, bottom)\n\ts.set(borderLeftForegroundKey, left)\n\n\treturn s\n}\n\n// BorderTopForeground set the foreground color for the top of the border.\nfunc (s Style) BorderTopForeground(c TerminalColor) Style {\n\ts.set(borderTopForegroundKey, c)\n\treturn s\n}\n\n// BorderRightForeground sets the foreground color for the right side of the\n// border.\nfunc (s Style) BorderRightForeground(c TerminalColor) Style {\n\ts.set(borderRightForegroundKey, c)\n\treturn s\n}\n\n// BorderBottomForeground sets the foreground color for the bottom of the\n// border.\nfunc (s Style) BorderBottomForeground(c TerminalColor) Style {\n\ts.set(borderBottomForegroundKey, c)\n\treturn s\n}\n\n// BorderLeftForeground sets the foreground color for the left side of the\n// border.\nfunc (s Style) BorderLeftForeground(c TerminalColor) Style {\n\ts.set(borderLeftForegroundKey, c)\n\treturn s\n}\n\n// BorderBackground is a shorthand function for setting all of the\n// background colors of the borders at once. The arguments work as follows:\n//\n// With one argument, the argument is applied to all sides.\n//\n// With two arguments, the arguments are applied to the vertical and horizontal\n// sides, in that order.\n//\n// With three arguments, the arguments are applied to the top side, the\n// horizontal sides, and the bottom side, in that order.\n//\n// With four arguments, the arguments are applied clockwise starting from the\n// top side, followed by the right side, then the bottom, and finally the left.\n//\n// With more than four arguments nothing will be set.\nfunc (s Style) BorderBackground(c ...TerminalColor) Style {\n\tif len(c) == 0 {\n\t\treturn s\n\t}\n\n\ttop, right, bottom, left, ok := whichSidesColor(c...)\n\tif !ok {\n\t\treturn s\n\t}\n\n\ts.set(borderTopBackgroundKey, top)\n\ts.set(borderRightBackgroundKey, right)\n\ts.set(borderBottomBackgroundKey, bottom)\n\ts.set(borderLeftBackgroundKey, left)\n\n\treturn s\n}\n\n// BorderTopBackground sets the background color of the top of the border.\nfunc (s Style) BorderTopBackground(c TerminalColor) Style {\n\ts.set(borderTopBackgroundKey, c)\n\treturn s\n}\n\n// BorderRightBackground sets the background color of right side the border.\nfunc (s Style) BorderRightBackground(c TerminalColor) Style {\n\ts.set(borderRightBackgroundKey, c)\n\treturn s\n}\n\n// BorderBottomBackground sets the background color of the bottom of the\n// border.\nfunc (s Style) BorderBottomBackground(c TerminalColor) Style {\n\ts.set(borderBottomBackgroundKey, c)\n\treturn s\n}\n\n// BorderLeftBackground set the background color of the left side of the\n// border.\nfunc (s Style) BorderLeftBackground(c TerminalColor) Style {\n\ts.set(borderLeftBackgroundKey, c)\n\treturn s\n}\n\n// Inline makes rendering output one line and disables the rendering of\n// margins, padding and borders. This is useful when you need a style to apply\n// only to font rendering and don't want it to change any physical dimensions.\n// It works well with Style.MaxWidth.\n//\n// Because this in intended to be used at the time of render, this method will\n// not mutate the style and instead return a copy.\n//\n// Example:\n//\n//\tvar userInput string = \"...\"\n//\tvar userStyle = text.Style{ /* ... */ }\n//\tfmt.Println(userStyle.Inline(true).Render(userInput))\nfunc (s Style) Inline(v bool) Style {\n\to := s // copy\n\to.set(inlineKey, v)\n\treturn o\n}\n\n// MaxWidth applies a max width to a given style. This is useful in enforcing\n// a certain width at render time, particularly with arbitrary strings and\n// styles.\n//\n// Because this in intended to be used at the time of render, this method will\n// not mutate the style and instead return a copy.\n//\n// Example:\n//\n//\tvar userInput string = \"...\"\n//\tvar userStyle = text.Style{ /* ... */ }\n//\tfmt.Println(userStyle.MaxWidth(16).Render(userInput))\nfunc (s Style) MaxWidth(n int) Style {\n\to := s // copy\n\to.set(maxWidthKey, n)\n\treturn o\n}\n\n// MaxHeight applies a max height to a given style. This is useful in enforcing\n// a certain height at render time, particularly with arbitrary strings and\n// styles.\n//\n// Because this in intended to be used at the time of render, this method will\n// not mutate the style and instead returns a copy.\nfunc (s Style) MaxHeight(n int) Style {\n\to := s // copy\n\to.set(maxHeightKey, n)\n\treturn o\n}\n\n// NoTabConversion can be passed to [Style.TabWidth] to disable the replacement\n// of tabs with spaces at render time.\nconst NoTabConversion = -1\n\n// TabWidth sets the number of spaces that a tab (/t) should be rendered as.\n// When set to 0, tabs will be removed. To disable the replacement of tabs with\n// spaces entirely, set this to [NoTabConversion].\n//\n// By default, tabs will be replaced with 4 spaces.\nfunc (s Style) TabWidth(n int) Style {\n\tif n <= -1 {\n\t\tn = -1\n\t}\n\ts.set(tabWidthKey, n)\n\treturn s\n}\n\n// UnderlineSpaces determines whether to underline spaces between words. By\n// default, this is true. Spaces can also be underlined without underlining the\n// text itself.\nfunc (s Style) UnderlineSpaces(v bool) Style {\n\ts.set(underlineSpacesKey, v)\n\treturn s\n}\n\n// StrikethroughSpaces determines whether to apply strikethroughs to spaces\n// between words. By default, this is true. Spaces can also be struck without\n// underlining the text itself.\nfunc (s Style) StrikethroughSpaces(v bool) Style {\n\ts.set(strikethroughSpacesKey, v)\n\treturn s\n}\n\n// Transform applies a given function to a string at render time, allowing for\n// the string being rendered to be manipuated.\n//\n// Example:\n//\n//\ts := NewStyle().Transform(strings.ToUpper)\n//\tfmt.Println(s.Render(\"raow!\") // \"RAOW!\"\nfunc (s Style) Transform(fn func(string) string) Style {\n\ts.set(transformKey, fn)\n\treturn s\n}\n\n// Renderer sets the renderer for the style. This is useful for changing the\n// renderer for a style that is being used in a different context.\nfunc (s Style) Renderer(r *Renderer) Style {\n\ts.r = r\n\treturn s\n}\n\n// whichSidesInt is a helper method for setting values on sides of a block based\n// on the number of arguments. It follows the CSS shorthand rules for blocks\n// like margin, padding. and borders. Here are how the rules work:\n//\n// 0 args:  do nothing\n// 1 arg:   all sides\n// 2 args:  top -> bottom\n// 3 args:  top -> horizontal -> bottom\n// 4 args:  top -> right -> bottom -> left\n// 5+ args: do nothing.\nfunc whichSidesInt(i ...int) (top, right, bottom, left int, ok bool) {\n\tswitch len(i) {\n\tcase 1:\n\t\ttop = i[0]\n\t\tbottom = i[0]\n\t\tleft = i[0]\n\t\tright = i[0]\n\t\tok = true\n\tcase 2: //nolint:gomnd\n\t\ttop = i[0]\n\t\tbottom = i[0]\n\t\tleft = i[1]\n\t\tright = i[1]\n\t\tok = true\n\tcase 3: //nolint:gomnd\n\t\ttop = i[0]\n\t\tleft = i[1]\n\t\tright = i[1]\n\t\tbottom = i[2]\n\t\tok = true\n\tcase 4: //nolint:gomnd\n\t\ttop = i[0]\n\t\tright = i[1]\n\t\tbottom = i[2]\n\t\tleft = i[3]\n\t\tok = true\n\t}\n\treturn top, right, bottom, left, ok\n}\n\n// whichSidesBool is like whichSidesInt, except it operates on a series of\n// boolean values. See the comment on whichSidesInt for details on how this\n// works.\nfunc whichSidesBool(i ...bool) (top, right, bottom, left bool, ok bool) {\n\tswitch len(i) {\n\tcase 1:\n\t\ttop = i[0]\n\t\tbottom = i[0]\n\t\tleft = i[0]\n\t\tright = i[0]\n\t\tok = true\n\tcase 2: //nolint:gomnd\n\t\ttop = i[0]\n\t\tbottom = i[0]\n\t\tleft = i[1]\n\t\tright = i[1]\n\t\tok = true\n\tcase 3: //nolint:gomnd\n\t\ttop = i[0]\n\t\tleft = i[1]\n\t\tright = i[1]\n\t\tbottom = i[2]\n\t\tok = true\n\tcase 4: //nolint:gomnd\n\t\ttop = i[0]\n\t\tright = i[1]\n\t\tbottom = i[2]\n\t\tleft = i[3]\n\t\tok = true\n\t}\n\treturn top, right, bottom, left, ok\n}\n\n// whichSidesColor is like whichSides, except it operates on a series of\n// boolean values. See the comment on whichSidesInt for details on how this\n// works.\nfunc whichSidesColor(i ...TerminalColor) (top, right, bottom, left TerminalColor, ok bool) {\n\tswitch len(i) {\n\tcase 1:\n\t\ttop = i[0]\n\t\tbottom = i[0]\n\t\tleft = i[0]\n\t\tright = i[0]\n\t\tok = true\n\tcase 2: //nolint:gomnd\n\t\ttop = i[0]\n\t\tbottom = i[0]\n\t\tleft = i[1]\n\t\tright = i[1]\n\t\tok = true\n\tcase 3: //nolint:gomnd\n\t\ttop = i[0]\n\t\tleft = i[1]\n\t\tright = i[1]\n\t\tbottom = i[2]\n\t\tok = true\n\tcase 4: //nolint:gomnd\n\t\ttop = i[0]\n\t\tright = i[1]\n\t\tbottom = i[2]\n\t\tleft = i[3]\n\t\tok = true\n\t}\n\treturn top, right, bottom, left, ok\n}\n"
        },
        {
          "name": "size.go",
          "type": "blob",
          "size": 1.138671875,
          "content": "package lipgloss\n\nimport (\n\t\"strings\"\n\n\t\"github.com/charmbracelet/x/ansi\"\n)\n\n// Width returns the cell width of characters in the string. ANSI sequences are\n// ignored and characters wider than one cell (such as Chinese characters and\n// emojis) are appropriately measured.\n//\n// You should use this instead of len(string) len([]rune(string) as neither\n// will give you accurate results.\nfunc Width(str string) (width int) {\n\tfor _, l := range strings.Split(str, \"\\n\") {\n\t\tw := ansi.StringWidth(l)\n\t\tif w > width {\n\t\t\twidth = w\n\t\t}\n\t}\n\n\treturn width\n}\n\n// Height returns height of a string in cells. This is done simply by\n// counting \\n characters. If your strings use \\r\\n for newlines you should\n// convert them to \\n first, or simply write a separate function for measuring\n// height.\nfunc Height(str string) int {\n\treturn strings.Count(str, \"\\n\") + 1\n}\n\n// Size returns the width and height of the string in cells. ANSI sequences are\n// ignored and characters wider than one cell (such as Chinese characters and\n// emojis) are appropriately measured.\nfunc Size(str string) (width, height int) {\n\twidth = Width(str)\n\theight = Height(str)\n\treturn width, height\n}\n"
        },
        {
          "name": "style.go",
          "type": "blob",
          "size": 12.767578125,
          "content": "package lipgloss\n\nimport (\n\t\"strings\"\n\t\"unicode\"\n\n\t\"github.com/charmbracelet/x/ansi\"\n\t\"github.com/muesli/termenv\"\n)\n\nconst tabWidthDefault = 4\n\n// Property for a key.\ntype propKey int64\n\n// Available properties.\nconst (\n\t// Boolean props come first.\n\tboldKey propKey = 1 << iota\n\titalicKey\n\tunderlineKey\n\tstrikethroughKey\n\treverseKey\n\tblinkKey\n\tfaintKey\n\tunderlineSpacesKey\n\tstrikethroughSpacesKey\n\tcolorWhitespaceKey\n\n\t// Non-boolean props.\n\tforegroundKey\n\tbackgroundKey\n\twidthKey\n\theightKey\n\talignHorizontalKey\n\talignVerticalKey\n\n\t// Padding.\n\tpaddingTopKey\n\tpaddingRightKey\n\tpaddingBottomKey\n\tpaddingLeftKey\n\n\t// Margins.\n\tmarginTopKey\n\tmarginRightKey\n\tmarginBottomKey\n\tmarginLeftKey\n\tmarginBackgroundKey\n\n\t// Border runes.\n\tborderStyleKey\n\n\t// Border edges.\n\tborderTopKey\n\tborderRightKey\n\tborderBottomKey\n\tborderLeftKey\n\n\t// Border foreground colors.\n\tborderTopForegroundKey\n\tborderRightForegroundKey\n\tborderBottomForegroundKey\n\tborderLeftForegroundKey\n\n\t// Border background colors.\n\tborderTopBackgroundKey\n\tborderRightBackgroundKey\n\tborderBottomBackgroundKey\n\tborderLeftBackgroundKey\n\n\tinlineKey\n\tmaxWidthKey\n\tmaxHeightKey\n\ttabWidthKey\n\n\ttransformKey\n)\n\n// props is a set of properties.\ntype props int64\n\n// set sets a property.\nfunc (p props) set(k propKey) props {\n\treturn p | props(k)\n}\n\n// unset unsets a property.\nfunc (p props) unset(k propKey) props {\n\treturn p &^ props(k)\n}\n\n// has checks if a property is set.\nfunc (p props) has(k propKey) bool {\n\treturn p&props(k) != 0\n}\n\n// NewStyle returns a new, empty Style. While it's syntactic sugar for the\n// Style{} primitive, it's recommended to use this function for creating styles\n// in case the underlying implementation changes. It takes an optional string\n// value to be set as the underlying string value for this style.\nfunc NewStyle() Style {\n\treturn renderer.NewStyle()\n}\n\n// NewStyle returns a new, empty Style. While it's syntactic sugar for the\n// Style{} primitive, it's recommended to use this function for creating styles\n// in case the underlying implementation changes. It takes an optional string\n// value to be set as the underlying string value for this style.\nfunc (r *Renderer) NewStyle() Style {\n\ts := Style{r: r}\n\treturn s\n}\n\n// Style contains a set of rules that comprise a style as a whole.\ntype Style struct {\n\tr     *Renderer\n\tprops props\n\tvalue string\n\n\t// we store bool props values here\n\tattrs int\n\n\t// props that have values\n\tfgColor TerminalColor\n\tbgColor TerminalColor\n\n\twidth  int\n\theight int\n\n\talignHorizontal Position\n\talignVertical   Position\n\n\tpaddingTop    int\n\tpaddingRight  int\n\tpaddingBottom int\n\tpaddingLeft   int\n\n\tmarginTop     int\n\tmarginRight   int\n\tmarginBottom  int\n\tmarginLeft    int\n\tmarginBgColor TerminalColor\n\n\tborderStyle         Border\n\tborderTopFgColor    TerminalColor\n\tborderRightFgColor  TerminalColor\n\tborderBottomFgColor TerminalColor\n\tborderLeftFgColor   TerminalColor\n\tborderTopBgColor    TerminalColor\n\tborderRightBgColor  TerminalColor\n\tborderBottomBgColor TerminalColor\n\tborderLeftBgColor   TerminalColor\n\n\tmaxWidth  int\n\tmaxHeight int\n\ttabWidth  int\n\n\ttransform func(string) string\n}\n\n// joinString joins a list of strings into a single string separated with a\n// space.\nfunc joinString(strs ...string) string {\n\treturn strings.Join(strs, \" \")\n}\n\n// SetString sets the underlying string value for this style. To render once\n// the underlying string is set, use the Style.String. This method is\n// a convenience for cases when having a stringer implementation is handy, such\n// as when using fmt.Sprintf. You can also simply define a style and render out\n// strings directly with Style.Render.\nfunc (s Style) SetString(strs ...string) Style {\n\ts.value = joinString(strs...)\n\treturn s\n}\n\n// Value returns the raw, unformatted, underlying string value for this style.\nfunc (s Style) Value() string {\n\treturn s.value\n}\n\n// String implements stringer for a Style, returning the rendered result based\n// on the rules in this style. An underlying string value must be set with\n// Style.SetString prior to using this method.\nfunc (s Style) String() string {\n\treturn s.Render()\n}\n\n// Copy returns a copy of this style, including any underlying string values.\n//\n// Deprecated: to copy just use assignment (i.e. a := b). All methods also\n// return a new style.\nfunc (s Style) Copy() Style {\n\treturn s\n}\n\n// Inherit overlays the style in the argument onto this style by copying each explicitly\n// set value from the argument style onto this style if it is not already explicitly set.\n// Existing set values are kept intact and not overwritten.\n//\n// Margins, padding, and underlying string values are not inherited.\nfunc (s Style) Inherit(i Style) Style {\n\tfor k := boldKey; k <= transformKey; k <<= 1 {\n\t\tif !i.isSet(k) {\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch k { //nolint:exhaustive\n\t\tcase marginTopKey, marginRightKey, marginBottomKey, marginLeftKey:\n\t\t\t// Margins are not inherited\n\t\t\tcontinue\n\t\tcase paddingTopKey, paddingRightKey, paddingBottomKey, paddingLeftKey:\n\t\t\t// Padding is not inherited\n\t\t\tcontinue\n\t\tcase backgroundKey:\n\t\t\t// The margins also inherit the background color\n\t\t\tif !s.isSet(marginBackgroundKey) && !i.isSet(marginBackgroundKey) {\n\t\t\t\ts.set(marginBackgroundKey, i.bgColor)\n\t\t\t}\n\t\t}\n\n\t\tif s.isSet(k) {\n\t\t\tcontinue\n\t\t}\n\n\t\ts.setFrom(k, i)\n\t}\n\treturn s\n}\n\n// Render applies the defined style formatting to a given string.\nfunc (s Style) Render(strs ...string) string {\n\tif s.r == nil {\n\t\ts.r = renderer\n\t}\n\tif s.value != \"\" {\n\t\tstrs = append([]string{s.value}, strs...)\n\t}\n\n\tvar (\n\t\tstr = joinString(strs...)\n\n\t\tp            = s.r.ColorProfile()\n\t\tte           = p.String()\n\t\tteSpace      = p.String()\n\t\tteWhitespace = p.String()\n\n\t\tbold          = s.getAsBool(boldKey, false)\n\t\titalic        = s.getAsBool(italicKey, false)\n\t\tunderline     = s.getAsBool(underlineKey, false)\n\t\tstrikethrough = s.getAsBool(strikethroughKey, false)\n\t\treverse       = s.getAsBool(reverseKey, false)\n\t\tblink         = s.getAsBool(blinkKey, false)\n\t\tfaint         = s.getAsBool(faintKey, false)\n\n\t\tfg = s.getAsColor(foregroundKey)\n\t\tbg = s.getAsColor(backgroundKey)\n\n\t\twidth           = s.getAsInt(widthKey)\n\t\theight          = s.getAsInt(heightKey)\n\t\thorizontalAlign = s.getAsPosition(alignHorizontalKey)\n\t\tverticalAlign   = s.getAsPosition(alignVerticalKey)\n\n\t\ttopPadding    = s.getAsInt(paddingTopKey)\n\t\trightPadding  = s.getAsInt(paddingRightKey)\n\t\tbottomPadding = s.getAsInt(paddingBottomKey)\n\t\tleftPadding   = s.getAsInt(paddingLeftKey)\n\n\t\tcolorWhitespace = s.getAsBool(colorWhitespaceKey, true)\n\t\tinline          = s.getAsBool(inlineKey, false)\n\t\tmaxWidth        = s.getAsInt(maxWidthKey)\n\t\tmaxHeight       = s.getAsInt(maxHeightKey)\n\n\t\tunderlineSpaces     = s.getAsBool(underlineSpacesKey, false) || (underline && s.getAsBool(underlineSpacesKey, true))\n\t\tstrikethroughSpaces = s.getAsBool(strikethroughSpacesKey, false) || (strikethrough && s.getAsBool(strikethroughSpacesKey, true))\n\n\t\t// Do we need to style whitespace (padding and space outside\n\t\t// paragraphs) separately?\n\t\tstyleWhitespace = reverse\n\n\t\t// Do we need to style spaces separately?\n\t\tuseSpaceStyler = (underline && !underlineSpaces) || (strikethrough && !strikethroughSpaces) || underlineSpaces || strikethroughSpaces\n\n\t\ttransform = s.getAsTransform(transformKey)\n\t)\n\n\tif transform != nil {\n\t\tstr = transform(str)\n\t}\n\n\tif s.props == 0 {\n\t\treturn s.maybeConvertTabs(str)\n\t}\n\n\t// Enable support for ANSI on the legacy Windows cmd.exe console. This is a\n\t// no-op on non-Windows systems and on Windows runs only once.\n\tenableLegacyWindowsANSI()\n\n\tif bold {\n\t\tte = te.Bold()\n\t}\n\tif italic {\n\t\tte = te.Italic()\n\t}\n\tif underline {\n\t\tte = te.Underline()\n\t}\n\tif reverse {\n\t\tteWhitespace = teWhitespace.Reverse()\n\t\tte = te.Reverse()\n\t}\n\tif blink {\n\t\tte = te.Blink()\n\t}\n\tif faint {\n\t\tte = te.Faint()\n\t}\n\n\tif fg != noColor {\n\t\tte = te.Foreground(fg.color(s.r))\n\t\tif styleWhitespace {\n\t\t\tteWhitespace = teWhitespace.Foreground(fg.color(s.r))\n\t\t}\n\t\tif useSpaceStyler {\n\t\t\tteSpace = teSpace.Foreground(fg.color(s.r))\n\t\t}\n\t}\n\n\tif bg != noColor {\n\t\tte = te.Background(bg.color(s.r))\n\t\tif colorWhitespace {\n\t\t\tteWhitespace = teWhitespace.Background(bg.color(s.r))\n\t\t}\n\t\tif useSpaceStyler {\n\t\t\tteSpace = teSpace.Background(bg.color(s.r))\n\t\t}\n\t}\n\n\tif underline {\n\t\tte = te.Underline()\n\t}\n\tif strikethrough {\n\t\tte = te.CrossOut()\n\t}\n\n\tif underlineSpaces {\n\t\tteSpace = teSpace.Underline()\n\t}\n\tif strikethroughSpaces {\n\t\tteSpace = teSpace.CrossOut()\n\t}\n\n\t// Potentially convert tabs to spaces\n\tstr = s.maybeConvertTabs(str)\n\t// carriage returns can cause strange behaviour when rendering.\n\tstr = strings.ReplaceAll(str, \"\\r\\n\", \"\\n\")\n\n\t// Strip newlines in single line mode\n\tif inline {\n\t\tstr = strings.ReplaceAll(str, \"\\n\", \"\")\n\t}\n\n\t// Word wrap\n\tif !inline && width > 0 {\n\t\twrapAt := width - leftPadding - rightPadding\n\t\tstr = ansi.Wrap(str, wrapAt, \"\")\n\t}\n\n\t// Render core text\n\t{\n\t\tvar b strings.Builder\n\n\t\tl := strings.Split(str, \"\\n\")\n\t\tfor i := range l {\n\t\t\tif useSpaceStyler {\n\t\t\t\t// Look for spaces and apply a different styler\n\t\t\t\tfor _, r := range l[i] {\n\t\t\t\t\tif unicode.IsSpace(r) {\n\t\t\t\t\t\tb.WriteString(teSpace.Styled(string(r)))\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tb.WriteString(te.Styled(string(r)))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tb.WriteString(te.Styled(l[i]))\n\t\t\t}\n\t\t\tif i != len(l)-1 {\n\t\t\t\tb.WriteRune('\\n')\n\t\t\t}\n\t\t}\n\n\t\tstr = b.String()\n\t}\n\n\t// Padding\n\tif !inline { //nolint:nestif\n\t\tif leftPadding > 0 {\n\t\t\tvar st *termenv.Style\n\t\t\tif colorWhitespace || styleWhitespace {\n\t\t\t\tst = &teWhitespace\n\t\t\t}\n\t\t\tstr = padLeft(str, leftPadding, st)\n\t\t}\n\n\t\tif rightPadding > 0 {\n\t\t\tvar st *termenv.Style\n\t\t\tif colorWhitespace || styleWhitespace {\n\t\t\t\tst = &teWhitespace\n\t\t\t}\n\t\t\tstr = padRight(str, rightPadding, st)\n\t\t}\n\n\t\tif topPadding > 0 {\n\t\t\tstr = strings.Repeat(\"\\n\", topPadding) + str\n\t\t}\n\n\t\tif bottomPadding > 0 {\n\t\t\tstr += strings.Repeat(\"\\n\", bottomPadding)\n\t\t}\n\t}\n\n\t// Height\n\tif height > 0 {\n\t\tstr = alignTextVertical(str, verticalAlign, height, nil)\n\t}\n\n\t// Set alignment. This will also pad short lines with spaces so that all\n\t// lines are the same length, so we run it under a few different conditions\n\t// beyond alignment.\n\t{\n\t\tnumLines := strings.Count(str, \"\\n\")\n\n\t\tif !(numLines == 0 && width == 0) {\n\t\t\tvar st *termenv.Style\n\t\t\tif colorWhitespace || styleWhitespace {\n\t\t\t\tst = &teWhitespace\n\t\t\t}\n\t\t\tstr = alignTextHorizontal(str, horizontalAlign, width, st)\n\t\t}\n\t}\n\n\tif !inline {\n\t\tstr = s.applyBorder(str)\n\t\tstr = s.applyMargins(str, inline)\n\t}\n\n\t// Truncate according to MaxWidth\n\tif maxWidth > 0 {\n\t\tlines := strings.Split(str, \"\\n\")\n\n\t\tfor i := range lines {\n\t\t\tlines[i] = ansi.Truncate(lines[i], maxWidth, \"\")\n\t\t}\n\n\t\tstr = strings.Join(lines, \"\\n\")\n\t}\n\n\t// Truncate according to MaxHeight\n\tif maxHeight > 0 {\n\t\tlines := strings.Split(str, \"\\n\")\n\t\theight := min(maxHeight, len(lines))\n\t\tif len(lines) > 0 {\n\t\t\tstr = strings.Join(lines[:height], \"\\n\")\n\t\t}\n\t}\n\n\treturn str\n}\n\nfunc (s Style) maybeConvertTabs(str string) string {\n\ttw := tabWidthDefault\n\tif s.isSet(tabWidthKey) {\n\t\ttw = s.getAsInt(tabWidthKey)\n\t}\n\tswitch tw {\n\tcase -1:\n\t\treturn str\n\tcase 0:\n\t\treturn strings.ReplaceAll(str, \"\\t\", \"\")\n\tdefault:\n\t\treturn strings.ReplaceAll(str, \"\\t\", strings.Repeat(\" \", tw))\n\t}\n}\n\nfunc (s Style) applyMargins(str string, inline bool) string {\n\tvar (\n\t\ttopMargin    = s.getAsInt(marginTopKey)\n\t\trightMargin  = s.getAsInt(marginRightKey)\n\t\tbottomMargin = s.getAsInt(marginBottomKey)\n\t\tleftMargin   = s.getAsInt(marginLeftKey)\n\n\t\tstyler termenv.Style\n\t)\n\n\tbgc := s.getAsColor(marginBackgroundKey)\n\tif bgc != noColor {\n\t\tstyler = styler.Background(bgc.color(s.r))\n\t}\n\n\t// Add left and right margin\n\tstr = padLeft(str, leftMargin, &styler)\n\tstr = padRight(str, rightMargin, &styler)\n\n\t// Top/bottom margin\n\tif !inline {\n\t\t_, width := getLines(str)\n\t\tspaces := strings.Repeat(\" \", width)\n\n\t\tif topMargin > 0 {\n\t\t\tstr = styler.Styled(strings.Repeat(spaces+\"\\n\", topMargin)) + str\n\t\t}\n\t\tif bottomMargin > 0 {\n\t\t\tstr += styler.Styled(strings.Repeat(\"\\n\"+spaces, bottomMargin))\n\t\t}\n\t}\n\n\treturn str\n}\n\n// Apply left padding.\nfunc padLeft(str string, n int, style *termenv.Style) string {\n\treturn pad(str, -n, style)\n}\n\n// Apply right padding.\nfunc padRight(str string, n int, style *termenv.Style) string {\n\treturn pad(str, n, style)\n}\n\n// pad adds padding to either the left or right side of a string.\n// Positive values add to the right side while negative values\n// add to the left side.\nfunc pad(str string, n int, style *termenv.Style) string {\n\tif n == 0 {\n\t\treturn str\n\t}\n\n\tsp := strings.Repeat(\" \", abs(n))\n\tif style != nil {\n\t\tsp = style.Styled(sp)\n\t}\n\n\tb := strings.Builder{}\n\tl := strings.Split(str, \"\\n\")\n\n\tfor i := range l {\n\t\tswitch {\n\t\t// pad right\n\t\tcase n > 0:\n\t\t\tb.WriteString(l[i])\n\t\t\tb.WriteString(sp)\n\t\t// pad left\n\t\tdefault:\n\t\t\tb.WriteString(sp)\n\t\t\tb.WriteString(l[i])\n\t\t}\n\n\t\tif i != len(l)-1 {\n\t\t\tb.WriteRune('\\n')\n\t\t}\n\t}\n\n\treturn b.String()\n}\n\nfunc max(a, b int) int { //nolint:unparam,predeclared\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int) int { //nolint:predeclared\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc abs(a int) int {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\n\treturn a\n}\n"
        },
        {
          "name": "style_test.go",
          "type": "blob",
          "size": 13.8935546875,
          "content": "package lipgloss\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/muesli/termenv\"\n)\n\nfunc TestUnderline(t *testing.T) {\n\tr := NewRenderer(io.Discard)\n\tr.SetColorProfile(termenv.TrueColor)\n\tr.SetHasDarkBackground(true)\n\tt.Parallel()\n\n\ttt := []struct {\n\t\tstyle    Style\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tr.NewStyle().Underline(true),\n\t\t\t\"\\x1b[4;4ma\\x1b[0m\\x1b[4;4mb\\x1b[0m\\x1b[4m \\x1b[0m\\x1b[4;4mc\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tr.NewStyle().Underline(true).UnderlineSpaces(true),\n\t\t\t\"\\x1b[4;4ma\\x1b[0m\\x1b[4;4mb\\x1b[0m\\x1b[4m \\x1b[0m\\x1b[4;4mc\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tr.NewStyle().Underline(true).UnderlineSpaces(false),\n\t\t\t\"\\x1b[4;4ma\\x1b[0m\\x1b[4;4mb\\x1b[0m \\x1b[4;4mc\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tr.NewStyle().UnderlineSpaces(true),\n\t\t\t\"ab\\x1b[4m \\x1b[0mc\",\n\t\t},\n\t}\n\n\tfor i, tc := range tt {\n\t\ts := tc.style.SetString(\"ab c\")\n\t\tres := s.Render()\n\t\tif res != tc.expected {\n\t\t\tt.Errorf(\"Test %d, expected:\\n\\n`%s`\\n`%s`\\n\\nActual output:\\n\\n`%s`\\n`%s`\\n\\n\",\n\t\t\t\ti, tc.expected, formatEscapes(tc.expected),\n\t\t\t\tres, formatEscapes(res))\n\t\t}\n\t}\n}\n\nfunc TestStrikethrough(t *testing.T) {\n\tr := NewRenderer(io.Discard)\n\tr.SetColorProfile(termenv.TrueColor)\n\tr.SetHasDarkBackground(true)\n\tt.Parallel()\n\n\ttt := []struct {\n\t\tstyle    Style\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tr.NewStyle().Strikethrough(true),\n\t\t\t\"\\x1b[9ma\\x1b[0m\\x1b[9mb\\x1b[0m\\x1b[9m \\x1b[0m\\x1b[9mc\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tr.NewStyle().Strikethrough(true).StrikethroughSpaces(true),\n\t\t\t\"\\x1b[9ma\\x1b[0m\\x1b[9mb\\x1b[0m\\x1b[9m \\x1b[0m\\x1b[9mc\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tr.NewStyle().Strikethrough(true).StrikethroughSpaces(false),\n\t\t\t\"\\x1b[9ma\\x1b[0m\\x1b[9mb\\x1b[0m \\x1b[9mc\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tr.NewStyle().StrikethroughSpaces(true),\n\t\t\t\"ab\\x1b[9m \\x1b[0mc\",\n\t\t},\n\t}\n\n\tfor i, tc := range tt {\n\t\ts := tc.style.SetString(\"ab c\")\n\t\tres := s.Render()\n\t\tif res != tc.expected {\n\t\t\tt.Errorf(\"Test %d, expected:\\n\\n`%s`\\n`%s`\\n\\nActual output:\\n\\n`%s`\\n`%s`\\n\\n\",\n\t\t\t\ti, tc.expected, formatEscapes(tc.expected),\n\t\t\t\tres, formatEscapes(res))\n\t\t}\n\t}\n}\n\nfunc TestStyleRender(t *testing.T) {\n\tr := NewRenderer(io.Discard)\n\tr.SetColorProfile(termenv.TrueColor)\n\tr.SetHasDarkBackground(true)\n\tt.Parallel()\n\n\ttt := []struct {\n\t\tstyle    Style\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tr.NewStyle().Foreground(Color(\"#5A56E0\")),\n\t\t\t\"\\x1b[38;2;89;86;224mhello\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tr.NewStyle().Foreground(AdaptiveColor{Light: \"#fffe12\", Dark: \"#5A56E0\"}),\n\t\t\t\"\\x1b[38;2;89;86;224mhello\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tr.NewStyle().Bold(true),\n\t\t\t\"\\x1b[1mhello\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tr.NewStyle().Italic(true),\n\t\t\t\"\\x1b[3mhello\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tr.NewStyle().Underline(true),\n\t\t\t\"\\x1b[4;4mh\\x1b[0m\\x1b[4;4me\\x1b[0m\\x1b[4;4ml\\x1b[0m\\x1b[4;4ml\\x1b[0m\\x1b[4;4mo\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tr.NewStyle().Blink(true),\n\t\t\t\"\\x1b[5mhello\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tr.NewStyle().Faint(true),\n\t\t\t\"\\x1b[2mhello\\x1b[0m\",\n\t\t},\n\t}\n\n\tfor i, tc := range tt {\n\t\ts := tc.style.SetString(\"hello\")\n\t\tres := s.Render()\n\t\tif res != tc.expected {\n\t\t\tt.Errorf(\"Test %d, expected:\\n\\n`%s`\\n`%s`\\n\\nActual output:\\n\\n`%s`\\n`%s`\\n\\n\",\n\t\t\t\ti, tc.expected, formatEscapes(tc.expected),\n\t\t\t\tres, formatEscapes(res))\n\t\t}\n\t}\n}\n\nfunc TestStyleCustomRender(t *testing.T) {\n\tr := NewRenderer(io.Discard)\n\tr.SetHasDarkBackground(false)\n\tr.SetColorProfile(termenv.TrueColor)\n\ttt := []struct {\n\t\tstyle    Style\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tr.NewStyle().Foreground(Color(\"#5A56E0\")),\n\t\t\t\"\\x1b[38;2;89;86;224mhello\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tr.NewStyle().Foreground(AdaptiveColor{Light: \"#fffe12\", Dark: \"#5A56E0\"}),\n\t\t\t\"\\x1b[38;2;255;254;18mhello\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tr.NewStyle().Bold(true),\n\t\t\t\"\\x1b[1mhello\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tr.NewStyle().Italic(true),\n\t\t\t\"\\x1b[3mhello\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tr.NewStyle().Underline(true),\n\t\t\t\"\\x1b[4;4mh\\x1b[0m\\x1b[4;4me\\x1b[0m\\x1b[4;4ml\\x1b[0m\\x1b[4;4ml\\x1b[0m\\x1b[4;4mo\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tr.NewStyle().Blink(true),\n\t\t\t\"\\x1b[5mhello\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tr.NewStyle().Faint(true),\n\t\t\t\"\\x1b[2mhello\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tNewStyle().Faint(true).Renderer(r),\n\t\t\t\"\\x1b[2mhello\\x1b[0m\",\n\t\t},\n\t}\n\n\tfor i, tc := range tt {\n\t\ts := tc.style.SetString(\"hello\")\n\t\tres := s.Render()\n\t\tif res != tc.expected {\n\t\t\tt.Errorf(\"Test %d, expected:\\n\\n`%s`\\n`%s`\\n\\nActual output:\\n\\n`%s`\\n`%s`\\n\\n\",\n\t\t\t\ti, tc.expected, formatEscapes(tc.expected),\n\t\t\t\tres, formatEscapes(res))\n\t\t}\n\t}\n}\n\nfunc TestStyleRenderer(t *testing.T) {\n\tr := NewRenderer(io.Discard)\n\ts1 := NewStyle().Bold(true)\n\ts2 := s1.Renderer(r)\n\tif s1.r == s2.r {\n\t\tt.Fatalf(\"expected different renderers\")\n\t}\n}\n\nfunc TestValueCopy(t *testing.T) {\n\tt.Parallel()\n\n\ts := NewStyle().\n\t\tBold(true)\n\n\ti := s\n\ti.Bold(false)\n\n\trequireEqual(t, s.GetBold(), i.GetBold())\n}\n\nfunc TestStyleInherit(t *testing.T) {\n\tt.Parallel()\n\n\ts := NewStyle().\n\t\tBold(true).\n\t\tItalic(true).\n\t\tUnderline(true).\n\t\tStrikethrough(true).\n\t\tBlink(true).\n\t\tFaint(true).\n\t\tForeground(Color(\"#ffffff\")).\n\t\tBackground(Color(\"#111111\")).\n\t\tMargin(1, 1, 1, 1).\n\t\tPadding(1, 1, 1, 1)\n\n\ti := NewStyle().Inherit(s)\n\n\trequireEqual(t, s.GetBold(), i.GetBold())\n\trequireEqual(t, s.GetItalic(), i.GetItalic())\n\trequireEqual(t, s.GetUnderline(), i.GetUnderline())\n\trequireEqual(t, s.GetUnderlineSpaces(), i.GetUnderlineSpaces())\n\trequireEqual(t, s.GetStrikethrough(), i.GetStrikethrough())\n\trequireEqual(t, s.GetStrikethroughSpaces(), i.GetStrikethroughSpaces())\n\trequireEqual(t, s.GetBlink(), i.GetBlink())\n\trequireEqual(t, s.GetFaint(), i.GetFaint())\n\trequireEqual(t, s.GetForeground(), i.GetForeground())\n\trequireEqual(t, s.GetBackground(), i.GetBackground())\n\n\trequireNotEqual(t, s.GetMarginLeft(), i.GetMarginLeft())\n\trequireNotEqual(t, s.GetMarginRight(), i.GetMarginRight())\n\trequireNotEqual(t, s.GetMarginTop(), i.GetMarginTop())\n\trequireNotEqual(t, s.GetMarginBottom(), i.GetMarginBottom())\n\trequireNotEqual(t, s.GetPaddingLeft(), i.GetPaddingLeft())\n\trequireNotEqual(t, s.GetPaddingRight(), i.GetPaddingRight())\n\trequireNotEqual(t, s.GetPaddingTop(), i.GetPaddingTop())\n\trequireNotEqual(t, s.GetPaddingBottom(), i.GetPaddingBottom())\n}\n\nfunc TestStyleCopy(t *testing.T) {\n\tt.Parallel()\n\n\ts := NewStyle().\n\t\tBold(true).\n\t\tItalic(true).\n\t\tUnderline(true).\n\t\tStrikethrough(true).\n\t\tBlink(true).\n\t\tFaint(true).\n\t\tForeground(Color(\"#ffffff\")).\n\t\tBackground(Color(\"#111111\")).\n\t\tMargin(1, 1, 1, 1).\n\t\tPadding(1, 1, 1, 1).\n\t\tTabWidth(2)\n\n\ti := s // copy\n\n\trequireEqual(t, s.GetBold(), i.GetBold())\n\trequireEqual(t, s.GetItalic(), i.GetItalic())\n\trequireEqual(t, s.GetUnderline(), i.GetUnderline())\n\trequireEqual(t, s.GetUnderlineSpaces(), i.GetUnderlineSpaces())\n\trequireEqual(t, s.GetStrikethrough(), i.GetStrikethrough())\n\trequireEqual(t, s.GetStrikethroughSpaces(), i.GetStrikethroughSpaces())\n\trequireEqual(t, s.GetBlink(), i.GetBlink())\n\trequireEqual(t, s.GetFaint(), i.GetFaint())\n\trequireEqual(t, s.GetForeground(), i.GetForeground())\n\trequireEqual(t, s.GetBackground(), i.GetBackground())\n\n\trequireEqual(t, s.GetMarginLeft(), i.GetMarginLeft())\n\trequireEqual(t, s.GetMarginRight(), i.GetMarginRight())\n\trequireEqual(t, s.GetMarginTop(), i.GetMarginTop())\n\trequireEqual(t, s.GetMarginBottom(), i.GetMarginBottom())\n\trequireEqual(t, s.GetPaddingLeft(), i.GetPaddingLeft())\n\trequireEqual(t, s.GetPaddingRight(), i.GetPaddingRight())\n\trequireEqual(t, s.GetPaddingTop(), i.GetPaddingTop())\n\trequireEqual(t, s.GetPaddingBottom(), i.GetPaddingBottom())\n\trequireEqual(t, s.GetTabWidth(), i.GetTabWidth())\n}\n\nfunc TestStyleUnset(t *testing.T) {\n\tt.Parallel()\n\n\ts := NewStyle().Bold(true)\n\trequireTrue(t, s.GetBold())\n\ts = s.UnsetBold()\n\trequireFalse(t, s.GetBold())\n\n\ts = NewStyle().Italic(true)\n\trequireTrue(t, s.GetItalic())\n\ts = s.UnsetItalic()\n\trequireFalse(t, s.GetItalic())\n\n\ts = NewStyle().Underline(true)\n\trequireTrue(t, s.GetUnderline())\n\ts = s.UnsetUnderline()\n\trequireFalse(t, s.GetUnderline())\n\n\ts = NewStyle().UnderlineSpaces(true)\n\trequireTrue(t, s.GetUnderlineSpaces())\n\ts = s.UnsetUnderlineSpaces()\n\trequireFalse(t, s.GetUnderlineSpaces())\n\n\ts = NewStyle().Strikethrough(true)\n\trequireTrue(t, s.GetStrikethrough())\n\ts = s.UnsetStrikethrough()\n\trequireFalse(t, s.GetStrikethrough())\n\n\ts = NewStyle().StrikethroughSpaces(true)\n\trequireTrue(t, s.GetStrikethroughSpaces())\n\ts = s.UnsetStrikethroughSpaces()\n\trequireFalse(t, s.GetStrikethroughSpaces())\n\n\ts = NewStyle().Reverse(true)\n\trequireTrue(t, s.GetReverse())\n\ts = s.UnsetReverse()\n\trequireFalse(t, s.GetReverse())\n\n\ts = NewStyle().Blink(true)\n\trequireTrue(t, s.GetBlink())\n\ts = s.UnsetBlink()\n\trequireFalse(t, s.GetBlink())\n\n\ts = NewStyle().Faint(true)\n\trequireTrue(t, s.GetFaint())\n\ts = s.UnsetFaint()\n\trequireFalse(t, s.GetFaint())\n\n\ts = NewStyle().Inline(true)\n\trequireTrue(t, s.GetInline())\n\ts = s.UnsetInline()\n\trequireFalse(t, s.GetInline())\n\n\t// colors\n\tcol := Color(\"#ffffff\")\n\ts = NewStyle().Foreground(col)\n\trequireEqual(t, col, s.GetForeground())\n\ts = s.UnsetForeground()\n\trequireNotEqual(t, col, s.GetForeground())\n\n\ts = NewStyle().Background(col)\n\trequireEqual(t, col, s.GetBackground())\n\ts = s.UnsetBackground()\n\trequireNotEqual(t, col, s.GetBackground())\n\n\t// margins\n\ts = NewStyle().Margin(1, 2, 3, 4)\n\trequireEqual(t, 1, s.GetMarginTop())\n\ts = s.UnsetMarginTop()\n\trequireEqual(t, 0, s.GetMarginTop())\n\n\trequireEqual(t, 2, s.GetMarginRight())\n\ts = s.UnsetMarginRight()\n\trequireEqual(t, 0, s.GetMarginRight())\n\n\trequireEqual(t, 3, s.GetMarginBottom())\n\ts = s.UnsetMarginBottom()\n\trequireEqual(t, 0, s.GetMarginBottom())\n\n\trequireEqual(t, 4, s.GetMarginLeft())\n\ts = s.UnsetMarginLeft()\n\trequireEqual(t, 0, s.GetMarginLeft())\n\n\t// padding\n\ts = NewStyle().Padding(1, 2, 3, 4)\n\trequireEqual(t, 1, s.GetPaddingTop())\n\ts = s.UnsetPaddingTop()\n\trequireEqual(t, 0, s.GetPaddingTop())\n\n\trequireEqual(t, 2, s.GetPaddingRight())\n\ts = s.UnsetPaddingRight()\n\trequireEqual(t, 0, s.GetPaddingRight())\n\n\trequireEqual(t, 3, s.GetPaddingBottom())\n\ts = s.UnsetPaddingBottom()\n\trequireEqual(t, 0, s.GetPaddingBottom())\n\n\trequireEqual(t, 4, s.GetPaddingLeft())\n\ts = s.UnsetPaddingLeft()\n\trequireEqual(t, 0, s.GetPaddingLeft())\n\n\t// border\n\ts = NewStyle().Border(normalBorder, true, true, true, true)\n\trequireTrue(t, s.GetBorderTop())\n\ts = s.UnsetBorderTop()\n\trequireFalse(t, s.GetBorderTop())\n\n\trequireTrue(t, s.GetBorderRight())\n\ts = s.UnsetBorderRight()\n\trequireFalse(t, s.GetBorderRight())\n\n\trequireTrue(t, s.GetBorderBottom())\n\ts = s.UnsetBorderBottom()\n\trequireFalse(t, s.GetBorderBottom())\n\n\trequireTrue(t, s.GetBorderLeft())\n\ts = s.UnsetBorderLeft()\n\trequireFalse(t, s.GetBorderLeft())\n\n\t// tab width\n\ts = NewStyle().TabWidth(2)\n\trequireEqual(t, s.GetTabWidth(), 2)\n\ts = s.UnsetTabWidth()\n\trequireNotEqual(t, s.GetTabWidth(), 4)\n}\n\nfunc TestStyleValue(t *testing.T) {\n\tt.Parallel()\n\n\ttt := []struct {\n\t\tname     string\n\t\ttext     string\n\t\tstyle    Style\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty\",\n\t\t\ttext:     \"foo\",\n\t\t\tstyle:    NewStyle(),\n\t\t\texpected: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname:     \"set string\",\n\t\t\ttext:     \"foo\",\n\t\t\tstyle:    NewStyle().SetString(\"bar\"),\n\t\t\texpected: \"bar foo\",\n\t\t},\n\t\t{\n\t\t\tname:     \"set string with bold\",\n\t\t\ttext:     \"foo\",\n\t\t\tstyle:    NewStyle().SetString(\"bar\").Bold(true),\n\t\t\texpected: \"\\x1b[1mbar foo\\x1b[0m\",\n\t\t},\n\t\t{\n\t\t\tname:     \"new style with string\",\n\t\t\ttext:     \"foo\",\n\t\t\tstyle:    NewStyle().SetString(\"bar\", \"foobar\"),\n\t\t\texpected: \"bar foobar foo\",\n\t\t},\n\t\t{\n\t\t\tname:     \"margin right\",\n\t\t\ttext:     \"foo\",\n\t\t\tstyle:    NewStyle().MarginRight(1),\n\t\t\texpected: \"foo \",\n\t\t},\n\t\t{\n\t\t\tname:     \"margin left\",\n\t\t\ttext:     \"foo\",\n\t\t\tstyle:    NewStyle().MarginLeft(1),\n\t\t\texpected: \" foo\",\n\t\t},\n\t\t{\n\t\t\tname:     \"empty text margin right\",\n\t\t\ttext:     \"\",\n\t\t\tstyle:    NewStyle().MarginRight(1),\n\t\t\texpected: \" \",\n\t\t},\n\t\t{\n\t\t\tname:     \"empty text margin left\",\n\t\t\ttext:     \"\",\n\t\t\tstyle:    NewStyle().MarginLeft(1),\n\t\t\texpected: \" \",\n\t\t},\n\t}\n\n\tfor i, tc := range tt {\n\t\tres := tc.style.Render(tc.text)\n\t\tif res != tc.expected {\n\t\t\tt.Errorf(\"Test %d, expected:\\n\\n`%s`\\n`%s`\\n\\nActual output:\\n\\n`%s`\\n`%s`\\n\\n\",\n\t\t\t\ti, tc.expected, formatEscapes(tc.expected),\n\t\t\t\tres, formatEscapes(res))\n\t\t}\n\t}\n}\n\nfunc TestTabConversion(t *testing.T) {\n\ts := NewStyle()\n\trequireEqual(t, \"[    ]\", s.Render(\"[\\t]\"))\n\ts = NewStyle().TabWidth(2)\n\trequireEqual(t, \"[  ]\", s.Render(\"[\\t]\"))\n\ts = NewStyle().TabWidth(0)\n\trequireEqual(t, \"[]\", s.Render(\"[\\t]\"))\n\ts = NewStyle().TabWidth(-1)\n\trequireEqual(t, \"[\\t]\", s.Render(\"[\\t]\"))\n}\n\nfunc TestStringTransform(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tinput    string\n\t\tfn       func(string) string\n\t\texpected string\n\t}{\n\t\t// No-op.\n\t\t{\n\t\t\t\"hello\",\n\t\t\tfunc(s string) string { return s },\n\t\t\t\"hello\",\n\t\t},\n\t\t// Uppercase.\n\t\t{\n\t\t\t\"raow\",\n\t\t\tstrings.ToUpper,\n\t\t\t\"RAOW\",\n\t\t},\n\t\t// English and Chinese.\n\t\t{\n\t\t\t\"The quick brown 狐 jumped over the lazy 犬\",\n\t\t\tfunc(s string) string {\n\t\t\t\tn := 0\n\t\t\t\trune := make([]rune, len(s))\n\t\t\t\tfor _, r := range s {\n\t\t\t\t\trune[n] = r\n\t\t\t\t\tn++\n\t\t\t\t}\n\t\t\t\trune = rune[0:n]\n\t\t\t\tfor i := 0; i < n/2; i++ {\n\t\t\t\t\trune[i], rune[n-1-i] = rune[n-1-i], rune[i]\n\t\t\t\t}\n\t\t\t\treturn string(rune)\n\t\t\t},\n\t\t\t\"犬 yzal eht revo depmuj 狐 nworb kciuq ehT\",\n\t\t},\n\t} {\n\t\tres := NewStyle().Bold(true).Transform(tc.fn).Render(tc.input)\n\t\texpected := \"\\x1b[1m\" + tc.expected + \"\\x1b[0m\"\n\t\tif res != expected {\n\t\t\tt.Errorf(\"Test #%d:\\nExpected: %q\\nGot:      %q\", i+1, expected, res)\n\t\t}\n\t}\n}\n\nfunc BenchmarkStyleRender(b *testing.B) {\n\ts := NewStyle().\n\t\tBold(true).\n\t\tForeground(Color(\"#ffffff\"))\n\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Render(\"Hello world\")\n\t}\n}\n\nfunc requireTrue(tb testing.TB, b bool) {\n\ttb.Helper()\n\trequireEqual(tb, true, b)\n}\n\nfunc requireFalse(tb testing.TB, b bool) {\n\ttb.Helper()\n\trequireEqual(tb, false, b)\n}\n\nfunc requireEqual(tb testing.TB, a, b interface{}) {\n\ttb.Helper()\n\tif !reflect.DeepEqual(a, b) {\n\t\ttb.Errorf(\"%v != %v\", a, b)\n\t\ttb.FailNow()\n\t}\n}\n\nfunc requireNotEqual(tb testing.TB, a, b interface{}) {\n\ttb.Helper()\n\tif reflect.DeepEqual(a, b) {\n\t\ttb.Errorf(\"%v == %v\", a, b)\n\t\ttb.FailNow()\n\t}\n}\n\nfunc TestCarriageReturnInRender(t *testing.T) {\n\tout := fmt.Sprintf(\"%s\\r\\n%s\\r\\n\", \"Super duper california oranges\", \"Hello world\")\n\ttestStyle := NewStyle().\n\t\tMarginLeft(1)\n\tgot := testStyle.Render(string(out))\n\twant := testStyle.Render(fmt.Sprintf(\"%s\\n%s\\n\", \"Super duper california oranges\", \"Hello world\"))\n\n\tif got != want {\n\t\tt.Logf(\"got(detailed):\\n%q\\nwant(detailed):\\n%q\", got, want)\n\t\tt.Fatalf(\"got(string):\\n%s\\nwant(string):\\n%s\", got, want)\n\t}\n}\n"
        },
        {
          "name": "table",
          "type": "tree",
          "content": null
        },
        {
          "name": "tree",
          "type": "tree",
          "content": null
        },
        {
          "name": "unset.go",
          "type": "blob",
          "size": 7.9921875,
          "content": "package lipgloss\n\n// unset unsets a property from a style.\nfunc (s *Style) unset(key propKey) {\n\ts.props = s.props.unset(key)\n}\n\n// UnsetBold removes the bold style rule, if set.\nfunc (s Style) UnsetBold() Style {\n\ts.unset(boldKey)\n\treturn s\n}\n\n// UnsetItalic removes the italic style rule, if set.\nfunc (s Style) UnsetItalic() Style {\n\ts.unset(italicKey)\n\treturn s\n}\n\n// UnsetUnderline removes the underline style rule, if set.\nfunc (s Style) UnsetUnderline() Style {\n\ts.unset(underlineKey)\n\treturn s\n}\n\n// UnsetStrikethrough removes the strikethrough style rule, if set.\nfunc (s Style) UnsetStrikethrough() Style {\n\ts.unset(strikethroughKey)\n\treturn s\n}\n\n// UnsetReverse removes the reverse style rule, if set.\nfunc (s Style) UnsetReverse() Style {\n\ts.unset(reverseKey)\n\treturn s\n}\n\n// UnsetBlink removes the blink style rule, if set.\nfunc (s Style) UnsetBlink() Style {\n\ts.unset(blinkKey)\n\treturn s\n}\n\n// UnsetFaint removes the faint style rule, if set.\nfunc (s Style) UnsetFaint() Style {\n\ts.unset(faintKey)\n\treturn s\n}\n\n// UnsetForeground removes the foreground style rule, if set.\nfunc (s Style) UnsetForeground() Style {\n\ts.unset(foregroundKey)\n\treturn s\n}\n\n// UnsetBackground removes the background style rule, if set.\nfunc (s Style) UnsetBackground() Style {\n\ts.unset(backgroundKey)\n\treturn s\n}\n\n// UnsetWidth removes the width style rule, if set.\nfunc (s Style) UnsetWidth() Style {\n\ts.unset(widthKey)\n\treturn s\n}\n\n// UnsetHeight removes the height style rule, if set.\nfunc (s Style) UnsetHeight() Style {\n\ts.unset(heightKey)\n\treturn s\n}\n\n// UnsetAlign removes the horizontal and vertical text alignment style rule, if set.\nfunc (s Style) UnsetAlign() Style {\n\ts.unset(alignHorizontalKey)\n\ts.unset(alignVerticalKey)\n\treturn s\n}\n\n// UnsetAlignHorizontal removes the horizontal text alignment style rule, if set.\nfunc (s Style) UnsetAlignHorizontal() Style {\n\ts.unset(alignHorizontalKey)\n\treturn s\n}\n\n// UnsetAlignVertical removes the vertical text alignment style rule, if set.\nfunc (s Style) UnsetAlignVertical() Style {\n\ts.unset(alignVerticalKey)\n\treturn s\n}\n\n// UnsetPadding removes all padding style rules.\nfunc (s Style) UnsetPadding() Style {\n\ts.unset(paddingLeftKey)\n\ts.unset(paddingRightKey)\n\ts.unset(paddingTopKey)\n\ts.unset(paddingBottomKey)\n\treturn s\n}\n\n// UnsetPaddingLeft removes the left padding style rule, if set.\nfunc (s Style) UnsetPaddingLeft() Style {\n\ts.unset(paddingLeftKey)\n\treturn s\n}\n\n// UnsetPaddingRight removes the right padding style rule, if set.\nfunc (s Style) UnsetPaddingRight() Style {\n\ts.unset(paddingRightKey)\n\treturn s\n}\n\n// UnsetPaddingTop removes the top padding style rule, if set.\nfunc (s Style) UnsetPaddingTop() Style {\n\ts.unset(paddingTopKey)\n\treturn s\n}\n\n// UnsetPaddingBottom removes the bottom padding style rule, if set.\nfunc (s Style) UnsetPaddingBottom() Style {\n\ts.unset(paddingBottomKey)\n\treturn s\n}\n\n// UnsetColorWhitespace removes the rule for coloring padding, if set.\nfunc (s Style) UnsetColorWhitespace() Style {\n\ts.unset(colorWhitespaceKey)\n\treturn s\n}\n\n// UnsetMargins removes all margin style rules.\nfunc (s Style) UnsetMargins() Style {\n\ts.unset(marginLeftKey)\n\ts.unset(marginRightKey)\n\ts.unset(marginTopKey)\n\ts.unset(marginBottomKey)\n\treturn s\n}\n\n// UnsetMarginLeft removes the left margin style rule, if set.\nfunc (s Style) UnsetMarginLeft() Style {\n\ts.unset(marginLeftKey)\n\treturn s\n}\n\n// UnsetMarginRight removes the right margin style rule, if set.\nfunc (s Style) UnsetMarginRight() Style {\n\ts.unset(marginRightKey)\n\treturn s\n}\n\n// UnsetMarginTop removes the top margin style rule, if set.\nfunc (s Style) UnsetMarginTop() Style {\n\ts.unset(marginTopKey)\n\treturn s\n}\n\n// UnsetMarginBottom removes the bottom margin style rule, if set.\nfunc (s Style) UnsetMarginBottom() Style {\n\ts.unset(marginBottomKey)\n\treturn s\n}\n\n// UnsetMarginBackground removes the margin's background color. Note that the\n// margin's background color can be set from the background color of another\n// style during inheritance.\nfunc (s Style) UnsetMarginBackground() Style {\n\ts.unset(marginBackgroundKey)\n\treturn s\n}\n\n// UnsetBorderStyle removes the border style rule, if set.\nfunc (s Style) UnsetBorderStyle() Style {\n\ts.unset(borderStyleKey)\n\treturn s\n}\n\n// UnsetBorderTop removes the border top style rule, if set.\nfunc (s Style) UnsetBorderTop() Style {\n\ts.unset(borderTopKey)\n\treturn s\n}\n\n// UnsetBorderRight removes the border right style rule, if set.\nfunc (s Style) UnsetBorderRight() Style {\n\ts.unset(borderRightKey)\n\treturn s\n}\n\n// UnsetBorderBottom removes the border bottom style rule, if set.\nfunc (s Style) UnsetBorderBottom() Style {\n\ts.unset(borderBottomKey)\n\treturn s\n}\n\n// UnsetBorderLeft removes the border left style rule, if set.\nfunc (s Style) UnsetBorderLeft() Style {\n\ts.unset(borderLeftKey)\n\treturn s\n}\n\n// UnsetBorderForeground removes all border foreground color styles, if set.\nfunc (s Style) UnsetBorderForeground() Style {\n\ts.unset(borderTopForegroundKey)\n\ts.unset(borderRightForegroundKey)\n\ts.unset(borderBottomForegroundKey)\n\ts.unset(borderLeftForegroundKey)\n\treturn s\n}\n\n// UnsetBorderTopForeground removes the top border foreground color rule,\n// if set.\nfunc (s Style) UnsetBorderTopForeground() Style {\n\ts.unset(borderTopForegroundKey)\n\treturn s\n}\n\n// UnsetBorderRightForeground removes the right border foreground color rule,\n// if set.\nfunc (s Style) UnsetBorderRightForeground() Style {\n\ts.unset(borderRightForegroundKey)\n\treturn s\n}\n\n// UnsetBorderBottomForeground removes the bottom border foreground color\n// rule, if set.\nfunc (s Style) UnsetBorderBottomForeground() Style {\n\ts.unset(borderBottomForegroundKey)\n\treturn s\n}\n\n// UnsetBorderLeftForeground removes the left border foreground color rule,\n// if set.\nfunc (s Style) UnsetBorderLeftForeground() Style {\n\ts.unset(borderLeftForegroundKey)\n\treturn s\n}\n\n// UnsetBorderBackground removes all border background color styles, if\n// set.\nfunc (s Style) UnsetBorderBackground() Style {\n\ts.unset(borderTopBackgroundKey)\n\ts.unset(borderRightBackgroundKey)\n\ts.unset(borderBottomBackgroundKey)\n\ts.unset(borderLeftBackgroundKey)\n\treturn s\n}\n\n// UnsetBorderTopBackgroundColor removes the top border background color rule,\n// if set.\n//\n// Deprecated: This function simply calls Style.UnsetBorderTopBackground.\nfunc (s Style) UnsetBorderTopBackgroundColor() Style {\n\treturn s.UnsetBorderTopBackground()\n}\n\n// UnsetBorderTopBackground removes the top border background color rule,\n// if set.\nfunc (s Style) UnsetBorderTopBackground() Style {\n\ts.unset(borderTopBackgroundKey)\n\treturn s\n}\n\n// UnsetBorderRightBackground removes the right border background color\n// rule, if set.\nfunc (s Style) UnsetBorderRightBackground() Style {\n\ts.unset(borderRightBackgroundKey)\n\treturn s\n}\n\n// UnsetBorderBottomBackground removes the bottom border background color\n// rule, if set.\nfunc (s Style) UnsetBorderBottomBackground() Style {\n\ts.unset(borderBottomBackgroundKey)\n\treturn s\n}\n\n// UnsetBorderLeftBackground removes the left border color rule, if set.\nfunc (s Style) UnsetBorderLeftBackground() Style {\n\ts.unset(borderLeftBackgroundKey)\n\treturn s\n}\n\n// UnsetInline removes the inline style rule, if set.\nfunc (s Style) UnsetInline() Style {\n\ts.unset(inlineKey)\n\treturn s\n}\n\n// UnsetMaxWidth removes the max width style rule, if set.\nfunc (s Style) UnsetMaxWidth() Style {\n\ts.unset(maxWidthKey)\n\treturn s\n}\n\n// UnsetMaxHeight removes the max height style rule, if set.\nfunc (s Style) UnsetMaxHeight() Style {\n\ts.unset(maxHeightKey)\n\treturn s\n}\n\n// UnsetTabWidth removes the tab width style rule, if set.\nfunc (s Style) UnsetTabWidth() Style {\n\ts.unset(tabWidthKey)\n\treturn s\n}\n\n// UnsetUnderlineSpaces removes the value set by UnderlineSpaces.\nfunc (s Style) UnsetUnderlineSpaces() Style {\n\ts.unset(underlineSpacesKey)\n\treturn s\n}\n\n// UnsetStrikethroughSpaces removes the value set by StrikethroughSpaces.\nfunc (s Style) UnsetStrikethroughSpaces() Style {\n\ts.unset(strikethroughSpacesKey)\n\treturn s\n}\n\n// UnsetTransform removes the value set by Transform.\nfunc (s Style) UnsetTransform() Style {\n\ts.unset(transformKey)\n\treturn s\n}\n\n// UnsetString sets the underlying string value to the empty string.\nfunc (s Style) UnsetString() Style {\n\ts.value = \"\"\n\treturn s\n}\n"
        },
        {
          "name": "whitespace.go",
          "type": "blob",
          "size": 1.9462890625,
          "content": "package lipgloss\n\nimport (\n\t\"strings\"\n\n\t\"github.com/charmbracelet/x/ansi\"\n\t\"github.com/muesli/termenv\"\n)\n\n// whitespace is a whitespace renderer.\ntype whitespace struct {\n\tre    *Renderer\n\tstyle termenv.Style\n\tchars string\n}\n\n// newWhitespace creates a new whitespace renderer. The order of the options\n// matters, if you're using WithWhitespaceRenderer, make sure it comes first as\n// other options might depend on it.\nfunc newWhitespace(r *Renderer, opts ...WhitespaceOption) *whitespace {\n\tw := &whitespace{\n\t\tre:    r,\n\t\tstyle: r.ColorProfile().String(),\n\t}\n\tfor _, opt := range opts {\n\t\topt(w)\n\t}\n\treturn w\n}\n\n// Render whitespaces.\nfunc (w whitespace) render(width int) string {\n\tif w.chars == \"\" {\n\t\tw.chars = \" \"\n\t}\n\n\tr := []rune(w.chars)\n\tj := 0\n\tb := strings.Builder{}\n\n\t// Cycle through runes and print them into the whitespace.\n\tfor i := 0; i < width; {\n\t\tb.WriteRune(r[j])\n\t\tj++\n\t\tif j >= len(r) {\n\t\t\tj = 0\n\t\t}\n\t\ti += ansi.StringWidth(string(r[j]))\n\t}\n\n\t// Fill any extra gaps white spaces. This might be necessary if any runes\n\t// are more than one cell wide, which could leave a one-rune gap.\n\tshort := width - ansi.StringWidth(b.String())\n\tif short > 0 {\n\t\tb.WriteString(strings.Repeat(\" \", short))\n\t}\n\n\treturn w.style.Styled(b.String())\n}\n\n// WhitespaceOption sets a styling rule for rendering whitespace.\ntype WhitespaceOption func(*whitespace)\n\n// WithWhitespaceForeground sets the color of the characters in the whitespace.\nfunc WithWhitespaceForeground(c TerminalColor) WhitespaceOption {\n\treturn func(w *whitespace) {\n\t\tw.style = w.style.Foreground(c.color(w.re))\n\t}\n}\n\n// WithWhitespaceBackground sets the background color of the whitespace.\nfunc WithWhitespaceBackground(c TerminalColor) WhitespaceOption {\n\treturn func(w *whitespace) {\n\t\tw.style = w.style.Background(c.color(w.re))\n\t}\n}\n\n// WithWhitespaceChars sets the characters to be rendered in the whitespace.\nfunc WithWhitespaceChars(s string) WhitespaceOption {\n\treturn func(w *whitespace) {\n\t\tw.chars = s\n\t}\n}\n"
        }
      ]
    }
  ]
}