{
  "metadata": {
    "timestamp": 1736567774354,
    "page": 357,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "russross/blackfriday",
      "stars": 5486,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.044921875,
          "content": "*.out\n*.swp\n*.8\n*.6\n_obj\n_test*\nmarkdown\ntags\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.4013671875,
          "content": "sudo: false\nlanguage: go\ngo:\n  - \"1.9.x\"\n  - \"1.10.x\"\n  - \"1.11.x\"\n  - tip\nmatrix:\n  fast_finish: true\n  allow_failures:\n    - go: tip\ninstall:\n  - # Do nothing. This is needed to prevent default install action \"go get -t -v ./...\" from happening here (we want it to happen inside script step).\nscript:\n  - go get -t -v ./...\n  - diff -u <(echo -n) <(gofmt -d -s .)\n  - go tool vet .\n  - go test -v -race ./...\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.3330078125,
          "content": "Blackfriday is distributed under the Simplified BSD License:\n\nCopyright © 2011 Russ Ross\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n1.  Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n2.  Redistributions in binary form must reproduce the above\n    copyright notice, this list of conditions and the following\n    disclaimer in the documentation and/or other materials provided with\n    the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\nFOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\nCOPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\nBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\nANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.64453125,
          "content": "Blackfriday\n[![Build Status][BuildV2SVG]][BuildV2URL]\n[![PkgGoDev][PkgGoDevV2SVG]][PkgGoDevV2URL]\n===========\n\nBlackfriday is a [Markdown][1] processor implemented in [Go][2]. It\nis paranoid about its input (so you can safely feed it user-supplied\ndata), it is fast, it supports common extensions (tables, smart\npunctuation substitutions, etc.), and it is safe for all utf-8\n(unicode) input.\n\nHTML output is currently supported, along with Smartypants\nextensions.\n\nIt started as a translation from C of [Sundown][3].\n\n\nInstallation\n------------\n\nBlackfriday is compatible with modern Go releases in module mode.\nWith Go installed:\n\n    go get github.com/russross/blackfriday\n\nwill resolve and add the package to the current development module,\nthen build and install it. Alternatively, you can achieve the same\nif you import it in a package:\n\n    import \"github.com/russross/blackfriday\"\n\nand `go get` without parameters.\n\nOld versions of Go and legacy GOPATH mode might work,\nbut no effort is made to keep them working.\n\n\nVersions\n--------\n\nCurrently maintained and recommended version of Blackfriday is `v2`. It's being\ndeveloped on its own branch: https://github.com/russross/blackfriday/tree/v2 and the\ndocumentation is available at\nhttps://pkg.go.dev/github.com/russross/blackfriday/v2.\n\nIt is `go get`-able in module mode at `github.com/russross/blackfriday/v2`.\n\nVersion 2 offers a number of improvements over v1:\n\n* Cleaned up API\n* A separate call to [`Parse`][4], which produces an abstract syntax tree for\n  the document\n* Latest bug fixes\n* Flexibility to easily add your own rendering extensions\n\nPotential drawbacks:\n\n* Our benchmarks show v2 to be slightly slower than v1. Currently in the\n  ballpark of around 15%.\n* API breakage. If you can't afford modifying your code to adhere to the new API\n  and don't care too much about the new features, v2 is probably not for you.\n* Several bug fixes are trailing behind and still need to be forward-ported to\n  v2. See issue [#348](https://github.com/russross/blackfriday/issues/348) for\n  tracking.\n\nIf you are still interested in the legacy `v1`, you can import it from\n`github.com/russross/blackfriday`. Documentation for the legacy v1 can be found\nhere: https://pkg.go.dev/github.com/russross/blackfriday.\n\n\nUsage\n-----\n\n### v1\n\nFor basic usage, it is as simple as getting your input into a byte\nslice and calling:\n\n```go\noutput := blackfriday.MarkdownBasic(input)\n```\n\nThis renders it with no extensions enabled. To get a more useful\nfeature set, use this instead:\n\n```go\noutput := blackfriday.MarkdownCommon(input)\n```\n\n### v2\n\nFor the most sensible markdown processing, it is as simple as getting your input\ninto a byte slice and calling:\n\n```go\noutput := blackfriday.Run(input)\n```\n\nYour input will be parsed and the output rendered with a set of most popular\nextensions enabled. If you want the most basic feature set, corresponding with\nthe bare Markdown specification, use:\n\n```go\noutput := blackfriday.Run(input, blackfriday.WithNoExtensions())\n```\n\n### Sanitize untrusted content\n\nBlackfriday itself does nothing to protect against malicious content. If you are\ndealing with user-supplied markdown, we recommend running Blackfriday's output\nthrough HTML sanitizer such as [Bluemonday][5].\n\nHere's an example of simple usage of Blackfriday together with Bluemonday:\n\n```go\nimport (\n    \"github.com/microcosm-cc/bluemonday\"\n    \"github.com/russross/blackfriday\"\n)\n\n// ...\nunsafe := blackfriday.Run(input)\nhtml := bluemonday.UGCPolicy().SanitizeBytes(unsafe)\n```\n\n### Custom options, v1\n\nIf you want to customize the set of options, first get a renderer\n(currently only the HTML output engine), then use it to\ncall the more general `Markdown` function. For examples, see the\nimplementations of `MarkdownBasic` and `MarkdownCommon` in\n`markdown.go`.\n\n### Custom options, v2\n\nIf you want to customize the set of options, use `blackfriday.WithExtensions`,\n`blackfriday.WithRenderer` and `blackfriday.WithRefOverride`.\n\n### `blackfriday-tool`\n\nYou can also check out `blackfriday-tool` for a more complete example\nof how to use it. Download and install it using:\n\n    go get github.com/russross/blackfriday-tool\n\nThis is a simple command-line tool that allows you to process a\nmarkdown file using a standalone program.  You can also browse the\nsource directly on github if you are just looking for some example\ncode:\n\n* <https://github.com/russross/blackfriday-tool>\n\nNote that if you have not already done so, installing\n`blackfriday-tool` will be sufficient to download and install\nblackfriday in addition to the tool itself. The tool binary will be\ninstalled in `$GOPATH/bin`.  This is a statically-linked binary that\ncan be copied to wherever you need it without worrying about\ndependencies and library versions.\n\n### Sanitized anchor names\n\nBlackfriday includes an algorithm for creating sanitized anchor names\ncorresponding to a given input text. This algorithm is used to create\nanchors for headings when `EXTENSION_AUTO_HEADER_IDS` is enabled. The\nalgorithm has a specification, so that other packages can create\ncompatible anchor names and links to those anchors.\n\nThe specification is located at https://pkg.go.dev/github.com/russross/blackfriday#hdr-Sanitized_Anchor_Names.\n\n[`SanitizedAnchorName`](https://pkg.go.dev/github.com/russross/blackfriday#SanitizedAnchorName) exposes this functionality, and can be used to\ncreate compatible links to the anchor names generated by blackfriday.\nThis algorithm is also implemented in a small standalone package at\n[`github.com/shurcooL/sanitized_anchor_name`](https://pkg.go.dev/github.com/shurcooL/sanitized_anchor_name). It can be useful for clients\nthat want a small package and don't need full functionality of blackfriday.\n\n\nFeatures\n--------\n\nAll features of Sundown are supported, including:\n\n*   **Compatibility**. The Markdown v1.0.3 test suite passes with\n    the `--tidy` option.  Without `--tidy`, the differences are\n    mostly in whitespace and entity escaping, where blackfriday is\n    more consistent and cleaner.\n\n*   **Common extensions**, including table support, fenced code\n    blocks, autolinks, strikethroughs, non-strict emphasis, etc.\n\n*   **Safety**. Blackfriday is paranoid when parsing, making it safe\n    to feed untrusted user input without fear of bad things\n    happening. The test suite stress tests this and there are no\n    known inputs that make it crash.  If you find one, please let me\n    know and send me the input that does it.\n\n    NOTE: \"safety\" in this context means *runtime safety only*. In order to\n    protect yourself against JavaScript injection in untrusted content, see\n    [this example](https://github.com/russross/blackfriday#sanitize-untrusted-content).\n\n*   **Fast processing**. It is fast enough to render on-demand in\n    most web applications without having to cache the output.\n\n*   **Thread safety**. You can run multiple parsers in different\n    goroutines without ill effect. There is no dependence on global\n    shared state.\n\n*   **Minimal dependencies**. Blackfriday only depends on standard\n    library packages in Go. The source code is pretty\n    self-contained, so it is easy to add to any project, including\n    Google App Engine projects.\n\n*   **Standards compliant**. Output successfully validates using the\n    W3C validation tool for HTML 4.01 and XHTML 1.0 Transitional.\n\n\nExtensions\n----------\n\nIn addition to the standard markdown syntax, this package\nimplements the following extensions:\n\n*   **Intra-word emphasis supression**. The `_` character is\n    commonly used inside words when discussing code, so having\n    markdown interpret it as an emphasis command is usually the\n    wrong thing. Blackfriday lets you treat all emphasis markers as\n    normal characters when they occur inside a word.\n\n*   **Tables**. Tables can be created by drawing them in the input\n    using a simple syntax:\n\n    ```\n    Name    | Age\n    --------|------\n    Bob     | 27\n    Alice   | 23\n    ```\n\n*   **Fenced code blocks**. In addition to the normal 4-space\n    indentation to mark code blocks, you can explicitly mark them\n    and supply a language (to make syntax highlighting simple). Just\n    mark it like this:\n\n        ```go\n        func getTrue() bool {\n            return true\n        }\n        ```\n\n    You can use 3 or more backticks to mark the beginning of the\n    block, and the same number to mark the end of the block.\n\n    To preserve classes of fenced code blocks while using the bluemonday\n    HTML sanitizer, use the following policy:\n\n    ```go\n    p := bluemonday.UGCPolicy()\n    p.AllowAttrs(\"class\").Matching(regexp.MustCompile(\"^language-[a-zA-Z0-9]+$\")).OnElements(\"code\")\n    html := p.SanitizeBytes(unsafe)\n    ```\n\n*   **Definition lists**. A simple definition list is made of a single-line\n    term followed by a colon and the definition for that term.\n\n        Cat\n        : Fluffy animal everyone likes\n\n        Internet\n        : Vector of transmission for pictures of cats\n\n    Terms must be separated from the previous definition by a blank line.\n\n*   **Footnotes**. A marker in the text that will become a superscript number;\n    a footnote definition that will be placed in a list of footnotes at the\n    end of the document. A footnote looks like this:\n\n        This is a footnote.[^1]\n\n        [^1]: the footnote text.\n\n*   **Autolinking**. Blackfriday can find URLs that have not been\n    explicitly marked as links and turn them into links.\n\n*   **Strikethrough**. Use two tildes (`~~`) to mark text that\n    should be crossed out.\n\n*   **Hard line breaks**. With this extension enabled (it is off by\n    default in the `MarkdownBasic` and `MarkdownCommon` convenience\n    functions), newlines in the input translate into line breaks in\n    the output.\n\n*   **Smart quotes**. Smartypants-style punctuation substitution is\n    supported, turning normal double- and single-quote marks into\n    curly quotes, etc.\n\n*   **LaTeX-style dash parsing** is an additional option, where `--`\n    is translated into `&ndash;`, and `---` is translated into\n    `&mdash;`. This differs from most smartypants processors, which\n    turn a single hyphen into an ndash and a double hyphen into an\n    mdash.\n\n*   **Smart fractions**, where anything that looks like a fraction\n    is translated into suitable HTML (instead of just a few special\n    cases like most smartypant processors). For example, `4/5`\n    becomes `<sup>4</sup>&frasl;<sub>5</sub>`, which renders as\n    <sup>4</sup>&frasl;<sub>5</sub>.\n\n\nOther renderers\n---------------\n\nBlackfriday is structured to allow alternative rendering engines. Here\nare a few of note:\n\n*   [github_flavored_markdown](https://pkg.go.dev/github.com/shurcooL/github_flavored_markdown):\n    provides a GitHub Flavored Markdown renderer with fenced code block\n    highlighting, clickable heading anchor links.\n\n    It's not customizable, and its goal is to produce HTML output\n    equivalent to the [GitHub Markdown API endpoint](https://developer.github.com/v3/markdown/#render-a-markdown-document-in-raw-mode),\n    except the rendering is performed locally.\n\n*   [markdownfmt](https://github.com/shurcooL/markdownfmt): like gofmt,\n    but for markdown.\n\n*   [LaTeX output](https://gitlab.com/ambrevar/blackfriday-latex):\n    renders output as LaTeX.\n\n*   [bfchroma](https://github.com/Depado/bfchroma/): provides convenience\n    integration with the [Chroma](https://github.com/alecthomas/chroma) code\n    highlighting library. bfchroma is only compatible with v2 of Blackfriday and\n    provides a drop-in renderer ready to use with Blackfriday, as well as\n    options and means for further customization.\n\n*   [Blackfriday-Confluence](https://github.com/kentaro-m/blackfriday-confluence): provides a [Confluence Wiki Markup](https://confluence.atlassian.com/doc/confluence-wiki-markup-251003035.html) renderer.\n\n*   [Blackfriday-Slack](https://github.com/karriereat/blackfriday-slack): converts markdown to slack message style\n\n\nTODO\n----\n\n*   More unit testing\n*   Improve Unicode support. It does not understand all Unicode\n    rules (about what constitutes a letter, a punctuation symbol,\n    etc.), so it may fail to detect word boundaries correctly in\n    some instances. It is safe on all UTF-8 input.\n\n\nLicense\n-------\n\n[Blackfriday is distributed under the Simplified BSD License](LICENSE.txt)\n\n\n   [1]: https://daringfireball.net/projects/markdown/ \"Markdown\"\n   [2]: https://golang.org/ \"Go Language\"\n   [3]: https://github.com/vmg/sundown \"Sundown\"\n   [4]: https://pkg.go.dev/github.com/russross/blackfriday/v2#Parse \"Parse func\"\n   [5]: https://github.com/microcosm-cc/bluemonday \"Bluemonday\"\n\n   [BuildV2SVG]: https://travis-ci.org/russross/blackfriday.svg?branch=v2\n   [BuildV2URL]: https://travis-ci.org/russross/blackfriday\n   [PkgGoDevV2SVG]: https://pkg.go.dev/badge/github.com/russross/blackfriday/v2\n   [PkgGoDevV2URL]: https://pkg.go.dev/github.com/russross/blackfriday/v2\n"
        },
        {
          "name": "block.go",
          "type": "blob",
          "size": 30.576171875,
          "content": "//\n// Blackfriday Markdown Processor\n// Available at http://github.com/russross/blackfriday\n//\n// Copyright © 2011 Russ Ross <russ@russross.com>.\n// Distributed under the Simplified BSD License.\n// See README.md for details.\n//\n\n//\n// Functions to parse block-level elements.\n//\n\npackage blackfriday\n\nimport (\n\t\"bytes\"\n\t\"strings\"\n\t\"unicode\"\n)\n\n// Parse block-level data.\n// Note: this function and many that it calls assume that\n// the input buffer ends with a newline.\nfunc (p *parser) block(out *bytes.Buffer, data []byte) {\n\tif len(data) == 0 || data[len(data)-1] != '\\n' {\n\t\tpanic(\"block input is missing terminating newline\")\n\t}\n\n\t// this is called recursively: enforce a maximum depth\n\tif p.nesting >= p.maxNesting {\n\t\treturn\n\t}\n\tp.nesting++\n\n\t// parse out one block-level construct at a time\n\tfor len(data) > 0 {\n\t\t// prefixed header:\n\t\t//\n\t\t// # Header 1\n\t\t// ## Header 2\n\t\t// ...\n\t\t// ###### Header 6\n\t\tif p.isPrefixHeader(data) {\n\t\t\tdata = data[p.prefixHeader(out, data):]\n\t\t\tcontinue\n\t\t}\n\n\t\t// block of preformatted HTML:\n\t\t//\n\t\t// <div>\n\t\t//     ...\n\t\t// </div>\n\t\tif data[0] == '<' {\n\t\t\tif i := p.html(out, data, true); i > 0 {\n\t\t\t\tdata = data[i:]\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// title block\n\t\t//\n\t\t// % stuff\n\t\t// % more stuff\n\t\t// % even more stuff\n\t\tif p.flags&EXTENSION_TITLEBLOCK != 0 {\n\t\t\tif data[0] == '%' {\n\t\t\t\tif i := p.titleBlock(out, data, true); i > 0 {\n\t\t\t\t\tdata = data[i:]\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// blank lines.  note: returns the # of bytes to skip\n\t\tif i := p.isEmpty(data); i > 0 {\n\t\t\tdata = data[i:]\n\t\t\tcontinue\n\t\t}\n\n\t\t// indented code block:\n\t\t//\n\t\t//     func max(a, b int) int {\n\t\t//         if a > b {\n\t\t//             return a\n\t\t//         }\n\t\t//         return b\n\t\t//      }\n\t\tif p.codePrefix(data) > 0 {\n\t\t\tdata = data[p.code(out, data):]\n\t\t\tcontinue\n\t\t}\n\n\t\t// fenced code block:\n\t\t//\n\t\t// ``` go info string here\n\t\t// func fact(n int) int {\n\t\t//     if n <= 1 {\n\t\t//         return n\n\t\t//     }\n\t\t//     return n * fact(n-1)\n\t\t// }\n\t\t// ```\n\t\tif p.flags&EXTENSION_FENCED_CODE != 0 {\n\t\t\tif i := p.fencedCodeBlock(out, data, true); i > 0 {\n\t\t\t\tdata = data[i:]\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// horizontal rule:\n\t\t//\n\t\t// ------\n\t\t// or\n\t\t// ******\n\t\t// or\n\t\t// ______\n\t\tif p.isHRule(data) {\n\t\t\tp.r.HRule(out)\n\t\t\tvar i int\n\t\t\tfor i = 0; data[i] != '\\n'; i++ {\n\t\t\t}\n\t\t\tdata = data[i:]\n\t\t\tcontinue\n\t\t}\n\n\t\t// block quote:\n\t\t//\n\t\t// > A big quote I found somewhere\n\t\t// > on the web\n\t\tif p.quotePrefix(data) > 0 {\n\t\t\tdata = data[p.quote(out, data):]\n\t\t\tcontinue\n\t\t}\n\n\t\t// table:\n\t\t//\n\t\t// Name  | Age | Phone\n\t\t// ------|-----|---------\n\t\t// Bob   | 31  | 555-1234\n\t\t// Alice | 27  | 555-4321\n\t\tif p.flags&EXTENSION_TABLES != 0 {\n\t\t\tif i := p.table(out, data); i > 0 {\n\t\t\t\tdata = data[i:]\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// an itemized/unordered list:\n\t\t//\n\t\t// * Item 1\n\t\t// * Item 2\n\t\t//\n\t\t// also works with + or -\n\t\tif p.uliPrefix(data) > 0 {\n\t\t\tdata = data[p.list(out, data, 0):]\n\t\t\tcontinue\n\t\t}\n\n\t\t// a numbered/ordered list:\n\t\t//\n\t\t// 1. Item 1\n\t\t// 2. Item 2\n\t\tif p.oliPrefix(data) > 0 {\n\t\t\tdata = data[p.list(out, data, LIST_TYPE_ORDERED):]\n\t\t\tcontinue\n\t\t}\n\n\t\t// definition lists:\n\t\t//\n\t\t// Term 1\n\t\t// :   Definition a\n\t\t// :   Definition b\n\t\t//\n\t\t// Term 2\n\t\t// :   Definition c\n\t\tif p.flags&EXTENSION_DEFINITION_LISTS != 0 {\n\t\t\tif p.dliPrefix(data) > 0 {\n\t\t\t\tdata = data[p.list(out, data, LIST_TYPE_DEFINITION):]\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// anything else must look like a normal paragraph\n\t\t// note: this finds underlined headers, too\n\t\tdata = data[p.paragraph(out, data):]\n\t}\n\n\tp.nesting--\n}\n\nfunc (p *parser) isPrefixHeader(data []byte) bool {\n\tif data[0] != '#' {\n\t\treturn false\n\t}\n\n\tif p.flags&EXTENSION_SPACE_HEADERS != 0 {\n\t\tlevel := 0\n\t\tfor level < 6 && data[level] == '#' {\n\t\t\tlevel++\n\t\t}\n\t\tif data[level] != ' ' {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (p *parser) prefixHeader(out *bytes.Buffer, data []byte) int {\n\tlevel := 0\n\tfor level < 6 && data[level] == '#' {\n\t\tlevel++\n\t}\n\ti := skipChar(data, level, ' ')\n\tend := skipUntilChar(data, i, '\\n')\n\tskip := end\n\tid := \"\"\n\tif p.flags&EXTENSION_HEADER_IDS != 0 {\n\t\tj, k := 0, 0\n\t\t// find start/end of header id\n\t\tfor j = i; j < end-1 && (data[j] != '{' || data[j+1] != '#'); j++ {\n\t\t}\n\t\tfor k = j + 1; k < end && data[k] != '}'; k++ {\n\t\t}\n\t\t// extract header id iff found\n\t\tif j < end && k < end {\n\t\t\tid = string(data[j+2 : k])\n\t\t\tend = j\n\t\t\tskip = k + 1\n\t\t\tfor end > 0 && data[end-1] == ' ' {\n\t\t\t\tend--\n\t\t\t}\n\t\t}\n\t}\n\tfor end > 0 && data[end-1] == '#' {\n\t\tif isBackslashEscaped(data, end-1) {\n\t\t\tbreak\n\t\t}\n\t\tend--\n\t}\n\tfor end > 0 && data[end-1] == ' ' {\n\t\tend--\n\t}\n\tif end > i {\n\t\tif id == \"\" && p.flags&EXTENSION_AUTO_HEADER_IDS != 0 {\n\t\t\tid = SanitizedAnchorName(string(data[i:end]))\n\t\t}\n\t\twork := func() bool {\n\t\t\tp.inline(out, data[i:end])\n\t\t\treturn true\n\t\t}\n\t\tp.r.Header(out, work, level, id)\n\t}\n\treturn skip\n}\n\nfunc (p *parser) isUnderlinedHeader(data []byte) int {\n\t// test of level 1 header\n\tif data[0] == '=' {\n\t\ti := skipChar(data, 1, '=')\n\t\ti = skipChar(data, i, ' ')\n\t\tif data[i] == '\\n' {\n\t\t\treturn 1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\t}\n\n\t// test of level 2 header\n\tif data[0] == '-' {\n\t\ti := skipChar(data, 1, '-')\n\t\ti = skipChar(data, i, ' ')\n\t\tif data[i] == '\\n' {\n\t\t\treturn 2\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\t}\n\n\treturn 0\n}\n\nfunc (p *parser) titleBlock(out *bytes.Buffer, data []byte, doRender bool) int {\n\tif data[0] != '%' {\n\t\treturn 0\n\t}\n\tsplitData := bytes.Split(data, []byte(\"\\n\"))\n\tvar i int\n\tfor idx, b := range splitData {\n\t\tif !bytes.HasPrefix(b, []byte(\"%\")) {\n\t\t\ti = idx // - 1\n\t\t\tbreak\n\t\t}\n\t}\n\n\tdata = bytes.Join(splitData[0:i], []byte(\"\\n\"))\n\tp.r.TitleBlock(out, data)\n\n\treturn len(data)\n}\n\nfunc (p *parser) html(out *bytes.Buffer, data []byte, doRender bool) int {\n\tvar i, j int\n\n\t// identify the opening tag\n\tif data[0] != '<' {\n\t\treturn 0\n\t}\n\tcurtag, tagfound := p.htmlFindTag(data[1:])\n\n\t// handle special cases\n\tif !tagfound {\n\t\t// check for an HTML comment\n\t\tif size := p.htmlComment(out, data, doRender); size > 0 {\n\t\t\treturn size\n\t\t}\n\n\t\t// check for an <hr> tag\n\t\tif size := p.htmlHr(out, data, doRender); size > 0 {\n\t\t\treturn size\n\t\t}\n\n\t\t// check for HTML CDATA\n\t\tif size := p.htmlCDATA(out, data, doRender); size > 0 {\n\t\t\treturn size\n\t\t}\n\n\t\t// no special case recognized\n\t\treturn 0\n\t}\n\n\t// look for an unindented matching closing tag\n\t// followed by a blank line\n\tfound := false\n\t/*\n\t\tclosetag := []byte(\"\\n</\" + curtag + \">\")\n\t\tj = len(curtag) + 1\n\t\tfor !found {\n\t\t\t// scan for a closing tag at the beginning of a line\n\t\t\tif skip := bytes.Index(data[j:], closetag); skip >= 0 {\n\t\t\t\tj += skip + len(closetag)\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// see if it is the only thing on the line\n\t\t\tif skip := p.isEmpty(data[j:]); skip > 0 {\n\t\t\t\t// see if it is followed by a blank line/eof\n\t\t\t\tj += skip\n\t\t\t\tif j >= len(data) {\n\t\t\t\t\tfound = true\n\t\t\t\t\ti = j\n\t\t\t\t} else {\n\t\t\t\t\tif skip := p.isEmpty(data[j:]); skip > 0 {\n\t\t\t\t\t\tj += skip\n\t\t\t\t\t\tfound = true\n\t\t\t\t\t\ti = j\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t*/\n\n\t// if not found, try a second pass looking for indented match\n\t// but not if tag is \"ins\" or \"del\" (following original Markdown.pl)\n\tif !found && curtag != \"ins\" && curtag != \"del\" {\n\t\ti = 1\n\t\tfor i < len(data) {\n\t\t\ti++\n\t\t\tfor i < len(data) && !(data[i-1] == '<' && data[i] == '/') {\n\t\t\t\ti++\n\t\t\t}\n\n\t\t\tif i+2+len(curtag) >= len(data) {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tj = p.htmlFindEnd(curtag, data[i-1:])\n\n\t\t\tif j > 0 {\n\t\t\t\ti += j - 1\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif !found {\n\t\treturn 0\n\t}\n\n\t// the end of the block has been found\n\tif doRender {\n\t\t// trim newlines\n\t\tend := i\n\t\tfor end > 0 && data[end-1] == '\\n' {\n\t\t\tend--\n\t\t}\n\t\tp.r.BlockHtml(out, data[:end])\n\t}\n\n\treturn i\n}\n\nfunc (p *parser) renderHTMLBlock(out *bytes.Buffer, data []byte, start int, doRender bool) int {\n\t// html block needs to end with a blank line\n\tif i := p.isEmpty(data[start:]); i > 0 {\n\t\tsize := start + i\n\t\tif doRender {\n\t\t\t// trim trailing newlines\n\t\t\tend := size\n\t\t\tfor end > 0 && data[end-1] == '\\n' {\n\t\t\t\tend--\n\t\t\t}\n\t\t\tp.r.BlockHtml(out, data[:end])\n\t\t}\n\t\treturn size\n\t}\n\treturn 0\n}\n\n// HTML comment, lax form\nfunc (p *parser) htmlComment(out *bytes.Buffer, data []byte, doRender bool) int {\n\ti := p.inlineHTMLComment(out, data)\n\treturn p.renderHTMLBlock(out, data, i, doRender)\n}\n\n// HTML CDATA section\nfunc (p *parser) htmlCDATA(out *bytes.Buffer, data []byte, doRender bool) int {\n\tconst cdataTag = \"<![cdata[\"\n\tconst cdataTagLen = len(cdataTag)\n\tif len(data) < cdataTagLen+1 {\n\t\treturn 0\n\t}\n\tif !bytes.Equal(bytes.ToLower(data[:cdataTagLen]), []byte(cdataTag)) {\n\t\treturn 0\n\t}\n\ti := cdataTagLen\n\t// scan for an end-of-comment marker, across lines if necessary\n\tfor i < len(data) && !(data[i-2] == ']' && data[i-1] == ']' && data[i] == '>') {\n\t\ti++\n\t}\n\ti++\n\t// no end-of-comment marker\n\tif i >= len(data) {\n\t\treturn 0\n\t}\n\treturn p.renderHTMLBlock(out, data, i, doRender)\n}\n\n// HR, which is the only self-closing block tag considered\nfunc (p *parser) htmlHr(out *bytes.Buffer, data []byte, doRender bool) int {\n\tif data[0] != '<' || (data[1] != 'h' && data[1] != 'H') || (data[2] != 'r' && data[2] != 'R') {\n\t\treturn 0\n\t}\n\tif data[3] != ' ' && data[3] != '/' && data[3] != '>' {\n\t\t// not an <hr> tag after all; at least not a valid one\n\t\treturn 0\n\t}\n\n\ti := 3\n\tfor data[i] != '>' && data[i] != '\\n' {\n\t\ti++\n\t}\n\n\tif data[i] == '>' {\n\t\treturn p.renderHTMLBlock(out, data, i+1, doRender)\n\t}\n\n\treturn 0\n}\n\nfunc (p *parser) htmlFindTag(data []byte) (string, bool) {\n\ti := 0\n\tfor isalnum(data[i]) {\n\t\ti++\n\t}\n\tkey := string(data[:i])\n\tif _, ok := blockTags[key]; ok {\n\t\treturn key, true\n\t}\n\treturn \"\", false\n}\n\nfunc (p *parser) htmlFindEnd(tag string, data []byte) int {\n\t// assume data[0] == '<' && data[1] == '/' already tested\n\n\t// check if tag is a match\n\tclosetag := []byte(\"</\" + tag + \">\")\n\tif !bytes.HasPrefix(data, closetag) {\n\t\treturn 0\n\t}\n\ti := len(closetag)\n\n\t// check that the rest of the line is blank\n\tskip := 0\n\tif skip = p.isEmpty(data[i:]); skip == 0 {\n\t\treturn 0\n\t}\n\ti += skip\n\tskip = 0\n\n\tif i >= len(data) {\n\t\treturn i\n\t}\n\n\tif p.flags&EXTENSION_LAX_HTML_BLOCKS != 0 {\n\t\treturn i\n\t}\n\tif skip = p.isEmpty(data[i:]); skip == 0 {\n\t\t// following line must be blank\n\t\treturn 0\n\t}\n\n\treturn i + skip\n}\n\nfunc (*parser) isEmpty(data []byte) int {\n\t// it is okay to call isEmpty on an empty buffer\n\tif len(data) == 0 {\n\t\treturn 0\n\t}\n\n\tvar i int\n\tfor i = 0; i < len(data) && data[i] != '\\n'; i++ {\n\t\tif data[i] != ' ' && data[i] != '\\t' {\n\t\t\treturn 0\n\t\t}\n\t}\n\treturn i + 1\n}\n\nfunc (*parser) isHRule(data []byte) bool {\n\ti := 0\n\n\t// skip up to three spaces\n\tfor i < 3 && data[i] == ' ' {\n\t\ti++\n\t}\n\n\t// look at the hrule char\n\tif data[i] != '*' && data[i] != '-' && data[i] != '_' {\n\t\treturn false\n\t}\n\tc := data[i]\n\n\t// the whole line must be the char or whitespace\n\tn := 0\n\tfor data[i] != '\\n' {\n\t\tswitch {\n\t\tcase data[i] == c:\n\t\t\tn++\n\t\tcase data[i] != ' ':\n\t\t\treturn false\n\t\t}\n\t\ti++\n\t}\n\n\treturn n >= 3\n}\n\n// isFenceLine checks if there's a fence line (e.g., ``` or ``` go) at the beginning of data,\n// and returns the end index if so, or 0 otherwise. It also returns the marker found.\n// If syntax is not nil, it gets set to the syntax specified in the fence line.\n// A final newline is mandatory to recognize the fence line, unless newlineOptional is true.\nfunc isFenceLine(data []byte, info *string, oldmarker string, newlineOptional bool) (end int, marker string) {\n\ti, size := 0, 0\n\n\t// skip up to three spaces\n\tfor i < len(data) && i < 3 && data[i] == ' ' {\n\t\ti++\n\t}\n\n\t// check for the marker characters: ~ or `\n\tif i >= len(data) {\n\t\treturn 0, \"\"\n\t}\n\tif data[i] != '~' && data[i] != '`' {\n\t\treturn 0, \"\"\n\t}\n\n\tc := data[i]\n\n\t// the whole line must be the same char or whitespace\n\tfor i < len(data) && data[i] == c {\n\t\tsize++\n\t\ti++\n\t}\n\n\t// the marker char must occur at least 3 times\n\tif size < 3 {\n\t\treturn 0, \"\"\n\t}\n\tmarker = string(data[i-size : i])\n\n\t// if this is the end marker, it must match the beginning marker\n\tif oldmarker != \"\" && marker != oldmarker {\n\t\treturn 0, \"\"\n\t}\n\n\t// TODO(shurcooL): It's probably a good idea to simplify the 2 code paths here\n\t// into one, always get the info string, and discard it if the caller doesn't care.\n\tif info != nil {\n\t\tinfoLength := 0\n\t\ti = skipChar(data, i, ' ')\n\n\t\tif i >= len(data) {\n\t\t\tif newlineOptional && i == len(data) {\n\t\t\t\treturn i, marker\n\t\t\t}\n\t\t\treturn 0, \"\"\n\t\t}\n\n\t\tinfoStart := i\n\n\t\tif data[i] == '{' {\n\t\t\ti++\n\t\t\tinfoStart++\n\n\t\t\tfor i < len(data) && data[i] != '}' && data[i] != '\\n' {\n\t\t\t\tinfoLength++\n\t\t\t\ti++\n\t\t\t}\n\n\t\t\tif i >= len(data) || data[i] != '}' {\n\t\t\t\treturn 0, \"\"\n\t\t\t}\n\n\t\t\t// strip all whitespace at the beginning and the end\n\t\t\t// of the {} block\n\t\t\tfor infoLength > 0 && isspace(data[infoStart]) {\n\t\t\t\tinfoStart++\n\t\t\t\tinfoLength--\n\t\t\t}\n\n\t\t\tfor infoLength > 0 && isspace(data[infoStart+infoLength-1]) {\n\t\t\t\tinfoLength--\n\t\t\t}\n\n\t\t\ti++\n\t\t} else {\n\t\t\tfor i < len(data) && !isverticalspace(data[i]) {\n\t\t\t\tinfoLength++\n\t\t\t\ti++\n\t\t\t}\n\t\t}\n\n\t\t*info = strings.TrimSpace(string(data[infoStart : infoStart+infoLength]))\n\t}\n\n\ti = skipChar(data, i, ' ')\n\tif i >= len(data) {\n\t\tif newlineOptional {\n\t\t\treturn i, marker\n\t\t}\n\t\treturn 0, \"\"\n\t}\n\tif data[i] == '\\n' {\n\t\ti++ // Take newline into account\n\t}\n\n\treturn i, marker\n}\n\n// fencedCodeBlock returns the end index if data contains a fenced code block at the beginning,\n// or 0 otherwise. It writes to out if doRender is true, otherwise it has no side effects.\n// If doRender is true, a final newline is mandatory to recognize the fenced code block.\nfunc (p *parser) fencedCodeBlock(out *bytes.Buffer, data []byte, doRender bool) int {\n\tvar infoString string\n\tbeg, marker := isFenceLine(data, &infoString, \"\", false)\n\tif beg == 0 || beg >= len(data) {\n\t\treturn 0\n\t}\n\n\tvar work bytes.Buffer\n\n\tfor {\n\t\t// safe to assume beg < len(data)\n\n\t\t// check for the end of the code block\n\t\tnewlineOptional := !doRender\n\t\tfenceEnd, _ := isFenceLine(data[beg:], nil, marker, newlineOptional)\n\t\tif fenceEnd != 0 {\n\t\t\tbeg += fenceEnd\n\t\t\tbreak\n\t\t}\n\n\t\t// copy the current line\n\t\tend := skipUntilChar(data, beg, '\\n') + 1\n\n\t\t// did we reach the end of the buffer without a closing marker?\n\t\tif end >= len(data) {\n\t\t\treturn 0\n\t\t}\n\n\t\t// verbatim copy to the working buffer\n\t\tif doRender {\n\t\t\twork.Write(data[beg:end])\n\t\t}\n\t\tbeg = end\n\t}\n\n\tif doRender {\n\t\tp.r.BlockCode(out, work.Bytes(), infoString)\n\t}\n\n\treturn beg\n}\n\nfunc (p *parser) table(out *bytes.Buffer, data []byte) int {\n\tvar header bytes.Buffer\n\ti, columns := p.tableHeader(&header, data)\n\tif i == 0 {\n\t\treturn 0\n\t}\n\n\tvar body bytes.Buffer\n\n\tfor i < len(data) {\n\t\tpipes, rowStart := 0, i\n\t\tfor ; data[i] != '\\n'; i++ {\n\t\t\tif data[i] == '|' {\n\t\t\t\tpipes++\n\t\t\t}\n\t\t}\n\n\t\tif pipes == 0 {\n\t\t\ti = rowStart\n\t\t\tbreak\n\t\t}\n\n\t\t// include the newline in data sent to tableRow\n\t\ti++\n\t\tp.tableRow(&body, data[rowStart:i], columns, false)\n\t}\n\n\tp.r.Table(out, header.Bytes(), body.Bytes(), columns)\n\n\treturn i\n}\n\n// check if the specified position is preceded by an odd number of backslashes\nfunc isBackslashEscaped(data []byte, i int) bool {\n\tbackslashes := 0\n\tfor i-backslashes-1 >= 0 && data[i-backslashes-1] == '\\\\' {\n\t\tbackslashes++\n\t}\n\treturn backslashes&1 == 1\n}\n\nfunc (p *parser) tableHeader(out *bytes.Buffer, data []byte) (size int, columns []int) {\n\ti := 0\n\tcolCount := 1\n\tfor i = 0; data[i] != '\\n'; i++ {\n\t\tif data[i] == '|' && !isBackslashEscaped(data, i) {\n\t\t\tcolCount++\n\t\t}\n\t}\n\n\t// doesn't look like a table header\n\tif colCount == 1 {\n\t\treturn\n\t}\n\n\t// include the newline in the data sent to tableRow\n\theader := data[:i+1]\n\n\t// column count ignores pipes at beginning or end of line\n\tif data[0] == '|' {\n\t\tcolCount--\n\t}\n\tif i > 2 && data[i-1] == '|' && !isBackslashEscaped(data, i-1) {\n\t\tcolCount--\n\t}\n\n\tcolumns = make([]int, colCount)\n\n\t// move on to the header underline\n\ti++\n\tif i >= len(data) {\n\t\treturn\n\t}\n\n\tif data[i] == '|' && !isBackslashEscaped(data, i) {\n\t\ti++\n\t}\n\ti = skipChar(data, i, ' ')\n\n\t// each column header is of form: / *:?-+:? *|/ with # dashes + # colons >= 3\n\t// and trailing | optional on last column\n\tcol := 0\n\tfor data[i] != '\\n' {\n\t\tdashes := 0\n\n\t\tif data[i] == ':' {\n\t\t\ti++\n\t\t\tcolumns[col] |= TABLE_ALIGNMENT_LEFT\n\t\t\tdashes++\n\t\t}\n\t\tfor data[i] == '-' {\n\t\t\ti++\n\t\t\tdashes++\n\t\t}\n\t\tif data[i] == ':' {\n\t\t\ti++\n\t\t\tcolumns[col] |= TABLE_ALIGNMENT_RIGHT\n\t\t\tdashes++\n\t\t}\n\t\tfor data[i] == ' ' {\n\t\t\ti++\n\t\t}\n\n\t\t// end of column test is messy\n\t\tswitch {\n\t\tcase dashes < 3:\n\t\t\t// not a valid column\n\t\t\treturn\n\n\t\tcase data[i] == '|' && !isBackslashEscaped(data, i):\n\t\t\t// marker found, now skip past trailing whitespace\n\t\t\tcol++\n\t\t\ti++\n\t\t\tfor data[i] == ' ' {\n\t\t\t\ti++\n\t\t\t}\n\n\t\t\t// trailing junk found after last column\n\t\t\tif col >= colCount && data[i] != '\\n' {\n\t\t\t\treturn\n\t\t\t}\n\n\t\tcase (data[i] != '|' || isBackslashEscaped(data, i)) && col+1 < colCount:\n\t\t\t// something else found where marker was required\n\t\t\treturn\n\n\t\tcase data[i] == '\\n':\n\t\t\t// marker is optional for the last column\n\t\t\tcol++\n\n\t\tdefault:\n\t\t\t// trailing junk found after last column\n\t\t\treturn\n\t\t}\n\t}\n\tif col != colCount {\n\t\treturn\n\t}\n\n\tp.tableRow(out, header, columns, true)\n\tsize = i + 1\n\treturn\n}\n\nfunc (p *parser) tableRow(out *bytes.Buffer, data []byte, columns []int, header bool) {\n\ti, col := 0, 0\n\tvar rowWork bytes.Buffer\n\n\tif data[i] == '|' && !isBackslashEscaped(data, i) {\n\t\ti++\n\t}\n\n\tfor col = 0; col < len(columns) && i < len(data); col++ {\n\t\tfor data[i] == ' ' {\n\t\t\ti++\n\t\t}\n\n\t\tcellStart := i\n\n\t\tfor (data[i] != '|' || isBackslashEscaped(data, i)) && data[i] != '\\n' {\n\t\t\ti++\n\t\t}\n\n\t\tcellEnd := i\n\n\t\t// skip the end-of-cell marker, possibly taking us past end of buffer\n\t\ti++\n\n\t\tfor cellEnd > cellStart && data[cellEnd-1] == ' ' {\n\t\t\tcellEnd--\n\t\t}\n\n\t\tvar cellWork bytes.Buffer\n\t\tp.inline(&cellWork, data[cellStart:cellEnd])\n\n\t\tif header {\n\t\t\tp.r.TableHeaderCell(&rowWork, cellWork.Bytes(), columns[col])\n\t\t} else {\n\t\t\tp.r.TableCell(&rowWork, cellWork.Bytes(), columns[col])\n\t\t}\n\t}\n\n\t// pad it out with empty columns to get the right number\n\tfor ; col < len(columns); col++ {\n\t\tif header {\n\t\t\tp.r.TableHeaderCell(&rowWork, nil, columns[col])\n\t\t} else {\n\t\t\tp.r.TableCell(&rowWork, nil, columns[col])\n\t\t}\n\t}\n\n\t// silently ignore rows with too many cells\n\n\tp.r.TableRow(out, rowWork.Bytes())\n}\n\n// returns blockquote prefix length\nfunc (p *parser) quotePrefix(data []byte) int {\n\ti := 0\n\tfor i < 3 && data[i] == ' ' {\n\t\ti++\n\t}\n\tif data[i] == '>' {\n\t\tif data[i+1] == ' ' {\n\t\t\treturn i + 2\n\t\t}\n\t\treturn i + 1\n\t}\n\treturn 0\n}\n\n// blockquote ends with at least one blank line\n// followed by something without a blockquote prefix\nfunc (p *parser) terminateBlockquote(data []byte, beg, end int) bool {\n\tif p.isEmpty(data[beg:]) <= 0 {\n\t\treturn false\n\t}\n\tif end >= len(data) {\n\t\treturn true\n\t}\n\treturn p.quotePrefix(data[end:]) == 0 && p.isEmpty(data[end:]) == 0\n}\n\n// parse a blockquote fragment\nfunc (p *parser) quote(out *bytes.Buffer, data []byte) int {\n\tvar raw bytes.Buffer\n\tbeg, end := 0, 0\n\tfor beg < len(data) {\n\t\tend = beg\n\t\t// Step over whole lines, collecting them. While doing that, check for\n\t\t// fenced code and if one's found, incorporate it altogether,\n\t\t// irregardless of any contents inside it\n\t\tfor data[end] != '\\n' {\n\t\t\tif p.flags&EXTENSION_FENCED_CODE != 0 {\n\t\t\t\tif i := p.fencedCodeBlock(out, data[end:], false); i > 0 {\n\t\t\t\t\t// -1 to compensate for the extra end++ after the loop:\n\t\t\t\t\tend += i - 1\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tend++\n\t\t}\n\t\tend++\n\n\t\tif pre := p.quotePrefix(data[beg:]); pre > 0 {\n\t\t\t// skip the prefix\n\t\t\tbeg += pre\n\t\t} else if p.terminateBlockquote(data, beg, end) {\n\t\t\tbreak\n\t\t}\n\n\t\t// this line is part of the blockquote\n\t\traw.Write(data[beg:end])\n\t\tbeg = end\n\t}\n\n\tvar cooked bytes.Buffer\n\tp.block(&cooked, raw.Bytes())\n\tp.r.BlockQuote(out, cooked.Bytes())\n\treturn end\n}\n\n// returns prefix length for block code\nfunc (p *parser) codePrefix(data []byte) int {\n\tif data[0] == ' ' && data[1] == ' ' && data[2] == ' ' && data[3] == ' ' {\n\t\treturn 4\n\t}\n\treturn 0\n}\n\nfunc (p *parser) code(out *bytes.Buffer, data []byte) int {\n\tvar work bytes.Buffer\n\n\ti := 0\n\tfor i < len(data) {\n\t\tbeg := i\n\t\tfor data[i] != '\\n' {\n\t\t\ti++\n\t\t}\n\t\ti++\n\n\t\tblankline := p.isEmpty(data[beg:i]) > 0\n\t\tif pre := p.codePrefix(data[beg:i]); pre > 0 {\n\t\t\tbeg += pre\n\t\t} else if !blankline {\n\t\t\t// non-empty, non-prefixed line breaks the pre\n\t\t\ti = beg\n\t\t\tbreak\n\t\t}\n\n\t\t// verbatim copy to the working buffeu\n\t\tif blankline {\n\t\t\twork.WriteByte('\\n')\n\t\t} else {\n\t\t\twork.Write(data[beg:i])\n\t\t}\n\t}\n\n\t// trim all the \\n off the end of work\n\tworkbytes := work.Bytes()\n\teol := len(workbytes)\n\tfor eol > 0 && workbytes[eol-1] == '\\n' {\n\t\teol--\n\t}\n\tif eol != len(workbytes) {\n\t\twork.Truncate(eol)\n\t}\n\n\twork.WriteByte('\\n')\n\n\tp.r.BlockCode(out, work.Bytes(), \"\")\n\n\treturn i\n}\n\n// returns unordered list item prefix\nfunc (p *parser) uliPrefix(data []byte) int {\n\ti := 0\n\n\t// start with up to 3 spaces\n\tfor i < 3 && data[i] == ' ' {\n\t\ti++\n\t}\n\n\t// need a *, +, or - followed by a space\n\tif (data[i] != '*' && data[i] != '+' && data[i] != '-') ||\n\t\tdata[i+1] != ' ' {\n\t\treturn 0\n\t}\n\treturn i + 2\n}\n\n// returns ordered list item prefix\nfunc (p *parser) oliPrefix(data []byte) int {\n\ti := 0\n\n\t// start with up to 3 spaces\n\tfor i < 3 && data[i] == ' ' {\n\t\ti++\n\t}\n\n\t// count the digits\n\tstart := i\n\tfor data[i] >= '0' && data[i] <= '9' {\n\t\ti++\n\t}\n\n\t// we need >= 1 digits followed by a dot and a space\n\tif start == i || data[i] != '.' || data[i+1] != ' ' {\n\t\treturn 0\n\t}\n\treturn i + 2\n}\n\n// returns definition list item prefix\nfunc (p *parser) dliPrefix(data []byte) int {\n\ti := 0\n\n\t// need a : followed by a spaces\n\tif data[i] != ':' || data[i+1] != ' ' {\n\t\treturn 0\n\t}\n\tfor data[i] == ' ' {\n\t\ti++\n\t}\n\treturn i + 2\n}\n\n// parse ordered or unordered list block\nfunc (p *parser) list(out *bytes.Buffer, data []byte, flags int) int {\n\ti := 0\n\tflags |= LIST_ITEM_BEGINNING_OF_LIST\n\twork := func() bool {\n\t\tfor i < len(data) {\n\t\t\tskip := p.listItem(out, data[i:], &flags)\n\t\t\ti += skip\n\n\t\t\tif skip == 0 || flags&LIST_ITEM_END_OF_LIST != 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tflags &= ^LIST_ITEM_BEGINNING_OF_LIST\n\t\t}\n\t\treturn true\n\t}\n\n\tp.r.List(out, work, flags)\n\treturn i\n}\n\n// Parse a single list item.\n// Assumes initial prefix is already removed if this is a sublist.\nfunc (p *parser) listItem(out *bytes.Buffer, data []byte, flags *int) int {\n\t// keep track of the indentation of the first line\n\titemIndent := 0\n\tfor itemIndent < 3 && data[itemIndent] == ' ' {\n\t\titemIndent++\n\t}\n\n\ti := p.uliPrefix(data)\n\tif i == 0 {\n\t\ti = p.oliPrefix(data)\n\t}\n\tif i == 0 {\n\t\ti = p.dliPrefix(data)\n\t\t// reset definition term flag\n\t\tif i > 0 {\n\t\t\t*flags &= ^LIST_TYPE_TERM\n\t\t}\n\t}\n\tif i == 0 {\n\t\t// if in defnition list, set term flag and continue\n\t\tif *flags&LIST_TYPE_DEFINITION != 0 {\n\t\t\t*flags |= LIST_TYPE_TERM\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\t}\n\n\t// skip leading whitespace on first line\n\tfor data[i] == ' ' {\n\t\ti++\n\t}\n\n\t// find the end of the line\n\tline := i\n\tfor i > 0 && data[i-1] != '\\n' {\n\t\ti++\n\t}\n\n\t// process the following lines\n\tcontainsBlankLine := false\n\tsublist := 0\n\tcodeBlockMarker := \"\"\n\tif p.flags&EXTENSION_FENCED_CODE != 0 && i > line {\n\t\t// determine if codeblock starts on the first line\n\t\t_, codeBlockMarker = isFenceLine(data[line:i], nil, \"\", false)\n\t}\n\n\t// get working buffer\n\tvar raw bytes.Buffer\n\n\t// put the first line into the working buffer\n\traw.Write(data[line:i])\n\tline = i\n\ngatherlines:\n\tfor line < len(data) {\n\t\ti++\n\n\t\t// find the end of this line\n\t\tfor data[i-1] != '\\n' {\n\t\t\ti++\n\t\t}\n\t\t// if it is an empty line, guess that it is part of this item\n\t\t// and move on to the next line\n\t\tif p.isEmpty(data[line:i]) > 0 {\n\t\t\tcontainsBlankLine = true\n\t\t\traw.Write(data[line:i])\n\t\t\tline = i\n\t\t\tcontinue\n\t\t}\n\n\t\t// calculate the indentation\n\t\tindent := 0\n\t\tfor indent < 4 && line+indent < i && data[line+indent] == ' ' {\n\t\t\tindent++\n\t\t}\n\n\t\tchunk := data[line+indent : i]\n\n\t\tif p.flags&EXTENSION_FENCED_CODE != 0 {\n\t\t\t// determine if in or out of codeblock\n\t\t\t// if in codeblock, ignore normal list processing\n\t\t\t_, marker := isFenceLine(chunk, nil, codeBlockMarker, false)\n\t\t\tif marker != \"\" {\n\t\t\t\tif codeBlockMarker == \"\" {\n\t\t\t\t\t// start of codeblock\n\t\t\t\t\tcodeBlockMarker = marker\n\t\t\t\t} else {\n\t\t\t\t\t// end of codeblock.\n\t\t\t\t\t*flags |= LIST_ITEM_CONTAINS_BLOCK\n\t\t\t\t\tcodeBlockMarker = \"\"\n\t\t\t\t}\n\t\t\t}\n\t\t\t// we are in a codeblock, write line, and continue\n\t\t\tif codeBlockMarker != \"\" || marker != \"\" {\n\t\t\t\traw.Write(data[line+indent : i])\n\t\t\t\tline = i\n\t\t\t\tcontinue gatherlines\n\t\t\t}\n\t\t}\n\n\t\t// evaluate how this line fits in\n\t\tswitch {\n\t\t// is this a nested list item?\n\t\tcase (p.uliPrefix(chunk) > 0 && !p.isHRule(chunk)) ||\n\t\t\tp.oliPrefix(chunk) > 0 ||\n\t\t\tp.dliPrefix(chunk) > 0:\n\n\t\t\tif containsBlankLine {\n\t\t\t\t// end the list if the type changed after a blank line\n\t\t\t\tif indent <= itemIndent &&\n\t\t\t\t\t((*flags&LIST_TYPE_ORDERED != 0 && p.uliPrefix(chunk) > 0) ||\n\t\t\t\t\t\t(*flags&LIST_TYPE_ORDERED == 0 && p.oliPrefix(chunk) > 0)) {\n\n\t\t\t\t\t*flags |= LIST_ITEM_END_OF_LIST\n\t\t\t\t\tbreak gatherlines\n\t\t\t\t}\n\t\t\t\t*flags |= LIST_ITEM_CONTAINS_BLOCK\n\t\t\t}\n\n\t\t\t// to be a nested list, it must be indented more\n\t\t\t// if not, it is the next item in the same list\n\t\t\tif indent <= itemIndent {\n\t\t\t\tbreak gatherlines\n\t\t\t}\n\n\t\t\t// is this the first item in the nested list?\n\t\t\tif sublist == 0 {\n\t\t\t\tsublist = raw.Len()\n\t\t\t}\n\n\t\t// is this a nested prefix header?\n\t\tcase p.isPrefixHeader(chunk):\n\t\t\t// if the header is not indented, it is not nested in the list\n\t\t\t// and thus ends the list\n\t\t\tif containsBlankLine && indent < 4 {\n\t\t\t\t*flags |= LIST_ITEM_END_OF_LIST\n\t\t\t\tbreak gatherlines\n\t\t\t}\n\t\t\t*flags |= LIST_ITEM_CONTAINS_BLOCK\n\n\t\t// anything following an empty line is only part\n\t\t// of this item if it is indented 4 spaces\n\t\t// (regardless of the indentation of the beginning of the item)\n\t\tcase containsBlankLine && indent < 4:\n\t\t\tif *flags&LIST_TYPE_DEFINITION != 0 && i < len(data)-1 {\n\t\t\t\t// is the next item still a part of this list?\n\t\t\t\tnext := i\n\t\t\t\tfor data[next] != '\\n' {\n\t\t\t\t\tnext++\n\t\t\t\t}\n\t\t\t\tfor next < len(data)-1 && data[next] == '\\n' {\n\t\t\t\t\tnext++\n\t\t\t\t}\n\t\t\t\tif i < len(data)-1 && data[i] != ':' && data[next] != ':' {\n\t\t\t\t\t*flags |= LIST_ITEM_END_OF_LIST\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*flags |= LIST_ITEM_END_OF_LIST\n\t\t\t}\n\t\t\tbreak gatherlines\n\n\t\t// a blank line means this should be parsed as a block\n\t\tcase containsBlankLine:\n\t\t\t*flags |= LIST_ITEM_CONTAINS_BLOCK\n\t\t}\n\n\t\tcontainsBlankLine = false\n\n\t\t// add the line into the working buffer without prefix\n\t\traw.Write(data[line+indent : i])\n\n\t\tline = i\n\t}\n\n\t// If reached end of data, the Renderer.ListItem call we're going to make below\n\t// is definitely the last in the list.\n\tif line >= len(data) {\n\t\t*flags |= LIST_ITEM_END_OF_LIST\n\t}\n\n\trawBytes := raw.Bytes()\n\n\t// render the contents of the list item\n\tvar cooked bytes.Buffer\n\tif *flags&LIST_ITEM_CONTAINS_BLOCK != 0 && *flags&LIST_TYPE_TERM == 0 {\n\t\t// intermediate render of block item, except for definition term\n\t\tif sublist > 0 {\n\t\t\tp.block(&cooked, rawBytes[:sublist])\n\t\t\tp.block(&cooked, rawBytes[sublist:])\n\t\t} else {\n\t\t\tp.block(&cooked, rawBytes)\n\t\t}\n\t} else {\n\t\t// intermediate render of inline item\n\t\tif sublist > 0 {\n\t\t\tp.inline(&cooked, rawBytes[:sublist])\n\t\t\tp.block(&cooked, rawBytes[sublist:])\n\t\t} else {\n\t\t\tp.inline(&cooked, rawBytes)\n\t\t}\n\t}\n\n\t// render the actual list item\n\tcookedBytes := cooked.Bytes()\n\tparsedEnd := len(cookedBytes)\n\n\t// strip trailing newlines\n\tfor parsedEnd > 0 && cookedBytes[parsedEnd-1] == '\\n' {\n\t\tparsedEnd--\n\t}\n\tp.r.ListItem(out, cookedBytes[:parsedEnd], *flags)\n\n\treturn line\n}\n\n// render a single paragraph that has already been parsed out\nfunc (p *parser) renderParagraph(out *bytes.Buffer, data []byte) {\n\tif len(data) == 0 {\n\t\treturn\n\t}\n\n\t// trim leading spaces\n\tbeg := 0\n\tfor data[beg] == ' ' {\n\t\tbeg++\n\t}\n\n\t// trim trailing newline\n\tend := len(data) - 1\n\n\t// trim trailing spaces\n\tfor end > beg && data[end-1] == ' ' {\n\t\tend--\n\t}\n\n\twork := func() bool {\n\t\tp.inline(out, data[beg:end])\n\t\treturn true\n\t}\n\tp.r.Paragraph(out, work)\n}\n\nfunc (p *parser) paragraph(out *bytes.Buffer, data []byte) int {\n\t// prev: index of 1st char of previous line\n\t// line: index of 1st char of current line\n\t// i: index of cursor/end of current line\n\tvar prev, line, i int\n\n\t// keep going until we find something to mark the end of the paragraph\n\tfor i < len(data) {\n\t\t// mark the beginning of the current line\n\t\tprev = line\n\t\tcurrent := data[i:]\n\t\tline = i\n\n\t\t// did we find a blank line marking the end of the paragraph?\n\t\tif n := p.isEmpty(current); n > 0 {\n\t\t\t// did this blank line followed by a definition list item?\n\t\t\tif p.flags&EXTENSION_DEFINITION_LISTS != 0 {\n\t\t\t\tif i < len(data)-1 && data[i+1] == ':' {\n\t\t\t\t\treturn p.list(out, data[prev:], LIST_TYPE_DEFINITION)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp.renderParagraph(out, data[:i])\n\t\t\treturn i + n\n\t\t}\n\n\t\t// an underline under some text marks a header, so our paragraph ended on prev line\n\t\tif i > 0 {\n\t\t\tif level := p.isUnderlinedHeader(current); level > 0 {\n\t\t\t\t// render the paragraph\n\t\t\t\tp.renderParagraph(out, data[:prev])\n\n\t\t\t\t// ignore leading and trailing whitespace\n\t\t\t\teol := i - 1\n\t\t\t\tfor prev < eol && data[prev] == ' ' {\n\t\t\t\t\tprev++\n\t\t\t\t}\n\t\t\t\tfor eol > prev && data[eol-1] == ' ' {\n\t\t\t\t\teol--\n\t\t\t\t}\n\n\t\t\t\t// render the header\n\t\t\t\t// this ugly double closure avoids forcing variables onto the heap\n\t\t\t\twork := func(o *bytes.Buffer, pp *parser, d []byte) func() bool {\n\t\t\t\t\treturn func() bool {\n\t\t\t\t\t\tpp.inline(o, d)\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}(out, p, data[prev:eol])\n\n\t\t\t\tid := \"\"\n\t\t\t\tif p.flags&EXTENSION_AUTO_HEADER_IDS != 0 {\n\t\t\t\t\tid = SanitizedAnchorName(string(data[prev:eol]))\n\t\t\t\t}\n\n\t\t\t\tp.r.Header(out, work, level, id)\n\n\t\t\t\t// find the end of the underline\n\t\t\t\tfor data[i] != '\\n' {\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\n\t\t// if the next line starts a block of HTML, then the paragraph ends here\n\t\tif p.flags&EXTENSION_LAX_HTML_BLOCKS != 0 {\n\t\t\tif data[i] == '<' && p.html(out, current, false) > 0 {\n\t\t\t\t// rewind to before the HTML block\n\t\t\t\tp.renderParagraph(out, data[:i])\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\n\t\t// if there's a prefixed header or a horizontal rule after this, paragraph is over\n\t\tif p.isPrefixHeader(current) || p.isHRule(current) {\n\t\t\tp.renderParagraph(out, data[:i])\n\t\t\treturn i\n\t\t}\n\n\t\t// if there's a fenced code block, paragraph is over\n\t\tif p.flags&EXTENSION_FENCED_CODE != 0 {\n\t\t\tif p.fencedCodeBlock(out, current, false) > 0 {\n\t\t\t\tp.renderParagraph(out, data[:i])\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\n\t\t// if there's a definition list item, prev line is a definition term\n\t\tif p.flags&EXTENSION_DEFINITION_LISTS != 0 {\n\t\t\tif p.dliPrefix(current) != 0 {\n\t\t\t\treturn p.list(out, data[prev:], LIST_TYPE_DEFINITION)\n\t\t\t}\n\t\t}\n\n\t\t// if there's a list after this, paragraph is over\n\t\tif p.flags&EXTENSION_NO_EMPTY_LINE_BEFORE_BLOCK != 0 {\n\t\t\tif p.uliPrefix(current) != 0 ||\n\t\t\t\tp.oliPrefix(current) != 0 ||\n\t\t\t\tp.quotePrefix(current) != 0 ||\n\t\t\t\tp.codePrefix(current) != 0 {\n\t\t\t\tp.renderParagraph(out, data[:i])\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\n\t\t// otherwise, scan to the beginning of the next line\n\t\tfor data[i] != '\\n' {\n\t\t\ti++\n\t\t}\n\t\ti++\n\t}\n\n\tp.renderParagraph(out, data[:i])\n\treturn i\n}\n\n// SanitizedAnchorName returns a sanitized anchor name for the given text.\n//\n// It implements the algorithm specified in the package comment.\nfunc SanitizedAnchorName(text string) string {\n\tvar anchorName []rune\n\tfutureDash := false\n\tfor _, r := range text {\n\t\tswitch {\n\t\tcase unicode.IsLetter(r) || unicode.IsNumber(r):\n\t\t\tif futureDash && len(anchorName) > 0 {\n\t\t\t\tanchorName = append(anchorName, '-')\n\t\t\t}\n\t\t\tfutureDash = false\n\t\t\tanchorName = append(anchorName, unicode.ToLower(r))\n\t\tdefault:\n\t\t\tfutureDash = true\n\t\t}\n\t}\n\treturn string(anchorName)\n}\n"
        },
        {
          "name": "block_test.go",
          "type": "blob",
          "size": 51.8271484375,
          "content": "//\n// Blackfriday Markdown Processor\n// Available at http://github.com/russross/blackfriday\n//\n// Copyright © 2011 Russ Ross <russ@russross.com>.\n// Distributed under the Simplified BSD License.\n// See README.md for details.\n//\n\n//\n// Unit tests for block parsing\n//\n\npackage blackfriday\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc runMarkdownBlockWithRenderer(input string, extensions int, renderer Renderer) string {\n\treturn string(Markdown([]byte(input), renderer, extensions))\n}\n\nfunc runMarkdownBlock(input string, extensions int) string {\n\thtmlFlags := 0\n\thtmlFlags |= HTML_USE_XHTML\n\n\trenderer := HtmlRenderer(htmlFlags, \"\", \"\")\n\n\treturn runMarkdownBlockWithRenderer(input, extensions, renderer)\n}\n\nfunc runnerWithRendererParameters(parameters HtmlRendererParameters) func(string, int) string {\n\treturn func(input string, extensions int) string {\n\t\thtmlFlags := 0\n\t\thtmlFlags |= HTML_USE_XHTML\n\n\t\trenderer := HtmlRendererWithParameters(htmlFlags, \"\", \"\", parameters)\n\n\t\treturn runMarkdownBlockWithRenderer(input, extensions, renderer)\n\t}\n}\n\nfunc doTestsBlock(t *testing.T, tests []string, extensions int) {\n\tdoTestsBlockWithRunner(t, tests, extensions, runMarkdownBlock)\n}\n\nfunc doTestsBlockWithRunner(t *testing.T, tests []string, extensions int, runner func(string, int) string) {\n\t// catch and report panics\n\tvar candidate string\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tt.Errorf(\"\\npanic while processing [%#v]: %s\\n\", candidate, err)\n\t\t}\n\t}()\n\n\tfor i := 0; i+1 < len(tests); i += 2 {\n\t\tinput := tests[i]\n\t\tcandidate = input\n\t\texpected := tests[i+1]\n\t\tactual := runner(candidate, extensions)\n\t\tif actual != expected {\n\t\t\tt.Errorf(\"\\nInput   [%#v]\\nExpected[%#v]\\nActual  [%#v]\",\n\t\t\t\tcandidate, expected, actual)\n\t\t}\n\n\t\t// now test every substring to stress test bounds checking\n\t\tif !testing.Short() {\n\t\t\tfor start := 0; start < len(input); start++ {\n\t\t\t\tfor end := start + 1; end <= len(input); end++ {\n\t\t\t\t\tcandidate = input[start:end]\n\t\t\t\t\t_ = runMarkdownBlock(candidate, extensions)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestPrefixHeaderNoExtensions(t *testing.T) {\n\tvar tests = []string{\n\t\t\"# Header 1\\n\",\n\t\t\"<h1>Header 1</h1>\\n\",\n\n\t\t\"## Header 2\\n\",\n\t\t\"<h2>Header 2</h2>\\n\",\n\n\t\t\"### Header 3\\n\",\n\t\t\"<h3>Header 3</h3>\\n\",\n\n\t\t\"#### Header 4\\n\",\n\t\t\"<h4>Header 4</h4>\\n\",\n\n\t\t\"##### Header 5\\n\",\n\t\t\"<h5>Header 5</h5>\\n\",\n\n\t\t\"###### Header 6\\n\",\n\t\t\"<h6>Header 6</h6>\\n\",\n\n\t\t\"####### Header 7\\n\",\n\t\t\"<h6># Header 7</h6>\\n\",\n\n\t\t\"#Header 1\\n\",\n\t\t\"<h1>Header 1</h1>\\n\",\n\n\t\t\"##Header 2\\n\",\n\t\t\"<h2>Header 2</h2>\\n\",\n\n\t\t\"###Header 3\\n\",\n\t\t\"<h3>Header 3</h3>\\n\",\n\n\t\t\"####Header 4\\n\",\n\t\t\"<h4>Header 4</h4>\\n\",\n\n\t\t\"#####Header 5\\n\",\n\t\t\"<h5>Header 5</h5>\\n\",\n\n\t\t\"######Header 6\\n\",\n\t\t\"<h6>Header 6</h6>\\n\",\n\n\t\t\"#######Header 7\\n\",\n\t\t\"<h6>#Header 7</h6>\\n\",\n\n\t\t\"Hello\\n# Header 1\\nGoodbye\\n\",\n\t\t\"<p>Hello</p>\\n\\n<h1>Header 1</h1>\\n\\n<p>Goodbye</p>\\n\",\n\n\t\t\"* List\\n# Header\\n* List\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<h1>Header</h1></li>\\n\\n<li><p>List</p></li>\\n</ul>\\n\",\n\n\t\t\"* List\\n#Header\\n* List\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<h1>Header</h1></li>\\n\\n<li><p>List</p></li>\\n</ul>\\n\",\n\n\t\t\"*   List\\n    * Nested list\\n    # Nested header\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<ul>\\n<li><p>Nested list</p>\\n\\n\" +\n\t\t\t\"<h1>Nested header</h1></li>\\n</ul></li>\\n</ul>\\n\",\n\n\t\t\"#Header 1 \\\\#\\n\",\n\t\t\"<h1>Header 1 #</h1>\\n\",\n\n\t\t\"#Header 1 \\\\# foo\\n\",\n\t\t\"<h1>Header 1 # foo</h1>\\n\",\n\n\t\t\"#Header 1 #\\\\##\\n\",\n\t\t\"<h1>Header 1 ##</h1>\\n\",\n\t}\n\tdoTestsBlock(t, tests, 0)\n}\n\nfunc TestPrefixHeaderSpaceExtension(t *testing.T) {\n\tvar tests = []string{\n\t\t\"# Header 1\\n\",\n\t\t\"<h1>Header 1</h1>\\n\",\n\n\t\t\"## Header 2\\n\",\n\t\t\"<h2>Header 2</h2>\\n\",\n\n\t\t\"### Header 3\\n\",\n\t\t\"<h3>Header 3</h3>\\n\",\n\n\t\t\"#### Header 4\\n\",\n\t\t\"<h4>Header 4</h4>\\n\",\n\n\t\t\"##### Header 5\\n\",\n\t\t\"<h5>Header 5</h5>\\n\",\n\n\t\t\"###### Header 6\\n\",\n\t\t\"<h6>Header 6</h6>\\n\",\n\n\t\t\"####### Header 7\\n\",\n\t\t\"<p>####### Header 7</p>\\n\",\n\n\t\t\"#Header 1\\n\",\n\t\t\"<p>#Header 1</p>\\n\",\n\n\t\t\"##Header 2\\n\",\n\t\t\"<p>##Header 2</p>\\n\",\n\n\t\t\"###Header 3\\n\",\n\t\t\"<p>###Header 3</p>\\n\",\n\n\t\t\"####Header 4\\n\",\n\t\t\"<p>####Header 4</p>\\n\",\n\n\t\t\"#####Header 5\\n\",\n\t\t\"<p>#####Header 5</p>\\n\",\n\n\t\t\"######Header 6\\n\",\n\t\t\"<p>######Header 6</p>\\n\",\n\n\t\t\"#######Header 7\\n\",\n\t\t\"<p>#######Header 7</p>\\n\",\n\n\t\t\"Hello\\n# Header 1\\nGoodbye\\n\",\n\t\t\"<p>Hello</p>\\n\\n<h1>Header 1</h1>\\n\\n<p>Goodbye</p>\\n\",\n\n\t\t\"* List\\n# Header\\n* List\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<h1>Header</h1></li>\\n\\n<li><p>List</p></li>\\n</ul>\\n\",\n\n\t\t\"* List\\n#Header\\n* List\\n\",\n\t\t\"<ul>\\n<li>List\\n#Header</li>\\n<li>List</li>\\n</ul>\\n\",\n\n\t\t\"*   List\\n    * Nested list\\n    # Nested header\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<ul>\\n<li><p>Nested list</p>\\n\\n\" +\n\t\t\t\"<h1>Nested header</h1></li>\\n</ul></li>\\n</ul>\\n\",\n\t}\n\tdoTestsBlock(t, tests, EXTENSION_SPACE_HEADERS)\n}\n\nfunc TestPrefixHeaderIdExtension(t *testing.T) {\n\tvar tests = []string{\n\t\t\"# Header 1 {#someid}\\n\",\n\t\t\"<h1 id=\\\"someid\\\">Header 1</h1>\\n\",\n\n\t\t\"# Header 1 {#someid}   \\n\",\n\t\t\"<h1 id=\\\"someid\\\">Header 1</h1>\\n\",\n\n\t\t\"# Header 1         {#someid}\\n\",\n\t\t\"<h1 id=\\\"someid\\\">Header 1</h1>\\n\",\n\n\t\t\"# Header 1 {#someid\\n\",\n\t\t\"<h1>Header 1 {#someid</h1>\\n\",\n\n\t\t\"# Header 1 {#someid\\n\",\n\t\t\"<h1>Header 1 {#someid</h1>\\n\",\n\n\t\t\"# Header 1 {#someid}}\\n\",\n\t\t\"<h1 id=\\\"someid\\\">Header 1</h1>\\n\\n<p>}</p>\\n\",\n\n\t\t\"## Header 2 {#someid}\\n\",\n\t\t\"<h2 id=\\\"someid\\\">Header 2</h2>\\n\",\n\n\t\t\"### Header 3 {#someid}\\n\",\n\t\t\"<h3 id=\\\"someid\\\">Header 3</h3>\\n\",\n\n\t\t\"#### Header 4 {#someid}\\n\",\n\t\t\"<h4 id=\\\"someid\\\">Header 4</h4>\\n\",\n\n\t\t\"##### Header 5 {#someid}\\n\",\n\t\t\"<h5 id=\\\"someid\\\">Header 5</h5>\\n\",\n\n\t\t\"###### Header 6 {#someid}\\n\",\n\t\t\"<h6 id=\\\"someid\\\">Header 6</h6>\\n\",\n\n\t\t\"####### Header 7 {#someid}\\n\",\n\t\t\"<h6 id=\\\"someid\\\"># Header 7</h6>\\n\",\n\n\t\t\"# Header 1 # {#someid}\\n\",\n\t\t\"<h1 id=\\\"someid\\\">Header 1</h1>\\n\",\n\n\t\t\"## Header 2 ## {#someid}\\n\",\n\t\t\"<h2 id=\\\"someid\\\">Header 2</h2>\\n\",\n\n\t\t\"Hello\\n# Header 1\\nGoodbye\\n\",\n\t\t\"<p>Hello</p>\\n\\n<h1>Header 1</h1>\\n\\n<p>Goodbye</p>\\n\",\n\n\t\t\"* List\\n# Header {#someid}\\n* List\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<h1 id=\\\"someid\\\">Header</h1></li>\\n\\n<li><p>List</p></li>\\n</ul>\\n\",\n\n\t\t\"* List\\n#Header {#someid}\\n* List\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<h1 id=\\\"someid\\\">Header</h1></li>\\n\\n<li><p>List</p></li>\\n</ul>\\n\",\n\n\t\t\"*   List\\n    * Nested list\\n    # Nested header {#someid}\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<ul>\\n<li><p>Nested list</p>\\n\\n\" +\n\t\t\t\"<h1 id=\\\"someid\\\">Nested header</h1></li>\\n</ul></li>\\n</ul>\\n\",\n\t}\n\tdoTestsBlock(t, tests, EXTENSION_HEADER_IDS)\n}\n\nfunc TestPrefixHeaderIdExtensionWithPrefixAndSuffix(t *testing.T) {\n\tvar tests = []string{\n\t\t\"# header 1 {#someid}\\n\",\n\t\t\"<h1 id=\\\"PRE:someid:POST\\\">header 1</h1>\\n\",\n\n\t\t\"## header 2 {#someid}\\n\",\n\t\t\"<h2 id=\\\"PRE:someid:POST\\\">header 2</h2>\\n\",\n\n\t\t\"### header 3 {#someid}\\n\",\n\t\t\"<h3 id=\\\"PRE:someid:POST\\\">header 3</h3>\\n\",\n\n\t\t\"#### header 4 {#someid}\\n\",\n\t\t\"<h4 id=\\\"PRE:someid:POST\\\">header 4</h4>\\n\",\n\n\t\t\"##### header 5 {#someid}\\n\",\n\t\t\"<h5 id=\\\"PRE:someid:POST\\\">header 5</h5>\\n\",\n\n\t\t\"###### header 6 {#someid}\\n\",\n\t\t\"<h6 id=\\\"PRE:someid:POST\\\">header 6</h6>\\n\",\n\n\t\t\"####### header 7 {#someid}\\n\",\n\t\t\"<h6 id=\\\"PRE:someid:POST\\\"># header 7</h6>\\n\",\n\n\t\t\"# header 1 # {#someid}\\n\",\n\t\t\"<h1 id=\\\"PRE:someid:POST\\\">header 1</h1>\\n\",\n\n\t\t\"## header 2 ## {#someid}\\n\",\n\t\t\"<h2 id=\\\"PRE:someid:POST\\\">header 2</h2>\\n\",\n\n\t\t\"* List\\n# Header {#someid}\\n* List\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<h1 id=\\\"PRE:someid:POST\\\">Header</h1></li>\\n\\n<li><p>List</p></li>\\n</ul>\\n\",\n\n\t\t\"* List\\n#Header {#someid}\\n* List\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<h1 id=\\\"PRE:someid:POST\\\">Header</h1></li>\\n\\n<li><p>List</p></li>\\n</ul>\\n\",\n\n\t\t\"*   List\\n    * Nested list\\n    # Nested header {#someid}\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<ul>\\n<li><p>Nested list</p>\\n\\n\" +\n\t\t\t\"<h1 id=\\\"PRE:someid:POST\\\">Nested header</h1></li>\\n</ul></li>\\n</ul>\\n\",\n\t}\n\n\tparameters := HtmlRendererParameters{\n\t\tHeaderIDPrefix: \"PRE:\",\n\t\tHeaderIDSuffix: \":POST\",\n\t}\n\n\tdoTestsBlockWithRunner(t, tests, EXTENSION_HEADER_IDS, runnerWithRendererParameters(parameters))\n}\n\nfunc TestPrefixAutoHeaderIdExtension(t *testing.T) {\n\tvar tests = []string{\n\t\t\"# Header 1\\n\",\n\t\t\"<h1 id=\\\"header-1\\\">Header 1</h1>\\n\",\n\n\t\t\"# Header 1   \\n\",\n\t\t\"<h1 id=\\\"header-1\\\">Header 1</h1>\\n\",\n\n\t\t\"## Header 2\\n\",\n\t\t\"<h2 id=\\\"header-2\\\">Header 2</h2>\\n\",\n\n\t\t\"### Header 3\\n\",\n\t\t\"<h3 id=\\\"header-3\\\">Header 3</h3>\\n\",\n\n\t\t\"#### Header 4\\n\",\n\t\t\"<h4 id=\\\"header-4\\\">Header 4</h4>\\n\",\n\n\t\t\"##### Header 5\\n\",\n\t\t\"<h5 id=\\\"header-5\\\">Header 5</h5>\\n\",\n\n\t\t\"###### Header 6\\n\",\n\t\t\"<h6 id=\\\"header-6\\\">Header 6</h6>\\n\",\n\n\t\t\"####### Header 7\\n\",\n\t\t\"<h6 id=\\\"header-7\\\"># Header 7</h6>\\n\",\n\n\t\t\"Hello\\n# Header 1\\nGoodbye\\n\",\n\t\t\"<p>Hello</p>\\n\\n<h1 id=\\\"header-1\\\">Header 1</h1>\\n\\n<p>Goodbye</p>\\n\",\n\n\t\t\"* List\\n# Header\\n* List\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<h1 id=\\\"header\\\">Header</h1></li>\\n\\n<li><p>List</p></li>\\n</ul>\\n\",\n\n\t\t\"* List\\n#Header\\n* List\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<h1 id=\\\"header\\\">Header</h1></li>\\n\\n<li><p>List</p></li>\\n</ul>\\n\",\n\n\t\t\"*   List\\n    * Nested list\\n    # Nested header\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<ul>\\n<li><p>Nested list</p>\\n\\n\" +\n\t\t\t\"<h1 id=\\\"nested-header\\\">Nested header</h1></li>\\n</ul></li>\\n</ul>\\n\",\n\n\t\t\"# Header\\n\\n# Header\\n\",\n\t\t\"<h1 id=\\\"header\\\">Header</h1>\\n\\n<h1 id=\\\"header-1\\\">Header</h1>\\n\",\n\n\t\t\"# Header 1\\n\\n# Header 1\",\n\t\t\"<h1 id=\\\"header-1\\\">Header 1</h1>\\n\\n<h1 id=\\\"header-1-1\\\">Header 1</h1>\\n\",\n\n\t\t\"# Header\\n\\n# Header 1\\n\\n# Header\\n\\n# Header\",\n\t\t\"<h1 id=\\\"header\\\">Header</h1>\\n\\n<h1 id=\\\"header-1\\\">Header 1</h1>\\n\\n<h1 id=\\\"header-1-1\\\">Header</h1>\\n\\n<h1 id=\\\"header-1-2\\\">Header</h1>\\n\",\n\t}\n\tdoTestsBlock(t, tests, EXTENSION_AUTO_HEADER_IDS)\n}\n\nfunc TestPrefixAutoHeaderIdExtensionWithPrefixAndSuffix(t *testing.T) {\n\tvar tests = []string{\n\t\t\"# Header 1\\n\",\n\t\t\"<h1 id=\\\"PRE:header-1:POST\\\">Header 1</h1>\\n\",\n\n\t\t\"# Header 1   \\n\",\n\t\t\"<h1 id=\\\"PRE:header-1:POST\\\">Header 1</h1>\\n\",\n\n\t\t\"## Header 2\\n\",\n\t\t\"<h2 id=\\\"PRE:header-2:POST\\\">Header 2</h2>\\n\",\n\n\t\t\"### Header 3\\n\",\n\t\t\"<h3 id=\\\"PRE:header-3:POST\\\">Header 3</h3>\\n\",\n\n\t\t\"#### Header 4\\n\",\n\t\t\"<h4 id=\\\"PRE:header-4:POST\\\">Header 4</h4>\\n\",\n\n\t\t\"##### Header 5\\n\",\n\t\t\"<h5 id=\\\"PRE:header-5:POST\\\">Header 5</h5>\\n\",\n\n\t\t\"###### Header 6\\n\",\n\t\t\"<h6 id=\\\"PRE:header-6:POST\\\">Header 6</h6>\\n\",\n\n\t\t\"####### Header 7\\n\",\n\t\t\"<h6 id=\\\"PRE:header-7:POST\\\"># Header 7</h6>\\n\",\n\n\t\t\"Hello\\n# Header 1\\nGoodbye\\n\",\n\t\t\"<p>Hello</p>\\n\\n<h1 id=\\\"PRE:header-1:POST\\\">Header 1</h1>\\n\\n<p>Goodbye</p>\\n\",\n\n\t\t\"* List\\n# Header\\n* List\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<h1 id=\\\"PRE:header:POST\\\">Header</h1></li>\\n\\n<li><p>List</p></li>\\n</ul>\\n\",\n\n\t\t\"* List\\n#Header\\n* List\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<h1 id=\\\"PRE:header:POST\\\">Header</h1></li>\\n\\n<li><p>List</p></li>\\n</ul>\\n\",\n\n\t\t\"*   List\\n    * Nested list\\n    # Nested header\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<ul>\\n<li><p>Nested list</p>\\n\\n\" +\n\t\t\t\"<h1 id=\\\"PRE:nested-header:POST\\\">Nested header</h1></li>\\n</ul></li>\\n</ul>\\n\",\n\n\t\t\"# Header\\n\\n# Header\\n\",\n\t\t\"<h1 id=\\\"PRE:header:POST\\\">Header</h1>\\n\\n<h1 id=\\\"PRE:header-1:POST\\\">Header</h1>\\n\",\n\n\t\t\"# Header 1\\n\\n# Header 1\",\n\t\t\"<h1 id=\\\"PRE:header-1:POST\\\">Header 1</h1>\\n\\n<h1 id=\\\"PRE:header-1-1:POST\\\">Header 1</h1>\\n\",\n\n\t\t\"# Header\\n\\n# Header 1\\n\\n# Header\\n\\n# Header\",\n\t\t\"<h1 id=\\\"PRE:header:POST\\\">Header</h1>\\n\\n<h1 id=\\\"PRE:header-1:POST\\\">Header 1</h1>\\n\\n<h1 id=\\\"PRE:header-1-1:POST\\\">Header</h1>\\n\\n<h1 id=\\\"PRE:header-1-2:POST\\\">Header</h1>\\n\",\n\t}\n\n\tparameters := HtmlRendererParameters{\n\t\tHeaderIDPrefix: \"PRE:\",\n\t\tHeaderIDSuffix: \":POST\",\n\t}\n\n\tdoTestsBlockWithRunner(t, tests, EXTENSION_AUTO_HEADER_IDS, runnerWithRendererParameters(parameters))\n}\n\nfunc TestPrefixMultipleHeaderExtensions(t *testing.T) {\n\tvar tests = []string{\n\t\t\"# Header\\n\\n# Header {#header}\\n\\n# Header 1\",\n\t\t\"<h1 id=\\\"header\\\">Header</h1>\\n\\n<h1 id=\\\"header-1\\\">Header</h1>\\n\\n<h1 id=\\\"header-1-1\\\">Header 1</h1>\\n\",\n\t}\n\tdoTestsBlock(t, tests, EXTENSION_AUTO_HEADER_IDS|EXTENSION_HEADER_IDS)\n}\n\nfunc TestUnderlineHeaders(t *testing.T) {\n\tvar tests = []string{\n\t\t\"Header 1\\n========\\n\",\n\t\t\"<h1>Header 1</h1>\\n\",\n\n\t\t\"Header 2\\n--------\\n\",\n\t\t\"<h2>Header 2</h2>\\n\",\n\n\t\t\"A\\n=\\n\",\n\t\t\"<h1>A</h1>\\n\",\n\n\t\t\"B\\n-\\n\",\n\t\t\"<h2>B</h2>\\n\",\n\n\t\t\"Paragraph\\nHeader\\n=\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<h1>Header</h1>\\n\",\n\n\t\t\"Header\\n===\\nParagraph\\n\",\n\t\t\"<h1>Header</h1>\\n\\n<p>Paragraph</p>\\n\",\n\n\t\t\"Header\\n===\\nAnother header\\n---\\n\",\n\t\t\"<h1>Header</h1>\\n\\n<h2>Another header</h2>\\n\",\n\n\t\t\"   Header\\n======\\n\",\n\t\t\"<h1>Header</h1>\\n\",\n\n\t\t\"    Code\\n========\\n\",\n\t\t\"<pre><code>Code\\n</code></pre>\\n\\n<p>========</p>\\n\",\n\n\t\t\"Header with *inline*\\n=====\\n\",\n\t\t\"<h1>Header with <em>inline</em></h1>\\n\",\n\n\t\t\"*   List\\n    * Sublist\\n    Not a header\\n    ------\\n\",\n\t\t\"<ul>\\n<li>List\\n\\n<ul>\\n<li>Sublist\\nNot a header\\n------</li>\\n</ul></li>\\n</ul>\\n\",\n\n\t\t\"Paragraph\\n\\n\\n\\n\\nHeader\\n===\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<h1>Header</h1>\\n\",\n\n\t\t\"Trailing space \\n====        \\n\\n\",\n\t\t\"<h1>Trailing space</h1>\\n\",\n\n\t\t\"Trailing spaces\\n====        \\n\\n\",\n\t\t\"<h1>Trailing spaces</h1>\\n\",\n\n\t\t\"Double underline\\n=====\\n=====\\n\",\n\t\t\"<h1>Double underline</h1>\\n\\n<p>=====</p>\\n\",\n\t}\n\tdoTestsBlock(t, tests, 0)\n}\n\nfunc TestUnderlineHeadersAutoIDs(t *testing.T) {\n\tvar tests = []string{\n\t\t\"Header 1\\n========\\n\",\n\t\t\"<h1 id=\\\"header-1\\\">Header 1</h1>\\n\",\n\n\t\t\"Header 2\\n--------\\n\",\n\t\t\"<h2 id=\\\"header-2\\\">Header 2</h2>\\n\",\n\n\t\t\"A\\n=\\n\",\n\t\t\"<h1 id=\\\"a\\\">A</h1>\\n\",\n\n\t\t\"B\\n-\\n\",\n\t\t\"<h2 id=\\\"b\\\">B</h2>\\n\",\n\n\t\t\"Paragraph\\nHeader\\n=\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<h1 id=\\\"header\\\">Header</h1>\\n\",\n\n\t\t\"Header\\n===\\nParagraph\\n\",\n\t\t\"<h1 id=\\\"header\\\">Header</h1>\\n\\n<p>Paragraph</p>\\n\",\n\n\t\t\"Header\\n===\\nAnother header\\n---\\n\",\n\t\t\"<h1 id=\\\"header\\\">Header</h1>\\n\\n<h2 id=\\\"another-header\\\">Another header</h2>\\n\",\n\n\t\t\"   Header\\n======\\n\",\n\t\t\"<h1 id=\\\"header\\\">Header</h1>\\n\",\n\n\t\t\"Header with *inline*\\n=====\\n\",\n\t\t\"<h1 id=\\\"header-with-inline\\\">Header with <em>inline</em></h1>\\n\",\n\n\t\t\"Paragraph\\n\\n\\n\\n\\nHeader\\n===\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<h1 id=\\\"header\\\">Header</h1>\\n\",\n\n\t\t\"Trailing space \\n====        \\n\\n\",\n\t\t\"<h1 id=\\\"trailing-space\\\">Trailing space</h1>\\n\",\n\n\t\t\"Trailing spaces\\n====        \\n\\n\",\n\t\t\"<h1 id=\\\"trailing-spaces\\\">Trailing spaces</h1>\\n\",\n\n\t\t\"Double underline\\n=====\\n=====\\n\",\n\t\t\"<h1 id=\\\"double-underline\\\">Double underline</h1>\\n\\n<p>=====</p>\\n\",\n\n\t\t\"Header\\n======\\n\\nHeader\\n======\\n\",\n\t\t\"<h1 id=\\\"header\\\">Header</h1>\\n\\n<h1 id=\\\"header-1\\\">Header</h1>\\n\",\n\n\t\t\"Header 1\\n========\\n\\nHeader 1\\n========\\n\",\n\t\t\"<h1 id=\\\"header-1\\\">Header 1</h1>\\n\\n<h1 id=\\\"header-1-1\\\">Header 1</h1>\\n\",\n\t}\n\tdoTestsBlock(t, tests, EXTENSION_AUTO_HEADER_IDS)\n}\n\nfunc TestHorizontalRule(t *testing.T) {\n\tvar tests = []string{\n\t\t\"-\\n\",\n\t\t\"<p>-</p>\\n\",\n\n\t\t\"--\\n\",\n\t\t\"<p>--</p>\\n\",\n\n\t\t\"---\\n\",\n\t\t\"<hr />\\n\",\n\n\t\t\"----\\n\",\n\t\t\"<hr />\\n\",\n\n\t\t\"*\\n\",\n\t\t\"<p>*</p>\\n\",\n\n\t\t\"**\\n\",\n\t\t\"<p>**</p>\\n\",\n\n\t\t\"***\\n\",\n\t\t\"<hr />\\n\",\n\n\t\t\"****\\n\",\n\t\t\"<hr />\\n\",\n\n\t\t\"_\\n\",\n\t\t\"<p>_</p>\\n\",\n\n\t\t\"__\\n\",\n\t\t\"<p>__</p>\\n\",\n\n\t\t\"___\\n\",\n\t\t\"<hr />\\n\",\n\n\t\t\"____\\n\",\n\t\t\"<hr />\\n\",\n\n\t\t\"-*-\\n\",\n\t\t\"<p>-*-</p>\\n\",\n\n\t\t\"- - -\\n\",\n\t\t\"<hr />\\n\",\n\n\t\t\"* * *\\n\",\n\t\t\"<hr />\\n\",\n\n\t\t\"_ _ _\\n\",\n\t\t\"<hr />\\n\",\n\n\t\t\"-----*\\n\",\n\t\t\"<p>-----*</p>\\n\",\n\n\t\t\"   ------   \\n\",\n\t\t\"<hr />\\n\",\n\n\t\t\"Hello\\n***\\n\",\n\t\t\"<p>Hello</p>\\n\\n<hr />\\n\",\n\n\t\t\"---\\n***\\n___\\n\",\n\t\t\"<hr />\\n\\n<hr />\\n\\n<hr />\\n\",\n\t}\n\tdoTestsBlock(t, tests, 0)\n}\n\nfunc TestUnorderedList(t *testing.T) {\n\tvar tests = []string{\n\t\t\"* Hello\\n\",\n\t\t\"<ul>\\n<li>Hello</li>\\n</ul>\\n\",\n\n\t\t\"* Yin\\n* Yang\\n\",\n\t\t\"<ul>\\n<li>Yin</li>\\n<li>Yang</li>\\n</ul>\\n\",\n\n\t\t\"* Ting\\n* Bong\\n* Goo\\n\",\n\t\t\"<ul>\\n<li>Ting</li>\\n<li>Bong</li>\\n<li>Goo</li>\\n</ul>\\n\",\n\n\t\t\"* Yin\\n\\n* Yang\\n\",\n\t\t\"<ul>\\n<li><p>Yin</p></li>\\n\\n<li><p>Yang</p></li>\\n</ul>\\n\",\n\n\t\t\"* Ting\\n\\n* Bong\\n* Goo\\n\",\n\t\t\"<ul>\\n<li><p>Ting</p></li>\\n\\n<li><p>Bong</p></li>\\n\\n<li><p>Goo</p></li>\\n</ul>\\n\",\n\n\t\t\"+ Hello\\n\",\n\t\t\"<ul>\\n<li>Hello</li>\\n</ul>\\n\",\n\n\t\t\"+ Yin\\n+ Yang\\n\",\n\t\t\"<ul>\\n<li>Yin</li>\\n<li>Yang</li>\\n</ul>\\n\",\n\n\t\t\"+ Ting\\n+ Bong\\n+ Goo\\n\",\n\t\t\"<ul>\\n<li>Ting</li>\\n<li>Bong</li>\\n<li>Goo</li>\\n</ul>\\n\",\n\n\t\t\"+ Yin\\n\\n+ Yang\\n\",\n\t\t\"<ul>\\n<li><p>Yin</p></li>\\n\\n<li><p>Yang</p></li>\\n</ul>\\n\",\n\n\t\t\"+ Ting\\n\\n+ Bong\\n+ Goo\\n\",\n\t\t\"<ul>\\n<li><p>Ting</p></li>\\n\\n<li><p>Bong</p></li>\\n\\n<li><p>Goo</p></li>\\n</ul>\\n\",\n\n\t\t\"- Hello\\n\",\n\t\t\"<ul>\\n<li>Hello</li>\\n</ul>\\n\",\n\n\t\t\"- Yin\\n- Yang\\n\",\n\t\t\"<ul>\\n<li>Yin</li>\\n<li>Yang</li>\\n</ul>\\n\",\n\n\t\t\"- Ting\\n- Bong\\n- Goo\\n\",\n\t\t\"<ul>\\n<li>Ting</li>\\n<li>Bong</li>\\n<li>Goo</li>\\n</ul>\\n\",\n\n\t\t\"- Yin\\n\\n- Yang\\n\",\n\t\t\"<ul>\\n<li><p>Yin</p></li>\\n\\n<li><p>Yang</p></li>\\n</ul>\\n\",\n\n\t\t\"- Ting\\n\\n- Bong\\n- Goo\\n\",\n\t\t\"<ul>\\n<li><p>Ting</p></li>\\n\\n<li><p>Bong</p></li>\\n\\n<li><p>Goo</p></li>\\n</ul>\\n\",\n\n\t\t\"*Hello\\n\",\n\t\t\"<p>*Hello</p>\\n\",\n\n\t\t\"*   Hello \\n\",\n\t\t\"<ul>\\n<li>Hello</li>\\n</ul>\\n\",\n\n\t\t\"*   Hello \\n    Next line \\n\",\n\t\t\"<ul>\\n<li>Hello\\nNext line</li>\\n</ul>\\n\",\n\n\t\t\"Paragraph\\n* No linebreak\\n\",\n\t\t\"<p>Paragraph\\n* No linebreak</p>\\n\",\n\n\t\t\"Paragraph\\n\\n* Linebreak\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<ul>\\n<li>Linebreak</li>\\n</ul>\\n\",\n\n\t\t\"*   List\\n\\n1. Spacer Mixed listing\\n\",\n\t\t\"<ul>\\n<li>List</li>\\n</ul>\\n\\n<ol>\\n<li>Spacer Mixed listing</li>\\n</ol>\\n\",\n\n\t\t\"*   List\\n    * Nested list\\n\",\n\t\t\"<ul>\\n<li>List\\n\\n<ul>\\n<li>Nested list</li>\\n</ul></li>\\n</ul>\\n\",\n\n\t\t\"*   List\\n\\n    * Nested list\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<ul>\\n<li>Nested list</li>\\n</ul></li>\\n</ul>\\n\",\n\n\t\t\"*   List\\n    Second line\\n\\n    + Nested\\n\",\n\t\t\"<ul>\\n<li><p>List\\nSecond line</p>\\n\\n<ul>\\n<li>Nested</li>\\n</ul></li>\\n</ul>\\n\",\n\n\t\t\"*   List\\n    + Nested\\n\\n    Continued\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<ul>\\n<li>Nested</li>\\n</ul>\\n\\n<p>Continued</p></li>\\n</ul>\\n\",\n\n\t\t\"*   List\\n   * shallow indent\\n\",\n\t\t\"<ul>\\n<li>List\\n\\n<ul>\\n<li>shallow indent</li>\\n</ul></li>\\n</ul>\\n\",\n\n\t\t\"* List\\n\" +\n\t\t\t\" * shallow indent\\n\" +\n\t\t\t\"  * part of second list\\n\" +\n\t\t\t\"   * still second\\n\" +\n\t\t\t\"    * almost there\\n\" +\n\t\t\t\"     * third level\\n\",\n\t\t\"<ul>\\n\" +\n\t\t\t\"<li>List\\n\\n\" +\n\t\t\t\"<ul>\\n\" +\n\t\t\t\"<li>shallow indent</li>\\n\" +\n\t\t\t\"<li>part of second list</li>\\n\" +\n\t\t\t\"<li>still second</li>\\n\" +\n\t\t\t\"<li>almost there\\n\\n\" +\n\t\t\t\"<ul>\\n\" +\n\t\t\t\"<li>third level</li>\\n\" +\n\t\t\t\"</ul></li>\\n\" +\n\t\t\t\"</ul></li>\\n\" +\n\t\t\t\"</ul>\\n\",\n\n\t\t\"* List\\n        extra indent, same paragraph\\n\",\n\t\t\"<ul>\\n<li>List\\n    extra indent, same paragraph</li>\\n</ul>\\n\",\n\n\t\t\"* List\\n\\n        code block\\n\\n* List continues\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<pre><code>code block\\n</code></pre></li>\\n\\n<li><p>List continues</p></li>\\n</ul>\\n\",\n\n\t\t\"* List\\n\\n          code block with spaces\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<pre><code>  code block with spaces\\n</code></pre></li>\\n</ul>\\n\",\n\n\t\t\"* List\\n\\n    * sublist\\n\\n    normal text\\n\\n    * another sublist\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<ul>\\n<li>sublist</li>\\n</ul>\\n\\n<p>normal text</p>\\n\\n<ul>\\n<li>another sublist</li>\\n</ul></li>\\n</ul>\\n\",\n\n\t\t`* Foo\n\n        bar\n\n        qux\n`,\n\t\t`<ul>\n<li><p>Foo</p>\n\n<pre><code>bar\n\nqux\n</code></pre></li>\n</ul>\n`,\n\t}\n\tdoTestsBlock(t, tests, 0)\n}\n\nfunc TestFencedCodeBlockWithinList(t *testing.T) {\n\tdoTestsBlock(t, []string{\n\t\t\"* Foo\\n\\n    ```\\n    bar\\n\\n    qux\\n    ```\\n\",\n\t\t`<ul>\n<li><p>Foo</p>\n\n<pre><code>bar\n\nqux\n</code></pre></li>\n</ul>\n`,\n\t}, EXTENSION_FENCED_CODE)\n}\n\nfunc TestOrderedList(t *testing.T) {\n\tvar tests = []string{\n\t\t\"1. Hello\\n\",\n\t\t\"<ol>\\n<li>Hello</li>\\n</ol>\\n\",\n\n\t\t\"1. Yin\\n2. Yang\\n\",\n\t\t\"<ol>\\n<li>Yin</li>\\n<li>Yang</li>\\n</ol>\\n\",\n\n\t\t\"1. Ting\\n2. Bong\\n3. Goo\\n\",\n\t\t\"<ol>\\n<li>Ting</li>\\n<li>Bong</li>\\n<li>Goo</li>\\n</ol>\\n\",\n\n\t\t\"1. Yin\\n\\n2. Yang\\n\",\n\t\t\"<ol>\\n<li><p>Yin</p></li>\\n\\n<li><p>Yang</p></li>\\n</ol>\\n\",\n\n\t\t\"1. Ting\\n\\n2. Bong\\n3. Goo\\n\",\n\t\t\"<ol>\\n<li><p>Ting</p></li>\\n\\n<li><p>Bong</p></li>\\n\\n<li><p>Goo</p></li>\\n</ol>\\n\",\n\n\t\t\"1 Hello\\n\",\n\t\t\"<p>1 Hello</p>\\n\",\n\n\t\t\"1.Hello\\n\",\n\t\t\"<p>1.Hello</p>\\n\",\n\n\t\t\"1.  Hello \\n\",\n\t\t\"<ol>\\n<li>Hello</li>\\n</ol>\\n\",\n\n\t\t\"1.  Hello \\n    Next line \\n\",\n\t\t\"<ol>\\n<li>Hello\\nNext line</li>\\n</ol>\\n\",\n\n\t\t\"Paragraph\\n1. No linebreak\\n\",\n\t\t\"<p>Paragraph\\n1. No linebreak</p>\\n\",\n\n\t\t\"Paragraph\\n\\n1. Linebreak\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<ol>\\n<li>Linebreak</li>\\n</ol>\\n\",\n\n\t\t\"1.  List\\n    1. Nested list\\n\",\n\t\t\"<ol>\\n<li>List\\n\\n<ol>\\n<li>Nested list</li>\\n</ol></li>\\n</ol>\\n\",\n\n\t\t\"1.  List\\n\\n    1. Nested list\\n\",\n\t\t\"<ol>\\n<li><p>List</p>\\n\\n<ol>\\n<li>Nested list</li>\\n</ol></li>\\n</ol>\\n\",\n\n\t\t\"1.  List\\n    Second line\\n\\n    1. Nested\\n\",\n\t\t\"<ol>\\n<li><p>List\\nSecond line</p>\\n\\n<ol>\\n<li>Nested</li>\\n</ol></li>\\n</ol>\\n\",\n\n\t\t\"1.  List\\n    1. Nested\\n\\n    Continued\\n\",\n\t\t\"<ol>\\n<li><p>List</p>\\n\\n<ol>\\n<li>Nested</li>\\n</ol>\\n\\n<p>Continued</p></li>\\n</ol>\\n\",\n\n\t\t\"1.  List\\n   1. shallow indent\\n\",\n\t\t\"<ol>\\n<li>List\\n\\n<ol>\\n<li>shallow indent</li>\\n</ol></li>\\n</ol>\\n\",\n\n\t\t\"1. List\\n\" +\n\t\t\t\" 1. shallow indent\\n\" +\n\t\t\t\"  2. part of second list\\n\" +\n\t\t\t\"   3. still second\\n\" +\n\t\t\t\"    4. almost there\\n\" +\n\t\t\t\"     1. third level\\n\",\n\t\t\"<ol>\\n\" +\n\t\t\t\"<li>List\\n\\n\" +\n\t\t\t\"<ol>\\n\" +\n\t\t\t\"<li>shallow indent</li>\\n\" +\n\t\t\t\"<li>part of second list</li>\\n\" +\n\t\t\t\"<li>still second</li>\\n\" +\n\t\t\t\"<li>almost there\\n\\n\" +\n\t\t\t\"<ol>\\n\" +\n\t\t\t\"<li>third level</li>\\n\" +\n\t\t\t\"</ol></li>\\n\" +\n\t\t\t\"</ol></li>\\n\" +\n\t\t\t\"</ol>\\n\",\n\n\t\t\"1. List\\n        extra indent, same paragraph\\n\",\n\t\t\"<ol>\\n<li>List\\n    extra indent, same paragraph</li>\\n</ol>\\n\",\n\n\t\t\"1. List\\n\\n        code block\\n\",\n\t\t\"<ol>\\n<li><p>List</p>\\n\\n<pre><code>code block\\n</code></pre></li>\\n</ol>\\n\",\n\n\t\t\"1. List\\n\\n          code block with spaces\\n\",\n\t\t\"<ol>\\n<li><p>List</p>\\n\\n<pre><code>  code block with spaces\\n</code></pre></li>\\n</ol>\\n\",\n\n\t\t\"1. List\\n\\n* Spacer Mixed listing\\n\",\n\t\t\"<ol>\\n<li>List</li>\\n</ol>\\n\\n<ul>\\n<li>Spacer Mixed listing</li>\\n</ul>\\n\",\n\n\t\t\"1. List\\n* Mixed listing\\n\",\n\t\t\"<ol>\\n<li>List</li>\\n<li>Mixed listing</li>\\n</ol>\\n\",\n\n\t\t\"1. List\\n    * Mixted list\\n\",\n\t\t\"<ol>\\n<li>List\\n\\n<ul>\\n<li>Mixted list</li>\\n</ul></li>\\n</ol>\\n\",\n\n\t\t\"1. List\\n * Mixed list\\n\",\n\t\t\"<ol>\\n<li>List\\n\\n<ul>\\n<li>Mixed list</li>\\n</ul></li>\\n</ol>\\n\",\n\n\t\t\"* Start with unordered\\n 1. Ordered\\n\",\n\t\t\"<ul>\\n<li>Start with unordered\\n\\n<ol>\\n<li>Ordered</li>\\n</ol></li>\\n</ul>\\n\",\n\n\t\t\"* Start with unordered\\n    1. Ordered\\n\",\n\t\t\"<ul>\\n<li>Start with unordered\\n\\n<ol>\\n<li>Ordered</li>\\n</ol></li>\\n</ul>\\n\",\n\n\t\t\"1. numbers\\n1. are ignored\\n\",\n\t\t\"<ol>\\n<li>numbers</li>\\n<li>are ignored</li>\\n</ol>\\n\",\n\n\t\t`1. Foo\n\n        bar\n\n\n\n        qux\n`,\n\t\t`<ol>\n<li><p>Foo</p>\n\n<pre><code>bar\n\n\n\nqux\n</code></pre></li>\n</ol>\n`,\n\t}\n\tdoTestsBlock(t, tests, 0)\n}\n\nfunc TestDefinitionList(t *testing.T) {\n\tvar tests = []string{\n\t\t\"Term 1\\n:   Definition a\\n\",\n\t\t\"<dl>\\n<dt>Term 1</dt>\\n<dd>Definition a</dd>\\n</dl>\\n\",\n\n\t\t\"Term 1\\n:   Definition a \\n\",\n\t\t\"<dl>\\n<dt>Term 1</dt>\\n<dd>Definition a</dd>\\n</dl>\\n\",\n\n\t\t\"Term 1\\n:   Definition a\\n:   Definition b\\n\",\n\t\t\"<dl>\\n<dt>Term 1</dt>\\n<dd>Definition a</dd>\\n<dd>Definition b</dd>\\n</dl>\\n\",\n\n\t\t\"Term 1\\n:   Definition a\\n\\nTerm 2\\n:   Definition b\\n\",\n\t\t\"<dl>\\n\" +\n\t\t\t\"<dt>Term 1</dt>\\n\" +\n\t\t\t\"<dd>Definition a</dd>\\n\" +\n\t\t\t\"<dt>Term 2</dt>\\n\" +\n\t\t\t\"<dd>Definition b</dd>\\n\" +\n\t\t\t\"</dl>\\n\",\n\n\t\t\"Term 1\\n:   Definition a\\n\\nTerm 2\\n:   Definition b\\n\\nTerm 3\\n:   Definition c\\n\",\n\t\t\"<dl>\\n\" +\n\t\t\t\"<dt>Term 1</dt>\\n\" +\n\t\t\t\"<dd>Definition a</dd>\\n\" +\n\t\t\t\"<dt>Term 2</dt>\\n\" +\n\t\t\t\"<dd>Definition b</dd>\\n\" +\n\t\t\t\"<dt>Term 3</dt>\\n\" +\n\t\t\t\"<dd>Definition c</dd>\\n\" +\n\t\t\t\"</dl>\\n\",\n\n\t\t\"Term 1\\n:   Definition a\\n:   Definition b\\n\\nTerm 2\\n:   Definition c\\n\",\n\t\t\"<dl>\\n\" +\n\t\t\t\"<dt>Term 1</dt>\\n\" +\n\t\t\t\"<dd>Definition a</dd>\\n\" +\n\t\t\t\"<dd>Definition b</dd>\\n\" +\n\t\t\t\"<dt>Term 2</dt>\\n\" +\n\t\t\t\"<dd>Definition c</dd>\\n\" +\n\t\t\t\"</dl>\\n\",\n\n\t\t\"Term 1\\n\\n:   Definition a\\n\\nTerm 2\\n\\n:   Definition b\\n\",\n\t\t\"<dl>\\n\" +\n\t\t\t\"<dt>Term 1</dt>\\n\" +\n\t\t\t\"<dd><p>Definition a</p></dd>\\n\" +\n\t\t\t\"<dt>Term 2</dt>\\n\" +\n\t\t\t\"<dd><p>Definition b</p></dd>\\n\" +\n\t\t\t\"</dl>\\n\",\n\n\t\t\"Term 1\\n\\n:   Definition a\\n\\n:   Definition b\\n\\nTerm 2\\n\\n:   Definition c\\n\",\n\t\t\"<dl>\\n\" +\n\t\t\t\"<dt>Term 1</dt>\\n\" +\n\t\t\t\"<dd><p>Definition a</p></dd>\\n\" +\n\t\t\t\"<dd><p>Definition b</p></dd>\\n\" +\n\t\t\t\"<dt>Term 2</dt>\\n\" +\n\t\t\t\"<dd><p>Definition c</p></dd>\\n\" +\n\t\t\t\"</dl>\\n\",\n\n\t\t\"Term 1\\n:   Definition a\\nNext line\\n\",\n\t\t\"<dl>\\n<dt>Term 1</dt>\\n<dd>Definition a\\nNext line</dd>\\n</dl>\\n\",\n\n\t\t\"Term 1\\n:   Definition a\\n  Next line\\n\",\n\t\t\"<dl>\\n<dt>Term 1</dt>\\n<dd>Definition a\\nNext line</dd>\\n</dl>\\n\",\n\n\t\t\"Term 1\\n:   Definition a \\n  Next line \\n\",\n\t\t\"<dl>\\n<dt>Term 1</dt>\\n<dd>Definition a\\nNext line</dd>\\n</dl>\\n\",\n\n\t\t\"Term 1\\n:   Definition a\\nNext line\\n\\nTerm 2\\n:   Definition b\",\n\t\t\"<dl>\\n\" +\n\t\t\t\"<dt>Term 1</dt>\\n\" +\n\t\t\t\"<dd>Definition a\\nNext line</dd>\\n\" +\n\t\t\t\"<dt>Term 2</dt>\\n\" +\n\t\t\t\"<dd>Definition b</dd>\\n\" +\n\t\t\t\"</dl>\\n\",\n\n\t\t\"Term 1\\n: Definition a\\n\",\n\t\t\"<dl>\\n<dt>Term 1</dt>\\n<dd>Definition a</dd>\\n</dl>\\n\",\n\n\t\t\"Term 1\\n:Definition a\\n\",\n\t\t\"<p>Term 1\\n:Definition a</p>\\n\",\n\n\t\t\"Term 1\\n\\n:   Definition a\\n\\nTerm 2\\n\\n:   Definition b\\n\\nText 1\",\n\t\t\"<dl>\\n\" +\n\t\t\t\"<dt>Term 1</dt>\\n\" +\n\t\t\t\"<dd><p>Definition a</p></dd>\\n\" +\n\t\t\t\"<dt>Term 2</dt>\\n\" +\n\t\t\t\"<dd><p>Definition b</p></dd>\\n\" +\n\t\t\t\"</dl>\\n\" +\n\t\t\t\"\\n<p>Text 1</p>\\n\",\n\n\t\t\"Term 1\\n\\n:   Definition a\\n\\nText 1\\n\\nTerm 2\\n\\n:   Definition b\\n\\nText 2\",\n\t\t\"<dl>\\n\" +\n\t\t\t\"<dt>Term 1</dt>\\n\" +\n\t\t\t\"<dd><p>Definition a</p></dd>\\n\" +\n\t\t\t\"</dl>\\n\" +\n\t\t\t\"\\n<p>Text 1</p>\\n\" +\n\t\t\t\"\\n<dl>\\n\" +\n\t\t\t\"<dt>Term 2</dt>\\n\" +\n\t\t\t\"<dd><p>Definition b</p></dd>\\n\" +\n\t\t\t\"</dl>\\n\" +\n\t\t\t\"\\n<p>Text 2</p>\\n\",\n\n\t\t\"Term 1\\n:   Definition a\\n\\n    Text 1\\n\\n    1. First\\n    2. Second\",\n\t\t\"<dl>\\n\" +\n\t\t\t\"<dt>Term 1</dt>\\n\" +\n\t\t\t\"<dd><p>Definition a</p>\\n\\n\" +\n\t\t\t\"<p>Text 1</p>\\n\\n\" +\n\t\t\t\"<ol>\\n<li>First</li>\\n<li>Second</li>\\n</ol></dd>\\n\" +\n\t\t\t\"</dl>\\n\",\n\t}\n\tdoTestsBlock(t, tests, EXTENSION_DEFINITION_LISTS)\n}\n\nfunc TestPreformattedHtml(t *testing.T) {\n\tvar tests = []string{\n\t\t\"<div></div>\\n\",\n\t\t\"<div></div>\\n\",\n\n\t\t\"<div>\\n</div>\\n\",\n\t\t\"<div>\\n</div>\\n\",\n\n\t\t\"<div>\\n</div>\\nParagraph\\n\",\n\t\t\"<p><div>\\n</div>\\nParagraph</p>\\n\",\n\n\t\t\"<div class=\\\"foo\\\">\\n</div>\\n\",\n\t\t\"<div class=\\\"foo\\\">\\n</div>\\n\",\n\n\t\t\"<div>\\nAnything here\\n</div>\\n\",\n\t\t\"<div>\\nAnything here\\n</div>\\n\",\n\n\t\t\"<div>\\n  Anything here\\n</div>\\n\",\n\t\t\"<div>\\n  Anything here\\n</div>\\n\",\n\n\t\t\"<div>\\nAnything here\\n  </div>\\n\",\n\t\t\"<div>\\nAnything here\\n  </div>\\n\",\n\n\t\t\"<div>\\nThis is *not* &proceessed\\n</div>\\n\",\n\t\t\"<div>\\nThis is *not* &proceessed\\n</div>\\n\",\n\n\t\t\"<faketag>\\n  Something\\n</faketag>\\n\",\n\t\t\"<p><faketag>\\n  Something\\n</faketag></p>\\n\",\n\n\t\t\"<div>\\n  Something here\\n</divv>\\n\",\n\t\t\"<p><div>\\n  Something here\\n</divv></p>\\n\",\n\n\t\t\"Paragraph\\n<div>\\nHere? >&<\\n</div>\\n\",\n\t\t\"<p>Paragraph\\n<div>\\nHere? &gt;&amp;&lt;\\n</div></p>\\n\",\n\n\t\t\"Paragraph\\n\\n<div>\\nHow about here? >&<\\n</div>\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<div>\\nHow about here? >&<\\n</div>\\n\",\n\n\t\t\"Paragraph\\n<div>\\nHere? >&<\\n</div>\\nAnd here?\\n\",\n\t\t\"<p>Paragraph\\n<div>\\nHere? &gt;&amp;&lt;\\n</div>\\nAnd here?</p>\\n\",\n\n\t\t\"Paragraph\\n\\n<div>\\nHow about here? >&<\\n</div>\\nAnd here?\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<p><div>\\nHow about here? &gt;&amp;&lt;\\n</div>\\nAnd here?</p>\\n\",\n\n\t\t\"Paragraph\\n<div>\\nHere? >&<\\n</div>\\n\\nAnd here?\\n\",\n\t\t\"<p>Paragraph\\n<div>\\nHere? &gt;&amp;&lt;\\n</div></p>\\n\\n<p>And here?</p>\\n\",\n\n\t\t\"Paragraph\\n\\n<div>\\nHow about here? >&<\\n</div>\\n\\nAnd here?\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<div>\\nHow about here? >&<\\n</div>\\n\\n<p>And here?</p>\\n\",\n\t}\n\tdoTestsBlock(t, tests, 0)\n}\n\nfunc TestPreformattedHtmlLax(t *testing.T) {\n\tvar tests = []string{\n\t\t\"Paragraph\\n<div>\\nHere? >&<\\n</div>\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<div>\\nHere? >&<\\n</div>\\n\",\n\n\t\t\"Paragraph\\n\\n<div>\\nHow about here? >&<\\n</div>\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<div>\\nHow about here? >&<\\n</div>\\n\",\n\n\t\t\"Paragraph\\n<div>\\nHere? >&<\\n</div>\\nAnd here?\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<div>\\nHere? >&<\\n</div>\\n\\n<p>And here?</p>\\n\",\n\n\t\t\"Paragraph\\n\\n<div>\\nHow about here? >&<\\n</div>\\nAnd here?\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<div>\\nHow about here? >&<\\n</div>\\n\\n<p>And here?</p>\\n\",\n\n\t\t\"Paragraph\\n<div>\\nHere? >&<\\n</div>\\n\\nAnd here?\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<div>\\nHere? >&<\\n</div>\\n\\n<p>And here?</p>\\n\",\n\n\t\t\"Paragraph\\n\\n<div>\\nHow about here? >&<\\n</div>\\n\\nAnd here?\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<div>\\nHow about here? >&<\\n</div>\\n\\n<p>And here?</p>\\n\",\n\t}\n\tdoTestsBlock(t, tests, EXTENSION_LAX_HTML_BLOCKS)\n}\n\nfunc TestFencedCodeBlock(t *testing.T) {\n\tvar tests = []string{\n\t\t\"``` go\\nfunc foo() bool {\\n\\treturn true;\\n}\\n```\\n\",\n\t\t\"<pre><code class=\\\"language-go\\\">func foo() bool {\\n\\treturn true;\\n}\\n</code></pre>\\n\",\n\n\t\t\"``` go foo bar\\nfunc foo() bool {\\n\\treturn true;\\n}\\n```\\n\",\n\t\t\"<pre><code class=\\\"language-go\\\">func foo() bool {\\n\\treturn true;\\n}\\n</code></pre>\\n\",\n\n\t\t\"``` c\\n/* special & char < > \\\" escaping */\\n```\\n\",\n\t\t\"<pre><code class=\\\"language-c\\\">/* special &amp; char &lt; &gt; &quot; escaping */\\n</code></pre>\\n\",\n\n\t\t\"``` c\\nno *inline* processing ~~of text~~\\n```\\n\",\n\t\t\"<pre><code class=\\\"language-c\\\">no *inline* processing ~~of text~~\\n</code></pre>\\n\",\n\n\t\t\"```\\nNo language\\n```\\n\",\n\t\t\"<pre><code>No language\\n</code></pre>\\n\",\n\n\t\t\"``` {ocaml}\\nlanguage in braces\\n```\\n\",\n\t\t\"<pre><code class=\\\"language-ocaml\\\">language in braces\\n</code></pre>\\n\",\n\n\t\t\"```    {ocaml}      \\nwith extra whitespace\\n```\\n\",\n\t\t\"<pre><code class=\\\"language-ocaml\\\">with extra whitespace\\n</code></pre>\\n\",\n\n\t\t\"```{   ocaml   }\\nwith extra whitespace\\n```\\n\",\n\t\t\"<pre><code class=\\\"language-ocaml\\\">with extra whitespace\\n</code></pre>\\n\",\n\n\t\t\"~ ~~ java\\nWith whitespace\\n~~~\\n\",\n\t\t\"<p>~ ~~ java\\nWith whitespace\\n~~~</p>\\n\",\n\n\t\t\"~~\\nonly two\\n~~\\n\",\n\t\t\"<p>~~\\nonly two\\n~~</p>\\n\",\n\n\t\t\"```` python\\nextra\\n````\\n\",\n\t\t\"<pre><code class=\\\"language-python\\\">extra\\n</code></pre>\\n\",\n\n\t\t\"~~~ perl\\nthree to start, four to end\\n~~~~\\n\",\n\t\t\"<p>~~~ perl\\nthree to start, four to end\\n~~~~</p>\\n\",\n\n\t\t\"~~~~ perl\\nfour to start, three to end\\n~~~\\n\",\n\t\t\"<p>~~~~ perl\\nfour to start, three to end\\n~~~</p>\\n\",\n\n\t\t\"~~~ bash\\ntildes\\n~~~\\n\",\n\t\t\"<pre><code class=\\\"language-bash\\\">tildes\\n</code></pre>\\n\",\n\n\t\t\"``` lisp\\nno ending\\n\",\n\t\t\"<p>``` lisp\\nno ending</p>\\n\",\n\n\t\t\"~~~ lisp\\nend with language\\n~~~ lisp\\n\",\n\t\t\"<pre><code class=\\\"language-lisp\\\">end with language\\n</code></pre>\\n\\n<p>lisp</p>\\n\",\n\n\t\t\"```\\nmismatched begin and end\\n~~~\\n\",\n\t\t\"<p>```\\nmismatched begin and end\\n~~~</p>\\n\",\n\n\t\t\"~~~\\nmismatched begin and end\\n```\\n\",\n\t\t\"<p>~~~\\nmismatched begin and end\\n```</p>\\n\",\n\n\t\t\"   ``` oz\\nleading spaces\\n```\\n\",\n\t\t\"<pre><code class=\\\"language-oz\\\">leading spaces\\n</code></pre>\\n\",\n\n\t\t\"  ``` oz\\nleading spaces\\n ```\\n\",\n\t\t\"<pre><code class=\\\"language-oz\\\">leading spaces\\n</code></pre>\\n\",\n\n\t\t\" ``` oz\\nleading spaces\\n  ```\\n\",\n\t\t\"<pre><code class=\\\"language-oz\\\">leading spaces\\n</code></pre>\\n\",\n\n\t\t\"``` oz\\nleading spaces\\n   ```\\n\",\n\t\t\"<pre><code class=\\\"language-oz\\\">leading spaces\\n</code></pre>\\n\",\n\n\t\t\"    ``` oz\\nleading spaces\\n    ```\\n\",\n\t\t\"<pre><code>``` oz\\n</code></pre>\\n\\n<p>leading spaces\\n    ```</p>\\n\",\n\n\t\t\"Bla bla\\n\\n``` oz\\ncode blocks breakup paragraphs\\n```\\n\\nBla Bla\\n\",\n\t\t\"<p>Bla bla</p>\\n\\n<pre><code class=\\\"language-oz\\\">code blocks breakup paragraphs\\n</code></pre>\\n\\n<p>Bla Bla</p>\\n\",\n\n\t\t\"Some text before a fenced code block\\n``` oz\\ncode blocks breakup paragraphs\\n```\\nAnd some text after a fenced code block\",\n\t\t\"<p>Some text before a fenced code block</p>\\n\\n<pre><code class=\\\"language-oz\\\">code blocks breakup paragraphs\\n</code></pre>\\n\\n<p>And some text after a fenced code block</p>\\n\",\n\n\t\t\"`\",\n\t\t\"<p>`</p>\\n\",\n\n\t\t\"Bla bla\\n\\n``` oz\\ncode blocks breakup paragraphs\\n```\\n\\nBla Bla\\n\\n``` oz\\nmultiple code blocks work okay\\n```\\n\\nBla Bla\\n\",\n\t\t\"<p>Bla bla</p>\\n\\n<pre><code class=\\\"language-oz\\\">code blocks breakup paragraphs\\n</code></pre>\\n\\n<p>Bla Bla</p>\\n\\n<pre><code class=\\\"language-oz\\\">multiple code blocks work okay\\n</code></pre>\\n\\n<p>Bla Bla</p>\\n\",\n\n\t\t\"Some text before a fenced code block\\n``` oz\\ncode blocks breakup paragraphs\\n```\\nSome text in between\\n``` oz\\nmultiple code blocks work okay\\n```\\nAnd some text after a fenced code block\",\n\t\t\"<p>Some text before a fenced code block</p>\\n\\n<pre><code class=\\\"language-oz\\\">code blocks breakup paragraphs\\n</code></pre>\\n\\n<p>Some text in between</p>\\n\\n<pre><code class=\\\"language-oz\\\">multiple code blocks work okay\\n</code></pre>\\n\\n<p>And some text after a fenced code block</p>\\n\",\n\n\t\t\"```\\n[]:()\\n```\\n\",\n\t\t\"<pre><code>[]:()\\n</code></pre>\\n\",\n\n\t\t\"```\\n[]:()\\n[]:)\\n[]:(\\n[]:x\\n[]:testing\\n[:testing\\n\\n[]:\\nlinebreak\\n[]()\\n\\n[]:\\n[]()\\n```\",\n\t\t\"<pre><code>[]:()\\n[]:)\\n[]:(\\n[]:x\\n[]:testing\\n[:testing\\n\\n[]:\\nlinebreak\\n[]()\\n\\n[]:\\n[]()\\n</code></pre>\\n\",\n\n\t\t\"- test\\n\\n```\\n  codeblock\\n  ```\\ntest\\n\",\n\t\t\"<ul>\\n<li><p>test</p>\\n\\n<pre><code>codeblock\\n</code></pre></li>\\n</ul>\\n\\n<p>test</p>\\n\",\n\n\t\t\"- ```\\n  codeblock\\n  ```\\n\\n- test\\n\",\n\t\t\"<ul>\\n<li><pre><code>codeblock\\n</code></pre></li>\\n\\n<li><p>test</p></li>\\n</ul>\\n\",\n\n\t\t\"- test\\n- ```\\n  codeblock\\n  ```\\n\",\n\t\t\"<ul>\\n<li>test</li>\\n\\n<li><pre><code>codeblock\\n</code></pre></li>\\n</ul>\\n\",\n\n\t\t\"- test\\n```\\ncodeblock\\n```\\n\\n- test\\n\",\n\t\t\"<ul>\\n<li><p>test</p>\\n\\n<pre><code>codeblock\\n</code></pre></li>\\n\\n<li><p>test</p></li>\\n</ul>\\n\",\n\n\t\t\"- test\\n```go\\nfunc foo() bool {\\n\\treturn true;\\n}\\n```\\n\\n- test\\n\",\n\t\t\"<ul>\\n<li><p>test</p>\\n\\n<pre><code class=\\\"language-go\\\">func foo() bool {\\n\\treturn true;\\n}\\n</code></pre></li>\\n\\n<li><p>test</p></li>\\n</ul>\\n\",\n\t}\n\tdoTestsBlock(t, tests, EXTENSION_FENCED_CODE)\n}\n\nfunc TestFencedCodeInsideBlockquotes(t *testing.T) {\n\tcat := func(s ...string) string { return strings.Join(s, \"\\n\") }\n\tvar tests = []string{\n\t\tcat(\"> ```go\",\n\t\t\t\"package moo\",\n\t\t\t\"\",\n\t\t\t\"```\",\n\t\t\t\"\"),\n\t\t`<blockquote>\n<pre><code class=\"language-go\">package moo\n\n</code></pre>\n</blockquote>\n`,\n\t\t// -------------------------------------------\n\t\tcat(\"> foo\",\n\t\t\t\"> \",\n\t\t\t\"> ```go\",\n\t\t\t\"package moo\",\n\t\t\t\"```\",\n\t\t\t\"> \",\n\t\t\t\"> goo.\",\n\t\t\t\"\"),\n\t\t`<blockquote>\n<p>foo</p>\n\n<pre><code class=\"language-go\">package moo\n</code></pre>\n\n<p>goo.</p>\n</blockquote>\n`,\n\t\t// -------------------------------------------\n\t\tcat(\"> foo\",\n\t\t\t\"> \",\n\t\t\t\"> quote\",\n\t\t\t\"continues\",\n\t\t\t\"```\",\n\t\t\t\"\"),\n\t\t`<blockquote>\n<p>foo</p>\n\n<p>quote\ncontinues\n` + \"```\" + `</p>\n</blockquote>\n`,\n\t\t// -------------------------------------------\n\t\tcat(\"> foo\",\n\t\t\t\"> \",\n\t\t\t\"> ```go\",\n\t\t\t\"package moo\",\n\t\t\t\"```\",\n\t\t\t\"> \",\n\t\t\t\"> goo.\",\n\t\t\t\"> \",\n\t\t\t\"> ```go\",\n\t\t\t\"package zoo\",\n\t\t\t\"```\",\n\t\t\t\"> \",\n\t\t\t\"> woo.\",\n\t\t\t\"\"),\n\t\t`<blockquote>\n<p>foo</p>\n\n<pre><code class=\"language-go\">package moo\n</code></pre>\n\n<p>goo.</p>\n\n<pre><code class=\"language-go\">package zoo\n</code></pre>\n\n<p>woo.</p>\n</blockquote>\n`,\n\t}\n\n\t// These 2 alternative forms of blockquoted fenced code blocks should produce same output.\n\tforms := [2]string{\n\t\tcat(\"> plain quoted text\",\n\t\t\t\"> ```fenced\",\n\t\t\t\"code\",\n\t\t\t\" with leading single space correctly preserved\",\n\t\t\t\"okay\",\n\t\t\t\"```\",\n\t\t\t\"> rest of quoted text\"),\n\t\tcat(\"> plain quoted text\",\n\t\t\t\"> ```fenced\",\n\t\t\t\"> code\",\n\t\t\t\">  with leading single space correctly preserved\",\n\t\t\t\"> okay\",\n\t\t\t\"> ```\",\n\t\t\t\"> rest of quoted text\"),\n\t}\n\twant := `<blockquote>\n<p>plain quoted text</p>\n\n<pre><code class=\"language-fenced\">code\n with leading single space correctly preserved\nokay\n</code></pre>\n\n<p>rest of quoted text</p>\n</blockquote>\n`\n\ttests = append(tests, forms[0], want)\n\ttests = append(tests, forms[1], want)\n\n\tdoTestsBlock(t, tests, EXTENSION_FENCED_CODE)\n}\n\nfunc TestTable(t *testing.T) {\n\tvar tests = []string{\n\t\t\"a | b\\n---|---\\nc | d\\n\",\n\t\t\"<table>\\n<thead>\\n<tr>\\n<th>a</th>\\n<th>b</th>\\n</tr>\\n</thead>\\n\\n\" +\n\t\t\t\"<tbody>\\n<tr>\\n<td>c</td>\\n<td>d</td>\\n</tr>\\n</tbody>\\n</table>\\n\",\n\n\t\t\"a | b\\n---|--\\nc | d\\n\",\n\t\t\"<p>a | b\\n---|--\\nc | d</p>\\n\",\n\n\t\t\"|a|b|c|d|\\n|----|----|----|---|\\n|e|f|g|h|\\n\",\n\t\t\"<table>\\n<thead>\\n<tr>\\n<th>a</th>\\n<th>b</th>\\n<th>c</th>\\n<th>d</th>\\n</tr>\\n</thead>\\n\\n\" +\n\t\t\t\"<tbody>\\n<tr>\\n<td>e</td>\\n<td>f</td>\\n<td>g</td>\\n<td>h</td>\\n</tr>\\n</tbody>\\n</table>\\n\",\n\n\t\t\"*a*|__b__|[c](C)|d\\n---|---|---|---\\ne|f|g|h\\n\",\n\t\t\"<table>\\n<thead>\\n<tr>\\n<th><em>a</em></th>\\n<th><strong>b</strong></th>\\n<th><a href=\\\"C\\\">c</a></th>\\n<th>d</th>\\n</tr>\\n</thead>\\n\\n\" +\n\t\t\t\"<tbody>\\n<tr>\\n<td>e</td>\\n<td>f</td>\\n<td>g</td>\\n<td>h</td>\\n</tr>\\n</tbody>\\n</table>\\n\",\n\n\t\t\"a|b|c\\n---|---|---\\nd|e|f\\ng|h\\ni|j|k|l|m\\nn|o|p\\n\",\n\t\t\"<table>\\n<thead>\\n<tr>\\n<th>a</th>\\n<th>b</th>\\n<th>c</th>\\n</tr>\\n</thead>\\n\\n\" +\n\t\t\t\"<tbody>\\n<tr>\\n<td>d</td>\\n<td>e</td>\\n<td>f</td>\\n</tr>\\n\\n\" +\n\t\t\t\"<tr>\\n<td>g</td>\\n<td>h</td>\\n<td></td>\\n</tr>\\n\\n\" +\n\t\t\t\"<tr>\\n<td>i</td>\\n<td>j</td>\\n<td>k</td>\\n</tr>\\n\\n\" +\n\t\t\t\"<tr>\\n<td>n</td>\\n<td>o</td>\\n<td>p</td>\\n</tr>\\n</tbody>\\n</table>\\n\",\n\n\t\t\"a|b|c\\n---|---|---\\n*d*|__e__|f\\n\",\n\t\t\"<table>\\n<thead>\\n<tr>\\n<th>a</th>\\n<th>b</th>\\n<th>c</th>\\n</tr>\\n</thead>\\n\\n\" +\n\t\t\t\"<tbody>\\n<tr>\\n<td><em>d</em></td>\\n<td><strong>e</strong></td>\\n<td>f</td>\\n</tr>\\n</tbody>\\n</table>\\n\",\n\n\t\t\"a|b|c|d\\n:--|--:|:-:|---\\ne|f|g|h\\n\",\n\t\t\"<table>\\n<thead>\\n<tr>\\n<th align=\\\"left\\\">a</th>\\n<th align=\\\"right\\\">b</th>\\n\" +\n\t\t\t\"<th align=\\\"center\\\">c</th>\\n<th>d</th>\\n</tr>\\n</thead>\\n\\n\" +\n\t\t\t\"<tbody>\\n<tr>\\n<td align=\\\"left\\\">e</td>\\n<td align=\\\"right\\\">f</td>\\n\" +\n\t\t\t\"<td align=\\\"center\\\">g</td>\\n<td>h</td>\\n</tr>\\n</tbody>\\n</table>\\n\",\n\n\t\t\"a|b|c\\n---|---|---\\n\",\n\t\t\"<table>\\n<thead>\\n<tr>\\n<th>a</th>\\n<th>b</th>\\n<th>c</th>\\n</tr>\\n</thead>\\n\\n<tbody>\\n</tbody>\\n</table>\\n\",\n\n\t\t\"a| b|c | d | e\\n---|---|---|---|---\\nf| g|h | i |j\\n\",\n\t\t\"<table>\\n<thead>\\n<tr>\\n<th>a</th>\\n<th>b</th>\\n<th>c</th>\\n<th>d</th>\\n<th>e</th>\\n</tr>\\n</thead>\\n\\n\" +\n\t\t\t\"<tbody>\\n<tr>\\n<td>f</td>\\n<td>g</td>\\n<td>h</td>\\n<td>i</td>\\n<td>j</td>\\n</tr>\\n</tbody>\\n</table>\\n\",\n\n\t\t\"a|b\\\\|c|d\\n---|---|---\\nf|g\\\\|h|i\\n\",\n\t\t\"<table>\\n<thead>\\n<tr>\\n<th>a</th>\\n<th>b|c</th>\\n<th>d</th>\\n</tr>\\n</thead>\\n\\n<tbody>\\n<tr>\\n<td>f</td>\\n<td>g|h</td>\\n<td>i</td>\\n</tr>\\n</tbody>\\n</table>\\n\",\n\t}\n\tdoTestsBlock(t, tests, EXTENSION_TABLES)\n}\n\nfunc TestUnorderedListWith_EXTENSION_NO_EMPTY_LINE_BEFORE_BLOCK(t *testing.T) {\n\tvar tests = []string{\n\t\t\"* Hello\\n\",\n\t\t\"<ul>\\n<li>Hello</li>\\n</ul>\\n\",\n\n\t\t\"* Yin\\n* Yang\\n\",\n\t\t\"<ul>\\n<li>Yin</li>\\n<li>Yang</li>\\n</ul>\\n\",\n\n\t\t\"* Ting\\n* Bong\\n* Goo\\n\",\n\t\t\"<ul>\\n<li>Ting</li>\\n<li>Bong</li>\\n<li>Goo</li>\\n</ul>\\n\",\n\n\t\t\"* Yin\\n\\n* Yang\\n\",\n\t\t\"<ul>\\n<li><p>Yin</p></li>\\n\\n<li><p>Yang</p></li>\\n</ul>\\n\",\n\n\t\t\"* Ting\\n\\n* Bong\\n* Goo\\n\",\n\t\t\"<ul>\\n<li><p>Ting</p></li>\\n\\n<li><p>Bong</p></li>\\n\\n<li><p>Goo</p></li>\\n</ul>\\n\",\n\n\t\t\"+ Hello\\n\",\n\t\t\"<ul>\\n<li>Hello</li>\\n</ul>\\n\",\n\n\t\t\"+ Yin\\n+ Yang\\n\",\n\t\t\"<ul>\\n<li>Yin</li>\\n<li>Yang</li>\\n</ul>\\n\",\n\n\t\t\"+ Ting\\n+ Bong\\n+ Goo\\n\",\n\t\t\"<ul>\\n<li>Ting</li>\\n<li>Bong</li>\\n<li>Goo</li>\\n</ul>\\n\",\n\n\t\t\"+ Yin\\n\\n+ Yang\\n\",\n\t\t\"<ul>\\n<li><p>Yin</p></li>\\n\\n<li><p>Yang</p></li>\\n</ul>\\n\",\n\n\t\t\"+ Ting\\n\\n+ Bong\\n+ Goo\\n\",\n\t\t\"<ul>\\n<li><p>Ting</p></li>\\n\\n<li><p>Bong</p></li>\\n\\n<li><p>Goo</p></li>\\n</ul>\\n\",\n\n\t\t\"- Hello\\n\",\n\t\t\"<ul>\\n<li>Hello</li>\\n</ul>\\n\",\n\n\t\t\"- Yin\\n- Yang\\n\",\n\t\t\"<ul>\\n<li>Yin</li>\\n<li>Yang</li>\\n</ul>\\n\",\n\n\t\t\"- Ting\\n- Bong\\n- Goo\\n\",\n\t\t\"<ul>\\n<li>Ting</li>\\n<li>Bong</li>\\n<li>Goo</li>\\n</ul>\\n\",\n\n\t\t\"- Yin\\n\\n- Yang\\n\",\n\t\t\"<ul>\\n<li><p>Yin</p></li>\\n\\n<li><p>Yang</p></li>\\n</ul>\\n\",\n\n\t\t\"- Ting\\n\\n- Bong\\n- Goo\\n\",\n\t\t\"<ul>\\n<li><p>Ting</p></li>\\n\\n<li><p>Bong</p></li>\\n\\n<li><p>Goo</p></li>\\n</ul>\\n\",\n\n\t\t\"*Hello\\n\",\n\t\t\"<p>*Hello</p>\\n\",\n\n\t\t\"*   Hello \\n\",\n\t\t\"<ul>\\n<li>Hello</li>\\n</ul>\\n\",\n\n\t\t\"*   Hello \\n    Next line \\n\",\n\t\t\"<ul>\\n<li>Hello\\nNext line</li>\\n</ul>\\n\",\n\n\t\t\"Paragraph\\n* No linebreak\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<ul>\\n<li>No linebreak</li>\\n</ul>\\n\",\n\n\t\t\"Paragraph\\n\\n* Linebreak\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<ul>\\n<li>Linebreak</li>\\n</ul>\\n\",\n\n\t\t\"*   List\\n    * Nested list\\n\",\n\t\t\"<ul>\\n<li>List\\n\\n<ul>\\n<li>Nested list</li>\\n</ul></li>\\n</ul>\\n\",\n\n\t\t\"*   List\\n\\n    * Nested list\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<ul>\\n<li>Nested list</li>\\n</ul></li>\\n</ul>\\n\",\n\n\t\t\"*   List\\n    Second line\\n\\n    + Nested\\n\",\n\t\t\"<ul>\\n<li><p>List\\nSecond line</p>\\n\\n<ul>\\n<li>Nested</li>\\n</ul></li>\\n</ul>\\n\",\n\n\t\t\"*   List\\n    + Nested\\n\\n    Continued\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<ul>\\n<li>Nested</li>\\n</ul>\\n\\n<p>Continued</p></li>\\n</ul>\\n\",\n\n\t\t\"*   List\\n   * shallow indent\\n\",\n\t\t\"<ul>\\n<li>List\\n\\n<ul>\\n<li>shallow indent</li>\\n</ul></li>\\n</ul>\\n\",\n\n\t\t\"* List\\n\" +\n\t\t\t\" * shallow indent\\n\" +\n\t\t\t\"  * part of second list\\n\" +\n\t\t\t\"   * still second\\n\" +\n\t\t\t\"    * almost there\\n\" +\n\t\t\t\"     * third level\\n\",\n\t\t\"<ul>\\n\" +\n\t\t\t\"<li>List\\n\\n\" +\n\t\t\t\"<ul>\\n\" +\n\t\t\t\"<li>shallow indent</li>\\n\" +\n\t\t\t\"<li>part of second list</li>\\n\" +\n\t\t\t\"<li>still second</li>\\n\" +\n\t\t\t\"<li>almost there\\n\\n\" +\n\t\t\t\"<ul>\\n\" +\n\t\t\t\"<li>third level</li>\\n\" +\n\t\t\t\"</ul></li>\\n\" +\n\t\t\t\"</ul></li>\\n\" +\n\t\t\t\"</ul>\\n\",\n\n\t\t\"* List\\n        extra indent, same paragraph\\n\",\n\t\t\"<ul>\\n<li>List\\n    extra indent, same paragraph</li>\\n</ul>\\n\",\n\n\t\t\"* List\\n\\n        code block\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<pre><code>code block\\n</code></pre></li>\\n</ul>\\n\",\n\n\t\t\"* List\\n\\n          code block with spaces\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<pre><code>  code block with spaces\\n</code></pre></li>\\n</ul>\\n\",\n\n\t\t\"* List\\n\\n    * sublist\\n\\n    normal text\\n\\n    * another sublist\\n\",\n\t\t\"<ul>\\n<li><p>List</p>\\n\\n<ul>\\n<li>sublist</li>\\n</ul>\\n\\n<p>normal text</p>\\n\\n<ul>\\n<li>another sublist</li>\\n</ul></li>\\n</ul>\\n\",\n\t}\n\tdoTestsBlock(t, tests, EXTENSION_NO_EMPTY_LINE_BEFORE_BLOCK)\n}\n\nfunc TestOrderedList_EXTENSION_NO_EMPTY_LINE_BEFORE_BLOCK(t *testing.T) {\n\tvar tests = []string{\n\t\t\"1. Hello\\n\",\n\t\t\"<ol>\\n<li>Hello</li>\\n</ol>\\n\",\n\n\t\t\"1. Yin\\n2. Yang\\n\",\n\t\t\"<ol>\\n<li>Yin</li>\\n<li>Yang</li>\\n</ol>\\n\",\n\n\t\t\"1. Ting\\n2. Bong\\n3. Goo\\n\",\n\t\t\"<ol>\\n<li>Ting</li>\\n<li>Bong</li>\\n<li>Goo</li>\\n</ol>\\n\",\n\n\t\t\"1. Yin\\n\\n2. Yang\\n\",\n\t\t\"<ol>\\n<li><p>Yin</p></li>\\n\\n<li><p>Yang</p></li>\\n</ol>\\n\",\n\n\t\t\"1. Ting\\n\\n2. Bong\\n3. Goo\\n\",\n\t\t\"<ol>\\n<li><p>Ting</p></li>\\n\\n<li><p>Bong</p></li>\\n\\n<li><p>Goo</p></li>\\n</ol>\\n\",\n\n\t\t\"1 Hello\\n\",\n\t\t\"<p>1 Hello</p>\\n\",\n\n\t\t\"1.Hello\\n\",\n\t\t\"<p>1.Hello</p>\\n\",\n\n\t\t\"1.  Hello \\n\",\n\t\t\"<ol>\\n<li>Hello</li>\\n</ol>\\n\",\n\n\t\t\"1.  Hello \\n    Next line \\n\",\n\t\t\"<ol>\\n<li>Hello\\nNext line</li>\\n</ol>\\n\",\n\n\t\t\"Paragraph\\n1. No linebreak\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<ol>\\n<li>No linebreak</li>\\n</ol>\\n\",\n\n\t\t\"Paragraph\\n\\n1. Linebreak\\n\",\n\t\t\"<p>Paragraph</p>\\n\\n<ol>\\n<li>Linebreak</li>\\n</ol>\\n\",\n\n\t\t\"1.  List\\n    1. Nested list\\n\",\n\t\t\"<ol>\\n<li>List\\n\\n<ol>\\n<li>Nested list</li>\\n</ol></li>\\n</ol>\\n\",\n\n\t\t\"1.  List\\n\\n    1. Nested list\\n\",\n\t\t\"<ol>\\n<li><p>List</p>\\n\\n<ol>\\n<li>Nested list</li>\\n</ol></li>\\n</ol>\\n\",\n\n\t\t\"1.  List\\n    Second line\\n\\n    1. Nested\\n\",\n\t\t\"<ol>\\n<li><p>List\\nSecond line</p>\\n\\n<ol>\\n<li>Nested</li>\\n</ol></li>\\n</ol>\\n\",\n\n\t\t\"1.  List\\n    1. Nested\\n\\n    Continued\\n\",\n\t\t\"<ol>\\n<li><p>List</p>\\n\\n<ol>\\n<li>Nested</li>\\n</ol>\\n\\n<p>Continued</p></li>\\n</ol>\\n\",\n\n\t\t\"1.  List\\n   1. shallow indent\\n\",\n\t\t\"<ol>\\n<li>List\\n\\n<ol>\\n<li>shallow indent</li>\\n</ol></li>\\n</ol>\\n\",\n\n\t\t\"1. List\\n\" +\n\t\t\t\" 1. shallow indent\\n\" +\n\t\t\t\"  2. part of second list\\n\" +\n\t\t\t\"   3. still second\\n\" +\n\t\t\t\"    4. almost there\\n\" +\n\t\t\t\"     1. third level\\n\",\n\t\t\"<ol>\\n\" +\n\t\t\t\"<li>List\\n\\n\" +\n\t\t\t\"<ol>\\n\" +\n\t\t\t\"<li>shallow indent</li>\\n\" +\n\t\t\t\"<li>part of second list</li>\\n\" +\n\t\t\t\"<li>still second</li>\\n\" +\n\t\t\t\"<li>almost there\\n\\n\" +\n\t\t\t\"<ol>\\n\" +\n\t\t\t\"<li>third level</li>\\n\" +\n\t\t\t\"</ol></li>\\n\" +\n\t\t\t\"</ol></li>\\n\" +\n\t\t\t\"</ol>\\n\",\n\n\t\t\"1. List\\n        extra indent, same paragraph\\n\",\n\t\t\"<ol>\\n<li>List\\n    extra indent, same paragraph</li>\\n</ol>\\n\",\n\n\t\t\"1. List\\n\\n        code block\\n\",\n\t\t\"<ol>\\n<li><p>List</p>\\n\\n<pre><code>code block\\n</code></pre></li>\\n</ol>\\n\",\n\n\t\t\"1. List\\n\\n          code block with spaces\\n\",\n\t\t\"<ol>\\n<li><p>List</p>\\n\\n<pre><code>  code block with spaces\\n</code></pre></li>\\n</ol>\\n\",\n\n\t\t\"1. List\\n    * Mixted list\\n\",\n\t\t\"<ol>\\n<li>List\\n\\n<ul>\\n<li>Mixted list</li>\\n</ul></li>\\n</ol>\\n\",\n\n\t\t\"1. List\\n * Mixed list\\n\",\n\t\t\"<ol>\\n<li>List\\n\\n<ul>\\n<li>Mixed list</li>\\n</ul></li>\\n</ol>\\n\",\n\n\t\t\"* Start with unordered\\n 1. Ordered\\n\",\n\t\t\"<ul>\\n<li>Start with unordered\\n\\n<ol>\\n<li>Ordered</li>\\n</ol></li>\\n</ul>\\n\",\n\n\t\t\"* Start with unordered\\n    1. Ordered\\n\",\n\t\t\"<ul>\\n<li>Start with unordered\\n\\n<ol>\\n<li>Ordered</li>\\n</ol></li>\\n</ul>\\n\",\n\n\t\t\"1. numbers\\n1. are ignored\\n\",\n\t\t\"<ol>\\n<li>numbers</li>\\n<li>are ignored</li>\\n</ol>\\n\",\n\t}\n\tdoTestsBlock(t, tests, EXTENSION_NO_EMPTY_LINE_BEFORE_BLOCK)\n}\n\nfunc TestFencedCodeBlock_EXTENSION_NO_EMPTY_LINE_BEFORE_BLOCK(t *testing.T) {\n\tvar tests = []string{\n\t\t\"``` go\\nfunc foo() bool {\\n\\treturn true;\\n}\\n```\\n\",\n\t\t\"<pre><code class=\\\"language-go\\\">func foo() bool {\\n\\treturn true;\\n}\\n</code></pre>\\n\",\n\n\t\t\"``` go foo bar\\nfunc foo() bool {\\n\\treturn true;\\n}\\n```\\n\",\n\t\t\"<pre><code class=\\\"language-go\\\">func foo() bool {\\n\\treturn true;\\n}\\n</code></pre>\\n\",\n\n\t\t\"``` c\\n/* special & char < > \\\" escaping */\\n```\\n\",\n\t\t\"<pre><code class=\\\"language-c\\\">/* special &amp; char &lt; &gt; &quot; escaping */\\n</code></pre>\\n\",\n\n\t\t\"``` c\\nno *inline* processing ~~of text~~\\n```\\n\",\n\t\t\"<pre><code class=\\\"language-c\\\">no *inline* processing ~~of text~~\\n</code></pre>\\n\",\n\n\t\t\"```\\nNo language\\n```\\n\",\n\t\t\"<pre><code>No language\\n</code></pre>\\n\",\n\n\t\t\"``` {ocaml}\\nlanguage in braces\\n```\\n\",\n\t\t\"<pre><code class=\\\"language-ocaml\\\">language in braces\\n</code></pre>\\n\",\n\n\t\t\"```    {ocaml}      \\nwith extra whitespace\\n```\\n\",\n\t\t\"<pre><code class=\\\"language-ocaml\\\">with extra whitespace\\n</code></pre>\\n\",\n\n\t\t\"```{   ocaml   }\\nwith extra whitespace\\n```\\n\",\n\t\t\"<pre><code class=\\\"language-ocaml\\\">with extra whitespace\\n</code></pre>\\n\",\n\n\t\t\"~ ~~ java\\nWith whitespace\\n~~~\\n\",\n\t\t\"<p>~ ~~ java\\nWith whitespace\\n~~~</p>\\n\",\n\n\t\t\"~~\\nonly two\\n~~\\n\",\n\t\t\"<p>~~\\nonly two\\n~~</p>\\n\",\n\n\t\t\"```` python\\nextra\\n````\\n\",\n\t\t\"<pre><code class=\\\"language-python\\\">extra\\n</code></pre>\\n\",\n\n\t\t\"~~~ perl\\nthree to start, four to end\\n~~~~\\n\",\n\t\t\"<p>~~~ perl\\nthree to start, four to end\\n~~~~</p>\\n\",\n\n\t\t\"~~~~ perl\\nfour to start, three to end\\n~~~\\n\",\n\t\t\"<p>~~~~ perl\\nfour to start, three to end\\n~~~</p>\\n\",\n\n\t\t\"~~~ bash\\ntildes\\n~~~\\n\",\n\t\t\"<pre><code class=\\\"language-bash\\\">tildes\\n</code></pre>\\n\",\n\n\t\t\"``` lisp\\nno ending\\n\",\n\t\t\"<p>``` lisp\\nno ending</p>\\n\",\n\n\t\t\"~~~ lisp\\nend with language\\n~~~ lisp\\n\",\n\t\t\"<pre><code class=\\\"language-lisp\\\">end with language\\n</code></pre>\\n\\n<p>lisp</p>\\n\",\n\n\t\t\"```\\nmismatched begin and end\\n~~~\\n\",\n\t\t\"<p>```\\nmismatched begin and end\\n~~~</p>\\n\",\n\n\t\t\"~~~\\nmismatched begin and end\\n```\\n\",\n\t\t\"<p>~~~\\nmismatched begin and end\\n```</p>\\n\",\n\n\t\t\"   ``` oz\\nleading spaces\\n```\\n\",\n\t\t\"<pre><code class=\\\"language-oz\\\">leading spaces\\n</code></pre>\\n\",\n\n\t\t\"  ``` oz\\nleading spaces\\n ```\\n\",\n\t\t\"<pre><code class=\\\"language-oz\\\">leading spaces\\n</code></pre>\\n\",\n\n\t\t\" ``` oz\\nleading spaces\\n  ```\\n\",\n\t\t\"<pre><code class=\\\"language-oz\\\">leading spaces\\n</code></pre>\\n\",\n\n\t\t\"``` oz\\nleading spaces\\n   ```\\n\",\n\t\t\"<pre><code class=\\\"language-oz\\\">leading spaces\\n</code></pre>\\n\",\n\n\t\t\"    ``` oz\\nleading spaces\\n    ```\\n\",\n\t\t\"<pre><code>``` oz\\n</code></pre>\\n\\n<p>leading spaces</p>\\n\\n<pre><code>```\\n</code></pre>\\n\",\n\t}\n\tdoTestsBlock(t, tests, EXTENSION_FENCED_CODE|EXTENSION_NO_EMPTY_LINE_BEFORE_BLOCK)\n}\n\nfunc TestListWithFencedCodeBlock(t *testing.T) {\n\tvar tests = []string{\n\t\t\"1. one\\n\\n    ```\\n    code\\n    ```\\n\\n2. two\\n\",\n\t\t\"<ol>\\n<li><p>one</p>\\n\\n<pre><code>code\\n</code></pre></li>\\n\\n<li><p>two</p></li>\\n</ol>\\n\",\n\t\t// https://github.com/russross/blackfriday/issues/239\n\t\t\"1. one\\n\\n    ```\\n    - code\\n    ```\\n\\n2. two\\n\",\n\t\t\"<ol>\\n<li><p>one</p>\\n\\n<pre><code>- code\\n</code></pre></li>\\n\\n<li><p>two</p></li>\\n</ol>\\n\",\n\t}\n\tdoTestsBlock(t, tests, EXTENSION_FENCED_CODE)\n}\n\nfunc TestListWithMalformedFencedCodeBlock(t *testing.T) {\n\t// Ensure that in the case of an unclosed fenced code block in a list,\n\t// no source gets ommitted (even if it is malformed).\n\t// See russross/blackfriday#372 for context.\n\tvar tests = []string{\n\t\t\"1. one\\n\\n    ```\\n    code\\n\\n2. two\\n\",\n\t\t\"<ol>\\n<li>one\\n\\n```\\ncode\\n\\n2. two</li>\\n</ol>\\n\",\n\n\t\t\"1. one\\n\\n    ```\\n    - code\\n\\n2. two\\n\",\n\t\t\"<ol>\\n<li>one\\n\\n```\\n- code\\n\\n2. two</li>\\n</ol>\\n\",\n\t}\n\tdoTestsBlock(t, tests, EXTENSION_FENCED_CODE)\n}\n\nfunc TestListWithFencedCodeBlockNoExtensions(t *testing.T) {\n\t// If there is a fenced code block in a list, and FencedCode is not set,\n\t// lists should be processed normally.\n\tvar tests = []string{\n\t\t\"1. one\\n\\n    ```\\n    code\\n    ```\\n\\n2. two\\n\",\n\t\t\"<ol>\\n<li><p>one</p>\\n\\n<p><code>\\ncode\\n</code></p></li>\\n\\n<li><p>two</p></li>\\n</ol>\\n\",\n\n\t\t\"1. one\\n\\n    ```\\n    - code\\n    ```\\n\\n2. two\\n\",\n\t\t\"<ol>\\n<li><p>one</p>\\n\\n<p>```</p>\\n\\n<ul>\\n<li>code\\n```</li>\\n</ul></li>\\n\\n<li><p>two</p></li>\\n</ol>\\n\",\n\t}\n\tdoTestsBlock(t, tests, 0)\n}\n\nfunc TestTitleBlock_EXTENSION_TITLEBLOCK(t *testing.T) {\n\tvar tests = []string{\n\t\t\"% Some title\\n\" +\n\t\t\t\"% Another title line\\n\" +\n\t\t\t\"% Yep, more here too\\n\",\n\t\t\"<h1 class=\\\"title\\\">\" +\n\t\t\t\"Some title\\n\" +\n\t\t\t\"Another title line\\n\" +\n\t\t\t\"Yep, more here too\\n\" +\n\t\t\t\"</h1>\",\n\t}\n\tdoTestsBlock(t, tests, EXTENSION_TITLEBLOCK)\n}\n\nfunc TestBlockComments(t *testing.T) {\n\tvar tests = []string{\n\t\t\"Some text\\n\\n<!-- comment -->\\n\",\n\t\t\"<p>Some text</p>\\n\\n<!-- comment -->\\n\",\n\n\t\t\"Some text\\n\\n<!--\\n\\nmultiline\\ncomment\\n-->\\n\",\n\t\t\"<p>Some text</p>\\n\\n<!--\\n\\nmultiline\\ncomment\\n-->\\n\",\n\n\t\t\"Some text\\n\\n<!--\\n\\n<div><p>Commented</p>\\n<span>html</span></div>\\n-->\\n\",\n\t\t\"<p>Some text</p>\\n\\n<!--\\n\\n<div><p>Commented</p>\\n<span>html</span></div>\\n-->\\n\",\n\t}\n\tdoTestsBlock(t, tests, 0)\n}\n\nfunc TestCDATA(t *testing.T) {\n\tvar tests = []string{\n\t\t\"Some text\\n\\n<![CDATA[foo]]>\\n\",\n\t\t\"<p>Some text</p>\\n\\n<![CDATA[foo]]>\\n\",\n\n\t\t\"CDATA ]]\\n\\n<![CDATA[]]]]>\\n\",\n\t\t\"<p>CDATA ]]</p>\\n\\n<![CDATA[]]]]>\\n\",\n\n\t\t\"CDATA >\\n\\n<![CDATA[>]]>\\n\",\n\t\t\"<p>CDATA &gt;</p>\\n\\n<![CDATA[>]]>\\n\",\n\n\t\t\"Lots of text\\n\\n<![CDATA[lots of te><t\\non\\nseveral\\nlines]]>\\n\",\n\t\t\"<p>Lots of text</p>\\n\\n<![CDATA[lots of te><t\\non\\nseveral\\nlines]]>\\n\",\n\n\t\t\"<![CDATA[>]]>\\n\",\n\t\t\"<![CDATA[>]]>\\n\",\n\t}\n\tdoTestsBlock(t, tests, 0)\n\tdoTestsBlock(t, []string{\n\t\t\"``` html\\n<![CDATA[foo]]>\\n```\\n\",\n\t\t\"<pre><code class=\\\"language-html\\\">&lt;![CDATA[foo]]&gt;\\n</code></pre>\\n\",\n\n\t\t\"<![CDATA[\\n``` python\\ndef func():\\n    pass\\n```\\n]]>\\n\",\n\t\t\"<![CDATA[\\n``` python\\ndef func():\\n    pass\\n```\\n]]>\\n\",\n\n\t\t`<![CDATA[\n> def func():\n>     pass\n]]>\n`,\n\t\t`<![CDATA[\n> def func():\n>     pass\n]]>\n`,\n\t}, EXTENSION_FENCED_CODE)\n}\n\nfunc TestIsFenceLine(t *testing.T) {\n\ttests := []struct {\n\t\tdata            []byte\n\t\tinfoRequested   bool\n\t\tnewlineOptional bool\n\t\twantEnd         int\n\t\twantMarker      string\n\t\twantInfo        string\n\t}{\n\t\t{\n\t\t\tdata:    []byte(\"```\"),\n\t\t\twantEnd: 0,\n\t\t},\n\t\t{\n\t\t\tdata:       []byte(\"```\\nstuff here\\n\"),\n\t\t\twantEnd:    4,\n\t\t\twantMarker: \"```\",\n\t\t},\n\t\t{\n\t\t\tdata:          []byte(\"```\\nstuff here\\n\"),\n\t\t\tinfoRequested: true,\n\t\t\twantEnd:       4,\n\t\t\twantMarker:    \"```\",\n\t\t},\n\t\t{\n\t\t\tdata:    []byte(\"stuff here\\n```\\n\"),\n\t\t\twantEnd: 0,\n\t\t},\n\t\t{\n\t\t\tdata:            []byte(\"```\"),\n\t\t\tnewlineOptional: true,\n\t\t\twantEnd:         3,\n\t\t\twantMarker:      \"```\",\n\t\t},\n\t\t{\n\t\t\tdata:            []byte(\"```\"),\n\t\t\tinfoRequested:   true,\n\t\t\tnewlineOptional: true,\n\t\t\twantEnd:         3,\n\t\t\twantMarker:      \"```\",\n\t\t},\n\t\t{\n\t\t\tdata:            []byte(\"``` go\"),\n\t\t\tinfoRequested:   true,\n\t\t\tnewlineOptional: true,\n\t\t\twantEnd:         6,\n\t\t\twantMarker:      \"```\",\n\t\t\twantInfo:        \"go\",\n\t\t},\n\t\t{\n\t\t\tdata:            []byte(\"``` go foo bar\"),\n\t\t\tinfoRequested:   true,\n\t\t\tnewlineOptional: true,\n\t\t\twantEnd:         14,\n\t\t\twantMarker:      \"```\",\n\t\t\twantInfo:        \"go foo bar\",\n\t\t},\n\t\t{\n\t\t\tdata:            []byte(\"``` go foo bar  \"),\n\t\t\tinfoRequested:   true,\n\t\t\tnewlineOptional: true,\n\t\t\twantEnd:         16,\n\t\t\twantMarker:      \"```\",\n\t\t\twantInfo:        \"go foo bar\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tvar info *string\n\t\tif test.infoRequested {\n\t\t\tinfo = new(string)\n\t\t}\n\t\tend, marker := isFenceLine(test.data, info, \"```\", test.newlineOptional)\n\t\tif got, want := end, test.wantEnd; got != want {\n\t\t\tt.Errorf(\"got end %v, want %v\", got, want)\n\t\t}\n\t\tif got, want := marker, test.wantMarker; got != want {\n\t\t\tt.Errorf(\"got marker %q, want %q\", got, want)\n\t\t}\n\t\tif test.infoRequested {\n\t\t\tif got, want := *info, test.wantInfo; got != want {\n\t\t\t\tt.Errorf(\"got info %q, want %q\", got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestJoinLines(t *testing.T) {\n\tinput := `# 标题\n\n第一\n行文字。\n\n第\n二\n行文字。\n`\n\tresult := `<h1>标题</h1>\n\n<p>第一行文字。</p>\n\n<p>第二行文字。</p>\n`\n\topt := Options{Extensions: commonExtensions | EXTENSION_JOIN_LINES}\n\trenderer := HtmlRenderer(commonHtmlFlags, \"\", \"\")\n\toutput := MarkdownOptions([]byte(input), renderer, opt)\n\n\tif string(output) != result {\n\t\tt.Error(\"output dose not match.\")\n\t}\n}\n\nfunc TestSanitizedAnchorName(t *testing.T) {\n\ttests := []struct {\n\t\ttext string\n\t\twant string\n\t}{\n\t\t{\n\t\t\ttext: \"This is a header\",\n\t\t\twant: \"this-is-a-header\",\n\t\t},\n\t\t{\n\t\t\ttext: \"This is also          a header\",\n\t\t\twant: \"this-is-also-a-header\",\n\t\t},\n\t\t{\n\t\t\ttext: \"main.go\",\n\t\t\twant: \"main-go\",\n\t\t},\n\t\t{\n\t\t\ttext: \"Article 123\",\n\t\t\twant: \"article-123\",\n\t\t},\n\t\t{\n\t\t\ttext: \"<- Let's try this, shall we?\",\n\t\t\twant: \"let-s-try-this-shall-we\",\n\t\t},\n\t\t{\n\t\t\ttext: \"        \",\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\ttext: \"Hello, 世界\",\n\t\t\twant: \"hello-世界\",\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tif got := SanitizedAnchorName(test.text); got != test.want {\n\t\t\tt.Errorf(\"SanitizedAnchorName(%q):\\ngot %q\\nwant %q\", test.text, got, test.want)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 1.7177734375,
          "content": "// Package blackfriday is a Markdown processor.\n//\n// It translates plain text with simple formatting rules into HTML or LaTeX.\n//\n// Sanitized Anchor Names\n//\n// Blackfriday includes an algorithm for creating sanitized anchor names\n// corresponding to a given input text. This algorithm is used to create\n// anchors for headings when EXTENSION_AUTO_HEADER_IDS is enabled. The\n// algorithm is specified below, so that other packages can create\n// compatible anchor names and links to those anchors.\n//\n// The algorithm iterates over the input text, interpreted as UTF-8,\n// one Unicode code point (rune) at a time. All runes that are letters (category L)\n// or numbers (category N) are considered valid characters. They are mapped to\n// lower case, and included in the output. All other runes are considered\n// invalid characters. Invalid characters that preceed the first valid character,\n// as well as invalid character that follow the last valid character\n// are dropped completely. All other sequences of invalid characters\n// between two valid characters are replaced with a single dash character '-'.\n//\n// SanitizedAnchorName exposes this functionality, and can be used to\n// create compatible links to the anchor names generated by blackfriday.\n// This algorithm is also implemented in a small standalone package at\n// github.com/shurcooL/sanitized_anchor_name. It can be useful for clients\n// that want a small package and don't need full functionality of blackfriday.\npackage blackfriday\n\n// NOTE: Keep Sanitized Anchor Name algorithm in sync with package\n//       github.com/shurcooL/sanitized_anchor_name.\n//       Otherwise, users of sanitized_anchor_name will get anchor names\n//       that are incompatible with those generated by blackfriday.\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.046875,
          "content": "module github.com/russross/blackfriday\n\ngo 1.13\n"
        },
        {
          "name": "html.go",
          "type": "blob",
          "size": 23.7978515625,
          "content": "//\n// Blackfriday Markdown Processor\n// Available at http://github.com/russross/blackfriday\n//\n// Copyright © 2011 Russ Ross <russ@russross.com>.\n// Distributed under the Simplified BSD License.\n// See README.md for details.\n//\n\n//\n//\n// HTML rendering backend\n//\n//\n\npackage blackfriday\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Html renderer configuration options.\nconst (\n\tHTML_SKIP_HTML                 = 1 << iota // skip preformatted HTML blocks\n\tHTML_SKIP_STYLE                            // skip embedded <style> elements\n\tHTML_SKIP_IMAGES                           // skip embedded images\n\tHTML_SKIP_LINKS                            // skip all links\n\tHTML_SAFELINK                              // only link to trusted protocols\n\tHTML_NOFOLLOW_LINKS                        // only link with rel=\"nofollow\"\n\tHTML_NOREFERRER_LINKS                      // only link with rel=\"noreferrer\"\n\tHTML_NOOPENER_LINKS                        // only link with rel=\"noopener\"\n\tHTML_HREF_TARGET_BLANK                     // add a blank target\n\tHTML_TOC                                   // generate a table of contents\n\tHTML_OMIT_CONTENTS                         // skip the main contents (for a standalone table of contents)\n\tHTML_COMPLETE_PAGE                         // generate a complete HTML page\n\tHTML_USE_XHTML                             // generate XHTML output instead of HTML\n\tHTML_USE_SMARTYPANTS                       // enable smart punctuation substitutions\n\tHTML_SMARTYPANTS_FRACTIONS                 // enable smart fractions (with HTML_USE_SMARTYPANTS)\n\tHTML_SMARTYPANTS_DASHES                    // enable smart dashes (with HTML_USE_SMARTYPANTS)\n\tHTML_SMARTYPANTS_LATEX_DASHES              // enable LaTeX-style dashes (with HTML_USE_SMARTYPANTS and HTML_SMARTYPANTS_DASHES)\n\tHTML_SMARTYPANTS_ANGLED_QUOTES             // enable angled double quotes (with HTML_USE_SMARTYPANTS) for double quotes rendering\n\tHTML_SMARTYPANTS_QUOTES_NBSP               // enable \"French guillemets\" (with HTML_USE_SMARTYPANTS)\n\tHTML_FOOTNOTE_RETURN_LINKS                 // generate a link at the end of a footnote to return to the source\n)\n\nvar (\n\talignments = []string{\n\t\t\"left\",\n\t\t\"right\",\n\t\t\"center\",\n\t}\n\n\t// TODO: improve this regexp to catch all possible entities:\n\thtmlEntity = regexp.MustCompile(`&[a-z]{2,5};`)\n)\n\ntype HtmlRendererParameters struct {\n\t// Prepend this text to each relative URL.\n\tAbsolutePrefix string\n\t// Add this text to each footnote anchor, to ensure uniqueness.\n\tFootnoteAnchorPrefix string\n\t// Show this text inside the <a> tag for a footnote return link, if the\n\t// HTML_FOOTNOTE_RETURN_LINKS flag is enabled. If blank, the string\n\t// <sup>[return]</sup> is used.\n\tFootnoteReturnLinkContents string\n\t// If set, add this text to the front of each Header ID, to ensure\n\t// uniqueness.\n\tHeaderIDPrefix string\n\t// If set, add this text to the back of each Header ID, to ensure uniqueness.\n\tHeaderIDSuffix string\n}\n\n// Html is a type that implements the Renderer interface for HTML output.\n//\n// Do not create this directly, instead use the HtmlRenderer function.\ntype Html struct {\n\tflags    int    // HTML_* options\n\tcloseTag string // how to end singleton tags: either \" />\" or \">\"\n\ttitle    string // document title\n\tcss      string // optional css file url (used with HTML_COMPLETE_PAGE)\n\n\tparameters HtmlRendererParameters\n\n\t// table of contents data\n\ttocMarker    int\n\theaderCount  int\n\tcurrentLevel int\n\ttoc          *bytes.Buffer\n\n\t// Track header IDs to prevent ID collision in a single generation.\n\theaderIDs map[string]int\n\n\tsmartypants *smartypantsRenderer\n}\n\nconst (\n\txhtmlClose = \" />\"\n\thtmlClose  = \">\"\n)\n\n// HtmlRenderer creates and configures an Html object, which\n// satisfies the Renderer interface.\n//\n// flags is a set of HTML_* options ORed together.\n// title is the title of the document, and css is a URL for the document's\n// stylesheet.\n// title and css are only used when HTML_COMPLETE_PAGE is selected.\nfunc HtmlRenderer(flags int, title string, css string) Renderer {\n\treturn HtmlRendererWithParameters(flags, title, css, HtmlRendererParameters{})\n}\n\nfunc HtmlRendererWithParameters(flags int, title string,\n\tcss string, renderParameters HtmlRendererParameters) Renderer {\n\t// configure the rendering engine\n\tcloseTag := htmlClose\n\tif flags&HTML_USE_XHTML != 0 {\n\t\tcloseTag = xhtmlClose\n\t}\n\n\tif renderParameters.FootnoteReturnLinkContents == \"\" {\n\t\trenderParameters.FootnoteReturnLinkContents = `<sup>[return]</sup>`\n\t}\n\n\treturn &Html{\n\t\tflags:      flags,\n\t\tcloseTag:   closeTag,\n\t\ttitle:      title,\n\t\tcss:        css,\n\t\tparameters: renderParameters,\n\n\t\theaderCount:  0,\n\t\tcurrentLevel: 0,\n\t\ttoc:          new(bytes.Buffer),\n\n\t\theaderIDs: make(map[string]int),\n\n\t\tsmartypants: smartypants(flags),\n\t}\n}\n\n// Using if statements is a bit faster than a switch statement. As the compiler\n// improves, this should be unnecessary this is only worthwhile because\n// attrEscape is the single largest CPU user in normal use.\n// Also tried using map, but that gave a ~3x slowdown.\nfunc escapeSingleChar(char byte) (string, bool) {\n\tif char == '\"' {\n\t\treturn \"&quot;\", true\n\t}\n\tif char == '&' {\n\t\treturn \"&amp;\", true\n\t}\n\tif char == '<' {\n\t\treturn \"&lt;\", true\n\t}\n\tif char == '>' {\n\t\treturn \"&gt;\", true\n\t}\n\treturn \"\", false\n}\n\nfunc attrEscape(out *bytes.Buffer, src []byte) {\n\torg := 0\n\tfor i, ch := range src {\n\t\tif entity, ok := escapeSingleChar(ch); ok {\n\t\t\tif i > org {\n\t\t\t\t// copy all the normal characters since the last escape\n\t\t\t\tout.Write(src[org:i])\n\t\t\t}\n\t\t\torg = i + 1\n\t\t\tout.WriteString(entity)\n\t\t}\n\t}\n\tif org < len(src) {\n\t\tout.Write(src[org:])\n\t}\n}\n\nfunc entityEscapeWithSkip(out *bytes.Buffer, src []byte, skipRanges [][]int) {\n\tend := 0\n\tfor _, rang := range skipRanges {\n\t\tattrEscape(out, src[end:rang[0]])\n\t\tout.Write(src[rang[0]:rang[1]])\n\t\tend = rang[1]\n\t}\n\tattrEscape(out, src[end:])\n}\n\nfunc (options *Html) GetFlags() int {\n\treturn options.flags\n}\n\nfunc (options *Html) TitleBlock(out *bytes.Buffer, text []byte) {\n\ttext = bytes.TrimPrefix(text, []byte(\"% \"))\n\ttext = bytes.Replace(text, []byte(\"\\n% \"), []byte(\"\\n\"), -1)\n\tout.WriteString(\"<h1 class=\\\"title\\\">\")\n\tout.Write(text)\n\tout.WriteString(\"\\n</h1>\")\n}\n\nfunc (options *Html) Header(out *bytes.Buffer, text func() bool, level int, id string) {\n\tmarker := out.Len()\n\tdoubleSpace(out)\n\n\tif id == \"\" && options.flags&HTML_TOC != 0 {\n\t\tid = fmt.Sprintf(\"toc_%d\", options.headerCount)\n\t}\n\n\tif id != \"\" {\n\t\tid = options.ensureUniqueHeaderID(id)\n\n\t\tif options.parameters.HeaderIDPrefix != \"\" {\n\t\t\tid = options.parameters.HeaderIDPrefix + id\n\t\t}\n\n\t\tif options.parameters.HeaderIDSuffix != \"\" {\n\t\t\tid = id + options.parameters.HeaderIDSuffix\n\t\t}\n\n\t\tout.WriteString(fmt.Sprintf(\"<h%d id=\\\"%s\\\">\", level, id))\n\t} else {\n\t\tout.WriteString(fmt.Sprintf(\"<h%d>\", level))\n\t}\n\n\ttocMarker := out.Len()\n\tif !text() {\n\t\tout.Truncate(marker)\n\t\treturn\n\t}\n\n\t// are we building a table of contents?\n\tif options.flags&HTML_TOC != 0 {\n\t\toptions.TocHeaderWithAnchor(out.Bytes()[tocMarker:], level, id)\n\t}\n\n\tout.WriteString(fmt.Sprintf(\"</h%d>\\n\", level))\n}\n\nfunc (options *Html) BlockHtml(out *bytes.Buffer, text []byte) {\n\tif options.flags&HTML_SKIP_HTML != 0 {\n\t\treturn\n\t}\n\n\tdoubleSpace(out)\n\tout.Write(text)\n\tout.WriteByte('\\n')\n}\n\nfunc (options *Html) HRule(out *bytes.Buffer) {\n\tdoubleSpace(out)\n\tout.WriteString(\"<hr\")\n\tout.WriteString(options.closeTag)\n\tout.WriteByte('\\n')\n}\n\nfunc (options *Html) BlockCode(out *bytes.Buffer, text []byte, info string) {\n\tdoubleSpace(out)\n\n\tendOfLang := strings.IndexAny(info, \"\\t \")\n\tif endOfLang < 0 {\n\t\tendOfLang = len(info)\n\t}\n\tlang := info[:endOfLang]\n\tif len(lang) == 0 || lang == \".\" {\n\t\tout.WriteString(\"<pre><code>\")\n\t} else {\n\t\tout.WriteString(\"<pre><code class=\\\"language-\")\n\t\tattrEscape(out, []byte(lang))\n\t\tout.WriteString(\"\\\">\")\n\t}\n\tattrEscape(out, text)\n\tout.WriteString(\"</code></pre>\\n\")\n}\n\nfunc (options *Html) BlockQuote(out *bytes.Buffer, text []byte) {\n\tdoubleSpace(out)\n\tout.WriteString(\"<blockquote>\\n\")\n\tout.Write(text)\n\tout.WriteString(\"</blockquote>\\n\")\n}\n\nfunc (options *Html) Table(out *bytes.Buffer, header []byte, body []byte, columnData []int) {\n\tdoubleSpace(out)\n\tout.WriteString(\"<table>\\n<thead>\\n\")\n\tout.Write(header)\n\tout.WriteString(\"</thead>\\n\\n<tbody>\\n\")\n\tout.Write(body)\n\tout.WriteString(\"</tbody>\\n</table>\\n\")\n}\n\nfunc (options *Html) TableRow(out *bytes.Buffer, text []byte) {\n\tdoubleSpace(out)\n\tout.WriteString(\"<tr>\\n\")\n\tout.Write(text)\n\tout.WriteString(\"\\n</tr>\\n\")\n}\n\nfunc (options *Html) TableHeaderCell(out *bytes.Buffer, text []byte, align int) {\n\tdoubleSpace(out)\n\tswitch align {\n\tcase TABLE_ALIGNMENT_LEFT:\n\t\tout.WriteString(\"<th align=\\\"left\\\">\")\n\tcase TABLE_ALIGNMENT_RIGHT:\n\t\tout.WriteString(\"<th align=\\\"right\\\">\")\n\tcase TABLE_ALIGNMENT_CENTER:\n\t\tout.WriteString(\"<th align=\\\"center\\\">\")\n\tdefault:\n\t\tout.WriteString(\"<th>\")\n\t}\n\n\tout.Write(text)\n\tout.WriteString(\"</th>\")\n}\n\nfunc (options *Html) TableCell(out *bytes.Buffer, text []byte, align int) {\n\tdoubleSpace(out)\n\tswitch align {\n\tcase TABLE_ALIGNMENT_LEFT:\n\t\tout.WriteString(\"<td align=\\\"left\\\">\")\n\tcase TABLE_ALIGNMENT_RIGHT:\n\t\tout.WriteString(\"<td align=\\\"right\\\">\")\n\tcase TABLE_ALIGNMENT_CENTER:\n\t\tout.WriteString(\"<td align=\\\"center\\\">\")\n\tdefault:\n\t\tout.WriteString(\"<td>\")\n\t}\n\n\tout.Write(text)\n\tout.WriteString(\"</td>\")\n}\n\nfunc (options *Html) Footnotes(out *bytes.Buffer, text func() bool) {\n\tout.WriteString(\"<div class=\\\"footnotes\\\">\\n\")\n\toptions.HRule(out)\n\toptions.List(out, text, LIST_TYPE_ORDERED)\n\tout.WriteString(\"</div>\\n\")\n}\n\nfunc (options *Html) FootnoteItem(out *bytes.Buffer, name, text []byte, flags int) {\n\tif flags&LIST_ITEM_CONTAINS_BLOCK != 0 || flags&LIST_ITEM_BEGINNING_OF_LIST != 0 {\n\t\tdoubleSpace(out)\n\t}\n\tslug := slugify(name)\n\tout.WriteString(`<li id=\"`)\n\tout.WriteString(`fn:`)\n\tout.WriteString(options.parameters.FootnoteAnchorPrefix)\n\tout.Write(slug)\n\tout.WriteString(`\">`)\n\tout.Write(text)\n\tif options.flags&HTML_FOOTNOTE_RETURN_LINKS != 0 {\n\t\tout.WriteString(` <a class=\"footnote-return\" href=\"#`)\n\t\tout.WriteString(`fnref:`)\n\t\tout.WriteString(options.parameters.FootnoteAnchorPrefix)\n\t\tout.Write(slug)\n\t\tout.WriteString(`\">`)\n\t\tout.WriteString(options.parameters.FootnoteReturnLinkContents)\n\t\tout.WriteString(`</a>`)\n\t}\n\tout.WriteString(\"</li>\\n\")\n}\n\nfunc (options *Html) List(out *bytes.Buffer, text func() bool, flags int) {\n\tmarker := out.Len()\n\tdoubleSpace(out)\n\n\tif flags&LIST_TYPE_DEFINITION != 0 {\n\t\tout.WriteString(\"<dl>\")\n\t} else if flags&LIST_TYPE_ORDERED != 0 {\n\t\tout.WriteString(\"<ol>\")\n\t} else {\n\t\tout.WriteString(\"<ul>\")\n\t}\n\tif !text() {\n\t\tout.Truncate(marker)\n\t\treturn\n\t}\n\tif flags&LIST_TYPE_DEFINITION != 0 {\n\t\tout.WriteString(\"</dl>\\n\")\n\t} else if flags&LIST_TYPE_ORDERED != 0 {\n\t\tout.WriteString(\"</ol>\\n\")\n\t} else {\n\t\tout.WriteString(\"</ul>\\n\")\n\t}\n}\n\nfunc (options *Html) ListItem(out *bytes.Buffer, text []byte, flags int) {\n\tif (flags&LIST_ITEM_CONTAINS_BLOCK != 0 && flags&LIST_TYPE_DEFINITION == 0) ||\n\t\tflags&LIST_ITEM_BEGINNING_OF_LIST != 0 {\n\t\tdoubleSpace(out)\n\t}\n\tif flags&LIST_TYPE_TERM != 0 {\n\t\tout.WriteString(\"<dt>\")\n\t} else if flags&LIST_TYPE_DEFINITION != 0 {\n\t\tout.WriteString(\"<dd>\")\n\t} else {\n\t\tout.WriteString(\"<li>\")\n\t}\n\tout.Write(text)\n\tif flags&LIST_TYPE_TERM != 0 {\n\t\tout.WriteString(\"</dt>\\n\")\n\t} else if flags&LIST_TYPE_DEFINITION != 0 {\n\t\tout.WriteString(\"</dd>\\n\")\n\t} else {\n\t\tout.WriteString(\"</li>\\n\")\n\t}\n}\n\nfunc (options *Html) Paragraph(out *bytes.Buffer, text func() bool) {\n\tmarker := out.Len()\n\tdoubleSpace(out)\n\n\tout.WriteString(\"<p>\")\n\tif !text() {\n\t\tout.Truncate(marker)\n\t\treturn\n\t}\n\tout.WriteString(\"</p>\\n\")\n}\n\nfunc (options *Html) AutoLink(out *bytes.Buffer, link []byte, kind int) {\n\tskipRanges := htmlEntity.FindAllIndex(link, -1)\n\tif options.flags&HTML_SAFELINK != 0 && !isSafeLink(link) && kind != LINK_TYPE_EMAIL {\n\t\t// mark it but don't link it if it is not a safe link: no smartypants\n\t\tout.WriteString(\"<tt>\")\n\t\tentityEscapeWithSkip(out, link, skipRanges)\n\t\tout.WriteString(\"</tt>\")\n\t\treturn\n\t}\n\n\tout.WriteString(\"<a href=\\\"\")\n\tif kind == LINK_TYPE_EMAIL {\n\t\tout.WriteString(\"mailto:\")\n\t} else {\n\t\toptions.maybeWriteAbsolutePrefix(out, link)\n\t}\n\n\tentityEscapeWithSkip(out, link, skipRanges)\n\n\tvar relAttrs []string\n\tif options.flags&HTML_NOFOLLOW_LINKS != 0 && !isRelativeLink(link) {\n\t\trelAttrs = append(relAttrs, \"nofollow\")\n\t}\n\tif options.flags&HTML_NOREFERRER_LINKS != 0 && !isRelativeLink(link) {\n\t\trelAttrs = append(relAttrs, \"noreferrer\")\n\t}\n\tif options.flags&HTML_NOOPENER_LINKS != 0 && !isRelativeLink(link) {\n\t\trelAttrs = append(relAttrs, \"noopener\")\n\t}\n\tif len(relAttrs) > 0 {\n\t\tout.WriteString(fmt.Sprintf(\"\\\" rel=\\\"%s\", strings.Join(relAttrs, \" \")))\n\t}\n\n\t// blank target only add to external link\n\tif options.flags&HTML_HREF_TARGET_BLANK != 0 && !isRelativeLink(link) {\n\t\tout.WriteString(\"\\\" target=\\\"_blank\")\n\t}\n\n\tout.WriteString(\"\\\">\")\n\n\t// Pretty print: if we get an email address as\n\t// an actual URI, e.g. `mailto:foo@bar.com`, we don't\n\t// want to print the `mailto:` prefix\n\tswitch {\n\tcase bytes.HasPrefix(link, []byte(\"mailto://\")):\n\t\tattrEscape(out, link[len(\"mailto://\"):])\n\tcase bytes.HasPrefix(link, []byte(\"mailto:\")):\n\t\tattrEscape(out, link[len(\"mailto:\"):])\n\tdefault:\n\t\tentityEscapeWithSkip(out, link, skipRanges)\n\t}\n\n\tout.WriteString(\"</a>\")\n}\n\nfunc (options *Html) CodeSpan(out *bytes.Buffer, text []byte) {\n\tout.WriteString(\"<code>\")\n\tattrEscape(out, text)\n\tout.WriteString(\"</code>\")\n}\n\nfunc (options *Html) DoubleEmphasis(out *bytes.Buffer, text []byte) {\n\tout.WriteString(\"<strong>\")\n\tout.Write(text)\n\tout.WriteString(\"</strong>\")\n}\n\nfunc (options *Html) Emphasis(out *bytes.Buffer, text []byte) {\n\tif len(text) == 0 {\n\t\treturn\n\t}\n\tout.WriteString(\"<em>\")\n\tout.Write(text)\n\tout.WriteString(\"</em>\")\n}\n\nfunc (options *Html) maybeWriteAbsolutePrefix(out *bytes.Buffer, link []byte) {\n\tif options.parameters.AbsolutePrefix != \"\" && isRelativeLink(link) && link[0] != '.' {\n\t\tout.WriteString(options.parameters.AbsolutePrefix)\n\t\tif link[0] != '/' {\n\t\t\tout.WriteByte('/')\n\t\t}\n\t}\n}\n\nfunc (options *Html) Image(out *bytes.Buffer, link []byte, title []byte, alt []byte) {\n\tif options.flags&HTML_SKIP_IMAGES != 0 {\n\t\treturn\n\t}\n\n\tout.WriteString(\"<img src=\\\"\")\n\toptions.maybeWriteAbsolutePrefix(out, link)\n\tattrEscape(out, link)\n\tout.WriteString(\"\\\" alt=\\\"\")\n\tif len(alt) > 0 {\n\t\tattrEscape(out, alt)\n\t}\n\tif len(title) > 0 {\n\t\tout.WriteString(\"\\\" title=\\\"\")\n\t\tattrEscape(out, title)\n\t}\n\n\tout.WriteByte('\"')\n\tout.WriteString(options.closeTag)\n}\n\nfunc (options *Html) LineBreak(out *bytes.Buffer) {\n\tout.WriteString(\"<br\")\n\tout.WriteString(options.closeTag)\n\tout.WriteByte('\\n')\n}\n\nfunc (options *Html) Link(out *bytes.Buffer, link []byte, title []byte, content []byte) {\n\tif options.flags&HTML_SKIP_LINKS != 0 {\n\t\t// write the link text out but don't link it, just mark it with typewriter font\n\t\tout.WriteString(\"<tt>\")\n\t\tattrEscape(out, content)\n\t\tout.WriteString(\"</tt>\")\n\t\treturn\n\t}\n\n\tif options.flags&HTML_SAFELINK != 0 && !isSafeLink(link) {\n\t\t// write the link text out but don't link it, just mark it with typewriter font\n\t\tout.WriteString(\"<tt>\")\n\t\tattrEscape(out, content)\n\t\tout.WriteString(\"</tt>\")\n\t\treturn\n\t}\n\n\tout.WriteString(\"<a href=\\\"\")\n\toptions.maybeWriteAbsolutePrefix(out, link)\n\tattrEscape(out, link)\n\tif len(title) > 0 {\n\t\tout.WriteString(\"\\\" title=\\\"\")\n\t\tattrEscape(out, title)\n\t}\n\tvar relAttrs []string\n\tif options.flags&HTML_NOFOLLOW_LINKS != 0 && !isRelativeLink(link) {\n\t\trelAttrs = append(relAttrs, \"nofollow\")\n\t}\n\tif options.flags&HTML_NOREFERRER_LINKS != 0 && !isRelativeLink(link) {\n\t\trelAttrs = append(relAttrs, \"noreferrer\")\n\t}\n\tif options.flags&HTML_NOOPENER_LINKS != 0 && !isRelativeLink(link) {\n\t\trelAttrs = append(relAttrs, \"noopener\")\n\t}\n\tif len(relAttrs) > 0 {\n\t\tout.WriteString(fmt.Sprintf(\"\\\" rel=\\\"%s\", strings.Join(relAttrs, \" \")))\n\t}\n\n\t// blank target only add to external link\n\tif options.flags&HTML_HREF_TARGET_BLANK != 0 && !isRelativeLink(link) {\n\t\tout.WriteString(\"\\\" target=\\\"_blank\")\n\t}\n\n\tout.WriteString(\"\\\">\")\n\tout.Write(content)\n\tout.WriteString(\"</a>\")\n\treturn\n}\n\nfunc (options *Html) RawHtmlTag(out *bytes.Buffer, text []byte) {\n\tif options.flags&HTML_SKIP_HTML != 0 {\n\t\treturn\n\t}\n\tif options.flags&HTML_SKIP_STYLE != 0 && isHtmlTag(text, \"style\") {\n\t\treturn\n\t}\n\tif options.flags&HTML_SKIP_LINKS != 0 && isHtmlTag(text, \"a\") {\n\t\treturn\n\t}\n\tif options.flags&HTML_SKIP_IMAGES != 0 && isHtmlTag(text, \"img\") {\n\t\treturn\n\t}\n\tout.Write(text)\n}\n\nfunc (options *Html) TripleEmphasis(out *bytes.Buffer, text []byte) {\n\tout.WriteString(\"<strong><em>\")\n\tout.Write(text)\n\tout.WriteString(\"</em></strong>\")\n}\n\nfunc (options *Html) StrikeThrough(out *bytes.Buffer, text []byte) {\n\tout.WriteString(\"<del>\")\n\tout.Write(text)\n\tout.WriteString(\"</del>\")\n}\n\nfunc (options *Html) FootnoteRef(out *bytes.Buffer, ref []byte, id int) {\n\tslug := slugify(ref)\n\tout.WriteString(`<sup class=\"footnote-ref\" id=\"`)\n\tout.WriteString(`fnref:`)\n\tout.WriteString(options.parameters.FootnoteAnchorPrefix)\n\tout.Write(slug)\n\tout.WriteString(`\"><a href=\"#`)\n\tout.WriteString(`fn:`)\n\tout.WriteString(options.parameters.FootnoteAnchorPrefix)\n\tout.Write(slug)\n\tout.WriteString(`\">`)\n\tout.WriteString(strconv.Itoa(id))\n\tout.WriteString(`</a></sup>`)\n}\n\nfunc (options *Html) Entity(out *bytes.Buffer, entity []byte) {\n\tout.Write(entity)\n}\n\nfunc (options *Html) NormalText(out *bytes.Buffer, text []byte) {\n\tif options.flags&HTML_USE_SMARTYPANTS != 0 {\n\t\toptions.Smartypants(out, text)\n\t} else {\n\t\tattrEscape(out, text)\n\t}\n}\n\nfunc (options *Html) Smartypants(out *bytes.Buffer, text []byte) {\n\tsmrt := smartypantsData{false, false}\n\n\t// first do normal entity escaping\n\tvar escaped bytes.Buffer\n\tattrEscape(&escaped, text)\n\ttext = escaped.Bytes()\n\n\tmark := 0\n\tfor i := 0; i < len(text); i++ {\n\t\tif action := options.smartypants[text[i]]; action != nil {\n\t\t\tif i > mark {\n\t\t\t\tout.Write(text[mark:i])\n\t\t\t}\n\n\t\t\tpreviousChar := byte(0)\n\t\t\tif i > 0 {\n\t\t\t\tpreviousChar = text[i-1]\n\t\t\t}\n\t\t\ti += action(out, &smrt, previousChar, text[i:])\n\t\t\tmark = i + 1\n\t\t}\n\t}\n\n\tif mark < len(text) {\n\t\tout.Write(text[mark:])\n\t}\n}\n\nfunc (options *Html) DocumentHeader(out *bytes.Buffer) {\n\tif options.flags&HTML_COMPLETE_PAGE == 0 {\n\t\treturn\n\t}\n\n\tending := \"\"\n\tif options.flags&HTML_USE_XHTML != 0 {\n\t\tout.WriteString(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \")\n\t\tout.WriteString(\"\\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\\n\")\n\t\tout.WriteString(\"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\\n\")\n\t\tending = \" /\"\n\t} else {\n\t\tout.WriteString(\"<!DOCTYPE html>\\n\")\n\t\tout.WriteString(\"<html>\\n\")\n\t}\n\tout.WriteString(\"<head>\\n\")\n\tout.WriteString(\"  <title>\")\n\toptions.NormalText(out, []byte(options.title))\n\tout.WriteString(\"</title>\\n\")\n\tout.WriteString(\"  <meta name=\\\"GENERATOR\\\" content=\\\"Blackfriday Markdown Processor v\")\n\tout.WriteString(VERSION)\n\tout.WriteString(\"\\\"\")\n\tout.WriteString(ending)\n\tout.WriteString(\">\\n\")\n\tout.WriteString(\"  <meta charset=\\\"utf-8\\\"\")\n\tout.WriteString(ending)\n\tout.WriteString(\">\\n\")\n\tif options.css != \"\" {\n\t\tout.WriteString(\"  <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"\")\n\t\tattrEscape(out, []byte(options.css))\n\t\tout.WriteString(\"\\\"\")\n\t\tout.WriteString(ending)\n\t\tout.WriteString(\">\\n\")\n\t}\n\tout.WriteString(\"</head>\\n\")\n\tout.WriteString(\"<body>\\n\")\n\n\toptions.tocMarker = out.Len()\n}\n\nfunc (options *Html) DocumentFooter(out *bytes.Buffer) {\n\t// finalize and insert the table of contents\n\tif options.flags&HTML_TOC != 0 {\n\t\toptions.TocFinalize()\n\n\t\t// now we have to insert the table of contents into the document\n\t\tvar temp bytes.Buffer\n\n\t\t// start by making a copy of everything after the document header\n\t\ttemp.Write(out.Bytes()[options.tocMarker:])\n\n\t\t// now clear the copied material from the main output buffer\n\t\tout.Truncate(options.tocMarker)\n\n\t\t// corner case spacing issue\n\t\tif options.flags&HTML_COMPLETE_PAGE != 0 {\n\t\t\tout.WriteByte('\\n')\n\t\t}\n\n\t\t// insert the table of contents\n\t\tout.WriteString(\"<nav>\\n\")\n\t\tout.Write(options.toc.Bytes())\n\t\tout.WriteString(\"</nav>\\n\")\n\n\t\t// corner case spacing issue\n\t\tif options.flags&HTML_COMPLETE_PAGE == 0 && options.flags&HTML_OMIT_CONTENTS == 0 {\n\t\t\tout.WriteByte('\\n')\n\t\t}\n\n\t\t// write out everything that came after it\n\t\tif options.flags&HTML_OMIT_CONTENTS == 0 {\n\t\t\tout.Write(temp.Bytes())\n\t\t}\n\t}\n\n\tif options.flags&HTML_COMPLETE_PAGE != 0 {\n\t\tout.WriteString(\"\\n</body>\\n\")\n\t\tout.WriteString(\"</html>\\n\")\n\t}\n\n}\n\nfunc (options *Html) TocHeaderWithAnchor(text []byte, level int, anchor string) {\n\tfor level > options.currentLevel {\n\t\tswitch {\n\t\tcase bytes.HasSuffix(options.toc.Bytes(), []byte(\"</li>\\n\")):\n\t\t\t// this sublist can nest underneath a header\n\t\t\tsize := options.toc.Len()\n\t\t\toptions.toc.Truncate(size - len(\"</li>\\n\"))\n\n\t\tcase options.currentLevel > 0:\n\t\t\toptions.toc.WriteString(\"<li>\")\n\t\t}\n\t\tif options.toc.Len() > 0 {\n\t\t\toptions.toc.WriteByte('\\n')\n\t\t}\n\t\toptions.toc.WriteString(\"<ul>\\n\")\n\t\toptions.currentLevel++\n\t}\n\n\tfor level < options.currentLevel {\n\t\toptions.toc.WriteString(\"</ul>\")\n\t\tif options.currentLevel > 1 {\n\t\t\toptions.toc.WriteString(\"</li>\\n\")\n\t\t}\n\t\toptions.currentLevel--\n\t}\n\n\toptions.toc.WriteString(\"<li><a href=\\\"#\")\n\tif anchor != \"\" {\n\t\toptions.toc.WriteString(anchor)\n\t} else {\n\t\toptions.toc.WriteString(\"toc_\")\n\t\toptions.toc.WriteString(strconv.Itoa(options.headerCount))\n\t}\n\toptions.toc.WriteString(\"\\\">\")\n\toptions.headerCount++\n\n\toptions.toc.Write(text)\n\n\toptions.toc.WriteString(\"</a></li>\\n\")\n}\n\nfunc (options *Html) TocHeader(text []byte, level int) {\n\toptions.TocHeaderWithAnchor(text, level, \"\")\n}\n\nfunc (options *Html) TocFinalize() {\n\tfor options.currentLevel > 1 {\n\t\toptions.toc.WriteString(\"</ul></li>\\n\")\n\t\toptions.currentLevel--\n\t}\n\n\tif options.currentLevel > 0 {\n\t\toptions.toc.WriteString(\"</ul>\\n\")\n\t}\n}\n\nfunc isHtmlTag(tag []byte, tagname string) bool {\n\tfound, _ := findHtmlTagPos(tag, tagname)\n\treturn found\n}\n\n// Look for a character, but ignore it when it's in any kind of quotes, it\n// might be JavaScript\nfunc skipUntilCharIgnoreQuotes(html []byte, start int, char byte) int {\n\tinSingleQuote := false\n\tinDoubleQuote := false\n\tinGraveQuote := false\n\ti := start\n\tfor i < len(html) {\n\t\tswitch {\n\t\tcase html[i] == char && !inSingleQuote && !inDoubleQuote && !inGraveQuote:\n\t\t\treturn i\n\t\tcase html[i] == '\\'':\n\t\t\tinSingleQuote = !inSingleQuote\n\t\tcase html[i] == '\"':\n\t\t\tinDoubleQuote = !inDoubleQuote\n\t\tcase html[i] == '`':\n\t\t\tinGraveQuote = !inGraveQuote\n\t\t}\n\t\ti++\n\t}\n\treturn start\n}\n\nfunc findHtmlTagPos(tag []byte, tagname string) (bool, int) {\n\ti := 0\n\tif i < len(tag) && tag[0] != '<' {\n\t\treturn false, -1\n\t}\n\ti++\n\ti = skipSpace(tag, i)\n\n\tif i < len(tag) && tag[i] == '/' {\n\t\ti++\n\t}\n\n\ti = skipSpace(tag, i)\n\tj := 0\n\tfor ; i < len(tag); i, j = i+1, j+1 {\n\t\tif j >= len(tagname) {\n\t\t\tbreak\n\t\t}\n\n\t\tif strings.ToLower(string(tag[i]))[0] != tagname[j] {\n\t\t\treturn false, -1\n\t\t}\n\t}\n\n\tif i == len(tag) {\n\t\treturn false, -1\n\t}\n\n\trightAngle := skipUntilCharIgnoreQuotes(tag, i, '>')\n\tif rightAngle > i {\n\t\treturn true, rightAngle\n\t}\n\n\treturn false, -1\n}\n\nfunc skipUntilChar(text []byte, start int, char byte) int {\n\ti := start\n\tfor i < len(text) && text[i] != char {\n\t\ti++\n\t}\n\treturn i\n}\n\nfunc skipSpace(tag []byte, i int) int {\n\tfor i < len(tag) && isspace(tag[i]) {\n\t\ti++\n\t}\n\treturn i\n}\n\nfunc skipChar(data []byte, start int, char byte) int {\n\ti := start\n\tfor i < len(data) && data[i] == char {\n\t\ti++\n\t}\n\treturn i\n}\n\nfunc doubleSpace(out *bytes.Buffer) {\n\tif out.Len() > 0 {\n\t\tout.WriteByte('\\n')\n\t}\n}\n\nfunc isRelativeLink(link []byte) (yes bool) {\n\t// a tag begin with '#'\n\tif link[0] == '#' {\n\t\treturn true\n\t}\n\n\t// link begin with '/' but not '//', the second maybe a protocol relative link\n\tif len(link) >= 2 && link[0] == '/' && link[1] != '/' {\n\t\treturn true\n\t}\n\n\t// only the root '/'\n\tif len(link) == 1 && link[0] == '/' {\n\t\treturn true\n\t}\n\n\t// current directory : begin with \"./\"\n\tif bytes.HasPrefix(link, []byte(\"./\")) {\n\t\treturn true\n\t}\n\n\t// parent directory : begin with \"../\"\n\tif bytes.HasPrefix(link, []byte(\"../\")) {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc (options *Html) ensureUniqueHeaderID(id string) string {\n\tfor count, found := options.headerIDs[id]; found; count, found = options.headerIDs[id] {\n\t\ttmp := fmt.Sprintf(\"%s-%d\", id, count+1)\n\n\t\tif _, tmpFound := options.headerIDs[tmp]; !tmpFound {\n\t\t\toptions.headerIDs[id] = count + 1\n\t\t\tid = tmp\n\t\t} else {\n\t\t\tid = id + \"-1\"\n\t\t}\n\t}\n\n\tif _, found := options.headerIDs[id]; !found {\n\t\toptions.headerIDs[id] = 0\n\t}\n\n\treturn id\n}\n"
        },
        {
          "name": "inline.go",
          "type": "blob",
          "size": 22.6796875,
          "content": "//\n// Blackfriday Markdown Processor\n// Available at http://github.com/russross/blackfriday\n//\n// Copyright © 2011 Russ Ross <russ@russross.com>.\n// Distributed under the Simplified BSD License.\n// See README.md for details.\n//\n\n//\n// Functions to parse inline elements.\n//\n\npackage blackfriday\n\nimport (\n\t\"bytes\"\n\t\"regexp\"\n\t\"strconv\"\n)\n\nvar (\n\turlRe    = `((https?|ftp):\\/\\/|\\/)[-A-Za-z0-9+&@#\\/%?=~_|!:,.;\\(\\)]+`\n\tanchorRe = regexp.MustCompile(`^(<a\\shref=\"` + urlRe + `\"(\\stitle=\"[^\"<>]+\")?\\s?>` + urlRe + `<\\/a>)`)\n)\n\n// Functions to parse text within a block\n// Each function returns the number of chars taken care of\n// data is the complete block being rendered\n// offset is the number of valid chars before the current cursor\n\nfunc (p *parser) inline(out *bytes.Buffer, data []byte) {\n\t// this is called recursively: enforce a maximum depth\n\tif p.nesting >= p.maxNesting {\n\t\treturn\n\t}\n\tp.nesting++\n\n\ti, end := 0, 0\n\tfor i < len(data) {\n\t\t// copy inactive chars into the output\n\t\tfor end < len(data) && p.inlineCallback[data[end]] == nil {\n\t\t\tend++\n\t\t}\n\n\t\tp.r.NormalText(out, data[i:end])\n\n\t\tif end >= len(data) {\n\t\t\tbreak\n\t\t}\n\t\ti = end\n\n\t\t// call the trigger\n\t\thandler := p.inlineCallback[data[end]]\n\t\tif consumed := handler(p, out, data, i); consumed == 0 {\n\t\t\t// no action from the callback; buffer the byte for later\n\t\t\tend = i + 1\n\t\t} else {\n\t\t\t// skip past whatever the callback used\n\t\t\ti += consumed\n\t\t\tend = i\n\t\t}\n\t}\n\n\tp.nesting--\n}\n\n// single and double emphasis parsing\nfunc emphasis(p *parser, out *bytes.Buffer, data []byte, offset int) int {\n\tdata = data[offset:]\n\tc := data[0]\n\tret := 0\n\n\tif len(data) > 2 && data[1] != c {\n\t\t// whitespace cannot follow an opening emphasis;\n\t\t// strikethrough only takes two characters '~~'\n\t\tif c == '~' || isspace(data[1]) {\n\t\t\treturn 0\n\t\t}\n\t\tif ret = helperEmphasis(p, out, data[1:], c); ret == 0 {\n\t\t\treturn 0\n\t\t}\n\n\t\treturn ret + 1\n\t}\n\n\tif len(data) > 3 && data[1] == c && data[2] != c {\n\t\tif isspace(data[2]) {\n\t\t\treturn 0\n\t\t}\n\t\tif ret = helperDoubleEmphasis(p, out, data[2:], c); ret == 0 {\n\t\t\treturn 0\n\t\t}\n\n\t\treturn ret + 2\n\t}\n\n\tif len(data) > 4 && data[1] == c && data[2] == c && data[3] != c {\n\t\tif c == '~' || isspace(data[3]) {\n\t\t\treturn 0\n\t\t}\n\t\tif ret = helperTripleEmphasis(p, out, data, 3, c); ret == 0 {\n\t\t\treturn 0\n\t\t}\n\n\t\treturn ret + 3\n\t}\n\n\treturn 0\n}\n\nfunc codeSpan(p *parser, out *bytes.Buffer, data []byte, offset int) int {\n\tdata = data[offset:]\n\n\tnb := 0\n\n\t// count the number of backticks in the delimiter\n\tfor nb < len(data) && data[nb] == '`' {\n\t\tnb++\n\t}\n\n\t// find the next delimiter\n\ti, end := 0, 0\n\tfor end = nb; end < len(data) && i < nb; end++ {\n\t\tif data[end] == '`' {\n\t\t\ti++\n\t\t} else {\n\t\t\ti = 0\n\t\t}\n\t}\n\n\t// no matching delimiter?\n\tif i < nb && end >= len(data) {\n\t\treturn 0\n\t}\n\n\t// trim outside whitespace\n\tfBegin := nb\n\tfor fBegin < end && data[fBegin] == ' ' {\n\t\tfBegin++\n\t}\n\n\tfEnd := end - nb\n\tfor fEnd > fBegin && data[fEnd-1] == ' ' {\n\t\tfEnd--\n\t}\n\n\t// render the code span\n\tif fBegin != fEnd {\n\t\tp.r.CodeSpan(out, data[fBegin:fEnd])\n\t}\n\n\treturn end\n\n}\n\n// newline preceded by two spaces becomes <br>\n// newline without two spaces works when EXTENSION_HARD_LINE_BREAK is enabled\nfunc lineBreak(p *parser, out *bytes.Buffer, data []byte, offset int) int {\n\t// remove trailing spaces from out\n\toutBytes := out.Bytes()\n\tend := len(outBytes)\n\teol := end\n\tfor eol > 0 && outBytes[eol-1] == ' ' {\n\t\teol--\n\t}\n\tout.Truncate(eol)\n\n\tprecededByTwoSpaces := offset >= 2 && data[offset-2] == ' ' && data[offset-1] == ' '\n\tprecededByBackslash := offset >= 1 && data[offset-1] == '\\\\' // see http://spec.commonmark.org/0.18/#example-527\n\tprecededByBackslash = precededByBackslash && p.flags&EXTENSION_BACKSLASH_LINE_BREAK != 0\n\n\tif p.flags&EXTENSION_JOIN_LINES != 0 {\n\t\treturn 1\n\t}\n\n\t// should there be a hard line break here?\n\tif p.flags&EXTENSION_HARD_LINE_BREAK == 0 && !precededByTwoSpaces && !precededByBackslash {\n\t\treturn 0\n\t}\n\n\tif precededByBackslash && eol > 0 {\n\t\tout.Truncate(eol - 1)\n\t}\n\tp.r.LineBreak(out)\n\treturn 1\n}\n\ntype linkType int\n\nconst (\n\tlinkNormal linkType = iota\n\tlinkImg\n\tlinkDeferredFootnote\n\tlinkInlineFootnote\n)\n\nfunc isReferenceStyleLink(data []byte, pos int, t linkType) bool {\n\tif t == linkDeferredFootnote {\n\t\treturn false\n\t}\n\treturn pos < len(data)-1 && data[pos] == '[' && data[pos+1] != '^'\n}\n\n// '[': parse a link or an image or a footnote\nfunc link(p *parser, out *bytes.Buffer, data []byte, offset int) int {\n\t// no links allowed inside regular links, footnote, and deferred footnotes\n\tif p.insideLink && (offset > 0 && data[offset-1] == '[' || len(data)-1 > offset && data[offset+1] == '^') {\n\t\treturn 0\n\t}\n\n\tvar t linkType\n\tswitch {\n\t// special case: ![^text] == deferred footnote (that follows something with\n\t// an exclamation point)\n\tcase p.flags&EXTENSION_FOOTNOTES != 0 && len(data)-1 > offset && data[offset+1] == '^':\n\t\tt = linkDeferredFootnote\n\t// ![alt] == image\n\tcase offset > 0 && data[offset-1] == '!':\n\t\tt = linkImg\n\t// ^[text] == inline footnote\n\t// [^refId] == deferred footnote\n\tcase p.flags&EXTENSION_FOOTNOTES != 0:\n\t\tif offset > 0 && data[offset-1] == '^' {\n\t\t\tt = linkInlineFootnote\n\t\t} else if len(data)-1 > offset && data[offset+1] == '^' {\n\t\t\tt = linkDeferredFootnote\n\t\t}\n\t// [text] == regular link\n\tdefault:\n\t\tt = linkNormal\n\t}\n\n\tdata = data[offset:]\n\n\tvar (\n\t\ti                       = 1\n\t\tnoteId                  int\n\t\ttitle, link, altContent []byte\n\t\ttextHasNl               = false\n\t)\n\n\tif t == linkDeferredFootnote {\n\t\ti++\n\t}\n\n\tbrace := 0\n\n\t// look for the matching closing bracket\n\tfor level := 1; level > 0 && i < len(data); i++ {\n\t\tswitch {\n\t\tcase data[i] == '\\n':\n\t\t\ttextHasNl = true\n\n\t\tcase isBackslashEscaped(data, i):\n\t\t\tcontinue\n\n\t\tcase data[i] == '[':\n\t\t\tlevel++\n\n\t\tcase data[i] == ']':\n\t\t\tlevel--\n\t\t\tif level <= 0 {\n\t\t\t\ti-- // compensate for extra i++ in for loop\n\t\t\t}\n\t\t}\n\t}\n\n\tif i >= len(data) {\n\t\treturn 0\n\t}\n\n\ttxtE := i\n\ti++\n\n\t// skip any amount of whitespace or newline\n\t// (this is much more lax than original markdown syntax)\n\tfor i < len(data) && isspace(data[i]) {\n\t\ti++\n\t}\n\n\tswitch {\n\t// inline style link\n\tcase i < len(data) && data[i] == '(':\n\t\t// skip initial whitespace\n\t\ti++\n\n\t\tfor i < len(data) && isspace(data[i]) {\n\t\t\ti++\n\t\t}\n\n\t\tlinkB := i\n\n\t\t// look for link end: ' \" ), check for new opening braces and take this\n\t\t// into account, this may lead for overshooting and probably will require\n\t\t// some fine-tuning.\n\tfindlinkend:\n\t\tfor i < len(data) {\n\t\t\tswitch {\n\t\t\tcase data[i] == '\\\\':\n\t\t\t\ti += 2\n\n\t\t\tcase data[i] == '(':\n\t\t\t\tbrace++\n\t\t\t\ti++\n\n\t\t\tcase data[i] == ')':\n\t\t\t\tif brace <= 0 {\n\t\t\t\t\tbreak findlinkend\n\t\t\t\t}\n\t\t\t\tbrace--\n\t\t\t\ti++\n\n\t\t\tcase data[i] == '\\'' || data[i] == '\"':\n\t\t\t\tbreak findlinkend\n\n\t\t\tdefault:\n\t\t\t\ti++\n\t\t\t}\n\t\t}\n\n\t\tif i >= len(data) {\n\t\t\treturn 0\n\t\t}\n\t\tlinkE := i\n\n\t\t// look for title end if present\n\t\ttitleB, titleE := 0, 0\n\t\tif data[i] == '\\'' || data[i] == '\"' {\n\t\t\ti++\n\t\t\ttitleB = i\n\n\t\tfindtitleend:\n\t\t\tfor i < len(data) {\n\t\t\t\tswitch {\n\t\t\t\tcase data[i] == '\\\\':\n\t\t\t\t\ti += 2\n\n\t\t\t\tcase data[i] == ')':\n\t\t\t\t\tbreak findtitleend\n\n\t\t\t\tdefault:\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif i >= len(data) {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\t// skip whitespace after title\n\t\t\ttitleE = i - 1\n\t\t\tfor titleE > titleB && isspace(data[titleE]) {\n\t\t\t\ttitleE--\n\t\t\t}\n\n\t\t\t// check for closing quote presence\n\t\t\tif data[titleE] != '\\'' && data[titleE] != '\"' {\n\t\t\t\ttitleB, titleE = 0, 0\n\t\t\t\tlinkE = i\n\t\t\t}\n\t\t}\n\n\t\t// remove whitespace at the end of the link\n\t\tfor linkE > linkB && isspace(data[linkE-1]) {\n\t\t\tlinkE--\n\t\t}\n\n\t\t// remove optional angle brackets around the link\n\t\tif data[linkB] == '<' {\n\t\t\tlinkB++\n\t\t}\n\t\tif data[linkE-1] == '>' {\n\t\t\tlinkE--\n\t\t}\n\n\t\t// build escaped link and title\n\t\tif linkE > linkB {\n\t\t\tlink = data[linkB:linkE]\n\t\t}\n\n\t\tif titleE > titleB {\n\t\t\ttitle = data[titleB:titleE]\n\t\t}\n\n\t\ti++\n\n\t// reference style link\n\tcase isReferenceStyleLink(data, i, t):\n\t\tvar id []byte\n\t\taltContentConsidered := false\n\n\t\t// look for the id\n\t\ti++\n\t\tlinkB := i\n\t\tfor i < len(data) && data[i] != ']' {\n\t\t\ti++\n\t\t}\n\t\tif i >= len(data) {\n\t\t\treturn 0\n\t\t}\n\t\tlinkE := i\n\n\t\t// find the reference\n\t\tif linkB == linkE {\n\t\t\tif textHasNl {\n\t\t\t\tvar b bytes.Buffer\n\n\t\t\t\tfor j := 1; j < txtE; j++ {\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase data[j] != '\\n':\n\t\t\t\t\t\tb.WriteByte(data[j])\n\t\t\t\t\tcase data[j-1] != ' ':\n\t\t\t\t\t\tb.WriteByte(' ')\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tid = b.Bytes()\n\t\t\t} else {\n\t\t\t\tid = data[1:txtE]\n\t\t\t\taltContentConsidered = true\n\t\t\t}\n\t\t} else {\n\t\t\tid = data[linkB:linkE]\n\t\t}\n\n\t\t// find the reference with matching id\n\t\tlr, ok := p.getRef(string(id))\n\t\tif !ok {\n\t\t\treturn 0\n\t\t}\n\n\t\t// keep link and title from reference\n\t\tlink = lr.link\n\t\ttitle = lr.title\n\t\tif altContentConsidered {\n\t\t\taltContent = lr.text\n\t\t}\n\t\ti++\n\n\t// shortcut reference style link or reference or inline footnote\n\tdefault:\n\t\tvar id []byte\n\n\t\t// craft the id\n\t\tif textHasNl {\n\t\t\tvar b bytes.Buffer\n\n\t\t\tfor j := 1; j < txtE; j++ {\n\t\t\t\tswitch {\n\t\t\t\tcase data[j] != '\\n':\n\t\t\t\t\tb.WriteByte(data[j])\n\t\t\t\tcase data[j-1] != ' ':\n\t\t\t\t\tb.WriteByte(' ')\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tid = b.Bytes()\n\t\t} else {\n\t\t\tif t == linkDeferredFootnote {\n\t\t\t\tid = data[2:txtE] // get rid of the ^\n\t\t\t} else {\n\t\t\t\tid = data[1:txtE]\n\t\t\t}\n\t\t}\n\n\t\tif t == linkInlineFootnote {\n\t\t\t// create a new reference\n\t\t\tnoteId = len(p.notes) + 1\n\n\t\t\tvar fragment []byte\n\t\t\tif len(id) > 0 {\n\t\t\t\tif len(id) < 16 {\n\t\t\t\t\tfragment = make([]byte, len(id))\n\t\t\t\t} else {\n\t\t\t\t\tfragment = make([]byte, 16)\n\t\t\t\t}\n\t\t\t\tcopy(fragment, slugify(id))\n\t\t\t} else {\n\t\t\t\tfragment = append([]byte(\"footnote-\"), []byte(strconv.Itoa(noteId))...)\n\t\t\t}\n\n\t\t\tref := &reference{\n\t\t\t\tnoteId:   noteId,\n\t\t\t\thasBlock: false,\n\t\t\t\tlink:     fragment,\n\t\t\t\ttitle:    id,\n\t\t\t}\n\n\t\t\tp.notes = append(p.notes, ref)\n\t\t\tp.notesRecord[string(ref.link)] = struct{}{}\n\n\t\t\tlink = ref.link\n\t\t\ttitle = ref.title\n\t\t} else {\n\t\t\t// find the reference with matching id\n\t\t\tlr, ok := p.getRef(string(id))\n\t\t\tif !ok {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tif t == linkDeferredFootnote && !p.isFootnote(lr) {\n\t\t\t\tlr.noteId = len(p.notes) + 1\n\t\t\t\tp.notes = append(p.notes, lr)\n\t\t\t\tp.notesRecord[string(lr.link)] = struct{}{}\n\t\t\t}\n\n\t\t\t// keep link and title from reference\n\t\t\tlink = lr.link\n\t\t\t// if inline footnote, title == footnote contents\n\t\t\ttitle = lr.title\n\t\t\tnoteId = lr.noteId\n\t\t}\n\n\t\t// rewind the whitespace\n\t\ti = txtE + 1\n\t}\n\n\t// build content: img alt is escaped, link content is parsed\n\tvar content bytes.Buffer\n\tif txtE > 1 {\n\t\tif t == linkImg {\n\t\t\tcontent.Write(data[1:txtE])\n\t\t} else {\n\t\t\t// links cannot contain other links, so turn off link parsing temporarily\n\t\t\tinsideLink := p.insideLink\n\t\t\tp.insideLink = true\n\t\t\tp.inline(&content, data[1:txtE])\n\t\t\tp.insideLink = insideLink\n\t\t}\n\t}\n\n\tvar uLink []byte\n\tif t == linkNormal || t == linkImg {\n\t\tif len(link) > 0 {\n\t\t\tvar uLinkBuf bytes.Buffer\n\t\t\tunescapeText(&uLinkBuf, link)\n\t\t\tuLink = uLinkBuf.Bytes()\n\t\t}\n\n\t\t// links need something to click on and somewhere to go\n\t\tif len(uLink) == 0 || (t == linkNormal && content.Len() == 0) {\n\t\t\treturn 0\n\t\t}\n\t}\n\n\t// call the relevant rendering function\n\tswitch t {\n\tcase linkNormal:\n\t\tif len(altContent) > 0 {\n\t\t\tp.r.Link(out, uLink, title, altContent)\n\t\t} else {\n\t\t\tp.r.Link(out, uLink, title, content.Bytes())\n\t\t}\n\n\tcase linkImg:\n\t\toutSize := out.Len()\n\t\toutBytes := out.Bytes()\n\t\tif outSize > 0 && outBytes[outSize-1] == '!' {\n\t\t\tout.Truncate(outSize - 1)\n\t\t}\n\n\t\tp.r.Image(out, uLink, title, content.Bytes())\n\n\tcase linkInlineFootnote:\n\t\toutSize := out.Len()\n\t\toutBytes := out.Bytes()\n\t\tif outSize > 0 && outBytes[outSize-1] == '^' {\n\t\t\tout.Truncate(outSize - 1)\n\t\t}\n\n\t\tp.r.FootnoteRef(out, link, noteId)\n\n\tcase linkDeferredFootnote:\n\t\tp.r.FootnoteRef(out, link, noteId)\n\n\tdefault:\n\t\treturn 0\n\t}\n\n\treturn i\n}\n\nfunc (p *parser) inlineHTMLComment(out *bytes.Buffer, data []byte) int {\n\tif len(data) < 5 {\n\t\treturn 0\n\t}\n\tif data[0] != '<' || data[1] != '!' || data[2] != '-' || data[3] != '-' {\n\t\treturn 0\n\t}\n\ti := 5\n\t// scan for an end-of-comment marker, across lines if necessary\n\tfor i < len(data) && !(data[i-2] == '-' && data[i-1] == '-' && data[i] == '>') {\n\t\ti++\n\t}\n\t// no end-of-comment marker\n\tif i >= len(data) {\n\t\treturn 0\n\t}\n\treturn i + 1\n}\n\n// '<' when tags or autolinks are allowed\nfunc leftAngle(p *parser, out *bytes.Buffer, data []byte, offset int) int {\n\tdata = data[offset:]\n\taltype := LINK_TYPE_NOT_AUTOLINK\n\tend := tagLength(data, &altype)\n\tif size := p.inlineHTMLComment(out, data); size > 0 {\n\t\tend = size\n\t}\n\tif end > 2 {\n\t\tif altype != LINK_TYPE_NOT_AUTOLINK {\n\t\t\tvar uLink bytes.Buffer\n\t\t\tunescapeText(&uLink, data[1:end+1-2])\n\t\t\tif uLink.Len() > 0 {\n\t\t\t\tp.r.AutoLink(out, uLink.Bytes(), altype)\n\t\t\t}\n\t\t} else {\n\t\t\tp.r.RawHtmlTag(out, data[:end])\n\t\t}\n\t}\n\n\treturn end\n}\n\n// '\\\\' backslash escape\nvar escapeChars = []byte(\"\\\\`*_{}[]()#+-.!:|&<>~\")\n\nfunc escape(p *parser, out *bytes.Buffer, data []byte, offset int) int {\n\tdata = data[offset:]\n\n\tif len(data) > 1 {\n\t\tif bytes.IndexByte(escapeChars, data[1]) < 0 {\n\t\t\treturn 0\n\t\t}\n\n\t\tp.r.NormalText(out, data[1:2])\n\t}\n\n\treturn 2\n}\n\nfunc unescapeText(ob *bytes.Buffer, src []byte) {\n\ti := 0\n\tfor i < len(src) {\n\t\torg := i\n\t\tfor i < len(src) && src[i] != '\\\\' {\n\t\t\ti++\n\t\t}\n\n\t\tif i > org {\n\t\t\tob.Write(src[org:i])\n\t\t}\n\n\t\tif i+1 >= len(src) {\n\t\t\tbreak\n\t\t}\n\n\t\tob.WriteByte(src[i+1])\n\t\ti += 2\n\t}\n}\n\n// '&' escaped when it doesn't belong to an entity\n// valid entities are assumed to be anything matching &#?[A-Za-z0-9]+;\nfunc entity(p *parser, out *bytes.Buffer, data []byte, offset int) int {\n\tdata = data[offset:]\n\n\tend := 1\n\n\tif end < len(data) && data[end] == '#' {\n\t\tend++\n\t}\n\n\tfor end < len(data) && isalnum(data[end]) {\n\t\tend++\n\t}\n\n\tif end < len(data) && data[end] == ';' {\n\t\tend++ // real entity\n\t} else {\n\t\treturn 0 // lone '&'\n\t}\n\n\tp.r.Entity(out, data[:end])\n\n\treturn end\n}\n\nfunc linkEndsWithEntity(data []byte, linkEnd int) bool {\n\tentityRanges := htmlEntity.FindAllIndex(data[:linkEnd], -1)\n\treturn entityRanges != nil && entityRanges[len(entityRanges)-1][1] == linkEnd\n}\n\nfunc autoLink(p *parser, out *bytes.Buffer, data []byte, offset int) int {\n\t// quick check to rule out most false hits on ':'\n\tif p.insideLink || len(data) < offset+3 || data[offset+1] != '/' || data[offset+2] != '/' {\n\t\treturn 0\n\t}\n\n\t// Now a more expensive check to see if we're not inside an anchor element\n\tanchorStart := offset\n\toffsetFromAnchor := 0\n\tfor anchorStart > 0 && data[anchorStart] != '<' {\n\t\tanchorStart--\n\t\toffsetFromAnchor++\n\t}\n\n\tanchorStr := anchorRe.Find(data[anchorStart:])\n\tif anchorStr != nil {\n\t\tout.Write(anchorStr[offsetFromAnchor:])\n\t\treturn len(anchorStr) - offsetFromAnchor\n\t}\n\n\t// scan backward for a word boundary\n\trewind := 0\n\tfor offset-rewind > 0 && rewind <= 7 && isletter(data[offset-rewind-1]) {\n\t\trewind++\n\t}\n\tif rewind > 6 { // longest supported protocol is \"mailto\" which has 6 letters\n\t\treturn 0\n\t}\n\n\torigData := data\n\tdata = data[offset-rewind:]\n\n\tif !isSafeLink(data) {\n\t\treturn 0\n\t}\n\n\tlinkEnd := 0\n\tfor linkEnd < len(data) && !isEndOfLink(data[linkEnd]) {\n\t\tlinkEnd++\n\t}\n\n\t// Skip punctuation at the end of the link\n\tif (data[linkEnd-1] == '.' || data[linkEnd-1] == ',') && data[linkEnd-2] != '\\\\' {\n\t\tlinkEnd--\n\t}\n\n\t// But don't skip semicolon if it's a part of escaped entity:\n\tif data[linkEnd-1] == ';' && data[linkEnd-2] != '\\\\' && !linkEndsWithEntity(data, linkEnd) {\n\t\tlinkEnd--\n\t}\n\n\t// See if the link finishes with a punctuation sign that can be closed.\n\tvar copen byte\n\tswitch data[linkEnd-1] {\n\tcase '\"':\n\t\tcopen = '\"'\n\tcase '\\'':\n\t\tcopen = '\\''\n\tcase ')':\n\t\tcopen = '('\n\tcase ']':\n\t\tcopen = '['\n\tcase '}':\n\t\tcopen = '{'\n\tdefault:\n\t\tcopen = 0\n\t}\n\n\tif copen != 0 {\n\t\tbufEnd := offset - rewind + linkEnd - 2\n\n\t\topenDelim := 1\n\n\t\t/* Try to close the final punctuation sign in this same line;\n\t\t * if we managed to close it outside of the URL, that means that it's\n\t\t * not part of the URL. If it closes inside the URL, that means it\n\t\t * is part of the URL.\n\t\t *\n\t\t * Examples:\n\t\t *\n\t\t *      foo http://www.pokemon.com/Pikachu_(Electric) bar\n\t\t *              => http://www.pokemon.com/Pikachu_(Electric)\n\t\t *\n\t\t *      foo (http://www.pokemon.com/Pikachu_(Electric)) bar\n\t\t *              => http://www.pokemon.com/Pikachu_(Electric)\n\t\t *\n\t\t *      foo http://www.pokemon.com/Pikachu_(Electric)) bar\n\t\t *              => http://www.pokemon.com/Pikachu_(Electric))\n\t\t *\n\t\t *      (foo http://www.pokemon.com/Pikachu_(Electric)) bar\n\t\t *              => foo http://www.pokemon.com/Pikachu_(Electric)\n\t\t */\n\n\t\tfor bufEnd >= 0 && origData[bufEnd] != '\\n' && openDelim != 0 {\n\t\t\tif origData[bufEnd] == data[linkEnd-1] {\n\t\t\t\topenDelim++\n\t\t\t}\n\n\t\t\tif origData[bufEnd] == copen {\n\t\t\t\topenDelim--\n\t\t\t}\n\n\t\t\tbufEnd--\n\t\t}\n\n\t\tif openDelim == 0 {\n\t\t\tlinkEnd--\n\t\t}\n\t}\n\n\t// we were triggered on the ':', so we need to rewind the output a bit\n\tif out.Len() >= rewind {\n\t\tout.Truncate(len(out.Bytes()) - rewind)\n\t}\n\n\tvar uLink bytes.Buffer\n\tunescapeText(&uLink, data[:linkEnd])\n\n\tif uLink.Len() > 0 {\n\t\tp.r.AutoLink(out, uLink.Bytes(), LINK_TYPE_NORMAL)\n\t}\n\n\treturn linkEnd - rewind\n}\n\nfunc isEndOfLink(char byte) bool {\n\treturn isspace(char) || char == '<'\n}\n\nvar validUris = [][]byte{[]byte(\"http://\"), []byte(\"https://\"), []byte(\"ftp://\"), []byte(\"mailto://\")}\nvar validPaths = [][]byte{[]byte(\"/\"), []byte(\"./\"), []byte(\"../\")}\n\nfunc isSafeLink(link []byte) bool {\n\tfor _, path := range validPaths {\n\t\tif len(link) >= len(path) && bytes.Equal(link[:len(path)], path) {\n\t\t\tif len(link) == len(path) {\n\t\t\t\treturn true\n\t\t\t} else if isalnum(link[len(path)]) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, prefix := range validUris {\n\t\t// TODO: handle unicode here\n\t\t// case-insensitive prefix test\n\t\tif len(link) > len(prefix) && bytes.Equal(bytes.ToLower(link[:len(prefix)]), prefix) && isalnum(link[len(prefix)]) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// return the length of the given tag, or 0 is it's not valid\nfunc tagLength(data []byte, autolink *int) int {\n\tvar i, j int\n\n\t// a valid tag can't be shorter than 3 chars\n\tif len(data) < 3 {\n\t\treturn 0\n\t}\n\n\t// begins with a '<' optionally followed by '/', followed by letter or number\n\tif data[0] != '<' {\n\t\treturn 0\n\t}\n\tif data[1] == '/' {\n\t\ti = 2\n\t} else {\n\t\ti = 1\n\t}\n\n\tif !isalnum(data[i]) {\n\t\treturn 0\n\t}\n\n\t// scheme test\n\t*autolink = LINK_TYPE_NOT_AUTOLINK\n\n\t// try to find the beginning of an URI\n\tfor i < len(data) && (isalnum(data[i]) || data[i] == '.' || data[i] == '+' || data[i] == '-') {\n\t\ti++\n\t}\n\n\tif i > 1 && i < len(data) && data[i] == '@' {\n\t\tif j = isMailtoAutoLink(data[i:]); j != 0 {\n\t\t\t*autolink = LINK_TYPE_EMAIL\n\t\t\treturn i + j\n\t\t}\n\t}\n\n\tif i > 2 && i < len(data) && data[i] == ':' {\n\t\t*autolink = LINK_TYPE_NORMAL\n\t\ti++\n\t}\n\n\t// complete autolink test: no whitespace or ' or \"\n\tswitch {\n\tcase i >= len(data):\n\t\t*autolink = LINK_TYPE_NOT_AUTOLINK\n\tcase *autolink != 0:\n\t\tj = i\n\n\t\tfor i < len(data) {\n\t\t\tif data[i] == '\\\\' {\n\t\t\t\ti += 2\n\t\t\t} else if data[i] == '>' || data[i] == '\\'' || data[i] == '\"' || isspace(data[i]) {\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\ti++\n\t\t\t}\n\n\t\t}\n\n\t\tif i >= len(data) {\n\t\t\treturn 0\n\t\t}\n\t\tif i > j && data[i] == '>' {\n\t\t\treturn i + 1\n\t\t}\n\n\t\t// one of the forbidden chars has been found\n\t\t*autolink = LINK_TYPE_NOT_AUTOLINK\n\t}\n\n\t// look for something looking like a tag end\n\tfor i < len(data) && data[i] != '>' {\n\t\ti++\n\t}\n\tif i >= len(data) {\n\t\treturn 0\n\t}\n\treturn i + 1\n}\n\n// look for the address part of a mail autolink and '>'\n// this is less strict than the original markdown e-mail address matching\nfunc isMailtoAutoLink(data []byte) int {\n\tnb := 0\n\n\t// address is assumed to be: [-@._a-zA-Z0-9]+ with exactly one '@'\n\tfor i := 0; i < len(data); i++ {\n\t\tif isalnum(data[i]) {\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch data[i] {\n\t\tcase '@':\n\t\t\tnb++\n\n\t\tcase '-', '.', '_':\n\t\t\t// Do nothing.\n\n\t\tcase '>':\n\t\t\tif nb == 1 {\n\t\t\t\treturn i + 1\n\t\t\t} else {\n\t\t\t\treturn 0\n\t\t\t}\n\t\tdefault:\n\t\t\treturn 0\n\t\t}\n\t}\n\n\treturn 0\n}\n\n// look for the next emph char, skipping other constructs\nfunc helperFindEmphChar(data []byte, c byte) int {\n\ti := 0\n\n\tfor i < len(data) {\n\t\tfor i < len(data) && data[i] != c && data[i] != '`' && data[i] != '[' {\n\t\t\ti++\n\t\t}\n\t\tif i >= len(data) {\n\t\t\treturn 0\n\t\t}\n\t\t// do not count escaped chars\n\t\tif i != 0 && data[i-1] == '\\\\' {\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tif data[i] == c {\n\t\t\treturn i\n\t\t}\n\n\t\tif data[i] == '`' {\n\t\t\t// skip a code span\n\t\t\ttmpI := 0\n\t\t\ti++\n\t\t\tfor i < len(data) && data[i] != '`' {\n\t\t\t\tif tmpI == 0 && data[i] == c {\n\t\t\t\t\ttmpI = i\n\t\t\t\t}\n\t\t\t\ti++\n\t\t\t}\n\t\t\tif i >= len(data) {\n\t\t\t\treturn tmpI\n\t\t\t}\n\t\t\ti++\n\t\t} else if data[i] == '[' {\n\t\t\t// skip a link\n\t\t\ttmpI := 0\n\t\t\ti++\n\t\t\tfor i < len(data) && data[i] != ']' {\n\t\t\t\tif tmpI == 0 && data[i] == c {\n\t\t\t\t\ttmpI = i\n\t\t\t\t}\n\t\t\t\ti++\n\t\t\t}\n\t\t\ti++\n\t\t\tfor i < len(data) && (data[i] == ' ' || data[i] == '\\n') {\n\t\t\t\ti++\n\t\t\t}\n\t\t\tif i >= len(data) {\n\t\t\t\treturn tmpI\n\t\t\t}\n\t\t\tif data[i] != '[' && data[i] != '(' { // not a link\n\t\t\t\tif tmpI > 0 {\n\t\t\t\t\treturn tmpI\n\t\t\t\t} else {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tcc := data[i]\n\t\t\ti++\n\t\t\tfor i < len(data) && data[i] != cc {\n\t\t\t\tif tmpI == 0 && data[i] == c {\n\t\t\t\t\treturn i\n\t\t\t\t}\n\t\t\t\ti++\n\t\t\t}\n\t\t\tif i >= len(data) {\n\t\t\t\treturn tmpI\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc helperEmphasis(p *parser, out *bytes.Buffer, data []byte, c byte) int {\n\ti := 0\n\n\t// skip one symbol if coming from emph3\n\tif len(data) > 1 && data[0] == c && data[1] == c {\n\t\ti = 1\n\t}\n\n\tfor i < len(data) {\n\t\tlength := helperFindEmphChar(data[i:], c)\n\t\tif length == 0 {\n\t\t\treturn 0\n\t\t}\n\t\ti += length\n\t\tif i >= len(data) {\n\t\t\treturn 0\n\t\t}\n\n\t\tif i+1 < len(data) && data[i+1] == c {\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\n\t\tif data[i] == c && !isspace(data[i-1]) {\n\n\t\t\tif p.flags&EXTENSION_NO_INTRA_EMPHASIS != 0 {\n\t\t\t\tif !(i+1 == len(data) || isspace(data[i+1]) || ispunct(data[i+1])) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar work bytes.Buffer\n\t\t\tp.inline(&work, data[:i])\n\t\t\tp.r.Emphasis(out, work.Bytes())\n\t\t\treturn i + 1\n\t\t}\n\t}\n\n\treturn 0\n}\n\nfunc helperDoubleEmphasis(p *parser, out *bytes.Buffer, data []byte, c byte) int {\n\ti := 0\n\n\tfor i < len(data) {\n\t\tlength := helperFindEmphChar(data[i:], c)\n\t\tif length == 0 {\n\t\t\treturn 0\n\t\t}\n\t\ti += length\n\n\t\tif i+1 < len(data) && data[i] == c && data[i+1] == c && i > 0 && !isspace(data[i-1]) {\n\t\t\tvar work bytes.Buffer\n\t\t\tp.inline(&work, data[:i])\n\n\t\t\tif work.Len() > 0 {\n\t\t\t\t// pick the right renderer\n\t\t\t\tif c == '~' {\n\t\t\t\t\tp.r.StrikeThrough(out, work.Bytes())\n\t\t\t\t} else {\n\t\t\t\t\tp.r.DoubleEmphasis(out, work.Bytes())\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn i + 2\n\t\t}\n\t\ti++\n\t}\n\treturn 0\n}\n\nfunc helperTripleEmphasis(p *parser, out *bytes.Buffer, data []byte, offset int, c byte) int {\n\ti := 0\n\torigData := data\n\tdata = data[offset:]\n\n\tfor i < len(data) {\n\t\tlength := helperFindEmphChar(data[i:], c)\n\t\tif length == 0 {\n\t\t\treturn 0\n\t\t}\n\t\ti += length\n\n\t\t// skip whitespace preceded symbols\n\t\tif data[i] != c || isspace(data[i-1]) {\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch {\n\t\tcase i+2 < len(data) && data[i+1] == c && data[i+2] == c:\n\t\t\t// triple symbol found\n\t\t\tvar work bytes.Buffer\n\n\t\t\tp.inline(&work, data[:i])\n\t\t\tif work.Len() > 0 {\n\t\t\t\tp.r.TripleEmphasis(out, work.Bytes())\n\t\t\t}\n\t\t\treturn i + 3\n\t\tcase (i+1 < len(data) && data[i+1] == c):\n\t\t\t// double symbol found, hand over to emph1\n\t\t\tlength = helperEmphasis(p, out, origData[offset-2:], c)\n\t\t\tif length == 0 {\n\t\t\t\treturn 0\n\t\t\t} else {\n\t\t\t\treturn length - 2\n\t\t\t}\n\t\tdefault:\n\t\t\t// single symbol found, hand over to emph2\n\t\t\tlength = helperDoubleEmphasis(p, out, origData[offset-1:], c)\n\t\t\tif length == 0 {\n\t\t\t\treturn 0\n\t\t\t} else {\n\t\t\t\treturn length - 1\n\t\t\t}\n\t\t}\n\t}\n\treturn 0\n}\n"
        },
        {
          "name": "inline_test.go",
          "type": "blob",
          "size": 37.2958984375,
          "content": "//\n// Blackfriday Markdown Processor\n// Available at http://github.com/russross/blackfriday\n//\n// Copyright © 2011 Russ Ross <russ@russross.com>.\n// Distributed under the Simplified BSD License.\n// See README.md for details.\n//\n\n//\n// Unit tests for inline parsing\n//\n\npackage blackfriday\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc runMarkdownInline(input string, opts Options, htmlFlags int, params HtmlRendererParameters) string {\n\topts.Extensions |= EXTENSION_AUTOLINK\n\topts.Extensions |= EXTENSION_STRIKETHROUGH\n\n\thtmlFlags |= HTML_USE_XHTML\n\n\trenderer := HtmlRendererWithParameters(htmlFlags, \"\", \"\", params)\n\n\treturn string(MarkdownOptions([]byte(input), renderer, opts))\n}\n\nfunc doTestsInline(t *testing.T, tests []string) {\n\tdoTestsInlineParam(t, tests, Options{}, 0, HtmlRendererParameters{})\n}\n\nfunc doLinkTestsInline(t *testing.T, tests []string) {\n\tdoTestsInline(t, tests)\n\n\tprefix := \"http://localhost\"\n\tparams := HtmlRendererParameters{AbsolutePrefix: prefix}\n\ttransformTests := transformLinks(tests, prefix)\n\tdoTestsInlineParam(t, transformTests, Options{}, 0, params)\n\tdoTestsInlineParam(t, transformTests, Options{}, commonHtmlFlags, params)\n}\n\nfunc doSafeTestsInline(t *testing.T, tests []string) {\n\tdoTestsInlineParam(t, tests, Options{}, HTML_SAFELINK, HtmlRendererParameters{})\n\n\t// All the links in this test should not have the prefix appended, so\n\t// just rerun it with different parameters and the same expectations.\n\tprefix := \"http://localhost\"\n\tparams := HtmlRendererParameters{AbsolutePrefix: prefix}\n\ttransformTests := transformLinks(tests, prefix)\n\tdoTestsInlineParam(t, transformTests, Options{}, HTML_SAFELINK, params)\n}\n\nfunc doTestsInlineParam(t *testing.T, tests []string, opts Options, htmlFlags int,\n\tparams HtmlRendererParameters) {\n\t// catch and report panics\n\tvar candidate string\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tt.Errorf(\"\\npanic while processing [%#v]: %s\\n\", candidate, err)\n\t\t}\n\t}()\n\n\tfor i := 0; i+1 < len(tests); i += 2 {\n\t\tinput := tests[i]\n\t\tcandidate = input\n\t\texpected := tests[i+1]\n\t\tactual := runMarkdownInline(candidate, opts, htmlFlags, params)\n\t\tif actual != expected {\n\t\t\tt.Errorf(\"\\nInput   [%#v]\\nExpected[%#v]\\nActual  [%#v]\",\n\t\t\t\tcandidate, expected, actual)\n\t\t}\n\n\t\t// now test every substring to stress test bounds checking\n\t\tif !testing.Short() {\n\t\t\tfor start := 0; start < len(input); start++ {\n\t\t\t\tfor end := start + 1; end <= len(input); end++ {\n\t\t\t\t\tcandidate = input[start:end]\n\t\t\t\t\t_ = runMarkdownInline(candidate, opts, htmlFlags, params)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc transformLinks(tests []string, prefix string) []string {\n\tnewTests := make([]string, len(tests))\n\tanchorRe := regexp.MustCompile(`<a href=\"/(.*?)\"`)\n\timgRe := regexp.MustCompile(`<img src=\"/(.*?)\"`)\n\tfor i, test := range tests {\n\t\tif i%2 == 1 {\n\t\t\ttest = anchorRe.ReplaceAllString(test, `<a href=\"`+prefix+`/$1\"`)\n\t\t\ttest = imgRe.ReplaceAllString(test, `<img src=\"`+prefix+`/$1\"`)\n\t\t}\n\t\tnewTests[i] = test\n\t}\n\treturn newTests\n}\n\nfunc TestEmphasis(t *testing.T) {\n\tvar tests = []string{\n\t\t\"nothing inline\\n\",\n\t\t\"<p>nothing inline</p>\\n\",\n\n\t\t\"simple *inline* test\\n\",\n\t\t\"<p>simple <em>inline</em> test</p>\\n\",\n\n\t\t\"*at the* beginning\\n\",\n\t\t\"<p><em>at the</em> beginning</p>\\n\",\n\n\t\t\"at the *end*\\n\",\n\t\t\"<p>at the <em>end</em></p>\\n\",\n\n\t\t\"*try two* in *one line*\\n\",\n\t\t\"<p><em>try two</em> in <em>one line</em></p>\\n\",\n\n\t\t\"over *two\\nlines* test\\n\",\n\t\t\"<p>over <em>two\\nlines</em> test</p>\\n\",\n\n\t\t\"odd *number of* markers* here\\n\",\n\t\t\"<p>odd <em>number of</em> markers* here</p>\\n\",\n\n\t\t\"odd *number\\nof* markers* here\\n\",\n\t\t\"<p>odd <em>number\\nof</em> markers* here</p>\\n\",\n\n\t\t\"simple _inline_ test\\n\",\n\t\t\"<p>simple <em>inline</em> test</p>\\n\",\n\n\t\t\"_at the_ beginning\\n\",\n\t\t\"<p><em>at the</em> beginning</p>\\n\",\n\n\t\t\"at the _end_\\n\",\n\t\t\"<p>at the <em>end</em></p>\\n\",\n\n\t\t\"_try two_ in _one line_\\n\",\n\t\t\"<p><em>try two</em> in <em>one line</em></p>\\n\",\n\n\t\t\"over _two\\nlines_ test\\n\",\n\t\t\"<p>over <em>two\\nlines</em> test</p>\\n\",\n\n\t\t\"odd _number of_ markers_ here\\n\",\n\t\t\"<p>odd <em>number of</em> markers_ here</p>\\n\",\n\n\t\t\"odd _number\\nof_ markers_ here\\n\",\n\t\t\"<p>odd <em>number\\nof</em> markers_ here</p>\\n\",\n\n\t\t\"mix of *markers_\\n\",\n\t\t\"<p>mix of *markers_</p>\\n\",\n\n\t\t\"*What is A\\\\* algorithm?*\\n\",\n\t\t\"<p><em>What is A* algorithm?</em></p>\\n\",\n\n\t\t\"some para_graph with _emphasised_ text.\\n\",\n\t\t\"<p>some para_graph with <em>emphasised</em> text.</p>\\n\",\n\n\t\t\"some paragraph with _emphasised_ te_xt.\\n\",\n\t\t\"<p>some paragraph with <em>emphasised</em> te_xt.</p>\\n\",\n\n\t\t\"some paragraph with t_wo bi_ts of _emphasised_ text.\\n\",\n\t\t\"<p>some paragraph with t<em>wo bi</em>ts of <em>emphasised</em> text.</p>\\n\",\n\n\t\t\"un*frigging*believable\\n\",\n\t\t\"<p>un<em>frigging</em>believable</p>\\n\",\n\t}\n\tdoTestsInline(t, tests)\n}\n\nfunc TestNoIntraEmphasis(t *testing.T) {\n\ttests := []string{\n\t\t\"some para_graph with _emphasised_ text.\\n\",\n\t\t\"<p>some para_graph with <em>emphasised</em> text.</p>\\n\",\n\n\t\t\"un*frigging*believable\\n\",\n\t\t\"<p>un*frigging*believable</p>\\n\",\n\t}\n\tdoTestsInlineParam(t, tests, Options{\n\t\tExtensions: EXTENSION_NO_INTRA_EMPHASIS},\n\t\t0, HtmlRendererParameters{})\n}\n\nfunc TestReferenceOverride(t *testing.T) {\n\tvar tests = []string{\n\t\t\"test [ref1][]\\n\",\n\t\t\"<p>test <a href=\\\"http://www.ref1.com/\\\" title=\\\"Reference 1\\\">ref1</a></p>\\n\",\n\n\t\t\"test [my ref][ref1]\\n\",\n\t\t\"<p>test <a href=\\\"http://www.ref1.com/\\\" title=\\\"Reference 1\\\">my ref</a></p>\\n\",\n\n\t\t\"test [ref2][]\\n\\n[ref2]: http://www.leftalone.com/ (Ref left alone)\\n\",\n\t\t\"<p>test <a href=\\\"http://www.overridden.com/\\\" title=\\\"Reference Overridden\\\">ref2</a></p>\\n\",\n\n\t\t\"test [ref3][]\\n\\n[ref3]: http://www.leftalone.com/ (Ref left alone)\\n\",\n\t\t\"<p>test <a href=\\\"http://www.leftalone.com/\\\" title=\\\"Ref left alone\\\">ref3</a></p>\\n\",\n\n\t\t\"test [ref4][]\\n\\n[ref4]: http://zombo.com/ (You can do anything)\\n\",\n\t\t\"<p>test [ref4][]</p>\\n\",\n\n\t\t\"test [!(*http.ServeMux).ServeHTTP][] complicated ref\\n\",\n\t\t\"<p>test <a href=\\\"http://localhost:6060/pkg/net/http/#ServeMux.ServeHTTP\\\" title=\\\"ServeHTTP docs\\\">!(*http.ServeMux).ServeHTTP</a> complicated ref</p>\\n\",\n\n\t\t\"test [ref5][]\\n\",\n\t\t\"<p>test <a href=\\\"http://www.ref5.com/\\\" title=\\\"Reference 5\\\">Moo</a></p>\\n\",\n\t}\n\tdoTestsInlineParam(t, tests, Options{\n\t\tReferenceOverride: func(reference string) (rv *Reference, overridden bool) {\n\t\t\tswitch reference {\n\t\t\tcase \"ref1\":\n\t\t\t\t// just an overriden reference exists without definition\n\t\t\t\treturn &Reference{\n\t\t\t\t\tLink:  \"http://www.ref1.com/\",\n\t\t\t\t\tTitle: \"Reference 1\"}, true\n\t\t\tcase \"ref2\":\n\t\t\t\t// overridden exists and reference defined\n\t\t\t\treturn &Reference{\n\t\t\t\t\tLink:  \"http://www.overridden.com/\",\n\t\t\t\t\tTitle: \"Reference Overridden\"}, true\n\t\t\tcase \"ref3\":\n\t\t\t\t// not overridden and reference defined\n\t\t\t\treturn nil, false\n\t\t\tcase \"ref4\":\n\t\t\t\t// overridden missing and defined\n\t\t\t\treturn nil, true\n\t\t\tcase \"!(*http.ServeMux).ServeHTTP\":\n\t\t\t\treturn &Reference{\n\t\t\t\t\tLink:  \"http://localhost:6060/pkg/net/http/#ServeMux.ServeHTTP\",\n\t\t\t\t\tTitle: \"ServeHTTP docs\"}, true\n\t\t\tcase \"ref5\":\n\t\t\t\treturn &Reference{\n\t\t\t\t\tLink:  \"http://www.ref5.com/\",\n\t\t\t\t\tTitle: \"Reference 5\",\n\t\t\t\t\tText:  \"Moo\",\n\t\t\t\t}, true\n\t\t\t}\n\t\t\treturn nil, false\n\t\t}}, 0, HtmlRendererParameters{})\n}\n\nfunc TestStrong(t *testing.T) {\n\tvar tests = []string{\n\t\t\"nothing inline\\n\",\n\t\t\"<p>nothing inline</p>\\n\",\n\n\t\t\"simple **inline** test\\n\",\n\t\t\"<p>simple <strong>inline</strong> test</p>\\n\",\n\n\t\t\"**at the** beginning\\n\",\n\t\t\"<p><strong>at the</strong> beginning</p>\\n\",\n\n\t\t\"at the **end**\\n\",\n\t\t\"<p>at the <strong>end</strong></p>\\n\",\n\n\t\t\"**try two** in **one line**\\n\",\n\t\t\"<p><strong>try two</strong> in <strong>one line</strong></p>\\n\",\n\n\t\t\"over **two\\nlines** test\\n\",\n\t\t\"<p>over <strong>two\\nlines</strong> test</p>\\n\",\n\n\t\t\"odd **number of** markers** here\\n\",\n\t\t\"<p>odd <strong>number of</strong> markers** here</p>\\n\",\n\n\t\t\"odd **number\\nof** markers** here\\n\",\n\t\t\"<p>odd <strong>number\\nof</strong> markers** here</p>\\n\",\n\n\t\t\"simple __inline__ test\\n\",\n\t\t\"<p>simple <strong>inline</strong> test</p>\\n\",\n\n\t\t\"__at the__ beginning\\n\",\n\t\t\"<p><strong>at the</strong> beginning</p>\\n\",\n\n\t\t\"at the __end__\\n\",\n\t\t\"<p>at the <strong>end</strong></p>\\n\",\n\n\t\t\"__try two__ in __one line__\\n\",\n\t\t\"<p><strong>try two</strong> in <strong>one line</strong></p>\\n\",\n\n\t\t\"over __two\\nlines__ test\\n\",\n\t\t\"<p>over <strong>two\\nlines</strong> test</p>\\n\",\n\n\t\t\"odd __number of__ markers__ here\\n\",\n\t\t\"<p>odd <strong>number of</strong> markers__ here</p>\\n\",\n\n\t\t\"odd __number\\nof__ markers__ here\\n\",\n\t\t\"<p>odd <strong>number\\nof</strong> markers__ here</p>\\n\",\n\n\t\t\"mix of **markers__\\n\",\n\t\t\"<p>mix of **markers__</p>\\n\",\n\n\t\t\"**`/usr`** : this folder is named `usr`\\n\",\n\t\t\"<p><strong><code>/usr</code></strong> : this folder is named <code>usr</code></p>\\n\",\n\n\t\t\"**`/usr`** :\\n\\n this folder is named `usr`\\n\",\n\t\t\"<p><strong><code>/usr</code></strong> :</p>\\n\\n<p>this folder is named <code>usr</code></p>\\n\",\n\t}\n\tdoTestsInline(t, tests)\n}\n\nfunc TestEmphasisMix(t *testing.T) {\n\tvar tests = []string{\n\t\t\"***triple emphasis***\\n\",\n\t\t\"<p><strong><em>triple emphasis</em></strong></p>\\n\",\n\n\t\t\"***triple\\nemphasis***\\n\",\n\t\t\"<p><strong><em>triple\\nemphasis</em></strong></p>\\n\",\n\n\t\t\"___triple emphasis___\\n\",\n\t\t\"<p><strong><em>triple emphasis</em></strong></p>\\n\",\n\n\t\t\"***triple emphasis___\\n\",\n\t\t\"<p>***triple emphasis___</p>\\n\",\n\n\t\t\"*__triple emphasis__*\\n\",\n\t\t\"<p><em><strong>triple emphasis</strong></em></p>\\n\",\n\n\t\t\"__*triple emphasis*__\\n\",\n\t\t\"<p><strong><em>triple emphasis</em></strong></p>\\n\",\n\n\t\t\"**improper *nesting** is* bad\\n\",\n\t\t\"<p><strong>improper *nesting</strong> is* bad</p>\\n\",\n\n\t\t\"*improper **nesting* is** bad\\n\",\n\t\t\"<p>*improper <strong>nesting* is</strong> bad</p>\\n\",\n\t}\n\tdoTestsInline(t, tests)\n}\n\nfunc TestEmphasisLink(t *testing.T) {\n\tvar tests = []string{\n\t\t\"[first](before) *text[second] (inside)text* [third](after)\\n\",\n\t\t\"<p><a href=\\\"before\\\">first</a> <em>text<a href=\\\"inside\\\">second</a>text</em> <a href=\\\"after\\\">third</a></p>\\n\",\n\n\t\t\"*incomplete [link] definition*\\n\",\n\t\t\"<p><em>incomplete [link] definition</em></p>\\n\",\n\n\t\t\"*it's [emphasis*] (not link)\\n\",\n\t\t\"<p><em>it's [emphasis</em>] (not link)</p>\\n\",\n\n\t\t\"*it's [emphasis*] and *[asterisk]\\n\",\n\t\t\"<p><em>it's [emphasis</em>] and *[asterisk]</p>\\n\",\n\t}\n\tdoTestsInline(t, tests)\n}\n\nfunc TestStrikeThrough(t *testing.T) {\n\tvar tests = []string{\n\t\t\"nothing inline\\n\",\n\t\t\"<p>nothing inline</p>\\n\",\n\n\t\t\"simple ~~inline~~ test\\n\",\n\t\t\"<p>simple <del>inline</del> test</p>\\n\",\n\n\t\t\"~~at the~~ beginning\\n\",\n\t\t\"<p><del>at the</del> beginning</p>\\n\",\n\n\t\t\"at the ~~end~~\\n\",\n\t\t\"<p>at the <del>end</del></p>\\n\",\n\n\t\t\"~~try two~~ in ~~one line~~\\n\",\n\t\t\"<p><del>try two</del> in <del>one line</del></p>\\n\",\n\n\t\t\"over ~~two\\nlines~~ test\\n\",\n\t\t\"<p>over <del>two\\nlines</del> test</p>\\n\",\n\n\t\t\"odd ~~number of~~ markers~~ here\\n\",\n\t\t\"<p>odd <del>number of</del> markers~~ here</p>\\n\",\n\n\t\t\"odd ~~number\\nof~~ markers~~ here\\n\",\n\t\t\"<p>odd <del>number\\nof</del> markers~~ here</p>\\n\",\n\t}\n\tdoTestsInline(t, tests)\n}\n\nfunc TestCodeSpan(t *testing.T) {\n\tvar tests = []string{\n\t\t\"`source code`\\n\",\n\t\t\"<p><code>source code</code></p>\\n\",\n\n\t\t\"` source code with spaces `\\n\",\n\t\t\"<p><code>source code with spaces</code></p>\\n\",\n\n\t\t\"` source code with spaces `not here\\n\",\n\t\t\"<p><code>source code with spaces</code>not here</p>\\n\",\n\n\t\t\"a `single marker\\n\",\n\t\t\"<p>a `single marker</p>\\n\",\n\n\t\t\"a single multi-tick marker with ``` no text\\n\",\n\t\t\"<p>a single multi-tick marker with ``` no text</p>\\n\",\n\n\t\t\"markers with ` ` a space\\n\",\n\t\t\"<p>markers with  a space</p>\\n\",\n\n\t\t\"`source code` and a `stray\\n\",\n\t\t\"<p><code>source code</code> and a `stray</p>\\n\",\n\n\t\t\"`source *with* _awkward characters_ in it`\\n\",\n\t\t\"<p><code>source *with* _awkward characters_ in it</code></p>\\n\",\n\n\t\t\"`split over\\ntwo lines`\\n\",\n\t\t\"<p><code>split over\\ntwo lines</code></p>\\n\",\n\n\t\t\"```multiple ticks``` for the marker\\n\",\n\t\t\"<p><code>multiple ticks</code> for the marker</p>\\n\",\n\n\t\t\"```multiple ticks `with` ticks inside```\\n\",\n\t\t\"<p><code>multiple ticks `with` ticks inside</code></p>\\n\",\n\t}\n\tdoTestsInline(t, tests)\n}\n\nfunc TestLineBreak(t *testing.T) {\n\tvar tests = []string{\n\t\t\"this line  \\nhas a break\\n\",\n\t\t\"<p>this line<br />\\nhas a break</p>\\n\",\n\n\t\t\"this line \\ndoes not\\n\",\n\t\t\"<p>this line\\ndoes not</p>\\n\",\n\n\t\t\"this line\\\\\\ndoes not\\n\",\n\t\t\"<p>this line\\\\\\ndoes not</p>\\n\",\n\n\t\t\"this line\\\\ \\ndoes not\\n\",\n\t\t\"<p>this line\\\\\\ndoes not</p>\\n\",\n\n\t\t\"this has an   \\nextra space\\n\",\n\t\t\"<p>this has an<br />\\nextra space</p>\\n\",\n\t}\n\tdoTestsInline(t, tests)\n\n\ttests = []string{\n\t\t\"this line  \\nhas a break\\n\",\n\t\t\"<p>this line<br />\\nhas a break</p>\\n\",\n\n\t\t\"this line \\ndoes not\\n\",\n\t\t\"<p>this line\\ndoes not</p>\\n\",\n\n\t\t\"this line\\\\\\nhas a break\\n\",\n\t\t\"<p>this line<br />\\nhas a break</p>\\n\",\n\n\t\t\"this line\\\\ \\ndoes not\\n\",\n\t\t\"<p>this line\\\\\\ndoes not</p>\\n\",\n\n\t\t\"this has an   \\nextra space\\n\",\n\t\t\"<p>this has an<br />\\nextra space</p>\\n\",\n\t}\n\tdoTestsInlineParam(t, tests, Options{\n\t\tExtensions: EXTENSION_BACKSLASH_LINE_BREAK},\n\t\t0, HtmlRendererParameters{})\n}\n\nfunc TestInlineLink(t *testing.T) {\n\tvar tests = []string{\n\t\t\"[foo](/bar/)\\n\",\n\t\t\"<p><a href=\\\"/bar/\\\">foo</a></p>\\n\",\n\n\t\t\"[foo with a title](/bar/ \\\"title\\\")\\n\",\n\t\t\"<p><a href=\\\"/bar/\\\" title=\\\"title\\\">foo with a title</a></p>\\n\",\n\n\t\t\"[foo with a title](/bar/\\t\\\"title\\\")\\n\",\n\t\t\"<p><a href=\\\"/bar/\\\" title=\\\"title\\\">foo with a title</a></p>\\n\",\n\n\t\t\"[foo with a title](/bar/ \\\"title\\\"  )\\n\",\n\t\t\"<p><a href=\\\"/bar/\\\" title=\\\"title\\\">foo with a title</a></p>\\n\",\n\n\t\t\"[foo with a title](/bar/ title with no quotes)\\n\",\n\t\t\"<p><a href=\\\"/bar/ title with no quotes\\\">foo with a title</a></p>\\n\",\n\n\t\t\"[foo]()\\n\",\n\t\t\"<p>[foo]()</p>\\n\",\n\n\t\t\"![foo](/bar/)\\n\",\n\t\t\"<p><img src=\\\"/bar/\\\" alt=\\\"foo\\\" /></p>\\n\",\n\n\t\t\"![foo with a title](/bar/ \\\"title\\\")\\n\",\n\t\t\"<p><img src=\\\"/bar/\\\" alt=\\\"foo with a title\\\" title=\\\"title\\\" /></p>\\n\",\n\n\t\t\"![foo with a title](/bar/\\t\\\"title\\\")\\n\",\n\t\t\"<p><img src=\\\"/bar/\\\" alt=\\\"foo with a title\\\" title=\\\"title\\\" /></p>\\n\",\n\n\t\t\"![foo with a title](/bar/ \\\"title\\\"  )\\n\",\n\t\t\"<p><img src=\\\"/bar/\\\" alt=\\\"foo with a title\\\" title=\\\"title\\\" /></p>\\n\",\n\n\t\t\"![foo with a title](/bar/ title with no quotes)\\n\",\n\t\t\"<p><img src=\\\"/bar/ title with no quotes\\\" alt=\\\"foo with a title\\\" /></p>\\n\",\n\n\t\t\"![](img.jpg)\\n\",\n\t\t\"<p><img src=\\\"img.jpg\\\" alt=\\\"\\\" /></p>\\n\",\n\n\t\t\"[link](url)\\n\",\n\t\t\"<p><a href=\\\"url\\\">link</a></p>\\n\",\n\n\t\t\"![foo]()\\n\",\n\t\t\"<p>![foo]()</p>\\n\",\n\n\t\t\"[a link]\\t(/with_a_tab/)\\n\",\n\t\t\"<p><a href=\\\"/with_a_tab/\\\">a link</a></p>\\n\",\n\n\t\t\"[a link]  (/with_spaces/)\\n\",\n\t\t\"<p><a href=\\\"/with_spaces/\\\">a link</a></p>\\n\",\n\n\t\t\"[text (with) [[nested] (brackets)]](/url/)\\n\",\n\t\t\"<p><a href=\\\"/url/\\\">text (with) [[nested] (brackets)]</a></p>\\n\",\n\n\t\t\"[text (with) [broken nested] (brackets)]](/url/)\\n\",\n\t\t\"<p>[text (with) <a href=\\\"brackets\\\">broken nested</a>]](/url/)</p>\\n\",\n\n\t\t\"[text\\nwith a newline](/link/)\\n\",\n\t\t\"<p><a href=\\\"/link/\\\">text\\nwith a newline</a></p>\\n\",\n\n\t\t\"[text in brackets] [followed](/by a link/)\\n\",\n\t\t\"<p>[text in brackets] <a href=\\\"/by a link/\\\">followed</a></p>\\n\",\n\n\t\t\"[link with\\\\] a closing bracket](/url/)\\n\",\n\t\t\"<p><a href=\\\"/url/\\\">link with] a closing bracket</a></p>\\n\",\n\n\t\t\"[link with\\\\[ an opening bracket](/url/)\\n\",\n\t\t\"<p><a href=\\\"/url/\\\">link with[ an opening bracket</a></p>\\n\",\n\n\t\t\"[link with\\\\) a closing paren](/url/)\\n\",\n\t\t\"<p><a href=\\\"/url/\\\">link with) a closing paren</a></p>\\n\",\n\n\t\t\"[link with\\\\( an opening paren](/url/)\\n\",\n\t\t\"<p><a href=\\\"/url/\\\">link with( an opening paren</a></p>\\n\",\n\n\t\t\"[link](  with whitespace)\\n\",\n\t\t\"<p><a href=\\\"with whitespace\\\">link</a></p>\\n\",\n\n\t\t\"[link](  with whitespace   )\\n\",\n\t\t\"<p><a href=\\\"with whitespace\\\">link</a></p>\\n\",\n\n\t\t\"[![image](someimage)](with image)\\n\",\n\t\t\"<p><a href=\\\"with image\\\"><img src=\\\"someimage\\\" alt=\\\"image\\\" /></a></p>\\n\",\n\n\t\t\"[link](url \\\"one quote)\\n\",\n\t\t\"<p><a href=\\\"url &quot;one quote\\\">link</a></p>\\n\",\n\n\t\t\"[link](url 'one quote)\\n\",\n\t\t\"<p><a href=\\\"url 'one quote\\\">link</a></p>\\n\",\n\n\t\t\"[link](<url>)\\n\",\n\t\t\"<p><a href=\\\"url\\\">link</a></p>\\n\",\n\n\t\t\"[link & ampersand](/url/)\\n\",\n\t\t\"<p><a href=\\\"/url/\\\">link &amp; ampersand</a></p>\\n\",\n\n\t\t\"[link &amp; ampersand](/url/)\\n\",\n\t\t\"<p><a href=\\\"/url/\\\">link &amp; ampersand</a></p>\\n\",\n\n\t\t\"[link](/url/&query)\\n\",\n\t\t\"<p><a href=\\\"/url/&amp;query\\\">link</a></p>\\n\",\n\n\t\t\"[[t]](/t)\\n\",\n\t\t\"<p><a href=\\\"/t\\\">[t]</a></p>\\n\",\n\n\t\t\"[link](</>)\\n\",\n\t\t\"<p><a href=\\\"/\\\">link</a></p>\\n\",\n\n\t\t\"[link](<./>)\\n\",\n\t\t\"<p><a href=\\\"./\\\">link</a></p>\\n\",\n\n\t\t\"[link](<../>)\\n\",\n\t\t\"<p><a href=\\\"../\\\">link</a></p>\\n\",\n\n\t\t// Issue 116 in blackfriday\n\t\t\"![](http://www.broadgate.co.uk/Content/Upload/DetailImages/Cyclus700(1).jpg)\",\n\t\t\"<p><img src=\\\"http://www.broadgate.co.uk/Content/Upload/DetailImages/Cyclus700(1).jpg\\\" alt=\\\"\\\" /></p>\\n\",\n\n\t\t// no closing ), autolinking detects the url next\n\t\t\"[disambiguation](http://en.wikipedia.org/wiki/Disambiguation_(disambiguation) is the\",\n\t\t\"<p>[disambiguation](<a href=\\\"http://en.wikipedia.org/wiki/Disambiguation_(disambiguation\\\">http://en.wikipedia.org/wiki/Disambiguation_(disambiguation</a>) is the</p>\\n\",\n\n\t\t\"[disambiguation](http://en.wikipedia.org/wiki/Disambiguation_(disambiguation)) is the\",\n\t\t\"<p><a href=\\\"http://en.wikipedia.org/wiki/Disambiguation_(disambiguation)\\\">disambiguation</a> is the</p>\\n\",\n\n\t\t\"[disambiguation](http://en.wikipedia.org/wiki/Disambiguation_(disambiguation))\",\n\t\t\"<p><a href=\\\"http://en.wikipedia.org/wiki/Disambiguation_(disambiguation)\\\">disambiguation</a></p>\\n\",\n\t}\n\tdoLinkTestsInline(t, tests)\n\n}\n\nfunc TestRelAttrLink(t *testing.T) {\n\tvar nofollowTests = []string{\n\t\t\"[foo](http://bar.com/foo/)\\n\",\n\t\t\"<p><a href=\\\"http://bar.com/foo/\\\" rel=\\\"nofollow\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](/bar/)\\n\",\n\t\t\"<p><a href=\\\"/bar/\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](/)\\n\",\n\t\t\"<p><a href=\\\"/\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](./)\\n\",\n\t\t\"<p><a href=\\\"./\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](../)\\n\",\n\t\t\"<p><a href=\\\"../\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](../bar)\\n\",\n\t\t\"<p><a href=\\\"../bar\\\">foo</a></p>\\n\",\n\t}\n\tdoTestsInlineParam(t, nofollowTests, Options{}, HTML_SAFELINK|HTML_NOFOLLOW_LINKS,\n\t\tHtmlRendererParameters{})\n\n\tvar noreferrerTests = []string{\n\t\t\"[foo](http://bar.com/foo/)\\n\",\n\t\t\"<p><a href=\\\"http://bar.com/foo/\\\" rel=\\\"noreferrer\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](/bar/)\\n\",\n\t\t\"<p><a href=\\\"/bar/\\\">foo</a></p>\\n\",\n\t}\n\tdoTestsInlineParam(t, noreferrerTests, Options{}, HTML_SAFELINK|HTML_NOREFERRER_LINKS,\n\t\tHtmlRendererParameters{})\n\n\tvar nofollownoreferrerTests = []string{\n\t\t\"[foo](http://bar.com/foo/)\\n\",\n\t\t\"<p><a href=\\\"http://bar.com/foo/\\\" rel=\\\"nofollow noreferrer\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](/bar/)\\n\",\n\t\t\"<p><a href=\\\"/bar/\\\">foo</a></p>\\n\",\n\t}\n\tdoTestsInlineParam(t, nofollownoreferrerTests, Options{}, HTML_SAFELINK|HTML_NOFOLLOW_LINKS|HTML_NOREFERRER_LINKS,\n\t\tHtmlRendererParameters{})\n\n\tvar noopenerTests = []string{\n\t\t\"[foo](http://bar.com/foo/)\\n\",\n\t\t\"<p><a href=\\\"http://bar.com/foo/\\\" rel=\\\"noopener\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](/bar/)\\n\",\n\t\t\"<p><a href=\\\"/bar/\\\">foo</a></p>\\n\",\n\t}\n\tdoTestsInlineParam(t, noopenerTests, Options{}, HTML_SAFELINK|HTML_NOOPENER_LINKS, HtmlRendererParameters{})\n\n\tvar nofollownoreferrernoopenerTests = []string{\n\t\t\"[foo](http://bar.com/foo/)\\n\",\n\t\t\"<p><a href=\\\"http://bar.com/foo/\\\" rel=\\\"nofollow noreferrer noopener\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](/bar/)\\n\",\n\t\t\"<p><a href=\\\"/bar/\\\">foo</a></p>\\n\",\n\t}\n\tdoTestsInlineParam(t, nofollownoreferrernoopenerTests, Options{},\n\t\tHTML_SAFELINK|HTML_NOOPENER_LINKS|HTML_NOFOLLOW_LINKS|HTML_NOREFERRER_LINKS, HtmlRendererParameters{})\n}\n\nfunc TestHrefTargetBlank(t *testing.T) {\n\tvar tests = []string{\n\t\t// internal link\n\t\t\"[foo](/bar/)\\n\",\n\t\t\"<p><a href=\\\"/bar/\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](/)\\n\",\n\t\t\"<p><a href=\\\"/\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](./)\\n\",\n\t\t\"<p><a href=\\\"./\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](./bar)\\n\",\n\t\t\"<p><a href=\\\"./bar\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](../)\\n\",\n\t\t\"<p><a href=\\\"../\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](../bar)\\n\",\n\t\t\"<p><a href=\\\"../bar\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](http://example.com)\\n\",\n\t\t\"<p><a href=\\\"http://example.com\\\" target=\\\"_blank\\\">foo</a></p>\\n\",\n\t}\n\tdoTestsInlineParam(t, tests, Options{}, HTML_SAFELINK|HTML_HREF_TARGET_BLANK, HtmlRendererParameters{})\n}\n\nfunc TestSafeInlineLink(t *testing.T) {\n\tvar tests = []string{\n\t\t\"[foo](/bar/)\\n\",\n\t\t\"<p><a href=\\\"/bar/\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](/)\\n\",\n\t\t\"<p><a href=\\\"/\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](./)\\n\",\n\t\t\"<p><a href=\\\"./\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](../)\\n\",\n\t\t\"<p><a href=\\\"../\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](http://bar/)\\n\",\n\t\t\"<p><a href=\\\"http://bar/\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](https://bar/)\\n\",\n\t\t\"<p><a href=\\\"https://bar/\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](ftp://bar/)\\n\",\n\t\t\"<p><a href=\\\"ftp://bar/\\\">foo</a></p>\\n\",\n\n\t\t\"[foo](mailto://bar/)\\n\",\n\t\t\"<p><a href=\\\"mailto://bar/\\\">foo</a></p>\\n\",\n\n\t\t// Not considered safe\n\t\t\"[foo](baz://bar/)\\n\",\n\t\t\"<p><tt>foo</tt></p>\\n\",\n\t}\n\tdoSafeTestsInline(t, tests)\n}\n\nfunc TestReferenceLink(t *testing.T) {\n\tvar tests = []string{\n\t\t\"[link][ref]\\n\",\n\t\t\"<p>[link][ref]</p>\\n\",\n\n\t\t\"[link][ref]\\n   [ref]: /url/ \\\"title\\\"\\n\",\n\t\t\"<p><a href=\\\"/url/\\\" title=\\\"title\\\">link</a></p>\\n\",\n\n\t\t\"[link][ref]\\n   [ref]: /url/\\n\",\n\t\t\"<p><a href=\\\"/url/\\\">link</a></p>\\n\",\n\n\t\t\"   [ref]: /url/\\n\",\n\t\t\"\",\n\n\t\t\"   [ref]: /url/\\n[ref2]: /url/\\n [ref3]: /url/\\n\",\n\t\t\"\",\n\n\t\t\"   [ref]: /url/\\n[ref2]: /url/\\n [ref3]: /url/\\n    [4spaces]: /url/\\n\",\n\t\t\"<pre><code>[4spaces]: /url/\\n</code></pre>\\n\",\n\n\t\t\"[hmm](ref2)\\n   [ref]: /url/\\n[ref2]: /url/\\n [ref3]: /url/\\n\",\n\t\t\"<p><a href=\\\"ref2\\\">hmm</a></p>\\n\",\n\n\t\t\"[ref]\\n\",\n\t\t\"<p>[ref]</p>\\n\",\n\n\t\t\"[ref]\\n   [ref]: /url/ \\\"title\\\"\\n\",\n\t\t\"<p><a href=\\\"/url/\\\" title=\\\"title\\\">ref</a></p>\\n\",\n\n\t\t\"[ref]\\n   [ref]: ../url/ \\\"title\\\"\\n\",\n\t\t\"<p><a href=\\\"../url/\\\" title=\\\"title\\\">ref</a></p>\\n\",\n\n\t\t\"[link][ref]\\n   [ref]: /url/\",\n\t\t\"<p><a href=\\\"/url/\\\">link</a></p>\\n\",\n\t}\n\tdoLinkTestsInline(t, tests)\n}\n\nfunc TestTags(t *testing.T) {\n\tvar tests = []string{\n\t\t\"a <span>tag</span>\\n\",\n\t\t\"<p>a <span>tag</span></p>\\n\",\n\n\t\t\"<span>tag</span>\\n\",\n\t\t\"<p><span>tag</span></p>\\n\",\n\n\t\t\"<span>mismatch</spandex>\\n\",\n\t\t\"<p><span>mismatch</spandex></p>\\n\",\n\n\t\t\"a <singleton /> tag\\n\",\n\t\t\"<p>a <singleton /> tag</p>\\n\",\n\t}\n\tdoTestsInline(t, tests)\n}\n\nfunc TestAutoLink(t *testing.T) {\n\tvar tests = []string{\n\t\t\"http://foo.com/\\n\",\n\t\t\"<p><a href=\\\"http://foo.com/\\\">http://foo.com/</a></p>\\n\",\n\n\t\t\"1 http://foo.com/\\n\",\n\t\t\"<p>1 <a href=\\\"http://foo.com/\\\">http://foo.com/</a></p>\\n\",\n\n\t\t\"1http://foo.com/\\n\",\n\t\t\"<p>1<a href=\\\"http://foo.com/\\\">http://foo.com/</a></p>\\n\",\n\n\t\t\"1.http://foo.com/\\n\",\n\t\t\"<p>1.<a href=\\\"http://foo.com/\\\">http://foo.com/</a></p>\\n\",\n\n\t\t\"1. http://foo.com/\\n\",\n\t\t\"<ol>\\n<li><a href=\\\"http://foo.com/\\\">http://foo.com/</a></li>\\n</ol>\\n\",\n\n\t\t\"-http://foo.com/\\n\",\n\t\t\"<p>-<a href=\\\"http://foo.com/\\\">http://foo.com/</a></p>\\n\",\n\n\t\t\"- http://foo.com/\\n\",\n\t\t\"<ul>\\n<li><a href=\\\"http://foo.com/\\\">http://foo.com/</a></li>\\n</ul>\\n\",\n\n\t\t\"_http://foo.com/\\n\",\n\t\t\"<p>_<a href=\\\"http://foo.com/\\\">http://foo.com/</a></p>\\n\",\n\n\t\t\"令狐http://foo.com/\\n\",\n\t\t\"<p>令狐<a href=\\\"http://foo.com/\\\">http://foo.com/</a></p>\\n\",\n\n\t\t\"令狐 http://foo.com/\\n\",\n\t\t\"<p>令狐 <a href=\\\"http://foo.com/\\\">http://foo.com/</a></p>\\n\",\n\n\t\t\"ahttp://foo.com/\\n\",\n\t\t\"<p>ahttp://foo.com/</p>\\n\",\n\n\t\t\">http://foo.com/\\n\",\n\t\t\"<blockquote>\\n<p><a href=\\\"http://foo.com/\\\">http://foo.com/</a></p>\\n</blockquote>\\n\",\n\n\t\t\"> http://foo.com/\\n\",\n\t\t\"<blockquote>\\n<p><a href=\\\"http://foo.com/\\\">http://foo.com/</a></p>\\n</blockquote>\\n\",\n\n\t\t\"go to <http://foo.com/>\\n\",\n\t\t\"<p>go to <a href=\\\"http://foo.com/\\\">http://foo.com/</a></p>\\n\",\n\n\t\t\"a secure <https://link.org>\\n\",\n\t\t\"<p>a secure <a href=\\\"https://link.org\\\">https://link.org</a></p>\\n\",\n\n\t\t\"an email <mailto:some@one.com>\\n\",\n\t\t\"<p>an email <a href=\\\"mailto:some@one.com\\\">some@one.com</a></p>\\n\",\n\n\t\t\"an email <mailto://some@one.com>\\n\",\n\t\t\"<p>an email <a href=\\\"mailto://some@one.com\\\">some@one.com</a></p>\\n\",\n\n\t\t\"an email <some@one.com>\\n\",\n\t\t\"<p>an email <a href=\\\"mailto:some@one.com\\\">some@one.com</a></p>\\n\",\n\n\t\t\"an ftp <ftp://old.com>\\n\",\n\t\t\"<p>an ftp <a href=\\\"ftp://old.com\\\">ftp://old.com</a></p>\\n\",\n\n\t\t\"an ftp <ftp:old.com>\\n\",\n\t\t\"<p>an ftp <a href=\\\"ftp:old.com\\\">ftp:old.com</a></p>\\n\",\n\n\t\t\"a link with <http://new.com?query=foo&bar>\\n\",\n\t\t\"<p>a link with <a href=\\\"http://new.com?query=foo&amp;bar\\\">\" +\n\t\t\t\"http://new.com?query=foo&amp;bar</a></p>\\n\",\n\n\t\t\"quotes mean a tag <http://new.com?query=\\\"foo\\\"&bar>\\n\",\n\t\t\"<p>quotes mean a tag <http://new.com?query=\\\"foo\\\"&bar></p>\\n\",\n\n\t\t\"quotes mean a tag <http://new.com?query='foo'&bar>\\n\",\n\t\t\"<p>quotes mean a tag <http://new.com?query='foo'&bar></p>\\n\",\n\n\t\t\"unless escaped <http://new.com?query=\\\\\\\"foo\\\\\\\"&bar>\\n\",\n\t\t\"<p>unless escaped <a href=\\\"http://new.com?query=&quot;foo&quot;&amp;bar\\\">\" +\n\t\t\t\"http://new.com?query=&quot;foo&quot;&amp;bar</a></p>\\n\",\n\n\t\t\"even a > can be escaped <http://new.com?q=\\\\>&etc>\\n\",\n\t\t\"<p>even a &gt; can be escaped <a href=\\\"http://new.com?q=&gt;&amp;etc\\\">\" +\n\t\t\t\"http://new.com?q=&gt;&amp;etc</a></p>\\n\",\n\n\t\t\"<a href=\\\"http://fancy.com\\\">http://fancy.com</a>\\n\",\n\t\t\"<p><a href=\\\"http://fancy.com\\\">http://fancy.com</a></p>\\n\",\n\n\t\t\"<a href=\\\"http://fancy.com\\\">This is a link</a>\\n\",\n\t\t\"<p><a href=\\\"http://fancy.com\\\">This is a link</a></p>\\n\",\n\n\t\t\"<a href=\\\"http://www.fancy.com/A_B.pdf\\\">http://www.fancy.com/A_B.pdf</a>\\n\",\n\t\t\"<p><a href=\\\"http://www.fancy.com/A_B.pdf\\\">http://www.fancy.com/A_B.pdf</a></p>\\n\",\n\n\t\t\"(<a href=\\\"http://www.fancy.com/A_B\\\">http://www.fancy.com/A_B</a> (\\n\",\n\t\t\"<p>(<a href=\\\"http://www.fancy.com/A_B\\\">http://www.fancy.com/A_B</a> (</p>\\n\",\n\n\t\t\"(<a href=\\\"http://www.fancy.com/A_B\\\">http://www.fancy.com/A_B</a> (part two: <a href=\\\"http://www.fancy.com/A_B\\\">http://www.fancy.com/A_B</a>)).\\n\",\n\t\t\"<p>(<a href=\\\"http://www.fancy.com/A_B\\\">http://www.fancy.com/A_B</a> (part two: <a href=\\\"http://www.fancy.com/A_B\\\">http://www.fancy.com/A_B</a>)).</p>\\n\",\n\n\t\t\"http://www.foo.com<br />\\n\",\n\t\t\"<p><a href=\\\"http://www.foo.com\\\">http://www.foo.com</a><br /></p>\\n\",\n\n\t\t\"http://foo.com/viewtopic.php?f=18&amp;t=297\",\n\t\t\"<p><a href=\\\"http://foo.com/viewtopic.php?f=18&amp;t=297\\\">http://foo.com/viewtopic.php?f=18&amp;t=297</a></p>\\n\",\n\n\t\t\"http://foo.com/viewtopic.php?param=&quot;18&quot;zz\",\n\t\t\"<p><a href=\\\"http://foo.com/viewtopic.php?param=&quot;18&quot;zz\\\">http://foo.com/viewtopic.php?param=&quot;18&quot;zz</a></p>\\n\",\n\n\t\t\"http://foo.com/viewtopic.php?param=&quot;18&quot;\",\n\t\t\"<p><a href=\\\"http://foo.com/viewtopic.php?param=&quot;18&quot;\\\">http://foo.com/viewtopic.php?param=&quot;18&quot;</a></p>\\n\",\n\t}\n\tdoLinkTestsInline(t, tests)\n}\n\nvar footnoteTests = []string{\n\t\"testing footnotes.[^a]\\n\\n[^a]: This is the note\\n\",\n\t`<p>testing footnotes.<sup class=\"footnote-ref\" id=\"fnref:a\"><a href=\"#fn:a\">1</a></sup></p>\n<div class=\"footnotes\">\n\n<hr />\n\n<ol>\n<li id=\"fn:a\">This is the note\n</li>\n</ol>\n</div>\n`,\n\n\t`testing long[^b] notes.\n\n[^b]: Paragraph 1\n\n\tParagraph 2\n\n\t` + \"```\\n\\tsome code\\n\\t```\" + `\n\n\tParagraph 3\n\nNo longer in the footnote\n`,\n\t`<p>testing long<sup class=\"footnote-ref\" id=\"fnref:b\"><a href=\"#fn:b\">1</a></sup> notes.</p>\n\n<p>No longer in the footnote</p>\n<div class=\"footnotes\">\n\n<hr />\n\n<ol>\n<li id=\"fn:b\"><p>Paragraph 1</p>\n\n<p>Paragraph 2</p>\n\n<p><code>\nsome code\n</code></p>\n\n<p>Paragraph 3</p>\n</li>\n</ol>\n</div>\n`,\n\n\t`testing[^c] multiple[^d] notes.\n\n[^c]: this is [note] c\n\n\nomg\n\n[^d]: this is note d\n\nwhat happens here\n\n[note]: /link/c\n\n`,\n\t`<p>testing<sup class=\"footnote-ref\" id=\"fnref:c\"><a href=\"#fn:c\">1</a></sup> multiple<sup class=\"footnote-ref\" id=\"fnref:d\"><a href=\"#fn:d\">2</a></sup> notes.</p>\n\n<p>omg</p>\n\n<p>what happens here</p>\n<div class=\"footnotes\">\n\n<hr />\n\n<ol>\n<li id=\"fn:c\">this is <a href=\"/link/c\">note</a> c\n</li>\n<li id=\"fn:d\">this is note d\n</li>\n</ol>\n</div>\n`,\n\n\t\"testing inline^[this is the note] notes.\\n\",\n\t`<p>testing inline<sup class=\"footnote-ref\" id=\"fnref:this-is-the-note\"><a href=\"#fn:this-is-the-note\">1</a></sup> notes.</p>\n<div class=\"footnotes\">\n\n<hr />\n\n<ol>\n<li id=\"fn:this-is-the-note\">this is the note</li>\n</ol>\n</div>\n`,\n\n\t\"testing multiple[^1] types^[inline note] of notes[^2]\\n\\n[^2]: the second deferred note\\n[^1]: the first deferred note\\n\\n\\twhich happens to be a block\\n\",\n\t`<p>testing multiple<sup class=\"footnote-ref\" id=\"fnref:1\"><a href=\"#fn:1\">1</a></sup> types<sup class=\"footnote-ref\" id=\"fnref:inline-note\"><a href=\"#fn:inline-note\">2</a></sup> of notes<sup class=\"footnote-ref\" id=\"fnref:2\"><a href=\"#fn:2\">3</a></sup></p>\n<div class=\"footnotes\">\n\n<hr />\n\n<ol>\n<li id=\"fn:1\"><p>the first deferred note</p>\n\n<p>which happens to be a block</p>\n</li>\n<li id=\"fn:inline-note\">inline note</li>\n<li id=\"fn:2\">the second deferred note\n</li>\n</ol>\n</div>\n`,\n\n\t`This is a footnote[^1]^[and this is an inline footnote]\n\n[^1]: the footnote text.\n\n    may be multiple paragraphs.\n`,\n\t`<p>This is a footnote<sup class=\"footnote-ref\" id=\"fnref:1\"><a href=\"#fn:1\">1</a></sup><sup class=\"footnote-ref\" id=\"fnref:and-this-is-an-i\"><a href=\"#fn:and-this-is-an-i\">2</a></sup></p>\n<div class=\"footnotes\">\n\n<hr />\n\n<ol>\n<li id=\"fn:1\"><p>the footnote text.</p>\n\n<p>may be multiple paragraphs.</p>\n</li>\n<li id=\"fn:and-this-is-an-i\">and this is an inline footnote</li>\n</ol>\n</div>\n`,\n\n\t\"empty footnote[^]\\n\\n[^]: fn text\",\n\t\"<p>empty footnote<sup class=\\\"footnote-ref\\\" id=\\\"fnref:\\\"><a href=\\\"#fn:\\\">1</a></sup></p>\\n<div class=\\\"footnotes\\\">\\n\\n<hr />\\n\\n<ol>\\n<li id=\\\"fn:\\\">fn text\\n</li>\\n</ol>\\n</div>\\n\",\n\n\t\"Some text.[^note1]\\n\\n[^note1]: fn1\",\n\t\"<p>Some text.<sup class=\\\"footnote-ref\\\" id=\\\"fnref:note1\\\"><a href=\\\"#fn:note1\\\">1</a></sup></p>\\n<div class=\\\"footnotes\\\">\\n\\n<hr />\\n\\n<ol>\\n<li id=\\\"fn:note1\\\">fn1\\n</li>\\n</ol>\\n</div>\\n\",\n\n\t\"Some text.[^note1][^note2]\\n\\n[^note1]: fn1\\n[^note2]: fn2\\n\",\n\t\"<p>Some text.<sup class=\\\"footnote-ref\\\" id=\\\"fnref:note1\\\"><a href=\\\"#fn:note1\\\">1</a></sup><sup class=\\\"footnote-ref\\\" id=\\\"fnref:note2\\\"><a href=\\\"#fn:note2\\\">2</a></sup></p>\\n<div class=\\\"footnotes\\\">\\n\\n<hr />\\n\\n<ol>\\n<li id=\\\"fn:note1\\\">fn1\\n</li>\\n<li id=\\\"fn:note2\\\">fn2\\n</li>\\n</ol>\\n</div>\\n\",\n\n\t`Bla bla [^1] [WWW][w3]\n\n[^1]: This is a footnote\n\n[w3]: http://www.w3.org/\n`,\n\t`<p>Bla bla <sup class=\"footnote-ref\" id=\"fnref:1\"><a href=\"#fn:1\">1</a></sup> <a href=\"http://www.w3.org/\">WWW</a></p>\n<div class=\"footnotes\">\n\n<hr />\n\n<ol>\n<li id=\"fn:1\">This is a footnote\n</li>\n</ol>\n</div>\n`,\n\n\t`This is exciting![^fn1]\n\n[^fn1]: Fine print\n`,\n\t`<p>This is exciting!<sup class=\"footnote-ref\" id=\"fnref:fn1\"><a href=\"#fn:fn1\">1</a></sup></p>\n<div class=\"footnotes\">\n\n<hr />\n\n<ol>\n<li id=\"fn:fn1\">Fine print\n</li>\n</ol>\n</div>\n`,\n\t`testing footnotes.[^a]\n\ntest footnotes the second.[^b]\n\n[^a]: This is the first note[^a].\n[^b]: this is the second note.[^a]\n`,\n\t`<p>testing footnotes.<sup class=\"footnote-ref\" id=\"fnref:a\"><a href=\"#fn:a\">1</a></sup></p>\n\n<p>test footnotes the second.<sup class=\"footnote-ref\" id=\"fnref:b\"><a href=\"#fn:b\">2</a></sup></p>\n<div class=\"footnotes\">\n\n<hr />\n\n<ol>\n<li id=\"fn:a\">This is the first note<sup class=\"footnote-ref\" id=\"fnref:a\"><a href=\"#fn:a\">1</a></sup>.\n</li>\n<li id=\"fn:b\">this is the second note.<sup class=\"footnote-ref\" id=\"fnref:a\"><a href=\"#fn:a\">1</a></sup>\n</li>\n</ol>\n</div>\n`,\n}\n\nfunc TestFootnotes(t *testing.T) {\n\tdoTestsInlineParam(t, footnoteTests, Options{Extensions: EXTENSION_FOOTNOTES}, 0, HtmlRendererParameters{})\n}\n\nfunc TestFootnotesWithParameters(t *testing.T) {\n\ttests := make([]string, len(footnoteTests))\n\n\tprefix := \"testPrefix\"\n\treturnText := \"ret\"\n\tre := regexp.MustCompile(`(?ms)<li id=\"fn:(\\S+?)\">(.*?)</li>`)\n\n\t// Transform the test expectations to match the parameters we're using.\n\tfor i, test := range footnoteTests {\n\t\tif i%2 == 1 {\n\t\t\ttest = strings.Replace(test, \"fn:\", \"fn:\"+prefix, -1)\n\t\t\ttest = strings.Replace(test, \"fnref:\", \"fnref:\"+prefix, -1)\n\t\t\ttest = re.ReplaceAllString(test, `<li id=\"fn:$1\">$2 <a class=\"footnote-return\" href=\"#fnref:$1\">ret</a></li>`)\n\t\t}\n\t\ttests[i] = test\n\t}\n\n\tparams := HtmlRendererParameters{\n\t\tFootnoteAnchorPrefix:       prefix,\n\t\tFootnoteReturnLinkContents: returnText,\n\t}\n\n\tdoTestsInlineParam(t, tests, Options{Extensions: EXTENSION_FOOTNOTES}, HTML_FOOTNOTE_RETURN_LINKS, params)\n}\n\nfunc TestNestedFootnotes(t *testing.T) {\n\tvar tests = []string{\n\t\t`Paragraph.[^fn1]\n\n[^fn1]:\n  Asterisk[^fn2]\n\n[^fn2]:\n  Obelisk`,\n\t\t`<p>Paragraph.<sup class=\"footnote-ref\" id=\"fnref:fn1\"><a href=\"#fn:fn1\">1</a></sup></p>\n<div class=\"footnotes\">\n\n<hr />\n\n<ol>\n<li id=\"fn:fn1\">Asterisk<sup class=\"footnote-ref\" id=\"fnref:fn2\"><a href=\"#fn:fn2\">2</a></sup>\n</li>\n<li id=\"fn:fn2\">Obelisk\n</li>\n</ol>\n</div>\n`,\n\t\t`This uses footnote A.[^A]\n\nThis uses footnote C.[^C]\n\n[^A]:\n  A note. use itself.[^A]\n[^B]:\n  B note, uses A to test duplicate.[^A]\n[^C]:\n  C note, uses B.[^B]\n`,\n\t\t`<p>This uses footnote A.<sup class=\"footnote-ref\" id=\"fnref:A\"><a href=\"#fn:A\">1</a></sup></p>\n\n<p>This uses footnote C.<sup class=\"footnote-ref\" id=\"fnref:C\"><a href=\"#fn:C\">2</a></sup></p>\n<div class=\"footnotes\">\n\n<hr />\n\n<ol>\n<li id=\"fn:A\">A note. use itself.<sup class=\"footnote-ref\" id=\"fnref:A\"><a href=\"#fn:A\">1</a></sup>\n</li>\n<li id=\"fn:C\">C note, uses B.<sup class=\"footnote-ref\" id=\"fnref:B\"><a href=\"#fn:B\">3</a></sup>\n</li>\n<li id=\"fn:B\">B note, uses A to test duplicate.<sup class=\"footnote-ref\" id=\"fnref:A\"><a href=\"#fn:A\">1</a></sup>\n</li>\n</ol>\n</div>\n`,\n\t}\n\tdoTestsInlineParam(t, tests, Options{Extensions: EXTENSION_FOOTNOTES}, 0,\n\t\tHtmlRendererParameters{})\n}\n\nfunc TestInlineComments(t *testing.T) {\n\tvar tests = []string{\n\t\t\"Hello <!-- there ->\\n\",\n\t\t\"<p>Hello &lt;!&mdash; there &ndash;&gt;</p>\\n\",\n\n\t\t\"Hello <!-- there -->\\n\",\n\t\t\"<p>Hello <!-- there --></p>\\n\",\n\n\t\t\"Hello <!-- there -->\",\n\t\t\"<p>Hello <!-- there --></p>\\n\",\n\n\t\t\"Hello <!---->\\n\",\n\t\t\"<p>Hello <!----></p>\\n\",\n\n\t\t\"Hello <!-- there -->\\na\",\n\t\t\"<p>Hello <!-- there -->\\na</p>\\n\",\n\n\t\t\"* list <!-- item -->\\n\",\n\t\t\"<ul>\\n<li>list <!-- item --></li>\\n</ul>\\n\",\n\n\t\t\"<!-- Front --> comment\\n\",\n\t\t\"<p><!-- Front --> comment</p>\\n\",\n\n\t\t\"blahblah\\n<!--- foo -->\\nrhubarb\\n\",\n\t\t\"<p>blahblah\\n<!--- foo -->\\nrhubarb</p>\\n\",\n\t}\n\tdoTestsInlineParam(t, tests, Options{}, HTML_USE_SMARTYPANTS|HTML_SMARTYPANTS_DASHES, HtmlRendererParameters{})\n}\n\nfunc TestSmartDoubleQuotes(t *testing.T) {\n\tvar tests = []string{\n\t\t\"this should be normal \\\"quoted\\\" text.\\n\",\n\t\t\"<p>this should be normal &ldquo;quoted&rdquo; text.</p>\\n\",\n\t\t\"this \\\" single double\\n\",\n\t\t\"<p>this &ldquo; single double</p>\\n\",\n\t\t\"two pair of \\\"some\\\" quoted \\\"text\\\".\\n\",\n\t\t\"<p>two pair of &ldquo;some&rdquo; quoted &ldquo;text&rdquo;.</p>\\n\"}\n\n\tdoTestsInlineParam(t, tests, Options{}, HTML_USE_SMARTYPANTS, HtmlRendererParameters{})\n}\n\nfunc TestSmartDoubleQuotesNbsp(t *testing.T) {\n\tvar tests = []string{\n\t\t\"this should be normal \\\"quoted\\\" text.\\n\",\n\t\t\"<p>this should be normal &ldquo;&nbsp;quoted&nbsp;&rdquo; text.</p>\\n\",\n\t\t\"this \\\" single double\\n\",\n\t\t\"<p>this &ldquo;&nbsp; single double</p>\\n\",\n\t\t\"two pair of \\\"some\\\" quoted \\\"text\\\".\\n\",\n\t\t\"<p>two pair of &ldquo;&nbsp;some&nbsp;&rdquo; quoted &ldquo;&nbsp;text&nbsp;&rdquo;.</p>\\n\"}\n\n\tdoTestsInlineParam(t, tests, Options{}, HTML_USE_SMARTYPANTS|HTML_SMARTYPANTS_QUOTES_NBSP, HtmlRendererParameters{})\n}\n\nfunc TestSmartAngledDoubleQuotes(t *testing.T) {\n\tvar tests = []string{\n\t\t\"this should be angled \\\"quoted\\\" text.\\n\",\n\t\t\"<p>this should be angled &laquo;quoted&raquo; text.</p>\\n\",\n\t\t\"this \\\" single double\\n\",\n\t\t\"<p>this &laquo; single double</p>\\n\",\n\t\t\"two pair of \\\"some\\\" quoted \\\"text\\\".\\n\",\n\t\t\"<p>two pair of &laquo;some&raquo; quoted &laquo;text&raquo;.</p>\\n\"}\n\n\tdoTestsInlineParam(t, tests, Options{}, HTML_USE_SMARTYPANTS|HTML_SMARTYPANTS_ANGLED_QUOTES, HtmlRendererParameters{})\n}\n\nfunc TestSmartAngledDoubleQuotesNbsp(t *testing.T) {\n\tvar tests = []string{\n\t\t\"this should be angled \\\"quoted\\\" text.\\n\",\n\t\t\"<p>this should be angled &laquo;&nbsp;quoted&nbsp;&raquo; text.</p>\\n\",\n\t\t\"this \\\" single double\\n\",\n\t\t\"<p>this &laquo;&nbsp; single double</p>\\n\",\n\t\t\"two pair of \\\"some\\\" quoted \\\"text\\\".\\n\",\n\t\t\"<p>two pair of &laquo;&nbsp;some&nbsp;&raquo; quoted &laquo;&nbsp;text&nbsp;&raquo;.</p>\\n\"}\n\n\tdoTestsInlineParam(t, tests, Options{}, HTML_USE_SMARTYPANTS|HTML_SMARTYPANTS_ANGLED_QUOTES|HTML_SMARTYPANTS_QUOTES_NBSP, HtmlRendererParameters{})\n}\n\nfunc TestSmartFractions(t *testing.T) {\n\tvar tests = []string{\n\t\t\"1/2, 1/4 and 3/4; 1/4th and 3/4ths\\n\",\n\t\t\"<p>&frac12;, &frac14; and &frac34;; &frac14;th and &frac34;ths</p>\\n\",\n\t\t\"1/2/2015, 1/4/2015, 3/4/2015; 2015/1/2, 2015/1/4, 2015/3/4.\\n\",\n\t\t\"<p>1/2/2015, 1/4/2015, 3/4/2015; 2015/1/2, 2015/1/4, 2015/3/4.</p>\\n\"}\n\n\tdoTestsInlineParam(t, tests, Options{}, HTML_USE_SMARTYPANTS, HtmlRendererParameters{})\n\n\ttests = []string{\n\t\t\"1/2, 2/3, 81/100 and 1000000/1048576.\\n\",\n\t\t\"<p><sup>1</sup>&frasl;<sub>2</sub>, <sup>2</sup>&frasl;<sub>3</sub>, <sup>81</sup>&frasl;<sub>100</sub> and <sup>1000000</sup>&frasl;<sub>1048576</sub>.</p>\\n\",\n\t\t\"1/2/2015, 1/4/2015, 3/4/2015; 2015/1/2, 2015/1/4, 2015/3/4.\\n\",\n\t\t\"<p>1/2/2015, 1/4/2015, 3/4/2015; 2015/1/2, 2015/1/4, 2015/3/4.</p>\\n\"}\n\n\tdoTestsInlineParam(t, tests, Options{}, HTML_USE_SMARTYPANTS|HTML_SMARTYPANTS_FRACTIONS, HtmlRendererParameters{})\n}\n\nfunc TestDisableSmartDashes(t *testing.T) {\n\tdoTestsInlineParam(t, []string{\n\t\t\"foo - bar\\n\",\n\t\t\"<p>foo - bar</p>\\n\",\n\t\t\"foo -- bar\\n\",\n\t\t\"<p>foo -- bar</p>\\n\",\n\t\t\"foo --- bar\\n\",\n\t\t\"<p>foo --- bar</p>\\n\",\n\t}, Options{}, 0, HtmlRendererParameters{})\n\tdoTestsInlineParam(t, []string{\n\t\t\"foo - bar\\n\",\n\t\t\"<p>foo &ndash; bar</p>\\n\",\n\t\t\"foo -- bar\\n\",\n\t\t\"<p>foo &mdash; bar</p>\\n\",\n\t\t\"foo --- bar\\n\",\n\t\t\"<p>foo &mdash;&ndash; bar</p>\\n\",\n\t}, Options{}, HTML_USE_SMARTYPANTS|HTML_SMARTYPANTS_DASHES, HtmlRendererParameters{})\n\tdoTestsInlineParam(t, []string{\n\t\t\"foo - bar\\n\",\n\t\t\"<p>foo - bar</p>\\n\",\n\t\t\"foo -- bar\\n\",\n\t\t\"<p>foo &ndash; bar</p>\\n\",\n\t\t\"foo --- bar\\n\",\n\t\t\"<p>foo &mdash; bar</p>\\n\",\n\t}, Options{}, HTML_USE_SMARTYPANTS|HTML_SMARTYPANTS_LATEX_DASHES|HTML_SMARTYPANTS_DASHES,\n\t\tHtmlRendererParameters{})\n\tdoTestsInlineParam(t, []string{\n\t\t\"foo - bar\\n\",\n\t\t\"<p>foo - bar</p>\\n\",\n\t\t\"foo -- bar\\n\",\n\t\t\"<p>foo -- bar</p>\\n\",\n\t\t\"foo --- bar\\n\",\n\t\t\"<p>foo --- bar</p>\\n\",\n\t}, Options{},\n\t\tHTML_USE_SMARTYPANTS|HTML_SMARTYPANTS_LATEX_DASHES,\n\t\tHtmlRendererParameters{})\n}\n\nfunc BenchmarkSmartDoubleQuotes(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\trunMarkdownInline(\"this should be normal \\\"quoted\\\" text.\\n\", Options{}, HTML_USE_SMARTYPANTS, HtmlRendererParameters{})\n\t}\n}\n"
        },
        {
          "name": "latex.go",
          "type": "blob",
          "size": 7.796875,
          "content": "//\n// Blackfriday Markdown Processor\n// Available at http://github.com/russross/blackfriday\n//\n// Copyright © 2011 Russ Ross <russ@russross.com>.\n// Distributed under the Simplified BSD License.\n// See README.md for details.\n//\n\n//\n//\n// LaTeX rendering backend\n//\n//\n\npackage blackfriday\n\nimport (\n\t\"bytes\"\n\t\"strings\"\n)\n\n// Latex is a type that implements the Renderer interface for LaTeX output.\n//\n// Do not create this directly, instead use the LatexRenderer function.\ntype Latex struct {\n}\n\n// LatexRenderer creates and configures a Latex object, which\n// satisfies the Renderer interface.\n//\n// flags is a set of LATEX_* options ORed together (currently no such options\n// are defined).\nfunc LatexRenderer(flags int) Renderer {\n\treturn &Latex{}\n}\n\nfunc (options *Latex) GetFlags() int {\n\treturn 0\n}\n\n// render code chunks using verbatim, or listings if we have a language\nfunc (options *Latex) BlockCode(out *bytes.Buffer, text []byte, info string) {\n\tif info == \"\" {\n\t\tout.WriteString(\"\\n\\\\begin{verbatim}\\n\")\n\t} else {\n\t\tlang := strings.Fields(info)[0]\n\t\tout.WriteString(\"\\n\\\\begin{lstlisting}[language=\")\n\t\tout.WriteString(lang)\n\t\tout.WriteString(\"]\\n\")\n\t}\n\tout.Write(text)\n\tif info == \"\" {\n\t\tout.WriteString(\"\\n\\\\end{verbatim}\\n\")\n\t} else {\n\t\tout.WriteString(\"\\n\\\\end{lstlisting}\\n\")\n\t}\n}\n\nfunc (options *Latex) TitleBlock(out *bytes.Buffer, text []byte) {\n\n}\n\nfunc (options *Latex) BlockQuote(out *bytes.Buffer, text []byte) {\n\tout.WriteString(\"\\n\\\\begin{quotation}\\n\")\n\tout.Write(text)\n\tout.WriteString(\"\\n\\\\end{quotation}\\n\")\n}\n\nfunc (options *Latex) BlockHtml(out *bytes.Buffer, text []byte) {\n\t// a pretty lame thing to do...\n\tout.WriteString(\"\\n\\\\begin{verbatim}\\n\")\n\tout.Write(text)\n\tout.WriteString(\"\\n\\\\end{verbatim}\\n\")\n}\n\nfunc (options *Latex) Header(out *bytes.Buffer, text func() bool, level int, id string) {\n\tmarker := out.Len()\n\n\tswitch level {\n\tcase 1:\n\t\tout.WriteString(\"\\n\\\\section{\")\n\tcase 2:\n\t\tout.WriteString(\"\\n\\\\subsection{\")\n\tcase 3:\n\t\tout.WriteString(\"\\n\\\\subsubsection{\")\n\tcase 4:\n\t\tout.WriteString(\"\\n\\\\paragraph{\")\n\tcase 5:\n\t\tout.WriteString(\"\\n\\\\subparagraph{\")\n\tcase 6:\n\t\tout.WriteString(\"\\n\\\\textbf{\")\n\t}\n\tif !text() {\n\t\tout.Truncate(marker)\n\t\treturn\n\t}\n\tout.WriteString(\"}\\n\")\n}\n\nfunc (options *Latex) HRule(out *bytes.Buffer) {\n\tout.WriteString(\"\\n\\\\HRule\\n\")\n}\n\nfunc (options *Latex) List(out *bytes.Buffer, text func() bool, flags int) {\n\tmarker := out.Len()\n\tif flags&LIST_TYPE_ORDERED != 0 {\n\t\tout.WriteString(\"\\n\\\\begin{enumerate}\\n\")\n\t} else {\n\t\tout.WriteString(\"\\n\\\\begin{itemize}\\n\")\n\t}\n\tif !text() {\n\t\tout.Truncate(marker)\n\t\treturn\n\t}\n\tif flags&LIST_TYPE_ORDERED != 0 {\n\t\tout.WriteString(\"\\n\\\\end{enumerate}\\n\")\n\t} else {\n\t\tout.WriteString(\"\\n\\\\end{itemize}\\n\")\n\t}\n}\n\nfunc (options *Latex) ListItem(out *bytes.Buffer, text []byte, flags int) {\n\tout.WriteString(\"\\n\\\\item \")\n\tout.Write(text)\n}\n\nfunc (options *Latex) Paragraph(out *bytes.Buffer, text func() bool) {\n\tmarker := out.Len()\n\tout.WriteString(\"\\n\")\n\tif !text() {\n\t\tout.Truncate(marker)\n\t\treturn\n\t}\n\tout.WriteString(\"\\n\")\n}\n\nfunc (options *Latex) Table(out *bytes.Buffer, header []byte, body []byte, columnData []int) {\n\tout.WriteString(\"\\n\\\\begin{tabular}{\")\n\tfor _, elt := range columnData {\n\t\tswitch elt {\n\t\tcase TABLE_ALIGNMENT_LEFT:\n\t\t\tout.WriteByte('l')\n\t\tcase TABLE_ALIGNMENT_RIGHT:\n\t\t\tout.WriteByte('r')\n\t\tdefault:\n\t\t\tout.WriteByte('c')\n\t\t}\n\t}\n\tout.WriteString(\"}\\n\")\n\tout.Write(header)\n\tout.WriteString(\" \\\\\\\\\\n\\\\hline\\n\")\n\tout.Write(body)\n\tout.WriteString(\"\\n\\\\end{tabular}\\n\")\n}\n\nfunc (options *Latex) TableRow(out *bytes.Buffer, text []byte) {\n\tif out.Len() > 0 {\n\t\tout.WriteString(\" \\\\\\\\\\n\")\n\t}\n\tout.Write(text)\n}\n\nfunc (options *Latex) TableHeaderCell(out *bytes.Buffer, text []byte, align int) {\n\tif out.Len() > 0 {\n\t\tout.WriteString(\" & \")\n\t}\n\tout.Write(text)\n}\n\nfunc (options *Latex) TableCell(out *bytes.Buffer, text []byte, align int) {\n\tif out.Len() > 0 {\n\t\tout.WriteString(\" & \")\n\t}\n\tout.Write(text)\n}\n\n// TODO: this\nfunc (options *Latex) Footnotes(out *bytes.Buffer, text func() bool) {\n\n}\n\nfunc (options *Latex) FootnoteItem(out *bytes.Buffer, name, text []byte, flags int) {\n\n}\n\nfunc (options *Latex) AutoLink(out *bytes.Buffer, link []byte, kind int) {\n\tout.WriteString(\"\\\\href{\")\n\tif kind == LINK_TYPE_EMAIL {\n\t\tout.WriteString(\"mailto:\")\n\t}\n\tout.Write(link)\n\tout.WriteString(\"}{\")\n\tout.Write(link)\n\tout.WriteString(\"}\")\n}\n\nfunc (options *Latex) CodeSpan(out *bytes.Buffer, text []byte) {\n\tout.WriteString(\"\\\\texttt{\")\n\tescapeSpecialChars(out, text)\n\tout.WriteString(\"}\")\n}\n\nfunc (options *Latex) DoubleEmphasis(out *bytes.Buffer, text []byte) {\n\tout.WriteString(\"\\\\textbf{\")\n\tout.Write(text)\n\tout.WriteString(\"}\")\n}\n\nfunc (options *Latex) Emphasis(out *bytes.Buffer, text []byte) {\n\tout.WriteString(\"\\\\textit{\")\n\tout.Write(text)\n\tout.WriteString(\"}\")\n}\n\nfunc (options *Latex) Image(out *bytes.Buffer, link []byte, title []byte, alt []byte) {\n\tif bytes.HasPrefix(link, []byte(\"http://\")) || bytes.HasPrefix(link, []byte(\"https://\")) {\n\t\t// treat it like a link\n\t\tout.WriteString(\"\\\\href{\")\n\t\tout.Write(link)\n\t\tout.WriteString(\"}{\")\n\t\tout.Write(alt)\n\t\tout.WriteString(\"}\")\n\t} else {\n\t\tout.WriteString(\"\\\\includegraphics{\")\n\t\tout.Write(link)\n\t\tout.WriteString(\"}\")\n\t}\n}\n\nfunc (options *Latex) LineBreak(out *bytes.Buffer) {\n\tout.WriteString(\" \\\\\\\\\\n\")\n}\n\nfunc (options *Latex) Link(out *bytes.Buffer, link []byte, title []byte, content []byte) {\n\tout.WriteString(\"\\\\href{\")\n\tout.Write(link)\n\tout.WriteString(\"}{\")\n\tout.Write(content)\n\tout.WriteString(\"}\")\n}\n\nfunc (options *Latex) RawHtmlTag(out *bytes.Buffer, tag []byte) {\n}\n\nfunc (options *Latex) TripleEmphasis(out *bytes.Buffer, text []byte) {\n\tout.WriteString(\"\\\\textbf{\\\\textit{\")\n\tout.Write(text)\n\tout.WriteString(\"}}\")\n}\n\nfunc (options *Latex) StrikeThrough(out *bytes.Buffer, text []byte) {\n\tout.WriteString(\"\\\\sout{\")\n\tout.Write(text)\n\tout.WriteString(\"}\")\n}\n\n// TODO: this\nfunc (options *Latex) FootnoteRef(out *bytes.Buffer, ref []byte, id int) {\n\n}\n\nfunc needsBackslash(c byte) bool {\n\tfor _, r := range []byte(\"_{}%$&\\\\~#\") {\n\t\tif c == r {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc escapeSpecialChars(out *bytes.Buffer, text []byte) {\n\tfor i := 0; i < len(text); i++ {\n\t\t// directly copy normal characters\n\t\torg := i\n\n\t\tfor i < len(text) && !needsBackslash(text[i]) {\n\t\t\ti++\n\t\t}\n\t\tif i > org {\n\t\t\tout.Write(text[org:i])\n\t\t}\n\n\t\t// escape a character\n\t\tif i >= len(text) {\n\t\t\tbreak\n\t\t}\n\t\tout.WriteByte('\\\\')\n\t\tout.WriteByte(text[i])\n\t}\n}\n\nfunc (options *Latex) Entity(out *bytes.Buffer, entity []byte) {\n\t// TODO: convert this into a unicode character or something\n\tout.Write(entity)\n}\n\nfunc (options *Latex) NormalText(out *bytes.Buffer, text []byte) {\n\tescapeSpecialChars(out, text)\n}\n\n// header and footer\nfunc (options *Latex) DocumentHeader(out *bytes.Buffer) {\n\tout.WriteString(\"\\\\documentclass{article}\\n\")\n\tout.WriteString(\"\\n\")\n\tout.WriteString(\"\\\\usepackage{graphicx}\\n\")\n\tout.WriteString(\"\\\\usepackage{listings}\\n\")\n\tout.WriteString(\"\\\\usepackage[margin=1in]{geometry}\\n\")\n\tout.WriteString(\"\\\\usepackage[utf8]{inputenc}\\n\")\n\tout.WriteString(\"\\\\usepackage{verbatim}\\n\")\n\tout.WriteString(\"\\\\usepackage[normalem]{ulem}\\n\")\n\tout.WriteString(\"\\\\usepackage{hyperref}\\n\")\n\tout.WriteString(\"\\n\")\n\tout.WriteString(\"\\\\hypersetup{colorlinks,%\\n\")\n\tout.WriteString(\"  citecolor=black,%\\n\")\n\tout.WriteString(\"  filecolor=black,%\\n\")\n\tout.WriteString(\"  linkcolor=black,%\\n\")\n\tout.WriteString(\"  urlcolor=black,%\\n\")\n\tout.WriteString(\"  pdfstartview=FitH,%\\n\")\n\tout.WriteString(\"  breaklinks=true,%\\n\")\n\tout.WriteString(\"  pdfauthor={Blackfriday Markdown Processor v\")\n\tout.WriteString(VERSION)\n\tout.WriteString(\"}}\\n\")\n\tout.WriteString(\"\\n\")\n\tout.WriteString(\"\\\\newcommand{\\\\HRule}{\\\\rule{\\\\linewidth}{0.5mm}}\\n\")\n\tout.WriteString(\"\\\\addtolength{\\\\parskip}{0.5\\\\baselineskip}\\n\")\n\tout.WriteString(\"\\\\parindent=0pt\\n\")\n\tout.WriteString(\"\\n\")\n\tout.WriteString(\"\\\\begin{document}\\n\")\n}\n\nfunc (options *Latex) DocumentFooter(out *bytes.Buffer) {\n\tout.WriteString(\"\\n\\\\end{document}\\n\")\n}\n"
        },
        {
          "name": "markdown.go",
          "type": "blob",
          "size": 24.4462890625,
          "content": "//\n// Blackfriday Markdown Processor\n// Available at http://github.com/russross/blackfriday\n//\n// Copyright © 2011 Russ Ross <russ@russross.com>.\n// Distributed under the Simplified BSD License.\n// See README.md for details.\n//\n\n//\n//\n// Markdown parsing and processing\n//\n//\n\npackage blackfriday\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strings\"\n\t\"unicode/utf8\"\n)\n\nconst VERSION = \"1.5\"\n\n// These are the supported markdown parsing extensions.\n// OR these values together to select multiple extensions.\nconst (\n\tEXTENSION_NO_INTRA_EMPHASIS          = 1 << iota // ignore emphasis markers inside words\n\tEXTENSION_TABLES                                 // render tables\n\tEXTENSION_FENCED_CODE                            // render fenced code blocks\n\tEXTENSION_AUTOLINK                               // detect embedded URLs that are not explicitly marked\n\tEXTENSION_STRIKETHROUGH                          // strikethrough text using ~~test~~\n\tEXTENSION_LAX_HTML_BLOCKS                        // loosen up HTML block parsing rules\n\tEXTENSION_SPACE_HEADERS                          // be strict about prefix header rules\n\tEXTENSION_HARD_LINE_BREAK                        // translate newlines into line breaks\n\tEXTENSION_TAB_SIZE_EIGHT                         // expand tabs to eight spaces instead of four\n\tEXTENSION_FOOTNOTES                              // Pandoc-style footnotes\n\tEXTENSION_NO_EMPTY_LINE_BEFORE_BLOCK             // No need to insert an empty line to start a (code, quote, ordered list, unordered list) block\n\tEXTENSION_HEADER_IDS                             // specify header IDs  with {#id}\n\tEXTENSION_TITLEBLOCK                             // Titleblock ala pandoc\n\tEXTENSION_AUTO_HEADER_IDS                        // Create the header ID from the text\n\tEXTENSION_BACKSLASH_LINE_BREAK                   // translate trailing backslashes into line breaks\n\tEXTENSION_DEFINITION_LISTS                       // render definition lists\n\tEXTENSION_JOIN_LINES                             // delete newline and join lines\n\n\tcommonHtmlFlags = 0 |\n\t\tHTML_USE_XHTML |\n\t\tHTML_USE_SMARTYPANTS |\n\t\tHTML_SMARTYPANTS_FRACTIONS |\n\t\tHTML_SMARTYPANTS_DASHES |\n\t\tHTML_SMARTYPANTS_LATEX_DASHES\n\n\tcommonExtensions = 0 |\n\t\tEXTENSION_NO_INTRA_EMPHASIS |\n\t\tEXTENSION_TABLES |\n\t\tEXTENSION_FENCED_CODE |\n\t\tEXTENSION_AUTOLINK |\n\t\tEXTENSION_STRIKETHROUGH |\n\t\tEXTENSION_SPACE_HEADERS |\n\t\tEXTENSION_HEADER_IDS |\n\t\tEXTENSION_BACKSLASH_LINE_BREAK |\n\t\tEXTENSION_DEFINITION_LISTS\n)\n\n// These are the possible flag values for the link renderer.\n// Only a single one of these values will be used; they are not ORed together.\n// These are mostly of interest if you are writing a new output format.\nconst (\n\tLINK_TYPE_NOT_AUTOLINK = iota\n\tLINK_TYPE_NORMAL\n\tLINK_TYPE_EMAIL\n)\n\n// These are the possible flag values for the ListItem renderer.\n// Multiple flag values may be ORed together.\n// These are mostly of interest if you are writing a new output format.\nconst (\n\tLIST_TYPE_ORDERED = 1 << iota\n\tLIST_TYPE_DEFINITION\n\tLIST_TYPE_TERM\n\tLIST_ITEM_CONTAINS_BLOCK\n\tLIST_ITEM_BEGINNING_OF_LIST\n\tLIST_ITEM_END_OF_LIST\n)\n\n// These are the possible flag values for the table cell renderer.\n// Only a single one of these values will be used; they are not ORed together.\n// These are mostly of interest if you are writing a new output format.\nconst (\n\tTABLE_ALIGNMENT_LEFT = 1 << iota\n\tTABLE_ALIGNMENT_RIGHT\n\tTABLE_ALIGNMENT_CENTER = (TABLE_ALIGNMENT_LEFT | TABLE_ALIGNMENT_RIGHT)\n)\n\n// The size of a tab stop.\nconst (\n\tTAB_SIZE_DEFAULT = 4\n\tTAB_SIZE_EIGHT   = 8\n)\n\n// blockTags is a set of tags that are recognized as HTML block tags.\n// Any of these can be included in markdown text without special escaping.\nvar blockTags = map[string]struct{}{\n\t\"blockquote\": {},\n\t\"del\":        {},\n\t\"div\":        {},\n\t\"dl\":         {},\n\t\"fieldset\":   {},\n\t\"form\":       {},\n\t\"h1\":         {},\n\t\"h2\":         {},\n\t\"h3\":         {},\n\t\"h4\":         {},\n\t\"h5\":         {},\n\t\"h6\":         {},\n\t\"iframe\":     {},\n\t\"ins\":        {},\n\t\"math\":       {},\n\t\"noscript\":   {},\n\t\"ol\":         {},\n\t\"pre\":        {},\n\t\"p\":          {},\n\t\"script\":     {},\n\t\"style\":      {},\n\t\"table\":      {},\n\t\"ul\":         {},\n\n\t// HTML5\n\t\"address\":    {},\n\t\"article\":    {},\n\t\"aside\":      {},\n\t\"canvas\":     {},\n\t\"details\":    {},\n\t\"figcaption\": {},\n\t\"figure\":     {},\n\t\"footer\":     {},\n\t\"header\":     {},\n\t\"hgroup\":     {},\n\t\"main\":       {},\n\t\"nav\":        {},\n\t\"output\":     {},\n\t\"progress\":   {},\n\t\"section\":    {},\n\t\"summary\":    {},\n\t\"video\":      {},\n}\n\n// Renderer is the rendering interface.\n// This is mostly of interest if you are implementing a new rendering format.\n//\n// When a byte slice is provided, it contains the (rendered) contents of the\n// element.\n//\n// When a callback is provided instead, it will write the contents of the\n// respective element directly to the output buffer and return true on success.\n// If the callback returns false, the rendering function should reset the\n// output buffer as though it had never been called.\n//\n// Currently Html and Latex implementations are provided\ntype Renderer interface {\n\t// block-level callbacks\n\tBlockCode(out *bytes.Buffer, text []byte, infoString string)\n\tBlockQuote(out *bytes.Buffer, text []byte)\n\tBlockHtml(out *bytes.Buffer, text []byte)\n\tHeader(out *bytes.Buffer, text func() bool, level int, id string)\n\tHRule(out *bytes.Buffer)\n\tList(out *bytes.Buffer, text func() bool, flags int)\n\tListItem(out *bytes.Buffer, text []byte, flags int)\n\tParagraph(out *bytes.Buffer, text func() bool)\n\tTable(out *bytes.Buffer, header []byte, body []byte, columnData []int)\n\tTableRow(out *bytes.Buffer, text []byte)\n\tTableHeaderCell(out *bytes.Buffer, text []byte, flags int)\n\tTableCell(out *bytes.Buffer, text []byte, flags int)\n\tFootnotes(out *bytes.Buffer, text func() bool)\n\tFootnoteItem(out *bytes.Buffer, name, text []byte, flags int)\n\tTitleBlock(out *bytes.Buffer, text []byte)\n\n\t// Span-level callbacks\n\tAutoLink(out *bytes.Buffer, link []byte, kind int)\n\tCodeSpan(out *bytes.Buffer, text []byte)\n\tDoubleEmphasis(out *bytes.Buffer, text []byte)\n\tEmphasis(out *bytes.Buffer, text []byte)\n\tImage(out *bytes.Buffer, link []byte, title []byte, alt []byte)\n\tLineBreak(out *bytes.Buffer)\n\tLink(out *bytes.Buffer, link []byte, title []byte, content []byte)\n\tRawHtmlTag(out *bytes.Buffer, tag []byte)\n\tTripleEmphasis(out *bytes.Buffer, text []byte)\n\tStrikeThrough(out *bytes.Buffer, text []byte)\n\tFootnoteRef(out *bytes.Buffer, ref []byte, id int)\n\n\t// Low-level callbacks\n\tEntity(out *bytes.Buffer, entity []byte)\n\tNormalText(out *bytes.Buffer, text []byte)\n\n\t// Header and footer\n\tDocumentHeader(out *bytes.Buffer)\n\tDocumentFooter(out *bytes.Buffer)\n\n\tGetFlags() int\n}\n\n// Callback functions for inline parsing. One such function is defined\n// for each character that triggers a response when parsing inline data.\ntype inlineParser func(p *parser, out *bytes.Buffer, data []byte, offset int) int\n\n// Parser holds runtime state used by the parser.\n// This is constructed by the Markdown function.\ntype parser struct {\n\tr              Renderer\n\trefOverride    ReferenceOverrideFunc\n\trefs           map[string]*reference\n\tinlineCallback [256]inlineParser\n\tflags          int\n\tnesting        int\n\tmaxNesting     int\n\tinsideLink     bool\n\n\t// Footnotes need to be ordered as well as available to quickly check for\n\t// presence. If a ref is also a footnote, it's stored both in refs and here\n\t// in notes. Slice is nil if footnotes not enabled.\n\tnotes       []*reference\n\tnotesRecord map[string]struct{}\n}\n\nfunc (p *parser) getRef(refid string) (ref *reference, found bool) {\n\tif p.refOverride != nil {\n\t\tr, overridden := p.refOverride(refid)\n\t\tif overridden {\n\t\t\tif r == nil {\n\t\t\t\treturn nil, false\n\t\t\t}\n\t\t\treturn &reference{\n\t\t\t\tlink:     []byte(r.Link),\n\t\t\t\ttitle:    []byte(r.Title),\n\t\t\t\tnoteId:   0,\n\t\t\t\thasBlock: false,\n\t\t\t\ttext:     []byte(r.Text)}, true\n\t\t}\n\t}\n\t// refs are case insensitive\n\tref, found = p.refs[strings.ToLower(refid)]\n\treturn ref, found\n}\n\nfunc (p *parser) isFootnote(ref *reference) bool {\n\t_, ok := p.notesRecord[string(ref.link)]\n\treturn ok\n}\n\n//\n//\n// Public interface\n//\n//\n\n// Reference represents the details of a link.\n// See the documentation in Options for more details on use-case.\ntype Reference struct {\n\t// Link is usually the URL the reference points to.\n\tLink string\n\t// Title is the alternate text describing the link in more detail.\n\tTitle string\n\t// Text is the optional text to override the ref with if the syntax used was\n\t// [refid][]\n\tText string\n}\n\n// ReferenceOverrideFunc is expected to be called with a reference string and\n// return either a valid Reference type that the reference string maps to or\n// nil. If overridden is false, the default reference logic will be executed.\n// See the documentation in Options for more details on use-case.\ntype ReferenceOverrideFunc func(reference string) (ref *Reference, overridden bool)\n\n// Options represents configurable overrides and callbacks (in addition to the\n// extension flag set) for configuring a Markdown parse.\ntype Options struct {\n\t// Extensions is a flag set of bit-wise ORed extension bits. See the\n\t// EXTENSION_* flags defined in this package.\n\tExtensions int\n\n\t// ReferenceOverride is an optional function callback that is called every\n\t// time a reference is resolved.\n\t//\n\t// In Markdown, the link reference syntax can be made to resolve a link to\n\t// a reference instead of an inline URL, in one of the following ways:\n\t//\n\t//  * [link text][refid]\n\t//  * [refid][]\n\t//\n\t// Usually, the refid is defined at the bottom of the Markdown document. If\n\t// this override function is provided, the refid is passed to the override\n\t// function first, before consulting the defined refids at the bottom. If\n\t// the override function indicates an override did not occur, the refids at\n\t// the bottom will be used to fill in the link details.\n\tReferenceOverride ReferenceOverrideFunc\n}\n\n// MarkdownBasic is a convenience function for simple rendering.\n// It processes markdown input with no extensions enabled.\nfunc MarkdownBasic(input []byte) []byte {\n\t// set up the HTML renderer\n\thtmlFlags := HTML_USE_XHTML\n\trenderer := HtmlRenderer(htmlFlags, \"\", \"\")\n\n\t// set up the parser\n\treturn MarkdownOptions(input, renderer, Options{Extensions: 0})\n}\n\n// Call Markdown with most useful extensions enabled\n// MarkdownCommon is a convenience function for simple rendering.\n// It processes markdown input with common extensions enabled, including:\n//\n// * Smartypants processing with smart fractions and LaTeX dashes\n//\n// * Intra-word emphasis suppression\n//\n// * Tables\n//\n// * Fenced code blocks\n//\n// * Autolinking\n//\n// * Strikethrough support\n//\n// * Strict header parsing\n//\n// * Custom Header IDs\nfunc MarkdownCommon(input []byte) []byte {\n\t// set up the HTML renderer\n\trenderer := HtmlRenderer(commonHtmlFlags, \"\", \"\")\n\treturn MarkdownOptions(input, renderer, Options{\n\t\tExtensions: commonExtensions})\n}\n\n// Markdown is the main rendering function.\n// It parses and renders a block of markdown-encoded text.\n// The supplied Renderer is used to format the output, and extensions dictates\n// which non-standard extensions are enabled.\n//\n// To use the supplied Html or LaTeX renderers, see HtmlRenderer and\n// LatexRenderer, respectively.\nfunc Markdown(input []byte, renderer Renderer, extensions int) []byte {\n\treturn MarkdownOptions(input, renderer, Options{\n\t\tExtensions: extensions})\n}\n\n// MarkdownOptions is just like Markdown but takes additional options through\n// the Options struct.\nfunc MarkdownOptions(input []byte, renderer Renderer, opts Options) []byte {\n\t// no point in parsing if we can't render\n\tif renderer == nil {\n\t\treturn nil\n\t}\n\n\textensions := opts.Extensions\n\n\t// fill in the render structure\n\tp := new(parser)\n\tp.r = renderer\n\tp.flags = extensions\n\tp.refOverride = opts.ReferenceOverride\n\tp.refs = make(map[string]*reference)\n\tp.maxNesting = 16\n\tp.insideLink = false\n\n\t// register inline parsers\n\tp.inlineCallback['*'] = emphasis\n\tp.inlineCallback['_'] = emphasis\n\tif extensions&EXTENSION_STRIKETHROUGH != 0 {\n\t\tp.inlineCallback['~'] = emphasis\n\t}\n\tp.inlineCallback['`'] = codeSpan\n\tp.inlineCallback['\\n'] = lineBreak\n\tp.inlineCallback['['] = link\n\tp.inlineCallback['<'] = leftAngle\n\tp.inlineCallback['\\\\'] = escape\n\tp.inlineCallback['&'] = entity\n\n\tif extensions&EXTENSION_AUTOLINK != 0 {\n\t\tp.inlineCallback[':'] = autoLink\n\t}\n\n\tif extensions&EXTENSION_FOOTNOTES != 0 {\n\t\tp.notes = make([]*reference, 0)\n\t\tp.notesRecord = make(map[string]struct{})\n\t}\n\n\tfirst := firstPass(p, input)\n\tsecond := secondPass(p, first)\n\treturn second\n}\n\n// first pass:\n// - normalize newlines\n// - extract references (outside of fenced code blocks)\n// - expand tabs (outside of fenced code blocks)\n// - copy everything else\nfunc firstPass(p *parser, input []byte) []byte {\n\tvar out bytes.Buffer\n\ttabSize := TAB_SIZE_DEFAULT\n\tif p.flags&EXTENSION_TAB_SIZE_EIGHT != 0 {\n\t\ttabSize = TAB_SIZE_EIGHT\n\t}\n\tbeg := 0\n\tlastFencedCodeBlockEnd := 0\n\tfor beg < len(input) {\n\t\t// Find end of this line, then process the line.\n\t\tend := beg\n\t\tfor end < len(input) && input[end] != '\\n' && input[end] != '\\r' {\n\t\t\tend++\n\t\t}\n\n\t\tif p.flags&EXTENSION_FENCED_CODE != 0 {\n\t\t\t// track fenced code block boundaries to suppress tab expansion\n\t\t\t// and reference extraction inside them:\n\t\t\tif beg >= lastFencedCodeBlockEnd {\n\t\t\t\tif i := p.fencedCodeBlock(&out, input[beg:], false); i > 0 {\n\t\t\t\t\tlastFencedCodeBlockEnd = beg + i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// add the line body if present\n\t\tif end > beg {\n\t\t\tif end < lastFencedCodeBlockEnd { // Do not expand tabs while inside fenced code blocks.\n\t\t\t\tout.Write(input[beg:end])\n\t\t\t} else if refEnd := isReference(p, input[beg:], tabSize); refEnd > 0 {\n\t\t\t\tbeg += refEnd\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\texpandTabs(&out, input[beg:end], tabSize)\n\t\t\t}\n\t\t}\n\n\t\tif end < len(input) && input[end] == '\\r' {\n\t\t\tend++\n\t\t}\n\t\tif end < len(input) && input[end] == '\\n' {\n\t\t\tend++\n\t\t}\n\t\tout.WriteByte('\\n')\n\n\t\tbeg = end\n\t}\n\n\t// empty input?\n\tif out.Len() == 0 {\n\t\tout.WriteByte('\\n')\n\t}\n\n\treturn out.Bytes()\n}\n\n// second pass: actual rendering\nfunc secondPass(p *parser, input []byte) []byte {\n\tvar output bytes.Buffer\n\n\tp.r.DocumentHeader(&output)\n\tp.block(&output, input)\n\n\tif p.flags&EXTENSION_FOOTNOTES != 0 && len(p.notes) > 0 {\n\t\tp.r.Footnotes(&output, func() bool {\n\t\t\tflags := LIST_ITEM_BEGINNING_OF_LIST\n\t\t\tfor i := 0; i < len(p.notes); i += 1 {\n\t\t\t\tref := p.notes[i]\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\tif ref.hasBlock {\n\t\t\t\t\tflags |= LIST_ITEM_CONTAINS_BLOCK\n\t\t\t\t\tp.block(&buf, ref.title)\n\t\t\t\t} else {\n\t\t\t\t\tp.inline(&buf, ref.title)\n\t\t\t\t}\n\t\t\t\tp.r.FootnoteItem(&output, ref.link, buf.Bytes(), flags)\n\t\t\t\tflags &^= LIST_ITEM_BEGINNING_OF_LIST | LIST_ITEM_CONTAINS_BLOCK\n\t\t\t}\n\n\t\t\treturn true\n\t\t})\n\t}\n\n\tp.r.DocumentFooter(&output)\n\n\tif p.nesting != 0 {\n\t\tpanic(\"Nesting level did not end at zero\")\n\t}\n\n\treturn output.Bytes()\n}\n\n//\n// Link references\n//\n// This section implements support for references that (usually) appear\n// as footnotes in a document, and can be referenced anywhere in the document.\n// The basic format is:\n//\n//    [1]: http://www.google.com/ \"Google\"\n//    [2]: http://www.github.com/ \"Github\"\n//\n// Anywhere in the document, the reference can be linked by referring to its\n// label, i.e., 1 and 2 in this example, as in:\n//\n//    This library is hosted on [Github][2], a git hosting site.\n//\n// Actual footnotes as specified in Pandoc and supported by some other Markdown\n// libraries such as php-markdown are also taken care of. They look like this:\n//\n//    This sentence needs a bit of further explanation.[^note]\n//\n//    [^note]: This is the explanation.\n//\n// Footnotes should be placed at the end of the document in an ordered list.\n// Inline footnotes such as:\n//\n//    Inline footnotes^[Not supported.] also exist.\n//\n// are not yet supported.\n\n// References are parsed and stored in this struct.\ntype reference struct {\n\tlink     []byte\n\ttitle    []byte\n\tnoteId   int // 0 if not a footnote ref\n\thasBlock bool\n\ttext     []byte\n}\n\nfunc (r *reference) String() string {\n\treturn fmt.Sprintf(\"{link: %q, title: %q, text: %q, noteId: %d, hasBlock: %v}\",\n\t\tr.link, r.title, r.text, r.noteId, r.hasBlock)\n}\n\n// Check whether or not data starts with a reference link.\n// If so, it is parsed and stored in the list of references\n// (in the render struct).\n// Returns the number of bytes to skip to move past it,\n// or zero if the first line is not a reference.\nfunc isReference(p *parser, data []byte, tabSize int) int {\n\t// up to 3 optional leading spaces\n\tif len(data) < 4 {\n\t\treturn 0\n\t}\n\ti := 0\n\tfor i < 3 && data[i] == ' ' {\n\t\ti++\n\t}\n\n\tnoteId := 0\n\n\t// id part: anything but a newline between brackets\n\tif data[i] != '[' {\n\t\treturn 0\n\t}\n\ti++\n\tif p.flags&EXTENSION_FOOTNOTES != 0 {\n\t\tif i < len(data) && data[i] == '^' {\n\t\t\t// we can set it to anything here because the proper noteIds will\n\t\t\t// be assigned later during the second pass. It just has to be != 0\n\t\t\tnoteId = 1\n\t\t\ti++\n\t\t}\n\t}\n\tidOffset := i\n\tfor i < len(data) && data[i] != '\\n' && data[i] != '\\r' && data[i] != ']' {\n\t\ti++\n\t}\n\tif i >= len(data) || data[i] != ']' {\n\t\treturn 0\n\t}\n\tidEnd := i\n\n\t// spacer: colon (space | tab)* newline? (space | tab)*\n\ti++\n\tif i >= len(data) || data[i] != ':' {\n\t\treturn 0\n\t}\n\ti++\n\tfor i < len(data) && (data[i] == ' ' || data[i] == '\\t') {\n\t\ti++\n\t}\n\tif i < len(data) && (data[i] == '\\n' || data[i] == '\\r') {\n\t\ti++\n\t\tif i < len(data) && data[i] == '\\n' && data[i-1] == '\\r' {\n\t\t\ti++\n\t\t}\n\t}\n\tfor i < len(data) && (data[i] == ' ' || data[i] == '\\t') {\n\t\ti++\n\t}\n\tif i >= len(data) {\n\t\treturn 0\n\t}\n\n\tvar (\n\t\tlinkOffset, linkEnd   int\n\t\ttitleOffset, titleEnd int\n\t\tlineEnd               int\n\t\traw                   []byte\n\t\thasBlock              bool\n\t)\n\n\tif p.flags&EXTENSION_FOOTNOTES != 0 && noteId != 0 {\n\t\tlinkOffset, linkEnd, raw, hasBlock = scanFootnote(p, data, i, tabSize)\n\t\tlineEnd = linkEnd\n\t} else {\n\t\tlinkOffset, linkEnd, titleOffset, titleEnd, lineEnd = scanLinkRef(p, data, i)\n\t}\n\tif lineEnd == 0 {\n\t\treturn 0\n\t}\n\n\t// a valid ref has been found\n\n\tref := &reference{\n\t\tnoteId:   noteId,\n\t\thasBlock: hasBlock,\n\t}\n\n\tif noteId > 0 {\n\t\t// reusing the link field for the id since footnotes don't have links\n\t\tref.link = data[idOffset:idEnd]\n\t\t// if footnote, it's not really a title, it's the contained text\n\t\tref.title = raw\n\t} else {\n\t\tref.link = data[linkOffset:linkEnd]\n\t\tref.title = data[titleOffset:titleEnd]\n\t}\n\n\t// id matches are case-insensitive\n\tid := string(bytes.ToLower(data[idOffset:idEnd]))\n\n\tp.refs[id] = ref\n\n\treturn lineEnd\n}\n\nfunc scanLinkRef(p *parser, data []byte, i int) (linkOffset, linkEnd, titleOffset, titleEnd, lineEnd int) {\n\t// link: whitespace-free sequence, optionally between angle brackets\n\tif data[i] == '<' {\n\t\ti++\n\t}\n\tlinkOffset = i\n\tif i == len(data) {\n\t\treturn\n\t}\n\tfor i < len(data) && data[i] != ' ' && data[i] != '\\t' && data[i] != '\\n' && data[i] != '\\r' {\n\t\ti++\n\t}\n\tlinkEnd = i\n\tif data[linkOffset] == '<' && data[linkEnd-1] == '>' {\n\t\tlinkOffset++\n\t\tlinkEnd--\n\t}\n\n\t// optional spacer: (space | tab)* (newline | '\\'' | '\"' | '(' )\n\tfor i < len(data) && (data[i] == ' ' || data[i] == '\\t') {\n\t\ti++\n\t}\n\tif i < len(data) && data[i] != '\\n' && data[i] != '\\r' && data[i] != '\\'' && data[i] != '\"' && data[i] != '(' {\n\t\treturn\n\t}\n\n\t// compute end-of-line\n\tif i >= len(data) || data[i] == '\\r' || data[i] == '\\n' {\n\t\tlineEnd = i\n\t}\n\tif i+1 < len(data) && data[i] == '\\r' && data[i+1] == '\\n' {\n\t\tlineEnd++\n\t}\n\n\t// optional (space|tab)* spacer after a newline\n\tif lineEnd > 0 {\n\t\ti = lineEnd + 1\n\t\tfor i < len(data) && (data[i] == ' ' || data[i] == '\\t') {\n\t\t\ti++\n\t\t}\n\t}\n\n\t// optional title: any non-newline sequence enclosed in '\"() alone on its line\n\tif i+1 < len(data) && (data[i] == '\\'' || data[i] == '\"' || data[i] == '(') {\n\t\ti++\n\t\ttitleOffset = i\n\n\t\t// look for EOL\n\t\tfor i < len(data) && data[i] != '\\n' && data[i] != '\\r' {\n\t\t\ti++\n\t\t}\n\t\tif i+1 < len(data) && data[i] == '\\n' && data[i+1] == '\\r' {\n\t\t\ttitleEnd = i + 1\n\t\t} else {\n\t\t\ttitleEnd = i\n\t\t}\n\n\t\t// step back\n\t\ti--\n\t\tfor i > titleOffset && (data[i] == ' ' || data[i] == '\\t') {\n\t\t\ti--\n\t\t}\n\t\tif i > titleOffset && (data[i] == '\\'' || data[i] == '\"' || data[i] == ')') {\n\t\t\tlineEnd = titleEnd\n\t\t\ttitleEnd = i\n\t\t}\n\t}\n\n\treturn\n}\n\n// The first bit of this logic is the same as (*parser).listItem, but the rest\n// is much simpler. This function simply finds the entire block and shifts it\n// over by one tab if it is indeed a block (just returns the line if it's not).\n// blockEnd is the end of the section in the input buffer, and contents is the\n// extracted text that was shifted over one tab. It will need to be rendered at\n// the end of the document.\nfunc scanFootnote(p *parser, data []byte, i, indentSize int) (blockStart, blockEnd int, contents []byte, hasBlock bool) {\n\tif i == 0 || len(data) == 0 {\n\t\treturn\n\t}\n\n\t// skip leading whitespace on first line\n\tfor i < len(data) && data[i] == ' ' {\n\t\ti++\n\t}\n\n\tblockStart = i\n\n\t// find the end of the line\n\tblockEnd = i\n\tfor i < len(data) && data[i-1] != '\\n' {\n\t\ti++\n\t}\n\n\t// get working buffer\n\tvar raw bytes.Buffer\n\n\t// put the first line into the working buffer\n\traw.Write(data[blockEnd:i])\n\tblockEnd = i\n\n\t// process the following lines\n\tcontainsBlankLine := false\n\ngatherLines:\n\tfor blockEnd < len(data) {\n\t\ti++\n\n\t\t// find the end of this line\n\t\tfor i < len(data) && data[i-1] != '\\n' {\n\t\t\ti++\n\t\t}\n\n\t\t// if it is an empty line, guess that it is part of this item\n\t\t// and move on to the next line\n\t\tif p.isEmpty(data[blockEnd:i]) > 0 {\n\t\t\tcontainsBlankLine = true\n\t\t\tblockEnd = i\n\t\t\tcontinue\n\t\t}\n\n\t\tn := 0\n\t\tif n = isIndented(data[blockEnd:i], indentSize); n == 0 {\n\t\t\t// this is the end of the block.\n\t\t\t// we don't want to include this last line in the index.\n\t\t\tbreak gatherLines\n\t\t}\n\n\t\t// if there were blank lines before this one, insert a new one now\n\t\tif containsBlankLine {\n\t\t\traw.WriteByte('\\n')\n\t\t\tcontainsBlankLine = false\n\t\t}\n\n\t\t// get rid of that first tab, write to buffer\n\t\traw.Write(data[blockEnd+n : i])\n\t\thasBlock = true\n\n\t\tblockEnd = i\n\t}\n\n\tif data[blockEnd-1] != '\\n' {\n\t\traw.WriteByte('\\n')\n\t}\n\n\tcontents = raw.Bytes()\n\n\treturn\n}\n\n//\n//\n// Miscellaneous helper functions\n//\n//\n\n// Test if a character is a punctuation symbol.\n// Taken from a private function in regexp in the stdlib.\nfunc ispunct(c byte) bool {\n\tfor _, r := range []byte(\"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\") {\n\t\tif c == r {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Test if a character is a whitespace character.\nfunc isspace(c byte) bool {\n\treturn ishorizontalspace(c) || isverticalspace(c)\n}\n\n// Test if a character is a horizontal whitespace character.\nfunc ishorizontalspace(c byte) bool {\n\treturn c == ' ' || c == '\\t'\n}\n\n// Test if a character is a vertical whitespace character.\nfunc isverticalspace(c byte) bool {\n\treturn c == '\\n' || c == '\\r' || c == '\\f' || c == '\\v'\n}\n\n// Test if a character is letter.\nfunc isletter(c byte) bool {\n\treturn (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n}\n\n// Test if a character is a letter or a digit.\n// TODO: check when this is looking for ASCII alnum and when it should use unicode\nfunc isalnum(c byte) bool {\n\treturn (c >= '0' && c <= '9') || isletter(c)\n}\n\n// Replace tab characters with spaces, aligning to the next TAB_SIZE column.\n// always ends output with a newline\nfunc expandTabs(out *bytes.Buffer, line []byte, tabSize int) {\n\t// first, check for common cases: no tabs, or only tabs at beginning of line\n\ti, prefix := 0, 0\n\tslowcase := false\n\tfor i = 0; i < len(line); i++ {\n\t\tif line[i] == '\\t' {\n\t\t\tif prefix == i {\n\t\t\t\tprefix++\n\t\t\t} else {\n\t\t\t\tslowcase = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// no need to decode runes if all tabs are at the beginning of the line\n\tif !slowcase {\n\t\tfor i = 0; i < prefix*tabSize; i++ {\n\t\t\tout.WriteByte(' ')\n\t\t}\n\t\tout.Write(line[prefix:])\n\t\treturn\n\t}\n\n\t// the slow case: we need to count runes to figure out how\n\t// many spaces to insert for each tab\n\tcolumn := 0\n\ti = 0\n\tfor i < len(line) {\n\t\tstart := i\n\t\tfor i < len(line) && line[i] != '\\t' {\n\t\t\t_, size := utf8.DecodeRune(line[i:])\n\t\t\ti += size\n\t\t\tcolumn++\n\t\t}\n\n\t\tif i > start {\n\t\t\tout.Write(line[start:i])\n\t\t}\n\n\t\tif i >= len(line) {\n\t\t\tbreak\n\t\t}\n\n\t\tfor {\n\t\t\tout.WriteByte(' ')\n\t\t\tcolumn++\n\t\t\tif column%tabSize == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\ti++\n\t}\n}\n\n// Find if a line counts as indented or not.\n// Returns number of characters the indent is (0 = not indented).\nfunc isIndented(data []byte, indentSize int) int {\n\tif len(data) == 0 {\n\t\treturn 0\n\t}\n\tif data[0] == '\\t' {\n\t\treturn 1\n\t}\n\tif len(data) < indentSize {\n\t\treturn 0\n\t}\n\tfor i := 0; i < indentSize; i++ {\n\t\tif data[i] != ' ' {\n\t\t\treturn 0\n\t\t}\n\t}\n\treturn indentSize\n}\n\n// Create a url-safe slug for fragments\nfunc slugify(in []byte) []byte {\n\tif len(in) == 0 {\n\t\treturn in\n\t}\n\tout := make([]byte, 0, len(in))\n\tsym := false\n\n\tfor _, ch := range in {\n\t\tif isalnum(ch) {\n\t\t\tsym = false\n\t\t\tout = append(out, ch)\n\t\t} else if sym {\n\t\t\tcontinue\n\t\t} else {\n\t\t\tout = append(out, '-')\n\t\t\tsym = true\n\t\t}\n\t}\n\tvar a, b int\n\tvar ch byte\n\tfor a, ch = range out {\n\t\tif ch != '-' {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor b = len(out) - 1; b > 0; b-- {\n\t\tif out[b] != '-' {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn out[a : b+1]\n}\n"
        },
        {
          "name": "markdown_test.go",
          "type": "blob",
          "size": 1.505859375,
          "content": "//\n// Blackfriday Markdown Processor\n// Available at http://github.com/russross/blackfriday\n//\n// Copyright © 2011 Russ Ross <russ@russross.com>.\n// Distributed under the Simplified BSD License.\n// See README.md for details.\n//\n\n//\n// Unit tests for full document parsing and rendering\n//\n\npackage blackfriday\n\nimport (\n\t\"testing\"\n)\n\nfunc runMarkdown(input string) string {\n\treturn string(MarkdownCommon([]byte(input)))\n}\n\nfunc doTests(t *testing.T, tests []string) {\n\t// catch and report panics\n\tvar candidate string\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tt.Errorf(\"\\npanic while processing [%#v]: %s\\n\", candidate, err)\n\t\t}\n\t}()\n\n\tfor i := 0; i+1 < len(tests); i += 2 {\n\t\tinput := tests[i]\n\t\tcandidate = input\n\t\texpected := tests[i+1]\n\t\tactual := runMarkdown(candidate)\n\t\tif actual != expected {\n\t\t\tt.Errorf(\"\\nInput   [%#v]\\nExpected[%#v]\\nActual  [%#v]\",\n\t\t\t\tcandidate, expected, actual)\n\t\t}\n\n\t\t// now test every substring to stress test bounds checking\n\t\tif !testing.Short() {\n\t\t\tfor start := 0; start < len(input); start++ {\n\t\t\t\tfor end := start + 1; end <= len(input); end++ {\n\t\t\t\t\tcandidate = input[start:end]\n\t\t\t\t\t_ = runMarkdown(candidate)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestDocument(t *testing.T) {\n\tvar tests = []string{\n\t\t// Empty document.\n\t\t\"\",\n\t\t\"\",\n\n\t\t\" \",\n\t\t\"\",\n\n\t\t// This shouldn't panic.\n\t\t// https://github.com/russross/blackfriday/issues/172\n\t\t\"[]:<\",\n\t\t\"<p>[]:&lt;</p>\\n\",\n\n\t\t// This shouldn't panic.\n\t\t// https://github.com/russross/blackfriday/issues/173\n\t\t\"   [\",\n\t\t\"<p>[</p>\\n\",\n\t}\n\tdoTests(t, tests)\n}\n"
        },
        {
          "name": "ref_test.go",
          "type": "blob",
          "size": 3.248046875,
          "content": "//\n// Blackfriday Markdown Processor\n// Available at http://github.com/russross/blackfriday\n//\n// Copyright © 2011 Russ Ross <russ@russross.com>.\n// Distributed under the Simplified BSD License.\n// See README.md for details.\n//\n\n//\n// Markdown 1.0.3 reference tests\n//\n\npackage blackfriday\n\nimport (\n\t\"io/ioutil\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\nfunc runMarkdownReference(input string, flag int) string {\n\trenderer := HtmlRenderer(0, \"\", \"\")\n\treturn string(Markdown([]byte(input), renderer, flag))\n}\n\nfunc doTestsReference(t *testing.T, files []string, flag int) {\n\t// catch and report panics\n\tvar candidate string\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tt.Errorf(\"\\npanic while processing [%#v]: %s\\n\", candidate, err)\n\t\t}\n\t}()\n\n\tfor _, basename := range files {\n\t\tfilename := filepath.Join(\"testdata\", basename+\".text\")\n\t\tinputBytes, err := ioutil.ReadFile(filename)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Couldn't open '%s', error: %v\\n\", filename, err)\n\t\t\tcontinue\n\t\t}\n\t\tinput := string(inputBytes)\n\n\t\tfilename = filepath.Join(\"testdata\", basename+\".html\")\n\t\texpectedBytes, err := ioutil.ReadFile(filename)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Couldn't open '%s', error: %v\\n\", filename, err)\n\t\t\tcontinue\n\t\t}\n\t\texpected := string(expectedBytes)\n\n\t\t// fmt.Fprintf(os.Stderr, \"processing %s ...\", filename)\n\t\tactual := string(runMarkdownReference(input, flag))\n\t\tif actual != expected {\n\t\t\tt.Errorf(\"\\n    [%#v]\\nExpected[%#v]\\nActual  [%#v]\",\n\t\t\t\tbasename+\".text\", expected, actual)\n\t\t}\n\t\t// fmt.Fprintf(os.Stderr, \" ok\\n\")\n\n\t\t// now test every prefix of every input to check for\n\t\t// bounds checking\n\t\tif !testing.Short() {\n\t\t\tstart, max := 0, len(input)\n\t\t\tfor end := start + 1; end <= max; end++ {\n\t\t\t\tcandidate = input[start:end]\n\t\t\t\t// fmt.Fprintf(os.Stderr, \"  %s %d:%d/%d\\n\", filename, start, end, max)\n\t\t\t\t_ = runMarkdownReference(candidate, flag)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReference(t *testing.T) {\n\tfiles := []string{\n\t\t\"Amps and angle encoding\",\n\t\t\"Auto links\",\n\t\t\"Backslash escapes\",\n\t\t\"Blockquotes with code blocks\",\n\t\t\"Code Blocks\",\n\t\t\"Code Spans\",\n\t\t\"Hard-wrapped paragraphs with list-like lines\",\n\t\t\"Horizontal rules\",\n\t\t\"Inline HTML (Advanced)\",\n\t\t\"Inline HTML (Simple)\",\n\t\t\"Inline HTML comments\",\n\t\t\"Links, inline style\",\n\t\t\"Links, reference style\",\n\t\t\"Links, shortcut references\",\n\t\t\"Literal quotes in titles\",\n\t\t\"Markdown Documentation - Basics\",\n\t\t\"Markdown Documentation - Syntax\",\n\t\t\"Nested blockquotes\",\n\t\t\"Ordered and unordered lists\",\n\t\t\"Strong and em together\",\n\t\t\"Tabs\",\n\t\t\"Tidyness\",\n\t}\n\tdoTestsReference(t, files, 0)\n}\n\nfunc TestReference_EXTENSION_NO_EMPTY_LINE_BEFORE_BLOCK(t *testing.T) {\n\tfiles := []string{\n\t\t\"Amps and angle encoding\",\n\t\t\"Auto links\",\n\t\t\"Backslash escapes\",\n\t\t\"Blockquotes with code blocks\",\n\t\t\"Code Blocks\",\n\t\t\"Code Spans\",\n\t\t\"Hard-wrapped paragraphs with list-like lines no empty line before block\",\n\t\t\"Horizontal rules\",\n\t\t\"Inline HTML (Advanced)\",\n\t\t\"Inline HTML (Simple)\",\n\t\t\"Inline HTML comments\",\n\t\t\"Links, inline style\",\n\t\t\"Links, reference style\",\n\t\t\"Links, shortcut references\",\n\t\t\"Literal quotes in titles\",\n\t\t\"Markdown Documentation - Basics\",\n\t\t\"Markdown Documentation - Syntax\",\n\t\t\"Nested blockquotes\",\n\t\t\"Ordered and unordered lists\",\n\t\t\"Strong and em together\",\n\t\t\"Tabs\",\n\t\t\"Tidyness\",\n\t}\n\tdoTestsReference(t, files, EXTENSION_NO_EMPTY_LINE_BEFORE_BLOCK)\n}\n"
        },
        {
          "name": "smartypants.go",
          "type": "blob",
          "size": 10.69140625,
          "content": "//\n// Blackfriday Markdown Processor\n// Available at http://github.com/russross/blackfriday\n//\n// Copyright © 2011 Russ Ross <russ@russross.com>.\n// Distributed under the Simplified BSD License.\n// See README.md for details.\n//\n\n//\n//\n// SmartyPants rendering\n//\n//\n\npackage blackfriday\n\nimport (\n\t\"bytes\"\n)\n\ntype smartypantsData struct {\n\tinSingleQuote bool\n\tinDoubleQuote bool\n}\n\nfunc wordBoundary(c byte) bool {\n\treturn c == 0 || isspace(c) || ispunct(c)\n}\n\nfunc tolower(c byte) byte {\n\tif c >= 'A' && c <= 'Z' {\n\t\treturn c - 'A' + 'a'\n\t}\n\treturn c\n}\n\nfunc isdigit(c byte) bool {\n\treturn c >= '0' && c <= '9'\n}\n\nfunc smartQuoteHelper(out *bytes.Buffer, previousChar byte, nextChar byte, quote byte, isOpen *bool, addNBSP bool) bool {\n\t// edge of the buffer is likely to be a tag that we don't get to see,\n\t// so we treat it like text sometimes\n\n\t// enumerate all sixteen possibilities for (previousChar, nextChar)\n\t// each can be one of {0, space, punct, other}\n\tswitch {\n\tcase previousChar == 0 && nextChar == 0:\n\t\t// context is not any help here, so toggle\n\t\t*isOpen = !*isOpen\n\tcase isspace(previousChar) && nextChar == 0:\n\t\t// [ \"] might be [ \"<code>foo...]\n\t\t*isOpen = true\n\tcase ispunct(previousChar) && nextChar == 0:\n\t\t// [!\"] hmm... could be [Run!\"] or [(\"<code>...]\n\t\t*isOpen = false\n\tcase /* isnormal(previousChar) && */ nextChar == 0:\n\t\t// [a\"] is probably a close\n\t\t*isOpen = false\n\tcase previousChar == 0 && isspace(nextChar):\n\t\t// [\" ] might be [...foo</code>\" ]\n\t\t*isOpen = false\n\tcase isspace(previousChar) && isspace(nextChar):\n\t\t// [ \" ] context is not any help here, so toggle\n\t\t*isOpen = !*isOpen\n\tcase ispunct(previousChar) && isspace(nextChar):\n\t\t// [!\" ] is probably a close\n\t\t*isOpen = false\n\tcase /* isnormal(previousChar) && */ isspace(nextChar):\n\t\t// [a\" ] this is one of the easy cases\n\t\t*isOpen = false\n\tcase previousChar == 0 && ispunct(nextChar):\n\t\t// [\"!] hmm... could be [\"$1.95] or [</code>\"!...]\n\t\t*isOpen = false\n\tcase isspace(previousChar) && ispunct(nextChar):\n\t\t// [ \"!] looks more like [ \"$1.95]\n\t\t*isOpen = true\n\tcase ispunct(previousChar) && ispunct(nextChar):\n\t\t// [!\"!] context is not any help here, so toggle\n\t\t*isOpen = !*isOpen\n\tcase /* isnormal(previousChar) && */ ispunct(nextChar):\n\t\t// [a\"!] is probably a close\n\t\t*isOpen = false\n\tcase previousChar == 0 /* && isnormal(nextChar) */ :\n\t\t// [\"a] is probably an open\n\t\t*isOpen = true\n\tcase isspace(previousChar) /* && isnormal(nextChar) */ :\n\t\t// [ \"a] this is one of the easy cases\n\t\t*isOpen = true\n\tcase ispunct(previousChar) /* && isnormal(nextChar) */ :\n\t\t// [!\"a] is probably an open\n\t\t*isOpen = true\n\tdefault:\n\t\t// [a'b] maybe a contraction?\n\t\t*isOpen = false\n\t}\n\n\t// Note that with the limited lookahead, this non-breaking\n\t// space will also be appended to single double quotes.\n\tif addNBSP && !*isOpen {\n\t\tout.WriteString(\"&nbsp;\")\n\t}\n\n\tout.WriteByte('&')\n\tif *isOpen {\n\t\tout.WriteByte('l')\n\t} else {\n\t\tout.WriteByte('r')\n\t}\n\tout.WriteByte(quote)\n\tout.WriteString(\"quo;\")\n\n\tif addNBSP && *isOpen {\n\t\tout.WriteString(\"&nbsp;\")\n\t}\n\n\treturn true\n}\n\nfunc smartSingleQuote(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {\n\tif len(text) >= 2 {\n\t\tt1 := tolower(text[1])\n\n\t\tif t1 == '\\'' {\n\t\t\tnextChar := byte(0)\n\t\t\tif len(text) >= 3 {\n\t\t\t\tnextChar = text[2]\n\t\t\t}\n\t\t\tif smartQuoteHelper(out, previousChar, nextChar, 'd', &smrt.inDoubleQuote, false) {\n\t\t\t\treturn 1\n\t\t\t}\n\t\t}\n\n\t\tif (t1 == 's' || t1 == 't' || t1 == 'm' || t1 == 'd') && (len(text) < 3 || wordBoundary(text[2])) {\n\t\t\tout.WriteString(\"&rsquo;\")\n\t\t\treturn 0\n\t\t}\n\n\t\tif len(text) >= 3 {\n\t\t\tt2 := tolower(text[2])\n\n\t\t\tif ((t1 == 'r' && t2 == 'e') || (t1 == 'l' && t2 == 'l') || (t1 == 'v' && t2 == 'e')) &&\n\t\t\t\t(len(text) < 4 || wordBoundary(text[3])) {\n\t\t\t\tout.WriteString(\"&rsquo;\")\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\n\tnextChar := byte(0)\n\tif len(text) > 1 {\n\t\tnextChar = text[1]\n\t}\n\tif smartQuoteHelper(out, previousChar, nextChar, 's', &smrt.inSingleQuote, false) {\n\t\treturn 0\n\t}\n\n\tout.WriteByte(text[0])\n\treturn 0\n}\n\nfunc smartParens(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {\n\tif len(text) >= 3 {\n\t\tt1 := tolower(text[1])\n\t\tt2 := tolower(text[2])\n\n\t\tif t1 == 'c' && t2 == ')' {\n\t\t\tout.WriteString(\"&copy;\")\n\t\t\treturn 2\n\t\t}\n\n\t\tif t1 == 'r' && t2 == ')' {\n\t\t\tout.WriteString(\"&reg;\")\n\t\t\treturn 2\n\t\t}\n\n\t\tif len(text) >= 4 && t1 == 't' && t2 == 'm' && text[3] == ')' {\n\t\t\tout.WriteString(\"&trade;\")\n\t\t\treturn 3\n\t\t}\n\t}\n\n\tout.WriteByte(text[0])\n\treturn 0\n}\n\nfunc smartDash(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {\n\tif len(text) >= 2 {\n\t\tif text[1] == '-' {\n\t\t\tout.WriteString(\"&mdash;\")\n\t\t\treturn 1\n\t\t}\n\n\t\tif wordBoundary(previousChar) && wordBoundary(text[1]) {\n\t\t\tout.WriteString(\"&ndash;\")\n\t\t\treturn 0\n\t\t}\n\t}\n\n\tout.WriteByte(text[0])\n\treturn 0\n}\n\nfunc smartDashLatex(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {\n\tif len(text) >= 3 && text[1] == '-' && text[2] == '-' {\n\t\tout.WriteString(\"&mdash;\")\n\t\treturn 2\n\t}\n\tif len(text) >= 2 && text[1] == '-' {\n\t\tout.WriteString(\"&ndash;\")\n\t\treturn 1\n\t}\n\n\tout.WriteByte(text[0])\n\treturn 0\n}\n\nfunc smartAmpVariant(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte, quote byte, addNBSP bool) int {\n\tif bytes.HasPrefix(text, []byte(\"&quot;\")) {\n\t\tnextChar := byte(0)\n\t\tif len(text) >= 7 {\n\t\t\tnextChar = text[6]\n\t\t}\n\t\tif smartQuoteHelper(out, previousChar, nextChar, quote, &smrt.inDoubleQuote, addNBSP) {\n\t\t\treturn 5\n\t\t}\n\t}\n\n\tif bytes.HasPrefix(text, []byte(\"&#0;\")) {\n\t\treturn 3\n\t}\n\n\tout.WriteByte('&')\n\treturn 0\n}\n\nfunc smartAmp(angledQuotes, addNBSP bool) func(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {\n\tvar quote byte = 'd'\n\tif angledQuotes {\n\t\tquote = 'a'\n\t}\n\n\treturn func(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {\n\t\treturn smartAmpVariant(out, smrt, previousChar, text, quote, addNBSP)\n\t}\n}\n\nfunc smartPeriod(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {\n\tif len(text) >= 3 && text[1] == '.' && text[2] == '.' {\n\t\tout.WriteString(\"&hellip;\")\n\t\treturn 2\n\t}\n\n\tif len(text) >= 5 && text[1] == ' ' && text[2] == '.' && text[3] == ' ' && text[4] == '.' {\n\t\tout.WriteString(\"&hellip;\")\n\t\treturn 4\n\t}\n\n\tout.WriteByte(text[0])\n\treturn 0\n}\n\nfunc smartBacktick(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {\n\tif len(text) >= 2 && text[1] == '`' {\n\t\tnextChar := byte(0)\n\t\tif len(text) >= 3 {\n\t\t\tnextChar = text[2]\n\t\t}\n\t\tif smartQuoteHelper(out, previousChar, nextChar, 'd', &smrt.inDoubleQuote, false) {\n\t\t\treturn 1\n\t\t}\n\t}\n\n\tout.WriteByte(text[0])\n\treturn 0\n}\n\nfunc smartNumberGeneric(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {\n\tif wordBoundary(previousChar) && previousChar != '/' && len(text) >= 3 {\n\t\t// is it of the form digits/digits(word boundary)?, i.e., \\d+/\\d+\\b\n\t\t// note: check for regular slash (/) or fraction slash (⁄, 0x2044, or 0xe2 81 84 in utf-8)\n\t\t//       and avoid changing dates like 1/23/2005 into fractions.\n\t\tnumEnd := 0\n\t\tfor len(text) > numEnd && isdigit(text[numEnd]) {\n\t\t\tnumEnd++\n\t\t}\n\t\tif numEnd == 0 {\n\t\t\tout.WriteByte(text[0])\n\t\t\treturn 0\n\t\t}\n\t\tdenStart := numEnd + 1\n\t\tif len(text) > numEnd+3 && text[numEnd] == 0xe2 && text[numEnd+1] == 0x81 && text[numEnd+2] == 0x84 {\n\t\t\tdenStart = numEnd + 3\n\t\t} else if len(text) < numEnd+2 || text[numEnd] != '/' {\n\t\t\tout.WriteByte(text[0])\n\t\t\treturn 0\n\t\t}\n\t\tdenEnd := denStart\n\t\tfor len(text) > denEnd && isdigit(text[denEnd]) {\n\t\t\tdenEnd++\n\t\t}\n\t\tif denEnd == denStart {\n\t\t\tout.WriteByte(text[0])\n\t\t\treturn 0\n\t\t}\n\t\tif len(text) == denEnd || wordBoundary(text[denEnd]) && text[denEnd] != '/' {\n\t\t\tout.WriteString(\"<sup>\")\n\t\t\tout.Write(text[:numEnd])\n\t\t\tout.WriteString(\"</sup>&frasl;<sub>\")\n\t\t\tout.Write(text[denStart:denEnd])\n\t\t\tout.WriteString(\"</sub>\")\n\t\t\treturn denEnd - 1\n\t\t}\n\t}\n\n\tout.WriteByte(text[0])\n\treturn 0\n}\n\nfunc smartNumber(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {\n\tif wordBoundary(previousChar) && previousChar != '/' && len(text) >= 3 {\n\t\tif text[0] == '1' && text[1] == '/' && text[2] == '2' {\n\t\t\tif len(text) < 4 || wordBoundary(text[3]) && text[3] != '/' {\n\t\t\t\tout.WriteString(\"&frac12;\")\n\t\t\t\treturn 2\n\t\t\t}\n\t\t}\n\n\t\tif text[0] == '1' && text[1] == '/' && text[2] == '4' {\n\t\t\tif len(text) < 4 || wordBoundary(text[3]) && text[3] != '/' || (len(text) >= 5 && tolower(text[3]) == 't' && tolower(text[4]) == 'h') {\n\t\t\t\tout.WriteString(\"&frac14;\")\n\t\t\t\treturn 2\n\t\t\t}\n\t\t}\n\n\t\tif text[0] == '3' && text[1] == '/' && text[2] == '4' {\n\t\t\tif len(text) < 4 || wordBoundary(text[3]) && text[3] != '/' || (len(text) >= 6 && tolower(text[3]) == 't' && tolower(text[4]) == 'h' && tolower(text[5]) == 's') {\n\t\t\t\tout.WriteString(\"&frac34;\")\n\t\t\t\treturn 2\n\t\t\t}\n\t\t}\n\t}\n\n\tout.WriteByte(text[0])\n\treturn 0\n}\n\nfunc smartDoubleQuoteVariant(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte, quote byte) int {\n\tnextChar := byte(0)\n\tif len(text) > 1 {\n\t\tnextChar = text[1]\n\t}\n\tif !smartQuoteHelper(out, previousChar, nextChar, quote, &smrt.inDoubleQuote, false) {\n\t\tout.WriteString(\"&quot;\")\n\t}\n\n\treturn 0\n}\n\nfunc smartDoubleQuote(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {\n\treturn smartDoubleQuoteVariant(out, smrt, previousChar, text, 'd')\n}\n\nfunc smartAngledDoubleQuote(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {\n\treturn smartDoubleQuoteVariant(out, smrt, previousChar, text, 'a')\n}\n\nfunc smartLeftAngle(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {\n\ti := 0\n\n\tfor i < len(text) && text[i] != '>' {\n\t\ti++\n\t}\n\n\tout.Write(text[:i+1])\n\treturn i\n}\n\ntype smartCallback func(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int\n\ntype smartypantsRenderer [256]smartCallback\n\nvar (\n\tsmartAmpAngled      = smartAmp(true, false)\n\tsmartAmpAngledNBSP  = smartAmp(true, true)\n\tsmartAmpRegular     = smartAmp(false, false)\n\tsmartAmpRegularNBSP = smartAmp(false, true)\n)\n\nfunc smartypants(flags int) *smartypantsRenderer {\n\tr := new(smartypantsRenderer)\n\taddNBSP := flags&HTML_SMARTYPANTS_QUOTES_NBSP != 0\n\tif flags&HTML_SMARTYPANTS_ANGLED_QUOTES == 0 {\n\t\tr['\"'] = smartDoubleQuote\n\t\tif !addNBSP {\n\t\t\tr['&'] = smartAmpRegular\n\t\t} else {\n\t\t\tr['&'] = smartAmpRegularNBSP\n\t\t}\n\t} else {\n\t\tr['\"'] = smartAngledDoubleQuote\n\t\tif !addNBSP {\n\t\t\tr['&'] = smartAmpAngled\n\t\t} else {\n\t\t\tr['&'] = smartAmpAngledNBSP\n\t\t}\n\t}\n\tr['\\''] = smartSingleQuote\n\tr['('] = smartParens\n\tif flags&HTML_SMARTYPANTS_DASHES != 0 {\n\t\tif flags&HTML_SMARTYPANTS_LATEX_DASHES == 0 {\n\t\t\tr['-'] = smartDash\n\t\t} else {\n\t\t\tr['-'] = smartDashLatex\n\t\t}\n\t}\n\tr['.'] = smartPeriod\n\tif flags&HTML_SMARTYPANTS_FRACTIONS == 0 {\n\t\tr['1'] = smartNumber\n\t\tr['3'] = smartNumber\n\t} else {\n\t\tfor ch := '1'; ch <= '9'; ch++ {\n\t\t\tr[ch] = smartNumberGeneric\n\t\t}\n\t}\n\tr['<'] = smartLeftAngle\n\tr['`'] = smartBacktick\n\treturn r\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}