{
  "metadata": {
    "timestamp": 1736567741732,
    "page": 328,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "go-pg/pg",
      "stars": 5692,
      "defaultBranch": "v10",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.2431640625,
          "content": "run:\n  concurrency: 8\n  deadline: 5m\n  tests: false\nlinters:\n  enable-all: true\n  disable:\n    - gochecknoglobals\n    - gocognit\n    - gomnd\n    - wsl\n    - funlen\n    - godox\n    - goerr113\n    - exhaustive\n    - nestif\n    - gofumpt\n    - goconst\n"
        },
        {
          "name": ".prettierrc",
          "type": "blob",
          "size": 0.0625,
          "content": "semi: false\nsingleQuote: true\nproseWrap: always\nprintWidth: 100\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 10.5927734375,
          "content": "# Maintenance mode\n\ngo-pg is in a maintenance mode and only critical issues are addressed. New development happens in\n[**Bun**](https://bun.uptrace.dev/guide/pg-migration.html) repo which offers similar functionality\nbut works with PostgreSQL, MySQL, and SQLite.\n\n---\n\n# Changelog\n\n## v10.14.0\n\n- Added support for comments on ORM generated queries ([#2011](https://github.com/go-pg/pg/pull/2011))\n- Make reader and writer buffers configurable ([#2014](https://github.com/go-pg/pg/pull/2014))\n- Bumped golang.org/x/crypto from 0.21.0 to 0.31.0 ([#2013](https://github.com/go-pg/pg/pull/2013), [#2015](https://github.com/go-pg/pg/pull/2015))\n\nThank you [@wwoytenko](https://github.com/wwoytenko) and [@tony2001](https://github.com/tony2001)\n\n## v10.13.0\n\n- Removed references to deprecated `io/ioutil` ([#2001](https://github.com/go-pg/pg/pull/2001))\n- Added password environment variable for easier testing ([#1996](https://github.com/go-pg/pg/pull/1996))\n- Bumped google.golang.org/protobuf from 1.25.0 to 1.33.0 ([#2000](https://github.com/go-pg/pg/pull/2000))\n- Bumped golang.org/x/net from 0.17.0 to 0.23.0 ([#2002](https://github.com/go-pg/pg/pull/2002))\n\nThank you [@DarrylWong](https://github.com/DarrylWong) and [@testwill](https://github.com/testwill)\n\n## v10.12.0\n\n- Fixed invalid pointer dereference when accessing results ([#1990](https://github.com/go-pg/pg/pull/1990))\n- Updated minimum Golang version to v1.19.0 + go.mod cleanup ([#1992](https://github.com/go-pg/pg/pull/1992))\n- Bumped golang.org/x/net from 0.10.0 to 0.17.0 ([#1993](https://github.com/go-pg/pg/pull/1993))\n- Bumped gopkg.in/yaml.v3 from 3.0.0-20200313102051-9f266ea9e77c to 3.0.0 ([#1994](https://github.com/go-pg/pg/pull/1994))\n\nThank you [@fernandez14](https://github.com/fernandez14)\n\n## v10.11.2\n\n- Improved memory allocation when working with multi-byte characters in `appendRune` ([#1988](https://github.com/go-pg/pg/pull/1988))\n- Added `ToURL` to `*Options` ([#1934](https://github.com/go-pg/pg/pull/1934))\n\nThank you @dillonstreator and @MateusVeloso!\n\n## v10.11.1\n\n- Fixed bug with how cancelled contexts are handled in SingleConnPool connections ([#1981](https://github.com/go-pg/pg/pull/1981))\n\nThank you @xin-tsla!\n\n## v10.11.0\n\n- Updated dependency `mellium.im/sasl` from 0.2.1 to 0.3.1. ([#1969](https://github.com/go-pg/pg/pull/1969))\n\n## v10.10.7\n\n- Fixed race condition in notify listener.\n- Add shortcut `WhereInOr`.\n- Fixed bug in sending cancel request to terminate long running query.\n\n## v10.10.6\n\n- Updated OpenTelemetry to v1.0.0.\n\n## v10.10\n\n- Removed extra OpenTelemetry spans from go-pg core. Now go-pg instrumentation only adds a single\n  span with a SQL query (instead of 4 spans). There are multiple reasons behind this decision:\n\n  - Traces become smaller and less noisy.\n  - [Bun](https://github.com/uptrace/bun) can't support the same level of instrumentation and it is\n    nice to keep projects synced.\n  - It may be costly to process those 3 extra spans for each query.\n\n  Eventually we hope to replace the information that we no longer collect with OpenTelemetry\n  Metrics.\n\n## v10.9\n\n- To make updating easier, extra modules now have the same version as go-pg does. That means that\n  you need to update your imports:\n\n```\ngithub.com/go-pg/pg/extra/pgdebug -> github.com/go-pg/pg/extra/pgdebug/v10\ngithub.com/go-pg/pg/extra/pgotel -> github.com/go-pg/pg/extra/pgotel/v10\ngithub.com/go-pg/pg/extra/pgsegment -> github.com/go-pg/pg/extra/pgsegment/v10\n```\n\n- Exported `pg.Query` which should be used instead of `orm.Query`.\n- Added `pg.DBI` which is a DB interface implemented by `pg.DB` and `pg.Tx`.\n\n## v10\n\n### Resources\n\n- Docs at https://pg.uptrace.dev/ powered by [mkdocs](https://github.com/squidfunk/mkdocs-material).\n- [RealWorld example application](https://github.com/uptrace/go-realworld-example-app).\n- [Discord](https://discord.gg/rWtp5Aj).\n\n### Features\n\n- `Select`, `Insert`, and `Update` support `map[string]interface{}`. `Select` also supports\n  `[]map[string]interface{}`.\n\n```go\nvar mm []map[string]interface{}\nerr := db.Model((*User)(nil)).Limit(10).Select(&mm)\n```\n\n- Columns that start with `_` are ignored if there is no destination field.\n- Optional [faster json encoding](https://github.com/go-pg/pgext).\n- Added [pgext.OpenTelemetryHook](https://github.com/go-pg/pgext) that adds\n  [OpenTelemetry instrumentation](https://pg.uptrace.dev/tracing/).\n- Added [pgext.DebugHook](https://github.com/go-pg/pgext) that logs failed queries.\n- Added `db.Ping` to check if database is healthy.\n\n### Changes\n\n- ORM relations are reworked and now require `rel` tag option (but existing code will continue\n  working until v11). Supported options:\n  - `pg:\"rel:has-one\"` - has one relation.\n  - `pg:\"rel:belongs-to\"` - belongs to relation.\n  - `pg:\"rel:has-many\"` - has many relation.\n  - `pg:\"many2many:book_genres\"` - many to many relation.\n- Changed `pg.QueryHook` to return temp byte slice to reduce memory usage.\n- `,msgpack` struct tag marshals data in MessagePack format using\n  https://github.com/vmihailenco/msgpack\n- Empty slices and maps are no longer marshaled as `NULL`. Nil slices and maps are still marshaled\n  as `NULL`.\n- Changed `UpdateNotZero` to include zero fields with `pg:\",use_zero\"` tag. Consider using\n  `Model(*map[string]interface{})` for inserts and updates.\n- `joinFK` is deprecated in favor of `join_fk`.\n- `partitionBy` is deprecated in favor of `partition_by`.\n- ORM shortcuts are removed:\n  - `db.Select(model)` becomes `db.Model(model).WherePK().Select()`.\n  - `db.Insert(model)` becomes `db.Model(model).Insert()`.\n  - `db.Update(model)` becomes `db.Model(model).WherePK().Update()`.\n  - `db.Delete(model)` becomes `db.Model(model).WherePK().Delete()`.\n- Deprecated types and funcs are removed.\n- `WhereStruct` is removed.\n\n## v9\n\n- `pg:\",notnull\"` is reworked. Now it means SQL `NOT NULL` constraint and nothing more.\n- Added `pg:\",use_zero\"` to prevent go-pg from converting Go zero values to SQL `NULL`.\n- UpdateNotNull is renamed to UpdateNotZero. As previously it omits zero Go values, but it does not\n  take in account if field is nullable or not.\n- ORM supports DistinctOn.\n- Hooks accept and return context.\n- Client respects Context.Deadline when setting net.Conn deadline.\n- Client listens on Context.Done while waiting for a connection from the pool and returns an error\n  when context is cancelled.\n- `Query.Column` does not accept relation name any more. Use `Query.Relation` instead which returns\n  an error if relation does not exist.\n- urlvalues package is removed in favor of https://github.com/go-pg/urlstruct. You can also use\n  struct based filters via `Query.WhereStruct`.\n- `NewModel` and `AddModel` methods of `HooklessModel` interface were renamed to `NextColumnScanner`\n  and `AddColumnScanner` respectively.\n- `types.F` and `pg.F` are deprecated in favor of `pg.Ident`.\n- `types.Q` is deprecated in favor of `pg.Safe`.\n- `pg.Q` is deprecated in favor of `pg.SafeQuery`.\n- `TableName` field is deprecated in favor of `tableName`.\n- Always use `pg:\"...\"` struct field tag instead of `sql:\"...\"`.\n- `pg:\",override\"` is deprecated in favor of `pg:\",inherit\"`.\n\n## v8\n\n- Added `QueryContext`, `ExecContext`, and `ModelContext` which accept `context.Context`. Queries\n  are cancelled when context is cancelled.\n- Model hooks are changed to accept `context.Context` as first argument.\n- Fixed array and hstore parsers to handle multiple single quotes (#1235).\n\n## v7\n\n- DB.OnQueryProcessed is replaced with DB.AddQueryHook.\n- Added WhereStruct.\n- orm.Pager is moved to urlvalues.Pager. Pager.FromURLValues returns an error if page or limit\n  params can't be parsed.\n\n## v6.16\n\n- Read buffer is re-worked. Default read buffer is increased to 65kb.\n\n## v6.15\n\n- Added Options.MinIdleConns.\n- Options.MaxAge renamed to Options.MaxConnAge.\n- PoolStats.FreeConns is renamed to PoolStats.IdleConns.\n- New hook BeforeSelectQuery.\n- `,override` is renamed to `,inherit`.\n- Dialer.KeepAlive is set to 5 minutes by default.\n- Added support \"scram-sha-256\" authentication.\n\n## v6.14\n\n- Fields ignored with `sql:\"-\"` tag are no longer considered by ORM relation detector.\n\n## v6.12\n\n- `Insert`, `Update`, and `Delete` can return `pg.ErrNoRows` and `pg.ErrMultiRows` when `Returning`\n  is used and model expects single row.\n\n## v6.11\n\n- `db.Model(&strct).Update()` and `db.Model(&strct).Delete()` no longer adds WHERE condition based\n  on primary key when there are no conditions. Instead you should use `db.Update(&strct)` or\n  `db.Model(&strct).WherePK().Update()`.\n\n## v6.10\n\n- `?Columns` is renamed to `?TableColumns`. `?Columns` is changed to produce column names without\n  table alias.\n\n## v6.9\n\n- `pg:\"fk\"` tag now accepts SQL names instead of Go names, e.g. `pg:\"fk:ParentId\"` becomes\n  `pg:\"fk:parent_id\"`. Old code should continue working in most cases, but it is strongly advised to\n  start using new convention.\n- uint and uint64 SQL type is changed from decimal to bigint according to the lesser of two evils\n  principle. Use `sql:\"type:decimal\"` to get old behavior.\n\n## v6.8\n\n- `CreateTable` no longer adds ON DELETE hook by default. To get old behavior users should add\n  `sql:\"on_delete:CASCADE\"` tag on foreign key field.\n\n## v6\n\n- `types.Result` is renamed to `orm.Result`.\n- Added `OnQueryProcessed` event that can be used to log / report queries timing. Query logger is\n  removed.\n- `orm.URLValues` is renamed to `orm.URLFilters`. It no longer adds ORDER clause.\n- `orm.Pager` is renamed to `orm.Pagination`.\n- Support for net.IP and net.IPNet.\n- Support for context.Context.\n- Bulk/multi updates.\n- Query.WhereGroup for enclosing conditions in parentheses.\n\n## v5\n\n- All fields are nullable by default. `,null` tag is replaced with `,notnull`.\n- `Result.Affected` renamed to `Result.RowsAffected`.\n- Added `Result.RowsReturned`.\n- `Create` renamed to `Insert`, `BeforeCreate` to `BeforeInsert`, `AfterCreate` to `AfterInsert`.\n- Indexed placeholders support, e.g. `db.Exec(\"SELECT ?0 + ?0\", 1)`.\n- Named placeholders are evaluated when query is executed.\n- Added Update and Delete hooks.\n- Order reworked to quote column names. OrderExpr added to bypass Order quoting restrictions.\n- Group reworked to quote column names. GroupExpr added to bypass Group quoting restrictions.\n\n## v4\n\n- `Options.Host` and `Options.Port` merged into `Options.Addr`.\n- Added `Options.MaxRetries`. Now queries are not retried by default.\n- `LoadInto` renamed to `Scan`, `ColumnLoader` renamed to `ColumnScanner`, LoadColumn renamed to\n  ScanColumn, `NewRecord() interface{}` changed to `NewModel() ColumnScanner`,\n  `AppendQuery(dst []byte) []byte` changed to `AppendValue(dst []byte, quote bool) ([]byte, error)`.\n- Structs, maps and slices are marshalled to JSON by default.\n- Added support for scanning slices, .e.g. scanning `[]int`.\n- Added object relational mapping.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.27734375,
          "content": "Copyright (c) 2013 github.com/go-pg/pg Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.69921875,
          "content": "PACKAGE_DIRS := $(shell find . -mindepth 2 -type f -name 'go.mod' -exec dirname {} \\; | sort)\n\nall:\n\tTZ= go test ./...\n\tTZ= go test ./... -short -race\n\tTZ= go test ./... -run=NONE -bench=. -benchmem\n\tenv GOOS=linux GOARCH=386 go test ./...\n\tgo vet\n\tgolangci-lint run\n\n.PHONY: test\ntest:\n\tTZ= PGSSLMODE=disable go test ./... -v -race\n\ntag:\n\tgit tag $(VERSION)\n\tgit tag extra/pgdebug/$(VERSION)\n\tgit tag extra/pgotel/$(VERSION)\n\tgit tag extra/pgsegment/$(VERSION)\n\nfmt:\n\tgofmt -w -s ./\n\tgoimports -w  -local github.com/go-pg/pg ./\n\ngo_mod_tidy:\n\tgo get -u && go mod tidy\n\tset -e; for dir in $(PACKAGE_DIRS); do \\\n\t  echo \"go mod tidy in $${dir}\"; \\\n\t  (cd \"$${dir}\" && \\\n\t    go get -u && \\\n\t    go mod tidy); \\\n\tdone\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.3408203125,
          "content": "# PostgreSQL client and ORM for Golang\n\n## Maintenance mode\n\ngo-pg is in a maintenance mode and only critical issues are addressed. New development happens in\n[**Bun**](https://bun.uptrace.dev/guide/pg-migration.html) repo which offers similar functionality\nbut works with PostgreSQL, MySQL, MariaDB, and SQLite.\n\n## [Golang ORM](https://github.com/uptrace/bun)\n\n---\n\n[![Go](https://github.com/go-pg/pg/actions/workflows/build.yml/badge.svg?branch=v10)](https://github.com/go-pg/pg/actions/workflows/build.yml)\n[![PkgGoDev](https://pkg.go.dev/badge/github.com/go-pg/pg/v10)](https://pkg.go.dev/github.com/go-pg/pg/v10)\n[![Documentation](https://img.shields.io/badge/pg-documentation-informational)](https://pg.uptrace.dev/)\n[![Chat](https://discordapp.com/api/guilds/752070105847955518/widget.png)](https://discord.gg/rWtp5Aj)\n\n- [Documentation](https://pg.uptrace.dev)\n- [Reference](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc)\n- [Examples](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#pkg-examples)\n- Example projects:\n  - [monetr](https://github.com/monetr/monetr) - budgeting application focused on planning for\n    recurring expenses\n  - [bunrouter](https://github.com/go-bun/bun-realworld-app)\n  - [gin](https://github.com/gogjango/gjango)\n  - [go-kit](https://github.com/Tsovak/rest-api-demo)\n  - [aah framework](https://github.com/kieusonlam/golamapi)\n\n## Tutorials\n\n- [GraphQL Tutorial on YouTube](https://www.youtube.com/playlist?list=PLzQWIQOqeUSNwXcneWYJHUREAIucJ5UZn).\n- [Modern API design with Golang, PostgreSQL and Docker](https://bognov.tech/modern-api-design-with-golang-postgresql-and-docker)\n\n## Ecosystem\n\n- Migrations by [vmihailenco](https://github.com/go-pg/migrations) and\n  [robinjoseph08](https://github.com/robinjoseph08/go-pg-migrations).\n- [Genna - cli tool for generating go-pg models](https://github.com/dizzyfool/genna).\n- [bigint](https://github.com/d-fal/bigint) - big.Int type for go-pg.\n- [urlstruct](https://github.com/go-pg/urlstruct) to decode `url.Values` into structs.\n- [Sharding](https://github.com/go-pg/sharding).\n- [go-pg-monitor](https://github.com/hypnoglow/go-pg-monitor) - Prometheus metrics based on go-pg\n  client stats.\n\n## Features\n\n- Basic types: integers, floats, string, bool, time.Time, net.IP, net.IPNet.\n- sql.NullBool, sql.NullString, sql.NullInt64, sql.NullFloat64 and\n  [pg.NullTime](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#NullTime).\n- [sql.Scanner](http://golang.org/pkg/database/sql/#Scanner) and\n  [sql/driver.Valuer](http://golang.org/pkg/database/sql/driver/#Valuer) interfaces.\n- Structs, maps and arrays are marshalled as JSON by default.\n- PostgreSQL multidimensional Arrays using\n  [array tag](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB-Model-PostgresArrayStructTag)\n  and [Array wrapper](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-Array).\n- Hstore using\n  [hstore tag](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB-Model-HstoreStructTag)\n  and [Hstore wrapper](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-Hstore).\n- [Composite types](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB-Model-CompositeType).\n- All struct fields are nullable by default and zero values (empty string, 0, zero time, empty map\n  or slice, nil ptr) are marshalled as SQL `NULL`. `pg:\",notnull\"` is used to add SQL `NOT NULL`\n  constraint and `pg:\",use_zero\"` to allow Go zero values.\n- [Transactions](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB-Begin).\n- [Prepared statements](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB-Prepare).\n- [Notifications](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-Listener) using\n  `LISTEN` and `NOTIFY`.\n- [Copying data](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB-CopyFrom) using\n  `COPY FROM` and `COPY TO`.\n- [Timeouts](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#Options) and canceling queries using\n  context.Context.\n- Automatic connection pooling with\n  [circuit breaker](https://en.wikipedia.org/wiki/Circuit_breaker_design_pattern) support.\n- Queries retry on network errors.\n- Working with models using\n  [ORM](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB.Model) and\n  [SQL](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB.Query).\n- Scanning variables using\n  [ORM](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB.Model-SelectSomeColumnsIntoVars)\n  and [SQL](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-Scan).\n- [SelectOrInsert](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB.Model-InsertSelectOrInsert)\n  using on-conflict.\n- [INSERT ... ON CONFLICT DO UPDATE](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB.Model-InsertOnConflictDoUpdate)\n  using ORM.\n- Bulk/batch\n  [inserts](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB.Model-BulkInsert),\n  [updates](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB.Model-BulkUpdate), and\n  [deletes](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB.Model-BulkDelete).\n- Common table expressions using\n  [WITH](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB.Model-SelectWith) and\n  [WrapWith](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB.Model-SelectWrapWith).\n- [CountEstimate](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB.Model-CountEstimate)\n  using `EXPLAIN` to get\n  [estimated number of matching rows](https://wiki.postgresql.org/wiki/Count_estimate).\n- ORM supports\n  [has one](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB.Model-HasOne),\n  [belongs to](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB.Model-BelongsTo),\n  [has many](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB.Model-HasMany), and\n  [many to many](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB.Model-ManyToMany)\n  with composite/multi-column primary keys.\n- [Soft deletes](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB.Model-SoftDelete).\n- [Creating tables from structs](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB.Model-CreateTable).\n- [ForEach](https://pkg.go.dev/github.com/go-pg/pg/v10?tab=doc#example-DB.Model-ForEach) that calls\n  a function for each row returned by the query without loading all rows into the memory.\n\n## Installation\n\ngo-pg supports 2 last Go versions and requires a Go version with\n[modules](https://github.com/golang/go/wiki/Modules) support. So make sure to initialize a Go\nmodule:\n\n```shell\ngo mod init github.com/my/repo\n```\n\nAnd then install go-pg (note _v10_ in the import; omitting it is a popular mistake):\n\n```shell\ngo get github.com/go-pg/pg/v10\n```\n\n## Quickstart\n\n```go\npackage pg_test\n\nimport (\n    \"fmt\"\n\n    \"github.com/go-pg/pg/v10\"\n    \"github.com/go-pg/pg/v10/orm\"\n)\n\ntype User struct {\n    Id     int64\n    Name   string\n    Emails []string\n}\n\nfunc (u User) String() string {\n    return fmt.Sprintf(\"User<%d %s %v>\", u.Id, u.Name, u.Emails)\n}\n\ntype Story struct {\n    Id       int64\n    Title    string\n    AuthorId int64\n    Author   *User `pg:\"rel:has-one\"`\n}\n\nfunc (s Story) String() string {\n    return fmt.Sprintf(\"Story<%d %s %s>\", s.Id, s.Title, s.Author)\n}\n\nfunc ExampleDB_Model() {\n    db := pg.Connect(&pg.Options{\n        User: \"postgres\",\n    })\n    defer db.Close()\n\n    err := createSchema(db)\n    if err != nil {\n        panic(err)\n    }\n\n    user1 := &User{\n        Name:   \"admin\",\n        Emails: []string{\"admin1@admin\", \"admin2@admin\"},\n    }\n    _, err = db.Model(user1).Insert()\n    if err != nil {\n        panic(err)\n    }\n\n    _, err = db.Model(&User{\n        Name:   \"root\",\n        Emails: []string{\"root1@root\", \"root2@root\"},\n    }).Insert()\n    if err != nil {\n        panic(err)\n    }\n\n    story1 := &Story{\n        Title:    \"Cool story\",\n        AuthorId: user1.Id,\n    }\n    _, err = db.Model(story1).Insert()\n    if err != nil {\n        panic(err)\n    }\n\n    // Select user by primary key.\n    user := &User{Id: user1.Id}\n    err = db.Model(user).WherePK().Select()\n    if err != nil {\n        panic(err)\n    }\n\n    // Select all users.\n    var users []User\n    err = db.Model(&users).Select()\n    if err != nil {\n        panic(err)\n    }\n\n    // Select story and associated author in one query.\n    story := new(Story)\n    err = db.Model(story).\n        Relation(\"Author\").\n        Where(\"story.id = ?\", story1.Id).\n        Select()\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Println(user)\n    fmt.Println(users)\n    fmt.Println(story)\n    // Output: User<1 admin [admin1@admin admin2@admin]>\n    // [User<1 admin [admin1@admin admin2@admin]> User<2 root [root1@root root2@root]>]\n    // Story<1 Cool story User<1 admin [admin1@admin admin2@admin]>>\n}\n\n// createSchema creates database schema for User and Story models.\nfunc createSchema(db *pg.DB) error {\n    models := []interface{}{\n        (*User)(nil),\n        (*Story)(nil),\n    }\n\n    for _, model := range models {\n        err := db.Model(model).CreateTable(&orm.CreateTableOptions{\n            Temp: true,\n        })\n        if err != nil {\n            return err\n        }\n    }\n    return nil\n}\n```\n\n## See also\n\n- [Golang PostgreSQL](https://bun.uptrace.dev/postgres/)\n- [Golang HTTP router](https://github.com/uptrace/bunrouter)\n- [Golang ClickHouse ORM](https://github.com/uptrace/go-clickhouse)\n- [Golang msgpack](https://github.com/vmihailenco/msgpack)\n- [Distributed tracing tools](https://get.uptrace.dev/compare/distributed-tracing-tools.html)\n"
        },
        {
          "name": "base.go",
          "type": "blob",
          "size": 15.013671875,
          "content": "package pg\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"time\"\n\n\t\"github.com/go-pg/pg/v10/internal\"\n\t\"github.com/go-pg/pg/v10/internal/pool\"\n\t\"github.com/go-pg/pg/v10/orm\"\n\t\"github.com/go-pg/pg/v10/types\"\n)\n\ntype baseDB struct {\n\tdb   orm.DB\n\topt  *Options\n\tpool pool.Pooler\n\n\tfmter      *orm.Formatter\n\tqueryHooks []QueryHook\n}\n\n// PoolStats contains the stats of a connection pool.\ntype PoolStats pool.Stats\n\n// PoolStats returns connection pool stats.\nfunc (db *baseDB) PoolStats() *PoolStats {\n\tstats := db.pool.Stats()\n\treturn (*PoolStats)(stats)\n}\n\nfunc (db *baseDB) clone() *baseDB {\n\treturn &baseDB{\n\t\tdb:   db.db,\n\t\topt:  db.opt,\n\t\tpool: db.pool,\n\n\t\tfmter:      db.fmter,\n\t\tqueryHooks: copyQueryHooks(db.queryHooks),\n\t}\n}\n\nfunc (db *baseDB) withPool(p pool.Pooler) *baseDB {\n\tcp := db.clone()\n\tcp.pool = p\n\treturn cp\n}\n\nfunc (db *baseDB) WithTimeout(d time.Duration) *baseDB {\n\tnewopt := *db.opt\n\tnewopt.ReadTimeout = d\n\tnewopt.WriteTimeout = d\n\n\tcp := db.clone()\n\tcp.opt = &newopt\n\treturn cp\n}\n\nfunc (db *baseDB) WithParam(param string, value interface{}) *baseDB {\n\tcp := db.clone()\n\tcp.fmter = db.fmter.WithParam(param, value)\n\treturn cp\n}\n\n// Param returns value for the param.\nfunc (db *baseDB) Param(param string) interface{} {\n\treturn db.fmter.Param(param)\n}\n\nfunc (db *baseDB) retryBackoff(retry int) time.Duration {\n\treturn internal.RetryBackoff(retry, db.opt.MinRetryBackoff, db.opt.MaxRetryBackoff)\n}\n\nfunc (db *baseDB) getConn(ctx context.Context) (*pool.Conn, error) {\n\tcn, err := db.pool.Get(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif cn.Inited {\n\t\treturn cn, nil\n\t}\n\n\tif err := db.initConn(ctx, cn); err != nil {\n\t\tdb.pool.Remove(ctx, cn, err)\n\t\t// It is safe to reset StickyConnPool if conn can't be initialized.\n\t\tif p, ok := db.pool.(*pool.StickyConnPool); ok {\n\t\t\t_ = p.Reset(ctx)\n\t\t}\n\t\tif err := internal.Unwrap(err); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn cn, nil\n}\n\nfunc (db *baseDB) initConn(ctx context.Context, cn *pool.Conn) error {\n\tif cn.Inited {\n\t\treturn nil\n\t}\n\tcn.Inited = true\n\n\tif db.opt.TLSConfig != nil {\n\t\terr := db.enableSSL(ctx, cn, db.opt.TLSConfig)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\terr := db.startup(ctx, cn, db.opt.User, db.opt.Password, db.opt.Database, db.opt.ApplicationName)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif db.opt.OnConnect != nil {\n\t\tp := pool.NewSingleConnPool(db.pool, cn)\n\t\treturn db.opt.OnConnect(ctx, newConn(ctx, db.withPool(p)))\n\t}\n\n\treturn nil\n}\n\nfunc (db *baseDB) releaseConn(ctx context.Context, cn *pool.Conn, err error) {\n\tif bad, code := isBadConn(err, false); bad {\n\t\tif code != \"25P02\" { // canceling statement if it is a bad conn expect 25P02 (current transaction is aborted)\n\t\t\terr := db.cancelRequest(cn.ProcessID, cn.SecretKey)\n\t\t\tif err != nil {\n\t\t\t\tinternal.Logger.Printf(ctx, \"cancelRequest failed: %s\", err)\n\t\t\t}\n\t\t}\n\t\tdb.pool.Remove(ctx, cn, err)\n\t} else {\n\t\tdb.pool.Put(ctx, cn)\n\t}\n}\n\nfunc (db *baseDB) withConn(\n\tctx context.Context, fn func(context.Context, *pool.Conn) error,\n) error {\n\tcn, err := db.getConn(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar fnDone chan struct{}\n\tif ctx != nil && ctx.Done() != nil {\n\t\tfnDone = make(chan struct{})\n\t\tgo func() {\n\t\t\tselect {\n\t\t\tcase <-fnDone: // fn has finished, skip cancel\n\t\t\tcase <-ctx.Done():\n\t\t\t\terr := db.cancelRequest(cn.ProcessID, cn.SecretKey)\n\t\t\t\tif err != nil {\n\t\t\t\t\tinternal.Logger.Printf(ctx, \"cancelRequest failed: %s\", err)\n\t\t\t\t}\n\t\t\t\t// Signal end of conn use.\n\t\t\t\tfnDone <- struct{}{}\n\t\t\t}\n\t\t}()\n\t}\n\n\tdefer func() {\n\t\tif fnDone == nil {\n\t\t\tdb.releaseConn(ctx, cn, err)\n\t\t\treturn\n\t\t}\n\n\t\tselect {\n\t\tcase <-fnDone: // wait for cancel to finish request\n\t\t\t// Looks like the canceled connection must be always removed from the pool.\n\t\t\tdb.pool.Remove(ctx, cn, err)\n\t\tcase fnDone <- struct{}{}: // signal fn finish, skip cancel goroutine\n\t\t\tdb.releaseConn(ctx, cn, err)\n\t\t}\n\t}()\n\n\terr = fn(ctx, cn)\n\treturn err\n}\n\nfunc (db *baseDB) shouldRetry(err error) bool {\n\tswitch err {\n\tcase io.EOF, io.ErrUnexpectedEOF:\n\t\treturn true\n\tcase nil, context.Canceled, context.DeadlineExceeded:\n\t\treturn false\n\t}\n\n\tif pgerr, ok := err.(Error); ok {\n\t\tswitch pgerr.Field('C') {\n\t\tcase \"40001\", // serialization_failure\n\t\t\t\"53300\", // too_many_connections\n\t\t\t\"55000\": // attempted to delete invisible tuple\n\t\t\treturn true\n\t\tcase \"57014\": // statement_timeout\n\t\t\treturn db.opt.RetryStatementTimeout\n\t\tdefault:\n\t\t\treturn false\n\t\t}\n\t}\n\n\tif _, ok := err.(timeoutError); ok {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// Close closes the database client, releasing any open resources.\n//\n// It is rare to Close a DB, as the DB handle is meant to be\n// long-lived and shared between many goroutines.\nfunc (db *baseDB) Close() error {\n\treturn db.pool.Close()\n}\n\n// Exec executes a query ignoring returned rows. The params are for any\n// placeholders in the query.\nfunc (db *baseDB) Exec(query interface{}, params ...interface{}) (res Result, err error) {\n\treturn db.exec(db.db.Context(), query, params...)\n}\n\nfunc (db *baseDB) ExecContext(c context.Context, query interface{}, params ...interface{}) (Result, error) {\n\treturn db.exec(c, query, params...)\n}\n\nfunc (db *baseDB) exec(ctx context.Context, query interface{}, params ...interface{}) (Result, error) {\n\twb := db.pool.GetWriteBuffer()\n\tdefer db.pool.PutWriteBuffer(wb)\n\n\tif err := writeQueryMsg(wb, db.fmter, query, params...); err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx, evt, err := db.beforeQuery(ctx, db.db, nil, query, params, wb.Query())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar res Result\n\tvar lastErr error\n\tfor attempt := 0; attempt <= db.opt.MaxRetries; attempt++ {\n\t\tif attempt > 0 {\n\t\t\tif err := internal.Sleep(ctx, db.retryBackoff(attempt-1)); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tlastErr = db.withConn(ctx, func(ctx context.Context, cn *pool.Conn) error {\n\t\t\tres, err = db.simpleQuery(ctx, cn, wb)\n\t\t\treturn err\n\t\t})\n\t\tif !db.shouldRetry(lastErr) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err := db.afterQuery(ctx, evt, res, lastErr); err != nil {\n\t\treturn nil, err\n\t}\n\treturn res, lastErr\n}\n\n// ExecOne acts like Exec, but query must affect only one row. It\n// returns ErrNoRows error when query returns zero rows or\n// ErrMultiRows when query returns multiple rows.\nfunc (db *baseDB) ExecOne(query interface{}, params ...interface{}) (Result, error) {\n\treturn db.execOne(db.db.Context(), query, params...)\n}\n\nfunc (db *baseDB) ExecOneContext(ctx context.Context, query interface{}, params ...interface{}) (Result, error) {\n\treturn db.execOne(ctx, query, params...)\n}\n\nfunc (db *baseDB) execOne(c context.Context, query interface{}, params ...interface{}) (Result, error) {\n\tres, err := db.ExecContext(c, query, params...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := internal.AssertOneRow(res.RowsAffected()); err != nil {\n\t\treturn nil, err\n\t}\n\treturn res, nil\n}\n\n// Query executes a query that returns rows, typically a SELECT.\n// The params are for any placeholders in the query.\nfunc (db *baseDB) Query(model, query interface{}, params ...interface{}) (res Result, err error) {\n\treturn db.query(db.db.Context(), model, query, params...)\n}\n\nfunc (db *baseDB) QueryContext(c context.Context, model, query interface{}, params ...interface{}) (Result, error) {\n\treturn db.query(c, model, query, params...)\n}\n\nfunc (db *baseDB) query(ctx context.Context, model, query interface{}, params ...interface{}) (Result, error) {\n\twb := db.pool.GetWriteBuffer()\n\tdefer db.pool.PutWriteBuffer(wb)\n\n\tif err := writeQueryMsg(wb, db.fmter, query, params...); err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx, evt, err := db.beforeQuery(ctx, db.db, model, query, params, wb.Query())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar res Result\n\tvar lastErr error\n\tfor attempt := 0; attempt <= db.opt.MaxRetries; attempt++ {\n\t\tif attempt > 0 {\n\t\t\tif err := internal.Sleep(ctx, db.retryBackoff(attempt-1)); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tlastErr = db.withConn(ctx, func(ctx context.Context, cn *pool.Conn) error {\n\t\t\tres, err = db.simpleQueryData(ctx, cn, model, wb)\n\t\t\treturn err\n\t\t})\n\t\tif !db.shouldRetry(lastErr) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err := db.afterQuery(ctx, evt, res, lastErr); err != nil {\n\t\treturn nil, err\n\t}\n\treturn res, lastErr\n}\n\n// QueryOne acts like Query, but query must return only one row. It\n// returns ErrNoRows error when query returns zero rows or\n// ErrMultiRows when query returns multiple rows.\nfunc (db *baseDB) QueryOne(model, query interface{}, params ...interface{}) (Result, error) {\n\treturn db.queryOne(db.db.Context(), model, query, params...)\n}\n\nfunc (db *baseDB) QueryOneContext(\n\tctx context.Context, model, query interface{}, params ...interface{},\n) (Result, error) {\n\treturn db.queryOne(ctx, model, query, params...)\n}\n\nfunc (db *baseDB) queryOne(ctx context.Context, model, query interface{}, params ...interface{}) (Result, error) {\n\tres, err := db.QueryContext(ctx, model, query, params...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := internal.AssertOneRow(res.RowsAffected()); err != nil {\n\t\treturn nil, err\n\t}\n\treturn res, nil\n}\n\n// CopyFrom copies data from reader to a table.\nfunc (db *baseDB) CopyFrom(r io.Reader, query interface{}, params ...interface{}) (res Result, err error) {\n\tc := db.db.Context()\n\terr = db.withConn(c, func(c context.Context, cn *pool.Conn) error {\n\t\tres, err = db.copyFrom(c, cn, r, query, params...)\n\t\treturn err\n\t})\n\treturn res, err\n}\n\n// TODO: don't get/put conn in the pool.\nfunc (db *baseDB) copyFrom(\n\tctx context.Context, cn *pool.Conn, r io.Reader, query interface{}, params ...interface{},\n) (res Result, err error) {\n\tvar evt *QueryEvent\n\n\twb := db.pool.GetWriteBuffer()\n\tdefer db.pool.PutWriteBuffer(wb)\n\n\tif err := writeQueryMsg(wb, db.fmter, query, params...); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar model interface{}\n\tif len(params) > 0 {\n\t\tmodel, _ = params[len(params)-1].(orm.TableModel)\n\t}\n\n\tctx, evt, err = db.beforeQuery(ctx, db.db, model, query, params, wb.Query())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Note that afterQuery uses the err.\n\tdefer func() {\n\t\tif afterQueryErr := db.afterQuery(ctx, evt, res, err); afterQueryErr != nil {\n\t\t\terr = afterQueryErr\n\t\t}\n\t}()\n\n\terr = cn.WithWriter(ctx, db.opt.WriteTimeout, func(wb *pool.WriteBuffer) error {\n\t\treturn writeQueryMsg(wb, db.fmter, query, params...)\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = cn.WithReader(ctx, db.opt.ReadTimeout, readCopyInResponse)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor {\n\t\terr = cn.WithWriter(ctx, db.opt.WriteTimeout, func(wb *pool.WriteBuffer) error {\n\t\t\treturn writeCopyData(wb, r)\n\t\t})\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\terr = cn.WithWriter(ctx, db.opt.WriteTimeout, func(wb *pool.WriteBuffer) error {\n\t\twriteCopyDone(wb)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = cn.WithReader(ctx, db.opt.ReadTimeout, func(rd *pool.ReaderContext) error {\n\t\tres, err = readReadyForQuery(rd)\n\t\treturn err\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn res, nil\n}\n\n// CopyTo copies data from a table to writer.\nfunc (db *baseDB) CopyTo(w io.Writer, query interface{}, params ...interface{}) (res Result, err error) {\n\tc := db.db.Context()\n\terr = db.withConn(c, func(c context.Context, cn *pool.Conn) error {\n\t\tres, err = db.copyTo(c, cn, w, query, params...)\n\t\treturn err\n\t})\n\treturn res, err\n}\n\nfunc (db *baseDB) copyTo(\n\tctx context.Context, cn *pool.Conn, w io.Writer, query interface{}, params ...interface{},\n) (res Result, err error) {\n\tvar evt *QueryEvent\n\n\twb := db.pool.GetWriteBuffer()\n\tdefer db.pool.PutWriteBuffer(wb)\n\n\tif err := writeQueryMsg(wb, db.fmter, query, params...); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar model interface{}\n\tif len(params) > 0 {\n\t\tmodel, _ = params[len(params)-1].(orm.TableModel)\n\t}\n\n\tctx, evt, err = db.beforeQuery(ctx, db.db, model, query, params, wb.Query())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Note that afterQuery uses the err.\n\tdefer func() {\n\t\tif afterQueryErr := db.afterQuery(ctx, evt, res, err); afterQueryErr != nil {\n\t\t\terr = afterQueryErr\n\t\t}\n\t}()\n\n\terr = cn.WithWriter(ctx, db.opt.WriteTimeout, func(wb *pool.WriteBuffer) error {\n\t\treturn writeQueryMsg(wb, db.fmter, query, params...)\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = cn.WithReader(ctx, db.opt.ReadTimeout, func(rd *pool.ReaderContext) error {\n\t\terr := readCopyOutResponse(rd)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tres, err = readCopyData(rd, w)\n\t\treturn err\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn res, nil\n}\n\n// Ping verifies a connection to the database is still alive,\n// establishing a connection if necessary.\nfunc (db *baseDB) Ping(ctx context.Context) error {\n\t_, err := db.ExecContext(ctx, \"SELECT 1\")\n\treturn err\n}\n\n// Model returns new query for the model.\nfunc (db *baseDB) Model(model ...interface{}) *Query {\n\treturn orm.NewQuery(db.db, model...)\n}\n\nfunc (db *baseDB) ModelContext(c context.Context, model ...interface{}) *Query {\n\treturn orm.NewQueryContext(c, db.db, model...)\n}\n\nfunc (db *baseDB) Formatter() orm.QueryFormatter {\n\treturn db.fmter\n}\n\nfunc (db *baseDB) cancelRequest(processID, secretKey int32) error {\n\tc := context.TODO()\n\n\tcn, err := db.pool.NewConn(c)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\t_ = db.pool.CloseConn(cn)\n\t}()\n\n\treturn cn.WithWriter(c, db.opt.WriteTimeout, func(wb *pool.WriteBuffer) error {\n\t\twriteCancelRequestMsg(wb, processID, secretKey)\n\t\treturn nil\n\t})\n}\n\nfunc (db *baseDB) simpleQuery(\n\tc context.Context, cn *pool.Conn, wb *pool.WriteBuffer,\n) (*result, error) {\n\tif err := cn.WriteBuffer(c, db.opt.WriteTimeout, wb); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar res *result\n\tif err := cn.WithReader(c, db.opt.ReadTimeout, func(rd *pool.ReaderContext) error {\n\t\tvar err error\n\t\tres, err = readSimpleQuery(rd)\n\t\treturn err\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn res, nil\n}\n\nfunc (db *baseDB) simpleQueryData(\n\tc context.Context, cn *pool.Conn, model interface{}, wb *pool.WriteBuffer,\n) (*result, error) {\n\tif err := cn.WriteBuffer(c, db.opt.WriteTimeout, wb); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar res *result\n\tif err := cn.WithReader(c, db.opt.ReadTimeout, func(rd *pool.ReaderContext) error {\n\t\tvar err error\n\t\tres, err = readSimpleQueryData(c, rd, model)\n\t\treturn err\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn res, nil\n}\n\n// Prepare creates a prepared statement for later queries or\n// executions. Multiple queries or executions may be run concurrently\n// from the returned statement.\nfunc (db *baseDB) Prepare(q string) (*Stmt, error) {\n\treturn prepareStmt(db.withPool(pool.NewStickyConnPool(db.pool)), q)\n}\n\nfunc (db *baseDB) prepare(\n\tc context.Context, cn *pool.Conn, q string,\n) (string, []types.ColumnInfo, error) {\n\tname := cn.NextID()\n\terr := cn.WithWriter(c, db.opt.WriteTimeout, func(wb *pool.WriteBuffer) error {\n\t\twriteParseDescribeSyncMsg(wb, name, q)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\tvar columns []types.ColumnInfo\n\terr = cn.WithReader(c, db.opt.ReadTimeout, func(rd *pool.ReaderContext) error {\n\t\tcolumns, err = readParseDescribeSync(rd)\n\t\treturn err\n\t})\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\treturn name, columns, nil\n}\n\nfunc (db *baseDB) closeStmt(c context.Context, cn *pool.Conn, name string) error {\n\terr := cn.WithWriter(c, db.opt.WriteTimeout, func(wb *pool.WriteBuffer) error {\n\t\twriteCloseMsg(wb, name)\n\t\twriteFlushMsg(wb)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = cn.WithReader(c, db.opt.ReadTimeout, readCloseCompleteMsg)\n\treturn err\n}\n"
        },
        {
          "name": "base_test.go",
          "type": "blob",
          "size": 3.2265625,
          "content": "package pg\n\nimport (\n\t\"context\"\n\t\"encoding/binary\"\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-pg/pg/v10/internal/pool\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n/*\nThe test is for testing the case that sending a cancel request when the timeout from connection comes earlier than ctx.Done().\n*/\nfunc Test_baseDB_withConn(t *testing.T) {\n\tb := mockBaseDB{}\n\tb.init()\n\tb.pool = &mockPooler{}\n\tctx, _ := context.WithDeadline(context.TODO(), time.Now().Add(1000*time.Second)) // Make a deadline in context further than the timeout of connection.\n\tb.withConn(ctx, func(context.Context, *pool.Conn) error {\n\t\t// Immediately returns the error, so it is faster than the ctx.Done() returns. The error code here according to the function `isBadConn`.\n\t\treturn &mockPGError{map[byte]string{byte('C'): \"57014\"}}\n\t})\n\t// In the new change, a cancel request is sent to db and that connection is removed from the connection pool.\n\t// Check if the cancel request, its code int32(80877102), is sent.\n\tassert.Equal(t, int32(80877102), b.pool.(*mockPooler).mockConn.cancelCode)\n\tassert.True(t, b.pool.(*mockPooler).toRemove)\n}\n\ntype mockBaseDB struct {\n\tbaseDB\n}\n\nfunc (m *mockBaseDB) init() {\n\tm.opt = &Options{}\n}\n\ntype mockPooler struct {\n\tconn     *pool.Conn\n\ttoRemove bool\n\tmockConn mockConn\n}\n\nfunc (m *mockPooler) NewConn(ctx context.Context) (*pool.Conn, error) {\n\tm.mockConn = mockConn{}\n\tm.conn = pool.NewConn(&m.mockConn, pool.NewConnPool(&pool.Options{}))\n\tm.conn.ProcessID = 123\n\tm.conn.SecretKey = 234\n\treturn m.conn, nil\n}\n\nfunc (m *mockPooler) CloseConn(conn *pool.Conn) error {\n\treturn nil\n}\n\nfunc (m *mockPooler) Get(ctx context.Context) (*pool.Conn, error) {\n\treturn &pool.Conn{ProcessID: 123, SecretKey: 234, Inited: true}, nil\n}\n\nfunc (m *mockPooler) Put(ctx context.Context, conn *pool.Conn) {\n\treturn\n}\n\nfunc (m *mockPooler) Remove(ctx context.Context, conn *pool.Conn, err error) {\n\tm.toRemove = true\n\treturn\n}\n\nfunc (m *mockPooler) Len() int {\n\treturn 1\n}\n\nfunc (m *mockPooler) IdleLen() int {\n\treturn 1\n}\n\nfunc (m *mockPooler) Stats() *pool.Stats {\n\treturn nil\n}\n\nfunc (m *mockPooler) Close() error {\n\treturn nil\n}\n\nfunc (m *mockPooler) GetWriteBuffer() *pool.WriteBuffer {\n\treturn pool.NewWriteBuffer(1024)\n}\n\nfunc (m *mockPooler) PutWriteBuffer(_ *pool.WriteBuffer) {\n}\n\nfunc (m *mockPooler) GetReaderContext() *pool.ReaderContext {\n\treturn pool.NewReaderContext(1024)\n}\n\nfunc (m *mockPooler) PutReaderContext(_ *pool.ReaderContext) {\n}\n\ntype mockPGError struct {\n\tM map[byte]string\n}\n\nfunc (m *mockPGError) Error() string {\n\treturn \"\"\n}\n\nfunc (m *mockPGError) Field(field byte) string {\n\treturn m.M[field]\n}\n\nfunc (m *mockPGError) IntegrityViolation() bool {\n\treturn false\n}\n\ntype mockConn struct {\n\tcancelCode int32\n}\n\nfunc (m *mockConn) Read(b []byte) (n int, err error) {\n\treturn 0, nil\n}\n\nfunc (m *mockConn) Write(b []byte) (n int, err error) {\n\tm.cancelCode = int32(binary.BigEndian.Uint32(b[4:8]))\n\treturn 0, nil\n}\n\nfunc (m *mockConn) Close() error {\n\treturn nil\n}\n\nfunc (m *mockConn) LocalAddr() net.Addr {\n\treturn nil\n}\n\nfunc (m *mockConn) RemoteAddr() net.Addr {\n\treturn nil\n}\n\nfunc (m *mockConn) SetDeadline(t time.Time) error {\n\treturn nil\n}\n\nfunc (m *mockConn) SetReadDeadline(t time.Time) error {\n\treturn nil\n}\n\nfunc (m *mockConn) SetWriteDeadline(t time.Time) error {\n\treturn nil\n}\n"
        },
        {
          "name": "bench_test.go",
          "type": "blob",
          "size": 10.546875,
          "content": "package pg_test\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"strconv\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-pg/pg/v10\"\n\t\"github.com/go-pg/pg/v10/orm\"\n\t\"github.com/go-pg/pg/v10/types\"\n)\n\nfunc benchmarkDB() *pg.DB {\n\treturn pg.Connect(&pg.Options{\n\t\tUser:         \"postgres\",\n\t\tPassword:     \"postgres\",\n\t\tDatabase:     \"postgres\",\n\t\tDialTimeout:  30 * time.Second,\n\t\tReadTimeout:  10 * time.Second,\n\t\tWriteTimeout: 10 * time.Second,\n\t\tPoolSize:     10,\n\t\tPoolTimeout:  30 * time.Second,\n\t})\n}\n\nfunc BenchmarkQueryRowsGopgDiscard(b *testing.B) {\n\tseedDB()\n\n\tdb := benchmarkDB()\n\tdefer db.Close()\n\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_, err := db.Query(pg.Discard, `SELECT * FROM records LIMIT 100`)\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkQueryRowsGopgOptimized(b *testing.B) {\n\tseedDB()\n\n\tdb := benchmarkDB()\n\tdefer db.Close()\n\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tvar rs OptRecords\n\t\t\t_, err := db.Query(&rs, `SELECT * FROM records LIMIT 100`)\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t\tif len(rs.C) != 100 {\n\t\t\t\tb.Fatalf(\"got %d, wanted 100\", len(rs.C))\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkQueryRowsGopgReflect(b *testing.B) {\n\tseedDB()\n\n\tdb := benchmarkDB()\n\tdefer db.Close()\n\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tvar rs []Record\n\t\t\t_, err := db.Query(&rs, `SELECT * FROM records LIMIT 100`)\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t\tif len(rs) != 100 {\n\t\t\t\tb.Fatalf(\"got %d, wanted 100\", len(rs))\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkQueryRowsGopgORM(b *testing.B) {\n\tseedDB()\n\n\tdb := benchmarkDB()\n\tdefer db.Close()\n\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tvar rs []Record\n\t\t\terr := db.Model(&rs).Limit(100).Select()\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t\tif len(rs) != 100 {\n\t\t\t\tb.Fatalf(\"got %d, wanted 100\", len(rs))\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkModelHasOneGopg(b *testing.B) {\n\tseedDB()\n\n\tdb := benchmarkDB()\n\tdefer db.Close()\n\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tvar books []Book\n\t\t\terr := db.Model(&books).Column(\"book.*\").Relation(\"Author\").Limit(100).Select()\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\n\t\t\tif len(books) != 100 {\n\t\t\t\tb.Fatalf(\"got %d, wanted 100\", len(books))\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkModelHasManyGopg(b *testing.B) {\n\tseedDB()\n\n\tdb := benchmarkDB()\n\tdefer db.Close()\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tvar books []Book\n\t\t\terr := db.Model(&books).Column(\"book.*\").Relation(\"Translations\").Limit(100).Select()\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\n\t\t\tif len(books) != 100 {\n\t\t\t\tb.Fatalf(\"got %d, wanted 100\", len(books))\n\t\t\t}\n\t\t\tfor _, book := range books {\n\t\t\t\tif len(book.Translations) != 10 {\n\t\t\t\t\tb.Fatalf(\"got %d, wanted 10\", len(book.Translations))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkModelHasMany2ManyGopg(b *testing.B) {\n\tseedDB()\n\n\tdb := benchmarkDB()\n\tdefer db.Close()\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tvar books []Book\n\t\t\terr := db.Model(&books).\n\t\t\t\tColumn(\"book.*\").Relation(\"Genres\").\n\t\t\t\tLimit(100).\n\t\t\t\tSelect()\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\n\t\t\tif len(books) != 100 {\n\t\t\t\tb.Fatalf(\"got %d, wanted 100\", len(books))\n\t\t\t}\n\t\t\tfor _, book := range books {\n\t\t\t\tif len(book.Genres) != 10 {\n\t\t\t\t\tb.Fatalf(\"got %d, wanted 10\", len(book.Genres))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkQueryRow(b *testing.B) {\n\tdb := benchmarkDB()\n\tdefer db.Close()\n\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tvar dst numLoader\n\t\t_, err := db.QueryOne(&dst, `SELECT ?::bigint AS num`, 1)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tif dst.Num != 1 {\n\t\t\tb.Fatalf(\"got %d, wanted 1\", dst.Num)\n\t\t}\n\t}\n}\n\nfunc BenchmarkQueryRowStmt(b *testing.B) {\n\tdb := benchmarkDB()\n\tdefer db.Close()\n\n\tstmt, err := db.Prepare(`SELECT $1::bigint AS num`)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tdefer stmt.Close()\n\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tvar dst numLoader\n\t\t_, err := stmt.QueryOne(&dst, 1)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tif dst.Num != 1 {\n\t\t\tb.Fatalf(\"got %d, wanted 1\", dst.Num)\n\t\t}\n\t}\n}\n\nfunc BenchmarkQueryRowScan(b *testing.B) {\n\tdb := benchmarkDB()\n\tdefer db.Close()\n\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tvar n int64\n\t\t\t_, err := db.QueryOne(pg.Scan(&n), `SELECT ? AS num`, 1)\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t\tif n != 1 {\n\t\t\t\tb.Fatalf(\"got %d, wanted 1\", n)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkQueryRowStmtScan(b *testing.B) {\n\tdb := benchmarkDB()\n\tdefer db.Close()\n\n\tstmt, err := db.Prepare(`SELECT $1::bigint AS num`)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tdefer stmt.Close()\n\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tvar n int64\n\t\t_, err := stmt.QueryOne(pg.Scan(&n), 1)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tif n != 1 {\n\t\t\tb.Fatalf(\"got %d, wanted 1\", n)\n\t\t}\n\t}\n}\n\nfunc BenchmarkExec(b *testing.B) {\n\tdb := benchmarkDB()\n\tdefer db.Close()\n\n\tqs := []string{\n\t\t`DROP TABLE IF EXISTS exec_test`,\n\t\t`CREATE TABLE exec_test(id bigint, name varchar(500))`,\n\t}\n\tfor _, q := range qs {\n\t\t_, err := db.Exec(q)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_, err := db.Exec(`INSERT INTO exec_test (id, name) VALUES (?, ?)`, 1, \"hello world\")\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkExecWithError(b *testing.B) {\n\tdb := benchmarkDB()\n\tdefer db.Close()\n\n\tqs := []string{\n\t\t`DROP TABLE IF EXISTS exec_with_error_test`,\n\t\t`CREATE TABLE exec_with_error_test(id bigint PRIMARY KEY, name varchar(500))`,\n\t}\n\tfor _, q := range qs {\n\t\t_, err := db.Exec(q)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n\n\t_, err := db.Exec(`\n\t\tINSERT INTO exec_with_error_test(id, name) VALUES(?, ?)\n\t`, 1, \"hello world\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_, err := db.Exec(`INSERT INTO exec_with_error_test(id) VALUES(?)`, 1)\n\t\t\tif err == nil {\n\t\t\t\tb.Fatalf(\"got nil error, expected integrity violation\")\n\t\t\t} else if pgErr, ok := err.(pg.Error); !ok || !pgErr.IntegrityViolation() {\n\t\t\t\tb.Fatalf(\"got %s, expected integrity violation\", err)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkExecStmt(b *testing.B) {\n\tdb := benchmarkDB()\n\tdefer db.Close()\n\n\t_, err := db.Exec(`CREATE TEMP TABLE statement_exec(id bigint, name varchar(500))`)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tstmt, err := db.Prepare(`INSERT INTO statement_exec (id, name) VALUES ($1, $2)`)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tdefer stmt.Close()\n\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := stmt.Exec(1, \"hello world\")\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nvar letters = []rune(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\nfunc randSeq(n int) string {\n\tb := make([]rune, n)\n\tfor i := range b {\n\t\tb[i] = letters[rand.Intn(len(letters))]\n\t}\n\treturn string(b)\n}\n\ntype Record struct {\n\tNum1, Num2, Num3 int64\n\tStr1, Str2, Str3 string\n}\n\nfunc (r *Record) GetNum1() int64 {\n\treturn r.Num1\n}\n\nfunc (r *Record) GetNum2() int64 {\n\treturn r.Num2\n}\n\nfunc (r *Record) GetNum3() int64 {\n\treturn r.Num3\n}\n\nfunc (r *Record) GetStr1() string {\n\treturn r.Str1\n}\n\nfunc (r *Record) GetStr2() string {\n\treturn r.Str2\n}\n\nfunc (r *Record) GetStr3() string {\n\treturn r.Str3\n}\n\ntype OptRecord struct {\n\tNum1, Num2, Num3 int64\n\tStr1, Str2, Str3 string\n}\n\nvar _ orm.ColumnScanner = (*OptRecord)(nil)\n\nfunc (r *OptRecord) ScanColumn(col types.ColumnInfo, rd types.Reader, n int) error {\n\ttmp, err := rd.ReadFullTemp()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch col.Name {\n\tcase \"num1\":\n\t\tr.Num1, err = strconv.ParseInt(string(tmp), 10, 64)\n\tcase \"num2\":\n\t\tr.Num2, err = strconv.ParseInt(string(tmp), 10, 64)\n\tcase \"num3\":\n\t\tr.Num3, err = strconv.ParseInt(string(tmp), 10, 64)\n\tcase \"str1\":\n\t\tr.Str1 = string(tmp)\n\tcase \"str2\":\n\t\tr.Str2 = string(tmp)\n\tcase \"str3\":\n\t\tr.Str3 = string(tmp)\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown column: %q\", col.Name)\n\t}\n\treturn err\n}\n\ntype OptRecords struct {\n\tC []OptRecord\n}\n\nvar _ orm.HooklessModel = (*OptRecords)(nil)\n\nfunc (rs *OptRecords) Init() error {\n\treturn nil\n}\n\nfunc (rs *OptRecords) NextColumnScanner() orm.ColumnScanner {\n\trs.C = append(rs.C, OptRecord{})\n\treturn &rs.C[len(rs.C)-1]\n}\n\nfunc (OptRecords) AddColumnScanner(_ orm.ColumnScanner) error {\n\treturn nil\n}\n\nvar seedDBOnce sync.Once\n\nfunc seedDB() {\n\tseedDBOnce.Do(func() {\n\t\tif err := _seedDB(); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t})\n}\n\nfunc _seedDB() error {\n\tdb := benchmarkDB()\n\tdefer db.Close()\n\n\t_, err := db.Exec(`DROP TABLE IF EXISTS records`)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = db.Exec(`\n\t\tCREATE TABLE records(\n\t\t\tnum1 serial,\n\t\t\tnum2 serial,\n\t\t\tnum3 serial,\n\t\t\tstr1 text,\n\t\t\tstr2 text,\n\t\t\tstr3 text\n\t\t)\n\t`)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor i := 0; i < 1000; i++ {\n\t\t_, err = db.Exec(`\n\t\t\tINSERT INTO records (str1, str2, str3) VALUES (?, ?, ?)\n\t\t`, randSeq(100), randSeq(200), randSeq(300))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\terr = createTestSchema(db)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor i := 1; i < 100; i++ {\n\t\tgenre := &Genre{\n\t\t\tID:   i,\n\t\t\tName: fmt.Sprintf(\"genre %d\", i),\n\t\t}\n\t\t_, err = db.Model(genre).Insert()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tauthor := &Author{\n\t\t\tID:   i,\n\t\t\tName: fmt.Sprintf(\"author %d\", i),\n\t\t}\n\t\t_, err = db.Model(author).Insert()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor i := 1; i <= 1000; i++ {\n\t\tbook := &Book{\n\t\t\tID:        i,\n\t\t\tTitle:     fmt.Sprintf(\"book %d\", i),\n\t\t\tAuthorID:  rand.Intn(99) + 1,\n\t\t\tCreatedAt: time.Now(),\n\t\t}\n\t\t_, err = db.Model(book).Insert()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor j := 1; j <= 10; j++ {\n\t\t\tbookGenre := &BookGenre{\n\t\t\t\tBookID:  i,\n\t\t\t\tGenreID: j,\n\t\t\t}\n\t\t\t_, err = db.Model(bookGenre).Insert()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\ttranslation := &Translation{\n\t\t\t\tBookID: i,\n\t\t\t\tLang:   fmt.Sprintf(\"%d\", j),\n\t\t\t}\n\t\t\t_, err = db.Model(translation).Insert()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc BenchmarkForEachReal(b *testing.B) {\n\tconst N = 100000\n\n\ttype Model struct {\n\t\tId int\n\t\t_  [1000]byte\n\t}\n\n\tdb := benchmarkDB()\n\tdefer db.Close()\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tvar i int\n\t\terr := db.Model().\n\t\t\tTableExpr(\"generate_series(1, ?) as id\", N).\n\t\t\tForEach(func(m *Model) error {\n\t\t\t\ti++\n\t\t\t\treturn nil\n\t\t\t})\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tif i != N {\n\t\t\tb.Fatalf(\"got %d, wanted %d\", i, N)\n\t\t}\n\t}\n}\n\nfunc BenchmarkForEachInMemory(b *testing.B) {\n\tconst N = 100000\n\n\ttype Model struct {\n\t\tId int\n\t\t_  [1000]byte\n\t}\n\n\tdb := benchmarkDB()\n\tdefer db.Close()\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tvar model []Model\n\t\terr := db.Model().\n\t\t\tTableExpr(\"generate_series(1, ?) as id\", N).\n\t\t\tSelect(&model)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tif len(model) != N {\n\t\t\tb.Fatalf(\"got %d, wanted %d\", len(model), N)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "conv_test.go",
          "type": "blob",
          "size": 20.3837890625,
          "content": "package pg_test\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"math\"\n\t\"net\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"github.com/go-pg/pg/v10\"\n\t\"github.com/go-pg/pg/v10/orm\"\n\t\"github.com/go-pg/pg/v10/pgjson\"\n\t\"github.com/go-pg/pg/v10/types\"\n)\n\ntype JSONMap map[string]interface{}\n\nfunc (m *JSONMap) Scan(b interface{}) error {\n\tif b == nil {\n\t\t*m = nil\n\t\treturn nil\n\t}\n\treturn pgjson.Unmarshal(b.([]byte), m)\n}\n\nfunc (m JSONMap) Value() (driver.Value, error) {\n\tb, err := pgjson.Marshal(m)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn string(b), nil\n}\n\n//------------------------------------------------------------------------------\n\ntype Valuer struct {\n\tv string\n}\n\nvar _ driver.Valuer = (*Valuer)(nil)\n\nfunc (v Valuer) Value() (driver.Value, error) {\n\treturn v.v, nil\n}\n\nvar _ sql.Scanner = (*Valuer)(nil)\n\nfunc (v *Valuer) Scan(src interface{}) error {\n\tswitch src := src.(type) {\n\tcase nil:\n\t\tv.v = \"\"\n\t\treturn nil\n\tcase []byte:\n\t\tv.v = string(src)\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupported type: %T\", src)\n\t}\n}\n\ntype Struct struct {\n\tFoo string\n}\n\ntype conversionTest struct {\n\ti                int\n\tsrc, dst, wanted interface{}\n\tpgtype           string\n\n\twanterr     string\n\twantnil     bool\n\twantzero    bool\n\twantnothing bool\n}\n\nfunc unwrap(v interface{}) interface{} {\n\tif arr, ok := v.(*types.Array); ok {\n\t\treturn arr.Value()\n\t}\n\tif hstore, ok := v.(*types.Hstore); ok {\n\t\treturn hstore.Value()\n\t}\n\treturn v\n}\n\nfunc deref(vi interface{}) interface{} {\n\tv := reflect.ValueOf(vi)\n\tfor v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\tif v.IsValid() {\n\t\treturn v.Interface()\n\t}\n\treturn nil\n}\n\nfunc zero(v interface{}) interface{} {\n\treturn reflect.Zero(reflect.ValueOf(v).Elem().Type()).Interface()\n}\n\nfunc (test *conversionTest) String() string {\n\treturn fmt.Sprintf(\"#%d src=%#v dst=%#v\", test.i, test.src, test.dst)\n}\n\nfunc (test *conversionTest) Assert(t *testing.T, err error) {\n\tif test.wanterr != \"\" {\n\t\tif err == nil || err.Error() != test.wanterr {\n\t\t\tt.Fatalf(\"got error %v, wanted %q (%s)\", err, test.wanterr, test)\n\t\t}\n\t\treturn\n\t}\n\n\tif err != nil {\n\t\tt.Fatalf(\"got error %q, wanted nil (%s)\", err, test)\n\t}\n\n\tif test.wantnothing {\n\t\treturn\n\t}\n\n\tdst := reflect.Indirect(reflect.ValueOf(unwrap(test.dst))).Interface()\n\n\tif test.wantnil {\n\t\tdstValue := reflect.ValueOf(dst)\n\t\tif !dstValue.IsValid() {\n\t\t\treturn\n\t\t}\n\t\tif dstValue.IsNil() {\n\t\t\treturn\n\t\t}\n\t\tt.Fatalf(\"got %#v, wanted nil (%s)\", dst, test)\n\t\treturn\n\t}\n\n\t// Remove any intermediate pointers to compare values.\n\tdst = deref(unwrap(dst))\n\tsrc := deref(unwrap(test.src))\n\n\tif test.wantzero {\n\t\tdstValue := reflect.ValueOf(dst)\n\t\tswitch dstValue.Kind() {\n\t\tcase reflect.Slice, reflect.Map:\n\t\t\tif dstValue.IsNil() {\n\t\t\t\tt.Fatalf(\"got nil, wanted zero value\")\n\t\t\t}\n\t\t\tif dstValue.Len() != 0 {\n\t\t\t\tt.Fatalf(\"got %d items, wanted 0\", dstValue.Len())\n\t\t\t}\n\t\tdefault:\n\t\t\tzero := zero(test.dst)\n\t\t\tif dst != zero {\n\t\t\t\tt.Fatalf(\"%#v != %#v (%s)\", dst, zero, test)\n\t\t\t}\n\t\t}\n\t\treturn\n\t}\n\n\tif dstTime, ok := dst.(time.Time); ok {\n\t\tsrcTime := src.(time.Time)\n\t\tif dstTime.Unix() != srcTime.Unix() {\n\t\t\tt.Fatalf(\"%#v != %#v\", dstTime, srcTime)\n\t\t}\n\t\treturn\n\t}\n\n\tif dstTimes, ok := dst.([]time.Time); ok {\n\t\tsrcTimes := src.([]time.Time)\n\t\tfor i, dstTime := range dstTimes {\n\t\t\tsrcTime := srcTimes[i]\n\t\t\tif dstTime.Unix() != srcTime.Unix() {\n\t\t\t\tt.Fatalf(\"%#v != %#v\", dstTime, srcTime)\n\t\t\t}\n\t\t}\n\t\treturn\n\t}\n\n\twanted := test.wanted\n\tif wanted == nil {\n\t\twanted = src\n\t}\n\tif !reflect.DeepEqual(dst, wanted) {\n\t\tt.Fatalf(\"%#v != %#v (%s)\", dst, wanted, test)\n\t}\n}\n\nfunc conversionTests() []conversionTest {\n\treturn []conversionTest{\n\t\t{src: nil, dst: nil, wanterr: \"pg: Scan(nil)\"},\n\t\t{src: nil, dst: new(uintptr), wanterr: \"pg: Scan(unsupported uintptr)\"},\n\n\t\t{src: nil, dst: true, pgtype: \"bool\", wanterr: \"pg: Scan(non-pointer bool)\"},\n\t\t{src: nil, dst: new(*bool), pgtype: \"bool\", wantnil: true},\n\t\t{src: nil, dst: new(bool), pgtype: \"bool\", wantzero: true},\n\t\t{src: true, dst: new(bool), pgtype: \"bool\"},\n\t\t{src: true, dst: new(*bool), pgtype: \"bool\"},\n\t\t{src: 1, dst: new(bool), wanted: true},\n\n\t\t{src: nil, dst: \"\", pgtype: \"text\", wanterr: \"pg: Scan(non-pointer string)\"},\n\t\t{src: nil, dst: new(string), pgtype: \"text\", wantzero: true},\n\t\t{src: nil, dst: new(*string), pgtype: \"text\", wantnil: true},\n\t\t{src: \"hello world\", dst: new(string), pgtype: \"text\"},\n\t\t{src: \"hello world\", dst: new(*string), pgtype: \"text\"},\n\t\t{src: \"'\\\"\\000\\xa7\", dst: new(string), wanted: `'\"`, pgtype: \"text\"},\n\n\t\t{src: nil, dst: []byte(nil), pgtype: \"bytea\", wanterr: \"pg: Scan(non-pointer []uint8)\"},\n\t\t{src: nil, dst: new([]byte), pgtype: \"bytea\", wantnil: true},\n\t\t{src: []byte(\"hello world\\000\"), dst: new([]byte), pgtype: \"bytea\"},\n\t\t{src: []byte{}, dst: new([]byte), pgtype: \"bytea\", wantzero: true},\n\t\t{src: [3]byte{}, dst: new([3]byte), pgtype: \"bytea\"},\n\n\t\t{src: nil, dst: int8(0), pgtype: \"smallint\", wanterr: \"pg: Scan(non-pointer int8)\"},\n\t\t{src: nil, dst: new(int8), pgtype: \"smallint\", wantzero: true},\n\t\t{src: int8(math.MaxInt8), dst: new(int8), pgtype: \"smallint\"},\n\t\t{src: int8(math.MaxInt8), dst: new(*int8), pgtype: \"smallint\"},\n\t\t{src: int8(math.MinInt8), dst: new(int8), pgtype: \"smallint\"},\n\n\t\t{src: nil, dst: int16(0), pgtype: \"smallint\", wanterr: \"pg: Scan(non-pointer int16)\"},\n\t\t{src: nil, dst: new(int16), pgtype: \"smallint\", wantzero: true},\n\t\t{src: int16(math.MaxInt16), dst: new(int16), pgtype: \"smallint\"},\n\t\t{src: int16(math.MaxInt16), dst: new(*int16), pgtype: \"smallint\"},\n\t\t{src: int16(math.MinInt16), dst: new(int16), pgtype: \"smallint\"},\n\n\t\t{src: nil, dst: int32(0), pgtype: \"int\", wanterr: \"pg: Scan(non-pointer int32)\"},\n\t\t{src: nil, dst: new(int32), pgtype: \"int\", wantzero: true},\n\t\t{src: int32(math.MaxInt32), dst: new(int32), pgtype: \"int\"},\n\t\t{src: int32(math.MaxInt32), dst: new(*int32), pgtype: \"int\"},\n\t\t{src: int32(math.MinInt32), dst: new(int32), pgtype: \"int\"},\n\n\t\t{src: nil, dst: int64(0), pgtype: \"bigint\", wanterr: \"pg: Scan(non-pointer int64)\"},\n\t\t{src: nil, dst: new(int64), pgtype: \"bigint\", wantzero: true},\n\t\t{src: int64(math.MaxInt64), dst: new(int64), pgtype: \"bigint\"},\n\t\t{src: int64(math.MaxInt64), dst: new(*int64), pgtype: \"bigint\"},\n\t\t{src: int64(math.MinInt64), dst: new(int64), pgtype: \"bigint\"},\n\n\t\t{src: nil, dst: 0, pgtype: \"bigint\", wanterr: \"pg: Scan(non-pointer int)\"},\n\t\t{src: nil, dst: new(int), pgtype: \"bigint\", wantzero: true},\n\t\t{src: int64(math.MaxInt64), dst: new(int64), pgtype: \"bigint\"},\n\t\t{src: int64(math.MaxInt64), dst: new(*int64), pgtype: \"bigint\"},\n\t\t{src: int64(math.MinInt32), dst: new(int64), pgtype: \"bigint\"},\n\n\t\t{src: nil, dst: uint8(0), pgtype: \"smallint\", wanterr: \"pg: Scan(non-pointer uint8)\"},\n\t\t{src: nil, dst: new(uint8), pgtype: \"smallint\", wantzero: true},\n\t\t{src: uint8(math.MaxUint8), dst: new(uint8), pgtype: \"smallint\"},\n\t\t{src: uint8(math.MaxUint8), dst: new(*uint8), pgtype: \"smallint\"},\n\n\t\t{src: nil, dst: uint16(0), pgtype: \"smallint\", wanterr: \"pg: Scan(non-pointer uint16)\"},\n\t\t{src: nil, dst: new(uint16), pgtype: \"smallint\", wantzero: true},\n\t\t{src: uint16(math.MaxUint16), dst: new(uint16), pgtype: \"int\"},\n\t\t{src: uint16(math.MaxUint16), dst: new(*uint16), pgtype: \"int\"},\n\n\t\t{src: nil, dst: uint32(0), pgtype: \"bigint\", wanterr: \"pg: Scan(non-pointer uint32)\"},\n\t\t{src: nil, dst: new(uint32), pgtype: \"bigint\", wantzero: true},\n\t\t{src: uint32(math.MaxUint32), dst: new(uint32), pgtype: \"bigint\"},\n\t\t{src: uint32(math.MaxUint32), dst: new(*uint32), pgtype: \"bigint\"},\n\n\t\t{src: nil, dst: uint64(0), pgtype: \"bigint\", wanterr: \"pg: Scan(non-pointer uint64)\"},\n\t\t{src: nil, dst: new(uint64), pgtype: \"bigint\", wantzero: true},\n\t\t{src: uint64(math.MaxUint64), dst: new(uint64)},\n\t\t{src: uint64(math.MaxUint64), dst: new(*uint64)},\n\t\t{src: uint64(math.MaxUint32), dst: new(uint64), pgtype: \"bigint\"},\n\n\t\t{src: nil, dst: uint(0), pgtype: \"smallint\", wanterr: \"pg: Scan(non-pointer uint)\"},\n\t\t{src: nil, dst: new(uint), pgtype: \"bigint\", wantzero: true},\n\t\t{src: uint64(math.MaxUint64), dst: new(uint64)},\n\t\t{src: uint64(math.MaxUint64), dst: new(*uint64)},\n\t\t{src: uint64(math.MaxUint32), dst: new(uint64), pgtype: \"bigint\"},\n\n\t\t{src: nil, dst: float32(0), pgtype: \"decimal\", wanterr: \"pg: Scan(non-pointer float32)\"},\n\t\t{src: nil, dst: new(float32), pgtype: \"decimal\", wantzero: true},\n\t\t{src: float32(math.MaxFloat32), dst: new(float32), pgtype: \"decimal\"},\n\t\t{src: float32(math.MaxFloat32), dst: new(*float32), pgtype: \"decimal\"},\n\t\t{src: float32(math.SmallestNonzeroFloat32), dst: new(float32), pgtype: \"decimal\"},\n\n\t\t{src: nil, dst: float64(0), pgtype: \"decimal\", wanterr: \"pg: Scan(non-pointer float64)\"},\n\t\t{src: nil, dst: new(float64), pgtype: \"decimal\", wantzero: true},\n\t\t{src: float64(math.MaxFloat64), dst: new(float64), pgtype: \"decimal\"},\n\t\t{src: float64(math.MaxFloat64), dst: new(*float64), pgtype: \"decimal\"},\n\t\t{src: float64(math.SmallestNonzeroFloat64), dst: new(float64), pgtype: \"decimal\"},\n\n\t\t{src: nil, dst: []int(nil), pgtype: \"jsonb\", wanterr: \"pg: Scan(non-pointer []int)\"},\n\t\t{src: nil, dst: new([]int), pgtype: \"jsonb\", wantnil: true},\n\t\t{src: []int(nil), dst: new([]int), pgtype: \"jsonb\", wantnil: true},\n\t\t{src: []int{}, dst: new([]int), pgtype: \"jsonb\", wantzero: true},\n\t\t{src: []int{1, 2, 3}, dst: new([]int), pgtype: \"jsonb\"},\n\t\t{src: [3]int{1, 2, 3}, dst: new([3]int), pgtype: \"jsonb\"},\n\n\t\t{src: nil, dst: pg.Array([]int(nil)), pgtype: \"int[]\", wanterr: \"pg: Array(non-pointer []int)\"},\n\t\t{src: pg.Array([]int(nil)), dst: pg.Array(new([]int)), pgtype: \"int[]\", wantnil: true},\n\t\t{src: pg.Array([]int{}), dst: pg.Array(new([]int)), pgtype: \"int[]\"},\n\t\t{src: pg.Array([]int{1, 2, 3}), dst: pg.Array(new([]int)), pgtype: \"int[]\"},\n\t\t{src: pg.Array(&[3]int{1, 2, 3}), dst: pg.Array(new([3]int)), pgtype: \"int[]\"},\n\n\t\t{src: nil, dst: pg.Array([]int64(nil)), pgtype: \"bigint[]\", wanterr: \"pg: Array(non-pointer []int64)\"},\n\t\t{src: nil, dst: pg.Array(new([]int64)), pgtype: \"bigint[]\", wantnil: true},\n\t\t{src: pg.Array([]int64(nil)), dst: pg.Array(new([]int64)), pgtype: \"bigint[]\", wantnil: true},\n\t\t{src: pg.Array([]int64{}), dst: pg.Array(new([]int64)), pgtype: \"bigint[]\"},\n\t\t{src: pg.Array([]int64{1, 2, 3}), dst: pg.Array(new([]int64)), pgtype: \"bigint[]\"},\n\n\t\t{src: nil, dst: pg.Array([]float64(nil)), pgtype: \"decimal[]\", wanterr: \"pg: Array(non-pointer []float64)\"},\n\t\t{src: nil, dst: pg.Array(new([]float64)), pgtype: \"decimal[]\", wantnil: true},\n\t\t{src: pg.Array([]float64(nil)), dst: pg.Array(new([]float64)), pgtype: \"decimal[]\", wantnil: true},\n\t\t{src: pg.Array([]float64{}), dst: pg.Array(new([]float64)), pgtype: \"decimal[]\"},\n\t\t{src: pg.Array([]float64{1.1, 2.22, 3.333}), dst: pg.Array(new([]float64)), pgtype: \"decimal[]\"},\n\t\t{src: pg.Array([]float64{math.NaN(), math.Inf(+1), math.Inf(-1)}), dst: pg.Array(new([]float64)), pgtype: \"float[]\", wantnothing: true},\n\n\t\t{src: nil, dst: pg.Array([]string(nil)), pgtype: \"text[]\", wanterr: \"pg: Array(non-pointer []string)\"},\n\t\t{src: nil, dst: pg.Array(new([]string)), pgtype: \"text[]\", wantnil: true},\n\t\t{src: pg.Array([]string(nil)), dst: pg.Array(new([]string)), pgtype: \"text[]\", wantnil: true},\n\t\t{src: pg.Array([]string{}), dst: pg.Array(new([]string)), pgtype: \"text[]\"},\n\t\t{src: pg.Array([]string{\"one\", \"two\", \"three\"}), dst: pg.Array(new([]string)), pgtype: \"text[]\"},\n\t\t{src: pg.Array([]string{`''\"{}`}), dst: pg.Array(new([]string)), pgtype: \"text[]\"},\n\n\t\t{src: nil, dst: pg.Array([][]string(nil)), pgtype: \"text[][]\", wanterr: \"pg: Array(non-pointer [][]string)\"},\n\t\t{src: nil, dst: pg.Array(new([][]string)), pgtype: \"text[][]\", wantnil: true},\n\t\t{src: pg.Array([][]string(nil)), dst: pg.Array(new([]string)), pgtype: \"text[][]\", wantnil: true},\n\t\t{src: pg.Array([][]string{}), dst: pg.Array(new([][]string)), pgtype: \"text[][]\"},\n\t\t{src: pg.Array([][]string{{\"one\", \"two\"}, {\"three\", \"four\"}}), dst: pg.Array(new([][]string)), pgtype: \"text[][]\"},\n\t\t{src: pg.Array([][]string{{`'\"\\{}`}}), dst: pg.Array(new([][]string)), pgtype: \"text[][]\"},\n\n\t\t{src: pg.Array([][]byte{[]byte(`'\"\\{}`)}), dst: pg.Array(new([][]byte)), pgtype: \"bytea[]\"},\n\n\t\t{src: nil, dst: pg.Hstore(map[string]string(nil)), pgtype: \"hstore\", wanterr: \"pg: Hstore(non-pointer map[string]string)\"},\n\t\t{src: nil, dst: pg.Hstore(new(map[string]string)), pgtype: \"hstore\", wantnil: true},\n\t\t{src: pg.Hstore(map[string]string(nil)), dst: pg.Hstore(new(map[string]string)), pgtype: \"hstore\", wantnil: true},\n\t\t{src: pg.Hstore(map[string]string{}), dst: pg.Hstore(new(map[string]string)), pgtype: \"hstore\"},\n\t\t{src: pg.Hstore(map[string]string{\"foo\": \"bar\"}), dst: pg.Hstore(new(map[string]string)), pgtype: \"hstore\"},\n\t\t{src: pg.Hstore(map[string]string{`'\"\\{}=>`: `'\"\\{}=>`}), dst: pg.Hstore(new(map[string]string)), pgtype: \"hstore\"},\n\n\t\t{src: nil, dst: sql.NullBool{}, pgtype: \"bool\", wanterr: \"pg: Scan(non-pointer sql.NullBool)\"},\n\t\t{src: nil, dst: new(*sql.NullBool), pgtype: \"bool\", wantnil: true},\n\t\t{src: nil, dst: new(sql.NullBool), pgtype: \"bool\", wanted: sql.NullBool{}},\n\t\t{src: &sql.NullBool{}, dst: new(sql.NullBool), pgtype: \"bool\"},\n\t\t{src: &sql.NullBool{Valid: true}, dst: new(sql.NullBool), pgtype: \"bool\"},\n\t\t{src: &sql.NullBool{Valid: true, Bool: true}, dst: new(sql.NullBool), pgtype: \"bool\"},\n\n\t\t{src: &sql.NullString{}, dst: new(sql.NullString), pgtype: \"text\"},\n\t\t{src: &sql.NullString{Valid: true}, dst: new(sql.NullString), pgtype: \"text\"},\n\t\t{src: &sql.NullString{Valid: true, String: \"foo\"}, dst: new(sql.NullString), pgtype: \"text\"},\n\n\t\t{src: &sql.NullInt64{}, dst: new(sql.NullInt64), pgtype: \"bigint\"},\n\t\t{src: &sql.NullInt64{Valid: true}, dst: new(sql.NullInt64), pgtype: \"bigint\"},\n\t\t{src: &sql.NullInt64{Valid: true, Int64: math.MaxInt64}, dst: new(sql.NullInt64), pgtype: \"bigint\"},\n\n\t\t{src: &sql.NullFloat64{}, dst: new(sql.NullFloat64), pgtype: \"decimal\"},\n\t\t{src: &sql.NullFloat64{Valid: true}, dst: new(sql.NullFloat64), pgtype: \"decimal\"},\n\t\t{src: &sql.NullFloat64{Valid: true, Float64: math.MaxFloat64}, dst: new(sql.NullFloat64), pgtype: \"decimal\"},\n\n\t\t{src: nil, dst: customStrSlice{}, wanterr: \"pg: Scan(non-pointer pg_test.customStrSlice)\"},\n\t\t{src: nil, dst: new(customStrSlice), wantnil: true},\n\t\t{src: nil, dst: new(*customStrSlice), wantnil: true},\n\t\t{src: customStrSlice{}, dst: new(customStrSlice), wantzero: true},\n\t\t{src: customStrSlice{\"one\", \"two\"}, dst: new(customStrSlice)},\n\n\t\t{src: nil, dst: time.Time{}, wanterr: \"pg: Scan(non-pointer time.Time)\"},\n\t\t{src: nil, dst: new(time.Time), pgtype: \"timestamptz\", wantzero: true},\n\t\t{src: nil, dst: new(*time.Time), pgtype: \"timestamptz\", wantnil: true},\n\t\t{src: time.Now(), dst: new(time.Time), pgtype: \"timestamptz\"},\n\t\t{src: time.Now(), dst: new(*time.Time), pgtype: \"timestamptz\"},\n\t\t{src: time.Now().UTC(), dst: new(time.Time), pgtype: \"timestamptz\"},\n\t\t{src: time.Time{}, dst: new(time.Time), pgtype: \"timestamptz\"},\n\n\t\t{src: nil, dst: pg.Array([]time.Time(nil)), pgtype: \"timestamptz[]\", wanterr: \"pg: Array(non-pointer []time.Time)\"},\n\t\t{src: nil, dst: pg.Array(new([]time.Time)), pgtype: \"timestamptz[]\", wantnil: true},\n\t\t{src: pg.Array([]time.Time(nil)), dst: pg.Array(new([]time.Time)), pgtype: \"timestamptz[]\", wantnil: true},\n\t\t{src: pg.Array([]time.Time{}), dst: pg.Array(new([]time.Time)), pgtype: \"timestamptz[]\"},\n\t\t{src: pg.Array([]time.Time{time.Now(), time.Now(), time.Now()}), dst: pg.Array(new([]time.Time)), pgtype: \"timestamptz[]\"},\n\n\t\t{src: nil, dst: pg.Ints{}, wanterr: \"pg: Scan(non-pointer pg.Ints)\"},\n\t\t{src: 1, dst: new(pg.Ints), wanted: pg.Ints{1}},\n\n\t\t{src: nil, dst: pg.Strings{}, wanterr: \"pg: Scan(non-pointer pg.Strings)\"},\n\t\t{src: \"hello\", dst: new(pg.Strings), wanted: pg.Strings{\"hello\"}},\n\n\t\t{src: nil, dst: pg.IntSet{}, wanterr: \"pg: Scan(non-pointer pg.IntSet)\"},\n\t\t{src: 1, dst: new(pg.IntSet), wanted: pg.IntSet{1: struct{}{}}},\n\n\t\t{src: nil, dst: JSONMap{}, pgtype: \"json\", wanterr: \"pg: Scan(non-pointer pg_test.JSONMap)\"},\n\t\t{src: nil, dst: new(JSONMap), pgtype: \"json\", wantnil: true},\n\t\t{src: nil, dst: new(*JSONMap), pgtype: \"json\", wantnil: true},\n\t\t{src: JSONMap{}, dst: new(JSONMap), pgtype: \"json\"},\n\t\t{src: JSONMap{}, dst: new(*JSONMap), pgtype: \"json\"},\n\t\t{src: JSONMap{\"foo\": \"bar\"}, dst: new(JSONMap), pgtype: \"json\"},\n\t\t{src: `{\"foo\": \"bar\"}`, dst: new(JSONMap), pgtype: \"json\", wanted: JSONMap{\"foo\": \"bar\"}},\n\n\t\t{src: nil, dst: Struct{}, pgtype: \"json\", wanterr: \"pg: Scan(non-pointer pg_test.Struct)\"},\n\t\t{src: nil, dst: new(*Struct), pgtype: \"json\", wantnil: true},\n\t\t{src: nil, dst: new(Struct), pgtype: \"json\", wantzero: true},\n\t\t{src: Struct{}, dst: new(Struct), pgtype: \"json\"},\n\t\t{src: Struct{Foo: \"bar\"}, dst: new(Struct), pgtype: \"json\"},\n\t\t{src: `{\"foo\": \"bar\"}`, dst: new(Struct), wanted: Struct{Foo: \"bar\"}},\n\n\t\t{src: nil, dst: new(net.IP), wanted: net.IP(nil), pgtype: \"inet\"},\n\t\t{src: net.ParseIP(\"127.0.0.1\"), dst: new(net.IP), pgtype: \"inet\"},\n\t\t{src: net.ParseIP(\"::10.2.3.4\"), dst: new(net.IP), pgtype: \"inet\"},\n\t\t{src: net.ParseIP(\"::ffff:10.4.3.2\"), dst: new(net.IP), pgtype: \"inet\"},\n\n\t\t{src: nil, dst: (*net.IPNet)(nil), pgtype: \"cidr\", wanterr: \"pg: Scan(non-settable *net.IPNet)\"},\n\t\t{src: nil, dst: new(net.IPNet), wanted: net.IPNet{}, pgtype: \"cidr\"},\n\t\t{src: nil, dst: mustParseCIDR(\"192.168.100.128/25\"), wanted: net.IPNet{}, pgtype: \"cidr\"},\n\t\t{src: mustParseCIDR(\"192.168.100.128/25\"), dst: new(net.IPNet), pgtype: \"cidr\"},\n\t\t{src: mustParseCIDR(\"2001:4f8:3:ba::/64\"), dst: new(net.IPNet), pgtype: \"cidr\"},\n\t\t{src: mustParseCIDR(\"2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128\"), dst: new(net.IPNet), pgtype: \"cidr\"},\n\n\t\t{src: nil, dst: new(Valuer), wanted: Valuer{}},\n\t\t{src: (*Valuer)(nil), dst: new(Valuer), wanted: Valuer{}},\n\t\t{src: new(Valuer), dst: new(Valuer), wanted: Valuer{}},\n\t\t{src: Valuer{v: \"hello\"}, dst: new(Valuer)},\n\t}\n}\n\nfunc TestConversion(t *testing.T) {\n\tdb := pg.Connect(pgOptions())\n\tdefer db.Close()\n\n\tfor i, test := range conversionTests() {\n\t\ttest.i = i\n\n\t\tvar scanner orm.ColumnScanner\n\t\tif v, ok := test.dst.(orm.ColumnScanner); ok {\n\t\t\tscanner = v\n\t\t} else {\n\t\t\tscanner = pg.Scan(test.dst)\n\t\t}\n\n\t\t_, err := db.QueryOne(scanner, \"SELECT (?) AS dst\", test.src)\n\t\ttest.Assert(t, err)\n\t}\n\n\tfor i, test := range conversionTests() {\n\t\ttest.i = i\n\n\t\tvar scanner orm.ColumnScanner\n\t\tif v, ok := test.dst.(orm.ColumnScanner); ok {\n\t\t\tscanner = v\n\t\t} else {\n\t\t\tscanner = pg.Scan(test.dst)\n\t\t}\n\n\t\terr := db.Model().ColumnExpr(\"(?) AS dst\", test.src).Select(scanner)\n\t\ttest.Assert(t, err)\n\t}\n\n\tfor i, test := range conversionTests() {\n\t\ttest.i = i\n\n\t\tif test.pgtype == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tstmt, err := db.Prepare(fmt.Sprintf(\"SELECT ($1::%s) AS dst\", test.pgtype))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tvar scanner orm.ColumnScanner\n\t\tif v, ok := test.dst.(orm.ColumnScanner); ok {\n\t\t\tscanner = v\n\t\t} else {\n\t\t\tscanner = pg.Scan(test.dst)\n\t\t}\n\n\t\t_, err = stmt.QueryOne(scanner, test.src)\n\t\ttest.Assert(t, err)\n\n\t\tif err := stmt.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc mustParseCIDR(s string) *net.IPNet {\n\t_, ipnet, err := net.ParseCIDR(s)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn ipnet\n}\n\nfunc TestReadColumnValue(t *testing.T) {\n\tdb := pg.Connect(pgOptions())\n\tdefer db.Close()\n\n\ttype Test struct {\n\t\tpgtype  string\n\t\tvalue   interface{}\n\t\tisArray bool\n\t}\n\n\ttests := []Test{\n\t\t{pgtype: \"boolean\", value: true},\n\n\t\t{pgtype: \"int2\", value: int16(math.MaxInt16)},\n\t\t{pgtype: \"int4\", value: int32(math.MaxInt32)},\n\t\t{pgtype: \"int8\", value: int64(math.MaxInt64)},\n\n\t\t{pgtype: \"float4\", value: float32(1.2345)},\n\t\t{pgtype: \"float8\", value: float64(1.2345)},\n\n\t\t{pgtype: \"decimal\", value: types.RawValue{\n\t\t\tType:  1700,\n\t\t\tValue: \"111111111111111111111111111111111111111111111\",\n\t\t}},\n\t\t{pgtype: \"numeric\", value: types.RawValue{\n\t\t\tType:  1700,\n\t\t\tValue: \"222222222222222222222222222222222222222222222\",\n\t\t}},\n\n\t\t{pgtype: \"text\", value: \"hello\"},\n\t\t{pgtype: \"varchar(1000)\", value: \"hello\"},\n\t\t{pgtype: \"bytea\", value: []byte(\"hello\")},\n\t\t{pgtype: \"json\", value: json.RawMessage(\"[]\")},\n\t\t{pgtype: \"jsonb\", value: json.RawMessage(\"[]\")},\n\n\t\t{pgtype: \"int8[]\", value: []int64{1, 2, 3}, isArray: true},\n\t\t{pgtype: \"float8[]\", value: []float64{1.23, 4.567}, isArray: true},\n\t\t{pgtype: \"text[]\", value: []string{\"foo\", \"bar\"}, isArray: true},\n\n\t\t{pgtype: \"timestamptz\", value: time.Unix(0, 0)},\n\t\t{pgtype: \"timestamp\", value: time.Unix(0, 0).UTC()},\n\n\t\t{pgtype: \"uuid\", value: \"a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tvalue := test.value\n\t\tif test.isArray {\n\t\t\tvalue = pg.Array(value)\n\t\t}\n\n\t\tvar m map[string]interface{}\n\t\terr := db.Model().ColumnExpr(\"?::? AS col\", value, pg.Safe(test.pgtype)).Select(&m)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, m[\"col\"], test.value)\n\t}\n\n\tvar mm []map[string]interface{}\n\terr := db.Model().ColumnExpr(\"1\").Union(\n\t\tdb.Model().ColumnExpr(\"2\"),\n\t).Select(&mm)\n\tassert.Nil(t, err)\n\tassert.Equal(t, []map[string]interface{}{\n\t\t{\"?column?\": int32(1)},\n\t\t{\"?column?\": int32(2)},\n\t}, mm)\n}\n"
        },
        {
          "name": "db.go",
          "type": "blob",
          "size": 3.501953125,
          "content": "package pg\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-pg/pg/v10/internal/pool\"\n\t\"github.com/go-pg/pg/v10/orm\"\n)\n\n// Connect connects to a database using provided options.\n//\n// The returned DB is safe for concurrent use by multiple goroutines\n// and maintains its own connection pool.\nfunc Connect(opt *Options) *DB {\n\topt.init()\n\treturn newDB(\n\t\tcontext.Background(),\n\t\t&baseDB{\n\t\t\topt:   opt,\n\t\t\tpool:  newConnPool(opt),\n\t\t\tfmter: orm.NewFormatter(),\n\t\t},\n\t)\n}\n\nfunc newDB(ctx context.Context, baseDB *baseDB) *DB {\n\tdb := &DB{\n\t\tbaseDB: baseDB.clone(),\n\t\tctx:    ctx,\n\t}\n\tdb.baseDB.db = db\n\treturn db\n}\n\n// DB is a database handle representing a pool of zero or more\n// underlying connections. It's safe for concurrent use by multiple\n// goroutines.\ntype DB struct {\n\t*baseDB\n\tctx context.Context\n}\n\nvar _ orm.DB = (*DB)(nil)\n\nfunc (db *DB) String() string {\n\treturn fmt.Sprintf(\"DB<Addr=%q%s>\", db.opt.Addr, db.fmter)\n}\n\n// Options returns read-only Options that were used to connect to the DB.\nfunc (db *DB) Options() *Options {\n\treturn db.opt\n}\n\n// Context returns DB context.\nfunc (db *DB) Context() context.Context {\n\treturn db.ctx\n}\n\n// WithContext returns a copy of the DB that uses the ctx.\nfunc (db *DB) WithContext(ctx context.Context) *DB {\n\treturn newDB(ctx, db.baseDB)\n}\n\n// WithTimeout returns a copy of the DB that uses d as the read/write timeout.\nfunc (db *DB) WithTimeout(d time.Duration) *DB {\n\treturn newDB(db.ctx, db.baseDB.WithTimeout(d))\n}\n\n// WithParam returns a copy of the DB that replaces the param with the value\n// in queries.\nfunc (db *DB) WithParam(param string, value interface{}) *DB {\n\treturn newDB(db.ctx, db.baseDB.WithParam(param, value))\n}\n\n// Listen listens for notifications sent with NOTIFY command.\nfunc (db *DB) Listen(ctx context.Context, channels ...string) *Listener {\n\tln := &Listener{\n\t\tdb: db,\n\t}\n\tln.init()\n\t_ = ln.Listen(ctx, channels...)\n\treturn ln\n}\n\n// Conn represents a single database connection rather than a pool of database\n// connections. Prefer running queries from DB unless there is a specific\n// need for a continuous single database connection.\n//\n// A Conn must call Close to return the connection to the database pool\n// and may do so concurrently with a running query.\n//\n// After a call to Close, all operations on the connection fail.\ntype Conn struct {\n\t*baseDB\n\tctx context.Context\n}\n\nvar _ orm.DB = (*Conn)(nil)\n\n// Conn returns a single connection from the connection pool.\n// Queries run on the same Conn will be run in the same database session.\n//\n// Every Conn must be returned to the database pool after use by\n// calling Conn.Close.\nfunc (db *DB) Conn() *Conn {\n\treturn newConn(db.ctx, db.baseDB.withPool(pool.NewStickyConnPool(db.pool)))\n}\n\nfunc newConn(ctx context.Context, baseDB *baseDB) *Conn {\n\tconn := &Conn{\n\t\tbaseDB: baseDB,\n\t\tctx:    ctx,\n\t}\n\tconn.baseDB.db = conn\n\treturn conn\n}\n\n// Context returns DB context.\nfunc (db *Conn) Context() context.Context {\n\tif db.ctx != nil {\n\t\treturn db.ctx\n\t}\n\treturn context.Background()\n}\n\n// WithContext returns a copy of the DB that uses the ctx.\nfunc (db *Conn) WithContext(ctx context.Context) *Conn {\n\treturn newConn(ctx, db.baseDB)\n}\n\n// WithTimeout returns a copy of the DB that uses d as the read/write timeout.\nfunc (db *Conn) WithTimeout(d time.Duration) *Conn {\n\treturn newConn(db.ctx, db.baseDB.WithTimeout(d))\n}\n\n// WithParam returns a copy of the DB that replaces the param with the value\n// in queries.\nfunc (db *Conn) WithParam(param string, value interface{}) *Conn {\n\treturn newConn(db.ctx, db.baseDB.WithParam(param, value))\n}\n"
        },
        {
          "name": "db_test.go",
          "type": "blob",
          "size": 60.927734375,
          "content": "package pg_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-pg/pg/v10\"\n\t\"github.com/go-pg/pg/v10/orm\"\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc init() {\n\torm.RegisterTable((*BookGenre)(nil))\n\torm.RegisterTable((*IngredientRecipe)(nil))\n}\n\nfunc TestGinkgo(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"pg\")\n}\n\nfunc pgOptions() *pg.Options {\n\treturn &pg.Options{\n\t\tTLSConfig: getTLSConfig(),\n\n\t\tMaxRetries:      1,\n\t\tMinRetryBackoff: -1,\n\n\t\tDialTimeout:  30 * time.Second,\n\t\tReadTimeout:  10 * time.Second,\n\t\tWriteTimeout: 10 * time.Second,\n\n\t\tPoolSize:           10,\n\t\tMaxConnAge:         10 * time.Second,\n\t\tPoolTimeout:        30 * time.Second,\n\t\tIdleTimeout:        10 * time.Second,\n\t\tIdleCheckFrequency: 100 * time.Millisecond,\n\t}\n}\n\nfunc getTLSConfig() *tls.Config {\n\tpgSSLMode := os.Getenv(\"PGSSLMODE\")\n\tif pgSSLMode == \"disable\" {\n\t\treturn nil\n\t}\n\treturn &tls.Config{\n\t\tInsecureSkipVerify: true,\n\t}\n}\n\nvar _testDB *pg.DB\n\nfunc testDB() *pg.DB {\n\tif _testDB == nil {\n\t\t_testDB = pg.Connect(pgOptions())\n\t}\n\treturn _testDB\n}\n\nfunc TestDBString(t *testing.T) {\n\tdb := pg.Connect(pgOptions())\n\tdefer db.Close()\n\n\tenv := func(key, defValue string) string {\n\t\tenvValue := os.Getenv(key)\n\t\tif envValue != \"\" {\n\t\t\treturn envValue\n\t\t}\n\t\treturn defValue\n\t}\n\thost := env(\"PGHOST\", \"localhost\")\n\tport := env(\"PGPORT\", \"5432\")\n\n\twanted := fmt.Sprintf(`DB<Addr=\"%s:%s\">`, host, port)\n\tif db.String() != wanted {\n\t\tt.Fatalf(\"got %q, wanted %q\", db.String(), wanted)\n\t}\n\n\tdb = db.WithParam(\"param1\", \"value1\").WithParam(\"param2\", 2)\n\twanted = fmt.Sprintf(`DB<Addr=\"%s:%s\" param1=value1 param2=2>`, host, port)\n\tif db.String() != wanted {\n\t\tt.Fatalf(\"got %q, wanted %q\", db.String(), wanted)\n\t}\n}\n\nfunc TestDBConnectWithStartupNotice(t *testing.T) {\n\toptions := pgOptions()\n\t// Set our application name to be too long.\n\toptions.ApplicationName = \"i am just a really really super long application name so that i make a notice during startup\"\n\tdb := pg.Connect(options)\n\tdefer db.Close()\n\n\t// Upon hitting PostgreSQL we would normally receive an error if we don't handle the notice response, this will\n\t// now succeed.\n\trequire.NoError(t, db.Ping(context.Background()), \"must successfully ping database with long application name\")\n}\n\nfunc TestOnConnect(t *testing.T) {\n\topt := pgOptions()\n\topt.OnConnect = func(ctx context.Context, db *pg.Conn) error {\n\t\t_, err := db.Exec(\"SET application_name = 'myapp'\")\n\t\treturn err\n\t}\n\n\tdb := pg.Connect(opt)\n\tdefer db.Close()\n\n\tvar name string\n\t_, err := db.QueryOne(pg.Scan(&name), \"SHOW application_name\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif name != \"myapp\" {\n\t\tt.Fatalf(`got %q, wanted \"myapp\"`, name)\n\t}\n}\n\nfunc TestEmptyQuery(t *testing.T) {\n\tdb := pg.Connect(pgOptions())\n\tdefer db.Close()\n\n\tassert := func(err error) {\n\t\tif err == nil {\n\t\t\tt.Fatal(\"error expected\")\n\t\t}\n\t\tif err.Error() != \"pg: query is empty\" {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\t_, err := db.Exec(\"\")\n\tassert(err)\n\n\t_, err = db.Query(pg.Discard, \"\")\n\tassert(err)\n\n\tstmt, err := db.Prepare(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = stmt.Exec()\n\tassert(err)\n}\n\nfunc TestAnonymousStructField(t *testing.T) {\n\ttype MyInt struct{ int }\n\n\ttype MyStruct struct {\n\t\tInts []MyInt `pg:\",array\"`\n\t}\n\n\tdb := testDB()\n\n\tvar st MyStruct\n\t_, err := db.Query(&st, \"SELECT ARRAY[1,2,3,4] AS ints\")\n\tExpect(err).ToNot(BeNil())\n\tif !strings.Contains(err.Error(), \"json: cannot unmarshal\") {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestContextCanceled(t *testing.T) {\n\tdb := testDB()\n\n\tc := context.Background()\n\tc, cancel := context.WithCancel(c)\n\tcancel()\n\n\t_, err := db.ExecContext(c, \"SELECT 1\")\n\tif err == nil {\n\t\tt.Fatalf(\"got nil, expected an error\")\n\t}\n\twanted := \"context canceled\"\n\tif err.Error() != wanted {\n\t\tt.Fatalf(\"got %q, wanted %q\", err, wanted)\n\t}\n}\n\nfunc TestBigColumn(t *testing.T) {\n\tconst colLen = 100000\n\n\ttype Test struct {\n\t\tID   int\n\t\tText string\n\t}\n\n\tdb := pg.Connect(pgOptions())\n\tdefer db.Close()\n\n\terr := db.Model((*Test)(nil)).CreateTable(&orm.CreateTableOptions{\n\t\tTemp: true,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = db.Model(&Test{\n\t\tText: strings.Repeat(\"*\", colLen),\n\t}).Insert()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttest := new(Test)\n\terr = db.Model(test).Select()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(test.Text) != colLen {\n\t\tt.Fatalf(\"got %d, wanted %d\", len(test.Text), colLen)\n\t}\n\n\tif _, err := db.Exec(\"SELECT * FROM tests\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = db.CopyTo(io.Discard, \"COPY (SELECT * FROM tests) TO STDOUT WITH CSV\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nvar _ = Describe(\"OnConnect\", func() {\n\tIt(\"does not panic on timeout\", func() {\n\t\topt := pgOptions()\n\t\topt.OnConnect = func(ctx context.Context, conn *pg.Conn) error {\n\t\t\t_, err := conn.Exec(\"SELECT pg_sleep(10)\")\n\t\t\treturn err\n\t\t}\n\n\t\tdb := pg.Connect(opt)\n\t\tdefer db.Close()\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tgo func() {\n\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t\tcancel()\n\t\t}()\n\n\t\t_, err := db.ExecContext(ctx, \"SELECT 1\")\n\t\tExpect(err).To(MatchError(\"ERROR #57014 canceling statement due to user request\"))\n\t})\n\n\tIt(\"does not panic with RunInTransaction\", func() {\n\t\topt := pgOptions()\n\t\topt.OnConnect = func(ctx context.Context, conn *pg.Conn) error {\n\t\t\t_, err := conn.Exec(\"SELECT 1\")\n\t\t\treturn err\n\t\t}\n\n\t\tdb := pg.Connect(opt)\n\t\tdefer db.Close()\n\n\t\terr := db.RunInTransaction(ctx, func(tx *pg.Tx) error {\n\t\t\t_, err := tx.Exec(`SELECT 1`)\n\t\t\treturn err\n\t\t})\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n})\n\nvar _ = Describe(\"DB\", func() {\n\tvar db *pg.DB\n\tvar tx *pg.Tx\n\n\tBeforeEach(func() {\n\t\tdb = pg.Connect(pgOptions())\n\n\t\tvar err error\n\t\ttx, err = db.Begin()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t})\n\n\tDescribe(\"uint64 in struct field\", func() {\n\t\tIt(\"is appended and scanned as int64\", func() {\n\t\t\ttype My struct {\n\t\t\t\tID uint64 `pg:\"type:bigint\"`\n\t\t\t}\n\n\t\t\terr := db.Model((*My)(nil)).CreateTable(&orm.CreateTableOptions{\n\t\t\t\tTemp: true,\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tmy := &My{\n\t\t\t\tID: math.MaxUint64,\n\t\t\t}\n\t\t\t_, err = db.Model(my).Insert()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tmy = &My{}\n\t\t\terr = db.Model(my).First()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(my.ID).To(Equal(uint64(math.MaxUint64)))\n\t\t})\n\t})\n\n\tDescribe(\"Query\", func() {\n\t\tIt(\"does not return an error when there are no results\", func() {\n\t\t\tres, err := db.Query(pg.Discard, \"SELECT 1 WHERE 1 = 2\")\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res.RowsAffected()).To(Equal(0))\n\n\t\t\tres, err = tx.Query(pg.Discard, \"SELECT 1 WHERE 1 = 2\")\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res.RowsAffected()).To(Equal(0))\n\t\t})\n\n\t\tIt(\"selects into embedded struct pointer\", func() {\n\t\t\ttype One struct {\n\t\t\t\tID int\n\t\t\t}\n\n\t\t\ttype Two struct {\n\t\t\t\t*One\n\t\t\t}\n\n\t\t\ttwo := new(Two)\n\t\t\t_, err := db.QueryOne(two, \"SELECT 1 AS id\")\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(two.One.ID).To(Equal(1))\n\t\t})\n\t})\n\n\tDescribe(\"QueryOne\", func() {\n\t\tIt(\"returns pg.ErrNoRows when there are no results\", func() {\n\t\t\t_, err := db.QueryOne(pg.Discard, \"SELECT 1 WHERE 1 = 2\")\n\t\t\tExpect(err).To(Equal(pg.ErrNoRows))\n\n\t\t\t_, err = tx.QueryOne(pg.Discard, \"SELECT 1 WHERE 1 = 2\")\n\t\t\tExpect(err).To(Equal(pg.ErrNoRows))\n\t\t})\n\t})\n\n\tDescribe(\"Exec\", func() {\n\t\tIt(\"does not return an error when there are no results\", func() {\n\t\t\tres, err := db.Exec(\"SELECT 1 WHERE 1 = 2\")\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res.RowsAffected()).To(Equal(0))\n\n\t\t\tres, err = tx.Exec(\"SELECT 1 WHERE 1 = 2\")\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res.RowsAffected()).To(Equal(0))\n\t\t})\n\t})\n\n\tDescribe(\"ExecOne\", func() {\n\t\tIt(\"returns pg.ErrNoRows when there are no results\", func() {\n\t\t\t_, err := db.ExecOne(\"SELECT 1 WHERE 1 = 2\")\n\t\t\tExpect(err).To(Equal(pg.ErrNoRows))\n\n\t\t\t_, err = tx.ExecOne(\"SELECT 1 WHERE 1 = 2\")\n\t\t\tExpect(err).To(Equal(pg.ErrNoRows))\n\t\t})\n\t})\n\n\tDescribe(\"Prepare\", func() {\n\t\tIt(\"returns an error when query can't be prepared\", func() {\n\t\t\tfor i := 0; i < 3; i++ {\n\t\t\t\t_, err := db.Prepare(\"totally invalid sql\")\n\t\t\t\tExpect(err).NotTo(BeNil())\n\t\t\t\tExpect(strings.Contains(err.Error(), \"#42601\")).To(BeTrue())\n\t\t\t\tExpect(strings.Contains(err.Error(), \"syntax error\")).To(BeTrue())\n\n\t\t\t\t_, err = db.Exec(\"SELECT 1\")\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\t\t})\n\t})\n\n\tDescribe(\"Context\", func() {\n\t\tIt(\"cancels query when context is cancelled\", func() {\n\t\t\tstart := time.Now()\n\n\t\t\tc, cancel := context.WithTimeout(context.Background(), time.Second)\n\t\t\tdefer cancel()\n\n\t\t\t_, err := db.ExecContext(c, \"SELECT pg_sleep(5)\")\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(time.Since(start)).To(BeNumerically(\"~\", time.Second, 100*time.Millisecond))\n\t\t})\n\t})\n})\n\nvar _ = Describe(\"DB.Conn\", func() {\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\tdb = pg.Connect(pgOptions())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"does not acquire connection immediately\", func() {\n\t\tconn := db.Conn()\n\n\t\tstats := db.PoolStats()\n\t\tExpect(stats.TotalConns).To(Equal(uint32(0)))\n\n\t\terr := conn.Close()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"acquires connection when used and frees when closed\", func() {\n\t\tconn := db.Conn()\n\t\t_, err := conn.Exec(\"SELECT 1\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tstats := db.PoolStats()\n\t\tExpect(stats.TotalConns).To(Equal(uint32(1)))\n\t\tExpect(stats.IdleConns).To(Equal(uint32(0)))\n\n\t\terr = conn.Close()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tstats = db.PoolStats()\n\t\tExpect(stats.TotalConns).To(Equal(uint32(1)))\n\t\tExpect(stats.IdleConns).To(Equal(uint32(1)))\n\t})\n\n\tIt(\"supports Tx\", func() {\n\t\tconn := db.Conn()\n\n\t\ttx, err := conn.Begin()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t_, err = tx.Exec(\"SELECT 1\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t_, err = conn.Exec(\"SELECT 1\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\terr = tx.Commit()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t_, err = conn.Exec(\"SELECT 1\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\terr = conn.Close()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tstats := db.PoolStats()\n\t\tExpect(stats.TotalConns).To(Equal(uint32(1)))\n\t\tExpect(stats.IdleConns).To(Equal(uint32(1)))\n\t})\n})\n\nvar _ = Describe(\"Time\", func() {\n\ttests := []struct {\n\t\tstr    string\n\t\twanted time.Time\n\t}{\n\t\t{\"0001-01-01 00:00:00+00\", time.Time{}},\n\t\t{\"0000-01-01 00:00:00+00\", time.Date(0, time.January, 1, 0, 0, 0, 0, time.UTC)},\n\n\t\t{\"2001-02-03\", time.Date(2001, time.February, 3, 0, 0, 0, 0, time.UTC)},\n\t\t{\"2001-02-03 04:05:06\", time.Date(2001, time.February, 3, 4, 5, 6, 0, time.UTC)},\n\t\t{\"2001-02-03 04:05:06.000001\", time.Date(2001, time.February, 3, 4, 5, 6, 1000, time.UTC)},\n\t\t{\"2001-02-03 04:05:06.00001\", time.Date(2001, time.February, 3, 4, 5, 6, 10000, time.UTC)},\n\t\t{\"2001-02-03 04:05:06.0001\", time.Date(2001, time.February, 3, 4, 5, 6, 100000, time.UTC)},\n\t\t{\"2001-02-03 04:05:06.001\", time.Date(2001, time.February, 3, 4, 5, 6, 1000000, time.UTC)},\n\t\t{\"2001-02-03 04:05:06.01\", time.Date(2001, time.February, 3, 4, 5, 6, 10000000, time.UTC)},\n\t\t{\"2001-02-03 04:05:06.1\", time.Date(2001, time.February, 3, 4, 5, 6, 100000000, time.UTC)},\n\t\t{\"2001-02-03 04:05:06.12\", time.Date(2001, time.February, 3, 4, 5, 6, 120000000, time.UTC)},\n\t\t{\"2001-02-03 04:05:06.123\", time.Date(2001, time.February, 3, 4, 5, 6, 123000000, time.UTC)},\n\t\t{\"2001-02-03 04:05:06.1234\", time.Date(2001, time.February, 3, 4, 5, 6, 123400000, time.UTC)},\n\t\t{\"2001-02-03 04:05:06.12345\", time.Date(2001, time.February, 3, 4, 5, 6, 123450000, time.UTC)},\n\t\t{\"2001-02-03 04:05:06.123456\", time.Date(2001, time.February, 3, 4, 5, 6, 123456000, time.UTC)},\n\t\t{\"2001-02-03 04:05:06.123-07\", time.Date(2001, time.February, 3, 4, 5, 6, 123000000, time.FixedZone(\"\", -7*60*60))},\n\t\t{\"2001-02-03 04:05:06-07\", time.Date(2001, time.February, 3, 4, 5, 6, 0, time.FixedZone(\"\", -7*60*60))},\n\t\t{\"2001-02-03 04:05:06-07:42\", time.Date(2001, time.February, 3, 4, 5, 6, 0, time.FixedZone(\"\", -(7*60*60+42*60)))},\n\t\t{\"2001-02-03 04:05:06-07:30:09\", time.Date(2001, time.February, 3, 4, 5, 6, 0, time.FixedZone(\"\", -(7*60*60+30*60+9)))},\n\t\t{\"2001-02-03 04:05:06+07\", time.Date(2001, time.February, 3, 4, 5, 6, 0, time.FixedZone(\"\", 7*60*60))},\n\t}\n\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\tdb = pg.Connect(pgOptions())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"is formatted correctly\", func() {\n\t\tfor i, test := range tests {\n\t\t\tvar tm time.Time\n\t\t\t_, err := db.QueryOne(pg.Scan(&tm), \"SELECT ?\", test.wanted)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(tm.Unix()).To(\n\t\t\t\tEqual(test.wanted.Unix()),\n\t\t\t\t\"#%d str=%q wanted=%q\", i, test.str, test.wanted,\n\t\t\t)\n\t\t}\n\t})\n\n\tIt(\"is parsed correctly\", func() {\n\t\tfor i, test := range tests {\n\t\t\tvar tm time.Time\n\t\t\t_, err := db.QueryOne(pg.Scan(&tm), \"SELECT ?\", test.str)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(tm.Unix()).To(\n\t\t\t\tEqual(test.wanted.Unix()),\n\t\t\t\t\"#%d str=%q wanted=%q\", i, test.str, test.wanted,\n\t\t\t)\n\t\t}\n\t})\n})\n\nvar _ = Describe(\"array model\", func() {\n\ttype value struct {\n\t\tValues []int16 `pg:\",array\"`\n\t}\n\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\tdb = pg.Connect(pgOptions())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"selects values\", func() {\n\t\tmodel := new(value)\n\t\t_, err := db.QueryOne(model, \"SELECT ? AS values\", pg.Array([]int16{1, 2}))\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(model.Values).To(Equal([]int16{1, 2}))\n\t})\n\n\tIt(\"selects empty values\", func() {\n\t\tmodel := &value{\n\t\t\tValues: []int16{1, 2},\n\t\t}\n\t\t_, err := db.QueryOne(model, \"SELECT ? AS values\", pg.Array([]int16{}))\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(model.Values).To(BeEmpty())\n\t})\n\n\tIt(\"selects null values\", func() {\n\t\tmodel := &value{\n\t\t\tValues: []int16{1, 2},\n\t\t}\n\t\t_, err := db.QueryOne(model, \"SELECT NULL AS values\", pg.Array([]int16{}))\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(model.Values).To(BeEmpty())\n\t})\n})\n\nvar _ = Describe(\"slice model\", func() {\n\ttype value struct {\n\t\tId int\n\t}\n\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\tdb = pg.Connect(pgOptions())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"does not error when there are no rows\", func() {\n\t\tints := make([]int, 1)\n\t\t_, err := db.Query(&ints, \"SELECT generate_series(1, 0)\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(ints).To(BeEmpty())\n\t})\n\n\tIt(\"does not error when there are no rows\", func() {\n\t\tslice := make([]value, 1)\n\t\t_, err := db.Query(&slice, \"SELECT generate_series(1, 0)\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(slice).To(BeEmpty())\n\t})\n\n\tIt(\"does not error when there are no rows\", func() {\n\t\tslice := make([]*value, 1)\n\t\t_, err := db.Query(&slice, \"SELECT generate_series(1, 0)\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(slice).To(BeEmpty())\n\t})\n\n\tIt(\"supports slice of structs\", func() {\n\t\tvar slice []value\n\t\t_, err := db.Query(&slice, `SELECT generate_series(1, 3) AS id`)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(slice).To(Equal([]value{{1}, {2}, {3}}))\n\t})\n\n\tIt(\"supports slice of pointers\", func() {\n\t\tvar slice []*value\n\t\t_, err := db.Query(&slice, `SELECT generate_series(1, 3) AS id`)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(slice).To(Equal([]*value{{1}, {2}, {3}}))\n\t})\n\n\tIt(\"supports Ints\", func() {\n\t\tvar ints pg.Ints\n\t\t_, err := db.Query(&ints, `SELECT generate_series(1, 3)`)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(ints).To(Equal(pg.Ints{1, 2, 3}))\n\t})\n\n\tIt(\"supports slice of ints\", func() {\n\t\tvar ints []int\n\t\t_, err := db.Query(&ints, `SELECT generate_series(1, 3)`)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(ints).To(Equal([]int{1, 2, 3}))\n\t})\n\n\tIt(\"supports slice of time.Time\", func() {\n\t\tvar times []time.Time\n\t\t_, err := db.Query(&times, `\n\t\t\tWITH data (time) AS (VALUES (clock_timestamp()), (clock_timestamp()))\n\t\t\tSELECT time FROM data\n\t\t`)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(times).To(HaveLen(2))\n\t})\n\n\tIt(\"resets slice\", func() {\n\t\tints := []int{1, 2, 3}\n\t\t_, err := db.Query(&ints, `SELECT 1`)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(ints).To(Equal([]int{1}))\n\t})\n\n\tIt(\"resets slice when there are no results\", func() {\n\t\tints := []int{1, 2, 3}\n\t\t_, err := db.Query(&ints, `SELECT 1 WHERE FALSE`)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(ints).To(BeEmpty())\n\t})\n})\n\nvar _ = Describe(\"read/write timeout\", func() {\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\topt := pgOptions()\n\t\topt.ReadTimeout = time.Millisecond\n\t\tdb = pg.Connect(opt)\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"slow query timeouts\", func() {\n\t\t_, err := db.Exec(`SELECT pg_sleep(1)`)\n\t\tExpect(err.(net.Error).Timeout()).To(BeTrue())\n\t})\n\n\tContext(\"WithTimeout\", func() {\n\t\tIt(\"slow query passes\", func() {\n\t\t\t_, err := db.WithTimeout(time.Minute).Exec(`SELECT pg_sleep(1)`)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\t})\n})\n\nvar _ = Describe(\"CopyFrom/CopyTo\", func() {\n\tconst n = 1000000\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\tdb = pg.Connect(pgOptions())\n\n\t\tqs := []string{\n\t\t\t\"CREATE TEMP TABLE copy_src(n int)\",\n\t\t\t\"CREATE TEMP TABLE copy_dst(n int)\",\n\t\t\tfmt.Sprintf(\"INSERT INTO copy_src SELECT generate_series(1, %d)\", n),\n\t\t}\n\t\tfor _, q := range qs {\n\t\t\t_, err := db.Exec(q)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t}\n\t})\n\n\tAfterEach(func() {\n\t\terr := db.Close()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"copies data from a table and to a table\", func() {\n\t\tvar buf bytes.Buffer\n\t\tres, err := db.CopyTo(&buf, \"COPY copy_src TO STDOUT\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.RowsAffected()).To(Equal(n))\n\n\t\tres, err = db.CopyFrom(&buf, \"COPY copy_dst FROM STDIN\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.RowsAffected()).To(Equal(n))\n\n\t\tst := db.PoolStats()\n\t\tExpect(st.Hits).To(Equal(uint32(4)))\n\t\tExpect(st.Misses).To(Equal(uint32(1)))\n\t\tExpect(st.Timeouts).To(Equal(uint32(0)))\n\t\tExpect(st.TotalConns).To(Equal(uint32(1)))\n\t\tExpect(st.IdleConns).To(Equal(uint32(1)))\n\n\t\tvar count int\n\t\t_, err = db.QueryOne(pg.Scan(&count), \"SELECT count(*) FROM copy_dst\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(count).To(Equal(n))\n\t})\n\n\tIt(\"copies corrupted data to a table\", func() {\n\t\tbuf := bytes.NewBufferString(\"corrupted,data\\nrow,two\\r\\nrow three\")\n\t\tres, err := db.CopyFrom(buf, \"COPY copy_dst FROM STDIN WITH FORMAT csv\")\n\t\tExpect(err).To(MatchError(`ERROR #42601 syntax error at or near \"FORMAT\"`))\n\t\tExpect(res).To(BeNil())\n\n\t\tst := db.Pool().Stats()\n\t\tExpect(st.Hits).To(Equal(uint32(3)))\n\t\tExpect(st.Misses).To(Equal(uint32(1)))\n\t\tExpect(st.Timeouts).To(Equal(uint32(0)))\n\t\tExpect(st.TotalConns).To(Equal(uint32(1)))\n\t\tExpect(st.IdleConns).To(Equal(uint32(1)))\n\n\t\tvar count int\n\t\t_, err = db.QueryOne(pg.Scan(&count), \"SELECT count(*) FROM copy_dst\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(count).To(Equal(0))\n\t})\n})\n\nvar _ = Describe(\"CountEstimate\", func() {\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\tdb = pg.Connect(pgOptions())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"works\", func() {\n\t\tcount, err := db.Model().\n\t\t\tTableExpr(\"generate_series(1, 10)\").\n\t\t\tCountEstimate(1000)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(count).To(Equal(10))\n\t})\n\n\tIt(\"works when there are no results\", func() {\n\t\tcount, err := db.Model().\n\t\t\tTableExpr(\"generate_series(1, 0)\").\n\t\t\tCountEstimate(1000)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(count).To(Equal(0))\n\t})\n\n\tIt(\"works with GROUP\", func() {\n\t\tcount, err := db.Model().\n\t\t\tTableExpr(\"generate_series(1, 10)\").\n\t\t\tGroup(\"generate_series\").\n\t\t\tCountEstimate(1000)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(count).To(Equal(10))\n\t})\n\n\tIt(\"works with GROUP when there are no results\", func() {\n\t\tcount, err := db.Model().\n\t\t\tTableExpr(\"generate_series(1, 0)\").\n\t\t\tGroup(\"generate_series\").\n\t\t\tCountEstimate(1000)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(count).To(Equal(0))\n\t})\n})\n\nvar _ = Describe(\"DB nulls\", func() {\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\tdb = pg.Connect(pgOptions())\n\n\t\t_, err := db.Exec(\"CREATE TEMP TABLE tests (id int, value int)\")\n\t\tExpect(err).To(BeNil())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t})\n\n\tDescribe(\"sql.NullInt64\", func() {\n\t\ttype Test struct {\n\t\t\tID    int\n\t\t\tValue sql.NullInt64\n\t\t}\n\n\t\tIt(\"inserts null value\", func() {\n\t\t\tins := &Test{\n\t\t\t\tID: 1,\n\t\t\t}\n\t\t\t_, err := db.Model(ins).Insert(ins)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tsel := &Test{\n\t\t\t\tID: 1,\n\t\t\t}\n\t\t\terr = db.Model(sel).WherePK().Select()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(sel.Value.Valid).To(BeFalse())\n\t\t})\n\n\t\tIt(\"inserts non-null value\", func() {\n\t\t\tins := &Test{\n\t\t\t\tID: 1,\n\t\t\t\tValue: sql.NullInt64{\n\t\t\t\t\tInt64: 2,\n\t\t\t\t\tValid: true,\n\t\t\t\t},\n\t\t\t}\n\t\t\t_, err := db.Model(ins).Insert()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tsel := &Test{\n\t\t\t\tID: 1,\n\t\t\t}\n\t\t\terr = db.Model(sel).WherePK().Select()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(sel.Value.Valid).To(BeTrue())\n\t\t\tExpect(sel.Value.Int64).To(Equal(int64(2)))\n\t\t})\n\t})\n\n\tContext(\"nil ptr\", func() {\n\t\ttype Test struct {\n\t\t\tID    int\n\t\t\tValue *int\n\t\t}\n\n\t\tIt(\"inserts null value\", func() {\n\t\t\tins := &Test{\n\t\t\t\tID: 1,\n\t\t\t}\n\t\t\t_, err := db.Model(ins).Insert()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tsel := &Test{\n\t\t\t\tID: 1,\n\t\t\t}\n\t\t\terr = db.Model(sel).WherePK().Select()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(sel.Value).To(BeNil())\n\t\t})\n\n\t\tIt(\"inserts non-null value\", func() {\n\t\t\tvalue := 2\n\t\t\tins := &Test{\n\t\t\t\tID:    1,\n\t\t\t\tValue: &value,\n\t\t\t}\n\t\t\t_, err := db.Model(ins).Insert()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tsel := &Test{\n\t\t\t\tID: 1,\n\t\t\t}\n\t\t\terr = db.Model(sel).WherePK().Select()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(sel.Value).NotTo(BeNil())\n\t\t\tExpect(*sel.Value).To(Equal(2))\n\t\t})\n\t})\n})\n\nvar _ = Describe(\"DB.Select\", func() {\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\tdb = pg.Connect(pgOptions())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"selects bytea\", func() {\n\t\tqs := []string{\n\t\t\t`CREATE TEMP TABLE tests (col bytea)`,\n\t\t\tfmt.Sprintf(`INSERT INTO tests VALUES ('\\x%x')`, []byte(\"bytes\")),\n\t\t}\n\t\tfor _, q := range qs {\n\t\t\t_, err := db.Exec(q)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t}\n\n\t\tvar col []byte\n\t\terr := db.Model().Table(\"tests\").Column(\"col\").Select(pg.Scan(&col))\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"selects into embedded struct pointer\", func() {\n\t\ttype One struct {\n\t\t\tID int\n\t\t}\n\n\t\ttype Two struct {\n\t\t\t*One\n\t\t}\n\n\t\terr := db.Model((*Two)(nil)).CreateTable(&orm.CreateTableOptions{\n\t\t\tTemp: true,\n\t\t})\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t_, err = db.Model(&Two{\n\t\t\tOne: &One{\n\t\t\t\tID: 1,\n\t\t\t},\n\t\t}).Insert()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\ttwo := new(Two)\n\t\terr = db.Model(two).Where(\"id = 1\").Select()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(two.One.ID).To(Equal(1))\n\t})\n})\n\nvar _ = Describe(\"DB.Insert\", func() {\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\tdb = pg.Connect(pgOptions())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"returns an error on nil\", func() {\n\t\t_, err := db.Model(nil).Insert()\n\t\tExpect(err).To(MatchError(\"pg: Model(nil)\"))\n\t})\n\n\tIt(\"returns an error if value is not settable\", func() {\n\t\t_, err := db.Model(1).Insert()\n\t\tExpect(err).To(MatchError(\"pg: Model(non-pointer int)\"))\n\t})\n\n\tIt(\"returns an error if value is not supported\", func() {\n\t\tvar v int\n\t\t_, err := db.Model(&v).Insert()\n\t\tExpect(err).To(MatchError(\"pg: Model(unsupported *int)\"))\n\t})\n})\n\nvar _ = Describe(\"DB.Update\", func() {\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\tdb = pg.Connect(pgOptions())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"returns an error on nil\", func() {\n\t\t_, err := db.Model(nil).Update()\n\t\tExpect(err).To(MatchError(\"pg: Model(nil)\"))\n\t})\n\n\tIt(\"returns an error if there are no pks\", func() {\n\t\ttype Test struct{}\n\t\tvar test Test\n\t\t_, err := db.Model(&test).WherePK().Update()\n\t\tExpect(err).To(MatchError(`pg: model=Test does not have primary keys`))\n\t})\n})\n\nvar _ = Describe(\"DB.Delete\", func() {\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\tdb = pg.Connect(pgOptions())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"returns an error on nil\", func() {\n\t\t_, err := db.Model(nil).Delete()\n\t\tExpect(err).To(MatchError(\"pg: Model(nil)\"))\n\t})\n\n\tIt(\"returns an error if there are no pks\", func() {\n\t\ttype Test struct{}\n\t\tvar test Test\n\t\t_, err := db.Model(&test).WherePK().Delete()\n\t\tExpect(err).To(MatchError(`pg: model=Test does not have primary keys`))\n\t})\n\n\tIt(\"returns an error if there are no where\", func() {\n\t\tvar test []struct {\n\t\t\tId int\n\t\t}\n\t\t_, err := db.Model(&test).Delete()\n\t\tExpect(err).To(MatchError(`pg: Update and Delete queries require Where clause (try WherePK)`))\n\t})\n})\n\nvar _ = Describe(\"errors\", func() {\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\tdb = pg.Connect(pgOptions())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"unknown column error\", func() {\n\t\ttype Test struct {\n\t\t\tCol1 int\n\t\t}\n\n\t\tvar test Test\n\t\t_, err := db.QueryOne(&test, \"SELECT 1 AS col1, 2 AS col2\")\n\t\tExpect(err).To(MatchError(\"pg: can't find column=col2 in model=Test (prefix the column with underscore or use discard_unknown_columns)\"))\n\t\tExpect(test.Col1).To(Equal(1))\n\t})\n\n\tIt(\"Scan error\", func() {\n\t\tvar n1 int\n\t\t_, err := db.QueryOne(pg.Scan(&n1), \"SELECT 1, 2\")\n\t\tExpect(err).To(MatchError(`pg: no Scan var for column index=1 name=\"?column?\"`))\n\t\tExpect(n1).To(Equal(1))\n\t})\n})\n\ntype Genre struct {\n\t// tableName is an optional field that specifies custom table name and alias.\n\t// By default go-pg generates table name and alias from struct name.\n\ttableName struct{} `pg:\"genres,alias:genre\"` // default values are the same\n\n\tID     int\n\tName   string\n\tRating int `pg:\"-\"` // - is used to ignore field\n\n\tBooks []Book `pg:\"many2many:book_genres\"`\n\n\tParentID  int\n\tSubgenres []Genre `pg:\"rel:has-many,join_fk:parent_id\"`\n}\n\nfunc (g Genre) String() string {\n\treturn fmt.Sprintf(\"Genre<Id=%d Name=%q>\", g.ID, g.Name)\n}\n\ntype Image struct {\n\tID   int\n\tPath string\n}\n\ntype Author struct {\n\tID    int\n\tName  string  `pg:\",unique\"`\n\tBooks []*Book `pg:\"rel:has-many\"`\n\n\tAvatarID int\n\tAvatar   Image `pg:\"rel:has-one\"`\n}\n\nfunc (a Author) String() string {\n\treturn fmt.Sprintf(\"Author<ID=%d Name=%q>\", a.ID, a.Name)\n}\n\ntype BookGenre struct {\n\ttableName struct{} `pg:\"alias:bg\"` // custom table alias\n\n\tBookID  int    `pg:\",pk\"` // pk tag is used to mark field as primary key\n\tBook    *Book  `pg:\"rel:has-one\"`\n\tGenreID int    `pg:\",pk\"`\n\tGenre   *Genre `pg:\"rel:has-one\"`\n\n\tGenre_Rating int // belongs to and is copied to Genre model\n}\n\ntype Book struct {\n\tID        int\n\tTitle     string\n\tAuthorID  int\n\tAuthor    Author `pg:\"rel:has-one\"`\n\tEditorID  int\n\tEditor    *Author   `pg:\"rel:has-one\"`\n\tCreatedAt time.Time `pg:\"default:now()\"`\n\tUpdatedAt time.Time\n\n\tGenres       []Genre       `pg:\"many2many:book_genres\"` // many to many relation\n\tTranslations []Translation `pg:\"rel:has-many\"`\n\tComments     []Comment     `pg:\"rel:has-many,join_fk:trackable_,polymorphic\"`\n}\n\nvar _ orm.BeforeInsertHook = (*Book)(nil)\n\nfunc (b Book) String() string {\n\treturn fmt.Sprintf(\"Book<Id=%d Title=%q>\", b.ID, b.Title)\n}\n\nfunc (b *Book) BeforeInsert(c context.Context) (context.Context, error) {\n\tif b.CreatedAt.IsZero() {\n\t\tb.CreatedAt = time.Now()\n\t}\n\treturn c, nil\n}\n\n// BookWithCommentCount is like Book model, but has additional CommentCount\n// field that is used to select data into it. The use of `pg:\",inherit\"` tag\n// is essential here so it inherits internal model properties such as table name.\ntype BookWithCommentCount struct {\n\tBook `pg:\",inherit\"`\n\n\tCommentCount int\n}\n\ntype Translation struct {\n\ttableName struct{} `pg:\",alias:tr\"` // custom table alias\n\n\tID     int\n\tBookID int    `pg:\"unique:book_id_lang\"`\n\tBook   *Book  `pg:\"rel:has-one\"`\n\tLang   string `pg:\"unique:book_id_lang\"`\n\n\tComments []Comment `pg:\"rel:has-many,join_fk:trackable_,polymorphic\"`\n}\n\ntype Comment struct {\n\tTrackableID   int    // Book.ID or Translation.ID\n\tTrackableType string // \"Book\" or \"Translation\"\n\tText          string\n}\n\nfunc createTestSchema(db *pg.DB) error {\n\tmodels := []interface{}{\n\t\t(*Image)(nil),\n\t\t(*Author)(nil),\n\t\t(*Book)(nil),\n\t\t(*Genre)(nil),\n\t\t(*BookGenre)(nil),\n\t\t(*Translation)(nil),\n\t\t(*Comment)(nil),\n\t}\n\tfor _, model := range models {\n\t\terr := db.Model(model).DropTable(&orm.DropTableOptions{\n\t\t\tIfExists: true,\n\t\t\tCascade:  true,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = db.Model(model).CreateTable(nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nvar _ = Describe(\"ORM\", func() {\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\tdb = pg.Connect(pgOptions())\n\n\t\terr := createTestSchema(db)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tgenres := []Genre{{\n\t\t\tID:   1,\n\t\t\tName: \"genre 1\",\n\t\t}, {\n\t\t\tID:   2,\n\t\t\tName: \"genre 2\",\n\t\t}, {\n\t\t\tID:       3,\n\t\t\tName:     \"subgenre 1\",\n\t\t\tParentID: 1,\n\t\t}, {\n\t\t\tID:       4,\n\t\t\tName:     \"subgenre 2\",\n\t\t\tParentID: 1,\n\t\t}}\n\t\t_, err = db.Model(&genres).Insert()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(genres).To(HaveLen(4))\n\n\t\timages := []Image{{\n\t\t\tID:   1,\n\t\t\tPath: \"/path/to/1.jpg\",\n\t\t}, {\n\t\t\tID:   2,\n\t\t\tPath: \"/path/to/2.jpg\",\n\t\t}, {\n\t\t\tID:   3,\n\t\t\tPath: \"/path/to/3.jpg\",\n\t\t}}\n\t\t_, err = db.Model(&images).Insert()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(images).To(HaveLen(3))\n\n\t\tauthors := []Author{{\n\t\t\tID:       10,\n\t\t\tName:     \"author 1\",\n\t\t\tAvatarID: images[0].ID,\n\t\t}, {\n\t\t\tID:       11,\n\t\t\tName:     \"author 2\",\n\t\t\tAvatarID: images[1].ID,\n\t\t}, {\n\t\t\tID:       12,\n\t\t\tName:     \"author 3\",\n\t\t\tAvatarID: images[2].ID,\n\t\t}}\n\t\t_, err = db.Model(&authors).Insert()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(authors).To(HaveLen(3))\n\n\t\tbooks := []Book{{\n\t\t\tID:       100,\n\t\t\tTitle:    \"book 1\",\n\t\t\tAuthorID: 10,\n\t\t\tEditorID: 11,\n\t\t}, {\n\t\t\tID:       101,\n\t\t\tTitle:    \"book 2\",\n\t\t\tAuthorID: 10,\n\t\t\tEditorID: 12,\n\t\t}, {\n\t\t\tID:       102,\n\t\t\tTitle:    \"book 3\",\n\t\t\tAuthorID: 11,\n\t\t\tEditorID: 11,\n\t\t}}\n\t\t_, err = db.Model(&books).Insert()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(books).To(HaveLen(3))\n\t\tfor _, book := range books {\n\t\t\tExpect(book.CreatedAt).To(BeTemporally(\"~\", time.Now(), time.Second))\n\t\t}\n\n\t\tbookGenres := []BookGenre{{\n\t\t\tBookID:       100,\n\t\t\tGenreID:      1,\n\t\t\tGenre_Rating: 999,\n\t\t}, {\n\t\t\tBookID:       100,\n\t\t\tGenreID:      2,\n\t\t\tGenre_Rating: 9999,\n\t\t}, {\n\t\t\tBookID:       101,\n\t\t\tGenreID:      1,\n\t\t\tGenre_Rating: 99999,\n\t\t}}\n\t\t_, err = db.Model(&bookGenres).Insert()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(bookGenres).To(HaveLen(3))\n\n\t\ttranslations := []Translation{{\n\t\t\tID:     1000,\n\t\t\tBookID: 100,\n\t\t\tLang:   \"ru\",\n\t\t}, {\n\t\t\tID:     1001,\n\t\t\tBookID: 100,\n\t\t\tLang:   \"md\",\n\t\t}, {\n\t\t\tID:     1002,\n\t\t\tBookID: 101,\n\t\t\tLang:   \"ua\",\n\t\t}}\n\t\t_, err = db.Model(&translations).Insert()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(translations).To(HaveLen(3))\n\n\t\tcomments := []Comment{{\n\t\t\tTrackableID:   100,\n\t\t\tTrackableType: \"Book\",\n\t\t\tText:          \"comment1\",\n\t\t}, {\n\t\t\tTrackableID:   100,\n\t\t\tTrackableType: \"Book\",\n\t\t\tText:          \"comment2\",\n\t\t}, {\n\t\t\tTrackableID:   1000,\n\t\t\tTrackableType: \"Translation\",\n\t\t\tText:          \"comment3\",\n\t\t}}\n\t\t_, err = db.Model(&comments).Insert()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(comments).To(HaveLen(3))\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t})\n\n\tDescribe(\"relation with no results\", func() {\n\t\tIt(\"does not panic\", func() {\n\t\t\ttr := new(Translation)\n\t\t\ttr.ID = 123\n\t\t\t_, err := db.Model(tr).Insert()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = db.Model(tr).\n\t\t\t\tRelation(\"Book.Genres\").\n\t\t\t\tRelation(\"Book.Translations\").\n\t\t\t\tRelation(\"Book.Comments\").\n\t\t\t\tWherePK().\n\t\t\t\tSelect()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\t})\n\n\tDescribe(\"struct model\", func() {\n\t\tIt(\"Select returns pg.ErrNoRows\", func() {\n\t\t\tbook := new(Book)\n\t\t\terr := db.Model(book).\n\t\t\t\tWhere(\"1 = 2\").\n\t\t\t\tSelect()\n\t\t\tExpect(err).To(Equal(pg.ErrNoRows))\n\t\t})\n\n\t\tIt(\"Insert returns pg.ErrNoRows\", func() {\n\t\t\tbook := new(Book)\n\t\t\terr := db.Model(book).First()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t_, err = db.Model(book).\n\t\t\t\tOnConflict(\"DO NOTHING\").\n\t\t\t\tReturning(\"*\").\n\t\t\t\tInsert()\n\t\t\tExpect(err).To(Equal(pg.ErrNoRows))\n\t\t})\n\n\t\tIt(\"Update returns pg.ErrNoRows\", func() {\n\t\t\tbook := new(Book)\n\t\t\t_, err := db.Model(book).\n\t\t\t\tWhere(\"1 = 2\").\n\t\t\t\tReturning(\"*\").\n\t\t\t\tUpdate()\n\t\t\tExpect(err).To(Equal(pg.ErrNoRows))\n\t\t})\n\n\t\tIt(\"Delete returns pg.ErrNoRows\", func() {\n\t\t\tbook := new(Book)\n\t\t\t_, err := db.Model(book).\n\t\t\t\tWhere(\"1 = 2\").\n\t\t\t\tReturning(\"*\").\n\t\t\t\tDelete()\n\t\t\tExpect(err).To(Equal(pg.ErrNoRows))\n\t\t})\n\n\t\tIt(\"fetches Book relations\", func() {\n\t\t\tbook := new(Book)\n\t\t\terr := db.Model(book).\n\t\t\t\tColumn(\"book.id\").\n\t\t\t\tRelation(\"Author\").\n\t\t\t\tRelation(\"Author.Avatar\").\n\t\t\t\tRelation(\"Editor\").\n\t\t\t\tRelation(\"Editor.Avatar\").\n\t\t\t\tRelation(\"Genres\").\n\t\t\t\tRelation(\"Comments\").\n\t\t\t\tRelation(\"Translations\", func(q *pg.Query) (*pg.Query, error) {\n\t\t\t\t\treturn q.Order(\"id\"), nil\n\t\t\t\t}).\n\t\t\t\tRelation(\"Translations.Comments\", func(q *pg.Query) (*pg.Query, error) {\n\t\t\t\t\treturn q.Order(\"text\"), nil\n\t\t\t\t}).\n\t\t\t\tFirst()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(book).To(Equal(&Book{\n\t\t\t\tID:    100,\n\t\t\t\tTitle: \"\",\n\t\t\t\tAuthor: Author{\n\t\t\t\t\tID:       10,\n\t\t\t\t\tName:     \"author 1\",\n\t\t\t\t\tAvatarID: 1,\n\t\t\t\t\tAvatar: Image{\n\t\t\t\t\t\tID:   1,\n\t\t\t\t\t\tPath: \"/path/to/1.jpg\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tEditor: &Author{\n\t\t\t\t\tID:       11,\n\t\t\t\t\tName:     \"author 2\",\n\t\t\t\t\tAvatarID: 2,\n\t\t\t\t\tAvatar: Image{\n\t\t\t\t\t\tID:   2,\n\t\t\t\t\t\tPath: \"/path/to/2.jpg\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tCreatedAt: time.Time{},\n\t\t\t\tGenres: []Genre{\n\t\t\t\t\t{ID: 1, Name: \"genre 1\", Rating: 999},\n\t\t\t\t\t{ID: 2, Name: \"genre 2\", Rating: 9999},\n\t\t\t\t},\n\t\t\t\tTranslations: []Translation{{\n\t\t\t\t\tID:     1000,\n\t\t\t\t\tBookID: 100,\n\t\t\t\t\tLang:   \"ru\",\n\t\t\t\t\tComments: []Comment{\n\t\t\t\t\t\t{TrackableID: 1000, TrackableType: \"Translation\", Text: \"comment3\"},\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tID:       1001,\n\t\t\t\t\tBookID:   100,\n\t\t\t\t\tLang:     \"md\",\n\t\t\t\t\tComments: nil,\n\t\t\t\t}},\n\t\t\t\tComments: []Comment{\n\t\t\t\t\t{TrackableID: 100, TrackableType: \"Book\", Text: \"comment1\"},\n\t\t\t\t\t{TrackableID: 100, TrackableType: \"Book\", Text: \"comment2\"},\n\t\t\t\t},\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"fetches Author relations\", func() {\n\t\t\tvar author Author\n\t\t\terr := db.Model(&author).\n\t\t\t\tColumn(\"author.*\").\n\t\t\t\tRelation(\"Books.id\").Relation(\"Books.author_id\").Relation(\"Books.editor_id\").\n\t\t\t\tRelation(\"Books.Author\").\n\t\t\t\tRelation(\"Books.Editor\").\n\t\t\t\tRelation(\"Books.Translations\").\n\t\t\t\tFirst()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(author).To(Equal(Author{\n\t\t\t\tID:       10,\n\t\t\t\tName:     \"author 1\",\n\t\t\t\tAvatarID: 1,\n\t\t\t\tBooks: []*Book{{\n\t\t\t\t\tID:        100,\n\t\t\t\t\tTitle:     \"\",\n\t\t\t\t\tAuthorID:  10,\n\t\t\t\t\tAuthor:    Author{ID: 10, Name: \"author 1\", AvatarID: 1},\n\t\t\t\t\tEditorID:  11,\n\t\t\t\t\tEditor:    &Author{ID: 11, Name: \"author 2\", AvatarID: 2},\n\t\t\t\t\tCreatedAt: time.Time{},\n\t\t\t\t\tGenres:    nil,\n\t\t\t\t\tTranslations: []Translation{\n\t\t\t\t\t\t{ID: 1000, BookID: 100, Book: nil, Lang: \"ru\", Comments: nil},\n\t\t\t\t\t\t{ID: 1001, BookID: 100, Book: nil, Lang: \"md\", Comments: nil},\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tID:        101,\n\t\t\t\t\tTitle:     \"\",\n\t\t\t\t\tAuthorID:  10,\n\t\t\t\t\tAuthor:    Author{ID: 10, Name: \"author 1\", AvatarID: 1},\n\t\t\t\t\tEditorID:  12,\n\t\t\t\t\tEditor:    &Author{ID: 12, Name: \"author 3\", AvatarID: 3},\n\t\t\t\t\tCreatedAt: time.Time{},\n\t\t\t\t\tGenres:    nil,\n\t\t\t\t\tTranslations: []Translation{\n\t\t\t\t\t\t{ID: 1002, BookID: 101, Book: nil, Lang: \"ua\", Comments: nil},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"fetches Genre relations\", func() {\n\t\t\tvar genre Genre\n\t\t\terr := db.Model(&genre).\n\t\t\t\tColumn(\"genre.*\").\n\t\t\t\tRelation(\"Books.id\").\n\t\t\t\tRelation(\"Books.Translations\").\n\t\t\t\tFirst()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(genre).To(Equal(Genre{\n\t\t\t\tID:     1,\n\t\t\t\tName:   \"genre 1\",\n\t\t\t\tRating: 0,\n\t\t\t\tBooks: []Book{{\n\t\t\t\t\tID: 100,\n\t\t\t\t\tTranslations: []Translation{\n\t\t\t\t\t\t{ID: 1000, BookID: 100, Book: nil, Lang: \"ru\", Comments: nil},\n\t\t\t\t\t\t{ID: 1001, BookID: 100, Book: nil, Lang: \"md\", Comments: nil},\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tID: 101,\n\t\t\t\t\tTranslations: []Translation{\n\t\t\t\t\t\t{ID: 1002, BookID: 101, Book: nil, Lang: \"ua\", Comments: nil},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t\tParentID:  0,\n\t\t\t\tSubgenres: nil,\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"fetches Translation relation\", func() {\n\t\t\tvar translation Translation\n\t\t\terr := db.Model(&translation).\n\t\t\t\tColumn(\"tr.*\").\n\t\t\t\tRelation(\"Book.id\").\n\t\t\t\tRelation(\"Book.Author\").\n\t\t\t\tRelation(\"Book.Editor\").\n\t\t\t\tFirst()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(translation).To(Equal(Translation{\n\t\t\t\tID:     1000,\n\t\t\t\tBookID: 100,\n\t\t\t\tBook: &Book{\n\t\t\t\t\tID:     100,\n\t\t\t\t\tAuthor: Author{ID: 10, Name: \"author 1\", AvatarID: 1},\n\t\t\t\t\tEditor: &Author{ID: 11, Name: \"author 2\", AvatarID: 2},\n\t\t\t\t},\n\t\t\t\tLang: \"ru\",\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"works when there are no results\", func() {\n\t\t\tbook := new(Book)\n\t\t\terr := db.Model(book).\n\t\t\t\tColumn(\"book.*\").\n\t\t\t\tRelation(\"Author\").\n\t\t\t\tRelation(\"Genres\").\n\t\t\t\tRelation(\"Comments\").\n\t\t\t\tWhere(\"1 = 2\").\n\t\t\t\tSelect()\n\t\t\tExpect(err).To(Equal(pg.ErrNoRows))\n\t\t})\n\n\t\tIt(\"supports overriding\", func() {\n\t\t\tbook := new(BookWithCommentCount)\n\t\t\terr := db.Model(book).\n\t\t\t\tColumn(\"book.id\").\n\t\t\t\tRelation(\"Author\").\n\t\t\t\tRelation(\"Genres\").\n\t\t\t\tColumnExpr(`(SELECT COUNT(*) FROM comments\n\t\t\t\t\tWHERE trackable_type = 'Book' AND\n\t\t\t\t\ttrackable_id = book.id) AS comment_count`).\n\t\t\t\tFirst()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(book).To(Equal(&BookWithCommentCount{\n\t\t\t\tBook: Book{\n\t\t\t\t\tID:     100,\n\t\t\t\t\tAuthor: Author{ID: 10, Name: \"author 1\", AvatarID: 1},\n\t\t\t\t\tGenres: []Genre{\n\t\t\t\t\t\t{ID: 1, Name: \"genre 1\", Rating: 999},\n\t\t\t\t\t\t{ID: 2, Name: \"genre 2\", Rating: 9999},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tCommentCount: 2,\n\t\t\t}))\n\t\t})\n\t})\n\n\tDescribe(\"slice model\", func() {\n\t\tIt(\"fetches Book relations\", func() {\n\t\t\tvar books []Book\n\t\t\terr := db.Model(&books).\n\t\t\t\tColumn(\"book.id\").\n\t\t\t\tRelation(\"Author\").\n\t\t\t\tRelation(\"Author.Avatar\").\n\t\t\t\tRelation(\"Editor\").\n\t\t\t\tRelation(\"Editor.Avatar\").\n\t\t\t\tRelation(\"Genres\").\n\t\t\t\tRelation(\"Comments\").\n\t\t\t\tRelation(\"Translations\").\n\t\t\t\tRelation(\"Translations.Comments\").\n\t\t\t\tOrderExpr(\"book.id ASC\").\n\t\t\t\tSelect()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(books).To(Equal([]Book{{\n\t\t\t\tID:       100,\n\t\t\t\tTitle:    \"\",\n\t\t\t\tAuthorID: 0,\n\t\t\t\tAuthor: Author{\n\t\t\t\t\tID:       10,\n\t\t\t\t\tName:     \"author 1\",\n\t\t\t\t\tAvatarID: 1,\n\t\t\t\t\tAvatar: Image{\n\t\t\t\t\t\tID:   1,\n\t\t\t\t\t\tPath: \"/path/to/1.jpg\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tEditorID: 0,\n\t\t\t\tEditor: &Author{\n\t\t\t\t\tID:       11,\n\t\t\t\t\tName:     \"author 2\",\n\t\t\t\t\tAvatarID: 2,\n\t\t\t\t\tAvatar: Image{\n\t\t\t\t\t\tID:   2,\n\t\t\t\t\t\tPath: \"/path/to/2.jpg\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tGenres: []Genre{\n\t\t\t\t\t{ID: 1, Name: \"genre 1\", Rating: 999},\n\t\t\t\t\t{ID: 2, Name: \"genre 2\", Rating: 9999},\n\t\t\t\t},\n\t\t\t\tTranslations: []Translation{{\n\t\t\t\t\tID:     1000,\n\t\t\t\t\tBookID: 100,\n\t\t\t\t\tLang:   \"ru\",\n\t\t\t\t\tComments: []Comment{\n\t\t\t\t\t\t{TrackableID: 1000, TrackableType: \"Translation\", Text: \"comment3\"},\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tID:       1001,\n\t\t\t\t\tBookID:   100,\n\t\t\t\t\tLang:     \"md\",\n\t\t\t\t\tComments: nil,\n\t\t\t\t}},\n\t\t\t\tComments: []Comment{\n\t\t\t\t\t{TrackableID: 100, TrackableType: \"Book\", Text: \"comment1\"},\n\t\t\t\t\t{TrackableID: 100, TrackableType: \"Book\", Text: \"comment2\"},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\tID:       101,\n\t\t\t\tTitle:    \"\",\n\t\t\t\tAuthorID: 0,\n\t\t\t\tAuthor: Author{\n\t\t\t\t\tID:       10,\n\t\t\t\t\tName:     \"author 1\",\n\t\t\t\t\tAvatarID: 1,\n\t\t\t\t\tAvatar: Image{\n\t\t\t\t\t\tID:   1,\n\t\t\t\t\t\tPath: \"/path/to/1.jpg\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tEditorID: 0,\n\t\t\t\tEditor: &Author{\n\t\t\t\t\tID:       12,\n\t\t\t\t\tName:     \"author 3\",\n\t\t\t\t\tAvatarID: 3,\n\t\t\t\t\tAvatar: Image{\n\t\t\t\t\t\tID:   3,\n\t\t\t\t\t\tPath: \"/path/to/3.jpg\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tGenres: []Genre{\n\t\t\t\t\t{ID: 1, Name: \"genre 1\", Rating: 99999},\n\t\t\t\t},\n\t\t\t\tTranslations: []Translation{\n\t\t\t\t\t{ID: 1002, BookID: 101, Lang: \"ua\"},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\tID:       102,\n\t\t\t\tTitle:    \"\",\n\t\t\t\tAuthorID: 0,\n\t\t\t\tAuthor: Author{\n\t\t\t\t\tID:       11,\n\t\t\t\t\tName:     \"author 2\",\n\t\t\t\t\tAvatarID: 2,\n\t\t\t\t\tAvatar: Image{\n\t\t\t\t\t\tID:   2,\n\t\t\t\t\t\tPath: \"/path/to/2.jpg\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tEditorID: 0,\n\t\t\t\tEditor: &Author{\n\t\t\t\t\tID:       11,\n\t\t\t\t\tName:     \"author 2\",\n\t\t\t\t\tAvatarID: 2,\n\t\t\t\t\tAvatar: Image{\n\t\t\t\t\t\tID:   2,\n\t\t\t\t\t\tPath: \"/path/to/2.jpg\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"fetches Genre relations\", func() {\n\t\t\tvar genres []Genre\n\t\t\terr := db.Model(&genres).\n\t\t\t\tColumn(\"genre.*\").\n\t\t\t\tRelation(\"Subgenres\").\n\t\t\t\tRelation(\"Books.id\").\n\t\t\t\tRelation(\"Books.Translations\").\n\t\t\t\tWhere(\"genre.parent_id IS NULL\").\n\t\t\t\tOrderExpr(\"genre.id\").\n\t\t\t\tSelect()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(genres).To(Equal([]Genre{\n\t\t\t\t{\n\t\t\t\t\tID:     1,\n\t\t\t\t\tName:   \"genre 1\",\n\t\t\t\t\tRating: 0,\n\t\t\t\t\tBooks: []Book{{\n\t\t\t\t\t\tID: 100,\n\t\t\t\t\t\tTranslations: []Translation{\n\t\t\t\t\t\t\t{ID: 1000, BookID: 100, Book: nil, Lang: \"ru\", Comments: nil},\n\t\t\t\t\t\t\t{ID: 1001, BookID: 100, Book: nil, Lang: \"md\", Comments: nil},\n\t\t\t\t\t\t},\n\t\t\t\t\t}, {\n\t\t\t\t\t\tID: 101,\n\t\t\t\t\t\tTranslations: []Translation{\n\t\t\t\t\t\t\t{ID: 1002, BookID: 101, Book: nil, Lang: \"ua\", Comments: nil},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t\tParentID: 0,\n\t\t\t\t\tSubgenres: []Genre{\n\t\t\t\t\t\t{ID: 3, Name: \"subgenre 1\", Rating: 0, Books: nil, ParentID: 1, Subgenres: nil},\n\t\t\t\t\t\t{ID: 4, Name: \"subgenre 2\", Rating: 0, Books: nil, ParentID: 1, Subgenres: nil},\n\t\t\t\t\t},\n\t\t\t\t}, {\n\t\t\t\t\tID:     2,\n\t\t\t\t\tName:   \"genre 2\",\n\t\t\t\t\tRating: 0,\n\t\t\t\t\tBooks: []Book{{\n\t\t\t\t\t\tID: 100,\n\t\t\t\t\t\tTranslations: []Translation{\n\t\t\t\t\t\t\t{ID: 1000, BookID: 100, Book: nil, Lang: \"ru\", Comments: nil},\n\t\t\t\t\t\t\t{ID: 1001, BookID: 100, Book: nil, Lang: \"md\", Comments: nil},\n\t\t\t\t\t\t},\n\t\t\t\t\t}},\n\t\t\t\t\tParentID:  0,\n\t\t\t\t\tSubgenres: nil,\n\t\t\t\t},\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"fetches Translation relation\", func() {\n\t\t\tvar translations []Translation\n\t\t\terr := db.Model(&translations).\n\t\t\t\tColumn(\"tr.*\").\n\t\t\t\tRelation(\"Book.id\").\n\t\t\t\tRelation(\"Book.Author\").\n\t\t\t\tRelation(\"Book.Editor\").\n\t\t\t\tSelect()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(translations).To(Equal([]Translation{{\n\t\t\t\tID:     1000,\n\t\t\t\tBookID: 100,\n\t\t\t\tBook: &Book{\n\t\t\t\t\tID:     100,\n\t\t\t\t\tAuthor: Author{ID: 10, Name: \"author 1\", AvatarID: 1},\n\t\t\t\t\tEditor: &Author{ID: 11, Name: \"author 2\", AvatarID: 2},\n\t\t\t\t},\n\t\t\t\tLang: \"ru\",\n\t\t\t}, {\n\t\t\t\tID:     1001,\n\t\t\t\tBookID: 100,\n\t\t\t\tBook: &Book{\n\t\t\t\t\tID:     100,\n\t\t\t\t\tAuthor: Author{ID: 10, Name: \"author 1\", AvatarID: 1},\n\t\t\t\t\tEditor: &Author{ID: 11, Name: \"author 2\", AvatarID: 2},\n\t\t\t\t},\n\t\t\t\tLang: \"md\",\n\t\t\t}, {\n\t\t\t\tID:     1002,\n\t\t\t\tBookID: 101,\n\t\t\t\tBook: &Book{\n\t\t\t\t\tID:     101,\n\t\t\t\t\tAuthor: Author{ID: 10, Name: \"author 1\", AvatarID: 1},\n\t\t\t\t\tEditor: &Author{ID: 12, Name: \"author 3\", AvatarID: 3},\n\t\t\t\t},\n\t\t\t\tLang: \"ua\",\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"works when there are no results\", func() {\n\t\t\tvar books []Book\n\t\t\terr := db.Model(&books).\n\t\t\t\tColumn(\"book.*\").\n\t\t\t\tRelation(\"Author\").\n\t\t\t\tRelation(\"Genres\").\n\t\t\t\tRelation(\"Comments\").\n\t\t\t\tWhere(\"1 = 2\").\n\t\t\t\tSelect()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(books).To(BeNil())\n\t\t})\n\n\t\tIt(\"supports overriding\", func() {\n\t\t\tvar books []BookWithCommentCount\n\t\t\terr := db.Model(&books).\n\t\t\t\tColumn(\"book.id\").\n\t\t\t\tRelation(\"Author\").\n\t\t\t\tRelation(\"Genres\").\n\t\t\t\tColumnExpr(`(SELECT COUNT(*) FROM comments WHERE trackable_type = 'Book' AND trackable_id = book.id) AS comment_count`).\n\t\t\t\tOrderExpr(\"id ASC\").\n\t\t\t\tSelect()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(books).To(Equal([]BookWithCommentCount{{\n\t\t\t\tBook: Book{\n\t\t\t\t\tID:     100,\n\t\t\t\t\tAuthor: Author{ID: 10, Name: \"author 1\", AvatarID: 1},\n\t\t\t\t\tGenres: []Genre{\n\t\t\t\t\t\t{ID: 1, Name: \"genre 1\", Rating: 999},\n\t\t\t\t\t\t{ID: 2, Name: \"genre 2\", Rating: 9999},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tCommentCount: 2,\n\t\t\t}, {\n\t\t\t\tBook: Book{\n\t\t\t\t\tID:     101,\n\t\t\t\t\tAuthor: Author{ID: 10, Name: \"author 1\", AvatarID: 1},\n\t\t\t\t\tGenres: []Genre{\n\t\t\t\t\t\t{ID: 1, Name: \"genre 1\", Rating: 99999},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tCommentCount: 0,\n\t\t\t}, {\n\t\t\t\tBook: Book{\n\t\t\t\t\tID:     102,\n\t\t\t\t\tAuthor: Author{ID: 11, Name: \"author 2\", AvatarID: 2},\n\t\t\t\t},\n\t\t\t\tCommentCount: 0,\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"supports WherePK\", func() {\n\t\t\tbooks := []Book{\n\t\t\t\t{ID: 101},\n\t\t\t\t{ID: 100},\n\t\t\t}\n\t\t\terr := db.Model(&books).Column(\"title\").WherePK().Select()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(books).To(Equal([]Book{\n\t\t\t\t{ID: 101, Title: \"book 2\"},\n\t\t\t\t{ID: 100, Title: \"book 1\"},\n\t\t\t}))\n\t\t})\n\t})\n\n\tDescribe(\"fetches Book relations\", func() {\n\t\tIt(\"supports HasOne, HasMany, HasMany2Many\", func() {\n\t\t\tvar books []*Book\n\t\t\terr := db.Model(&books).\n\t\t\t\tColumn(\"book.id\").\n\t\t\t\tRelation(\"Author\").\n\t\t\t\tRelation(\"Editor\").\n\t\t\t\tRelation(\"Translations\").\n\t\t\t\tRelation(\"Genres\").\n\t\t\t\tOrderExpr(\"book.id ASC\").\n\t\t\t\tSelect()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(books).To(HaveLen(3))\n\t\t})\n\n\t\tIt(\"fetches Genre relations\", func() {\n\t\t\tvar genres []*Genre\n\t\t\terr := db.Model(&genres).\n\t\t\t\tColumn(\"genre.*\").\n\t\t\t\tRelation(\"Subgenres\").\n\t\t\t\tRelation(\"Books.id\").\n\t\t\t\tRelation(\"Books.Translations\").\n\t\t\t\tWhere(\"genre.parent_id IS NULL\").\n\t\t\t\tOrderExpr(\"genre.id\").\n\t\t\t\tSelect()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(genres).To(HaveLen(2))\n\t\t})\n\n\t\tIt(\"fetches Translation relations\", func() {\n\t\t\tvar translations []*Translation\n\t\t\terr := db.Model(&translations).\n\t\t\t\tColumn(\"tr.*\").\n\t\t\t\tRelation(\"Book.id\").\n\t\t\t\tRelation(\"Book.Author\").\n\t\t\t\tRelation(\"Book.Editor\").\n\t\t\t\tSelect()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(translations).To(HaveLen(3))\n\t\t})\n\n\t\tIt(\"works when there are no results\", func() {\n\t\t\tvar books []*Book\n\t\t\terr := db.Model(&books).\n\t\t\t\tColumn(\"book.*\").\n\t\t\t\tRelation(\"Author\").\n\t\t\t\tRelation(\"Genres\").\n\t\t\t\tRelation(\"Comments\").\n\t\t\t\tWhere(\"1 = 2\").\n\t\t\t\tSelect()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(books).To(BeNil())\n\t\t})\n\n\t\tIt(\"supports overriding\", func() {\n\t\t\tvar books []*BookWithCommentCount\n\t\t\terr := db.Model(&books).\n\t\t\t\tColumn(\"book.id\").\n\t\t\t\tRelation(\"Author\").\n\t\t\t\tColumnExpr(`(SELECT COUNT(*) FROM comments WHERE trackable_type = 'Book' AND trackable_id = book.id) AS comment_count`).\n\t\t\t\tOrderExpr(\"id ASC\").\n\t\t\t\tSelect()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(books).To(HaveLen(3))\n\t\t})\n\t})\n\n\tDescribe(\"bulk insert\", func() {\n\t\tIt(\"returns an error if there is no data\", func() {\n\t\t\tvar books []Book\n\t\t\t_, err := db.Model(&books).Insert()\n\t\t\tExpect(err).To(MatchError(\"pg: can't bulk-insert empty slice []pg_test.Book\"))\n\t\t})\n\n\t\tIt(\"inserts books\", func() {\n\t\t\tbooks := []Image{{\n\t\t\t\tID:   111,\n\t\t\t\tPath: \"111.jpg\",\n\t\t\t}, {\n\t\t\t\tID:   222,\n\t\t\t\tPath: \"222.jpg\",\n\t\t\t}}\n\t\t\t_, err := db.Model(&books).Insert()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(len(books)).NotTo(BeZero())\n\t\t})\n\t})\n\n\tDescribe(\"bulk update\", func() {\n\t\tIt(\"returns an error if there is no data\", func() {\n\t\t\tvar books []Book\n\t\t\t_, err := db.Model(&books).Update()\n\t\t\tExpect(err).To(MatchError(\"pg: can't bulk-update empty slice []pg_test.Book\"))\n\t\t})\n\n\t\tIt(\"updates books using Set\", func() {\n\t\t\tvar books []Book\n\t\t\terr := db.Model(&books).Order(\"id\").Select()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tfor i := range books {\n\t\t\t\tbooks[i].Title = fmt.Sprintf(\"censored %d\", i)\n\t\t\t}\n\n\t\t\t_, err = db.Model(&books).Set(\"title = ?title\").Update()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(len(books)).NotTo(BeZero())\n\n\t\t\tbooks = nil\n\t\t\terr = db.Model(&books).Order(\"id\").Select()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tfor i := range books {\n\t\t\t\tExpect(books[i].Title).To(Equal(fmt.Sprintf(\"censored %d\", i)))\n\t\t\t}\n\t\t})\n\n\t\tIt(\"updates books using Set expression\", func() {\n\t\t\tbooks := []Book{{\n\t\t\t\tID:    100,\n\t\t\t\tTitle: \" suffix\",\n\t\t\t}, {\n\t\t\t\tID: 101,\n\t\t\t}}\n\t\t\tres, err := db.Model(&books).\n\t\t\t\tSet(\"title = book.title || COALESCE(_data.title, '')\").\n\t\t\t\tUpdate()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res.RowsAffected()).To(Equal(2))\n\t\t\tExpect(len(books)).NotTo(BeZero())\n\n\t\t\tbooks = nil\n\t\t\terr = db.Model(&books).Column(\"id\", \"title\").Order(\"id\").Select()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(books).To(Equal([]Book{{\n\t\t\t\tID:    100,\n\t\t\t\tTitle: \"book 1 suffix\",\n\t\t\t}, {\n\t\t\t\tID:    101,\n\t\t\t\tTitle: \"book 2\",\n\t\t\t}, {\n\t\t\t\tID:    102,\n\t\t\t\tTitle: \"book 3\",\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"updates books using Column\", func() {\n\t\t\tvar books []Book\n\t\t\terr := db.Model(&books).Order(\"id\").Select()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tfor i := range books {\n\t\t\t\tbooks[i].Title = fmt.Sprintf(\"censored %d\", i)\n\t\t\t}\n\n\t\t\t_, err = db.Model(&books).Column(\"title\").Update()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(len(books)).NotTo(BeZero())\n\n\t\t\tbooks = nil\n\t\t\terr = db.Model(&books).Order(\"id\").Select()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tfor i := range books {\n\t\t\t\tExpect(books[i].Title).To(Equal(fmt.Sprintf(\"censored %d\", i)))\n\t\t\t}\n\t\t})\n\t})\n\n\tDescribe(\"bulk delete\", func() {\n\t\tIt(\"returns an error when slice is empty\", func() {\n\t\t\tvar books []Book\n\t\t\t_, err := db.Model(&books).Delete()\n\t\t\tExpect(err).To(MatchError(\"pg: Update and Delete queries require Where clause (try WherePK)\"))\n\t\t})\n\n\t\tIt(\"deletes books\", func() {\n\t\t\tvar books []Book\n\t\t\terr := db.Model(&books).Order(\"id\").Select()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tres, err := db.Model(&books).Delete()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res.RowsAffected()).To(Equal(3))\n\n\t\t\tbooks = make([]Book, 0)\n\t\t\tn, err := db.Model(&books).Count()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(0))\n\t\t})\n\n\t\tIt(\"deletes ptrs of books\", func() {\n\t\t\tvar books []*Book\n\t\t\terr := db.Model(&books).Order(\"id\").Select()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tres, err := db.Model(&books).Delete()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res.RowsAffected()).To(Equal(3))\n\n\t\t\tbooks = make([]*Book, 0)\n\t\t\tn, err := db.Model(&books).Count()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(0))\n\t\t})\n\t})\n\n\tIt(\"filters by HasOne\", func() {\n\t\tvar books []Book\n\t\terr := db.Model(&books).\n\t\t\tColumn(\"book.id\").\n\t\t\tRelation(\"Author._\").\n\t\t\tWhere(\"author.id = 10\").\n\t\t\tOrderExpr(\"book.id ASC\").\n\t\t\tSelect()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(books).To(Equal([]Book{{\n\t\t\tID: 100,\n\t\t}, {\n\t\t\tID: 101,\n\t\t}}))\n\t})\n\n\tIt(\"supports filtering HasMany\", func() {\n\t\tvar book Book\n\t\terr := db.Model(&book).\n\t\t\tColumn(\"book.id\").\n\t\t\tRelation(\"Translations\", func(q *pg.Query) (*pg.Query, error) {\n\t\t\t\treturn q.Where(\"lang = 'ru'\"), nil\n\t\t\t}).\n\t\t\tFirst()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(book).To(Equal(Book{\n\t\t\tID: 100,\n\t\t\tTranslations: []Translation{\n\t\t\t\t{ID: 1000, BookID: 100, Lang: \"ru\"},\n\t\t\t},\n\t\t}))\n\t})\n\n\tIt(\"supports filtering HasMany2Many\", func() {\n\t\tvar book Book\n\t\terr := db.Model(&book).\n\t\t\tColumn(\"book.id\").\n\t\t\tRelation(\"Genres\", func(q *pg.Query) (*pg.Query, error) {\n\t\t\t\treturn q.Where(\"genre__rating > 999\"), nil\n\t\t\t}).\n\t\t\tFirst()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(book).To(Equal(Book{\n\t\t\tID: 100,\n\t\t\tGenres: []Genre{\n\t\t\t\t{ID: 2, Name: \"genre 2\", Rating: 9999},\n\t\t\t},\n\t\t}))\n\t})\n\n\tIt(\"deletes book returning title\", func() {\n\t\tbook := &Book{\n\t\t\tID: 100,\n\t\t}\n\t\tres, err := db.Model(book).WherePK().Returning(\"title\").Delete()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.RowsAffected()).To(Equal(1))\n\t\tExpect(book).To(Equal(&Book{\n\t\t\tID:    100,\n\t\t\tTitle: \"book 1\",\n\t\t}))\n\t})\n\n\tIt(\"deletes books returning id\", func() {\n\t\tvar ids []int\n\t\tres, err := db.Model((*Book)(nil)).Where(\"TRUE\").Returning(\"id\").Delete(&ids)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.RowsAffected()).To(Equal(3))\n\t\tExpect(ids).To(Equal([]int{100, 101, 102}))\n\t})\n\n\tIt(\"supports Exec & Query\", func() {\n\t\t_, err := db.Model((*Book)(nil)).Exec(\"DROP TABLE ?TableName CASCADE\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tvar num int\n\t\t_, err = db.Model(&Book{}).QueryOne(pg.Scan(&num), \"SELECT 1 FROM ?TableName\")\n\t\tExpect(err).To(MatchError(`ERROR #42P01 relation \"books\" does not exist`))\n\t})\n\n\tIt(\"does not create zero model for null relation\", func() {\n\t\tnewBook := &Book{Title: \"new\"}\n\t\t_, err := db.Model(newBook).Insert()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tbook := new(Book)\n\t\terr = db.Model(book).\n\t\t\tRelation(\"Editor\").\n\t\t\tWhere(\"book.id = ?\", newBook.ID).\n\t\t\tSelect()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(book.Editor).To(BeNil())\n\n\t\tbook = new(Book)\n\t\terr = db.Model(book).\n\t\t\tRelation(\"Editor\").\n\t\t\tWhere(\"book.id = ?\", newBook.ID).\n\t\t\tSelect(book)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(book.Editor).To(BeNil())\n\t})\n\n\tDescribe(\"ForEach\", func() {\n\t\tIt(\"works with a struct ptr\", func() {\n\t\t\tq := db.Model((*Book)(nil)).\n\t\t\t\tOrder(\"id ASC\")\n\n\t\t\tvar books []Book\n\t\t\terr := q.Select(&books)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvar count int\n\t\t\terr = q.ForEach(func(b *Book) error {\n\t\t\t\tbook := &books[count]\n\t\t\t\tExpect(book).To(Equal(b))\n\t\t\t\tcount++\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(count).To(Equal(3))\n\t\t})\n\n\t\tIt(\"works with a struct\", func() {\n\t\t\tq := db.Model((*Book)(nil)).\n\t\t\t\tOrder(\"id ASC\")\n\n\t\t\tvar books []Book\n\t\t\terr := q.Select(&books)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvar count int\n\t\t\terr = q.ForEach(func(b Book) error {\n\t\t\t\tbook := &books[count]\n\t\t\t\tExpect(book).To(Equal(&b))\n\t\t\t\tcount++\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(count).To(Equal(3))\n\t\t})\n\n\t\tIt(\"works with a model\", func() {\n\t\t\tq := db.Model((*Book)(nil)).\n\t\t\t\tOrder(\"id ASC\")\n\n\t\t\tvar count int\n\t\t\terr := q.ForEach(func(_ orm.Discard) error {\n\t\t\t\tcount++\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(count).To(Equal(3))\n\t\t})\n\n\t\tIt(\"works with scalars\", func() {\n\t\t\tq := db.Model((*Book)(nil)).\n\t\t\t\tColumnExpr(\"id, title\").\n\t\t\t\tOrder(\"id ASC\")\n\n\t\t\tvar books []Book\n\t\t\terr := q.Select(&books)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvar count int\n\t\t\terr = q.ForEach(func(id int, title string) error {\n\t\t\t\tbook := &books[count]\n\t\t\t\tExpect(id).To(Equal(book.ID))\n\t\t\t\tExpect(title).To(Equal(book.Title))\n\t\t\t\tcount++\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(count).To(Equal(3))\n\t\t})\n\t})\n\n\tDescribe(\"SelectAndCount\", func() {\n\t\tIt(\"selects and counts books\", func() {\n\t\t\tvar books []Book\n\t\t\tcount, err := db.Model(&books).SelectAndCount()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(count).To(Equal(3))\n\t\t\tExpect(books).To(HaveLen(3))\n\t\t})\n\n\t\tIt(\"works with Limit=-1\", func() {\n\t\t\tvar books []Book\n\t\t\tcount, err := db.Model(&books).Limit(-1).SelectAndCount()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(count).To(Equal(3))\n\t\t\tExpect(books).To(HaveLen(0))\n\t\t})\n\t})\n\n\tDescribe(\"Exists\", func() {\n\t\tIt(\"returns true for existing rows\", func() {\n\t\t\tvar books []Book\n\t\t\texists, err := db.Model(&books).Exists()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(exists).To(Equal(true))\n\t\t\tExpect(books).To(HaveLen(0))\n\t\t})\n\n\t\tIt(\"returns false otherwise\", func() {\n\t\t\tvar books []Book\n\t\t\texists, err := db.Model(&books).Where(\"id = 0\").Exists()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(exists).To(Equal(false))\n\t\t\tExpect(books).To(HaveLen(0))\n\t\t})\n\t})\n})\n\ntype SoftDeleteWithTimeModel struct {\n\tID        int\n\tDeletedAt time.Time `pg:\",soft_delete\"`\n}\n\nvar _ = Describe(\"soft delete with time column\", func() {\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\tdb = testDB()\n\n\t\terr := db.Model((*SoftDeleteWithTimeModel)(nil)).CreateTable(&orm.CreateTableOptions{\n\t\t\tTemp: true,\n\t\t})\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\terr := db.Model((*SoftDeleteWithTimeModel)(nil)).DropTable(nil)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tassert := func() {\n\t\tIt(\"soft deletes the model\", func() {\n\t\t\tmodel := new(SoftDeleteWithTimeModel)\n\t\t\terr := db.Model(model).Select()\n\t\t\tExpect(err).To(Equal(pg.ErrNoRows))\n\n\t\t\tn, err := db.Model((*SoftDeleteWithTimeModel)(nil)).Count()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(0))\n\t\t})\n\n\t\tIt(\"Deleted allows to select deleted model\", func() {\n\t\t\tmodel := new(SoftDeleteWithTimeModel)\n\t\t\terr := db.Model(model).Deleted().Select()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(model.ID).To(Equal(1))\n\t\t\tExpect(model.DeletedAt).To(BeTemporally(\"~\", time.Now(), 3*time.Second))\n\n\t\t\tn, err := db.Model((*SoftDeleteWithTimeModel)(nil)).Deleted().Count()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(1))\n\t\t})\n\n\t\tDescribe(\"ForceDelete\", func() {\n\t\t\tBeforeEach(func() {\n\t\t\t\tmodel := &SoftDeleteWithTimeModel{\n\t\t\t\t\tID: 1,\n\t\t\t\t}\n\t\t\t\t_, err := db.Model(model).WherePK().ForceDelete()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t})\n\n\t\t\tIt(\"deletes the model\", func() {\n\t\t\t\tmodel := new(SoftDeleteWithTimeModel)\n\t\t\t\terr := db.Model(model).Deleted().Select()\n\t\t\t\tExpect(err).To(Equal(pg.ErrNoRows))\n\n\t\t\t\tn, err := db.Model((*SoftDeleteWithTimeModel)(nil)).Deleted().Count()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(n).To(Equal(0))\n\t\t\t})\n\t\t})\n\t}\n\n\tDescribe(\"nil model\", func() {\n\t\tBeforeEach(func() {\n\t\t\tmodel := &SoftDeleteWithTimeModel{\n\t\t\t\tID: 1,\n\t\t\t}\n\t\t\t_, err := db.Model(model).Insert()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t_, err = db.Model((*SoftDeleteWithTimeModel)(nil)).Where(\"1 = 1\").Delete()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tassert()\n\t})\n\n\tDescribe(\"model\", func() {\n\t\tBeforeEach(func() {\n\t\t\tmodel := &SoftDeleteWithTimeModel{\n\t\t\t\tID: 1,\n\t\t\t}\n\t\t\t_, err := db.Model(model).Insert()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t_, err = db.Model(model).WherePK().Delete()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(model.DeletedAt).To(BeTemporally(\"~\", time.Now(), time.Second))\n\t\t})\n\n\t\tassert()\n\t})\n})\n\ntype SoftDeleteWithIntModel struct {\n\tID        int\n\tDeletedAt *int64 `pg:\",soft_delete\"`\n}\n\nvar _ = Describe(\"soft delete with int column\", func() {\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\tdb = testDB()\n\n\t\terr := db.Model((*SoftDeleteWithIntModel)(nil)).CreateTable(&orm.CreateTableOptions{\n\t\t\tTemp: true,\n\t\t})\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\terr := db.Model((*SoftDeleteWithIntModel)(nil)).DropTable(nil)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tassert := func() {\n\t\tIt(\"soft deletes the model\", func() {\n\t\t\tmodel := new(SoftDeleteWithIntModel)\n\t\t\terr := db.Model(model).Select()\n\t\t\tExpect(err).To(Equal(pg.ErrNoRows))\n\n\t\t\tn, err := db.Model((*SoftDeleteWithIntModel)(nil)).Count()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(0))\n\t\t})\n\n\t\tIt(\"Deleted allows to select deleted model\", func() {\n\t\t\tmodel := new(SoftDeleteWithIntModel)\n\t\t\terr := db.Model(model).Deleted().Select()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(model.ID).To(Equal(1))\n\t\t\tdeletedTime := time.Unix(0, *model.DeletedAt)\n\t\t\tExpect(deletedTime).To(BeTemporally(\"~\", time.Now(), time.Second))\n\n\t\t\tn, err := db.Model((*SoftDeleteWithIntModel)(nil)).Deleted().Count()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(1))\n\t\t})\n\n\t\tDescribe(\"ForceDelete\", func() {\n\t\t\tBeforeEach(func() {\n\t\t\t\tmodel := &SoftDeleteWithIntModel{\n\t\t\t\t\tID: 1,\n\t\t\t\t}\n\t\t\t\t_, err := db.Model(model).WherePK().ForceDelete()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t})\n\n\t\t\tIt(\"deletes the model\", func() {\n\t\t\t\tmodel := new(SoftDeleteWithIntModel)\n\t\t\t\terr := db.Model(model).Deleted().Select()\n\t\t\t\tExpect(err).To(Equal(pg.ErrNoRows))\n\n\t\t\t\tn, err := db.Model((*SoftDeleteWithIntModel)(nil)).Deleted().Count()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(n).To(Equal(0))\n\t\t\t})\n\t\t})\n\t}\n\n\tDescribe(\"nil model\", func() {\n\t\tBeforeEach(func() {\n\t\t\tmodel := &SoftDeleteWithIntModel{\n\t\t\t\tID: 1,\n\t\t\t}\n\t\t\t_, err := db.Model(model).Insert()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t_, err = db.Model((*SoftDeleteWithIntModel)(nil)).Where(\"1 = 1\").Delete()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tassert()\n\t})\n\n\tDescribe(\"model\", func() {\n\t\tBeforeEach(func() {\n\t\t\tmodel := &SoftDeleteWithIntModel{\n\t\t\t\tID: 1,\n\t\t\t}\n\t\t\t_, err := db.Model(model).Insert()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t_, err = db.Model(model).WherePK().Delete()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tdeletedTime := time.Unix(0, *model.DeletedAt)\n\t\t\tExpect(deletedTime).To(BeTemporally(\"~\", time.Now(), time.Second))\n\t\t})\n\n\t\tassert()\n\t})\n})\n\ntype Recipe struct {\n\ttableName   struct{} `pg:\"?tenant.recipes\"`\n\tId          int\n\tIngredients []*Ingredient `pg:\"many2many:?tenant.ingredients_recipes\"`\n}\n\ntype Ingredient struct {\n\ttableName struct{} `pg:\"?tenant.ingredients\"`\n\tId        int\n\tRecipes   []*Recipe `pg:\"many2many:?tenant.ingredients_recipes\"`\n}\n\ntype IngredientRecipe struct {\n\ttableName    struct{}    `pg:\"?tenant.ingredients_recipes\"`\n\tRecipe       *Recipe     `pg:\"rel:has-one\"`\n\tRecipeId     int         `pg:\",pk\"`\n\tIngredient   *Ingredient `pg:\"rel:has-one\"`\n\tIngredientId int         `pg:\",pk\"`\n}\n\nvar _ = Describe(\"many2many multi-tenant bug\", func() {\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\tdb = testDB().WithParam(\"tenant\", pg.Safe(\"public\"))\n\t\toptions := orm.CreateTableOptions{}\n\n\t\terr := db.Model((*Recipe)(nil)).CreateTable(&options)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\terr = db.Model((*Ingredient)(nil)).CreateTable(&options)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\terr = db.Model((*IngredientRecipe)(nil)).CreateTable(&options)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\terr := db.Model((*Recipe)(nil)).DropTable(nil)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\terr = db.Model((*Ingredient)(nil)).DropTable(nil)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\terr = db.Model((*IngredientRecipe)(nil)).DropTable(nil)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should find the many2many table\", func() {\n\t\trecipe := Recipe{Id: 1}\n\t\tingredient := Ingredient{Id: 1}\n\t\tingredientRecipe := IngredientRecipe{\n\t\t\tRecipeId:     1,\n\t\t\tIngredientId: 1,\n\t\t}\n\n\t\t_, err := db.Model(&recipe).Insert()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t_, err = db.Model(&ingredient).Insert()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t_, err = db.Model(&ingredientRecipe).Insert()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\terr = db.Model(&recipe).WherePK().Relation(\"Ingredients\").Select()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(recipe.Ingredients).To(HaveLen(1))\n\t\tExpect(recipe.Ingredients[0].Id).To(Equal(1))\n\t})\n})\n\nfunc TestColumnReuse(t *testing.T) {\n\tdb := testDB()\n\n\terr := createSchema(db)\n\tpanicIf(err)\n\n\tuser1 := &User{\n\t\tName:   \"admin\",\n\t\tEmails: []string{\"admin1@admin\", \"admin2@admin\"},\n\t}\n\terr = CreateUser(db, user1)\n\tpanicIf(err)\n\n\terr = CreateUser(db, &User{\n\t\tName:   \"root\",\n\t\tEmails: []string{\"root1@root\", \"root2@root\"},\n\t})\n\tpanicIf(err)\n\n\tstory1 := &Story{\n\t\tTitle:    \"Cool story\",\n\t\tAuthorId: user1.Id,\n\t}\n\terr = CreateStory(db, story1)\n\tpanicIf(err)\n\n\tusers := []map[string]interface{}{}\n\tstories := []map[string]interface{}{}\n\n\tctx := context.Background()\n\t_, err = db.QueryContext(ctx, &users, `SELECT * FROM users`)\n\tpanicIf(err)\n\n\t_, err = db.QueryContext(ctx, &stories, `SELECT * FROM stories`)\n\tpanicIf(err)\n\n\tfor _, user := range users {\n\t\tks := []string{}\n\t\tfor k := range user {\n\t\t\tks = append(ks, k)\n\t\t}\n\t\trequire.ElementsMatch(t, []string{\"name\", \"id\", \"emails\"}, ks)\n\t}\n\tfor _, story := range stories {\n\t\tks := []string{}\n\t\tfor k := range story {\n\t\t\tks = append(ks, k)\n\t\t}\n\t\trequire.ElementsMatch(t, []string{\"id\", \"title\", \"author_id\"}, ks)\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.046875,
          "content": "/*\npg provides PostgreSQL client.\n*/\npackage pg\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 1.7353515625,
          "content": "package pg\n\nimport (\n\t\"net\"\n\n\t\"github.com/go-pg/pg/v10/internal\"\n)\n\n// ErrNoRows is returned by QueryOne and ExecOne when query returned zero rows\n// but at least one row is expected.\nvar ErrNoRows = internal.ErrNoRows\n\n// ErrMultiRows is returned by QueryOne and ExecOne when query returned\n// multiple rows but exactly one row is expected.\nvar ErrMultiRows = internal.ErrMultiRows\n\n// Error represents an error returned by PostgreSQL server\n// using PostgreSQL ErrorResponse protocol.\n//\n// https://www.postgresql.org/docs/10/static/protocol-message-formats.html\ntype Error interface {\n\terror\n\n\t// Field returns a string value associated with an error field.\n\t//\n\t// https://www.postgresql.org/docs/10/static/protocol-error-fields.html\n\tField(field byte) string\n\n\t// IntegrityViolation reports whether an error is a part of\n\t// Integrity Constraint Violation class of errors.\n\t//\n\t// https://www.postgresql.org/docs/10/static/errcodes-appendix.html\n\tIntegrityViolation() bool\n}\n\nvar _ Error = (*internal.PGError)(nil)\n\nfunc isBadConn(err error, allowTimeout bool) (bool, string) {\n\tif err == nil {\n\t\treturn false, \"\"\n\t}\n\tif _, ok := err.(internal.Error); ok {\n\t\treturn false, \"\"\n\t}\n\tif pgErr, ok := err.(Error); ok {\n\t\tswitch pgErr.Field('V') {\n\t\tcase \"FATAL\", \"PANIC\":\n\t\t\treturn true, \"\"\n\t\t}\n\t\tswitch pgErr.Field('C') {\n\t\tcase \"25P02\": // current transaction is aborted\n\t\t\treturn true, \"25P02\"\n\t\tcase \"57014\": // canceling statement due to user request\n\t\t\treturn true, \"57014\"\n\t\t}\n\t\treturn false, \"\"\n\t}\n\tif allowTimeout {\n\t\tif netErr, ok := err.(net.Error); ok && netErr.Timeout() {\n\t\t\treturn !netErr.Temporary(), \"\"\n\t\t}\n\t}\n\treturn true, \"\"\n}\n\n//------------------------------------------------------------------------------\n\ntype timeoutError interface {\n\tTimeout() bool\n}\n"
        },
        {
          "name": "example_array_test.go",
          "type": "blob",
          "size": 1.7099609375,
          "content": "package pg_test\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/go-pg/pg/v10\"\n\t\"github.com/go-pg/pg/v10/types\"\n)\n\nfunc ExampleDB_Model_postgresArrayStructTag() {\n\ttype Item struct {\n\t\tId      int64\n\t\tEmails  []string `pg:\",array\"` // marshalled as PostgreSQL array\n\t\tNumbers [][]int  `pg:\",array\"` // marshalled as PostgreSQL array\n\t}\n\n\t_, err := pgdb.Exec(`CREATE TEMP TABLE items (id serial, emails text[], numbers int[][])`)\n\tpanicIf(err)\n\tdefer pgdb.Exec(\"DROP TABLE items\")\n\n\titem1 := &Item{\n\t\tId:      1,\n\t\tEmails:  []string{\"one@example.com\", \"two@example.com\"},\n\t\tNumbers: [][]int{{1, 2}, {3, 4}},\n\t}\n\t_, err = pgdb.Model(item1).Insert()\n\tpanicIf(err)\n\n\titem := new(Item)\n\terr = pgdb.Model(item).Where(\"id = ?\", 1).Select()\n\tpanicIf(err)\n\tfmt.Println(item)\n\t// Output: &{1 [one@example.com two@example.com] [[1 2] [3 4]]}\n}\n\nfunc ExampleArray() {\n\tsrc := []string{\"one@example.com\", \"two@example.com\"}\n\tvar dst []string\n\t_, err := pgdb.QueryOne(pg.Scan(pg.Array(&dst)), `SELECT ?`, pg.Array(src))\n\tpanicIf(err)\n\tfmt.Println(dst)\n\t// Output: [one@example.com two@example.com]\n}\n\ntype MyArrayValueScanner struct {\n\tsum int\n}\n\nvar _ types.ArrayValueScanner = (*MyArrayValueScanner)(nil)\n\nfunc (s *MyArrayValueScanner) BeforeScanArrayValue(rd types.Reader, n int) error {\n\treturn nil\n}\n\nfunc (s *MyArrayValueScanner) ScanArrayValue(rd types.Reader, n int) error {\n\tnum, err := types.ScanInt(rd, n)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.sum += num\n\treturn nil\n}\n\nfunc (s *MyArrayValueScanner) AfterScanArrayValue() error {\n\treturn nil\n}\n\nfunc ExampleDB_arrayValueScanner() {\n\tvar dst MyArrayValueScanner\n\t_, err := pgdb.QueryOne(pg.Scan(pg.Array(&dst)),\n\t\t`SELECT array_agg(id) from generate_series(0, 10) AS id`)\n\tpanicIf(err)\n\tfmt.Println(dst.sum)\n\t// Output: 55\n}\n"
        },
        {
          "name": "example_composite_test.go",
          "type": "blob",
          "size": 1.04296875,
          "content": "package pg_test\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/go-pg/pg/v10/orm\"\n)\n\ntype InventoryItem struct {\n\tName       string\n\tSupplierID int\n\tPrice      float64\n}\n\ntype OnHand struct {\n\ttableName struct{} `pg:\"on_hand\"`\n\n\tItem  InventoryItem `pg:\"composite:inventory_item\"`\n\tCount int\n}\n\nfunc ExampleDB_Model_compositeType() {\n\tdb := connect()\n\tdefer db.Close()\n\n\terr := db.Model((*OnHand)(nil)).DropTable(&orm.DropTableOptions{\n\t\tIfExists: true,\n\t\tCascade:  true,\n\t})\n\tpanicIf(err)\n\n\terr = db.Model((*InventoryItem)(nil)).DropComposite(&orm.DropCompositeOptions{\n\t\tIfExists: true,\n\t})\n\tpanicIf(err)\n\n\terr = db.Model((*InventoryItem)(nil)).CreateComposite(nil)\n\tpanicIf(err)\n\n\terr = db.Model((*OnHand)(nil)).CreateTable(nil)\n\tpanicIf(err)\n\n\t_, err = db.Model(&OnHand{\n\t\tItem: InventoryItem{\n\t\t\tName:       \"fuzzy dice\",\n\t\t\tSupplierID: 42,\n\t\t\tPrice:      1.99,\n\t\t},\n\t\tCount: 1000,\n\t}).Insert()\n\tpanicIf(err)\n\n\tonHand := new(OnHand)\n\terr = db.Model(onHand).Select()\n\tpanicIf(err)\n\n\tfmt.Println(onHand.Item.Name, onHand.Item.Price, onHand.Count)\n\t// Output: fuzzy dice 1.99 1000\n}\n"
        },
        {
          "name": "example_custom_test.go",
          "type": "blob",
          "size": 1.2392578125,
          "content": "package pg_test\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-pg/pg/v10/orm\"\n\t\"github.com/go-pg/pg/v10/types\"\n)\n\nconst pgTimeFormat = \"15:04:05.999999999\"\n\ntype Time struct {\n\ttime.Time\n}\n\nvar _ types.ValueAppender = (*Time)(nil)\n\nfunc (tm Time) AppendValue(b []byte, flags int) ([]byte, error) {\n\tif flags == 1 {\n\t\tb = append(b, '\\'')\n\t}\n\tb = tm.UTC().AppendFormat(b, pgTimeFormat)\n\tif flags == 1 {\n\t\tb = append(b, '\\'')\n\t}\n\treturn b, nil\n}\n\nvar _ types.ValueScanner = (*Time)(nil)\n\nfunc (tm *Time) ScanValue(rd types.Reader, n int) error {\n\tif n <= 0 {\n\t\ttm.Time = time.Time{}\n\t\treturn nil\n\t}\n\n\ttmp, err := rd.ReadFullTemp()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttm.Time, err = time.ParseInLocation(pgTimeFormat, string(tmp), time.UTC)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\ntype Event struct {\n\tId   int\n\tTime Time `pg:\"type:time\"`\n}\n\nfunc ExampleDB_Model_customType() {\n\tdb := connect()\n\tdefer db.Close()\n\n\terr := db.Model((*Event)(nil)).CreateTable(&orm.CreateTableOptions{\n\t\tTemp: true,\n\t})\n\tpanicIf(err)\n\n\t_, err = db.Model(&Event{\n\t\tTime: Time{time.Date(0, 0, 0, 12, 00, 00, 00, time.UTC)}, // noon\n\t}).Insert()\n\tpanicIf(err)\n\n\tevt := new(Event)\n\terr = db.Model(evt).Select()\n\tpanicIf(err)\n\n\tfmt.Println(evt.Time)\n\t// Output: 0000-01-01 12:00:00 +0000 UTC\n}\n"
        },
        {
          "name": "example_db_model_test.go",
          "type": "blob",
          "size": 2.0869140625,
          "content": "package pg_test\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/go-pg/pg/v10\"\n\t\"github.com/go-pg/pg/v10/orm\"\n)\n\ntype User struct {\n\tId     int64\n\tName   string\n\tEmails []string\n}\n\nfunc (u User) String() string {\n\treturn fmt.Sprintf(\"User<%d %s %v>\", u.Id, u.Name, u.Emails)\n}\n\ntype Story struct {\n\tId       int64\n\tTitle    string\n\tAuthorId int64\n\tAuthor   *User `pg:\"rel:has-one\"`\n}\n\nfunc (s Story) String() string {\n\treturn fmt.Sprintf(\"Story<%d %s %s>\", s.Id, s.Title, s.Author)\n}\n\nfunc ExampleDB_Model() {\n\tdb := pg.Connect(&pg.Options{\n\t\tUser:     \"postgres\",\n\t\tPassword: \"postgres\",\n\t})\n\tdefer db.Close()\n\n\terr := createSchema(db)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tuser1 := &User{\n\t\tName:   \"admin\",\n\t\tEmails: []string{\"admin1@admin\", \"admin2@admin\"},\n\t}\n\t_, err = db.Model(user1).Insert()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t_, err = db.Model(&User{\n\t\tName:   \"root\",\n\t\tEmails: []string{\"root1@root\", \"root2@root\"},\n\t}).Insert()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tstory1 := &Story{\n\t\tTitle:    \"Cool story\",\n\t\tAuthorId: user1.Id,\n\t}\n\t_, err = db.Model(story1).Insert()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Select user by primary key.\n\tuser := &User{Id: user1.Id}\n\terr = db.Model(user).WherePK().Select()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Select all users.\n\tvar users []User\n\terr = db.Model(&users).Select()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Select story and associated author in one query.\n\tstory := new(Story)\n\terr = db.Model(story).\n\t\tRelation(\"Author\").\n\t\tWhere(\"story.id = ?\", story1.Id).\n\t\tSelect()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(user)\n\tfmt.Println(users)\n\tfmt.Println(story)\n\t// Output: User<1 admin [admin1@admin admin2@admin]>\n\t// [User<1 admin [admin1@admin admin2@admin]> User<2 root [root1@root root2@root]>]\n\t// Story<1 Cool story User<1 admin [admin1@admin admin2@admin]>>\n}\n\n// createSchema creates database schema for User and Story models.\nfunc createSchema(db *pg.DB) error {\n\tmodels := []interface{}{\n\t\t(*User)(nil),\n\t\t(*Story)(nil),\n\t}\n\n\tfor _, model := range models {\n\t\terr := db.Model(model).CreateTable(&orm.CreateTableOptions{\n\t\t\tTemp: true,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "example_db_query_test.go",
          "type": "blob",
          "size": 2.1259765625,
          "content": "package pg_test\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/go-pg/pg/v10\"\n)\n\nfunc CreateUser(db *pg.DB, user *User) error {\n\t_, err := db.QueryOne(user, `\n\t\tINSERT INTO users (name, emails) VALUES (?name, ?emails)\n\t\tRETURNING id\n\t`, user)\n\treturn err\n}\n\nfunc GetUser(db *pg.DB, id int64) (*User, error) {\n\tvar user User\n\t_, err := db.QueryOne(&user, `SELECT * FROM users WHERE id = ?`, id)\n\treturn &user, err\n}\n\nfunc GetUsers(db *pg.DB) ([]User, error) {\n\tvar users []User\n\t_, err := db.Query(&users, `SELECT * FROM users`)\n\treturn users, err\n}\n\nfunc GetUsersByIds(db *pg.DB, ids []int64) ([]User, error) {\n\tvar users []User\n\t_, err := db.Query(&users, `SELECT * FROM users WHERE id IN (?)`, pg.In(ids))\n\treturn users, err\n}\n\nfunc CreateStory(db *pg.DB, story *Story) error {\n\t_, err := db.QueryOne(story, `\n\t\tINSERT INTO stories (title, author_id) VALUES (?title, ?author_id)\n\t\tRETURNING id\n\t`, story)\n\treturn err\n}\n\n// GetStory returns story with associated author.\nfunc GetStory(db *pg.DB, id int64) (*Story, error) {\n\tvar story Story\n\t_, err := db.QueryOne(&story, `\n\t\tSELECT s.*,\n\t\t\tu.id AS author__id, u.name AS author__name, u.emails AS author__emails\n\t\tFROM stories AS s, users AS u\n\t\tWHERE s.id = ? AND u.id = s.author_id\n\t`, id)\n\treturn &story, err\n}\n\nfunc ExampleDB_Query() {\n\tdb := pg.Connect(&pg.Options{\n\t\tUser:     \"postgres\",\n\t\tPassword: \"postgres\",\n\t})\n\n\terr := createSchema(db)\n\tpanicIf(err)\n\n\tuser1 := &User{\n\t\tName:   \"admin\",\n\t\tEmails: []string{\"admin1@admin\", \"admin2@admin\"},\n\t}\n\terr = CreateUser(db, user1)\n\tpanicIf(err)\n\n\terr = CreateUser(db, &User{\n\t\tName:   \"root\",\n\t\tEmails: []string{\"root1@root\", \"root2@root\"},\n\t})\n\tpanicIf(err)\n\n\tstory1 := &Story{\n\t\tTitle:    \"Cool story\",\n\t\tAuthorId: user1.Id,\n\t}\n\terr = CreateStory(db, story1)\n\tpanicIf(err)\n\n\tuser, err := GetUser(db, user1.Id)\n\tpanicIf(err)\n\n\tusers, err := GetUsers(db)\n\tpanicIf(err)\n\n\tstory, err := GetStory(db, story1.Id)\n\tpanicIf(err)\n\n\tfmt.Println(user)\n\tfmt.Println(users)\n\tfmt.Println(story)\n\t// Output: User<1 admin [admin1@admin admin2@admin]>\n\t// [User<1 admin [admin1@admin admin2@admin]> User<2 root [root1@root root2@root]>]\n\t// Story<1 Cool story User<1 admin [admin1@admin admin2@admin]>>\n}\n"
        },
        {
          "name": "example_hstore_test.go",
          "type": "blob",
          "size": 0.90234375,
          "content": "package pg_test\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/go-pg/pg/v10\"\n)\n\nfunc ExampleDB_Model_hstoreStructTag() {\n\ttype Item struct {\n\t\tId    int64\n\t\tAttrs map[string]string `pg:\",hstore\"` // marshalled as PostgreSQL hstore\n\t}\n\n\t_, err := pgdb.Exec(`CREATE TEMP TABLE items (id serial, attrs hstore)`)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer pgdb.Exec(\"DROP TABLE items\")\n\n\titem1 := Item{\n\t\tId:    1,\n\t\tAttrs: map[string]string{\"hello\": \"world\"},\n\t}\n\t_, err = pgdb.Model(&item1).Insert()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar item Item\n\terr = pgdb.Model(&item).Where(\"id = ?\", 1).Select()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(item)\n\t// Output: {1 map[hello:world]}\n}\n\nfunc ExampleHstore() {\n\tsrc := map[string]string{\"hello\": \"world\"}\n\tvar dst map[string]string\n\t_, err := pgdb.QueryOne(pg.Scan(pg.Hstore(&dst)), `SELECT ?`, pg.Hstore(src))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(dst)\n\t// Output: map[hello:world]\n}\n"
        },
        {
          "name": "example_many2many_self_test.go",
          "type": "blob",
          "size": 1.630859375,
          "content": "package pg_test\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/go-pg/pg/v10\"\n\t\"github.com/go-pg/pg/v10/orm\"\n)\n\nfunc init() {\n\t// Register many to many model so ORM can better recognize m2m relation.\n\t// This should be done before dependant models are used.\n\torm.RegisterTable((*ElemToElem)(nil))\n}\n\ntype Elem struct {\n\tId    int\n\tElems []Elem `pg:\"many2many:elem_to_elems,join_fk:sub_id\"`\n}\n\ntype ElemToElem struct {\n\tElemId int\n\tSubId  int\n}\n\nfunc createManyToManySefTables(db *pg.DB) error {\n\tmodels := []interface{}{\n\t\t(*Elem)(nil),\n\t\t(*ElemToElem)(nil),\n\t}\n\tfor _, model := range models {\n\t\terr := db.Model(model).CreateTable(&orm.CreateTableOptions{\n\t\t\tTemp: true,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc ExampleDB_Model_manyToManySelf() {\n\tdb := connect()\n\tdefer db.Close()\n\n\tif err := createManyToManySefTables(db); err != nil {\n\t\tpanic(err)\n\t}\n\n\tvalues := []interface{}{\n\t\t&Elem{Id: 1},\n\t\t&Elem{Id: 2},\n\t\t&Elem{Id: 3},\n\t\t&ElemToElem{ElemId: 1, SubId: 2},\n\t\t&ElemToElem{ElemId: 1, SubId: 3},\n\t}\n\tfor _, v := range values {\n\t\t_, err := db.Model(v).Insert()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\t// Select elem and all subelems with following queries:\n\t//\n\t// SELECT \"elem\".\"id\" FROM \"elems\" AS \"elem\" ORDER BY \"elem\".\"id\" LIMIT 1\n\t//\n\t// SELECT elem_to_elems.*, \"elem\".\"id\" FROM \"elems\" AS \"elem\"\n\t// JOIN elem_to_elems AS elem_to_elems ON (elem_to_elems.\"elem_id\") IN (1)\n\t// WHERE (\"elem\".\"id\" = elem_to_elems.\"sub_id\")\n\n\telem := new(Elem)\n\terr := db.Model(elem).Relation(\"Elems\").First()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"Elem\", elem.Id)\n\tfmt.Println(\"Subelems\", elem.Elems[0].Id, elem.Elems[1].Id)\n\t// Output: Elem 1\n\t// Subelems 2 3\n}\n"
        },
        {
          "name": "example_many2many_test.go",
          "type": "blob",
          "size": 2.328125,
          "content": "package pg_test\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/go-pg/pg/v10\"\n\t\"github.com/go-pg/pg/v10/orm\"\n)\n\nfunc init() {\n\t// Register many to many model so ORM can better recognize m2m relation.\n\t// This should be done before dependant models are used.\n\torm.RegisterTable((*OrderToItem)(nil))\n}\n\ntype Order struct {\n\tId    int\n\tItems []Item `pg:\"many2many:order_to_items\"`\n}\n\ntype Item struct {\n\tId int\n}\n\ntype OrderToItem struct {\n\tOrderId int\n\tItemId  int\n}\n\nfunc ExampleDB_Model_manyToMany() {\n\tdb := connect()\n\tdefer db.Close()\n\n\tif err := createManyToManyTables(db); err != nil {\n\t\tpanic(err)\n\t}\n\n\tvalues := []interface{}{\n\t\t&Item{Id: 1},\n\t\t&Item{Id: 2},\n\t\t&Order{Id: 1},\n\t\t&OrderToItem{OrderId: 1, ItemId: 1},\n\t\t&OrderToItem{OrderId: 1, ItemId: 2},\n\t}\n\tfor _, v := range values {\n\t\t_, err := db.Model(v).Insert()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\t// Select order and all items with following queries:\n\t//\n\t// SELECT \"order\".\"id\" FROM \"orders\" AS \"order\" ORDER BY \"order\".\"id\" LIMIT 1\n\t//\n\t// SELECT order_to_items.*, \"item\".\"id\" FROM \"items\" AS \"item\"\n\t// JOIN order_to_items AS order_to_items ON (order_to_items.\"order_id\") IN (1)\n\t// WHERE (\"item\".\"id\" = order_to_items.\"item_id\")\n\n\torder := new(Order)\n\terr := db.Model(order).Relation(\"Items\").First()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"Order\", order.Id, \"Items\", order.Items[0].Id, order.Items[1].Id)\n\n\t// Select order and all items sorted by id with following queries:\n\t//\n\t// SELECT \"order\".\"id\" FROM \"orders\" AS \"order\" ORDER BY \"order\".\"id\" LIMIT 1\n\t//\n\t// SELECT order_to_items.*, \"item\".\"id\" FROM \"items\" AS \"item\"\n\t// JOIN order_to_items AS order_to_items ON (order_to_items.\"order_id\") IN (1)\n\t// WHERE (\"item\".\"id\" = order_to_items.\"item_id\")\n\t// ORDER BY item.id DESC\n\n\torder = new(Order)\n\terr = db.Model(order).\n\t\tRelation(\"Items\", func(q *pg.Query) (*pg.Query, error) {\n\t\t\tq = q.OrderExpr(\"item.id DESC\")\n\t\t\treturn q, nil\n\t\t}).\n\t\tFirst()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"Order\", order.Id, \"Items\", order.Items[0].Id, order.Items[1].Id)\n\n\t// Output: Order 1 Items 1 2\n\t// Order 1 Items 2 1\n}\n\nfunc createManyToManyTables(db *pg.DB) error {\n\tmodels := []interface{}{\n\t\t(*Order)(nil),\n\t\t(*Item)(nil),\n\t\t(*OrderToItem)(nil),\n\t}\n\tfor _, model := range models {\n\t\terr := db.Model(model).CreateTable(&orm.CreateTableOptions{\n\t\t\tTemp: true,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "example_model_test.go",
          "type": "blob",
          "size": 21.853515625,
          "content": "package pg_test\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-pg/pg/v10\"\n\t\"github.com/go-pg/pg/v10/orm\"\n)\n\nfunc modelDB() *pg.DB {\n\tdb := pg.Connect(&pg.Options{\n\t\tUser:     \"postgres\",\n\t\tPassword: \"postgres\",\n\t})\n\n\terr := createTestSchema(db)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t_, err = db.Model(&Author{\n\t\tName: \"author 1\",\n\t}).Insert()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tbooks := []Book{{\n\t\tTitle:    \"book 1\",\n\t\tAuthorID: 1,\n\t\tEditorID: 11,\n\t}, {\n\t\tTitle:    \"book 2\",\n\t\tAuthorID: 1,\n\t\tEditorID: 12,\n\t}, {\n\t\tTitle:     \"book 3\",\n\t\tAuthorID:  11,\n\t\tEditorID:  11,\n\t\tCreatedAt: time.Now(),\n\t}}\n\t_, err = db.Model(&books).Insert()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfor i := 0; i < 2; i++ {\n\t\tgenre := Genre{\n\t\t\tName: fmt.Sprintf(\"genre %d\", i+1),\n\t\t}\n\t\t_, err = db.Model(&genre).Insert()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\t_, err = db.Model(&BookGenre{\n\t\t\tBookID:  1,\n\t\t\tGenreID: genre.ID,\n\t\t}).Insert()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\t// For CountEstimate.\n\t_, err = db.Exec(\"VACUUM\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn db\n}\n\nfunc ExampleDB_Model_insert() {\n\tdb := modelDB()\n\n\tbook := &Book{\n\t\tTitle:    \"new book\",\n\t\tAuthorID: 1,\n\t}\n\n\t_, err := db.Model(book).Insert()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(book)\n\t// Output: Book<Id=4 Title=\"new book\">\n\n\t_, err = db.Model(book).WherePK().Delete()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc ExampleDB_Model_bulkInsert() {\n\tdb := modelDB()\n\n\tbook1 := &Book{\n\t\tTitle: \"new book 1\",\n\t}\n\tbook2 := &Book{\n\t\tTitle: \"new book 2\",\n\t}\n\t_, err := db.Model(book1, book2).Insert()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(book1, book2)\n\t// Output: Book<Id=4 Title=\"new book 1\"> Book<Id=5 Title=\"new book 2\">\n\n\tfor _, book := range []*Book{book1, book2} {\n\t\t_, err := db.Model(book).WherePK().Delete()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\nfunc ExampleDB_Model_bulkInsertSlice() {\n\tdb := modelDB()\n\n\tbooks := []Book{{\n\t\tTitle: \"new book 1\",\n\t}, {\n\t\tTitle: \"new book 2\",\n\t}}\n\t_, err := db.Model(&books).Insert()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(books)\n\t// Output: [Book<Id=4 Title=\"new book 1\"> Book<Id=5 Title=\"new book 2\">]\n\n\tfor i := range books {\n\t\t_, err := db.Model(&books[i]).WherePK().Delete()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\nfunc ExampleDB_Model_insertOnConflictDoNothing() {\n\tdb := modelDB()\n\n\tbook := &Book{\n\t\tID:    100,\n\t\tTitle: \"book 100\",\n\t}\n\n\tfor i := 0; i < 2; i++ {\n\t\tres, err := db.Model(book).OnConflict(\"DO NOTHING\").Insert()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif res.RowsAffected() > 0 {\n\t\t\tfmt.Println(\"created\")\n\t\t} else {\n\t\t\tfmt.Println(\"did nothing\")\n\t\t}\n\t}\n\n\t_, err := db.Model(book).WherePK().Delete()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Output: created\n\t// did nothing\n}\n\nfunc ExampleDB_Model_insertOnConflictDoUpdate() {\n\tdb := modelDB()\n\n\tvar book *Book\n\tfor i := 0; i < 2; i++ {\n\t\tbook = &Book{\n\t\t\tID:    100,\n\t\t\tTitle: fmt.Sprintf(\"title version #%d\", i),\n\t\t}\n\t\t_, err := db.Model(book).\n\t\t\tOnConflict(\"(id) DO UPDATE\").\n\t\t\tSet(\"title = EXCLUDED.title\").\n\t\t\tInsert()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\terr = db.Model(book).WherePK().Select()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(book)\n\t}\n\n\t_, err := db.Model(book).WherePK().Delete()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Output: Book<Id=100 Title=\"title version #0\">\n\t// Book<Id=100 Title=\"title version #1\">\n}\n\nfunc ExampleDB_Model_selectOrInsert() {\n\tdb := modelDB()\n\n\tauthor := Author{\n\t\tName: \"R. Scott Bakker\",\n\t}\n\tcreated, err := db.Model(&author).\n\t\tColumn(\"id\").\n\t\tWhere(\"name = ?name\").\n\t\tOnConflict(\"DO NOTHING\"). // OnConflict is optional\n\t\tReturning(\"id\").\n\t\tSelectOrInsert()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(created, author)\n\t// Output: true Author<ID=2 Name=\"R. Scott Bakker\">\n}\n\nfunc ExampleDB_Model_insertDynamicTableName() {\n\ttype NamelessModel struct {\n\t\ttableName struct{} `pg:\"_\"` // \"_\" means no name\n\t\tId        int\n\t}\n\n\tdb := modelDB()\n\n\terr := db.Model((*NamelessModel)(nil)).Table(\"dynamic_name\").CreateTable(nil)\n\tpanicIf(err)\n\n\trow123 := &NamelessModel{\n\t\tId: 123,\n\t}\n\t_, err = db.Model(row123).Table(\"dynamic_name\").Insert()\n\tpanicIf(err)\n\n\trow := new(NamelessModel)\n\terr = db.Model(row).Table(\"dynamic_name\").First()\n\tpanicIf(err)\n\tfmt.Println(\"id is\", row.Id)\n\n\terr = db.Model((*NamelessModel)(nil)).Table(\"dynamic_name\").DropTable(nil)\n\tpanicIf(err)\n\n\t// Output: id is 123\n}\n\nfunc ExampleDB_Model_select() {\n\tdb := modelDB()\n\n\tbook := &Book{\n\t\tID: 1,\n\t}\n\terr := db.Model(book).WherePK().Select()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(book)\n\t// Output: Book<Id=1 Title=\"book 1\">\n}\n\nfunc ExampleDB_Model_selectFirstRow() {\n\tdb := modelDB()\n\n\tvar firstBook Book\n\terr := db.Model(&firstBook).First()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(firstBook)\n\t// Output: Book<Id=1 Title=\"book 1\">\n}\n\nfunc ExampleDB_Model_selectLastRow() {\n\tdb := modelDB()\n\n\tvar lastBook Book\n\terr := db.Model(&lastBook).Last()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(lastBook)\n\t// Output: Book<Id=3 Title=\"book 3\">\n}\n\nfunc ExampleDB_Model_selectAllColumns() {\n\tdb := modelDB()\n\n\tvar book Book\n\terr := db.Model(&book).Column(\"book.*\").First()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(book, book.AuthorID)\n\t// Output: Book<Id=1 Title=\"book 1\"> 1\n}\n\nfunc ExampleDB_Model_selectSomeColumns() {\n\tdb := modelDB()\n\n\tvar book Book\n\terr := db.Model(&book).\n\t\tColumn(\"book.id\", \"book.title\").\n\t\tOrderExpr(\"book.id ASC\").\n\t\tLimit(1).\n\t\tSelect()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(book)\n\t// Output: Book<Id=1 Title=\"book 1\">\n}\n\nfunc ExampleDB_Model_selectSomeColumnsIntoVars() {\n\tdb := modelDB()\n\n\tvar id int\n\tvar title string\n\terr := db.Model(&Book{}).\n\t\tColumn(\"book.id\", \"book.title\").\n\t\tOrderExpr(\"book.id ASC\").\n\t\tLimit(1).\n\t\tSelect(&id, &title)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(id, title)\n\t// Output: 1 book 1\n}\n\nfunc ExampleDB_Model_selectWhereIn() {\n\tdb := modelDB()\n\n\tvar books []Book\n\terr := db.Model(&books).WhereIn(\"id IN (?)\", []int{1, 2}).Select()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(books)\n\t// Output: [Book<Id=1 Title=\"book 1\"> Book<Id=2 Title=\"book 2\">]\n}\n\nfunc ExampleDB_Model_selectWhereGroup() {\n\tdb := modelDB()\n\n\tvar books []Book\n\terr := db.Model(&books).\n\t\tWhereGroup(func(q *pg.Query) (*pg.Query, error) {\n\t\t\tq = q.WhereOr(\"id = 1\").\n\t\t\t\tWhereOr(\"id = 2\")\n\t\t\treturn q, nil\n\t\t}).\n\t\tWhere(\"title IS NOT NULL\").\n\t\tSelect()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(books)\n\t// Output: [Book<Id=1 Title=\"book 1\"> Book<Id=2 Title=\"book 2\">]\n}\n\nfunc ExampleDB_Model_selectSQLExpression() {\n\tdb := modelDB()\n\n\tvar ids []int\n\terr := db.Model(&Book{}).\n\t\tColumnExpr(\"array_agg(book.id)\").\n\t\tSelect(pg.Array(&ids))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(ids)\n\t// Output: [1 2 3]\n}\n\nfunc ExampleDB_Model_selectGroupBy() {\n\tdb := modelDB()\n\n\tvar res []struct {\n\t\tAuthorId  int\n\t\tBookCount int\n\t}\n\n\terr := db.Model(&Book{}).\n\t\tColumn(\"author_id\").\n\t\tColumnExpr(\"count(*) AS book_count\").\n\t\tGroup(\"author_id\").\n\t\tOrderExpr(\"book_count DESC\").\n\t\tSelect(&res)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"len\", len(res))\n\tfmt.Printf(\"author %d has %d books\\n\", res[0].AuthorId, res[0].BookCount)\n\tfmt.Printf(\"author %d has %d books\\n\", res[1].AuthorId, res[1].BookCount)\n\t// Output: len 2\n\t// author 1 has 2 books\n\t// author 11 has 1 books\n}\n\nfunc ExampleDB_Model_selectWith() {\n\tauthorBooks := pgdb.Model(&Book{}).Where(\"author_id = ?\", 1)\n\n\tvar books []Book\n\terr := pgdb.Model().\n\t\tWith(\"author_books\", authorBooks).\n\t\tTable(\"author_books\").\n\t\tSelect(&books)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(books)\n\t// Output: [Book<Id=1 Title=\"book 1\"> Book<Id=2 Title=\"book 2\">]\n}\n\nfunc ExampleDB_Model_selectWrapWith() {\n\t// WITH author_books AS (\n\t//     SELECT * books WHERE author_id = 1\n\t// )\n\t// SELECT * FROM author_books\n\tvar books []Book\n\terr := pgdb.Model(&books).\n\t\tWhere(\"author_id = ?\", 1).\n\t\tWrapWith(\"author_books\").\n\t\tTable(\"author_books\").\n\t\tSelect(&books)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(books)\n\t// Output: [Book<Id=1 Title=\"book 1\"> Book<Id=2 Title=\"book 2\">]\n}\n\nfunc ExampleDB_Model_selectApplyFunc() {\n\tdb := modelDB()\n\n\tvar authorId int\n\tvar editorId int\n\n\tfilter := func(q *pg.Query) (*pg.Query, error) {\n\t\tif authorId != 0 {\n\t\t\tq = q.Where(\"author_id = ?\", authorId)\n\t\t}\n\t\tif editorId != 0 {\n\t\t\tq = q.Where(\"editor_id = ?\", editorId)\n\t\t}\n\t\treturn q, nil\n\t}\n\n\tvar books []Book\n\tauthorId = 1\n\terr := db.Model(&books).\n\t\tApply(filter).\n\t\tSelect()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(books)\n\t// Output: [Book<Id=1 Title=\"book 1\"> Book<Id=2 Title=\"book 2\">]\n}\n\nfunc ExampleDB_Model_count() {\n\tdb := modelDB()\n\n\tcount, err := db.Model(&Book{}).Count()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(count)\n\t// Output: 3\n}\n\nfunc ExampleDB_Model_countEstimate() {\n\tdb := modelDB()\n\n\tcount, err := db.Model(&Book{}).CountEstimate(0)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(count)\n\t// Output: 3\n}\n\nfunc ExampleDB_Model_selectAndCount() {\n\tdb := modelDB()\n\n\tvar books []Book\n\tcount, err := db.Model(&books).OrderExpr(\"id ASC\").Limit(2).SelectAndCount()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(count)\n\tfmt.Println(books)\n\t// Output: 3\n\t// [Book<Id=1 Title=\"book 1\"> Book<Id=2 Title=\"book 2\">]\n}\n\nfunc ExampleDB_Model_exists() {\n\tdb := modelDB()\n\n\tvar books []Book\n\texists, err := db.Model(&books).Where(\"author_id = ?\", 1).Exists()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(exists)\n\t// Output: true\n}\n\nfunc ExampleDB_Model_nullEmptyValue() {\n\ttype Example struct {\n\t\tHello string\n\t}\n\n\tvar str sql.NullString\n\t_, err := pgdb.QueryOne(pg.Scan(&str), \"SELECT ?hello\", &Example{Hello: \"\"})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(str.Valid)\n\t// Output: false\n}\n\nfunc ExampleDB_Model_forEach() {\n\terr := pgdb.Model((*Book)(nil)).\n\t\tOrderExpr(\"id ASC\").\n\t\tForEach(func(b *Book) error {\n\t\t\tfmt.Println(b)\n\t\t\treturn nil\n\t\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// Output: Book<Id=1 Title=\"book 1\">\n\t// Book<Id=2 Title=\"book 2\">\n\t// Book<Id=3 Title=\"book 3\">\n}\n\nfunc ExampleDB_Model_hasOne() {\n\ttype Profile struct {\n\t\tId   int\n\t\tLang string\n\t}\n\n\t// User has one profile.\n\ttype User struct {\n\t\tId        int\n\t\tName      string\n\t\tProfileId int\n\t\tProfile   *Profile `pg:\"rel:has-one\"`\n\t}\n\n\tdb := connect()\n\tdefer db.Close()\n\n\tqs := []string{\n\t\t\"CREATE TEMP TABLE users (id int, name text, profile_id int)\",\n\t\t\"CREATE TEMP TABLE profiles (id int, lang text)\",\n\t\t\"INSERT INTO users VALUES (1, 'user 1', 1), (2, 'user 2', 2)\",\n\t\t\"INSERT INTO profiles VALUES (1, 'en'), (2, 'ru')\",\n\t}\n\tfor _, q := range qs {\n\t\t_, err := db.Exec(q)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\t// Select users joining their profiles with following query:\n\t//\n\t// SELECT\n\t//   \"user\".*,\n\t//   \"profile\".\"id\" AS \"profile__id\",\n\t//   \"profile\".\"lang\" AS \"profile__lang\"\n\t// FROM \"users\" AS \"user\"\n\t// LEFT JOIN \"profiles\" AS \"profile\" ON \"profile\".\"id\" = \"user\".\"profile_id\"\n\n\tvar users []User\n\terr := db.Model(&users).\n\t\tColumn(\"user.*\").\n\t\tRelation(\"Profile\").\n\t\tSelect()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(len(users), \"results\")\n\tfmt.Println(users[0].Id, users[0].Name, users[0].Profile)\n\tfmt.Println(users[1].Id, users[1].Name, users[1].Profile)\n\t// Output: 2 results\n\t// 1 user 1 &{1 en}\n\t// 2 user 2 &{2 ru}\n}\n\nfunc ExampleDB_Model_belongsTo() {\n\t// Profile belongs to User.\n\ttype Profile struct {\n\t\tId     int\n\t\tLang   string\n\t\tUserId int\n\t}\n\n\ttype User struct {\n\t\tId      int\n\t\tName    string\n\t\tProfile *Profile `pg:\"rel:belongs-to\"`\n\t}\n\n\tdb := connect()\n\tdefer db.Close()\n\n\tqs := []string{\n\t\t\"CREATE TEMP TABLE users (id int, name text)\",\n\t\t\"CREATE TEMP TABLE profiles (id int, lang text, user_id int)\",\n\t\t\"INSERT INTO users VALUES (1, 'user 1'), (2, 'user 2')\",\n\t\t\"INSERT INTO profiles VALUES (1, 'en', 1), (2, 'ru', 2)\",\n\t}\n\tfor _, q := range qs {\n\t\t_, err := db.Exec(q)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\t// Select users joining their profiles with following query:\n\t//\n\t// SELECT\n\t//   \"user\".*,\n\t//   \"profile\".\"id\" AS \"profile__id\",\n\t//   \"profile\".\"lang\" AS \"profile__lang\",\n\t//   \"profile\".\"user_id\" AS \"profile__user_id\"\n\t// FROM \"users\" AS \"user\"\n\t// LEFT JOIN \"profiles\" AS \"profile\" ON \"profile\".\"user_id\" = \"user\".\"id\"\n\n\tvar users []User\n\terr := db.Model(&users).\n\t\tColumn(\"user.*\").\n\t\tRelation(\"Profile\").\n\t\tSelect()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(len(users), \"results\")\n\tfmt.Println(users[0].Id, users[0].Name, users[0].Profile)\n\tfmt.Println(users[1].Id, users[1].Name, users[1].Profile)\n\t// Output: 2 results\n\t// 1 user 1 &{1 en 1}\n\t// 2 user 2 &{2 ru 2}\n}\n\nfunc ExampleDB_Model_hasMany() {\n\ttype Profile struct {\n\t\tId     int\n\t\tLang   string\n\t\tActive bool\n\t\tUserId int\n\t}\n\n\t// User has many profiles.\n\ttype User struct {\n\t\tId       int\n\t\tName     string\n\t\tProfiles []*Profile `pg:\"rel:has-many\"`\n\t}\n\n\tdb := connect()\n\tdefer db.Close()\n\n\tqs := []string{\n\t\t\"CREATE TEMP TABLE users (id int, name text)\",\n\t\t\"CREATE TEMP TABLE profiles (id int, lang text, active bool, user_id int)\",\n\t\t\"INSERT INTO users VALUES (1, 'user 1')\",\n\t\t\"INSERT INTO profiles VALUES (1, 'en', TRUE, 1), (2, 'ru', TRUE, 1), (3, 'md', FALSE, 1)\",\n\t}\n\tfor _, q := range qs {\n\t\t_, err := db.Exec(q)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\t// Select user and all his active profiles with following queries:\n\t//\n\t// SELECT \"user\".* FROM \"users\" AS \"user\" ORDER BY \"user\".\"id\" LIMIT 1\n\t//\n\t// SELECT \"profile\".* FROM \"profiles\" AS \"profile\"\n\t// WHERE (active IS TRUE) AND ((\"profile\".\"user_id\") IN ((1)))\n\n\tvar user User\n\terr := db.Model(&user).\n\t\tColumn(\"user.*\").\n\t\tRelation(\"Profiles\", func(q *pg.Query) (*pg.Query, error) {\n\t\t\treturn q.Where(\"active IS TRUE\"), nil\n\t\t}).\n\t\tFirst()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(user.Id, user.Name, user.Profiles[0], user.Profiles[1])\n\t// Output: 1 user 1 &{1 en true 1} &{2 ru true 1}\n}\n\nfunc ExampleDB_Model_hasManySelf() {\n\ttype Item struct {\n\t\tId       int\n\t\tItems    []Item `pg:\"rel:has-many,join_fk:parent_id\"`\n\t\tParentId int\n\t}\n\n\tdb := connect()\n\tdefer db.Close()\n\n\tqs := []string{\n\t\t\"CREATE TEMP TABLE items (id int, parent_id int)\",\n\t\t\"INSERT INTO items VALUES (1, NULL), (2, 1), (3, 1)\",\n\t}\n\tfor _, q := range qs {\n\t\t_, err := db.Exec(q)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\t// Select item and all subitems with following queries:\n\t//\n\t// SELECT \"item\".* FROM \"items\" AS \"item\" ORDER BY \"item\".\"id\" LIMIT 1\n\t//\n\t// SELECT \"item\".* FROM \"items\" AS \"item\" WHERE ((\"item\".\"parent_id\") IN ((1)))\n\n\tvar item Item\n\terr := db.Model(&item).Column(\"item.*\").Relation(\"Items\").First()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"Item\", item.Id)\n\tfmt.Println(\"Subitems\", item.Items[0].Id, item.Items[1].Id)\n\t// Output: Item 1\n\t// Subitems 2 3\n}\n\nfunc ExampleDB_Model_update() {\n\tdb := modelDB()\n\n\tbook := &Book{ID: 1}\n\terr := db.Model(book).WherePK().Select()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tbook.Title = \"updated book 1\"\n\t_, err = db.Model(book).WherePK().Update()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\terr = db.Model(book).WherePK().Select()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(book)\n\t// Output: Book<Id=1 Title=\"updated book 1\">\n}\n\nfunc ExampleDB_Model_updateNotZero() {\n\tdb := modelDB()\n\n\tbook := &Book{\n\t\tID:    1,\n\t\tTitle: \"updated book 1\",\n\t}\n\t_, err := db.Model(book).WherePK().UpdateNotZero()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tbook = new(Book)\n\terr = db.Model(book).Where(\"id = ?\", 1).Select()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(book)\n\t// Output: Book<Id=1 Title=\"updated book 1\">\n}\n\nfunc ExampleDB_Model_updateUseZeroBool() {\n\ttype Event struct {\n\t\tID     int\n\t\tActive bool `pg:\",use_zero\"`\n\t}\n\n\tdb := pg.Connect(pgOptions())\n\tdefer db.Close()\n\n\terr := db.Model((*Event)(nil)).CreateTable(&orm.CreateTableOptions{\n\t\tTemp: true,\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tevent := &Event{\n\t\tID:     1,\n\t\tActive: true,\n\t}\n\t_, err = db.Model(event).Insert()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(event)\n\n\tevent.Active = false\n\t_, err = db.Model(event).WherePK().UpdateNotZero()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tevent2 := new(Event)\n\terr = db.Model(event2).Where(\"id = ?\", 1).Select()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(event2)\n\t// Output: &{1 true}\n\t// &{1 false}\n}\n\nfunc ExampleDB_Model_updateSomeColumns() {\n\tdb := modelDB()\n\n\tbook := Book{\n\t\tID:       1,\n\t\tTitle:    \"updated book 1\", // only this column is going to be updated\n\t\tAuthorID: 2,\n\t}\n\t_, err := db.Model(&book).Column(\"title\").WherePK().Returning(\"*\").Update()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(book, book.AuthorID)\n\t// Output: Book<Id=1 Title=\"updated book 1\"> 1\n}\n\nfunc ExampleDB_Model_updateSomeColumns2() {\n\tdb := modelDB()\n\n\tbook := Book{\n\t\tID:       1,\n\t\tTitle:    \"updated book 1\",\n\t\tAuthorID: 2, // this column will not be updated\n\t}\n\t_, err := db.Model(&book).Set(\"title = ?title\").WherePK().Returning(\"*\").Update()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(book, book.AuthorID)\n\t// Output: Book<Id=1 Title=\"updated book 1\"> 1\n}\n\nfunc ExampleDB_Model_updateSetValues() {\n\tdb := modelDB()\n\n\tvar book Book\n\t_, err := db.Model(&book).\n\t\tSet(\"title = concat(?, title, ?)\", \"prefix \", \" suffix\").\n\t\tWhere(\"id = ?\", 1).\n\t\tReturning(\"*\").\n\t\tUpdate()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(book)\n\t// Output: Book<Id=1 Title=\"prefix book 1 suffix\">\n}\n\nfunc ExampleDB_Model_bulkUpdate() {\n\tdb := modelDB()\n\n\tbook1 := &Book{\n\t\tID:        1,\n\t\tTitle:     \"updated book 1\",\n\t\tUpdatedAt: time.Now(),\n\t}\n\tbook2 := &Book{\n\t\tID:        2,\n\t\tTitle:     \"updated book 2\",\n\t\tUpdatedAt: time.Now(),\n\t}\n\n\t// UPDATE \"books\" AS \"book\"\n\t// SET \"title\" = _data.\"title\"\n\t// FROM (VALUES ('updated book 1', 1), ('updated book 2', 2)) AS _data(\"title\", \"id\")\n\t// WHERE \"book\".\"id\" = _data.\"id\"\n\t_, err := db.Model(book1, book2).Column(\"title\", \"updated_at\").Update()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar books []Book\n\terr = db.Model(&books).Order(\"id\").Select()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(books)\n\t// Output: [Book<Id=1 Title=\"updated book 1\"> Book<Id=2 Title=\"updated book 2\"> Book<Id=3 Title=\"book 3\">]\n}\n\nfunc ExampleDB_Model_bulkUpdateSlice() {\n\tdb := modelDB()\n\n\tbooks := []Book{{\n\t\tID:        1,\n\t\tTitle:     \"updated book 1\",\n\t\tUpdatedAt: time.Now(),\n\t}, {\n\t\tID:        2,\n\t\tTitle:     \"updated book 2\",\n\t\tUpdatedAt: time.Now(),\n\t}}\n\n\t// UPDATE \"books\" AS \"book\"\n\t// SET \"title\" = _data.\"title\"\n\t// FROM (VALUES ('updated book 1', 1), ('updated book 2', 2)) AS _data(\"title\", \"id\")\n\t// WHERE \"book\".\"id\" = _data.\"id\"\n\t_, err := db.Model(&books).Column(\"title\", \"updated_at\").Update()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tbooks = nil\n\terr = db.Model(&books).Order(\"id\").Select()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(books)\n\t// Output: [Book<Id=1 Title=\"updated book 1\"> Book<Id=2 Title=\"updated book 2\"> Book<Id=3 Title=\"book 3\">]\n}\n\nfunc ExampleDB_Model_delete() {\n\tdb := modelDB()\n\n\tbook := &Book{\n\t\tTitle:    \"title 1\",\n\t\tAuthorID: 1,\n\t}\n\t_, err := db.Model(book).Insert()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t_, err = db.Model(book).WherePK().Delete()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\terr = db.Model(book).WherePK().Select()\n\tfmt.Println(err)\n\t// Output: pg: no rows in result set\n}\n\nfunc ExampleDB_Model_deleteMultipleRows() {\n\tdb := modelDB()\n\n\tids := pg.In([]int{1, 2, 3})\n\tres, err := db.Model((*Book)(nil)).Where(\"id IN (?)\", ids).Delete()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"deleted\", res.RowsAffected())\n\n\tcount, err := db.Model((*Book)(nil)).Count()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"left\", count)\n\n\t// Output: deleted 3\n\t// left 0\n}\n\nfunc ExampleDB_Model_bulkDelete() {\n\tdb := modelDB()\n\n\tvar books []Book\n\terr := db.Model(&books).Select()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tres, err := db.Model(&books).Delete()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"deleted\", res.RowsAffected())\n\n\tcount, err := db.Model((*Book)(nil)).Count()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"left\", count)\n\n\t// Output: deleted 3\n\t// left 0\n}\n\nfunc ExampleSafe() {\n\tdb := modelDB()\n\n\tcond := fmt.Sprintf(\"id = %d\", 1)\n\n\tvar book Book\n\terr := db.Model(&book).Where(\"?\", pg.Safe(cond)).Select()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(book)\n\t// Output: Book<Id=1 Title=\"book 1\">\n}\n\nfunc ExampleIdent() {\n\tdb := modelDB()\n\n\tvar book Book\n\terr := db.Model(&book).Where(\"? = 1\", pg.Ident(\"id\")).Select()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(book)\n\t// Output: Book<Id=1 Title=\"book 1\">\n}\n\nfunc ExampleDB_jsonUseNumber() {\n\ttype Event struct {\n\t\tId   int\n\t\tData map[string]interface{} `pg:\",json_use_number\"`\n\t}\n\n\tdb := pg.Connect(pgOptions())\n\tdefer db.Close()\n\n\terr := db.Model((*Event)(nil)).CreateTable(&orm.CreateTableOptions{\n\t\tTemp: true,\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tevent := &Event{\n\t\tData: map[string]interface{}{\n\t\t\t\"price\": 1.23,\n\t\t},\n\t}\n\t_, err = db.Model(event).Insert()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tevent2 := new(Event)\n\terr = db.Model(event2).Where(\"id = ?\", event.Id).Select()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Check that price is decoded as json.Number.\n\tfmt.Printf(\"%T\", event2.Data[\"price\"])\n\t// Output: json.Number\n}\n\nfunc ExampleDB_Model_discardUnknownColumns() {\n\ttype Model1 struct {\n\t}\n\n\tvar model1 Model1\n\t_, err := pgdb.QueryOne(&model1, \"SELECT 1 AS id\")\n\tfmt.Printf(\"Model1: %v\\n\", err)\n\n\ttype Model2 struct {\n\t\ttableName struct{} `pg:\",discard_unknown_columns\"`\n\t}\n\n\tvar model2 Model2\n\t_, err = pgdb.QueryOne(&model2, \"SELECT 1 AS id\")\n\tfmt.Printf(\"Model2: %v\\n\", err)\n\n\t// Output: Model1: pg: can't find column=id in model=Model1 (prefix the column with underscore or use discard_unknown_columns)\n\t// Model2: <nil>\n}\n\nfunc ExampleDB_Model_softDelete() {\n\ttype Flight struct {\n\t\tId        int\n\t\tName      string\n\t\tDeletedAt time.Time `pg:\",soft_delete\"`\n\t}\n\n\terr := pgdb.Model((*Flight)(nil)).CreateTable(&orm.CreateTableOptions{\n\t\tTemp: true,\n\t})\n\tpanicIf(err)\n\n\tflight1 := &Flight{\n\t\tId: 1,\n\t}\n\t_, err = pgdb.Model(flight1).Insert()\n\tpanicIf(err)\n\n\t// Soft delete.\n\t_, err = pgdb.Model(flight1).WherePK().Delete()\n\tpanicIf(err)\n\n\t// Count visible flights.\n\tcount, err := pgdb.Model((*Flight)(nil)).Count()\n\tpanicIf(err)\n\tfmt.Println(\"count\", count)\n\n\t// Count soft deleted flights.\n\tdeletedCount, err := pgdb.Model((*Flight)(nil)).Deleted().Count()\n\tpanicIf(err)\n\tfmt.Println(\"deleted count\", deletedCount)\n\n\t// Actually delete the flight.\n\t_, err = pgdb.Model(flight1).WherePK().ForceDelete()\n\tpanicIf(err)\n\n\t// Count soft deleted flights.\n\tdeletedCount, err = pgdb.Model((*Flight)(nil)).Deleted().Count()\n\tpanicIf(err)\n\tfmt.Println(\"deleted count\", deletedCount)\n\n\t// Output: count 0\n\t// deleted count 1\n\t// deleted count 0\n}\n"
        },
        {
          "name": "example_placeholders_test.go",
          "type": "blob",
          "size": 1.7998046875,
          "content": "package pg_test\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/go-pg/pg/v10\"\n)\n\ntype Params struct {\n\tX int\n\tY int\n}\n\nfunc (p *Params) Sum() int {\n\treturn p.X + p.Y\n}\n\n// go-pg recognizes `?` in queries as placeholders and replaces them\n// with parameters when queries are executed. `?` can be escaped with backslash.\n// Parameters are escaped before replacing according to PostgreSQL rules.\n// Specifically:\n//   - all parameters are properly quoted against SQL injections;\n//   - null byte is removed;\n//   - JSON/JSONB gets `\\u0000` escaped as `\\\\u0000`.\nfunc Example_placeholders() {\n\tvar num int\n\n\t// Simple params.\n\t_, err := pgdb.Query(pg.Scan(&num), \"SELECT ?\", 42)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"simple:\", num)\n\n\t// Indexed params.\n\t_, err = pgdb.Query(pg.Scan(&num), \"SELECT ?0 + ?0\", 1)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"indexed:\", num)\n\n\t// Named params.\n\tparams := &Params{\n\t\tX: 1,\n\t\tY: 1,\n\t}\n\t_, err = pgdb.Query(pg.Scan(&num), \"SELECT ?x + ?y + ?Sum\", params)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"named:\", num)\n\n\t// Global params.\n\t_, err = pgdb.WithParam(\"z\", 1).Query(pg.Scan(&num), \"SELECT ?x + ?y + ?z\", params)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"global:\", num)\n\n\t// Model params.\n\tvar tableName, tableAlias, tableColumns, columns string\n\t_, err = pgdb.Model(&Params{}).Query(\n\t\tpg.Scan(&tableName, &tableAlias, &tableColumns, &columns),\n\t\t\"SELECT '?TableName', '?TableAlias', '?TableColumns', '?Columns'\",\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"table name:\", tableName)\n\tfmt.Println(\"table alias:\", tableAlias)\n\tfmt.Println(\"table columns:\", tableColumns)\n\tfmt.Println(\"columns:\", columns)\n\n\t// Output: simple: 42\n\t// indexed: 2\n\t// named: 4\n\t// global: 3\n\t// table name: \"params\"\n\t// table alias: \"params\"\n\t// table columns: \"params\".\"x\", \"params\".\"y\"\n\t// columns: \"x\", \"y\"\n}\n"
        },
        {
          "name": "example_soft_delete_test.go",
          "type": "blob",
          "size": 1.337890625,
          "content": "package pg_test\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-pg/pg/v10/types\"\n)\n\ntype CustomTime struct {\n\tTime time.Time\n}\n\nvar _ types.ValueScanner = (*CustomTime)(nil)\n\nfunc (tm *CustomTime) ScanValue(rd types.Reader, n int) error {\n\tvar err error\n\ttm.Time, err = types.ScanTime(rd, n)\n\treturn err\n}\n\nvar _ types.ValueAppender = (*CustomTime)(nil)\n\nfunc (tm *CustomTime) AppendValue(b []byte, flags int) ([]byte, error) {\n\treturn types.AppendTime(b, tm.Time, flags), nil\n}\n\ntype Video struct {\n\tId        int\n\tName      string\n\tDeletedAt CustomTime `pg:\",soft_delete\"`\n}\n\nfunc ExampleDB_Model_softDeleteCustom() {\n\tvideo1 := &Video{\n\t\tId: 1,\n\t}\n\t_, err := pgdb.Model(video1).Insert()\n\tpanicIf(err)\n\n\t// Soft delete.\n\t_, err = pgdb.Model(video1).WherePK().Delete()\n\tpanicIf(err)\n\n\t// Count visible videos.\n\tcount, err := pgdb.Model((*Video)(nil)).Count()\n\tpanicIf(err)\n\tfmt.Println(\"count\", count)\n\n\t// Count soft deleted videos.\n\tdeletedCount, err := pgdb.Model((*Video)(nil)).Deleted().Count()\n\tpanicIf(err)\n\tfmt.Println(\"deleted count\", deletedCount)\n\n\t// Actually delete the video.\n\t_, err = pgdb.Model(video1).WherePK().ForceDelete()\n\tpanicIf(err)\n\n\t// Count soft deleted videos.\n\tdeletedCount, err = pgdb.Model((*Video)(nil)).Deleted().Count()\n\tpanicIf(err)\n\tfmt.Println(\"deleted count\", deletedCount)\n\n\t// Output: count 0\n\t// deleted count 1\n\t// deleted count 0\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 6.1923828125,
          "content": "package pg_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/go-pg/pg/v10\"\n\t\"github.com/go-pg/pg/v10/orm\"\n)\n\nvar (\n\tctx  = context.Background()\n\tpgdb *pg.DB\n)\n\nfunc init() {\n\tpgdb = connect()\n\n\terr := pgdb.Model((*Video)(nil)).DropTable(&orm.DropTableOptions{\n\t\tIfExists: true,\n\t\tCascade:  true,\n\t})\n\tpanicIf(err)\n\n\terr = pgdb.Model((*Video)(nil)).CreateTable(&orm.CreateTableOptions{})\n\tpanicIf(err)\n}\n\nfunc connect() *pg.DB {\n\treturn pg.Connect(pgOptions())\n}\n\nfunc panicIf(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc ExampleConnect() {\n\tdb := pg.Connect(&pg.Options{\n\t\tUser:     \"postgres\",\n\t\tPassword: \"postgres\",\n\t\tDatabase: \"postgres\",\n\t})\n\tdefer db.Close()\n\n\tvar n int\n\t_, err := db.QueryOne(pg.Scan(&n), \"SELECT 1\")\n\tpanicIf(err)\n\tfmt.Println(n)\n\t// Output: 1\n}\n\nfunc ExampleDB_QueryOne() {\n\tvar user struct {\n\t\tName string\n\t}\n\n\tres, err := pgdb.QueryOne(&user, `\n        WITH users (name) AS (VALUES (?))\n        SELECT * FROM users\n    `, \"admin\")\n\tpanicIf(err)\n\tfmt.Println(res.RowsAffected())\n\tfmt.Println(user)\n\t// Output: 1\n\t// {admin}\n}\n\nfunc ExampleDB_QueryOne_returning_id() {\n\t_, err := pgdb.Exec(`CREATE TEMP TABLE users(id serial, name varchar(500))`)\n\tpanicIf(err)\n\n\tvar user struct {\n\t\tId   int32\n\t\tName string\n\t}\n\tuser.Name = \"admin\"\n\n\t_, err = pgdb.QueryOne(&user, `\n        INSERT INTO users (name) VALUES (?name) RETURNING id\n    `, &user)\n\tpanicIf(err)\n\tfmt.Println(user)\n\t// Output: {1 admin}\n}\n\nfunc ExampleDB_Exec() {\n\tres, err := pgdb.Exec(`CREATE TEMP TABLE test()`)\n\tpanicIf(err)\n\tfmt.Println(res.RowsAffected())\n\t// Output: -1\n}\n\nfunc ExampleListener() {\n\tln := pgdb.Listen(ctx, \"mychan\")\n\tdefer ln.Close()\n\n\tch := ln.Channel()\n\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond)\n\t\t_, err := pgdb.Exec(\"NOTIFY mychan, ?\", \"hello world\")\n\t\tpanicIf(err)\n\t}()\n\n\tnotif := <-ch\n\tfmt.Println(notif)\n\t// Output: {mychan hello world}\n}\n\nfunc txExample() *pg.DB {\n\tdb := pg.Connect(&pg.Options{\n\t\tUser:     \"postgres\",\n\t\tPassword: \"postgres\",\n\t})\n\n\tqueries := []string{\n\t\t`DROP TABLE IF EXISTS tx_test`,\n\t\t`CREATE TABLE tx_test(counter int)`,\n\t\t`INSERT INTO tx_test (counter) VALUES (0)`,\n\t}\n\tfor _, q := range queries {\n\t\t_, err := db.Exec(q)\n\t\tpanicIf(err)\n\t}\n\n\treturn db\n}\n\nfunc ExampleDB_Begin() {\n\tdb := txExample()\n\n\tincrInTx := func(db *pg.DB) error {\n\t\ttx, err := db.Begin()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Rollback tx on error.\n\t\tdefer tx.Rollback()\n\n\t\tvar counter int\n\t\t_, err = tx.QueryOne(\n\t\t\tpg.Scan(&counter), `SELECT counter FROM tx_test FOR UPDATE`)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tcounter++\n\n\t\t_, err = tx.Exec(`UPDATE tx_test SET counter = ?`, counter)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn tx.Commit()\n\t}\n\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\terr := incrInTx(db)\n\t\t\tpanicIf(err)\n\t\t}()\n\t}\n\twg.Wait()\n\n\tvar counter int\n\t_, err := db.QueryOne(pg.Scan(&counter), `SELECT counter FROM tx_test`)\n\tpanicIf(err)\n\tfmt.Println(counter)\n\t// Output: 10\n}\n\nfunc ExampleDB_RunInTransaction() {\n\tdb := txExample()\n\n\tincrInTx := func(db *pg.DB) error {\n\t\t// Transaction is automatically rolled back on error.\n\t\treturn db.RunInTransaction(ctx, func(tx *pg.Tx) error {\n\t\t\tvar counter int\n\t\t\t_, err := tx.QueryOne(\n\t\t\t\tpg.Scan(&counter), `SELECT counter FROM tx_test FOR UPDATE`)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcounter++\n\n\t\t\t_, err = tx.Exec(`UPDATE tx_test SET counter = ?`, counter)\n\t\t\treturn err\n\t\t})\n\t}\n\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\terr := incrInTx(db)\n\t\t\tpanicIf(err)\n\t\t}()\n\t}\n\twg.Wait()\n\n\tvar counter int\n\t_, err := db.QueryOne(pg.Scan(&counter), `SELECT counter FROM tx_test`)\n\tpanicIf(err)\n\tfmt.Println(counter)\n\t// Output: 10\n}\n\nfunc ExampleDB_Prepare() {\n\tstmt, err := pgdb.Prepare(`SELECT $1::text, $2::text`)\n\tpanicIf(err)\n\n\tvar s1, s2 string\n\t_, err = stmt.QueryOne(pg.Scan(&s1, &s2), \"foo\", \"bar\")\n\tpanicIf(err)\n\tfmt.Println(s1, s2)\n\t// Output: foo bar\n}\n\nfunc ExampleDB_Model_createTable() {\n\ttype Model1 struct {\n\t\tId int\n\t}\n\n\ttype Model2 struct {\n\t\tId   int\n\t\tName string\n\n\t\tModel1Id int     `pg:\"on_delete:RESTRICT,on_update: CASCADE\"`\n\t\tModel1   *Model1 `pg:\"rel:has-one\"`\n\t}\n\n\tfor _, model := range []interface{}{&Model1{}, &Model2{}} {\n\t\terr := pgdb.Model(model).CreateTable(&orm.CreateTableOptions{\n\t\t\tTemp:          true, // create temp table\n\t\t\tFKConstraints: true,\n\t\t})\n\t\tpanicIf(err)\n\t}\n\n\tvar info []struct {\n\t\tColumnName string\n\t\tDataType   string\n\t}\n\t_, err := pgdb.Query(&info, `\n\t\tSELECT column_name, data_type\n\t\tFROM information_schema.columns\n\t\tWHERE table_name = 'model2'\n\t`)\n\tpanicIf(err)\n\tfmt.Println(info)\n\t// Output: [{id bigint} {name text} {model1_id bigint}]\n}\n\nfunc ExampleInts() {\n\tvar nums pg.Ints\n\t_, err := pgdb.Query(&nums, `SELECT generate_series(0, 10)`)\n\tpanicIf(err)\n\tfmt.Println(nums)\n\t// Output: [0 1 2 3 4 5 6 7 8 9 10]\n}\n\nfunc ExampleStrings() {\n\tvar strs pg.Strings\n\t_, err := pgdb.Query(&strs, `\n\t\tWITH users AS (VALUES ('foo'), ('bar')) SELECT * FROM users\n\t`)\n\tpanicIf(err)\n\tfmt.Println(strs)\n\t// Output: [foo bar]\n}\n\nfunc ExampleDB_CopyFrom() {\n\t_, err := pgdb.Exec(`CREATE TEMP TABLE words(word text, len int)`)\n\tpanicIf(err)\n\n\tr := strings.NewReader(\"hello,5\\nfoo,3\\n\")\n\t_, err = pgdb.CopyFrom(r, `COPY words FROM STDIN WITH CSV`)\n\tpanicIf(err)\n\n\tvar buf bytes.Buffer\n\t_, err = pgdb.CopyTo(&buf, `COPY words TO STDOUT WITH CSV`)\n\tpanicIf(err)\n\tfmt.Println(buf.String())\n\t// Output: hello,5\n\t// foo,3\n}\n\nfunc ExampleDB_WithTimeout() {\n\tvar count int\n\t// Use bigger timeout since this query is known to be slow.\n\t_, err := pgdb.WithTimeout(time.Minute).QueryOne(pg.Scan(&count), `\n\t\tSELECT count(*) FROM big_table\n\t`)\n\tpanicIf(err)\n}\n\nfunc ExampleScan() {\n\tvar s1, s2 string\n\t_, err := pgdb.QueryOne(pg.Scan(&s1, &s2), `SELECT ?, ?`, \"foo\", \"bar\")\n\tpanicIf(err)\n\tfmt.Println(s1, s2)\n\t// Output: foo bar\n}\n\nfunc ExampleError() {\n\tvideo := &Video{\n\t\tId: 123,\n\t}\n\t_, err := pgdb.Model(video).Insert()\n\tpanicIf(err)\n\n\t_, err = pgdb.Model(video).Insert()\n\tif err != nil {\n\t\tpgErr, ok := err.(pg.Error)\n\t\tif ok && pgErr.IntegrityViolation() {\n\t\t\tfmt.Println(\"video already exists:\", err)\n\t\t} else if pgErr.Field('S') == \"PANIC\" {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\t// Output: video already exists: ERROR #23505 duplicate key value violates unique constraint \"videos_pkey\"\n}\n"
        },
        {
          "name": "export_test.go",
          "type": "blob",
          "size": 0.1728515625,
          "content": "package pg\n\nimport \"github.com/go-pg/pg/v10/internal/pool\"\n\nfunc (db *DB) Pool() pool.Pooler {\n\treturn db.pool\n}\n\nfunc (ln *Listener) CurrentConn() *pool.Conn {\n\treturn ln.cn\n}\n"
        },
        {
          "name": "extra",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.2890625,
          "content": "module github.com/go-pg/pg/v10\n\ngo 1.19\n\nrequire (\n\tgithub.com/go-pg/zerochecker v0.2.0\n\tgithub.com/jinzhu/inflection v1.0.0\n\tgithub.com/onsi/ginkgo v1.14.2\n\tgithub.com/onsi/gomega v1.10.3\n\tgithub.com/stretchr/testify v1.7.0\n\tgithub.com/tmthrgd/go-hex v0.0.0-20190904060850-447a3041c3bc\n\tgithub.com/vmihailenco/bufpool v0.1.11\n\tgithub.com/vmihailenco/msgpack/v5 v5.3.4\n\tgithub.com/vmihailenco/tagparser v0.1.2\n\tgopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f\n\tmellium.im/sasl v0.3.1\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/fsnotify/fsnotify v1.4.9 // indirect\n\tgithub.com/golang/protobuf v1.5.0 // indirect\n\tgithub.com/kr/text v0.1.0 // indirect\n\tgithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e // indirect\n\tgithub.com/nxadm/tail v1.4.4 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/vmihailenco/tagparser/v2 v2.0.0 // indirect\n\tgolang.org/x/crypto v0.31.0 // indirect\n\tgolang.org/x/net v0.23.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n\tgolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 // indirect\n\tgoogle.golang.org/protobuf v1.33.0 // indirect\n\tgopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 // indirect\n\tgopkg.in/yaml.v2 v2.3.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 10.1513671875,
          "content": "github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/fsnotify/fsnotify v1.4.9 h1:hsms1Qyu0jgnwNXIxa+/V/PDsU6CfLf6CNO8H7IWoS4=\ngithub.com/fsnotify/fsnotify v1.4.9/go.mod h1:znqG4EE+3YCdAaPaxE2ZRY/06pZUdp0tY4IgpuI1SZQ=\ngithub.com/go-pg/zerochecker v0.2.0 h1:pp7f72c3DobMWOb2ErtZsnrPaSvHd2W4o9//8HtF4mU=\ngithub.com/go-pg/zerochecker v0.2.0/go.mod h1:NJZ4wKL0NmTtz0GKCoJ8kym6Xn/EQzXRl2OnAe7MmDo=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=\ngithub.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=\ngithub.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=\ngithub.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=\ngithub.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=\ngithub.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/golang/protobuf v1.5.0 h1:LUVKkCeviFUMKqHa4tXIIij/lbhnMbP7Fn5wKdKkRh4=\ngithub.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=\ngithub.com/jinzhu/inflection v1.0.0 h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=\ngithub.com/jinzhu/inflection v1.0.0/go.mod h1:h+uFLlag+Qp1Va5pdKtLDYj+kHp5pxUVkryuEj+Srlc=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e h1:fD57ERR4JtEqsWbfPhv4DMiApHyliiK5xCTNVSPiaAs=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e/go.mod h1:zD1mROLANZcx1PVRCS0qkT7pwLkGfwJo4zjcN/Tysno=\ngithub.com/nxadm/tail v1.4.4 h1:DQuhQpB1tVlglWS2hLQ5OV6B5r8aGxSrPc5Qo6uTN78=\ngithub.com/nxadm/tail v1.4.4/go.mod h1:kenIhsEOeOJmVchQTgglprH7qJGnHDVpk1VPCcaMI8A=\ngithub.com/onsi/ginkgo v1.6.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo v1.12.1/go.mod h1:zj2OWP4+oCPe1qIXoGWkgMRwljMUYCdkwsT2108oapk=\ngithub.com/onsi/ginkgo v1.14.2 h1:8mVmC9kjFFmA8H4pKMUhcblgifdkOIXPvbhN1T36q1M=\ngithub.com/onsi/ginkgo v1.14.2/go.mod h1:iSB4RoI2tjJc9BBv4NKIKWKya62Rps+oPG/Lv9klQyY=\ngithub.com/onsi/gomega v1.7.1/go.mod h1:XdKZgCCFLUoM/7CFJVPcG8C1xQ1AJ0vpAezJrB7JYyY=\ngithub.com/onsi/gomega v1.10.1/go.mod h1:iN09h71vgCQne3DLsj+A5owkum+a2tYe+TOCB1ybHNo=\ngithub.com/onsi/gomega v1.10.3 h1:gph6h/qe9GSUw1NhH1gp+qb+h8rXD8Cy60Z32Qw3ELA=\ngithub.com/onsi/gomega v1.10.3/go.mod h1:V9xEwhxec5O8UDM77eCW8vLymOMltsqPVYWrpDsH8xc=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/tmthrgd/go-hex v0.0.0-20190904060850-447a3041c3bc h1:9lRDQMhESg+zvGYmW5DyG0UqvY96Bu5QYsTLvCHdrgo=\ngithub.com/tmthrgd/go-hex v0.0.0-20190904060850-447a3041c3bc/go.mod h1:bciPuU6GHm1iF1pBvUfxfsH0Wmnc2VbpgvbI9ZWuIRs=\ngithub.com/vmihailenco/bufpool v0.1.11 h1:gOq2WmBrq0i2yW5QJ16ykccQ4wH9UyEsgLm6czKAd94=\ngithub.com/vmihailenco/bufpool v0.1.11/go.mod h1:AFf/MOy3l2CFTKbxwt0mp2MwnqjNEs5H/UxrkA5jxTQ=\ngithub.com/vmihailenco/msgpack/v5 v5.3.4 h1:qMKAwOV+meBw2Y8k9cVwAy7qErtYCwBzZ2ellBfvnqc=\ngithub.com/vmihailenco/msgpack/v5 v5.3.4/go.mod h1:7xyJ9e+0+9SaZT0Wt1RGleJXzli6Q/V5KbhBonMG9jc=\ngithub.com/vmihailenco/tagparser v0.1.2 h1:gnjoVuB/kljJ5wICEEOpx98oXMWPLj22G67Vbd1qPqc=\ngithub.com/vmihailenco/tagparser v0.1.2/go.mod h1:OeAg3pn3UbLjkWt+rN9oFYB6u/cQgqMEUPoW2WPyhdI=\ngithub.com/vmihailenco/tagparser/v2 v2.0.0 h1:y09buUbR+b5aycVFQs/g70pqKVZNBmxwAhO7/IwNM9g=\ngithub.com/vmihailenco/tagparser/v2 v2.0.0/go.mod h1:Wri+At7QHww0WTrCBeu4J6bNtoV6mEfg5OIWRZA9qds=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20200520004742-59133d7f0dd7/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20201006153459-a7d1128ccaa0/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.23.0 h1:7EYJ93RZ9vYSZAIb2x3lnuvqO5zneoD6IvWjuhfxjTs=\ngolang.org/x/net v0.23.0/go.mod h1:JKghWKKOSdJwpW2GEx0Ja7fmaKnMsbu+MWVZTokSYmg=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190904154756-749cb33beabd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191005200804-aed5e4c7ecf9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191120155948-bd437916bb0e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200519105757-fe76b779f299/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=\ngoogle.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=\ngoogle.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=\ngoogle.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=\ngoogle.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=\ngoogle.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.33.0 h1:uNO2rsAINq/JlFpSdYEKIZ0uKD/R9cpdv0T+yoGwGmI=\ngoogle.golang.org/protobuf v1.33.0/go.mod h1:c6P6GXX6sHbq/GpV6MGZEdwhWPcYBgnhAHhKbcUYpos=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f h1:BLraFXnmrev5lT+xlilqcH8XK9/i0At2xKjWk4p6zsU=\ngopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 h1:uRGJdciOHaEIrze2W8Q3AKkepLTh2hOroT7a+7czfdQ=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.3.0 h1:clyUAQHOM3G0M3f5vQj7LuJrETvjVot3Z5el9nffUtU=\ngopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.0 h1:hjy8E9ON/egN1tAYqKb61G10WtihqetD4sz2H+8nIeA=\ngopkg.in/yaml.v3 v3.0.0/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nmellium.im/sasl v0.3.1 h1:wE0LW6g7U83vhvxjC1IY8DnXM+EU095yeo8XClvCdfo=\nmellium.im/sasl v0.3.1/go.mod h1:xm59PUYpZHhgQ9ZqoJ5QaCqzWMi8IeS49dhp6plPCzw=\n"
        },
        {
          "name": "hook.go",
          "type": "blob",
          "size": 3.1611328125,
          "content": "package pg\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-pg/pg/v10/orm\"\n)\n\ntype (\n\tBeforeScanHook   = orm.BeforeScanHook\n\tAfterScanHook    = orm.AfterScanHook\n\tAfterSelectHook  = orm.AfterSelectHook\n\tBeforeInsertHook = orm.BeforeInsertHook\n\tAfterInsertHook  = orm.AfterInsertHook\n\tBeforeUpdateHook = orm.BeforeUpdateHook\n\tAfterUpdateHook  = orm.AfterUpdateHook\n\tBeforeDeleteHook = orm.BeforeDeleteHook\n\tAfterDeleteHook  = orm.AfterDeleteHook\n)\n\n//------------------------------------------------------------------------------\n\ntype dummyFormatter struct{}\n\nfunc (dummyFormatter) FormatQuery(b []byte, query string, params ...interface{}) []byte {\n\treturn append(b, query...)\n}\n\n// QueryEvent ...\ntype QueryEvent struct {\n\tStartTime  time.Time\n\tDB         orm.DB\n\tModel      interface{}\n\tQuery      interface{}\n\tParams     []interface{}\n\tfmtedQuery []byte\n\tResult     Result\n\tErr        error\n\n\tStash map[interface{}]interface{}\n}\n\n// QueryHook ...\ntype QueryHook interface {\n\tBeforeQuery(context.Context, *QueryEvent) (context.Context, error)\n\tAfterQuery(context.Context, *QueryEvent) error\n}\n\n// UnformattedQuery returns the unformatted query of a query event.\n// The query is only valid until the query Result is returned to the user.\nfunc (e *QueryEvent) UnformattedQuery() ([]byte, error) {\n\treturn queryString(e.Query)\n}\n\nfunc queryString(query interface{}) ([]byte, error) {\n\tswitch query := query.(type) {\n\tcase orm.TemplateAppender:\n\t\treturn query.AppendTemplate(nil)\n\tcase string:\n\t\treturn dummyFormatter{}.FormatQuery(nil, query), nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"pg: can't append %T\", query)\n\t}\n}\n\n// FormattedQuery returns the formatted query of a query event.\n// The query is only valid until the query Result is returned to the user.\nfunc (e *QueryEvent) FormattedQuery() ([]byte, error) {\n\treturn e.fmtedQuery, nil\n}\n\n// AddQueryHook adds a hook into query processing.\nfunc (db *baseDB) AddQueryHook(hook QueryHook) {\n\tdb.queryHooks = append(db.queryHooks, hook)\n}\n\nfunc (db *baseDB) beforeQuery(\n\tctx context.Context,\n\tormDB orm.DB,\n\tmodel, query interface{},\n\tparams []interface{},\n\tfmtedQuery []byte,\n) (context.Context, *QueryEvent, error) {\n\tif len(db.queryHooks) == 0 {\n\t\treturn ctx, nil, nil\n\t}\n\n\tevent := &QueryEvent{\n\t\tStartTime:  time.Now(),\n\t\tDB:         ormDB,\n\t\tModel:      model,\n\t\tQuery:      query,\n\t\tParams:     params,\n\t\tfmtedQuery: fmtedQuery,\n\t}\n\n\tfor i, hook := range db.queryHooks {\n\t\tvar err error\n\t\tctx, err = hook.BeforeQuery(ctx, event)\n\t\tif err != nil {\n\t\t\tif err := db.afterQueryFromIndex(ctx, event, i); err != nil {\n\t\t\t\treturn ctx, nil, err\n\t\t\t}\n\t\t\treturn ctx, nil, err\n\t\t}\n\t}\n\n\treturn ctx, event, nil\n}\n\nfunc (db *baseDB) afterQuery(\n\tctx context.Context,\n\tevent *QueryEvent,\n\tres Result,\n\terr error,\n) error {\n\tif event == nil {\n\t\treturn nil\n\t}\n\n\tevent.Err = err\n\tevent.Result = res\n\treturn db.afterQueryFromIndex(ctx, event, len(db.queryHooks)-1)\n}\n\nfunc (db *baseDB) afterQueryFromIndex(ctx context.Context, event *QueryEvent, hookIndex int) error {\n\tfor ; hookIndex >= 0; hookIndex-- {\n\t\tif err := db.queryHooks[hookIndex].AfterQuery(ctx, event); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc copyQueryHooks(s []QueryHook) []QueryHook {\n\treturn s[:len(s):len(s)]\n}\n"
        },
        {
          "name": "hook_test.go",
          "type": "blob",
          "size": 14.654296875,
          "content": "package pg_test\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"strings\"\n\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"github.com/go-pg/pg/v10\"\n)\n\ntype HookTest struct {\n\tId    int\n\tValue string\n\n\tbeforeScan int\n\tafterScan  int\n\n\tafterSelect int\n\n\tbeforeInsert int\n\tafterInsert  int\n\n\tbeforeUpdate int\n\tafterUpdate  int\n\n\tbeforeDelete int\n\tafterDelete  int\n}\n\nvar _ pg.BeforeScanHook = (*HookTest)(nil)\n\nfunc (t *HookTest) BeforeScan(c context.Context) error {\n\tt.beforeScan++\n\treturn nil\n}\n\nvar _ pg.AfterScanHook = (*HookTest)(nil)\n\nfunc (t *HookTest) AfterScan(c context.Context) error {\n\tt.afterScan++\n\treturn nil\n}\n\nvar _ pg.AfterSelectHook = (*HookTest)(nil)\n\nfunc (t *HookTest) AfterSelect(c context.Context) error {\n\tt.afterSelect++\n\treturn nil\n}\n\nvar _ pg.BeforeInsertHook = (*HookTest)(nil)\n\nfunc (t *HookTest) BeforeInsert(c context.Context) (context.Context, error) {\n\tt.beforeInsert++\n\treturn c, nil\n}\n\nvar _ pg.AfterInsertHook = (*HookTest)(nil)\n\nfunc (t *HookTest) AfterInsert(c context.Context) error {\n\tt.afterInsert++\n\treturn nil\n}\n\nvar _ pg.BeforeUpdateHook = (*HookTest)(nil)\n\nfunc (t *HookTest) BeforeUpdate(c context.Context) (context.Context, error) {\n\tt.beforeUpdate++\n\treturn c, nil\n}\n\nvar _ pg.AfterUpdateHook = (*HookTest)(nil)\n\nfunc (t *HookTest) AfterUpdate(c context.Context) error {\n\tt.afterUpdate++\n\treturn nil\n}\n\nvar _ pg.BeforeDeleteHook = (*HookTest)(nil)\n\nfunc (t *HookTest) BeforeDelete(c context.Context) (context.Context, error) {\n\tt.beforeDelete++\n\treturn c, nil\n}\n\nvar _ pg.AfterDeleteHook = (*HookTest)(nil)\n\nfunc (t *HookTest) AfterDelete(c context.Context) error {\n\tt.afterDelete++\n\treturn nil\n}\n\nvar _ = Describe(\"HookTest\", func() {\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\tdb = pg.Connect(pgOptions())\n\n\t\tqs := []string{\n\t\t\t\"CREATE TEMP TABLE hook_tests (id int, value text)\",\n\t\t\t\"INSERT INTO hook_tests VALUES (1, '')\",\n\t\t}\n\t\tfor _, q := range qs {\n\t\t\t_, err := db.Exec(q)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t}\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"calls AfterSelect for a struct model\", func() {\n\t\tvar hook HookTest\n\t\terr := db.Model(&hook).Select()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(hook).To(Equal(HookTest{\n\t\t\tId:          1,\n\t\t\tbeforeScan:  1,\n\t\t\tafterScan:   1,\n\t\t\tafterSelect: 1,\n\t\t}))\n\t})\n\n\tIt(\"calls AfterSelect for a slice model\", func() {\n\t\tvar hooks []HookTest\n\t\terr := db.Model(&hooks).Select()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(hooks).To(HaveLen(1))\n\t\tExpect(hooks[0]).To(Equal(HookTest{\n\t\t\tId:          1,\n\t\t\tbeforeScan:  1,\n\t\t\tafterScan:   1,\n\t\t\tafterSelect: 1,\n\t\t}))\n\t})\n\n\tIt(\"calls BeforeInsert and AfterInsert\", func() {\n\t\thook := &HookTest{\n\t\t\tId: 1,\n\t\t}\n\t\t_, err := db.Model(hook).Insert()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(hook).To(Equal(&HookTest{\n\t\t\tId:           1,\n\t\t\tbeforeScan:   1,\n\t\t\tafterScan:    1,\n\t\t\tbeforeInsert: 1,\n\t\t\tafterInsert:  1,\n\t\t}))\n\t})\n\n\tIt(\"calls BeforeUpdate and AfterUpdate\", func() {\n\t\thook := &HookTest{\n\t\t\tId: 1,\n\t\t}\n\t\t_, err := db.Model(hook).WherePK().Update()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(hook).To(Equal(&HookTest{\n\t\t\tId:           1,\n\t\t\tbeforeUpdate: 1,\n\t\t\tafterUpdate:  1,\n\t\t}))\n\t})\n\n\tIt(\"does not call BeforeUpdate and AfterUpdate for nil model\", func() {\n\t\t_, err := db.Model((*HookTest)(nil)).\n\t\t\tSet(\"value = 'new'\").\n\t\t\tWhere(\"id = 123\").\n\t\t\tUpdate()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"calls BeforeDelete and AfterDelete\", func() {\n\t\thook := &HookTest{\n\t\t\tId: 1,\n\t\t}\n\t\t_, err := db.Model(hook).WherePK().Delete()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(hook).To(Equal(&HookTest{\n\t\t\tId:           1,\n\t\t\tbeforeDelete: 1,\n\t\t\tafterDelete:  1,\n\t\t}))\n\t})\n\n\tIt(\"does not call BeforeDelete and AfterDelete for nil model\", func() {\n\t\t_, err := db.Model((*HookTest)(nil)).\n\t\t\tWhere(\"id = 123\").\n\t\t\tDelete()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n})\n\ntype queryHookTest struct {\n\tbeforeQueryMethod func(context.Context, *pg.QueryEvent) (context.Context, error)\n\tafterQueryMethod  func(context.Context, *pg.QueryEvent) error\n}\n\nfunc (e queryHookTest) BeforeQuery(c context.Context, evt *pg.QueryEvent) (context.Context, error) {\n\treturn e.beforeQueryMethod(c, evt)\n}\n\nfunc (e queryHookTest) AfterQuery(c context.Context, evt *pg.QueryEvent) error {\n\treturn e.afterQueryMethod(c, evt)\n}\n\nvar _ = Describe(\"BeforeQuery and AfterQuery\", func() {\n\tvar db *pg.DB\n\tvar count int\n\n\tBeforeEach(func() {\n\t\tdb = pg.Connect(pgOptions())\n\t\tcount = 0\n\n\t\tqs := []string{\n\t\t\t\"CREATE TEMP TABLE hook_tests (id int, value text)\",\n\t\t\t\"INSERT INTO hook_tests VALUES (1, '')\",\n\t\t}\n\t\tfor _, q := range qs {\n\t\t\t_, err := db.Exec(q)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t}\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t})\n\n\tDescribe(\"Query/Exec\", func() {\n\t\tbeforeQuery := func(c context.Context, evt *pg.QueryEvent) (context.Context, error) {\n\t\t\tExpect(evt.DB).To(Equal(db))\n\t\t\tExpect(evt.Query).To(Equal(\"SELECT ?\"))\n\t\t\tExpect(evt.Params).To(Equal([]interface{}{1}))\n\t\t\tExpect(evt.Result).To(BeNil())\n\t\t\tExpect(evt.Err).To(BeNil())\n\n\t\t\tq, err := evt.UnformattedQuery()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(string(q)).To(Equal(\"SELECT ?\"))\n\n\t\t\tq, err = evt.FormattedQuery()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(string(q)).To(Equal(\"SELECT 1\"))\n\n\t\t\tevt.Stash = map[interface{}]interface{}{\n\t\t\t\t\"data\": 1,\n\t\t\t}\n\n\t\t\treturn c, nil\n\t\t}\n\n\t\tafterQuery := func(c context.Context, evt *pg.QueryEvent) error {\n\t\t\tExpect(evt.DB).To(Equal(db))\n\t\t\tExpect(evt.Query).To(Equal(\"SELECT ?\"))\n\t\t\tExpect(evt.Params).To(Equal([]interface{}{1}))\n\t\t\tExpect(evt.Result).NotTo(BeNil())\n\t\t\tExpect(evt.Err).NotTo(HaveOccurred())\n\n\t\t\tq, err := evt.UnformattedQuery()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(string(q)).To(Equal(\"SELECT ?\"))\n\n\t\t\tq, err = evt.FormattedQuery()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(string(q)).To(Equal(\"SELECT 1\"))\n\n\t\t\tExpect(evt.Stash[\"data\"]).To(Equal(1))\n\n\t\t\tcount++\n\n\t\t\treturn nil\n\t\t}\n\n\t\tBeforeEach(func() {\n\t\t\thookImpl := struct{ queryHookTest }{}\n\t\t\thookImpl.beforeQueryMethod = beforeQuery\n\t\t\thookImpl.afterQueryMethod = afterQuery\n\t\t\tdb.AddQueryHook(hookImpl)\n\t\t})\n\n\t\tIt(\"is called for Query\", func() {\n\t\t\t_, err := db.Query(pg.Discard, \"SELECT ?\", 1)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(count).To(Equal(1))\n\t\t})\n\n\t\tIt(\"is called for Exec\", func() {\n\t\t\t_, err := db.Exec(\"SELECT ?\", 1)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(count).To(Equal(1))\n\t\t})\n\t})\n\n\tDescribe(\"Model\", func() {\n\t\tbeforeQuery := func(c context.Context, evt *pg.QueryEvent) (context.Context, error) {\n\t\t\tExpect(evt.DB).To(Equal(db))\n\t\t\tExpect(evt.Query).NotTo(BeNil())\n\t\t\tExpect(evt.Params).To(HaveLen(1))\n\t\t\tExpect(evt.Result).To(BeNil())\n\t\t\tExpect(evt.Err).To(BeNil())\n\n\t\t\tq, err := evt.UnformattedQuery()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(string(q)).To(Equal(\"SELECT ?\"))\n\n\t\t\tq, err = evt.FormattedQuery()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(string(q)).To(Equal(\"SELECT 1\"))\n\n\t\t\tevt.Stash = map[interface{}]interface{}{\n\t\t\t\t\"data\": 1,\n\t\t\t}\n\n\t\t\treturn c, nil\n\t\t}\n\n\t\tafterQuery := func(c context.Context, evt *pg.QueryEvent) error {\n\t\t\tExpect(evt.DB).To(Equal(db))\n\t\t\tExpect(evt.Query).NotTo(BeNil())\n\t\t\tExpect(evt.Params).To(HaveLen(1))\n\t\t\tExpect(evt.Result).NotTo(BeNil())\n\t\t\tExpect(evt.Err).NotTo(HaveOccurred())\n\n\t\t\tq, err := evt.UnformattedQuery()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(string(q)).To(Equal(\"SELECT ?\"))\n\n\t\t\tq, err = evt.FormattedQuery()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(string(q)).To(Equal(\"SELECT 1\"))\n\n\t\t\tExpect(evt.Stash[\"data\"]).To(Equal(1))\n\n\t\t\tcount++\n\n\t\t\treturn nil\n\t\t}\n\n\t\tBeforeEach(func() {\n\t\t\thookImpl := struct{ queryHookTest }{}\n\t\t\thookImpl.beforeQueryMethod = beforeQuery\n\t\t\thookImpl.afterQueryMethod = afterQuery\n\t\t\tdb.AddQueryHook(hookImpl)\n\t\t})\n\n\t\tIt(\"is called for Model\", func() {\n\t\t\tvar n int\n\t\t\terr := db.Model().ColumnExpr(\"?\", 1).Select(&n)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(count).To(Equal(1))\n\t\t})\n\t})\n\n\tDescribe(\"model params\", func() {\n\t\tBeforeEach(func() {\n\t\t\thookImpl := struct{ queryHookTest }{}\n\t\t\thookImpl.beforeQueryMethod = func(c context.Context, evt *pg.QueryEvent) (context.Context, error) {\n\t\t\t\treturn c, nil\n\t\t\t}\n\t\t\thookImpl.afterQueryMethod = func(c context.Context, evt *pg.QueryEvent) error {\n\t\t\t\tq, err := evt.FormattedQuery()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(string(q)).To(Equal(`CREATE INDEX stories_author_id_idx ON \"hook_tests\" (author_id)`))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tdb.AddQueryHook(hookImpl)\n\t\t})\n\n\t\tIt(\"is called for Model\", func() {\n\t\t\t_, err := db.Model((*HookTest)(nil)).Exec(\"CREATE INDEX stories_author_id_idx ON ?TableName (author_id)\")\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t})\n\t})\n\n\tDescribe(\"CopyTo\", func() {\n\t\tIt(\"is called for CopyTo with model\", func() {\n\t\t\thookImpl := struct{ queryHookTest }{}\n\t\t\thookImpl.beforeQueryMethod = func(c context.Context, evt *pg.QueryEvent) (context.Context, error) {\n\t\t\t\tExpect(evt.DB).To(Equal(db))\n\t\t\t\tExpect(evt.Query).To(Equal(`COPY ?TableName TO STDOUT CSV`))\n\t\t\t\tExpect(evt.Model).NotTo(BeNil())\n\t\t\t\tExpect(evt.Params).To(ContainElement(evt.Model))\n\t\t\t\tExpect(evt.Err).To(BeNil())\n\n\t\t\t\tq, err := evt.UnformattedQuery()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(string(q)).To(Equal(`COPY ?TableName TO STDOUT CSV`))\n\n\t\t\t\tq, err = evt.FormattedQuery()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(string(q)).To(Equal(`COPY \"hook_tests\" TO STDOUT CSV`))\n\n\t\t\t\tevt.Stash = map[interface{}]interface{}{\n\t\t\t\t\t\"data\": 1,\n\t\t\t\t}\n\n\t\t\t\treturn c, nil\n\t\t\t}\n\n\t\t\thookImpl.afterQueryMethod = func(c context.Context, evt *pg.QueryEvent) error {\n\t\t\t\tExpect(evt.DB).To(Equal(db))\n\t\t\t\tExpect(evt.Query).To(Equal(`COPY ?TableName TO STDOUT CSV`))\n\t\t\t\tExpect(evt.Model).NotTo(BeNil())\n\t\t\t\tExpect(evt.Params).To(ContainElement(evt.Model))\n\t\t\t\tExpect(evt.Err).NotTo(HaveOccurred())\n\n\t\t\t\tq, err := evt.UnformattedQuery()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(string(q)).To(Equal(`COPY ?TableName TO STDOUT CSV`))\n\n\t\t\t\tq, err = evt.FormattedQuery()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(string(q)).To(Equal(`COPY \"hook_tests\" TO STDOUT CSV`))\n\n\t\t\t\tExpect(evt.Stash[\"data\"]).To(Equal(1))\n\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tdb.AddQueryHook(hookImpl)\n\n\t\t\t_, err := db.Model((*HookTest)(nil)).CopyTo(io.Discard, `COPY ?TableName TO STDOUT CSV`)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"is called for CopyTo without model\", func() {\n\t\t\thookImpl := struct{ queryHookTest }{}\n\t\t\thookImpl.beforeQueryMethod = func(c context.Context, evt *pg.QueryEvent) (context.Context, error) {\n\t\t\t\tExpect(evt.DB).To(Equal(db))\n\t\t\t\tExpect(evt.Query).To(Equal(`COPY (SELECT 1) TO STDOUT CSV`))\n\t\t\t\tExpect(evt.Params).To(BeNil())\n\t\t\t\tExpect(evt.Err).To(BeNil())\n\n\t\t\t\tq, err := evt.UnformattedQuery()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(string(q)).To(Equal(`COPY (SELECT 1) TO STDOUT CSV`))\n\n\t\t\t\tq, err = evt.FormattedQuery()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(string(q)).To(Equal(`COPY (SELECT 1) TO STDOUT CSV`))\n\n\t\t\t\tevt.Stash = map[interface{}]interface{}{\n\t\t\t\t\t\"data\": 1,\n\t\t\t\t}\n\n\t\t\t\treturn c, nil\n\t\t\t}\n\n\t\t\thookImpl.afterQueryMethod = func(c context.Context, evt *pg.QueryEvent) error {\n\t\t\t\tExpect(evt.DB).To(Equal(db))\n\t\t\t\tExpect(evt.Query).To(Equal(`COPY (SELECT 1) TO STDOUT CSV`))\n\t\t\t\tExpect(evt.Params).To(BeNil())\n\t\t\t\tExpect(evt.Err).To(BeNil())\n\n\t\t\t\tq, err := evt.UnformattedQuery()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(string(q)).To(Equal(`COPY (SELECT 1) TO STDOUT CSV`))\n\n\t\t\t\tq, err = evt.FormattedQuery()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(string(q)).To(Equal(`COPY (SELECT 1) TO STDOUT CSV`))\n\n\t\t\t\tExpect(evt.Stash[\"data\"]).To(Equal(1))\n\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tdb.AddQueryHook(hookImpl)\n\n\t\t\t_, err := db.CopyTo(io.Discard, `COPY (SELECT 1) TO STDOUT CSV`)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\t})\n\n\tDescribe(\"CopyFrom\", func() {\n\t\tIt(\"is called for CopyFrom with model\", func() {\n\t\t\thookImpl := struct{ queryHookTest }{}\n\t\t\thookImpl.beforeQueryMethod = func(c context.Context, evt *pg.QueryEvent) (context.Context, error) {\n\t\t\t\tExpect(evt.DB).To(Equal(db))\n\t\t\t\tExpect(evt.Query).To(Equal(`COPY ?TableName FROM STDIN CSV`))\n\t\t\t\tExpect(evt.Model).NotTo(BeNil())\n\t\t\t\tExpect(evt.Params).To(ContainElement(evt.Model))\n\t\t\t\tExpect(evt.Err).To(BeNil())\n\n\t\t\t\tq, err := evt.UnformattedQuery()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(string(q)).To(Equal(`COPY ?TableName FROM STDIN CSV`))\n\n\t\t\t\tq, err = evt.FormattedQuery()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(string(q)).To(Equal(`COPY \"hook_tests\" FROM STDIN CSV`))\n\n\t\t\t\tevt.Stash = map[interface{}]interface{}{\n\t\t\t\t\t\"data\": 1,\n\t\t\t\t}\n\n\t\t\t\treturn c, nil\n\t\t\t}\n\n\t\t\thookImpl.afterQueryMethod = func(c context.Context, evt *pg.QueryEvent) error {\n\t\t\t\tExpect(evt.DB).To(Equal(db))\n\t\t\t\tExpect(evt.Query).To(Equal(`COPY ?TableName FROM STDIN CSV`))\n\t\t\t\tExpect(evt.Model).NotTo(BeNil())\n\t\t\t\tExpect(evt.Params).To(ContainElement(evt.Model))\n\t\t\t\tExpect(evt.Err).NotTo(HaveOccurred())\n\n\t\t\t\tq, err := evt.UnformattedQuery()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(string(q)).To(Equal(`COPY ?TableName FROM STDIN CSV`))\n\n\t\t\t\tq, err = evt.FormattedQuery()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(string(q)).To(Equal(`COPY \"hook_tests\" FROM STDIN CSV`))\n\n\t\t\t\tExpect(evt.Stash[\"data\"]).To(Equal(1))\n\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tdb.AddQueryHook(hookImpl)\n\n\t\t\tconst in = `10,test`\n\t\t\t_, err := db.Model((*HookTest)(nil)).CopyFrom(strings.NewReader(in), `COPY ?TableName FROM STDIN CSV`)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"is called for CopyFrom without model\", func() {\n\t\t\thookImpl := struct{ queryHookTest }{}\n\t\t\thookImpl.beforeQueryMethod = func(c context.Context, evt *pg.QueryEvent) (context.Context, error) {\n\t\t\t\tExpect(evt.DB).To(Equal(db))\n\t\t\t\tExpect(evt.Query).To(Equal(`COPY \"hook_tests\" FROM STDIN CSV`))\n\t\t\t\tExpect(evt.Model).To(BeNil())\n\t\t\t\tExpect(evt.Err).To(BeNil())\n\n\t\t\t\tq, err := evt.UnformattedQuery()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(string(q)).To(Equal(`COPY \"hook_tests\" FROM STDIN CSV`))\n\n\t\t\t\tq, err = evt.FormattedQuery()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(string(q)).To(Equal(`COPY \"hook_tests\" FROM STDIN CSV`))\n\n\t\t\t\tevt.Stash = map[interface{}]interface{}{\n\t\t\t\t\t\"data\": 1,\n\t\t\t\t}\n\n\t\t\t\treturn c, nil\n\t\t\t}\n\n\t\t\thookImpl.afterQueryMethod = func(c context.Context, evt *pg.QueryEvent) error {\n\t\t\t\tExpect(evt.DB).To(Equal(db))\n\t\t\t\tExpect(evt.Query).To(Equal(`COPY \"hook_tests\" FROM STDIN CSV`))\n\t\t\t\tExpect(evt.Model).To(BeNil())\n\t\t\t\tExpect(evt.Err).NotTo(HaveOccurred())\n\n\t\t\t\tq, err := evt.UnformattedQuery()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(string(q)).To(Equal(`COPY \"hook_tests\" FROM STDIN CSV`))\n\n\t\t\t\tq, err = evt.FormattedQuery()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(string(q)).To(Equal(`COPY \"hook_tests\" FROM STDIN CSV`))\n\n\t\t\t\tExpect(evt.Stash[\"data\"]).To(Equal(1))\n\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tdb.AddQueryHook(hookImpl)\n\n\t\t\tconst in = `10,test`\n\t\t\t_, err := db.CopyFrom(strings.NewReader(in), `COPY \"hook_tests\" FROM STDIN CSV`)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\t})\n})\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "listener.go",
          "type": "blob",
          "size": 8.4365234375,
          "content": "package pg\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/go-pg/pg/v10/internal\"\n\t\"github.com/go-pg/pg/v10/internal/pool\"\n\t\"github.com/go-pg/pg/v10/types\"\n)\n\nconst gopgChannel = \"gopg:ping\"\n\nvar (\n\terrListenerClosed = errors.New(\"pg: listener is closed\")\n\terrPingTimeout    = errors.New(\"pg: ping timeout\")\n)\n\n// Notification which is received with LISTEN command.\ntype Notification struct {\n\tChannel string\n\tPayload string\n}\n\n// Listener listens for notifications sent with NOTIFY command.\n// It's NOT safe for concurrent use by multiple goroutines\n// except the Channel API.\ntype Listener struct {\n\tdb *DB\n\n\tchannels []string\n\n\tmu     sync.Mutex\n\tcn     *pool.Conn\n\texit   chan struct{}\n\tclosed bool\n\n\tchOnce sync.Once\n\tch     chan Notification\n\tpingCh chan struct{}\n}\n\nfunc (ln *Listener) String() string {\n\tln.mu.Lock()\n\tdefer ln.mu.Unlock()\n\n\treturn fmt.Sprintf(\"Listener(%s)\", strings.Join(ln.channels, \", \"))\n}\n\nfunc (ln *Listener) init() {\n\tln.exit = make(chan struct{})\n}\n\nfunc (ln *Listener) connWithLock(ctx context.Context) (*pool.Conn, error) {\n\tln.mu.Lock()\n\tcn, err := ln.conn(ctx)\n\tln.mu.Unlock()\n\n\tswitch err {\n\tcase nil:\n\t\treturn cn, nil\n\tcase errListenerClosed:\n\t\treturn nil, err\n\tcase pool.ErrClosed:\n\t\t_ = ln.Close()\n\t\treturn nil, errListenerClosed\n\tdefault:\n\t\tinternal.Logger.Printf(ctx, \"pg: Listen failed: %s\", err)\n\t\treturn nil, err\n\t}\n}\n\nfunc (ln *Listener) conn(ctx context.Context) (*pool.Conn, error) {\n\tif ln.closed {\n\t\treturn nil, errListenerClosed\n\t}\n\n\tif ln.cn != nil {\n\t\treturn ln.cn, nil\n\t}\n\n\tcn, err := ln.db.pool.NewConn(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := ln.db.initConn(ctx, cn); err != nil {\n\t\t_ = ln.db.pool.CloseConn(cn)\n\t\treturn nil, err\n\t}\n\n\tcn.LockReader()\n\n\tif len(ln.channels) > 0 {\n\t\terr := ln.listen(ctx, cn, ln.channels...)\n\t\tif err != nil {\n\t\t\t_ = ln.db.pool.CloseConn(cn)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tln.cn = cn\n\treturn cn, nil\n}\n\nfunc (ln *Listener) releaseConn(ctx context.Context, cn *pool.Conn, err error, allowTimeout bool) {\n\tln.mu.Lock()\n\tif ln.cn == cn {\n\t\tif bad, _ := isBadConn(err, allowTimeout); bad {\n\t\t\tln.reconnect(ctx, err)\n\t\t}\n\t}\n\tln.mu.Unlock()\n}\n\nfunc (ln *Listener) reconnect(ctx context.Context, reason error) {\n\t_ = ln.closeTheCn(reason)\n\t_, _ = ln.conn(ctx)\n}\n\nfunc (ln *Listener) closeTheCn(reason error) error {\n\tif ln.cn == nil {\n\t\treturn nil\n\t}\n\tif !ln.closed {\n\t\tinternal.Logger.Printf(ln.db.ctx, \"pg: discarding bad listener connection: %s\", reason)\n\t}\n\n\terr := ln.db.pool.CloseConn(ln.cn)\n\tln.cn = nil\n\treturn err\n}\n\n// Close closes the listener, releasing any open resources.\nfunc (ln *Listener) Close() error {\n\tln.mu.Lock()\n\tdefer ln.mu.Unlock()\n\n\tif ln.closed {\n\t\treturn errListenerClosed\n\t}\n\tln.closed = true\n\tclose(ln.exit)\n\n\treturn ln.closeTheCn(errListenerClosed)\n}\n\n// Listen starts listening for notifications on channels.\nfunc (ln *Listener) Listen(ctx context.Context, channels ...string) error {\n\t// Always append channels so DB.Listen works correctly.\n\tln.mu.Lock()\n\tln.channels = appendIfNotExists(ln.channels, channels...)\n\tln.mu.Unlock()\n\n\tcn, err := ln.connWithLock(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := ln.listen(ctx, cn, channels...); err != nil {\n\t\tln.releaseConn(ctx, cn, err, false)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (ln *Listener) listen(ctx context.Context, cn *pool.Conn, channels ...string) error {\n\terr := cn.WithWriter(ctx, ln.db.opt.WriteTimeout, func(wb *pool.WriteBuffer) error {\n\t\tfor _, channel := range channels {\n\t\t\tif err := writeQueryMsg(wb, ln.db.fmter, \"LISTEN ?\", pgChan(channel)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\treturn err\n}\n\n// Unlisten stops listening for notifications on channels.\nfunc (ln *Listener) Unlisten(ctx context.Context, channels ...string) error {\n\tln.mu.Lock()\n\tln.channels = removeIfExists(ln.channels, channels...)\n\n\tcn, err := ln.conn(ctx)\n\t// I don't want to defer this unlock as the mutex is re-acquired in the `.releaseConn` function. But it is safe to\n\t// unlock here regardless of an error.\n\tln.mu.Unlock()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := ln.unlisten(ctx, cn, channels...); err != nil {\n\t\tln.releaseConn(ctx, cn, err, false)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (ln *Listener) unlisten(ctx context.Context, cn *pool.Conn, channels ...string) error {\n\terr := cn.WithWriter(ctx, ln.db.opt.WriteTimeout, func(wb *pool.WriteBuffer) error {\n\t\tfor _, channel := range channels {\n\t\t\tif err := writeQueryMsg(wb, ln.db.fmter, \"UNLISTEN ?\", pgChan(channel)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\treturn err\n}\n\n// Receive indefinitely waits for a notification. This is low-level API\n// and in most cases Channel should be used instead.\nfunc (ln *Listener) Receive(ctx context.Context) (channel string, payload string, err error) {\n\treturn ln.ReceiveTimeout(ctx, 0)\n}\n\n// ReceiveTimeout waits for a notification until timeout is reached.\n// This is low-level API and in most cases Channel should be used instead.\nfunc (ln *Listener) ReceiveTimeout(\n\tctx context.Context, timeout time.Duration,\n) (channel, payload string, err error) {\n\tcn, err := ln.connWithLock(ctx)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\terr = cn.WithReader(ctx, timeout, func(rd *pool.ReaderContext) error {\n\t\tchannel, payload, err = readNotification(rd)\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tln.releaseConn(ctx, cn, err, timeout > 0)\n\t\treturn \"\", \"\", err\n\t}\n\n\treturn channel, payload, nil\n}\n\n// Channel returns a channel for concurrently receiving notifications.\n// It periodically sends Ping notification to test connection health.\n//\n// The channel is closed with Listener. Receive* APIs can not be used\n// after channel is created.\nfunc (ln *Listener) Channel() <-chan Notification {\n\treturn ln.channel(100)\n}\n\n// ChannelSize is like Channel, but creates a Go channel\n// with specified buffer size.\nfunc (ln *Listener) ChannelSize(size int) <-chan Notification {\n\treturn ln.channel(size)\n}\n\nfunc (ln *Listener) channel(size int) <-chan Notification {\n\tln.chOnce.Do(func() {\n\t\tln.initChannel(size)\n\t})\n\tif cap(ln.ch) != size {\n\t\terr := fmt.Errorf(\"pg: Listener.Channel is called with different buffer size\")\n\t\tpanic(err)\n\t}\n\treturn ln.ch\n}\n\nfunc (ln *Listener) initChannel(size int) {\n\tconst pingTimeout = time.Second\n\tconst chanSendTimeout = time.Minute\n\n\tctx := ln.db.ctx\n\t_ = ln.Listen(ctx, gopgChannel)\n\n\tln.ch = make(chan Notification, size)\n\tln.pingCh = make(chan struct{}, 1)\n\n\tgo func() {\n\t\ttimer := time.NewTimer(time.Minute)\n\t\ttimer.Stop()\n\n\t\tvar errCount int\n\t\tfor {\n\t\t\tchannel, payload, err := ln.Receive(ctx)\n\t\t\tif err != nil {\n\t\t\t\tif err == errListenerClosed {\n\t\t\t\t\tclose(ln.ch)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif errCount > 0 {\n\t\t\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t\t\t}\n\t\t\t\terrCount++\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\terrCount = 0\n\n\t\t\t// Any notification is as good as a ping.\n\t\t\tselect {\n\t\t\tcase ln.pingCh <- struct{}{}:\n\t\t\tdefault:\n\t\t\t}\n\n\t\t\tswitch channel {\n\t\t\tcase gopgChannel:\n\t\t\t\t// ignore\n\t\t\tdefault:\n\t\t\t\ttimer.Reset(chanSendTimeout)\n\t\t\t\tselect {\n\t\t\t\tcase ln.ch <- Notification{channel, payload}:\n\t\t\t\t\tif !timer.Stop() {\n\t\t\t\t\t\t<-timer.C\n\t\t\t\t\t}\n\t\t\t\tcase <-timer.C:\n\t\t\t\t\tinternal.Logger.Printf(\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\t\"pg: %s channel is full for %s (notification is dropped)\",\n\t\t\t\t\t\tln,\n\t\t\t\t\t\tchanSendTimeout,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\ttimer := time.NewTimer(time.Minute)\n\t\ttimer.Stop()\n\n\t\thealthy := true\n\t\tfor {\n\t\t\ttimer.Reset(pingTimeout)\n\t\t\tselect {\n\t\t\tcase <-ln.pingCh:\n\t\t\t\thealthy = true\n\t\t\t\tif !timer.Stop() {\n\t\t\t\t\t<-timer.C\n\t\t\t\t}\n\t\t\tcase <-timer.C:\n\t\t\t\tpingErr := ln.ping()\n\t\t\t\tif healthy {\n\t\t\t\t\thealthy = false\n\t\t\t\t} else {\n\t\t\t\t\tif pingErr == nil {\n\t\t\t\t\t\tpingErr = errPingTimeout\n\t\t\t\t\t}\n\t\t\t\t\tln.mu.Lock()\n\t\t\t\t\tln.reconnect(ctx, pingErr)\n\t\t\t\t\tln.mu.Unlock()\n\t\t\t\t}\n\t\t\tcase <-ln.exit:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n}\n\nfunc (ln *Listener) ping() error {\n\t_, err := ln.db.Exec(\"NOTIFY ?\", pgChan(gopgChannel))\n\treturn err\n}\n\nfunc appendIfNotExists(ss []string, es ...string) []string {\nloop:\n\tfor _, e := range es {\n\t\tfor _, s := range ss {\n\t\t\tif s == e {\n\t\t\t\tcontinue loop\n\t\t\t}\n\t\t}\n\t\tss = append(ss, e)\n\t}\n\treturn ss\n}\n\nfunc removeIfExists(ss []string, es ...string) []string {\n\tfor _, e := range es {\n\t\tfor i, s := range ss {\n\t\t\tif s == e {\n\t\t\t\tlast := len(ss) - 1\n\t\t\t\tss[i] = ss[last]\n\t\t\t\tss = ss[:last]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn ss\n}\n\ntype pgChan string\n\nvar _ types.ValueAppender = pgChan(\"\")\n\nfunc (ch pgChan) AppendValue(b []byte, quote int) ([]byte, error) {\n\tif quote == 0 {\n\t\treturn append(b, ch...), nil\n\t}\n\n\tb = append(b, '\"')\n\tfor _, c := range []byte(ch) {\n\t\tif c == '\"' {\n\t\t\tb = append(b, '\"', '\"')\n\t\t} else {\n\t\t\tb = append(b, c)\n\t\t}\n\t}\n\tb = append(b, '\"')\n\n\treturn b, nil\n}\n"
        },
        {
          "name": "listener_test.go",
          "type": "blob",
          "size": 4.505859375,
          "content": "package pg_test\n\nimport (\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/go-pg/pg/v10\"\n\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n)\n\nvar _ = Context(\"Listener\", func() {\n\tvar db *pg.DB\n\tvar ln *pg.Listener\n\n\tBeforeEach(func() {\n\t\topt := pgOptions()\n\t\topt.PoolSize = 2\n\t\topt.PoolTimeout = time.Second\n\n\t\tdb = pg.Connect(opt)\n\t\tln = db.Listen(ctx, \"test_channel\")\n\t})\n\n\t_ = AfterEach(func() {\n\t\t_ = ln.Close()\n\t\t_ = db.Close()\n\t})\n\n\tIt(\"implements Stringer\", func() {\n\t\tExpect(ln.String()).To(Equal(\"Listener(test_channel)\"))\n\n\t\t_ = ln.Channel()\n\t\tExpect(ln.String()).To(Equal(\"Listener(test_channel, gopg:ping)\"))\n\t})\n\n\tIt(\"reuses connection\", func() {\n\t\tfor i := 0; i < 100; i++ {\n\t\t\t_, _, err := ln.ReceiveTimeout(ctx, time.Nanosecond)\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.Error()).To(MatchRegexp(\".+ i/o timeout\"))\n\t\t}\n\n\t\tst := db.PoolStats()\n\t\tExpect(st.Hits).To(Equal(uint32(0)))\n\t\tExpect(st.Misses).To(Equal(uint32(0)))\n\t\tExpect(st.Timeouts).To(Equal(uint32(0)))\n\t\tExpect(st.TotalConns).To(Equal(uint32(1)))\n\t\tExpect(st.IdleConns).To(Equal(uint32(0)))\n\t})\n\n\tIt(\"listens for notifications\", func() {\n\t\twait := make(chan struct{}, 2)\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\n\t\t\twait <- struct{}{}\n\t\t\tchannel, payload, err := ln.Receive(ctx)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(channel).To(Equal(\"test_channel\"))\n\t\t\tExpect(payload).To(Equal(\"\"))\n\t\t\twait <- struct{}{}\n\t\t}()\n\n\t\tselect {\n\t\tcase <-wait:\n\t\t\t// ok\n\t\tcase <-time.After(3 * time.Second):\n\t\t\tFail(\"timeout\")\n\t\t}\n\n\t\t_, err := db.Exec(\"NOTIFY test_channel\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tselect {\n\t\tcase <-wait:\n\t\t\t// ok\n\t\tcase <-time.After(3 * time.Second):\n\t\t\tFail(\"timeout\")\n\t\t}\n\t})\n\n\tIt(\"is closed when DB is closed\", func() {\n\t\twait := make(chan struct{}, 2)\n\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\n\t\t\twait <- struct{}{}\n\t\t\t_, _, err := ln.Receive(ctx)\n\n\t\t\tExpect(err).ToNot(BeNil())\n\t\t\tExpect(err.Error()).To(SatisfyAny(\n\t\t\t\tEqual(\"EOF\"),\n\t\t\t\tMatchRegexp(`use of closed (file or )?network connection$`),\n\t\t\t))\n\t\t\twait <- struct{}{}\n\t\t}()\n\n\t\tselect {\n\t\tcase <-wait:\n\t\t\t// ok\n\t\tcase <-time.After(time.Second):\n\t\t\tFail(\"timeout\")\n\t\t}\n\n\t\tselect {\n\t\tcase <-wait:\n\t\t\tFail(\"Receive is not blocked\")\n\t\tcase <-time.After(time.Second):\n\t\t\t// ok\n\t\t}\n\n\t\tExpect(db.Close()).To(BeNil())\n\n\t\tselect {\n\t\tcase <-wait:\n\t\t\t// ok\n\t\tcase <-time.After(3 * time.Second):\n\t\t\tFail(\"Listener is not closed\")\n\t\t}\n\n\t\t_, _, err := ln.Receive(ctx)\n\t\tExpect(err).To(MatchError(\"pg: listener is closed\"))\n\n\t\terr = ln.Close()\n\t\tExpect(err).To(MatchError(\"pg: listener is closed\"))\n\t})\n\n\tIt(\"returns an error on timeout\", func() {\n\t\tchannel, payload, err := ln.ReceiveTimeout(ctx, time.Second)\n\t\tExpect(err.(net.Error).Timeout()).To(BeTrue())\n\t\tExpect(channel).To(Equal(\"\"))\n\t\tExpect(payload).To(Equal(\"\"))\n\t})\n\n\tIt(\"reconnects on bad connection\", func() {\n\t\tcn := ln.CurrentConn()\n\t\tExpect(cn).NotTo(BeNil())\n\t\tcn.SetNetConn(&badConn{})\n\n\t\terr := ln.Listen(ctx, \"test_channel2\")\n\t\tExpect(err).Should(MatchError(\"bad connection\"))\n\n\t\terr = ln.Listen(ctx, \"test_channel2\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"reconnects on receive error\", func() {\n\t\tcn := ln.CurrentConn()\n\t\tExpect(cn).NotTo(BeNil())\n\t\tcn.SetNetConn(&badConn{})\n\n\t\t_, _, err := ln.ReceiveTimeout(ctx, time.Second)\n\t\tExpect(err).Should(MatchError(\"bad connection\"))\n\n\t\t_, _, err = ln.ReceiveTimeout(ctx, time.Second)\n\t\tExpect(err.(net.Error).Timeout()).To(BeTrue())\n\n\t\twait := make(chan struct{}, 2)\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\n\t\t\twait <- struct{}{}\n\t\t\t_, _, lnerr := ln.Receive(ctx)\n\t\t\tExpect(lnerr).NotTo(HaveOccurred())\n\t\t\twait <- struct{}{}\n\t\t}()\n\n\t\tselect {\n\t\tcase <-wait:\n\t\t\t// ok\n\t\tcase <-time.After(3 * time.Second):\n\t\t\tFail(\"timeout\")\n\t\t}\n\n\t\tselect {\n\t\tcase <-wait:\n\t\t\tFail(\"Receive is not blocked\")\n\t\tcase <-time.After(time.Second):\n\t\t\t// ok\n\t\t}\n\n\t\t_, err = db.Exec(\"NOTIFY test_channel\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tselect {\n\t\tcase <-wait:\n\t\t\t// ok\n\t\tcase <-time.After(3 * time.Second):\n\t\t\tFail(\"timeout\")\n\t\t}\n\t})\n\n\tIt(\"supports concurrent Listen and Receive\", func() {\n\t\tconst N = 100\n\n\t\twg := performAsync(N, func(_ int) {\n\t\t\t_, err := db.Exec(\"NOTIFY test_channel\")\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tdone := make(chan struct{})\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\t_, _, err := ln.ReceiveTimeout(ctx, 5*time.Second)\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\t\t\tclose(done)\n\t\t}()\n\n\t\tfor i := 0; i < N; i++ {\n\t\t\terr := ln.Listen(ctx, \"test_channel\")\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t}\n\n\t\tselect {\n\t\tcase <-done:\n\t\t\twg.Wait()\n\t\tcase <-time.After(30 * time.Second):\n\t\t\tFail(\"timeout\")\n\t\t}\n\t})\n})\n"
        },
        {
          "name": "loader_test.go",
          "type": "blob",
          "size": 3.16796875,
          "content": "package pg_test\n\nimport (\n\t\"errors\"\n\n\t\"github.com/go-pg/pg/v10\"\n\t\"github.com/go-pg/pg/v10/orm\"\n\t\"github.com/go-pg/pg/v10/types\"\n\n\t. \"gopkg.in/check.v1\"\n)\n\ntype LoaderTest struct {\n\tdb *pg.DB\n}\n\nvar _ = Suite(&LoaderTest{})\n\nfunc (t *LoaderTest) SetUpTest(c *C) {\n\tt.db = pg.Connect(pgOptions())\n}\n\nfunc (t *LoaderTest) TearDownTest(c *C) {\n\tc.Assert(t.db.Close(), IsNil)\n}\n\ntype numLoader struct {\n\tNum int\n}\n\ntype embeddedLoader struct {\n\t*numLoader\n\tNum2 int\n}\n\ntype multipleLoader struct {\n\tOne struct {\n\t\tNum int\n\t}\n\tNum int\n}\n\nfunc (t *LoaderTest) TestQuery(c *C) {\n\tvar dst numLoader\n\t_, err := t.db.Query(&dst, \"SELECT 1 AS num\")\n\tc.Assert(err, IsNil)\n\tc.Assert(dst.Num, Equals, 1)\n}\n\nfunc (t *LoaderTest) TestQueryNull(c *C) {\n\tvar dst numLoader\n\t_, err := t.db.Query(&dst, \"SELECT NULL AS num\")\n\tc.Assert(err, IsNil)\n\tc.Assert(dst.Num, Equals, 0)\n}\n\nfunc (t *LoaderTest) TestQueryEmbeddedStruct(c *C) {\n\tsrc := &embeddedLoader{\n\t\tnumLoader: &numLoader{\n\t\t\tNum: 1,\n\t\t},\n\t\tNum2: 2,\n\t}\n\tdst := &embeddedLoader{\n\t\tnumLoader: &numLoader{},\n\t}\n\t_, err := t.db.QueryOne(dst, \"SELECT ?num AS num, ?num2 as num2\", src)\n\tc.Assert(err, IsNil)\n\tc.Assert(dst, DeepEquals, src)\n}\n\nfunc (t *LoaderTest) TestQueryNestedStructs(c *C) {\n\tsrc := &multipleLoader{}\n\tsrc.One.Num = 1\n\tsrc.Num = 2\n\tdst := &multipleLoader{}\n\t_, err := t.db.QueryOne(dst, `SELECT ?one__num AS one__num, ?num as num`, src)\n\tc.Assert(err, IsNil)\n\tc.Assert(dst, DeepEquals, src)\n}\n\nfunc (t *LoaderTest) TestQueryStmt(c *C) {\n\tstmt, err := t.db.Prepare(\"SELECT 1 AS num\")\n\tc.Assert(err, IsNil)\n\tdefer stmt.Close()\n\n\tdst := &numLoader{}\n\t_, err = stmt.Query(dst)\n\tc.Assert(err, IsNil)\n\tc.Assert(dst.Num, Equals, 1)\n}\n\nfunc (t *LoaderTest) TestQueryInts(c *C) {\n\tvar ids pg.Ints\n\t_, err := t.db.Query(&ids, \"SELECT s.num AS num FROM generate_series(0, 10) AS s(num)\")\n\tc.Assert(err, IsNil)\n\tc.Assert(ids, DeepEquals, pg.Ints{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\n}\n\nfunc (t *LoaderTest) TestQueryInts2(c *C) {\n\tvar ints pg.Ints\n\t_, err := t.db.Query(&ints, \"SELECT * FROM generate_series(1, 1000000)\")\n\tc.Assert(err, IsNil)\n\tc.Assert(ints, HasLen, 1000000)\n}\n\nfunc (t *LoaderTest) TestQueryStrings(c *C) {\n\tvar strings pg.Strings\n\t_, err := t.db.Query(&strings, \"SELECT 'hello'\")\n\tc.Assert(err, IsNil)\n\tc.Assert(strings, DeepEquals, pg.Strings{\"hello\"})\n}\n\ntype errLoader struct {\n\terr error\n}\n\nvar _ orm.HooklessModel = (*errLoader)(nil)\n\nfunc newErrLoader(err error) *errLoader {\n\treturn &errLoader{\n\t\terr: err,\n\t}\n}\n\nfunc (m *errLoader) Init() error {\n\treturn nil\n}\n\nfunc (m *errLoader) NextColumnScanner() orm.ColumnScanner {\n\treturn m\n}\n\nfunc (m *errLoader) AddColumnScanner(_ orm.ColumnScanner) error {\n\treturn nil\n}\n\nfunc (m *errLoader) ScanColumn(types.ColumnInfo, types.Reader, int) error {\n\treturn m.err\n}\n\nfunc (t *LoaderTest) TestLoaderError(c *C) {\n\ttx, err := t.db.Begin()\n\tc.Assert(err, IsNil)\n\tdefer tx.Rollback()\n\n\tloader := newErrLoader(errors.New(\"my error\"))\n\t_, err = tx.QueryOne(loader, \"SELECT 1, 2\")\n\tc.Assert(err, Not(IsNil))\n\tc.Assert(err.Error(), Equals, \"my error\")\n\n\t// Verify that client is still functional.\n\tvar n1, n2 int\n\t_, err = tx.QueryOne(pg.Scan(&n1, &n2), \"SELECT 1, 2\")\n\tc.Assert(err, IsNil)\n\tc.Assert(n1, Equals, 1)\n\tc.Assert(n2, Equals, 2)\n}\n"
        },
        {
          "name": "main_test.go",
          "type": "blob",
          "size": 4.3359375,
          "content": "package pg_test\n\nimport (\n\t\"bytes\"\n\t\"database/sql/driver\"\n\t\"net\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t. \"github.com/onsi/ginkgo\"\n\t. \"gopkg.in/check.v1\"\n\n\t\"github.com/go-pg/pg/v10\"\n)\n\nfunc TestUnixSocket(t *testing.T) {\n\tt.Skip()\n\n\topt := pgOptions()\n\topt.Network = \"unix\"\n\topt.Addr = \"/var/run/postgresql/.s.PGSQL.5432\"\n\topt.TLSConfig = nil\n\tdb := pg.Connect(opt)\n\tdefer db.Close()\n\n\t_, err := db.Exec(\"SELECT 'test_unix_socket'\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGocheck(t *testing.T) { TestingT(t) }\n\nvar _ = Suite(&DBTest{})\n\ntype DBTest struct {\n\tdb *pg.DB\n}\n\nfunc (t *DBTest) SetUpTest(c *C) {\n\tt.db = pg.Connect(pgOptions())\n}\n\nfunc (t *DBTest) TearDownTest(c *C) {\n\tc.Assert(t.db.Close(), IsNil)\n}\n\nfunc (t *DBTest) TestQueryOneErrMultiRows(c *C) {\n\t_, err := t.db.QueryOne(pg.Discard, \"SELECT generate_series(0, 1)\")\n\tc.Assert(err, Equals, pg.ErrMultiRows)\n}\n\nfunc (t *DBTest) TestExecOne(c *C) {\n\tres, err := t.db.ExecOne(\"SELECT 'test_exec_one'\")\n\tc.Assert(err, IsNil)\n\tc.Assert(res.RowsAffected(), Equals, 1)\n}\n\nfunc (t *DBTest) TestExecOneErrNoRows(c *C) {\n\t_, err := t.db.ExecOne(\"SELECT 1 WHERE 1 != 1\")\n\tc.Assert(err, Equals, pg.ErrNoRows)\n}\n\nfunc (t *DBTest) TestExecOneErrMultiRows(c *C) {\n\t_, err := t.db.ExecOne(\"SELECT generate_series(0, 1)\")\n\tc.Assert(err, Equals, pg.ErrMultiRows)\n}\n\nfunc (t *DBTest) TestScan(c *C) {\n\tvar dst int\n\t_, err := t.db.QueryOne(pg.Scan(&dst), \"SELECT 1\")\n\tc.Assert(err, IsNil)\n\tc.Assert(dst, Equals, 1)\n}\n\nfunc (t *DBTest) TestExec(c *C) {\n\tres, err := t.db.Exec(\"CREATE TEMP TABLE test(id serial PRIMARY KEY)\")\n\tc.Assert(err, IsNil)\n\tc.Assert(res.RowsAffected(), Equals, -1)\n\n\tres, err = t.db.Exec(\"INSERT INTO test VALUES (1)\")\n\tc.Assert(err, IsNil)\n\tc.Assert(res.RowsAffected(), Equals, 1)\n}\n\nfunc (t *DBTest) TestStatementExec(c *C) {\n\tres, err := t.db.Exec(\"CREATE TEMP TABLE test(id serial PRIMARY KEY)\")\n\tc.Assert(err, IsNil)\n\tc.Assert(res.RowsAffected(), Equals, -1)\n\n\tstmt, err := t.db.Prepare(\"INSERT INTO test VALUES($1)\")\n\tc.Assert(err, IsNil)\n\tdefer stmt.Close()\n\n\tres, err = stmt.Exec(1)\n\tc.Assert(err, IsNil)\n\tc.Assert(res.RowsAffected(), Equals, 1)\n}\n\nfunc (t *DBTest) TestLargeWriteRead(c *C) {\n\tsrc := bytes.Repeat([]byte{0x1}, 1e6)\n\tvar dst []byte\n\t_, err := t.db.QueryOne(pg.Scan(&dst), \"SELECT ?\", src)\n\tc.Assert(err, IsNil)\n\tc.Assert(dst, DeepEquals, src)\n}\n\nfunc (t *DBTest) TestIntegrityError(c *C) {\n\t_, err := t.db.Exec(\"DO $$BEGIN RAISE unique_violation USING MESSAGE='foo'; END$$;\")\n\tc.Assert(err.(pg.Error).IntegrityViolation(), Equals, true)\n}\n\ntype customStrSlice []string\n\nfunc (s customStrSlice) Value() (driver.Value, error) {\n\treturn strings.Join(s, \"\\n\"), nil\n}\n\nfunc (s *customStrSlice) Scan(v interface{}) error {\n\tif v == nil {\n\t\t*s = nil\n\t\treturn nil\n\t}\n\n\tb := v.([]byte)\n\n\tif len(b) == 0 {\n\t\t*s = []string{}\n\t\treturn nil\n\t}\n\n\t*s = strings.Split(string(b), \"\\n\")\n\treturn nil\n}\n\nfunc (t *DBTest) TestScannerValueOnStruct(c *C) {\n\tsrc := customStrSlice{\"foo\", \"bar\"}\n\tdst := struct{ Dst customStrSlice }{}\n\t_, err := t.db.QueryOne(&dst, \"SELECT ? AS dst\", src)\n\tc.Assert(err, IsNil)\n\tc.Assert(dst.Dst, DeepEquals, src)\n}\n\n//------------------------------------------------------------------------------\n\ntype badConnError string\n\nfunc (e badConnError) Error() string   { return string(e) }\nfunc (e badConnError) Timeout() bool   { return true }\nfunc (e badConnError) Temporary() bool { return false }\n\ntype badConn struct {\n\tnet.TCPConn\n\n\treadDelay, writeDelay time.Duration\n\treadErr, writeErr     error\n}\n\nvar _ net.Conn = &badConn{}\n\nfunc (cn *badConn) SetReadDeadline(t time.Time) error {\n\treturn nil\n}\n\nfunc (cn *badConn) SetWriteDeadline(t time.Time) error {\n\treturn nil\n}\n\nfunc (cn *badConn) Read([]byte) (int, error) {\n\tif cn.readDelay != 0 {\n\t\ttime.Sleep(cn.readDelay)\n\t}\n\tif cn.readErr != nil {\n\t\treturn 0, cn.readErr\n\t}\n\treturn 0, badConnError(\"bad connection\")\n}\n\nfunc (cn *badConn) Write([]byte) (int, error) {\n\tif cn.writeDelay != 0 {\n\t\ttime.Sleep(cn.writeDelay)\n\t}\n\tif cn.writeErr != nil {\n\t\treturn 0, cn.writeErr\n\t}\n\treturn 0, badConnError(\"bad connection\")\n}\n\nfunc performAsync(n int, cbs ...func(int)) *sync.WaitGroup {\n\tvar wg sync.WaitGroup\n\tfor _, cb := range cbs {\n\t\tfor i := 0; i < n; i++ {\n\t\t\twg.Add(1)\n\t\t\tgo func(cb func(int), i int) {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tdefer wg.Done()\n\n\t\t\t\tcb(i)\n\t\t\t}(cb, i)\n\t\t}\n\t}\n\treturn &wg\n}\n\nfunc perform(n int, cbs ...func(int)) {\n\twg := performAsync(n, cbs...)\n\twg.Wait()\n}\n"
        },
        {
          "name": "messages.go",
          "type": "blob",
          "size": 29.8056640625,
          "content": "package pg\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"crypto/md5\" //nolint\n\t\"crypto/tls\"\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\n\t\"mellium.im/sasl\"\n\n\t\"github.com/go-pg/pg/v10/internal\"\n\t\"github.com/go-pg/pg/v10/internal/pool\"\n\t\"github.com/go-pg/pg/v10/orm\"\n\t\"github.com/go-pg/pg/v10/types\"\n)\n\n// https://www.postgresql.org/docs/current/protocol-message-formats.html\nconst (\n\tcommandCompleteMsg  = 'C'\n\terrorResponseMsg    = 'E'\n\tnoticeResponseMsg   = 'N'\n\tparameterStatusMsg  = 'S'\n\tauthenticationOKMsg = 'R'\n\tbackendKeyDataMsg   = 'K'\n\tnoDataMsg           = 'n'\n\tpasswordMessageMsg  = 'p'\n\tterminateMsg        = 'X'\n\n\tsaslInitialResponseMsg        = 'p'\n\tauthenticationSASLContinueMsg = 'R'\n\tsaslResponseMsg               = 'p'\n\tauthenticationSASLFinalMsg    = 'R'\n\n\tauthenticationOK                = 0\n\tauthenticationCleartextPassword = 3\n\tauthenticationMD5Password       = 5\n\tauthenticationSASL              = 10\n\n\tnotificationResponseMsg = 'A'\n\n\tdescribeMsg             = 'D'\n\tparameterDescriptionMsg = 't'\n\n\tqueryMsg              = 'Q'\n\treadyForQueryMsg      = 'Z'\n\temptyQueryResponseMsg = 'I'\n\trowDescriptionMsg     = 'T'\n\tdataRowMsg            = 'D'\n\n\tparseMsg         = 'P'\n\tparseCompleteMsg = '1'\n\n\tbindMsg         = 'B'\n\tbindCompleteMsg = '2'\n\n\texecuteMsg = 'E'\n\n\tsyncMsg  = 'S'\n\tflushMsg = 'H'\n\n\tcloseMsg         = 'C'\n\tcloseCompleteMsg = '3'\n\n\tcopyInResponseMsg  = 'G'\n\tcopyOutResponseMsg = 'H'\n\tcopyDataMsg        = 'd'\n\tcopyDoneMsg        = 'c'\n)\n\nvar errEmptyQuery = internal.Errorf(\"pg: query is empty\")\n\nfunc (db *baseDB) startup(\n\tc context.Context, cn *pool.Conn, user, password, database, appName string,\n) error {\n\terr := cn.WithWriter(c, db.opt.WriteTimeout, func(wb *pool.WriteBuffer) error {\n\t\twriteStartupMsg(wb, user, database, appName)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn cn.WithReader(c, db.opt.ReadTimeout, func(rd *pool.ReaderContext) error {\n\t\tfor {\n\t\t\ttyp, msgLen, err := readMessageType(rd)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tswitch typ {\n\t\t\tcase backendKeyDataMsg:\n\t\t\t\tprocessID, err := readInt32(rd)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsecretKey, err := readInt32(rd)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tcn.ProcessID = processID\n\t\t\t\tcn.SecretKey = secretKey\n\t\t\tcase parameterStatusMsg:\n\t\t\t\tif err := logParameterStatus(rd, msgLen); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\tcase authenticationOKMsg:\n\t\t\t\terr := db.auth(c, cn, rd, user, password)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\tcase readyForQueryMsg:\n\t\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\t\treturn err\n\t\t\tcase noticeResponseMsg:\n\t\t\t\t// If we encounter a notice message from the server then we want to try to log it as it might be\n\t\t\t\t// important for the client. If something goes wrong with this we want to fail. At the time of writing\n\t\t\t\t// this the client will fail just encountering a notice during startup. So failing if a bad notice is\n\t\t\t\t// sent is probably better than not failing, especially if we can try to log at least some data from the\n\t\t\t\t// notice.\n\t\t\t\tif err := db.logStartupNotice(rd); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\tcase errorResponseMsg:\n\t\t\t\te, err := readError(rd)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn e\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"pg: unknown startup message response: %q\", typ)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc (db *baseDB) enableSSL(c context.Context, cn *pool.Conn, tlsConf *tls.Config) error {\n\terr := cn.WithWriter(c, db.opt.WriteTimeout, func(wb *pool.WriteBuffer) error {\n\t\twriteSSLMsg(wb)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = cn.WithReader(c, db.opt.ReadTimeout, func(rd *pool.ReaderContext) error {\n\t\tc, err := rd.ReadByte()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif c != 'S' {\n\t\t\treturn errors.New(\"pg: SSL is not enabled on the server\")\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcn.SetNetConn(tls.Client(cn.NetConn(), tlsConf))\n\treturn nil\n}\n\nfunc (db *baseDB) auth(\n\tc context.Context, cn *pool.Conn, rd *pool.ReaderContext, user, password string,\n) error {\n\tnum, err := readInt32(rd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch num {\n\tcase authenticationOK:\n\t\treturn nil\n\tcase authenticationCleartextPassword:\n\t\treturn db.authCleartext(c, cn, rd, password)\n\tcase authenticationMD5Password:\n\t\treturn db.authMD5(c, cn, rd, user, password)\n\tcase authenticationSASL:\n\t\treturn db.authSASL(c, cn, rd, user, password)\n\tdefault:\n\t\treturn fmt.Errorf(\"pg: unknown authentication message response: %q\", num)\n\t}\n}\n\n// logStartupNotice will handle notice messages during the startup process. It will parse them and log them for the\n// client. Notices are not common and only happen if there is something the client should be aware of. So logging should\n// not be a problem.\n// Notice messages can be seen in startup: https://www.postgresql.org/docs/13/protocol-flow.html\n// Information on the notice message format: https://www.postgresql.org/docs/13/protocol-message-formats.html\n// Note: This is true for earlier versions of PostgreSQL as well, I've just included the latest versions of the docs.\nfunc (db *baseDB) logStartupNotice(\n\trd *pool.ReaderContext,\n) error {\n\tmessage := make([]string, 0)\n\t// Notice messages are null byte delimited key-value pairs. Where the keys are one byte.\n\tfor {\n\t\t// Read the key byte.\n\t\tfieldType, err := rd.ReadByte()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If they key byte (the type of field this data is) is 0 then that means we have reached the end of the notice.\n\t\t// We can break our loop here and throw our message data into the logger.\n\t\tif fieldType == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\t// Read until the next null byte to get the data for this field. This does include the null byte at the end of\n\t\t// fieldValue so we will trim it off down below.\n\t\tfieldValue, err := readString(rd)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Just throw the field type as a string and its value into an array.\n\t\t// Field types can be seen here: https://www.postgresql.org/docs/13/protocol-error-fields.html\n\t\t// TODO This is a rare occurrence as is, would it be worth adding something to indicate what the field names\n\t\t//  are? Or is PostgreSQL documentation enough for a user at this point?\n\t\tmessage = append(message, fmt.Sprintf(\"%s: %s\", string(fieldType), fieldValue))\n\t}\n\n\t// Tell the client what PostgreSQL told us. Warning because its probably something the client should at the very\n\t// least adjust.\n\tinternal.Warn.Printf(\"notice during startup: %s\", strings.Join(message, \", \"))\n\n\treturn nil\n}\n\nfunc (db *baseDB) authCleartext(\n\tc context.Context, cn *pool.Conn, rd *pool.ReaderContext, password string,\n) error {\n\terr := cn.WithWriter(c, db.opt.WriteTimeout, func(wb *pool.WriteBuffer) error {\n\t\twritePasswordMsg(wb, password)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn readAuthOK(rd)\n}\n\nfunc (db *baseDB) authMD5(\n\tc context.Context, cn *pool.Conn, rd *pool.ReaderContext, user, password string,\n) error {\n\tb, err := rd.ReadN(4)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsecret := \"md5\" + md5s(md5s(password+user)+string(b))\n\terr = cn.WithWriter(c, db.opt.WriteTimeout, func(wb *pool.WriteBuffer) error {\n\t\twritePasswordMsg(wb, secret)\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn readAuthOK(rd)\n}\n\nfunc readAuthOK(rd *pool.ReaderContext) error {\n\tc, _, err := readMessageType(rd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch c {\n\tcase authenticationOKMsg:\n\t\tc0, err := readInt32(rd)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif c0 != 0 {\n\t\t\treturn fmt.Errorf(\"pg: unexpected authentication code: %q\", c0)\n\t\t}\n\t\treturn nil\n\tcase errorResponseMsg:\n\t\te, err := readError(rd)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn e\n\tdefault:\n\t\treturn fmt.Errorf(\"pg: unknown password message response: %q\", c)\n\t}\n}\n\nfunc (db *baseDB) authSASL(\n\tc context.Context, cn *pool.Conn, rd *pool.ReaderContext, user, password string,\n) error {\n\tvar saslMech sasl.Mechanism\n\nloop:\n\tfor {\n\t\ts, err := readString(rd)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch s {\n\t\tcase \"\":\n\t\t\tbreak loop\n\t\tcase sasl.ScramSha256.Name:\n\t\t\tsaslMech = sasl.ScramSha256\n\t\tcase sasl.ScramSha256Plus.Name:\n\t\t\t// ignore\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"got %q, wanted %q\", s, sasl.ScramSha256.Name)\n\t\t}\n\t}\n\n\tcreds := sasl.Credentials(func() (Username, Password, Identity []byte) {\n\t\treturn []byte(user), []byte(password), nil\n\t})\n\tclient := sasl.NewClient(saslMech, creds)\n\n\t_, resp, err := client.Step(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = cn.WithWriter(c, db.opt.WriteTimeout, func(wb *pool.WriteBuffer) error {\n\t\twb.StartMessage(saslInitialResponseMsg)\n\t\twb.WriteString(saslMech.Name)\n\t\twb.WriteInt32(int32(len(resp)))\n\t\t_, err := wb.Write(resp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\twb.FinishMessage()\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttyp, n, err := readMessageType(rd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch typ {\n\tcase authenticationSASLContinueMsg:\n\t\tc11, err := readInt32(rd)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif c11 != 11 {\n\t\t\treturn fmt.Errorf(\"pg: SASL: got %q, wanted %q\", typ, 11)\n\t\t}\n\n\t\tb, err := rd.ReadN(n - 4)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, resp, err = client.Step(b)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = cn.WithWriter(c, db.opt.WriteTimeout, func(wb *pool.WriteBuffer) error {\n\t\t\twb.StartMessage(saslResponseMsg)\n\t\t\t_, err := wb.Write(resp)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\twb.FinishMessage()\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn readAuthSASLFinal(rd, client)\n\tcase errorResponseMsg:\n\t\te, err := readError(rd)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn e\n\tdefault:\n\t\treturn fmt.Errorf(\n\t\t\t\"pg: SASL: got %q, wanted %q\", typ, authenticationSASLContinueMsg)\n\t}\n}\n\nfunc readAuthSASLFinal(rd *pool.ReaderContext, client *sasl.Negotiator) error {\n\tc, n, err := readMessageType(rd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch c {\n\tcase authenticationSASLFinalMsg:\n\t\tc12, err := readInt32(rd)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif c12 != 12 {\n\t\t\treturn fmt.Errorf(\"pg: SASL: got %q, wanted %q\", c, 12)\n\t\t}\n\n\t\tb, err := rd.ReadN(n - 4)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, _, err = client.Step(b)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif client.State() != sasl.ValidServerResponse {\n\t\t\treturn fmt.Errorf(\"pg: SASL: state=%q, wanted %q\",\n\t\t\t\tclient.State(), sasl.ValidServerResponse)\n\t\t}\n\tcase errorResponseMsg:\n\t\te, err := readError(rd)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn e\n\tdefault:\n\t\treturn fmt.Errorf(\n\t\t\t\"pg: SASL: got %q, wanted %q\", c, authenticationSASLFinalMsg)\n\t}\n\n\treturn readAuthOK(rd)\n}\n\nfunc md5s(s string) string {\n\t//nolint\n\th := md5.Sum([]byte(s))\n\treturn hex.EncodeToString(h[:])\n}\n\nfunc writeStartupMsg(buf *pool.WriteBuffer, user, database, appName string) {\n\tbuf.StartMessage(0)\n\tbuf.WriteInt32(196608)\n\tbuf.WriteString(\"user\")\n\tbuf.WriteString(user)\n\tbuf.WriteString(\"database\")\n\tbuf.WriteString(database)\n\tif appName != \"\" {\n\t\tbuf.WriteString(\"application_name\")\n\t\tbuf.WriteString(appName)\n\t}\n\tbuf.WriteString(\"\")\n\tbuf.FinishMessage()\n}\n\nfunc writeSSLMsg(buf *pool.WriteBuffer) {\n\tbuf.StartMessage(0)\n\tbuf.WriteInt32(80877103)\n\tbuf.FinishMessage()\n}\n\nfunc writePasswordMsg(buf *pool.WriteBuffer, password string) {\n\tbuf.StartMessage(passwordMessageMsg)\n\tbuf.WriteString(password)\n\tbuf.FinishMessage()\n}\n\nfunc writeFlushMsg(buf *pool.WriteBuffer) {\n\tbuf.StartMessage(flushMsg)\n\tbuf.FinishMessage()\n}\n\nfunc writeCancelRequestMsg(buf *pool.WriteBuffer, processID, secretKey int32) {\n\tbuf.StartMessage(0)\n\tbuf.WriteInt32(80877102)\n\tbuf.WriteInt32(processID)\n\tbuf.WriteInt32(secretKey)\n\tbuf.FinishMessage()\n}\n\nfunc writeQueryMsg(\n\tbuf *pool.WriteBuffer,\n\tfmter orm.QueryFormatter,\n\tquery interface{},\n\tparams ...interface{},\n) error {\n\tbuf.StartMessage(queryMsg)\n\tbytes, err := appendQuery(fmter, buf.Bytes, query, params...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf.Bytes = bytes\n\terr = buf.WriteByte(0x0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf.FinishMessage()\n\treturn nil\n}\n\nfunc appendQuery(fmter orm.QueryFormatter, dst []byte, query interface{}, params ...interface{}) ([]byte, error) {\n\tswitch query := query.(type) {\n\tcase orm.QueryAppender:\n\t\tif v, ok := fmter.(*orm.Formatter); ok {\n\t\t\tfmter = v.WithModel(query)\n\t\t}\n\t\treturn query.AppendQuery(fmter, dst)\n\tcase string:\n\t\tif len(params) > 0 {\n\t\t\tmodel, ok := params[len(params)-1].(orm.TableModel)\n\t\t\tif ok {\n\t\t\t\tif v, ok := fmter.(*orm.Formatter); ok {\n\t\t\t\t\tfmter = v.WithTableModel(model)\n\t\t\t\t\tparams = params[:len(params)-1]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn fmter.FormatQuery(dst, query, params...), nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"pg: can't append %T\", query)\n\t}\n}\n\nfunc writeSyncMsg(buf *pool.WriteBuffer) {\n\tbuf.StartMessage(syncMsg)\n\tbuf.FinishMessage()\n}\n\nfunc writeParseDescribeSyncMsg(buf *pool.WriteBuffer, name, q string) {\n\tbuf.StartMessage(parseMsg)\n\tbuf.WriteString(name)\n\tbuf.WriteString(q)\n\tbuf.WriteInt16(0)\n\tbuf.FinishMessage()\n\n\tbuf.StartMessage(describeMsg)\n\tbuf.WriteByte('S') //nolint\n\tbuf.WriteString(name)\n\tbuf.FinishMessage()\n\n\twriteSyncMsg(buf)\n}\n\nfunc readParseDescribeSync(rd *pool.ReaderContext) ([]types.ColumnInfo, error) {\n\tvar columns []types.ColumnInfo\n\tvar firstErr error\n\tfor {\n\t\tc, msgLen, err := readMessageType(rd)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tswitch c {\n\t\tcase parseCompleteMsg:\n\t\t\t_, err = rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase rowDescriptionMsg: // Response to the DESCRIBE message.\n\t\t\tcolumns, err = readRowDescription(rd, pool.NewColumnAlloc())\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase parameterDescriptionMsg: // Response to the DESCRIBE message.\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase noDataMsg: // Response to the DESCRIBE message.\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase readyForQueryMsg:\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif firstErr != nil {\n\t\t\t\treturn nil, firstErr\n\t\t\t}\n\t\t\treturn columns, err\n\t\tcase errorResponseMsg:\n\t\t\te, err := readError(rd)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif firstErr == nil {\n\t\t\t\tfirstErr = e\n\t\t\t}\n\t\tcase noticeResponseMsg:\n\t\t\tif err := logNotice(rd, msgLen); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase parameterStatusMsg:\n\t\t\tif err := logParameterStatus(rd, msgLen); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"pg: readParseDescribeSync: unexpected message %q\", c)\n\t\t}\n\t}\n}\n\n// Writes BIND, EXECUTE and SYNC messages.\nfunc writeBindExecuteMsg(buf *pool.WriteBuffer, name string, params ...interface{}) error {\n\tbuf.StartMessage(bindMsg)\n\tbuf.WriteString(\"\")\n\tbuf.WriteString(name)\n\tbuf.WriteInt16(0)\n\tbuf.WriteInt16(int16(len(params)))\n\tfor _, param := range params {\n\t\tbuf.StartParam()\n\t\tbytes := types.Append(buf.Bytes, param, 0)\n\t\tif bytes != nil {\n\t\t\tbuf.Bytes = bytes\n\t\t\tbuf.FinishParam()\n\t\t} else {\n\t\t\tbuf.FinishNullParam()\n\t\t}\n\t}\n\tbuf.WriteInt16(0)\n\tbuf.FinishMessage()\n\n\tbuf.StartMessage(executeMsg)\n\tbuf.WriteString(\"\")\n\tbuf.WriteInt32(0)\n\tbuf.FinishMessage()\n\n\twriteSyncMsg(buf)\n\n\treturn nil\n}\n\nfunc writeCloseMsg(buf *pool.WriteBuffer, name string) {\n\tbuf.StartMessage(closeMsg)\n\tbuf.WriteByte('S') //nolint\n\tbuf.WriteString(name)\n\tbuf.FinishMessage()\n}\n\nfunc readCloseCompleteMsg(rd *pool.ReaderContext) error {\n\tfor {\n\t\tc, msgLen, err := readMessageType(rd)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tswitch c {\n\t\tcase closeCompleteMsg:\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\treturn err\n\t\tcase errorResponseMsg:\n\t\t\te, err := readError(rd)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn e\n\t\tcase noticeResponseMsg:\n\t\t\tif err := logNotice(rd, msgLen); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase parameterStatusMsg:\n\t\t\tif err := logParameterStatus(rd, msgLen); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"pg: readCloseCompleteMsg: unexpected message %q\", c)\n\t\t}\n\t}\n}\n\nfunc readSimpleQuery(rd *pool.ReaderContext) (*result, error) {\n\tvar res result\n\tvar firstErr error\n\tfor {\n\t\tc, msgLen, err := readMessageType(rd)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tswitch c {\n\t\tcase commandCompleteMsg:\n\t\t\tb, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif err := res.parse(b); err != nil && firstErr == nil {\n\t\t\t\tfirstErr = err\n\t\t\t}\n\t\tcase readyForQueryMsg:\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif firstErr != nil {\n\t\t\t\treturn nil, firstErr\n\t\t\t}\n\t\t\treturn &res, nil\n\t\tcase rowDescriptionMsg:\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase dataRowMsg:\n\t\t\tif _, err := rd.Discard(msgLen); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tres.returned++\n\t\tcase errorResponseMsg:\n\t\t\te, err := readError(rd)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif firstErr == nil {\n\t\t\t\tfirstErr = e\n\t\t\t}\n\t\tcase emptyQueryResponseMsg:\n\t\t\tif firstErr == nil {\n\t\t\t\tfirstErr = errEmptyQuery\n\t\t\t}\n\t\tcase noticeResponseMsg:\n\t\t\tif err := logNotice(rd, msgLen); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase parameterStatusMsg:\n\t\t\tif err := logParameterStatus(rd, msgLen); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"pg: readSimpleQuery: unexpected message %q\", c)\n\t\t}\n\t}\n}\n\nfunc readExtQuery(rd *pool.ReaderContext) (*result, error) {\n\tvar res result\n\tvar firstErr error\n\tfor {\n\t\tc, msgLen, err := readMessageType(rd)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tswitch c {\n\t\tcase bindCompleteMsg:\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase dataRowMsg:\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tres.returned++\n\t\tcase commandCompleteMsg: // Response to the EXECUTE message.\n\t\t\tb, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif err := res.parse(b); err != nil && firstErr == nil {\n\t\t\t\tfirstErr = err\n\t\t\t}\n\t\tcase readyForQueryMsg: // Response to the SYNC message.\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif firstErr != nil {\n\t\t\t\treturn nil, firstErr\n\t\t\t}\n\t\t\treturn &res, nil\n\t\tcase errorResponseMsg:\n\t\t\te, err := readError(rd)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif firstErr == nil {\n\t\t\t\tfirstErr = e\n\t\t\t}\n\t\tcase emptyQueryResponseMsg:\n\t\t\tif firstErr == nil {\n\t\t\t\tfirstErr = errEmptyQuery\n\t\t\t}\n\t\tcase noticeResponseMsg:\n\t\t\tif err := logNotice(rd, msgLen); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase parameterStatusMsg:\n\t\t\tif err := logParameterStatus(rd, msgLen); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"pg: readExtQuery: unexpected message %q\", c)\n\t\t}\n\t}\n}\n\nfunc readRowDescription(\n\trd *pool.ReaderContext, columnAlloc *pool.ColumnAlloc,\n) ([]types.ColumnInfo, error) {\n\tnumCol, err := readInt16(rd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor i := 0; i < int(numCol); i++ {\n\t\tb, err := rd.ReadSlice(0)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tcol := columnAlloc.New(int16(i), b[:len(b)-1])\n\n\t\tif _, err := rd.ReadN(6); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdataType, err := readInt32(rd)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcol.DataType = dataType\n\n\t\tif _, err := rd.ReadN(8); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn columnAlloc.Columns(), nil\n}\n\nfunc readDataRow(\n\tctx context.Context,\n\trd *pool.ReaderContext,\n\tcolumns []types.ColumnInfo,\n\tscanner orm.ColumnScanner,\n) error {\n\tnumCol, err := readInt16(rd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif h, ok := scanner.(orm.BeforeScanHook); ok {\n\t\tif err := h.BeforeScan(ctx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tvar firstErr error\n\n\tfor colIdx := int16(0); colIdx < numCol; colIdx++ {\n\t\tn, err := readInt32(rd)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar colRd types.Reader\n\t\tif int(n) <= rd.Buffered() {\n\t\t\tcolRd = rd.BytesReader(int(n))\n\t\t} else {\n\t\t\trd.SetAvailable(int(n))\n\t\t\tcolRd = rd\n\t\t}\n\n\t\tcolumn := columns[colIdx]\n\t\tif err := scanner.ScanColumn(column, colRd, int(n)); err != nil && firstErr == nil {\n\t\t\tfirstErr = internal.Errorf(err.Error())\n\t\t}\n\n\t\tif rd == colRd {\n\t\t\tif rd.Available() > 0 {\n\t\t\t\tif _, err := rd.Discard(rd.Available()); err != nil && firstErr == nil {\n\t\t\t\t\tfirstErr = err\n\t\t\t\t}\n\t\t\t}\n\t\t\trd.SetAvailable(-1)\n\t\t}\n\t}\n\n\tif h, ok := scanner.(orm.AfterScanHook); ok {\n\t\tif err := h.AfterScan(ctx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn firstErr\n}\n\nfunc newModel(mod interface{}) (orm.Model, error) {\n\tm, err := orm.NewModel(mod)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn m, m.Init()\n}\n\nfunc readSimpleQueryData(\n\tctx context.Context, rd *pool.ReaderContext, mod interface{},\n) (*result, error) {\n\tvar columns []types.ColumnInfo\n\tvar res result\n\tvar firstErr error\n\tfor {\n\t\tc, msgLen, err := readMessageType(rd)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tswitch c {\n\t\tcase rowDescriptionMsg:\n\t\t\tcolumns, err = readRowDescription(rd, rd.ColumnAlloc)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif res.model == nil {\n\t\t\t\tvar err error\n\t\t\t\tres.model, err = newModel(mod)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif firstErr == nil {\n\t\t\t\t\t\tfirstErr = err\n\t\t\t\t\t}\n\t\t\t\t\tres.model = Discard\n\t\t\t\t}\n\t\t\t}\n\t\tcase dataRowMsg:\n\t\t\tscanner := res.model.NextColumnScanner()\n\t\t\tif err := readDataRow(ctx, rd, columns, scanner); err != nil {\n\t\t\t\tif firstErr == nil {\n\t\t\t\t\tfirstErr = err\n\t\t\t\t}\n\t\t\t} else if err := res.model.AddColumnScanner(scanner); err != nil {\n\t\t\t\tif firstErr == nil {\n\t\t\t\t\tfirstErr = err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tres.returned++\n\t\tcase commandCompleteMsg:\n\t\t\tb, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif err := res.parse(b); err != nil && firstErr == nil {\n\t\t\t\tfirstErr = err\n\t\t\t}\n\t\tcase readyForQueryMsg:\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif firstErr != nil {\n\t\t\t\treturn nil, firstErr\n\t\t\t}\n\t\t\treturn &res, nil\n\t\tcase errorResponseMsg:\n\t\t\te, err := readError(rd)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif firstErr == nil {\n\t\t\t\tfirstErr = e\n\t\t\t}\n\t\tcase emptyQueryResponseMsg:\n\t\t\tif firstErr == nil {\n\t\t\t\tfirstErr = errEmptyQuery\n\t\t\t}\n\t\tcase noticeResponseMsg:\n\t\t\tif err := logNotice(rd, msgLen); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase parameterStatusMsg:\n\t\t\tif err := logParameterStatus(rd, msgLen); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"pg: readSimpleQueryData: unexpected message %q\", c)\n\t\t}\n\t}\n}\n\nfunc readExtQueryData(\n\tctx context.Context, rd *pool.ReaderContext, mod interface{}, columns []types.ColumnInfo,\n) (*result, error) {\n\tvar res result\n\tvar firstErr error\n\tfor {\n\t\tc, msgLen, err := readMessageType(rd)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tswitch c {\n\t\tcase bindCompleteMsg:\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase dataRowMsg:\n\t\t\tif res.model == nil {\n\t\t\t\tvar err error\n\t\t\t\tres.model, err = newModel(mod)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif firstErr == nil {\n\t\t\t\t\t\tfirstErr = err\n\t\t\t\t\t}\n\t\t\t\t\tres.model = Discard\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscanner := res.model.NextColumnScanner()\n\t\t\tif err := readDataRow(ctx, rd, columns, scanner); err != nil {\n\t\t\t\tif firstErr == nil {\n\t\t\t\t\tfirstErr = err\n\t\t\t\t}\n\t\t\t} else if err := res.model.AddColumnScanner(scanner); err != nil {\n\t\t\t\tif firstErr == nil {\n\t\t\t\t\tfirstErr = err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tres.returned++\n\t\tcase commandCompleteMsg: // Response to the EXECUTE message.\n\t\t\tb, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif err := res.parse(b); err != nil && firstErr == nil {\n\t\t\t\tfirstErr = err\n\t\t\t}\n\t\tcase readyForQueryMsg: // Response to the SYNC message.\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif firstErr != nil {\n\t\t\t\treturn nil, firstErr\n\t\t\t}\n\t\t\treturn &res, nil\n\t\tcase errorResponseMsg:\n\t\t\te, err := readError(rd)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif firstErr == nil {\n\t\t\t\tfirstErr = e\n\t\t\t}\n\t\tcase noticeResponseMsg:\n\t\t\tif err := logNotice(rd, msgLen); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase parameterStatusMsg:\n\t\t\tif err := logParameterStatus(rd, msgLen); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"pg: readExtQueryData: unexpected message %q\", c)\n\t\t}\n\t}\n}\n\nfunc readCopyInResponse(rd *pool.ReaderContext) error {\n\tvar firstErr error\n\tfor {\n\t\tc, msgLen, err := readMessageType(rd)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch c {\n\t\tcase copyInResponseMsg:\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\treturn err\n\t\tcase errorResponseMsg:\n\t\t\te, err := readError(rd)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif firstErr == nil {\n\t\t\t\tfirstErr = e\n\t\t\t}\n\t\tcase readyForQueryMsg:\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn firstErr\n\t\tcase noticeResponseMsg:\n\t\t\tif err := logNotice(rd, msgLen); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase parameterStatusMsg:\n\t\t\tif err := logParameterStatus(rd, msgLen); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"pg: readCopyInResponse: unexpected message %q\", c)\n\t\t}\n\t}\n}\n\nfunc readCopyOutResponse(rd *pool.ReaderContext) error {\n\tvar firstErr error\n\tfor {\n\t\tc, msgLen, err := readMessageType(rd)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch c {\n\t\tcase copyOutResponseMsg:\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\treturn err\n\t\tcase errorResponseMsg:\n\t\t\te, err := readError(rd)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif firstErr == nil {\n\t\t\t\tfirstErr = e\n\t\t\t}\n\t\tcase readyForQueryMsg:\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn firstErr\n\t\tcase noticeResponseMsg:\n\t\t\tif err := logNotice(rd, msgLen); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase parameterStatusMsg:\n\t\t\tif err := logParameterStatus(rd, msgLen); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"pg: readCopyOutResponse: unexpected message %q\", c)\n\t\t}\n\t}\n}\n\nfunc readCopyData(rd *pool.ReaderContext, w io.Writer) (*result, error) {\n\tvar res result\n\tvar firstErr error\n\tfor {\n\t\tc, msgLen, err := readMessageType(rd)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tswitch c {\n\t\tcase copyDataMsg:\n\t\t\tfor msgLen > 0 {\n\t\t\t\tb, err := rd.ReadN(msgLen)\n\t\t\t\tif err != nil && err != bufio.ErrBufferFull {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\t_, err = w.Write(b)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tmsgLen -= len(b)\n\t\t\t}\n\t\tcase copyDoneMsg:\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase commandCompleteMsg:\n\t\t\tb, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif err := res.parse(b); err != nil && firstErr == nil {\n\t\t\t\tfirstErr = err\n\t\t\t}\n\t\tcase readyForQueryMsg:\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif firstErr != nil {\n\t\t\t\treturn nil, firstErr\n\t\t\t}\n\t\t\treturn &res, nil\n\t\tcase errorResponseMsg:\n\t\t\te, err := readError(rd)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn nil, e\n\t\tcase noticeResponseMsg:\n\t\t\tif err := logNotice(rd, msgLen); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase parameterStatusMsg:\n\t\t\tif err := logParameterStatus(rd, msgLen); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"pg: readCopyData: unexpected message %q\", c)\n\t\t}\n\t}\n}\n\nfunc writeCopyData(buf *pool.WriteBuffer, r io.Reader) error {\n\tbuf.StartMessage(copyDataMsg)\n\t_, err := buf.ReadFrom(r)\n\tbuf.FinishMessage()\n\treturn err\n}\n\nfunc writeCopyDone(buf *pool.WriteBuffer) {\n\tbuf.StartMessage(copyDoneMsg)\n\tbuf.FinishMessage()\n}\n\nfunc readReadyForQuery(rd *pool.ReaderContext) (*result, error) {\n\tvar res result\n\tvar firstErr error\n\tfor {\n\t\tc, msgLen, err := readMessageType(rd)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tswitch c {\n\t\tcase commandCompleteMsg:\n\t\t\tb, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif err := res.parse(b); err != nil && firstErr == nil {\n\t\t\t\tfirstErr = err\n\t\t\t}\n\t\tcase readyForQueryMsg:\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif firstErr != nil {\n\t\t\t\treturn nil, firstErr\n\t\t\t}\n\t\t\treturn &res, nil\n\t\tcase errorResponseMsg:\n\t\t\te, err := readError(rd)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif firstErr == nil {\n\t\t\t\tfirstErr = e\n\t\t\t}\n\t\tcase noticeResponseMsg:\n\t\t\tif err := logNotice(rd, msgLen); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase parameterStatusMsg:\n\t\t\tif err := logParameterStatus(rd, msgLen); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"pg: readReadyForQueryOrError: unexpected message %q\", c)\n\t\t}\n\t}\n}\n\nfunc readNotification(rd *pool.ReaderContext) (channel, payload string, err error) {\n\tfor {\n\t\tc, msgLen, err := readMessageType(rd)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\n\t\tswitch c {\n\t\tcase commandCompleteMsg:\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", \"\", err\n\t\t\t}\n\t\tcase readyForQueryMsg:\n\t\t\t_, err := rd.ReadN(msgLen)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", \"\", err\n\t\t\t}\n\t\tcase errorResponseMsg:\n\t\t\te, err := readError(rd)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", \"\", err\n\t\t\t}\n\t\t\treturn \"\", \"\", e\n\t\tcase noticeResponseMsg:\n\t\t\tif err := logNotice(rd, msgLen); err != nil {\n\t\t\t\treturn \"\", \"\", err\n\t\t\t}\n\t\tcase notificationResponseMsg:\n\t\t\t_, err := readInt32(rd)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", \"\", err\n\t\t\t}\n\t\t\tchannel, err = readString(rd)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", \"\", err\n\t\t\t}\n\t\t\tpayload, err = readString(rd)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", \"\", err\n\t\t\t}\n\t\t\treturn channel, payload, nil\n\t\tdefault:\n\t\t\treturn \"\", \"\", fmt.Errorf(\"pg: readNotification: unexpected message %q\", c)\n\t\t}\n\t}\n}\n\nvar terminateMessage = []byte{terminateMsg, 0, 0, 0, 4}\n\nfunc terminateConn(cn *pool.Conn) error {\n\t// Don't use cn.Buf because it is racy with user code.\n\t_, err := cn.NetConn().Write(terminateMessage)\n\treturn err\n}\n\n//------------------------------------------------------------------------------\n\nfunc logNotice(rd *pool.ReaderContext, msgLen int) error {\n\t_, err := rd.ReadN(msgLen)\n\treturn err\n}\n\nfunc logParameterStatus(rd *pool.ReaderContext, msgLen int) error {\n\t_, err := rd.ReadN(msgLen)\n\treturn err\n}\n\nfunc readInt16(rd *pool.ReaderContext) (int16, error) {\n\tb, err := rd.ReadN(2)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn int16(binary.BigEndian.Uint16(b)), nil\n}\n\nfunc readInt32(rd *pool.ReaderContext) (int32, error) {\n\tb, err := rd.ReadN(4)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn int32(binary.BigEndian.Uint32(b)), nil\n}\n\nfunc readString(rd *pool.ReaderContext) (string, error) {\n\tb, err := rd.ReadSlice(0)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(b[:len(b)-1]), nil\n}\n\nfunc readError(rd *pool.ReaderContext) (error, error) {\n\tm := make(map[byte]string)\n\tfor {\n\t\tc, err := rd.ReadByte()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif c == 0 {\n\t\t\tbreak\n\t\t}\n\t\ts, err := readString(rd)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tm[c] = s\n\t}\n\treturn internal.NewPGError(m), nil\n}\n\nfunc readMessageType(rd *pool.ReaderContext) (byte, int, error) {\n\tc, err := rd.ReadByte()\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\tl, err := readInt32(rd)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\treturn c, int(l) - 4, nil\n}\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 8.578125,
          "content": "package pg\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/url\"\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/go-pg/pg/v10/internal/pool\"\n)\n\n// Options contains database connection options.\ntype Options struct {\n\t// Network type, either tcp or unix.\n\t// Default is tcp.\n\tNetwork string\n\t// TCP host:port or Unix socket depending on Network.\n\tAddr string\n\n\t// Dialer creates new network connection and has priority over\n\t// Network and Addr options.\n\tDialer func(ctx context.Context, network, addr string) (net.Conn, error)\n\n\t// Hook that is called after new connection is established\n\t// and user is authenticated.\n\tOnConnect func(ctx context.Context, cn *Conn) error\n\n\tUser     string\n\tPassword string\n\tDatabase string\n\n\t// ApplicationName is the application name. Used in logs on Pg side.\n\t// Only available from pg-9.0.\n\tApplicationName string\n\n\t// TLS config for secure connections.\n\tTLSConfig *tls.Config\n\n\t// Dial timeout for establishing new connections.\n\t// Default is 5 seconds.\n\tDialTimeout time.Duration\n\n\t// Timeout for socket reads. If reached, commands will fail\n\t// with a timeout instead of blocking.\n\tReadTimeout time.Duration\n\t// Timeout for socket writes. If reached, commands will fail\n\t// with a timeout instead of blocking.\n\tWriteTimeout time.Duration\n\n\t// Maximum number of retries before giving up.\n\t// Default is to not retry failed queries.\n\tMaxRetries int\n\t// Whether to retry queries cancelled because of statement_timeout.\n\tRetryStatementTimeout bool\n\t// Minimum backoff between each retry.\n\t// Default is 250 milliseconds; -1 disables backoff.\n\tMinRetryBackoff time.Duration\n\t// Maximum backoff between each retry.\n\t// Default is 4 seconds; -1 disables backoff.\n\tMaxRetryBackoff time.Duration\n\n\t// Maximum number of socket connections.\n\t// Default is 10 connections per every CPU as reported by runtime.NumCPU.\n\tPoolSize int\n\t// Minimum number of idle connections which is useful when establishing\n\t// new connection is slow.\n\tMinIdleConns int\n\t// Connection age at which client retires (closes) the connection.\n\t// It is useful with proxies like PgBouncer and HAProxy.\n\t// Default is to not close aged connections.\n\tMaxConnAge time.Duration\n\t// Time for which client waits for free connection if all\n\t// connections are busy before returning an error.\n\t// Default is 30 seconds if ReadTimeOut is not defined, otherwise,\n\t// ReadTimeout + 1 second.\n\tPoolTimeout time.Duration\n\t// Amount of time after which client closes idle connections.\n\t// Should be less than server's timeout.\n\t// Default is 5 minutes. -1 disables idle timeout check.\n\tIdleTimeout time.Duration\n\t// Frequency of idle checks made by idle connections reaper.\n\t// Default is 1 minute. -1 disables idle connections reaper,\n\t// but idle connections are still discarded by the client\n\t// if IdleTimeout is set.\n\tIdleCheckFrequency time.Duration\n\t// Connections read buffers stored in a sync.Pool to reduce allocations.\n\t// Using this option you can adjust the initial size of the buffer.\n\t// Default is 1 Mb.\n\tReadBufferInitialSize int\n\t// Connections write buffers stored in a sync.Pool to reduce allocations.\n\t// Using this option you can adjust the initial size of the buffer.\n\t// Default is 64 Kb.\n\tWriteBufferInitialSize int\n}\n\nfunc (opt *Options) init() {\n\tif opt.Network == \"\" {\n\t\topt.Network = \"tcp\"\n\t}\n\n\tif opt.Addr == \"\" {\n\t\tswitch opt.Network {\n\t\tcase \"tcp\":\n\t\t\thost := env(\"PGHOST\", \"localhost\")\n\t\t\tport := env(\"PGPORT\", \"5432\")\n\t\t\topt.Addr = fmt.Sprintf(\"%s:%s\", host, port)\n\t\tcase \"unix\":\n\t\t\topt.Addr = \"/var/run/postgresql/.s.PGSQL.5432\"\n\t\t}\n\t}\n\n\tif opt.DialTimeout == 0 {\n\t\topt.DialTimeout = 5 * time.Second\n\t}\n\tif opt.Dialer == nil {\n\t\topt.Dialer = func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\t\tnetDialer := &net.Dialer{\n\t\t\t\tTimeout:   opt.DialTimeout,\n\t\t\t\tKeepAlive: 5 * time.Minute,\n\t\t\t}\n\t\t\treturn netDialer.DialContext(ctx, network, addr)\n\t\t}\n\t}\n\n\tif opt.User == \"\" {\n\t\topt.User = env(\"PGUSER\", \"postgres\")\n\t}\n\n\tif opt.Password == \"\" {\n\t\topt.Password = env(\"PGPASSWORD\", \"postgres\")\n\t}\n\n\tif opt.Database == \"\" {\n\t\topt.Database = env(\"PGDATABASE\", \"postgres\")\n\t}\n\n\tif opt.PoolSize == 0 {\n\t\topt.PoolSize = 10 * runtime.NumCPU()\n\t}\n\n\tif opt.PoolTimeout == 0 {\n\t\tif opt.ReadTimeout != 0 {\n\t\t\topt.PoolTimeout = opt.ReadTimeout + time.Second\n\t\t} else {\n\t\t\topt.PoolTimeout = 30 * time.Second\n\t\t}\n\t}\n\n\tif opt.IdleTimeout == 0 {\n\t\topt.IdleTimeout = 5 * time.Minute\n\t}\n\tif opt.IdleCheckFrequency == 0 {\n\t\topt.IdleCheckFrequency = time.Minute\n\t}\n\n\tswitch opt.MinRetryBackoff {\n\tcase -1:\n\t\topt.MinRetryBackoff = 0\n\tcase 0:\n\t\topt.MinRetryBackoff = 250 * time.Millisecond\n\t}\n\tswitch opt.MaxRetryBackoff {\n\tcase -1:\n\t\topt.MaxRetryBackoff = 0\n\tcase 0:\n\t\topt.MaxRetryBackoff = 4 * time.Second\n\t}\n\n\tif opt.ReadBufferInitialSize == 0 {\n\t\topt.ReadBufferInitialSize = 1048576 // 1Mb\n\t}\n\n\tif opt.WriteBufferInitialSize == 0 {\n\t\topt.WriteBufferInitialSize = 65536 // 64Kb\n\t}\n}\n\nfunc env(key, defValue string) string {\n\tenvValue := os.Getenv(key)\n\tif envValue != \"\" {\n\t\treturn envValue\n\t}\n\treturn defValue\n}\n\n// ParseURL parses an URL into options that can be used to connect to PostgreSQL.\nfunc ParseURL(sURL string) (*Options, error) {\n\tparsedURL, err := url.Parse(sURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// scheme\n\tif parsedURL.Scheme != \"postgres\" && parsedURL.Scheme != \"postgresql\" {\n\t\treturn nil, errors.New(\"pg: invalid scheme: \" + parsedURL.Scheme)\n\t}\n\n\t// host and port\n\toptions := &Options{\n\t\tAddr: parsedURL.Host,\n\t}\n\tif !strings.Contains(options.Addr, \":\") {\n\t\toptions.Addr += \":5432\"\n\t}\n\n\t// username and password\n\tif parsedURL.User != nil {\n\t\toptions.User = parsedURL.User.Username()\n\n\t\tif password, ok := parsedURL.User.Password(); ok {\n\t\t\toptions.Password = password\n\t\t}\n\t}\n\n\tif options.User == \"\" {\n\t\toptions.User = \"postgres\"\n\t}\n\n\t// database\n\tif len(strings.Trim(parsedURL.Path, \"/\")) > 0 {\n\t\toptions.Database = parsedURL.Path[1:]\n\t} else {\n\t\treturn nil, errors.New(\"pg: database name not provided\")\n\t}\n\n\t// ssl mode\n\tquery, err := url.ParseQuery(parsedURL.RawQuery)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif sslMode, ok := query[\"sslmode\"]; ok && len(sslMode) > 0 {\n\t\tswitch sslMode[0] {\n\t\tcase \"verify-ca\", \"verify-full\":\n\t\t\toptions.TLSConfig = &tls.Config{}\n\t\tcase \"allow\", \"prefer\", \"require\":\n\t\t\toptions.TLSConfig = &tls.Config{InsecureSkipVerify: true} //nolint\n\t\tcase \"disable\":\n\t\t\toptions.TLSConfig = nil\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"pg: sslmode '%v' is not supported\", sslMode[0])\n\t\t}\n\t} else {\n\t\toptions.TLSConfig = &tls.Config{InsecureSkipVerify: true} //nolint\n\t}\n\n\tdelete(query, \"sslmode\")\n\n\tif appName, ok := query[\"application_name\"]; ok && len(appName) > 0 {\n\t\toptions.ApplicationName = appName[0]\n\t}\n\n\tdelete(query, \"application_name\")\n\n\tif connTimeout, ok := query[\"connect_timeout\"]; ok && len(connTimeout) > 0 {\n\t\tct, err := strconv.Atoi(connTimeout[0])\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"pg: cannot parse connect_timeout option as int\")\n\t\t}\n\t\toptions.DialTimeout = time.Second * time.Duration(ct)\n\t}\n\n\tdelete(query, \"connect_timeout\")\n\n\tif len(query) > 0 {\n\t\treturn nil, errors.New(\"pg: options other than 'sslmode', 'application_name' and 'connect_timeout' are not supported\")\n\t}\n\n\treturn options, nil\n}\n\nfunc (opts *Options) ToURL() string {\n\tdsn := \"postgres://\"\n\n\tif len(opts.User) > 0 {\n\t\tdsn += opts.User\n\n\t\tif len(opts.Password) > 0 {\n\t\t\tdsn += \":\" + opts.Password\n\t\t}\n\n\t\tdsn += \"@\"\n\t}\n\n\tif len(opts.Addr) > 0 {\n\t\tdsn += opts.Addr\n\t} else {\n\t\tdsn += \"localhost:5432\"\n\t}\n\n\tdsn += \"/\" + opts.Database\n\n\tvalues := url.Values{}\n\n\tif opts.DialTimeout > 0 {\n\t\tvalues.Add(\"connect_timeout\", strconv.Itoa(int(opts.DialTimeout)/int(time.Second)))\n\t}\n\n\tif len(opts.ApplicationName) > 0 {\n\t\tvalues.Add(\"application_name\", opts.ApplicationName)\n\t}\n\n\tif opts.TLSConfig == nil {\n\t\tvalues.Add(\"sslmode\", \"disable\")\n\t} else if opts.TLSConfig.InsecureSkipVerify {\n\t\tvalues.Add(\"sslmode\", \"allow\")\n\t} else if !opts.TLSConfig.InsecureSkipVerify {\n\t\tvalues.Add(\"sslmode\", \"verify-ca\")\n\t}\n\n\tencoded := values.Encode()\n\tif len(encoded) > 0 {\n\t\tdsn += \"?\" + encoded\n\t}\n\n\treturn dsn\n}\n\nfunc (opt *Options) getDialer() func(context.Context) (net.Conn, error) {\n\treturn func(ctx context.Context) (net.Conn, error) {\n\t\treturn opt.Dialer(ctx, opt.Network, opt.Addr)\n\t}\n}\n\nfunc newConnPool(opt *Options) *pool.ConnPool {\n\treturn pool.NewConnPool(&pool.Options{\n\t\tDialer:  opt.getDialer(),\n\t\tOnClose: terminateConn,\n\n\t\tPoolSize:               opt.PoolSize,\n\t\tMinIdleConns:           opt.MinIdleConns,\n\t\tMaxConnAge:             opt.MaxConnAge,\n\t\tPoolTimeout:            opt.PoolTimeout,\n\t\tIdleTimeout:            opt.IdleTimeout,\n\t\tIdleCheckFrequency:     opt.IdleCheckFrequency,\n\t\tReadBufferInitialSize:  opt.ReadBufferInitialSize,\n\t\tWriteBufferInitialSize: opt.WriteBufferInitialSize,\n\t})\n}\n"
        },
        {
          "name": "options_test.go",
          "type": "blob",
          "size": 6.978515625,
          "content": "//go:build go1.7\n// +build go1.7\n\npackage pg\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestParseURL(t *testing.T) {\n\tcases := []struct {\n\t\turl         string\n\t\taddr        string\n\t\tuser        string\n\t\tpassword    string\n\t\tdatabase    string\n\t\tappName     string\n\t\tdialTimeout time.Duration\n\t\ttls         bool\n\t\terr         error\n\t}{\n\t\t{\n\t\t\t\"postgres://vasya:pupkin@somewhere.at.amazonaws.com:5432/postgres\",\n\t\t\t\"somewhere.at.amazonaws.com:5432\",\n\t\t\t\"vasya\",\n\t\t\t\"pupkin\",\n\t\t\t\"postgres\",\n\t\t\t\"\",\n\t\t\t0,\n\t\t\ttrue,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"postgres://vasya:pupkin@somewhere.at.amazonaws.com:5432/postgres?sslmode=allow\",\n\t\t\t\"somewhere.at.amazonaws.com:5432\",\n\t\t\t\"vasya\",\n\t\t\t\"pupkin\",\n\t\t\t\"postgres\",\n\t\t\t\"\",\n\t\t\t0,\n\t\t\ttrue,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"postgres://vasya:pupkin@somewhere.at.amazonaws.com:5432/postgres?sslmode=prefer\",\n\t\t\t\"somewhere.at.amazonaws.com:5432\",\n\t\t\t\"vasya\",\n\t\t\t\"pupkin\",\n\t\t\t\"postgres\",\n\t\t\t\"\",\n\t\t\t0,\n\t\t\ttrue,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"postgres://vasya:pupkin@somewhere.at.amazonaws.com:5432/postgres?sslmode=require\",\n\t\t\t\"somewhere.at.amazonaws.com:5432\",\n\t\t\t\"vasya\",\n\t\t\t\"pupkin\",\n\t\t\t\"postgres\",\n\t\t\t\"\",\n\t\t\t0,\n\t\t\ttrue,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"postgres://vasya:pupkin@somewhere.at.amazonaws.com:5432/postgres?sslmode=verify-ca\",\n\t\t\t\"somewhere.at.amazonaws.com:5432\",\n\t\t\t\"vasya\",\n\t\t\t\"pupkin\",\n\t\t\t\"postgres\",\n\t\t\t\"\",\n\t\t\t0,\n\t\t\ttrue,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"postgres://vasya:pupkin@somewhere.at.amazonaws.com:5432/postgres?sslmode=verify-full\",\n\t\t\t\"somewhere.at.amazonaws.com:5432\",\n\t\t\t\"vasya\",\n\t\t\t\"pupkin\",\n\t\t\t\"postgres\",\n\t\t\t\"\",\n\t\t\t0,\n\t\t\ttrue,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"postgres://vasya:pupkin@somewhere.at.amazonaws.com:5432/postgres?sslmode=disable\",\n\t\t\t\"somewhere.at.amazonaws.com:5432\",\n\t\t\t\"vasya\",\n\t\t\t\"pupkin\",\n\t\t\t\"postgres\",\n\t\t\t\"\",\n\t\t\t0,\n\t\t\tfalse,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"postgres://vasya:pupkin@somewhere.at.amazonaws.com:5432/postgres?sslmode=disable&application_name=myApp\",\n\t\t\t\"somewhere.at.amazonaws.com:5432\",\n\t\t\t\"vasya\",\n\t\t\t\"pupkin\",\n\t\t\t\"postgres\",\n\t\t\t\"myApp\",\n\t\t\t0,\n\t\t\tfalse,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"postgres://vasya:pupkin@somewhere.at.amazonaws.com:5432/postgres?application_name=myApp\",\n\t\t\t\"somewhere.at.amazonaws.com:5432\",\n\t\t\t\"vasya\",\n\t\t\t\"pupkin\",\n\t\t\t\"postgres\",\n\t\t\t\"myApp\",\n\t\t\t0,\n\t\t\tfalse,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"postgres://vasya:pupkin@somewhere.at.amazonaws.com:5432/\",\n\t\t\t\"somewhere.at.amazonaws.com:5432\",\n\t\t\t\"vasya\",\n\t\t\t\"pupkin\",\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t\t0,\n\t\t\ttrue,\n\t\t\terrors.New(\"pg: database name not provided\"),\n\t\t},\n\t\t{\n\t\t\t\"postgres://vasya:pupkin@somewhere.at.amazonaws.com/postgres\",\n\t\t\t\"somewhere.at.amazonaws.com:5432\",\n\t\t\t\"vasya\",\n\t\t\t\"pupkin\",\n\t\t\t\"postgres\",\n\t\t\t\"\",\n\t\t\t0,\n\t\t\ttrue,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"postgres://vasya:pupkin@somewhere.at.amazonaws.com:5432/postgres?abc=123\",\n\t\t\t\"somewhere.at.amazonaws.com:5432\",\n\t\t\t\"vasya\",\n\t\t\t\"pupkin\",\n\t\t\t\"postgres\",\n\t\t\t\"\",\n\t\t\t0,\n\t\t\ttrue,\n\t\t\terrors.New(\"pg: options other than 'sslmode', 'application_name' and 'connect_timeout' are not supported\"),\n\t\t},\n\t\t{\n\t\t\t\"postgres://vasya@somewhere.at.amazonaws.com:5432/postgres\",\n\t\t\t\"somewhere.at.amazonaws.com:5432\",\n\t\t\t\"vasya\",\n\t\t\t\"\",\n\t\t\t\"postgres\",\n\t\t\t\"\",\n\t\t\t0,\n\t\t\ttrue,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"postgres://somewhere.at.amazonaws.com:5432/postgres\",\n\t\t\t\"somewhere.at.amazonaws.com:5432\",\n\t\t\t\"postgres\",\n\t\t\t\"\",\n\t\t\t\"postgres\",\n\t\t\t\"\",\n\t\t\t0,\n\t\t\ttrue,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"postgresql://somewhere.at.amazonaws.com:5432/postgres\",\n\t\t\t\"somewhere.at.amazonaws.com:5432\",\n\t\t\t\"postgres\",\n\t\t\t\"\",\n\t\t\t\"postgres\",\n\t\t\t\"\",\n\t\t\t0,\n\t\t\ttrue,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"http://google.com/test\",\n\t\t\t\"google.com:5432\",\n\t\t\t\"postgres\",\n\t\t\t\"\",\n\t\t\t\"test\",\n\t\t\t\"\",\n\t\t\t0,\n\t\t\ttrue,\n\t\t\terrors.New(\"pg: invalid scheme: http\"),\n\t\t},\n\t\t{\n\t\t\t\"postgresql://pg.example.com:5432/db?connect_timeout=10\",\n\t\t\t\"pg.example.com:5432\",\n\t\t\t\"postgres\",\n\t\t\t\"\",\n\t\t\t\"db\",\n\t\t\t\"\",\n\t\t\ttime.Second * 10,\n\t\t\ttrue,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"postgresql://pg.example.com:5432/db?connect_timeout=10s\",\n\t\t\t\"pg.example.com:5432\",\n\t\t\t\"postgres\",\n\t\t\t\"\",\n\t\t\t\"db\",\n\t\t\t\"\",\n\t\t\t0,\n\t\t\ttrue,\n\t\t\terrors.New(\"pg: cannot parse connect_timeout option as int\"),\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.url, func(t *testing.T) {\n\t\t\to, err := ParseURL(c.url)\n\t\t\tif c.err == nil && err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: '%q'\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif c.err != nil && err != nil {\n\t\t\t\tif c.err.Error() != err.Error() {\n\t\t\t\t\tt.Fatalf(\"expected error %q, want %q\", err, c.err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif c.err != nil && err == nil {\n\t\t\t\tt.Errorf(\"expected error %q, got nothing\", c.err)\n\t\t\t}\n\t\t\tif o.Addr != c.addr {\n\t\t\t\tt.Errorf(\"addr: got %q, want %q\", o.Addr, c.addr)\n\t\t\t}\n\t\t\tif o.User != c.user {\n\t\t\t\tt.Errorf(\"user: got %q, want %q\", o.User, c.user)\n\t\t\t}\n\t\t\tif o.Password != c.password {\n\t\t\t\tt.Errorf(\"password: got %q, want %q\", o.Password, c.password)\n\t\t\t}\n\t\t\tif o.Database != c.database {\n\t\t\t\tt.Errorf(\"database: got %q, want %q\", o.Database, c.database)\n\t\t\t}\n\t\t\tif o.ApplicationName != c.appName {\n\t\t\t\tt.Errorf(\"appName: got %q, want %q\", o.ApplicationName, c.appName)\n\t\t\t}\n\n\t\t\tif c.tls {\n\t\t\t\tif o.TLSConfig == nil {\n\t\t\t\t\tt.Error(\"got nil TLSConfig, expected a TLSConfig\")\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestOptions_ToURL(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\topts     *Options\n\t\texpected string\n\t}{\n\t\t{\"Empty\", &Options{Database: \"postgres\"}, \"postgres://localhost:5432/postgres?sslmode=disable\"},\n\t\t{\"User\", &Options{Database: \"postgres\", User: \"postgres\"}, \"postgres://postgres@localhost:5432/postgres?sslmode=disable\"},\n\t\t{\"UserPass\", &Options{Database: \"postgres\", User: \"postgres\", Password: \"password\"}, \"postgres://postgres:password@localhost:5432/postgres?sslmode=disable\"},\n\t\t{\"UserPassAddr\", &Options{Database: \"postgres\", User: \"postgres\", Password: \"password\", Addr: \"somewhere:1234\"}, \"postgres://postgres:password@somewhere:1234/postgres?sslmode=disable\"},\n\t\t{\"UserPassAddrAppl\", &Options{Database: \"postgres\", User: \"postgres\", Password: \"password\", Addr: \"somewhere:1234\", ApplicationName: \"test\"}, \"postgres://postgres:password@somewhere:1234/postgres?application_name=test&sslmode=disable\"},\n\t\t{\"UserPassAddrApplTimeout\", &Options{Database: \"postgres\", User: \"postgres\", Password: \"password\", Addr: \"somewhere:1234\", ApplicationName: \"test\", DialTimeout: time.Second}, \"postgres://postgres:password@somewhere:1234/postgres?application_name=test&connect_timeout=1&sslmode=disable\"},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tassert := assert.New(t)\n\n\t\t\tactual := tt.opts.ToURL()\n\t\t\tassert.Equal(tt.expected, actual)\n\n\t\t\t_, err := ParseURL(actual)\n\t\t\tassert.NoError(err)\n\t\t})\n\t}\n}\n\nfunc TestOptions_ToURL_reparsable(t *testing.T) {\n\tassert := assert.New(t)\n\n\topts := &Options{\n\t\tDatabase:        \"postgres\",\n\t\tUser:            \"postgres\",\n\t\tPassword:        \"password\",\n\t\tAddr:            \"somewhere:1234\",\n\t\tApplicationName: \"test\",\n\t\tDialTimeout:     time.Second,\n\t}\n\n\turl := opts.ToURL()\n\n\tactual, err := ParseURL(url)\n\tassert.NoError(err)\n\n\tassert.Equal(opts.Database, actual.Database)\n\tassert.Equal(opts.User, actual.User)\n\tassert.Equal(opts.Password, actual.Password)\n\tassert.Equal(opts.Addr, actual.Addr)\n\tassert.Equal(opts.ApplicationName, actual.ApplicationName)\n\tassert.Equal(opts.DialTimeout, actual.DialTimeout)\n}\n"
        },
        {
          "name": "orm",
          "type": "tree",
          "content": null
        },
        {
          "name": "pg.go",
          "type": "blob",
          "size": 6.7978515625,
          "content": "package pg\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"strconv\"\n\n\t\"github.com/go-pg/pg/v10/internal\"\n\t\"github.com/go-pg/pg/v10/orm\"\n\t\"github.com/go-pg/pg/v10/types\"\n)\n\n// Discard is used with Query and QueryOne to discard rows.\nvar Discard orm.Discard\n\n// NullTime is a time.Time wrapper that marshals zero time as JSON null and\n// PostgreSQL NULL.\ntype NullTime = types.NullTime\n\n// Scan returns ColumnScanner that copies the columns in the\n// row into the values.\nfunc Scan(values ...interface{}) orm.ColumnScanner {\n\treturn orm.Scan(values...)\n}\n\n// Safe represents a safe SQL query.\ntype Safe = types.Safe\n\n// Ident represents a SQL identifier, e.g. table or column name.\ntype Ident = types.Ident\n\n// SafeQuery replaces any placeholders found in the query.\nfunc SafeQuery(query string, params ...interface{}) *orm.SafeQueryAppender {\n\treturn orm.SafeQuery(query, params...)\n}\n\n// In accepts a slice and returns a wrapper that can be used with PostgreSQL\n// IN operator:\n//\n//    Where(\"id IN (?)\", pg.In([]int{1, 2, 3, 4}))\n//\n// produces\n//\n//    WHERE id IN (1, 2, 3, 4)\nfunc In(slice interface{}) types.ValueAppender {\n\treturn types.In(slice)\n}\n\n// InMulti accepts multiple values and returns a wrapper that can be used\n// with PostgreSQL IN operator:\n//\n//    Where(\"(id1, id2) IN (?)\", pg.InMulti([]int{1, 2}, []int{3, 4}))\n//\n// produces\n//\n//    WHERE (id1, id2) IN ((1, 2), (3, 4))\nfunc InMulti(values ...interface{}) types.ValueAppender {\n\treturn types.InMulti(values...)\n}\n\n// Array accepts a slice and returns a wrapper for working with PostgreSQL\n// array data type.\n//\n// For struct fields you can use array tag:\n//\n//    Emails  []string `pg:\",array\"`\nfunc Array(v interface{}) *types.Array {\n\treturn types.NewArray(v)\n}\n\n// Hstore accepts a map and returns a wrapper for working with hstore data type.\n// Supported map types are:\n//   - map[string]string\n//\n// For struct fields you can use hstore tag:\n//\n//    Attrs map[string]string `pg:\",hstore\"`\nfunc Hstore(v interface{}) *types.Hstore {\n\treturn types.NewHstore(v)\n}\n\n// SetLogger sets the logger to the given one.\nfunc SetLogger(logger internal.Logging) {\n\tinternal.Logger = logger\n}\n\n//------------------------------------------------------------------------------\n\ntype Query = orm.Query\n\n// Model returns a new query for the optional model.\nfunc Model(model ...interface{}) *Query {\n\treturn orm.NewQuery(nil, model...)\n}\n\n// ModelContext returns a new query for the optional model with a context.\nfunc ModelContext(c context.Context, model ...interface{}) *Query {\n\treturn orm.NewQueryContext(c, nil, model...)\n}\n\n// DBI is a DB interface implemented by *DB and *Tx.\ntype DBI interface {\n\tModel(model ...interface{}) *Query\n\tModelContext(c context.Context, model ...interface{}) *Query\n\n\tExec(query interface{}, params ...interface{}) (Result, error)\n\tExecContext(c context.Context, query interface{}, params ...interface{}) (Result, error)\n\tExecOne(query interface{}, params ...interface{}) (Result, error)\n\tExecOneContext(c context.Context, query interface{}, params ...interface{}) (Result, error)\n\tQuery(model, query interface{}, params ...interface{}) (Result, error)\n\tQueryContext(c context.Context, model, query interface{}, params ...interface{}) (Result, error)\n\tQueryOne(model, query interface{}, params ...interface{}) (Result, error)\n\tQueryOneContext(c context.Context, model, query interface{}, params ...interface{}) (Result, error)\n\n\tBegin() (*Tx, error)\n\tRunInTransaction(ctx context.Context, fn func(*Tx) error) error\n\n\tCopyFrom(r io.Reader, query interface{}, params ...interface{}) (Result, error)\n\tCopyTo(w io.Writer, query interface{}, params ...interface{}) (Result, error)\n}\n\nvar (\n\t_ DBI = (*DB)(nil)\n\t_ DBI = (*Tx)(nil)\n)\n\n//------------------------------------------------------------------------------\n\n// Strings is a type alias for a slice of strings.\ntype Strings []string\n\nvar (\n\t_ orm.HooklessModel   = (*Strings)(nil)\n\t_ types.ValueAppender = (*Strings)(nil)\n)\n\n// Init initializes the Strings slice.\nfunc (strings *Strings) Init() error {\n\tif s := *strings; len(s) > 0 {\n\t\t*strings = s[:0]\n\t}\n\treturn nil\n}\n\n// NextColumnScanner ...\nfunc (strings *Strings) NextColumnScanner() orm.ColumnScanner {\n\treturn strings\n}\n\n// AddColumnScanner ...\nfunc (Strings) AddColumnScanner(_ orm.ColumnScanner) error {\n\treturn nil\n}\n\n// ScanColumn scans the columns and appends them to `strings`.\nfunc (strings *Strings) ScanColumn(col types.ColumnInfo, rd types.Reader, n int) error {\n\tb := make([]byte, n)\n\t_, err := io.ReadFull(rd, b)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t*strings = append(*strings, internal.BytesToString(b))\n\treturn nil\n}\n\n// AppendValue appends the values from `strings` to the given byte slice.\nfunc (strings Strings) AppendValue(dst []byte, quote int) ([]byte, error) {\n\tif len(strings) == 0 {\n\t\treturn dst, nil\n\t}\n\n\tfor _, s := range strings {\n\t\tdst = types.AppendString(dst, s, 1)\n\t\tdst = append(dst, ',')\n\t}\n\tdst = dst[:len(dst)-1]\n\treturn dst, nil\n}\n\n//------------------------------------------------------------------------------\n\n// Ints is a type alias for a slice of int64 values.\ntype Ints []int64\n\nvar (\n\t_ orm.HooklessModel   = (*Ints)(nil)\n\t_ types.ValueAppender = (*Ints)(nil)\n)\n\n// Init initializes the Int slice.\nfunc (ints *Ints) Init() error {\n\tif s := *ints; len(s) > 0 {\n\t\t*ints = s[:0]\n\t}\n\treturn nil\n}\n\n// NewColumnScanner ...\nfunc (ints *Ints) NextColumnScanner() orm.ColumnScanner {\n\treturn ints\n}\n\n// AddColumnScanner ...\nfunc (Ints) AddColumnScanner(_ orm.ColumnScanner) error {\n\treturn nil\n}\n\n// ScanColumn scans the columns and appends them to `ints`.\nfunc (ints *Ints) ScanColumn(col types.ColumnInfo, rd types.Reader, n int) error {\n\tnum, err := types.ScanInt64(rd, n)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t*ints = append(*ints, num)\n\treturn nil\n}\n\n// AppendValue appends the values from `ints` to the given byte slice.\nfunc (ints Ints) AppendValue(dst []byte, quote int) ([]byte, error) {\n\tif len(ints) == 0 {\n\t\treturn dst, nil\n\t}\n\n\tfor _, v := range ints {\n\t\tdst = strconv.AppendInt(dst, v, 10)\n\t\tdst = append(dst, ',')\n\t}\n\tdst = dst[:len(dst)-1]\n\treturn dst, nil\n}\n\n//------------------------------------------------------------------------------\n\n// IntSet is a set of int64 values.\ntype IntSet map[int64]struct{}\n\nvar _ orm.HooklessModel = (*IntSet)(nil)\n\n// Init initializes the IntSet.\nfunc (set *IntSet) Init() error {\n\tif len(*set) > 0 {\n\t\t*set = make(map[int64]struct{})\n\t}\n\treturn nil\n}\n\n// NextColumnScanner ...\nfunc (set *IntSet) NextColumnScanner() orm.ColumnScanner {\n\treturn set\n}\n\n// AddColumnScanner ...\nfunc (IntSet) AddColumnScanner(_ orm.ColumnScanner) error {\n\treturn nil\n}\n\n// ScanColumn scans the columns and appends them to `IntSet`.\nfunc (set *IntSet) ScanColumn(col types.ColumnInfo, rd types.Reader, n int) error {\n\tnum, err := types.ScanInt64(rd, n)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsetVal := *set\n\tif setVal == nil {\n\t\t*set = make(IntSet)\n\t\tsetVal = *set\n\t}\n\n\tsetVal[num] = struct{}{}\n\treturn nil\n}\n"
        },
        {
          "name": "pgjson",
          "type": "tree",
          "content": null
        },
        {
          "name": "pool_test.go",
          "type": "blob",
          "size": 3.419921875,
          "content": "package pg_test\n\nimport (\n\t\"time\"\n\n\t\"github.com/go-pg/pg/v10\"\n\n\t. \"gopkg.in/check.v1\"\n)\n\nvar _ = Suite(&PoolTest{})\n\ntype PoolTest struct {\n\tdb *pg.DB\n}\n\nfunc (t *PoolTest) SetUpTest(c *C) {\n\topt := pgOptions()\n\topt.IdleTimeout = time.Second\n\tt.db = pg.Connect(opt)\n}\n\nfunc (t *PoolTest) TearDownTest(c *C) {\n\t_ = t.db.Close()\n}\n\nfunc (t *PoolTest) TestPoolReusesConnection(c *C) {\n\tfor i := 0; i < 100; i++ {\n\t\t_, err := t.db.Exec(\"SELECT 'test_pool_reuses_connection'\")\n\t\tc.Assert(err, IsNil)\n\t}\n\n\tc.Assert(t.db.Pool().Len(), Equals, 1)\n\tc.Assert(t.db.Pool().IdleLen(), Equals, 1)\n}\n\nfunc (t *PoolTest) TestPoolMaxSize(c *C) {\n\tN := 1000\n\n\tperform(N, func(int) {\n\t\t_, err := t.db.Exec(\"SELECT 'test_pool_max_size'\")\n\t\tc.Assert(err, IsNil)\n\t})\n\n\tc.Assert(t.db.Pool().Len(), Equals, 10)\n\tc.Assert(t.db.Pool().IdleLen(), Equals, 10)\n}\n\nfunc (t *PoolTest) TestCloseClosesAllConnections(c *C) {\n\tln := t.db.Listen(ctx, \"test_channel\")\n\n\twait := make(chan struct{}, 2)\n\tgo func() {\n\t\twait <- struct{}{}\n\t\t_, _, err := ln.Receive(ctx)\n\t\tc.Assert(err, ErrorMatches, `^(.*use of closed (file or )?network connection|EOF)$`)\n\t\twait <- struct{}{}\n\t}()\n\n\tselect {\n\tcase <-wait:\n\t\t// ok\n\tcase <-time.After(3 * time.Second):\n\t\tc.Fatal(\"timeout\")\n\t}\n\n\tc.Assert(t.db.Close(), IsNil)\n\n\tselect {\n\tcase <-wait:\n\t\t// ok\n\tcase <-time.After(3 * time.Second):\n\t\tc.Fatal(\"timeout\")\n\t}\n\n\tc.Assert(t.db.Pool().Len(), Equals, 0)\n\tc.Assert(t.db.Pool().IdleLen(), Equals, 0)\n}\n\nfunc (t *PoolTest) TestClosedDB(c *C) {\n\tc.Assert(t.db.Close(), IsNil)\n\n\tc.Assert(t.db.Pool().Len(), Equals, 0)\n\tc.Assert(t.db.Pool().IdleLen(), Equals, 0)\n\n\terr := t.db.Close()\n\tc.Assert(err, Not(IsNil))\n\tc.Assert(err.Error(), Equals, \"pg: database is closed\")\n\n\t_, err = t.db.Exec(\"SELECT 'test_closed_db'\")\n\tc.Assert(err, Not(IsNil))\n\tc.Assert(err.Error(), Equals, \"pg: database is closed\")\n}\n\nfunc (t *PoolTest) TestClosedListener(c *C) {\n\tln := t.db.Listen(ctx, \"test_channel\")\n\n\tc.Assert(t.db.Pool().Len(), Equals, 1)\n\tc.Assert(t.db.Pool().IdleLen(), Equals, 0)\n\n\tc.Assert(ln.Close(), IsNil)\n\n\tc.Assert(t.db.Pool().Len(), Equals, 0)\n\tc.Assert(t.db.Pool().IdleLen(), Equals, 0)\n\n\terr := ln.Close()\n\tc.Assert(err, Not(IsNil))\n\tc.Assert(err.Error(), Equals, \"pg: listener is closed\")\n\n\t_, _, err = ln.ReceiveTimeout(ctx, time.Second)\n\tc.Assert(err, Not(IsNil))\n\tc.Assert(err.Error(), Equals, \"pg: listener is closed\")\n}\n\nfunc (t *PoolTest) TestClosedTx(c *C) {\n\ttx, err := t.db.Begin()\n\tc.Assert(err, IsNil)\n\n\tc.Assert(t.db.Pool().Len(), Equals, 1)\n\tc.Assert(t.db.Pool().IdleLen(), Equals, 0)\n\n\tc.Assert(tx.Rollback(), IsNil)\n\n\tc.Assert(t.db.Pool().Len(), Equals, 1)\n\tc.Assert(t.db.Pool().IdleLen(), Equals, 1)\n\n\terr = tx.Rollback()\n\tc.Assert(err, Not(IsNil))\n\tc.Assert(err.Error(), Equals, \"pg: transaction has already been committed or rolled back\")\n\n\t_, err = tx.Exec(\"SELECT 'test_closed_tx'\")\n\tc.Assert(err, Not(IsNil))\n\tc.Assert(err.Error(), Equals, \"pg: transaction has already been committed or rolled back\")\n}\n\nfunc (t *PoolTest) TestClosedStmt(c *C) {\n\tstmt, err := t.db.Prepare(\"SELECT $1::int\")\n\tc.Assert(err, IsNil)\n\n\tc.Assert(t.db.Pool().Len(), Equals, 1)\n\tc.Assert(t.db.Pool().IdleLen(), Equals, 0)\n\n\tc.Assert(stmt.Close(), IsNil)\n\n\tc.Assert(t.db.Pool().Len(), Equals, 1)\n\tc.Assert(t.db.Pool().IdleLen(), Equals, 1)\n\n\terr = stmt.Close()\n\tc.Assert(err, Not(IsNil))\n\tc.Assert(err.Error(), Equals, \"pg: statement is closed\")\n\n\t_, err = stmt.Exec(1)\n\tc.Assert(err, Not(IsNil))\n\tc.Assert(err.Error(), Equals, \"pg: statement is closed\")\n}\n"
        },
        {
          "name": "race_test.go",
          "type": "blob",
          "size": 4.16796875,
          "content": "package pg_test\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-pg/pg/v10\"\n\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n)\n\nfunc concurrency() (int, int) {\n\tif testing.Short() {\n\t\treturn 4, 100\n\t}\n\treturn 10, 1000\n}\n\nvar _ = Describe(\"DB timeout race\", func() {\n\tvar db *pg.DB\n\tvar C, N int\n\n\tBeforeEach(func() {\n\t\tC, N = concurrency()\n\t\tN = 100\n\t})\n\n\tAfterEach(func() {\n\t\tpool := db.Pool()\n\t\tExpect(pool.Len()).To(Equal(0))\n\t\tExpect(pool.IdleLen()).To(Equal(0))\n\n\t\terr := db.Close()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t// Give Postgres some time to recover.\n\t\ttime.Sleep(time.Second)\n\t})\n\n\ttest := func() {\n\t\tIt(\"is race free\", func() {\n\t\t\tperform(C, func(id int) {\n\t\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\t\t_, err := db.Exec(\"SELECT pg_sleep(1)\")\n\t\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\n\tDescribe(\"dial timeout\", func() {\n\t\tBeforeEach(func() {\n\t\t\topt := pgOptions()\n\t\t\topt.DialTimeout = time.Nanosecond\n\t\t\tdb = pg.Connect(opt)\n\t\t})\n\n\t\ttest()\n\t})\n\n\tDescribe(\"read timeout\", func() {\n\t\tBeforeEach(func() {\n\t\t\topt := pgOptions()\n\t\t\topt.ReadTimeout = time.Nanosecond\n\t\t\tdb = pg.Connect(opt)\n\t\t})\n\n\t\ttest()\n\t})\n\n\tDescribe(\"write timeout\", func() {\n\t\tBeforeEach(func() {\n\t\t\topt := pgOptions()\n\t\t\topt.WriteTimeout = time.Nanosecond\n\t\t\tdb = pg.Connect(opt)\n\t\t})\n\n\t\ttest()\n\t})\n})\n\nvar _ = Describe(\"DB race\", func() {\n\tvar db *pg.DB\n\tvar C, N int\n\n\tBeforeEach(func() {\n\t\tdb = pg.Connect(pgOptions())\n\n\t\terr := createTestSchema(db)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tC, N = concurrency()\n\t})\n\n\tAfterEach(func() {\n\t\terr := db.Close()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"invalid Scan is race free\", func() {\n\t\tperform(C, func(id int) {\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\tvar n int\n\t\t\t\tif i%2 == 0 {\n\t\t\t\t\t_, err := db.QueryOne(pg.Scan(&n), \"SELECT 1, 2\")\n\t\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t\t} else {\n\t\t\t\t\t_, err := db.QueryOne(pg.Scan(&n), \"SELECT 123\")\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(n).To(Equal(123))\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t})\n\n\tIt(\"SelectOrInsert with OnConflict is race free\", func() {\n\t\tperform(C, func(id int) {\n\t\t\ta := &Author{\n\t\t\t\tName: \"R. Scott Bakker\",\n\t\t\t}\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\ta.ID = 0\n\t\t\t\t_, err := db.Model(a).\n\t\t\t\t\tColumn(\"id\").\n\t\t\t\t\tWhere(\"name = ?name\").\n\t\t\t\t\tOnConflict(\"DO NOTHING\").\n\t\t\t\t\tReturning(\"id\").\n\t\t\t\t\tSelectOrInsert(&a.ID)\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(a.ID).NotTo(BeZero())\n\n\t\t\t\tif i%(N/C) == 0 {\n\t\t\t\t\t_, err := db.Model(a).WherePK().Delete()\n\t\t\t\t\tif err != pg.ErrNoRows {\n\t\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tcount, err := db.Model((*Author)(nil)).Count()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(count).To(Equal(1))\n\t})\n\n\tIt(\"SelectOrInsert without OnConflict is race free\", func() {\n\t\tperform(C, func(id int) {\n\t\t\ta := &Author{\n\t\t\t\tName: \"R. Scott Bakker\",\n\t\t\t}\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\ta.ID = 0\n\t\t\t\t_, err := db.Model(a).\n\t\t\t\t\tColumn(\"id\").\n\t\t\t\t\tWhere(\"name = ?name\").\n\t\t\t\t\tReturning(\"id\").\n\t\t\t\t\tSelectOrInsert(&a.ID)\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(a.ID).NotTo(BeZero())\n\n\t\t\t\tif i%(N/C) == 0 {\n\t\t\t\t\t_, err := db.Model(a).WherePK().Delete()\n\t\t\t\t\tif err != pg.ErrNoRows {\n\t\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tcount, err := db.Model((*Author)(nil)).Count()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(count).To(Equal(1))\n\t})\n\n\tIt(\"WithContext is race free\", func() {\n\t\tperform(C, func(id int) {\n\t\t\tdbWithCtx := db.WithContext(context.Background())\n\t\t\tExpect(dbWithCtx).NotTo(BeNil())\n\t\t})\n\t})\n\n\tIt(\"WithTimeout is race free\", func() {\n\t\tperform(C, func(id int) {\n\t\t\tdbWithTimeout := db.WithTimeout(5 * time.Second)\n\t\t\tExpect(dbWithTimeout).NotTo(BeNil())\n\t\t})\n\t})\n\n\tIt(\"context timeout is race free\", func() {\n\t\tperform(C, func(id int) {\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\tfunc() {\n\t\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second*5)\n\t\t\t\t\tdefer cancel()\n\t\t\t\t\t_, err := db.ExecContext(ctx, \"SELECT 1\")\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t}()\n\t\t\t}\n\t\t})\n\t})\n\n\tIt(\"fully initializes model table\", func() {\n\t\ttype TestTable struct {\n\t\t\ttableName struct{} `pg:\"'generate_series(0, 9)'\"`\n\t\t}\n\n\t\tperform(C, func(id int) {\n\t\t\tn, err := db.Model((*TestTable)(nil)).Count()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(10))\n\t\t})\n\t})\n})\n"
        },
        {
          "name": "result.go",
          "type": "blob",
          "size": 0.7890625,
          "content": "package pg\n\nimport (\n\t\"bytes\"\n\t\"strconv\"\n\n\t\"github.com/go-pg/pg/v10/internal\"\n\t\"github.com/go-pg/pg/v10/orm\"\n)\n\n// Result summarizes an executed SQL command.\ntype Result = orm.Result\n\n// A result summarizes an executed SQL command.\ntype result struct {\n\tmodel orm.Model\n\n\taffected int\n\treturned int\n}\n\nvar _ Result = (*result)(nil)\n\n//nolint\nfunc (res *result) parse(b []byte) error {\n\tres.affected = -1\n\n\tind := bytes.LastIndexByte(b, ' ')\n\tif ind == -1 {\n\t\treturn nil\n\t}\n\n\ts := internal.BytesToString(b[ind+1 : len(b)-1])\n\n\taffected, err := strconv.Atoi(s)\n\tif err == nil {\n\t\tres.affected = affected\n\t}\n\n\treturn nil\n}\n\nfunc (res *result) Model() orm.Model {\n\treturn res.model\n}\n\nfunc (res *result) RowsAffected() int {\n\treturn res.affected\n}\n\nfunc (res *result) RowsReturned() int {\n\treturn res.returned\n}\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "stmt.go",
          "type": "blob",
          "size": 6.9794921875,
          "content": "package pg\n\nimport (\n\t\"context\"\n\t\"errors\"\n\n\t\"github.com/go-pg/pg/v10/internal\"\n\t\"github.com/go-pg/pg/v10/internal/pool\"\n\t\"github.com/go-pg/pg/v10/orm\"\n\t\"github.com/go-pg/pg/v10/types\"\n)\n\nvar errStmtClosed = errors.New(\"pg: statement is closed\")\n\n// Stmt is a prepared statement. Stmt is safe for concurrent use by\n// multiple goroutines.\ntype Stmt struct {\n\tdb        *baseDB\n\tstickyErr error\n\n\tq       string\n\tname    string\n\tcolumns []types.ColumnInfo\n}\n\nfunc prepareStmt(db *baseDB, q string) (*Stmt, error) {\n\tstmt := &Stmt{\n\t\tdb: db,\n\n\t\tq: q,\n\t}\n\n\terr := stmt.prepare(context.TODO(), q)\n\tif err != nil {\n\t\t_ = stmt.Close()\n\t\treturn nil, err\n\t}\n\treturn stmt, nil\n}\n\nfunc (stmt *Stmt) prepare(ctx context.Context, q string) error {\n\tvar lastErr error\n\tfor attempt := 0; attempt <= stmt.db.opt.MaxRetries; attempt++ {\n\t\tif attempt > 0 {\n\t\t\tif err := internal.Sleep(ctx, stmt.db.retryBackoff(attempt-1)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\terr := stmt.db.pool.(*pool.StickyConnPool).Reset(ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tlastErr = stmt.withConn(ctx, func(ctx context.Context, cn *pool.Conn) error {\n\t\t\tvar err error\n\t\t\tstmt.name, stmt.columns, err = stmt.db.prepare(ctx, cn, q)\n\t\t\treturn err\n\t\t})\n\t\tif !stmt.db.shouldRetry(lastErr) {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn lastErr\n}\n\nfunc (stmt *Stmt) withConn(c context.Context, fn func(context.Context, *pool.Conn) error) error {\n\tif stmt.stickyErr != nil {\n\t\treturn stmt.stickyErr\n\t}\n\terr := stmt.db.withConn(c, fn)\n\tif err == pool.ErrClosed {\n\t\treturn errStmtClosed\n\t}\n\treturn err\n}\n\n// Exec executes a prepared statement with the given parameters.\nfunc (stmt *Stmt) Exec(params ...interface{}) (Result, error) {\n\treturn stmt.exec(context.TODO(), params...)\n}\n\n// ExecContext executes a prepared statement with the given parameters.\nfunc (stmt *Stmt) ExecContext(c context.Context, params ...interface{}) (Result, error) {\n\treturn stmt.exec(c, params...)\n}\n\nfunc (stmt *Stmt) exec(ctx context.Context, params ...interface{}) (Result, error) {\n\tctx, evt, err := stmt.db.beforeQuery(ctx, stmt.db.db, nil, stmt.q, params, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar res Result\n\tvar lastErr error\n\tfor attempt := 0; attempt <= stmt.db.opt.MaxRetries; attempt++ {\n\t\tif attempt > 0 {\n\t\t\tlastErr = internal.Sleep(ctx, stmt.db.retryBackoff(attempt-1))\n\t\t\tif lastErr != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tlastErr = stmt.withConn(ctx, func(c context.Context, cn *pool.Conn) error {\n\t\t\tres, err = stmt.extQuery(ctx, cn, stmt.name, params...)\n\t\t\treturn err\n\t\t})\n\t\tif !stmt.db.shouldRetry(lastErr) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err := stmt.db.afterQuery(ctx, evt, res, lastErr); err != nil {\n\t\treturn nil, err\n\t}\n\treturn res, lastErr\n}\n\n// ExecOne acts like Exec, but query must affect only one row. It\n// returns ErrNoRows error when query returns zero rows or\n// ErrMultiRows when query returns multiple rows.\nfunc (stmt *Stmt) ExecOne(params ...interface{}) (Result, error) {\n\treturn stmt.execOne(context.Background(), params...)\n}\n\n// ExecOneContext acts like ExecOne but additionally receives a context.\nfunc (stmt *Stmt) ExecOneContext(c context.Context, params ...interface{}) (Result, error) {\n\treturn stmt.execOne(c, params...)\n}\n\nfunc (stmt *Stmt) execOne(c context.Context, params ...interface{}) (Result, error) {\n\tres, err := stmt.ExecContext(c, params...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := internal.AssertOneRow(res.RowsAffected()); err != nil {\n\t\treturn nil, err\n\t}\n\treturn res, nil\n}\n\n// Query executes a prepared query statement with the given parameters.\nfunc (stmt *Stmt) Query(model interface{}, params ...interface{}) (Result, error) {\n\treturn stmt.query(context.Background(), model, params...)\n}\n\n// QueryContext acts like Query but additionally receives a context.\nfunc (stmt *Stmt) QueryContext(c context.Context, model interface{}, params ...interface{}) (Result, error) {\n\treturn stmt.query(c, model, params...)\n}\n\nfunc (stmt *Stmt) query(ctx context.Context, model interface{}, params ...interface{}) (Result, error) {\n\tctx, evt, err := stmt.db.beforeQuery(ctx, stmt.db.db, model, stmt.q, params, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar res Result\n\tvar lastErr error\n\tfor attempt := 0; attempt <= stmt.db.opt.MaxRetries; attempt++ {\n\t\tif attempt > 0 {\n\t\t\tlastErr = internal.Sleep(ctx, stmt.db.retryBackoff(attempt-1))\n\t\t\tif lastErr != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tlastErr = stmt.withConn(ctx, func(c context.Context, cn *pool.Conn) error {\n\t\t\tres, err = stmt.extQueryData(ctx, cn, stmt.name, model, stmt.columns, params...)\n\t\t\treturn err\n\t\t})\n\t\tif !stmt.db.shouldRetry(lastErr) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err := stmt.db.afterQuery(ctx, evt, res, lastErr); err != nil {\n\t\treturn nil, err\n\t}\n\treturn res, lastErr\n}\n\n// QueryOne acts like Query, but query must return only one row. It\n// returns ErrNoRows error when query returns zero rows or\n// ErrMultiRows when query returns multiple rows.\nfunc (stmt *Stmt) QueryOne(model interface{}, params ...interface{}) (Result, error) {\n\treturn stmt.queryOne(context.Background(), model, params...)\n}\n\n// QueryOneContext acts like QueryOne but additionally receives a context.\nfunc (stmt *Stmt) QueryOneContext(c context.Context, model interface{}, params ...interface{}) (Result, error) {\n\treturn stmt.queryOne(c, model, params...)\n}\n\nfunc (stmt *Stmt) queryOne(c context.Context, model interface{}, params ...interface{}) (Result, error) {\n\tmod, err := orm.NewModel(model)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tres, err := stmt.QueryContext(c, mod, params...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := internal.AssertOneRow(res.RowsAffected()); err != nil {\n\t\treturn nil, err\n\t}\n\treturn res, nil\n}\n\n// Close closes the statement.\nfunc (stmt *Stmt) Close() error {\n\tvar firstErr error\n\n\tif stmt.name != \"\" {\n\t\tfirstErr = stmt.closeStmt()\n\t}\n\n\terr := stmt.db.Close()\n\tif err != nil && firstErr == nil {\n\t\tfirstErr = err\n\t}\n\n\treturn firstErr\n}\n\nfunc (stmt *Stmt) extQuery(\n\tc context.Context, cn *pool.Conn, name string, params ...interface{},\n) (Result, error) {\n\terr := cn.WithWriter(c, stmt.db.opt.WriteTimeout, func(wb *pool.WriteBuffer) error {\n\t\treturn writeBindExecuteMsg(wb, name, params...)\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar res Result\n\terr = cn.WithReader(c, stmt.db.opt.ReadTimeout, func(rd *pool.ReaderContext) error {\n\t\tres, err = readExtQuery(rd)\n\t\treturn err\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn res, nil\n}\n\nfunc (stmt *Stmt) extQueryData(\n\tc context.Context,\n\tcn *pool.Conn,\n\tname string,\n\tmodel interface{},\n\tcolumns []types.ColumnInfo,\n\tparams ...interface{},\n) (Result, error) {\n\terr := cn.WithWriter(c, stmt.db.opt.WriteTimeout, func(wb *pool.WriteBuffer) error {\n\t\treturn writeBindExecuteMsg(wb, name, params...)\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar res *result\n\terr = cn.WithReader(c, stmt.db.opt.ReadTimeout, func(rd *pool.ReaderContext) error {\n\t\tres, err = readExtQueryData(c, rd, model, columns)\n\t\treturn err\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn res, nil\n}\n\nfunc (stmt *Stmt) closeStmt() error {\n\treturn stmt.withConn(context.TODO(), func(c context.Context, cn *pool.Conn) error {\n\t\treturn stmt.db.closeStmt(c, cn, stmt.name)\n\t})\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "tx.go",
          "type": "blob",
          "size": 9.6533203125,
          "content": "package pg\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"github.com/go-pg/pg/v10/internal\"\n\t\"github.com/go-pg/pg/v10/internal/pool\"\n\t\"github.com/go-pg/pg/v10/orm\"\n)\n\n// ErrTxDone is returned by any operation that is performed on a transaction\n// that has already been committed or rolled back.\nvar ErrTxDone = errors.New(\"pg: transaction has already been committed or rolled back\")\n\n// Tx is an in-progress database transaction. It is safe for concurrent use\n// by multiple goroutines.\n//\n// A transaction must end with a call to Commit or Rollback.\n//\n// After a call to Commit or Rollback, all operations on the transaction fail\n// with ErrTxDone.\n//\n// The statements prepared for a transaction by calling the transaction's\n// Prepare or Stmt methods are closed by the call to Commit or Rollback.\ntype Tx struct {\n\tdb  *baseDB\n\tctx context.Context\n\n\tstmtsMu sync.Mutex\n\tstmts   []*Stmt\n\n\t_closed int32\n}\n\nvar _ orm.DB = (*Tx)(nil)\n\n// Context returns the context.Context of the transaction.\nfunc (tx *Tx) Context() context.Context {\n\treturn tx.ctx\n}\n\n// Begin starts a transaction. Most callers should use RunInTransaction instead.\nfunc (db *baseDB) Begin() (*Tx, error) {\n\treturn db.BeginContext(db.db.Context())\n}\n\nfunc (db *baseDB) BeginContext(ctx context.Context) (*Tx, error) {\n\ttx := &Tx{\n\t\tdb:  db.withPool(pool.NewStickyConnPool(db.pool)),\n\t\tctx: ctx,\n\t}\n\n\terr := tx.begin(ctx)\n\tif err != nil {\n\t\ttx.close()\n\t\treturn nil, err\n\t}\n\n\treturn tx, nil\n}\n\n// RunInTransaction runs a function in a transaction. If function\n// returns an error transaction is rolled back, otherwise transaction\n// is committed.\nfunc (db *baseDB) RunInTransaction(ctx context.Context, fn func(*Tx) error) error {\n\ttx, err := db.BeginContext(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn tx.RunInTransaction(ctx, fn)\n}\n\n// Begin returns current transaction. It does not start new transaction.\nfunc (tx *Tx) Begin() (*Tx, error) {\n\treturn tx, nil\n}\n\n// RunInTransaction runs a function in the transaction. If function\n// returns an error transaction is rolled back, otherwise transaction\n// is committed.\nfunc (tx *Tx) RunInTransaction(ctx context.Context, fn func(*Tx) error) error {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tif err := tx.RollbackContext(ctx); err != nil {\n\t\t\t\tinternal.Logger.Printf(ctx, \"tx.Rollback panicked: %s\", err)\n\t\t\t}\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\tif err := fn(tx); err != nil {\n\t\tif err := tx.RollbackContext(ctx); err != nil {\n\t\t\tinternal.Logger.Printf(ctx, \"tx.Rollback failed: %s\", err)\n\t\t}\n\t\treturn err\n\t}\n\treturn tx.CommitContext(ctx)\n}\n\nfunc (tx *Tx) withConn(c context.Context, fn func(context.Context, *pool.Conn) error) error {\n\terr := tx.db.withConn(c, fn)\n\tif tx.closed() && err == pool.ErrClosed {\n\t\treturn ErrTxDone\n\t}\n\treturn err\n}\n\n// Stmt returns a transaction-specific prepared statement\n// from an existing statement.\nfunc (tx *Tx) Stmt(stmt *Stmt) *Stmt {\n\tstmt, err := tx.Prepare(stmt.q)\n\tif err != nil {\n\t\treturn &Stmt{stickyErr: err}\n\t}\n\treturn stmt\n}\n\n// Prepare creates a prepared statement for use within a transaction.\n//\n// The returned statement operates within the transaction and can no longer\n// be used once the transaction has been committed or rolled back.\n//\n// To use an existing prepared statement on this transaction, see Tx.Stmt.\nfunc (tx *Tx) Prepare(q string) (*Stmt, error) {\n\ttx.stmtsMu.Lock()\n\tdefer tx.stmtsMu.Unlock()\n\n\tdb := tx.db.withPool(pool.NewStickyConnPool(tx.db.pool))\n\tstmt, err := prepareStmt(db, q)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttx.stmts = append(tx.stmts, stmt)\n\n\treturn stmt, nil\n}\n\n// Exec is an alias for DB.Exec.\nfunc (tx *Tx) Exec(query interface{}, params ...interface{}) (Result, error) {\n\treturn tx.exec(tx.ctx, query, params...)\n}\n\n// ExecContext acts like Exec but additionally receives a context.\nfunc (tx *Tx) ExecContext(c context.Context, query interface{}, params ...interface{}) (Result, error) {\n\treturn tx.exec(c, query, params...)\n}\n\nfunc (tx *Tx) exec(ctx context.Context, query interface{}, params ...interface{}) (Result, error) {\n\twb := tx.db.pool.GetWriteBuffer()\n\tdefer tx.db.pool.PutWriteBuffer(wb)\n\n\tif err := writeQueryMsg(wb, tx.db.fmter, query, params...); err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx, evt, err := tx.db.beforeQuery(ctx, tx, nil, query, params, wb.Query())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar res Result\n\tlastErr := tx.withConn(ctx, func(ctx context.Context, cn *pool.Conn) error {\n\t\tres, err = tx.db.simpleQuery(ctx, cn, wb)\n\t\treturn err\n\t})\n\n\tif err := tx.db.afterQuery(ctx, evt, res, lastErr); err != nil {\n\t\treturn nil, err\n\t}\n\treturn res, lastErr\n}\n\n// ExecOne is an alias for DB.ExecOne.\nfunc (tx *Tx) ExecOne(query interface{}, params ...interface{}) (Result, error) {\n\treturn tx.execOne(tx.ctx, query, params...)\n}\n\n// ExecOneContext acts like ExecOne but additionally receives a context.\nfunc (tx *Tx) ExecOneContext(c context.Context, query interface{}, params ...interface{}) (Result, error) {\n\treturn tx.execOne(c, query, params...)\n}\n\nfunc (tx *Tx) execOne(c context.Context, query interface{}, params ...interface{}) (Result, error) {\n\tres, err := tx.ExecContext(c, query, params...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := internal.AssertOneRow(res.RowsAffected()); err != nil {\n\t\treturn nil, err\n\t}\n\treturn res, nil\n}\n\n// Query is an alias for DB.Query.\nfunc (tx *Tx) Query(model interface{}, query interface{}, params ...interface{}) (Result, error) {\n\treturn tx.query(tx.ctx, model, query, params...)\n}\n\n// QueryContext acts like Query but additionally receives a context.\nfunc (tx *Tx) QueryContext(\n\tc context.Context,\n\tmodel interface{},\n\tquery interface{},\n\tparams ...interface{},\n) (Result, error) {\n\treturn tx.query(c, model, query, params...)\n}\n\nfunc (tx *Tx) query(\n\tctx context.Context,\n\tmodel interface{},\n\tquery interface{},\n\tparams ...interface{},\n) (Result, error) {\n\twb := tx.db.pool.GetWriteBuffer()\n\tdefer tx.db.pool.PutWriteBuffer(wb)\n\n\tif err := writeQueryMsg(wb, tx.db.fmter, query, params...); err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx, evt, err := tx.db.beforeQuery(ctx, tx, model, query, params, wb.Query())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar res *result\n\tlastErr := tx.withConn(ctx, func(ctx context.Context, cn *pool.Conn) error {\n\t\tres, err = tx.db.simpleQueryData(ctx, cn, model, wb)\n\t\treturn err\n\t})\n\n\tif err := tx.db.afterQuery(ctx, evt, res, err); err != nil {\n\t\treturn nil, err\n\t}\n\treturn res, lastErr\n}\n\n// QueryOne is an alias for DB.QueryOne.\nfunc (tx *Tx) QueryOne(model interface{}, query interface{}, params ...interface{}) (Result, error) {\n\treturn tx.queryOne(tx.ctx, model, query, params...)\n}\n\n// QueryOneContext acts like QueryOne but additionally receives a context.\nfunc (tx *Tx) QueryOneContext(\n\tc context.Context,\n\tmodel interface{},\n\tquery interface{},\n\tparams ...interface{},\n) (Result, error) {\n\treturn tx.queryOne(c, model, query, params...)\n}\n\nfunc (tx *Tx) queryOne(\n\tc context.Context,\n\tmodel interface{},\n\tquery interface{},\n\tparams ...interface{},\n) (Result, error) {\n\tmod, err := orm.NewModel(model)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tres, err := tx.QueryContext(c, mod, query, params...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := internal.AssertOneRow(res.RowsAffected()); err != nil {\n\t\treturn nil, err\n\t}\n\treturn res, nil\n}\n\n// Model is an alias for DB.Model.\nfunc (tx *Tx) Model(model ...interface{}) *Query {\n\treturn orm.NewQuery(tx, model...)\n}\n\n// ModelContext acts like Model but additionally receives a context.\nfunc (tx *Tx) ModelContext(c context.Context, model ...interface{}) *Query {\n\treturn orm.NewQueryContext(c, tx, model...)\n}\n\n// CopyFrom is an alias for DB.CopyFrom.\nfunc (tx *Tx) CopyFrom(r io.Reader, query interface{}, params ...interface{}) (res Result, err error) {\n\terr = tx.withConn(tx.ctx, func(c context.Context, cn *pool.Conn) error {\n\t\tres, err = tx.db.copyFrom(c, cn, r, query, params...)\n\t\treturn err\n\t})\n\treturn res, err\n}\n\n// CopyTo is an alias for DB.CopyTo.\nfunc (tx *Tx) CopyTo(w io.Writer, query interface{}, params ...interface{}) (res Result, err error) {\n\terr = tx.withConn(tx.ctx, func(c context.Context, cn *pool.Conn) error {\n\t\tres, err = tx.db.copyTo(c, cn, w, query, params...)\n\t\treturn err\n\t})\n\treturn res, err\n}\n\n// Formatter is an alias for DB.Formatter.\nfunc (tx *Tx) Formatter() orm.QueryFormatter {\n\treturn tx.db.Formatter()\n}\n\nfunc (tx *Tx) begin(ctx context.Context) error {\n\tvar lastErr error\n\tfor attempt := 0; attempt <= tx.db.opt.MaxRetries; attempt++ {\n\t\tif attempt > 0 {\n\t\t\tif err := internal.Sleep(ctx, tx.db.retryBackoff(attempt-1)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\terr := tx.db.pool.(*pool.StickyConnPool).Reset(ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t_, lastErr = tx.ExecContext(ctx, \"BEGIN\")\n\t\tif !tx.db.shouldRetry(lastErr) {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn lastErr\n}\n\nfunc (tx *Tx) Commit() error {\n\treturn tx.CommitContext(tx.ctx)\n}\n\n// Commit commits the transaction.\nfunc (tx *Tx) CommitContext(ctx context.Context) error {\n\t_, err := tx.ExecContext(internal.UndoContext(ctx), \"COMMIT\")\n\ttx.close()\n\treturn err\n}\n\nfunc (tx *Tx) Rollback() error {\n\treturn tx.RollbackContext(tx.ctx)\n}\n\n// Rollback aborts the transaction.\nfunc (tx *Tx) RollbackContext(ctx context.Context) error {\n\t_, err := tx.ExecContext(internal.UndoContext(ctx), \"ROLLBACK\")\n\ttx.close()\n\treturn err\n}\n\nfunc (tx *Tx) Close() error {\n\treturn tx.CloseContext(tx.ctx)\n}\n\n// Close calls Rollback if the tx has not already been committed or rolled back.\nfunc (tx *Tx) CloseContext(ctx context.Context) error {\n\tif tx.closed() {\n\t\treturn nil\n\t}\n\treturn tx.RollbackContext(ctx)\n}\n\nfunc (tx *Tx) close() {\n\tif !atomic.CompareAndSwapInt32(&tx._closed, 0, 1) {\n\t\treturn\n\t}\n\n\ttx.stmtsMu.Lock()\n\tdefer tx.stmtsMu.Unlock()\n\n\tfor _, stmt := range tx.stmts {\n\t\t_ = stmt.Close()\n\t}\n\ttx.stmts = nil\n\n\t_ = tx.db.Close()\n}\n\nfunc (tx *Tx) closed() bool {\n\treturn atomic.LoadInt32(&tx._closed) == 1\n}\n"
        },
        {
          "name": "tx_test.go",
          "type": "blob",
          "size": 4.33984375,
          "content": "package pg_test\n\nimport (\n\t\"context\"\n\t\"strings\"\n\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"github.com/go-pg/pg/v10\"\n)\n\nvar _ = Describe(\"Tx\", func() {\n\tvar db *pg.DB\n\n\tBeforeEach(func() {\n\t\tdb = pg.Connect(pgOptions())\n\t})\n\n\tAfterEach(func() {\n\t\terr := db.Close()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"reconnects on bad connection\", func() {\n\t\tcn, err := db.Pool().Get(context.Background())\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tcn.SetNetConn(&badConn{})\n\t\tdb.Pool().Put(ctx, cn)\n\n\t\ttx, err := db.Begin()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\terr = tx.Rollback()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"supports multiple statements\", func() {\n\t\ttx, err := db.Begin()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tstmt1, err := tx.Prepare(`SELECT 'test_multi_prepare_tx1'`)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tstmt2, err := tx.Prepare(`SELECT 'test_multi_prepare_tx2'`)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tvar s1 string\n\t\t_, err = stmt1.QueryOne(pg.Scan(&s1))\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(s1).To(Equal(\"test_multi_prepare_tx1\"))\n\n\t\tvar s2 string\n\t\t_, err = stmt2.QueryOne(pg.Scan(&s2))\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(s2).To(Equal(\"test_multi_prepare_tx2\"))\n\n\t\terr = tx.Rollback()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"supports CopyFrom and CopyIn\", func() {\n\t\tdata := \"hello\\t5\\nworld\\t5\\nfoo\\t3\\nbar\\t3\\n\"\n\n\t\t_, err := db.Exec(\"DROP TABLE IF EXISTS test_copy_from\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t_, err = db.Exec(\"CREATE TABLE test_copy_from(word text, len int)\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\ttx1, err := db.Begin()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\ttx2, err := db.Begin()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tr := strings.NewReader(data)\n\t\tres, err := tx1.CopyFrom(r, \"COPY test_copy_from FROM STDIN\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.RowsAffected()).To(Equal(4))\n\n\t\tvar count int\n\t\t_, err = tx1.QueryOne(pg.Scan(&count), \"SELECT COUNT(*) FROM test_copy_from\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(count).To(Equal(4))\n\n\t\t_, err = tx2.QueryOne(pg.Scan(&count), \"SELECT COUNT(*) FROM test_copy_from\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(count).To(Equal(0))\n\n\t\terr = tx1.Commit()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t_, err = tx2.QueryOne(pg.Scan(&count), \"SELECT COUNT(*) FROM test_copy_from\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(count).To(Equal(4)) // assuming READ COMMITTED\n\n\t\terr = tx2.Rollback()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t_, err = db.Exec(\"DROP TABLE IF EXISTS test_copy_from\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"supports CopyFrom and CopyIn with errors\", func() {\n\t\t// too many fields on second line\n\t\tdata := \"hello\\t5\\nworld\\t5\\t6\\t8\\t9\\nfoo\\t3\\nbar\\t3\\n\"\n\n\t\t_, err := db.Exec(\"DROP TABLE IF EXISTS test_copy_from\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t_, err = db.Exec(\"CREATE TABLE test_copy_from(word text, len int)\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\t_, err = db.Exec(\"INSERT INTO test_copy_from VALUES ('xxx', 3)\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\ttx1, err := db.Begin()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\ttx2, err := db.Begin()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t_, err = tx1.Exec(\"INSERT INTO test_copy_from VALUES ('yyy', 3)\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tr := strings.NewReader(data)\n\t\t_, err = tx1.CopyFrom(r, \"COPY test_copy_from FROM STDIN\")\n\t\tExpect(err).To(HaveOccurred())\n\n\t\tvar count int\n\t\t_, err = tx1.QueryOne(pg.Scan(&count), \"SELECT COUNT(*) FROM test_copy_from\")\n\t\tExpect(err).To(HaveOccurred()) // transaction has errors, cannot proceed\n\n\t\t_, err = tx2.QueryOne(pg.Scan(&count), \"SELECT COUNT(*) FROM test_copy_from\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(count).To(Equal(1))\n\n\t\terr = tx1.Commit()\n\t\tExpect(err).To(HaveOccurred()) // actually ROLLBACK happens here\n\n\t\t_, err = tx2.QueryOne(pg.Scan(&count), \"SELECT COUNT(*) FROM test_copy_from\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(count).To(Equal(1)) // other transaction was rolled back so it's not 2 and not 6\n\n\t\terr = tx2.Rollback()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t_, err = db.Exec(\"DROP TABLE IF EXISTS test_copy_from\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"drops bad connections\", func() {\n\t\t_ = db.RunInTransaction(ctx, func(tx *pg.Tx) error {\n\t\t\tstmt, err := tx.Prepare(\"invalid statement\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn stmt.Close()\n\t\t})\n\n\t\t_, err := db.Exec(\"select 1\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n})\n"
        },
        {
          "name": "types",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.0966796875,
          "content": "package pg\n\n// Version is the current release version.\nfunc Version() string {\n\treturn \"10.14.0\"\n}\n"
        }
      ]
    }
  ]
}