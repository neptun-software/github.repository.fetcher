{
  "metadata": {
    "timestamp": 1736567525105,
    "page": 126,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "securego/gosec",
      "stars": 7938,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3740234375,
          "content": "# transient files\n/image\n\n# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n*.swp\n/gosec\n\n# Folders\n_obj\n_test\nvendor\ndist\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n\n.DS_Store\n\n.vscode\n.idea\n\n# SBOMs generated during CI\n/bom.json\n1"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.78125,
          "content": "linters:\n  enable:\n    - asciicheck\n    - bodyclose\n    - copyloopvar\n    - dogsled\n    - durationcheck\n    - errcheck\n    - errorlint\n    - gci\n    - ginkgolinter\n    - gochecknoinits\n    - gofmt\n    - gofumpt\n    - goimports\n    - gosec\n    - gosimple\n    - govet\n    - importas\n    - ineffassign\n    - misspell\n    - nakedret\n    - nolintlint\n    - revive\n    - staticcheck\n    - testifylint\n    - typecheck\n    - unconvert\n    - unparam\n    - unused\n    - wastedassign\n\nlinters-settings:\n  gci:\n    sections:\n      - standard\n      - default\n      - prefix(github.com/securego)\n  staticcheck:\n    checks:\n     - all\n     - '-SA1019'\n\n  testifylint:\n    enable-all: true\n\n  revive:\n    rules:\n      - name: dot-imports\n        disabled: true\n      - name: redefines-builtin-id\n\nrun:\n  timeout: 5m\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 0.6015625,
          "content": "---\nversion: 2\nproject_name: gosec\n\nrelease:\n  extra_files:\n    - glob: ./bom.json\n  github:\n    owner: securego\n    name: gosec\n\nbuilds:\n  - main: ./cmd/gosec/\n    binary: gosec\n    goos:\n      - darwin\n      - linux\n      - windows\n    goarch:\n      - amd64\n      - arm64\n      - s390x\n      - ppc64le\n    ldflags: -X main.Version={{.Version}} -X main.GitTag={{.Tag}} -X main.BuildDate={{.Date}}\n    env:\n      - CGO_ENABLED=0\n\nsigns:\n- cmd: cosign\n  stdin: '{{ .Env.COSIGN_PASSWORD}}'\n  args:\n  - \"sign-blob\"\n  - \"--key=/tmp/cosign.key\"\n  - \"--output=${signature}\"\n  - \"${artifact}\"\n  - \"--yes\"\n  artifacts: all\n\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 3.861328125,
          "content": "# Contributing\n\n## Adding a new rule\n\nNew rules can be implemented in two ways:\n\n- as a `gosec.Rule` -- these define an arbitrary function which will be called on every AST node in the analyzed file, and are appropriate for rules that mostly need to reason about a single statement.\n- as an Analyzer -- these can operate on the entire program, and receive an [SSA](https://pkg.go.dev/golang.org/x/tools/go/ssa) representation of the package. This type of rule is useful when you need to perform a more complex analysis that requires a great deal of context.\n\n### Adding a gosec.Rule\n\n1. Copy an existing rule file as a starting point-- `./rules/unsafe.go` is a good option, as it implements a very simple rule with no additional supporting logic. Put the copied file in the `./rules/` directory.\n2. Change the name of the rule constructor function and of the types in the rule file you've copied so they will be unique.\n3. Edit the `Generate` function in `./rules/rulelist.go` to include your rule.\n4. Add a RuleID to CWE ID mapping for your rule to the `ruleToCWE` map in `./issue/issue.go`. If you need a CWE that isn't already defined in `./cwe/data.go`, add it to the `idWeaknessess` map in that file.\n5. Use `make` to compile `gosec`. The binary will now contain your rule.\n\nTo make your rule actually useful, you will likely want to use the support functions defined in `./resolve.go`, `./helpers.go` and `./call_list.go`. There are inline comments explaining the purpose of most of these functions, and you can find usage examples in the existing rule files.\n\n### Adding an Analyzer\n\n1. Create a new go file under `./analyzers/` with the following scaffolding in it:\n\n```go\npackage analyzers\n\nimport (\n        \"fmt\"\n\n        \"golang.org/x/tools/go/analysis\"\n        \"golang.org/x/tools/go/analysis/passes/buildssa\"\n        \"github.com/securego/gosec/v2/issue\"\n)\n\nconst defaultIssueDescriptionMyAnalyzer = \"My new analyzer!\"\n\nfunc newMyAnalyzer(id string, description string) *analysis.Analyzer {\n        return &analysis.Analyzer{\n                Name:     id,\n                Doc:      description,\n                Run:      runMyAnalyzer,\n                Requires: []*analysis.Analyzer{buildssa.Analyzer},\n        }\n}\n\nfunc runMyAnalyzer(pass *analysis.Pass) (interface{}, error) {\n        ssaResult, err := getSSAResult(pass)\n        if err != nil {\n                return nil, fmt.Errorf(\"building ssa representation: %w\", err)\n        }\n        var issues []*issue.Issue\n        fmt.Printf(\"My Analyzer ran! %+v\\n\", ssaResult)\n\n        return issues, nil\n}\n```\n\n2. Add the analyzer to `./analyzers/analyzerslist.go` in the `defaultAnalyzers` variable under an entry like `{\"G999\", \"My test analyzer\", newMyAnalyzer}`\n3. Add a RuleID to CWE ID mapping for your rule to the `ruleToCWE` map in `./issue/issue.go`. If you need a CWE that isn't already defined in `./cwe/data.go`, add it to the `idWeaknessess` map in that file.\n4. `make`; then run the `gosec` binary produced. You should see the output from our print statement.\n5. You now have a working example analyzer to play with-- look at the other implemented analyzers for ideas on how to make useful rules.\n\n## Developing your rule\n\nThere are some utility tools which are useful for analyzing the SSA and AST representation `gosec` works with before writing rules or analyzers.\n\nFor instance to dump the SSA, the [ssadump](https://pkg.go.dev/golang.org/x/tools/cmd/ssadump) tool can be used as following:\n\n```bash\nssadump -build F main.go\n```\n\nConsult the documentation for ssadump for an overview of available output flags and options.\n\nFor outputting the AST and supporting information, there is a utility tool in <https://github.com/securego/gosec/blob/master/cmd/gosecutil/tools.go> which can be compiled and used as standalone.\n\n```bash\ngosecutil -tool ast main.go\n```\n\nValid tool arguments for this command are `ast`, `callobj`, `uses`, `types`, `defs`, `comments`, and `imports`.\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.4541015625,
          "content": "ARG GO_VERSION\nFROM golang:${GO_VERSION}-alpine AS builder\nRUN apk add --no-cache ca-certificates make git curl gcc libc-dev \\\n    && mkdir -p /build\nWORKDIR /build\nCOPY . /build/\nRUN go mod download \\\n    && make build-linux\n\nFROM golang:${GO_VERSION}-alpine \nRUN apk add --no-cache ca-certificates bash git gcc libc-dev openssh\nENV GO111MODULE on\nCOPY --from=builder /build/gosec /bin/gosec\nCOPY entrypoint.sh /bin/entrypoint.sh\nENTRYPOINT [\"/bin/entrypoint.sh\"]\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 8.923828125,
          "content": "Apache License\n\nVersion 2.0, January 2004\n\nhttp://www.apache.org/licenses/\n\nTERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n1. Definitions.\n\n\"License\" shall mean the terms and conditions for use, reproduction, and\ndistribution as defined by Sections 1 through 9 of this document.\n\n\"Licensor\" shall mean the copyright owner or entity authorized by the copyright\nowner that is granting the License.\n\n\"Legal Entity\" shall mean the union of the acting entity and all other entities\nthat control, are controlled by, or are under common control with that entity.\nFor the purposes of this definition, \"control\" means (i) the power, direct or\nindirect, to cause the direction or management of such entity, whether by\ncontract or otherwise, or (ii) ownership of fifty percent (50%) or more of the\noutstanding shares, or (iii) beneficial ownership of such entity.\n\n\"You\" (or \"Your\") shall mean an individual or Legal Entity exercising\npermissions granted by this License.\n\n\"Source\" form shall mean the preferred form for making modifications, including\nbut not limited to software source code, documentation source, and configuration\nfiles.\n\n\"Object\" form shall mean any form resulting from mechanical transformation or\ntranslation of a Source form, including but not limited to compiled object code,\ngenerated documentation, and conversions to other media types.\n\n\"Work\" shall mean the work of authorship, whether in Source or Object form, made\navailable under the License, as indicated by a copyright notice that is included\nin or attached to the work (an example is provided in the Appendix below).\n\n\"Derivative Works\" shall mean any work, whether in Source or Object form, that\nis based on (or derived from) the Work and for which the editorial revisions,\nannotations, elaborations, or other modifications represent, as a whole, an\noriginal work of authorship. For the purposes of this License, Derivative Works\nshall not include works that remain separable from, or merely link (or bind by\nname) to the interfaces of, the Work and Derivative Works thereof.\n\n\"Contribution\" shall mean any work of authorship, including the original version\nof the Work and any modifications or additions to that Work or Derivative Works\nthereof, that is intentionally submitted to Licensor for inclusion in the Work\nby the copyright owner or by an individual or Legal Entity authorized to submit\non behalf of the copyright owner. For the purposes of this definition,\n\"submitted\" means any form of electronic, verbal, or written communication sent\nto the Licensor or its representatives, including but not limited to\ncommunication on electronic mailing lists, source code control systems, and\nissue tracking systems that are managed by, or on behalf of, the Licensor for\nthe purpose of discussing and improving the Work, but excluding communication\nthat is conspicuously marked or otherwise designated in writing by the copyright\nowner as \"Not a Contribution.\"\n\n\"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf\nof whom a Contribution has been received by Licensor and subsequently\nincorporated within the Work.\n\n2. Grant of Copyright License. Subject to the terms and conditions of this\nLicense, each Contributor hereby grants to You a perpetual, worldwide,\nnon-exclusive, no-charge, royalty-free, irrevocable copyright license to\nreproduce, prepare Derivative Works of, publicly display, publicly perform,\nsublicense, and distribute the Work and such Derivative Works in Source or\nObject form.\n\n3. Grant of Patent License. Subject to the terms and conditions of this License,\neach Contributor hereby grants to You a perpetual, worldwide, non-exclusive,\nno-charge, royalty-free, irrevocable (except as stated in this section) patent\nlicense to make, have made, use, offer to sell, sell, import, and otherwise\ntransfer the Work, where such license applies only to those patent claims\nlicensable by such Contributor that are necessarily infringed by their\nContribution(s) alone or by combination of their Contribution(s) with the Work\nto which such Contribution(s) was submitted. If You institute patent litigation\nagainst any entity (including a cross-claim or counterclaim in a lawsuit)\nalleging that the Work or a Contribution incorporated within the Work\nconstitutes direct or contributory patent infringement, then any patent licenses\ngranted to You under this License for that Work shall terminate as of the date\nsuch litigation is filed.\n\n4. Redistribution. You may reproduce and distribute copies of the Work or\nDerivative Works thereof in any medium, with or without modifications, and in\nSource or Object form, provided that You meet the following conditions:\n\nYou must give any other recipients of the Work or Derivative Works a copy of\nthis License; and You must cause any modified files to carry prominent notices\nstating that You changed the files; and You must retain, in the Source form of\nany Derivative Works that You distribute, all copyright, patent, trademark, and\nattribution notices from the Source form of the Work, excluding those notices\nthat do not pertain to any part of the Derivative Works; and If the Work\nincludes a \"NOTICE\" text file as part of its distribution, then any Derivative\nWorks that You distribute must include a readable copy of the attribution\nnotices contained within such NOTICE file, excluding those notices that do not\npertain to any part of the Derivative Works, in at least one of the following\nplaces: within a NOTICE text file distributed as part of the Derivative Works;\nwithin the Source form or documentation, if provided along with the Derivative\nWorks; or, within a display generated by the Derivative Works, if and wherever\nsuch third-party notices normally appear. The contents of the NOTICE file are\nfor informational purposes only and do not modify the License. You may add Your\nown attribution notices within Derivative Works that You distribute, alongside\nor as an addendum to the NOTICE text from the Work, provided that such\nadditional attribution notices cannot be construed as modifying the License.\n\nYou may add Your own copyright statement to Your modifications and may provide\nadditional or different license terms and conditions for use, reproduction, or\ndistribution of Your modifications, or for any such Derivative Works as a whole,\nprovided Your use, reproduction, and distribution of the Work otherwise complies\nwith the conditions stated in this License. 5. Submission of Contributions.\nUnless You explicitly state otherwise, any Contribution intentionally submitted\nfor inclusion in the Work by You to the Licensor shall be under the terms and\nconditions of this License, without any additional terms or conditions.\nNotwithstanding the above, nothing herein shall supersede or modify the terms of\nany separate license agreement you may have executed with Licensor regarding\nsuch Contributions.\n\n6. Trademarks. This License does not grant permission to use the trade names,\ntrademarks, service marks, or product names of the Licensor, except as required\nfor reasonable and customary use in describing the origin of the Work and\nreproducing the content of the NOTICE file.\n\n7. Disclaimer of Warranty. Unless required by applicable law or agreed to in\nwriting, Licensor provides the Work (and each Contributor provides its\nContributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, either express or implied, including, without limitation, any warranties\nor conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\nPARTICULAR PURPOSE. You are solely responsible for determining the\nappropriateness of using or redistributing the Work and assume any risks\nassociated with Your exercise of permissions under this License.\n\n8. Limitation of Liability. In no event and under no legal theory, whether in\ntort (including negligence), contract, or otherwise, unless required by\napplicable law (such as deliberate and grossly negligent acts) or agreed to in\nwriting, shall any Contributor be liable to You for damages, including any\ndirect, indirect, special, incidental, or consequential damages of any character\narising as a result of this License or out of the use or inability to use the\nWork (including but not limited to damages for loss of goodwill, work stoppage,\ncomputer failure or malfunction, or any and all other commercial damages or\nlosses), even if such Contributor has been advised of the possibility of such\ndamages.\n\n9. Accepting Warranty or Additional Liability. While redistributing the Work or\nDerivative Works thereof, You may choose to offer, and charge a fee for,\nacceptance of support, warranty, indemnity, or other liability obligations\nand/or rights consistent with this License. However, in accepting such\nobligations, You may act only on Your own behalf and on Your sole\nresponsibility, not on behalf of any other Contributor, and only if You agree to\nindemnify, defend, and hold each Contributor harmless for any liability incurred\nby, or claims asserted against, such Contributor by reason of your accepting any\nsuch warranty or additional liability.\n\nEND OF TERMS AND CONDITIONS\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.5830078125,
          "content": "GIT_TAG?= $(shell git describe --always --tags)\nBIN = gosec\nFMT_CMD = $(gofmt -s -l -w $(find . -type f -name '*.go' -not -path './vendor/*') | tee /dev/stderr)\nIMAGE_REPO = securego\nDATE_FMT=+%Y-%m-%d\nifdef SOURCE_DATE_EPOCH\n    BUILD_DATE ?= $(shell date -u -d \"@$(SOURCE_DATE_EPOCH)\" \"$(DATE_FMT)\" 2>/dev/null || date -u -r \"$(SOURCE_DATE_EPOCH)\" \"$(DATE_FMT)\" 2>/dev/null || date -u \"$(DATE_FMT)\")\nelse\n    BUILD_DATE ?= $(shell date \"$(DATE_FMT)\")\nendif\nBUILDFLAGS := \"-w -s -X 'main.Version=$(GIT_TAG)' -X 'main.GitTag=$(GIT_TAG)' -X 'main.BuildDate=$(BUILD_DATE)'\"\nCGO_ENABLED = 0\nGO := GO111MODULE=on go\nGOPATH ?= $(shell $(GO) env GOPATH)\nGOBIN ?= $(GOPATH)/bin\nGOSEC ?= $(GOBIN)/gosec\nGINKGO ?= $(GOBIN)/ginkgo\nGO_MINOR_VERSION = $(shell $(GO) version | cut -c 14- | cut -d' ' -f1 | cut -d'.' -f2)\nGOVULN_MIN_VERSION = 17\nGO_VERSION = 1.23\n\ndefault:\n\t$(MAKE) build\n\ninstall-test-deps:\n\tgo install github.com/onsi/ginkgo/v2/ginkgo@latest\n\tgo install golang.org/x/crypto/...@latest\n\tgo install github.com/lib/pq/...@latest\n\ninstall-govulncheck:\n\t@if [ $(GO_MINOR_VERSION) -gt $(GOVULN_MIN_VERSION) ]; then \\\n\t\tgo install golang.org/x/vuln/cmd/govulncheck@latest; \\\n\tfi\n\ntest: install-test-deps build-race fmt vet sec govulncheck\n\t$(GINKGO) -v --fail-fast\n\nfmt:\n\t@echo \"FORMATTING\"\n\t@FORMATTED=`$(GO) fmt ./...`\n\t@([ ! -z \"$(FORMATTED)\" ] && printf \"Fixed unformatted files:\\n$(FORMATTED)\") || true\n\nvet:\n\t@echo \"VETTING\"\n\t$(GO) vet ./...\n\ngolangci:\n\t@echo \"LINTING: golangci-lint\"\n\tgolangci-lint run\n\nsec:\n\t@echo \"SECURITY SCANNING\"\n\t./$(BIN) ./...\n\ngovulncheck: install-govulncheck\n\t@echo \"CHECKING VULNERABILITIES\"\n\t@if [ $(GO_MINOR_VERSION) -gt $(GOVULN_MIN_VERSION) ]; then \\\n\t\tgovulncheck ./...; \\\n\tfi\n\ntest-coverage: install-test-deps\n\tgo test -race -v -count=1 -coverprofile=coverage.out ./...\n\nbuild:\n\tgo build -o $(BIN) ./cmd/gosec/\n\nbuild-race:\n\tgo build -race -o $(BIN) ./cmd/gosec/\n\nclean:\n\trm -rf build vendor dist coverage.out\n\trm -f release image $(BIN)\n\nrelease:\n\t@echo \"Releasing the gosec binary...\"\n\tgoreleaser release\n\nbuild-linux:\n\tCGO_ENABLED=$(CGO_ENABLED) GOOS=linux go build -ldflags=$(BUILDFLAGS) -o $(BIN) ./cmd/gosec/\n\nimage:\n\t@echo \"Building the Docker image...\"\n\tdocker build -t $(IMAGE_REPO)/$(BIN):$(GIT_TAG) --build-arg GO_VERSION=$(GO_VERSION) .\n\tdocker tag $(IMAGE_REPO)/$(BIN):$(GIT_TAG) $(IMAGE_REPO)/$(BIN):latest\n\ttouch image\n\nimage-push: image\n\t@echo \"Pushing the Docker image...\"\n\tdocker push $(IMAGE_REPO)/$(BIN):$(GIT_TAG)\n\tdocker push $(IMAGE_REPO)/$(BIN):latest\n\ntlsconfig:\n\tgo generate ./...\n\nperf-diff:\n\t./perf-diff.sh\n\n.PHONY: test build clean release image image-push tlsconfig perf-diff\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 17.0595703125,
          "content": "\n# gosec - Go Security Checker\n\nInspects source code for security problems by scanning the Go AST and SSA code representation.\n\n<img src=\"https://securego.io/img/gosec.png\" width=\"320\">\n\n## License\n\nLicensed under the Apache License, Version 2.0 (the \"License\").\nYou may not use this file except in compliance with the License.\nYou may obtain a copy of the License [here](http://www.apache.org/licenses/LICENSE-2.0).\n\n## Project status\n\n[![CII Best Practices](https://bestpractices.coreinfrastructure.org/projects/3218/badge)](https://bestpractices.coreinfrastructure.org/projects/3218)\n[![Build Status](https://github.com/securego/gosec/workflows/CI/badge.svg)](https://github.com/securego/gosec/actions?query=workflows%3ACI)\n[![Coverage Status](https://codecov.io/gh/securego/gosec/branch/master/graph/badge.svg)](https://codecov.io/gh/securego/gosec)\n[![GoReport](https://goreportcard.com/badge/github.com/securego/gosec)](https://goreportcard.com/report/github.com/securego/gosec)\n[![GoDoc](https://pkg.go.dev/badge/github.com/securego/gosec/v2)](https://pkg.go.dev/github.com/securego/gosec/v2)\n[![Docs](https://readthedocs.org/projects/docs/badge/?version=latest)](https://securego.io/)\n[![Downloads](https://img.shields.io/github/downloads/securego/gosec/total.svg)](https://github.com/securego/gosec/releases)\n[![Docker Pulls](https://img.shields.io/docker/pulls/securego/gosec.svg)](https://hub.docker.com/r/securego/gosec/tags)\n[![Slack](https://img.shields.io/badge/Slack-4A154B?style=for-the-badge&logo=slack&logoColor=white)](http://securego.slack.com)\n[![go-recipes](https://raw.githubusercontent.com/nikolaydubina/go-recipes/main/badge.svg?raw=true)](https://github.com/nikolaydubina/go-recipes)\n\n## Install\n\n### CI Installation\n\n```bash\n# binary will be $(go env GOPATH)/bin/gosec\ncurl -sfL https://raw.githubusercontent.com/securego/gosec/master/install.sh | sh -s -- -b $(go env GOPATH)/bin vX.Y.Z\n\n# or install it into ./bin/\ncurl -sfL https://raw.githubusercontent.com/securego/gosec/master/install.sh | sh -s vX.Y.Z\n\n# In alpine linux (as it does not come with curl by default)\nwget -O - -q https://raw.githubusercontent.com/securego/gosec/master/install.sh | sh -s vX.Y.Z\n\n# If you want to use the checksums provided on the \"Releases\" page\n# then you will have to download a tar.gz file for your operating system instead of a binary file\nwget https://github.com/securego/gosec/releases/download/vX.Y.Z/gosec_vX.Y.Z_OS.tar.gz\n\n# The file will be in the current folder where you run the command\n# and you can check the checksum like this\necho \"<check sum from the check sum file>  gosec_vX.Y.Z_OS.tar.gz\" | sha256sum -c -\n\ngosec --help\n```\n\n### GitHub Action\n\nYou can run `gosec` as a GitHub action as follows:\n\n```yaml\nname: Run Gosec\non:\n  push:\n    branches:\n      - master\n  pull_request:\n    branches:\n      - master\njobs:\n  tests:\n    runs-on: ubuntu-latest\n    env:\n      GO111MODULE: on\n    steps:\n      - name: Checkout Source\n        uses: actions/checkout@v3\n      - name: Run Gosec Security Scanner\n        uses: securego/gosec@master\n        with:\n          args: ./...\n```\n\n### Integrating with code scanning\n\nYou can [integrate third-party code analysis tools](https://docs.github.com/en/github/finding-security-vulnerabilities-and-errors-in-your-code/integrating-with-code-scanning) with GitHub code scanning by uploading data as SARIF files.\n\nThe workflow shows an example of running the `gosec` as a step in a GitHub action workflow which outputs the `results.sarif` file. The workflow then uploads the `results.sarif` file to GitHub using the `upload-sarif` action.\n\n```yaml\nname: \"Security Scan\"\n\n# Run workflow each time code is pushed to your repository and on a schedule.\n# The scheduled workflow runs every at 00:00 on Sunday UTC time.\non:\n  push:\n  schedule:\n  - cron: '0 0 * * 0'\n\njobs:\n  tests:\n    runs-on: ubuntu-latest\n    env:\n      GO111MODULE: on\n    steps:\n      - name: Checkout Source\n        uses: actions/checkout@v3\n      - name: Run Gosec Security Scanner\n        uses: securego/gosec@master\n        with:\n          # we let the report trigger content trigger a failure using the GitHub Security features.\n          args: '-no-fail -fmt sarif -out results.sarif ./...'\n      - name: Upload SARIF file\n        uses: github/codeql-action/upload-sarif@v2\n        with:\n          # Path to SARIF file relative to the root of the repository\n          sarif_file: results.sarif\n```\n\n### Local Installation\n\n```bash\ngo install github.com/securego/gosec/v2/cmd/gosec@latest\n```\n\n## Usage\n\nGosec can be configured to only run a subset of rules, to exclude certain file\npaths, and produce reports in different formats. By default all rules will be\nrun against the supplied input files. To recursively scan from the current\ndirectory you can supply `./...` as the input argument.\n\n### Available rules\n\n- G101: Look for hard coded credentials\n- G102: Bind to all interfaces\n- G103: Audit the use of unsafe block\n- G104: Audit errors not checked\n- G106: Audit the use of ssh.InsecureIgnoreHostKey\n- G107: Url provided to HTTP request as taint input\n- G108: Profiling endpoint automatically exposed on /debug/pprof\n- G109: Potential Integer overflow made by strconv.Atoi result conversion to int16/32\n- G110: Potential DoS vulnerability via decompression bomb\n- G111: Potential directory traversal\n- G112: Potential slowloris attack\n- G113: Usage of Rat.SetString in math/big with an overflow (CVE-2022-23772)\n- G114: Use of net/http serve function that has no support for setting timeouts\n- G115: Potential integer overflow when converting between integer types\n- G201: SQL query construction using format string\n- G202: SQL query construction using string concatenation\n- G203: Use of unescaped data in HTML templates\n- G204: Audit use of command execution\n- G301: Poor file permissions used when creating a directory\n- G302: Poor file permissions used with chmod\n- G303: Creating tempfile using a predictable path\n- G304: File path provided as taint input\n- G305: File traversal when extracting zip/tar archive\n- G306: Poor file permissions used when writing to a new file\n- G307: Poor file permissions used when creating a file with os.Create\n- G401: Detect the usage of MD5 or SHA1\n- G402: Look for bad TLS connection settings\n- G403: Ensure minimum RSA key length of 2048 bits\n- G404: Insecure random number source (rand)\n- G405: Detect the usage of DES or RC4\n- G406: Detect the usage of MD4 or RIPEMD160\n- G407: Detect the usage of hardcoded Initialization Vector(IV)/Nonce\n- G501: Import blocklist: crypto/md5\n- G502: Import blocklist: crypto/des\n- G503: Import blocklist: crypto/rc4\n- G504: Import blocklist: net/http/cgi\n- G505: Import blocklist: crypto/sha1\n- G506: Import blocklist: golang.org/x/crypto/md4\n- G507: Import blocklist: golang.org/x/crypto/ripemd160\n- G601: Implicit memory aliasing of items from a range statement (only for Go 1.21 or lower)\n- G602: Slice access out of bounds\n\n### Retired rules\n\n- G105: Audit the use of math/big.Int.Exp - [CVE is fixed](https://github.com/golang/go/issues/15184)\n- G307: Deferring a method which returns an error - causing more inconvenience than fixing a security issue, despite the details from this [blog post](https://www.joeshaw.org/dont-defer-close-on-writable-files/)\n\n### Selecting rules\n\nBy default, gosec will run all rules against the supplied file paths. It is however possible to select a subset of rules to run via the `-include=` flag,\nor to specify a set of rules to explicitly exclude using the `-exclude=` flag.\n\n```bash\n# Run a specific set of rules\n$ gosec -include=G101,G203,G401 ./...\n\n# Run everything except for rule G303\n$ gosec -exclude=G303 ./...\n```\n\n### CWE Mapping\n\nEvery issue detected by `gosec` is mapped to a [CWE (Common Weakness Enumeration)](http://cwe.mitre.org/data/index.html) which describes in more generic terms the vulnerability. The exact mapping can be found  [here](https://github.com/securego/gosec/blob/master/issue/issue.go#L50).\n\n### Configuration\n\nA number of global settings can be provided in a configuration file as follows:\n\n```JSON\n{\n    \"global\": {\n        \"nosec\": \"enabled\",\n        \"audit\": \"enabled\"\n    }\n}\n```\n\n- `nosec`: this setting will overwrite all `#nosec` directives defined throughout the code base\n- `audit`: runs in audit mode which enables addition checks that for normal code analysis might be too nosy\n\n```bash\n# Run with a global configuration file\n$ gosec -conf config.json .\n```\n\n#### Rule Configuration\n\nSome rules accept configuration flags as well; these flags are documented in [RULES.md](https://github.com/securego/gosec/blob/master/RULES.md).\n\n#### Go version\n\nSome rules require a specific Go version which is retrieved from the Go module file present in the project. If this version cannot be found, it will fallback to Go runtime version.\n\nThe Go module version is parsed using the `go list` command which in some cases might lead to performance degradation. In this situation, the go module version can be easily provided by setting the environment variable `GOSECGOVERSION=go1.21.1`.\n\n### Dependencies\n\ngosec will fetch automatically the dependencies of the code which is being analyzed when go module is turned on (e.g.`GO111MODULE=on`). If this is not the case,\nthe dependencies need to be explicitly downloaded by running the `go get -d` command before the scan.\n\n### Excluding test files and folders\n\ngosec will ignore test files across all packages and any dependencies in your vendor directory.\n\nThe scanning of test files can be enabled with the following flag:\n\n```bash\ngosec -tests ./...\n```\n\nAlso additional folders can be excluded as follows:\n\n```bash\n gosec -exclude-dir=rules -exclude-dir=cmd ./...\n```\n\n### Excluding generated files\n\ngosec can ignore generated go files with default generated code comment.\n\n```\n// Code generated by some generator DO NOT EDIT.\n```\n\n```bash\ngosec -exclude-generated ./...\n```\n\n### Auto fixing vulnerabilities\ngosec can suggest fixes based on AI recommendation. It will call an AI API to receive a suggestion for a security finding.\n\nYou can enable this feature by providing the following command line arguments:\n- `ai-api-provider`: the name of the AI API provider, currently only `gemini`is supported.\n- `ai-api-key` or set the environment variable `GOSEC_AI_API_KEY`: the key to access the AI API,\nFor gemini, you can create an API key following [these instructions](https://ai.google.dev/gemini-api/docs/api-key).\n- `ai-endpoint`: the endpoint of the AI provider, this is optional argument.\n\n\n```bash\ngosec -ai-api-provider=\"gemini\" -ai-api-key=\"your_key\" ./...\n```\n\n### Annotating code\n\nAs with all automated detection tools, there will be cases of false positives.\nIn cases where gosec reports a failure that has been manually verified as being safe,\nit is possible to annotate the code with a comment that starts with `#nosec`.\n\nThe `#nosec` comment should have the format `#nosec [RuleList] [-- Justification]`.\n\nThe `#nosec` comment needs to be placed on the line where the warning is reported.\n\n```go\nfunc main() {\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{\n\t\t\tInsecureSkipVerify: true, // #nosec G402\n\t\t},\n\t}\n\n\tclient := &http.Client{Transport: tr}\n\t_, err := client.Get(\"https://go.dev/\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}\n```\n\nWhen a specific false positive has been identified and verified as safe, you may\nwish to suppress only that single rule (or a specific set of rules) within a section of code,\nwhile continuing to scan for other problems. To do this, you can list the rule(s) to be suppressed within\nthe `#nosec` annotation, e.g: `/* #nosec G401 */` or `//#nosec G201 G202 G203`\n\nYou could put the description or justification text for the annotation. The\njustification should be after the rule(s) to suppress and start with two or\nmore dashes, e.g: `//#nosec G101 G102 -- This is a false positive`\n\nIn some cases you may also want to revisit places where `#nosec` annotations\nhave been used. To run the scanner and ignore any `#nosec` annotations you\ncan do the following:\n\n```bash\ngosec -nosec=true ./...\n```\n\n### Tracking suppressions\n\nAs described above, we could suppress violations externally (using `-include`/\n`-exclude`) or inline (using `#nosec` annotations) in gosec. This suppression\ninflammation can be used to generate corresponding signals for auditing\npurposes.\n\nWe could track suppressions by the `-track-suppressions` flag as follows:\n\n```bash\ngosec -track-suppressions -exclude=G101 -fmt=sarif -out=results.sarif ./...\n```\n\n- For external suppressions, gosec records suppression info where `kind` is\n`external` and `justification` is a certain sentence \"Globally suppressed\".\n- For inline suppressions, gosec records suppression info where `kind` is\n`inSource` and `justification` is the text after two or more dashes in the\ncomment.\n\n**Note:** Only SARIF and JSON formats support tracking suppressions.\n\n### Build tags\n\ngosec is able to pass your [Go build tags](https://pkg.go.dev/go/build/) to the analyzer.\nThey can be provided as a comma separated list as follows:\n\n```bash\ngosec -tags debug,ignore ./...\n```\n\n### Output formats\n\ngosec currently supports `text`, `json`, `yaml`, `csv`, `sonarqube`, `JUnit XML`, `html` and `golint` output formats. By default\nresults will be reported to stdout, but can also be written to an output\nfile. The output format is controlled by the `-fmt` flag, and the output file is controlled by the `-out` flag as follows:\n\n```bash\n# Write output in json format to results.json\n$ gosec -fmt=json -out=results.json *.go\n```\n\nResults will be reported to stdout as well as to the provided output file by `-stdout` flag. The `-verbose` flag overrides the\noutput format when stdout the results while saving them in the output file\n```bash\n# Write output in json format to results.json as well as stdout\n$ gosec -fmt=json -out=results.json -stdout *.go\n\n# Overrides the output format to 'text' when stdout the results, while writing it to results.json\n$ gosec -fmt=json -out=results.json -stdout -verbose=text *.go\n```\n\n**Note:** gosec generates the [generic issue import format](https://docs.sonarqube.org/latest/analysis/generic-issue/) for SonarQube, and a report has to be imported into SonarQube using `sonar.externalIssuesReportPaths=path/to/gosec-report.json`.\n\n## Development\n\n[CONTRIBUTING.md](https://github.com/securego/gosec/blob/master/CONTRIBUTING.md) contains detailed information about adding new rules to gosec.\n\n### Build\n\nYou can build the binary with:\n\n```bash\nmake\n```\n\n### Note on Sarif Types Generation\n\nInstall the tool with :\n\n```bash\ngo get -u github.com/a-h/generate/cmd/schema-generate\n```\n\nThen generate the types with :\n\n```bash\nschema-generate -i sarif-schema-2.1.0.json -o mypath/types.go\n```\n\nMost of the MarshallJSON/UnmarshalJSON are removed except the one for PropertyBag which is handy to inline the additional properties. The rest can be removed.\nThe URI,ID, UUID, GUID were renamed so it fits the Go convention defined [here](https://github.com/golang/lint/blob/master/lint.go#L700)\n\n### Tests\n\nYou can run all unit tests using:\n\n```bash\nmake test\n```\n\n### Release\n\nYou can create a release by tagging the version as follows:\n\n``` bash\ngit tag v1.0.0 -m \"Release version v1.0.0\"\ngit push origin v1.0.0\n```\n\nThe GitHub [release workflow](.github/workflows/release.yml) triggers immediately after the tag is pushed upstream. This flow will\nrelease the binaries using the [goreleaser](https://goreleaser.com/actions/) action and then it will build and publish the docker image into Docker Hub.\n\nThe released artifacts are signed using [cosign](https://docs.sigstore.dev/). You can use the public key from [cosign.pub](cosign.pub)\nfile to verify the signature of docker image and binaries files.\n\nThe docker image signature can be verified with the following command:\n```\ncosign verify --key cosign.pub securego/gosec:<TAG>\n```\n\nThe binary files signature can be verified with the following command:\n```\ncosign verify-blob --key cosign.pub --signature gosec_<VERSION>_darwin_amd64.tar.gz.sig  gosec_<VERSION>_darwin_amd64.tar.gz\n```\n\n### Docker image\n\nYou can also build locally the docker image by using the command:\n\n```bash\nmake image\n```\n\nYou can run the `gosec` tool in a container against your local Go project. You only have to mount the project\ninto a volume as follows:\n\n```bash\ndocker run --rm -it -w /<PROJECT>/ -v <YOUR PROJECT PATH>/<PROJECT>:/<PROJECT> securego/gosec /<PROJECT>/...\n```\n\n**Note:** the current working directory needs to be set with `-w` option in order to get successfully resolved the dependencies from go module file\n\n### Generate TLS rule\n\nThe configuration of TLS rule can be generated from [Mozilla's TLS ciphers recommendation](https://statics.tls.security.mozilla.org/server-side-tls-conf.json).\n\nFirst you need to install the generator tool:\n\n```bash\ngo get github.com/securego/gosec/v2/cmd/tlsconfig/...\n```\n\nYou can invoke now the `go generate` in the root of the project:\n\n```bash\ngo generate ./...\n```\n\nThis will generate the `rules/tls_config.go` file which will contain the current ciphers recommendation from Mozilla.\n\n## Who is using gosec?\n\nThis is a [list](USERS.md) with some of the gosec's users.\n\n## Sponsors\n\nSupport this project by becoming a sponsor. Your logo will show up here with a link to your website\n\n<a href=\"https://github.com/mercedes-benz\" target=\"_blank\"><img src=\"https://avatars.githubusercontent.com/u/34240465?s=80&v=4\"></a>\n"
        },
        {
          "name": "RULES.md",
          "type": "blob",
          "size": 1.609375,
          "content": "# Rule Documentation\n\n## Rules accepting parameters\n\nAs [README.md](https://github.com/securego/gosec/blob/master/README.md) mentions, some rules can be configured by adding parameters to the gosec JSON config. Per rule configs are encoded as top level objects in the gosec config, with the rule ID (`Gxxx`) as the key.\n\nCurrently, the following rules accept parameters. This list is manually maintained; if you notice an omission please add it!\n\n### G101\n\nThe hard-coded credentials rule `G101` can be configured with additional patterns, and the entropy threshold can be adjusted:\n\n```JSON\n{\n    \"G101\": {\n        \"pattern\": \"(?i)passwd|pass|password|pwd|secret|private_key|token\",\n         \"ignore_entropy\": false,\n         \"entropy_threshold\": \"80.0\",\n         \"per_char_threshold\": \"3.0\",\n         \"truncate\": \"32\"\n    }\n}\n```\n\n### G104\n\nThe unchecked error value rule `G104` can be configured with additional functions that should be permitted to be called without checking errors.\n\n```JSON\n{\n    \"G104\": {\n        \"ioutil\": [\"WriteFile\"]\n    }\n}\n```\n\n### G111\n\nThe HTTP Directory serving rule `G111` can be configured with a different regex for detecting potentially overly permissive servers. Note that this *replaces* the default pattern of `http\\.Dir\\(\"\\/\"\\)|http\\.Dir\\('\\/'\\)`.\n\n```JSON\n{\n    \"G111\": {\n        \"pattern\": \"http\\\\.Dir\\\\(\\\"\\\\\\/\\\"\\\\)|http\\\\.Dir\\\\('\\\\\\/'\\\\)\"\n    }\n}\n\n```\n\n### G301, G302, G306, G307\n\nThe various file and directory permission checking rules can be configured with a different maximum allowable file permission.\n\n```JSON\n{\n    \"G301\":\"0o600\",\n    \"G302\":\"0o600\",\n    \"G306\":\"0o750\",\n    \"G307\":\"0o750\"\n}\n```\n"
        },
        {
          "name": "USERS.md",
          "type": "blob",
          "size": 1.3017578125,
          "content": "# Users\n\nThis is a list of gosec's users. Please send a pull request with your organisation or project name if you are using gosec. \n\n## Companies\n\n1. [Gitlab](https://docs.gitlab.com/ee/user/application_security/sast/)\n2. [CloudBees](https://cloudbees.com)\n3. [VMware](https://www.vmware.com)\n4. [Codacy](https://support.codacy.com/hc/en-us/articles/213632009-Engines)\n5. [Coinbase](https://github.com/coinbase/watchdog/blob/master/Makefile#L12)\n6. [RedHat/OpenShift](https://github.com/openshift/openshift-azure)\n7. [Guardalis](https://www.guardrails.io/)\n8. [1Password](https://github.com/1Password/srp)\n9. [PingCAP/tidb](https://github.com/pingcap/tidb)\n10. [Checkmarx](https://www.checkmarx.com/)\n11. [SeatGeek](https://www.seatgeek.com/)\n12. [reMarkable](https://remarkable.com)\n\n## Projects\n\n1. [golangci-lint](https://github.com/golangci/golangci-lint)\n2. [Kubernetes](https://github.com/kubernetes/kubernetes) (via golangci)\n3. [caddy](https://github.com/caddyserver/caddy) (via golangci)\n4. [Jenkins X](https://github.com/jenkins-x/jx/blob/bdc51840a41b75776159c1c7b7faa1cf477be473/hack/linter.sh#L25)\n5. [HuskyCI](https://huskyci.opensource.globo.com/)\n6. [GolangCI](https://golangci.com/)\n7. [semgrep.live](https://semgrep.live/)\n8. [gofiber](https://github.com/gofiber/fiber)\n9. [KICS](https://github.com/Checkmarx/kics)\n"
        },
        {
          "name": "action.yml",
          "type": "blob",
          "size": 0.3349609375,
          "content": "name: 'Gosec Security Checker'\ndescription: 'Runs the gosec security checker'\nauthor: '@ccojocar'\n\ninputs:\n  args:\n    description: 'Arguments for gosec'\n    required: true\n    default: '-h'\n\nruns:\n    using: 'docker'\n    image: 'docker://securego/gosec:2.21.4'\n    args:\n      - ${{ inputs.args }}\n\nbranding:\n  icon: 'shield'\n  color: 'blue'\n"
        },
        {
          "name": "analyzer.go",
          "type": "blob",
          "size": 20.375,
          "content": "// (c) Copyright 2016 Hewlett Packard Enterprise Development LP\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Package gosec holds the central scanning logic used by gosec security scanner\npackage gosec\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/build\"\n\t\"go/token\"\n\t\"go/types\"\n\t\"log\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"golang.org/x/tools/go/analysis\"\n\t\"golang.org/x/tools/go/analysis/passes/buildssa\"\n\t\"golang.org/x/tools/go/packages\"\n\n\t\"github.com/securego/gosec/v2/analyzers\"\n\t\"github.com/securego/gosec/v2/issue\"\n)\n\n// LoadMode controls the amount of details to return when loading the packages\nconst LoadMode = packages.NeedName |\n\tpackages.NeedFiles |\n\tpackages.NeedCompiledGoFiles |\n\tpackages.NeedImports |\n\tpackages.NeedTypes |\n\tpackages.NeedTypesSizes |\n\tpackages.NeedTypesInfo |\n\tpackages.NeedSyntax |\n\tpackages.NeedModule |\n\tpackages.NeedEmbedFiles |\n\tpackages.NeedEmbedPatterns\n\nconst externalSuppressionJustification = \"Globally suppressed.\"\n\nconst aliasOfAllRules = \"*\"\n\ntype ignore struct {\n\tstart        int\n\tend          int\n\tsuppressions map[string][]issue.SuppressionInfo\n}\n\ntype ignores map[string][]ignore\n\nfunc newIgnores() ignores {\n\treturn make(map[string][]ignore)\n}\n\nfunc (i ignores) parseLine(line string) (int, int) {\n\tparts := strings.Split(line, \"-\")\n\tstart, err := strconv.Atoi(parts[0])\n\tif err != nil {\n\t\tstart = 0\n\t}\n\tend := start\n\tif len(parts) > 1 {\n\t\tif e, err := strconv.Atoi(parts[1]); err == nil {\n\t\t\tend = e\n\t\t}\n\t}\n\treturn start, end\n}\n\nfunc (i ignores) add(file string, line string, suppressions map[string]issue.SuppressionInfo) {\n\tis := []ignore{}\n\tif _, ok := i[file]; ok {\n\t\tis = i[file]\n\t}\n\tfound := false\n\tstart, end := i.parseLine(line)\n\tfor _, ig := range is {\n\t\tif ig.start <= start && ig.end >= end {\n\t\t\tfound = true\n\t\t\tfor r, s := range suppressions {\n\t\t\t\tss, ok := ig.suppressions[r]\n\t\t\t\tif !ok {\n\t\t\t\t\tss = []issue.SuppressionInfo{}\n\t\t\t\t}\n\t\t\t\tss = append(ss, s)\n\t\t\t\tig.suppressions[r] = ss\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\tig := ignore{\n\t\t\tstart:        start,\n\t\t\tend:          end,\n\t\t\tsuppressions: map[string][]issue.SuppressionInfo{},\n\t\t}\n\t\tfor r, s := range suppressions {\n\t\t\tig.suppressions[r] = []issue.SuppressionInfo{s}\n\t\t}\n\t\tis = append(is, ig)\n\t}\n\ti[file] = is\n}\n\nfunc (i ignores) get(file string, line string) map[string][]issue.SuppressionInfo {\n\tstart, end := i.parseLine(line)\n\tif is, ok := i[file]; ok {\n\t\tfor _, i := range is {\n\t\t\tif i.start <= start && i.end >= end || start <= i.start && end >= i.end {\n\t\t\t\treturn i.suppressions\n\t\t\t}\n\t\t}\n\t}\n\treturn map[string][]issue.SuppressionInfo{}\n}\n\n// The Context is populated with data parsed from the source code as it is scanned.\n// It is passed through to all rule functions as they are called. Rules may use\n// this data in conjunction with the encountered AST node.\ntype Context struct {\n\tFileSet      *token.FileSet\n\tComments     ast.CommentMap\n\tInfo         *types.Info\n\tPkg          *types.Package\n\tPkgFiles     []*ast.File\n\tRoot         *ast.File\n\tImports      *ImportTracker\n\tConfig       Config\n\tIgnores      ignores\n\tPassedValues map[string]interface{}\n}\n\n// GetFileAtNodePos returns the file at the node position in the file set available in the context.\nfunc (ctx *Context) GetFileAtNodePos(node ast.Node) *token.File {\n\treturn ctx.FileSet.File(node.Pos())\n}\n\n// NewIssue creates a new issue\nfunc (ctx *Context) NewIssue(node ast.Node, ruleID, desc string,\n\tseverity, confidence issue.Score,\n) *issue.Issue {\n\treturn issue.New(ctx.GetFileAtNodePos(node), node, ruleID, desc, severity, confidence)\n}\n\n// Metrics used when reporting information about a scanning run.\ntype Metrics struct {\n\tNumFiles int `json:\"files\"`\n\tNumLines int `json:\"lines\"`\n\tNumNosec int `json:\"nosec\"`\n\tNumFound int `json:\"found\"`\n}\n\n// Analyzer object is the main object of gosec. It has methods traverse an AST\n// and invoke the correct checking rules as on each node as required.\ntype Analyzer struct {\n\tignoreNosec       bool\n\truleset           RuleSet\n\tcontext           *Context\n\tconfig            Config\n\tlogger            *log.Logger\n\tissues            []*issue.Issue\n\tstats             *Metrics\n\terrors            map[string][]Error // keys are file paths; values are the golang errors in those files\n\ttests             bool\n\texcludeGenerated  bool\n\tshowIgnored       bool\n\ttrackSuppressions bool\n\tconcurrency       int\n\tanalyzerSet       *analyzers.AnalyzerSet\n\tmu                sync.Mutex\n}\n\n// NewAnalyzer builds a new analyzer.\nfunc NewAnalyzer(conf Config, tests bool, excludeGenerated bool, trackSuppressions bool, concurrency int, logger *log.Logger) *Analyzer {\n\tignoreNoSec := false\n\tif enabled, err := conf.IsGlobalEnabled(Nosec); err == nil {\n\t\tignoreNoSec = enabled\n\t}\n\tshowIgnored := false\n\tif enabled, err := conf.IsGlobalEnabled(ShowIgnored); err == nil {\n\t\tshowIgnored = enabled\n\t}\n\tif logger == nil {\n\t\tlogger = log.New(os.Stderr, \"[gosec]\", log.LstdFlags)\n\t}\n\treturn &Analyzer{\n\t\tignoreNosec:       ignoreNoSec,\n\t\tshowIgnored:       showIgnored,\n\t\truleset:           NewRuleSet(),\n\t\tcontext:           &Context{},\n\t\tconfig:            conf,\n\t\tlogger:            logger,\n\t\tissues:            make([]*issue.Issue, 0, 16),\n\t\tstats:             &Metrics{},\n\t\terrors:            make(map[string][]Error),\n\t\ttests:             tests,\n\t\tconcurrency:       concurrency,\n\t\texcludeGenerated:  excludeGenerated,\n\t\ttrackSuppressions: trackSuppressions,\n\t\tanalyzerSet:       analyzers.NewAnalyzerSet(),\n\t}\n}\n\n// SetConfig updates the analyzer configuration\nfunc (gosec *Analyzer) SetConfig(conf Config) {\n\tgosec.config = conf\n}\n\n// Config returns the current configuration\nfunc (gosec *Analyzer) Config() Config {\n\treturn gosec.config\n}\n\n// LoadRules instantiates all the rules to be used when analyzing source\n// packages\nfunc (gosec *Analyzer) LoadRules(ruleDefinitions map[string]RuleBuilder, ruleSuppressed map[string]bool) {\n\tfor id, def := range ruleDefinitions {\n\t\tr, nodes := def(id, gosec.config)\n\t\tgosec.ruleset.Register(r, ruleSuppressed[id], nodes...)\n\t}\n}\n\n// LoadAnalyzers instantiates all the analyzers to be used when analyzing source\n// packages\nfunc (gosec *Analyzer) LoadAnalyzers(analyzerDefinitions map[string]analyzers.AnalyzerDefinition, analyzerSuppressed map[string]bool) {\n\tfor id, def := range analyzerDefinitions {\n\t\tr := def.Create(def.ID, def.Description)\n\t\tgosec.analyzerSet.Register(r, analyzerSuppressed[id])\n\t}\n}\n\n// Process kicks off the analysis process for a given package\nfunc (gosec *Analyzer) Process(buildTags []string, packagePaths ...string) error {\n\tconfig := &packages.Config{\n\t\tMode:       LoadMode,\n\t\tBuildFlags: buildTags,\n\t\tTests:      gosec.tests,\n\t}\n\n\ttype result struct {\n\t\tpkgPath string\n\t\tpkgs    []*packages.Package\n\t\terr     error\n\t}\n\n\tresults := make(chan result)\n\tjobs := make(chan string, len(packagePaths))\n\tquit := make(chan struct{})\n\n\tvar wg sync.WaitGroup\n\n\tworker := func(j chan string, r chan result, quit chan struct{}) {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase s := <-j:\n\t\t\t\tpkgs, err := gosec.load(s, config)\n\t\t\t\tselect {\n\t\t\t\tcase r <- result{pkgPath: s, pkgs: pkgs, err: err}:\n\t\t\t\tcase <-quit:\n\t\t\t\t\t// we've been told to stop, probably an error while\n\t\t\t\t\t// processing a previous result.\n\t\t\t\t\twg.Done()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t// j is empty and there are no jobs left\n\t\t\t\twg.Done()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\t// fill the buffer\n\tfor _, pkgPath := range packagePaths {\n\t\tjobs <- pkgPath\n\t}\n\n\tfor i := 0; i < gosec.concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo worker(jobs, results, quit)\n\t}\n\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(results)\n\t}()\n\n\tfor r := range results {\n\t\tif r.err != nil {\n\t\t\tgosec.AppendError(r.pkgPath, r.err)\n\t\t}\n\t\tfor _, pkg := range r.pkgs {\n\t\t\tif pkg.Name != \"\" {\n\t\t\t\terr := gosec.ParseErrors(pkg)\n\t\t\t\tif err != nil {\n\t\t\t\t\tclose(quit)\n\t\t\t\t\twg.Wait() // wait for the goroutines to stop\n\t\t\t\t\treturn fmt.Errorf(\"parsing errors in pkg %q: %w\", pkg.Name, err)\n\t\t\t\t}\n\t\t\t\tgosec.CheckRules(pkg)\n\t\t\t\tgosec.CheckAnalyzers(pkg)\n\t\t\t}\n\t\t}\n\t}\n\tsortErrors(gosec.errors)\n\treturn nil\n}\n\nfunc (gosec *Analyzer) load(pkgPath string, conf *packages.Config) ([]*packages.Package, error) {\n\tabspath, err := GetPkgAbsPath(pkgPath)\n\tif err != nil {\n\t\tgosec.logger.Printf(\"Skipping: %s. Path doesn't exist.\", abspath)\n\t\treturn []*packages.Package{}, nil\n\t}\n\n\tgosec.logger.Println(\"Import directory:\", abspath)\n\t// step 1/3 create build context.\n\tbuildD := build.Default\n\t// step 2/3: add build tags to get env dependent files into basePackage.\n\tgosec.mu.Lock()\n\tbuildD.BuildTags = conf.BuildFlags\n\tgosec.mu.Unlock()\n\tbasePackage, err := buildD.ImportDir(pkgPath, build.ImportComment)\n\tif err != nil {\n\t\treturn []*packages.Package{}, fmt.Errorf(\"importing dir %q: %w\", pkgPath, err)\n\t}\n\n\tvar packageFiles []string\n\tfor _, filename := range basePackage.GoFiles {\n\t\tpackageFiles = append(packageFiles, path.Join(pkgPath, filename))\n\t}\n\tfor _, filename := range basePackage.CgoFiles {\n\t\tpackageFiles = append(packageFiles, path.Join(pkgPath, filename))\n\t}\n\n\tif gosec.tests {\n\t\ttestsFiles := make([]string, 0)\n\t\ttestsFiles = append(testsFiles, basePackage.TestGoFiles...)\n\t\ttestsFiles = append(testsFiles, basePackage.XTestGoFiles...)\n\t\tfor _, filename := range testsFiles {\n\t\t\tpackageFiles = append(packageFiles, path.Join(pkgPath, filename))\n\t\t}\n\t}\n\n\t// step 3/3 remove build tags from conf to proceed build correctly.\n\tgosec.mu.Lock()\n\tconf.BuildFlags = nil\n\tdefer gosec.mu.Unlock()\n\tpkgs, err := packages.Load(conf, packageFiles...)\n\tif err != nil {\n\t\treturn []*packages.Package{}, fmt.Errorf(\"loading files from package %q: %w\", pkgPath, err)\n\t}\n\treturn pkgs, nil\n}\n\n// CheckRules runs analysis on the given package.\nfunc (gosec *Analyzer) CheckRules(pkg *packages.Package) {\n\tgosec.logger.Println(\"Checking package:\", pkg.Name)\n\tfor _, file := range pkg.Syntax {\n\t\tfp := pkg.Fset.File(file.Pos())\n\t\tif fp == nil {\n\t\t\t// skip files which cannot be located\n\t\t\tcontinue\n\t\t}\n\t\tcheckedFile := fp.Name()\n\t\t// Skip the no-Go file from analysis (e.g. a Cgo files is expanded in 3 different files\n\t\t// stored in the cache which do not need to by analyzed)\n\t\tif filepath.Ext(checkedFile) != \".go\" {\n\t\t\tcontinue\n\t\t}\n\t\tif gosec.excludeGenerated && ast.IsGenerated(file) {\n\t\t\tgosec.logger.Println(\"Ignoring generated file:\", checkedFile)\n\t\t\tcontinue\n\t\t}\n\n\t\tgosec.logger.Println(\"Checking file:\", checkedFile)\n\t\tgosec.context.FileSet = pkg.Fset\n\t\tgosec.context.Config = gosec.config\n\t\tgosec.context.Comments = ast.NewCommentMap(gosec.context.FileSet, file, file.Comments)\n\t\tgosec.context.Root = file\n\t\tgosec.context.Info = pkg.TypesInfo\n\t\tgosec.context.Pkg = pkg.Types\n\t\tgosec.context.PkgFiles = pkg.Syntax\n\t\tgosec.context.Imports = NewImportTracker()\n\t\tgosec.context.PassedValues = make(map[string]interface{})\n\t\tgosec.updateIgnores()\n\t\tast.Walk(gosec, file)\n\t\tgosec.stats.NumFiles++\n\t\tgosec.stats.NumLines += pkg.Fset.File(file.Pos()).LineCount()\n\t}\n}\n\n// CheckAnalyzers runs analyzers on a given package.\nfunc (gosec *Analyzer) CheckAnalyzers(pkg *packages.Package) {\n\tssaResult, err := gosec.buildSSA(pkg)\n\tif err != nil || ssaResult == nil {\n\t\tgosec.logger.Printf(\"Error building the SSA representation of the package %q: %s\", pkg.Name, err)\n\t\treturn\n\t}\n\n\tresultMap := map[*analysis.Analyzer]interface{}{\n\t\tbuildssa.Analyzer: &analyzers.SSAAnalyzerResult{\n\t\t\tConfig: gosec.Config(),\n\t\t\tLogger: gosec.logger,\n\t\t\tSSA:    ssaResult.(*buildssa.SSA),\n\t\t},\n\t}\n\n\tgeneratedFiles := gosec.generatedFiles(pkg)\n\n\tfor _, analyzer := range gosec.analyzerSet.Analyzers {\n\t\tpass := &analysis.Pass{\n\t\t\tAnalyzer:          analyzer,\n\t\t\tFset:              pkg.Fset,\n\t\t\tFiles:             pkg.Syntax,\n\t\t\tOtherFiles:        pkg.OtherFiles,\n\t\t\tIgnoredFiles:      pkg.IgnoredFiles,\n\t\t\tPkg:               pkg.Types,\n\t\t\tTypesInfo:         pkg.TypesInfo,\n\t\t\tTypesSizes:        pkg.TypesSizes,\n\t\t\tResultOf:          resultMap,\n\t\t\tReport:            func(d analysis.Diagnostic) {},\n\t\t\tImportObjectFact:  nil,\n\t\t\tExportObjectFact:  nil,\n\t\t\tImportPackageFact: nil,\n\t\t\tExportPackageFact: nil,\n\t\t\tAllObjectFacts:    nil,\n\t\t\tAllPackageFacts:   nil,\n\t\t}\n\t\tresult, err := pass.Analyzer.Run(pass)\n\t\tif err != nil {\n\t\t\tgosec.logger.Printf(\"Error running analyzer %s: %s\\n\", analyzer.Name, err)\n\t\t\tcontinue\n\t\t}\n\t\tif result != nil {\n\t\t\tif passIssues, ok := result.([]*issue.Issue); ok {\n\t\t\t\tfor _, iss := range passIssues {\n\t\t\t\t\tif gosec.excludeGenerated {\n\t\t\t\t\t\tif _, ok := generatedFiles[iss.File]; ok {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgosec.updateIssues(iss)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (gosec *Analyzer) generatedFiles(pkg *packages.Package) map[string]bool {\n\tgeneratedFiles := map[string]bool{}\n\tfor _, file := range pkg.Syntax {\n\t\tif ast.IsGenerated(file) {\n\t\t\tfp := pkg.Fset.File(file.Pos())\n\t\t\tif fp == nil {\n\t\t\t\t// skip files which cannot be located\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tgeneratedFiles[fp.Name()] = true\n\t\t}\n\t}\n\treturn generatedFiles\n}\n\n// buildSSA runs the SSA pass which builds the SSA representation of the package. It handles gracefully any panic.\nfunc (gosec *Analyzer) buildSSA(pkg *packages.Package) (interface{}, error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tgosec.logger.Printf(\"Panic when running SSA analyser on package: %s\", pkg.Name)\n\t\t}\n\t}()\n\tssaPass := &analysis.Pass{\n\t\tAnalyzer:          buildssa.Analyzer,\n\t\tFset:              pkg.Fset,\n\t\tFiles:             pkg.Syntax,\n\t\tOtherFiles:        pkg.OtherFiles,\n\t\tIgnoredFiles:      pkg.IgnoredFiles,\n\t\tPkg:               pkg.Types,\n\t\tTypesInfo:         pkg.TypesInfo,\n\t\tTypesSizes:        pkg.TypesSizes,\n\t\tResultOf:          nil,\n\t\tReport:            nil,\n\t\tImportObjectFact:  nil,\n\t\tExportObjectFact:  nil,\n\t\tImportPackageFact: nil,\n\t\tExportPackageFact: nil,\n\t\tAllObjectFacts:    nil,\n\t\tAllPackageFacts:   nil,\n\t}\n\n\treturn ssaPass.Analyzer.Run(ssaPass)\n}\n\n// ParseErrors parses the errors from given package\nfunc (gosec *Analyzer) ParseErrors(pkg *packages.Package) error {\n\tif len(pkg.Errors) == 0 {\n\t\treturn nil\n\t}\n\tfor _, pkgErr := range pkg.Errors {\n\t\tparts := strings.Split(pkgErr.Pos, \":\")\n\t\tfile := parts[0]\n\t\tvar err error\n\t\tvar line int\n\t\tif len(parts) > 1 {\n\t\t\tif line, err = strconv.Atoi(parts[1]); err != nil {\n\t\t\t\treturn fmt.Errorf(\"parsing line: %w\", err)\n\t\t\t}\n\t\t}\n\t\tvar column int\n\t\tif len(parts) > 2 {\n\t\t\tif column, err = strconv.Atoi(parts[2]); err != nil {\n\t\t\t\treturn fmt.Errorf(\"parsing column: %w\", err)\n\t\t\t}\n\t\t}\n\t\tmsg := strings.TrimSpace(pkgErr.Msg)\n\t\tnewErr := NewError(line, column, msg)\n\t\tif errSlice, ok := gosec.errors[file]; ok {\n\t\t\tgosec.errors[file] = append(errSlice, *newErr)\n\t\t} else {\n\t\t\terrSlice = []Error{}\n\t\t\tgosec.errors[file] = append(errSlice, *newErr)\n\t\t}\n\t}\n\treturn nil\n}\n\n// AppendError appends an error to the file errors\nfunc (gosec *Analyzer) AppendError(file string, err error) {\n\t// Do not report the error for empty packages (e.g. files excluded from build with a tag)\n\tvar noGoErr *build.NoGoError\n\tif errors.As(err, &noGoErr) {\n\t\treturn\n\t}\n\terrors := make([]Error, 0)\n\tif ferrs, ok := gosec.errors[file]; ok {\n\t\terrors = ferrs\n\t}\n\tferr := NewError(0, 0, err.Error())\n\terrors = append(errors, *ferr)\n\tgosec.errors[file] = errors\n}\n\n// ignore a node (and sub-tree) if it is tagged with a nosec tag comment\nfunc (gosec *Analyzer) ignore(n ast.Node) map[string]issue.SuppressionInfo {\n\tif gosec.ignoreNosec {\n\t\treturn nil\n\t}\n\tgroups, ok := gosec.context.Comments[n]\n\tif !ok {\n\t\treturn nil\n\t}\n\n\t// Checks if an alternative for #nosec is set and, if not, uses the default.\n\tnoSecDefaultTag, err := gosec.config.GetGlobal(Nosec)\n\tif err != nil {\n\t\tnoSecDefaultTag = NoSecTag(string(Nosec))\n\t} else {\n\t\tnoSecDefaultTag = NoSecTag(noSecDefaultTag)\n\t}\n\tnoSecAlternativeTag, err := gosec.config.GetGlobal(NoSecAlternative)\n\tif err != nil {\n\t\tnoSecAlternativeTag = noSecDefaultTag\n\t} else {\n\t\tnoSecAlternativeTag = NoSecTag(noSecAlternativeTag)\n\t}\n\n\tfor _, group := range groups {\n\t\tcomment := strings.TrimSpace(group.Text())\n\t\tfoundDefaultTag := strings.HasPrefix(comment, noSecDefaultTag) || regexp.MustCompile(\"\\n *\"+noSecDefaultTag).MatchString(comment)\n\t\tfoundAlternativeTag := strings.HasPrefix(comment, noSecAlternativeTag) || regexp.MustCompile(\"\\n *\"+noSecAlternativeTag).MatchString(comment)\n\n\t\tif foundDefaultTag || foundAlternativeTag {\n\t\t\tgosec.stats.NumNosec++\n\n\t\t\t// Discard what's in front of the nosec tag.\n\t\t\tif foundDefaultTag {\n\t\t\t\tcomment = strings.SplitN(comment, noSecDefaultTag, 2)[1]\n\t\t\t} else {\n\t\t\t\tcomment = strings.SplitN(comment, noSecAlternativeTag, 2)[1]\n\t\t\t}\n\n\t\t\t// Extract the directive and the justification.\n\t\t\tjustification := \"\"\n\t\t\tcommentParts := regexp.MustCompile(`-{2,}`).Split(comment, 2)\n\t\t\tdirective := commentParts[0]\n\t\t\tif len(commentParts) > 1 {\n\t\t\t\tjustification = strings.TrimSpace(strings.TrimRight(commentParts[1], \"\\n\"))\n\t\t\t}\n\n\t\t\t// Pull out the specific rules that are listed to be ignored.\n\t\t\tre := regexp.MustCompile(`(G\\d{3})`)\n\t\t\tmatches := re.FindAllStringSubmatch(directive, -1)\n\n\t\t\tsuppression := issue.SuppressionInfo{\n\t\t\t\tKind:          \"inSource\",\n\t\t\t\tJustification: justification,\n\t\t\t}\n\n\t\t\t// Find the rule IDs to ignore.\n\t\t\tignores := make(map[string]issue.SuppressionInfo)\n\t\t\tfor _, v := range matches {\n\t\t\t\tignores[v[1]] = suppression\n\t\t\t}\n\n\t\t\t// If no specific rules were given, ignore everything.\n\t\t\tif len(matches) == 0 {\n\t\t\t\tignores[aliasOfAllRules] = suppression\n\t\t\t}\n\t\t\treturn ignores\n\t\t}\n\t}\n\treturn nil\n}\n\n// Visit runs the gosec visitor logic over an AST created by parsing go code.\n// Rule methods added with AddRule will be invoked as necessary.\nfunc (gosec *Analyzer) Visit(n ast.Node) ast.Visitor {\n\t// Using ast.File instead of ast.ImportSpec, so that we can track all imports at once.\n\tswitch i := n.(type) {\n\tcase *ast.File:\n\t\tgosec.context.Imports.TrackFile(i)\n\t}\n\n\tfor _, rule := range gosec.ruleset.RegisteredFor(n) {\n\t\tissue, err := rule.Match(n, gosec.context)\n\t\tif err != nil {\n\t\t\tfile, line := GetLocation(n, gosec.context)\n\t\t\tfile = path.Base(file)\n\t\t\tgosec.logger.Printf(\"Rule error: %v => %s (%s:%d)\\n\", reflect.TypeOf(rule), err, file, line)\n\t\t}\n\t\tgosec.updateIssues(issue)\n\t}\n\treturn gosec\n}\n\nfunc (gosec *Analyzer) updateIgnores() {\n\tfor n := range gosec.context.Comments {\n\t\tgosec.updateIgnoredRulesForNode(n)\n\t}\n}\n\nfunc (gosec *Analyzer) updateIgnoredRulesForNode(n ast.Node) {\n\tignoredRules := gosec.ignore(n)\n\tif len(ignoredRules) > 0 {\n\t\tif gosec.context.Ignores == nil {\n\t\t\tgosec.context.Ignores = newIgnores()\n\t\t}\n\t\tline := issue.GetLine(gosec.context.FileSet.File(n.Pos()), n)\n\t\tgosec.context.Ignores.add(\n\t\t\tgosec.context.FileSet.File(n.Pos()).Name(),\n\t\t\tline,\n\t\t\tignoredRules,\n\t\t)\n\t}\n}\n\nfunc (gosec *Analyzer) getSuppressionsAtLineInFile(file string, line string, id string) ([]issue.SuppressionInfo, bool) {\n\tignoredRules := gosec.context.Ignores.get(file, line)\n\n\t// Check if the rule was specifically suppressed at this location.\n\tgeneralSuppressions, generalIgnored := ignoredRules[aliasOfAllRules]\n\truleSuppressions, ruleIgnored := ignoredRules[id]\n\tignored := generalIgnored || ruleIgnored\n\tsuppressions := append(generalSuppressions, ruleSuppressions...)\n\n\t// Track external suppressions of this rule.\n\tif gosec.ruleset.IsRuleSuppressed(id) || gosec.analyzerSet.IsSuppressed(id) {\n\t\tignored = true\n\t\tsuppressions = append(suppressions, issue.SuppressionInfo{\n\t\t\tKind:          \"external\",\n\t\t\tJustification: externalSuppressionJustification,\n\t\t})\n\t}\n\treturn suppressions, ignored\n}\n\nfunc (gosec *Analyzer) updateIssues(issue *issue.Issue) {\n\tif issue != nil {\n\t\tsuppressions, ignored := gosec.getSuppressionsAtLineInFile(issue.File, issue.Line, issue.RuleID)\n\t\tif gosec.showIgnored {\n\t\t\tissue.NoSec = ignored\n\t\t}\n\t\tif !ignored || !gosec.showIgnored {\n\t\t\tgosec.stats.NumFound++\n\t\t}\n\t\tif ignored && gosec.trackSuppressions {\n\t\t\tissue.WithSuppressions(suppressions)\n\t\t\tgosec.issues = append(gosec.issues, issue)\n\t\t} else if !ignored || gosec.showIgnored || gosec.ignoreNosec {\n\t\t\tgosec.issues = append(gosec.issues, issue)\n\t\t}\n\t}\n}\n\n// Report returns the current issues discovered and the metrics about the scan\nfunc (gosec *Analyzer) Report() ([]*issue.Issue, *Metrics, map[string][]Error) {\n\treturn gosec.issues, gosec.stats, gosec.errors\n}\n\n// Reset clears state such as context, issues and metrics from the configured analyzer\nfunc (gosec *Analyzer) Reset() {\n\tgosec.context = &Context{}\n\tgosec.issues = make([]*issue.Issue, 0, 16)\n\tgosec.stats = &Metrics{}\n\tgosec.ruleset = NewRuleSet()\n\tgosec.analyzerSet = analyzers.NewAnalyzerSet()\n}\n"
        },
        {
          "name": "analyzer_test.go",
          "type": "blob",
          "size": 64.486328125,
          "content": "// (c) Copyright 2024 Mercedes-Benz Tech Innovation GmbH\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gosec_test\n\nimport (\n\t\"errors\"\n\t\"go/build\"\n\t\"log\"\n\t\"regexp\"\n\t\"strings\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n\t\"github.com/securego/gosec/v2\"\n\t\"github.com/securego/gosec/v2/analyzers\"\n\t\"github.com/securego/gosec/v2/rules\"\n\t\"github.com/securego/gosec/v2/testutils\"\n\t\"golang.org/x/tools/go/packages\"\n)\n\nvar _ = Describe(\"Analyzer\", func() {\n\tvar (\n\t\tanalyzer  *gosec.Analyzer\n\t\tlogger    *log.Logger\n\t\tbuildTags []string\n\t\ttests     bool\n\t)\n\tBeforeEach(func() {\n\t\tlogger, _ = testutils.NewLogger()\n\t\tanalyzer = gosec.NewAnalyzer(nil, tests, false, false, 1, logger)\n\t})\n\n\tContext(\"when processing a package\", func() {\n\t\tIt(\"should not report an error if the package contains no Go files\", func() {\n\t\t\tanalyzer.LoadRules(rules.Generate(false).RulesInfo())\n\t\t\tdir := GinkgoT().TempDir()\n\t\t\terr := analyzer.Process(buildTags, dir)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\t_, _, errors := analyzer.Report()\n\t\t\tExpect(errors).To(BeEmpty())\n\t\t})\n\n\t\tIt(\"should report an error if the package fails to build\", func() {\n\t\t\tanalyzer.LoadRules(rules.Generate(false).RulesInfo())\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"wonky.go\", `func main(){ println(\"forgot the package\")}`)\n\t\t\terr := pkg.Build()\n\t\t\tExpect(err).Should(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, pkg.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\t_, _, errors := analyzer.Report()\n\t\t\tExpect(errors).To(HaveLen(1))\n\t\t\tfor _, ferr := range errors {\n\t\t\t\tExpect(ferr).To(HaveLen(1))\n\t\t\t}\n\t\t})\n\n\t\tIt(\"should be able to analyze multiple Go files\", func() {\n\t\t\tanalyzer.LoadRules(rules.Generate(false).RulesInfo())\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `\n\t\t\t\tpackage main\n\t\t\t\tfunc main(){\n\t\t\t\t\tbar()\n\t\t\t\t}`)\n\t\t\tpkg.AddFile(\"bar.go\", `\n\t\t\t\tpackage main\n\t\t\t\tfunc bar(){\n\t\t\t\t\tprintln(\"package has two files!\")\n\t\t\t\t}`)\n\t\t\terr := pkg.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, pkg.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\t_, metrics, _ := analyzer.Report()\n\t\t\tExpect(metrics.NumFiles).To(Equal(2))\n\t\t})\n\n\t\tIt(\"should be able to analyze multiple Go files concurrently\", func() {\n\t\t\tcustomAnalyzer := gosec.NewAnalyzer(nil, true, true, false, 32, logger)\n\t\t\tcustomAnalyzer.LoadRules(rules.Generate(false).RulesInfo())\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `\n\t\t\t\tpackage main\n\t\t\t\tfunc main(){\n\t\t\t\t\tbar()\n\t\t\t\t}`)\n\t\t\tpkg.AddFile(\"bar.go\", `\n\t\t\t\tpackage main\n\t\t\t\tfunc bar(){\n\t\t\t\t\tprintln(\"package has two files!\")\n\t\t\t\t}`)\n\t\t\terr := pkg.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = customAnalyzer.Process(buildTags, pkg.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\t_, metrics, _ := customAnalyzer.Report()\n\t\t\tExpect(metrics.NumFiles).To(Equal(2))\n\t\t})\n\n\t\tIt(\"should be able to analyze multiple Go packages\", func() {\n\t\t\tanalyzer.LoadRules(rules.Generate(false).RulesInfo())\n\t\t\tpkg1 := testutils.NewTestPackage()\n\t\t\tpkg2 := testutils.NewTestPackage()\n\t\t\tdefer pkg1.Close()\n\t\t\tdefer pkg2.Close()\n\t\t\tpkg1.AddFile(\"foo.go\", `\n\t\t\t\tpackage main\n\t\t\t\tfunc main(){\n\t\t\t\t}`)\n\t\t\tpkg2.AddFile(\"bar.go\", `\n\t\t\t\tpackage main\n\t\t\t\tfunc bar(){\n\t\t\t\t}`)\n\t\t\terr := pkg1.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = pkg2.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, pkg1.Path, pkg2.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\t_, metrics, _ := analyzer.Report()\n\t\t\tExpect(metrics.NumFiles).To(Equal(2))\n\t\t})\n\n\t\tIt(\"should find errors when nosec is not in use\", func() {\n\t\t\tsample := testutils.SampleCodeG401[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G401\")).RulesInfo())\n\n\t\t\tcontrolPackage := testutils.NewTestPackage()\n\t\t\tdefer controlPackage.Close()\n\t\t\tcontrolPackage.AddFile(\"md5.go\", source)\n\t\t\terr := controlPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, controlPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tcontrolIssues, _, _ := analyzer.Report()\n\t\t\tExpect(controlIssues).Should(HaveLen(sample.Errors))\n\t\t})\n\n\t\tIt(\"should find errors when nosec is not in use\", func() {\n\t\t\tsample := testutils.SampleCodeG405[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G405\")).RulesInfo())\n\n\t\t\tcontrolPackage := testutils.NewTestPackage()\n\t\t\tdefer controlPackage.Close()\n\t\t\tcontrolPackage.AddFile(\"cipher.go\", source)\n\t\t\terr := controlPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, controlPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tcontrolIssues, _, _ := analyzer.Report()\n\t\t\tExpect(controlIssues).Should(HaveLen(sample.Errors))\n\t\t})\n\n\t\tIt(\"should find errors when nosec is not in use\", func() {\n\t\t\tsample := testutils.SampleCodeG406[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G406\")).RulesInfo())\n\n\t\t\tcontrolPackage := testutils.NewTestPackage()\n\t\t\tdefer controlPackage.Close()\n\t\t\tcontrolPackage.AddFile(\"md4.go\", source)\n\t\t\terr := controlPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, controlPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tcontrolIssues, _, _ := analyzer.Report()\n\t\t\tExpect(controlIssues).Should(HaveLen(sample.Errors))\n\t\t})\n\n\t\tIt(\"should report Go build errors and invalid files\", func() {\n\t\t\tanalyzer.LoadRules(rules.Generate(false).RulesInfo())\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `\n\t\t\t\tpackage main\n\t\t\t\tfunc main()\n\t\t\t\t}`)\n\t\t\terr := pkg.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, pkg.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\t_, _, errors := analyzer.Report()\n\t\t\tfoundErr := false\n\t\t\tfor _, ferr := range errors {\n\t\t\t\tExpect(ferr).To(HaveLen(1))\n\t\t\t\tmatch, err := regexp.MatchString(ferr[0].Err, `expected declaration, found '}'`)\n\t\t\t\tif !match || err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tfoundErr = true\n\t\t\t\tExpect(ferr[0].Line).To(Equal(4))\n\t\t\t\tExpect(ferr[0].Column).To(Equal(5))\n\t\t\t\tExpect(ferr[0].Err).Should(MatchRegexp(`expected declaration, found '}'`))\n\t\t\t}\n\t\t\tExpect(foundErr).To(BeTrue())\n\t\t})\n\n\t\tIt(\"should not report errors when a nosec line comment is present\", func() {\n\t\t\tsample := testutils.SampleCodeG401[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G401\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md5.New()\", \"h := md5.New() //#nosec\", 1)\n\t\t\tnosecPackage.AddFile(\"md5.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should not report errors when a nosec line comment is present\", func() {\n\t\t\tsample := testutils.SampleCodeG405[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G405\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"c, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", \"c, e := des.NewCipher([]byte(\\\"mySecret\\\")) //#nosec\", 1)\n\t\t\tnosecPackage.AddFile(\"cipher.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should not report errors when a nosec line comment is present\", func() {\n\t\t\tsample := testutils.SampleCodeG406[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G406\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md4.New()\", \"h := md4.New() //#nosec\", 1)\n\t\t\tnosecPackage.AddFile(\"md4.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should not report errors when a nosec block comment is present\", func() {\n\t\t\tsample := testutils.SampleCodeG401[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G401\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md5.New()\", \"h := md5.New() /* #nosec */\", 1)\n\t\t\tnosecPackage.AddFile(\"md5.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should not report errors when a nosec block comment is present\", func() {\n\t\t\tsample := testutils.SampleCodeG405[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G405\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"c, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", \"c, e := des.NewCipher([]byte(\\\"mySecret\\\")) /* #nosec */\", 1)\n\t\t\tnosecPackage.AddFile(\"cipher.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should not report errors when a nosec block comment is present\", func() {\n\t\t\tsample := testutils.SampleCodeG406[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G406\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md4.New()\", \"h := md4.New() /* #nosec */\", 1)\n\t\t\tnosecPackage.AddFile(\"md4.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should not report errors when an exclude comment is present for the correct rule\", func() {\n\t\t\t// Rule for MD5 weak crypto usage\n\t\t\tsample := testutils.SampleCodeG401[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G401\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md5.New()\", \"h := md5.New() //#nosec G401\", 1)\n\t\t\tnosecPackage.AddFile(\"md5.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should not report errors when an exclude comment is present for the correct rule\", func() {\n\t\t\t// Rule for DES weak crypto usage\n\t\t\tsample := testutils.SampleCodeG405[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G405\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"c, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", \"c, e := des.NewCipher([]byte(\\\"mySecret\\\")) //#nosec G405\", 1)\n\t\t\tnosecPackage.AddFile(\"cipher.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should not report errors when an exclude comment is present for the correct rule\", func() {\n\t\t\t// Rule for MD4 deprecated weak crypto usage\n\t\t\tsample := testutils.SampleCodeG406[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G406\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md4.New()\", \"h := md4.New() //#nosec G406\", 1)\n\t\t\tnosecPackage.AddFile(\"md4.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should not report errors when a nosec  block and line comment are present\", func() {\n\t\t\tsample := testutils.SampleCodeG101[23]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G101\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecPackage.AddFile(\"g101.go\", source)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\t\tIt(\"should not report errors when only a nosec  block is present\", func() {\n\t\t\tsample := testutils.SampleCodeG101[24]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G101\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecPackage.AddFile(\"g101.go\", source)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\t\tIt(\"should not report errors when a single line nosec  is present on a multi-line issue\", func() {\n\t\t\tsample := testutils.SampleCodeG112[3]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G112\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecPackage.AddFile(\"g112.go\", source)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should report errors when an exclude comment is present for a different rule\", func() {\n\t\t\tsample := testutils.SampleCodeG401[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G401\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md5.New()\", \"h := md5.New() //#nosec G301\", 1)\n\t\t\tnosecPackage.AddFile(\"md5.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(HaveLen(sample.Errors))\n\t\t})\n\n\t\tIt(\"should report errors when an exclude comment is present for a different rule\", func() {\n\t\t\tsample := testutils.SampleCodeG405[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G405\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"c, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", \"c, e := des.NewCipher([]byte(\\\"mySecret\\\")) //#nosec G301\", 1)\n\t\t\tnosecPackage.AddFile(\"cipher.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(HaveLen(sample.Errors))\n\t\t})\n\n\t\tIt(\"should report errors when an exclude comment is present for a different rule\", func() {\n\t\t\tsample := testutils.SampleCodeG406[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G406\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md4.New()\", \"h := md4.New() //#nosec G301\", 1)\n\t\t\tnosecPackage.AddFile(\"md4.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(HaveLen(sample.Errors))\n\t\t})\n\n\t\tIt(\"should not report errors when an exclude comment is present for multiple rules, including the correct rule\", func() {\n\t\t\tsample := testutils.SampleCodeG401[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G401\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md5.New()\", \"h := md5.New() //#nosec G301 G401\", 1)\n\t\t\tnosecPackage.AddFile(\"md5.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should not report errors when an exclude comment is present for multiple rules, including the correct rule\", func() {\n\t\t\tsample := testutils.SampleCodeG405[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G405\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"c, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", \"c, e := des.NewCipher([]byte(\\\"mySecret\\\")) //#nosec G301 G405\", 1)\n\t\t\tnosecPackage.AddFile(\"cipher.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should not report errors when an exclude comment is present for multiple rules, including the correct rule\", func() {\n\t\t\tsample := testutils.SampleCodeG406[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G406\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md4.New()\", \"h := md4.New() //#nosec G301 G406\", 1)\n\t\t\tnosecPackage.AddFile(\"md4.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should pass the build tags\", func() {\n\t\t\tsample := testutils.SampleCodeBuildTag[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false).RulesInfo())\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"tags.go\", source)\n\t\t\ttags := []string{\"tag\"}\n\t\t\terr := analyzer.Process(tags, pkg.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t})\n\n\t\tIt(\"should process an empty package with test file\", func() {\n\t\t\tanalyzer.LoadRules(rules.Generate(false).RulesInfo())\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo_test.go\", `\n\t\t\t\tpackage tests\n\t\t\t    import \"testing\"\n\t\t\t    func TestFoo(t *testing.T){\n\t\t\t    }`)\n\t\t\terr := pkg.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, pkg.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t})\n\n\t\tIt(\"should be possible to overwrite nosec comments, and report issues\", func() {\n\t\t\t// Rule for MD5 weak crypto usage\n\t\t\tsample := testutils.SampleCodeG401[0]\n\t\t\tsource := sample.Code[0]\n\n\t\t\t// overwrite nosec option\n\t\t\tnosecIgnoreConfig := gosec.NewConfig()\n\t\t\tnosecIgnoreConfig.SetGlobal(gosec.Nosec, \"true\")\n\t\t\tcustomAnalyzer := gosec.NewAnalyzer(nosecIgnoreConfig, tests, false, false, 1, logger)\n\t\t\tcustomAnalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G401\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md5.New()\", \"h := md5.New() //#nosec\", 1)\n\t\t\tnosecPackage.AddFile(\"md5.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = customAnalyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := customAnalyzer.Report()\n\t\t\tExpect(nosecIssues).Should(HaveLen(sample.Errors))\n\t\t})\n\n\t\tIt(\"should be possible to overwrite nosec comments, and report issues\", func() {\n\t\t\t// Rule for DES weak crypto usage\n\t\t\tsample := testutils.SampleCodeG405[0]\n\t\t\tsource := sample.Code[0]\n\n\t\t\t// overwrite nosec option\n\t\t\tnosecIgnoreConfig := gosec.NewConfig()\n\t\t\tnosecIgnoreConfig.SetGlobal(gosec.Nosec, \"true\")\n\t\t\tcustomAnalyzer := gosec.NewAnalyzer(nosecIgnoreConfig, tests, false, false, 1, logger)\n\t\t\tcustomAnalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G405\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"c, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", \"c, e := des.NewCipher([]byte(\\\"mySecret\\\")) //#nosec\", 1)\n\t\t\tnosecPackage.AddFile(\"cipher.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = customAnalyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := customAnalyzer.Report()\n\t\t\tExpect(nosecIssues).Should(HaveLen(sample.Errors))\n\t\t})\n\n\t\tIt(\"should be possible to overwrite nosec comments, and report issues\", func() {\n\t\t\t// Rule for MD4 weak crypto usage\n\t\t\tsample := testutils.SampleCodeG406[0]\n\t\t\tsource := sample.Code[0]\n\n\t\t\t// overwrite nosec option\n\t\t\tnosecIgnoreConfig := gosec.NewConfig()\n\t\t\tnosecIgnoreConfig.SetGlobal(gosec.Nosec, \"true\")\n\t\t\tcustomAnalyzer := gosec.NewAnalyzer(nosecIgnoreConfig, tests, false, false, 1, logger)\n\t\t\tcustomAnalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G406\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md4.New()\", \"h := md4.New() //#nosec\", 1)\n\t\t\tnosecPackage.AddFile(\"md4.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = customAnalyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := customAnalyzer.Report()\n\t\t\tExpect(nosecIssues).Should(HaveLen(sample.Errors))\n\t\t})\n\n\t\tIt(\"should be possible to overwrite nosec comments, and report issues but they should not be counted\", func() {\n\t\t\t// Rule for MD5 weak crypto usage\n\t\t\tsample := testutils.SampleCodeG401[0]\n\t\t\tsource := sample.Code[0]\n\n\t\t\t// overwrite nosec option\n\t\t\tnosecIgnoreConfig := gosec.NewConfig()\n\t\t\tnosecIgnoreConfig.SetGlobal(gosec.Nosec, \"mynosec\")\n\t\t\tnosecIgnoreConfig.SetGlobal(gosec.ShowIgnored, \"true\")\n\t\t\tcustomAnalyzer := gosec.NewAnalyzer(nosecIgnoreConfig, tests, false, false, 1, logger)\n\t\t\tcustomAnalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G401\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md5.New()\", \"h := md5.New() // #mynosec\", 1)\n\t\t\tnosecPackage.AddFile(\"md5.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = customAnalyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, metrics, _ := customAnalyzer.Report()\n\t\t\tExpect(nosecIssues).Should(HaveLen(sample.Errors))\n\t\t\tExpect(metrics.NumFound).Should(Equal(0))\n\t\t\tExpect(metrics.NumNosec).Should(Equal(1))\n\t\t})\n\n\t\tIt(\"should be possible to overwrite nosec comments, and report issues but they should not be counted\", func() {\n\t\t\t// Rule for DES weak crypto usage\n\t\t\tsample := testutils.SampleCodeG405[0]\n\t\t\tsource := sample.Code[0]\n\n\t\t\t// overwrite nosec option\n\t\t\tnosecIgnoreConfig := gosec.NewConfig()\n\t\t\tnosecIgnoreConfig.SetGlobal(gosec.Nosec, \"mynosec\")\n\t\t\tnosecIgnoreConfig.SetGlobal(gosec.ShowIgnored, \"true\")\n\t\t\tcustomAnalyzer := gosec.NewAnalyzer(nosecIgnoreConfig, tests, false, false, 1, logger)\n\t\t\tcustomAnalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G405\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"c, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", \"c, e := des.NewCipher([]byte(\\\"mySecret\\\")) // #mynosec\", 1)\n\t\t\tnosecPackage.AddFile(\"cipher.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = customAnalyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, metrics, _ := customAnalyzer.Report()\n\t\t\tExpect(nosecIssues).Should(HaveLen(sample.Errors))\n\t\t\tExpect(metrics.NumFound).Should(Equal(0))\n\t\t\tExpect(metrics.NumNosec).Should(Equal(1))\n\t\t})\n\n\t\tIt(\"should be possible to overwrite nosec comments, and report issues but they should not be counted\", func() {\n\t\t\t// Rule for MD4 weak crypto usage\n\t\t\tsample := testutils.SampleCodeG406[0]\n\t\t\tsource := sample.Code[0]\n\n\t\t\t// overwrite nosec option\n\t\t\tnosecIgnoreConfig := gosec.NewConfig()\n\t\t\tnosecIgnoreConfig.SetGlobal(gosec.Nosec, \"mynosec\")\n\t\t\tnosecIgnoreConfig.SetGlobal(gosec.ShowIgnored, \"true\")\n\t\t\tcustomAnalyzer := gosec.NewAnalyzer(nosecIgnoreConfig, tests, false, false, 1, logger)\n\t\t\tcustomAnalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G406\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md4.New()\", \"h := md4.New() // #mynosec\", 1)\n\t\t\tnosecPackage.AddFile(\"md4.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = customAnalyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, metrics, _ := customAnalyzer.Report()\n\t\t\tExpect(nosecIssues).Should(HaveLen(sample.Errors))\n\t\t\tExpect(metrics.NumFound).Should(Equal(0))\n\t\t\tExpect(metrics.NumNosec).Should(Equal(1))\n\t\t})\n\n\t\tIt(\"should not report errors when nosec tag is in front of a line\", func() {\n\t\t\tsample := testutils.SampleCodeG401[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G401\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md5.New()\", \"//Some description\\n//#nosec G401\\nh := md5.New()\", 1)\n\t\t\tnosecPackage.AddFile(\"md5.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should not report errors when nosec tag is in front of a line\", func() {\n\t\t\tsample := testutils.SampleCodeG405[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G405\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"c, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", \"//Some description\\n//#nosec G405\\nc, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", 1)\n\t\t\tnosecPackage.AddFile(\"cipher.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should not report errors when nosec tag is in front of a line\", func() {\n\t\t\tsample := testutils.SampleCodeG406[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G406\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md4.New()\", \"//Some description\\n//#nosec G406\\nh := md4.New()\", 1)\n\t\t\tnosecPackage.AddFile(\"md4.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should report errors when nosec tag is not in front of a line\", func() {\n\t\t\tsample := testutils.SampleCodeG401[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G401\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md5.New()\", \"//Some description\\n//Another description #nosec G401\\nh := md5.New()\", 1)\n\t\t\tnosecPackage.AddFile(\"md5.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(HaveLen(sample.Errors))\n\t\t})\n\n\t\tIt(\"should report errors when nosec tag is not in front of a line\", func() {\n\t\t\tsample := testutils.SampleCodeG405[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G405\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"c, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", \"//Some description\\n//Another description #nosec G405\\nc, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", 1)\n\t\t\tnosecPackage.AddFile(\"cipher.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(HaveLen(sample.Errors))\n\t\t})\n\n\t\tIt(\"should report errors when nosec tag is not in front of a line\", func() {\n\t\t\tsample := testutils.SampleCodeG406[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G406\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md4.New()\", \"//Some description\\n//Another description #nosec G406\\nh := md4.New()\", 1)\n\t\t\tnosecPackage.AddFile(\"md4.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(HaveLen(sample.Errors))\n\t\t})\n\n\t\tIt(\"should not report errors when rules are in front of nosec tag even rules are wrong\", func() {\n\t\t\tsample := testutils.SampleCodeG401[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G401\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md5.New()\", \"//G301\\n//#nosec\\nh := md5.New()\", 1)\n\t\t\tnosecPackage.AddFile(\"md5.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should not report errors when rules are in front of nosec tag even rules are wrong\", func() {\n\t\t\tsample := testutils.SampleCodeG405[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G405\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"c, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", \"//G301\\n//#nosec\\nc, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", 1)\n\t\t\tnosecPackage.AddFile(\"cipher.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should not report errors when rules are in front of nosec tag even rules are wrong\", func() {\n\t\t\tsample := testutils.SampleCodeG406[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G406\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md4.New()\", \"//G301\\n//#nosec\\nh := md4.New()\", 1)\n\t\t\tnosecPackage.AddFile(\"md4.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should report errors when there are nosec tags after a #nosec WrongRuleList annotation\", func() {\n\t\t\tsample := testutils.SampleCodeG401[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G401\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md5.New()\", \"//#nosec\\n//G301\\n//#nosec\\nh := md5.New()\", 1)\n\t\t\tnosecPackage.AddFile(\"md5.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(HaveLen(sample.Errors))\n\t\t})\n\n\t\tIt(\"should report errors when there are nosec tags after a #nosec WrongRuleList annotation\", func() {\n\t\t\tsample := testutils.SampleCodeG405[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G405\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"c, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", \"//#nosec\\n//G301\\n//#nosec\\nc, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", 1)\n\t\t\tnosecPackage.AddFile(\"cipher.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(HaveLen(sample.Errors))\n\t\t})\n\n\t\tIt(\"should report errors when there are nosec tags after a #nosec WrongRuleList annotation\", func() {\n\t\t\tsample := testutils.SampleCodeG406[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G406\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md4.New()\", \"//#nosec\\n//G301\\n//#nosec\\nh := md4.New()\", 1)\n\t\t\tnosecPackage.AddFile(\"md4.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := analyzer.Report()\n\t\t\tExpect(nosecIssues).Should(HaveLen(sample.Errors))\n\t\t})\n\n\t\tIt(\"should be possible to use an alternative nosec tag\", func() {\n\t\t\t// Rule for MD5 weak crypto usage\n\t\t\tsample := testutils.SampleCodeG401[0]\n\t\t\tsource := sample.Code[0]\n\n\t\t\t// overwrite nosec option\n\t\t\tnosecIgnoreConfig := gosec.NewConfig()\n\t\t\tnosecIgnoreConfig.SetGlobal(gosec.NoSecAlternative, \"falsePositive\")\n\t\t\tcustomAnalyzer := gosec.NewAnalyzer(nosecIgnoreConfig, tests, false, false, 1, logger)\n\t\t\tcustomAnalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G401\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md5.New()\", \"h := md5.New() // #falsePositive\", 1)\n\t\t\tnosecPackage.AddFile(\"md5.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = customAnalyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := customAnalyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should be possible to use an alternative nosec tag\", func() {\n\t\t\t// Rule for DES weak crypto usage\n\t\t\tsample := testutils.SampleCodeG405[0]\n\t\t\tsource := sample.Code[0]\n\n\t\t\t// overwrite nosec option\n\t\t\tnosecIgnoreConfig := gosec.NewConfig()\n\t\t\tnosecIgnoreConfig.SetGlobal(gosec.NoSecAlternative, \"falsePositive\")\n\t\t\tcustomAnalyzer := gosec.NewAnalyzer(nosecIgnoreConfig, tests, false, false, 1, logger)\n\t\t\tcustomAnalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G405\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"c, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", \"c, e := des.NewCipher([]byte(\\\"mySecret\\\")) // #falsePositive\", 1)\n\t\t\tnosecPackage.AddFile(\"cipher.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = customAnalyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := customAnalyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should be possible to use an alternative nosec tag\", func() {\n\t\t\t// Rule for MD4 deprecated weak crypto usage\n\t\t\tsample := testutils.SampleCodeG406[0]\n\t\t\tsource := sample.Code[0]\n\n\t\t\t// overwrite nosec option\n\t\t\tnosecIgnoreConfig := gosec.NewConfig()\n\t\t\tnosecIgnoreConfig.SetGlobal(gosec.NoSecAlternative, \"falsePositive\")\n\t\t\tcustomAnalyzer := gosec.NewAnalyzer(nosecIgnoreConfig, tests, false, false, 1, logger)\n\t\t\tcustomAnalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G406\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md4.New()\", \"h := md4.New() // #falsePositive\", 1)\n\t\t\tnosecPackage.AddFile(\"md4.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = customAnalyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := customAnalyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should ignore vulnerabilities when the default tag is found\", func() {\n\t\t\t// Rule for MD5 weak crypto usage\n\t\t\tsample := testutils.SampleCodeG401[0]\n\t\t\tsource := sample.Code[0]\n\n\t\t\t// overwrite nosec option\n\t\t\tnosecIgnoreConfig := gosec.NewConfig()\n\t\t\tnosecIgnoreConfig.SetGlobal(gosec.NoSecAlternative, \"falsePositive\")\n\t\t\tcustomAnalyzer := gosec.NewAnalyzer(nosecIgnoreConfig, tests, false, false, 1, logger)\n\t\t\tcustomAnalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G401\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md5.New()\", \"h := md5.New() //#nosec\", 1)\n\t\t\tnosecPackage.AddFile(\"md5.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = customAnalyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := customAnalyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should ignore vulnerabilities when the default tag is found\", func() {\n\t\t\t// Rule for DES weak crypto usage\n\t\t\tsample := testutils.SampleCodeG405[0]\n\t\t\tsource := sample.Code[0]\n\n\t\t\t// overwrite nosec option\n\t\t\tnosecIgnoreConfig := gosec.NewConfig()\n\t\t\tnosecIgnoreConfig.SetGlobal(gosec.NoSecAlternative, \"falsePositive\")\n\t\t\tcustomAnalyzer := gosec.NewAnalyzer(nosecIgnoreConfig, tests, false, false, 1, logger)\n\t\t\tcustomAnalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G405\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"c, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", \"c, e := des.NewCipher([]byte(\\\"mySecret\\\")) //#nosec\", 1)\n\t\t\tnosecPackage.AddFile(\"cipher.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = customAnalyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := customAnalyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should ignore vulnerabilities when the default tag is found\", func() {\n\t\t\t// Rule for MD4 deprecated weak crypto usage\n\t\t\tsample := testutils.SampleCodeG406[0]\n\t\t\tsource := sample.Code[0]\n\n\t\t\t// overwrite nosec option\n\t\t\tnosecIgnoreConfig := gosec.NewConfig()\n\t\t\tnosecIgnoreConfig.SetGlobal(gosec.NoSecAlternative, \"falsePositive\")\n\t\t\tcustomAnalyzer := gosec.NewAnalyzer(nosecIgnoreConfig, tests, false, false, 1, logger)\n\t\t\tcustomAnalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G406\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md4.New()\", \"h := md4.New() //#nosec\", 1)\n\t\t\tnosecPackage.AddFile(\"md4.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = customAnalyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tnosecIssues, _, _ := customAnalyzer.Report()\n\t\t\tExpect(nosecIssues).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should be able to analyze Go test package\", func() {\n\t\t\tcustomAnalyzer := gosec.NewAnalyzer(nil, true, false, false, 1, logger)\n\t\t\tcustomAnalyzer.LoadRules(rules.Generate(false).RulesInfo())\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `\n\t\t\t\tpackage foo\n\t\t\t\tfunc foo(){\n\t\t\t\t}`)\n\t\t\tpkg.AddFile(\"foo_test.go\", `\n\t\t\t\tpackage foo_test\n\t\t\t\timport \"testing\"\n\t\t\t\tfunc test() error {\n\t\t\t\t  return nil\n\t\t\t\t}\n\t\t\t\tfunc TestFoo(t *testing.T){\n\t\t\t\t\ttest()\n\t\t\t\t}`)\n\t\t\terr := pkg.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = customAnalyzer.Process(buildTags, pkg.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tissues, _, _ := customAnalyzer.Report()\n\t\t\tExpect(issues).Should(HaveLen(1))\n\t\t})\n\t\tIt(\"should be able to scan generated files if NOT excluded when using the rules\", func() {\n\t\t\tcustomAnalyzer := gosec.NewAnalyzer(nil, true, false, false, 1, logger)\n\t\t\tcustomAnalyzer.LoadRules(rules.Generate(false).RulesInfo())\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `\n\t\t\t\tpackage foo\n\t\t\t\t// Code generated some-generator DO NOT EDIT.\n\t\t\t\tfunc test() error {\n\t\t\t\t  return nil\n\t\t\t\t}\n\t\t\t\tfunc TestFoo(t *testing.T){\n\t\t\t\t\ttest()\n\t\t\t\t}`)\n\t\t\terr := pkg.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = customAnalyzer.Process(buildTags, pkg.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tissues, _, _ := customAnalyzer.Report()\n\t\t\tExpect(issues).Should(HaveLen(1))\n\t\t})\n\t\tIt(\"should be able to skip generated files if excluded when using the rules\", func() {\n\t\t\tcustomAnalyzer := gosec.NewAnalyzer(nil, true, true, false, 1, logger)\n\t\t\tcustomAnalyzer.LoadRules(rules.Generate(false).RulesInfo())\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `\n\t\t\t\t// Code generated some-generator DO NOT EDIT.\n\t\t\t\tpackage foo\n\t\t\t\tfunc test() error {\n\t\t\t\t  return nil\n\t\t\t\t}\n\t\t\t\tfunc TestFoo(t *testing.T){\n\t\t\t\t\ttest()\n\t\t\t\t}`)\n\t\t\terr := pkg.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = customAnalyzer.Process(buildTags, pkg.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tissues, _, _ := customAnalyzer.Report()\n\t\t\tExpect(issues).Should(BeEmpty())\n\t\t})\n\t\tIt(\"should be able to scan generated files if NOT excluded when using the analyzes\", func() {\n\t\t\tcustomAnalyzer := gosec.NewAnalyzer(nil, true, false, false, 1, logger)\n\t\t\tcustomAnalyzer.LoadRules(rules.Generate(false).RulesInfo())\n\t\t\tcustomAnalyzer.LoadAnalyzers(analyzers.Generate(false).AnalyzersInfo())\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `\n\t\t\t\tpackage main\n\t\t\t\t// Code generated some-generator DO NOT EDIT.\n        import (\n          \"fmt\"\n        )\n        func main() {\n          values := []string{}\n          fmt.Println(values[0])\n\t\t\t\t}`)\n\t\t\terr := pkg.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = customAnalyzer.Process(buildTags, pkg.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tissues, _, _ := customAnalyzer.Report()\n\t\t\tExpect(issues).Should(HaveLen(1))\n\t\t})\n\t\tIt(\"should be able to skip generated files if excluded when using the analyzes\", func() {\n\t\t\tcustomAnalyzer := gosec.NewAnalyzer(nil, true, true, false, 1, logger)\n\t\t\tcustomAnalyzer.LoadRules(rules.Generate(false).RulesInfo())\n\t\t\tcustomAnalyzer.LoadAnalyzers(analyzers.Generate(false).AnalyzersInfo())\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `\n\t\t\t\t// Code generated some-generator DO NOT EDIT.\n\t\t\t\tpackage main\n        import (\n          \"fmt\"\n        )\n        func main() {\n          values := []string{}\n          fmt.Println(values[0])\n\t\t\t\t}`)\n\t\t\terr := pkg.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = customAnalyzer.Process(buildTags, pkg.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tissues, _, _ := customAnalyzer.Report()\n\t\t\tExpect(issues).Should(BeEmpty())\n\t\t})\n\t})\n\tIt(\"should be able to analyze Cgo files\", func() {\n\t\tanalyzer.LoadRules(rules.Generate(false).RulesInfo())\n\t\tsample := testutils.SampleCodeCgo[0]\n\t\tsource := sample.Code[0]\n\n\t\ttestPackage := testutils.NewTestPackage()\n\t\tdefer testPackage.Close()\n\t\ttestPackage.AddFile(\"main.go\", source)\n\t\terr := testPackage.Build()\n\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\terr = analyzer.Process(buildTags, testPackage.Path)\n\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\tissues, _, _ := analyzer.Report()\n\t\tExpect(issues).Should(BeEmpty())\n\t})\n\n\tContext(\"when parsing errors from a package\", func() {\n\t\tIt(\"should return no error when the error list is empty\", func() {\n\t\t\tpkg := &packages.Package{}\n\t\t\terr := analyzer.ParseErrors(pkg)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t})\n\n\t\tIt(\"should properly parse the errors\", func() {\n\t\t\tpkg := &packages.Package{\n\t\t\t\tErrors: []packages.Error{\n\t\t\t\t\t{\n\t\t\t\t\t\tPos: \"file:1:2\",\n\t\t\t\t\t\tMsg: \"build error\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\terr := analyzer.ParseErrors(pkg)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\t_, _, errors := analyzer.Report()\n\t\t\tExpect(errors).To(HaveLen(1))\n\t\t\tfor _, ferr := range errors {\n\t\t\t\tExpect(ferr).To(HaveLen(1))\n\t\t\t\tExpect(ferr[0].Line).To(Equal(1))\n\t\t\t\tExpect(ferr[0].Column).To(Equal(2))\n\t\t\t\tExpect(ferr[0].Err).Should(MatchRegexp(`build error`))\n\t\t\t}\n\t\t})\n\n\t\tIt(\"should properly parse the errors without line and column\", func() {\n\t\t\tpkg := &packages.Package{\n\t\t\t\tErrors: []packages.Error{\n\t\t\t\t\t{\n\t\t\t\t\t\tPos: \"file\",\n\t\t\t\t\t\tMsg: \"build error\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\terr := analyzer.ParseErrors(pkg)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\t_, _, errors := analyzer.Report()\n\t\t\tExpect(errors).To(HaveLen(1))\n\t\t\tfor _, ferr := range errors {\n\t\t\t\tExpect(ferr).To(HaveLen(1))\n\t\t\t\tExpect(ferr[0].Line).To(Equal(0))\n\t\t\t\tExpect(ferr[0].Column).To(Equal(0))\n\t\t\t\tExpect(ferr[0].Err).Should(MatchRegexp(`build error`))\n\t\t\t}\n\t\t})\n\n\t\tIt(\"should properly parse the errors without column\", func() {\n\t\t\tpkg := &packages.Package{\n\t\t\t\tErrors: []packages.Error{\n\t\t\t\t\t{\n\t\t\t\t\t\tPos: \"file\",\n\t\t\t\t\t\tMsg: \"build error\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\terr := analyzer.ParseErrors(pkg)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\t_, _, errors := analyzer.Report()\n\t\t\tExpect(errors).To(HaveLen(1))\n\t\t\tfor _, ferr := range errors {\n\t\t\t\tExpect(ferr).To(HaveLen(1))\n\t\t\t\tExpect(ferr[0].Line).To(Equal(0))\n\t\t\t\tExpect(ferr[0].Column).To(Equal(0))\n\t\t\t\tExpect(ferr[0].Err).Should(MatchRegexp(`build error`))\n\t\t\t}\n\t\t})\n\n\t\tIt(\"should return error when line cannot be parsed\", func() {\n\t\t\tpkg := &packages.Package{\n\t\t\t\tErrors: []packages.Error{\n\t\t\t\t\t{\n\t\t\t\t\t\tPos: \"file:line\",\n\t\t\t\t\t\tMsg: \"build error\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\terr := analyzer.ParseErrors(pkg)\n\t\t\tExpect(err).Should(HaveOccurred())\n\t\t})\n\n\t\tIt(\"should return error when column cannot be parsed\", func() {\n\t\t\tpkg := &packages.Package{\n\t\t\t\tErrors: []packages.Error{\n\t\t\t\t\t{\n\t\t\t\t\t\tPos: \"file:1:column\",\n\t\t\t\t\t\tMsg: \"build error\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\terr := analyzer.ParseErrors(pkg)\n\t\t\tExpect(err).Should(HaveOccurred())\n\t\t})\n\n\t\tIt(\"should append  error to the same file\", func() {\n\t\t\tpkg := &packages.Package{\n\t\t\t\tErrors: []packages.Error{\n\t\t\t\t\t{\n\t\t\t\t\t\tPos: \"file:1:2\",\n\t\t\t\t\t\tMsg: \"error1\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tPos: \"file:3:4\",\n\t\t\t\t\t\tMsg: \"error2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\terr := analyzer.ParseErrors(pkg)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\t_, _, errors := analyzer.Report()\n\t\t\tExpect(errors).To(HaveLen(1))\n\t\t\tfor _, ferr := range errors {\n\t\t\t\tExpect(ferr).To(HaveLen(2))\n\t\t\t\tExpect(ferr[0].Line).To(Equal(1))\n\t\t\t\tExpect(ferr[0].Column).To(Equal(2))\n\t\t\t\tExpect(ferr[0].Err).Should(MatchRegexp(`error1`))\n\t\t\t\tExpect(ferr[1].Line).To(Equal(3))\n\t\t\t\tExpect(ferr[1].Column).To(Equal(4))\n\t\t\t\tExpect(ferr[1].Err).Should(MatchRegexp(`error2`))\n\t\t\t}\n\t\t})\n\n\t\tIt(\"should set the config\", func() {\n\t\t\tconfig := gosec.NewConfig()\n\t\t\tconfig[\"test\"] = \"test\"\n\t\t\tanalyzer.SetConfig(config)\n\t\t\tfound := analyzer.Config()\n\t\t\tExpect(config).To(Equal(found))\n\t\t})\n\n\t\tIt(\"should reset the analyzer\", func() {\n\t\t\tanalyzer.Reset()\n\t\t\tissues, metrics, errors := analyzer.Report()\n\t\t\tExpect(issues).To(BeEmpty())\n\t\t\tExpect(*metrics).To(Equal(gosec.Metrics{}))\n\t\t\tExpect(errors).To(BeEmpty())\n\t\t})\n\t})\n\n\tContext(\"when appending errors\", func() {\n\t\tIt(\"should skip error for non-buildable packages\", func() {\n\t\t\terr := &build.NoGoError{\n\t\t\t\tDir: \"pkg/test\",\n\t\t\t}\n\t\t\tanalyzer.AppendError(\"test\", err)\n\t\t\t_, _, errors := analyzer.Report()\n\t\t\tExpect(errors).To(BeEmpty())\n\t\t})\n\n\t\tIt(\"should add a new error\", func() {\n\t\t\tpkg := &packages.Package{\n\t\t\t\tErrors: []packages.Error{\n\t\t\t\t\t{\n\t\t\t\t\t\tPos: \"file:1:2\",\n\t\t\t\t\t\tMsg: \"build error\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\terr := analyzer.ParseErrors(pkg)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tanalyzer.AppendError(\"file\", errors.New(\"file build error\"))\n\t\t\t_, _, errors := analyzer.Report()\n\t\t\tExpect(errors).To(HaveLen(1))\n\t\t\tfor _, ferr := range errors {\n\t\t\t\tExpect(ferr).To(HaveLen(2))\n\t\t\t}\n\t\t})\n\t})\n\n\tContext(\"when tracking suppressions\", func() {\n\t\tBeforeEach(func() {\n\t\t\tanalyzer = gosec.NewAnalyzer(nil, tests, false, true, 1, logger)\n\t\t})\n\n\t\tIt(\"should not report an error if the violation is suppressed\", func() {\n\t\t\tsample := testutils.SampleCodeG401[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G401\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md5.New()\", \"h := md5.New() //#nosec G401 -- Justification\", 1)\n\t\t\tnosecPackage.AddFile(\"md5.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tissues, _, _ := analyzer.Report()\n\t\t\tExpect(issues).To(HaveLen(sample.Errors))\n\t\t\tExpect(issues[0].Suppressions).To(HaveLen(1))\n\t\t\tExpect(issues[0].Suppressions[0].Kind).To(Equal(\"inSource\"))\n\t\t\tExpect(issues[0].Suppressions[0].Justification).To(Equal(\"Justification\"))\n\t\t})\n\n\t\tIt(\"should not report an error if the violation is suppressed\", func() {\n\t\t\tsample := testutils.SampleCodeG405[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G405\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"c, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", \"c, e := des.NewCipher([]byte(\\\"mySecret\\\")) //#nosec G405 -- Justification\", 1)\n\t\t\tnosecPackage.AddFile(\"cipher.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tissues, _, _ := analyzer.Report()\n\t\t\tExpect(issues).To(HaveLen(sample.Errors))\n\t\t\tExpect(issues[0].Suppressions).To(HaveLen(1))\n\t\t\tExpect(issues[0].Suppressions[0].Kind).To(Equal(\"inSource\"))\n\t\t\tExpect(issues[0].Suppressions[0].Justification).To(Equal(\"Justification\"))\n\t\t})\n\n\t\tIt(\"should not report an error if the violation is suppressed\", func() {\n\t\t\tsample := testutils.SampleCodeG406[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G406\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md4.New()\", \"h := md4.New() //#nosec G406 -- Justification\", 1)\n\t\t\tnosecPackage.AddFile(\"md4.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tissues, _, _ := analyzer.Report()\n\t\t\tExpect(issues).To(HaveLen(sample.Errors))\n\t\t\tExpect(issues[0].Suppressions).To(HaveLen(1))\n\t\t\tExpect(issues[0].Suppressions[0].Kind).To(Equal(\"inSource\"))\n\t\t\tExpect(issues[0].Suppressions[0].Justification).To(Equal(\"Justification\"))\n\t\t})\n\n\t\tIt(\"should not report an error if the violation is suppressed without certain rules\", func() {\n\t\t\tsample := testutils.SampleCodeG401[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G401\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md5.New()\", \"h := md5.New() //#nosec\", 1)\n\t\t\tnosecPackage.AddFile(\"md5.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tissues, _, _ := analyzer.Report()\n\t\t\tExpect(issues).To(HaveLen(sample.Errors))\n\t\t\tExpect(issues[0].Suppressions).To(HaveLen(1))\n\t\t\tExpect(issues[0].Suppressions[0].Kind).To(Equal(\"inSource\"))\n\t\t\tExpect(issues[0].Suppressions[0].Justification).To(Equal(\"\"))\n\t\t})\n\n\t\tIt(\"should not report an error if the violation is suppressed without certain rules\", func() {\n\t\t\tsample := testutils.SampleCodeG405[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G405\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"c, e := des.NewCipher([]byte(\\\"mySecret\\\"))\", \"c, e := des.NewCipher([]byte(\\\"mySecret\\\")) //#nosec\", 1)\n\t\t\tnosecPackage.AddFile(\"cipher.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tissues, _, _ := analyzer.Report()\n\t\t\tExpect(issues).To(HaveLen(sample.Errors))\n\t\t\tExpect(issues[0].Suppressions).To(HaveLen(1))\n\t\t\tExpect(issues[0].Suppressions[0].Kind).To(Equal(\"inSource\"))\n\t\t\tExpect(issues[0].Suppressions[0].Justification).To(Equal(\"\"))\n\t\t})\n\n\t\tIt(\"should not report an error if the violation is suppressed without certain rules\", func() {\n\t\t\tsample := testutils.SampleCodeG406[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G406\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"h := md4.New()\", \"h := md4.New() //#nosec\", 1)\n\t\t\tnosecPackage.AddFile(\"md4.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tissues, _, _ := analyzer.Report()\n\t\t\tExpect(issues).To(HaveLen(sample.Errors))\n\t\t\tExpect(issues[0].Suppressions).To(HaveLen(1))\n\t\t\tExpect(issues[0].Suppressions[0].Kind).To(Equal(\"inSource\"))\n\t\t\tExpect(issues[0].Suppressions[0].Justification).To(Equal(\"\"))\n\t\t})\n\n\t\tIt(\"should not report an error if the rule is not included\", func() {\n\t\t\tsample := testutils.SampleCodeG101[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(true, rules.NewRuleFilter(false, \"G401\")).RulesInfo())\n\n\t\t\tcontrolPackage := testutils.NewTestPackage()\n\t\t\tdefer controlPackage.Close()\n\t\t\tcontrolPackage.AddFile(\"pwd.go\", source)\n\t\t\terr := controlPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, controlPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tcontrolIssues, _, _ := analyzer.Report()\n\t\t\tExpect(controlIssues).Should(HaveLen(sample.Errors))\n\t\t\tExpect(controlIssues[0].Suppressions).To(HaveLen(1))\n\t\t\tExpect(controlIssues[0].Suppressions[0].Kind).To(Equal(\"external\"))\n\t\t\tExpect(controlIssues[0].Suppressions[0].Justification).To(Equal(\"Globally suppressed.\"))\n\t\t})\n\n\t\tIt(\"should not report an error if the rule is excluded\", func() {\n\t\t\tsample := testutils.SampleCodeG101[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(true, rules.NewRuleFilter(true, \"G101\")).RulesInfo())\n\n\t\t\tcontrolPackage := testutils.NewTestPackage()\n\t\t\tdefer controlPackage.Close()\n\t\t\tcontrolPackage.AddFile(\"pwd.go\", source)\n\t\t\terr := controlPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, controlPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tissues, _, _ := analyzer.Report()\n\t\t\tExpect(issues).Should(HaveLen(sample.Errors))\n\t\t\tExpect(issues[0].Suppressions).To(HaveLen(1))\n\t\t\tExpect(issues[0].Suppressions[0].Kind).To(Equal(\"external\"))\n\t\t\tExpect(issues[0].Suppressions[0].Justification).To(Equal(\"Globally suppressed.\"))\n\t\t})\n\n\t\tIt(\"should not report an error if the analyzer is not included\", func() {\n\t\t\tsample := testutils.SampleCodeG407[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadAnalyzers(analyzers.Generate(true, analyzers.NewAnalyzerFilter(false, \"G115\")).AnalyzersInfo())\n\n\t\t\tcontrolPackage := testutils.NewTestPackage()\n\t\t\tdefer controlPackage.Close()\n\t\t\tcontrolPackage.AddFile(\"cipher.go\", source)\n\t\t\terr := controlPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, controlPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tcontrolIssues, _, _ := analyzer.Report()\n\t\t\tExpect(controlIssues).Should(HaveLen(sample.Errors))\n\t\t\tExpect(controlIssues[0].Suppressions).To(HaveLen(1))\n\t\t\tExpect(controlIssues[0].Suppressions[0].Kind).To(Equal(\"external\"))\n\t\t\tExpect(controlIssues[0].Suppressions[0].Justification).To(Equal(\"Globally suppressed.\"))\n\t\t})\n\n\t\tIt(\"should not report an error if the analyzer is excluded\", func() {\n\t\t\tsample := testutils.SampleCodeG407[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadAnalyzers(analyzers.Generate(true, analyzers.NewAnalyzerFilter(true, \"G407\")).AnalyzersInfo())\n\n\t\t\tcontrolPackage := testutils.NewTestPackage()\n\t\t\tdefer controlPackage.Close()\n\t\t\tcontrolPackage.AddFile(\"cipher.go\", source)\n\t\t\terr := controlPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, controlPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tissues, _, _ := analyzer.Report()\n\t\t\tExpect(issues).Should(HaveLen(sample.Errors))\n\t\t\tExpect(issues[0].Suppressions).To(HaveLen(1))\n\t\t\tExpect(issues[0].Suppressions[0].Kind).To(Equal(\"external\"))\n\t\t\tExpect(issues[0].Suppressions[0].Justification).To(Equal(\"Globally suppressed.\"))\n\t\t})\n\n\t\tIt(\"should not report an error if the analyzer is not included\", func() {\n\t\t\tsample := testutils.SampleCodeG602[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadAnalyzers(analyzers.Generate(true, analyzers.NewAnalyzerFilter(false, \"G115\")).AnalyzersInfo())\n\n\t\t\tcontrolPackage := testutils.NewTestPackage()\n\t\t\tdefer controlPackage.Close()\n\t\t\tcontrolPackage.AddFile(\"cipher.go\", source)\n\t\t\terr := controlPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, controlPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tcontrolIssues, _, _ := analyzer.Report()\n\t\t\tExpect(controlIssues).Should(HaveLen(sample.Errors))\n\t\t\tExpect(controlIssues[0].Suppressions).To(HaveLen(1))\n\t\t\tExpect(controlIssues[0].Suppressions[0].Kind).To(Equal(\"external\"))\n\t\t\tExpect(controlIssues[0].Suppressions[0].Justification).To(Equal(\"Globally suppressed.\"))\n\t\t})\n\n\t\tIt(\"should not report an error if the analyzer is excluded\", func() {\n\t\t\tsample := testutils.SampleCodeG602[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadAnalyzers(analyzers.Generate(true, analyzers.NewAnalyzerFilter(true, \"G602\")).AnalyzersInfo())\n\n\t\t\tcontrolPackage := testutils.NewTestPackage()\n\t\t\tdefer controlPackage.Close()\n\t\t\tcontrolPackage.AddFile(\"cipher.go\", source)\n\t\t\terr := controlPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, controlPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tissues, _, _ := analyzer.Report()\n\t\t\tExpect(issues).Should(HaveLen(sample.Errors))\n\t\t\tExpect(issues[0].Suppressions).To(HaveLen(1))\n\t\t\tExpect(issues[0].Suppressions[0].Kind).To(Equal(\"external\"))\n\t\t\tExpect(issues[0].Suppressions[0].Justification).To(Equal(\"Globally suppressed.\"))\n\t\t})\n\n\t\tIt(\"should track multiple suppressions if the violation is multiply suppressed\", func() {\n\t\t\tsample := testutils.SampleCodeG101[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(true, rules.NewRuleFilter(true, \"G101\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source, \"password := \\\"f62e5bcda4fae4f82370da0c6f20697b8f8447ef\\\"\", \"password := \\\"f62e5bcda4fae4f82370da0c6f20697b8f8447ef\\\" //#nosec G101 -- Justification\", 1)\n\t\t\tnosecPackage.AddFile(\"pwd.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tissues, _, _ := analyzer.Report()\n\t\t\tExpect(issues).Should(HaveLen(sample.Errors))\n\t\t\tExpect(issues[0].Suppressions).To(HaveLen(2))\n\t\t})\n\n\t\tIt(\"should not report an error if the violation is suppressed on a struct filed\", func() {\n\t\t\tsample := testutils.SampleCodeG402[0]\n\t\t\tsource := sample.Code[0]\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G402\")).RulesInfo())\n\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecSource := strings.Replace(source,\n\t\t\t\t\"TLSClientConfig: &tls.Config{InsecureSkipVerify: true}\",\n\t\t\t\t\"TLSClientConfig: &tls.Config{InsecureSkipVerify: true} // #nosec G402\", 1)\n\t\t\tnosecPackage.AddFile(\"tls.go\", nosecSource)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tissues, _, _ := analyzer.Report()\n\t\t\tExpect(issues).To(HaveLen(sample.Errors))\n\t\t\tExpect(issues[0].Suppressions).To(HaveLen(1))\n\t\t\tExpect(issues[0].Suppressions[0].Kind).To(Equal(\"inSource\"))\n\t\t})\n\n\t\tIt(\"should not report an error if the violation is suppressed on multi-lien issue\", func() {\n\t\t\tsource := `\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nconst TokenLabel = `\n\t\t\tsource += \"`\" + `\nf62e5bcda4fae4f82370da0c6f20697b8f8447ef\n      ` + \"`\" + \"//#nosec G101 -- false positive, this is not a private data\" + `\nfunc main() {\n\tfmt.Printf(\"Label: %s \", TokenLabel)\n}\n      `\n\t\t\tanalyzer.LoadRules(rules.Generate(false, rules.NewRuleFilter(false, \"G101\")).RulesInfo())\n\t\t\tnosecPackage := testutils.NewTestPackage()\n\t\t\tdefer nosecPackage.Close()\n\t\t\tnosecPackage.AddFile(\"pwd.go\", source)\n\t\t\terr := nosecPackage.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\terr = analyzer.Process(buildTags, nosecPackage.Path)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tissues, _, _ := analyzer.Report()\n\t\t\tExpect(issues).To(HaveLen(1))\n\t\t\tExpect(issues[0].Suppressions).To(HaveLen(1))\n\t\t\tExpect(issues[0].Suppressions[0].Kind).To(Equal(\"inSource\"))\n\t\t\tExpect(issues[0].Suppressions[0].Justification).To(Equal(\"false positive, this is not a private data\"))\n\t\t})\n\t})\n})\n"
        },
        {
          "name": "analyzers",
          "type": "tree",
          "content": null
        },
        {
          "name": "autofix",
          "type": "tree",
          "content": null
        },
        {
          "name": "call_list.go",
          "type": "blob",
          "size": 3.28515625,
          "content": "//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gosec\n\nimport (\n\t\"go/ast\"\n\t\"strings\"\n)\n\nconst vendorPath = \"vendor/\"\n\ntype set map[string]bool\n\n// CallList is used to check for usage of specific packages\n// and functions.\ntype CallList map[string]set\n\n// NewCallList creates a new empty CallList\nfunc NewCallList() CallList {\n\treturn make(CallList)\n}\n\n// AddAll will add several calls to the call list at once\nfunc (c CallList) AddAll(selector string, idents ...string) {\n\tfor _, ident := range idents {\n\t\tc.Add(selector, ident)\n\t}\n}\n\n// Add a selector and call to the call list\nfunc (c CallList) Add(selector, ident string) {\n\tif _, ok := c[selector]; !ok {\n\t\tc[selector] = make(set)\n\t}\n\tc[selector][ident] = true\n}\n\n// Contains returns true if the package and function are\n// members of this call list.\nfunc (c CallList) Contains(selector, ident string) bool {\n\tif idents, ok := c[selector]; ok {\n\t\t_, found := idents[ident]\n\t\treturn found\n\t}\n\treturn false\n}\n\n// ContainsPointer returns true if a pointer to the selector type or the type\n// itself is a members of this call list.\nfunc (c CallList) ContainsPointer(selector, indent string) bool {\n\tif strings.HasPrefix(selector, \"*\") {\n\t\tif c.Contains(selector, indent) {\n\t\t\treturn true\n\t\t}\n\t\ts := strings.TrimPrefix(selector, \"*\")\n\t\treturn c.Contains(s, indent)\n\t}\n\treturn false\n}\n\n// ContainsPkgCallExpr resolves the call expression name and type, and then further looks\n// up the package path for that type. Finally, it determines if the call exists within the call list\nfunc (c CallList) ContainsPkgCallExpr(n ast.Node, ctx *Context, stripVendor bool) *ast.CallExpr {\n\tselector, ident, err := GetCallInfo(n, ctx)\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\t// Selector can have two forms:\n\t// 1. A short name if a module function is called (expr.Name).\n\t// E.g., \"big\" if called function from math/big.\n\t// 2. A full name if a structure function is called (TypeOf(expr)).\n\t// E.g., \"math/big.Rat\" if called function of Rat structure from math/big.\n\tif !strings.ContainsRune(selector, '.') {\n\t\t// Use only explicit path (optionally strip vendor path prefix) to reduce conflicts\n\t\tpath, ok := GetImportPath(selector, ctx)\n\t\tif !ok {\n\t\t\treturn nil\n\t\t}\n\t\tselector = path\n\t}\n\n\tif stripVendor {\n\t\tif vendorIdx := strings.Index(selector, vendorPath); vendorIdx >= 0 {\n\t\t\tselector = selector[vendorIdx+len(vendorPath):]\n\t\t}\n\t}\n\tif !c.Contains(selector, ident) {\n\t\treturn nil\n\t}\n\n\treturn n.(*ast.CallExpr)\n}\n\n// ContainsCallExpr resolves the call expression name and type, and then determines\n// if the call exists with the call list\nfunc (c CallList) ContainsCallExpr(n ast.Node, ctx *Context) *ast.CallExpr {\n\tselector, ident, err := GetCallInfo(n, ctx)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tif !c.Contains(selector, ident) && !c.ContainsPointer(selector, ident) {\n\t\treturn nil\n\t}\n\n\treturn n.(*ast.CallExpr)\n}\n"
        },
        {
          "name": "call_list_test.go",
          "type": "blob",
          "size": 4.607421875,
          "content": "package gosec_test\n\nimport (\n\t\"go/ast\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"github.com/securego/gosec/v2\"\n\t\"github.com/securego/gosec/v2/testutils\"\n)\n\nvar _ = Describe(\"Call List\", func() {\n\tvar calls gosec.CallList\n\tBeforeEach(func() {\n\t\tcalls = gosec.NewCallList()\n\t})\n\n\tIt(\"should not return any matches when empty\", func() {\n\t\tExpect(calls.Contains(\"foo\", \"bar\")).Should(BeFalse())\n\t})\n\n\tIt(\"should be possible to add a single call\", func() {\n\t\tExpect(calls).Should(BeEmpty())\n\t\tcalls.Add(\"foo\", \"bar\")\n\t\tExpect(calls).Should(HaveLen(1))\n\n\t\texpected := make(map[string]bool)\n\t\texpected[\"bar\"] = true\n\t\tactual := map[string]bool(calls[\"foo\"])\n\t\tExpect(actual).Should(Equal(expected))\n\t})\n\n\tIt(\"should be possible to add multiple calls at once\", func() {\n\t\tExpect(calls).Should(BeEmpty())\n\t\tcalls.AddAll(\"fmt\", \"Sprint\", \"Sprintf\", \"Printf\", \"Println\")\n\n\t\texpected := map[string]bool{\n\t\t\t\"Sprint\":  true,\n\t\t\t\"Sprintf\": true,\n\t\t\t\"Printf\":  true,\n\t\t\t\"Println\": true,\n\t\t}\n\t\tactual := map[string]bool(calls[\"fmt\"])\n\t\tExpect(actual).Should(Equal(expected))\n\t})\n\n\tIt(\"should be possible to add pointer call\", func() {\n\t\tExpect(calls).Should(BeEmpty())\n\t\tcalls.Add(\"*bytes.Buffer\", \"WriteString\")\n\t\tactual := calls.ContainsPointer(\"*bytes.Buffer\", \"WriteString\")\n\t\tExpect(actual).Should(BeTrue())\n\t})\n\n\tIt(\"should be possible to check pointer call\", func() {\n\t\tExpect(calls).Should(BeEmpty())\n\t\tcalls.Add(\"bytes.Buffer\", \"WriteString\")\n\t\tactual := calls.ContainsPointer(\"*bytes.Buffer\", \"WriteString\")\n\t\tExpect(actual).Should(BeTrue())\n\t})\n\n\tIt(\"should not return a match if none are present\", func() {\n\t\tcalls.Add(\"ioutil\", \"Copy\")\n\t\tExpect(calls.Contains(\"fmt\", \"Println\")).Should(BeFalse())\n\t})\n\n\tIt(\"should match a call based on selector and ident\", func() {\n\t\tcalls.Add(\"ioutil\", \"Copy\")\n\t\tExpect(calls.Contains(\"ioutil\", \"Copy\")).Should(BeTrue())\n\t})\n\n\tIt(\"should match a package call expression\", func() {\n\t\t// Create file to be scanned\n\t\tpkg := testutils.NewTestPackage()\n\t\tdefer pkg.Close()\n\t\tpkg.AddFile(\"md5.go\", testutils.SampleCodeG401[0].Code[0])\n\n\t\tctx := pkg.CreateContext(\"md5.go\")\n\n\t\t// Search for md5.New()\n\t\tcalls.Add(\"crypto/md5\", \"New\")\n\n\t\t// Stub out visitor and count number of matched call expr\n\t\tmatched := 0\n\t\tv := testutils.NewMockVisitor()\n\t\tv.Context = ctx\n\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\tif _, ok := n.(*ast.CallExpr); ok && calls.ContainsPkgCallExpr(n, ctx, false) != nil {\n\t\t\t\tmatched++\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\t\tast.Walk(v, ctx.Root)\n\t\tExpect(matched).Should(Equal(1))\n\t})\n\n\tIt(\"should match a package call expression\", func() {\n\t\t// Create file to be scanned\n\t\tpkg := testutils.NewTestPackage()\n\t\tdefer pkg.Close()\n\t\tpkg.AddFile(\"cipher.go\", testutils.SampleCodeG405[0].Code[0])\n\n\t\tctx := pkg.CreateContext(\"cipher.go\")\n\n\t\t// Search for des.NewCipher()\n\t\tcalls.Add(\"crypto/des\", \"NewCipher\")\n\n\t\t// Stub out visitor and count number of matched call expr\n\t\tmatched := 0\n\t\tv := testutils.NewMockVisitor()\n\t\tv.Context = ctx\n\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\tif _, ok := n.(*ast.CallExpr); ok && calls.ContainsPkgCallExpr(n, ctx, false) != nil {\n\t\t\t\tmatched++\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\t\tast.Walk(v, ctx.Root)\n\t\tExpect(matched).Should(Equal(1))\n\t})\n\n\tIt(\"should match a package call expression\", func() {\n\t\t// Create file to be scanned\n\t\tpkg := testutils.NewTestPackage()\n\t\tdefer pkg.Close()\n\t\tpkg.AddFile(\"md4.go\", testutils.SampleCodeG406[0].Code[0])\n\n\t\tctx := pkg.CreateContext(\"md4.go\")\n\n\t\t// Search for md4.New()\n\t\tcalls.Add(\"golang.org/x/crypto/md4\", \"New\")\n\n\t\t// Stub out visitor and count number of matched call expr\n\t\tmatched := 0\n\t\tv := testutils.NewMockVisitor()\n\t\tv.Context = ctx\n\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\tif _, ok := n.(*ast.CallExpr); ok && calls.ContainsPkgCallExpr(n, ctx, false) != nil {\n\t\t\t\tmatched++\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\t\tast.Walk(v, ctx.Root)\n\t\tExpect(matched).Should(Equal(1))\n\t})\n\n\tIt(\"should match a call expression\", func() {\n\t\t// Create file to be scanned\n\t\tpkg := testutils.NewTestPackage()\n\t\tdefer pkg.Close()\n\t\tpkg.AddFile(\"main.go\", testutils.SampleCodeG104[6].Code[0])\n\n\t\tctx := pkg.CreateContext(\"main.go\")\n\n\t\tcalls.Add(\"bytes.Buffer\", \"WriteString\")\n\t\tcalls.Add(\"strings.Builder\", \"WriteString\")\n\t\tcalls.Add(\"io.Pipe\", \"CloseWithError\")\n\t\tcalls.Add(\"fmt\", \"Fprintln\")\n\n\t\t// Stub out visitor and count number of matched call expr\n\t\tmatched := 0\n\t\tv := testutils.NewMockVisitor()\n\t\tv.Context = ctx\n\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\tif _, ok := n.(*ast.CallExpr); ok && calls.ContainsCallExpr(n, ctx) != nil {\n\t\t\t\tmatched++\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\t\tast.Walk(v, ctx.Root)\n\t\tExpect(matched).Should(Equal(5))\n\t})\n})\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 3.9189453125,
          "content": "package gosec\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n)\n\nconst (\n\t// Globals are applicable to all rules and used for general\n\t// configuration settings for gosec.\n\tGlobals = \"global\"\n)\n\n// GlobalOption defines the name of the global options\ntype GlobalOption string\n\nconst (\n\t// Nosec global option for #nosec directive\n\tNosec GlobalOption = \"nosec\"\n\t// ShowIgnored defines whether nosec issues are counted as finding or not\n\tShowIgnored GlobalOption = \"show-ignored\"\n\t// Audit global option which indicates that gosec runs in audit mode\n\tAudit GlobalOption = \"audit\"\n\t// NoSecAlternative global option alternative for #nosec directive\n\tNoSecAlternative GlobalOption = \"#nosec\"\n\t// ExcludeRules global option for some rules  should not be load\n\tExcludeRules GlobalOption = \"exclude\"\n\t// IncludeRules global option for  should be load\n\tIncludeRules GlobalOption = \"include\"\n\t// SSA global option to enable go analysis framework with SSA support\n\tSSA GlobalOption = \"ssa\"\n)\n\n// NoSecTag returns the tag used to disable gosec for a line of code.\nfunc NoSecTag(tag string) string {\n\treturn fmt.Sprintf(\"%s%s\", \"#\", tag)\n}\n\n// Config is used to provide configuration and customization to each of the rules.\ntype Config map[string]interface{}\n\n// NewConfig initializes a new configuration instance. The configuration data then\n// needs to be loaded via c.ReadFrom(strings.NewReader(\"config data\"))\n// or from a *os.File.\nfunc NewConfig() Config {\n\tcfg := make(Config)\n\tcfg[Globals] = make(map[GlobalOption]string)\n\treturn cfg\n}\n\nfunc (c Config) keyToGlobalOptions(key string) GlobalOption {\n\treturn GlobalOption(key)\n}\n\nfunc (c Config) convertGlobals() {\n\tif globals, ok := c[Globals]; ok {\n\t\tif settings, ok := globals.(map[string]interface{}); ok {\n\t\t\tvalidGlobals := map[GlobalOption]string{}\n\t\t\tfor k, v := range settings {\n\t\t\t\tvalidGlobals[c.keyToGlobalOptions(k)] = fmt.Sprintf(\"%v\", v)\n\t\t\t}\n\t\t\tc[Globals] = validGlobals\n\t\t}\n\t}\n}\n\n// ReadFrom implements the io.ReaderFrom interface. This\n// should be used with io.Reader to load configuration from\n// file or from string etc.\nfunc (c Config) ReadFrom(r io.Reader) (int64, error) {\n\tdata, err := io.ReadAll(r)\n\tif err != nil {\n\t\treturn int64(len(data)), err\n\t}\n\tif err = json.Unmarshal(data, &c); err != nil {\n\t\treturn int64(len(data)), err\n\t}\n\tc.convertGlobals()\n\treturn int64(len(data)), nil\n}\n\n// WriteTo implements the io.WriteTo interface. This should\n// be used to save or print out the configuration information.\nfunc (c Config) WriteTo(w io.Writer) (int64, error) {\n\tdata, err := json.Marshal(c)\n\tif err != nil {\n\t\treturn int64(len(data)), err\n\t}\n\treturn io.Copy(w, bytes.NewReader(data))\n}\n\n// Get returns the configuration section for the supplied key\nfunc (c Config) Get(section string) (interface{}, error) {\n\tsettings, found := c[section]\n\tif !found {\n\t\treturn nil, fmt.Errorf(\"Section %s not in configuration\", section)\n\t}\n\treturn settings, nil\n}\n\n// Set section in the configuration to specified value\nfunc (c Config) Set(section string, value interface{}) {\n\tc[section] = value\n}\n\n// GetGlobal returns value associated with global configuration option\nfunc (c Config) GetGlobal(option GlobalOption) (string, error) {\n\tif globals, ok := c[Globals]; ok {\n\t\tif settings, ok := globals.(map[GlobalOption]string); ok {\n\t\t\tif value, ok := settings[option]; ok {\n\t\t\t\treturn value, nil\n\t\t\t}\n\t\t\treturn \"\", fmt.Errorf(\"global setting for %s not found\", option)\n\t\t}\n\t}\n\treturn \"\", fmt.Errorf(\"no global config options found\")\n}\n\n// SetGlobal associates a value with a global configuration option\nfunc (c Config) SetGlobal(option GlobalOption, value string) {\n\tif globals, ok := c[Globals]; ok {\n\t\tif settings, ok := globals.(map[GlobalOption]string); ok {\n\t\t\tsettings[option] = value\n\t\t}\n\t}\n}\n\n// IsGlobalEnabled checks if a global option is enabled\nfunc (c Config) IsGlobalEnabled(option GlobalOption) (bool, error) {\n\tvalue, err := c.GetGlobal(option)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn (value == \"true\" || value == \"enabled\"), nil\n}\n"
        },
        {
          "name": "config_test.go",
          "type": "blob",
          "size": 4.05859375,
          "content": "package gosec_test\n\nimport (\n\t\"bytes\"\n\t\"strings\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"github.com/securego/gosec/v2\"\n)\n\nvar _ = Describe(\"Configuration\", func() {\n\tvar configuration gosec.Config\n\tBeforeEach(func() {\n\t\tconfiguration = gosec.NewConfig()\n\t})\n\n\tContext(\"when loading from disk\", func() {\n\t\tIt(\"should be possible to load configuration from a file\", func() {\n\t\t\tjson := `{\"G101\": {}}`\n\t\t\tbuffer := bytes.NewBufferString(json)\n\t\t\tnread, err := configuration.ReadFrom(buffer)\n\t\t\tExpect(nread).Should(Equal(int64(len(json))))\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t})\n\n\t\tIt(\"should return an error if configuration file is invalid\", func() {\n\t\t\tvar err error\n\t\t\tinvalidBuffer := bytes.NewBuffer([]byte{0xc0, 0xff, 0xee})\n\t\t\t_, err = configuration.ReadFrom(invalidBuffer)\n\t\t\tExpect(err).Should(HaveOccurred())\n\n\t\t\temptyBuffer := bytes.NewBuffer([]byte{})\n\t\t\t_, err = configuration.ReadFrom(emptyBuffer)\n\t\t\tExpect(err).Should(HaveOccurred())\n\t\t})\n\t})\n\n\tContext(\"when saving to disk\", func() {\n\t\tIt(\"should be possible to save an empty configuration to file\", func() {\n\t\t\texpected := `{\"global\":{}}`\n\t\t\tbuffer := bytes.NewBuffer([]byte{})\n\t\t\tnbytes, err := configuration.WriteTo(buffer)\n\t\t\tExpect(int(nbytes)).Should(Equal(len(expected)))\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tExpect(buffer.String()).Should(Equal(expected))\n\t\t})\n\n\t\tIt(\"should be possible to save configuration to file\", func() {\n\t\t\tconfiguration.Set(\"G101\", map[string]string{\n\t\t\t\t\"mode\": \"strict\",\n\t\t\t})\n\n\t\t\tbuffer := bytes.NewBuffer([]byte{})\n\t\t\tnbytes, err := configuration.WriteTo(buffer)\n\t\t\tExpect(int(nbytes)).ShouldNot(BeZero())\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tExpect(buffer.String()).Should(Equal(`{\"G101\":{\"mode\":\"strict\"},\"global\":{}}`))\n\t\t})\n\t})\n\n\tContext(\"when configuring rules\", func() {\n\t\tIt(\"should be possible to get configuration for a rule\", func() {\n\t\t\tsettings := map[string]string{\n\t\t\t\t\"ciphers\": \"AES256-GCM\",\n\t\t\t}\n\t\t\tconfiguration.Set(\"G101\", settings)\n\n\t\t\tretrieved, err := configuration.Get(\"G101\")\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tExpect(retrieved).Should(HaveKeyWithValue(\"ciphers\", \"AES256-GCM\"))\n\t\t\tExpect(retrieved).ShouldNot(HaveKey(\"foobar\"))\n\t\t})\n\t})\n\n\tContext(\"when using global configuration options\", func() {\n\t\tIt(\"should have a default global section\", func() {\n\t\t\tsettings, err := configuration.Get(\"global\")\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\texpectedType := make(map[gosec.GlobalOption]string)\n\t\t\tExpect(settings).Should(BeAssignableToTypeOf(expectedType))\n\t\t})\n\n\t\tIt(\"should save global settings to correct section\", func() {\n\t\t\tconfiguration.SetGlobal(gosec.Nosec, \"enabled\")\n\t\t\tsettings, err := configuration.Get(\"global\")\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tif globals, ok := settings.(map[gosec.GlobalOption]string); ok {\n\t\t\t\tExpect(globals[\"nosec\"]).Should(MatchRegexp(\"enabled\"))\n\t\t\t} else {\n\t\t\t\tFail(\"globals are not defined as map\")\n\t\t\t}\n\n\t\t\tsetValue, err := configuration.GetGlobal(gosec.Nosec)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tExpect(setValue).Should(MatchRegexp(\"enabled\"))\n\t\t})\n\n\t\tIt(\"should find global settings which are enabled\", func() {\n\t\t\tconfiguration.SetGlobal(gosec.Nosec, \"enabled\")\n\t\t\tenabled, err := configuration.IsGlobalEnabled(gosec.Nosec)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tExpect(enabled).Should(BeTrue())\n\t\t})\n\n\t\tIt(\"should parse the global settings of type string from file\", func() {\n\t\t\tconfig := `\n\t\t\t{\n\t\t\t\t\"global\": {\n\t\t\t\t\t\"nosec\": \"enabled\"\n\t\t\t\t}\n\t\t\t}`\n\t\t\tcfg := gosec.NewConfig()\n\t\t\t_, err := cfg.ReadFrom(strings.NewReader(config))\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\n\t\t\tvalue, err := cfg.GetGlobal(gosec.Nosec)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tExpect(value).Should(Equal(\"enabled\"))\n\t\t})\n\t\tIt(\"should parse the global settings of other types from file\", func() {\n\t\t\tconfig := `\n\t\t\t{\n\t\t\t\t\"global\": {\n\t\t\t\t\t\"nosec\": true\n\t\t\t\t}\n\t\t\t}`\n\t\t\tcfg := gosec.NewConfig()\n\t\t\t_, err := cfg.ReadFrom(strings.NewReader(config))\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\n\t\t\tvalue, err := cfg.GetGlobal(gosec.Nosec)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tExpect(value).Should(Equal(\"true\"))\n\t\t})\n\t})\n})\n"
        },
        {
          "name": "cosign.pub",
          "type": "blob",
          "size": 0.173828125,
          "content": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEFphl7f2VuFRfsi4wqiLUCQ9xHQgV\nO2VMDNcvh+kxiymLXa+GkPzSKExFYIlVwfg13URvCiB+kFvITmLzuLiGQg==\n-----END PUBLIC KEY-----\n"
        },
        {
          "name": "cwe",
          "type": "tree",
          "content": null
        },
        {
          "name": "entrypoint.sh",
          "type": "blob",
          "size": 0.3857421875,
          "content": "#!/usr/bin/env bash\n\n# Expand the arguments into an array of strings. This is required because the GitHub action\n# provides all arguments concatenated as a single string.\nARGS=(\"$@\")\n\nif [[ ! -z \"${GITHUB_AUTHENTICATION_TOKEN}\" ]]; then\n  git config --global --add url.\"https://x-access-token:${GITHUB_AUTHENTICATION_TOKEN}@github.com/\".insteadOf \"https://github.com/\"\nfi\n\n/bin/gosec ${ARGS[*]}\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 0.67578125,
          "content": "package gosec\n\nimport (\n\t\"sort\"\n)\n\n// Error is used when there are golang errors while parsing the AST\ntype Error struct {\n\tLine   int    `json:\"line\"`\n\tColumn int    `json:\"column\"`\n\tErr    string `json:\"error\"`\n}\n\n// NewError creates Error object\nfunc NewError(line, column int, err string) *Error {\n\treturn &Error{\n\t\tLine:   line,\n\t\tColumn: column,\n\t\tErr:    err,\n\t}\n}\n\n// sortErrors sorts the golang errors by line\nfunc sortErrors(allErrors map[string][]Error) {\n\tfor _, errors := range allErrors {\n\t\tsort.Slice(errors, func(i, j int) bool {\n\t\t\tif errors[i].Line == errors[j].Line {\n\t\t\t\treturn errors[i].Column <= errors[j].Column\n\t\t\t}\n\t\t\treturn errors[i].Line < errors[j].Line\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "flag_test.go",
          "type": "blob",
          "size": 1.4072265625,
          "content": "package gosec_test\n\nimport (\n\t\"flag\"\n\t\"os\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"github.com/securego/gosec/v2/cmd/vflag\"\n)\n\nvar _ = Describe(\"Cli\", func() {\n\tContext(\"vflag test\", func() {\n\t\tIt(\"value must be empty as parameter value contains invalid character\", func() {\n\t\t\tos.Args = []string{\"gosec\", \"-flag1=-incorrect\"}\n\t\t\tf := vflag.ValidatedFlag{}\n\t\t\tflag.CommandLine = flag.NewFlagSet(os.Args[0], flag.ContinueOnError)\n\t\t\tflag.Var(&f, \"falg1\", \"\")\n\t\t\tflag.CommandLine.Init(\"flag1\", flag.ContinueOnError)\n\t\t\tflag.Parse()\n\t\t\tExpect(flag.Parsed()).Should(BeTrue())\n\t\t\tExpect(f.Value).Should(Equal(``))\n\t\t})\n\t\tIt(\"value must be empty as parameter value contains invalid character without equal sign\", func() {\n\t\t\tos.Args = []string{\"gosec\", \"-test2= -incorrect\"}\n\t\t\tf := vflag.ValidatedFlag{}\n\t\t\tflag.CommandLine = flag.NewFlagSet(os.Args[0], flag.ContinueOnError)\n\t\t\tflag.Var(&f, \"test2\", \"\")\n\t\t\tflag.CommandLine.Init(\"test2\", flag.ContinueOnError)\n\t\t\tflag.Parse()\n\t\t\tExpect(flag.Parsed()).Should(BeTrue())\n\t\t\tExpect(f.Value).Should(Equal(``))\n\t\t})\n\t\tIt(\"value must not be empty as parameter value contains valid character\", func() {\n\t\t\tos.Args = []string{\"gosec\", \"-test3=correct\"}\n\t\t\tf := vflag.ValidatedFlag{}\n\t\t\tflag.Var(&f, \"test3\", \"\")\n\t\t\tflag.CommandLine.Init(\"test3\", flag.ContinueOnError)\n\t\t\tflag.Parse()\n\t\t\tExpect(flag.Parsed()).Should(BeTrue())\n\t\t\tExpect(f.Value).Should(Equal(`correct`))\n\t\t})\n\t})\n})\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 2.326171875,
          "content": "module github.com/securego/gosec/v2\n\nrequire (\n\tgithub.com/ccojocar/zxcvbn-go v1.0.2\n\tgithub.com/google/generative-ai-go v0.19.0\n\tgithub.com/google/uuid v1.6.0\n\tgithub.com/gookit/color v1.5.4\n\tgithub.com/lib/pq v1.10.9\n\tgithub.com/mozilla/tls-observatory v0.0.0-20210609171429-7bc42856d2e5\n\tgithub.com/onsi/ginkgo/v2 v2.22.2\n\tgithub.com/onsi/gomega v1.36.2\n\tgithub.com/stretchr/testify v1.10.0\n\tgolang.org/x/crypto v0.31.0\n\tgolang.org/x/text v0.21.0\n\tgolang.org/x/tools v0.28.0\n\tgoogle.golang.org/api v0.214.0\n\tgopkg.in/yaml.v3 v3.0.1\n)\n\nrequire (\n\tcloud.google.com/go v0.116.0 // indirect\n\tcloud.google.com/go/ai v0.8.0 // indirect\n\tcloud.google.com/go/auth v0.13.0 // indirect\n\tcloud.google.com/go/auth/oauth2adapt v0.2.6 // indirect\n\tcloud.google.com/go/compute/metadata v0.6.0 // indirect\n\tcloud.google.com/go/longrunning v0.5.7 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/felixge/httpsnoop v1.0.4 // indirect\n\tgithub.com/go-logr/logr v1.4.2 // indirect\n\tgithub.com/go-logr/stdr v1.2.2 // indirect\n\tgithub.com/go-task/slim-sprig/v3 v3.0.0 // indirect\n\tgithub.com/google/go-cmp v0.6.0 // indirect\n\tgithub.com/google/pprof v0.0.0-20241210010833-40e02aabc2ad // indirect\n\tgithub.com/google/s2a-go v0.1.8 // indirect\n\tgithub.com/googleapis/enterprise-certificate-proxy v0.3.4 // indirect\n\tgithub.com/googleapis/gax-go/v2 v2.14.0 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/stretchr/objx v0.5.2 // indirect\n\tgithub.com/xo/terminfo v0.0.0-20210125001918-ca9a967f8778 // indirect\n\tgo.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.54.0 // indirect\n\tgo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.54.0 // indirect\n\tgo.opentelemetry.io/otel v1.29.0 // indirect\n\tgo.opentelemetry.io/otel/metric v1.29.0 // indirect\n\tgo.opentelemetry.io/otel/trace v1.29.0 // indirect\n\tgolang.org/x/mod v0.22.0 // indirect\n\tgolang.org/x/net v0.33.0 // indirect\n\tgolang.org/x/oauth2 v0.24.0 // indirect\n\tgolang.org/x/sync v0.10.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n\tgolang.org/x/time v0.8.0 // indirect\n\tgoogle.golang.org/genproto/googleapis/api v0.0.0-20241118233622-e639e219e697 // indirect\n\tgoogle.golang.org/genproto/googleapis/rpc v0.0.0-20241209162323-e6fa225c2576 // indirect\n\tgoogle.golang.org/grpc v1.67.1 // indirect\n\tgoogle.golang.org/protobuf v1.36.1 // indirect\n)\n\ngo 1.22.0\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 69.8125,
          "content": "bitbucket.org/creachadair/shell v0.0.6/go.mod h1:8Qqi/cYk7vPnsOePHroKXDJYmb5x7ENhtiFtfZq8K+M=\ncloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.38.0/go.mod h1:990N+gfupTy94rShfmMCWGDn0LpTmnzTp2qbd1dvSRU=\ncloud.google.com/go v0.44.1/go.mod h1:iSa0KzasP4Uvy3f1mN/7PiObzGgflwredwwASm/v6AU=\ncloud.google.com/go v0.44.2/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxKY=\ncloud.google.com/go v0.45.1/go.mod h1:RpBamKRgapWJb87xiFSdk4g1CME7QZg3uwTez+TSTjc=\ncloud.google.com/go v0.46.3/go.mod h1:a6bKKbmY7er1mI7TEI4lsAkts/mkhTSZK8w33B4RAg0=\ncloud.google.com/go v0.50.0/go.mod h1:r9sluTvynVuxRIOHXQEHMFffphuXHOMZMycpNR5e6To=\ncloud.google.com/go v0.52.0/go.mod h1:pXajvRH/6o3+F9jDHZWQ5PbGhn+o8w9qiu/CffaVdO4=\ncloud.google.com/go v0.53.0/go.mod h1:fp/UouUEsRkN6ryDKNW/Upv/JBKnv6WDthjR6+vze6M=\ncloud.google.com/go v0.54.0/go.mod h1:1rq2OEkV3YMf6n/9ZvGWI3GWw0VoqH/1x2nd8Is/bPc=\ncloud.google.com/go v0.56.0/go.mod h1:jr7tqZxxKOVYizybht9+26Z/gUq7tiRzu+ACVAMbKVk=\ncloud.google.com/go v0.57.0/go.mod h1:oXiQ6Rzq3RAkkY7N6t3TcE6jE+CIBBbA36lwQ1JyzZs=\ncloud.google.com/go v0.60.0/go.mod h1:yw2G51M9IfRboUH61Us8GqCeF1PzPblB823Mn2q2eAU=\ncloud.google.com/go v0.116.0 h1:B3fRrSDkLRt5qSHWe40ERJvhvnQwdZiHu0bJOpldweE=\ncloud.google.com/go v0.116.0/go.mod h1:cEPSRWPzZEswwdr9BxE6ChEn01dWlTaF05LiC2Xs70U=\ncloud.google.com/go/ai v0.8.0 h1:rXUEz8Wp2OlrM8r1bfmpF2+VKqc1VJpafE3HgzRnD/w=\ncloud.google.com/go/ai v0.8.0/go.mod h1:t3Dfk4cM61sytiggo2UyGsDVW3RF1qGZaUKDrZFyqkE=\ncloud.google.com/go/auth v0.13.0 h1:8Fu8TZy167JkW8Tj3q7dIkr2v4cndv41ouecJx0PAHs=\ncloud.google.com/go/auth v0.13.0/go.mod h1:COOjD9gwfKNKz+IIduatIhYJQIc0mG3H102r/EMxX6Q=\ncloud.google.com/go/auth/oauth2adapt v0.2.6 h1:V6a6XDu2lTwPZWOawrAa9HUK+DB2zfJyTuciBG5hFkU=\ncloud.google.com/go/auth/oauth2adapt v0.2.6/go.mod h1:AlmsELtlEBnaNTL7jCj8VQFLy6mbZv0s4Q7NGBeQ5E8=\ncloud.google.com/go/bigquery v1.0.1/go.mod h1:i/xbL2UlR5RvWAURpBYZTtm/cXjCha9lbfbpx4poX+o=\ncloud.google.com/go/bigquery v1.3.0/go.mod h1:PjpwJnslEMmckchkHFfq+HTD2DmtT67aNFKH1/VBDHE=\ncloud.google.com/go/bigquery v1.4.0/go.mod h1:S8dzgnTigyfTmLBfrtrhyYhwRxG72rYxvftPBK2Dvzc=\ncloud.google.com/go/bigquery v1.5.0/go.mod h1:snEHRnqQbz117VIFhE8bmtwIDY80NLUZUMb4Nv6dBIg=\ncloud.google.com/go/bigquery v1.7.0/go.mod h1://okPTzCYNXSlb24MZs83e2Do+h+VXtc4gLoIoXIAPc=\ncloud.google.com/go/bigquery v1.8.0/go.mod h1:J5hqkt3O0uAFnINi6JXValWIb1v0goeZM77hZzJN/fQ=\ncloud.google.com/go/compute/metadata v0.6.0 h1:A6hENjEsCDtC1k8byVsgwvVcioamEHvZ4j01OwKxG9I=\ncloud.google.com/go/compute/metadata v0.6.0/go.mod h1:FjyFAW1MW0C203CEOMDTu3Dk1FlqW3Rga40jzHL4hfg=\ncloud.google.com/go/datastore v1.0.0/go.mod h1:LXYbyblFSglQ5pkeyhO+Qmw7ukd3C+pD7TKLgZqpHYE=\ncloud.google.com/go/datastore v1.1.0/go.mod h1:umbIZjpQpHh4hmRpGhH4tLFup+FVzqBi1b3c64qFpCk=\ncloud.google.com/go/longrunning v0.5.7 h1:WLbHekDbjK1fVFD3ibpFFVoyizlLRl73I7YKuAKilhU=\ncloud.google.com/go/longrunning v0.5.7/go.mod h1:8GClkudohy1Fxm3owmBGid8W0pSgodEMwEAztp38Xng=\ncloud.google.com/go/pubsub v1.0.1/go.mod h1:R0Gpsv3s54REJCy4fxDixWD93lHJMoZTyQ2kNxGRt3I=\ncloud.google.com/go/pubsub v1.1.0/go.mod h1:EwwdRX2sKPjnvnqCa270oGRyludottCI76h+R3AArQw=\ncloud.google.com/go/pubsub v1.2.0/go.mod h1:jhfEVHT8odbXTkndysNHCcx0awwzvfOlguIAii9o8iA=\ncloud.google.com/go/pubsub v1.3.1/go.mod h1:i+ucay31+CNRpDW4Lu78I4xXG+O1r/MAHgjpRVR+TSU=\ncloud.google.com/go/pubsub v1.5.0/go.mod h1:ZEwJccE3z93Z2HWvstpri00jOg7oO4UZDtKhwDwqF0w=\ncloud.google.com/go/spanner v1.7.0/go.mod h1:sd3K2gZ9Fd0vMPLXzeCrF6fq4i63Q7aTLW/lBIfBkIk=\ncloud.google.com/go/storage v1.0.0/go.mod h1:IhtSnM/ZTZV8YYJWCY8RULGVqBDmpoyjwiyrjsg+URw=\ncloud.google.com/go/storage v1.5.0/go.mod h1:tpKbwo567HUNpVclU5sGELwQWBDZ8gh0ZeosJ0Rtdos=\ncloud.google.com/go/storage v1.6.0/go.mod h1:N7U0C8pVQ/+NIKOBQyamJIeKQKkZ+mxpohlUTyfDhBk=\ncloud.google.com/go/storage v1.8.0/go.mod h1:Wv1Oy7z6Yz3DshWRJFhqM/UCfaWIRTdp0RXyy7KQOVs=\ncontrib.go.opencensus.io/exporter/stackdriver v0.13.4/go.mod h1:aXENhDJ1Y4lIg4EUaVTwzvYETVNZk10Pu26tevFKLUc=\ndmitri.shuralyov.com/gpu/mtl v0.0.0-20190408044501-666a987793e9/go.mod h1:H6x//7gZCb22OMCxBHrMx7a5I7Hp++hsVxbQ4BYO7hU=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=\ngithub.com/Masterminds/goutils v1.1.0/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=\ngithub.com/Masterminds/semver v1.4.2/go.mod h1:MB6lktGJrhw8PrUyiEoblNEGEQ+RzHPF078ddwwvV3Y=\ngithub.com/Masterminds/semver v1.5.0/go.mod h1:MB6lktGJrhw8PrUyiEoblNEGEQ+RzHPF078ddwwvV3Y=\ngithub.com/Masterminds/sprig v2.15.0+incompatible/go.mod h1:y6hNFY5UBTIWBxnzTeuNhlNS5hqE0NB0E6fgfo2Br3o=\ngithub.com/Masterminds/sprig v2.22.0+incompatible/go.mod h1:y6hNFY5UBTIWBxnzTeuNhlNS5hqE0NB0E6fgfo2Br3o=\ngithub.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=\ngithub.com/alecthomas/units v0.0.0-20190717042225-c3de453c63f4/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=\ngithub.com/antihax/optional v0.0.0-20180407024304-ca021399b1a6/go.mod h1:V8iCPQYkqmusNa815XgQio277wI47sdRh1dUOLdyC6Q=\ngithub.com/aokoli/goutils v1.0.1/go.mod h1:SijmP0QR8LtwsmDs8Yii5Z/S4trXFGFC2oO5g9DP+DQ=\ngithub.com/armon/consul-api v0.0.0-20180202201655-eb2c6b5be1b6/go.mod h1:grANhF5doyWs3UAsr3K4I6qtAmlQcZDesFNEHPZAzj8=\ngithub.com/aws/aws-sdk-go v1.23.20/go.mod h1:KmX6BPdI08NWTb3/sm4ZGu5ShLoqVDhKgpiN924inxo=\ngithub.com/aws/aws-sdk-go v1.25.37/go.mod h1:KmX6BPdI08NWTb3/sm4ZGu5ShLoqVDhKgpiN924inxo=\ngithub.com/aws/aws-sdk-go v1.36.30/go.mod h1:hcU610XS61/+aQV88ixoOzUoG7v3b31pl2zKMmprdro=\ngithub.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=\ngithub.com/beorn7/perks v1.0.0/go.mod h1:KWe93zE9D1o94FZ5RNwFwVgaQK1VOXiVxmqh+CedLV8=\ngithub.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=\ngithub.com/bgentry/speakeasy v0.1.0/go.mod h1:+zsyZBPWlz7T6j88CTgSN5bM796AkVf0kBD4zp0CCIs=\ngithub.com/ccojocar/zxcvbn-go v1.0.2 h1:na/czXU8RrhXO4EZme6eQJLR4PzcGsahsBOAwU6I3Vg=\ngithub.com/ccojocar/zxcvbn-go v1.0.2/go.mod h1:g1qkXtUSvHP8lhHp5GrSmTz6uWALGRMQdw6Qnz/hi60=\ngithub.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=\ngithub.com/cespare/xxhash/v2 v2.1.1/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=\ngithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=\ngithub.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=\ngithub.com/cockroachdb/datadriven v0.0.0-20190809214429-80d97fb3cbaa/go.mod h1:zn76sxSg3SzpJ0PPJaLDCu+Bu0Lg3sKTORVIj19EIF8=\ngithub.com/coreos/etcd v3.3.10+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=\ngithub.com/coreos/go-etcd v2.0.0+incompatible/go.mod h1:Jez6KQU2B/sWsbdaef3ED8NzMklzPG4d5KIOhIy30Tk=\ngithub.com/coreos/go-semver v0.2.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=\ngithub.com/coreos/go-semver v0.3.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=\ngithub.com/coreos/go-systemd v0.0.0-20180511133405-39ca1b05acc7/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=\ngithub.com/coreos/go-systemd v0.0.0-20190620071333-e64a0ec8b42a/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=\ngithub.com/coreos/pkg v0.0.0-20160727233714-3ac0863d7acf/go.mod h1:E3G3o1h8I7cfcXa63jLwjI0eiQQMgzzUDFVpN/nH/eA=\ngithub.com/coreos/pkg v0.0.0-20180928190104-399ea9e2e55f/go.mod h1:E3G3o1h8I7cfcXa63jLwjI0eiQQMgzzUDFVpN/nH/eA=\ngithub.com/cpuguy83/go-md2man v1.0.10/go.mod h1:SmD6nW6nTyfqj6ABTjUi3V3JVMnlJmwcJI5acqYI6dE=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.0-20190314233015-f79a8a8ca69d/go.mod h1:maD7wRr/U5Z6m/iR4s+kqSMx2CaBsrgA7czyZG/E6dU=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.0/go.mod h1:maD7wRr/U5Z6m/iR4s+kqSMx2CaBsrgA7czyZG/E6dU=\ngithub.com/creack/pty v1.1.7/go.mod h1:lj5s0c3V2DBrqTV7llrYr5NG6My20zk30Fl46Y7DoTY=\ngithub.com/davecgh/go-spew v0.0.0-20161028175848-04cdfd42973b/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=\ngithub.com/dustin/go-humanize v0.0.0-20171111073723-bb3d318650d4/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=\ngithub.com/dustin/go-humanize v1.0.0/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=\ngithub.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=\ngithub.com/envoyproxy/protoc-gen-validate v0.0.14/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=\ngithub.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=\ngithub.com/fatih/color v1.7.0/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=\ngithub.com/fatih/color v1.10.0/go.mod h1:ELkj/draVOlAH/xkhN6mQ50Qd0MPOk5AAr3maGEBuJM=\ngithub.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=\ngithub.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/fullstorydev/grpcurl v1.6.0/go.mod h1:ZQ+ayqbKMJNhzLmbpCiurTVlaK2M/3nqZCxaQ2Ze/sM=\ngithub.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=\ngithub.com/go-gl/glfw v0.0.0-20190409004039-e6da0acd62b1/go.mod h1:vR7hzQXu2zJy9AVAgeJqvqgH9Q5CA+iKCZ2gyEVpxRU=\ngithub.com/go-gl/glfw/v3.3/glfw v0.0.0-20191125211704-12ad95a8df72/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=\ngithub.com/go-gl/glfw/v3.3/glfw v0.0.0-20200222043503-6f7a984d4dc4/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=\ngithub.com/go-kit/kit v0.8.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=\ngithub.com/go-kit/kit v0.9.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=\ngithub.com/go-logfmt/logfmt v0.3.0/go.mod h1:Qt1PoO58o5twSAckw1HlFXLmHsOX5/0LbT9GBnD5lWE=\ngithub.com/go-logfmt/logfmt v0.4.0/go.mod h1:3RMwSq7FuexP4Kalkev3ejPJsZTpXXBr9+V4qmtdjCk=\ngithub.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=\ngithub.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=\ngithub.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=\ngithub.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=\ngithub.com/go-redis/redis v6.15.8+incompatible/go.mod h1:NAIEuMOZ/fxfXJIrKDQDz8wamY7mA7PouImQ2Jvg6kA=\ngithub.com/go-sql-driver/mysql v1.5.0/go.mod h1:DCzpHaOWr8IXmIStZouvnhqoel9Qv2LBy8hT2VhHyBg=\ngithub.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=\ngithub.com/go-task/slim-sprig/v3 v3.0.0 h1:sUs3vkvUymDpBKi3qH1YSqBQk9+9D/8M2mN1vB6EwHI=\ngithub.com/go-task/slim-sprig/v3 v3.0.0/go.mod h1:W848ghGpv3Qj3dhTPRyJypKRiqCdHZiAzKg9hl15HA8=\ngithub.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/gogo/protobuf v1.2.1/go.mod h1:hp+jE20tsWTFYpLwKvXlhS1hjn+gTNwPg2I6zVXpSg4=\ngithub.com/gogo/protobuf v1.3.0/go.mod h1:SlYgWuQ5SjCEi6WLHjHCa1yvBfUnHcTbrrZtXPKa29o=\ngithub.com/gogo/protobuf v1.3.1/go.mod h1:SlYgWuQ5SjCEi6WLHjHCa1yvBfUnHcTbrrZtXPKa29o=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/groupcache v0.0.0-20160516000752-02826c3e7903/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20190702054246-869f871628b6/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20191227052852-215e87163ea7/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.3.1/go.mod h1:sBzyDLLjw3U8JLTeZvSv8jJB+tU5PVekmnlKIyFUx0Y=\ngithub.com/golang/mock v1.4.0/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=\ngithub.com/golang/mock v1.4.1/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=\ngithub.com/golang/mock v1.4.3/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=\ngithub.com/golang/mock v1.4.4/go.mod h1:l3mdAwkq5BuhzHwde/uurv3sEJeZMXNpwsxVWU71h+4=\ngithub.com/golang/protobuf v1.1.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=\ngithub.com/golang/protobuf v1.3.4/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=\ngithub.com/golang/protobuf v1.3.5/go.mod h1:6O5/vntMXwX2lRkT1hjjk0nAC1IDOTvTlVgjlRvqsdk=\ngithub.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=\ngithub.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=\ngithub.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=\ngithub.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=\ngithub.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=\ngithub.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=\ngithub.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/certificate-transparency-go v1.0.21/go.mod h1:QeJfpSbVSfYc7RgB3gJFj9cbuQMMchQxrWXz8Ruopmg=\ngithub.com/google/certificate-transparency-go v1.1.1/go.mod h1:FDKqPvSXawb2ecErVRrD+nfy23RCzyl7eqVCEmlT1Zs=\ngithub.com/google/generative-ai-go v0.19.0 h1:R71szggh8wHMCUlEMsW2A/3T+5LdEIkiaHSYgSpUgdg=\ngithub.com/google/generative-ai-go v0.19.0/go.mod h1:JYolL13VG7j79kM5BtHz4qwONHkeJQzOCkKXnpqtS/E=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.2/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=\ngithub.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\ngithub.com/google/pprof v0.0.0-20190515194954-54271f7e092f/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\ngithub.com/google/pprof v0.0.0-20191218002539-d4f498aebedc/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200212024743-f11f1df84d12/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200229191704-1ebb73c60ed3/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200430221834-fc25d7d30c6d/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200507031123-427632fa3b1c/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20241210010833-40e02aabc2ad h1:a6HEuzUHeKH6hwfN/ZoQgRgVIWFJljSWa/zetS2WTvg=\ngithub.com/google/pprof v0.0.0-20241210010833-40e02aabc2ad/go.mod h1:vavhavw2zAxS5dIdcRluK6cSGGPlZynqzFM8NdvU144=\ngithub.com/google/renameio v0.1.0/go.mod h1:KWCgfxg9yswjAJkECMjeO8J8rahYeXnNhOm40UhjYkI=\ngithub.com/google/s2a-go v0.1.8 h1:zZDs9gcbt9ZPLV0ndSyQk6Kacx2g/X+SKYovpnz3SMM=\ngithub.com/google/s2a-go v0.1.8/go.mod h1:6iNWHTpQ+nfNRN5E00MSdfDwVesa8hhS32PhPO8deJA=\ngithub.com/google/trillian v1.3.11/go.mod h1:0tPraVHrSDkA3BO6vKX67zgLXs6SsOAbHEivX+9mPgw=\ngithub.com/google/uuid v0.0.0-20161128191214-064e2069ce9c/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/google/uuid v1.0.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/google/uuid v1.1.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/googleapis/enterprise-certificate-proxy v0.3.4 h1:XYIDZApgAnrN1c855gTgghdIA6Stxb52D5RnLI1SLyw=\ngithub.com/googleapis/enterprise-certificate-proxy v0.3.4/go.mod h1:YKe7cfqYXjKGpGvmSg28/fFvhNzinZQm8DGnaburhGA=\ngithub.com/googleapis/gax-go/v2 v2.0.4/go.mod h1:0Wqv26UfaUD9n4G6kQubkQ+KchISgw+vpHVxEJEs9eg=\ngithub.com/googleapis/gax-go/v2 v2.0.5/go.mod h1:DWXyrwAJ9X0FpwwEdw+IPEYBICEFu5mhpdKc/us6bOk=\ngithub.com/googleapis/gax-go/v2 v2.14.0 h1:f+jMrjBPl+DL9nI4IQzLUxMq7XrAqFYB7hBPqMNIe8o=\ngithub.com/googleapis/gax-go/v2 v2.14.0/go.mod h1:lhBCnjdLrWRaPvLWhmc8IS24m9mr07qSYnHncrgo+zk=\ngithub.com/gookit/color v1.5.4 h1:FZmqs7XOyGgCAxmWyPslpiok1k05wmY3SJTytgvYFs0=\ngithub.com/gookit/color v1.5.4/go.mod h1:pZJOeOS8DM43rXbp4AZo1n9zCU2qjpcRko0b6/QJi9w=\ngithub.com/gordonklaus/ineffassign v0.0.0-20200309095847-7953dde2c7bf/go.mod h1:cuNKsD1zp2v6XfE/orVX2QE1LC+i254ceGcVeDT3pTU=\ngithub.com/gorhill/cronexpr v0.0.0-20180427100037-88b0669f7d75/go.mod h1:g2644b03hfBX9Ov0ZBDgXXens4rxSxmqFBbhvKv2yVA=\ngithub.com/gorilla/mux v1.8.0/go.mod h1:DVbg23sWSpFRCP0SfiEN6jmj59UnW/n46BH5rLB71So=\ngithub.com/gorilla/websocket v0.0.0-20170926233335-4201258b820c/go.mod h1:E7qHFY5m1UJ88s3WnNqhKjPHQ0heANvMoAMk2YaljkQ=\ngithub.com/gorilla/websocket v1.4.1/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\ngithub.com/gregjones/httpcache v0.0.0-20190611155906-901d90724c79/go.mod h1:FecbI9+v66THATjSRHfNgh1IVFe/9kFxbXtjV0ctIMA=\ngithub.com/grpc-ecosystem/go-grpc-middleware v1.0.1-0.20190118093823-f849b5445de4/go.mod h1:FiyG127CGDf3tlThmgyCl78X/SZQqEOJBCDaAfeWzPs=\ngithub.com/grpc-ecosystem/go-grpc-middleware v1.2.2/go.mod h1:EaizFBKfUKtMIF5iaDEhniwNedqGo9FuLFzppDr3uwI=\ngithub.com/grpc-ecosystem/go-grpc-prometheus v1.2.0/go.mod h1:8NvIoxWQoOIhqOTXgfV/d3M/q6VIi02HzZEHgUlZvzk=\ngithub.com/grpc-ecosystem/grpc-gateway v1.9.5/go.mod h1:vNeuVxBJEsws4ogUvrchl83t/GYV9WGTSLVdBhOQFDY=\ngithub.com/grpc-ecosystem/grpc-gateway v1.12.1/go.mod h1:8XEsbTttt/W+VvjtQhLACqCisSPWTxCZ7sBRjU6iH9c=\ngithub.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/hashicorp/golang-lru v0.5.1/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/hashicorp/golang-lru v0.5.4/go.mod h1:iADmTwqILo4mZ8BN3D2Q6+9jd8WM5uGBxy+E8yxSoD4=\ngithub.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=\ngithub.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=\ngithub.com/huandu/xstrings v1.0.0/go.mod h1:4qWG/gcEcfX4z/mBDHJ++3ReCw9ibxbsNJbcucJdbSo=\ngithub.com/huandu/xstrings v1.2.0/go.mod h1:DvyZB1rfVYsBIigL8HwpZgxHwXozlTgGqn63UyNX5k4=\ngithub.com/ianlancetaylor/demangle v0.0.0-20181102032728-5e5cf60278f6/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=\ngithub.com/imdario/mergo v0.3.4/go.mod h1:2EnlNZ0deacrJVfApfmtdGgDfMuh/nq6Ok1EcJh5FfA=\ngithub.com/imdario/mergo v0.3.8/go.mod h1:2EnlNZ0deacrJVfApfmtdGgDfMuh/nq6Ok1EcJh5FfA=\ngithub.com/inconshreveable/mousetrap v1.0.0/go.mod h1:PxqpIevigyE2G7u3NXJIT2ANytuPF1OarO4DADm73n8=\ngithub.com/jhump/protoreflect v1.6.1/go.mod h1:RZQ/lnuN+zqeRVpQigTwO6o0AJUkxbnSnpuG7toUTG4=\ngithub.com/jmespath/go-jmespath v0.0.0-20180206201540-c2b33e8439af/go.mod h1:Nht3zPeWKUH0NzdCt2Blrr5ys8VGpn0CEB0cQHVjt7k=\ngithub.com/jmespath/go-jmespath v0.4.0/go.mod h1:T8mJZnbsbmF+m6zOOFylbeCJqk5+pHWvzYPziyZiYoo=\ngithub.com/jmespath/go-jmespath/internal/testify v1.5.1/go.mod h1:L3OGu8Wl2/fWfCI6z80xFu9LTZmf1ZRjMHUOPmWr69U=\ngithub.com/jonboulle/clockwork v0.1.0/go.mod h1:Ii8DK3G1RaLaWxj9trq07+26W01tbo22gdxWY5EU2bo=\ngithub.com/jonboulle/clockwork v0.2.0/go.mod h1:Pkfl5aHPm1nk2H9h0bjmnJD/BcgbGXUBGnn1kMkgxc8=\ngithub.com/json-iterator/go v1.1.6/go.mod h1:+SdeFBvtyEkXs7REEP0seUULqWtbJapLOCVDaaPEHmU=\ngithub.com/json-iterator/go v1.1.7/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=\ngithub.com/json-iterator/go v1.1.10/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=\ngithub.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=\ngithub.com/jstemmer/go-junit-report v0.9.1/go.mod h1:Brl9GWCQeLvo8nXZwPNNblvFj/XSXhF0NWZEnDohbsk=\ngithub.com/juju/ratelimit v1.0.1/go.mod h1:qapgC/Gy+xNh9UxzV13HGGl/6UXNN+ct+vwSgWNm/qk=\ngithub.com/julienschmidt/httprouter v1.2.0/go.mod h1:SYymIcj16QtmaHHD7aYtjjsJG7VTCxuUUipMqKk8s4w=\ngithub.com/k0kubun/colorstring v0.0.0-20150214042306-9440f1994b88/go.mod h1:3w7q1U84EfirKl04SVQ/s7nPm1ZPhiXd34z40TNz36k=\ngithub.com/kisielk/errcheck v1.1.0/go.mod h1:EZBBE59ingxPouuu3KfxchcWSUPOHkagtvWXihfKN4Q=\ngithub.com/kisielk/errcheck v1.2.0/go.mod h1:/BMXB+zMLi60iA8Vv6Ksmxu/1UDYcXs4uQLJ+jE2L00=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.2/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFBFZlji/RkVcI2GknAs/DXo4wKdlNEc=\ngithub.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kylelemons/godebug v1.1.0/go.mod h1:9/0rRGxNHcop5bhtWyNeEfOS8JIWk580+fNqagV/RAw=\ngithub.com/letsencrypt/pkcs11key/v4 v4.0.0/go.mod h1:EFUvBDay26dErnNb70Nd0/VW3tJiIbETBPTl9ATXQag=\ngithub.com/lib/pq v1.8.0/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=\ngithub.com/lib/pq v1.9.0/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=\ngithub.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=\ngithub.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=\ngithub.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=\ngithub.com/mattn/go-colorable v0.0.9/go.mod h1:9vuHe8Xs5qXnSaW/c/ABM9alt+Vo+STaOChaDxuIBZU=\ngithub.com/mattn/go-colorable v0.1.4/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=\ngithub.com/mattn/go-colorable v0.1.8/go.mod h1:u6P/XSegPjTcexA+o6vUJrdnUu04hMope9wVRipJSqc=\ngithub.com/mattn/go-isatty v0.0.4/go.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=\ngithub.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=\ngithub.com/mattn/go-isatty v0.0.10/go.mod h1:qgIWMr58cqv1PHHyhnkY9lrL7etaEgOFcMEpPG5Rm84=\ngithub.com/mattn/go-isatty v0.0.12/go.mod h1:cbi8OIDigv2wuxKPP5vlRcQ1OAZbq2CE4Kysco4FUpU=\ngithub.com/mattn/go-runewidth v0.0.2/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=\ngithub.com/mattn/go-runewidth v0.0.4/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=\ngithub.com/mattn/go-runewidth v0.0.6/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=\ngithub.com/miekg/dns v1.1.35/go.mod h1:KNUDUusw/aVsxyTYZM1oqvCicbwhgbNgztCETuNZ7xM=\ngithub.com/miekg/pkcs11 v1.0.2/go.mod h1:XsNlhZGX73bx86s2hdc/FuaLm2CPZJemRLMA+WTFxgs=\ngithub.com/miekg/pkcs11 v1.0.3/go.mod h1:XsNlhZGX73bx86s2hdc/FuaLm2CPZJemRLMA+WTFxgs=\ngithub.com/mitchellh/copystructure v1.0.0/go.mod h1:SNtv71yrdKgLRyLFxmLdkAbkKEFWgYaq1OVrnRcwhnw=\ngithub.com/mitchellh/go-homedir v1.1.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=\ngithub.com/mitchellh/mapstructure v1.1.2/go.mod h1:FVVH3fgwuzCH5S8UJGiWEs2h04kUh9fWfEaFds41c1Y=\ngithub.com/mitchellh/reflectwalk v1.0.0/go.mod h1:mSTlrgnPZtwu0c4WaC2kGObEpuNDbx0jmZXqmk4esnw=\ngithub.com/mitchellh/reflectwalk v1.0.1/go.mod h1:mSTlrgnPZtwu0c4WaC2kGObEpuNDbx0jmZXqmk4esnw=\ngithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/modern-go/reflect2 v1.0.1/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826/go.mod h1:TaXosZuwdSHYgviHp1DAtfrULt5eUgsSMsZf+YrPgl8=\ngithub.com/mozilla/scribe v0.0.0-20180711195314-fb71baf557c1/go.mod h1:FIczTrinKo8VaLxe6PWTPEXRXDIHz2QAwiaBaP5/4a8=\ngithub.com/mozilla/tls-observatory v0.0.0-20210609171429-7bc42856d2e5 h1:0KqC6/sLy7fDpBdybhVkkv4Yz+PmB7c9Dz9z3dLW804=\ngithub.com/mozilla/tls-observatory v0.0.0-20210609171429-7bc42856d2e5/go.mod h1:FUqVoUPHSEdDR0MnFM3Dh8AU0pZHLXUD127SAJGER/s=\ngithub.com/mwitkow/go-conntrack v0.0.0-20161129095857-cc309e4a2223/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=\ngithub.com/mwitkow/go-proto-validators v0.0.0-20180403085117-0950a7990007/go.mod h1:m2XC9Qq0AlmmVksL6FktJCdTYyLk7V3fKyp0sl1yWQo=\ngithub.com/mwitkow/go-proto-validators v0.2.0/go.mod h1:ZfA1hW+UH/2ZHOWvQ3HnQaU0DtnpXu850MZiy+YUgcc=\ngithub.com/nishanths/predeclared v0.0.0-20190419143655-18a43bb90ffc/go.mod h1:62PewwiQTlm/7Rj+cxVYqZvDIUc+JjZq6GHAC1fsObQ=\ngithub.com/olekukonko/tablewriter v0.0.0-20170122224234-a0225b3f23b5/go.mod h1:vsDQFd/mU46D+Z4whnwzcISnGGzXWMclvtLoiIKAKIo=\ngithub.com/olekukonko/tablewriter v0.0.1/go.mod h1:vsDQFd/mU46D+Z4whnwzcISnGGzXWMclvtLoiIKAKIo=\ngithub.com/olekukonko/tablewriter v0.0.2/go.mod h1:rSAaSIOAGT9odnlyGlUfAJaoc5w2fSBUmeGDbRWPxyQ=\ngithub.com/onsi/ginkgo v1.6.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo v1.10.3/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo/v2 v2.22.2 h1:/3X8Panh8/WwhU/3Ssa6rCKqPLuAkVY2I0RoyDLySlU=\ngithub.com/onsi/ginkgo/v2 v2.22.2/go.mod h1:oeMosUL+8LtarXBHu/c0bx2D/K9zyQ6uX3cTyztHwsk=\ngithub.com/onsi/gomega v1.7.1/go.mod h1:XdKZgCCFLUoM/7CFJVPcG8C1xQ1AJ0vpAezJrB7JYyY=\ngithub.com/onsi/gomega v1.36.2 h1:koNYke6TVk6ZmnyHrCXba/T/MoLBXFjeC1PtvYgw0A8=\ngithub.com/onsi/gomega v1.36.2/go.mod h1:DdwyADRjrc825LhMEkD76cHR5+pUnjhUN8GlHlRPHzY=\ngithub.com/opentracing/opentracing-go v1.1.0/go.mod h1:UkNAQd3GIcIGf0SeVgPpRdFStlNbqXla1AfSYxPUl2o=\ngithub.com/pelletier/go-toml v1.2.0/go.mod h1:5z9KED0ma1S8pY6P1sdut58dfprrGBbd/94hg7ilaic=\ngithub.com/peterbourgon/diskv v2.0.1+incompatible/go.mod h1:uqqh8zWWbv1HBMNONnaR/tNboyR3/BZd58JJSHlUSCU=\ngithub.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v0.0.0-20151028094244-d8ed2627bdf0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_golang v0.9.1/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=\ngithub.com/prometheus/client_golang v1.0.0/go.mod h1:db9x61etRT2tGnBNRi70OPL5FsnadC4Ky3P0J6CfImo=\ngithub.com/prometheus/client_golang v1.7.1/go.mod h1:PY5Wy2awLA44sXw4AOSfFBetzPP4j5+D6mVACh+pe2M=\ngithub.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/client_model v0.0.0-20190129233127-fd36f4220a90/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/client_model v0.2.0/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/common v0.4.1/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=\ngithub.com/prometheus/common v0.10.0/go.mod h1:Tlit/dnDKsSWFlCLTWaA1cyBgKHSMdTB80sz/V91rCo=\ngithub.com/prometheus/procfs v0.0.0-20181005140218-185b4288413d/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/prometheus/procfs v0.0.2/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=\ngithub.com/prometheus/procfs v0.1.3/go.mod h1:lV6e/gmhEcM9IjHGsFOCxxuZ+z1YqCvr4OA4YeYWdaU=\ngithub.com/pseudomuto/protoc-gen-doc v1.3.2/go.mod h1:y5+P6n3iGrbKG+9O04V5ld71in3v/bX88wUwgt+U8EA=\ngithub.com/pseudomuto/protokit v0.2.0/go.mod h1:2PdH30hxVHsup8KpBTOXTBeMVhJZVio3Q8ViKSAXT0Q=\ngithub.com/rogpeppe/fastuuid v0.0.0-20150106093220-6724a57986af/go.mod h1:XWv6SoW27p1b0cqNHllgS5HIMJraePCO15w5zCzIWYg=\ngithub.com/rogpeppe/fastuuid v1.2.0/go.mod h1:jVj6XXZzXRy/MSR5jhDC/2q6DgLz+nrA6LYCDYWNEvQ=\ngithub.com/rogpeppe/go-internal v1.3.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=\ngithub.com/rs/cors v1.7.0/go.mod h1:gFx+x8UowdsKA9AchylcLynDq+nNFfI8FkUZdN/jGCU=\ngithub.com/russross/blackfriday v1.5.2/go.mod h1:JO/DiYxRf+HjHt06OyowR9PTA263kcR/rfWxYHBV53g=\ngithub.com/russross/blackfriday/v2 v2.0.1/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/sergi/go-diff v1.1.0/go.mod h1:STckp+ISIX8hZLjrqAeVduY0gWCT9IjLuqbuNXdaHfM=\ngithub.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=\ngithub.com/sirupsen/logrus v1.2.0/go.mod h1:LxeOpSwHxABJmUn/MG1IvRgCAasNZTLOkJPxbbu5VWo=\ngithub.com/sirupsen/logrus v1.4.2/go.mod h1:tLMulIdttU9McNUspp0xgXVQah82FyeX6MwdIuYE2rE=\ngithub.com/sirupsen/logrus v1.7.0/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0=\ngithub.com/soheilhy/cmux v0.1.4/go.mod h1:IM3LyeVVIOuxMH7sFAkER9+bJ4dT7Ms6E4xg4kGIyLM=\ngithub.com/spf13/afero v1.1.2/go.mod h1:j4pytiNVoe2o6bmDsKpLACNPDBIoEAkihy7loJ1B0CQ=\ngithub.com/spf13/cast v1.3.0/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=\ngithub.com/spf13/cobra v0.0.3/go.mod h1:1l0Ry5zgKvJasoi3XT1TypsSe7PqH0Sj9dhYf7v3XqQ=\ngithub.com/spf13/cobra v0.0.5/go.mod h1:3K3wKZymM7VvHMDS9+Akkh4K60UwM26emMESw8tLCHU=\ngithub.com/spf13/jwalterweatherman v1.0.0/go.mod h1:cQK4TGJAtQXfYWX+Ddv3mKDzgVb68N+wFjFa4jdeBTo=\ngithub.com/spf13/pflag v1.0.1/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=\ngithub.com/spf13/pflag v1.0.3/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=\ngithub.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngithub.com/spf13/viper v1.3.2/go.mod h1:ZiWeW+zYFKm7srdB9IoDzzZXaJaI5eL9QjNiN/DMA2s=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.5.2 h1:xuMeJ0Sdp5ZMRXx/aWO6RZxdr3beISkG5/G/aIRr3pY=\ngithub.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=\ngithub.com/stretchr/testify v0.0.0-20170130113145-4d4bfba8f1d1/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/tmc/grpc-websocket-proxy v0.0.0-20170815181823-89b8d40f7ca8/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=\ngithub.com/tmc/grpc-websocket-proxy v0.0.0-20190109142713-0ad062ec5ee5/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=\ngithub.com/tmc/grpc-websocket-proxy v0.0.0-20200427203606-3cfed13b9966/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=\ngithub.com/tomasen/realip v0.0.0-20180522021738-f0c99a92ddce/go.mod h1:o8v6yHRoik09Xen7gje4m9ERNah1d1PPsVq1VEx9vE4=\ngithub.com/ugorji/go/codec v0.0.0-20181204163529-d75b2dcb6bc8/go.mod h1:VFNgLljTbGfSG7qAOspJ7OScBnGdDN/yBr0sguwnwf0=\ngithub.com/urfave/cli v1.20.0/go.mod h1:70zkFmudgCuE/ngEzBv17Jvp/497gISqfk5gWijbERA=\ngithub.com/urfave/cli v1.22.1/go.mod h1:Gos4lmkARVdJ6EkW0WaNv/tZAAMe9V7XWyB60NtXRu0=\ngithub.com/viki-org/dnscache v0.0.0-20130720023526-c70c1f23c5d8/go.mod h1:dniwbG03GafCjFohMDmz6Zc6oCuiqgH6tGNyXTkHzXE=\ngithub.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2/go.mod h1:UETIi67q53MR2AWcXfiuqkDkRtnGDLqkBTpCHuJHxtU=\ngithub.com/xo/terminfo v0.0.0-20210125001918-ca9a967f8778 h1:QldyIu/L63oPpyvQmHgvgickp1Yw510KJOqX7H24mg8=\ngithub.com/xo/terminfo v0.0.0-20210125001918-ca9a967f8778/go.mod h1:2MuV+tbUrU1zIOPMxZ5EncGwgmMJsa+9ucAQZXxsObs=\ngithub.com/xordataexchange/crypt v0.0.3-0.20170626215501-b2862e3d0a77/go.mod h1:aYKd//L2LvnjZzWKhF00oedf4jCCReLcmhLdhm1A27Q=\ngithub.com/yudai/gojsondiff v1.0.0/go.mod h1:AY32+k2cwILAkW1fbgxQ5mUmMiZFgLIV+FBNExI05xg=\ngithub.com/yudai/golcs v0.0.0-20170316035057-ecda9a501e82/go.mod h1:lgjkn3NuSvDfVJdfcVVdX+jpBxNmX4rDAzaS45IcYoM=\ngithub.com/yudai/pp v2.0.1+incompatible/go.mod h1:PuxR/8QJ7cyCkFp/aUDS+JY727OFEZkTdatxwunjIkc=\ngithub.com/yuin/goldmark v1.1.25/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.1.32/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngo.etcd.io/bbolt v1.3.3/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=\ngo.etcd.io/bbolt v1.3.4/go.mod h1:G5EMThwa9y8QZGBClrRx5EY+Yw9kAhnjy3bSjsnlVTQ=\ngo.etcd.io/etcd v0.0.0-20200513171258-e048e166ab9c/go.mod h1:xCI7ZzBfRuGgBXyXO6yfWfDmlWd35khcWpUa4L0xI/k=\ngo.mozilla.org/mozlog v0.0.0-20170222151521-4bb13139d403/go.mod h1:jHoPAGnDrCy6kaI2tAze5Prf0Nr0w/oNkROt2lw3n3o=\ngo.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU=\ngo.opencensus.io v0.22.0/go.mod h1:+kGneAE2xo2IficOXnaByMWTGM9T73dGwxeWcUqIpI8=\ngo.opencensus.io v0.22.2/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=\ngo.opencensus.io v0.22.3/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=\ngo.opencensus.io v0.22.4/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=\ngo.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.54.0 h1:r6I7RJCN86bpD/FQwedZ0vSixDpwuWREjW9oRMsmqDc=\ngo.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.54.0/go.mod h1:B9yO6b04uB80CzjedvewuqDhxJxi11s7/GtiGa8bAjI=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.54.0 h1:TT4fX+nBOA/+LUkobKGW1ydGcn+G3vRw9+g5HwCphpk=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.54.0/go.mod h1:L7UH0GbB0p47T4Rri3uHjbpCFYrVrwc1I25QhNPiGK8=\ngo.opentelemetry.io/otel v1.29.0 h1:PdomN/Al4q/lN6iBJEN3AwPvUiHPMlt93c8bqTG5Llw=\ngo.opentelemetry.io/otel v1.29.0/go.mod h1:N/WtXPs1CNCUEx+Agz5uouwCba+i+bJGFicT8SR4NP8=\ngo.opentelemetry.io/otel/metric v1.29.0 h1:vPf/HFWTNkPu1aYeIsc98l4ktOQaL6LeSoeV2g+8YLc=\ngo.opentelemetry.io/otel/metric v1.29.0/go.mod h1:auu/QWieFVWx+DmQOUMgj0F8LHWdgalxXqvp7BII/W8=\ngo.opentelemetry.io/otel/trace v1.29.0 h1:J/8ZNK4XgR7a21DZUAsbF8pZ5Jcw1VhACmnYt39JTi4=\ngo.opentelemetry.io/otel/trace v1.29.0/go.mod h1:eHl3w0sp3paPkYstJOmAimxhiFXPg+MMTlEh3nsQgWQ=\ngo.uber.org/atomic v1.3.2/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=\ngo.uber.org/atomic v1.4.0/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=\ngo.uber.org/atomic v1.5.0/go.mod h1:sABNBOSYdrvTF6hTgEIbc7YasKWGhgEQZyfxyTvoXHQ=\ngo.uber.org/multierr v1.1.0/go.mod h1:wR5kodmAFQ0UK8QlbwjlSNy0Z68gJhDJUG5sjR94q/0=\ngo.uber.org/multierr v1.3.0/go.mod h1:VgVr7evmIr6uPjLBxg28wmKNXyqE9akIJ5XnfpiKl+4=\ngo.uber.org/multierr v1.4.0/go.mod h1:VgVr7evmIr6uPjLBxg28wmKNXyqE9akIJ5XnfpiKl+4=\ngo.uber.org/tools v0.0.0-20190618225709-2cfd321de3ee/go.mod h1:vJERXedbb3MVM5f9Ejo0C68/HhF8uaILCdgjnY+goOA=\ngo.uber.org/zap v1.10.0/go.mod h1:vwi/ZaCAaUcBkycHslxD9B2zi4UTXhF60s6SWpuDF0Q=\ngo.uber.org/zap v1.13.0/go.mod h1:zwrFLgMcdUuIBviXEYEH1YKNaOBnKXsx2IPda5bBwHM=\ngolang.org/x/crypto v0.0.0-20180501155221-613d6eafa307/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20180904163835-0709b304e793/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20181203042331-505ab145d0a9/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190510104115-cbcb75029529/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190605123033-f99c8df09eb5/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20201221181555-eec23a3978ad/go.mod h1:jdWPYTVW3xRLrWPugEBEK3UY2ZEsg3UU495nc5E+M+I=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=\ngolang.org/x/exp v0.0.0-20190829153037-c13cbed26979/go.mod h1:86+5VVa7VpoJ4kLfm080zCjGlMRFzhUhsZKEZO7MGek=\ngolang.org/x/exp v0.0.0-20191030013958-a1ab85dbe136/go.mod h1:JXzH8nQsPlswgeRAPE3MuO9GYsAcnJvJ4vnMwN/5qkY=\ngolang.org/x/exp v0.0.0-20191129062945-2f5052295587/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=\ngolang.org/x/exp v0.0.0-20191227195350-da58074b4299/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=\ngolang.org/x/exp v0.0.0-20200119233911-0405dc783f0a/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=\ngolang.org/x/exp v0.0.0-20200207192155-f17229e696bd/go.mod h1:J/WKrq2StrnmMY6+EHIKF9dgMWnmCNThgcyBT1FY9mM=\ngolang.org/x/exp v0.0.0-20200224162631-6cc2880d07d6/go.mod h1:3jZMyOhIsHpP37uCMkUooju7aAi5cS1Q23tOzKc+0MU=\ngolang.org/x/exp v0.0.0-20200331195152-e8c3332aa8e5/go.mod h1:4M0jN8W1tt0AVLNr8HDosyJCDCDuyL9N9+3m7wDWgKw=\ngolang.org/x/image v0.0.0-20190227222117-0694c2d4d067/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=\ngolang.org/x/image v0.0.0-20190802002840-cff245a6509b/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/lint v0.0.0-20190301231843-5614ed5bae6f/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190409202823-959b441ac422/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190909230951-414d861bb4ac/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190930215403-16217165b5de/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20191125180803-fdd1cda4f05f/go.mod h1:5qLYkcX4OjUUV8bRuDixDT3tpyyb+LUpUlRWLxfhWrs=\ngolang.org/x/lint v0.0.0-20200130185559-910be7a94367/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/lint v0.0.0-20200302205851-738671d3881b/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/mobile v0.0.0-20190312151609-d3739f865fa6/go.mod h1:z+o9i4GpDbdi3rU15maQ/Ox0txvL9dWGYEHz965HBQE=\ngolang.org/x/mobile v0.0.0-20190719004257-d2bd2a29d028/go.mod h1:E/iHnbuqvinMTCcRqshq8CkpyQDoeVncDDYHnLhea+o=\ngolang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=\ngolang.org/x/mod v0.1.0/go.mod h1:0QHyrYULN0/3qlju5TqG8bIK38QM8yzMo5ekMj3DlcY=\ngolang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=\ngolang.org/x/mod v0.1.1-0.20191107180719-034126e5016b/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=\ngolang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.22.0 h1:D4nJWe9zXqHOmWqj4VMOJhvzj7bEZg4wEYa759z1pH4=\ngolang.org/x/mod v0.22.0/go.mod h1:6SkKJ3Xj0I0BrPOZoBy3bdMptDDU9oJrpohJ3eWZ1fY=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181220203305-927f97764cc3/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190501004415-9ce7a6920f09/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190503192946-f4e77d36d62c/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=\ngolang.org/x/net v0.0.0-20190613194153-d28f0bde5980/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190724013045-ca1201d0de80/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190813141303-74dc4d7220e7/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190923162816-aa69164e4478/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20191002035440-2ec189313ef0/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20191209160850-c0dbc17a3553/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200114155413-6afb5195e5aa/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200202094626-16171245cfb2/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200222125558-5a598a2470a0/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200301022130-244492dfa37a/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200324143707-d3edc9973b7e/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200421231249-e086a090c8fd/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200501053045-e0ff5e5a1de5/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200506145744-7e3656a0809f/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200513185701-a91f0712d120/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200520182314-0ba52f642ac2/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200625001655-4c5254603344/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20201110031124-69a78807bb2b/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20191202225959-858c2ad4c8b6/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.24.0 h1:KTBBxWqUa0ykRPLtV69rRto9TLXcqYkeswu48x/gvNE=\ngolang.org/x/oauth2 v0.24.0/go.mod h1:XYTD2NtWslqkgxebSiOHnXEap4TF09sJSc7H1sXbhtI=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190412183630-56d357773e84/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20200317015054-43a5402ce75a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20200625203802-6e8e738ad208/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181107165924-66b7b1311ac8/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181205085412-a5c9d58dba9a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190312061237-fead79001313/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190422165155-953cdadca894/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190502145724-3ef323f4f1fd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190507160741-ecd444e8653b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190606165138-5da285871e9c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190624142023-c5567b49c5d0/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190726091711-fc99dfbffb4e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190826190057-c7b8b68b1456/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190924154521-2837fb4f24fe/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191001151750-bb3f8db39f24/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191008105621-543471e840be/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191204072324-ce4227a45e2e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191228213918-04cbcbbfeed8/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200106162015-b016eb3dc98e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200113162924-86b910548bc1/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200116001909-b77594299b42/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200122134326-e047566fdf82/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200202164722-d101bd2416d5/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200212091648-12a6c2dcc1e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200302150141-5c8b2ff67527/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200331124033-c3d80250170d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200420163511-1957bb5e6d1f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200501052902-10377860bb8e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200511232937-7e40ca221e25/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200515095857-1151b9dac4a9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200523222454-059865788121/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200615200032-f1bc736245b1/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201117132131-f5c789dd3221/go.mod h1:Nr5EML6q2oocZ2LXRh80K7BxOlk5/8JxuGnuhpl+muw=\ngolang.org/x/term v0.27.0 h1:WP60Sv1nlK1T6SupCHbXzSaN0b9wUmsPoRS9b61A23Q=\ngolang.org/x/term v0.27.0/go.mod h1:iMsnZpn0cago0GOrHO2+Y7u7JPn5AylBrcoWkElMTSM=\ngolang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/time v0.0.0-20180412165947-fbb02b2291d2/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20191024005414-555d28b269f0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20200416051211-89c76fbcd5d1/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.8.0 h1:9i3RxcPv3PZnitoVGMPDKZSq1xW1gK1Xy3ArNOGZfEg=\ngolang.org/x/time v0.8.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=\ngolang.org/x/tools v0.0.0-20180221164845-07fd8470d635/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20181030221726-6c7e314b6563/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190312151545-0bb0c0a6e846/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190312170243-e65039ee4138/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190425150028-36563e24a262/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190506145303-2d16b83fe98c/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190606124116-d0a3d012864b/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190621195816-6e04913cbbac/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190628153133-6cdbf07be9d0/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190816200558-6889da9d5479/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20190911174233-4f2ddba30aff/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191010075000-0337d82405ff/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191012152004-8de300cfc20a/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191029041327-9cc4af7d6b2c/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191029190741-b9c20aec41a5/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191113191852-77e3bb0ad9e7/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191115202509-3a792d9c32b2/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191125144606-a911d9008d1f/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191130070609-6e064ea0cf2d/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191216052735-49a3e744a425/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20191216173652-a0e659d51361/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20191227053925-7b8e75db28f4/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200117161641-43d50277825c/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200122220014-bf1340f18c4a/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200204074204-1cc6d1ef6c74/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200207183749-b753a1ba74fa/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200212150539-ea181f53ac56/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200224181240-023911ca70b2/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200227222343-706bc42d1f0d/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200304193943-95d2e580d8eb/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=\ngolang.org/x/tools v0.0.0-20200312045724-11d5b4c81c7d/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=\ngolang.org/x/tools v0.0.0-20200331025713-a30bf2db82d4/go.mod h1:Sl4aGygMT6LrqrWclx+PTx3U+LnKx/seiNR+3G19Ar8=\ngolang.org/x/tools v0.0.0-20200426102838-f3a5411a4c3b/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200501065659-ab2804fb9c9d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200512131952-2bc93b1c0c88/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200515010526-7d3b6ebf133d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200626171337-aa94e735be7f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200630154851-b2d8b0336632/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200706234117-b22de6825cf7/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=\ngolang.org/x/tools v0.28.0 h1:WuB6qZ4RPCQo5aP3WdKZS7i595EdWqWR8vqJTlwTVK8=\ngolang.org/x/tools v0.28.0/go.mod h1:dcIOrVd3mfQKTgrDVQHqCPMWy6lnhfhtX3hLXYVLfRw=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/api v0.4.0/go.mod h1:8k5glujaEP+g9n7WNsDg8QP6cUVNI86fCNMcbazEtwE=\ngoogle.golang.org/api v0.7.0/go.mod h1:WtwebWUNSVBH/HAw79HIFXZNqEvBhG+Ra+ax0hx3E3M=\ngoogle.golang.org/api v0.8.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=\ngoogle.golang.org/api v0.9.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=\ngoogle.golang.org/api v0.10.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=\ngoogle.golang.org/api v0.13.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=\ngoogle.golang.org/api v0.14.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=\ngoogle.golang.org/api v0.15.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=\ngoogle.golang.org/api v0.17.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.18.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.19.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.20.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.22.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.24.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=\ngoogle.golang.org/api v0.28.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=\ngoogle.golang.org/api v0.29.0/go.mod h1:Lcubydp8VUV7KeIHD9z2Bys/sm/vGKnG1UHuDBSrHWM=\ngoogle.golang.org/api v0.214.0 h1:h2Gkq07OYi6kusGOaT/9rnNljuXmqPnaig7WGPmKbwA=\ngoogle.golang.org/api v0.214.0/go.mod h1:bYPpLG8AyeMWwDU6NXoB00xC0DFkikVvd5MfwoxjLqE=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.5.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.6.1/go.mod h1:i06prIuMbXzDqacNJfV5OdTW448YApPu5ww/cMBSeb0=\ngoogle.golang.org/appengine v1.6.2/go.mod h1:i06prIuMbXzDqacNJfV5OdTW448YApPu5ww/cMBSeb0=\ngoogle.golang.org/appengine v1.6.5/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=\ngoogle.golang.org/appengine v1.6.6/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=\ngoogle.golang.org/genproto v0.0.0-20170818010345-ee236bd376b0/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20181107211654-5fc9ac540362/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20190307195333-5fe7a883aa19/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190418145605-e7d98fc518a7/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190425155659-357c62f0e4bb/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190502173448-54afdca5d873/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190801165951-fa694d86fc64/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20190911173649-1774047e7e51/go.mod h1:IbNlFCBrqXvoKpeg0TB2l7cyZUmoaFKYIwrEpbDKLA8=\ngoogle.golang.org/genproto v0.0.0-20190927181202-20e1ac93f88c/go.mod h1:IbNlFCBrqXvoKpeg0TB2l7cyZUmoaFKYIwrEpbDKLA8=\ngoogle.golang.org/genproto v0.0.0-20191108220845-16a3f7862a1a/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20191115194625-c23dd37a84c9/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20191216164720-4f79533eabd1/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20191230161307-f3c370f40bfb/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200115191322-ca5a22157cba/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200122232147-0452cf42e150/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200204135345-fa8e72b47b90/go.mod h1:GmwEX6Z4W5gMy59cAlVYjN9JhxgbQH6Gn+gFDQe2lzA=\ngoogle.golang.org/genproto v0.0.0-20200212174721-66ed5ce911ce/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200224152610-e50cd9704f63/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200228133532-8c2c7df3a383/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200305110556-506484158171/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200312145019-da6875a35672/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200331122359-1ee6d9798940/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200423170343-7949de9c1215/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200430143042-b979b6f78d84/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200511104702-f5ebc3bea380/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200515170657-fc4c6c6a6587/go.mod h1:YsZOwe1myG/8QRHRsmBRE1LrgQY60beZKjly0O1fX9U=\ngoogle.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=\ngoogle.golang.org/genproto v0.0.0-20200626011028-ee7919e894b5/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20200707001353-8e8330bf89df/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20241118233622-e639e219e697 h1:pgr/4QbFyktUv9CtQ/Fq4gzEE6/Xs7iCXbktaGzLHbQ=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20241118233622-e639e219e697/go.mod h1:+D9ySVjN8nY8YCVjc5O7PZDIdZporIDY3KaGfJunh88=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20241209162323-e6fa225c2576 h1:8ZmaLZE4XWrtU3MyClkYqqtl6Oegr3235h7jxsDyqCY=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20241209162323-e6fa225c2576/go.mod h1:5uTbfoYQed2U9p3KIj2/Zzm02PYhndfdmML0qC3q3FU=\ngoogle.golang.org/grpc v1.8.0/go.mod h1:yo6s7OP7yaDglbqo1J04qKzAhqBH6lvTonzMVmEdcZw=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/grpc v1.20.1/go.mod h1:10oTOabMzJvdu6/UiuZezV6QK5dSlG84ov/aaiqXj38=\ngoogle.golang.org/grpc v1.21.1/go.mod h1:oYelfM1adQP15Ek0mdvEgi9Df8B9CZIaU1084ijfRaM=\ngoogle.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=\ngoogle.golang.org/grpc v1.23.1/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=\ngoogle.golang.org/grpc v1.24.0/go.mod h1:XDChyiUovWa60DnaeDeZmSW86xtLtjtZbwvSiRnRtcA=\ngoogle.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=\ngoogle.golang.org/grpc v1.26.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=\ngoogle.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=\ngoogle.golang.org/grpc v1.27.1/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=\ngoogle.golang.org/grpc v1.28.0/go.mod h1:rpkK4SK4GF4Ach/+MFLZUBavHOvF2JJB5uozKKal+60=\ngoogle.golang.org/grpc v1.29.0/go.mod h1:itym6AZVZYACWQqET3MqgPpjcuV5QH3BxFS3IjizoKk=\ngoogle.golang.org/grpc v1.29.1/go.mod h1:itym6AZVZYACWQqET3MqgPpjcuV5QH3BxFS3IjizoKk=\ngoogle.golang.org/grpc v1.67.1 h1:zWnc1Vrcno+lHZCOofnIMvycFcc0QRGIzm9dhnDX68E=\ngoogle.golang.org/grpc v1.67.1/go.mod h1:1gLDyUQU7CTLJI90u3nXZ9ekeghjeM7pTDZlqFNg2AA=\ngoogle.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=\ngoogle.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=\ngoogle.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=\ngoogle.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=\ngoogle.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=\ngoogle.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.24.0/go.mod h1:r/3tXBNzIEhYS9I1OUVjXDlt8tc493IdKGjtUeSXeh4=\ngoogle.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=\ngoogle.golang.org/protobuf v1.36.1 h1:yBPeRvTftaleIgM3PZ/WBIZ7XM/eEYAaEyCwvyjq/gk=\ngoogle.golang.org/protobuf v1.36.1/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=\ngopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/cheggaaa/pb.v1 v1.0.25/go.mod h1:V/YB90LKu/1FcN3WVnfiiE5oMCibMjukxqG/qStrOgw=\ngopkg.in/cheggaaa/pb.v1 v1.0.28/go.mod h1:V/YB90LKu/1FcN3WVnfiiE5oMCibMjukxqG/qStrOgw=\ngopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=\ngopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=\ngopkg.in/gcfg.v1 v1.2.3/go.mod h1:yesOnuUOFQAhST5vPY4nbZsb/huCgGGXlipJsBn0b3o=\ngopkg.in/resty.v1 v1.12.0/go.mod h1:mDo4pnntr5jdWRML875a/NmxYqAlA73dVijT2AXvQQo=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=\ngopkg.in/warnings.v0 v0.1.2/go.mod h1:jksf8JmL6Qr/oQM2OXTHunEvvTAsrWBLb6OOjuVWRNI=\ngopkg.in/yaml.v2 v2.0.0-20170812160011-eb3733d160e7/go.mod h1:JAlM8MvJe8wmxCU4Bli9HhUf9+ttbYbLASfIpnQbh74=\ngopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.3/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.5/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.6/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190418001031-e561f6794a2a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.1-2019.2.3/go.mod h1:a3bituU0lyd329TUQxRnasdCoJDkEUEAqEt0JzvZhAg=\nhonnef.co/go/tools v0.0.1-2020.1.3/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=\nhonnef.co/go/tools v0.0.1-2020.1.4/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=\nrsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8=\nrsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=\nrsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=\nsigs.k8s.io/yaml v1.1.0/go.mod h1:UJmg0vDUVViEyp3mgSv9WPwZCDxu4rQW1olrI1uml+o=\n"
        },
        {
          "name": "gosec_suite_test.go",
          "type": "blob",
          "size": 0.1865234375,
          "content": "package gosec_test\n\nimport (\n\t\"testing\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n)\n\nfunc TestGosec(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"gosec Suite\")\n}\n"
        },
        {
          "name": "helpers.go",
          "type": "blob",
          "size": 15.65234375,
          "content": "// (c) Copyright 2016 Hewlett Packard Enterprise Development LP\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gosec\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/token\"\n\t\"go/types\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/user\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// envGoModVersion overrides the Go version detection.\nconst envGoModVersion = \"GOSECGOVERSION\"\n\n// MatchCallByPackage ensures that the specified package is imported,\n// adjusts the name for any aliases and ignores cases that are\n// initialization only imports.\n//\n// Usage:\n//\n//\tnode, matched := MatchCallByPackage(n, ctx, \"math/rand\", \"Read\")\nfunc MatchCallByPackage(n ast.Node, c *Context, pkg string, names ...string) (*ast.CallExpr, bool) {\n\timportedNames, found := GetImportedNames(pkg, c)\n\tif !found {\n\t\treturn nil, false\n\t}\n\n\tif callExpr, ok := n.(*ast.CallExpr); ok {\n\t\tpackageName, callName, err := GetCallInfo(callExpr, c)\n\t\tif err != nil {\n\t\t\treturn nil, false\n\t\t}\n\t\tfor _, in := range importedNames {\n\t\t\tif packageName != in {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, name := range names {\n\t\t\t\tif callName == name {\n\t\t\t\t\treturn callExpr, true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil, false\n}\n\n// MatchCompLit will match an ast.CompositeLit based on the supplied type\nfunc MatchCompLit(n ast.Node, ctx *Context, required string) *ast.CompositeLit {\n\tif complit, ok := n.(*ast.CompositeLit); ok {\n\t\ttypeOf := ctx.Info.TypeOf(complit)\n\t\tif typeOf.String() == required {\n\t\t\treturn complit\n\t\t}\n\t}\n\treturn nil\n}\n\n// GetInt will read and return an integer value from an ast.BasicLit\nfunc GetInt(n ast.Node) (int64, error) {\n\tif node, ok := n.(*ast.BasicLit); ok && node.Kind == token.INT {\n\t\treturn strconv.ParseInt(node.Value, 0, 64)\n\t}\n\treturn 0, fmt.Errorf(\"Unexpected AST node type: %T\", n)\n}\n\n// GetFloat will read and return a float value from an ast.BasicLit\nfunc GetFloat(n ast.Node) (float64, error) {\n\tif node, ok := n.(*ast.BasicLit); ok && node.Kind == token.FLOAT {\n\t\treturn strconv.ParseFloat(node.Value, 64)\n\t}\n\treturn 0.0, fmt.Errorf(\"Unexpected AST node type: %T\", n)\n}\n\n// GetChar will read and return a char value from an ast.BasicLit\nfunc GetChar(n ast.Node) (byte, error) {\n\tif node, ok := n.(*ast.BasicLit); ok && node.Kind == token.CHAR {\n\t\treturn node.Value[0], nil\n\t}\n\treturn 0, fmt.Errorf(\"Unexpected AST node type: %T\", n)\n}\n\n// GetStringRecursive will recursively walk down a tree of *ast.BinaryExpr. It will then concat the results, and return.\n// Unlike the other getters, it does _not_ raise an error for unknown ast.Node types. At the base, the recursion will hit a non-BinaryExpr type,\n// either BasicLit or other, so it's not an error case. It will only error if `strconv.Unquote` errors. This matters, because there's\n// currently functionality that relies on error values being returned by GetString if and when it hits a non-basiclit string node type,\n// hence for cases where recursion is needed, we use this separate function, so that we can still be backwards compatible.\n//\n// This was added to handle a SQL injection concatenation case where the injected value is infixed between two strings, not at the start or end. See example below\n//\n// Do note that this will omit non-string values. So for example, if you were to use this node:\n// ```go\n// q := \"SELECT * FROM foo WHERE name = '\" + os.Args[0] + \"' AND 1=1\" // will result in \"SELECT * FROM foo WHERE ” AND 1=1\"\n\nfunc GetStringRecursive(n ast.Node) (string, error) {\n\tif node, ok := n.(*ast.BasicLit); ok && node.Kind == token.STRING {\n\t\treturn strconv.Unquote(node.Value)\n\t}\n\n\tif expr, ok := n.(*ast.BinaryExpr); ok {\n\t\tx, err := GetStringRecursive(expr.X)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\ty, err := GetStringRecursive(expr.Y)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\treturn x + y, nil\n\t}\n\n\treturn \"\", nil\n}\n\n// GetString will read and return a string value from an ast.BasicLit\nfunc GetString(n ast.Node) (string, error) {\n\tif node, ok := n.(*ast.BasicLit); ok && node.Kind == token.STRING {\n\t\treturn strconv.Unquote(node.Value)\n\t}\n\n\treturn \"\", fmt.Errorf(\"Unexpected AST node type: %T\", n)\n}\n\n// GetCallObject returns the object and call expression and associated\n// object for a given AST node. nil, nil will be returned if the\n// object cannot be resolved.\nfunc GetCallObject(n ast.Node, ctx *Context) (*ast.CallExpr, types.Object) {\n\tswitch node := n.(type) {\n\tcase *ast.CallExpr:\n\t\tswitch fn := node.Fun.(type) {\n\t\tcase *ast.Ident:\n\t\t\treturn node, ctx.Info.Uses[fn]\n\t\tcase *ast.SelectorExpr:\n\t\t\treturn node, ctx.Info.Uses[fn.Sel]\n\t\t}\n\t}\n\treturn nil, nil\n}\n\n// GetCallInfo returns the package or type and name  associated with a\n// call expression.\nfunc GetCallInfo(n ast.Node, ctx *Context) (string, string, error) {\n\tswitch node := n.(type) {\n\tcase *ast.CallExpr:\n\t\tswitch fn := node.Fun.(type) {\n\t\tcase *ast.SelectorExpr:\n\t\t\tswitch expr := fn.X.(type) {\n\t\t\tcase *ast.Ident:\n\t\t\t\tif expr.Obj != nil && expr.Obj.Kind == ast.Var {\n\t\t\t\t\tt := ctx.Info.TypeOf(expr)\n\t\t\t\t\tif t != nil {\n\t\t\t\t\t\treturn t.String(), fn.Sel.Name, nil\n\t\t\t\t\t}\n\t\t\t\t\treturn \"undefined\", fn.Sel.Name, fmt.Errorf(\"missing type info\")\n\t\t\t\t}\n\t\t\t\treturn expr.Name, fn.Sel.Name, nil\n\t\t\tcase *ast.SelectorExpr:\n\t\t\t\tif expr.Sel != nil {\n\t\t\t\t\tt := ctx.Info.TypeOf(expr.Sel)\n\t\t\t\t\tif t != nil {\n\t\t\t\t\t\treturn t.String(), fn.Sel.Name, nil\n\t\t\t\t\t}\n\t\t\t\t\treturn \"undefined\", fn.Sel.Name, fmt.Errorf(\"missing type info\")\n\t\t\t\t}\n\t\t\tcase *ast.CallExpr:\n\t\t\t\tswitch call := expr.Fun.(type) {\n\t\t\t\tcase *ast.Ident:\n\t\t\t\t\tif call.Name == \"new\" && len(expr.Args) > 0 {\n\t\t\t\t\t\tt := ctx.Info.TypeOf(expr.Args[0])\n\t\t\t\t\t\tif t != nil {\n\t\t\t\t\t\t\treturn t.String(), fn.Sel.Name, nil\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn \"undefined\", fn.Sel.Name, fmt.Errorf(\"missing type info\")\n\t\t\t\t\t}\n\t\t\t\t\tif call.Obj != nil {\n\t\t\t\t\t\tswitch decl := call.Obj.Decl.(type) {\n\t\t\t\t\t\tcase *ast.FuncDecl:\n\t\t\t\t\t\t\tret := decl.Type.Results\n\t\t\t\t\t\t\tif ret != nil && len(ret.List) > 0 {\n\t\t\t\t\t\t\t\tret1 := ret.List[0]\n\t\t\t\t\t\t\t\tif ret1 != nil {\n\t\t\t\t\t\t\t\t\tt := ctx.Info.TypeOf(ret1.Type)\n\t\t\t\t\t\t\t\t\tif t != nil {\n\t\t\t\t\t\t\t\t\t\treturn t.String(), fn.Sel.Name, nil\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn \"undefined\", fn.Sel.Name, fmt.Errorf(\"missing type info\")\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcase *ast.Ident:\n\t\t\treturn ctx.Pkg.Name(), fn.Name, nil\n\t\t}\n\t}\n\n\treturn \"\", \"\", fmt.Errorf(\"unable to determine call info\")\n}\n\n// GetCallStringArgsValues returns the values of strings arguments if they can be resolved\nfunc GetCallStringArgsValues(n ast.Node, _ *Context) []string {\n\tvalues := []string{}\n\tswitch node := n.(type) {\n\tcase *ast.CallExpr:\n\t\tfor _, arg := range node.Args {\n\t\t\tswitch param := arg.(type) {\n\t\t\tcase *ast.BasicLit:\n\t\t\t\tvalue, err := GetString(param)\n\t\t\t\tif err == nil {\n\t\t\t\t\tvalues = append(values, value)\n\t\t\t\t}\n\t\t\tcase *ast.Ident:\n\t\t\t\tvalues = append(values, GetIdentStringValues(param)...)\n\t\t\t}\n\t\t}\n\t}\n\treturn values\n}\n\nfunc getIdentStringValues(ident *ast.Ident, stringFinder func(ast.Node) (string, error)) []string {\n\tvalues := []string{}\n\tobj := ident.Obj\n\tif obj != nil {\n\t\tswitch decl := obj.Decl.(type) {\n\t\tcase *ast.ValueSpec:\n\t\t\tfor _, v := range decl.Values {\n\t\t\t\tvalue, err := stringFinder(v)\n\t\t\t\tif err == nil {\n\t\t\t\t\tvalues = append(values, value)\n\t\t\t\t}\n\t\t\t}\n\t\tcase *ast.AssignStmt:\n\t\t\tfor _, v := range decl.Rhs {\n\t\t\t\tvalue, err := stringFinder(v)\n\t\t\t\tif err == nil {\n\t\t\t\t\tvalues = append(values, value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn values\n}\n\n// GetIdentStringValuesRecursive returns the string of values of an Ident if they can be resolved\n// The difference between this and GetIdentStringValues is that it will attempt to resolve the strings recursively,\n// if it is passed a *ast.BinaryExpr. See GetStringRecursive for details\nfunc GetIdentStringValuesRecursive(ident *ast.Ident) []string {\n\treturn getIdentStringValues(ident, GetStringRecursive)\n}\n\n// GetIdentStringValues return the string values of an Ident if they can be resolved\nfunc GetIdentStringValues(ident *ast.Ident) []string {\n\treturn getIdentStringValues(ident, GetString)\n}\n\n// GetBinaryExprOperands returns all operands of a binary expression by traversing\n// the expression tree\nfunc GetBinaryExprOperands(be *ast.BinaryExpr) []ast.Node {\n\tvar traverse func(be *ast.BinaryExpr)\n\tresult := []ast.Node{}\n\ttraverse = func(be *ast.BinaryExpr) {\n\t\tif lhs, ok := be.X.(*ast.BinaryExpr); ok {\n\t\t\ttraverse(lhs)\n\t\t} else {\n\t\t\tresult = append(result, be.X)\n\t\t}\n\t\tif rhs, ok := be.Y.(*ast.BinaryExpr); ok {\n\t\t\ttraverse(rhs)\n\t\t} else {\n\t\t\tresult = append(result, be.Y)\n\t\t}\n\t}\n\ttraverse(be)\n\treturn result\n}\n\n// GetImportedNames returns the name(s)/alias(es) used for the package within\n// the code. It ignores initialization-only imports.\nfunc GetImportedNames(path string, ctx *Context) (names []string, found bool) {\n\timportNames, imported := ctx.Imports.Imported[path]\n\treturn importNames, imported\n}\n\n// GetImportPath resolves the full import path of an identifier based on\n// the imports in the current context(including aliases).\nfunc GetImportPath(name string, ctx *Context) (string, bool) {\n\tfor path := range ctx.Imports.Imported {\n\t\tif imported, ok := GetImportedNames(path, ctx); ok {\n\t\t\tfor _, n := range imported {\n\t\t\t\tif n == name {\n\t\t\t\t\treturn path, true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", false\n}\n\n// GetLocation returns the filename and line number of an ast.Node\nfunc GetLocation(n ast.Node, ctx *Context) (string, int) {\n\tfobj := ctx.FileSet.File(n.Pos())\n\treturn fobj.Name(), fobj.Line(n.Pos())\n}\n\n// Gopath returns all GOPATHs\nfunc Gopath() []string {\n\tdefaultGoPath := runtime.GOROOT()\n\tif u, err := user.Current(); err == nil {\n\t\tdefaultGoPath = filepath.Join(u.HomeDir, \"go\")\n\t}\n\tpath := Getenv(\"GOPATH\", defaultGoPath)\n\tpaths := strings.Split(path, string(os.PathListSeparator))\n\tfor idx, path := range paths {\n\t\tif abs, err := filepath.Abs(path); err == nil {\n\t\t\tpaths[idx] = abs\n\t\t}\n\t}\n\treturn paths\n}\n\n// Getenv returns the values of the environment variable, otherwise\n// returns the default if variable is not set\nfunc Getenv(key, userDefault string) string {\n\tif val := os.Getenv(key); val != \"\" {\n\t\treturn val\n\t}\n\treturn userDefault\n}\n\n// GetPkgRelativePath returns the Go relative path derived\n// form the given path\nfunc GetPkgRelativePath(path string) (string, error) {\n\tabspath, err := filepath.Abs(path)\n\tif err != nil {\n\t\tabspath = path\n\t}\n\tif strings.HasSuffix(abspath, \".go\") {\n\t\tabspath = filepath.Dir(abspath)\n\t}\n\tfor _, base := range Gopath() {\n\t\tprojectRoot := filepath.FromSlash(fmt.Sprintf(\"%s/src/\", base))\n\t\tif strings.HasPrefix(abspath, projectRoot) {\n\t\t\treturn strings.TrimPrefix(abspath, projectRoot), nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no project relative path found\")\n}\n\n// GetPkgAbsPath returns the Go package absolute path derived from\n// the given path\nfunc GetPkgAbsPath(pkgPath string) (string, error) {\n\tabsPath, err := filepath.Abs(pkgPath)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif _, err := os.Stat(absPath); os.IsNotExist(err) {\n\t\treturn \"\", errors.New(\"no project absolute path found\")\n\t}\n\treturn absPath, nil\n}\n\n// ConcatString recursively concatenates strings from a binary expression\nfunc ConcatString(n *ast.BinaryExpr) (string, bool) {\n\tvar s string\n\t// sub expressions are found in X object, Y object is always last BasicLit\n\tif rightOperand, ok := n.Y.(*ast.BasicLit); ok {\n\t\tif str, err := GetString(rightOperand); err == nil {\n\t\t\ts = str + s\n\t\t}\n\t} else {\n\t\treturn \"\", false\n\t}\n\tif leftOperand, ok := n.X.(*ast.BinaryExpr); ok {\n\t\tif recursion, ok := ConcatString(leftOperand); ok {\n\t\t\ts = recursion + s\n\t\t}\n\t} else if leftOperand, ok := n.X.(*ast.BasicLit); ok {\n\t\tif str, err := GetString(leftOperand); err == nil {\n\t\t\ts = str + s\n\t\t}\n\t} else {\n\t\treturn \"\", false\n\t}\n\treturn s, true\n}\n\n// FindVarIdentities returns array of all variable identities in a given binary expression\nfunc FindVarIdentities(n *ast.BinaryExpr, c *Context) ([]*ast.Ident, bool) {\n\tidentities := []*ast.Ident{}\n\t// sub expressions are found in X object, Y object is always the last term\n\tif rightOperand, ok := n.Y.(*ast.Ident); ok {\n\t\tobj := c.Info.ObjectOf(rightOperand)\n\t\tif _, ok := obj.(*types.Var); ok && !TryResolve(rightOperand, c) {\n\t\t\tidentities = append(identities, rightOperand)\n\t\t}\n\t}\n\tif leftOperand, ok := n.X.(*ast.BinaryExpr); ok {\n\t\tif leftIdentities, ok := FindVarIdentities(leftOperand, c); ok {\n\t\t\tidentities = append(identities, leftIdentities...)\n\t\t}\n\t} else {\n\t\tif leftOperand, ok := n.X.(*ast.Ident); ok {\n\t\t\tobj := c.Info.ObjectOf(leftOperand)\n\t\t\tif _, ok := obj.(*types.Var); ok && !TryResolve(leftOperand, c) {\n\t\t\t\tidentities = append(identities, leftOperand)\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(identities) > 0 {\n\t\treturn identities, true\n\t}\n\t// if nil or error, return false\n\treturn nil, false\n}\n\n// PackagePaths returns a slice with all packages path at given root directory\nfunc PackagePaths(root string, excludes []*regexp.Regexp) ([]string, error) {\n\tif strings.HasSuffix(root, \"...\") {\n\t\troot = root[0 : len(root)-3]\n\t} else {\n\t\treturn []string{root}, nil\n\t}\n\tpaths := map[string]bool{}\n\terr := filepath.Walk(root, func(path string, f os.FileInfo, err error) error {\n\t\tif filepath.Ext(path) == \".go\" {\n\t\t\tpath = filepath.Dir(path)\n\t\t\tif isExcluded(filepath.ToSlash(path), excludes) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tpaths[path] = true\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn []string{}, err\n\t}\n\n\tresult := []string{}\n\tfor path := range paths {\n\t\tresult = append(result, path)\n\t}\n\treturn result, nil\n}\n\n// isExcluded checks if a string matches any of the exclusion regexps\nfunc isExcluded(str string, excludes []*regexp.Regexp) bool {\n\tif excludes == nil {\n\t\treturn false\n\t}\n\tfor _, exclude := range excludes {\n\t\tif exclude != nil && exclude.MatchString(str) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// ExcludedDirsRegExp builds the regexps for a list of excluded dirs provided as strings\nfunc ExcludedDirsRegExp(excludedDirs []string) []*regexp.Regexp {\n\tvar exps []*regexp.Regexp\n\tfor _, excludedDir := range excludedDirs {\n\t\tstr := fmt.Sprintf(`([\\\\/])?%s([\\\\/])?`, strings.ReplaceAll(filepath.ToSlash(excludedDir), \"/\", `\\/`))\n\t\tr := regexp.MustCompile(str)\n\t\texps = append(exps, r)\n\t}\n\treturn exps\n}\n\n// RootPath returns the absolute root path of a scan\nfunc RootPath(root string) (string, error) {\n\troot = strings.TrimSuffix(root, \"...\")\n\treturn filepath.Abs(root)\n}\n\n// GoVersion returns parsed version of Go mod version and fallback to runtime version if not found.\nfunc GoVersion() (int, int, int) {\n\tif env, ok := os.LookupEnv(envGoModVersion); ok {\n\t\treturn parseGoVersion(strings.TrimPrefix(env, \"go\"))\n\t}\n\n\tgoVersion, err := goModVersion()\n\tif err != nil {\n\t\treturn parseGoVersion(strings.TrimPrefix(runtime.Version(), \"go\"))\n\t}\n\n\treturn parseGoVersion(goVersion)\n}\n\ntype goListOutput struct {\n\tGoVersion string `json:\"GoVersion\"`\n}\n\nfunc goModVersion() (string, error) {\n\tcmd := exec.Command(\"go\", \"list\", \"-m\", \"-json\")\n\n\traw, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"command go list: %w: %s\", err, string(raw))\n\t}\n\n\tvar v goListOutput\n\terr = json.NewDecoder(bytes.NewBuffer(raw)).Decode(&v)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"unmarshaling error: %w: %s\", err, string(raw))\n\t}\n\n\treturn v.GoVersion, nil\n}\n\n// parseGoVersion parses Go version.\n// example:\n// - 1.19rc2\n// - 1.19beta2\n// - 1.19.4\n// - 1.19\nfunc parseGoVersion(version string) (int, int, int) {\n\texp := regexp.MustCompile(`(\\d+).(\\d+)(?:.(\\d+))?.*`)\n\tparts := exp.FindStringSubmatch(version)\n\tif len(parts) <= 1 {\n\t\treturn 0, 0, 0\n\t}\n\n\tmajor, _ := strconv.Atoi(parts[1])\n\tminor, _ := strconv.Atoi(parts[2])\n\tbuild, _ := strconv.Atoi(parts[3])\n\n\treturn major, minor, build\n}\n"
        },
        {
          "name": "helpers_test.go",
          "type": "blob",
          "size": 9.0576171875,
          "content": "package gosec_test\n\nimport (\n\t\"go/ast\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"github.com/securego/gosec/v2\"\n\t\"github.com/securego/gosec/v2/testutils\"\n)\n\nvar _ = Describe(\"Helpers\", func() {\n\tContext(\"when listing package paths\", func() {\n\t\tvar dir string\n\t\tJustBeforeEach(func() {\n\t\t\tdir = GinkgoT().TempDir()\n\t\t\t_, err := os.MkdirTemp(dir, \"test*.go\")\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t})\n\t\tIt(\"should return the root directory as package path\", func() {\n\t\t\tpaths, err := gosec.PackagePaths(dir, nil)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tExpect(paths).Should(Equal([]string{dir}))\n\t\t})\n\t\tIt(\"should return the package path\", func() {\n\t\t\tpaths, err := gosec.PackagePaths(dir+\"/...\", nil)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tExpect(paths).Should(Equal([]string{dir}))\n\t\t})\n\t\tIt(\"should exclude folder\", func() {\n\t\t\tnested := dir + \"/vendor\"\n\t\t\terr := os.Mkdir(nested, 0o755)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\t_, err = os.Create(nested + \"/test.go\")\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\texclude, err := regexp.Compile(`([\\\\/])?vendor([\\\\/])?`)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tpaths, err := gosec.PackagePaths(dir+\"/...\", []*regexp.Regexp{exclude})\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tExpect(paths).Should(Equal([]string{dir}))\n\t\t})\n\t\tIt(\"should exclude folder with subpath\", func() {\n\t\t\tnested := dir + \"/pkg/generated\"\n\t\t\terr := os.MkdirAll(nested, 0o755)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\t_, err = os.Create(nested + \"/test.go\")\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\texclude, err := regexp.Compile(`([\\\\/])?/pkg\\/generated([\\\\/])?`)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tpaths, err := gosec.PackagePaths(dir+\"/...\", []*regexp.Regexp{exclude})\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tExpect(paths).Should(Equal([]string{dir}))\n\t\t})\n\t\tIt(\"should be empty when folder does not exist\", func() {\n\t\t\tnested := dir + \"/test\"\n\t\t\tpaths, err := gosec.PackagePaths(nested+\"/...\", nil)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tExpect(paths).Should(BeEmpty())\n\t\t})\n\t})\n\n\tContext(\"when getting the root path\", func() {\n\t\tIt(\"should return the absolute path from relative path\", func() {\n\t\t\tbase := \"test\"\n\t\t\tcwd, err := os.Getwd()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\troot, err := gosec.RootPath(base)\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tExpect(root).Should(Equal(filepath.Join(cwd, base)))\n\t\t})\n\t\tIt(\"should return the absolute path from ellipsis path\", func() {\n\t\t\tbase := \"test\"\n\t\t\tcwd, err := os.Getwd()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\troot, err := gosec.RootPath(filepath.Join(base, \"...\"))\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tExpect(root).Should(Equal(filepath.Join(cwd, base)))\n\t\t})\n\t})\n\n\tContext(\"when excluding the dirs\", func() {\n\t\tIt(\"should create a proper regexp\", func() {\n\t\t\tr := gosec.ExcludedDirsRegExp([]string{\"test\"})\n\t\t\tExpect(r).Should(HaveLen(1))\n\t\t\tmatch := r[0].MatchString(\"/home/go/src/project/test/pkg\")\n\t\t\tExpect(match).Should(BeTrue())\n\t\t\tmatch = r[0].MatchString(\"/home/go/src/project/vendor/pkg\")\n\t\t\tExpect(match).Should(BeFalse())\n\t\t})\n\n\t\tIt(\"should create a proper regexp for dir with subdir\", func() {\n\t\t\tr := gosec.ExcludedDirsRegExp([]string{`test/generated`})\n\t\t\tExpect(r).Should(HaveLen(1))\n\t\t\tmatch := r[0].MatchString(\"/home/go/src/project/test/generated\")\n\t\t\tExpect(match).Should(BeTrue())\n\t\t\tmatch = r[0].MatchString(\"/home/go/src/project/test/pkg\")\n\t\t\tExpect(match).Should(BeFalse())\n\t\t\tmatch = r[0].MatchString(\"/home/go/src/project/vendor/pkg\")\n\t\t\tExpect(match).Should(BeFalse())\n\t\t})\n\n\t\tIt(\"should create no regexp when dir list is empty\", func() {\n\t\t\tr := gosec.ExcludedDirsRegExp(nil)\n\t\t\tExpect(r).Should(BeEmpty())\n\t\t\tr = gosec.ExcludedDirsRegExp([]string{})\n\t\t\tExpect(r).Should(BeEmpty())\n\t\t})\n\t})\n\n\tContext(\"when getting call info\", func() {\n\t\tIt(\"should return the type and call name for selector expression\", func() {\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"main.go\", `\n\t\t\tpackage main\n\n\t\t\timport(\n\t\t\t    \"bytes\"\n\t\t\t)\n\n\t\t\tfunc main() {\n\t\t\t    b := new(bytes.Buffer)\n\t\t\t\t_, err := b.WriteString(\"test\")\n\t\t\t\tif err != nil {\n\t\t\t\t    panic(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\t`)\n\t\t\tctx := pkg.CreateContext(\"main.go\")\n\t\t\tresult := map[string]string{}\n\t\t\tvisitor := testutils.NewMockVisitor()\n\t\t\tvisitor.Context = ctx\n\t\t\tvisitor.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\ttypeName, call, err := gosec.GetCallInfo(n, ctx)\n\t\t\t\tif err == nil {\n\t\t\t\t\tresult[typeName] = call\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tast.Walk(visitor, ctx.Root)\n\n\t\t\tExpect(result).Should(HaveKeyWithValue(\"*bytes.Buffer\", \"WriteString\"))\n\t\t})\n\n\t\tIt(\"should return the type and call name for new selector expression\", func() {\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"main.go\", `\n\t\t\tpackage main\n\n\t\t\timport(\n\t\t\t    \"bytes\"\n\t\t\t)\n\n\t\t\tfunc main() {\n\t\t\t\t_, err := new(bytes.Buffer).WriteString(\"test\")\n\t\t\t\tif err != nil {\n\t\t\t\t    panic(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\t`)\n\t\t\tctx := pkg.CreateContext(\"main.go\")\n\t\t\tresult := map[string]string{}\n\t\t\tvisitor := testutils.NewMockVisitor()\n\t\t\tvisitor.Context = ctx\n\t\t\tvisitor.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\ttypeName, call, err := gosec.GetCallInfo(n, ctx)\n\t\t\t\tif err == nil {\n\t\t\t\t\tresult[typeName] = call\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tast.Walk(visitor, ctx.Root)\n\n\t\t\tExpect(result).Should(HaveKeyWithValue(\"bytes.Buffer\", \"WriteString\"))\n\t\t})\n\n\t\tIt(\"should return the type and call name for function selector expression\", func() {\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"main.go\", `\n\t\t\tpackage main\n\n\t\t\timport(\n\t\t\t    \"bytes\"\n\t\t\t)\n\n\t\t\tfunc createBuffer() *bytes.Buffer {\n\t\t\t    return new(bytes.Buffer)\n\t\t\t}\n\n\t\t\tfunc main() {\n\t\t\t\t_, err := createBuffer().WriteString(\"test\")\n\t\t\t\tif err != nil {\n\t\t\t\t    panic(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\t`)\n\t\t\tctx := pkg.CreateContext(\"main.go\")\n\t\t\tresult := map[string]string{}\n\t\t\tvisitor := testutils.NewMockVisitor()\n\t\t\tvisitor.Context = ctx\n\t\t\tvisitor.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\ttypeName, call, err := gosec.GetCallInfo(n, ctx)\n\t\t\t\tif err == nil {\n\t\t\t\t\tresult[typeName] = call\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tast.Walk(visitor, ctx.Root)\n\n\t\t\tExpect(result).Should(HaveKeyWithValue(\"*bytes.Buffer\", \"WriteString\"))\n\t\t})\n\n\t\tIt(\"should return the type and call name for package function\", func() {\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"main.go\", `\n\t\t\tpackage main\n\n\t\t\timport(\n\t\t\t    \"fmt\"\n\t\t\t)\n\n\t\t\tfunc main() {\n\t\t\t    fmt.Println(\"test\")\n\t\t\t}\n\t\t\t`)\n\t\t\tctx := pkg.CreateContext(\"main.go\")\n\t\t\tresult := map[string]string{}\n\t\t\tvisitor := testutils.NewMockVisitor()\n\t\t\tvisitor.Context = ctx\n\t\t\tvisitor.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\ttypeName, call, err := gosec.GetCallInfo(n, ctx)\n\t\t\t\tif err == nil {\n\t\t\t\t\tresult[typeName] = call\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tast.Walk(visitor, ctx.Root)\n\n\t\t\tExpect(result).Should(HaveKeyWithValue(\"fmt\", \"Println\"))\n\t\t})\n\n\t\tIt(\"should return the type and call name when built-in new function is overridden\", func() {\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"main.go\", `\n      package main\n\n      type S struct{ F int }\n\n      func (f S) Fun() {}\n\n      func new() S { return S{} }\n\n      func main() {\n\t      new().Fun()\n      }\n\t\t\t`)\n\t\t\tctx := pkg.CreateContext(\"main.go\")\n\t\t\tresult := map[string]string{}\n\t\t\tvisitor := testutils.NewMockVisitor()\n\t\t\tvisitor.Context = ctx\n\t\t\tvisitor.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\ttypeName, call, err := gosec.GetCallInfo(n, ctx)\n\t\t\t\tif err == nil {\n\t\t\t\t\tresult[typeName] = call\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tast.Walk(visitor, ctx.Root)\n\n\t\t\tExpect(result).Should(HaveKeyWithValue(\"main\", \"new\"))\n\t\t})\n\t})\n\tContext(\"when getting binary expression operands\", func() {\n\t\tIt(\"should return all operands of a binary expression\", func() {\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"main.go\", `\n\t\t\tpackage main\n\n\t\t\timport(\n\t\t\t    \"fmt\"\n\t\t\t)\n\n\t\t\tfunc main() {\n\t\t\t\tbe := \"test1\" + \"test2\"\n\t\t\t\tfmt.Println(be)\n\t\t\t}\n\t\t\t`)\n\t\t\tctx := pkg.CreateContext(\"main.go\")\n\t\t\tvar be *ast.BinaryExpr\n\t\t\tvisitor := testutils.NewMockVisitor()\n\t\t\tvisitor.Context = ctx\n\t\t\tvisitor.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\tif expr, ok := n.(*ast.BinaryExpr); ok {\n\t\t\t\t\tbe = expr\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tast.Walk(visitor, ctx.Root)\n\n\t\t\toperands := gosec.GetBinaryExprOperands(be)\n\t\t\tExpect(operands).Should(HaveLen(2))\n\t\t})\n\t\tIt(\"should return all operands of complex binary expression\", func() {\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"main.go\", `\n\t\t\tpackage main\n\n\t\t\timport(\n\t\t\t    \"fmt\"\n\t\t\t)\n\n\t\t\tfunc main() {\n\t\t\t\tbe := \"test1\" + \"test2\" + \"test3\" + \"test4\"\n\t\t\t\tfmt.Println(be)\n\t\t\t}\n\t\t\t`)\n\t\t\tctx := pkg.CreateContext(\"main.go\")\n\t\t\tvar be *ast.BinaryExpr\n\t\t\tvisitor := testutils.NewMockVisitor()\n\t\t\tvisitor.Context = ctx\n\t\t\tvisitor.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\tif expr, ok := n.(*ast.BinaryExpr); ok {\n\t\t\t\t\tif be == nil {\n\t\t\t\t\t\tbe = expr\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tast.Walk(visitor, ctx.Root)\n\n\t\t\toperands := gosec.GetBinaryExprOperands(be)\n\t\t\tExpect(operands).Should(HaveLen(4))\n\t\t})\n\t})\n})\n"
        },
        {
          "name": "import_tracker.go",
          "type": "blob",
          "size": 2.36328125,
          "content": "// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gosec\n\nimport (\n\t\"go/ast\"\n\t\"go/types\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar versioningPackagePattern = regexp.MustCompile(`v[0-9]+$`)\n\n// ImportTracker is used to normalize the packages that have been imported\n// by a source file. It is able to differentiate between plain imports, aliased\n// imports and init only imports.\ntype ImportTracker struct {\n\t// Imported is a map of Imported with their associated names/aliases.\n\tImported map[string][]string\n}\n\n// NewImportTracker creates an empty Import tracker instance\nfunc NewImportTracker() *ImportTracker {\n\treturn &ImportTracker{\n\t\tImported: make(map[string][]string),\n\t}\n}\n\n// TrackFile track all the imports used by the supplied file\nfunc (t *ImportTracker) TrackFile(file *ast.File) {\n\tfor _, imp := range file.Imports {\n\t\tt.TrackImport(imp)\n\t}\n}\n\n// TrackPackages tracks all the imports used by the supplied packages\nfunc (t *ImportTracker) TrackPackages(pkgs ...*types.Package) {\n\tfor _, pkg := range pkgs {\n\t\tt.Imported[pkg.Path()] = []string{pkg.Name()}\n\t}\n}\n\n// TrackImport tracks imports.\nfunc (t *ImportTracker) TrackImport(imported *ast.ImportSpec) {\n\timportPath := strings.Trim(imported.Path.Value, `\"`)\n\tif imported.Name != nil {\n\t\tif imported.Name.Name != \"_\" {\n\t\t\t// Aliased import\n\t\t\tt.Imported[importPath] = append(t.Imported[importPath], imported.Name.String())\n\t\t}\n\t} else {\n\t\tt.Imported[importPath] = append(t.Imported[importPath], importName(importPath))\n\t}\n}\n\nfunc importName(importPath string) string {\n\tparts := strings.Split(importPath, \"/\")\n\tname := importPath\n\tif len(parts) > 0 {\n\t\tname = parts[len(parts)-1]\n\t}\n\t// If the last segment of the path is version information, consider the second to last segment as the package name.\n\t// (e.g., `math/rand/v2` would be `rand`)\n\tif len(parts) > 1 && versioningPackagePattern.MatchString(name) {\n\t\tname = parts[len(parts)-2]\n\t}\n\treturn name\n}\n"
        },
        {
          "name": "import_tracker_test.go",
          "type": "blob",
          "size": 1.345703125,
          "content": "package gosec_test\n\nimport (\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"github.com/securego/gosec/v2\"\n\t\"github.com/securego/gosec/v2/testutils\"\n)\n\nvar _ = Describe(\"Import Tracker\", func() {\n\tContext(\"when tracking a file\", func() {\n\t\tIt(\"should parse the imports from file\", func() {\n\t\t\ttracker := gosec.NewImportTracker()\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `\n\t\t\t\tpackage foo\n\t\t\t\timport \"fmt\"\n\t\t\t\tfunc foo() {\n\t\t\t\t  fmt.Println()\n\t\t\t\t}\n\t\t\t`)\n\t\t\terr := pkg.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tpkgs := pkg.Pkgs()\n\t\t\tExpect(pkgs).Should(HaveLen(1))\n\t\t\tfiles := pkgs[0].Syntax\n\t\t\tExpect(files).Should(HaveLen(1))\n\t\t\ttracker.TrackFile(files[0])\n\t\t\tExpect(tracker.Imported).Should(Equal(map[string][]string{\"fmt\": {\"fmt\"}}))\n\t\t})\n\t\tIt(\"should parse the named imports from file\", func() {\n\t\t\ttracker := gosec.NewImportTracker()\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `\n\t\t\t\tpackage foo\n\t\t\t\timport fm \"fmt\"\n\t\t\t\tfunc foo() {\n\t\t\t\t  fm.Println()\n\t\t\t\t}\n\t\t\t`)\n\t\t\terr := pkg.Build()\n\t\t\tExpect(err).ShouldNot(HaveOccurred())\n\t\t\tpkgs := pkg.Pkgs()\n\t\t\tExpect(pkgs).Should(HaveLen(1))\n\t\t\tfiles := pkgs[0].Syntax\n\t\t\tExpect(files).Should(HaveLen(1))\n\t\t\ttracker.TrackFile(files[0])\n\t\t\tExpect(tracker.Imported).Should(Equal(map[string][]string{\"fmt\": {\"fm\"}}))\n\t\t})\n\t})\n})\n"
        },
        {
          "name": "install.sh",
          "type": "blob",
          "size": 9.12890625,
          "content": "#!/bin/sh\nset -e\n# Code generated by godownloader. DO NOT EDIT.\n#\n\nusage() {\n  this=$1\n  cat <<EOF\n$this: download go binaries for securego/gosec\n\nUsage: $this [-b] bindir [-d] [tag]\n  -b sets bindir or installation directory, Defaults to ./bin\n  -d turns on debug logging\n   [tag] is a tag from\n   https://github.com/securego/gosec/releases\n   If tag is missing, then the latest will be used.\n\n Generated by godownloader\n  https://github.com/goreleaser/godownloader\n\nEOF\n  exit 2\n}\n\nparse_args() {\n  #BINDIR is ./bin unless set be ENV\n  # over-ridden by flag below\n\n  BINDIR=${BINDIR:-./bin}\n  while getopts \"b:dh?x\" arg; do\n    case \"$arg\" in\n      b) BINDIR=\"$OPTARG\" ;;\n      d) log_set_priority 10 ;;\n      h | \\?) usage \"$0\" ;;\n      x) set -x ;;\n    esac\n  done\n  shift $((OPTIND - 1))\n  TAG=$1\n}\n# this function wraps all the destructive operations\n# if a curl|bash cuts off the end of the script due to\n# network, either nothing will happen or will syntax error\n# out preventing half-done work\nexecute() {\n  tmpdir=$(mktemp -d)\n  log_debug \"downloading files into ${tmpdir}\"\n  http_download \"${tmpdir}/${TARBALL}\" \"${TARBALL_URL}\"\n  http_download \"${tmpdir}/${CHECKSUM}\" \"${CHECKSUM_URL}\"\n  hash_sha256_verify \"${tmpdir}/${TARBALL}\" \"${tmpdir}/${CHECKSUM}\"\n  srcdir=\"${tmpdir}\"\n  (cd \"${tmpdir}\" && untar \"${TARBALL}\")\n  test ! -d \"${BINDIR}\" && install -d \"${BINDIR}\"\n  for binexe in $BINARIES; do\n    if [ \"$OS\" = \"windows\" ]; then\n      binexe=\"${binexe}.exe\"\n    fi\n    install \"${srcdir}/${binexe}\" \"${BINDIR}/\"\n    log_info \"installed ${BINDIR}/${binexe}\"\n  done\n  rm -rf \"${tmpdir}\"\n}\nget_binaries() {\n  case \"$PLATFORM\" in\n    darwin/amd64) BINARIES=\"gosec\" ;;\n    darwin/arm64) BINARIES=\"gosec\" ;;\n    linux/amd64) BINARIES=\"gosec\" ;;\n    linux/arm64) BINARIES=\"gosec\" ;;\n    windows/amd64) BINARIES=\"gosec\" ;;\n    windows/arm64) BINARIES=\"gosec\" ;;\n    *)\n      log_crit \"platform $PLATFORM is not supported.  Make sure this script is up-to-date and file request at https://github.com/${PREFIX}/issues/new\"\n      exit 1\n      ;;\n  esac\n}\ntag_to_version() {\n  if [ -z \"${TAG}\" ]; then\n    log_info \"checking GitHub for latest tag\"\n  else\n    log_info \"checking GitHub for tag '${TAG}'\"\n  fi\n  REALTAG=$(github_release \"$OWNER/$REPO\" \"${TAG}\") && true\n  if test -z \"$REALTAG\"; then\n    log_crit \"unable to find '${TAG}' - use 'latest' or see https://github.com/${PREFIX}/releases for details\"\n    exit 1\n  fi\n  # if version starts with 'v', remove it\n  TAG=\"$REALTAG\"\n  VERSION=${TAG#v}\n}\nadjust_format() {\n  # change format (tar.gz or zip) based on OS\n  true\n}\nadjust_os() {\n  # adjust archive name based on OS\n  true\n}\nadjust_arch() {\n  # adjust archive name based on ARCH\n  true\n}\n\ncat /dev/null <<EOF\n------------------------------------------------------------------------\nhttps://github.com/client9/shlib - portable posix shell functions\nPublic domain - http://unlicense.org\nhttps://github.com/client9/shlib/blob/master/LICENSE.md\nbut credit (and pull requests) appreciated.\n------------------------------------------------------------------------\nEOF\nis_command() {\n  command -v \"$1\" >/dev/null\n}\nechoerr() {\n  echo \"$@\" 1>&2\n}\nlog_prefix() {\n  echo \"$0\"\n}\n_logp=6\nlog_set_priority() {\n  _logp=\"$1\"\n}\nlog_priority() {\n  if test -z \"$1\"; then\n    echo \"$_logp\"\n    return\n  fi\n  [ \"$1\" -le \"$_logp\" ]\n}\nlog_tag() {\n  case $1 in\n    0) echo \"emerg\" ;;\n    1) echo \"alert\" ;;\n    2) echo \"crit\" ;;\n    3) echo \"err\" ;;\n    4) echo \"warning\" ;;\n    5) echo \"notice\" ;;\n    6) echo \"info\" ;;\n    7) echo \"debug\" ;;\n    *) echo \"$1\" ;;\n  esac\n}\nlog_debug() {\n  log_priority 7 || return 0\n  echoerr \"$(log_prefix)\" \"$(log_tag 7)\" \"$@\"\n}\nlog_info() {\n  log_priority 6 || return 0\n  echoerr \"$(log_prefix)\" \"$(log_tag 6)\" \"$@\"\n}\nlog_err() {\n  log_priority 3 || return 0\n  echoerr \"$(log_prefix)\" \"$(log_tag 3)\" \"$@\"\n}\nlog_crit() {\n  log_priority 2 || return 0\n  echoerr \"$(log_prefix)\" \"$(log_tag 2)\" \"$@\"\n}\nuname_os() {\n  os=$(uname -s | tr '[:upper:]' '[:lower:]')\n  case \"$os\" in\n    cygwin_nt*) os=\"windows\" ;;\n    mingw*) os=\"windows\" ;;\n    msys_nt*) os=\"windows\" ;;\n  esac\n  echo \"$os\"\n}\nuname_arch() {\n  arch=$(uname -m)\n  case $arch in\n    x86_64) arch=\"amd64\" ;;\n    x86) arch=\"386\" ;;\n    i686) arch=\"386\" ;;\n    i386) arch=\"386\" ;;\n    aarch64) arch=\"arm64\" ;;\n    armv5*) arch=\"armv5\" ;;\n    armv6*) arch=\"armv6\" ;;\n    armv7*) arch=\"armv7\" ;;\n  esac\n  echo ${arch}\n}\nuname_os_check() {\n  os=$(uname_os)\n  case \"$os\" in\n    darwin) return 0 ;;\n    dragonfly) return 0 ;;\n    freebsd) return 0 ;;\n    linux) return 0 ;;\n    android) return 0 ;;\n    nacl) return 0 ;;\n    netbsd) return 0 ;;\n    openbsd) return 0 ;;\n    plan9) return 0 ;;\n    solaris) return 0 ;;\n    windows) return 0 ;;\n  esac\n  log_crit \"uname_os_check '$(uname -s)' got converted to '$os' which is not a GOOS value. Please file bug at https://github.com/client9/shlib\"\n  return 1\n}\nuname_arch_check() {\n  arch=$(uname_arch)\n  case \"$arch\" in\n    386) return 0 ;;\n    amd64) return 0 ;;\n    arm64) return 0 ;;\n    armv5) return 0 ;;\n    armv6) return 0 ;;\n    armv7) return 0 ;;\n    ppc64) return 0 ;;\n    ppc64le) return 0 ;;\n    mips) return 0 ;;\n    mipsle) return 0 ;;\n    mips64) return 0 ;;\n    mips64le) return 0 ;;\n    s390x) return 0 ;;\n    amd64p32) return 0 ;;\n  esac\n  log_crit \"uname_arch_check '$(uname -m)' got converted to '$arch' which is not a GOARCH value.  Please file bug report at https://github.com/client9/shlib\"\n  return 1\n}\nuntar() {\n  tarball=$1\n  case \"${tarball}\" in\n    *.tar.gz | *.tgz) tar --no-same-owner -xzf \"${tarball}\" ;;\n    *.tar) tar --no-same-owner -xf \"${tarball}\" ;;\n    *.zip) unzip \"${tarball}\" ;;\n    *)\n      log_err \"untar unknown archive format for ${tarball}\"\n      return 1\n      ;;\n  esac\n}\nhttp_download_curl() {\n  local_file=$1\n  source_url=$2\n  header=$3\n  if [ -z \"$header\" ]; then\n    code=$(curl -w '%{http_code}' -sL -o \"$local_file\" \"$source_url\")\n  else\n    code=$(curl -w '%{http_code}' -sL -H \"$header\" -o \"$local_file\" \"$source_url\")\n  fi\n  if [ \"$code\" != \"200\" ]; then\n    log_debug \"http_download_curl received HTTP status $code\"\n    return 1\n  fi\n  return 0\n}\nhttp_download_wget() {\n  local_file=$1\n  source_url=$2\n  header=$3\n  if [ -z \"$header\" ]; then\n    wget -q -O \"$local_file\" \"$source_url\"\n  else\n    wget -q --header \"$header\" -O \"$local_file\" \"$source_url\"\n  fi\n}\nhttp_download() {\n  log_debug \"http_download $2\"\n  if is_command curl; then\n    http_download_curl \"$@\"\n    return\n  elif is_command wget; then\n    http_download_wget \"$@\"\n    return\n  fi\n  log_crit \"http_download unable to find wget or curl\"\n  return 1\n}\nhttp_copy() {\n  tmp=$(mktemp)\n  http_download \"${tmp}\" \"$1\" \"$2\" || return 1\n  body=$(cat \"$tmp\")\n  rm -f \"${tmp}\"\n  echo \"$body\"\n}\ngithub_release() {\n  owner_repo=$1\n  version=$2\n  giturl=\"https://api.github.com/repos/${owner_repo}/releases/tags/${version}\"\n  if [ -z \"${version}\" ]; then\n    giturl=\"https://api.github.com/repos/${owner_repo}/releases/latest\"\n  fi\n  json=$(http_copy \"$giturl\" \"Accept:application/json\")\n  test -z \"$json\" && return 1\n  version=$(echo \"$json\" | tr -s '\\n' ' ' | sed 's/.*\"tag_name\": *\"//' | sed 's/\".*//')\n  test -z \"$version\" && return 1\n  echo \"$version\"\n}\nhash_sha256() {\n  TARGET=${1:-/dev/stdin}\n  if is_command gsha256sum; then\n    hash=$(gsha256sum \"$TARGET\") || return 1\n    echo \"$hash\" | cut -d ' ' -f 1\n  elif is_command sha256sum; then\n    hash=$(sha256sum \"$TARGET\") || return 1\n    echo \"$hash\" | cut -d ' ' -f 1\n  elif is_command shasum; then\n    hash=$(shasum -a 256 \"$TARGET\" 2>/dev/null) || return 1\n    echo \"$hash\" | cut -d ' ' -f 1\n  elif is_command openssl; then\n    hash=$(openssl -dst openssl dgst -sha256 \"$TARGET\") || return 1\n    echo \"$hash\" | cut -d ' ' -f a\n  else\n    log_crit \"hash_sha256 unable to find command to compute sha-256 hash\"\n    return 1\n  fi\n}\nhash_sha256_verify() {\n  TARGET=$1\n  checksums=$2\n  if [ -z \"$checksums\" ]; then\n    log_err \"hash_sha256_verify checksum file not specified in arg2\"\n    return 1\n  fi\n  BASENAME=${TARGET##*/}\n  want=$(grep \"${BASENAME}\" \"${checksums}\" 2>/dev/null | tr '\\t' ' ' | cut -d ' ' -f 1)\n  if [ -z \"$want\" ]; then\n    log_err \"hash_sha256_verify unable to find checksum for '${TARGET}' in '${checksums}'\"\n    return 1\n  fi\n  got=$(hash_sha256 \"$TARGET\")\n  if [ \"$want\" != \"$got\" ]; then\n    log_err \"hash_sha256_verify checksum for '$TARGET' did not verify ${want} vs $got\"\n    return 1\n  fi\n}\ncat /dev/null <<EOF\n------------------------------------------------------------------------\nEnd of functions from https://github.com/client9/shlib\n------------------------------------------------------------------------\nEOF\n\nPROJECT_NAME=\"gosec\"\nOWNER=securego\nREPO=\"gosec\"\nBINARY=gosec\nFORMAT=tar.gz\nOS=$(uname_os)\nARCH=$(uname_arch)\nPREFIX=\"$OWNER/$REPO\"\n\n# use in logging routines\nlog_prefix() {\n\techo \"$PREFIX\"\n}\nPLATFORM=\"${OS}/${ARCH}\"\nGITHUB_DOWNLOAD=https://github.com/${OWNER}/${REPO}/releases/download\n\nuname_os_check \"$OS\"\nuname_arch_check \"$ARCH\"\n\nparse_args \"$@\"\n\nget_binaries\n\ntag_to_version\n\nadjust_format\n\nadjust_os\n\nadjust_arch\n\nlog_info \"found version: ${VERSION} for ${TAG}/${OS}/${ARCH}\"\n\nNAME=${PROJECT_NAME}_${VERSION}_${OS}_${ARCH}\nTARBALL=${NAME}.${FORMAT}\nTARBALL_URL=${GITHUB_DOWNLOAD}/${TAG}/${TARBALL}\nCHECKSUM=${PROJECT_NAME}_${VERSION}_checksums.txt\nCHECKSUM_URL=${GITHUB_DOWNLOAD}/${TAG}/${CHECKSUM}\n\n\nexecute\n"
        },
        {
          "name": "issue",
          "type": "tree",
          "content": null
        },
        {
          "name": "perf-diff.sh",
          "type": "blob",
          "size": 1.0322265625,
          "content": "#!/bin/bash\n\nBIN=\"gosec\"\nBUILD_DIR=\"/tmp/securego\"\n\n# Scan the current folder and measure the duration.\nfunction scan() {\n  local scan_cmd=$1\n  s=$(date +%s%3N)\n  $scan_cmd -quiet ./...\n  e=$(date +%s%3N)\n  res=$(expr $e - $s)\n  echo $res\n}\n\n# Build the master reference version.\nmkdir -p ${BUILD_DIR}\ngit clone --quiet https://github.com/securego/gosec.git ${BUILD_DIR} >/dev/null\nmake -C ${BUILD_DIR} >/dev/null\n\n# Scan once with the main reference.\nduration_master=$(scan \"${BUILD_DIR}/${BIN}\")\necho \"gosec reference time: ${duration_master}ms\"\n\n# Build the current version.\nmake -C . >/dev/null\n\n# Scan once with the current version.\nduration=$(scan \"./${BIN}\")\necho \"gosec time: ${duration}ms\"\n\n# Compute the difference of the execution time.\ndiff=$(($duration - $duration_master))\nif [[ diff -lt 0 ]]; then\n  diff=$(($diff * -1))\nfi\necho \"diff: ${diff}ms\"\nperf=$((100 - ($duration * 100) / $duration_master))\necho \"perf diff: ${perf}%\"\n\n# Fail the build if there is a performance degradation of more than 10%.\nif [[ $perf -lt -10 ]]; then\n  exit 1\nfi\n"
        },
        {
          "name": "renovate.json",
          "type": "blob",
          "size": 0.49609375,
          "content": "{\n  \"dependencyDashboard\": true,\n  \"dependencyDashboardTitle\" : \"Renovate(bot) : dependency dashboard\",\n  \"vulnerabilityAlerts\": {\n    \"enabled\": true\n  },\n  \"extends\": [\n    \":preserveSemverRanges\",\n    \"group:all\",\n    \"schedule:weekly\"\n  ],\n  \"lockFileMaintenance\": {\n    \"commitMessageAction\": \"Update\",\n    \"enabled\": true,\n    \"extends\": [\n      \"group:all\",\n      \"schedule:weekly\"\n    ]\n  },\n  \"postUpdateOptions\": [\n    \"gomodTidy\",\n    \"gomodUpdateImportPaths\"\n  ],\n  \"separateMajorMinor\": false\n}\n"
        },
        {
          "name": "report.go",
          "type": "blob",
          "size": 0.6455078125,
          "content": "package gosec\n\nimport (\n\t\"github.com/securego/gosec/v2/issue\"\n)\n\n// ReportInfo this is report information\ntype ReportInfo struct {\n\tErrors       map[string][]Error `json:\"Golang errors\"`\n\tIssues       []*issue.Issue\n\tStats        *Metrics\n\tGosecVersion string\n}\n\n// NewReportInfo instantiate a ReportInfo\nfunc NewReportInfo(issues []*issue.Issue, metrics *Metrics, errors map[string][]Error) *ReportInfo {\n\treturn &ReportInfo{\n\t\tErrors: errors,\n\t\tIssues: issues,\n\t\tStats:  metrics,\n\t}\n}\n\n// WithVersion defines the version of gosec used to generate the report\nfunc (r *ReportInfo) WithVersion(version string) *ReportInfo {\n\tr.GosecVersion = version\n\treturn r\n}\n"
        },
        {
          "name": "report",
          "type": "tree",
          "content": null
        },
        {
          "name": "resolve.go",
          "type": "blob",
          "size": 2.3017578125,
          "content": "// (c) Copyright 2016 Hewlett Packard Enterprise Development LP\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gosec\n\nimport \"go/ast\"\n\nfunc resolveIdent(n *ast.Ident, c *Context) bool {\n\tif n.Obj == nil || n.Obj.Kind != ast.Var {\n\t\treturn true\n\t}\n\tif node, ok := n.Obj.Decl.(ast.Node); ok {\n\t\treturn TryResolve(node, c)\n\t}\n\treturn false\n}\n\nfunc resolveValueSpec(n *ast.ValueSpec, c *Context) bool {\n\tif len(n.Values) == 0 {\n\t\treturn false\n\t}\n\tfor _, value := range n.Values {\n\t\tif !TryResolve(value, c) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc resolveAssign(n *ast.AssignStmt, c *Context) bool {\n\tif len(n.Rhs) == 0 {\n\t\treturn false\n\t}\n\tfor _, arg := range n.Rhs {\n\t\tif !TryResolve(arg, c) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc resolveCompLit(n *ast.CompositeLit, c *Context) bool {\n\tif len(n.Elts) == 0 {\n\t\treturn false\n\t}\n\tfor _, arg := range n.Elts {\n\t\tif !TryResolve(arg, c) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc resolveBinExpr(n *ast.BinaryExpr, c *Context) bool {\n\treturn (TryResolve(n.X, c) && TryResolve(n.Y, c))\n}\n\nfunc resolveCallExpr(_ *ast.CallExpr, _ *Context) bool {\n\t// TODO(tkelsey): next step, full function resolution\n\treturn false\n}\n\n// TryResolve will attempt, given a subtree starting at some AST node, to resolve\n// all values contained within to a known constant. It is used to check for any\n// unknown values in compound expressions.\nfunc TryResolve(n ast.Node, c *Context) bool {\n\tswitch node := n.(type) {\n\tcase *ast.BasicLit:\n\t\treturn true\n\tcase *ast.CompositeLit:\n\t\treturn resolveCompLit(node, c)\n\tcase *ast.Ident:\n\t\treturn resolveIdent(node, c)\n\tcase *ast.ValueSpec:\n\t\treturn resolveValueSpec(node, c)\n\tcase *ast.AssignStmt:\n\t\treturn resolveAssign(node, c)\n\tcase *ast.CallExpr:\n\t\treturn resolveCallExpr(node, c)\n\tcase *ast.BinaryExpr:\n\t\treturn resolveBinExpr(node, c)\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "resolve_test.go",
          "type": "blob",
          "size": 10.837890625,
          "content": "package gosec_test\n\nimport (\n\t\"go/ast\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"github.com/securego/gosec/v2\"\n\t\"github.com/securego/gosec/v2/testutils\"\n)\n\nvar _ = Describe(\"Resolve ast node to concrete value\", func() {\n\tContext(\"when attempting to resolve an ast node\", func() {\n\t\tIt(\"should successfully resolve basic literal\", func() {\n\t\t\tvar basicLiteral *ast.BasicLit\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `package main; const foo = \"bar\"; func main(){}`)\n\t\t\tctx := pkg.CreateContext(\"foo.go\")\n\t\t\tv := testutils.NewMockVisitor()\n\t\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\tif node, ok := n.(*ast.BasicLit); ok {\n\t\t\t\t\tbasicLiteral = node\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tv.Context = ctx\n\t\t\tast.Walk(v, ctx.Root)\n\t\t\tExpect(basicLiteral).ShouldNot(BeNil())\n\t\t\tExpect(gosec.TryResolve(basicLiteral, ctx)).Should(BeTrue())\n\t\t})\n\n\t\tIt(\"should successfully resolve identifier\", func() {\n\t\t\tvar ident *ast.Ident\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `package main; var foo string = \"bar\"; func main(){}`)\n\t\t\tctx := pkg.CreateContext(\"foo.go\")\n\t\t\tv := testutils.NewMockVisitor()\n\t\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\tif node, ok := n.(*ast.Ident); ok {\n\t\t\t\t\tident = node\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tv.Context = ctx\n\t\t\tast.Walk(v, ctx.Root)\n\t\t\tExpect(ident).ShouldNot(BeNil())\n\t\t\tExpect(gosec.TryResolve(ident, ctx)).Should(BeTrue())\n\t\t})\n\n\t\tIt(\"should successfully resolve variable identifier\", func() {\n\t\t\tvar ident *ast.Ident\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `package main; import \"fmt\"; func main(){ x := \"test\"; y := x; fmt.Println(y) }`)\n\t\t\tctx := pkg.CreateContext(\"foo.go\")\n\t\t\tv := testutils.NewMockVisitor()\n\t\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\tif node, ok := n.(*ast.Ident); ok && node.Name == \"y\" {\n\t\t\t\t\tident = node\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tv.Context = ctx\n\t\t\tast.Walk(v, ctx.Root)\n\t\t\tExpect(ident).ShouldNot(BeNil())\n\t\t\tExpect(gosec.TryResolve(ident, ctx)).Should(BeTrue())\n\t\t})\n\n\t\tIt(\"should successfully not resolve variable identifier with no declaration\", func() {\n\t\t\tvar ident *ast.Ident\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `package main; import \"fmt\"; func main(){ x := \"test\"; y := x; fmt.Println(y) }`)\n\t\t\tctx := pkg.CreateContext(\"foo.go\")\n\t\t\tv := testutils.NewMockVisitor()\n\t\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\tif node, ok := n.(*ast.Ident); ok && node.Name == \"y\" {\n\t\t\t\t\tident = node\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tv.Context = ctx\n\t\t\tast.Walk(v, ctx.Root)\n\t\t\tExpect(ident).ShouldNot(BeNil())\n\t\t\tident.Obj.Decl = nil\n\t\t\tExpect(gosec.TryResolve(ident, ctx)).Should(BeFalse())\n\t\t})\n\n\t\tIt(\"should successfully resolve assign statement\", func() {\n\t\t\tvar assign *ast.AssignStmt\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `package main; const x = \"bar\"; func main(){ y := x; println(y) }`)\n\t\t\tctx := pkg.CreateContext(\"foo.go\")\n\t\t\tv := testutils.NewMockVisitor()\n\t\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\tif node, ok := n.(*ast.AssignStmt); ok {\n\t\t\t\t\tif id, ok := node.Lhs[0].(*ast.Ident); ok && id.Name == \"y\" {\n\t\t\t\t\t\tassign = node\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tv.Context = ctx\n\t\t\tast.Walk(v, ctx.Root)\n\t\t\tExpect(assign).ShouldNot(BeNil())\n\t\t\tExpect(gosec.TryResolve(assign, ctx)).Should(BeTrue())\n\t\t})\n\n\t\tIt(\"should successfully not resolve assign statement without rhs\", func() {\n\t\t\tvar assign *ast.AssignStmt\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `package main; const x = \"bar\"; func main(){ y := x; println(y) }`)\n\t\t\tctx := pkg.CreateContext(\"foo.go\")\n\t\t\tv := testutils.NewMockVisitor()\n\t\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\tif node, ok := n.(*ast.AssignStmt); ok {\n\t\t\t\t\tif id, ok := node.Lhs[0].(*ast.Ident); ok && id.Name == \"y\" {\n\t\t\t\t\t\tassign = node\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tv.Context = ctx\n\t\t\tast.Walk(v, ctx.Root)\n\t\t\tExpect(assign).ShouldNot(BeNil())\n\t\t\tassign.Rhs = []ast.Expr{}\n\t\t\tExpect(gosec.TryResolve(assign, ctx)).Should(BeFalse())\n\t\t})\n\n\t\tIt(\"should successfully not resolve assign statement with unsolvable rhs\", func() {\n\t\t\tvar assign *ast.AssignStmt\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `package main; const x = \"bar\"; func main(){ y := x; println(y) }`)\n\t\t\tctx := pkg.CreateContext(\"foo.go\")\n\t\t\tv := testutils.NewMockVisitor()\n\t\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\tif node, ok := n.(*ast.AssignStmt); ok {\n\t\t\t\t\tif id, ok := node.Lhs[0].(*ast.Ident); ok && id.Name == \"y\" {\n\t\t\t\t\t\tassign = node\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tv.Context = ctx\n\t\t\tast.Walk(v, ctx.Root)\n\t\t\tExpect(assign).ShouldNot(BeNil())\n\t\t\tassign.Rhs = []ast.Expr{&ast.CallExpr{}}\n\t\t\tExpect(gosec.TryResolve(assign, ctx)).Should(BeFalse())\n\t\t})\n\n\t\tIt(\"should successfully resolve a binary statement\", func() {\n\t\t\tvar target *ast.BinaryExpr\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `package main; const (x = \"bar\"; y = \"baz\"); func main(){ z := x + y; println(z) }`)\n\t\t\tctx := pkg.CreateContext(\"foo.go\")\n\t\t\tv := testutils.NewMockVisitor()\n\t\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\tif node, ok := n.(*ast.BinaryExpr); ok {\n\t\t\t\t\ttarget = node\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tv.Context = ctx\n\t\t\tast.Walk(v, ctx.Root)\n\t\t\tExpect(target).ShouldNot(BeNil())\n\t\t\tExpect(gosec.TryResolve(target, ctx)).Should(BeTrue())\n\t\t})\n\n\t\tIt(\"should successfully resolve value spec\", func() {\n\t\t\tvar value *ast.ValueSpec\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `package main; const x = \"bar\"; func main(){ var y string = x; println(y) }`)\n\t\t\tctx := pkg.CreateContext(\"foo.go\")\n\t\t\tv := testutils.NewMockVisitor()\n\t\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\tif node, ok := n.(*ast.ValueSpec); ok {\n\t\t\t\t\tif len(node.Names) == 1 && node.Names[0].Name == \"y\" {\n\t\t\t\t\t\tvalue = node\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tv.Context = ctx\n\t\t\tast.Walk(v, ctx.Root)\n\t\t\tExpect(value).ShouldNot(BeNil())\n\t\t\tExpect(gosec.TryResolve(value, ctx)).Should(BeTrue())\n\t\t})\n\t\tIt(\"should successfully not resolve value spec without values\", func() {\n\t\t\tvar value *ast.ValueSpec\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `package main; const x = \"bar\"; func main(){ var y string = x; println(y) }`)\n\t\t\tctx := pkg.CreateContext(\"foo.go\")\n\t\t\tv := testutils.NewMockVisitor()\n\t\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\tif node, ok := n.(*ast.ValueSpec); ok {\n\t\t\t\t\tif len(node.Names) == 1 && node.Names[0].Name == \"y\" {\n\t\t\t\t\t\tvalue = node\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tv.Context = ctx\n\t\t\tast.Walk(v, ctx.Root)\n\t\t\tExpect(value).ShouldNot(BeNil())\n\t\t\tvalue.Values = []ast.Expr{}\n\t\t\tExpect(gosec.TryResolve(value, ctx)).Should(BeFalse())\n\t\t})\n\n\t\tIt(\"should successfully not resolve value spec with unsolvable value\", func() {\n\t\t\tvar value *ast.ValueSpec\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `package main; const x = \"bar\"; func main(){ var y string = x; println(y) }`)\n\t\t\tctx := pkg.CreateContext(\"foo.go\")\n\t\t\tv := testutils.NewMockVisitor()\n\t\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\tif node, ok := n.(*ast.ValueSpec); ok {\n\t\t\t\t\tif len(node.Names) == 1 && node.Names[0].Name == \"y\" {\n\t\t\t\t\t\tvalue = node\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tv.Context = ctx\n\t\t\tast.Walk(v, ctx.Root)\n\t\t\tExpect(value).ShouldNot(BeNil())\n\t\t\tvalue.Values = []ast.Expr{&ast.CallExpr{}}\n\t\t\tExpect(gosec.TryResolve(value, ctx)).Should(BeFalse())\n\t\t})\n\n\t\tIt(\"should successfully resolve composite literal\", func() {\n\t\t\tvar value *ast.CompositeLit\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `package main; func main(){ y := []string{\"value1\", \"value2\"}; println(y) }`)\n\t\t\tctx := pkg.CreateContext(\"foo.go\")\n\t\t\tv := testutils.NewMockVisitor()\n\t\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\tif node, ok := n.(*ast.CompositeLit); ok {\n\t\t\t\t\tvalue = node\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tv.Context = ctx\n\t\t\tast.Walk(v, ctx.Root)\n\t\t\tExpect(value).ShouldNot(BeNil())\n\t\t\tExpect(gosec.TryResolve(value, ctx)).Should(BeTrue())\n\t\t})\n\n\t\tIt(\"should successfully not resolve composite literal without elst\", func() {\n\t\t\tvar value *ast.CompositeLit\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `package main; func main(){ y := []string{\"value1\", \"value2\"}; println(y) }`)\n\t\t\tctx := pkg.CreateContext(\"foo.go\")\n\t\t\tv := testutils.NewMockVisitor()\n\t\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\tif node, ok := n.(*ast.CompositeLit); ok {\n\t\t\t\t\tvalue = node\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tv.Context = ctx\n\t\t\tast.Walk(v, ctx.Root)\n\t\t\tExpect(value).ShouldNot(BeNil())\n\t\t\tvalue.Elts = []ast.Expr{}\n\t\t\tExpect(gosec.TryResolve(value, ctx)).Should(BeFalse())\n\t\t})\n\n\t\tIt(\"should successfully not resolve composite literal with unsolvable elst\", func() {\n\t\t\tvar value *ast.CompositeLit\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `package main; func main(){ y := []string{\"value1\", \"value2\"}; println(y) }`)\n\t\t\tctx := pkg.CreateContext(\"foo.go\")\n\t\t\tv := testutils.NewMockVisitor()\n\t\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\tif node, ok := n.(*ast.CompositeLit); ok {\n\t\t\t\t\tvalue = node\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tv.Context = ctx\n\t\t\tast.Walk(v, ctx.Root)\n\t\t\tExpect(value).ShouldNot(BeNil())\n\t\t\tvalue.Elts = []ast.Expr{&ast.CallExpr{}}\n\t\t\tExpect(gosec.TryResolve(value, ctx)).Should(BeFalse())\n\t\t})\n\n\t\tIt(\"should successfully not resolve call expressions\", func() {\n\t\t\tvar value *ast.CallExpr\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `package main; func main(){ y := []string{\"value1\", \"value2\"}; println(y) }`)\n\t\t\tctx := pkg.CreateContext(\"foo.go\")\n\t\t\tv := testutils.NewMockVisitor()\n\t\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\tif node, ok := n.(*ast.CallExpr); ok {\n\t\t\t\t\tvalue = node\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tv.Context = ctx\n\t\t\tast.Walk(v, ctx.Root)\n\t\t\tExpect(value).ShouldNot(BeNil())\n\t\t\tExpect(gosec.TryResolve(value, ctx)).Should(BeFalse())\n\t\t})\n\n\t\tIt(\"should successfully not resolve call expressions\", func() {\n\t\t\tvar value *ast.ImportSpec\n\t\t\tpkg := testutils.NewTestPackage()\n\t\t\tdefer pkg.Close()\n\t\t\tpkg.AddFile(\"foo.go\", `package main; import \"fmt\"; func main(){ y := []string{\"value1\", \"value2\"}; fmt.Println(y) }`)\n\t\t\tctx := pkg.CreateContext(\"foo.go\")\n\t\t\tv := testutils.NewMockVisitor()\n\t\t\tv.Callback = func(n ast.Node, ctx *gosec.Context) bool {\n\t\t\t\tif node, ok := n.(*ast.ImportSpec); ok {\n\t\t\t\t\tvalue = node\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tv.Context = ctx\n\t\t\tast.Walk(v, ctx.Root)\n\t\t\tExpect(value).ShouldNot(BeNil())\n\t\t\tExpect(gosec.TryResolve(value, ctx)).Should(BeFalse())\n\t\t})\n\t})\n})\n"
        },
        {
          "name": "rule.go",
          "type": "blob",
          "size": 2.1767578125,
          "content": "// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gosec\n\nimport (\n\t\"go/ast\"\n\t\"reflect\"\n\n\t\"github.com/securego/gosec/v2/issue\"\n)\n\n// The Rule interface used by all rules supported by gosec.\ntype Rule interface {\n\tID() string\n\tMatch(ast.Node, *Context) (*issue.Issue, error)\n}\n\n// RuleBuilder is used to register a rule definition with the analyzer\ntype RuleBuilder func(id string, c Config) (Rule, []ast.Node)\n\n// A RuleSet contains a mapping of lists of rules to the type of AST node they\n// should be run on and a mapping of rule ID's to whether the rule are\n// suppressed.\n// The analyzer will only invoke rules contained in the list associated with the\n// type of AST node it is currently visiting.\ntype RuleSet struct {\n\tRules             map[reflect.Type][]Rule\n\tRuleSuppressedMap map[string]bool\n}\n\n// NewRuleSet constructs a new RuleSet\nfunc NewRuleSet() RuleSet {\n\treturn RuleSet{make(map[reflect.Type][]Rule), make(map[string]bool)}\n}\n\n// Register adds a trigger for the supplied rule for the\n// specified ast nodes.\nfunc (r RuleSet) Register(rule Rule, isSuppressed bool, nodes ...ast.Node) {\n\tfor _, n := range nodes {\n\t\tt := reflect.TypeOf(n)\n\t\tif rules, ok := r.Rules[t]; ok {\n\t\t\tr.Rules[t] = append(rules, rule)\n\t\t} else {\n\t\t\tr.Rules[t] = []Rule{rule}\n\t\t}\n\t}\n\tr.RuleSuppressedMap[rule.ID()] = isSuppressed\n}\n\n// RegisteredFor will return all rules that are registered for a\n// specified ast node.\nfunc (r RuleSet) RegisteredFor(n ast.Node) []Rule {\n\tif rules, found := r.Rules[reflect.TypeOf(n)]; found {\n\t\treturn rules\n\t}\n\treturn []Rule{}\n}\n\n// IsRuleSuppressed will return whether the rule is suppressed.\nfunc (r RuleSet) IsRuleSuppressed(ruleID string) bool {\n\treturn r.RuleSuppressedMap[ruleID]\n}\n"
        },
        {
          "name": "rule_test.go",
          "type": "blob",
          "size": 3.0849609375,
          "content": "package gosec_test\n\nimport (\n\t\"fmt\"\n\t\"go/ast\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n\n\t\"github.com/securego/gosec/v2\"\n\t\"github.com/securego/gosec/v2/issue\"\n)\n\ntype mockrule struct {\n\tissue    *issue.Issue\n\terr      error\n\tcallback func(n ast.Node, ctx *gosec.Context) bool\n}\n\nfunc (m *mockrule) ID() string {\n\treturn \"MOCK\"\n}\n\nfunc (m *mockrule) Match(n ast.Node, ctx *gosec.Context) (*issue.Issue, error) {\n\tif m.callback(n, ctx) {\n\t\treturn m.issue, nil\n\t}\n\treturn nil, m.err\n}\n\nvar _ = Describe(\"Rule\", func() {\n\tContext(\"when using a ruleset\", func() {\n\t\tvar (\n\t\t\truleset        gosec.RuleSet\n\t\t\tdummyErrorRule gosec.Rule\n\t\t\tdummyIssueRule gosec.Rule\n\t\t)\n\n\t\tJustBeforeEach(func() {\n\t\t\truleset = gosec.NewRuleSet()\n\t\t\tdummyErrorRule = &mockrule{\n\t\t\t\tissue:    nil,\n\t\t\t\terr:      fmt.Errorf(\"An unexpected error occurred\"),\n\t\t\t\tcallback: func(n ast.Node, ctx *gosec.Context) bool { return false },\n\t\t\t}\n\t\t\tdummyIssueRule = &mockrule{\n\t\t\t\tissue: &issue.Issue{\n\t\t\t\t\tSeverity:   issue.High,\n\t\t\t\t\tConfidence: issue.High,\n\t\t\t\t\tWhat:       `Some explanation of the thing`,\n\t\t\t\t\tFile:       \"main.go\",\n\t\t\t\t\tCode:       `#include <stdio.h> int main(){ puts(\"hello world\"); }`,\n\t\t\t\t\tLine:       \"42\",\n\t\t\t\t},\n\t\t\t\terr:      nil,\n\t\t\t\tcallback: func(n ast.Node, ctx *gosec.Context) bool { return true },\n\t\t\t}\n\t\t})\n\t\tIt(\"should be possible to register a rule for multiple ast.Node\", func() {\n\t\t\tregisteredNodeA := (*ast.CallExpr)(nil)\n\t\t\tregisteredNodeB := (*ast.AssignStmt)(nil)\n\t\t\tunregisteredNode := (*ast.BinaryExpr)(nil)\n\n\t\t\truleset.Register(dummyIssueRule, false, registeredNodeA, registeredNodeB)\n\t\t\tExpect(ruleset.RegisteredFor(unregisteredNode)).Should(BeEmpty())\n\t\t\tExpect(ruleset.RegisteredFor(registeredNodeA)).Should(ContainElement(dummyIssueRule))\n\t\t\tExpect(ruleset.RegisteredFor(registeredNodeB)).Should(ContainElement(dummyIssueRule))\n\t\t\tExpect(ruleset.IsRuleSuppressed(dummyIssueRule.ID())).Should(BeFalse())\n\t\t})\n\n\t\tIt(\"should not register a rule when no ast.Nodes are specified\", func() {\n\t\t\truleset.Register(dummyErrorRule, false)\n\t\t\tExpect(ruleset.Rules).Should(BeEmpty())\n\t\t})\n\n\t\tIt(\"should be possible to retrieve a list of rules for a given node type\", func() {\n\t\t\tregisteredNode := (*ast.CallExpr)(nil)\n\t\t\tunregisteredNode := (*ast.AssignStmt)(nil)\n\t\t\truleset.Register(dummyErrorRule, false, registeredNode)\n\t\t\truleset.Register(dummyIssueRule, false, registeredNode)\n\t\t\tExpect(ruleset.RegisteredFor(unregisteredNode)).Should(BeEmpty())\n\t\t\tExpect(ruleset.RegisteredFor(registeredNode)).Should(HaveLen(2))\n\t\t\tExpect(ruleset.RegisteredFor(registeredNode)).Should(ContainElement(dummyErrorRule))\n\t\t\tExpect(ruleset.RegisteredFor(registeredNode)).Should(ContainElement(dummyIssueRule))\n\t\t})\n\n\t\tIt(\"should register a suppressed rule\", func() {\n\t\t\tregisteredNode := (*ast.CallExpr)(nil)\n\t\t\tunregisteredNode := (*ast.AssignStmt)(nil)\n\t\t\truleset.Register(dummyIssueRule, true, registeredNode)\n\t\t\tExpect(ruleset.RegisteredFor(registeredNode)).Should(ContainElement(dummyIssueRule))\n\t\t\tExpect(ruleset.RegisteredFor(unregisteredNode)).Should(BeEmpty())\n\t\t\tExpect(ruleset.IsRuleSuppressed(dummyIssueRule.ID())).Should(BeTrue())\n\t\t})\n\t})\n})\n"
        },
        {
          "name": "rules",
          "type": "tree",
          "content": null
        },
        {
          "name": "testutils",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}