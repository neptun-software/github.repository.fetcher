{
  "metadata": {
    "timestamp": 1736567526990,
    "page": 128,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "gokcehan/lf",
      "stars": 7892,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0283203125,
          "content": "lf\nlf.exe\ntags\ndist/\nvendor/\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.6337890625,
          "content": "# Contributing\n\nCode contributions are always welcomed in lf.\n\nIf you are going to introduce a new feature, it is best to open an issue first for discussion. If your feature can be implemented as a configuration option **please add it to the [wiki](https://github.com/gokcehan/lf/wiki)**.\n\nFor bug fixes, you can simply send a pull request.\n\n## Code conventions\n\nIn addition to `gofmt` and friends (e.g. [go vet](https://pkg.go.dev/cmd/vet), [staticcheck](https://staticcheck.dev/), [golangci-lint](https://golangci-lint.run/)), we have a few conventions:\n\n- Global variables are best avoided except when they are not.\nGlobal variable names are prefixed with `g` as in `gFooBar`.\nExceptions are variables holding values of environmental variables which are prefixed with `env` as in `envFooBar` and regular expressions which are prefixed with `re` as in `reFooBar` when they are global.\n- Type and function names are small case as in `fooBar` since we don't use exporting.\n- For file name variables, `name`, `fname`, or `filename` should refer to the base name of the file as in `baz.txt`, and `path`, `fpath`, or `filepath` should refer to the full path of the file as in `/foo/bar/baz.txt`.\n- Run `go fmt` to ensure that files are formatted correctly.\n\nUse the surrounding code as reference when in doubt as usual.\n\n## Adding a new option\n\nAdding a new option usually requires the following steps:\n\n- Add option name/type to `gOpts` struct in `opts.go`\n- Add default option value to `init` function in `opts.go`\n- Add option evaluation logic to `setExpr.eval` in `eval.go`\n- Implement the option somewhere in the code\n- Add option name and its default value to `Quick Reference` and `Options` sections in `doc.md`\n- Run `gen/doc-with-docker.sh` to update the documentation\n- Commit your changes and send a pull request\n\n## Adding a new builtin command\n\nAdding a new command usually requires the following steps:\n\n- Add default key if any to `init` function in `opts.go`\n- Add command evaluation logic to `callExpr.eval` in `eval.go`\n- Implement the command somewhere in the code\n- Add command name to `gCmdWords` in `complete.go` for tab completion\n- Add command name to `Quick Reference` and `Commands` sections in `doc.md`\n- Optionally, run `gen/doc-with-docker.sh` to update the documentation\n- Commit your changes and send a pull request\n\n## Platform specific code\n\nThere are two files named `os.go` and `os_windows.go` for unix and windows specific code respectively.\nIf you add something to either of these files but not the other, you probably break the build for the other platform.\nIf your addition works the same in both platforms, your addition probably belongs to `main.go` instead.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.046875,
          "content": "MIT License\n\nCopyright (c) 2016 Gökçehan Kara\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.90234375,
          "content": "# LF\n\n[Google Groups](https://groups.google.com/forum/#!forum/lf-fm)\n| [Doc](doc.md)\n| [Wiki](https://github.com/gokcehan/lf/wiki)\n| [#lf](https://web.libera.chat/#lf) (on Libera.Chat)\n| [#lf:matrix.org](https://matrix.to/#/#lf:matrix.org) (with IRC bridge)\n\n[![Go Build](https://github.com/gokcehan/lf/actions/workflows/go.yml/badge.svg)](https://github.com/gokcehan/lf/actions/workflows/go.yml)\n[![Go Report Card](https://goreportcard.com/badge/github.com/gokcehan/lf)](https://goreportcard.com/report/github.com/gokcehan/lf)\n\n`lf` (as in \"list files\") is a terminal file manager written in Go with a heavy inspiration from ranger file manager.\nSee [faq](https://github.com/gokcehan/lf/wiki/FAQ) for more information and [tutorial](https://github.com/gokcehan/lf/wiki/Tutorial) for a gentle introduction with screencasts.\n\n![multicol-screenshot](http://i.imgur.com/DaTUenu.png)\n![singlecol-screenshot](http://i.imgur.com/p95xzUj.png)\n\n## Features\n\n- Cross-platform (Linux, macOS, BSDs, Windows)\n- Single binary without any runtime dependencies\n- Fast startup and low memory footprint due to native code and static binaries\n- Asynchronous IO operations to avoid UI locking\n- Server/client architecture and remote commands to manage multiple instances\n- Extendable and configurable with shell commands\n- Customizable keybindings (vi and readline defaults)\n- A reasonable set of other features (see the [documentation](doc.md))\n\n## Non-Features\n\n- Tabs or windows (better handled by window manager or terminal multiplexer)\n- Builtin pager/editor (better handled by your pager/editor of choice)\n- Builtin commands for file operations (better handled by the underlying shell tools including but not limited to `mkdir`, `touch`, `chmod`, `chown`, `chgrp`, and `ln`)\n\n## Installation\n\nSee [packages](https://github.com/gokcehan/lf/wiki/Packages) for community maintained packages.\n\nSee [releases](https://github.com/gokcehan/lf/releases) for pre-built binaries.\n\nBuilding from the source requires [Go](https://go.dev/).\n\nOn Unix:\n\n```bash\nenv CGO_ENABLED=0 go install -ldflags=\"-s -w\" github.com/gokcehan/lf@latest\n```\n\nOn Windows `cmd`:\n\n```cmd\nset CGO_ENABLED=0\ngo install -ldflags=\"-s -w\" github.com/gokcehan/lf@latest\n```\n\nOn Windows `powershell`:\n\n```powershell\n$env:CGO_ENABLED = '0'\ngo install -ldflags=\"-s -w\" github.com/gokcehan/lf@latest\n```\n\n## Usage\n\nAfter the installation `lf` command should start the application in the current directory.\n\nRun `lf -help` to see command line options.\n\nRun `lf -doc` to see the [documentation](doc.md).\n\nSee [etc](etc) directory to integrate `lf` to your shell and/or editor.\nExample configuration files along with example colors and icons files can also be found in this directory.\n\nSee [integrations](https://github.com/gokcehan/lf/wiki/Integrations) to integrate `lf` to other tools.\n\nSee [tips](https://github.com/gokcehan/lf/wiki/Tips) for more examples.\n\n## Contributing\n\nSee [contributing](CONTRIBUTING.md) for guidelines.\n"
        },
        {
          "name": "app.go",
          "type": "blob",
          "size": 13.3916015625,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n)\n\ntype cmdItem struct {\n\tprefix string\n\tvalue  string\n}\n\ntype app struct {\n\tui             *ui\n\tnav            *nav\n\tticker         *time.Ticker\n\tquitChan       chan struct{}\n\tcmd            *exec.Cmd\n\tcmdIn          io.WriteCloser\n\tcmdOutBuf      []byte\n\tcmdHistory     []cmdItem\n\tcmdHistoryBeg  int\n\tcmdHistoryInd  int\n\tmenuCompActive bool\n\tmenuComps      []string\n\tmenuCompInd    int\n\tselectionOut   []string\n\twatch          *watch\n\tquitting       bool\n}\n\nfunc newApp(ui *ui, nav *nav) *app {\n\tquitChan := make(chan struct{}, 1)\n\n\tapp := &app{\n\t\tui:       ui,\n\t\tnav:      nav,\n\t\tticker:   new(time.Ticker),\n\t\tquitChan: quitChan,\n\t\twatch:    newWatch(nav.dirChan, nav.fileChan, nav.delChan),\n\t}\n\n\tsigChan := make(chan os.Signal, 1)\n\tsignal.Notify(sigChan, os.Interrupt, syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM)\n\tgo func() {\n\t\tfor {\n\t\t\tswitch <-sigChan {\n\t\t\tcase os.Interrupt:\n\t\t\tcase syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM:\n\t\t\t\tapp.quit()\n\t\t\t\tos.Exit(3)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn app\n}\n\nfunc (app *app) quit() {\n\t// Using synchronous shell commands for `on-quit` can cause this to be\n\t// called again, so a guard variable is introduced here to prevent an\n\t// infinite loop.\n\tif app.quitting {\n\t\treturn\n\t}\n\tapp.quitting = true\n\n\tonQuit(app)\n\n\tif gOpts.history {\n\t\tif err := app.writeHistory(); err != nil {\n\t\t\tlog.Printf(\"writing history file: %s\", err)\n\t\t}\n\t}\n\tif !gSingleMode {\n\t\tif err := remote(fmt.Sprintf(\"drop %d\", gClientID)); err != nil {\n\t\t\tlog.Printf(\"dropping connection: %s\", err)\n\t\t}\n\t\tif gOpts.autoquit {\n\t\t\tif err := remote(\"quit\"); err != nil {\n\t\t\t\tlog.Printf(\"auto quitting server: %s\", err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (app *app) readFile(path string) {\n\tlog.Printf(\"reading file: %s\", path)\n\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\tapp.ui.echoerrf(\"opening file: %s\", err)\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\tp := newParser(f)\n\n\tfor p.parse() {\n\t\tp.expr.eval(app, nil)\n\t}\n\n\tif p.err != nil {\n\t\tapp.ui.echoerrf(\"%s\", p.err)\n\t}\n}\n\nfunc loadFiles() (list []string, cp bool, err error) {\n\tfiles, err := os.Open(gFilesPath)\n\tif os.IsNotExist(err) {\n\t\terr = nil\n\t\treturn\n\t}\n\tif err != nil {\n\t\terr = fmt.Errorf(\"opening file selections file: %s\", err)\n\t\treturn\n\t}\n\tdefer files.Close()\n\n\ts := bufio.NewScanner(files)\n\n\ts.Scan()\n\n\tswitch s.Text() {\n\tcase \"copy\":\n\t\tcp = true\n\tcase \"move\":\n\t\tcp = false\n\tdefault:\n\t\terr = fmt.Errorf(\"unexpected option to copy file(s): %s\", s.Text())\n\t\treturn\n\t}\n\n\tfor s.Scan() && s.Text() != \"\" {\n\t\tlist = append(list, s.Text())\n\t}\n\n\tif s.Err() != nil {\n\t\terr = fmt.Errorf(\"scanning file list: %s\", s.Err())\n\t\treturn\n\t}\n\n\tlog.Printf(\"loading files: %v\", list)\n\n\treturn\n}\n\nfunc saveFiles(list []string, cp bool) error {\n\tif err := os.MkdirAll(filepath.Dir(gFilesPath), os.ModePerm); err != nil {\n\t\treturn fmt.Errorf(\"creating data directory: %s\", err)\n\t}\n\n\tfiles, err := os.Create(gFilesPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"opening file selections file: %s\", err)\n\t}\n\tdefer files.Close()\n\n\tlog.Printf(\"saving files: %v\", list)\n\n\tif cp {\n\t\tfmt.Fprintln(files, \"copy\")\n\t} else {\n\t\tfmt.Fprintln(files, \"move\")\n\t}\n\n\tfor _, f := range list {\n\t\tfmt.Fprintln(files, f)\n\t}\n\n\tfiles.Sync()\n\treturn nil\n}\n\nfunc (app *app) readHistory() error {\n\tf, err := os.Open(gHistoryPath)\n\tif os.IsNotExist(err) {\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"opening history file: %s\", err)\n\t}\n\tdefer f.Close()\n\n\tscanner := bufio.NewScanner(f)\n\tfor scanner.Scan() {\n\t\ttoks := strings.SplitN(scanner.Text(), \" \", 2)\n\t\tif toks[0] != \":\" && toks[0] != \"$\" && toks[0] != \"%\" && toks[0] != \"!\" && toks[0] != \"&\" {\n\t\t\tcontinue\n\t\t}\n\t\tif len(toks) < 2 {\n\t\t\tcontinue\n\t\t}\n\t\tapp.cmdHistory = append(app.cmdHistory, cmdItem{toks[0], toks[1]})\n\t}\n\n\tapp.cmdHistoryBeg = len(app.cmdHistory)\n\n\tif err := scanner.Err(); err != nil {\n\t\treturn fmt.Errorf(\"reading history file: %s\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (app *app) writeHistory() error {\n\tif len(app.cmdHistory) == 0 {\n\t\treturn nil\n\t}\n\n\tlocal := make([]cmdItem, len(app.cmdHistory)-app.cmdHistoryBeg)\n\tcopy(local, app.cmdHistory[app.cmdHistoryBeg:])\n\tapp.cmdHistory = nil\n\n\tif err := app.readHistory(); err != nil {\n\t\treturn fmt.Errorf(\"reading history file: %s\", err)\n\t}\n\n\tapp.cmdHistory = append(app.cmdHistory, local...)\n\n\tif err := os.MkdirAll(filepath.Dir(gHistoryPath), os.ModePerm); err != nil {\n\t\treturn fmt.Errorf(\"creating data directory: %s\", err)\n\t}\n\n\tf, err := os.Create(gHistoryPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"creating history file: %s\", err)\n\t}\n\tdefer f.Close()\n\n\tif len(app.cmdHistory) > 1000 {\n\t\tapp.cmdHistory = app.cmdHistory[len(app.cmdHistory)-1000:]\n\t}\n\n\tfor _, cmd := range app.cmdHistory {\n\t\t_, err = fmt.Fprintf(f, \"%s %s\\n\", cmd.prefix, cmd.value)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"writing history file: %s\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// This is the main event loop of the application. Expressions are read from\n// the client and the server on separate goroutines and sent here over channels\n// for evaluation. Similarly directories and regular files are also read in\n// separate goroutines and sent here for update.\nfunc (app *app) loop() {\n\tgo app.nav.previewLoop(app.ui)\n\tgo app.nav.dirPreviewLoop(app.ui)\n\n\tvar serverChan <-chan expr\n\tif !gSingleMode {\n\t\tserverChan = readExpr()\n\t}\n\n\tapp.ui.readExpr()\n\n\tif gConfigPath != \"\" {\n\t\tif _, err := os.Stat(gConfigPath); !os.IsNotExist(err) {\n\t\t\tapp.readFile(gConfigPath)\n\t\t} else {\n\t\t\tlog.Printf(\"config file does not exist: %s\", err)\n\t\t}\n\t} else {\n\t\tfor _, path := range gConfigPaths {\n\t\t\tif _, err := os.Stat(path); !os.IsNotExist(err) {\n\t\t\t\tapp.readFile(path)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, cmd := range gCommands {\n\t\tp := newParser(strings.NewReader(cmd))\n\n\t\tfor p.parse() {\n\t\t\tp.expr.eval(app, nil)\n\t\t}\n\n\t\tif p.err != nil {\n\t\t\tapp.ui.echoerrf(\"%s\", p.err)\n\t\t}\n\t}\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tlog.Printf(\"getting current directory: %s\", err)\n\t}\n\n\tapp.nav.getDirs(wd)\n\tapp.nav.addJumpList()\n\tapp.nav.init = true\n\n\tif gSelect != \"\" {\n\t\tgo func() {\n\t\t\tlstat, err := os.Lstat(gSelect)\n\t\t\tif err != nil {\n\t\t\t\tapp.ui.exprChan <- &callExpr{\"echoerr\", []string{err.Error()}, 1}\n\t\t\t} else if lstat.IsDir() {\n\t\t\t\tapp.ui.exprChan <- &callExpr{\"cd\", []string{gSelect}, 1}\n\t\t\t} else {\n\t\t\t\tapp.ui.exprChan <- &callExpr{\"select\", []string{gSelect}, 1}\n\t\t\t}\n\t\t}()\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase <-app.quitChan:\n\t\t\tif app.nav.copyTotal > 0 {\n\t\t\t\tapp.ui.echoerr(\"quit: copy operation in progress\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif app.nav.moveTotal > 0 {\n\t\t\t\tapp.ui.echoerr(\"quit: move operation in progress\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif app.nav.deleteTotal > 0 {\n\t\t\t\tapp.ui.echoerr(\"quit: delete operation in progress\")\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tapp.quit()\n\n\t\t\tapp.nav.previewChan <- \"\"\n\t\t\tapp.nav.dirPreviewChan <- nil\n\n\t\t\tlog.Print(\"bye!\")\n\n\t\t\treturn\n\t\tcase n := <-app.nav.copyBytesChan:\n\t\t\tapp.nav.copyBytes += n\n\t\t\t// n is usually 32*1024B (default io.Copy() buffer) so update roughly per 32KB x 128 = 4MB copied\n\t\t\tif app.nav.copyUpdate++; app.nav.copyUpdate >= 128 {\n\t\t\t\tapp.nav.copyUpdate = 0\n\t\t\t\tapp.ui.draw(app.nav)\n\t\t\t}\n\t\tcase n := <-app.nav.copyTotalChan:\n\t\t\tapp.nav.copyTotal += n\n\t\t\tif n < 0 {\n\t\t\t\tapp.nav.copyBytes += n\n\t\t\t}\n\t\t\tif app.nav.copyTotal == 0 {\n\t\t\t\tapp.nav.copyUpdate = 0\n\t\t\t}\n\t\t\tapp.ui.draw(app.nav)\n\t\tcase n := <-app.nav.moveCountChan:\n\t\t\tapp.nav.moveCount += n\n\t\t\tif app.nav.moveUpdate++; app.nav.moveUpdate >= 1000 {\n\t\t\t\tapp.nav.moveUpdate = 0\n\t\t\t\tapp.ui.draw(app.nav)\n\t\t\t}\n\t\tcase n := <-app.nav.moveTotalChan:\n\t\t\tapp.nav.moveTotal += n\n\t\t\tif n < 0 {\n\t\t\t\tapp.nav.moveCount += n\n\t\t\t}\n\t\t\tif app.nav.moveTotal == 0 {\n\t\t\t\tapp.nav.moveUpdate = 0\n\t\t\t}\n\t\t\tapp.ui.draw(app.nav)\n\t\tcase n := <-app.nav.deleteCountChan:\n\t\t\tapp.nav.deleteCount += n\n\t\t\tif app.nav.deleteUpdate++; app.nav.deleteUpdate >= 1000 {\n\t\t\t\tapp.nav.deleteUpdate = 0\n\t\t\t\tapp.ui.draw(app.nav)\n\t\t\t}\n\t\tcase n := <-app.nav.deleteTotalChan:\n\t\t\tapp.nav.deleteTotal += n\n\t\t\tif n < 0 {\n\t\t\t\tapp.nav.deleteCount += n\n\t\t\t}\n\t\t\tif app.nav.deleteTotal == 0 {\n\t\t\t\tapp.nav.deleteUpdate = 0\n\t\t\t}\n\t\t\tapp.ui.draw(app.nav)\n\t\tcase d := <-app.nav.dirChan:\n\t\t\tif gOpts.dircache {\n\t\t\t\tprev, ok := app.nav.dirCache[d.path]\n\t\t\t\tif ok {\n\t\t\t\t\td.ind = prev.ind\n\t\t\t\t\td.pos = prev.pos\n\t\t\t\t\td.filter = prev.filter\n\t\t\t\t\td.sort()\n\t\t\t\t\td.sel(prev.name(), app.nav.height)\n\t\t\t\t}\n\n\t\t\t\tapp.nav.dirCache[d.path] = d\n\t\t\t}\n\n\t\t\tvar oldCurrPath string\n\t\t\tif curr, err := app.nav.currFile(); err == nil {\n\t\t\t\toldCurrPath = curr.path\n\t\t\t}\n\n\t\t\tfor i := range app.nav.dirs {\n\t\t\t\tif app.nav.dirs[i].path == d.path {\n\t\t\t\t\tapp.nav.dirs[i] = d\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tapp.nav.position()\n\n\t\t\tcurr, err := app.nav.currFile()\n\t\t\tif err == nil {\n\t\t\t\tif curr.path != oldCurrPath {\n\t\t\t\t\tapp.ui.loadFile(app, true)\n\t\t\t\t\tif app.ui.msgIsStat {\n\t\t\t\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif d.path == curr.path {\n\t\t\t\t\tapp.ui.dirPrev = d\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tapp.setWatchPaths()\n\n\t\t\tapp.ui.draw(app.nav)\n\t\tcase r := <-app.nav.regChan:\n\t\t\tapp.nav.regCache[r.path] = r\n\n\t\t\tcurr, err := app.nav.currFile()\n\t\t\tif err == nil {\n\t\t\t\tif r.path == curr.path {\n\t\t\t\t\tapp.ui.regPrev = r\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tapp.ui.draw(app.nav)\n\t\tcase f := <-app.nav.fileChan:\n\t\t\tdirs := app.nav.dirs\n\t\t\tif app.ui.dirPrev != nil {\n\t\t\t\tdirs = append(dirs, app.ui.dirPrev)\n\t\t\t}\n\n\t\t\tfor _, dir := range dirs {\n\t\t\t\tif dir.path != filepath.Dir(f.path) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor i := range dir.allFiles {\n\t\t\t\t\tif dir.allFiles[i].path == f.path {\n\t\t\t\t\t\tdir.allFiles[i] = f\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tname := dir.name()\n\t\t\t\tdir.sort()\n\t\t\t\tdir.sel(name, app.nav.height)\n\t\t\t}\n\n\t\t\tapp.ui.loadFile(app, false)\n\t\t\tif app.ui.msgIsStat {\n\t\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t\t}\n\t\t\tapp.ui.draw(app.nav)\n\t\tcase path := <-app.nav.delChan:\n\t\t\tdelete(app.nav.dirCache, path)\n\t\t\tdelete(app.nav.regCache, path)\n\t\tcase ev := <-app.ui.evChan:\n\t\t\te := app.ui.readEvent(ev, app.nav)\n\t\t\tif e == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\te.eval(app, nil)\n\t\tloop:\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase ev := <-app.ui.evChan:\n\t\t\t\t\te = app.ui.readEvent(ev, app.nav)\n\t\t\t\t\tif e == nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\te.eval(app, nil)\n\t\t\t\tdefault:\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t}\n\t\t\tapp.ui.draw(app.nav)\n\t\tcase e := <-app.ui.exprChan:\n\t\t\te.eval(app, nil)\n\t\t\tapp.ui.draw(app.nav)\n\t\tcase e := <-serverChan:\n\t\t\te.eval(app, nil)\n\t\t\tapp.ui.draw(app.nav)\n\t\tcase <-app.ticker.C:\n\t\t\tapp.nav.renew()\n\t\t\tapp.ui.loadFile(app, false)\n\t\tcase <-app.nav.previewTimer.C:\n\t\t\tapp.nav.previewLoading = true\n\t\t\tapp.ui.draw(app.nav)\n\t\t}\n\t}\n}\n\nfunc (app *app) runCmdSync(cmd *exec.Cmd, pause_after bool) {\n\tapp.nav.previewChan <- \"\"\n\tapp.nav.dirPreviewChan <- nil\n\n\tif err := app.ui.suspend(); err != nil {\n\t\tlog.Printf(\"suspend: %s\", err)\n\t}\n\tdefer func() {\n\t\tif err := app.ui.resume(); err != nil {\n\t\t\tapp.quit()\n\t\t\tos.Exit(3)\n\t\t}\n\t}()\n\n\tif err := cmd.Run(); err != nil {\n\t\tapp.ui.echoerrf(\"running shell: %s\", err)\n\t}\n\tif pause_after {\n\t\tanyKey()\n\t}\n\n\tapp.ui.loadFile(app, true)\n\tapp.nav.renew()\n}\n\n// This function is used to run a shell command. Modes are as follows:\n//\n//\tPrefix  Wait  Async  Stdin  Stdout  Stderr  UI action\n//\t$       No    No     Yes    Yes     Yes     Pause and then resume\n//\t%       No    No     Yes    Yes     Yes     Statline for input/output\n//\t!       Yes   No     Yes    Yes     Yes     Pause and then resume\n//\t&       No    Yes    No     No      No      Do nothing\nfunc (app *app) runShell(s string, args []string, prefix string) {\n\tapp.nav.exportFiles()\n\tapp.ui.exportSizes()\n\tapp.ui.exportMode()\n\texportOpts()\n\n\tgState.mutex.Lock()\n\tgState.data[\"maps\"] = listBinds(gOpts.keys).String()\n\tgState.data[\"cmaps\"] = listBinds(gOpts.cmdkeys).String()\n\tgState.data[\"cmds\"] = listCmds().String()\n\tgState.data[\"jumps\"] = listJumps(app.nav.jumpList, app.nav.jumpListInd).String()\n\tgState.data[\"history\"] = listHistory(app.cmdHistory).String()\n\tgState.mutex.Unlock()\n\n\tcmd := shellCommand(s, args)\n\n\tvar out io.Reader\n\tvar err error\n\tswitch prefix {\n\tcase \"$\", \"!\":\n\t\tcmd.Stdin = os.Stdin\n\t\tcmd.Stdout = os.Stderr\n\t\tcmd.Stderr = os.Stderr\n\n\t\tapp.runCmdSync(cmd, prefix == \"!\")\n\t\treturn\n\t}\n\n\t// We are running the command asynchronously\n\tif prefix == \"%\" {\n\t\tif app.ui.cmdPrefix == \">\" {\n\t\t\treturn\n\t\t}\n\t\tstdin, err := cmd.StdinPipe()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"writing stdin: %s\", err)\n\t\t}\n\t\tapp.cmdIn = stdin\n\t\tstdout, err := cmd.StdoutPipe()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"reading stdout: %s\", err)\n\t\t}\n\t\tout = stdout\n\t\tcmd.Stderr = cmd.Stdout\n\t}\n\n\tshellSetPG(cmd)\n\tif err = cmd.Start(); err != nil {\n\t\tapp.ui.echoerrf(\"running shell: %s\", err)\n\t}\n\n\tswitch prefix {\n\tcase \"%\":\n\t\tnormal(app)\n\t\tapp.cmd = cmd\n\t\tapp.cmdOutBuf = nil\n\t\tapp.ui.msg = \"\"\n\t\tapp.ui.cmdPrefix = \">\"\n\n\t\tgo func() {\n\t\t\teol := false\n\t\t\treader := bufio.NewReader(out)\n\t\t\tfor {\n\t\t\t\tb, err := reader.ReadByte()\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif eol {\n\t\t\t\t\teol = false\n\t\t\t\t\tapp.cmdOutBuf = nil\n\t\t\t\t}\n\t\t\t\tapp.cmdOutBuf = append(app.cmdOutBuf, b)\n\t\t\t\tif b == '\\n' || b == '\\r' {\n\t\t\t\t\teol = true\n\t\t\t\t}\n\t\t\t\tif reader.Buffered() > 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tapp.ui.exprChan <- &callExpr{\"echo\", []string{string(app.cmdOutBuf)}, 1}\n\t\t\t}\n\n\t\t\tif err := cmd.Wait(); err != nil {\n\t\t\t\tlog.Printf(\"running shell: %s\", err)\n\t\t\t}\n\t\t\tapp.cmd = nil\n\t\t\tapp.ui.cmdPrefix = \"\"\n\t\t\tapp.ui.exprChan <- &callExpr{\"load\", nil, 1}\n\t\t}()\n\tcase \"&\":\n\t\tgo func() {\n\t\t\tif err := cmd.Wait(); err != nil {\n\t\t\t\tlog.Printf(\"running shell: %s\", err)\n\t\t\t}\n\t\t\tapp.ui.exprChan <- &callExpr{\"load\", nil, 1}\n\t\t}()\n\t}\n}\n\nfunc (app *app) setWatchPaths() {\n\tif !gOpts.watch || len(app.nav.dirs) == 0 {\n\t\treturn\n\t}\n\n\tpaths := make(map[string]bool)\n\tfor _, dir := range app.nav.dirs {\n\t\tpaths[dir.path] = true\n\t}\n\n\tfor _, file := range app.nav.currDir().allFiles {\n\t\tif file.IsDir() {\n\t\t\tpaths[file.path] = true\n\t\t}\n\t}\n\n\tapp.watch.set(paths)\n}\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 3.71875,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gdamore/tcell/v2\"\n)\n\ntype State struct {\n\tmutex sync.Mutex\n\tdata  map[string]string\n}\n\nvar gState State\n\nfunc init() {\n\tgState.data = make(map[string]string)\n}\n\nfunc run() {\n\tvar screen tcell.Screen\n\tvar err error\n\tif screen, err = tcell.NewScreen(); err != nil {\n\t\tlog.Fatalf(\"creating screen: %s\", err)\n\t} else if err = screen.Init(); err != nil {\n\t\tlog.Fatalf(\"initializing screen: %s\", err)\n\t}\n\tif gOpts.mouse {\n\t\tscreen.EnableMouse()\n\t}\n\n\tif gLogPath != \"\" {\n\t\tf, err := os.OpenFile(gLogPath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0o600)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tdefer f.Close()\n\t\tlog.SetOutput(f)\n\t} else {\n\t\tlog.SetOutput(io.Discard)\n\t}\n\n\tlog.Print(\"hi!\")\n\n\tui := newUI(screen)\n\tnav := newNav(ui.wins[0].h)\n\tapp := newApp(ui, nav)\n\n\tif err := nav.sync(); err != nil {\n\t\tapp.ui.echoerrf(\"sync: %s\", err)\n\t}\n\n\tif err := app.readHistory(); err != nil {\n\t\tapp.ui.echoerrf(\"reading history file: %s\", err)\n\t}\n\n\tapp.loop()\n\n\tapp.ui.screen.Fini()\n\n\tif gLastDirPath != \"\" {\n\t\twriteLastDir(gLastDirPath, app.nav.currDir().path)\n\t}\n\n\tif gSelectionPath != \"\" && len(app.selectionOut) > 0 {\n\t\twriteSelection(gSelectionPath, app.selectionOut)\n\t}\n\n\tif gPrintLastDir {\n\t\tfmt.Println(app.nav.currDir().path)\n\t}\n\n\tif gPrintSelection && len(app.selectionOut) > 0 {\n\t\tfor _, file := range app.selectionOut {\n\t\t\tfmt.Println(file)\n\t\t}\n\t}\n}\n\nfunc writeLastDir(filename string, lastDir string) {\n\tf, err := os.Create(filename)\n\tif err != nil {\n\t\tlog.Printf(\"opening last dir file: %s\", err)\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\t_, err = f.WriteString(lastDir)\n\tif err != nil {\n\t\tlog.Printf(\"writing last dir file: %s\", err)\n\t}\n}\n\nfunc writeSelection(filename string, selection []string) {\n\tf, err := os.Create(filename)\n\tif err != nil {\n\t\tlog.Printf(\"opening selection file: %s\", err)\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\t_, err = f.WriteString(strings.Join(selection, \"\\n\"))\n\tif err != nil {\n\t\tlog.Printf(\"writing selection file: %s\", err)\n\t}\n}\n\nfunc readExpr() <-chan expr {\n\tch := make(chan expr)\n\n\tgo func() {\n\t\tduration := 100 * time.Millisecond\n\n\t\tc, err := net.Dial(gSocketProt, gSocketPath)\n\t\tfor err != nil {\n\t\t\tlog.Printf(\"connecting server: %s\", err)\n\t\t\ttime.Sleep(duration)\n\t\t\tduration *= 2\n\t\t\tc, err = net.Dial(gSocketProt, gSocketPath)\n\t\t}\n\n\t\tfmt.Fprintf(c, \"conn %d\\n\", gClientID)\n\n\t\tch <- &callExpr{\"sync\", nil, 1}\n\t\tch <- &callExpr{\"on-init\", nil, 1}\n\n\t\ts := bufio.NewScanner(c)\n\t\tfor s.Scan() {\n\t\t\tlog.Printf(\"recv: %s\", s.Text())\n\n\t\t\t// `query` has to be handled outside of the main thread, which is\n\t\t\t// blocked when running a synchronous shell command (\"$\" or \"!\").\n\t\t\t// This is important since `query` is often the result of the user\n\t\t\t// running `$lf -remote \"query $id <something>\"`.\n\t\t\tif word, rest := splitWord(s.Text()); word == \"query\" {\n\t\t\t\tgState.mutex.Lock()\n\t\t\t\tstate, ok := gState.data[rest]\n\t\t\t\tgState.mutex.Unlock()\n\t\t\t\tif ok {\n\t\t\t\t\tfmt.Fprint(c, state)\n\t\t\t\t}\n\t\t\t\tfmt.Fprintln(c, \"\")\n\t\t\t} else {\n\t\t\t\tp := newParser(strings.NewReader(s.Text()))\n\t\t\t\tif p.parse() {\n\t\t\t\t\tch <- p.expr\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tc.Close()\n\t}()\n\n\treturn ch\n}\n\nfunc remote(cmd string) error {\n\tc, err := net.Dial(gSocketProt, gSocketPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"dialing to send server: %s\", err)\n\t}\n\n\tfmt.Fprintln(c, cmd)\n\n\t// XXX: Standard net.Conn interface does not include a CloseWrite method\n\t// but net.UnixConn and net.TCPConn implement it so the following should be\n\t// safe as long as we do not use other types of connections. We need\n\t// CloseWrite to notify the server that this is not a persistent connection\n\t// and it should be closed after the response.\n\tif v, ok := c.(interface {\n\t\tCloseWrite() error\n\t}); ok {\n\t\tv.CloseWrite()\n\t}\n\n\tio.Copy(os.Stdout, c)\n\n\tc.Close()\n\n\treturn nil\n}\n"
        },
        {
          "name": "colors.go",
          "type": "blob",
          "size": 7.353515625,
          "content": "package main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/gdamore/tcell/v2\"\n)\n\ntype styleMap struct {\n\tstyles        map[string]tcell.Style\n\tuseLinkTarget bool\n}\n\nfunc parseStyles() styleMap {\n\tsm := styleMap{\n\t\tstyles:        make(map[string]tcell.Style),\n\t\tuseLinkTarget: false,\n\t}\n\n\t// Default values from dircolors\n\t//\n\t// no*  NORMAL                 00\n\t// fi   FILE                   00\n\t// rs*  RESET                  0\n\t// di   DIR                    01;34\n\t// ln   LINK                   01;36\n\t// mh*  MULTIHARDLINK          00\n\t// pi   FIFO                   40;33\n\t// so   SOCK                   01;35\n\t// do*  DOOR                   01;35\n\t// bd   BLK                    40;33;01\n\t// cd   CHR                    40;33;01\n\t// or   ORPHAN                 40;31;01\n\t// mi*  MISSING                00\n\t// su   SETUID                 37;41\n\t// sg   SETGID                 30;43\n\t// ca*  CAPABILITY             30;41\n\t// tw   STICKY_OTHER_WRITABLE  30;42\n\t// ow   OTHER_WRITABLE         34;42\n\t// st   STICKY                 37;44\n\t// ex   EXEC                   01;32\n\t//\n\t// (Entries marked with * are not implemented in lf)\n\n\t// default values from dircolors with background colors removed\n\tdefaultColors := []string{\n\t\t\"fi=00\",\n\t\t\"di=01;34\",\n\t\t\"ln=01;36\",\n\t\t\"pi=33\",\n\t\t\"so=01;35\",\n\t\t\"bd=33;01\",\n\t\t\"cd=33;01\",\n\t\t\"or=31;01\",\n\t\t\"su=01;32\",\n\t\t\"sg=01;32\",\n\t\t\"tw=01;34\",\n\t\t\"ow=01;34\",\n\t\t\"st=01;34\",\n\t\t\"ex=01;32\",\n\t}\n\n\tsm.parseGNU(strings.Join(defaultColors, \":\"))\n\n\tif env := os.Getenv(\"LSCOLORS\"); env != \"\" {\n\t\tsm.parseBSD(env)\n\t}\n\n\tif env := os.Getenv(\"LS_COLORS\"); env != \"\" {\n\t\tsm.parseGNU(env)\n\t}\n\n\tif env := os.Getenv(\"LF_COLORS\"); env != \"\" {\n\t\tsm.parseGNU(env)\n\t}\n\n\tfor _, path := range gColorsPaths {\n\t\tif _, err := os.Stat(path); !os.IsNotExist(err) {\n\t\t\tsm.parseFile(path)\n\t\t}\n\t}\n\n\treturn sm\n}\n\nfunc parseEscapeSequence(s string) tcell.Style {\n\ts = strings.TrimPrefix(s, \"\\033[\")\n\tif i := strings.IndexByte(s, 'm'); i >= 0 {\n\t\ts = s[:i]\n\t}\n\treturn applyAnsiCodes(s, tcell.StyleDefault)\n}\n\nfunc applyAnsiCodes(s string, st tcell.Style) tcell.Style {\n\ttoks := strings.Split(s, \";\")\n\n\tnums := make([]int, 0, len(toks))\n\tfor _, tok := range toks {\n\t\tif tok == \"\" {\n\t\t\tnums = append(nums, 0)\n\t\t\tcontinue\n\t\t}\n\t\tn, err := strconv.Atoi(tok)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"converting escape code: %s\", err)\n\t\t\tcontinue\n\t\t}\n\t\tnums = append(nums, n)\n\t}\n\n\t// ECMA-48 details the standard\n\t// TODO: should we support turning off attributes?\n\t//    Probably because this is used for previewers too\n\tnumslen := len(nums)\n\tfor i := 0; i < numslen; i++ {\n\t\tn := nums[i]\n\t\tswitch {\n\t\tcase n == 0:\n\t\t\tst = tcell.StyleDefault\n\t\tcase n == 1:\n\t\t\tst = st.Bold(true)\n\t\tcase n == 2:\n\t\t\tst = st.Dim(true)\n\t\tcase n == 3:\n\t\t\tst = st.Italic(true)\n\t\tcase n == 4:\n\t\t\tst = st.Underline(true)\n\t\tcase n == 5 || n == 6:\n\t\t\tst = st.Blink(true)\n\t\tcase n == 7:\n\t\t\tst = st.Reverse(true)\n\t\tcase n == 8:\n\t\t\t// TODO: tcell PR for proper conceal\n\t\t\t_, bg, _ := st.Decompose()\n\t\t\tst = st.Foreground(bg)\n\t\tcase n == 9:\n\t\t\tst = st.StrikeThrough(true)\n\t\tcase n >= 30 && n <= 37:\n\t\t\tst = st.Foreground(tcell.PaletteColor(n - 30))\n\t\tcase n >= 90 && n <= 97:\n\t\t\tst = st.Foreground(tcell.PaletteColor(n - 82))\n\t\tcase n == 38:\n\t\t\tif i+3 <= numslen && nums[i+1] == 5 {\n\t\t\t\tst = st.Foreground(tcell.PaletteColor(nums[i+2]))\n\t\t\t\ti += 2\n\t\t\t} else if i+5 <= numslen && nums[i+1] == 2 {\n\t\t\t\tst = st.Foreground(tcell.NewRGBColor(\n\t\t\t\t\tint32(nums[i+2]),\n\t\t\t\t\tint32(nums[i+3]),\n\t\t\t\t\tint32(nums[i+4])))\n\t\t\t\ti += 4\n\t\t\t} else {\n\t\t\t\tlog.Printf(\"unknown ansi code or incorrect form: %d\", n)\n\t\t\t}\n\t\tcase n >= 40 && n <= 47:\n\t\t\tst = st.Background(tcell.PaletteColor(n - 40))\n\t\tcase n >= 100 && n <= 107:\n\t\t\tst = st.Background(tcell.PaletteColor(n - 92))\n\t\tcase n == 48:\n\t\t\tif i+3 <= numslen && nums[i+1] == 5 {\n\t\t\t\tst = st.Background(tcell.PaletteColor(nums[i+2]))\n\t\t\t\ti += 2\n\t\t\t} else if i+5 <= numslen && nums[i+1] == 2 {\n\t\t\t\tst = st.Background(tcell.NewRGBColor(\n\t\t\t\t\tint32(nums[i+2]),\n\t\t\t\t\tint32(nums[i+3]),\n\t\t\t\t\tint32(nums[i+4])))\n\t\t\t\ti += 4\n\t\t\t} else {\n\t\t\t\tlog.Printf(\"unknown ansi code or incorrect form: %d\", n)\n\t\t\t}\n\t\tdefault:\n\t\t\tlog.Printf(\"unknown ansi code: %d\", n)\n\t\t}\n\t}\n\n\treturn st\n}\n\nfunc (sm styleMap) parseFile(path string) {\n\tlog.Printf(\"reading file: %s\", path)\n\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\tlog.Printf(\"opening colors file: %s\", err)\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\tpairs, err := readPairs(f)\n\tif err != nil {\n\t\tlog.Printf(\"reading colors file: %s\", err)\n\t\treturn\n\t}\n\n\tfor _, pair := range pairs {\n\t\tsm.parsePair(pair)\n\t}\n}\n\n// This function parses $LS_COLORS environment variable.\nfunc (sm *styleMap) parseGNU(env string) {\n\tfor _, entry := range strings.Split(env, \":\") {\n\t\tif entry == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tpair := strings.Split(entry, \"=\")\n\n\t\tif len(pair) != 2 {\n\t\t\tlog.Printf(\"invalid $LS_COLORS entry: %s\", entry)\n\t\t\treturn\n\t\t}\n\n\t\tsm.parsePair(pair)\n\t}\n}\n\nfunc (sm *styleMap) parsePair(pair []string) {\n\tkey, val := pair[0], pair[1]\n\n\tkey = replaceTilde(key)\n\n\tif filepath.IsAbs(key) {\n\t\tkey = filepath.Clean(key)\n\t}\n\n\tif key == \"ln\" && val == \"target\" {\n\t\tsm.useLinkTarget = true\n\t}\n\n\tsm.styles[key] = applyAnsiCodes(val, tcell.StyleDefault)\n}\n\n// This function parses $LSCOLORS environment variable.\nfunc (sm styleMap) parseBSD(env string) {\n\tif len(env) != 22 {\n\t\tlog.Printf(\"invalid $LSCOLORS variable: %s\", env)\n\t\treturn\n\t}\n\n\tcolorNames := []string{\"di\", \"ln\", \"so\", \"pi\", \"ex\", \"bd\", \"cd\", \"su\", \"sg\", \"tw\", \"ow\"}\n\n\tgetStyle := func(r1, r2 byte) tcell.Style {\n\t\tst := tcell.StyleDefault\n\n\t\tswitch {\n\t\tcase r1 == 'x':\n\t\t\tst = st.Foreground(tcell.ColorDefault)\n\t\tcase 'A' <= r1 && r1 <= 'H':\n\t\t\tst = st.Foreground(tcell.PaletteColor(int(r1 - 'A'))).Bold(true)\n\t\tcase 'a' <= r1 && r1 <= 'h':\n\t\t\tst = st.Foreground(tcell.PaletteColor(int(r1 - 'a')))\n\t\tdefault:\n\t\t\tlog.Printf(\"invalid $LSCOLORS entry: %c\", r1)\n\t\t\treturn tcell.StyleDefault\n\t\t}\n\n\t\tswitch {\n\t\tcase r2 == 'x':\n\t\t\tst = st.Background(tcell.ColorDefault)\n\t\tcase 'a' <= r2 && r2 <= 'h':\n\t\t\tst = st.Background(tcell.PaletteColor(int(r2 - 'a')))\n\t\tdefault:\n\t\t\tlog.Printf(\"invalid $LSCOLORS entry: %c\", r2)\n\t\t\treturn tcell.StyleDefault\n\t\t}\n\n\t\treturn st\n\t}\n\n\tfor i, key := range colorNames {\n\t\tsm.styles[key] = getStyle(env[i*2], env[i*2+1])\n\t}\n}\n\nfunc (sm styleMap) get(f *file) tcell.Style {\n\tif val, ok := sm.styles[f.path]; ok {\n\t\treturn val\n\t}\n\n\tif f.IsDir() {\n\t\tif val, ok := sm.styles[f.Name()+\"/\"]; ok {\n\t\t\treturn val\n\t\t}\n\t}\n\n\tvar key string\n\n\tswitch {\n\tcase f.linkState == working && !sm.useLinkTarget:\n\t\tkey = \"ln\"\n\tcase f.linkState == broken:\n\t\tkey = \"or\"\n\tcase f.IsDir() && f.Mode()&os.ModeSticky != 0 && f.Mode()&0o002 != 0:\n\t\tkey = \"tw\"\n\tcase f.IsDir() && f.Mode()&0o002 != 0:\n\t\tkey = \"ow\"\n\tcase f.IsDir() && f.Mode()&os.ModeSticky != 0:\n\t\tkey = \"st\"\n\tcase f.IsDir():\n\t\tkey = \"di\"\n\tcase f.Mode()&os.ModeNamedPipe != 0:\n\t\tkey = \"pi\"\n\tcase f.Mode()&os.ModeSocket != 0:\n\t\tkey = \"so\"\n\tcase f.Mode()&os.ModeCharDevice != 0:\n\t\tkey = \"cd\"\n\tcase f.Mode()&os.ModeDevice != 0:\n\t\tkey = \"bd\"\n\tcase f.Mode()&os.ModeSetuid != 0:\n\t\tkey = \"su\"\n\tcase f.Mode()&os.ModeSetgid != 0:\n\t\tkey = \"sg\"\n\tcase f.Mode()&0o111 != 0:\n\t\tkey = \"ex\"\n\t}\n\n\tif val, ok := sm.styles[key]; ok {\n\t\treturn val\n\t}\n\n\tif val, ok := sm.styles[f.Name()+\"*\"]; ok {\n\t\treturn val\n\t}\n\n\tif val, ok := sm.styles[\"*\"+f.Name()]; ok {\n\t\treturn val\n\t}\n\n\tif val, ok := sm.styles[filepath.Base(f.Name())+\".*\"]; ok {\n\t\treturn val\n\t}\n\n\tif val, ok := sm.styles[\"*\"+strings.ToLower(f.ext)]; ok {\n\t\treturn val\n\t}\n\n\tif val, ok := sm.styles[\"fi\"]; ok {\n\t\treturn val\n\t}\n\n\treturn tcell.StyleDefault\n}\n"
        },
        {
          "name": "colors_test.go",
          "type": "blob",
          "size": 3.16015625,
          "content": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/gdamore/tcell/v2\"\n)\n\nfunc TestApplyAnsiCodes(t *testing.T) {\n\tnone := tcell.StyleDefault\n\n\ttests := []struct {\n\t\ts     string\n\t\tst    tcell.Style\n\t\tstExp tcell.Style\n\t}{\n\t\t{\"\", none, none},\n\t\t{\"\", none.Foreground(tcell.ColorMaroon).Background(tcell.ColorMaroon), none},\n\t\t{\"\", none.Bold(true), none},\n\t\t{\"\", none.Foreground(tcell.ColorMaroon).Bold(true), none},\n\n\t\t{\"0\", none, none},\n\t\t{\"0\", none.Foreground(tcell.ColorMaroon).Background(tcell.ColorMaroon), none},\n\t\t{\"0\", none.Bold(true), none},\n\t\t{\"0\", none.Foreground(tcell.ColorMaroon).Bold(true), none},\n\n\t\t{\"1\", none, none.Bold(true)},\n\t\t{\"4\", none, none.Underline(true)},\n\t\t{\"7\", none, none.Reverse(true)},\n\n\t\t{\"1\", none.Foreground(tcell.ColorMaroon), none.Foreground(tcell.ColorMaroon).Bold(true)},\n\t\t{\"4\", none.Foreground(tcell.ColorMaroon), none.Foreground(tcell.ColorMaroon).Underline(true)},\n\t\t{\"7\", none.Foreground(tcell.ColorMaroon), none.Foreground(tcell.ColorMaroon).Reverse(true)},\n\n\t\t{\"4\", none.Bold(true), none.Bold(true).Underline(true)},\n\t\t{\"4\", none.Foreground(tcell.ColorMaroon).Bold(true), none.Foreground(tcell.ColorMaroon).Bold(true).Underline(true)},\n\n\t\t{\"31\", none, none.Foreground(tcell.ColorMaroon)},\n\t\t{\"31\", none.Foreground(tcell.ColorGreen), none.Foreground(tcell.ColorMaroon)},\n\t\t{\"31\", none.Foreground(tcell.ColorGreen).Bold(true), none.Foreground(tcell.ColorMaroon).Bold(true)},\n\n\t\t{\"41\", none, none.Background(tcell.ColorMaroon)},\n\t\t{\"41\", none.Background(tcell.ColorGreen), none.Background(tcell.ColorMaroon)},\n\n\t\t{\"1;31\", none, none.Foreground(tcell.ColorMaroon).Bold(true)},\n\t\t{\"1;31\", none.Foreground(tcell.ColorGreen), none.Foreground(tcell.ColorMaroon).Bold(true)},\n\n\t\t{\"38;5;0\", none, none.Foreground(tcell.ColorBlack)},\n\t\t{\"38;5;1\", none, none.Foreground(tcell.ColorMaroon)},\n\t\t{\"38;5;8\", none, none.Foreground(tcell.ColorGray)},\n\t\t{\"38;5;16\", none, none.Foreground(tcell.Color16)},\n\t\t{\"38;5;232\", none, none.Foreground(tcell.Color232)},\n\n\t\t{\"38;5;1\", none.Foreground(tcell.ColorGreen), none.Foreground(tcell.ColorMaroon)},\n\t\t{\"38;5;1\", none.Foreground(tcell.ColorGreen).Bold(true), none.Foreground(tcell.ColorMaroon).Bold(true)},\n\n\t\t{\"48;5;0\", none, none.Background(tcell.ColorBlack)},\n\t\t{\"48;5;1\", none, none.Background(tcell.ColorMaroon)},\n\t\t{\"48;5;8\", none, none.Background(tcell.ColorGray)},\n\t\t{\"48;5;16\", none, none.Background(tcell.Color16)},\n\t\t{\"48;5;232\", none, none.Background(tcell.Color232)},\n\n\t\t{\"48;5;1\", none.Background(tcell.ColorGreen), none.Background(tcell.ColorMaroon)},\n\n\t\t{\"1;38;5;1\", none, none.Foreground(tcell.ColorMaroon).Bold(true)},\n\t\t{\"1;38;5;1\", none.Foreground(tcell.ColorGreen), none.Foreground(tcell.ColorMaroon).Bold(true)},\n\n\t\t{\"38;2;5;102;8\", none, none.Foreground(tcell.NewRGBColor(5, 102, 8))},\n\t\t{\"48;2;0;48;143\", none, none.Background(tcell.NewRGBColor(0, 48, 143))},\n\n\t\t// Fixes color construction issue: https://github.com/gokcehan/lf/pull/439#issuecomment-674409446\n\t\t{\"38;5;34;1\", none, none.Foreground(tcell.Color34).Bold(true)},\n\t}\n\n\tfor _, test := range tests {\n\t\tif stGot := applyAnsiCodes(test.s, test.st); stGot != test.stExp {\n\t\t\tt.Errorf(\"at input '%s' with '%v' expected '%v' but got '%v'\",\n\t\t\t\ttest.s, test.st, test.stExp, stGot)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "complete.go",
          "type": "blob",
          "size": 7.705078125,
          "content": "package main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n)\n\nvar (\n\tgCmdWords = []string{\n\t\t\"set\",\n\t\t\"setlocal\",\n\t\t\"map\",\n\t\t\"cmap\",\n\t\t\"cmd\",\n\t\t\"quit\",\n\t\t\"up\",\n\t\t\"half-up\",\n\t\t\"page-up\",\n\t\t\"scroll-up\",\n\t\t\"down\",\n\t\t\"half-down\",\n\t\t\"page-down\",\n\t\t\"scroll-down\",\n\t\t\"updir\",\n\t\t\"open\",\n\t\t\"jump-next\",\n\t\t\"jump-prev\",\n\t\t\"top\",\n\t\t\"bottom\",\n\t\t\"high\",\n\t\t\"middle\",\n\t\t\"low\",\n\t\t\"toggle\",\n\t\t\"invert\",\n\t\t\"invert-below\",\n\t\t\"unselect\",\n\t\t\"glob-select\",\n\t\t\"glob-unselect\",\n\t\t\"calcdirsize\",\n\t\t\"clearmaps\",\n\t\t\"copy\",\n\t\t\"cut\",\n\t\t\"paste\",\n\t\t\"clear\",\n\t\t\"sync\",\n\t\t\"draw\",\n\t\t\"redraw\",\n\t\t\"load\",\n\t\t\"reload\",\n\t\t\"echo\",\n\t\t\"echomsg\",\n\t\t\"echoerr\",\n\t\t\"cd\",\n\t\t\"select\",\n\t\t\"delete\",\n\t\t\"rename\",\n\t\t\"source\",\n\t\t\"push\",\n\t\t\"read\",\n\t\t\"shell\",\n\t\t\"shell-pipe\",\n\t\t\"shell-wait\",\n\t\t\"shell-async\",\n\t\t\"find\",\n\t\t\"find-back\",\n\t\t\"find-next\",\n\t\t\"find-prev\",\n\t\t\"search\",\n\t\t\"search-back\",\n\t\t\"search-next\",\n\t\t\"search-prev\",\n\t\t\"filter\",\n\t\t\"setfilter\",\n\t\t\"mark-save\",\n\t\t\"mark-load\",\n\t\t\"mark-remove\",\n\t\t\"tag\",\n\t\t\"tag-toggle\",\n\t\t\"cmd-escape\",\n\t\t\"cmd-complete\",\n\t\t\"cmd-menu-complete\",\n\t\t\"cmd-menu-complete-back\",\n\t\t\"cmd-menu-accept\",\n\t\t\"cmd-enter\",\n\t\t\"cmd-interrupt\",\n\t\t\"cmd-history-next\",\n\t\t\"cmd-history-prev\",\n\t\t\"cmd-left\",\n\t\t\"cmd-right\",\n\t\t\"cmd-home\",\n\t\t\"cmd-end\",\n\t\t\"cmd-delete\",\n\t\t\"cmd-delete-back\",\n\t\t\"cmd-delete-home\",\n\t\t\"cmd-delete-end\",\n\t\t\"cmd-delete-unix-word\",\n\t\t\"cmd-yank\",\n\t\t\"cmd-transpose\",\n\t\t\"cmd-transpose-word\",\n\t\t\"cmd-word\",\n\t\t\"cmd-word-back\",\n\t\t\"cmd-delete-word\",\n\t\t\"cmd-delete-word-back\",\n\t\t\"cmd-capitalize-word\",\n\t\t\"cmd-uppercase-word\",\n\t\t\"cmd-lowercase-word\",\n\t}\n\n\tgOptWords      = getOptWords(gOpts)\n\tgLocalOptWords = getLocalOptWords(gLocalOpts)\n)\n\nfunc getOptWords(opts any) (optWords []string) {\n\tt := reflect.TypeOf(opts)\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tfield := t.Field(i)\n\t\tswitch field.Type.Kind() {\n\t\tcase reflect.Map:\n\t\t\tcontinue\n\t\tcase reflect.Bool:\n\t\t\tname := field.Name\n\t\t\toptWords = append(optWords, name, \"no\"+name, name+\"!\")\n\t\tdefault:\n\t\t\toptWords = append(optWords, field.Name)\n\t\t}\n\t}\n\tsort.Strings(optWords)\n\treturn\n}\n\nfunc getLocalOptWords(localOpts any) (localOptWords []string) {\n\tt := reflect.TypeOf(localOpts)\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tfield := t.Field(i)\n\t\tname := strings.TrimSuffix(field.Name, \"s\")\n\t\tif field.Type.Kind() != reflect.Map {\n\t\t\tcontinue\n\t\t}\n\t\tif field.Type.Elem().Kind() == reflect.Bool {\n\t\t\tlocalOptWords = append(localOptWords, name, \"no\"+name, name+\"!\")\n\t\t} else {\n\t\t\tlocalOptWords = append(localOptWords, name)\n\t\t}\n\t}\n\tsort.Strings(localOptWords)\n\treturn\n}\n\nfunc matchLongest(s1, s2 []rune) []rune {\n\ti := 0\n\tfor ; i < len(s1) && i < len(s2); i++ {\n\t\tif s1[i] != s2[i] {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn s1[:i]\n}\n\nfunc matchWord(s string, words []string) (matches []string, longest []rune) {\n\tfor _, w := range words {\n\t\tif !strings.HasPrefix(w, s) {\n\t\t\tcontinue\n\t\t}\n\n\t\tmatches = append(matches, w)\n\t\tif len(longest) != 0 {\n\t\t\tlongest = matchLongest(longest, []rune(w))\n\t\t} else if s != \"\" {\n\t\t\tlongest = []rune(w + \" \")\n\t\t}\n\t}\n\n\tif len(longest) == 0 {\n\t\tlongest = []rune(s)\n\t}\n\n\treturn\n}\n\nfunc matchExec(s string) (matches []string, longest []rune) {\n\tvar words []string\n\n\tpaths := strings.Split(envPath, string(filepath.ListSeparator))\n\n\tfor _, p := range paths {\n\t\tif _, err := os.Stat(p); os.IsNotExist(err) {\n\t\t\tcontinue\n\t\t}\n\n\t\tfiles, err := os.ReadDir(p)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"reading path: %s\", err)\n\t\t}\n\n\t\tfor _, f := range files {\n\t\t\tif !strings.HasPrefix(f.Name(), s) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfinfo, err := f.Info()\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"getting file information: %s\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !finfo.Mode().IsRegular() || !isExecutable(finfo) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\twords = append(words, finfo.Name())\n\t\t}\n\t}\n\n\tif len(words) > 0 {\n\t\tsort.Strings(words)\n\n\t\tuniq := words[:1]\n\t\tfor i := 1; i < len(words); i++ {\n\t\t\tif words[i] != words[i-1] {\n\t\t\t\tuniq = append(uniq, words[i])\n\t\t\t}\n\t\t}\n\t\twords = uniq\n\t}\n\n\treturn matchWord(s, words)\n}\n\nfunc matchFile(s string) (matches []string, longest []rune) {\n\tdir := replaceTilde(s)\n\n\tif !filepath.IsAbs(dir) {\n\t\twd, err := os.Getwd()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"getting current directory: %s\", err)\n\t\t} else {\n\t\t\tdir = wd + string(filepath.Separator) + dir\n\t\t}\n\t}\n\n\tdir = filepath.Dir(unescape(dir))\n\n\tfiles, err := os.ReadDir(dir)\n\tif err != nil {\n\t\tlog.Printf(\"reading directory: %s\", err)\n\t}\n\n\tfor _, f := range files {\n\t\tname := filepath.Join(dir, f.Name())\n\t\tf, err := os.Lstat(name)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"getting file information: %s\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tname = strings.ToLower(escape(f.Name()))\n\t\t_, last := filepath.Split(s)\n\t\tif !strings.HasPrefix(name, strings.ToLower(last)) {\n\t\t\tcontinue\n\t\t}\n\n\t\tname = f.Name()\n\t\tif isRoot(s) || filepath.Base(s) != s {\n\t\t\tname = filepath.Join(filepath.Dir(unescape(s)), f.Name())\n\t\t}\n\t\tname = escape(replaceTilde(name))\n\n\t\titem := f.Name()\n\t\tif f.Mode().IsDir() {\n\t\t\titem += escape(string(filepath.Separator))\n\t\t}\n\t\tmatches = append(matches, item)\n\n\t\tif longest == nil {\n\t\t\tif f.Mode().IsRegular() {\n\t\t\t\tlongest = []rune(name + \" \")\n\t\t\t} else {\n\t\t\t\tlongest = []rune(name + escape(string(filepath.Separator)))\n\t\t\t}\n\t\t} else {\n\t\t\tlongest = matchLongest(longest, []rune(name))\n\t\t}\n\t}\n\n\tif len(longest) < len([]rune(s)) {\n\t\tlongest = []rune(s)\n\t}\n\n\treturn\n}\n\nfunc matchCmd(s string) (matches []string, longest []rune) {\n\twords := make([]string, 0, len(gCmdWords)+len(gOpts.cmds))\n\twords = append(words, gCmdWords...)\n\tfor c := range gOpts.cmds {\n\t\twords = append(words, c)\n\t}\n\tsort.Strings(words)\n\tj := 0\n\tfor i := 1; i < len(words); i++ {\n\t\tif words[j] == words[i] {\n\t\t\tcontinue\n\t\t}\n\t\tj++\n\t\twords[i], words[j] = words[j], words[i]\n\t}\n\twords = words[:j+1]\n\tmatches, longest = matchWord(s, words)\n\treturn\n}\n\nfunc completeCmd(acc []rune) (matches []string, longestAcc []rune) {\n\ts := string(acc)\n\tf := tokenize(s)\n\n\tvar longest []rune\n\n\tswitch len(f) {\n\tcase 1:\n\t\tmatches, longestAcc = matchCmd(s)\n\tcase 2:\n\t\tswitch f[0] {\n\t\tcase \"set\":\n\t\t\tmatches, longest = matchWord(f[1], gOptWords)\n\t\t\tlongestAcc = append(acc[:len(acc)-len([]rune(f[len(f)-1]))], longest...)\n\t\tcase \"map\", \"cmap\", \"cmd\":\n\t\t\tlongestAcc = acc\n\t\tdefault:\n\t\t\tmatches, longest = matchFile(f[len(f)-1])\n\t\t\tlongestAcc = append(acc[:len(acc)-len([]rune(f[len(f)-1]))], longest...)\n\t\t}\n\tcase 3:\n\t\tswitch f[0] {\n\t\tcase \"setlocal\":\n\t\t\tmatches, longest = matchWord(f[2], gLocalOptWords)\n\t\t\tlongestAcc = append(acc[:len(acc)-len([]rune(f[len(f)-1]))], longest...)\n\t\tcase \"map\", \"cmap\":\n\t\t\tmatches, longest = matchCmd(f[2])\n\t\t\tlongestAcc = append(acc[:len(acc)-len([]rune(f[len(f)-1]))], longest...)\n\t\tdefault:\n\t\t\tmatches, longest = matchFile(f[len(f)-1])\n\t\t\tlongestAcc = append(acc[:len(acc)-len([]rune(f[len(f)-1]))], longest...)\n\t\t}\n\tdefault:\n\t\tswitch f[0] {\n\t\tcase \"set\", \"setlocal\", \"map\", \"cmap\", \"cmd\":\n\t\t\tlongestAcc = acc\n\t\tdefault:\n\t\t\tmatches, longest = matchFile(f[len(f)-1])\n\t\t\tlongestAcc = append(acc[:len(acc)-len([]rune(f[len(f)-1]))], longest...)\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc completeFile(acc []rune) (matches []string, longestAcc []rune) {\n\ts := string(acc)\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tlog.Printf(\"getting current directory: %s\", err)\n\t}\n\n\tfiles, err := os.ReadDir(wd)\n\tif err != nil {\n\t\tlog.Printf(\"reading directory: %s\", err)\n\t}\n\n\tfor _, f := range files {\n\t\tif !strings.HasPrefix(strings.ToLower(f.Name()), strings.ToLower(s)) {\n\t\t\tcontinue\n\t\t}\n\n\t\tmatches = append(matches, f.Name())\n\n\t\tif longestAcc == nil {\n\t\t\tlongestAcc = []rune(f.Name())\n\t\t} else {\n\t\t\tlongestAcc = matchLongest(longestAcc, []rune(f.Name()))\n\t\t}\n\t}\n\n\tif len(longestAcc) < len(acc) {\n\t\tlongestAcc = acc\n\t}\n\n\treturn\n}\n\nfunc completeShell(acc []rune) (matches []string, longestAcc []rune) {\n\ts := string(acc)\n\tf := tokenize(s)\n\n\tvar longest []rune\n\n\tswitch len(f) {\n\tcase 1:\n\t\tmatches, longestAcc = matchExec(s)\n\tdefault:\n\t\tmatches, longest = matchFile(f[len(f)-1])\n\t\tlongestAcc = append(acc[:len(acc)-len([]rune(f[len(f)-1]))], longest...)\n\t}\n\n\treturn\n}\n"
        },
        {
          "name": "complete_test.go",
          "type": "blob",
          "size": 2.447265625,
          "content": "package main\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMatchLongest(t *testing.T) {\n\ttests := []struct {\n\t\ts1  string\n\t\ts2  string\n\t\texp string\n\t}{\n\t\t{\"\", \"\", \"\"},\n\t\t{\"\", \"foo\", \"\"},\n\t\t{\"foo\", \"\", \"\"},\n\t\t{\"foo\", \"bar\", \"\"},\n\t\t{\"foo\", \"foobar\", \"foo\"},\n\t\t{\"foo\", \"barfoo\", \"\"},\n\t\t{\"foobar\", \"foobaz\", \"fooba\"},\n\t\t{\"год\", \"гол\", \"го\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tif got := string(matchLongest([]rune(test.s1), []rune(test.s2))); got != test.exp {\n\t\t\tt.Errorf(\"at input '%s' and '%s' expected '%s' but got '%s'\", test.s1, test.s2, test.exp, got)\n\t\t}\n\t}\n}\n\nfunc TestMatchWord(t *testing.T) {\n\ttests := []struct {\n\t\ts       string\n\t\twords   []string\n\t\tmatches []string\n\t\tlongest string\n\t}{\n\t\t{\"\", nil, nil, \"\"},\n\t\t{\"\", []string{\"foo\", \"bar\", \"baz\"}, []string{\"foo\", \"bar\", \"baz\"}, \"\"},\n\t\t{\"fo\", []string{\"foo\", \"bar\", \"baz\"}, []string{\"foo\"}, \"foo \"},\n\t\t{\"ba\", []string{\"foo\", \"bar\", \"baz\"}, []string{\"bar\", \"baz\"}, \"ba\"},\n\t\t{\"fo\", []string{\"bar\", \"baz\"}, nil, \"fo\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tm, l := matchWord(test.s, test.words)\n\n\t\tif !reflect.DeepEqual(m, test.matches) {\n\t\t\tt.Errorf(\"at input '%s' with '%s' expected '%s' but got '%s'\", test.s, test.words, test.matches, m)\n\t\t}\n\n\t\tif ls := string(l); ls != test.longest {\n\t\t\tt.Errorf(\"at input '%s' with '%s' expected '%s' but got '%s'\", test.s, test.words, test.longest, ls)\n\t\t}\n\t}\n}\n\nfunc TestGetOptWords(t *testing.T) {\n\ttests := []struct {\n\t\topts any\n\t\texp  []string\n\t}{\n\t\t{struct{ feature bool }{}, []string{\"feature\", \"feature!\", \"nofeature\"}},\n\t\t{struct{ feature int }{}, []string{\"feature\"}},\n\t\t{struct{ feature string }{}, []string{\"feature\"}},\n\t\t{struct{ feature []string }{}, []string{\"feature\"}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := getOptWords(test.opts)\n\t\tif !reflect.DeepEqual(result, test.exp) {\n\t\t\tt.Errorf(\"at input '%#v' expected '%s' but got '%s'\", test.opts, test.exp, result)\n\t\t}\n\t}\n}\n\nfunc TestGetLocalOptWords(t *testing.T) {\n\ttests := []struct {\n\t\tlocalOpts any\n\t\texp       []string\n\t}{\n\t\t{struct{ features map[string]bool }{}, []string{\"feature\", \"feature!\", \"nofeature\"}},\n\t\t{struct{ features map[string]int }{}, []string{\"feature\"}},\n\t\t{struct{ features map[string]string }{}, []string{\"feature\"}},\n\t\t{struct{ features map[string][]string }{}, []string{\"feature\"}},\n\t}\n\n\tfor _, test := range tests {\n\t\tresult := getLocalOptWords(test.localOpts)\n\t\tif !reflect.DeepEqual(result, test.exp) {\n\t\t\tt.Errorf(\"at input '%#v' expected '%s' but got '%s'\", test.localOpts, test.exp, result)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "copy.go",
          "type": "blob",
          "size": 3.56640625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/djherbis/times\"\n)\n\ntype ProgressWriter struct {\n\twriter io.Writer\n\tnums   chan<- int64\n}\n\nfunc NewProgressWriter(writer io.Writer, nums chan<- int64) *ProgressWriter {\n\treturn &ProgressWriter{\n\t\twriter: writer,\n\t\tnums:   nums,\n\t}\n}\n\nfunc (progressWriter *ProgressWriter) Write(b []byte) (int, error) {\n\tn, err := progressWriter.writer.Write(b)\n\tprogressWriter.nums <- int64(n)\n\treturn n, err\n}\n\nfunc copySize(srcs []string) (int64, error) {\n\tvar total int64\n\n\tfor _, src := range srcs {\n\t\t_, err := os.Lstat(src)\n\t\tif os.IsNotExist(err) {\n\t\t\treturn total, fmt.Errorf(\"src does not exist: %q\", src)\n\t\t}\n\n\t\terr = filepath.Walk(src, func(_ string, info os.FileInfo, err error) error {\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"walk: %s\", err)\n\t\t\t}\n\t\t\ttotal += info.Size()\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\treturn total, err\n\t\t}\n\t}\n\n\treturn total, nil\n}\n\nfunc copyFile(src, dst string, preserve []string, info os.FileInfo, nums chan int64) error {\n\tvar dst_mode os.FileMode = 0o666\n\tpreserve_timestamps := false\n\tfor _, s := range preserve {\n\t\tswitch s {\n\t\tcase \"timestamps\":\n\t\t\tpreserve_timestamps = true\n\t\tcase \"mode\":\n\t\t\tdst_mode = info.Mode()\n\t\t}\n\t}\n\n\tr, err := os.Open(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer r.Close()\n\n\tw, err := os.OpenFile(dst, os.O_RDWR|os.O_CREATE|os.O_TRUNC, dst_mode)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = io.Copy(NewProgressWriter(w, nums), r)\n\tif err != nil {\n\t\tw.Close()\n\t\tos.Remove(dst)\n\t\treturn err\n\t}\n\n\tif err := w.Close(); err != nil {\n\t\tos.Remove(dst)\n\t\treturn err\n\t}\n\n\tif preserve_timestamps {\n\t\tts := times.Get(info)\n\t\tmtime := info.ModTime()\n\t\tatime := ts.AccessTime()\n\t\tif err := os.Chtimes(dst, atime, mtime); err != nil {\n\t\t\tos.Remove(dst)\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc copyAll(srcs []string, dstDir string, preserve []string) (nums chan int64, errs chan error) {\n\tnums = make(chan int64, 1024)\n\terrs = make(chan error, 1024)\n\n\tgo func() {\n\t\tfor _, src := range srcs {\n\t\t\tfile := filepath.Base(src)\n\t\t\tdst := filepath.Join(dstDir, file)\n\n\t\t\tlstat, err := os.Lstat(dst)\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\text := getFileExtension(lstat)\n\t\t\t\tbasename := file[:len(file)-len(ext)]\n\t\t\t\tvar newPath string\n\t\t\t\tfor i := 1; !os.IsNotExist(err); i++ {\n\t\t\t\t\tfile = strings.ReplaceAll(gOpts.dupfilefmt, \"%f\", basename+ext)\n\t\t\t\t\tfile = strings.ReplaceAll(file, \"%b\", basename)\n\t\t\t\t\tfile = strings.ReplaceAll(file, \"%e\", ext)\n\t\t\t\t\tfile = strings.ReplaceAll(file, \"%n\", strconv.Itoa(i))\n\t\t\t\t\tnewPath = filepath.Join(dstDir, file)\n\t\t\t\t\t_, err = os.Lstat(newPath)\n\t\t\t\t}\n\t\t\t\tdst = newPath\n\t\t\t}\n\n\t\t\tfilepath.Walk(src, func(path string, info os.FileInfo, err error) error {\n\t\t\t\tif err != nil {\n\t\t\t\t\terrs <- fmt.Errorf(\"walk: %s\", err)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\trel, err := filepath.Rel(src, path)\n\t\t\t\tif err != nil {\n\t\t\t\t\terrs <- fmt.Errorf(\"relative: %s\", err)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tnewPath := filepath.Join(dst, rel)\n\t\t\t\tif info.IsDir() {\n\t\t\t\t\tif err := os.MkdirAll(newPath, info.Mode()); err != nil {\n\t\t\t\t\t\terrs <- fmt.Errorf(\"mkdir: %s\", err)\n\t\t\t\t\t}\n\t\t\t\t\tnums <- info.Size()\n\t\t\t\t} else if info.Mode()&os.ModeSymlink != 0 { /* Symlink */\n\t\t\t\t\tif rlink, err := os.Readlink(path); err != nil {\n\t\t\t\t\t\terrs <- fmt.Errorf(\"symlink: %s\", err)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif err := os.Symlink(rlink, newPath); err != nil {\n\t\t\t\t\t\t\terrs <- fmt.Errorf(\"symlink: %s\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnums <- info.Size()\n\t\t\t\t} else {\n\t\t\t\t\tif err := copyFile(path, newPath, preserve, info, nums); err != nil {\n\t\t\t\t\t\terrs <- fmt.Errorf(\"copy: %s\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\t\t}\n\n\t\tclose(errs)\n\t}()\n\n\treturn nums, errs\n}\n"
        },
        {
          "name": "df_openbsd.go",
          "type": "blob",
          "size": 0.3515625,
          "content": "package main\n\nimport (\n\t\"log\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc diskFree(wd string) string {\n\tvar stat unix.Statfs_t\n\n\tif err := unix.Statfs(wd, &stat); err != nil {\n\t\tlog.Printf(\"diskfree: %s\", err)\n\t\treturn \"\"\n\t}\n\n\t// Available blocks * size per block = available space in bytes\n\treturn \"df: \" + humanize(int64(uint64(stat.F_bavail)*uint64(stat.F_bsize)))\n}\n"
        },
        {
          "name": "df_statfs.go",
          "type": "blob",
          "size": 0.3984375,
          "content": "//go:build darwin || dragonfly || freebsd || linux\n\npackage main\n\nimport (\n\t\"log\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc diskFree(wd string) string {\n\tvar stat unix.Statfs_t\n\n\tif err := unix.Statfs(wd, &stat); err != nil {\n\t\tlog.Printf(\"diskfree: %s\", err)\n\t\treturn \"\"\n\t}\n\n\t// Available blocks * size per block = available space in bytes\n\treturn \"df: \" + humanize(int64(uint64(stat.Bavail)*uint64(stat.Bsize)))\n}\n"
        },
        {
          "name": "df_statvfs.go",
          "type": "blob",
          "size": 0.3896484375,
          "content": "//go:build illumos || netbsd || solaris\n\npackage main\n\nimport (\n\t\"log\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc diskFree(wd string) string {\n\tvar stat unix.Statvfs_t\n\n\tif err := unix.Statvfs(wd, &stat); err != nil {\n\t\tlog.Printf(\"diskfree: %s\", err)\n\t\treturn \"\"\n\t}\n\n\t// Available blocks * size per block = available space in bytes\n\treturn \"df: \" + humanize(int64(uint64(stat.Bavail)*uint64(stat.Bsize)))\n}\n"
        },
        {
          "name": "df_windows.go",
          "type": "blob",
          "size": 0.416015625,
          "content": "package main\n\nimport (\n\t\"log\"\n\n\t\"golang.org/x/sys/windows\"\n)\n\nfunc diskFree(wd string) string {\n\tvar free uint64\n\n\tpathPtr, err := windows.UTF16PtrFromString(wd)\n\tif err != nil {\n\t\tlog.Printf(\"diskfree: %s\", err)\n\t\treturn \"\"\n\t}\n\terr = windows.GetDiskFreeSpaceEx(pathPtr, &free, nil, nil) // cwd, free, total, available\n\tif err != nil {\n\t\tlog.Printf(\"diskfree: %s\", err)\n\t\treturn \"\"\n\t}\n\treturn \"df: \" + humanize(int64(free))\n}\n"
        },
        {
          "name": "diacritics.go",
          "type": "blob",
          "size": 3.298828125,
          "content": "package main\n\nvar normMap = map[rune]rune{\n\t// lowercase (not only) european\n\t'ě': 'e', 'ř': 'r', 'ů': 'u', 'ø': 'o', 'ĉ': 'c', 'ĝ': 'g', 'ĥ': 'h', 'ĵ': 'j', 'ŝ': 's',\n\t'ŭ': 'u', 'è': 'e', 'ù': 'u', 'ÿ': 'y', 'ė': 'e', 'į': 'i', 'ų': 'u', 'ā': 'a', 'ē': 'e',\n\t'ī': 'i', 'ū': 'u', 'ļ': 'l', 'ķ': 'k', 'ņ': 'n', 'ģ': 'g', 'ő': 'o', 'ű': 'u', 'ë': 'e',\n\t'ï': 'i', 'ą': 'a', 'ć': 'c', 'ę': 'e', 'ł': 'l', 'ń': 'n', 'ś': 's', 'ź': 'z', 'ż': 'z',\n\t'õ': 'o', 'ș': 's', 'ț': 't', 'č': 'c', 'ď': 'd', 'ĺ': 'l', 'ľ': 'l', 'ň': 'n', 'ŕ': 'r',\n\t'š': 's', 'ť': 't', 'ý': 'y', 'ž': 'z', 'é': 'e', 'í': 'i', 'ñ': 'n', 'ó': 'o', 'ú': 'u',\n\t'ü': 'u', 'å': 'a', 'ä': 'a', 'ö': 'o', 'ç': 'c', 'î': 'i', 'ş': 's', 'û': 'u', 'ğ': 'g',\n\t'ă': 'a', 'â': 'a', 'đ': 'd', 'ê': 'e', 'ô': 'o', 'ơ': 'o', 'ư': 'u', 'á': 'a', 'à': 'a',\n\t'ã': 'a', 'ả': 'a', 'ạ': 'a',\n\t// uppercase (not only) european\n\t'Ě': 'E', 'Ř': 'R', 'Ů': 'U', 'Ø': 'O', 'Ĉ': 'C', 'Ĝ': 'G', 'Ĥ': 'H', 'Ĵ': 'J', 'Ŝ': 'S',\n\t'Ŭ': 'U', 'È': 'E', 'Ù': 'U', 'Ÿ': 'Y', 'Ė': 'E', 'Į': 'I', 'Ų': 'U', 'Ā': 'A', 'Ē': 'E',\n\t'Ī': 'I', 'Ū': 'U', 'Ļ': 'L', 'Ķ': 'K', 'Ņ': 'N', 'Ģ': 'G', 'Ő': 'O', 'Ű': 'U', 'Ë': 'E',\n\t'Ï': 'I', 'Ą': 'A', 'Ć': 'C', 'Ę': 'E', 'Ł': 'L', 'Ń': 'N', 'Ś': 'S', 'Ź': 'Z', 'Ż': 'Z',\n\t'Õ': 'O', 'Ș': 'S', 'Ț': 'T', 'Č': 'C', 'Ď': 'D', 'Ĺ': 'L', 'Ľ': 'L', 'Ň': 'N', 'Ŕ': 'R',\n\t'Š': 'S', 'Ť': 'T', 'Ý': 'Y', 'Ž': 'Z', 'É': 'E', 'Í': 'I', 'Ñ': 'N', 'Ó': 'O', 'Ú': 'U',\n\t'Ü': 'U', 'Å': 'A', 'Ä': 'A', 'Ö': 'O', 'Ç': 'C', 'Î': 'I', 'Ş': 'S', 'Û': 'U', 'Ğ': 'G',\n\t'Ă': 'A', 'Â': 'A', 'Đ': 'D', 'Ê': 'E', 'Ô': 'O', 'Ơ': 'O', 'Ư': 'U', 'Á': 'A', 'À': 'A',\n\t'Ã': 'A', 'Ả': 'A', 'Ạ': 'A',\n\n\t// lowercase Vietnamese\n\t'ắ': 'a', 'ặ': 'a', 'ằ': 'a', 'ẳ': 'a', 'ẵ': 'a', 'ấ': 'a', 'ậ': 'a', 'ầ': 'a', 'ẩ': 'a',\n\t'ẫ': 'a', 'ẹ': 'e', 'ẻ': 'e', 'ẽ': 'e', 'ế': 'e', 'ệ': 'e', 'ề': 'e', 'ể': 'e', 'ễ': 'e',\n\t'i': 'i', 'ị': 'i', 'ì': 'i', 'ỉ': 'i', 'ĩ': 'i', 'o': 'o', 'ọ': 'o', 'ò': 'o', 'ỏ': 'o',\n\t'ố': 'o', 'ộ': 'o', 'ồ': 'o', 'ổ': 'o', 'ỗ': 'o', 'ớ': 'o', 'ợ': 'o', 'ờ': 'o', 'ở': 'o',\n\t'ỡ': 'o', 'ụ': 'u', 'ủ': 'u', 'ũ': 'u', 'ứ': 'u', 'ự': 'u', 'ừ': 'u', 'ử': 'u', 'ữ': 'u',\n\t'y': 'y', 'ỵ': 'y', 'ỳ': 'y', 'ỷ': 'y', 'ỹ': 'y',\n\t// uppercase Vietnamese\n\t'Ắ': 'A', 'Ặ': 'A', 'Ằ': 'A', 'Ẳ': 'A', 'Ẵ': 'A', 'Ấ': 'A', 'Ậ': 'A', 'Ầ': 'A', 'Ẩ': 'A',\n\t'Ẫ': 'A', 'Ẹ': 'E', 'Ẻ': 'E', 'Ẽ': 'E', 'Ế': 'E', 'Ệ': 'E', 'Ề': 'E', 'Ể': 'E', 'Ễ': 'E',\n\t'I': 'I', 'Ị': 'I', 'Ì': 'I', 'Ỉ': 'I', 'Ĩ': 'I', 'O': 'O', 'Ọ': 'O', 'Ò': 'O', 'Ỏ': 'O',\n\t'Ố': 'O', 'Ộ': 'O', 'Ồ': 'O', 'Ổ': 'O', 'Ỗ': 'O', 'Ớ': 'O', 'Ợ': 'O', 'Ờ': 'O', 'Ở': 'O',\n\t'Ỡ': 'O', 'Ụ': 'U', 'Ủ': 'U', 'Ũ': 'U', 'Ứ': 'U', 'Ự': 'U', 'Ừ': 'U', 'Ử': 'U', 'Ữ': 'U',\n\t'Y': 'Y', 'Ỵ': 'Y', 'Ỳ': 'Y', 'Ỷ': 'Y', 'Ỹ': 'Y',\n}\n\nfunc removeDiacritics(baseString string) string {\n\tnormalizedRunes := make([]rune, 0, len(baseString))\n\tfor _, baseRune := range baseString {\n\t\tif normRune, ok := normMap[baseRune]; ok {\n\t\t\tnormalizedRunes = append(normalizedRunes, normRune)\n\t\t} else {\n\t\t\tnormalizedRunes = append(normalizedRunes, baseRune)\n\t\t}\n\t}\n\treturn string(normalizedRunes)\n}\n"
        },
        {
          "name": "diacritics_test.go",
          "type": "blob",
          "size": 3.8603515625,
          "content": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\n// typical czech test sentence ;-)\nconst baseTestString = \"Příliš žluťoučký kůň příšerně úpěl ďábelské ódy\"\n\nfunc TestRemoveDiacritics(t *testing.T) {\n\ttestStr := baseTestString\n\texpStr := \"Prilis zlutoucky kun priserne upel dabelske ody\"\n\tcheckRemoveDiacritics(testStr, expStr, t)\n\n\t// other accents (non complete, but all I found)\n\ttestStr = \"áéíóúýčďěňřšťžůåøĉĝĥĵŝŭšžõäöüàâçéèêëîïôùûüÿžščćđáéíóúąęėįųūčšžāēīūčšžļķņģáéíóúöüőűäöüëïąćęłńóśźżáàãâçéêíóõôăâîșțáäčďéíĺľňóôŕšťúýžáéíñóúüåäöâçîşûğăâđêôơưáàãảạ\"\n\texpStr = \"aeiouycdenrstzuaocghjsuszoaouaaceeeeiiouuuyzsccdaeiouaeeiuucszaeiucszlkngaeiouououaoueiacelnoszzaaaaceeioooaaistaacdeillnoorstuyzaeinouuaaoacisugaadeoouaaaaa\"\n\tcheckRemoveDiacritics(testStr, expStr, t)\n\n\ttestStr = \"ÁÉÍÓÚÝČĎĚŇŘŠŤŽŮÅØĈĜĤĴŜŬŠŽÕÄÖÜÀÂÇÉÈÊËÎÏÔÙÛÜŸŽŠČĆĐÁÉÍÓÚĄĘĖĮŲŪČŠŽĀĒĪŪČŠŽĻĶŅĢÁÉÍÓÚÖÜŐŰÄÖÜËÏĄĆĘŁŃÓŚŹŻÁÀÃÂÇÉÊÍÓÕÔĂÂÎȘȚÁÄČĎÉÍĹĽŇÓÔŔŠŤÚÝŽÁÉÍÑÓÚÜÅÄÖÂÇÎŞÛĞĂÂĐÊÔƠƯÁÀÃẢẠ\"\n\texpStr = \"AEIOUYCDENRSTZUAOCGHJSUSZOAOUAACEEEEIIOUUUYZSCCDAEIOUAEEIUUCSZAEIUCSZLKNGAEIOUOUOUAOUEIACELNOSZZAAAACEEIOOOAAISTAACDEILLNOORSTUYZAEINOUUAAOACISUGAADEOOUAAAAA\"\n\tcheckRemoveDiacritics(testStr, expStr, t)\n\n\ttestStr = \"áạàảãăắặằẳẵâấậầẩẫéẹèẻẽêếệềểễiíịìỉĩoóọòỏõôốộồổỗơớợờởỡúụùủũưứựừửữyýỵỳỷỹđ\"\n\texpStr = \"aaaaaaaaaaaaaaaaaeeeeeeeeeeeiiiiiioooooooooooooooooouuuuuuuuuuuyyyyyyd\"\n\tcheckRemoveDiacritics(testStr, expStr, t)\n\n\ttestStr = \"ÁẠÀẢÃĂẮẶẰẲẴÂẤẬẦẨẪÉẸÈẺẼÊẾỆỀỂỄÍỊÌỈĨÓỌÒỎÕÔỐỘỒỔỖƠỚỢỜỞỠÚỤÙỦŨƯỨỰỪỬỮÝỴỲỶỸĐ\"\n\texpStr = \"AAAAAAAAAAAAAAAAAEEEEEEEEEEEIIIIIOOOOOOOOOOOOOOOOOUUUUUUUUUUUYYYYYD\"\n\tcheckRemoveDiacritics(testStr, expStr, t)\n}\n\nfunc checkRemoveDiacritics(testStr string, expStr string, t *testing.T) {\n\tresultStr := removeDiacritics(testStr)\n\tif resultStr != expStr {\n\t\tt.Errorf(\"at input '%v' expected '%v' but got '%v'\", testStr, expStr, resultStr)\n\t}\n}\n\nfunc TestSearchSettings(t *testing.T) {\n\trunSearch(t, true, false, true, true, \"Veřejný\", \"vere\", true)\n\n\trunSearch(t, true, false, true, false, baseTestString, \"Zlutoucky\", true)\n\trunSearch(t, true, false, true, false, baseTestString, \"zlutoucky\", true)\n\trunSearch(t, true, true, true, false, baseTestString, \"Zlutoucky\", false)\n\trunSearch(t, true, true, true, true, baseTestString, \"zlutoucky\", true)\n\n\trunSearch(t, false, false, true, false, baseTestString, \"žlutoucky\", true)\n\trunSearch(t, false, false, true, false, baseTestString, \"Žlutoucky\", false)\n\n\trunSearch(t, false, false, true, true, baseTestString, \"žluťoučký\", true)\n\trunSearch(t, false, false, true, false, baseTestString, \"žluťoučký\", true)\n\trunSearch(t, false, false, false, false, baseTestString, \"žluťoučký\", true)\n\trunSearch(t, false, false, false, false, baseTestString, \"zlutoucky\", false)\n\trunSearch(t, false, false, true, true, baseTestString, \"zlutoucky\", true)\n}\n\nfunc runSearch(t *testing.T, ignorecase, smartcase, ignorediacritics, smartdiacritics bool, base, pattern string, expected bool) {\n\tgOpts.ignorecase = ignorecase\n\tgOpts.smartcase = smartcase\n\tgOpts.ignoredia = ignorediacritics\n\tgOpts.smartdia = smartdiacritics\n\tmatched, _ := searchMatch(base, pattern, false)\n\tif matched != expected {\n\t\tt.Errorf(\"False search for\" +\n\t\t\t\" ignorecase = \" + strconv.FormatBool(gOpts.ignorecase) + \", \" +\n\t\t\t\" smartcase = \" + strconv.FormatBool(gOpts.smartcase) + \", \" +\n\t\t\t\" ignoredia = \" + strconv.FormatBool(gOpts.ignoredia) + \", \" +\n\t\t\t\" smartdia = \" + strconv.FormatBool(gOpts.smartdia) + \", \")\n\t}\n}\n"
        },
        {
          "name": "doc.md",
          "type": "blob",
          "size": 71.37890625,
          "content": "# NAME\n\nlf - terminal file manager\n\n# SYNOPSIS\n\n**lf**\n[**-command** *command*]\n[**-config** *path*]\n[**-cpuprofile** *path*]\n[**-doc**]\n[**-last-dir-path** *path*]\n[**-log path**]\n[**-memprofile** *path*]\n[**-print-last-dir**]\n[**-print-selection**]\n[**-remote** *command*]\n[**-selection-path** *path*]\n[**-server**]\n[**-single**]\n[**-version**]\n[**-help**]\n[*cd-or-select-path*]\n\n# DESCRIPTION\n\nlf is a terminal file manager.\n\nThe source code can be found in the repository at https://github.com/gokcehan/lf\n\nThis documentation can either be read from the terminal using `lf -doc` or online at https://github.com/gokcehan/lf/blob/master/doc.md\nYou can also use the `doc` command (default `<f-1>`) inside lf to view the documentation in a pager.\nA man page with the same content is also available in the repository at https://github.com/gokcehan/lf/blob/master/lf.1\n\nYou can run `lf -help` to see descriptions of command line options.\n\n# QUICK REFERENCE\n\nThe following commands are provided by lf:\n\n\tquit                     (default 'q')\n\tup                       (default 'k' and '<up>')\n\thalf-up                  (default '<c-u>')\n\tpage-up                  (default '<c-b>' and '<pgup>')\n\tscroll-up                (default '<c-y>')\n\tdown                     (default 'j' and '<down>')\n\thalf-down                (default '<c-d>')\n\tpage-down                (default '<c-f>' and '<pgdn>')\n\tscroll-down              (default '<c-e>')\n\tupdir                    (default 'h' and '<left>')\n\topen                     (default 'l' and '<right>')\n\tjump-next                (default ']')\n\tjump-prev                (default '[')\n\ttop                      (default 'gg' and '<home>')\n\tbottom                   (default 'G' and '<end>')\n\thigh                     (default 'H')\n\tmiddle                   (default 'M')\n\tlow                      (default 'L')\n\ttoggle\n\tinvert                   (default 'v')\n\tinvert-below\n\tunselect                 (default 'u')\n\tglob-select\n\tglob-unselect\n\tcalcdirsize\n\tclearmaps\n\tcopy                     (default 'y')\n\tcut                      (default 'd')\n\tpaste                    (default 'p')\n\tclear                    (default 'c')\n\tsync\n\tdraw\n\tredraw                   (default '<c-l>')\n\tload\n\treload                   (default '<c-r>')\n\techo\n\techomsg\n\techoerr\n\tcd\n\tselect\n\tdelete         (modal)\n\trename         (modal)   (default 'r')\n\tsource\n\tpush\n\tread           (modal)   (default ':')\n\tshell          (modal)   (default '$')\n\tshell-pipe     (modal)   (default '%')\n\tshell-wait     (modal)   (default '!')\n\tshell-async    (modal)   (default '&')\n\tfind           (modal)   (default 'f')\n\tfind-back      (modal)   (default 'F')\n\tfind-next                (default ';')\n\tfind-prev                (default ',')\n\tsearch         (modal)   (default '/')\n\tsearch-back    (modal)   (default '?')\n\tsearch-next              (default 'n')\n\tsearch-prev              (default 'N')\n\tfilter         (modal)\n\tsetfilter\n\tmark-save      (modal)   (default 'm')\n\tmark-load      (modal)   (default \"'\")\n\tmark-remove    (modal)   (default '\"')\n\ttag\n\ttag-toggle               (default 't')\n\nThe following command line commands are provided by lf:\n\n\tcmd-escape               (default '<esc>')\n\tcmd-complete             (default '<tab>')\n\tcmd-menu-complete\n\tcmd-menu-complete-back\n\tcmd-menu-accept\n\tcmd-enter                (default '<c-j>' and '<enter>')\n\tcmd-interrupt            (default '<c-c>')\n\tcmd-history-next         (default '<c-n>' and '<down>')\n\tcmd-history-prev         (default '<c-p>' and '<up>')\n\tcmd-left                 (default '<c-b>' and '<left>')\n\tcmd-right                (default '<c-f>' and '<right>')\n\tcmd-home                 (default '<c-a>' and '<home>')\n\tcmd-end                  (default '<c-e>' and '<end>')\n\tcmd-delete               (default '<c-d>' and '<delete>')\n\tcmd-delete-back          (default '<backspace>' and '<backspace2>')\n\tcmd-delete-home          (default '<c-u>')\n\tcmd-delete-end           (default '<c-k>')\n\tcmd-delete-unix-word     (default '<c-w>')\n\tcmd-yank                 (default '<c-y>')\n\tcmd-transpose            (default '<c-t>')\n\tcmd-transpose-word       (default '<a-t>')\n\tcmd-word                 (default '<a-f>')\n\tcmd-word-back            (default '<a-b>')\n\tcmd-delete-word          (default '<a-d>')\n\tcmd-delete-word-back     (default '<a-backspace>' and '<a-backspace2>')\n\tcmd-capitalize-word      (default '<a-c>')\n\tcmd-uppercase-word       (default '<a-u>')\n\tcmd-lowercase-word       (default '<a-l>')\n\nThe following options can be used to customize the behavior of lf:\n\n\tanchorfind        bool      (default true)\n\tautoquit          bool      (default true)\n\tborderfmt         string    (default \"\\033[0m\")\n\tcleaner           string    (default '')\n\tcopyfmt           string    (default \"\\033[7;33m\")\n\tcursoractivefmt   string    (default \"\\033[7m\")\n\tcursorparentfmt   string    (default \"\\033[7m\")\n\tcursorpreviewfmt  string    (default \"\\033[4m\")\n\tcutfmt            string    (default \"\\033[7;31m\")\n\tdircache          bool      (default true)\n\tdircounts         bool      (default false)\n\tdirfirst          bool      (default true)\n\tdironly           bool      (default false)\n\tdirpreviews       bool      (default false)\n\tdrawbox           bool      (default false)\n\tdupfilefmt        string    (default '%f.~%n~')\n\terrorfmt          string    (default \"\\033[7;31;47m\")\n\tfilesep           string    (default \"\\n\")\n\tfindlen           int       (default 1)\n\tglobfilter        bool      (default false)\n\tglobsearch        bool      (default false)\n\thidden            bool      (default false)\n\thiddenfiles       []string  (default '.*' for Unix and '' for Windows)\n\thistory           bool      (default true)\n\ticons             bool      (default false)\n\tifs               string    (default '')\n\tignorecase        bool      (default true)\n\tignoredia         bool      (default true)\n\tincfilter         bool      (default false)\n\tincsearch         bool      (default false)\n\tinfo              []string  (default '')\n\tinfotimefmtnew    string    (default 'Jan _2 15:04')\n\tinfotimefmtold    string    (default 'Jan _2  2006')\n\tlocale            string    (default '')\n\tmouse             bool      (default false)\n\tnumber            bool      (default false)\n\tnumberfmt         string    (default \"\\033[33m\")\n\tperiod            int       (default 0)\n\tpreserve          []string  (default \"mode\")\n\tpreview           bool      (default true)\n\tpreviewer         string    (default '')\n\tpromptfmt         string    (default \"\\033[32;1m%u@%h\\033[0m:\\033[34;1m%d\\033[0m\\033[1m%f\\033[0m\")\n\tratios            []int     (default '1:2:3')\n\trelativenumber    bool      (default false)\n\treverse           bool      (default false)\n\troundbox          bool      (default false)\n\trulerfmt          string    (default \"  %a|  %p|  \\033[7;31m %m \\033[0m|  \\033[7;33m %c \\033[0m|  \\033[7;35m %s \\033[0m|  \\033[7;34m %f \\033[0m|  %i/%t\")\n\tscrolloff         int       (default 0)\n\tselectfmt         string    (default \"\\033[7;35m\")\n\tselmode           string    (default 'all')\n\tshell             string    (default 'sh' for Unix and 'cmd' for Windows)\n\tshellflag         string    (default '-c' for Unix and '/c' for Windows)\n\tshellopts         []string  (default '')\n\tshowbinds         bool      (default true)\n\tsixel             bool      (default false)\n\tsmartcase         bool      (default true)\n\tsmartdia          bool      (default false)\n\tsortby            string    (default 'natural')\n\tstatfmt           string    (default \"\\033[36m%p\\033[0m| %c| %u| %g| %S| %t| -> %l\")\n\ttabstop           int       (default 8)\n\ttagfmt            string    (default \"\\033[31m\")\n\ttempmarks         string    (default '')\n\ttimefmt           string    (default 'Mon Jan _2 15:04:05 2006')\n\ttruncatechar      string    (default '~')\n\ttruncatepct       int       (default 100)\n\twaitmsg           string    (default 'Press any key to continue')\n\twatch             bool      (default false)\n\twrapscan          bool      (default true)\n\twrapscroll        bool      (default false)\n\tuser_{option}     string    (default none)\n\nThe following environment variables are exported for shell commands:\n\n\tf\n\tfs\n\tfx\n\tid\n\tPWD\n\tOLDPWD\n\tLF_LEVEL\n\tOPENER\n\tVISUAL\n\tEDITOR\n\tPAGER\n\tSHELL\n\tlf\n\tlf_{option}\n\tlf_user_{option}\n\tlf_width\n\tlf_height\n\tlf_count\n\tlf_mode\n\nThe following special shell commands are used to customize the behavior of lf when defined:\n\n\topen\n\tpaste\n\trename\n\tdelete\n\tpre-cd\n\ton-cd\n\ton-focus-gained\n\ton-focus-lost\n\ton-init\n\ton-select\n\ton-redraw\n\ton-quit\n\nThe following commands/keybindings are provided by default:\n\n\tUnix\n\tcmd open &$OPENER \"$f\"\n\tmap e $$EDITOR \"$f\"\n\tmap i $$PAGER \"$f\"\n\tmap w $$SHELL\n\tcmd doc $$lf -doc | $PAGER\n\tmap <f-1> doc\n\tcmd maps $lf -remote \"query $id maps\" | $PAGER\n\tcmd cmaps $lf -remote \"query $id cmaps\" | $PAGER\n\tcmd cmds $lf -remote \"query $id cmds\" | $PAGER\n\n\tWindows\n\tcmd open &%OPENER% %f%\n\tmap e $%EDITOR% %f%\n\tmap i !%PAGER% %f%\n\tmap w $%SHELL%\n\tcmd doc !%lf% -doc | %PAGER%\n\tmap <f-1> doc\n\tcmd maps !%lf% -remote \"query %id% maps\" | %PAGER%\n\tcmd cmaps !%lf% -remote \"query %id% cmaps\" | %PAGER%\n\tcmd cmds !%lf% -remote \"query %id% cmds\" | %PAGER%\n\nThe following additional keybindings are provided by default:\n\n\tmap zh set hidden!\n\tmap zr set reverse!\n\tmap zn set info\n\tmap zs set info size\n\tmap zt set info time\n\tmap za set info size:time\n\tmap sn :set sortby natural; set info\n\tmap ss :set sortby size; set info size\n\tmap st :set sortby time; set info time\n\tmap sa :set sortby atime; set info atime\n\tmap sc :set sortby ctime; set info ctime\n\tmap se :set sortby ext; set info\n\tmap gh cd ~\n\tmap <space> :toggle; down\n\nIf the `mouse` option is enabled, mouse buttons have the following default effects:\n\n\tLeft mouse button\n\t    Click on a file or directory to select it.\n\n\tRight mouse button\n\t    Enter a directory or open a file. Also works on the preview window.\n\n\tScroll wheel\n\t    Move up or down. If Ctrl is pressed, scroll up or down.\n\n# CONFIGURATION\n\nConfiguration files should be located at:\n\n\tOS       system-wide               user-specific\n\tUnix     /etc/lf/lfrc              ~/.config/lf/lfrc\n\tWindows  C:\\ProgramData\\lf\\lfrc    C:\\Users\\<user>\\AppData\\Local\\lf\\lfrc\n\nThe colors file should be located at:\n\n\tOS       system-wide               user-specific\n\tUnix     /etc/lf/colors            ~/.config/lf/colors\n\tWindows  C:\\ProgramData\\lf\\colors  C:\\Users\\<user>\\AppData\\Local\\lf\\colors\n\nThe icons file should be located at:\n\n\tOS       system-wide               user-specific\n\tUnix     /etc/lf/icons             ~/.config/lf/icons\n\tWindows  C:\\ProgramData\\lf\\icons   C:\\Users\\<user>\\AppData\\Local\\lf\\icons\n\nThe selection file should be located at:\n\n\tUnix     ~/.local/share/lf/files\n\tWindows  C:\\Users\\<user>\\AppData\\Local\\lf\\files\n\nThe marks file should be located at:\n\n\tUnix     ~/.local/share/lf/marks\n\tWindows  C:\\Users\\<user>\\AppData\\Local\\lf\\marks\n\nThe tags file should be located at:\n\n\tUnix     ~/.local/share/lf/tags\n\tWindows  C:\\Users\\<user>\\AppData\\Local\\lf\\tags\n\nThe history file should be located at:\n\n\tUnix     ~/.local/share/lf/history\n\tWindows  C:\\Users\\<user>\\AppData\\Local\\lf\\history\n\nYou can configure these locations with the following variables given with their order of precedences and their default values:\n\n\tUnix\n\t    $LF_CONFIG_HOME\n\t    $XDG_CONFIG_HOME\n\t    ~/.config\n\n\t    $LF_DATA_HOME\n\t    $XDG_DATA_HOME\n\t    ~/.local/share\n\n\tWindows\n\t    %ProgramData%\n\t    C:\\ProgramData\n\n\t    %LF_CONFIG_HOME%\n\t    %LOCALAPPDATA%\n\t    C:\\Users\\<user>\\AppData\\Local\n\nA sample configuration file can be found at\nhttps://github.com/gokcehan/lf/blob/master/etc/lfrc.example\n\n# COMMANDS\n\nThis section shows information about built-in commands.\nModal commands do not take any arguments, but instead change the operation mode to read their input conveniently, and so they are meant to be assigned to keybindings.\n\n## quit (default `q`)\n\nQuit lf and return to the shell.\n\n## up (default `k` and `<up>`), half-up (default `<c-u>`), page-up (default `<c-b>` and `<pgup>`), scroll-up (default `<c-y>`), down (default `j` and `<down>`), half-down (default `<c-d>`), page-down (default `<c-f>` and `<pgdn>`), scroll-down (default `<c-e>`)\n\nMove/scroll the current file selection upwards/downwards by one/half a page/full page.\n\n## updir (default `h` and `<left>`)\n\nChange the current working directory to the parent directory.\n\n## open (default `l` and `<right>`)\n\nIf the current file is a directory, then change the current directory to it, otherwise, execute the `open` command.\nA default `open` command is provided to call the default system opener asynchronously with the current file as the argument.\nA custom `open` command can be defined to override this default.\n\n## jump-next (default `]`), jump-prev (default `[`)\n\nChange the current working directory to the next/previous jumplist item.\n\n## top (default `gg` and `<home>`), bottom (default `G` and `<end>`)\n\nMove the current file selection to the top/bottom of the directory.\nA count can be specified to move to a specific line, for example, use `3G` to move to the third line.\n\n## high (default `H`), middle (default `M`), low (default `L`)\n\nMove the current file selection to the high/middle/low of the screen.\n\n## toggle\n\nToggle the selection of the current file or files given as arguments.\n\n## invert (default `v`)\n\nReverse the selection of all files in the current directory (i.e. `toggle` all files).\nSelections in other directories are not affected by this command.\nYou can define a new command to select all files in the directory by combining `invert` with `unselect` (i.e. `cmd select-all :unselect; invert`), though this will also remove selections in other directories.\n\n## invert-below\n\nReverse the selection (i.e. `toggle`) of all files at or after the current file in the current directory.\n\nTo select a contiguous block of files, use this command on the first file you want to select.\nThen, move down to the first file you do *not* want to select (the one after the end of the desired selection) and use this command again.\nThis achieves an effect similar to the visual mode in Vim.\n\nThis command is experimental and may be removed once a better replacement for the visual mode is implemented in `lf`.\nIf you'd like to experiment with using this command, you should bind it to a key (e.g. `V`) for a better experience.\n\n## unselect (default `u`)\n\nRemove the selection of all files in all directories.\n\n## glob-select, glob-unselect\n\nSelect/unselect files that match the given glob.\n\n## calcdirsize\n\nCalculate the total size for each of the selected directories.\nOption `info` should include `size` and option `dircounts` should be disabled to show this size.\nIf the total size of a directory is not calculated, it will be shown as `-`.\n\n## clearmaps\n\nRemove all keybindings associated with the `map` command.\nThis command can be used in the config file to remove the default keybindings.\nFor safety purposes, `:` is left mapped to the `read` command, and `cmap` keybindings are retained so that it is still possible to exit `lf` using `:quit`.\n\n## copy (default `y`)\n\nIf there are no selections, save the path of the current file to the copy buffer, otherwise, copy the paths of selected files.\n\n## cut (default `d`)\n\nIf there are no selections, save the path of the current file to the cut buffer, otherwise, copy the paths of selected files.\n\n## paste (default `p`)\n\nCopy/Move files in the copy/cut buffer to the current working directory.\nA custom `paste` command can be defined to override this default.\n\n## clear (default `c`)\n\nClear file paths in copy/cut buffer.\n\n## sync\n\nSynchronize copied/cut files with the server.\nThis command is automatically called when required.\n\n## draw\n\nDraw the screen.\nThis command is automatically called when required.\n\n## redraw (default `<c-l>`)\n\nSynchronize the terminal and redraw the screen.\n\n## load\n\nLoad modified files and directories.\nThis command is automatically called when required.\n\n## reload (default `<c-r>`)\n\nFlush the cache and reload all files and directories.\n\n## echo\n\nPrint the given arguments to the message line at the bottom.\n\n## echomsg\n\nPrint the given arguments to the message line at the bottom and also to the log file.\n\n## echoerr\n\nPrint given arguments to the message line at the bottom as `errorfmt` and also to the log file.\n\n## cd\n\nChange the working directory to the given argument.\n\n## select\n\nChange the current file selection to the given argument.\n\n## delete (modal)\n\nRemove the current file or selected file(s).\nA custom `delete` command can be defined to override this default.\n\n## rename (modal) (default `r`)\n\nRename the current file using the built-in method.\nA custom `rename` command can be defined to override this default.\n\n## source\n\nRead the configuration file given in the argument.\n\n## push\n\nSimulate key pushes given in the argument.\n\n## read (modal) (default `:`)\n\nRead a command to evaluate.\n\n## shell (modal) (default `$`)\n\nRead a shell command to execute.\n\n## shell-pipe (modal) (default `%`)\n\nRead a shell command to execute piping its standard I/O to the bottom statline.\n\n## shell-wait (modal) (default `!`)\n\nRead a shell command to execute and wait for a key press in the end.\n\n## shell-async (modal) (default `&`)\n\nRead a shell command to execute asynchronously without standard I/O.\n\n## find (modal) (default `f`), find-back (modal) (default `F`), find-next (default `;`), find-prev (default `,`)\n\nRead key(s) to find the appropriate file name match in the forward/backward direction and jump to the next/previous match.\n\n## search (default `/`), search-back (default `?`), search-next (default `n`), search-prev (default `N`)\n\nRead a pattern to search for a file name match in the forward/backward direction and jump to the next/previous match.\n\n## filter (modal), setfilter\n\nCommand `filter` reads a pattern to filter out and only view files matching the pattern.\nCommand `setfilter` does the same but uses an argument to set the filter immediately.\nYou can supply an argument to `filter` to use as the starting prompt.\n\n## mark-save (modal) (default `m`)\n\nSave the current directory as a bookmark assigned to the given key.\n\n## mark-load (modal) (default `'`)\n\nChange the current directory to the bookmark assigned to the given key.\nA special bookmark `'` holds the previous directory after a `mark-load`, `cd`, or `select` command.\n\n## mark-remove (modal) (default `\"`)\n\nRemove a bookmark assigned to the given key.\n\n## tag\n\nTag a file with `*` or a single-width character given in the argument.\nYou can define a new tag-clearing command by combining `tag` with `tag-toggle` (i.e. `cmd tag-clear :tag; tag-toggle`).\n\n## tag-toggle (default `t`)\n\nTag a file with `*` or a single width character given in the argument if the file is untagged, otherwise remove the tag.\n\n# COMMAND LINE COMMANDS\n\nThe prompt character specifies which of the several command-line modes you are in.\nFor example, the `read` command takes you to the `:` mode.\n\nWhen the cursor is at the first character in `:` mode, pressing one of the keys `!`, `$`, `%`, or `&` takes you to the corresponding mode.\nYou can go back with `cmd-delete-back` (`<backspace>` by default).\n\nThe command line commands should be mostly compatible with readline keybindings.\nA character refers to a Unicode code point, a word consists of letters and digits, and a unix word consists of any non-blank characters.\n\n## cmd-escape (default `<esc>`)\n\nQuit command line mode and return to normal mode.\n\n## cmd-complete (default `<tab>`)\n\nAutocomplete the current word.\n\n## cmd-menu-complete, cmd-menu-complete-back\n\nAutocomplete the current word with the menu selection.\nYou need to assign keys to these commands (e.g. `cmap <tab> cmd-menu-complete; cmap <backtab> cmd-menu-complete-back`).\nYou can use the assigned keys to display the menu and then cycle through completion options.\n\n## cmd-menu-accept\n\nAccept the currently selected match in menu completion and close the menu.\n\n## cmd-enter (default `<c-j>` and `<enter>`)\n\nExecute the current line.\n\n## cmd-interrupt (default `<c-c>`)\n\nInterrupt the current shell-pipe command and return to the normal mode.\n\n## cmd-history-next (default `<c-n>` and `<down>`), cmd-history-prev (default `<c-p>` and `<up>`)\n\nGo to the next/previous item in the history.\n\n## cmd-left (default `<c-b>` and `<left>`), cmd-right (default `<c-f>` and `<right>`)\n\nMove the cursor to the left/right.\n\n## cmd-home (default `<c-a>` and `<home>`), cmd-end (default `<c-e>` and `<end>`)\n\nMove the cursor to the beginning/end of the line.\n\n## cmd-delete (default `<c-d>` and `<delete>`)\n\nDelete the next character.\n\n## cmd-delete-back (default `<backspace>` and `<backspace2>`)\n\nDelete the previous character.\nWhen at the beginning of a prompt, returns either to normal mode or to `:` mode.\n\n## cmd-delete-home (default `<c-u>`), cmd-delete-end (default `<c-k>`)\n\nDelete everything up to the beginning/end of the line.\n\n## cmd-delete-unix-word (default `<c-w>`)\n\nDelete the previous unix word.\n\n## cmd-yank (default `<c-y>`)\n\nPaste the buffer content containing the last deleted item.\n\n## cmd-transpose (default `<c-t>`), cmd-transpose-word (default `<a-t>`)\n\nTranspose the positions of the last two characters/words.\n\n## cmd-word (default `<a-f>`), cmd-word-back (default `<a-b>`)\n\nMove the cursor by one word in the forward/backward direction.\n\n## cmd-delete-word (default `<a-d>`)\n\nDelete the next word in the forward direction.\n\n## cmd-delete-word-back (default `<a-backspace>` and `<a-backspace2>`)\n\nDelete the previous word in the backward direction.\n\n## cmd-capitalize-word (default `<a-c>`), cmd-uppercase-word (default `<a-u>`), cmd-lowercase-word (default `<a-l>`)\n\nCapitalize/uppercase/lowercase the current word and jump to the next word.\n\n# OPTIONS\n\nThis section shows information about options to customize the behavior.\nCharacter `:` is used as the separator for list options `[]int` and `[]string`.\n\n## anchorfind (bool) (default true)\n\nWhen this option is enabled, the find command starts matching patterns from the beginning of file names, otherwise, it can match at an arbitrary position.\n\n## autoquit (bool) (default true)\n\nAutomatically quit the server when there are no clients left connected.\n\n## borderfmt (string) (default `\\033[0m`)\n\nFormat string of the box drawing characters enabled by the `drawbox` option.\n\n## cleaner (string) (default ``) (not called if empty)\n\nSet the path of a cleaner file.\nThe file should be executable.\nThis file is called if previewing is enabled, the previewer is set, and the previously selected file has its preview cache disabled.\nThe following arguments are passed to the file, (1) current file name, (2) width, (3) height, (4) horizontal position, (5) vertical position of preview pane and (6) next file name to be previewed respectively.\nPreview cleaning is disabled when the value of this option is left empty.\n\n## copyfmt (string) (default `\\033[7;33m`)\n\nFormat string of the indicator for files to be copied.\n\n## cursoractivefmt (string) (default `\\033[7m`), cursorparentfmt string (default `\\033[7m`), cursorpreviewfmt string (default `\\033[4m`)\n\nFormat strings for highlighting the cursor.\n`cursoractivefmt` applies in the current directory pane,\n`cursorparentfmt` applies in panes that show parents of the current directory,\nand `cursorpreviewfmt` applies in panes that preview directories.\n\nThe default is to make the active cursor and the parent directory cursor inverted. The preview cursor is underlined.\n\nSome other possibilities to consider for the preview or parent cursors: an empty string for no cursor, `\\033[7;2m` for dimmed inverted text (visibility varies by terminal), `\\033[7;90m` for inverted text with grey (aka \"brightblack\") background.\n\nIf the format string contains the characters `%s`, it is interpreted as a format string for `fmt.Sprintf`. Such a string should end with the terminal reset sequence.\nFor example, `\\033[4m%s\\033[0m` has the same effect as `\\033[4m`.\n\n## cutfmt (string) (default `\\033[7;31m`)\n\nFormat string of the indicator for files to be cut.\n\n## dircache (bool) (default true)\n\nCache directory contents.\n\n## dircounts (bool) (default false)\n\nWhen this option is enabled, directory sizes show the number of items inside instead of the total size of the directory, which needs to be calculated for each directory using `calcdirsize`.\nThis information needs to be calculated by reading the directory and counting the items inside.\nTherefore, this option is disabled by default for performance reasons.\nThis option only has an effect when `info` has a `size` field and the pane is wide enough to show the information.\n999 items are counted per directory at most, and bigger directories are shown as `999+`.\n\n## dirfirst (bool) (default true)\n\nShow directories first above regular files.\n\n## dironly (bool) (default false)\n\nShow only directories.\n\n## dirpreviews (bool) (default false)\n\nIf enabled, directories will also be passed to the previewer script. This allows custom previews for directories.\n\n## drawbox (bool) (default false)\n\nDraw boxes around panes with box drawing characters.\n\n## dupfilefmt (string) (default `%f.~%n~`)\n\nFormat string of file name when creating duplicate files. With the default format, copying a file `abc.txt` to the same directory will result in a duplicate file called `abc.txt.~1~`.\nSpecial expansions are provided, `%f` as the file name, `%b` for the basename (file name without extension), `%e` as the extension (including the dot) and `%n` as the number of duplicates.\n\n## errorfmt (string) (default `\\033[7;31;47m`)\n\nFormat string of error messages shown in the bottom message line.\n\nIf the format string contains the characters `%s`, it is interpreted as a format string for `fmt.Sprintf`. Such a string should end with the terminal reset sequence.\nFor example, `\\033[4m%s\\033[0m` has the same effect as `\\033[4m`.\n\n## filesep (string) (default `\\n`)\n\nFile separator used in environment variables `fs` and `fx`.\n\n## findlen (int) (default 1)\n\nNumber of characters prompted for the find command.\nWhen this value is set to 0, find command prompts until there is only a single match left.\n\n## globfilter (bool) (default false)\n\nPatterns are treated as globs for the filter command, see `globsearch` for more details.\n\n## globsearch (bool) (default false)\n\nWhen this option is enabled, search command patterns are considered as globs, otherwise, they are literals.\nWith globbing, `*` matches any sequence, `?` matches any character, and `[...]` or `[^...]` matches character sets or ranges.\nOtherwise, these characters are interpreted as they are.\n\n## hidden (bool) (default false)\n\nShow hidden files.\nOn Unix systems, hidden files are determined by the value of `hiddenfiles`.\nOn Windows, files with hidden attributes are also considered hidden files.\n\n## hiddenfiles ([]string) (default `.*` for Unix and `` for Windows)\n\nList of hidden file glob patterns.\nPatterns can be given as relative or absolute paths.\nGlobbing supports the usual special characters, `*` to match any sequence, `?` to match any character, and `[...]` or `[^...]` to match character sets or ranges.\nIn addition, if a pattern starts with `!`, then its matches are excluded from hidden files. To add multiple patterns, use `:` as a separator. Example: `.*:lost+found:*.bak`\n\n## history (bool) (default true)\n\nSave command history.\n\n## icons (bool) (default false)\n\nShow icons before each item in the list.\n\n## ifs (string) (default ``)\n\nSets `IFS` variable in shell commands.\nIt works by adding the assignment to the beginning of the command string as `IFS=...; ...`.\nThe reason is that `IFS` variable is not inherited by the shell for security reasons.\nThis method assumes a POSIX shell syntax so it can fail for non-POSIX shells.\nThis option has no effect when the value is left empty.\nThis option does not have any effect on Windows.\n\n## ignorecase (bool) (default true)\n\nIgnore case in sorting and search patterns.\n\n## ignoredia (bool) (default true)\n\nIgnore diacritics in sorting and search patterns.\n\n## incsearch (bool) (default false)\n\nJump to the first match after each keystroke during searching.\n\n## incfilter (bool) (default false)\n\nApply filter pattern after each keystroke during filtering.\n\n## info ([]string)  (default ``)\n\nA list of information that is shown for directory items at the right side of the pane.\nCurrently supported information types are `size`, `time`, `atime`, `ctime`, `perm`, `user` and `group`.\nInformation is only shown when the pane width is more than twice the width of information.\n\n## infotimefmtnew (string) (default `Jan _2 15:04`)\n\nFormat string of the file time shown in the info column when it matches this year.\n\n## infotimefmtold (string) (default `Jan _2  2006`)\n\nFormat string of the file time shown in the info column when it doesn't match this year.\n\n## locale (string) (default ``)\n\nAn IETF BCP 47 language tag (e.g. `zh-CN`) for specifying the locale used when using sort type `natural` and `name`.\n\nAn empty string means disable locale ordering, and the special value `*` is used to indicate reading the locale setting from the system environment.\n\n## mouse (bool) (default false)\n\nSend mouse events as input.\n\n## number (bool) (default false)\n\nShow the position number for directory items on the left side of the pane.\nWhen the `relativenumber` option is enabled, only the current line shows the absolute position and relative positions are shown for the rest.\n\n## numberfmt (string) (default `\\033[33m`)\n\nFormat string of the position number for each line.\n\n## period (int) (default 0)\n\nSet the interval in seconds for periodic checks of directory updates.\nThis works by periodically calling the `load` command.\nNote that directories are already updated automatically in many cases.\nThis option can be useful when there is an external process changing the displayed directory and you are not doing anything in lf.\nPeriodic checks are disabled when the value of this option is set to zero.\n\n## preserve ([]string) (default `mode`)\n\nList of attributes that are preserved when copying files.\nCurrently supported attributes are `mode` (i.a. access mode) and `timestamps` (i.e. modification time and access time).\nNote that preserving other attributes like ownership of change/birth timestamp is desirable, but not portably supported in Go.\n\n## preview (bool) (default true)\n\nShow previews of files and directories at the rightmost pane.\nIf the file has more lines than the preview pane, the rest of the lines are not read.\nFiles containing the null character (U+0000) in the read portion are considered binary files and displayed as `binary`.\n\n## previewer (string) (default ``) (not filtered if empty)\n\nSet the path of a previewer file to filter the content of regular files for previewing.\nThe file should be executable.\nThe following arguments are passed to the file, (1) current file name, (2) width, (3) height, (4) horizontal position, and (5) vertical position of preview pane respectively.\nSIGPIPE signal is sent when enough lines are read.\nIf the previewer returns a non-zero exit code, then the preview cache for the given file is disabled.\nThis means that if the file is selected in the future, the previewer is called once again.\nPreview filtering is disabled and files are displayed as they are when the value of this option is left empty.\n\n## promptfmt (string) (default `\\033[32;1m%u@%h\\033[0m:\\033[34;1m%d\\033[0m\\033[1m%f\\033[0m`)\n\nFormat string of the prompt shown in the top line.\nSpecial expansions are provided, `%u` as the user name, `%h` as the hostname, `%w` as the working directory, `%d` as the working directory with a trailing path separator, `%f` as the file name, and `%F` as the current filter. `%S` may be used once and will provide a spacer so that the following parts are right aligned on the screen.\nThe home folder is shown as `~` in the working directory expansion.\nDirectory names are automatically shortened to a single character starting from the leftmost parent when the prompt does not fit the screen.\n\n## ratios ([]int) (default `1:2:3`)\n\nList of ratios of pane widths.\nNumber of items in the list determines the number of panes in the UI.\nWhen the `preview` option is enabled, the rightmost number is used for the width of the preview pane.\n\n## relativenumber (bool) (default false)\n\nShow the position number relative to the current line.\nWhen `number` is enabled, the current line shows the absolute position, otherwise nothing is shown.\n\n## reverse (bool) (default false)\n\nReverse the direction of sort.\n\n## roundbox (bool) (default false)\n\nDraw rounded outer corners when the `drawbox` option is enabled.\n\n## rulerfmt (string) (default `  %a|  %p|  \\033[7;31m %m \\033[0m|  \\033[7;33m %c \\033[0m|  \\033[7;35m %s \\033[0m|  \\033[7;34m %f \\033[0m|  %i/%t`)\n\nFormat string of the ruler shown in the bottom right corner.\nSpecial expansions are provided, `%a` as the pressed keys, `%p` as the progress of file operations, `%m` as the number of files to be cut (moved), `%c` as the number of files to be copied, `%s` as the number of selected files, `%f` as the filter, `%i` as the position of the cursor, `%t` as the number of files shown in the current directory, `%h` as the number of files hidden in the current directory, and `%d` as the amount of free disk space remaining.\nAdditional expansions are provided for environment variables exported by lf, in the form `%{lf_<name>}` (e.g. `%{lf_selmode}`). This is useful for displaying the current settings.\nExpansions are also provided for user-defined options, in the form `%{lf_user_<name>}` (e.g. `%{lf_user_foo}`).\nThe `|` character splits the format string into sections. Any section containing a failed expansion (result is a blank string) is discarded and not shown.\n\n## selectfmt (string) (default `\\033[7;35m`)\n\nFormat string of the indicator for files that are selected.\n\n## selmode (string) (default `all`)\n\nSelection mode for commands.\nWhen set to `all` it will use the selected files from all directories.\nWhen set to `dir` it will only use the selected files in the current directory.\n\n## scrolloff (int) (default 0)\n\nMinimum number of offset lines shown at all times at the top and bottom of the screen when scrolling.\nThe current line is kept in the middle when this option is set to a large value that is bigger than the half of number of lines.\nA smaller offset can be used when the current file is close to the beginning or end of the list to show the maximum number of items.\n\n## shell (string) (default `sh` for Unix and `cmd` for Windows)\n\nShell executable to use for shell commands.\nShell commands are executed as `shell shellopts shellflag command -- arguments`.\n\n## shellflag (string) (default `-c` for Unix and `/c` for Windows)\n\nCommand line flag used to pass shell commands.\n\n## shellopts ([]string)  (default ``)\n\nList of shell options to pass to the shell executable.\n\n## showbinds (bool) (default true)\n\nShow bindings associated with pressed keys.\n\n## sixel (bool) (default false)\n\nRender sixel images in preview.\n\n## smartcase (bool) (default true)\n\nOverride `ignorecase` option when the pattern contains an uppercase character.\nThis option has no effect when `ignorecase` is disabled.\n\n## smartdia (bool) (default false)\n\nOverride `ignoredia` option when the pattern contains a character with diacritic.\nThis option has no effect when `ignoredia` is disabled.\n\n## sortby (string) (default `natural`)\n\nSort type for directories.\nCurrently supported sort types are `natural`, `name`, `size`, `time`, `ctime`, `atime`, and `ext`.\n\n## statfmt (string) (default `\\033[36m%p\\033[0m| %c| %u| %g| %S| %t| -> %l`)\n\nFormat string of the file info shown in the bottom left corner.\nSpecial expansions are provided, `%p` as the file permissions, `%c` as the link count, `%u` as the user, `%g` as the group, `%s` as the file size, `%S` as the file size but with a fixed width of four characters (left-padded with spaces), `%t` as the last modified time, and `%l` as the link target.\nThe `|` character splits the format string into sections. Any section containing a failed expansion (result is a blank string) is discarded and not shown.\n\n## tabstop (int) (default 8)\n\nNumber of space characters to show for horizontal tabulation (U+0009) character.\n\n## tagfmt (string) (default `\\033[31m`)\n\nFormat string of the tags.\n\nIf the format string contains the characters `%s`, it is interpreted as a format string for `fmt.Sprintf`. Such a string should end with the terminal reset sequence.\nFor example, `\\033[4m%s\\033[0m` has the same effect as `\\033[4m`.\n\n## tempmarks (string) (default ``)\n\nMarks to be considered temporary (e.g. `abc` refers to marks `a`, `b`, and `c`).\nThese marks are not synced to other clients and they are not saved in the bookmarks file.\nNote that the special bookmark `` ` `` is always treated as temporary and it does not need to be specified.\n\n## timefmt (string) (default `Mon Jan _2 15:04:05 2006`)\n\nFormat string of the file modification time shown in the bottom line.\n\n## truncatechar (string) (default `~`)\n\nThe truncate character that is shown at the end when the file name does not fit into the pane.\n\n## truncatepct (int) (default 100)\n\nWhen a filename is too long to be shown completely, the available space is\npartitioned into two pieces. truncatepct defines a fraction (in percent\nbetween 0 and 100) for the size of the first piece, which will show the\nbeginning of the filename. The second piece will show the end of the filename\nand will use the rest of the available space. Both pieces are separated by the\ntruncation character (truncatechar).\nA value of 100 will only show the beginning of the filename,\nwhile a value of 0 will only show the end of the filename, e.g.:\n\n- `set truncatepct 100` -> `very-long-filename-tr~` (default)\n\n- `set truncatepct 50`  -> `very-long-f~-truncated`\n\n- `set truncatepct 0`   -> `~ng-filename-truncated`\n\n## waitmsg (string) (default `Press any key to continue`)\n\nString shown after commands of shell-wait type.\n\n## watch (bool) (default false)\n\nWatch the filesystem for changes using `fsnotify` to automatically refresh file information.\nFUSE is currently not supported due to limitations in `fsnotify`.\n\n## wrapscan (bool) (default true)\n\nSearching can wrap around the file list.\n\n## wrapscroll (bool) (default false)\n\nScrolling can wrap around the file list.\n\n## user_{option} (string) (default none)\n\nAny option that is prefixed with `user_` is a user-defined option and can be set to any string.\nInside a user-defined command, the value will be provided in the `lf_user_{option}` environment variable.\nThese options are not used by lf and are not persisted.\n\n# ENVIRONMENT VARIABLES\n\nThe following variables are exported for shell commands:\nThese are referred to with a `$` prefix on POSIX shells (e.g. `$f`), between `%` characters on Windows cmd (e.g. `%f%`), and with a `$env:` prefix on Windows PowerShell (e.g. `$env:f`).\n\n## f\n\nCurrent file selection as a full path.\n\n## fs\n\nSelected file(s) separated with the value of `filesep` option as full path(s).\n\n## fx\n\nSelected file(s) (i.e. `fs`) if there are any selected files, otherwise current file selection (i.e. `f`).\n\n## id\n\nId of the running client.\n\n## PWD\n\nPresent working directory.\n\n## OLDPWD\n\nInitial working directory.\n\n## LF_LEVEL\n\nThe value of this variable is set to the current nesting level when you run lf from a shell spawned inside lf.\nYou can add the value of this variable to your shell prompt to make it clear that your shell runs inside lf.\nFor example, with POSIX shells, you can use `[ -n \"$LF_LEVEL\" ] && PS1=\"$PS1\"\"(lf level: $LF_LEVEL) \"` in your shell configuration file (e.g. `~/.bashrc`).\n\n## OPENER\n\nIf this variable is set in the environment, use the same value. Otherwise, this is set to `start` in Windows, `open` in MacOS, `xdg-open` in others.\n\n## EDITOR\n\nIf VISUAL is set in the environment, use its value. Otherwise, use the value of the environment variable EDITOR. If neither variable is set, this is set to `vi` on Unix, `notepad` in Windows.\n\n## PAGER\n\nIf this variable is set in the environment, use the same value. Otherwise, this is set to `less` on Unix, `more` in Windows.\n\n## SHELL\n\nIf this variable is set in the environment, use the same value. Otherwise, this is set to `sh` on Unix, `cmd` in Windows.\n\n## lf\n\nAbsolute path to the currently running lf binary, if it can be found. Otherwise, this is set to the string `lf`.\n\n## lf_{option}\n\nValue of the {option}.\n\n## lf_user_{option}\n\nValue of the user_{option}.\n\n## lf_width, lf_height\n\nWidth/Height of the terminal.\n\n## lf_count\n\nValue of the count associated with the current command.\n\n## lf_mode\n\nCurrent mode that `lf` is operating in.\nThis is useful for customizing keybindings depending on what the current mode is.\nPossible values are `delete`, `rename`, `filter`, `find`, `mark`, `search`, `command`, `shell`, `pipe` (when running a shell-pipe command), `normal`, and `unknown`.\n\n# SPECIAL COMMANDS\n\nThis section shows information about special shell commands.\n\n## open\n\nThis shell command can be defined to override the default `open` command when the current file is not a directory.\n\n## paste\n\nThis shell command can be defined to override the default `paste` command.\n\n## rename\n\nThis shell command can be defined to override the default `rename` command.\n\n## delete\n\nThis shell command can be defined to override the default `delete` command.\n\n## pre-cd\n\nThis shell command can be defined to be executed before changing a directory.\n\n## on-cd\n\nThis shell command can be defined to be executed after changing a directory.\n\n## on-focus-gained\n\nThis shell command can be defined to be executed when the terminal gains focus.\n\n## on-focus-lost\n\nThis shell command can be defined to be executed when the terminal loses focus.\n\n## on-init\n\nThis shell command can be defined to be executed after initializing and connecting to the server.\n\n## on-select\n\nThis shell command can be defined to be executed after the selection changes.\n\n## on-redraw\n\nThis shell command can be defined to be executed after the screen is redrawn or if the terminal is resized.\n\n## on-quit\n\nThis shell command can be defined to be executed before quitting.\n\n# PREFIXES\n\nThe following command prefixes are used by lf:\n\n\t:  read (default)  builtin/custom command\n\t$  shell           shell command\n\t%  shell-pipe      shell command running with the UI\n\t!  shell-wait      shell command waiting for a key press\n\t&  shell-async     shell command running asynchronously\n\nThe same evaluator is used for the command line and the configuration file for reading shell commands.\nThe difference is that prefixes are not necessary in the command line.\nInstead, different modes are provided to read corresponding commands.\nThese modes are mapped to the prefix keys above by default.\n\n# SYNTAX\n\nCharacters from `#` to newline are comments and ignored:\n\n\t# comments start with `#`\n\nThere are five special commands (`set`, `setlocal`, `map`, `cmap`, and `cmd`) for configuration.\n\nCommand `set` is used to set an option which can be a boolean, integer, or string:\n\n\tset hidden         # boolean enable\n\tset hidden true    # boolean enable\n\tset nohidden       # boolean disable\n\tset hidden false   # boolean disable\n\tset hidden!        # boolean toggle\n\tset scrolloff 10   # integer value\n\tset sortby time    # string value w/o quotes\n\tset sortby 'time'  # string value with single quotes (whitespaces)\n\tset sortby \"time\"  # string value with double quotes (backslash escapes)\n\nCommand `setlocal` is used to set a local option for a directory which can be a boolean or string.\nCurrently supported local options are `dirfirst`, `dironly`, `hidden`, `info`, `reverse`, `sortby` and `locale`.\nAdding a trailing path separator (i.e. `/` for Unix and `\\` for Windows) sets the option for the given directory along with its subdirectories:\n\n\tsetlocal /foo/bar hidden         # boolean enable\n\tsetlocal /foo/bar hidden true    # boolean enable\n\tsetlocal /foo/bar nohidden       # boolean disable\n\tsetlocal /foo/bar hidden false   # boolean disable\n\tsetlocal /foo/bar hidden!        # boolean toggle\n\tsetlocal /foo/bar sortby time    # string value w/o quotes\n\tsetlocal /foo/bar sortby 'time'  # string value with single quotes (whitespaces)\n\tsetlocal /foo/bar sortby \"time\"  # string value with double quotes (backslash escapes)\n\tsetlocal /foo/bar  hidden        # for only '/foo/bar' directory\n\tsetlocal /foo/bar/ hidden        # for '/foo/bar' and its subdirectories (e.g. '/foo/bar/baz')\n\nCommand 'map' is used to bind a key to a command which can be a builtin command, custom command, or shell command:\n\n\tmap gh cd ~        # builtin command\n\tmap D trash        # custom command\n\tmap i $less $f     # shell command\n\tmap U !du -csh *   # waiting shell command\n\nCommand 'cmap' is used to bind a key on the command line to a command line command or any other command:\n\n\tcmap <c-g> cmd-escape\n\tcmap <a-i> set incsearch!\n\nYou can delete an existing binding by leaving the expression empty:\n\n\tmap gh             # deletes 'gh' mapping\n\tcmap <c-g>         # deletes '<c-g>' mapping\n\nCommand `cmd` is used to define a custom command:\n\n\tcmd usage $du -h -d1 | less\n\nYou can delete an existing command by leaving the expression empty:\n\n\tcmd trash          # deletes 'trash' command\n\nIf there is no prefix then `:` is assumed:\n\n\tmap zt set info time\n\nAn explicit `:` can be provided to group statements until a newline which is especially useful for `map` and `cmd` commands:\n\n\tmap st :set sortby time; set info time\n\nIf you need multiline you can wrap statements in `{{` and `}}` after the proper prefix.\n\n\tmap st :{{\n\t    set sortby time\n\t    set info time\n\t}}\n\n# KEY MAPPINGS\n\nRegular keys are assigned to a command with the usual syntax:\n\n\tmap a down\n\nKeys combined with the shift key simply use the uppercase letter:\n\n\tmap A down\n\nSpecial keys are written in between `<` and `>` characters and always use lowercase letters:\n\n\tmap <enter> down\n\nAngle brackets can be assigned with their special names:\n\n\tmap <lt> down\n\tmap <gt> down\n\nFunction keys are prefixed with `f` character:\n\n\tmap <f-1> down\n\nKeys combined with the control key are prefixed with a `c` character:\n\n\tmap <c-a> down\n\nKeys combined with the alt key are assigned in two different ways depending on the behavior of your terminal.\nOlder terminals (e.g. xterm) may set the 8th bit of a character when the alt key is pressed.\nOn these terminals, you can use the corresponding byte for the mapping:\n\n\tmap á down\n\nNewer terminals (e.g. gnome-terminal) may prefix the key with an escape key when the alt key is pressed.\nlf uses the escape delaying mechanism to recognize alt keys in these terminals (delay is 100ms).\nOn these terminals, keys combined with the alt key are prefixed with an `a` character:\n\n\tmap <a-a> down\n\nIt is possible to combine special keys with modifiers:\n\n\tmap <a-enter> down\n\nWARNING: Some key combinations will likely be intercepted by your OS, window manager, or terminal.\nOther key combinations cannot be recognized by lf due to the way terminals work (e.g. `Ctrl+h` combination sends a backspace key instead).\nThe easiest way to find out the name of a key combination and whether it will work on your system is to press the key while lf is running and read the name from the `unknown mapping` error.\n\nMouse buttons are prefixed with an `m` character:\n\n\tmap <m-1> down  # primary\n\tmap <m-2> down  # secondary\n\tmap <m-3> down  # middle\n\tmap <m-4> down\n\tmap <m-5> down\n\tmap <m-6> down\n\tmap <m-7> down\n\tmap <m-8> down\n\nMouse wheel events are also prefixed with an `m` character:\n\n\tmap <m-up>    down\n\tmap <m-down>  down\n\tmap <m-left>  down\n\tmap <m-right> down\n\n# PUSH MAPPINGS\n\nThe usual way to map a key sequence is to assign it to a named or unnamed command.\nWhile this provides a clean way to remap built-in keys as well as other commands, it can be limiting at times.\nFor this reason, the `push` command is provided by lf.\nThis command is used to simulate key pushes given as its arguments.\nYou can `map` a key to a `push` command with an argument to create various keybindings.\n\nThis is mainly useful for two purposes.\nFirst, it can be used to map a command with a command count:\n\n\tmap <c-j> push 10j\n\nSecond, it can be used to avoid typing the name when a command takes arguments:\n\n\tmap r push :rename<space>\n\nOne thing to be careful of is that since the `push` command works with keys instead of commands it is possible to accidentally create recursive bindings:\n\n\tmap j push 2j\n\nThese types of bindings create a deadlock when executed.\n\n# SHELL COMMANDS\n\nRegular shell commands are the most basic command type that is useful for many purposes.\nFor example, we can write a shell command to move the selected file(s) to trash.\nA first attempt to write such a command may look like this:\n\n\tcmd trash ${{\n\t    mkdir -p ~/.trash\n\t    if [ -z \"$fs\" ]; then\n\t        mv \"$f\" ~/.trash\n\t    else\n\t        IFS=\"$(printf '\\n\\t')\"; mv $fs ~/.trash\n\t    fi\n\t}}\n\nWe check `$fs` to see if there are any selected files.\nOtherwise, we just delete the current file.\nSince this is such a common pattern, a separate `$fx` variable is provided.\nWe can use this variable to get rid of the conditional:\n\n\tcmd trash ${{\n\t    mkdir -p ~/.trash\n\t    IFS=\"$(printf '\\n\\t')\"; mv $fx ~/.trash\n\t}}\n\nThe trash directory is checked each time the command is executed.\nWe can move it outside of the command so it would only run once at startup:\n\n\t${{ mkdir -p ~/.trash }}\n\n\tcmd trash ${{ IFS=\"$(printf '\\n\\t')\"; mv $fx ~/.trash }}\n\nSince these are one-liners, we can drop `{{` and `}}`:\n\n\t$mkdir -p ~/.trash\n\n\tcmd trash $IFS=\"$(printf '\\n\\t')\"; mv $fx ~/.trash\n\nFinally, note that we set the `IFS` variable manually in these commands.\nInstead, we could use the `ifs` option to set it for all shell commands (i.e. `set ifs \"\\n\"`).\nThis can be especially useful for interactive use (e.g. `$rm $f` or `$rm $fs` would simply work).\nThis option is not set by default as it can behave unexpectedly for new users.\nHowever, use of this option is highly recommended and it is assumed in the rest of the documentation.\n\n# PIPING SHELL COMMANDS\n\nRegular shell commands have some limitations in some cases.\nWhen an output or error message is given and the command exits afterwards, the ui is immediately resumed and there is no way to see the message without dropping to shell again.\nAlso, even when there is no output or error, the UI still needs to be paused while the command is running.\nThis can cause flickering on the screen for short commands and similar distractions for longer commands.\n\nInstead of pausing the UI, piping shell commands connect stdin, stdout, and stderr of the command to the statline at the bottom of the UI.\nThis can be useful for programs following the Unix philosophy to give no output in the success case, and brief error messages or prompts in other cases.\n\nFor example, following rename command prompts for overwrite in the statline if there is an existing file with the given name:\n\n\tcmd rename %mv -i $f $1\n\nYou can also output error messages in the command and it will show up in the statline.\nFor example, an alternative rename command may look like this:\n\n\tcmd rename %[ -e $1 ] && printf \"file exists\" || mv $f $1\n\nNote that input is line buffered and output and error are byte buffered.\n\n# WAITING SHELL COMMANDS\n\nWaiting shell commands are similar to regular shell commands except that they wait for a key press when the command is finished.\nThese can be useful to see the output of a program before the UI is resumed.\nWaiting shell commands are more appropriate than piping shell commands when the command is verbose and the output is best displayed as multiline.\n\n# ASYNCHRONOUS SHELL COMMANDS\n\nAsynchronous shell commands are used to start a command in the background and then resume operation without waiting for the command to finish.\nStdin, stdout, and stderr of the command are neither connected to the terminal nor the UI.\n\n# REMOTE COMMANDS\n\nOne of the more advanced features in lf is remote commands.\nAll clients connect to a server on startup.\nIt is possible to send commands to all or any of the connected clients over the common server.\nThis is used internally to notify file selection changes to other clients.\n\nTo use this feature, you need to use a client which supports communicating with a Unix domain socket.\nOpenBSD implementation of netcat (nc) is one such example.\nYou can use it to send a command to the socket file:\n\n\techo 'send echo hello world' | nc -U ${XDG_RUNTIME_DIR:-/tmp}/lf.${USER}.sock\n\nSince such a client may not be available everywhere, lf comes bundled with a command line flag to be used as such.\nWhen using lf, you do not need to specify the address of the socket file.\nThis is the recommended way of using remote commands since it is shorter and immune to socket file address changes:\n\n\tlf -remote 'send echo hello world'\n\nIn this command `send` is used to send the rest of the string as a command to all connected clients.\nYou can optionally give it an ID number to send a command to a single client:\n\n\tlf -remote 'send 1234 echo hello world'\n\nAll clients have a unique id number but you may not be aware of the id number when you are writing a command.\nFor this purpose, an `$id` variable is exported to the environment for shell commands.\nThe value of this variable is set to the process ID of the client.\nYou can use it to send a remote command from a client to the server which in return sends a command back to itself.\nSo now you can display a message in the current client by calling the following in a shell command:\n\n\tlf -remote \"send $id echo hello world\"\n\nSince lf does not have control flow syntax, remote commands are used for such needs.\nFor example, you can configure the number of columns in the UI with respect to the terminal width as follows:\n\n\tcmd recol %{{\n\t    if [ $lf_width -le 80 ]; then\n\t        lf -remote \"send $id set ratios 1:2\"\n\t    elif [ $lf_width -le 160 ]; then\n\t        lf -remote \"send $id set ratios 1:2:3\"\n\t    else\n\t        lf -remote \"send $id set ratios 1:2:3:5\"\n\t    fi\n\t}}\n\nIn addition, the `query` command can be used to obtain information about a specific lf instance by providing its id:\n\n\tlf -remote \"query $id maps\"\n\nThe following types of information are supported:\n\n\tmaps     list of mappings created by the 'map' command\n\tcmaps    list of mappings created by the 'cmap' command\n\tcmds     list of commands created by the 'cmd' command\n\tjumps    contents of the jump list, showing previously visited locations\n\thistory  list of previously executed commands on the command line\n\nThis is useful for scripting actions based on the internal state of lf.\nFor example, to select a previous command using fzf and execute it:\n\n\tmap <a-h> ${{\n\t\tclear\n\t\tcmd=$(\n\t\t\tlf -remote \"query $id history\" |\n\t\t\tawk -F'\\t' 'NR > 1 { print $NF}' |\n\t\t\tsort -u |\n\t\t\tfzf --reverse --prompt='Execute command: '\n\t\t)\n\t\tlf -remote \"send $id $cmd\"\n\t}}\n\nThere is also a `quit` command to quit the server when there are no connected clients left, and a `quit!` command to force quit the server by closing client connections first:\n\n\tlf -remote 'quit'\n\tlf -remote 'quit!'\n\nLastly, there is a `conn` command to connect the server to a client.\nThis should not be needed for users.\n\n# FILE OPERATIONS\n\nlf uses its own built-in copy and move operations by default.\nThese are implemented as asynchronous operations and progress is shown in the bottom ruler.\nThese commands do not overwrite existing files or directories with the same name.\nInstead, a suffix that is compatible with the `--backup=numbered` option in GNU cp is added to the new files or directories.\nOnly file modes and (some) timestamps can be preserved (see `preserve` option), all other attributes are ignored including ownership, context, and xattr.\nSpecial files such as character and block devices, named pipes, and sockets are skipped and links are not followed.\nMoving is performed using the rename operation of the underlying OS.\nFor cross-device moving, lf falls back to copying and then deletes the original files if there are no errors.\nOperation errors are shown in the message line as well as the log file and they do not preemptively finish the corresponding file operation.\n\nFile operations can be performed on the currently selected file or on multiple files by selecting them first.\nWhen you `copy` a file, lf doesn't actually copy the file on the disk, but only records its name to a file.\nThe actual file copying takes place when you `paste`.\nSimilarly `paste` after a `cut` operation moves the file.\n\nYou can customize copy and move operations by defining a `paste` command.\nThis is a special command that is called when it is defined instead of the built-in implementation.\nYou can use the following example as a starting point:\n\n\tcmd paste %{{\n\t    load=$(cat ~/.local/share/lf/files)\n\t    mode=$(echo \"$load\" | sed -n '1p')\n\t    list=$(echo \"$load\" | sed '1d')\n\t    if [ $mode = 'copy' ]; then\n\t        cp -R $list .\n\t    elif [ $mode = 'move' ]; then\n\t        mv $list .\n\t        rm ~/.local/share/lf/files\n\t        lf -remote 'send clear'\n\t    fi\n\t}}\n\nSome useful things to be considered are to use the backup (`--backup`) and/or preserve attributes (`-a`) options with `cp` and `mv` commands if they support it (i.e. GNU implementation), change the command type to asynchronous, or use `rsync` command with progress bar option for copying and feed the progress to the client periodically with remote `echo` calls.\n\nBy default, lf does not assign `delete` command to a key to protect new users.\nYou can customize file deletion by defining a `delete` command.\nYou can also assign a key to this command if you like.\nAn example command to move selected files to a trash folder and remove files completely after a prompt is provided in the example configuration file.\n\n# SEARCHING FILES\n\nThere are two mechanisms implemented in lf to search a file in the current directory.\nSearching is the traditional method to move the selection to a file matching a given pattern.\nFinding is an alternative way to search for a pattern possibly using fewer keystrokes.\n\nThe searching mechanism is implemented with commands `search` (default `/`), `search-back` (default `?`), `search-next` (default `n`), and `search-prev` (default `N`).\nYou can enable `globsearch` option to match with a glob pattern.\nGlobbing supports `*` to match any sequence, `?` to match any character, and `[...]` or `[^...]` to match character sets or ranges.\nYou can enable `incsearch` option to jump to the current match at each keystroke while typing.\nIn this mode, you can either use `cmd-enter` to accept the search or use `cmd-escape` to cancel the search.\nYou can also map some other commands with `cmap` to accept the search and execute the command immediately afterwards.\nFor example, you can use the right arrow key to finish the search and open the selected file with the following mapping:\n\n\tcmap <right> :cmd-enter; open\n\nThe finding mechanism is implemented with commands `find` (default `f`), `find-back` (default `F`), `find-next` (default `;`), `find-prev` (default `,`).\nYou can disable `anchorfind` option to match a pattern at an arbitrary position in the filename instead of the beginning.\nYou can set the number of keys to match using `findlen` option.\nIf you set this value to zero, then the keys are read until there is only a single match.\nThe default values of these two options are set to jump to the first file with the given initial.\n\nSome options effect both searching and finding.\nYou can disable `wrapscan` option to prevent searches from being wrapped around at the end of the file list.\nYou can disable `ignorecase` option to match cases in the pattern and the filename.\nThis option is already automatically overridden if the pattern contains upper-case characters.\nYou can disable `smartcase` option to disable this behavior.\nTwo similar options `ignoredia` and `smartdia` are provided to control matching diacritics in Latin letters.\n\n# OPENING FILES\n\nYou can define an `open` command (default `l` and `<right>`) to configure file opening.\nThis command is only called when the current file is not a directory, otherwise, the directory is entered instead.\nYou can define it just as you would define any other command:\n\n\tcmd open $vi $fx\n\nIt is possible to use different command types:\n\n\tcmd open &xdg-open $f\n\nYou may want to use either file extensions or mime types from `file` command:\n\n\tcmd open ${{\n\t    case $(file --mime-type -Lb $f) in\n\t        text/*) vi $fx;;\n\t        *) for f in $fx; do xdg-open $f > /dev/null 2> /dev/null & done;;\n\t    esac\n\t}}\n\nYou may want to use `setsid` before your opener command to have persistent processes that continue to run after lf quits.\n\nRegular shell commands (i.e. `$`) drop to the terminal which results in a flicker for commands that finish immediately (e.g. `xdg-open` in the above example).\nIf you want to use asynchronous shell commands (i.e. `&`) but also want to use the terminal when necessary (e.g. `vi` in the above example), you can use a remote command:\n\n\tcmd open &{{\n\t    case $(file --mime-type -Lb $f) in\n\t        text/*) lf -remote \"send $id \\$vi \\$fx\";;\n\t        *) for f in $fx; do xdg-open $f > /dev/null 2> /dev/null & done;;\n\t    esac\n\t}}\n\nNote that asynchronous shell commands run in their own process group by default so they do not require the manual use of `setsid`.\n\nThe following command is provided by default:\n\n\tcmd open &$OPENER $f\n\nYou may also use any other existing file openers as you like.\nPossible options are `libfile-mimeinfo-perl` (executable name is `mimeopen`), `rifle` (ranger's default file opener), or `mimeo` to name a few.\n\n# PREVIEWING FILES\n\nlf previews files on the preview pane by printing the file until the end or until the preview pane is filled.\nThis output can be enhanced by providing a custom preview script for filtering.\nThis can be used to highlight source codes, list contents of archive files or view PDF or image files to name a few.\nFor coloring lf recognizes ANSI escape codes.\n\nTo use this feature, you need to set the value of `previewer` option to the path of an executable file.\nFive arguments are passed to the file, (1) current file name, (2) width, (3) height, (4) horizontal position, and (5) vertical position of preview pane respectively.\nThe output of the execution is printed in the preview pane.\nYou may also want to use the same script in your pager mapping as well:\n\n\tset previewer ~/.config/lf/pv.sh\n\tmap i $~/.config/lf/pv.sh $f | less -R\n\nFor `less` pager, you may instead utilize `LESSOPEN` mechanism so that useful information about the file such as the full path of the file can still be displayed in the statusline below:\n\n\tset previewer ~/.config/lf/pv.sh\n\tmap i $LESSOPEN='| ~/.config/lf/pv.sh %s' less -R $f\n\nSince this script is called for each file selection change it needs to be as efficient as possible and this responsibility is left to the user.\nYou may use file extensions to determine the type of file more efficiently compared to obtaining mime types from `file` command.\nExtensions can then be used to match cleanly within a conditional:\n\n\t#!/bin/sh\n\n\tcase \"$1\" in\n\t    *.tar*) tar tf \"$1\";;\n\t    *.zip) unzip -l \"$1\";;\n\t    *.rar) unrar l \"$1\";;\n\t    *.7z) 7z l \"$1\";;\n\t    *.pdf) pdftotext \"$1\" -;;\n\t    *) highlight -O ansi \"$1\";;\n\tesac\n\nAnother important consideration for efficiency is the use of programs with short startup times for preview.\nFor this reason, `highlight` is recommended over `pygmentize` for syntax highlighting.\nBesides, it is also important that the application processes the file on the fly rather than first reading it to the memory and then doing the processing afterwards.\nThis is especially relevant for big files.\nlf automatically closes the previewer script output pipe with a SIGPIPE when enough lines are read.\nWhen everything else fails, you can make use of the height argument to only feed the first portion of the file to a program for preview.\nNote that some programs may not respond well to SIGPIPE to exit with a non-zero return code and avoid caching.\nYou may add a trailing `|| true` command to avoid such errors:\n\n\thighlight -O ansi \"$1\" || true\n\nYou may also use an existing preview filter as you like.\nYour system may already come with a preview filter named `lesspipe`.\nThese filters may have a mechanism to add user customizations as well.\nSee the related documentation for more information.\n\n# CHANGING DIRECTORY\n\nlf changes the working directory of the process to the current directory so that shell commands always work in the displayed directory.\nAfter quitting, it returns to the original directory where it is first launched like all shell programs.\nIf you want to stay in the current directory after quitting, you can use one of the example lfcd wrapper shell scripts provided in the repository at\nhttps://github.com/gokcehan/lf/tree/master/etc\n\nThere is a special command `on-cd` that runs a shell command when it is defined and the directory is changed.\nYou can define it just as you would define any other command:\n\n\tcmd on-cd &{{\n\t    bash -c '\n\t    # display git repository status in your prompt\n\t    source /usr/share/git/completion/git-prompt.sh\n\t    GIT_PS1_SHOWDIRTYSTATE=auto\n\t    GIT_PS1_SHOWSTASHSTATE=auto\n\t    GIT_PS1_SHOWUNTRACKEDFILES=auto\n\t    GIT_PS1_SHOWUPSTREAM=auto\n\t    git=$(__git_ps1 \" (%s)\")\n\t    fmt=\"\\033[32;1m%u@%h\\033[0m:\\033[34;1m%d\\033[0m\\033[1m%f$git\\033[0m\"\n\t    lf -remote \"send $id set promptfmt \\\"$fmt\\\"\"\n\t    '\n\t}}\n\nIf you want to print escape sequences, you may redirect `printf` output to `/dev/tty`.\nThe following xterm-specific escape sequence sets the terminal title to the working directory:\n\n\tcmd on-cd &{{\n\t    printf \"\\033]0; $PWD\\007\" > /dev/tty\n\t}}\n\nThis command runs whenever you change the directory but not on startup.\nYou can add an extra call to make it run on startup as well:\n\n\tcmd on-cd &{{ ... }}\n\ton-cd\n\nNote that all shell commands are possible but `%` and `&` are usually more appropriate as `$` and `!` causes flickers and pauses respectively.\n\nThere is also a `pre-cd` command, that works like `on-cd`, but is run before the directory is actually changed.\n\n# COLORS\n\nlf tries to automatically adapt its colors to the environment.\nIt starts with a default color scheme and updates colors using values of existing environment variables possibly by overwriting its previous values.\nColors are set in the following order:\n\n 1. default\n 2. LSCOLORS (Mac/BSD ls)\n 3. LS_COLORS (GNU ls)\n 4. LF_COLORS (lf specific)\n 5. colors file (lf specific)\n\nPlease refer to the corresponding man pages for more information about `LSCOLORS` and `LS_COLORS`.\n`LF_COLORS` is provided with the same syntax as `LS_COLORS` in case you want to configure colors only for lf but not ls.\nThis can be useful since there are some differences between ls and lf, though one should expect the same behavior for common cases.\nThe colors file (refer to the [CONFIGURATION section](https://github.com/gokcehan/lf/blob/master/doc.md#configuration)) is provided for easier configuration without environment variables.\nThis file should consist of whitespace-separated pairs with a `#` character to start comments until the end of the line.\n\nYou can configure lf colors in two different ways.\nFirst, you can only configure 8 basic colors used by your terminal and lf should pick up those colors automatically.\nDepending on your terminal, you should be able to select your colors from a 24-bit palette.\nThis is the recommended approach as colors used by other programs will also match each other.\n\nSecond, you can set the values of environment variables or colors file mentioned above for fine-grained customization.\nNote that `LS_COLORS/LF_COLORS` are more powerful than `LSCOLORS` and they can be used even when GNU programs are not installed on the system.\nYou can combine this second method with the first method for the best results.\n\nLastly, you may also want to configure the colors of the prompt line to match the rest of the colors.\nColors of the prompt line can be configured using the `promptfmt` option which can include hardcoded colors as ANSI escapes.\nSee the default value of this option to have an idea about how to color this line.\n\nIt is worth noting that lf uses as many colors advertised by your terminal's entry in terminfo or infocmp databases on your system.\nIf an entry is not present, it falls back to an internal database.\nIf your terminal supports 24-bit colors but either does not have a database entry or does not advertise all capabilities, you can enable support by setting the `$COLORTERM` variable to `truecolor` or ensuring `$TERM` is set to a value that ends with `-truecolor`.\n\nDefault lf colors are mostly taken from GNU dircolors defaults.\nThese defaults use 8 basic colors and bold attribute.\nDefault dircolors entries with background colors are simplified to avoid confusion with current file selection in lf.\nSimilarly, there are only file type matchings and extension matchings are left out for simplicity.\nDefault values are as follows given with their matching order in lf:\n\n\tln  01;36\n\tor  31;01\n\ttw  01;34\n\tow  01;34\n\tst  01;34\n\tdi  01;34\n\tpi  33\n\tso  01;35\n\tbd  33;01\n\tcd  33;01\n\tsu  01;32\n\tsg  01;32\n\tex  01;32\n\tfi  00\n\nNote that lf first tries matching file names and then falls back to file types.\nThe full order of matchings from most specific to least are as follows:\n\n 1. Full Path (e.g. `~/.config/lf/lfrc`)\n 2. Dir Name  (e.g. `.git/`) (only matches dirs with a trailing slash at the end)\n 3. File Type (e.g. `ln`) (except `fi`)\n 4. File Name (e.g. `README*`)\n 5. File Name (e.g. `*README`)\n 6. Base Name (e.g. `README.*`)\n 7. Extension (e.g. `*.txt`)\n 8. Default   (i.e. `fi`)\n\nFor example, given a regular text file `/path/to/README.txt`, the following entries are checked in the configuration and the first one to match is used:\n\n 1. `/path/to/README.txt`\n 2. (skipped since the file is not a directory)\n 3. (skipped since the file is of type `fi`)\n 4. `README.txt*`\n 5. `*README.txt`\n 6. `README.*`\n 7. `*.txt`\n 8. `fi`\n\nGiven a regular directory `/path/to/example.d`, the following entries are checked in the configuration and the first one to match is used:\n\n 1. `/path/to/example.d`\n 2. `example.d/`\n 3. `di`\n 4. `example.d*`\n 5. `*example.d`\n 6. `example.*`\n 7. `*.d`\n 8. `fi`\n\nNote that glob-like patterns do not perform glob matching for performance reasons.\n\nFor example, you can set a variable as follows:\n\n\texport LF_COLORS=\"~/Documents=01;31:~/Downloads=01;31:~/.local/share=01;31:~/.config/lf/lfrc=31:.git/=01;32:.git*=32:*.gitignore=32:*Makefile=32:README.*=33:*.txt=34:*.md=34:ln=01;36:di=01;34:ex=01;32:\"\n\nHaving all entries on a single line can make it hard to read.\nYou may instead divide it into multiple lines in between double quotes by escaping newlines with backslashes as follows:\n\n\texport LF_COLORS=\"\\\n\t~/Documents=01;31:\\\n\t~/Downloads=01;31:\\\n\t~/.local/share=01;31:\\\n\t~/.config/lf/lfrc=31:\\\n\t.git/=01;32:\\\n\t.git*=32:\\\n\t*.gitignore=32:\\\n\t*Makefile=32:\\\n\tREADME.*=33:\\\n\t*.txt=34:\\\n\t*.md=34:\\\n\tln=01;36:\\\n\tdi=01;34:\\\n\tex=01;32:\\\n\t\"\n\nThe `ln` entry supports the special value `target`, which will use the link target to select a style. File name rules will still apply based on the link's name -- this mirrors GNU's `ls` and `dircolors` behavior.\nHaving such a long variable definition in a shell configuration file might be undesirable.\nYou may instead use the colors file (refer to the [CONFIGURATION section](https://github.com/gokcehan/lf/blob/master/doc.md#configuration)) for configuration.\nA sample colors file can be found at\nhttps://github.com/gokcehan/lf/blob/master/etc/colors.example\nYou may also see the wiki page for ANSI escape codes\nhttps://en.wikipedia.org/wiki/ANSI_escape_code\n\n# ICONS\n\nIcons are configured using `LF_ICONS` environment variable or an icons file (refer to the [CONFIGURATION section](https://github.com/gokcehan/lf/blob/master/doc.md#configuration)).\nThe variable uses the same syntax as `LS_COLORS/LF_COLORS`.\nInstead of colors, you should put a single characters as values of entries.\nThe `ln` entry supports the special value `target`, which will use the link target to select a icon. File name rules will still apply based on the link's name -- this mirrors GNU's `ls` and `dircolors` behavior.\nThe icons file (refer to the [CONFIGURATION section](https://github.com/gokcehan/lf/blob/master/doc.md#configuration)) should consist of whitespace-separated arrays with a `#` character to start comments until the end of the line.\nEach line should contain 1-3 columns, first column is filetype or filename pattern, second column is the icon, third column is an optional icon color. If there is only one column, means to disable rule for this filetype or pattern.\nDo not forget to add `set icons true` to your `lfrc` to see the icons.\nDefault values are as follows given with their matching order in lf:\n\n\tln  l\n\tor  l\n\ttw  t\n\tow  d\n\tst  t\n\tdi  d\n\tpi  p\n\tso  s\n\tbd  b\n\tcd  c\n\tsu  u\n\tsg  g\n\tex  x\n\tfi  -\n\nA sample icons file can be found at\nhttps://github.com/gokcehan/lf/blob/master/etc/icons.example\n\nA sample colored icons file can be found at\nhttps://github.com/gokcehan/lf/blob/master/etc/icons_colored.example\n"
        },
        {
          "name": "doc.txt",
          "type": "blob",
          "size": 70.955078125,
          "content": "NAME\n\nlf - terminal file manager\n\nSYNOPSIS\n\nlf [-command command] [-config path] [-cpuprofile path] [-doc]\n[-last-dir-path path] [-log path] [-memprofile path] [-print-last-dir]\n[-print-selection] [-remote command] [-selection-path path] [-server]\n[-single] [-version] [-help] [cd-or-select-path]\n\nDESCRIPTION\n\nlf is a terminal file manager.\n\nThe source code can be found in the repository at\nhttps://github.com/gokcehan/lf\n\nThis documentation can either be read from the terminal using lf -doc or\nonline at https://github.com/gokcehan/lf/blob/master/doc.md You can also\nuse the doc command (default <f-1>) inside lf to view the documentation\nin a pager. A man page with the same content is also available in the\nrepository at https://github.com/gokcehan/lf/blob/master/lf.1\n\nYou can run lf -help to see descriptions of command line options.\n\nQUICK REFERENCE\n\nThe following commands are provided by lf:\n\n    quit                     (default 'q')\n    up                       (default 'k' and '<up>')\n    half-up                  (default '<c-u>')\n    page-up                  (default '<c-b>' and '<pgup>')\n    scroll-up                (default '<c-y>')\n    down                     (default 'j' and '<down>')\n    half-down                (default '<c-d>')\n    page-down                (default '<c-f>' and '<pgdn>')\n    scroll-down              (default '<c-e>')\n    updir                    (default 'h' and '<left>')\n    open                     (default 'l' and '<right>')\n    jump-next                (default ']')\n    jump-prev                (default '[')\n    top                      (default 'gg' and '<home>')\n    bottom                   (default 'G' and '<end>')\n    high                     (default 'H')\n    middle                   (default 'M')\n    low                      (default 'L')\n    toggle\n    invert                   (default 'v')\n    invert-below\n    unselect                 (default 'u')\n    glob-select\n    glob-unselect\n    calcdirsize\n    clearmaps\n    copy                     (default 'y')\n    cut                      (default 'd')\n    paste                    (default 'p')\n    clear                    (default 'c')\n    sync\n    draw\n    redraw                   (default '<c-l>')\n    load\n    reload                   (default '<c-r>')\n    echo\n    echomsg\n    echoerr\n    cd\n    select\n    delete         (modal)\n    rename         (modal)   (default 'r')\n    source\n    push\n    read           (modal)   (default ':')\n    shell          (modal)   (default '$')\n    shell-pipe     (modal)   (default '%')\n    shell-wait     (modal)   (default '!')\n    shell-async    (modal)   (default '&')\n    find           (modal)   (default 'f')\n    find-back      (modal)   (default 'F')\n    find-next                (default ';')\n    find-prev                (default ',')\n    search         (modal)   (default '/')\n    search-back    (modal)   (default '?')\n    search-next              (default 'n')\n    search-prev              (default 'N')\n    filter         (modal)\n    setfilter\n    mark-save      (modal)   (default 'm')\n    mark-load      (modal)   (default \"'\")\n    mark-remove    (modal)   (default '\"')\n    tag\n    tag-toggle               (default 't')\n\nThe following command line commands are provided by lf:\n\n    cmd-escape               (default '<esc>')\n    cmd-complete             (default '<tab>')\n    cmd-menu-complete\n    cmd-menu-complete-back\n    cmd-menu-accept\n    cmd-enter                (default '<c-j>' and '<enter>')\n    cmd-interrupt            (default '<c-c>')\n    cmd-history-next         (default '<c-n>' and '<down>')\n    cmd-history-prev         (default '<c-p>' and '<up>')\n    cmd-left                 (default '<c-b>' and '<left>')\n    cmd-right                (default '<c-f>' and '<right>')\n    cmd-home                 (default '<c-a>' and '<home>')\n    cmd-end                  (default '<c-e>' and '<end>')\n    cmd-delete               (default '<c-d>' and '<delete>')\n    cmd-delete-back          (default '<backspace>' and '<backspace2>')\n    cmd-delete-home          (default '<c-u>')\n    cmd-delete-end           (default '<c-k>')\n    cmd-delete-unix-word     (default '<c-w>')\n    cmd-yank                 (default '<c-y>')\n    cmd-transpose            (default '<c-t>')\n    cmd-transpose-word       (default '<a-t>')\n    cmd-word                 (default '<a-f>')\n    cmd-word-back            (default '<a-b>')\n    cmd-delete-word          (default '<a-d>')\n    cmd-delete-word-back     (default '<a-backspace>' and '<a-backspace2>')\n    cmd-capitalize-word      (default '<a-c>')\n    cmd-uppercase-word       (default '<a-u>')\n    cmd-lowercase-word       (default '<a-l>')\n\nThe following options can be used to customize the behavior of lf:\n\n    anchorfind        bool      (default true)\n    autoquit          bool      (default true)\n    borderfmt         string    (default \"\\033[0m\")\n    cleaner           string    (default '')\n    copyfmt           string    (default \"\\033[7;33m\")\n    cursoractivefmt   string    (default \"\\033[7m\")\n    cursorparentfmt   string    (default \"\\033[7m\")\n    cursorpreviewfmt  string    (default \"\\033[4m\")\n    cutfmt            string    (default \"\\033[7;31m\")\n    dircache          bool      (default true)\n    dircounts         bool      (default false)\n    dirfirst          bool      (default true)\n    dironly           bool      (default false)\n    dirpreviews       bool      (default false)\n    drawbox           bool      (default false)\n    dupfilefmt        string    (default '%f.~%n~')\n    errorfmt          string    (default \"\\033[7;31;47m\")\n    filesep           string    (default \"\\n\")\n    findlen           int       (default 1)\n    globfilter        bool      (default false)\n    globsearch        bool      (default false)\n    hidden            bool      (default false)\n    hiddenfiles       []string  (default '.*' for Unix and '' for Windows)\n    history           bool      (default true)\n    icons             bool      (default false)\n    ifs               string    (default '')\n    ignorecase        bool      (default true)\n    ignoredia         bool      (default true)\n    incfilter         bool      (default false)\n    incsearch         bool      (default false)\n    info              []string  (default '')\n    infotimefmtnew    string    (default 'Jan _2 15:04')\n    infotimefmtold    string    (default 'Jan _2  2006')\n    locale            string    (default '')\n    mouse             bool      (default false)\n    number            bool      (default false)\n    numberfmt         string    (default \"\\033[33m\")\n    period            int       (default 0)\n    preserve          []string  (default \"mode\")\n    preview           bool      (default true)\n    previewer         string    (default '')\n    promptfmt         string    (default \"\\033[32;1m%u@%h\\033[0m:\\033[34;1m%d\\033[0m\\033[1m%f\\033[0m\")\n    ratios            []int     (default '1:2:3')\n    relativenumber    bool      (default false)\n    reverse           bool      (default false)\n    roundbox          bool      (default false)\n    rulerfmt          string    (default \"  %a|  %p|  \\033[7;31m %m \\033[0m|  \\033[7;33m %c \\033[0m|  \\033[7;35m %s \\033[0m|  \\033[7;34m %f \\033[0m|  %i/%t\")\n    scrolloff         int       (default 0)\n    selectfmt         string    (default \"\\033[7;35m\")\n    selmode           string    (default 'all')\n    shell             string    (default 'sh' for Unix and 'cmd' for Windows)\n    shellflag         string    (default '-c' for Unix and '/c' for Windows)\n    shellopts         []string  (default '')\n    showbinds         bool      (default true)\n    sixel             bool      (default false)\n    smartcase         bool      (default true)\n    smartdia          bool      (default false)\n    sortby            string    (default 'natural')\n    statfmt           string    (default \"\\033[36m%p\\033[0m| %c| %u| %g| %S| %t| -> %l\")\n    tabstop           int       (default 8)\n    tagfmt            string    (default \"\\033[31m\")\n    tempmarks         string    (default '')\n    timefmt           string    (default 'Mon Jan _2 15:04:05 2006')\n    truncatechar      string    (default '~')\n    truncatepct       int       (default 100)\n    waitmsg           string    (default 'Press any key to continue')\n    watch             bool      (default false)\n    wrapscan          bool      (default true)\n    wrapscroll        bool      (default false)\n    user_{option}     string    (default none)\n\nThe following environment variables are exported for shell commands:\n\n    f\n    fs\n    fx\n    id\n    PWD\n    OLDPWD\n    LF_LEVEL\n    OPENER\n    VISUAL\n    EDITOR\n    PAGER\n    SHELL\n    lf\n    lf_{option}\n    lf_user_{option}\n    lf_width\n    lf_height\n    lf_count\n    lf_mode\n\nThe following special shell commands are used to customize the behavior\nof lf when defined:\n\n    open\n    paste\n    rename\n    delete\n    pre-cd\n    on-cd\n    on-focus-gained\n    on-focus-lost\n    on-init\n    on-select\n    on-redraw\n    on-quit\n\nThe following commands/keybindings are provided by default:\n\n    Unix\n    cmd open &$OPENER \"$f\"\n    map e $$EDITOR \"$f\"\n    map i $$PAGER \"$f\"\n    map w $$SHELL\n    cmd doc $$lf -doc | $PAGER\n    map <f-1> doc\n    cmd maps $lf -remote \"query $id maps\" | $PAGER\n    cmd cmaps $lf -remote \"query $id cmaps\" | $PAGER\n    cmd cmds $lf -remote \"query $id cmds\" | $PAGER\n\n    Windows\n    cmd open &%OPENER% %f%\n    map e $%EDITOR% %f%\n    map i !%PAGER% %f%\n    map w $%SHELL%\n    cmd doc !%lf% -doc | %PAGER%\n    map <f-1> doc\n    cmd maps !%lf% -remote \"query %id% maps\" | %PAGER%\n    cmd cmaps !%lf% -remote \"query %id% cmaps\" | %PAGER%\n    cmd cmds !%lf% -remote \"query %id% cmds\" | %PAGER%\n\nThe following additional keybindings are provided by default:\n\n    map zh set hidden!\n    map zr set reverse!\n    map zn set info\n    map zs set info size\n    map zt set info time\n    map za set info size:time\n    map sn :set sortby natural; set info\n    map ss :set sortby size; set info size\n    map st :set sortby time; set info time\n    map sa :set sortby atime; set info atime\n    map sc :set sortby ctime; set info ctime\n    map se :set sortby ext; set info\n    map gh cd ~\n    map <space> :toggle; down\n\nIf the mouse option is enabled, mouse buttons have the following default\neffects:\n\n    Left mouse button\n        Click on a file or directory to select it.\n\n    Right mouse button\n        Enter a directory or open a file. Also works on the preview window.\n\n    Scroll wheel\n        Move up or down. If Ctrl is pressed, scroll up or down.\n\nCONFIGURATION\n\nConfiguration files should be located at:\n\n    OS       system-wide               user-specific\n    Unix     /etc/lf/lfrc              ~/.config/lf/lfrc\n    Windows  C:\\ProgramData\\lf\\lfrc    C:\\Users\\<user>\\AppData\\Local\\lf\\lfrc\n\nThe colors file should be located at:\n\n    OS       system-wide               user-specific\n    Unix     /etc/lf/colors            ~/.config/lf/colors\n    Windows  C:\\ProgramData\\lf\\colors  C:\\Users\\<user>\\AppData\\Local\\lf\\colors\n\nThe icons file should be located at:\n\n    OS       system-wide               user-specific\n    Unix     /etc/lf/icons             ~/.config/lf/icons\n    Windows  C:\\ProgramData\\lf\\icons   C:\\Users\\<user>\\AppData\\Local\\lf\\icons\n\nThe selection file should be located at:\n\n    Unix     ~/.local/share/lf/files\n    Windows  C:\\Users\\<user>\\AppData\\Local\\lf\\files\n\nThe marks file should be located at:\n\n    Unix     ~/.local/share/lf/marks\n    Windows  C:\\Users\\<user>\\AppData\\Local\\lf\\marks\n\nThe tags file should be located at:\n\n    Unix     ~/.local/share/lf/tags\n    Windows  C:\\Users\\<user>\\AppData\\Local\\lf\\tags\n\nThe history file should be located at:\n\n    Unix     ~/.local/share/lf/history\n    Windows  C:\\Users\\<user>\\AppData\\Local\\lf\\history\n\nYou can configure these locations with the following variables given\nwith their order of precedences and their default values:\n\n    Unix\n        $LF_CONFIG_HOME\n        $XDG_CONFIG_HOME\n        ~/.config\n\n        $LF_DATA_HOME\n        $XDG_DATA_HOME\n        ~/.local/share\n\n    Windows\n        %ProgramData%\n        C:\\ProgramData\n\n        %LF_CONFIG_HOME%\n        %LOCALAPPDATA%\n        C:\\Users\\<user>\\AppData\\Local\n\nA sample configuration file can be found at\nhttps://github.com/gokcehan/lf/blob/master/etc/lfrc.example\n\nCOMMANDS\n\nThis section shows information about built-in commands. Modal commands\ndo not take any arguments, but instead change the operation mode to read\ntheir input conveniently, and so they are meant to be assigned to\nkeybindings.\n\nquit (default q)\n\nQuit lf and return to the shell.\n\nup (default k and <up>), half-up (default <c-u>), page-up (default <c-b> and <pgup>), scroll-up (default <c-y>), down (default j and <down>), half-down (default <c-d>), page-down (default <c-f> and <pgdn>), scroll-down (default <c-e>)\n\nMove/scroll the current file selection upwards/downwards by one/half a\npage/full page.\n\nupdir (default h and <left>)\n\nChange the current working directory to the parent directory.\n\nopen (default l and <right>)\n\nIf the current file is a directory, then change the current directory to\nit, otherwise, execute the open command. A default open command is\nprovided to call the default system opener asynchronously with the\ncurrent file as the argument. A custom open command can be defined to\noverride this default.\n\njump-next (default ]), jump-prev (default [)\n\nChange the current working directory to the next/previous jumplist item.\n\ntop (default gg and <home>), bottom (default G and <end>)\n\nMove the current file selection to the top/bottom of the directory. A\ncount can be specified to move to a specific line, for example, use 3G\nto move to the third line.\n\nhigh (default H), middle (default M), low (default L)\n\nMove the current file selection to the high/middle/low of the screen.\n\ntoggle\n\nToggle the selection of the current file or files given as arguments.\n\ninvert (default v)\n\nReverse the selection of all files in the current directory (i.e. toggle\nall files). Selections in other directories are not affected by this\ncommand. You can define a new command to select all files in the\ndirectory by combining invert with unselect (i.e.\ncmd select-all :unselect; invert), though this will also remove\nselections in other directories.\n\ninvert-below\n\nReverse the selection (i.e. toggle) of all files at or after the current\nfile in the current directory.\n\nTo select a contiguous block of files, use this command on the first\nfile you want to select. Then, move down to the first file you do not\nwant to select (the one after the end of the desired selection) and use\nthis command again. This achieves an effect similar to the visual mode\nin Vim.\n\nThis command is experimental and may be removed once a better\nreplacement for the visual mode is implemented in lf. If you'd like to\nexperiment with using this command, you should bind it to a key (e.g. V)\nfor a better experience.\n\nunselect (default u)\n\nRemove the selection of all files in all directories.\n\nglob-select, glob-unselect\n\nSelect/unselect files that match the given glob.\n\ncalcdirsize\n\nCalculate the total size for each of the selected directories. Option\ninfo should include size and option dircounts should be disabled to show\nthis size. If the total size of a directory is not calculated, it will\nbe shown as -.\n\nclearmaps\n\nRemove all keybindings associated with the map command. This command can\nbe used in the config file to remove the default keybindings. For safety\npurposes, : is left mapped to the read command, and cmap keybindings are\nretained so that it is still possible to exit lf using :quit.\n\ncopy (default y)\n\nIf there are no selections, save the path of the current file to the\ncopy buffer, otherwise, copy the paths of selected files.\n\ncut (default d)\n\nIf there are no selections, save the path of the current file to the cut\nbuffer, otherwise, copy the paths of selected files.\n\npaste (default p)\n\nCopy/Move files in the copy/cut buffer to the current working directory.\nA custom paste command can be defined to override this default.\n\nclear (default c)\n\nClear file paths in copy/cut buffer.\n\nsync\n\nSynchronize copied/cut files with the server. This command is\nautomatically called when required.\n\ndraw\n\nDraw the screen. This command is automatically called when required.\n\nredraw (default <c-l>)\n\nSynchronize the terminal and redraw the screen.\n\nload\n\nLoad modified files and directories. This command is automatically\ncalled when required.\n\nreload (default <c-r>)\n\nFlush the cache and reload all files and directories.\n\necho\n\nPrint the given arguments to the message line at the bottom.\n\nechomsg\n\nPrint the given arguments to the message line at the bottom and also to\nthe log file.\n\nechoerr\n\nPrint given arguments to the message line at the bottom as errorfmt and\nalso to the log file.\n\ncd\n\nChange the working directory to the given argument.\n\nselect\n\nChange the current file selection to the given argument.\n\ndelete (modal)\n\nRemove the current file or selected file(s). A custom delete command can\nbe defined to override this default.\n\nrename (modal) (default r)\n\nRename the current file using the built-in method. A custom rename\ncommand can be defined to override this default.\n\nsource\n\nRead the configuration file given in the argument.\n\npush\n\nSimulate key pushes given in the argument.\n\nread (modal) (default :)\n\nRead a command to evaluate.\n\nshell (modal) (default $)\n\nRead a shell command to execute.\n\nshell-pipe (modal) (default %)\n\nRead a shell command to execute piping its standard I/O to the bottom\nstatline.\n\nshell-wait (modal) (default !)\n\nRead a shell command to execute and wait for a key press in the end.\n\nshell-async (modal) (default &)\n\nRead a shell command to execute asynchronously without standard I/O.\n\nfind (modal) (default f), find-back (modal) (default F), find-next (default ;), find-prev (default ,)\n\nRead key(s) to find the appropriate file name match in the\nforward/backward direction and jump to the next/previous match.\n\nsearch (default /), search-back (default ?), search-next (default n), search-prev (default N)\n\nRead a pattern to search for a file name match in the forward/backward\ndirection and jump to the next/previous match.\n\nfilter (modal), setfilter\n\nCommand filter reads a pattern to filter out and only view files\nmatching the pattern. Command setfilter does the same but uses an\nargument to set the filter immediately. You can supply an argument to\nfilter to use as the starting prompt.\n\nmark-save (modal) (default m)\n\nSave the current directory as a bookmark assigned to the given key.\n\nmark-load (modal) (default ')\n\nChange the current directory to the bookmark assigned to the given key.\nA special bookmark ' holds the previous directory after a mark-load, cd,\nor select command.\n\nmark-remove (modal) (default \")\n\nRemove a bookmark assigned to the given key.\n\ntag\n\nTag a file with * or a single-width character given in the argument. You\ncan define a new tag-clearing command by combining tag with tag-toggle\n(i.e. cmd tag-clear :tag; tag-toggle).\n\ntag-toggle (default t)\n\nTag a file with * or a single width character given in the argument if\nthe file is untagged, otherwise remove the tag.\n\nCOMMAND LINE COMMANDS\n\nThe prompt character specifies which of the several command-line modes\nyou are in. For example, the read command takes you to the : mode.\n\nWhen the cursor is at the first character in : mode, pressing one of the\nkeys !, $, %, or & takes you to the corresponding mode. You can go back\nwith cmd-delete-back (<backspace> by default).\n\nThe command line commands should be mostly compatible with readline\nkeybindings. A character refers to a Unicode code point, a word consists\nof letters and digits, and a unix word consists of any non-blank\ncharacters.\n\ncmd-escape (default <esc>)\n\nQuit command line mode and return to normal mode.\n\ncmd-complete (default <tab>)\n\nAutocomplete the current word.\n\ncmd-menu-complete, cmd-menu-complete-back\n\nAutocomplete the current word with the menu selection. You need to\nassign keys to these commands (e.g.\ncmap <tab> cmd-menu-complete; cmap <backtab> cmd-menu-complete-back).\nYou can use the assigned keys to display the menu and then cycle through\ncompletion options.\n\ncmd-menu-accept\n\nAccept the currently selected match in menu completion and close the\nmenu.\n\ncmd-enter (default <c-j> and <enter>)\n\nExecute the current line.\n\ncmd-interrupt (default <c-c>)\n\nInterrupt the current shell-pipe command and return to the normal mode.\n\ncmd-history-next (default <c-n> and <down>), cmd-history-prev (default <c-p> and <up>)\n\nGo to the next/previous item in the history.\n\ncmd-left (default <c-b> and <left>), cmd-right (default <c-f> and <right>)\n\nMove the cursor to the left/right.\n\ncmd-home (default <c-a> and <home>), cmd-end (default <c-e> and <end>)\n\nMove the cursor to the beginning/end of the line.\n\ncmd-delete (default <c-d> and <delete>)\n\nDelete the next character.\n\ncmd-delete-back (default <backspace> and <backspace2>)\n\nDelete the previous character. When at the beginning of a prompt,\nreturns either to normal mode or to : mode.\n\ncmd-delete-home (default <c-u>), cmd-delete-end (default <c-k>)\n\nDelete everything up to the beginning/end of the line.\n\ncmd-delete-unix-word (default <c-w>)\n\nDelete the previous unix word.\n\ncmd-yank (default <c-y>)\n\nPaste the buffer content containing the last deleted item.\n\ncmd-transpose (default <c-t>), cmd-transpose-word (default <a-t>)\n\nTranspose the positions of the last two characters/words.\n\ncmd-word (default <a-f>), cmd-word-back (default <a-b>)\n\nMove the cursor by one word in the forward/backward direction.\n\ncmd-delete-word (default <a-d>)\n\nDelete the next word in the forward direction.\n\ncmd-delete-word-back (default <a-backspace> and <a-backspace2>)\n\nDelete the previous word in the backward direction.\n\ncmd-capitalize-word (default <a-c>), cmd-uppercase-word (default <a-u>), cmd-lowercase-word (default <a-l>)\n\nCapitalize/uppercase/lowercase the current word and jump to the next\nword.\n\nOPTIONS\n\nThis section shows information about options to customize the behavior.\nCharacter : is used as the separator for list options []int and\n[]string.\n\nanchorfind (bool) (default true)\n\nWhen this option is enabled, the find command starts matching patterns\nfrom the beginning of file names, otherwise, it can match at an\narbitrary position.\n\nautoquit (bool) (default true)\n\nAutomatically quit the server when there are no clients left connected.\n\nborderfmt (string) (default \\033[0m)\n\nFormat string of the box drawing characters enabled by the drawbox\noption.\n\ncleaner (string) (default ``) (not called if empty)\n\nSet the path of a cleaner file. The file should be executable. This file\nis called if previewing is enabled, the previewer is set, and the\npreviously selected file has its preview cache disabled. The following\narguments are passed to the file, (1) current file name, (2) width, (3)\nheight, (4) horizontal position, (5) vertical position of preview pane\nand (6) next file name to be previewed respectively. Preview cleaning is\ndisabled when the value of this option is left empty.\n\ncopyfmt (string) (default \\033[7;33m)\n\nFormat string of the indicator for files to be copied.\n\ncursoractivefmt (string) (default \\033[7m), cursorparentfmt string (default \\033[7m), cursorpreviewfmt string (default \\033[4m)\n\nFormat strings for highlighting the cursor. cursoractivefmt applies in\nthe current directory pane, cursorparentfmt applies in panes that show\nparents of the current directory, and cursorpreviewfmt applies in panes\nthat preview directories.\n\nThe default is to make the active cursor and the parent directory cursor\ninverted. The preview cursor is underlined.\n\nSome other possibilities to consider for the preview or parent cursors:\nan empty string for no cursor, \\033[7;2m for dimmed inverted text\n(visibility varies by terminal), \\033[7;90m for inverted text with grey\n(aka \"brightblack\") background.\n\nIf the format string contains the characters %s, it is interpreted as a\nformat string for fmt.Sprintf. Such a string should end with the\nterminal reset sequence. For example, \\033[4m%s\\033[0m has the same\neffect as \\033[4m.\n\ncutfmt (string) (default \\033[7;31m)\n\nFormat string of the indicator for files to be cut.\n\ndircache (bool) (default true)\n\nCache directory contents.\n\ndircounts (bool) (default false)\n\nWhen this option is enabled, directory sizes show the number of items\ninside instead of the total size of the directory, which needs to be\ncalculated for each directory using calcdirsize. This information needs\nto be calculated by reading the directory and counting the items inside.\nTherefore, this option is disabled by default for performance reasons.\nThis option only has an effect when info has a size field and the pane\nis wide enough to show the information. 999 items are counted per\ndirectory at most, and bigger directories are shown as 999+.\n\ndirfirst (bool) (default true)\n\nShow directories first above regular files.\n\ndironly (bool) (default false)\n\nShow only directories.\n\ndirpreviews (bool) (default false)\n\nIf enabled, directories will also be passed to the previewer script.\nThis allows custom previews for directories.\n\ndrawbox (bool) (default false)\n\nDraw boxes around panes with box drawing characters.\n\ndupfilefmt (string) (default %f.~%n~)\n\nFormat string of file name when creating duplicate files. With the\ndefault format, copying a file abc.txt to the same directory will result\nin a duplicate file called abc.txt.~1~. Special expansions are provided,\n%f as the file name, %b for the basename (file name without extension),\n%e as the extension (including the dot) and %n as the number of\nduplicates.\n\nerrorfmt (string) (default \\033[7;31;47m)\n\nFormat string of error messages shown in the bottom message line.\n\nIf the format string contains the characters %s, it is interpreted as a\nformat string for fmt.Sprintf. Such a string should end with the\nterminal reset sequence. For example, \\033[4m%s\\033[0m has the same\neffect as \\033[4m.\n\nfilesep (string) (default \\n)\n\nFile separator used in environment variables fs and fx.\n\nfindlen (int) (default 1)\n\nNumber of characters prompted for the find command. When this value is\nset to 0, find command prompts until there is only a single match left.\n\nglobfilter (bool) (default false)\n\nPatterns are treated as globs for the filter command, see globsearch for\nmore details.\n\nglobsearch (bool) (default false)\n\nWhen this option is enabled, search command patterns are considered as\nglobs, otherwise, they are literals. With globbing, * matches any\nsequence, ? matches any character, and [...] or [^...] matches character\nsets or ranges. Otherwise, these characters are interpreted as they are.\n\nhidden (bool) (default false)\n\nShow hidden files. On Unix systems, hidden files are determined by the\nvalue of hiddenfiles. On Windows, files with hidden attributes are also\nconsidered hidden files.\n\nhiddenfiles ([]string) (default .* for Unix and `` for Windows)\n\nList of hidden file glob patterns. Patterns can be given as relative or\nabsolute paths. Globbing supports the usual special characters, * to\nmatch any sequence, ? to match any character, and [...] or [^...] to\nmatch character sets or ranges. In addition, if a pattern starts with !,\nthen its matches are excluded from hidden files. To add multiple\npatterns, use : as a separator. Example: .*:lost+found:*.bak\n\nhistory (bool) (default true)\n\nSave command history.\n\nicons (bool) (default false)\n\nShow icons before each item in the list.\n\nifs (string) (default ``)\n\nSets IFS variable in shell commands. It works by adding the assignment\nto the beginning of the command string as IFS=...; .... The reason is\nthat IFS variable is not inherited by the shell for security reasons.\nThis method assumes a POSIX shell syntax so it can fail for non-POSIX\nshells. This option has no effect when the value is left empty. This\noption does not have any effect on Windows.\n\nignorecase (bool) (default true)\n\nIgnore case in sorting and search patterns.\n\nignoredia (bool) (default true)\n\nIgnore diacritics in sorting and search patterns.\n\nincsearch (bool) (default false)\n\nJump to the first match after each keystroke during searching.\n\nincfilter (bool) (default false)\n\nApply filter pattern after each keystroke during filtering.\n\ninfo ([]string) (default ``)\n\nA list of information that is shown for directory items at the right\nside of the pane. Currently supported information types are size, time,\natime, ctime, perm, user and group. Information is only shown when the\npane width is more than twice the width of information.\n\ninfotimefmtnew (string) (default Jan _2 15:04)\n\nFormat string of the file time shown in the info column when it matches\nthis year.\n\ninfotimefmtold (string) (default Jan _2  2006)\n\nFormat string of the file time shown in the info column when it doesn't\nmatch this year.\n\nlocale (string) (default ``)\n\nAn IETF BCP 47 language tag (e.g. zh-CN) for specifying the locale used\nwhen using sort type natural and name.\n\nAn empty string means disable locale ordering, and the special value *\nis used to indicate reading the locale setting from the system\nenvironment.\n\nmouse (bool) (default false)\n\nSend mouse events as input.\n\nnumber (bool) (default false)\n\nShow the position number for directory items on the left side of the\npane. When the relativenumber option is enabled, only the current line\nshows the absolute position and relative positions are shown for the\nrest.\n\nnumberfmt (string) (default \\033[33m)\n\nFormat string of the position number for each line.\n\nperiod (int) (default 0)\n\nSet the interval in seconds for periodic checks of directory updates.\nThis works by periodically calling the load command. Note that\ndirectories are already updated automatically in many cases. This option\ncan be useful when there is an external process changing the displayed\ndirectory and you are not doing anything in lf. Periodic checks are\ndisabled when the value of this option is set to zero.\n\npreserve ([]string) (default mode)\n\nList of attributes that are preserved when copying files. Currently\nsupported attributes are mode (i.a. access mode) and timestamps (i.e.\nmodification time and access time). Note that preserving other\nattributes like ownership of change/birth timestamp is desirable, but\nnot portably supported in Go.\n\npreview (bool) (default true)\n\nShow previews of files and directories at the rightmost pane. If the\nfile has more lines than the preview pane, the rest of the lines are not\nread. Files containing the null character (U+0000) in the read portion\nare considered binary files and displayed as binary.\n\npreviewer (string) (default ``) (not filtered if empty)\n\nSet the path of a previewer file to filter the content of regular files\nfor previewing. The file should be executable. The following arguments\nare passed to the file, (1) current file name, (2) width, (3) height,\n(4) horizontal position, and (5) vertical position of preview pane\nrespectively. SIGPIPE signal is sent when enough lines are read. If the\npreviewer returns a non-zero exit code, then the preview cache for the\ngiven file is disabled. This means that if the file is selected in the\nfuture, the previewer is called once again. Preview filtering is\ndisabled and files are displayed as they are when the value of this\noption is left empty.\n\npromptfmt (string) (default \\033[32;1m%u@%h\\033[0m:\\033[34;1m%d\\033[0m\\033[1m%f\\033[0m)\n\nFormat string of the prompt shown in the top line. Special expansions\nare provided, %u as the user name, %h as the hostname, %w as the working\ndirectory, %d as the working directory with a trailing path separator,\n%f as the file name, and %F as the current filter. %S may be used once\nand will provide a spacer so that the following parts are right aligned\non the screen. The home folder is shown as ~ in the working directory\nexpansion. Directory names are automatically shortened to a single\ncharacter starting from the leftmost parent when the prompt does not fit\nthe screen.\n\nratios ([]int) (default 1:2:3)\n\nList of ratios of pane widths. Number of items in the list determines\nthe number of panes in the UI. When the preview option is enabled, the\nrightmost number is used for the width of the preview pane.\n\nrelativenumber (bool) (default false)\n\nShow the position number relative to the current line. When number is\nenabled, the current line shows the absolute position, otherwise nothing\nis shown.\n\nreverse (bool) (default false)\n\nReverse the direction of sort.\n\nroundbox (bool) (default false)\n\nDraw rounded outer corners when the drawbox option is enabled.\n\nrulerfmt (string) (default   %a|  %p|  \\033[7;31m %m \\033[0m|  \\033[7;33m %c \\033[0m|  \\033[7;35m %s \\033[0m|  \\033[7;34m %f \\033[0m|  %i/%t)\n\nFormat string of the ruler shown in the bottom right corner. Special\nexpansions are provided, %a as the pressed keys, %p as the progress of\nfile operations, %m as the number of files to be cut (moved), %c as the\nnumber of files to be copied, %s as the number of selected files, %f as\nthe filter, %i as the position of the cursor, %t as the number of files\nshown in the current directory, %h as the number of files hidden in the\ncurrent directory, and %d as the amount of free disk space remaining.\nAdditional expansions are provided for environment variables exported by\nlf, in the form %{lf_<name>} (e.g. %{lf_selmode}). This is useful for\ndisplaying the current settings. Expansions are also provided for\nuser-defined options, in the form %{lf_user_<name>} (e.g.\n%{lf_user_foo}). The | character splits the format string into sections.\nAny section containing a failed expansion (result is a blank string) is\ndiscarded and not shown.\n\nselectfmt (string) (default \\033[7;35m)\n\nFormat string of the indicator for files that are selected.\n\nselmode (string) (default all)\n\nSelection mode for commands. When set to all it will use the selected\nfiles from all directories. When set to dir it will only use the\nselected files in the current directory.\n\nscrolloff (int) (default 0)\n\nMinimum number of offset lines shown at all times at the top and bottom\nof the screen when scrolling. The current line is kept in the middle\nwhen this option is set to a large value that is bigger than the half of\nnumber of lines. A smaller offset can be used when the current file is\nclose to the beginning or end of the list to show the maximum number of\nitems.\n\nshell (string) (default sh for Unix and cmd for Windows)\n\nShell executable to use for shell commands. Shell commands are executed\nas shell shellopts shellflag command -- arguments.\n\nshellflag (string) (default -c for Unix and /c for Windows)\n\nCommand line flag used to pass shell commands.\n\nshellopts ([]string) (default ``)\n\nList of shell options to pass to the shell executable.\n\nshowbinds (bool) (default true)\n\nShow bindings associated with pressed keys.\n\nsixel (bool) (default false)\n\nRender sixel images in preview.\n\nsmartcase (bool) (default true)\n\nOverride ignorecase option when the pattern contains an uppercase\ncharacter. This option has no effect when ignorecase is disabled.\n\nsmartdia (bool) (default false)\n\nOverride ignoredia option when the pattern contains a character with\ndiacritic. This option has no effect when ignoredia is disabled.\n\nsortby (string) (default natural)\n\nSort type for directories. Currently supported sort types are natural,\nname, size, time, ctime, atime, and ext.\n\nstatfmt (string) (default \\033[36m%p\\033[0m| %c| %u| %g| %S| %t| -> %l)\n\nFormat string of the file info shown in the bottom left corner. Special\nexpansions are provided, %p as the file permissions, %c as the link\ncount, %u as the user, %g as the group, %s as the file size, %S as the\nfile size but with a fixed width of four characters (left-padded with\nspaces), %t as the last modified time, and %l as the link target. The |\ncharacter splits the format string into sections. Any section containing\na failed expansion (result is a blank string) is discarded and not\nshown.\n\ntabstop (int) (default 8)\n\nNumber of space characters to show for horizontal tabulation (U+0009)\ncharacter.\n\ntagfmt (string) (default \\033[31m)\n\nFormat string of the tags.\n\nIf the format string contains the characters %s, it is interpreted as a\nformat string for fmt.Sprintf. Such a string should end with the\nterminal reset sequence. For example, \\033[4m%s\\033[0m has the same\neffect as \\033[4m.\n\ntempmarks (string) (default ``)\n\nMarks to be considered temporary (e.g. abc refers to marks a, b, and c).\nThese marks are not synced to other clients and they are not saved in\nthe bookmarks file. Note that the special bookmark ` is always treated\nas temporary and it does not need to be specified.\n\ntimefmt (string) (default Mon Jan _2 15:04:05 2006)\n\nFormat string of the file modification time shown in the bottom line.\n\ntruncatechar (string) (default ~)\n\nThe truncate character that is shown at the end when the file name does\nnot fit into the pane.\n\ntruncatepct (int) (default 100)\n\nWhen a filename is too long to be shown completely, the available space\nis partitioned into two pieces. truncatepct defines a fraction (in\npercent between 0 and 100) for the size of the first piece, which will\nshow the beginning of the filename. The second piece will show the end\nof the filename and will use the rest of the available space. Both\npieces are separated by the truncation character (truncatechar). A value\nof 100 will only show the beginning of the filename, while a value of 0\nwill only show the end of the filename, e.g.:\n\n-   set truncatepct 100 -> very-long-filename-tr~ (default)\n\n-   set truncatepct 50 -> very-long-f~-truncated\n\n-   set truncatepct 0 -> ~ng-filename-truncated\n\nwaitmsg (string) (default Press any key to continue)\n\nString shown after commands of shell-wait type.\n\nwatch (bool) (default false)\n\nWatch the filesystem for changes using fsnotify to automatically refresh\nfile information. FUSE is currently not supported due to limitations in\nfsnotify.\n\nwrapscan (bool) (default true)\n\nSearching can wrap around the file list.\n\nwrapscroll (bool) (default false)\n\nScrolling can wrap around the file list.\n\nuser_{option} (string) (default none)\n\nAny option that is prefixed with user_ is a user-defined option and can\nbe set to any string. Inside a user-defined command, the value will be\nprovided in the lf_user_{option} environment variable. These options are\nnot used by lf and are not persisted.\n\nENVIRONMENT VARIABLES\n\nThe following variables are exported for shell commands: These are\nreferred to with a $ prefix on POSIX shells (e.g. $f), between %\ncharacters on Windows cmd (e.g. %f%), and with a $env: prefix on Windows\nPowerShell (e.g. $env:f).\n\nf\n\nCurrent file selection as a full path.\n\nfs\n\nSelected file(s) separated with the value of filesep option as full\npath(s).\n\nfx\n\nSelected file(s) (i.e. fs) if there are any selected files, otherwise\ncurrent file selection (i.e. f).\n\nid\n\nId of the running client.\n\nPWD\n\nPresent working directory.\n\nOLDPWD\n\nInitial working directory.\n\nLF_LEVEL\n\nThe value of this variable is set to the current nesting level when you\nrun lf from a shell spawned inside lf. You can add the value of this\nvariable to your shell prompt to make it clear that your shell runs\ninside lf. For example, with POSIX shells, you can use\n[ -n \"$LF_LEVEL\" ] && PS1=\"$PS1\"\"(lf level: $LF_LEVEL) \" in your shell\nconfiguration file (e.g. ~/.bashrc).\n\nOPENER\n\nIf this variable is set in the environment, use the same value.\nOtherwise, this is set to start in Windows, open in MacOS, xdg-open in\nothers.\n\nEDITOR\n\nIf VISUAL is set in the environment, use its value. Otherwise, use the\nvalue of the environment variable EDITOR. If neither variable is set,\nthis is set to vi on Unix, notepad in Windows.\n\nPAGER\n\nIf this variable is set in the environment, use the same value.\nOtherwise, this is set to less on Unix, more in Windows.\n\nSHELL\n\nIf this variable is set in the environment, use the same value.\nOtherwise, this is set to sh on Unix, cmd in Windows.\n\nlf\n\nAbsolute path to the currently running lf binary, if it can be found.\nOtherwise, this is set to the string lf.\n\nlf_{option}\n\nValue of the {option}.\n\nlf_user_{option}\n\nValue of the user_{option}.\n\nlf_width, lf_height\n\nWidth/Height of the terminal.\n\nlf_count\n\nValue of the count associated with the current command.\n\nlf_mode\n\nCurrent mode that lf is operating in. This is useful for customizing\nkeybindings depending on what the current mode is. Possible values are\ndelete, rename, filter, find, mark, search, command, shell, pipe (when\nrunning a shell-pipe command), normal, and unknown.\n\nSPECIAL COMMANDS\n\nThis section shows information about special shell commands.\n\nopen\n\nThis shell command can be defined to override the default open command\nwhen the current file is not a directory.\n\npaste\n\nThis shell command can be defined to override the default paste command.\n\nrename\n\nThis shell command can be defined to override the default rename\ncommand.\n\ndelete\n\nThis shell command can be defined to override the default delete\ncommand.\n\npre-cd\n\nThis shell command can be defined to be executed before changing a\ndirectory.\n\non-cd\n\nThis shell command can be defined to be executed after changing a\ndirectory.\n\non-focus-gained\n\nThis shell command can be defined to be executed when the terminal gains\nfocus.\n\non-focus-lost\n\nThis shell command can be defined to be executed when the terminal loses\nfocus.\n\non-init\n\nThis shell command can be defined to be executed after initializing and\nconnecting to the server.\n\non-select\n\nThis shell command can be defined to be executed after the selection\nchanges.\n\non-redraw\n\nThis shell command can be defined to be executed after the screen is\nredrawn or if the terminal is resized.\n\non-quit\n\nThis shell command can be defined to be executed before quitting.\n\nPREFIXES\n\nThe following command prefixes are used by lf:\n\n    :  read (default)  builtin/custom command\n    $  shell           shell command\n    %  shell-pipe      shell command running with the UI\n    !  shell-wait      shell command waiting for a key press\n    &  shell-async     shell command running asynchronously\n\nThe same evaluator is used for the command line and the configuration\nfile for reading shell commands. The difference is that prefixes are not\nnecessary in the command line. Instead, different modes are provided to\nread corresponding commands. These modes are mapped to the prefix keys\nabove by default.\n\nSYNTAX\n\nCharacters from # to newline are comments and ignored:\n\n    # comments start with `#`\n\nThere are five special commands (set, setlocal, map, cmap, and cmd) for\nconfiguration.\n\nCommand set is used to set an option which can be a boolean, integer, or\nstring:\n\n    set hidden         # boolean enable\n    set hidden true    # boolean enable\n    set nohidden       # boolean disable\n    set hidden false   # boolean disable\n    set hidden!        # boolean toggle\n    set scrolloff 10   # integer value\n    set sortby time    # string value w/o quotes\n    set sortby 'time'  # string value with single quotes (whitespaces)\n    set sortby \"time\"  # string value with double quotes (backslash escapes)\n\nCommand setlocal is used to set a local option for a directory which can\nbe a boolean or string. Currently supported local options are dirfirst,\ndironly, hidden, info, reverse, sortby and locale. Adding a trailing\npath separator (i.e. / for Unix and \\ for Windows) sets the option for\nthe given directory along with its subdirectories:\n\n    setlocal /foo/bar hidden         # boolean enable\n    setlocal /foo/bar hidden true    # boolean enable\n    setlocal /foo/bar nohidden       # boolean disable\n    setlocal /foo/bar hidden false   # boolean disable\n    setlocal /foo/bar hidden!        # boolean toggle\n    setlocal /foo/bar sortby time    # string value w/o quotes\n    setlocal /foo/bar sortby 'time'  # string value with single quotes (whitespaces)\n    setlocal /foo/bar sortby \"time\"  # string value with double quotes (backslash escapes)\n    setlocal /foo/bar  hidden        # for only '/foo/bar' directory\n    setlocal /foo/bar/ hidden        # for '/foo/bar' and its subdirectories (e.g. '/foo/bar/baz')\n\nCommand 'map' is used to bind a key to a command which can be a builtin\ncommand, custom command, or shell command:\n\n    map gh cd ~        # builtin command\n    map D trash        # custom command\n    map i $less $f     # shell command\n    map U !du -csh *   # waiting shell command\n\nCommand 'cmap' is used to bind a key on the command line to a command\nline command or any other command:\n\n    cmap <c-g> cmd-escape\n    cmap <a-i> set incsearch!\n\nYou can delete an existing binding by leaving the expression empty:\n\n    map gh             # deletes 'gh' mapping\n    cmap <c-g>         # deletes '<c-g>' mapping\n\nCommand cmd is used to define a custom command:\n\n    cmd usage $du -h -d1 | less\n\nYou can delete an existing command by leaving the expression empty:\n\n    cmd trash          # deletes 'trash' command\n\nIf there is no prefix then : is assumed:\n\n    map zt set info time\n\nAn explicit : can be provided to group statements until a newline which\nis especially useful for map and cmd commands:\n\n    map st :set sortby time; set info time\n\nIf you need multiline you can wrap statements in {{ and }} after the\nproper prefix.\n\n    map st :{{\n        set sortby time\n        set info time\n    }}\n\nKEY MAPPINGS\n\nRegular keys are assigned to a command with the usual syntax:\n\n    map a down\n\nKeys combined with the shift key simply use the uppercase letter:\n\n    map A down\n\nSpecial keys are written in between < and > characters and always use\nlowercase letters:\n\n    map <enter> down\n\nAngle brackets can be assigned with their special names:\n\n    map <lt> down\n    map <gt> down\n\nFunction keys are prefixed with f character:\n\n    map <f-1> down\n\nKeys combined with the control key are prefixed with a c character:\n\n    map <c-a> down\n\nKeys combined with the alt key are assigned in two different ways\ndepending on the behavior of your terminal. Older terminals (e.g. xterm)\nmay set the 8th bit of a character when the alt key is pressed. On these\nterminals, you can use the corresponding byte for the mapping:\n\n    map á down\n\nNewer terminals (e.g. gnome-terminal) may prefix the key with an escape\nkey when the alt key is pressed. lf uses the escape delaying mechanism\nto recognize alt keys in these terminals (delay is 100ms). On these\nterminals, keys combined with the alt key are prefixed with an a\ncharacter:\n\n    map <a-a> down\n\nIt is possible to combine special keys with modifiers:\n\n    map <a-enter> down\n\nWARNING: Some key combinations will likely be intercepted by your OS,\nwindow manager, or terminal. Other key combinations cannot be recognized\nby lf due to the way terminals work (e.g. Ctrl+h combination sends a\nbackspace key instead). The easiest way to find out the name of a key\ncombination and whether it will work on your system is to press the key\nwhile lf is running and read the name from the unknown mapping error.\n\nMouse buttons are prefixed with an m character:\n\n    map <m-1> down  # primary\n    map <m-2> down  # secondary\n    map <m-3> down  # middle\n    map <m-4> down\n    map <m-5> down\n    map <m-6> down\n    map <m-7> down\n    map <m-8> down\n\nMouse wheel events are also prefixed with an m character:\n\n    map <m-up>    down\n    map <m-down>  down\n    map <m-left>  down\n    map <m-right> down\n\nPUSH MAPPINGS\n\nThe usual way to map a key sequence is to assign it to a named or\nunnamed command. While this provides a clean way to remap built-in keys\nas well as other commands, it can be limiting at times. For this reason,\nthe push command is provided by lf. This command is used to simulate key\npushes given as its arguments. You can map a key to a push command with\nan argument to create various keybindings.\n\nThis is mainly useful for two purposes. First, it can be used to map a\ncommand with a command count:\n\n    map <c-j> push 10j\n\nSecond, it can be used to avoid typing the name when a command takes\narguments:\n\n    map r push :rename<space>\n\nOne thing to be careful of is that since the push command works with\nkeys instead of commands it is possible to accidentally create recursive\nbindings:\n\n    map j push 2j\n\nThese types of bindings create a deadlock when executed.\n\nSHELL COMMANDS\n\nRegular shell commands are the most basic command type that is useful\nfor many purposes. For example, we can write a shell command to move the\nselected file(s) to trash. A first attempt to write such a command may\nlook like this:\n\n    cmd trash ${{\n        mkdir -p ~/.trash\n        if [ -z \"$fs\" ]; then\n            mv \"$f\" ~/.trash\n        else\n            IFS=\"$(printf '\\n\\t')\"; mv $fs ~/.trash\n        fi\n    }}\n\nWe check $fs to see if there are any selected files. Otherwise, we just\ndelete the current file. Since this is such a common pattern, a separate\n$fx variable is provided. We can use this variable to get rid of the\nconditional:\n\n    cmd trash ${{\n        mkdir -p ~/.trash\n        IFS=\"$(printf '\\n\\t')\"; mv $fx ~/.trash\n    }}\n\nThe trash directory is checked each time the command is executed. We can\nmove it outside of the command so it would only run once at startup:\n\n    ${{ mkdir -p ~/.trash }}\n\n    cmd trash ${{ IFS=\"$(printf '\\n\\t')\"; mv $fx ~/.trash }}\n\nSince these are one-liners, we can drop {{ and }}:\n\n    $mkdir -p ~/.trash\n\n    cmd trash $IFS=\"$(printf '\\n\\t')\"; mv $fx ~/.trash\n\nFinally, note that we set the IFS variable manually in these commands.\nInstead, we could use the ifs option to set it for all shell commands\n(i.e. set ifs \"\\n\"). This can be especially useful for interactive use\n(e.g. $rm $f or $rm $fs would simply work). This option is not set by\ndefault as it can behave unexpectedly for new users. However, use of\nthis option is highly recommended and it is assumed in the rest of the\ndocumentation.\n\nPIPING SHELL COMMANDS\n\nRegular shell commands have some limitations in some cases. When an\noutput or error message is given and the command exits afterwards, the\nui is immediately resumed and there is no way to see the message without\ndropping to shell again. Also, even when there is no output or error,\nthe UI still needs to be paused while the command is running. This can\ncause flickering on the screen for short commands and similar\ndistractions for longer commands.\n\nInstead of pausing the UI, piping shell commands connect stdin, stdout,\nand stderr of the command to the statline at the bottom of the UI. This\ncan be useful for programs following the Unix philosophy to give no\noutput in the success case, and brief error messages or prompts in other\ncases.\n\nFor example, following rename command prompts for overwrite in the\nstatline if there is an existing file with the given name:\n\n    cmd rename %mv -i $f $1\n\nYou can also output error messages in the command and it will show up in\nthe statline. For example, an alternative rename command may look like\nthis:\n\n    cmd rename %[ -e $1 ] && printf \"file exists\" || mv $f $1\n\nNote that input is line buffered and output and error are byte buffered.\n\nWAITING SHELL COMMANDS\n\nWaiting shell commands are similar to regular shell commands except that\nthey wait for a key press when the command is finished. These can be\nuseful to see the output of a program before the UI is resumed. Waiting\nshell commands are more appropriate than piping shell commands when the\ncommand is verbose and the output is best displayed as multiline.\n\nASYNCHRONOUS SHELL COMMANDS\n\nAsynchronous shell commands are used to start a command in the\nbackground and then resume operation without waiting for the command to\nfinish. Stdin, stdout, and stderr of the command are neither connected\nto the terminal nor the UI.\n\nREMOTE COMMANDS\n\nOne of the more advanced features in lf is remote commands. All clients\nconnect to a server on startup. It is possible to send commands to all\nor any of the connected clients over the common server. This is used\ninternally to notify file selection changes to other clients.\n\nTo use this feature, you need to use a client which supports\ncommunicating with a Unix domain socket. OpenBSD implementation of\nnetcat (nc) is one such example. You can use it to send a command to the\nsocket file:\n\n    echo 'send echo hello world' | nc -U ${XDG_RUNTIME_DIR:-/tmp}/lf.${USER}.sock\n\nSince such a client may not be available everywhere, lf comes bundled\nwith a command line flag to be used as such. When using lf, you do not\nneed to specify the address of the socket file. This is the recommended\nway of using remote commands since it is shorter and immune to socket\nfile address changes:\n\n    lf -remote 'send echo hello world'\n\nIn this command send is used to send the rest of the string as a command\nto all connected clients. You can optionally give it an ID number to\nsend a command to a single client:\n\n    lf -remote 'send 1234 echo hello world'\n\nAll clients have a unique id number but you may not be aware of the id\nnumber when you are writing a command. For this purpose, an $id variable\nis exported to the environment for shell commands. The value of this\nvariable is set to the process ID of the client. You can use it to send\na remote command from a client to the server which in return sends a\ncommand back to itself. So now you can display a message in the current\nclient by calling the following in a shell command:\n\n    lf -remote \"send $id echo hello world\"\n\nSince lf does not have control flow syntax, remote commands are used for\nsuch needs. For example, you can configure the number of columns in the\nUI with respect to the terminal width as follows:\n\n    cmd recol %{{\n        if [ $lf_width -le 80 ]; then\n            lf -remote \"send $id set ratios 1:2\"\n        elif [ $lf_width -le 160 ]; then\n            lf -remote \"send $id set ratios 1:2:3\"\n        else\n            lf -remote \"send $id set ratios 1:2:3:5\"\n        fi\n    }}\n\nIn addition, the query command can be used to obtain information about a\nspecific lf instance by providing its id:\n\n    lf -remote \"query $id maps\"\n\nThe following types of information are supported:\n\n    maps     list of mappings created by the 'map' command\n    cmaps    list of mappings created by the 'cmap' command\n    cmds     list of commands created by the 'cmd' command\n    jumps    contents of the jump list, showing previously visited locations\n    history  list of previously executed commands on the command line\n\nThis is useful for scripting actions based on the internal state of lf.\nFor example, to select a previous command using fzf and execute it:\n\n    map <a-h> ${{\n        clear\n        cmd=$(\n            lf -remote \"query $id history\" |\n            awk -F'\\t' 'NR > 1 { print $NF}' |\n            sort -u |\n            fzf --reverse --prompt='Execute command: '\n        )\n        lf -remote \"send $id $cmd\"\n    }}\n\nThere is also a quit command to quit the server when there are no\nconnected clients left, and a quit! command to force quit the server by\nclosing client connections first:\n\n    lf -remote 'quit'\n    lf -remote 'quit!'\n\nLastly, there is a conn command to connect the server to a client. This\nshould not be needed for users.\n\nFILE OPERATIONS\n\nlf uses its own built-in copy and move operations by default. These are\nimplemented as asynchronous operations and progress is shown in the\nbottom ruler. These commands do not overwrite existing files or\ndirectories with the same name. Instead, a suffix that is compatible\nwith the --backup=numbered option in GNU cp is added to the new files or\ndirectories. Only file modes and (some) timestamps can be preserved (see\npreserve option), all other attributes are ignored including ownership,\ncontext, and xattr. Special files such as character and block devices,\nnamed pipes, and sockets are skipped and links are not followed. Moving\nis performed using the rename operation of the underlying OS. For\ncross-device moving, lf falls back to copying and then deletes the\noriginal files if there are no errors. Operation errors are shown in the\nmessage line as well as the log file and they do not preemptively finish\nthe corresponding file operation.\n\nFile operations can be performed on the currently selected file or on\nmultiple files by selecting them first. When you copy a file, lf doesn't\nactually copy the file on the disk, but only records its name to a file.\nThe actual file copying takes place when you paste. Similarly paste\nafter a cut operation moves the file.\n\nYou can customize copy and move operations by defining a paste command.\nThis is a special command that is called when it is defined instead of\nthe built-in implementation. You can use the following example as a\nstarting point:\n\n    cmd paste %{{\n        load=$(cat ~/.local/share/lf/files)\n        mode=$(echo \"$load\" | sed -n '1p')\n        list=$(echo \"$load\" | sed '1d')\n        if [ $mode = 'copy' ]; then\n            cp -R $list .\n        elif [ $mode = 'move' ]; then\n            mv $list .\n            rm ~/.local/share/lf/files\n            lf -remote 'send clear'\n        fi\n    }}\n\nSome useful things to be considered are to use the backup (--backup)\nand/or preserve attributes (-a) options with cp and mv commands if they\nsupport it (i.e. GNU implementation), change the command type to\nasynchronous, or use rsync command with progress bar option for copying\nand feed the progress to the client periodically with remote echo calls.\n\nBy default, lf does not assign delete command to a key to protect new\nusers. You can customize file deletion by defining a delete command. You\ncan also assign a key to this command if you like. An example command to\nmove selected files to a trash folder and remove files completely after\na prompt is provided in the example configuration file.\n\nSEARCHING FILES\n\nThere are two mechanisms implemented in lf to search a file in the\ncurrent directory. Searching is the traditional method to move the\nselection to a file matching a given pattern. Finding is an alternative\nway to search for a pattern possibly using fewer keystrokes.\n\nThe searching mechanism is implemented with commands search (default /),\nsearch-back (default ?), search-next (default n), and search-prev\n(default N). You can enable globsearch option to match with a glob\npattern. Globbing supports * to match any sequence, ? to match any\ncharacter, and [...] or [^...] to match character sets or ranges. You\ncan enable incsearch option to jump to the current match at each\nkeystroke while typing. In this mode, you can either use cmd-enter to\naccept the search or use cmd-escape to cancel the search. You can also\nmap some other commands with cmap to accept the search and execute the\ncommand immediately afterwards. For example, you can use the right arrow\nkey to finish the search and open the selected file with the following\nmapping:\n\n    cmap <right> :cmd-enter; open\n\nThe finding mechanism is implemented with commands find (default f),\nfind-back (default F), find-next (default ;), find-prev (default ,). You\ncan disable anchorfind option to match a pattern at an arbitrary\nposition in the filename instead of the beginning. You can set the\nnumber of keys to match using findlen option. If you set this value to\nzero, then the keys are read until there is only a single match. The\ndefault values of these two options are set to jump to the first file\nwith the given initial.\n\nSome options effect both searching and finding. You can disable wrapscan\noption to prevent searches from being wrapped around at the end of the\nfile list. You can disable ignorecase option to match cases in the\npattern and the filename. This option is already automatically\noverridden if the pattern contains upper-case characters. You can\ndisable smartcase option to disable this behavior. Two similar options\nignoredia and smartdia are provided to control matching diacritics in\nLatin letters.\n\nOPENING FILES\n\nYou can define an open command (default l and <right>) to configure file\nopening. This command is only called when the current file is not a\ndirectory, otherwise, the directory is entered instead. You can define\nit just as you would define any other command:\n\n    cmd open $vi $fx\n\nIt is possible to use different command types:\n\n    cmd open &xdg-open $f\n\nYou may want to use either file extensions or mime types from file\ncommand:\n\n    cmd open ${{\n        case $(file --mime-type -Lb $f) in\n            text/*) vi $fx;;\n            *) for f in $fx; do xdg-open $f > /dev/null 2> /dev/null & done;;\n        esac\n    }}\n\nYou may want to use setsid before your opener command to have persistent\nprocesses that continue to run after lf quits.\n\nRegular shell commands (i.e. $) drop to the terminal which results in a\nflicker for commands that finish immediately (e.g. xdg-open in the above\nexample). If you want to use asynchronous shell commands (i.e. &) but\nalso want to use the terminal when necessary (e.g. vi in the above\nexample), you can use a remote command:\n\n    cmd open &{{\n        case $(file --mime-type -Lb $f) in\n            text/*) lf -remote \"send $id \\$vi \\$fx\";;\n            *) for f in $fx; do xdg-open $f > /dev/null 2> /dev/null & done;;\n        esac\n    }}\n\nNote that asynchronous shell commands run in their own process group by\ndefault so they do not require the manual use of setsid.\n\nThe following command is provided by default:\n\n    cmd open &$OPENER $f\n\nYou may also use any other existing file openers as you like. Possible\noptions are libfile-mimeinfo-perl (executable name is mimeopen), rifle\n(ranger's default file opener), or mimeo to name a few.\n\nPREVIEWING FILES\n\nlf previews files on the preview pane by printing the file until the end\nor until the preview pane is filled. This output can be enhanced by\nproviding a custom preview script for filtering. This can be used to\nhighlight source codes, list contents of archive files or view PDF or\nimage files to name a few. For coloring lf recognizes ANSI escape codes.\n\nTo use this feature, you need to set the value of previewer option to\nthe path of an executable file. Five arguments are passed to the file,\n(1) current file name, (2) width, (3) height, (4) horizontal position,\nand (5) vertical position of preview pane respectively. The output of\nthe execution is printed in the preview pane. You may also want to use\nthe same script in your pager mapping as well:\n\n    set previewer ~/.config/lf/pv.sh\n    map i $~/.config/lf/pv.sh $f | less -R\n\nFor less pager, you may instead utilize LESSOPEN mechanism so that\nuseful information about the file such as the full path of the file can\nstill be displayed in the statusline below:\n\n    set previewer ~/.config/lf/pv.sh\n    map i $LESSOPEN='| ~/.config/lf/pv.sh %s' less -R $f\n\nSince this script is called for each file selection change it needs to\nbe as efficient as possible and this responsibility is left to the user.\nYou may use file extensions to determine the type of file more\nefficiently compared to obtaining mime types from file command.\nExtensions can then be used to match cleanly within a conditional:\n\n    #!/bin/sh\n\n    case \"$1\" in\n        *.tar*) tar tf \"$1\";;\n        *.zip) unzip -l \"$1\";;\n        *.rar) unrar l \"$1\";;\n        *.7z) 7z l \"$1\";;\n        *.pdf) pdftotext \"$1\" -;;\n        *) highlight -O ansi \"$1\";;\n    esac\n\nAnother important consideration for efficiency is the use of programs\nwith short startup times for preview. For this reason, highlight is\nrecommended over pygmentize for syntax highlighting. Besides, it is also\nimportant that the application processes the file on the fly rather than\nfirst reading it to the memory and then doing the processing afterwards.\nThis is especially relevant for big files. lf automatically closes the\npreviewer script output pipe with a SIGPIPE when enough lines are read.\nWhen everything else fails, you can make use of the height argument to\nonly feed the first portion of the file to a program for preview. Note\nthat some programs may not respond well to SIGPIPE to exit with a\nnon-zero return code and avoid caching. You may add a trailing || true\ncommand to avoid such errors:\n\n    highlight -O ansi \"$1\" || true\n\nYou may also use an existing preview filter as you like. Your system may\nalready come with a preview filter named lesspipe. These filters may\nhave a mechanism to add user customizations as well. See the related\ndocumentation for more information.\n\nCHANGING DIRECTORY\n\nlf changes the working directory of the process to the current directory\nso that shell commands always work in the displayed directory. After\nquitting, it returns to the original directory where it is first\nlaunched like all shell programs. If you want to stay in the current\ndirectory after quitting, you can use one of the example lfcd wrapper\nshell scripts provided in the repository at\nhttps://github.com/gokcehan/lf/tree/master/etc\n\nThere is a special command on-cd that runs a shell command when it is\ndefined and the directory is changed. You can define it just as you\nwould define any other command:\n\n    cmd on-cd &{{\n        bash -c '\n        # display git repository status in your prompt\n        source /usr/share/git/completion/git-prompt.sh\n        GIT_PS1_SHOWDIRTYSTATE=auto\n        GIT_PS1_SHOWSTASHSTATE=auto\n        GIT_PS1_SHOWUNTRACKEDFILES=auto\n        GIT_PS1_SHOWUPSTREAM=auto\n        git=$(__git_ps1 \" (%s)\")\n        fmt=\"\\033[32;1m%u@%h\\033[0m:\\033[34;1m%d\\033[0m\\033[1m%f$git\\033[0m\"\n        lf -remote \"send $id set promptfmt \\\"$fmt\\\"\"\n        '\n    }}\n\nIf you want to print escape sequences, you may redirect printf output to\n/dev/tty. The following xterm-specific escape sequence sets the terminal\ntitle to the working directory:\n\n    cmd on-cd &{{\n        printf \"\\033]0; $PWD\\007\" > /dev/tty\n    }}\n\nThis command runs whenever you change the directory but not on startup.\nYou can add an extra call to make it run on startup as well:\n\n    cmd on-cd &{{ ... }}\n    on-cd\n\nNote that all shell commands are possible but % and & are usually more\nappropriate as $ and ! causes flickers and pauses respectively.\n\nThere is also a pre-cd command, that works like on-cd, but is run before\nthe directory is actually changed.\n\nCOLORS\n\nlf tries to automatically adapt its colors to the environment. It starts\nwith a default color scheme and updates colors using values of existing\nenvironment variables possibly by overwriting its previous values.\nColors are set in the following order:\n\n1.  default\n2.  LSCOLORS (Mac/BSD ls)\n3.  LS_COLORS (GNU ls)\n4.  LF_COLORS (lf specific)\n5.  colors file (lf specific)\n\nPlease refer to the corresponding man pages for more information about\nLSCOLORS and LS_COLORS. LF_COLORS is provided with the same syntax as\nLS_COLORS in case you want to configure colors only for lf but not ls.\nThis can be useful since there are some differences between ls and lf,\nthough one should expect the same behavior for common cases. The colors\nfile (refer to the CONFIGURATION section) is provided for easier\nconfiguration without environment variables. This file should consist of\nwhitespace-separated pairs with a # character to start comments until\nthe end of the line.\n\nYou can configure lf colors in two different ways. First, you can only\nconfigure 8 basic colors used by your terminal and lf should pick up\nthose colors automatically. Depending on your terminal, you should be\nable to select your colors from a 24-bit palette. This is the\nrecommended approach as colors used by other programs will also match\neach other.\n\nSecond, you can set the values of environment variables or colors file\nmentioned above for fine-grained customization. Note that\nLS_COLORS/LF_COLORS are more powerful than LSCOLORS and they can be used\neven when GNU programs are not installed on the system. You can combine\nthis second method with the first method for the best results.\n\nLastly, you may also want to configure the colors of the prompt line to\nmatch the rest of the colors. Colors of the prompt line can be\nconfigured using the promptfmt option which can include hardcoded colors\nas ANSI escapes. See the default value of this option to have an idea\nabout how to color this line.\n\nIt is worth noting that lf uses as many colors advertised by your\nterminal's entry in terminfo or infocmp databases on your system. If an\nentry is not present, it falls back to an internal database. If your\nterminal supports 24-bit colors but either does not have a database\nentry or does not advertise all capabilities, you can enable support by\nsetting the $COLORTERM variable to truecolor or ensuring $TERM is set to\na value that ends with -truecolor.\n\nDefault lf colors are mostly taken from GNU dircolors defaults. These\ndefaults use 8 basic colors and bold attribute. Default dircolors\nentries with background colors are simplified to avoid confusion with\ncurrent file selection in lf. Similarly, there are only file type\nmatchings and extension matchings are left out for simplicity. Default\nvalues are as follows given with their matching order in lf:\n\n    ln  01;36\n    or  31;01\n    tw  01;34\n    ow  01;34\n    st  01;34\n    di  01;34\n    pi  33\n    so  01;35\n    bd  33;01\n    cd  33;01\n    su  01;32\n    sg  01;32\n    ex  01;32\n    fi  00\n\nNote that lf first tries matching file names and then falls back to file\ntypes. The full order of matchings from most specific to least are as\nfollows:\n\n1.  Full Path (e.g. ~/.config/lf/lfrc)\n2.  Dir Name (e.g. .git/) (only matches dirs with a trailing slash at\n    the end)\n3.  File Type (e.g. ln) (except fi)\n4.  File Name (e.g. README*)\n5.  File Name (e.g. *README)\n6.  Base Name (e.g. README.*)\n7.  Extension (e.g. *.txt)\n8.  Default (i.e. fi)\n\nFor example, given a regular text file /path/to/README.txt, the\nfollowing entries are checked in the configuration and the first one to\nmatch is used:\n\n1.  /path/to/README.txt\n2.  (skipped since the file is not a directory)\n3.  (skipped since the file is of type fi)\n4.  README.txt*\n5.  *README.txt\n6.  README.*\n7.  *.txt\n8.  fi\n\nGiven a regular directory /path/to/example.d, the following entries are\nchecked in the configuration and the first one to match is used:\n\n1.  /path/to/example.d\n2.  example.d/\n3.  di\n4.  example.d*\n5.  *example.d\n6.  example.*\n7.  *.d\n8.  fi\n\nNote that glob-like patterns do not perform glob matching for\nperformance reasons.\n\nFor example, you can set a variable as follows:\n\n    export LF_COLORS=\"~/Documents=01;31:~/Downloads=01;31:~/.local/share=01;31:~/.config/lf/lfrc=31:.git/=01;32:.git*=32:*.gitignore=32:*Makefile=32:README.*=33:*.txt=34:*.md=34:ln=01;36:di=01;34:ex=01;32:\"\n\nHaving all entries on a single line can make it hard to read. You may\ninstead divide it into multiple lines in between double quotes by\nescaping newlines with backslashes as follows:\n\n    export LF_COLORS=\"\\\n    ~/Documents=01;31:\\\n    ~/Downloads=01;31:\\\n    ~/.local/share=01;31:\\\n    ~/.config/lf/lfrc=31:\\\n    .git/=01;32:\\\n    .git*=32:\\\n    *.gitignore=32:\\\n    *Makefile=32:\\\n    README.*=33:\\\n    *.txt=34:\\\n    *.md=34:\\\n    ln=01;36:\\\n    di=01;34:\\\n    ex=01;32:\\\n    \"\n\nThe ln entry supports the special value target, which will use the link\ntarget to select a style. File name rules will still apply based on the\nlink's name -- this mirrors GNU's ls and dircolors behavior. Having such\na long variable definition in a shell configuration file might be\nundesirable. You may instead use the colors file (refer to the\nCONFIGURATION section) for configuration. A sample colors file can be\nfound at https://github.com/gokcehan/lf/blob/master/etc/colors.example\nYou may also see the wiki page for ANSI escape codes\nhttps://en.wikipedia.org/wiki/ANSI_escape_code\n\nICONS\n\nIcons are configured using LF_ICONS environment variable or an icons\nfile (refer to the CONFIGURATION section). The variable uses the same\nsyntax as LS_COLORS/LF_COLORS. Instead of colors, you should put a\nsingle characters as values of entries. The ln entry supports the\nspecial value target, which will use the link target to select a icon.\nFile name rules will still apply based on the link's name -- this\nmirrors GNU's ls and dircolors behavior. The icons file (refer to the\nCONFIGURATION section) should consist of whitespace-separated arrays\nwith a # character to start comments until the end of the line. Each\nline should contain 1-3 columns, first column is filetype or filename\npattern, second column is the icon, third column is an optional icon\ncolor. If there is only one column, means to disable rule for this\nfiletype or pattern. Do not forget to add set icons true to your lfrc to\nsee the icons. Default values are as follows given with their matching\norder in lf:\n\n    ln  l\n    or  l\n    tw  t\n    ow  d\n    st  t\n    di  d\n    pi  p\n    so  s\n    bd  b\n    cd  c\n    su  u\n    sg  g\n    ex  x\n    fi  -\n\nA sample icons file can be found at\nhttps://github.com/gokcehan/lf/blob/master/etc/icons.example\n\nA sample colored icons file can be found at\nhttps://github.com/gokcehan/lf/blob/master/etc/icons_colored.example\n"
        },
        {
          "name": "etc",
          "type": "tree",
          "content": null
        },
        {
          "name": "eval.go",
          "type": "blob",
          "size": 52.349609375,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"slices\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n\n\t\"github.com/gdamore/tcell/v2\"\n)\n\nfunc applyBoolOpt(opt *bool, e *setExpr) error {\n\tswitch {\n\tcase strings.HasPrefix(e.opt, \"no\"):\n\t\tif e.val != \"\" {\n\t\t\treturn fmt.Errorf(\"%s: unexpected value: %s\", e.opt, e.val)\n\t\t}\n\t\t*opt = false\n\tcase strings.HasSuffix(e.opt, \"!\"):\n\t\tif e.val != \"\" {\n\t\t\treturn fmt.Errorf(\"%s: unexpected value: %s\", e.opt, e.val)\n\t\t}\n\t\t*opt = !*opt\n\tdefault:\n\t\tswitch e.val {\n\t\tcase \"\", \"true\":\n\t\t\t*opt = true\n\t\tcase \"false\":\n\t\t\t*opt = false\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"%s: value should be empty, 'true', or 'false'\", e.opt)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc applyLocalBoolOpt(localOpt map[string]bool, globalOpt bool, e *setLocalExpr) error {\n\topt, ok := localOpt[e.path]\n\tif !ok {\n\t\topt = globalOpt\n\t}\n\n\tif err := applyBoolOpt(&opt, &setExpr{e.opt, e.val}); err != nil {\n\t\treturn err\n\t}\n\n\tlocalOpt[e.path] = opt\n\treturn nil\n}\n\nfunc (e *setExpr) eval(app *app, args []string) {\n\tvar err error\n\tswitch e.opt {\n\tcase \"anchorfind\", \"noanchorfind\", \"anchorfind!\":\n\t\terr = applyBoolOpt(&gOpts.anchorfind, e)\n\tcase \"autoquit\", \"noautoquit\", \"autoquit!\":\n\t\terr = applyBoolOpt(&gOpts.autoquit, e)\n\tcase \"dircache\", \"nodircache\", \"dircache!\":\n\t\terr = applyBoolOpt(&gOpts.dircache, e)\n\tcase \"dircounts\", \"nodircounts\", \"dircounts!\":\n\t\terr = applyBoolOpt(&gOpts.dircounts, e)\n\tcase \"dirfirst\", \"nodirfirst\", \"dirfirst!\":\n\t\terr = applyBoolOpt(&gOpts.dirfirst, e)\n\t\tif err == nil {\n\t\t\tapp.nav.sort()\n\t\t\tapp.ui.sort()\n\t\t}\n\tcase \"dironly\", \"nodironly\", \"dironly!\":\n\t\terr = applyBoolOpt(&gOpts.dironly, e)\n\t\tif err == nil {\n\t\t\tapp.nav.sort()\n\t\t\tapp.nav.position()\n\t\t\tapp.ui.sort()\n\t\t\tapp.ui.loadFile(app, true)\n\t\t}\n\tcase \"dirpreviews\", \"nodirpreviews\", \"dirpreviews!\":\n\t\terr = applyBoolOpt(&gOpts.dirpreviews, e)\n\tcase \"drawbox\", \"nodrawbox\", \"drawbox!\":\n\t\terr = applyBoolOpt(&gOpts.drawbox, e)\n\t\tif err == nil {\n\t\t\tapp.ui.renew()\n\t\t\tif app.nav.height != app.ui.wins[0].h {\n\t\t\t\tapp.nav.height = app.ui.wins[0].h\n\t\t\t\tapp.nav.regCache = make(map[string]*reg)\n\t\t\t\tif gOpts.sixel {\n\t\t\t\t\tapp.ui.sxScreen.lastFile = \"\"\n\t\t\t\t}\n\t\t\t}\n\t\t\tapp.ui.loadFile(app, true)\n\t\t}\n\tcase \"globfilter\", \"noglobfilter\", \"globfilter!\":\n\t\terr = applyBoolOpt(&gOpts.globfilter, e)\n\t\tif err == nil {\n\t\t\tapp.nav.sort()\n\t\t\tapp.nav.position()\n\t\t\tapp.ui.sort()\n\t\t\tapp.ui.loadFile(app, true)\n\t\t}\n\tcase \"globsearch\", \"noglobsearch\", \"globsearch!\":\n\t\terr = applyBoolOpt(&gOpts.globsearch, e)\n\tcase \"hidden\", \"nohidden\", \"hidden!\":\n\t\terr = applyBoolOpt(&gOpts.hidden, e)\n\t\tif err == nil {\n\t\t\tapp.nav.sort()\n\t\t\tapp.nav.position()\n\t\t\tapp.ui.sort()\n\t\t\tapp.ui.loadFile(app, true)\n\t\t}\n\tcase \"history\", \"nohistory\", \"history!\":\n\t\terr = applyBoolOpt(&gOpts.history, e)\n\tcase \"icons\", \"noicons\", \"icons!\":\n\t\terr = applyBoolOpt(&gOpts.icons, e)\n\tcase \"ignorecase\", \"noignorecase\", \"ignorecase!\":\n\t\terr = applyBoolOpt(&gOpts.ignorecase, e)\n\t\tif err == nil {\n\t\t\tapp.nav.sort()\n\t\t\tapp.nav.position()\n\t\t\tapp.ui.sort()\n\t\t\tapp.ui.loadFile(app, true)\n\t\t}\n\tcase \"ignoredia\", \"noignoredia\", \"ignoredia!\":\n\t\terr = applyBoolOpt(&gOpts.ignoredia, e)\n\t\tif err == nil {\n\t\t\tapp.nav.sort()\n\t\t\tapp.nav.position()\n\t\t\tapp.ui.sort()\n\t\t\tapp.ui.loadFile(app, true)\n\t\t}\n\tcase \"incfilter\", \"noincfilter\", \"incfilter!\":\n\t\terr = applyBoolOpt(&gOpts.incfilter, e)\n\tcase \"incsearch\", \"noincsearch\", \"incsearch!\":\n\t\terr = applyBoolOpt(&gOpts.incsearch, e)\n\tcase \"mouse\", \"nomouse\", \"mouse!\":\n\t\terr = applyBoolOpt(&gOpts.mouse, e)\n\t\tif err == nil {\n\t\t\tif gOpts.mouse {\n\t\t\t\tapp.ui.screen.EnableMouse(tcell.MouseButtonEvents)\n\t\t\t} else {\n\t\t\t\tapp.ui.screen.DisableMouse()\n\t\t\t}\n\t\t}\n\tcase \"number\", \"nonumber\", \"number!\":\n\t\terr = applyBoolOpt(&gOpts.number, e)\n\tcase \"preview\", \"nopreview\", \"preview!\":\n\t\tpreview := gOpts.preview\n\t\terr = applyBoolOpt(&preview, e)\n\t\tif preview && len(gOpts.ratios) < 2 {\n\t\t\terr = errors.New(\"preview: 'ratios' should consist of at least two numbers before enabling 'preview'\")\n\t\t}\n\t\tif err == nil {\n\t\t\tgOpts.preview = preview\n\t\t\tapp.ui.loadFile(app, true)\n\t\t}\n\tcase \"relativenumber\", \"norelativenumber\", \"relativenumber!\":\n\t\terr = applyBoolOpt(&gOpts.relativenumber, e)\n\tcase \"reverse\", \"noreverse\", \"reverse!\":\n\t\terr = applyBoolOpt(&gOpts.reverse, e)\n\t\tif err == nil {\n\t\t\tapp.nav.sort()\n\t\t\tapp.ui.sort()\n\t\t}\n\tcase \"roundbox\", \"noroundbox\", \"roundbox!\":\n\t\terr = applyBoolOpt(&gOpts.roundbox, e)\n\tcase \"showbinds\", \"noshowbinds\", \"showbinds!\":\n\t\terr = applyBoolOpt(&gOpts.showbinds, e)\n\tcase \"sixel\", \"nosixel\", \"sixel!\":\n\t\terr = applyBoolOpt(&gOpts.sixel, e)\n\tcase \"smartcase\", \"nosmartcase\", \"smartcase!\":\n\t\terr = applyBoolOpt(&gOpts.smartcase, e)\n\t\tif err == nil {\n\t\t\tapp.nav.sort()\n\t\t\tapp.nav.position()\n\t\t\tapp.ui.sort()\n\t\t\tapp.ui.loadFile(app, true)\n\t\t}\n\tcase \"smartdia\", \"nosmartdia\", \"smartdia!\":\n\t\terr = applyBoolOpt(&gOpts.smartdia, e)\n\t\tif err == nil {\n\t\t\tapp.nav.sort()\n\t\t\tapp.nav.position()\n\t\t\tapp.ui.sort()\n\t\t\tapp.ui.loadFile(app, true)\n\t\t}\n\tcase \"watch\", \"nowatch\", \"watch!\":\n\t\terr = applyBoolOpt(&gOpts.watch, e)\n\t\tif err == nil {\n\t\t\tif gOpts.watch {\n\t\t\t\tapp.watch.start()\n\t\t\t\tapp.setWatchPaths()\n\t\t\t} else {\n\t\t\t\tapp.watch.stop()\n\t\t\t}\n\t\t}\n\tcase \"wrapscan\", \"nowrapscan\", \"wrapscan!\":\n\t\terr = applyBoolOpt(&gOpts.wrapscan, e)\n\tcase \"wrapscroll\", \"nowrapscroll\", \"wrapscroll!\":\n\t\terr = applyBoolOpt(&gOpts.wrapscroll, e)\n\tcase \"borderfmt\":\n\t\tgOpts.borderfmt = e.val\n\tcase \"cleaner\":\n\t\tgOpts.cleaner = replaceTilde(e.val)\n\tcase \"copyfmt\":\n\t\tgOpts.copyfmt = e.val\n\tcase \"cursoractivefmt\":\n\t\tgOpts.cursoractivefmt = e.val\n\tcase \"cursorparentfmt\":\n\t\tgOpts.cursorparentfmt = e.val\n\tcase \"cursorpreviewfmt\":\n\t\tgOpts.cursorpreviewfmt = e.val\n\tcase \"cutfmt\":\n\t\tgOpts.cutfmt = e.val\n\tcase \"dupfilefmt\":\n\t\tgOpts.dupfilefmt = e.val\n\tcase \"errorfmt\":\n\t\tgOpts.errorfmt = e.val\n\tcase \"filesep\":\n\t\tgOpts.filesep = e.val\n\tcase \"findlen\":\n\t\tn, err := strconv.Atoi(e.val)\n\t\tif err != nil {\n\t\t\tapp.ui.echoerrf(\"findlen: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tif n < 0 {\n\t\t\tapp.ui.echoerr(\"findlen: value should be a non-negative number\")\n\t\t\treturn\n\t\t}\n\t\tgOpts.findlen = n\n\tcase \"hiddenfiles\":\n\t\ttoks := strings.Split(e.val, \":\")\n\t\tfor _, s := range toks {\n\t\t\tif s == \"\" {\n\t\t\t\tapp.ui.echoerr(\"hiddenfiles: glob should be non-empty\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\t_, err := filepath.Match(s, \"a\")\n\t\t\tif err != nil {\n\t\t\t\tapp.ui.echoerrf(\"hiddenfiles: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tgOpts.hiddenfiles = toks\n\t\tapp.nav.sort()\n\t\tapp.nav.position()\n\t\tapp.ui.sort()\n\t\tapp.ui.loadFile(app, true)\n\tcase \"ifs\":\n\t\tgOpts.ifs = e.val\n\tcase \"info\":\n\t\tif e.val == \"\" {\n\t\t\tgOpts.info = nil\n\t\t\treturn\n\t\t}\n\t\ttoks := strings.Split(e.val, \":\")\n\t\tfor _, s := range toks {\n\t\t\tswitch s {\n\t\t\tcase \"size\", \"time\", \"atime\", \"ctime\", \"perm\", \"user\", \"group\":\n\t\t\tdefault:\n\t\t\t\tapp.ui.echoerr(\"info: should consist of 'size', 'time', 'atime', 'ctime', 'perm', 'user' or 'group' separated with colon\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tgOpts.info = toks\n\tcase \"locale\":\n\t\tlocaleStr := e.val\n\t\tif localeStr != localeStrDisable {\n\t\t\tif _, err = getLocaleTag(localeStr); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"locale: %s\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tgOpts.locale = localeStr\n\t\tapp.nav.sort()\n\t\tapp.ui.sort()\n\tcase \"rulerfmt\":\n\t\tgOpts.rulerfmt = e.val\n\tcase \"preserve\":\n\t\tif e.val == \"\" {\n\t\t\tgOpts.preserve = nil\n\t\t\treturn\n\t\t}\n\t\ttoks := strings.Split(e.val, \":\")\n\t\tfor _, s := range toks {\n\t\t\tswitch s {\n\t\t\tcase \"mode\", \"timestamps\":\n\t\t\tdefault:\n\t\t\t\tapp.ui.echoerr(\"preserve: should consist of 'mode' or 'timestamps separated with colon\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tgOpts.preserve = toks\n\tcase \"infotimefmtnew\":\n\t\tgOpts.infotimefmtnew = e.val\n\tcase \"infotimefmtold\":\n\t\tgOpts.infotimefmtold = e.val\n\tcase \"numberfmt\":\n\t\tgOpts.numberfmt = e.val\n\tcase \"period\":\n\t\tn, err := strconv.Atoi(e.val)\n\t\tif err != nil {\n\t\t\tapp.ui.echoerrf(\"period: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tif n < 0 {\n\t\t\tapp.ui.echoerr(\"period: value should be a non-negative number\")\n\t\t\treturn\n\t\t}\n\t\tgOpts.period = n\n\t\tif n == 0 {\n\t\t\tapp.ticker.Stop()\n\t\t} else {\n\t\t\tapp.ticker.Stop()\n\t\t\tapp.ticker = time.NewTicker(time.Duration(gOpts.period) * time.Second)\n\t\t}\n\tcase \"previewer\":\n\t\tgOpts.previewer = replaceTilde(e.val)\n\tcase \"promptfmt\":\n\t\tgOpts.promptfmt = e.val\n\tcase \"ratios\":\n\t\ttoks := strings.Split(e.val, \":\")\n\t\trats := make([]int, 0, len(toks))\n\t\tfor _, s := range toks {\n\t\t\tn, err := strconv.Atoi(s)\n\t\t\tif err != nil {\n\t\t\t\tapp.ui.echoerrf(\"ratios: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif n <= 0 {\n\t\t\t\tapp.ui.echoerr(\"ratios: value should be a positive number\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\trats = append(rats, n)\n\t\t}\n\t\tif gOpts.preview && len(rats) < 2 {\n\t\t\tapp.ui.echoerr(\"ratios: should consist of at least two numbers when 'preview' is enabled\")\n\t\t\treturn\n\t\t}\n\t\tgOpts.ratios = rats\n\t\tapp.ui.wins = getWins(app.ui.screen)\n\t\tif gOpts.sixel {\n\t\t\tapp.nav.regCache = make(map[string]*reg)\n\t\t\tapp.ui.sxScreen.lastFile = \"\"\n\t\t}\n\t\tapp.ui.loadFile(app, true)\n\tcase \"scrolloff\":\n\t\tn, err := strconv.Atoi(e.val)\n\t\tif err != nil {\n\t\t\tapp.ui.echoerrf(\"scrolloff: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tif n < 0 {\n\t\t\tapp.ui.echoerr(\"scrolloff: value should be a non-negative number\")\n\t\t\treturn\n\t\t}\n\t\tgOpts.scrolloff = n\n\tcase \"selectfmt\":\n\t\tgOpts.selectfmt = e.val\n\tcase \"selmode\":\n\t\tswitch e.val {\n\t\tcase \"all\", \"dir\":\n\t\t\tgOpts.selmode = e.val\n\t\tdefault:\n\t\t\tapp.ui.echoerr(\"selmode: value should either be 'all' or 'dir'\")\n\t\t\treturn\n\t\t}\n\tcase \"shell\":\n\t\tgOpts.shell = e.val\n\tcase \"shellflag\":\n\t\tgOpts.shellflag = e.val\n\tcase \"shellopts\":\n\t\tif e.val == \"\" {\n\t\t\tgOpts.shellopts = nil\n\t\t\treturn\n\t\t}\n\t\tgOpts.shellopts = strings.Split(e.val, \":\")\n\tcase \"sortby\":\n\t\tmethod := sortMethod(e.val)\n\t\tif !isValidSortMethod(method) {\n\t\t\tapp.ui.echoerr(invalidSortErrorMessage)\n\t\t\treturn\n\t\t}\n\t\tgOpts.sortby = method\n\t\tapp.nav.sort()\n\t\tapp.ui.sort()\n\tcase \"statfmt\":\n\t\tgOpts.statfmt = e.val\n\tcase \"tabstop\":\n\t\tn, err := strconv.Atoi(e.val)\n\t\tif err != nil {\n\t\t\tapp.ui.echoerrf(\"tabstop: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tif n <= 0 {\n\t\t\tapp.ui.echoerr(\"tabstop: value should be a positive number\")\n\t\t\treturn\n\t\t}\n\t\tgOpts.tabstop = n\n\tcase \"tagfmt\":\n\t\tgOpts.tagfmt = e.val\n\tcase \"tempmarks\":\n\t\tgOpts.tempmarks = \"'\" + e.val\n\tcase \"timefmt\":\n\t\tgOpts.timefmt = e.val\n\tcase \"truncatechar\":\n\t\tif runeSliceWidth([]rune(e.val)) != 1 {\n\t\t\tapp.ui.echoerr(\"truncatechar: value should be a single character\")\n\t\t\treturn\n\t\t}\n\n\t\tgOpts.truncatechar = e.val\n\tcase \"truncatepct\":\n\t\tn, err := strconv.Atoi(e.val)\n\t\tif err != nil {\n\t\t\tapp.ui.echoerrf(\"truncatepct: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tif n < 0 || n > 100 {\n\t\t\tapp.ui.echoerrf(\"truncatepct: must be between 0 and 100 (both inclusive), got %d\", n)\n\t\t\treturn\n\t\t}\n\t\tgOpts.truncatepct = n\n\tcase \"waitmsg\":\n\t\tgOpts.waitmsg = e.val\n\tdefault:\n\t\t// any key with the prefix user_ is accepted as a user defined option\n\t\tif strings.HasPrefix(e.opt, \"user_\") {\n\t\t\tgOpts.user[e.opt[5:]] = e.val\n\t\t\t// Export user defined options immediately, so that the current values\n\t\t\t// are available for some external previewer, which is started in a\n\t\t\t// different thread and thus cannot export (as `setenv` is not thread-safe).\n\t\t\tos.Setenv(\"lf_\"+e.opt, e.val)\n\t\t} else {\n\t\t\terr = fmt.Errorf(\"unknown option: %s\", e.opt)\n\t\t}\n\t}\n\n\tif err != nil {\n\t\tapp.ui.echoerr(err.Error())\n\t\treturn\n\t}\n\n\tapp.ui.loadFileInfo(app.nav)\n}\n\nfunc (e *setLocalExpr) eval(app *app, args []string) {\n\te.path = replaceTilde(e.path)\n\tif !filepath.IsAbs(e.path) {\n\t\tapp.ui.echoerr(\"setlocal: path should be absolute\")\n\t\treturn\n\t}\n\n\tvar err error\n\tswitch e.opt {\n\tcase \"dirfirst\", \"nodirfirst\", \"dirfirst!\":\n\t\terr = applyLocalBoolOpt(gLocalOpts.dirfirsts, gOpts.dirfirst, e)\n\t\tif err == nil {\n\t\t\tapp.nav.sort()\n\t\t\tapp.ui.sort()\n\t\t}\n\tcase \"dironly\", \"nodironly\", \"dironly!\":\n\t\terr = applyLocalBoolOpt(gLocalOpts.dironlys, gOpts.dironly, e)\n\t\tif err == nil {\n\t\t\tapp.nav.sort()\n\t\t\tapp.nav.position()\n\t\t\tapp.ui.sort()\n\t\t\tapp.ui.loadFile(app, true)\n\t\t}\n\tcase \"hidden\", \"nohidden\", \"hidden!\":\n\t\terr = applyLocalBoolOpt(gLocalOpts.hiddens, gOpts.hidden, e)\n\t\tif err == nil {\n\t\t\tapp.nav.sort()\n\t\t\tapp.nav.position()\n\t\t\tapp.ui.sort()\n\t\t\tapp.ui.loadFile(app, true)\n\t\t}\n\tcase \"reverse\", \"noreverse\", \"reverse!\":\n\t\terr = applyLocalBoolOpt(gLocalOpts.reverses, gOpts.reverse, e)\n\t\tif err == nil {\n\t\t\tapp.nav.sort()\n\t\t\tapp.ui.sort()\n\t\t}\n\tcase \"info\":\n\t\tif e.val == \"\" {\n\t\t\tgLocalOpts.infos[e.path] = nil\n\t\t\treturn\n\t\t}\n\t\ttoks := strings.Split(e.val, \":\")\n\t\tfor _, s := range toks {\n\t\t\tswitch s {\n\t\t\tcase \"size\", \"time\", \"atime\", \"ctime\", \"perm\", \"user\", \"group\":\n\t\t\tdefault:\n\t\t\t\tapp.ui.echoerr(\"info: should consist of 'size', 'time', 'atime', 'ctime', 'perm', 'user' or 'group' separated with colon\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tgLocalOpts.infos[e.path] = toks\n\tcase \"sortby\":\n\t\tmethod := sortMethod(e.val)\n\t\tif !isValidSortMethod(method) {\n\t\t\tapp.ui.echoerr(invalidSortErrorMessage)\n\t\t\treturn\n\t\t}\n\t\tgLocalOpts.sortbys[e.path] = method\n\t\tapp.nav.sort()\n\t\tapp.ui.sort()\n\tcase \"locale\":\n\t\tlocaleStr := e.val\n\t\tif localeStr != localeStrDisable {\n\t\t\tif _, err = getLocaleTag(localeStr); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"locale: %s\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tgLocalOpts.locales[e.path] = localeStr\n\t\tapp.nav.sort()\n\t\tapp.ui.sort()\n\tdefault:\n\t\terr = fmt.Errorf(\"unknown option: %s\", e.opt)\n\t}\n\n\tif err != nil {\n\t\tapp.ui.echoerr(err.Error())\n\t\treturn\n\t}\n\n\tapp.ui.loadFileInfo(app.nav)\n}\n\nfunc (e *mapExpr) eval(app *app, args []string) {\n\tif e.expr == nil {\n\t\tdelete(gOpts.keys, e.keys)\n\t} else {\n\t\tgOpts.keys[e.keys] = e.expr\n\t}\n\tapp.ui.loadFileInfo(app.nav)\n}\n\nfunc (e *cmapExpr) eval(app *app, args []string) {\n\tif e.expr == nil {\n\t\tdelete(gOpts.cmdkeys, e.key)\n\t} else {\n\t\tgOpts.cmdkeys[e.key] = e.expr\n\t}\n\tapp.ui.loadFileInfo(app.nav)\n}\n\nfunc (e *cmdExpr) eval(app *app, args []string) {\n\tif e.expr == nil {\n\t\tdelete(gOpts.cmds, e.name)\n\t} else {\n\t\tgOpts.cmds[e.name] = e.expr\n\t}\n\n\t// only enable focus reporting if required by the user\n\tif e.name == \"on-focus-gained\" || e.name == \"on-focus-lost\" {\n\t\t_, onFocusGainedExists := gOpts.cmds[\"on-focus-gained\"]\n\t\t_, onFocusLostExists := gOpts.cmds[\"on-focus-lost\"]\n\t\tif onFocusGainedExists || onFocusLostExists {\n\t\t\tapp.ui.screen.EnableFocus()\n\t\t} else {\n\t\t\tapp.ui.screen.DisableFocus()\n\t\t}\n\t}\n\n\tapp.ui.loadFileInfo(app.nav)\n}\n\nfunc preChdir(app *app) {\n\tif cmd, ok := gOpts.cmds[\"pre-cd\"]; ok {\n\t\tcmd.eval(app, nil)\n\t}\n}\n\nfunc onChdir(app *app) {\n\tapp.nav.addJumpList()\n\tapp.setWatchPaths()\n\tif cmd, ok := gOpts.cmds[\"on-cd\"]; ok {\n\t\tcmd.eval(app, nil)\n\t}\n}\n\nfunc onFocusGained(app *app) {\n\tif cmd, ok := gOpts.cmds[\"on-focus-gained\"]; ok {\n\t\tcmd.eval(app, nil)\n\t}\n}\n\nfunc onFocusLost(app *app) {\n\tif cmd, ok := gOpts.cmds[\"on-focus-lost\"]; ok {\n\t\tcmd.eval(app, nil)\n\t}\n}\n\nfunc onInit(app *app) {\n\tif cmd, ok := gOpts.cmds[\"on-init\"]; ok {\n\t\tcmd.eval(app, nil)\n\t}\n}\n\nfunc onRedraw(app *app) {\n\tif cmd, ok := gOpts.cmds[\"on-redraw\"]; ok {\n\t\tcmd.eval(app, nil)\n\t}\n}\n\nfunc onSelect(app *app) {\n\tif cmd, ok := gOpts.cmds[\"on-select\"]; ok {\n\t\tcmd.eval(app, nil)\n\t}\n}\n\nfunc onQuit(app *app) {\n\tif cmd, ok := gOpts.cmds[\"on-quit\"]; ok {\n\t\tcmd.eval(app, nil)\n\t}\n}\n\nfunc splitKeys(s string) (keys []string) {\n\tfor i := 0; i < len(s); {\n\t\tr, w := utf8.DecodeRuneInString(s[i:])\n\t\tif r != '<' {\n\t\t\tkeys = append(keys, s[i:i+w])\n\t\t\ti += w\n\t\t} else {\n\t\t\tj := i + w\n\t\t\tfor r != '>' && j < len(s) {\n\t\t\t\tr, w = utf8.DecodeRuneInString(s[j:])\n\t\t\t\tj += w\n\t\t\t}\n\t\t\tkeys = append(keys, s[i:j])\n\t\t\ti = j\n\t\t}\n\t}\n\treturn\n}\n\nfunc doComplete(app *app) (matches []string) {\n\tswitch app.ui.cmdPrefix {\n\tcase \":\":\n\t\tmatches, app.ui.cmdAccLeft = completeCmd(app.ui.cmdAccLeft)\n\tcase \"/\", \"?\":\n\t\tmatches, app.ui.cmdAccLeft = completeFile(app.ui.cmdAccLeft)\n\tcase \"$\", \"%\", \"!\", \"&\":\n\t\tmatches, app.ui.cmdAccLeft = completeShell(app.ui.cmdAccLeft)\n\t}\n\treturn\n}\n\nfunc menuComplete(app *app, dir int) {\n\tif !app.menuCompActive {\n\t\ttoks := tokenize(string(app.ui.cmdAccLeft))\n\t\tfor i, tok := range toks {\n\t\t\ttoks[i] = replaceTilde(tok)\n\t\t}\n\t\tapp.ui.cmdAccLeft = []rune(strings.Join(toks, \" \"))\n\t\tapp.ui.cmdTmp = app.ui.cmdAccLeft\n\t\tapp.menuComps = doComplete(app)\n\t\tif len(app.menuComps) > 1 {\n\t\t\tapp.menuCompInd = -1\n\t\t\tapp.menuCompActive = true\n\t\t}\n\t} else {\n\t\tapp.menuCompInd += dir\n\t\tif app.menuCompInd == len(app.menuComps) {\n\t\t\tapp.menuCompInd = 0\n\t\t} else if app.menuCompInd < 0 {\n\t\t\tapp.menuCompInd = len(app.menuComps) - 1\n\t\t}\n\n\t\tcomp := app.menuComps[app.menuCompInd]\n\t\ttoks := tokenize(string(app.ui.cmdTmp))\n\t\tlast := toks[len(toks)-1]\n\n\t\tif app.ui.cmdPrefix != \"/\" && app.ui.cmdPrefix != \"?\" {\n\t\t\tcomp = escape(comp)\n\t\t\t_, last = filepath.Split(last)\n\t\t}\n\n\t\tind := len(app.ui.cmdTmp) - len([]rune(last))\n\t\tapp.ui.cmdAccLeft = append(app.ui.cmdTmp[:ind], []rune(comp)...)\n\t}\n\tapp.ui.menuBuf = listMatches(app.ui.screen, app.menuComps, app.menuCompInd)\n}\n\nfunc update(app *app) {\n\tapp.ui.menuBuf = nil\n\tapp.menuCompActive = false\n\n\tswitch {\n\tcase gOpts.incsearch && app.ui.cmdPrefix == \"/\":\n\t\tapp.nav.search = string(app.ui.cmdAccLeft) + string(app.ui.cmdAccRight)\n\t\tif app.nav.search == \"\" {\n\t\t\treturn\n\t\t}\n\n\t\tdir := app.nav.currDir()\n\t\told := dir.ind\n\t\tdir.ind = app.nav.searchInd\n\t\tdir.pos = app.nav.searchPos\n\n\t\tif _, err := app.nav.searchNext(); err != nil {\n\t\t\tapp.ui.echoerrf(\"search: %s: %s\", err, app.nav.search)\n\t\t} else if old != dir.ind {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase gOpts.incsearch && app.ui.cmdPrefix == \"?\":\n\t\tapp.nav.search = string(app.ui.cmdAccLeft) + string(app.ui.cmdAccRight)\n\t\tif app.nav.search == \"\" {\n\t\t\treturn\n\t\t}\n\n\t\tdir := app.nav.currDir()\n\t\told := dir.ind\n\t\tdir.ind = app.nav.searchInd\n\t\tdir.pos = app.nav.searchPos\n\n\t\tif _, err := app.nav.searchPrev(); err != nil {\n\t\t\tapp.ui.echoerrf(\"search: %s: %s\", err, app.nav.search)\n\t\t} else if old != dir.ind {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase gOpts.incfilter && app.ui.cmdPrefix == \"filter: \":\n\t\tfilter := string(app.ui.cmdAccLeft) + string(app.ui.cmdAccRight)\n\t\tdir := app.nav.currDir()\n\t\told := dir.ind\n\n\t\tif err := app.nav.setFilter(strings.Split(filter, \" \")); err != nil {\n\t\t\tapp.ui.echoerrf(\"filter: %s\", err)\n\t\t} else if old != dir.ind {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\t}\n}\n\nfunc restartIncCmd(app *app) {\n\tif gOpts.incsearch && (app.ui.cmdPrefix == \"/\" || app.ui.cmdPrefix == \"?\") {\n\t\tdir := app.nav.currDir()\n\t\tapp.nav.searchInd = dir.ind\n\t\tapp.nav.searchPos = dir.pos\n\t\tupdate(app)\n\t} else if gOpts.incfilter && app.ui.cmdPrefix == \"filter: \" {\n\t\tdir := app.nav.currDir()\n\t\tapp.nav.prevFilter = dir.filter\n\t\tupdate(app)\n\t}\n}\n\nfunc resetIncCmd(app *app) {\n\tif gOpts.incsearch && (app.ui.cmdPrefix == \"/\" || app.ui.cmdPrefix == \"?\") {\n\t\tdir := app.nav.currDir()\n\t\tdir.pos = app.nav.searchPos\n\t\tif dir.ind != app.nav.searchInd {\n\t\t\tdir.ind = app.nav.searchInd\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\t} else if gOpts.incfilter && app.ui.cmdPrefix == \"filter: \" {\n\t\tdir := app.nav.currDir()\n\t\told := dir.ind\n\t\tapp.nav.setFilter(app.nav.prevFilter)\n\t\tif old != dir.ind {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\t}\n}\n\nfunc normal(app *app) {\n\tresetIncCmd(app)\n\n\tapp.cmdHistoryInd = 0\n\tapp.menuCompActive = false\n\n\tapp.ui.menuBuf = nil\n\tapp.ui.cmdAccLeft = nil\n\tapp.ui.cmdAccRight = nil\n\tapp.ui.cmdPrefix = \"\"\n}\n\nfunc insert(app *app, arg string) {\n\tswitch {\n\tcase gOpts.incsearch && (app.ui.cmdPrefix == \"/\" || app.ui.cmdPrefix == \"?\"):\n\t\tapp.ui.cmdAccLeft = append(app.ui.cmdAccLeft, []rune(arg)...)\n\t\tupdate(app)\n\tcase gOpts.incfilter && app.ui.cmdPrefix == \"filter: \":\n\t\tapp.ui.cmdAccLeft = append(app.ui.cmdAccLeft, []rune(arg)...)\n\t\tupdate(app)\n\tcase app.ui.cmdPrefix == \"find: \":\n\t\tapp.nav.find = string(app.ui.cmdAccLeft) + arg + string(app.ui.cmdAccRight)\n\n\t\tif gOpts.findlen == 0 {\n\t\t\tswitch app.nav.findSingle() {\n\t\t\tcase 0:\n\t\t\t\tapp.ui.echoerrf(\"find: pattern not found: %s\", app.nav.find)\n\t\t\tcase 1:\n\t\t\t\tapp.ui.loadFile(app, true)\n\t\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t\tdefault:\n\t\t\t\tapp.ui.cmdAccLeft = append(app.ui.cmdAccLeft, []rune(arg)...)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif len(app.nav.find) < gOpts.findlen {\n\t\t\t\tapp.ui.cmdAccLeft = append(app.ui.cmdAccLeft, []rune(arg)...)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif moved, found := app.nav.findNext(); !found {\n\t\t\t\tapp.ui.echoerrf(\"find: pattern not found: %s\", app.nav.find)\n\t\t\t} else if moved {\n\t\t\t\tapp.ui.loadFile(app, true)\n\t\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t\t}\n\t\t}\n\n\t\tnormal(app)\n\tcase app.ui.cmdPrefix == \"find-back: \":\n\t\tapp.nav.find = string(app.ui.cmdAccLeft) + arg + string(app.ui.cmdAccRight)\n\n\t\tif gOpts.findlen == 0 {\n\t\t\tswitch app.nav.findSingle() {\n\t\t\tcase 0:\n\t\t\t\tapp.ui.echoerrf(\"find-back: pattern not found: %s\", app.nav.find)\n\t\t\tcase 1:\n\t\t\t\tapp.ui.loadFile(app, true)\n\t\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t\tdefault:\n\t\t\t\tapp.ui.cmdAccLeft = append(app.ui.cmdAccLeft, []rune(arg)...)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif len(app.nav.find) < gOpts.findlen {\n\t\t\t\tapp.ui.cmdAccLeft = append(app.ui.cmdAccLeft, []rune(arg)...)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif moved, found := app.nav.findPrev(); !found {\n\t\t\t\tapp.ui.echoerrf(\"find-back: pattern not found: %s\", app.nav.find)\n\t\t\t} else if moved {\n\t\t\t\tapp.ui.loadFile(app, true)\n\t\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t\t}\n\t\t}\n\n\t\tnormal(app)\n\tcase strings.HasPrefix(app.ui.cmdPrefix, \"delete\"):\n\t\tnormal(app)\n\n\t\tif arg == \"y\" {\n\t\t\tif err := app.nav.del(app); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"delete: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tapp.nav.unselect()\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase strings.HasPrefix(app.ui.cmdPrefix, \"replace\"):\n\t\tnormal(app)\n\n\t\tif arg == \"y\" {\n\t\t\tif err := app.nav.rename(); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"rename: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gSingleMode {\n\t\t\t\tapp.nav.renew()\n\t\t\t\tapp.ui.loadFile(app, true)\n\t\t\t} else {\n\t\t\t\tif err := remote(\"send load\"); err != nil {\n\t\t\t\t\tapp.ui.echoerrf(\"rename: %s\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase strings.HasPrefix(app.ui.cmdPrefix, \"create\"):\n\t\tnormal(app)\n\n\t\tif arg == \"y\" {\n\t\t\tif err := os.MkdirAll(filepath.Dir(app.nav.renameNewPath), os.ModePerm); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"rename: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err := app.nav.rename(); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"rename: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif gSingleMode {\n\t\t\t\tapp.nav.renew()\n\t\t\t\tapp.ui.loadFile(app, true)\n\t\t\t} else {\n\t\t\t\tif err := remote(\"send load\"); err != nil {\n\t\t\t\t\tapp.ui.echoerrf(\"rename: %s\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase app.ui.cmdPrefix == \"mark-save: \":\n\t\tnormal(app)\n\n\t\tapp.nav.marks[arg] = app.nav.currDir().path\n\t\tif err := app.nav.writeMarks(); err != nil {\n\t\t\tapp.ui.echoerrf(\"mark-save: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tif gSingleMode {\n\t\t\tif err := app.nav.sync(); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"mark-save: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := remote(\"send sync\"); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"mark-save: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase app.ui.cmdPrefix == \"mark-load: \":\n\t\tnormal(app)\n\n\t\twd, err := os.Getwd()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"getting current directory: %s\", err)\n\t\t}\n\n\t\tpath, ok := app.nav.marks[arg]\n\t\tif !ok {\n\t\t\tapp.ui.echoerr(\"mark-load: no such mark\")\n\t\t\treturn\n\t\t}\n\n\t\tif wd != path {\n\t\t\tresetIncCmd(app)\n\t\t\tpreChdir(app)\n\t\t}\n\n\t\tif err := app.nav.cd(path); err != nil {\n\t\t\tapp.ui.echoerrf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\t\tapp.ui.loadFile(app, true)\n\t\tapp.ui.loadFileInfo(app.nav)\n\n\t\tif wd != path {\n\t\t\tapp.nav.marks[\"'\"] = wd\n\t\t\trestartIncCmd(app)\n\t\t\tonChdir(app)\n\t\t}\n\tcase app.ui.cmdPrefix == \"mark-remove: \":\n\t\tnormal(app)\n\t\tif err := app.nav.removeMark(arg); err != nil {\n\t\t\tapp.ui.echoerrf(\"mark-remove: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tif err := app.nav.writeMarks(); err != nil {\n\t\t\tapp.ui.echoerrf(\"mark-remove: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tif gSingleMode {\n\t\t\tif err := app.nav.sync(); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"mark-remove: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := remote(\"send sync\"); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"mark-remove: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase app.ui.cmdPrefix == \":\" && len(app.ui.cmdAccLeft) == 0:\n\t\tswitch arg {\n\t\tcase \"!\", \"$\", \"%\", \"&\":\n\t\t\tapp.ui.cmdPrefix = arg\n\t\t\treturn\n\t\t}\n\t\tfallthrough\n\tdefault:\n\t\tapp.ui.menuBuf = nil\n\t\tapp.menuCompActive = false\n\t\tapp.ui.cmdAccLeft = append(app.ui.cmdAccLeft, []rune(arg)...)\n\t}\n}\n\nfunc (e *callExpr) eval(app *app, args []string) {\n\tos.Setenv(\"lf_count\", strconv.Itoa(e.count))\n\n\tswitch e.name {\n\tcase \"up\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif app.nav.up(e.count) {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase \"half-up\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif app.nav.up(e.count * app.nav.height / 2) {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase \"page-up\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif app.nav.up(e.count * app.nav.height) {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase \"scroll-up\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif app.nav.scrollUp(e.count) {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase \"down\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif app.nav.down(e.count) {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase \"half-down\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif app.nav.down(e.count * app.nav.height / 2) {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase \"page-down\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif app.nav.down(e.count * app.nav.height) {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase \"scroll-down\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif app.nav.scrollDown(e.count) {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase \"updir\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tresetIncCmd(app)\n\t\tpreChdir(app)\n\t\tfor i := 0; i < e.count; i++ {\n\t\t\tif err := app.nav.updir(); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"%s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tapp.ui.loadFile(app, true)\n\t\tapp.ui.loadFileInfo(app.nav)\n\t\trestartIncCmd(app)\n\t\tonChdir(app)\n\tcase \"open\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tcurr, err := app.nav.currFile()\n\t\tif err != nil {\n\t\t\tapp.ui.echoerrf(\"opening: %s\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif curr.IsDir() {\n\t\t\tresetIncCmd(app)\n\t\t\tpreChdir(app)\n\t\t\terr := app.nav.open()\n\t\t\tif err != nil {\n\t\t\t\tapp.ui.echoerrf(\"opening directory: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t\trestartIncCmd(app)\n\t\t\tonChdir(app)\n\t\t\treturn\n\t\t}\n\n\t\tif gSelectionPath != \"\" || gPrintSelection {\n\t\t\tapp.selectionOut, _ = app.nav.currFileOrSelections()\n\t\t\tapp.quitChan <- struct{}{}\n\t\t\treturn\n\t\t}\n\n\t\tapp.ui.loadFileInfo(app.nav)\n\n\t\tif cmd, ok := gOpts.cmds[\"open\"]; ok {\n\t\t\tcmd.eval(app, e.args)\n\t\t}\n\tcase \"jump-prev\":\n\t\tresetIncCmd(app)\n\t\tpreChdir(app)\n\t\tfor i := 0; i < e.count; i++ {\n\t\t\tapp.nav.cdJumpListPrev()\n\t\t}\n\t\tapp.ui.loadFile(app, true)\n\t\tapp.ui.loadFileInfo(app.nav)\n\t\trestartIncCmd(app)\n\t\tonChdir(app)\n\tcase \"jump-next\":\n\t\tresetIncCmd(app)\n\t\tpreChdir(app)\n\t\tfor i := 0; i < e.count; i++ {\n\t\t\tapp.nav.cdJumpListNext()\n\t\t}\n\t\tapp.ui.loadFile(app, true)\n\t\tapp.ui.loadFileInfo(app.nav)\n\t\trestartIncCmd(app)\n\t\tonChdir(app)\n\tcase \"quit\":\n\t\tapp.quitChan <- struct{}{}\n\tcase \"top\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tvar moved bool\n\t\tif e.count == 1 {\n\t\t\tmoved = app.nav.top()\n\t\t} else {\n\t\t\tmoved = app.nav.move(e.count - 1)\n\t\t}\n\t\tif moved {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase \"bottom\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tvar moved bool\n\t\tif e.count == 1 {\n\t\t\t// Different from Vim, which would treat a count of 1 as meaning to\n\t\t\t// move to the first line (i.e. the top)\n\t\t\tmoved = app.nav.bottom()\n\t\t} else {\n\t\t\tmoved = app.nav.move(e.count - 1)\n\t\t}\n\t\tif moved {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase \"high\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif app.nav.high() {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase \"middle\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif app.nav.middle() {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase \"low\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif app.nav.low() {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase \"toggle\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif len(e.args) == 0 {\n\t\t\tapp.nav.toggle()\n\t\t} else {\n\t\t\tdir := app.nav.currDir()\n\t\t\tfor _, path := range e.args {\n\t\t\t\tpath = replaceTilde(path)\n\t\t\t\tif !filepath.IsAbs(path) {\n\t\t\t\t\tpath = filepath.Join(dir.path, path)\n\t\t\t\t}\n\t\t\t\tif _, err := os.Lstat(path); !os.IsNotExist(err) {\n\t\t\t\t\tapp.nav.toggleSelection(path)\n\t\t\t\t} else {\n\t\t\t\t\tapp.ui.echoerrf(\"toggle: %s\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcase \"tag-toggle\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\n\t\ttag := \"*\"\n\t\tif len(e.args) != 0 {\n\t\t\ttag = e.args[0]\n\t\t}\n\n\t\tif err := app.nav.tagToggle(tag); err != nil {\n\t\t\tapp.ui.echoerrf(\"tag-toggle: %s\", err)\n\t\t} else if err := app.nav.writeTags(); err != nil {\n\t\t\tapp.ui.echoerrf(\"tag-toggle: %s\", err)\n\t\t}\n\n\t\tif gSingleMode {\n\t\t\tif err := app.nav.sync(); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"tag-toggle: %s\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tif err := remote(\"send sync\"); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"tag-toggle: %s\", err)\n\t\t\t}\n\t\t}\n\tcase \"tag\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\n\t\ttag := \"*\"\n\t\tif len(e.args) != 0 {\n\t\t\ttag = e.args[0]\n\t\t}\n\n\t\tif err := app.nav.tag(tag); err != nil {\n\t\t\tapp.ui.echoerrf(\"tag: %s\", err)\n\t\t} else if err := app.nav.writeTags(); err != nil {\n\t\t\tapp.ui.echoerrf(\"tag: %s\", err)\n\t\t}\n\n\t\tif gSingleMode {\n\t\t\tif err := app.nav.sync(); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"tag: %s\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tif err := remote(\"send sync\"); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"tag: %s\", err)\n\t\t\t}\n\t\t}\n\tcase \"invert\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tapp.nav.invert()\n\tcase \"invert-below\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tapp.nav.invertBelow()\n\tcase \"unselect\":\n\t\tapp.nav.unselect()\n\tcase \"calcdirsize\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\terr := app.nav.calcDirSize()\n\t\tif err != nil {\n\t\t\tapp.ui.echoerrf(\"calcdirsize: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tapp.ui.loadFileInfo(app.nav)\n\t\tapp.nav.sort()\n\t\tapp.ui.sort()\n\tcase \"clearmaps\":\n\t\t// leave `:` and cmaps bound so the user can still exit using `:quit`\n\t\tgOpts.keys = make(map[string]expr)\n\t\tgOpts.keys[\":\"] = &callExpr{\"read\", nil, 1}\n\tcase \"copy\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\n\t\tif err := app.nav.save(true); err != nil {\n\t\t\tapp.ui.echoerrf(\"copy: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tapp.nav.unselect()\n\t\tif gSingleMode {\n\t\t\tif err := app.nav.sync(); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"copy: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := remote(\"send sync\"); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"copy: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"cut\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\n\t\tif err := app.nav.save(false); err != nil {\n\t\t\tapp.ui.echoerrf(\"cut: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tapp.nav.unselect()\n\t\tif gSingleMode {\n\t\t\tif err := app.nav.sync(); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"cut: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := remote(\"send sync\"); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"cut: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"paste\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\n\t\tif cmd, ok := gOpts.cmds[\"paste\"]; ok {\n\t\t\tcmd.eval(app, e.args)\n\t\t} else if err := app.nav.paste(app); err != nil {\n\t\t\tapp.ui.echoerrf(\"paste: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tapp.ui.loadFile(app, true)\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"delete\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\n\t\tif cmd, ok := gOpts.cmds[\"delete\"]; ok {\n\t\t\tcmd.eval(app, e.args)\n\t\t\tapp.nav.unselect()\n\t\t\tif gSingleMode {\n\t\t\t\tapp.nav.renew()\n\t\t\t\tapp.ui.loadFile(app, true)\n\t\t\t} else {\n\t\t\t\tif err := remote(\"send load\"); err != nil {\n\t\t\t\t\tapp.ui.echoerrf(\"delete: %s\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlist, err := app.nav.currFileOrSelections()\n\t\t\tif err != nil {\n\t\t\t\tapp.ui.echoerrf(\"delete: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif app.ui.cmdPrefix == \">\" {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tnormal(app)\n\t\t\tif len(list) == 1 {\n\t\t\t\tapp.ui.cmdPrefix = \"delete '\" + list[0] + \"' ? [y/N] \"\n\t\t\t} else {\n\t\t\t\tapp.ui.cmdPrefix = \"delete \" + strconv.Itoa(len(list)) + \" items? [y/N] \"\n\t\t\t}\n\t\t}\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"clear\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif err := saveFiles(nil, false); err != nil {\n\t\t\tapp.ui.echoerrf(\"clear: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tif gSingleMode {\n\t\t\tif err := app.nav.sync(); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"clear: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\tif err := remote(\"send sync\"); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"clear: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"draw\":\n\tcase \"redraw\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tapp.ui.renew()\n\t\tapp.ui.screen.Sync()\n\t\tif app.nav.height != app.ui.wins[0].h {\n\t\t\tapp.nav.height = app.ui.wins[0].h\n\t\t\tapp.nav.regCache = make(map[string]*reg)\n\t\t}\n\t\tif gOpts.sixel {\n\t\t\tapp.nav.regCache = make(map[string]*reg)\n\t\t\tapp.ui.sxScreen.lastFile = \"\"\n\t\t}\n\t\tfor _, dir := range app.nav.dirs {\n\t\t\tdir.boundPos(app.nav.height)\n\t\t}\n\t\tapp.ui.loadFile(app, true)\n\t\tonRedraw(app)\n\tcase \"load\":\n\t\tif !app.nav.init || gOpts.watch {\n\t\t\treturn\n\t\t}\n\t\tapp.nav.renew()\n\t\tapp.ui.loadFile(app, false)\n\tcase \"reload\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif err := app.nav.reload(); err != nil {\n\t\t\tapp.ui.echoerrf(\"reload: %s\", err)\n\t\t}\n\t\tapp.ui.loadFile(app, true)\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"read\":\n\t\tif app.ui.cmdPrefix == \">\" {\n\t\t\treturn\n\t\t}\n\t\tnormal(app)\n\t\tapp.ui.cmdPrefix = \":\"\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"shell\":\n\t\tif app.ui.cmdPrefix == \">\" {\n\t\t\treturn\n\t\t}\n\t\tnormal(app)\n\t\tapp.ui.cmdPrefix = \"$\"\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"shell-pipe\":\n\t\tif app.ui.cmdPrefix == \">\" {\n\t\t\treturn\n\t\t}\n\t\tnormal(app)\n\t\tapp.ui.cmdPrefix = \"%\"\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"shell-wait\":\n\t\tif app.ui.cmdPrefix == \">\" {\n\t\t\treturn\n\t\t}\n\t\tnormal(app)\n\t\tapp.ui.cmdPrefix = \"!\"\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"shell-async\":\n\t\tif app.ui.cmdPrefix == \">\" {\n\t\t\treturn\n\t\t}\n\t\tnormal(app)\n\t\tapp.ui.cmdPrefix = \"&\"\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"find\":\n\t\tif app.ui.cmdPrefix == \">\" {\n\t\t\treturn\n\t\t}\n\t\tnormal(app)\n\t\tapp.ui.cmdPrefix = \"find: \"\n\t\tapp.nav.findBack = false\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"find-back\":\n\t\tif app.ui.cmdPrefix == \">\" {\n\t\t\treturn\n\t\t}\n\t\tnormal(app)\n\t\tapp.ui.cmdPrefix = \"find-back: \"\n\t\tapp.nav.findBack = true\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"find-next\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tdir := app.nav.currDir()\n\t\told := dir.ind\n\t\tfor i := 0; i < e.count; i++ {\n\t\t\tif app.nav.findBack {\n\t\t\t\tapp.nav.findPrev()\n\t\t\t} else {\n\t\t\t\tapp.nav.findNext()\n\t\t\t}\n\t\t}\n\t\tif old != dir.ind {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase \"find-prev\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tdir := app.nav.currDir()\n\t\told := dir.ind\n\t\tfor i := 0; i < e.count; i++ {\n\t\t\tif app.nav.findBack {\n\t\t\t\tapp.nav.findNext()\n\t\t\t} else {\n\t\t\t\tapp.nav.findPrev()\n\t\t\t}\n\t\t}\n\t\tif old != dir.ind {\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t}\n\tcase \"search\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif app.ui.cmdPrefix == \">\" {\n\t\t\treturn\n\t\t}\n\t\tnormal(app)\n\t\tapp.ui.cmdPrefix = \"/\"\n\t\tdir := app.nav.currDir()\n\t\tapp.nav.searchInd = dir.ind\n\t\tapp.nav.searchPos = dir.pos\n\t\tapp.nav.searchBack = false\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"search-back\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif app.ui.cmdPrefix == \">\" {\n\t\t\treturn\n\t\t}\n\t\tnormal(app)\n\t\tapp.ui.cmdPrefix = \"?\"\n\t\tdir := app.nav.currDir()\n\t\tapp.nav.searchInd = dir.ind\n\t\tapp.nav.searchPos = dir.pos\n\t\tapp.nav.searchBack = true\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"search-next\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tfor i := 0; i < e.count; i++ {\n\t\t\tif app.nav.searchBack {\n\t\t\t\tif moved, err := app.nav.searchPrev(); err != nil {\n\t\t\t\t\tapp.ui.echoerrf(\"search-back: %s: %s\", err, app.nav.search)\n\t\t\t\t} else if moved {\n\t\t\t\t\tapp.ui.loadFile(app, true)\n\t\t\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif moved, err := app.nav.searchNext(); err != nil {\n\t\t\t\t\tapp.ui.echoerrf(\"search: %s: %s\", err, app.nav.search)\n\t\t\t\t} else if moved {\n\t\t\t\t\tapp.ui.loadFile(app, true)\n\t\t\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcase \"search-prev\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tfor i := 0; i < e.count; i++ {\n\t\t\tif app.nav.searchBack {\n\t\t\t\tif moved, err := app.nav.searchNext(); err != nil {\n\t\t\t\t\tapp.ui.echoerrf(\"search-back: %s: %s\", err, app.nav.search)\n\t\t\t\t} else if moved {\n\t\t\t\t\tapp.ui.loadFile(app, true)\n\t\t\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif moved, err := app.nav.searchPrev(); err != nil {\n\t\t\t\t\tapp.ui.echoerrf(\"search: %s: %s\", err, app.nav.search)\n\t\t\t\t} else if moved {\n\t\t\t\t\tapp.ui.loadFile(app, true)\n\t\t\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcase \"filter\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif app.ui.cmdPrefix == \">\" {\n\t\t\treturn\n\t\t}\n\t\tnormal(app)\n\t\tapp.ui.cmdPrefix = \"filter: \"\n\t\tdir := app.nav.currDir()\n\t\tapp.nav.prevFilter = dir.filter\n\t\tif len(e.args) == 0 {\n\t\t\tapp.ui.cmdAccLeft = []rune(strings.Join(dir.filter, \" \"))\n\t\t} else {\n\t\t\tapp.ui.cmdAccLeft = []rune(strings.Join(e.args, \" \"))\n\t\t}\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"setfilter\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tlog.Printf(\"filter: %s\", e.args)\n\t\tif err := app.nav.setFilter(e.args); err != nil {\n\t\t\tapp.ui.echoerrf(\"filter: %s\", err)\n\t\t}\n\t\tapp.ui.loadFile(app, true)\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"mark-save\":\n\t\tif app.ui.cmdPrefix == \">\" {\n\t\t\treturn\n\t\t}\n\t\tnormal(app)\n\t\tapp.ui.cmdPrefix = \"mark-save: \"\n\tcase \"mark-load\":\n\t\tif app.ui.cmdPrefix == \">\" {\n\t\t\treturn\n\t\t}\n\t\tnormal(app)\n\t\tapp.ui.menuBuf = listMarks(app.nav.marks)\n\t\tapp.ui.cmdPrefix = \"mark-load: \"\n\tcase \"mark-remove\":\n\t\tif app.ui.cmdPrefix == \">\" {\n\t\t\treturn\n\t\t}\n\t\tnormal(app)\n\t\tapp.ui.menuBuf = listMarks(app.nav.marks)\n\t\tapp.ui.cmdPrefix = \"mark-remove: \"\n\tcase \"rename\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif cmd, ok := gOpts.cmds[\"rename\"]; ok {\n\t\t\tcmd.eval(app, e.args)\n\t\t\tif gSingleMode {\n\t\t\t\tapp.nav.renew()\n\t\t\t\tapp.ui.loadFile(app, true)\n\t\t\t} else {\n\t\t\t\tif err := remote(\"send load\"); err != nil {\n\t\t\t\t\tapp.ui.echoerrf(\"rename: %s\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tcurr, err := app.nav.currFile()\n\t\t\tif err != nil {\n\t\t\t\tapp.ui.echoerrf(\"rename: %s:\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif app.ui.cmdPrefix == \">\" {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tnormal(app)\n\t\t\tapp.ui.cmdPrefix = \"rename: \"\n\t\t\textension := getFileExtension(curr)\n\t\t\tif len(extension) == 0 {\n\t\t\t\t// no extension or .hidden or is directory\n\t\t\t\tapp.ui.cmdAccLeft = append(app.ui.cmdAccLeft, []rune(curr.Name())...)\n\t\t\t} else {\n\t\t\t\tapp.ui.cmdAccLeft = append(app.ui.cmdAccLeft, []rune(curr.Name()[:len(curr.Name())-len(extension)])...)\n\t\t\t\tapp.ui.cmdAccRight = append(app.ui.cmdAccRight, []rune(extension)...)\n\t\t\t}\n\t\t}\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"sync\":\n\t\tif err := app.nav.sync(); err != nil {\n\t\t\tapp.ui.echoerrf(\"sync: %s\", err)\n\t\t}\n\tcase \"echo\":\n\t\tapp.ui.echo(strings.Join(e.args, \" \"))\n\tcase \"echomsg\":\n\t\tapp.ui.echomsg(strings.Join(e.args, \" \"))\n\tcase \"echoerr\":\n\t\tapp.ui.echoerr(strings.Join(e.args, \" \"))\n\tcase \"cd\":\n\t\tpath := \"~\"\n\t\tif len(e.args) > 0 {\n\t\t\tpath = e.args[0]\n\t\t}\n\n\t\twd, err := os.Getwd()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"getting current directory: %s\", err)\n\t\t}\n\n\t\tpath = replaceTilde(path)\n\t\tif !filepath.IsAbs(path) {\n\t\t\tpath = filepath.Join(wd, path)\n\t\t} else {\n\t\t\tpath = filepath.Clean(path)\n\t\t}\n\n\t\tif wd != path {\n\t\t\tresetIncCmd(app)\n\t\t\tpreChdir(app)\n\t\t}\n\n\t\tif err := app.nav.cd(path); err != nil {\n\t\t\tapp.ui.echoerrf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\n\t\tapp.ui.loadFile(app, true)\n\t\tapp.ui.loadFileInfo(app.nav)\n\n\t\tif wd != path {\n\t\t\tapp.nav.marks[\"'\"] = wd\n\t\t\trestartIncCmd(app)\n\t\t\tonChdir(app)\n\t\t}\n\tcase \"select\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\n\t\tif len(e.args) != 1 {\n\t\t\tapp.ui.echoerr(\"select: requires an argument\")\n\t\t\treturn\n\t\t}\n\n\t\twd, err := os.Getwd()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"getting current directory: %s\", err)\n\t\t}\n\n\t\tpath := filepath.Dir(replaceTilde(e.args[0]))\n\t\tif !filepath.IsAbs(path) {\n\t\t\tpath = filepath.Join(wd, path)\n\t\t} else {\n\t\t\tpath = filepath.Clean(path)\n\t\t}\n\n\t\tif wd != path {\n\t\t\tresetIncCmd(app)\n\t\t\tpreChdir(app)\n\t\t}\n\n\t\tif err := app.nav.sel(e.args[0]); err != nil {\n\t\t\tapp.ui.echoerrf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\n\t\tapp.ui.loadFile(app, true)\n\t\tapp.ui.loadFileInfo(app.nav)\n\n\t\tif wd != path {\n\t\t\tapp.nav.marks[\"'\"] = wd\n\t\t\trestartIncCmd(app)\n\t\t\tonChdir(app)\n\t\t}\n\tcase \"glob-select\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif len(e.args) != 1 {\n\t\t\tapp.ui.echoerr(\"glob-select: requires a pattern to match\")\n\t\t\treturn\n\t\t}\n\t\tif err := app.nav.globSel(e.args[0], false); err != nil {\n\t\t\tapp.ui.echoerrf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\tcase \"glob-unselect\":\n\t\tif !app.nav.init {\n\t\t\treturn\n\t\t}\n\t\tif len(e.args) != 1 {\n\t\t\tapp.ui.echoerr(\"glob-unselect: requires a pattern to match\")\n\t\t\treturn\n\t\t}\n\t\tif err := app.nav.globSel(e.args[0], true); err != nil {\n\t\t\tapp.ui.echoerrf(\"%s\", err)\n\t\t\treturn\n\t\t}\n\tcase \"source\":\n\t\tif len(e.args) != 1 {\n\t\t\tapp.ui.echoerr(\"source: requires an argument\")\n\t\t\treturn\n\t\t}\n\t\tapp.readFile(replaceTilde(e.args[0]))\n\t\tapp.ui.loadFileInfo(app.nav)\n\tcase \"push\":\n\t\tif len(e.args) != 1 {\n\t\t\tapp.ui.echoerr(\"push: requires an argument\")\n\t\t\treturn\n\t\t}\n\t\tlog.Println(\"pushing keys\", e.args[0])\n\t\tfor _, val := range splitKeys(e.args[0]) {\n\t\t\tapp.ui.keyChan <- val\n\t\t}\n\tcase \"on-focus-gained\":\n\t\tonFocusGained(app)\n\tcase \"on-focus-lost\":\n\t\tonFocusLost(app)\n\tcase \"on-init\":\n\t\tonInit(app)\n\tcase \"cmd-insert\":\n\t\tif len(e.args) == 0 {\n\t\t\treturn\n\t\t}\n\t\tinsert(app, e.args[0])\n\tcase \"cmd-escape\":\n\t\tif app.ui.cmdPrefix == \">\" {\n\t\t\treturn\n\t\t}\n\t\tnormal(app)\n\tcase \"cmd-complete\":\n\t\tmatches := doComplete(app)\n\t\tapp.ui.menuBuf = listMatches(app.ui.screen, matches, -1)\n\tcase \"cmd-menu-complete\":\n\t\tmenuComplete(app, 1)\n\tcase \"cmd-menu-complete-back\":\n\t\tmenuComplete(app, -1)\n\tcase \"cmd-menu-accept\":\n\t\tapp.ui.menuBuf = nil\n\t\tapp.menuCompActive = false\n\tcase \"cmd-enter\":\n\t\ts := string(append(app.ui.cmdAccLeft, app.ui.cmdAccRight...))\n\t\tif len(s) == 0 && app.ui.cmdPrefix != \"filter: \" && app.ui.cmdPrefix != \">\" {\n\t\t\treturn\n\t\t}\n\n\t\tapp.ui.menuBuf = nil\n\t\tapp.menuCompActive = false\n\n\t\tapp.ui.cmdAccLeft = nil\n\t\tapp.ui.cmdAccRight = nil\n\n\t\tswitch app.ui.cmdPrefix {\n\t\tcase \":\":\n\t\t\tlog.Printf(\"command: %s\", s)\n\t\t\tapp.ui.cmdPrefix = \"\"\n\t\t\tapp.cmdHistory = append(app.cmdHistory, cmdItem{\":\", s})\n\t\t\tp := newParser(strings.NewReader(s))\n\t\t\tfor p.parse() {\n\t\t\t\tp.expr.eval(app, nil)\n\t\t\t}\n\t\t\tif p.err != nil {\n\t\t\t\tapp.ui.echoerrf(\"%s\", p.err)\n\t\t\t}\n\t\tcase \"$\":\n\t\t\tlog.Printf(\"shell: %s\", s)\n\t\t\tapp.ui.cmdPrefix = \"\"\n\t\t\tapp.cmdHistory = append(app.cmdHistory, cmdItem{\"$\", s})\n\t\t\tapp.runShell(s, nil, \"$\")\n\t\tcase \"%\":\n\t\t\tlog.Printf(\"shell-pipe: %s\", s)\n\t\t\tapp.cmdHistory = append(app.cmdHistory, cmdItem{\"%\", s})\n\t\t\tapp.runShell(s, nil, \"%\")\n\t\tcase \">\":\n\t\t\tio.WriteString(app.cmdIn, s+\"\\n\")\n\t\t\tapp.cmdOutBuf = nil\n\t\tcase \"!\":\n\t\t\tlog.Printf(\"shell-wait: %s\", s)\n\t\t\tapp.ui.cmdPrefix = \"\"\n\t\t\tapp.cmdHistory = append(app.cmdHistory, cmdItem{\"!\", s})\n\t\t\tapp.runShell(s, nil, \"!\")\n\t\tcase \"&\":\n\t\t\tlog.Printf(\"shell-async: %s\", s)\n\t\t\tapp.ui.cmdPrefix = \"\"\n\t\t\tapp.cmdHistory = append(app.cmdHistory, cmdItem{\"&\", s})\n\t\t\tapp.runShell(s, nil, \"&\")\n\t\tcase \"/\":\n\t\t\tdir := app.nav.currDir()\n\t\t\told := dir.ind\n\t\t\tif gOpts.incsearch {\n\t\t\t\tdir.ind = app.nav.searchInd\n\t\t\t\tdir.pos = app.nav.searchPos\n\t\t\t}\n\t\t\tlog.Printf(\"search: %s\", s)\n\t\t\tapp.ui.cmdPrefix = \"\"\n\t\t\tapp.nav.search = s\n\t\t\tif _, err := app.nav.searchNext(); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"search: %s: %s\", err, app.nav.search)\n\t\t\t} else if old != dir.ind {\n\t\t\t\tapp.ui.loadFile(app, true)\n\t\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t\t}\n\t\tcase \"?\":\n\t\t\tdir := app.nav.currDir()\n\t\t\told := dir.ind\n\t\t\tif gOpts.incsearch {\n\t\t\t\tdir.ind = app.nav.searchInd\n\t\t\t\tdir.pos = app.nav.searchPos\n\t\t\t}\n\t\t\tlog.Printf(\"search-back: %s\", s)\n\t\t\tapp.ui.cmdPrefix = \"\"\n\t\t\tapp.nav.search = s\n\t\t\tif _, err := app.nav.searchPrev(); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"search-back: %s: %s\", err, app.nav.search)\n\t\t\t} else if old != dir.ind {\n\t\t\t\tapp.ui.loadFile(app, true)\n\t\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t\t}\n\t\tcase \"filter: \":\n\t\t\tlog.Printf(\"filter: %s\", s)\n\t\t\tapp.ui.cmdPrefix = \"\"\n\t\t\tif err := app.nav.setFilter(strings.Split(s, \" \")); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"filter: %s\", err)\n\t\t\t}\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\tcase \"find: \":\n\t\t\tapp.ui.cmdPrefix = \"\"\n\t\t\tif moved, found := app.nav.findNext(); !found {\n\t\t\t\tapp.ui.echoerrf(\"find: pattern not found: %s\", app.nav.find)\n\t\t\t} else if moved {\n\t\t\t\tapp.ui.loadFile(app, true)\n\t\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t\t}\n\t\tcase \"find-back: \":\n\t\t\tapp.ui.cmdPrefix = \"\"\n\t\t\tif moved, found := app.nav.findPrev(); !found {\n\t\t\t\tapp.ui.echoerrf(\"find-back: pattern not found: %s\", app.nav.find)\n\t\t\t} else if moved {\n\t\t\t\tapp.ui.loadFile(app, true)\n\t\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\t\t}\n\t\tcase \"rename: \":\n\t\t\tapp.ui.cmdPrefix = \"\"\n\n\t\t\tcurr, err := app.nav.currFile()\n\t\t\tif err != nil {\n\t\t\t\tapp.ui.echoerrf(\"rename: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\twd, err := os.Getwd()\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"getting current directory: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\toldPath := filepath.Join(wd, curr.Name())\n\t\t\tnewPath := filepath.Clean(replaceTilde(s))\n\t\t\tif !filepath.IsAbs(newPath) {\n\t\t\t\tnewPath = filepath.Join(wd, newPath)\n\t\t\t}\n\t\t\tif oldPath == newPath {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tapp.nav.renameOldPath = oldPath\n\t\t\tapp.nav.renameNewPath = newPath\n\n\t\t\tnewDir := filepath.Dir(newPath)\n\t\t\tif _, err := os.Stat(newDir); os.IsNotExist(err) {\n\t\t\t\tapp.ui.cmdPrefix = \"create '\" + newDir + \"' ? [y/N] \"\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\toldStat, err := os.Lstat(oldPath)\n\t\t\tif err != nil {\n\t\t\t\tapp.ui.echoerrf(\"rename: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif newStat, err := os.Lstat(newPath); !os.IsNotExist(err) && !os.SameFile(oldStat, newStat) {\n\t\t\t\tapp.ui.cmdPrefix = \"replace '\" + newPath + \"' ? [y/N] \"\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err := app.nav.rename(); err != nil {\n\t\t\t\tapp.ui.echoerrf(\"rename: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif gSingleMode {\n\t\t\t\tapp.nav.renew()\n\t\t\t} else {\n\t\t\t\tif err := remote(\"send load\"); err != nil {\n\t\t\t\t\tapp.ui.echoerrf(\"rename: %s\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tapp.ui.loadFile(app, true)\n\t\t\tapp.ui.loadFileInfo(app.nav)\n\t\tdefault:\n\t\t\tlog.Printf(\"entering unknown execution prefix: %q\", app.ui.cmdPrefix)\n\t\t}\n\tcase \"cmd-history-next\":\n\t\tif app.ui.cmdPrefix == \"\" || app.ui.cmdPrefix == \">\" {\n\t\t\treturn\n\t\t}\n\t\tif app.cmdHistoryInd > 0 {\n\t\t\tapp.cmdHistoryInd--\n\t\t}\n\t\tif app.cmdHistoryInd == 0 {\n\t\t\tnormal(app)\n\t\t\tapp.ui.cmdPrefix = \":\"\n\t\t\treturn\n\t\t}\n\t\thistoryInd := app.cmdHistoryInd\n\t\tcmd := app.cmdHistory[len(app.cmdHistory)-historyInd]\n\t\tnormal(app)\n\t\tapp.cmdHistoryInd = historyInd\n\t\tapp.ui.cmdPrefix = cmd.prefix\n\t\tapp.ui.cmdAccLeft = []rune(cmd.value)\n\tcase \"cmd-history-prev\":\n\t\tif app.ui.cmdPrefix == \">\" {\n\t\t\treturn\n\t\t}\n\t\tif app.cmdHistoryInd == len(app.cmdHistory) {\n\t\t\treturn\n\t\t}\n\t\thistoryInd := app.cmdHistoryInd + 1\n\t\tcmd := app.cmdHistory[len(app.cmdHistory)-historyInd]\n\t\tnormal(app)\n\t\tapp.cmdHistoryInd = historyInd\n\t\tapp.ui.cmdPrefix = cmd.prefix\n\t\tapp.ui.cmdAccLeft = []rune(cmd.value)\n\tcase \"cmd-delete\":\n\t\tif len(app.ui.cmdAccRight) == 0 {\n\t\t\treturn\n\t\t}\n\t\tapp.ui.cmdAccRight = app.ui.cmdAccRight[1:]\n\t\tupdate(app)\n\tcase \"cmd-delete-back\":\n\t\tif len(app.ui.cmdAccLeft) == 0 {\n\t\t\tswitch app.ui.cmdPrefix {\n\t\t\tcase \"!\", \"$\", \"%\", \"&\":\n\t\t\t\tapp.ui.cmdPrefix = \":\"\n\t\t\tcase \">\", \"rename: \", \"filter: \":\n\t\t\t\t// Don't mess with programs waiting for input.\n\t\t\t\t// Exiting on backspace is also inconvenient for 'rename' and 'filter',\n\t\t\t\t// since the text field can start out nonempty.\n\t\t\tdefault:\n\t\t\t\tnormal(app)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tapp.ui.cmdAccLeft = app.ui.cmdAccLeft[:len(app.ui.cmdAccLeft)-1]\n\t\tupdate(app)\n\tcase \"cmd-left\":\n\t\tif len(app.ui.cmdAccLeft) == 0 {\n\t\t\treturn\n\t\t}\n\t\tapp.ui.cmdAccRight = append([]rune{app.ui.cmdAccLeft[len(app.ui.cmdAccLeft)-1]}, app.ui.cmdAccRight...)\n\t\tapp.ui.cmdAccLeft = app.ui.cmdAccLeft[:len(app.ui.cmdAccLeft)-1]\n\tcase \"cmd-right\":\n\t\tif len(app.ui.cmdAccRight) == 0 {\n\t\t\treturn\n\t\t}\n\t\tapp.ui.cmdAccLeft = append(app.ui.cmdAccLeft, app.ui.cmdAccRight[0])\n\t\tapp.ui.cmdAccRight = app.ui.cmdAccRight[1:]\n\tcase \"cmd-home\":\n\t\tapp.ui.cmdAccRight = append(app.ui.cmdAccLeft, app.ui.cmdAccRight...)\n\t\tapp.ui.cmdAccLeft = nil\n\tcase \"cmd-end\":\n\t\tapp.ui.cmdAccLeft = append(app.ui.cmdAccLeft, app.ui.cmdAccRight...)\n\t\tapp.ui.cmdAccRight = nil\n\tcase \"cmd-delete-home\":\n\t\tif len(app.ui.cmdAccLeft) == 0 {\n\t\t\treturn\n\t\t}\n\t\tapp.ui.cmdYankBuf = app.ui.cmdAccLeft\n\t\tapp.ui.cmdAccLeft = nil\n\t\tupdate(app)\n\tcase \"cmd-delete-end\":\n\t\tif len(app.ui.cmdAccRight) == 0 {\n\t\t\treturn\n\t\t}\n\t\tapp.ui.cmdYankBuf = app.ui.cmdAccRight\n\t\tapp.ui.cmdAccRight = nil\n\t\tupdate(app)\n\tcase \"cmd-delete-unix-word\":\n\t\tind := strings.LastIndex(strings.TrimRight(string(app.ui.cmdAccLeft), \" \"), \" \") + 1\n\t\tapp.ui.cmdYankBuf = []rune(string(app.ui.cmdAccLeft)[ind:])\n\t\tapp.ui.cmdAccLeft = []rune(string(app.ui.cmdAccLeft)[:ind])\n\t\tupdate(app)\n\tcase \"cmd-yank\":\n\t\tapp.ui.cmdAccLeft = append(app.ui.cmdAccLeft, app.ui.cmdYankBuf...)\n\t\tupdate(app)\n\tcase \"cmd-transpose\":\n\t\tif len(app.ui.cmdAccLeft) < 2 {\n\t\t\treturn\n\t\t}\n\t\tapp.ui.cmdAccLeft[len(app.ui.cmdAccLeft)-1], app.ui.cmdAccLeft[len(app.ui.cmdAccLeft)-2] = app.ui.cmdAccLeft[len(app.ui.cmdAccLeft)-2], app.ui.cmdAccLeft[len(app.ui.cmdAccLeft)-1]\n\t\tupdate(app)\n\tcase \"cmd-interrupt\":\n\t\tif app.cmd != nil {\n\t\t\terr := shellKill(app.cmd)\n\t\t\tif err != nil {\n\t\t\t\tapp.ui.echoerrf(\"kill: %s\", err)\n\t\t\t} else {\n\t\t\t\tapp.ui.echoerr(\"process interrupt\")\n\t\t\t}\n\t\t}\n\t\tnormal(app)\n\tcase \"cmd-word\":\n\t\tif len(app.ui.cmdAccRight) == 0 {\n\t\t\treturn\n\t\t}\n\t\tloc := reWordEnd.FindStringSubmatchIndex(string(app.ui.cmdAccRight))\n\t\tif loc == nil {\n\t\t\treturn\n\t\t}\n\t\tind := loc[3]\n\t\tapp.ui.cmdAccLeft = append(app.ui.cmdAccLeft, []rune(string(app.ui.cmdAccRight)[:ind])...)\n\t\tapp.ui.cmdAccRight = []rune(string(app.ui.cmdAccRight)[ind:])\n\tcase \"cmd-word-back\":\n\t\tif len(app.ui.cmdAccLeft) == 0 {\n\t\t\treturn\n\t\t}\n\t\tlocs := reWordBeg.FindAllStringSubmatchIndex(string(app.ui.cmdAccLeft), -1)\n\t\tif locs == nil {\n\t\t\treturn\n\t\t}\n\t\tind := locs[len(locs)-1][3]\n\t\told := app.ui.cmdAccRight\n\t\tapp.ui.cmdAccRight = append([]rune(string(app.ui.cmdAccLeft)[ind:]), old...)\n\t\tapp.ui.cmdAccLeft = []rune(string(app.ui.cmdAccLeft)[:ind])\n\tcase \"cmd-capitalize-word\":\n\t\tif len(app.ui.cmdAccRight) == 0 {\n\t\t\treturn\n\t\t}\n\t\tind := 0\n\t\tfor ; ind < len(app.ui.cmdAccRight) && unicode.IsSpace(app.ui.cmdAccRight[ind]); ind++ {\n\t\t}\n\t\tif ind >= len(app.ui.cmdAccRight) {\n\t\t\treturn\n\t\t}\n\t\tapp.ui.cmdAccRight[ind] = unicode.ToUpper(app.ui.cmdAccRight[ind])\n\t\tloc := reWordEnd.FindStringSubmatchIndex(string(app.ui.cmdAccRight))\n\t\tif loc == nil {\n\t\t\treturn\n\t\t}\n\t\tind = loc[3]\n\t\tapp.ui.cmdAccLeft = append(app.ui.cmdAccLeft, []rune(string(app.ui.cmdAccRight)[:ind])...)\n\t\tapp.ui.cmdAccRight = []rune(string(app.ui.cmdAccRight)[ind:])\n\t\tupdate(app)\n\tcase \"cmd-delete-word\":\n\t\tif len(app.ui.cmdAccRight) == 0 {\n\t\t\treturn\n\t\t}\n\t\tloc := reWordEnd.FindStringSubmatchIndex(string(app.ui.cmdAccRight))\n\t\tif loc == nil {\n\t\t\treturn\n\t\t}\n\t\tind := loc[3]\n\t\tapp.ui.cmdYankBuf = []rune(string(app.ui.cmdAccRight)[:ind])\n\t\tapp.ui.cmdAccRight = []rune(string(app.ui.cmdAccRight)[ind:])\n\t\tupdate(app)\n\tcase \"cmd-delete-word-back\":\n\t\tif len(app.ui.cmdAccLeft) == 0 {\n\t\t\treturn\n\t\t}\n\t\tlocs := reWordBeg.FindAllStringSubmatchIndex(string(app.ui.cmdAccLeft), -1)\n\t\tif locs == nil {\n\t\t\treturn\n\t\t}\n\t\tind := locs[len(locs)-1][3]\n\t\tapp.ui.cmdYankBuf = []rune(string(app.ui.cmdAccLeft)[ind:])\n\t\tapp.ui.cmdAccLeft = app.ui.cmdAccLeft[:ind]\n\t\tupdate(app)\n\tcase \"cmd-uppercase-word\":\n\t\tif len(app.ui.cmdAccRight) == 0 {\n\t\t\treturn\n\t\t}\n\t\tloc := reWordEnd.FindStringSubmatchIndex(string(app.ui.cmdAccRight))\n\t\tif loc == nil {\n\t\t\treturn\n\t\t}\n\t\tind := loc[3]\n\t\tapp.ui.cmdAccLeft = append(app.ui.cmdAccLeft, []rune(strings.ToUpper(string(app.ui.cmdAccRight)[:ind]))...)\n\t\tapp.ui.cmdAccRight = []rune(string(app.ui.cmdAccRight)[ind:])\n\t\tupdate(app)\n\tcase \"cmd-lowercase-word\":\n\t\tif len(app.ui.cmdAccRight) == 0 {\n\t\t\treturn\n\t\t}\n\t\tloc := reWordEnd.FindStringSubmatchIndex(string(app.ui.cmdAccRight))\n\t\tif loc == nil {\n\t\t\treturn\n\t\t}\n\t\tind := loc[3]\n\t\tapp.ui.cmdAccLeft = append(app.ui.cmdAccLeft, []rune(strings.ToLower(string(app.ui.cmdAccRight)[:ind]))...)\n\t\tapp.ui.cmdAccRight = []rune(string(app.ui.cmdAccRight)[ind:])\n\t\tupdate(app)\n\tcase \"cmd-transpose-word\":\n\t\tif len(app.ui.cmdAccLeft) == 0 {\n\t\t\treturn\n\t\t}\n\n\t\tlocs := reWord.FindAllStringIndex(string(app.ui.cmdAccLeft), -1)\n\t\tif len(locs) < 2 {\n\t\t\treturn\n\t\t}\n\n\t\tif len(app.ui.cmdAccRight) > 0 {\n\t\t\tloc := reWordEnd.FindStringSubmatchIndex(string(app.ui.cmdAccRight))\n\t\t\tif loc != nil {\n\t\t\t\tind := loc[3]\n\t\t\t\tapp.ui.cmdAccLeft = append(app.ui.cmdAccLeft, []rune(string(app.ui.cmdAccRight)[:ind])...)\n\t\t\t\tapp.ui.cmdAccRight = []rune(string(app.ui.cmdAccRight)[ind:])\n\t\t\t}\n\t\t}\n\n\t\tlocs = reWord.FindAllStringIndex(string(app.ui.cmdAccLeft), -1)\n\n\t\tbeg1, end1 := locs[len(locs)-2][0], locs[len(locs)-2][1]\n\t\tbeg2, end2 := locs[len(locs)-1][0], locs[len(locs)-1][1]\n\n\t\tapp.ui.cmdAccLeft = slices.Concat(\n\t\t\t[]rune(string(app.ui.cmdAccLeft)[:beg1]),\n\t\t\t[]rune(string(app.ui.cmdAccLeft)[beg2:end2]),\n\t\t\t[]rune(string(app.ui.cmdAccLeft)[end1:beg2]),\n\t\t\t[]rune(string(app.ui.cmdAccLeft)[beg1:end1]),\n\t\t\t[]rune(string(app.ui.cmdAccLeft)[end2:]),\n\t\t)\n\t\tupdate(app)\n\tdefault:\n\t\tcmd, ok := gOpts.cmds[e.name]\n\t\tif !ok {\n\t\t\tapp.ui.echoerrf(\"command not found: %s\", e.name)\n\t\t\treturn\n\t\t}\n\t\tcmd.eval(app, e.args)\n\t}\n}\n\nfunc (e *execExpr) eval(app *app, args []string) {\n\tswitch e.prefix {\n\tcase \"$\":\n\t\tlog.Printf(\"shell: %s -- %s\", e, args)\n\t\tapp.runShell(e.value, args, e.prefix)\n\tcase \"%\":\n\t\tlog.Printf(\"shell-pipe: %s -- %s\", e, args)\n\t\tapp.runShell(e.value, args, e.prefix)\n\tcase \"!\":\n\t\tlog.Printf(\"shell-wait: %s -- %s\", e, args)\n\t\tapp.runShell(e.value, args, e.prefix)\n\tcase \"&\":\n\t\tlog.Printf(\"shell-async: %s -- %s\", e, args)\n\t\tapp.runShell(e.value, args, e.prefix)\n\tdefault:\n\t\tlog.Printf(\"evaluating unknown execution prefix: %q\", e.prefix)\n\t}\n}\n\nfunc (e *listExpr) eval(app *app, args []string) {\n\tfor i := 0; i < e.count; i++ {\n\t\tfor _, expr := range e.exprs {\n\t\t\texpr.eval(app, nil)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "eval_test.go",
          "type": "blob",
          "size": 15.9072265625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nvar gEvalTests = []struct {\n\tinp   string\n\ttoks  []string\n\texprs []expr\n}{\n\t{\n\t\t\"\",\n\t\t[]string{},\n\t\tnil,\n\t},\n\n\t{\n\t\t\"# comments start with '#'\",\n\t\t[]string{},\n\t\tnil,\n\t},\n\n\t{\n\t\t\"echo hello\",\n\t\t[]string{\"echo\", \"hello\", \"\\n\"},\n\t\t[]expr{&callExpr{\"echo\", []string{\"hello\"}, 1}},\n\t},\n\n\t{\n\t\t\"echo hello world\",\n\t\t[]string{\"echo\", \"hello\", \"world\", \"\\n\"},\n\t\t[]expr{&callExpr{\"echo\", []string{\"hello\", \"world\"}, 1}},\n\t},\n\n\t{\n\t\t\"echo 'hello world'\",\n\t\t[]string{\"echo\", \"hello world\", \"\\n\"},\n\t\t[]expr{&callExpr{\"echo\", []string{\"hello world\"}, 1}},\n\t},\n\n\t{\n\t\t`echo \"hello world\"`,\n\t\t[]string{\"echo\", \"hello world\", \"\\n\"},\n\t\t[]expr{&callExpr{\"echo\", []string{\"hello world\"}, 1}},\n\t},\n\n\t{\n\t\t`echo \"hello\\\"world\"`,\n\t\t[]string{\"echo\", `hello\"world`, \"\\n\"},\n\t\t[]expr{&callExpr{\"echo\", []string{`hello\"world`}, 1}},\n\t},\n\n\t{\n\t\t`echo \"hello\\tworld\"`,\n\t\t[]string{\"echo\", \"hello\\tworld\", \"\\n\"},\n\t\t[]expr{&callExpr{\"echo\", []string{\"hello\\tworld\"}, 1}},\n\t},\n\n\t{\n\t\t`echo \"hello\\nworld\"`,\n\t\t[]string{\"echo\", \"hello\\nworld\", \"\\n\"},\n\t\t[]expr{&callExpr{\"echo\", []string{\"hello\\nworld\"}, 1}},\n\t},\n\n\t{\n\t\t`echo \"hello\\zworld\"`,\n\t\t[]string{\"echo\", `hello\\zworld`, \"\\n\"},\n\t\t[]expr{&callExpr{\"echo\", []string{`hello\\zworld`}, 1}},\n\t},\n\n\t{\n\t\t`echo \"hello\\0world\"`,\n\t\t[]string{\"echo\", \"hello\\000world\", \"\\n\"},\n\t\t[]expr{&callExpr{\"echo\", []string{\"hello\\000world\"}, 1}},\n\t},\n\n\t{\n\t\t`echo \"hello\\101world\"`,\n\t\t[]string{\"echo\", \"hello\\101world\", \"\\n\"},\n\t\t[]expr{&callExpr{\"echo\", []string{\"hello\\101world\"}, 1}},\n\t},\n\n\t{\n\t\t`echo hello\\ world`,\n\t\t[]string{\"echo\", \"hello world\", \"\\n\"},\n\t\t[]expr{&callExpr{\"echo\", []string{\"hello world\"}, 1}},\n\t},\n\n\t{\n\t\t\"echo hello\\\\\\tworld\",\n\t\t[]string{\"echo\", \"hello\\tworld\", \"\\n\"},\n\t\t[]expr{&callExpr{\"echo\", []string{\"hello\\tworld\"}, 1}},\n\t},\n\n\t{\n\t\t\"echo hello\\\\\\nworld\",\n\t\t[]string{\"echo\", \"hello\\nworld\", \"\\n\"},\n\t\t[]expr{&callExpr{\"echo\", []string{\"hello\\nworld\"}, 1}},\n\t},\n\n\t{\n\t\t`echo hello\\\\world`,\n\t\t[]string{\"echo\", `hello\\world`, \"\\n\"},\n\t\t[]expr{&callExpr{\"echo\", []string{`hello\\world`}, 1}},\n\t},\n\n\t{\n\t\t`echo hello\\zworld`,\n\t\t[]string{\"echo\", \"hellozworld\", \"\\n\"},\n\t\t[]expr{&callExpr{\"echo\", []string{\"hellozworld\"}, 1}},\n\t},\n\n\t{\n\t\t\"set hidden # trailing comments are allowed\",\n\t\t[]string{\"set\", \"hidden\", \"\\n\"},\n\t\t[]expr{&setExpr{\"hidden\", \"\"}},\n\t},\n\n\t{\n\t\t\"set hidden; set preview\",\n\t\t[]string{\"set\", \"hidden\", \";\", \"set\", \"preview\", \"\\n\"},\n\t\t[]expr{&setExpr{\"hidden\", \"\"}, &setExpr{\"preview\", \"\"}},\n\t},\n\n\t{\n\t\t\"set hidden\\nset preview\",\n\t\t[]string{\"set\", \"hidden\", \"\\n\", \"set\", \"preview\", \"\\n\"},\n\t\t[]expr{&setExpr{\"hidden\", \"\"}, &setExpr{\"preview\", \"\"}},\n\t},\n\n\t{\n\t\t`set ifs \"\"`,\n\t\t[]string{\"set\", \"ifs\", \"\", \"\\n\"},\n\t\t[]expr{&setExpr{\"ifs\", \"\"}},\n\t},\n\n\t{\n\t\t`set ifs \"\\n\"`,\n\t\t[]string{\"set\", \"ifs\", \"\\n\", \"\\n\"},\n\t\t[]expr{&setExpr{\"ifs\", \"\\n\"}},\n\t},\n\n\t{\n\t\t\"set ratios 1:2:3\",\n\t\t[]string{\"set\", \"ratios\", \"1:2:3\", \"\\n\"},\n\t\t[]expr{&setExpr{\"ratios\", \"1:2:3\"}},\n\t},\n\n\t{\n\t\t\"set ratios 1:2:3;\",\n\t\t[]string{\"set\", \"ratios\", \"1:2:3\", \";\"},\n\t\t[]expr{&setExpr{\"ratios\", \"1:2:3\"}},\n\t},\n\n\t{\n\t\t\":set ratios 1:2:3\",\n\t\t[]string{\":\", \"set\", \"ratios\", \"1:2:3\", \"\\n\", \"\\n\"},\n\t\t[]expr{&listExpr{[]expr{&setExpr{\"ratios\", \"1:2:3\"}}, 1}},\n\t},\n\n\t{\n\t\t\":set ratios 1:2:3\\nset hidden\",\n\t\t[]string{\":\", \"set\", \"ratios\", \"1:2:3\", \"\\n\", \"\\n\", \"set\", \"hidden\", \"\\n\"},\n\t\t[]expr{&listExpr{[]expr{&setExpr{\"ratios\", \"1:2:3\"}}, 1}, &setExpr{\"hidden\", \"\"}},\n\t},\n\n\t{\n\t\t\":set ratios 1:2:3;\",\n\t\t[]string{\":\", \"set\", \"ratios\", \"1:2:3\", \";\", \"\\n\"},\n\t\t[]expr{&listExpr{[]expr{&setExpr{\"ratios\", \"1:2:3\"}}, 1}},\n\t},\n\n\t{\n\t\t\":set ratios 1:2:3;\\nset hidden\",\n\t\t[]string{\":\", \"set\", \"ratios\", \"1:2:3\", \";\", \"\\n\", \"set\", \"hidden\", \"\\n\"},\n\t\t[]expr{&listExpr{[]expr{&setExpr{\"ratios\", \"1:2:3\"}}, 1}, &setExpr{\"hidden\", \"\"}},\n\t},\n\n\t{\n\t\t\"set ratios 1:2:3\\n set hidden\",\n\t\t[]string{\"set\", \"ratios\", \"1:2:3\", \"\\n\", \"set\", \"hidden\", \"\\n\"},\n\t\t[]expr{&setExpr{\"ratios\", \"1:2:3\"}, &setExpr{\"hidden\", \"\"}},\n\t},\n\n\t{\n\t\t\"set ratios 1:2:3 \\nset hidden\",\n\t\t[]string{\"set\", \"ratios\", \"1:2:3\", \"\\n\", \"set\", \"hidden\", \"\\n\"},\n\t\t[]expr{&setExpr{\"ratios\", \"1:2:3\"}, &setExpr{\"hidden\", \"\"}},\n\t},\n\n\t{\n\t\t\"setlocal /foo/bar hidden # trailing comments are allowed\",\n\t\t[]string{\"setlocal\", \"/foo/bar\", \"hidden\", \"\\n\"},\n\t\t[]expr{&setLocalExpr{\"/foo/bar\", \"hidden\", \"\"}},\n\t},\n\n\t{\n\t\t\"setlocal /foo/bar hidden; setlocal /foo/bar reverse\",\n\t\t[]string{\"setlocal\", \"/foo/bar\", \"hidden\", \";\", \"setlocal\", \"/foo/bar\", \"reverse\", \"\\n\"},\n\t\t[]expr{&setLocalExpr{\"/foo/bar\", \"hidden\", \"\"}, &setLocalExpr{\"/foo/bar\", \"reverse\", \"\"}},\n\t},\n\n\t{\n\t\t\"setlocal /foo/bar hidden\\nsetlocal /foo/bar reverse\",\n\t\t[]string{\"setlocal\", \"/foo/bar\", \"hidden\", \"\\n\", \"setlocal\", \"/foo/bar\", \"reverse\", \"\\n\"},\n\t\t[]expr{&setLocalExpr{\"/foo/bar\", \"hidden\", \"\"}, &setLocalExpr{\"/foo/bar\", \"reverse\", \"\"}},\n\t},\n\n\t{\n\t\t`setlocal /foo/bar info \"\"`,\n\t\t[]string{\"setlocal\", \"/foo/bar\", \"info\", \"\", \"\\n\"},\n\t\t[]expr{&setLocalExpr{\"/foo/bar\", \"info\", \"\"}},\n\t},\n\n\t{\n\t\t`setlocal /foo/bar info \"size\"`,\n\t\t[]string{\"setlocal\", \"/foo/bar\", \"info\", \"size\", \"\\n\"},\n\t\t[]expr{&setLocalExpr{\"/foo/bar\", \"info\", \"size\"}},\n\t},\n\n\t{\n\t\t\"setlocal /foo/bar info size:time\",\n\t\t[]string{\"setlocal\", \"/foo/bar\", \"info\", \"size:time\", \"\\n\"},\n\t\t[]expr{&setLocalExpr{\"/foo/bar\", \"info\", \"size:time\"}},\n\t},\n\n\t{\n\t\t\"setlocal /foo/bar info size:time;\",\n\t\t[]string{\"setlocal\", \"/foo/bar\", \"info\", \"size:time\", \";\"},\n\t\t[]expr{&setLocalExpr{\"/foo/bar\", \"info\", \"size:time\"}},\n\t},\n\n\t{\n\t\t\":setlocal /foo/bar info size:time\",\n\t\t[]string{\":\", \"setlocal\", \"/foo/bar\", \"info\", \"size:time\", \"\\n\", \"\\n\"},\n\t\t[]expr{&listExpr{[]expr{&setLocalExpr{\"/foo/bar\", \"info\", \"size:time\"}}, 1}},\n\t},\n\n\t{\n\t\t\":setlocal /foo/bar info size:time\\nsetlocal /foo/bar hidden\",\n\t\t[]string{\":\", \"setlocal\", \"/foo/bar\", \"info\", \"size:time\", \"\\n\", \"\\n\", \"setlocal\", \"/foo/bar\", \"hidden\", \"\\n\"},\n\t\t[]expr{&listExpr{[]expr{&setLocalExpr{\"/foo/bar\", \"info\", \"size:time\"}}, 1}, &setLocalExpr{\"/foo/bar\", \"hidden\", \"\"}},\n\t},\n\n\t{\n\t\t\":setlocal /foo/bar info size:time;\",\n\t\t[]string{\":\", \"setlocal\", \"/foo/bar\", \"info\", \"size:time\", \";\", \"\\n\"},\n\t\t[]expr{&listExpr{[]expr{&setLocalExpr{\"/foo/bar\", \"info\", \"size:time\"}}, 1}},\n\t},\n\n\t{\n\t\t\":setlocal /foo/bar info size:time;\\nsetlocal /foo/bar hidden\",\n\t\t[]string{\":\", \"setlocal\", \"/foo/bar\", \"info\", \"size:time\", \";\", \"\\n\", \"setlocal\", \"/foo/bar\", \"hidden\", \"\\n\"},\n\t\t[]expr{&listExpr{[]expr{&setLocalExpr{\"/foo/bar\", \"info\", \"size:time\"}}, 1}, &setLocalExpr{\"/foo/bar\", \"hidden\", \"\"}},\n\t},\n\n\t{\n\t\t\"setlocal /foo/bar info size:time\\n setlocal /foo/bar hidden\",\n\t\t[]string{\"setlocal\", \"/foo/bar\", \"info\", \"size:time\", \"\\n\", \"setlocal\", \"/foo/bar\", \"hidden\", \"\\n\"},\n\t\t[]expr{&setLocalExpr{\"/foo/bar\", \"info\", \"size:time\"}, &setLocalExpr{\"/foo/bar\", \"hidden\", \"\"}},\n\t},\n\n\t{\n\t\t\"setlocal /foo/bar info size:time \\nsetlocal /foo/bar hidden\",\n\t\t[]string{\"setlocal\", \"/foo/bar\", \"info\", \"size:time\", \"\\n\", \"setlocal\", \"/foo/bar\", \"hidden\", \"\\n\"},\n\t\t[]expr{&setLocalExpr{\"/foo/bar\", \"info\", \"size:time\"}, &setLocalExpr{\"/foo/bar\", \"hidden\", \"\"}},\n\t},\n\n\t{\n\t\t\"map gh cd ~\",\n\t\t[]string{\"map\", \"gh\", \"cd\", \"~\", \"\\n\"},\n\t\t[]expr{&mapExpr{\"gh\", &callExpr{\"cd\", []string{\"~\"}, 1}}},\n\t},\n\n\t{\n\t\t\"map gh cd ~;\",\n\t\t[]string{\"map\", \"gh\", \"cd\", \"~\", \";\"},\n\t\t[]expr{&mapExpr{\"gh\", &callExpr{\"cd\", []string{\"~\"}, 1}}},\n\t},\n\n\t{\n\t\t\"map gh :cd ~\",\n\t\t[]string{\"map\", \"gh\", \":\", \"cd\", \"~\", \"\\n\", \"\\n\"},\n\t\t[]expr{&mapExpr{\"gh\", &listExpr{[]expr{&callExpr{\"cd\", []string{\"~\"}, 1}}, 1}}},\n\t},\n\n\t{\n\t\t\"map gh :cd ~;\",\n\t\t[]string{\"map\", \"gh\", \":\", \"cd\", \"~\", \";\", \"\\n\"},\n\t\t[]expr{&mapExpr{\"gh\", &listExpr{[]expr{&callExpr{\"cd\", []string{\"~\"}, 1}}, 1}}},\n\t},\n\n\t{\n\t\t\"cmap <c-g> cmd-escape\",\n\t\t[]string{\"cmap\", \"<c-g>\", \"cmd-escape\", \"\\n\"},\n\t\t[]expr{&cmapExpr{\"<c-g>\", &callExpr{\"cmd-escape\", nil, 1}}},\n\t},\n\n\t{\n\t\t\"cmd usage $du -h . | less\",\n\t\t[]string{\"cmd\", \"usage\", \"$\", \"du -h . | less\", \"\\n\"},\n\t\t[]expr{&cmdExpr{\"usage\", &execExpr{\"$\", \"du -h . | less\"}}},\n\t},\n\n\t{\n\t\t\"cmd 世界 $echo 世界\",\n\t\t[]string{\"cmd\", \"世界\", \"$\", \"echo 世界\", \"\\n\"},\n\t\t[]expr{&cmdExpr{\"世界\", &execExpr{\"$\", \"echo 世界\"}}},\n\t},\n\n\t{\n\t\t\"map u usage\",\n\t\t[]string{\"map\", \"u\", \"usage\", \"\\n\"},\n\t\t[]expr{&mapExpr{\"u\", &callExpr{\"usage\", nil, 1}}},\n\t},\n\n\t{\n\t\t\"map u usage;\",\n\t\t[]string{\"map\", \"u\", \"usage\", \";\"},\n\t\t[]expr{&mapExpr{\"u\", &callExpr{\"usage\", nil, 1}}},\n\t},\n\n\t{\n\t\t\"map u :usage\",\n\t\t[]string{\"map\", \"u\", \":\", \"usage\", \"\\n\", \"\\n\"},\n\t\t[]expr{&mapExpr{\"u\", &listExpr{[]expr{&callExpr{\"usage\", nil, 1}}, 1}}},\n\t},\n\n\t{\n\t\t\"map u :usage;\",\n\t\t[]string{\"map\", \"u\", \":\", \"usage\", \";\", \"\\n\"},\n\t\t[]expr{&mapExpr{\"u\", &listExpr{[]expr{&callExpr{\"usage\", nil, 1}}, 1}}},\n\t},\n\n\t{\n\t\t\"map r push :rename<space>\",\n\t\t[]string{\"map\", \"r\", \"push\", \":rename<space>\", \"\\n\"},\n\t\t[]expr{&mapExpr{\"r\", &callExpr{\"push\", []string{\":rename<space>\"}, 1}}},\n\t},\n\n\t{\n\t\t\"map r push :rename<space>;\",\n\t\t[]string{\"map\", \"r\", \"push\", \":rename<space>;\", \"\\n\"},\n\t\t[]expr{&mapExpr{\"r\", &callExpr{\"push\", []string{\":rename<space>;\"}, 1}}},\n\t},\n\n\t{\n\t\t\"map r push :rename<space> # trailing comments are allowed after a space\",\n\t\t[]string{\"map\", \"r\", \"push\", \":rename<space>\", \"\\n\"},\n\t\t[]expr{&mapExpr{\"r\", &callExpr{\"push\", []string{\":rename<space>\"}, 1}}},\n\t},\n\n\t{\n\t\t\"map r :push :rename<space>\",\n\t\t[]string{\"map\", \"r\", \":\", \"push\", \":rename<space>\", \"\\n\", \"\\n\"},\n\t\t[]expr{&mapExpr{\"r\", &listExpr{[]expr{&callExpr{\"push\", []string{\":rename<space>\"}, 1}}, 1}}},\n\t},\n\n\t{\n\t\t\"map r :push :rename<space> ; set hidden\",\n\t\t[]string{\"map\", \"r\", \":\", \"push\", \":rename<space>\", \";\", \"set\", \"hidden\", \"\\n\", \"\\n\"},\n\t\t[]expr{&mapExpr{\"r\", &listExpr{[]expr{&callExpr{\"push\", []string{\":rename<space>\"}, 1}, &setExpr{\"hidden\", \"\"}}, 1}}},\n\t},\n\n\t{\n\t\t\"map u $du -h . | less\",\n\t\t[]string{\"map\", \"u\", \"$\", \"du -h . | less\", \"\\n\"},\n\t\t[]expr{&mapExpr{\"u\", &execExpr{\"$\", \"du -h . | less\"}}},\n\t},\n\n\t{\n\t\t\"cmd usage $du -h $1 | less\",\n\t\t[]string{\"cmd\", \"usage\", \"$\", \"du -h $1 | less\", \"\\n\"},\n\t\t[]expr{&cmdExpr{\"usage\", &execExpr{\"$\", \"du -h $1 | less\"}}},\n\t},\n\n\t{\n\t\t\"map u usage /\",\n\t\t[]string{\"map\", \"u\", \"usage\", \"/\", \"\\n\"},\n\t\t[]expr{&mapExpr{\"u\", &callExpr{\"usage\", []string{\"/\"}, 1}}},\n\t},\n\n\t{\n\t\t\"map ss :set sortby size; set info size\",\n\t\t[]string{\"map\", \"ss\", \":\", \"set\", \"sortby\", \"size\", \";\", \"set\", \"info\", \"size\", \"\\n\", \"\\n\"},\n\t\t[]expr{&mapExpr{\"ss\", &listExpr{[]expr{&setExpr{\"sortby\", \"size\"}, &setExpr{\"info\", \"size\"}}, 1}}},\n\t},\n\n\t{\n\t\t\"map ss :set sortby size; set info size;\",\n\t\t[]string{\"map\", \"ss\", \":\", \"set\", \"sortby\", \"size\", \";\", \"set\", \"info\", \"size\", \";\", \"\\n\"},\n\t\t[]expr{&mapExpr{\"ss\", &listExpr{[]expr{&setExpr{\"sortby\", \"size\"}, &setExpr{\"info\", \"size\"}}, 1}}},\n\t},\n\n\t{\n\t\t`cmd gohome :{{\n\t\t\tcd ~\n\t\t\tset hidden\n\t\t}}`,\n\t\t[]string{\n\t\t\t\"cmd\", \"gohome\", \":\", \"{{\",\n\t\t\t\"cd\", \"~\", \"\\n\",\n\t\t\t\"set\", \"hidden\", \"\\n\",\n\t\t\t\"}}\", \"\\n\",\n\t\t},\n\t\t[]expr{&cmdExpr{\n\t\t\t\"gohome\", &listExpr{[]expr{\n\t\t\t\t&callExpr{\"cd\", []string{\"~\"}, 1},\n\t\t\t\t&setExpr{\"hidden\", \"\"},\n\t\t\t}, 1},\n\t\t}},\n\t},\n\n\t{\n\t\t`map gh :{{\n\t\t\tcd ~\n\t\t\tset hidden\n\t\t}}`,\n\t\t[]string{\n\t\t\t\"map\", \"gh\", \":\", \"{{\",\n\t\t\t\"cd\", \"~\", \"\\n\",\n\t\t\t\"set\", \"hidden\", \"\\n\",\n\t\t\t\"}}\", \"\\n\",\n\t\t},\n\t\t[]expr{&mapExpr{\n\t\t\t\"gh\", &listExpr{[]expr{\n\t\t\t\t&callExpr{\"cd\", []string{\"~\"}, 1},\n\t\t\t\t&setExpr{\"hidden\", \"\"},\n\t\t\t}, 1},\n\t\t}},\n\t},\n\n\t{\n\t\t`map c ${{\n\t\t\tmkdir foo\n\t\t\tcp $fs foo\n\t\t\ttar -czvf foo.tar.gz foo\n\t\t\trm -rf foo\n\t\t}}`,\n\t\t[]string{\"map\", \"c\", \"$\", \"{{\", `\n\t\t\tmkdir foo\n\t\t\tcp $fs foo\n\t\t\ttar -czvf foo.tar.gz foo\n\t\t\trm -rf foo\n\t\t`, \"}}\", \"\\n\"},\n\t\t[]expr{&mapExpr{\"c\", &execExpr{\"$\", `\n\t\t\tmkdir foo\n\t\t\tcp $fs foo\n\t\t\ttar -czvf foo.tar.gz foo\n\t\t\trm -rf foo\n\t\t`}}},\n\t},\n\n\t{\n\t\t`cmd compress ${{\n\t\t\tmkdir $1\n\t\t\tcp $fs $1\n\t\t\ttar -czvf $1.tar.gz $1\n\t\t\trm -rf $1\n\t\t}}`,\n\t\t[]string{\"cmd\", \"compress\", \"$\", \"{{\", `\n\t\t\tmkdir $1\n\t\t\tcp $fs $1\n\t\t\ttar -czvf $1.tar.gz $1\n\t\t\trm -rf $1\n\t\t`, \"}}\", \"\\n\"},\n\t\t[]expr{&cmdExpr{\"compress\", &execExpr{\"$\", `\n\t\t\tmkdir $1\n\t\t\tcp $fs $1\n\t\t\ttar -czvf $1.tar.gz $1\n\t\t\trm -rf $1\n\t\t`}}},\n\t},\n}\n\nfunc TestScan(t *testing.T) {\n\tfor _, test := range gEvalTests {\n\t\ts := newScanner(strings.NewReader(test.inp))\n\n\t\tfor _, tok := range test.toks {\n\t\t\tif s.scan(); s.tok != tok {\n\t\t\t\tt.Errorf(\"at input '%s' expected '%s' but scanned '%s'\", test.inp, tok, s.tok)\n\t\t\t}\n\t\t}\n\n\t\tif s.scan() {\n\t\t\tt.Errorf(\"at input '%s' unexpected '%s'\", test.inp, s.tok)\n\t\t}\n\t}\n}\n\nfunc TestParse(t *testing.T) {\n\tfor _, test := range gEvalTests {\n\t\tp := newParser(strings.NewReader(test.inp))\n\n\t\tfor _, expr := range test.exprs {\n\t\t\tif p.parse(); !reflect.DeepEqual(p.expr, expr) {\n\t\t\t\tt.Errorf(\"at input '%s' expected '%s' but parsed '%s'\", test.inp, expr, p.expr)\n\t\t\t}\n\t\t}\n\n\t\tif p.parse(); p.expr != nil {\n\t\t\tt.Errorf(\"at input '%s' unexpected '%s'\", test.inp, p.expr)\n\t\t}\n\t}\n}\n\nfunc TestSplitKeys(t *testing.T) {\n\tinps := []struct {\n\t\ts    string\n\t\tkeys []string\n\t}{\n\t\t{\"\", nil},\n\t\t{\"j\", []string{\"j\"}},\n\t\t{\"jk\", []string{\"j\", \"k\"}},\n\t\t{\"1j\", []string{\"1\", \"j\"}},\n\t\t{\"42j\", []string{\"4\", \"2\", \"j\"}},\n\t\t{\"<space>\", []string{\"<space>\"}},\n\t\t{\"j<space>\", []string{\"j\", \"<space>\"}},\n\t\t{\"j<space>k\", []string{\"j\", \"<space>\", \"k\"}},\n\t\t{\"1j<space>k\", []string{\"1\", \"j\", \"<space>\", \"k\"}},\n\t\t{\"1j<space>1k\", []string{\"1\", \"j\", \"<space>\", \"1\", \"k\"}},\n\t\t{\"<>\", []string{\"<>\"}},\n\t\t{\"<space\", []string{\"<space\"}},\n\t\t{\"<space<\", []string{\"<space<\"}},\n\t\t{\"<space<>\", []string{\"<space<>\"}},\n\t\t{\"><space>\", []string{\">\", \"<space>\"}},\n\t\t{\"><space>>\", []string{\">\", \"<space>\", \">\"}},\n\t}\n\n\tfor _, inp := range inps {\n\t\tif keys := splitKeys(inp.s); !reflect.DeepEqual(keys, inp.keys) {\n\t\t\tt.Errorf(\"at input '%s' expected '%v' but got '%v'\", inp.s, inp.keys, keys)\n\t\t}\n\t}\n}\n\nfunc TestApplyBoolOpt(t *testing.T) {\n\ttests := []struct {\n\t\topt bool\n\t\te   setExpr\n\t\texp bool\n\t}{\n\t\t{true, setExpr{\"feature\", \"\"}, true},\n\t\t{true, setExpr{\"feature\", \"true\"}, true},\n\t\t{true, setExpr{\"feature\", \"false\"}, false},\n\t\t{false, setExpr{\"feature\", \"\"}, true},\n\t\t{false, setExpr{\"feature\", \"true\"}, true},\n\t\t{false, setExpr{\"feature\", \"false\"}, false},\n\t\t{true, setExpr{\"nofeature\", \"\"}, false},\n\t\t{false, setExpr{\"nofeature\", \"\"}, false},\n\t\t{true, setExpr{\"feature!\", \"\"}, false},\n\t\t{false, setExpr{\"feature!\", \"\"}, true},\n\t}\n\n\tfor _, test := range tests {\n\t\ttestStr := fmt.Sprintf(\"%v\", test)\n\t\tif err := applyBoolOpt(&test.opt, &test.e); err != nil {\n\t\t\tt.Errorf(\"at test '%s' expected '%t' but got an error '%s'\", testStr, test.exp, err)\n\t\t\tcontinue\n\t\t}\n\t\tif test.opt != test.exp {\n\t\t\tt.Errorf(\"at test '%s' expected '%t' but got '%t'\", testStr, test.exp, test.opt)\n\t\t}\n\t}\n}\n\nfunc TestApplyLocalBoolOpt(t *testing.T) {\n\ttests := []struct {\n\t\tlocalOpt  map[string]bool\n\t\tglobalOpt bool\n\t\te         setLocalExpr\n\t\texp       bool\n\t}{\n\t\t{map[string]bool{}, false, setLocalExpr{\"/\", \"feature\", \"\"}, true},\n\t\t{map[string]bool{}, false, setLocalExpr{\"/\", \"feature\", \"true\"}, true},\n\t\t{map[string]bool{}, false, setLocalExpr{\"/\", \"feature\", \"false\"}, false},\n\t\t{map[string]bool{}, false, setLocalExpr{\"/\", \"nofeature\", \"\"}, false},\n\t\t{map[string]bool{}, true, setLocalExpr{\"/\", \"feature!\", \"\"}, false},\n\t\t{map[string]bool{}, false, setLocalExpr{\"/\", \"feature!\", \"\"}, true},\n\t\t{map[string]bool{\"/\": true}, false, setLocalExpr{\"/\", \"feature\", \"\"}, true},\n\t\t{map[string]bool{\"/\": true}, false, setLocalExpr{\"/\", \"feature\", \"true\"}, true},\n\t\t{map[string]bool{\"/\": true}, false, setLocalExpr{\"/\", \"feature\", \"false\"}, false},\n\t\t{map[string]bool{\"/\": true}, false, setLocalExpr{\"/\", \"nofeature\", \"\"}, false},\n\t\t{map[string]bool{\"/\": true}, true, setLocalExpr{\"/\", \"feature!\", \"\"}, false},\n\t\t{map[string]bool{\"/\": true}, false, setLocalExpr{\"/\", \"feature!\", \"\"}, false},\n\t\t{map[string]bool{\"/\": false}, false, setLocalExpr{\"/\", \"feature\", \"\"}, true},\n\t\t{map[string]bool{\"/\": false}, false, setLocalExpr{\"/\", \"feature\", \"true\"}, true},\n\t\t{map[string]bool{\"/\": false}, false, setLocalExpr{\"/\", \"feature\", \"false\"}, false},\n\t\t{map[string]bool{\"/\": false}, false, setLocalExpr{\"/\", \"nofeature\", \"\"}, false},\n\t\t{map[string]bool{\"/\": false}, true, setLocalExpr{\"/\", \"feature!\", \"\"}, true},\n\t\t{map[string]bool{\"/\": false}, false, setLocalExpr{\"/\", \"feature!\", \"\"}, true},\n\t}\n\n\tfor _, test := range tests {\n\t\ttestStr := fmt.Sprintf(\"%v\", test)\n\t\tif err := applyLocalBoolOpt(test.localOpt, test.globalOpt, &test.e); err != nil {\n\t\t\tt.Errorf(\"at test '%s' expected '%t' but got an error '%s'\", testStr, test.exp, err)\n\t\t\tcontinue\n\t\t}\n\t\tresult := test.localOpt[test.e.path]\n\t\tif result != test.exp {\n\t\t\tt.Errorf(\"at test '%s' expected '%t' but got '%t'\", testStr, test.exp, result)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "gen",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.4619140625,
          "content": "module github.com/gokcehan/lf\n\ngo 1.23\n\nrequire (\n\tgithub.com/Xuanwo/go-locale v1.1.2\n\tgithub.com/djherbis/times v1.6.0\n\tgithub.com/fsnotify/fsnotify v1.7.0\n\tgithub.com/gdamore/tcell/v2 v2.7.4\n\tgithub.com/mattn/go-runewidth v0.0.16\n\tgolang.org/x/sys v0.28.0\n\tgolang.org/x/term v0.27.0\n\tgolang.org/x/text v0.21.0\n)\n\nrequire (\n\tgithub.com/gdamore/encoding v1.0.0 // indirect\n\tgithub.com/lucasb-eyer/go-colorful v1.2.0 // indirect\n\tgithub.com/rivo/uniseg v0.4.3 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 5.17578125,
          "content": "github.com/Xuanwo/go-locale v1.1.2 h1:6H+olvrQcyVOZ+GAC2rXu4armacTT4ZrFCA0mB24XVo=\ngithub.com/Xuanwo/go-locale v1.1.2/go.mod h1:1JBER4QV7Ji39GJ4AvVlfvqmTUqopzxQxdg2mXYOw94=\ngithub.com/djherbis/times v1.6.0 h1:w2ctJ92J8fBvWPxugmXIv7Nz7Q3iDMKNx9v5ocVH20c=\ngithub.com/djherbis/times v1.6.0/go.mod h1:gOHeRAz2h+VJNZ5Gmc/o7iD9k4wW7NMVqieYCY99oc0=\ngithub.com/fsnotify/fsnotify v1.7.0 h1:8JEhPFa5W2WU7YfeZzPNqzMP6Lwt7L2715Ggo0nosvA=\ngithub.com/fsnotify/fsnotify v1.7.0/go.mod h1:40Bi/Hjc2AVfZrqy+aj+yEI+/bRxZnMJyTJwOpGvigM=\ngithub.com/gdamore/encoding v1.0.0 h1:+7OoQ1Bc6eTm5niUzBa0Ctsh6JbMW6Ra+YNuAtDBdko=\ngithub.com/gdamore/encoding v1.0.0/go.mod h1:alR0ol34c49FCSBLjhosxzcPHQbf2trDkoo5dl+VrEg=\ngithub.com/gdamore/tcell/v2 v2.7.4 h1:sg6/UnTM9jGpZU+oFYAsDahfchWAFW8Xx2yFinNSAYU=\ngithub.com/gdamore/tcell/v2 v2.7.4/go.mod h1:dSXtXTSK0VsW1biw65DZLZ2NKr7j0qP/0J7ONmsraWg=\ngithub.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=\ngithub.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=\ngithub.com/mattn/go-runewidth v0.0.15/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=\ngithub.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.3 h1:utMvzDsuh3suAEnhH0RdHmoPbU648o6CvXxTx4SBMOw=\ngithub.com/rivo/uniseg v0.4.3/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220615213510-4f61da869c0c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=\ngolang.org/x/term v0.27.0 h1:WP60Sv1nlK1T6SupCHbXzSaN0b9wUmsPoRS9b61A23Q=\ngolang.org/x/term v0.27.0/go.mod h1:iMsnZpn0cago0GOrHO2+Y7u7JPn5AylBrcoWkElMTSM=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n"
        },
        {
          "name": "icons.go",
          "type": "blob",
          "size": 3.3037109375,
          "content": "package main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/gdamore/tcell/v2\"\n)\n\ntype iconDef struct {\n\ticon     string\n\thasStyle bool\n\tstyle    tcell.Style\n}\n\ntype iconMap struct {\n\ticons         map[string]iconDef\n\tuseLinkTarget bool\n}\n\nfunc iconWithoutStyle(icon string) iconDef {\n\treturn iconDef{icon, false, tcell.StyleDefault}\n}\n\nfunc iconWithStyle(icon string, style tcell.Style) iconDef {\n\treturn iconDef{icon, true, style}\n}\n\nfunc parseIcons() iconMap {\n\tim := iconMap{\n\t\ticons:         make(map[string]iconDef),\n\t\tuseLinkTarget: false,\n\t}\n\n\tdefaultIcons := []string{\n\t\t\"ln=l\",\n\t\t\"or=l\",\n\t\t\"tw=t\",\n\t\t\"ow=d\",\n\t\t\"st=t\",\n\t\t\"di=d\",\n\t\t\"pi=p\",\n\t\t\"so=s\",\n\t\t\"bd=b\",\n\t\t\"cd=c\",\n\t\t\"su=u\",\n\t\t\"sg=g\",\n\t\t\"ex=x\",\n\t\t\"fi=-\",\n\t}\n\n\tim.parseEnv(strings.Join(defaultIcons, \":\"))\n\n\tif env := os.Getenv(\"LF_ICONS\"); env != \"\" {\n\t\tim.parseEnv(env)\n\t}\n\n\tfor _, path := range gIconsPaths {\n\t\tif _, err := os.Stat(path); !os.IsNotExist(err) {\n\t\t\tim.parseFile(path)\n\t\t}\n\t}\n\n\treturn im\n}\n\nfunc (im *iconMap) parseFile(path string) {\n\tlog.Printf(\"reading file: %s\", path)\n\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\tlog.Printf(\"opening icons file: %s\", err)\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\tarrs, err := readArrays(f, 1, 3)\n\tif err != nil {\n\t\tlog.Printf(\"reading icons file: %s\", err)\n\t\treturn\n\t}\n\n\tfor _, arr := range arrs {\n\t\tim.parseArray(arr)\n\t}\n}\n\nfunc (im *iconMap) parseEnv(env string) {\n\tfor _, entry := range strings.Split(env, \":\") {\n\t\tif entry == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tpair := strings.Split(entry, \"=\")\n\n\t\tif len(pair) != 2 {\n\t\t\tlog.Printf(\"invalid $LF_ICONS entry: %s\", entry)\n\t\t\treturn\n\t\t}\n\n\t\tim.parseArray(pair)\n\t}\n}\n\nfunc (im *iconMap) parseArray(arr []string) {\n\tkey := replaceTilde(arr[0])\n\n\tif filepath.IsAbs(key) {\n\t\tkey = filepath.Clean(key)\n\t}\n\n\tswitch len(arr) {\n\tcase 1:\n\t\tdelete(im.icons, key)\n\tcase 2:\n\t\ticon := arr[1]\n\t\tif key == \"ln\" && icon == \"target\" {\n\t\t\tim.useLinkTarget = true\n\t\t} else {\n\t\t\tim.icons[key] = iconWithoutStyle(icon)\n\t\t}\n\tcase 3:\n\t\ticon, color := arr[1], arr[2]\n\t\tim.icons[key] = iconWithStyle(icon, applyAnsiCodes(color, tcell.StyleDefault))\n\t}\n}\n\nfunc (im iconMap) get(f *file) iconDef {\n\tif val, ok := im.icons[f.path]; ok {\n\t\treturn val\n\t}\n\n\tif f.IsDir() {\n\t\tif val, ok := im.icons[f.Name()+\"/\"]; ok {\n\t\t\treturn val\n\t\t}\n\t}\n\n\tvar key string\n\n\tswitch {\n\tcase f.linkState == working && !im.useLinkTarget:\n\t\tkey = \"ln\"\n\tcase f.linkState == broken:\n\t\tkey = \"or\"\n\tcase f.IsDir() && f.Mode()&os.ModeSticky != 0 && f.Mode()&0o002 != 0:\n\t\tkey = \"tw\"\n\tcase f.IsDir() && f.Mode()&0o002 != 0:\n\t\tkey = \"ow\"\n\tcase f.IsDir() && f.Mode()&os.ModeSticky != 0:\n\t\tkey = \"st\"\n\tcase f.IsDir():\n\t\tkey = \"di\"\n\tcase f.Mode()&os.ModeNamedPipe != 0:\n\t\tkey = \"pi\"\n\tcase f.Mode()&os.ModeSocket != 0:\n\t\tkey = \"so\"\n\tcase f.Mode()&os.ModeCharDevice != 0:\n\t\tkey = \"cd\"\n\tcase f.Mode()&os.ModeDevice != 0:\n\t\tkey = \"bd\"\n\tcase f.Mode()&os.ModeSetuid != 0:\n\t\tkey = \"su\"\n\tcase f.Mode()&os.ModeSetgid != 0:\n\t\tkey = \"sg\"\n\tcase f.Mode()&0o111 != 0:\n\t\tkey = \"ex\"\n\t}\n\n\tif val, ok := im.icons[key]; ok {\n\t\treturn val\n\t}\n\n\tif val, ok := im.icons[f.Name()+\"*\"]; ok {\n\t\treturn val\n\t}\n\n\tif val, ok := im.icons[\"*\"+f.Name()]; ok {\n\t\treturn val\n\t}\n\n\tif val, ok := im.icons[filepath.Base(f.Name())+\".*\"]; ok {\n\t\treturn val\n\t}\n\n\tif val, ok := im.icons[\"*\"+strings.ToLower(f.ext)]; ok {\n\t\treturn val\n\t}\n\n\tif val, ok := im.icons[\"fi\"]; ok {\n\t\treturn val\n\t}\n\n\treturn iconWithoutStyle(\" \")\n}\n"
        },
        {
          "name": "lf.1",
          "type": "blob",
          "size": 80.6044921875,
          "content": ".\\\" Automatically generated by Pandoc 2.11.4\n.\\\"\n.TH \"LF\" \"1\" \"2024-11-06\" \"\" \"DOCUMENTATION\"\n.hy\n.SH NAME\n.PP\nlf - terminal file manager\n.SH SYNOPSIS\n.PP\n\\f[B]lf\\f[R] [\\f[B]-command\\f[R] \\f[I]command\\f[R]] [\\f[B]-config\\f[R]\n\\f[I]path\\f[R]] [\\f[B]-cpuprofile\\f[R] \\f[I]path\\f[R]] [\\f[B]-doc\\f[R]]\n[\\f[B]-last-dir-path\\f[R] \\f[I]path\\f[R]] [\\f[B]-log path\\f[R]]\n[\\f[B]-memprofile\\f[R] \\f[I]path\\f[R]] [\\f[B]-print-last-dir\\f[R]]\n[\\f[B]-print-selection\\f[R]] [\\f[B]-remote\\f[R] \\f[I]command\\f[R]]\n[\\f[B]-selection-path\\f[R] \\f[I]path\\f[R]] [\\f[B]-server\\f[R]]\n[\\f[B]-single\\f[R]] [\\f[B]-version\\f[R]] [\\f[B]-help\\f[R]]\n[\\f[I]cd-or-select-path\\f[R]]\n.SH DESCRIPTION\n.PP\nlf is a terminal file manager.\n.PP\nThe source code can be found in the repository at\n<https://github.com/gokcehan/lf>\n.PP\nThis documentation can either be read from the terminal using\n\\f[C]lf -doc\\f[R] or online at\n<https://github.com/gokcehan/lf/blob/master/doc.md> You can also use the\n\\f[C]doc\\f[R] command (default \\f[C]<f-1>\\f[R]) inside lf to view the\ndocumentation in a pager.\nA man page with the same content is also available in the repository at\n<https://github.com/gokcehan/lf/blob/master/lf.1>\n.PP\nYou can run \\f[C]lf -help\\f[R] to see descriptions of command line\noptions.\n.SH QUICK REFERENCE\n.PP\nThe following commands are provided by lf:\n.IP\n.nf\n\\f[C]\nquit                     (default \\[aq]q\\[aq])\nup                       (default \\[aq]k\\[aq] and \\[aq]<up>\\[aq])\nhalf-up                  (default \\[aq]<c-u>\\[aq])\npage-up                  (default \\[aq]<c-b>\\[aq] and \\[aq]<pgup>\\[aq])\nscroll-up                (default \\[aq]<c-y>\\[aq])\ndown                     (default \\[aq]j\\[aq] and \\[aq]<down>\\[aq])\nhalf-down                (default \\[aq]<c-d>\\[aq])\npage-down                (default \\[aq]<c-f>\\[aq] and \\[aq]<pgdn>\\[aq])\nscroll-down              (default \\[aq]<c-e>\\[aq])\nupdir                    (default \\[aq]h\\[aq] and \\[aq]<left>\\[aq])\nopen                     (default \\[aq]l\\[aq] and \\[aq]<right>\\[aq])\njump-next                (default \\[aq]]\\[aq])\njump-prev                (default \\[aq][\\[aq])\ntop                      (default \\[aq]gg\\[aq] and \\[aq]<home>\\[aq])\nbottom                   (default \\[aq]G\\[aq] and \\[aq]<end>\\[aq])\nhigh                     (default \\[aq]H\\[aq])\nmiddle                   (default \\[aq]M\\[aq])\nlow                      (default \\[aq]L\\[aq])\ntoggle\ninvert                   (default \\[aq]v\\[aq])\ninvert-below\nunselect                 (default \\[aq]u\\[aq])\nglob-select\nglob-unselect\ncalcdirsize\nclearmaps\ncopy                     (default \\[aq]y\\[aq])\ncut                      (default \\[aq]d\\[aq])\npaste                    (default \\[aq]p\\[aq])\nclear                    (default \\[aq]c\\[aq])\nsync\ndraw\nredraw                   (default \\[aq]<c-l>\\[aq])\nload\nreload                   (default \\[aq]<c-r>\\[aq])\necho\nechomsg\nechoerr\ncd\nselect\ndelete         (modal)\nrename         (modal)   (default \\[aq]r\\[aq])\nsource\npush\nread           (modal)   (default \\[aq]:\\[aq])\nshell          (modal)   (default \\[aq]$\\[aq])\nshell-pipe     (modal)   (default \\[aq]%\\[aq])\nshell-wait     (modal)   (default \\[aq]!\\[aq])\nshell-async    (modal)   (default \\[aq]&\\[aq])\nfind           (modal)   (default \\[aq]f\\[aq])\nfind-back      (modal)   (default \\[aq]F\\[aq])\nfind-next                (default \\[aq];\\[aq])\nfind-prev                (default \\[aq],\\[aq])\nsearch         (modal)   (default \\[aq]/\\[aq])\nsearch-back    (modal)   (default \\[aq]?\\[aq])\nsearch-next              (default \\[aq]n\\[aq])\nsearch-prev              (default \\[aq]N\\[aq])\nfilter         (modal)\nsetfilter\nmark-save      (modal)   (default \\[aq]m\\[aq])\nmark-load      (modal)   (default \\[dq]\\[aq]\\[dq])\nmark-remove    (modal)   (default \\[aq]\\[dq]\\[aq])\ntag\ntag-toggle               (default \\[aq]t\\[aq])\n\\f[R]\n.fi\n.PP\nThe following command line commands are provided by lf:\n.IP\n.nf\n\\f[C]\ncmd-escape               (default \\[aq]<esc>\\[aq])\ncmd-complete             (default \\[aq]<tab>\\[aq])\ncmd-menu-complete\ncmd-menu-complete-back\ncmd-menu-accept\ncmd-enter                (default \\[aq]<c-j>\\[aq] and \\[aq]<enter>\\[aq])\ncmd-interrupt            (default \\[aq]<c-c>\\[aq])\ncmd-history-next         (default \\[aq]<c-n>\\[aq] and \\[aq]<down>\\[aq])\ncmd-history-prev         (default \\[aq]<c-p>\\[aq] and \\[aq]<up>\\[aq])\ncmd-left                 (default \\[aq]<c-b>\\[aq] and \\[aq]<left>\\[aq])\ncmd-right                (default \\[aq]<c-f>\\[aq] and \\[aq]<right>\\[aq])\ncmd-home                 (default \\[aq]<c-a>\\[aq] and \\[aq]<home>\\[aq])\ncmd-end                  (default \\[aq]<c-e>\\[aq] and \\[aq]<end>\\[aq])\ncmd-delete               (default \\[aq]<c-d>\\[aq] and \\[aq]<delete>\\[aq])\ncmd-delete-back          (default \\[aq]<backspace>\\[aq] and \\[aq]<backspace2>\\[aq])\ncmd-delete-home          (default \\[aq]<c-u>\\[aq])\ncmd-delete-end           (default \\[aq]<c-k>\\[aq])\ncmd-delete-unix-word     (default \\[aq]<c-w>\\[aq])\ncmd-yank                 (default \\[aq]<c-y>\\[aq])\ncmd-transpose            (default \\[aq]<c-t>\\[aq])\ncmd-transpose-word       (default \\[aq]<a-t>\\[aq])\ncmd-word                 (default \\[aq]<a-f>\\[aq])\ncmd-word-back            (default \\[aq]<a-b>\\[aq])\ncmd-delete-word          (default \\[aq]<a-d>\\[aq])\ncmd-delete-word-back     (default \\[aq]<a-backspace>\\[aq] and \\[aq]<a-backspace2>\\[aq])\ncmd-capitalize-word      (default \\[aq]<a-c>\\[aq])\ncmd-uppercase-word       (default \\[aq]<a-u>\\[aq])\ncmd-lowercase-word       (default \\[aq]<a-l>\\[aq])\n\\f[R]\n.fi\n.PP\nThe following options can be used to customize the behavior of lf:\n.IP\n.nf\n\\f[C]\nanchorfind        bool      (default true)\nautoquit          bool      (default true)\nborderfmt         string    (default \\[dq]\\[rs]033[0m\\[dq])\ncleaner           string    (default \\[aq]\\[aq])\ncopyfmt           string    (default \\[dq]\\[rs]033[7;33m\\[dq])\ncursoractivefmt   string    (default \\[dq]\\[rs]033[7m\\[dq])\ncursorparentfmt   string    (default \\[dq]\\[rs]033[7m\\[dq])\ncursorpreviewfmt  string    (default \\[dq]\\[rs]033[4m\\[dq])\ncutfmt            string    (default \\[dq]\\[rs]033[7;31m\\[dq])\ndircache          bool      (default true)\ndircounts         bool      (default false)\ndirfirst          bool      (default true)\ndironly           bool      (default false)\ndirpreviews       bool      (default false)\ndrawbox           bool      (default false)\ndupfilefmt        string    (default \\[aq]%f.\\[ti]%n\\[ti]\\[aq])\nerrorfmt          string    (default \\[dq]\\[rs]033[7;31;47m\\[dq])\nfilesep           string    (default \\[dq]\\[rs]n\\[dq])\nfindlen           int       (default 1)\nglobfilter        bool      (default false)\nglobsearch        bool      (default false)\nhidden            bool      (default false)\nhiddenfiles       []string  (default \\[aq].*\\[aq] for Unix and \\[aq]\\[aq] for Windows)\nhistory           bool      (default true)\nicons             bool      (default false)\nifs               string    (default \\[aq]\\[aq])\nignorecase        bool      (default true)\nignoredia         bool      (default true)\nincfilter         bool      (default false)\nincsearch         bool      (default false)\ninfo              []string  (default \\[aq]\\[aq])\ninfotimefmtnew    string    (default \\[aq]Jan _2 15:04\\[aq])\ninfotimefmtold    string    (default \\[aq]Jan _2  2006\\[aq])\nlocale            string    (default \\[aq]\\[aq])\nmouse             bool      (default false)\nnumber            bool      (default false)\nnumberfmt         string    (default \\[dq]\\[rs]033[33m\\[dq])\nperiod            int       (default 0)\npreserve          []string  (default \\[dq]mode\\[dq])\npreview           bool      (default true)\npreviewer         string    (default \\[aq]\\[aq])\npromptfmt         string    (default \\[dq]\\[rs]033[32;1m%u\\[at]%h\\[rs]033[0m:\\[rs]033[34;1m%d\\[rs]033[0m\\[rs]033[1m%f\\[rs]033[0m\\[dq])\nratios            []int     (default \\[aq]1:2:3\\[aq])\nrelativenumber    bool      (default false)\nreverse           bool      (default false)\nroundbox          bool      (default false)\nrulerfmt          string    (default \\[dq]  %a|  %p|  \\[rs]033[7;31m %m \\[rs]033[0m|  \\[rs]033[7;33m %c \\[rs]033[0m|  \\[rs]033[7;35m %s \\[rs]033[0m|  \\[rs]033[7;34m %f \\[rs]033[0m|  %i/%t\\[dq])\nscrolloff         int       (default 0)\nselectfmt         string    (default \\[dq]\\[rs]033[7;35m\\[dq])\nselmode           string    (default \\[aq]all\\[aq])\nshell             string    (default \\[aq]sh\\[aq] for Unix and \\[aq]cmd\\[aq] for Windows)\nshellflag         string    (default \\[aq]-c\\[aq] for Unix and \\[aq]/c\\[aq] for Windows)\nshellopts         []string  (default \\[aq]\\[aq])\nshowbinds         bool      (default true)\nsixel             bool      (default false)\nsmartcase         bool      (default true)\nsmartdia          bool      (default false)\nsortby            string    (default \\[aq]natural\\[aq])\nstatfmt           string    (default \\[dq]\\[rs]033[36m%p\\[rs]033[0m| %c| %u| %g| %S| %t| -> %l\\[dq])\ntabstop           int       (default 8)\ntagfmt            string    (default \\[dq]\\[rs]033[31m\\[dq])\ntempmarks         string    (default \\[aq]\\[aq])\ntimefmt           string    (default \\[aq]Mon Jan _2 15:04:05 2006\\[aq])\ntruncatechar      string    (default \\[aq]\\[ti]\\[aq])\ntruncatepct       int       (default 100)\nwaitmsg           string    (default \\[aq]Press any key to continue\\[aq])\nwatch             bool      (default false)\nwrapscan          bool      (default true)\nwrapscroll        bool      (default false)\nuser_{option}     string    (default none)\n\\f[R]\n.fi\n.PP\nThe following environment variables are exported for shell commands:\n.IP\n.nf\n\\f[C]\nf\nfs\nfx\nid\nPWD\nOLDPWD\nLF_LEVEL\nOPENER\nVISUAL\nEDITOR\nPAGER\nSHELL\nlf\nlf_{option}\nlf_user_{option}\nlf_width\nlf_height\nlf_count\nlf_mode\n\\f[R]\n.fi\n.PP\nThe following special shell commands are used to customize the behavior\nof lf when defined:\n.IP\n.nf\n\\f[C]\nopen\npaste\nrename\ndelete\npre-cd\non-cd\non-focus-gained\non-focus-lost\non-init\non-select\non-redraw\non-quit\n\\f[R]\n.fi\n.PP\nThe following commands/keybindings are provided by default:\n.IP\n.nf\n\\f[C]\nUnix\ncmd open &$OPENER \\[dq]$f\\[dq]\nmap e $$EDITOR \\[dq]$f\\[dq]\nmap i $$PAGER \\[dq]$f\\[dq]\nmap w $$SHELL\ncmd doc $$lf -doc | $PAGER\nmap <f-1> doc\ncmd maps $lf -remote \\[dq]query $id maps\\[dq] | $PAGER\ncmd cmaps $lf -remote \\[dq]query $id cmaps\\[dq] | $PAGER\ncmd cmds $lf -remote \\[dq]query $id cmds\\[dq] | $PAGER\n\nWindows\ncmd open &%OPENER% %f%\nmap e $%EDITOR% %f%\nmap i !%PAGER% %f%\nmap w $%SHELL%\ncmd doc !%lf% -doc | %PAGER%\nmap <f-1> doc\ncmd maps !%lf% -remote \\[dq]query %id% maps\\[dq] | %PAGER%\ncmd cmaps !%lf% -remote \\[dq]query %id% cmaps\\[dq] | %PAGER%\ncmd cmds !%lf% -remote \\[dq]query %id% cmds\\[dq] | %PAGER%\n\\f[R]\n.fi\n.PP\nThe following additional keybindings are provided by default:\n.IP\n.nf\n\\f[C]\nmap zh set hidden!\nmap zr set reverse!\nmap zn set info\nmap zs set info size\nmap zt set info time\nmap za set info size:time\nmap sn :set sortby natural; set info\nmap ss :set sortby size; set info size\nmap st :set sortby time; set info time\nmap sa :set sortby atime; set info atime\nmap sc :set sortby ctime; set info ctime\nmap se :set sortby ext; set info\nmap gh cd \\[ti]\nmap <space> :toggle; down\n\\f[R]\n.fi\n.PP\nIf the \\f[C]mouse\\f[R] option is enabled, mouse buttons have the\nfollowing default effects:\n.IP\n.nf\n\\f[C]\nLeft mouse button\n    Click on a file or directory to select it.\n\nRight mouse button\n    Enter a directory or open a file. Also works on the preview window.\n\nScroll wheel\n    Move up or down. If Ctrl is pressed, scroll up or down.\n\\f[R]\n.fi\n.SH CONFIGURATION\n.PP\nConfiguration files should be located at:\n.IP\n.nf\n\\f[C]\nOS       system-wide               user-specific\nUnix     /etc/lf/lfrc              \\[ti]/.config/lf/lfrc\nWindows  C:\\[rs]ProgramData\\[rs]lf\\[rs]lfrc    C:\\[rs]Users\\[rs]<user>\\[rs]AppData\\[rs]Local\\[rs]lf\\[rs]lfrc\n\\f[R]\n.fi\n.PP\nThe colors file should be located at:\n.IP\n.nf\n\\f[C]\nOS       system-wide               user-specific\nUnix     /etc/lf/colors            \\[ti]/.config/lf/colors\nWindows  C:\\[rs]ProgramData\\[rs]lf\\[rs]colors  C:\\[rs]Users\\[rs]<user>\\[rs]AppData\\[rs]Local\\[rs]lf\\[rs]colors\n\\f[R]\n.fi\n.PP\nThe icons file should be located at:\n.IP\n.nf\n\\f[C]\nOS       system-wide               user-specific\nUnix     /etc/lf/icons             \\[ti]/.config/lf/icons\nWindows  C:\\[rs]ProgramData\\[rs]lf\\[rs]icons   C:\\[rs]Users\\[rs]<user>\\[rs]AppData\\[rs]Local\\[rs]lf\\[rs]icons\n\\f[R]\n.fi\n.PP\nThe selection file should be located at:\n.IP\n.nf\n\\f[C]\nUnix     \\[ti]/.local/share/lf/files\nWindows  C:\\[rs]Users\\[rs]<user>\\[rs]AppData\\[rs]Local\\[rs]lf\\[rs]files\n\\f[R]\n.fi\n.PP\nThe marks file should be located at:\n.IP\n.nf\n\\f[C]\nUnix     \\[ti]/.local/share/lf/marks\nWindows  C:\\[rs]Users\\[rs]<user>\\[rs]AppData\\[rs]Local\\[rs]lf\\[rs]marks\n\\f[R]\n.fi\n.PP\nThe tags file should be located at:\n.IP\n.nf\n\\f[C]\nUnix     \\[ti]/.local/share/lf/tags\nWindows  C:\\[rs]Users\\[rs]<user>\\[rs]AppData\\[rs]Local\\[rs]lf\\[rs]tags\n\\f[R]\n.fi\n.PP\nThe history file should be located at:\n.IP\n.nf\n\\f[C]\nUnix     \\[ti]/.local/share/lf/history\nWindows  C:\\[rs]Users\\[rs]<user>\\[rs]AppData\\[rs]Local\\[rs]lf\\[rs]history\n\\f[R]\n.fi\n.PP\nYou can configure these locations with the following variables given\nwith their order of precedences and their default values:\n.IP\n.nf\n\\f[C]\nUnix\n    $LF_CONFIG_HOME\n    $XDG_CONFIG_HOME\n    \\[ti]/.config\n\n    $LF_DATA_HOME\n    $XDG_DATA_HOME\n    \\[ti]/.local/share\n\nWindows\n    %ProgramData%\n    C:\\[rs]ProgramData\n\n    %LF_CONFIG_HOME%\n    %LOCALAPPDATA%\n    C:\\[rs]Users\\[rs]<user>\\[rs]AppData\\[rs]Local\n\\f[R]\n.fi\n.PP\nA sample configuration file can be found at\n<https://github.com/gokcehan/lf/blob/master/etc/lfrc.example>\n.SH COMMANDS\n.PP\nThis section shows information about built-in commands.\nModal commands do not take any arguments, but instead change the\noperation mode to read their input conveniently, and so they are meant\nto be assigned to keybindings.\n.SS quit (default \\f[C]q\\f[R])\n.PP\nQuit lf and return to the shell.\n.SS up (default \\f[C]k\\f[R] and \\f[C]<up>\\f[R]), half-up (default \\f[C]<c-u>\\f[R]), page-up (default \\f[C]<c-b>\\f[R] and \\f[C]<pgup>\\f[R]), scroll-up (default \\f[C]<c-y>\\f[R]), down (default \\f[C]j\\f[R] and \\f[C]<down>\\f[R]), half-down (default \\f[C]<c-d>\\f[R]), page-down (default \\f[C]<c-f>\\f[R] and \\f[C]<pgdn>\\f[R]), scroll-down (default \\f[C]<c-e>\\f[R])\n.PP\nMove/scroll the current file selection upwards/downwards by one/half a\npage/full page.\n.SS updir (default \\f[C]h\\f[R] and \\f[C]<left>\\f[R])\n.PP\nChange the current working directory to the parent directory.\n.SS open (default \\f[C]l\\f[R] and \\f[C]<right>\\f[R])\n.PP\nIf the current file is a directory, then change the current directory to\nit, otherwise, execute the \\f[C]open\\f[R] command.\nA default \\f[C]open\\f[R] command is provided to call the default system\nopener asynchronously with the current file as the argument.\nA custom \\f[C]open\\f[R] command can be defined to override this default.\n.SS jump-next (default \\f[C]]\\f[R]), jump-prev (default \\f[C][\\f[R])\n.PP\nChange the current working directory to the next/previous jumplist item.\n.SS top (default \\f[C]gg\\f[R] and \\f[C]<home>\\f[R]), bottom (default \\f[C]G\\f[R] and \\f[C]<end>\\f[R])\n.PP\nMove the current file selection to the top/bottom of the directory.\nA count can be specified to move to a specific line, for example, use\n\\f[C]3G\\f[R] to move to the third line.\n.SS high (default \\f[C]H\\f[R]), middle (default \\f[C]M\\f[R]), low (default \\f[C]L\\f[R])\n.PP\nMove the current file selection to the high/middle/low of the screen.\n.SS toggle\n.PP\nToggle the selection of the current file or files given as arguments.\n.SS invert (default \\f[C]v\\f[R])\n.PP\nReverse the selection of all files in the current directory (i.e.\n\\f[C]toggle\\f[R] all files).\nSelections in other directories are not affected by this command.\nYou can define a new command to select all files in the directory by\ncombining \\f[C]invert\\f[R] with \\f[C]unselect\\f[R] (i.e.\n\\f[C]cmd select-all :unselect; invert\\f[R]), though this will also\nremove selections in other directories.\n.SS invert-below\n.PP\nReverse the selection (i.e.\n\\f[C]toggle\\f[R]) of all files at or after the current file in the\ncurrent directory.\n.PP\nTo select a contiguous block of files, use this command on the first\nfile you want to select.\nThen, move down to the first file you do \\f[I]not\\f[R] want to select\n(the one after the end of the desired selection) and use this command\nagain.\nThis achieves an effect similar to the visual mode in Vim.\n.PP\nThis command is experimental and may be removed once a better\nreplacement for the visual mode is implemented in \\f[C]lf\\f[R].\nIf you\\[aq]d like to experiment with using this command, you should bind\nit to a key (e.g.\n\\f[C]V\\f[R]) for a better experience.\n.SS unselect (default \\f[C]u\\f[R])\n.PP\nRemove the selection of all files in all directories.\n.SS glob-select, glob-unselect\n.PP\nSelect/unselect files that match the given glob.\n.SS calcdirsize\n.PP\nCalculate the total size for each of the selected directories.\nOption \\f[C]info\\f[R] should include \\f[C]size\\f[R] and option\n\\f[C]dircounts\\f[R] should be disabled to show this size.\nIf the total size of a directory is not calculated, it will be shown as\n\\f[C]-\\f[R].\n.SS clearmaps\n.PP\nRemove all keybindings associated with the \\f[C]map\\f[R] command.\nThis command can be used in the config file to remove the default\nkeybindings.\nFor safety purposes, \\f[C]:\\f[R] is left mapped to the \\f[C]read\\f[R]\ncommand, and \\f[C]cmap\\f[R] keybindings are retained so that it is still\npossible to exit \\f[C]lf\\f[R] using \\f[C]:quit\\f[R].\n.SS copy (default \\f[C]y\\f[R])\n.PP\nIf there are no selections, save the path of the current file to the\ncopy buffer, otherwise, copy the paths of selected files.\n.SS cut (default \\f[C]d\\f[R])\n.PP\nIf there are no selections, save the path of the current file to the cut\nbuffer, otherwise, copy the paths of selected files.\n.SS paste (default \\f[C]p\\f[R])\n.PP\nCopy/Move files in the copy/cut buffer to the current working directory.\nA custom \\f[C]paste\\f[R] command can be defined to override this\ndefault.\n.SS clear (default \\f[C]c\\f[R])\n.PP\nClear file paths in copy/cut buffer.\n.SS sync\n.PP\nSynchronize copied/cut files with the server.\nThis command is automatically called when required.\n.SS draw\n.PP\nDraw the screen.\nThis command is automatically called when required.\n.SS redraw (default \\f[C]<c-l>\\f[R])\n.PP\nSynchronize the terminal and redraw the screen.\n.SS load\n.PP\nLoad modified files and directories.\nThis command is automatically called when required.\n.SS reload (default \\f[C]<c-r>\\f[R])\n.PP\nFlush the cache and reload all files and directories.\n.SS echo\n.PP\nPrint the given arguments to the message line at the bottom.\n.SS echomsg\n.PP\nPrint the given arguments to the message line at the bottom and also to\nthe log file.\n.SS echoerr\n.PP\nPrint given arguments to the message line at the bottom as\n\\f[C]errorfmt\\f[R] and also to the log file.\n.SS cd\n.PP\nChange the working directory to the given argument.\n.SS select\n.PP\nChange the current file selection to the given argument.\n.SS delete (modal)\n.PP\nRemove the current file or selected file(s).\nA custom \\f[C]delete\\f[R] command can be defined to override this\ndefault.\n.SS rename (modal) (default \\f[C]r\\f[R])\n.PP\nRename the current file using the built-in method.\nA custom \\f[C]rename\\f[R] command can be defined to override this\ndefault.\n.SS source\n.PP\nRead the configuration file given in the argument.\n.SS push\n.PP\nSimulate key pushes given in the argument.\n.SS read (modal) (default \\f[C]:\\f[R])\n.PP\nRead a command to evaluate.\n.SS shell (modal) (default \\f[C]$\\f[R])\n.PP\nRead a shell command to execute.\n.SS shell-pipe (modal) (default \\f[C]%\\f[R])\n.PP\nRead a shell command to execute piping its standard I/O to the bottom\nstatline.\n.SS shell-wait (modal) (default \\f[C]!\\f[R])\n.PP\nRead a shell command to execute and wait for a key press in the end.\n.SS shell-async (modal) (default \\f[C]&\\f[R])\n.PP\nRead a shell command to execute asynchronously without standard I/O.\n.SS find (modal) (default \\f[C]f\\f[R]), find-back (modal) (default \\f[C]F\\f[R]), find-next (default \\f[C];\\f[R]), find-prev (default \\f[C],\\f[R])\n.PP\nRead key(s) to find the appropriate file name match in the\nforward/backward direction and jump to the next/previous match.\n.SS search (default \\f[C]/\\f[R]), search-back (default \\f[C]?\\f[R]), search-next (default \\f[C]n\\f[R]), search-prev (default \\f[C]N\\f[R])\n.PP\nRead a pattern to search for a file name match in the forward/backward\ndirection and jump to the next/previous match.\n.SS filter (modal), setfilter\n.PP\nCommand \\f[C]filter\\f[R] reads a pattern to filter out and only view\nfiles matching the pattern.\nCommand \\f[C]setfilter\\f[R] does the same but uses an argument to set\nthe filter immediately.\nYou can supply an argument to \\f[C]filter\\f[R] to use as the starting\nprompt.\n.SS mark-save (modal) (default \\f[C]m\\f[R])\n.PP\nSave the current directory as a bookmark assigned to the given key.\n.SS mark-load (modal) (default \\f[C]\\[aq]\\f[R])\n.PP\nChange the current directory to the bookmark assigned to the given key.\nA special bookmark \\f[C]\\[aq]\\f[R] holds the previous directory after a\n\\f[C]mark-load\\f[R], \\f[C]cd\\f[R], or \\f[C]select\\f[R] command.\n.SS mark-remove (modal) (default \\f[C]\\[dq]\\f[R])\n.PP\nRemove a bookmark assigned to the given key.\n.SS tag\n.PP\nTag a file with \\f[C]*\\f[R] or a single-width character given in the\nargument.\nYou can define a new tag-clearing command by combining \\f[C]tag\\f[R]\nwith \\f[C]tag-toggle\\f[R] (i.e.\n\\f[C]cmd tag-clear :tag; tag-toggle\\f[R]).\n.SS tag-toggle (default \\f[C]t\\f[R])\n.PP\nTag a file with \\f[C]*\\f[R] or a single width character given in the\nargument if the file is untagged, otherwise remove the tag.\n.SH COMMAND LINE COMMANDS\n.PP\nThe prompt character specifies which of the several command-line modes\nyou are in.\nFor example, the \\f[C]read\\f[R] command takes you to the \\f[C]:\\f[R]\nmode.\n.PP\nWhen the cursor is at the first character in \\f[C]:\\f[R] mode, pressing\none of the keys \\f[C]!\\f[R], \\f[C]$\\f[R], \\f[C]%\\f[R], or \\f[C]&\\f[R]\ntakes you to the corresponding mode.\nYou can go back with \\f[C]cmd-delete-back\\f[R] (\\f[C]<backspace>\\f[R] by\ndefault).\n.PP\nThe command line commands should be mostly compatible with readline\nkeybindings.\nA character refers to a Unicode code point, a word consists of letters\nand digits, and a unix word consists of any non-blank characters.\n.SS cmd-escape (default \\f[C]<esc>\\f[R])\n.PP\nQuit command line mode and return to normal mode.\n.SS cmd-complete (default \\f[C]<tab>\\f[R])\n.PP\nAutocomplete the current word.\n.SS cmd-menu-complete, cmd-menu-complete-back\n.PP\nAutocomplete the current word with the menu selection.\nYou need to assign keys to these commands (e.g.\n\\f[C]cmap <tab> cmd-menu-complete; cmap <backtab> cmd-menu-complete-back\\f[R]).\nYou can use the assigned keys to display the menu and then cycle through\ncompletion options.\n.SS cmd-menu-accept\n.PP\nAccept the currently selected match in menu completion and close the\nmenu.\n.SS cmd-enter (default \\f[C]<c-j>\\f[R] and \\f[C]<enter>\\f[R])\n.PP\nExecute the current line.\n.SS cmd-interrupt (default \\f[C]<c-c>\\f[R])\n.PP\nInterrupt the current shell-pipe command and return to the normal mode.\n.SS cmd-history-next (default \\f[C]<c-n>\\f[R] and \\f[C]<down>\\f[R]), cmd-history-prev (default \\f[C]<c-p>\\f[R] and \\f[C]<up>\\f[R])\n.PP\nGo to the next/previous item in the history.\n.SS cmd-left (default \\f[C]<c-b>\\f[R] and \\f[C]<left>\\f[R]), cmd-right (default \\f[C]<c-f>\\f[R] and \\f[C]<right>\\f[R])\n.PP\nMove the cursor to the left/right.\n.SS cmd-home (default \\f[C]<c-a>\\f[R] and \\f[C]<home>\\f[R]), cmd-end (default \\f[C]<c-e>\\f[R] and \\f[C]<end>\\f[R])\n.PP\nMove the cursor to the beginning/end of the line.\n.SS cmd-delete (default \\f[C]<c-d>\\f[R] and \\f[C]<delete>\\f[R])\n.PP\nDelete the next character.\n.SS cmd-delete-back (default \\f[C]<backspace>\\f[R] and \\f[C]<backspace2>\\f[R])\n.PP\nDelete the previous character.\nWhen at the beginning of a prompt, returns either to normal mode or to\n\\f[C]:\\f[R] mode.\n.SS cmd-delete-home (default \\f[C]<c-u>\\f[R]), cmd-delete-end (default \\f[C]<c-k>\\f[R])\n.PP\nDelete everything up to the beginning/end of the line.\n.SS cmd-delete-unix-word (default \\f[C]<c-w>\\f[R])\n.PP\nDelete the previous unix word.\n.SS cmd-yank (default \\f[C]<c-y>\\f[R])\n.PP\nPaste the buffer content containing the last deleted item.\n.SS cmd-transpose (default \\f[C]<c-t>\\f[R]), cmd-transpose-word (default \\f[C]<a-t>\\f[R])\n.PP\nTranspose the positions of the last two characters/words.\n.SS cmd-word (default \\f[C]<a-f>\\f[R]), cmd-word-back (default \\f[C]<a-b>\\f[R])\n.PP\nMove the cursor by one word in the forward/backward direction.\n.SS cmd-delete-word (default \\f[C]<a-d>\\f[R])\n.PP\nDelete the next word in the forward direction.\n.SS cmd-delete-word-back (default \\f[C]<a-backspace>\\f[R] and \\f[C]<a-backspace2>\\f[R])\n.PP\nDelete the previous word in the backward direction.\n.SS cmd-capitalize-word (default \\f[C]<a-c>\\f[R]), cmd-uppercase-word (default \\f[C]<a-u>\\f[R]), cmd-lowercase-word (default \\f[C]<a-l>\\f[R])\n.PP\nCapitalize/uppercase/lowercase the current word and jump to the next\nword.\n.SH OPTIONS\n.PP\nThis section shows information about options to customize the behavior.\nCharacter \\f[C]:\\f[R] is used as the separator for list options\n\\f[C][]int\\f[R] and \\f[C][]string\\f[R].\n.SS anchorfind (bool) (default true)\n.PP\nWhen this option is enabled, the find command starts matching patterns\nfrom the beginning of file names, otherwise, it can match at an\narbitrary position.\n.SS autoquit (bool) (default true)\n.PP\nAutomatically quit the server when there are no clients left connected.\n.SS borderfmt (string) (default \\f[C]\\[rs]033[0m\\f[R])\n.PP\nFormat string of the box drawing characters enabled by the\n\\f[C]drawbox\\f[R] option.\n.SS cleaner (string) (default \\[ga]\\[ga]) (not called if empty)\n.PP\nSet the path of a cleaner file.\nThe file should be executable.\nThis file is called if previewing is enabled, the previewer is set, and\nthe previously selected file has its preview cache disabled.\nThe following arguments are passed to the file, (1) current file name,\n(2) width, (3) height, (4) horizontal position, (5) vertical position of\npreview pane and (6) next file name to be previewed respectively.\nPreview cleaning is disabled when the value of this option is left\nempty.\n.SS copyfmt (string) (default \\f[C]\\[rs]033[7;33m\\f[R])\n.PP\nFormat string of the indicator for files to be copied.\n.SS cursoractivefmt (string) (default \\f[C]\\[rs]033[7m\\f[R]), cursorparentfmt string (default \\f[C]\\[rs]033[7m\\f[R]), cursorpreviewfmt string (default \\f[C]\\[rs]033[4m\\f[R])\n.PP\nFormat strings for highlighting the cursor.\n\\f[C]cursoractivefmt\\f[R] applies in the current directory pane,\n\\f[C]cursorparentfmt\\f[R] applies in panes that show parents of the\ncurrent directory, and \\f[C]cursorpreviewfmt\\f[R] applies in panes that\npreview directories.\n.PP\nThe default is to make the active cursor and the parent directory cursor\ninverted.\nThe preview cursor is underlined.\n.PP\nSome other possibilities to consider for the preview or parent cursors:\nan empty string for no cursor, \\f[C]\\[rs]033[7;2m\\f[R] for dimmed\ninverted text (visibility varies by terminal), \\f[C]\\[rs]033[7;90m\\f[R]\nfor inverted text with grey (aka \\[dq]brightblack\\[dq]) background.\n.PP\nIf the format string contains the characters \\f[C]%s\\f[R], it is\ninterpreted as a format string for \\f[C]fmt.Sprintf\\f[R].\nSuch a string should end with the terminal reset sequence.\nFor example, \\f[C]\\[rs]033[4m%s\\[rs]033[0m\\f[R] has the same effect as\n\\f[C]\\[rs]033[4m\\f[R].\n.SS cutfmt (string) (default \\f[C]\\[rs]033[7;31m\\f[R])\n.PP\nFormat string of the indicator for files to be cut.\n.SS dircache (bool) (default true)\n.PP\nCache directory contents.\n.SS dircounts (bool) (default false)\n.PP\nWhen this option is enabled, directory sizes show the number of items\ninside instead of the total size of the directory, which needs to be\ncalculated for each directory using \\f[C]calcdirsize\\f[R].\nThis information needs to be calculated by reading the directory and\ncounting the items inside.\nTherefore, this option is disabled by default for performance reasons.\nThis option only has an effect when \\f[C]info\\f[R] has a \\f[C]size\\f[R]\nfield and the pane is wide enough to show the information.\n999 items are counted per directory at most, and bigger directories are\nshown as \\f[C]999+\\f[R].\n.SS dirfirst (bool) (default true)\n.PP\nShow directories first above regular files.\n.SS dironly (bool) (default false)\n.PP\nShow only directories.\n.SS dirpreviews (bool) (default false)\n.PP\nIf enabled, directories will also be passed to the previewer script.\nThis allows custom previews for directories.\n.SS drawbox (bool) (default false)\n.PP\nDraw boxes around panes with box drawing characters.\n.SS dupfilefmt (string) (default \\f[C]%f.\\[ti]%n\\[ti]\\f[R])\n.PP\nFormat string of file name when creating duplicate files.\nWith the default format, copying a file \\f[C]abc.txt\\f[R] to the same\ndirectory will result in a duplicate file called\n\\f[C]abc.txt.\\[ti]1\\[ti]\\f[R].\nSpecial expansions are provided, \\f[C]%f\\f[R] as the file name,\n\\f[C]%b\\f[R] for the basename (file name without extension),\n\\f[C]%e\\f[R] as the extension (including the dot) and \\f[C]%n\\f[R] as\nthe number of duplicates.\n.SS errorfmt (string) (default \\f[C]\\[rs]033[7;31;47m\\f[R])\n.PP\nFormat string of error messages shown in the bottom message line.\n.PP\nIf the format string contains the characters \\f[C]%s\\f[R], it is\ninterpreted as a format string for \\f[C]fmt.Sprintf\\f[R].\nSuch a string should end with the terminal reset sequence.\nFor example, \\f[C]\\[rs]033[4m%s\\[rs]033[0m\\f[R] has the same effect as\n\\f[C]\\[rs]033[4m\\f[R].\n.SS filesep (string) (default \\f[C]\\[rs]n\\f[R])\n.PP\nFile separator used in environment variables \\f[C]fs\\f[R] and\n\\f[C]fx\\f[R].\n.SS findlen (int) (default 1)\n.PP\nNumber of characters prompted for the find command.\nWhen this value is set to 0, find command prompts until there is only a\nsingle match left.\n.SS globfilter (bool) (default false)\n.PP\nPatterns are treated as globs for the filter command, see\n\\f[C]globsearch\\f[R] for more details.\n.SS globsearch (bool) (default false)\n.PP\nWhen this option is enabled, search command patterns are considered as\nglobs, otherwise, they are literals.\nWith globbing, \\f[C]*\\f[R] matches any sequence, \\f[C]?\\f[R] matches any\ncharacter, and \\f[C][...]\\f[R] or \\f[C][\\[ha]...]\\f[R] matches character\nsets or ranges.\nOtherwise, these characters are interpreted as they are.\n.SS hidden (bool) (default false)\n.PP\nShow hidden files.\nOn Unix systems, hidden files are determined by the value of\n\\f[C]hiddenfiles\\f[R].\nOn Windows, files with hidden attributes are also considered hidden\nfiles.\n.SS hiddenfiles ([]string) (default \\f[C].*\\f[R] for Unix and \\[ga]\\[ga] for Windows)\n.PP\nList of hidden file glob patterns.\nPatterns can be given as relative or absolute paths.\nGlobbing supports the usual special characters, \\f[C]*\\f[R] to match any\nsequence, \\f[C]?\\f[R] to match any character, and \\f[C][...]\\f[R] or\n\\f[C][\\[ha]...]\\f[R] to match character sets or ranges.\nIn addition, if a pattern starts with \\f[C]!\\f[R], then its matches are\nexcluded from hidden files.\nTo add multiple patterns, use \\f[C]:\\f[R] as a separator.\nExample: \\f[C].*:lost+found:*.bak\\f[R]\n.SS history (bool) (default true)\n.PP\nSave command history.\n.SS icons (bool) (default false)\n.PP\nShow icons before each item in the list.\n.SS ifs (string) (default \\[ga]\\[ga])\n.PP\nSets \\f[C]IFS\\f[R] variable in shell commands.\nIt works by adding the assignment to the beginning of the command string\nas \\f[C]IFS=...; ...\\f[R].\nThe reason is that \\f[C]IFS\\f[R] variable is not inherited by the shell\nfor security reasons.\nThis method assumes a POSIX shell syntax so it can fail for non-POSIX\nshells.\nThis option has no effect when the value is left empty.\nThis option does not have any effect on Windows.\n.SS ignorecase (bool) (default true)\n.PP\nIgnore case in sorting and search patterns.\n.SS ignoredia (bool) (default true)\n.PP\nIgnore diacritics in sorting and search patterns.\n.SS incsearch (bool) (default false)\n.PP\nJump to the first match after each keystroke during searching.\n.SS incfilter (bool) (default false)\n.PP\nApply filter pattern after each keystroke during filtering.\n.SS info ([]string) (default \\[ga]\\[ga])\n.PP\nA list of information that is shown for directory items at the right\nside of the pane.\nCurrently supported information types are \\f[C]size\\f[R],\n\\f[C]time\\f[R], \\f[C]atime\\f[R], \\f[C]ctime\\f[R], \\f[C]perm\\f[R],\n\\f[C]user\\f[R] and \\f[C]group\\f[R].\nInformation is only shown when the pane width is more than twice the\nwidth of information.\n.SS infotimefmtnew (string) (default \\f[C]Jan _2 15:04\\f[R])\n.PP\nFormat string of the file time shown in the info column when it matches\nthis year.\n.SS infotimefmtold (string) (default \\f[C]Jan _2  2006\\f[R])\n.PP\nFormat string of the file time shown in the info column when it\ndoesn\\[aq]t match this year.\n.SS locale (string) (default \\[ga]\\[ga])\n.PP\nAn IETF BCP 47 language tag (e.g.\n\\f[C]zh-CN\\f[R]) for specifying the locale used when using sort type\n\\f[C]natural\\f[R] and \\f[C]name\\f[R].\n.PP\nAn empty string means disable locale ordering, and the special value\n\\f[C]*\\f[R] is used to indicate reading the locale setting from the\nsystem environment.\n.SS mouse (bool) (default false)\n.PP\nSend mouse events as input.\n.SS number (bool) (default false)\n.PP\nShow the position number for directory items on the left side of the\npane.\nWhen the \\f[C]relativenumber\\f[R] option is enabled, only the current\nline shows the absolute position and relative positions are shown for\nthe rest.\n.SS numberfmt (string) (default \\f[C]\\[rs]033[33m\\f[R])\n.PP\nFormat string of the position number for each line.\n.SS period (int) (default 0)\n.PP\nSet the interval in seconds for periodic checks of directory updates.\nThis works by periodically calling the \\f[C]load\\f[R] command.\nNote that directories are already updated automatically in many cases.\nThis option can be useful when there is an external process changing the\ndisplayed directory and you are not doing anything in lf.\nPeriodic checks are disabled when the value of this option is set to\nzero.\n.SS preserve ([]string) (default \\f[C]mode\\f[R])\n.PP\nList of attributes that are preserved when copying files.\nCurrently supported attributes are \\f[C]mode\\f[R] (i.a.\naccess mode) and \\f[C]timestamps\\f[R] (i.e.\nmodification time and access time).\nNote that preserving other attributes like ownership of change/birth\ntimestamp is desirable, but not portably supported in Go.\n.SS preview (bool) (default true)\n.PP\nShow previews of files and directories at the rightmost pane.\nIf the file has more lines than the preview pane, the rest of the lines\nare not read.\nFiles containing the null character (U+0000) in the read portion are\nconsidered binary files and displayed as \\f[C]binary\\f[R].\n.SS previewer (string) (default \\[ga]\\[ga]) (not filtered if empty)\n.PP\nSet the path of a previewer file to filter the content of regular files\nfor previewing.\nThe file should be executable.\nThe following arguments are passed to the file, (1) current file name,\n(2) width, (3) height, (4) horizontal position, and (5) vertical\nposition of preview pane respectively.\nSIGPIPE signal is sent when enough lines are read.\nIf the previewer returns a non-zero exit code, then the preview cache\nfor the given file is disabled.\nThis means that if the file is selected in the future, the previewer is\ncalled once again.\nPreview filtering is disabled and files are displayed as they are when\nthe value of this option is left empty.\n.SS promptfmt (string) (default \\f[C]\\[rs]033[32;1m%u\\[at]%h\\[rs]033[0m:\\[rs]033[34;1m%d\\[rs]033[0m\\[rs]033[1m%f\\[rs]033[0m\\f[R])\n.PP\nFormat string of the prompt shown in the top line.\nSpecial expansions are provided, \\f[C]%u\\f[R] as the user name,\n\\f[C]%h\\f[R] as the hostname, \\f[C]%w\\f[R] as the working directory,\n\\f[C]%d\\f[R] as the working directory with a trailing path separator,\n\\f[C]%f\\f[R] as the file name, and \\f[C]%F\\f[R] as the current filter.\n\\f[C]%S\\f[R] may be used once and will provide a spacer so that the\nfollowing parts are right aligned on the screen.\nThe home folder is shown as \\f[C]\\[ti]\\f[R] in the working directory\nexpansion.\nDirectory names are automatically shortened to a single character\nstarting from the leftmost parent when the prompt does not fit the\nscreen.\n.SS ratios ([]int) (default \\f[C]1:2:3\\f[R])\n.PP\nList of ratios of pane widths.\nNumber of items in the list determines the number of panes in the UI.\nWhen the \\f[C]preview\\f[R] option is enabled, the rightmost number is\nused for the width of the preview pane.\n.SS relativenumber (bool) (default false)\n.PP\nShow the position number relative to the current line.\nWhen \\f[C]number\\f[R] is enabled, the current line shows the absolute\nposition, otherwise nothing is shown.\n.SS reverse (bool) (default false)\n.PP\nReverse the direction of sort.\n.SS roundbox (bool) (default false)\n.PP\nDraw rounded outer corners when the \\f[C]drawbox\\f[R] option is enabled.\n.SS rulerfmt (string) (default \\f[C]  %a|  %p|  \\[rs]033[7;31m %m \\[rs]033[0m|  \\[rs]033[7;33m %c \\[rs]033[0m|  \\[rs]033[7;35m %s \\[rs]033[0m|  \\[rs]033[7;34m %f \\[rs]033[0m|  %i/%t\\f[R])\n.PP\nFormat string of the ruler shown in the bottom right corner.\nSpecial expansions are provided, \\f[C]%a\\f[R] as the pressed keys,\n\\f[C]%p\\f[R] as the progress of file operations, \\f[C]%m\\f[R] as the\nnumber of files to be cut (moved), \\f[C]%c\\f[R] as the number of files\nto be copied, \\f[C]%s\\f[R] as the number of selected files, \\f[C]%f\\f[R]\nas the filter, \\f[C]%i\\f[R] as the position of the cursor, \\f[C]%t\\f[R]\nas the number of files shown in the current directory, \\f[C]%h\\f[R] as\nthe number of files hidden in the current directory, and \\f[C]%d\\f[R] as\nthe amount of free disk space remaining.\nAdditional expansions are provided for environment variables exported by\nlf, in the form \\f[C]%{lf_<name>}\\f[R] (e.g.\n\\f[C]%{lf_selmode}\\f[R]).\nThis is useful for displaying the current settings.\nExpansions are also provided for user-defined options, in the form\n\\f[C]%{lf_user_<name>}\\f[R] (e.g.\n\\f[C]%{lf_user_foo}\\f[R]).\nThe \\f[C]|\\f[R] character splits the format string into sections.\nAny section containing a failed expansion (result is a blank string) is\ndiscarded and not shown.\n.SS selectfmt (string) (default \\f[C]\\[rs]033[7;35m\\f[R])\n.PP\nFormat string of the indicator for files that are selected.\n.SS selmode (string) (default \\f[C]all\\f[R])\n.PP\nSelection mode for commands.\nWhen set to \\f[C]all\\f[R] it will use the selected files from all\ndirectories.\nWhen set to \\f[C]dir\\f[R] it will only use the selected files in the\ncurrent directory.\n.SS scrolloff (int) (default 0)\n.PP\nMinimum number of offset lines shown at all times at the top and bottom\nof the screen when scrolling.\nThe current line is kept in the middle when this option is set to a\nlarge value that is bigger than the half of number of lines.\nA smaller offset can be used when the current file is close to the\nbeginning or end of the list to show the maximum number of items.\n.SS shell (string) (default \\f[C]sh\\f[R] for Unix and \\f[C]cmd\\f[R] for Windows)\n.PP\nShell executable to use for shell commands.\nShell commands are executed as\n\\f[C]shell shellopts shellflag command -- arguments\\f[R].\n.SS shellflag (string) (default \\f[C]-c\\f[R] for Unix and \\f[C]/c\\f[R] for Windows)\n.PP\nCommand line flag used to pass shell commands.\n.SS shellopts ([]string) (default \\[ga]\\[ga])\n.PP\nList of shell options to pass to the shell executable.\n.SS showbinds (bool) (default true)\n.PP\nShow bindings associated with pressed keys.\n.SS sixel (bool) (default false)\n.PP\nRender sixel images in preview.\n.SS smartcase (bool) (default true)\n.PP\nOverride \\f[C]ignorecase\\f[R] option when the pattern contains an\nuppercase character.\nThis option has no effect when \\f[C]ignorecase\\f[R] is disabled.\n.SS smartdia (bool) (default false)\n.PP\nOverride \\f[C]ignoredia\\f[R] option when the pattern contains a\ncharacter with diacritic.\nThis option has no effect when \\f[C]ignoredia\\f[R] is disabled.\n.SS sortby (string) (default \\f[C]natural\\f[R])\n.PP\nSort type for directories.\nCurrently supported sort types are \\f[C]natural\\f[R], \\f[C]name\\f[R],\n\\f[C]size\\f[R], \\f[C]time\\f[R], \\f[C]ctime\\f[R], \\f[C]atime\\f[R], and\n\\f[C]ext\\f[R].\n.SS statfmt (string) (default \\f[C]\\[rs]033[36m%p\\[rs]033[0m| %c| %u| %g| %S| %t| -> %l\\f[R])\n.PP\nFormat string of the file info shown in the bottom left corner.\nSpecial expansions are provided, \\f[C]%p\\f[R] as the file permissions,\n\\f[C]%c\\f[R] as the link count, \\f[C]%u\\f[R] as the user, \\f[C]%g\\f[R]\nas the group, \\f[C]%s\\f[R] as the file size, \\f[C]%S\\f[R] as the file\nsize but with a fixed width of four characters (left-padded with\nspaces), \\f[C]%t\\f[R] as the last modified time, and \\f[C]%l\\f[R] as the\nlink target.\nThe \\f[C]|\\f[R] character splits the format string into sections.\nAny section containing a failed expansion (result is a blank string) is\ndiscarded and not shown.\n.SS tabstop (int) (default 8)\n.PP\nNumber of space characters to show for horizontal tabulation (U+0009)\ncharacter.\n.SS tagfmt (string) (default \\f[C]\\[rs]033[31m\\f[R])\n.PP\nFormat string of the tags.\n.PP\nIf the format string contains the characters \\f[C]%s\\f[R], it is\ninterpreted as a format string for \\f[C]fmt.Sprintf\\f[R].\nSuch a string should end with the terminal reset sequence.\nFor example, \\f[C]\\[rs]033[4m%s\\[rs]033[0m\\f[R] has the same effect as\n\\f[C]\\[rs]033[4m\\f[R].\n.SS tempmarks (string) (default \\[ga]\\[ga])\n.PP\nMarks to be considered temporary (e.g.\n\\f[C]abc\\f[R] refers to marks \\f[C]a\\f[R], \\f[C]b\\f[R], and\n\\f[C]c\\f[R]).\nThese marks are not synced to other clients and they are not saved in\nthe bookmarks file.\nNote that the special bookmark \\f[C]\\[ga]\\f[R] is always treated as\ntemporary and it does not need to be specified.\n.SS timefmt (string) (default \\f[C]Mon Jan _2 15:04:05 2006\\f[R])\n.PP\nFormat string of the file modification time shown in the bottom line.\n.SS truncatechar (string) (default \\f[C]\\[ti]\\f[R])\n.PP\nThe truncate character that is shown at the end when the file name does\nnot fit into the pane.\n.SS truncatepct (int) (default 100)\n.PP\nWhen a filename is too long to be shown completely, the available space\nis partitioned into two pieces.\ntruncatepct defines a fraction (in percent between 0 and 100) for the\nsize of the first piece, which will show the beginning of the filename.\nThe second piece will show the end of the filename and will use the rest\nof the available space.\nBoth pieces are separated by the truncation character (truncatechar).\nA value of 100 will only show the beginning of the filename, while a\nvalue of 0 will only show the end of the filename, e.g.:\n.IP \\[bu] 2\n\\f[C]set truncatepct 100\\f[R] -> \\f[C]very-long-filename-tr\\[ti]\\f[R]\n(default)\n.IP \\[bu] 2\n\\f[C]set truncatepct 50\\f[R] -> \\f[C]very-long-f\\[ti]-truncated\\f[R]\n.IP \\[bu] 2\n\\f[C]set truncatepct 0\\f[R] -> \\f[C]\\[ti]ng-filename-truncated\\f[R]\n.SS waitmsg (string) (default \\f[C]Press any key to continue\\f[R])\n.PP\nString shown after commands of shell-wait type.\n.SS watch (bool) (default false)\n.PP\nWatch the filesystem for changes using \\f[C]fsnotify\\f[R] to\nautomatically refresh file information.\nFUSE is currently not supported due to limitations in\n\\f[C]fsnotify\\f[R].\n.SS wrapscan (bool) (default true)\n.PP\nSearching can wrap around the file list.\n.SS wrapscroll (bool) (default false)\n.PP\nScrolling can wrap around the file list.\n.SS user_{option} (string) (default none)\n.PP\nAny option that is prefixed with \\f[C]user_\\f[R] is a user-defined\noption and can be set to any string.\nInside a user-defined command, the value will be provided in the\n\\f[C]lf_user_{option}\\f[R] environment variable.\nThese options are not used by lf and are not persisted.\n.SH ENVIRONMENT VARIABLES\n.PP\nThe following variables are exported for shell commands: These are\nreferred to with a \\f[C]$\\f[R] prefix on POSIX shells (e.g.\n\\f[C]$f\\f[R]), between \\f[C]%\\f[R] characters on Windows cmd (e.g.\n\\f[C]%f%\\f[R]), and with a \\f[C]$env:\\f[R] prefix on Windows PowerShell\n(e.g.\n\\f[C]$env:f\\f[R]).\n.SS f\n.PP\nCurrent file selection as a full path.\n.SS fs\n.PP\nSelected file(s) separated with the value of \\f[C]filesep\\f[R] option as\nfull path(s).\n.SS fx\n.PP\nSelected file(s) (i.e.\n\\f[C]fs\\f[R]) if there are any selected files, otherwise current file\nselection (i.e.\n\\f[C]f\\f[R]).\n.SS id\n.PP\nId of the running client.\n.SS PWD\n.PP\nPresent working directory.\n.SS OLDPWD\n.PP\nInitial working directory.\n.SS LF_LEVEL\n.PP\nThe value of this variable is set to the current nesting level when you\nrun lf from a shell spawned inside lf.\nYou can add the value of this variable to your shell prompt to make it\nclear that your shell runs inside lf.\nFor example, with POSIX shells, you can use\n\\f[C][ -n \\[dq]$LF_LEVEL\\[dq] ] && PS1=\\[dq]$PS1\\[dq]\\[dq](lf level: $LF_LEVEL) \\[dq]\\f[R]\nin your shell configuration file (e.g.\n\\f[C]\\[ti]/.bashrc\\f[R]).\n.SS OPENER\n.PP\nIf this variable is set in the environment, use the same value.\nOtherwise, this is set to \\f[C]start\\f[R] in Windows, \\f[C]open\\f[R] in\nMacOS, \\f[C]xdg-open\\f[R] in others.\n.SS EDITOR\n.PP\nIf VISUAL is set in the environment, use its value.\nOtherwise, use the value of the environment variable EDITOR.\nIf neither variable is set, this is set to \\f[C]vi\\f[R] on Unix,\n\\f[C]notepad\\f[R] in Windows.\n.SS PAGER\n.PP\nIf this variable is set in the environment, use the same value.\nOtherwise, this is set to \\f[C]less\\f[R] on Unix, \\f[C]more\\f[R] in\nWindows.\n.SS SHELL\n.PP\nIf this variable is set in the environment, use the same value.\nOtherwise, this is set to \\f[C]sh\\f[R] on Unix, \\f[C]cmd\\f[R] in\nWindows.\n.SS lf\n.PP\nAbsolute path to the currently running lf binary, if it can be found.\nOtherwise, this is set to the string \\f[C]lf\\f[R].\n.SS lf_{option}\n.PP\nValue of the {option}.\n.SS lf_user_{option}\n.PP\nValue of the user_{option}.\n.SS lf_width, lf_height\n.PP\nWidth/Height of the terminal.\n.SS lf_count\n.PP\nValue of the count associated with the current command.\n.SS lf_mode\n.PP\nCurrent mode that \\f[C]lf\\f[R] is operating in.\nThis is useful for customizing keybindings depending on what the current\nmode is.\nPossible values are \\f[C]delete\\f[R], \\f[C]rename\\f[R],\n\\f[C]filter\\f[R], \\f[C]find\\f[R], \\f[C]mark\\f[R], \\f[C]search\\f[R],\n\\f[C]command\\f[R], \\f[C]shell\\f[R], \\f[C]pipe\\f[R] (when running a\nshell-pipe command), \\f[C]normal\\f[R], and \\f[C]unknown\\f[R].\n.SH SPECIAL COMMANDS\n.PP\nThis section shows information about special shell commands.\n.SS open\n.PP\nThis shell command can be defined to override the default \\f[C]open\\f[R]\ncommand when the current file is not a directory.\n.SS paste\n.PP\nThis shell command can be defined to override the default\n\\f[C]paste\\f[R] command.\n.SS rename\n.PP\nThis shell command can be defined to override the default\n\\f[C]rename\\f[R] command.\n.SS delete\n.PP\nThis shell command can be defined to override the default\n\\f[C]delete\\f[R] command.\n.SS pre-cd\n.PP\nThis shell command can be defined to be executed before changing a\ndirectory.\n.SS on-cd\n.PP\nThis shell command can be defined to be executed after changing a\ndirectory.\n.SS on-focus-gained\n.PP\nThis shell command can be defined to be executed when the terminal gains\nfocus.\n.SS on-focus-lost\n.PP\nThis shell command can be defined to be executed when the terminal loses\nfocus.\n.SS on-init\n.PP\nThis shell command can be defined to be executed after initializing and\nconnecting to the server.\n.SS on-select\n.PP\nThis shell command can be defined to be executed after the selection\nchanges.\n.SS on-redraw\n.PP\nThis shell command can be defined to be executed after the screen is\nredrawn or if the terminal is resized.\n.SS on-quit\n.PP\nThis shell command can be defined to be executed before quitting.\n.SH PREFIXES\n.PP\nThe following command prefixes are used by lf:\n.IP\n.nf\n\\f[C]\n:  read (default)  builtin/custom command\n$  shell           shell command\n%  shell-pipe      shell command running with the UI\n!  shell-wait      shell command waiting for a key press\n&  shell-async     shell command running asynchronously\n\\f[R]\n.fi\n.PP\nThe same evaluator is used for the command line and the configuration\nfile for reading shell commands.\nThe difference is that prefixes are not necessary in the command line.\nInstead, different modes are provided to read corresponding commands.\nThese modes are mapped to the prefix keys above by default.\n.SH SYNTAX\n.PP\nCharacters from \\f[C]#\\f[R] to newline are comments and ignored:\n.IP\n.nf\n\\f[C]\n# comments start with \\[ga]#\\[ga]\n\\f[R]\n.fi\n.PP\nThere are five special commands (\\f[C]set\\f[R], \\f[C]setlocal\\f[R],\n\\f[C]map\\f[R], \\f[C]cmap\\f[R], and \\f[C]cmd\\f[R]) for configuration.\n.PP\nCommand \\f[C]set\\f[R] is used to set an option which can be a boolean,\ninteger, or string:\n.IP\n.nf\n\\f[C]\nset hidden         # boolean enable\nset hidden true    # boolean enable\nset nohidden       # boolean disable\nset hidden false   # boolean disable\nset hidden!        # boolean toggle\nset scrolloff 10   # integer value\nset sortby time    # string value w/o quotes\nset sortby \\[aq]time\\[aq]  # string value with single quotes (whitespaces)\nset sortby \\[dq]time\\[dq]  # string value with double quotes (backslash escapes)\n\\f[R]\n.fi\n.PP\nCommand \\f[C]setlocal\\f[R] is used to set a local option for a directory\nwhich can be a boolean or string.\nCurrently supported local options are \\f[C]dirfirst\\f[R],\n\\f[C]dironly\\f[R], \\f[C]hidden\\f[R], \\f[C]info\\f[R], \\f[C]reverse\\f[R],\n\\f[C]sortby\\f[R] and \\f[C]locale\\f[R].\nAdding a trailing path separator (i.e.\n\\f[C]/\\f[R] for Unix and \\f[C]\\[rs]\\f[R] for Windows) sets the option\nfor the given directory along with its subdirectories:\n.IP\n.nf\n\\f[C]\nsetlocal /foo/bar hidden         # boolean enable\nsetlocal /foo/bar hidden true    # boolean enable\nsetlocal /foo/bar nohidden       # boolean disable\nsetlocal /foo/bar hidden false   # boolean disable\nsetlocal /foo/bar hidden!        # boolean toggle\nsetlocal /foo/bar sortby time    # string value w/o quotes\nsetlocal /foo/bar sortby \\[aq]time\\[aq]  # string value with single quotes (whitespaces)\nsetlocal /foo/bar sortby \\[dq]time\\[dq]  # string value with double quotes (backslash escapes)\nsetlocal /foo/bar  hidden        # for only \\[aq]/foo/bar\\[aq] directory\nsetlocal /foo/bar/ hidden        # for \\[aq]/foo/bar\\[aq] and its subdirectories (e.g. \\[aq]/foo/bar/baz\\[aq])\n\\f[R]\n.fi\n.PP\nCommand \\[aq]map\\[aq] is used to bind a key to a command which can be a\nbuiltin command, custom command, or shell command:\n.IP\n.nf\n\\f[C]\nmap gh cd \\[ti]        # builtin command\nmap D trash        # custom command\nmap i $less $f     # shell command\nmap U !du -csh *   # waiting shell command\n\\f[R]\n.fi\n.PP\nCommand \\[aq]cmap\\[aq] is used to bind a key on the command line to a\ncommand line command or any other command:\n.IP\n.nf\n\\f[C]\ncmap <c-g> cmd-escape\ncmap <a-i> set incsearch!\n\\f[R]\n.fi\n.PP\nYou can delete an existing binding by leaving the expression empty:\n.IP\n.nf\n\\f[C]\nmap gh             # deletes \\[aq]gh\\[aq] mapping\ncmap <c-g>         # deletes \\[aq]<c-g>\\[aq] mapping\n\\f[R]\n.fi\n.PP\nCommand \\f[C]cmd\\f[R] is used to define a custom command:\n.IP\n.nf\n\\f[C]\ncmd usage $du -h -d1 | less\n\\f[R]\n.fi\n.PP\nYou can delete an existing command by leaving the expression empty:\n.IP\n.nf\n\\f[C]\ncmd trash          # deletes \\[aq]trash\\[aq] command\n\\f[R]\n.fi\n.PP\nIf there is no prefix then \\f[C]:\\f[R] is assumed:\n.IP\n.nf\n\\f[C]\nmap zt set info time\n\\f[R]\n.fi\n.PP\nAn explicit \\f[C]:\\f[R] can be provided to group statements until a\nnewline which is especially useful for \\f[C]map\\f[R] and \\f[C]cmd\\f[R]\ncommands:\n.IP\n.nf\n\\f[C]\nmap st :set sortby time; set info time\n\\f[R]\n.fi\n.PP\nIf you need multiline you can wrap statements in \\f[C]{{\\f[R] and\n\\f[C]}}\\f[R] after the proper prefix.\n.IP\n.nf\n\\f[C]\nmap st :{{\n    set sortby time\n    set info time\n}}\n\\f[R]\n.fi\n.SH KEY MAPPINGS\n.PP\nRegular keys are assigned to a command with the usual syntax:\n.IP\n.nf\n\\f[C]\nmap a down\n\\f[R]\n.fi\n.PP\nKeys combined with the shift key simply use the uppercase letter:\n.IP\n.nf\n\\f[C]\nmap A down\n\\f[R]\n.fi\n.PP\nSpecial keys are written in between \\f[C]<\\f[R] and \\f[C]>\\f[R]\ncharacters and always use lowercase letters:\n.IP\n.nf\n\\f[C]\nmap <enter> down\n\\f[R]\n.fi\n.PP\nAngle brackets can be assigned with their special names:\n.IP\n.nf\n\\f[C]\nmap <lt> down\nmap <gt> down\n\\f[R]\n.fi\n.PP\nFunction keys are prefixed with \\f[C]f\\f[R] character:\n.IP\n.nf\n\\f[C]\nmap <f-1> down\n\\f[R]\n.fi\n.PP\nKeys combined with the control key are prefixed with a \\f[C]c\\f[R]\ncharacter:\n.IP\n.nf\n\\f[C]\nmap <c-a> down\n\\f[R]\n.fi\n.PP\nKeys combined with the alt key are assigned in two different ways\ndepending on the behavior of your terminal.\nOlder terminals (e.g.\nxterm) may set the 8th bit of a character when the alt key is pressed.\nOn these terminals, you can use the corresponding byte for the mapping:\n.IP\n.nf\n\\f[C]\nmap \\['a] down\n\\f[R]\n.fi\n.PP\nNewer terminals (e.g.\ngnome-terminal) may prefix the key with an escape key when the alt key\nis pressed.\nlf uses the escape delaying mechanism to recognize alt keys in these\nterminals (delay is 100ms).\nOn these terminals, keys combined with the alt key are prefixed with an\n\\f[C]a\\f[R] character:\n.IP\n.nf\n\\f[C]\nmap <a-a> down\n\\f[R]\n.fi\n.PP\nIt is possible to combine special keys with modifiers:\n.IP\n.nf\n\\f[C]\nmap <a-enter> down\n\\f[R]\n.fi\n.PP\nWARNING: Some key combinations will likely be intercepted by your OS,\nwindow manager, or terminal.\nOther key combinations cannot be recognized by lf due to the way\nterminals work (e.g.\n\\f[C]Ctrl+h\\f[R] combination sends a backspace key instead).\nThe easiest way to find out the name of a key combination and whether it\nwill work on your system is to press the key while lf is running and\nread the name from the \\f[C]unknown mapping\\f[R] error.\n.PP\nMouse buttons are prefixed with an \\f[C]m\\f[R] character:\n.IP\n.nf\n\\f[C]\nmap <m-1> down  # primary\nmap <m-2> down  # secondary\nmap <m-3> down  # middle\nmap <m-4> down\nmap <m-5> down\nmap <m-6> down\nmap <m-7> down\nmap <m-8> down\n\\f[R]\n.fi\n.PP\nMouse wheel events are also prefixed with an \\f[C]m\\f[R] character:\n.IP\n.nf\n\\f[C]\nmap <m-up>    down\nmap <m-down>  down\nmap <m-left>  down\nmap <m-right> down\n\\f[R]\n.fi\n.SH PUSH MAPPINGS\n.PP\nThe usual way to map a key sequence is to assign it to a named or\nunnamed command.\nWhile this provides a clean way to remap built-in keys as well as other\ncommands, it can be limiting at times.\nFor this reason, the \\f[C]push\\f[R] command is provided by lf.\nThis command is used to simulate key pushes given as its arguments.\nYou can \\f[C]map\\f[R] a key to a \\f[C]push\\f[R] command with an argument\nto create various keybindings.\n.PP\nThis is mainly useful for two purposes.\nFirst, it can be used to map a command with a command count:\n.IP\n.nf\n\\f[C]\nmap <c-j> push 10j\n\\f[R]\n.fi\n.PP\nSecond, it can be used to avoid typing the name when a command takes\narguments:\n.IP\n.nf\n\\f[C]\nmap r push :rename<space>\n\\f[R]\n.fi\n.PP\nOne thing to be careful of is that since the \\f[C]push\\f[R] command\nworks with keys instead of commands it is possible to accidentally\ncreate recursive bindings:\n.IP\n.nf\n\\f[C]\nmap j push 2j\n\\f[R]\n.fi\n.PP\nThese types of bindings create a deadlock when executed.\n.SH SHELL COMMANDS\n.PP\nRegular shell commands are the most basic command type that is useful\nfor many purposes.\nFor example, we can write a shell command to move the selected file(s)\nto trash.\nA first attempt to write such a command may look like this:\n.IP\n.nf\n\\f[C]\ncmd trash ${{\n    mkdir -p \\[ti]/.trash\n    if [ -z \\[dq]$fs\\[dq] ]; then\n        mv \\[dq]$f\\[dq] \\[ti]/.trash\n    else\n        IFS=\\[dq]$(printf \\[aq]\\[rs]n\\[rs]t\\[aq])\\[dq]; mv $fs \\[ti]/.trash\n    fi\n}}\n\\f[R]\n.fi\n.PP\nWe check \\f[C]$fs\\f[R] to see if there are any selected files.\nOtherwise, we just delete the current file.\nSince this is such a common pattern, a separate \\f[C]$fx\\f[R] variable\nis provided.\nWe can use this variable to get rid of the conditional:\n.IP\n.nf\n\\f[C]\ncmd trash ${{\n    mkdir -p \\[ti]/.trash\n    IFS=\\[dq]$(printf \\[aq]\\[rs]n\\[rs]t\\[aq])\\[dq]; mv $fx \\[ti]/.trash\n}}\n\\f[R]\n.fi\n.PP\nThe trash directory is checked each time the command is executed.\nWe can move it outside of the command so it would only run once at\nstartup:\n.IP\n.nf\n\\f[C]\n${{ mkdir -p \\[ti]/.trash }}\n\ncmd trash ${{ IFS=\\[dq]$(printf \\[aq]\\[rs]n\\[rs]t\\[aq])\\[dq]; mv $fx \\[ti]/.trash }}\n\\f[R]\n.fi\n.PP\nSince these are one-liners, we can drop \\f[C]{{\\f[R] and \\f[C]}}\\f[R]:\n.IP\n.nf\n\\f[C]\n$mkdir -p \\[ti]/.trash\n\ncmd trash $IFS=\\[dq]$(printf \\[aq]\\[rs]n\\[rs]t\\[aq])\\[dq]; mv $fx \\[ti]/.trash\n\\f[R]\n.fi\n.PP\nFinally, note that we set the \\f[C]IFS\\f[R] variable manually in these\ncommands.\nInstead, we could use the \\f[C]ifs\\f[R] option to set it for all shell\ncommands (i.e.\n\\f[C]set ifs \\[dq]\\[rs]n\\[dq]\\f[R]).\nThis can be especially useful for interactive use (e.g.\n\\f[C]$rm $f\\f[R] or \\f[C]$rm $fs\\f[R] would simply work).\nThis option is not set by default as it can behave unexpectedly for new\nusers.\nHowever, use of this option is highly recommended and it is assumed in\nthe rest of the documentation.\n.SH PIPING SHELL COMMANDS\n.PP\nRegular shell commands have some limitations in some cases.\nWhen an output or error message is given and the command exits\nafterwards, the ui is immediately resumed and there is no way to see the\nmessage without dropping to shell again.\nAlso, even when there is no output or error, the UI still needs to be\npaused while the command is running.\nThis can cause flickering on the screen for short commands and similar\ndistractions for longer commands.\n.PP\nInstead of pausing the UI, piping shell commands connect stdin, stdout,\nand stderr of the command to the statline at the bottom of the UI.\nThis can be useful for programs following the Unix philosophy to give no\noutput in the success case, and brief error messages or prompts in other\ncases.\n.PP\nFor example, following rename command prompts for overwrite in the\nstatline if there is an existing file with the given name:\n.IP\n.nf\n\\f[C]\ncmd rename %mv -i $f $1\n\\f[R]\n.fi\n.PP\nYou can also output error messages in the command and it will show up in\nthe statline.\nFor example, an alternative rename command may look like this:\n.IP\n.nf\n\\f[C]\ncmd rename %[ -e $1 ] && printf \\[dq]file exists\\[dq] || mv $f $1\n\\f[R]\n.fi\n.PP\nNote that input is line buffered and output and error are byte buffered.\n.SH WAITING SHELL COMMANDS\n.PP\nWaiting shell commands are similar to regular shell commands except that\nthey wait for a key press when the command is finished.\nThese can be useful to see the output of a program before the UI is\nresumed.\nWaiting shell commands are more appropriate than piping shell commands\nwhen the command is verbose and the output is best displayed as\nmultiline.\n.SH ASYNCHRONOUS SHELL COMMANDS\n.PP\nAsynchronous shell commands are used to start a command in the\nbackground and then resume operation without waiting for the command to\nfinish.\nStdin, stdout, and stderr of the command are neither connected to the\nterminal nor the UI.\n.SH REMOTE COMMANDS\n.PP\nOne of the more advanced features in lf is remote commands.\nAll clients connect to a server on startup.\nIt is possible to send commands to all or any of the connected clients\nover the common server.\nThis is used internally to notify file selection changes to other\nclients.\n.PP\nTo use this feature, you need to use a client which supports\ncommunicating with a Unix domain socket.\nOpenBSD implementation of netcat (nc) is one such example.\nYou can use it to send a command to the socket file:\n.IP\n.nf\n\\f[C]\necho \\[aq]send echo hello world\\[aq] | nc -U ${XDG_RUNTIME_DIR:-/tmp}/lf.${USER}.sock\n\\f[R]\n.fi\n.PP\nSince such a client may not be available everywhere, lf comes bundled\nwith a command line flag to be used as such.\nWhen using lf, you do not need to specify the address of the socket\nfile.\nThis is the recommended way of using remote commands since it is shorter\nand immune to socket file address changes:\n.IP\n.nf\n\\f[C]\nlf -remote \\[aq]send echo hello world\\[aq]\n\\f[R]\n.fi\n.PP\nIn this command \\f[C]send\\f[R] is used to send the rest of the string as\na command to all connected clients.\nYou can optionally give it an ID number to send a command to a single\nclient:\n.IP\n.nf\n\\f[C]\nlf -remote \\[aq]send 1234 echo hello world\\[aq]\n\\f[R]\n.fi\n.PP\nAll clients have a unique id number but you may not be aware of the id\nnumber when you are writing a command.\nFor this purpose, an \\f[C]$id\\f[R] variable is exported to the\nenvironment for shell commands.\nThe value of this variable is set to the process ID of the client.\nYou can use it to send a remote command from a client to the server\nwhich in return sends a command back to itself.\nSo now you can display a message in the current client by calling the\nfollowing in a shell command:\n.IP\n.nf\n\\f[C]\nlf -remote \\[dq]send $id echo hello world\\[dq]\n\\f[R]\n.fi\n.PP\nSince lf does not have control flow syntax, remote commands are used for\nsuch needs.\nFor example, you can configure the number of columns in the UI with\nrespect to the terminal width as follows:\n.IP\n.nf\n\\f[C]\ncmd recol %{{\n    if [ $lf_width -le 80 ]; then\n        lf -remote \\[dq]send $id set ratios 1:2\\[dq]\n    elif [ $lf_width -le 160 ]; then\n        lf -remote \\[dq]send $id set ratios 1:2:3\\[dq]\n    else\n        lf -remote \\[dq]send $id set ratios 1:2:3:5\\[dq]\n    fi\n}}\n\\f[R]\n.fi\n.PP\nIn addition, the \\f[C]query\\f[R] command can be used to obtain\ninformation about a specific lf instance by providing its id:\n.IP\n.nf\n\\f[C]\nlf -remote \\[dq]query $id maps\\[dq]\n\\f[R]\n.fi\n.PP\nThe following types of information are supported:\n.IP\n.nf\n\\f[C]\nmaps     list of mappings created by the \\[aq]map\\[aq] command\ncmaps    list of mappings created by the \\[aq]cmap\\[aq] command\ncmds     list of commands created by the \\[aq]cmd\\[aq] command\njumps    contents of the jump list, showing previously visited locations\nhistory  list of previously executed commands on the command line\n\\f[R]\n.fi\n.PP\nThis is useful for scripting actions based on the internal state of lf.\nFor example, to select a previous command using fzf and execute it:\n.IP\n.nf\n\\f[C]\nmap <a-h> ${{\n    clear\n    cmd=$(\n        lf -remote \\[dq]query $id history\\[dq] |\n        awk -F\\[aq]\\[rs]t\\[aq] \\[aq]NR > 1 { print $NF}\\[aq] |\n        sort -u |\n        fzf --reverse --prompt=\\[aq]Execute command: \\[aq]\n    )\n    lf -remote \\[dq]send $id $cmd\\[dq]\n}}\n\\f[R]\n.fi\n.PP\nThere is also a \\f[C]quit\\f[R] command to quit the server when there are\nno connected clients left, and a \\f[C]quit!\\f[R] command to force quit\nthe server by closing client connections first:\n.IP\n.nf\n\\f[C]\nlf -remote \\[aq]quit\\[aq]\nlf -remote \\[aq]quit!\\[aq]\n\\f[R]\n.fi\n.PP\nLastly, there is a \\f[C]conn\\f[R] command to connect the server to a\nclient.\nThis should not be needed for users.\n.SH FILE OPERATIONS\n.PP\nlf uses its own built-in copy and move operations by default.\nThese are implemented as asynchronous operations and progress is shown\nin the bottom ruler.\nThese commands do not overwrite existing files or directories with the\nsame name.\nInstead, a suffix that is compatible with the\n\\f[C]--backup=numbered\\f[R] option in GNU cp is added to the new files\nor directories.\nOnly file modes and (some) timestamps can be preserved (see\n\\f[C]preserve\\f[R] option), all other attributes are ignored including\nownership, context, and xattr.\nSpecial files such as character and block devices, named pipes, and\nsockets are skipped and links are not followed.\nMoving is performed using the rename operation of the underlying OS.\nFor cross-device moving, lf falls back to copying and then deletes the\noriginal files if there are no errors.\nOperation errors are shown in the message line as well as the log file\nand they do not preemptively finish the corresponding file operation.\n.PP\nFile operations can be performed on the currently selected file or on\nmultiple files by selecting them first.\nWhen you \\f[C]copy\\f[R] a file, lf doesn\\[aq]t actually copy the file on\nthe disk, but only records its name to a file.\nThe actual file copying takes place when you \\f[C]paste\\f[R].\nSimilarly \\f[C]paste\\f[R] after a \\f[C]cut\\f[R] operation moves the\nfile.\n.PP\nYou can customize copy and move operations by defining a \\f[C]paste\\f[R]\ncommand.\nThis is a special command that is called when it is defined instead of\nthe built-in implementation.\nYou can use the following example as a starting point:\n.IP\n.nf\n\\f[C]\ncmd paste %{{\n    load=$(cat \\[ti]/.local/share/lf/files)\n    mode=$(echo \\[dq]$load\\[dq] | sed -n \\[aq]1p\\[aq])\n    list=$(echo \\[dq]$load\\[dq] | sed \\[aq]1d\\[aq])\n    if [ $mode = \\[aq]copy\\[aq] ]; then\n        cp -R $list .\n    elif [ $mode = \\[aq]move\\[aq] ]; then\n        mv $list .\n        rm \\[ti]/.local/share/lf/files\n        lf -remote \\[aq]send clear\\[aq]\n    fi\n}}\n\\f[R]\n.fi\n.PP\nSome useful things to be considered are to use the backup\n(\\f[C]--backup\\f[R]) and/or preserve attributes (\\f[C]-a\\f[R]) options\nwith \\f[C]cp\\f[R] and \\f[C]mv\\f[R] commands if they support it (i.e.\nGNU implementation), change the command type to asynchronous, or use\n\\f[C]rsync\\f[R] command with progress bar option for copying and feed\nthe progress to the client periodically with remote \\f[C]echo\\f[R]\ncalls.\n.PP\nBy default, lf does not assign \\f[C]delete\\f[R] command to a key to\nprotect new users.\nYou can customize file deletion by defining a \\f[C]delete\\f[R] command.\nYou can also assign a key to this command if you like.\nAn example command to move selected files to a trash folder and remove\nfiles completely after a prompt is provided in the example configuration\nfile.\n.SH SEARCHING FILES\n.PP\nThere are two mechanisms implemented in lf to search a file in the\ncurrent directory.\nSearching is the traditional method to move the selection to a file\nmatching a given pattern.\nFinding is an alternative way to search for a pattern possibly using\nfewer keystrokes.\n.PP\nThe searching mechanism is implemented with commands \\f[C]search\\f[R]\n(default \\f[C]/\\f[R]), \\f[C]search-back\\f[R] (default \\f[C]?\\f[R]),\n\\f[C]search-next\\f[R] (default \\f[C]n\\f[R]), and \\f[C]search-prev\\f[R]\n(default \\f[C]N\\f[R]).\nYou can enable \\f[C]globsearch\\f[R] option to match with a glob pattern.\nGlobbing supports \\f[C]*\\f[R] to match any sequence, \\f[C]?\\f[R] to\nmatch any character, and \\f[C][...]\\f[R] or \\f[C][\\[ha]...]\\f[R] to\nmatch character sets or ranges.\nYou can enable \\f[C]incsearch\\f[R] option to jump to the current match\nat each keystroke while typing.\nIn this mode, you can either use \\f[C]cmd-enter\\f[R] to accept the\nsearch or use \\f[C]cmd-escape\\f[R] to cancel the search.\nYou can also map some other commands with \\f[C]cmap\\f[R] to accept the\nsearch and execute the command immediately afterwards.\nFor example, you can use the right arrow key to finish the search and\nopen the selected file with the following mapping:\n.IP\n.nf\n\\f[C]\ncmap <right> :cmd-enter; open\n\\f[R]\n.fi\n.PP\nThe finding mechanism is implemented with commands \\f[C]find\\f[R]\n(default \\f[C]f\\f[R]), \\f[C]find-back\\f[R] (default \\f[C]F\\f[R]),\n\\f[C]find-next\\f[R] (default \\f[C];\\f[R]), \\f[C]find-prev\\f[R] (default\n\\f[C],\\f[R]).\nYou can disable \\f[C]anchorfind\\f[R] option to match a pattern at an\narbitrary position in the filename instead of the beginning.\nYou can set the number of keys to match using \\f[C]findlen\\f[R] option.\nIf you set this value to zero, then the keys are read until there is\nonly a single match.\nThe default values of these two options are set to jump to the first\nfile with the given initial.\n.PP\nSome options effect both searching and finding.\nYou can disable \\f[C]wrapscan\\f[R] option to prevent searches from being\nwrapped around at the end of the file list.\nYou can disable \\f[C]ignorecase\\f[R] option to match cases in the\npattern and the filename.\nThis option is already automatically overridden if the pattern contains\nupper-case characters.\nYou can disable \\f[C]smartcase\\f[R] option to disable this behavior.\nTwo similar options \\f[C]ignoredia\\f[R] and \\f[C]smartdia\\f[R] are\nprovided to control matching diacritics in Latin letters.\n.SH OPENING FILES\n.PP\nYou can define an \\f[C]open\\f[R] command (default \\f[C]l\\f[R] and\n\\f[C]<right>\\f[R]) to configure file opening.\nThis command is only called when the current file is not a directory,\notherwise, the directory is entered instead.\nYou can define it just as you would define any other command:\n.IP\n.nf\n\\f[C]\ncmd open $vi $fx\n\\f[R]\n.fi\n.PP\nIt is possible to use different command types:\n.IP\n.nf\n\\f[C]\ncmd open &xdg-open $f\n\\f[R]\n.fi\n.PP\nYou may want to use either file extensions or mime types from\n\\f[C]file\\f[R] command:\n.IP\n.nf\n\\f[C]\ncmd open ${{\n    case $(file --mime-type -Lb $f) in\n        text/*) vi $fx;;\n        *) for f in $fx; do xdg-open $f > /dev/null 2> /dev/null & done;;\n    esac\n}}\n\\f[R]\n.fi\n.PP\nYou may want to use \\f[C]setsid\\f[R] before your opener command to have\npersistent processes that continue to run after lf quits.\n.PP\nRegular shell commands (i.e.\n\\f[C]$\\f[R]) drop to the terminal which results in a flicker for\ncommands that finish immediately (e.g.\n\\f[C]xdg-open\\f[R] in the above example).\nIf you want to use asynchronous shell commands (i.e.\n\\f[C]&\\f[R]) but also want to use the terminal when necessary (e.g.\n\\f[C]vi\\f[R] in the above example), you can use a remote command:\n.IP\n.nf\n\\f[C]\ncmd open &{{\n    case $(file --mime-type -Lb $f) in\n        text/*) lf -remote \\[dq]send $id \\[rs]$vi \\[rs]$fx\\[dq];;\n        *) for f in $fx; do xdg-open $f > /dev/null 2> /dev/null & done;;\n    esac\n}}\n\\f[R]\n.fi\n.PP\nNote that asynchronous shell commands run in their own process group by\ndefault so they do not require the manual use of \\f[C]setsid\\f[R].\n.PP\nThe following command is provided by default:\n.IP\n.nf\n\\f[C]\ncmd open &$OPENER $f\n\\f[R]\n.fi\n.PP\nYou may also use any other existing file openers as you like.\nPossible options are \\f[C]libfile-mimeinfo-perl\\f[R] (executable name is\n\\f[C]mimeopen\\f[R]), \\f[C]rifle\\f[R] (ranger\\[aq]s default file opener),\nor \\f[C]mimeo\\f[R] to name a few.\n.SH PREVIEWING FILES\n.PP\nlf previews files on the preview pane by printing the file until the end\nor until the preview pane is filled.\nThis output can be enhanced by providing a custom preview script for\nfiltering.\nThis can be used to highlight source codes, list contents of archive\nfiles or view PDF or image files to name a few.\nFor coloring lf recognizes ANSI escape codes.\n.PP\nTo use this feature, you need to set the value of \\f[C]previewer\\f[R]\noption to the path of an executable file.\nFive arguments are passed to the file, (1) current file name, (2) width,\n(3) height, (4) horizontal position, and (5) vertical position of\npreview pane respectively.\nThe output of the execution is printed in the preview pane.\nYou may also want to use the same script in your pager mapping as well:\n.IP\n.nf\n\\f[C]\nset previewer \\[ti]/.config/lf/pv.sh\nmap i $\\[ti]/.config/lf/pv.sh $f | less -R\n\\f[R]\n.fi\n.PP\nFor \\f[C]less\\f[R] pager, you may instead utilize \\f[C]LESSOPEN\\f[R]\nmechanism so that useful information about the file such as the full\npath of the file can still be displayed in the statusline below:\n.IP\n.nf\n\\f[C]\nset previewer \\[ti]/.config/lf/pv.sh\nmap i $LESSOPEN=\\[aq]| \\[ti]/.config/lf/pv.sh %s\\[aq] less -R $f\n\\f[R]\n.fi\n.PP\nSince this script is called for each file selection change it needs to\nbe as efficient as possible and this responsibility is left to the user.\nYou may use file extensions to determine the type of file more\nefficiently compared to obtaining mime types from \\f[C]file\\f[R]\ncommand.\nExtensions can then be used to match cleanly within a conditional:\n.IP\n.nf\n\\f[C]\n#!/bin/sh\n\ncase \\[dq]$1\\[dq] in\n    *.tar*) tar tf \\[dq]$1\\[dq];;\n    *.zip) unzip -l \\[dq]$1\\[dq];;\n    *.rar) unrar l \\[dq]$1\\[dq];;\n    *.7z) 7z l \\[dq]$1\\[dq];;\n    *.pdf) pdftotext \\[dq]$1\\[dq] -;;\n    *) highlight -O ansi \\[dq]$1\\[dq];;\nesac\n\\f[R]\n.fi\n.PP\nAnother important consideration for efficiency is the use of programs\nwith short startup times for preview.\nFor this reason, \\f[C]highlight\\f[R] is recommended over\n\\f[C]pygmentize\\f[R] for syntax highlighting.\nBesides, it is also important that the application processes the file on\nthe fly rather than first reading it to the memory and then doing the\nprocessing afterwards.\nThis is especially relevant for big files.\nlf automatically closes the previewer script output pipe with a SIGPIPE\nwhen enough lines are read.\nWhen everything else fails, you can make use of the height argument to\nonly feed the first portion of the file to a program for preview.\nNote that some programs may not respond well to SIGPIPE to exit with a\nnon-zero return code and avoid caching.\nYou may add a trailing \\f[C]|| true\\f[R] command to avoid such errors:\n.IP\n.nf\n\\f[C]\nhighlight -O ansi \\[dq]$1\\[dq] || true\n\\f[R]\n.fi\n.PP\nYou may also use an existing preview filter as you like.\nYour system may already come with a preview filter named\n\\f[C]lesspipe\\f[R].\nThese filters may have a mechanism to add user customizations as well.\nSee the related documentation for more information.\n.SH CHANGING DIRECTORY\n.PP\nlf changes the working directory of the process to the current directory\nso that shell commands always work in the displayed directory.\nAfter quitting, it returns to the original directory where it is first\nlaunched like all shell programs.\nIf you want to stay in the current directory after quitting, you can use\none of the example lfcd wrapper shell scripts provided in the repository\nat <https://github.com/gokcehan/lf/tree/master/etc>\n.PP\nThere is a special command \\f[C]on-cd\\f[R] that runs a shell command\nwhen it is defined and the directory is changed.\nYou can define it just as you would define any other command:\n.IP\n.nf\n\\f[C]\ncmd on-cd &{{\n    bash -c \\[aq]\n    # display git repository status in your prompt\n    source /usr/share/git/completion/git-prompt.sh\n    GIT_PS1_SHOWDIRTYSTATE=auto\n    GIT_PS1_SHOWSTASHSTATE=auto\n    GIT_PS1_SHOWUNTRACKEDFILES=auto\n    GIT_PS1_SHOWUPSTREAM=auto\n    git=$(__git_ps1 \\[dq] (%s)\\[dq])\n    fmt=\\[dq]\\[rs]033[32;1m%u\\[at]%h\\[rs]033[0m:\\[rs]033[34;1m%d\\[rs]033[0m\\[rs]033[1m%f$git\\[rs]033[0m\\[dq]\n    lf -remote \\[dq]send $id set promptfmt \\[rs]\\[dq]$fmt\\[rs]\\[dq]\\[dq]\n    \\[aq]\n}}\n\\f[R]\n.fi\n.PP\nIf you want to print escape sequences, you may redirect \\f[C]printf\\f[R]\noutput to \\f[C]/dev/tty\\f[R].\nThe following xterm-specific escape sequence sets the terminal title to\nthe working directory:\n.IP\n.nf\n\\f[C]\ncmd on-cd &{{\n    printf \\[dq]\\[rs]033]0; $PWD\\[rs]007\\[dq] > /dev/tty\n}}\n\\f[R]\n.fi\n.PP\nThis command runs whenever you change the directory but not on startup.\nYou can add an extra call to make it run on startup as well:\n.IP\n.nf\n\\f[C]\ncmd on-cd &{{ ... }}\non-cd\n\\f[R]\n.fi\n.PP\nNote that all shell commands are possible but \\f[C]%\\f[R] and\n\\f[C]&\\f[R] are usually more appropriate as \\f[C]$\\f[R] and \\f[C]!\\f[R]\ncauses flickers and pauses respectively.\n.PP\nThere is also a \\f[C]pre-cd\\f[R] command, that works like\n\\f[C]on-cd\\f[R], but is run before the directory is actually changed.\n.SH COLORS\n.PP\nlf tries to automatically adapt its colors to the environment.\nIt starts with a default color scheme and updates colors using values of\nexisting environment variables possibly by overwriting its previous\nvalues.\nColors are set in the following order:\n.IP \"1.\" 3\ndefault\n.IP \"2.\" 3\nLSCOLORS (Mac/BSD ls)\n.IP \"3.\" 3\nLS_COLORS (GNU ls)\n.IP \"4.\" 3\nLF_COLORS (lf specific)\n.IP \"5.\" 3\ncolors file (lf specific)\n.PP\nPlease refer to the corresponding man pages for more information about\n\\f[C]LSCOLORS\\f[R] and \\f[C]LS_COLORS\\f[R].\n\\f[C]LF_COLORS\\f[R] is provided with the same syntax as\n\\f[C]LS_COLORS\\f[R] in case you want to configure colors only for lf but\nnot ls.\nThis can be useful since there are some differences between ls and lf,\nthough one should expect the same behavior for common cases.\nThe colors file (refer to the CONFIGURATION\nsection (https://github.com/gokcehan/lf/blob/master/doc.md#configuration))\nis provided for easier configuration without environment variables.\nThis file should consist of whitespace-separated pairs with a\n\\f[C]#\\f[R] character to start comments until the end of the line.\n.PP\nYou can configure lf colors in two different ways.\nFirst, you can only configure 8 basic colors used by your terminal and\nlf should pick up those colors automatically.\nDepending on your terminal, you should be able to select your colors\nfrom a 24-bit palette.\nThis is the recommended approach as colors used by other programs will\nalso match each other.\n.PP\nSecond, you can set the values of environment variables or colors file\nmentioned above for fine-grained customization.\nNote that \\f[C]LS_COLORS/LF_COLORS\\f[R] are more powerful than\n\\f[C]LSCOLORS\\f[R] and they can be used even when GNU programs are not\ninstalled on the system.\nYou can combine this second method with the first method for the best\nresults.\n.PP\nLastly, you may also want to configure the colors of the prompt line to\nmatch the rest of the colors.\nColors of the prompt line can be configured using the\n\\f[C]promptfmt\\f[R] option which can include hardcoded colors as ANSI\nescapes.\nSee the default value of this option to have an idea about how to color\nthis line.\n.PP\nIt is worth noting that lf uses as many colors advertised by your\nterminal\\[aq]s entry in terminfo or infocmp databases on your system.\nIf an entry is not present, it falls back to an internal database.\nIf your terminal supports 24-bit colors but either does not have a\ndatabase entry or does not advertise all capabilities, you can enable\nsupport by setting the \\f[C]$COLORTERM\\f[R] variable to\n\\f[C]truecolor\\f[R] or ensuring \\f[C]$TERM\\f[R] is set to a value that\nends with \\f[C]-truecolor\\f[R].\n.PP\nDefault lf colors are mostly taken from GNU dircolors defaults.\nThese defaults use 8 basic colors and bold attribute.\nDefault dircolors entries with background colors are simplified to avoid\nconfusion with current file selection in lf.\nSimilarly, there are only file type matchings and extension matchings\nare left out for simplicity.\nDefault values are as follows given with their matching order in lf:\n.IP\n.nf\n\\f[C]\nln  01;36\nor  31;01\ntw  01;34\now  01;34\nst  01;34\ndi  01;34\npi  33\nso  01;35\nbd  33;01\ncd  33;01\nsu  01;32\nsg  01;32\nex  01;32\nfi  00\n\\f[R]\n.fi\n.PP\nNote that lf first tries matching file names and then falls back to file\ntypes.\nThe full order of matchings from most specific to least are as follows:\n.IP \"1.\" 3\nFull Path (e.g.\n\\f[C]\\[ti]/.config/lf/lfrc\\f[R])\n.IP \"2.\" 3\nDir Name (e.g.\n\\f[C].git/\\f[R]) (only matches dirs with a trailing slash at the end)\n.IP \"3.\" 3\nFile Type (e.g.\n\\f[C]ln\\f[R]) (except \\f[C]fi\\f[R])\n.IP \"4.\" 3\nFile Name (e.g.\n\\f[C]README*\\f[R])\n.IP \"5.\" 3\nFile Name (e.g.\n\\f[C]*README\\f[R])\n.IP \"6.\" 3\nBase Name (e.g.\n\\f[C]README.*\\f[R])\n.IP \"7.\" 3\nExtension (e.g.\n\\f[C]*.txt\\f[R])\n.IP \"8.\" 3\nDefault (i.e.\n\\f[C]fi\\f[R])\n.PP\nFor example, given a regular text file \\f[C]/path/to/README.txt\\f[R],\nthe following entries are checked in the configuration and the first one\nto match is used:\n.IP \"1.\" 3\n\\f[C]/path/to/README.txt\\f[R]\n.IP \"2.\" 3\n(skipped since the file is not a directory)\n.IP \"3.\" 3\n(skipped since the file is of type \\f[C]fi\\f[R])\n.IP \"4.\" 3\n\\f[C]README.txt*\\f[R]\n.IP \"5.\" 3\n\\f[C]*README.txt\\f[R]\n.IP \"6.\" 3\n\\f[C]README.*\\f[R]\n.IP \"7.\" 3\n\\f[C]*.txt\\f[R]\n.IP \"8.\" 3\n\\f[C]fi\\f[R]\n.PP\nGiven a regular directory \\f[C]/path/to/example.d\\f[R], the following\nentries are checked in the configuration and the first one to match is\nused:\n.IP \"1.\" 3\n\\f[C]/path/to/example.d\\f[R]\n.IP \"2.\" 3\n\\f[C]example.d/\\f[R]\n.IP \"3.\" 3\n\\f[C]di\\f[R]\n.IP \"4.\" 3\n\\f[C]example.d*\\f[R]\n.IP \"5.\" 3\n\\f[C]*example.d\\f[R]\n.IP \"6.\" 3\n\\f[C]example.*\\f[R]\n.IP \"7.\" 3\n\\f[C]*.d\\f[R]\n.IP \"8.\" 3\n\\f[C]fi\\f[R]\n.PP\nNote that glob-like patterns do not perform glob matching for\nperformance reasons.\n.PP\nFor example, you can set a variable as follows:\n.IP\n.nf\n\\f[C]\nexport LF_COLORS=\\[dq]\\[ti]/Documents=01;31:\\[ti]/Downloads=01;31:\\[ti]/.local/share=01;31:\\[ti]/.config/lf/lfrc=31:.git/=01;32:.git*=32:*.gitignore=32:*Makefile=32:README.*=33:*.txt=34:*.md=34:ln=01;36:di=01;34:ex=01;32:\\[dq]\n\\f[R]\n.fi\n.PP\nHaving all entries on a single line can make it hard to read.\nYou may instead divide it into multiple lines in between double quotes\nby escaping newlines with backslashes as follows:\n.IP\n.nf\n\\f[C]\nexport LF_COLORS=\\[dq]\\[rs]\n\\[ti]/Documents=01;31:\\[rs]\n\\[ti]/Downloads=01;31:\\[rs]\n\\[ti]/.local/share=01;31:\\[rs]\n\\[ti]/.config/lf/lfrc=31:\\[rs]\n\\&.git/=01;32:\\[rs]\n\\&.git*=32:\\[rs]\n*.gitignore=32:\\[rs]\n*Makefile=32:\\[rs]\nREADME.*=33:\\[rs]\n*.txt=34:\\[rs]\n*.md=34:\\[rs]\nln=01;36:\\[rs]\ndi=01;34:\\[rs]\nex=01;32:\\[rs]\n\\[dq]\n\\f[R]\n.fi\n.PP\nThe \\f[C]ln\\f[R] entry supports the special value \\f[C]target\\f[R],\nwhich will use the link target to select a style.\nFile name rules will still apply based on the link\\[aq]s name -- this\nmirrors GNU\\[aq]s \\f[C]ls\\f[R] and \\f[C]dircolors\\f[R] behavior.\nHaving such a long variable definition in a shell configuration file\nmight be undesirable.\nYou may instead use the colors file (refer to the CONFIGURATION\nsection (https://github.com/gokcehan/lf/blob/master/doc.md#configuration))\nfor configuration.\nA sample colors file can be found at\n<https://github.com/gokcehan/lf/blob/master/etc/colors.example> You may\nalso see the wiki page for ANSI escape codes\n<https://en.wikipedia.org/wiki/ANSI_escape_code>\n.SH ICONS\n.PP\nIcons are configured using \\f[C]LF_ICONS\\f[R] environment variable or an\nicons file (refer to the CONFIGURATION\nsection (https://github.com/gokcehan/lf/blob/master/doc.md#configuration)).\nThe variable uses the same syntax as \\f[C]LS_COLORS/LF_COLORS\\f[R].\nInstead of colors, you should put a single characters as values of\nentries.\nThe \\f[C]ln\\f[R] entry supports the special value \\f[C]target\\f[R],\nwhich will use the link target to select a icon.\nFile name rules will still apply based on the link\\[aq]s name -- this\nmirrors GNU\\[aq]s \\f[C]ls\\f[R] and \\f[C]dircolors\\f[R] behavior.\nThe icons file (refer to the CONFIGURATION\nsection (https://github.com/gokcehan/lf/blob/master/doc.md#configuration))\nshould consist of whitespace-separated arrays with a \\f[C]#\\f[R]\ncharacter to start comments until the end of the line.\nEach line should contain 1-3 columns, first column is filetype or\nfilename pattern, second column is the icon, third column is an optional\nicon color.\nIf there is only one column, means to disable rule for this filetype or\npattern.\nDo not forget to add \\f[C]set icons true\\f[R] to your \\f[C]lfrc\\f[R] to\nsee the icons.\nDefault values are as follows given with their matching order in lf:\n.IP\n.nf\n\\f[C]\nln  l\nor  l\ntw  t\now  d\nst  t\ndi  d\npi  p\nso  s\nbd  b\ncd  c\nsu  u\nsg  g\nex  x\nfi  -\n\\f[R]\n.fi\n.PP\nA sample icons file can be found at\n<https://github.com/gokcehan/lf/blob/master/etc/icons.example>\n.PP\nA sample colored icons file can be found at\n<https://github.com/gokcehan/lf/blob/master/etc/icons_colored.example>\n"
        },
        {
          "name": "lf.desktop",
          "type": "blob",
          "size": 0.197265625,
          "content": "[Desktop Entry]\nType=Application\nName=lf\nComment=Launches the lf file manager\nIcon=utilities-terminal\nTerminal=true\nExec=lf\nCategories=ConsoleOnly;System;FileTools;FileManager\nMimeType=inode/directory;\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 7.0966796875,
          "content": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"runtime/debug\"\n\t\"runtime/pprof\"\n\t\"strconv\"\n\t\"strings\"\n\n\t_ \"embed\"\n)\n\n//go:embed doc.txt\nvar genDocString string\n\nvar (\n\tenvPath  = os.Getenv(\"PATH\")\n\tenvLevel = os.Getenv(\"LF_LEVEL\")\n)\n\ntype arrayFlag []string\n\nvar (\n\tgSingleMode     bool\n\tgPrintLastDir   bool\n\tgPrintSelection bool\n\tgClientID       int\n\tgHostname       string\n\tgLastDirPath    string\n\tgSelectionPath  string\n\tgSocketProt     string\n\tgSocketPath     string\n\tgLogPath        string\n\tgSelect         string\n\tgConfigPath     string\n\tgCommands       arrayFlag\n\tgVersion        string\n)\n\nfunc (a *arrayFlag) Set(v string) error {\n\t*a = append(*a, v)\n\treturn nil\n}\n\nfunc (a *arrayFlag) String() string {\n\treturn strings.Join(*a, \", \")\n}\n\nfunc init() {\n\th, err := os.Hostname()\n\tif err != nil {\n\t\tlog.Printf(\"hostname: %s\", err)\n\t}\n\tgHostname = h\n\n\tif envLevel == \"\" {\n\t\tenvLevel = \"0\"\n\t}\n}\n\nfunc exportEnvVars() {\n\tos.Setenv(\"id\", strconv.Itoa(gClientID))\n\n\tos.Setenv(\"OPENER\", envOpener)\n\tos.Setenv(\"EDITOR\", envEditor)\n\tos.Setenv(\"PAGER\", envPager)\n\tos.Setenv(\"SHELL\", envShell)\n\n\tdir, err := os.Getwd()\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"getting current directory: %s\\n\", err)\n\t}\n\tos.Setenv(\"OLDPWD\", dir)\n\n\tlevel, err := strconv.Atoi(envLevel)\n\tif err != nil {\n\t\tlog.Printf(\"reading lf level: %s\", err)\n\t}\n\n\tlevel++\n\n\tos.Setenv(\"LF_LEVEL\", strconv.Itoa(level))\n\n\tlfPath, err := os.Executable()\n\tif err != nil {\n\t\tlog.Printf(\"getting path to lf binary: %s\", err)\n\t\tlfPath = \"lf\"\n\t}\n\tos.Setenv(\"lf\", quoteString(lfPath))\n}\n\n// used by exportOpts below\nfunc fieldToString(field reflect.Value) string {\n\tkind := field.Kind()\n\tvar value string\n\n\tswitch kind {\n\tcase reflect.Int:\n\t\tvalue = strconv.Itoa(int(field.Int()))\n\tcase reflect.Bool:\n\t\tvalue = strconv.FormatBool(field.Bool())\n\tcase reflect.Slice:\n\t\tfor i := 0; i < field.Len(); i++ {\n\t\t\telement := field.Index(i)\n\n\t\t\tif i == 0 {\n\t\t\t\tvalue = fieldToString(element)\n\t\t\t} else {\n\t\t\t\tvalue += \":\" + fieldToString(element)\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tvalue = field.String()\n\t}\n\n\treturn value\n}\n\nfunc getOptsMap() map[string]string {\n\topts := make(map[string]string)\n\tv := reflect.ValueOf(gOpts)\n\tt := v.Type()\n\n\tfor i := 0; i < v.NumField(); i++ {\n\t\t// Get field name and prefix it with lf_\n\t\tname := \"lf_\" + t.Field(i).Name\n\n\t\t// Skip maps\n\t\tif name == \"lf_keys\" || name == \"lf_cmdkeys\" || name == \"lf_cmds\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif name == \"lf_user\" {\n\t\t\t// set each user option\n\t\t\tfor key, value := range gOpts.user {\n\t\t\t\topts[name+\"_\"+key] = value\n\t\t\t}\n\t\t} else {\n\t\t\topts[name] = fieldToString(v.Field(i))\n\t\t}\n\t}\n\n\treturn opts\n}\n\nfunc exportOpts() {\n\tfor key, value := range getOptsMap() {\n\t\tos.Setenv(key, value)\n\t}\n}\n\nfunc startServer() {\n\tcmd := detachedCommand(os.Args[0], \"-server\")\n\tif err := cmd.Start(); err != nil {\n\t\tlog.Printf(\"starting server: %s\", err)\n\t}\n}\n\nfunc checkServer() {\n\tif gSocketProt == \"unix\" {\n\t\tif _, err := os.Stat(gSocketPath); os.IsNotExist(err) {\n\t\t\tstartServer()\n\t\t} else if _, err := net.Dial(gSocketProt, gSocketPath); err != nil {\n\t\t\tos.Remove(gSocketPath)\n\t\t\tstartServer()\n\t\t}\n\t} else {\n\t\tif _, err := net.Dial(gSocketProt, gSocketPath); err != nil {\n\t\t\tstartServer()\n\t\t}\n\t}\n}\n\nfunc printVersion() {\n\tif gVersion != \"\" {\n\t\tfmt.Println(gVersion)\n\t\treturn\n\t}\n\n\tbuildInfo, ok := debug.ReadBuildInfo()\n\tif !ok {\n\t\treturn\n\t}\n\n\tvar vcsRevision, vcsTime, vcsModified string\n\tfor _, setting := range buildInfo.Settings {\n\t\tswitch setting.Key {\n\t\tcase \"vcs.revision\":\n\t\t\tvcsRevision = setting.Value\n\t\tcase \"vcs.time\":\n\t\t\tvcsTime = setting.Value\n\t\tcase \"vcs.modified\":\n\t\t\tif setting.Value == \"true\" {\n\t\t\t\tvcsModified = \" (dirty)\"\n\t\t\t}\n\t\t}\n\t}\n\n\tif vcsRevision != \"\" {\n\t\tfmt.Printf(\"Built at commit: %s%s %s\\n\", vcsRevision, vcsModified, vcsTime)\n\t}\n\tfmt.Printf(\"Go version: %s\\n\", buildInfo.GoVersion)\n}\n\nfunc main() {\n\tflag.Usage = func() {\n\t\tf := flag.CommandLine.Output()\n\t\tfmt.Fprintln(f, \"lf - Terminal file manager\")\n\t\tfmt.Fprintln(f, \"\")\n\t\tfmt.Fprintf(f, \"Usage:  %s [options] [cd-or-select-path]\\n\\n\", os.Args[0])\n\t\tfmt.Fprintln(f, \"  cd-or-select-path\")\n\t\tfmt.Fprintln(f, \"        set the initial dir or file selection to the given argument\")\n\t\tfmt.Fprintln(f, \"\")\n\t\tfmt.Fprintln(f, \"Options:\")\n\t\tflag.PrintDefaults()\n\t}\n\n\tshowDoc := flag.Bool(\n\t\t\"doc\",\n\t\tfalse,\n\t\t\"show documentation\")\n\n\tshowVersion := flag.Bool(\n\t\t\"version\",\n\t\tfalse,\n\t\t\"show version\")\n\n\tserverMode := flag.Bool(\n\t\t\"server\",\n\t\tfalse,\n\t\t\"start server (automatic)\")\n\n\tsingleMode := flag.Bool(\n\t\t\"single\",\n\t\tfalse,\n\t\t\"start a client without server\")\n\n\tprintLastDir := flag.Bool(\n\t\t\"print-last-dir\",\n\t\tfalse,\n\t\t\"print the last dir to stdout on exit (to use for cd)\")\n\n\tprintSelection := flag.Bool(\n\t\t\"print-selection\",\n\t\tfalse,\n\t\t\"print the selected files to stdout on open (to use as open file dialog)\")\n\n\tremoteCmd := flag.String(\n\t\t\"remote\",\n\t\t\"\",\n\t\t\"send remote command to server\")\n\n\tcpuprofile := flag.String(\n\t\t\"cpuprofile\",\n\t\t\"\",\n\t\t\"path to the file to write the CPU profile\")\n\n\tmemprofile := flag.String(\n\t\t\"memprofile\",\n\t\t\"\",\n\t\t\"path to the file to write the memory profile\")\n\n\tflag.StringVar(&gLastDirPath,\n\t\t\"last-dir-path\",\n\t\t\"\",\n\t\t\"path to the file to write the last dir on exit (to use for cd)\")\n\n\tflag.StringVar(&gSelectionPath,\n\t\t\"selection-path\",\n\t\t\"\",\n\t\t\"path to the file to write selected files on open (to use as open file dialog)\")\n\n\tflag.StringVar(&gConfigPath,\n\t\t\"config\",\n\t\t\"\",\n\t\t\"path to the config file (instead of the usual paths)\")\n\n\tflag.Var(&gCommands,\n\t\t\"command\",\n\t\t\"command to execute on client initialization\")\n\n\tflag.StringVar(&gLogPath,\n\t\t\"log\",\n\t\t\"\",\n\t\t\"path to the log file to write messages\")\n\n\tflag.Parse()\n\n\tgSocketProt = gDefaultSocketProt\n\tgSocketPath = gDefaultSocketPath\n\n\tif *cpuprofile != \"\" {\n\t\tf, err := os.Create(*cpuprofile)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"could not create CPU profile: %s\", err)\n\t\t}\n\t\tif err := pprof.StartCPUProfile(f); err != nil {\n\t\t\tlog.Fatalf(\"could not start CPU profile: %s\", err)\n\t\t}\n\t\tdefer pprof.StopCPUProfile()\n\t}\n\n\tswitch {\n\tcase *showDoc:\n\t\tfmt.Print(genDocString)\n\tcase *showVersion:\n\t\tprintVersion()\n\tcase *remoteCmd != \"\":\n\t\tif err := remote(*remoteCmd); err != nil {\n\t\t\tlog.Fatalf(\"remote command: %s\", err)\n\t\t}\n\tcase *serverMode:\n\t\tif gLogPath != \"\" && !filepath.IsAbs(gLogPath) {\n\t\t\twd, err := os.Getwd()\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\"getting current directory: %s\", err)\n\t\t\t} else {\n\t\t\t\tgLogPath = filepath.Join(wd, gLogPath)\n\t\t\t}\n\t\t}\n\t\tos.Chdir(gUser.HomeDir)\n\t\tserve()\n\tdefault:\n\t\tgSingleMode = *singleMode\n\t\tgPrintLastDir = *printLastDir\n\t\tgPrintSelection = *printSelection\n\n\t\tif !gSingleMode {\n\t\t\tcheckServer()\n\t\t}\n\n\t\tgClientID = os.Getpid()\n\n\t\tswitch flag.NArg() {\n\t\tcase 0:\n\t\t\t_, err := os.Getwd()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"getting current directory: %s\\n\", err)\n\t\t\t\tos.Exit(2)\n\t\t\t}\n\t\tcase 1:\n\t\t\tgSelect = flag.Arg(0)\n\t\tdefault:\n\t\t\tfmt.Fprintf(os.Stderr, \"only single file or directory is allowed\\n\")\n\t\t\tos.Exit(2)\n\t\t}\n\n\t\texportEnvVars()\n\n\t\trun()\n\t}\n\n\tif *memprofile != \"\" {\n\t\tf, err := os.Create(*memprofile)\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"could not create memory profile: \", err)\n\t\t}\n\t\truntime.GC()\n\t\tif err := pprof.WriteHeapProfile(f); err != nil {\n\t\t\tlog.Fatal(\"could not write memory profile: \", err)\n\t\t}\n\t\tf.Close()\n\t}\n}\n"
        },
        {
          "name": "misc.go",
          "type": "blob",
          "size": 8.6025390625,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode\"\n\n\t\"github.com/Xuanwo/go-locale\"\n\t\"github.com/mattn/go-runewidth\"\n\t\"golang.org/x/text/collate\"\n\t\"golang.org/x/text/language\"\n)\n\nconst (\n\tlocaleStrDisable = \"\"  // disable locale ordering for this locale value\n\tlocaleStrSys     = \"*\" // replace this locale value with locale value read from environment\n)\n\nfunc isRoot(name string) bool { return filepath.Dir(name) == name }\n\nfunc replaceTilde(s string) string {\n\tif strings.HasPrefix(s, \"~\") {\n\t\treturn gUser.HomeDir + s[1:]\n\t}\n\treturn s\n}\n\nfunc runeSliceWidth(rs []rune) int {\n\tw := 0\n\tfor _, r := range rs {\n\t\tw += runewidth.RuneWidth(r)\n\t}\n\treturn w\n}\n\nfunc runeSliceWidthRange(rs []rune, beg, end int) []rune {\n\tif beg == end {\n\t\treturn []rune{}\n\t}\n\n\tcurr := 0\n\tb := 0\n\tfoundb := false\n\tfor i, r := range rs {\n\t\tw := runewidth.RuneWidth(r)\n\t\tif curr >= beg && !foundb {\n\t\t\tb = i\n\t\t\tfoundb = true\n\t\t}\n\t\tif curr == end || curr+w > end {\n\t\t\treturn rs[b:i]\n\t\t}\n\t\tcurr += w\n\t}\n\n\treturn rs[b:]\n}\n\n// Returns the last runes of `rs` that take up at most `maxWidth` space.\nfunc runeSliceWidthLastRange(rs []rune, maxWidth int) []rune {\n\tlastWidth := 0\n\tfor i := len(rs) - 1; i >= 0; i-- {\n\t\tw := runewidth.RuneWidth(rs[i])\n\t\tif lastWidth+w > maxWidth {\n\t\t\treturn rs[i+1:]\n\t\t}\n\t\tlastWidth += w\n\t}\n\treturn rs\n}\n\n// This function is used to escape whitespaces and special characters with\n// backslashes in a given string.\nfunc escape(s string) string {\n\tbuf := make([]rune, 0, len(s))\n\tfor _, r := range s {\n\t\tif unicode.IsSpace(r) || r == '\\\\' || r == ';' || r == '#' {\n\t\t\tbuf = append(buf, '\\\\')\n\t\t}\n\t\tbuf = append(buf, r)\n\t}\n\treturn string(buf)\n}\n\n// This function is used to remove backslashes that are used to escape\n// whitespaces and special characters in a given string.\nfunc unescape(s string) string {\n\tesc := false\n\tbuf := make([]rune, 0, len(s))\n\tfor _, r := range s {\n\t\tif esc {\n\t\t\tif !unicode.IsSpace(r) && r != '\\\\' && r != ';' && r != '#' {\n\t\t\t\tbuf = append(buf, '\\\\')\n\t\t\t}\n\t\t\tbuf = append(buf, r)\n\t\t\tesc = false\n\t\t\tcontinue\n\t\t}\n\t\tif r == '\\\\' {\n\t\t\tesc = true\n\t\t\tcontinue\n\t\t}\n\t\tesc = false\n\t\tbuf = append(buf, r)\n\t}\n\tif esc {\n\t\tbuf = append(buf, '\\\\')\n\t}\n\treturn string(buf)\n}\n\n// This function splits the given string by whitespaces. It is aware of escaped\n// whitespaces so that they are not split unintentionally.\nfunc tokenize(s string) []string {\n\tesc := false\n\tvar buf []rune\n\tvar toks []string\n\tfor _, r := range s {\n\t\tif r == '\\\\' {\n\t\t\tesc = true\n\t\t\tbuf = append(buf, r)\n\t\t\tcontinue\n\t\t}\n\t\tif esc {\n\t\t\tesc = false\n\t\t\tbuf = append(buf, r)\n\t\t\tcontinue\n\t\t}\n\t\tif !unicode.IsSpace(r) {\n\t\t\tbuf = append(buf, r)\n\t\t} else {\n\t\t\ttoks = append(toks, string(buf))\n\t\t\tbuf = nil\n\t\t}\n\t}\n\treturn append(toks, string(buf))\n}\n\n// This function splits the first word of a string delimited by whitespace from\n// the rest. This is used to tokenize a string one by one without touching the\n// rest. Whitespace on the left side of both the word and the rest are trimmed.\nfunc splitWord(s string) (word, rest string) {\n\ts = strings.TrimLeftFunc(s, unicode.IsSpace)\n\tind := len(s)\n\tfor i, c := range s {\n\t\tif unicode.IsSpace(c) {\n\t\t\tind = i\n\t\t\tbreak\n\t\t}\n\t}\n\tword = s[0:ind]\n\trest = strings.TrimLeftFunc(s[ind:], unicode.IsSpace)\n\treturn\n}\n\n// This function reads whitespace separated string arrays at each line. Single\n// or double quotes can be used to escape whitespaces. Hash characters can be\n// used to add a comment until the end of line. Leading and trailing space is\n// trimmed. Empty lines are skipped.\nfunc readArrays(r io.Reader, min_cols, max_cols int) ([][]string, error) {\n\tvar arrays [][]string\n\ts := bufio.NewScanner(r)\n\tfor s.Scan() {\n\t\tline := s.Text()\n\n\t\tsquote, dquote := false, false\n\t\tfor i := 0; i < len(line); i++ {\n\t\t\tif line[i] == '\\'' && !dquote {\n\t\t\t\tsquote = !squote\n\t\t\t} else if line[i] == '\"' && !squote {\n\t\t\t\tdquote = !dquote\n\t\t\t}\n\t\t\tif !squote && !dquote && line[i] == '#' {\n\t\t\t\tline = line[:i]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tline = strings.TrimSpace(line)\n\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tsquote, dquote = false, false\n\t\tarr := strings.FieldsFunc(line, func(r rune) bool {\n\t\t\tif r == '\\'' && !dquote {\n\t\t\t\tsquote = !squote\n\t\t\t} else if r == '\"' && !squote {\n\t\t\t\tdquote = !dquote\n\t\t\t}\n\t\t\treturn !squote && !dquote && unicode.IsSpace(r)\n\t\t})\n\t\tarrlen := len(arr)\n\n\t\tif arrlen < min_cols || arrlen > max_cols {\n\t\t\tif min_cols == max_cols {\n\t\t\t\treturn nil, fmt.Errorf(\"expected %d columns but found: %s\", min_cols, s.Text())\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"expected %d~%d columns but found: %s\", min_cols, max_cols, s.Text())\n\t\t}\n\n\t\tfor i := 0; i < arrlen; i++ {\n\t\t\tsquote, dquote = false, false\n\t\t\tbuf := make([]rune, 0, len(arr[i]))\n\t\t\tfor _, r := range arr[i] {\n\t\t\t\tif r == '\\'' && !dquote {\n\t\t\t\t\tsquote = !squote\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif r == '\"' && !squote {\n\t\t\t\t\tdquote = !dquote\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tbuf = append(buf, r)\n\t\t\t}\n\t\t\tarr[i] = string(buf)\n\t\t}\n\n\t\tarrays = append(arrays, arr)\n\t}\n\n\treturn arrays, nil\n}\n\nfunc readPairs(r io.Reader) ([][]string, error) {\n\treturn readArrays(r, 2, 2)\n}\n\n// This function converts a size in bytes to a human readable form using metric\n// suffixes (e.g. 1K = 1000). For values less than 10 the first significant\n// digit is shown, otherwise it is hidden. Numbers are always rounded down.\n// This should be fine for most human beings.\nfunc humanize(size int64) string {\n\tif size < 1000 {\n\t\treturn fmt.Sprintf(\"%dB\", size)\n\t}\n\n\tsuffix := []string{\n\t\t\"K\", // kilo\n\t\t\"M\", // mega\n\t\t\"G\", // giga\n\t\t\"T\", // tera\n\t\t\"P\", // peta\n\t\t\"E\", // exa\n\t\t\"Z\", // zeta\n\t\t\"Y\", // yotta\n\t}\n\n\tcurr := float64(size) / 1000\n\tfor _, s := range suffix {\n\t\tif curr < 10 {\n\t\t\treturn fmt.Sprintf(\"%.1f%s\", curr-0.0499, s)\n\t\t}\n\t\tif curr < 1000 {\n\t\t\treturn fmt.Sprintf(\"%d%s\", int(curr), s)\n\t\t}\n\t\tcurr /= 1000\n\t}\n\n\treturn \"\"\n}\n\n// This function compares two strings for natural sorting which takes into\n// account values of numbers in strings. For example, '2' is less than '10',\n// and similarly 'foo2bar' is less than 'foo10bar', but 'bar2bar' is greater\n// than 'foo10bar'.\nfunc naturalLess(s1, s2 string) bool {\n\tlo1, lo2, hi1, hi2 := 0, 0, 0, 0\n\ts1len := len(s1)\n\ts2len := len(s2)\n\tfor {\n\t\tif hi1 >= s1len {\n\t\t\treturn hi2 != s2len\n\t\t}\n\n\t\tif hi2 >= s2len {\n\t\t\treturn false\n\t\t}\n\n\t\tisDigit1 := isDigit(s1[hi1])\n\t\tisDigit2 := isDigit(s2[hi2])\n\n\t\tfor lo1 = hi1; hi1 < s1len && isDigit(s1[hi1]) == isDigit1; hi1++ {\n\t\t}\n\n\t\tfor lo2 = hi2; hi2 < s2len && isDigit(s2[hi2]) == isDigit2; hi2++ {\n\t\t}\n\n\t\tif s1[lo1:hi1] == s2[lo2:hi2] {\n\t\t\tcontinue\n\t\t}\n\n\t\tif isDigit1 && isDigit2 {\n\t\t\tnum1, err1 := strconv.Atoi(s1[lo1:hi1])\n\t\t\tnum2, err2 := strconv.Atoi(s2[lo2:hi2])\n\n\t\t\tif err1 == nil && err2 == nil {\n\t\t\t\treturn num1 < num2\n\t\t\t}\n\t\t}\n\n\t\treturn s1[lo1:hi1] < s2[lo2:hi2]\n\t}\n}\n\n// This function returns the extension of a file with a leading dot\n// it returns an empty string if extension could not be determined\n// i.e. directories, filenames without extensions\nfunc getFileExtension(file fs.FileInfo) string {\n\tif file.IsDir() {\n\t\treturn \"\"\n\t}\n\tif strings.Count(file.Name(), \".\") == 1 && file.Name()[0] == '.' {\n\t\t// hidden file without extension\n\t\treturn \"\"\n\t}\n\treturn filepath.Ext(file.Name())\n}\n\nvar (\n\treModKey   = regexp.MustCompile(`<(c|s|a)-(.+)>`)\n\treRulerSub = regexp.MustCompile(`%[apmcsfithd]|%\\{[^}]+\\}`)\n)\n\nvar (\n\treWord    = regexp.MustCompile(`(\\pL|\\pN)+`)\n\treWordBeg = regexp.MustCompile(`([^\\pL\\pN]|^)(\\pL|\\pN)`)\n\treWordEnd = regexp.MustCompile(`(\\pL|\\pN)([^\\pL\\pN]|$)`)\n)\n\n// This function parses given locale string into language tag value. Passing empty\n// string as locale means reading locale value from environment.\nfunc getLocaleTag(localeStr string) (language.Tag, error) {\n\tif localeStr == localeStrSys {\n\t\t// read environment locale\n\t\treturn locale.Detect()\n\t}\n\n\tlocaleTag, err := language.Parse(localeStr)\n\tif err != nil {\n\t\treturn localeTag, fmt.Errorf(\"invalid locale %q: %s\", localeStr, err)\n\t}\n\n\treturn localeTag, nil\n}\n\n// This function creates new collator for given locale. Passing empty string as\n// as locale means reading locale value from environment.\n//\n// *Note*: this function returns error when given `localeStr` has value `localeStrDisable`\n// or is an invalid locale tag.\nfunc makeCollator(localeStr string, opts ...collate.Option) (*collate.Collator, error) {\n\tif localeStr == localeStrDisable {\n\t\treturn nil, fmt.Errorf(\"locale is disabled\")\n\t}\n\n\tlocaleTag, err := getLocaleTag(localeStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn collate.New(localeTag, opts...), nil\n}\n\n// We don't need no generic code\n// We don't need no type control\n// No dark templates in compiler\n// Haskell leave them kids alone\n// Hey Bjarne leave them kids alone\n// All in all it's just another brick in the code\n// All in all you're just another brick in the code\n//\n// -- Pink Trolled --\n"
        },
        {
          "name": "misc_test.go",
          "type": "blob",
          "size": 10.73828125,
          "content": "package main\n\nimport (\n\t\"os\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"golang.org/x/text/collate\"\n)\n\nfunc TestIsRoot(t *testing.T) {\n\tsep := string(os.PathSeparator)\n\tif !isRoot(sep) {\n\t\tt.Errorf(`\"%s\" is root`, sep)\n\t}\n\n\tpaths := []string{\n\t\t\"\",\n\t\t\"~\",\n\t\t\"foo\",\n\t\t\"foo/bar\",\n\t\t\"foo/bar\",\n\t\t\"/home\",\n\t\t\"/home/user\",\n\t}\n\n\tfor _, p := range paths {\n\t\tif isRoot(p) {\n\t\t\tt.Errorf(\"'%s' is not root\", p)\n\t\t}\n\t}\n}\n\nfunc TestRuneSliceWidth(t *testing.T) {\n\ttests := []struct {\n\t\trs  []rune\n\t\texp int\n\t}{\n\t\t{[]rune{'a', 'b'}, 2},\n\t\t{[]rune{'ı', 'ş'}, 2},\n\t\t{[]rune{'世', '界'}, 4},\n\t\t{[]rune{'世', 'a', '界', 'ı'}, 6},\n\t}\n\n\tfor _, test := range tests {\n\t\tif got := runeSliceWidth(test.rs); got != test.exp {\n\t\t\tt.Errorf(\"at input '%v' expected '%d' but got '%d'\", test.rs, test.exp, got)\n\t\t}\n\t}\n}\n\nfunc TestRuneSliceWidthRange(t *testing.T) {\n\ttests := []struct {\n\t\trs  []rune\n\t\tbeg int\n\t\tend int\n\t\texp []rune\n\t}{\n\t\t{[]rune{}, 0, 0, []rune{}},\n\t\t{[]rune{'a', 'b', 'c', 'd'}, 1, 3, []rune{'b', 'c'}},\n\t\t{[]rune{'a', 'ı', 'b', 'ş'}, 1, 3, []rune{'ı', 'b'}},\n\t\t{[]rune{'世', '界', '世', '界'}, 2, 6, []rune{'界', '世'}},\n\t\t{[]rune{'世', '界', '世', '界'}, 3, 6, []rune{'世'}},\n\t\t{[]rune{'世', '界', '世', '界'}, 2, 5, []rune{'界'}},\n\t\t{[]rune{'世', '界', '世', '界'}, 3, 5, []rune{}},\n\t\t{[]rune{'世', '界', '世', '界'}, 4, 4, []rune{}},\n\t\t{[]rune{'世', '界', '世', '界'}, 5, 5, []rune{}},\n\t\t{[]rune{'世', '界', '世', '界'}, 4, 7, []rune{'世'}},\n\t\t{[]rune{'世', '界', '世', '界'}, 4, 8, []rune{'世', '界'}},\n\t\t{[]rune{'世', 'a', '界', 'ı'}, 2, 5, []rune{'a', '界'}},\n\t\t{[]rune{'世', 'a', '界', 'ı'}, 2, 4, []rune{'a'}},\n\t\t{[]rune{'世', 'a', '界', 'ı'}, 3, 5, []rune{'界'}},\n\t\t{[]rune{'世', 'a', '界', 'ı'}, 3, 4, []rune{}},\n\t\t{[]rune{'世', 'a', '界', 'ı'}, 3, 3, []rune{}},\n\t\t{[]rune{'世', 'a', '界', 'ı'}, 4, 4, []rune{}},\n\t\t{[]rune{'世', 'a', '界', 'ı'}, 4, 6, []rune{'ı'}},\n\t\t{[]rune{'世', 'a', '界', 'ı'}, 5, 6, []rune{'ı'}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif got := runeSliceWidthRange(test.rs, test.beg, test.end); !reflect.DeepEqual(got, test.exp) {\n\t\t\tt.Errorf(\"at input '%v' expected '%v' but got '%v'\", test.rs, test.exp, got)\n\t\t}\n\t}\n}\n\nfunc TestRuneSliceWidthLastRange(t *testing.T) {\n\ttests := []struct {\n\t\trs       []rune\n\t\tmaxWidth int\n\t\texp      []rune\n\t}{\n\t\t{[]rune{}, 0, []rune{}},\n\t\t{[]rune{}, 1, []rune{}},\n\t\t{[]rune{'a', 'ı', 'b', ' '}, 0, []rune{}},\n\t\t{[]rune{'a', 'ı', 'b', ' '}, 1, []rune{' '}},\n\t\t{[]rune{'a', 'ı', 'b', ' '}, 2, []rune{'b', ' '}},\n\t\t{[]rune{'a', 'ı', 'b', ' '}, 3, []rune{'ı', 'b', ' '}},\n\t\t{[]rune{'a', 'ı', 'b', ' '}, 4, []rune{'a', 'ı', 'b', ' '}},\n\t\t{[]rune{'a', 'ı', 'b', ' '}, 5, []rune{'a', 'ı', 'b', ' '}},\n\t\t{[]rune{'世', '界', '世', '界'}, 0, []rune{}},\n\t\t{[]rune{'世', '界', '世', '界'}, 1, []rune{}},\n\t\t{[]rune{'世', '界', '世', '界'}, 2, []rune{'界'}},\n\t\t{[]rune{'世', '界', '世', '界'}, 3, []rune{'界'}},\n\t\t{[]rune{'世', '界', '世', '界'}, 4, []rune{'世', '界'}},\n\t\t{[]rune{'世', '界', '世', '界'}, 5, []rune{'世', '界'}},\n\t\t{[]rune{'世', '界', '世', '界'}, 6, []rune{'界', '世', '界'}},\n\t\t{[]rune{'世', '界', '世', '界'}, 7, []rune{'界', '世', '界'}},\n\t\t{[]rune{'世', '界', '世', '界'}, 8, []rune{'世', '界', '世', '界'}},\n\t\t{[]rune{'世', '界', '世', '界'}, 9, []rune{'世', '界', '世', '界'}},\n\t\t{[]rune{'世', 'a', '界', 'ı'}, 0, []rune{}},\n\t\t{[]rune{'世', 'a', '界', 'ı'}, 1, []rune{'ı'}},\n\t\t{[]rune{'世', 'a', '界', 'ı'}, 2, []rune{'ı'}},\n\t\t{[]rune{'世', 'a', '界', 'ı'}, 3, []rune{'界', 'ı'}},\n\t\t{[]rune{'世', 'a', '界', 'ı'}, 4, []rune{'a', '界', 'ı'}},\n\t\t{[]rune{'世', 'a', '界', 'ı'}, 5, []rune{'a', '界', 'ı'}},\n\t\t{[]rune{'世', 'a', '界', 'ı'}, 6, []rune{'世', 'a', '界', 'ı'}},\n\t\t{[]rune{'世', 'a', '界', 'ı'}, 7, []rune{'世', 'a', '界', 'ı'}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif got := runeSliceWidthLastRange(test.rs, test.maxWidth); !reflect.DeepEqual(got, test.exp) {\n\t\t\tt.Errorf(\"at input '%v' expected '%v' but got '%v'\", test.rs, test.exp, got)\n\t\t}\n\t}\n}\n\nfunc TestEscape(t *testing.T) {\n\ttests := []struct {\n\t\ts   string\n\t\texp string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"foo\", \"foo\"},\n\t\t{\"foo bar\", `foo\\ bar`},\n\t\t{\"foo  bar\", `foo\\ \\ bar`},\n\t\t{`foo\\bar`, `foo\\\\bar`},\n\t\t{`foo\\ bar`, `foo\\\\\\ bar`},\n\t\t{`foo;bar`, `foo\\;bar`},\n\t\t{`foo#bar`, `foo\\#bar`},\n\t\t{`foo\\tbar`, `foo\\\\tbar`},\n\t\t{\"foo\\tbar\", \"foo\\\\\\tbar\"},\n\t\t{`foo\\`, `foo\\\\`},\n\t}\n\n\tfor _, test := range tests {\n\t\tif got := escape(test.s); !reflect.DeepEqual(got, test.exp) {\n\t\t\tt.Errorf(\"at input '%v' expected '%v' but got '%v'\", test.s, test.exp, got)\n\t\t}\n\t}\n}\n\nfunc TestUnescape(t *testing.T) {\n\ttests := []struct {\n\t\ts   string\n\t\texp string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"foo\", \"foo\"},\n\t\t{`foo\\ bar`, \"foo bar\"},\n\t\t{`foo\\ \\ bar`, \"foo  bar\"},\n\t\t{`foo\\\\bar`, `foo\\bar`},\n\t\t{`foo\\\\\\ bar`, `foo\\ bar`},\n\t\t{`foo\\;bar`, `foo;bar`},\n\t\t{`foo\\#bar`, `foo#bar`},\n\t\t{`foo\\\\tbar`, `foo\\tbar`},\n\t\t{\"foo\\\\\\tbar\", \"foo\\tbar\"},\n\t\t{`foo\\`, `foo\\`},\n\t}\n\n\tfor _, test := range tests {\n\t\tif got := unescape(test.s); !reflect.DeepEqual(got, test.exp) {\n\t\t\tt.Errorf(\"at input '%v' expected '%v' but got '%v'\", test.s, test.exp, got)\n\t\t}\n\t}\n}\n\nfunc TestTokenize(t *testing.T) {\n\ttests := []struct {\n\t\ts   string\n\t\texp []string\n\t}{\n\t\t{\"\", []string{\"\"}},\n\t\t{\"foo\", []string{\"foo\"}},\n\t\t{\"foo bar\", []string{\"foo\", \"bar\"}},\n\t\t{`:rename foo\\ bar`, []string{\":rename\", `foo\\ bar`}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif got := tokenize(test.s); !reflect.DeepEqual(got, test.exp) {\n\t\t\tt.Errorf(\"at input '%v' expected '%v' but got '%v'\", test.s, test.exp, got)\n\t\t}\n\t}\n}\n\nfunc TestSplitWord(t *testing.T) {\n\ttests := []struct {\n\t\ts    string\n\t\tword string\n\t\trest string\n\t}{\n\t\t{\"\", \"\", \"\"},\n\t\t{\"foo\", \"foo\", \"\"},\n\t\t{\"  foo\", \"foo\", \"\"},\n\t\t{\"foo  \", \"foo\", \"\"},\n\t\t{\"  foo  \", \"foo\", \"\"},\n\t\t{\"foo bar baz\", \"foo\", \"bar baz\"},\n\t\t{\"  foo bar baz\", \"foo\", \"bar baz\"},\n\t\t{\"foo   bar baz\", \"foo\", \"bar baz\"},\n\t\t{\"  foo   bar baz\", \"foo\", \"bar baz\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tif w, r := splitWord(test.s); w != test.word || r != test.rest {\n\t\t\tt.Errorf(\"at input '%s' expected '%s' and '%s' but got '%s' and '%s'\", test.s, test.word, test.rest, w, r)\n\t\t}\n\t}\n}\n\nfunc TestReadArrays(t *testing.T) {\n\ttests := []struct {\n\t\ts        string\n\t\tmin_cols int\n\t\tmax_cols int\n\t\texp      [][]string\n\t}{\n\t\t{\"foo bar\", 2, 2, [][]string{{\"foo\", \"bar\"}}},\n\t\t{\"foo bar \", 2, 2, [][]string{{\"foo\", \"bar\"}}},\n\t\t{\" foo bar\", 2, 2, [][]string{{\"foo\", \"bar\"}}},\n\t\t{\" foo bar \", 2, 2, [][]string{{\"foo\", \"bar\"}}},\n\t\t{\"foo bar#baz\", 2, 2, [][]string{{\"foo\", \"bar\"}}},\n\t\t{\"foo bar #baz\", 2, 2, [][]string{{\"foo\", \"bar\"}}},\n\t\t{`'foo#baz' bar`, 2, 2, [][]string{{\"foo#baz\", \"bar\"}}},\n\t\t{`\"foo#baz\" bar`, 2, 2, [][]string{{\"foo#baz\", \"bar\"}}},\n\t\t{\"foo bar baz\", 3, 3, [][]string{{\"foo\", \"bar\", \"baz\"}}},\n\t\t{`\"foo bar baz\"`, 1, 1, [][]string{{\"foo bar baz\"}}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif got, _ := readArrays(strings.NewReader(test.s), test.min_cols, test.max_cols); !reflect.DeepEqual(got, test.exp) {\n\t\t\tt.Errorf(\"at input '%v' expected '%v' but got '%v'\", test.s, test.exp, got)\n\t\t}\n\t}\n}\n\nfunc TestHumanize(t *testing.T) {\n\ttests := []struct {\n\t\ti   int64\n\t\texp string\n\t}{\n\t\t{0, \"0B\"},\n\t\t{9, \"9B\"},\n\t\t{99, \"99B\"},\n\t\t{999, \"999B\"},\n\t\t{1000, \"1.0K\"},\n\t\t{1023, \"1.0K\"},\n\t\t{1025, \"1.0K\"},\n\t\t{1049, \"1.0K\"},\n\t\t{1050, \"1.0K\"},\n\t\t{1099, \"1.0K\"},\n\t\t{9999, \"9.9K\"},\n\t\t{10000, \"10K\"},\n\t\t{10100, \"10K\"},\n\t\t{10500, \"10K\"},\n\t\t{1000000, \"1.0M\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tif got := humanize(test.i); got != test.exp {\n\t\t\tt.Errorf(\"at input '%d' expected '%s' but got '%s'\", test.i, test.exp, got)\n\t\t}\n\t}\n}\n\nfunc TestNaturalLess(t *testing.T) {\n\ttests := []struct {\n\t\ts1  string\n\t\ts2  string\n\t\texp bool\n\t}{\n\t\t{\"foo\", \"bar\", false},\n\t\t{\"bar\", \"baz\", true},\n\t\t{\"foo\", \"123\", false},\n\t\t{\"foo1\", \"foobar\", true},\n\t\t{\"foo1\", \"foo10\", true},\n\t\t{\"foo2\", \"foo10\", true},\n\t\t{\"foo1\", \"foo10bar\", true},\n\t\t{\"foo2\", \"foo10bar\", true},\n\t\t{\"foo1bar\", \"foo10bar\", true},\n\t\t{\"foo2bar\", \"foo10bar\", true},\n\t\t{\"foo1bar\", \"foo10\", true},\n\t\t{\"foo2bar\", \"foo10\", true},\n\t}\n\n\tfor _, test := range tests {\n\t\tif got := naturalLess(test.s1, test.s2); got != test.exp {\n\t\t\tt.Errorf(\"at input '%s' and '%s' expected '%t' but got '%t'\", test.s1, test.s2, test.exp, got)\n\t\t}\n\t}\n}\n\ntype fakeFileInfo struct {\n\tname  string\n\tisDir bool\n}\n\nfunc (fileinfo fakeFileInfo) Name() string       { return fileinfo.name }\nfunc (fileinfo fakeFileInfo) Size() int64        { return 0 }\nfunc (fileinfo fakeFileInfo) Mode() os.FileMode  { return os.FileMode(0o000) }\nfunc (fileinfo fakeFileInfo) ModTime() time.Time { return time.Unix(0, 0) }\nfunc (fileinfo fakeFileInfo) IsDir() bool        { return fileinfo.isDir }\nfunc (fileinfo fakeFileInfo) Sys() any           { return nil }\n\nfunc TestGetFileExtension(t *testing.T) {\n\ttests := []struct {\n\t\tname              string\n\t\tfileName          string\n\t\tisDir             bool\n\t\texpectedExtension string\n\t}{\n\t\t{\"normal file\", \"file.txt\", false, \".txt\"},\n\t\t{\"file without extension\", \"file\", false, \"\"},\n\t\t{\"hidden file\", \".gitignore\", false, \"\"},\n\t\t{\"hidden file with extension\", \".file.txt\", false, \".txt\"},\n\t\t{\"directory\", \"dir\", true, \"\"},\n\t\t{\"hidden directory\", \".git\", true, \"\"},\n\t\t{\"directory with dot\", \"profile.d\", true, \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tif got := getFileExtension(fakeFileInfo{test.fileName, test.isDir}); got != test.expectedExtension {\n\t\t\t\tt.Errorf(\"at input '%s' expected '%s' but got '%s'\", test.fileName, test.expectedExtension, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLocaleNaturalLess(t *testing.T) {\n\ttests := []struct {\n\t\ts1  string\n\t\ts2  string\n\t\texp bool\n\t}{\n\t\t// preserving behavior of `naturalLess`\n\t\t{\"foo\", \"bar\", false},\n\t\t{\"bar\", \"baz\", true},\n\t\t{\"foo\", \"123\", false},\n\t\t{\"foo1\", \"foobar\", true},\n\t\t{\"foo1\", \"foo10\", true},\n\t\t{\"foo2\", \"foo10\", true},\n\t\t{\"foo1\", \"foo10bar\", true},\n\t\t{\"foo2\", \"foo10bar\", true},\n\t\t{\"foo1bar\", \"foo10bar\", true},\n\t\t{\"foo2bar\", \"foo10bar\", true},\n\t\t{\"foo1bar\", \"foo10\", true},\n\t\t{\"foo2bar\", \"foo10\", true},\n\n\t\t// locale sort\n\t\t{\"你好\", \"他好\", true},     // \\u4F60\\u597D, \\u4ED6\\u597D\n\t\t{\"到这\", \"到那\", false},    // \\u5230\\u8FD9, \\u5230\\u90A3\n\t\t{\"你说\", \"什么\", true},     // \\u4f60\\u8bf4, \\u4ec0\\u4e48\n\t\t{\"你好\", \"World\", false}, // \\u4F60\\u597D, \\u57\\u6f\\u72\\u6c\\u64\n\t\t{\"甲1\", \"甲乙\", true},\n\t\t{\"甲1\", \"甲10\", true},\n\t\t{\"甲2\", \"甲10\", true},\n\t\t{\"甲1\", \"甲10乙\", true},\n\t\t{\"甲2\", \"甲10乙\", true},\n\t\t{\"甲1乙\", \"甲10乙\", true},\n\t\t{\"甲2乙\", \"甲10乙\", true},\n\t\t{\"甲1乙\", \"甲10\", true},\n\t\t{\"甲2乙\", \"甲10\", true},\n\t}\n\n\tlocaleStr := \"zh-CN\"\n\tcollator, err := makeCollator(localeStr, collate.Numeric)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create collator for %q: %s\", localeStr, err)\n\t}\n\n\tfor _, test := range tests {\n\t\tif got := collator.CompareString(test.s1, test.s2) < 0; got != test.exp {\n\t\t\tt.Errorf(\"at input '%s' and '%s' expected '%t' but got '%t'\", test.s1, test.s2, test.exp, got)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "nav.go",
          "type": "blob",
          "size": 43.8935546875,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/djherbis/times\"\n\t\"golang.org/x/text/collate\"\n)\n\ntype linkState byte\n\nconst (\n\tnotLink linkState = iota\n\tworking\n\tbroken\n)\n\ntype file struct {\n\tos.FileInfo\n\tlinkState  linkState\n\tlinkTarget string\n\tpath       string\n\tdirCount   int\n\tdirSize    int64\n\taccessTime time.Time\n\tchangeTime time.Time\n\text        string\n\terr        error\n}\n\nfunc newFile(path string) *file {\n\tlstat, err := os.Lstat(path)\n\n\tif err != nil {\n\t\tlog.Printf(\"getting file information: %s\", err)\n\t\treturn &file{\n\t\t\tFileInfo:   &fakeStat{name: filepath.Base(path)},\n\t\t\tlinkState:  notLink,\n\t\t\tlinkTarget: \"\",\n\t\t\tpath:       path,\n\t\t\tdirCount:   -1,\n\t\t\tdirSize:    -1,\n\t\t\taccessTime: time.Unix(0, 0),\n\t\t\tchangeTime: time.Unix(0, 0),\n\t\t\text:        \"\",\n\t\t\terr:        err,\n\t\t}\n\t}\n\n\tvar linkState linkState\n\tvar linkTarget string\n\n\tif lstat.Mode()&os.ModeSymlink != 0 {\n\t\tstat, err := os.Stat(path)\n\t\tif err == nil {\n\t\t\tlinkState = working\n\t\t\tlstat = stat\n\t\t} else {\n\t\t\tlinkState = broken\n\t\t}\n\t\tlinkTarget, err = os.Readlink(path)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"reading link target: %s\", err)\n\t\t}\n\t}\n\n\tts := times.Get(lstat)\n\tat := ts.AccessTime()\n\tvar ct time.Time\n\t// from times docs: ChangeTime() panics unless HasChangeTime() is true\n\tif ts.HasChangeTime() {\n\t\tct = ts.ChangeTime()\n\t} else {\n\t\t// fall back to ModTime if ChangeTime cannot be determined\n\t\tct = lstat.ModTime()\n\t}\n\n\tdirCount := -1\n\tif lstat.IsDir() && gOpts.dircounts {\n\t\td, err := os.Open(path)\n\t\tif err != nil {\n\t\t\tdirCount = -2\n\t\t} else {\n\t\t\tnames, err := d.Readdirnames(1000)\n\t\t\td.Close()\n\n\t\t\tif names == nil && err != io.EOF {\n\t\t\t\tdirCount = -2\n\t\t\t} else {\n\t\t\t\tdirCount = len(names)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn &file{\n\t\tFileInfo:   lstat,\n\t\tlinkState:  linkState,\n\t\tlinkTarget: linkTarget,\n\t\tpath:       path,\n\t\tdirCount:   dirCount,\n\t\tdirSize:    -1,\n\t\taccessTime: at,\n\t\tchangeTime: ct,\n\t\text:        getFileExtension(lstat),\n\t\terr:        nil,\n\t}\n}\n\nfunc (file *file) TotalSize() int64 {\n\tif file.IsDir() {\n\t\tif file.dirSize >= 0 {\n\t\t\treturn file.dirSize\n\t\t}\n\t\treturn 0\n\t}\n\treturn file.Size()\n}\n\ntype fakeStat struct {\n\tname string\n}\n\nfunc (fs *fakeStat) Name() string       { return fs.name }\nfunc (fs *fakeStat) Size() int64        { return 0 }\nfunc (fs *fakeStat) Mode() os.FileMode  { return os.FileMode(0o000) }\nfunc (fs *fakeStat) ModTime() time.Time { return time.Unix(0, 0) }\nfunc (fs *fakeStat) IsDir() bool        { return false }\nfunc (fs *fakeStat) Sys() any           { return nil }\n\nfunc readdir(path string) ([]*file, error) {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tnames, err := f.Readdirnames(-1)\n\tf.Close()\n\n\tfiles := make([]*file, 0, len(names))\n\tfor _, fname := range names {\n\t\tfiles = append(files, newFile(filepath.Join(path, fname)))\n\t}\n\n\treturn files, err\n}\n\ntype dir struct {\n\tloading     bool       // directory is loading from disk\n\tloadTime    time.Time  // current loading or last load time\n\tind         int        // index of current entry in files\n\tpos         int        // position of current entry in ui\n\tpath        string     // full path of directory\n\tfiles       []*file    // displayed files in directory including or excluding hidden ones\n\tallFiles    []*file    // all files in directory including hidden ones (same array as files)\n\tsortby      sortMethod // sortby value from last sort\n\tdirfirst    bool       // dirfirst value from last sort\n\tdironly     bool       // dironly value from last sort\n\thidden      bool       // hidden value from last sort\n\treverse     bool       // reverse value from last sort\n\thiddenfiles []string   // hiddenfiles value from last sort\n\tfilter      []string   // last filter for this directory\n\tignorecase  bool       // ignorecase value from last sort\n\tignoredia   bool       // ignoredia value from last sort\n\tlocale      string     // locale value from last sort\n\tnoPerm      bool       // whether lf has no permission to open the directory\n\tlines       []string   // lines of text to display if directory previews are enabled\n}\n\nfunc newDir(path string) *dir {\n\ttime := time.Now()\n\n\tfiles, err := readdir(path)\n\tif err != nil {\n\t\tlog.Printf(\"reading directory: %s\", err)\n\t}\n\n\treturn &dir{\n\t\tloading:  gOpts.dirpreviews, // Directory is loaded after previewer function exits.\n\t\tloadTime: time,\n\t\tpath:     path,\n\t\tfiles:    files,\n\t\tallFiles: files,\n\t\tnoPerm:   os.IsPermission(err),\n\t}\n}\n\nfunc normalize(s1, s2 string, ignorecase, ignoredia bool) (string, string) {\n\tif ignorecase {\n\t\ts1 = strings.ToLower(s1)\n\t\ts2 = strings.ToLower(s2)\n\t}\n\tif ignoredia {\n\t\ts1 = removeDiacritics(s1)\n\t\ts2 = removeDiacritics(s2)\n\t}\n\treturn s1, s2\n}\n\nfunc (dir *dir) sort() {\n\tdir.sortby = getSortBy(dir.path)\n\tdir.dirfirst = getDirFirst(dir.path)\n\tdir.dironly = getDirOnly(dir.path)\n\tdir.hidden = getHidden(dir.path)\n\tdir.reverse = getReverse(dir.path)\n\tdir.locale = getLocale(dir.path)\n\tdir.hiddenfiles = gOpts.hiddenfiles\n\tdir.ignorecase = gOpts.ignorecase\n\tdir.ignoredia = gOpts.ignoredia\n\n\tdir.files = dir.allFiles\n\n\t// reverse order cannot be applied after stable sorting, otherwise the order\n\t// of equivalent elements will be reversed\n\tswitch dir.sortby {\n\tcase naturalSort:\n\t\tif collator, err := makeCollator(dir.locale, collate.Numeric); err == nil {\n\t\t\tsort.SliceStable(dir.files, func(i, j int) bool {\n\t\t\t\ts1, s2 := normalize(dir.files[i].Name(), dir.files[j].Name(), dir.ignorecase, dir.ignoredia)\n\t\t\t\tresult := collator.CompareString(s1, s2)\n\t\t\t\tif !dir.reverse {\n\t\t\t\t\treturn result < 0\n\t\t\t\t} else {\n\t\t\t\t\treturn result > 0\n\t\t\t\t}\n\t\t\t})\n\t\t} else {\n\t\t\tsort.SliceStable(dir.files, func(i, j int) bool {\n\t\t\t\ts1, s2 := normalize(dir.files[i].Name(), dir.files[j].Name(), dir.ignorecase, dir.ignoredia)\n\t\t\t\tif !dir.reverse {\n\t\t\t\t\treturn naturalLess(s1, s2)\n\t\t\t\t} else {\n\t\t\t\t\treturn naturalLess(s2, s1)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\tcase nameSort:\n\t\tif collator, err := makeCollator(dir.locale); err == nil {\n\t\t\tsort.SliceStable(dir.files, func(i, j int) bool {\n\t\t\t\ts1, s2 := normalize(dir.files[i].Name(), dir.files[j].Name(), dir.ignorecase, dir.ignoredia)\n\t\t\t\tresult := collator.CompareString(s1, s2)\n\t\t\t\tif !dir.reverse {\n\t\t\t\t\treturn result < 0\n\t\t\t\t} else {\n\t\t\t\t\treturn result > 0\n\t\t\t\t}\n\t\t\t})\n\t\t} else {\n\t\t\tsort.SliceStable(dir.files, func(i, j int) bool {\n\t\t\t\ts1, s2 := normalize(dir.files[i].Name(), dir.files[j].Name(), dir.ignorecase, dir.ignoredia)\n\t\t\t\tif !dir.reverse {\n\t\t\t\t\treturn s1 < s2\n\t\t\t\t} else {\n\t\t\t\t\treturn s2 < s1\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\tcase sizeSort:\n\t\tsort.SliceStable(dir.files, func(i, j int) bool {\n\t\t\tif !dir.reverse {\n\t\t\t\treturn dir.files[i].TotalSize() < dir.files[j].TotalSize()\n\t\t\t} else {\n\t\t\t\treturn dir.files[j].TotalSize() < dir.files[i].TotalSize()\n\t\t\t}\n\t\t})\n\tcase timeSort:\n\t\tsort.SliceStable(dir.files, func(i, j int) bool {\n\t\t\tif !dir.reverse {\n\t\t\t\treturn dir.files[i].ModTime().Before(dir.files[j].ModTime())\n\t\t\t} else {\n\t\t\t\treturn dir.files[j].ModTime().Before(dir.files[i].ModTime())\n\t\t\t}\n\t\t})\n\tcase atimeSort:\n\t\tsort.SliceStable(dir.files, func(i, j int) bool {\n\t\t\tif !dir.reverse {\n\t\t\t\treturn dir.files[i].accessTime.Before(dir.files[j].accessTime)\n\t\t\t} else {\n\t\t\t\treturn dir.files[j].accessTime.Before(dir.files[i].accessTime)\n\t\t\t}\n\t\t})\n\tcase ctimeSort:\n\t\tsort.SliceStable(dir.files, func(i, j int) bool {\n\t\t\tif !dir.reverse {\n\t\t\t\treturn dir.files[i].changeTime.Before(dir.files[j].changeTime)\n\t\t\t} else {\n\t\t\t\treturn dir.files[j].changeTime.Before(dir.files[i].changeTime)\n\t\t\t}\n\t\t})\n\tcase extSort:\n\t\tsort.SliceStable(dir.files, func(i, j int) bool {\n\t\t\text1, ext2 := normalize(dir.files[i].ext, dir.files[j].ext, dir.ignorecase, dir.ignoredia)\n\t\t\tname1, name2 := normalize(dir.files[i].Name(), dir.files[j].Name(), dir.ignorecase, dir.ignoredia)\n\t\t\tif !dir.reverse {\n\t\t\t\treturn ext1 < ext2 || ext1 == ext2 && name1 < name2\n\t\t\t} else {\n\t\t\t\treturn ext2 < ext1 || ext2 == ext1 && name2 < name1\n\t\t\t}\n\t\t})\n\t}\n\n\tif dir.dirfirst {\n\t\tsort.SliceStable(dir.files, func(i, j int) bool {\n\t\t\tif dir.files[i].IsDir() == dir.files[j].IsDir() {\n\t\t\t\treturn i < j\n\t\t\t}\n\t\t\treturn dir.files[i].IsDir()\n\t\t})\n\t}\n\n\t// when dironly option is enabled, we move files to the beginning of our file\n\t// list and then set the beginning of displayed files to the first directory\n\t// in the list\n\tif dir.dironly {\n\t\tsort.SliceStable(dir.files, func(i, j int) bool {\n\t\t\tif !dir.files[i].IsDir() && !dir.files[j].IsDir() {\n\t\t\t\treturn i < j\n\t\t\t}\n\t\t\treturn !dir.files[i].IsDir()\n\t\t})\n\t\tdir.files = func() []*file {\n\t\t\tfor i, f := range dir.files {\n\t\t\t\tif f.IsDir() {\n\t\t\t\t\treturn dir.files[i:]\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dir.files[len(dir.files):]\n\t\t}()\n\t}\n\n\t// when hidden option is disabled, we move hidden files to the\n\t// beginning of our file list and then set the beginning of displayed\n\t// files to the first non-hidden file in the list\n\tif !dir.hidden {\n\t\tsort.SliceStable(dir.files, func(i, j int) bool {\n\t\t\tif isHidden(dir.files[i], dir.path, dir.hiddenfiles) && isHidden(dir.files[j], dir.path, dir.hiddenfiles) {\n\t\t\t\treturn i < j\n\t\t\t}\n\t\t\treturn isHidden(dir.files[i], dir.path, dir.hiddenfiles)\n\t\t})\n\t\tfor i, f := range dir.files {\n\t\t\tif !isHidden(f, dir.path, dir.hiddenfiles) {\n\t\t\t\tdir.files = dir.files[i:]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif len(dir.files) > 0 && isHidden(dir.files[len(dir.files)-1], dir.path, dir.hiddenfiles) {\n\t\t\tdir.files = dir.files[len(dir.files):]\n\t\t}\n\t}\n\n\tif len(dir.filter) != 0 {\n\t\tsort.SliceStable(dir.files, func(i, j int) bool {\n\t\t\tif isFiltered(dir.files[i], dir.filter) && isFiltered(dir.files[j], dir.filter) {\n\t\t\t\treturn i < j\n\t\t\t}\n\t\t\treturn isFiltered(dir.files[i], dir.filter)\n\t\t})\n\t\tfor i, f := range dir.files {\n\t\t\tif !isFiltered(f, dir.filter) {\n\t\t\t\tdir.files = dir.files[i:]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif len(dir.files) > 0 && isFiltered(dir.files[len(dir.files)-1], dir.filter) {\n\t\t\tdir.files = dir.files[len(dir.files):]\n\t\t}\n\t}\n\n\tdir.ind = max(dir.ind, 0)\n\tdir.ind = min(dir.ind, len(dir.files)-1)\n}\n\nfunc (dir *dir) name() string {\n\tif len(dir.files) == 0 {\n\t\treturn \"\"\n\t}\n\n\treturn dir.files[dir.ind].Name()\n}\n\nfunc (dir *dir) sel(name string, height int) {\n\tif len(dir.files) == 0 {\n\t\tdir.ind, dir.pos = 0, 0\n\t\treturn\n\t}\n\n\tdir.ind = max(dir.ind, 0)\n\tdir.ind = min(dir.ind, len(dir.files)-1)\n\n\tif dir.files[dir.ind].Name() != name {\n\t\tfor i, f := range dir.files {\n\t\t\tif f.Name() == name {\n\t\t\t\tdir.ind = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tdir.boundPos(height)\n}\n\nfunc (dir *dir) boundPos(height int) {\n\tif len(dir.files) <= height {\n\t\tdir.pos = dir.ind\n\t\treturn\n\t}\n\n\tedge := min(height/2, gOpts.scrolloff)\n\tdir.pos = max(dir.pos, edge)\n\n\t// use a smaller value for half when the height is even and scrolloff is\n\t// maxed in order to stay at the same row while scrolling up and down\n\tif height%2 == 0 {\n\t\tedge = min(height/2-1, gOpts.scrolloff)\n\t}\n\tdir.pos = min(dir.pos, height-1-edge)\n\n\tdir.pos = min(dir.pos, dir.ind)\n\tdir.pos = max(dir.pos, height-(len(dir.files)-dir.ind))\n}\n\ntype nav struct {\n\tinit            bool\n\tdirs            []*dir\n\tcopyBytes       int64\n\tcopyTotal       int64\n\tcopyUpdate      int\n\tmoveCount       int\n\tmoveTotal       int\n\tmoveUpdate      int\n\tdeleteCount     int\n\tdeleteTotal     int\n\tdeleteUpdate    int\n\tcopyBytesChan   chan int64\n\tcopyTotalChan   chan int64\n\tmoveCountChan   chan int\n\tmoveTotalChan   chan int\n\tdeleteCountChan chan int\n\tdeleteTotalChan chan int\n\tpreviewChan     chan string\n\tdirPreviewChan  chan *dir\n\tdirChan         chan *dir\n\tregChan         chan *reg\n\tfileChan        chan *file\n\tdelChan         chan string\n\tdirCache        map[string]*dir\n\tregCache        map[string]*reg\n\tsaves           map[string]bool\n\tmarks           map[string]string\n\trenameOldPath   string\n\trenameNewPath   string\n\tselections      map[string]int\n\ttags            map[string]string\n\tselectionInd    int\n\theight          int\n\tfind            string\n\tfindBack        bool\n\tsearch          string\n\tsearchBack      bool\n\tsearchInd       int\n\tsearchPos       int\n\tprevFilter      []string\n\tvolatilePreview bool\n\tpreviewTimer    *time.Timer\n\tpreviewLoading  bool\n\tjumpList        []string\n\tjumpListInd     int\n}\n\nfunc (nav *nav) loadDirInternal(path string) *dir {\n\tnav.startPreview()\n\n\td := &dir{\n\t\tloading:     true,\n\t\tloadTime:    time.Now(),\n\t\tpath:        path,\n\t\tsortby:      getSortBy(path),\n\t\tdirfirst:    getDirFirst(path),\n\t\tdironly:     getDirOnly(path),\n\t\thidden:      getHidden(path),\n\t\treverse:     getReverse(path),\n\t\tlocale:      getLocale(path),\n\t\thiddenfiles: gOpts.hiddenfiles,\n\t\tignorecase:  gOpts.ignorecase,\n\t\tignoredia:   gOpts.ignoredia,\n\t}\n\tgo func() {\n\t\td := newDir(path)\n\t\td.sort()\n\t\td.ind, d.pos = 0, 0\n\t\tif gOpts.dirpreviews {\n\t\t\tnav.dirPreviewChan <- d\n\t\t}\n\t\tnav.dirChan <- d\n\t}()\n\treturn d\n}\n\nfunc (nav *nav) loadDir(path string) *dir {\n\tif gOpts.dircache {\n\t\td, ok := nav.dirCache[path]\n\t\tif !ok {\n\t\t\td = nav.loadDirInternal(path)\n\t\t\tnav.dirCache[path] = d\n\t\t\treturn d\n\t\t}\n\n\t\tnav.checkDir(d)\n\n\t\treturn d\n\t}\n\treturn nav.loadDirInternal(path)\n}\n\nfunc (nav *nav) checkDir(dir *dir) {\n\ts, err := os.Stat(dir.path)\n\tif err != nil {\n\t\tlog.Printf(\"getting directory info: %s\", err)\n\t\treturn\n\t}\n\n\tswitch {\n\tcase s.ModTime().After(dir.loadTime):\n\t\tnow := time.Now()\n\n\t\t// XXX: Linux builtin exFAT drivers are able to predict modifications in the future\n\t\t// https://bugs.launchpad.net/ubuntu/+source/ubuntu-meta/+bug/1872504\n\t\tif s.ModTime().After(now) {\n\t\t\treturn\n\t\t}\n\n\t\tnav.startPreview()\n\t\tdir.loading = true\n\t\tdir.loadTime = now\n\t\tgo func() {\n\t\t\tnd := newDir(dir.path)\n\t\t\tif gOpts.dirpreviews {\n\t\t\t\tnav.dirPreviewChan <- nd\n\t\t\t}\n\t\t\tnav.dirChan <- nd\n\t\t}()\n\tcase dir.sortby != getSortBy(dir.path) ||\n\t\tdir.dirfirst != getDirFirst(dir.path) ||\n\t\tdir.dironly != getDirOnly(dir.path) ||\n\t\tdir.hidden != getHidden(dir.path) ||\n\t\tdir.reverse != getReverse(dir.path) ||\n\t\tdir.locale != getLocale(dir.path) ||\n\t\t!reflect.DeepEqual(dir.hiddenfiles, gOpts.hiddenfiles) ||\n\t\tdir.ignorecase != gOpts.ignorecase ||\n\t\tdir.ignoredia != gOpts.ignoredia:\n\t\tdir.loading = true\n\t\tsd := *dir\n\t\tgo func() {\n\t\t\tsd.sort()\n\t\t\tsd.loading = false\n\t\t\tnav.dirChan <- &sd\n\t\t}()\n\t}\n}\n\nfunc (nav *nav) getDirs(wd string) {\n\tvar dirs []*dir\n\n\twd = filepath.Clean(wd)\n\n\tfor curr, base := wd, \"\"; !isRoot(base); curr, base = filepath.Dir(curr), filepath.Base(curr) {\n\t\tdir := nav.loadDir(curr)\n\t\tif base != \"\" {\n\t\t\tdir.sel(base, nav.height)\n\t\t}\n\t\tdirs = append(dirs, dir)\n\t}\n\n\tfor i, j := 0, len(dirs)-1; i < j; i, j = i+1, j-1 {\n\t\tdirs[i], dirs[j] = dirs[j], dirs[i]\n\t}\n\n\tnav.dirs = dirs\n}\n\nfunc newNav(height int) *nav {\n\tnav := &nav{\n\t\tcopyBytesChan:   make(chan int64, 1024),\n\t\tcopyTotalChan:   make(chan int64, 1024),\n\t\tmoveCountChan:   make(chan int, 1024),\n\t\tmoveTotalChan:   make(chan int, 1024),\n\t\tdeleteCountChan: make(chan int, 1024),\n\t\tdeleteTotalChan: make(chan int, 1024),\n\t\tpreviewChan:     make(chan string, 1024),\n\t\tdirPreviewChan:  make(chan *dir, 1024),\n\t\tdirChan:         make(chan *dir),\n\t\tregChan:         make(chan *reg),\n\t\tfileChan:        make(chan *file),\n\t\tdelChan:         make(chan string),\n\t\tdirCache:        make(map[string]*dir),\n\t\tregCache:        make(map[string]*reg),\n\t\tsaves:           make(map[string]bool),\n\t\tmarks:           make(map[string]string),\n\t\tselections:      make(map[string]int),\n\t\ttags:            make(map[string]string),\n\t\tselectionInd:    0,\n\t\theight:          height,\n\t\tpreviewTimer:    time.NewTimer(0),\n\t\tjumpList:        make([]string, 0),\n\t\tjumpListInd:     -1,\n\t}\n\n\treturn nav\n}\n\nfunc (nav *nav) addJumpList() {\n\tcurrPath := nav.currDir().path\n\tif nav.jumpListInd >= 0 && nav.jumpListInd < len(nav.jumpList)-1 {\n\t\tif nav.jumpList[nav.jumpListInd] == currPath {\n\t\t\t// walking the jumpList\n\t\t\treturn\n\t\t}\n\t\tnav.jumpList = nav.jumpList[:nav.jumpListInd+1]\n\t}\n\tif len(nav.jumpList) == 0 || nav.jumpList[len(nav.jumpList)-1] != currPath {\n\t\tnav.jumpList = append(nav.jumpList, currPath)\n\t}\n\tnav.jumpListInd = len(nav.jumpList) - 1\n}\n\nfunc (nav *nav) cdJumpListPrev() {\n\tif nav.jumpListInd > 0 {\n\t\tnav.jumpListInd -= 1\n\t\tnav.cd(nav.jumpList[nav.jumpListInd])\n\t}\n}\n\nfunc (nav *nav) cdJumpListNext() {\n\tif nav.jumpListInd < len(nav.jumpList)-1 {\n\t\tnav.jumpListInd += 1\n\t\tnav.cd(nav.jumpList[nav.jumpListInd])\n\t}\n}\n\nfunc (nav *nav) renew() {\n\tfor _, d := range nav.dirs {\n\t\tnav.checkDir(d)\n\t}\n\n\tfor m := range nav.selections {\n\t\tif _, err := os.Lstat(m); os.IsNotExist(err) {\n\t\t\tdelete(nav.selections, m)\n\t\t}\n\t}\n\n\tif len(nav.selections) == 0 {\n\t\tnav.selectionInd = 0\n\t}\n}\n\nfunc (nav *nav) reload() error {\n\tnav.dirCache = make(map[string]*dir)\n\tnav.regCache = make(map[string]*reg)\n\n\tcurr, err := nav.currFile()\n\tnav.getDirs(nav.currDir().path)\n\tif err == nil {\n\t\tlast := nav.dirs[len(nav.dirs)-1]\n\t\tlast.files = append(last.files, curr)\n\t}\n\n\treturn nil\n}\n\nfunc (nav *nav) position() {\n\tif !nav.init {\n\t\treturn\n\t}\n\n\tpath := nav.currDir().path\n\tfor i := len(nav.dirs) - 2; i >= 0; i-- {\n\t\tnav.dirs[i].sel(filepath.Base(path), nav.height)\n\t\tpath = filepath.Dir(path)\n\t}\n}\n\nfunc (nav *nav) exportFiles() {\n\tif !nav.init {\n\t\treturn\n\t}\n\n\tvar currFile string\n\tif curr, err := nav.currFile(); err == nil {\n\t\tcurrFile = quoteString(curr.path)\n\t}\n\n\tvar selections []string\n\tfor _, selection := range nav.currSelections() {\n\t\tselections = append(selections, quoteString(selection))\n\t}\n\tcurrSelections := strings.Join(selections, gOpts.filesep)\n\n\tos.Setenv(\"f\", currFile)\n\tos.Setenv(\"fs\", currSelections)\n\tos.Setenv(\"PWD\", quoteString(nav.currDir().path))\n\n\tif len(selections) == 0 {\n\t\tos.Setenv(\"fx\", currFile)\n\t} else {\n\t\tos.Setenv(\"fx\", currSelections)\n\t}\n}\n\nfunc (nav *nav) dirPreviewLoop(ui *ui) {\n\tvar prevPath string\n\tfor dir := range nav.dirPreviewChan {\n\t\tif dir == nil && len(gOpts.previewer) != 0 && len(gOpts.cleaner) != 0 && nav.volatilePreview {\n\t\t\tcmd := exec.Command(gOpts.cleaner, prevPath)\n\t\t\tif err := cmd.Run(); err != nil {\n\t\t\t\tlog.Printf(\"cleaning preview: %s\", err)\n\t\t\t}\n\t\t\tnav.volatilePreview = false\n\t\t} else if dir != nil {\n\t\t\twin := ui.wins[len(ui.wins)-1]\n\t\t\tnav.previewDir(dir, win)\n\t\t\tprevPath = dir.path\n\t\t}\n\t}\n}\n\nfunc (nav *nav) previewLoop(ui *ui) {\n\tvar prev string\n\tfor path := range nav.previewChan {\n\t\tclear := len(path) == 0\n\tloop:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase path = <-nav.previewChan:\n\t\t\t\tclear = clear || len(path) == 0\n\t\t\tdefault:\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t}\n\t\twin := ui.wins[len(ui.wins)-1]\n\t\tif clear && len(gOpts.previewer) != 0 && len(gOpts.cleaner) != 0 && nav.volatilePreview {\n\t\t\tcmd := exec.Command(gOpts.cleaner, prev,\n\t\t\t\tstrconv.Itoa(win.w),\n\t\t\t\tstrconv.Itoa(win.h),\n\t\t\t\tstrconv.Itoa(win.x),\n\t\t\t\tstrconv.Itoa(win.y),\n\t\t\t\tpath)\n\t\t\tif err := cmd.Run(); err != nil {\n\t\t\t\tlog.Printf(\"cleaning preview: %s\", err)\n\t\t\t}\n\t\t\tnav.volatilePreview = false\n\t\t}\n\t\tif len(path) != 0 {\n\t\t\tnav.preview(path, win)\n\t\t\tprev = path\n\t\t}\n\t}\n}\n\nfunc matchPattern(pattern, name, path string) bool {\n\ts := name\n\n\tpattern = replaceTilde(pattern)\n\n\tif filepath.IsAbs(pattern) {\n\t\ts = filepath.Join(path, name)\n\t}\n\n\t// pattern errors are checked when 'hiddenfiles' option is set\n\tmatched, _ := filepath.Match(pattern, s)\n\n\treturn matched\n}\n\nfunc (nav *nav) previewDir(dir *dir, win *win) {\n\tdefer func() {\n\t\tdir.loading = false\n\t\tnav.dirChan <- dir\n\t}()\n\n\tvar reader io.Reader\n\n\tif len(gOpts.previewer) != 0 {\n\t\tcmd := exec.Command(gOpts.previewer, dir.path,\n\t\t\tstrconv.Itoa(win.w),\n\t\t\tstrconv.Itoa(win.h),\n\t\t\tstrconv.Itoa(win.x),\n\t\t\tstrconv.Itoa(win.y))\n\n\t\tout, err := cmd.StdoutPipe()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"previewing dir: %s\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif err := cmd.Start(); err != nil {\n\t\t\tlog.Printf(\"previewing dir: %s\", err)\n\t\t\tout.Close()\n\t\t\treturn\n\t\t}\n\n\t\tdefer func() {\n\t\t\tif err := cmd.Wait(); err != nil {\n\t\t\t\tif e, ok := err.(*exec.ExitError); ok {\n\t\t\t\t\tif e.ExitCode() != 0 {\n\t\t\t\t\t\tnav.volatilePreview = true\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlog.Printf(\"loading dir: %s\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tdefer out.Close()\n\t\treader = out\n\t\tbuf := bufio.NewScanner(reader)\n\n\t\tfor i := 0; i < win.h && buf.Scan(); i++ {\n\t\t\tfor _, r := range buf.Text() {\n\t\t\t\tif r == 0 {\n\t\t\t\t\tdir.lines = []string{\"\\033[7mbinary\\033[0m\"}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tdir.lines = append(dir.lines, buf.Text())\n\t\t}\n\n\t\tif buf.Err() != nil {\n\t\t\tlog.Printf(\"loading dir: %s\", buf.Err())\n\t\t}\n\t}\n}\n\nfunc (nav *nav) preview(path string, win *win) {\n\treg := &reg{loadTime: time.Now(), path: path}\n\tdefer func() { nav.regChan <- reg }()\n\n\tvar reader *bufio.Reader\n\n\tif len(gOpts.previewer) != 0 {\n\t\tcmd := exec.Command(gOpts.previewer, path,\n\t\t\tstrconv.Itoa(win.w),\n\t\t\tstrconv.Itoa(win.h),\n\t\t\tstrconv.Itoa(win.x),\n\t\t\tstrconv.Itoa(win.y))\n\n\t\tout, err := cmd.StdoutPipe()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"previewing file: %s\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif err := cmd.Start(); err != nil {\n\t\t\tlog.Printf(\"previewing file: %s\", err)\n\t\t\tout.Close()\n\t\t\treturn\n\t\t}\n\n\t\tdefer func() {\n\t\t\tif err := cmd.Wait(); err != nil {\n\t\t\t\tif e, ok := err.(*exec.ExitError); ok {\n\t\t\t\t\tif e.ExitCode() != 0 {\n\t\t\t\t\t\treg.volatile = true\n\t\t\t\t\t\tnav.volatilePreview = true\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlog.Printf(\"loading file: %s\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tdefer out.Close()\n\t\treader = bufio.NewReader(out)\n\t} else {\n\t\tf, err := os.Open(path)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"opening file: %s\", err)\n\t\t\treturn\n\t\t}\n\n\t\tdefer f.Close()\n\t\treader = bufio.NewReader(f)\n\t}\n\n\tif gOpts.sixel {\n\t\tprefix, err := reader.Peek(2)\n\t\tif err == nil && string(prefix) == gSixelBegin {\n\t\t\tb, err := io.ReadAll(reader)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"loading sixel: %s\", err)\n\t\t\t}\n\t\t\tstr := string(b)\n\t\t\treg.sixel = &str\n\t\t\treturn\n\t\t}\n\t}\n\n\t// bufio.Scanner can't handle files containing long lines if they exceed the\n\t// size of its internal buffer\n\tline := []byte{}\n\tfor len(reg.lines) < win.h {\n\t\tbytes, isPrefix, err := reader.ReadLine()\n\t\tif err != nil {\n\t\t\tif len(line) > 0 {\n\t\t\t\treg.lines = append(reg.lines, string(line))\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tfor _, byte := range bytes {\n\t\t\tif byte == 0 {\n\t\t\t\treg.lines = []string{\"\\033[7mbinary\\033[0m\"}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tline = append(line, bytes...)\n\n\t\tif !isPrefix {\n\t\t\treg.lines = append(reg.lines, string(line))\n\t\t\tline = []byte{}\n\t\t}\n\t}\n}\n\nfunc (nav *nav) loadReg(path string, volatile bool) *reg {\n\tr, ok := nav.regCache[path]\n\tif !ok || (volatile && r.volatile) {\n\t\tr := &reg{loading: true, loadTime: time.Now(), path: path, volatile: true}\n\t\tnav.regCache[path] = r\n\t\tnav.startPreview()\n\t\tnav.previewChan <- path\n\t\treturn r\n\t}\n\n\tnav.checkReg(r)\n\n\treturn r\n}\n\nfunc (nav *nav) checkReg(reg *reg) {\n\ts, err := os.Stat(reg.path)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tnow := time.Now()\n\n\t// XXX: Linux builtin exFAT drivers are able to predict modifications in the future\n\t// https://bugs.launchpad.net/ubuntu/+source/ubuntu-meta/+bug/1872504\n\tif s.ModTime().After(now) {\n\t\treturn\n\t}\n\n\tif s.ModTime().After(reg.loadTime) {\n\t\treg.loadTime = now\n\t\tnav.startPreview()\n\t\tnav.previewChan <- reg.path\n\t}\n}\n\nfunc (nav *nav) startPreview() {\n\tnav.previewTimer.Stop()\n\tnav.previewLoading = false\n\tnav.previewTimer.Reset(100 * time.Millisecond)\n}\n\nfunc (nav *nav) sort() {\n\tfor _, d := range nav.dirs {\n\t\tname := d.name()\n\t\td.sort()\n\t\td.sel(name, nav.height)\n\t}\n}\n\nfunc (nav *nav) setFilter(filter []string) error {\n\tnewfilter := []string{}\n\tfor _, tok := range filter {\n\t\t_, err := filepath.Match(tok, \"a\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif tok != \"\" {\n\t\t\tnewfilter = append(newfilter, tok)\n\t\t}\n\t}\n\tdir := nav.currDir()\n\tdir.filter = newfilter\n\n\t// Apply filter, by sorting current dir (see nav.sort())\n\tname := dir.name()\n\tdir.sort()\n\tdir.sel(name, nav.height)\n\treturn nil\n}\n\nfunc (nav *nav) up(dist int) bool {\n\tdir := nav.currDir()\n\n\told := dir.ind\n\n\tif dir.ind == 0 {\n\t\tif gOpts.wrapscroll {\n\t\t\tnav.bottom()\n\t\t}\n\t\treturn old != dir.ind\n\t}\n\n\tdir.ind -= dist\n\tdir.ind = max(0, dir.ind)\n\n\tdir.pos -= dist\n\tdir.boundPos(nav.height)\n\n\treturn old != dir.ind\n}\n\nfunc (nav *nav) down(dist int) bool {\n\tdir := nav.currDir()\n\n\told := dir.ind\n\n\tmaxind := len(dir.files) - 1\n\n\tif dir.ind >= maxind {\n\t\tif gOpts.wrapscroll {\n\t\t\tnav.top()\n\t\t}\n\t\treturn old != dir.ind\n\t}\n\n\tdir.ind += dist\n\tdir.ind = min(maxind, dir.ind)\n\n\tdir.pos += dist\n\tdir.boundPos(nav.height)\n\n\treturn old != dir.ind\n}\n\nfunc (nav *nav) scrollUp(dist int) bool {\n\tdir := nav.currDir()\n\n\t// when reached top do nothing\n\tif istop := dir.ind == dir.pos; istop {\n\t\treturn false\n\t}\n\n\told := dir.ind\n\n\tminedge := min(nav.height/2, gOpts.scrolloff)\n\n\tdir.pos += dist\n\n\t// jump to ensure minedge when edge < minedge\n\tedge := nav.height - dir.pos\n\tdelta := min(0, edge-minedge-1)\n\tdir.pos = min(dir.pos, nav.height-minedge-1)\n\t// update dir.ind accordingly\n\tdir.ind = dir.ind + delta\n\n\tdir.ind = min(dir.ind, dir.ind-(dir.pos-nav.height+1))\n\n\t// prevent cursor disappearing downwards\n\tdir.pos = min(dir.pos, nav.height-1)\n\n\treturn old != dir.ind\n}\n\nfunc (nav *nav) scrollDown(dist int) bool {\n\tdir := nav.currDir()\n\tmaxind := len(dir.files) - 1\n\n\t// reached bottom\n\tif dir.ind-dir.pos > maxind-nav.height {\n\t\treturn false\n\t}\n\n\told := dir.ind\n\n\tminedge := min(nav.height/2, gOpts.scrolloff)\n\n\tdir.pos -= dist\n\n\t// jump to ensure minedge when edge < minedge\n\tdelta := min(0, dir.pos-minedge)\n\tdir.pos = max(dir.pos, minedge)\n\t// update dir.ind accordingly\n\tdir.ind = dir.ind - delta\n\tdir.ind = max(dir.ind, dir.ind-(dir.pos-minedge))\n\n\tdir.ind = min(maxind, dir.ind)\n\t// prevent disappearing\n\tdir.pos = max(dir.pos, 0)\n\n\treturn old != dir.ind\n}\n\nfunc (nav *nav) updir() error {\n\tif len(nav.dirs) <= 1 {\n\t\treturn nil\n\t}\n\n\tdir := nav.currDir()\n\n\tnav.dirs = nav.dirs[:len(nav.dirs)-1]\n\n\tif err := os.Chdir(filepath.Dir(dir.path)); err != nil {\n\t\treturn fmt.Errorf(\"updir: %s\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (nav *nav) open() error {\n\tcurr, err := nav.currFile()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"open: %s\", err)\n\t}\n\n\tpath := curr.path\n\n\tdir := nav.loadDir(path)\n\n\tnav.dirs = append(nav.dirs, dir)\n\n\tif err := os.Chdir(path); err != nil {\n\t\treturn fmt.Errorf(\"open: %s\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (nav *nav) top() bool {\n\tdir := nav.currDir()\n\n\told := dir.ind\n\n\tdir.ind = 0\n\tdir.pos = 0\n\n\treturn old != dir.ind\n}\n\nfunc (nav *nav) bottom() bool {\n\tdir := nav.currDir()\n\n\told := dir.ind\n\n\tdir.ind = len(dir.files) - 1\n\tdir.pos = min(dir.ind, nav.height-1)\n\n\treturn old != dir.ind\n}\n\nfunc (nav *nav) high() bool {\n\tdir := nav.currDir()\n\n\told := dir.ind\n\tbeg := max(dir.ind-dir.pos, 0)\n\toffs := min(nav.height/2, gOpts.scrolloff)\n\tif beg == 0 {\n\t\toffs = 0\n\t}\n\n\tdir.ind = beg + offs\n\tdir.pos = offs\n\n\treturn old != dir.ind\n}\n\nfunc (nav *nav) middle() bool {\n\tdir := nav.currDir()\n\n\told := dir.ind\n\tbeg := max(dir.ind-dir.pos, 0)\n\tend := min(beg+nav.height, len(dir.files))\n\n\thalf := (end - beg) / 2\n\tdir.ind = beg + half\n\tdir.pos = half\n\n\treturn old != dir.ind\n}\n\nfunc (nav *nav) low() bool {\n\tdir := nav.currDir()\n\n\told := dir.ind\n\tbeg := max(dir.ind-dir.pos, 0)\n\tend := min(beg+nav.height, len(dir.files))\n\n\toffs := min(nav.height/2, gOpts.scrolloff)\n\t// use a smaller value for half when the height is even and scrolloff is\n\t// maxed in order to stay at the same row when using both high and low\n\tif nav.height%2 == 0 {\n\t\toffs = min(nav.height/2-1, gOpts.scrolloff)\n\t}\n\n\tif end == len(dir.files) {\n\t\toffs = 0\n\t}\n\n\tdir.ind = end - 1 - offs\n\tdir.pos = end - beg - 1 - offs\n\n\treturn old != dir.ind\n}\n\nfunc (nav *nav) move(index int) bool {\n\told := nav.currDir().ind\n\n\tswitch {\n\tcase index < old:\n\t\treturn nav.up(old - index)\n\tcase index > old:\n\t\treturn nav.down(index - old)\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (nav *nav) toggleSelection(path string) {\n\tif _, ok := nav.selections[path]; ok {\n\t\tdelete(nav.selections, path)\n\t\tif len(nav.selections) == 0 {\n\t\t\tnav.selectionInd = 0\n\t\t}\n\t} else {\n\t\tnav.selections[path] = nav.selectionInd\n\t\tnav.selectionInd++\n\t}\n}\n\nfunc (nav *nav) toggle() {\n\tcurr, err := nav.currFile()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tnav.toggleSelection(curr.path)\n}\n\nfunc (nav *nav) tagToggleSelection(path string, tag string) {\n\tif _, ok := nav.tags[path]; ok {\n\t\tdelete(nav.tags, path)\n\t} else {\n\t\tnav.tags[path] = tag\n\t}\n}\n\nfunc (nav *nav) tagToggle(tag string) error {\n\tlist, err := nav.currFileOrSelections()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif printLength(tag) != 1 {\n\t\treturn errors.New(\"tag should be single width character\")\n\t}\n\n\tfor _, path := range list {\n\t\tnav.tagToggleSelection(path, tag)\n\t}\n\n\treturn nil\n}\n\nfunc (nav *nav) tag(tag string) error {\n\tlist, err := nav.currFileOrSelections()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif printLength(tag) != 1 {\n\t\treturn errors.New(\"tag should be single width character\")\n\t}\n\n\tfor _, path := range list {\n\t\tnav.tags[path] = tag\n\t}\n\n\treturn nil\n}\n\nfunc (nav *nav) invertAfter(ix int) {\n\tdir := nav.currDir()\n\tfor _, f := range dir.files[ix:] {\n\t\tpath := filepath.Join(dir.path, f.Name())\n\t\tnav.toggleSelection(path)\n\t}\n}\n\nfunc (nav *nav) invert() {\n\tnav.invertAfter(0)\n}\n\nfunc (nav *nav) invertBelow() {\n\tnav.invertAfter(nav.currDir().ind)\n}\n\nfunc (nav *nav) unselect() {\n\tnav.selections = make(map[string]int)\n\tnav.selectionInd = 0\n}\n\nfunc (nav *nav) save(cp bool) error {\n\tlist, err := nav.currFileOrSelections()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := saveFiles(list, cp); err != nil {\n\t\treturn err\n\t}\n\n\tnav.saves = make(map[string]bool)\n\tfor _, f := range list {\n\t\tnav.saves[f] = cp\n\t}\n\n\treturn nil\n}\n\nfunc (nav *nav) copyAsync(app *app, srcs []string, dstDir string) {\n\techo := &callExpr{\"echoerr\", []string{\"\"}, 1}\n\n\t_, err := os.Stat(dstDir)\n\tif os.IsNotExist(err) {\n\t\techo.args[0] = err.Error()\n\t\tapp.ui.exprChan <- echo\n\t\treturn\n\t}\n\n\ttotal, err := copySize(srcs)\n\tif err != nil {\n\t\techo.args[0] = err.Error()\n\t\tapp.ui.exprChan <- echo\n\t\treturn\n\t}\n\n\tnav.copyTotalChan <- total\n\n\tnums, errs := copyAll(srcs, dstDir, gOpts.preserve)\n\n\terrCount := 0\nloop:\n\tfor {\n\t\tselect {\n\t\tcase n := <-nums:\n\t\t\tnav.copyBytesChan <- n\n\t\tcase err, ok := <-errs:\n\t\t\tif !ok {\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t\terrCount++\n\t\t\techo.args[0] = fmt.Sprintf(\"[%d] %s\", errCount, err)\n\t\t\tapp.ui.exprChan <- echo\n\t\t}\n\t}\n\n\tnav.copyTotalChan <- -total\n\n\tif gSingleMode {\n\t\tnav.renew()\n\t\tapp.ui.loadFile(app, true)\n\t} else {\n\t\tif err := remote(\"send load\"); err != nil {\n\t\t\terrCount++\n\t\t\techo.args[0] = fmt.Sprintf(\"[%d] %s\", errCount, err)\n\t\t\tapp.ui.exprChan <- echo\n\t\t}\n\t}\n\n\tif errCount == 0 {\n\t\tapp.ui.exprChan <- &callExpr{\"echo\", []string{\"\\033[0;32mCopied successfully\\033[0m\"}, 1}\n\t}\n}\n\nfunc (nav *nav) moveAsync(app *app, srcs []string, dstDir string) {\n\techo := &callExpr{\"echoerr\", []string{\"\"}, 1}\n\n\t_, err := os.Stat(dstDir)\n\tif os.IsNotExist(err) {\n\t\techo.args[0] = err.Error()\n\t\tapp.ui.exprChan <- echo\n\t\treturn\n\t}\n\n\tnav.moveTotalChan <- len(srcs)\n\n\terrCount := 0\n\tfor _, src := range srcs {\n\t\tnav.moveCountChan <- 1\n\n\t\tsrcStat, err := os.Lstat(src)\n\t\tif err != nil {\n\t\t\terrCount++\n\t\t\techo.args[0] = fmt.Sprintf(\"[%d] %s\", errCount, err)\n\t\t\tapp.ui.exprChan <- echo\n\t\t\tcontinue\n\t\t}\n\n\t\tfile := filepath.Base(src)\n\t\tdst := filepath.Join(dstDir, file)\n\n\t\tdstStat, err := os.Stat(dst)\n\t\tif os.SameFile(srcStat, dstStat) {\n\t\t\terrCount++\n\t\t\techo.args[0] = fmt.Sprintf(\"[%d] rename %s %s: source and destination are the same file\", errCount, src, dst)\n\t\t\tapp.ui.exprChan <- echo\n\t\t\tcontinue\n\t\t} else if !os.IsNotExist(err) {\n\t\t\text := getFileExtension(dstStat)\n\t\t\tbasename := file[:len(file)-len(ext)]\n\t\t\tvar newPath string\n\t\t\tfor i := 1; !os.IsNotExist(err); i++ {\n\t\t\t\tfile = strings.ReplaceAll(gOpts.dupfilefmt, \"%f\", basename+ext)\n\t\t\t\tfile = strings.ReplaceAll(file, \"%b\", basename)\n\t\t\t\tfile = strings.ReplaceAll(file, \"%e\", ext)\n\t\t\t\tfile = strings.ReplaceAll(file, \"%n\", strconv.Itoa(i))\n\t\t\t\tnewPath = filepath.Join(dstDir, file)\n\t\t\t\t_, err = os.Lstat(newPath)\n\t\t\t}\n\t\t\tdst = newPath\n\t\t}\n\n\t\tif err := os.Rename(src, dst); err != nil {\n\t\t\tif errCrossDevice(err) {\n\t\t\t\ttotal, err := copySize([]string{src})\n\t\t\t\tif err != nil {\n\t\t\t\t\techo.args[0] = err.Error()\n\t\t\t\t\tapp.ui.exprChan <- echo\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tnav.copyTotalChan <- total\n\n\t\t\t\tnums, errs := copyAll([]string{src}, dstDir, []string{\"mode\", \"timestamps\"})\n\n\t\t\t\toldCount := errCount\n\t\t\tloop:\n\t\t\t\tfor {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase n := <-nums:\n\t\t\t\t\t\tnav.copyBytesChan <- n\n\t\t\t\t\tcase err, ok := <-errs:\n\t\t\t\t\t\tif !ok {\n\t\t\t\t\t\t\tbreak loop\n\t\t\t\t\t\t}\n\t\t\t\t\t\terrCount++\n\t\t\t\t\t\techo.args[0] = fmt.Sprintf(\"[%d] %s\", errCount, err)\n\t\t\t\t\t\tapp.ui.exprChan <- echo\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnav.copyTotalChan <- -total\n\n\t\t\t\tif errCount == oldCount {\n\t\t\t\t\tif err := os.RemoveAll(src); err != nil {\n\t\t\t\t\t\terrCount++\n\t\t\t\t\t\techo.args[0] = fmt.Sprintf(\"[%d] %s\", errCount, err)\n\t\t\t\t\t\tapp.ui.exprChan <- echo\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terrCount++\n\t\t\t\techo.args[0] = fmt.Sprintf(\"[%d] %s\", errCount, err)\n\t\t\t\tapp.ui.exprChan <- echo\n\t\t\t}\n\t\t}\n\t}\n\n\tnav.moveTotalChan <- -len(srcs)\n\n\tif gSingleMode {\n\t\tnav.renew()\n\t\tapp.ui.loadFile(app, true)\n\t} else {\n\t\tif err := remote(\"send load\"); err != nil {\n\t\t\terrCount++\n\t\t\techo.args[0] = fmt.Sprintf(\"[%d] %s\", errCount, err)\n\t\t\tapp.ui.exprChan <- echo\n\t\t}\n\t}\n\n\tif errCount == 0 {\n\t\tapp.ui.exprChan <- &callExpr{\"clear\", nil, 1}\n\t\tapp.ui.exprChan <- &callExpr{\"echo\", []string{\"\\033[0;32mMoved successfully\\033[0m\"}, 1}\n\t}\n}\n\nfunc (nav *nav) paste(app *app) error {\n\tsrcs, cp, err := loadFiles()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(srcs) == 0 {\n\t\treturn errors.New(\"no file in copy/cut buffer\")\n\t}\n\n\tdstDir := nav.currDir().path\n\n\tif cp {\n\t\tgo nav.copyAsync(app, srcs, dstDir)\n\t} else {\n\t\tgo nav.moveAsync(app, srcs, dstDir)\n\t}\n\n\treturn nil\n}\n\nfunc (nav *nav) del(app *app) error {\n\tlist, err := nav.currFileOrSelections()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tgo func() {\n\t\techo := &callExpr{\"echoerr\", []string{\"\"}, 1}\n\t\terrCount := 0\n\n\t\tnav.deleteTotalChan <- len(list)\n\n\t\tfor _, path := range list {\n\t\t\tnav.deleteCountChan <- 1\n\n\t\t\tif err := os.RemoveAll(path); err != nil {\n\t\t\t\terrCount++\n\t\t\t\techo.args[0] = fmt.Sprintf(\"[%d] %s\", errCount, err)\n\t\t\t\tapp.ui.exprChan <- echo\n\t\t\t}\n\t\t}\n\n\t\tnav.deleteTotalChan <- -len(list)\n\n\t\tif gSingleMode {\n\t\t\tnav.renew()\n\t\t\tapp.ui.loadFile(app, true)\n\t\t} else {\n\t\t\tif err := remote(\"send load\"); err != nil {\n\t\t\t\terrCount++\n\t\t\t\techo.args[0] = fmt.Sprintf(\"[%d] %s\", errCount, err)\n\t\t\t\tapp.ui.exprChan <- echo\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc (nav *nav) rename() error {\n\toldPath := nav.renameOldPath\n\tnewPath := nav.renameNewPath\n\n\tif err := os.Rename(oldPath, newPath); err != nil {\n\t\treturn err\n\t}\n\n\tlstat, err := os.Lstat(newPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// It is possible for newPath to already have cache entries if it previously\n\t// existed and was deleted. In this case the cache entries should be deleted\n\t// before loading newPath to prevent displaying a stale preview. However,\n\t// this clears only the current instance of lf, and not any other instances.\n\tdelete(nav.regCache, newPath)\n\tdelete(nav.dirCache, newPath)\n\tdir := nav.loadDir(filepath.Dir(newPath))\n\n\tif dir.loading {\n\t\tfor i := range dir.allFiles {\n\t\t\tif dir.allFiles[i].path == oldPath {\n\t\t\t\tdir.allFiles[i] = &file{FileInfo: lstat}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tdir.sort()\n\t}\n\n\tdir.sel(lstat.Name(), nav.height)\n\n\treturn nil\n}\n\nfunc (nav *nav) sync() error {\n\tlist, cp, err := loadFiles()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tnav.saves = make(map[string]bool)\n\tfor _, f := range list {\n\t\tnav.saves[f] = cp\n\t}\n\n\toldmarks := nav.marks\n\terrMarks := nav.readMarks()\n\tfor _, ch := range gOpts.tempmarks {\n\t\ttmp := string(ch)\n\t\tif v, e := oldmarks[tmp]; e {\n\t\t\tnav.marks[tmp] = v\n\t\t}\n\t}\n\terr = nav.readTags()\n\tif errMarks != nil {\n\t\treturn errMarks\n\t}\n\treturn err\n}\n\nfunc (nav *nav) cd(wd string) error {\n\twd = replaceTilde(wd)\n\twd = filepath.Clean(wd)\n\n\tif !filepath.IsAbs(wd) {\n\t\twd = filepath.Join(nav.currDir().path, wd)\n\t}\n\n\tif err := os.Chdir(wd); err != nil {\n\t\treturn fmt.Errorf(\"cd: %s\", err)\n\t}\n\n\tnav.getDirs(wd)\n\tnav.addJumpList()\n\treturn nil\n}\n\nfunc (nav *nav) sel(path string) error {\n\tpath = replaceTilde(path)\n\tpath = filepath.Clean(path)\n\n\tlstat, err := os.Lstat(path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"select: %s\", err)\n\t}\n\n\tdir := filepath.Dir(path)\n\n\tif err := nav.cd(dir); err != nil {\n\t\treturn fmt.Errorf(\"select: %s\", err)\n\t}\n\n\tbase := filepath.Base(path)\n\n\tlast := nav.currDir()\n\n\tif last.loading {\n\t\tlast.files = append(last.files, &file{FileInfo: lstat})\n\t}\n\n\tfor i, f := range last.files {\n\t\tif f.Name() == base {\n\t\t\tnav.move(i)\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (nav *nav) globSel(pattern string, invert bool) error {\n\tdir := nav.currDir()\n\tanyMatched := false\n\n\tfor i := 0; i < len(dir.files); i++ {\n\t\tmatched, err := filepath.Match(pattern, dir.files[i].Name())\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"glob-select: %s\", err)\n\t\t}\n\t\tif matched {\n\t\t\tanyMatched = true\n\t\t\tfpath := filepath.Join(dir.path, dir.files[i].Name())\n\t\t\tif _, ok := nav.selections[fpath]; ok == invert {\n\t\t\t\tnav.toggleSelection(fpath)\n\t\t\t}\n\t\t}\n\t}\n\n\tif !anyMatched {\n\t\treturn fmt.Errorf(\"glob-select: pattern not found: %s\", pattern)\n\t}\n\n\treturn nil\n}\n\nfunc findMatch(name, pattern string) bool {\n\tif gOpts.ignorecase {\n\t\tlpattern := strings.ToLower(pattern)\n\t\tif !gOpts.smartcase || lpattern == pattern {\n\t\t\tpattern = lpattern\n\t\t\tname = strings.ToLower(name)\n\t\t}\n\t}\n\tif gOpts.ignoredia {\n\t\tlpattern := removeDiacritics(pattern)\n\t\tif !gOpts.smartdia || lpattern == pattern {\n\t\t\tpattern = lpattern\n\t\t\tname = removeDiacritics(name)\n\t\t}\n\t}\n\tif gOpts.anchorfind {\n\t\treturn strings.HasPrefix(name, pattern)\n\t}\n\treturn strings.Contains(name, pattern)\n}\n\nfunc (nav *nav) findSingle() int {\n\tcount := 0\n\tindex := 0\n\tdir := nav.currDir()\n\tfor i := 0; i < len(dir.files); i++ {\n\t\tif findMatch(dir.files[i].Name(), nav.find) {\n\t\t\tcount++\n\t\t\tif count > 1 {\n\t\t\t\treturn count\n\t\t\t}\n\t\t\tindex = i\n\t\t}\n\t}\n\tif count == 1 {\n\t\tif index > dir.ind {\n\t\t\tnav.down(index - dir.ind)\n\t\t} else {\n\t\t\tnav.up(dir.ind - index)\n\t\t}\n\t}\n\treturn count\n}\n\nfunc (nav *nav) findNext() (bool, bool) {\n\tdir := nav.currDir()\n\tfor i := dir.ind + 1; i < len(dir.files); i++ {\n\t\tif findMatch(dir.files[i].Name(), nav.find) {\n\t\t\treturn nav.down(i - dir.ind), true\n\t\t}\n\t}\n\tif gOpts.wrapscan {\n\t\tfor i := 0; i < dir.ind; i++ {\n\t\t\tif findMatch(dir.files[i].Name(), nav.find) {\n\t\t\t\treturn nav.up(dir.ind - i), true\n\t\t\t}\n\t\t}\n\t}\n\treturn false, false\n}\n\nfunc (nav *nav) findPrev() (bool, bool) {\n\tdir := nav.currDir()\n\tfor i := dir.ind - 1; i >= 0; i-- {\n\t\tif findMatch(dir.files[i].Name(), nav.find) {\n\t\t\treturn nav.up(dir.ind - i), true\n\t\t}\n\t}\n\tif gOpts.wrapscan {\n\t\tfor i := len(dir.files) - 1; i > dir.ind; i-- {\n\t\t\tif findMatch(dir.files[i].Name(), nav.find) {\n\t\t\t\treturn nav.down(i - dir.ind), true\n\t\t\t}\n\t\t}\n\t}\n\treturn false, false\n}\n\nfunc searchMatch(name, pattern string, glob bool) (matched bool, err error) {\n\tif gOpts.ignorecase {\n\t\tlpattern := strings.ToLower(pattern)\n\t\tif !gOpts.smartcase || lpattern == pattern {\n\t\t\tpattern = lpattern\n\t\t\tname = strings.ToLower(name)\n\t\t}\n\t}\n\tif gOpts.ignoredia {\n\t\tlpattern := removeDiacritics(pattern)\n\t\tif !gOpts.smartdia || lpattern == pattern {\n\t\t\tpattern = lpattern\n\t\t\tname = removeDiacritics(name)\n\t\t}\n\t}\n\tif glob {\n\t\treturn filepath.Match(pattern, name)\n\t}\n\treturn strings.Contains(name, pattern), nil\n}\n\nfunc (nav *nav) searchNext() (bool, error) {\n\tdir := nav.currDir()\n\tfor i := dir.ind + 1; i < len(dir.files); i++ {\n\t\tif matched, err := searchMatch(dir.files[i].Name(), nav.search, gOpts.globsearch); err != nil {\n\t\t\treturn false, err\n\t\t} else if matched {\n\t\t\treturn nav.down(i - dir.ind), nil\n\t\t}\n\t}\n\tif gOpts.wrapscan {\n\t\tfor i := 0; i < dir.ind; i++ {\n\t\t\tif matched, err := searchMatch(dir.files[i].Name(), nav.search, gOpts.globsearch); err != nil {\n\t\t\t\treturn false, err\n\t\t\t} else if matched {\n\t\t\t\treturn nav.up(dir.ind - i), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn false, nil\n}\n\nfunc (nav *nav) searchPrev() (bool, error) {\n\tdir := nav.currDir()\n\tfor i := dir.ind - 1; i >= 0; i-- {\n\t\tif matched, err := searchMatch(dir.files[i].Name(), nav.search, gOpts.globsearch); err != nil {\n\t\t\treturn false, err\n\t\t} else if matched {\n\t\t\treturn nav.up(dir.ind - i), nil\n\t\t}\n\t}\n\tif gOpts.wrapscan {\n\t\tfor i := len(dir.files) - 1; i > dir.ind; i-- {\n\t\t\tif matched, err := searchMatch(dir.files[i].Name(), nav.search, gOpts.globsearch); err != nil {\n\t\t\t\treturn false, err\n\t\t\t} else if matched {\n\t\t\t\treturn nav.down(i - dir.ind), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn false, nil\n}\n\nfunc isFiltered(f os.FileInfo, filter []string) bool {\n\tfor _, pattern := range filter {\n\t\tmatched, err := searchMatch(f.Name(), strings.TrimPrefix(pattern, \"!\"), gOpts.globfilter)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Filter Error: %s\", err)\n\t\t\treturn false\n\t\t}\n\t\tif strings.HasPrefix(pattern, \"!\") && matched {\n\t\t\treturn true\n\t\t} else if !strings.HasPrefix(pattern, \"!\") && !matched {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (nav *nav) removeMark(mark string) error {\n\tif _, ok := nav.marks[mark]; ok {\n\t\tdelete(nav.marks, mark)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"no such mark\")\n}\n\nfunc (nav *nav) readMarks() error {\n\tnav.marks = make(map[string]string)\n\tf, err := os.Open(gMarksPath)\n\tif os.IsNotExist(err) {\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"opening marks file: %s\", err)\n\t}\n\tdefer f.Close()\n\n\tscanner := bufio.NewScanner(f)\n\tfor scanner.Scan() {\n\t\tmark, path, found := strings.Cut(scanner.Text(), \":\")\n\t\tif !found {\n\t\t\treturn fmt.Errorf(\"invalid marks file entry: %s\", scanner.Text())\n\t\t}\n\t\tif _, ok := nav.marks[mark]; !ok {\n\t\t\tnav.marks[mark] = path\n\t\t}\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\treturn fmt.Errorf(\"reading marks file: %s\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (nav *nav) writeMarks() error {\n\tif err := os.MkdirAll(filepath.Dir(gMarksPath), os.ModePerm); err != nil {\n\t\treturn fmt.Errorf(\"creating data directory: %s\", err)\n\t}\n\n\tf, err := os.Create(gMarksPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"creating marks file: %s\", err)\n\t}\n\tdefer f.Close()\n\n\tvar keys []string\n\tfor k := range nav.marks {\n\t\tif !strings.Contains(gOpts.tempmarks, k) {\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t}\n\tsort.Strings(keys)\n\n\tfor _, k := range keys {\n\t\t_, err = fmt.Fprintf(f, \"%s:%s\\n\", k, nav.marks[k])\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"writing marks file: %s\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (nav *nav) readTags() error {\n\tnav.tags = make(map[string]string)\n\tf, err := os.Open(gTagsPath)\n\tif os.IsNotExist(err) {\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"opening tags file: %s\", err)\n\t}\n\tdefer f.Close()\n\n\tscanner := bufio.NewScanner(f)\n\tfor scanner.Scan() {\n\t\ttext := scanner.Text()\n\n\t\tind := strings.LastIndex(text, \":\")\n\t\tif ind == -1 {\n\t\t\treturn fmt.Errorf(\"invalid tags file entry: %s\", text)\n\t\t}\n\n\t\tpath := text[0:ind]\n\t\ttag := text[ind+1:]\n\t\tif _, ok := nav.tags[path]; !ok {\n\t\t\tnav.tags[path] = tag\n\t\t}\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\treturn fmt.Errorf(\"reading tags file: %s\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (nav *nav) writeTags() error {\n\tif err := os.MkdirAll(filepath.Dir(gTagsPath), os.ModePerm); err != nil {\n\t\treturn fmt.Errorf(\"creating data directory: %s\", err)\n\t}\n\n\tf, err := os.Create(gTagsPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"creating tags file: %s\", err)\n\t}\n\tdefer f.Close()\n\n\tvar keys []string\n\tfor k := range nav.tags {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\n\tfor _, k := range keys {\n\t\t_, err = fmt.Fprintf(f, \"%s:%s\\n\", k, nav.tags[k])\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"writing tags file: %s\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (nav *nav) currDir() *dir {\n\treturn nav.dirs[len(nav.dirs)-1]\n}\n\nfunc (nav *nav) currFile() (*file, error) {\n\tdir := nav.dirs[len(nav.dirs)-1]\n\n\tif len(dir.files) == 0 {\n\t\treturn nil, fmt.Errorf(\"empty directory\")\n\t}\n\n\treturn dir.files[dir.ind], nil\n}\n\ntype indexedSelections struct {\n\tpaths   []string\n\tindices []int\n}\n\nfunc (m indexedSelections) Len() int { return len(m.paths) }\n\nfunc (m indexedSelections) Swap(i, j int) {\n\tm.paths[i], m.paths[j] = m.paths[j], m.paths[i]\n\tm.indices[i], m.indices[j] = m.indices[j], m.indices[i]\n}\n\nfunc (m indexedSelections) Less(i, j int) bool { return m.indices[i] < m.indices[j] }\n\nfunc (nav *nav) currSelections() []string {\n\tcurrDirOnly := gOpts.selmode == \"dir\"\n\tcurrDirPath := \"\"\n\tif currDirOnly {\n\t\t// select only from this directory\n\t\tcurrDirPath = nav.currDir().path\n\t}\n\n\tpaths := make([]string, 0, len(nav.selections))\n\tindices := make([]int, 0, len(nav.selections))\n\tfor path, index := range nav.selections {\n\t\tif !currDirOnly || filepath.Dir(path) == currDirPath {\n\t\t\tpaths = append(paths, path)\n\t\t\tindices = append(indices, index)\n\t\t}\n\t}\n\tsort.Sort(indexedSelections{paths: paths, indices: indices})\n\treturn paths\n}\n\nfunc (nav *nav) currFileOrSelections() (list []string, err error) {\n\tsel := nav.currSelections()\n\n\tif len(sel) == 0 {\n\t\tcurr, err := nav.currFile()\n\t\tif err != nil {\n\t\t\treturn nil, errors.New(\"no file selected\")\n\t\t}\n\t\treturn []string{curr.path}, nil\n\t}\n\treturn sel, nil\n}\n\nfunc (nav *nav) calcDirSize() error {\n\tcalc := func(f *file) error {\n\t\tif f.IsDir() {\n\t\t\ttotal, err := copySize([]string{f.path})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tf.dirSize = total\n\t\t}\n\t\treturn nil\n\t}\n\n\tif len(nav.selections) == 0 {\n\t\tcurr, err := nav.currFile()\n\t\tif err != nil {\n\t\t\treturn errors.New(\"no file selected\")\n\t\t}\n\t\treturn calc(curr)\n\t}\n\n\tfor sel := range nav.selections {\n\t\tlstat, err := os.Lstat(sel)\n\t\tif err != nil || !lstat.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tpath, name := filepath.Dir(sel), filepath.Base(sel)\n\t\tdir := nav.loadDir(path)\n\n\t\tfor _, f := range dir.files {\n\t\t\tif f.Name() == name {\n\t\t\t\terr := calc(f)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "opts.go",
          "type": "blob",
          "size": 11.9619140625,
          "content": "package main\n\nimport (\n\t\"path/filepath\"\n\t\"time\"\n)\n\n// String values match the sortby string sent by the user at startup\ntype sortMethod string\n\nconst (\n\tnaturalSort sortMethod = \"natural\"\n\tnameSort    sortMethod = \"name\"\n\tsizeSort    sortMethod = \"size\"\n\ttimeSort    sortMethod = \"time\"\n\tatimeSort   sortMethod = \"atime\"\n\tctimeSort   sortMethod = \"ctime\"\n\textSort     sortMethod = \"ext\"\n)\n\nfunc isValidSortMethod(method sortMethod) bool {\n\treturn method == naturalSort ||\n\t\tmethod == nameSort ||\n\t\tmethod == sizeSort ||\n\t\tmethod == timeSort ||\n\t\tmethod == atimeSort ||\n\t\tmethod == ctimeSort ||\n\t\tmethod == extSort\n}\n\nconst invalidSortErrorMessage = `sortby: value should either be 'natural', 'name', 'size', 'time', 'atime', 'ctime' or 'ext'`\n\nvar gOpts struct {\n\tanchorfind       bool\n\tautoquit         bool\n\tborderfmt        string\n\tcopyfmt          string\n\tcursoractivefmt  string\n\tcursorparentfmt  string\n\tcursorpreviewfmt string\n\tcutfmt           string\n\tdircache         bool\n\tdircounts        bool\n\tdirfirst         bool\n\tdironly          bool\n\tdirpreviews      bool\n\tdrawbox          bool\n\tdupfilefmt       string\n\tglobfilter       bool\n\tglobsearch       bool\n\thidden           bool\n\ticons            bool\n\tignorecase       bool\n\tignoredia        bool\n\tincfilter        bool\n\tincsearch        bool\n\tlocale           string\n\tmouse            bool\n\tnumber           bool\n\tpreview          bool\n\trelativenumber   bool\n\treverse          bool\n\troundbox         bool\n\tselectfmt        string\n\tshowbinds        bool\n\tsixel            bool\n\tsortby           sortMethod\n\tsmartcase        bool\n\tsmartdia         bool\n\twaitmsg          string\n\twatch            bool\n\twrapscan         bool\n\twrapscroll       bool\n\tfindlen          int\n\tperiod           int\n\tscrolloff        int\n\ttabstop          int\n\terrorfmt         string\n\tfilesep          string\n\tifs              string\n\tpreviewer        string\n\tcleaner          string\n\tpromptfmt        string\n\tselmode          string\n\tshell            string\n\tshellflag        string\n\tstatfmt          string\n\ttimefmt          string\n\tinfotimefmtnew   string\n\tinfotimefmtold   string\n\ttruncatechar     string\n\ttruncatepct      int\n\tratios           []int\n\thiddenfiles      []string\n\thistory          bool\n\tinfo             []string\n\trulerfmt         string\n\tpreserve         []string\n\tshellopts        []string\n\tkeys             map[string]expr\n\tcmdkeys          map[string]expr\n\tcmds             map[string]expr\n\tuser             map[string]string\n\ttempmarks        string\n\tnumberfmt        string\n\ttagfmt           string\n}\n\nvar gLocalOpts struct {\n\tsortbys   map[string]sortMethod\n\tdirfirsts map[string]bool\n\tdironlys  map[string]bool\n\thiddens   map[string]bool\n\treverses  map[string]bool\n\tinfos     map[string][]string\n\tlocales   map[string]string\n}\n\nfunc localOptPaths(path string) []string {\n\tlist := []string{path}\n\tfor curr := path; !isRoot(curr); curr = filepath.Dir(curr) {\n\t\tlist = append(list, curr+string(filepath.Separator))\n\t}\n\treturn list\n}\n\nfunc getDirFirst(path string) bool {\n\tfor _, key := range localOptPaths(path) {\n\t\tif val, ok := gLocalOpts.dirfirsts[key]; ok {\n\t\t\treturn val\n\t\t}\n\t}\n\treturn gOpts.dirfirst\n}\n\nfunc getDirOnly(path string) bool {\n\tfor _, key := range localOptPaths(path) {\n\t\tif val, ok := gLocalOpts.dironlys[key]; ok {\n\t\t\treturn val\n\t\t}\n\t}\n\treturn gOpts.dironly\n}\n\nfunc getHidden(path string) bool {\n\tfor _, key := range localOptPaths(path) {\n\t\tif val, ok := gLocalOpts.hiddens[key]; ok {\n\t\t\treturn val\n\t\t}\n\t}\n\treturn gOpts.hidden\n}\n\nfunc getInfo(path string) []string {\n\tfor _, key := range localOptPaths(path) {\n\t\tif val, ok := gLocalOpts.infos[key]; ok {\n\t\t\treturn val\n\t\t}\n\t}\n\treturn gOpts.info\n}\n\nfunc getReverse(path string) bool {\n\tfor _, key := range localOptPaths(path) {\n\t\tif val, ok := gLocalOpts.reverses[key]; ok {\n\t\t\treturn val\n\t\t}\n\t}\n\treturn gOpts.reverse\n}\n\nfunc getSortBy(path string) sortMethod {\n\tfor _, key := range localOptPaths(path) {\n\t\tif val, ok := gLocalOpts.sortbys[key]; ok {\n\t\t\treturn val\n\t\t}\n\t}\n\treturn gOpts.sortby\n}\n\nfunc getLocale(path string) string {\n\tfor _, key := range localOptPaths(path) {\n\t\tif val, ok := gLocalOpts.locales[key]; ok {\n\t\t\treturn val\n\t\t}\n\t}\n\treturn gOpts.locale\n}\n\nfunc init() {\n\tgOpts.anchorfind = true\n\tgOpts.autoquit = true\n\tgOpts.dircache = true\n\tgOpts.dircounts = false\n\tgOpts.dirfirst = true\n\tgOpts.dironly = false\n\tgOpts.dirpreviews = false\n\tgOpts.drawbox = false\n\tgOpts.dupfilefmt = \"%f.~%n~\"\n\tgOpts.borderfmt = \"\\033[0m\"\n\tgOpts.copyfmt = \"\\033[7;33m\"\n\tgOpts.cursoractivefmt = \"\\033[7m\"\n\tgOpts.cursorparentfmt = \"\\033[7m\"\n\tgOpts.cursorpreviewfmt = \"\\033[4m\"\n\tgOpts.cutfmt = \"\\033[7;31m\"\n\tgOpts.globfilter = false\n\tgOpts.globsearch = false\n\tgOpts.hidden = false\n\tgOpts.icons = false\n\tgOpts.ignorecase = true\n\tgOpts.ignoredia = true\n\tgOpts.incfilter = false\n\tgOpts.incsearch = false\n\tgOpts.locale = localeStrDisable\n\tgOpts.mouse = false\n\tgOpts.number = false\n\tgOpts.preview = true\n\tgOpts.relativenumber = false\n\tgOpts.reverse = false\n\tgOpts.roundbox = false\n\tgOpts.selectfmt = \"\\033[7;35m\"\n\tgOpts.showbinds = true\n\tgOpts.sixel = false\n\tgOpts.sortby = naturalSort\n\tgOpts.smartcase = true\n\tgOpts.smartdia = false\n\tgOpts.waitmsg = \"Press any key to continue\"\n\tgOpts.watch = false\n\tgOpts.wrapscan = true\n\tgOpts.wrapscroll = false\n\tgOpts.findlen = 1\n\tgOpts.period = 0\n\tgOpts.scrolloff = 0\n\tgOpts.tabstop = 8\n\tgOpts.errorfmt = \"\\033[7;31;47m\"\n\tgOpts.filesep = \"\\n\"\n\tgOpts.ifs = \"\"\n\tgOpts.previewer = \"\"\n\tgOpts.cleaner = \"\"\n\tgOpts.promptfmt = \"\\033[32;1m%u@%h\\033[0m:\\033[34;1m%d\\033[0m\\033[1m%f\\033[0m\"\n\tgOpts.selmode = \"all\"\n\tgOpts.shell = gDefaultShell\n\tgOpts.shellflag = gDefaultShellFlag\n\tgOpts.statfmt = \"\\033[36m%p\\033[0m| %c| %u| %g| %S| %t| -> %l\"\n\tgOpts.timefmt = time.ANSIC\n\tgOpts.infotimefmtnew = \"Jan _2 15:04\"\n\tgOpts.infotimefmtold = \"Jan _2  2006\"\n\tgOpts.truncatechar = \"~\"\n\tgOpts.truncatepct = 100\n\tgOpts.ratios = []int{1, 2, 3}\n\tgOpts.hiddenfiles = gDefaultHiddenFiles\n\tgOpts.history = true\n\tgOpts.info = nil\n\tgOpts.rulerfmt = \"  %a|  %p|  \\033[7;31m %m \\033[0m|  \\033[7;33m %c \\033[0m|  \\033[7;35m %s \\033[0m|  \\033[7;34m %f \\033[0m|  %i/%t\"\n\tgOpts.preserve = []string{\"mode\"}\n\tgOpts.shellopts = nil\n\tgOpts.tempmarks = \"'\"\n\tgOpts.numberfmt = \"\\033[33m\"\n\tgOpts.tagfmt = \"\\033[31m\"\n\n\tgOpts.keys = map[string]expr{\n\t\t\"k\":          &callExpr{\"up\", nil, 1},\n\t\t\"<up>\":       &callExpr{\"up\", nil, 1},\n\t\t\"<m-up>\":     &callExpr{\"up\", nil, 1},\n\t\t\"<c-u>\":      &callExpr{\"half-up\", nil, 1},\n\t\t\"<c-b>\":      &callExpr{\"page-up\", nil, 1},\n\t\t\"<pgup>\":     &callExpr{\"page-up\", nil, 1},\n\t\t\"<c-y>\":      &callExpr{\"scroll-up\", nil, 1},\n\t\t\"<c-m-up>\":   &callExpr{\"scroll-up\", nil, 1},\n\t\t\"j\":          &callExpr{\"down\", nil, 1},\n\t\t\"<down>\":     &callExpr{\"down\", nil, 1},\n\t\t\"<m-down>\":   &callExpr{\"down\", nil, 1},\n\t\t\"<c-d>\":      &callExpr{\"half-down\", nil, 1},\n\t\t\"<c-f>\":      &callExpr{\"page-down\", nil, 1},\n\t\t\"<pgdn>\":     &callExpr{\"page-down\", nil, 1},\n\t\t\"<c-e>\":      &callExpr{\"scroll-down\", nil, 1},\n\t\t\"<c-m-down>\": &callExpr{\"scroll-down\", nil, 1},\n\t\t\"h\":          &callExpr{\"updir\", nil, 1},\n\t\t\"<left>\":     &callExpr{\"updir\", nil, 1},\n\t\t\"l\":          &callExpr{\"open\", nil, 1},\n\t\t\"<right>\":    &callExpr{\"open\", nil, 1},\n\t\t\"q\":          &callExpr{\"quit\", nil, 1},\n\t\t\"gg\":         &callExpr{\"top\", nil, 1},\n\t\t\"<home>\":     &callExpr{\"top\", nil, 1},\n\t\t\"G\":          &callExpr{\"bottom\", nil, 1},\n\t\t\"<end>\":      &callExpr{\"bottom\", nil, 1},\n\t\t\"H\":          &callExpr{\"high\", nil, 1},\n\t\t\"M\":          &callExpr{\"middle\", nil, 1},\n\t\t\"L\":          &callExpr{\"low\", nil, 1},\n\t\t\"[\":          &callExpr{\"jump-prev\", nil, 1},\n\t\t\"]\":          &callExpr{\"jump-next\", nil, 1},\n\t\t\"<space>\":    &listExpr{[]expr{&callExpr{\"toggle\", nil, 1}, &callExpr{\"down\", nil, 1}}, 1},\n\t\t\"t\":          &callExpr{\"tag-toggle\", nil, 1},\n\t\t\"v\":          &callExpr{\"invert\", nil, 1},\n\t\t\"u\":          &callExpr{\"unselect\", nil, 1},\n\t\t\"y\":          &callExpr{\"copy\", nil, 1},\n\t\t\"d\":          &callExpr{\"cut\", nil, 1},\n\t\t\"c\":          &callExpr{\"clear\", nil, 1},\n\t\t\"p\":          &callExpr{\"paste\", nil, 1},\n\t\t\"<c-l>\":      &callExpr{\"redraw\", nil, 1},\n\t\t\"<c-r>\":      &callExpr{\"reload\", nil, 1},\n\t\t\":\":          &callExpr{\"read\", nil, 1},\n\t\t\"$\":          &callExpr{\"shell\", nil, 1},\n\t\t\"%\":          &callExpr{\"shell-pipe\", nil, 1},\n\t\t\"!\":          &callExpr{\"shell-wait\", nil, 1},\n\t\t\"&\":          &callExpr{\"shell-async\", nil, 1},\n\t\t\"f\":          &callExpr{\"find\", nil, 1},\n\t\t\"F\":          &callExpr{\"find-back\", nil, 1},\n\t\t\";\":          &callExpr{\"find-next\", nil, 1},\n\t\t\",\":          &callExpr{\"find-prev\", nil, 1},\n\t\t\"/\":          &callExpr{\"search\", nil, 1},\n\t\t\"?\":          &callExpr{\"search-back\", nil, 1},\n\t\t\"n\":          &callExpr{\"search-next\", nil, 1},\n\t\t\"N\":          &callExpr{\"search-prev\", nil, 1},\n\t\t\"m\":          &callExpr{\"mark-save\", nil, 1},\n\t\t\"'\":          &callExpr{\"mark-load\", nil, 1},\n\t\t`\"`:          &callExpr{\"mark-remove\", nil, 1},\n\t\t`r`:          &callExpr{\"rename\", nil, 1},\n\t\t\"<c-n>\":      &callExpr{\"cmd-history-next\", nil, 1},\n\t\t\"<c-p>\":      &callExpr{\"cmd-history-prev\", nil, 1},\n\n\t\t\"zh\": &setExpr{\"hidden!\", \"\"},\n\t\t\"zr\": &setExpr{\"reverse!\", \"\"},\n\t\t\"zn\": &setExpr{\"info\", \"\"},\n\t\t\"zs\": &setExpr{\"info\", \"size\"},\n\t\t\"zt\": &setExpr{\"info\", \"time\"},\n\t\t\"za\": &setExpr{\"info\", \"size:time\"},\n\t\t\"sn\": &listExpr{[]expr{&setExpr{\"sortby\", \"natural\"}, &setExpr{\"info\", \"\"}}, 1},\n\t\t\"ss\": &listExpr{[]expr{&setExpr{\"sortby\", \"size\"}, &setExpr{\"info\", \"size\"}}, 1},\n\t\t\"st\": &listExpr{[]expr{&setExpr{\"sortby\", \"time\"}, &setExpr{\"info\", \"time\"}}, 1},\n\t\t\"sa\": &listExpr{[]expr{&setExpr{\"sortby\", \"atime\"}, &setExpr{\"info\", \"atime\"}}, 1},\n\t\t\"sc\": &listExpr{[]expr{&setExpr{\"sortby\", \"ctime\"}, &setExpr{\"info\", \"ctime\"}}, 1},\n\t\t\"se\": &listExpr{[]expr{&setExpr{\"sortby\", \"ext\"}, &setExpr{\"info\", \"\"}}, 1},\n\t\t\"gh\": &callExpr{\"cd\", []string{\"~\"}, 1},\n\t}\n\n\tgOpts.cmdkeys = map[string]expr{\n\t\t\"<space>\":        &callExpr{\"cmd-insert\", []string{\" \"}, 1},\n\t\t\"<esc>\":          &callExpr{\"cmd-escape\", nil, 1},\n\t\t\"<tab>\":          &callExpr{\"cmd-complete\", nil, 1},\n\t\t\"<enter>\":        &callExpr{\"cmd-enter\", nil, 1},\n\t\t\"<c-j>\":          &callExpr{\"cmd-enter\", nil, 1},\n\t\t\"<down>\":         &callExpr{\"cmd-history-next\", nil, 1},\n\t\t\"<c-n>\":          &callExpr{\"cmd-history-next\", nil, 1},\n\t\t\"<up>\":           &callExpr{\"cmd-history-prev\", nil, 1},\n\t\t\"<c-p>\":          &callExpr{\"cmd-history-prev\", nil, 1},\n\t\t\"<delete>\":       &callExpr{\"cmd-delete\", nil, 1},\n\t\t\"<c-d>\":          &callExpr{\"cmd-delete\", nil, 1},\n\t\t\"<backspace>\":    &callExpr{\"cmd-delete-back\", nil, 1},\n\t\t\"<backspace2>\":   &callExpr{\"cmd-delete-back\", nil, 1},\n\t\t\"<left>\":         &callExpr{\"cmd-left\", nil, 1},\n\t\t\"<c-b>\":          &callExpr{\"cmd-left\", nil, 1},\n\t\t\"<right>\":        &callExpr{\"cmd-right\", nil, 1},\n\t\t\"<c-f>\":          &callExpr{\"cmd-right\", nil, 1},\n\t\t\"<home>\":         &callExpr{\"cmd-home\", nil, 1},\n\t\t\"<c-a>\":          &callExpr{\"cmd-home\", nil, 1},\n\t\t\"<end>\":          &callExpr{\"cmd-end\", nil, 1},\n\t\t\"<c-e>\":          &callExpr{\"cmd-end\", nil, 1},\n\t\t\"<c-u>\":          &callExpr{\"cmd-delete-home\", nil, 1},\n\t\t\"<c-k>\":          &callExpr{\"cmd-delete-end\", nil, 1},\n\t\t\"<c-w>\":          &callExpr{\"cmd-delete-unix-word\", nil, 1},\n\t\t\"<c-y>\":          &callExpr{\"cmd-yank\", nil, 1},\n\t\t\"<c-t>\":          &callExpr{\"cmd-transpose\", nil, 1},\n\t\t\"<c-c>\":          &callExpr{\"cmd-interrupt\", nil, 1},\n\t\t\"<a-f>\":          &callExpr{\"cmd-word\", nil, 1},\n\t\t\"<a-b>\":          &callExpr{\"cmd-word-back\", nil, 1},\n\t\t\"<a-c>\":          &callExpr{\"cmd-capitalize-word\", nil, 1},\n\t\t\"<a-d>\":          &callExpr{\"cmd-delete-word\", nil, 1},\n\t\t\"<a-backspace>\":  &callExpr{\"cmd-delete-word-back\", nil, 1},\n\t\t\"<a-backspace2>\": &callExpr{\"cmd-delete-word-back\", nil, 1},\n\t\t\"<a-u>\":          &callExpr{\"cmd-uppercase-word\", nil, 1},\n\t\t\"<a-l>\":          &callExpr{\"cmd-lowercase-word\", nil, 1},\n\t\t\"<a-t>\":          &callExpr{\"cmd-transpose-word\", nil, 1},\n\t}\n\n\tgOpts.cmds = make(map[string]expr)\n\tgOpts.user = make(map[string]string)\n\n\tgLocalOpts.sortbys = make(map[string]sortMethod)\n\tgLocalOpts.dirfirsts = make(map[string]bool)\n\tgLocalOpts.dironlys = make(map[string]bool)\n\tgLocalOpts.hiddens = make(map[string]bool)\n\tgLocalOpts.reverses = make(map[string]bool)\n\tgLocalOpts.infos = make(map[string][]string)\n\tgLocalOpts.locales = make(map[string]string)\n\n\tsetDefaults()\n}\n"
        },
        {
          "name": "os.go",
          "type": "blob",
          "size": 4.837890625,
          "content": "//go:build !windows\n\npackage main\n\nimport (\n\t\"cmp\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/user\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nvar (\n\tenvOpener = os.Getenv(\"OPENER\")\n\tenvEditor = os.Getenv(\"VISUAL\")\n\tenvPager  = os.Getenv(\"PAGER\")\n\tenvShell  = os.Getenv(\"SHELL\")\n)\n\nvar (\n\tgDefaultShell       = \"sh\"\n\tgDefaultShellFlag   = \"-c\"\n\tgDefaultSocketProt  = \"unix\"\n\tgDefaultSocketPath  string\n\tgDefaultHiddenFiles = []string{\".*\"}\n)\n\nvar (\n\tgUser        *user.User\n\tgConfigPaths []string\n\tgColorsPaths []string\n\tgIconsPaths  []string\n\tgFilesPath   string\n\tgMarksPath   string\n\tgTagsPath    string\n\tgHistoryPath string\n)\n\nfunc init() {\n\tif envOpener == \"\" {\n\t\tif runtime.GOOS == \"darwin\" {\n\t\t\tenvOpener = \"open\"\n\t\t} else {\n\t\t\tenvOpener = \"xdg-open\"\n\t\t}\n\t}\n\n\tif envEditor == \"\" {\n\t\tenvEditor = cmp.Or(os.Getenv(\"EDITOR\"), \"vi\")\n\t}\n\n\tif envPager == \"\" {\n\t\tenvPager = \"less\"\n\t}\n\n\tif envShell == \"\" {\n\t\tenvShell = \"sh\"\n\t}\n\n\tu, err := user.Current()\n\tif err != nil {\n\t\t// When the user is not in /etc/passwd (for e.g. LDAP) and CGO_ENABLED=1 in go env,\n\t\t// the cgo implementation of user.Current() fails even when HOME and USER are set.\n\n\t\tlog.Printf(\"user: %s\", err)\n\t\tif os.Getenv(\"HOME\") == \"\" {\n\t\t\tpanic(\"$HOME variable is empty or not set\")\n\t\t}\n\t\tif os.Getenv(\"USER\") == \"\" {\n\t\t\tpanic(\"$USER variable is empty or not set\")\n\t\t}\n\t\tu = &user.User{\n\t\t\tUsername: os.Getenv(\"USER\"),\n\t\t\tHomeDir:  os.Getenv(\"HOME\"),\n\t\t}\n\t}\n\tgUser = u\n\n\tconfig := cmp.Or(\n\t\tos.Getenv(\"LF_CONFIG_HOME\"),\n\t\tos.Getenv(\"XDG_CONFIG_HOME\"),\n\t\tfilepath.Join(gUser.HomeDir, \".config\"),\n\t)\n\n\tgConfigPaths = []string{\n\t\tfilepath.Join(\"/etc\", \"lf\", \"lfrc\"),\n\t\tfilepath.Join(config, \"lf\", \"lfrc\"),\n\t}\n\n\tgColorsPaths = []string{\n\t\tfilepath.Join(\"/etc\", \"lf\", \"colors\"),\n\t\tfilepath.Join(config, \"lf\", \"colors\"),\n\t}\n\n\tgIconsPaths = []string{\n\t\tfilepath.Join(\"/etc\", \"lf\", \"icons\"),\n\t\tfilepath.Join(config, \"lf\", \"icons\"),\n\t}\n\n\tdata := cmp.Or(\n\t\tos.Getenv(\"LF_DATA_HOME\"),\n\t\tos.Getenv(\"XDG_DATA_HOME\"),\n\t\tfilepath.Join(gUser.HomeDir, \".local\", \"share\"),\n\t)\n\n\tgFilesPath = filepath.Join(data, \"lf\", \"files\")\n\tgMarksPath = filepath.Join(data, \"lf\", \"marks\")\n\tgTagsPath = filepath.Join(data, \"lf\", \"tags\")\n\tgHistoryPath = filepath.Join(data, \"lf\", \"history\")\n\n\truntime := cmp.Or(os.Getenv(\"XDG_RUNTIME_DIR\"), os.TempDir())\n\n\tgDefaultSocketPath = filepath.Join(runtime, fmt.Sprintf(\"lf.%s.sock\", gUser.Username))\n}\n\nfunc detachedCommand(name string, arg ...string) *exec.Cmd {\n\tcmd := exec.Command(name, arg...)\n\tcmd.SysProcAttr = &unix.SysProcAttr{Setsid: true}\n\treturn cmd\n}\n\nfunc shellCommand(s string, args []string) *exec.Cmd {\n\tif len(gOpts.ifs) != 0 {\n\t\ts = fmt.Sprintf(\"IFS='%s'; %s\", gOpts.ifs, s)\n\t}\n\n\targs = append([]string{gOpts.shellflag, s, \"--\"}, args...)\n\n\targs = append(gOpts.shellopts, args...)\n\n\treturn exec.Command(gOpts.shell, args...)\n}\n\nfunc shellSetPG(cmd *exec.Cmd) {\n\tcmd.SysProcAttr = &unix.SysProcAttr{Setpgid: true}\n}\n\nfunc shellKill(cmd *exec.Cmd) error {\n\tpgid, err := unix.Getpgid(cmd.Process.Pid)\n\tif err == nil && cmd.Process.Pid == pgid {\n\t\t// kill the process group\n\t\terr = unix.Kill(-pgid, syscall.SIGTERM)\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn cmd.Process.Kill()\n}\n\nfunc setDefaults() {\n\tgOpts.cmds[\"open\"] = &execExpr{\"&\", `$OPENER \"$f\"`}\n\tgOpts.keys[\"e\"] = &execExpr{\"$\", `$EDITOR \"$f\"`}\n\tgOpts.keys[\"i\"] = &execExpr{\"$\", `$PAGER \"$f\"`}\n\tgOpts.keys[\"w\"] = &execExpr{\"$\", \"$SHELL\"}\n\n\tgOpts.cmds[\"doc\"] = &execExpr{\"$\", `\"$lf\" -doc | $PAGER`}\n\tgOpts.keys[\"<f-1>\"] = &callExpr{\"doc\", nil, 1}\n\n\tgOpts.cmds[\"maps\"] = &execExpr{\"$\", `\"$lf\" -remote \"query $id maps\" | $PAGER`}\n\tgOpts.cmds[\"cmaps\"] = &execExpr{\"$\", `\"$lf\" -remote \"query $id cmaps\" | $PAGER`}\n\tgOpts.cmds[\"cmds\"] = &execExpr{\"$\", `\"$lf\" -remote \"query $id cmds\" | $PAGER`}\n}\n\nfunc setUserUmask() {\n\tunix.Umask(0o077)\n}\n\nfunc isExecutable(f os.FileInfo) bool {\n\treturn f.Mode()&0o111 != 0\n}\n\nfunc isHidden(f os.FileInfo, path string, hiddenfiles []string) bool {\n\thidden := false\n\tfor _, pattern := range hiddenfiles {\n\t\tif matchPattern(strings.TrimPrefix(pattern, \"!\"), f.Name(), path) {\n\t\t\thidden = !strings.HasPrefix(pattern, \"!\")\n\t\t}\n\t}\n\treturn hidden\n}\n\nfunc userName(f os.FileInfo) string {\n\tif stat, ok := f.Sys().(*syscall.Stat_t); ok {\n\t\tuid := strconv.FormatUint(uint64(stat.Uid), 10)\n\t\tif u, err := user.LookupId(uid); err == nil {\n\t\t\treturn u.Username\n\t\t}\n\t\treturn uid\n\t}\n\treturn \"\"\n}\n\nfunc groupName(f os.FileInfo) string {\n\tif stat, ok := f.Sys().(*syscall.Stat_t); ok {\n\t\tgid := strconv.FormatUint(uint64(stat.Gid), 10)\n\t\tif g, err := user.LookupGroupId(gid); err == nil {\n\t\t\treturn g.Name\n\t\t}\n\t\treturn gid\n\t}\n\treturn \"\"\n}\n\nfunc linkCount(f os.FileInfo) string {\n\tif stat, ok := f.Sys().(*syscall.Stat_t); ok {\n\t\treturn strconv.FormatUint(uint64(stat.Nlink), 10)\n\t}\n\treturn \"\"\n}\n\nfunc errCrossDevice(err error) bool {\n\treturn err.(*os.LinkError).Err.(unix.Errno) == unix.EXDEV\n}\n\nfunc quoteString(s string) string {\n\treturn s\n}\n"
        },
        {
          "name": "os_windows.go",
          "type": "blob",
          "size": 4.83203125,
          "content": "package main\n\nimport (\n\t\"cmp\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/user\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"golang.org/x/sys/windows\"\n)\n\nvar (\n\tenvOpener = os.Getenv(\"OPENER\")\n\tenvEditor = os.Getenv(\"VISUAL\")\n\tenvPager  = os.Getenv(\"PAGER\")\n\tenvShell  = os.Getenv(\"SHELL\")\n)\n\nvar envPathExt = os.Getenv(\"PATHEXT\")\n\nvar (\n\tgDefaultShell       = \"cmd\"\n\tgDefaultShellFlag   = \"/c\"\n\tgDefaultSocketProt  = \"unix\"\n\tgDefaultSocketPath  string\n\tgDefaultHiddenFiles []string\n)\n\nvar (\n\tgUser        *user.User\n\tgConfigPaths []string\n\tgColorsPaths []string\n\tgIconsPaths  []string\n\tgFilesPath   string\n\tgTagsPath    string\n\tgMarksPath   string\n\tgHistoryPath string\n)\n\nfunc init() {\n\tif envOpener == \"\" {\n\t\tenvOpener = `start \"\"`\n\t}\n\n\tif envEditor == \"\" {\n\t\tenvEditor = cmp.Or(os.Getenv(\"EDITOR\"), \"notepad\")\n\t}\n\n\tif envPager == \"\" {\n\t\tenvPager = \"more\"\n\t}\n\n\tif envShell == \"\" {\n\t\tenvShell = \"cmd\"\n\t}\n\n\thomeDir, err := os.UserHomeDir()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tusername := os.Getenv(\"USERNAME\")\n\tif username == \"\" {\n\t\tpanic(\"$USERNAME variable is empty or not set\")\n\t}\n\n\tgUser = &user.User{\n\t\tHomeDir:  homeDir,\n\t\tUsername: username,\n\t}\n\n\tdata := cmp.Or(os.Getenv(\"LF_CONFIG_HOME\"), os.Getenv(\"LOCALAPPDATA\"))\n\n\tgConfigPaths = []string{\n\t\tfilepath.Join(os.Getenv(\"ProgramData\"), \"lf\", \"lfrc\"),\n\t\tfilepath.Join(data, \"lf\", \"lfrc\"),\n\t}\n\n\tgColorsPaths = []string{\n\t\tfilepath.Join(os.Getenv(\"ProgramData\"), \"lf\", \"colors\"),\n\t\tfilepath.Join(data, \"lf\", \"colors\"),\n\t}\n\n\tgIconsPaths = []string{\n\t\tfilepath.Join(os.Getenv(\"ProgramData\"), \"lf\", \"icons\"),\n\t\tfilepath.Join(data, \"lf\", \"icons\"),\n\t}\n\n\tgFilesPath = filepath.Join(data, \"lf\", \"files\")\n\tgMarksPath = filepath.Join(data, \"lf\", \"marks\")\n\tgTagsPath = filepath.Join(data, \"lf\", \"tags\")\n\tgHistoryPath = filepath.Join(data, \"lf\", \"history\")\n\n\tsocket, err := syscall.Socket(syscall.AF_UNIX, syscall.SOCK_STREAM, 0)\n\tif err != nil {\n\t\tgDefaultSocketProt = \"tcp\"\n\t\tgDefaultSocketPath = \"127.0.0.1:12345\"\n\t} else {\n\t\truntime := os.TempDir()\n\t\tgDefaultSocketPath = filepath.Join(runtime, fmt.Sprintf(\"lf.%s.sock\", gUser.Username))\n\t\tsyscall.Close(socket)\n\t}\n}\n\nfunc detachedCommand(name string, arg ...string) *exec.Cmd {\n\tcmd := exec.Command(name, arg...)\n\tcmd.SysProcAttr = &windows.SysProcAttr{CreationFlags: 8}\n\treturn cmd\n}\n\nfunc shellCommand(s string, args []string) *exec.Cmd {\n\t// Windows CMD requires special handling to deal with quoted arguments\n\tif strings.ToLower(gOpts.shell) == \"cmd\" {\n\t\tvar builder strings.Builder\n\t\tbuilder.WriteString(s)\n\t\tfor _, arg := range args {\n\t\t\tfmt.Fprintf(&builder, ` \"%s\"`, arg)\n\t\t}\n\t\tshellOpts := strings.Join(gOpts.shellopts, \" \")\n\t\tcmdline := fmt.Sprintf(`%s %s %s \"%s\"`, gOpts.shell, shellOpts, gOpts.shellflag, builder.String())\n\n\t\tcmd := exec.Command(gOpts.shell)\n\t\tcmd.SysProcAttr = &windows.SysProcAttr{CmdLine: cmdline}\n\t\treturn cmd\n\t}\n\n\targs = append([]string{gOpts.shellflag, s}, args...)\n\targs = append(gOpts.shellopts, args...)\n\treturn exec.Command(gOpts.shell, args...)\n}\n\nfunc shellSetPG(cmd *exec.Cmd) {\n}\n\nfunc shellKill(cmd *exec.Cmd) error {\n\treturn cmd.Process.Kill()\n}\n\nfunc setDefaults() {\n\tgOpts.cmds[\"open\"] = &execExpr{\"&\", \"%OPENER% %f%\"}\n\tgOpts.keys[\"e\"] = &execExpr{\"$\", \"%EDITOR% %f%\"}\n\tgOpts.keys[\"i\"] = &execExpr{\"!\", \"%PAGER% %f%\"}\n\tgOpts.keys[\"w\"] = &execExpr{\"$\", \"%SHELL%\"}\n\n\tgOpts.cmds[\"doc\"] = &execExpr{\"!\", \"%lf% -doc | %PAGER%\"}\n\tgOpts.keys[\"<f-1>\"] = &callExpr{\"doc\", nil, 1}\n\n\tgOpts.cmds[\"maps\"] = &execExpr{\"!\", `%lf% -remote \"query %id% maps\" | %PAGER%`}\n\tgOpts.cmds[\"cmaps\"] = &execExpr{\"!\", `%lf% -remote \"query %id% cmaps\" | %PAGER%`}\n\tgOpts.cmds[\"cmds\"] = &execExpr{\"!\", `%lf% -remote \"query %id% cmds\" | %PAGER%`}\n}\n\nfunc setUserUmask() {}\n\nfunc isExecutable(f os.FileInfo) bool {\n\texts := strings.Split(envPathExt, string(filepath.ListSeparator))\n\tfor _, e := range exts {\n\t\tif strings.HasSuffix(strings.ToLower(f.Name()), strings.ToLower(e)) {\n\t\t\tlog.Print(f.Name(), e)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc isHidden(f os.FileInfo, path string, hiddenfiles []string) bool {\n\tptr, err := windows.UTF16PtrFromString(filepath.Join(path, f.Name()))\n\tif err != nil {\n\t\treturn false\n\t}\n\tattrs, err := windows.GetFileAttributes(ptr)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tif attrs&windows.FILE_ATTRIBUTE_HIDDEN != 0 {\n\t\treturn true\n\t}\n\n\thidden := false\n\tfor _, pattern := range hiddenfiles {\n\t\tif matchPattern(strings.TrimPrefix(pattern, \"!\"), f.Name(), path) {\n\t\t\thidden = !strings.HasPrefix(pattern, \"!\")\n\t\t}\n\t}\n\n\treturn hidden\n}\n\nfunc userName(_ os.FileInfo) string {\n\treturn \"\"\n}\n\nfunc groupName(_ os.FileInfo) string {\n\treturn \"\"\n}\n\nfunc linkCount(_ os.FileInfo) string {\n\treturn \"\"\n}\n\nfunc errCrossDevice(err error) bool {\n\treturn err.(*os.LinkError).Err.(windows.Errno) == windows.ERROR_NOT_SAME_DEVICE\n}\n\nfunc quoteString(s string) string {\n\t// Windows CMD requires special handling to deal with quoted arguments\n\tif strings.ToLower(gOpts.shell) == \"cmd\" {\n\t\treturn fmt.Sprintf(`\"%s\"`, s)\n\t}\n\treturn s\n}\n"
        },
        {
          "name": "parse.go",
          "type": "blob",
          "size": 5.0947265625,
          "content": "package main\n\n// Grammar of the language used in the evaluator\n//\n// Expr         = SetExpr\n//              | SetLocalExpr\n//              | MapExpr\n//              | CMapExpr\n//              | CmdExpr\n//              | CallExpr\n//              | ExecExpr\n//              | ListExpr\n//\n// SetExpr      = 'set' <opt> <val> ';'\n//\n// SetLocalExpr = 'setlocal' <dir> <opt> <val> ';'\n//\n// MapExpr      = 'map' <keys> Expr\n//\n// CMapExpr     = 'cmap' <key> Expr\n//\n// CmdExpr      = 'cmd' <name> Expr\n//\n// CallExpr     = <name> <args> ';'\n//\n// ExecExpr     = Prefix      <value>      '\\n'\n//              | Prefix '{{' <value> '}}' ';'\n//\n// Prefix       = '$' | '%' | '!' | '&'\n//\n// ListExpr     = ':'      Expr ListRest      '\\n'\n//              | ':' '{{' Expr ListRest '}}' ';'\n//\n// ListRest     = Nil\n//              | Expr ListExpr\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\ntype expr interface {\n\tString() string\n\teval(app *app, args []string)\n}\n\ntype setExpr struct {\n\topt string\n\tval string\n}\n\nfunc (e *setExpr) String() string { return fmt.Sprintf(\"set %s %s\", e.opt, e.val) }\n\ntype setLocalExpr struct {\n\tpath string\n\topt  string\n\tval  string\n}\n\nfunc (e *setLocalExpr) String() string { return fmt.Sprintf(\"setlocal %s %s %s\", e.path, e.opt, e.val) }\n\ntype mapExpr struct {\n\tkeys string\n\texpr expr\n}\n\nfunc (e *mapExpr) String() string { return fmt.Sprintf(\"map %s %s\", e.keys, e.expr) }\n\ntype cmapExpr struct {\n\tkey  string\n\texpr expr\n}\n\nfunc (e *cmapExpr) String() string { return fmt.Sprintf(\"cmap %s %s\", e.key, e.expr) }\n\ntype cmdExpr struct {\n\tname string\n\texpr expr\n}\n\nfunc (e *cmdExpr) String() string { return fmt.Sprintf(\"cmd %s %s\", e.name, e.expr) }\n\ntype callExpr struct {\n\tname  string\n\targs  []string\n\tcount int\n}\n\nfunc (e *callExpr) String() string { return fmt.Sprintf(\"%s -- %s\", e.name, e.args) }\n\ntype execExpr struct {\n\tprefix string\n\tvalue  string\n}\n\nfunc (e *execExpr) String() string {\n\tvar buf bytes.Buffer\n\n\tbuf.WriteString(e.prefix)\n\tbuf.WriteString(\"{{ \")\n\n\tlines := strings.Split(e.value, \"\\n\")\n\n\tfor _, line := range lines {\n\t\ttrimmed := strings.TrimSpace(line)\n\t\tif trimmed == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tbuf.WriteString(trimmed)\n\n\t\tif len(lines) > 1 {\n\t\t\tbuf.WriteString(\" ...\")\n\t\t}\n\n\t\tbreak\n\t}\n\n\tbuf.WriteString(\" }}\")\n\n\treturn buf.String()\n}\n\ntype listExpr struct {\n\texprs []expr\n\tcount int\n}\n\nfunc (e *listExpr) String() string {\n\tvar buf bytes.Buffer\n\n\tbuf.WriteString(\":{{ \")\n\n\tfor _, expr := range e.exprs {\n\t\tbuf.WriteString(expr.String())\n\t\tbuf.WriteString(\"; \")\n\t}\n\n\tbuf.WriteString(\"}}\")\n\n\treturn buf.String()\n}\n\ntype parser struct {\n\tscanner *scanner\n\texpr    expr\n\terr     error\n}\n\nfunc newParser(r io.Reader) *parser {\n\tscanner := newScanner(r)\n\n\tscanner.scan()\n\n\treturn &parser{\n\t\tscanner: scanner,\n\t}\n}\n\nfunc (p *parser) parseExpr() expr {\n\ts := p.scanner\n\n\tvar result expr\n\n\tswitch s.typ {\n\tcase tokenEOF:\n\t\treturn nil\n\tcase tokenIdent:\n\t\tswitch s.tok {\n\t\tcase \"set\":\n\t\t\tvar val string\n\n\t\t\ts.scan()\n\t\t\tif s.typ != tokenIdent {\n\t\t\t\tp.err = fmt.Errorf(\"expected identifier: %s\", s.tok)\n\t\t\t}\n\t\t\topt := s.tok\n\n\t\t\ts.scan()\n\t\t\tif s.typ != tokenSemicolon {\n\t\t\t\tval = s.tok\n\t\t\t\ts.scan()\n\t\t\t}\n\n\t\t\ts.scan()\n\n\t\t\tresult = &setExpr{opt, val}\n\t\tcase \"setlocal\":\n\t\t\tvar val string\n\n\t\t\ts.scan()\n\t\t\tif s.typ != tokenIdent {\n\t\t\t\tp.err = fmt.Errorf(\"expected directory: %s\", s.tok)\n\t\t\t}\n\t\t\tdir := s.tok\n\n\t\t\ts.scan()\n\t\t\tif s.typ != tokenIdent {\n\t\t\t\tp.err = fmt.Errorf(\"expected identifier: %s\", s.tok)\n\t\t\t}\n\t\t\topt := s.tok\n\n\t\t\ts.scan()\n\t\t\tif s.typ != tokenSemicolon {\n\t\t\t\tval = s.tok\n\t\t\t\ts.scan()\n\t\t\t}\n\n\t\t\ts.scan()\n\n\t\t\tresult = &setLocalExpr{dir, opt, val}\n\t\tcase \"map\":\n\t\t\tvar expr expr\n\n\t\t\ts.scan()\n\t\t\tkeys := s.tok\n\n\t\t\ts.scan()\n\t\t\tif s.typ != tokenSemicolon {\n\t\t\t\texpr = p.parseExpr()\n\t\t\t} else {\n\t\t\t\ts.scan()\n\t\t\t}\n\n\t\t\tresult = &mapExpr{keys, expr}\n\t\tcase \"cmap\":\n\t\t\tvar expr expr\n\n\t\t\ts.scan()\n\t\t\tkey := s.tok\n\n\t\t\ts.scan()\n\t\t\tif s.typ != tokenSemicolon {\n\t\t\t\texpr = p.parseExpr()\n\t\t\t} else {\n\t\t\t\ts.scan()\n\t\t\t}\n\n\t\t\tresult = &cmapExpr{key, expr}\n\t\tcase \"cmd\":\n\t\t\tvar expr expr\n\n\t\t\ts.scan()\n\t\t\tname := s.tok\n\n\t\t\ts.scan()\n\t\t\tif s.typ != tokenSemicolon {\n\t\t\t\texpr = p.parseExpr()\n\t\t\t} else {\n\t\t\t\ts.scan()\n\t\t\t}\n\n\t\t\tresult = &cmdExpr{name, expr}\n\t\tdefault:\n\t\t\tname := s.tok\n\n\t\t\tvar args []string\n\t\t\tfor s.scan() && s.typ != tokenSemicolon {\n\t\t\t\targs = append(args, s.tok)\n\t\t\t}\n\n\t\t\ts.scan()\n\n\t\t\tresult = &callExpr{name, args, 1}\n\t\t}\n\tcase tokenColon:\n\t\ts.scan()\n\n\t\tvar exprs []expr\n\t\tif s.typ == tokenLBraces {\n\t\t\ts.scan()\n\t\t\tfor {\n\t\t\t\te := p.parseExpr()\n\t\t\t\tif e == nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\texprs = append(exprs, e)\n\t\t\t\tif s.typ == tokenRBraces {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.scan()\n\t\t} else {\n\t\t\tfor {\n\t\t\t\te := p.parseExpr()\n\t\t\t\tif e == nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\texprs = append(exprs, e)\n\t\t\t\tif s.tok == \"\\n\" {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ts.scan()\n\n\t\tresult = &listExpr{exprs, 1}\n\tcase tokenPrefix:\n\t\tvar expr string\n\n\t\tprefix := s.tok\n\n\t\ts.scan()\n\t\tif s.typ == tokenLBraces {\n\t\t\ts.scan()\n\t\t\texpr = s.tok\n\t\t\ts.scan()\n\t\t} else {\n\t\t\texpr = s.tok\n\t\t}\n\n\t\ts.scan()\n\t\ts.scan()\n\n\t\tresult = &execExpr{prefix, expr}\n\tdefault:\n\t\tp.err = fmt.Errorf(\"unexpected token: %s\", s.tok)\n\t}\n\n\treturn result\n}\n\nfunc (p *parser) parse() bool {\n\tp.expr = p.parseExpr()\n\treturn p.expr != nil\n}\n"
        },
        {
          "name": "scan.go",
          "type": "blob",
          "size": 5.3662109375,
          "content": "package main\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"strconv\"\n)\n\ntype tokenType byte\n\nconst (\n\ttokenEOF tokenType = iota\n\t// no explicit keyword type\n\ttokenIdent     // e.g. set, ratios, 1:2:3\n\ttokenColon     // :\n\ttokenPrefix    // $, %, !, &\n\ttokenLBraces   // {{\n\ttokenRBraces   // }}\n\ttokenCommand   // in between a prefix to \\n or between {{ and }}\n\ttokenSemicolon // ;\n\t// comments are stripped\n)\n\ntype scanner struct {\n\tbuf []byte    // input buffer\n\toff int       // current offset in buf\n\tchr byte      // current character in buf\n\tsem bool      // insert semicolon\n\tnln bool      // insert newline\n\teof bool      // buffer ended\n\tkey bool      // scanning keys\n\tblk bool      // scanning block\n\tcmd bool      // scanning command\n\ttyp tokenType // scanned token type\n\ttok string    // scanned token value\n\t// TODO: pos\n}\n\nfunc newScanner(r io.Reader) *scanner {\n\tbuf, err := io.ReadAll(r)\n\tif err != nil {\n\t\tlog.Printf(\"scanning: %s\", err)\n\t}\n\n\tvar eof bool\n\tvar chr byte\n\n\tif len(buf) == 0 {\n\t\teof = true\n\t} else {\n\t\teof = false\n\t\tchr = buf[0]\n\t}\n\n\treturn &scanner{\n\t\tbuf: buf,\n\t\teof: eof,\n\t\tchr: chr,\n\t}\n}\n\nfunc (s *scanner) next() {\n\tif s.off+1 < len(s.buf) {\n\t\ts.off++\n\t\ts.chr = s.buf[s.off]\n\t\treturn\n\t}\n\n\ts.off = len(s.buf)\n\ts.chr = 0\n\ts.eof = true\n}\n\nfunc (s *scanner) peek() byte {\n\tif s.off+1 < len(s.buf) {\n\t\treturn s.buf[s.off+1]\n\t}\n\n\treturn 0\n}\n\nfunc isSpace(b byte) bool {\n\tswitch b {\n\tcase '\\t', '\\n', '\\v', '\\f', '\\r', ' ':\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc isDigit(b byte) bool {\n\treturn '0' <= b && b <= '9'\n}\n\nfunc isPrefix(b byte) bool {\n\tswitch b {\n\tcase '$', '%', '!', '&':\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (s *scanner) scan() bool {\nscan:\n\tswitch {\n\tcase s.eof:\n\t\ts.next()\n\t\tif s.sem {\n\t\t\ts.typ = tokenSemicolon\n\t\t\ts.tok = \"\\n\"\n\t\t\ts.sem = false\n\t\t\treturn true\n\t\t}\n\t\tif s.nln {\n\t\t\ts.typ = tokenSemicolon\n\t\t\ts.tok = \"\\n\"\n\t\t\ts.nln = false\n\t\t\treturn true\n\t\t}\n\t\ts.typ = tokenEOF\n\t\ts.tok = \"EOF\"\n\t\treturn false\n\tcase s.key:\n\t\tbeg := s.off\n\t\tfor !s.eof && !isSpace(s.chr) {\n\t\t\ts.next()\n\t\t}\n\t\ts.typ = tokenIdent\n\t\ts.tok = string(s.buf[beg:s.off])\n\t\ts.key = false\n\tcase s.blk:\n\t\t// return here by setting s.cmd to false\n\t\t// after scanning the command in the loop below\n\t\tif !s.cmd {\n\t\t\ts.next()\n\t\t\ts.next()\n\t\t\ts.typ = tokenRBraces\n\t\t\ts.tok = \"}}\"\n\t\t\ts.blk = false\n\t\t\ts.sem = true\n\t\t\treturn true\n\t\t}\n\n\t\tbeg := s.off\n\n\t\tfor !s.eof {\n\t\t\ts.next()\n\t\t\tif s.chr == '}' {\n\t\t\t\tif !s.eof && s.peek() == '}' {\n\t\t\t\t\ts.typ = tokenCommand\n\t\t\t\t\ts.tok = string(s.buf[beg:s.off])\n\t\t\t\t\ts.cmd = false\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ts.typ = tokenEOF\n\t\ts.tok = \"EOF\"\n\t\treturn false\n\tcase s.cmd:\n\t\tfor !s.eof && isSpace(s.chr) {\n\t\t\ts.next()\n\t\t}\n\n\t\tif !s.eof && s.chr == '{' {\n\t\t\tif s.peek() == '{' {\n\t\t\t\ts.next()\n\t\t\t\ts.next()\n\t\t\t\ts.typ = tokenLBraces\n\t\t\t\ts.tok = \"{{\"\n\t\t\t\ts.blk = true\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\tbeg := s.off\n\n\t\tfor !s.eof && s.chr != '\\n' {\n\t\t\ts.next()\n\t\t}\n\n\t\ts.typ = tokenCommand\n\t\ts.tok = string(s.buf[beg:s.off])\n\t\ts.cmd = false\n\t\ts.sem = true\n\tcase s.chr == '\\n':\n\t\tif s.sem {\n\t\t\ts.typ = tokenSemicolon\n\t\t\ts.tok = \"\\n\"\n\t\t\ts.sem = false\n\t\t\treturn true\n\t\t}\n\t\ts.next()\n\t\tif s.nln {\n\t\t\ts.typ = tokenSemicolon\n\t\t\ts.tok = \"\\n\"\n\t\t\ts.nln = false\n\t\t\treturn true\n\t\t}\n\t\tgoto scan\n\tcase isSpace(s.chr):\n\t\tfor !s.eof && isSpace(s.chr) && s.chr != '\\n' {\n\t\t\ts.next()\n\t\t}\n\t\tgoto scan\n\tcase s.chr == ';':\n\t\ts.typ = tokenSemicolon\n\t\ts.tok = \";\"\n\t\ts.sem = false\n\t\ts.next()\n\tcase s.chr == '#':\n\t\tfor !s.eof && s.chr != '\\n' {\n\t\t\ts.next()\n\t\t}\n\t\tgoto scan\n\tcase s.chr == '\"':\n\t\ts.next()\n\t\tvar buf []byte\n\t\tfor !s.eof && s.chr != '\"' {\n\t\t\tif s.chr == '\\\\' {\n\t\t\t\ts.next()\n\t\t\t\tswitch {\n\t\t\t\tcase s.chr == '\"' || s.chr == '\\\\':\n\t\t\t\t\tbuf = append(buf, s.chr)\n\t\t\t\tcase s.chr == 'a':\n\t\t\t\t\tbuf = append(buf, '\\a')\n\t\t\t\tcase s.chr == 'b':\n\t\t\t\t\tbuf = append(buf, '\\b')\n\t\t\t\tcase s.chr == 'f':\n\t\t\t\t\tbuf = append(buf, '\\f')\n\t\t\t\tcase s.chr == 'n':\n\t\t\t\t\tbuf = append(buf, '\\n')\n\t\t\t\tcase s.chr == 'r':\n\t\t\t\t\tbuf = append(buf, '\\r')\n\t\t\t\tcase s.chr == 't':\n\t\t\t\t\tbuf = append(buf, '\\t')\n\t\t\t\tcase s.chr == 'v':\n\t\t\t\t\tbuf = append(buf, '\\v')\n\t\t\t\tcase isDigit(s.chr):\n\t\t\t\t\tvar oct []byte\n\t\t\t\t\tfor isDigit(s.chr) {\n\t\t\t\t\t\toct = append(oct, s.chr)\n\t\t\t\t\t\ts.next()\n\t\t\t\t\t}\n\t\t\t\t\tn, err := strconv.ParseInt(string(oct), 8, 0)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Printf(\"scanning: %s\", err)\n\t\t\t\t\t}\n\t\t\t\t\tbuf = append(buf, byte(n))\n\t\t\t\t\tcontinue\n\t\t\t\tdefault:\n\t\t\t\t\tbuf = append(buf, '\\\\', s.chr)\n\t\t\t\t}\n\t\t\t\ts.next()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tbuf = append(buf, s.chr)\n\t\t\ts.next()\n\t\t}\n\t\ts.typ = tokenIdent\n\t\ts.tok = string(buf)\n\t\ts.next()\n\tcase s.chr == '\\'':\n\t\ts.next()\n\t\tbeg := s.off\n\t\tfor !s.eof && s.chr != '\\'' {\n\t\t\ts.next()\n\t\t}\n\t\ts.typ = tokenIdent\n\t\ts.tok = string(s.buf[beg:s.off])\n\t\ts.next()\n\tcase s.chr == ':':\n\t\ts.typ = tokenColon\n\t\ts.tok = \":\"\n\t\ts.nln = true\n\t\ts.next()\n\tcase s.chr == '{' && s.peek() == '{':\n\t\ts.next()\n\t\ts.next()\n\t\ts.typ = tokenLBraces\n\t\ts.tok = \"{{\"\n\t\ts.sem = false\n\t\ts.nln = false\n\tcase s.chr == '}' && s.peek() == '}':\n\t\ts.next()\n\t\ts.next()\n\t\ts.typ = tokenRBraces\n\t\ts.tok = \"}}\"\n\t\ts.sem = true\n\tcase isPrefix(s.chr):\n\t\ts.typ = tokenPrefix\n\t\ts.tok = string(s.chr)\n\t\ts.cmd = true\n\t\ts.next()\n\tdefault:\n\t\tvar buf []byte\n\t\tfor !s.eof && !isSpace(s.chr) && s.chr != ';' && s.chr != '#' {\n\t\t\tif s.chr == '\\\\' {\n\t\t\t\ts.next()\n\t\t\t\tbuf = append(buf, s.chr)\n\t\t\t\ts.next()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tbuf = append(buf, s.chr)\n\t\t\ts.next()\n\t\t}\n\n\t\ts.typ = tokenIdent\n\t\ts.tok = string(buf)\n\t\ts.sem = true\n\n\t\tif s.tok == \"push\" {\n\t\t\ts.key = true\n\t\t\tfor !s.eof && isSpace(s.chr) && s.chr != '\\n' {\n\t\t\t\ts.next()\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true\n}\n"
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 3.240234375,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar (\n\tgConnList = make(map[int]net.Conn)\n\tgQuitChan = make(chan struct{}, 1)\n\tgListener net.Listener\n)\n\nfunc serve() {\n\tif gLogPath != \"\" {\n\t\tf, err := os.OpenFile(gLogPath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0o600)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tdefer f.Close()\n\t\tlog.SetOutput(f)\n\t}\n\n\tlog.Print(\"hi!\")\n\n\tif gSocketProt == \"unix\" {\n\t\tsetUserUmask()\n\t}\n\n\tl, err := net.Listen(gSocketProt, gSocketPath)\n\tif err != nil {\n\t\tlog.Printf(\"listening socket: %s\", err)\n\t\treturn\n\t}\n\tdefer l.Close()\n\n\tgListener = l\n\n\tlisten(l)\n}\n\nfunc listen(l net.Listener) {\n\tfor {\n\t\tc, err := l.Accept()\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase <-gQuitChan:\n\t\t\t\tlog.Printf(\"bye!\")\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tlog.Printf(\"accepting connection: %s\", err)\n\t\t\t}\n\t\t}\n\t\tgo handleConn(c)\n\t}\n}\n\nfunc echoerr(c net.Conn, msg string) {\n\tfmt.Fprintln(c, msg)\n\tlog.Print(msg)\n}\n\nfunc echoerrf(c net.Conn, format string, a ...interface{}) {\n\techoerr(c, fmt.Sprintf(format, a...))\n}\n\nfunc handleConn(c net.Conn) {\n\ts := bufio.NewScanner(c)\n\nLoop:\n\tfor s.Scan() {\n\t\tlog.Printf(\"listen: %s\", s.Text())\n\t\tword, rest := splitWord(s.Text())\n\t\tswitch word {\n\t\tcase \"conn\":\n\t\t\tif rest != \"\" {\n\t\t\t\tword2, _ := splitWord(rest)\n\t\t\t\tid, err := strconv.Atoi(word2)\n\t\t\t\tif err != nil {\n\t\t\t\t\techoerr(c, \"listen: conn: client id should be a number\")\n\t\t\t\t} else {\n\t\t\t\t\t// lifetime of the connection is managed by the server and\n\t\t\t\t\t// will be cleaned up via the `drop` command\n\t\t\t\t\tgConnList[id] = c\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\techoerr(c, \"listen: conn: requires a client id\")\n\t\t\t}\n\t\tcase \"drop\":\n\t\t\tif rest != \"\" {\n\t\t\t\tword2, _ := splitWord(rest)\n\t\t\t\tid, err := strconv.Atoi(word2)\n\t\t\t\tif err != nil {\n\t\t\t\t\techoerr(c, \"listen: drop: client id should be a number\")\n\t\t\t\t} else {\n\t\t\t\t\tif c2, ok := gConnList[id]; ok {\n\t\t\t\t\t\tc2.Close()\n\t\t\t\t\t}\n\t\t\t\t\tdelete(gConnList, id)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\techoerr(c, \"listen: drop: requires a client id\")\n\t\t\t}\n\t\tcase \"send\":\n\t\t\tif rest != \"\" {\n\t\t\t\tword2, rest2 := splitWord(rest)\n\t\t\t\tid, err := strconv.Atoi(word2)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfor _, c := range gConnList {\n\t\t\t\t\t\tfmt.Fprintln(c, rest)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif c2, ok := gConnList[id]; ok {\n\t\t\t\t\t\tfmt.Fprintln(c2, rest2)\n\t\t\t\t\t} else {\n\t\t\t\t\t\techoerr(c, \"listen: send: no such client id is connected\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"query\":\n\t\t\tif rest == \"\" {\n\t\t\t\techoerr(c, \"listen: query: requires a client id\")\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tword2, rest2 := splitWord(rest)\n\t\t\tid, err := strconv.Atoi(word2)\n\t\t\tif err != nil {\n\t\t\t\techoerr(c, \"listen: query: client id should be a number\")\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc2, ok := gConnList[id]\n\t\t\tif !ok {\n\t\t\t\techoerr(c, \"listen: query: no such client id is connected\")\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfmt.Fprintln(c2, \"query \"+rest2)\n\t\t\ts2 := bufio.NewScanner(c2)\n\t\t\tfor s2.Scan() && s2.Text() != \"\" {\n\t\t\t\tfmt.Fprintln(c, s2.Text())\n\t\t\t}\n\t\tcase \"quit\":\n\t\t\tif len(gConnList) == 0 {\n\t\t\t\tgQuitChan <- struct{}{}\n\t\t\t\tgListener.Close()\n\t\t\t\tbreak Loop\n\t\t\t}\n\t\tcase \"quit!\":\n\t\t\tgQuitChan <- struct{}{}\n\t\t\tfor _, c := range gConnList {\n\t\t\t\tfmt.Fprintln(c, \"echo server is quitting...\")\n\t\t\t\tc.Close()\n\t\t\t}\n\t\t\tgListener.Close()\n\t\t\tbreak Loop\n\t\tdefault:\n\t\t\techoerrf(c, \"listen: unexpected command: %s\", word)\n\t\t}\n\t}\n\n\tif s.Err() != nil {\n\t\techoerrf(c, \"listening: %s\", s.Err())\n\t}\n\n\tc.Close()\n}\n"
        },
        {
          "name": "sixel.go",
          "type": "blob",
          "size": 1.8701171875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/gdamore/tcell/v2\"\n)\n\nconst (\n\tgSixelBegin = \"\\033P\"\n\n\t// The filler character should be:\n\t// - rarely used: the filler is used to trick tcell into redrawing, if the\n\t//   filler character appears in the user's preview, that cell might not\n\t//   be cleaned up properly\n\t// - ideally renders as empty space: the filler alternates between bold\n\t//   and regular, using a non-space would look weird to the user.\n\tgSixelFiller = '\\u2000'\n)\n\ntype sixelScreen struct {\n\txprev, yprev int\n\tsixel        *string\n\taltFill      bool\n\tlastFile     string // TODO maybe use hash of sixels instead to flip altFill\n}\n\nfunc (sxs *sixelScreen) fillerStyle(filePath string) tcell.Style {\n\tif sxs.lastFile != filePath {\n\t\tsxs.altFill = !sxs.altFill\n\t}\n\n\tif sxs.altFill {\n\t\treturn tcell.StyleDefault.Bold(true)\n\t}\n\treturn tcell.StyleDefault\n}\n\nfunc (sxs *sixelScreen) showSixels() {\n\tif sxs.sixel == nil {\n\t\treturn\n\t}\n\n\t// XXX: workaround for bug where quitting lf might leave the terminal in bold\n\tfmt.Fprint(os.Stderr, \"\\033[0m\")\n\n\tfmt.Fprint(os.Stderr, \"\\0337\")                              // Save cursor position\n\tfmt.Fprintf(os.Stderr, \"\\033[%d;%dH\", sxs.yprev, sxs.xprev) // Move cursor to position\n\tfmt.Fprint(os.Stderr, *sxs.sixel)                           //\n\tfmt.Fprint(os.Stderr, \"\\0338\")                              // Restore cursor position\n}\n\nfunc (sxs *sixelScreen) printSixel(win *win, screen tcell.Screen, reg *reg) {\n\tif reg.sixel == nil {\n\t\treturn\n\t}\n\n\t// HACK: fillers are used to control when tcell redraws the region where a sixel image is drawn.\n\t// alternating between bold and regular is to clear the image before drawing a new one.\n\tst := sxs.fillerStyle(reg.path)\n\tfor y := 0; y < win.h; y++ {\n\t\tst = win.print(screen, 0, y, st, strings.Repeat(string(gSixelFiller), win.w))\n\t}\n\n\tsxs.xprev, sxs.yprev = win.x+1, win.y+1\n\tsxs.sixel = reg.sixel\n}\n"
        },
        {
          "name": "ui.go",
          "type": "blob",
          "size": 37.158203125,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"text/tabwriter\"\n\t\"time\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n\n\t\"github.com/gdamore/tcell/v2\"\n\t\"github.com/mattn/go-runewidth\"\n\t\"golang.org/x/term\"\n)\n\nconst gEscapeCode = 27\n\nvar gKeyVal = map[tcell.Key]string{\n\ttcell.KeyEnter:          \"<enter>\",\n\ttcell.KeyBackspace:      \"<backspace>\",\n\ttcell.KeyTab:            \"<tab>\",\n\ttcell.KeyBacktab:        \"<backtab>\",\n\ttcell.KeyEsc:            \"<esc>\",\n\ttcell.KeyBackspace2:     \"<backspace2>\",\n\ttcell.KeyDelete:         \"<delete>\",\n\ttcell.KeyInsert:         \"<insert>\",\n\ttcell.KeyUp:             \"<up>\",\n\ttcell.KeyDown:           \"<down>\",\n\ttcell.KeyLeft:           \"<left>\",\n\ttcell.KeyRight:          \"<right>\",\n\ttcell.KeyHome:           \"<home>\",\n\ttcell.KeyEnd:            \"<end>\",\n\ttcell.KeyUpLeft:         \"<upleft>\",\n\ttcell.KeyUpRight:        \"<upright>\",\n\ttcell.KeyDownLeft:       \"<downleft>\",\n\ttcell.KeyDownRight:      \"<downright>\",\n\ttcell.KeyCenter:         \"<center>\",\n\ttcell.KeyPgDn:           \"<pgdn>\",\n\ttcell.KeyPgUp:           \"<pgup>\",\n\ttcell.KeyClear:          \"<clear>\",\n\ttcell.KeyExit:           \"<exit>\",\n\ttcell.KeyCancel:         \"<cancel>\",\n\ttcell.KeyPause:          \"<pause>\",\n\ttcell.KeyPrint:          \"<print>\",\n\ttcell.KeyF1:             \"<f-1>\",\n\ttcell.KeyF2:             \"<f-2>\",\n\ttcell.KeyF3:             \"<f-3>\",\n\ttcell.KeyF4:             \"<f-4>\",\n\ttcell.KeyF5:             \"<f-5>\",\n\ttcell.KeyF6:             \"<f-6>\",\n\ttcell.KeyF7:             \"<f-7>\",\n\ttcell.KeyF8:             \"<f-8>\",\n\ttcell.KeyF9:             \"<f-9>\",\n\ttcell.KeyF10:            \"<f-10>\",\n\ttcell.KeyF11:            \"<f-11>\",\n\ttcell.KeyF12:            \"<f-12>\",\n\ttcell.KeyF13:            \"<f-13>\",\n\ttcell.KeyF14:            \"<f-14>\",\n\ttcell.KeyF15:            \"<f-15>\",\n\ttcell.KeyF16:            \"<f-16>\",\n\ttcell.KeyF17:            \"<f-17>\",\n\ttcell.KeyF18:            \"<f-18>\",\n\ttcell.KeyF19:            \"<f-19>\",\n\ttcell.KeyF20:            \"<f-20>\",\n\ttcell.KeyF21:            \"<f-21>\",\n\ttcell.KeyF22:            \"<f-22>\",\n\ttcell.KeyF23:            \"<f-23>\",\n\ttcell.KeyF24:            \"<f-24>\",\n\ttcell.KeyF25:            \"<f-25>\",\n\ttcell.KeyF26:            \"<f-26>\",\n\ttcell.KeyF27:            \"<f-27>\",\n\ttcell.KeyF28:            \"<f-28>\",\n\ttcell.KeyF29:            \"<f-29>\",\n\ttcell.KeyF30:            \"<f-30>\",\n\ttcell.KeyF31:            \"<f-31>\",\n\ttcell.KeyF32:            \"<f-32>\",\n\ttcell.KeyF33:            \"<f-33>\",\n\ttcell.KeyF34:            \"<f-34>\",\n\ttcell.KeyF35:            \"<f-35>\",\n\ttcell.KeyF36:            \"<f-36>\",\n\ttcell.KeyF37:            \"<f-37>\",\n\ttcell.KeyF38:            \"<f-38>\",\n\ttcell.KeyF39:            \"<f-39>\",\n\ttcell.KeyF40:            \"<f-40>\",\n\ttcell.KeyF41:            \"<f-41>\",\n\ttcell.KeyF42:            \"<f-42>\",\n\ttcell.KeyF43:            \"<f-43>\",\n\ttcell.KeyF44:            \"<f-44>\",\n\ttcell.KeyF45:            \"<f-45>\",\n\ttcell.KeyF46:            \"<f-46>\",\n\ttcell.KeyF47:            \"<f-47>\",\n\ttcell.KeyF48:            \"<f-48>\",\n\ttcell.KeyF49:            \"<f-49>\",\n\ttcell.KeyF50:            \"<f-50>\",\n\ttcell.KeyF51:            \"<f-51>\",\n\ttcell.KeyF52:            \"<f-52>\",\n\ttcell.KeyF53:            \"<f-53>\",\n\ttcell.KeyF54:            \"<f-54>\",\n\ttcell.KeyF55:            \"<f-55>\",\n\ttcell.KeyF56:            \"<f-56>\",\n\ttcell.KeyF57:            \"<f-57>\",\n\ttcell.KeyF58:            \"<f-58>\",\n\ttcell.KeyF59:            \"<f-59>\",\n\ttcell.KeyF60:            \"<f-60>\",\n\ttcell.KeyF61:            \"<f-61>\",\n\ttcell.KeyF62:            \"<f-62>\",\n\ttcell.KeyF63:            \"<f-63>\",\n\ttcell.KeyF64:            \"<f-64>\",\n\ttcell.KeyCtrlA:          \"<c-a>\",\n\ttcell.KeyCtrlB:          \"<c-b>\",\n\ttcell.KeyCtrlC:          \"<c-c>\",\n\ttcell.KeyCtrlD:          \"<c-d>\",\n\ttcell.KeyCtrlE:          \"<c-e>\",\n\ttcell.KeyCtrlF:          \"<c-f>\",\n\ttcell.KeyCtrlG:          \"<c-g>\",\n\ttcell.KeyCtrlJ:          \"<c-j>\",\n\ttcell.KeyCtrlK:          \"<c-k>\",\n\ttcell.KeyCtrlL:          \"<c-l>\",\n\ttcell.KeyCtrlN:          \"<c-n>\",\n\ttcell.KeyCtrlO:          \"<c-o>\",\n\ttcell.KeyCtrlP:          \"<c-p>\",\n\ttcell.KeyCtrlQ:          \"<c-q>\",\n\ttcell.KeyCtrlR:          \"<c-r>\",\n\ttcell.KeyCtrlS:          \"<c-s>\",\n\ttcell.KeyCtrlT:          \"<c-t>\",\n\ttcell.KeyCtrlU:          \"<c-u>\",\n\ttcell.KeyCtrlV:          \"<c-v>\",\n\ttcell.KeyCtrlW:          \"<c-w>\",\n\ttcell.KeyCtrlX:          \"<c-x>\",\n\ttcell.KeyCtrlY:          \"<c-y>\",\n\ttcell.KeyCtrlZ:          \"<c-z>\",\n\ttcell.KeyCtrlSpace:      \"<c-space>\",\n\ttcell.KeyCtrlUnderscore: \"<c-_>\",\n\ttcell.KeyCtrlRightSq:    \"<c-]>\",\n\ttcell.KeyCtrlBackslash:  \"<c-\\\\>\",\n\ttcell.KeyCtrlCarat:      \"<c-^>\",\n}\n\nvar gValKey map[string]tcell.Key\n\nfunc init() {\n\tgValKey = make(map[string]tcell.Key, len(gKeyVal))\n\tfor k, v := range gKeyVal {\n\t\tgValKey[v] = k\n\t}\n}\n\ntype win struct {\n\tw, h, x, y int\n}\n\nfunc newWin(w, h, x, y int) *win {\n\treturn &win{w, h, x, y}\n}\n\nfunc (win *win) renew(w, h, x, y int) {\n\twin.w, win.h, win.x, win.y = w, h, x, y\n}\n\nfunc printLength(s string) int {\n\tind := 0\n\toff := 0\n\tslen := len(s)\n\tfor i := 0; i < slen; i++ {\n\t\tr, w := utf8.DecodeRuneInString(s[i:])\n\n\t\tif r == gEscapeCode && i+1 < slen && s[i+1] == '[' {\n\t\t\tj := strings.IndexAny(s[i:min(slen, i+64)], \"mK\")\n\t\t\tif j == -1 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\ti += j\n\t\t\tcontinue\n\t\t}\n\n\t\ti += w - 1\n\n\t\tif r == '\\t' {\n\t\t\tind += gOpts.tabstop - (ind-off)%gOpts.tabstop\n\t\t} else {\n\t\t\tind += runewidth.RuneWidth(r)\n\t\t}\n\t}\n\n\treturn ind\n}\n\nfunc (win *win) print(screen tcell.Screen, x, y int, st tcell.Style, s string) tcell.Style {\n\toff := x\n\tvar comb []rune\n\tslen := len(s)\n\tfor i := 0; i < slen; i++ {\n\t\tr, w := utf8.DecodeRuneInString(s[i:])\n\n\t\tif r == gEscapeCode && i+1 < slen && s[i+1] == '[' {\n\t\t\tj := strings.IndexAny(s[i:min(slen, i+64)], \"mK\")\n\t\t\tif j == -1 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif s[i+j] == 'm' {\n\t\t\t\tst = applyAnsiCodes(s[i+2:i+j], st)\n\t\t\t}\n\n\t\t\ti += j\n\t\t\tcontinue\n\t\t}\n\n\t\tfor {\n\t\t\trc, wc := utf8.DecodeRuneInString(s[i+w:])\n\t\t\tif !unicode.Is(unicode.Mn, rc) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcomb = append(comb, rc)\n\t\t\ti += wc\n\t\t}\n\n\t\tif x < win.w {\n\t\t\tscreen.SetContent(win.x+x, win.y+y, r, comb, st)\n\t\t\tcomb = nil\n\t\t}\n\n\t\ti += w - 1\n\n\t\tif r == '\\t' {\n\t\t\tind := gOpts.tabstop - (x-off)%gOpts.tabstop\n\t\t\tfor i := 0; i < ind && x+i < win.w; i++ {\n\t\t\t\tscreen.SetContent(win.x+x+i, win.y+y, ' ', nil, st)\n\t\t\t}\n\t\t\tx += ind\n\t\t} else {\n\t\t\tx += runewidth.RuneWidth(r)\n\t\t}\n\t}\n\n\treturn st\n}\n\nfunc (win *win) printf(screen tcell.Screen, x, y int, st tcell.Style, format string, a ...interface{}) {\n\twin.print(screen, x, y, st, fmt.Sprintf(format, a...))\n}\n\nfunc (win *win) printLine(screen tcell.Screen, x, y int, st tcell.Style, s string) {\n\twin.printf(screen, x, y, st, \"%s%*s\", s, win.w-printLength(s), \"\")\n}\n\nfunc (win *win) printRight(screen tcell.Screen, y int, st tcell.Style, s string) {\n\twin.print(screen, win.w-printLength(s), y, st, s)\n}\n\nfunc (win *win) printReg(screen tcell.Screen, reg *reg, previewLoading bool, sxs *sixelScreen) {\n\tif reg == nil {\n\t\treturn\n\t}\n\n\tst := tcell.StyleDefault\n\n\tif reg.loading {\n\t\tif previewLoading {\n\t\t\tst = st.Reverse(true)\n\t\t\twin.print(screen, 2, 0, st, \"loading...\")\n\t\t}\n\t\treturn\n\t}\n\n\tfor i, l := range reg.lines {\n\t\tif i > win.h-1 {\n\t\t\tbreak\n\t\t}\n\n\t\tst = win.print(screen, 2, i, st, l)\n\t}\n\n\tsxs.printSixel(win, screen, reg)\n}\n\nvar gThisYear = time.Now().Year()\n\nfunc infotimefmt(t time.Time) string {\n\tif t.Year() == gThisYear {\n\t\treturn t.Format(gOpts.infotimefmtnew)\n\t}\n\treturn t.Format(gOpts.infotimefmtold)\n}\n\nfunc fileInfo(f *file, d *dir, userWidth int, groupWidth int) string {\n\tvar info strings.Builder\n\n\tfor _, s := range getInfo(d.path) {\n\t\tswitch s {\n\t\tcase \"size\":\n\t\t\tif f.IsDir() && gOpts.dircounts {\n\t\t\t\tswitch {\n\t\t\t\tcase f.dirCount < -1:\n\t\t\t\t\tinfo.WriteString(\"    !\")\n\t\t\t\tcase f.dirCount < 0:\n\t\t\t\t\tinfo.WriteString(\"    ?\")\n\t\t\t\tcase f.dirCount < 1000:\n\t\t\t\t\tfmt.Fprintf(&info, \" %4d\", f.dirCount)\n\t\t\t\tdefault:\n\t\t\t\t\tinfo.WriteString(\" 999+\")\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvar sz string\n\t\t\tif f.IsDir() && f.dirSize < 0 {\n\t\t\t\tsz = \"-\"\n\t\t\t} else {\n\t\t\t\tsz = humanize(f.TotalSize())\n\t\t\t}\n\t\t\tfmt.Fprintf(&info, \" %4s\", sz)\n\t\tcase \"time\":\n\t\t\tfmt.Fprintf(&info, \" %*s\", max(len(gOpts.infotimefmtnew), len(gOpts.infotimefmtold)), infotimefmt(f.ModTime()))\n\t\tcase \"atime\":\n\t\t\tfmt.Fprintf(&info, \" %*s\", max(len(gOpts.infotimefmtnew), len(gOpts.infotimefmtold)), infotimefmt(f.accessTime))\n\t\tcase \"ctime\":\n\t\t\tfmt.Fprintf(&info, \" %*s\", max(len(gOpts.infotimefmtnew), len(gOpts.infotimefmtold)), infotimefmt(f.changeTime))\n\t\tcase \"perm\":\n\t\t\tinfo.WriteString(\" \" + f.FileInfo.Mode().String())\n\t\tcase \"user\":\n\t\t\tfmt.Fprintf(&info, \" %-*s\", userWidth, userName(f.FileInfo))\n\t\tcase \"group\":\n\t\t\tfmt.Fprintf(&info, \" %-*s\", groupWidth, groupName(f.FileInfo))\n\t\tdefault:\n\t\t\tlog.Printf(\"unknown info type: %s\", s)\n\t\t}\n\t}\n\n\treturn info.String()\n}\n\ntype dirContext struct {\n\tselections map[string]int\n\tsaves      map[string]bool\n\ttags       map[string]string\n}\n\ntype dirRole byte\n\nconst (\n\tActive dirRole = iota\n\tParent\n\tPreview\n)\n\ntype dirStyle struct {\n\tcolors styleMap\n\ticons  iconMap\n\trole   dirRole\n}\n\nfunc (win *win) printDir(ui *ui, dir *dir, context *dirContext, dirStyle *dirStyle, previewLoading bool) {\n\tif win.w < 5 || dir == nil {\n\t\treturn\n\t}\n\n\tmessageStyle := tcell.StyleDefault.Reverse(true)\n\n\tif dir.noPerm {\n\t\twin.print(ui.screen, 2, 0, messageStyle, \"permission denied\")\n\t\treturn\n\t}\n\tfileslen := len(dir.files)\n\tif (dir.loading && fileslen == 0) || (dirStyle.role == Preview && dir.loading && gOpts.dirpreviews) {\n\t\tif dirStyle.role != Preview || previewLoading {\n\t\t\twin.print(ui.screen, 2, 0, messageStyle, \"loading...\")\n\t\t}\n\t\treturn\n\t}\n\n\tif dirStyle.role == Preview && gOpts.dirpreviews && len(gOpts.previewer) > 0 {\n\t\t// Print previewer result instead of default directory print operation.\n\t\tst := tcell.StyleDefault\n\t\tfor i, l := range dir.lines {\n\t\t\tif i > win.h-1 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tst = win.print(ui.screen, 2, i, st, l)\n\t\t}\n\t\treturn\n\t}\n\tif fileslen == 0 {\n\t\twin.print(ui.screen, 2, 0, messageStyle, \"empty\")\n\t\treturn\n\t}\n\n\tbeg := max(dir.ind-dir.pos, 0)\n\tend := min(beg+win.h, fileslen)\n\n\tif beg > end {\n\t\treturn\n\t}\n\n\tvar lnwidth int\n\n\tif dirStyle.role == Active && (gOpts.number || gOpts.relativenumber) {\n\t\tlnwidth = 1\n\t\tif gOpts.number && gOpts.relativenumber {\n\t\t\tlnwidth++\n\t\t}\n\t\tfor j := 10; j <= fileslen; j *= 10 {\n\t\t\tlnwidth++\n\t\t}\n\t}\n\n\tvar userWidth int\n\tvar groupWidth int\n\n\t// Only fetch user/group widths if configured to display them\n\tfor _, s := range getInfo(dir.path) {\n\t\tswitch s {\n\t\tcase \"user\":\n\t\t\tuserWidth = getUserWidth(dir, beg, end)\n\t\tcase \"group\":\n\t\t\tgroupWidth = getGroupWidth(dir, beg, end)\n\t\t}\n\n\t\tif userWidth > 0 && groupWidth > 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tfor i, f := range dir.files[beg:end] {\n\t\tst := dirStyle.colors.get(f)\n\n\t\tif lnwidth > 0 {\n\t\t\tvar ln string\n\n\t\t\tif gOpts.number && (!gOpts.relativenumber) {\n\t\t\t\tln = fmt.Sprintf(\"%*d\", lnwidth, i+1+beg)\n\t\t\t} else if gOpts.relativenumber {\n\t\t\t\tswitch {\n\t\t\t\tcase i < dir.pos:\n\t\t\t\t\tln = fmt.Sprintf(\"%*d\", lnwidth, dir.pos-i)\n\t\t\t\tcase i > dir.pos:\n\t\t\t\t\tln = fmt.Sprintf(\"%*d\", lnwidth, i-dir.pos)\n\t\t\t\tcase gOpts.number:\n\t\t\t\t\tln = fmt.Sprintf(\"%*d \", lnwidth-1, i+1+beg)\n\t\t\t\tdefault:\n\t\t\t\t\tln = fmt.Sprintf(\"%*d\", lnwidth, 0)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twin.print(ui.screen, 0, i, tcell.StyleDefault, fmt.Sprintf(optionToFmtstr(gOpts.numberfmt), ln))\n\t\t}\n\n\t\tpath := filepath.Join(dir.path, f.Name())\n\n\t\tif _, ok := context.selections[path]; ok {\n\t\t\twin.print(ui.screen, lnwidth, i, parseEscapeSequence(gOpts.selectfmt), \" \")\n\t\t} else if cp, ok := context.saves[path]; ok {\n\t\t\tif cp {\n\t\t\t\twin.print(ui.screen, lnwidth, i, parseEscapeSequence(gOpts.copyfmt), \" \")\n\t\t\t} else {\n\t\t\t\twin.print(ui.screen, lnwidth, i, parseEscapeSequence(gOpts.cutfmt), \" \")\n\t\t\t}\n\t\t}\n\n\t\t// make space for select marker, and leave another space at the end\n\t\tmaxWidth := win.w - lnwidth - 2\n\t\t// make extra space to separate windows if drawbox is not enabled\n\t\tif !gOpts.drawbox {\n\t\t\tmaxWidth -= 1\n\t\t}\n\n\t\ttag := \" \"\n\t\tif val, ok := context.tags[path]; ok && len(val) > 0 {\n\t\t\ttag = val\n\t\t}\n\n\t\tvar icon []rune\n\t\tvar iconDef iconDef\n\t\tif gOpts.icons {\n\t\t\ticonDef = dirStyle.icons.get(f)\n\t\t\ticon = append(icon, []rune(iconDef.icon)...)\n\t\t\ticon = append(icon, ' ')\n\t\t}\n\n\t\t// subtract space for tag and icon\n\t\tmaxFilenameWidth := maxWidth - 1 - runeSliceWidth(icon)\n\n\t\tinfo := fileInfo(f, dir, userWidth, groupWidth)\n\t\tinfolen := len(info)\n\t\tshowInfo := infolen > 0 && 2*infolen < maxWidth\n\t\tif showInfo {\n\t\t\tmaxFilenameWidth -= infolen\n\t\t}\n\n\t\tfilename := []rune(f.Name())\n\t\tif runeSliceWidth(filename) > maxFilenameWidth {\n\t\t\ttruncatePos := (maxFilenameWidth - 1) * gOpts.truncatepct / 100\n\t\t\tlastPart := runeSliceWidthLastRange(filename, maxFilenameWidth-truncatePos-1)\n\t\t\tfilename = runeSliceWidthRange(filename, 0, truncatePos)\n\t\t\tfilename = append(filename, []rune(gOpts.truncatechar)...)\n\t\t\tfilename = append(filename, lastPart...)\n\t\t}\n\t\tfor j := runeSliceWidth(filename); j < maxFilenameWidth; j++ {\n\t\t\tfilename = append(filename, ' ')\n\t\t}\n\n\t\tif showInfo {\n\t\t\tfilename = append(filename, []rune(info)...)\n\t\t}\n\n\t\tif i == dir.pos {\n\t\t\tvar cursorFmt string\n\t\t\tswitch dirStyle.role {\n\t\t\tcase Active:\n\t\t\t\tcursorFmt = optionToFmtstr(gOpts.cursoractivefmt)\n\t\t\tcase Parent:\n\t\t\t\tcursorFmt = optionToFmtstr(gOpts.cursorparentfmt)\n\t\t\tcase Preview:\n\t\t\t\tcursorFmt = optionToFmtstr(gOpts.cursorpreviewfmt)\n\t\t\t}\n\n\t\t\t// print tag separately as it can contain color escape sequences\n\t\t\twin.print(ui.screen, lnwidth+1, i, st, fmt.Sprintf(cursorFmt, tag))\n\n\t\t\tline := append(icon, filename...)\n\t\t\tline = append(line, ' ')\n\t\t\twin.print(ui.screen, lnwidth+2, i, st, fmt.Sprintf(cursorFmt, string(line)))\n\t\t} else {\n\t\t\tif tag == \" \" {\n\t\t\t\twin.print(ui.screen, lnwidth+1, i, st, \" \")\n\t\t\t} else {\n\t\t\t\ttagStr := fmt.Sprintf(optionToFmtstr(gOpts.tagfmt), tag)\n\t\t\t\twin.print(ui.screen, lnwidth+1, i, tcell.StyleDefault, tagStr)\n\t\t\t}\n\n\t\t\tif len(icon) > 0 {\n\t\t\t\ticonStyle := st\n\t\t\t\tif iconDef.hasStyle {\n\t\t\t\t\ticonStyle = iconDef.style\n\t\t\t\t}\n\t\t\t\twin.print(ui.screen, lnwidth+2, i, iconStyle, string(icon))\n\t\t\t}\n\n\t\t\tline := append(filename, ' ')\n\t\t\twin.print(ui.screen, lnwidth+2+runeSliceWidth(icon), i, st, string(line))\n\t\t}\n\t}\n}\n\nfunc getUserWidth(dir *dir, beg int, end int) int {\n\tmaxw := 0\n\n\tfor _, f := range dir.files[beg:end] {\n\t\tmaxw = max(len(userName(f.FileInfo)), maxw)\n\t}\n\n\treturn maxw\n}\n\nfunc getGroupWidth(dir *dir, beg int, end int) int {\n\tmaxw := 0\n\n\tfor _, f := range dir.files[beg:end] {\n\t\tmaxw = max(len(groupName(f.FileInfo)), maxw)\n\t}\n\n\treturn maxw\n}\n\nfunc getWidths(wtot int) []int {\n\trsum := 0\n\tfor _, r := range gOpts.ratios {\n\t\trsum += r\n\t}\n\n\twlen := len(gOpts.ratios)\n\twidths := make([]int, wlen)\n\n\tif gOpts.drawbox {\n\t\twtot -= (wlen + 1)\n\t}\n\n\twsum := 0\n\tfor i := 0; i < wlen-1; i++ {\n\t\twidths[i] = gOpts.ratios[i] * wtot / rsum\n\t\twsum += widths[i]\n\t}\n\twidths[wlen-1] = wtot - wsum\n\n\treturn widths\n}\n\nfunc getWins(screen tcell.Screen) []*win {\n\twtot, htot := screen.Size()\n\n\twidths := getWidths(wtot)\n\n\twacc := 0\n\twlen := len(widths)\n\twins := make([]*win, 0, wlen)\n\tfor i := 0; i < wlen; i++ {\n\t\tif gOpts.drawbox {\n\t\t\twacc++\n\t\t\twins = append(wins, newWin(widths[i], htot-4, wacc, 2))\n\t\t} else {\n\t\t\twins = append(wins, newWin(widths[i], htot-2, wacc, 1))\n\t\t}\n\t\twacc += widths[i]\n\t}\n\n\treturn wins\n}\n\ntype ui struct {\n\tscreen      tcell.Screen\n\tsxScreen    sixelScreen\n\tpolling     bool\n\twins        []*win\n\tpromptWin   *win\n\tmsgWin      *win\n\tmenuWin     *win\n\tmsg         string\n\tmsgIsStat   bool\n\tregPrev     *reg\n\tdirPrev     *dir\n\texprChan    chan expr\n\tkeyChan     chan string\n\ttevChan     chan tcell.Event\n\tevChan      chan tcell.Event\n\tmenuBuf     *bytes.Buffer\n\tcmdPrefix   string\n\tcmdAccLeft  []rune\n\tcmdAccRight []rune\n\tcmdYankBuf  []rune\n\tcmdTmp      []rune\n\tkeyAcc      []rune\n\tkeyCount    []rune\n\tstyles      styleMap\n\ticons       iconMap\n\tcurrentFile string\n}\n\nfunc newUI(screen tcell.Screen) *ui {\n\twtot, htot := screen.Size()\n\n\tui := &ui{\n\t\tscreen:      screen,\n\t\tpolling:     true,\n\t\twins:        getWins(screen),\n\t\tpromptWin:   newWin(wtot, 1, 0, 0),\n\t\tmsgWin:      newWin(wtot, 1, 0, htot-1),\n\t\tmenuWin:     newWin(wtot, 1, 0, htot-2),\n\t\tmsgIsStat:   true,\n\t\texprChan:    make(chan expr, 1000),\n\t\tkeyChan:     make(chan string, 1000),\n\t\ttevChan:     make(chan tcell.Event, 1000),\n\t\tevChan:      make(chan tcell.Event, 1000),\n\t\tstyles:      parseStyles(),\n\t\ticons:       parseIcons(),\n\t\tcurrentFile: \"\",\n\t\tsxScreen:    sixelScreen{},\n\t}\n\n\tgo ui.pollEvents()\n\n\treturn ui\n}\n\nfunc (ui *ui) winAt(x, y int) (int, *win) {\n\tfor i := len(ui.wins) - 1; i >= 0; i-- {\n\t\tw := ui.wins[i]\n\t\tif x >= w.x && y >= w.y && y < w.y+w.h {\n\t\t\treturn i, w\n\t\t}\n\t}\n\treturn -1, nil\n}\n\nfunc (ui *ui) pollEvents() {\n\tvar ev tcell.Event\n\tfor {\n\t\tev = ui.screen.PollEvent()\n\t\tif ev == nil {\n\t\t\tui.polling = false\n\t\t\treturn\n\t\t}\n\t\tui.tevChan <- ev\n\t}\n}\n\nfunc (ui *ui) renew() {\n\tui.wins = getWins(ui.screen)\n\n\twtot, htot := ui.screen.Size()\n\tui.promptWin.renew(wtot, 1, 0, 0)\n\tui.msgWin.renew(wtot, 1, 0, htot-1)\n\tui.menuWin.renew(wtot, 1, 0, htot-2)\n}\n\nfunc (ui *ui) sort() {\n\tif ui.dirPrev == nil {\n\t\treturn\n\t}\n\tname := ui.dirPrev.name()\n\tui.dirPrev.sort()\n\tui.dirPrev.sel(name, ui.wins[0].h)\n}\n\nfunc (ui *ui) echo(msg string) {\n\tui.msg = msg\n\tui.msgIsStat = false\n}\n\nfunc (ui *ui) echomsg(msg string) {\n\tui.echo(msg)\n\tlog.Print(msg)\n}\n\nfunc optionToFmtstr(optstr string) string {\n\tif !strings.Contains(optstr, \"%s\") {\n\t\treturn optstr + \"%s\\033[0m\"\n\t} else {\n\t\treturn optstr\n\t}\n}\n\nfunc (ui *ui) echoerr(msg string) {\n\tui.echo(fmt.Sprintf(optionToFmtstr(gOpts.errorfmt), msg))\n\tlog.Printf(\"error: %s\", msg)\n}\n\nfunc (ui *ui) echoerrf(format string, a ...interface{}) {\n\tui.echoerr(fmt.Sprintf(format, a...))\n}\n\ntype reg struct {\n\tloading  bool\n\tvolatile bool\n\tloadTime time.Time\n\tpath     string\n\tlines    []string\n\tsixel    *string\n}\n\nfunc (ui *ui) loadFile(app *app, volatile bool) {\n\tif !app.nav.init {\n\t\treturn\n\t}\n\n\tcurr, err := app.nav.currFile()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif curr.path != ui.currentFile {\n\t\tui.currentFile = curr.path\n\t\tonSelect(app)\n\t}\n\n\tif volatile {\n\t\tapp.nav.previewChan <- \"\"\n\t}\n\n\tif !gOpts.preview {\n\t\treturn\n\t}\n\n\tif curr.IsDir() {\n\t\tui.dirPrev = app.nav.loadDir(curr.path)\n\t} else if curr.Mode().IsRegular() {\n\t\tui.regPrev = app.nav.loadReg(curr.path, volatile)\n\t}\n}\n\nfunc (ui *ui) loadFileInfo(nav *nav) {\n\tif !nav.init {\n\t\treturn\n\t}\n\n\tui.msg = \"\"\n\tui.msgIsStat = true\n\n\tcurr, err := nav.currFile()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif curr.err != nil {\n\t\tui.echoerrf(\"stat: %s\", curr.err)\n\t\treturn\n\t}\n\n\tstatfmt := strings.ReplaceAll(gOpts.statfmt, \"|\", \"\\x1f\")\n\treplace := func(s string, val string) {\n\t\tif val == \"\" {\n\t\t\tval = \"\\x00\"\n\t\t}\n\t\tstatfmt = strings.ReplaceAll(statfmt, s, val)\n\t}\n\treplace(\"%p\", curr.Mode().String())\n\treplace(\"%c\", linkCount(curr))\n\treplace(\"%u\", userName(curr))\n\treplace(\"%g\", groupName(curr))\n\treplace(\"%s\", humanize(curr.Size()))\n\treplace(\"%S\", fmt.Sprintf(\"%4s\", humanize(curr.Size())))\n\treplace(\"%t\", curr.ModTime().Format(gOpts.timefmt))\n\treplace(\"%l\", curr.linkTarget)\n\n\tvar fileInfo strings.Builder\n\tfor _, section := range strings.Split(statfmt, \"\\x1f\") {\n\t\tif !strings.Contains(section, \"\\x00\") {\n\t\t\tfileInfo.WriteString(section)\n\t\t}\n\t}\n\n\tui.msg = fileInfo.String()\n}\n\nfunc (ui *ui) drawPromptLine(nav *nav) {\n\tst := tcell.StyleDefault\n\n\tdir := nav.currDir()\n\tpwd := dir.path\n\n\tif strings.HasPrefix(pwd, gUser.HomeDir) {\n\t\tpwd = filepath.Join(\"~\", strings.TrimPrefix(pwd, gUser.HomeDir))\n\t}\n\n\tsep := string(filepath.Separator)\n\n\tvar fname string\n\tcurr, err := nav.currFile()\n\tif err == nil {\n\t\tfname = filepath.Base(curr.path)\n\t}\n\n\tvar prompt string\n\n\tprompt = strings.ReplaceAll(gOpts.promptfmt, \"%u\", gUser.Username)\n\tprompt = strings.ReplaceAll(prompt, \"%h\", gHostname)\n\tprompt = strings.ReplaceAll(prompt, \"%f\", fname)\n\n\tif printLength(strings.ReplaceAll(strings.ReplaceAll(prompt, \"%w\", pwd), \"%d\", pwd)) > ui.promptWin.w {\n\t\tnames := strings.Split(pwd, sep)\n\t\tfor i := range names {\n\t\t\tif names[i] == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tr, _ := utf8.DecodeRuneInString(names[i])\n\t\t\tnames[i] = string(r)\n\t\t\tif printLength(strings.ReplaceAll(strings.ReplaceAll(prompt, \"%w\", strings.Join(names, sep)), \"%d\", strings.Join(names, sep))) <= ui.promptWin.w {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tpwd = strings.Join(names, sep)\n\t}\n\n\tprompt = strings.ReplaceAll(prompt, \"%w\", pwd)\n\tif !strings.HasSuffix(pwd, sep) {\n\t\tpwd += sep\n\t}\n\tprompt = strings.ReplaceAll(prompt, \"%d\", pwd)\n\n\tif len(dir.filter) != 0 {\n\t\tprompt = strings.ReplaceAll(prompt, \"%F\", fmt.Sprint(dir.filter))\n\t} else {\n\t\tprompt = strings.ReplaceAll(prompt, \"%F\", \"\")\n\t}\n\n\t// spacer\n\tavail := ui.promptWin.w - printLength(prompt) + 2\n\tif avail > 0 {\n\t\tprompt = strings.Replace(prompt, \"%S\", strings.Repeat(\" \", avail), 1)\n\t}\n\tprompt = strings.ReplaceAll(prompt, \"%S\", \"\")\n\n\tui.promptWin.print(ui.screen, 0, 0, st, prompt)\n}\n\nfunc formatRulerOpt(name string, val string) string {\n\t// handle escape character so it doesn't mess up the ruler\n\tval = strings.ReplaceAll(val, \"\\033\", \"\\033[7m\\\\033\\033[0m\")\n\n\t// display name of builtin options for clarity\n\tif !strings.HasPrefix(name, \"lf_user_\") {\n\t\treturn fmt.Sprintf(\"%s=%s\", strings.TrimPrefix(name, \"lf_\"), val)\n\t}\n\n\treturn val\n}\n\nfunc (ui *ui) drawRuler(nav *nav) {\n\tst := tcell.StyleDefault\n\n\tdir := nav.currDir()\n\n\tui.msgWin.print(ui.screen, 0, 0, st, ui.msg)\n\n\ttot := len(dir.files)\n\tind := min(dir.ind+1, tot)\n\thid := len(dir.allFiles) - tot\n\tacc := string(ui.keyCount) + string(ui.keyAcc)\n\n\tcopy := 0\n\tmove := 0\n\tfor _, cp := range nav.saves {\n\t\tif cp {\n\t\t\tcopy++\n\t\t} else {\n\t\t\tmove++\n\t\t}\n\t}\n\n\tcurrSelections := nav.currSelections()\n\n\tprogress := []string{}\n\n\tif nav.copyTotal > 0 {\n\t\tpercentage := int((100 * float64(nav.copyBytes)) / float64(nav.copyTotal))\n\t\tprogress = append(progress, fmt.Sprintf(\"[%d%%]\", percentage))\n\t}\n\n\tif nav.moveTotal > 0 {\n\t\tprogress = append(progress, fmt.Sprintf(\"[%d/%d]\", nav.moveCount, nav.moveTotal))\n\t}\n\n\tif nav.deleteTotal > 0 {\n\t\tprogress = append(progress, fmt.Sprintf(\"[%d/%d]\", nav.deleteCount, nav.deleteTotal))\n\t}\n\n\topts := getOptsMap()\n\n\trulerfmt := strings.ReplaceAll(gOpts.rulerfmt, \"|\", \"\\x1f\")\n\trulerfmt = reRulerSub.ReplaceAllStringFunc(rulerfmt, func(s string) string {\n\t\tvar result string\n\t\tswitch s {\n\t\tcase \"%a\":\n\t\t\tresult = acc\n\t\tcase \"%p\":\n\t\t\tresult = strings.Join(progress, \" \")\n\t\tcase \"%m\":\n\t\t\tresult = fmt.Sprintf(\"%.d\", move)\n\t\tcase \"%c\":\n\t\t\tresult = fmt.Sprintf(\"%.d\", copy)\n\t\tcase \"%s\":\n\t\t\tresult = fmt.Sprintf(\"%.d\", len(currSelections))\n\t\tcase \"%f\":\n\t\t\tresult = strings.Join(dir.filter, \" \")\n\t\tcase \"%i\":\n\t\t\tresult = strconv.Itoa(ind)\n\t\tcase \"%t\":\n\t\t\tresult = strconv.Itoa(tot)\n\t\tcase \"%h\":\n\t\t\tresult = strconv.Itoa(hid)\n\t\tcase \"%d\":\n\t\t\tresult = diskFree(dir.path)\n\t\tdefault:\n\t\t\ts = strings.TrimSuffix(strings.TrimPrefix(s, \"%{\"), \"}\")\n\t\t\tif val, ok := opts[s]; ok {\n\t\t\t\tresult = formatRulerOpt(s, val)\n\t\t\t}\n\t\t}\n\t\tif result == \"\" {\n\t\t\treturn \"\\x00\"\n\t\t}\n\t\treturn result\n\t})\n\tvar ruler strings.Builder\n\tfor _, section := range strings.Split(rulerfmt, \"\\x1f\") {\n\t\tif !strings.Contains(section, \"\\x00\") {\n\t\t\truler.WriteString(section)\n\t\t}\n\t}\n\tui.msgWin.printRight(ui.screen, 0, st, ruler.String())\n}\n\nfunc (ui *ui) drawBox() {\n\tst := parseEscapeSequence(gOpts.borderfmt)\n\n\tw, h := ui.screen.Size()\n\n\tfor i := 1; i < w-1; i++ {\n\t\tui.screen.SetContent(i, 1, tcell.RuneHLine, nil, st)\n\t\tui.screen.SetContent(i, h-2, tcell.RuneHLine, nil, st)\n\t}\n\n\tfor i := 2; i < h-2; i++ {\n\t\tui.screen.SetContent(0, i, tcell.RuneVLine, nil, st)\n\t\tui.screen.SetContent(w-1, i, tcell.RuneVLine, nil, st)\n\t}\n\n\tif gOpts.roundbox {\n\t\tui.screen.SetContent(0, 1, '╭', nil, st)\n\t\tui.screen.SetContent(w-1, 1, '╮', nil, st)\n\t\tui.screen.SetContent(0, h-2, '╰', nil, st)\n\t\tui.screen.SetContent(w-1, h-2, '╯', nil, st)\n\t} else {\n\t\tui.screen.SetContent(0, 1, tcell.RuneULCorner, nil, st)\n\t\tui.screen.SetContent(w-1, 1, tcell.RuneURCorner, nil, st)\n\t\tui.screen.SetContent(0, h-2, tcell.RuneLLCorner, nil, st)\n\t\tui.screen.SetContent(w-1, h-2, tcell.RuneLRCorner, nil, st)\n\t}\n\n\twacc := 0\n\tfor wind := 0; wind < len(ui.wins)-1; wind++ {\n\t\twacc += ui.wins[wind].w + 1\n\t\tui.screen.SetContent(wacc, 1, tcell.RuneTTee, nil, st)\n\t\tfor i := 2; i < h-2; i++ {\n\t\t\tui.screen.SetContent(wacc, i, tcell.RuneVLine, nil, st)\n\t\t}\n\t\tui.screen.SetContent(wacc, h-2, tcell.RuneBTee, nil, st)\n\t}\n}\n\nfunc (ui *ui) dirOfWin(nav *nav, wind int) *dir {\n\twins := len(ui.wins)\n\tif gOpts.preview {\n\t\twins--\n\t}\n\tind := len(nav.dirs) - wins + wind\n\tif ind < 0 {\n\t\treturn nil\n\t}\n\treturn nav.dirs[ind]\n}\n\nfunc (ui *ui) draw(nav *nav) {\n\tst := tcell.StyleDefault\n\tcontext := dirContext{selections: nav.selections, saves: nav.saves, tags: nav.tags}\n\n\t// XXX: manual clean without flush to avoid flicker on Windows\n\twtot, htot := ui.screen.Size()\n\tfor i := 0; i < wtot; i++ {\n\t\tfor j := 0; j < htot; j++ {\n\t\t\tui.screen.SetContent(i, j, ' ', nil, st)\n\t\t}\n\t}\n\tui.sxScreen.sixel = nil\n\n\tui.drawPromptLine(nav)\n\n\twins := len(ui.wins)\n\tif gOpts.preview {\n\t\twins--\n\t}\n\tfor i := 0; i < wins; i++ {\n\t\trole := Parent\n\t\tif i == wins-1 {\n\t\t\trole = Active\n\t\t}\n\t\tif dir := ui.dirOfWin(nav, i); dir != nil {\n\t\t\tui.wins[i].printDir(ui, dir, &context,\n\t\t\t\t&dirStyle{colors: ui.styles, icons: ui.icons, role: role},\n\t\t\t\tnav.previewLoading)\n\t\t}\n\t}\n\n\tswitch ui.cmdPrefix {\n\tcase \"\":\n\t\tui.drawRuler(nav)\n\t\tui.screen.HideCursor()\n\tcase \">\":\n\t\tmaxWidth := ui.msgWin.w - 1 // leave space for cursor at the end\n\t\tprefix := runeSliceWidthRange([]rune(ui.cmdPrefix), 0, maxWidth)\n\t\tleft := runeSliceWidthLastRange(ui.cmdAccLeft, maxWidth-runeSliceWidth(prefix)-printLength(ui.msg))\n\t\tui.msgWin.printLine(ui.screen, 0, 0, st, string(prefix)+ui.msg)\n\t\tui.msgWin.print(ui.screen, runeSliceWidth(prefix)+printLength(ui.msg), 0, st, string(left)+string(ui.cmdAccRight))\n\t\tui.screen.ShowCursor(ui.msgWin.x+runeSliceWidth(prefix)+printLength(ui.msg)+runeSliceWidth(left), ui.msgWin.y)\n\tdefault:\n\t\tmaxWidth := ui.msgWin.w - 1 // leave space for cursor at the end\n\t\tprefix := runeSliceWidthRange([]rune(ui.cmdPrefix), 0, maxWidth)\n\t\tleft := runeSliceWidthLastRange(ui.cmdAccLeft, maxWidth-runeSliceWidth(prefix))\n\t\tui.msgWin.printLine(ui.screen, 0, 0, st, string(prefix)+string(left)+string(ui.cmdAccRight))\n\t\tui.screen.ShowCursor(ui.msgWin.x+runeSliceWidth(prefix)+runeSliceWidth(left), ui.msgWin.y)\n\t}\n\n\tif gOpts.preview {\n\t\tcurr, err := nav.currFile()\n\t\tif err == nil {\n\t\t\tpreview := ui.wins[len(ui.wins)-1]\n\n\t\t\tif curr.IsDir() {\n\t\t\t\tpreview.printDir(ui, ui.dirPrev, &context,\n\t\t\t\t\t&dirStyle{colors: ui.styles, icons: ui.icons, role: Preview},\n\t\t\t\t\tnav.previewLoading)\n\t\t\t} else if curr.Mode().IsRegular() {\n\t\t\t\tpreview.printReg(ui.screen, ui.regPrev, nav.previewLoading, &ui.sxScreen)\n\t\t\t}\n\t\t}\n\t}\n\n\tif gOpts.drawbox {\n\t\tui.drawBox()\n\t}\n\n\tif ui.menuBuf != nil {\n\t\tlines := strings.Split(ui.menuBuf.String(), \"\\n\")\n\n\t\tlines = lines[:len(lines)-1]\n\n\t\tui.menuWin.h = len(lines) - 1\n\t\tui.menuWin.y = ui.wins[0].h - ui.menuWin.h\n\n\t\tif gOpts.drawbox {\n\t\t\tui.menuWin.y += 2\n\t\t}\n\n\t\tui.menuWin.printLine(ui.screen, 0, 0, st.Bold(true), lines[0])\n\n\t\tfor i, line := range lines[1:] {\n\t\t\tui.menuWin.printLine(ui.screen, 0, i+1, st, \"\")\n\t\t\tui.menuWin.print(ui.screen, 0, i+1, st, line)\n\t\t}\n\t}\n\n\tui.screen.Show()\n\tif ui.menuBuf == nil && ui.cmdPrefix == \"\" && ui.sxScreen.sixel != nil {\n\t\tui.sxScreen.lastFile = ui.regPrev.path\n\t\tui.sxScreen.showSixels()\n\t}\n}\n\nfunc findBinds(keys map[string]expr, prefix string) (binds map[string]expr, ok bool) {\n\tbinds = make(map[string]expr)\n\tfor key, expr := range keys {\n\t\tif !strings.HasPrefix(key, prefix) {\n\t\t\tcontinue\n\t\t}\n\t\tbinds[key] = expr\n\t\tif key == prefix {\n\t\t\tok = true\n\t\t}\n\t}\n\treturn\n}\n\nfunc listExprMap(binds map[string]expr, title string) *bytes.Buffer {\n\tt := new(tabwriter.Writer)\n\tb := new(bytes.Buffer)\n\n\tkeys := make([]string, 0, len(binds))\n\tfor k := range binds {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\n\tt.Init(b, 0, gOpts.tabstop, 2, '\\t', 0)\n\tfmt.Fprintf(t, \"%s\\tcommand\\n\", title)\n\tfor _, k := range keys {\n\t\tfmt.Fprintf(t, \"%s\\t%v\\n\", k, binds[k])\n\t}\n\tt.Flush()\n\n\treturn b\n}\n\nfunc listBinds(binds map[string]expr) *bytes.Buffer {\n\treturn listExprMap(binds, \"keys\")\n}\n\nfunc listCmds() *bytes.Buffer {\n\treturn listExprMap(gOpts.cmds, \"name\")\n}\n\nfunc listJumps(jumps []string, ind int) *bytes.Buffer {\n\tt := new(tabwriter.Writer)\n\tb := new(bytes.Buffer)\n\n\tmaxlength := len(strconv.Itoa(max(ind, len(jumps)-1-ind)))\n\n\tt.Init(b, 0, gOpts.tabstop, 2, '\\t', 0)\n\tfmt.Fprintln(t, \"  jump\\tpath\")\n\t// print jumps in order of most recent, Vim uses the opposite order\n\tfor i := len(jumps) - 1; i >= 0; i-- {\n\t\tswitch {\n\t\tcase i < ind:\n\t\t\tfmt.Fprintf(t, \"  %*d\\t%s\\n\", maxlength, ind-i, jumps[i])\n\t\tcase i > ind:\n\t\t\tfmt.Fprintf(t, \"  %*d\\t%s\\n\", maxlength, i-ind, jumps[i])\n\t\tdefault:\n\t\t\tfmt.Fprintf(t, \"> %*d\\t%s\\n\", maxlength, 0, jumps[i])\n\t\t}\n\t}\n\tt.Flush()\n\n\treturn b\n}\n\nfunc listHistory(history []cmdItem) *bytes.Buffer {\n\tt := new(tabwriter.Writer)\n\tb := new(bytes.Buffer)\n\n\tmaxlength := len(strconv.Itoa(len(history)))\n\n\tt.Init(b, 0, gOpts.tabstop, 2, '\\t', 0)\n\tfmt.Fprintln(t, \"number\\tcommand\")\n\tfor i, cmd := range history {\n\t\tfmt.Fprintf(t, \"%*d\\t%s%s\\n\", maxlength, i+1, cmd.prefix, cmd.value)\n\t}\n\tt.Flush()\n\n\treturn b\n}\n\nfunc listMarks(marks map[string]string) *bytes.Buffer {\n\tt := new(tabwriter.Writer)\n\tb := new(bytes.Buffer)\n\n\tkeys := make([]string, 0, len(marks))\n\tfor k := range marks {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\n\tt.Init(b, 0, gOpts.tabstop, 2, '\\t', 0)\n\tfmt.Fprintln(t, \"mark\\tpath\")\n\tfor _, k := range keys {\n\t\tfmt.Fprintf(t, \"%s\\t%s\\n\", k, marks[k])\n\t}\n\tt.Flush()\n\n\treturn b\n}\n\nfunc (ui *ui) pollEvent() tcell.Event {\n\tselect {\n\tcase val := <-ui.keyChan:\n\t\tvar ch rune\n\t\tvar mod tcell.ModMask\n\t\tk := tcell.KeyRune\n\n\t\tif key, ok := gValKey[val]; ok {\n\t\t\treturn tcell.NewEventKey(key, ch, mod)\n\t\t}\n\n\t\tswitch {\n\t\tcase utf8.RuneCountInString(val) == 1:\n\t\t\tch, _ = utf8.DecodeRuneInString(val)\n\t\tcase val == \"<lt>\":\n\t\t\tch = '<'\n\t\tcase val == \"<gt>\":\n\t\t\tch = '>'\n\t\tcase val == \"<space>\":\n\t\t\tch = ' '\n\t\tcase reModKey.MatchString(val):\n\t\t\tmatches := reModKey.FindStringSubmatch(val)\n\t\t\tswitch matches[1] {\n\t\t\tcase \"c\":\n\t\t\t\tmod = tcell.ModCtrl\n\t\t\tcase \"s\":\n\t\t\t\tmod = tcell.ModShift\n\t\t\tcase \"a\":\n\t\t\t\tmod = tcell.ModAlt\n\t\t\t}\n\t\t\tval = matches[2]\n\t\t\tif utf8.RuneCountInString(val) == 1 {\n\t\t\t\tch, _ = utf8.DecodeRuneInString(val)\n\t\t\t\tbreak\n\t\t\t} else if key, ok := gValKey[\"<\"+val+\">\"]; ok {\n\t\t\t\tk = key\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfallthrough\n\t\tdefault:\n\t\t\tk = tcell.KeyESC\n\t\t\tui.echoerrf(\"unknown key: %s\", val)\n\t\t}\n\n\t\treturn tcell.NewEventKey(k, ch, mod)\n\tcase ev := <-ui.tevChan:\n\t\treturn ev\n\t}\n}\n\nfunc addSpecialKeyModifier(val string, mod tcell.ModMask) string {\n\tswitch {\n\tcase !strings.HasPrefix(val, \"<\"):\n\t\treturn val\n\tcase mod == tcell.ModCtrl && !strings.HasPrefix(val, \"<c-\"):\n\t\treturn \"<c-\" + val[1:]\n\tcase mod == tcell.ModShift:\n\t\treturn \"<s-\" + val[1:]\n\tcase mod == tcell.ModAlt:\n\t\treturn \"<a-\" + val[1:]\n\tdefault:\n\t\treturn val\n\t}\n}\n\n// This function is used to read a normal event on the client side. For keys,\n// digits are interpreted as command counts but this is only done for digits\n// preceding any non-digit characters (e.g. \"42y2k\" as 42 times \"y2k\").\nfunc (ui *ui) readNormalEvent(ev tcell.Event, nav *nav) expr {\n\tdraw := &callExpr{\"draw\", nil, 1}\n\tcount := 0\n\n\tswitch tev := ev.(type) {\n\tcase *tcell.EventKey:\n\t\t// KeyRune is a regular character\n\t\tif tev.Key() == tcell.KeyRune {\n\t\t\tswitch {\n\t\t\tcase tev.Rune() == '<':\n\t\t\t\tui.keyAcc = append(ui.keyAcc, []rune(\"<lt>\")...)\n\t\t\tcase tev.Rune() == '>':\n\t\t\t\tui.keyAcc = append(ui.keyAcc, []rune(\"<gt>\")...)\n\t\t\tcase tev.Rune() == ' ':\n\t\t\t\tui.keyAcc = append(ui.keyAcc, []rune(\"<space>\")...)\n\t\t\tcase tev.Modifiers() == tcell.ModAlt:\n\t\t\t\tui.keyAcc = append(ui.keyAcc, '<', 'a', '-', tev.Rune(), '>')\n\t\t\tcase unicode.IsDigit(tev.Rune()) && len(ui.keyAcc) == 0:\n\t\t\t\tui.keyCount = append(ui.keyCount, tev.Rune())\n\t\t\tdefault:\n\t\t\t\tui.keyAcc = append(ui.keyAcc, tev.Rune())\n\t\t\t}\n\t\t} else {\n\t\t\tval := gKeyVal[tev.Key()]\n\t\t\tval = addSpecialKeyModifier(val, tev.Modifiers())\n\t\t\tif val == \"<esc>\" && len(ui.keyAcc) != 0 {\n\t\t\t\tui.keyAcc = nil\n\t\t\t\tui.keyCount = nil\n\t\t\t\tui.menuBuf = nil\n\t\t\t\treturn draw\n\t\t\t}\n\t\t\tui.keyAcc = append(ui.keyAcc, []rune(val)...)\n\t\t}\n\n\t\tif len(ui.keyAcc) == 0 {\n\t\t\treturn draw\n\t\t}\n\n\t\tbinds, ok := findBinds(gOpts.keys, string(ui.keyAcc))\n\n\t\tswitch len(binds) {\n\t\tcase 0:\n\t\t\tui.echoerrf(\"unknown mapping: %s\", string(ui.keyAcc))\n\t\t\tui.keyAcc = nil\n\t\t\tui.keyCount = nil\n\t\t\tui.menuBuf = nil\n\t\t\treturn draw\n\t\tdefault:\n\t\t\tif ok {\n\t\t\t\tif len(ui.keyCount) > 0 {\n\t\t\t\t\tc, err := strconv.Atoi(string(ui.keyCount))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Printf(\"converting command count: %s\", err)\n\t\t\t\t\t}\n\t\t\t\t\tcount = c\n\t\t\t\t}\n\t\t\t\texpr := gOpts.keys[string(ui.keyAcc)]\n\n\t\t\t\tif count != 0 {\n\t\t\t\t\tswitch e := expr.(type) {\n\t\t\t\t\tcase *callExpr:\n\t\t\t\t\t\texpr = &callExpr{name: e.name, args: e.args, count: count}\n\t\t\t\t\tcase *listExpr:\n\t\t\t\t\t\texpr = &listExpr{exprs: e.exprs, count: count}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tui.keyAcc = nil\n\t\t\t\tui.keyCount = nil\n\t\t\t\tui.menuBuf = nil\n\t\t\t\treturn expr\n\t\t\t}\n\t\t\tif gOpts.showbinds {\n\t\t\t\tui.menuBuf = listBinds(binds)\n\t\t\t}\n\t\t\treturn draw\n\t\t}\n\tcase *tcell.EventMouse:\n\t\tif ui.cmdPrefix != \"\" {\n\t\t\treturn nil\n\t\t}\n\n\t\tvar button string\n\n\t\tswitch tev.Buttons() {\n\t\tcase tcell.Button1:\n\t\t\tbutton = \"<m-1>\"\n\t\tcase tcell.Button2:\n\t\t\tbutton = \"<m-2>\"\n\t\tcase tcell.Button3:\n\t\t\tbutton = \"<m-3>\"\n\t\tcase tcell.Button4:\n\t\t\tbutton = \"<m-4>\"\n\t\tcase tcell.Button5:\n\t\t\tbutton = \"<m-5>\"\n\t\tcase tcell.Button6:\n\t\t\tbutton = \"<m-6>\"\n\t\tcase tcell.Button7:\n\t\t\tbutton = \"<m-7>\"\n\t\tcase tcell.Button8:\n\t\t\tbutton = \"<m-8>\"\n\t\tcase tcell.WheelUp:\n\t\t\tbutton = \"<m-up>\"\n\t\tcase tcell.WheelDown:\n\t\t\tbutton = \"<m-down>\"\n\t\tcase tcell.WheelLeft:\n\t\t\tbutton = \"<m-left>\"\n\t\tcase tcell.WheelRight:\n\t\t\tbutton = \"<m-right>\"\n\t\tcase tcell.ButtonNone:\n\t\t\treturn nil\n\t\t}\n\t\tif tev.Modifiers() == tcell.ModCtrl {\n\t\t\tbutton = \"<c-\" + button[1:]\n\t\t}\n\t\tif expr, ok := gOpts.keys[button]; ok {\n\t\t\treturn expr\n\t\t}\n\t\tif button != \"<m-1>\" && button != \"<m-2>\" {\n\t\t\tui.echoerrf(\"unknown mapping: %s\", button)\n\t\t\tui.keyAcc = nil\n\t\t\tui.keyCount = nil\n\t\t\tui.menuBuf = nil\n\t\t\treturn draw\n\t\t}\n\n\t\tx, y := tev.Position()\n\t\twind, w := ui.winAt(x, y)\n\t\tif wind == -1 {\n\t\t\treturn nil\n\t\t}\n\n\t\tvar dir *dir\n\t\tif gOpts.preview && wind == len(ui.wins)-1 {\n\t\t\tcurr, err := nav.currFile()\n\t\t\tif err != nil {\n\t\t\t\treturn nil\n\t\t\t} else if !curr.IsDir() || gOpts.dirpreviews {\n\t\t\t\tif tev.Buttons() != tcell.Button2 {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn &callExpr{\"open\", nil, 1}\n\t\t\t}\n\t\t\tdir = ui.dirPrev\n\t\t} else {\n\t\t\tdir = ui.dirOfWin(nav, wind)\n\t\t\tif dir == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\tvar file *file\n\t\tind := dir.ind - dir.pos + y - w.y\n\t\tif ind < len(dir.files) {\n\t\t\tfile = dir.files[ind]\n\t\t}\n\n\t\tif file != nil {\n\t\t\tsel := &callExpr{\"select\", []string{file.path}, 1}\n\n\t\t\tif tev.Buttons() == tcell.Button1 {\n\t\t\t\treturn sel\n\t\t\t}\n\t\t\tif file.IsDir() {\n\t\t\t\treturn &callExpr{\"cd\", []string{file.path}, 1}\n\t\t\t}\n\t\t\treturn &listExpr{[]expr{sel, &callExpr{\"open\", nil, 1}}, 1}\n\t\t}\n\t\tif tev.Buttons() == tcell.Button1 {\n\t\t\treturn &callExpr{\"cd\", []string{dir.path}, 1}\n\t\t}\n\tcase *tcell.EventResize:\n\t\treturn &callExpr{\"redraw\", nil, 1}\n\tcase *tcell.EventError:\n\t\tlog.Printf(\"Got EventError: '%s' at %s\", tev.Error(), tev.When())\n\tcase *tcell.EventInterrupt:\n\t\tlog.Printf(\"Got EventInterrupt: at %s\", tev.When())\n\tcase *tcell.EventFocus:\n\t\tif tev.Focused {\n\t\t\treturn &callExpr{\"on-focus-gained\", nil, 1}\n\t\t} else {\n\t\t\treturn &callExpr{\"on-focus-lost\", nil, 1}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc readCmdEvent(ev tcell.Event) expr {\n\tswitch tev := ev.(type) {\n\tcase *tcell.EventKey:\n\t\tif tev.Key() == tcell.KeyRune {\n\t\t\tif tev.Modifiers() == tcell.ModMask(tcell.ModAlt) {\n\t\t\t\tval := string([]rune{'<', 'a', '-', tev.Rune(), '>'})\n\t\t\t\tif expr, ok := gOpts.cmdkeys[val]; ok {\n\t\t\t\t\treturn expr\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn &callExpr{\"cmd-insert\", []string{string(tev.Rune())}, 1}\n\t\t\t}\n\t\t} else {\n\t\t\tval := gKeyVal[tev.Key()]\n\t\t\tval = addSpecialKeyModifier(val, tev.Modifiers())\n\t\t\tif expr, ok := gOpts.cmdkeys[val]; ok {\n\t\t\t\treturn expr\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (ui *ui) readEvent(ev tcell.Event, nav *nav) expr {\n\tif ev == nil {\n\t\treturn nil\n\t}\n\n\tif _, ok := ev.(*tcell.EventKey); ok && ui.cmdPrefix != \"\" {\n\t\treturn readCmdEvent(ev)\n\t}\n\n\treturn ui.readNormalEvent(ev, nav)\n}\n\nfunc (ui *ui) readExpr() {\n\tgo func() {\n\t\tfor {\n\t\t\tui.evChan <- ui.pollEvent()\n\t\t}\n\t}()\n}\n\nfunc (ui *ui) suspend() error {\n\treturn ui.screen.Suspend()\n}\n\nfunc (ui *ui) resume() error {\n\terr := ui.screen.Resume()\n\tif !ui.polling {\n\t\tgo ui.pollEvents()\n\t\tui.polling = true\n\t}\n\treturn err\n}\n\nfunc (ui *ui) exportMode() {\n\tgetMode := func() string {\n\t\tif strings.HasPrefix(ui.cmdPrefix, \"delete\") {\n\t\t\treturn \"delete\"\n\t\t}\n\n\t\tif strings.HasPrefix(ui.cmdPrefix, \"replace\") || strings.HasPrefix(ui.cmdPrefix, \"create\") {\n\t\t\treturn \"rename\"\n\t\t}\n\n\t\tswitch ui.cmdPrefix {\n\t\tcase \"filter: \":\n\t\t\treturn \"filter\"\n\t\tcase \"find: \", \"find-back: \":\n\t\t\treturn \"find\"\n\t\tcase \"mark-save: \", \"mark-load: \", \"mark-remove: \":\n\t\t\treturn \"mark\"\n\t\tcase \"rename: \":\n\t\t\treturn \"rename\"\n\t\tcase \"/\", \"?\":\n\t\t\treturn \"search\"\n\t\tcase \":\":\n\t\t\treturn \"command\"\n\t\tcase \"$\", \"%\", \"!\", \"&\":\n\t\t\treturn \"shell\"\n\t\tcase \">\":\n\t\t\treturn \"pipe\"\n\t\tcase \"\":\n\t\t\treturn \"normal\"\n\t\tdefault:\n\t\t\treturn \"unknown\"\n\t\t}\n\t}\n\n\tos.Setenv(\"lf_mode\", getMode())\n}\n\nfunc (ui *ui) exportSizes() {\n\tw, h := ui.screen.Size()\n\tos.Setenv(\"lf_width\", strconv.Itoa(w))\n\tos.Setenv(\"lf_height\", strconv.Itoa(h))\n}\n\nfunc anyKey() {\n\tfmt.Fprint(os.Stderr, gOpts.waitmsg)\n\tdefer fmt.Fprint(os.Stderr, \"\\n\")\n\toldState, err := term.MakeRaw(int(os.Stdin.Fd()))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer term.Restore(int(os.Stdin.Fd()), oldState)\n\n\tb := make([]byte, 1)\n\tos.Stdin.Read(b)\n}\n\nfunc listMatches(screen tcell.Screen, matches []string, selectedInd int) *bytes.Buffer {\n\tmlen := len(matches)\n\tif mlen < 2 {\n\t\treturn nil\n\t}\n\tb := new(bytes.Buffer)\n\n\twtot, _ := screen.Size()\n\twcol := 0\n\tfor _, m := range matches {\n\t\twcol = max(wcol, len(m))\n\t}\n\twcol += gOpts.tabstop - wcol%gOpts.tabstop\n\tncol := max(wtot/wcol, 1)\n\n\tb.WriteString(\"possible matches\\n\")\n\n\tfor i := 0; i < mlen; {\n\t\tfor j := 0; j < ncol && i < mlen; i, j = i+1, j+1 {\n\t\t\ttarget := matches[i]\n\n\t\t\tif selectedInd == i {\n\t\t\t\tfmt.Fprintf(b, \"\\033[7m%s\\033[0m%*s\", target, wcol-len(target), \"\")\n\t\t\t} else {\n\t\t\t\tfmt.Fprintf(b, \"%s%*s\", target, wcol-len(target), \"\")\n\t\t\t}\n\t\t}\n\t\tb.WriteByte('\\n')\n\t}\n\n\treturn b\n}\n"
        },
        {
          "name": "watch.go",
          "type": "blob",
          "size": 2.6845703125,
          "content": "package main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n\n\t\"github.com/fsnotify/fsnotify\"\n)\n\ntype watch struct {\n\twatcher     *fsnotify.Watcher\n\tevents      <-chan fsnotify.Event\n\tquit        chan struct{}\n\tloads       map[string]bool\n\tloadTimer   *time.Timer\n\tupdates     map[string]bool\n\tupdateTimer *time.Timer\n\tdirChan     chan<- *dir\n\tfileChan    chan<- *file\n\tdelChan     chan<- string\n}\n\nfunc newWatch(dirChan chan<- *dir, fileChan chan<- *file, delChan chan<- string) *watch {\n\treturn &watch{\n\t\tquit:        make(chan struct{}),\n\t\tloads:       make(map[string]bool),\n\t\tloadTimer:   time.NewTimer(0),\n\t\tupdates:     make(map[string]bool),\n\t\tupdateTimer: time.NewTimer(0),\n\t\tdirChan:     dirChan,\n\t\tfileChan:    fileChan,\n\t\tdelChan:     delChan,\n\t}\n}\n\nfunc (watch *watch) start() {\n\tif watch.watcher != nil {\n\t\treturn\n\t}\n\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\tlog.Printf(\"start watcher: %s\", err)\n\t\treturn\n\t}\n\n\twatch.watcher = watcher\n\twatch.events = watcher.Events\n\n\tgo watch.loop()\n}\n\nfunc (watch *watch) stop() {\n\tif watch.watcher == nil {\n\t\treturn\n\t}\n\n\twatch.quit <- struct{}{}\n\twatch.watcher.Close()\n\n\twatch.watcher = nil\n\twatch.events = nil\n}\n\nfunc (watch *watch) set(paths map[string]bool) {\n\tif watch.watcher == nil {\n\t\treturn\n\t}\n\n\tfor _, path := range watch.watcher.WatchList() {\n\t\tif !paths[path] {\n\t\t\twatch.watcher.Remove(path)\n\t\t}\n\t}\n\n\tfor path := range paths {\n\t\twatch.watcher.Add(path)\n\t}\n}\n\nfunc (watch *watch) loop() {\n\tfor {\n\t\tselect {\n\t\tcase ev := <-watch.events:\n\t\t\tif ev.Has(fsnotify.Create) {\n\t\t\t\tdir := filepath.Dir(ev.Name)\n\t\t\t\twatch.addLoad(dir)\n\t\t\t\twatch.addUpdate(dir)\n\t\t\t}\n\n\t\t\tif ev.Has(fsnotify.Remove) || ev.Has(fsnotify.Rename) {\n\t\t\t\twatch.delChan <- ev.Name\n\t\t\t\tdir := filepath.Dir(ev.Name)\n\t\t\t\twatch.addLoad(dir)\n\t\t\t\twatch.addUpdate(dir)\n\t\t\t}\n\n\t\t\tif ev.Has(fsnotify.Write) || ev.Has(fsnotify.Chmod) {\n\t\t\t\twatch.addUpdate(ev.Name)\n\t\t\t}\n\t\tcase <-watch.loadTimer.C:\n\t\t\tfor path := range watch.loads {\n\t\t\t\tif _, err := os.Lstat(path); err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tdir := newDir(path)\n\t\t\t\tdir.sort()\n\t\t\t\twatch.dirChan <- dir\n\t\t\t}\n\t\t\twatch.loads = make(map[string]bool)\n\t\tcase <-watch.updateTimer.C:\n\t\t\tfor path := range watch.updates {\n\t\t\t\tif _, err := os.Lstat(path); err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\twatch.fileChan <- newFile(path)\n\t\t\t}\n\t\t\twatch.updates = make(map[string]bool)\n\t\tcase <-watch.quit:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (watch *watch) addLoad(path string) {\n\tif len(watch.loads) == 0 {\n\t\twatch.loadTimer.Stop()\n\t\twatch.loadTimer.Reset(10 * time.Millisecond)\n\t}\n\twatch.loads[path] = true\n}\n\nfunc (watch *watch) addUpdate(path string) {\n\tif len(watch.updates) == 0 {\n\t\twatch.updateTimer.Stop()\n\t\twatch.updateTimer.Reset(10 * time.Millisecond)\n\t}\n\twatch.updates[path] = true\n}\n"
        }
      ]
    }
  ]
}