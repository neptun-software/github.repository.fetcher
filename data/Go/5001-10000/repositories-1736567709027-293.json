{
  "metadata": {
    "timestamp": 1736567709027,
    "page": 293,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tealeg/xlsx",
      "stars": 5900,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.05859375,
          "content": ".vscode\n.idea\n.DS_Store\nxlsx.test\n*.swp\ncoverage.txt\n.idea\n\n"
        },
        {
          "name": "AUTHORS.txt",
          "type": "blob",
          "size": 1.9326171875,
          "content": "ACHER <artem.chernyak@monsanto.com>\nAndrew Schwartz <andrew.schwartz@gengo.com>\nArtem Chernyak <artemchernyak@Artems-MacBook-Air.local>\nArtem Chernyak <artemchernyak@gmail.com>\nblackss2 <blackss2@nate.com>\nBrandon Mulcahy <brandon@jangler.info>\nBrian Smith <ohohvi@gmail.com>\nbronze1man <bronze1man@gmail.com>\nBruno Bigras <bigras.bruno@gmail.com>\nChris Glass <tribaal@gmail.com>\nColin Fox <colin.fox@cumul8.com>\nColin Fox <greenenergy@gmail.com>\ncrahles <christoph@rahles.de>\nDaniel Upton <daniel@floppy.co>\nDaniel YC Lin <dlin@u40>\nDerLinkshaender <mail@arminhanisch.de>\nEric <ericscottlagergren@gmail.com>\nfrogs <frogs@frogss-MacBook-Air.local>\nfzerorubigd <fzerorubigd@gmail.com>\nGeoffrey J. Teale <geoffrey.teale@canonical.com>\nGyu-Ho Lee <gyuho.cs@gmail.com>\nHerman Schaaf <hermanschaaf@gmail.com>\nHugh Gao <email@klniu.com>\nIain Lowe <i.lowe@mademediacorp.com>\nivnivnch <ivnivnch@gmail.com>\nJason Hall <imjasonh@gmail.com>\nJoshua Baker <joshua.baker@cumul8.com>\nKaur Kuut <strom@nevermore.ee>\nLunny Xiao <xiaolunwen@gmail.com>\nmagician1 <kouta-k@mbm.nifty.com>\nMathias Fredriksson <mafredri@gmail.com>\nMatt Aimonetti <mattaimonetti@gmail.com>\nMoch. Lutfi <kapten_lufi@yahoo.co.id>\nMoch.Lutfi <kapten_lufi@yahoo.co.id>\nNeoin <Heinoldewage@gmail.com>\nNguyen Nguyen <ntn@NTN.local>\nNikita Danilov <mirt@mirt.su>\nOneOfOne <OneOfOne@gmail.com>\nPeter Waller <p@pwaller.net>\nPhilipp Klose <TheHippo@users.noreply.github.com>\nrichard bucker <richard@bucker.net>\nShawn Milochik <shawn@milochik.com>\nShawn Smith <shawnpsmith@gmail.com>\nShawn Smith <shawn.smith@gengo.com>\nSHIMADA Koji <koji.shimada@enishi-tech.com>\nSteven Degutis <steven.degutis@gmail.com>\ntakuya sato <sato-taku@klab.com>\nThieu Pham <thieu.pham@workiva.com>\nTormod Erevik Lea <tormodlea@gmail.com>\ntrinchan <andrew.schwartz@gengo.com>\nU-NORTH_AMERICA\\ACHER <ACHER@PBECRLK.na.ds.monsanto.com>\nYAMADA Tsuyoshi <tyamada@minimum2scp.org>\nYoshiki Shibukawa <shibukawa.yoshiki@dena.jp>\nzhcy <zhangchenyu2009@gmail.com>\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.1376953125,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment include:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at tealeg@gmail.com. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [http://contributor-covenant.org/version/1/4][version]\n\n[homepage]: http://contributor-covenant.org\n[version]: http://contributor-covenant.org/version/1/4/\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.923828125,
          "content": "BSD 3-Clause License\n\nCopyright (c) 2011-2020, Geoffrey J. Teale\nCopyright (c) 2014 Paul Smith\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of the copyright holder nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n----\n\nAs of 14th May 2020, the ColIndexToLetters function in lib.go has been\nrewritten using code from the following repository\nhttps://github.com/psmithuk/xlsx.  This code was licensed under the\nMIT license and doesn't confer any additional restraints on users of\nthis library, other than the addition of Paul Smiths copyright\nstatement in our own, which you must reproduce in accordance with the\nterms above.\n\n----"
        },
        {
          "name": "README.org",
          "type": "blob",
          "size": 4.3095703125,
          "content": "* XLSX\n\n[[https://github.com/tealeg/xlsx/actions/workflows/go.yml][https://github.com/tealeg/xlsx/actions/workflows/go.yml/badge.svg?branch=master]]\n[[https://codecov.io/gh/tealeg/xlsx][https://codecov.io/gh/tealeg/xlsx/branch/master/graph/badge.svg]]\n[[https://pkg.go.dev/github.com/tealeg/xlsx/v3][https://pkg.go.dev/badge/github.com/tealeg/xlsx/v3.svg]]\n[[https://github.com/tealeg/xlsx#license][https://img.shields.io/badge/license-bsd-orange.svg]]\n\n** Introduction\nxlsx is a library to simplify reading and writing the XML format, used\nby versions of Microsoft Excel since 2002, in Go programs.\n\n* Current status\nWe're back! The will of the people has spoken.  [[https://github.com/tealeg][I]] tried to slowly let\nthis die, but the patches keep coming in, and people keep expressing\nfrustration at the alternatives.  So, the fate of this library\nlies with you all. [[https://github.com/tealeg][I]] will review patches, make releases, etc.  [[https://github.com/tealeg][I]]\ndon't plan to take on any new development work here myself, but I will\nattempt to support you if you do.\n\n** Tutorial\n\nIf you'd like an introduction to this project try the [[https://github.com/tealeg/xlsx/blob/master/tutorial/tutorial.adoc][tutorial]].\n\n** Different versions of this project\n\n*** Prior to v1.0.0\n\nYou don't want these versions ;-)\n\nIt's hard to remember exactly, but work on this library started within\na month of the first public announcement of Go, now more than a decade\nago.  It was essentially a quick hack to get data out of XLSX files at\nmy workplace.  Nobody but me relied on it, so it was fine to use this\nbrand new language for this task. Somewhat later I decided to share\nthe code, and I know it was well established as an open-source project\nby the time I left that job in late 2011.\n\nAlthough I did do some \"release\" tags, versioning in Go in the early\ndays relied on tagging your code with the name of the Go release\n(i.e. go1.2) and then `go get` would fetch that tag, if it existed,\nand if not, it'd grab the master branch.\n\n*** Version 1.x.x\n\nVersion 1.0.0 was tagged in 2017 to support vendoring tools.\n\nAs of October 8th, 2019, I've branched off v1.x.x maintenance work\nfrom master.  The master branch now tracks v2.x.x.\n\nIf you have existing code, can live with the issues in the 1.x.x\ncodebase, and don't want to update your code to use a later version,\nthen you can stick to these releases.  I mostly won't be touching this\ncode, but if something really important comes up, let me know.\n\n*** Version 2.x.x\n\nVersion 2.0.0 introduced breaking changes in the API.\n\nThe scope of these changes included the way `Col` elements and\n`DataValidation` works, as these aspects have been built around\nincorrect models of the underlying XLSX format.\n\nSee the [[milestone][https://github.com/tealeg/xlsx/milestone/5]] for details.\n\nVersion 2.0.1 was tagged purely because 2.0.0 wasn't handled correctly\nwith regards to how go modules work. It isn't possible to use 2.0.0\nfrom a Go Modules based project.\n\n*** Version 3.x.x \nVersion 3.0.0 introduces some more breaking changes in the API.  All\nmethods that can return an `xlsx.File` struct now accept zero, one or\nmany `xlsx.FileOption` functions as their final arguments.  These can\nbe used to modify the behaviour of the resultant struct - in\nparticular they replace the `...WithRowLimit` variants of those\nmethods with the result of calling `xlsx.RowLimit` and they add the\nability to define a custom backing store for the spreadsheet data to\nbe held in whilst processing.\n\nStreamFileBuilder has been dropped from this version of the library as it has become difficult to maintain. \n\n** Full API docs\nThe full API docs can be viewed using go's built in documentation\ntool, or online at [[https://pkg.go.dev/github.com/tealeg/xlsx/v3][pkg.go.dev]].\n\n** Contributing\n\n Please be patient, maintaining XLSX doesn't pay anyone's salary (to my knowledge).\n\nIf you'd like to propose a change please ensure the following:\n\n- All existing tests are passing.\n- There are tests in the test suite that cover the changes you're making.\n- You have added documentation strings (in English) to (at least) the public functions you've added or modified.\n- Your use of, or creation of, XML is compliant with [[http://www.ecma-international.org/publications/standards/Ecma-376.htm][part 1 of the 4th edition of the ECMA-376 Standard for Office Open XML]].\n\nEat a peach - Geoff\n"
        },
        {
          "name": "cell.go",
          "type": "blob",
          "size": 15.671875,
          "content": "package xlsx\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst (\n\tmaxNonScientificNumber = 1e11\n\tminNonScientificNumber = 1e-9\n)\n\n// CellType is an int type for storing metadata about the data type in the cell.\ntype CellType int\n\n// These are the cell types from the ST_CellType spec\nconst (\n\tCellTypeString CellType = iota\n\t// CellTypeStringFormula is a specific format for formulas that return string values. Formulas that return numbers\n\t// and booleans are stored as those types.\n\tCellTypeStringFormula\n\tCellTypeNumeric\n\tCellTypeBool\n\t// CellTypeInline is not respected on save, all inline string cells will be saved as SharedStrings\n\t// when saving to an XLSX file. This the same behavior as that found in Excel.\n\tCellTypeInline\n\tCellTypeError\n\t// d (Date): Cell contains a date in the ISO 8601 format.\n\t// That is the only mention of this format in the XLSX spec.\n\t// Date seems to be unused by the current version of Excel, it stores dates as Numeric cells with a date format string.\n\t// For now these cells will have their value output directly. It is unclear if the value is supposed to be parsed\n\t// into a number and then formatted using the formatting or not.\n\tCellTypeDate\n)\n\nfunc (ct CellType) Ptr() *CellType {\n\treturn &ct\n}\n\nfunc (ct *CellType) fallbackTo(cellData string, fallback CellType) CellType {\n\tif ct != nil {\n\t\tswitch *ct {\n\t\tcase CellTypeNumeric:\n\t\t\tif _, err := strconv.ParseFloat(cellData, 64); err == nil {\n\t\t\t\treturn *ct\n\t\t\t}\n\t\tdefault:\n\t\t}\n\t}\n\treturn fallback\n}\n\n// Cell is a high level structure intended to provide user access to\n// the contents of Cell within an xlsx.Row.\ntype Cell struct {\n\tRow            *Row\n\tValue          string\n\tRichText       []RichTextRun\n\tformula        string\n\tstyle          *Style\n\tNumFmt         string\n\tparsedNumFmt   *parsedNumberFormat\n\tdate1904       bool\n\tHidden         bool\n\tHMerge         int\n\tVMerge         int\n\tcellType       CellType\n\tDataValidation *xlsxDataValidation\n\tHyperlink      Hyperlink\n\tnum            int\n\tmodified       bool\n\torigValue      string\n\torigNumFmt     string\n\torigRichText   []RichTextRun\n}\n\n// Return a representation of the Cell as a slice of bytes\nfunc (c Cell) MarshalBinary() ([]byte, error) {\n\n\t// bs uses base64 to avoid directly encoding newlines and other bad values\n\tbs := func(s string) string {\n\t\treturn base64.StdEncoding.EncodeToString([]byte(s))\n\t}\n\n\tvar b bytes.Buffer\n\t// We can omit the Row pointer, because we know this information when we unmarshal.\n\t// We can omit the parsedNumFmt because this is created on demand anyway.\n\t// We can omit the DataValidation because we store this separately with a derived key\n\t// We can omit the Style because we store this separately with a derived key\n\t//\n\t// String values all contain fixed prefixes to avoid issues with empty strings.\n\tfmt.Fprintln(&b, bs(\"V\"+c.Value), bs(\"F\"+c.formula), bs(\"N\"+c.NumFmt), c.date1904, c.Hidden, c.HMerge, c.VMerge, c.cellType, bs(\"HDS\"+c.Hyperlink.DisplayString), bs(\"HL\"+c.Hyperlink.Link), bs(\"HTT\"+c.Hyperlink.Tooltip), c.num)\n\treturn b.Bytes(), nil\n}\n\n// Read a slice of bytes, produced by MarshalBinary, into a Cell\nfunc (c *Cell) UnmarshalBinary(data []byte) error {\n\tubs := func(s string) string {\n\t\tdecoded, err := base64.StdEncoding.DecodeString(s)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\treturn string(decoded)\n\t}\n\n\tb := bytes.NewBuffer(data)\n\n\tvar value, formula, numfmt, hds, hl, htt string\n\t_, err := fmt.Fscanln(b, &value, &formula, &numfmt, &c.date1904, &c.Hidden, &c.HMerge, &c.VMerge, &c.cellType, &hds, &hl, &htt, &c.num)\n\tc.Value = strings.TrimPrefix(ubs(value), \"V\")\n\tc.formula = strings.TrimPrefix(ubs(formula), \"F\")\n\tc.NumFmt = strings.TrimPrefix(ubs(numfmt), \"N\")\n\tc.Hyperlink.DisplayString = strings.TrimPrefix(ubs(hds), \"HDS\")\n\tc.Hyperlink.Link = strings.TrimPrefix(ubs(hl), \"HL\")\n\tc.Hyperlink.Tooltip = strings.TrimPrefix(ubs(htt), \"HTT\")\n\treturn err\n}\n\n// Modified returns True if a cell has been modified since it was last persisted.\nfunc (c *Cell) Modified() bool {\n\tif c == nil {\n\t\treturn false\n\t}\n\trtEq := func(a, b []RichTextRun) bool {\n\t\tif len(a) != len(b) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := 0; i < len(a); i++ {\n\t\t\tif a[i] != b[i] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\n\treturn c.modified || c.Value != c.origValue || c.NumFmt != c.origNumFmt || !rtEq(c.RichText, c.origRichText)\n}\n\n// Return a string repersenting a Cell in a way that can be used by the CellStore\nfunc (c *Cell) key() string {\n\treturn fmt.Sprintf(\"%s:%06d:%06d\", c.Row.Sheet.Name, c.Row.num, c.num)\n}\n\n// Hyperlink is a structure to store link information\n// in-workbook links to cells or defined names are stored in Location\n// external links are stores in Link\ntype Hyperlink struct {\n\tDisplayString string\n\tLink          string\n\tTooltip       string\n\tLocation      string\n}\n\n// CellInterface defines the public API of the Cell.\ntype CellInterface interface {\n\tString() string\n\tFormattedValue() string\n}\n\n// NewCell creates a cell with a reference to its parent Row.  In most\n// cases you shouldn't call this, but rather call Row.AddCell.\nfunc newCell(r *Row, num int) *Cell {\n\tcell := &Cell{Row: r, num: num}\n\treturn cell\n}\n\nfunc (c *Cell) updatable() {\n\tif c.Row != nil && c.Row.cellStoreRow != nil {\n\t\tc.Row.cellStoreRow.CellUpdatable(c)\n\t}\n\n}\n\n// Merge with other cells, horizontally and/or vertically.\nfunc (c *Cell) Merge(hcells, vcells int) {\n\tc.updatable()\n\tc.HMerge = hcells\n\tc.VMerge = vcells\n\tc.modified = true\n}\n\n// Type returns the CellType of a cell. See CellType constants for more details.\nfunc (c *Cell) Type() CellType {\n\treturn c.cellType\n}\n\n// SetString sets the value of a cell to a string.\nfunc (c *Cell) SetString(s string) {\n\tc.updatable()\n\tc.Value = s\n\tc.RichText = nil\n\tc.formula = \"\"\n\tc.cellType = CellTypeString\n\tc.modified = true\n}\n\n// SetRichText sets the value of a cell to a set of the rich text.\nfunc (c *Cell) SetRichText(r []RichTextRun) {\n\tc.updatable()\n\tc.Value = \"\"\n\tc.RichText = append([]RichTextRun(nil), r...)\n\tc.formula = \"\"\n\tc.cellType = CellTypeString\n\tc.modified = true\n}\n\n// String returns the value of a Cell as a string.  If you'd like to\n// see errors returned from formatting then please use\n// Cell.FormattedValue() instead.\nfunc (c *Cell) String() string {\n\t// To preserve the String() interface we'll throw away errors.\n\t// Note that using FormattedValue is therefore strongly\n\t// preferred.\n\tvalue, _ := c.FormattedValue()\n\treturn value\n}\n\n// SetFloat sets the value of a cell to a float.\nfunc (c *Cell) SetFloat(n float64) {\n\tc.updatable()\n\tc.SetValue(n)\n}\n\n// IsTime returns true if the cell stores a time value.\nfunc (c *Cell) IsTime() bool {\n\tc.getNumberFormat()\n\treturn c.parsedNumFmt.isTimeFormat\n}\n\n// GetTime returns the value of a Cell as a time.Time\nfunc (c *Cell) GetTime(date1904 bool) (t time.Time, err error) {\n\tf, err := c.Float()\n\tif err != nil {\n\t\treturn t, err\n\t}\n\treturn TimeFromExcelTime(f, date1904), nil\n}\n\n/*\n\tThe following are samples of format samples.\n\n\t* \"0.00e+00\"\n\t* \"0\", \"#,##0\"\n\t* \"0.00\", \"#,##0.00\", \"@\"\n\t* \"#,##0 ;(#,##0)\", \"#,##0 ;[red](#,##0)\"\n\t* \"#,##0.00;(#,##0.00)\", \"#,##0.00;[red](#,##0.00)\"\n\t* \"0%\", \"0.00%\"\n\t* \"0.00e+00\", \"##0.0e+0\"\n*/\n\n// SetFloatWithFormat sets the value of a cell to a float and applies\n// formatting to the cell.\nfunc (c *Cell) SetFloatWithFormat(n float64, format string) {\n\tc.updatable()\n\tc.SetValue(n)\n\tc.NumFmt = format\n\tc.formula = \"\"\n}\n\n// SetCellFormat set cell value  format\nfunc (c *Cell) SetFormat(format string) {\n\tc.updatable()\n\tc.NumFmt = format\n\tc.modified = true\n}\n\n// DateTimeOptions are additional options for exporting times\ntype DateTimeOptions struct {\n\t// Location allows calculating times in other timezones/locations\n\tLocation *time.Location\n\t// ExcelTimeFormat is the string you want excel to use to format the datetime\n\tExcelTimeFormat string\n}\n\nvar (\n\tDefaultDateFormat     = builtInNumFmt[14]\n\tDefaultDateTimeFormat = builtInNumFmt[22]\n\n\tDefaultDateOptions = DateTimeOptions{\n\t\tLocation:        timeLocationUTC,\n\t\tExcelTimeFormat: DefaultDateFormat,\n\t}\n\n\tDefaultDateTimeOptions = DateTimeOptions{\n\t\tLocation:        timeLocationUTC,\n\t\tExcelTimeFormat: DefaultDateTimeFormat,\n\t}\n)\n\n// SetDate sets the value of a cell to a float.\nfunc (c *Cell) SetDate(t time.Time) {\n\tc.updatable()\n\tc.SetDateWithOptions(t, DefaultDateOptions)\n}\n\nfunc (c *Cell) SetDateTime(t time.Time) {\n\tc.updatable()\n\tc.SetDateWithOptions(t, DefaultDateTimeOptions)\n}\n\n// SetDateWithOptions allows for more granular control when exporting dates and times\nfunc (c *Cell) SetDateWithOptions(t time.Time, options DateTimeOptions) {\n\tc.updatable()\n\t_, offset := t.In(options.Location).Zone()\n\tt = time.Unix(t.Unix()+int64(offset), int64(t.Nanosecond()))\n\tc.SetDateTimeWithFormat(TimeToExcelTime(t.In(timeLocationUTC), c.date1904), options.ExcelTimeFormat)\n\tc.modified = true\n}\n\nfunc (c *Cell) SetDateTimeWithFormat(n float64, format string) {\n\tc.updatable()\n\tc.Value = strconv.FormatFloat(n, 'f', -1, 64)\n\tc.NumFmt = format\n\tc.formula = \"\"\n\tc.cellType = CellTypeNumeric\n\tc.modified = true\n}\n\n// Float returns the value of cell as a number.\nfunc (c *Cell) Float() (float64, error) {\n\tf, err := strconv.ParseFloat(c.Value, 64)\n\tif err != nil {\n\t\treturn math.NaN(), err\n\t}\n\treturn f, nil\n}\n\n// SetInt64 sets a cell's value to a 64-bit integer.\nfunc (c *Cell) SetInt64(n int64) {\n\tc.updatable()\n\tc.SetValue(n)\n}\n\n// Int64 returns the value of cell as 64-bit integer.\nfunc (c *Cell) Int64() (int64, error) {\n\tf, err := strconv.ParseInt(c.Value, 10, 64)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\treturn f, nil\n}\n\n// GeneralNumeric returns the value of the cell as a string. It is formatted very closely to the the XLSX spec for how\n// to display values when the storage type is Number and the format type is General. It is not 100% identical to the\n// spec but is as close as you can get using the built in Go formatting tools.\nfunc (c *Cell) GeneralNumeric() (string, error) {\n\treturn generalNumericScientific(c.Value, true)\n}\n\n// GeneralNumericWithoutScientific returns numbers that are always formatted as numbers, but it does not follow\n// the rules for when XLSX should switch to scientific notation, since sometimes scientific notation is not desired,\n// even if that is how the document is supposed to be formatted.\nfunc (c *Cell) GeneralNumericWithoutScientific() (string, error) {\n\treturn generalNumericScientific(c.Value, false)\n}\n\n// SetInt sets a cell's value to an integer.\nfunc (c *Cell) SetInt(n int) {\n\tc.updatable()\n\tc.SetValue(n)\n}\n\n// SetHyperlink sets this cell to contain the given hyperlink, displayText and tooltip.\n// If the displayText or tooltip are an empty string, they will not be set.\n// The hyperlink provided must be a valid URL starting with http:// or https:// or\n// excel will not recognize it as an external link. All other hyperlink formats will be\n// treated as internal link between sheets. Official format in form of `#Sheet!A123`.\n// Maximum number of hyperlinks per sheet is 65530, according to specification.\nfunc (c *Cell) SetHyperlink(hyperlink string, displayText string, tooltip string) {\n\tc.updatable()\n\th := strings.ToLower(hyperlink)\n\tif strings.HasPrefix(h, \"http:\") || strings.HasPrefix(h, \"https://\") {\n\t\tc.Hyperlink = Hyperlink{Link: hyperlink}\n\t} else {\n\t\tc.Hyperlink = Hyperlink{Link: hyperlink, Location: hyperlink}\n\t}\n\tc.SetString(hyperlink)\n\tc.Row.Sheet.addRelation(RelationshipTypeHyperlink, hyperlink, RelationshipTargetModeExternal)\n\tif displayText != \"\" {\n\t\tc.Hyperlink.DisplayString = displayText\n\t\tc.SetString(displayText)\n\t}\n\tif tooltip != \"\" {\n\t\tc.Hyperlink.Tooltip = tooltip\n\t}\n}\n\n// SetValue sets a cell's value to any type.\nfunc (c *Cell) SetValue(n interface{}) {\n\tc.updatable()\n\tswitch t := n.(type) {\n\tcase time.Time:\n\t\tc.SetDateTime(t)\n\tcase int, int8, int16, int32, int64:\n\t\tc.SetNumeric(fmt.Sprintf(\"%d\", n))\n\tcase float64:\n\t\t// When formatting floats, do not use fmt.Sprintf(\"%v\", n), this will cause numbers below 1e-4 to be printed in\n\t\t// scientific notation. Scientific notation is not a valid way to store numbers in XML.\n\t\t// Also not not use fmt.Sprintf(\"%f\", n), this will cause numbers to be stored as X.XXXXXX. Which means that\n\t\t// numbers will lose precision and numbers with fewer significant digits such as 0 will be stored as 0.000000\n\t\t// which causes tests to fail.\n\t\tc.SetNumeric(strconv.FormatFloat(t, 'f', -1, 64))\n\tcase float32:\n\t\tc.SetNumeric(strconv.FormatFloat(float64(t), 'f', -1, 32))\n\tcase string:\n\t\tc.SetString(t)\n\tcase []byte:\n\t\tc.SetString(string(t))\n\tcase bool:\n\t\tc.SetBool(t)\n\tcase nil:\n\t\tc.SetString(\"\")\n\tdefault:\n\t\tc.SetString(fmt.Sprintf(\"%v\", n))\n\t}\n}\n\n// SetNumeric sets a cell's value to a number\nfunc (c *Cell) SetNumeric(s string) {\n\tc.updatable()\n\tc.Value = s\n\tc.NumFmt = builtInNumFmt[builtInNumFmtIndex_GENERAL]\n\tc.formula = \"\"\n\tc.cellType = CellTypeNumeric\n\tc.modified = true\n}\n\n// Int returns the value of cell as integer.\n// Has max 53 bits of precision\n// See: float64(int64(math.MaxInt))\nfunc (c *Cell) Int() (int, error) {\n\tf, err := strconv.ParseFloat(c.Value, 64)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\treturn int(f), nil\n}\n\n// SetBool sets a cell's value to a boolean.\nfunc (c *Cell) SetBool(b bool) {\n\tc.updatable()\n\tif b {\n\t\tc.Value = \"1\"\n\t} else {\n\t\tc.Value = \"0\"\n\t}\n\tc.cellType = CellTypeBool\n\tc.modified = true\n}\n\n// Bool returns a boolean from a cell's value.\n// TODO: Determine if the current return value is\n// appropriate for types other than CellTypeBool.\nfunc (c *Cell) Bool() bool {\n\t// If bool, just return the value.\n\tif c.cellType == CellTypeBool {\n\t\treturn c.Value == \"1\"\n\t}\n\t// If numeric, base it on a non-zero.\n\tif c.cellType == CellTypeNumeric {\n\t\treturn c.Value != \"0\"\n\t}\n\t// Return whether there's an empty string.\n\treturn c.Value != \"\"\n}\n\n// SetFormula sets the format string for a cell.\nfunc (c *Cell) SetFormula(formula string) {\n\tc.updatable()\n\tc.formula = formula\n\tc.cellType = CellTypeNumeric\n\tc.modified = true\n}\n\nfunc (c *Cell) SetStringFormula(formula string) {\n\tc.updatable()\n\tc.formula = formula\n\tc.cellType = CellTypeStringFormula\n\tc.modified = true\n}\n\n// Formula returns the formula string for the cell.\nfunc (c *Cell) Formula() string {\n\treturn c.formula\n}\n\n// GetStyle returns the Style associated with a Cell\nfunc (c *Cell) GetStyle() *Style {\n\tif c.style == nil {\n\t\tc.style = NewStyle()\n\t}\n\treturn c.style\n}\n\n// SetStyle sets the style of a cell.\nfunc (c *Cell) SetStyle(style *Style) {\n\tc.updatable()\n\tc.style = style\n\tc.modified = true\n}\n\n// GetNumberFormat returns the number format string for a cell.\nfunc (c *Cell) GetNumberFormat() string {\n\treturn c.NumFmt\n}\n\n// getNumberFormat will update the parsedNumFmt struct if it has become out of date, since a cell's NumFmt string is a\n// public field that could be edited by clients.\nfunc (c *Cell) getNumberFormat() *parsedNumberFormat {\n\tif c.parsedNumFmt == nil || c.parsedNumFmt.numFmt != c.NumFmt {\n\t\tc.parsedNumFmt = parseFullNumberFormatString(c.NumFmt)\n\t}\n\treturn c.parsedNumFmt\n}\n\n// FormattedValue returns a value, and possibly an error condition\n// from a Cell.  If it is possible to apply a format to the cell\n// value, it will do so, if not then an error will be returned, along\n// with the raw value of the Cell.\nfunc (c *Cell) FormattedValue() (string, error) {\n\tfullFormat := c.getNumberFormat()\n\treturnVal, err := fullFormat.FormatValue(c)\n\tif fullFormat.parseEncounteredError != nil {\n\t\treturn returnVal, *fullFormat.parseEncounteredError\n\t}\n\treturn returnVal, err\n}\n\n// SetDataValidation set data validation\nfunc (c *Cell) SetDataValidation(dd *xlsxDataValidation) {\n\tc.updatable()\n\tc.DataValidation = dd\n\tc.modified = true\n}\n\n// GetCoordinates returns a pair of integers representing the\n// cartesian coorindates of the Cell within the Sheet.  The\n// coordinates are zero based and a returned in order x,y where x is\n// the Column number and y is the Row number.  If you need to convert\n// these numbers to a Excel cellID (i.e. B15) then please see the\n// GetCellIDStringFromCoords function.\nfunc (c *Cell) GetCoordinates() (int, int) {\n\treturn c.num, c.Row.num\n}\n"
        },
        {
          "name": "cell_test.go",
          "type": "blob",
          "size": 28.9833984375,
          "content": "package xlsx\n\nimport (\n\t\"math\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\nfunc TestCell(t *testing.T) {\n\tc := qt.New(t)\n\n\t// Initially a cell is unmodified\n\tc.Run(\"TestUnmodified\", func(c *qt.C) {\n\t\tcell := &Cell{}\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t})\n\n\t// Test that we can set and get a Value from a Cell\n\tc.Run(\"TestValueSet\", func(c *qt.C) {\n\t\t// Note, this test is fairly pointless, it serves mostly to\n\t\t// reinforce that this functionality is important, and should\n\t\t// the mechanics of this all change at some point, to remind\n\t\t// us not to lose this.\n\t\tcell := Cell{}\n\t\tcell.Value = \"A string\"\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t})\n\n\t// Test that GetStyle correctly converts the xlsxStyle.Fonts.\n\tc.Run(\"TestGetStyleWithFonts\", func(c *qt.C) {\n\t\tfont := NewFont(10, \"Calibra\")\n\t\tstyle := NewStyle()\n\t\tstyle.Font = *font\n\n\t\tcell := &Cell{Value: \"123\", style: style, origValue: \"123\"}\n\t\tstyle = cell.GetStyle()\n\t\tc.Assert(style, qt.Not(qt.IsNil))\n\t\tc.Assert(style.Font.Size, qt.Equals, 10.0)\n\t\tc.Assert(style.Font.Name, qt.Equals, \"Calibra\")\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t})\n\n\t// Test that SetStyle correctly translates into a xlsxFont element\n\tcsRunO(c, \"TestSetStyleWithFonts\", func(c *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Test\")\n\t\trow := sheet.AddRow()\n\t\tcell := row.AddCell()\n\t\tfont := NewFont(12, \"Calibra\")\n\t\tstyle := NewStyle()\n\t\tstyle.Font = *font\n\t\tcell.SetStyle(style)\n\t\tstyle = cell.GetStyle()\n\t\txFont, _, _, _ := style.makeXLSXStyleElements()\n\t\tc.Assert(xFont.Sz.Val, qt.Equals, \"12\")\n\t\tc.Assert(xFont.Name.Val, qt.Equals, \"Calibra\")\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t})\n\n\t// Test that GetStyle correctly converts the xlsxStyle.Fills.\n\tc.Run(\"TestGetStyleWithFills\", func(c *qt.C) {\n\t\tfill := *NewFill(\"solid\", \"FF000000\", \"00FF0000\")\n\t\tstyle := NewStyle()\n\t\tstyle.Fill = fill\n\t\tcell := &Cell{Value: \"123\", style: style, origValue: \"123\"}\n\t\tstyle = cell.GetStyle()\n\t\t_, xFill, _, _ := style.makeXLSXStyleElements()\n\t\tc.Assert(xFill.PatternFill.PatternType, qt.Equals, \"solid\")\n\t\tc.Assert(xFill.PatternFill.BgColor.RGB, qt.Equals, \"00FF0000\")\n\t\tc.Assert(xFill.PatternFill.FgColor.RGB, qt.Equals, \"FF000000\")\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t})\n\n\t// Test that SetStyle correctly updates xlsxStyle.Fills.\n\tcsRunO(c, \"TestSetStyleWithFills\", func(c *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Test\")\n\t\trow := sheet.AddRow()\n\t\tcell := row.AddCell()\n\t\tfill := NewFill(\"solid\", \"00FF0000\", \"FF000000\")\n\t\tstyle := NewStyle()\n\t\tstyle.Fill = *fill\n\t\tcell.SetStyle(style)\n\t\tstyle = cell.GetStyle()\n\t\t_, xFill, _, _ := style.makeXLSXStyleElements()\n\t\txPatternFill := xFill.PatternFill\n\t\tc.Assert(xPatternFill.PatternType, qt.Equals, \"solid\")\n\t\tc.Assert(xPatternFill.FgColor.RGB, qt.Equals, \"00FF0000\")\n\t\tc.Assert(xPatternFill.BgColor.RGB, qt.Equals, \"FF000000\")\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t})\n\n\t// Test that GetStyle correctly converts the xlsxStyle.Borders.\n\tc.Run(\"TestGetStyleWithBorders\", func(c *qt.C) {\n\t\tborder := *NewBorder(\"thin\", \"thin\", \"thin\", \"thin\")\n\t\tstyle := NewStyle()\n\t\tstyle.Border = border\n\t\tcell := Cell{Value: \"123\", style: style, origValue: \"123\"}\n\t\tstyle = cell.GetStyle()\n\t\t_, _, xBorder, _ := style.makeXLSXStyleElements()\n\t\tc.Assert(xBorder.Left.Style, qt.Equals, \"thin\")\n\t\tc.Assert(xBorder.Right.Style, qt.Equals, \"thin\")\n\t\tc.Assert(xBorder.Top.Style, qt.Equals, \"thin\")\n\t\tc.Assert(xBorder.Bottom.Style, qt.Equals, \"thin\")\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t})\n\n\t// We can return a string representation of the formatted data\n\tc.Run(\"TestSetFloatWithFormat\", func(c *qt.C) {\n\t\tcell := Cell{}\n\t\tcell.SetFloatWithFormat(37947.75334343, \"yyyy/mm/dd\")\n\t\tc.Assert(cell.Value, qt.Equals, \"37947.75334343\")\n\t\tc.Assert(cell.NumFmt, qt.Equals, \"yyyy/mm/dd\")\n\t\tc.Assert(cell.Type(), qt.Equals, CellTypeNumeric)\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t})\n\n\tc.Run(\"TestSetFloat\", func(c *qt.C) {\n\t\tcell := Cell{}\n\t\tcell.SetFloat(0)\n\t\tc.Assert(cell.Value, qt.Equals, \"0\")\n\t\tcell.SetFloat(0.000005)\n\t\tc.Assert(cell.Value, qt.Equals, \"0.000005\")\n\t\tcell.SetFloat(100.0)\n\t\tc.Assert(cell.Value, qt.Equals, \"100\")\n\t\tcell.SetFloat(37947.75334343)\n\t\tc.Assert(cell.Value, qt.Equals, \"37947.75334343\")\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t})\n\n\tc.Run(\"TestGeneralNumberHandling\", func(c *qt.C) {\n\t\t// If you go to Excel, make a new file, type 18.99 in a cell, and save, what you will get is a\n\t\t// cell where the format is General and the storage type is Number, that contains the value 18.989999999999998.\n\t\t// The correct way to format this should be 18.99.\n\t\t// 1.1 will get you the same, with a stored value of 1.1000000000000001.\n\t\t// Also, numbers greater than 1e11 and less than 1e-9 wil be shown as scientific notation.\n\t\ttestCases := []struct {\n\t\t\tvalue                   string\n\t\t\tformattedValueOutput    string\n\t\t\tnoScientificValueOutput string\n\t\t}{\n\t\t\t{\n\t\t\t\tvalue:                   \"18.989999999999998\",\n\t\t\t\tformattedValueOutput:    \"18.99\",\n\t\t\t\tnoScientificValueOutput: \"18.99\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tvalue:                   \"1.1000000000000001\",\n\t\t\t\tformattedValueOutput:    \"1.1\",\n\t\t\t\tnoScientificValueOutput: \"1.1\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tvalue:                   \"0.0000000000000001\",\n\t\t\t\tformattedValueOutput:    \"1E-16\",\n\t\t\t\tnoScientificValueOutput: \"0.0000000000000001\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tvalue:                   \"0.000000000000008\",\n\t\t\t\tformattedValueOutput:    \"8E-15\",\n\t\t\t\tnoScientificValueOutput: \"0.000000000000008\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tvalue:                   \"1000000000000000000\",\n\t\t\t\tformattedValueOutput:    \"1E+18\",\n\t\t\t\tnoScientificValueOutput: \"1000000000000000000\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tvalue:                   \"1230000000000000000\",\n\t\t\t\tformattedValueOutput:    \"1.23E+18\",\n\t\t\t\tnoScientificValueOutput: \"1230000000000000000\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tvalue:                   \"12345678\",\n\t\t\t\tformattedValueOutput:    \"12345678\",\n\t\t\t\tnoScientificValueOutput: \"12345678\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tvalue:                   \"0\",\n\t\t\t\tformattedValueOutput:    \"0\",\n\t\t\t\tnoScientificValueOutput: \"0\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tvalue:                   \"-18.989999999999998\",\n\t\t\t\tformattedValueOutput:    \"-18.99\",\n\t\t\t\tnoScientificValueOutput: \"-18.99\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tvalue:                   \"-1.1000000000000001\",\n\t\t\t\tformattedValueOutput:    \"-1.1\",\n\t\t\t\tnoScientificValueOutput: \"-1.1\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tvalue:                   \"-0.0000000000000001\",\n\t\t\t\tformattedValueOutput:    \"-1E-16\",\n\t\t\t\tnoScientificValueOutput: \"-0.0000000000000001\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tvalue:                   \"-0.000000000000008\",\n\t\t\t\tformattedValueOutput:    \"-8E-15\",\n\t\t\t\tnoScientificValueOutput: \"-0.000000000000008\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tvalue:                   \"-1000000000000000000\",\n\t\t\t\tformattedValueOutput:    \"-1E+18\",\n\t\t\t\tnoScientificValueOutput: \"-1000000000000000000\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tvalue:                   \"-1230000000000000000\",\n\t\t\t\tformattedValueOutput:    \"-1.23E+18\",\n\t\t\t\tnoScientificValueOutput: \"-1230000000000000000\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tvalue:                   \"-12345678\",\n\t\t\t\tformattedValueOutput:    \"-12345678\",\n\t\t\t\tnoScientificValueOutput: \"-12345678\",\n\t\t\t},\n\t\t}\n\t\tfor _, testCase := range testCases {\n\t\t\tcell := Cell{\n\t\t\t\tcellType:  CellTypeNumeric,\n\t\t\t\tNumFmt:    builtInNumFmt[builtInNumFmtIndex_GENERAL],\n\t\t\t\tValue:     testCase.value,\n\t\t\t\torigValue: testCase.value,\n\t\t\t}\n\t\t\tval, err := cell.FormattedValue()\n\t\t\tif err != nil {\n\t\t\t\tc.Fatal(err)\n\t\t\t}\n\t\t\tc.Assert(val, qt.Equals, testCase.formattedValueOutput)\n\t\t\tval, err = cell.GeneralNumericWithoutScientific()\n\t\t\tif err != nil {\n\t\t\t\tc.Fatal(err)\n\t\t\t}\n\t\t\tc.Assert(val, qt.Equals, testCase.noScientificValueOutput)\n\t\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t\t}\n\t})\n\n\t// TestCellTypeFormatHandling tests all cell types other than numeric. Numeric cells are tested above since those\n\t// cells have so many edge cases.\n\tc.Run(\"TestCellTypeFormatHandling\", func(c *qt.C) {\n\t\ttestCases := []struct {\n\t\t\tcellType             CellType\n\t\t\tnumFmt               string\n\t\t\tvalue                string\n\t\t\tformattedValueOutput string\n\t\t\texpectError          bool\n\t\t}{\n\t\t\t// All of the string cell types, will return only the string format if there is no @ symbol in the format.\n\t\t\t{\n\t\t\t\tcellType:             CellTypeInline,\n\t\t\t\tnumFmt:               `0;0;0;\"Error\"`,\n\t\t\t\tvalue:                \"asdf\",\n\t\t\t\tformattedValueOutput: \"Error\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tcellType:             CellTypeString,\n\t\t\t\tnumFmt:               `0;0;0;\"Error\"`,\n\t\t\t\tvalue:                \"asdf\",\n\t\t\t\tformattedValueOutput: \"Error\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tcellType:             CellTypeStringFormula,\n\t\t\t\tnumFmt:               `0;0;0;\"Error\"`,\n\t\t\t\tvalue:                \"asdf\",\n\t\t\t\tformattedValueOutput: \"Error\",\n\t\t\t},\n\t\t\t// Errors are returned as is regardless of what the format shows\n\t\t\t{\n\t\t\t\tcellType:             CellTypeError,\n\t\t\t\tnumFmt:               `0;0;0;\"Error\"`,\n\t\t\t\tvalue:                \"#NAME?\",\n\t\t\t\tformattedValueOutput: \"#NAME?\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tcellType:             CellTypeError,\n\t\t\t\tnumFmt:               `\"$\"@`,\n\t\t\t\tvalue:                \"#######\",\n\t\t\t\tformattedValueOutput: \"#######\",\n\t\t\t},\n\t\t\t// Dates are returned as is regardless of what the format shows\n\t\t\t{\n\t\t\t\tcellType:             CellTypeDate,\n\t\t\t\tnumFmt:               `\"$\"@`,\n\t\t\t\tvalue:                \"2017-10-24T15:29:30+00:00\",\n\t\t\t\tformattedValueOutput: \"2017-10-24T15:29:30+00:00\",\n\t\t\t},\n\t\t\t// Make sure the format used above would have done something for a string\n\t\t\t{\n\t\t\t\tcellType:             CellTypeString,\n\t\t\t\tnumFmt:               `\"$\"@`,\n\t\t\t\tvalue:                \"#######\",\n\t\t\t\tformattedValueOutput: \"$#######\",\n\t\t\t},\n\t\t\t// For bool cells, 0 is false, 1 is true, anything else will error\n\t\t\t{\n\t\t\t\tcellType:             CellTypeBool,\n\t\t\t\tnumFmt:               `\"$\"@`,\n\t\t\t\tvalue:                \"1\",\n\t\t\t\tformattedValueOutput: \"TRUE\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tcellType:             CellTypeBool,\n\t\t\t\tnumFmt:               `\"$\"@`,\n\t\t\t\tvalue:                \"0\",\n\t\t\t\tformattedValueOutput: \"FALSE\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tcellType:             CellTypeBool,\n\t\t\t\tnumFmt:               `\"$\"@`,\n\t\t\t\tvalue:                \"2\",\n\t\t\t\texpectError:          true,\n\t\t\t\tformattedValueOutput: \"2\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tcellType:             CellTypeBool,\n\t\t\t\tnumFmt:               `\"$\"@`,\n\t\t\t\tvalue:                \"2\",\n\t\t\t\texpectError:          true,\n\t\t\t\tformattedValueOutput: \"2\",\n\t\t\t},\n\t\t\t// Invalid cell type should cause an error\n\t\t\t{\n\t\t\t\tcellType:             CellType(7),\n\t\t\t\tnumFmt:               `0`,\n\t\t\t\tvalue:                \"1.0\",\n\t\t\t\texpectError:          true,\n\t\t\t\tformattedValueOutput: \"1.0\",\n\t\t\t},\n\t\t}\n\t\tfor _, testCase := range testCases {\n\t\t\tcell := Cell{\n\t\t\t\tcellType:   testCase.cellType,\n\t\t\t\tNumFmt:     testCase.numFmt,\n\t\t\t\torigNumFmt: testCase.numFmt,\n\t\t\t\tValue:      testCase.value,\n\t\t\t\torigValue:  testCase.value,\n\t\t\t}\n\t\t\tval, err := cell.FormattedValue()\n\t\t\tif err != nil != testCase.expectError {\n\t\t\t\tc.Fatal(err)\n\t\t\t}\n\t\t\tc.Assert(val, qt.Equals, testCase.formattedValueOutput)\n\t\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t\t}\n\t})\n\n\tc.Run(\"TestIsTime\", func(c *qt.C) {\n\t\tcell := Cell{}\n\t\tisTime := cell.IsTime()\n\t\tc.Assert(isTime, qt.Equals, false)\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t\tcell.Value = \"43221\"\n\t\tc.Assert(isTime, qt.Equals, false)\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t\tcell.NumFmt = \"d-mmm-yy\"\n\t\tcell.Value = \"43221\"\n\t\tisTime = cell.IsTime()\n\t\tc.Assert(isTime, qt.Equals, true)\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t})\n\n\tc.Run(\"TestGetTime\", func(c *qt.C) {\n\t\tcell := Cell{}\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t\tcell.SetFloat(0)\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t\tdate, err := cell.GetTime(false)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(date, qt.Equals, time.Date(1899, 12, 30, 0, 0, 0, 0, time.UTC))\n\t\tcell.SetFloat(39813.0)\n\t\tdate, err = cell.GetTime(true)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(date, qt.Equals, time.Date(2013, 1, 1, 0, 0, 0, 0, time.UTC))\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t\tcell.Value = \"d\"\n\t\t_, err = cell.GetTime(false)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t})\n\n\t// FormattedValue returns an error for formatting errors\n\tc.Run(\"TestFormattedValueErrorsOnBadFormat\", func(c *qt.C) {\n\t\tcell := Cell{Value: \"Fudge Cake\", cellType: CellTypeNumeric, origValue: \"Fudge Cake\"}\n\t\tcell.NumFmt = \"#,##0 ;(#,##0)\"\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t\tvalue, err := cell.FormattedValue()\n\t\tc.Assert(value, qt.Equals, \"Fudge Cake\")\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t\tc.Assert(err.Error(), qt.Equals, \"strconv.ParseFloat: parsing \\\"Fudge Cake\\\": invalid syntax\")\n\t})\n\n\t// We can return a string representation of the formatted data\n\tc.Run(\"TestFormattedValue\", func(c *qt.C) {\n\t\tcell := Cell{Value: \"37947.7500001\", origValue: \"37947.7500001\", cellType: CellTypeNumeric}\n\t\tnegativeCell := Cell{Value: \"-37947.7500001\", origValue: \"-37947.7500001\", cellType: CellTypeNumeric}\n\t\tsmallCell := Cell{Value: \"0.007\", origValue: \"0.007\", cellType: CellTypeNumeric}\n\t\tearlyCell := Cell{Value: \"2.1\", origValue: \"2.1\", cellType: CellTypeNumeric}\n\n\t\tfvc := formattedValueChecker{c: c}\n\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t\tcell.NumFmt = \"general\"\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\n\t\tfvc.Equals(cell, \"37947.7500001\")\n\t\tnegativeCell.NumFmt = \"general\"\n\t\tfvc.Equals(negativeCell, \"-37947.7500001\")\n\n\t\t// TODO: This test is currently broken.  For a string type cell, I\n\t\t// don't think FormattedValue() should be doing a numeric conversion on the value\n\t\t// before returning the string.\n\t\tcell.NumFmt = \"0\"\n\t\tfvc.Equals(cell, \"37948\")\n\n\t\tcell.NumFmt = \"#,##0\" // For the time being we're not doing\n\t\t// this comma formatting, so it'll fall back to the related\n\t\t// non-comma form.\n\t\tfvc.Equals(cell, \"37948\")\n\n\t\tcell.NumFmt = \"#,##0.00;(#,##0.00)\"\n\t\tfvc.Equals(cell, \"37947.75\")\n\n\t\tcell.NumFmt = \"0.00\"\n\t\tfvc.Equals(cell, \"37947.75\")\n\n\t\tcell.NumFmt = \"#,##0.00\" // For the time being we're not doing\n\t\t// this comma formatting, so it'll fall back to the related\n\t\t// non-comma form.\n\t\tfvc.Equals(cell, \"37947.75\")\n\n\t\tcell.NumFmt = \"#,##0 ;(#,##0)\"\n\t\tfvc.Equals(cell, \"37948\")\n\t\tnegativeCell.NumFmt = \"#,##0 ;(#,##0)\"\n\t\tfvc.Equals(negativeCell, \"(37948)\")\n\n\t\tcell.NumFmt = \"#,##0 ;[red](#,##0)\"\n\t\tfvc.Equals(cell, \"37948\")\n\t\tnegativeCell.NumFmt = \"#,##0 ;[red](#,##0)\"\n\t\tfvc.Equals(negativeCell, \"(37948)\")\n\n\t\tnegativeCell.NumFmt = \"#,##0.00;(#,##0.00)\"\n\t\tfvc.Equals(negativeCell, \"(37947.75)\")\n\n\t\tcell.NumFmt = \"0%\"\n\t\tfvc.Equals(cell, \"3794775%\")\n\n\t\tcell.NumFmt = \"0.00%\"\n\t\tfvc.Equals(cell, \"3794775.00%\")\n\n\t\tcell.NumFmt = \"0.00e+00\"\n\t\tfvc.Equals(cell, \"3.794775e+04\")\n\n\t\tcell.NumFmt = \"##0.0e+0\" // This is wrong, but we'll use it for now.\n\t\tfvc.Equals(cell, \"3.794775e+04\")\n\n\t\tcell.NumFmt = \"mm-dd-yy\"\n\t\tfvc.Equals(cell, \"11-22-03\")\n\n\t\tcell.NumFmt = \"d-mmm-yy\"\n\t\tfvc.Equals(cell, \"22-Nov-03\")\n\t\tearlyCell.NumFmt = \"d-mmm-yy\"\n\t\tfvc.Equals(earlyCell, \"1-Jan-00\")\n\n\t\tcell.NumFmt = \"d-mmm\"\n\t\tfvc.Equals(cell, \"22-Nov\")\n\t\tearlyCell.NumFmt = \"d-mmm\"\n\t\tfvc.Equals(earlyCell, \"1-Jan\")\n\n\t\tcell.NumFmt = \"mmm-yy\"\n\t\tfvc.Equals(cell, \"Nov-03\")\n\n\t\tcell.NumFmt = \"h:mm am/pm\"\n\t\tfvc.Equals(cell, \"6:00 pm\")\n\t\tsmallCell.NumFmt = \"h:mm am/pm\"\n\t\tfvc.Equals(smallCell, \"12:10 am\")\n\n\t\tcell.NumFmt = \"h:mm:ss am/pm\"\n\t\tfvc.Equals(cell, \"6:00:00 pm\")\n\t\tcell.NumFmt = \"hh:mm:ss\"\n\t\tfvc.Equals(cell, \"18:00:00\")\n\t\tsmallCell.NumFmt = \"h:mm:ss am/pm\"\n\t\tfvc.Equals(smallCell, \"12:10:04 am\")\n\n\t\tcell.NumFmt = \"h:mm\"\n\t\tfvc.Equals(cell, \"18:00\")\n\t\tsmallCell.NumFmt = \"h:mm\"\n\t\tfvc.Equals(smallCell, \"00:10\")\n\t\tsmallCell.NumFmt = \"hh:mm\"\n\t\tfvc.Equals(smallCell, \"00:10\")\n\n\t\tcell.NumFmt = \"h:mm:ss\"\n\t\tfvc.Equals(cell, \"18:00:00\")\n\t\tcell.NumFmt = \"hh:mm:ss\"\n\t\tfvc.Equals(cell, \"18:00:00\")\n\n\t\tsmallCell.NumFmt = \"hh:mm:ss\"\n\t\tfvc.Equals(smallCell, \"00:10:04\")\n\t\tsmallCell.NumFmt = \"h:mm:ss\"\n\t\tfvc.Equals(smallCell, \"00:10:04\")\n\n\t\tcell.NumFmt = \"m/d/yy h:mm\"\n\t\tfvc.Equals(cell, \"11/22/03 18:00\")\n\t\tcell.NumFmt = \"m/d/yy hh:mm\"\n\t\tfvc.Equals(cell, \"11/22/03 18:00\")\n\t\tsmallCell.NumFmt = \"m/d/yy h:mm\"\n\t\tfvc.Equals(smallCell, \"12/30/99 00:10\")\n\t\tsmallCell.NumFmt = \"m/d/yy hh:mm\"\n\t\tfvc.Equals(smallCell, \"12/30/99 00:10\")\n\t\tearlyCell.NumFmt = \"m/d/yy hh:mm\"\n\t\tfvc.Equals(earlyCell, \"1/1/00 02:24\")\n\t\tearlyCell.NumFmt = \"m/d/yy h:mm\"\n\t\tfvc.Equals(earlyCell, \"1/1/00 02:24\")\n\n\t\tcell.NumFmt = \"mm:ss\"\n\t\tfvc.Equals(cell, \"00:00\")\n\t\tsmallCell.NumFmt = \"mm:ss\"\n\t\tfvc.Equals(smallCell, \"10:04\")\n\n\t\tcell.NumFmt = \"[hh]:mm:ss\"\n\t\tfvc.Equals(cell, \"18:00:00\")\n\t\tcell.NumFmt = \"[h]:mm:ss\"\n\t\tfvc.Equals(cell, \"18:00:00\")\n\t\tsmallCell.NumFmt = \"[h]:mm:ss\"\n\t\tfvc.Equals(smallCell, \"10:04\")\n\n\t\tconst (\n\t\t\texpect1 = \"0000.0086\"\n\t\t\texpect2 = \"1004.8000\"\n\t\t\tformat  = \"mmss.0000\"\n\t\t\ttlen    = len(format)\n\t\t)\n\n\t\tfor i := 0; i < 3; i++ {\n\t\t\ttfmt := format[0 : tlen-i]\n\t\t\tcell.NumFmt = tfmt\n\t\t\tfvc.Equals(cell, expect1[0:tlen-i])\n\t\t\tsmallCell.NumFmt = tfmt\n\t\t\tfvc.Equals(smallCell, expect2[0:tlen-i])\n\t\t}\n\n\t\tcell.NumFmt = \"YYYY-MM-DD\"\n\t\tfvc.Equals(cell, \"2003-11-22\")\n\n\t\tcell.NumFmt = \"yyyy-mm-dd\"\n\t\tfvc.Equals(cell, \"2003-11-22\")\n\n\t\tcell.NumFmt = \"yyyy\\\\-mm\\\\-dd\"\n\t\tfvc.Equals(cell, \"2003\\\\-11\\\\-22\")\n\n\t\tcell.NumFmt = \"dd/mm/yyyy hh:mm:ss\"\n\t\tfvc.Equals(cell, \"22/11/2003 18:00:00\")\n\n\t\tcell.NumFmt = \"dd/mm/yy\"\n\t\tfvc.Equals(cell, \"22/11/03\")\n\t\tearlyCell.NumFmt = \"dd/mm/yy\"\n\t\tfvc.Equals(earlyCell, \"01/01/00\")\n\n\t\tcell.NumFmt = \"hh:mm:ss\"\n\t\tfvc.Equals(cell, \"18:00:00\")\n\t\tsmallCell.NumFmt = \"hh:mm:ss\"\n\t\tfvc.Equals(smallCell, \"00:10:04\")\n\n\t\tcell.NumFmt = \"dd/mm/yy\\\\ hh:mm\"\n\t\tfvc.Equals(cell, \"22/11/03\\\\ 18:00\")\n\n\t\tcell.NumFmt = \"yyyy/mm/dd\"\n\t\tfvc.Equals(cell, \"2003/11/22\")\n\n\t\tcell.NumFmt = \"yy-mm-dd\"\n\t\tfvc.Equals(cell, \"03-11-22\")\n\n\t\tcell.NumFmt = \"d-mmm-yyyy\"\n\t\tfvc.Equals(cell, \"22-Nov-2003\")\n\t\tearlyCell.NumFmt = \"d-mmm-yyyy\"\n\t\tfvc.Equals(earlyCell, \"1-Jan-1900\")\n\n\t\tcell.NumFmt = \"m/d/yy\"\n\t\tfvc.Equals(cell, \"11/22/03\")\n\t\tearlyCell.NumFmt = \"m/d/yy\"\n\t\tfvc.Equals(earlyCell, \"1/1/00\")\n\n\t\tcell.NumFmt = \"m/d/yyyy\"\n\t\tfvc.Equals(cell, \"11/22/2003\")\n\t\tearlyCell.NumFmt = \"m/d/yyyy\"\n\t\tfvc.Equals(earlyCell, \"1/1/1900\")\n\n\t\tcell.NumFmt = \"dd-mmm-yyyy\"\n\t\tfvc.Equals(cell, \"22-Nov-2003\")\n\n\t\tcell.NumFmt = \"dd/mm/yyyy\"\n\t\tfvc.Equals(cell, \"22/11/2003\")\n\n\t\tcell.NumFmt = \"mm/dd/yy hh:mm am/pm\"\n\t\tfvc.Equals(cell, \"11/22/03 06:00 pm\")\n\t\tcell.NumFmt = \"mm/dd/yy h:mm am/pm\"\n\t\tfvc.Equals(cell, \"11/22/03 6:00 pm\")\n\n\t\tcell.NumFmt = \"mm/dd/yyyy hh:mm:ss\"\n\t\tfvc.Equals(cell, \"11/22/2003 18:00:00\")\n\t\tsmallCell.NumFmt = \"mm/dd/yyyy hh:mm:ss\"\n\t\tfvc.Equals(smallCell, \"12/30/1899 00:10:04\")\n\n\t\tcell.NumFmt = \"yyyy-mm-dd hh:mm:ss\"\n\t\tfvc.Equals(cell, \"2003-11-22 18:00:00\")\n\t\tsmallCell.NumFmt = \"yyyy-mm-dd hh:mm:ss\"\n\t\tfvc.Equals(smallCell, \"1899-12-30 00:10:04\")\n\n\t\tcell.NumFmt = \"mmmm d, yyyy\"\n\t\tfvc.Equals(cell, \"November 22, 2003\")\n\t\tsmallCell.NumFmt = \"mmmm d, yyyy\"\n\t\tfvc.Equals(smallCell, \"December 30, 1899\")\n\n\t\tcell.NumFmt = \"dddd, mmmm dd, yyyy\"\n\t\tfvc.Equals(cell, \"Saturday, November 22, 2003\")\n\t\tsmallCell.NumFmt = \"dddd, mmmm dd, yyyy\"\n\t\tfvc.Equals(smallCell, \"Saturday, December 30, 1899\")\n\t})\n\n\tc.Run(\"TestTimeToExcelTime\", func(c *qt.C) {\n\t\tc.Assert(0.0, qt.Equals, TimeToExcelTime(time.Date(1899, 12, 30, 0, 0, 0, 0, time.UTC), false))\n\t\tc.Assert(-1462.0, qt.Equals, TimeToExcelTime(time.Date(1899, 12, 30, 0, 0, 0, 0, time.UTC), true))\n\t\tc.Assert(25569.0, qt.Equals, TimeToExcelTime(time.Unix(0, 0), false))\n\t\tc.Assert(43269.0, qt.Equals, TimeToExcelTime(time.Date(2018, 6, 18, 0, 0, 0, 0, time.UTC), false))\n\t\tc.Assert(401769.0, qt.Equals, TimeToExcelTime(time.Date(3000, 1, 1, 0, 0, 0, 0, time.UTC), false))\n\t\tsmallDate := time.Date(1899, 12, 30, 0, 0, 0, 1000, time.UTC)\n\t\tsmallExcelTime := TimeToExcelTime(smallDate, false)\n\n\t\tc.Assert(0.0, qt.Not(qt.Equals), smallExcelTime)\n\t\troundTrippedDate := TimeFromExcelTime(smallExcelTime, false)\n\t\tc.Assert(roundTrippedDate, qt.Equals, smallDate)\n\t})\n\n\t// test setters and getters\n\tc.Run(\"TestSetterGetters\", func(c *qt.C) {\n\t\tcell := Cell{}\n\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t\tcell.SetString(\"hello world\")\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t\tif val, err := cell.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"hello world\")\n\t\t}\n\t\tc.Assert(cell.Type(), qt.Equals, CellTypeString)\n\n\t\tcell = Cell{}\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t\tcell.SetInt(1024)\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t\tintValue, _ := cell.Int()\n\t\tc.Assert(intValue, qt.Equals, 1024)\n\t\tc.Assert(cell.NumFmt, qt.Equals, builtInNumFmt[builtInNumFmtIndex_GENERAL])\n\t\tc.Assert(cell.Type(), qt.Equals, CellTypeNumeric)\n\n\t\tcell = Cell{}\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t\tcell.SetInt64(1024)\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t\tint64Value, _ := cell.Int64()\n\t\tc.Assert(int64Value, qt.Equals, int64(1024))\n\t\tc.Assert(cell.NumFmt, qt.Equals, builtInNumFmt[builtInNumFmtIndex_GENERAL])\n\t\tc.Assert(cell.Type(), qt.Equals, CellTypeNumeric)\n\n\t\tcell = Cell{}\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t\tcell.SetFloat(1.024)\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t\tfloat, _ := cell.Float()\n\t\tintValue, _ = cell.Int() // convert\n\t\tc.Assert(float, qt.Equals, 1.024)\n\t\tc.Assert(intValue, qt.Equals, 1)\n\t\tc.Assert(cell.NumFmt, qt.Equals, builtInNumFmt[builtInNumFmtIndex_GENERAL])\n\t\tc.Assert(cell.Type(), qt.Equals, CellTypeNumeric)\n\n\t\tcell = Cell{}\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t\tcell.SetFormula(\"10+20\")\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t\tc.Assert(cell.Formula(), qt.Equals, \"10+20\")\n\t\tc.Assert(cell.Type(), qt.Equals, CellTypeNumeric)\n\n\t\tcell = Cell{}\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t\tcell.SetStringFormula(\"A1\")\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t\tc.Assert(cell.Formula(), qt.Equals, \"A1\")\n\t\tc.Assert(cell.Type(), qt.Equals, CellTypeStringFormula)\n\t})\n\n\t// TestOddInput is a regression test for #101. When the number format\n\t// was \"@\" (string), the input below caused a crash in strconv.ParseFloat.\n\t// The solution was to check if cell.Value was both a CellTypeString and\n\t// had a NumFmt of \"general\" or \"@\" and short-circuit FormattedValue() if so.\n\tc.Run(\"TestOddInput\", func(c *qt.C) {\n\t\tcell := Cell{}\n\t\todd := `[1],[12,\"DATE NOT NULL DEFAULT '0000-00-00'\"]`\n\t\tcell.Value = odd\n\t\tcell.NumFmt = \"@\"\n\t\tif val, err := cell.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, odd)\n\t\t}\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t})\n\n\t// TestBool tests basic Bool getting and setting booleans.\n\tc.Run(\"TestBool\", func(c *qt.C) {\n\t\tcell := Cell{}\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t\tcell.SetBool(true)\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t\tc.Assert(cell.Value, qt.Equals, \"1\")\n\t\tc.Assert(cell.Bool(), qt.Equals, true)\n\t\tcell.SetBool(false)\n\t\tc.Assert(cell.Value, qt.Equals, \"0\")\n\t\tc.Assert(cell.Bool(), qt.Equals, false)\n\t})\n\n\t// TestStringBool tests calling Bool on a non CellTypeBool value.\n\tc.Run(\"TestStringBool\", func(c *qt.C) {\n\t\tcell := Cell{}\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t\tcell.SetInt(0)\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t\tc.Assert(cell.Bool(), qt.Equals, false)\n\t\tcell.SetInt(1)\n\t\tc.Assert(cell.Bool(), qt.Equals, true)\n\t\tcell.SetString(\"\")\n\t\tc.Assert(cell.Bool(), qt.Equals, false)\n\t\tcell.SetString(\"0\")\n\t\tc.Assert(cell.Bool(), qt.Equals, true)\n\t})\n\n\t// TestSetValue tests whether SetValue handle properly for different type values.\n\tc.Run(\"TestSetValue\", func(c *qt.C) {\n\t\tcell := Cell{}\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t\t// int\n\t\tfor _, i := range []interface{}{1, int8(1), int16(1), int32(1), int64(1)} {\n\t\t\tcell.SetValue(i)\n\t\t\tval, err := cell.Int64()\n\t\t\tc.Assert(err, qt.IsNil)\n\t\t\tc.Assert(val, qt.Equals, int64(1))\n\t\t}\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\n\t\tcell = Cell{}\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t\t// float\n\t\tfor _, i := range []interface{}{1.11, float32(1.11), float64(1.11)} {\n\t\t\tcell.SetValue(i)\n\t\t\tval, err := cell.Float()\n\t\t\tc.Assert(err, qt.IsNil)\n\t\t\tc.Assert(val, qt.Equals, 1.11)\n\t\t}\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\n\t\tcell = Cell{}\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t\t// In the naive implementation using go fmt \"%v\", this test would fail and the cell.Value would be \"1e-06\"\n\t\tfor _, i := range []interface{}{0.000001, float32(0.000001), float64(0.000001)} {\n\t\t\tcell.SetValue(i)\n\t\t\tc.Assert(cell.Value, qt.Equals, \"0.000001\")\n\t\t\tval, err := cell.Float()\n\t\t\tc.Assert(err, qt.IsNil)\n\t\t\tc.Assert(val, qt.Equals, 0.000001)\n\t\t}\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\n\t\tcell = Cell{}\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t\t// time\n\t\tcell.SetValue(time.Unix(0, 0))\n\t\tval, err := cell.Float()\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(math.Floor(val), qt.Equals, 25569.0)\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\n\t\t// string and nil\n\t\tcell = Cell{}\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t\tfor _, i := range []interface{}{nil, \"\", []byte(\"\")} {\n\t\t\tcell.SetValue(i)\n\t\t\tc.Assert(cell.Value, qt.Equals, \"\")\n\t\t}\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\n\t\t// others\n\t\tcell = Cell{}\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\t\tcell.SetValue([]string{\"test\"})\n\t\tc.Assert(cell.Value, qt.Equals, \"[test]\")\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\t})\n\n\tc.Run(\"TestSetDateWithOptions\", func(c *qt.C) {\n\t\tcell := Cell{}\n\t\tc.Assert(cell.Modified(), qt.Equals, false)\n\n\t\t// time\n\t\tcell.SetDate(time.Unix(0, 0))\n\t\tval, err := cell.Float()\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(math.Floor(val), qt.Equals, 25569.0)\n\t\tc.Assert(cell.Modified(), qt.Equals, true)\n\n\t\t// our test subject\n\t\tdate2016UTC := time.Date(2016, 1, 1, 12, 0, 0, 0, time.UTC)\n\n\t\t// test ny timezone\n\t\tnyTZ, err := time.LoadLocation(\"America/New_York\")\n\t\tc.Assert(err, qt.IsNil)\n\t\tcell.SetDateWithOptions(date2016UTC, DateTimeOptions{\n\t\t\tExcelTimeFormat: \"test_format1\",\n\t\t\tLocation:        nyTZ,\n\t\t})\n\t\tval, err = cell.Float()\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(val, qt.Equals, TimeToExcelTime(time.Date(2016, 1, 1, 7, 0, 0, 0, time.UTC), false))\n\n\t\t// test jp timezone\n\t\tjpTZ, err := time.LoadLocation(\"Asia/Tokyo\")\n\t\tc.Assert(err, qt.IsNil)\n\t\tcell.SetDateWithOptions(date2016UTC, DateTimeOptions{\n\t\t\tExcelTimeFormat: \"test_format2\",\n\t\t\tLocation:        jpTZ,\n\t\t})\n\t\tval, err = cell.Float()\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(val, qt.Equals, TimeToExcelTime(time.Date(2016, 1, 1, 21, 0, 0, 0, time.UTC), false))\n\t})\n\n\tc.Run(\"TestIsTimeFormat\", func(c *qt.C) {\n\t\tc.Assert(isTimeFormat(\"yy\"), qt.Equals, true)\n\t\tc.Assert(isTimeFormat(\"hh\"), qt.Equals, true)\n\t\tc.Assert(isTimeFormat(\"h\"), qt.Equals, true)\n\t\tc.Assert(isTimeFormat(\"am/pm\"), qt.Equals, true)\n\t\tc.Assert(isTimeFormat(\"AM/PM\"), qt.Equals, true)\n\t\tc.Assert(isTimeFormat(\"A/P\"), qt.Equals, true)\n\t\tc.Assert(isTimeFormat(\"a/p\"), qt.Equals, true)\n\t\tc.Assert(isTimeFormat(\"ss\"), qt.Equals, true)\n\t\tc.Assert(isTimeFormat(\"mm\"), qt.Equals, true)\n\t\tc.Assert(isTimeFormat(\":\"), qt.Equals, false)\n\t\tc.Assert(isTimeFormat(\"z\"), qt.Equals, false)\n\t})\n\n\tc.Run(\"TestIs12HourtTime\", func(c *qt.C) {\n\t\tc.Assert(is12HourTime(\"am/pm\"), qt.Equals, true)\n\t\tc.Assert(is12HourTime(\"AM/PM\"), qt.Equals, true)\n\t\tc.Assert(is12HourTime(\"a/p\"), qt.Equals, true)\n\t\tc.Assert(is12HourTime(\"A/P\"), qt.Equals, true)\n\t\tc.Assert(is12HourTime(\"x\"), qt.Equals, false)\n\t})\n\n\tc.Run(\"TestFallbackTo\", func(c *qt.C) {\n\t\ttestCases := []struct {\n\t\t\tcellType       *CellType\n\t\t\tcellData       string\n\t\t\tfallback       CellType\n\t\t\texpectedReturn CellType\n\t\t}{\n\t\t\t{\n\t\t\t\tcellType:       CellTypeNumeric.Ptr(),\n\t\t\t\tcellData:       `string`,\n\t\t\t\tfallback:       CellTypeString,\n\t\t\t\texpectedReturn: CellTypeString,\n\t\t\t},\n\t\t\t{\n\t\t\t\tcellType:       nil,\n\t\t\t\tcellData:       `string`,\n\t\t\t\tfallback:       CellTypeNumeric,\n\t\t\t\texpectedReturn: CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tcellType:       CellTypeNumeric.Ptr(),\n\t\t\t\tcellData:       `300.24`,\n\t\t\t\tfallback:       CellTypeString,\n\t\t\t\texpectedReturn: CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tcellType:       CellTypeNumeric.Ptr(),\n\t\t\t\tcellData:       `300`,\n\t\t\t\tfallback:       CellTypeString,\n\t\t\t\texpectedReturn: CellTypeNumeric,\n\t\t\t},\n\t\t}\n\t\tfor _, testCase := range testCases {\n\t\t\tc.Assert(testCase.cellType.fallbackTo(testCase.cellData, testCase.fallback), qt.Equals, testCase.expectedReturn)\n\t\t}\n\t})\n\n\t// Test that GetCoordinates returns accurate numbers..\n\tcsRunO(c, \"GetCoordinates\", func(c *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Test\")\n\t\trow := sheet.AddRow()\n\t\tcell := row.AddCell()\n\t\tx, y := cell.GetCoordinates()\n\t\tc.Assert(x, qt.Equals, 0)\n\t\tc.Assert(y, qt.Equals, 0)\n\t\tcell = row.AddCell()\n\t\tx, y = cell.GetCoordinates()\n\t\tc.Assert(x, qt.Equals, 1)\n\t\tc.Assert(y, qt.Equals, 0)\n\t\trow = sheet.AddRow()\n\t\tcell = row.AddCell()\n\t\tx, y = cell.GetCoordinates()\n\t\tc.Assert(x, qt.Equals, 0)\n\t\tc.Assert(y, qt.Equals, 1)\n\t})\n\n}\n\n// formattedValueChecker removes all the boilerplate for testing Cell.FormattedValue\n// after its change from returning one value (a string) to two values (string, error)\n// This allows all the old one-line asserts in the test to continue to be one\n// line, instead of multi-line with error checking.\ntype formattedValueChecker struct {\n\tc *qt.C\n}\n\nfunc (fvc *formattedValueChecker) Equals(cell Cell, expected string) {\n\tval, err := cell.FormattedValue()\n\tif err != nil {\n\t\tfvc.c.Error(err)\n\t}\n\tfvc.c.Assert(val, qt.Equals, expected)\n}\n\nfunc TestCellMerge(t *testing.T) {\n\tc := qt.New(t)\n\tcsRunO(c, \"MergeAndSave\", func(c *qt.C, option FileOption) {\n\t\t// This test exposed issue #559 with the custom XML writer for xlsxWorksheet\n\t\tf := NewFile(option)\n\t\tsht, err := f.AddSheet(\"sheet1\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\trow := sht.AddRow()\n\t\tcell := row.AddCell()\n\t\tcell.Value = \"test\"\n\t\tcell.Merge(1, 0)\n\t\tpath := filepath.Join(t.TempDir(), \"merged.xlsx\")\n\t\terr = f.Save(path)\n\t\tc.Assert(err, qt.Equals, nil)\n\t})\n}\n"
        },
        {
          "name": "cellstore.go",
          "type": "blob",
          "size": 2.3828125,
          "content": "package xlsx\n\nimport \"fmt\"\n\n// CellStore provides an interface for interacting with backend cell\n// storage. For example, this allows us, as required, to persist cells\n// to some store instead of holding them in memory.  This tactic\n// allows us a degree of control around the characteristics of our\n// programs when handling large spreadsheets - we can choose to run\n// more slowly, but without exhausting system memory.\n//\n// If you wish to implement a custom CellStore you must not only\n// support this interface, but also a CellStoreConstructor and a\n// FileOption that set's the File's cellStoreConstructor to the right\n// constructor.\ntype CellStore interface {\n\tMakeRow(sheet *Sheet) *Row\n\tMakeRowWithLen(sheet *Sheet, len int) *Row\n\tReadRow(key string, sheet *Sheet) (*Row, error)\n\tWriteRow(r *Row) error\n\tMoveRow(r *Row, newIndex int) error\n\tRemoveRow(key string) error\n\tClose() error\n}\n\n// CellStoreConstructor defines the signature of a function that will\n// be used to return a new instance of the CellStore implmentation,\n// you must pass this into\ntype CellStoreConstructor func() (CellStore, error)\n\n// CellStoreRow is the interface used to interact with the currently loaded Row from the CellStore.  Different backends can choose whether to hold the whole row in memory, or persist and load the cell\ntype CellStoreRow interface {\n\tAddCell() *Cell\n\tGetCell(colIdx int) *Cell\n\tPushCell(c *Cell)\n\tForEachCell(cvf CellVisitorFunc, option ...CellVisitorOption) error\n\tMaxCol() int\n\tCellCount() int\n\tUpdatable()\n\tCellUpdatable(c *Cell)\n}\n\n// CellVisitorFunc defines the signature of a function that will be\n// called when visiting a Cell using CellStore.ForEachInRow.\ntype CellVisitorFunc func(c *Cell) error\n\n// RowNotFoundError is an Error that should be returned by a\n// RowStore implementation if a call to ReadRow is made with a key\n// that doesn't correspond to any persisted Row.\ntype RowNotFoundError struct {\n\tkey    string\n\treason string\n}\n\n// NewRowNotFoundError creates a new RowNotFoundError, capturing the Row key and the reason this key could not be found.\nfunc NewRowNotFoundError(key, reason string) *RowNotFoundError {\n\treturn &RowNotFoundError{key, reason}\n}\n\n// Error returns a human-readable description of the failure to find a Row.  It makes RowNotFoundError comply with the Error interface.\nfunc (cnfe RowNotFoundError) Error() string {\n\treturn fmt.Sprintf(\"Row %q not found. %s\", cnfe.key, cnfe.reason)\n}\n"
        },
        {
          "name": "col.go",
          "type": "blob",
          "size": 9.486328125,
          "content": "package xlsx\n\n// Default column width in excel\nconst ColWidth = 9.5\nconst Excel2006MaxRowCount = 1048576\nconst Excel2006MaxRowIndex = Excel2006MaxRowCount - 1\n\ntype Col struct {\n\tMin          int\n\tMax          int\n\tHidden       *bool\n\tWidth        *float64\n\tCollapsed    *bool\n\tOutlineLevel *uint8\n\tBestFit      *bool\n\tCustomWidth  *bool\n\tPhonetic     *bool\n\tnumFmt       string\n\tparsedNumFmt *parsedNumberFormat\n\tstyle        *Style\n\toutXfID      int\n}\n\n// NewColForRange return a pointer to a new Col, which will apply to\n// columns in the range min to max (inclusive).  Note, in order for\n// this Col to do anything useful you must set some of its parameters\n// and then apply it to a Sheet by calling sheet.SetColParameters.\n// Column numbers start from 1.\nfunc NewColForRange(min, max int) *Col {\n\tif min < 1 {\n\t\tpanic(\"min col must be >= 1\")\n\t}\n\tif max < min {\n\t\t// Nice try ;-)\n\t\treturn &Col{Min: max, Max: min}\n\t}\n\n\treturn &Col{Min: min, Max: max}\n}\n\n// SetWidth sets the width of columns that have this Col applied to\n// them.  The width is expressed as the number of characters of the\n// maximum digit width of the numbers 0-9 as rendered in the normal\n// style's font.\nfunc (c *Col) SetWidth(width float64) {\n\tc.Width = &width\n\tcustom := true\n\tc.CustomWidth = &custom\n}\n\n// SetType will set the format string of a column based on the type that you want to set it to.\n// This function does not really make a lot of sense.\nfunc (c *Col) SetType(cellType CellType) {\n\tswitch cellType {\n\tcase CellTypeString:\n\t\tc.numFmt = builtInNumFmt[builtInNumFmtIndex_STRING]\n\tcase CellTypeNumeric:\n\t\tc.numFmt = builtInNumFmt[builtInNumFmtIndex_INT]\n\tcase CellTypeBool:\n\t\tc.numFmt = builtInNumFmt[builtInNumFmtIndex_GENERAL] //TEMP\n\tcase CellTypeInline:\n\t\tc.numFmt = builtInNumFmt[builtInNumFmtIndex_STRING]\n\tcase CellTypeError:\n\t\tc.numFmt = builtInNumFmt[builtInNumFmtIndex_GENERAL] //TEMP\n\tcase CellTypeDate:\n\t\t// Cells that are stored as dates are not properly supported in this library.\n\t\t// They should instead be stored as a Numeric with a date format.\n\t\tc.numFmt = builtInNumFmt[builtInNumFmtIndex_GENERAL]\n\tcase CellTypeStringFormula:\n\t\tc.numFmt = builtInNumFmt[builtInNumFmtIndex_STRING]\n\t}\n}\n\n// GetStyle returns the Style associated with a Col\nfunc (c *Col) GetStyle() *Style {\n\treturn c.style\n}\n\n// SetStyle sets the style of a Col\nfunc (c *Col) SetStyle(style *Style) {\n\tc.style = style\n}\n\nfunc (c *Col) SetOutlineLevel(outlineLevel uint8) {\n\tc.OutlineLevel = &outlineLevel\n}\n\n// copyToRange is an internal convenience function to make a copy of a\n// Col with a different Min and Max value, it is not intended as a\n// general purpose Col copying function as you must still insert the\n// resulting Col into the Col Store.\nfunc (c *Col) copyToRange(min, max int) *Col {\n\treturn &Col{\n\t\tMin:          min,\n\t\tMax:          max,\n\t\tHidden:       c.Hidden,\n\t\tWidth:        c.Width,\n\t\tCollapsed:    c.Collapsed,\n\t\tOutlineLevel: c.OutlineLevel,\n\t\tBestFit:      c.BestFit,\n\t\tCustomWidth:  c.CustomWidth,\n\t\tPhonetic:     c.Phonetic,\n\t\tnumFmt:       c.numFmt,\n\t\tparsedNumFmt: c.parsedNumFmt,\n\t\tstyle:        c.style,\n\t}\n}\n\ntype ColStoreNode struct {\n\tCol  *Col\n\tPrev *ColStoreNode\n\tNext *ColStoreNode\n}\n\nfunc (csn *ColStoreNode) findNodeForColNum(num int) *ColStoreNode {\n\tswitch {\n\tcase num >= csn.Col.Min && num <= csn.Col.Max:\n\t\treturn csn\n\n\tcase num < csn.Col.Min:\n\t\tif csn.Prev == nil {\n\t\t\treturn nil\n\t\t}\n\t\tif csn.Prev.Col.Max < num {\n\t\t\treturn nil\n\t\t}\n\t\treturn csn.Prev.findNodeForColNum(num)\n\n\tcase num > csn.Col.Max:\n\t\tif csn.Next == nil {\n\t\t\treturn nil\n\t\t}\n\t\tif csn.Next.Col.Min > num {\n\t\t\treturn nil\n\t\t}\n\t\treturn csn.Next.findNodeForColNum(num)\n\t}\n\treturn nil\n}\n\n// ColStore is the working store of Col definitions, it will simplify all Cols added to it, to ensure there ar no overlapping definitions.\ntype ColStore struct {\n\tRoot *ColStoreNode\n\tLen  int\n}\n\n// Add a Col to the ColStore. If it overwrites all, or part of some\n// existing Col's range of columns the that Col will be adjusted\n// and/or split to make room for the new Col.\nfunc (cs *ColStore) Add(col *Col) *ColStoreNode {\n\tnewNode := &ColStoreNode{Col: col}\n\tif cs.Root == nil {\n\t\tcs.Root = newNode\n\t\tcs.Len = 1\n\t\treturn newNode\n\t}\n\tcs.makeWay(cs.Root, newNode)\n\treturn newNode\n}\n\nfunc (cs *ColStore) FindColByIndex(index int) *Col {\n\tcsn := cs.findNodeForColNum(index)\n\tif csn != nil {\n\t\treturn csn.Col\n\t}\n\treturn nil\n}\n\nfunc (cs *ColStore) findNodeForColNum(num int) *ColStoreNode {\n\tif cs.Root == nil {\n\t\treturn nil\n\t}\n\treturn cs.Root.findNodeForColNum(num)\n}\n\nfunc (cs *ColStore) removeNode(node *ColStoreNode) {\n\tif node.Prev != nil {\n\t\tif node.Next != nil {\n\t\t\tnode.Prev.Next = node.Next\n\t\t} else {\n\t\t\tnode.Prev.Next = nil\n\t\t}\n\n\t}\n\tif node.Next != nil {\n\t\tif node.Prev != nil {\n\t\t\tnode.Next.Prev = node.Prev\n\t\t} else {\n\t\t\tnode.Next.Prev = nil\n\t\t}\n\t}\n\tif cs.Root == node {\n\t\tswitch {\n\t\tcase node.Prev != nil:\n\t\t\tcs.Root = node.Prev\n\t\tcase node.Next != nil:\n\t\t\tcs.Root = node.Next\n\t\tdefault:\n\t\t\tcs.Root = nil\n\t\t}\n\t}\n\tnode.Next = nil\n\tnode.Prev = nil\n\tcs.Len -= 1\n}\n\n// makeWay will adjust the Min and Max of this ColStoreNode's Col to\n// make way for a new ColStoreNode's Col. If necessary it will\n// generate an additional ColStoreNode with a new Col covering the\n// \"tail\" portion of this ColStoreNode's Col should the new node lay\n// completely within the range of this one, but without reaching its\n// maximum extent.\nfunc (cs *ColStore) makeWay(node1, node2 *ColStoreNode) {\n\tswitch {\n\tcase node1.Col.Max < node2.Col.Min:\n\t\t// The node2 starts after node1 ends, there's no overlap\n\t\t//\n\t\t// Node1 |----|\n\t\t// Node2        |----|\n\t\tif node1.Next != nil {\n\t\t\tif node1.Next.Col.Min <= node2.Col.Max {\n\t\t\t\tcs.makeWay(node1.Next, node2)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcs.addNode(node1, node2, node1.Next)\n\t\t\treturn\n\t\t}\n\t\tcs.addNode(node1, node2, nil)\n\t\treturn\n\n\tcase node1.Col.Min > node2.Col.Max:\n\t\t// Node2 ends before node1 begins, there's no overlap\n\t\t//\n\t\t// Node1         |-----|\n\t\t// Node2  |----|\n\t\tif node1.Prev != nil {\n\t\t\tif node1.Prev.Col.Max >= node2.Col.Min {\n\t\t\t\tcs.makeWay(node1.Prev, node2)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcs.addNode(node1.Prev, node2, node1)\n\t\t\treturn\n\t\t}\n\t\tcs.addNode(nil, node2, node1)\n\t\treturn\n\n\tcase node1.Col.Min == node2.Col.Min && node1.Col.Max == node2.Col.Max:\n\t\t// Exact match\n\t\t//\n\t\t// Node1 |xxx|\n\t\t// Node2 |---|\n\n\t\tprev := node1.Prev\n\t\tnext := node1.Next\n\t\tcs.removeNode(node1)\n\t\tcs.addNode(prev, node2, next)\n\t\t// Remove node may have set the root to nil\n\t\tif cs.Root == nil {\n\t\t\tcs.Root = node2\n\t\t}\n\t\treturn\n\n\tcase node1.Col.Min > node2.Col.Min && node1.Col.Max < node2.Col.Max:\n\t\t// Node2 envelopes node1\n\t\t//\n\t\t// Node1  |xx|\n\t\t// Node2 |----|\n\n\t\tprev := node1.Prev\n\t\tnext := node1.Next\n\t\tcs.removeNode(node1)\n\t\tswitch {\n\t\tcase prev == node2:\n\t\t\tnode2.Next = next\n\t\tcase next == node2:\n\t\t\tnode2.Prev = prev\n\t\tdefault:\n\t\t\tcs.addNode(prev, node2, next)\n\t\t}\n\n\t\tif node2.Prev != nil && node2.Prev.Col.Max >= node2.Col.Min {\n\t\t\tcs.makeWay(prev, node2)\n\t\t}\n\t\tif node2.Next != nil && node2.Next.Col.Min <= node2.Col.Max {\n\t\t\tcs.makeWay(next, node2)\n\t\t}\n\n\t\tif cs.Root == nil {\n\t\t\tcs.Root = node2\n\t\t}\n\n\tcase node1.Col.Min < node2.Col.Min && node1.Col.Max > node2.Col.Max:\n\t\t// Node2 bisects node1:\n\t\t//\n\t\t// Node1 |---xx---|\n\t\t// Node2    |--|\n\t\tnewCol := node1.Col.copyToRange(node2.Col.Max+1, node1.Col.Max)\n\t\tnewNode := &ColStoreNode{Col: newCol}\n\t\tcs.addNode(node1, newNode, node1.Next)\n\t\tnode1.Col.Max = node2.Col.Min - 1\n\t\tcs.addNode(node1, node2, newNode)\n\t\treturn\n\n\tcase node1.Col.Max >= node2.Col.Min && node1.Col.Min < node2.Col.Min:\n\t\t// Node2 overlaps node1 at some point above it's minimum:\n\t\t//\n\t\t//  Node1  |----xx|\n\t\t//  Node2      |-------|\n\t\tnext := node1.Next\n\t\tnode1.Col.Max = node2.Col.Min - 1\n\t\tif next == node2 {\n\t\t\treturn\n\t\t}\n\t\tcs.addNode(node1, node2, next)\n\t\tif next != nil && next.Col.Min <= node2.Col.Max {\n\t\t\tcs.makeWay(next, node2)\n\t\t}\n\t\treturn\n\n\tcase node1.Col.Min <= node2.Col.Max && node1.Col.Min > node2.Col.Min:\n\t\t// Node2 overlaps node1 at some point below it's maximum:\n\t\t//\n\t\t// Node1:     |------|\n\t\t// Node2: |----xx|\n\t\tprev := node1.Prev\n\t\tnode1.Col.Min = node2.Col.Max + 1\n\t\tif prev == node2 {\n\t\t\treturn\n\t\t}\n\t\tcs.addNode(prev, node2, node1)\n\t\tif prev != nil && prev.Col.Max >= node2.Col.Min {\n\t\t\tcs.makeWay(node1.Prev, node2)\n\t\t}\n\t\treturn\n\t}\n}\n\nfunc (cs *ColStore) addNode(prev, this, next *ColStoreNode) {\n\tif prev != nil {\n\t\tprev.Next = this\n\t}\n\tthis.Prev = prev\n\tthis.Next = next\n\tif next != nil {\n\t\tnext.Prev = this\n\t}\n\tcs.Len += 1\n}\n\nfunc (cs *ColStore) getOrMakeColsForRange(start *ColStoreNode, min, max int) []*Col {\n\tcols := []*Col{}\n\tvar csn *ColStoreNode\n\tvar newCol *Col\n\tswitch {\n\tcase start == nil:\n\t\tnewCol = NewColForRange(min, max)\n\t\tcsn = cs.Add(newCol)\n\tcase start.Col.Min <= min && start.Col.Max >= min:\n\t\tcsn = start\n\tcase start.Col.Min < min && start.Col.Max < min:\n\t\tif start.Next != nil {\n\t\t\treturn cs.getOrMakeColsForRange(start.Next, min, max)\n\t\t}\n\t\tnewCol = NewColForRange(min, max)\n\t\tcsn = cs.Add(newCol)\n\tcase start.Col.Min > min:\n\t\tif start.Col.Min > max {\n\t\t\tnewCol = NewColForRange(min, max)\n\t\t} else {\n\t\t\tnewCol = NewColForRange(min, start.Col.Min-1)\n\t\t}\n\t\tcsn = cs.Add(newCol)\n\t}\n\n\tcols = append(cols, csn.Col)\n\tif csn.Col.Max >= max {\n\t\treturn cols\n\t}\n\tcols = append(cols, cs.getOrMakeColsForRange(csn.Next, csn.Col.Max+1, max)...)\n\treturn cols\n}\n\nfunc chainOp(csn *ColStoreNode, fn func(idx int, col *Col)) {\n\tfor csn.Prev != nil {\n\t\tcsn = csn.Prev\n\t}\n\n\tvar i int\n\tfor i = 0; csn.Next != nil; i++ {\n\t\tfn(i, csn.Col)\n\t\tcsn = csn.Next\n\t}\n\tfn(i+1, csn.Col)\n}\n\n// ForEach calls the function fn for each Col defined in the ColStore.\nfunc (cs *ColStore) ForEach(fn func(idx int, col *Col)) {\n\tif cs.Root == nil {\n\t\treturn\n\t}\n\tchainOp(cs.Root, fn)\n}\n"
        },
        {
          "name": "col_test.go",
          "type": "blob",
          "size": 16.7197265625,
          "content": "package xlsx\n\nimport (\n\t\t\"testing\"\n\n\t\tqt \"github.com/frankban/quicktest\"\n)\n\nvar notNil = qt.Not(qt.IsNil)\n\nfunc TestNewColForRange(t *testing.T) {\n\t\tc := qt.New(t)\n\t\tcol := NewColForRange(30, 45)\n\t\tc.Assert(col, notNil)\n\t\tc.Assert(col.Min, qt.Equals, 30)\n\t\tc.Assert(col.Max, qt.Equals, 45)\n\n\t\t// Auto fix the min/max\n\t\tcol = NewColForRange(45, 30)\n\t\tc.Assert(col, notNil)\n\t\tc.Assert(col.Min, qt.Equals, 30)\n\t\tc.Assert(col.Max, qt.Equals, 45)\n\n\t\t// Min cannot be less than 1\n\t\tc.Assert(func() {NewColForRange(0, 1)}, qt.PanicMatches, \"min col must be >= 1\")\n}\n\nfunc TestCol(t *testing.T) {\n\t\tc := qt.New(t)\n\t\tc.Run(\"SetType\", func(c *qt.C) {\n\t\t\t\texpectations := map[CellType]string{\n\t\t\t\t\t\tCellTypeString:        builtInNumFmt[builtInNumFmtIndex_STRING],\n\t\t\t\t\t\tCellTypeNumeric:       builtInNumFmt[builtInNumFmtIndex_INT],\n\t\t\t\t\t\tCellTypeBool:          builtInNumFmt[builtInNumFmtIndex_GENERAL],\n\t\t\t\t\t\tCellTypeInline:        builtInNumFmt[builtInNumFmtIndex_STRING],\n\t\t\t\t\t\tCellTypeError:         builtInNumFmt[builtInNumFmtIndex_GENERAL],\n\t\t\t\t\t\tCellTypeDate:          builtInNumFmt[builtInNumFmtIndex_GENERAL],\n\t\t\t\t\t\tCellTypeStringFormula: builtInNumFmt[builtInNumFmtIndex_STRING],\n\t\t\t\t}\n\n\t\t\t\tassertSetType := func(cellType CellType, expectation string) {\n\t\t\t\t\t\tcol := &Col{}\n\t\t\t\t\t\tcol.SetType(cellType)\n\t\t\t\t\t\tc.Assert(col.numFmt, qt.Equals, expectation)\n\t\t\t\t}\n\t\t\t\tfor k, v := range expectations {\n\t\t\t\t\t\tassertSetType(k, v)\n\t\t\t\t}\n\t\t})\n\t\tc.Run(\"SetWidth\", func(c *qt.C) {\n\t\t\t\tcol := &Col{}\n\t\t\t\tcol.SetWidth(20.2)\n\t\t\t\tc.Assert(*col.Width, qt.Equals, 20.2)\n\t\t\t\tc.Assert(*col.CustomWidth, qt.Equals, true)\n\t\t})\n\n\t\tc.Run(\"copyToRange\", func(c *qt.C) {\n\t\t\t\tnf := &parsedNumberFormat{}\n\t\t\t\ts := &Style{}\n\t\t\t\tc1 := &Col{\n\t\t\t\t\t\tMin:          1,\n\t\t\t\t\t\tMax:          11,\n\t\t\t\t\t\tHidden:       bPtr(true),\n\t\t\t\t\t\tWidth:        fPtr(300.4),\n\t\t\t\t\t\tCollapsed:    bPtr(true),\n\t\t\t\t\t\tOutlineLevel: u8Ptr(2),\n\t\t\t\t\t\tnumFmt:       \"-0.00\",\n\t\t\t\t\t\tparsedNumFmt: nf,\n\t\t\t\t\t\tstyle:        s,\n\t\t\t\t}\n\n\t\t\t\tc2 := c1.copyToRange(4, 10)\n\t\t\t\tc.Assert(c2.Min, qt.Equals, 4)\n\t\t\t\tc.Assert(c2.Max, qt.Equals, 10)\n\t\t\t\tc.Assert(c2.Hidden, qt.Equals, c1.Hidden)\n\t\t\t\tc.Assert(c2.Width, qt.Equals, c1.Width)\n\t\t\t\tc.Assert(c2.Collapsed, qt.Equals, c1.Collapsed)\n\t\t\t\tc.Assert(c2.OutlineLevel, qt.Equals, c1.OutlineLevel)\n\t\t\t\tc.Assert(c2.numFmt, qt.Equals, c1.numFmt)\n\t\t\t\tc.Assert(c2.parsedNumFmt, qt.Equals, c1.parsedNumFmt)\n\t\t\t\tc.Assert(c2.style, qt.Equals, c1.style)\n\t\t})\n\n}\n\ntype ColStoreSuite struct{}\n\nfunc TestAddRootNode(t *testing.T) {\n\t\tcol := &Col{Min: 1, Max: 1}\n\t\tcs := ColStore{}\n\t\tcs.Add(col)\n\t\tc := qt.New(t)\n\t\tc.Assert(cs.Len, qt.Equals, 1)\n\t\tc.Assert(cs.Root.Col, qt.Equals, col)\n}\n\nfunc TestMakeWay(t *testing.T) {\n\t\tc := qt.New(t)\n\t\tassertWayMade := func(cols []*Col, chainFunc func(*ColStore)) {\n\n\t\t\t\tcs := &ColStore{}\n\t\t\t\tfor _, col := range cols {\n\t\t\t\t\t\t_ = cs.Add(col)\n\t\t\t\t}\n\t\t\t\tchainFunc(cs)\n\t\t}\n\n\t\t// Col1: |--|\n\t\t// Col2:    |--|\n\t\tassertWayMade([]*Col{{Min: 1, Max: 2}, {Min: 3, Max: 4}},\n\t\t\t\tfunc(cs *ColStore) {\n\t\t\t\t\t\tc.Assert(cs.Len, qt.Equals, 2)\n\t\t\t\t\t\troot := cs.Root\n\t\t\t\t\t\tc.Assert(root.Col.Min, qt.Equals, 1)\n\t\t\t\t\t\tc.Assert(root.Col.Max, qt.Equals, 2)\n\t\t\t\t\t\tc.Assert(root.Prev, qt.IsNil)\n\t\t\t\t\t\tc.Assert(root.Next, notNil)\n\t\t\t\t\t\tnode2 := root.Next\n\t\t\t\t\t\tc.Assert(node2.Prev, qt.Equals, root)\n\t\t\t\t\t\tc.Assert(node2.Next, qt.IsNil)\n\t\t\t\t\t\tc.Assert(node2.Col.Min, qt.Equals, 3)\n\t\t\t\t\t\tc.Assert(node2.Col.Max, qt.Equals, 4)\n\t\t\t\t})\n\n\t\t// Col1:    |--|\n\t\t// Col2: |--|\n\t\tassertWayMade([]*Col{{Min: 3, Max: 4}, {Min: 1, Max: 2}},\n\t\t\t\tfunc(cs *ColStore) {\n\t\t\t\t\t\troot := cs.Root\n\t\t\t\t\t\tc.Assert(cs.Len, qt.Equals, 2)\n\t\t\t\t\t\tc.Assert(root.Col.Min, qt.Equals, 3)\n\t\t\t\t\t\tc.Assert(root.Col.Max, qt.Equals, 4)\n\t\t\t\t\t\tc.Assert(root.Prev, notNil)\n\t\t\t\t\t\tc.Assert(root.Next, qt.IsNil)\n\t\t\t\t\t\tnode2 := root.Prev\n\t\t\t\t\t\tc.Assert(node2.Next, qt.Equals, root)\n\t\t\t\t\t\tc.Assert(node2.Prev, qt.IsNil)\n\t\t\t\t\t\tc.Assert(node2.Col.Min, qt.Equals, 1)\n\t\t\t\t\t\tc.Assert(node2.Col.Max, qt.Equals, 2)\n\t\t\t\t})\n\n\t\t// Col1: |--x|\n\t\t// Col2:   |--|\n\t\tassertWayMade([]*Col{{Min: 1, Max: 3}, {Min: 3, Max: 4}},\n\t\t\t\tfunc(cs *ColStore) {\n\t\t\t\t\t\troot := cs.Root\n\t\t\t\t\t\tc.Assert(cs.Len, qt.Equals, 2)\n\t\t\t\t\t\tc.Assert(root.Col.Min, qt.Equals, 1)\n\t\t\t\t\t\tc.Assert(root.Col.Max, qt.Equals, 2)\n\t\t\t\t\t\tc.Assert(root.Prev, qt.IsNil)\n\t\t\t\t\t\tc.Assert(root.Next, notNil)\n\t\t\t\t\t\tnode2 := root.Next\n\t\t\t\t\t\tc.Assert(node2.Prev, qt.Equals, root)\n\t\t\t\t\t\tc.Assert(node2.Next, qt.IsNil)\n\t\t\t\t\t\tc.Assert(node2.Col.Min, qt.Equals, 3)\n\t\t\t\t\t\tc.Assert(node2.Col.Max, qt.Equals, 4)\n\t\t\t\t})\n\n\t\t// Col1:  |x-|\n\t\t// Col2: |--|\n\t\tassertWayMade([]*Col{{Min: 2, Max: 3}, {Min: 1, Max: 2}},\n\t\t\t\tfunc(cs *ColStore) {\n\t\t\t\t\t\troot := cs.Root\n\t\t\t\t\t\tc.Assert(cs.Len, qt.Equals, 2)\n\t\t\t\t\t\tc.Assert(root.Col.Min, qt.Equals, 3)\n\t\t\t\t\t\tc.Assert(root.Col.Max, qt.Equals, 3)\n\t\t\t\t\t\tc.Assert(root.Prev, notNil)\n\t\t\t\t\t\tc.Assert(root.Next, qt.IsNil)\n\t\t\t\t\t\tnode2 := root.Prev\n\t\t\t\t\t\tc.Assert(node2.Next, qt.Equals, root)\n\t\t\t\t\t\tc.Assert(node2.Prev, qt.IsNil)\n\t\t\t\t\t\tc.Assert(node2.Col.Min, qt.Equals, 1)\n\t\t\t\t\t\tc.Assert(node2.Col.Max, qt.Equals, 2)\n\t\t\t\t})\n\n\t\t// Col1: |---xx---|\n\t\t// Col2:    |--|\n\t\tassertWayMade([]*Col{{Min: 1, Max: 8}, {Min: 4, Max: 5}},\n\t\t\t\tfunc(cs *ColStore) {\n\t\t\t\t\t\troot := cs.Root\n\t\t\t\t\t\tc.Assert(cs.Len, qt.Equals, 3)\n\t\t\t\t\t\tc.Assert(root.Prev, qt.IsNil)\n\t\t\t\t\t\tc.Assert(root.Next, notNil)\n\t\t\t\t\t\tc.Assert(root.Col.Min, qt.Equals, 1)\n\t\t\t\t\t\tc.Assert(root.Col.Max, qt.Equals, 3)\n\t\t\t\t\t\tnode2 := root.Next\n\t\t\t\t\t\tc.Assert(node2.Prev, qt.Equals, root)\n\t\t\t\t\t\tc.Assert(node2.Col.Min, qt.Equals, 4)\n\t\t\t\t\t\tc.Assert(node2.Col.Max, qt.Equals, 5)\n\t\t\t\t\t\tc.Assert(node2.Next, notNil)\n\t\t\t\t\t\tnode3 := node2.Next\n\t\t\t\t\t\tc.Assert(node3.Prev, qt.Equals, node2)\n\t\t\t\t\t\tc.Assert(node3.Next, qt.IsNil)\n\t\t\t\t\t\tc.Assert(node3.Col.Min, qt.Equals, 6)\n\t\t\t\t\t\tc.Assert(node3.Col.Max, qt.Equals, 8)\n\t\t\t\t})\n\n\t\t// Col1: |xx|\n\t\t// Col2: |--|\n\t\tassertWayMade([]*Col{{Min: 1, Max: 2, Width: fPtr(40.1)}, {Min: 1, Max: 2, Width: fPtr(10.0)}},\n\t\t\t\tfunc(cs *ColStore) {\n\t\t\t\t\t\troot := cs.Root\n\t\t\t\t\t\tc.Assert(cs.Len, qt.Equals, 1)\n\t\t\t\t\t\tc.Assert(root, notNil)\n\t\t\t\t\t\tc.Assert(root.Prev, qt.IsNil)\n\t\t\t\t\t\tc.Assert(root.Next, qt.IsNil)\n\t\t\t\t\t\tc.Assert(root.Col.Min, qt.Equals, 1)\n\t\t\t\t\t\tc.Assert(root.Col.Max, qt.Equals, 2)\n\t\t\t\t\t\t// This is how we establish we have the new node, and not the old one\n\t\t\t\t\t\tc.Assert(*root.Col.Width, qt.Equals, 10.0)\n\t\t\t\t})\n\n\t\t// Col1:  |xx|\n\t\t// Col2: |----|\n\t\tassertWayMade([]*Col{{Min: 2, Max: 3, Width: fPtr(40.1)}, {Min: 1, Max: 4, Width: fPtr(10.0)}},\n\t\t\t\tfunc(cs *ColStore) {\n\t\t\t\t\t\troot := cs.Root\n\t\t\t\t\t\tc.Assert(cs.Len, qt.Equals, 1)\n\t\t\t\t\t\tc.Assert(root.Prev, qt.IsNil)\n\t\t\t\t\t\tc.Assert(root.Next, qt.IsNil)\n\t\t\t\t\t\tc.Assert(root.Col.Min, qt.Equals, 1)\n\t\t\t\t\t\tc.Assert(root.Col.Max, qt.Equals, 4)\n\t\t\t\t\t\t// This is how we establish we have the new node, and not the old one\n\t\t\t\t\t\tc.Assert(*root.Col.Width, qt.Equals, 10.0)\n\t\t\t\t})\n\n\t\t// Col1: |--|\n\t\t// Col2:    |--|\n\t\t// Col3:       |--|\n\t\tassertWayMade([]*Col{{Min: 1, Max: 2}, {Min: 3, Max: 4}, {Min: 5, Max: 6}},\n\t\t\t\tfunc(cs *ColStore) {\n\t\t\t\t\t\troot := cs.Root\n\t\t\t\t\t\tc.Assert(cs.Len, qt.Equals, 3)\n\t\t\t\t\t\tc.Assert(root.Prev, qt.IsNil)\n\t\t\t\t\t\tc.Assert(root.Next, notNil)\n\t\t\t\t\t\tc.Assert(root.Col.Min, qt.Equals, 1)\n\t\t\t\t\t\tc.Assert(root.Col.Max, qt.Equals, 2)\n\t\t\t\t\t\tnode2 := root.Next\n\t\t\t\t\t\tc.Assert(node2.Prev, qt.Equals, root)\n\t\t\t\t\t\tc.Assert(node2.Col.Min, qt.Equals, 3)\n\t\t\t\t\t\tc.Assert(node2.Col.Max, qt.Equals, 4)\n\t\t\t\t\t\tc.Assert(node2.Next, notNil)\n\t\t\t\t\t\tnode3 := node2.Next\n\t\t\t\t\t\tc.Assert(node3.Prev, qt.Equals, node2)\n\t\t\t\t\t\tc.Assert(node3.Next, qt.IsNil)\n\t\t\t\t\t\tc.Assert(node3.Col.Min, qt.Equals, 5)\n\t\t\t\t\t\tc.Assert(node3.Col.Max, qt.Equals, 6)\n\t\t\t\t})\n\n\t\t// Col1:       |--|\n\t\t// Col2:    |--|\n\t\t// Col3: |--|\n\t\tassertWayMade([]*Col{{Min: 5, Max: 6}, {Min: 3, Max: 4}, {Min: 1, Max: 2}},\n\t\t\t\tfunc(cs *ColStore) {\n\t\t\t\t\t\troot := cs.Root\n\t\t\t\t\t\tc.Assert(cs.Len, qt.Equals, 3)\n\t\t\t\t\t\tc.Assert(root.Prev, notNil)\n\t\t\t\t\t\tc.Assert(root.Next, qt.IsNil)\n\t\t\t\t\t\tc.Assert(root.Col.Min, qt.Equals, 5)\n\t\t\t\t\t\tc.Assert(root.Col.Max, qt.Equals, 6)\n\t\t\t\t\t\tnode2 := root.Prev\n\t\t\t\t\t\tc.Assert(node2.Next, qt.Equals, root)\n\t\t\t\t\t\tc.Assert(node2.Col.Min, qt.Equals, 3)\n\t\t\t\t\t\tc.Assert(node2.Col.Max, qt.Equals, 4)\n\t\t\t\t\t\tc.Assert(node2.Prev, notNil)\n\t\t\t\t\t\tnode3 := node2.Prev\n\t\t\t\t\t\tc.Assert(node3.Next, qt.Equals, node2)\n\t\t\t\t\t\tc.Assert(node3.Prev, qt.IsNil)\n\t\t\t\t\t\tc.Assert(node3.Col.Min, qt.Equals, 1)\n\t\t\t\t\t\tc.Assert(node3.Col.Max, qt.Equals, 2)\n\t\t\t\t})\n\n\t\t// Col1: |--|\n\t\t// Col2:          |--|\n\t\t// Col3:     |--|\n\t\tassertWayMade([]*Col{{Min: 1, Max: 2}, {Min: 10, Max: 11}, {Min: 5, Max: 6}},\n\t\t\t\tfunc(cs *ColStore) {\n\t\t\t\t\t\troot := cs.Root\n\t\t\t\t\t\tc.Assert(cs.Len, qt.Equals, 3)\n\t\t\t\t\t\tc.Assert(root.Prev, qt.IsNil)\n\t\t\t\t\t\tc.Assert(root.Next, notNil)\n\t\t\t\t\t\tc.Assert(root.Col.Min, qt.Equals, 1)\n\t\t\t\t\t\tc.Assert(root.Col.Max, qt.Equals, 2)\n\t\t\t\t\t\tnode2 := root.Next\n\t\t\t\t\t\tc.Assert(node2.Prev, qt.Equals, root)\n\t\t\t\t\t\tc.Assert(node2.Col.Min, qt.Equals, 5)\n\t\t\t\t\t\tc.Assert(node2.Col.Max, qt.Equals, 6)\n\t\t\t\t\t\tc.Assert(node2.Next, notNil)\n\t\t\t\t\t\tnode3 := node2.Next\n\t\t\t\t\t\tc.Assert(node3.Prev, qt.Equals, node2)\n\t\t\t\t\t\tc.Assert(node3.Next, qt.IsNil)\n\t\t\t\t\t\tc.Assert(node3.Col.Min, qt.Equals, 10)\n\t\t\t\t\t\tc.Assert(node3.Col.Max, qt.Equals, 11)\n\t\t\t\t})\n\n\t\t// Col1: |-x|\n\t\t// Col2:        |x-|\n\t\t// Col3:  |-------|\n\t\tassertWayMade([]*Col{\n\t\t\t\t{Min: 1, Max: 2}, {Min: 8, Max: 9}, {Min: 2, Max: 8}},\n\t\t\t\tfunc(cs *ColStore) {\n\t\t\t\t\t\troot := cs.Root\n\t\t\t\t\t\tc.Assert(cs.Len, qt.Equals, 3)\n\t\t\t\t\t\tc.Assert(root.Prev, qt.IsNil)\n\t\t\t\t\t\tc.Assert(root.Next, notNil)\n\t\t\t\t\t\tc.Assert(root.Col.Min, qt.Equals, 1)\n\t\t\t\t\t\tc.Assert(root.Col.Max, qt.Equals, 1)\n\t\t\t\t\t\tnode2 := root.Next\n\t\t\t\t\t\tc.Assert(node2.Prev, qt.Equals, root)\n\t\t\t\t\t\tc.Assert(node2.Next, notNil)\n\t\t\t\t\t\tc.Assert(node2.Col.Min, qt.Equals, 2)\n\t\t\t\t\t\tc.Assert(node2.Col.Max, qt.Equals, 8)\n\t\t\t\t\t\tnode3 := node2.Next\n\t\t\t\t\t\tc.Assert(node3.Prev, qt.Equals, node2)\n\t\t\t\t\t\tc.Assert(node3.Next, qt.IsNil)\n\t\t\t\t\t\tc.Assert(node3.Col.Min, qt.Equals, 9)\n\t\t\t\t\t\tc.Assert(node3.Col.Max, qt.Equals, 9)\n\t\t\t\t})\n\n\t\t// Col1: |-x|\n\t\t// Col2:        |--|\n\t\t// Col3:  |-----|\n\t\tassertWayMade([]*Col{\n\t\t\t\t{Min: 1, Max: 2}, {Min: 8, Max: 9}, {Min: 2, Max: 7}},\n\t\t\t\tfunc(cs *ColStore) {\n\t\t\t\t\t\troot := cs.Root\n\t\t\t\t\t\tc.Assert(cs.Len, qt.Equals, 3)\n\t\t\t\t\t\tc.Assert(root.Prev, qt.IsNil)\n\t\t\t\t\t\tc.Assert(root.Next, notNil)\n\t\t\t\t\t\tc.Assert(root.Col.Min, qt.Equals, 1)\n\t\t\t\t\t\tc.Assert(root.Col.Max, qt.Equals, 1)\n\t\t\t\t\t\tnode2 := root.Next\n\t\t\t\t\t\tc.Assert(node2.Prev, qt.Equals, root)\n\t\t\t\t\t\tc.Assert(node2.Next, notNil)\n\t\t\t\t\t\tc.Assert(node2.Col.Min, qt.Equals, 2)\n\t\t\t\t\t\tc.Assert(node2.Col.Max, qt.Equals, 7)\n\t\t\t\t\t\tnode3 := node2.Next\n\t\t\t\t\t\tc.Assert(node3.Prev, qt.Equals, node2)\n\t\t\t\t\t\tc.Assert(node3.Next, qt.IsNil)\n\t\t\t\t\t\tc.Assert(node3.Col.Min, qt.Equals, 8)\n\t\t\t\t\t\tc.Assert(node3.Col.Max, qt.Equals, 9)\n\t\t\t\t})\n\n\t\t// Col1: |--|\n\t\t// Col2:        |x-|\n\t\t// Col3:    |-----|\n\t\tassertWayMade([]*Col{\n\t\t\t\t{Min: 1, Max: 2}, {Min: 8, Max: 9}, {Min: 3, Max: 8}},\n\t\t\t\tfunc(cs *ColStore) {\n\t\t\t\t\t\troot := cs.Root\n\t\t\t\t\t\tc.Assert(cs.Len, qt.Equals, 3)\n\t\t\t\t\t\tc.Assert(root.Prev, qt.IsNil)\n\t\t\t\t\t\tc.Assert(root.Next, notNil)\n\t\t\t\t\t\tc.Assert(root.Col.Min, qt.Equals, 1)\n\t\t\t\t\t\tc.Assert(root.Col.Max, qt.Equals, 2)\n\t\t\t\t\t\tnode2 := root.Next\n\t\t\t\t\t\tc.Assert(node2.Prev, qt.Equals, root)\n\t\t\t\t\t\tc.Assert(node2.Next, notNil)\n\t\t\t\t\t\tc.Assert(node2.Col.Min, qt.Equals, 3)\n\t\t\t\t\t\tc.Assert(node2.Col.Max, qt.Equals, 8)\n\t\t\t\t\t\tnode3 := node2.Next\n\t\t\t\t\t\tc.Assert(node3.Prev, qt.Equals, node2)\n\t\t\t\t\t\tc.Assert(node3.Next, qt.IsNil)\n\t\t\t\t\t\tc.Assert(node3.Col.Min, qt.Equals, 9)\n\t\t\t\t\t\tc.Assert(node3.Col.Max, qt.Equals, 9)\n\t\t\t\t})\n\n\t\t// Col1: |--|\n\t\t// Col2:   |xx|\n\t\t// Col3:     |--|\n\t\t// Col4:   |--|\n\t\tassertWayMade(\n\t\t\t\t[]*Col{\n\t\t\t\t\t\t{Min: 1, Max: 2},\n\t\t\t\t\t\t{Min: 3, Max: 4, Width: fPtr(1.0)},\n\t\t\t\t\t\t{Min: 5, Max: 6},\n\t\t\t\t\t\t{Min: 3, Max: 4, Width: fPtr(2.0)},\n\t\t\t\t},\n\t\t\t\tfunc(cs *ColStore) {\n\t\t\t\t\t\troot := cs.Root\n\t\t\t\t\t\tc.Assert(cs.Len, qt.Equals, 3)\n\t\t\t\t\t\tc.Assert(root.Prev, qt.IsNil)\n\t\t\t\t\t\tc.Assert(root.Next, notNil)\n\t\t\t\t\t\tc.Assert(root.Col.Min, qt.Equals, 1)\n\t\t\t\t\t\tc.Assert(root.Col.Max, qt.Equals, 2)\n\t\t\t\t\t\tnode2 := root.Next\n\t\t\t\t\t\tc.Assert(node2.Prev, qt.Equals, root)\n\t\t\t\t\t\tc.Assert(node2.Next, notNil)\n\t\t\t\t\t\tc.Assert(node2.Col.Min, qt.Equals, 3)\n\t\t\t\t\t\tc.Assert(node2.Col.Max, qt.Equals, 4)\n\t\t\t\t\t\tc.Assert(*node2.Col.Width, qt.Equals, 2.0) // We have the later version\n\t\t\t\t\t\tnode3 := node2.Next\n\t\t\t\t\t\tc.Assert(node3.Prev, qt.Equals, node2)\n\t\t\t\t\t\tc.Assert(node3.Next, qt.IsNil)\n\t\t\t\t\t\tc.Assert(node3.Col.Min, qt.Equals, 5)\n\t\t\t\t\t\tc.Assert(node3.Col.Max, qt.Equals, 6)\n\t\t\t\t})\n\n\t\t// Col1: |-x|\n\t\t// Col2:   |xx|\n\t\t// Col3:     |x-|\n\t\t// Col4:  |----|\n\t\tassertWayMade(\n\t\t\t\t[]*Col{\n\t\t\t\t\t\t{Min: 1, Max: 2, Width: fPtr(1.0)},\n\t\t\t\t\t\t{Min: 3, Max: 4, Width: fPtr(2.0)},\n\t\t\t\t\t\t{Min: 5, Max: 6, Width: fPtr(3.0)},\n\t\t\t\t\t\t{Min: 2, Max: 5, Width: fPtr(4.0)},\n\t\t\t\t},\n\t\t\t\tfunc(cs *ColStore) {\n\t\t\t\t\t\troot := cs.Root\n\t\t\t\t\t\tc.Assert(cs.Len, qt.Equals, 3)\n\t\t\t\t\t\tc.Assert(root.Prev, qt.IsNil)\n\t\t\t\t\t\tc.Assert(root.Next, notNil)\n\t\t\t\t\t\tc.Assert(root.Col.Min, qt.Equals, 1)\n\t\t\t\t\t\tc.Assert(root.Col.Max, qt.Equals, 1)\n\t\t\t\t\t\tc.Assert(*root.Col.Width, qt.Equals, 1.0)\n\t\t\t\t\t\tnode2 := root.Next\n\t\t\t\t\t\tc.Assert(node2.Prev, qt.Equals, root)\n\t\t\t\t\t\tc.Assert(node2.Next, notNil)\n\t\t\t\t\t\tc.Assert(node2.Col.Min, qt.Equals, 2)\n\t\t\t\t\t\tc.Assert(node2.Col.Max, qt.Equals, 5)\n\t\t\t\t\t\tc.Assert(*node2.Col.Width, qt.Equals, 4.0)\n\t\t\t\t\t\tnode3 := node2.Next\n\t\t\t\t\t\tc.Assert(node3.Prev, qt.Equals, node2)\n\t\t\t\t\t\tc.Assert(node3.Next, qt.IsNil)\n\t\t\t\t\t\tc.Assert(node3.Col.Min, qt.Equals, 6)\n\t\t\t\t\t\tc.Assert(node3.Col.Max, qt.Equals, 6)\n\t\t\t\t\t\tc.Assert(*node3.Col.Width, qt.Equals, 3.0)\n\t\t\t\t})\n\n}\n\nfunc TestFindNodeForCol(t *testing.T) {\n\t\tc := qt.New(t)\n\n\t\tassertNodeFound := func(cs *ColStore, num int, col *Col) {\n\t\t\t\tnode := cs.findNodeForColNum(num)\n\t\t\t\tif col == nil {\n\t\t\t\t\t\tc.Assert(node, qt.IsNil)\n\t\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tc.Assert(node, qt.IsNotNil)\n\t\t\t\tc.Assert(node.Col, qt.Equals, col)\n\t\t}\n\n\t\tcs := &ColStore{}\n\t\tcol0 := &Col{Min: 1, Max: 1}\n\t\tcs.Add(col0)\n\t\tcol1 := &Col{Min: 2, Max: 2}\n\t\tcs.Add(col1)\n\t\tcol2 := &Col{Min: 3, Max: 3}\n\t\tcs.Add(col2)\n\t\tcol3 := &Col{Min: 4, Max: 4}\n\t\tcs.Add(col3)\n\t\tcol4 := &Col{Min: 5, Max: 5}\n\t\tcs.Add(col4)\n\t\tcol5 := &Col{Min: 100, Max: 125}\n\t\tcs.Add(col5)\n\n\t\tassertNodeFound(cs, 0, nil)\n\t\tassertNodeFound(cs, 1, col0)\n\t\tassertNodeFound(cs, 2, col1)\n\t\tassertNodeFound(cs, 3, col2)\n\t\tassertNodeFound(cs, 4, col3)\n\t\tassertNodeFound(cs, 5, col4)\n\t\tassertNodeFound(cs, 6, nil)\n\t\tassertNodeFound(cs, 99, nil)\n\t\tassertNodeFound(cs, 100, col5)\n\t\tassertNodeFound(cs, 110, col5)\n\t\tassertNodeFound(cs, 125, col5)\n\t\tassertNodeFound(cs, 126, nil)\n}\n\nfunc TestRemoveNode(t *testing.T) {\n\t\tc := qt.New(t)\n\n\t\tassertChain := func(cs *ColStore, chain []*Col) {\n\t\t\t\tnode := cs.Root\n\t\t\t\tfor _, col := range chain {\n\t\t\t\t\t\tc.Assert(node, qt.IsNotNil)\n\t\t\t\t\t\tc.Assert(node.Col.Min, qt.Equals, col.Min)\n\t\t\t\t\t\tc.Assert(node.Col.Max, qt.Equals, col.Max)\n\t\t\t\t\t\tnode = node.Next\n\t\t\t\t}\n\t\t\t\tc.Assert(node, qt.IsNil)\n\t\t}\n\n\t\tcs := &ColStore{}\n\t\tcol0 := &Col{Min: 1, Max: 1}\n\t\tcs.Add(col0)\n\t\tcol1 := &Col{Min: 2, Max: 2}\n\t\tcs.Add(col1)\n\t\tcol2 := &Col{Min: 3, Max: 3}\n\t\tcs.Add(col2)\n\t\tcol3 := &Col{Min: 4, Max: 4}\n\t\tcs.Add(col3)\n\t\tcol4 := &Col{Min: 5, Max: 5}\n\t\tcs.Add(col4)\n\t\tc.Assert(cs.Len, qt.Equals, 5)\n\n\t\tcs.removeNode(cs.findNodeForColNum(5))\n\t\tc.Assert(cs.Len, qt.Equals, 4)\n\t\tassertChain(cs, []*Col{col0, col1, col2, col3})\n\n\t\tcs.removeNode(cs.findNodeForColNum(1))\n\t\tc.Assert(cs.Len, qt.Equals, 3)\n\t\tassertChain(cs, []*Col{col1, col2, col3})\n}\n\nfunc TestForEach(t *testing.T) {\n\t\tc := qt.New(t)\n\t\tcs := &ColStore{}\n\t\tcol0 := &Col{Min: 1, Max: 1, Hidden: bPtr(true)}\n\t\tcs.Add(col0)\n\t\tcol1 := &Col{Min: 2, Max: 2}\n\t\tcs.Add(col1)\n\t\tcol2 := &Col{Min: 3, Max: 3}\n\t\tcs.Add(col2)\n\t\tcol3 := &Col{Min: 4, Max: 4}\n\t\tcs.Add(col3)\n\t\tcol4 := &Col{Min: 5, Max: 5}\n\t\tcs.Add(col4)\n\t\tcs.ForEach(func(index int, col *Col) {\n\t\t\t\tcol.Phonetic = bPtr(true)\n\t\t})\n\n\t\tc.Assert(*col0.Phonetic, qt.Equals, true)\n\t\tc.Assert(*col1.Phonetic, qt.Equals, true)\n\t\tc.Assert(*col2.Phonetic, qt.Equals, true)\n\t\tc.Assert(*col3.Phonetic, qt.Equals, true)\n\t\tc.Assert(*col4.Phonetic, qt.Equals, true)\n}\n\nfunc TestGetOrMakeColsForRange(t *testing.T) {\n\t\tc := qt.New(t)\n\t\tassertCols := func(min, max int, initalCols, expectedCols []*Col) {\n\t\t\t\tcs := &ColStore{}\n\t\t\t\tfor _, col := range initalCols {\n\t\t\t\t\t\tcs.Add(col)\n\t\t\t\t}\n\t\t\t\tresult := cs.getOrMakeColsForRange(cs.Root, min, max)\n\t\t\t\tc.Assert(result, qt.HasLen, len(expectedCols))\n\t\t\t\tfor i := 0; i < len(expectedCols); i++ {\n\t\t\t\t\t\tgot := result[i]\n\t\t\t\t\t\texpected := expectedCols[i]\n\t\t\t\t\t\tc.Assert(got.Min, qt.Equals, expected.Min)\n\t\t\t\t\t\tc.Assert(got.Max, qt.Equals, expected.Max)\n\t\t\t\t}\n\t\t}\n\n\t\t// make everything\n\t\tassertCols(1, 11, nil, []*Col{{Min: 1, Max: 11}})\n\n\t\t// get everything, one col\n\t\tassertCols(1, 11, []*Col{{Min: 1, Max: 11}}, []*Col{{Min: 1, Max: 11}})\n\n\t\t// get everything, many cols\n\t\tassertCols(1, 11,\n\t\t\t\t[]*Col{\n\t\t\t\t\t\t{Min: 1, Max: 4},\n\t\t\t\t\t\t{Min: 5, Max: 8},\n\t\t\t\t\t\t{Min: 9, Max: 11},\n\t\t\t\t},\n\t\t\t\t[]*Col{\n\t\t\t\t\t\t{Min: 1, Max: 4},\n\t\t\t\t\t\t{Min: 5, Max: 8},\n\t\t\t\t\t\t{Min: 9, Max: 11},\n\t\t\t\t},\n\t\t)\n\n\t\t// make missing col\n\t\tassertCols(1, 11,\n\t\t\t\t[]*Col{\n\t\t\t\t\t\t{Min: 1, Max: 4},\n\t\t\t\t\t\t{Min: 9, Max: 11},\n\t\t\t\t},\n\t\t\t\t[]*Col{\n\t\t\t\t\t\t{Min: 1, Max: 4},\n\t\t\t\t\t\t{Min: 5, Max: 8},\n\t\t\t\t\t\t{Min: 9, Max: 11},\n\t\t\t\t},\n\t\t)\n\n}\n"
        },
        {
          "name": "compatibility_test.go",
          "type": "blob",
          "size": 2.9052734375,
          "content": "package xlsx\n\nimport (\n\t\"testing\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\n// Test that we can successfully read an XLSX file generated by\n// Google Docs.\nfunc TestGoogleDocsExcel(t *testing.T) {\n\tc := qt.New(t)\n\tcsRunO(c, \"OpenExcel\", func(c *qt.C, option FileOption) {\n\t\txlsxFile, err := OpenFile(\"./testdocs/googleDocsTest.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(xlsxFile, qt.Not(qt.IsNil))\n\t})\n}\n\n// Test that we can successfully read an XLSX file generated by\n// Microsoft Excel for Mac.  In particular this requires that we\n// respect the contents of workbook.xml.rels, which maps the sheet IDs\n// to their internal file names.\nfunc TestMacExcel(t *testing.T) {\n\tc := qt.New(t)\n\tcsRunO(c, \"OpenMacExcel\", func(c *qt.C, option FileOption) {\n\t\txlsxFile, err := OpenFile(\"./testdocs/macExcelTest.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(xlsxFile, qt.Not(qt.IsNil))\n\t\tsheet, ok := xlsxFile.Sheet[\"普通技能\"]\n\t\tc.Assert(ok, qt.Equals, true)\n\n\t\tdefer sheet.Close()\n\t\tcell, err := sheet.Cell(0, 0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tif val, err := cell.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"编号\")\n\t\t}\n\t})\n}\n\n// Test that we can successfully read an XLSX file generated by\n// Numbers for Mac.\nfunc TestMacNumbers(t *testing.T) {\n\tc := qt.New(t)\n\tcsRunO(c, \"OpenMacNumbers\", func(c *qt.C, option FileOption) {\n\t\txlsxFile, err := OpenFile(\"./testdocs/macNumbersTest.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(xlsxFile, qt.Not(qt.IsNil))\n\t\tsheet, ok := xlsxFile.Sheet[\"主动技能\"]\n\t\tc.Assert(ok, qt.Equals, true)\n\t\tdefer sheet.Close()\n\t\tcell, err := sheet.Cell(0, 0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tif val, err := cell.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"编号\")\n\t\t}\n\t})\n}\n\n// Test that we can successfully read an XLSX file generated by\n// Wps on windows. you can download it freely from http://www.wps.cn/\nfunc TestWpsBlankLine(t *testing.T) {\n\tc := qt.New(t)\n\tcsRunO(c, \"OpenWps\", func(c *qt.C, option FileOption) {\n\t\txlsxFile, err := OpenFile(\"./testdocs/wpsBlankLineTest.xlsx\", option)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(xlsxFile, qt.Not(qt.IsNil))\n\t\tsheet := xlsxFile.Sheet[\"Sheet1\"]\n\t\trow, err := sheet.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tcell := row.GetCell(0)\n\n\t\texpected := \"编号\"\n\t\tvar val string\n\n\t\tif val, err = cell.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t}\n\t\tc.Assert(val, qt.Equals, expected)\n\n\t\trow, err = sheet.Row(2)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tcell = row.GetCell(0)\n\t\tif val, err = cell.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t}\n\t\tc.Assert(val, qt.Equals, expected)\n\n\t\trow, err = sheet.Row(4)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tcell = row.GetCell(1)\n\t\tif val, err = cell.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t}\n\t\tc.Assert(val, qt.Equals, \"\")\n\n\t\tif val, err = row.GetCell(2).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t}\n\t\tc.Assert(val, qt.Equals, expected)\n\t})\n}\n"
        },
        {
          "name": "data_validation.go",
          "type": "blob",
          "size": 5.5703125,
          "content": "package xlsx\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"unicode/utf8\"\n)\n\ntype DataValidationType int\n\n// Data validation types\nconst (\n\t_DataValidationType = iota\n\ttypeNone            //inline use\n\tDataValidationTypeCustom\n\tDataValidationTypeDate\n\tDataValidationTypeDecimal\n\tdataValidationTypeList //inline use\n\tDataValidationTypeTextLeng\n\tDataValidationTypeTime\n\t// DataValidationTypeWhole Integer\n\tDataValidationTypeWhole\n)\n\nconst (\n\t// dataValidationFormulaStrLen 255 runes + 2 quotes\n\tdataValidationFormulaStrLen = 257\n\t// dataValidationFormulaStrLenErr\n\tdataValidationFormulaStrLenErr = \"data validation must be 0-255 runes\"\n)\n\ntype DataValidationErrorStyle int\n\n// Data validation error styles\nconst (\n\t_ DataValidationErrorStyle = iota\n\tStyleStop\n\tStyleWarning\n\tStyleInformation\n)\n\n// Data validation error styles\nconst (\n\tstyleStop        = \"stop\"\n\tstyleWarning     = \"warning\"\n\tstyleInformation = \"information\"\n)\n\n// DataValidationOperator operator enum\ntype DataValidationOperator int\n\n// Data validation operators\nconst (\n\t_DataValidationOperator = iota\n\tDataValidationOperatorBetween\n\tDataValidationOperatorEqual\n\tDataValidationOperatorGreaterThan\n\tDataValidationOperatorGreaterThanOrEqual\n\tDataValidationOperatorLessThan\n\tDataValidationOperatorLessThanOrEqual\n\tDataValidationOperatorNotBetween\n\tDataValidationOperatorNotEqual\n)\n\n// NewDataValidation return data validation struct\nfunc NewDataValidation(startRow, startCol, endRow, endCol int, allowBlank bool) *xlsxDataValidation {\n\tstartX := ColIndexToLetters(startCol)\n\tstartY := RowIndexToString(startRow)\n\tendX := ColIndexToLetters(endCol)\n\tendY := RowIndexToString(endRow)\n\n\tsqref := startX + startY\n\tif startX != endX || startY != endY {\n\t\tsqref += \":\" + endX + endY\n\t}\n\treturn &xlsxDataValidation{\n\t\tAllowBlank: allowBlank,\n\t\tSqref:      sqref,\n\t}\n}\n\n// SetError set error notice\nfunc (dd *xlsxDataValidation) SetError(style DataValidationErrorStyle, title, msg *string) {\n\tdd.ShowErrorMessage = true\n\tdd.Error = msg\n\tdd.ErrorTitle = title\n\tstrStyle := styleStop\n\tswitch style {\n\tcase StyleStop:\n\t\tstrStyle = styleStop\n\tcase StyleWarning:\n\t\tstrStyle = styleWarning\n\tcase StyleInformation:\n\t\tstrStyle = styleInformation\n\n\t}\n\tdd.ErrorStyle = &strStyle\n}\n\n// SetInput set prompt notice\nfunc (dd *xlsxDataValidation) SetInput(title, msg *string) {\n\tdd.ShowInputMessage = true\n\tdd.PromptTitle = title\n\tdd.Prompt = msg\n}\n\n// SetDropList sets a hard coded list of values that the drop down will choose from.\n// List validations do not work in Apple Numbers.\nfunc (dd *xlsxDataValidation) SetDropList(keys []string) error {\n\tformula := \"\\\"\" + strings.Join(keys, \",\") + \"\\\"\"\n\tif dataValidationFormulaStrLen < utf8.RuneCountInString(formula) {\n\t\treturn errors.New(dataValidationFormulaStrLenErr)\n\t}\n\tdd.Formula1 = formula\n\tdd.Type = convDataValidationType(dataValidationTypeList)\n\treturn nil\n}\n\n// SetInFileList is like SetDropList, excel that instead of having a hard coded list,\n// a reference to a part of the file is accepted and the list is automatically taken from there.\n// Setting y2 to -1 will select all the way to the end of the column. Selecting to the end of the\n// column will cause Google Sheets to spin indefinitely while trying to load the possible drop down\n// values (more than 5 minutes).\n// List validations do not work in Apple Numbers.\nfunc (dd *xlsxDataValidation) SetInFileList(sheet string, x1, y1, x2, y2 int) error {\n\tstart := GetCellIDStringFromCoordsWithFixed(x1, y1, true, true)\n\tif y2 < 0 {\n\t\ty2 = Excel2006MaxRowIndex\n\t}\n\n\tend := GetCellIDStringFromCoordsWithFixed(x2, y2, true, true)\n\t// Escape single quotes in the file name.\n\t// Single quotes are escaped by replacing them with two single quotes.\n\tsheet = strings.Replace(sheet, \"'\", \"''\", -1)\n\tformula := \"'\" + sheet + \"'\" + externalSheetBangChar + start + cellRangeChar + end\n\tdd.Formula1 = formula\n\tdd.Type = convDataValidationType(dataValidationTypeList)\n\treturn nil\n}\n\n// SetDropList data validation range\nfunc (dd *xlsxDataValidation) SetRange(f1, f2 int, t DataValidationType, o DataValidationOperator) error {\n\tformula1 := fmt.Sprintf(\"%d\", f1)\n\tformula2 := fmt.Sprintf(\"%d\", f2)\n\n\tswitch o {\n\tcase DataValidationOperatorBetween:\n\t\tif f1 > f2 {\n\t\t\ttmp := formula1\n\t\t\tformula1 = formula2\n\t\t\tformula2 = tmp\n\t\t}\n\tcase DataValidationOperatorNotBetween:\n\t\tif f1 > f2 {\n\t\t\ttmp := formula1\n\t\t\tformula1 = formula2\n\t\t\tformula2 = tmp\n\t\t}\n\t}\n\n\tdd.Formula1 = formula1\n\tdd.Formula2 = formula2\n\tdd.Type = convDataValidationType(t)\n\tdd.Operator = convDataValidationOperatior(o)\n\treturn nil\n}\n\n// convDataValidationType get excel data validation type\nfunc convDataValidationType(t DataValidationType) string {\n\ttypeMap := map[DataValidationType]string{\n\t\ttypeNone:                   \"none\",\n\t\tDataValidationTypeCustom:   \"custom\",\n\t\tDataValidationTypeDate:     \"date\",\n\t\tDataValidationTypeDecimal:  \"decimal\",\n\t\tdataValidationTypeList:     \"list\",\n\t\tDataValidationTypeTextLeng: \"textLength\",\n\t\tDataValidationTypeTime:     \"time\",\n\t\tDataValidationTypeWhole:    \"whole\",\n\t}\n\n\treturn typeMap[t]\n\n}\n\n// convDataValidationOperatior get excel data validation operator\nfunc convDataValidationOperatior(o DataValidationOperator) string {\n\ttypeMap := map[DataValidationOperator]string{\n\t\tDataValidationOperatorBetween:            \"between\",\n\t\tDataValidationOperatorEqual:              \"equal\",\n\t\tDataValidationOperatorGreaterThan:        \"greaterThan\",\n\t\tDataValidationOperatorGreaterThanOrEqual: \"greaterThanOrEqual\",\n\t\tDataValidationOperatorLessThan:           \"lessThan\",\n\t\tDataValidationOperatorLessThanOrEqual:    \"lessThanOrEqual\",\n\t\tDataValidationOperatorNotBetween:         \"notBetween\",\n\t\tDataValidationOperatorNotEqual:           \"notEqual\",\n\t}\n\n\treturn typeMap[o]\n\n}\n"
        },
        {
          "name": "data_validation_test.go",
          "type": "blob",
          "size": 8.1982421875,
          "content": "package xlsx\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\nfunc TestDataValidation(t *testing.T) {\n\n\tc := qt.New(t)\n\n\tcsRunO(c, \"DataValidation\", func(c *qt.C, option FileOption) {\n\t\tvar file *File\n\t\tvar sheet *Sheet\n\t\tvar row *Row\n\t\tvar cell *Cell\n\t\tvar err error\n\t\tvar title = \"cell\"\n\t\tvar msg = \"cell msg\"\n\n\t\tfile = NewFile(option)\n\t\tsheet, err = file.AddSheet(\"Sheet1\")\n\t\tc.Assert(err, qt.Equals, nil)\n\t\trow = sheet.AddRow()\n\t\tcell = row.AddCell()\n\t\tcell.Value = \"a1\"\n\n\t\tdd := NewDataValidation(0, 0, 0, 0, true)\n\t\terr = dd.SetDropList([]string{\"a1\", \"a2\", \"a3\"})\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tdd.SetInput(&title, &msg)\n\t\tcell.SetDataValidation(dd)\n\n\t\tdd = NewDataValidation(2, 0, 2, 0, true)\n\t\terr = dd.SetDropList([]string{\"c1\", \"c2\", \"c3\"})\n\t\tc.Assert(err, qt.IsNil)\n\t\ttitle = \"col c\"\n\t\tdd.SetInput(&title, &msg)\n\t\tsheet.AddDataValidation(dd)\n\n\t\tdd = NewDataValidation(3, 3, 3, 7, true)\n\t\terr = dd.SetDropList([]string{\"d\", \"d1\", \"d2\"})\n\t\tc.Assert(err, qt.IsNil)\n\t\ttitle = \"col d range\"\n\t\tdd.SetInput(&title, &msg)\n\t\tsheet.AddDataValidation(dd)\n\n\t\tdd = NewDataValidation(4, 1, 4, Excel2006MaxRowIndex, true)\n\t\terr = dd.SetDropList([]string{\"e1\", \"e2\", \"e3\"})\n\t\tc.Assert(err, qt.IsNil)\n\t\ttitle = \"col e start 3\"\n\t\tdd.SetInput(&title, &msg)\n\t\tsheet.AddDataValidation(dd)\n\n\t\tindex := 5\n\t\trowIndex := 1\n\t\tdd = NewDataValidation(rowIndex, index, rowIndex, index, true)\n\t\terr = dd.SetRange(15, 4, DataValidationTypeTextLeng, DataValidationOperatorBetween)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tindex++\n\n\t\tdd = NewDataValidation(rowIndex, index, rowIndex, index, true)\n\t\terr = dd.SetRange(10, 1, DataValidationTypeTextLeng, DataValidationOperatorEqual)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tindex++\n\n\t\tdd = NewDataValidation(rowIndex, index, rowIndex, index, true)\n\t\terr = dd.SetRange(10, 1, DataValidationTypeTextLeng, DataValidationOperatorGreaterThanOrEqual)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tindex++\n\n\t\tdd = NewDataValidation(rowIndex, index, rowIndex, index, true)\n\t\terr = dd.SetRange(10, 1, DataValidationTypeTextLeng, DataValidationOperatorGreaterThan)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tindex++\n\n\t\tdd = NewDataValidation(rowIndex, index, rowIndex, index, true)\n\t\terr = dd.SetRange(10, 1, DataValidationTypeTextLeng, DataValidationOperatorLessThan)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tindex++\n\n\t\tdd = NewDataValidation(rowIndex, index, rowIndex, index, true)\n\t\terr = dd.SetRange(10, 1, DataValidationTypeTextLeng, DataValidationOperatorLessThanOrEqual)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tindex++\n\n\t\tdd = NewDataValidation(rowIndex, index, rowIndex, index, true)\n\t\terr = dd.SetRange(10, 1, DataValidationTypeTextLeng, DataValidationOperatorNotEqual)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tindex++\n\n\t\tdd = NewDataValidation(rowIndex, index, rowIndex, index, true)\n\t\terr = dd.SetRange(10, 1, DataValidationTypeTextLeng, DataValidationOperatorNotBetween)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tindex++\n\n\t\trowIndex++\n\t\tindex = 5\n\n\t\tdd = NewDataValidation(rowIndex, index, rowIndex, index, true)\n\t\terr = dd.SetRange(4, 15, DataValidationTypeWhole, DataValidationOperatorBetween)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tindex++\n\n\t\tdd = NewDataValidation(rowIndex, index, rowIndex, index, true)\n\t\terr = dd.SetRange(10, 1, DataValidationTypeWhole, DataValidationOperatorEqual)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tindex++\n\n\t\tdd = NewDataValidation(rowIndex, index, rowIndex, index, true)\n\t\terr = dd.SetRange(10, 1, DataValidationTypeWhole, DataValidationOperatorGreaterThanOrEqual)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tindex++\n\n\t\tdd = NewDataValidation(rowIndex, index, rowIndex, index, true)\n\t\terr = dd.SetRange(10, 1, DataValidationTypeWhole, DataValidationOperatorGreaterThan)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tindex++\n\n\t\tdd = NewDataValidation(rowIndex, index, rowIndex, index, true)\n\t\terr = dd.SetRange(10, 1, DataValidationTypeWhole, DataValidationOperatorLessThan)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tindex++\n\n\t\tdd = NewDataValidation(rowIndex, index, rowIndex, index, true)\n\t\terr = dd.SetRange(10, 1, DataValidationTypeWhole, DataValidationOperatorLessThanOrEqual)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tindex++\n\n\t\tdd = NewDataValidation(rowIndex, index, rowIndex, index, true)\n\t\terr = dd.SetRange(10, 1, DataValidationTypeWhole, DataValidationOperatorNotEqual)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tindex++\n\n\t\tdd = NewDataValidation(rowIndex, index, rowIndex, index, true)\n\t\terr = dd.SetRange(10, 50, DataValidationTypeWhole, DataValidationOperatorNotBetween)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tsheet.AddDataValidation(dd)\n\t\tindex++\n\n\t\tdd = NewDataValidation(12, 2, 12, 10, true)\n\t\terr = dd.SetDropList([]string{\"1\", \"2\", \"4\"})\n\t\tc.Assert(err, qt.IsNil)\n\t\tdd1 := NewDataValidation(12, 3, 12, 4, true)\n\t\terr = dd1.SetDropList([]string{\"11\", \"22\", \"44\"})\n\t\tc.Assert(err, qt.IsNil)\n\t\tdd2 := NewDataValidation(12, 5, 12, 7, true)\n\t\terr = dd2.SetDropList([]string{\"111\", \"222\", \"444\"})\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tsheet.AddDataValidation(dd1)\n\t\tsheet.AddDataValidation(dd2)\n\n\t\tdd = NewDataValidation(13, 2, 13, 10, true)\n\t\terr = dd.SetDropList([]string{\"1\", \"2\", \"4\"})\n\t\tc.Assert(err, qt.IsNil)\n\t\tdd1 = NewDataValidation(13, 1, 13, 2, true)\n\t\terr = dd1.SetDropList([]string{\"11\", \"22\", \"44\"})\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tsheet.AddDataValidation(dd1)\n\n\t\tdd = NewDataValidation(14, 2, 14, 10, true)\n\t\terr = dd.SetDropList([]string{\"1\", \"2\", \"4\"})\n\t\tc.Assert(err, qt.IsNil)\n\t\tdd1 = NewDataValidation(14, 1, 14, 5, true)\n\t\terr = dd1.SetDropList([]string{\"11\", \"22\", \"44\"})\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tsheet.AddDataValidation(dd1)\n\n\t\tdd = NewDataValidation(15, 2, 15, 10, true)\n\t\terr = dd.SetDropList([]string{\"1\", \"2\", \"4\"})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdd1 = NewDataValidation(15, 1, 15, 10, true)\n\t\terr = dd1.SetDropList([]string{\"11\", \"22\", \"44\"})\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tsheet.AddDataValidation(dd1)\n\n\t\tdd = NewDataValidation(16, 10, 16, 20, true)\n\t\terr = dd.SetDropList([]string{\"1\", \"2\", \"4\"})\n\t\tc.Assert(err, qt.IsNil)\n\t\tdd1 = NewDataValidation(16, 2, 16, 4, true)\n\t\terr = dd1.SetDropList([]string{\"11\", \"22\", \"44\"})\n\t\tc.Assert(err, qt.IsNil)\n\t\tdd2 = NewDataValidation(16, 12, 16, 30, true)\n\t\terr = dd2.SetDropList([]string{\"111\", \"222\", \"444\"})\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet.AddDataValidation(dd)\n\t\tsheet.AddDataValidation(dd1)\n\t\tsheet.AddDataValidation(dd2)\n\n\t\tdd = NewDataValidation(3, 3, 3, Excel2006MaxRowIndex, true)\n\t\terr = dd.SetDropList([]string{\"d\", \"d1\", \"d2\"})\n\t\tc.Assert(err, qt.IsNil)\n\t\ttitle = \"col d range\"\n\t\tdd.SetInput(&title, &msg)\n\t\tsheet.AddDataValidation(dd)\n\n\t\tdd = NewDataValidation(3, 4, 3, Excel2006MaxRowIndex, true)\n\t\terr = dd.SetDropList([]string{\"d\", \"d1\", \"d2\"})\n\t\tc.Assert(err, qt.IsNil)\n\t\ttitle = \"col d range\"\n\t\tdd.SetInput(&title, &msg)\n\t\tsheet.AddDataValidation(dd)\n\n\t\tdest := &bytes.Buffer{}\n\t\terr = file.Write(dest)\n\t\tc.Assert(err, qt.IsNil)\n\t\t// Read and write the file that was just saved.\n\t\tfile, err = OpenBinary(dest.Bytes())\n\t\tc.Assert(err, qt.IsNil)\n\t\tdest = &bytes.Buffer{}\n\t\terr = file.Write(dest)\n\t\tc.Assert(err, qt.IsNil)\n\t})\n\n\tc.Run(\"DataValidation2\", func(c *qt.C) {\n\t\t// Show error and show info start disabled, but automatically get enabled when setting a message\n\t\tdd := NewDataValidation(0, 0, 0, 0, true)\n\t\tc.Assert(dd.ShowErrorMessage, qt.Equals, false)\n\t\tc.Assert(dd.ShowInputMessage, qt.Equals, false)\n\n\t\tstr := \"you got an error\"\n\t\tdd.SetError(StyleStop, &str, &str)\n\t\tc.Assert(dd.ShowErrorMessage, qt.Equals, true)\n\t\tc.Assert(dd.ShowInputMessage, qt.Equals, false)\n\n\t\tstr = \"hello\"\n\t\tdd.SetInput(&str, &str)\n\t\tc.Assert(dd.ShowInputMessage, qt.Equals, true)\n\n\t\t// Check the formula created by this function\n\t\t// The sheet name needs single quotes, the single quote in the name gets escaped,\n\t\t// and all references are fixed.\n\t\terr := dd.SetInFileList(\"Sheet ' 2\", 2, 1, 3, 10)\n\t\tc.Assert(err, qt.IsNil)\n\t\texpectedFormula := \"'Sheet '' 2'!$C$2:$D$11\"\n\t\tc.Assert(dd.Formula1, qt.Equals, expectedFormula)\n\t\tc.Assert(dd.Type, qt.Equals, \"list\")\n\t})\n}\n"
        },
        {
          "name": "date.go",
          "type": "blob",
          "size": 4.962890625,
          "content": "package xlsx\n\nimport (\n\t\"math\"\n\t\"time\"\n)\n\nconst (\n\tMJD_0      float64 = 2400000.5\n\tMJD_JD2000 float64 = 51544.5\n\n\tsecondsInADay = float64((24 * time.Hour) / time.Second)\n\tnanosInADay   = float64((24 * time.Hour) / time.Nanosecond)\n)\n\nvar (\n\ttimeLocationUTC, _ = time.LoadLocation(\"UTC\")\n\n\tunixEpoc = time.Date(1970, time.January, 1, 0, 0, 0, 0, time.UTC)\n\t// In 1900 mode, Excel takes dates in floating point numbers of days starting with Jan 1 1900.\n\t// The days are not zero indexed, so Jan 1 1900 would be 1.\n\t// Except that Excel pretends that Feb 29, 1900 occurred to be compatible with a bug in Lotus 123.\n\t// So, this constant uses Dec 30, 1899 instead of Jan 1, 1900, so the diff will be correct.\n\t// http://www.cpearson.com/excel/datetime.htm\n\texcel1900Epoc = time.Date(1899, time.December, 30, 0, 0, 0, 0, time.UTC)\n\texcel1904Epoc = time.Date(1904, time.January, 1, 0, 0, 0, 0, time.UTC)\n\t// Days between epocs, including both off by one errors for 1900.\n\tdaysBetween1970And1900 = float64(unixEpoc.Sub(excel1900Epoc) / (24 * time.Hour))\n\tdaysBetween1970And1904 = float64(unixEpoc.Sub(excel1904Epoc) / (24 * time.Hour))\n)\n\nfunc TimeToUTCTime(t time.Time) time.Time {\n\treturn time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second(), t.Nanosecond(), timeLocationUTC)\n}\n\nfunc shiftJulianToNoon(julianDays, julianFraction float64) (float64, float64) {\n\tswitch {\n\tcase -0.5 < julianFraction && julianFraction < 0.5:\n\t\tjulianFraction += 0.5\n\tcase julianFraction >= 0.5:\n\t\tjulianDays += 1\n\t\tjulianFraction -= 0.5\n\tcase julianFraction <= -0.5:\n\t\tjulianDays -= 1\n\t\tjulianFraction += 1.5\n\t}\n\treturn julianDays, julianFraction\n}\n\n// Return the integer values for hour, minutes, seconds and\n// nanoseconds that comprised a given fraction of a day.\n// values would round to 1 us.\nfunc fractionOfADay(fraction float64) (hours, minutes, seconds, nanoseconds int) {\n\n\tconst (\n\t\tc1us  = 1e3\n\t\tc1s   = 1e9\n\t\tc1day = 24 * 60 * 60 * c1s\n\t)\n\n\tfrac := int64(c1day*fraction + c1us/2)\n\tnanoseconds = int((frac%c1s)/c1us) * c1us\n\tfrac /= c1s\n\tseconds = int(frac % 60)\n\tfrac /= 60\n\tminutes = int(frac % 60)\n\thours = int(frac / 60)\n\treturn\n}\n\nfunc julianDateToGregorianTime(part1, part2 float64) time.Time {\n\tpart1I, part1F := math.Modf(part1)\n\tpart2I, part2F := math.Modf(part2)\n\tjulianDays := part1I + part2I\n\tjulianFraction := part1F + part2F\n\tjulianDays, julianFraction = shiftJulianToNoon(julianDays, julianFraction)\n\tday, month, year := doTheFliegelAndVanFlandernAlgorithm(int(julianDays))\n\thours, minutes, seconds, nanoseconds := fractionOfADay(julianFraction)\n\treturn time.Date(year, time.Month(month), day, hours, minutes, seconds, nanoseconds, time.UTC)\n}\n\n// By this point generations of programmers have repeated the\n// algorithm sent to the editor of \"Communications of the ACM\" in 1968\n// (published in CACM, volume 11, number 10, October 1968, p.657).\n// None of those programmers seems to have found it necessary to\n// explain the constants or variable names set out by Henry F. Fliegel\n// and Thomas C. Van Flandern.  Maybe one day I'll buy that jounal and\n// expand an explanation here - that day is not today.\nfunc doTheFliegelAndVanFlandernAlgorithm(jd int) (day, month, year int) {\n\tl := jd + 68569\n\tn := (4 * l) / 146097\n\tl = l - (146097*n+3)/4\n\ti := (4000 * (l + 1)) / 1461001\n\tl = l - (1461*i)/4 + 31\n\tj := (80 * l) / 2447\n\td := l - (2447*j)/80\n\tl = j / 11\n\tm := j + 2 - (12 * l)\n\ty := 100*(n-49) + i + l\n\treturn d, m, y\n}\n\n// Convert an excelTime representation (stored as a floating point number) to a time.Time.\nfunc TimeFromExcelTime(excelTime float64, date1904 bool) time.Time {\n\tvar date time.Time\n\tvar wholeDaysPart = int(excelTime)\n\t// Excel uses Julian dates prior to March 1st 1900, and\n\t// Gregorian thereafter.\n\tif wholeDaysPart <= 61 {\n\t\tconst OFFSET1900 = 15018.0\n\t\tconst OFFSET1904 = 16480.0\n\t\tvar date time.Time\n\t\tif date1904 {\n\t\t\tdate = julianDateToGregorianTime(MJD_0, excelTime+OFFSET1904)\n\t\t} else {\n\t\t\tdate = julianDateToGregorianTime(MJD_0, excelTime+OFFSET1900)\n\t\t}\n\t\treturn date\n\t}\n\tvar floatPart = excelTime - float64(wholeDaysPart)\n\tif date1904 {\n\t\tdate = excel1904Epoc\n\t} else {\n\t\tdate = excel1900Epoc\n\t}\n\tdurationPart := time.Duration(nanosInADay * floatPart)\n\treturn date.AddDate(0, 0, wholeDaysPart).Add(durationPart)\n}\n\n// TimeToExcelTime will convert a time.Time into Excel's float representation, in either 1900 or 1904\n// mode. If you don't know which to use, set date1904 to false.\n// TODO should this should handle Julian dates?\nfunc TimeToExcelTime(t time.Time, date1904 bool) float64 {\n\t// Get the number of days since the unix epoc\n\tdaysSinceUnixEpoc := float64(t.Unix()) / secondsInADay\n\t// Get the number of nanoseconds in days since Unix() is in seconds.\n\tnanosPart := float64(t.Nanosecond()) / nanosInADay\n\t// Add both together plus the number of days difference between unix and Excel epocs.\n\tvar offsetDays float64\n\tif date1904 {\n\t\toffsetDays = daysBetween1970And1904\n\t} else {\n\t\toffsetDays = daysBetween1970And1900\n\t}\n\tdaysSinceExcelEpoc := daysSinceUnixEpoc + offsetDays + nanosPart\n\treturn daysSinceExcelEpoc\n}\n"
        },
        {
          "name": "date_test.go",
          "type": "blob",
          "size": 2.984375,
          "content": "package xlsx\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\nfunc TestFractionOfADay(t *testing.T) {\n\tc := qt.New(t)\n\tvar h, m, s, n int\n\th, m, s, n = fractionOfADay(0)\n\tc.Assert(h, qt.Equals, 0)\n\tc.Assert(m, qt.Equals, 0)\n\tc.Assert(s, qt.Equals, 0)\n\tc.Assert(n, qt.Equals, 0)\n\th, m, s, n = fractionOfADay(1.0 / 24.0)\n\tc.Assert(h, qt.Equals, 1)\n\tc.Assert(m, qt.Equals, 0)\n\tc.Assert(s, qt.Equals, 0)\n\tc.Assert(n, qt.Equals, 0)\n}\n\nfunc TestJulianDateToGregorianTime(t *testing.T) {\n\tc := qt.New(t)\n\tc.Assert(julianDateToGregorianTime(2400000.5, 51544.0),\n\t\tqt.Equals, time.Date(2000, 1, 1, 0, 0, 0, 0, time.UTC))\n\tc.Assert(julianDateToGregorianTime(2400000.5, 51544.5),\n\t\tqt.Equals, time.Date(2000, 1, 1, 12, 0, 0, 0, time.UTC))\n\tc.Assert(julianDateToGregorianTime(2400000.5, 51544.245),\n\t\tqt.Equals, time.Date(2000, 1, 1, 5, 52, 48, 0, time.UTC))\n\tc.Assert(julianDateToGregorianTime(2400000.5, 51544.2456),\n\t\tqt.Equals, time.Date(2000, 1, 1, 5, 53, 39, 840000000, time.UTC))\n\t/* test rounding: 0.24560789123*24*3600 = 21220.521802272 */\n\tc.Assert(julianDateToGregorianTime(2400000.5, 51544.24560789123),\n\t\tqt.Equals, time.Date(2000, 1, 1, 5, 53, 40, 521802000, time.UTC))\n\tc.Assert(julianDateToGregorianTime(2400000.5, 51544.1),\n\t\tqt.Equals, time.Date(2000, 1, 1, 2, 24, 00, 0, time.UTC))\n\tc.Assert(julianDateToGregorianTime(2400000.5, 51544.75),\n\t\tqt.Equals, time.Date(2000, 1, 1, 18, 0, 0, 0, time.UTC))\n}\n\nfunc TestTimeFromExcelTime(t *testing.T) {\n\tc := qt.New(t)\n\tdate := TimeFromExcelTime(0, false)\n\tc.Assert(date, qt.Equals, time.Date(1899, 12, 30, 0, 0, 0, 0, time.UTC))\n\tdate = TimeFromExcelTime(60, false)\n\tc.Assert(date, qt.Equals, time.Date(1900, 2, 28, 0, 0, 0, 0, time.UTC))\n\tdate = TimeFromExcelTime(61, false)\n\tc.Assert(date, qt.Equals, time.Date(1900, 3, 1, 0, 0, 0, 0, time.UTC))\n\tdate = TimeFromExcelTime(41275.0, false)\n\tc.Assert(date, qt.Equals, time.Date(2013, 1, 1, 0, 0, 0, 0, time.UTC))\n\tdate = TimeFromExcelTime(401769, false)\n\tc.Assert(date, qt.Equals, time.Date(3000, 1, 1, 0, 0, 0, 0, time.UTC))\n}\n\nfunc TestTimeFromExcelTimeWithFractionalPart(t *testing.T) {\n\tc := qt.New(t)\n\tdate := TimeFromExcelTime(0.114583333333333, false)\n\tc.Assert(date.Round(time.Second), qt.Equals, time.Date(1899, 12, 30, 2, 45, 0, 0, time.UTC))\n\n\tdate = TimeFromExcelTime(60.1145833333333, false)\n\tc.Assert(date.Round(time.Second), qt.Equals, time.Date(1900, 2, 28, 2, 45, 0, 0, time.UTC))\n\n\tdate = TimeFromExcelTime(61.3986111111111, false)\n\tc.Assert(date.Round(time.Second), qt.Equals, time.Date(1900, 3, 1, 9, 34, 0, 0, time.UTC))\n\n\tdate = TimeFromExcelTime(37947.75, false)\n\tc.Assert(date.Round(time.Second), qt.Equals, time.Date(2003, 11, 22, 18, 0, 0, 0, time.UTC))\n\n\tdate = TimeFromExcelTime(41275.1145833333, false)\n\tc.Assert(date.Round(time.Second), qt.Equals, time.Date(2013, 1, 1, 2, 45, 0, 0, time.UTC))\n}\n\nfunc TestTimeFromExcelTimeWith1904Offest(t *testing.T) {\n\tc := qt.New(t)\n\tdate1904Offset := TimeFromExcelTime(39813.0, true)\n\tc.Assert(date1904Offset, qt.Equals, time.Date(2013, 1, 1, 0, 0, 0, 0, time.UTC))\n\n}\n"
        },
        {
          "name": "diskv.go",
          "type": "blob",
          "size": 32.0283203125,
          "content": "package xlsx\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/peterbourgon/diskv/v3\"\n\t\"github.com/rogpeppe/fastuuid\"\n)\n\nconst (\n\tTRUE  = 0x01\n\tFALSE = 0x00\n\tUS    = 0x1f // Unit Separator\n\tRS    = 0x1e // Record Separator\n\tGS    = 0x1d // Group Separator\n)\n\nvar generator *fastuuid.Generator\n\nfunc init() {\n\tgenerator = fastuuid.MustNewGenerator()\n}\n\ntype DiskVRow struct {\n\trow         *Row\n\tmaxCol      int\n\tstore       *diskv.Diskv\n\tbuf         bytes.Buffer\n\tcurrentCell *Cell\n}\n\nfunc makeDiskVRow(sheet *Sheet, store *diskv.Diskv) *DiskVRow {\n\tdvr := &DiskVRow{\n\t\trow:    new(Row),\n\t\tmaxCol: -1,\n\t\tstore:  store,\n\t}\n\tdvr.row.Sheet = sheet\n\tdvr.row.cellStoreRow = dvr\n\tsheet.setCurrentRow(dvr.row)\n\treturn dvr\n}\n\nfunc (dvr *DiskVRow) CellUpdatable(c *Cell) {\n\tif c != dvr.currentCell {\n\t\tpanic(\"Attempt to update Cell that isn't the current cell whilst using the DiskVCellStore.  You must use the Cell returned by the most recent operation.\")\n\n\t}\n}\nfunc (dvr *DiskVRow) Updatable() {\n\tif dvr.row != dvr.row.Sheet.currentRow {\n\t\tpanic(\"Attempt to update Row that isn't the current row whilst using the DiskVCellStore.  You must use the row returned by the most recent operation.\")\n\t}\n}\n\nfunc (dvr *DiskVRow) AddCell() *Cell {\n\tcell := newCell(dvr.row, dvr.maxCol+1)\n\tdvr.setCurrentCell(cell)\n\treturn cell\n}\n\nfunc (dvr *DiskVRow) readCell(key string) (*Cell, error) {\n\tvar err error\n\tvar cellType int\n\tvar hasStyle, hasDataValidation bool\n\tvar cellIsNil bool\n\n\tb, err := dvr.store.Read(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbuf := bytes.NewReader(b)\n\tif cellIsNil, err = readBool(buf); err != nil {\n\t\treturn nil, err\n\t}\n\tif cellIsNil {\n\t\tif err = readEndOfRecord(buf); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn nil, nil\n\t}\n\tc := &Cell{}\n\tif c.Value, err = readString(buf); err != nil {\n\t\treturn c, err\n\t}\n\tif c.formula, err = readString(buf); err != nil {\n\t\treturn c, err\n\t}\n\tif hasStyle, err = readBool(buf); err != nil {\n\t\treturn c, err\n\t}\n\tif c.NumFmt, err = readString(buf); err != nil {\n\t\treturn c, err\n\t}\n\tif c.date1904, err = readBool(buf); err != nil {\n\t\treturn c, err\n\t}\n\tif c.Hidden, err = readBool(buf); err != nil {\n\t\treturn c, err\n\t}\n\tif c.HMerge, err = readInt(buf); err != nil {\n\t\treturn c, err\n\t}\n\tif c.VMerge, err = readInt(buf); err != nil {\n\t\treturn c, err\n\t}\n\tif cellType, err = readInt(buf); err != nil {\n\t\treturn c, err\n\t}\n\tc.cellType = CellType(cellType)\n\tif hasDataValidation, err = readBool(buf); err != nil {\n\t\treturn c, err\n\t}\n\tif c.Hyperlink.DisplayString, err = readString(buf); err != nil {\n\t\treturn c, err\n\t}\n\tif c.Hyperlink.Link, err = readString(buf); err != nil {\n\t\treturn c, err\n\t}\n\tif c.Hyperlink.Tooltip, err = readString(buf); err != nil {\n\t\treturn c, err\n\t}\n\tif c.num, err = readInt(buf); err != nil {\n\t\treturn c, err\n\t}\n\tif c.RichText, err = readRichText(buf); err != nil {\n\t\treturn c, err\n\t}\n\tif err = readEndOfRecord(buf); err != nil {\n\t\treturn c, err\n\t}\n\tif hasStyle {\n\t\tif c.style, err = readStyle(buf); err != nil {\n\t\t\treturn c, err\n\t\t}\n\t}\n\tif hasDataValidation {\n\t\tif c.DataValidation, err = readDataValidation(buf); err != nil {\n\t\t\treturn c, err\n\t\t}\n\t}\n\treturn c, nil\n}\n\nfunc (dvr *DiskVRow) writeCell(c *Cell) error {\n\tvar err error\n\tdvr.buf.Reset()\n\tif c == nil {\n\t\tif err := writeBool(&dvr.buf, true); err != nil {\n\n\t\t\treturn err\n\t\t}\n\t\treturn writeEndOfRecord(&dvr.buf)\n\t}\n\tif err := writeBool(&dvr.buf, false); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(&dvr.buf, c.Value); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(&dvr.buf, c.formula); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(&dvr.buf, c.style != nil); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(&dvr.buf, c.NumFmt); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(&dvr.buf, c.date1904); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(&dvr.buf, c.Hidden); err != nil {\n\t\treturn err\n\t}\n\tif err = writeInt(&dvr.buf, c.HMerge); err != nil {\n\t\treturn err\n\t}\n\tif err = writeInt(&dvr.buf, c.VMerge); err != nil {\n\t\treturn err\n\t}\n\tif err = writeInt(&dvr.buf, int(c.cellType)); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(&dvr.buf, c.DataValidation != nil); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(&dvr.buf, c.Hyperlink.DisplayString); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(&dvr.buf, c.Hyperlink.Link); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(&dvr.buf, c.Hyperlink.Tooltip); err != nil {\n\t\treturn err\n\t}\n\tif err = writeInt(&dvr.buf, c.num); err != nil {\n\t\treturn err\n\t}\n\tif err = writeRichText(&dvr.buf, c.RichText); err != nil {\n\t\treturn err\n\t}\n\tif err = writeEndOfRecord(&dvr.buf); err != nil {\n\t\treturn err\n\t}\n\tif c.style != nil {\n\t\tif err = writeStyle(&dvr.buf, c.style); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif c.DataValidation != nil {\n\t\tif err = writeDataValidation(&dvr.buf, c.DataValidation); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tkey := dvr.row.makeCellKey(c.num)\n\treturn dvr.store.Write(key, dvr.buf.Bytes())\n\n}\n\nfunc (dvr *DiskVRow) setCurrentCell(cell *Cell) {\n\tif dvr.currentCell.Modified() {\n\t\terr := dvr.writeCell(dvr.currentCell)\n\t\tif err != nil {\n\t\t\tpanic(err.Error())\n\t\t}\n\t}\n\tif cell.num > dvr.maxCol {\n\t\tdvr.maxCol = cell.num\n\t}\n\tdvr.currentCell = cell\n\n}\n\nfunc (dvr *DiskVRow) PushCell(c *Cell) {\n\tc.modified = true\n\tdvr.setCurrentCell(c)\n}\n\nfunc (dvr *DiskVRow) GetCell(colIdx int) *Cell {\n\tif dvr.currentCell != nil {\n\t\tif dvr.currentCell.num == colIdx {\n\t\t\treturn dvr.currentCell\n\t\t}\n\t}\n\tkey := dvr.row.makeCellKey(colIdx)\n\tcell, err := dvr.readCell(key)\n\tif err == nil {\n\t\tdvr.setCurrentCell(cell)\n\t\treturn cell\n\t}\n\tcell = newCell(dvr.row, colIdx)\n\tdvr.PushCell(cell)\n\treturn cell\n}\n\nfunc (dvr *DiskVRow) ForEachCell(cvf CellVisitorFunc, option ...CellVisitorOption) error {\n\tflags := &cellVisitorFlags{}\n\tfor _, opt := range option {\n\t\topt(flags)\n\t}\n\tfn := func(ci int, c *Cell) error {\n\t\tif c == nil {\n\t\t\tif flags.skipEmptyCells {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tc = dvr.GetCell(ci)\n\t\t}\n\t\tif !c.Modified() && flags.skipEmptyCells {\n\t\t\treturn nil\n\t\t}\n\t\tc.Row = dvr.row\n\t\tdvr.setCurrentCell(c)\n\t\treturn cvf(c)\n\t}\n\n\tfor ci := 0; ci <= dvr.maxCol; ci++ {\n\t\tvar cell *Cell\n\t\tkey := dvr.row.makeCellKey(ci)\n\t\tb, err := dvr.store.Read(key)\n\t\tif err != nil {\n\t\t\t// If the file doesn't exist that's fine, it was just an empty cell.\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t} else {\n\t\t\tcell, err = readCell(bytes.NewReader(b))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\terr = fn(ci, cell)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif !flags.skipEmptyCells {\n\t\tfor ci := dvr.maxCol + 1; ci < dvr.row.Sheet.MaxCol; ci++ {\n\t\t\tc := dvr.GetCell(ci)\n\t\t\terr := cvf(c)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// MaxCol returns the index of the rightmost cell in the row's column.\nfunc (dvr *DiskVRow) MaxCol() int {\n\treturn dvr.maxCol\n}\n\n// CellCount returns the total number of cells in the row.\nfunc (dvr *DiskVRow) CellCount() int {\n\treturn dvr.maxCol + 1\n}\n\n// DiskVCellStore is an implementation of the CellStore interface, backed by DiskV\ntype DiskVCellStore struct {\n\tbaseDir string\n\tbuf     *bytes.Buffer\n\tstore   *diskv.Diskv\n}\n\n// UseDiskVCellStore is a FileOption that makes all Sheet instances\n// for a File use DiskV as their backing store.  You can use this\n// option when handling very large Sheets that would otherwise require\n// allocating vast amounts of memory.\nfunc UseDiskVCellStore(f *File) {\n\tf.cellStoreConstructor = NewDiskVCellStore\n}\n\nconst cellStorePrefix = \"cellstore\"\n\n// NewDiskVCellStore is a CellStoreConstructor than returns a\n// CellStore in terms of DiskV.\nfunc NewDiskVCellStore() (CellStore, error) {\n\tcs := &DiskVCellStore{\n\t\tbuf: bytes.NewBuffer([]byte{}),\n\t}\n\n\tdir, err := os.MkdirTemp(\"\", cellStorePrefix+generator.Hex128())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcs.baseDir = dir\n\tcs.store = diskv.New(diskv.Options{\n\t\tBasePath:     dir,\n\t\tCacheSizeMax: 1024 * 1024, // 1MB for file. TODO make this configurable\n\t})\n\treturn cs, nil\n}\n\n// ReadRow reads a row from the persistant store, identified by key,\n// into memory and returns it, with the provided Sheet set as the Row's Sheet.\nfunc (cs *DiskVCellStore) ReadRow(key string, s *Sheet) (*Row, error) {\n\tb, err := cs.store.Read(key)\n\tif err != nil {\n\t\tif _, ok := err.(*os.PathError); ok {\n\t\t\treturn nil, NewRowNotFoundError(key, err.Error())\n\t\t}\n\t\treturn nil, err\n\t}\n\tr, err := readRow(bytes.NewReader(b), cs.store, s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn r, nil\n}\n\n// MoveRow moves a Row from one position in a Sheet (index) to another\n// within the persistant store.\nfunc (cs *DiskVCellStore) MoveRow(r *Row, index int) error {\n\n\tcell := r.cellStoreRow.(*DiskVRow).currentCell\n\tif cell != nil {\n\t\tcs.buf.Reset()\n\t\tif err := writeCell(cs.buf, cell); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tkey := r.makeCellKey(cell.num)\n\t\tif err := cs.store.WriteStream(key, cs.buf, true); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\toldKey := r.key()\n\tr.num = index\n\tnewKey := r.key()\n\tif cs.store.Has(newKey) {\n\t\treturn fmt.Errorf(\"target index for row (%d) would overwrite a row already exists\", index)\n\t}\n\terr := cs.store.Erase(oldKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcs.buf.Reset()\n\terr = writeRow(cs.buf, r)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar cBuf bytes.Buffer\n\tkeys := cs.store.KeysPrefix(oldKey, nil)\n\tfor key := range keys {\n\t\tif key != oldKey {\n\t\t\tb, err := cs.store.Read(key)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc, err := readCell(bytes.NewReader(b))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.Row = r\n\t\t\terr = writeCell(&cBuf, c)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tnewCKey := r.makeCellKey(c.num)\n\t\t\tif err := cs.store.Write(newCKey, cBuf.Bytes()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcs.store.Erase(key)\n\n\t\t}\n\t}\n\n\terr = r.ForEachCell(func(c *Cell) error {\n\t\tc.key()\n\t\tc.Row = r\n\t\tif err := writeCell(&cBuf, c); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tkey := r.makeCellKey(c.num)\n\t\tcs.store.WriteStream(key, &cBuf, true)\n\t\tcBuf.Reset()\n\t\treturn nil\n\t}, SkipEmptyCells)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn cs.store.WriteStream(newKey, cs.buf, true)\n}\n\n// RemoveRow removes a Row from the Sheet's representation in the\n// persistant store.\nfunc (cs *DiskVCellStore) RemoveRow(key string) error {\n\tkeys := cs.store.KeysPrefix(key, nil)\n\tfor key := range keys {\n\t\terr := cs.store.Erase(key)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// MakeRow returns an empty Row\nfunc (cs *DiskVCellStore) MakeRow(sheet *Sheet) *Row {\n\treturn makeDiskVRow(sheet, cs.store).row\n}\n\n// MakeRowWithLen returns an empty Row, with a preconfigured starting length.\nfunc (cs *DiskVCellStore) MakeRowWithLen(sheet *Sheet, len int) *Row {\n\tmr := makeDiskVRow(sheet, cs.store)\n\tmr.maxCol = len - 1\n\treturn mr.row\n}\n\n// Close will remove the persisant storage for a given Sheet completely.\nfunc (cs *DiskVCellStore) Close() error {\n\treturn os.RemoveAll(cs.baseDir)\n\n}\n\nfunc writeBool(buf *bytes.Buffer, b bool) error {\n\tif b {\n\t\terr := buf.WriteByte(TRUE)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\terr := buf.WriteByte(FALSE)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn writeUnitSeparator(buf)\n}\n\nfunc readUnitSeparator(reader *bytes.Reader) error {\n\tus, err := reader.ReadByte()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif us != US {\n\t\treturn errors.New(\"invalid format in cellstore, no unit separator found\")\n\t}\n\treturn nil\n}\n\nfunc writeUnitSeparator(buf *bytes.Buffer) error {\n\treturn buf.WriteByte(US)\n}\n\nfunc writeGroupSeparator(buf *bytes.Buffer) error {\n\treturn buf.WriteByte(GS)\n}\n\nfunc readBool(reader *bytes.Reader) (bool, error) {\n\tb, err := reader.ReadByte()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\terr = readUnitSeparator(reader)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif b == TRUE {\n\t\treturn true, nil\n\t}\n\treturn false, nil\n}\n\nfunc writeString(buf *bytes.Buffer, s string) error {\n\t_, err := buf.WriteString(s)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn writeUnitSeparator(buf)\n}\n\nfunc readString(reader *bytes.Reader) (string, error) {\n\tvar s strings.Builder\n\tfor {\n\t\tb, err := reader.ReadByte()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif b == US {\n\t\t\treturn s.String(), nil\n\t\t}\n\t\terr = s.WriteByte(b)\n\t\tif err != nil {\n\t\t\treturn s.String(), err\n\t\t}\n\t}\n}\n\nfunc writeInt(buf *bytes.Buffer, i int) error {\n\tibuf := make([]byte, binary.MaxVarintLen64)\n\n\tn := binary.PutVarint(ibuf, int64(i))\n\t_, err := buf.Write(ibuf[:n])\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn writeUnitSeparator(buf)\n}\n\nfunc readFloat(reader *bytes.Reader) (float64, error) {\n\ti, err := binary.ReadUvarint(reader)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\terr = readUnitSeparator(reader)\n\tif err != nil {\n\t\treturn -2, err\n\t}\n\treturn math.Float64frombits(i), nil\n\n}\n\nfunc writeFloat(buf *bytes.Buffer, f float64) error {\n\tibuf := make([]byte, binary.MaxVarintLen64)\n\tbits := math.Float64bits(f)\n\tn := binary.PutUvarint(ibuf, bits)\n\t_, err := buf.Write(ibuf[:n])\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn writeUnitSeparator(buf)\n}\n\nfunc readInt(reader *bytes.Reader) (int, error) {\n\ti, err := binary.ReadVarint(reader)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\terr = readUnitSeparator(reader)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\treturn int(i), nil\n}\n\nfunc writeStringPointer(buf *bytes.Buffer, sp *string) error {\n\terr := writeBool(buf, sp == nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif sp != nil {\n\t\t_, err = buf.WriteString(*sp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn writeUnitSeparator(buf)\n}\n\nfunc readStringPointer(reader *bytes.Reader) (*string, error) {\n\tisNil, err := readBool(reader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif isNil {\n\t\terr := readUnitSeparator(reader)\n\t\treturn nil, err\n\t}\n\ts, err := readString(reader)\n\treturn &s, err\n}\n\nfunc writeEndOfRecord(buf *bytes.Buffer) error {\n\treturn buf.WriteByte(RS)\n}\n\nfunc readEndOfRecord(reader *bytes.Reader) error {\n\tb, err := reader.ReadByte()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif b != RS {\n\t\treturn errors.New(\"expected end of record, but not found\")\n\t}\n\treturn nil\n}\n\nfunc writeBorder(buf *bytes.Buffer, b Border) error {\n\tif err := writeString(buf, b.Left); err != nil {\n\t\treturn err\n\t}\n\tif err := writeString(buf, b.LeftColor); err != nil {\n\t\treturn err\n\t}\n\tif err := writeString(buf, b.Right); err != nil {\n\t\treturn err\n\t}\n\tif err := writeString(buf, b.RightColor); err != nil {\n\t\treturn err\n\t}\n\tif err := writeString(buf, b.Top); err != nil {\n\t\treturn err\n\t}\n\tif err := writeString(buf, b.TopColor); err != nil {\n\t\treturn err\n\t}\n\tif err := writeString(buf, b.Bottom); err != nil {\n\t\treturn err\n\t}\n\tif err := writeString(buf, b.BottomColor); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc readBorder(reader *bytes.Reader) (Border, error) {\n\tvar err error\n\tb := Border{}\n\tif b.Left, err = readString(reader); err != nil {\n\t\treturn b, err\n\t}\n\tif b.LeftColor, err = readString(reader); err != nil {\n\t\treturn b, err\n\t}\n\tif b.Right, err = readString(reader); err != nil {\n\t\treturn b, err\n\t}\n\tif b.RightColor, err = readString(reader); err != nil {\n\t\treturn b, err\n\t}\n\tif b.Top, err = readString(reader); err != nil {\n\t\treturn b, err\n\t}\n\tif b.TopColor, err = readString(reader); err != nil {\n\t\treturn b, err\n\t}\n\tif b.Bottom, err = readString(reader); err != nil {\n\t\treturn b, err\n\t}\n\tif b.BottomColor, err = readString(reader); err != nil {\n\t\treturn b, err\n\t}\n\treturn b, nil\n}\n\nfunc writeFill(buf *bytes.Buffer, f Fill) error {\n\tif err := writeString(buf, f.PatternType); err != nil {\n\t\treturn err\n\t}\n\tif err := writeString(buf, f.BgColor); err != nil {\n\t\treturn err\n\t}\n\tif err := writeString(buf, f.FgColor); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc readFill(reader *bytes.Reader) (Fill, error) {\n\tvar err error\n\tf := Fill{}\n\tif f.PatternType, err = readString(reader); err != nil {\n\t\treturn f, err\n\t}\n\tif f.BgColor, err = readString(reader); err != nil {\n\t\treturn f, err\n\t}\n\tif f.FgColor, err = readString(reader); err != nil {\n\t\treturn f, err\n\t}\n\treturn f, nil\n}\n\nfunc writeFont(buf *bytes.Buffer, f Font) error {\n\tif err := writeFloat(buf, f.Size); err != nil {\n\t\treturn err\n\t}\n\tif err := writeString(buf, f.Name); err != nil {\n\t\treturn err\n\t}\n\tif err := writeInt(buf, f.Family); err != nil {\n\t\treturn err\n\t}\n\tif err := writeInt(buf, f.Charset); err != nil {\n\t\treturn err\n\t}\n\tif err := writeString(buf, f.Color); err != nil {\n\t\treturn err\n\t}\n\tif err := writeBool(buf, f.Bold); err != nil {\n\t\treturn err\n\t}\n\tif err := writeBool(buf, f.Italic); err != nil {\n\t\treturn err\n\t}\n\tif err := writeBool(buf, f.Underline); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc readFont(reader *bytes.Reader) (Font, error) {\n\tvar err error\n\tf := Font{}\n\tif f.Size, err = readFloat(reader); err != nil {\n\t\treturn f, err\n\t}\n\tif f.Name, err = readString(reader); err != nil {\n\t\treturn f, err\n\t}\n\tif f.Family, err = readInt(reader); err != nil {\n\t\treturn f, err\n\t}\n\tif f.Charset, err = readInt(reader); err != nil {\n\t\treturn f, err\n\t}\n\tif f.Color, err = readString(reader); err != nil {\n\t\treturn f, err\n\t}\n\tif f.Bold, err = readBool(reader); err != nil {\n\t\treturn f, err\n\t}\n\tif f.Italic, err = readBool(reader); err != nil {\n\t\treturn f, err\n\t}\n\tif f.Underline, err = readBool(reader); err != nil {\n\t\treturn f, err\n\t}\n\treturn f, nil\n}\n\nfunc writeAlignment(buf *bytes.Buffer, a Alignment) error {\n\tvar err error\n\tif err = writeString(buf, a.Horizontal); err != nil {\n\t\treturn err\n\t}\n\tif err = writeInt(buf, a.Indent); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, a.ShrinkToFit); err != nil {\n\t\treturn err\n\t}\n\tif err = writeInt(buf, a.TextRotation); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(buf, a.Vertical); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, a.WrapText); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc readAlignment(reader *bytes.Reader) (Alignment, error) {\n\tvar err error\n\ta := Alignment{}\n\tif a.Horizontal, err = readString(reader); err != nil {\n\t\treturn a, err\n\t}\n\tif a.Indent, err = readInt(reader); err != nil {\n\t\treturn a, err\n\t}\n\tif a.ShrinkToFit, err = readBool(reader); err != nil {\n\t\treturn a, err\n\t}\n\tif a.TextRotation, err = readInt(reader); err != nil {\n\t\treturn a, err\n\t}\n\tif a.Vertical, err = readString(reader); err != nil {\n\t\treturn a, err\n\t}\n\tif a.WrapText, err = readBool(reader); err != nil {\n\t\treturn a, err\n\t}\n\treturn a, nil\n}\n\nfunc writeStyle(buf *bytes.Buffer, s *Style) error {\n\tvar err error\n\tif err = writeBorder(buf, s.Border); err != nil {\n\t\treturn err\n\t}\n\tif err = writeFill(buf, s.Fill); err != nil {\n\t\treturn err\n\t}\n\tif err = writeFont(buf, s.Font); err != nil {\n\t\treturn err\n\t}\n\tif err = writeAlignment(buf, s.Alignment); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, s.ApplyBorder); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, s.ApplyFill); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, s.ApplyFont); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, s.ApplyAlignment); err != nil {\n\t\treturn err\n\t}\n\tif err = writeEndOfRecord(buf); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc readStyle(reader *bytes.Reader) (*Style, error) {\n\tvar err error\n\ts := &Style{}\n\tif s.Border, err = readBorder(reader); err != nil {\n\t\treturn s, err\n\t}\n\tif s.Fill, err = readFill(reader); err != nil {\n\t\treturn s, err\n\t}\n\tif s.Font, err = readFont(reader); err != nil {\n\t\treturn s, err\n\t}\n\tif s.Alignment, err = readAlignment(reader); err != nil {\n\t\treturn s, err\n\t}\n\tif s.ApplyBorder, err = readBool(reader); err != nil {\n\t\treturn s, err\n\t}\n\tif s.ApplyFill, err = readBool(reader); err != nil {\n\t\treturn s, err\n\t}\n\tif s.ApplyFont, err = readBool(reader); err != nil {\n\t\treturn s, err\n\t}\n\tif s.ApplyAlignment, err = readBool(reader); err != nil {\n\t\treturn s, err\n\t}\n\tif err = readEndOfRecord(reader); err != nil {\n\t\treturn s, err\n\t}\n\treturn s, nil\n}\n\nfunc writeDataValidation(buf *bytes.Buffer, dv *xlsxDataValidation) error {\n\tvar err error\n\tif err = writeBool(buf, dv.AllowBlank); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, dv.ShowInputMessage); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, dv.ShowErrorMessage); err != nil {\n\t\treturn err\n\t}\n\tif err = writeStringPointer(buf, dv.ErrorStyle); err != nil {\n\t\treturn err\n\t}\n\tif err = writeStringPointer(buf, dv.ErrorTitle); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(buf, dv.Operator); err != nil {\n\t\treturn err\n\t}\n\tif err = writeStringPointer(buf, dv.Error); err != nil {\n\t\treturn err\n\t}\n\tif err = writeStringPointer(buf, dv.PromptTitle); err != nil {\n\t\treturn err\n\t}\n\tif err = writeStringPointer(buf, dv.Prompt); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(buf, dv.Type); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(buf, dv.Sqref); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(buf, dv.Formula1); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(buf, dv.Formula2); err != nil {\n\t\treturn err\n\t}\n\tif err = writeEndOfRecord(buf); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc readDataValidation(reader *bytes.Reader) (*xlsxDataValidation, error) {\n\tvar err error\n\tdv := &xlsxDataValidation{}\n\tif dv.AllowBlank, err = readBool(reader); err != nil {\n\t\treturn dv, err\n\t}\n\tif dv.ShowInputMessage, err = readBool(reader); err != nil {\n\t\treturn dv, err\n\t}\n\tif dv.ShowErrorMessage, err = readBool(reader); err != nil {\n\t\treturn dv, err\n\t}\n\tif dv.ErrorStyle, err = readStringPointer(reader); err != nil {\n\t\treturn dv, err\n\t}\n\tif dv.ErrorTitle, err = readStringPointer(reader); err != nil {\n\t\treturn dv, err\n\t}\n\tif dv.Operator, err = readString(reader); err != nil {\n\t\treturn dv, err\n\t}\n\tif dv.Error, err = readStringPointer(reader); err != nil {\n\t\treturn dv, err\n\t}\n\tif dv.PromptTitle, err = readStringPointer(reader); err != nil {\n\t\treturn dv, err\n\t}\n\tif dv.Prompt, err = readStringPointer(reader); err != nil {\n\t\treturn dv, err\n\t}\n\tif dv.Type, err = readString(reader); err != nil {\n\t\treturn dv, err\n\t}\n\tif dv.Sqref, err = readString(reader); err != nil {\n\t\treturn dv, err\n\t}\n\tif dv.Formula1, err = readString(reader); err != nil {\n\t\treturn dv, err\n\t}\n\tif dv.Formula2, err = readString(reader); err != nil {\n\t\treturn dv, err\n\t}\n\tif err = readEndOfRecord(reader); err != nil {\n\t\treturn dv, err\n\t}\n\treturn dv, nil\n}\n\nfunc writeRow(buf *bytes.Buffer, r *Row) error {\n\tvar err error\n\tif err = writeBool(buf, r.Hidden); err != nil {\n\t\treturn err\n\t}\n\t// We don't write the Sheet reference, it's always restorable from context.\n\tif err = writeFloat(buf, r.GetHeight()); err != nil {\n\t\treturn err\n\t}\n\tif err = writeInt(buf, int(r.GetOutlineLevel())); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, r.isCustom); err != nil {\n\t\treturn err\n\t}\n\tif err = writeInt(buf, r.num); err != nil {\n\t\treturn err\n\t}\n\tif err = writeInt(buf, r.cellStoreRow.MaxCol()); err != nil {\n\t\treturn err\n\t}\n\tif err = writeEndOfRecord(buf); err != nil {\n\t\treturn err\n\t}\n\treturn writeGroupSeparator(buf)\n}\n\nfunc writeCell(buf *bytes.Buffer, c *Cell) error {\n\tvar err error\n\tif c == nil {\n\t\tif err := writeBool(buf, true); err != nil {\n\n\t\t\treturn err\n\t\t}\n\t\treturn writeEndOfRecord(buf)\n\t}\n\tif err := writeBool(buf, false); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(buf, c.Value); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(buf, c.formula); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, c.style != nil); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(buf, c.NumFmt); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, c.date1904); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, c.Hidden); err != nil {\n\t\treturn err\n\t}\n\tif err = writeInt(buf, c.HMerge); err != nil {\n\t\treturn err\n\t}\n\tif err = writeInt(buf, c.VMerge); err != nil {\n\t\treturn err\n\t}\n\tif err = writeInt(buf, int(c.cellType)); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, c.DataValidation != nil); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(buf, c.Hyperlink.DisplayString); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(buf, c.Hyperlink.Link); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(buf, c.Hyperlink.Tooltip); err != nil {\n\t\treturn err\n\t}\n\tif err = writeInt(buf, c.num); err != nil {\n\t\treturn err\n\t}\n\tif err = writeRichText(buf, c.RichText); err != nil {\n\t\treturn err\n\t}\n\tif err = writeEndOfRecord(buf); err != nil {\n\t\treturn err\n\t}\n\tif c.style != nil {\n\t\tif err = writeStyle(buf, c.style); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif c.DataValidation != nil {\n\t\tif err = writeDataValidation(buf, c.DataValidation); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc readRow(reader *bytes.Reader, store *diskv.Diskv, sheet *Sheet) (*Row, error) {\n\tvar err error\n\n\tr := &Row{\n\t\tSheet: sheet,\n\t}\n\tdr := &DiskVRow{\n\t\trow:   r,\n\t\tstore: store,\n\t}\n\tr.cellStoreRow = dr\n\n\tr.Hidden, err = readBool(reader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\theight, err := readFloat(reader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tr.height = height\n\toutlineLevel, err := readInt(reader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tr.outlineLevel = uint8(outlineLevel)\n\tr.isCustom, err = readBool(reader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tr.num, err = readInt(reader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdr.maxCol, err = readInt(reader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = readEndOfRecord(reader)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\treturn r, nil\n}\n\nfunc readCell(reader *bytes.Reader) (*Cell, error) {\n\tvar err error\n\tvar cellType int\n\tvar hasStyle, hasDataValidation bool\n\tvar cellIsNil bool\n\tif cellIsNil, err = readBool(reader); err != nil {\n\t\treturn nil, err\n\t}\n\tif cellIsNil {\n\t\tif err = readEndOfRecord(reader); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn nil, nil\n\t}\n\tc := &Cell{}\n\tif c.Value, err = readString(reader); err != nil {\n\t\treturn c, err\n\t}\n\tif c.formula, err = readString(reader); err != nil {\n\t\treturn c, err\n\t}\n\tif hasStyle, err = readBool(reader); err != nil {\n\t\treturn c, err\n\t}\n\tif c.NumFmt, err = readString(reader); err != nil {\n\t\treturn c, err\n\t}\n\tif c.date1904, err = readBool(reader); err != nil {\n\t\treturn c, err\n\t}\n\tif c.Hidden, err = readBool(reader); err != nil {\n\t\treturn c, err\n\t}\n\tif c.HMerge, err = readInt(reader); err != nil {\n\t\treturn c, err\n\t}\n\tif c.VMerge, err = readInt(reader); err != nil {\n\t\treturn c, err\n\t}\n\tif cellType, err = readInt(reader); err != nil {\n\t\treturn c, err\n\t}\n\tc.cellType = CellType(cellType)\n\tif hasDataValidation, err = readBool(reader); err != nil {\n\t\treturn c, err\n\t}\n\tif c.Hyperlink.DisplayString, err = readString(reader); err != nil {\n\t\treturn c, err\n\t}\n\tif c.Hyperlink.Link, err = readString(reader); err != nil {\n\t\treturn c, err\n\t}\n\tif c.Hyperlink.Tooltip, err = readString(reader); err != nil {\n\t\treturn c, err\n\t}\n\tif c.num, err = readInt(reader); err != nil {\n\t\treturn c, err\n\t}\n\tif c.RichText, err = readRichText(reader); err != nil {\n\t\treturn c, err\n\t}\n\tif err = readEndOfRecord(reader); err != nil {\n\t\treturn c, err\n\t}\n\tif hasStyle {\n\t\tif c.style, err = readStyle(reader); err != nil {\n\t\t\treturn c, err\n\t\t}\n\t}\n\tif hasDataValidation {\n\t\tif c.DataValidation, err = readDataValidation(reader); err != nil {\n\t\t\treturn c, err\n\t\t}\n\t}\n\treturn c, nil\n}\n\n// WriteRow writes a Row to persistant storage.\nfunc (cs *DiskVCellStore) WriteRow(r *Row) error {\n\tdvr, ok := r.cellStoreRow.(*DiskVRow)\n\tif !ok {\n\t\treturn fmt.Errorf(\"cellStoreRow for a DiskVCellStore is not DiskVRow (%T)\", r.cellStoreRow)\n\t}\n\tif dvr.currentCell != nil {\n\t\terr := dvr.writeCell(dvr.currentCell)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tcs.buf.Reset()\n\terr := writeRow(cs.buf, r)\n\tif err != nil {\n\t\treturn err\n\t}\n\tkey := r.key()\n\treturn cs.store.WriteStream(key, cs.buf, true)\n}\n\nfunc writeRichTextColor(buf *bytes.Buffer, c *RichTextColor) error {\n\tvar err error\n\tvar hasIndexed bool\n\tvar hasTheme bool\n\n\thasIndexed = c.coreColor.Indexed != nil\n\thasTheme = c.coreColor.Theme != nil\n\n\tif err = writeString(buf, c.coreColor.RGB); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, hasTheme); err != nil {\n\t\treturn err\n\t}\n\tif err = writeFloat(buf, c.coreColor.Tint); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, hasIndexed); err != nil {\n\t\treturn err\n\t}\n\tif err = writeEndOfRecord(buf); err != nil {\n\t\treturn err\n\t}\n\n\tif hasTheme {\n\t\tif err = writeInt(buf, *c.coreColor.Theme); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = writeEndOfRecord(buf); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif hasIndexed {\n\t\tif err = writeInt(buf, *c.coreColor.Indexed); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = writeEndOfRecord(buf); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc readRichTextColor(reader *bytes.Reader) (*RichTextColor, error) {\n\tvar err error\n\tvar hasIndexed bool\n\tvar hasTheme bool\n\n\tc := &RichTextColor{}\n\n\tif c.coreColor.RGB, err = readString(reader); err != nil {\n\t\treturn nil, err\n\t}\n\tif hasTheme, err = readBool(reader); err != nil {\n\t\treturn nil, err\n\t}\n\tif c.coreColor.Tint, err = readFloat(reader); err != nil {\n\t\treturn nil, err\n\t}\n\tif hasIndexed, err = readBool(reader); err != nil {\n\t\treturn nil, err\n\t}\n\tif err = readEndOfRecord(reader); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif hasTheme {\n\t\tvar theme int\n\t\tif theme, err = readInt(reader); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err = readEndOfRecord(reader); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tc.coreColor.Theme = &theme\n\t}\n\n\tif hasIndexed {\n\t\tvar indexed int\n\t\tif indexed, err = readInt(reader); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err = readEndOfRecord(reader); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tc.coreColor.Indexed = &indexed\n\t}\n\n\treturn c, nil\n}\n\nfunc writeRichTextFont(buf *bytes.Buffer, f *RichTextFont) error {\n\tvar err error\n\tvar hasColor bool = f.Color != nil\n\n\tif err = writeString(buf, f.Name); err != nil {\n\t\treturn err\n\t}\n\tif err = writeFloat(buf, f.Size); err != nil {\n\t\treturn err\n\t}\n\tif err = writeInt(buf, int(f.Family)); err != nil {\n\t\treturn err\n\t}\n\tif err = writeInt(buf, int(f.Charset)); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, hasColor); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, f.Bold); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, f.Italic); err != nil {\n\t\treturn err\n\t}\n\tif err = writeBool(buf, f.Strike); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(buf, string(f.VertAlign)); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(buf, string(f.Underline)); err != nil {\n\t\treturn err\n\t}\n\tif err = writeEndOfRecord(buf); err != nil {\n\t\treturn err\n\t}\n\n\tif hasColor {\n\t\tif err = writeRichTextColor(buf, f.Color); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc readRichTextFont(reader *bytes.Reader) (*RichTextFont, error) {\n\tvar err error\n\tvar hasColor bool\n\tvar family int\n\tvar charset int\n\tvar verAlign string\n\tvar underline string\n\n\tf := &RichTextFont{}\n\n\tif f.Name, err = readString(reader); err != nil {\n\t\treturn nil, err\n\t}\n\tif f.Size, err = readFloat(reader); err != nil {\n\t\treturn nil, err\n\t}\n\tif family, err = readInt(reader); err != nil {\n\t\treturn nil, err\n\t}\n\tf.Family = RichTextFontFamily(family)\n\tif charset, err = readInt(reader); err != nil {\n\t\treturn nil, err\n\t}\n\tf.Charset = RichTextCharset(charset)\n\tif hasColor, err = readBool(reader); err != nil {\n\t\treturn nil, err\n\t}\n\tif f.Bold, err = readBool(reader); err != nil {\n\t\treturn nil, err\n\t}\n\tif f.Italic, err = readBool(reader); err != nil {\n\t\treturn nil, err\n\t}\n\tif f.Strike, err = readBool(reader); err != nil {\n\t\treturn nil, err\n\t}\n\tif verAlign, err = readString(reader); err != nil {\n\t\treturn nil, err\n\t}\n\tf.VertAlign = RichTextVertAlign(verAlign)\n\tif underline, err = readString(reader); err != nil {\n\t\treturn nil, err\n\t}\n\tf.Underline = RichTextUnderline(underline)\n\tif err = readEndOfRecord(reader); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif hasColor {\n\t\tif f.Color, err = readRichTextColor(reader); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn f, nil\n}\n\nfunc writeRichTextRun(buf *bytes.Buffer, r *RichTextRun) error {\n\tvar err error\n\tvar hasFont bool = r.Font != nil\n\n\tif err = writeBool(buf, hasFont); err != nil {\n\t\treturn err\n\t}\n\tif err = writeString(buf, r.Text); err != nil {\n\t\treturn err\n\t}\n\tif err = writeEndOfRecord(buf); err != nil {\n\t\treturn err\n\t}\n\n\tif hasFont {\n\t\tif err = writeRichTextFont(buf, r.Font); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc readRichTextRun(reader *bytes.Reader) (*RichTextRun, error) {\n\tvar err error\n\tvar hasFont bool\n\n\tr := &RichTextRun{}\n\n\tif hasFont, err = readBool(reader); err != nil {\n\t\treturn nil, err\n\t}\n\tif r.Text, err = readString(reader); err != nil {\n\t\treturn nil, err\n\t}\n\tif err = readEndOfRecord(reader); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif hasFont {\n\t\tif r.Font, err = readRichTextFont(reader); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn r, nil\n}\n\nfunc writeRichText(buf *bytes.Buffer, rt []RichTextRun) error {\n\tvar err error\n\tvar length int = len(rt)\n\n\tif err = writeInt(buf, length); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, r := range rt {\n\t\tif err = writeRichTextRun(buf, &r); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc readRichText(reader *bytes.Reader) ([]RichTextRun, error) {\n\tvar err error\n\tvar length int\n\n\tif length, err = readInt(reader); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar rt []RichTextRun\n\n\tvar i int\n\tfor i = 0; i < length; i++ {\n\t\tvar r *RichTextRun\n\t\tif r, err = readRichTextRun(reader); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trt = append(rt, *r)\n\t}\n\n\treturn rt, nil\n}\n"
        },
        {
          "name": "diskv_test.go",
          "type": "blob",
          "size": 25.2138671875,
          "content": "package xlsx\n\nimport (\n\t\"bytes\"\n\t\"math\"\n\t\"testing\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\nfunc TestDiskVCellStore(t *testing.T) {\n\tc := qt.New(t)\n\n\tc.Run(\"RowNotFoundError\", func(c *qt.C) {\n\t\tdiskvCs, err := NewDiskVCellStore()\n\t\tc.Assert(err, qt.IsNil)\n\t\tcs, ok := diskvCs.(*DiskVCellStore)\n\t\tc.Assert(ok, qt.Equals, true)\n\t\tdefer cs.Close()\n\n\t\t_, err = cs.ReadRow(\"I don't exist\", nil)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t\t_, ok = err.(*RowNotFoundError)\n\t\tc.Assert(ok, qt.Equals, true)\n\t})\n\n\tc.Run(\"Write and Read Empty Row\", func(c *qt.C) {\n\t\tdiskvCs, err := NewDiskVCellStore()\n\t\tc.Assert(err, qt.IsNil)\n\t\tcs, ok := diskvCs.(*DiskVCellStore)\n\t\tc.Assert(ok, qt.Equals, true)\n\t\tdefer cs.Close()\n\n\t\tfile := NewFile(UseDiskVCellStore)\n\t\tsheet, _ := file.AddSheet(\"Test\")\n\t\trow := sheet.AddRow()\n\n\t\trow.Hidden = true\n\t\trow.SetHeight(40.4)\n\t\trow.SetOutlineLevel(2)\n\t\trow.isCustom = true\n\t\trow.num = 3\n\n\t\terr = cs.WriteRow(row)\n\t\tc.Assert(err, qt.IsNil)\n\t\trow2, err := cs.ReadRow(row.key(), sheet)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(row2, qt.Not(qt.IsNil))\n\t\tc.Assert(row.Hidden, qt.Equals, row2.Hidden)\n\t\tc.Assert(row.GetHeight(), qt.Equals, row2.GetHeight())\n\t\tc.Assert(row.GetOutlineLevel(), qt.Equals, row2.GetOutlineLevel())\n\t\tc.Assert(row.isCustom, qt.Equals, row2.isCustom)\n\t\tc.Assert(row.num, qt.Equals, row2.num)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, row2.cellStoreRow.CellCount())\n\t})\n\n\tc.Run(\"Write and Read Row with Cells\", func(c *qt.C) {\n\t\tfile := NewFile(UseDiskVCellStore)\n\t\tsheet, _ := file.AddSheet(\"Test\")\n\t\trow := sheet.AddRow()\n\n\t\ts := &Style{\n\t\t\tBorder: Border{\n\t\t\t\tLeft:        \"left\",\n\t\t\t\tLeftColor:   \"leftColor\",\n\t\t\t\tRight:       \"right\",\n\t\t\t\tRightColor:  \"rightColor\",\n\t\t\t\tTop:         \"top\",\n\t\t\t\tTopColor:    \"topColor\",\n\t\t\t\tBottom:      \"bottom\",\n\t\t\t\tBottomColor: \"bottomColor\",\n\t\t\t},\n\t\t\tFill: Fill{\n\t\t\t\tPatternType: \"PatternType\",\n\t\t\t\tBgColor:     \"BgColor\",\n\t\t\t\tFgColor:     \"FgColor\",\n\t\t\t},\n\t\t\tFont: Font{\n\t\t\t\tSize:      1,\n\t\t\t\tName:      \"Font\",\n\t\t\t\tFamily:    2,\n\t\t\t\tCharset:   3,\n\t\t\t\tColor:     \"Red\",\n\t\t\t\tBold:      true,\n\t\t\t\tItalic:    true,\n\t\t\t\tUnderline: true,\n\t\t\t},\n\t\t\tAlignment: Alignment{\n\t\t\t\tHorizontal:   \"left\",\n\t\t\t\tIndent:       1,\n\t\t\t\tShrinkToFit:  true,\n\t\t\t\tTextRotation: 90,\n\t\t\t\tVertical:     \"top\",\n\t\t\t\tWrapText:     true,\n\t\t\t},\n\t\t\tApplyBorder:    true,\n\t\t\tApplyFill:      true,\n\t\t\tApplyFont:      true,\n\t\t\tApplyAlignment: true,\n\t\t}\n\n\t\tdv := &xlsxDataValidation{\n\t\t\tAllowBlank:       true,\n\t\t\tShowInputMessage: true,\n\t\t\tShowErrorMessage: true,\n\t\t\tType:             \"type\",\n\t\t\tSqref:            \"sqref\",\n\t\t\tFormula1:         \"formula1\",\n\t\t\tFormula2:         \"formula1\",\n\t\t\tOperator:         \"operator\",\n\t\t}\n\n\t\tdv.ErrorStyle = sPtr(\"errorstyle\")\n\t\tdv.ErrorTitle = sPtr(\"errortitle\")\n\t\tdv.Error = sPtr(\"error\")\n\t\tdv.PromptTitle = sPtr(\"prompttitle\")\n\t\tdv.Prompt = sPtr(\"prompt\")\n\n\t\tcell := row.AddCell()\n\t\tcell.Value = \"value\"\n\t\tcell.formula = \"formula\"\n\t\tcell.style = s\n\t\tcell.NumFmt = \"numFmt\"\n\t\tcell.date1904 = true\n\t\tcell.Hidden = true\n\t\tcell.HMerge = 49\n\t\tcell.VMerge = 50\n\t\tcell.cellType = CellType(2)\n\t\tcell.DataValidation = dv\n\t\tcell.Hyperlink = Hyperlink{\n\t\t\tDisplayString: \"displaystring\",\n\t\t\tLink:          \"link\",\n\t\t\tTooltip:       \"tooltip\",\n\t\t}\n\n\t\tcs := sheet.cellStore\n\t\terr := cs.WriteRow(row)\n\t\tc.Assert(err, qt.IsNil)\n\t\trow2, err := cs.ReadRow(row.key(), sheet)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tcell2 := row2.GetCell(0)\n\n\t\tc.Assert(cell.Value, qt.Equals, cell2.Value)\n\t\tc.Assert(cell.formula, qt.Equals, cell2.formula)\n\t\tc.Assert(cell.NumFmt, qt.Equals, cell2.NumFmt)\n\t\tc.Assert(cell.date1904, qt.Equals, cell2.date1904)\n\t\tc.Assert(cell.Hidden, qt.Equals, cell2.Hidden)\n\t\tc.Assert(cell.HMerge, qt.Equals, cell2.HMerge)\n\t\tc.Assert(cell.VMerge, qt.Equals, cell2.VMerge)\n\t\tc.Assert(cell.cellType, qt.Equals, cell2.cellType)\n\t\tc.Assert(*cell.DataValidation, qt.DeepEquals, *cell2.DataValidation)\n\t\tc.Assert(cell.Hyperlink, qt.DeepEquals, cell2.Hyperlink)\n\t\tc.Assert(cell.num, qt.Equals, cell2.num)\n\n\t\ts2 := cell2.style\n\t\tc.Assert(s2.Border, qt.DeepEquals, s.Border)\n\t\tc.Assert(s2.Fill, qt.DeepEquals, s.Fill)\n\t\tc.Assert(s2.Font, qt.DeepEquals, s.Font)\n\t\tc.Assert(s2.Alignment, qt.DeepEquals, s.Alignment)\n\t\tc.Assert(s2.ApplyBorder, qt.Equals, s.ApplyBorder)\n\t\tc.Assert(s2.ApplyFill, qt.Equals, s.ApplyFill)\n\t\tc.Assert(s2.ApplyFont, qt.Equals, s.ApplyFont)\n\t\tc.Assert(s2.ApplyAlignment, qt.Equals, s.ApplyAlignment)\n\n\t})\n\n\tc.Run(\"Write and Read Bool\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\t\twriteBool(buf, true)\n\t\twriteBool(buf, false)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tv, err := readBool(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.Equals, true)\n\t\tv, err = readBool(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.Equals, false)\n\t\t_, err = readBool(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t})\n\n\tc.Run(\"Write and Read unit separator\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\t\twriteUnitSeparator(buf)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\terr := readUnitSeparator(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\terr = readUnitSeparator(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t})\n\n\tc.Run(\"Write and Read String\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\t\twriteString(buf, \"simple\")\n\t\twriteString(buf, `multi\nline!`)\n\t\twriteString(buf, \"\")\n\t\twriteString(buf, \"Scheiß encoding\")\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tv, err := readString(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.Equals, \"simple\")\n\t\tv, err = readString(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.Equals, `multi\nline!`)\n\t\tv, err = readString(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.Equals, \"\")\n\t\tv, err = readString(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.Equals, \"Scheiß encoding\")\n\t\t_, err = readString(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t})\n\n\tc.Run(\"Write and Read Int\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\t\twriteInt(buf, math.MinInt64)\n\t\twriteInt(buf, 0)\n\t\twriteInt(buf, math.MaxInt64)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tv, err := readInt(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.Equals, math.MinInt64)\n\t\tv, err = readInt(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.Equals, 0)\n\t\tv, err = readInt(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.Equals, math.MaxInt64)\n\t\t_, err = readInt(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t})\n\n\tc.Run(\"Write and Read String Pointer\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\n\t\ts := \"foo\"\n\t\twriteStringPointer(buf, nil)\n\t\twriteStringPointer(buf, &s)\n\t\ts = \"bar\"\n\t\twriteStringPointer(buf, &s)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tv, err := readStringPointer(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(v, qt.IsNil)\n\t\tv, err = readStringPointer(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(*v, qt.Equals, \"foo\")\n\t\tv, err = readStringPointer(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(*v, qt.Equals, \"bar\")\n\t\t_, err = readStringPointer(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t})\n\n\tc.Run(\"Write and Read end of record\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\t\twriteEndOfRecord(buf)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\terr := readEndOfRecord(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\terr = readEndOfRecord(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t})\n\n\tc.Run(\"Write and Read Border\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\n\t\tb := Border{\n\t\t\tLeft:        \"left\",\n\t\t\tLeftColor:   \"leftColor\",\n\t\t\tRight:       \"right\",\n\t\t\tRightColor:  \"rightColor\",\n\t\t\tTop:         \"top\",\n\t\t\tTopColor:    \"topColor\",\n\t\t\tBottom:      \"bottom\",\n\t\t\tBottomColor: \"bottomColor\",\n\t\t}\n\t\twriteBorder(buf, b)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tb2, err := readBorder(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(b2, qt.DeepEquals, b)\n\t\t_, err = readBorder(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t})\n\n\tc.Run(\"Write and Read Fill\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\t\tb := Fill{\n\t\t\tPatternType: \"PatternType\",\n\t\t\tBgColor:     \"BgColor\",\n\t\t\tFgColor:     \"FgColor\",\n\t\t}\n\t\twriteFill(buf, b)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tb2, err := readFill(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(b2, qt.DeepEquals, b)\n\t\t_, err = readFill(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\n\t})\n\n\tc.Run(\"Write and Read Font\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\t\tb := Font{\n\t\t\tSize:      1,\n\t\t\tName:      \"Font\",\n\t\t\tFamily:    2,\n\t\t\tCharset:   3,\n\t\t\tColor:     \"Red\",\n\t\t\tBold:      true,\n\t\t\tItalic:    true,\n\t\t\tUnderline: true,\n\t\t}\n\t\twriteFont(buf, b)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tb2, err := readFont(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(b2, qt.DeepEquals, b)\n\t\t_, err = readFont(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t})\n\n\tc.Run(\"Write and Read Alignment\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\t\tb := Alignment{\n\t\t\tHorizontal:   \"left\",\n\t\t\tIndent:       1,\n\t\t\tShrinkToFit:  true,\n\t\t\tTextRotation: 90,\n\t\t\tVertical:     \"top\",\n\t\t\tWrapText:     true,\n\t\t}\n\t\twriteAlignment(buf, b)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tb2, err := readAlignment(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(b2, qt.DeepEquals, b2)\n\t\t_, err = readAlignment(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t})\n\n\tc.Run(\"Write and Read Style\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\t\ts := Style{\n\t\t\tBorder: Border{\n\t\t\t\tLeft:        \"left\",\n\t\t\t\tLeftColor:   \"leftColor\",\n\t\t\t\tRight:       \"right\",\n\t\t\t\tRightColor:  \"rightColor\",\n\t\t\t\tTop:         \"top\",\n\t\t\t\tTopColor:    \"topColor\",\n\t\t\t\tBottom:      \"bottom\",\n\t\t\t\tBottomColor: \"bottomColor\",\n\t\t\t},\n\t\t\tFill: Fill{\n\t\t\t\tPatternType: \"PatternType\",\n\t\t\t\tBgColor:     \"BgColor\",\n\t\t\t\tFgColor:     \"FgColor\",\n\t\t\t},\n\t\t\tFont: Font{\n\t\t\t\tSize:      1,\n\t\t\t\tName:      \"Font\",\n\t\t\t\tFamily:    2,\n\t\t\t\tCharset:   3,\n\t\t\t\tColor:     \"Red\",\n\t\t\t\tBold:      true,\n\t\t\t\tItalic:    true,\n\t\t\t\tUnderline: true,\n\t\t\t},\n\t\t\tAlignment: Alignment{\n\t\t\t\tHorizontal:   \"left\",\n\t\t\t\tIndent:       1,\n\t\t\t\tShrinkToFit:  true,\n\t\t\t\tTextRotation: 90,\n\t\t\t\tVertical:     \"top\",\n\t\t\t\tWrapText:     true,\n\t\t\t},\n\t\t\tApplyBorder:    true,\n\t\t\tApplyFill:      true,\n\t\t\tApplyFont:      true,\n\t\t\tApplyAlignment: true,\n\t\t}\n\t\terr := writeStyle(buf, &s)\n\t\tc.Assert(err, qt.IsNil)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\ts2, err := readStyle(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\t// We can't just DeepEquals style because we can't\n\t\t// compare the nil pointer in the NamedStyle field.\n\t\tc.Assert(s2.Border, qt.DeepEquals, s.Border)\n\t\tc.Assert(s2.Fill, qt.DeepEquals, s.Fill)\n\t\tc.Assert(s2.Font, qt.DeepEquals, s.Font)\n\t\tc.Assert(s2.Alignment, qt.DeepEquals, s.Alignment)\n\t\tc.Assert(s2.ApplyBorder, qt.Equals, s.ApplyBorder)\n\t\tc.Assert(s2.ApplyFill, qt.Equals, s.ApplyFill)\n\t\tc.Assert(s2.ApplyFont, qt.Equals, s.ApplyFont)\n\t\tc.Assert(s2.ApplyAlignment, qt.Equals, s.ApplyAlignment)\n\t\t_, err = readStyle(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\n\t})\n\n\tc.Run(\"Write and Read DataValidation\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\n\t\tdv := &xlsxDataValidation{\n\t\t\tAllowBlank:       true,\n\t\t\tShowInputMessage: true,\n\t\t\tShowErrorMessage: true,\n\t\t\tType:             \"type\",\n\t\t\tSqref:            \"sqref\",\n\t\t\tFormula1:         \"formula1\",\n\t\t\tFormula2:         \"formula1\",\n\t\t\tOperator:         \"operator\",\n\t\t}\n\n\t\tdv.ErrorStyle = sPtr(\"errorstyle\")\n\t\tdv.ErrorTitle = sPtr(\"errortitle\")\n\t\tdv.Error = sPtr(\"error\")\n\t\tdv.PromptTitle = sPtr(\"prompttitle\")\n\t\tdv.Prompt = sPtr(\"prompt\")\n\n\t\twriteDataValidation(buf, dv)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tdv2, err := readDataValidation(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(dv2, qt.DeepEquals, dv)\n\t\t_, err = readDataValidation(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\n\t})\n\n\tc.Run(\"Write and Read Cell\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\n\t\tcell := &Cell{\n\t\t\tValue:          \"value\",\n\t\t\tformula:        \"formula\",\n\t\t\tstyle:          nil,\n\t\t\tNumFmt:         \"numFmt\",\n\t\t\tdate1904:       true,\n\t\t\tHidden:         true,\n\t\t\tHMerge:         49,\n\t\t\tVMerge:         50,\n\t\t\tcellType:       CellType(2),\n\t\t\tDataValidation: nil,\n\t\t\tHyperlink: Hyperlink{\n\t\t\t\tDisplayString: \"displaystring\",\n\t\t\t\tLink:          \"link\",\n\t\t\t\tTooltip:       \"tooltip\",\n\t\t\t},\n\t\t\tnum: 1,\n\t\t}\n\n\t\twriteCell(buf, cell)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tcell2, err := readCell(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(cell.Value, qt.Equals, cell2.Value)\n\t\tc.Assert(cell.RichText, qt.HasLen, 0)\n\t\tc.Assert(cell.formula, qt.Equals, cell2.formula)\n\t\tc.Assert(cell.style, qt.Equals, cell2.style)\n\t\tc.Assert(cell.NumFmt, qt.Equals, cell2.NumFmt)\n\t\tc.Assert(cell.date1904, qt.Equals, cell2.date1904)\n\t\tc.Assert(cell.Hidden, qt.Equals, cell2.Hidden)\n\t\tc.Assert(cell.HMerge, qt.Equals, cell2.HMerge)\n\t\tc.Assert(cell.VMerge, qt.Equals, cell2.VMerge)\n\t\tc.Assert(cell.cellType, qt.Equals, cell2.cellType)\n\t\tc.Assert(cell.DataValidation, qt.Equals, cell2.DataValidation)\n\t\tc.Assert(cell.Hyperlink, qt.DeepEquals, cell2.Hyperlink)\n\t\tc.Assert(cell.num, qt.Equals, cell2.num)\n\t\t_, err = readCell(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\n\t})\n\n\tc.Run(\"Write and Read Cell with style\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\n\t\ts := Style{\n\t\t\tBorder: Border{\n\t\t\t\tLeft:        \"left\",\n\t\t\t\tLeftColor:   \"leftColor\",\n\t\t\t\tRight:       \"right\",\n\t\t\t\tRightColor:  \"rightColor\",\n\t\t\t\tTop:         \"top\",\n\t\t\t\tTopColor:    \"topColor\",\n\t\t\t\tBottom:      \"bottom\",\n\t\t\t\tBottomColor: \"bottomColor\",\n\t\t\t},\n\t\t\tFill: Fill{\n\t\t\t\tPatternType: \"PatternType\",\n\t\t\t\tBgColor:     \"BgColor\",\n\t\t\t\tFgColor:     \"FgColor\",\n\t\t\t},\n\t\t\tFont: Font{\n\t\t\t\tSize:      1,\n\t\t\t\tName:      \"Font\",\n\t\t\t\tFamily:    2,\n\t\t\t\tCharset:   3,\n\t\t\t\tColor:     \"Red\",\n\t\t\t\tBold:      true,\n\t\t\t\tItalic:    true,\n\t\t\t\tUnderline: true,\n\t\t\t},\n\t\t\tAlignment: Alignment{\n\t\t\t\tHorizontal:   \"left\",\n\t\t\t\tIndent:       1,\n\t\t\t\tShrinkToFit:  true,\n\t\t\t\tTextRotation: 90,\n\t\t\t\tVertical:     \"top\",\n\t\t\t\tWrapText:     true,\n\t\t\t},\n\t\t\tApplyBorder:    true,\n\t\t\tApplyFill:      true,\n\t\t\tApplyFont:      true,\n\t\t\tApplyAlignment: true,\n\t\t}\n\n\t\tcell := &Cell{\n\t\t\tValue:          \"value\",\n\t\t\tformula:        \"formula\",\n\t\t\tstyle:          &s,\n\t\t\tNumFmt:         \"numFmt\",\n\t\t\tdate1904:       true,\n\t\t\tHidden:         true,\n\t\t\tHMerge:         49,\n\t\t\tVMerge:         50,\n\t\t\tcellType:       CellType(2),\n\t\t\tDataValidation: nil,\n\t\t\tHyperlink: Hyperlink{\n\t\t\t\tDisplayString: \"displaystring\",\n\t\t\t\tLink:          \"link\",\n\t\t\t\tTooltip:       \"tooltip\",\n\t\t\t},\n\t\t\tnum: 1,\n\t\t}\n\n\t\twriteCell(buf, cell)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tcell2, err := readCell(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(cell.Value, qt.Equals, cell2.Value)\n\t\tc.Assert(cell.RichText, qt.HasLen, 0)\n\t\tc.Assert(cell.formula, qt.Equals, cell2.formula)\n\t\tc.Assert(cell.NumFmt, qt.Equals, cell2.NumFmt)\n\t\tc.Assert(cell.date1904, qt.Equals, cell2.date1904)\n\t\tc.Assert(cell.Hidden, qt.Equals, cell2.Hidden)\n\t\tc.Assert(cell.HMerge, qt.Equals, cell2.HMerge)\n\t\tc.Assert(cell.VMerge, qt.Equals, cell2.VMerge)\n\t\tc.Assert(cell.cellType, qt.Equals, cell2.cellType)\n\t\tc.Assert(cell.DataValidation, qt.Equals, cell2.DataValidation)\n\t\tc.Assert(cell.Hyperlink, qt.DeepEquals, cell2.Hyperlink)\n\t\tc.Assert(cell.num, qt.Equals, cell2.num)\n\n\t\ts2 := cell2.style\n\t\tc.Assert(s2.Border, qt.DeepEquals, s.Border)\n\t\tc.Assert(s2.Fill, qt.DeepEquals, s.Fill)\n\t\tc.Assert(s2.Font, qt.DeepEquals, s.Font)\n\t\tc.Assert(s2.Alignment, qt.DeepEquals, s.Alignment)\n\t\tc.Assert(s2.ApplyBorder, qt.Equals, s.ApplyBorder)\n\t\tc.Assert(s2.ApplyFill, qt.Equals, s.ApplyFill)\n\t\tc.Assert(s2.ApplyFont, qt.Equals, s.ApplyFont)\n\t\tc.Assert(s2.ApplyAlignment, qt.Equals, s.ApplyAlignment)\n\n\t\t_, err = readCell(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\n\t})\n\n\tc.Run(\"Write and Read Cell with DataValidation\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\n\t\tdv := &xlsxDataValidation{\n\t\t\tAllowBlank:       true,\n\t\t\tShowInputMessage: true,\n\t\t\tShowErrorMessage: true,\n\t\t\tType:             \"type\",\n\t\t\tSqref:            \"sqref\",\n\t\t\tFormula1:         \"formula1\",\n\t\t\tFormula2:         \"formula1\",\n\t\t\tOperator:         \"operator\",\n\t\t}\n\t\tsPtr := func(s string) *string {\n\t\t\treturn &s\n\t\t}\n\n\t\tdv.ErrorStyle = sPtr(\"errorstyle\")\n\t\tdv.ErrorTitle = sPtr(\"errortitle\")\n\t\tdv.Error = sPtr(\"error\")\n\t\tdv.PromptTitle = sPtr(\"prompttitle\")\n\t\tdv.Prompt = sPtr(\"prompt\")\n\n\t\tcell := &Cell{\n\t\t\tValue:          \"value\",\n\t\t\tformula:        \"formula\",\n\t\t\tstyle:          nil,\n\t\t\tNumFmt:         \"numFmt\",\n\t\t\tdate1904:       true,\n\t\t\tHidden:         true,\n\t\t\tHMerge:         49,\n\t\t\tVMerge:         50,\n\t\t\tcellType:       CellType(2),\n\t\t\tDataValidation: dv,\n\t\t\tHyperlink: Hyperlink{\n\t\t\t\tDisplayString: \"displaystring\",\n\t\t\t\tLink:          \"link\",\n\t\t\t\tTooltip:       \"tooltip\",\n\t\t\t},\n\t\t\tnum: 1,\n\t\t}\n\n\t\twriteCell(buf, cell)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tcell2, err := readCell(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(cell.Value, qt.Equals, cell2.Value)\n\t\tc.Assert(cell.RichText, qt.HasLen, 0)\n\t\tc.Assert(cell.formula, qt.Equals, cell2.formula)\n\t\tc.Assert(cell.NumFmt, qt.Equals, cell2.NumFmt)\n\t\tc.Assert(cell.date1904, qt.Equals, cell2.date1904)\n\t\tc.Assert(cell.Hidden, qt.Equals, cell2.Hidden)\n\t\tc.Assert(cell.HMerge, qt.Equals, cell2.HMerge)\n\t\tc.Assert(cell.VMerge, qt.Equals, cell2.VMerge)\n\t\tc.Assert(cell.cellType, qt.Equals, cell2.cellType)\n\t\tc.Assert(*cell.DataValidation, qt.DeepEquals, *cell2.DataValidation)\n\t\tc.Assert(cell.Hyperlink, qt.DeepEquals, cell2.Hyperlink)\n\t\tc.Assert(cell.num, qt.Equals, cell2.num)\n\t\tc.Assert(cell.style, qt.Equals, cell2.style)\n\n\t\t_, err = readCell(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\n\t})\n\n\tc.Run(\"Write and Read Cell with RichText\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\n\t\tcell := &Cell{\n\t\t\tRichText: []RichTextRun{\n\t\t\t\t{\n\t\t\t\t\tFont: &RichTextFont{Bold: true},\n\t\t\t\t\tText: \"rich text\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tformula:        \"formula\",\n\t\t\tstyle:          nil,\n\t\t\tNumFmt:         \"numFmt\",\n\t\t\tdate1904:       true,\n\t\t\tHidden:         true,\n\t\t\tHMerge:         49,\n\t\t\tVMerge:         50,\n\t\t\tcellType:       CellType(2),\n\t\t\tDataValidation: nil,\n\t\t\tHyperlink: Hyperlink{\n\t\t\t\tDisplayString: \"displaystring\",\n\t\t\t\tLink:          \"link\",\n\t\t\t\tTooltip:       \"tooltip\",\n\t\t\t},\n\t\t\tnum: 1,\n\t\t}\n\n\t\twriteCell(buf, cell)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tcell2, err := readCell(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(cell.Value, qt.Equals, cell2.Value)\n\t\tc.Assert(cell.RichText, qt.DeepEquals, cell2.RichText)\n\t\tc.Assert(cell.formula, qt.Equals, cell2.formula)\n\t\tc.Assert(cell.style, qt.Equals, cell2.style)\n\t\tc.Assert(cell.NumFmt, qt.Equals, cell2.NumFmt)\n\t\tc.Assert(cell.date1904, qt.Equals, cell2.date1904)\n\t\tc.Assert(cell.Hidden, qt.Equals, cell2.Hidden)\n\t\tc.Assert(cell.HMerge, qt.Equals, cell2.HMerge)\n\t\tc.Assert(cell.VMerge, qt.Equals, cell2.VMerge)\n\t\tc.Assert(cell.cellType, qt.Equals, cell2.cellType)\n\t\tc.Assert(cell.DataValidation, qt.Equals, cell2.DataValidation)\n\t\tc.Assert(cell.Hyperlink, qt.DeepEquals, cell2.Hyperlink)\n\t\tc.Assert(cell.num, qt.Equals, cell2.num)\n\t\t_, err = readCell(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\n\t})\n\n\tc.Run(\"Write and Read RichTextColor RGB\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\n\t\tc1 := RichTextColor{\n\t\t\tcoreColor: xlsxColor{\n\t\t\t\tRGB:  \"01234567\",\n\t\t\t\tTint: -0.3,\n\t\t\t},\n\t\t}\n\n\t\terr := writeRichTextColor(buf, &c1)\n\t\tc.Assert(err, qt.IsNil)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tc2, err := readRichTextColor(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(c2.coreColor.RGB, qt.Equals, c1.coreColor.RGB)\n\t\tc.Assert(c2.coreColor.Tint, qt.Equals, c1.coreColor.Tint)\n\t\tc.Assert(c2.coreColor.Indexed, qt.Equals, c1.coreColor.Indexed)\n\t\tc.Assert(c2.coreColor.Theme, qt.Equals, c1.coreColor.Theme)\n\t\t_, err = readBool(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\n\t})\n\n\tc.Run(\"Write and Read RichTextColor Indexed\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\n\t\tindexed := 7\n\n\t\tc1 := RichTextColor{\n\t\t\tcoreColor: xlsxColor{\n\t\t\t\tIndexed: &indexed,\n\t\t\t\tTint:    0.4,\n\t\t\t},\n\t\t}\n\n\t\terr := writeRichTextColor(buf, &c1)\n\t\tc.Assert(err, qt.IsNil)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tc2, err := readRichTextColor(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(c2.coreColor.RGB, qt.Equals, c1.coreColor.RGB)\n\t\tc.Assert(c2.coreColor.Tint, qt.Equals, c1.coreColor.Tint)\n\t\tc.Assert(*c2.coreColor.Indexed, qt.Equals, *c1.coreColor.Indexed)\n\t\tc.Assert(c2.coreColor.Theme, qt.Equals, c1.coreColor.Theme)\n\t\t_, err = readBool(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\n\t})\n\n\tc.Run(\"Write and Read RichTextColor Theme\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\n\t\ttheme := 8\n\n\t\tc1 := RichTextColor{\n\t\t\tcoreColor: xlsxColor{\n\t\t\t\tTheme: &theme,\n\t\t\t},\n\t\t}\n\n\t\terr := writeRichTextColor(buf, &c1)\n\t\tc.Assert(err, qt.IsNil)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tc2, err := readRichTextColor(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(c2.coreColor.RGB, qt.Equals, c1.coreColor.RGB)\n\t\tc.Assert(c2.coreColor.Tint, qt.Equals, c1.coreColor.Tint)\n\t\tc.Assert(c2.coreColor.Indexed, qt.Equals, c1.coreColor.Indexed)\n\t\tc.Assert(*c2.coreColor.Theme, qt.Equals, *c1.coreColor.Theme)\n\t\t_, err = readBool(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\n\t})\n\n\tc.Run(\"Write and Read RichTextFont Bold\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\n\t\tf1 := RichTextFont{\n\t\t\tName:      \"Font1\",\n\t\t\tSize:      12.5,\n\t\t\tFamily:    RichTextFontFamilyScript,\n\t\t\tCharset:   RichTextCharsetGreek,\n\t\t\tColor:     &RichTextColor{coreColor: xlsxColor{RGB: \"12345678\"}},\n\t\t\tBold:      true,\n\t\t\tItalic:    false,\n\t\t\tStrike:    false,\n\t\t\tVertAlign: RichTextVertAlignSuperscript,\n\t\t\tUnderline: RichTextUnderlineSingle,\n\t\t}\n\n\t\terr := writeRichTextFont(buf, &f1)\n\t\tc.Assert(err, qt.IsNil)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tf2, err := readRichTextFont(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(f2.Name, qt.Equals, f1.Name)\n\t\tc.Assert(f2.Size, qt.Equals, f1.Size)\n\t\tc.Assert(f2.Family, qt.Equals, f1.Family)\n\t\tc.Assert(f2.Charset, qt.Equals, f1.Charset)\n\t\tc.Assert(f2.Color.coreColor.RGB, qt.Equals, f1.Color.coreColor.RGB)\n\t\tc.Assert(f2.Bold, qt.Equals, f1.Bold)\n\t\tc.Assert(f2.Italic, qt.Equals, f1.Italic)\n\t\tc.Assert(f2.Strike, qt.Equals, f1.Strike)\n\t\tc.Assert(f2.VertAlign, qt.Equals, f1.VertAlign)\n\t\tc.Assert(f2.Underline, qt.Equals, f1.Underline)\n\t\t_, err = readBool(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\n\t})\n\n\tc.Run(\"Write and Read RichTextFont Italic\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\n\t\tf1 := RichTextFont{\n\t\t\tItalic: true,\n\t\t}\n\n\t\terr := writeRichTextFont(buf, &f1)\n\t\tc.Assert(err, qt.IsNil)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tf2, err := readRichTextFont(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(f2.Name, qt.Equals, f1.Name)\n\t\tc.Assert(f2.Size, qt.Equals, f1.Size)\n\t\tc.Assert(f2.Family, qt.Equals, f1.Family)\n\t\tc.Assert(f2.Charset, qt.Equals, f1.Charset)\n\t\tc.Assert(f2.Color, qt.Equals, f1.Color)\n\t\tc.Assert(f2.Bold, qt.Equals, f1.Bold)\n\t\tc.Assert(f2.Italic, qt.Equals, f1.Italic)\n\t\tc.Assert(f2.Strike, qt.Equals, f1.Strike)\n\t\tc.Assert(f2.VertAlign, qt.Equals, f1.VertAlign)\n\t\tc.Assert(f2.Underline, qt.Equals, f1.Underline)\n\t\t_, err = readBool(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\n\t})\n\n\tc.Run(\"Write and Read RichTextFont Strike\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\n\t\tf1 := RichTextFont{\n\t\t\tStrike: true,\n\t\t}\n\n\t\terr := writeRichTextFont(buf, &f1)\n\t\tc.Assert(err, qt.IsNil)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tf2, err := readRichTextFont(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(f2.Name, qt.Equals, f1.Name)\n\t\tc.Assert(f2.Size, qt.Equals, f1.Size)\n\t\tc.Assert(f2.Family, qt.Equals, f1.Family)\n\t\tc.Assert(f2.Charset, qt.Equals, f1.Charset)\n\t\tc.Assert(f2.Color, qt.Equals, f1.Color)\n\t\tc.Assert(f2.Bold, qt.Equals, f1.Bold)\n\t\tc.Assert(f2.Italic, qt.Equals, f1.Italic)\n\t\tc.Assert(f2.Strike, qt.Equals, f1.Strike)\n\t\tc.Assert(f2.VertAlign, qt.Equals, f1.VertAlign)\n\t\tc.Assert(f2.Underline, qt.Equals, f1.Underline)\n\t\t_, err = readBool(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\n\t})\n\n\tc.Run(\"Write and Read RichTextRun with Font\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\n\t\tr1 := RichTextRun{\n\t\t\tFont: &RichTextFont{\n\t\t\t\tBold: true,\n\t\t\t},\n\t\t\tText: \"Text1\",\n\t\t}\n\n\t\terr := writeRichTextRun(buf, &r1)\n\t\tc.Assert(err, qt.IsNil)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tr2, err := readRichTextRun(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(r2.Font, qt.DeepEquals, r1.Font)\n\t\tc.Assert(r2.Text, qt.Equals, r1.Text)\n\t\t_, err = readBool(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\n\t})\n\n\tc.Run(\"Write and Read RichTextRun without Font\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\n\t\tr1 := RichTextRun{\n\t\t\tText: \"Text1\",\n\t\t}\n\n\t\terr := writeRichTextRun(buf, &r1)\n\t\tc.Assert(err, qt.IsNil)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\tr2, err := readRichTextRun(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(r2.Font, qt.Equals, r1.Font)\n\t\tc.Assert(r2.Text, qt.Equals, r1.Text)\n\t\t_, err = readBool(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t})\n\n\tc.Run(\"Write and Read RichText\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\n\t\trt1 := []RichTextRun{\n\t\t\t{\n\t\t\t\tText: \"Text1\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tFont: &RichTextFont{\n\t\t\t\t\tItalic: true,\n\t\t\t\t},\n\t\t\t\tText: \"Text2\",\n\t\t\t},\n\t\t}\n\n\t\terr := writeRichText(buf, rt1)\n\t\tc.Assert(err, qt.IsNil)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\trt2, err := readRichText(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(rt2, qt.DeepEquals, rt1)\n\t\t_, err = readBool(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\n\t})\n\n\tc.Run(\"Write and Read Nil RichText\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\t\tvar rt1 []RichTextRun = nil\n\n\t\terr := writeRichText(buf, rt1)\n\t\tc.Assert(err, qt.IsNil)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\trt2, err := readRichText(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(rt2, qt.HasLen, 0)\n\t\t_, err = readBool(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\n\t})\n\n\tc.Run(\"Write and Read Empty RichText\", func(c *qt.C) {\n\t\tbuf := bytes.NewBufferString(\"\")\n\n\t\trt1 := []RichTextRun{}\n\n\t\terr := writeRichText(buf, rt1)\n\t\tc.Assert(err, qt.IsNil)\n\t\treader := bytes.NewReader(buf.Bytes())\n\t\trt2, err := readRichText(reader)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(rt2, qt.HasLen, 0)\n\t\t_, err = readBool(reader)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t})\n\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.3955078125,
          "content": "// xslx is a package designed to help with reading data from\n// spreadsheets stored in the XLSX format used in recent versions of\n// Microsoft's Excel spreadsheet.\n//\n// Additionally, xlsx has started to grow some XLSX authoring\n// capabilities too.\n//\n// For a concise example of how to use this library why not check out\n// the source for xlsx2csv here: https://github.com/tealeg/xlsx2csv\n\npackage xlsx\n"
        },
        {
          "name": "example_read_test.go",
          "type": "blob",
          "size": 0.71875,
          "content": "package xlsx\n\nimport \"fmt\"\n\nfunc ExampleRow_ReadStruct() {\n\t//example type\n\ttype structTest struct {\n\t\tIntVal     int     `xlsx:\"0\"`\n\t\tStringVal  string  `xlsx:\"1\"`\n\t\tFloatVal   float64 `xlsx:\"2\"`\n\t\tIgnoredVal int     `xlsx:\"-\"`\n\t\tBoolVal    bool    `xlsx:\"4\"`\n\t}\n\tstructVal := structTest{\n\t\tIntVal:     16,\n\t\tStringVal:  \"heyheyhey :)!\",\n\t\tFloatVal:   3.14159216,\n\t\tIgnoredVal: 7,\n\t\tBoolVal:    true,\n\t}\n\t//create a new xlsx file and write a struct\n\t//in a new row\n\tf := NewFile()\n\tsheet, _ := f.AddSheet(\"TestRead\")\n\trow := sheet.AddRow()\n\trow.WriteStruct(&structVal, -1)\n\n\t//read the struct from the same row\n\treadStruct := &structTest{}\n\terr := row.ReadStruct(readStruct)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(readStruct)\n}\n"
        },
        {
          "name": "file.go",
          "type": "blob",
          "size": 20.498046875,
          "content": "package xlsx\n\nimport (\n\t\"archive/zip\"\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// File is a high level structure providing a slice of Sheet structs\n// to the user.\ntype File struct {\n\tworksheets           map[string]*zip.File\n\tworksheetRels        map[string]*zip.File\n\treferenceTable       *RefTable\n\tDate1904             bool\n\tstyles               *xlsxStyleSheet\n\tSheets               []*Sheet\n\tSheet                map[string]*Sheet\n\ttheme                *theme\n\tDefinedNames         []*xlsxDefinedName\n\tcellStoreConstructor CellStoreConstructor\n\trowLimit             int\n\tcolLimit             int\n\tvalueOnly            bool\n}\n\nconst NoRowLimit int = -1\nconst NoColLimit int = -1\n\ntype FileOption func(f *File)\n\n// RowLimit will limit the rows handled in any given sheet to the\n// first n, where n is the number of rows.\nfunc RowLimit(n int) FileOption {\n\treturn func(f *File) {\n\t\tf.rowLimit = n\n\t}\n}\n\n// ColLimit will limit the columns handled in any given sheet to the\n// first n, where n is the number of columns\nfunc ColLimit(n int) FileOption {\n\treturn func(f *File) {\n\t\tf.colLimit = n\n\t}\n}\n\n// ValueOnly treats all NULL values as meaningless and it will delete all NULL value cells,\n// before decode worksheet.xml. this option can save memory and time when parsing files\n// with a large number of NULL values. But it may also cause accidental injury,\n// because NULL may not really be meaningless. Use with caution\nfunc ValueOnly() FileOption {\n\treturn func(f *File) {\n\t\tf.valueOnly = true\n\t}\n}\n\n// NewFile creates a new File struct. You may pass it zero, one or\n// many FileOption functions that affect the behaviour of the file.\nfunc NewFile(options ...FileOption) *File {\n\tf := &File{\n\t\tSheet:                make(map[string]*Sheet),\n\t\tSheets:               make([]*Sheet, 0),\n\t\tDefinedNames:         make([]*xlsxDefinedName, 0),\n\t\trowLimit:             NoRowLimit,\n\t\tcolLimit:             NoColLimit,\n\t\tcellStoreConstructor: NewMemoryCellStore,\n\t}\n\tfor _, opt := range options {\n\t\topt(f)\n\t}\n\treturn f\n}\n\n// OpenFile will take the name of an XLSX file and returns a populated\n// xlsx.File struct for it.  You may pass it zero, one or\n// many FileOption functions that affect the behaviour of the file.\nfunc OpenFile(fileName string, options ...FileOption) (file *File, err error) {\n\twrap := func(err error) (*File, error) {\n\t\treturn nil, fmt.Errorf(\"OpenFile: %w\", err)\n\t}\n\n\tvar z *zip.ReadCloser\n\tz, err = zip.OpenReader(fileName)\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\tdefer z.Close()\n\n\tfile, err = ReadZip(z, options...)\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\treturn file, nil\n}\n\n// OpenBinary() take bytes of an XLSX file and returns a populated\n// xlsx.File struct for it.\nfunc OpenBinary(bs []byte, options ...FileOption) (*File, error) {\n\tr := bytes.NewReader(bs)\n\treturn OpenReaderAt(r, int64(r.Len()), options...)\n\n}\n\n// OpenReaderAt() take io.ReaderAt of an XLSX file and returns a populated\n// xlsx.File struct for it.\nfunc OpenReaderAt(r io.ReaderAt, size int64, options ...FileOption) (*File, error) {\n\tfile, err := zip.NewReader(r, size)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn ReadZipReader(file, options...)\n}\n\n// A convenient wrapper around File.ToSlice, FileToSlice will\n// return the raw data contained in an Excel XLSX file as three\n// dimensional slice.  The first index represents the sheet number,\n// the second the row number, and the third the cell number.\n//\n// For example:\n//\n//\tvar mySlice [][][]string\n//\tvar value string\n//\tmySlice = xlsx.FileToSlice(\"myXLSX.xlsx\")\n//\tvalue = mySlice[0][0][0]\n//\n// Here, value would be set to the raw value of the cell A1 in the\n// first sheet in the XLSX file.\nfunc FileToSlice(path string, options ...FileOption) ([][][]string, error) {\n\tf, err := OpenFile(path, options...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn f.ToSlice()\n}\n\n// FileToSliceUnmerged is a wrapper around File.ToSliceUnmerged.\n// It returns the raw data contained in an Excel XLSX file as three\n// dimensional slice. Merged cells will be unmerged. Covered cells become the\n// values of theirs origins.\nfunc FileToSliceUnmerged(path string, options ...FileOption) ([][][]string, error) {\n\tf, err := OpenFile(path, options...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn f.ToSliceUnmerged()\n}\n\n// Save the File to an xlsx file at the provided path.\nfunc (f *File) Save(path string) (err error) {\n\tdefer func() {\n\t\tif err != nil {\n\t\t\terr = fmt.Errorf(\"File.Save(%s): %w\", path, err)\n\t\t}\n\t}()\n\ttarget, err := os.Create(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif ie := target.Close(); ie != nil {\n\t\t\terr = fmt.Errorf(\"write:%+v close:%w\", err, ie)\n\t\t}\n\t}()\n\terr = f.Write(target)\n\treturn\n}\n\n// Write the File to io.Writer as xlsx\nfunc (f *File) Write(writer io.Writer) error {\n\twrap := func(err error) error {\n\t\treturn fmt.Errorf(\"File.Write: %w\", err)\n\t}\n\tzipWriter := zip.NewWriter(writer)\n\terr := f.MarshallParts(zipWriter)\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\terr = zipWriter.Close()\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\treturn nil\n}\n\n// AddSheet Add a new Sheet, with the provided name, to a File.\n// The minimum sheet name length is 1 character. If the sheet name length is less an error is thrown.\n// The maximum sheet name length is 31 characters. If the sheet name length is exceeded an error is thrown.\n// These special characters are also not allowed: : \\ / ? * [ ]\nfunc (f *File) AddSheet(sheetName string) (*Sheet, error) {\n\treturn f.AddSheetWithCellStore(sheetName, f.cellStoreConstructor)\n}\n\nfunc (f *File) AddSheetWithCellStore(sheetName string, constructor CellStoreConstructor) (*Sheet, error) {\n\tvar err error\n\tif _, exists := f.Sheet[sheetName]; exists {\n\t\treturn nil, fmt.Errorf(\"duplicate sheet name '%s'\", sheetName)\n\t}\n\n\tif err := IsSaneSheetName(sheetName); err != nil {\n\t\treturn nil, fmt.Errorf(\"sheet name is not valid: %w\", err)\n\t}\n\tsheet := &Sheet{\n\t\tName:          sheetName,\n\t\tFile:          f,\n\t\tSelected:      len(f.Sheets) == 0,\n\t\tCols:          &ColStore{},\n\t\tcellStoreName: sheetName,\n\t}\n\n\tsheet.cellStore, err = constructor()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tf.Sheet[sheetName] = sheet\n\tf.Sheets = append(f.Sheets, sheet)\n\treturn sheet, nil\n}\n\n// Appends an existing Sheet, with the provided name, to a File\nfunc (f *File) AppendSheet(sheet Sheet, sheetName string) (*Sheet, error) {\n\tif _, exists := f.Sheet[sheetName]; exists {\n\t\treturn nil, fmt.Errorf(\"duplicate sheet name '%s'\", sheetName)\n\t}\n\tif err := IsSaneSheetName(sheetName); err != nil {\n\t\treturn nil, fmt.Errorf(\"sheet name is not valid: %w\", err)\n\t}\n\tsheet.Name = sheetName\n\tsheet.File = f\n\tsheet.Selected = len(f.Sheets) == 0\n\tf.Sheet[sheetName] = &sheet\n\tf.Sheets = append(f.Sheets, &sheet)\n\treturn &sheet, nil\n}\n\nfunc (f *File) makeWorkbook() xlsxWorkbook {\n\treturn xlsxWorkbook{\n\t\tFileVersion: xlsxFileVersion{AppName: \"Go XLSX\"},\n\t\tWorkbookPr:  xlsxWorkbookPr{ShowObjects: \"all\"},\n\t\tBookViews: xlsxBookViews{\n\t\t\tWorkBookView: []xlsxWorkBookView{\n\t\t\t\t{\n\t\t\t\t\tShowHorizontalScroll: true,\n\t\t\t\t\tShowSheetTabs:        true,\n\t\t\t\t\tShowVerticalScroll:   true,\n\t\t\t\t\tTabRatio:             204,\n\t\t\t\t\tWindowHeight:         8192,\n\t\t\t\t\tWindowWidth:          16384,\n\t\t\t\t\tXWindow:              \"0\",\n\t\t\t\t\tYWindow:              \"0\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tSheets: xlsxSheets{Sheet: make([]xlsxSheet, len(f.Sheets))},\n\t\tCalcPr: xlsxCalcPr{\n\t\t\tIterateCount: 100,\n\t\t\tRefMode:      \"A1\",\n\t\t\tIterate:      false,\n\t\t\tIterateDelta: 0.001,\n\t\t},\n\t}\n}\n\n// Some tools that read XLSX files have very strict requirements about\n// the structure of the input XML.  In particular both Numbers on the Mac\n// and SAS dislike inline XML namespace declarations, or namespace\n// prefixes that don't match the ones that Excel itself uses.  This is a\n// problem because the Go XML library doesn't multiple namespace\n// declarations in a single element of a document.  This function is a\n// horrible hack to fix that after the XML marshalling is completed.\nfunc replaceRelationshipsNameSpace(workbookMarshal string) string {\n\tnewWorkbook := strings.Replace(workbookMarshal, `xmlns:relationships=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" relationships:id`, `r:id`, -1)\n\t// Dirty hack to fix issues #63 and #91; encoding/xml currently\n\t// \"doesn't allow for additional namespaces to be defined in the\n\t// root element of the document,\" as described by @tealeg in the\n\t// comments for #63.\n\toldXmlns := `<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\">`\n\tnewXmlns := `<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\">`\n\treturn strings.Replace(newWorkbook, oldXmlns, newXmlns, 1)\n}\n\nfunc addRelationshipNameSpaceToWorksheet(worksheetMarshal string) string {\n\toldXmlns := `<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\">`\n\tnewXmlns := `<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\">`\n\tnewSheetMarshall := strings.Replace(worksheetMarshal, oldXmlns, newXmlns, 1)\n\n\toldHyperlink := `<hyperlink id=`\n\tnewHyperlink := `<hyperlink r:id=`\n\tnewSheetMarshall = strings.Replace(newSheetMarshall, oldHyperlink, newHyperlink, -1)\n\treturn newSheetMarshall\n}\n\nfunc cellIDStringWithFixed(cellIDString string) string {\n\tletterPart := strings.Map(letterOnlyMapF, cellIDString)\n\tintPart := strings.Map(intOnlyMapF, cellIDString)\n\n\tif letterPart != \"\" && intPart == \"\" {\n\t\treturn fixedCellRefChar + letterPart\n\t} else if letterPart != \"\" && intPart != \"\" {\n\t\treturn fixedCellRefChar + letterPart + fixedCellRefChar + intPart\n\t}\n\n\treturn \"\"\n}\n\n// AutoFilter doesn't work in LibreOffice unless a special \"FilterDatabase\" tag\n// is present in the \"DefinedNames\" array.  See:\n//   - https://github.com/SheetJS/sheetjs/issues/1165\n//   - https://bugs.documentfoundation.org/show_bug.cgi?id=118592\nfunc autoFilterDefinedName(sheet *Sheet, sheetIndex int) (*xlsxDefinedName, error) {\n\tif sheet.AutoFilter == nil {\n\t\treturn nil, nil\n\t}\n\n\treturn &xlsxDefinedName{\n\t\tData: fmt.Sprintf(\n\t\t\t\"'%s'!%v:%v\",\n\t\t\tstrings.ReplaceAll(sheet.Name, \"'\", \"''\"),\n\t\t\tcellIDStringWithFixed(sheet.AutoFilter.TopLeftCell),\n\t\t\tcellIDStringWithFixed(sheet.AutoFilter.BottomRightCell),\n\t\t),\n\t\tName:         \"_xlnm._FilterDatabase\",\n\t\tLocalSheetID: sheetIndex - 1,\n\t\tHidden:       true,\n\t}, nil\n}\n\n// MakeStreamParts constructs a map of file name to XML content\n// representing the file in terms of the structure of an XLSX file.\nfunc (f *File) MakeStreamParts() (map[string]string, error) {\n\tvar parts map[string]string\n\tvar refTable *RefTable = NewSharedStringRefTable(DEFAULT_REFTABLE_SIZE)\n\trefTable.isWrite = true\n\tvar workbookRels WorkBookRels = make(WorkBookRels)\n\tvar err error\n\tvar workbook xlsxWorkbook\n\tvar types xlsxTypes = MakeDefaultContentTypes()\n\n\tmarshal := func(thing interface{}) (string, error) {\n\t\tbody, err := xml.Marshal(thing)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn xml.Header + string(body), nil\n\t}\n\n\tparts = make(map[string]string)\n\tworkbook = f.makeWorkbook()\n\tsheetIndex := 1\n\n\tif f.styles == nil {\n\t\tf.styles = newXlsxStyleSheet(f.theme)\n\t}\n\tf.styles.reset()\n\tif len(f.Sheets) == 0 {\n\t\terr := errors.New(\"workbook must contains at least one worksheet\")\n\t\treturn nil, err\n\t}\n\tfor _, sheet := range f.Sheets {\n\t\t// Make sure we don't lose the current state!\n\t\terr := sheet.cellStore.WriteRow(sheet.currentRow)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\txSheetRels := sheet.makeXLSXSheetRelations()\n\t\txSheet := sheet.makeXLSXSheet(refTable, f.styles, xSheetRels)\n\t\trId := fmt.Sprintf(\"rId%d\", sheetIndex)\n\t\tsheetId := strconv.Itoa(sheetIndex)\n\t\tsheetPath := fmt.Sprintf(\"worksheets/sheet%d.xml\", sheetIndex)\n\t\tpartName := \"xl/\" + sheetPath\n\t\trelPartName := fmt.Sprintf(\"xl/worksheets/_rels/sheet%d.xml.rels\", sheetIndex)\n\t\tsheetState := sheetStateVisible\n\t\tif sheet.Hidden {\n\t\t\tsheetState = sheetStateHidden\n\t\t}\n\t\ttypes.Overrides = append(\n\t\t\ttypes.Overrides,\n\t\t\txlsxOverride{\n\t\t\t\tPartName:    \"/\" + partName,\n\t\t\t\tContentType: \"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\"})\n\t\tworkbookRels[rId] = sheetPath\n\n\t\tworkbook.Sheets.Sheet[sheetIndex-1] = xlsxSheet{\n\t\t\tName:    sheet.Name,\n\t\t\tSheetId: sheetId,\n\t\t\tId:      rId,\n\t\t\tState:   sheetState}\n\n\t\tworksheetMarshal, err := marshal(xSheet)\n\t\tif err != nil {\n\t\t\treturn parts, err\n\t\t}\n\t\tworksheetMarshal = addRelationshipNameSpaceToWorksheet(worksheetMarshal)\n\t\tparts[partName] = worksheetMarshal\n\t\tif xSheetRels != nil {\n\t\t\tparts[relPartName], err = marshal(xSheetRels)\n\t\t\tif err != nil {\n\t\t\t\treturn parts, err\n\t\t\t}\n\t\t}\n\n\t\tdefinedName, err := autoFilterDefinedName(sheet, sheetIndex)\n\t\tif err != nil {\n\t\t\treturn parts, err\n\t\t} else if definedName != nil {\n\t\t\tworkbook.DefinedNames.DefinedName = append(workbook.DefinedNames.DefinedName, *definedName)\n\t\t}\n\n\t\tsheetIndex++\n\t}\n\n\tfor _, dn := range f.DefinedNames {\n\t\tworkbook.DefinedNames.DefinedName = append(workbook.DefinedNames.DefinedName, *dn)\n\t}\n\n\tworkbookMarshal, err := marshal(workbook)\n\tif err != nil {\n\t\treturn parts, err\n\t}\n\tworkbookMarshal = replaceRelationshipsNameSpace(workbookMarshal)\n\tparts[\"xl/workbook.xml\"] = workbookMarshal\n\tif err != nil {\n\t\treturn parts, err\n\t}\n\n\tparts[\"_rels/.rels\"] = TEMPLATE__RELS_DOT_RELS\n\tparts[\"docProps/app.xml\"] = TEMPLATE_DOCPROPS_APP\n\t// TODO - do this properly, modification and revision information\n\tparts[\"docProps/core.xml\"] = TEMPLATE_DOCPROPS_CORE\n\tparts[\"xl/theme/theme1.xml\"] = TEMPLATE_XL_THEME_THEME\n\n\txSST := refTable.makeXLSXSST()\n\tparts[\"xl/sharedStrings.xml\"], err = marshal(xSST)\n\tif err != nil {\n\t\treturn parts, err\n\t}\n\n\txWRel := workbookRels.MakeXLSXWorkbookRels()\n\n\tparts[\"xl/_rels/workbook.xml.rels\"], err = marshal(xWRel)\n\tif err != nil {\n\t\treturn parts, err\n\t}\n\n\tparts[\"[Content_Types].xml\"], err = marshal(types)\n\tif err != nil {\n\t\treturn parts, err\n\t}\n\n\tparts[\"xl/styles.xml\"], err = f.styles.Marshal()\n\tif err != nil {\n\t\treturn parts, err\n\t}\n\n\treturn parts, nil\n}\n\n// MarshallParts constructs a map of file name to XML content representing the file\n// in terms of the structure of an XLSX file.\nfunc (f *File) MarshallParts(zipWriter *zip.Writer) error {\n\tvar refTable *RefTable = NewSharedStringRefTable(DEFAULT_REFTABLE_SIZE)\n\trefTable.isWrite = true\n\tvar workbookRels WorkBookRels = make(WorkBookRels)\n\tvar err error\n\tvar workbook xlsxWorkbook\n\tvar types xlsxTypes = MakeDefaultContentTypes()\n\n\twrap := func(err error) error {\n\t\treturn fmt.Errorf(\"MarshallParts: %w\", err)\n\t}\n\n\tmarshal := func(thing interface{}) (string, error) {\n\t\tbody, err := xml.Marshal(thing)\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"xml.Marshal: %w\", err)\n\t\t}\n\t\treturn xml.Header + string(body), nil\n\t}\n\n\twritePart := func(partName, part string) error {\n\t\tw, err := zipWriter.Create(partName)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"zipwriter.Create(%s): %w\", partName, err)\n\t\t}\n\t\t_, err = w.Write([]byte(part))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"zipwriter.Write(%s): %w\", part, err)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// parts = make(map[string]string)\n\tworkbook = f.makeWorkbook()\n\tsheetIndex := 1\n\n\tif f.styles == nil {\n\t\tf.styles = newXlsxStyleSheet(f.theme)\n\t}\n\tf.styles.reset()\n\tif len(f.Sheets) == 0 {\n\t\terr := errors.New(\"MarshalParts: Workbook must contain at least one worksheet\")\n\t\treturn wrap(err)\n\t}\n\tfor _, sheet := range f.Sheets {\n\t\tif sheet.currentRow != nil {\n\t\t\t// Make sure we don't lose the current state!\n\t\t\terr := sheet.cellStore.WriteRow(sheet.currentRow)\n\t\t\tif err != nil {\n\t\t\t\treturn wrap(err)\n\t\t\t}\n\t\t}\n\n\t\txSheetRels := sheet.makeXLSXSheetRelations()\n\t\trId := fmt.Sprintf(\"rId%d\", sheetIndex)\n\t\tsheetId := strconv.Itoa(sheetIndex)\n\t\tsheetPath := fmt.Sprintf(\"worksheets/sheet%d.xml\", sheetIndex)\n\t\tpartName := \"xl/\" + sheetPath\n\t\trelPartName := fmt.Sprintf(\"xl/worksheets/_rels/sheet%d.xml.rels\", sheetIndex)\n\t\ttypes.Overrides = append(\n\t\t\ttypes.Overrides,\n\t\t\txlsxOverride{\n\t\t\t\tPartName:    \"/\" + partName,\n\t\t\t\tContentType: \"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\"})\n\t\tworkbookRels[rId] = sheetPath\n\t\tworkbook.Sheets.Sheet[sheetIndex-1] = xlsxSheet{\n\t\t\tName:    sheet.Name,\n\t\t\tSheetId: sheetId,\n\t\t\tId:      rId,\n\t\t\tState:   sheet.getState()}\n\n\t\tw, err := zipWriter.Create(partName)\n\t\tif err != nil {\n\t\t\treturn wrap(err)\n\t\t}\n\t\terr = sheet.MarshalSheet(w, refTable, f.styles, xSheetRels)\n\t\tif err != nil {\n\t\t\treturn wrap(err)\n\t\t}\n\n\t\tif xSheetRels != nil {\n\t\t\trelPart, err := marshal(xSheetRels)\n\t\t\tif err != nil {\n\t\t\t\treturn wrap(err)\n\t\t\t}\n\t\t\terr = writePart(relPartName, relPart)\n\t\t\tif err != nil {\n\t\t\t\treturn wrap(err)\n\t\t\t}\n\t\t}\n\n\t\tdefinedName, err := autoFilterDefinedName(sheet, sheetIndex)\n\t\tif err != nil {\n\t\t\treturn wrap(err)\n\t\t} else if definedName != nil {\n\t\t\tworkbook.DefinedNames.DefinedName = append(workbook.DefinedNames.DefinedName, *definedName)\n\t\t}\n\n\t\tsheetIndex++\n\t}\n\n\tfor _, dn := range f.DefinedNames {\n\t\tworkbook.DefinedNames.DefinedName = append(workbook.DefinedNames.DefinedName, *dn)\n\t}\n\n\tworkbookMarshal, err := marshal(workbook)\n\tif err != nil {\n\t\treturn err\n\t}\n\tworkbookMarshal = replaceRelationshipsNameSpace(workbookMarshal)\n\terr = writePart(\"xl/workbook.xml\", workbookMarshal)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = writePart(\"_rels/.rels\", TEMPLATE__RELS_DOT_RELS)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = writePart(\"docProps/app.xml\", TEMPLATE_DOCPROPS_APP)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// TODO - do this properly, modification and revision information\n\terr = writePart(\"docProps/core.xml\", TEMPLATE_DOCPROPS_CORE)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = writePart(\"xl/theme/theme1.xml\", TEMPLATE_XL_THEME_THEME)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\txSST := refTable.makeXLSXSST()\n\tsharedStrings, err := marshal(xSST)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = writePart(\"xl/sharedStrings.xml\", sharedStrings)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\txWRel := workbookRels.MakeXLSXWorkbookRels()\n\trelPart, err := marshal(xWRel)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = writePart(\"xl/_rels/workbook.xml.rels\", relPart)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttypesS, err := marshal(types)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = writePart(\"[Content_Types].xml\", typesS)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tstyles, err := f.styles.Marshal()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn writePart(\"xl/styles.xml\", styles)\n}\n\n// Return the raw data contained in the File as three\n// dimensional slice.  The first index represents the sheet number,\n// the second the row number, and the third the cell number.\n//\n// For example:\n//\n//\tvar mySlice [][][]string\n//\tvar value string\n//\tmySlice = xlsx.FileToSlice(\"myXLSX.xlsx\")\n//\tvalue = mySlice[0][0][0]\n//\n// Here, value would be set to the raw value of the cell A1 in the\n// first sheet in the XLSX file.\nfunc (f *File) ToSlice() (output [][][]string, err error) {\n\tsheetCount := len(f.Sheets)\n\toutput = make([][][]string, 0, sheetCount)\n\tfor _, sheet := range f.Sheets {\n\t\ts := make([][]string, 0, sheet.MaxRow)\n\t\terr := sheet.ForEachRow(func(row *Row) error {\n\t\t\tr := []string{}\n\t\t\terr := row.ForEachCell(func(cell *Cell) error {\n\t\t\t\tstr, err := cell.FormattedValue()\n\t\t\t\tif err != nil {\n\t\t\t\t\t// Recover from strconv.NumError if the value is an empty string,\n\t\t\t\t\t// and insert an empty string in the output.\n\t\t\t\t\tif numErr, ok := err.(*strconv.NumError); ok && numErr.Num == \"\" {\n\t\t\t\t\t\tstr = \"\"\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr = append(r, str)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\ts = append(s, r)\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\treturn output, err\n\t\t}\n\t\toutput = append(output, s)\n\t}\n\treturn output, nil\n}\n\n// ToSliceUnmerged returns the raw data contained in the File as three\n// dimensional slice (s. method ToSlice).\n// A covered cell become the value of its origin cell.\n// Example: table where A1:A2 at row 0 and row 1 are merged.\n// | 2011        | Bread | 20 |\n// |             | Fish  | 70 |\n// | 2012 | 2013 | Egg   | 80 |\n// This sheet will be converted to the slice:\n// [\n//\n//\t[2011 2011 Bread 20]\n//\t[2011 2011 Fish  70]\n//\t[2012 2013 Egg   80]\n//\n// ]\nfunc (f *File) ToSliceUnmerged() (output [][][]string, err error) {\n\toutput, err = f.ToSlice()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor s, sheet := range f.Sheets {\n\t\terr := sheet.ForEachRow(func(row *Row) error {\n\t\t\treturn row.ForEachCell(func(cell *Cell) error {\n\t\t\t\tif cell.HMerge > 0 || cell.VMerge > 0 {\n\t\t\t\t\tc, r := cell.GetCoordinates()\n\t\t\t\t\tv := output[s][r][c]\n\t\t\t\t\tfor i := r; i <= r+cell.VMerge; i++ {\n\t\t\t\t\t\tfor j := c; j <= c+cell.HMerge; j++ {\n\t\t\t\t\t\t\tif i != r || j != c {\n\t\t\t\t\t\t\t\toutput[s][i][j] = v\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\t\t})\n\t\tif err != nil {\n\t\t\treturn output, err\n\t\t}\n\t}\n\n\treturn output, nil\n}\n\ntype DefinedName xlsxDefinedName\n\n// AddDefinedName adds a new Name definition to the workbook.\nfunc (f *File) AddDefinedName(name DefinedName) error {\n\tdefinedName := xlsxDefinedName(name)\n\tf.DefinedNames = append(f.DefinedNames, &definedName)\n\treturn nil\n}\n"
        },
        {
          "name": "file_test.go",
          "type": "blob",
          "size": 49.9287109375,
          "content": "package xlsx\n\nimport (\n\t\"encoding/xml\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\n// ReaderAtCounter wraps a ReaderAt and counts the number of bytes that are read out of it\ntype ReaderAtCounter struct {\n\treaderAt  io.ReaderAt\n\tbytesRead int\n}\n\nvar _ io.ReaderAt = &ReaderAtCounter{}\n\n// NewReaderAtCounter creates a ReaderAtCounter by opening the file name, and provides the size which is needed for\n// opening as XLSX.\nfunc NewReaderAtCounter(name string) (*ReaderAtCounter, int64, error) {\n\tf, err := os.Open(name)\n\tif err != nil {\n\t\treturn nil, -1, err\n\t}\n\tfi, err := f.Stat()\n\tif err != nil {\n\t\tf.Close()\n\t\treturn nil, -1, err\n\t}\n\treaderAtCounter := &ReaderAtCounter{\n\t\treaderAt: f,\n\t}\n\treturn readerAtCounter, fi.Size(), nil\n}\n\nfunc (r *ReaderAtCounter) ReadAt(p []byte, off int64) (n int, err error) {\n\tn, err = r.readerAt.ReadAt(p, off)\n\tr.bytesRead += n\n\treturn n, err\n}\n\nfunc (r *ReaderAtCounter) GetBytesRead() int {\n\treturn r.bytesRead\n}\n\nfunc TestFile(t *testing.T) {\n\tc := qt.New(t)\n\n\t// Test we can correctly open a XSLX file and return a xlsx.File\n\t// struct.\n\tcsRunO(c, \"TestOpenFile\", func(c *qt.C, option FileOption) {\n\t\tvar xlsxFile *File\n\t\tvar err error\n\n\t\txlsxFile, err = OpenFile(\"./testdocs/testfile.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(xlsxFile, qt.Not(qt.IsNil))\n\t})\n\n\tcsRunO(c, \"TestFileWithEmptyCols\", func(c *qt.C, option FileOption) {\n\t\tf, err := OpenFile(\"./testdocs/empty_rows.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet, ok := f.Sheet[\"EmptyCols\"]\n\t\tc.Assert(ok, qt.Equals, true)\n\n\t\tcell, err := sheet.Cell(0, 0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tif val, err := cell.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"\")\n\t\t}\n\t\tcell, err = sheet.Cell(0, 2)\n\t\tc.Assert(err, qt.Equals, nil)\n\n\t\tif val, err := cell.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"C1\")\n\t\t}\n\t})\n\n\tcsRunO(c, \"TestFileWithEmptyCols\", func(c *qt.C, option FileOption) {\n\t\tf, err := OpenFile(\"./testdocs/empty_rows.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet, ok := f.Sheet[\"EmptyCols\"]\n\t\tc.Assert(ok, qt.Equals, true)\n\n\t\tcell, err := sheet.Cell(0, 0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tif val, err := cell.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"\")\n\t\t}\n\t\tcell, err = sheet.Cell(0, 2)\n\t\tc.Assert(err, qt.Equals, nil)\n\n\t\tif val, err := cell.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"C1\")\n\t\t}\n\t})\n\n\tcsRunO(c, \"TestPartialReadsWithFewSharedStringsOnlyPartiallyReads\", func(c *qt.C, option FileOption) {\n\t\t// This test verifies that a large file is only partially read when using a small row limit.\n\t\t// This file is 11,228,530 bytes, but only 14,020 bytes get read out when using a row limit of 10.\n\t\t// I'm specifying a limit of 20,000 to prevent test flakiness if the bytes read fluctuates with small code changes.\n\t\trowLimit := 10\n\t\t// It is possible that readLimit will need to be increased by a small amount in the future, but do not increase it\n\t\t// to anywhere near a significant amount of 11 million. We're testing that this number is low, to ensure that partial\n\t\t// reads are fast.\n\t\treadLimit := 20 * 1000\n\t\treader, size, err := NewReaderAtCounter(\"testdocs/large_sheet_no_shared_strings_no_dimension_tag.xlsx\")\n\t\tif err != nil {\n\t\t\tc.Fatal(err)\n\t\t}\n\t\tfile, err := OpenReaderAt(reader, size, RowLimit(rowLimit), option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tif reader.bytesRead > readLimit {\n\t\t\t// If this test begins failing, do not increase readLimit dramatically. Instead investigate why the number of\n\t\t\t// bytes read went up and fix this issue.\n\t\t\tc.Errorf(\"Reading %v rows from a sheet with ~31,000 rows and few shared strings read %v bytes, must read less than %v bytes\", rowLimit, reader.bytesRead, readLimit)\n\t\t}\n\t\tif len(file.Sheets) > 0 {\n\t\t\tif file.Sheets[0].MaxRow != rowLimit {\n\t\t\t\tc.Errorf(\"Expected sheet to have %v rows, but found %v rows\", rowLimit, file.Sheets[0].MaxRow)\n\t\t\t}\n\t\t}\n\t})\n\n\tcsRunO(c, \"TestPartialReadsWithLargeSharedStringsOnlyPartiallyReads\", func(c *qt.C, option FileOption) {\n\t\t// This test verifies that a large file is only partially read when using a small row limit.\n\t\t// This file is 7,055,632 bytes, but only 1,092,839 bytes get read out when using a row limit of 10.\n\t\t// I'm specifying a limit of 1.2 MB to prevent test flakiness if the bytes read fluctuates with small code changes.\n\t\t// The reason that this test has a much larger limit than TestPartialReadsWithFewSharedStringsOnlyPartiallyReads\n\t\t// is that this file has a Shared Strings file that is a little over 1 MB.\n\t\trowLimit := 10\n\t\t// It is possible that readLimit will need to be increased by a small amount in the future, but do not increase it\n\t\t// to anywhere near a significant amount of 7 million. We're testing that this number is low, to ensure that partial\n\t\t// reads are fast.\n\t\treadLimit := int(1.2 * 1000 * 1000)\n\t\treader, size, err := NewReaderAtCounter(\"testdocs/large_sheet_large_sharedstrings_dimension_tag.xlsx\")\n\t\tif err != nil {\n\t\t\tc.Fatal(err)\n\t\t}\n\t\tfile, err := OpenReaderAt(reader, size, RowLimit(rowLimit), option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tif reader.bytesRead > readLimit {\n\t\t\t// If this test begins failing, do not increase readLimit dramatically. Instead investigate why the number of\n\t\t\t// bytes read went up and fix this issue.\n\t\t\tc.Errorf(\"Reading %v rows from a sheet with ~31,000 rows and a large shared strings read %v bytes, must read less than %v bytes\", rowLimit, reader.bytesRead, readLimit)\n\t\t}\n\t\t// This is testing that the sheet was truncated, but it is also testing that the dimension tag was ignored.\n\t\t// If the dimension tag is not correctly ignored, there will be 10 rows of the data, plus ~31k empty rows tacked on.\n\t\tif file.Sheets[0].MaxRow != rowLimit {\n\t\t\tc.Errorf(\"Expected sheet to have %v rows, but found %v rows\", rowLimit, file.Sheets[0].MaxRow)\n\t\t}\n\t})\n\n\tcsRunO(c, \"TestPartialReadsWithFewerRowsThanRequested\", func(c *qt.C, option FileOption) {\n\t\trowLimit := 10\n\t\tfile, err := OpenFile(\"testdocs/testfile.xlsx\", RowLimit(rowLimit), option)\n\t\tif err != nil {\n\t\t\tc.Fatal(err)\n\t\t}\n\t\tif file.Sheets[0].MaxRow != 2 {\n\t\t\tc.Errorf(\"Expected sheet to have %v rows, but found %v rows\", 2, file.Sheets[0].MaxRow)\n\t\t}\n\t})\n\n\tcsRunO(c, \"TestPartialReadsWithXmlNamespacePrefix\", func(c *qt.C, option FileOption) {\n\t\tf, err := OpenFile(\"testdocs/namespaced.xlsx\", RowLimit(1))\n\t\tif err != nil {\n\t\t\tc.Fatal(err)\n\t\t}\n\t\tc.Assert(f.Sheets[0].MaxRow, qt.Equals, 1)\n\t})\n\n\tcsRunO(c, \"TestOpenFileWithoutStyleAndSharedStrings\", func(c *qt.C, option FileOption) {\n\t\tvar xlsxFile *File\n\t\tvar error error\n\n\t\txlsxFile, error = OpenFile(\"./testdocs/noStylesAndSharedStringsTest.xlsx\", option)\n\t\tc.Assert(error, qt.IsNil)\n\t\tc.Assert(xlsxFile, qt.Not(qt.IsNil))\n\t})\n\n\tcsRunO(c, \"TestOpenFileWithChartsheet\", func(c *qt.C, option FileOption) {\n\t\txlsxFile, error := OpenFile(\"./testdocs/testchartsheet.xlsx\", option)\n\t\tc.Assert(error, qt.IsNil)\n\t\tc.Assert(xlsxFile, qt.Not(qt.IsNil))\n\t})\n\n\t// Test that we can correctly extract a reference table from the\n\t// sharedStrings.xml file embedded in the XLSX file and return a\n\t// reference table of string values from it.\n\tcsRunO(c, \"TestReadSharedStringsFromZipFile\", func(c *qt.C, option FileOption) {\n\t\tvar xlsxFile *File\n\t\tvar err error\n\t\txlsxFile, err = OpenFile(\"./testdocs/testfile.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(xlsxFile.referenceTable, qt.Not(qt.IsNil))\n\t})\n\n\t// We can correctly extract a style table from the style.xml file\n\t// embedded in the XLSX file and return a styles struct from it.\n\tcsRunO(c, \"TestReadStylesFromZipFile\", func(c *qt.C, option FileOption) {\n\t\tvar xlsxFile *File\n\t\tvar err error\n\t\tvar fontCount, fillCount, borderCount, cellStyleXfCount, cellXfCount int\n\t\tvar font xlsxFont\n\t\tvar fill xlsxFill\n\t\tvar border xlsxBorder\n\t\tvar xf xlsxXf\n\n\t\txlsxFile, err = OpenFile(\"./testdocs/testfile.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(xlsxFile.styles, qt.Not(qt.IsNil))\n\n\t\tfontCount = len(xlsxFile.styles.Fonts.Font)\n\t\tc.Assert(fontCount, qt.Equals, 4)\n\n\t\tfont = xlsxFile.styles.Fonts.Font[0]\n\t\tc.Assert(font.Sz.Val, qt.Equals, \"11\")\n\t\tc.Assert(font.Name.Val, qt.Equals, \"Calibri\")\n\n\t\tfillCount = xlsxFile.styles.Fills.Count\n\t\tc.Assert(fillCount, qt.Equals, 3)\n\n\t\tfill = xlsxFile.styles.Fills.Fill[2]\n\t\tc.Assert(fill.PatternFill.PatternType, qt.Equals, \"solid\")\n\n\t\tborderCount = xlsxFile.styles.Borders.Count\n\t\tc.Assert(borderCount, qt.Equals, 2)\n\n\t\tborder = xlsxFile.styles.Borders.Border[1]\n\t\tc.Assert(border.Left.Style, qt.Equals, \"thin\")\n\t\tc.Assert(border.Right.Style, qt.Equals, \"thin\")\n\t\tc.Assert(border.Top.Style, qt.Equals, \"thin\")\n\t\tc.Assert(border.Bottom.Style, qt.Equals, \"thin\")\n\n\t\tcellStyleXfCount = xlsxFile.styles.CellStyleXfs.Count\n\t\tc.Assert(cellStyleXfCount, qt.Equals, 20)\n\n\t\txf = xlsxFile.styles.CellStyleXfs.Xf[0]\n\t\texpectedXf := &xlsxXf{\n\t\t\tApplyAlignment:  true,\n\t\t\tApplyBorder:     true,\n\t\t\tApplyFont:       true,\n\t\t\tApplyFill:       false,\n\t\t\tApplyProtection: true,\n\t\t\tBorderId:        0,\n\t\t\tFillId:          0,\n\t\t\tFontId:          0,\n\t\t\tNumFmtId:        164}\n\t\ttestXf(c, &xf, expectedXf)\n\n\t\tc.Assert(xf.Alignment, qt.Not(qt.IsNil))\n\t\tc.Assert(xf.Alignment.Horizontal, qt.Equals, \"general\")\n\t\tc.Assert(xf.Alignment.Indent, qt.Equals, 0)\n\t\tc.Assert(xf.Alignment.ShrinkToFit, qt.Equals, false)\n\t\tc.Assert(xf.Alignment.TextRotation, qt.Equals, 0)\n\t\tc.Assert(xf.Alignment.Vertical, qt.Equals, \"bottom\")\n\t\tc.Assert(xf.Alignment.WrapText, qt.Equals, false)\n\n\t\tcellXfCount = xlsxFile.styles.CellXfs.Count\n\t\tc.Assert(cellXfCount, qt.Equals, 3)\n\n\t\txf = xlsxFile.styles.CellXfs.Xf[0]\n\t\texpectedXf = &xlsxXf{\n\t\t\tApplyAlignment:  false,\n\t\t\tApplyBorder:     false,\n\t\t\tApplyFont:       false,\n\t\t\tApplyFill:       false,\n\t\t\tApplyProtection: false,\n\t\t\tBorderId:        0,\n\t\t\tFillId:          0,\n\t\t\tFontId:          0,\n\t\t\tNumFmtId:        164}\n\t\ttestXf(c, &xf, expectedXf)\n\t})\n\n\t// We can correctly extract a map of relationship Ids to the worksheet files in\n\t// which they are contained from the XLSX file.\n\tcsRunO(c, \"TestReadWorkbookRelationsFromZipFile\", func(c *qt.C, option FileOption) {\n\t\tvar xlsxFile *File\n\t\tvar err error\n\n\t\txlsxFile, err = OpenFile(\"./testdocs/testfile.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(len(xlsxFile.Sheets), qt.Equals, 3)\n\t\tsheet, ok := xlsxFile.Sheet[\"Tabelle1\"]\n\t\tc.Assert(ok, qt.Equals, true)\n\t\tc.Assert(sheet, qt.Not(qt.IsNil))\n\t})\n\n\t// Test we can create a File object from scratch\n\tcsRunO(c, \"TestCreateFile\", func(c *qt.C, option FileOption) {\n\t\txlsxFile := NewFile(option)\n\t\tc.Assert(xlsxFile, qt.Not(qt.IsNil))\n\t})\n\n\t// Test that when we open a real XLSX file we create xlsx.Sheet\n\t// objects for the sheets inside the file and that these sheets are\n\t// themselves correct.\n\tcsRunO(c, \"TestCreateSheet\", func(c *qt.C, option FileOption) {\n\t\tvar xlsxFile *File\n\t\tvar err error\n\t\tvar sheet *Sheet\n\t\tvar row *Row\n\t\txlsxFile, err = OpenFile(\"./testdocs/testfile.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(xlsxFile, qt.Not(qt.IsNil))\n\t\tsheetLen := len(xlsxFile.Sheets)\n\t\tc.Assert(sheetLen, qt.Equals, 3)\n\t\tsheet = xlsxFile.Sheet[\"Tabelle1\"]\n\t\trowLen := sheet.MaxRow\n\t\tc.Assert(rowLen, qt.Equals, 2)\n\t\trow, err = sheet.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\t// c.Assert(row.cellCount, qt.Equals, 2)\n\t\tcell := row.GetCell(0)\n\t\tif val, err := cell.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"Foo\")\n\t\t}\n\t})\n\n\t// Test that we can add a sheet to a File\n\tcsRunO(c, \"TestAddSheet\", func(c *qt.C, option FileOption) {\n\t\tf := NewFile(option)\n\t\tsheet, err := f.AddSheet(\"MySheet\")\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(sheet, qt.Not(qt.IsNil))\n\t\tc.Assert(len(f.Sheets), qt.Equals, 1)\n\t\tc.Assert(f.Sheet[\"MySheet\"], qt.Equals, sheet)\n\t})\n\n\t// Test that AddSheet returns an error if you try to add two sheets with the same name\n\tcsRunO(c, \"TestAddSheetWithDuplicateName\", func(c *qt.C, option FileOption) {\n\t\tf := NewFile(option)\n\t\t_, err := f.AddSheet(\"MySheet\")\n\t\tc.Assert(err, qt.IsNil)\n\t\t_, err = f.AddSheet(\"MySheet\")\n\t\tc.Assert(err.Error(), qt.Equals, \"duplicate sheet name 'MySheet'\")\n\t})\n\n\t// Test that AddSheet returns an error if you try to add sheet with name as empty string\n\tcsRunO(c, \"TestAddSheetWithEmptyName\", func(c *qt.C, option FileOption) {\n\t\tf := NewFile(option)\n\t\t_, err := f.AddSheet(\"\")\n\t\tc.Assert(err.Error(), qt.Contains, \"sheet name must be 31 or fewer characters long.  It is currently '0' characters long\")\n\t})\n\n\t// Test that we can append a sheet to a File\n\tcsRunO(c, \"TestAppendSheet\", func(c *qt.C, option FileOption) {\n\t\tf := NewFile(option)\n\t\ts := Sheet{}\n\t\tsheet, err := f.AppendSheet(s, \"MySheet\")\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(sheet, qt.Not(qt.IsNil))\n\t\tc.Assert(len(f.Sheets), qt.Equals, 1)\n\t\tc.Assert(f.Sheet[\"MySheet\"], qt.Equals, sheet)\n\t})\n\n\t// Test that AppendSheet returns an error if you try to add two sheets with the same name\n\tcsRunO(c, \"TestAppendSheetWithDuplicateName\", func(c *qt.C, option FileOption) {\n\t\tf := NewFile(option)\n\t\ts := Sheet{}\n\t\t_, err := f.AppendSheet(s, \"MySheet\")\n\t\tc.Assert(err, qt.IsNil)\n\t\t_, err = f.AppendSheet(s, \"MySheet\")\n\t\tc.Assert(err.Error(), qt.Equals, \"duplicate sheet name 'MySheet'\")\n\t})\n\n\t// Test that AppendSheet  doesn't lose rows because of a change  in the sheet name (this really occurred see https://github.com/tealeg/xlsx/issues/783 )\n\tcsRunO(c, \"TestAppendSheetWithNewSheetNameDoesNotLoseRows\", func(c *qt.C, option FileOption) {\n\n\t\tsourceFile, err := OpenFile(\"./testdocs/original.xlsx\")\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(len(sourceFile.Sheets), qt.Equals, 1)\n\t\ts := sourceFile.Sheets[0]\n\n\t\tf := NewFile(option)\n\t\t_, err = f.AppendSheet(*s, \"Dave\")\n\t\tc.Assert(err, qt.IsNil)\n\n\t\ttmp := c.TempDir()\n\t\tp := filepath.Join(tmp, \"blokes.xlsx\")\n\t\terr = f.Save(p)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tblokes, err := OpenFile(p)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tdave := blokes.Sheets[0]\n\t\tif dave.currentRow != nil {\n\t\t\tc.Assert(dave.cellStore.WriteRow(dave.currentRow), qt.IsNil)\n\t\t}\n\t\tcell, err := dave.Cell(0, 0)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(cell.String(), qt.Equals, \"Column A\")\n\n\t})\n\n\t// Test that we can read & create a 31 rune sheet name\n\tcsRunO(c, \"TestMaxSheetNameLength\", func(c *qt.C, option FileOption) {\n\t\t// Open a genuine xlsx created by Microsoft Excel 2007\n\t\txlsxFile, err := OpenFile(\"./testdocs/max_sheet_name_length.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(xlsxFile, qt.Not(qt.IsNil))\n\t\tc.Assert(xlsxFile.Sheets[0].Name, qt.Equals, \"αααααβββββγγγγγδδδδδεεεεεζζζζζη\")\n\t\t// Create a new file with the same sheet name\n\t\tf := NewFile(option)\n\t\ts, err := f.AddSheet(xlsxFile.Sheets[0].Name)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(s.Name, qt.Equals, \"αααααβββββγγγγγδδδδδεεεεεζζζζζη\")\n\t})\n\n\t// Test that we can get the Nth sheet\n\tcsRunO(c, \"TestNthSheet\", func(c *qt.C, option FileOption) {\n\t\tf := NewFile(option)\n\t\tsheet, _ := f.AddSheet(\"MySheet\")\n\t\tsheetByIndex := f.Sheets[0]\n\t\tsheetByName := f.Sheet[\"MySheet\"]\n\t\tc.Assert(sheetByIndex, qt.Not(qt.IsNil))\n\t\tc.Assert(sheetByIndex, qt.Equals, sheet)\n\t\tc.Assert(sheetByIndex, qt.Equals, sheetByName)\n\t})\n\n\t// Test invalid sheet name characters\n\tcsRunO(c, \"TestInvalidSheetNameCharacters\", func(c *qt.C, option FileOption) {\n\t\tf := NewFile(option)\n\t\tfor _, invalidChar := range []string{\":\", \"\\\\\", \"/\", \"?\", \"*\", \"[\", \"]\"} {\n\t\t\t_, err := f.AddSheet(invalidChar)\n\t\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t\t}\n\t})\n\n\t// Test that we can create a Workbook and marshal it to XML.\n\tcsRunO(c, \"TestMarshalWorkbook\", func(c *qt.C, option FileOption) {\n\t\tf := NewFile(option)\n\n\t\tf.AddSheet(\"MyFirstSheet\")\n\t\tf.AddSheet(\"MySecondSheet\")\n\t\tworkbook := f.makeWorkbook()\n\t\tworkbook.Sheets.Sheet[0] = xlsxSheet{\n\t\t\tName:    \"MyFirstSheet\",\n\t\t\tSheetId: \"1\",\n\t\t\tId:      \"rId1\",\n\t\t\tState:   \"visible\"}\n\n\t\tworkbook.Sheets.Sheet[1] = xlsxSheet{\n\t\t\tName:    \"MySecondSheet\",\n\t\t\tSheetId: \"2\",\n\t\t\tId:      \"rId2\",\n\t\t\tState:   \"visible\"}\n\n\t\texpectedWorkbook := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"><fileVersion appName=\"Go XLSX\"></fileVersion><workbookPr showObjects=\"all\" date1904=\"false\"></workbookPr><workbookProtection></workbookProtection><bookViews><workbookView showHorizontalScroll=\"true\" showVerticalScroll=\"true\" showSheetTabs=\"true\" tabRatio=\"204\" windowHeight=\"8192\" windowWidth=\"16384\" xWindow=\"0\" yWindow=\"0\"></workbookView></bookViews><sheets><sheet name=\"MyFirstSheet\" sheetId=\"1\" r:id=\"rId1\" state=\"visible\"></sheet><sheet name=\"MySecondSheet\" sheetId=\"2\" r:id=\"rId2\" state=\"visible\"></sheet></sheets><definedNames></definedNames><calcPr iterateCount=\"100\" refMode=\"A1\" iterateDelta=\"0.001\"></calcPr></workbook>`\n\t\toutput, err := xml.Marshal(workbook)\n\t\tc.Assert(err, qt.IsNil)\n\t\toutputStr := replaceRelationshipsNameSpace(string(output))\n\t\tstringOutput := xml.Header + outputStr\n\t\tc.Assert(stringOutput, qt.Equals, expectedWorkbook)\n\t})\n\n\t// Test that we can marshall a File to a collection of xml files\n\tcsRunO(c, \"TestMarshalFile\", func(c *qt.C, option FileOption) {\n\t\tf := NewFile(option)\n\t\tsheet1, _ := f.AddSheet(\"MySheet\")\n\t\trow1 := sheet1.AddRow()\n\t\tcell1 := row1.AddCell()\n\t\tcell1.SetString(\"A cell!\")\n\t\tsheet2, _ := f.AddSheet(\"AnotherSheet\")\n\t\trow2 := sheet2.AddRow()\n\t\tcell2 := row2.AddCell()\n\t\tcell2.SetString(\"A cell!\")\n\t\tparts, err := f.MakeStreamParts()\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(len(parts), qt.Equals, 11)\n\n\t\t// sheets\n\t\texpectedSheet1 := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"><sheetPr filterMode=\"false\"><pageSetUpPr fitToPage=\"false\"></pageSetUpPr></sheetPr><dimension ref=\"A1\"></dimension><sheetViews><sheetView windowProtection=\"false\" showFormulas=\"false\" showGridLines=\"true\" showRowColHeaders=\"true\" showZeros=\"true\" rightToLeft=\"false\" tabSelected=\"true\" showOutlineSymbols=\"true\" defaultGridColor=\"true\" view=\"normal\" topLeftCell=\"A1\" colorId=\"64\" zoomScale=\"100\" zoomScaleNormal=\"100\" zoomScalePageLayoutView=\"100\" workbookViewId=\"0\"><selection pane=\"topLeft\" activeCell=\"A1\" activeCellId=\"0\" sqref=\"A1\"></selection></sheetView></sheetViews><sheetFormatPr defaultRowHeight=\"12.85\"></sheetFormatPr><sheetData><row r=\"1\"><c r=\"A1\" t=\"s\"><v>0</v></c></row></sheetData></worksheet>`\n\t\tc.Assert(parts[\"xl/worksheets/sheet1.xml\"], qt.Equals, expectedSheet1)\n\n\t\texpectedSheet2 := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"><sheetPr filterMode=\"false\"><pageSetUpPr fitToPage=\"false\"></pageSetUpPr></sheetPr><dimension ref=\"A1\"></dimension><sheetViews><sheetView windowProtection=\"false\" showFormulas=\"false\" showGridLines=\"true\" showRowColHeaders=\"true\" showZeros=\"true\" rightToLeft=\"false\" tabSelected=\"false\" showOutlineSymbols=\"true\" defaultGridColor=\"true\" view=\"normal\" topLeftCell=\"A1\" colorId=\"64\" zoomScale=\"100\" zoomScaleNormal=\"100\" zoomScalePageLayoutView=\"100\" workbookViewId=\"0\"><selection pane=\"topLeft\" activeCell=\"A1\" activeCellId=\"0\" sqref=\"A1\"></selection></sheetView></sheetViews><sheetFormatPr defaultRowHeight=\"12.85\"></sheetFormatPr><sheetData><row r=\"1\"><c r=\"A1\" t=\"s\"><v>0</v></c></row></sheetData></worksheet>`\n\t\tc.Assert(parts[\"xl/worksheets/sheet2.xml\"], qt.Equals, expectedSheet2)\n\n\t\t// .rels.xml\n\t\texpectedRels := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\n  <Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\" Target=\"xl/workbook.xml\"/>\n  <Relationship Id=\"rId2\" Type=\"http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties\" Target=\"docProps/core.xml\"/>\n  <Relationship Id=\"rId3\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties\" Target=\"docProps/app.xml\"/>\n</Relationships>`\n\t\tc.Assert(parts[\"_rels/.rels\"], qt.Equals, expectedRels)\n\n\t\t// app.xml\n\t\texpectedApp := `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<Properties xmlns=\"http://schemas.openxmlformats.org/officeDocument/2006/extended-properties\" xmlns:vt=\"http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes\">\n  <TotalTime>0</TotalTime>\n  <Application>Go XLSX</Application>\n</Properties>`\n\t\tc.Assert(parts[\"docProps/app.xml\"], qt.Equals, expectedApp)\n\n\t\t// core.xml\n\t\texpectedCore := `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<cp:coreProperties xmlns:cp=\"http://schemas.openxmlformats.org/package/2006/metadata/core-properties\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:dcmitype=\"http://purl.org/dc/dcmitype/\" xmlns:dcterms=\"http://purl.org/dc/terms/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"></cp:coreProperties>`\n\t\tc.Assert(parts[\"docProps/core.xml\"], qt.Equals, expectedCore)\n\n\t\t// theme1.xml\n\t\texpectedTheme := `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<a:theme xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" name=\"Office-Design\">\n  <a:themeElements>\n    <a:clrScheme name=\"Office\">\n      <a:dk1>\n        <a:sysClr val=\"windowText\" lastClr=\"000000\"/>\n      </a:dk1>\n      <a:lt1>\n        <a:sysClr val=\"window\" lastClr=\"FFFFFF\"/>\n      </a:lt1>\n      <a:dk2>\n        <a:srgbClr val=\"1F497D\"/>\n      </a:dk2>\n      <a:lt2>\n        <a:srgbClr val=\"EEECE1\"/>\n      </a:lt2>\n      <a:accent1>\n        <a:srgbClr val=\"4F81BD\"/>\n      </a:accent1>\n      <a:accent2>\n        <a:srgbClr val=\"C0504D\"/>\n      </a:accent2>\n      <a:accent3>\n        <a:srgbClr val=\"9BBB59\"/>\n      </a:accent3>\n      <a:accent4>\n        <a:srgbClr val=\"8064A2\"/>\n      </a:accent4>\n      <a:accent5>\n        <a:srgbClr val=\"4BACC6\"/>\n      </a:accent5>\n      <a:accent6>\n        <a:srgbClr val=\"F79646\"/>\n      </a:accent6>\n      <a:hlink>\n        <a:srgbClr val=\"0000FF\"/>\n      </a:hlink>\n      <a:folHlink>\n        <a:srgbClr val=\"800080\"/>\n      </a:folHlink>\n    </a:clrScheme>\n    <a:fontScheme name=\"Office\">\n      <a:majorFont>\n        <a:latin typeface=\"Cambria\"/>\n        <a:ea typeface=\"\"/>\n        <a:cs typeface=\"\"/>\n        <a:font script=\"Jpan\" typeface=\"ＭＳ Ｐゴシック\"/>\n        <a:font script=\"Hang\" typeface=\"맑은 고딕\"/>\n        <a:font script=\"Hans\" typeface=\"宋体\"/>\n        <a:font script=\"Hant\" typeface=\"新細明體\"/>\n        <a:font script=\"Arab\" typeface=\"Times New Roman\"/>\n        <a:font script=\"Hebr\" typeface=\"Times New Roman\"/>\n        <a:font script=\"Thai\" typeface=\"Tahoma\"/>\n        <a:font script=\"Ethi\" typeface=\"Nyala\"/>\n        <a:font script=\"Beng\" typeface=\"Vrinda\"/>\n        <a:font script=\"Gujr\" typeface=\"Shruti\"/>\n        <a:font script=\"Khmr\" typeface=\"MoolBoran\"/>\n        <a:font script=\"Knda\" typeface=\"Tunga\"/>\n        <a:font script=\"Guru\" typeface=\"Raavi\"/>\n        <a:font script=\"Cans\" typeface=\"Euphemia\"/>\n        <a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/>\n        <a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/>\n        <a:font script=\"Tibt\" typeface=\"Microsoft Himalaya\"/>\n        <a:font script=\"Thaa\" typeface=\"MV Boli\"/>\n        <a:font script=\"Deva\" typeface=\"Mangal\"/>\n        <a:font script=\"Telu\" typeface=\"Gautami\"/>\n        <a:font script=\"Taml\" typeface=\"Latha\"/>\n        <a:font script=\"Syrc\" typeface=\"Estrangelo Edessa\"/>\n        <a:font script=\"Orya\" typeface=\"Kalinga\"/>\n        <a:font script=\"Mlym\" typeface=\"Kartika\"/>\n        <a:font script=\"Laoo\" typeface=\"DokChampa\"/>\n        <a:font script=\"Sinh\" typeface=\"Iskoola Pota\"/>\n        <a:font script=\"Mong\" typeface=\"Mongolian Baiti\"/>\n        <a:font script=\"Viet\" typeface=\"Times New Roman\"/>\n        <a:font script=\"Uigh\" typeface=\"Microsoft Uighur\"/>\n        <a:font script=\"Geor\" typeface=\"Sylfaen\"/>\n      </a:majorFont>\n      <a:minorFont>\n        <a:latin typeface=\"Arial\"/>\n        <a:ea typeface=\"\"/>\n        <a:cs typeface=\"\"/>\n        <a:font script=\"Jpan\" typeface=\"ＭＳ Ｐゴシック\"/>\n        <a:font script=\"Hang\" typeface=\"맑은 고딕\"/>\n        <a:font script=\"Hans\" typeface=\"宋体\"/>\n        <a:font script=\"Hant\" typeface=\"新細明體\"/>\n        <a:font script=\"Arab\" typeface=\"Arial\"/>\n        <a:font script=\"Hebr\" typeface=\"Arial\"/>\n        <a:font script=\"Thai\" typeface=\"Tahoma\"/>\n        <a:font script=\"Ethi\" typeface=\"Nyala\"/>\n        <a:font script=\"Beng\" typeface=\"Vrinda\"/>\n        <a:font script=\"Gujr\" typeface=\"Shruti\"/>\n        <a:font script=\"Khmr\" typeface=\"DaunPenh\"/>\n        <a:font script=\"Knda\" typeface=\"Tunga\"/>\n        <a:font script=\"Guru\" typeface=\"Raavi\"/>\n        <a:font script=\"Cans\" typeface=\"Euphemia\"/>\n        <a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/>\n        <a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/>\n        <a:font script=\"Tibt\" typeface=\"Microsoft Himalaya\"/>\n        <a:font script=\"Thaa\" typeface=\"MV Boli\"/>\n        <a:font script=\"Deva\" typeface=\"Mangal\"/>\n        <a:font script=\"Telu\" typeface=\"Gautami\"/>\n        <a:font script=\"Taml\" typeface=\"Latha\"/>\n        <a:font script=\"Syrc\" typeface=\"Estrangelo Edessa\"/>\n        <a:font script=\"Orya\" typeface=\"Kalinga\"/>\n        <a:font script=\"Mlym\" typeface=\"Kartika\"/>\n        <a:font script=\"Laoo\" typeface=\"DokChampa\"/>\n        <a:font script=\"Sinh\" typeface=\"Iskoola Pota\"/>\n        <a:font script=\"Mong\" typeface=\"Mongolian Baiti\"/>\n        <a:font script=\"Viet\" typeface=\"Arial\"/>\n        <a:font script=\"Uigh\" typeface=\"Microsoft Uighur\"/>\n        <a:font script=\"Geor\" typeface=\"Sylfaen\"/>\n      </a:minorFont>\n    </a:fontScheme>\n    <a:fmtScheme name=\"Office\">\n      <a:fillStyleLst>\n        <a:solidFill>\n          <a:schemeClr val=\"phClr\"/>\n        </a:solidFill>\n        <a:gradFill rotWithShape=\"1\">\n          <a:gsLst>\n            <a:gs pos=\"0\">\n              <a:schemeClr val=\"phClr\">\n                <a:tint val=\"50000\"/>\n                <a:satMod val=\"300000\"/>\n              </a:schemeClr>\n            </a:gs>\n            <a:gs pos=\"35000\">\n              <a:schemeClr val=\"phClr\">\n                <a:tint val=\"37000\"/>\n                <a:satMod val=\"300000\"/>\n              </a:schemeClr>\n            </a:gs>\n            <a:gs pos=\"100000\">\n              <a:schemeClr val=\"phClr\">\n                <a:tint val=\"15000\"/>\n                <a:satMod val=\"350000\"/>\n              </a:schemeClr>\n            </a:gs>\n          </a:gsLst>\n          <a:lin ang=\"16200000\" scaled=\"1\"/>\n        </a:gradFill>\n        <a:gradFill rotWithShape=\"1\">\n          <a:gsLst>\n            <a:gs pos=\"0\">\n              <a:schemeClr val=\"phClr\">\n                <a:tint val=\"100000\"/>\n                <a:shade val=\"100000\"/>\n                <a:satMod val=\"130000\"/>\n              </a:schemeClr>\n            </a:gs>\n            <a:gs pos=\"100000\">\n              <a:schemeClr val=\"phClr\">\n                <a:tint val=\"50000\"/>\n                <a:shade val=\"100000\"/>\n                <a:satMod val=\"350000\"/>\n              </a:schemeClr>\n            </a:gs>\n          </a:gsLst>\n          <a:lin ang=\"16200000\" scaled=\"0\"/>\n        </a:gradFill>\n      </a:fillStyleLst>\n      <a:lnStyleLst>\n        <a:ln w=\"9525\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\">\n          <a:solidFill>\n            <a:schemeClr val=\"phClr\">\n              <a:shade val=\"95000\"/>\n              <a:satMod val=\"105000\"/>\n            </a:schemeClr>\n          </a:solidFill>\n          <a:prstDash val=\"solid\"/>\n        </a:ln>\n        <a:ln w=\"25400\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\">\n          <a:solidFill>\n            <a:schemeClr val=\"phClr\"/>\n          </a:solidFill>\n          <a:prstDash val=\"solid\"/>\n        </a:ln>\n        <a:ln w=\"38100\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\">\n          <a:solidFill>\n            <a:schemeClr val=\"phClr\"/>\n          </a:solidFill>\n          <a:prstDash val=\"solid\"/>\n        </a:ln>\n      </a:lnStyleLst>\n      <a:effectStyleLst>\n        <a:effectStyle>\n          <a:effectLst>\n            <a:outerShdw blurRad=\"40000\" dist=\"20000\" dir=\"5400000\" rotWithShape=\"0\">\n              <a:srgbClr val=\"000000\">\n                <a:alpha val=\"38000\"/>\n              </a:srgbClr>\n            </a:outerShdw>\n          </a:effectLst>\n        </a:effectStyle>\n        <a:effectStyle>\n          <a:effectLst>\n            <a:outerShdw blurRad=\"40000\" dist=\"23000\" dir=\"5400000\" rotWithShape=\"0\">\n              <a:srgbClr val=\"000000\">\n                <a:alpha val=\"35000\"/>\n              </a:srgbClr>\n            </a:outerShdw>\n          </a:effectLst>\n        </a:effectStyle>\n        <a:effectStyle>\n          <a:effectLst>\n            <a:outerShdw blurRad=\"40000\" dist=\"23000\" dir=\"5400000\" rotWithShape=\"0\">\n              <a:srgbClr val=\"000000\">\n                <a:alpha val=\"35000\"/>\n              </a:srgbClr>\n            </a:outerShdw>\n          </a:effectLst>\n          <a:scene3d>\n            <a:camera prst=\"orthographicFront\">\n              <a:rot lat=\"0\" lon=\"0\" rev=\"0\"/>\n            </a:camera>\n            <a:lightRig rig=\"threePt\" dir=\"t\">\n              <a:rot lat=\"0\" lon=\"0\" rev=\"1200000\"/>\n            </a:lightRig>\n          </a:scene3d>\n          <a:sp3d>\n            <a:bevelT w=\"63500\" h=\"25400\"/>\n          </a:sp3d>\n        </a:effectStyle>\n      </a:effectStyleLst>\n      <a:bgFillStyleLst>\n        <a:solidFill>\n          <a:schemeClr val=\"phClr\"/>\n        </a:solidFill>\n        <a:gradFill rotWithShape=\"1\">\n          <a:gsLst>\n            <a:gs pos=\"0\">\n              <a:schemeClr val=\"phClr\">\n                <a:tint val=\"40000\"/>\n                <a:satMod val=\"350000\"/>\n              </a:schemeClr>\n            </a:gs>\n            <a:gs pos=\"40000\">\n              <a:schemeClr val=\"phClr\">\n                <a:tint val=\"45000\"/>\n                <a:shade val=\"99000\"/>\n                <a:satMod val=\"350000\"/>\n              </a:schemeClr>\n            </a:gs>\n            <a:gs pos=\"100000\">\n              <a:schemeClr val=\"phClr\">\n                <a:shade val=\"20000\"/>\n                <a:satMod val=\"255000\"/>\n              </a:schemeClr>\n            </a:gs>\n          </a:gsLst>\n          <a:path path=\"circle\">\n            <a:fillToRect l=\"50000\" t=\"-80000\" r=\"50000\" b=\"180000\"/>\n          </a:path>\n        </a:gradFill>\n        <a:gradFill rotWithShape=\"1\">\n          <a:gsLst>\n            <a:gs pos=\"0\">\n              <a:schemeClr val=\"phClr\">\n                <a:tint val=\"80000\"/>\n                <a:satMod val=\"300000\"/>\n              </a:schemeClr>\n            </a:gs>\n            <a:gs pos=\"100000\">\n              <a:schemeClr val=\"phClr\">\n                <a:shade val=\"30000\"/>\n                <a:satMod val=\"200000\"/>\n              </a:schemeClr>\n            </a:gs>\n          </a:gsLst>\n          <a:path path=\"circle\">\n            <a:fillToRect l=\"50000\" t=\"50000\" r=\"50000\" b=\"50000\"/>\n          </a:path>\n        </a:gradFill>\n      </a:bgFillStyleLst>\n    </a:fmtScheme>\n  </a:themeElements>\n  <a:objectDefaults>\n    <a:spDef>\n      <a:spPr/>\n      <a:bodyPr/>\n      <a:lstStyle/>\n      <a:style>\n        <a:lnRef idx=\"1\">\n          <a:schemeClr val=\"accent1\"/>\n        </a:lnRef>\n        <a:fillRef idx=\"3\">\n          <a:schemeClr val=\"accent1\"/>\n        </a:fillRef>\n        <a:effectRef idx=\"2\">\n          <a:schemeClr val=\"accent1\"/>\n        </a:effectRef>\n        <a:fontRef idx=\"minor\">\n          <a:schemeClr val=\"lt1\"/>\n        </a:fontRef>\n      </a:style>\n    </a:spDef>\n    <a:lnDef>\n      <a:spPr/>\n      <a:bodyPr/>\n      <a:lstStyle/>\n      <a:style>\n        <a:lnRef idx=\"2\">\n          <a:schemeClr val=\"accent1\"/>\n        </a:lnRef>\n        <a:fillRef idx=\"0\">\n          <a:schemeClr val=\"accent1\"/>\n        </a:fillRef>\n        <a:effectRef idx=\"1\">\n          <a:schemeClr val=\"accent1\"/>\n        </a:effectRef>\n        <a:fontRef idx=\"minor\">\n          <a:schemeClr val=\"tx1\"/>\n        </a:fontRef>\n      </a:style>\n    </a:lnDef>\n  </a:objectDefaults>\n  <a:extraClrSchemeLst/>\n</a:theme>`\n\t\tc.Assert(parts[\"xl/theme/theme1.xml\"], qt.Equals, expectedTheme)\n\n\t\t// sharedStrings.xml\n\t\texpectedXLSXSST := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"1\" uniqueCount=\"1\"><si><t>A cell!</t></si></sst>`\n\t\tc.Assert(parts[\"xl/sharedStrings.xml\"], qt.Equals, expectedXLSXSST)\n\n\t\t// workbook.xml.rels\n\t\texpectedXLSXWorkbookRels := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\"><Relationship Id=\"rId1\" Target=\"worksheets/sheet1.xml\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\"></Relationship><Relationship Id=\"rId2\" Target=\"worksheets/sheet2.xml\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\"></Relationship><Relationship Id=\"rId3\" Target=\"sharedStrings.xml\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings\"></Relationship><Relationship Id=\"rId4\" Target=\"theme/theme1.xml\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme\"></Relationship><Relationship Id=\"rId5\" Target=\"styles.xml\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles\"></Relationship></Relationships>`\n\t\tc.Assert(parts[\"xl/_rels/workbook.xml.rels\"], qt.Equals, expectedXLSXWorkbookRels)\n\n\t\t// workbook.xml\n\t\t// Note that the following XML snippet is just pasted in here to correspond to the hack\n\t\t// added in file.go to support Apple Numbers so the test passes.\n\t\t// `xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"`\n\t\texpectedWorkbook := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"><fileVersion appName=\"Go XLSX\"></fileVersion><workbookPr showObjects=\"all\" date1904=\"false\"></workbookPr><workbookProtection></workbookProtection><bookViews><workbookView showHorizontalScroll=\"true\" showVerticalScroll=\"true\" showSheetTabs=\"true\" tabRatio=\"204\" windowHeight=\"8192\" windowWidth=\"16384\" xWindow=\"0\" yWindow=\"0\"></workbookView></bookViews><sheets><sheet name=\"MySheet\" sheetId=\"1\" r:id=\"rId1\" state=\"visible\"></sheet><sheet name=\"AnotherSheet\" sheetId=\"2\" r:id=\"rId2\" state=\"visible\"></sheet></sheets><definedNames></definedNames><calcPr iterateCount=\"100\" refMode=\"A1\" iterateDelta=\"0.001\"></calcPr></workbook>`\n\t\tc.Assert(parts[\"xl/workbook.xml\"], qt.Equals, expectedWorkbook)\n\n\t\t// [Content_Types].xml\n\t\texpectedContentTypes := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Types xmlns=\"http://schemas.openxmlformats.org/package/2006/content-types\"><Override PartName=\"/_rels/.rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\"></Override><Override PartName=\"/docProps/app.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.extended-properties+xml\"></Override><Override PartName=\"/docProps/core.xml\" ContentType=\"application/vnd.openxmlformats-package.core-properties+xml\"></Override><Override PartName=\"/xl/_rels/workbook.xml.rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\"></Override><Override PartName=\"/xl/sharedStrings.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\"></Override><Override PartName=\"/xl/styles.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\"></Override><Override PartName=\"/xl/workbook.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\"></Override><Override PartName=\"/xl/theme/theme1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.theme+xml\"></Override><Override PartName=\"/xl/worksheets/sheet1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\"></Override><Override PartName=\"/xl/worksheets/sheet2.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\"></Override><Default Extension=\"rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\"></Default><Default Extension=\"xml\" ContentType=\"application/xml\"></Default></Types>`\n\t\tc.Assert(parts[\"[Content_Types].xml\"], qt.Equals, expectedContentTypes)\n\n\t\t// styles.xml\n\t\t//\n\t\t// For now we only allow simple string data in the\n\t\t// spreadsheet.  Style support will follow.\n\t\texpectedStyles := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<styleSheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"><fonts count=\"1\"><font><sz val=\"11\"/><name val=\"Arial\"/><family val=\"2\"/><color theme=\"1\" /><scheme val=\"minor\"/></font></fonts><fills count=\"2\"><fill><patternFill patternType=\"none\"/></fill><fill><patternFill patternType=\"gray125\"/></fill></fills><borders count=\"1\"><border><left/><right/><top/><bottom/></border></borders><cellStyleXfs count=\"1\"><xf applyAlignment=\"0\" applyBorder=\"0\" applyFont=\"0\" applyFill=\"0\" applyNumberFormat=\"0\" applyProtection=\"0\" borderId=\"0\" fillId=\"0\" fontId=\"0\" numFmtId=\"0\"><alignment horizontal=\"general\" indent=\"0\" shrinkToFit=\"0\" textRotation=\"0\" vertical=\"bottom\" wrapText=\"0\"/></xf></cellStyleXfs><cellXfs count=\"1\"><xf applyAlignment=\"0\" applyBorder=\"0\" applyFont=\"0\" applyFill=\"0\" applyNumberFormat=\"0\" applyProtection=\"0\" borderId=\"0\" fillId=\"0\" fontId=\"0\" numFmtId=\"0\"><alignment horizontal=\"general\" indent=\"0\" shrinkToFit=\"0\" textRotation=\"0\" vertical=\"bottom\" wrapText=\"0\"/></xf></cellXfs></styleSheet>`\n\n\t\tc.Assert(parts[\"xl/styles.xml\"], qt.Equals, expectedStyles)\n\t})\n\n\t// We can save a File as a valid XLSX file at a given path.\n\tcsRunO(c, \"TestSaveFile\", func(c *qt.C, option FileOption) {\n\t\ttmpPath, err := os.MkdirTemp(\"\", \"testsavefile\")\n\t\tc.Assert(err, qt.IsNil)\n\t\tdefer os.RemoveAll(tmpPath)\n\t\tf := NewFile(option)\n\t\tsheet1, _ := f.AddSheet(\"MySheet\")\n\t\trow1 := sheet1.AddRow()\n\t\tcell1 := row1.AddCell()\n\t\tcell1.Value = \"A cell!\"\n\t\tsheet2, _ := f.AddSheet(\"AnotherSheet\")\n\t\trow2 := sheet2.AddRow()\n\t\tcell2 := row2.AddCell()\n\t\tcell2.Value = \"A cell!\"\n\t\txlsxPath := filepath.Join(tmpPath, \"TestSaveFile.xlsx\")\n\t\terr = f.Save(xlsxPath)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\t// Let's eat our own dog food\n\t\txlsxFile, err := OpenFile(xlsxPath, option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(xlsxFile, qt.Not(qt.IsNil))\n\t\tc.Assert(len(xlsxFile.Sheets), qt.Equals, 2)\n\n\t\tsheet1, ok := xlsxFile.Sheet[\"MySheet\"]\n\t\tc.Assert(ok, qt.Equals, true)\n\t\tc.Assert(sheet1.MaxRow, qt.Equals, 1)\n\t\trow1, err = sheet1.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row1.cellStoreRow.CellCount(), qt.Equals, 1)\n\t\tc.Assert(row1.cellStoreRow.MaxCol(), qt.Equals, 0)\n\t\tcell1 = row1.GetCell(0)\n\t\tc.Assert(cell1.Value, qt.Equals, \"A cell!\")\n\t})\n\n\tcsRunO(c, \"TestMarshalFileWithHyperlinks\", func(c *qt.C, option FileOption) {\n\t\tf := NewFile(option)\n\t\tsheet1, _ := f.AddSheet(\"MySheet\")\n\t\trow1 := sheet1.AddRow()\n\t\tcell1 := row1.AddCell()\n\t\tcell1.SetString(\"A cell!\")\n\t\tcell1.SetHyperlink(\"http://www.google.com\", \"\", \"\")\n\t\tc.Assert(cell1.Value, qt.Equals, \"http://www.google.com\")\n\t\tsheet2, _ := f.AddSheet(\"AnotherSheet\")\n\t\trow2 := sheet2.AddRow()\n\t\tcell2 := row2.AddCell()\n\t\tcell2.SetString(\"A cell!\")\n\t\tcell2.SetHyperlink(\"http://www.google.com/index.html\", \"This is a hyperlink\", \"Click on the cell text to follow the hyperlink\")\n\t\tc.Assert(cell2.Value, qt.Equals, \"This is a hyperlink\")\n\t\tparts, err := f.MakeStreamParts()\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(len(parts), qt.Equals, 13)\n\t})\n\n\tcsRunO(c, \"TestMarshalFileWithHiddenSheet\", func(c *qt.C, option FileOption) {\n\t\tf := NewFile(option)\n\t\tsheet1, _ := f.AddSheet(\"MySheet\")\n\t\trow1 := sheet1.AddRow()\n\t\tcell1 := row1.AddCell()\n\t\tcell1.SetString(\"A cell!\")\n\t\tsheetHidden, _ := f.AddSheet(\"SomeHiddenSheet\")\n\t\tsheetHidden.Hidden = true\n\t\trow2 := sheetHidden.AddRow()\n\t\tcell2 := row2.AddCell()\n\t\tcell2.SetString(\"A cell!\")\n\n\t\tpath := filepath.Join(t.TempDir(), \"test.xlsx\")\n\t\terr := f.Save(path)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\txlsxFile, err := OpenFile(path, option)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\ts, ok := xlsxFile.Sheet[\"SomeHiddenSheet\"]\n\t\tc.Assert(ok, qt.Equals, true)\n\t\tc.Assert(s.Hidden, qt.Equals, true)\n\t})\n\n\tcsRunO(c, \"TestMarshalFileWithAutoFilter\", func(c *qt.C, option FileOption) {\n\t\tf := NewFile(option)\n\t\tsheet1, _ := f.AddSheet(\"MySheet\")\n\t\tsheet1.AutoFilter = &AutoFilter{\n\t\t\tTopLeftCell:     \"A1\",\n\t\t\tBottomRightCell: \"D\",\n\t\t}\n\n\t\trow1 := sheet1.AddRow()\n\t\tcell1 := row1.AddCell()\n\t\tcell1.SetString(\"A cell!\")\n\n\t\tparts, err := f.MakeStreamParts()\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(parts[\"xl/workbook.xml\"], qt.Contains, `<definedNames><definedName name=\"_xlnm._FilterDatabase\" localSheetId=\"0\" hidden=\"true\">&#39;MySheet&#39;!$A$1:$D</definedName></definedNames>`)\n\t\tc.Assert(parts[\"xl/worksheets/sheet1.xml\"], qt.Contains, `<autoFilter ref=\"A1:D\"></autoFilter>`)\n\t})\n\n\t// We can save a File as a valid XLSX file at a given path.\n\tcsRunO(c, \"TestSaveFileWithHyperlinks\", func(c *qt.C, option FileOption) {\n\t\ttmpPath, err := os.MkdirTemp(\"\", \"testsavefilewithhyperlinks\")\n\t\tc.Assert(err, qt.IsNil)\n\t\tdefer os.RemoveAll(tmpPath)\n\t\tf := NewFile(option)\n\t\tsheet1, _ := f.AddSheet(\"MySheet\")\n\t\trow1 := sheet1.AddRow()\n\t\tcell1 := row1.AddCell()\n\t\tcell1.SetString(\"A cell!\")\n\t\tcell1.SetHyperlink(\"http://www.google.com\", \"\", \"\")\n\t\tc.Assert(cell1.Value, qt.Equals, \"http://www.google.com\")\n\t\tsheet2, _ := f.AddSheet(\"AnotherSheet\")\n\t\trow2 := sheet2.AddRow()\n\t\tcell2 := row2.AddCell()\n\t\tcell2.SetString(\"A cell!\")\n\t\tcell2.SetHyperlink(\"http://www.google.com/index.html\", \"This is a hyperlink\", \"Click on the cell text to follow the hyperlink\")\n\t\tc.Assert(cell2.Value, qt.Equals, \"This is a hyperlink\")\n\t\txlsxPath := filepath.Join(tmpPath, \"TestSaveFile.xlsx\")\n\t\terr = f.Save(xlsxPath)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\txlsxFile, err := OpenFile(xlsxPath, option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(xlsxFile, qt.Not(qt.IsNil))\n\t\tc.Assert(len(xlsxFile.Sheets), qt.Equals, 2)\n\n\t\tsheet1, ok := xlsxFile.Sheet[\"MySheet\"]\n\t\tc.Assert(ok, qt.Equals, true)\n\t\tc.Assert(sheet1.MaxRow, qt.Equals, 1)\n\t\trow1, err = sheet1.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row1.cellStoreRow.CellCount(), qt.Equals, 1)\n\t\tc.Assert(row1.cellStoreRow.MaxCol(), qt.Equals, 0)\n\t\tcell1 = row1.GetCell(0)\n\t\tc.Assert(cell1.Value, qt.Equals, \"http://www.google.com\")\n\t})\n\n\tcsRunO(c, \"TestReadWorkbookWithTypes\", func(c *qt.C, option FileOption) {\n\t\tvar xlsxFile *File\n\t\tvar err error\n\n\t\txlsxFile, err = OpenFile(\"./testdocs/testcelltypes.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(len(xlsxFile.Sheets), qt.Equals, 1)\n\t\tsheet := xlsxFile.Sheet[\"Sheet1\"]\n\t\tc.Assert(sheet.MaxRow, qt.Equals, 8)\n\t\trow, err := sheet.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 2)\n\n\t\t// string 1\n\t\tc.Assert(row.GetCell(0).Type(), qt.Equals, CellTypeString)\n\t\tif val, err := row.GetCell(0).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"hello world\")\n\t\t}\n\n\t\t// string 2\n\t\trow, err = sheet.Row(1)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.GetCell(0).Type(), qt.Equals, CellTypeString)\n\t\tif val, err := row.GetCell(0).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"日本語\")\n\t\t}\n\n\t\t// integer\n\t\trow, err = sheet.Row(2)\n\t\tc.Assert(err, qt.Equals, nil)\n\n\t\tc.Assert(row.GetCell(0).Type(), qt.Equals, CellTypeNumeric)\n\t\tintValue, _ := row.GetCell(0).Int()\n\t\tc.Assert(intValue, qt.Equals, 12345)\n\n\t\t// float\n\t\trow, err = sheet.Row(3)\n\t\tc.Assert(err, qt.Equals, nil)\n\n\t\tc.Assert(row.GetCell(0).Type(), qt.Equals, CellTypeNumeric)\n\t\tfloatValue, _ := row.GetCell(0).Float()\n\t\tc.Assert(floatValue, qt.Equals, 1.024)\n\n\t\t// Now it can't detect date\n\t\trow, err = sheet.Row(4)\n\t\tc.Assert(err, qt.Equals, nil)\n\n\t\tc.Assert(row.GetCell(0).Type(), qt.Equals, CellTypeNumeric)\n\t\tintValue, _ = row.GetCell(0).Int()\n\t\tc.Assert(intValue, qt.Equals, 40543)\n\n\t\t// bool\n\t\trow, err = sheet.Row(5)\n\t\tc.Assert(err, qt.Equals, nil)\n\n\t\tc.Assert(row.GetCell(0).Type(), qt.Equals, CellTypeBool)\n\t\tc.Assert(row.GetCell(0).Bool(), qt.Equals, true)\n\n\t\t// formula\n\t\trow, err = sheet.Row(6)\n\t\tc.Assert(err, qt.Equals, nil)\n\n\t\tc.Assert(row.GetCell(0).Type(), qt.Equals, CellTypeNumeric)\n\t\tc.Assert(row.GetCell(0).Formula(), qt.Equals, \"10+20\")\n\t\tc.Assert(row.GetCell(0).Value, qt.Equals, \"30\")\n\n\t\t// error\n\t\trow, err = sheet.Row(7)\n\t\tc.Assert(err, qt.Equals, nil)\n\n\t\tc.Assert(row.GetCell(0).Type(), qt.Equals, CellTypeError)\n\t\tc.Assert(row.GetCell(0).Formula(), qt.Equals, \"10/0\")\n\t\tc.Assert(row.GetCell(0).Value, qt.Equals, \"#DIV/0!\")\n\t})\n\n}\n\n// we can unmarshal hyperlinks with in-workbook links\nfunc TestHyperlinks(t *testing.T) {\n\tvar xlsxFile *File\n\tvar err error\n\tc := qt.New(t)\n\n\txlsxFile, err = OpenFile(\"./testdocs/testhyperlinks.xlsx\")\n\tc.Assert(err, qt.IsNil)\n\tc.Assert(xlsxFile, qt.Not(qt.IsNil))\n\n\tsheet, ok := xlsxFile.Sheet[\"Sample\"]\n\tc.Assert(ok, qt.Equals, true)\n\trow, err := sheet.Row(1)\n\tc.Assert(err, qt.IsNil)\n\tcell := row.GetCell(0)\n\tc.Assert(cell.Hyperlink.Location, qt.Equals, \"cities\")\n\tc.Assert(cell.Hyperlink.Link, qt.Equals, \"\")\n\n\trow, err = sheet.Row(2)\n\tc.Assert(err, qt.IsNil)\n\tc.Assert(row.GetCell(0).Hyperlink.Location, qt.Equals, \"\")\n\tc.Assert(row.GetCell(0).Hyperlink.Link, qt.Equals, \"https://www.bobross.com/\")\n\n\trow, err = sheet.Row(3)\n\tc.Assert(err, qt.IsNil)\n\tc.Assert(row.GetCell(0).Hyperlink.Location, qt.Equals, \"Styles!C14\")\n\tc.Assert(row.GetCell(0).Hyperlink.Link, qt.Equals, \"\")\n}\n\n// Helper function used to test contents of a given xlsxXf against\n// expectations.\nfunc testXf(c *qt.C, result, expected *xlsxXf) {\n\tc.Assert(result.ApplyAlignment, qt.Equals, expected.ApplyAlignment)\n\tc.Assert(result.ApplyBorder, qt.Equals, expected.ApplyBorder)\n\tc.Assert(result.ApplyFont, qt.Equals, expected.ApplyFont)\n\tc.Assert(result.ApplyFill, qt.Equals, expected.ApplyFill)\n\tc.Assert(result.ApplyProtection, qt.Equals, expected.ApplyProtection)\n\tc.Assert(result.BorderId, qt.Equals, expected.BorderId)\n\tc.Assert(result.FillId, qt.Equals, expected.FillId)\n\tc.Assert(result.FontId, qt.Equals, expected.FontId)\n\tc.Assert(result.NumFmtId, qt.Equals, expected.NumFmtId)\n}\n\n// Style information is correctly extracted from the zipped XLSX file.\nfunc TestGetStyleFromZipFile(t *testing.T) {\n\tc := qt.New(t)\n\tcsRunO(c, \"GetStyleFromZipFile\", func(c *qt.C, option FileOption) {\n\t\tvar xlsxFile *File\n\t\tvar err error\n\t\tvar style *Style\n\t\tvar val string\n\n\t\txlsxFile, err = OpenFile(\"./testdocs/testfile.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheetCount := len(xlsxFile.Sheets)\n\t\tc.Assert(sheetCount, qt.Equals, 3)\n\n\t\ttabelle1 := xlsxFile.Sheet[\"Tabelle1\"]\n\n\t\trow0, err := tabelle1.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tcellFoo := row0.GetCell(0)\n\t\tstyle = cellFoo.GetStyle()\n\t\tif val, err = cellFoo.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t}\n\t\tc.Assert(val, qt.Equals, \"Foo\")\n\t\tc.Assert(style.Fill.BgColor, qt.Equals, \"FF33CCCC\")\n\t\tc.Assert(style.ApplyFill, qt.Equals, false)\n\t\tc.Assert(style.ApplyFont, qt.Equals, true)\n\n\t\trow1, err := tabelle1.Row(1)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tcellQuuk := row1.GetCell(1)\n\t\tstyle = cellQuuk.GetStyle()\n\t\tif val, err = cellQuuk.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t}\n\t\tc.Assert(val, qt.Equals, \"Quuk\")\n\t\tc.Assert(style.Border.Left, qt.Equals, \"thin\")\n\t\tc.Assert(style.ApplyBorder, qt.Equals, true)\n\n\t\tcellBar := row0.GetCell(1)\n\t\tif val, err = cellBar.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t}\n\t\tc.Assert(val, qt.Equals, \"Bar\")\n\t\tc.Assert(cellBar.GetStyle().Fill.BgColor, qt.Equals, \"\")\n\t})\n}\n\nfunc TestSliceReader(t *testing.T) {\n\tc := qt.New(t)\n\n\tfileToSliceCheckOutput := func(c *qt.C, output [][][]string) {\n\t\tc.Assert(len(output), qt.Equals, 3)\n\t\tc.Assert(len(output[0]), qt.Equals, 2)\n\t\tc.Assert(len(output[0][0]), qt.Equals, 2)\n\t\tc.Assert(output[0][0][0], qt.Equals, \"Foo\")\n\t\tc.Assert(output[0][0][1], qt.Equals, \"Bar\")\n\t\tc.Assert(len(output[0][1]), qt.Equals, 2)\n\t\tc.Assert(output[0][1][0], qt.Equals, \"Baz\")\n\t\tc.Assert(output[0][1][1], qt.Equals, \"Quuk\")\n\t\tc.Assert(len(output[1]), qt.Equals, 0)\n\t\tc.Assert(len(output[2]), qt.Equals, 0)\n\t}\n\n\tcsRunO(c, \"TestFileToSlice\", func(c *qt.C, option FileOption) {\n\t\toutput, err := FileToSlice(\"./testdocs/testfile.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tfileToSliceCheckOutput(c, output)\n\t})\n\n\tcsRunO(c, \"TestFileToSliceValueOnly\", func(c *qt.C, option FileOption) {\n\t\toutput, err := FileToSlice(\"./testdocs/testFileToSliceValueOnly.xlsx\", ValueOnly())\n\t\tc.Assert(err, qt.IsNil)\n\t\t// Because this option changes the structure of the XML inline, we get slightly different, but valid results.\n\t\tc.Assert(len(output), qt.Equals, 3)\n\t\tc.Assert(len(output[0]), qt.Equals, 2)\n\t\tc.Assert(len(output[0][0]), qt.Equals, 7)\n\t\tc.Assert(output[0][0][0], qt.Equals, \"Foo\")\n\t\tc.Assert(output[0][0][1], qt.Equals, \"Bar\")\n\t\tc.Assert(len(output[0][1]), qt.Equals, 5)\n\t\tc.Assert(output[0][1][0], qt.Equals, \"Baz\")\n\t\tc.Assert(output[0][1][1], qt.Equals, \"Quuk\")\n\t\tc.Assert(len(output[1]), qt.Equals, 0)\n\t\tc.Assert(len(output[2]), qt.Equals, 0)\n\t})\n\n\tcsRunO(c, \"TestFileToSliceMissingCol\", func(c *qt.C, option FileOption) {\n\t\t// Test xlsx file with the A column removed\n\t\t// CellCacheSize = 1024 * 1024 * 1024\n\t\t_, err := FileToSlice(\"./testdocs/testFileToSlice.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t})\n\n\tcsRunO(c, \"TestFileObjToSlice\", func(c *qt.C, option FileOption) {\n\t\tf, err := OpenFile(\"./testdocs/testfile.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\toutput, err := f.ToSlice()\n\t\tc.Assert(err, qt.IsNil)\n\t\tfileToSliceCheckOutput(c, output)\n\t})\n\n\tcsRunO(c, \"TestFileToSliceUnmerged\", func(c *qt.C, option FileOption) {\n\t\toutput, err := FileToSliceUnmerged(\"./testdocs/testfile.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tfileToSliceCheckOutput(c, output)\n\n\t\t// merged cells\n\t\toutput, err = FileToSliceUnmerged(\"./testdocs/merged_cells.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(output[0][6][2], qt.Equals, \"Happy New Year!\")\n\t\tc.Assert(output[0][6][1], qt.Equals, \"Happy New Year!\")\n\t\tc.Assert(output[0][1][0], qt.Equals, \"01.01.2016\")\n\t\tc.Assert(output[0][2][0], qt.Equals, \"01.01.2016\")\n\n\t\tcsRunO(c, \"#707 should be fixed\", func(c *qt.C, option FileOption) {\n\t\t\t// test merged cells again.\n\t\t\ta := \"A0A1\"\n\t\t\tbc := \"B1C1B2C2\"\n\t\t\tde := \"D0E0D1E1\"\n\t\t\texpect := [][]string{\n\t\t\t\t{a, \"B0\", \"C0\", de, de},\n\t\t\t\t{a, bc, bc, de, de},\n\t\t\t\t{\"A2\", \"B2\", \"C2\", \"D2\", \"E2\"},\n\t\t\t}\n\t\t\toutput, err := FileToSliceUnmerged(\"./testdocs/merged_cells2.xlsx\", option)\n\t\t\tc.Assert(err, qt.IsNil)\n\t\t\tc.Assert(output, qt.HasLen, 1)\n\t\t\tc.Assert(output[0], qt.HasLen, 3)\n\t\t\tfor i, row := range output[0] {\n\t\t\t\tc.Assert(row, qt.HasLen, 5)\n\t\t\t\tfor j, v := range row {\n\t\t\t\t\tc.Assert(v, qt.Equals, expect[i][j])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t})\n\n\tcsRunO(c, \"TestFileToSliceEmptyCells\", func(c *qt.C, option FileOption) {\n\t\toutput, err := FileToSlice(\"./testdocs/empty_cells.xlsx\", option)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(output, qt.HasLen, 1)\n\t\tsheetSlice := output[0]\n\t\tc.Assert(sheetSlice, qt.HasLen, 4)\n\t\tfor _, rowSlice := range sheetSlice {\n\t\t\tc.Assert(rowSlice, qt.HasLen, 4)\n\t\t}\n\t})\n\n}\n"
        },
        {
          "name": "format_code.go",
          "type": "blob",
          "size": 28.53515625,
          "content": "package xlsx\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Do not edit these attributes once this struct is created. This struct should only be created by\n// parseFullNumberFormatString() from a number format string. If the format for a cell needs to change, change\n// the number format string and getNumberFormat() will invalidate the old struct and re-parse the string.\ntype parsedNumberFormat struct {\n\tnumFmt                        string\n\tisTimeFormat                  bool\n\tnegativeFormatExpectsPositive bool\n\tpositiveFormat                *formatOptions\n\tnegativeFormat                *formatOptions\n\tzeroFormat                    *formatOptions\n\ttextFormat                    *formatOptions\n\tparseEncounteredError         *error\n}\n\ntype formatOptions struct {\n\tisTimeFormat        bool\n\tshowPercent         bool\n\tfullFormatString    string\n\treducedFormatString string\n\tprefix              string\n\tsuffix              string\n}\n\n// FormatValue returns a value, and possibly an error condition\n// from a Cell.  If it is possible to apply a format to the cell\n// value, it will do so, if not then an error will be returned, along\n// with the raw value of the Cell.\n//\n// This is the documentation of the \"General\" Format in the Office Open XML spec:\n//\n// Numbers\n// The application shall attempt to display the full number up to 11 digits (inc. decimal point). If the number is too\n// large*, the application shall attempt to show exponential format. If the number has too many significant digits, the\n// display shall be truncated. The optimal method of display is based on the available cell width. If the number cannot\n// be displayed using any of these formats in the available width, the application shall show \"#\" across the width of\n// the cell.\n//\n// Conditions for switching to exponential format:\n// 1. The cell value shall have at least five digits for xE-xx\n// 2. If the exponent is bigger than the size allowed, a floating point number cannot fit, so try exponential notation.\n// 3. Similarly, for negative exponents, check if there is space for even one (non-zero) digit in floating point format**.\n// 4. Finally, if there isn't room for all of the significant digits in floating point format (for a negative exponent),\n// exponential format shall display more digits if the exponent is less than -3. (The 3 is because E-xx takes 4\n// characters, and the leading 0 in floating point takes only 1 character. Thus, for an exponent less than -3, there is\n// more than 3 additional leading 0's, more than enough to compensate for the size of the E-xx.)\n//\n// Floating point rule:\n// For general formatting in cells, max overall length for cell display is 11, not including negative sign, but includes\n// leading zeros and decimal separator.***\n//\n// Added Notes:\n// * \"If the number is too large\" can also mean \"if the number has more than 11 digits\", so greater than or equal to\n// 1e11 and less than 1e-9.\n// ** Means that you should switch to scientific if there would be 9 zeros after the decimal (the decimal and first zero\n// count against the 11 character limit), so less than 1e9.\n// *** The way this is written, you can get numbers that are more than 11 characters because the golang Float fmt\n// does not support adjusting the precision while not padding with zeros, while also not switching to scientific\n// notation too early.\nfunc (fullFormat *parsedNumberFormat) FormatValue(cell *Cell) (string, error) {\n\tswitch cell.cellType {\n\tcase CellTypeError:\n\t\t// The error type is what XLSX uses in error cases such as when formulas are invalid.\n\t\t// There will be text in the cell's value that can be shown, something ugly like #NAME? or #######\n\t\treturn cell.Value, nil\n\tcase CellTypeBool:\n\t\tif cell.Value == \"0\" {\n\t\t\treturn \"FALSE\", nil\n\t\t} else if cell.Value == \"1\" {\n\t\t\treturn \"TRUE\", nil\n\t\t} else {\n\t\t\treturn cell.Value, errors.New(\"invalid value in bool cell\")\n\t\t}\n\tcase CellTypeString:\n\t\tfallthrough\n\tcase CellTypeInline:\n\t\tfallthrough\n\tcase CellTypeStringFormula:\n\t\tvar cellValue string\n\t\tif len(cell.RichText) > 0 {\n\t\t\tcellValue = richTextToPlainText(cell.RichText)\n\t\t} else {\n\t\t\tcellValue = cell.Value\n\t\t}\n\t\ttextFormat := cell.parsedNumFmt.textFormat\n\t\t// This switch statement is only for String formats\n\t\tswitch textFormat.reducedFormatString {\n\t\tcase builtInNumFmt[builtInNumFmtIndex_GENERAL]: // General is literally \"general\"\n\t\t\treturn cellValue, nil\n\t\tcase builtInNumFmt[builtInNumFmtIndex_STRING]: // String is \"@\"\n\t\t\treturn textFormat.prefix + cellValue + textFormat.suffix, nil\n\t\tcase \"\":\n\t\t\t// If cell is not \"General\" and there is not an \"@\" symbol in the format, then the cell's value is not\n\t\t\t// used when determining what to display. It would be completely legal to have a format of \"Error\"\n\t\t\t// for strings, and all values that are not numbers would show up as \"Error\". In that case, this code would\n\t\t\t// have a prefix of \"Error\" and a reduced format string of \"\" (empty string).\n\t\t\treturn textFormat.prefix + textFormat.suffix, nil\n\t\tdefault:\n\t\t\treturn cellValue, errors.New(\"invalid or unsupported format, unsupported string format\")\n\t\t}\n\tcase CellTypeDate:\n\t\t// These are dates that are stored in date format instead of being stored as numbers with a format to turn them\n\t\t// into a date string.\n\t\treturn cell.Value, nil\n\tcase CellTypeNumeric:\n\t\treturn fullFormat.formatNumericCell(cell)\n\tdefault:\n\t\treturn cell.Value, errors.New(\"unknown cell type\")\n\t}\n}\n\nfunc (fullFormat *parsedNumberFormat) formatNumericCell(cell *Cell) (string, error) {\n\trawValue := strings.TrimSpace(cell.Value)\n\t// If there wasn't a value in the cell, it shouldn't have been marked as Numeric.\n\t// It's better to support this case though.\n\tif rawValue == \"\" {\n\t\treturn \"\", nil\n\t}\n\n\tif fullFormat.isTimeFormat {\n\t\treturn fullFormat.parseTime(rawValue, cell.date1904)\n\t}\n\tvar numberFormat *formatOptions\n\tfloatVal, floatErr := strconv.ParseFloat(rawValue, 64)\n\tif floatErr != nil {\n\t\treturn rawValue, floatErr\n\t}\n\t// Choose the correct format. There can be different formats for positive, negative, and zero numbers.\n\t// Excel only uses the zero format if the value is literally zero, even if the number is so small that it shows\n\t// up as \"0\" when the positive format is used.\n\tif floatVal > 0 {\n\t\tnumberFormat = fullFormat.positiveFormat\n\t} else if floatVal < 0 {\n\t\t// If format string specified a different format for negative numbers, then the number should be made positive\n\t\t// before getting formatted. The format string itself will contain formatting that denotes a negative number and\n\t\t// this formatting will end up in the prefix or suffix. Commonly if there is a negative format specified, the\n\t\t// number will get surrounded by parenthesis instead of showing it with a minus sign.\n\t\tif fullFormat.negativeFormatExpectsPositive {\n\t\t\tfloatVal = math.Abs(floatVal)\n\t\t}\n\t\tnumberFormat = fullFormat.negativeFormat\n\t} else {\n\t\tnumberFormat = fullFormat.zeroFormat\n\t}\n\n\t// When showPercent is true, multiply the number by 100.\n\t// The percent sign will be in the prefix or suffix already, so it does not need to be added in this function.\n\t// The number format itself will be the same as any other number format once the value is multiplied by 100.\n\tif numberFormat.showPercent {\n\t\tfloatVal = 100 * floatVal\n\t}\n\n\t// Only the most common format strings are supported here.\n\t// Eventually this switch needs to be replaced with a more general solution.\n\t// Some of these \"supported\" formats should have thousand separators, but don't get them since Go fmt\n\t// doesn't have a way to request thousands separators.\n\t// The only things that should be supported here are in the array formattingCharacters,\n\t// everything else has been stripped out before and will be placed in the prefix or suffix.\n\t// The formatting characters can have non-formatting characters mixed in with them and those should be maintained.\n\t// However, at this time we fail to parse those formatting codes and they get replaced with \"General\"\n\tvar formattedNum string\n\tswitch numberFormat.reducedFormatString {\n\tcase builtInNumFmt[builtInNumFmtIndex_GENERAL]: // General is literally \"general\"\n\t\t// prefix, showPercent, and suffix cannot apply to the general format\n\t\t// The logic for showing numbers when the format is \"general\" is much more complicated than the rest of these.\n\t\tgeneralFormatted, err := generalNumericScientific(cell.Value, true)\n\t\tif err != nil {\n\t\t\treturn rawValue, nil\n\t\t}\n\t\treturn generalFormatted, nil\n\tcase builtInNumFmt[builtInNumFmtIndex_STRING]: // String is \"@\"\n\t\tformattedNum = cell.Value\n\tcase builtInNumFmt[builtInNumFmtIndex_INT], \"#,##0\": // Int is \"0\"\n\t\t// Previously this case would cast to int and print with %d, but that will not round the value correctly.\n\t\tformattedNum = fmt.Sprintf(\"%.0f\", floatVal)\n\tcase \"0.0\", \"#,##0.0\":\n\t\tformattedNum = fmt.Sprintf(\"%.1f\", floatVal)\n\tcase builtInNumFmt[builtInNumFmtIndex_FLOAT], \"#,##0.00\": // Float is \"0.00\"\n\t\tformattedNum = fmt.Sprintf(\"%.2f\", floatVal)\n\tcase \"0.000\", \"#,##0.000\":\n\t\tformattedNum = fmt.Sprintf(\"%.3f\", floatVal)\n\tcase \"0.0000\", \"#,##0.0000\":\n\t\tformattedNum = fmt.Sprintf(\"%.4f\", floatVal)\n\tcase \"0.00e+00\", \"##0.0e+0\":\n\t\tformattedNum = fmt.Sprintf(\"%e\", floatVal)\n\tcase \"\":\n\t\t// Do nothing.\n\tdefault:\n\t\treturn rawValue, nil\n\t}\n\treturn numberFormat.prefix + formattedNum + numberFormat.suffix, nil\n}\n\nfunc generalNumericScientific(value string, allowScientific bool) (string, error) {\n\tif strings.TrimSpace(value) == \"\" {\n\t\treturn \"\", nil\n\t}\n\tf, err := strconv.ParseFloat(value, 64)\n\tif err != nil {\n\t\treturn value, err\n\t}\n\tif allowScientific {\n\t\tabsF := math.Abs(f)\n\t\t// When using General format, numbers that are less than 1e-9 (0.000000001) and greater than or equal to\n\t\t// 1e11 (100,000,000,000) should be shown in scientific notation.\n\t\t// Numbers less than the number after zero, are assumed to be zero.\n\t\tif (absF >= math.SmallestNonzeroFloat64 && absF < minNonScientificNumber) || absF >= maxNonScientificNumber {\n\t\t\treturn strconv.FormatFloat(f, 'E', -1, 64), nil\n\t\t}\n\t}\n\t// This format (fmt=\"f\", prec=-1) will prevent padding with zeros and will never switch to scientific notation.\n\t// However, it will show more than 11 characters for very precise numbers, and this cannot be changed.\n\t// You could also use fmt=\"g\", prec=11, which doesn't pad with zeros and allows the correct precision,\n\t// but it will use scientific notation on numbers less than 1e-4. That value is hardcoded in Go and cannot be\n\t// configured or disabled.\n\treturn strconv.FormatFloat(f, 'f', -1, 64), nil\n}\n\n// Format strings are a little strange to compare because empty string\n// needs to be taken as general, and general needs to be compared case\n// insensitively.\nfunc compareFormatString(fmt1, fmt2 string) bool {\n\tif fmt1 == fmt2 {\n\t\treturn true\n\t}\n\tif fmt1 == \"\" || strings.EqualFold(fmt1, \"general\") {\n\t\tfmt1 = \"general\"\n\t}\n\tif fmt2 == \"\" || strings.EqualFold(fmt2, \"general\") {\n\t\tfmt2 = \"general\"\n\t}\n\treturn fmt1 == fmt2\n}\n\nfunc parseFullNumberFormatString(numFmt string) *parsedNumberFormat {\n\tparsedNumFmt := &parsedNumberFormat{\n\t\tnumFmt: numFmt,\n\t}\n\n\tvar fmtOptions []*formatOptions\n\tformats, err := splitFormatOnSemicolon(numFmt)\n\tif err == nil {\n\t\tfor _, formatSection := range formats {\n\t\t\tparsedFormat, err := parseNumberFormatSection(formatSection)\n\t\t\tif err != nil {\n\t\t\t\t// If an invalid number section is found, fall back to general\n\t\t\t\tparsedFormat = fallbackErrorFormat\n\t\t\t\tparsedNumFmt.parseEncounteredError = &err\n\t\t\t}\n\t\t\tfmtOptions = append(fmtOptions, parsedFormat)\n\t\t}\n\t} else {\n\t\tfmtOptions = append(fmtOptions, fallbackErrorFormat)\n\t\tparsedNumFmt.parseEncounteredError = &err\n\t}\n\tif len(fmtOptions) > 4 {\n\t\tfmtOptions = []*formatOptions{fallbackErrorFormat}\n\t\terr = errors.New(\"invalid number format, too many format sections\")\n\t\tparsedNumFmt.parseEncounteredError = &err\n\t}\n\n\tif len(fmtOptions) == 1 {\n\t\t// If there is only one option, it is used for all\n\t\tparsedNumFmt.isTimeFormat = fmtOptions[0].isTimeFormat\n\t\tparsedNumFmt.positiveFormat = fmtOptions[0]\n\t\tparsedNumFmt.negativeFormat = fmtOptions[0]\n\t\tparsedNumFmt.zeroFormat = fmtOptions[0]\n\t\tif strings.Contains(fmtOptions[0].fullFormatString, \"@\") {\n\t\t\tparsedNumFmt.textFormat = fmtOptions[0]\n\t\t} else {\n\t\t\tparsedNumFmt.textFormat, _ = parseNumberFormatSection(\"general\")\n\t\t}\n\t} else if len(fmtOptions) == 2 {\n\t\t// If there are two formats, the first is used for positive and zeros, the second gets used as a negative format,\n\t\t// and strings are not formatted.\n\t\t// When negative numbers now have their own format, they should become positive before having the format applied.\n\t\t// The format will contain a negative sign if it is desired, but they may be colored red or wrapped in\n\t\t// parenthesis instead.\n\t\tparsedNumFmt.isTimeFormat = fmtOptions[0].isTimeFormat\n\t\tparsedNumFmt.negativeFormatExpectsPositive = true\n\t\tparsedNumFmt.positiveFormat = fmtOptions[0]\n\t\tparsedNumFmt.negativeFormat = fmtOptions[1]\n\t\tparsedNumFmt.zeroFormat = fmtOptions[0]\n\t\tparsedNumFmt.textFormat, _ = parseNumberFormatSection(\"general\")\n\t} else if len(fmtOptions) == 3 {\n\t\t// If there are three formats, the first is used for positive, the second gets used as a negative format,\n\t\t// the third is for negative, and strings are not formatted.\n\t\tparsedNumFmt.isTimeFormat = fmtOptions[0].isTimeFormat\n\t\tparsedNumFmt.negativeFormatExpectsPositive = true\n\t\tparsedNumFmt.positiveFormat = fmtOptions[0]\n\t\tparsedNumFmt.negativeFormat = fmtOptions[1]\n\t\tparsedNumFmt.zeroFormat = fmtOptions[2]\n\t\tparsedNumFmt.textFormat, _ = parseNumberFormatSection(\"general\")\n\t} else {\n\t\t// With four options, the first is positive, the second is negative, the third is zero, and the fourth is strings\n\t\t// Negative numbers should be still become positive before having the negative formatting applied.\n\t\tparsedNumFmt.isTimeFormat = fmtOptions[0].isTimeFormat\n\t\tparsedNumFmt.negativeFormatExpectsPositive = true\n\t\tparsedNumFmt.positiveFormat = fmtOptions[0]\n\t\tparsedNumFmt.negativeFormat = fmtOptions[1]\n\t\tparsedNumFmt.zeroFormat = fmtOptions[2]\n\t\tparsedNumFmt.textFormat = fmtOptions[3]\n\t}\n\treturn parsedNumFmt\n}\n\n// splitFormatOnSemicolon will split the format string into the format sections\n// This logic to split the different formats on semicolon is fully correct, and will skip all literal semicolons,\n// and will catch all breaking semicolons.\nfunc splitFormatOnSemicolon(format string) ([]string, error) {\n\tvar formats []string\n\tprevIndex := 0\n\tfor i := 0; i < len(format); i++ {\n\t\tif format[i] == ';' {\n\t\t\tformats = append(formats, format[prevIndex:i])\n\t\t\tprevIndex = i + 1\n\t\t} else if format[i] == '\\\\' {\n\t\t\ti++\n\t\t} else if format[i] == '\"' {\n\t\t\tendQuoteIndex := strings.Index(format[i+1:], \"\\\"\")\n\t\t\tif endQuoteIndex == -1 {\n\t\t\t\t// This is an invalid format string, fall back to general\n\t\t\t\treturn nil, errors.New(\"invalid format string, unmatched double quote\")\n\t\t\t}\n\t\t\ti += endQuoteIndex + 1\n\t\t}\n\t}\n\treturn append(formats, format[prevIndex:]), nil\n}\n\nvar fallbackErrorFormat = &formatOptions{\n\tfullFormatString:    \"general\",\n\treducedFormatString: \"general\",\n}\n\n// parseNumberFormatSection takes in individual format and parses out most of the options.\n// Some options are parsed, removed from the string, and set as settings on formatOptions.\n// There remainder of the format string is put in the reducedFormatString attribute, and supported values for these\n// are handled in a switch in the Cell.FormattedValue() function.\n// Ideally more and more of the format string would be parsed out here into settings until there is no remainder string\n// at all.\n// Features that this supports:\n//   - Time formats are detected, and marked in the options. Time format strings are handled when doing the formatting.\n//     The logic to detect time formats is currently not correct, and can catch formats that are not time formats as well\n//     as miss formats that are time formats.\n//   - Color formats are detected and removed.\n//   - Currency annotations are handled properly.\n//   - Literal strings wrapped in quotes are handled and put into prefix or suffix.\n//   - Numbers that should be percent are detected and marked in the options.\n//   - Conditionals are detected and removed, but they are not obeyed. The conditional groups will be used just like the\n//     positive;negative;zero;string format groups. Here is an example of a conditional format: \"[Red][<=100];[Blue][>100]\"\n//\n// Decoding the actual number formatting portion is out of scope, that is placed into reducedFormatString and is used\n// when formatting the string. The string there will be reduced to only the things in the formattingCharacters array.\n// Everything not in that array has been parsed out and put into formatOptions.\nfunc parseNumberFormatSection(fullFormat string) (*formatOptions, error) {\n\treducedFormat := strings.TrimSpace(fullFormat)\n\n\t// general is the only format that does not use the normal format symbols notations\n\tif compareFormatString(reducedFormat, \"general\") {\n\t\treturn &formatOptions{\n\t\t\tfullFormatString:    \"general\",\n\t\t\treducedFormatString: \"general\",\n\t\t}, nil\n\t}\n\tif isTimeFormat(reducedFormat) {\n\t\treturn &formatOptions{\n\t\t\tfullFormatString:    fullFormat,\n\t\t\tisTimeFormat:        true,\n\t\t\treducedFormatString: reducedFormat,\n\t\t}, nil\n\t}\n\n\tprefix, reducedFormat, showPercent1, err := parseLiterals(reducedFormat)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treducedFormat, suffixFormat := splitFormatAndSuffixFormat(reducedFormat)\n\n\tsuffix, remaining, showPercent2, err := parseLiterals(suffixFormat)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(remaining) > 0 {\n\t\t// This paradigm of codes consisting of literals, number formats, then more literals is not always correct, they can\n\t\t// actually be intertwined. Though 99% of the time number formats will not do this.\n\t\t// Excel uses this format string for Social Security Numbers: 000\\-00\\-0000\n\t\t// and this for US phone numbers: [<=9999999]###\\-####;\\(###\\)\\ ###\\-####\n\t\treturn nil, errors.New(\"invalid or unsupported format string\")\n\t}\n\n\treturn &formatOptions{\n\t\tfullFormatString:    fullFormat,\n\t\tisTimeFormat:        false,\n\t\treducedFormatString: reducedFormat,\n\t\tprefix:              prefix,\n\t\tsuffix:              suffix,\n\t\tshowPercent:         showPercent1 || showPercent2,\n\t}, nil\n}\n\n// formattingCharacters will be left in the reducedNumberFormat\n// It is important that these be looked for in order so that the slash cases are handled correctly.\n// / (slash) is a fraction format if preceded by 0, #, or ?, otherwise it is not a formatting character\n// E- E+ e- e+ are scientific notation, but E, e, -, + are not formatting characters independently\n// \\ (back slash) makes the next character a literal (not formatting)\n// \" Anything in double quotes is not a formatting character\n// _ (underscore) skips the width of the next character, so the next character cannot be formatting\nvar formattingCharacters = []string{\"0/\", \"#/\", \"?/\", \"E-\", \"E+\", \"e-\", \"e+\", \"0\", \"#\", \"?\", \".\", \",\", \"@\", \"*\"}\n\n// The following are also time format characters, but since this is only used for detecting, not decoding, they are\n// redundant here: ee, gg, ggg, rr, ss, mm, hh, yyyy, dd, ddd, dddd, mm, mmm, mmmm, mmmmm, ss.0000, ss.000, ss.00, ss.0\n// The .00 type format is very tricky, because it only counts if it comes after ss or s or [ss] or [s]\n// .00 is actually a valid number format by itself.\nvar timeFormatCharacters = []string{\"M\", \"D\", \"Y\", \"YY\", \"YYYY\", \"MM\", \"yyyy\", \"m\", \"d\", \"yy\", \"h\", \"m\", \"AM/PM\", \"A/P\", \"am/pm\", \"a/p\", \"r\", \"g\", \"e\", \"b1\", \"b2\", \"[hh]\", \"[h]\", \"[mm]\", \"[m]\",\n\t\"s.0000\", \"s.000\", \"s.00\", \"s.0\", \"s\", \"[ss].0000\", \"[ss].000\", \"[ss].00\", \"[ss].0\", \"[ss]\", \"[s].0000\", \"[s].000\", \"[s].00\", \"[s].0\", \"[s]\", \"上\", \"午\", \"下\"}\n\nfunc splitFormatAndSuffixFormat(format string) (string, string) {\n\tvar i int\n\tfor ; i < len(format); i++ {\n\t\tcurReducedFormat := format[i:]\n\t\tvar found bool\n\t\tfor _, special := range formattingCharacters {\n\t\t\tif strings.HasPrefix(curReducedFormat, special) {\n\t\t\t\t// Skip ahead if the special character was longer than length 1\n\t\t\t\ti += len(special) - 1\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tbreak\n\t\t}\n\t}\n\tsuffixFormat := format[i:]\n\tformat = format[:i]\n\treturn format, suffixFormat\n}\n\nfunc parseLiterals(format string) (string, string, bool, error) {\n\tvar prefix string\n\tshowPercent := false\n\tfor i := 0; i < len(format); i++ {\n\t\tcurReducedFormat := format[i:]\n\t\tswitch curReducedFormat[0] {\n\t\tcase '\\\\':\n\t\t\t// If there is a slash, skip the next character, and add it to the prefix\n\t\t\tif len(curReducedFormat) > 1 {\n\t\t\t\ti++\n\t\t\t\tprefix += curReducedFormat[1:2]\n\t\t\t}\n\t\tcase '_':\n\t\t\t// If there is an underscore, skip the next character, but don't add it to the prefix\n\t\t\tif len(curReducedFormat) > 1 {\n\t\t\t\ti++\n\t\t\t}\n\t\tcase '*':\n\t\t\t// Asterisks are used to repeat the next character to fill the full cell width.\n\t\t\t// There isn't really a cell size in this context, so this will be ignored.\n\t\tcase '\"':\n\t\t\t// If there is a quote skip to the next quote, and add the quoted characters to the prefix\n\t\t\tendQuoteIndex := strings.Index(curReducedFormat[1:], \"\\\"\")\n\t\t\tif endQuoteIndex == -1 {\n\t\t\t\treturn \"\", \"\", false, errors.New(\"invalid formatting code, unmatched double quote\")\n\t\t\t}\n\t\t\tprefix = prefix + curReducedFormat[1:endQuoteIndex+1]\n\t\t\ti += endQuoteIndex + 1\n\t\tcase '%':\n\t\t\tshowPercent = true\n\t\t\tprefix += \"%\"\n\t\tcase '[':\n\t\t\t// Brackets can be currency annotations (e.g. [$$-409])\n\t\t\t// color formats (e.g. [color1] through [color56], as well as [red] etc.)\n\t\t\t// conditionals (e.g. [>100], the valid conditionals are =, >, <, >=, <=, <>)\n\t\t\tbracketIndex := strings.Index(curReducedFormat, \"]\")\n\t\t\tif bracketIndex == -1 {\n\t\t\t\treturn \"\", \"\", false, errors.New(\"invalid formatting code, invalid brackets\")\n\t\t\t}\n\t\t\t// Currencies in Excel are annotated with this format: [$<Currency String>-<Language Info>]\n\t\t\t// Currency String is something like $, ¥, €, or £\n\t\t\t// Language Info is three hexadecimal characters\n\t\t\tif len(curReducedFormat) > 2 && curReducedFormat[1] == '$' {\n\t\t\t\tdashIndex := strings.Index(curReducedFormat, \"-\")\n\t\t\t\tif dashIndex != -1 && dashIndex < bracketIndex {\n\t\t\t\t\t// Get the currency symbol, and skip to the end of the currency format\n\t\t\t\t\tprefix += curReducedFormat[2:dashIndex]\n\t\t\t\t} else {\n\t\t\t\t\treturn \"\", \"\", false, errors.New(\"invalid formatting code, invalid currency annotation\")\n\t\t\t\t}\n\t\t\t}\n\t\t\ti += bracketIndex\n\t\tcase '$', '-', '+', '/', '(', ')', ':', '!', '^', '&', '\\'', '~', '{', '}', '<', '>', '=', ' ':\n\t\t\t// These symbols are allowed to be used as literal without escaping\n\t\t\tprefix += curReducedFormat[0:1]\n\t\tdefault:\n\t\t\tfor _, special := range formattingCharacters {\n\t\t\t\tif strings.HasPrefix(curReducedFormat, special) {\n\t\t\t\t\t// This means we found the start of the actual number formatting portion, and should return.\n\t\t\t\t\treturn prefix, format[i:], showPercent, nil\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Symbols that don't have meaning and aren't in the exempt literal characters and are not escaped.\n\t\t\treturn \"\", \"\", false, errors.New(\"invalid formatting code: unsupported or unescaped characters\")\n\t\t}\n\t}\n\treturn prefix, \"\", showPercent, nil\n}\n\n// parseTime returns a string parsed using time.Time\nfunc (fullFormat *parsedNumberFormat) parseTime(value string, date1904 bool) (string, error) {\n\tf, err := strconv.ParseFloat(value, 64)\n\tif err != nil {\n\t\treturn value, err\n\t}\n\tval := TimeFromExcelTime(f, date1904)\n\tformat := fullFormat.positiveFormat.fullFormatString\n\t// Replace Excel placeholders with Go time placeholders.\n\t// For example, replace yyyy with 2006. These are in a specific order,\n\t// due to the fact that m is used in month, minute, and am/pm. It would\n\t// be easier to fix that with regular expressions, but if it's possible\n\t// to keep this simple it would be easier to maintain.\n\t// Full-length month and days (e.g. March, Tuesday) have letters in them that would be replaced\n\t// by other characters below (such as the 'h' in March, or the 'd' in Tuesday) below.\n\t// First we convert them to arbitrary characters unused in Excel Date formats, and then at the end,\n\t// turn them to what they should actually be.\n\t// Based off: http://www.ozgrid.com/Excel/CustomFormats.htm\n\treplacements := []struct{ xltime, gotime string }{\n\t\t{\"YYYY\", \"2006\"},\n\t\t{\"yyyy\", \"2006\"},\n\t\t{\"YY\", \"06\"},\n\t\t{\"yy\", \"06\"},\n\t\t{\"MMMM\", \"%%%%\"},\n\t\t{\"mmmm\", \"%%%%\"},\n\t\t{\"DDDD\", \"&&&&\"},\n\t\t{\"dddd\", \"&&&&\"},\n\t\t{\"DD\", \"02\"},\n\t\t{\"dd\", \"02\"},\n\t\t{\"D\", \"2\"},\n\t\t{\"d\", \"2\"},\n\t\t{\"MMM\", \"Jan\"},\n\t\t{\"mmm\", \"Jan\"},\n\t\t{\"MMSS\", \"0405\"},\n\t\t{\"mmss\", \"0405\"},\n\t\t{\"SS\", \"05\"},\n\t\t{\"ss\", \"05\"},\n\t\t{\"MM:\", \"04:\"},\n\t\t{\"mm:\", \"04:\"},\n\t\t{\":MM\", \":04\"},\n\t\t{\":mm\", \":04\"},\n\t\t{\"MM\", \"01\"},\n\t\t{\"mm\", \"01\"},\n\t\t{\"AM/PM\", \"pm\"},\n\t\t{\"am/pm\", \"pm\"},\n\t\t{\"M/\", \"1/\"},\n\t\t{\"m/\", \"1/\"},\n\t\t{\"%%%%\", \"January\"},\n\t\t{\"&&&&\", \"Monday\"},\n\t}\n\t// It is the presence of the \"am/pm\" indicator that determins\n\t// if this is a 12 hour or 24 hours time format, not the\n\t// number of 'h' characters.\n\tif is12HourTime(format) {\n\t\tformat = strings.Replace(format, \"hh\", \"03\", 1)\n\t\tformat = strings.Replace(format, \"h\", \"3\", 1)\n\t} else {\n\t\tformat = strings.Replace(format, \"hh\", \"15\", 1)\n\t\tformat = strings.Replace(format, \"h\", \"15\", 1)\n\t}\n\tfor _, repl := range replacements {\n\t\tformat = strings.Replace(format, repl.xltime, repl.gotime, 1)\n\t}\n\t// If the hour is optional, strip it out, along with the\n\t// possible dangling colon that would remain.\n\tif val.Hour() < 1 {\n\t\tformat = strings.Replace(format, \"]:\", \"]\", 1)\n\t\tformat = strings.Replace(format, \"[03]\", \"\", 1)\n\t\tformat = strings.Replace(format, \"[3]\", \"\", 1)\n\t\tformat = strings.Replace(format, \"[15]\", \"\", 1)\n\t} else {\n\t\tformat = strings.Replace(format, \"[3]\", \"3\", 1)\n\t\tformat = strings.Replace(format, \"[15]\", \"15\", 1)\n\t}\n\treturn val.Format(format), nil\n}\n\nfunc skipToRune(runes []rune, r rune) (int, error) {\n\tfor i := 1; i < len(runes); i++ {\n\t\tif runes[i] == r {\n\t\t\treturn i, nil\n\t\t}\n\t}\n\treturn -1, fmt.Errorf(\"no closing quote found\")\n}\n\n// isTimeFormat checks whether an Excel format string represents a time.Time.\n// This function is now correct, but it can detect time format strings that cannot be correctly handled by parseTime()\nfunc isTimeFormat(format string) bool {\n\tvar foundTimeFormatCharacters bool\n\n\trunes := []rune(format)\n\tfor i := 0; i < len(runes); i++ {\n\t\tcurReducedFormat := runes[i:]\n\t\tswitch curReducedFormat[0] {\n\t\tcase '\\\\', '_':\n\t\t\t// If there is a slash, skip the next character, and add it to the prefix\n\t\t\t// If there is an underscore, skip the next character, but don't add it to the prefix\n\t\t\tif len(curReducedFormat) > 1 {\n\t\t\t\ti++\n\t\t\t}\n\t\tcase '*':\n\t\t\t// Asterisks are used to repeat the next character to fill the full cell width.\n\t\t\t// There isn't really a cell size in this context, so this will be ignored.\n\t\tcase '\"':\n\t\t\t// If there is a quote skip to the next quote, and add the quoted characters to the prefix\n\t\t\tendQuoteIndex, err := skipToRune(curReducedFormat, '\"')\n\t\t\tif err != nil {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\ti += endQuoteIndex + 1\n\t\tcase '$', '-', '+', '/', '(', ')', ':', '!', '^', '&', '\\'', '~', '{', '}', '<', '>', '=', ' ':\n\t\t\t// These symbols are allowed to be used as literal without escaping\n\t\tcase ',':\n\t\t\t// This is not documented in the XLSX spec as far as I can tell, but Excel and Numbers will include\n\t\t\t// commas in number formats without escaping them, so this should be supported.\n\t\tdefault:\n\t\t\tfoundInThisLoop := false\n\t\t\tfor _, special := range timeFormatCharacters {\n\t\t\t\tif strings.HasPrefix(string(curReducedFormat), special) {\n\t\t\t\t\tfoundTimeFormatCharacters = true\n\t\t\t\t\tfoundInThisLoop = true\n\t\t\t\t\ti += len([]rune(special)) - 1\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif foundInThisLoop {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif curReducedFormat[0] == '[' {\n\t\t\t\t// For number formats, this code would happen above in a case '[': section.\n\t\t\t\t// However, for time formats it must happen after looking for occurrences in timeFormatCharacters\n\t\t\t\t// because there are a few time formats that can be wrapped in brackets.\n\n\t\t\t\t// Brackets can be currency annotations (e.g. [$$-409])\n\t\t\t\t// color formats (e.g. [color1] through [color56], as well as [red] etc.)\n\t\t\t\t// conditionals (e.g. [>100], the valid conditionals are =, >, <, >=, <=, <>)\n\t\t\t\tbracketIndex, err := skipToRune(curReducedFormat, ']')\n\t\t\t\tif err != nil {\n\t\t\t\t\t// This is not any type of valid format.\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\ti += bracketIndex\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Symbols that don't have meaning, aren't in the exempt literal characters, and aren't escaped are invalid.\n\t\t\t// The string could still be a valid number format string.\n\t\t\treturn false\n\t\t}\n\t}\n\t// If the string doesn't have any time formatting characters, it could technically be a time format, but it\n\t// would be a pretty weak time format. A valid time format with no time formatting symbols will also be a number\n\t// format with no number formatting symbols, which is essentially a constant string that does not depend on the\n\t// cell's value in anyway. The downstream logic will do the right thing in that case if this returns false.\n\treturn foundTimeFormatCharacters\n}\n\n// is12HourTime checks whether an Excel time format string is a 12\n// hours form.\nfunc is12HourTime(format string) bool {\n\treturn strings.Contains(format, \"am/pm\") || strings.Contains(format, \"AM/PM\") || strings.Contains(format, \"a/p\") || strings.Contains(format, \"A/P\")\n}\n"
        },
        {
          "name": "format_code_test.go",
          "type": "blob",
          "size": 11.6552734375,
          "content": "package xlsx\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\nfunc TestCellFormatCode(t *testing.T) {\n\tc := qt.New(t)\n\n\tc.Run(\"TestMoreFormattingFeatures\", func(c *qt.C) {\n\n\t\tcell := Cell{}\n\t\tcell.SetFloat(0)\n\t\tdate, err := cell.GetTime(false)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(date, qt.Equals, time.Date(1899, 12, 30, 0, 0, 0, 0, time.UTC))\n\t\tcell.SetFloat(39813.0)\n\t\tdate, err = cell.GetTime(true)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(date, qt.Equals, time.Date(2013, 1, 1, 0, 0, 0, 0, time.UTC))\n\t\tcell.Value = \"d\"\n\t\t_, err = cell.GetTime(false)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t})\n\n\tc.Run(\"TestFormatStringSupport\", func(c *qt.C) {\n\t\ttestCases := []struct {\n\t\t\tformatString         string\n\t\t\tvalue                string\n\t\t\tformattedValueOutput string\n\t\t\tcellType             CellType\n\t\t\texpectError          bool\n\t\t}{\n\t\t\t{\n\t\t\t\tformatString:         `[red]0`,\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"19\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tformatString:         `[blue]0`,\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"19\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tformatString:         `[color50]0`,\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"19\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tformatString:         `[$$-409]0`,\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"$19\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tformatString:         `[$¥-409]0`,\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"¥19\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tformatString:         `[$€-409]0`,\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"€19\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tformatString:         `[$£-409]0`,\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"£19\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tformatString:         `[$USD-409] 0`,\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"USD 19\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tformatString:         `0[$USD-409]`,\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"19USD\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tformatString:         `-[$USD-409]0`,\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"-USD19\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tformatString:         `\\[0`,\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"[19\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tformatString:         `\"[\"0`,\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"[19\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tformatString:         \"_[0\",\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"19\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tformatString:         `\"asdf\"0`,\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"asdf19\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tformatString:         `\"$\"0`,\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"$19\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tformatString:         `$0`,\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"$19\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tformatString:         `%0`, // The percent sign can be anywhere in the format.\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"%1899\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tformatString:         `$-+/()!^&'~{}<>=: 0 :=><}{~'&^)(/+-$`,\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"$-+/()!^&'~{}<>=: 19 :=><}{~'&^)(/+-$\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{\n\t\t\t\tformatString:         `0;-0;\"zero\"`,\n\t\t\t\tvalue:                \"18.989999999999998\",\n\t\t\t\tformattedValueOutput: \"19\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{ // 2 formats\n\t\t\t\tformatString:         `0;(0)`,\n\t\t\t\tvalue:                \"0\",\n\t\t\t\tformattedValueOutput: \"0\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{ // 2 formats\n\t\t\t\tformatString:         `0;(0)`,\n\t\t\t\tvalue:                \"4.1\",\n\t\t\t\tformattedValueOutput: \"4\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{ // 2 formats\n\t\t\t\tformatString:         `0;(0)`,\n\t\t\t\tvalue:                \"-1\",\n\t\t\t\tformattedValueOutput: \"(1)\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{ // 2 formats\n\t\t\t\tformatString:         `0;(0)`,\n\t\t\t\tvalue:                \"asdf\",\n\t\t\t\tformattedValueOutput: \"asdf\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t\texpectError:          true,\n\t\t\t},\n\t\t\t{ // 2 formats\n\t\t\t\tformatString:         `0;(0)`,\n\t\t\t\tvalue:                \"asdf\",\n\t\t\t\tformattedValueOutput: \"asdf\",\n\t\t\t\tcellType:             CellTypeString,\n\t\t\t},\n\t\t\t{ // 3 formats\n\t\t\t\tformatString:         `0;(0);\"zero\"`,\n\t\t\t\tvalue:                \"59.6\",\n\t\t\t\tformattedValueOutput: \"60\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{ // 3 formats\n\t\t\t\tformatString:         `0;(0);\"zero\"`,\n\t\t\t\tvalue:                \"-39\",\n\t\t\t\tformattedValueOutput: \"(39)\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{ // 3 formats\n\t\t\t\tformatString:         `0;(0);\"zero\"`,\n\t\t\t\tvalue:                \"0\",\n\t\t\t\tformattedValueOutput: \"zero\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t},\n\t\t\t{ // 3 formats\n\t\t\t\tformatString:         `0;(0);\"zero\"`,\n\t\t\t\tvalue:                \"asdf\",\n\t\t\t\tformattedValueOutput: \"asdf\",\n\t\t\t\tcellType:             CellTypeNumeric,\n\t\t\t\texpectError:          true,\n\t\t\t},\n\t\t\t{ // 3 formats\n\t\t\t\tformatString:         `0;(0);\"zero\"`,\n\t\t\t\tvalue:                \"asdf\",\n\t\t\t\tformattedValueOutput: \"asdf\",\n\t\t\t\tcellType:             CellTypeString,\n\t\t\t},\n\t\t\t{ // 4 formats, also note that the case of the format is maintained. Format codes should not be lower cased.\n\t\t\t\tformatString:         `0;(0);\"zero\";\"Behold: \"@`,\n\t\t\t\tvalue:                \"asdf\",\n\t\t\t\tformattedValueOutput: \"Behold: asdf\",\n\t\t\t\tcellType:             CellTypeString,\n\t\t\t},\n\t\t\t{ // 4 formats\n\t\t\t\tformatString:         `0;(0);\"zero\";\"Behold\": @`,\n\t\t\t\tvalue:                \"asdf\",\n\t\t\t\tformattedValueOutput: \"Behold: asdf\",\n\t\t\t\tcellType:             CellTypeString,\n\t\t\t},\n\t\t\t{ // 4 formats. This format contains an extra\n\t\t\t\tformatString:         `0;(0);\"zero\";\"Behold; \"@`,\n\t\t\t\tvalue:                \"asdf\",\n\t\t\t\tformattedValueOutput: \"Behold; asdf\",\n\t\t\t\tcellType:             CellTypeString,\n\t\t\t},\n\t\t}\n\t\tfor _, testCase := range testCases {\n\t\t\tcell := &Cell{\n\t\t\t\tcellType: testCase.cellType,\n\t\t\t\tNumFmt:   testCase.formatString,\n\t\t\t\tValue:    testCase.value,\n\t\t\t}\n\t\t\tval, err := cell.FormattedValue()\n\t\t\tif err != nil != testCase.expectError {\n\t\t\t\tc.Fatal(err, testCase)\n\t\t\t}\n\t\t\tif val != testCase.formattedValueOutput {\n\t\t\t\tc.Fatalf(\"Expected %v but got %v\", testCase.formattedValueOutput, val)\n\t\t\t}\n\t\t}\n\t})\n\n}\n\nfunc TestIsNumberFormat(t *testing.T) {\n\tc := qt.New(t)\n\n\tc.Assert(isTimeFormat(\"General\"), qt.Equals, false)\n\tc.Assert(isTimeFormat(\"0\"), qt.Equals, false)\n\tc.Assert(isTimeFormat(\"0.00\"), qt.Equals, false)\n\tc.Assert(isTimeFormat(\"#,##0\"), qt.Equals, false)\n\tc.Assert(isTimeFormat(\"#,##0.00\"), qt.Equals, false)\n\tc.Assert(isTimeFormat(\"0%\"), qt.Equals, false)\n\tc.Assert(isTimeFormat(\"0.00%\"), qt.Equals, false)\n\tc.Assert(isTimeFormat(\"0.00E+00\"), qt.Equals, false)\n\tc.Assert(isTimeFormat(`mm-dd-yy`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`d-mmm-yy`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`d-mmm`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`mmm-yy`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`h:mm AM/PM`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`h:mm:ss AM/PM`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`h:mm`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`h:mm:ss`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`m/d/yy h:mm`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`mm:ss`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`[h]:mm:ss`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`mmss.0`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`[$-404]e/m/d`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`yyyy\"年\"m\"月\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`[$-404]e\"年\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`m\"月\"d\"日\" m\"月\"d\"日\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`[$-404]e\"年\"m\"月\"d\"日\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`m\"月\"d\"日\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(` m/d/yy`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`m-d-yy`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`yyyy\"年\"m\"月\"d\"日\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`yyyy\"年\"m\"月\"d\"日\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`hh\"時\"mm\"分\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`h\"时\"mm\"分\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`[$-404]e/m/d`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`yyyy\"年\"m\"月\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`[$-404]e\"年\"m\"月\"d\"日\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`m\"月\"d\"日\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`[$-404]e\"年\"m\"月\"d\"日\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`m\"月\"d\"日\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`m/d/yy`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`m-d-yy`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`yyyy\"年\"m\"月\"d\"日\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`yyyy\"年\"m\"月\"d\"日\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`hh\"時\"mm\"分\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`h\"时\"mm\"分\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`hh\"時\"mm\"分\"ss\"秒\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`h\"时\"mm\"分\"ss\"秒\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`上午/下午 hh\"時\"mm\"分\"ss\"秒\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`上午/下午 h\"时\"mm\"分\"ss\"秒\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`[$-404]e/m/d`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`yyyy\"年\"m\"月\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`[$-404]e/m/d`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`yyyy\"年\"m\"月\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`[$-404]e\"年\"m\"月\"d\"日\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`m\"月\"d\"日\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`上午/下午`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`hh\"時\"mm\"分\" yyyy\"年\"m\"月\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`上午/下午`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`hh\"時\"mm\"分\"ss\"秒 \" m\"月\"d\"日\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`[$-409]M/D/YYYY`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`[$-404]e\"年\"m\"月\"d\"日\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`m\"月\"d\"日\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`上午/下午`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`hh\"時\"mm\"分\" 上午/下午 h\"时\"mm\"分\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`上午/下午`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`hh\"時\"mm\"分\"ss\"秒\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`下午`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`h\"时\"mm\"分\"ss\"秒\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`[$-404]e/m/d`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`yyyy\"年\"m\"月\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`[$-404]e\"年\"m\"月\"d\"日\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`m\"月\"d\"日\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`[$-404]e/m/d`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`yyyy\"5E74\"m\"6708\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`[$-404]e\"5E74\"m\"6708\"d\"65E5\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`m\"6708\"d\"65E5\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`[$-404]e\"5E74\"m\"6708\"d\"65E5\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`m\"6708\"d\"65E5\"`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`m/d/yy`), qt.Equals, true)\n\tc.Assert(isTimeFormat(`m-d-yy`), qt.Equals, true)\n}\n"
        },
        {
          "name": "fuzz.go",
          "type": "blob",
          "size": 0.353515625,
          "content": "//go:build gofuzz\n// +build gofuzz\n\npackage xlsx\n\n// Fuzz tests parsing and cell processing\nfunc Fuzz(fuzz []byte) int {\n\tfile, err := OpenBinary(fuzz)\n\tif err != nil {\n\t\treturn 0\n\t}\n\tfor _, sheet := range file.Sheets {\n\t\tsheet.ForEachRow(func(r *Row) error {\n\t\t\treturn r.ForEachCell(func(c *Cell) error {\n\t\t\t\tc.String()\n\t\t\t\treturn nil\n\t\t\t})\n\t\t})\n\t}\n\treturn 1\n}\n"
        },
        {
          "name": "fuzzit.sh",
          "type": "blob",
          "size": 0.7998046875,
          "content": "#!/bin/bash\nset -xe\n\n# Validate arguments\nif [ \"$#\" -ne 1 ]; then\n    echo \"Usage: $0 <fuzz-type>\"\n    exit 1\nfi\nif [ -z \"$FUZZIT_API_KEY\" ]; then\n    if [ \"$TRAVIS_PULL_REQUEST\" == \"false\" ]; then\n\techo \"Set FUZZIT_API_KEY to your Fuzzit API key\"\n\texit 2\n    else\n\techo \"Skipping FUZZIT because no key was available for the pull request\"\n\texit 0\n    fi\nfi\n\n# Configure\nNAME=xlsx\nTYPE=$1\n\n# Setup\nexport GO111MODULE=\"off\"\ngo get -u github.com/dvyukov/go-fuzz/go-fuzz github.com/dvyukov/go-fuzz/go-fuzz-build\ngo get -d -v -u ./...\nif [ ! -f fuzzit ]; then\n    wget -q -O fuzzit https://github.com/fuzzitdev/fuzzit/releases/download/v2.4.29/fuzzit_Linux_x86_64\n    chmod a+x fuzzit\nfi\n\n# Fuzz\ngo-fuzz-build -libfuzzer -o fuzzer.a .\nclang -fsanitize=fuzzer fuzzer.a -o fuzzer\n./fuzzit create job --type $TYPE $NAME fuzzer\n"
        },
        {
          "name": "fuzzy_test.go",
          "type": "blob",
          "size": 5.890625,
          "content": "//go:build fuzzy\n// +build fuzzy\n\npackage xlsx\n\nimport (\n\t\"archive/zip\"\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"math/rand\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t. \"gopkg.in/check.v1\"\n)\n\ntype Fuzzy struct{}\n\nvar _ = Suite(&Fuzzy{})\nvar randseed *int64 = flag.Int64(\"test.seed\", time.Now().Unix(), \"Set the random seed of the test for repeatable results\")\n\ntype tokenchange struct {\n\tfile bytes.Buffer\n\told  xml.Token\n\tnew  xml.Token\n}\n\ntype filechange struct {\n\tFile *zip.Reader\n\tName string\n\tOld  xml.Token\n\tNew  xml.Token\n}\n\nvar letters = []rune(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\")\nvar numbers = []rune(\"0123456789\")\n\nfunc randString(n int) []byte {\n\tb := make([]rune, n)\n\tfor i := range b {\n\t\tb[i] = letters[rand.Intn(len(letters))]\n\t}\n\treturn []byte(string(b))\n}\n\nfunc randInt(n int) []byte {\n\tb := make([]rune, n)\n\tfor i := range b {\n\t\tb[i] = numbers[rand.Intn(len(numbers))]\n\t}\n\treturn []byte(string(b))\n}\n\n// This function creates variations on tokens without regards as to positions in the file.\nfunc getTokenVariations(t xml.Token) []xml.Token {\n\tvar result []xml.Token = make([]xml.Token, 0)\n\tswitch t := t.(type) {\n\tcase xml.CharData:\n\t\t{\n\t\t\t//If the token is a number try some random number\n\t\t\tif _, err := strconv.Atoi(string(t)); err == nil {\n\t\t\t\tresult = append(result, xml.CharData(randInt(rand.Intn(15))))\n\t\t\t}\n\n\t\t\tresult = append(result, xml.CharData(randString(rand.Intn(100))))\n\t\t\treturn result\n\t\t}\n\tcase xml.StartElement:\n\t\t{\n\t\t\tfor k := range t.Attr {\n\t\t\t\tif _, err := strconv.Atoi(string(t.Attr[k].Value)); err == nil {\n\t\t\t\t\tstart := xml.CopyToken(t).(xml.StartElement)\n\t\t\t\t\tstart.Attr[k].Value = string(randInt(rand.Intn(15)))\n\t\t\t\t\tresult = append(result, start)\n\t\t\t\t}\n\t\t\t\tstart := xml.CopyToken(t).(xml.StartElement)\n\t\t\t\tstart.Attr[k].Value = string(randString(rand.Intn(100)))\n\t\t\t\tresult = append(result, start)\n\t\t\t}\n\t\t\treturn result\n\t\t}\n\n\tdefault:\n\t\t{\n\t\t\treturn make([]xml.Token, 0) // No variations on non char tokens yet\n\t\t}\n\t}\n}\n\nfunc variationsXML(f *zip.File) chan tokenchange {\n\tresult := make(chan tokenchange)\n\tr, _ := f.Open()\n\txmlReader := xml.NewDecoder(r)\n\tvar tokenList []xml.Token\n\tfor {\n\t\tif t, err := xmlReader.Token(); err == nil {\n\t\t\ttokenList = append(tokenList, xml.CopyToken(t))\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tgo func() {\n\t\t//Over every token we want to break\n\t\tfor TokenToBreak := range tokenList {\n\t\t\t//Get the ways we can break that token\n\t\t\tfor _, brokenToken := range getTokenVariations(tokenList[TokenToBreak]) {\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\txmlWriter := xml.NewEncoder(&buf)\n\t\t\t\t//Now create an xml file where one token is broken\n\t\t\t\tfor currentToken, t := range tokenList {\n\t\t\t\t\tif currentToken == TokenToBreak {\n\t\t\t\t\t\txmlWriter.EncodeToken(brokenToken)\n\t\t\t\t\t} else {\n\t\t\t\t\t\txmlWriter.EncodeToken(t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\txmlWriter.Flush()\n\t\t\t\tresult <- tokenchange{buf, tokenList[TokenToBreak], brokenToken}\n\t\t\t}\n\t\t}\n\t\tclose(result)\n\t}()\n\treturn result\n}\n\nfunc generateBrokenFiles(r *zip.Reader) chan filechange {\n\tresult := make(chan filechange)\n\tgo func() {\n\t\tcount := 0\n\t\t//For every file in the zip we want variation on\n\t\tfor breakIndex, fileToBreak := range r.File {\n\t\t\tif filepath.Ext(fileToBreak.Name) != \".xml\" {\n\t\t\t\tcontinue //We cannot create variations on non-xml files\n\t\t\t}\n\n\t\t\tvariationCount := 0\n\t\t\t//For every broken version of that file\n\t\t\tfor changedFile := range variationsXML(fileToBreak) {\n\t\t\t\tvariationCount++\n\t\t\t\tvar buffer bytes.Buffer\n\t\t\t\t//Create a new xlsx file in memory\n\t\t\t\toutZip := zip.NewWriter(&buffer)\n\t\t\t\tw, err := outZip.Create(fileToBreak.Name)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\t//Add modified file to xlsx\n\t\t\t\t_, err = changedFile.file.WriteTo(w)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Fatal(\"changedFile.file.WriteTo\", err)\n\t\t\t\t}\n\t\t\t\t//Add other, unchanged, files.\n\t\t\t\tfor otherIndex, otherFile := range r.File {\n\t\t\t\t\tif breakIndex == otherIndex {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tto, err := outZip.Create(otherFile.Name)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Fatal(\"Could not add new file to xlsx due to\", err)\n\t\t\t\t\t}\n\t\t\t\t\tfrom, err := otherFile.Open()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Fatal(\"Could not open original file from template xlsx due to\", err)\n\t\t\t\t\t}\n\t\t\t\t\tio.Copy(to, from)\n\t\t\t\t\tfrom.Close()\n\t\t\t\t}\n\t\t\t\toutZip.Close()\n\n\t\t\t\t//Return this combination of broken files\n\t\t\t\tb := buffer.Bytes()\n\t\t\t\tvar res filechange\n\t\t\t\tres.File, _ = zip.NewReader(bytes.NewReader(b), int64(len(b)))\n\t\t\t\tres.Name = fileToBreak.Name\n\t\t\t\tres.Old = changedFile.old\n\t\t\t\tres.New = changedFile.new\n\t\t\t\tresult <- res\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t\tclose(result)\n\t}()\n\treturn result\n}\n\nfunc Raises(f func()) (err interface{}) {\n\tdefer func() {\n\t\terr = recover()\n\t}()\n\terr = nil\n\tf()\n\treturn\n}\n\nfunc tokenToString(t xml.Token) string {\n\tswitch t := t.(type) {\n\tcase xml.CharData:\n\t\t{\n\t\t\treturn string(t)\n\t\t}\n\tdefault:\n\t\t{\n\t\t\treturn fmt.Sprint(t)\n\t\t}\n\t}\n}\n\nfunc (f *Fuzzy) TestRandomBrokenParts(c *C) {\n\tif testing.Short() {\n\t\tc.Log(\"This test, tests many versions of an xlsx file and might take a while, it is being skipped\")\n\t\tc.SucceedNow()\n\t}\n\tlog.Println(\"Fuzzy test is using this -test.seed=\" + strconv.FormatInt(*randseed, 10))\n\trand.Seed(*randseed)\n\ttemplate, err := zip.OpenReader(\"./testdocs/testfile.xlsx\")\n\tc.Assert(err, IsNil)\n\tdefer template.Close()\n\n\tcount := 0\n\n\tfor brokenFile := range generateBrokenFiles(&template.Reader) {\n\t\tcount++\n\t\tif testing.Verbose() {\n\t\t\t//If the library panics fatally it would be nice to know why\n\t\t\tlog.Println(\"Testing change to \", brokenFile.Name, \" on token \", tokenToString(brokenFile.Old), \" of type \", reflect.TypeOf(brokenFile.Old), \" to \", tokenToString(brokenFile.New))\n\t\t}\n\n\t\tif e := Raises(func() { ReadZipReader(brokenFile.File) }); e != nil {\n\n\t\t\tc.Log(\"Some file with random changes did raise an exception instead of returning an error\", e)\n\t\t\tc.Log(\"Testing change to \", brokenFile.Name, \" on token \", tokenToString(brokenFile.Old), \" of type \", reflect.TypeOf(brokenFile.Old), \" to \", tokenToString(brokenFile.New))\n\t\t\tc.FailNow()\n\t\t}\n\n\t}\n\tc.Succeed()\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.65625,
          "content": "module github.com/tealeg/xlsx/v3\n\ngo 1.18\n\nrequire (\n\tgithub.com/frankban/quicktest v1.14.6\n\tgithub.com/peterbourgon/diskv/v3 v3.0.1\n\tgithub.com/pkg/profile v1.5.0\n\tgithub.com/rogpeppe/fastuuid v1.2.0\n\tgithub.com/shabbyrobe/xmlwriter v0.0.0-20200208144257-9fca06d00ffa\n\tgopkg.in/check.v1 v1.0.0-20200902074654-038fdea0a05b\n)\n\nrequire (\n\tgithub.com/google/btree v1.0.0 // indirect\n\tgithub.com/google/go-cmp v0.5.9 // indirect\n\tgithub.com/kr/pretty v0.3.1 // indirect\n\tgithub.com/kr/text v0.2.0 // indirect\n\tgithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e // indirect\n\tgithub.com/rogpeppe/go-internal v1.9.0 // indirect\n\tgolang.org/x/text v0.3.8 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.8291015625,
          "content": "github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/frankban/quicktest v1.14.6 h1:7Xjx+VpznH+oBnejlPUj8oUpdxnVs4f8XU8WnHkI4W8=\ngithub.com/frankban/quicktest v1.14.6/go.mod h1:4ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=\ngithub.com/google/btree v1.0.0 h1:0udJVsspx3VBr5FwtLhQQtuAsVc79tTq0ocGIPAU6qo=\ngithub.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=\ngithub.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e h1:fD57ERR4JtEqsWbfPhv4DMiApHyliiK5xCTNVSPiaAs=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e/go.mod h1:zD1mROLANZcx1PVRCS0qkT7pwLkGfwJo4zjcN/Tysno=\ngithub.com/peterbourgon/diskv/v3 v3.0.1 h1:x06SQA46+PKIUftmEujdwSEpIx8kR+M9eLYsUxeYveU=\ngithub.com/peterbourgon/diskv/v3 v3.0.1/go.mod h1:kJ5Ny7vLdARGU3WUuy6uzO6T0nb/2gWcT1JiBvRmb5o=\ngithub.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=\ngithub.com/pkg/profile v1.5.0 h1:042Buzk+NhDI+DeSAA62RwJL8VAuZUMQZUjCsRz1Mug=\ngithub.com/pkg/profile v1.5.0/go.mod h1:qBsxPvzyUincmltOk6iyRVxHYg4adc0OFOv72ZdLa18=\ngithub.com/rogpeppe/fastuuid v1.2.0 h1:Ppwyp6VYCF1nvBTXL3trRso7mXMlRrw9ooo375wvi2s=\ngithub.com/rogpeppe/fastuuid v1.2.0/go.mod h1:jVj6XXZzXRy/MSR5jhDC/2q6DgLz+nrA6LYCDYWNEvQ=\ngithub.com/rogpeppe/go-internal v1.9.0 h1:73kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=\ngithub.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=\ngithub.com/shabbyrobe/xmlwriter v0.0.0-20200208144257-9fca06d00ffa h1:2cO3RojjYl3hVTbEvJVqrMaFmORhL6O06qdW42toftk=\ngithub.com/shabbyrobe/xmlwriter v0.0.0-20200208144257-9fca06d00ffa/go.mod h1:Yjr3bdWaVWyME1kha7X0jsz3k2DgXNa1Pj3XGyUAbx8=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/text v0.3.8 h1:nAL+RVCQ9uMn3vJZbV+MRnydTJFPf8qqY42YiA6MrqY=\ngolang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngopkg.in/check.v1 v1.0.0-20200902074654-038fdea0a05b h1:QRR6H1YWRnHb4Y/HeNFCTJLFVxaq6wH4YuVdsUOr75U=\ngopkg.in/check.v1 v1.0.0-20200902074654-038fdea0a05b/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\n"
        },
        {
          "name": "hsl.go",
          "type": "blob",
          "size": 3.6005859375,
          "content": "/*\nCopyright (c) 2012 Rodrigo Moraes. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n\t * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\t * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n\t * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\npackage xlsx\n\nimport (\n\t\"image/color\"\n\t\"math\"\n)\n\n// HSLModel converts any color.Color to a HSL color.\nvar HSLModel = color.ModelFunc(hslModel)\n\n// HSL represents a cylindrical coordinate of points in an RGB color model.\n//\n// Values are in the range 0 to 1.\ntype HSL struct {\n\tH, S, L float64\n}\n\n// RGBA returns the alpha-premultiplied red, green, blue and alpha values\n// for the HSL.\nfunc (c HSL) RGBA() (uint32, uint32, uint32, uint32) {\n\tr, g, b := HSLToRGB(c.H, c.S, c.L)\n\treturn uint32(r) * 0x101, uint32(g) * 0x101, uint32(b) * 0x101, 0xffff\n}\n\n// hslModel converts a color.Color to HSL.\nfunc hslModel(c color.Color) color.Color {\n\tif _, ok := c.(HSL); ok {\n\t\treturn c\n\t}\n\tr, g, b, _ := c.RGBA()\n\th, s, l := RGBToHSL(uint8(r>>8), uint8(g>>8), uint8(b>>8))\n\treturn HSL{h, s, l}\n}\n\n// RGBToHSL converts an RGB triple to a HSL triple.\n//\n// Ported from http://goo.gl/Vg1h9\nfunc RGBToHSL(r, g, b uint8) (h, s, l float64) {\n\tfR := float64(r) / 255\n\tfG := float64(g) / 255\n\tfB := float64(b) / 255\n\tmax := math.Max(math.Max(fR, fG), fB)\n\tmin := math.Min(math.Min(fR, fG), fB)\n\tl = (max + min) / 2\n\tif max == min {\n\t\t// Achromatic.\n\t\th, s = 0, 0\n\t} else {\n\t\t// Chromatic.\n\t\td := max - min\n\t\tif l > 0.5 {\n\t\t\ts = d / (2.0 - max - min)\n\t\t} else {\n\t\t\ts = d / (max + min)\n\t\t}\n\t\tswitch max {\n\t\tcase fR:\n\t\t\th = (fG - fB) / d\n\t\t\tif fG < fB {\n\t\t\t\th += 6\n\t\t\t}\n\t\tcase fG:\n\t\t\th = (fB-fR)/d + 2\n\t\tcase fB:\n\t\t\th = (fR-fG)/d + 4\n\t\t}\n\t\th /= 6\n\t}\n\treturn\n}\n\n// HSLToRGB converts an HSL triple to a RGB triple.\n//\n// Ported from http://goo.gl/Vg1h9\nfunc HSLToRGB(h, s, l float64) (r, g, b uint8) {\n\tvar fR, fG, fB float64\n\tif s == 0 {\n\t\tfR, fG, fB = l, l, l\n\t} else {\n\t\tvar q float64\n\t\tif l < 0.5 {\n\t\t\tq = l * (1 + s)\n\t\t} else {\n\t\t\tq = l + s - s*l\n\t\t}\n\t\tp := 2*l - q\n\t\tfR = hueToRGB(p, q, h+1.0/3)\n\t\tfG = hueToRGB(p, q, h)\n\t\tfB = hueToRGB(p, q, h-1.0/3)\n\t}\n\tr = uint8((fR * 255) + 0.5)\n\tg = uint8((fG * 255) + 0.5)\n\tb = uint8((fB * 255) + 0.5)\n\treturn\n}\n\n// hueToRGB is a helper function for HSLToRGB.\nfunc hueToRGB(p, q, t float64) float64 {\n\tif t < 0 {\n\t\tt += 1\n\t}\n\tif t > 1 {\n\t\tt -= 1\n\t}\n\tif t < 1.0/6 {\n\t\treturn p + (q-p)*6*t\n\t}\n\tif t < 0.5 {\n\t\treturn q\n\t}\n\tif t < 2.0/3 {\n\t\treturn p + (q-p)*(2.0/3-t)*6\n\t}\n\treturn p\n}\n"
        },
        {
          "name": "lib.go",
          "type": "blob",
          "size": 35.7607421875,
          "content": "package xlsx\n\nimport (\n\t\"archive/zip\"\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime/debug\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n)\n\nconst (\n\tfixedCellRefChar      = \"$\"\n\tcellRangeChar         = \":\"\n\texternalSheetBangChar = \"!\"\n)\n\nvar (\n\txlsxSIPool = sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\treturn &xlsxSI{}\n\t\t},\n\t}\n\n\txmlAttrPool = sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\treturn &xml.Attr{}\n\t\t},\n\t}\n)\n\n// XLSXReaderError is the standard error type for otherwise undefined\n// errors in the XSLX reading process.\ntype XLSXReaderError struct {\n\tErr string\n}\n\n// Error returns a string value from an XLSXReaderError struct in order\n// that it might comply with the builtin.error interface.\nfunc (e *XLSXReaderError) Error() string {\n\treturn e.Err\n}\n\n// getRangeFromString is an internal helper function that converts\n// XLSX internal range syntax to a pair of integers.  For example,\n// the range string \"1:3\" yield the upper and lower integers 1 and 3.\nfunc getRangeFromString(rangeString string) (int, int, error) {\n\tvar lower, upper int\n\tvar err error\n\tparts := strings.SplitN(rangeString, cellRangeChar, 2)\n\tif parts[0] == \"\" {\n\t\treturn 0, 0, fmt.Errorf(\"invalid range '%s'\", rangeString)\n\t}\n\tif parts[1] == \"\" {\n\t\treturn 0, 0, fmt.Errorf(\"invalid range '%s'\", rangeString)\n\t}\n\tlower, err = strconv.Atoi(parts[0])\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"invalid range (not integer in lower bound) %s\", rangeString)\n\t}\n\tupper, err = strconv.Atoi(parts[1])\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"invalid range (not integer in upper bound) %s\", rangeString)\n\t}\n\treturn lower, upper, err\n}\n\n// ColLettersToIndex is used to convert a character based column\n// reference to a zero based numeric column identifier.\nfunc ColLettersToIndex(letters string) int {\n\tsum, mul, n := 0, 1, 0\n\tfor i := len(letters) - 1; i >= 0; i, mul, n = i-1, mul*26, 1 {\n\t\tc := letters[i]\n\t\tswitch {\n\t\tcase 'A' <= c && c <= 'Z':\n\t\t\tn += int(c - 'A')\n\t\tcase 'a' <= c && c <= 'z':\n\t\t\tn += int(c - 'a')\n\t\t}\n\t\tsum += n * mul\n\t}\n\treturn sum\n}\n\n// ColIndexToLetters is used to convert a zero based, numeric column\n// indentifier into a character code.\nfunc ColIndexToLetters(n int) string {\n\t// taken from https://github.com/psmithuk/xlsx/blob/master/xlsx.go\n\tvar s string\n\tn += 1\n\n\tfor n > 0 {\n\t\tn -= 1\n\t\tl := n % 26\n\t\ts = string('A'+rune(l)) + s\n\t\tn /= 26\n\t}\n\n\treturn s\n}\n\n// RowIndexToString is used to convert a zero based, numeric row\n// indentifier into its string representation.\nfunc RowIndexToString(rowRef int) string {\n\treturn strconv.Itoa(rowRef + 1)\n}\n\n// letterOnlyMapF is used in conjunction with strings.Map to return\n// only the characters A-Z and a-z in a string\nfunc letterOnlyMapF(rune rune) rune {\n\tswitch {\n\tcase 'A' <= rune && rune <= 'Z':\n\t\treturn rune\n\tcase 'a' <= rune && rune <= 'z':\n\t\treturn rune - 32\n\t}\n\treturn -1\n}\n\n// intOnlyMapF is used in conjunction with strings.Map to return only\n// the numeric portions of a string.\nfunc intOnlyMapF(rune rune) rune {\n\tif rune >= 48 && rune < 58 {\n\t\treturn rune\n\t}\n\treturn -1\n}\n\n// GetCoordsFromCellIDString returns the zero based cartesian\n// coordinates from a cell name in Excel format, e.g. the cellIDString\n// \"A1\" returns 0, 0 and the \"B3\" return 1, 2.\nfunc GetCoordsFromCellIDString(cellIDString string) (x, y int, err error) {\n\twrap := func(err error) (int, int, error) {\n\t\treturn -1, -1, fmt.Errorf(\"GetCoordsFromCellIdString(%q): %w\", cellIDString, err)\n\t}\n\tvar letterPart string = strings.Map(letterOnlyMapF, cellIDString)\n\ty, err = strconv.Atoi(strings.Map(intOnlyMapF, cellIDString))\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\ty -= 1 // Zero based\n\tx = ColLettersToIndex(letterPart)\n\treturn x, y, nil\n}\n\n// GetCellIDStringFromCoords returns the Excel format cell name that\n// represents a pair of zero based cartesian coordinates.\nfunc GetCellIDStringFromCoords(x, y int) string {\n\treturn GetCellIDStringFromCoordsWithFixed(x, y, false, false)\n}\n\n// GetCellIDStringFromCoordsWithFixed returns the Excel format cell name that\n// represents a pair of zero based cartesian coordinates.\n// It can specify either value as fixed.\nfunc GetCellIDStringFromCoordsWithFixed(x, y int, xFixed, yFixed bool) string {\n\txStr := ColIndexToLetters(x)\n\tif xFixed {\n\t\txStr = fixedCellRefChar + xStr\n\t}\n\tyStr := RowIndexToString(y)\n\tif yFixed {\n\t\tyStr = fixedCellRefChar + yStr\n\t}\n\treturn xStr + yStr\n}\n\n// getMaxMinFromDimensionRef return the zero based cartesian maximum\n// and minimum coordinates from the dimension reference embedded in a\n// XLSX worksheet.  For example, the dimension reference \"A1:B2\"\n// returns \"0,0\", \"1,1\".\nfunc getMaxMinFromDimensionRef(ref string) (minx, miny, maxx, maxy int, err error) {\n\tvar parts []string\n\twrap := func(err error) (int, int, int, int, error) {\n\t\treturn -1, -1, -1, -1, fmt.Errorf(\"getMaxMinFromDimensionRef: %w\", err)\n\t}\n\n\tparts = strings.Split(ref, cellRangeChar)\n\tminx, miny, err = GetCoordsFromCellIDString(parts[0])\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\tmaxx, maxy, err = GetCoordsFromCellIDString(parts[1])\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\treturn\n}\n\n// calculateMaxMinFromWorkSheet works out the dimensions of a spreadsheet\n// that doesn't have a DimensionRef set.  The only case currently\n// known where this is true is with XLSX exported from Google Docs.\nfunc calculateMaxMinFromWorksheet(worksheet *xlsxWorksheet, colLimit int) (minx, miny, maxx, maxy int, err error) {\n\t// Note, this method could be very slow for large spreadsheets.\n\tvar x, y int\n\tvar maxVal int\n\n\twrap := func(err error) (int, int, int, int, error) {\n\t\treturn -1, -1, -1, -1, fmt.Errorf(\"calculateMaxMinFromWorksheet: %w\", err)\n\t}\n\n\tmaxVal = int(^uint(0) >> 1)\n\tminx = maxVal\n\tminy = maxVal\n\tmaxy = 0\n\tmaxx = 0\n\tfor _, row := range worksheet.SheetData.Row {\n\t\tfor _, cell := range row.C {\n\t\t\tx, y, err = GetCoordsFromCellIDString(cell.R)\n\t\t\tif err != nil {\n\t\t\t\treturn wrap(err)\n\t\t\t}\n\n\t\t\t// break out of the loop if a column limit is set\n\t\t\tif colLimit != NoColLimit && x+1 > colLimit {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif x < minx {\n\t\t\t\tminx = x\n\t\t\t}\n\t\t\tif x > maxx {\n\t\t\t\tmaxx = x\n\t\t\t}\n\t\t\tif y < miny {\n\t\t\t\tminy = y\n\t\t\t}\n\t\t\tif y > maxy {\n\t\t\t\tmaxy = y\n\t\t\t}\n\t\t}\n\t}\n\tif minx == maxVal {\n\t\tminx = 0\n\t}\n\tif miny == maxVal {\n\t\tminy = 0\n\t}\n\treturn\n}\n\n// makeRowFromSpan will, when given a span expressed as a string,\n// return an empty Row large enough to encompass that span and\n// populate it with empty cells.  All rows start from cell 1 -\n// regardless of the lower bound of the span.\nfunc makeRowFromSpan(spans string, sheet *Sheet) *Row {\n\t_, upper, err := getRangeFromString(spans)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\trow := sheet.cellStore.MakeRowWithLen(sheet, upper)\n\treturn row\n}\n\n// makeRowFromRaw returns the Row representation of the xlsxRow.\nfunc makeRowFromRaw(rawrow xlsxRow, sheet *Sheet) *Row {\n\tvar upper int\n\n\tupper = -1\n\tfor _, rawcell := range rawrow.C {\n\t\tif rawcell.R != \"\" {\n\t\t\tx, _, error := GetCoordsFromCellIDString(rawcell.R)\n\t\t\tif error != nil {\n\t\t\t\tpanic(fmt.Sprintf(\"Invalid Cell Coord, %s\\n\", rawcell.R))\n\t\t\t}\n\t\t\tif x > upper {\n\t\t\t\tupper = x\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tupper++\n\t}\n\tupper++\n\n\trow := sheet.cellStore.MakeRowWithLen(sheet, upper)\n\trow.SetOutlineLevel(rawrow.OutlineLevel)\n\treturn row\n}\n\ntype sharedFormula struct {\n\tx, y    int\n\tformula string\n}\n\nfunc formulaForCell(rawcell xlsxC, sharedFormulas map[int]sharedFormula) string {\n\tvar res string\n\n\tf := rawcell.F\n\tif f == nil {\n\t\treturn \"\"\n\t}\n\tif f.T == \"shared\" {\n\t\tx, y, err := GetCoordsFromCellIDString(rawcell.R)\n\t\tif err != nil {\n\t\t\tres = f.Content\n\t\t} else {\n\t\t\tif f.Ref != \"\" {\n\t\t\t\tres = f.Content\n\t\t\t\tsharedFormulas[f.Si] = sharedFormula{x, y, res}\n\t\t\t} else {\n\t\t\t\tsharedFormula := sharedFormulas[f.Si]\n\t\t\t\tdx := x - sharedFormula.x\n\t\t\t\tdy := y - sharedFormula.y\n\t\t\t\torig := []byte(sharedFormula.formula)\n\t\t\t\tvar start, end int\n\t\t\t\tvar stringLiteral bool\n\t\t\t\tfor end = 0; end < len(orig); end++ {\n\t\t\t\t\tc := orig[end]\n\n\t\t\t\t\tif c == '\"' {\n\t\t\t\t\t\tstringLiteral = !stringLiteral\n\t\t\t\t\t}\n\n\t\t\t\t\tif stringLiteral {\n\t\t\t\t\t\tcontinue // Skip characters in quotes\n\t\t\t\t\t}\n\n\t\t\t\t\tif c >= 'A' && c <= 'Z' || c == '$' {\n\t\t\t\t\t\tres += string(orig[start:end])\n\t\t\t\t\t\tstart = end\n\t\t\t\t\t\tend++\n\t\t\t\t\t\tfoundNum := false\n\t\t\t\t\t\tfor ; end < len(orig); end++ {\n\t\t\t\t\t\t\tidc := orig[end]\n\t\t\t\t\t\t\tif idc >= '0' && idc <= '9' || idc == '$' {\n\t\t\t\t\t\t\t\tfoundNum = true\n\t\t\t\t\t\t\t} else if idc >= 'A' && idc <= 'Z' {\n\t\t\t\t\t\t\t\tif foundNum {\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif foundNum {\n\t\t\t\t\t\t\tcellID := string(orig[start:end])\n\t\t\t\t\t\t\tres += shiftCell(cellID, dx, dy)\n\t\t\t\t\t\t\tstart = end\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif start < len(orig) {\n\t\t\t\t\tres += string(orig[start:])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tres = f.Content\n\t}\n\treturn strings.Trim(res, \" \\t\\n\\r\")\n}\n\n// shiftCell returns the cell shifted according to dx and dy taking into consideration of absolute\n// references with dollar sign ($)\nfunc shiftCell(cellID string, dx, dy int) string {\n\tfx, fy, _ := GetCoordsFromCellIDString(cellID)\n\n\t// Is fixed column?\n\tfixedCol := strings.Index(cellID, fixedCellRefChar) == 0\n\n\t// Is fixed row?\n\tfixedRow := strings.LastIndex(cellID, fixedCellRefChar) > 0\n\n\tif !fixedCol {\n\t\t// Shift column\n\t\tfx += dx\n\t}\n\n\tif !fixedRow {\n\t\t// Shift row\n\t\tfy += dy\n\t}\n\n\t// New shifted cell\n\tshiftedCellID := GetCellIDStringFromCoords(fx, fy)\n\n\tif !fixedCol && !fixedRow {\n\t\treturn shiftedCellID\n\t}\n\n\t// There are absolute references, need to put the $ back into the formula.\n\tletterPart := strings.Map(letterOnlyMapF, shiftedCellID)\n\tnumberPart := strings.Map(intOnlyMapF, shiftedCellID)\n\n\tresult := \"\"\n\n\tif fixedCol {\n\t\tresult += \"$\"\n\t}\n\n\tresult += letterPart\n\n\tif fixedRow {\n\t\tresult += \"$\"\n\t}\n\n\tresult += numberPart\n\n\treturn result\n}\n\n// fillCellData attempts to extract a valid value, usable in\n// CSV form from the raw cell value.  Note - this is not actually\n// general enough - we should support retaining tabs and newlines.\nfunc fillCellData(rawCell xlsxC, refTable *RefTable, sharedFormulas map[int]sharedFormula, cell *Cell) {\n\tval := strings.Trim(rawCell.V, \" \\t\\n\\r\")\n\tcell.formula = formulaForCell(rawCell, sharedFormulas)\n\tswitch rawCell.T {\n\tcase \"s\": // Shared String\n\t\tcell.cellType = CellTypeString\n\t\tif val != \"\" {\n\t\t\tref, err := strconv.Atoi(val)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tcell.Value, cell.RichText = refTable.ResolveSharedString(ref)\n\t\t}\n\tcase \"inlineStr\":\n\t\tcell.cellType = CellTypeInline\n\t\tfillCellDataFromInlineString(rawCell, cell)\n\tcase \"b\": // Boolean\n\t\tcell.Value = val\n\t\tcell.cellType = CellTypeBool\n\tcase \"e\": // Error\n\t\tcell.Value = val\n\t\tcell.cellType = CellTypeError\n\tcase \"str\":\n\t\t// String Formula (special type for cells with formulas that return a string value)\n\t\t// Unlike the other string cell types, the string is stored directly in the value.\n\t\tcell.Value = val\n\t\tcell.cellType = CellTypeStringFormula\n\tcase \"d\": // Date: Cell contains a date in the ISO 8601 format.\n\t\tcell.Value = val\n\t\tcell.cellType = CellTypeDate\n\tcase \"\": // Numeric is the default\n\t\tfallthrough\n\tcase \"n\": // Numeric\n\t\tcell.Value = val\n\t\tcell.cellType = CellTypeNumeric\n\tdefault:\n\t\tpanic(errors.New(\"invalid cell type\"))\n\t}\n\tcell.origValue = cell.Value\n\tcell.origRichText = cell.RichText\n\tcell.modified = false\n}\n\n// fillCellDataFromInlineString attempts to get inline string data and put it into a Cell.\nfunc fillCellDataFromInlineString(rawcell xlsxC, cell *Cell) {\n\tcell.Value = \"\"\n\tcell.RichText = nil\n\tif rawcell.Is != nil {\n\t\tif rawcell.Is.T != nil {\n\t\t\tcell.Value = strings.Trim(rawcell.Is.T.getText(), \" \\t\\n\\r\")\n\t\t} else {\n\t\t\tcell.RichText = xmlToRichText(rawcell.Is.R)\n\t\t}\n\t}\n\tcell.origValue = cell.Value\n\tcell.origRichText = cell.RichText\n\tcell.modified = false\n}\n\n// readRowsFromSheet is an internal helper function that extracts the\n// rows from a XSLXWorksheet, populates them with Cells and resolves\n// the value references from the reference table and stores them in\n// the rows and columns.\nfunc readRowsFromSheet(Worksheet *xlsxWorksheet, file *File, sheet *Sheet, rowLimit, colLimit int, linkTable hyperlinkTable) error {\n\tvar row *Row\n\tvar maxCol, maxRow, colCount, rowCount int\n\tvar reftable *RefTable\n\tvar err error\n\tvar insertRowIndex int // , insertColIndex int\n\tsharedFormulas := map[int]sharedFormula{}\n\n\twrap := func(err error) error {\n\t\treturn fmt.Errorf(\"readRowsFromSheet: %w\", err)\n\t}\n\tif len(Worksheet.SheetData.Row) == 0 {\n\t\tsheet.MaxRow = 0\n\t\tsheet.MaxCol = 0\n\t\treturn nil\n\t}\n\treftable = file.referenceTable\n\tif len(Worksheet.Dimension.Ref) > 0 && len(strings.Split(Worksheet.Dimension.Ref, cellRangeChar)) == 2 && rowLimit == NoRowLimit && colLimit == NoColLimit {\n\t\t_, _, maxCol, maxRow, err = getMaxMinFromDimensionRef(Worksheet.Dimension.Ref)\n\t} else {\n\t\t_, _, maxCol, maxRow, err = calculateMaxMinFromWorksheet(Worksheet, colLimit)\n\t}\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\n\trowCount = maxRow + 1\n\tcolCount = maxCol + 1\n\n\tif Worksheet.Cols != nil {\n\t\t// Columns can apply to a range, for convenience we expand the\n\t\t// ranges out into individual column definitions.\n\t\tfor _, rawcol := range Worksheet.Cols.Col {\n\n\t\t\tcol := &Col{\n\t\t\t\tHidden:       rawcol.Hidden,\n\t\t\t\tWidth:        rawcol.Width,\n\t\t\t\tMin:          rawcol.Min,\n\t\t\t\tMax:          rawcol.Max,\n\t\t\t\tOutlineLevel: rawcol.OutlineLevel,\n\t\t\t\tBestFit:      rawcol.BestFit,\n\t\t\t\tCustomWidth:  rawcol.CustomWidth,\n\t\t\t\tPhonetic:     rawcol.Phonetic,\n\t\t\t\tCollapsed:    rawcol.Collapsed,\n\t\t\t}\n\n\t\t\tif file.styles != nil {\n\t\t\t\tif rawcol.Style != nil && *rawcol.Style > 0 {\n\t\t\t\t\tcol.style = file.styles.getStyle(*rawcol.Style)\n\t\t\t\t\tcol.numFmt, col.parsedNumFmt = file.styles.getNumberFormat(*rawcol.Style)\n\t\t\t\t}\n\t\t\t}\n\t\t\tsheet.Cols.Add(col)\n\t\t}\n\t}\n\n\tfor rowIndex := 0; rowIndex < len(Worksheet.SheetData.Row); rowIndex++ {\n\t\trawrow := Worksheet.SheetData.Row[rowIndex]\n\t\t// range is not empty and only one range exist\n\t\tif len(rawrow.Spans) != 0 && strings.Count(rawrow.Spans, cellRangeChar) == 1 {\n\t\t\trow = makeRowFromSpan(rawrow.Spans, sheet)\n\t\t} else {\n\t\t\trow = makeRowFromRaw(rawrow, sheet)\n\t\t}\n\t\tsheet.setCurrentRow(row)\n\t\trow.num = rawrow.R - 1\n\n\t\trow.Hidden = rawrow.Hidden\n\t\theight, err := strconv.ParseFloat(rawrow.Ht, 64)\n\t\tif err == nil {\n\t\t\trow.SetHeight(height)\n\t\t}\n\t\trow.isCustom = rawrow.CustomHeight\n\t\trow.SetOutlineLevel(rawrow.OutlineLevel)\n\n\t\tfor _, rawcell := range rawrow.C {\n\t\t\tif rawcell.R == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\th, v, err := Worksheet.MergeCells.getExtent(rawcell.R)\n\t\t\tif err != nil {\n\t\t\t\treturn wrap(err)\n\t\t\t}\n\t\t\tx, y, err := GetCoordsFromCellIDString(rawcell.R)\n\t\t\tif err != nil {\n\t\t\t\treturn wrap(err)\n\t\t\t}\n\n\t\t\t// break out of the loop if column limit is set\n\t\t\tif colLimit != NoColLimit && colLimit < x+1 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tcellX := x\n\n\t\t\tcell := newCell(row, cellX)\n\t\t\trow.PushCell(cell)\n\t\t\tcell.HMerge = h\n\t\t\tcell.VMerge = v\n\t\t\tfillCellData(rawcell, reftable, sharedFormulas, cell)\n\t\t\tif file.styles != nil {\n\t\t\t\tcell.SetStyle(file.styles.getStyle(rawcell.S))\n\t\t\t\tcell.NumFmt, cell.parsedNumFmt = file.styles.getNumberFormat(rawcell.S)\n\t\t\t}\n\t\t\tcell.date1904 = file.Date1904\n\n\t\t\tif hyperlink, found := linkTable[coord{x: x, y: y}]; found {\n\t\t\t\tcell.Hyperlink = hyperlink\n\t\t\t}\n\n\t\t\t// Cell is considered hidden if the row or the column of this cell is hidden\n\t\t\tcol := sheet.Cols.FindColByIndex(cellX + 1)\n\t\t\tcell.Hidden = rawrow.Hidden || (col != nil && col.Hidden != nil && *col.Hidden)\n\t\t\tcell.modified = true\n\t\t}\n\t\tsheet.cellStore.WriteRow(row)\n\n\t\tinsertRowIndex++\n\t}\n\tsheet.MaxRow = rowCount\n\tsheet.MaxCol = colCount\n\n\tif rowCount >= 0 {\n\t\trow, err = sheet.Row(0)\n\t\tif err != nil {\n\t\t\treturn wrap(err)\n\t\t}\n\t\tsheet.setCurrentRow(row)\n\t}\n\n\treturn nil\n}\n\ntype indexedSheet struct {\n\tIndex int\n\tSheet *Sheet\n\tError error\n}\n\nfunc readSheetViews(xSheetViews xlsxSheetViews) []SheetView {\n\tif len(xSheetViews.SheetView) == 0 {\n\t\treturn nil\n\t}\n\tsheetViews := []SheetView{}\n\tfor _, xSheetView := range xSheetViews.SheetView {\n\t\tsheetView := SheetView{}\n\t\tif xSheetView.Pane != nil {\n\t\t\txlsxPane := xSheetView.Pane\n\t\t\tpane := &Pane{}\n\t\t\tpane.XSplit = xlsxPane.XSplit\n\t\t\tpane.YSplit = xlsxPane.YSplit\n\t\t\tpane.TopLeftCell = xlsxPane.TopLeftCell\n\t\t\tpane.ActivePane = xlsxPane.ActivePane\n\t\t\tpane.State = xlsxPane.State\n\t\t\tsheetView.Pane = pane\n\t\t}\n\t\tsheetViews = append(sheetViews, sheetView)\n\t}\n\treturn sheetViews\n}\n\ntype coord struct {\n\tx int\n\ty int\n}\n\ntype hyperlinkTable map[coord]Hyperlink\n\nfunc makeHyperlinkTable(worksheet *xlsxWorksheet, fi *File, rsheet *xlsxSheet) (hyperlinkTable, error) {\n\twrap := func(err error) (hyperlinkTable, error) {\n\t\treturn nil, fmt.Errorf(\"makeHyperlinkTable: %w\", err)\n\t}\n\n\ttable := make(hyperlinkTable)\n\n\t// Convert xlsxHyperlinks to Hyperlinks\n\tif worksheet.Hyperlinks != nil {\n\n\t\tworksheetRelsFile, ok := fi.worksheetRels[\"sheet\"+rsheet.SheetId]\n\t\tworksheetRels := new(xlsxWorksheetRels)\n\t\tif ok {\n\t\t\trc, err := worksheetRelsFile.Open()\n\t\t\tif err != nil {\n\t\t\t\treturn wrap(fmt.Errorf(\"file.Open: %w\", err))\n\t\t\t}\n\t\t\tdefer rc.Close()\n\n\t\t\tdecoder := xml.NewDecoder(rc)\n\t\t\terr = decoder.Decode(worksheetRels)\n\t\t\tif err != nil {\n\t\t\t\treturn wrap(fmt.Errorf(\"xml.Decoder.Decode: %w\", err))\n\t\t\t}\n\t\t}\n\t\tfor _, xlsxLink := range worksheet.Hyperlinks.HyperLinks {\n\t\t\tnewHyperLink := Hyperlink{}\n\n\t\t\tfor _, rel := range worksheetRels.Relationships {\n\t\t\t\tif rel.Id == xlsxLink.RelationshipId {\n\t\t\t\t\tnewHyperLink.Link = rel.Target\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif xlsxLink.Tooltip != \"\" {\n\t\t\t\tnewHyperLink.Tooltip = xlsxLink.Tooltip\n\t\t\t}\n\t\t\tif xlsxLink.DisplayString != \"\" {\n\t\t\t\tnewHyperLink.DisplayString = xlsxLink.DisplayString\n\t\t\t}\n\t\t\tif xlsxLink.Location != \"\" {\n\t\t\t\tnewHyperLink.Location = xlsxLink.Location\n\t\t\t}\n\t\t\tcellRef := xlsxLink.Reference\n\t\t\tx, y, err := GetCoordsFromCellIDString(cellRef)\n\t\t\tif err != nil {\n\t\t\t\treturn wrap(err)\n\t\t\t}\n\t\t\ttable[coord{x: x, y: y}] = newHyperLink\n\t\t}\n\n\t\t// \trow, err := sheet.Row(y)\n\t\t// \tif err != nil {\n\t\t// \t\treturn wrap(err)\n\t\t// \t}\n\t\t// \tfmt.Printf(\"%d, %d, %+v\\n\", x, y, row)\n\n\t\t// \t// cell := row.GetCell(x)\n\t\t// \t// cell.Hyperlink = newHyperLink\n\t\t// }\n\t}\n\treturn table, nil\n}\n\n// readSheetFromFile is the logic of converting a xlsxSheet struct\n// into a Sheet struct.  This work can be done in parallel and so\n// readSheetsFromZipFile will spawn an instance of this function per\n// sheet and get the results back on the provided channel.\nfunc readSheetFromFile(rsheet xlsxSheet, fi *File, sheetXMLMap map[string]string, rowLimit, colLimit int, valueOnly bool) (sheet *Sheet, errRes error) {\n\tdefer func() {\n\t\tif x := recover(); x != nil {\n\t\t\terrRes = fmt.Errorf(\"%v\\n%s\", x, debug.Stack())\n\t\t}\n\t}()\n\n\twrap := func(err error) (*Sheet, error) {\n\t\treturn nil, fmt.Errorf(\"readSheetFromFile: %w\", err)\n\t}\n\n\tworksheet, err := getWorksheetFromSheet(rsheet, fi.worksheets, sheetXMLMap, rowLimit, valueOnly)\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\n\tlinkTable, err := makeHyperlinkTable(worksheet, fi, &rsheet)\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\n\tsheet, err = NewSheetWithCellStore(rsheet.Name, fi.cellStoreConstructor)\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\n\tsheet.File = fi\n\terr = readRowsFromSheet(worksheet, fi, sheet, rowLimit, colLimit, linkTable)\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\n\tsheet.Hidden = rsheet.State == sheetStateHidden || rsheet.State == sheetStateVeryHidden\n\tsheet.SheetViews = readSheetViews(worksheet.SheetViews)\n\tif worksheet.AutoFilter != nil {\n\t\tautoFilterBounds := strings.Split(worksheet.AutoFilter.Ref, \":\")\n\n\t\tbottomRightCell := autoFilterBounds[0]\n\t\tif len(autoFilterBounds) > 1 {\n\t\t\tbottomRightCell = autoFilterBounds[1]\n\t\t}\n\n\t\tsheet.AutoFilter = &AutoFilter{autoFilterBounds[0], bottomRightCell}\n\t}\n\n\tsheet.SheetFormat.DefaultColWidth = worksheet.SheetFormatPr.DefaultColWidth\n\tsheet.SheetFormat.DefaultRowHeight = worksheet.SheetFormatPr.DefaultRowHeight\n\tsheet.SheetFormat.OutlineLevelCol = worksheet.SheetFormatPr.OutlineLevelCol\n\tsheet.SheetFormat.OutlineLevelRow = worksheet.SheetFormatPr.OutlineLevelRow\n\tif nil != worksheet.DataValidations {\n\t\tfor _, dd := range worksheet.DataValidations.DataValidation {\n\t\t\tsheet.AddDataValidation(dd)\n\t\t}\n\n\t}\n\n\treturn sheet, nil\n}\n\n// readSheetsFromZipFile is an internal helper function that loops\n// over the Worksheets defined in the XSLXWorkbook and loads them into\n// Sheet objects stored in the Sheets slice of a xlsx.File struct.\nfunc readSheetsFromZipFile(f *zip.File, file *File, sheetXMLMap map[string]string, rowLimit, colLimit int, valueOnly bool) (map[string]*Sheet, []*Sheet, error) {\n\tvar workbook *xlsxWorkbook\n\tvar err error\n\tvar rc io.ReadCloser\n\tvar decoder *xml.Decoder\n\tvar sheetCount int\n\n\twrap := func(err error) (map[string]*Sheet, []*Sheet, error) {\n\t\treturn nil, nil, fmt.Errorf(\"readSheetsFromZipFile: %w\", err)\n\t}\n\n\tworkbook = new(xlsxWorkbook)\n\trc, err = f.Open()\n\tif err != nil {\n\t\treturn wrap(fmt.Errorf(\"file.Open: %w\", err))\n\t}\n\tdefer rc.Close()\n\n\tdecoder = xml.NewDecoder(rc)\n\terr = decoder.Decode(workbook)\n\tif err != nil {\n\t\treturn wrap(fmt.Errorf(\"xml.Decoder.Decode: %w\", err))\n\t}\n\tfile.Date1904 = workbook.WorkbookPr.Date1904\n\n\tfor entryNum := range workbook.DefinedNames.DefinedName {\n\t\tfile.DefinedNames = append(file.DefinedNames, &workbook.DefinedNames.DefinedName[entryNum])\n\t}\n\n\t// Only try and read sheets that have corresponding files.\n\t// Notably this excludes chartsheets don't right now\n\tvar workbookSheets []xlsxSheet\n\tfor _, sheet := range workbook.Sheets.Sheet {\n\t\tif f := worksheetFileForSheet(sheet, file.worksheets, sheetXMLMap); f != nil {\n\t\t\tworkbookSheets = append(workbookSheets, sheet)\n\t\t}\n\t}\n\tsheetCount = len(workbookSheets)\n\tsheetsByName := make(map[string]*Sheet, sheetCount)\n\tsheets := make([]*Sheet, sheetCount)\n\tsheetChan := make(chan *indexedSheet, sheetCount)\n\n\tfor i, rawsheet := range workbookSheets {\n\t\ti, rawsheet := i, rawsheet\n\t\tgo func() {\n\t\t\tsheet, err := readSheetFromFile(rawsheet, file,\n\t\t\t\tsheetXMLMap, rowLimit, colLimit, valueOnly)\n\t\t\tsheetChan <- &indexedSheet{\n\t\t\t\tIndex: i,\n\t\t\t\tSheet: sheet,\n\t\t\t\tError: err,\n\t\t\t}\n\t\t}()\n\t}\n\n\tvar sb strings.Builder\n\terrFound := false\n\terr = nil\n\tfor j := 0; j < sheetCount; j++ {\n\t\tsheet := <-sheetChan\n\t\tif sheet == nil {\n\t\t\terrFound = true\n\t\t\tsb.WriteString(\"{SheetIndex: \")\n\t\t\tsb.WriteString(strconv.Itoa(j))\n\t\t\tsb.WriteString(\"} No sheet returned from readSheetFromFile\\n\")\n\t\t} else {\n\t\t\tif sheet.Error != nil {\n\t\t\t\terrFound = true\n\t\t\t\tsb.WriteString(\"{SheetIndex: \")\n\t\t\t\tsb.WriteString(strconv.Itoa(sheet.Index))\n\t\t\t\tsb.WriteString(\"} \")\n\t\t\t\tsb.WriteString(sheet.Error.Error())\n\t\t\t}\n\t\t\tsheetName := sheet.Sheet.Name\n\t\t\tsheetsByName[sheetName] = sheet.Sheet\n\t\t\tsheets[sheet.Index] = sheet.Sheet\n\t\t}\n\t}\n\tclose(sheetChan)\n\tif errFound {\n\t\terr = errors.New(sb.String())\n\t}\n\treturn sheetsByName, sheets, err\n}\n\nfunc readSharedStrings(rc io.Reader) (*RefTable, error) {\n\tvar err error\n\tvar decoder *xml.Decoder\n\tvar reftable *RefTable\n\tvar tok xml.Token\n\tvar count int\n\tvar countS string\n\tvar ok bool\n\tvar si *xlsxSI\n\tvar attr *xml.Attr\n\n\twrap := func(err error) (*RefTable, error) {\n\t\treturn nil, fmt.Errorf(\"readSharedStrings: %w\", err)\n\t}\n\n\tdecoder = xml.NewDecoder(rc)\n\n\tfor {\n\t\ttok, err = decoder.Token()\n\t\tif tok == nil {\n\t\t\tbreak\n\t\t} else if err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn wrap(err)\n\t\t}\n\t\tswitch ty := tok.(type) {\n\t\tcase xml.StartElement:\n\t\t\tswitch ty.Name.Local {\n\t\t\tcase \"sst\":\n\t\t\t\tattr = xmlAttrPool.Get().(*xml.Attr)\n\t\t\t\tok = false\n\t\t\t\tfor _, (*attr) = range ty.Attr {\n\t\t\t\t\tif attr.Name.Local == \"count\" {\n\t\t\t\t\t\tcountS = attr.Value\n\t\t\t\t\t\tok = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\txmlAttrPool.Put(attr)\n\t\t\t\tif !ok {\n\t\t\t\t\t// No hints on the size, so we'll just start with\n\t\t\t\t\t// a decent number of entries to avoid small\n\t\t\t\t\t// allocs.\n\t\t\t\t\treftable = NewSharedStringRefTable(DEFAULT_REFTABLE_SIZE)\n\t\t\t\t\treftable.isWrite = false //Todo, do we actually use this?\n\t\t\t\t} else {\n\t\t\t\t\tcount, err = strconv.Atoi(countS)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn wrap(err)\n\t\t\t\t\t}\n\t\t\t\t\treftable = NewSharedStringRefTable(count)\n\t\t\t\t\treftable.isWrite = false //Todo, do we actually use this?\n\t\t\t\t}\n\t\t\tcase \"si\":\n\t\t\t\tif reftable == nil {\n\t\t\t\t\treturn wrap(fmt.Errorf(\"si encountered before reftable created\"))\n\t\t\t\t}\n\t\t\t\tsi = xlsxSIPool.Get().(*xlsxSI)\n\t\t\t\tif err = decoder.DecodeElement(si, &ty); err != nil {\n\t\t\t\t\txlsxSIPool.Put(si)\n\t\t\t\t\treturn wrap(err)\n\t\t\t\t}\n\t\t\t\tif len(si.R) > 0 {\n\t\t\t\t\treftable.AddRichText(xmlToRichText(si.R))\n\t\t\t\t} else {\n\t\t\t\t\treftable.AddString(si.T.getText())\n\t\t\t\t}\n\t\t\t\t// clean up before returning to the pool, without\n\t\t\t\t// these lines you'll see weird effects when reading\n\t\t\t\t// another set of shared strings\n\t\t\t\tsi.R = nil\n\t\t\t\tsi.T = nil\n\t\t\t\txlsxSIPool.Put(si)\n\t\t\tdefault:\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\tdefault:\n\t\t\t// Do nothing\n\t\t}\n\t}\n\n\tif reftable == nil {\n\t\tpanic(\"Unitialised reftable\")\n\t}\n\treturn reftable, nil\n\n}\n\n// readSharedStringsFromZipFile() is an internal helper function to\n// extract a reference table from the sharedStrings.xml file within\n// the XLSX zip file.\nfunc readSharedStringsFromZipFile(f *zip.File) (*RefTable, error) {\n\tvar err error\n\tvar rc io.ReadCloser\n\n\twrap := func(err error) (*RefTable, error) {\n\t\treturn nil, fmt.Errorf(\"readSharedStringsFromZipFile: %w\", err)\n\t}\n\n\t// In a file with no strings it's possible that\n\t// sharedStrings.xml doesn't exist.  In this case the value\n\t// passed as f will be nil.\n\tif f == nil {\n\t\treturn nil, nil\n\t}\n\trc, err = f.Open()\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\tdefer rc.Close()\n\treturn readSharedStrings(rc)\n}\n\n// readStylesFromZipFile() is an internal helper function to\n// extract a style table from the style.xml file within\n// the XLSX zip file.\nfunc readStylesFromZipFile(f *zip.File, theme *theme) (*xlsxStyleSheet, error) {\n\tvar style *xlsxStyleSheet\n\tvar err error\n\tvar rc io.ReadCloser\n\tvar decoder *xml.Decoder\n\n\twrap := func(err error) (*xlsxStyleSheet, error) {\n\t\treturn nil, fmt.Errorf(\"readStylesFromZipFile: %w\", err)\n\t}\n\n\trc, err = f.Open()\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\tdefer rc.Close()\n\n\tstyle = newXlsxStyleSheet(theme)\n\tdecoder = xml.NewDecoder(rc)\n\terr = decoder.Decode(style)\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\tbuildNumFmtRefTable(style)\n\treturn style, nil\n}\n\nfunc buildNumFmtRefTable(style *xlsxStyleSheet) {\n\tif style.NumFmts != nil {\n\t\tfor _, numFmt := range style.NumFmts.NumFmt {\n\t\t\t// We do this for the side effect of populating the NumFmtRefTable.\n\t\t\tstyle.addNumFmt(numFmt)\n\t\t}\n\n\t}\n}\n\nfunc readThemeFromZipFile(f *zip.File) (*theme, error) {\n\twrap := func(err error) (*theme, error) {\n\t\treturn nil, fmt.Errorf(\"readThemeFromZipFile: %w\", err)\n\t}\n\n\trc, err := f.Open()\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\tdefer rc.Close()\n\n\tvar themeXml xlsxTheme\n\terr = xml.NewDecoder(rc).Decode(&themeXml)\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\n\treturn newTheme(themeXml), nil\n}\n\ntype WorkBookRels map[string]string\n\nfunc (w *WorkBookRels) MakeXLSXWorkbookRels() xlsxWorkbookRels {\n\trelCount := len(*w)\n\txWorkbookRels := xlsxWorkbookRels{}\n\txWorkbookRels.Relationships = make([]xlsxWorkbookRelation, relCount+3)\n\tfor k, v := range *w {\n\t\tindex, err := strconv.Atoi(k[3:])\n\t\tif err != nil {\n\t\t\tpanic(err.Error())\n\t\t}\n\t\txWorkbookRels.Relationships[index-1] = xlsxWorkbookRelation{\n\t\t\tId:     k,\n\t\t\tTarget: v,\n\t\t\tType:   \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\"}\n\t}\n\n\trelCount++\n\tsheetId := fmt.Sprintf(\"rId%d\", relCount)\n\txWorkbookRels.Relationships[relCount-1] = xlsxWorkbookRelation{\n\t\tId:     sheetId,\n\t\tTarget: \"sharedStrings.xml\",\n\t\tType:   \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings\"}\n\n\trelCount++\n\tsheetId = fmt.Sprintf(\"rId%d\", relCount)\n\txWorkbookRels.Relationships[relCount-1] = xlsxWorkbookRelation{\n\t\tId:     sheetId,\n\t\tTarget: \"theme/theme1.xml\",\n\t\tType:   \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme\"}\n\n\trelCount++\n\tsheetId = fmt.Sprintf(\"rId%d\", relCount)\n\txWorkbookRels.Relationships[relCount-1] = xlsxWorkbookRelation{\n\t\tId:     sheetId,\n\t\tTarget: \"styles.xml\",\n\t\tType:   \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles\"}\n\n\treturn xWorkbookRels\n}\n\n// readWorkbookRelationsFromZipFile is an internal helper function to\n// extract a map of relationship ID strings to the name of the\n// worksheet.xml file they refer to.  The resulting map can be used to\n// reliably derefence the worksheets in the XLSX file.\nfunc readWorkbookRelationsFromZipFile(workbookRels *zip.File) (WorkBookRels, error) {\n\tvar sheetXMLMap WorkBookRels\n\tvar wbRelationships *xlsxWorkbookRels\n\tvar rc io.ReadCloser\n\tvar decoder *xml.Decoder\n\tvar err error\n\n\twrap := func(err error) (WorkBookRels, error) {\n\t\treturn nil, fmt.Errorf(\"readWorkbookRelationsFromZipFile :%w\", err)\n\t}\n\n\trc, err = workbookRels.Open()\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\tdefer rc.Close()\n\n\tdecoder = xml.NewDecoder(rc)\n\twbRelationships = new(xlsxWorkbookRels)\n\terr = decoder.Decode(wbRelationships)\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\tsheetXMLMap = make(WorkBookRels)\n\tfor _, rel := range wbRelationships.Relationships {\n\t\tif strings.HasSuffix(rel.Target, \".xml\") && rel.Type == \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\" {\n\t\t\t_, filename := path.Split(rel.Target)\n\t\t\tsheetXMLMap[rel.Id] = strings.Replace(filename, \".xml\", \"\", 1)\n\t\t}\n\t}\n\treturn sheetXMLMap, nil\n}\n\n// ReadZip() takes a pointer to a zip.ReadCloser and returns a\n// xlsx.File struct populated with its contents.  In most cases\n// ReadZip is not used directly, but is called internally by OpenFile.\nfunc ReadZip(f *zip.ReadCloser, options ...FileOption) (*File, error) {\n\tdefer f.Close()\n\tfile, err := ReadZipReader(&f.Reader, options...)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"ReadZip: %w\", err)\n\t}\n\treturn file, nil\n}\n\n// ReadZipReader() can be used to read an XLSX in memory without\n// touching the filesystem.\nfunc ReadZipReader(r *zip.Reader, options ...FileOption) (*File, error) {\n\tvar err error\n\tvar file *File\n\tvar reftable *RefTable\n\tvar sharedStrings *zip.File\n\tvar sheetXMLMap map[string]string\n\tvar sheetsByName map[string]*Sheet\n\tvar sheets []*Sheet\n\tvar style *xlsxStyleSheet\n\tvar styles *zip.File\n\tvar themeFile *zip.File\n\tvar v *zip.File\n\tvar workbook *zip.File\n\tvar workbookRels *zip.File\n\tvar worksheets map[string]*zip.File\n\tvar worksheetRels map[string]*zip.File\n\n\twrap := func(err error) (*File, error) {\n\t\treturn nil, fmt.Errorf(\"ReadZipReader: %w\", err)\n\t}\n\n\tfile = NewFile(options...)\n\tworksheets = make(map[string]*zip.File, len(r.File))\n\tworksheetRels = make(map[string]*zip.File, len(r.File))\n\tfor _, v = range r.File {\n\t\t_, name := filepath.Split(v.Name)\n\t\tswitch name {\n\t\tcase `sharedStrings.xml`:\n\t\t\tsharedStrings = v\n\t\tcase `workbook.xml`:\n\t\t\tworkbook = v\n\t\tcase `workbook.xml.rels`:\n\t\t\tworkbookRels = v\n\t\tcase `styles.xml`:\n\t\t\tstyles = v\n\t\tcase `theme1.xml`:\n\t\t\tthemeFile = v\n\t\tdefault:\n\t\t\tif len(v.Name) > 17 {\n\t\t\t\tif v.Name[0:13] == \"xl/worksheets\" || v.Name[0:13] == `xl\\worksheets` {\n\t\t\t\t\tif v.Name[len(v.Name)-5:] == \".rels\" {\n\t\t\t\t\t\tworksheetRels[v.Name[20:len(v.Name)-9]] = v\n\t\t\t\t\t} else {\n\t\t\t\t\t\tworksheets[v.Name[14:len(v.Name)-4]] = v\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif workbookRels == nil {\n\t\treturn wrap(fmt.Errorf(\"workbook.xml.rels not found in input xlsx\"))\n\t}\n\tsheetXMLMap, err = readWorkbookRelationsFromZipFile(workbookRels)\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\tif len(worksheets) == 0 {\n\t\treturn wrap(fmt.Errorf(\"input XLSX contains no worksheets\"))\n\t}\n\tfile.worksheets = worksheets\n\tfile.worksheetRels = worksheetRels\n\treftable, err = readSharedStringsFromZipFile(sharedStrings)\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\tfile.referenceTable = reftable\n\tif themeFile != nil {\n\t\ttheme, err := readThemeFromZipFile(themeFile)\n\t\tif err != nil {\n\t\t\treturn wrap(err)\n\t\t}\n\n\t\tfile.theme = theme\n\t}\n\tif styles != nil {\n\t\tstyle, err = readStylesFromZipFile(styles, file.theme)\n\t\tif err != nil {\n\t\t\treturn wrap(err)\n\t\t}\n\n\t\tfile.styles = style\n\t}\n\tsheetsByName, sheets, err = readSheetsFromZipFile(workbook, file, sheetXMLMap, file.rowLimit, file.colLimit, file.valueOnly)\n\tif err != nil {\n\t\treturn wrap(err)\n\t}\n\tif sheets == nil {\n\t\treaderErr := new(XLSXReaderError)\n\t\treaderErr.Err = \"No sheets found in XLSX File\"\n\t\treturn wrap(readerErr)\n\t}\n\tfile.Sheet = sheetsByName\n\tfile.Sheets = sheets\n\treturn file, nil\n}\n\n// truncateSheetXML will take in a reader to an XML sheet file and will return a reader that will read an equivalent\n// XML sheet file with only the number of rows specified. This greatly speeds up XML unmarshalling when only\n// a few rows need to be read from a large sheet.\n// When sheets are truncated, all formatting present after the sheetData tag will be lost, but all of this formatting\n// is related to printing and visibility, and is out of scope for most purposes of this library.\nfunc truncateSheetXML(r io.Reader, rowLimit int) (io.Reader, error) {\n\tvar rowCount int\n\tvar token xml.Token\n\tvar readErr error\n\n\toutput := new(bytes.Buffer)\n\tr = io.TeeReader(r, output)\n\tdecoder := xml.NewDecoder(r)\n\n\tvar ns string\n\tfor {\n\t\ttoken, readErr = decoder.Token()\n\t\tif readErr == io.EOF {\n\t\t\tbreak\n\t\t} else if readErr != nil {\n\t\t\treturn nil, readErr\n\t\t}\n\t\tif start, ok := token.(xml.StartElement); ok && start.Name.Local == \"worksheet\" && start.Name.Space != \"\" {\n\t\t\tnamespace := start.Name.Space\n\t\t\t// find if the namespace has a short name\n\t\t\tfor _, attr := range start.Attr {\n\t\t\t\tif attr.Name.Space == \"xmlns\" && attr.Value == namespace {\n\t\t\t\t\tns = attr.Name.Local\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tend, ok := token.(xml.EndElement)\n\t\tif ok && end.Name.Local == \"row\" {\n\t\t\trowCount++\n\t\t\tif rowCount >= rowLimit {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\toffset := decoder.InputOffset()\n\toutput.Truncate(int(offset))\n\n\tif readErr != io.EOF {\n\t\tsheetEnding := `</sheetData></worksheet>`\n\t\tif ns != \"\" {\n\t\t\tsheetEnding = fmt.Sprintf(`</%s:sheetData></%s:worksheet>`, ns, ns)\n\t\t}\n\t\t_, err := output.Write([]byte(sheetEnding))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn output, nil\n}\n\n// truncateSheetXMLValueOnly will take in a reader to an XML sheet file and will return a reader that will read an equivalent\n// XML sheet file without null vaules of rows. This greatly speeds up XML unmarshalling when we\n// only need non-NULL data for the sheet.\n// When sheets are truncated, most of formatting present will be not right, but all of this formatting\n// is related to printing and visibility, and is out of scope for most purposes of this library.\nfunc truncateSheetXMLValueOnly(r io.Reader) (io.Reader, error) {\n\tsheetXML, err := io.ReadAll(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trowRegexp, _ := regexp.Compile(`(?s)<row>?.*?</row>`)\n\tcellRegexp, _ := regexp.Compile(`(?s)<c>?.*?/.*?>`)\n\tvalueRegexp, _ := regexp.Compile(`(?s)<v>.*?</v>`)\n\tmergerRegexp, _ := regexp.Compile(`<mergeCell ref=\"[A-Z0-9]+:[A-Z0-9]+\"/>`)\n\tdimensionRegexp, _ := regexp.Compile(`<dimension ref=\"[A-Z]+[0-9]+:[A-Z]+[0-9]+\"/>`)\n\n\t// record merger cell\n\tmergerMap := make(map[string][]byte)\n\tmergerByte := mergerRegexp.FindAll(sheetXML, -1)\n\tfor _, v := range mergerByte {\n\t\tmergerCells := strings.SplitN(strings.SplitN(strings.SplitN(string(v), \"ref=\\\"\", 2)[1], \"\\\"/\", 2)[0], \":\", -1)\n\t\tfor _, v := range mergerCells {\n\t\t\tmergerCellRegexp, err := regexp.Compile(fmt.Sprintf(\"<c r=\\\"%s\\\" .*?/[>|c>]\", v))\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tsheetXML = mergerCellRegexp.ReplaceAllFunc(sheetXML, func(mergeMatch []byte) []byte {\n\t\t\t\tif !valueRegexp.Match(mergeMatch) {\n\t\t\t\t\tid := generator.Hex128()\n\t\t\t\t\tmergerMap[id] = mergerCellRegexp.Find(sheetXML)\n\t\t\t\t\tmergeMatch = mergerCellRegexp.ReplaceAll(mergeMatch, []byte(id))\n\t\t\t\t}\n\t\t\t\treturn mergeMatch\n\t\t\t})\n\t\t}\n\t}\n\n\t// Delete all null value\n\tvar firstCell, lastCell []byte\n\tsheetXML = rowRegexp.ReplaceAllFunc(sheetXML, func(rowMatch []byte) []byte {\n\t\tif !valueRegexp.Match(rowMatch) {\n\t\t\trowMatch = rowRegexp.ReplaceAll(rowMatch, nil)\n\t\t}\n\t\trowMatch = cellRegexp.ReplaceAllFunc(rowMatch, func(cellMatch []byte) []byte {\n\n\t\t\tif !valueRegexp.Match(cellMatch) {\n\t\t\t\tcellMatch = cellRegexp.ReplaceAll(cellMatch, nil)\n\t\t\t} else {\n\t\t\t\tif firstCell == nil {\n\t\t\t\t\tfirstCell = cellMatch\n\t\t\t\t}\n\t\t\t\tlastCell = cellMatch\n\t\t\t}\n\t\t\treturn cellMatch\n\t\t})\n\t\treturn rowMatch\n\t})\n\n\t// restoring mergerMap\n\tfor k, v := range mergerMap {\n\t\tsheetXML = bytes.ReplaceAll(sheetXML, []byte(k), v)\n\t}\n\n\t// replace the dimension\n\tif firstCell != nil && lastCell != nil {\n\t\tfirstCellStr := strings.SplitN(strings.SplitN(string(firstCell), \"r=\\\"\", 2)[1], \"\\\"\", 2)[0]\n\t\tlastCellStr := strings.SplitN(strings.SplitN(string(lastCell), \"r=\\\"\", 2)[1], \"\\\"\", 2)[0]\n\t\tdimension := fmt.Sprintf(\"<dimension ref=\\\"%s:%s\\\"/>\", firstCellStr, lastCellStr)\n\t\tsheetXML = dimensionRegexp.ReplaceAll(sheetXML, []byte(dimension))\n\t}\n\n\toutput := new(bytes.Buffer)\n\t_, err = output.Write(sheetXML)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn output, nil\n}\n"
        },
        {
          "name": "lib_test.go",
          "type": "blob",
          "size": 67.1298828125,
          "content": "package xlsx\n\nimport (\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"math/rand\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\nfunc TestLib(t *testing.T) {\n\tc := qt.New(t)\n\n\tcsRunO(c, \"NovelFileLayout\", func(c *qt.C, option FileOption) {\n\t\tf, err := OpenFile(\"./testdocs/v3.xlsx\", option)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(f.Sheets, qt.HasLen, 5)\n\t\ts4 := f.Sheets[4]\n\t\tc.Assert(s4.MaxRow, qt.Equals, 9)\n\t\tr1, err := s4.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(r1.cellStoreRow.CellCount(), qt.Equals, 5)\n\t\tc1 := r1.GetCell(0)\n\t\tc.Assert(c1.Value, qt.Equals, \"填写前请仔细阅读规则和示例\")\n\t})\n\n\t// Attempting to open a file without workbook.xml.rels returns an error.\n\tcsRunO(c, \"ReadZipReaderWithFileWithNoWorkbookRels\", func(c *qt.C, option FileOption) {\n\t\t_, err := OpenFile(\"./testdocs/badfile_noWorkbookRels.xlsx\", option)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t\tc.Assert(err.Error(), qt.Equals, \"OpenFile: ReadZip: ReadZipReader: workbook.xml.rels not found in input xlsx\")\n\t})\n\n\t// Attempting to open a file with no worksheets returns an error.\n\tcsRunO(c, \"ReadZipReaderWithFileWithNoWorksheets\", func(c *qt.C, option FileOption) {\n\t\t_, err := OpenFile(\"./testdocs/badfile_noWorksheets.xlsx\", option)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t\tc.Assert(err.Error(), qt.Equals, \"OpenFile: ReadZip: ReadZipReader: input XLSX contains no worksheets\")\n\t})\n\n\t// Read a file containing hyperlinks in cells\n\tcsRunO(c, \"ReadFileWithHyperlinks\", func(c *qt.C, option FileOption) {\n\t\tfile, err := OpenFile(\"./testdocs/file_with_hyperlinks.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(file, qt.Not(qt.IsNil))\n\t\tc.Assert(file.Sheets, qt.HasLen, 1)\n\t\tsheet := file.Sheets[0]\n\t\trow, err := sheet.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.GetCell(0).Hyperlink, qt.Equals, Hyperlink{Link: \"https://www.google.com/\"})\n\t\trow, err = sheet.Row(1)\n\t\tc.Assert(err, qt.Equals, nil)\n\n\t\tc.Assert(row.GetCell(0).Hyperlink, qt.Equals, Hyperlink{Link: \"https://docs.microsoft.com/en-us/previous-versions/office/developer/office-2010/cc802445(v%3Doffice.14)\"})\n\n\t})\n\tcsRunO(c, \"ReadFileWithBrokenHyperlinks\", func(c *qt.C, option FileOption) {\n\t\tfile, err := OpenFile(\"./testdocs/file_with_broken_hyperlinks.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(file, qt.Not(qt.IsNil))\n\t\tsheet := file.Sheets[0]\n\t\trow, err := sheet.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.GetCell(0).Hyperlink, qt.Equals, Hyperlink{DisplayString: \"Hyperlink Text\"})\n\t\trow, err = sheet.Row(1)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.GetCell(0).Hyperlink, qt.Equals, Hyperlink{Link: \"https://www.google.com/\"})\n\t})\n\n\t// Attempt to read data from a file with inlined string sheet data.\n\tcsRunO(c, \"ReadWithInlineStrings\", func(c *qt.C, option FileOption) {\n\t\tvar xlsxFile *File\n\t\tvar err error\n\n\t\txlsxFile, err = OpenFile(\"./testdocs/inlineStrings.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet := xlsxFile.Sheets[0]\n\t\tr1, err := sheet.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc1 := r1.GetCell(1)\n\n\t\tval, err := c1.FormattedValue()\n\t\tif err != nil {\n\t\t\tc.Error(err)\n\t\t\treturn\n\t\t}\n\t\tif val == \"\" {\n\t\t\tc.Error(\"Expected a string value\")\n\t\t\treturn\n\t\t}\n\t\tc.Assert(val, qt.Equals, \"HL Retail - North America - Activity by Day - MTD\")\n\t})\n\n\t// which they are contained from the XLSX file, even when the\n\t// worksheet files have arbitrary, non-numeric names.\n\tcsRunO(c, \"ReadWorkbookRelationsFromZipFileWithFunnyNames\", func(c *qt.C, option FileOption) {\n\t\tvar xlsxFile *File\n\t\tvar err error\n\n\t\txlsxFile, err = OpenFile(\"./testdocs/testrels.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tbob := xlsxFile.Sheet[\"Bob\"]\n\t\trow1, err := bob.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tcell1 := row1.GetCell(0)\n\t\tif val, err := cell1.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"I am Bob\")\n\t\t}\n\t})\n\n\t// We can marshal WorkBookRels to an xml file\n\tc.Run(\"WorkBookRelsMarshal\", func(c *qt.C) {\n\t\tvar rels WorkBookRels = make(WorkBookRels)\n\t\trels[\"rId1\"] = \"worksheets/sheet.xml\"\n\t\texpectedXML := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\"><Relationship Id=\"rId1\" Target=\"worksheets/sheet.xml\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\"></Relationship><Relationship Id=\"rId2\" Target=\"sharedStrings.xml\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings\"></Relationship><Relationship Id=\"rId3\" Target=\"theme/theme1.xml\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme\"></Relationship><Relationship Id=\"rId4\" Target=\"styles.xml\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles\"></Relationship></Relationships>`\n\t\txRels := rels.MakeXLSXWorkbookRels()\n\n\t\toutput := bytes.NewBufferString(xml.Header)\n\t\tbody, err := xml.Marshal(xRels)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(body, qt.Not(qt.IsNil))\n\t\t_, err = output.Write(body)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(output.String(), qt.Equals, expectedXML)\n\t})\n\n\tc.Run(\"LettersToNumeric\", func(c *qt.C) {\n\t\tcases := map[string]int{\"A\": 0, \"G\": 6, \"z\": 25, \"AA\": 26, \"Az\": 51,\n\t\t\t\"BA\": 52, \"BZ\": 77, \"ZA\": 26*26 + 0, \"ZZ\": 26*26 + 25,\n\t\t\t\"AAA\": 26*26 + 26 + 0, \"AMI\": 1022}\n\t\tfor input, ans := range cases {\n\t\t\toutput := ColLettersToIndex(input)\n\t\t\tc.Assert(output, qt.Equals, ans)\n\t\t}\n\t})\n\n\tc.Run(\"NumericToLetters\", func(c *qt.C) {\n\t\tcases := map[string]int{\n\t\t\t\"A\":  0,\n\t\t\t\"G\":  6,\n\t\t\t\"Z\":  25,\n\t\t\t\"AA\": 26,\n\t\t\t\"AZ\": 51,\n\t\t\t\"BA\": 52,\n\t\t\t\"BZ\": 77, \"ZA\": 26 * 26, \"ZB\": 26*26 + 1,\n\t\t\t\"ZZ\":  26*26 + 25,\n\t\t\t\"AAA\": 26*26 + 26 + 0, \"AMI\": 1022}\n\t\tfor ans, input := range cases {\n\t\t\toutput := ColIndexToLetters(input)\n\t\t\tc.Assert(output, qt.Equals, ans)\n\t\t}\n\n\t})\n\n\tc.Run(\"LetterOnlyMapFunction\", func(c *qt.C) {\n\t\tvar input string = \"ABC123\"\n\t\tvar output string = strings.Map(letterOnlyMapF, input)\n\t\tc.Assert(output, qt.Equals, \"ABC\")\n\t\tinput = \"abc123\"\n\t\toutput = strings.Map(letterOnlyMapF, input)\n\t\tc.Assert(output, qt.Equals, \"ABC\")\n\t})\n\n\tc.Run(\"IntOnlyMapFunction\", func(c *qt.C) {\n\t\tvar input string = \"ABC123\"\n\t\tvar output string = strings.Map(intOnlyMapF, input)\n\t\tc.Assert(output, qt.Equals, \"123\")\n\t})\n\n\tc.Run(\"GetCoordsFromCellIDString\", func(c *qt.C) {\n\t\tvar cellIDString string = \"A3\"\n\t\tvar x, y int\n\t\tvar err error\n\t\tx, y, err = GetCoordsFromCellIDString(cellIDString)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(x, qt.Equals, 0)\n\t\tc.Assert(y, qt.Equals, 2)\n\t})\n\n\tc.Run(\"GetCellIDStringFromCoords\", func(c *qt.C) {\n\t\tc.Assert(GetCellIDStringFromCoords(0, 0), qt.Equals, \"A1\")\n\t\tc.Assert(GetCellIDStringFromCoords(2, 2), qt.Equals, \"C3\")\n\t})\n\n\tc.Run(\"GetMaxMinFromDimensionRef\", func(c *qt.C) {\n\t\tvar dimensionRef string = \"A1:B2\"\n\t\tvar minx, miny, maxx, maxy int\n\t\tvar err error\n\t\tminx, miny, maxx, maxy, err = getMaxMinFromDimensionRef(dimensionRef)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(minx, qt.Equals, 0)\n\t\tc.Assert(miny, qt.Equals, 0)\n\t\tc.Assert(maxx, qt.Equals, 1)\n\t\tc.Assert(maxy, qt.Equals, 1)\n\t})\n\n\tc.Run(\"CalculateMaxMinFromWorksheet\", func(c *qt.C) {\n\t\tvar sheetxml = bytes.NewBufferString(`\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"\n           xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"\n           xmlns:mx=\"http://schemas.microsoft.com/office/mac/excel/2008/main\"\n           xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n           xmlns:mv=\"urn:schemas-microsoft-com:mac:vml\"\n           xmlns:x14=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/main\"\n           xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\"\n           xmlns:xm=\"http://schemas.microsoft.com/office/excel/2006/main\">\n  <sheetViews>\n    <sheetView workbookViewId=\"0\"/>\n  </sheetViews>\n  <sheetFormatPr customHeight=\"1\" defaultColWidth=\"14.43\" defaultRowHeight=\"15.75\"/>\n  <sheetData>\n    <row r=\"1\">\n      <c t=\"s\" s=\"1\" r=\"A1\">\n        <v>0</v>\n      </c>\n      <c t=\"s\" s=\"1\" r=\"B1\">\n        <v>1</v>\n      </c>\n    </row>\n    <row r=\"2\">\n      <c t=\"s\" s=\"1\" r=\"A2\">\n        <v>2</v>\n      </c>\n      <c t=\"s\" s=\"1\" r=\"B2\">\n        <v>3</v>\n      </c>\n    </row>\n  </sheetData>\n  <drawing r:id=\"rId1\"/>\n</worksheet>`)\n\t\tworksheet := new(xlsxWorksheet)\n\t\terr := xml.NewDecoder(sheetxml).Decode(worksheet)\n\t\tc.Assert(err, qt.IsNil)\n\t\tminx, miny, maxx, maxy, err := calculateMaxMinFromWorksheet(worksheet, NoColLimit)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(minx, qt.Equals, 0)\n\t\tc.Assert(miny, qt.Equals, 0)\n\t\tc.Assert(maxx, qt.Equals, 1)\n\t\tc.Assert(maxy, qt.Equals, 1)\n\t})\n\n\tc.Run(\"GetRangeFromString\", func(c *qt.C) {\n\t\tvar rangeString string\n\t\tvar lower, upper int\n\t\tvar err error\n\t\trangeString = \"1:3\"\n\t\tlower, upper, err = getRangeFromString(rangeString)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(lower, qt.Equals, 1)\n\t\tc.Assert(upper, qt.Equals, 3)\n\t})\n\n\t// csRunC(c, \"MakeRowFromSpan\", func(c *qt.C, constructor CellStoreConstructor) {\n\t// \tvar rangeString string\n\t// \tvar row *Row\n\t// \tvar length int\n\t// \tvar sheet *Sheet\n\t// \tvar err error\n\t// \tsheet, err = NewSheetWithCellStore(\"test\", constructor)\n\t// \tc.Assert(err, qt.IsNil)\n\t// \trangeString = \"1:3\"\n\t// \trow = sheet.cellStore.MakeRowFromSpan(rangeString, sheet)\n\t// \tlength = row.cellStoreRow.CellCount()\n\t// \tc.Assert(length, qt.Equals, 3)\n\t// \tc.Assert(row.Sheet, qt.Equals, sheet)\n\t// \trangeString = \"5:7\" // Note - we ignore lower bound!\n\t// \trow = sheet.cellStore.MakeRowFromSpan(rangeString, sheet)\n\t// \tlength = row.cellStoreRow.CellCount()\n\t// \tc.Assert(length, qt.Equals, 7)\n\t// \tc.Assert(row.Sheet, qt.Equals, sheet)\n\t// \trangeString = \"1:1\"\n\t// \trow = sheet.cellStore.MakeRowFromSpan(rangeString, sheet)\n\t// \tlength = row.cellStoreRow.CellCount()\n\t// \tc.Assert(length, qt.Equals, 1)\n\t// \tc.Assert(row.Sheet, qt.Equals, sheet)\n\t// })\n\n\tcsRunC(c, \"ReadRowsFromSheet\", func(c *qt.C, constructor CellStoreConstructor) {\n\t\tvar err error\n\t\tvar sharedstringsXML = bytes.NewBufferString(`\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"4\" uniqueCount=\"4\">\n  <si>\n    <t>Foo</t>\n  </si>\n  <si>\n    <t>Bar</t>\n  </si>\n  <si>\n    <t xml:space=\"preserve\">Baz </t>\n  </si>\n  <si>\n    <t>Quuk</t>\n  </si>\n</sst>`)\n\t\tvar sheetxml = bytes.NewBufferString(`\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"\n           xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\">\n  <dimension ref=\"A1:B2\"/>\n  <sheetViews>\n    <sheetView tabSelected=\"1\" workbookViewId=\"0\">\n      <selection activeCell=\"C2\" sqref=\"C2\"/>\n\t  <pane ySplit=\"1\" topLeftCell=\"A2\" activePane=\"bottomLeft\" state=\"frozen\"/>\n    </sheetView>\n  </sheetViews>\n  <sheetFormatPr baseColWidth=\"10\" defaultRowHeight=\"15\"/>\n  <sheetData>\n    <row r=\"1\" spans=\"1:2\" ht=\"123.45\" customHeight=\"1\">\n      <c r=\"A1\" t=\"s\">\n        <v>0</v>\n      </c>\n      <c r=\"B1\" t=\"s\">\n        <v>1</v>\n      </c>\n    </row>\n    <row r=\"2\" spans=\"1:2\">\n      <c r=\"A2\" t=\"s\">\n        <v>2</v>\n      </c>\n      <c r=\"B2\" t=\"s\">\n        <v>3</v>\n      </c>\n    </row>\n  </sheetData>\n  <pageMargins left=\"0.7\" right=\"0.7\"\n               top=\"0.78740157499999996\"\n               bottom=\"0.78740157499999996\"\n               header=\"0.3\"\n               footer=\"0.3\"/>\n</worksheet>`)\n\t\tworksheet := new(xlsxWorksheet)\n\t\terr = xml.NewDecoder(sheetxml).Decode(worksheet)\n\t\tc.Assert(err, qt.IsNil)\n\t\tfile := new(File)\n\t\tfile.cellStoreConstructor = constructor\n\t\tfile.referenceTable, err = readSharedStrings(sharedstringsXML)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet, err := NewSheet(\"test\")\n\t\tc.Assert(err, qt.IsNil)\n\t\tlt := make(hyperlinkTable)\n\t\terr = readRowsFromSheet(worksheet, file, sheet, NoRowLimit, NoColLimit, lt)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(sheet.MaxRow, qt.Equals, 2)\n\t\tc.Assert(sheet.MaxCol, qt.Equals, 2)\n\t\trow, err := sheet.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.Sheet, qt.Equals, sheet)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 2)\n\t\tc.Assert(row.GetHeight(), qt.Equals, 123.45)\n\t\tc.Assert(row.isCustom, qt.Equals, true)\n\t\tcell1 := row.GetCell(0)\n\t\tc.Assert(cell1.Value, qt.Equals, \"Foo\")\n\t\tcell2 := row.GetCell(1)\n\t\tc.Assert(cell2.Value, qt.Equals, \"Bar\")\n\t\tcol := sheet.Col(0)\n\t\tc.Assert(col, qt.IsNil)\n\t\tc.Assert(len(worksheet.SheetViews.SheetView), qt.Equals, 1)\n\t\tsheetView := worksheet.SheetViews.SheetView[0]\n\t\tc.Assert(sheetView.Pane, qt.Not(qt.IsNil))\n\t\tpane := sheetView.Pane\n\t\tc.Assert(pane.XSplit, qt.Equals, 0.0)\n\t\tc.Assert(pane.YSplit, qt.Equals, 1.0)\n\t})\n\n\t// An invalid value in the \"r\" attribute in a <row> was causing a panic\n\t// in readRowsFromSheet. This test is a copy of TestReadRowsFromSheet,\n\t// with the important difference of the value 1048576 below in <row r=\"1048576\", which is\n\t// higher than the number of rows in the sheet. That number itself isn't significant;\n\t// it just happens to be the value found to trigger the error in a user's file.\n\tcsRunC(c, \"ReadRowsFromSheetBadR\", func(c *qt.C, constructor CellStoreConstructor) {\n\t\tvar sharedstringsXML = bytes.NewBufferString(`\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"4\" uniqueCount=\"4\">\n  <si>\n    <t>Foo</t>\n  </si>\n  <si>\n    <t>Bar</t>\n  </si>\n  <si>\n    <t xml:space=\"preserve\">Baz </t>\n  </si>\n  <si>\n    <t>Quuk</t>\n  </si>\n</sst>`)\n\t\tvar sheetxml = bytes.NewBufferString(`\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"\n           xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\">\n  <dimension ref=\"A1:B2\"/>\n  <sheetViews>\n    <sheetView tabSelected=\"1\" workbookViewId=\"0\">\n      <selection activeCell=\"C2\" sqref=\"C2\"/>\n\t  <pane ySplit=\"1\" topLeftCell=\"A2\" activePane=\"bottomLeft\" state=\"frozen\"/>\n    </sheetView>\n  </sheetViews>\n  <sheetFormatPr baseColWidth=\"10\" defaultRowHeight=\"15\"/>\n  <sheetData>\n    <row r=\"1\" spans=\"1:2\">\n      <c r=\"A1\" t=\"s\">\n        <v>0</v>\n      </c>\n      <c r=\"B1\" t=\"s\">\n        <v>1</v>\n      </c>\n    </row>\n    <row r=\"1048576\" spans=\"1:2\">\n      <c r=\"A2\" t=\"s\">\n        <v>2</v>\n      </c>\n      <c r=\"B2\" t=\"s\">\n        <v>3</v>\n      </c>\n    </row>\n  </sheetData>\n  <pageMargins left=\"0.7\" right=\"0.7\"\n               top=\"0.78740157499999996\"\n               bottom=\"0.78740157499999996\"\n               header=\"0.3\"\n               footer=\"0.3\"/>\n</worksheet>`)\n\t\tworksheet := new(xlsxWorksheet)\n\t\terr := xml.NewDecoder(sheetxml).Decode(worksheet)\n\t\tc.Assert(err, qt.IsNil)\n\t\tfile := new(File)\n\t\tfile.cellStoreConstructor = constructor\n\t\tfile.referenceTable, err = readSharedStrings(sharedstringsXML)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tsheet, err := NewSheetWithCellStore(\"test\", constructor)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tlt := make(hyperlinkTable)\n\n\t\t// Discarding all return values; this test is a regression for\n\t\t// a panic due to an \"index out of range.\"\n\t\treadRowsFromSheet(worksheet, file, sheet, NoRowLimit, NoColLimit, lt)\n\t})\n\n\tcsRunC(c, \"ReadRowsFromSheetWithLeadingEmptyRows\", func(c *qt.C, constructor CellStoreConstructor) {\n\t\tvar sharedstringsXML = bytes.NewBufferString(`<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"2\" uniqueCount=\"2\"><si><t>ABC</t></si><si><t>DEF</t></si></sst>`)\n\t\tvar sheetxml = bytes.NewBufferString(`<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x14ac\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\">\n  <dimension ref=\"A4:A5\"/>\n  <sheetViews>\n    <sheetView tabSelected=\"1\" workbookViewId=\"0\">\n      <selection activeCell=\"A2\" sqref=\"A2\"/>\n    </sheetView>\n  </sheetViews>\n  <sheetFormatPr baseColWidth=\"10\" defaultRowHeight=\"15\" x14ac:dyDescent=\"0\"/>\n  <sheetData>\n    <row r=\"4\" spans=\"1:1\">\n      <c r=\"A4\" t=\"s\">\n        <v>0</v>\n      </c>\n    </row>\n    <row r=\"5\" spans=\"1:1\">\n      <c r=\"A5\" t=\"s\">\n        <v>1</v>\n      </c>\n    </row>\n  </sheetData>\n  <pageMargins left=\"0.75\" right=\"0.75\" top=\"1\" bottom=\"1\" header=\"0.5\" footer=\"0.5\"/>\n  <pageSetup paperSize=\"9\" orientation=\"portrait\" horizontalDpi=\"4294967292\" verticalDpi=\"4294967292\"/>\n  <extLst>\n    <ext uri=\"{64002731-A6B0-56B0-2670-7721B7C09600}\" xmlns:mx=\"http://schemas.microsoft.com/office/mac/excel/2008/main\">\n      <mx:PLV Mode=\"0\" OnePage=\"0\" WScale=\"0\"/>\n    </ext>\n  </extLst>\n</worksheet>\n`)\n\t\tworksheet := new(xlsxWorksheet)\n\t\terr := xml.NewDecoder(sheetxml).Decode(worksheet)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tfile := new(File)\n\t\tfile.cellStoreConstructor = constructor\n\t\tfile.referenceTable, err = readSharedStrings(sharedstringsXML)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet, err := NewSheetWithCellStore(\"test\", constructor)\n\t\tc.Assert(err, qt.IsNil)\n\t\tlt := make(hyperlinkTable)\n\n\t\terr = readRowsFromSheet(worksheet, file, sheet, NoRowLimit, NoColLimit, lt)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(sheet.MaxRow, qt.Equals, 5)\n\t\tc.Assert(sheet.MaxCol, qt.Equals, 1)\n\n\t\trow, err := sheet.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 0)\n\t\trow, err = sheet.Row(1)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 0)\n\t\trow, err = sheet.Row(2)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 0)\n\t\trow, err = sheet.Row(3)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 1)\n\t\tif val, err := row.GetCell(0).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"ABC\")\n\t\t}\n\n\t\trow, err = sheet.Row(4)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 1)\n\t\tif val, err := row.GetCell(0).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"DEF\")\n\t\t}\n\t})\n\n\tcsRunC(c, \"ReadRowsFromSheetWithLeadingEmptyCols\", func(c *qt.C, constructor CellStoreConstructor) {\n\t\tvar sharedstringsXML = bytes.NewBufferString(`<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"2\" uniqueCount=\"2\"><si><t>ABC</t></si><si><t>DEF</t></si></sst>`)\n\t\tvar sheetxml = bytes.NewBufferString(`<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x14ac\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\">\n  <dimension ref=\"C1:D2\"/>\n  <sheetViews>\n    <sheetView tabSelected=\"1\" workbookViewId=\"0\">\n      <selection activeCell=\"A2\" sqref=\"A2\"/>\n    </sheetView>\n  </sheetViews>\n  <sheetFormatPr baseColWidth=\"10\" defaultRowHeight=\"15\" x14ac:dyDescent=\"0\"/>\n  <cols>\n  \t<col min=\"3\" max=\"3\" width=\"17\" customWidth=\"1\"/>\n  \t<col min=\"4\" max=\"4\" width=\"18\" customWidth=\"1\"/>\n  </cols>\n  <sheetData>\n    <row r=\"1\" spans=\"3:4\">\n      <c r=\"C1\" t=\"s\"><v>0</v></c>\n      <c r=\"D1\" t=\"s\"><v>1</v></c>\n    </row>\n    <row r=\"2\" spans=\"3:4\">\n      <c r=\"C2\" t=\"s\"><v>0</v></c>\n      <c r=\"D2\" t=\"s\"><v>1</v></c>\n    </row>\n  </sheetData>\n  <pageMargins left=\"0.75\" right=\"0.75\" top=\"1\" bottom=\"1\" header=\"0.5\" footer=\"0.5\"/>\n  <pageSetup paperSize=\"9\" orientation=\"portrait\" horizontalDpi=\"4294967292\" verticalDpi=\"4294967292\"/>\n  <extLst>\n    <ext uri=\"{64002731-A6B0-56B0-2670-7721B7C09600}\" xmlns:mx=\"http://schemas.microsoft.com/office/mac/excel/2008/main\">\n      <mx:PLV Mode=\"0\" OnePage=\"0\" WScale=\"0\"/>\n    </ext>\n  </extLst>\n</worksheet>\n`)\n\t\tworksheet := new(xlsxWorksheet)\n\t\terr := xml.NewDecoder(sheetxml).Decode(worksheet)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tfile := new(File)\n\t\tfile.cellStoreConstructor = constructor\n\t\tfile.referenceTable, err = readSharedStrings(sharedstringsXML)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet, err := NewSheetWithCellStore(\"test\", constructor)\n\t\tc.Assert(err, qt.IsNil)\n\t\tlt := make(hyperlinkTable)\n\n\t\terr = readRowsFromSheet(worksheet, file, sheet, NoRowLimit, NoColLimit, lt)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(sheet.MaxRow, qt.Equals, 2)\n\t\tc.Assert(sheet.MaxCol, qt.Equals, 4)\n\n\t\trow, err := sheet.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 4)\n\t\tif val, err := row.GetCell(0).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"\")\n\t\t}\n\t\tif val, err := row.GetCell(1).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"\")\n\t\t}\n\t\tif val, err := row.GetCell(2).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"ABC\")\n\t\t}\n\t\tif val, err := row.GetCell(3).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"DEF\")\n\t\t}\n\t\trow, err = sheet.Row(1)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 4)\n\t\tif val, err := row.GetCell(0).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"\")\n\t\t}\n\t\tif val, err := row.GetCell(1).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"\")\n\t\t}\n\t\tif val, err := row.GetCell(2).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"ABC\")\n\t\t}\n\t\tif val, err := row.GetCell(3).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"DEF\")\n\t\t}\n\n\t\tc.Assert(sheet.MaxCol, qt.Equals, 4)\n\t\tc.Assert(sheet.Col(0), qt.IsNil)\n\t\tc.Assert(sheet.Col(1), qt.IsNil)\n\t\tc.Assert(*sheet.Col(2).Width, qt.Equals, 17.0)\n\t\tc.Assert(*sheet.Col(3).Width, qt.Equals, 18.0)\n\t})\n\n\tcsRunC(c, \"ReadRowsFromSheetWithEmptyCells\", func(c *qt.C, constructor CellStoreConstructor) {\n\t\tvar sharedstringsXML = bytes.NewBufferString(`\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"8\" uniqueCount=\"5\">\n  <si>\n    <t>Bob</t>\n  </si>\n  <si>\n    <t>Alice</t>\n  </si>\n  <si>\n    <t>Sue</t>\n  </si>\n  <si>\n    <t>Yes</t>\n  </si>\n  <si>\n    <t>No</t>\n  </si>\n</sst>\n`)\n\t\tvar sheetxml = bytes.NewBufferString(`\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"><dimension ref=\"A1:C3\"/><sheetViews><sheetView tabSelected=\"1\" workbookViewId=\"0\"><selection activeCell=\"D3\" sqref=\"D3\"/></sheetView></sheetViews><sheetFormatPr baseColWidth=\"10\" defaultRowHeight=\"15\"/>\n<sheetData>\n  <row r=\"1\" spans=\"1:3\">\n    <c r=\"A1\" t=\"s\">\n      <v>\n        0\n      </v>\n    </c>\n    <c r=\"B1\" t=\"s\">\n      <v>\n        1\n      </v>\n    </c>\n    <c r=\"C1\" t=\"s\">\n      <v>\n        2\n      </v>\n    </c>\n  </row>\n  <row r=\"2\" spans=\"1:3\">\n    <c r=\"A2\" t=\"s\">\n      <v>\n        3\n      </v>\n    </c>\n    <c r=\"B2\" t=\"s\">\n      <v>\n        4\n      </v>\n    </c>\n    <c r=\"C2\" t=\"s\">\n      <v>\n        3\n      </v>\n    </c>\n  </row>\n  <row r=\"3\" spans=\"1:3\">\n    <c r=\"A3\" t=\"s\">\n      <v>\n        4\n      </v>\n    </c>\n    <c r=\"C3\" t=\"s\">\n      <v>\n        3\n      </v>\n    </c>\n  </row>\n</sheetData>\n<pageMargins left=\"0.7\" right=\"0.7\" top=\"0.78740157499999996\" bottom=\"0.78740157499999996\" header=\"0.3\" footer=\"0.3\"/>\n</worksheet>\n\n`)\n\t\tworksheet := new(xlsxWorksheet)\n\t\terr := xml.NewDecoder(sheetxml).Decode(worksheet)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tfile := new(File)\n\t\tfile.cellStoreConstructor = constructor\n\t\tfile.referenceTable, err = readSharedStrings(sharedstringsXML)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet, err := NewSheetWithCellStore(\"test\", constructor)\n\t\tc.Assert(err, qt.IsNil)\n\t\tlt := make(hyperlinkTable)\n\n\t\terr = readRowsFromSheet(worksheet, file, sheet, NoRowLimit, NoColLimit, lt)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(sheet.MaxRow, qt.Equals, 3)\n\t\tc.Assert(sheet.MaxCol, qt.Equals, 3)\n\n\t\trow, err := sheet.Row(2)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.Sheet, qt.Equals, sheet)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 3)\n\n\t\tcell1 := row.GetCell(0)\n\t\tc.Assert(cell1.Value, qt.Equals, \"No\")\n\n\t\tcell2 := row.GetCell(1)\n\t\tc.Assert(cell2.Value, qt.Equals, \"\")\n\n\t\tcell3 := row.GetCell(2)\n\t\tc.Assert(cell3.Value, qt.Equals, \"Yes\")\n\n\t\tcol := sheet.Col(0)\n\t\tc.Assert(col, qt.IsNil)\n\t})\n\n\tcsRunC(c, \"ReadRowsFromSheetWithTrailingEmptyCells\", func(c *qt.C, constructor CellStoreConstructor) {\n\t\tvar row *Row\n\t\tvar cell1, cell2, cell3, cell4 *Cell\n\t\tvar sharedstringsXML = bytes.NewBufferString(`\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"4\" uniqueCount=\"4\"><si><t>A</t></si><si><t>B</t></si><si><t>C</t></si><si><t>D</t></si></sst>`)\n\t\tvar sheetxml = bytes.NewBufferString(`\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"><dimension ref=\"A1:D8\"/><sheetViews><sheetView tabSelected=\"1\" workbookViewId=\"0\"><selection activeCell=\"A7\" sqref=\"A7\"/></sheetView></sheetViews><sheetFormatPr baseColWidth=\"10\" defaultRowHeight=\"15\"/><sheetData><row r=\"1\" spans=\"1:4\"><c r=\"A1\" t=\"s\"><v>0</v></c><c r=\"B1\" t=\"s\"><v>1</v></c><c r=\"C1\" t=\"s\"><v>2</v></c><c r=\"D1\" t=\"s\"><v>3</v></c></row><row r=\"2\" spans=\"1:4\"><c r=\"A2\"><v>1</v></c></row><row r=\"3\" spans=\"1:4\"><c r=\"B3\"><v>1</v></c></row><row r=\"4\" spans=\"1:4\"><c r=\"C4\"><v>1</v></c></row><row r=\"5\" spans=\"1:4\"><c r=\"D5\"><v>1</v></c></row><row r=\"6\" spans=\"1:4\"><c r=\"C6\"><v>1</v></c></row><row r=\"7\" spans=\"1:4\"><c r=\"B7\"><v>1</v></c></row><row r=\"8\" spans=\"1:4\"><c r=\"A8\"><v>1</v></c></row></sheetData><pageMargins left=\"0.7\" right=\"0.7\" top=\"0.78740157499999996\" bottom=\"0.78740157499999996\" header=\"0.3\" footer=\"0.3\"/></worksheet>\n`)\n\t\tworksheet := new(xlsxWorksheet)\n\t\terr := xml.NewDecoder(sheetxml).Decode(worksheet)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tfile := new(File)\n\t\tfile.cellStoreConstructor = constructor\n\t\tfile.referenceTable, err = readSharedStrings(sharedstringsXML)\n\t\tc.Assert(err, qt.IsNil)\n\t\tsheet, err := NewSheetWithCellStore(\"test\", constructor)\n\t\tc.Assert(err, qt.IsNil)\n\t\tlt := make(hyperlinkTable)\n\n\t\terr = readRowsFromSheet(worksheet, file, sheet, NoRowLimit, NoColLimit, lt)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(sheet.MaxCol, qt.Equals, 4)\n\t\tc.Assert(sheet.MaxRow, qt.Equals, 8)\n\n\t\trow, err = sheet.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.Sheet, qt.Equals, sheet)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 4)\n\n\t\tcell1 = row.GetCell(0)\n\t\tc.Assert(cell1.Value, qt.Equals, \"A\")\n\n\t\tcell2 = row.GetCell(1)\n\t\tc.Assert(cell2.Value, qt.Equals, \"B\")\n\n\t\tcell3 = row.GetCell(2)\n\t\tc.Assert(cell3.Value, qt.Equals, \"C\")\n\n\t\tcell4 = row.GetCell(3)\n\t\tc.Assert(cell4.Value, qt.Equals, \"D\")\n\n\t\trow, err = sheet.Row(1)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.Sheet, qt.Equals, sheet)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 4)\n\n\t\tcell1 = row.GetCell(0)\n\t\tc.Assert(cell1.Value, qt.Equals, \"1\")\n\n\t\tcell2 = row.GetCell(1)\n\t\tc.Assert(cell2.Value, qt.Equals, \"\")\n\n\t\tcell3 = row.GetCell(2)\n\t\tc.Assert(cell3.Value, qt.Equals, \"\")\n\n\t\tcell4 = row.GetCell(3)\n\t\tc.Assert(cell4.Value, qt.Equals, \"\")\n\t})\n\n\tcsRunC(c, \"ReadRowsFromSheetWithMultipleSpans\", func(c *qt.C, constructor CellStoreConstructor) {\n\t\tvar sharedstringsXML = bytes.NewBufferString(`\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"4\" uniqueCount=\"4\">\n  <si>\n    <t>Foo</t>\n  </si>\n  <si>\n    <t>Bar</t>\n  </si>\n  <si>\n    <t xml:space=\"preserve\">Baz </t>\n  </si>\n  <si>\n    <t>Quuk</t>\n  </si>\n</sst>`)\n\t\tvar sheetxml = bytes.NewBufferString(`\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"\n           xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\">\n  <dimension ref=\"A1:D2\"/>\n  <sheetViews>\n    <sheetView tabSelected=\"1\" workbookViewId=\"0\">\n      <selection activeCell=\"C2\" sqref=\"C2\"/>\n    </sheetView>\n  </sheetViews>\n  <sheetFormatPr baseColWidth=\"10\" defaultRowHeight=\"15\"/>\n  <sheetData>\n    <row r=\"1\" spans=\"1:2 3:4\">\n      <c r=\"A1\" t=\"s\">\n        <v>0</v>\n      </c>\n      <c r=\"B1\" t=\"s\">\n        <v>1</v>\n      </c>\n      <c r=\"C1\" t=\"s\">\n        <v>0</v>\n      </c>\n      <c r=\"D1\" t=\"s\">\n        <v>1</v>\n      </c>\n    </row>\n    <row r=\"2\" spans=\"1:2 3:4\">\n      <c r=\"A2\" t=\"s\">\n        <v>2</v>\n      </c>\n      <c r=\"B2\" t=\"s\">\n        <v>3</v>\n      </c>\n      <c r=\"C2\" t=\"s\">\n        <v>2</v>\n      </c>\n      <c r=\"D2\" t=\"s\">\n        <v>3</v>\n      </c>\n    </row>\n  </sheetData>\n  <pageMargins left=\"0.7\" right=\"0.7\"\n               top=\"0.78740157499999996\"\n               bottom=\"0.78740157499999996\"\n               header=\"0.3\"\n               footer=\"0.3\"/>\n</worksheet>`)\n\t\tworksheet := new(xlsxWorksheet)\n\t\terr := xml.NewDecoder(sheetxml).Decode(worksheet)\n\t\tc.Assert(err, qt.IsNil)\n\t\tfile := new(File)\n\t\tfile.cellStoreConstructor = constructor\n\t\tfile.referenceTable, err = readSharedStrings(sharedstringsXML)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tsheet, err := NewSheetWithCellStore(\"test\", constructor)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tlt := make(hyperlinkTable)\n\n\t\terr = readRowsFromSheet(worksheet, file, sheet, NoRowLimit, NoColLimit, lt)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(sheet.MaxRow, qt.Equals, 2)\n\t\tc.Assert(sheet.MaxCol, qt.Equals, 4)\n\t\trow, err := sheet.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.Sheet, qt.Equals, sheet)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 4)\n\t\tcell1 := row.GetCell(0)\n\t\tc.Assert(cell1.Value, qt.Equals, \"Foo\")\n\t\tcell2 := row.GetCell(1)\n\t\tc.Assert(cell2.Value, qt.Equals, \"Bar\")\n\t\tcell3 := row.GetCell(2)\n\t\tc.Assert(cell3.Value, qt.Equals, \"Foo\")\n\t\tcell4 := row.GetCell(3)\n\t\tc.Assert(cell4.Value, qt.Equals, \"Bar\")\n\n\t})\n\n\tcsRunC(c, \"ReadRowsFromSheetWithMultipleTypes\", func(c *qt.C, constructor CellStoreConstructor) {\n\t\tvar sharedstringsXML = bytes.NewBufferString(`\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"4\" uniqueCount=\"4\">\n  <si>\n    <t>Hello World</t>\n  </si>\n</sst>`)\n\t\tvar sheetxml = bytes.NewBufferString(`\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"\n           xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\">\n  <dimension ref=\"A1:F1\"/>\n  <sheetViews>\n    <sheetView tabSelected=\"1\" workbookViewId=\"0\">\n      <selection activeCell=\"C1\" sqref=\"C1\"/>\n    </sheetView>\n  </sheetViews>\n  <sheetFormatPr baseColWidth=\"10\" defaultRowHeight=\"15\"/>\n  <sheetData>\n    <row r=\"1\" spans=\"1:6\">\n      <c r=\"A1\" t=\"s\">\n        <v>0</v>\n      </c>\n      <c r=\"B1\">\n        <v>12345</v>\n      </c>\n      <c r=\"C1\">\n        <v>1.024</v>\n      </c>\n      <c r=\"D1\" t=\"b\">\n        <v>1</v>\n      </c>\n      <c r=\"E1\">\n      \t<f>10+20</f>\n        <v>30</v>\n      </c>\n      <c r=\"F1\" t=\"e\">\n      \t<f>10/0</f>\n        <v>#DIV/0!</v>\n      </c>\n    </row>\n  </sheetData>\n  <pageMargins left=\"0.7\" right=\"0.7\"\n               top=\"0.78740157499999996\"\n               bottom=\"0.78740157499999996\"\n               header=\"0.3\"\n               footer=\"0.3\"/>\n</worksheet>`)\n\t\tworksheet := new(xlsxWorksheet)\n\t\terr := xml.NewDecoder(sheetxml).Decode(worksheet)\n\t\tc.Assert(err, qt.IsNil)\n\t\tfile := new(File)\n\t\tfile.cellStoreConstructor = constructor\n\t\tfile.referenceTable, err = readSharedStrings(sharedstringsXML)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tsheet, err := NewSheetWithCellStore(\"test\", constructor)\n\t\tc.Assert(err, qt.IsNil)\n\t\tlt := make(hyperlinkTable)\n\n\t\terr = readRowsFromSheet(worksheet, file, sheet, NoRowLimit, NoColLimit, lt)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(sheet.MaxRow, qt.Equals, 1)\n\t\tc.Assert(sheet.MaxCol, qt.Equals, 6)\n\t\trow, err := sheet.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.Sheet, qt.Equals, sheet)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 6)\n\n\t\tcell1 := row.GetCell(0)\n\t\tc.Assert(cell1.Type(), qt.Equals, CellTypeString)\n\t\tif val, err := cell1.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"Hello World\")\n\t\t}\n\n\t\tcell2 := row.GetCell(1)\n\t\tc.Assert(cell2.Type(), qt.Equals, CellTypeNumeric)\n\t\tintValue, _ := cell2.Int()\n\t\tc.Assert(intValue, qt.Equals, 12345)\n\n\t\tcell3 := row.GetCell(2)\n\t\tc.Assert(cell3.Type(), qt.Equals, CellTypeNumeric)\n\t\tfloat, _ := cell3.Float()\n\t\tc.Assert(float, qt.Equals, 1.024)\n\n\t\tcell4 := row.GetCell(3)\n\t\tc.Assert(cell4.Type(), qt.Equals, CellTypeBool)\n\t\tc.Assert(cell4.Bool(), qt.Equals, true)\n\n\t\tcell5 := row.GetCell(4)\n\t\tc.Assert(cell5.Type(), qt.Equals, CellTypeNumeric)\n\t\tc.Assert(cell5.Formula(), qt.Equals, \"10+20\")\n\t\tc.Assert(cell5.Value, qt.Equals, \"30\")\n\n\t\tcell6 := row.GetCell(5)\n\t\tc.Assert(cell6.Type(), qt.Equals, CellTypeError)\n\t\tc.Assert(cell6.Formula(), qt.Equals, \"10/0\")\n\t\tc.Assert(cell6.Value, qt.Equals, \"#DIV/0!\")\n\t})\n\n\tcsRunC(c, \"ReadRowsFromSheetWithHiddenColumn\", func(c *qt.C, constructor CellStoreConstructor) {\n\t\tvar sharedstringsXML = bytes.NewBufferString(`\n\t\t<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n\t\t<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\">\n\t\t    <si><t>This is a test.</t></si>\n\t\t    <si><t>This should be invisible.</t></si>\n\t\t</sst>`)\n\t\tvar sheetxml = bytes.NewBufferString(`\n\t\t<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n\t\t<worksheet xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:mv=\"urn:schemas-microsoft-com:mac:vml\" xmlns:mx=\"http://schemas.microsoft.com/office/mac/excel/2008/main\"\n\t\t    xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:x14=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/main\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\" xmlns:xm=\"http://schemas.microsoft.com/office/excel/2006/main\"\n\t\t    xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\">\n\t\t\t<sheetViews><sheetView workbookViewId=\"0\"/>\n\t\t\t</sheetViews>\n\t\t\t<sheetFormatPr customHeight=\"1\" defaultColWidth=\"14.43\" defaultRowHeight=\"15.75\"/>\n\t\t\t<cols>\n\t\t\t\t<col hidden=\"1\" max=\"2\" min=\"2\"/>\n\t\t\t</cols>\n\t\t    <sheetData>\n\t\t        <row r=\"1\">\n\t\t            <c r=\"A1\" s=\"1\" t=\"s\"><v>0</v></c>\n\t\t            <c r=\"B1\" s=\"1\" t=\"s\"><v>1</v></c>\n\t\t        </row>\n\t\t    </sheetData><drawing r:id=\"rId1\"/></worksheet>`)\n\t\tworksheet := new(xlsxWorksheet)\n\t\terr := xml.NewDecoder(sheetxml).Decode(worksheet)\n\t\tc.Assert(err, qt.IsNil)\n\t\tfile := new(File)\n\t\tfile.cellStoreConstructor = constructor\n\t\tfile.referenceTable, err = readSharedStrings(sharedstringsXML)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tsheet, err := NewSheetWithCellStore(\"test\", constructor)\n\t\tc.Assert(err, qt.IsNil)\n\t\tlt := make(hyperlinkTable)\n\n\t\terr = readRowsFromSheet(worksheet, file, sheet, NoRowLimit, NoColLimit, lt)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(sheet.MaxRow, qt.Equals, 1)\n\t\tc.Assert(sheet.MaxCol, qt.Equals, 2)\n\t\trow, err := sheet.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.Sheet, qt.Equals, sheet)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 2)\n\n\t\tcell1 := row.GetCell(0)\n\t\tc.Assert(cell1.Type(), qt.Equals, CellTypeString)\n\t\tif val, err := cell1.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"This is a test.\")\n\t\t}\n\t\tc.Assert(cell1.Hidden, qt.Equals, false)\n\n\t\tcell2 := row.GetCell(1)\n\t\tc.Assert(cell2.Type(), qt.Equals, CellTypeString)\n\t\tif val, err := cell2.FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"This should be invisible.\")\n\t\t}\n\t\tc.Assert(cell2.Hidden, qt.Equals, true)\n\t})\n\n\t// // When converting the xlsxRow to a Row we create a as many cells as we find.\n\t// csRunC(c, \"ReadRowFromRaw\", func(c *qt.C, constructor CellStoreConstructor) {\n\t// \tvar rawRow xlsxRow\n\t// \tvar cell xlsxC\n\t// \tvar row *Row\n\n\t// \trawRow = xlsxRow{}\n\t// \tcell = xlsxC{R: \"A1\"}\n\t// \tcell = xlsxC{R: \"A2\"}\n\t// \trawRow.C = append(rawRow.C, cell)\n\t// \tsheet, err := NewSheetWithCellStore(\"test\", constructor)\n\t// \tc.Assert(err, qt.IsNil)\n\t// \trow = sheet.cellStore.MakeRowFromRaw(rawRow, sheet)\n\t// \tc.Assert(row, qt.Not(qt.IsNil))\n\t// \tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 1)\n\t// \tc.Assert(row.Sheet, qt.Equals, sheet)\n\t// })\n\n\t// // When a cell claims it is at a position greater than its ordinal\n\t// // position in the file we make up the missing cells.\n\t// csRunC(c, \"ReadRowFromRawWithMissingCells\", func(c *qt.C, constructor CellStoreConstructor) {\n\t// \tvar rawRow xlsxRow\n\t// \tvar cell xlsxC\n\t// \tvar row *Row\n\n\t// \trawRow = xlsxRow{}\n\t// \tcell = xlsxC{R: \"A1\"}\n\t// \trawRow.C = append(rawRow.C, cell)\n\t// \tcell = xlsxC{R: \"E1\"}\n\t// \trawRow.C = append(rawRow.C, cell)\n\t// \tsheet, err := NewSheetWithCellStore(\"test\", constructor)\n\t// \tc.Assert(err, qt.IsNil)\n\t// \trow = sheet.cellStore.MakeRowFromRaw(rawRow, sheet)\n\t// \tc.Assert(row, qt.Not(qt.IsNil))\n\t// \tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 5)\n\t// \tc.Assert(row.Sheet, qt.Equals, sheet)\n\t// })\n\n\t// // We can cope with missing coordinate references\n\t// csRunC(c, \"ReadRowFromRawWithPartialCoordinates\", func(c *qt.C, constructor CellStoreConstructor) {\n\t// \tvar rawRow xlsxRow\n\t// \tvar cell xlsxC\n\t// \tvar row *Row\n\n\t// \trawRow = xlsxRow{}\n\t// \tcell = xlsxC{R: \"A1\"}\n\t// \trawRow.C = append(rawRow.C, cell)\n\t// \tcell = xlsxC{}\n\t// \trawRow.C = append(rawRow.C, cell)\n\t// \tcell = xlsxC{R: \"Z:1\"}\n\t// \trawRow.C = append(rawRow.C, cell)\n\t// \tcell = xlsxC{}\n\t// \trawRow.C = append(rawRow.C, cell)\n\t// \tsheet, err := NewSheetWithCellStore(\"test\", constructor)\n\t// \tc.Assert(err, qt.IsNil)\n\t// \trow = sheet.cellStore.MakeRowFromRaw(rawRow, sheet)\n\t// \tc.Assert(row, qt.Not(qt.IsNil))\n\t// \tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 27)\n\t// \tc.Assert(row.Sheet, qt.Equals, sheet)\n\t// })\n\n\tcsRunC(c, \"SharedFormulas\", func(c *qt.C, constructor CellStoreConstructor) {\n\t\tvar sheetxml = bytes.NewBufferString(`\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"\n           xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\">\n  <dimension ref=\"A1:C2\"/>\n  <sheetViews>\n    <sheetView tabSelected=\"1\" workbookViewId=\"0\">\n      <selection activeCell=\"C1\" sqref=\"C1\"/>\n    </sheetView>\n  </sheetViews>\n  <sheetFormatPr baseColWidth=\"10\" defaultRowHeight=\"15\"/>\n  <sheetData>\n    <row r=\"1\" spans=\"1:3\">\n      <c r=\"A1\">\n        <v>1</v>\n      </c>\n      <c r=\"B1\">\n        <v>2</v>\n      </c>\n      <c r=\"C1\">\n        <v>3</v>\n      </c>\n    </row>\n    <row r=\"2\" spans=\"1:3\">\n      <c r=\"A2\">\n        <v>2</v>\n\t\t<f t=\"shared\" ref=\"A2:C2\" si=\"0\">2*A1</f>\n      </c>\n      <c r=\"B2\">\n        <v>4</v>\n\t\t<f t=\"shared\" si=\"0\"/>\n      </c>\n      <c r=\"C2\">\n        <v>6</v>\n\t\t<f t=\"shared\" si=\"0\"/>\n      </c>\n    </row>\n  </sheetData>\n  <pageMargins left=\"0.7\" right=\"0.7\"\n               top=\"0.78740157499999996\"\n               bottom=\"0.78740157499999996\"\n               header=\"0.3\"\n               footer=\"0.3\"/>\n</worksheet>`)\n\n\t\tworksheet := new(xlsxWorksheet)\n\t\terr := xml.NewDecoder(sheetxml).Decode(worksheet)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tfile := new(File)\n\t\tfile.cellStoreConstructor = constructor\n\t\tsheet, err := NewSheetWithCellStore(\"test\", constructor)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tlt := make(hyperlinkTable)\n\n\t\terr = readRowsFromSheet(worksheet, file, sheet, NoRowLimit, NoColLimit, lt)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(sheet.MaxCol, qt.Equals, 3)\n\t\tc.Assert(sheet.MaxRow, qt.Equals, 2)\n\n\t\trow, err := sheet.Row(1)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.GetCell(1).Formula(), qt.Equals, \"2*B1\")\n\t\tc.Assert(row.GetCell(2).Formula(), qt.Equals, \"2*C1\")\n\t})\n\n\t// Test shared formulas that have absolute references ($) in them\n\tc.Run(\"SharedFormulasWithAbsoluteReferences\", func(c *qt.C) {\n\t\tformulas := []string{\n\t\t\t\"A1\",\n\t\t\t\"$A1\",\n\t\t\t\"A$1\",\n\t\t\t\"$A$1\",\n\t\t\t\"A1+B1\",\n\t\t\t\"$A1+B1\",\n\t\t\t\"$A$1+B1\",\n\t\t\t\"A1+$B1\",\n\t\t\t\"A1+B$1\",\n\t\t\t\"A1+$B$1\",\n\t\t\t\"$A$1+$B$1\",\n\t\t\t`IF(C23>=E$12,\"Q4\",IF(C23>=$D$12,\"Q3\",IF(C23>=C$12,\"Q2\",\"Q1\")))`,\n\t\t\t`SUM(D44:H44)*IM_A_DEFINED_NAME`,\n\t\t\t`IM_A_DEFINED_NAME+SUM(D44:H44)*IM_A_DEFINED_NAME_ALSO`,\n\t\t\t`SUM(D44:H44)*IM_A_DEFINED_NAME+A1`,\n\t\t\t\"AA1\",\n\t\t\t\"$AA1\",\n\t\t\t\"AA$1\",\n\t\t\t\"$AA$1\",\n\t\t}\n\n\t\texpected := []string{\n\t\t\t\"B2\",\n\t\t\t\"$A2\",\n\t\t\t\"B$1\",\n\t\t\t\"$A$1\",\n\t\t\t\"B2+C2\",\n\t\t\t\"$A2+C2\",\n\t\t\t\"$A$1+C2\",\n\t\t\t\"B2+$B2\",\n\t\t\t\"B2+C$1\",\n\t\t\t\"B2+$B$1\",\n\t\t\t\"$A$1+$B$1\",\n\t\t\t`IF(D24>=F$12,\"Q4\",IF(D24>=$D$12,\"Q3\",IF(D24>=D$12,\"Q2\",\"Q1\")))`,\n\t\t\t`SUM(E45:I45)*IM_A_DEFINED_NAME`,\n\t\t\t`IM_A_DEFINED_NAME+SUM(E45:I45)*IM_A_DEFINED_NAME_ALSO`,\n\t\t\t`SUM(E45:I45)*IM_A_DEFINED_NAME+B2`,\n\t\t\t\"AB2\",\n\t\t\t\"$AA2\",\n\t\t\t\"AB$1\",\n\t\t\t\"$AA$1\",\n\t\t}\n\n\t\tanchorCell := \"C4\"\n\n\t\tsharedFormulas := map[int]sharedFormula{}\n\t\tx, y, _ := GetCoordsFromCellIDString(anchorCell)\n\t\tfor i, formula := range formulas {\n\t\t\tres := formula\n\t\t\tsharedFormulas[i] = sharedFormula{x, y, res}\n\t\t}\n\n\t\tfor i, formula := range formulas {\n\t\t\ttestCell := xlsxC{\n\t\t\t\tR: \"D5\",\n\t\t\t\tF: &xlsxF{\n\t\t\t\t\tContent: formula,\n\t\t\t\t\tT:       \"shared\",\n\t\t\t\t\tSi:      i,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tc.Assert(formulaForCell(testCell, sharedFormulas), qt.Equals, expected[i])\n\t\t}\n\t})\n\n\t// Avoid panic when cell.F.T is \"e\" (for error)\n\tc.Run(\"FormulaForCellPanic\", func(c *qt.C) {\n\t\tcell := xlsxC{R: \"A1\"}\n\t\t// This line would panic before the fix.\n\t\tsharedFormulas := make(map[int]sharedFormula)\n\n\t\t// Not really an important test; getting here without a\n\t\t// panic is the real win.\n\t\tc.Assert(formulaForCell(cell, sharedFormulas), qt.Equals, \"\")\n\t})\n\n\tcsRunC(c, \"RowNotOverwrittenWhenFollowedByEmptyRow\", func(c *qt.C, constructor CellStoreConstructor) {\n\t\tsheetXML := bytes.NewBufferString(`\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:mv=\"urn:schemas-microsoft-com:mac:vml\" xmlns:mx=\"http://schemas.microsoft.com/office/mac/excel/2008/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:x14=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/main\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\" xmlns:xm=\"http://schemas.microsoft.com/office/excel/2006/main\">\n\t\t<sheetViews>\n\t\t\t<sheetView workbookViewId=\"0\" />\n\t\t</sheetViews>\n\t\t<sheetFormatPr customHeight=\"1\" defaultColWidth=\"14.43\" defaultRowHeight=\"15.75\" />\n\t\t<sheetData>\n\t\t\t<row r=\"2\">\n\t\t\t\t<c r=\"A2\" t=\"str\">\n\t\t\t\t\t<f t=\"shared\" ref=\"A2\" si=\"1\">RANDBETWEEN(1,100)</f>\n\t\t\t\t\t<v>66</v>\n\t\t\t\t</c>\n\t\t\t</row>\n\t\t\t<row r=\"3\">\n\t\t\t\t<c r=\"A3\" t=\"str\">\n\t\t\t\t\t<f t=\"shared\" ref=\"A3\" si=\"2\">RANDBETWEEN(1,100)</f>\n\t\t\t\t\t<v>30</v>\n\t\t\t\t</c>\n\t\t\t</row>\n\t\t\t<row r=\"4\">\n\t\t\t\t<c r=\"A4\" t=\"str\">\n\t\t\t\t\t<f t=\"shared\" ref=\"A4\" si=\"3\">RANDBETWEEN(1,100)</f>\n\t\t\t\t\t<v>75</v>\n\t\t\t\t</c>\n\t\t\t</row>\n\t\t\t<row r=\"7\">\n\t\t\t\t<c r=\"A7\" s=\"1\" t=\"str\">\n\t\t\t\t\t<f t=\"shared\" ref=\"A7\" si=\"4\">A4/A2</f>\n\t\t\t\t\t<v>1.14</v>\n\t\t\t\t</c>\n\t\t\t</row>\n\t\t</sheetData>\n\t\t<drawing r:id=\"rId1\" />\n\t</worksheet>\n\t`)\n\n\t\tsharedstringsXML := bytes.NewBufferString(`<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"/>`)\n\n\t\tworksheet := new(xlsxWorksheet)\n\t\terr := xml.NewDecoder(sheetXML).Decode(worksheet)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tfile := new(File)\n\t\tfile.cellStoreConstructor = constructor\n\t\tfile.referenceTable, err = readSharedStrings(sharedstringsXML)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tsheet, err := NewSheetWithCellStore(\"test\", constructor)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tlt := make(hyperlinkTable)\n\n\t\terr = readRowsFromSheet(worksheet, file, sheet, NoRowLimit, NoColLimit, lt)\n\t\tc.Assert(err, qt.IsNil)\n\t\trow, err := sheet.Row(3)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 1)\n\t\tc.Assert(row.GetCell(0).Value, qt.Equals, \"75\")\n\t})\n\n\t// This was a specific issue raised by a user.\n\tcsRunO(c, \"RoundTripFileWithNoSheetCols\", func(c *qt.C, option FileOption) {\n\t\toriginalXlFile, err := OpenFile(\"testdocs/original.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tdestFile := \"testdocs/\" + strconv.Itoa(rand.Int()) + \".xlsx\"\n\t\terr = originalXlFile.Save(destFile)\n\t\tc.Assert(err, qt.IsNil)\n\t\t_, err = OpenFile(destFile)\n\t\tc.Assert(err, qt.IsNil)\n\t\terr = os.Remove(destFile)\n\t\tc.Assert(err, qt.IsNil)\n\t})\n\n\tcsRunO(c, \"ReadRestEmptyRowsFromSheet\", func(c *qt.C, option FileOption) {\n\t\toriginalXlFile, err := OpenFile(\"testdocs/empty_rows_in_the_rest.xlsx\", option)\n\t\tc.Assert(err, qt.IsNil)\n\t\tfor _, sheet := range originalXlFile.Sheets {\n\t\t\tsheet.ForEachRow(func(row *Row) error {\n\t\t\t\tif row == nil {\n\t\t\t\t\tc.Errorf(\"Row should not be nil\")\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\t\t}\n\t})\n\n}\n\nfunc TestReadRowsFromSheet(t *testing.T) {\n\tc := qt.New(t)\n\tcsRunC(c, \"WithMergeCells\", func(c *qt.C, constructor CellStoreConstructor) {\n\t\tvar sharedstringsXML = bytes.NewBufferString(`\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"3\" uniqueCount=\"3\">\n  <si>\n    <t>Value A</t>\n  </si>\n  <si>\n    <t>Value B</t>\n  </si>\n  <si>\n    <t>Value C</t>\n  </si>\n</sst>\n`)\n\t\tvar sheetxml = bytes.NewBufferString(`\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mx=\"http://schemas.microsoft.com/office/mac/excel/2008/main\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:mv=\"urn:schemas-microsoft-com:mac:vml\" xmlns:x14=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/main\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\" xmlns:xm=\"http://schemas.microsoft.com/office/excel/2006/main\">\n  <sheetViews>\n    <sheetView workbookViewId=\"0\"/>\n  </sheetViews>\n  <sheetFormatPr customHeight=\"1\" defaultColWidth=\"17.29\" defaultRowHeight=\"15.0\"/>\n  <cols>\n    <col customWidth=\"1\" min=\"1\" max=\"6\" width=\"14.43\"/>\n  </cols>\n  <sheetData>\n    <row r=\"1\" ht=\"15.75\" customHeight=\"1\">\n      <c r=\"A1\" s=\"1\" t=\"s\">\n        <v>0</v>\n      </c>\n    </row>\n    <row r=\"2\" ht=\"15.75\" customHeight=\"1\">\n      <c r=\"A2\" s=\"1\" t=\"s\">\n        <v>1</v>\n      </c>\n      <c r=\"B2\" s=\"1\" t=\"s\">\n        <v>2</v>\n      </c>\n    </row>\n  </sheetData>\n  <mergeCells count=\"1\">\n    <mergeCell ref=\"A1:B1\"/>\n  </mergeCells>\n  <drawing r:id=\"rId1\"/>\n</worksheet>`)\n\t\tworksheet := new(xlsxWorksheet)\n\t\terr := xml.NewDecoder(sheetxml).Decode(worksheet)\n\t\tc.Assert(err, qt.IsNil)\n\t\tfile := new(File)\n\t\tfile.cellStoreConstructor = constructor\n\t\tfile.referenceTable, err = readSharedStrings(sharedstringsXML)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tworksheet.mapMergeCells()\n\t\tsheet, err := NewSheetWithCellStore(\"test\", constructor)\n\t\tc.Assert(err, qt.IsNil)\n\t\tlt := make(hyperlinkTable)\n\t\terr = readRowsFromSheet(worksheet, file, sheet, NoRowLimit, NoColLimit, lt)\n\t\tc.Assert(err, qt.IsNil)\n\t\trow, err := sheet.Row(0)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tcell1 := row.GetCell(0)\n\t\tc.Assert(cell1.HMerge, qt.Equals, 1)\n\t\tc.Assert(cell1.VMerge, qt.Equals, 0)\n\t})\n}\n\n// See issue #362\n// An XSLX file with an invalid sheet name (xl/worksheets.xml) caused an exception\nfunc TestFuzzCrashers(t *testing.T) {\n\tvar crashers = []string{\n\t\t\"PK\\x03\\x04\\x14\\x00\\x00\\b\\b\\x00D\\xae\\fC\\xf4\\xeb\\xcaY=\\x01\" +\n\t\t\t\"\\x00\\x00g\\x05\\x00\\x00\\x13\\x00\\x00\\x00[Content_T\" +\n\t\t\t\"ypes].xml͔\\xd1K\\xc30\\x10\\xc6\\xdf\\xf7W\" +\n\t\t\t\"\\x94\\xbcJ\\x9bm\\x82\\x88\\xb4ۃ\\xe0\\xa3\\x0e\\x9c\\xcf\\x12\\x93\\xdb\\x1a\\xda\" +\n\t\t\t\"&\\xe1.\\xce\\xed\\xbf\\xf7R7A\\x11\\\\q\\xa8/\\r%\\xf7}\\xbf\" +\n\t\t\t\"\\xef\\x8ek\\xcb\\xf9\\xb6k\\xb3\\r Y\\xef*1)\\xc6\\\"\\x03\\xa7\\xbd\" +\n\t\t\t\"\\xb1n]\\x89\\x87\\xe5M~)\\xe6\\xb3Q\\xb9\\xdc\\x05\\xa0\\x8ck\\x1dU\" +\n\t\t\t\"\\xa2\\x8e1\\\\II\\xba\\x86NQ\\xe1\\x038\\xbeYy\\xecT\\xe4W\" +\n\t\t\t\"\\\\ˠt\\xa3\\xd6 \\xa7\\xe3\\xf1\\x85\\xd4\\xdeEp1\\x8f\\xc9C\\xcc\" +\n\t\t\t\"\\xca;ơ5\\x90-\\x14\\xc6[\\xd5A%\\xe4#BK\\xb2HO\" +\n\t\t\t\"\\x91]\\xbf\\t\\x12\\xb3\\x12*\\x84\\xd6j\\x159\\x9f\\xdc8\\xf3\\x89\\x96\\xef\" +\n\t\t\t\"II\\xd9\\xd7Pm\\x03\\x9dq\\x81\\x90_\\x93\\x8c\\xd7\\v\\xf4\\x81$\\x1b\" +\n\t\t\t\"\\x17\\xa9n\\x10ίVV\\x03{<w,)`\\xcbJ\\x03&\\x0f\" +\n\t\t\t\"l\\t\\x18-\\x1c\\xc7\\xd6\\x1ea8\\xfc\\xd0kR\\x1fIܶ\\xfb\\xd1\" +\n\t\t\t\"\\xbexl\\x9e\\xbco\\x12\\xf57\\xc6\\xcc`\\xaa\\x15\\x82\\xb9\\x8fȻD\" +\n\t\t\t\"?\\x1e5\\x05\\x04e\\xa8\\x06\\x88\\xdc\\xc1\\a\\xefor\\xa4\\xd6{\\x1d\\xc9\" +\n\t\t\t\"\\xfe8?q\\x96w\\xff\\x819\\xa6\\xff$\\xc7\\xe4\\x8frPܵp\" +\n\t\t\t\"\\xf2\\xc5\\xe8M\\x8f\\x98\\xc0\\xe1c8\\xe9R\\xf2Ytʺ=\\u007fT\" +\n\t\t\t\"\\xca\\xfe\\xc79{\\x05PK\\x03\\x04\\x14\\x00\\x00\\b\\b\\x00D\\xae\\fC\" +\n\t\t\t\"f\\xaa\\x82\\xb7\\xe0\\x00\\x00\\x00;\\x02\\x00\\x00\\v\\x00\\x00\\x00_rel\" +\n\t\t\t\"s/.rels\\xad\\x92\\xcfJ\\x031\\x10\\x87\\xef}\\x8a\\x90{\" +\n\t\t\t\"w\\xb6\\x15Dd\\xb3\\xbd\\x88ЛH}\\x80\\x98\\xcc\\xfea7\\x990\" +\n\t\t\t\"\\x19u}{\\x83\\bZ\\xa9\\xa5\\a\\x8fI~\\xf3\\xcd7C\\x9a\\xdd\\x12\" +\n\t\t\t\"f\\xf5\\x8a\\x9cG\\x8aFo\\xaaZ+\\x8c\\x8e\\xfc\\x18{\\xa3\\x9f\\x0e\\xf7\" +\n\t\t\t\"\\xeb\\x1b\\xbdkW\\xcd#\\xceVJ$\\x0fcʪ\\xd4\\xc4l\\xf4 \" +\n\t\t\t\"\\x92n\\x01\\xb2\\x1b0\\xd8\\\\Q\\xc2X^:\\xe2`\\xa5\\x1c\\xb9\\x87d\" +\n\t\t\t\"\\xddd{\\x84m]_\\x03\\xffd\\xe8\\xf6\\x88\\xa9\\xf6\\xdeh\\xde\\xfb\\x8d\" +\n\t\t\t\"V\\x87\\xf7\\x84\\x97\\xb0\\xa9\\xebF\\x87w\\xe4^\\x02F9\\xd1\\xe2W\\xa2\" +\n\t\t\t\"\\x90-\\xf7(F/3\\xbc\\x11O\\xcfDSU\\xa0\\x1aN\\xbbl/\" +\n\t\t\t\"w\\xf9{N\\b(\\xd6[\\xb1\\xe0\\x88q\\x9d\\xb8T\\xb3\\x8c\\x98\\xbfu\" +\n\t\t\t\"<\\xb9\\x87r\\x9d?\\x13焮\\xfes9\\xb8\\bF\\x8f\\xfe\\xbc\\x92\" +\n\t\t\t\"M\\xe9\\xcbh\\xd5\\xc0\\xd1'h?\\x00PK\\x03\\x04\\x14\\x00\\x00\\b\\b\" +\n\t\t\t\"\\x00D\\xae\\fC\\x17ϯ\\xa7\\xbc\\x00\\x00\\x005\\x01\\x00\\x00\\x10\\x00\\x00\" +\n\t\t\t\"\\x00docProps/app.xml\\x9d\\x8f\\xb1\" +\n\t\t\t\"j\\x031\\x10\\x05{\\u007f\\x85Po\\xeb\\xe2\\xc2\\x04\\xa3\\x93\\t$\\xee\\x02\" +\n\t\t\t\"..酴g\\v\\xa4]\\xa1ݘ\\xf3\\xdfG!\\x10\\xa7v9\" +\n\t\t\t\"\\f\\f\\xef\\xd9\\xc3R\\xb2\\xbaB\\xe3D8\\xea\\xa7͠\\x15`\\xa0\\x98\" +\n\t\t\t\"\\xf0<\\xea\\x8f\\xe9\\xb8~֊\\xc5c\\xf4\\x99\\x10F}\\x03\\xd6\\a\\xb7\" +\n\t\t\t\"\\xb2\\xa7F\\x15\\x9a$`\\xd5\\vȣ\\xbe\\x88Խ1\\x1c.P<\" +\n\t\t\t\"o\\xba\\xc6nfj\\xc5K\\xc7v64\\xcf)\\xc0+\\x85\\xaf\\x02(\" +\n\t\t\t\"f;\\f;\\x03\\x8b\\x00F\\x88\\xeb\\xfa\\x17Կ\\xc5\\xfdU\\x1e\\x8dF\" +\n\t\t\t\"\\n?\\xfb\\xf8s\\xba\\xd5\\xdesv\\\"\\xf1yJ\\x05\\xdc`\\xcd\\x1d\\xec\" +\n\t\t\t\"K\\xad9\\x05/\\xfd\\xbc{O\\xa1\\x11\\xd3,\\xeam\\t\\x90\\xad\\xf9/\" +\n\t\t\t\"\\xad\\xb9\\x1fv\\xdfPK\\x03\\x04\\x14\\x00\\x00\\b\\b\\x00D\\xae\\fC\\x17\" +\n\t\t\t\"qy\\xdb:\\x01\\x00\\x00x\\x02\\x00\\x00\\x11\\x00\\x00\\x00docPr\" +\n\t\t\t\"ops/core.xml\\x8d\\x92_O\\xc3 \\x14\\xc5\" +\n\t\t\t\"\\xdf\\xfd\\x14\\r\\xef-\\xa5]\\x96\\x85\\xb4]\\xa2f\\xbe\\xb8\\xc4\\xc4\\x1a\\x8d\" +\n\t\t\t\"o\\x04\\xee:b\\xa1\\x04pݾ\\xbdm\\xb7\\xe1\\xd4=\\xf8ƽ\\xe7\" +\n\t\t\t\"\\xdc\\x1f\\x87?\\xc5r\\xaf\\xdah\\a\\xd6\\xc9N\\x97\\x88$)\\x8a@\\xf3\" +\n\t\t\t\"NHݔ\\xe8\\xa5^\\xc5\\v\\x149ϴ`m\\xa7\\xa1D\\ap\" +\n\t\t\t\"hY\\xdd\\x14\\xdcP\\xdeYx\\xb2\\x9d\\x01\\xeb%\\xb8h\\x00iG\\xb9\" +\n\t\t\t\")\\xd1\\xd6{C1v|\\v\\x8a\\xb9dp\\xe8A\\xdctV1?\" +\n\t\t\t\"\\x94\\xb6\\xc1\\x86\\xf1\\x0f\\xd6\\x00\\xce\\xd2t\\x8e\\x15x&\\x98gx\\x04\\xc6\" +\n\t\t\t\"&\\x10\\xd1\\t)x@\\x9aO\\xdbN\\x00\\xc11\\xb4\\xa0@{\\x87I\" +\n\t\t\t\"B\\xf0\\xb7WI\\u007f0pu\\xe2,^\\xb8=X定'%\" +\n\t\t\t\"8\\xf7N\\x06W\\xdf\\xf7I\\x9fO\\xbe!?\\xc1o\\xeb\\xc7\\xe7\\xe9\\xa8\" +\n\t\t\t\"\\xb1\\xd4\\xe3Uq@UqBSn\\x81y\\x10\\xd1\\x00\\xa0\\xc7`g\" +\n\t\t\t\"\\xe55\\xbf\\xbb\\xafW\\xa8\\xcaRB\\xe2t\\x1eg\\x8b\\x9a\\xcc(\\xc9i\" +\n\t\t\t\"\\x9a\\xbf\\x17\\xf8\\xd7\\xfc\\b<\\xae;[\\xd5\\xc0Zx\\x18=\\xa15\\xbe\" +\n\t\t\t\"G˜_\\x0f/\\xb7\\x91 n\\x0f\\xc1\\xf5W\\t\\xe1ԩ\\xf7\\xff\" +\n\t\t\t\"t3\\x9ag\\x17\\xe9\\u0380i\\u007f\\v;9~\\xa3*\\x9d6\\r\\xe5\" +\n\t\t\t\"T\\xfd\\xfc,\\xd5\\x17PK\\x03\\x04\\x14\\x00\\x00\\b\\b\\x00D\\xae\\fC\" +\n\t\t\t\"(\\xba\\xe5Ҧ\\x00\\x00\\x00\\xec\\x00\\x00\\x00\\x14\\x00\\x00\\x00xl/s\" +\n\t\t\t\"haredStrings.xmle\\xce\\xc1\\x8a\" +\n\t\t\t\"\\xc20\\x10\\xc6\\xf1\\xbbO\\x11\\xe6\\xbeMw\\x11\\x11IRX\\xa1\\xf7\\x85\" +\n\t\t\t\"\\xf5\\x01B;\\xda`3\\xa9\\x99\\xc9\\xe2\\xfa\\xf4V\\x04\\x05=\\xfe\\u007f\\x03\" +\n\t\t\t\"\\x1fc\\x9as\\x1c\\xd5\\x1ff\\x0e\\x89,|V5(\\xa4.\\xf5\\x81\\x0e\" +\n\t\t\t\"\\x16v\\xbf\\xed\\xc7\\x1a\\x14\\x8b\\xa7ޏ\\x89\\xd0\\xc2?24na\\x98\" +\n\t\t\t\"Eu\\xa9\\x90XX\\x82*\\x14N\\x05\\xb7\\x8f\\x9eG\\x89-\\f\\\"\\xd3\" +\n\t\t\t\"Fk\\xee\\x06\\x8c\\x9e\\xab4!͗}\\xca\\xd1˜\\xf9\\xa0y\\xca\" +\n\t\t\t\"\\xe8{\\x1e\\x10%\\x8e\\xfa\\xab\\xaeW:\\xfa@\\xe0\\f\\agĵ)\" +\n\t\t\t\"\\x19-\\xce\\xe8[\\xde\\xe9\\xdb\\xe7w\\xba\\xbc\\xd2O)ǧ\\xe9\\xf9]\" +\n\t\t\t\"w\\x05PK\\x03\\x04\\x14\\x00\\x00\\b\\b\\x00\\xcf,\\rC\\x0ep\\x99\\x04\" +\n\t\t\t\"\\f\\x04\\x00\\x00\\x96\\x1f\\x00\\x00\\r\\x00\\x1c\\x00xl/style\" +\n\t\t\t\"s.xmlUT\\t\\x00\\x035\\xaa\\tR5\\xaa\\tRux\" +\n\t\t\t\"\\v\\x00\\x01\\x04\\xe8\\x03\\x00\\x00\\x04\\xe8\\x03\\x00\\x00\\xedYQo\\xdb*\\x14\" +\n\t\t\t\"~\\xef\\xaf@~\\xbf\\xb3\\x13\\xa7^|\\x95tjs\\x97\\xabI\\xd3T\" +\n\t\t\t\"m\\x9dt\\xa5\\xab\\xfb@ll\\xa3a\\xb00ْ\\xfd\\xfa\\x81\\xb1\\xb1\" +\n\t\t\t\"\\x9d6\\x90\\xaa/ծ\\x1dU\\x82\\xc3\\xc7\\xc7\\xc7\\xe1p\\\\\\xf0\\xea\\xdd\" +\n\t\t\t\"\\xa1$\\xe0;\\xe25ft\\xed\\xcd\\xde\\x04\\x1e@4a)\\xa6\\xf9\\xda\" +\n\t\t\t\"\\xfb\\xfa\\xb0\\xfdc\\xe9\\x81Z@\\x9aB\\xc2(Z{GT{\\xefn\" +\n\t\t\t\"\\xaeV\\xb58\\x12\\xf4\\xa5@H\\x00\\xc9@\\xeb\\xb5W\\bQ\\xfd\\xe9\\xfb\" +\n\t\t\t\"uR\\xa0\\x12\\xd6oX\\x85\\xa8l\\xc9\\x18/\\xa1\\x90U\\x9e\\xfbu\\xc5\" +\n\t\t\t\"\\x11Lkթ$\\xfe<\\b\\\"\\xbf\\x84\\x98z7W\\x00\\xac\\xe8\\xbe\" +\n\t\t\t\"ܖ\\xa2\\x06\\t\\xdbS!\\x954Vc\\a\\x9ag\\xc3R\\xa9\\xe1\\xef\" +\n\t\t\t\"\\xf7\\x9f\\xde\\u007f\\xbe\\xfd\\xe8\\x01\\xdd\\xf6!\\x95\\xf0h\\xe1\\xf9\\r\\x8f\\xdf\\x12\" +\n\t\t\t\"5\\x95\\x8cўr\\xd1Q*\\xab.\\xcaJ\\xfd\\x13|\\x87D2\\xcc\" +\n\t\t\t\"4AcL\\x18a\\x1c\\xf0|\\xb7\\xf6\\xb6۠y\\x06\\xad\\x14\\x96H\" +\n\t\t\t\"w\\xda@\\x82w\\x1c\\x0f\\xda2Xbrԭ\\xf3!c\\x01y-\" +\n\t\t\t\"\\x9d\\xa5\\xc7\\xea\\x1aV~\\xaf匬\\xa7\\a\\xbe\\xe5\\x18\\x923\\xc3\\x06\" +\n\t\t\t\"\\xbf\\x17\\xbb.\\xb5\\xeb\\x89\\t1\\xeb\\x19\\x9a\\xf5\\x94V\\xc3VA!\\x10\" +\n\t\t\t\"\\xa7[i\\x03m\\xf9\\xe1Xɨ\\xa12~\\a\\xec\\xa6υ\\xdds\" +\n\t\t\t\"\\x0e\\x8f\\xb3\\xf9\\xf5\\v\\x18jFp\\xeau8\\xd5-ߌ\\xe3\\xecn\" +\n\t\t\t\"\\xb9\\xdd\\xf6\\x8e\\x91\\x88\\xdd\\x18\\x11\\x86\\x1b\\xf9\\f\\\\\\xe7\\x0f\\x06;ե\" +\n\t\t\t\"K\\xdao;\\xc6S\\xb9\\xc7;\\xcf\\xcd;\\xcfi;H1\\xcc\\x19\\x85\" +\n\t\t\t\"\\xe4/\\xf6C&\\x81\\f\\x92\\x1ay\\xc6\\xf8\\xb5\\xeaLfX\\x822\\xd1\" +\n\t\t\t\"\\x8b\\xe08/\\x06U\\xc1\\xaa\\xbe\\xb2cB\\xb0\\xb2\\xafw\\xa4ƋZ\" +\n\t\t\t\"\\xc1\\xcb\\xe5\\x80&!\\xad=QȄr\\xa2\\xedL\\x9b\\x14z\\xa6E\" +\n\t\t\t\"\\xab>\\xd3h\\x99BW\\xd6NO\\x10!_\\x14\\xc5?Y\\xef\\xf9\\xa0\" +\n\t\t\t\"s\\xfd!\\x03\\xb0\\xaa\\xc8\\xf1\\x96\\xe0\\x9c\\x96H5\\n\\xbe\\x97\\x13m\\xac\" +\n\t\t\t\"w\\r\\xcfȴe'\\x98{\\xce\\x04JD\\x93\\xb8\\xb5Y\\x8f\\xae\\xf2\" +\n\t\t\t\"\\xa1L\\xe3j\\xf5\\xbb\\xa2\\xec\\xda\\x16\\xc7)\\xd3L\\nv*@\\xc18\" +\n\t\t\t\"\\xfe)\\xf1j7\\xe6\\x88\\\".\\xf7*\\xc04m\\x14J\\x82\\xba\\xe0\\x98\" +\n\t\t\t\"~{`[,\\xcc\\xda\\bt\\x10\\x9f\\x99\\x80Z\\x8b\\x04\\xc9\\x17\\x8a\\xc0\" +\n\t\t\t\"\\x89\\xa2Ю\\xf4\\xc0\\x0f\\x0e\\xab\\a\\t\\xeb\\xfa\\xf4\\xfe\\xac\\xcc4@\\x81\" +\n\t\t\t\"S9\\x8e\\xa1%,\\xf9\\x86\\xd2vr\\xc6݇\\xec\\xbc\\aێ#\" +\n\t\t\t\"\\x17\\x0emV\\x1f\\xb6@\\x97\\x13gC'\\x9a\\xe5\\x9cd=-k>\" +\n\t\t\t\"\\xc9z\\x86\\xac`\\x925ɚdM\\xb2&Y\\xbf\\xb1\\xacѫz\" +\n\t\t\t\"\\x11\\xbeR]\\xb3W\\xaak\\xf1Ju\\xcd_\\xa7\\xae\\xf8D\\xd6\\xca\\x1f\" +\n\t\t\t\"\\x9eK\\xccAepF\\t-G\\x94\\xcb\\xe4\\x0f-/ݶ\\xea\\x98\" +\n\t\t\t\"\\x02\\x0e\\xd9p\\aO\\xe7\\x15\\xa77\\xe7\\x937\\x9fw\\x80~\\xe4\\xcc\\xd9\" +\n\t\t\t\"\\xff&4uF\\x18&\\x83&;\\x98|\\x10u\\xf9\\xc04\\x81\\xdd\\x1e\" +\n\t\t\t\"\\x13\\x81i\\xeb\\x91d_Kaw\\xdaf\\x86T\\x17~k\\uf4fa\" +\n\t\t\t\"\\xb7%\\xbd\\x9b|\\x1bWh\\xe7ڰ\\xb2\\x84\\x1d\\xd5\\xec\\xda\\xce\\x15]\" +\n\t\t\t\"\\xc0\\x05\\xfe\\r\\xfe3|\\x91\\x9do\\xe1\\xe0\\xdbs\\x8ehr4to\" +\n\t\t\t\"\\xedto/\\xa3\\x1b)\\\\\\xda)\\xaf\\xed\\x94\\xf7\\x88'2\\xf2\\f[\" +\n\t\t\t\"\\xdc]\\x98\\xf7+\\xae\\x03@\\xdd8\\xd6\\xed@*Z\\x0f(\\xdd\\fl\" +\n\t\t\t\"\\xeaV-\\xdfm\\xac7\\xe4\\xa7\\x00\\xfdX\\x01\\x0e\\x86 P\\u007fV\\x80\" +\n\t\t\t\"\\x82848D:\\x18T\\xb3\\x15\\xb0t\\xf9!\\b\\x96.\\x80\\x82X\" +\n\t\t\t\"\\x87p0,]\\f\\xaa\\xd9\\n\\xd8\\x04\\xea\\xe7\\xd0`e\\x88\\xe5cu\" +\n\t\t\t\"T\\x1c\\x87a\\x149\\x16kt\\xd3\\xfdH\\xe4Ʊ\\x16Q\\x14\\x04\\x8e\" +\n\t\t\t\"!\\x1c\\xb3P\\xfd\\x1d\\x1a\\x94\\x8a\\x97\\xac\\xa63\\xe4\\x9cA{QL:\" +\n\t\t\t\"\\\"ꂠu8ʹq\\xc6_6\\x9e\\xbf\\x9a\\n`]\\v\\xf5\" +\n\t\t\t\"ı5\\xe4\\x1c\\x8b\\xa5!V\\r\\x8e\\xa8\\xd6\\x10\\v@\\x05\\xbd\\x95\\xe1\" +\n\t\t\t\"\\xd1\\a\\x9e\\xa7f\\xe1HbN@\\x1c;\\x00j\\xebXwV\\x14\\xd9\" +\n\t\t\t\"]\\x1d\\xa9\\x9f5\\x1e\\x1c\\xdb?\\f\\xe3\\xd8\\nP\\fV\\x91a\\xe8\\x00\" +\n\t\t\t\"\\xa8\\x14\\xe4\\x048D*\\x99\\x0e@\\x18\\xf6\\xffn=z\\x99\\xcawo\" +\n\t\t\t\"[^\\xf9\\xfd\\a\\xf5\\x9b\\xab_PK\\x03\\x04\\x14\\x00\\x00\\b\\b\\x00\\xe0\" +\n\t\t\t\"\\x15\\xf7D\\b\\xc40\\xf9\\xbe\\x01\\x00\\x00}\\x03\\x00\\x00\\x0f\\x00\\x1c\\x00x\" +\n\t\t\t\"l/workbook.xmlUT\\t\\x00\\x03\\x03\" +\n\t\t\t\"\\x06\\xcfS\\x03\\x06\\xcfSux\\v\\x00\\x01\\x04\\xe8\\x03\\x00\\x00\\x04\\xe8\\x03\" +\n\t\t\t\"\\x00\\x00\\x8dRMO\\xdb@\\x10\\xbd\\xe7W\\xac\\xf6N\\xfc\\x91\\x88\\x86\\xc8\" +\n\t\t\t\"\\x0e\\xaa@\\b\\x0e\\x94\\xaaP8\\x8f\\xd7\\xe3x\\x9b\\xf5\\xae\\xb5;I\\xa0\" +\n\t\t\t\"\\xbf\\xbec;.)\\xaa\\\"n;_o\\xdf{3\\xd9\\xe5kc\\xc4\" +\n\t\t\t\"\\x0e}\\xd0\\xce\\xe62\\x99\\xc6R\\xa0U\\xae\\xd4v\\x9d˟O7g\" +\n\t\t\t\"\\v)\\x02\\x81-\\xc18\\x8b\\xb9|\\xc3 /W\\x93l\\xef\\xfc\\xa6p\" +\n\t\t\t\"n#xކ\\\\\\xd6D\\xed2\\x8a\\x82\\xaa\\xb1\\x810u-Z\\xae\" +\n\t\t\t\"T\\xce7@\\x1c\\xfau\\x14Z\\x8fP\\x86\\x1a\\x91\\x1a\\x13\\xa5q|\\x1e\" +\n\t\t\t\"5\\xa0\\xad\\x1c\\x10\\x96\\xfe3\\x18\\xae\\xaa\\xb4\\xc2k\\xa7\\xb6\\rZ\\x1a@\" +\n\t\t\t\"<\\x1a f\\x1fj\\xdd\\x06\\xb9\\x9a\\b\\x91U\\xda\\xe0\\xf3\\xa0I@\\xdb\" +\n\t\t\t\"~\\x83\\x86\\x99_\\x81Q2\\xea\\xeb#\\xf9\\xef^\\x14\\xa06\\xdb\\xf6\\x86\" +\n\t\t\t\"\\arY\\x81\\t\\xc8rk\\xb7\\u007f(~\\xa1\\\"\\xd6\\x05\\xc6HQ\\x02\" +\n\t\t\t\"ar\\x11\\xcfǖ\\x8f(\\x8e\\xb8\\x99?\\x1b\\xf2]\\xeeY\\xe3>t\" +\n\t\t\t\"\\xd1Q_\\x97\\x13\\xc0\\x8d;|\\x82\\\"\\x97lu\\xa5}\\xa0\\xc7Β\" +\n\t\t\t\">\\xec~\\xbeu^\\xffv\\x96\\xc0<*\\xef\\x8c\\xc9%\\xf9\\xed\\x81U\" +\n\t\t\t\"\\xdfɳ\\xe18\\xc9BI\\xab\\x8f\\xed\\x04ŏΖ\\\\ο\\xf0\" +\n\t\t\t\"\\n\\xf7ږ\\x8c\\x8dz]\\xf3W\\x8b\\xe4\\\"\\x1ds/\\xba\\xa4\\x9a7\" +\n\t\t\t\"\\u007f>[\\xccy\\x17/}\\xb2g\\xf3\\xf6\\xfe\\x1e\\x84E\\xff(\\xcb\\xfa\" +\n\t\t\t\"U\\x8e\\\"\\xfb@\\xd8\\xdeif\\x88\\xc6`\\xd2\\xf1\\xe3\\xec]\\xc9\\xf0\\xfd\" +\n\t\t\t\"\\x15\\x11\\x17w:\\xe8\\xc20C\\xbf\\xd4\\\\\\xf0we:\\xc0\\xff\\x1f$\" +\n\t\t\t\"=\\x02IO\\x80\\xccN\\x81̎@f'@\\xe6\\xa3\\xd0wi\\x19\" +\n\t\t\t\";\\xab\\xf8N4\\xa1\\xe7\\xa9+\\xb7\\xb5l`\\x12\\xb3?\\x1e\\xab{W\" +\n\t\t\t\"2\\xd0WVw\\xa8\\xff=\\xa2C|\\x8d\\x86\\x80\\x1d\\x9c\\xc6q\\x9ct\" +\n\t\t\t\"\\xe8Y4\\x9e\\xc3j\\xf2\\aPK\\x03\\x04\\x14\\x00\\x00\\b\\b\\x00\\xb2\\x04\" +\n\t\t\t\"4C\\xa0J\\x80\\x9e\\x84\\x03\\x00\\x00\\x8f\\b\\x00\\x00\\x18\\x00\\x1c\\x00xl\" +\n\t\t\t\"/worksheets/sheet1.x\" +\n\t\t\t\"mlUT\\t\\x00\\x03\\xb0|;R\\xb0|;Rux\\v\\x00\\x01\" +\n\t\t\t\"\\x04\\xe8\\x03\\x00\\x00\\x04\\xe8\\x03\\x00\\x00\\xc5V\\xc1r\\xdb6\\x10\\xbd\\xfb+\" +\n\t\t\t\"0\\xb8W\\x94\\x14+V<\\x923\\x89]5\\x9dq\\\"O\\xe543\" +\n\t\t\t\"\\xbdA\\xc4R\\xc4\\x18\\x04X\\x00\\x94b\\u007f}w\\x01\\x92\\xa2\\x155\\xd3\" +\n\t\t\t\"[u\\x11\\xb1\\x8bžݷx\\xe4\\xe2\\xfd\\xf7J\\xb3=8\\xaf\\xac\" +\n\t\t\t\"Y\\xf2\\xc9h\\xcc\\x19\\x98\\xdcJevK\\xfe\\xf5q\\xf5˜3\\x1f\" +\n\t\t\t\"\\x84\\x91B[\\x03K\\xfe\\f\\x9e\\xbf\\xbf\\xb9X\\x1c\\xac{\\xf2%@`\" +\n\t\t\t\"x\\x80\\xf1K^\\x86P_g\\x99\\xcfK\\xa8\\x84\\x1f\\xd9\\x1a\\fz\\n\" +\n\t\t\t\"\\xeb*\\x11p\\xe9v\\x99\\xaf\\x1d\\b\\x19\\x83*\\x9dM\\xc7\\xe3\\xb7Y%\" +\n\t\t\t\"\\x94\\xe1\\xe9\\x84k\\xf7_ΰE\\xa1r\\xb8\\xb3yS\\x81\\t\\xe9\\x10\" +\n\t\t\t\"\\aZ\\x04\\x84\\xefKU{~s\\xc1\\xd8\\\"&yp\\xacP:\\x80\" +\n\t\t\t\"\\xfbl%\\\"/\\x84\\xf6\\x10ݸ\\xa1\\x16;\\xd8@\\xf8Z\\xc7M\\xe1\" +\n\t\t\t\"\\xd1>\\xa0\\xa1ۓ\\xc53\\xb2\\xf6\\x90\\xb8\\x90\\n\\xf3Q\\x8f\\x98\\x83b\" +\n\t\t\t\"\\xc9?L\\xae?N\\xdb}q۟\\n\\x0e\\xbe=\\xbb7\\xb0\\xdcj\" +\n\t\t\t\"\\xeb~\\x97K\\xfe\\xf6\\x923\\t\\x85ht\\xf8\\xcd)yK\\xf6%\\x0f\" +\n\t\t\t\"\\xae\\x01Μڕ\\b\\xe0\\x1e\\x8a\\xd0\\x01`\\xbe\\xb4\\x87\\x15\\x96\\xddh\" +\n\t\t\t\"\\xe1_\\x19)\\xfa^\\x19\\xf0]4\\x19\\xd7M\\xd0h\\xdb<W[\\xab\" +\n\t\t\t\"_y\\xfe\\xb0\\a\\xcc\\xf5\\tێ\\f\\x0f\\x1d\\u007f\\x81\\xb3\\xbd!\\x88\\xed\" +\n\t\t\t\"\\x064\\xe4\\x01do\\xb25\\x01\\xba\\x05\\xad\\xa9Z\\xce\\xf6Xϒ\\x1b\" +\n\t\t\t\"\\xa2BsvPF\\xdaÃ\\xb3\\x01\\xa3\\xe2\\xe4\\xb4\\x18i,\\xb6\\xd6\" +\n\t\t\t\">Q\\xf9T8\\x8eӋ\\xb5\\xd5&\\x17\\x1a\\xdb;\\x19\\x0f\\xd7_\\xe2\" +\n\t\t\t\"a\\xa7V\\\"\\xe2^<\\xdb&\\xb60ySc\\xa9\\xb5\\x11&\\xd1 \" +\n\t\t\t\"\\xf0o\\x0f\\t\\x1fR1X\\xb7ikA\\xe3\\xdaցE\\xff\\x1d\\x89\" +\n\t\t\t\"\\xebX\\xeb\\xf9\\xa5$\\x03\\xba{\\x1e\\x13\\x8b\\xab8z8#-y\\xd8\" +\n\t\t\t\"\\xcfO@|!\\xae\\x19\\x1f\\xc4u\\x1b\\xa3\\ti\\xeff\\x01\\x1fi\\n\" +\n\t\t\t\"\\xb4\\xa8=5\\xb7\\xedR\\xa9\\xa4\\x84c\\xd3*\\xf1\\x9d\\xea\\x9c\\xce\\xf0Q\" +\n\t\t\t\"\\xd1-\\xa4+\\xf7L\\r\\x1bS\\xabe(\\xc9=\\x9a]]\\xce\\xdf\\xcd\" +\n\t\t\t\"\\xaf\\xe6\\xb3\\xcb\\xe9l\\xd2\\ri\\x97+\\xe1\\xbd\\x13A\\xb4\\x99\\x9d=\\x9c\" +\n\t\t\t\"ɜ7>\\xd8*\\xa1=1v\\x85\\x9d\\xc7\\x18K\\xbe\\x1c\\xbd\\xe3\\xcc\" +\n\t\t\t\"\\xa6i\\xbb\\x87=\\xe8\\x88\\xd0\\x11➢\\x9c\\xd641>\\x16\\x82a\" +\n\t\t\t\"\\xbew\\xa2{\\u007f3^d\\xfb~w\\x96\\xbf\\x0e\\xfc\\x98\\x02\\xc7\\xe7\\x02\" +\n\t\t\t\"'\\xe7\\x02\\x17\\x19\\x16\\xfa\\u007f\\x94<=-y\\xfa\\xefȧ?-9\" +\n\t\t\t\"\\x05N\\xcf\\x05\\xbe\\xf9i\\xc9\\xed\\xecu\\xa4/j\\xa7LX\\xd7Q\\v\" +\n\t\t\t\"Y\\x89\\x97\\x1eE\\xfc(\\x1f\\xbb\\xa3t\\x9cZP\\t\\xbb\\x8b_Z\\xa7\" +\n\t\t\t\"^\\xac\\tBߢ\\xc0\\x82\\x1b4\\x12\\xdf\\x12A\\xe5?:\\xd2$\\x92\" +\n\t\t\t\"\\xa2~\\x16n\\xa70\\xb7\\x8eZ6\\x1e]\\xb5\\xea\\xd6>\\xe3e\\x8cO\" +\n\t\t\t\"\\xf3+\\x9c\\xf4\\xad\\r\\xc8\\xc0q]F\\x91\\xa2\\xf5l2\\x99\\x8fg\\xfd\" +\n\t\t\t\"\\x8f\\xb3¢Μu\\x1dSc\\tMͶZ\\xe4O\\x1f\\x8c\\xfc\" +\n\t\t\t\"V\\xaa\\x00G\\xb2Q\\x15nmEo\\fO\\x1af\\xc8fk\\x05i\" +\n\t\t\t\"D\\xa5\\x13\\x03\\xe9-\\x94\\xf3\\x81D\\xe8KSmcV\\x9e\\xde\\x10\\xfd\" +\n\t\t\t\"\\xc5o\\xd7\\xdfڋ9\\xec\\xd9]\\xad\\x96\\xfc\\r\\xe9\\x19\\x9a0\\x9dH\" +\n\t\t\t\"\\xe2X[\\x17\\x9cP\\x81Ti\\ak\\x17\\vE\\x015\\x8f%\\x985\" +\n\t\t\t\"\\xf6\\x95\\x1c5\\xb8\\x8dzA\\xd48p~\\xa0\\x97\\x8d\\x87\\xd5)\\xa6\\x16\" +\n\t\t\t\"+\\xba\\x1e\\x88spwI\\x9f\\xfc\\x0fd\\xf5\\x88R\\xabR\\x97W\\xb1\" +\n\t\t\t\"\\xa1L\\xaa\\xa2@\\\"M\\x88\\xe7\\xf7\\xa1\\xbdy-\\xe5\\xaf\\xfb\\xe3\\x85h\" +\n\t\t\t\"\\xa7\\xcfJ\\x99^(\\xdd4\\x9e\\x1ap\\x9d\\x12\\f6\\x1c\\r\\x8bl\\x88\" +\n\t\t\t\"\\x01\\xbf$\\xb2\\xfeS\\xe2\\xe6\\xe2\\x1fPK\\x03\\x04\\x14\\x00\\x00\\b\\b\\x00\" +\n\t\t\t\"\\xb3\\x044C\\xccJ\\xae2\\x0e\\x03\\x00\\x00\\x99\\x06\\x00\\x00\\x18\\x00\\x1c\\x00\" +\n\t\t\t\"xl/worksheets/sheet2\" +\n\t\t\t\".xmlUT\\t\\x00\\x03\\xb1|;R\\xb1|;Rux\\v\" +\n\t\t\t\"\\x00\\x01\\x04\\xe8\\x03\\x00\\x00\\x04\\xe8\\x03\\x00\\x00\\x8dUMO\\x1b1\\x10\\xbd\" +\n\t\t\t\"\\xf3+,\\xdf\\xcb&\\x94@@,\\bAS*\\x01A\\r\\x14\\xa97\" +\n\t\t\t\"g=\\x9b\\xb5\\xf0z\\xb6\\xb6\\x97\\x00\\xbf\\xbec\\xef'\\xd0Cs\\x89=\" +\n\t\t\t\"c\\xcf\\xc7{o\\xbc'g/\\xa5f\\xcf`\\x9dB\\x93\\xf2\\xe9\\xee\\x84\" +\n\t\t\t\"30\\x19Je6)\\u007f\\xb8_|\\x99s\\xe6\\xbc0Rh4\\x90\" +\n\t\t\t\"\\xf2Wp\\xfc\\xect\\xe7d\\x8b\\xf6\\xc9\\x15\\x00\\x9eQ\\x00\\xe3R^x\" +\n\t\t\t\"_\\x1d'\\x89\\xcb\\n(\\x85\\xdb\\xc5\\n\\fyr\\xb4\\xa5\\U00034d5b\" +\n\t\t\t\"\\xc4U\\x16\\x84\\x8c\\x97J\\x9d\\xecM&\\aI)\\x94\\xe1M\\x84c\\xfb\" +\n\t\t\t\"?10\\xcfU\\x06\\x97\\x98\\xd5%\\x18\\xdf\\x04\\xb1\\xa0\\x85\\xa7\\xf2]\\xa1\" +\n\t\t\t\"*\\xc7Ow\\x18;\\x89I\\xee,˕\\xf6`oPR\\xe5\\xb9\\xd0\" +\n\t\t\t\"\\x0e\\xa2\\x9b\\x0eTb\\x03+\\xf0\\x0fU<\\xe4\\xef\\xf1\\x8e\\fݙ$\" +\n\t\t\t\"\\xc6H\\xda q#\\x15\\xe5\\v\\x181\\vy\\xcaϧ\\xed\\xa1x\\xe6\" +\n\t\t\t\"\\x97\\x82\\xadk\\x03\\xf7\\x06\\x96\\xa1F\\xfbC\\xa6\\xfc`\\x9f3\\t\\xb9\\xa8\" +\n\t\t\t\"\\xb5\\xffn\\x95\\xbc\\b\\xf6\\x94{[\\x03gVm\\n\\xca~\\r\\xb9\\xef\" +\n\t\t\t\"\\xb23W\\xe0vA=\\xd7Z\\xb8w\\xc6p\\xfbZ\\x19p\\xdd\\xed`\" +\n\t\t\t\"\\\\\\xd6^\\x93m\\xf5Z\\xaeQ\\xbf\\xf3\\xfc\\xc4-\\xe5\\xba\\\"̉\\xde\" +\n\t\t\t\"\\xb1\\xe37X\\xec\\r^\\xacW\\xa0!\\xf3 \\xfbd\\x1e\\xabP\\xd1\\x05\" +\n\t\t\t\"h\\x1d{e\\xcf\\xd4P\\xcaM Bs\\xb6UF\\xe2\\xf6\\u03a2\\xa7\" +\n\t\t\t\"kQ7\\xed\\xbd \\x8a5\\xe2S\\xe8?tNbzC,W\\x99\" +\n\t\t\t\"\\xd0\\x04\\xeet2\\xde\\xdf\\xc6`\\x1f\\xad\\x81\\x86k\\xf1\\x8auİ\\xf1\" +\n\t\t\t\"6\\xc8\\x06lc\\x9d\\x81\\x04A\\u007f\\xcf0\\xd47\\xec۴\\x95\\bb\" +\n\t\t\t\"m\\xfb\\xa0\\xae\\xff\\xbc\\xa3\\xadg7$\\x19\\x91\\xdd\\x13\\xd9и\\x88\\xc2\" +\n\t\t\t\"#\\x85\\xb4\\xec\\x11\\xa0W\\x10\\b\\xa3\\xbaf|t\\xaf;\\x18M\\xc4{\" +\n\t\t\t\"'\\x06Z\\x06\\x19hQ\\xb9\\x11\\xba\\x85\\x92\\x12\\x06\\xd0J\\xf1\\x12\\xfa\\xdc\" +\n\t\t\t\"\\x9b\\xd1R\\x85\\x19\\f\\x03\\xf7\\x1a\\x00\\x9b\\x04\\xa8\\xa5/\\x82{wv\\xb8\" +\n\t\t\t\"??\\x9a\\x1f\\xceg\\xfb{\\xb3N}I\\x97\\xab\\xa9\\xf7Rx\\xd18\" +\n\t\t\t\"*\\xab\\x8c_Vq*XA\\n\\xa0q\\x1e\\xb4\\xb4\\x19t\\xf4\\xd1B\" +\n\t\t\t\"3\\xd1\\t\\xa3@\\xab\\xde\\xd0x\\xa1/h\\xd4\\xc0\\x8e:\\xa0\\xf7«\" +\n\t\t\t\"쳣MN\\x1c\\xde\\b\\xbbQ\\x94[GaOv\\x0f[\\xa9\\xb7\" +\n\t\t\t\"k\\\"&\\xae\\xe6\\x87\\xd4\\xf5\\x1a\\xbd\\xc7r\\xd8\\x17Q\\xb1a?\\x9bN\" +\n\t\t\t\"\\xe7\\x93Y\\xff\\xe3,G\\xd2\\xdc?]Cjj\\xa1\\xae\\xd8Z\\x8b\\xec\" +\n\t\t\t\"\\xe9\\xdc\\xc8\\xc7B\\xf9~\\xb0YF\\n\\xb9\\xc02\\xbc\\x1d.\\xe8\\xd9\\x04\" +\n\t\t\t\"\\x1bV*@A\\xb8K+Fs\\x98+\\xeb|\\x10\\xe4m]\\xaec\" +\n\t\t\t\"V\\u07bc\\x15\\xbd\\b\\xda\\xfdcK\\xd2\\x18\\xb3\\xcbJ\\xa5\\xfck\\xd06\" +\n\t\t\t\"\\x99(\\x9dh\\x06\\xa5B\\xeb\\xadP>(t\\x03K\\x1b\\x1b\\xa5a2\" +\n\t\t\t\"\\xf7\\x05\\x98%\\xe1\\x1a\\x1c\\x15ؕz\\xa3\\xaa\\x8fH\\n\\xa3٩\\x1d\" +\n\t\t\t\",>\\xd6\\xd4\\xd6J\\xae\\xbb\\xc09\\xd8\\xcbF\\xab\\xee\\x13Y}E\\r\" +\n\t\t\t\"T\\rʋ\\b(\\x93*ωH\\xe3c\\xfc\\xfejo^J\\xf9\" +\n\t\t\t\"\\xedy\\xd0l+o\\x94\\xb2y]\\xba\\x99\\xfah\\xa0}\\x93`t`\" +\n\t\t\t\"0\\x9c$\\xe3\\x1a蛒\\xf4\\x1f\\x95ӝ\\xbfPK\\x03\\x04\\x14\\x00\" +\n\t\t\t\"\\x00\\b\\b\\x00D\\xae\\fC\\xb6w\\xb3\\xfa\\xf6\\x02\\x00\\x00;\\x06\\x00\\x00\" +\n\t\t\t\"\\x18\\x00\\x00\\x00xl/worksheets/sh\" +\n\t\t\t\"eet3.xml\\x8dTMS\\xdb0\\x10\\xbd\\xf7Wht\" +\n\t\t\t\"o\\x9cP\\x02\\x81\\x89\\xc30\\xa4)\\x9d\\xa1\\x84i\\xa0\\xcc\\xf4\\xa6X\\xeb\" +\n\t\t\t\"X\\x83\\xacu%\\x99\\x10~}W\\xb2\\xe3\\x18\\xe8\\xa19\\x90\\xd5.\\xfb\" +\n\t\t\t\"\\xf5\\xde\\xdbL/^J͞\\xc1:\\x85&\\xe5\\xa3\\xc1\\x9030\\x19\" +\n\t\t\t\"Je6)\\u007f\\xb8_|\\x9ep\\xe6\\xbc0Rh4\\x90\\xf2\\x1d8\" +\n\t\t\t\"~1\\xfb4ݢ}r\\x05\\x80gT\\xc0\\xb8\\x94\\x17\\xdeW\\xe7I\" +\n\t\t\t\"\\xe2\\xb2\\x02J\\xe1\\x06X\\x81\\xa1H\\x8e\\xb6\\x14\\x9e\\x9ev\\x93\\xb8ʂ\" +\n\t\t\t\"\\x901\\xa9\\xd4\\xc9\\xd1px\\x92\\x94B\\x19\\xdeT8\\xb7\\xffS\\x03\\xf3\" +\n\t\t\t\"\\\\e0Ǭ.\\xc1\\xf8\\xa6\\x88\\x05-<\\x8d\\xef\\nU9>\\x9b\" +\n\t\t\t\"\\xc6\\x0ew\\x96\\xe5J{\\xb0?P\\xd2ع\\xd0\\x0e(V\\x89\\r\\xac\" +\n\t\t\t\"\\xc0?T1\\xee\\xef\\xf1\\x8e\\x1c\\xfbp2\\x9b&m\\xf2l*\\x15u\" +\n\t\t\t\"\\b\\xa80\\vy\\xca/G!\\x1c\\xa3\\xbf\\x14l]\\xcff\\x19j\\xb4\" +\n\t\t\t\"\\xdfe\\xcaO\\x8e9\\x93\\x90\\x8bZ\\xfboVɫ\\xe0O\\xb9\\xb75\" +\n\t\t\t\"pfզ\\xa0~7\\x90\\xfb}?\\xe6\\n\\xdc.h\\xbbZ\\v\\xf7\" +\n\t\t\t\"\\xc6\\x19\\xb2o\\x94\\x01\\xb7\\xcf\\x0e\\xcee\\xed5\\xf9V\\xbbr\\x8d\\xfaM\" +\n\t\t\t\"\\xe4'n\\xa9\\xd75\\xa1KD\\xf6\\x03\\xbf\\xc1b\\xe7\\xf0b\\xbd\\x02\\r\" +\n\t\t\t\"\\x99\\a\\xd95\\xf3X\\x85\\x89\\xae@\\xeb\\xb8#{\\xa6\\x85Rn\\x02\\xe4\" +\n\t\t\t\"\\x9a\\xb3\\xad2\\x12\\xb7w\\x16=\\xa5E\\x85\\xb4y\\x81\\xfe5\\xe2S\\xd8\" +\n\t\t\t\"?lN\\xb2yE,W\\x99\\xd0\\x04\\xe7h\\xd8\\u007f\\xdf\\xc6b\\xef\\xbd\" +\n\t\t\t\"\\x01\\xf8\\x1b\\xb1\\xc3:b\\xd8D\\t\\xd48`@]\\xd0\\xd73\\x1c\\x06\" +\n\t\t\t\";\\xbc\\xdb~\\x95\\bzl\\x17\\xa0u\\xff\\xf4xJ:r\\xfa\\xf6\\x9e\" +\n\t\t\t\"\\xb4E\\x14\\x14)\\xa0\\xe5\\x8aໆ@\\x0fM1\\xe6\\xfb\\x8c\\xfd\\u007f\" +\n\t\t\t\"ͦį\\x8b\\u007f\\x03\\xd3ZT\\xae\\a`\\xa1\\xa4\\x84\\x03.\\xa5x\" +\n\t\t\t\"\\t\\xab\\x1c\\x8d\\xc9T\\xe1\\xa0\\xc2\\xf5\\xec\\x02&À\\xa6\\xf4E\\b\\x0f\" +\n\t\t\t\"ƧǓ\\xb3\\xc9\\xe9d||4n\\x06nz\\xc4\\xc6s\\xe1\\x05\" +\n\t\t\t\"\\xb9*\\xab\\x8c_VQ٬ n\\xe9$\\x0f*\\xd9\\x1c\\x14\\xf2\\xde\" +\n\t\t\t\"C\\xfa\\xdeS^\\xa0U\\xafh\\xbc\\xd0Wt.`{\\x83\\xd3\\xcd{\" +\n\t\t\t\"\\x95}\\f$͑\\xfc\\x10v\\xa3\\xa8\\xb1\\x8ez\\x1d\\x0eN[\\x05\\xb7\" +\n\t\t\t\"6\\xc1\\x1e\\xad\\xc9)m\\xbaF\\xef\\xb1<\\xbc\\x8b(\\xc4\\xf0\\x1e\\x8fF\" +\n\t\t\t\"\\x93\\xe1\\xb8\\xfbp\\x96#I韡\\xa4;κbk-\\xb2\\xa7\" +\n\t\t\t\"K#\\x1f\\v\\xe5\\xbb\\xf3d\\x19\\x91\\u007f\\x85e\\xb8|\\x174j\\x82\\x0f\" +\n\t\t\t\"+\\x15@ \\xa0\\xa5\\x15\\xbd\\xdbʕu>\\x88\\xec\\xb6.ױ%\" +\n\t\t\t\"o.\\xbe\\xa3\\xba}?\\xb6\\xac\\xf4њW*\\xe5_\\x82^\\xc9E\" +\n\t\t\t\"\\xedD#\\xfe\\n\\xad\\xb7B\\xf9 \\xbe\\r,mܒ\\x0e\\xc4\\xdc\\x17\" +\n\t\t\t\"`\\x96\\x84h\\bT`Wꕦ>#\\xee{\\xf7P;X\\xbc\" +\n\t\t\t\"\\x9f\\xa9\\x9d\\x95Bw\\x81m\\xb0\\xf3F\\x91\\xee\\x03M\\xddD\\x84S\\x83\" +\n\t\t\t\"\\xef\\\"Bɤ\\xcas\\xe2\\xcf\\xf8X\\xbc\\xcb\\xeb\\xdcK)\\xbf>\\x1f\" +\n\t\t\t\"\\x14:\\x9b\\xa2\\x94\\xcd/\\x05\\xa9\\xaeg\\x93\\xd9Tlܝ\\xddoF\" +\n\t\t\t\"\\xcf\\xeew\\u007f\\xf6\\x17PK\\x01\\x02\\x14\\x00\\x14\\x00\\x00\\b\\b\\x00D\\xae\" +\n\t\t\t\"\\fC\\xf4\\xeb\\xcaY=\\x01\\x00\\x00g\\x05\\x00\\x00\\x13\\x00\\x00\\x00\\x00\\x00\" +\n\t\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00[Content\" +\n\t\t\t\"_Types].xmlPK\\x01\\x02\\x14\\x00\\x14\\x00\\x00\" +\n\t\t\t\"\\b\\b\\x00D\\xae\\fCf\\xaa\\x82\\xb7\\xe0\\x00\\x00\\x00;\\x02\\x00\\x00\\v\" +\n\t\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00n\\x01\\x00\\x00_re\" +\n\t\t\t\"ls/.relsPK\\x01\\x02\\x14\\x00\\x14\\x00\\x00\\b\\b\\x00\" +\n\t\t\t\"D\\xae\\fC\\x17ϯ\\xa7\\xbc\\x00\\x00\\x005\\x01\\x00\\x00\\x10\\x00\\x00\\x00\" +\n\t\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00w\\x02\\x00\\x00docPro\" +\n\t\t\t\"ps/app.xmlPK\\x01\\x02\\x14\\x00\\x14\\x00\\x00\\b\" +\n\t\t\t\"\\b\\x00D\\xae\\fC\\x17qy\\xdb:\\x01\\x00\\x00x\\x02\\x00\\x00\\x11\\x00\" +\n\t\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00a\\x03\\x00\\x00xl/w\" +\n\t\t\t\"orksheets.xmlPK\\x01\\x02\\x14\\x00\\x14\" +\n\t\t\t\"\\x00\\x00\\b\\b\\x00D\\xae\\fC(\\xba\\xe5Ҧ\\x00\\x00\\x00\\xec\\x00\\x00\" +\n\t\t\t\"\\x00\\x14\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xca\\x04\\x00\\x00x\" +\n\t\t\t\"l/sharedStrings.xmlP\" +\n\t\t\t\"K\\x01\\x02\\x1e\\x03\\x14\\x00\\x00\\b\\b\\x00\\xcf,\\rC\\x0ep\\x99\\x04\\f\" +\n\t\t\t\"\\x04\\x00\\x00\\x96\\x1f\\x00\\x00\\r\\x00\\x18\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xb6\" +\n\t\t\t\"\\x81\\xa2\\x05\\x00\\x00xl/styles.xmlUT\" +\n\t\t\t\"\\x05\\x00\\x035\\xaa\\tRux\\v\\x00\\x01\\x04\\xe8\\x03\\x00\\x00\\x04\\xe8\\x03\" +\n\t\t\t\"\\x00\\x00PK\\x01\\x02\\x1e\\x03\\x14\\x00\\x00\\b\\b\\x00\\xe0\\x15\\xf7D\\b\\xc4\" +\n\t\t\t\"0\\xf9\\xbe\\x01\\x00\\x00}\\x03\\x00\\x00\\x0f\\x00\\x18\\x00\\x00\\x00\\x00\\x00\\x01\\x00\" +\n\t\t\t\"\\x00\\x00\\xb6\\x81\\xf5\\t\\x00\\x00xl/workbook.\" +\n\t\t\t\"xmlUT\\x05\\x00\\x03\\x03\\x06\\xcfSux\\v\\x00\\x01\\x04\\xe8\\x03\" +\n\t\t\t\"\\x00\\x00\\x04\\xe8\\x03\\x00\\x00PK\\x01\\x02\\x1e\\x03\\x14\\x00\\x00\\b\\b\\x00\\xb2\" +\n\t\t\t\"\\x044C\\xa0J\\x80\\x9e\\x84\\x03\\x00\\x00\\x8f\\b\\x00\\x00\\x18\\x00\\x18\\x00\\x00\" +\n\t\t\t\"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xb6\\x81\\xfc\\v\\x00\\x00xl/work\" +\n\t\t\t\"sheets/sheet1.xmlUT\\x05\" +\n\t\t\t\"\\x00\\x03\\xb0|;Rux\\v\\x00\\x01\\x04\\xe8\\x03\\x00\\x00\\x04\\xe8\\x03\\x00\" +\n\t\t\t\"\\x00PK\\x01\\x02\\x1e\\x03\\x14\\x00\\x00\\b\\b\\x00\\xb3\\x044C\\xccJ\\xae\" +\n\t\t\t\"2\\x0e\\x03\\x00\\x00\\x99\\x06\\x00\\x00\\x18\\x00\\x18\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\" +\n\t\t\t\"\\x00\\xb6\\x81\\xd2\\x0f\\x00\\x00xl/worksheets\" +\n\t\t\t\"/sheet2.xmlUT\\x05\\x00\\x03\\xb1|;R\" +\n\t\t\t\"ux\\v\\x00\\x01\\x04\\xe8\\x03\\x00\\x00\\x04\\xe8\\x03\\x00\\x00PK\\x01\\x02D\" +\n\t\t\t\"\\xae\\fC\\xb6w\\xb3\\xfa\\xf6\\x02\\x00\\x00;\\x06\\x00\\x00\\x18\\x00\\x00\\x00\\x00\" +\n\t\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00PK\\x05\\x06\\x00\\x00\\x00\\x00\\n\\x00\\n\" +\n\t\t\t\"\\x00\\xe3\\x02\\x00\\x00^\\x16\\x00\\x00\\x00\\x00\",\n\t}\n\n\tfor _, f := range crashers {\n\t\t_, err := OpenBinary([]byte(f))\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected a well formed error from opening this file\")\n\t\t}\n\t}\n}\n\nfunc TestGrowRowCellSliceDuringFileLoad(t *testing.T) {\n\tc := qt.New(t)\n\tcsRunO(c, \"LoadFileThatRequiresCellSliceGrowth\", func(c *qt.C, o FileOption) {\n\t\t// Loading this file will cause the cell slice to have to grow\n\t\t// during load.  This logic was missing, so this tests that it\n\t\t// is now there ;-)\n\t\tfilePath := \"./testdocs/panic_test.xlsx\"\n\t\t_, err := OpenFile(filePath, RowLimit(100), o)\n\t\tc.Assert(err, qt.Equals, nil)\n\t})\n}\n\nfunc TestIssueSheetsWithHyperlinksHaveLegibleValues(t *testing.T) {\n\tc := qt.New(t)\n\n\t// Issue 574 concerned a sheet with cell values that\n\t// incorrectly showed up blank. This issue was caused by\n\t// mutable state being abused during the data load\n\t// (essentially using Sheet.Row(n) before the sheet was fully\n\t// loaded.  The file: testdocs/issue574.xlsx illustrates this issue.\n\tf, err := OpenFile(\"testdocs/issue574.xlsx\")\n\tc.Assert(err, qt.Equals, nil)\n\n\tsheet, ok := f.Sheet[\"Sheet1\"]\n\tc.Assert(ok, qt.Equals, true)\n\tc.Assert(sheet.MaxRow, qt.Equals, 4)\n\tsheet.ForEachRow(func(r *Row) error {\n\t\tr.ForEachCell(func(cell *Cell) error {\n\t\t\tc.Assert(cell, qt.Not(qt.IsNil))\n\t\t\tc.Assert(cell.Value, qt.Not(qt.Equals), \"\")\n\t\t\treturn nil\n\t\t})\n\t\treturn nil\n\t})\n}\n"
        },
        {
          "name": "memory.go",
          "type": "blob",
          "size": 4.7080078125,
          "content": "package xlsx\n\nimport (\n\t\"fmt\"\n)\n\ntype MemoryRow struct {\n\trow    *Row\n\tmaxCol int\n\tcells  []*Cell\n}\n\nfunc makeMemoryRow(sheet *Sheet) *MemoryRow {\n\tmr := &MemoryRow{\n\t\trow:    new(Row),\n\t\tmaxCol: -1,\n\t}\n\tmr.row.Sheet = sheet\n\tmr.row.cellStoreRow = mr\n\tsheet.setCurrentRow(mr.row)\n\treturn mr\n}\n\nfunc (mr *MemoryRow) Updatable() {\n\t// Do nothing\n}\n\nfunc (mr *MemoryRow) CellUpdatable(c *Cell) {\n\t// Do nothing\n}\n\nfunc (mr *MemoryRow) AddCell() *Cell {\n\tcell := newCell(mr.row, mr.maxCol+1)\n\tmr.PushCell(cell)\n\treturn cell\n}\n\nfunc (mr *MemoryRow) PushCell(c *Cell) {\n\tmr.growCellsSlice(c.num + 1)\n\tmr.cells[c.num] = c\n}\n\nfunc (mr *MemoryRow) growCellsSlice(newSize int) {\n\tif newSize > (mr.maxCol + 1) {\n\t\tmr.maxCol = (newSize - 1)\n\t}\n\n\tcapacity := cap(mr.cells)\n\tif newSize > capacity {\n\t\tnewCap := 2 * capacity\n\t\tif newSize > newCap {\n\t\t\tnewCap = newSize\n\t\t}\n\t\tcapacity = newCap\n\t}\n\tnewSlice := make([]*Cell, newSize, capacity)\n\tcopy(newSlice, mr.cells)\n\tmr.cells = newSlice\n}\n\nfunc (mr *MemoryRow) GetCell(colIdx int) *Cell {\n\tif colIdx >= len(mr.cells) {\n\t\tcell := newCell(mr.row, colIdx)\n\t\tmr.growCellsSlice(colIdx + 1)\n\n\t\tmr.cells[colIdx] = cell\n\t\treturn cell\n\t}\n\n\tcell := mr.cells[colIdx]\n\tif cell == nil {\n\t\tcell = newCell(mr.row, colIdx)\n\t\tmr.cells[colIdx] = cell\n\t}\n\treturn cell\n}\n\nfunc (mr *MemoryRow) ForEachCell(cvf CellVisitorFunc, option ...CellVisitorOption) error {\n\tflags := &cellVisitorFlags{}\n\tfor _, opt := range option {\n\t\topt(flags)\n\t}\n\tfn := func(ci int, c *Cell) error {\n\t\tif c == nil {\n\t\t\tif flags.skipEmptyCells {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tc = mr.GetCell(ci)\n\t\t}\n\t\tif !c.Modified() && flags.skipEmptyCells {\n\t\t\treturn nil\n\t\t}\n\t\tc.Row = mr.row\n\t\treturn cvf(c)\n\t}\n\n\tfor ci, cell := range mr.cells {\n\t\terr := fn(ci, cell)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tcellCount := len(mr.cells)\n\tvar c *Cell\n\tif !flags.skipEmptyCells {\n\t\tfor ci := cellCount; ci < mr.row.Sheet.MaxCol; ci++ {\n\t\t\tc = mr.GetCell(ci)\n\t\t\terr := cvf(c)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// MaxCol returns the index of the rightmost cell in the row's column.\nfunc (mr *MemoryRow) MaxCol() int {\n\treturn mr.maxCol\n}\n\n// CellCount returns the total number of cells in the row.\nfunc (mr *MemoryRow) CellCount() int {\n\treturn mr.maxCol + 1\n}\n\n// MemoryCellStore is the default CellStore - it holds all rows and\n// cells in system memory.  This is fast, right up until you run out\n// of memory ;-)\ntype MemoryCellStore struct {\n\trows map[string]*Row\n}\n\n// UseMemoryCellStore is a FileOption that makes all Sheet instances\n// for a File use memory as their backing store.  This is the default\n// backing store.  You can use this option when you are comfortable\n// keeping the contents of each Sheet in memory.  This is faster than\n// using a disk backed store, but can easily use a large amount of\n// memory and, if you exhaust the available system memory, it'll\n// actualy be slower than using a disk backed store (e.g. DiskV).\nfunc UseMemoryCellStore(f *File) {\n\tf.cellStoreConstructor = NewMemoryCellStore\n}\n\n// NewMemoryCellStore returns a pointer to a newly allocated MemoryCellStore\nfunc NewMemoryCellStore() (CellStore, error) {\n\tcs := &MemoryCellStore{\n\t\trows: make(map[string]*Row),\n\t}\n\treturn cs, nil\n}\n\n// Close is nullOp for the MemoryCellStore, but we have to comply with\n// the interface.\nfunc (mcs *MemoryCellStore) Close() error {\n\treturn nil\n}\n\n// ReadRow returns a Row identfied by the given key.\nfunc (mcs *MemoryCellStore) ReadRow(key string, s *Sheet) (*Row, error) {\n\tr, ok := mcs.rows[key]\n\tif !ok {\n\t\treturn nil, NewRowNotFoundError(key, \"No such row\")\n\t}\n\treturn r, nil\n}\n\n// WriteRow pushes the Row to the MemoryCellStore.\nfunc (mcs *MemoryCellStore) WriteRow(r *Row) error {\n\tif r != nil {\n\t\tkey := r.key()\n\t\tmcs.rows[key] = r\n\t}\n\treturn nil\n}\n\n// MoveRow moves the persisted Row's position in the sheet.\nfunc (mcs *MemoryCellStore) MoveRow(r *Row, index int) error {\n\toldKey := r.key()\n\tr.num = index\n\tnewKey := r.key()\n\tif _, exists := mcs.rows[newKey]; exists {\n\t\treturn fmt.Errorf(\"target index for row (%d) would overwrite a row already exists\", index)\n\t}\n\tmcs.rows[newKey] = r\n\tdelete(mcs.rows, oldKey)\n\treturn nil\n}\n\n// RemoveRow removes a row from the sheet, it doesn't specifically\n// move any following rows, leaving this decision to the user.\nfunc (mcs *MemoryCellStore) RemoveRow(key string) error {\n\tr, ok := mcs.rows[key]\n\tif ok {\n\t\tr.Sheet.setCurrentRow(nil)\n\t\tdelete(mcs.rows, key)\n\t}\n\treturn nil\n}\n\n// MakeRowWithLen returns an empty Row, with a preconfigured starting length.\nfunc (mcs *MemoryCellStore) MakeRowWithLen(sheet *Sheet, len int) *Row {\n\tmr := makeMemoryRow(sheet)\n\tmr.maxCol = len - 1\n\tmr.growCellsSlice(len)\n\treturn mr.row\n}\n\n// MakeRow returns an empty Row\nfunc (mcs *MemoryCellStore) MakeRow(sheet *Sheet) *Row {\n\treturn makeMemoryRow(sheet).row\n}\n"
        },
        {
          "name": "memory_test.go",
          "type": "blob",
          "size": 3.9375,
          "content": "package xlsx\n\nimport (\n\t\"testing\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\nfunc TestMemoryCellStore(t *testing.T) {\n\tc := qt.New(t)\n\n\tc.Run(\"RowNotFoundError\", func(c *qt.C) {\n\t\tmemoryCs, err := NewMemoryCellStore()\n\t\tc.Assert(err, qt.IsNil)\n\t\tcs, ok := memoryCs.(*MemoryCellStore)\n\t\tc.Assert(ok, qt.Equals, true)\n\t\tdefer cs.Close()\n\n\t\trow, err := cs.ReadRow(\"I don't exist\", nil)\n\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t\tc.Assert(row, qt.IsNil)\n\t\t_, ok = err.(*RowNotFoundError)\n\t\tc.Assert(ok, qt.Equals, true)\n\t})\n\n\tc.Run(\"Write and Read Row\", func(c *qt.C) {\n\t\tmCs, err := NewMemoryCellStore()\n\t\tc.Assert(err, qt.IsNil)\n\t\tcs, ok := mCs.(*MemoryCellStore)\n\t\tc.Assert(ok, qt.Equals, true)\n\t\tdefer cs.Close()\n\n\t\ts := &Style{\n\t\t\tBorder: Border{\n\t\t\t\tLeft:        \"left\",\n\t\t\t\tLeftColor:   \"leftColor\",\n\t\t\t\tRight:       \"right\",\n\t\t\t\tRightColor:  \"rightColor\",\n\t\t\t\tTop:         \"top\",\n\t\t\t\tTopColor:    \"topColor\",\n\t\t\t\tBottom:      \"bottom\",\n\t\t\t\tBottomColor: \"bottomColor\",\n\t\t\t},\n\t\t\tFill: Fill{\n\t\t\t\tPatternType: \"PatternType\",\n\t\t\t\tBgColor:     \"BgColor\",\n\t\t\t\tFgColor:     \"FgColor\",\n\t\t\t},\n\t\t\tFont: Font{\n\t\t\t\tSize:      1,\n\t\t\t\tName:      \"Font\",\n\t\t\t\tFamily:    2,\n\t\t\t\tCharset:   3,\n\t\t\t\tColor:     \"Red\",\n\t\t\t\tBold:      true,\n\t\t\t\tItalic:    true,\n\t\t\t\tUnderline: true,\n\t\t\t},\n\t\t\tAlignment: Alignment{\n\t\t\t\tHorizontal:   \"left\",\n\t\t\t\tIndent:       1,\n\t\t\t\tShrinkToFit:  true,\n\t\t\t\tTextRotation: 90,\n\t\t\t\tVertical:     \"top\",\n\t\t\t\tWrapText:     true,\n\t\t\t},\n\t\t\tApplyBorder:    true,\n\t\t\tApplyFill:      true,\n\t\t\tApplyFont:      true,\n\t\t\tApplyAlignment: true,\n\t\t}\n\n\t\tdv := &xlsxDataValidation{\n\t\t\tAllowBlank:       true,\n\t\t\tShowInputMessage: true,\n\t\t\tShowErrorMessage: true,\n\t\t\tType:             \"type\",\n\t\t\tSqref:            \"sqref\",\n\t\t\tFormula1:         \"formula1\",\n\t\t\tFormula2:         \"formula1\",\n\t\t\tOperator:         \"operator\",\n\t\t}\n\n\t\trt := []RichTextRun{\n\t\t\t{\n\t\t\t\tFont: &RichTextFont{Bold: true},\n\t\t\t\tText: \"bold\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tText: \"normal\",\n\t\t\t},\n\t\t}\n\n\t\tfile := NewFile()\n\t\tsheet, _ := file.AddSheet(\"Test\")\n\t\trow := sheet.AddRow()\n\t\tcell := row.AddCell()\n\n\t\tcell.Value = \"value\"\n\t\tcell.RichText = rt\n\t\tcell.formula = \"formula\"\n\t\tcell.style = s\n\t\tcell.NumFmt = \"numFmt\"\n\t\tcell.date1904 = true\n\t\tcell.Hidden = true\n\t\tcell.HMerge = 49\n\t\tcell.VMerge = 50\n\t\tcell.cellType = CellType(2)\n\t\tcell.DataValidation = dv\n\t\tcell.Hyperlink = Hyperlink{\n\t\t\tDisplayString: \"displaystring\",\n\t\t\tLink:          \"link\",\n\t\t\tTooltip:       \"tooltip\",\n\t\t}\n\n\t\terr = cs.WriteRow(row)\n\t\tc.Assert(err, qt.IsNil)\n\t\trow2, err := cs.ReadRow(row.key(), sheet)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tc.Assert(row2, qt.Not(qt.IsNil))\n\t\tc.Assert(row.Hidden, qt.Equals, row2.Hidden)\n\t\tc.Assert(row.GetHeight(), qt.Equals, row2.GetHeight())\n\t\tc.Assert(row.GetOutlineLevel(), qt.Equals, row2.GetOutlineLevel())\n\t\tc.Assert(row.isCustom, qt.Equals, row2.isCustom)\n\t\tc.Assert(row.num, qt.Equals, row2.num)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, row2.cellStoreRow.CellCount())\n\n\t\tcell2 := row.GetCell(0)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tc.Assert(cell.Value, qt.Equals, cell2.Value)\n\t\tc.Assert(cell.RichText, qt.DeepEquals, cell2.RichText)\n\t\tc.Assert(cell.formula, qt.Equals, cell2.formula)\n\t\tc.Assert(cell.NumFmt, qt.Equals, cell2.NumFmt)\n\t\tc.Assert(cell.date1904, qt.Equals, cell2.date1904)\n\t\tc.Assert(cell.Hidden, qt.Equals, cell2.Hidden)\n\t\tc.Assert(cell.HMerge, qt.Equals, cell2.HMerge)\n\t\tc.Assert(cell.VMerge, qt.Equals, cell2.VMerge)\n\t\tc.Assert(cell.cellType, qt.Equals, cell2.cellType)\n\t\tc.Assert(*cell.DataValidation, qt.DeepEquals, *cell2.DataValidation)\n\t\tc.Assert(cell.Hyperlink, qt.DeepEquals, cell2.Hyperlink)\n\t\tc.Assert(cell.num, qt.Equals, cell2.num)\n\n\t\ts2 := cell2.style\n\t\tc.Assert(s2.Border, qt.DeepEquals, s.Border)\n\t\tc.Assert(s2.Fill, qt.DeepEquals, s.Fill)\n\t\tc.Assert(s2.Font, qt.DeepEquals, s.Font)\n\t\tc.Assert(s2.Alignment, qt.DeepEquals, s.Alignment)\n\t\tc.Assert(s2.ApplyBorder, qt.Equals, s.ApplyBorder)\n\t\tc.Assert(s2.ApplyFill, qt.Equals, s.ApplyFill)\n\t\tc.Assert(s2.ApplyFont, qt.Equals, s.ApplyFont)\n\t\tc.Assert(s2.ApplyAlignment, qt.Equals, s.ApplyAlignment)\n\n\t})\n\n}\n"
        },
        {
          "name": "read.go",
          "type": "blob",
          "size": 2.8876953125,
          "content": "package xlsx\n\nimport (\n\t\"errors\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"time\"\n)\n\nvar (\n\terrNilInterface     = errors.New(\"nil pointer is not a valid argument\")\n\terrNotStructPointer = errors.New(\"argument must be a pointer to struct\")\n\terrInvalidTag       = errors.New(`invalid tag: must have the format xlsx:idx`)\n)\n\n// XLSXUnmarshaler is the interface implemented for types that can unmarshal a Row\n// as a representation of themselves.\ntype XLSXUnmarshaler interface {\n\tUnmarshal(*Row) error\n}\n\n// ReadStruct reads a struct from r to ptr. Accepts a ptr\n// to struct. This code expects a tag xlsx:\"N\", where N is the index\n// of the cell to be used. Basic types like int,string,float64 and bool\n// are supported\nfunc (r *Row) ReadStruct(ptr interface{}) error {\n\tif ptr == nil {\n\t\treturn errNilInterface\n\t}\n\t//check if the type implements XLSXUnmarshaler. If so,\n\t//just let it do the work.\n\tunmarshaller, ok := ptr.(XLSXUnmarshaler)\n\tif ok {\n\t\treturn unmarshaller.Unmarshal(r)\n\t}\n\tv := reflect.ValueOf(ptr)\n\tif v.Kind() != reflect.Ptr {\n\t\treturn errNotStructPointer\n\t}\n\tv = v.Elem()\n\tif v.Kind() != reflect.Struct {\n\t\treturn errNotStructPointer\n\t}\n\tn := v.NumField()\n\tfor i := 0; i < n; i++ {\n\t\tfield := v.Type().Field(i)\n\t\tidx := field.Tag.Get(\"xlsx\")\n\t\t//do a recursive check for the field if it is a struct or a pointer\n\t\t//even if it doesn't have a tag\n\t\t//ignore if it has a - or empty tag\n\t\tisTime := false\n\t\tswitch {\n\t\tcase idx == \"-\":\n\t\t\tcontinue\n\t\tcase field.Type.Kind() == reflect.Ptr || field.Type.Kind() == reflect.Struct:\n\t\t\tvar structPtr interface{}\n\t\t\tif !v.Field(i).CanSet() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif field.Type.Kind() == reflect.Struct {\n\t\t\t\tstructPtr = v.Field(i).Addr().Interface()\n\t\t\t} else {\n\t\t\t\tstructPtr = v.Field(i).Interface()\n\t\t\t}\n\t\t\t//check if the container is a time.Time\n\t\t\t_, isTime = structPtr.(*time.Time)\n\t\t\tif isTime {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\terr := r.ReadStruct(structPtr)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\tcase len(idx) == 0:\n\t\t\tcontinue\n\t\t}\n\t\tpos, err := strconv.Atoi(idx)\n\t\tif err != nil {\n\t\t\treturn errInvalidTag\n\t\t}\n\n\t\tcell := r.GetCell(pos)\n\t\tfieldV := v.Field(i)\n\t\t//continue if the field is not settable\n\t\tif !fieldV.CanSet() {\n\t\t\tcontinue\n\t\t}\n\t\tif isTime {\n\t\t\tt, err := cell.GetTime(false)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif field.Type.Kind() == reflect.Ptr {\n\t\t\t\tfieldV.Set(reflect.ValueOf(&t))\n\t\t\t} else {\n\t\t\t\tfieldV.Set(reflect.ValueOf(t))\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tswitch field.Type.Kind() {\n\t\tcase reflect.String:\n\t\t\tvalue, err := cell.FormattedValue()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfieldV.SetString(value)\n\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\t\tvalue, err := cell.Int64()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfieldV.SetInt(value)\n\t\tcase reflect.Float64:\n\t\t\tvalue, err := cell.Float()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfieldV.SetFloat(value)\n\t\tcase reflect.Bool:\n\t\t\tvalue := cell.Bool()\n\t\t\tfieldV.SetBool(value)\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "read_test.go",
          "type": "blob",
          "size": 5.892578125,
          "content": "package xlsx\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\nvar (\n\terrorNoPair         = errors.New(\"integer to be unmarshaled is not a pair\")\n\terrorNotEnoughCells = errors.New(\"row has not enough cells\")\n)\n\ntype pairUnmarshaler int\n\nfunc (i *pairUnmarshaler) Unmarshal(row *Row) error {\n\tif row.cellStoreRow.CellCount() == 0 {\n\t\treturn errorNotEnoughCells\n\t}\n\tcellInt, err := row.GetCell(0).Int()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif cellInt%2 != 0 {\n\t\treturn errorNoPair\n\t}\n\t*i = pairUnmarshaler(cellInt)\n\treturn nil\n}\n\ntype structUnmarshaler struct {\n\tprivate bool\n\tcustom  string\n\tnormal  int\n}\n\nfunc (s *structUnmarshaler) Unmarshal(r *Row) error {\n\tif r.cellStoreRow.CellCount() < 3 {\n\t\treturn errorNotEnoughCells\n\t}\n\ts.private = r.GetCell(0).Bool()\n\tvar err error\n\ts.normal, err = r.GetCell(2).Int()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcurrency, err := r.GetCell(1).FormattedValue()\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.custom = fmt.Sprintf(\"$ %s\", currency)\n\treturn nil\n}\n\nfunc TestRead(t *testing.T) {\n\tc := qt.New(t)\n\n\tcsRunO(c, \"TestInterface\", func(c *qt.C, option FileOption) {\n\t\tvar p pairUnmarshaler\n\t\tvar s structUnmarshaler\n\t\tf := NewFile(option)\n\t\tsheet, _ := f.AddSheet(\"TestReadTime\")\n\t\trow := sheet.AddRow()\n\t\tvalues := []interface{}{1, \"500\", true}\n\t\trow.WriteSlice(&values, -1)\n\t\terrPair := row.ReadStruct(&p)\n\t\terr := row.ReadStruct(&s)\n\t\tc.Assert(errPair, qt.Equals, errorNoPair)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tvar empty pairUnmarshaler\n\t\tc.Assert(p, qt.Equals, empty)\n\t\tc.Assert(s.normal, qt.Equals, 1)\n\t\tc.Assert(s.private, qt.Equals, true)\n\t\tc.Assert(s.custom, qt.Equals, \"$ 500\")\n\t})\n\n\tcsRunO(c, \"TestTime\", func(c *qt.C, option FileOption) {\n\t\ttype Timer struct {\n\t\t\tInitial time.Time `xlsx:\"0\"`\n\t\t\tFinal   time.Time `xlsx:\"1\"`\n\t\t}\n\t\tinitial := time.Date(1990, 12, 30, 10, 30, 30, 0, time.UTC)\n\t\tt := Timer{\n\t\t\tInitial: initial,\n\t\t\tFinal:   initial.Add(time.Hour * 24),\n\t\t}\n\t\tf := NewFile(option)\n\t\tsheet, _ := f.AddSheet(\"TestReadTime\")\n\t\trow := sheet.AddRow()\n\t\tcell := row.AddCell()\n\t\tcell.SetDateTime(t.Initial)\n\t\tctime2 := row.AddCell()\n\t\tctime2.SetDate(t.Final)\n\t\tt2 := Timer{}\n\t\terr := row.ReadStruct(&t2)\n\t\tif err != nil {\n\t\t\tc.Error(err)\n\t\t\tc.FailNow()\n\t\t}\n\t\t//removing ns precition\n\t\tt2.Initial = t2.Initial.Add(time.Duration(-1 * t2.Initial.Nanosecond()))\n\t\tt2.Final = t2.Final.Add(time.Duration(-1 * t2.Final.Nanosecond()))\n\t\tc.Assert(t2.Initial, qt.Equals, t.Initial)\n\t\tc.Assert(t2.Final, qt.Equals, t.Final)\n\t})\n\n\tcsRunO(c, \"TestEmbedStruct\", func(c *qt.C, option FileOption) {\n\t\ttype Embed struct {\n\t\t\tprivateVal bool   `xlsx:\"0\"`\n\t\t\tIgnoredVal int    `xlsx:\"-\"`\n\t\t\tVisibleVal string `xlsx:\"2\"`\n\t\t}\n\t\ttype structTest struct {\n\t\t\tEmbed\n\t\t\tFinalVal string `xlsx:\"3\"`\n\t\t}\n\t\tf := NewFile(option)\n\t\tsheet, _ := f.AddSheet(\"TestRead\")\n\t\trow := sheet.AddRow()\n\t\tv := structTest{\n\t\t\tEmbed: Embed{\n\t\t\t\tprivateVal: true,\n\t\t\t\tIgnoredVal: 10,\n\t\t\t\tVisibleVal: \"--This is a test value--\",\n\t\t\t},\n\t\t\tFinalVal: \"--end of struct\",\n\t\t}\n\t\tvalues := []string{\n\t\t\tfmt.Sprint(v.privateVal),\n\t\t\tfmt.Sprint(v.IgnoredVal),\n\t\t\tfmt.Sprint(v.VisibleVal),\n\t\t\tfmt.Sprint(v.FinalVal),\n\t\t}\n\t\trow.WriteSlice(&values, -1)\n\t\tread := new(structTest)\n\t\terr := row.ReadStruct(read)\n\t\tif err != nil {\n\t\t\tc.Error(err)\n\t\t\tc.FailNow()\n\t\t}\n\t\tc.Assert(read.privateVal, qt.Equals, false)\n\t\tc.Assert(read.VisibleVal, qt.Equals, v.VisibleVal)\n\t\tc.Assert(read.IgnoredVal, qt.Equals, 0)\n\t\tc.Assert(read.FinalVal, qt.Equals, v.FinalVal)\n\t})\n\n\tcsRunO(c, \"TestReadStructPrivateFields\", func(c *qt.C, option FileOption) {\n\t\ttype nested struct {\n\t\t\tIgnoredVal int    `xlsx:\"-\"`\n\t\t\tVisibleVal string `xlsx:\"6\"`\n\t\t\tprivateVal bool   `xlsx:\"7\"`\n\t\t}\n\t\ttype structTest struct {\n\t\t\tIntVal     int16   `xlsx:\"0\"`\n\t\t\tStringVal  string  `xlsx:\"1\"`\n\t\t\tFloatVal   float64 `xlsx:\"2\"`\n\t\t\tIgnoredVal int     `xlsx:\"-\"`\n\t\t\tBoolVal    bool    `xlsx:\"4\"`\n\t\t\tNested     nested\n\t\t}\n\t\tval := structTest{\n\t\t\tIntVal:     16,\n\t\t\tStringVal:  \"heyheyhey :)!\",\n\t\t\tFloatVal:   3.14159216,\n\t\t\tIgnoredVal: 7,\n\t\t\tBoolVal:    true,\n\t\t\tNested: nested{\n\t\t\t\tprivateVal: true,\n\t\t\t\tIgnoredVal: 90,\n\t\t\t\tVisibleVal: \"Hello\",\n\t\t\t},\n\t\t}\n\t\twrittenValues := []string{\n\t\t\tfmt.Sprint(val.IntVal), val.StringVal, fmt.Sprint(val.FloatVal),\n\t\t\tfmt.Sprint(val.IgnoredVal), fmt.Sprint(val.BoolVal),\n\t\t\tfmt.Sprint(val.Nested.IgnoredVal), val.Nested.VisibleVal,\n\t\t\tfmt.Sprint(val.Nested.privateVal),\n\t\t}\n\t\tf := NewFile(option)\n\t\tsheet, _ := f.AddSheet(\"TestRead\")\n\t\trow := sheet.AddRow()\n\t\trow.WriteSlice(&writtenValues, -1)\n\t\treadStruct := structTest{}\n\t\terr := row.ReadStruct(&readStruct)\n\t\tif err != nil {\n\t\t\tc.Error(err)\n\t\t\tc.FailNow()\n\t\t}\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(readStruct.IntVal, qt.Equals, val.IntVal)\n\t\tc.Assert(readStruct.StringVal, qt.Equals, val.StringVal)\n\t\tc.Assert(readStruct.IgnoredVal, qt.Equals, 0)\n\t\tc.Assert(readStruct.FloatVal, qt.Equals, val.FloatVal)\n\t\tc.Assert(readStruct.BoolVal, qt.Equals, val.BoolVal)\n\t\tc.Assert(readStruct.Nested.IgnoredVal, qt.Equals, 0)\n\t\tc.Assert(readStruct.Nested.VisibleVal, qt.Equals, \"Hello\")\n\t\tc.Assert(readStruct.Nested.privateVal, qt.Equals, false)\n\t})\n\n\tcsRunO(c, \"TestReadStruct\", func(c *qt.C, option FileOption) {\n\t\ttype structTest struct {\n\t\t\tIntVal     int8    `xlsx:\"0\"`\n\t\t\tStringVal  string  `xlsx:\"1\"`\n\t\t\tFloatVal   float64 `xlsx:\"2\"`\n\t\t\tIgnoredVal int     `xlsx:\"-\"`\n\t\t\tBoolVal    bool    `xlsx:\"4\"`\n\t\t}\n\t\tstructVal := structTest{\n\t\t\tIntVal:     10,\n\t\t\tStringVal:  \"heyheyhey :)!\",\n\t\t\tFloatVal:   3.14159216,\n\t\t\tIgnoredVal: 7,\n\t\t\tBoolVal:    true,\n\t\t}\n\t\tf := NewFile(option)\n\t\tsheet, _ := f.AddSheet(\"TestRead\")\n\t\trow := sheet.AddRow()\n\t\trow.WriteStruct(&structVal, -1)\n\n\t\treadStruct := &structTest{}\n\t\terr := row.ReadStruct(readStruct)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(readStruct.IntVal, qt.Equals, structVal.IntVal)\n\t\tc.Assert(readStruct.StringVal, qt.Equals, structVal.StringVal)\n\t\tc.Assert(readStruct.IgnoredVal, qt.Equals, 0)\n\t\tc.Assert(readStruct.FloatVal, qt.Equals, structVal.FloatVal)\n\t\tc.Assert(readStruct.BoolVal, qt.Equals, structVal.BoolVal)\n\t})\n\n}\n"
        },
        {
          "name": "reftable.go",
          "type": "blob",
          "size": 3.728515625,
          "content": "package xlsx\n\nconst DEFAULT_REFTABLE_SIZE = 500\n\ntype plainTextOrRichText struct {\n\tplainText  string\n\tisRichText bool\n\trichText   []RichTextRun\n}\n\ntype RefTable struct {\n\tindexedStrings []plainTextOrRichText\n\tknownStrings   map[string][]int\n\tisWrite        bool\n}\n\n// NewSharedStringRefTable creates a new, empty RefTable.\nfunc NewSharedStringRefTable(size int) *RefTable {\n\trt := RefTable{}\n\trt.indexedStrings = make([]plainTextOrRichText, 0, size)\n\trt.knownStrings = make(map[string][]int, size)\n\treturn &rt\n}\n\n// // MakeSharedStringRefTable takes an xlsxSST struct and converts\n// // it's contents to an slice of strings used to refer to string values\n// // by numeric index - this is the model used within XLSX worksheet (a\n// // numeric reference is stored to a shared cell value).\n// func MakeSharedStringRefTable(source *xlsxSST) *RefTable {\n// \treftable := NewSharedStringRefTable(len(source.SI))\n// \treftable.isWrite = false\n// \tfor _, si := range source.SI {\n// \t\tif len(si.R) > 0 {\n// \t\t\trichText := xmlToRichText(si.R)\n// \t\t\treftable.AddRichText(richText)\n// \t\t} else {\n// \t\t\treftable.AddString(si.T.getText())\n// \t\t}\n// \t}\n// \treturn reftable\n// }\n\n// makeXlsxSST takes a RefTable and returns and\n// equivalent xlsxSST representation.\nfunc (rt *RefTable) makeXLSXSST() xlsxSST {\n\tsst := xlsxSST{}\n\tsst.Count = len(rt.indexedStrings)\n\tsst.UniqueCount = sst.Count\n\tfor _, ref := range rt.indexedStrings {\n\t\tsi := xlsxSI{}\n\t\tif ref.isRichText {\n\t\t\tsi.R = richTextToXml(ref.richText)\n\t\t} else {\n\t\t\tsi.T = &xlsxT{Text: ref.plainText}\n\t\t}\n\t\tsst.SI = append(sst.SI, si)\n\t}\n\treturn sst\n}\n\n// ResolveSharedString looks up a string value or the rich text by numeric index from\n// a provided reference table (just a slice of strings in the correct order).\n// If the rich text was found, non-empty slice will be returned in richText.\n// This function only exists to provide clarity of purpose via it's name.\nfunc (rt *RefTable) ResolveSharedString(index int) (plainText string, richText []RichTextRun) {\n\tptrt := rt.indexedStrings[index]\n\tif ptrt.isRichText {\n\t\trichText = ptrt.richText\n\t} else {\n\t\tplainText = ptrt.plainText\n\t}\n\treturn\n}\n\n// AddString adds a string to the reference table and return it's\n// numeric index.  If the string already exists then it simply returns\n// the existing index.\nfunc (rt *RefTable) AddString(str string) int {\n\tif rt.isWrite {\n\t\tindices, ok := rt.knownStrings[str]\n\t\tif ok {\n\t\t\tfor _, index := range indices {\n\t\t\t\tif !rt.indexedStrings[index].isRichText {\n\t\t\t\t\treturn index\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tptrt := plainTextOrRichText{plainText: str, isRichText: false}\n\trt.indexedStrings = append(rt.indexedStrings, ptrt)\n\tindex := len(rt.indexedStrings) - 1\n\trt.knownStrings[str] = append(rt.knownStrings[str], index)\n\treturn index\n}\n\n// AddRichText adds a set of rich text to the reference table and return it's\n// numeric index.  If a set of rich text already exists then it simply returns\n// the existing index.\nfunc (rt *RefTable) AddRichText(r []RichTextRun) int {\n\tplain := richTextToPlainText(r)\n\tif rt.isWrite {\n\t\tindices, ok := rt.knownStrings[plain]\n\t\tif ok {\n\t\t\tfor _, index := range indices {\n\t\t\t\tif rt.indexedStrings[index].isRichText && areRichTextsEqual(rt.indexedStrings[index].richText, r) {\n\t\t\t\t\treturn index\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tptrt := plainTextOrRichText{isRichText: true}\n\tptrt.richText = append(ptrt.richText, r...)\n\trt.indexedStrings = append(rt.indexedStrings, ptrt)\n\tindex := len(rt.indexedStrings) - 1\n\trt.knownStrings[plain] = append(rt.knownStrings[plain], index)\n\treturn index\n}\n\nfunc areRichTextsEqual(r1 []RichTextRun, r2 []RichTextRun) bool {\n\tif len(r1) != len(r2) {\n\t\treturn false\n\t}\n\tfor i, rt1 := range r1 {\n\t\trt2 := r2[i]\n\t\tif !rt1.Equals(&rt2) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (rt *RefTable) Length() int {\n\treturn len(rt.indexedStrings)\n}\n"
        },
        {
          "name": "reftable_test.go",
          "type": "blob",
          "size": 7.107421875,
          "content": "package xlsx\n\nimport (\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"testing\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\ntype RefTableSuite struct {\n\tSharedStringsXML *bytes.Buffer\n}\n\nvar reftabletest_sharedStringsXMLStr = (`<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n\t<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"\n\t\t count=\"4\"\n\t\t uniqueCount=\"4\">\n\t  <si>\n\t\t<t>Foo</t>\n\t  </si>\n\t  <si>\n\t\t<t>Bar</t>\n\t  </si>\n\t  <si>\n\t\t<t xml:space=\"preserve\">Baz \n</t>\n\t  </si>\n\t  <si>\n\t\t<t>Quuk</t>\n\t  </si>\n\t  <si>\n\t\t<r>\n\t\t  <rPr>\n\t\t\t<sz val=\"11.5\"/>\n\t\t\t<rFont val=\"Font1\"/>\n\t\t  </rPr>\n\t\t  <t>Text1</t>\n\t\t</r>\n\t\t<r>\n\t\t  <rPr>\n\t\t\t<sz val=\"12.5\"/>\n\t\t\t<rFont val=\"Font2\"/>\n\t\t  </rPr>\n\t\t  <t>Text2</t>\n\t\t</r>\n\t  </si>\n\t  </sst>`)\n\n// We can add a new string to the RefTable\nfunc TestRefTableAddString(t *testing.T) {\n\tc := qt.New(t)\n\trefTable := NewSharedStringRefTable(1)\n\tindex := refTable.AddString(\"Foo\")\n\tc.Assert(index, qt.Equals, 0)\n\tp, r := refTable.ResolveSharedString(0)\n\tc.Assert(p, qt.Equals, \"Foo\")\n\tc.Assert(r, qt.IsNil)\n}\n\nfunc TestCreateNewSharedStringRefTable(t *testing.T) {\n\tc := qt.New(t)\n\trefTable := NewSharedStringRefTable(2)\n\trefTable.AddString(\"Foo\")\n\trefTable.AddString(\"Bar\")\n\tp, r := refTable.ResolveSharedString(0)\n\tc.Assert(p, qt.Equals, \"Foo\")\n\tc.Assert(r, qt.IsNil)\n\tp, r = refTable.ResolveSharedString(1)\n\tc.Assert(p, qt.Equals, \"Bar\")\n\tc.Assert(r, qt.IsNil)\n}\n\n// Test we can correctly convert a xlsxSST into a reference table\n// using xlsx.MakeSharedStringRefTable().\nfunc TestMakeSharedStringRefTable(t *testing.T) {\n\tc := qt.New(t)\n\tsharedStringsXML := bytes.NewBufferString(reftabletest_sharedStringsXMLStr)\n\n\treftable, err := readSharedStrings(sharedStringsXML)\n\tc.Assert(err, qt.IsNil)\n\n\tc.Assert(reftable.Length(), qt.Equals, 5)\n\tp, r := reftable.ResolveSharedString(0)\n\tc.Assert(p, qt.Equals, \"Foo\")\n\tc.Assert(r, qt.IsNil)\n\tp, r = reftable.ResolveSharedString(1)\n\tc.Assert(p, qt.Equals, \"Bar\")\n\tc.Assert(r, qt.IsNil)\n\tp, r = reftable.ResolveSharedString(2)\n\tc.Assert(p, qt.Equals, \"Baz \\n\")\n\tc.Assert(r, qt.IsNil)\n\tp, r = reftable.ResolveSharedString(3)\n\tc.Assert(p, qt.Equals, \"Quuk\")\n\tc.Assert(r, qt.IsNil)\n\tp, r = reftable.ResolveSharedString(4)\n\tc.Assert(p, qt.Equals, \"\")\n\tc.Assert(r, qt.HasLen, 2)\n\tc.Assert(r[0].Font.Size, qt.Equals, 11.5)\n\tc.Assert(r[0].Font.Name, qt.Equals, \"Font1\")\n\tc.Assert(r[1].Font.Size, qt.Equals, 12.5)\n\tc.Assert(r[1].Font.Name, qt.Equals, \"Font2\")\n}\n\n// Test we can correctly resolve a numeric reference in the reference\n// table to a string value using RefTable.ResolveSharedString().\nfunc TestResolveSharedString(t *testing.T) {\n\tc := qt.New(t)\n\tsharedStringsXML := bytes.NewBufferString(reftabletest_sharedStringsXMLStr)\n\treftable, err := readSharedStrings(sharedStringsXML)\n\tc.Assert(err, qt.IsNil)\n\n\tp, r := reftable.ResolveSharedString(0)\n\tc.Assert(p, qt.Equals, \"Foo\")\n\tc.Assert(r, qt.IsNil)\n}\n\n// Test we can correctly create the xlsx.xlsxSST struct from a RefTable\nfunc TestMakeXLSXSST(t *testing.T) {\n\tc := qt.New(t)\n\trefTable := NewSharedStringRefTable(2)\n\trefTable.AddString(\"Foo\")\n\trefTable.AddString(\"Bar\")\n\trefTable.AddRichText([]RichTextRun{\n\t\t{\n\t\t\tFont: &RichTextFont{\n\t\t\t\tFamily:  RichTextFontFamilyUnspecified,\n\t\t\t\tCharset: RichTextCharsetUnspecified,\n\t\t\t\tBold:    true,\n\t\t\t},\n\t\t\tText: \"Text1\",\n\t\t},\n\t\t{\n\t\t\tText: \"Text2\",\n\t\t},\n\t})\n\tsst := refTable.makeXLSXSST()\n\tc.Assert(sst, qt.IsNotNil)\n\tc.Assert(sst.Count, qt.Equals, 3)\n\tc.Assert(sst.UniqueCount, qt.Equals, 3)\n\tc.Assert(sst.SI, qt.HasLen, 3)\n\tsi := sst.SI[0]\n\tc.Assert(si.T.Text, qt.Equals, \"Foo\")\n\tc.Assert(si.R, qt.IsNil)\n\tsi = sst.SI[2]\n\tc.Assert(si.T, qt.IsNil)\n\tc.Assert(si.R, qt.HasLen, 2)\n\tc.Assert(si.R[0].RPr.B, qt.IsNotNil)\n\tc.Assert(si.R[0].T.Text, qt.Equals, \"Text1\")\n\tc.Assert(si.R[1].RPr, qt.IsNil)\n\tc.Assert(si.R[1].T.Text, qt.Equals, \"Text2\")\n}\n\nfunc TestMarshalSST(t *testing.T) {\n\tc := qt.New(t)\n\trefTable := NewSharedStringRefTable(1)\n\trefTable.AddString(\"Foo\")\n\trefTable.AddRichText([]RichTextRun{\n\t\t{\n\t\t\tFont: &RichTextFont{\n\t\t\t\tFamily:  RichTextFontFamilyUnspecified,\n\t\t\t\tCharset: RichTextCharsetUnspecified,\n\t\t\t\tBold:    true,\n\t\t\t},\n\t\t\tText: \"Text1\",\n\t\t},\n\t\t{\n\t\t\tText: \"Text2\",\n\t\t},\n\t})\n\tsst := refTable.makeXLSXSST()\n\n\toutput := bytes.NewBufferString(xml.Header)\n\tbody, err := xml.Marshal(sst)\n\tc.Assert(err, qt.IsNil)\n\tc.Assert(body, qt.IsNotNil)\n\t_, err = output.Write(body)\n\tc.Assert(err, qt.IsNil)\n\n\texpectedXLSXSST := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"2\" uniqueCount=\"2\"><si><t>Foo</t></si><si><r><rPr><b></b></rPr><t>Text1</t></r><r><t>Text2</t></r></si></sst>`\n\tc.Assert(output.String(), qt.Equals, expectedXLSXSST)\n}\n\nfunc TestRefTableReadAddString(t *testing.T) {\n\tc := qt.New(t)\n\trefTable := NewSharedStringRefTable(2)\n\trefTable.isWrite = false\n\tindex1 := refTable.AddString(\"Foo\")\n\tindex2 := refTable.AddString(\"Foo\")\n\tc.Assert(index1, qt.Equals, 0)\n\tc.Assert(index2, qt.Equals, 1)\n\tp, r := refTable.ResolveSharedString(0)\n\tc.Assert(p, qt.Equals, \"Foo\")\n\tc.Assert(r, qt.IsNil)\n\tp, r = refTable.ResolveSharedString(1)\n\tc.Assert(p, qt.Equals, \"Foo\")\n\tc.Assert(r, qt.IsNil)\n}\n\nfunc TestRefTableWriteAddString(t *testing.T) {\n\tc := qt.New(t)\n\trefTable := NewSharedStringRefTable(2)\n\trefTable.isWrite = true\n\tindex1 := refTable.AddString(\"Foo\")\n\tindex2 := refTable.AddString(\"Foo\")\n\tc.Assert(index1, qt.Equals, 0)\n\tc.Assert(index2, qt.Equals, 0)\n\tp, r := refTable.ResolveSharedString(0)\n\tc.Assert(p, qt.Equals, \"Foo\")\n\tc.Assert(r, qt.IsNil)\n}\n\nfunc TestRefTableReadAddRichText(t *testing.T) {\n\tc := qt.New(t)\n\trefTable := NewSharedStringRefTable(2)\n\trefTable.isWrite = false\n\tindex1 := refTable.AddRichText([]RichTextRun{\n\t\t{\n\t\t\tFont: &RichTextFont{\n\t\t\t\tFamily:  RichTextFontFamilyUnspecified,\n\t\t\t\tCharset: RichTextCharsetUnspecified,\n\t\t\t\tBold:    true,\n\t\t\t},\n\t\t\tText: \"Text1\",\n\t\t},\n\t})\n\tindex2 := refTable.AddRichText([]RichTextRun{\n\t\t{\n\t\t\tFont: &RichTextFont{\n\t\t\t\tFamily:  RichTextFontFamilyUnspecified,\n\t\t\t\tCharset: RichTextCharsetUnspecified,\n\t\t\t\tBold:    true,\n\t\t\t},\n\t\t\tText: \"Text1\",\n\t\t},\n\t})\n\n\tc.Assert(index1, qt.Equals, 0)\n\tc.Assert(index2, qt.Equals, 1)\n\tp, r := refTable.ResolveSharedString(0)\n\tc.Assert(p, qt.Equals, \"\")\n\tc.Assert(r, qt.HasLen, 1)\n\tc.Assert(r[0].Font.Bold, qt.IsNotNil)\n\tc.Assert(r[0].Text, qt.Equals, \"Text1\")\n\tp, r = refTable.ResolveSharedString(1)\n\tc.Assert(p, qt.Equals, \"\")\n\tc.Assert(r, qt.HasLen, 1)\n\tc.Assert(r[0].Font.Bold, qt.IsNotNil)\n\tc.Assert(r[0].Text, qt.Equals, \"Text1\")\n}\n\nfunc TestRefTableWriteAddRichText(t *testing.T) {\n\tc := qt.New(t)\n\trefTable := NewSharedStringRefTable(2)\n\trefTable.isWrite = true\n\tindex1 := refTable.AddRichText([]RichTextRun{\n\t\t{\n\t\t\tFont: &RichTextFont{\n\t\t\t\tFamily:  RichTextFontFamilyUnspecified,\n\t\t\t\tCharset: RichTextCharsetUnspecified,\n\t\t\t\tBold:    true,\n\t\t\t},\n\t\t\tText: \"Text1\",\n\t\t},\n\t})\n\tindex2 := refTable.AddRichText([]RichTextRun{\n\t\t{\n\t\t\tFont: &RichTextFont{\n\t\t\t\tFamily:  RichTextFontFamilyUnspecified,\n\t\t\t\tCharset: RichTextCharsetUnspecified,\n\t\t\t\tBold:    true,\n\t\t\t},\n\t\t\tText: \"Text1\",\n\t\t},\n\t})\n\n\tc.Assert(index1, qt.Equals, 0)\n\tc.Assert(index2, qt.Equals, 0)\n\tp, r := refTable.ResolveSharedString(0)\n\tc.Assert(p, qt.Equals, \"\")\n\tc.Assert(r, qt.HasLen, 1)\n\tc.Assert(r[0].Font.Bold, qt.IsNotNil)\n\tc.Assert(r[0].Text, qt.Equals, \"Text1\")\n}\n"
        },
        {
          "name": "richtext.go",
          "type": "blob",
          "size": 6.169921875,
          "content": "package xlsx\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\ntype RichTextFontFamily int\ntype RichTextCharset int\ntype RichTextVertAlign string\ntype RichTextUnderline string\n\nconst (\n\t// RichTextFontFamilyUnspecified indicates that the font family was not specified\n\tRichTextFontFamilyUnspecified   RichTextFontFamily = -1\n\tRichTextFontFamilyNotApplicable RichTextFontFamily = 0\n\tRichTextFontFamilyRoman         RichTextFontFamily = 1\n\tRichTextFontFamilySwiss         RichTextFontFamily = 2\n\tRichTextFontFamilyModern        RichTextFontFamily = 3\n\tRichTextFontFamilyScript        RichTextFontFamily = 4\n\tRichTextFontFamilyDecorative    RichTextFontFamily = 5\n\n\t// RichTextCharsetUnspecified indicates that the font charset was not specified\n\tRichTextCharsetUnspecified RichTextCharset = -1\n\tRichTextCharsetANSI        RichTextCharset = 0\n\tRichTextCharsetDefault     RichTextCharset = 1\n\tRichTextCharsetSymbol      RichTextCharset = 2\n\tRichTextCharsetMac         RichTextCharset = 77\n\tRichTextCharsetShiftJIS    RichTextCharset = 128\n\tRichTextCharsetHangul      RichTextCharset = 129\n\tRichTextCharsetJohab       RichTextCharset = 130\n\tRichTextCharsetGB2312      RichTextCharset = 134\n\tRichTextCharsetBIG5        RichTextCharset = 136\n\tRichTextCharsetGreek       RichTextCharset = 161\n\tRichTextCharsetTurkish     RichTextCharset = 162\n\tRichTextCharsetVietnamese  RichTextCharset = 163\n\tRichTextCharsetHebrew      RichTextCharset = 177\n\tRichTextCharsetArabic      RichTextCharset = 178\n\tRichTextCharsetBaltic      RichTextCharset = 186\n\tRichTextCharsetRussian     RichTextCharset = 204\n\tRichTextCharsetThai        RichTextCharset = 222\n\tRichTextCharsetEastEurope  RichTextCharset = 238\n\tRichTextCharsetOEM         RichTextCharset = 255\n\n\tRichTextVertAlignSuperscript RichTextVertAlign = \"superscript\"\n\tRichTextVertAlignSubscript   RichTextVertAlign = \"subscript\"\n\n\tRichTextUnderlineSingle RichTextUnderline = \"single\"\n\tRichTextUnderlineDouble RichTextUnderline = \"double\"\n\n\t// These underline styles doesn't work on the RichTextRun,\n\t// and should be set as a part of cell style.\n\t// \"singleAccounting\"\n\t// \"doubleAccounting\"\n)\n\n// RichTextColor is the color of the RichTextRun.\ntype RichTextColor struct {\n\tcoreColor xlsxColor\n}\n\n// NewRichTextColorFromARGB creates a new RichTextColor from ARGB component values.\n// Each component must have a value in range of 0 to 255.\nfunc NewRichTextColorFromARGB(alpha, red, green, blue int) *RichTextColor {\n\targb := fmt.Sprintf(\"%02X%02X%02X%02X\", alpha, red, green, blue)\n\treturn &RichTextColor{coreColor: xlsxColor{RGB: argb}}\n}\n\n// NewRichTextColorFromThemeColor creates a new RichTextColor from the theme color.\n// The argument `themeColor` is a zero-based index of the theme color.\nfunc NewRichTextColorFromThemeColor(themeColor int) *RichTextColor {\n\treturn &RichTextColor{coreColor: xlsxColor{Theme: &themeColor}}\n}\n\n// RichTextFont is the font spec of the RichTextRun.\ntype RichTextFont struct {\n\t// Name is the font name. If Name is empty, Size, Family and Charset will be ignored.\n\tName string\n\t// Size is the font size.\n\tSize float64\n\t// Family is a value of the font family. Use one of the RichTextFontFamily constants.\n\tFamily RichTextFontFamily\n\t// Charset is a value of the charset of the font. Use one of the RichTextCharset constants.\n\tCharset RichTextCharset\n\t// Color is the text color.\n\tColor *RichTextColor\n\t// Bold specifies the bold face font style.\n\tBold bool\n\t// Italic specifies the italic font style.\n\tItalic bool\n\t// Strike specifies a strikethrough line.\n\tStrike bool\n\t// VertAlign specifies the vertical position of the text. Use one of the RichTextVertAlign constants, or empty.\n\tVertAlign RichTextVertAlign\n\t// Underline specifies the underline style. Use one of the RichTextUnderline constants, or empty.\n\tUnderline RichTextUnderline\n}\n\n// RichTextRun is a run of the decorated text.\ntype RichTextRun struct {\n\tFont *RichTextFont\n\tText string\n}\n\nfunc (rt *RichTextRun) Equals(other *RichTextRun) bool {\n\treturn reflect.DeepEqual(rt, other)\n}\n\nfunc richTextToXml(r []RichTextRun) []xlsxR {\n\tvar xrs []xlsxR\n\tfor _, rt := range r {\n\t\txr := xlsxR{}\n\t\txr.T = xlsxT{Text: rt.Text}\n\t\tif rt.Font != nil {\n\t\t\trpr := xlsxRunProperties{}\n\t\t\tif len(rt.Font.Name) > 0 {\n\t\t\t\trpr.RFont = &xlsxVal{Val: rt.Font.Name}\n\t\t\t}\n\t\t\tif rt.Font.Size > 0.0 {\n\t\t\t\trpr.Sz = &xlsxFloatVal{Val: rt.Font.Size}\n\t\t\t}\n\t\t\tif rt.Font.Family != RichTextFontFamilyUnspecified {\n\t\t\t\trpr.Family = &xlsxIntVal{Val: int(rt.Font.Family)}\n\t\t\t}\n\t\t\tif rt.Font.Charset != RichTextCharsetUnspecified {\n\t\t\t\trpr.Charset = &xlsxIntVal{Val: int(rt.Font.Charset)}\n\t\t\t}\n\t\t\tif rt.Font.Color != nil {\n\t\t\t\txcolor := rt.Font.Color.coreColor\n\t\t\t\trpr.Color = &xcolor\n\t\t\t}\n\t\t\tif rt.Font.Bold {\n\t\t\t\trpr.B.Val = true\n\t\t\t}\n\t\t\tif rt.Font.Italic {\n\t\t\t\trpr.I.Val = true\n\t\t\t}\n\t\t\tif rt.Font.Strike {\n\t\t\t\trpr.Strike.Val = true\n\t\t\t}\n\t\t\tif len(rt.Font.VertAlign) > 0 {\n\t\t\t\trpr.VertAlign = &xlsxVal{Val: string(rt.Font.VertAlign)}\n\t\t\t}\n\t\t\tif len(rt.Font.Underline) > 0 {\n\t\t\t\trpr.U = &xlsxVal{Val: string(rt.Font.Underline)}\n\t\t\t}\n\t\t\txr.RPr = &rpr\n\t\t}\n\t\txrs = append(xrs, xr)\n\t}\n\treturn xrs\n}\n\nfunc xmlToRichText(r []xlsxR) []RichTextRun {\n\trichiText := []RichTextRun(nil)\n\tfor _, rr := range r {\n\t\trtr := RichTextRun{Text: rr.T.Text}\n\t\trpr := rr.RPr\n\t\tif rpr != nil {\n\t\t\trtr.Font = &RichTextFont{}\n\t\t\tif rpr.RFont != nil {\n\t\t\t\trtr.Font.Name = rpr.RFont.Val\n\t\t\t}\n\t\t\tif rpr.Sz != nil {\n\t\t\t\trtr.Font.Size = rpr.Sz.Val\n\t\t\t}\n\t\t\tif rpr.Family != nil {\n\t\t\t\trtr.Font.Family = RichTextFontFamily(rpr.Family.Val)\n\t\t\t} else {\n\t\t\t\trtr.Font.Family = RichTextFontFamilyUnspecified\n\t\t\t}\n\t\t\tif rpr.Charset != nil {\n\t\t\t\trtr.Font.Charset = RichTextCharset(rpr.Charset.Val)\n\t\t\t} else {\n\t\t\t\trtr.Font.Charset = RichTextCharsetUnspecified\n\t\t\t}\n\t\t\tif rpr.Color != nil {\n\t\t\t\trtr.Font.Color = &RichTextColor{coreColor: *rpr.Color}\n\t\t\t}\n\t\t\tif rpr.B.Val {\n\t\t\t\trtr.Font.Bold = true\n\t\t\t}\n\t\t\tif rpr.I.Val {\n\t\t\t\trtr.Font.Italic = true\n\t\t\t}\n\t\t\tif rpr.Strike.Val {\n\t\t\t\trtr.Font.Strike = true\n\t\t\t}\n\t\t\tif rpr.VertAlign != nil {\n\t\t\t\trtr.Font.VertAlign = RichTextVertAlign(rpr.VertAlign.Val)\n\t\t\t}\n\t\t\tif rpr.U != nil {\n\t\t\t\trtr.Font.Underline = RichTextUnderline(rpr.U.Val)\n\t\t\t}\n\t\t}\n\t\trichiText = append(richiText, rtr)\n\t}\n\treturn richiText\n}\n\nfunc richTextToPlainText(richText []RichTextRun) string {\n\tvar s string\n\tfor _, r := range richText {\n\t\ts += r.Text\n\t}\n\treturn s\n}\n"
        },
        {
          "name": "richtext_test.go",
          "type": "blob",
          "size": 11.076171875,
          "content": "package xlsx\n\nimport (\n\t\"testing\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\nfunc TestNewRichTextColorFromARGB(t *testing.T) {\n\tc := qt.New(t)\n\trtColor := NewRichTextColorFromARGB(127, 128, 129, 130)\n\tc.Assert(rtColor.coreColor.RGB, qt.Equals, \"7F808182\")\n}\n\nfunc TestNewRichTextColorFromThemeColor(t *testing.T) {\n\tc := qt.New(t)\n\trtColor := NewRichTextColorFromThemeColor(123)\n\tc.Assert(*rtColor.coreColor.Theme, qt.Equals, 123)\n}\n\nfunc TestRichTextRunEquals(t *testing.T) {\n\tc := qt.New(t)\n\tr1color := 1\n\tr1 := &RichTextRun{\n\t\tFont: &RichTextFont{\n\t\t\tFamily:  RichTextFontFamilyUnspecified,\n\t\t\tCharset: RichTextCharsetUnspecified,\n\t\t\tColor:   &RichTextColor{coreColor: xlsxColor{Theme: &r1color}},\n\t\t\tBold:    true,\n\t\t\tItalic:  true,\n\t\t},\n\t\tText: \"X\",\n\t}\n\n\tr2color := r1color\n\tr2 := &RichTextRun{ // same with r1\n\t\tFont: &RichTextFont{\n\t\t\tFamily:  RichTextFontFamilyUnspecified,\n\t\t\tCharset: RichTextCharsetUnspecified,\n\t\t\tColor:   &RichTextColor{coreColor: xlsxColor{Theme: &r2color}},\n\t\t\tBold:    true,\n\t\t\tItalic:  true,\n\t\t},\n\t\tText: \"X\",\n\t}\n\n\tr3color := r1color\n\tr3 := &RichTextRun{ // different font setting from r1\n\t\tFont: &RichTextFont{\n\t\t\tFamily:  RichTextFontFamilyUnspecified,\n\t\t\tCharset: RichTextCharsetUnspecified,\n\t\t\tColor:   &RichTextColor{coreColor: xlsxColor{Theme: &r3color}},\n\t\t\tBold:    true,\n\t\t\tItalic:  false,\n\t\t},\n\t\tText: \"X\",\n\t}\n\n\tr4color := 2\n\tr4 := &RichTextRun{ // different color setting from r1\n\t\tFont: &RichTextFont{\n\t\t\tFamily:  RichTextFontFamilyUnspecified,\n\t\t\tCharset: RichTextCharsetUnspecified,\n\t\t\tColor:   &RichTextColor{coreColor: xlsxColor{Theme: &r4color}},\n\t\t\tBold:    true,\n\t\t\tItalic:  true,\n\t\t},\n\t\tText: \"X\",\n\t}\n\n\tr5 := &RichTextRun{ // no font setting\n\t\tText: \"X\",\n\t}\n\n\tr6color := r1color\n\tr6 := &RichTextRun{ // different text from r1\n\t\tFont: &RichTextFont{\n\t\t\tFamily:  RichTextFontFamilyUnspecified,\n\t\t\tCharset: RichTextCharsetUnspecified,\n\t\t\tColor:   &RichTextColor{coreColor: xlsxColor{Theme: &r6color}},\n\t\t\tBold:    true,\n\t\t\tItalic:  true,\n\t\t},\n\t\tText: \"Y\",\n\t}\n\n\tvar r7 *RichTextRun = nil\n\n\tc.Assert(r1.Equals(r2), qt.Equals, true)\n\tc.Assert(r1.Equals(r3), qt.Equals, false)\n\tc.Assert(r1.Equals(r4), qt.Equals, false)\n\tc.Assert(r1.Equals(r5), qt.Equals, false)\n\tc.Assert(r1.Equals(r6), qt.Equals, false)\n\tc.Assert(r1.Equals(r7), qt.Equals, false)\n\n\tc.Assert(r2.Equals(r1), qt.Equals, true)\n\tc.Assert(r3.Equals(r1), qt.Equals, false)\n\tc.Assert(r4.Equals(r1), qt.Equals, false)\n\tc.Assert(r5.Equals(r1), qt.Equals, false)\n\tc.Assert(r6.Equals(r1), qt.Equals, false)\n\tc.Assert(r7.Equals(r1), qt.Equals, false)\n\n\tc.Assert(r7.Equals(nil), qt.Equals, true)\n}\n\nfunc TestRichTextToXml(t *testing.T) {\n\tc := qt.New(t)\n\trtr := []RichTextRun{\n\t\t{\n\t\t\tFont: &RichTextFont{\n\t\t\t\tName:      \"Font\",\n\t\t\t\tSize:      12.345,\n\t\t\t\tFamily:    RichTextFontFamilyScript,\n\t\t\t\tCharset:   RichTextCharsetHebrew,\n\t\t\t\tColor:     &RichTextColor{coreColor: xlsxColor{RGB: \"DEADBEEF\"}},\n\t\t\t\tBold:      true,\n\t\t\t\tItalic:    false,\n\t\t\t\tStrike:    false,\n\t\t\t\tVertAlign: RichTextVertAlignSuperscript,\n\t\t\t\tUnderline: RichTextUnderlineSingle,\n\t\t\t},\n\t\t\tText: \"Bold\",\n\t\t},\n\t\t{\n\t\t\tFont: &RichTextFont{\n\t\t\t\tFamily:  RichTextFontFamilyUnspecified,\n\t\t\t\tCharset: RichTextCharsetUnspecified,\n\t\t\t\tItalic:  true,\n\t\t\t},\n\t\t\tText: \"Italic\",\n\t\t},\n\t\t{\n\t\t\tFont: &RichTextFont{\n\t\t\t\tFamily:  RichTextFontFamilyUnspecified,\n\t\t\t\tCharset: RichTextCharsetUnspecified,\n\t\t\t\tStrike:  true,\n\t\t\t},\n\t\t\tText: \"Strike\",\n\t\t},\n\t\t{\n\t\t\tFont: &RichTextFont{},\n\t\t\tText: \"Empty\",\n\t\t},\n\t\t{\n\t\t\tText: \"No Font\",\n\t\t},\n\t}\n\n\txmlr := richTextToXml(rtr)\n\tc.Assert(xmlr, qt.HasLen, 5)\n\n\tr := xmlr[0]\n\tc.Assert(r.RPr.RFont.Val, qt.Equals, \"Font\")\n\tc.Assert(r.RPr.Charset.Val, qt.Equals, int(RichTextCharsetHebrew))\n\tc.Assert(r.RPr.Family.Val, qt.Equals, int(RichTextFontFamilyScript))\n\tc.Assert(r.RPr.B.Val, qt.Equals, true)\n\tc.Assert(r.RPr.I.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Strike.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Outline.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Shadow.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Condense.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Extend.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Color.RGB, qt.Equals, \"DEADBEEF\")\n\tc.Assert(r.RPr.Sz.Val, qt.Equals, 12.345)\n\tc.Assert(r.RPr.U.Val, qt.Equals, string(RichTextUnderlineSingle))\n\tc.Assert(r.RPr.VertAlign.Val, qt.Equals, string(RichTextVertAlignSuperscript))\n\tc.Assert(r.RPr.Scheme, qt.IsNil)\n\tc.Assert(r.T.Text, qt.Equals, \"Bold\")\n\n\tr = xmlr[1]\n\tc.Assert(r.RPr.RFont, qt.IsNil)\n\tc.Assert(r.RPr.Charset, qt.IsNil)\n\tc.Assert(r.RPr.Family, qt.IsNil)\n\tc.Assert(r.RPr.B.Val, qt.Equals, false)\n\tc.Assert(r.RPr.I.Val, qt.Equals, true)\n\tc.Assert(r.RPr.Strike.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Outline.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Shadow.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Condense.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Extend.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Color, qt.IsNil)\n\tc.Assert(r.RPr.Sz, qt.IsNil)\n\tc.Assert(r.RPr.U, qt.IsNil)\n\tc.Assert(r.RPr.VertAlign, qt.IsNil)\n\tc.Assert(r.RPr.Scheme, qt.IsNil)\n\tc.Assert(r.T.Text, qt.Equals, \"Italic\")\n\n\tr = xmlr[2]\n\tc.Assert(r.RPr.RFont, qt.IsNil)\n\tc.Assert(r.RPr.Charset, qt.IsNil)\n\tc.Assert(r.RPr.Family, qt.IsNil)\n\tc.Assert(r.RPr.B.Val, qt.Equals, false)\n\tc.Assert(r.RPr.I.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Strike.Val, qt.Equals, true)\n\tc.Assert(r.RPr.Outline.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Shadow.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Condense.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Extend.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Color, qt.IsNil)\n\tc.Assert(r.RPr.Sz, qt.IsNil)\n\tc.Assert(r.RPr.U, qt.IsNil)\n\tc.Assert(r.RPr.VertAlign, qt.IsNil)\n\tc.Assert(r.RPr.Scheme, qt.IsNil)\n\tc.Assert(r.T.Text, qt.Equals, \"Strike\")\n\n\tr = xmlr[3]\n\tc.Assert(r.RPr.RFont, qt.IsNil)\n\tc.Assert(r.RPr.Charset.Val, qt.Equals, int(RichTextCharsetANSI))\n\tc.Assert(r.RPr.Family.Val, qt.Equals, int(RichTextFontFamilyNotApplicable))\n\tc.Assert(r.RPr.B.Val, qt.Equals, false)\n\tc.Assert(r.RPr.I.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Strike.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Outline.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Shadow.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Condense.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Extend.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Color, qt.IsNil)\n\tc.Assert(r.RPr.Sz, qt.IsNil)\n\tc.Assert(r.RPr.U, qt.IsNil)\n\tc.Assert(r.RPr.VertAlign, qt.IsNil)\n\tc.Assert(r.RPr.Scheme, qt.IsNil)\n\tc.Assert(r.T.Text, qt.Equals, \"Empty\")\n\n\tr = xmlr[4]\n\tc.Assert(r.RPr, qt.IsNil)\n\tc.Assert(r.T.Text, qt.Equals, \"No Font\")\n}\n\nfunc TestXmlToRichText(t *testing.T) {\n\tc := qt.New(t)\n\txmlr := []xlsxR{\n\t\t{\n\t\t\tRPr: &xlsxRunProperties{\n\t\t\t\tRFont:     &xlsxVal{Val: \"Font\"},\n\t\t\t\tCharset:   &xlsxIntVal{Val: int(RichTextCharsetGreek)},\n\t\t\t\tFamily:    &xlsxIntVal{Val: int(RichTextFontFamilySwiss)},\n\t\t\t\tB:         xlsxBoolProp{Val: true},\n\t\t\t\tI:         xlsxBoolProp{Val: false},\n\t\t\t\tStrike:    xlsxBoolProp{Val: false},\n\t\t\t\tOutline:   xlsxBoolProp{Val: false},\n\t\t\t\tShadow:    xlsxBoolProp{Val: false},\n\t\t\t\tCondense:  xlsxBoolProp{Val: false},\n\t\t\t\tExtend:    xlsxBoolProp{Val: false},\n\t\t\t\tColor:     &xlsxColor{RGB: \"DEADBEEF\"},\n\t\t\t\tSz:        &xlsxFloatVal{Val: 12.345},\n\t\t\t\tU:         &xlsxVal{Val: string(RichTextUnderlineDouble)},\n\t\t\t\tVertAlign: &xlsxVal{Val: string(RichTextVertAlignSuperscript)},\n\t\t\t\tScheme:    nil,\n\t\t\t},\n\t\t\tT: xlsxT{Text: \"Bold\"},\n\t\t},\n\t\t{\n\t\t\tRPr: &xlsxRunProperties{\n\t\t\t\tRFont:     nil,\n\t\t\t\tCharset:   nil,\n\t\t\t\tFamily:    nil,\n\t\t\t\tB:         xlsxBoolProp{Val: false},\n\t\t\t\tI:         xlsxBoolProp{Val: true},\n\t\t\t\tStrike:    xlsxBoolProp{Val: false},\n\t\t\t\tOutline:   xlsxBoolProp{Val: false},\n\t\t\t\tShadow:    xlsxBoolProp{Val: false},\n\t\t\t\tCondense:  xlsxBoolProp{Val: false},\n\t\t\t\tExtend:    xlsxBoolProp{Val: false},\n\t\t\t\tColor:     nil,\n\t\t\t\tSz:        nil,\n\t\t\t\tU:         nil,\n\t\t\t\tVertAlign: nil,\n\t\t\t\tScheme:    nil,\n\t\t\t},\n\t\t\tT: xlsxT{Text: \"Italic\"},\n\t\t},\n\t\t{\n\t\t\tRPr: &xlsxRunProperties{\n\t\t\t\tRFont:     nil,\n\t\t\t\tCharset:   nil,\n\t\t\t\tFamily:    nil,\n\t\t\t\tB:         xlsxBoolProp{Val: false},\n\t\t\t\tI:         xlsxBoolProp{Val: false},\n\t\t\t\tStrike:    xlsxBoolProp{Val: true},\n\t\t\t\tOutline:   xlsxBoolProp{Val: false},\n\t\t\t\tShadow:    xlsxBoolProp{Val: false},\n\t\t\t\tCondense:  xlsxBoolProp{Val: false},\n\t\t\t\tExtend:    xlsxBoolProp{Val: false},\n\t\t\t\tColor:     nil,\n\t\t\t\tSz:        nil,\n\t\t\t\tU:         nil,\n\t\t\t\tVertAlign: nil,\n\t\t\t\tScheme:    nil,\n\t\t\t},\n\t\t\tT: xlsxT{Text: \"Strike\"},\n\t\t},\n\t\t{\n\t\t\tRPr: &xlsxRunProperties{},\n\t\t\tT:   xlsxT{Text: \"Empty\"},\n\t\t},\n\t\t{\n\t\t\tRPr: nil,\n\t\t\tT:   xlsxT{Text: \"No Font\"},\n\t\t},\n\t}\n\n\trtr := xmlToRichText(xmlr)\n\tc.Assert(rtr, qt.HasLen, 5)\n\n\tr := rtr[0]\n\tc.Assert(r.Font.Name, qt.Equals, \"Font\")\n\tc.Assert(r.Font.Size, qt.Equals, 12.345)\n\tc.Assert(r.Font.Family, qt.Equals, RichTextFontFamilySwiss)\n\tc.Assert(r.Font.Charset, qt.Equals, RichTextCharsetGreek)\n\tc.Assert(r.Font.Color.coreColor.RGB, qt.Equals, \"DEADBEEF\")\n\tc.Assert(r.Font.Bold, qt.Equals, true)\n\tc.Assert(r.Font.Italic, qt.Equals, false)\n\tc.Assert(r.Font.Strike, qt.Equals, false)\n\tc.Assert(r.Font.VertAlign, qt.Equals, RichTextVertAlignSuperscript)\n\tc.Assert(r.Font.Underline, qt.Equals, RichTextUnderlineDouble)\n\tc.Assert(r.Text, qt.Equals, \"Bold\")\n\n\tr = rtr[1]\n\tc.Assert(r.Font.Name, qt.Equals, \"\")\n\tc.Assert(r.Font.Size, qt.Equals, 0.0)\n\tc.Assert(r.Font.Family, qt.Equals, RichTextFontFamilyUnspecified)\n\tc.Assert(r.Font.Charset, qt.Equals, RichTextCharsetUnspecified)\n\tc.Assert(r.Font.Color, qt.IsNil)\n\tc.Assert(r.Font.Bold, qt.Equals, false)\n\tc.Assert(r.Font.Italic, qt.Equals, true)\n\tc.Assert(r.Font.Strike, qt.Equals, false)\n\tc.Assert(r.Font.VertAlign, qt.Equals, RichTextVertAlign(\"\"))\n\tc.Assert(r.Font.Underline, qt.Equals, RichTextUnderline(\"\"))\n\tc.Assert(r.Text, qt.Equals, \"Italic\")\n\n\tr = rtr[2]\n\tc.Assert(r.Font.Name, qt.Equals, \"\")\n\tc.Assert(r.Font.Size, qt.Equals, 0.0)\n\tc.Assert(r.Font.Family, qt.Equals, RichTextFontFamilyUnspecified)\n\tc.Assert(r.Font.Charset, qt.Equals, RichTextCharsetUnspecified)\n\tc.Assert(r.Font.Color, qt.IsNil)\n\tc.Assert(r.Font.Bold, qt.Equals, false)\n\tc.Assert(r.Font.Italic, qt.Equals, false)\n\tc.Assert(r.Font.Strike, qt.Equals, true)\n\tc.Assert(r.Font.VertAlign, qt.Equals, RichTextVertAlign(\"\"))\n\tc.Assert(r.Font.Underline, qt.Equals, RichTextUnderline(\"\"))\n\tc.Assert(r.Text, qt.Equals, \"Strike\")\n\n\tr = rtr[3]\n\tc.Assert(r.Font.Name, qt.Equals, \"\")\n\tc.Assert(r.Font.Size, qt.Equals, 0.0)\n\tc.Assert(r.Font.Family, qt.Equals, RichTextFontFamilyUnspecified)\n\tc.Assert(r.Font.Charset, qt.Equals, RichTextCharsetUnspecified)\n\tc.Assert(r.Font.Color, qt.IsNil)\n\tc.Assert(r.Font.Bold, qt.Equals, false)\n\tc.Assert(r.Font.Italic, qt.Equals, false)\n\tc.Assert(r.Font.Strike, qt.Equals, false)\n\tc.Assert(r.Font.VertAlign, qt.Equals, RichTextVertAlign(\"\"))\n\tc.Assert(r.Font.Underline, qt.Equals, RichTextUnderline(\"\"))\n\tc.Assert(r.Text, qt.Equals, \"Empty\")\n\n\tr = rtr[4]\n\tc.Assert(r.Font, qt.IsNil)\n\tc.Assert(r.Text, qt.Equals, \"No Font\")\n}\n\nfunc TestRichTextToPlainText(t *testing.T) {\n\tc := qt.New(t)\n\trt := []RichTextRun{\n\t\t{\n\t\t\tFont: &RichTextFont{\n\t\t\t\tBold: true,\n\t\t\t},\n\t\t\tText: \"Bold\",\n\t\t},\n\t\t{\n\t\t\tFont: &RichTextFont{\n\t\t\t\tItalic: true,\n\t\t\t},\n\t\t\tText: \"Italic\",\n\t\t},\n\t\t{\n\t\t\tFont: &RichTextFont{\n\t\t\t\tStrike: true,\n\t\t\t},\n\t\t\tText: \"Strike\",\n\t\t},\n\t}\n\tplainText := richTextToPlainText(rt)\n\tc.Assert(plainText, qt.Equals, \"BoldItalicStrike\")\n}\n\nfunc TestRichTextToPlainTextEmpty(t *testing.T) {\n\tc := qt.New(t)\n\trt := []RichTextRun{}\n\tplainText := richTextToPlainText(rt)\n\tc.Assert(plainText, qt.Equals, \"\")\n}\n"
        },
        {
          "name": "row.go",
          "type": "blob",
          "size": 4.1318359375,
          "content": "package xlsx\n\nimport (\n\t\"fmt\"\n)\n\n// Row represents a single Row in the current Sheet.\ntype Row struct {\n\tHidden       bool         // Hidden determines whether this Row is hidden or not.\n\tSheet        *Sheet       // Sheet is a reference back to the Sheet that this Row is within.\n\theight       float64      // Height is the current height of the Row in PostScript Points\n\toutlineLevel uint8        // OutlineLevel contains the outline level of this Row.  Used for collapsing.\n\tisCustom     bool         // isCustom is a flag that is set to true when the Row has been modified\n\tcustomHeight bool         // customHeight is a flag to let the writer know that this row has a custom height\n\tnum          int          // Num hold the positional number of the Row in the Sheet\n\tcellStoreRow CellStoreRow // A reference to the underlying CellStoreRow which handles persistence of the cells\n}\n\n// GetCoordinate returns the y coordinate of the row (the row number). This number is zero based, i.e. the Excel CellID \"A1\" is in Row 0, not Row 1.\nfunc (r *Row) GetCoordinate() int {\n\treturn r.num\n}\n\n// setHeight internally sets the \"height\" value for a row along with letting\n// the row object know that there is a custom height for this row\nfunc (r *Row) setHeight(ht float64) {\n\tr.cellStoreRow.Updatable()\n\tr.height = ht\n\tr.customHeight = true\n}\n\n// SetHeight sets the height of the Row in PostScript points\nfunc (r *Row) SetHeight(ht float64) {\n\tr.setHeight(ht)\n\tr.isCustom = true\n}\n\nconst cmToPs = 28.3464567\n\n// SetHeightCM sets the height of the Row in centimetres, inherently converting it to PostScript points.\nfunc (r *Row) SetHeightCM(ht float64) {\n\tr.setHeight(ht * cmToPs) // Convert CM to postscript points\n\tr.isCustom = true\n}\n\n// GetHeight returns the height of the Row in PostScript points.\nfunc (r *Row) GetHeight() float64 {\n\treturn r.height\n}\n\n// SetOutlineLevel sets the outline level of the Row (used for collapsing rows)\nfunc (r *Row) SetOutlineLevel(outlineLevel uint8) {\n\tr.cellStoreRow.Updatable()\n\tr.outlineLevel = outlineLevel\n\tif r.Sheet != nil {\n\t\tif r.outlineLevel > r.Sheet.SheetFormat.OutlineLevelRow {\n\t\t\tr.Sheet.SheetFormat.OutlineLevelRow = outlineLevel\n\t\t}\n\t}\n\tr.isCustom = true\n}\n\n// GetOutlineLevel returns the outline level of the Row.\nfunc (r *Row) GetOutlineLevel() uint8 {\n\treturn r.outlineLevel\n}\n\n// AddCell adds a new Cell to the end of the Row\nfunc (r *Row) AddCell() *Cell {\n\tr.cellStoreRow.Updatable()\n\tr.isCustom = true\n\tcell := r.cellStoreRow.AddCell()\n\tif cell.num > r.Sheet.MaxCol-1 {\n\t\tr.Sheet.MaxCol = cell.num + 1\n\t}\n\treturn cell\n}\n\n// PushCell adds a predefiend cell to the end of the Row\nfunc (r *Row) PushCell(c *Cell) {\n\tr.cellStoreRow.Updatable()\n\tr.isCustom = true\n\tr.cellStoreRow.PushCell(c)\n}\n\nfunc (r *Row) makeCellKey(colIdx int) string {\n\treturn fmt.Sprintf(\"%s:%06d:%06d\", r.Sheet.Name, r.num, colIdx)\n}\n\nfunc (r *Row) key() string {\n\treturn r.makeCellKeyRowPrefix()\n}\n\nfunc (r *Row) makeCellKeyRowPrefix() string {\n\treturn fmt.Sprintf(\"%s:%06d\", r.Sheet.Name, r.num)\n}\n\n// GetCell returns the Cell at a given column index, creating it if it doesn't exist.\nfunc (r *Row) GetCell(colIdx int) *Cell {\n\treturn r.cellStoreRow.GetCell(colIdx)\n}\n\n// cellVisitorFlags contains flags that can be set by CellVisitorOption implementations to modify the behaviour of ForEachCell.\ntype cellVisitorFlags struct {\n\t// skipEmptyCells indicates if we should skip nil cells.\n\tskipEmptyCells bool\n}\n\n// CellVisitorOption is an option for [Row.ForEachCell].\n//\n// Available options: [SkipEmptyCells].\ntype CellVisitorOption func(flags *cellVisitorFlags)\n\n// SkipEmptyCells can be passed as an option to [Row.ForEachCell] in\n// order to make it skip over empty cells in the sheet.\nfunc SkipEmptyCells(flags *cellVisitorFlags) {\n\tflags.skipEmptyCells = true\n}\n\n// ForEachCell will call the provided [CellVisitorFunc] for each\n// currently defined cell in the Row.  Optionally you may pass one or\n// more [CellVisitorOption] to affect how ForEachCell operates.  For\n// example you may wish to pass [SkipEmptyCells] to only visit cells\n// which are populated.\nfunc (r *Row) ForEachCell(cvf CellVisitorFunc, option ...CellVisitorOption) error {\n\treturn r.cellStoreRow.ForEachCell(cvf, option...)\n}\n"
        },
        {
          "name": "row_test.go",
          "type": "blob",
          "size": 2.6923828125,
          "content": "package xlsx\n\nimport (\n\t\"testing\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\nfunc TestRow(t *testing.T) {\n\tc := qt.New(t)\n\t// Test we can add a new Cell to a Row\n\tcsRunO(c, \"TestAddCell\", func(c *qt.C, option FileOption) {\n\t\tf := NewFile(option)\n\t\tsheet, _ := f.AddSheet(\"MySheet\")\n\t\trow := sheet.AddRow()\n\t\tcell := row.AddCell()\n\t\tc.Assert(cell, qt.Not(qt.IsNil))\n\t\tc.Assert(row.Sheet.MaxCol, qt.Equals, 1)\n\t\tc.Assert(row.cellStoreRow.CellCount(), qt.Equals, 1)\n\t})\n\n\tcsRunO(c, \"TestGetCell\", func(c *qt.C, option FileOption) {\n\t\tf := NewFile(option)\n\t\tsheet, _ := f.AddSheet(\"MySheet\")\n\t\trow := sheet.AddRow()\n\t\tcell := row.AddCell()\n\t\tcell.SetValue(\"foo\")\n\t\tcell1 := row.AddCell()\n\t\tcell1.SetValue(\"bar\")\n\n\t\tcell2 := row.GetCell(0)\n\t\tc.Assert(cell.Value, qt.Equals, cell2.Value)\n\t})\n\n\tcsRunO(c, \"TestForEachCell\", func(c *qt.C, option FileOption) {\n\t\tvar f *File\n\t\tf, err := OpenFile(\"./testdocs/empty_cells.xlsx\", option)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tsheet := f.Sheets[0]\n\t\tc.Run(\"NoOptions\", func(c *qt.C) {\n\t\t\toutput := [][]string{}\n\t\t\terr := sheet.ForEachRow(func(r *Row) error {\n\t\t\t\tcells := []string{}\n\t\t\t\terr := r.ForEachCell(func(c *Cell) error {\n\t\t\t\t\tcells = append(cells, c.Value)\n\t\t\t\t\treturn nil\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\toutput = append(output, cells)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tc.Assert(err, qt.Equals, nil)\n\t\t\tc.Assert(output, qt.DeepEquals, [][]string{\n\t\t\t\t{\"\", \"B1\", \"C1\", \"D1\"},\n\t\t\t\t{\"A2\", \"\", \"C2\", \"D2\"},\n\t\t\t\t{\"A3\", \"B3\", \"\", \"D3\"},\n\t\t\t\t{\"A4\", \"B4\", \"C4\", \"\"},\n\t\t\t})\n\t\t})\n\n\t\tc.Run(\"SkipEmptyCells\", func(c *qt.C) {\n\t\t\toutput := [][]string{}\n\t\t\terr := sheet.ForEachRow(func(r *Row) error {\n\t\t\t\tcells := []string{}\n\t\t\t\terr := r.ForEachCell(func(c *Cell) error {\n\t\t\t\t\tcells = append(cells, c.Value)\n\t\t\t\t\treturn nil\n\t\t\t\t}, SkipEmptyCells)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\toutput = append(output, cells)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tc.Assert(err, qt.Equals, nil)\n\t\t\tc.Assert(output, qt.DeepEquals,\n\t\t\t\t[][]string{\n\t\t\t\t\t{\"B1\", \"C1\", \"D1\"},\n\t\t\t\t\t{\"A2\", \"C2\", \"D2\"},\n\t\t\t\t\t{\"A3\", \"B3\", \"D3\"},\n\t\t\t\t\t{\"A4\", \"B4\", \"C4\"},\n\t\t\t\t})\n\t\t})\n\n\t})\n\n\tcsRunO(c, \"Test Set Height\", func(c *qt.C, option FileOption) {\n\t\tf := NewFile(option)\n\t\tsheet, _ := f.AddSheet(\"MySheet\")\n\t\trow := sheet.AddRow()\n\t\tc.Assert(row.height, qt.Equals, 0.0)\n\t\tc.Assert(row.GetHeight(), qt.Equals, 0.0)\n\t\tc.Assert(row.customHeight, qt.IsFalse)\n\t\tc.Assert(row.isCustom, qt.IsFalse)\n\n\t\tvar heightToSet float64 = 30.0\n\t\trow.SetHeight(heightToSet)\n\t\tc.Assert(row.GetHeight(), qt.Equals, heightToSet)\n\t\tc.Assert(row.customHeight, qt.IsTrue)\n\t\tc.Assert(row.isCustom, qt.IsTrue)\n\n\t\trow.SetHeightCM(heightToSet)\n\t\tc.Assert(row.GetHeight(), qt.Equals, heightToSet*cmToPs)\n\t\tc.Assert(row.customHeight, qt.IsTrue)\n\t\tc.Assert(row.isCustom, qt.IsTrue)\n\n\t})\n}\n"
        },
        {
          "name": "sheet.go",
          "type": "blob",
          "size": 25.91796875,
          "content": "package xlsx\n\nimport (\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode/utf8\"\n\n\t\"github.com/shabbyrobe/xmlwriter\"\n)\n\n// Sheet is a high level structure intended to provide user access to\n// the contents of a particular sheet within an XLSX file.\ntype Sheet struct {\n\tName            string\n\tFile            *File\n\tCols            *ColStore\n\tMaxRow          int\n\tMaxCol          int\n\tHidden          bool\n\tSelected        bool\n\tSheetViews      []SheetView\n\tSheetFormat     SheetFormat\n\tAutoFilter      *AutoFilter\n\tRelations       []Relation\n\tDataValidations []*xlsxDataValidation\n\tcellStore       CellStore\n\tcurrentRow      *Row\n\tcellStoreName   string // The first part of the key used in\n\t// the cellStore.  This name is stable,\n\t// unlike the Name, which can change\n}\n\n// NewSheet constructs a Sheet with the default CellStore and returns\n// a pointer to it.\nfunc NewSheet(name string) (*Sheet, error) {\n\treturn NewSheetWithCellStore(name, NewMemoryCellStore)\n}\n\n// NewSheetWithCellStore constructs a Sheet, backed by a CellStore,\n// for which you must provide the constructor function.\nfunc NewSheetWithCellStore(name string, constructor CellStoreConstructor) (*Sheet, error) {\n\tif err := IsSaneSheetName(name); err != nil {\n\t\treturn nil, fmt.Errorf(\"sheet name is invalid: %w\", err)\n\t}\n\tsheet := &Sheet{\n\t\tName:          name,\n\t\tCols:          &ColStore{},\n\t\tcellStoreName: name,\n\t}\n\tvar err error\n\tsheet.cellStore, err = constructor()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"NewSheetWithCellStore: %w\", err)\n\t}\n\treturn sheet, err\n\n}\n\n// Remove Sheet's dependant resources - if you are done with operations on a sheet this should be called to clear down the Sheet's persistent cache.  Note: if you call this, all further read operaton on the sheet will fail - including any attempt to save the file, or dump it's contents to a byte stream.  Therefore only call this *after* you've saved your changes, of when you're done reading a sheet in a file you don't plan to persist.\nfunc (s *Sheet) Close() {\n\ts.cellStore.Close()\n\ts.cellStore = nil\n}\n\nfunc (s *Sheet) getState() string {\n\tif s.Hidden {\n\t\treturn \"hidden\"\n\t}\n\treturn \"visible\"\n}\n\ntype SheetView struct {\n\tPane *Pane\n}\n\ntype Pane struct {\n\tXSplit      float64\n\tYSplit      float64\n\tTopLeftCell string\n\tActivePane  string\n\tState       string // Either \"split\" or \"frozen\"\n}\n\ntype SheetFormat struct {\n\tDefaultColWidth  float64\n\tDefaultRowHeight float64\n\tOutlineLevelCol  uint8\n\tOutlineLevelRow  uint8\n}\n\ntype AutoFilter struct {\n\tTopLeftCell     string\n\tBottomRightCell string\n}\n\ntype Relation struct {\n\tType       RelationshipType\n\tTarget     string\n\tTargetMode RelationshipTargetMode\n}\n\nfunc (s *Sheet) makeXLSXSheetRelations() *xlsxWorksheetRels {\n\trelSheet := xlsxWorksheetRels{XMLName: xml.Name{Local: \"Relationships\"}, Relationships: []xlsxWorksheetRelation{}}\n\tfor id, rel := range s.Relations {\n\t\txRel := xlsxWorksheetRelation{Id: \"rId\" + strconv.Itoa(id+1), Type: rel.Type, Target: rel.Target, TargetMode: rel.TargetMode}\n\t\trelSheet.Relationships = append(relSheet.Relationships, xRel)\n\t}\n\tif len(relSheet.Relationships) == 0 {\n\t\treturn nil\n\t}\n\treturn &relSheet\n}\n\nfunc (s *Sheet) addRelation(relType RelationshipType, target string, targetMode RelationshipTargetMode) {\n\tnewRel := Relation{Type: relType, Target: target, TargetMode: targetMode}\n\tfor _, rel := range s.Relations {\n\t\tif rel == newRel {\n\t\t\treturn\n\t\t}\n\t}\n\ts.Relations = append(s.Relations, newRel)\n}\n\nfunc (s *Sheet) setCurrentRow(r *Row) {\n\tif r != nil && r == s.currentRow {\n\t\treturn\n\t}\n\tif s.currentRow != nil && s.currentRow.isCustom {\n\t\terr := s.cellStore.WriteRow(s.currentRow)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\ts.currentRow = r\n}\n\n// rowVisitorFlags contains flags that can be set by a RowVisitorOption to affect the behaviour of sheet.ForEachRow\ntype rowVisitorFlags struct {\n\tskipEmptyRows bool\n}\n\n// RowVisitorOption defines the call signature of functions that can be passed as options to the Sheet.ForEachRow function to affect its behaviour.\ntype RowVisitorOption func(flags *rowVisitorFlags)\n\n// SkipEmptyRows can be passed to the Sheet.ForEachRow function to\n// cause it to skip over empty Rows.\nfunc SkipEmptyRows(flags *rowVisitorFlags) {\n\tflags.skipEmptyRows = true\n}\n\n// A RowVisitor function should be provided by the user when calling\n// Sheet.ForEachRow, it will be called once for every Row visited.\ntype RowVisitor func(r *Row) error\n\nfunc (s *Sheet) mustBeOpen() {\n\tif s.cellStore == nil {\n\t\tpanic(\"Attempt to iterate over sheet with no cellstore. Perhaps you called Close() on this sheet?\")\n\t}\n}\n\nfunc (s *Sheet) ForEachRow(rv RowVisitor, options ...RowVisitorOption) error {\n\ts.mustBeOpen()\n\tflags := &rowVisitorFlags{}\n\tfor _, opt := range options {\n\t\topt(flags)\n\t}\n\tif s.currentRow != nil {\n\t\terr := s.cellStore.WriteRow(s.currentRow)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor i := 0; i < s.MaxRow; i++ {\n\t\tr, err := s.cellStore.ReadRow(makeRowKey(s, i), s)\n\t\tif err != nil {\n\t\t\tif _, ok := err.(*RowNotFoundError); !ok {\n\t\t\t\treturn err\n\n\t\t\t}\n\t\t\tif flags.skipEmptyRows {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tr = s.cellStore.MakeRow(s)\n\t\t\tr.num = i\n\t\t}\n\t\tif r.cellStoreRow.CellCount() == 0 && flags.skipEmptyRows {\n\t\t\tcontinue\n\t\t}\n\t\tr.Sheet = s\n\t\ts.setCurrentRow(r)\n\t\terr = rv(r)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Add a new Row to a Sheet\nfunc (s *Sheet) AddRow() *Row {\n\ts.mustBeOpen()\n\t// NOTE - this is not safe to use concurrently\n\tif s.currentRow != nil {\n\t\ts.cellStore.WriteRow(s.currentRow)\n\t}\n\trow := s.cellStore.MakeRow(s)\n\trow.num = s.MaxRow\n\ts.MaxRow++\n\ts.setCurrentRow(row)\n\treturn row\n}\n\nfunc makeRowKey(s *Sheet, i int) string {\n\treturn fmt.Sprintf(\"%s:%06d\", s.cellStoreName, i)\n}\n\n// Add a new Row to a Sheet at a specific index\nfunc (s *Sheet) AddRowAtIndex(index int) (*Row, error) {\n\ts.mustBeOpen()\n\tif index < 0 || index > s.MaxRow {\n\t\treturn nil, errors.New(\"AddRowAtIndex: index out of bounds\")\n\t}\n\n\tif s.currentRow != nil {\n\t\ts.cellStore.WriteRow(s.currentRow)\n\t}\n\n\t// We move rows in reverse order to avoid overwriting anyting\n\tfor i := (s.MaxRow - 1); i >= index; i-- {\n\t\tnRow, err := s.cellStore.ReadRow(makeRowKey(s, i), s)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tnRow.Sheet = s\n\t\ts.setCurrentRow(nRow)\n\t\ts.cellStore.MoveRow(nRow, i+1)\n\t}\n\trow := s.cellStore.MakeRow(s)\n\trow.num = index\n\ts.setCurrentRow(row)\n\terr := s.cellStore.WriteRow(row)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts.MaxRow++\n\treturn row, nil\n}\n\n// Add a DataValidation to a range of cells\nfunc (s *Sheet) AddDataValidation(dv *xlsxDataValidation) {\n\ts.mustBeOpen()\n\ts.DataValidations = append(s.DataValidations, dv)\n}\n\n// Removes a row at a specific index\nfunc (s *Sheet) RemoveRowAtIndex(index int) error {\n\ts.mustBeOpen()\n\tif index < 0 || index >= s.MaxRow {\n\t\treturn fmt.Errorf(\"cannot remove row: index out of range: %d\", index)\n\t}\n\tif s.currentRow != nil {\n\t\ts.setCurrentRow(nil)\n\t}\n\terr := s.cellStore.RemoveRow(makeRowKey(s, index))\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor i := index + 1; i < s.MaxRow; i++ {\n\t\tnRow, err := s.cellStore.ReadRow(makeRowKey(s, i), s)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tnRow.Sheet = s\n\t\ts.cellStore.MoveRow(nRow, i-1)\n\t}\n\ts.MaxRow--\n\treturn nil\n}\n\n// Make sure we always have as many Rows as we do cells.\nfunc (s *Sheet) maybeAddRow(rowCount int) {\n\ts.mustBeOpen()\n\tif rowCount > s.MaxRow {\n\t\tloopCnt := rowCount - s.MaxRow\n\t\tfor i := 0; i < loopCnt; i++ {\n\t\t\trow := s.cellStore.MakeRow(s)\n\t\t\trow.num = s.MaxRow + i\n\t\t\ts.setCurrentRow(row)\n\t\t}\n\t\ts.MaxRow = rowCount\n\t}\n}\n\n// Make sure we always have as many Rows as we do cells.\nfunc (s *Sheet) Row(idx int) (*Row, error) {\n\ts.mustBeOpen()\n\n\ts.maybeAddRow(idx + 1)\n\tif s.currentRow != nil {\n\t\tif idx == s.currentRow.num {\n\t\t\treturn s.currentRow, nil\n\t\t}\n\t\ts.cellStore.WriteRow(s.currentRow)\n\t}\n\n\tr, err := s.cellStore.ReadRow(makeRowKey(s, idx), s)\n\tif err != nil {\n\t\tif _, ok := err.(*RowNotFoundError); !ok {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif r == nil {\n\t\tr = s.cellStore.MakeRow(s)\n\t\tr.num = idx\n\t} else {\n\t\tr.Sheet = s\n\t}\n\ts.setCurrentRow(r)\n\treturn r, nil\n}\n\n// Return the Col that applies to this Column index, or return nil if no such Col exists\n// Column numbers start from 1.\nfunc (s *Sheet) Col(idx int) *Col {\n\ts.mustBeOpen()\n\tif s.Cols == nil {\n\t\tpanic(\"trying to use uninitialised ColStore\")\n\t}\n\treturn s.Cols.FindColByIndex(idx + 1)\n}\n\n// Get a Cell by passing it's cartesian coordinates (zero based) as\n// row and column integer indexes.\n//\n// For example:\n//\n//\tcell := sheet.Cell(0,0)\n//\n// ... would set the variable \"cell\" to contain a Cell struct\n// containing the data from the field \"A1\" on the spreadsheet.\nfunc (s *Sheet) Cell(row, col int) (*Cell, error) {\n\ts.mustBeOpen()\n\t// If the user requests a row beyond what we have, then extend.\n\tfor s.MaxRow <= row {\n\t\ts.AddRow()\n\t}\n\n\tr, err := s.Row(row)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcell := r.GetCell(col)\n\tcell.Row = r\n\treturn cell, err\n}\n\n// Set the parameters of a column.  Parameters are passed as a pointer\n// to a Col structure which you much construct yourself.\n// Column numbers start from 1.\nfunc (s *Sheet) SetColParameters(col *Col) {\n\ts.mustBeOpen()\n\tif s.Cols == nil {\n\t\tpanic(\"trying to use uninitialised ColStore\")\n\t}\n\ts.Cols.Add(col)\n}\n\nfunc (s *Sheet) setCol(min, max int, setter func(col *Col)) {\n\ts.mustBeOpen()\n\tif s.Cols == nil {\n\t\tpanic(\"trying to use uninitialised ColStore\")\n\t}\n\n\tcols := s.Cols.getOrMakeColsForRange(s.Cols.Root, min, max)\n\n\tfor _, col := range cols {\n\t\tswitch {\n\t\tcase col.Min < min && col.Max > max:\n\t\t\t// The column completely envelops the range,\n\t\t\t// so we'll split it into three parts and only\n\t\t\t// set the width on the part within the range.\n\t\t\t// The ColStore will do most of this work for\n\t\t\t// us, we just need to create the new Col\n\t\t\t// based on the old one.\n\t\t\tnewCol := col.copyToRange(min, max)\n\t\t\tsetter(newCol)\n\t\t\ts.Cols.Add(newCol)\n\t\tcase col.Min < min:\n\t\t\t// If this column crosses the minimum boundary\n\t\t\t// of the range we must split it and only\n\t\t\t// apply the change within the range.  Again,\n\t\t\t// we can lean on the ColStore to deal with\n\t\t\t// the rest we just need to make the new\n\t\t\t// Col.\n\t\t\tnewCol := col.copyToRange(min, col.Max)\n\t\t\tsetter(newCol)\n\t\t\ts.Cols.Add(newCol)\n\t\tcase col.Max > max:\n\t\t\t// Likewise if a col definition crosses the\n\t\t\t// maximum boundary of the range, it must also\n\t\t\t// be split\n\t\t\tnewCol := col.copyToRange(col.Min, max)\n\t\t\tsetter(newCol)\n\t\t\ts.Cols.Add(newCol)\n\t\tdefault:\n\t\t\tnewCol := col.copyToRange(min, max)\n\t\t\tsetter(newCol)\n\t\t\ts.Cols.Add(newCol)\n\n\t\t}\n\t}\n}\n\n// Set the width of a range of columns.\n// Column numbers start from 1.\nfunc (s *Sheet) SetColWidth(min, max int, width float64) {\n\ts.mustBeOpen()\n\ts.setCol(min, max, func(col *Col) {\n\t\tcol.SetWidth(width)\n\t})\n}\n\n// This can be use as the default scale function for the autowidth.\n// It works well with the default font sizes.\nfunc DefaultAutoWidth(s string) float64 {\n\treturn (float64(strings.Count(s, \"\")) + 3.0) * 1.2\n}\n\n// Tries to guess the best width for a column, based on the largest\n// cell content. A scale function needs to be provided.\n// Column numbers start from 1.\nfunc (s *Sheet) SetColAutoWidth(colIndex int, width func(string) float64) error {\n\ts.mustBeOpen()\n\tlargestWidth := 0.0\n\trowVisitor := func(r *Row) error {\n\t\tcell := r.GetCell(colIndex - 1)\n\t\tvalue, err := cell.FormattedValue()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif width(value) > largestWidth {\n\t\t\tlargestWidth = width(value)\n\t\t}\n\t\treturn nil\n\t}\n\terr := s.ForEachRow(rowVisitor)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.SetColWidth(colIndex, colIndex, largestWidth)\n\n\treturn nil\n}\n\n// Set the outline level for a range of columns.\nfunc (s *Sheet) SetOutlineLevel(minCol, maxCol int, outlineLevel uint8) {\n\ts.mustBeOpen()\n\ts.setCol(minCol, maxCol, func(col *Col) {\n\t\tcol.SetOutlineLevel(outlineLevel)\n\t})\n}\n\n// Set the type for a range of columns.\nfunc (s *Sheet) SetType(minCol, maxCol int, cellType CellType) {\n\ts.mustBeOpen()\n\ts.setCol(minCol, maxCol, func(col *Col) {\n\t\tcol.SetType(cellType)\n\t})\n\n}\n\n// When merging cells, the cell may be the 'original' or the 'covered'.\n// First, figure out which cells are merge starting points. Then create\n// the necessary cells underlying the merge area.\n// Then go through all the underlying cells and apply the appropriate\n// border, based on the original cell.\nfunc (s *Sheet) handleMerged() {\n\tmerged := make(map[string]*Cell)\n\n\ts.ForEachRow(func(row *Row) error {\n\t\treturn row.ForEachCell(func(cell *Cell) error {\n\t\t\tif cell.HMerge > 0 || cell.VMerge > 0 {\n\t\t\t\tcoord := GetCellIDStringFromCoords(cell.num, row.num)\n\t\t\t\tmerged[coord] = cell\n\t\t\t}\n\t\t\treturn nil\n\t\t}, SkipEmptyCells)\n\n\t}, SkipEmptyRows)\n\n\t// This loop iterates over all cells that should be merged and applies the correct\n\t// borders to them depending on their position. If any cells required by the merge\n\t// are missing, they will be allocated by s.Cell().\n\tfor key, cell := range merged {\n\n\t\tmaincol, mainrow, _ := GetCoordsFromCellIDString(key)\n\t\tfor rownum := 0; rownum <= cell.VMerge; rownum++ {\n\t\t\tfor colnum := 0; colnum <= cell.HMerge; colnum++ {\n\t\t\t\t// make cell\n\t\t\t\ts.Cell(mainrow+rownum, maincol+colnum)\n\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (s *Sheet) makeSheetView(worksheet *xlsxWorksheet) {\n\tfor index, sheetView := range s.SheetViews {\n\t\tif sheetView.Pane != nil {\n\t\t\tworksheet.SheetViews.SheetView[index].Pane = &xlsxPane{\n\t\t\t\tXSplit:      sheetView.Pane.XSplit,\n\t\t\t\tYSplit:      sheetView.Pane.YSplit,\n\t\t\t\tTopLeftCell: sheetView.Pane.TopLeftCell,\n\t\t\t\tActivePane:  sheetView.Pane.ActivePane,\n\t\t\t\tState:       sheetView.Pane.State,\n\t\t\t}\n\n\t\t}\n\t}\n\tif s.Selected {\n\t\tworksheet.SheetViews.SheetView[0].TabSelected = true\n\t}\n\n}\n\nfunc (s *Sheet) makeSheetFormatPr(worksheet *xlsxWorksheet) {\n\tif s.SheetFormat.DefaultRowHeight != 0 {\n\t\tworksheet.SheetFormatPr.DefaultRowHeight = s.SheetFormat.DefaultRowHeight\n\t}\n\tworksheet.SheetFormatPr.DefaultColWidth = s.SheetFormat.DefaultColWidth\n}\n\nfunc (s *Sheet) makeCols(worksheet *xlsxWorksheet, styles *xlsxStyleSheet) (maxLevelCol uint8) {\n\ts.mustBeOpen()\n\tmaxLevelCol = 0\n\tif s.Cols == nil {\n\t\tpanic(\"trying to use uninitialised ColStore\")\n\t}\n\ts.Cols.ForEach(\n\t\tfunc(c int, col *Col) {\n\t\t\tXfId := 0\n\t\t\tstyle := col.GetStyle()\n\n\t\t\thasNumFmt := len(col.numFmt) > 0\n\t\t\tif hasNumFmt {\n\t\t\t\tif style == nil {\n\t\t\t\t\tstyle = NewStyle()\n\t\t\t\t}\n\n\t\t\t\txNumFmt := styles.newNumFmt(col.numFmt)\n\t\t\t\tXfId = handleStyleForXLSX(style, xNumFmt.NumFmtId, styles)\n\t\t\t} else {\n\t\t\t\tif style != nil {\n\t\t\t\t\tXfId = handleStyleForXLSX(style, 0, styles)\n\t\t\t\t}\n\t\t\t}\n\t\t\tcol.outXfID = XfId\n\n\t\t\t// When the cols content is empty, the cols flag is not output in the xml file.\n\t\t\tif worksheet.Cols == nil {\n\t\t\t\tworksheet.Cols = &xlsxCols{Col: []xlsxCol{}}\n\t\t\t}\n\t\t\tworksheet.Cols.Col = append(worksheet.Cols.Col,\n\t\t\t\txlsxCol{\n\t\t\t\t\tMin:          col.Min,\n\t\t\t\t\tMax:          col.Max,\n\t\t\t\t\tHidden:       col.Hidden,\n\t\t\t\t\tWidth:        col.Width,\n\t\t\t\t\tCustomWidth:  col.CustomWidth,\n\t\t\t\t\tCollapsed:    col.Collapsed,\n\t\t\t\t\tOutlineLevel: col.OutlineLevel,\n\t\t\t\t\tStyle:        &XfId,\n\t\t\t\t\tBestFit:      col.BestFit,\n\t\t\t\t\tPhonetic:     col.Phonetic,\n\t\t\t\t})\n\n\t\t\tif col.OutlineLevel != nil && *col.OutlineLevel > maxLevelCol {\n\t\t\t\tmaxLevelCol = *col.OutlineLevel\n\t\t\t}\n\t\t})\n\n\treturn maxLevelCol\n}\n\nfunc (s *Sheet) prepSheetForMarshalling(maxLevelCol uint8) {\n\ts.SheetFormat.OutlineLevelCol = maxLevelCol\n}\n\nfunc (s *Sheet) prepWorksheetFromRows(worksheet *xlsxWorksheet, relations *xlsxWorksheetRels) error {\n\ts.mustBeOpen()\n\tvar maxCell, maxRow int\n\n\tprepRow := func(row *Row) error {\n\t\tif row.num > maxRow {\n\t\t\tmaxRow = row.num\n\t\t}\n\n\t\tprepCell := func(cell *Cell) error {\n\t\t\tif cell.num > maxCell {\n\t\t\t\tmaxCell = cell.num\n\t\t\t}\n\t\t\tcellID := GetCellIDStringFromCoords(cell.num, row.num)\n\t\t\tif nil != cell.DataValidation {\n\t\t\t\tif nil == worksheet.DataValidations {\n\t\t\t\t\tworksheet.DataValidations = &xlsxDataValidations{}\n\t\t\t\t}\n\t\t\t\tcell.DataValidation.Sqref = cellID\n\t\t\t\tworksheet.DataValidations.DataValidation = append(worksheet.DataValidations.DataValidation, cell.DataValidation)\n\t\t\t\tworksheet.DataValidations.Count = len(worksheet.DataValidations.DataValidation)\n\t\t\t}\n\n\t\t\tif cell.Hyperlink != (Hyperlink{}) {\n\t\t\t\tif worksheet.Hyperlinks == nil {\n\t\t\t\t\tworksheet.Hyperlinks = &xlsxHyperlinks{HyperLinks: []xlsxHyperlink{}}\n\t\t\t\t}\n\n\t\t\t\tvar relId string\n\t\t\t\tif relations != nil && relations.Relationships != nil {\n\t\t\t\t\tfor _, rel := range relations.Relationships {\n\t\t\t\t\t\tif rel.Target == cell.Hyperlink.Link {\n\t\t\t\t\t\t\trelId = rel.Id\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif relId != \"\" {\n\n\t\t\t\t\txlsxLink := xlsxHyperlink{\n\t\t\t\t\t\tRelationshipId: relId,\n\t\t\t\t\t\tReference:      cellID,\n\t\t\t\t\t\tDisplayString:  cell.Hyperlink.DisplayString,\n\t\t\t\t\t\tTooltip:        cell.Hyperlink.Tooltip}\n\t\t\t\t\tworksheet.Hyperlinks.HyperLinks = append(worksheet.Hyperlinks.HyperLinks, xlsxLink)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif cell.HMerge > 0 || cell.VMerge > 0 {\n\t\t\t\tmc := xlsxMergeCell{}\n\t\t\t\tstart := fmt.Sprintf(\"%s%d\", ColIndexToLetters(cell.num), row.num+1)\n\t\t\t\tendcol := cell.num + cell.HMerge\n\t\t\t\tendrow := row.num + cell.VMerge + 1\n\t\t\t\tend := fmt.Sprintf(\"%s%d\", ColIndexToLetters(endcol), endrow)\n\t\t\t\tmc.Ref = start + \":\" + end\n\t\t\t\tif worksheet.MergeCells == nil {\n\t\t\t\t\tworksheet.MergeCells = &xlsxMergeCells{}\n\t\t\t\t}\n\t\t\t\tworksheet.MergeCells.Cells = append(worksheet.MergeCells.Cells, mc)\n\t\t\t\tworksheet.MergeCells.addCell(mc)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\treturn row.ForEachCell(prepCell, SkipEmptyCells)\n\t}\n\n\terr := s.ForEachRow(prepRow, SkipEmptyRows)\n\tif err != nil {\n\t\treturn err\n\t}\n\tworksheet.SheetFormatPr.OutlineLevelCol = s.SheetFormat.OutlineLevelCol\n\tworksheet.SheetFormatPr.OutlineLevelRow = s.SheetFormat.OutlineLevelRow\n\tif worksheet.MergeCells != nil {\n\t\tworksheet.MergeCells.Count = len(worksheet.MergeCells.Cells)\n\t}\n\n\tif s.AutoFilter != nil {\n\t\tworksheet.AutoFilter = &xlsxAutoFilter{Ref: fmt.Sprintf(\"%v:%v\", s.AutoFilter.TopLeftCell, s.AutoFilter.BottomRightCell)}\n\t}\n\n\tdimension := xlsxDimension{}\n\tdimension.Ref = \"A1:\" + GetCellIDStringFromCoords(maxCell, maxRow)\n\tif dimension.Ref == \"A1:A1\" {\n\t\tdimension.Ref = \"A1\"\n\t}\n\tworksheet.Dimension = dimension\n\treturn nil\n}\n\nfunc (s *Sheet) makeRows(worksheet *xlsxWorksheet, styles *xlsxStyleSheet, refTable *RefTable, relations *xlsxWorksheetRels, maxLevelCol uint8) error {\n\ts.mustBeOpen()\n\tmaxRow := 0\n\tmaxCell := 0\n\tvar maxLevelRow uint8\n\txSheet := xlsxSheetData{}\n\tmakeR := func(row *Row) error {\n\t\tr := row.num\n\t\tif r > maxRow {\n\t\t\tmaxRow = r\n\t\t}\n\t\txRow := xlsxRow{}\n\t\txRow.R = r + 1\n\t\tif row.customHeight {\n\t\t\txRow.CustomHeight = true\n\t\t\txRow.Ht = fmt.Sprintf(\"%g\", row.GetHeight())\n\t\t}\n\t\txRow.OutlineLevel = row.GetOutlineLevel()\n\t\tif xRow.OutlineLevel > maxLevelRow {\n\t\t\tmaxLevelRow = xRow.OutlineLevel\n\t\t}\n\t\tmakeC := func(cell *Cell) error {\n\t\t\tvar XfId int\n\n\t\t\tc := cell.num\n\t\t\tcol := s.Col(c)\n\t\t\tif col != nil {\n\t\t\t\tXfId = col.outXfID\n\t\t\t}\n\n\t\t\t// generate NumFmtId and add new NumFmt\n\t\t\txNumFmt := styles.newNumFmt(cell.NumFmt)\n\n\t\t\tstyle := cell.style\n\t\t\tswitch {\n\t\t\tcase style != nil:\n\t\t\t\tXfId = handleStyleForXLSX(style, xNumFmt.NumFmtId, styles)\n\t\t\tcase len(cell.NumFmt) == 0:\n\t\t\t\t// Do nothing\n\t\t\tcase col == nil:\n\t\t\t\tXfId = handleNumFmtIdForXLSX(xNumFmt.NumFmtId, styles)\n\t\t\tcase !compareFormatString(col.numFmt, cell.NumFmt):\n\t\t\t\tXfId = handleNumFmtIdForXLSX(xNumFmt.NumFmtId, styles)\n\t\t\t}\n\n\t\t\tif c > maxCell {\n\t\t\t\tmaxCell = c\n\t\t\t}\n\t\t\txC := xlsxC{\n\t\t\t\tS: XfId,\n\t\t\t\tR: GetCellIDStringFromCoords(c, r),\n\t\t\t}\n\t\t\tif cell.formula != \"\" {\n\t\t\t\txC.F = &xlsxF{Content: cell.formula}\n\t\t\t}\n\t\t\tswitch cell.cellType {\n\t\t\tcase CellTypeInline:\n\t\t\t\t// Inline strings are turned into shared strings since they are more efficient.\n\t\t\t\t// This is what Excel does as well.\n\t\t\t\tfallthrough\n\t\t\tcase CellTypeString:\n\t\t\t\tif len(cell.Value) > 0 {\n\t\t\t\t\txC.V = strconv.Itoa(refTable.AddString(cell.Value))\n\t\t\t\t} else if len(cell.RichText) > 0 {\n\t\t\t\t\txC.V = strconv.Itoa(refTable.AddRichText(cell.RichText))\n\t\t\t\t}\n\t\t\t\txC.T = \"s\"\n\t\t\tcase CellTypeNumeric:\n\t\t\t\t// Numeric is the default, so the type can be left blank\n\t\t\t\txC.V = cell.Value\n\t\t\tcase CellTypeBool:\n\t\t\t\txC.V = cell.Value\n\t\t\t\txC.T = \"b\"\n\t\t\tcase CellTypeError:\n\t\t\t\txC.V = cell.Value\n\t\t\t\txC.T = \"e\"\n\t\t\tcase CellTypeDate:\n\t\t\t\txC.V = cell.Value\n\t\t\t\txC.T = \"d\"\n\t\t\tcase CellTypeStringFormula:\n\t\t\t\txC.V = cell.Value\n\t\t\t\txC.T = \"str\"\n\t\t\tdefault:\n\t\t\t\tpanic(errors.New(\"unknown cell type cannot be marshaled\"))\n\t\t\t}\n\n\t\t\txRow.C = append(xRow.C, xC)\n\t\t\tif nil != cell.DataValidation {\n\t\t\t\tif nil == worksheet.DataValidations {\n\t\t\t\t\tworksheet.DataValidations = &xlsxDataValidations{}\n\t\t\t\t}\n\t\t\t\tcell.DataValidation.Sqref = xC.R\n\t\t\t\tworksheet.DataValidations.DataValidation = append(worksheet.DataValidations.DataValidation, cell.DataValidation)\n\t\t\t\tworksheet.DataValidations.Count = len(worksheet.DataValidations.DataValidation)\n\t\t\t}\n\n\t\t\tif cell.Hyperlink != (Hyperlink{}) {\n\t\t\t\tif worksheet.Hyperlinks == nil {\n\t\t\t\t\tworksheet.Hyperlinks = &xlsxHyperlinks{HyperLinks: []xlsxHyperlink{}}\n\t\t\t\t}\n\n\t\t\t\tvar relId string\n\t\t\t\tfor _, rel := range relations.Relationships {\n\t\t\t\t\tif rel.Target == cell.Hyperlink.Link {\n\t\t\t\t\t\trelId = rel.Id\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif relId != \"\" {\n\n\t\t\t\t\txlsxLink := xlsxHyperlink{\n\t\t\t\t\t\tRelationshipId: relId,\n\t\t\t\t\t\tReference:      xC.R,\n\t\t\t\t\t\tDisplayString:  cell.Hyperlink.DisplayString,\n\t\t\t\t\t\tTooltip:        cell.Hyperlink.Tooltip}\n\t\t\t\t\tworksheet.Hyperlinks.HyperLinks = append(worksheet.Hyperlinks.HyperLinks, xlsxLink)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif cell.HMerge > 0 || cell.VMerge > 0 {\n\t\t\t\t// r == rownum, c == colnum\n\t\t\t\tmc := xlsxMergeCell{}\n\t\t\t\tstart := fmt.Sprintf(\"%s%d\", ColIndexToLetters(c), r+1)\n\t\t\t\tendcol := c + cell.HMerge\n\t\t\t\tendrow := r + cell.VMerge + 1\n\t\t\t\tend := fmt.Sprintf(\"%s%d\", ColIndexToLetters(endcol), endrow)\n\t\t\t\tmc.Ref = start + \":\" + end\n\t\t\t\tif worksheet.MergeCells == nil {\n\t\t\t\t\tworksheet.MergeCells = &xlsxMergeCells{}\n\t\t\t\t}\n\t\t\t\tworksheet.MergeCells.Cells = append(worksheet.MergeCells.Cells, mc)\n\t\t\t\tworksheet.MergeCells.addCell(mc)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\terr := row.ForEachCell(makeC, SkipEmptyCells)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\txSheet.Row = append(xSheet.Row, xRow)\n\t\treturn nil\n\t}\n\n\terr := s.ForEachRow(makeR, SkipEmptyRows)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Update sheet format with the freshly determined max levels\n\ts.SheetFormat.OutlineLevelCol = maxLevelCol\n\ts.SheetFormat.OutlineLevelRow = maxLevelRow\n\t// .. and then also apply this to the xml worksheet\n\tworksheet.SheetFormatPr.OutlineLevelCol = s.SheetFormat.OutlineLevelCol\n\tworksheet.SheetFormatPr.OutlineLevelRow = s.SheetFormat.OutlineLevelRow\n\tif worksheet.MergeCells != nil {\n\t\tworksheet.MergeCells.Count = len(worksheet.MergeCells.Cells)\n\t}\n\n\tif s.AutoFilter != nil {\n\t\tworksheet.AutoFilter = &xlsxAutoFilter{Ref: fmt.Sprintf(\"%v:%v\", s.AutoFilter.TopLeftCell, s.AutoFilter.BottomRightCell)}\n\t}\n\n\tworksheet.SheetData = xSheet\n\tdimension := xlsxDimension{}\n\tdimension.Ref = \"A1:\" + GetCellIDStringFromCoords(maxCell, maxRow)\n\tif dimension.Ref == \"A1:A1\" {\n\t\tdimension.Ref = \"A1\"\n\t}\n\tworksheet.Dimension = dimension\n\treturn nil\n}\n\nfunc (s *Sheet) makeDataValidations(worksheet *xlsxWorksheet) {\n\ts.mustBeOpen()\n\tif len(s.DataValidations) > 0 {\n\t\tif worksheet.DataValidations == nil {\n\t\t\tworksheet.DataValidations = &xlsxDataValidations{}\n\t\t}\n\t\tworksheet.DataValidations.DataValidation = append(worksheet.DataValidations.DataValidation, s.DataValidations...)\n\t\tworksheet.DataValidations.Count = len(worksheet.DataValidations.DataValidation)\n\t}\n}\n\nfunc (s *Sheet) MarshalSheet(w io.Writer, refTable *RefTable, styles *xlsxStyleSheet, relations *xlsxWorksheetRels) error {\n\tworksheet := newXlsxWorksheet()\n\n\ts.handleMerged()\n\ts.makeSheetView(worksheet)\n\ts.makeSheetFormatPr(worksheet)\n\tmaxLevelCol := s.makeCols(worksheet, styles)\n\ts.makeDataValidations(worksheet)\n\ts.prepSheetForMarshalling(maxLevelCol)\n\terr := s.prepWorksheetFromRows(worksheet, relations)\n\tif err != nil {\n\t\treturn err\n\t}\n\txw := xmlwriter.Open(w)\n\n\terr = xw.StartDoc(xmlwriter.Doc{})\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = worksheet.WriteXML(xw, s, styles, refTable)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn xw.EndAllFlush()\n}\n\n// Dump sheet to its XML representation, intended for internal use only\nfunc (s *Sheet) makeXLSXSheet(refTable *RefTable, styles *xlsxStyleSheet, relations *xlsxWorksheetRels) *xlsxWorksheet {\n\ts.mustBeOpen()\n\tworksheet := newXlsxWorksheet()\n\n\t// Scan through the sheet and see if there are any merged cells. If there\n\t// are, we may need to extend the size of the sheet. There needs to be\n\t// phantom cells underlying the area covered by the merged cell\n\ts.handleMerged()\n\n\ts.makeSheetView(worksheet)\n\ts.makeSheetFormatPr(worksheet)\n\tmaxLevelCol := s.makeCols(worksheet, styles)\n\ts.makeDataValidations(worksheet)\n\ts.makeRows(worksheet, styles, refTable, relations, maxLevelCol)\n\n\treturn worksheet\n}\n\nfunc handleStyleForXLSX(style *Style, NumFmtId int, styles *xlsxStyleSheet) (XfId int) {\n\txFont, xFill, xBorder, xCellXf := style.makeXLSXStyleElements()\n\tfontId := styles.addFont(xFont)\n\tfillId := styles.addFill(xFill)\n\n\t// HACK - adding light grey fill, as in OO and Google\n\tgreyfill := xlsxFill{}\n\tgreyfill.PatternFill.PatternType = \"lightGray\"\n\tstyles.addFill(greyfill)\n\n\tborderId := styles.addBorder(xBorder)\n\txCellXf.FontId = fontId\n\txCellXf.FillId = fillId\n\txCellXf.BorderId = borderId\n\txCellXf.NumFmtId = NumFmtId\n\t// apply the numFmtId when it is not the default cellxf\n\tif xCellXf.NumFmtId > 0 {\n\t\txCellXf.ApplyNumberFormat = true\n\t}\n\n\txCellXf.Alignment.Horizontal = style.Alignment.Horizontal\n\txCellXf.Alignment.Indent = style.Alignment.Indent\n\txCellXf.Alignment.ShrinkToFit = style.Alignment.ShrinkToFit\n\txCellXf.Alignment.TextRotation = style.Alignment.TextRotation\n\txCellXf.Alignment.Vertical = style.Alignment.Vertical\n\txCellXf.Alignment.WrapText = style.Alignment.WrapText\n\n\tXfId = styles.addCellXf(xCellXf)\n\treturn\n}\n\nfunc handleNumFmtIdForXLSX(NumFmtId int, styles *xlsxStyleSheet) (XfId int) {\n\txCellXf := makeXLSXCellElement()\n\txCellXf.NumFmtId = NumFmtId\n\tif xCellXf.NumFmtId > 0 {\n\t\txCellXf.ApplyNumberFormat = true\n\t}\n\tXfId = styles.addCellXf(xCellXf)\n\treturn\n}\n\nfunc IsSaneSheetName(sheetName string) error {\n\truneLength := utf8.RuneCountInString(sheetName)\n\tif runeLength > 31 || runeLength == 0 {\n\t\treturn fmt.Errorf(\"sheet name must be 31 or fewer characters long.  It is currently '%d' characters long\", runeLength)\n\t}\n\t// Iterate over the runes\n\tfor _, r := range sheetName {\n\t\t// Excel forbids : \\ / ? * [ ]\n\t\tif r == ':' || r == '\\\\' || r == '/' || r == '?' || r == '*' || r == '[' || r == ']' {\n\t\t\treturn fmt.Errorf(\"sheet name must not contain any restricted characters : \\\\ / ? * [ ] but contains '%s'\", string(r))\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "sheet_test.go",
          "type": "blob",
          "size": 28.458984375,
          "content": "package xlsx\n\nimport (\n\t\"archive/zip\"\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"io\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\nfunc TestSheet(t *testing.T) {\n\tc := qt.New(t)\n\t// Test we can add a Row to a Sheet\n\tcsRunO(c, \"TestAddAndRemoveRow\", func(c *qt.C, option FileOption) {\n\t\toption = UseDiskVCellStore\n\t\tsetUp := func() (*Sheet, error) {\n\t\t\tf := NewFile(option)\n\t\t\tsheet, err := f.AddSheet(\"MySheet\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\trow0 := sheet.AddRow()\n\t\t\tcell0 := row0.AddCell()\n\t\t\tcell0.Value = \"Row 0\"\n\t\t\tc.Assert(row0, qt.Not(qt.IsNil))\n\t\t\trow1 := sheet.AddRow()\n\t\t\tcell1 := row1.AddCell()\n\t\t\tcell1.Value = \"Row 1\"\n\t\t\trow2 := sheet.AddRow()\n\t\t\tcell2 := row2.AddCell()\n\t\t\tcell2.Value = \"Row 2\"\n\t\t\treturn sheet, nil\n\t\t}\n\n\t\tassertRow := func(c *qt.C, sheet *Sheet, expected []string) {\n\t\t\tc.Assert(sheet.MaxRow, qt.Equals, len(expected))\n\t\t\tsheet.ForEachRow(func(row *Row) error {\n\t\t\t\tc.Assert(row.GetCell(0).Value, qt.Equals, expected[row.num])\n\t\t\t\treturn nil\n\t\t\t})\n\n\t\t}\n\n\t\tc.Run(\"AddRow\", func(c *qt.C) {\n\t\t\tc.Run(\"SimpleAddRow\", func(c *qt.C) {\n\t\t\t\tsheet, err := setUp()\n\t\t\t\tc.Assert(err, qt.Equals, nil)\n\t\t\t\t// Check the file\n\t\t\t\tassertRow(c, sheet, []string{\"Row 0\", \"Row 1\", \"Row 2\"})\n\t\t\t})\n\n\t\t\tc.Run(\"InsertARowInTheMiddle\", func(c *qt.C) {\n\t\t\t\tsheet, err := setUp()\n\t\t\t\tc.Assert(err, qt.Equals, nil)\n\t\t\t\tassertRow(c, sheet, []string{\"Row 0\", \"Row 1\", \"Row 2\"})\n\t\t\t\trow1pt5, err := sheet.AddRowAtIndex(2)\n\t\t\t\tc.Assert(err, qt.IsNil)\n\t\t\t\tcell1pt5 := row1pt5.AddCell()\n\t\t\t\tcell1pt5.Value = \"Row 1.5\"\n\n\t\t\t\tassertRow(c, sheet, []string{\"Row 0\", \"Row 1\", \"Row 1.5\", \"Row 2\"})\n\t\t\t})\n\n\t\t\tc.Run(\"InsertARowAtBeginning\", func(c *qt.C) {\n\t\t\t\tsheet, err := setUp()\n\t\t\t\tc.Assert(err, qt.Equals, nil)\n\t\t\t\tassertRow(c, sheet, []string{\"Row 0\", \"Row 1\", \"Row 2\"})\n\t\t\t\trowNewStart, err := sheet.AddRowAtIndex(0)\n\t\t\t\tc.Assert(err, qt.IsNil)\n\t\t\t\tcellNewStart := rowNewStart.AddCell()\n\t\t\t\tcellNewStart.Value = \"Row -1\"\n\t\t\t\tassertRow(c, sheet, []string{\"Row -1\", \"Row 0\", \"Row 1\", \"Row 2\"})\n\n\t\t\t})\n\n\t\t\tc.Run(\"InsertARowAtTheEnd\", func(c *qt.C) {\n\t\t\t\t// Insert a row at one index past the end,\n\t\t\t\t// this is the same as AddRow().\n\t\t\t\tsheet, err := setUp()\n\t\t\t\tc.Assert(err, qt.Equals, nil)\n\n\t\t\t\trow2pt5, err := sheet.AddRowAtIndex(3)\n\t\t\t\tc.Assert(err, qt.IsNil)\n\t\t\t\tcell2pt5 := row2pt5.AddCell()\n\t\t\t\tcell2pt5.Value = \"Row 2.5\"\n\n\t\t\t\tassertRow(c, sheet, []string{\"Row 0\", \"Row 1\", \"Row 2\", \"Row 2.5\"})\n\t\t\t})\n\n\t\t\tc.Run(\"NegativeIndexFails\", func(c *qt.C) {\n\t\t\t\t// TODO: why do we accept an int type instead of a uint?\n\t\t\t\tsheet, err := setUp()\n\t\t\t\tc.Assert(err, qt.Equals, nil)\n\n\t\t\t\t_, err = sheet.AddRowAtIndex(-1)\n\t\t\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t\t\t})\n\n\t\t\tc.Run(\"BeyondMaxRowPlusOne\", func(c *qt.C) {\n\t\t\t\t// TODO: The behaviour right now is that we\n\t\t\t\t// allow you to AddRowAtIndex up to an\n\t\t\t\t// including in one place after the final row,\n\t\t\t\t// this seems arbitrary and wrong.\n\t\t\t\tsheet, err := setUp()\n\t\t\t\tc.Assert(err, qt.Equals, nil)\n\n\t\t\t\t_, err = sheet.AddRowAtIndex(7)\n\t\t\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t\t\t})\n\t\t})\n\t\tc.Run(\"RemoveRow\", func(c *qt.C) {\n\t\t\tc.Run(\"NegativeIndex\", func(c *qt.C) {\n\t\t\t\t// Negative and out of range indicies should fail for remove\n\t\t\t\tsheet, err := setUp()\n\t\t\t\tc.Assert(err, qt.Equals, nil)\n\n\t\t\t\terr = sheet.RemoveRowAtIndex(-1)\n\t\t\t\tc.Assert(err, qt.Not(qt.IsNil))\n\t\t\t})\n\t\t\tc.Run(\"IndexOutOfRange\", func(c *qt.C) {\n\t\t\t\tsheet, err := setUp()\n\t\t\t\tc.Assert(err, qt.Equals, nil)\n\n\t\t\t\terr = sheet.RemoveRowAtIndex(6)\n\t\t\t\tc.Assert(err, qt.Not(qt.IsNil))\n\n\t\t\t})\n\n\t\t\tc.Run(\"RemoveFromTheBeginning\", func(c *qt.C) {\n\t\t\t\tsheet, err := setUp()\n\t\t\t\tc.Assert(err, qt.Equals, nil)\n\n\t\t\t\terr = sheet.RemoveRowAtIndex(0)\n\t\t\t\tc.Assert(err, qt.IsNil)\n\t\t\t\tassertRow(c, sheet, []string{\"Row 1\", \"Row 2\"})\n\t\t\t})\n\n\t\t\tc.Run(\"RemoveFromTheEnd\", func(c *qt.C) {\n\t\t\t\tsheet, err := setUp()\n\t\t\t\tc.Assert(err, qt.Equals, nil)\n\n\t\t\t\terr = sheet.RemoveRowAtIndex(2)\n\t\t\t\tc.Assert(err, qt.IsNil)\n\t\t\t\tassertRow(c, sheet, []string{\"Row 0\", \"Row 1\"})\n\t\t\t})\n\n\t\t\tc.Run(\"RemoveFromTheMiddle\", func(c *qt.C) {\n\t\t\t\tsheet, err := setUp()\n\t\t\t\tc.Assert(err, qt.Equals, nil)\n\n\t\t\t\terr = sheet.RemoveRowAtIndex(1)\n\t\t\t\tc.Assert(err, qt.IsNil)\n\t\t\t\tassertRow(c, sheet, []string{\"Row 0\", \"Row 2\"})\n\t\t\t})\n\n\t\t})\n\t})\n\n\t// Test we can get row by index from  Sheet\n\tcsRunO(c, \"TestGetRowByIndex\", func(c *qt.C, option FileOption) {\n\t\tf := NewFile()\n\t\tsheet, _ := f.AddSheet(\"MySheet\")\n\t\trow, err := sheet.Row(10)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row, qt.Not(qt.IsNil))\n\t\tc.Assert(sheet.MaxRow, qt.Equals, 11)\n\t\trow, err = sheet.Row(2)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(row, qt.Not(qt.IsNil))\n\t\tc.Assert(sheet.MaxRow, qt.Equals, 11)\n\t})\n\n\tcsRunO(c, \"TestMakeXLSXSheetFromRows\", func(c *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Sheet1\")\n\t\trow := sheet.AddRow()\n\t\tcell := row.AddCell()\n\t\tcell.Value = \"A cell!\"\n\n\t\tvar buf bytes.Buffer\n\n\t\trefTable := NewSharedStringRefTable(1)\n\t\tstyles := newXlsxStyleSheet(nil)\n\t\terr := sheet.MarshalSheet(&buf, refTable, styles, nil)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tvar xSheet xlsxWorksheet\n\t\terr = xml.Unmarshal(buf.Bytes(), &xSheet)\n\t\tc.Assert(err, qt.Equals, nil)\n\n\t\tc.Assert(xSheet.Dimension.Ref, qt.Equals, \"A1\")\n\t\tc.Assert(len(xSheet.SheetData.Row), qt.Equals, 1)\n\t\txRow := xSheet.SheetData.Row[0]\n\t\tc.Assert(xRow.R, qt.Equals, 1)\n\t\tc.Assert(xRow.Spans, qt.Equals, \"\")\n\t\tc.Assert(len(xRow.C), qt.Equals, 1)\n\t\txC := xRow.C[0]\n\t\tc.Assert(xC.R, qt.Equals, \"A1\")\n\t\tc.Assert(xC.S, qt.Equals, 0)\n\t\tc.Assert(xC.T, qt.Equals, \"s\") // Shared string type\n\t\tc.Assert(xC.V, qt.Equals, \"0\") // reference to shared string\n\t\txSST := refTable.makeXLSXSST()\n\t\tc.Assert(xSST.Count, qt.Equals, 1)\n\t\tc.Assert(xSST.UniqueCount, qt.Equals, 1)\n\t\tc.Assert(len(xSST.SI), qt.Equals, 1)\n\t\txSI := xSST.SI[0]\n\t\tc.Assert(xSI.T.Text, qt.Equals, \"A cell!\")\n\t\tc.Assert(xSI.R, qt.HasLen, 0)\n\t})\n\n\tcsRunO(c, \"TestMarshalSheetFromRows\", func(c *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Sheet1\")\n\t\trow := sheet.AddRow()\n\t\tcell := row.AddCell()\n\t\tcell.Value = \"A cell!\"\n\t\trefTable := NewSharedStringRefTable(1)\n\t\tstyles := newXlsxStyleSheet(nil)\n\t\tvar output bytes.Buffer\n\t\terr := sheet.MarshalSheet(&output, refTable, styles, nil)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tvar xSheet xlsxWorksheet\n\t\terr = xml.Unmarshal(output.Bytes(), &xSheet)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(xSheet.Dimension.Ref, qt.Equals, \"A1\")\n\t\tc.Assert(len(xSheet.SheetData.Row), qt.Equals, 1)\n\t\txRow := xSheet.SheetData.Row[0]\n\t\tc.Assert(xRow.R, qt.Equals, 1)\n\t\tc.Assert(xRow.Spans, qt.Equals, \"\")\n\t\tc.Assert(len(xRow.C), qt.Equals, 1)\n\t\txC := xRow.C[0]\n\t\tc.Assert(xC.R, qt.Equals, \"A1\")\n\t\tc.Assert(xC.S, qt.Equals, 0)\n\t\tc.Assert(xC.T, qt.Equals, \"s\") // Shared string type\n\t\tc.Assert(xC.V, qt.Equals, \"0\") // reference to shared string\n\t\txSST := refTable.makeXLSXSST()\n\t\tc.Assert(xSST.Count, qt.Equals, 1)\n\t\tc.Assert(xSST.UniqueCount, qt.Equals, 1)\n\t\tc.Assert(len(xSST.SI), qt.Equals, 1)\n\t\txSI := xSST.SI[0]\n\t\tc.Assert(xSI.T.Text, qt.Equals, \"A cell!\")\n\t\tc.Assert(xSI.R, qt.HasLen, 0)\n\t})\n\n\t// If the column width is not customised, the xslxCol.CustomWidth field is set to 0.\n\tcsRunO(c, \"TestMarshalSheetDefaultsCustomColWidth\", func(c *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Sheet1\")\n\t\trow := sheet.AddRow()\n\t\tcell1 := row.AddCell()\n\t\tcell1.Value = \"A cell!\"\n\n\t\trefTable := NewSharedStringRefTable(1)\n\t\tstyles := newXlsxStyleSheet(nil)\n\n\t\tvar output bytes.Buffer\n\t\terr := sheet.MarshalSheet(&output, refTable, styles, nil)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tvar result xlsxWorksheet\n\t\terr = xml.Unmarshal(output.Bytes(), &result)\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(result.Cols, qt.IsNil)\n\t})\n\n\tcsRunO(c, \"TestMarshalSheetWithColStyle\", func(qc *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Sheet1\")\n\t\trow := sheet.AddRow()\n\t\tcell1 := row.AddCell()\n\t\tcell1.Value = \"A cell!\"\n\n\t\tcolStyle := NewStyle()\n\t\tcolStyle.Fill.FgColor = \"EEEEEE00\"\n\t\tcolStyle.Fill.PatternType = \"solid\"\n\t\tcolStyle.ApplyFill = true\n\t\tcol := NewColForRange(10, 11)\n\t\tcol.SetStyle(colStyle)\n\t\tsheet.Cols.Add(col)\n\n\t\tvar buf bytes.Buffer\n\n\t\trefTable := NewSharedStringRefTable(1)\n\t\tstyles := newXlsxStyleSheet(nil)\n\t\terr := sheet.MarshalSheet(&buf, refTable, styles, nil)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tvar xSheet xlsxWorksheet\n\t\terr = xml.Unmarshal(buf.Bytes(), &xSheet)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(xSheet.Cols, qt.Not(qt.IsNil))\n\t\tc.Assert(*xSheet.Cols.Col[0].Style, qt.Equals, 0)\n\t\tc.Assert(styles.getStyle(0), qt.DeepEquals, colStyle)\n\t})\n\n\tcsRunO(c, \"TestMarshalSheet\", func(c *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Sheet1\")\n\t\trow := sheet.AddRow()\n\t\tcell := row.AddCell()\n\t\tcell.Value = \"A cell!\"\n\t\trefTable := NewSharedStringRefTable(1)\n\t\tstyles := newXlsxStyleSheet(nil)\n\t\tvar output strings.Builder\n\t\terr := sheet.MarshalSheet(&output, refTable, styles, nil)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\texpectedXLSXSheet := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"><sheetPr filterMode=\"false\"><pageSetUpPr fitToPage=\"false\"/></sheetPr><dimension ref=\"A1\"/><sheetViews><sheetView windowProtection=\"false\" showFormulas=\"false\" showGridLines=\"true\" showRowColHeaders=\"true\" showZeros=\"true\" rightToLeft=\"false\" tabSelected=\"true\" showOutlineSymbols=\"true\" defaultGridColor=\"true\" view=\"normal\" topLeftCell=\"A1\" colorId=\"64\" zoomScale=\"100\" zoomScaleNormal=\"100\" zoomScalePageLayoutView=\"100\" workbookViewId=\"0\"><selection pane=\"topLeft\" activeCell=\"A1\" activeCellId=\"0\" sqref=\"A1\"/></sheetView></sheetViews><sheetFormatPr defaultRowHeight=\"12.85\"/><sheetData><row r=\"1\"><c r=\"A1\" t=\"s\"><v>0</v></c></row></sheetData></worksheet>`\n\n\t\tc.Assert(output.String(), qt.Equals, expectedXLSXSheet)\n\t})\n\n\tcsRunO(c, \"TestMarshalSheetWithMultipleCells\", func(c *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Sheet1\")\n\t\trow := sheet.AddRow()\n\t\tcell := row.AddCell()\n\t\tcell.Value = \"A cell (with value 1)!\"\n\t\tcell = row.AddCell()\n\t\tcell.Value = \"A cell (with value 2)!\"\n\t\tvar buf bytes.Buffer\n\n\t\trefTable := NewSharedStringRefTable(2)\n\t\tstyles := newXlsxStyleSheet(nil)\n\t\terr := sheet.MarshalSheet(&buf, refTable, styles, nil)\n\t\tc.Assert(err, qt.Equals, nil)\n\n\t\texpectedXLSXSheet := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"><sheetPr filterMode=\"false\"><pageSetUpPr fitToPage=\"false\"/></sheetPr><dimension ref=\"A1:B1\"/><sheetViews><sheetView windowProtection=\"false\" showFormulas=\"false\" showGridLines=\"true\" showRowColHeaders=\"true\" showZeros=\"true\" rightToLeft=\"false\" tabSelected=\"true\" showOutlineSymbols=\"true\" defaultGridColor=\"true\" view=\"normal\" topLeftCell=\"A1\" colorId=\"64\" zoomScale=\"100\" zoomScaleNormal=\"100\" zoomScalePageLayoutView=\"100\" workbookViewId=\"0\"><selection pane=\"topLeft\" activeCell=\"A1\" activeCellId=\"0\" sqref=\"A1\"/></sheetView></sheetViews><sheetFormatPr defaultRowHeight=\"12.85\"/><sheetData><row r=\"1\"><c r=\"A1\" t=\"s\"><v>0</v></c><c r=\"B1\" t=\"s\"><v>1</v></c></row></sheetData></worksheet>`\n\t\tc.Assert(buf.String(), qt.Equals, expectedXLSXSheet)\n\t})\n\tcsRunO(c, \"TestSetRowHeightCM\", func(c *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Sheet1\")\n\t\trow := sheet.AddRow()\n\t\trow.SetHeightCM(1.5)\n\t\tc.Assert(row.GetHeight(), qt.Equals, 42.51968505)\n\t})\n\n\tcsRunO(c, \"TestAlignment\", func(c *qt.C, option FileOption) {\n\t\tleftalign := *DefaultAlignment()\n\t\tleftalign.Horizontal = \"left\"\n\t\tcenterHalign := *DefaultAlignment()\n\t\tcenterHalign.Horizontal = \"center\"\n\t\trightalign := *DefaultAlignment()\n\t\trightalign.Horizontal = \"right\"\n\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Sheet1\")\n\n\t\tstyle := NewStyle()\n\n\t\throw := sheet.AddRow()\n\n\t\t// Horizontals\n\t\tcell := hrow.AddCell()\n\t\tcell.Value = \"left\"\n\t\tstyle.Alignment = leftalign\n\t\tstyle.ApplyAlignment = true\n\t\tcell.SetStyle(style)\n\n\t\tstyle = NewStyle()\n\t\tcell = hrow.AddCell()\n\t\tcell.Value = \"centerH\"\n\t\tstyle.Alignment = centerHalign\n\t\tstyle.ApplyAlignment = true\n\t\tcell.SetStyle(style)\n\n\t\tstyle = NewStyle()\n\t\tcell = hrow.AddCell()\n\t\tcell.Value = \"right\"\n\t\tstyle.Alignment = rightalign\n\t\tstyle.ApplyAlignment = true\n\t\tcell.SetStyle(style)\n\n\t\t// Verticals\n\t\ttopalign := *DefaultAlignment()\n\t\ttopalign.Vertical = \"top\"\n\t\tcenterValign := *DefaultAlignment()\n\t\tcenterValign.Vertical = \"center\"\n\t\tbottomalign := *DefaultAlignment()\n\t\tbottomalign.Vertical = \"bottom\"\n\n\t\tstyle = NewStyle()\n\t\tvrow := sheet.AddRow()\n\t\tcell = vrow.AddCell()\n\t\tcell.Value = \"top\"\n\t\tstyle.Alignment = topalign\n\t\tstyle.ApplyAlignment = true\n\t\tcell.SetStyle(style)\n\n\t\tstyle = NewStyle()\n\t\tcell = vrow.AddCell()\n\t\tcell.Value = \"centerV\"\n\t\tstyle.Alignment = centerValign\n\t\tstyle.ApplyAlignment = true\n\t\tcell.SetStyle(style)\n\n\t\tstyle = NewStyle()\n\t\tcell = vrow.AddCell()\n\t\tcell.Value = \"bottom\"\n\t\tstyle.Alignment = bottomalign\n\t\tstyle.ApplyAlignment = true\n\t\tcell.SetStyle(style)\n\n\t\tdir := t.TempDir()\n\t\tpath := filepath.Join(dir, \"test.xlsx\")\n\t\terr := file.Save(path)\n\t\tc.Assert(err, qt.IsNil)\n\t\tr, err := zip.OpenReader(path)\n\t\tc.Assert(err, qt.IsNil)\n\t\tdefer r.Close()\n\n\t\tvar obtained []byte\n\t\tfor _, f := range r.File {\n\t\t\tif f.Name == \"xl/styles.xml\" {\n\t\t\t\trc, err := f.Open()\n\t\t\t\tc.Assert(err, qt.Equals, nil)\n\t\t\t\tobtained, err = io.ReadAll(rc)\n\t\t\t\tc.Assert(err, qt.Equals, nil)\n\t\t\t}\n\t\t}\n\n\t\tshouldbe := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<styleSheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"><fonts count=\"2\"><font><sz val=\"11\"/><name val=\"Arial\"/><family val=\"2\"/><color theme=\"1\" /><scheme val=\"minor\"/></font><font><sz val=\"12\"/><name val=\"Verdana\"/><family val=\"0\"/><charset val=\"0\"/></font></fonts><fills count=\"3\"><fill><patternFill patternType=\"none\"/></fill><fill><patternFill patternType=\"gray125\"/></fill><fill><patternFill patternType=\"lightGray\"/></fill></fills><borders count=\"2\"><border><left/><right/><top/><bottom/></border><border><left style=\"none\"></left><right style=\"none\"></right><top style=\"none\"></top><bottom style=\"none\"></bottom></border></borders><cellStyleXfs count=\"1\"><xf applyAlignment=\"0\" applyBorder=\"0\" applyFont=\"0\" applyFill=\"0\" applyNumberFormat=\"0\" applyProtection=\"0\" borderId=\"0\" fillId=\"0\" fontId=\"0\" numFmtId=\"0\"><alignment horizontal=\"general\" indent=\"0\" shrinkToFit=\"0\" textRotation=\"0\" vertical=\"bottom\" wrapText=\"0\"/></xf></cellStyleXfs><cellXfs count=\"7\"><xf applyAlignment=\"0\" applyBorder=\"0\" applyFont=\"0\" applyFill=\"0\" applyNumberFormat=\"0\" applyProtection=\"0\" borderId=\"0\" fillId=\"0\" fontId=\"0\" numFmtId=\"0\"><alignment horizontal=\"general\" indent=\"0\" shrinkToFit=\"0\" textRotation=\"0\" vertical=\"bottom\" wrapText=\"0\"/></xf><xf applyAlignment=\"1\" applyBorder=\"0\" applyFont=\"0\" applyFill=\"0\" applyNumberFormat=\"0\" applyProtection=\"0\" borderId=\"1\" fillId=\"0\" fontId=\"1\" numFmtId=\"0\"><alignment horizontal=\"left\" indent=\"0\" shrinkToFit=\"0\" textRotation=\"0\" vertical=\"bottom\" wrapText=\"0\"/></xf><xf applyAlignment=\"1\" applyBorder=\"0\" applyFont=\"0\" applyFill=\"0\" applyNumberFormat=\"0\" applyProtection=\"0\" borderId=\"1\" fillId=\"0\" fontId=\"1\" numFmtId=\"0\"><alignment horizontal=\"center\" indent=\"0\" shrinkToFit=\"0\" textRotation=\"0\" vertical=\"bottom\" wrapText=\"0\"/></xf><xf applyAlignment=\"1\" applyBorder=\"0\" applyFont=\"0\" applyFill=\"0\" applyNumberFormat=\"0\" applyProtection=\"0\" borderId=\"1\" fillId=\"0\" fontId=\"1\" numFmtId=\"0\"><alignment horizontal=\"right\" indent=\"0\" shrinkToFit=\"0\" textRotation=\"0\" vertical=\"bottom\" wrapText=\"0\"/></xf><xf applyAlignment=\"1\" applyBorder=\"0\" applyFont=\"0\" applyFill=\"0\" applyNumberFormat=\"0\" applyProtection=\"0\" borderId=\"1\" fillId=\"0\" fontId=\"1\" numFmtId=\"0\"><alignment horizontal=\"general\" indent=\"0\" shrinkToFit=\"0\" textRotation=\"0\" vertical=\"top\" wrapText=\"0\"/></xf><xf applyAlignment=\"1\" applyBorder=\"0\" applyFont=\"0\" applyFill=\"0\" applyNumberFormat=\"0\" applyProtection=\"0\" borderId=\"1\" fillId=\"0\" fontId=\"1\" numFmtId=\"0\"><alignment horizontal=\"general\" indent=\"0\" shrinkToFit=\"0\" textRotation=\"0\" vertical=\"center\" wrapText=\"0\"/></xf><xf applyAlignment=\"1\" applyBorder=\"0\" applyFont=\"0\" applyFill=\"0\" applyNumberFormat=\"0\" applyProtection=\"0\" borderId=\"1\" fillId=\"0\" fontId=\"1\" numFmtId=\"0\"><alignment horizontal=\"general\" indent=\"0\" shrinkToFit=\"0\" textRotation=\"0\" vertical=\"bottom\" wrapText=\"0\"/></xf></cellXfs></styleSheet>`\n\n\t\texpected := bytes.NewBufferString(shouldbe)\n\t\tc.Assert(string(obtained), qt.Equals, expected.String())\n\t})\n\n\tcsRunO(c, \"TestAutoFilter\", func(c *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Sheet1\")\n\n\t\tr1 := sheet.AddRow()\n\t\tr1.AddCell()\n\t\tr1.AddCell()\n\t\tr1.AddCell()\n\n\t\tr2 := sheet.AddRow()\n\t\tr2.AddCell()\n\t\tr2.AddCell()\n\t\tr2.AddCell()\n\n\t\tr3 := sheet.AddRow()\n\t\tr3.AddCell()\n\t\tr3.AddCell()\n\t\tr3.AddCell()\n\n\t\t// Define a filter area\n\t\tsheet.AutoFilter = &AutoFilter{TopLeftCell: \"B2\", BottomRightCell: \"C3\"}\n\n\t\tvar buf bytes.Buffer\n\n\t\trefTable := NewSharedStringRefTable(10)\n\t\tstyles := newXlsxStyleSheet(nil)\n\t\terr := sheet.MarshalSheet(&buf, refTable, styles, nil)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tvar xSheet xlsxWorksheet\n\t\terr = xml.Unmarshal(buf.Bytes(), &xSheet)\n\t\tc.Assert(err, qt.Equals, nil)\n\n\t\tc.Assert(xSheet.AutoFilter, qt.Not(qt.IsNil))\n\t\tc.Assert(xSheet.AutoFilter.Ref, qt.Equals, \"B2:C3\")\n\t})\n\n}\n\nfunc TestMakeXLSXSheet(t *testing.T) {\n\tc := qt.New(t)\n\n\t// Test if the NumFmts assigned properly according the FormatCode in cell.\n\tcsRunO(c, \"SheetWithNumFormats\", func(c *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Sheet1\")\n\t\trow := sheet.AddRow()\n\n\t\tcell1 := row.AddCell()\n\t\tcell1.Value = \"A cell!\"\n\t\tcell1.NumFmt = \"general\"\n\n\t\tcell2 := row.AddCell()\n\t\tcell2.Value = \"37947.7500001\"\n\t\tcell2.NumFmt = \"0\"\n\n\t\tcell3 := row.AddCell()\n\t\tcell3.Value = \"37947.7500001\"\n\t\tcell3.NumFmt = \"mm-dd-yy\"\n\n\t\tcell4 := row.AddCell()\n\t\tcell4.Value = \"37947.7500001\"\n\t\tcell4.NumFmt = \"hh:mm:ss\"\n\n\t\tvar buf bytes.Buffer\n\n\t\trefTable := NewSharedStringRefTable(4)\n\t\tstyles := newXlsxStyleSheet(nil)\n\t\terr := sheet.MarshalSheet(&buf, refTable, styles, nil)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tvar xSheet xlsxWorksheet\n\t\terr = xml.Unmarshal(buf.Bytes(), &xSheet)\n\t\tc.Assert(err, qt.Equals, nil)\n\n\t\tc.Assert(styles.CellStyleXfs, qt.IsNil)\n\n\t\tc.Assert(styles.CellXfs.Count, qt.Equals, 4)\n\t\tc.Assert(styles.CellXfs.Xf[0].NumFmtId, qt.Equals, 0)\n\t\tc.Assert(styles.CellXfs.Xf[1].NumFmtId, qt.Equals, 1)\n\t\tc.Assert(styles.CellXfs.Xf[2].NumFmtId, qt.Equals, 14)\n\t\tc.Assert(styles.CellXfs.Xf[3].NumFmtId, qt.Equals, 164)\n\t\tc.Assert(styles.NumFmts.Count, qt.Equals, 1)\n\t\tc.Assert(styles.NumFmts.NumFmt[0].NumFmtId, qt.Equals, 164)\n\t\tc.Assert(styles.NumFmts.NumFmt[0].FormatCode, qt.Equals, \"hh:mm:ss\")\n\n\t\t// Finally we check that the cell points to the right CellXf /\n\t\t// CellStyleXf.\n\t\tc.Assert(xSheet.SheetData.Row[0].C[0].S, qt.Equals, 0)\n\t\tc.Assert(xSheet.SheetData.Row[0].C[1].S, qt.Equals, 1)\n\t})\n\n\t// When we create the xlsxSheet we also populate the xlsxStyles struct\n\t// with style information.\n\tcsRunO(c, \"PopulateXLSXSTyles\", func(c *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Sheet1\")\n\t\trow := sheet.AddRow()\n\n\t\tcell1 := row.AddCell()\n\t\tcell1.Value = \"A cell!\"\n\t\tstyle1 := NewStyle()\n\t\tstyle1.Font = *NewFont(10, \"Verdana\")\n\t\tstyle1.Fill = *NewFill(\"solid\", \"FFFFFFFF\", \"00000000\")\n\t\tstyle1.Border = *NewBorder(\"none\", \"thin\", \"none\", \"thin\")\n\t\tcell1.SetStyle(style1)\n\n\t\t// We need a second style to check that Xfs are populated correctly.\n\t\tcell2 := row.AddCell()\n\t\tcell2.Value = \"Another cell!\"\n\t\tstyle2 := NewStyle()\n\t\tstyle2.Font = *NewFont(10, \"Verdana\")\n\t\tstyle2.Fill = *NewFill(\"solid\", \"FFFFFFFF\", \"00000000\")\n\t\tstyle2.Border = *NewBorder(\"none\", \"thin\", \"none\", \"thin\")\n\t\tcell2.SetStyle(style2)\n\t\tvar buf bytes.Buffer\n\n\t\trefTable := NewSharedStringRefTable(2)\n\t\tstyles := newXlsxStyleSheet(nil)\n\t\terr := sheet.MarshalSheet(&buf, refTable, styles, nil)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tvar xSheet xlsxWorksheet\n\t\terr = xml.Unmarshal(buf.Bytes(), &xSheet)\n\t\tc.Assert(err, qt.Equals, nil)\n\n\t\tc.Assert(styles.Fonts.Count, qt.Equals, 1)\n\t\tc.Assert(styles.Fonts.Font[0].Sz.Val, qt.Equals, \"10\")\n\t\tc.Assert(styles.Fonts.Font[0].Name.Val, qt.Equals, \"Verdana\")\n\n\t\tc.Assert(styles.Fills.Count, qt.Equals, 2)\n\t\tc.Assert(styles.Fills.Fill[0].PatternFill.PatternType, qt.Equals, \"solid\")\n\t\tc.Assert(styles.Fills.Fill[0].PatternFill.FgColor.RGB, qt.Equals, \"FFFFFFFF\")\n\t\tc.Assert(styles.Fills.Fill[0].PatternFill.BgColor.RGB, qt.Equals, \"00000000\")\n\n\t\tc.Assert(styles.Borders.Count, qt.Equals, 1)\n\t\tc.Assert(styles.Borders.Border[0].Left.Style, qt.Equals, \"none\")\n\t\tc.Assert(styles.Borders.Border[0].Right.Style, qt.Equals, \"thin\")\n\t\tc.Assert(styles.Borders.Border[0].Top.Style, qt.Equals, \"none\")\n\t\tc.Assert(styles.Borders.Border[0].Bottom.Style, qt.Equals, \"thin\")\n\n\t\tc.Assert(styles.CellStyleXfs, qt.IsNil)\n\n\t\tc.Assert(styles.CellXfs.Count, qt.Equals, 1)\n\t\tc.Assert(styles.CellXfs.Xf[0].FontId, qt.Equals, 0)\n\t\tc.Assert(styles.CellXfs.Xf[0].FillId, qt.Equals, 0)\n\t\tc.Assert(styles.CellXfs.Xf[0].BorderId, qt.Equals, 0)\n\n\t\t// Finally we check that the cell points to the right CellXf /\n\t\t// CellStyleXf.\n\t\tc.Assert(xSheet.SheetData.Row[0].C[0].S, qt.Equals, 0)\n\t\tc.Assert(xSheet.SheetData.Row[0].C[1].S, qt.Equals, 0)\n\t})\n\n\t// If the column width is customised, the xslxCol.CustomWidth field is set to 1.\n\tcsRunO(c, \"SetCustomColWidth\", func(c *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Sheet1\")\n\t\trow := sheet.AddRow()\n\t\tcell1 := row.AddCell()\n\t\tcell1.Value = \"A cell!\"\n\t\tsheet.SetColWidth(1, 1, 10.5)\n\t\tvar buf bytes.Buffer\n\n\t\trefTable := NewSharedStringRefTable(1)\n\t\tstyles := newXlsxStyleSheet(nil)\n\t\terr := sheet.MarshalSheet(&buf, refTable, styles, nil)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tvar xSheet xlsxWorksheet\n\t\terr = xml.Unmarshal(buf.Bytes(), &xSheet)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(*xSheet.Cols.Col[0].CustomWidth, qt.Equals, true)\n\t})\n\n\tcsRunO(c, \"SetColWidth\", func(c *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Sheet1\")\n\t\tsheet.SetColWidth(1, 1, 10.5)\n\t\tsheet.SetColWidth(2, 6, 11)\n\t\tc.Assert(*sheet.Cols.FindColByIndex(1).Width, qt.Equals, 10.5)\n\t\tc.Assert(sheet.Cols.FindColByIndex(1).Max, qt.Equals, 1)\n\t\tc.Assert(sheet.Cols.FindColByIndex(1).Min, qt.Equals, 1)\n\t\tc.Assert(*sheet.Cols.FindColByIndex(2).Width, qt.Equals, float64(11))\n\t\tc.Assert(sheet.Cols.FindColByIndex(2).Max, qt.Equals, 6)\n\t\tc.Assert(sheet.Cols.FindColByIndex(2).Min, qt.Equals, 2)\n\t})\n\n\tcsRunO(c, \"SetColAutoWidth\", func(c *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Sheet1\")\n\t\trow := sheet.AddRow()\n\t\tcell11 := row.AddCell()\n\t\tcell11.Value = \"test 1\"\n\t\tcell12 := row.AddCell()\n\t\tcell12.Value = \"something else\"\n\n\t\tsheet.SetColAutoWidth(1, DefaultAutoWidth)\n\n\t\tscaleFunc := func(s string) float64 {\n\t\t\treturn float64(strings.Count(s, \"\")) * 1.5\n\t\t}\n\t\tsheet.SetColAutoWidth(2, scaleFunc)\n\n\t\tc.Assert(*sheet.Cols.FindColByIndex(1).Width, qt.Equals, 12.0)\n\t\tc.Assert(sheet.Cols.FindColByIndex(1).Max, qt.Equals, 1)\n\t\tc.Assert(sheet.Cols.FindColByIndex(1).Min, qt.Equals, 1)\n\n\t\tc.Assert(*sheet.Cols.FindColByIndex(2).Width, qt.Equals, 22.5)\n\t\tc.Assert(sheet.Cols.FindColByIndex(2).Max, qt.Equals, 2)\n\t\tc.Assert(sheet.Cols.FindColByIndex(2).Min, qt.Equals, 2)\n\t})\n\n\tcsRunO(c, \"SetDataValidation\", func(c *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Sheet1\")\n\n\t\tdd := NewDataValidation(0, 0, 10, 0, true)\n\t\terr := dd.SetDropList([]string{\"a1\", \"a2\", \"a3\"})\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tsheet.AddDataValidation(dd)\n\t\tc.Assert(sheet.DataValidations, qt.HasLen, 1)\n\t\tc.Assert(sheet.DataValidations[0], qt.Equals, dd)\n\t})\n\n\tcsRunO(c, \"Border\", func(c *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Sheet1\")\n\t\trow := sheet.AddRow()\n\n\t\tcell1 := row.AddCell()\n\t\tcell1.Value = \"A cell!\"\n\t\tstyle1 := NewStyle()\n\t\tstyle1.Border = *NewBorder(\"thin\", \"thin\", \"thin\", \"thin\")\n\t\tstyle1.ApplyBorder = true\n\t\tcell1.SetStyle(style1)\n\t\tvar buf bytes.Buffer\n\n\t\trefTable := NewSharedStringRefTable(1)\n\t\tstyles := newXlsxStyleSheet(nil)\n\t\terr := sheet.MarshalSheet(&buf, refTable, styles, nil)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tvar xSheet xlsxWorksheet\n\t\terr = xml.Unmarshal(buf.Bytes(), &xSheet)\n\t\tc.Assert(err, qt.Equals, nil)\n\n\t\tc.Assert(styles.Borders.Border, qt.HasLen, 1)\n\t\tc.Assert(styles.Borders.Border[0].Left.Style, qt.Equals, \"thin\")\n\t\tc.Assert(styles.Borders.Border[0].Right.Style, qt.Equals, \"thin\")\n\t\tc.Assert(styles.Borders.Border[0].Top.Style, qt.Equals, \"thin\")\n\t\tc.Assert(styles.Borders.Border[0].Bottom.Style, qt.Equals, \"thin\")\n\n\t\tc.Assert(xSheet.SheetData.Row[0].C[0].S, qt.Equals, 0)\n\t})\n\n\tcsRunO(c, \"OutlineLevels\", func(c *qt.C, option FileOption) {\n\t\tfile := NewFile(option)\n\t\tsheet, _ := file.AddSheet(\"Sheet1\")\n\n\t\tr1 := sheet.AddRow()\n\t\tc11 := r1.AddCell()\n\t\tc11.Value = \"A1\"\n\n\t\tc12 := r1.AddCell()\n\t\tc12.Value = \"B1\"\n\t\tr1.SetOutlineLevel(1)\n\n\t\tr2 := sheet.AddRow()\n\t\tc21 := r2.AddCell()\n\t\tc21.Value = \"A2\"\n\n\t\tc22 := r2.AddCell()\n\t\tc22.Value = \"B2\"\n\t\tr2.SetOutlineLevel(2)\n\n\t\tr3 := sheet.AddRow()\n\t\tc31 := r3.AddCell()\n\t\tc31.Value = \"A3\"\n\t\tc32 := r3.AddCell()\n\t\tc32.Value = \"B3\"\n\n\t\t// Add some groups\n\t\tsheet.SetOutlineLevel(1, 1, 1)\n\n\t\t// var buf bytes.Buffer\n\n\t\trefTable := NewSharedStringRefTable(9)\n\t\tstyles := newXlsxStyleSheet(nil)\n\n\t\txSheet := sheet.makeXLSXSheet(refTable, styles, nil)\n\t\t// err := sheet.MarshalSheet(&buf, refTable, styles, nil)\n\t\t// c.Assert(err, qt.Equals, nil)\n\t\t// var xSheet xlsxWorksheet\n\t\t// err = xml.Unmarshal(buf.Bytes(), &xSheet)\n\t\t// c.Assert(err, qt.Equals, nil)\n\n\t\tc.Assert(xSheet.SheetFormatPr.OutlineLevelCol, qt.Equals, uint8(1))\n\t\tc.Assert(xSheet.SheetFormatPr.OutlineLevelRow, qt.Equals, uint8(2))\n\n\t\tc.Assert(*xSheet.Cols.Col[0].OutlineLevel, qt.Equals, uint8(1))\n\t\tc.Assert(xSheet.SheetData.Row, qt.HasLen, 3)\n\t\tc.Assert(xSheet.SheetData.Row[0].OutlineLevel, qt.Equals, uint8(1))\n\t\tc.Assert(xSheet.SheetData.Row[1].OutlineLevel, qt.Equals, uint8(2))\n\t\tc.Assert(xSheet.SheetData.Row[2].OutlineLevel, qt.Equals, uint8(0))\n\t})\n}\n\nfunc TestIssue809(t *testing.T) {\n\tc := qt.New(t)\n\n\tcsRunO(c, \"Issue809\", func(c *qt.C, option FileOption) {\n\t\toutfile := filepath.Join(t.TempDir(), \"bug809.xlsx\")\n\t\tf := NewFile(option)\n\t\tsh, err := f.AddSheet(\"Sheet1\")\n\t\tc.Assert(err, qt.IsNil)\n\n\t\t// Write Colors (y-axis).\n\t\tcolors := []string{\"Red\", \"Green\", \"Blue\"}\n\t\tfor i, clr := range colors {\n\t\t\tcell, _ := sh.Cell(i+1, 0)\n\t\t\tcell.SetString(clr)\n\t\t}\n\n\t\t// Write Numbers (x-axis).\n\t\tnumbers := []string{\"1\", \"2\", \"3\"}\n\t\tfor i, num := range numbers {\n\t\t\tcell, _ := sh.Cell(0, i+1)\n\t\t\tcell.SetString(num)\n\t\t}\n\n\t\tc.Assert(f.Save(outfile), qt.IsNil)\n\n\t\tf = nil\n\n\t\tf2, err := OpenFile(outfile, option)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tsh2, ok := f2.Sheet[\"Sheet1\"]\n\t\tc.Assert(ok, qt.IsTrue)\n\n\t\tfor i, clr := range colors {\n\t\t\tcell, err := sh2.Cell(i+1, 0)\n\t\t\tc.Assert(err, qt.IsNil)\n\t\t\tt.Logf(\"%q == %q?\\n\", cell.String(), clr)\n\t\t\tc.Assert(cell.String(), qt.Equals, clr)\n\t\t}\n\n\t\tfor i, num := range numbers {\n\t\t\tcell, err := sh2.Cell(0, i+1)\n\t\t\tc.Assert(err, qt.IsNil)\n\t\t\tc.Assert(cell.String(), qt.Equals, num)\n\t\t}\n\t})\n}\n\nfunc TestTemp(t *testing.T) {\n\tc := qt.New(t)\n\toption := UseDiskVCellStore\n\tfile := NewFile(option)\n\tsheet, _ := file.AddSheet(\"Sheet1\")\n\trow := sheet.AddRow()\n\tcell := row.AddCell()\n\tcell.Value = \"A cell!\"\n\n\tvar buf bytes.Buffer\n\n\trefTable := NewSharedStringRefTable(1)\n\tstyles := newXlsxStyleSheet(nil)\n\terr := sheet.MarshalSheet(&buf, refTable, styles, nil)\n\tc.Assert(err, qt.Equals, nil)\n\tvar xSheet xlsxWorksheet\n\terr = xml.Unmarshal(buf.Bytes(), &xSheet)\n\tc.Assert(err, qt.Equals, nil)\n\n\tc.Assert(xSheet.Dimension.Ref, qt.Equals, \"A1\")\n\tc.Assert(len(xSheet.SheetData.Row), qt.Equals, 1)\n\txRow := xSheet.SheetData.Row[0]\n\tc.Assert(xRow.R, qt.Equals, 1)\n\tc.Assert(xRow.Spans, qt.Equals, \"\")\n\tc.Assert(len(xRow.C), qt.Equals, 1)\n\txC := xRow.C[0]\n\tc.Assert(xC.R, qt.Equals, \"A1\")\n\tc.Assert(xC.S, qt.Equals, 0)\n\tc.Assert(xC.T, qt.Equals, \"s\") // Shared string type\n\tc.Assert(xC.V, qt.Equals, \"0\") // reference to shared string\n\txSST := refTable.makeXLSXSST()\n\tc.Assert(xSST.Count, qt.Equals, 1)\n\tc.Assert(xSST.UniqueCount, qt.Equals, 1)\n\tc.Assert(len(xSST.SI), qt.Equals, 1)\n\txSI := xSST.SI[0]\n\tc.Assert(xSI.T.Text, qt.Equals, \"A cell!\")\n\tc.Assert(xSI.R, qt.HasLen, 0)\n}\n\nfunc TestAddEmptyRow(t *testing.T) {\n\tc := qt.New(t)\n\tsourceFile, err := OpenFile(\"./testdocs/original.xlsx\")\n\tc.Assert(err, qt.IsNil)\n\tsheet := sourceFile.Sheets[0]\n\tc.Assert(sheet, qt.IsNotNil)\n\tfirstRow, err := sheet.Row(0)\n\tc.Assert(err, qt.IsNil)\n\tcellStr := firstRow.GetCell(0).String()\n\tt.Logf(\"cell: %s\", cellStr)\n\n\tmaxRow := sheet.MaxRow\n\t_, err = sheet.Row(maxRow)\n\tc.Assert(err, qt.IsNil)\n\n\tfirstRow, err = sheet.Row(0)\n\tc.Assert(err, qt.IsNil)\n\tcellStr2 := firstRow.GetCell(0).String()\n\tt.Logf(\"cell: %s\", cellStr2)\n\tc.Assert(cellStr, qt.Equals, cellStr2)\n}\n"
        },
        {
          "name": "style.go",
          "type": "blob",
          "size": 4.6513671875,
          "content": "package xlsx\n\nimport \"strconv\"\n\n// Several popular font names that can be used to create fonts\nconst (\n\tHelvetica     = \"Helvetica\"\n\tBaskerville   = \"Baskerville Old Face\"\n\tTimesNewRoman = \"Times New Roman\"\n\tBodoni        = \"Bodoni MT\"\n\tGillSans      = \"Gill Sans MT\"\n\tCourier       = \"Courier\"\n)\n\nconst (\n\tRGB_Light_Green = \"FFC6EFCE\"\n\tRGB_Dark_Green  = \"FF006100\"\n\tRGB_Light_Red   = \"FFFFC7CE\"\n\tRGB_Dark_Red    = \"FF9C0006\"\n\tRGB_White       = \"FFFFFFFF\"\n\tRGB_Black       = \"00000000\"\n)\n\nconst (\n\tSolid_Cell_Fill = \"solid\"\n)\n\n// Style is a high level structure intended to provide user access to\n// the contents of Style within an XLSX file.\ntype Style struct {\n\tBorder          Border\n\tFill            Fill\n\tFont            Font\n\tApplyBorder     bool\n\tApplyFill       bool\n\tApplyFont       bool\n\tApplyAlignment  bool\n\tAlignment       Alignment\n\tNamedStyleIndex *int\n}\n\n// Return a new Style structure initialised with the default values.\nfunc NewStyle() *Style {\n\treturn &Style{\n\t\tAlignment: *DefaultAlignment(),\n\t\tBorder:    *DefaultBorder(),\n\t\tFill:      *DefaultFill(),\n\t\tFont:      *DefaultFont(),\n\t}\n}\n\n// Generate the underlying XLSX style elements that correspond to the Style.\nfunc (style *Style) makeXLSXStyleElements() (xFont xlsxFont, xFill xlsxFill, xBorder xlsxBorder, xCellXf xlsxXf) {\n\tif style == nil {\n\t\tpanic(\"Called makeXLSXStyleElements on a nil *Style!\")\n\t}\n\n\txFont = xlsxFont{}\n\txFill = xlsxFill{}\n\txBorder = xlsxBorder{}\n\txCellXf = xlsxXf{}\n\txFont.Sz.Val = strconv.FormatFloat(style.Font.Size, 'f', -1, 64)\n\txFont.Name.Val = style.Font.Name\n\txFont.Family.Val = strconv.Itoa(style.Font.Family)\n\txFont.Charset.Val = strconv.Itoa(style.Font.Charset)\n\txFont.Color.RGB = style.Font.Color\n\n\tif style.Font.Bold {\n\t\txFont.B = &xlsxVal{}\n\t} else {\n\t\txFont.B = nil\n\t}\n\tif style.Font.Italic {\n\t\txFont.I = &xlsxVal{}\n\t} else {\n\t\txFont.I = nil\n\t}\n\tif style.Font.Underline {\n\t\txFont.U = &xlsxVal{}\n\t} else {\n\t\txFont.U = nil\n\t}\n\tif style.Font.Strike {\n\t\txFont.Strike = &xlsxVal{}\n\t} else {\n\t\txFont.Strike = nil\n\t}\n\txPatternFill := xlsxPatternFill{}\n\txPatternFill.PatternType = style.Fill.PatternType\n\txPatternFill.FgColor.RGB = style.Fill.FgColor\n\txPatternFill.BgColor.RGB = style.Fill.BgColor\n\txFill.PatternFill = xPatternFill\n\txBorder.Left = xlsxLine{\n\t\tStyle: style.Border.Left,\n\t\tColor: xlsxColor{RGB: style.Border.LeftColor},\n\t}\n\txBorder.Right = xlsxLine{\n\t\tStyle: style.Border.Right,\n\t\tColor: xlsxColor{RGB: style.Border.RightColor},\n\t}\n\txBorder.Top = xlsxLine{\n\t\tStyle: style.Border.Top,\n\t\tColor: xlsxColor{RGB: style.Border.TopColor},\n\t}\n\txBorder.Bottom = xlsxLine{\n\t\tStyle: style.Border.Bottom,\n\t\tColor: xlsxColor{RGB: style.Border.BottomColor},\n\t}\n\txCellXf = makeXLSXCellElement()\n\txCellXf.ApplyBorder = style.ApplyBorder\n\txCellXf.ApplyFill = style.ApplyFill\n\txCellXf.ApplyFont = style.ApplyFont\n\txCellXf.ApplyAlignment = style.ApplyAlignment\n\tif style.NamedStyleIndex != nil {\n\t\txCellXf.XfId = style.NamedStyleIndex\n\t}\n\treturn\n}\n\nfunc makeXLSXCellElement() (xCellXf xlsxXf) {\n\txCellXf.NumFmtId = 0\n\treturn\n}\n\n// Border is a high level structure intended to provide user access to\n// the contents of Border Style within an Sheet.\ntype Border struct {\n\tLeft        string\n\tLeftColor   string\n\tRight       string\n\tRightColor  string\n\tTop         string\n\tTopColor    string\n\tBottom      string\n\tBottomColor string\n}\n\nfunc NewBorder(left, right, top, bottom string) *Border {\n\treturn &Border{\n\t\tLeft:   left,\n\t\tRight:  right,\n\t\tTop:    top,\n\t\tBottom: bottom,\n\t}\n}\n\n// Fill is a high level structure intended to provide user access to\n// the contents of background and foreground color index within an Sheet.\ntype Fill struct {\n\tPatternType string\n\tBgColor     string\n\tFgColor     string\n}\n\nfunc NewFill(patternType, fgColor, bgColor string) *Fill {\n\treturn &Fill{\n\t\tPatternType: patternType,\n\t\tFgColor:     fgColor,\n\t\tBgColor:     bgColor,\n\t}\n}\n\ntype Font struct {\n\tSize      float64\n\tName      string\n\tFamily    int\n\tCharset   int\n\tColor     string\n\tBold      bool\n\tItalic    bool\n\tUnderline bool\n\tStrike    bool\n}\n\nfunc NewFont(size float64, name string) *Font {\n\treturn &Font{Size: size, Name: name}\n}\n\ntype Alignment struct {\n\tHorizontal   string\n\tIndent       int\n\tShrinkToFit  bool\n\tTextRotation int\n\tVertical     string\n\tWrapText     bool\n}\n\nvar defaultFontSize = 12.0\nvar defaultFontName = \"Verdana\"\n\nfunc SetDefaultFont(size float64, name string) {\n\tdefaultFontSize = size\n\tdefaultFontName = name\n}\n\nfunc DefaultFont() *Font {\n\treturn NewFont(defaultFontSize, defaultFontName)\n}\n\nfunc DefaultFill() *Fill {\n\treturn NewFill(\"none\", \"\", \"\")\n\n}\n\nfunc DefaultBorder() *Border {\n\treturn NewBorder(\"none\", \"none\", \"none\", \"none\")\n}\n\nfunc DefaultAlignment() *Alignment {\n\treturn &Alignment{\n\t\tHorizontal: \"general\",\n\t\tVertical:   \"bottom\",\n\t}\n}\n"
        },
        {
          "name": "style_test.go",
          "type": "blob",
          "size": 2.740234375,
          "content": "package xlsx\n\nimport (\n\t\"testing\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\nfunc TestStyle(t *testing.T) {\n\n\tc := qt.New(t)\n\n\tc.Run(\"TestNewStyle\", func(c *qt.C) {\n\t\tstyle := NewStyle()\n\t\tc.Assert(style, qt.Not(qt.IsNil))\n\t})\n\n\tc.Run(\"TestNewStyleDefaultts\", func(c *qt.C) {\n\t\tstyle := NewStyle()\n\t\tc.Assert(style.Font, qt.Equals, *DefaultFont())\n\t\tc.Assert(style.Fill, qt.Equals, *DefaultFill())\n\t\tc.Assert(style.Border, qt.Equals, *DefaultBorder())\n\t})\n\n\tc.Run(\"TestMakeXLSXStyleElements\", func(c *qt.C) {\n\t\tstyle := NewStyle()\n\t\tfont := *NewFont(12, \"Verdana\")\n\t\tfont.Bold = true\n\t\tfont.Italic = true\n\t\tfont.Underline = true\n\t\tfont.Strike = true\n\t\tstyle.Font = font\n\t\tfill := *NewFill(\"solid\", \"00FF0000\", \"FF000000\")\n\t\tstyle.Fill = fill\n\t\tborder := *NewBorder(\"thin\", \"thin\", \"thin\", \"thin\")\n\t\tstyle.Border = border\n\t\tstyle.ApplyBorder = true\n\t\tstyle.ApplyFill = true\n\n\t\tstyle.ApplyFont = true\n\t\txFont, xFill, xBorder, xCellXf := style.makeXLSXStyleElements()\n\t\tc.Assert(xFont.Sz.Val, qt.Equals, \"12\")\n\t\tc.Assert(xFont.Name.Val, qt.Equals, \"Verdana\")\n\t\tc.Assert(xFont.B, qt.Not(qt.IsNil))\n\t\tc.Assert(xFont.I, qt.Not(qt.IsNil))\n\t\tc.Assert(xFont.U, qt.Not(qt.IsNil))\n\t\tc.Assert(xFont.Strike, qt.Not(qt.IsNil))\n\t\tc.Assert(xFill.PatternFill.PatternType, qt.Equals, \"solid\")\n\t\tc.Assert(xFill.PatternFill.FgColor.RGB, qt.Equals, \"00FF0000\")\n\t\tc.Assert(xFill.PatternFill.BgColor.RGB, qt.Equals, \"FF000000\")\n\t\tc.Assert(xBorder.Left.Style, qt.Equals, \"thin\")\n\t\tc.Assert(xBorder.Right.Style, qt.Equals, \"thin\")\n\t\tc.Assert(xBorder.Top.Style, qt.Equals, \"thin\")\n\t\tc.Assert(xBorder.Bottom.Style, qt.Equals, \"thin\")\n\t\tc.Assert(xCellXf.ApplyBorder, qt.Equals, true)\n\t\tc.Assert(xCellXf.ApplyFill, qt.Equals, true)\n\t\tc.Assert(xCellXf.ApplyFont, qt.Equals, true)\n\n\t})\n}\n\nfunc TestReadCellColorBackground(t *testing.T) {\n\tc := qt.New(t)\n\tcsRunO(c, \"ReadCellColorBackground\", func(c *qt.C, option FileOption) {\n\t\txFile, err := OpenFile(\"./testdocs/color_stylesheet.xlsx\", option)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tc.Assert(xFile.styles.Fills.Fill, qt.HasLen, 4)\n\t\tc.Assert(xFile.styles.Colors.IndexedColors, qt.HasLen, 64)\n\t\tsheet := xFile.Sheets[0]\n\t\tcell, err := sheet.Cell(0, 1)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tstyle := cell.GetStyle()\n\t\tc.Assert(style.Fill, qt.Equals, *NewFill(\"none\", \"\", \"\"))\n\t\tcell, err = sheet.Cell(1, 1)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tstyle = cell.GetStyle()\n\t\tc.Assert(style.Fill, qt.Equals, *NewFill(\"solid\", \"00FFCC99\", \"\"))\n\t\tcell, err = sheet.Cell(2, 1)\n\t\tc.Assert(err, qt.Equals, nil)\n\t\tstyle = cell.GetStyle()\n\t\tc.Assert(style.Fill, qt.Equals, *NewFill(\"solid\", \"FF990099\", \"\"))\n\t})\n}\n\nfunc TestNewFont(t *testing.T) {\n\tc := qt.New(t)\n\tfont := NewFont(12.2, \"Verdana\")\n\tc.Assert(font, qt.Not(qt.IsNil))\n\tc.Assert(font.Name, qt.Equals, \"Verdana\")\n\tc.Assert(font.Size, qt.Equals, 12.2)\n}\n"
        },
        {
          "name": "templates.go",
          "type": "blob",
          "size": 12.1533203125,
          "content": "// This file contains default templates for XML files we don't yet\n// populated based on content.\n\npackage xlsx\n\nconst TEMPLATE__RELS_DOT_RELS = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\n  <Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\" Target=\"xl/workbook.xml\"/>\n  <Relationship Id=\"rId2\" Type=\"http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties\" Target=\"docProps/core.xml\"/>\n  <Relationship Id=\"rId3\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties\" Target=\"docProps/app.xml\"/>\n</Relationships>`\n\nconst TEMPLATE_DOCPROPS_APP = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<Properties xmlns=\"http://schemas.openxmlformats.org/officeDocument/2006/extended-properties\" xmlns:vt=\"http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes\">\n  <TotalTime>0</TotalTime>\n  <Application>Go XLSX</Application>\n</Properties>`\n\nconst TEMPLATE_DOCPROPS_CORE = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<cp:coreProperties xmlns:cp=\"http://schemas.openxmlformats.org/package/2006/metadata/core-properties\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:dcmitype=\"http://purl.org/dc/dcmitype/\" xmlns:dcterms=\"http://purl.org/dc/terms/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"></cp:coreProperties>`\n\nconst TEMPLATE_XL_THEME_THEME = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<a:theme xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" name=\"Office-Design\">\n  <a:themeElements>\n    <a:clrScheme name=\"Office\">\n      <a:dk1>\n        <a:sysClr val=\"windowText\" lastClr=\"000000\"/>\n      </a:dk1>\n      <a:lt1>\n        <a:sysClr val=\"window\" lastClr=\"FFFFFF\"/>\n      </a:lt1>\n      <a:dk2>\n        <a:srgbClr val=\"1F497D\"/>\n      </a:dk2>\n      <a:lt2>\n        <a:srgbClr val=\"EEECE1\"/>\n      </a:lt2>\n      <a:accent1>\n        <a:srgbClr val=\"4F81BD\"/>\n      </a:accent1>\n      <a:accent2>\n        <a:srgbClr val=\"C0504D\"/>\n      </a:accent2>\n      <a:accent3>\n        <a:srgbClr val=\"9BBB59\"/>\n      </a:accent3>\n      <a:accent4>\n        <a:srgbClr val=\"8064A2\"/>\n      </a:accent4>\n      <a:accent5>\n        <a:srgbClr val=\"4BACC6\"/>\n      </a:accent5>\n      <a:accent6>\n        <a:srgbClr val=\"F79646\"/>\n      </a:accent6>\n      <a:hlink>\n        <a:srgbClr val=\"0000FF\"/>\n      </a:hlink>\n      <a:folHlink>\n        <a:srgbClr val=\"800080\"/>\n      </a:folHlink>\n    </a:clrScheme>\n    <a:fontScheme name=\"Office\">\n      <a:majorFont>\n        <a:latin typeface=\"Cambria\"/>\n        <a:ea typeface=\"\"/>\n        <a:cs typeface=\"\"/>\n        <a:font script=\"Jpan\" typeface=\"ＭＳ Ｐゴシック\"/>\n        <a:font script=\"Hang\" typeface=\"맑은 고딕\"/>\n        <a:font script=\"Hans\" typeface=\"宋体\"/>\n        <a:font script=\"Hant\" typeface=\"新細明體\"/>\n        <a:font script=\"Arab\" typeface=\"Times New Roman\"/>\n        <a:font script=\"Hebr\" typeface=\"Times New Roman\"/>\n        <a:font script=\"Thai\" typeface=\"Tahoma\"/>\n        <a:font script=\"Ethi\" typeface=\"Nyala\"/>\n        <a:font script=\"Beng\" typeface=\"Vrinda\"/>\n        <a:font script=\"Gujr\" typeface=\"Shruti\"/>\n        <a:font script=\"Khmr\" typeface=\"MoolBoran\"/>\n        <a:font script=\"Knda\" typeface=\"Tunga\"/>\n        <a:font script=\"Guru\" typeface=\"Raavi\"/>\n        <a:font script=\"Cans\" typeface=\"Euphemia\"/>\n        <a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/>\n        <a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/>\n        <a:font script=\"Tibt\" typeface=\"Microsoft Himalaya\"/>\n        <a:font script=\"Thaa\" typeface=\"MV Boli\"/>\n        <a:font script=\"Deva\" typeface=\"Mangal\"/>\n        <a:font script=\"Telu\" typeface=\"Gautami\"/>\n        <a:font script=\"Taml\" typeface=\"Latha\"/>\n        <a:font script=\"Syrc\" typeface=\"Estrangelo Edessa\"/>\n        <a:font script=\"Orya\" typeface=\"Kalinga\"/>\n        <a:font script=\"Mlym\" typeface=\"Kartika\"/>\n        <a:font script=\"Laoo\" typeface=\"DokChampa\"/>\n        <a:font script=\"Sinh\" typeface=\"Iskoola Pota\"/>\n        <a:font script=\"Mong\" typeface=\"Mongolian Baiti\"/>\n        <a:font script=\"Viet\" typeface=\"Times New Roman\"/>\n        <a:font script=\"Uigh\" typeface=\"Microsoft Uighur\"/>\n        <a:font script=\"Geor\" typeface=\"Sylfaen\"/>\n      </a:majorFont>\n      <a:minorFont>\n        <a:latin typeface=\"Arial\"/>\n        <a:ea typeface=\"\"/>\n        <a:cs typeface=\"\"/>\n        <a:font script=\"Jpan\" typeface=\"ＭＳ Ｐゴシック\"/>\n        <a:font script=\"Hang\" typeface=\"맑은 고딕\"/>\n        <a:font script=\"Hans\" typeface=\"宋体\"/>\n        <a:font script=\"Hant\" typeface=\"新細明體\"/>\n        <a:font script=\"Arab\" typeface=\"Arial\"/>\n        <a:font script=\"Hebr\" typeface=\"Arial\"/>\n        <a:font script=\"Thai\" typeface=\"Tahoma\"/>\n        <a:font script=\"Ethi\" typeface=\"Nyala\"/>\n        <a:font script=\"Beng\" typeface=\"Vrinda\"/>\n        <a:font script=\"Gujr\" typeface=\"Shruti\"/>\n        <a:font script=\"Khmr\" typeface=\"DaunPenh\"/>\n        <a:font script=\"Knda\" typeface=\"Tunga\"/>\n        <a:font script=\"Guru\" typeface=\"Raavi\"/>\n        <a:font script=\"Cans\" typeface=\"Euphemia\"/>\n        <a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/>\n        <a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/>\n        <a:font script=\"Tibt\" typeface=\"Microsoft Himalaya\"/>\n        <a:font script=\"Thaa\" typeface=\"MV Boli\"/>\n        <a:font script=\"Deva\" typeface=\"Mangal\"/>\n        <a:font script=\"Telu\" typeface=\"Gautami\"/>\n        <a:font script=\"Taml\" typeface=\"Latha\"/>\n        <a:font script=\"Syrc\" typeface=\"Estrangelo Edessa\"/>\n        <a:font script=\"Orya\" typeface=\"Kalinga\"/>\n        <a:font script=\"Mlym\" typeface=\"Kartika\"/>\n        <a:font script=\"Laoo\" typeface=\"DokChampa\"/>\n        <a:font script=\"Sinh\" typeface=\"Iskoola Pota\"/>\n        <a:font script=\"Mong\" typeface=\"Mongolian Baiti\"/>\n        <a:font script=\"Viet\" typeface=\"Arial\"/>\n        <a:font script=\"Uigh\" typeface=\"Microsoft Uighur\"/>\n        <a:font script=\"Geor\" typeface=\"Sylfaen\"/>\n      </a:minorFont>\n    </a:fontScheme>\n    <a:fmtScheme name=\"Office\">\n      <a:fillStyleLst>\n        <a:solidFill>\n          <a:schemeClr val=\"phClr\"/>\n        </a:solidFill>\n        <a:gradFill rotWithShape=\"1\">\n          <a:gsLst>\n            <a:gs pos=\"0\">\n              <a:schemeClr val=\"phClr\">\n                <a:tint val=\"50000\"/>\n                <a:satMod val=\"300000\"/>\n              </a:schemeClr>\n            </a:gs>\n            <a:gs pos=\"35000\">\n              <a:schemeClr val=\"phClr\">\n                <a:tint val=\"37000\"/>\n                <a:satMod val=\"300000\"/>\n              </a:schemeClr>\n            </a:gs>\n            <a:gs pos=\"100000\">\n              <a:schemeClr val=\"phClr\">\n                <a:tint val=\"15000\"/>\n                <a:satMod val=\"350000\"/>\n              </a:schemeClr>\n            </a:gs>\n          </a:gsLst>\n          <a:lin ang=\"16200000\" scaled=\"1\"/>\n        </a:gradFill>\n        <a:gradFill rotWithShape=\"1\">\n          <a:gsLst>\n            <a:gs pos=\"0\">\n              <a:schemeClr val=\"phClr\">\n                <a:tint val=\"100000\"/>\n                <a:shade val=\"100000\"/>\n                <a:satMod val=\"130000\"/>\n              </a:schemeClr>\n            </a:gs>\n            <a:gs pos=\"100000\">\n              <a:schemeClr val=\"phClr\">\n                <a:tint val=\"50000\"/>\n                <a:shade val=\"100000\"/>\n                <a:satMod val=\"350000\"/>\n              </a:schemeClr>\n            </a:gs>\n          </a:gsLst>\n          <a:lin ang=\"16200000\" scaled=\"0\"/>\n        </a:gradFill>\n      </a:fillStyleLst>\n      <a:lnStyleLst>\n        <a:ln w=\"9525\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\">\n          <a:solidFill>\n            <a:schemeClr val=\"phClr\">\n              <a:shade val=\"95000\"/>\n              <a:satMod val=\"105000\"/>\n            </a:schemeClr>\n          </a:solidFill>\n          <a:prstDash val=\"solid\"/>\n        </a:ln>\n        <a:ln w=\"25400\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\">\n          <a:solidFill>\n            <a:schemeClr val=\"phClr\"/>\n          </a:solidFill>\n          <a:prstDash val=\"solid\"/>\n        </a:ln>\n        <a:ln w=\"38100\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\">\n          <a:solidFill>\n            <a:schemeClr val=\"phClr\"/>\n          </a:solidFill>\n          <a:prstDash val=\"solid\"/>\n        </a:ln>\n      </a:lnStyleLst>\n      <a:effectStyleLst>\n        <a:effectStyle>\n          <a:effectLst>\n            <a:outerShdw blurRad=\"40000\" dist=\"20000\" dir=\"5400000\" rotWithShape=\"0\">\n              <a:srgbClr val=\"000000\">\n                <a:alpha val=\"38000\"/>\n              </a:srgbClr>\n            </a:outerShdw>\n          </a:effectLst>\n        </a:effectStyle>\n        <a:effectStyle>\n          <a:effectLst>\n            <a:outerShdw blurRad=\"40000\" dist=\"23000\" dir=\"5400000\" rotWithShape=\"0\">\n              <a:srgbClr val=\"000000\">\n                <a:alpha val=\"35000\"/>\n              </a:srgbClr>\n            </a:outerShdw>\n          </a:effectLst>\n        </a:effectStyle>\n        <a:effectStyle>\n          <a:effectLst>\n            <a:outerShdw blurRad=\"40000\" dist=\"23000\" dir=\"5400000\" rotWithShape=\"0\">\n              <a:srgbClr val=\"000000\">\n                <a:alpha val=\"35000\"/>\n              </a:srgbClr>\n            </a:outerShdw>\n          </a:effectLst>\n          <a:scene3d>\n            <a:camera prst=\"orthographicFront\">\n              <a:rot lat=\"0\" lon=\"0\" rev=\"0\"/>\n            </a:camera>\n            <a:lightRig rig=\"threePt\" dir=\"t\">\n              <a:rot lat=\"0\" lon=\"0\" rev=\"1200000\"/>\n            </a:lightRig>\n          </a:scene3d>\n          <a:sp3d>\n            <a:bevelT w=\"63500\" h=\"25400\"/>\n          </a:sp3d>\n        </a:effectStyle>\n      </a:effectStyleLst>\n      <a:bgFillStyleLst>\n        <a:solidFill>\n          <a:schemeClr val=\"phClr\"/>\n        </a:solidFill>\n        <a:gradFill rotWithShape=\"1\">\n          <a:gsLst>\n            <a:gs pos=\"0\">\n              <a:schemeClr val=\"phClr\">\n                <a:tint val=\"40000\"/>\n                <a:satMod val=\"350000\"/>\n              </a:schemeClr>\n            </a:gs>\n            <a:gs pos=\"40000\">\n              <a:schemeClr val=\"phClr\">\n                <a:tint val=\"45000\"/>\n                <a:shade val=\"99000\"/>\n                <a:satMod val=\"350000\"/>\n              </a:schemeClr>\n            </a:gs>\n            <a:gs pos=\"100000\">\n              <a:schemeClr val=\"phClr\">\n                <a:shade val=\"20000\"/>\n                <a:satMod val=\"255000\"/>\n              </a:schemeClr>\n            </a:gs>\n          </a:gsLst>\n          <a:path path=\"circle\">\n            <a:fillToRect l=\"50000\" t=\"-80000\" r=\"50000\" b=\"180000\"/>\n          </a:path>\n        </a:gradFill>\n        <a:gradFill rotWithShape=\"1\">\n          <a:gsLst>\n            <a:gs pos=\"0\">\n              <a:schemeClr val=\"phClr\">\n                <a:tint val=\"80000\"/>\n                <a:satMod val=\"300000\"/>\n              </a:schemeClr>\n            </a:gs>\n            <a:gs pos=\"100000\">\n              <a:schemeClr val=\"phClr\">\n                <a:shade val=\"30000\"/>\n                <a:satMod val=\"200000\"/>\n              </a:schemeClr>\n            </a:gs>\n          </a:gsLst>\n          <a:path path=\"circle\">\n            <a:fillToRect l=\"50000\" t=\"50000\" r=\"50000\" b=\"50000\"/>\n          </a:path>\n        </a:gradFill>\n      </a:bgFillStyleLst>\n    </a:fmtScheme>\n  </a:themeElements>\n  <a:objectDefaults>\n    <a:spDef>\n      <a:spPr/>\n      <a:bodyPr/>\n      <a:lstStyle/>\n      <a:style>\n        <a:lnRef idx=\"1\">\n          <a:schemeClr val=\"accent1\"/>\n        </a:lnRef>\n        <a:fillRef idx=\"3\">\n          <a:schemeClr val=\"accent1\"/>\n        </a:fillRef>\n        <a:effectRef idx=\"2\">\n          <a:schemeClr val=\"accent1\"/>\n        </a:effectRef>\n        <a:fontRef idx=\"minor\">\n          <a:schemeClr val=\"lt1\"/>\n        </a:fontRef>\n      </a:style>\n    </a:spDef>\n    <a:lnDef>\n      <a:spPr/>\n      <a:bodyPr/>\n      <a:lstStyle/>\n      <a:style>\n        <a:lnRef idx=\"2\">\n          <a:schemeClr val=\"accent1\"/>\n        </a:lnRef>\n        <a:fillRef idx=\"0\">\n          <a:schemeClr val=\"accent1\"/>\n        </a:fillRef>\n        <a:effectRef idx=\"1\">\n          <a:schemeClr val=\"accent1\"/>\n        </a:effectRef>\n        <a:fontRef idx=\"minor\">\n          <a:schemeClr val=\"tx1\"/>\n        </a:fontRef>\n      </a:style>\n    </a:lnDef>\n  </a:objectDefaults>\n  <a:extraClrSchemeLst/>\n</a:theme>`\n"
        },
        {
          "name": "testdocs",
          "type": "tree",
          "content": null
        },
        {
          "name": "testutil.go",
          "type": "blob",
          "size": 1.65625,
          "content": "package xlsx\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\n// cleanTempDir removes all the temporary files from NewDiskVCellStore\nfunc cleanTempDir(c *qt.C) {\n\ttempDirBase := os.TempDir()\n\n\tglobPattern := tempDirBase + \"/\" + cellStorePrefix + \"*\"\n\n\tdirs, err := filepath.Glob(globPattern)\n\tif err != nil {\n\t\tc.Logf(\"Cannot glob files of %s\", globPattern)\n\t\tc.FailNow()\n\t}\n\n\tfor _, directory := range dirs {\n\t\tif err = os.RemoveAll(directory); err != nil {\n\t\t\tc.Logf(\"Cannot remove files of %s\", directory)\n\t\t\tc.FailNow()\n\t\t}\n\t}\n}\n\n// csRunC will run the given test function with all available\n// CellStoreConstructors.  You must take care of setting the\n// CellStoreConstructors on the File struct or whereever else it is needed.\nfunc csRunC(c *qt.C, description string, test func(c *qt.C, constructor CellStoreConstructor)) {\n\n\tc.Run(description, func(c *qt.C) {\n\t\tc.Run(\"MemoryCellStore\", func(c *qt.C) {\n\t\t\tc.Parallel()\n\t\t\ttest(c, NewMemoryCellStore)\n\t\t})\n\t\tc.Run(\"DiskVCellStore\", func(c *qt.C) {\n\t\t\tc.Parallel()\n\t\t\ttest(c, NewDiskVCellStore)\n\t\t})\n\t})\n\n\tc.TB.Cleanup(func() {\n\t\tif !c.Failed() {\n\t\t\tcleanTempDir(c)\n\t\t}\n\t})\n}\n\n// csRunO will run the given test function with all available CellStore FileOptions, you must takes care of passing the FileOption to the appropriate method.\nfunc csRunO(c *qt.C, description string, test func(c *qt.C, option FileOption)) {\n\tc.Run(description, func(c *qt.C) {\n\t\tc.Run(\"MemoryCellStore\", func(c *qt.C) {\n\t\t\tc.Parallel()\n\t\t\ttest(c, UseMemoryCellStore)\n\t\t})\n\t\tc.Run(\"DiskVCellStore\", func(c *qt.C) {\n\t\t\tc.Parallel()\n\t\t\ttest(c, UseDiskVCellStore)\n\t\t})\n\t})\n\n\tc.TB.Cleanup(func() {\n\t\tif !c.Failed() {\n\t\t\tcleanTempDir(c)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "theme.go",
          "type": "blob",
          "size": 1.1904296875,
          "content": "package xlsx\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\ntype theme struct {\n\tcolors []string\n}\n\nfunc newTheme(themeXml xlsxTheme) *theme {\n\tclrMap := map[string]string{}\n\tclrSchemes := themeXml.ThemeElements.ClrScheme.Children\n\tfor _, scheme := range clrSchemes {\n\t\tvar rgbColor string\n\t\tif scheme.SysClr != nil {\n\t\t\trgbColor = scheme.SysClr.LastClr\n\t\t} else {\n\t\t\trgbColor = scheme.SrgbClr.Val\n\t\t}\n\t\tclrMap[scheme.XMLName.Local] = rgbColor\n\t}\n\tcolors := []string{clrMap[\"lt1\"], clrMap[\"dk1\"], clrMap[\"lt2\"], clrMap[\"dk2\"], clrMap[\"accent1\"],\n\t\tclrMap[\"accent2\"], clrMap[\"accent3\"], clrMap[\"accent4\"], clrMap[\"accent5\"],\n\t\tclrMap[\"accent6\"], clrMap[\"hlink\"], clrMap[\"folHlink\"]}\n\treturn &theme{colors}\n}\n\nfunc (t *theme) themeColor(index int64, tint float64) string {\n\tbaseColor := t.colors[index]\n\tif tint == 0 {\n\t\treturn \"FF\" + baseColor\n\t} else {\n\t\tr, _ := strconv.ParseInt(baseColor[0:2], 16, 64)\n\t\tg, _ := strconv.ParseInt(baseColor[2:4], 16, 64)\n\t\tb, _ := strconv.ParseInt(baseColor[4:6], 16, 64)\n\t\th, s, l := RGBToHSL(uint8(r), uint8(g), uint8(b))\n\t\tif tint < 0 {\n\t\t\tl *= (1 + tint)\n\t\t} else {\n\t\t\tl = l*(1-tint) + (1 - (1 - tint))\n\t\t}\n\t\tbr, bg, bb := HSLToRGB(h, s, l)\n\t\treturn fmt.Sprintf(\"FF%02X%02X%02X\", br, bg, bb)\n\t}\n}\n"
        },
        {
          "name": "theme_test.go",
          "type": "blob",
          "size": 1.986328125,
          "content": "package xlsx\n\nimport (\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"testing\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\nfunc TestThemeColors(t *testing.T) {\n\tc := qt.New(t)\n\tthemeXmlBytes := bytes.NewBufferString(`\n<?xml version=\"1.0\"?>\n<a:theme xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" name=\"Office Theme\">\n<a:themeElements>\n  <a:clrScheme name=\"Office\">\n    <a:dk1>\n      <a:sysClr val=\"windowText\" lastClr=\"000000\"/>\n    </a:dk1>\n    <a:lt1>\n      <a:sysClr val=\"window\" lastClr=\"FFFFFF\"/>\n    </a:lt1>\n    <a:dk2>\n      <a:srgbClr val=\"1F497D\"/>\n    </a:dk2>\n    <a:lt2>\n      <a:srgbClr val=\"EEECE1\"/>\n    </a:lt2>\n    <a:accent1>\n      <a:srgbClr val=\"4F81BD\"/>\n    </a:accent1>\n    <a:accent2>\n      <a:srgbClr val=\"C0504D\"/>\n    </a:accent2>\n    <a:accent3>\n      <a:srgbClr val=\"9BBB59\"/>\n    </a:accent3>\n    <a:accent4>\n      <a:srgbClr val=\"8064A2\"/>\n    </a:accent4>\n    <a:accent5>\n      <a:srgbClr val=\"4BACC6\"/>\n    </a:accent5>\n    <a:accent6>\n      <a:srgbClr val=\"F79646\"/>\n    </a:accent6>\n    <a:hlink>\n      <a:srgbClr val=\"0000FF\"/>\n    </a:hlink>\n    <a:folHlink>\n      <a:srgbClr val=\"800080\"/>\n    </a:folHlink>\n  </a:clrScheme>\n</a:themeElements>\n</a:theme>\n\t`)\n\tvar themeXml xlsxTheme\n\terr := xml.NewDecoder(themeXmlBytes).Decode(&themeXml)\n\tc.Assert(err, qt.IsNil)\n\n\tclrSchemes := themeXml.ThemeElements.ClrScheme.Children\n\tc.Assert(len(clrSchemes), qt.Equals, 12)\n\n\tdk1Scheme := clrSchemes[0]\n\tc.Assert(dk1Scheme.XMLName.Local, qt.Equals, \"dk1\")\n\tc.Assert(dk1Scheme.SrgbClr, qt.IsNil)\n\tc.Assert(dk1Scheme.SysClr, qt.IsNotNil)\n\tc.Assert(dk1Scheme.SysClr.Val, qt.Equals, \"windowText\")\n\tc.Assert(dk1Scheme.SysClr.LastClr, qt.Equals, \"000000\")\n\n\tdk2Scheme := clrSchemes[2]\n\tc.Assert(dk2Scheme.XMLName.Local, qt.Equals, \"dk2\")\n\tc.Assert(dk2Scheme.SysClr, qt.IsNil)\n\tc.Assert(dk2Scheme.SrgbClr, qt.IsNotNil)\n\tc.Assert(dk2Scheme.SrgbClr.Val, qt.Equals, \"1F497D\")\n\n\ttheme := newTheme(themeXml)\n\tc.Assert(theme.themeColor(0, 0), qt.Equals, \"FFFFFFFF\")\n\tc.Assert(theme.themeColor(2, 0), qt.Equals, \"FFEEECE1\")\n}\n"
        },
        {
          "name": "tutorial",
          "type": "tree",
          "content": null
        },
        {
          "name": "utility.go",
          "type": "blob",
          "size": 0.2373046875,
          "content": "package xlsx\n\n// sPtr simply returns a pointer to the provided string.\nfunc sPtr(s string) *string {\n\treturn &s\n}\n\nfunc fPtr(f float64) *float64 {\n\treturn &f\n}\n\nfunc bPtr(b bool) *bool {\n\treturn &b\n}\n\nfunc u8Ptr(u uint8) *uint8 {\n\treturn &u\n}\n"
        },
        {
          "name": "write.go",
          "type": "blob",
          "size": 3.9716796875,
          "content": "package xlsx\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"time\"\n)\n\n// Writes a slice to row r. Accepts a slice or a pointer to a slice,\n// and will wirte up to the provided number of columns, 'cols'.  If 'cols' is < 0,\n// the entire slice will be written if possible. Returns -1 if the 'e'\n// is not a slice type, otherwise the number of columns written.\nfunc (r *Row) WriteSlice(e interface{}, cols int) int {\n\tif e == nil {\n\t\treturn -1\n\t}\n\tif cols == 0 {\n\t\treturn cols\n\t}\n\tv := reflect.ValueOf(e)\n\tif v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\tif v.Kind() != reflect.Slice {\n\t\treturn -1\n\t}\n\t// it's a slice, so open up its values\n\tn := v.Len()\n\tif cols < n && cols > 0 {\n\t\tn = cols\n\t}\n\tvar setCell func(reflect.Value)\n\tsetCell = func(val reflect.Value) {\n\t\tswitch t := val.Interface().(type) {\n\t\tcase time.Time:\n\t\t\tcell := r.AddCell()\n\t\t\tcell.SetValue(t)\n\t\tcase fmt.Stringer: // check Stringer first\n\t\t\tcell := r.AddCell()\n\t\t\tcell.SetString(t.String())\n\t\tcase sql.NullString: // check null sql types nulls = ''\n\t\t\tcell := r.AddCell()\n\t\t\tif cell.SetString(``); t.Valid {\n\t\t\t\tcell.SetValue(t.String)\n\t\t\t}\n\t\tcase sql.NullTime:\n\t\t\tcell := r.AddCell()\n\t\t\tif cell.SetString(``); t.Valid {\n\t\t\t\tcell.SetValue(t.Time)\n\t\t\t}\n\t\tcase sql.NullBool:\n\t\t\tcell := r.AddCell()\n\t\t\tif cell.SetString(``); t.Valid {\n\t\t\t\tcell.SetBool(t.Bool)\n\t\t\t}\n\t\tcase sql.NullInt64:\n\t\t\tcell := r.AddCell()\n\t\t\tif cell.SetString(``); t.Valid {\n\t\t\t\tcell.SetValue(t.Int64)\n\t\t\t}\n\t\tcase sql.NullInt32:\n\t\t\tcell := r.AddCell()\n\t\t\tif cell.SetString(``); t.Valid {\n\t\t\t\tcell.SetValue(t.Int32)\n\t\t\t}\n\t\tcase sql.NullFloat64:\n\t\t\tcell := r.AddCell()\n\t\t\tif cell.SetString(``); t.Valid {\n\t\t\t\tcell.SetValue(t.Float64)\n\t\t\t}\n\t\tdefault:\n\t\t\tswitch val.Kind() { // underlying type of slice\n\t\t\tcase reflect.String, reflect.Int, reflect.Int8,\n\t\t\t\treflect.Int16, reflect.Int32, reflect.Int64, reflect.Float64, reflect.Float32:\n\t\t\t\tcell := r.AddCell()\n\t\t\t\tcell.SetValue(val.Interface())\n\t\t\tcase reflect.Bool:\n\t\t\t\tcell := r.AddCell()\n\t\t\t\tcell.SetBool(t.(bool))\n\t\t\tcase reflect.Interface:\n\t\t\t\tsetCell(reflect.ValueOf(t))\n\t\t\t}\n\t\t}\n\t}\n\n\tvar i int\n\tfor i = 0; i < n; i++ {\n\t\tsetCell(v.Index(i))\n\t}\n\treturn i\n}\n\n// Writes a struct to row r. Accepts a pointer to struct type 'e',\n// and the number of columns to write, `cols`. If 'cols' is < 0,\n// the entire struct will be written if possible. Returns -1 if the 'e'\n// doesn't point to a struct, otherwise the number of columns written\nfunc (r *Row) WriteStruct(e interface{}, cols int) int {\n\tif cols == 0 {\n\t\treturn cols\n\t}\n\n\tv := reflect.ValueOf(e).Elem()\n\tif v.Kind() != reflect.Struct {\n\t\treturn -1 // bail if it's not a struct\n\t}\n\n\tn := v.NumField() // number of fields in struct\n\tif cols < n && cols > 0 {\n\t\tn = cols\n\t}\n\n\tvar k int\n\tfor i := 0; i < n; i, k = i+1, k+1 {\n\t\tf := v.Field(i)\n\n\t\tswitch t := f.Interface().(type) {\n\t\tcase time.Time:\n\t\t\tcell := r.AddCell()\n\t\t\tcell.SetValue(t)\n\t\tcase fmt.Stringer: // check Stringer first\n\t\t\tcell := r.AddCell()\n\t\t\tcell.SetString(t.String())\n\t\tcase sql.NullString: // check null sql types nulls = ''\n\t\t\tcell := r.AddCell()\n\t\t\tif cell.SetString(``); t.Valid {\n\t\t\t\tcell.SetValue(t.String)\n\t\t\t}\n\t\tcase sql.NullTime:\n\t\t\tcell := r.AddCell()\n\t\t\tif cell.SetString(``); t.Valid {\n\t\t\t\tcell.SetValue(t.Time)\n\t\t\t}\n\t\tcase sql.NullBool:\n\t\t\tcell := r.AddCell()\n\t\t\tif cell.SetString(``); t.Valid {\n\t\t\t\tcell.SetBool(t.Bool)\n\t\t\t}\n\t\tcase sql.NullInt64:\n\t\t\tcell := r.AddCell()\n\t\t\tif cell.SetString(``); t.Valid {\n\t\t\t\tcell.SetValue(t.Int64)\n\t\t\t}\n\t\tcase sql.NullInt32:\n\t\t\tcell := r.AddCell()\n\t\t\tif cell.SetString(``); t.Valid {\n\t\t\t\tcell.SetValue(t.Int32)\n\t\t\t}\n\t\tcase sql.NullFloat64:\n\t\t\tcell := r.AddCell()\n\t\t\tif cell.SetString(``); t.Valid {\n\t\t\t\tcell.SetValue(t.Float64)\n\t\t\t}\n\t\tdefault:\n\t\t\tswitch f.Kind() {\n\t\t\tcase reflect.String, reflect.Int, reflect.Int8,\n\t\t\t\treflect.Int16, reflect.Int32, reflect.Int64, reflect.Float64, reflect.Float32:\n\t\t\t\tcell := r.AddCell()\n\t\t\t\tcell.SetValue(f.Interface())\n\t\t\tcase reflect.Bool:\n\t\t\t\tcell := r.AddCell()\n\t\t\t\tcell.SetBool(t.(bool))\n\t\t\tdefault:\n\t\t\t\tk-- // nothing set so reset to previous\n\t\t\t}\n\t\t}\n\t}\n\n\treturn k\n}\n"
        },
        {
          "name": "write_test.go",
          "type": "blob",
          "size": 8.9501953125,
          "content": "package xlsx\n\nimport (\n\t\"database/sql\"\n\t\"math\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\tqt \"github.com/frankban/quicktest\"\n\t\"github.com/pkg/profile\"\n)\n\ntype testStringerImpl struct {\n\tValue string\n}\n\nfunc (tsi testStringerImpl) String() string {\n\treturn tsi.Value\n}\n\nfunc TestWrite(t *testing.T) {\n\tc := qt.New(t)\n\n\t// Test if we can write a struct to a row\n\tcsRunO(c, \"TestWriteStruct\", func(c *qt.C, option FileOption) {\n\t\tf := NewFile(option)\n\t\tsheet, _ := f.AddSheet(\"Test1\")\n\t\trow := sheet.AddRow()\n\t\ttype e struct {\n\t\t\tFirstName       string\n\t\t\tAge             int\n\t\t\tGPA             float64\n\t\t\tLikesPHP        bool\n\t\t\tStringer        testStringerImpl\n\t\t\tStringerPtr     *testStringerImpl\n\t\t\tTime            time.Time\n\t\t\tLastName        sql.NullString\n\t\t\tHasPhd          sql.NullBool\n\t\t\tGithubStars     sql.NullInt64\n\t\t\tRaiting         sql.NullFloat64\n\t\t\tNullLastName    sql.NullString\n\t\t\tNullHasPhd      sql.NullBool\n\t\t\tNullGithubStars sql.NullInt32\n\t\t\tNullRaiting     sql.NullFloat64\n\t\t}\n\t\ttestStruct := e{\n\t\t\t\"Eric\",\n\t\t\t20,\n\t\t\t3.94,\n\t\t\tfalse,\n\t\t\ttestStringerImpl{\"Stringer\"},\n\t\t\t&testStringerImpl{\"Pointer to Stringer\"},\n\t\t\ttime.Unix(0, 0),\n\t\t\tsql.NullString{String: `Smith`, Valid: true},\n\t\t\tsql.NullBool{Bool: false, Valid: true},\n\t\t\tsql.NullInt64{Int64: 100, Valid: true},\n\t\t\tsql.NullFloat64{Float64: 0.123, Valid: true},\n\t\t\tsql.NullString{String: `What ever`, Valid: false},\n\t\t\tsql.NullBool{Bool: true, Valid: false},\n\t\t\tsql.NullInt32{Int32: 100, Valid: false},\n\t\t\tsql.NullFloat64{Float64: 0.123, Valid: false},\n\t\t}\n\t\tcnt := row.WriteStruct(&testStruct, -1)\n\t\tc.Assert(cnt, qt.Equals, 15)\n\t\tc.Assert(row, qt.Not(qt.IsNil))\n\n\t\tvar (\n\t\t\tc0, c4, c5, c7, c11, c12, c13, c14 string\n\t\t\terr                                error\n\t\t\tc6                                 float64\n\t\t)\n\t\tif c0, err = row.GetCell(0).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t}\n\t\tc1, e1 := row.GetCell(1).Int()\n\t\tc2, e2 := row.GetCell(2).Float()\n\t\tc3 := row.GetCell(3).Bool()\n\t\tif c4, err = row.GetCell(4).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t}\n\t\tif c5, err = row.GetCell(5).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t}\n\t\tif c6, err = row.GetCell(6).Float(); err != nil {\n\t\t\tc.Error(err)\n\t\t}\n\t\tif c7, err = row.GetCell(7).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t}\n\n\t\tc8 := row.GetCell(8).Bool()\n\t\tc9, e9 := row.GetCell(9).Int()\n\t\tc10, e10 := row.GetCell(10).Float()\n\n\t\tif c11, err = row.GetCell(11).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t}\n\t\tif c12, err = row.GetCell(12).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t}\n\t\tif c13, err = row.GetCell(13).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t}\n\t\tif c14, err = row.GetCell(14).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t}\n\n\t\tc.Assert(c0, qt.Equals, \"Eric\")\n\t\tc.Assert(c1, qt.Equals, 20)\n\t\tc.Assert(c2, qt.Equals, 3.94)\n\t\tc.Assert(c3, qt.Equals, false)\n\t\tc.Assert(c4, qt.Equals, \"Stringer\")\n\t\tc.Assert(c5, qt.Equals, \"Pointer to Stringer\")\n\t\tc.Assert(math.Floor(c6), qt.Equals, 25569.0)\n\t\tc.Assert(c7, qt.Equals, `Smith`)\n\t\tc.Assert(c8, qt.Equals, false)\n\t\tc.Assert(c9, qt.Equals, 100)\n\t\tc.Assert(c10, qt.Equals, 0.123)\n\t\tc.Assert(c11, qt.Equals, ``)\n\t\tc.Assert(c12, qt.Equals, ``)\n\t\tc.Assert(c13, qt.Equals, ``)\n\t\tc.Assert(c14, qt.Equals, ``)\n\n\t\tc.Assert(e1, qt.Equals, nil)\n\t\tc.Assert(e2, qt.Equals, nil)\n\t\tc.Assert(e9, qt.Equals, nil)\n\t\tc.Assert(e10, qt.Equals, nil)\n\n\t})\n\n\t// Test if we can write a slice to a row\n\tcsRunO(c, \"TestWriteSlice\", func(c *qt.C, option FileOption) {\n\t\tf := NewFile(option)\n\t\tsheet, _ := f.AddSheet(\"Test1\")\n\n\t\ttype strA []string\n\t\ttype intA []int\n\t\ttype floatA []float64\n\t\ttype boolA []bool\n\t\ttype interfaceA []interface{}\n\t\ttype stringerA []testStringerImpl\n\t\ttype stringerPtrA []*testStringerImpl\n\t\ttype nullStringA []sql.NullString\n\t\ttype nullBoolA []sql.NullBool\n\t\ttype nullFloatA []sql.NullFloat64\n\t\ttype nullIntA []sql.NullInt64\n\n\t\ts0 := strA{\"Eric\"}\n\t\trow0 := sheet.AddRow()\n\t\trow0.WriteSlice(&s0, -1)\n\t\tc.Assert(row0, qt.Not(qt.IsNil))\n\n\t\tif val, err := row0.GetCell(0).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"Eric\")\n\t\t}\n\n\t\ts1 := intA{10}\n\t\trow1 := sheet.AddRow()\n\t\trow1.WriteSlice(&s1, -1)\n\t\tc.Assert(row1, qt.Not(qt.IsNil))\n\t\tc1, e1 := row1.GetCell(0).Int()\n\t\tc.Assert(e1, qt.Equals, nil)\n\t\tc.Assert(c1, qt.Equals, 10)\n\n\t\ts2 := floatA{3.94}\n\t\trow2 := sheet.AddRow()\n\t\trow2.WriteSlice(&s2, -1)\n\t\tc.Assert(row2, qt.Not(qt.IsNil))\n\t\tc2, e2 := row2.GetCell(0).Float()\n\t\tc.Assert(e2, qt.Equals, nil)\n\t\tc.Assert(c2, qt.Equals, 3.94)\n\n\t\ts3 := boolA{true}\n\t\trow3 := sheet.AddRow()\n\t\trow3.WriteSlice(&s3, -1)\n\t\tc.Assert(row3, qt.Not(qt.IsNil))\n\t\tc3 := row3.GetCell(0).Bool()\n\t\tc.Assert(c3, qt.Equals, true)\n\n\t\ts4 := interfaceA{\"Eric\", 10, 3.94, true, time.Unix(0, 0)}\n\t\trow4 := sheet.AddRow()\n\t\trow4.WriteSlice(&s4, -1)\n\t\tc.Assert(row4, qt.Not(qt.IsNil))\n\t\tif val, err := row4.GetCell(0).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"Eric\")\n\t\t}\n\t\tc41, e41 := row4.GetCell(1).Int()\n\t\tc.Assert(e41, qt.Equals, nil)\n\t\tc.Assert(c41, qt.Equals, 10)\n\t\tc42, e42 := row4.GetCell(2).Float()\n\t\tc.Assert(e42, qt.Equals, nil)\n\t\tc.Assert(c42, qt.Equals, 3.94)\n\t\tc43 := row4.GetCell(3).Bool()\n\t\tc.Assert(c43, qt.Equals, true)\n\n\t\tc44, e44 := row4.GetCell(4).Float()\n\t\tc.Assert(e44, qt.Equals, nil)\n\t\tc.Assert(math.Floor(c44), qt.Equals, 25569.0)\n\n\t\ts5 := stringerA{testStringerImpl{\"Stringer\"}}\n\t\trow5 := sheet.AddRow()\n\t\trow5.WriteSlice(&s5, -1)\n\t\tc.Assert(row5, qt.Not(qt.IsNil))\n\n\t\tif val, err := row5.GetCell(0).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"Stringer\")\n\t\t}\n\n\t\ts6 := stringerPtrA{&testStringerImpl{\"Pointer to Stringer\"}}\n\t\trow6 := sheet.AddRow()\n\t\trow6.WriteSlice(&s6, -1)\n\t\tc.Assert(row6, qt.Not(qt.IsNil))\n\n\t\tif val, err := row6.GetCell(0).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"Pointer to Stringer\")\n\t\t}\n\n\t\ts7 := \"expects -1 on non pointer to slice\"\n\t\trow7 := sheet.AddRow()\n\t\tc.Assert(row7, qt.Not(qt.IsNil))\n\t\ts7_ret := row7.WriteSlice(s7, -1)\n\t\tc.Assert(s7_ret, qt.Equals, -1)\n\t\ts7_ret = row7.WriteSlice(&s7, -1)\n\t\tc.Assert(s7_ret, qt.Equals, -1)\n\n\t\ts8 := nullStringA{sql.NullString{String: \"Smith\", Valid: true}, sql.NullString{String: `What ever`, Valid: false}}\n\t\trow8 := sheet.AddRow()\n\t\trow8.WriteSlice(&s8, -1)\n\t\tc.Assert(row8, qt.Not(qt.IsNil))\n\n\t\tif val, err := row8.GetCell(0).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val, qt.Equals, \"Smith\")\n\t\t}\n\t\t// check second cell on empty string \"\"\n\n\t\tif val2, err := row8.GetCell(1).FormattedValue(); err != nil {\n\t\t\tc.Error(err)\n\t\t} else {\n\t\t\tc.Assert(val2, qt.Equals, \"\")\n\t\t}\n\n\t\ts9 := nullBoolA{sql.NullBool{Bool: false, Valid: true}, sql.NullBool{Bool: true, Valid: false}}\n\t\trow9 := sheet.AddRow()\n\t\trow9.WriteSlice(&s9, -1)\n\t\tc.Assert(row9, qt.Not(qt.IsNil))\n\t\tc9 := row9.GetCell(0).Bool()\n\t\tc9Null := row9.GetCell(1).String()\n\t\tc.Assert(c9, qt.Equals, false)\n\t\tc.Assert(c9Null, qt.Equals, \"\")\n\n\t\ts10 := nullIntA{sql.NullInt64{Int64: 100, Valid: true}, sql.NullInt64{Int64: 100, Valid: false}}\n\t\trow10 := sheet.AddRow()\n\t\trow10.WriteSlice(&s10, -1)\n\t\tc.Assert(row10, qt.Not(qt.IsNil))\n\t\tc10, e10 := row10.GetCell(0).Int()\n\t\tc10Null, e10Null := row10.GetCell(1).FormattedValue()\n\t\tc.Assert(e10, qt.Equals, nil)\n\t\tc.Assert(c10, qt.Equals, 100)\n\t\tc.Assert(e10Null, qt.Equals, nil)\n\t\tc.Assert(c10Null, qt.Equals, \"\")\n\n\t\ts11 := nullFloatA{sql.NullFloat64{Float64: 0.123, Valid: true}, sql.NullFloat64{Float64: 0.123, Valid: false}}\n\t\trow11 := sheet.AddRow()\n\t\trow11.WriteSlice(&s11, -1)\n\t\tc.Assert(row11, qt.Not(qt.IsNil))\n\t\tc11, e11 := row11.GetCell(0).Float()\n\t\tc11Null, e11Null := row11.GetCell(1).FormattedValue()\n\t\tc.Assert(e11, qt.Equals, nil)\n\t\tc.Assert(c11, qt.Equals, 0.123)\n\t\tc.Assert(e11Null, qt.Equals, nil)\n\t\tc.Assert(c11Null, qt.Equals, \"\")\n\t})\n}\n\nfunc TestBigWrite(t *testing.T) {\n\tt.SkipNow()\n\tc := qt.New(t)\n\tp := profile.Start(profile.MemProfile)\n\n\ttestDir := t.TempDir()\n\n\tpath := filepath.Join(testDir, \"test.xlsx\")\n\n\tf := NewFile(UseDiskVCellStore)\n\ts, err := f.AddSheet(\"big\")\n\tc.Assert(err, qt.Equals, nil)\n\n\tfor ri := 0; ri < 16384; ri++ {\n\t\tr := s.AddRow()\n\t\tfor ci := 0; ci < 200; ci++ {\n\t\t\tc := r.AddCell()\n\t\t\tc.SetInt64(int64(ri * ci))\n\t\t}\n\t}\n\n\terr = f.Save(path)\n\tp.Stop()\n\tc.Assert(err, qt.Equals, nil)\n\n}\n\nfunc TestWriteFileWithUnvisitedSheets(t *testing.T) {\n\tc := qt.New(t)\n\n\t// Issue 644 occured because we were checking the currentRow\n\t// on sheets that hadn't been visitied and thus had no current\n\t// row set.\n\tcsRunO(c, \"Test for panic\", func(c *qt.C, opt FileOption) {\n\t\tfileToOpen := filepath.Join(\"testdocs\", \"testfile.xlsx\")\n\t\t// open an existing file\n\t\twbFile, err := OpenFile(fileToOpen, opt)\n\t\tc.Assert(err, qt.IsNil)\n\n\t\tsheetName := \"Tabelle1\"\n\t\tsh, ok := wbFile.Sheet[sheetName]\n\t\tc.Assert(ok, qt.Equals, true)\n\t\tcolNum, rowNum, _ := GetCoordsFromCellIDString(\"DD3000\")\n\t\tcell, err := sh.Cell(rowNum, colNum)\n\t\tc.Assert(err, qt.IsNil)\n\t\tcell.SetInt64(39491)\n\n\t\ttestDir := t.TempDir()\n\t\tpath := filepath.Join(testDir, \"test.xlsx\")\n\n\t\t// With issue 644 this line would panic\n\t\terr = wbFile.Save(path)\n\t\tc.Assert(err, qt.IsNil)\n\t})\n}\n"
        },
        {
          "name": "xmlContentTypes.go",
          "type": "blob",
          "size": 1.98828125,
          "content": "package xlsx\n\nimport (\n\t\"encoding/xml\"\n)\n\ntype xlsxTypes struct {\n\tXMLName xml.Name `xml:\"http://schemas.openxmlformats.org/package/2006/content-types Types\"`\n\n\tOverrides []xlsxOverride `xml:\"Override\"`\n\tDefaults  []xlsxDefault  `xml:\"Default\"`\n}\n\ntype xlsxOverride struct {\n\tPartName    string `xml:\",attr\"`\n\tContentType string `xml:\",attr\"`\n}\n\ntype xlsxDefault struct {\n\tExtension   string `xml:\",attr\"`\n\tContentType string `xml:\",attr\"`\n}\n\nfunc MakeDefaultContentTypes() (types xlsxTypes) {\n\ttypes.Overrides = make([]xlsxOverride, 8)\n\ttypes.Defaults = make([]xlsxDefault, 2)\n\n\ttypes.Overrides[0].PartName = \"/_rels/.rels\"\n\ttypes.Overrides[0].ContentType = \"application/vnd.openxmlformats-package.relationships+xml\"\n\ttypes.Overrides[1].PartName = \"/docProps/app.xml\"\n\ttypes.Overrides[1].ContentType = \"application/vnd.openxmlformats-officedocument.extended-properties+xml\"\n\ttypes.Overrides[2].PartName = \"/docProps/core.xml\"\n\ttypes.Overrides[2].ContentType = \"application/vnd.openxmlformats-package.core-properties+xml\"\n\ttypes.Overrides[3].PartName = \"/xl/_rels/workbook.xml.rels\"\n\ttypes.Overrides[3].ContentType = \"application/vnd.openxmlformats-package.relationships+xml\"\n\ttypes.Overrides[4].PartName = \"/xl/sharedStrings.xml\"\n\ttypes.Overrides[4].ContentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\"\n\ttypes.Overrides[5].PartName = \"/xl/styles.xml\"\n\ttypes.Overrides[5].ContentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\"\n\ttypes.Overrides[6].PartName = \"/xl/workbook.xml\"\n\ttypes.Overrides[6].ContentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\"\n\ttypes.Overrides[7].PartName = \"/xl/theme/theme1.xml\"\n\ttypes.Overrides[7].ContentType = \"application/vnd.openxmlformats-officedocument.theme+xml\"\n\n\ttypes.Defaults[0].Extension = \"rels\"\n\ttypes.Defaults[0].ContentType = \"application/vnd.openxmlformats-package.relationships+xml\"\n\ttypes.Defaults[1].Extension = \"xml\"\n\ttypes.Defaults[1].ContentType = \"application/xml\"\n\treturn\n}\n"
        },
        {
          "name": "xmlContentTypes_test.go",
          "type": "blob",
          "size": 2.7392578125,
          "content": "package xlsx\n\nimport (\n\t\"encoding/xml\"\n\t\"testing\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\nfunc TestMarshalContentTypes(t *testing.T) {\n\tc := qt.New(t)\n\tvar types xlsxTypes = xlsxTypes{}\n\ttypes.Overrides = make([]xlsxOverride, 1)\n\ttypes.Overrides[0] = xlsxOverride{PartName: \"/_rels/.rels\", ContentType: \"application/vnd.openxmlformats-package.relationships+xml\"}\n\toutput, err := xml.Marshal(types)\n\tstringOutput := xml.Header + string(output)\n\tc.Assert(err, qt.IsNil)\n\texpectedContentTypes := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Types xmlns=\"http://schemas.openxmlformats.org/package/2006/content-types\"><Override PartName=\"/_rels/.rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\"></Override></Types>`\n\tc.Assert(stringOutput, qt.Equals, expectedContentTypes)\n}\n\nfunc TestMakeDefaultContentTypes(t *testing.T) {\n\tc := qt.New(t)\n\tvar types xlsxTypes = MakeDefaultContentTypes()\n\tc.Assert(len(types.Overrides), qt.Equals, 8)\n\tc.Assert(types.Overrides[0].PartName, qt.Equals, \"/_rels/.rels\")\n\tc.Assert(types.Overrides[0].ContentType, qt.Equals, \"application/vnd.openxmlformats-package.relationships+xml\")\n\tc.Assert(types.Overrides[1].PartName, qt.Equals, \"/docProps/app.xml\")\n\tc.Assert(types.Overrides[1].ContentType, qt.Equals, \"application/vnd.openxmlformats-officedocument.extended-properties+xml\")\n\tc.Assert(types.Overrides[2].PartName, qt.Equals, \"/docProps/core.xml\")\n\tc.Assert(types.Overrides[2].ContentType, qt.Equals, \"application/vnd.openxmlformats-package.core-properties+xml\")\n\tc.Assert(types.Overrides[3].PartName, qt.Equals, \"/xl/_rels/workbook.xml.rels\")\n\tc.Assert(types.Overrides[3].ContentType, qt.Equals, \"application/vnd.openxmlformats-package.relationships+xml\")\n\tc.Assert(types.Overrides[4].PartName, qt.Equals, \"/xl/sharedStrings.xml\")\n\tc.Assert(types.Overrides[4].ContentType, qt.Equals, \"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\")\n\tc.Assert(types.Overrides[5].PartName, qt.Equals, \"/xl/styles.xml\")\n\tc.Assert(types.Overrides[5].ContentType, qt.Equals, \"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\")\n\tc.Assert(types.Overrides[6].PartName, qt.Equals, \"/xl/workbook.xml\")\n\tc.Assert(types.Overrides[6].ContentType, qt.Equals, \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\")\n\tc.Assert(types.Overrides[7].PartName, qt.Equals, \"/xl/theme/theme1.xml\")\n\tc.Assert(types.Overrides[7].ContentType, qt.Equals, \"application/vnd.openxmlformats-officedocument.theme+xml\")\n\n\tc.Assert(types.Defaults[0].Extension, qt.Equals, \"rels\")\n\tc.Assert(types.Defaults[0].ContentType, qt.Equals, \"application/vnd.openxmlformats-package.relationships+xml\")\n\tc.Assert(types.Defaults[1].Extension, qt.Equals, \"xml\")\n\tc.Assert(types.Defaults[1].ContentType, qt.Equals, \"application/xml\")\n\n}\n"
        },
        {
          "name": "xmlSharedStrings.go",
          "type": "blob",
          "size": 4.697265625,
          "content": "package xlsx\n\nimport (\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"strings\"\n)\n\n// xlsxSST directly maps the sst element from the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main currently\n// I have not checked this for completeness - it does as much as I need.\ntype xlsxSST struct {\n\tXMLName     xml.Name `xml:\"http://schemas.openxmlformats.org/spreadsheetml/2006/main sst\"`\n\tCount       int      `xml:\"count,attr\"`\n\tUniqueCount int      `xml:\"uniqueCount,attr\"`\n\tSI          []xlsxSI `xml:\"si\"`\n}\n\n// xlsxSI directly maps the si element from the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked this for completeness - it does as\n// much as I need.\ntype xlsxSI struct {\n\tT *xlsxT  `xml:\"t\"`\n\tR []xlsxR `xml:\"r\"`\n}\n\n// xlsxR directly maps the r element from the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked this for completeness - it does as\n// much as I need.\ntype xlsxR struct {\n\tRPr *xlsxRunProperties `xml:\"rPr\"`\n\tT   xlsxT              `xml:\"t\"`\n}\n\n// xlsxRunProperties directly maps the rPr element from the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main\ntype xlsxRunProperties struct {\n\tRFont     *xlsxVal      `xml:\"rFont\"`\n\tCharset   *xlsxIntVal   `xml:\"charset\"`\n\tFamily    *xlsxIntVal   `xml:\"family\"`\n\tB         xlsxBoolProp  `xml:\"b\"`\n\tI         xlsxBoolProp  `xml:\"i\"`\n\tStrike    xlsxBoolProp  `xml:\"strike\"`\n\tOutline   xlsxBoolProp  `xml:\"outline\"`\n\tShadow    xlsxBoolProp  `xml:\"shadow\"`\n\tCondense  xlsxBoolProp  `xml:\"condense\"`\n\tExtend    xlsxBoolProp  `xml:\"extend\"`\n\tColor     *xlsxColor    `xml:\"color\"`\n\tSz        *xlsxFloatVal `xml:\"sz\"`\n\tU         *xlsxVal      `xml:\"u\"`\n\tVertAlign *xlsxVal      `xml:\"vertAlign\"`\n\tScheme    *xlsxVal      `xml:\"scheme\"`\n}\n\n// xlsxBoolProp handles \"CT_BooleanProperty\" type which is declared in the XML Schema of Office Open XML.\n// XML attribute \"val\" is optional. If \"val\" was omitted, the property value becomes \"true\".\n// On the serialization, the struct which has \"true\" will be serialized an empty XML tag without \"val\" attributes,\n// and the struct which has \"false\" will not be serialized.\ntype xlsxBoolProp struct {\n\tVal bool `xml:\"val,attr\"`\n}\n\n// MarshalXML implements xml.Marshaler interface for xlsxBoolProp\nfunc (b *xlsxBoolProp) MarshalXML(e *xml.Encoder, start xml.StartElement) error {\n\tif b.Val {\n\t\tif err := e.EncodeToken(start); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := e.EncodeToken(xml.EndElement{Name: start.Name}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// UnmarshalXML implements xml.Unmarshaler interface for xlsxBoolProp\nfunc (b *xlsxBoolProp) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {\n\tboolVal := true\n\tfor _, attr := range start.Attr {\n\t\tif attr.Name.Space == \"\" && attr.Name.Local == \"val\" {\n\t\t\t// supports xsd:boolean\n\t\t\tswitch attr.Value {\n\t\t\tcase \"true\", \"1\":\n\t\t\t\tboolVal = true\n\t\t\tcase \"false\", \"0\":\n\t\t\t\tboolVal = false\n\t\t\tdefault:\n\t\t\t\treturn errors.New(\n\t\t\t\t\t\"Cannot unmarshal into xlsxBoolProp: \\\"\" +\n\t\t\t\t\t\tattr.Value + \"\\\" is not a valid boolean value\")\n\t\t\t}\n\t\t}\n\t}\n\tb.Val = boolVal\n\treturn d.Skip()\n}\n\n// xlsxIntVal is like xlsxVal, except it has an int value\ntype xlsxIntVal struct {\n\tVal int `xml:\"val,attr\"`\n}\n\n// xlsxFloatVal is like xlsxVal, except it has a float value\ntype xlsxFloatVal struct {\n\tVal float64 `xml:\"val,attr\"`\n}\n\n// xlsxT represents a text. It will be serialized as a XML tag which has character data.\n// Attribute xml:space=\"preserve\" will be added to the XML tag if needed.\ntype xlsxT struct {\n\tText string `xml:\",chardata\"`\n}\n\n// MarshalXML implements xml.Marshaler interface for xlsxT\nfunc (t *xlsxT) MarshalXML(e *xml.Encoder, start xml.StartElement) error {\n\tif needPreserve(t.Text) {\n\t\tattr := xml.Attr{\n\t\t\tName:  xml.Name{Local: \"xml:space\"},\n\t\t\tValue: \"preserve\",\n\t\t}\n\t\tstart.Attr = append(start.Attr, attr)\n\t}\n\n\tif err := e.EncodeToken(start); err != nil {\n\t\treturn err\n\t}\n\tif err := e.EncodeToken(xml.CharData(t.Text)); err != nil {\n\t\treturn err\n\t}\n\tif err := e.EncodeToken(xml.EndElement{Name: start.Name}); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// getText is a nil-safe utility function that gets a string from xlsxT.\n// If the pointer of xlsxT was nil, returns an empty string.\nfunc (t *xlsxT) getText() string {\n\tif t == nil {\n\t\treturn \"\"\n\t}\n\treturn t.Text\n}\n\n// needPreserve determines whether xml:space=\"preserve\" is needed.\nfunc needPreserve(s string) bool {\n\tif len(s) == 0 {\n\t\treturn false\n\t}\n\t// Note:\n\t// xml:space=\"preserve\" is not needed for CR and TAB\n\t// because they are serialized as \"&#xD;\" and \"&#x9;\".\n\tc := s[0]\n\tif c <= 32 && c != 9 && c != 13 {\n\t\treturn true\n\t}\n\tc = s[len(s)-1]\n\tif c <= 32 && c != 9 && c != 13 {\n\t\treturn true\n\t}\n\treturn strings.ContainsRune(s, '\\u000a')\n}\n"
        },
        {
          "name": "xmlSharedStrings_test.go",
          "type": "blob",
          "size": 8.25390625,
          "content": "package xlsx\n\nimport (\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"testing\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\nconst xmlSharedStringsTest_sharedStringsXMLStr = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"\n\t count=\"5\"\n\t uniqueCount=\"5\">\n  <si>\n\t<t>Foo</t>\n  </si>\n  <si>\n\t<t>Bar</t>\n  </si>\n  <si>\n\t<t xml:space=\"preserve\">Baz </t>\n  </si>\n  <si>\n\t<t>Quuk</t>\n  </si>\n  <si>\n\t<r>\n\t\t<t>Normal</t>\n\t</r>\n\t<r>\n\t\t<rPr>\n\t\t</rPr>\n\t\t<t>Normal2</t>\n\t</r>\n\t<r>\n\t\t<rPr>\n\t\t\t<b val=\"true\"/>\n\t\t\t<i val=\"false\"/>\n\t\t\t<strike/>\n\t\t\t<condense val=\"1\"/>\n\t\t\t<extend val=\"0\"/>\n\t\t</rPr>\n\t\t<t>Bools</t>\n\t</r>\n\t<r>\n\t\t<rPr>\n\t\t\t<sz val=\"13.5\"/><color theme=\"1\"/><rFont val=\"FontZ\"/><family val=\"2\"/><charset val=\"128\"/><scheme val=\"minor\"/>\n\t\t</rPr>\n\t\t<t>Font Spec</t>\n\t</r>\n\t<r>\n\t\t<rPr>\n\t\t\t<u val=\"single\"/>\n\t\t\t<vertAlign val=\"superscript\"/>\n\t\t</rPr>\n\t\t<t>Misc</t>\n\t</r>\n  </si>\n</sst>`\n\n// Test we can correctly unmarshal an the sharedstrings.xml file into\n// an xlsx.xlsxSST struct and it's associated children.\nfunc TestUnmarshallSharedStrings(t *testing.T) {\n\tc := qt.New(t)\n\tsst := new(xlsxSST)\n\terr := xml.NewDecoder(bytes.NewBufferString(xmlSharedStringsTest_sharedStringsXMLStr)).Decode(sst)\n\tc.Assert(err, qt.IsNil)\n\tc.Assert(sst.Count, qt.Equals, 5)\n\tc.Assert(sst.UniqueCount, qt.Equals, 5)\n\tc.Assert(sst.SI, qt.HasLen, 5)\n\n\tsi := sst.SI[0]\n\tc.Assert(si.T.Text, qt.Equals, \"Foo\")\n\tc.Assert(si.R, qt.IsNil)\n\tsi = sst.SI[1]\n\tc.Assert(si.T.Text, qt.Equals, \"Bar\")\n\tc.Assert(si.R, qt.IsNil)\n\tsi = sst.SI[2]\n\tc.Assert(si.T.Text, qt.Equals, \"Baz \")\n\tc.Assert(si.R, qt.IsNil)\n\tsi = sst.SI[3]\n\tc.Assert(si.T.Text, qt.Equals, \"Quuk\")\n\tc.Assert(si.R, qt.IsNil)\n\tsi = sst.SI[4]\n\tc.Assert(si.T, qt.IsNil)\n\tc.Assert(len(si.R), qt.Equals, 5)\n\tr := si.R[0]\n\tc.Assert(r.T.Text, qt.Equals, \"Normal\")\n\tc.Assert(r.RPr, qt.IsNil)\n\tr = si.R[1]\n\tc.Assert(r.T.Text, qt.Equals, \"Normal2\")\n\tc.Assert(r.RPr.RFont, qt.IsNil)\n\tc.Assert(r.RPr.Sz, qt.IsNil)\n\tc.Assert(r.RPr.Color, qt.IsNil)\n\tc.Assert(r.RPr.Family, qt.IsNil)\n\tc.Assert(r.RPr.Charset, qt.IsNil)\n\tc.Assert(r.RPr.Scheme, qt.IsNil)\n\tc.Assert(r.RPr.B.Val, qt.Equals, false)\n\tc.Assert(r.RPr.I.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Strike.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Outline.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Shadow.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Condense.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Extend.Val, qt.Equals, false)\n\tc.Assert(r.RPr.U, qt.IsNil)\n\tc.Assert(r.RPr.VertAlign, qt.IsNil)\n\tr = si.R[2]\n\tc.Assert(r.T.Text, qt.Equals, \"Bools\")\n\tc.Assert(r.RPr.RFont, qt.IsNil)\n\tc.Assert(r.RPr.B.Val, qt.Equals, true)\n\tc.Assert(r.RPr.I.Val, qt.Equals, false)\n\tc.Assert(r.RPr.Strike.Val, qt.Equals, true)\n\tc.Assert(r.RPr.Condense.Val, qt.Equals, true)\n\tc.Assert(r.RPr.Extend.Val, qt.Equals, false)\n\tr = si.R[3]\n\tc.Assert(r.T.Text, qt.Equals, \"Font Spec\")\n\tc.Assert(r.RPr.RFont.Val, qt.Equals, \"FontZ\")\n\tc.Assert(r.RPr.Sz.Val, qt.Equals, 13.5)\n\tc.Assert(*r.RPr.Color.Theme, qt.Equals, 1)\n\tc.Assert(r.RPr.Family.Val, qt.Equals, 2)\n\tc.Assert(r.RPr.Charset.Val, qt.Equals, 128)\n\tc.Assert(r.RPr.Scheme.Val, qt.Equals, \"minor\")\n\tr = si.R[4]\n\tc.Assert(r.T.Text, qt.Equals, \"Misc\")\n\tc.Assert(r.RPr.U.Val, qt.Equals, \"single\")\n\tc.Assert(r.RPr.VertAlign.Val, qt.Equals, \"superscript\")\n}\n\n// TestMarshalSI_T tests that xlsxT is marshaled as it is expected.\nfunc TestMarshalSI_T(t *testing.T) {\n\tc := qt.New(t)\n\ttestMarshalSIT(c, \"\", \"<xlsxSI><t></t></xlsxSI>\")\n\ttestMarshalSIT(c, \"a b c\", \"<xlsxSI><t>a b c</t></xlsxSI>\")\n\ttestMarshalSIT(c, \" abc\", \"<xlsxSI><t xml:space=\\\"preserve\\\"> abc</t></xlsxSI>\")\n\ttestMarshalSIT(c, \"abc \", \"<xlsxSI><t xml:space=\\\"preserve\\\">abc </t></xlsxSI>\")\n\ttestMarshalSIT(c, \"\\nabc\", \"<xlsxSI><t xml:space=\\\"preserve\\\">\\nabc</t></xlsxSI>\")\n\ttestMarshalSIT(c, \"abc\\n\", \"<xlsxSI><t xml:space=\\\"preserve\\\">abc\\n</t></xlsxSI>\")\n\ttestMarshalSIT(c, \"ab\\nc\", \"<xlsxSI><t xml:space=\\\"preserve\\\">ab\\nc</t></xlsxSI>\")\n}\n\nfunc testMarshalSIT(c *qt.C, t string, expected string) {\n\tsi := xlsxSI{T: &xlsxT{Text: t}}\n\tbytes, err := xml.Marshal(&si)\n\tc.Assert(err, qt.IsNil)\n\tc.Assert(string(bytes), qt.Equals, expected)\n}\n\n// TestMarshalSI_R tests that xlsxR is marshaled as it is expected.\nfunc TestMarshalSI_R(t *testing.T) {\n\tc := qt.New(t)\n\ttestMarshalSIR(c, xlsxR{}, \"<xlsxSI><r><t></t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a b c\"}}, \"<xlsxSI><r><t>a b c</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \" abc\"}}, \"<xlsxSI><r><t xml:space=\\\"preserve\\\"> abc</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"abc \"}}, \"<xlsxSI><r><t xml:space=\\\"preserve\\\">abc </t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"\\nabc\"}}, \"<xlsxSI><r><t xml:space=\\\"preserve\\\">\\nabc</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"abc\\n\"}}, \"<xlsxSI><r><t xml:space=\\\"preserve\\\">abc\\n</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"ab\\nc\"}}, \"<xlsxSI><r><t xml:space=\\\"preserve\\\">ab\\nc</t></r></xlsxSI>\")\n\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a\"}, RPr: &xlsxRunProperties{RFont: &xlsxVal{Val: \"Times New Roman\"}}},\n\t\t\"<xlsxSI><r><rPr><rFont val=\\\"Times New Roman\\\"></rFont></rPr><t>a</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a\"}, RPr: &xlsxRunProperties{Charset: &xlsxIntVal{Val: 1}}},\n\t\t\"<xlsxSI><r><rPr><charset val=\\\"1\\\"></charset></rPr><t>a</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a\"}, RPr: &xlsxRunProperties{Family: &xlsxIntVal{Val: 1}}},\n\t\t\"<xlsxSI><r><rPr><family val=\\\"1\\\"></family></rPr><t>a</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a\"}, RPr: &xlsxRunProperties{B: xlsxBoolProp{Val: true}}},\n\t\t\"<xlsxSI><r><rPr><b></b></rPr><t>a</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a\"}, RPr: &xlsxRunProperties{I: xlsxBoolProp{Val: true}}},\n\t\t\"<xlsxSI><r><rPr><i></i></rPr><t>a</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a\"}, RPr: &xlsxRunProperties{Strike: xlsxBoolProp{Val: true}}},\n\t\t\"<xlsxSI><r><rPr><strike></strike></rPr><t>a</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a\"}, RPr: &xlsxRunProperties{Outline: xlsxBoolProp{Val: true}}},\n\t\t\"<xlsxSI><r><rPr><outline></outline></rPr><t>a</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a\"}, RPr: &xlsxRunProperties{Shadow: xlsxBoolProp{Val: true}}},\n\t\t\"<xlsxSI><r><rPr><shadow></shadow></rPr><t>a</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a\"}, RPr: &xlsxRunProperties{Condense: xlsxBoolProp{Val: true}}},\n\t\t\"<xlsxSI><r><rPr><condense></condense></rPr><t>a</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a\"}, RPr: &xlsxRunProperties{Extend: xlsxBoolProp{Val: true}}},\n\t\t\"<xlsxSI><r><rPr><extend></extend></rPr><t>a</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a\"}, RPr: &xlsxRunProperties{Color: &xlsxColor{RGB: \"FF123456\"}}},\n\t\t\"<xlsxSI><r><rPr><color rgb=\\\"FF123456\\\"></color></rPr><t>a</t></r></xlsxSI>\")\n\tcolorIndex := 11\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a\"}, RPr: &xlsxRunProperties{Color: &xlsxColor{Indexed: &colorIndex}}},\n\t\t\"<xlsxSI><r><rPr><color indexed=\\\"11\\\"></color></rPr><t>a</t></r></xlsxSI>\")\n\tcolorTheme := 5\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a\"}, RPr: &xlsxRunProperties{Color: &xlsxColor{Theme: &colorTheme}}},\n\t\t\"<xlsxSI><r><rPr><color theme=\\\"5\\\"></color></rPr><t>a</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a\"}, RPr: &xlsxRunProperties{Color: &xlsxColor{Theme: &colorTheme, Tint: 0.1}}},\n\t\t\"<xlsxSI><r><rPr><color theme=\\\"5\\\" tint=\\\"0.1\\\"></color></rPr><t>a</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a\"}, RPr: &xlsxRunProperties{Sz: &xlsxFloatVal{Val: 12.5}}},\n\t\t\"<xlsxSI><r><rPr><sz val=\\\"12.5\\\"></sz></rPr><t>a</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a\"}, RPr: &xlsxRunProperties{U: &xlsxVal{Val: \"single\"}}},\n\t\t\"<xlsxSI><r><rPr><u val=\\\"single\\\"></u></rPr><t>a</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a\"}, RPr: &xlsxRunProperties{VertAlign: &xlsxVal{Val: \"superscript\"}}},\n\t\t\"<xlsxSI><r><rPr><vertAlign val=\\\"superscript\\\"></vertAlign></rPr><t>a</t></r></xlsxSI>\")\n\ttestMarshalSIR(c, xlsxR{T: xlsxT{Text: \"a\"}, RPr: &xlsxRunProperties{Scheme: &xlsxVal{Val: \"major\"}}},\n\t\t\"<xlsxSI><r><rPr><scheme val=\\\"major\\\"></scheme></rPr><t>a</t></r></xlsxSI>\")\n}\n\nfunc testMarshalSIR(c *qt.C, r xlsxR, expected string) {\n\tsi := xlsxSI{R: []xlsxR{r}}\n\tbytes, err := xml.Marshal(&si)\n\tc.Assert(err, qt.IsNil)\n\tc.Assert(string(bytes), qt.Equals, expected)\n}\n"
        },
        {
          "name": "xmlStyle.go",
          "type": "blob",
          "size": 32.359375,
          "content": "// xslx is a package designed to help with reading data from\n// spreadsheets stored in the XLSX format used in recent versions of\n// Microsoft's Excel spreadsheet.\n//\n// For a concise example of how to use this library why not check out\n// the source for xlsx2csv here: https://github.com/tealeg/xlsx2csv\n\npackage xlsx\n\nimport (\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"sync\"\n)\n\nvar defaultTheme int = 1\n\n// Excel styles can reference number formats that are built-in, all of which\n// have an id less than 164.\nconst builtinNumFmtsCount = 163\n\n// Excel styles can reference number formats that are built-in, all of which\n// have an id less than 164. This is a possibly incomplete list comprised of as\n// many of them as I could find.\nvar builtInNumFmt = map[int]string{\n\t0:  \"general\",\n\t1:  \"0\",\n\t2:  \"0.00\",\n\t3:  \"#,##0\",\n\t4:  \"#,##0.00\",\n\t9:  \"0%\",\n\t10: \"0.00%\",\n\t11: \"0.00e+00\",\n\t12: \"# ?/?\",\n\t13: \"# ??/??\",\n\t14: \"mm-dd-yy\",\n\t15: \"d-mmm-yy\",\n\t16: \"d-mmm\",\n\t17: \"mmm-yy\",\n\t18: \"h:mm am/pm\",\n\t19: \"h:mm:ss am/pm\",\n\t20: \"h:mm\",\n\t21: \"h:mm:ss\",\n\t22: \"m/d/yy h:mm\",\n\t37: \"#,##0 ;(#,##0)\",\n\t38: \"#,##0 ;[red](#,##0)\",\n\t39: \"#,##0.00;(#,##0.00)\",\n\t40: \"#,##0.00;[red](#,##0.00)\",\n\t41: `_(* #,##0_);_(* \\(#,##0\\);_(* \"-\"_);_(@_)`,\n\t42: `_(\"$\"* #,##0_);_(\"$* \\(#,##0\\);_(\"$\"* \"-\"_);_(@_)`,\n\t43: `_(* #,##0.00_);_(* \\(#,##0.00\\);_(* \"-\"??_);_(@_)`,\n\t44: `_(\"$\"* #,##0.00_);_(\"$\"* \\(#,##0.00\\);_(\"$\"* \"-\"??_);_(@_)`,\n\t45: \"mm:ss\",\n\t46: \"[h]:mm:ss\",\n\t47: \"mmss.0\",\n\t48: \"##0.0e+0\",\n\t49: \"@\",\n}\n\nvar builtInNumFmtInv = make(map[string]int, 40)\n\nfunc init() {\n\tfor k, v := range builtInNumFmt {\n\t\tbuiltInNumFmtInv[v] = k\n\t}\n}\n\nconst (\n\tbuiltInNumFmtIndex_GENERAL = int(0)\n\tbuiltInNumFmtIndex_INT     = int(1)\n\tbuiltInNumFmtIndex_FLOAT   = int(2)\n\tbuiltInNumFmtIndex_DATE    = int(14)\n\tbuiltInNumFmtIndex_STRING  = int(49)\n)\n\n// xlsx Indexed Colors\n// https://github.com/ClosedXML/ClosedXML/wiki/Excel-Indexed-Colors\nvar xlsxIndexedColors = []string{\n\t\"FF000000\",\n\t\"FFFFFFFF\",\n\t\"FFFF0000\",\n\t\"FF00FF00\",\n\t\"FF0000FF\",\n\t\"FFFFFF00\",\n\t\"FFFF00FF\",\n\t\"FF00FFFF\",\n\t\"FF000000\",\n\t\"FFFFFFFF\",\n\t\"FFFF0000\",\n\t\"FF00FF00\",\n\t\"FF0000FF\",\n\t\"FFFFFF00\",\n\t\"FFFF00FF\",\n\t\"FF00FFFF\",\n\t\"FF800000\",\n\t\"FF008000\",\n\t\"FF000080\",\n\t\"FF808000\",\n\t\"FF800080\",\n\t\"FF008080\",\n\t\"FFC0C0C0\",\n\t\"FF808080\",\n\t\"FF9999FF\",\n\t\"FF993366\",\n\t\"FFFFFFCC\",\n\t\"FFCCFFFF\",\n\t\"FF660066\",\n\t\"FFFF8080\",\n\t\"FF0066CC\",\n\t\"FFCCCCFF\",\n\t\"FF000080\",\n\t\"FFFF00FF\",\n\t\"FFFFFF00\",\n\t\"FF00FFFF\",\n\t\"FF800080\",\n\t\"FF800000\",\n\t\"FF008080\",\n\t\"FF0000FF\",\n\t\"FF00CCFF\",\n\t\"FFCCFFFF\",\n\t\"FFCCFFCC\",\n\t\"FFFFFF99\",\n\t\"FF99CCFF\",\n\t\"FFFF99CC\",\n\t\"FFCC99FF\",\n\t\"FFFFCC99\",\n\t\"FF3366FF\",\n\t\"FF33CCCC\",\n\t\"FF99CC00\",\n\t\"FFFFCC00\",\n\t\"FFFF9900\",\n\t\"FFFF6600\",\n\t\"FF666699\",\n\t\"FF969696\",\n\t\"FF003366\",\n\t\"FF339966\",\n\t\"FF003300\",\n\t\"FF333300\",\n\t\"FF993300\",\n\t\"FF993366\",\n\t\"FF333399\",\n\t\"FF333333\",\n}\n\n// xlsxStyle directly maps the styleSheet element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxStyleSheet struct {\n\tXMLName xml.Name `xml:\"http://schemas.openxmlformats.org/spreadsheetml/2006/main styleSheet\"`\n\n\tFonts        xlsxFonts         `xml:\"fonts,omitempty\"`\n\tFills        xlsxFills         `xml:\"fills,omitempty\"`\n\tBorders      xlsxBorders       `xml:\"borders,omitempty\"`\n\tColors       *xlsxColors       `xml:\"colors,omitempty\"`\n\tCellStyles   *xlsxCellStyles   `xml:\"cellStyles,omitempty\"`\n\tCellStyleXfs *xlsxCellStyleXfs `xml:\"cellStyleXfs,omitempty\"`\n\tCellXfs      xlsxCellXfs       `xml:\"cellXfs,omitempty\"`\n\tNumFmts      *xlsxNumFmts      `xml:\"numFmts,omitempty\"`\n\tDXfs         xlsxDXFs          `xml:\"dxfs\"`\n\n\ttheme *theme\n\n\tstyleCacheMU        sync.RWMutex\n\tstyleCache          map[int]*Style\n\tnumFmtRefTableMU    sync.RWMutex\n\tnumFmtRefTable      map[int]xlsxNumFmt\n\tparsedNumFmtTableMU sync.RWMutex\n\tparsedNumFmtTable   map[string]*parsedNumberFormat\n}\n\nfunc newXlsxStyleSheet(t *theme) *xlsxStyleSheet {\n\treturn &xlsxStyleSheet{\n\t\ttheme:      t,\n\t\tstyleCache: make(map[int]*Style),\n\t}\n}\n\nfunc (styles *xlsxStyleSheet) reset() {\n\tstyles.Fonts = xlsxFonts{}\n\tstyles.Fills = xlsxFills{}\n\tstyles.Borders = xlsxBorders{}\n\n\t// Microsoft seems to want Arial 11 defined by default.\n\tstyles.addFont(\n\t\txlsxFont{\n\t\t\tSz:     xlsxVal{\"11\"},\n\t\t\tFamily: xlsxVal{\"2\"},\n\t\t\tColor:  xlsxColor{Theme: &defaultTheme},\n\t\t\tName:   xlsxVal{\"Arial\"},\n\t\t\tScheme: &xlsxVal{\"minor\"},\n\t\t},\n\t)\n\n\tstyles.addFill(xlsxFill{PatternFill: xlsxPatternFill{PatternType: \"none\"}})\n\tstyles.addFill(xlsxFill{PatternFill: xlsxPatternFill{PatternType: \"gray125\"}})\n\n\t// Microsoft seems to want an emtpy border to start with\n\tstyles.addBorder(\n\t\txlsxBorder{\n\t\t\tLeft:   xlsxLine{},\n\t\t\tRight:  xlsxLine{},\n\t\t\tTop:    xlsxLine{},\n\t\t\tBottom: xlsxLine{},\n\t\t})\n\n\t// add 0th CellStyleXf by default, as required by the standard\n\tstyles.CellStyleXfs = &xlsxCellStyleXfs{Count: 1, Xf: []xlsxXf{{}}}\n\n\t// add 0th CellXf by default, as required by the standard\n\tstyles.CellXfs = xlsxCellXfs{Count: 1, Xf: []xlsxXf{{}}}\n\tstyles.NumFmts = &xlsxNumFmts{}\n\tstyles.numFmtRefTableMU.Lock()\n\tstyles.numFmtRefTable = nil\n\tstyles.numFmtRefTableMU.Unlock()\n}\n\nfunc (styles *xlsxStyleSheet) populateStyleFromXf(style *Style, xf xlsxXf) {\n\tstyle.ApplyBorder = xf.ApplyBorder\n\tstyle.ApplyFill = xf.ApplyFill\n\tstyle.ApplyFont = xf.ApplyFont\n\tstyle.ApplyAlignment = xf.ApplyAlignment\n\n\tif xf.BorderId > -1 && xf.BorderId < styles.Borders.Count {\n\t\tborder := styles.Borders.Border[xf.BorderId]\n\t\tstyle.Border.Left = border.Left.Style\n\t\tstyle.Border.LeftColor = styles.argbValue(border.Left.Color)\n\t\tstyle.Border.Right = border.Right.Style\n\t\tstyle.Border.RightColor = styles.argbValue(border.Right.Color)\n\t\tstyle.Border.Top = border.Top.Style\n\t\tstyle.Border.TopColor = styles.argbValue(border.Top.Color)\n\t\tstyle.Border.Bottom = border.Bottom.Style\n\t\tstyle.Border.BottomColor = styles.argbValue(border.Bottom.Color)\n\t}\n\n\tif xf.FillId > -1 && xf.FillId < styles.Fills.Count {\n\t\txFill := styles.Fills.Fill[xf.FillId]\n\t\tstyle.Fill.PatternType = xFill.PatternFill.PatternType\n\t\tstyle.Fill.FgColor = styles.argbValue(xFill.PatternFill.FgColor)\n\t\tstyle.Fill.BgColor = styles.argbValue(xFill.PatternFill.BgColor)\n\t}\n\n\tif xf.FontId > -1 && xf.FontId < styles.Fonts.Count {\n\t\txfont := styles.Fonts.Font[xf.FontId]\n\t\tstyle.Font.Size, _ = strconv.ParseFloat(xfont.Sz.Val, 64)\n\t\tstyle.Font.Name = xfont.Name.Val\n\t\tstyle.Font.Family, _ = strconv.Atoi(xfont.Family.Val)\n\t\tstyle.Font.Charset, _ = strconv.Atoi(xfont.Charset.Val)\n\t\tstyle.Font.Color = styles.argbValue(xfont.Color)\n\n\t\tif bold := xfont.B; bold != nil && bold.Val != \"0\" {\n\t\t\tstyle.Font.Bold = true\n\t\t}\n\t\tif italic := xfont.I; italic != nil && italic.Val != \"0\" {\n\t\t\tstyle.Font.Italic = true\n\t\t}\n\t\tif underline := xfont.U; underline != nil && underline.Val != \"0\" {\n\t\t\tstyle.Font.Underline = true\n\t\t}\n\t\tif strike := xfont.Strike; strike != nil && strike.Val != \"0\" {\n\t\t\tstyle.Font.Strike = true\n\t\t}\n\t}\n\tif xf.Alignment.Horizontal != \"\" {\n\t\tstyle.Alignment.Horizontal = xf.Alignment.Horizontal\n\t}\n\n\tif xf.Alignment.Vertical != \"\" {\n\t\tstyle.Alignment.Vertical = xf.Alignment.Vertical\n\t}\n\n\tstyle.Alignment.ShrinkToFit = xf.Alignment.ShrinkToFit\n\tstyle.Alignment.WrapText = xf.Alignment.WrapText\n\tstyle.Alignment.TextRotation = xf.Alignment.TextRotation\n\n\tif xf.Alignment.Indent != 0 {\n\t\tstyle.Alignment.Indent = xf.Alignment.Indent\n\t}\n\n}\n\nfunc (styles *xlsxStyleSheet) getStyle(styleIndex int) *Style {\n\tstyles.styleCacheMU.RLock()\n\tstyle, ok := styles.styleCache[styleIndex]\n\tstyles.styleCacheMU.RUnlock()\n\tif ok {\n\t\treturn style\n\t}\n\n\tstyle = &Style{}\n\n\txfCount := styles.CellXfs.Count\n\tif styleIndex > -1 && xfCount > 0 && styleIndex < xfCount {\n\t\txf := styles.CellXfs.Xf[styleIndex]\n\t\tstyles.populateStyleFromXf(style, xf)\n\t\tif xf.XfId != nil && styles.CellStyleXfs != nil && *xf.XfId < len(styles.CellStyleXfs.Xf) {\n\t\t\tstyle.NamedStyleIndex = xf.XfId\n\t\t\tnamedStyleXf := styles.CellStyleXfs.Xf[*xf.XfId]\n\t\t\tstyle.ApplyBorder = style.ApplyBorder || namedStyleXf.ApplyBorder\n\t\t\tstyle.ApplyFill = style.ApplyFill || namedStyleXf.ApplyFill\n\t\t\tstyle.ApplyFont = style.ApplyFont || namedStyleXf.ApplyFont\n\t\t\tstyle.ApplyAlignment = style.ApplyAlignment || namedStyleXf.ApplyAlignment\n\t\t}\n\n\t\tif xf.Alignment.Vertical != \"\" {\n\t\t\tstyle.Alignment.Vertical = xf.Alignment.Vertical\n\t\t}\n\t\tstyle.Alignment.WrapText = xf.Alignment.WrapText\n\t\tstyle.Alignment.TextRotation = xf.Alignment.TextRotation\n\n\t\tstyles.styleCacheMU.Lock()\n\t\tstyles.styleCache[styleIndex] = style\n\t\tstyles.styleCacheMU.Unlock()\n\t}\n\treturn style\n}\n\nfunc (styles *xlsxStyleSheet) argbValue(color xlsxColor) string {\n\tif color.Theme != nil && styles.theme != nil {\n\t\treturn styles.theme.themeColor(int64(*color.Theme), color.Tint)\n\t}\n\tif color.Indexed != nil && styles.Colors != nil {\n\t\treturn styles.Colors.indexedColor(*color.Indexed)\n\t}\n\treturn color.RGB\n}\n\n// Excel styles can reference number formats that are built-in, all of which\n// have an id less than 164. This is a possibly incomplete list comprised of as\n// many of them as I could find.\nfunc getBuiltinNumberFormat(numFmtId int) string {\n\tnmfmt, ok := builtInNumFmt[numFmtId]\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn nmfmt\n}\n\nfunc (styles *xlsxStyleSheet) getNumberFormat(styleIndex int) (string, *parsedNumberFormat) {\n\tvar numberFormat string = \"general\"\n\tif styles.CellXfs.Xf != nil {\n\t\tif styleIndex > -1 && styleIndex < styles.CellXfs.Count {\n\t\t\txf := styles.CellXfs.Xf[styleIndex]\n\t\t\tif builtin := getBuiltinNumberFormat(xf.NumFmtId); builtin != \"\" {\n\t\t\t\tnumberFormat = builtin\n\t\t\t} else {\n\t\t\t\tstyles.numFmtRefTableMU.RLock()\n\t\t\t\tif styles.numFmtRefTable != nil {\n\t\t\t\t\tnumFmt := styles.numFmtRefTable[xf.NumFmtId]\n\t\t\t\t\tnumberFormat = numFmt.FormatCode\n\t\t\t\t}\n\t\t\t\tstyles.numFmtRefTableMU.RUnlock()\n\n\t\t\t}\n\t\t}\n\t}\n\tstyles.parsedNumFmtTableMU.RLock()\n\tparsedFmt, ok := styles.parsedNumFmtTable[numberFormat]\n\tstyles.parsedNumFmtTableMU.RUnlock()\n\tif !ok {\n\t\tstyles.parsedNumFmtTableMU.Lock()\n\t\tif styles.parsedNumFmtTable == nil {\n\t\t\tstyles.parsedNumFmtTable = map[string]*parsedNumberFormat{}\n\t\t}\n\t\tparsedFmt = parseFullNumberFormatString(numberFormat)\n\t\tstyles.parsedNumFmtTable[numberFormat] = parsedFmt\n\t\tstyles.parsedNumFmtTableMU.Unlock()\n\t}\n\n\treturn numberFormat, parsedFmt\n}\n\nfunc (styles *xlsxStyleSheet) addFont(xFont xlsxFont) (index int) {\n\tvar font xlsxFont\n\tif xFont.Name.Val == \"\" {\n\t\treturn 0\n\t}\n\tfor index, font = range styles.Fonts.Font {\n\t\tif font.Equals(xFont) {\n\t\t\treturn index\n\t\t}\n\t}\n\tstyles.Fonts.Font = append(styles.Fonts.Font, xFont)\n\tindex = styles.Fonts.Count\n\tstyles.Fonts.Count++\n\treturn\n}\n\nfunc (styles *xlsxStyleSheet) addFill(xFill xlsxFill) (index int) {\n\tvar fill xlsxFill\n\tfor index, fill = range styles.Fills.Fill {\n\t\tif fill.Equals(xFill) {\n\t\t\treturn index\n\t\t}\n\t}\n\tstyles.Fills.Fill = append(styles.Fills.Fill, xFill)\n\tindex = styles.Fills.Count\n\tstyles.Fills.Count++\n\treturn\n}\n\nfunc (styles *xlsxStyleSheet) addBorder(xBorder xlsxBorder) (index int) {\n\tvar border xlsxBorder\n\tfor index, border = range styles.Borders.Border {\n\t\tif border.Equals(xBorder) {\n\t\t\treturn index\n\t\t}\n\t}\n\tstyles.Borders.Border = append(styles.Borders.Border, xBorder)\n\tindex = styles.Borders.Count\n\n\tstyles.Borders.Count++\n\treturn\n}\n\nfunc (styles *xlsxStyleSheet) addCellXf(xCellXf xlsxXf) (index int) {\n\tvar cellXf xlsxXf\n\tfor index, cellXf = range styles.CellXfs.Xf {\n\t\tif cellXf.Equals(xCellXf) {\n\t\t\treturn index\n\t\t}\n\t}\n\n\tstyles.CellXfs.Xf = append(styles.CellXfs.Xf, xCellXf)\n\tindex = styles.CellXfs.Count\n\tstyles.CellXfs.Count++\n\treturn\n}\n\n// newNumFmt generate a xlsxNumFmt according the format code. When the FormatCode is built in, it will return a xlsxNumFmt with the NumFmtId defined in ECMA document, otherwise it will generate a new NumFmtId greater than 164.\nfunc (styles *xlsxStyleSheet) newNumFmt(formatCode string) xlsxNumFmt {\n\tif compareFormatString(formatCode, \"general\") {\n\t\treturn xlsxNumFmt{NumFmtId: 0, FormatCode: \"general\"}\n\t}\n\t// built in NumFmts in xmlStyle.go, traverse from the const.\n\tnumFmtId, ok := builtInNumFmtInv[formatCode]\n\tif ok {\n\t\treturn xlsxNumFmt{NumFmtId: numFmtId, FormatCode: formatCode}\n\t}\n\n\t// find the exist xlsxNumFmt\n\tif styles.NumFmts != nil {\n\t\tfor _, numFmt := range styles.NumFmts.NumFmt {\n\t\t\tif formatCode == numFmt.FormatCode {\n\t\t\t\treturn numFmt\n\t\t\t}\n\t\t}\n\t}\n\n\t// The user define NumFmtId. The one less than 164 in built in.\n\tnumFmtId = builtinNumFmtsCount + 1\n\n\tfor {\n\t\t// get a unused NumFmtId\n\t\tstyles.numFmtRefTableMU.RLock()\n\t\t_, ok := styles.numFmtRefTable[numFmtId]\n\t\tstyles.numFmtRefTableMU.RUnlock()\n\t\tif ok {\n\t\t\tnumFmtId++\n\t\t} else {\n\t\t\t// addNumFmt contains locking code, so we don't lock around it.\n\t\t\tstyles.addNumFmt(xlsxNumFmt{NumFmtId: numFmtId, FormatCode: formatCode})\n\t\t\tbreak\n\t\t}\n\t}\n\treturn xlsxNumFmt{NumFmtId: numFmtId, FormatCode: formatCode}\n}\n\n// addNumFmt add xlsxNumFmt if its not exist.\nfunc (styles *xlsxStyleSheet) addNumFmt(xNumFmt xlsxNumFmt) {\n\t// don't add built in NumFmt\n\tif _, ok := builtInNumFmt[xNumFmt.NumFmtId]; ok {\n\t\treturn\n\t}\n\tstyles.numFmtRefTableMU.RLock()\n\t_, ok := styles.numFmtRefTable[xNumFmt.NumFmtId]\n\tstyles.numFmtRefTableMU.RUnlock()\n\tif !ok {\n\t\tif styles.numFmtRefTable == nil {\n\t\t\tstyles.numFmtRefTableMU.Lock()\n\t\t\tstyles.numFmtRefTable = make(map[int]xlsxNumFmt)\n\t\t\tstyles.numFmtRefTableMU.Unlock()\n\t\t}\n\t\tif styles.NumFmts == nil {\n\t\t\tstyles.NumFmts = &xlsxNumFmts{}\n\t\t}\n\t\tstyles.NumFmts.NumFmt = append(styles.NumFmts.NumFmt, xNumFmt)\n\t\tstyles.numFmtRefTableMU.Lock()\n\t\tstyles.numFmtRefTable[xNumFmt.NumFmtId] = xNumFmt\n\t\tstyles.numFmtRefTableMU.Unlock()\n\t\tstyles.NumFmts.Count++\n\t}\n}\n\nfunc (styles *xlsxStyleSheet) Marshal() (string, error) {\n\tresult := xml.Header + `<styleSheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\">`\n\n\tif styles.NumFmts != nil {\n\t\txNumFmts, err := styles.NumFmts.Marshal()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tresult += xNumFmts\n\t}\n\n\toutputFontMap := make(map[int]int)\n\txfonts, err := styles.Fonts.Marshal(outputFontMap)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tresult += xfonts\n\n\toutputFillMap := make(map[int]int)\n\txfills, err := styles.Fills.Marshal(outputFillMap)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tresult += xfills\n\n\toutputBorderMap := make(map[int]int)\n\txborders, err := styles.Borders.Marshal(outputBorderMap)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tresult += xborders\n\n\tif styles.CellStyleXfs != nil {\n\t\txcellStyleXfs, err := styles.CellStyleXfs.Marshal(outputBorderMap, outputFillMap, outputFontMap)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tresult += xcellStyleXfs\n\t}\n\n\txcellXfs, err := styles.CellXfs.Marshal(outputBorderMap, outputFillMap, outputFontMap)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tresult += xcellXfs\n\tif styles.CellStyles != nil && styles.CellStyleXfs != nil {\n\t\txcellStyles, err := styles.CellStyles.Marshal(styles.CellStyleXfs.Count - 1)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tresult += xcellStyles\n\t}\n\n\treturn result + \"</styleSheet>\", nil\n}\n\ntype xlsxDXFs struct {\n\tCount int `xml:\"count,attr\"`\n}\n\n// xlsxNumFmts directly maps the numFmts element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxNumFmts struct {\n\tCount  int          `xml:\"count,attr\"`\n\tNumFmt []xlsxNumFmt `xml:\"numFmt,omitempty\"`\n}\n\nfunc (numFmts *xlsxNumFmts) Marshal() (result string, err error) {\n\tif numFmts.Count > 0 {\n\t\tresult = fmt.Sprintf(`<numFmts count=\"%d\">`, numFmts.Count)\n\t\tfor _, numFmt := range numFmts.NumFmt {\n\t\t\tvar xNumFmt string\n\t\t\txNumFmt, err = numFmt.Marshal()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresult += xNumFmt\n\t\t}\n\t\tresult += `</numFmts>`\n\t}\n\treturn\n}\n\n// xlsxNumFmt directly maps the numFmt element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxNumFmt struct {\n\tNumFmtId   int    `xml:\"numFmtId,attr,omitempty\"`\n\tFormatCode string `xml:\"formatCode,attr,omitempty\"`\n}\n\nfunc (numFmt *xlsxNumFmt) Marshal() (result string, err error) {\n\tformatCode := &bytes.Buffer{}\n\tif err := xml.EscapeText(formatCode, []byte(numFmt.FormatCode)); err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn fmt.Sprintf(`<numFmt numFmtId=\"%d\" formatCode=\"%s\"/>`, numFmt.NumFmtId, formatCode), nil\n}\n\n// xlsxFonts directly maps the fonts element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxFonts struct {\n\tXMLName xml.Name `xml:\"fonts\"`\n\n\tCount int        `xml:\"count,attr\"`\n\tFont  []xlsxFont `xml:\"font,omitempty\"`\n}\n\nfunc (fonts *xlsxFonts) addFont(font xlsxFont) {\n\tfonts.Font = append(fonts.Font, font)\n\tfonts.Count++\n}\n\nfunc (fonts *xlsxFonts) Marshal(outputFontMap map[int]int) (result string, err error) {\n\temittedCount := 0\n\tsubparts := \"\"\n\n\tfor i, font := range fonts.Font {\n\t\tvar xfont string\n\t\txfont, err = font.Marshal()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif xfont != \"\" {\n\t\t\toutputFontMap[i] = emittedCount\n\t\t\temittedCount++\n\t\t\tsubparts += xfont\n\t\t}\n\t}\n\tif emittedCount > 0 {\n\t\tresult = fmt.Sprintf(`<fonts count=\"%d\">`, fonts.Count)\n\t\tresult += subparts\n\t\tresult += `</fonts>`\n\t}\n\treturn\n}\n\n// xlsxFont directly maps the font element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxFont struct {\n\tSz      xlsxVal   `xml:\"sz,omitempty\"`\n\tName    xlsxVal   `xml:\"name,omitempty\"`\n\tFamily  xlsxVal   `xml:\"family,omitempty\"`\n\tCharset xlsxVal   `xml:\"charset,omitempty\"`\n\tColor   xlsxColor `xml:\"color,omitempty\"`\n\tB       *xlsxVal  `xml:\"b,omitempty\"`\n\tI       *xlsxVal  `xml:\"i,omitempty\"`\n\tU       *xlsxVal  `xml:\"u,omitempty\"`\n\tScheme  *xlsxVal  `xml:\"scheme,omitempty\"`\n\tStrike  *xlsxVal  `xml:\"strike,omitempty\"`\n}\n\nfunc (font *xlsxFont) Equals(other xlsxFont) bool {\n\tif (font.B == nil && other.B != nil) || (font.B != nil && other.B == nil) {\n\t\treturn false\n\t}\n\tif (font.I == nil && other.I != nil) || (font.I != nil && other.I == nil) {\n\t\treturn false\n\t}\n\tif (font.U == nil && other.U != nil) || (font.U != nil && other.U == nil) {\n\t\treturn false\n\t}\n\treturn font.Sz.Equals(other.Sz) && font.Name.Equals(other.Name) && font.Family.Equals(other.Family) && font.Charset.Equals(other.Charset) && font.Color.Equals(other.Color)\n}\n\nfunc (font *xlsxFont) Marshal() (result string, err error) {\n\tresult = \"<font>\"\n\tif font.Sz.Val != \"\" {\n\t\tresult += fmt.Sprintf(`<sz val=\"%s\"/>`, font.Sz.Val)\n\t}\n\tif font.Name.Val != \"\" {\n\t\tresult += fmt.Sprintf(`<name val=\"%s\"/>`, font.Name.Val)\n\t}\n\tif font.Family.Val != \"\" {\n\t\tresult += fmt.Sprintf(`<family val=\"%s\"/>`, font.Family.Val)\n\t}\n\tif font.Charset.Val != \"\" {\n\t\tresult += fmt.Sprintf(`<charset val=\"%s\"/>`, font.Charset.Val)\n\t}\n\tif font.Color.RGB != \"\" {\n\t\tresult += fmt.Sprintf(`<color rgb=\"%s\"/>`, font.Color.RGB)\n\t}\n\tif font.Color.Theme != nil {\n\t\tresult += fmt.Sprintf(`<color theme=\"%d\" />`, *font.Color.Theme)\n\t}\n\tif font.Scheme != nil && font.Scheme.Val != \"\" {\n\t\tresult += fmt.Sprintf(`<scheme val=\"%s\"/>`, font.Scheme.Val)\n\t}\n\tif font.B != nil {\n\t\tresult += \"<b/>\"\n\t}\n\tif font.I != nil {\n\t\tresult += \"<i/>\"\n\t}\n\tif font.U != nil {\n\t\tresult += \"<u/>\"\n\t}\n\tif font.Strike != nil {\n\t\tresult += \"<strike/>\"\n\t}\n\treturn result + \"</font>\", nil\n}\n\n// xlsxVal directly maps the val element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxVal struct {\n\tVal string `xml:\"val,attr,omitempty\"`\n}\n\nfunc (val *xlsxVal) Equals(other xlsxVal) bool {\n\treturn val.Val == other.Val\n}\n\n// xlsxFills directly maps the fills element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxFills struct {\n\tCount int        `xml:\"count,attr\"`\n\tFill  []xlsxFill `xml:\"fill,omitempty\"`\n}\n\nfunc (fills *xlsxFills) addFill(fill xlsxFill) {\n\tfills.Fill = append(fills.Fill, fill)\n\tfills.Count++\n}\n\nfunc (fills *xlsxFills) Marshal(outputFillMap map[int]int) (string, error) {\n\tvar subparts string\n\tvar emittedCount int\n\tfor i, fill := range fills.Fill {\n\t\txfill, err := fill.Marshal()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif xfill != \"\" {\n\t\t\toutputFillMap[i] = emittedCount\n\t\t\temittedCount++\n\t\t\tsubparts += xfill\n\t\t}\n\t}\n\tvar result string\n\tif emittedCount > 0 {\n\t\tresult = fmt.Sprintf(`<fills count=\"%d\">`, emittedCount)\n\t\tresult += subparts\n\t\tresult += `</fills>`\n\t}\n\treturn result, nil\n}\n\n// xlsxFill directly maps the fill element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxFill struct {\n\tPatternFill xlsxPatternFill `xml:\"patternFill,omitempty\"`\n}\n\nfunc (fill *xlsxFill) Equals(other xlsxFill) bool {\n\treturn fill.PatternFill.Equals(other.PatternFill)\n}\n\nfunc (fill *xlsxFill) Marshal() (result string, err error) {\n\tif fill.PatternFill.PatternType != \"\" {\n\t\tvar xpatternFill string\n\t\tresult = `<fill>`\n\n\t\txpatternFill, err = fill.PatternFill.Marshal()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tresult += xpatternFill\n\t\tresult += `</fill>`\n\t}\n\treturn\n}\n\n// xlsxPatternFill directly maps the patternFill element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxPatternFill struct {\n\tPatternType string    `xml:\"patternType,attr,omitempty\"`\n\tFgColor     xlsxColor `xml:\"fgColor,omitempty\"`\n\tBgColor     xlsxColor `xml:\"bgColor,omitempty\"`\n}\n\nfunc (patternFill *xlsxPatternFill) Equals(other xlsxPatternFill) bool {\n\treturn patternFill.PatternType == other.PatternType && patternFill.FgColor.Equals(other.FgColor) && patternFill.BgColor.Equals(other.BgColor)\n}\n\nfunc (patternFill *xlsxPatternFill) Marshal() (result string, err error) {\n\tresult = fmt.Sprintf(`<patternFill patternType=\"%s\"`, patternFill.PatternType)\n\tending := `/>`\n\tterminator := \"\"\n\tsubparts := \"\"\n\tif patternFill.FgColor.RGB != \"\" {\n\t\tending = `>`\n\t\tterminator = \"</patternFill>\"\n\t\tsubparts += fmt.Sprintf(`<fgColor rgb=\"%s\"/>`, patternFill.FgColor.RGB)\n\t}\n\tif patternFill.BgColor.RGB != \"\" {\n\t\tending = `>`\n\t\tterminator = \"</patternFill>\"\n\t\tsubparts += fmt.Sprintf(`<bgColor rgb=\"%s\"/>`, patternFill.BgColor.RGB)\n\t}\n\tresult += ending\n\tresult += subparts\n\tresult += terminator\n\treturn\n}\n\n// xlsxColor is a common mapping used for both the fgColor and bgColor\n// elements in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxColor struct {\n\tRGB     string  `xml:\"rgb,attr,omitempty\"`\n\tTheme   *int    `xml:\"theme,attr,omitempty\"`\n\tTint    float64 `xml:\"tint,attr,omitempty\"`\n\tIndexed *int    `xml:\"indexed,attr,omitempty\"`\n}\n\nfunc (color *xlsxColor) Equals(other xlsxColor) bool {\n\treturn color.RGB == other.RGB\n}\n\n// xlsxBorders directly maps the borders element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxBorders struct {\n\tCount  int          `xml:\"count,attr\"`\n\tBorder []xlsxBorder `xml:\"border\"`\n}\n\nfunc (borders *xlsxBorders) addBorder(border xlsxBorder) {\n\tborders.Border = append(borders.Border, border)\n\tborders.Count++\n}\n\nfunc (borders *xlsxBorders) Marshal(outputBorderMap map[int]int) (result string, err error) {\n\tresult = \"\"\n\temittedCount := 0\n\tsubparts := \"\"\n\tfor i, border := range borders.Border {\n\t\tvar xborder string\n\t\txborder, err = border.Marshal()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tif xborder != \"\" {\n\t\t\toutputBorderMap[i] = emittedCount\n\t\t\temittedCount++\n\t\t\tsubparts += xborder\n\t\t}\n\t}\n\tif emittedCount > 0 {\n\t\tresult += fmt.Sprintf(`<borders count=\"%d\">`, emittedCount)\n\t\tresult += subparts\n\t\tresult += `</borders>`\n\t}\n\treturn\n}\n\n// xlsxBorder directly maps the border element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxBorder struct {\n\tLeft   xlsxLine `xml:\"left,omitempty\"`\n\tRight  xlsxLine `xml:\"right,omitempty\"`\n\tTop    xlsxLine `xml:\"top,omitempty\"`\n\tBottom xlsxLine `xml:\"bottom,omitempty\"`\n}\n\nfunc (border *xlsxBorder) Equals(other xlsxBorder) bool {\n\treturn border.Left.Equals(other.Left) && border.Right.Equals(other.Right) && border.Top.Equals(other.Top) && border.Bottom.Equals(other.Bottom)\n}\n\nfunc (border *xlsxBorder) marshalBorderLine(line xlsxLine, name string) string {\n\tif line.Style == \"\" {\n\t\treturn fmt.Sprintf(\"<%s/>\", name)\n\t}\n\tsubparts := \"\"\n\tsubparts += fmt.Sprintf(`<%s style=\"%s\">`, name, line.Style)\n\tif line.Color.RGB != \"\" {\n\t\tsubparts += fmt.Sprintf(`<color rgb=\"%s\"/>`, line.Color.RGB)\n\t}\n\tsubparts += fmt.Sprintf(`</%s>`, name)\n\treturn subparts\n}\n\n// To get borders to work correctly in Excel, you have to always start with an\n// empty set of borders. There was logic in this function that would strip out\n// empty elements, but unfortunately that would cause the border to fail.\nfunc (border *xlsxBorder) Marshal() (result string, err error) {\n\tsubparts := border.marshalBorderLine(border.Left, \"left\")\n\tsubparts += border.marshalBorderLine(border.Right, \"right\")\n\tsubparts += border.marshalBorderLine(border.Top, \"top\")\n\tsubparts += border.marshalBorderLine(border.Bottom, \"bottom\")\n\tresult += `<border>`\n\tresult += subparts\n\tresult += `</border>`\n\treturn\n}\n\n// xlsxLine directly maps the line style element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxLine struct {\n\tStyle string    `xml:\"style,attr,omitempty\"`\n\tColor xlsxColor `xml:\"color,omitempty\"`\n}\n\nfunc (line *xlsxLine) Equals(other xlsxLine) bool {\n\treturn line.Style == other.Style && line.Color.Equals(other.Color)\n}\n\ntype xlsxCellStyles struct {\n\tXMLName   xml.Name        `xml:\"cellStyles\"`\n\tCount     int             `xml:\"count,attr\"`\n\tCellStyle []xlsxCellStyle `xml:\"cellStyle,omitempty\"`\n}\n\nfunc (cellStyles *xlsxCellStyles) Marshal(maxXfId int) (result string, err error) {\n\tstylesCount := 0\n\tfor _, cellStyle := range cellStyles.CellStyle {\n\t\tif cellStyle.XfId <= maxXfId {\n\t\t\tstylesCount++\n\t\t}\n\t}\n\n\tif stylesCount > 0 {\n\t\tresult = fmt.Sprintf(`<cellStyles count=\"%d\">`, stylesCount)\n\t\tfor _, cellStyle := range cellStyles.CellStyle {\n\t\t\tif cellStyle.XfId > maxXfId {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar xCellStyle []byte\n\t\t\txCellStyle, err = xml.Marshal(cellStyle)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresult += string(xCellStyle)\n\t\t}\n\t\tresult += `</cellStyles>`\n\t}\n\treturn\n\n}\n\ntype xlsxCellStyle struct {\n\tXMLName       xml.Name `xml:\"cellStyle\"`\n\tBuiltInId     *int     `xml:\"builtInId,attr,omitempty\"`\n\tCustomBuiltIn *bool    `xml:\"customBuiltIn,attr,omitempty\"`\n\tHidden        *bool    `xml:\"hidden,attr,omitempty\"`\n\tILevel        *bool    `xml:\"iLevel,attr,omitempty\"`\n\tName          string   `xml:\"name,attr\"`\n\tXfId          int      `xml:\"xfId,attr\"`\n}\n\n// xlsxCellStyleXfs directly maps the cellStyleXfs element in the\n// namespace http://schemas.openxmlformats.org/spreadsheetml/2006/main\n// - currently I have not checked it for completeness - it does as\n// much as I need.\ntype xlsxCellStyleXfs struct {\n\tCount int      `xml:\"count,attr\"`\n\tXf    []xlsxXf `xml:\"xf,omitempty\"`\n}\n\nfunc (cellStyleXfs *xlsxCellStyleXfs) addXf(Xf xlsxXf) {\n\tcellStyleXfs.Xf = append(cellStyleXfs.Xf, Xf)\n\tcellStyleXfs.Count++\n}\n\nfunc (cellStyleXfs *xlsxCellStyleXfs) Marshal(outputBorderMap, outputFillMap, outputFontMap map[int]int) (result string, err error) {\n\tif cellStyleXfs.Count > 0 {\n\t\tresult = fmt.Sprintf(`<cellStyleXfs count=\"%d\">`, cellStyleXfs.Count)\n\t\tfor _, xf := range cellStyleXfs.Xf {\n\t\t\tvar xxf string\n\t\t\txxf, err = xf.Marshal(outputBorderMap, outputFillMap, outputFontMap)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresult += xxf\n\t\t}\n\t\tresult += `</cellStyleXfs>`\n\t}\n\treturn\n}\n\n// xlsxCellXfs directly maps the cellXfs element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxCellXfs struct {\n\tCount int      `xml:\"count,attr\"`\n\tXf    []xlsxXf `xml:\"xf,omitempty\"`\n}\n\nfunc (cellXfs *xlsxCellXfs) addXf(Xf xlsxXf) {\n\tcellXfs.Xf = append(cellXfs.Xf, Xf)\n\tcellXfs.Count++\n}\n\nfunc (cellXfs *xlsxCellXfs) Marshal(outputBorderMap, outputFillMap, outputFontMap map[int]int) (result string, err error) {\n\tif cellXfs.Count > 0 {\n\t\tresult = fmt.Sprintf(`<cellXfs count=\"%d\">`, cellXfs.Count)\n\t\tfor _, xf := range cellXfs.Xf {\n\t\t\tvar xxf string\n\t\t\txxf, err = xf.Marshal(outputBorderMap, outputFillMap, outputFontMap)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresult += xxf\n\t\t}\n\t\tresult += `</cellXfs>`\n\t}\n\treturn\n}\n\n// xlsxXf directly maps the xf element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxXf struct {\n\tApplyAlignment    bool          `xml:\"applyAlignment,attr\"`\n\tApplyBorder       bool          `xml:\"applyBorder,attr\"`\n\tApplyFont         bool          `xml:\"applyFont,attr\"`\n\tApplyFill         bool          `xml:\"applyFill,attr\"`\n\tApplyNumberFormat bool          `xml:\"applyNumberFormat,attr\"`\n\tApplyProtection   bool          `xml:\"applyProtection,attr\"`\n\tBorderId          int           `xml:\"borderId,attr\"`\n\tFillId            int           `xml:\"fillId,attr\"`\n\tFontId            int           `xml:\"fontId,attr\"`\n\tNumFmtId          int           `xml:\"numFmtId,attr\"`\n\tXfId              *int          `xml:\"xfId,attr,omitempty\"`\n\tAlignment         xlsxAlignment `xml:\"alignment\"`\n}\n\nfunc (xf *xlsxXf) Equals(other xlsxXf) bool {\n\treturn xf.ApplyAlignment == other.ApplyAlignment &&\n\t\txf.ApplyBorder == other.ApplyBorder &&\n\t\txf.ApplyFont == other.ApplyFont &&\n\t\txf.ApplyFill == other.ApplyFill &&\n\t\txf.ApplyProtection == other.ApplyProtection &&\n\t\txf.BorderId == other.BorderId &&\n\t\txf.FillId == other.FillId &&\n\t\txf.FontId == other.FontId &&\n\t\txf.NumFmtId == other.NumFmtId &&\n\t\t(xf.XfId == other.XfId ||\n\t\t\t((xf.XfId != nil && other.XfId != nil) &&\n\t\t\t\t*xf.XfId == *other.XfId)) &&\n\t\txf.Alignment.Equals(other.Alignment)\n}\n\nfunc (xf *xlsxXf) Marshal(outputBorderMap, outputFillMap, outputFontMap map[int]int) (result string, err error) {\n\tresult = fmt.Sprintf(`<xf applyAlignment=\"%b\" applyBorder=\"%b\" applyFont=\"%b\" applyFill=\"%b\" applyNumberFormat=\"%b\" applyProtection=\"%b\" borderId=\"%d\" fillId=\"%d\" fontId=\"%d\" numFmtId=\"%d\"`, bool2Int(xf.ApplyAlignment), bool2Int(xf.ApplyBorder), bool2Int(xf.ApplyFont), bool2Int(xf.ApplyFill), bool2Int(xf.ApplyNumberFormat), bool2Int(xf.ApplyProtection), outputBorderMap[xf.BorderId], outputFillMap[xf.FillId], outputFontMap[xf.FontId], xf.NumFmtId)\n\tif xf.XfId != nil {\n\t\tresult += fmt.Sprintf(` xfId=\"%d\"`, *xf.XfId)\n\t}\n\tresult += \">\"\n\txAlignment, err := xf.Alignment.Marshal()\n\tif err != nil {\n\t\treturn result, err\n\t}\n\treturn result + xAlignment + \"</xf>\", nil\n}\n\ntype xlsxAlignment struct {\n\tHorizontal   string `xml:\"horizontal,attr\"`\n\tIndent       int    `xml:\"indent,attr\"`\n\tShrinkToFit  bool   `xml:\"shrinkToFit,attr\"`\n\tTextRotation int    `xml:\"textRotation,attr\"`\n\tVertical     string `xml:\"vertical,attr\"`\n\tWrapText     bool   `xml:\"wrapText,attr\"`\n}\n\nfunc (alignment *xlsxAlignment) Equals(other xlsxAlignment) bool {\n\treturn alignment.Horizontal == other.Horizontal &&\n\t\talignment.Indent == other.Indent &&\n\t\talignment.ShrinkToFit == other.ShrinkToFit &&\n\t\talignment.TextRotation == other.TextRotation &&\n\t\talignment.Vertical == other.Vertical &&\n\t\talignment.WrapText == other.WrapText\n}\n\nfunc (alignment *xlsxAlignment) Marshal() (result string, err error) {\n\tif alignment.Horizontal == \"\" {\n\t\talignment.Horizontal = \"general\"\n\t}\n\tif alignment.Vertical == \"\" {\n\t\talignment.Vertical = \"bottom\"\n\t}\n\treturn fmt.Sprintf(`<alignment horizontal=\"%s\" indent=\"%d\" shrinkToFit=\"%b\" textRotation=\"%d\" vertical=\"%s\" wrapText=\"%b\"/>`, alignment.Horizontal, alignment.Indent, bool2Int(alignment.ShrinkToFit), alignment.TextRotation, alignment.Vertical, bool2Int(alignment.WrapText)), nil\n}\n\nfunc bool2Int(b bool) int {\n\tif b {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\ntype xlsxRgbColor struct {\n\tRgb string `xml:\"rgb,attr\"`\n}\n\ntype xlsxColors struct {\n\tIndexedColors []xlsxRgbColor `xml:\"indexedColors>rgbColor,omitempty\"`\n\tMruColors     []xlsxColor    `xml:\"mruColors>color,omitempty\"`\n}\n\n// indexerdColor returns ARGB color string for the given index of the IndexedColors.\n// Indexes start from 0, see section 18.8.27 of ECMA-376 (part 1, 4th edition).\nfunc (c *xlsxColors) indexedColor(index int) string {\n\tif index < 0 {\n\t\treturn \"\"\n\t}\n\n\tif c.IndexedColors != nil && index < len(c.IndexedColors) {\n\t\treturn c.IndexedColors[index].Rgb\n\t}\n\n\t// This is a weird fallback? Why would we be using indexed colours\n\t// in a file that hasn't defined any?\n\tif index < len(xlsxIndexedColors) {\n\t\treturn xlsxIndexedColors[index]\n\t}\n\treturn \"\"\n}\n"
        },
        {
          "name": "xmlStyle_test.go",
          "type": "blob",
          "size": 19.9541015625,
          "content": "package xlsx\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\nfunc TestIndexedColor(t *testing.T) {\n\tc := qt.New(t)\n\n\tcolors := xlsxColors{}\n\tc.Run(\"Unitialised\", func(c *qt.C) {\n\t\tc.Assert(colors.indexedColor(0), qt.Equals, \"FF000000\")\n\t})\n\n\tc.Run(\"Initialised\", func(c *qt.C) {\n\t\tcolors.IndexedColors = []xlsxRgbColor{{Rgb: \"00FF00FF\"}}\n\t\tc.Assert(colors.indexedColor(0), qt.Equals, \"00FF00FF\")\n\t})\n}\n\nfunc TestXMLStyle(t *testing.T) {\n\tc := qt.New(t)\n\n\t// Test we produce valid output for an empty style file.\n\tc.Run(\"MarshalEmptyXlsxStyleSheet\", func(c *qt.C) {\n\t\tstyles := newXlsxStyleSheet(nil)\n\t\tresult, err := styles.Marshal()\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(string(result), qt.Equals, `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<styleSheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"></styleSheet>`)\n\t})\n\n\t// Test we produce valid output for a style file with one font definition.\n\tc.Run(\"MarshalXlsxStyleSheetWithAFont\", func(c *qt.C) {\n\t\tstyles := newXlsxStyleSheet(nil)\n\t\tstyles.Fonts = xlsxFonts{}\n\t\tstyles.Fonts.Count = 1\n\t\tstyles.Fonts.Font = make([]xlsxFont, 1)\n\t\tfont := xlsxFont{}\n\t\tfont.Sz.Val = \"10\"\n\t\tfont.Name.Val = \"Andale Mono\"\n\t\tfont.B = &xlsxVal{}\n\t\tfont.I = &xlsxVal{}\n\t\tfont.U = &xlsxVal{}\n\t\tfont.Strike = &xlsxVal{}\n\t\tstyles.Fonts.Font[0] = font\n\n\t\texpected := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<styleSheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"><fonts count=\"1\"><font><sz val=\"10\"/><name val=\"Andale Mono\"/><b/><i/><u/><strike/></font></fonts></styleSheet>`\n\t\tresult, err := styles.Marshal()\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(string(result), qt.Equals, expected)\n\t})\n\n\t// Test we produce valid output for a style file with one fill definition.\n\tc.Run(\"MarshalXlsxStyleSheetWithAFill\", func(c *qt.C) {\n\t\tstyles := newXlsxStyleSheet(nil)\n\t\tstyles.Fills = xlsxFills{}\n\t\tstyles.Fills.Count = 1\n\t\tstyles.Fills.Fill = make([]xlsxFill, 1)\n\t\tfill := xlsxFill{}\n\t\tpatternFill := xlsxPatternFill{\n\t\t\tPatternType: \"solid\",\n\t\t\tFgColor:     xlsxColor{RGB: \"#FFFFFF\"},\n\t\t\tBgColor:     xlsxColor{RGB: \"#000000\"}}\n\t\tfill.PatternFill = patternFill\n\t\tstyles.Fills.Fill[0] = fill\n\n\t\texpected := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<styleSheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"><fills count=\"1\"><fill><patternFill patternType=\"solid\"><fgColor rgb=\"#FFFFFF\"/><bgColor rgb=\"#000000\"/></patternFill></fill></fills></styleSheet>`\n\t\tresult, err := styles.Marshal()\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(string(result), qt.Equals, expected)\n\t})\n\n\t// Test we produce valid output for a style file with one border definition.\n\t// Empty elements are required to accommodate for Excel quirks.\n\tc.Run(\"MarshalXlsxStyleSheetWithABorder\", func(c *qt.C) {\n\t\tstyles := newXlsxStyleSheet(nil)\n\t\tstyles.Borders = xlsxBorders{}\n\t\tstyles.Borders.Count = 1\n\t\tstyles.Borders.Border = make([]xlsxBorder, 1)\n\t\tborder := xlsxBorder{}\n\t\tborder.Left.Style = \"solid\"\n\t\tborder.Top.Style = \"\"\n\t\tstyles.Borders.Border[0] = border\n\t\texpected := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<styleSheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"><borders count=\"1\"><border><left style=\"solid\"></left><right/><top/><bottom/></border></borders></styleSheet>`\n\n\t\tresult, err := styles.Marshal()\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(string(result), qt.Equals, expected)\n\t})\n\n\t// Test we produce valid output for a style file with one cellStyleXf definition.\n\tc.Run(\"MarshalXlsxStyleSheetWithACellStyleXf\", func(c *qt.C) {\n\t\tstyles := newXlsxStyleSheet(nil)\n\t\tstyles.CellStyleXfs = &xlsxCellStyleXfs{}\n\t\tstyles.CellStyleXfs.Count = 1\n\t\tstyles.CellStyleXfs.Xf = make([]xlsxXf, 1)\n\t\txf := xlsxXf{}\n\t\txf.ApplyAlignment = true\n\t\txf.ApplyBorder = true\n\t\txf.ApplyFont = true\n\t\txf.ApplyFill = true\n\t\txf.ApplyProtection = true\n\t\txf.BorderId = 0\n\t\txf.FillId = 0\n\t\txf.FontId = 0\n\t\txf.NumFmtId = 0\n\t\txf.Alignment = xlsxAlignment{\n\t\t\tHorizontal:   \"left\",\n\t\t\tIndent:       1,\n\t\t\tShrinkToFit:  true,\n\t\t\tTextRotation: 0,\n\t\t\tVertical:     \"middle\",\n\t\t\tWrapText:     false}\n\t\tstyles.CellStyleXfs.Xf[0] = xf\n\n\t\texpected := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<styleSheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"><cellStyleXfs count=\"1\"><xf applyAlignment=\"1\" applyBorder=\"1\" applyFont=\"1\" applyFill=\"1\" applyNumberFormat=\"0\" applyProtection=\"1\" borderId=\"0\" fillId=\"0\" fontId=\"0\" numFmtId=\"0\"><alignment horizontal=\"left\" indent=\"1\" shrinkToFit=\"1\" textRotation=\"0\" vertical=\"middle\" wrapText=\"0\"/></xf></cellStyleXfs></styleSheet>`\n\t\tresult, err := styles.Marshal()\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(string(result), qt.Equals, expected)\n\t})\n\n\t// Test we produce valid output for a style file with one cellStyle definition.\n\tc.Run(\"MarshalXlsxStyleSheetWithACellStyle\", func(c *qt.C) {\n\t\tvar builtInId int\n\t\tstyles := newXlsxStyleSheet(nil)\n\t\tstyles.CellStyles = &xlsxCellStyles{Count: 2}\n\t\tstyles.CellStyles.CellStyle = make([]xlsxCellStyle, 2)\n\n\t\tbuiltInId = 31\n\t\tstyles.CellStyles.CellStyle[0] = xlsxCellStyle{\n\t\t\tName:      \"Bob\",\n\t\t\tBuiltInId: &builtInId, // XXX Todo - work out built-ins!\n\t\t\tXfId:      0,\n\t\t}\n\t\tstyles.CellStyles.CellStyle[1] = xlsxCellStyle{\n\t\t\tName: \"Unknown\",\n\t\t\tXfId: 1,\n\t\t}\n\t\tstyles.CellStyleXfs = &xlsxCellStyleXfs{\n\t\t\tCount: 1,\n\t\t\tXf:    []xlsxXf{{}},\n\t\t}\n\t\texpected := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<styleSheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"><cellStyleXfs count=\"1\"><xf applyAlignment=\"0\" applyBorder=\"0\" applyFont=\"0\" applyFill=\"0\" applyNumberFormat=\"0\" applyProtection=\"0\" borderId=\"0\" fillId=\"0\" fontId=\"0\" numFmtId=\"0\"><alignment horizontal=\"general\" indent=\"0\" shrinkToFit=\"0\" textRotation=\"0\" vertical=\"bottom\" wrapText=\"0\"/></xf></cellStyleXfs><cellStyles count=\"1\"><cellStyle builtInId=\"31\" name=\"Bob\" xfId=\"0\"></cellStyle></cellStyles></styleSheet>`\n\t\tresult, err := styles.Marshal()\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(string(result), qt.Equals, expected)\n\t})\n\n\t// Test we produce valid output for a style file with one cellXf\n\t// definition.\n\tc.Run(\"MarshalXlsxStyleSheetWithACellXf\", func(c *qt.C) {\n\t\tstyles := newXlsxStyleSheet(nil)\n\t\tstyles.CellXfs = xlsxCellXfs{}\n\t\tstyles.CellXfs.Count = 1\n\t\tstyles.CellXfs.Xf = make([]xlsxXf, 1)\n\t\txf := xlsxXf{}\n\t\txf.ApplyAlignment = true\n\t\txf.ApplyBorder = true\n\t\txf.ApplyFont = true\n\t\txf.ApplyFill = true\n\t\txf.ApplyNumberFormat = true\n\t\txf.ApplyProtection = true\n\t\txf.BorderId = 0\n\t\txf.FillId = 0\n\t\txf.FontId = 0\n\t\txf.NumFmtId = 0\n\t\txf.Alignment = xlsxAlignment{\n\t\t\tHorizontal:   \"left\",\n\t\t\tIndent:       1,\n\t\t\tShrinkToFit:  true,\n\t\t\tTextRotation: 0,\n\t\t\tVertical:     \"middle\",\n\t\t\tWrapText:     false}\n\t\tstyles.CellXfs.Xf[0] = xf\n\n\t\texpected := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<styleSheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"><cellXfs count=\"1\"><xf applyAlignment=\"1\" applyBorder=\"1\" applyFont=\"1\" applyFill=\"1\" applyNumberFormat=\"1\" applyProtection=\"1\" borderId=\"0\" fillId=\"0\" fontId=\"0\" numFmtId=\"0\"><alignment horizontal=\"left\" indent=\"1\" shrinkToFit=\"1\" textRotation=\"0\" vertical=\"middle\" wrapText=\"0\"/></xf></cellXfs></styleSheet>`\n\t\tresult, err := styles.Marshal()\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(string(result), qt.Equals, expected)\n\t})\n\n\t// Test we produce valid output for a style file with one NumFmt\n\t// definition.\n\tc.Run(\"MarshalXlsxStyleSheetWithANumFmt\", func(c *qt.C) {\n\t\tstyles := &xlsxStyleSheet{}\n\t\tstyles.NumFmts = &xlsxNumFmts{}\n\t\tstyles.NumFmts.NumFmt = make([]xlsxNumFmt, 0)\n\t\tnumFmt := xlsxNumFmt{NumFmtId: 164, FormatCode: \"GENERAL\"}\n\t\tstyles.addNumFmt(numFmt)\n\n\t\texpected := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<styleSheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"><numFmts count=\"1\"><numFmt numFmtId=\"164\" formatCode=\"GENERAL\"/></numFmts></styleSheet>`\n\t\tresult, err := styles.Marshal()\n\t\tc.Assert(err, qt.IsNil)\n\t\tc.Assert(string(result), qt.Equals, expected)\n\t})\n\n\tc.Run(\"Fontqt.Equals\", func(c *qt.C) {\n\t\tfontA := xlsxFont{Sz: xlsxVal{Val: \"11\"},\n\t\t\tColor:  xlsxColor{RGB: \"FFFF0000\"},\n\t\t\tName:   xlsxVal{Val: \"Calibri\"},\n\t\t\tFamily: xlsxVal{Val: \"2\"},\n\t\t\tB:      &xlsxVal{},\n\t\t\tI:      &xlsxVal{},\n\t\t\tU:      &xlsxVal{}}\n\t\tfontB := xlsxFont{Sz: xlsxVal{Val: \"11\"},\n\t\t\tColor:  xlsxColor{RGB: \"FFFF0000\"},\n\t\t\tName:   xlsxVal{Val: \"Calibri\"},\n\t\t\tFamily: xlsxVal{Val: \"2\"},\n\t\t\tB:      &xlsxVal{},\n\t\t\tI:      &xlsxVal{},\n\t\t\tU:      &xlsxVal{}}\n\n\t\tc.Assert(fontA.Equals(fontB), qt.Equals, true)\n\t\tfontB.Sz.Val = \"12\"\n\t\tc.Assert(fontA.Equals(fontB), qt.Equals, false)\n\t\tfontB.Sz.Val = \"11\"\n\t\tfontB.Color.RGB = \"12345678\"\n\t\tc.Assert(fontA.Equals(fontB), qt.Equals, false)\n\t\tfontB.Color.RGB = \"FFFF0000\"\n\t\tfontB.Name.Val = \"Arial\"\n\t\tc.Assert(fontA.Equals(fontB), qt.Equals, false)\n\t\tfontB.Name.Val = \"Calibri\"\n\t\tfontB.Family.Val = \"1\"\n\t\tc.Assert(fontA.Equals(fontB), qt.Equals, false)\n\t\tfontB.Family.Val = \"2\"\n\t\tfontB.B = nil\n\t\tc.Assert(fontA.Equals(fontB), qt.Equals, false)\n\t\tfontB.B = &xlsxVal{}\n\t\tfontB.I = nil\n\t\tc.Assert(fontA.Equals(fontB), qt.Equals, false)\n\t\tfontB.I = &xlsxVal{}\n\t\tfontB.U = nil\n\t\tc.Assert(fontA.Equals(fontB), qt.Equals, false)\n\t\tfontB.U = &xlsxVal{}\n\t\t// For sanity\n\t\tc.Assert(fontA.Equals(fontB), qt.Equals, true)\n\t})\n\n\tc.Run(\"FillEquals\", func(c *qt.C) {\n\t\tfillA := xlsxFill{PatternFill: xlsxPatternFill{\n\t\t\tPatternType: \"solid\",\n\t\t\tFgColor:     xlsxColor{RGB: \"FFFF0000\"},\n\t\t\tBgColor:     xlsxColor{RGB: \"0000FFFF\"}}}\n\t\tfillB := xlsxFill{PatternFill: xlsxPatternFill{\n\t\t\tPatternType: \"solid\",\n\t\t\tFgColor:     xlsxColor{RGB: \"FFFF0000\"},\n\t\t\tBgColor:     xlsxColor{RGB: \"0000FFFF\"}}}\n\t\tc.Assert(fillA.Equals(fillB), qt.Equals, true)\n\t\tfillB.PatternFill.PatternType = \"gray125\"\n\t\tc.Assert(fillA.Equals(fillB), qt.Equals, false)\n\t\tfillB.PatternFill.PatternType = \"solid\"\n\t\tfillB.PatternFill.FgColor.RGB = \"00FF00FF\"\n\t\tc.Assert(fillA.Equals(fillB), qt.Equals, false)\n\t\tfillB.PatternFill.FgColor.RGB = \"FFFF0000\"\n\t\tfillB.PatternFill.BgColor.RGB = \"12456789\"\n\t\tc.Assert(fillA.Equals(fillB), qt.Equals, false)\n\t\tfillB.PatternFill.BgColor.RGB = \"0000FFFF\"\n\t\t// For sanity\n\t\tc.Assert(fillA.Equals(fillB), qt.Equals, true)\n\t})\n\n\tc.Run(\"BorderEquals\", func(c *qt.C) {\n\t\tborderA := xlsxBorder{Left: xlsxLine{Style: \"none\"},\n\t\t\tRight:  xlsxLine{Style: \"none\"},\n\t\t\tTop:    xlsxLine{Style: \"none\"},\n\t\t\tBottom: xlsxLine{Style: \"none\"}}\n\t\tborderB := xlsxBorder{Left: xlsxLine{Style: \"none\"},\n\t\t\tRight:  xlsxLine{Style: \"none\"},\n\t\t\tTop:    xlsxLine{Style: \"none\"},\n\t\t\tBottom: xlsxLine{Style: \"none\"}}\n\t\tc.Assert(borderA.Equals(borderB), qt.Equals, true)\n\t\tborderB.Left.Style = \"thin\"\n\t\tc.Assert(borderA.Equals(borderB), qt.Equals, false)\n\t\tborderB.Left.Style = \"none\"\n\t\tborderB.Right.Style = \"thin\"\n\t\tc.Assert(borderA.Equals(borderB), qt.Equals, false)\n\t\tborderB.Right.Style = \"none\"\n\t\tborderB.Top.Style = \"thin\"\n\t\tc.Assert(borderA.Equals(borderB), qt.Equals, false)\n\t\tborderB.Top.Style = \"none\"\n\t\tborderB.Bottom.Style = \"thin\"\n\t\tc.Assert(borderA.Equals(borderB), qt.Equals, false)\n\t\tborderB.Bottom.Style = \"none\"\n\t\t// for sanity\n\t\tc.Assert(borderA.Equals(borderB), qt.Equals, true)\n\t})\n\n\tc.Run(\"XfEquals\", func(c *qt.C) {\n\t\txfA := xlsxXf{\n\t\t\tApplyAlignment:  true,\n\t\t\tApplyBorder:     true,\n\t\t\tApplyFont:       true,\n\t\t\tApplyFill:       true,\n\t\t\tApplyProtection: true,\n\t\t\tBorderId:        0,\n\t\t\tFillId:          0,\n\t\t\tFontId:          0,\n\t\t\tNumFmtId:        0}\n\t\txfB := xlsxXf{\n\t\t\tApplyAlignment:  true,\n\t\t\tApplyBorder:     true,\n\t\t\tApplyFont:       true,\n\t\t\tApplyFill:       true,\n\t\t\tApplyProtection: true,\n\t\t\tBorderId:        0,\n\t\t\tFillId:          0,\n\t\t\tFontId:          0,\n\t\t\tNumFmtId:        0}\n\t\tc.Assert(xfA.Equals(xfB), qt.Equals, true)\n\t\txfB.ApplyAlignment = false\n\t\tc.Assert(xfA.Equals(xfB), qt.Equals, false)\n\t\txfB.ApplyAlignment = true\n\t\txfB.ApplyBorder = false\n\t\tc.Assert(xfA.Equals(xfB), qt.Equals, false)\n\t\txfB.ApplyBorder = true\n\t\txfB.ApplyFont = false\n\t\tc.Assert(xfA.Equals(xfB), qt.Equals, false)\n\t\txfB.ApplyFont = true\n\t\txfB.ApplyFill = false\n\t\tc.Assert(xfA.Equals(xfB), qt.Equals, false)\n\t\txfB.ApplyFill = true\n\t\txfB.ApplyProtection = false\n\t\tc.Assert(xfA.Equals(xfB), qt.Equals, false)\n\t\txfB.ApplyProtection = true\n\t\txfB.BorderId = 1\n\t\tc.Assert(xfA.Equals(xfB), qt.Equals, false)\n\t\txfB.BorderId = 0\n\t\txfB.FillId = 1\n\t\tc.Assert(xfA.Equals(xfB), qt.Equals, false)\n\t\txfB.FillId = 0\n\t\txfB.FontId = 1\n\t\tc.Assert(xfA.Equals(xfB), qt.Equals, false)\n\t\txfB.FontId = 0\n\t\txfB.NumFmtId = 1\n\t\tc.Assert(xfA.Equals(xfB), qt.Equals, false)\n\t\txfB.NumFmtId = 0\n\t\t// for sanity\n\t\tc.Assert(xfA.Equals(xfB), qt.Equals, true)\n\n\t\tvar i1 int = 1\n\n\t\txfA.XfId = &i1\n\t\tc.Assert(xfA.Equals(xfB), qt.Equals, false)\n\n\t\txfB.XfId = &i1\n\t\tc.Assert(xfA.Equals(xfB), qt.Equals, true)\n\n\t\tvar i2 int = 1\n\t\txfB.XfId = &i2\n\t\tc.Assert(xfA.Equals(xfB), qt.Equals, true)\n\n\t\ti2 = 2\n\t\tc.Assert(xfA.Equals(xfB), qt.Equals, false)\n\t})\n\n}\n\nfunc TestStyleSheet(t *testing.T) {\n\tc := qt.New(t)\n\n\tc.Run(\"NewNumFmt\", func(c *qt.C) {\n\t\tstyles := newXlsxStyleSheet(nil)\n\t\tstyles.NumFmts = &xlsxNumFmts{}\n\t\tstyles.NumFmts.NumFmt = make([]xlsxNumFmt, 0)\n\n\t\tc.Assert(styles.newNumFmt(\"0\"), qt.DeepEquals, xlsxNumFmt{1, \"0\"})\n\t\tc.Assert(styles.newNumFmt(\"0.00e+00\"), qt.DeepEquals, xlsxNumFmt{11, \"0.00e+00\"})\n\t\tc.Assert(styles.newNumFmt(\"mm-dd-yy\"), qt.DeepEquals, xlsxNumFmt{14, \"mm-dd-yy\"})\n\t\tc.Assert(styles.newNumFmt(\"hh:mm:ss\"), qt.DeepEquals, xlsxNumFmt{164, \"hh:mm:ss\"})\n\t\tc.Assert(len(styles.NumFmts.NumFmt), qt.Equals, 1)\n\t})\n\n\tc.Run(\"AddNumFmt\", func(c *qt.C) {\n\t\tstyles := &xlsxStyleSheet{}\n\t\tstyles.NumFmts = &xlsxNumFmts{}\n\t\tstyles.NumFmts.NumFmt = make([]xlsxNumFmt, 0)\n\n\t\tstyles.addNumFmt(xlsxNumFmt{1, \"0\"})\n\t\tc.Assert(styles.NumFmts.Count, qt.Equals, 0)\n\t\tstyles.addNumFmt(xlsxNumFmt{14, \"mm-dd-yy\"})\n\t\tc.Assert(styles.NumFmts.Count, qt.Equals, 0)\n\t\tstyles.addNumFmt(xlsxNumFmt{164, \"hh:mm:ss\"})\n\t\tc.Assert(styles.NumFmts.Count, qt.Equals, 1)\n\t\tstyles.addNumFmt(xlsxNumFmt{165, \"yyyy/mm/dd\"})\n\t\tc.Assert(styles.NumFmts.Count, qt.Equals, 2)\n\t\tstyles.addNumFmt(xlsxNumFmt{165, \"yyyy/mm/dd\"})\n\t\tc.Assert(styles.NumFmts.Count, qt.Equals, 2)\n\t})\n\n\tc.Run(\"GetStyle\", func(c *qt.C) {\n\t\tc.Run(\"NoNamedStyleIndex\", func(c *qt.C) {\n\t\t\tstyles := newXlsxStyleSheet(nil)\n\t\t\ts0 := styles.getStyle(0)\n\t\t\tc.Assert(s0.NamedStyleIndex, qt.Equals, (*int)(nil))\n\t\t})\n\t\tc.Run(\"NamedStyleIndex\", func(c *qt.C) {\n\t\t\tstyles := newXlsxStyleSheet(nil)\n\t\t\tnamedStyleId := 20\n\t\t\tcsXfs := xlsxCellStyleXfs{}\n\t\t\tcsXfs.addXf(xlsxXf{XfId: &namedStyleId})\n\t\t\tstyles.CellStyleXfs = &csXfs\n\t\t\tcellStyleId := 0\n\t\t\tstyles.CellXfs.addXf(xlsxXf{XfId: &cellStyleId})\n\t\t\ts0 := styles.getStyle(0)\n\t\t\tc.Assert(s0.NamedStyleIndex, qt.Equals, &cellStyleId)\n\t\t})\n\n\t\tc.Run(\"NamedStyleWins\", func(c *qt.C) {\n\t\t\tstyles := newXlsxStyleSheet(nil)\n\t\t\tnamedStyleId := 20\n\t\t\tcsXfs := xlsxCellStyleXfs{}\n\t\t\tcsXfs.addXf(xlsxXf{XfId: &namedStyleId,\n\t\t\t\tApplyBorder: true,\n\t\t\t\tApplyFont:   false,\n\t\t\t})\n\t\t\tstyles.CellStyleXfs = &csXfs\n\t\t\tcellStyleId := 0\n\t\t\tstyles.CellXfs.addXf(\n\t\t\t\txlsxXf{\n\t\t\t\t\tXfId:        &cellStyleId,\n\t\t\t\t\tApplyBorder: false,\n\t\t\t\t\tApplyFont:   true,\n\t\t\t\t})\n\t\t\ts0 := styles.getStyle(0)\n\t\t\tc.Assert(s0.NamedStyleIndex, qt.Equals, &cellStyleId)\n\t\t\tc.Assert(s0.ApplyBorder, qt.Equals, true)\n\t\t\tc.Assert(s0.ApplyFont, qt.Equals, true)\n\t\t})\n\n\t})\n\n\tc.Run(\"PopulateStyleFromXf\", func(c *qt.C) {\n\t\tc.Run(\"ApplyBorder\", func(c *qt.C) {\n\t\t\tstyles := newXlsxStyleSheet(nil)\n\t\t\tstyle := &Style{}\n\t\t\txf := xlsxXf{\n\t\t\t\tApplyBorder: true,\n\t\t\t}\n\t\t\tstyles.populateStyleFromXf(style, xf)\n\t\t\tc.Assert(style.ApplyBorder, qt.Equals, true)\n\n\t\t\txf = xlsxXf{\n\t\t\t\tApplyBorder: false,\n\t\t\t}\n\t\t\tstyles.populateStyleFromXf(style, xf)\n\t\t\tc.Assert(style.ApplyBorder, qt.Equals, false)\n\t\t})\n\n\t\tc.Run(\"ApplyFill\", func(c *qt.C) {\n\t\t\tstyles := newXlsxStyleSheet(nil)\n\t\t\tstyle := &Style{}\n\t\t\txf := xlsxXf{\n\t\t\t\tApplyFill: true,\n\t\t\t}\n\t\t\tstyles.populateStyleFromXf(style, xf)\n\t\t\tc.Assert(style.ApplyFill, qt.Equals, true)\n\n\t\t\txf = xlsxXf{\n\t\t\t\tApplyFill: false,\n\t\t\t}\n\t\t\tstyles.populateStyleFromXf(style, xf)\n\t\t\tc.Assert(style.ApplyFill, qt.Equals, false)\n\t\t})\n\t\tc.Run(\"ApplyFont\", func(c *qt.C) {\n\t\t\tstyles := newXlsxStyleSheet(nil)\n\t\t\tstyle := &Style{}\n\t\t\txf := xlsxXf{\n\t\t\t\tApplyFont: true,\n\t\t\t}\n\t\t\tstyles.populateStyleFromXf(style, xf)\n\t\t\tc.Assert(style.ApplyFont, qt.Equals, true)\n\n\t\t\txf = xlsxXf{\n\t\t\t\tApplyFont: false,\n\t\t\t}\n\t\t\tstyles.populateStyleFromXf(style, xf)\n\t\t\tc.Assert(style.ApplyFont, qt.Equals, false)\n\t\t})\n\t\tc.Run(\"ApplyAlignment\", func(c *qt.C) {\n\t\t\tstyles := newXlsxStyleSheet(nil)\n\t\t\tstyle := &Style{}\n\t\t\txf := xlsxXf{\n\t\t\t\tApplyAlignment: true,\n\t\t\t}\n\t\t\tstyles.populateStyleFromXf(style, xf)\n\t\t\tc.Assert(style.ApplyAlignment, qt.Equals, true)\n\n\t\t\txf = xlsxXf{\n\t\t\t\tApplyAlignment: false,\n\t\t\t}\n\t\t\tstyles.populateStyleFromXf(style, xf)\n\t\t\tc.Assert(style.ApplyAlignment, qt.Equals, false)\n\t\t})\n\t\tc.Run(\"Border\", func(c *qt.C) {\n\t\t\tstyles := newXlsxStyleSheet(nil)\n\t\t\tline := xlsxLine{Style: \"fake\", Color: xlsxColor{RGB: \"00aaff\"}}\n\n\t\t\tborders := xlsxBorders{}\n\t\t\tborder := xlsxBorder{\n\t\t\t\tLeft:   line,\n\t\t\t\tRight:  line,\n\t\t\t\tTop:    line,\n\t\t\t\tBottom: line,\n\t\t\t}\n\t\t\tborders.addBorder(border)\n\n\t\t\tstyles.Borders = borders\n\t\t\tstyle := &Style{}\n\t\t\txf := xlsxXf{\n\t\t\t\tApplyBorder: true,\n\t\t\t\tBorderId:    0,\n\t\t\t}\n\t\t\tstyles.populateStyleFromXf(style, xf)\n\n\t\t\tc.Assert(style.Border.Left, qt.Equals, border.Left.Style)\n\t\t\tc.Assert(style.Border.LeftColor, qt.Equals, border.Left.Color.RGB)\n\t\t\tc.Assert(style.Border.Right, qt.Equals, border.Right.Style)\n\t\t\tc.Assert(style.Border.RightColor, qt.Equals, border.Right.Color.RGB)\n\t\t\tc.Assert(style.Border.Top, qt.Equals, border.Top.Style)\n\t\t\tc.Assert(style.Border.TopColor, qt.Equals, border.Top.Color.RGB)\n\t\t\tc.Assert(style.Border.Bottom, qt.Equals, border.Bottom.Style)\n\t\t\tc.Assert(style.Border.BottomColor, qt.Equals, border.Bottom.Color.RGB)\n\n\t\t})\n\n\t\tc.Run(\"Fill\", func(c *qt.C) {\n\t\t\tstyles := newXlsxStyleSheet(nil)\n\n\t\t\tfills := xlsxFills{}\n\t\t\tpattern := xlsxPatternFill{\n\t\t\t\tPatternType: \"fake\",\n\t\t\t\tFgColor:     xlsxColor{RGB: \"00aaff\"},\n\t\t\t\tBgColor:     xlsxColor{RGB: \"ffaa00\"},\n\t\t\t}\n\t\t\tfill := xlsxFill{\n\t\t\t\tPatternFill: pattern,\n\t\t\t}\n\t\t\tfills.addFill(fill)\n\n\t\t\tstyles.Fills = fills\n\t\t\tstyle := &Style{}\n\t\t\txf := xlsxXf{\n\t\t\t\tApplyFill: true,\n\t\t\t\tFillId:    0,\n\t\t\t}\n\t\t\tstyles.populateStyleFromXf(style, xf)\n\t\t\tc.Assert(style.Fill.PatternType, qt.Equals, pattern.PatternType)\n\t\t\tc.Assert(style.Fill.FgColor, qt.Equals, styles.argbValue(pattern.FgColor))\n\t\t\tc.Assert(style.Fill.BgColor, qt.Equals, styles.argbValue(pattern.BgColor))\n\n\t\t})\n\t\tc.Run(\"Font\", func(c *qt.C) {\n\t\t\tstyles := newXlsxStyleSheet(nil)\n\n\t\t\tfonts := xlsxFonts{}\n\n\t\t\tsz := 10.0\n\t\t\tszVal := strconv.FormatFloat(sz, 'f', -1, 64)\n\t\t\tname := 0\n\t\t\tnameVal := strconv.Itoa(name)\n\t\t\tfamily := 2\n\t\t\tfamilyVal := strconv.Itoa(family)\n\t\t\tcharset := 10\n\t\t\tcharsetVal := strconv.Itoa(charset)\n\n\t\t\tfont := xlsxFont{\n\t\t\t\tSz:      xlsxVal{szVal},\n\t\t\t\tName:    xlsxVal{nameVal},\n\t\t\t\tFamily:  xlsxVal{familyVal},\n\t\t\t\tCharset: xlsxVal{charsetVal},\n\t\t\t\tColor:   xlsxColor{RGB: \"00aaff\"},\n\t\t\t\tB:       &xlsxVal{\"1\"},\n\t\t\t\tI:       &xlsxVal{\"1\"},\n\t\t\t\tU:       &xlsxVal{\"1\"},\n\t\t\t\tStrike:  &xlsxVal{\"1\"},\n\t\t\t}\n\n\t\t\tfonts.addFont(font)\n\n\t\t\tstyles.Fonts = fonts\n\t\t\tstyle := &Style{}\n\t\t\txf := xlsxXf{\n\t\t\t\tApplyFont: true,\n\t\t\t\tFontId:    0,\n\t\t\t}\n\t\t\tstyles.populateStyleFromXf(style, xf)\n\n\t\t\tc.Assert(style.Font.Size, qt.Equals, sz)\n\t\t\tc.Assert(style.Font.Name, qt.Equals, nameVal)\n\t\t\tc.Assert(style.Font.Family, qt.Equals, family)\n\t\t\tc.Assert(style.Font.Charset, qt.Equals, charset)\n\t\t\tc.Assert(style.Font.Color, qt.Equals, font.Color.RGB)\n\t\t\tc.Assert(style.Font.Bold, qt.Equals, true)\n\t\t\tc.Assert(style.Font.Italic, qt.Equals, true)\n\t\t\tc.Assert(style.Font.Underline, qt.Equals, true)\n\t\t\tc.Assert(style.Font.Strike, qt.Equals, true)\n\t\t})\n\n\t\tc.Run(\"Alignment\", func(c *qt.C) {\n\t\t\tstyles := newXlsxStyleSheet(nil)\n\t\t\tstyle := &Style{}\n\n\t\t\talignment := xlsxAlignment{\n\t\t\t\tHorizontal:   \"left\",\n\t\t\t\tIndent:       10,\n\t\t\t\tShrinkToFit:  true,\n\t\t\t\tTextRotation: 80,\n\t\t\t\tVertical:     \"top\",\n\t\t\t\tWrapText:     true,\n\t\t\t}\n\t\t\txf := xlsxXf{\n\t\t\t\tApplyAlignment: true,\n\t\t\t\tAlignment:      alignment,\n\t\t\t}\n\t\t\tstyles.populateStyleFromXf(style, xf)\n\t\t\tc.Assert(style.Alignment.Horizontal, qt.Equals, alignment.Horizontal)\n\t\t\tc.Assert(style.Alignment.Indent, qt.Equals, alignment.Indent)\n\t\t\tc.Assert(style.Alignment.ShrinkToFit, qt.Equals, alignment.ShrinkToFit)\n\t\t\tc.Assert(style.Alignment.TextRotation, qt.Equals, alignment.TextRotation)\n\t\t\tc.Assert(style.Alignment.Vertical, qt.Equals, alignment.Vertical)\n\t\t\tc.Assert(style.Alignment.WrapText, qt.Equals, alignment.WrapText)\n\t\t})\n\n\t})\n}\n"
        },
        {
          "name": "xmlTheme.go",
          "type": "blob",
          "size": 1.826171875,
          "content": "package xlsx\n\nimport \"encoding/xml\"\n\n// xlsxTheme directly maps the theme element in the namespace\n// http://schemas.openxmlformats.org/drawingml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxTheme struct {\n\tThemeElements xlsxThemeElements `xml:\"themeElements\"`\n}\n\n// xlsxThemeElements directly maps the themeElements element in the namespace\n// http://schemas.openxmlformats.org/drawingml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxThemeElements struct {\n\tClrScheme xlsxClrScheme `xml:\"clrScheme\"`\n}\n\n// xlsxClrScheme directly maps the clrScheme element in the namespace\n// http://schemas.openxmlformats.org/drawingml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxClrScheme struct {\n\tName     string            `xml:\"name,attr\"`\n\tChildren []xlsxClrSchemeEl `xml:\",any\"`\n}\n\n// xlsxClrScheme maps to children of the clrScheme element in the namespace\n// http://schemas.openxmlformats.org/drawingml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxClrSchemeEl struct {\n\tXMLName xml.Name\n\tSysClr  *xlsxSysClr  `xml:\"sysClr\"`\n\tSrgbClr *xlsxSrgbClr `xml:\"srgbClr\"`\n}\n\n// xlsxSysClr directly maps the sysClr element in the namespace\n// http://schemas.openxmlformats.org/drawingml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxSysClr struct {\n\tVal     string `xml:\"val,attr\"`\n\tLastClr string `xml:\"lastClr,attr\"`\n}\n\n// xlsxSrgbClr directly maps the srgbClr element in the namespace\n// http://schemas.openxmlformats.org/drawingml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxSrgbClr struct {\n\tVal string `xml:\"val,attr\"`\n}\n"
        },
        {
          "name": "xmlWorkbook.go",
          "type": "blob",
          "size": 8.53125,
          "content": "package xlsx\n\nimport (\n\t\"archive/zip\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"io\"\n)\n\nconst (\n\t// sheet state values as defined by\n\t// http://msdn.microsoft.com/en-us/library/office/documentformat.openxml.spreadsheet.sheetstatevalues.aspx\n\tsheetStateVisible    = \"visible\"\n\tsheetStateHidden     = \"hidden\"\n\tsheetStateVeryHidden = \"veryHidden\"\n)\n\n// xmlxWorkbookRels contains xmlxWorkbookRelations\n// which maps sheet id and sheet XML\ntype xlsxWorkbookRels struct {\n\tXMLName       xml.Name               `xml:\"http://schemas.openxmlformats.org/package/2006/relationships Relationships\"`\n\tRelationships []xlsxWorkbookRelation `xml:\"Relationship\"`\n}\n\n// xmlxWorkbookRelation maps sheet id and xl/worksheets/sheet%d.xml\ntype xlsxWorkbookRelation struct {\n\tId     string `xml:\",attr\"`\n\tTarget string `xml:\",attr\"`\n\tType   string `xml:\",attr\"`\n}\n\n// xlsxWorkbook directly maps the workbook element from the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxWorkbook struct {\n\tXMLName            xml.Name               `xml:\"http://schemas.openxmlformats.org/spreadsheetml/2006/main workbook\"`\n\tFileVersion        xlsxFileVersion        `xml:\"fileVersion\"`\n\tWorkbookPr         xlsxWorkbookPr         `xml:\"workbookPr\"`\n\tWorkbookProtection xlsxWorkbookProtection `xml:\"workbookProtection\"`\n\tBookViews          xlsxBookViews          `xml:\"bookViews\"`\n\tSheets             xlsxSheets             `xml:\"sheets\"`\n\tDefinedNames       xlsxDefinedNames       `xml:\"definedNames\"`\n\tCalcPr             xlsxCalcPr             `xml:\"calcPr\"`\n}\n\n// xlsxWorkbookProtection directly maps the workbookProtection element from the\n// namespace http://schemas.openxmlformats.org/spreadsheetml/2006/main\n// - currently I have not checked it for completeness - it does as\n// much as I need.\ntype xlsxWorkbookProtection struct {\n\t// We don't need this, yet.\n}\n\n// xlsxFileVersion directly maps the fileVersion element from the\n// namespace http://schemas.openxmlformats.org/spreadsheetml/2006/main\n// - currently I have not checked it for completeness - it does as\n// much as I need.\ntype xlsxFileVersion struct {\n\tAppName      string `xml:\"appName,attr,omitempty\"`\n\tLastEdited   string `xml:\"lastEdited,attr,omitempty\"`\n\tLowestEdited string `xml:\"lowestEdited,attr,omitempty\"`\n\tRupBuild     string `xml:\"rupBuild,attr,omitempty\"`\n}\n\n// xlsxWorkbookPr directly maps the workbookPr element from the\n// namespace http://schemas.openxmlformats.org/spreadsheetml/2006/main\n// - currently I have not checked it for completeness - it does as\n// much as I need.\ntype xlsxWorkbookPr struct {\n\tDefaultThemeVersion string `xml:\"defaultThemeVersion,attr,omitempty\"`\n\tBackupFile          bool   `xml:\"backupFile,attr,omitempty\"`\n\tShowObjects         string `xml:\"showObjects,attr,omitempty\"`\n\tDate1904            bool   `xml:\"date1904,attr\"`\n}\n\n// xlsxBookViews directly maps the bookViews element from the\n// namespace http://schemas.openxmlformats.org/spreadsheetml/2006/main\n// - currently I have not checked it for completeness - it does as\n// much as I need.\ntype xlsxBookViews struct {\n\tWorkBookView []xlsxWorkBookView `xml:\"workbookView\"`\n}\n\n// xlsxWorkBookView directly maps the workbookView element from the\n// namespace http://schemas.openxmlformats.org/spreadsheetml/2006/main\n// - currently I have not checked it for completeness - it does as\n// much as I need.\ntype xlsxWorkBookView struct {\n\tActiveTab            int    `xml:\"activeTab,attr,omitempty\"`\n\tFirstSheet           int    `xml:\"firstSheet,attr,omitempty\"`\n\tShowHorizontalScroll bool   `xml:\"showHorizontalScroll,attr,omitempty\"`\n\tShowVerticalScroll   bool   `xml:\"showVerticalScroll,attr,omitempty\"`\n\tShowSheetTabs        bool   `xml:\"showSheetTabs,attr,omitempty\"`\n\tTabRatio             int    `xml:\"tabRatio,attr,omitempty\"`\n\tWindowHeight         int    `xml:\"windowHeight,attr,omitempty\"`\n\tWindowWidth          int    `xml:\"windowWidth,attr,omitempty\"`\n\tXWindow              string `xml:\"xWindow,attr,omitempty\"`\n\tYWindow              string `xml:\"yWindow,attr,omitempty\"`\n}\n\n// xlsxSheets directly maps the sheets element from the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxSheets struct {\n\tSheet []xlsxSheet `xml:\"sheet\"`\n}\n\n// xlsxSheet directly maps the sheet element from the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxSheet struct {\n\tName    string `xml:\"name,attr,omitempty\"`\n\tSheetId string `xml:\"sheetId,attr,omitempty\"`\n\tId      string `xml:\"http://schemas.openxmlformats.org/officeDocument/2006/relationships id,attr,omitempty\"`\n\tState   string `xml:\"state,attr,omitempty\"`\n}\n\n// xlsxDefinedNames directly maps the definedNames element from the\n// namespace http://schemas.openxmlformats.org/spreadsheetml/2006/main\n// - currently I have not checked it for completeness - it does as\n// much as I need.\ntype xlsxDefinedNames struct {\n\tDefinedName []xlsxDefinedName `xml:\"definedName\"`\n}\n\n// xlsxDefinedName directly maps the definedName element from the\n// namespace http://schemas.openxmlformats.org/spreadsheetml/2006/main\n// - currently I have not checked it for completeness - it does as\n// much as I need.\n// for a descriptions of the attributes see\n// https://msdn.microsoft.com/en-us/library/office/documentformat.openxml.spreadsheet.definedname.aspx\ntype xlsxDefinedName struct {\n\tData              string `xml:\",chardata\"`\n\tName              string `xml:\"name,attr\"`\n\tComment           string `xml:\"comment,attr,omitempty\"`\n\tCustomMenu        string `xml:\"customMenu,attr,omitempty\"`\n\tDescription       string `xml:\"description,attr,omitempty\"`\n\tHelp              string `xml:\"help,attr,omitempty\"`\n\tShortcutKey       string `xml:\"shortcutKey,attr,omitempty\"`\n\tStatusBar         string `xml:\"statusBar,attr,omitempty\"`\n\tLocalSheetID      int    `xml:\"localSheetId,attr\"`\n\tFunctionGroupID   int    `xml:\"functionGroupId,attr,omitempty\"`\n\tFunction          bool   `xml:\"function,attr,omitempty\"`\n\tHidden            bool   `xml:\"hidden,attr,omitempty\"`\n\tVbProcedure       bool   `xml:\"vbProcedure,attr,omitempty\"`\n\tPublishToServer   bool   `xml:\"publishToServer,attr,omitempty\"`\n\tWorkbookParameter bool   `xml:\"workbookParameter,attr,omitempty\"`\n\tXlm               bool   `xml:\"xml,attr,omitempty\"`\n}\n\n// xlsxCalcPr directly maps the calcPr element from the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxCalcPr struct {\n\tCalcId       string  `xml:\"calcId,attr,omitempty\"`\n\tIterateCount int     `xml:\"iterateCount,attr,omitempty\"`\n\tRefMode      string  `xml:\"refMode,attr,omitempty\"`\n\tIterate      bool    `xml:\"iterate,attr,omitempty\"`\n\tIterateDelta float64 `xml:\"iterateDelta,attr,omitempty\"`\n}\n\n// Helper function to lookup the file corresponding to a xlsxSheet object in the worksheets map\nfunc worksheetFileForSheet(sheet xlsxSheet, worksheets map[string]*zip.File, sheetXMLMap map[string]string) *zip.File {\n\tsheetName, ok := sheetXMLMap[sheet.Id]\n\tif !ok {\n\t\tif sheet.SheetId != \"\" {\n\t\t\tsheetName = fmt.Sprintf(\"sheet%s\", sheet.SheetId)\n\t\t} else {\n\t\t\tsheetName = fmt.Sprintf(\"sheet%s\", sheet.Id)\n\t\t}\n\t}\n\treturn worksheets[sheetName]\n}\n\n// getWorksheetFromSheet() is an internal helper function to open a\n// sheetN.xml file, referred to by an xlsx.xlsxSheet struct, from the XLSX\n// file and unmarshal it an xlsx.xlsxWorksheet struct\nfunc getWorksheetFromSheet(sheet xlsxSheet, worksheets map[string]*zip.File, sheetXMLMap map[string]string, rowLimit int, valueOnly bool) (*xlsxWorksheet, error) {\n\tvar r io.Reader\n\tvar decoder *xml.Decoder\n\tvar worksheet *xlsxWorksheet\n\tvar err error\n\n\twrap := func(err error) (*xlsxWorksheet, error) {\n\t\treturn nil, fmt.Errorf(\"getWorksheetFromSheet: %w\", err)\n\t}\n\n\tworksheet = new(xlsxWorksheet)\n\n\tf := worksheetFileForSheet(sheet, worksheets, sheetXMLMap)\n\tif f == nil {\n\t\treturn wrap(fmt.Errorf(\"unable to find sheet '%s'\", sheet))\n\t}\n\tif rc, err := f.Open(); err != nil {\n\t\treturn wrap(fmt.Errorf(\"file.Open: %w\", err))\n\t} else {\n\t\tdefer rc.Close()\n\t\tr = rc\n\t}\n\n\tif rowLimit != NoRowLimit {\n\t\tr, err = truncateSheetXML(r, rowLimit)\n\t\tif err != nil {\n\t\t\treturn wrap(err)\n\t\t}\n\t}\n\n\tif valueOnly {\n\t\tr, err = truncateSheetXMLValueOnly(r)\n\t\tif err != nil {\n\t\t\treturn wrap(err)\n\t\t}\n\t}\n\n\tdecoder = xml.NewDecoder(r)\n\terr = decoder.Decode(worksheet)\n\tif err != nil {\n\t\treturn wrap(fmt.Errorf(\"xml.Decoder.Decode: %w\", err))\n\t}\n\n\tworksheet.mapMergeCells()\n\n\treturn worksheet, nil\n}\n"
        },
        {
          "name": "xmlWorkbook_test.go",
          "type": "blob",
          "size": 4.3515625,
          "content": "package xlsx\n\nimport (\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"testing\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\n// Test we can succesfully unmarshal the workbook.xml file from within\n// an XLSX file and return a xlsxWorkbook struct (and associated\n// children).\nfunc TestUnmarshallWorkbookXML(t *testing.T) {\n\tc := qt.New(t)\n\tvar buf = bytes.NewBufferString(\n\t\t`<?xml version=\"1.0\"\n        encoding=\"UTF-8\"\n        standalone=\"yes\"?>\n        <workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"\n                  xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\">\n          <fileVersion appName=\"xl\"\n                       lastEdited=\"4\"\n                       lowestEdited=\"4\"\n                       rupBuild=\"4506\"/>\n          <workbookPr defaultThemeVersion=\"124226\" date1904=\"true\"/>\n          <bookViews>\n            <workbookView xWindow=\"120\"\n                          yWindow=\"75\"\n                          windowWidth=\"15135\"\n                          windowHeight=\"7620\"/>\n          </bookViews>\n          <sheets>\n            <sheet name=\"Sheet1\"\n                   sheetId=\"1\"\n                   r:id=\"rId1\"\n                   state=\"visible\"/>\n            <sheet name=\"Sheet2\"\n                   sheetId=\"2\"\n                   r:id=\"rId2\"\n                   state=\"hidden\"/>\n            <sheet name=\"Sheet3\"\n                   sheetId=\"3\"\n                   r:id=\"rId3\"\n                   state=\"veryHidden\"/>\n          </sheets>\n          <definedNames>\n            <definedName name=\"monitors\" comment=\"this is the comment\"\n                         description=\"give cells a name\"\n                         localSheetId=\"0\">Sheet1!$A$1533</definedName>\n          </definedNames>\n          <calcPr calcId=\"125725\"/>\n          </workbook>`)\n\tworkbook := new(xlsxWorkbook)\n\terr := xml.NewDecoder(buf).Decode(workbook)\n\tc.Assert(err, qt.IsNil)\n\tc.Assert(workbook.FileVersion.AppName, qt.Equals, \"xl\")\n\tc.Assert(workbook.FileVersion.LastEdited, qt.Equals, \"4\")\n\tc.Assert(workbook.FileVersion.LowestEdited, qt.Equals, \"4\")\n\tc.Assert(workbook.FileVersion.RupBuild, qt.Equals, \"4506\")\n\tc.Assert(workbook.WorkbookPr.DefaultThemeVersion, qt.Equals, \"124226\")\n\tc.Assert(workbook.WorkbookPr.Date1904, qt.Equals, true)\n\tc.Assert(workbook.BookViews.WorkBookView, qt.HasLen, 1)\n\tworkBookView := workbook.BookViews.WorkBookView[0]\n\tc.Assert(workBookView.XWindow, qt.Equals, \"120\")\n\tc.Assert(workBookView.YWindow, qt.Equals, \"75\")\n\tc.Assert(workBookView.WindowWidth, qt.Equals, 15135)\n\tc.Assert(workBookView.WindowHeight, qt.Equals, 7620)\n\tc.Assert(workbook.Sheets.Sheet, qt.HasLen, 3)\n\tsheet := workbook.Sheets.Sheet[0]\n\tc.Assert(sheet.Id, qt.Equals, \"rId1\")\n\tc.Assert(sheet.Name, qt.Equals, \"Sheet1\")\n\tc.Assert(sheet.SheetId, qt.Equals, \"1\")\n\tc.Assert(sheet.State, qt.Equals, \"visible\")\n\tc.Assert(workbook.DefinedNames.DefinedName, qt.HasLen, 1)\n\tdname := workbook.DefinedNames.DefinedName[0]\n\tc.Assert(dname.Data, qt.Equals, \"Sheet1!$A$1533\")\n\tc.Assert(dname.LocalSheetID, qt.Equals, 0)\n\tc.Assert(dname.Name, qt.Equals, \"monitors\")\n\tc.Assert(dname.Comment, qt.Equals, \"this is the comment\")\n\tc.Assert(dname.Description, qt.Equals, \"give cells a name\")\n\tc.Assert(workbook.CalcPr.CalcId, qt.Equals, \"125725\")\n}\n\n// Test we can marshall a Workbook to xml\nfunc TestMarshallWorkbook(t *testing.T) {\n\tc := qt.New(t)\n\tworkbook := new(xlsxWorkbook)\n\tworkbook.FileVersion = xlsxFileVersion{}\n\tworkbook.FileVersion.AppName = \"xlsx\"\n\tworkbook.WorkbookPr = xlsxWorkbookPr{BackupFile: false}\n\tworkbook.BookViews = xlsxBookViews{}\n\tworkbook.BookViews.WorkBookView = make([]xlsxWorkBookView, 1)\n\tworkbook.BookViews.WorkBookView[0] = xlsxWorkBookView{}\n\tworkbook.Sheets = xlsxSheets{}\n\tworkbook.Sheets.Sheet = make([]xlsxSheet, 1)\n\tworkbook.Sheets.Sheet[0] = xlsxSheet{Name: \"sheet1\", SheetId: \"1\", Id: \"rId2\"}\n\n\tbody, err := xml.Marshal(workbook)\n\tc.Assert(err, qt.IsNil)\n\texpectedWorkbook := `<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"><fileVersion appName=\"xlsx\"></fileVersion><workbookPr date1904=\"false\"></workbookPr><workbookProtection></workbookProtection><bookViews><workbookView></workbookView></bookViews><sheets><sheet name=\"sheet1\" sheetId=\"1\" xmlns:relationships=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" relationships:id=\"rId2\"></sheet></sheets><definedNames></definedNames><calcPr></calcPr></workbook>`\n\tc.Assert(string(body), qt.Equals, expectedWorkbook)\n}\n"
        },
        {
          "name": "xmlWorksheet.go",
          "type": "blob",
          "size": 26.0439453125,
          "content": "package xlsx\n\nimport (\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/shabbyrobe/xmlwriter\"\n)\n\ntype RelationshipType string\n\nconst (\n\tRelationshipTypeHyperlink RelationshipType = \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink\"\n)\n\ntype RelationshipTargetMode string\n\nconst (\n\tRelationshipTargetModeExternal RelationshipTargetMode = \"External\"\n)\n\n// xlsxWorksheetRels contains xlsxWorksheetRelation\ntype xlsxWorksheetRels struct {\n\tXMLName       xml.Name                `xml:\"http://schemas.openxmlformats.org/package/2006/relationships Relationships\"`\n\tRelationships []xlsxWorksheetRelation `xml:\"Relationship\"`\n}\n\ntype xlsxWorksheetRelation struct {\n\tId         string                 `xml:\"Id,attr\"`\n\tType       RelationshipType       `xml:\"Type,attr\"`\n\tTarget     string                 `xml:\"Target,attr\"`\n\tTargetMode RelationshipTargetMode `xml:\"TargetMode,attr\"`\n}\n\n// xlsxWorksheet directly maps the worksheet element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxWorksheet struct {\n\tXMLName         xml.Name             `xml:\"http://schemas.openxmlformats.org/spreadsheetml/2006/main worksheet\"`\n\tXMLNSR          string               `xml:\"xmlns:r,attr\"`\n\tSheetPr         xlsxSheetPr          `xml:\"sheetPr\"`\n\tDimension       xlsxDimension        `xml:\"dimension\"`\n\tSheetViews      xlsxSheetViews       `xml:\"sheetViews\"`\n\tSheetFormatPr   xlsxSheetFormatPr    `xml:\"sheetFormatPr\"`\n\tCols            *xlsxCols            `xml:\"cols,omitempty\"`\n\tSheetData       xlsxSheetData        `xml:\"sheetData\"`\n\tHyperlinks      *xlsxHyperlinks      `xml:\"hyperlinks,omitempty\"`\n\tDataValidations *xlsxDataValidations `xml:\"dataValidations\"`\n\tAutoFilter      *xlsxAutoFilter      `xml:\"autoFilter,omitempty\"`\n\tMergeCells      *xlsxMergeCells      `xml:\"mergeCells,omitempty\"`\n\tPrintOptions    *xlsxPrintOptions    `xml:\"printOptions,omitempty\"`\n\tPageMargins     *xlsxPageMargins     `xml:\"pageMargins,omitempty\"`\n\tPageSetUp       *xlsxPageSetUp       `xml:\"pageSetup,omitempty\"`\n\tHeaderFooter    *xlsxHeaderFooter    `xml:\"headerFooter,omitempty\"`\n}\n\n// xlsxHeaderFooter directly maps the headerFooter element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxHeaderFooter struct {\n\tDifferentFirst   *bool           `xml:\"differentFirst,attr,omitempty\"`\n\tDifferentOddEven *bool           `xml:\"differentOddEven,attr,omitempty\"`\n\tOddHeader        []xlsxOddHeader `xml:\"oddHeader\"`\n\tOddFooter        []xlsxOddFooter `xml:\"oddFooter\"`\n}\n\n// xlsxOddHeader directly maps the oddHeader element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxOddHeader struct {\n\tContent string `xml:\",chardata\"`\n}\n\n// xlsxOddFooter directly maps the oddFooter element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxOddFooter struct {\n\tContent string `xml:\",chardata\"`\n}\n\n// xlsxPageSetUp directly maps the pageSetup element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxPageSetUp struct {\n\tPaperSize          string  `xml:\"paperSize,attr\"`\n\tScale              int     `xml:\"scale,attr\"`\n\tFirstPageNumber    int     `xml:\"firstPageNumber,attr\"`\n\tFitToWidth         int     `xml:\"fitToWidth,attr\"`\n\tFitToHeight        int     `xml:\"fitToHeight,attr\"`\n\tPageOrder          string  `xml:\"pageOrder,attr\"`\n\tOrientation        string  `xml:\"orientation,attr\"`\n\tUsePrinterDefaults bool    `xml:\"usePrinterDefaults,attr\"`\n\tBlackAndWhite      bool    `xml:\"blackAndWhite,attr\"`\n\tDraft              bool    `xml:\"draft,attr\"`\n\tCellComments       string  `xml:\"cellComments,attr\"`\n\tUseFirstPageNumber bool    `xml:\"useFirstPageNumber,attr\"`\n\tHorizontalDPI      float32 `xml:\"horizontalDpi,attr\"`\n\tVerticalDPI        float32 `xml:\"verticalDpi,attr\"`\n\tCopies             int     `xml:\"copies,attr\"`\n}\n\n// xlsxPrintOptions directly maps the printOptions element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxPrintOptions struct {\n\tHeadings           bool `xml:\"headings,attr\"`\n\tGridLines          bool `xml:\"gridLines,attr\"`\n\tGridLinesSet       bool `xml:\"gridLinesSet,attr\"`\n\tHorizontalCentered bool `xml:\"horizontalCentered,attr\"`\n\tVerticalCentered   bool `xml:\"verticalCentered,attr\"`\n}\n\n// xlsxPageMargins directly maps the pageMargins element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxPageMargins struct {\n\tLeft   float64 `xml:\"left,attr\"`\n\tRight  float64 `xml:\"right,attr\"`\n\tTop    float64 `xml:\"top,attr\"`\n\tBottom float64 `xml:\"bottom,attr\"`\n\tHeader float64 `xml:\"header,attr\"`\n\tFooter float64 `xml:\"footer,attr\"`\n}\n\n// xlsxSheetFormatPr directly maps the sheetFormatPr element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxSheetFormatPr struct {\n\tDefaultColWidth  float64 `xml:\"defaultColWidth,attr,omitempty\"`\n\tDefaultRowHeight float64 `xml:\"defaultRowHeight,attr\"`\n\tOutlineLevelCol  uint8   `xml:\"outlineLevelCol,attr,omitempty\"`\n\tOutlineLevelRow  uint8   `xml:\"outlineLevelRow,attr,omitempty\"`\n}\n\n// xlsxSheetViews directly maps the sheetViews element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxSheetViews struct {\n\tSheetView []xlsxSheetView `xml:\"sheetView\"`\n}\n\n// xlsxSheetView directly maps the sheetView element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxSheetView struct {\n\tWindowProtection        bool            `xml:\"windowProtection,attr\"`\n\tShowFormulas            bool            `xml:\"showFormulas,attr\"`\n\tShowGridLines           bool            `xml:\"showGridLines,attr\"`\n\tShowRowColHeaders       bool            `xml:\"showRowColHeaders,attr\"`\n\tShowZeros               bool            `xml:\"showZeros,attr\"`\n\tRightToLeft             bool            `xml:\"rightToLeft,attr\"`\n\tTabSelected             bool            `xml:\"tabSelected,attr\"`\n\tShowOutlineSymbols      bool            `xml:\"showOutlineSymbols,attr\"`\n\tDefaultGridColor        bool            `xml:\"defaultGridColor,attr\"`\n\tView                    string          `xml:\"view,attr\"`\n\tTopLeftCell             string          `xml:\"topLeftCell,attr\"`\n\tColorId                 int             `xml:\"colorId,attr\"`\n\tZoomScale               float64         `xml:\"zoomScale,attr\"`\n\tZoomScaleNormal         float64         `xml:\"zoomScaleNormal,attr\"`\n\tZoomScalePageLayoutView float64         `xml:\"zoomScalePageLayoutView,attr\"`\n\tWorkbookViewId          int             `xml:\"workbookViewId,attr\"`\n\tPane                    *xlsxPane       `xml:\"pane\"`\n\tSelection               []xlsxSelection `xml:\"selection\"`\n}\n\n// xlsxSelection directly maps the selection element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxSelection struct {\n\tPane         string `xml:\"pane,attr\"`\n\tActiveCell   string `xml:\"activeCell,attr\"`\n\tActiveCellId int    `xml:\"activeCellId,attr\"`\n\tSQRef        string `xml:\"sqref,attr\"`\n}\n\n// xlsxSelection directly maps the selection element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxPane struct {\n\tXSplit      float64 `xml:\"xSplit,attr\"`\n\tYSplit      float64 `xml:\"ySplit,attr\"`\n\tTopLeftCell string  `xml:\"topLeftCell,attr\"`\n\tActivePane  string  `xml:\"activePane,attr\"`\n\tState       string  `xml:\"state,attr\"` // Either \"split\" or \"frozen\"\n}\n\n// xlsxSheetPr directly maps the sheetPr element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxSheetPr struct {\n\tFilterMode  bool              `xml:\"filterMode,attr\"`\n\tPageSetUpPr []xlsxPageSetUpPr `xml:\"pageSetUpPr\"`\n}\n\n// xlsxPageSetUpPr directly maps the pageSetupPr element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxPageSetUpPr struct {\n\tFitToPage bool `xml:\"fitToPage,attr\"`\n}\n\n// xlsxCols directly maps the cols element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxCols struct {\n\tCol []xlsxCol `xml:\"col\"`\n}\n\n// xlsxCol directly maps the col element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxCol struct {\n\tCollapsed    *bool    `xml:\"collapsed,attr,omitempty\"`\n\tHidden       *bool    `xml:\"hidden,attr,omitempty\"`\n\tMax          int      `xml:\"max,attr\"`\n\tMin          int      `xml:\"min,attr\"`\n\tStyle        *int     `xml:\"style,attr,omitempty\"`\n\tWidth        *float64 `xml:\"width,attr,omitempty\"`\n\tCustomWidth  *bool    `xml:\"customWidth,attr,omitempty\"`\n\tOutlineLevel *uint8   `xml:\"outlineLevel,attr,omitempty\"`\n\tBestFit      *bool    `xml:\"bestFit,attr,omitempty\"`\n\tPhonetic     *bool    `xml:\"phonetic,attr,omitempty\"`\n}\n\n// xlsxDimension directly maps the dimension element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxDimension struct {\n\tRef string `xml:\"ref,attr\"`\n}\n\n// xlsxSheetData directly maps the sheetData element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxSheetData struct {\n\tXMLName xml.Name  `xml:\"sheetData\"`\n\tRow     []xlsxRow `xml:\"row\"`\n}\n\n// xlsxDataValidations  excel cell data validation\ntype xlsxDataValidations struct {\n\tDataValidation []*xlsxDataValidation `xml:\"dataValidation\"`\n\tCount          int                   `xml:\"count,attr\"`\n}\n\n// xlsxDataValidation\n// A single item of data validation defined on a range of the worksheet.\n// The list validation type would more commonly be called \"a drop down box.\"\ntype xlsxDataValidation struct {\n\t// A boolean value indicating whether the data validation allows the use of empty or blank\n\t//entries. 1 means empty entries are OK and do not violate the validation constraints.\n\tAllowBlank bool `xml:\"allowBlank,attr,omitempty\"`\n\t// A boolean value indicating whether to display the input prompt message.\n\tShowInputMessage bool `xml:\"showInputMessage,attr,omitempty\"`\n\t// A boolean value indicating whether to display the error alert message when an invalid\n\t// value has been entered, according to the criteria specified.\n\tShowErrorMessage bool `xml:\"showErrorMessage,attr,omitempty\"`\n\t// The style of error alert used for this data validation.\n\t// warning, infomation, or stop\n\t// Stop will prevent the user from entering data that does not pass validation.\n\tErrorStyle *string `xml:\"errorStyle,attr\"`\n\t// Title bar text of error alert.\n\tErrorTitle *string `xml:\"errorTitle,attr\"`\n\t// The relational operator used with this data validation.\n\t// The possible values for this can be equal, notEqual, lessThan, etc.\n\t// This only applies to certain validation types.\n\tOperator string `xml:\"operator,attr,omitempty\"`\n\t// Message text of error alert.\n\tError *string `xml:\"error,attr\"`\n\t// Title bar text of input prompt.\n\tPromptTitle *string `xml:\"promptTitle,attr\"`\n\t// Message text of input prompt.\n\tPrompt *string `xml:\"prompt,attr\"`\n\t// The type of data validation.\n\t// none, custom, date, decimal, list, textLength, time, whole\n\tType string `xml:\"type,attr\"`\n\t// Range over which data validation is applied.\n\t// Cell or range, eg: A1 OR A1:A20\n\tSqref string `xml:\"sqref,attr,omitempty\"`\n\t// The first formula in the Data Validation dropdown. It is used as a bounds for 'between' and\n\t// 'notBetween' relational operators, and the only formula used for other relational operators\n\t// (equal, notEqual, lessThan, lessThanOrEqual, greaterThan, greaterThanOrEqual), or for custom\n\t// or list type data validation. The content can be a formula or a constant or a list series (comma separated values).\n\tFormula1 string `xml:\"formula1\"`\n\t// The second formula in the DataValidation dropdown. It is used as a bounds for 'between' and\n\t// 'notBetween' relational operators only.\n\tFormula2 string `xml:\"formula2,omitempty\"`\n}\n\n// xlsxRow directly maps the row element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxRow struct {\n\tR            int     `xml:\"r,attr\"`\n\tSpans        string  `xml:\"spans,attr,omitempty\"`\n\tHidden       bool    `xml:\"hidden,attr,omitempty\"`\n\tC            []xlsxC `xml:\"c\"`\n\tHt           string  `xml:\"ht,attr,omitempty\"`\n\tCustomHeight bool    `xml:\"customHeight,attr,omitempty\"`\n\tOutlineLevel uint8   `xml:\"outlineLevel,attr,omitempty\"`\n}\n\ntype xlsxAutoFilter struct {\n\tRef string `xml:\"ref,attr\"`\n}\n\ntype xlsxMergeCell struct {\n\tRef string `xml:\"ref,attr\"` // ref: horiz \"A1:C1\", vert \"B3:B6\", both  \"D3:G4\"\n}\n\ntype xlsxMergeCells struct {\n\tXMLName  xml.Name                 // `xml:\"mergeCells,omitempty\"`\n\tCount    int                      `xml:\"count,attr,omitempty\"`\n\tCells    []xlsxMergeCell          `xml:\"mergeCell,omitempty\"`\n\tCellsMap map[string]xlsxMergeCell `xml:\"-\"`\n}\n\nfunc (mc *xlsxMergeCells) addCell(cell xlsxMergeCell) {\n\tif mc.CellsMap == nil {\n\t\tmc.CellsMap = make(map[string]xlsxMergeCell)\n\t}\n\tcellRefs := strings.Split(cell.Ref, \":\")\n\tmc.CellsMap[cellRefs[0]] = cell\n}\n\ntype xlsxHyperlinks struct {\n\tHyperLinks []xlsxHyperlink `xml:\"hyperlink\"`\n}\n\ntype xlsxHyperlink struct {\n\tRelationshipId string `xml:\"id,attr\"`\n\tReference      string `xml:\"ref,attr\"`\n\tDisplayString  string `xml:\"display,attr,omitempty\"`\n\tTooltip        string `xml:\"tooltip,attr,omitempty\"`\n\tLocation       string `xml:\"location,attr,omitempty\"`\n}\n\n// Return the cartesian extent of a merged cell range from its origin\n// cell (the closest merged cell to the to left of the sheet.\nfunc (mc *xlsxMergeCells) getExtent(cellRef string) (int, int, error) {\n\twrap := func(err error) (int, int, error) {\n\t\treturn -1, -1, fmt.Errorf(\"getExtent: %w\", err)\n\t}\n\n\tif mc == nil {\n\t\treturn 0, 0, nil\n\t}\n\tif cell, ok := mc.CellsMap[cellRef]; ok {\n\t\tparts := strings.Split(cell.Ref, \":\")\n\t\tstartx, starty, err := GetCoordsFromCellIDString(parts[0])\n\t\tif err != nil {\n\t\t\treturn wrap(err)\n\t\t}\n\t\tendx, endy, err := GetCoordsFromCellIDString(parts[1])\n\t\tif err != nil {\n\t\t\treturn wrap(err)\n\t\t}\n\t\treturn endx - startx, endy - starty, nil\n\t}\n\treturn 0, 0, nil\n}\n\n// xlsxC directly maps the c element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxC struct {\n\tXMLName xml.Name\n\tR       string  `xml:\"r,attr\"`           // Cell ID, e.g. A1\n\tS       int     `xml:\"s,attr,omitempty\"` // Style reference.\n\tT       string  `xml:\"t,attr,omitempty\"` // Type.\n\tF       *xlsxF  `xml:\"f,omitempty\"`      // Formula\n\tV       string  `xml:\"v,omitempty\"`      // Value\n\tIs      *xlsxSI `xml:\"is,omitempty\"`     // Inline String.\n}\n\n// xlsxF directly maps the f element in the namespace\n// http://schemas.openxmlformats.org/spreadsheetml/2006/main -\n// currently I have not checked it for completeness - it does as much\n// as I need.\ntype xlsxF struct {\n\tContent string `xml:\",chardata\"`\n\tT       string `xml:\"t,attr,omitempty\"`   // Formula type\n\tRef     string `xml:\"ref,attr,omitempty\"` // Shared formula ref\n\tSi      int    `xml:\"si,attr,omitempty\"`  // Shared formula index\n}\n\n// Create a new XLSX Worksheet with default values populated.\n// Strictly for internal use only!\nfunc newXlsxWorksheet() (worksheet *xlsxWorksheet) {\n\tworksheet = &xlsxWorksheet{}\n\tworksheet.XMLNSR = \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"\n\tworksheet.SheetPr.FilterMode = false\n\tworksheet.SheetPr.PageSetUpPr = make([]xlsxPageSetUpPr, 1)\n\tworksheet.SheetPr.PageSetUpPr[0] = xlsxPageSetUpPr{FitToPage: false}\n\tworksheet.SheetViews.SheetView = make([]xlsxSheetView, 1)\n\tworksheet.SheetViews.SheetView[0] = xlsxSheetView{\n\t\tColorId:                 64,\n\t\tDefaultGridColor:        true,\n\t\tRightToLeft:             false,\n\t\tSelection:               make([]xlsxSelection, 1),\n\t\tShowFormulas:            false,\n\t\tShowGridLines:           true,\n\t\tShowOutlineSymbols:      true,\n\t\tShowRowColHeaders:       true,\n\t\tShowZeros:               true,\n\t\tTabSelected:             false,\n\t\tTopLeftCell:             \"A1\",\n\t\tView:                    \"normal\",\n\t\tWindowProtection:        false,\n\t\tWorkbookViewId:          0,\n\t\tZoomScale:               100,\n\t\tZoomScaleNormal:         100,\n\t\tZoomScalePageLayoutView: 100}\n\tworksheet.SheetViews.SheetView[0].Selection[0] = xlsxSelection{\n\t\tPane:         \"topLeft\",\n\t\tActiveCell:   \"A1\",\n\t\tActiveCellId: 0,\n\t\tSQRef:        \"A1\"}\n\tworksheet.SheetFormatPr.DefaultRowHeight = 12.85\n\n\treturn\n}\n\n// setup the CellsMap so that we can rapidly calculate extents\nfunc (worksheet *xlsxWorksheet) mapMergeCells() {\n\n\tif worksheet.MergeCells != nil {\n\t\tfor _, cell := range worksheet.MergeCells.Cells {\n\t\t\tworksheet.MergeCells.addCell(cell)\n\t\t}\n\t}\n\n}\n\nfunc makeXMLAttr(fv reflect.Value, parentName, name string) (xmlwriter.Attr, error) {\n\tattr := xmlwriter.Attr{\n\t\tName: name,\n\t}\n\n\tif fv.Kind() == reflect.Ptr {\n\t\telm := fv.Elem()\n\t\tif elm.Kind() == reflect.Invalid {\n\t\t\treturn attr, nil\n\t\t}\n\t\treturn makeXMLAttr(elm, parentName, name)\n\t}\n\n\tswitch fv.Kind() {\n\tcase reflect.Bool:\n\t\tattr = attr.Bool(fv.Bool())\n\tcase reflect.Int:\n\t\tattr = attr.Int(int(fv.Int()))\n\tcase reflect.Int8:\n\t\tattr = attr.Int8(int8(fv.Int()))\n\tcase reflect.Int16:\n\t\tattr = attr.Int16(int16(fv.Int()))\n\tcase reflect.Int32:\n\t\tattr = attr.Int32(int32(fv.Int()))\n\tcase reflect.Int64:\n\t\tattr = attr.Int64(fv.Int())\n\tcase reflect.Uint:\n\t\tattr = attr.Uint(int(fv.Uint()))\n\tcase reflect.Uint8:\n\t\tattr = attr.Uint8(uint8(fv.Uint()))\n\tcase reflect.Uint16:\n\t\tattr = attr.Uint16(uint16(fv.Uint()))\n\tcase reflect.Uint32:\n\t\tattr = attr.Uint32(uint32(fv.Uint()))\n\tcase reflect.Uint64:\n\t\tattr = attr.Uint64(fv.Uint())\n\tcase reflect.Float32:\n\t\tattr = attr.Float32(float32(fv.Float()))\n\tcase reflect.Float64:\n\t\tattr = attr.Float64(fv.Float())\n\tcase reflect.String:\n\t\tattr.Value = fv.String()\n\tdefault:\n\t\treturn attr, fmt.Errorf(\"not yet handled %s.%s (%s)\", parentName, name, fv.Kind())\n\n\t}\n\n\treturn attr, nil\n}\n\nfunc parseXMLTag(tag string) (string, string, bool, bool, bool) {\n\tvar xmlNS string\n\tvar name string\n\tvar omitempty bool\n\tvar isAttr bool\n\tvar charData bool\n\tparts := strings.Split(tag, \",\")\n\tpartLen := len(parts)\n\tif partLen > 0 {\n\t\tnameParts := strings.Split(parts[0], \" \")\n\t\tif len(nameParts) > 1 {\n\t\t\txmlNS = nameParts[0]\n\t\t\tname = nameParts[1]\n\t\t} else {\n\t\t\tname = nameParts[0]\n\t\t}\n\t}\n\tif partLen > 1 {\n\t\tfor _, p := range parts[1:] {\n\t\t\tomitempty = omitempty || p == \"omitempty\"\n\t\t\tisAttr = isAttr || p == \"attr\"\n\t\t\tcharData = charData || p == \"chardata\"\n\t\t}\n\t}\n\treturn xmlNS, name, omitempty, isAttr, charData\n}\n\nfunc emitStructAsXML(v reflect.Value, name, xmlNS string) (xmlwriter.Elem, error) {\n\tif v.Kind() == reflect.Ptr {\n\t\treturn emitStructAsXML(v.Elem(), name, xmlNS)\n\t}\n\toutput := xmlwriter.Elem{\n\t\tName: name,\n\t}\n\n\tif xmlNS != \"\" {\n\t\toutput.Attrs = append(output.Attrs, xmlwriter.Attr{\n\t\t\tName:  \"xmlns\",\n\t\t\tValue: xmlNS,\n\t\t})\n\t}\n\n\tfor i := 0; i < v.NumField(); i++ {\n\t\tvar xmlNS string\n\t\tvar name string\n\t\tvar omitempty bool\n\t\tvar isAttr bool\n\t\tvar charData bool\n\t\tfv := v.Field(i)\n\t\tft := v.Type().Field(i)\n\t\ttag := ft.Tag.Get(\"xml\")\n\t\tif tag == \"\" {\n\t\t\t// This field is not intended for export!\n\t\t\tcontinue\n\t\t}\n\n\t\txmlNS, name, omitempty, isAttr, charData = parseXMLTag(tag)\n\t\tif name == \"-\" {\n\t\t\t// This name means we shouldn't emit this element.\n\t\t\tcontinue\n\t\t}\n\t\tif isAttr {\n\t\t\tif omitempty && reflect.Zero(fv.Type()).Interface() == fv.Interface() {\n\t\t\t\t// The value is this types zero value\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif output.Name == \"hyperlink\" && name == \"id\" {\n\t\t\t\t// Hack to respect the relationship namespace\n\t\t\t\tname = \"r:id\"\n\t\t\t}\n\t\t\tattr, err := makeXMLAttr(fv, output.Name, name)\n\t\t\tif err != nil {\n\t\t\t\treturn output, err\n\t\t\t}\n\t\t\toutput.Attrs = append(output.Attrs, attr)\n\t\t\tcontinue\n\t\t}\n\t\tif charData {\n\t\t\toutput.Content = append(output.Content, xmlwriter.Text(fv.String()))\n\t\t\tcontinue\n\t\t}\n\t\tswitch ft.Name {\n\t\tcase \"XMLName\":\n\t\t\toutput.Name = name\n\t\t\toutput.Attrs = append(output.Attrs, xmlwriter.Attr{\n\t\t\t\tName:  \"xmlns\",\n\t\t\t\tValue: xmlNS,\n\t\t\t})\n\t\tcase \"SheetData\", \"MergeCells\", \"DataValidations\", \"AutoFilter\":\n\t\t\t// Skip SheetData here, we explicitly generate this in writeXML below\n\t\t\t// Microsoft Excel considers a mergeCells element before a sheetData element to be\n\t\t\t// an error and will fail to open the document, so we'll be back with this data\n\t\t\t// from writeXml later.\n\n\t\t\tcontinue\n\t\tdefault:\n\t\t\tif fv.Kind() == reflect.Ptr {\n\t\t\t\tif fv.IsNil() {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tfv = fv.Elem()\n\t\t\t}\n\t\t\tswitch fv.Kind() {\n\t\t\tcase reflect.Struct:\n\t\t\t\telem, err := emitStructAsXML(fv, name, xmlNS)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn output, err\n\t\t\t\t}\n\t\t\t\toutput.Content = append(output.Content, elem)\n\t\t\tcase reflect.Slice:\n\t\t\t\tfor i := 0; i < fv.Len(); i++ {\n\t\t\t\t\tv := fv.Index(i)\n\t\t\t\t\telem, err := emitStructAsXML(v, name, xmlNS)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn output, err\n\t\t\t\t\t}\n\t\t\t\t\toutput.Content = append(output.Content, elem)\n\t\t\t\t}\n\t\t\tcase reflect.String:\n\t\t\t\telem := xmlwriter.Elem{Name: name}\n\t\t\t\tif xmlNS != \"\" {\n\t\t\t\t\telem.Attrs = append(elem.Attrs, xmlwriter.Attr{\n\t\t\t\t\t\tName:  \"xmlns\",\n\t\t\t\t\t\tValue: xmlNS,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\telem.Content = append(elem.Content, xmlwriter.Text(fv.String()))\n\t\t\t\toutput.Content = append(output.Content, elem)\n\t\t\tdefault:\n\t\t\t\treturn output, fmt.Errorf(\"todo with unhandled kind %s : %s\", fv.Kind(), name)\n\t\t\t}\n\t\t}\n\t}\n\treturn output, nil\n\n}\n\nfunc (worksheet *xlsxWorksheet) makeXlsxRowFromRow(row *Row, styles *xlsxStyleSheet, refTable *RefTable) (*xlsxRow, error) {\n\txRow := &xlsxRow{}\n\txRow.R = row.num + 1\n\tif row.customHeight {\n\t\txRow.CustomHeight = true\n\t\txRow.Ht = fmt.Sprintf(\"%g\", row.GetHeight())\n\t}\n\txRow.OutlineLevel = row.GetOutlineLevel()\n\n\terr := row.ForEachCell(func(cell *Cell) error {\n\t\tvar XfId int\n\n\t\tcol := row.Sheet.Col(cell.num)\n\t\tif col != nil {\n\t\t\tXfId = col.outXfID\n\t\t}\n\n\t\t// generate NumFmtId and add new NumFmt\n\t\txNumFmt := styles.newNumFmt(cell.NumFmt)\n\n\t\tstyle := cell.style\n\t\tswitch {\n\t\tcase style != nil:\n\t\t\tXfId = handleStyleForXLSX(style, xNumFmt.NumFmtId, styles)\n\t\tcase len(cell.NumFmt) == 0:\n\t\t\t// Do nothing\n\t\tcase col == nil:\n\t\t\tXfId = handleNumFmtIdForXLSX(xNumFmt.NumFmtId, styles)\n\t\tcase !compareFormatString(col.numFmt, cell.NumFmt):\n\t\t\tXfId = handleNumFmtIdForXLSX(xNumFmt.NumFmtId, styles)\n\t\t}\n\t\txC := xlsxC{\n\t\t\tS: XfId,\n\t\t\tR: GetCellIDStringFromCoords(cell.num, row.num),\n\t\t}\n\t\tif cell.formula != \"\" {\n\t\t\txC.F = &xlsxF{Content: cell.formula}\n\t\t}\n\t\tswitch cell.cellType {\n\t\tcase CellTypeInline:\n\t\t\t// Inline strings are turned into shared strings since they are more efficient.\n\t\t\t// This is what Excel does as well.\n\t\t\tfallthrough\n\t\tcase CellTypeString:\n\t\t\tif len(cell.Value) > 0 {\n\t\t\t\txC.V = strconv.Itoa(refTable.AddString(cell.Value))\n\t\t\t} else if len(cell.RichText) > 0 {\n\t\t\t\txC.V = strconv.Itoa(refTable.AddRichText(cell.RichText))\n\t\t\t} else {\n\t\t\t\txC.V = strconv.Itoa(refTable.AddString(\"\"))\n\t\t\t}\n\t\t\txC.T = \"s\"\n\t\tcase CellTypeNumeric:\n\t\t\t// Numeric is the default, so the type can be left blank\n\t\t\txC.V = cell.Value\n\t\tcase CellTypeBool:\n\t\t\txC.V = cell.Value\n\t\t\txC.T = \"b\"\n\t\tcase CellTypeError:\n\t\t\txC.V = cell.Value\n\t\t\txC.T = \"e\"\n\t\tcase CellTypeDate:\n\t\t\txC.V = cell.Value\n\t\t\txC.T = \"d\"\n\t\tcase CellTypeStringFormula:\n\t\t\txC.V = cell.Value\n\t\t\txC.T = \"str\"\n\t\tdefault:\n\t\t\treturn errors.New(\"unknown cell type cannot be marshaled\")\n\t\t}\n\t\txRow.C = append(xRow.C, xC)\n\n\t\treturn nil\n\t}, SkipEmptyCells)\n\n\treturn xRow, err\n}\n\nfunc (worksheet *xlsxWorksheet) WriteXML(xw *xmlwriter.Writer, s *Sheet, styles *xlsxStyleSheet, refTable *RefTable) (err error) {\n\tvar output xmlwriter.Elem\n\tworksheet.XMLNSR = \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\"\n\telem := reflect.ValueOf(worksheet)\n\toutput, err = emitStructAsXML(elem, \"\", \"\")\n\tif err != nil {\n\t\treturn\n\t}\n\n\tec := xmlwriter.ErrCollector{}\n\tdefer ec.Set(&err)\n\tec.Do(\n\t\txw.StartElem(output),\n\t\txw.StartElem(xmlwriter.Elem{Name: \"sheetData\"}),\n\t\ts.ForEachRow(func(row *Row) error {\n\t\t\txRow, err := worksheet.makeXlsxRowFromRow(row, styles, refTable)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\telem := reflect.ValueOf(xRow)\n\t\t\toutput, err := emitStructAsXML(elem, \"row\", \"\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\terr = xw.Write(output)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn xw.Flush()\n\n\t\t}, SkipEmptyRows),\n\t\txw.EndElem(\"sheetData\"),\n\t\tfunc() error {\n\t\t\tif worksheet.MergeCells != nil {\n\t\t\t\tmergeCells, err := emitStructAsXML(reflect.ValueOf(worksheet.MergeCells), \"mergeCells\", \"\")\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif err := xw.Write(mergeCells); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\tif worksheet.DataValidations != nil {\n\t\t\t\tdataValidation, err := emitStructAsXML(reflect.ValueOf(worksheet.DataValidations), \"dataValidations\", \"\")\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif err := xw.Write(dataValidation); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\tif worksheet.AutoFilter != nil {\n\t\t\t\tautoFilter, err := emitStructAsXML(reflect.ValueOf(worksheet.AutoFilter), \"autoFilter\", \"\")\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif err := xw.Write(autoFilter); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}(),\n\t\txw.EndElem(output.Name),\n\t\txw.Flush(),\n\t)\n\treturn\n\n}\n"
        },
        {
          "name": "xmlWorksheet_test.go",
          "type": "blob",
          "size": 8.44921875,
          "content": "package xlsx\n\nimport (\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"testing\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\n// Test we can succesfully unmarshal the sheetN.xml files within and\n// XLSX file into an xlsxWorksheet struct (and it's related children).\nfunc TestUnmarshallWorksheet(t *testing.T) {\n\tc := qt.New(t)\n\tvar sheetxml = bytes.NewBufferString(\n\t\t`<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n        <worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"\n                   xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\">\n          <sheetPr filterMode=\"false\">\n            <pageSetUpPr fitToPage=\"false\"/>\n          </sheetPr>\n          <dimension ref=\"A1:B2\"/>\n          <sheetViews>\n            <sheetView colorId=\"64\"\n                       defaultGridColor=\"true\"\n                       rightToLeft=\"false\"\n                       showFormulas=\"false\"\n                       showGridLines=\"true\"\n                       showOutlineSymbols=\"true\"\n                       showRowColHeaders=\"true\"\n                       showZeros=\"true\"\n                       tabSelected=\"true\"\n                       topLeftCell=\"A1\"\n                       view=\"normal\"\n                       windowProtection=\"false\"\n                       workbookViewId=\"0\"\n                       zoomScale=\"100\"\n                       zoomScaleNormal=\"100\"\n                       zoomScalePageLayoutView=\"100\">\n              <selection activeCell=\"B2\"\n                         activeCellId=\"0\"\n                         pane=\"topLeft\"\n                         sqref=\"B2\"/>\n            </sheetView>\n          </sheetViews>\n          <sheetFormatPr defaultRowHeight=\"15\" defaultColWidth=\"8\">\n          </sheetFormatPr>\n          <cols>\n            <col collapsed=\"false\"\n                 hidden=\"false\"\n                 max=\"1025\"\n                 min=\"1\"\n                 style=\"0\"\n                 width=\"10.5748987854251\"/>\n          </cols>\n          <sheetData>\n            <row collapsed=\"false\"\n                 customFormat=\"false\"\n                 customHeight=\"false\"\n                 hidden=\"false\"\n                 ht=\"14.9\"\n                 outlineLevel=\"0\"\n                 r=\"1\">\n              <c r=\"A1\"\n                 s=\"1\"\n                 t=\"s\">\n                <v>0</v>\n              </c>\n              <c r=\"B1\"\n                 s=\"0\"\n                 t=\"s\">\n                <v>1</v>\n              </c>\n            </row>\n            <row collapsed=\"false\"\n                 customFormat=\"false\"\n                 customHeight=\"false\"\n                 hidden=\"false\"\n                 ht=\"14.9\"\n                 outlineLevel=\"0\"\n                 r=\"2\">\n              <c r=\"A2\"\n                 s=\"0\"\n                 t=\"s\">\n                <v>2</v>\n              </c>\n              <c r=\"B2\"\n                 s=\"2\"\n                 t=\"s\">\n                <v>3</v>\n              </c>\n            </row>\n          </sheetData>\n          <autoFilter ref=\"A1:Z4\" />\n          <printOptions headings=\"false\"\n                        gridLines=\"false\"\n                        gridLinesSet=\"true\"\n                        horizontalCentered=\"false\"\n                        verticalCentered=\"false\"/>\n          <pageMargins left=\"0.7\"\n                       right=\"0.7\"\n                       top=\"0.7875\"\n                       bottom=\"0.7875\"\n                       header=\"0.511805555555555\"\n                       footer=\"0.511805555555555\"/>\n          <pageSetup blackAndWhite=\"false\"\n                     cellComments=\"none\"\n                     copies=\"1\"\n                     draft=\"false\"\n                     firstPageNumber=\"0\"\n                     fitToHeight=\"1\"\n                     fitToWidth=\"1\"\n                     horizontalDpi=\"300\"\n                     orientation=\"portrait\"\n                     pageOrder=\"downThenOver\"\n                     paperSize=\"9\"\n                     scale=\"100\"\n                     useFirstPageNumber=\"false\"\n                     usePrinterDefaults=\"false\"\n                     verticalDpi=\"300\"/>\n          <headerFooter differentFirst=\"false\"\n                        differentOddEven=\"false\">\n            <oddHeader>\n            </oddHeader>\n            <oddFooter>\n            </oddFooter>\n          </headerFooter>\n        </worksheet>`)\n\tworksheet := new(xlsxWorksheet)\n\terr := xml.NewDecoder(sheetxml).Decode(worksheet)\n\tc.Assert(err, qt.IsNil)\n\tc.Assert(worksheet.Dimension.Ref, qt.Equals, \"A1:B2\")\n\tc.Assert(worksheet.SheetData.Row, qt.HasLen, 2)\n\tc.Assert(worksheet.SheetFormatPr.DefaultRowHeight, qt.Equals, 15.0)\n\tc.Assert(worksheet.SheetFormatPr.DefaultColWidth, qt.Equals, 8.0)\n\trow := worksheet.SheetData.Row[0]\n\tc.Assert(row.R, qt.Equals, 1)\n\tc.Assert(row.C, qt.HasLen, 2)\n\tcell := row.C[0]\n\tc.Assert(cell.R, qt.Equals, \"A1\")\n\tc.Assert(cell.T, qt.Equals, \"s\")\n\tc.Assert(cell.V, qt.Equals, \"0\")\n\tc.Assert(worksheet.AutoFilter, qt.IsNotNil)\n\tc.Assert(worksheet.AutoFilter.Ref, qt.Equals, \"A1:Z4\")\n}\n\n// MergeCells information is correctly read from the worksheet.\nfunc TestUnmarshallWorksheetWithMergeCells(t *testing.T) {\n\tc := qt.New(t)\n\tvar sheetxml = bytes.NewBufferString(\n\t\t`<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mx=\"http://schemas.microsoft.com/office/mac/excel/2008/main\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:mv=\"urn:schemas-microsoft-com:mac:vml\" xmlns:x14=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/main\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\" xmlns:xm=\"http://schemas.microsoft.com/office/excel/2006/main\">\n  <sheetViews>\n    <sheetView workbookViewId=\"0\"/>\n  </sheetViews>\n  <sheetFormatPr customHeight=\"1\" defaultColWidth=\"17.29\" defaultRowHeight=\"15.0\"/>\n  <cols>\n    <col customWidth=\"1\" min=\"1\" max=\"6\" width=\"14.43\"/>\n  </cols>\n  <sheetData>\n    <row r=\"1\" ht=\"15.75\" customHeight=\"1\">\n      <c r=\"A1\" s=\"1\" t=\"s\">\n        <v>0</v>\n      </c>\n    </row>\n    <row r=\"2\" ht=\"15.75\" customHeight=\"1\">\n      <c r=\"A2\" s=\"1\" t=\"s\">\n        <v>1</v>\n      </c>\n      <c r=\"B2\" s=\"1\" t=\"s\">\n        <v>2</v>\n      </c>\n    </row>\n  </sheetData>\n  <mergeCells count=\"1\">\n    <mergeCell ref=\"A1:B1\"/>\n  </mergeCells>\n  <drawing r:id=\"rId1\"/>\n</worksheet>\n`)\n\tworksheet := new(xlsxWorksheet)\n\terr := xml.NewDecoder(sheetxml).Decode(worksheet)\n\tc.Assert(err, qt.IsNil)\n\tc.Assert(worksheet.MergeCells, qt.IsNotNil)\n\tc.Assert(worksheet.MergeCells.Count, qt.Equals, 1)\n\tmergeCell := worksheet.MergeCells.Cells[0]\n\tc.Assert(mergeCell.Ref, qt.Equals, \"A1:B1\")\n}\n\n// MergeCells.getExtents returns the horizontal and vertical extent of\n// a merge that begins at a given reference.\nfunc TestMergeCellsGetExtent(t *testing.T) {\n\tc := qt.New(t)\n\tmc := xlsxMergeCells{Count: 2}\n\tmc.Cells = make([]xlsxMergeCell, 2)\n\tcell1 := xlsxMergeCell{Ref: \"A11:A12\"}\n\tmc.Cells[0] = cell1\n\tmc.addCell(cell1)\n\tcell2 := xlsxMergeCell{Ref: \"A1:C5\"}\n\tmc.Cells[1] = cell2\n\tmc.addCell(cell2)\n\th, v, err := mc.getExtent(\"A1\")\n\tc.Assert(err, qt.IsNil)\n\tc.Assert(h, qt.Equals, 2)\n\tc.Assert(v, qt.Equals, 4)\n\th, v, err = mc.getExtent(\"A11\")\n\tc.Assert(err, qt.IsNil)\n\tc.Assert(h, qt.Equals, 0)\n\tc.Assert(v, qt.Equals, 1)\n}\n\nfunc TestParseXMLTag(t *testing.T) {\n\tc := qt.New(t)\n\n\tassertTag := func(caseName, tag, exXMLNS, exName string, exOmitEmpty, exIsAttr, exCharData bool) {\n\t\tc.Run(caseName, func(c *qt.C) {\n\t\t\txmlNS, name, omitEmpty, isAttr, charData := parseXMLTag(tag)\n\t\t\tc.Assert(xmlNS, qt.Equals, exXMLNS)\n\t\t\tc.Assert(name, qt.Equals, exName)\n\t\t\tc.Assert(omitEmpty, qt.Equals, exOmitEmpty)\n\t\t\tc.Assert(isAttr, qt.Equals, exIsAttr)\n\t\t\tc.Assert(charData, qt.Equals, exCharData)\n\t\t})\n\t}\n\n\tassertTag(\"Name\", \"Relationship\", \"\", \"Relationship\", false, false, false)\n\tassertTag(\"XML Namespace, Name\", \"http://schemas.openxmlformats.org/spreadsheetml/2006/main worksheet\",\n\t\t\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\",\n\t\t\"worksheet\",\n\t\tfalse,\n\t\tfalse,\n\t\tfalse)\n\n\tassertTag(\"Omit empty\", \",omitempty\", \"\", \"\", true, false, false)\n\tassertTag(\"Attr\", \",attr\", \"\", \"\", false, true, false)\n\tassertTag(\"Char Data\", \",chardata\", \"\", \"\", false, false, true)\n\n\tassertTag(\"Name, Attr\", \"Id,attr\", \"\", \"Id\", false, true, false)\n\tassertTag(\"Name, Omit Empty\", \"cols,omitempty\", \"\", \"cols\", true, false, false)\n\tassertTag(\"Name, Char Data\", \"cols,chardata\", \"\", \"cols\", false, false, true)\n\n\tassertTag(\"Name, Attr, Omit Empty\", \"defaultColWidth,attr,omitempty\", \"\", \"defaultColWidth\", true, true, false)\n}\n"
        }
      ]
    }
  ]
}