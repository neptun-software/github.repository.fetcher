{
  "metadata": {
    "timestamp": 1736567766971,
    "page": 349,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tools/godep",
      "stars": 5534,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0068359375,
          "content": "/godep\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.490234375,
          "content": "language: go\nsudo: false\ngo: 1.6\nscript:\n  # Godep's unit tests run git, and git complains\n  # if we don't set these config parameters.\n  # We put dummy values here because they don't matter.\n- git config --global user.email \"you@example.com\"\n- git config --global user.name \"Your Name\"\n- test -z \"$(go fmt)\"\n- go vet\n- go test -v\n- go test -v -race\n- test -z \"$(goimports -l .)\"\nbefore_install:\n- go get golang.org/x/tools/cmd/goimports\nbefore_deploy:\n- export OS_TARGETS=\"linux darwin windows\"\n- export ARCH_TARGETS=\"386 amd64\"\n- go get github.com/mitchellh/gox\n- gox -os \"$OS_TARGETS\" -arch=\"$ARCH_TARGETS\"\ndeploy:\n  skip_cleanup: true\n  provider: releases\n  api_key:\n    secure: Q1JP8LziaXMTxFmNXiyC1YhS9e4M4WnI6UDjRTMf6mm1LZeJyUFOCCtXnifL7RyCIR1hpjp6s8M1aWE+NpuweF96IZI3Uk4ASx5C8FePC4qvhsCdtJ2sLD2GTIrp9b0MS9/+ao20AIbpVDSaLaF9IjqXpMxMyM0P8P5coRTkwItlGxmQbVJW3YuiYcPa8UojwM4EyafO2CIoUKapW8lwb9KcimBJV8PfF/XZjPVhMkn2ABhh5Hqbn2zBJtvPYMMzi0CnY50JQF5LwN3vGTMpTsRP+lOLCNbOWfkl+2hgG7VpKrtx+cX62knOodpF457sIJ31KUzmeLUVBejTGb1zuVeTojuyi8Huo8YBIBCcN+p3Dqd+n2ZK45mIrheGiEJIkf/vI4MI6A01Nu/o+xU0IPsVfAL/xU5j5nntEGfFWVoclPrl9qcfqf74xdRcARzcCJVmdc8iw49DBDHJfnPa3zxzVz//00+Rz6mZXmhk+Npk/HLLNW59vmJIjP+8XOtPor7dST9HrS1a9AcnmIjNuw9yfbwK5769SDVxCKgqNwXW/Dy5F39aIH5AL4I4y9hCEeeT8ctvSJHGOyiB9MWU5jnt5tluPtz5opG51tFXnIYP/XaWpTfO+eJ6x55pbwT+n3LfRS5l1POM+jGAFF1MFWwc14RY7qynEIEzm4Wb/UE=\n  file:\n    - godep_darwin_amd64\n    - godep_linux_amd64\n    - godep_windows_386.exe\n    - godep_windows_amd64.exe\n  on:\n    tags: true\n    repo: tools/godep\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "Changelog.md",
          "type": "blob",
          "size": 11.2333984375,
          "content": "#v80 (2018/01/26)\n\n* Address lin/vet feedback.\n\n#v79 (2017/02/01)\n\n* Fixes #531: fullPackageInDir didn't capture the error from fillPackage()\n\n#v78 (2017/01/19)\n\n* Don't use build.ImportDir when discovering packages for the package spec. Fixes #529\n\n#v77 (2017/01/13)\n\n* Don't include quotes around hg revisions\n\n#v76 (2017/01/10)\n\n* Default to vendor being on unless older go versions.\n\n#v75 (2016/11/02)\n\n* Add \"AUTHORS\" and \"CONTRIBUTORS\" to legal files list: https://github.com/tools/godep/pull/522\n\n#v74 (2016/06/01)\n\n* Enable vendor/ on go1.7\n* No longer use a godep workspace, use vendor/ (yay!)\n* Notify that support for Godep workspaces will be removed once go1.8 ships\n\n#v73 (2016/05/31)\n\n* Fix permission changes on Windows via @alexbrand. Closes #481.\n\n#v72 (2016/05/27)\n\n* Improve handling of git remote show origin. Should help in cases where remote HEAD is ambiguous.\n* Add ISSUE_TEMPLATE\n\n#v71 (2016/05/24)\n\n* Preserve permissions on copied files.\n\n#v70 (2016/05/20)\n\n* Fix the May changelog dates\n* No need to call build.Import, we already have the root of the dependency. Fixes an additional comment on #365\n\n#v69 (2016/05/16)\n\n* Make sure `devel-<short sha>` enabled `vendor/` unless there is a classic Godep _workspace already.\n\n#v68 (2016/05/16)\n\n* `devel-<short sha>` is always considered newer than any released go version\n\n#v67 (2016/05/13)\n\n* Attempt to handle missing deps a little better.\n\n#v66 (2016/05/10)\n\n* Use `git remote show origin` to find the default branch when restoring a git based package repository that is in detached head state\n\n#v65 (2016/05/09)\n\n* Rewrite update so that it considers new transitive dependencies, both in the same repo and outside of it.\n\n#v64 (2016/05/09)\n\n* godep update golang.org/x/tools/go/vcs\n\n#v63 (2016/05/03)\n\n* Support recording devel-<short sha> so development versions of Go can be matched\n\n#v62 (2016/04/07)\n\n* Note new go1.6+ behavior of not checking out master in README / restore help text.\n\n#v61 (2016/04/06)\n\n* Obey go version build tags based on recorded major go version. Fixes #448.\n\n#v60 (2016/03/18)\n\n* Make the $GOPATH check a warning.\n\n#v59 (2016/03/18)\n\n* Enforce requirement to be inside of a go src directory. A lot of time is usually spent\ntracking down bug reports where people are doign stuff from outside of their $GOPATH. This\nshould help with that, at least until there it time to properly test godep use outside of a\n$GOPATH and fix the issues.\n\n#v58 (2016/03/15)\n\n* Add GodepVersion to Godeps.json file so that as godep changes / adds features / fixes bugs we can know which version of godep most recently wrote out the file.\n\n#v57 (2016/03/07)\n\n* Don't use `git rev-parse --show-toplevel` to determine git repo roots as it resolves symlinks: https://github.com/tools/godep/pull/418\n\n# v56 (2016/02/26)\n\n* replace path comparisons with case insensitive pathEqual()\n* add versionString() to debug output\n* Send log output to Stderr\n\n# v55 2016/02/22\n\n* re-saved deps to clean out extra stuff (see v54; godep restore; godep save -r=false; rm -rf Godeps; godep save -r). We're still using a workspace with rewrites so users of older go version can still go get this tool.\n* Replace simple == with strings.EqualFold in listFiles to avoid problems with case insensitive filesystems (\"Code\" != \"code\" when doing a byte by byte comparison)\n\n# v54 2016/02/22\n\n* Update some docs around vendor/\n* More precise recording of dependencies. Removed recursive copying of sub directories of a package (precise vendoring). This should allow using `./...` with the go tool for compilation of project using `vendor/`. See https://github.com/tools/godep/pull/415\n\n# v53 2016/02/11\n\n* Disable VendorExperiment if a godep workspace already exists.\n\n# v52 2016/01/27\n\n* Trim 'rc' out of go version strings when determining major version.\n\n# v51 2016/01/21\n\n* Trim 'beta' out of go version strings when determining major version.\n\n# v50 2016/01/19\n\n* More verbose output on save -v.\n\n# v49 2016/01/13\n\n* Add UK spelling license/licence to the pile + fix up a bunch of typos\n* Clarify tag handling in docs\n\n# v48 2016/01/13\n\n* Abort restore if there is no $GOPATH set.\n\n# v47 2016/01/12\n\n* Dev versions of go should honor the current meaning of GO15VENDOREXPERIMENT\n\n# v46 2016/01/03\n\n* Record \"devel\" when the release is a devel release of go (compiled from git).\n\n# v45 2015/12/28\n\n* Upcase windows drive letters before comparing. Fixes #383.\n\n# v44 2015/12/23\n\n* Clean package roots when attempting to find a vendor directory so we don't loop forever.\n    * Fixes 382\n\n# v43 2015/12/22\n\n* Better error messages when parsing Godeps.json: Fixes #372\n\n# v42 2015/12/22\n\n* Fix a bunch of GO15VENDOREXPERIMENT issues\n    * Find package directories better. Previously we used build.FindOnly which didn't work the way I expected it to (any dir would work w/o error).\n    * Set the VendorExperiment bool based on go version as 1.6 defaults to on.\n    * A bunch of extra debugging for use while sanity checking myself.\n    * vendor flag for test structs.\n    * Some tests for vendor/ stuff:\n        * Basic Test\n        * Transitive\n        * Transitive, across GOPATHs + collapse vendor/ directories.\n* Should Fix #358\n\n# v41 2015/12/17\n\n* Don't rewrite packages outside of the project. This would happen if you specified\n  an external package for vendoring when you ran `goodep save -r ./... github.com/some/other/package`\n\n# v40 2015/12/17\n\n* When downloading a dependency, create the base directory if needed.\n\n# v39 2015/12/16\n\n* Record only the major go version (ex. go1.5) instead of the complete string.\n\n# v38 2015/12/16\n\n* Replace `go get`, further fix up restore error handling/reporting.\n    * Fixes #186\n    * Don't bother restoring/downloading if already done.\n\n# v37 2015/12/15\n\n* Change up how download/restore works a little\n    * Try to load the package after downloading/restoring. Previously\n      that was done too early in the process.\n    * make previous verbose output debug output\n    * report a typed error instead of a string from listPackage so it can\n      be asserted to provide a nicer error.\n    * Catch go get errors that say there are no go files found. See code\n      comment as to why.\n    * do *all* downloading during download phase.\n\n# v36 2015/12/14\n\n* Fixes #358: Using wrong variable. Will add test after release.\n\n# v35 2015/12/11\n\n* Fixes #356: Major performance regressions in v34\n    * Enable cpu profiling via flag on save.\n    * Cache packages by dir\n    * Don't do a full import pass on deps for packages in the GOROOT\n    * create a bit less garbage at times\n* Generalize -v & -d flags\n\n# v34 2015/12/08\n\n* We now use build.Context to help locate packages only and do our own parsing (via go/ast).\n* Fixes reported issues caused by v33 (Removal of `go list`):\n    * #345: Bug in godep restore\n    * #346: Fix loading a dot package\n    * #348: Godep save issue when importing lib/pq\n    * #350: undefined: build.MultiplePackageError\n    * #351: stow away helper files\n    * #353: cannot find package \"appengine\"\n        * Don't process imports of `.go` files tagged with the `appengine` build tag.\n\n# v33 2015/12/07\n\n* Replace the use of `go list`. This is a large change although all existing tests pass.\n    * Don't process the imports of `.go` files with the `ignore` build tag.\n\n# v32 2015/12/02\n\n* Eval Symlinks in Contains() check.\n\n# v31 2015/12/02\n\n* In restore, mention which package had the problem -- @shurcool\n\n# v30 2015/11/25\n\n* Add `-t` flag to the `godep get` command.\n\n# v29 2015/11/17\n\n* Temp work around to fix issue with LICENSE files.\n\n# v28 2015/11/09\n\n* Make `version` an actual command.\n\n# v27 2015/11/06\n\n* run command once during restore -v\n\n# v26 2015/11/05\n\n* Better fix for the issue fixed in v25: All update paths are now path.Clean()'d\n\n# v25 2015/11/05\n\n* `godep update package/` == `godep update package`. Fixes #313\n\n# v24 2015/11/05\n\n* Honor -t during update. Fixes #312\n\n# v23 2015/11/05\n\n* Do not use --debug to find full revision name for mercurial repositories\n\n# v22 2015/11/14\n\n* s/GOVENDOREXPERIMENT/GO15VENDOREXPERIMENT :-(\n\n# v21 2015/11/13\n\n* Fix #310: Case insensitive fs issue\n\n# v20 2015/11/13\n\n* Attempt to include license files when vendoring. (@client9)\n\n# v19 2015/11/3\n\n* Fix conflict error message. Revisions were swapped. Also better selection of package that needs update.\n\n# v18 2015/10/16\n\n* Improve error message when trying to save a conflicting revision.\n\n# v17 2015/10/15\n\n* Fix for v16 bug. All vcs list commands now produce paths relative to the root of the vcs.\n\n# v16 2015/10/15\n\n* Determine repo root using vcs commands and use that instead of dep.dir\n\n# v15 2015/10/14\n\n* Update .travis.yml file to do releases to github\n\n# v14 2015/10/08\n\n* Don't print out a workspace path when GO15VENDOREXPERIMENT is active. The vendor/ directory is not a valid workspace, so can't be added to your $GOPATH.\n\n# v13 2015/10/07\n\n* Do restores in 2 separate steps, first download all deps and then check out the recorded revisions.\n* Update Changelog date format\n\n# v12 2015/09/22\n\n* Extract errors into separate file.\n\n# v11 2015/08/22\n\n* Amend code to pass golint.\n\n# v10 2015/09/21\n\n* Analyse vendored package test dependencies.\n* Update documentation.\n\n# v9 2015/09/17\n\n* Don't save test dependencies by default.\n\n# v8 2015/09/17\n\n* Reorganize code.\n\n# v7 2015/09/09\n\n* Add verbose flag.\n* Skip untracked files.\n* Add VCS list command.\n\n# v6 2015/09/04\n\n*  Revert ignoring testdata directories and instead ignore it while\nprocessing Go files and copy the whole directory unmodified.\n\n# v5 2015/09/04\n\n* Fix vcs selection in restore command to work as go get does\n\n# v4 2015/09/03\n\n* Remove the deprecated copy option.\n\n# v3 2015/08/26\n\n* Ignore testdata directories\n\n# v2 2015/08/11\n\n* Include command line packages in the set to copy\n\nThis is a simplification to how we define the behavior\nof the save command. Now it has two distinct package\nparameters, the \"root set\" and the \"destination\", and\nthey have clearer roles. The packages listed on the\ncommand line form the root set; they and all their\ndependencies will be copied into the Godeps directory.\nAdditionally, the destination (always \".\") will form the\ninitial list of \"seen\" import paths to exclude from\ncopying.\n\nIn the common case, the root set is equal to the\ndestination, so the effective behavior doesn't change.\nThis is primarily just a simpler definition. However, if\nthe user specifies a package on the command line that\nlives outside of . then that package will be copied.\n\nAs a side effect, there's a simplification to the way we\nadd packages to the initial \"seen\" set. Formerly, to\navoid copying dependencies unnecessarily, we would try\nto find the root of the VCS repo for each package in the\nroot set, and mark the import path of the entire repo as\nseen. This meant for a repo at path C, if destination\nC/S imports C/T, we would not copy C/T into C/S/Godeps.\nNow we don't treat the repo root specially, and as\nmentioned above, the destination alone is considered\nseen.\n\nThis also means we don't require listed packages to be\nin VCS unless they're outside of the destination.\n\n# v1 2015/07/20\n\n* godep version command\n\nOutput the version as well as some godep runtime information that is\nuseful for debugging user's issues.\n\nThe version const would be bumped each time a PR is merged into master\nto ensure that we'll be able to tell which version someone got when they\ndid a `go get github.com/tools/godep`.\n\n# Older changes\n\nMany and more, see `git log -p`\n"
        },
        {
          "name": "FAQ.md",
          "type": "blob",
          "size": 1.162109375,
          "content": "## Why do I need to check in `vendor/`?\n\ngodep's primary concern is to allow you to repeatably build your project. Your\ndependencies are part of that project. Without them it won't build. Not\ncommitting `vendor/` adds additional external dependencies that are outside of\nyour control. In Go, fetching packages is tied to multiple external systems\n(DNS, web servers, etc). Over time other developers or code hosting sites may\ndiscontinue service, delete code, force push, or take any number of other\nactions that may make a package unreachable. Therefore it's the opinion of the\ngodep authors that `vendor/` should always be checked in.\n\n## Should I use `godep restore`?\n\nProbably not, unless you **need** to. Situations where you would **need** to are:\n\n1. Using older Godep Workspaces (`Godeps/_workspace`) and not using `godep go\n   <cmd>`.\n1. Resetting the state of $GOPATH to what is in your `Godeps.json` file in order\n   to cleanly re-vendor everything w/o upgrading/changing any deps. This is\n   useful when [migrating](https://github.com/tools/godep#migrating-to-vendor)\n   from workspaces to `vendor` or when a bug is fixed in `godep` that cleans up\n   a previous vendoring error.\n"
        },
        {
          "name": "Godeps",
          "type": "tree",
          "content": null
        },
        {
          "name": "License",
          "type": "blob",
          "size": 1.484375,
          "content": "Copyright © 2013 Keith Rarick.\nPortions Copyright (c) 2012 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Readme.md",
          "type": "blob",
          "size": 6.8232421875,
          "content": "# Godep - Archived\n\nPlease use [dep](https://github.com/golang/dep) or another tool instead.\n\nThe rest of this readme is preserved for those that may still need its contents.\n\n[![Build Status](https://travis-ci.org/tools/godep.svg)](https://travis-ci.org/tools/godep)\n\n[![GoDoc](https://godoc.org/github.com/tools/godep?status.svg)](https://godoc.org/github.com/tools/godep)\n\ngodep helps build packages reproducibly by fixing their dependencies.\n\nThis tool assumes you are working in a standard Go workspace, as described [here](http://golang.org/doc/code.html). We\nexpect godep to build on Go 1.4* or newer, but you can use it on any project that works with Go 1 or newer.\n\nPlease check the [FAQ](FAQ.md) if you have a question.\n\n## Golang Dep\n\nThe Go community now has the [dep](https://github.com/golang/dep) project to\nmanage dependencies. Please consider trying to migrate from Godep to dep. If there\nis an issue preventing you from migrating please file an issue with dep so the\nproblem can be corrected. Godep will continue to be supported for some time but\nis considered to be in a state of support rather than active feature development.\n\n## Install\n\n```console\ngo get github.com/tools/godep\n```\n\n## How to use godep with a new project\n\nAssuming you've got everything working already, so you can build your project\nwith `go install` and test it with `go test`, it's one command to start using:\n\n```console\ngodep save\n```\n\nThis will save a list of dependencies to the file `Godeps/Godeps.json` and copy\ntheir source code into `vendor/` (or `Godeps/_workspace/` when using older\nversions of Go). Godep does **not copy**:\n\n- files from source repositories that are not tracked in version control.\n- `*_test.go` files.\n- `testdata` directories.\n- files outside of the go packages.\n\nGodep does not process the imports of `.go` files with either the `ignore`\nor `appengine` build tags.\n\nTest files and testdata directories can be saved by adding `-t`.\n\nRead over the contents of `vendor/` and make sure it looks reasonable. Then\ncommit the `Godeps/` and `vendor/` directories to version control.\n\n## The deprecated `-r` flag\n\nFor older versions of Go, the `-r` flag tells save to automatically rewrite\npackage import paths. This allows your code to refer directly to the copied\ndependencies in `Godeps/_workspace`. So, a package C that depends on package\nD will actually import `C/Godeps/_workspace/src/D`. This makes C's repo\nself-contained and causes `go get` to build C with the right version of all\ndependencies.\n\nIf you don't use `-r`, when using older version of Go, then in order to use the\nfixed dependencies and get reproducible builds, you must make sure that **every\ntime** you run a Go-related command, you wrap it in one of these two ways:\n\n- If the command you are running is just `go`, run it as `godep go ...`, e.g.\n  `godep go install -v ./...`\n- When using a different command, set your `$GOPATH` using `godep path` as\n  described below.\n\n`-r` isn't necessary with go1.6+ and isn't allowed.\n\n## Additional Operations\n\n### Restore\n\nThe `godep restore` installs the\npackage versions specified in `Godeps/Godeps.json` to your `$GOPATH`. This\nmodifies the state of packages in your `$GOPATH`. NOTE: `godep restore` leaves\ngit repositories in a detached state. `go1.6`+ no longer checks out the master\nbranch when doing a `go get`, see [here](https://github.com/golang/go/commit/42206598671a44111c8f726ad33dc7b265bdf669).\n\n> If you run `godep restore` in your main `$GOPATH` `go get -u` will fail on packages that are behind master.\n\nPlease see the [FAQ](https://github.com/tools/godep/blob/master/FAQ.md#should-i-use-godep-restore) section about restore.\n\n### Edit-test Cycle\n\n1. Edit code\n1. Run `godep go test`\n1. (repeat)\n\n### Add a Dependency\n\nTo add a new package foo/bar, do this:\n\n1. Run `go get foo/bar`\n1. Edit your code to import foo/bar.\n1. Run `godep save` (or `godep save ./...`).\n\n### Update a Dependency\n\nTo update a package from your `$GOPATH`, do this:\n\n1. Run `go get -u foo/bar`\n1. Run `godep update foo/bar`.\n\nYou can use the `...` wildcard, for example `godep update foo/...`. Before comitting the change, you'll probably want to\ninspect the changes to Godeps, for example with `git diff`, and make sure it looks reasonable.\n\n## Multiple Packages\n\nIf your repository has more than one package, you're probably accustomed to\nrunning commands like `go test ./...`, `go install ./...`, and `go fmt ./...`.\nSimilarly, you should run `godep save ./...` to capture the dependencies of all\npackages in your application.\n\n## File Format\n\nGodeps is a json file with the following structure:\n\n```go\ntype Godeps struct {\n  ImportPath   string\n  GoVersion    string   // Abridged output of 'go version'.\n  GodepVersion string   // Abridged output of 'godep version'\n  Packages     []string // Arguments to godep save, if any.\n  Deps         []struct {\n    ImportPath string\n    Comment    string // Description of commit, if present.\n    Rev        string // VCS-specific commit ID.\n  }\n}\n```\n\nExample Godeps:\n\n```json\n{\n  \"ImportPath\": \"github.com/kr/hk\",\n  \"GoVersion\": \"go1.6\",\n  \"Deps\": [\n    {\n      \"ImportPath\": \"code.google.com/p/go-netrc/netrc\",\n      \"Rev\": \"28676070ab99\"\n    },\n    {\n      \"ImportPath\": \"github.com/kr/binarydist\",\n      \"Rev\": \"3380ade90f8b0dfa3e363fd7d7e941fa857d0d13\"\n    }\n  ]\n}\n```\n\n## Migrating to vendor/\n\nGodep supports the Go 1.5+ vendor/\n[experiment](https://github.com/golang/go/commit/183cc0cd41f06f83cb7a2490a499e3f9101befff)\nutilizing the same environment variable that the go tooling itself supports\n(`GO15VENDOREXPERIMENT`).\n\ngodep mostly works the same way as the `go` command line tool. If you have go\n1.5.X and set `GO15VENDOREXPERIMENT=1` or have go1.6.X (or devel) `vendor/`\nis enabled. **Unless** you already have a `Godeps/_workspace`. This is a safety\nfeature and godep warns you about this.\n\nWhen `vendor/` is enabled godep will write the vendored code into the top level\n`./vendor/` directory. A `./Godeps/Godeps.json` file is created to track\nthe dependencies and revisions. `vendor/` is not compatible with rewrites.\n\nThere is currently no automated migration between the old Godeps workspace and\nthe vendor directory, but the following steps should work:\n\n```term\n# just to be safe\n$ unset GO15VENDOREXPERIMENT\n\n# restore currently vendored deps to the $GOPATH\n$ godep restore\n\n# The next line is only needed to automatically undo rewritten imports that were\n# created with godep save -r.\n$ godep save -r=false <pkg spec>\n\n# Remove the old Godeps folder\n$ rm -rf Godeps\n\n# If on go1.5.X to enable `vendor/`\n$ export GO15VENDOREXPERIMENT=1\n\n# re-analyze deps and save to `vendor/`.\n$ godep save <pkg spec>\n\n# Add the changes to your VCS\n$ git add -A . ; git commit -am \"Godep workspace -> vendor/\"\n\n# You should see your Godeps/_workspace/src files \"moved\" to vendor/.\n```\n\n## Releasing\n\n1. Increment the version in `version.go`.\n1. Tag the commit with the same version number.\n1. Update `Changelog.md`.\n"
        },
        {
          "name": "dep.go",
          "type": "blob",
          "size": 2.7939453125,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// A Dependency is a specific revision of a package.\ntype Dependency struct {\n\tImportPath string\n\tComment    string `json:\",omitempty\"` // Description of commit, if present.\n\tRev        string // VCS-specific commit ID.\n\n\t// used by command save & update\n\tws   string // workspace\n\troot string // import path to repo root\n\tdir  string // full path to package\n\n\t// used by command update\n\tmatched bool // selected for update by command line\n\tpkg     *Package\n\tmissing bool // packages is missing\n\n\t// used by command go\n\tvcs *VCS\n}\n\nfunc eqDeps(a, b []Dependency) bool {\n\tok := true\n\tfor _, da := range a {\n\t\tfor _, db := range b {\n\t\t\tif da.ImportPath == db.ImportPath && da.Rev != db.Rev {\n\t\t\t\tok = false\n\t\t\t}\n\t\t}\n\t}\n\treturn ok\n}\n\n// containsPathPrefix returns whether any string in a\n// is s or a directory containing s.\n// For example, pattern [\"a\"] matches \"a\" and \"a/b\"\n// (but not \"ab\").\nfunc containsPathPrefix(pats []string, s string) bool {\n\tfor _, pat := range pats {\n\t\tif pat == s || strings.HasPrefix(s, pat+\"/\") {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc uniq(a []string) []string {\n\tvar s string\n\tvar i int\n\tif !sort.StringsAreSorted(a) {\n\t\tsort.Strings(a)\n\t}\n\tfor _, t := range a {\n\t\tif t != s {\n\t\t\ta[i] = t\n\t\t\ti++\n\t\t\ts = t\n\t\t}\n\t}\n\treturn a[:i]\n}\n\n// trimGoVersion and return the major version\nfunc trimGoVersion(version string) (string, error) {\n\tif version == \"devel\" {\n\t\treturn \"devel\", nil\n\t}\n\tif strings.HasPrefix(version, \"devel+\") || strings.HasPrefix(version, \"devel-\") {\n\t\treturn strings.Replace(version, \"devel+\", \"devel-\", 1), nil\n\t}\n\tp := strings.Split(version, \".\")\n\tif len(p) < 2 {\n\t\treturn \"\", fmt.Errorf(\"Error determining major go version from: %q\", version)\n\t}\n\tvar split string\n\tswitch {\n\tcase strings.Contains(p[1], \"beta\"):\n\t\tsplit = \"beta\"\n\tcase strings.Contains(p[1], \"rc\"):\n\t\tsplit = \"rc\"\n\t}\n\tif split != \"\" {\n\t\tp[1] = strings.Split(p[1], split)[0]\n\t}\n\treturn p[0] + \".\" + p[1], nil\n}\n\nvar goVersionTestOutput = \"\"\n\nfunc getGoVersion() (string, error) {\n\t// For testing purposes only\n\tif goVersionTestOutput != \"\" {\n\t\treturn goVersionTestOutput, nil\n\t}\n\n\t// Godep might have been compiled with a different\n\t// version, so we can't just use runtime.Version here.\n\tcmd := exec.Command(\"go\", \"version\")\n\tcmd.Stderr = os.Stderr\n\tout, err := cmd.Output()\n\treturn string(out), err\n}\n\n// goVersion returns the major version string of the Go compiler\n// currently installed, e.g. \"go1.5\".\nfunc goVersion() (string, error) {\n\tout, err := getGoVersion()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tgv := strings.Split(out, \" \")\n\tif len(gv) < 4 {\n\t\treturn \"\", fmt.Errorf(\"Error splitting output of `go version`: Expected 4 or more elements, but there are < 4: %q\", out)\n\t}\n\tif gv[2] == \"devel\" {\n\t\treturn trimGoVersion(gv[2] + gv[3])\n\t}\n\treturn trimGoVersion(gv[2])\n}\n"
        },
        {
          "name": "dep_test.go",
          "type": "blob",
          "size": 1.3935546875,
          "content": "package main\n\nimport \"testing\"\n\nfunc TestTrimGoVersion(t *testing.T) {\n\tvar cases = []struct {\n\t\tin, out string\n\t\terr     bool\n\t}{\n\t\t{in: \"go1.5\", out: \"go1.5\", err: false},\n\t\t{in: \"go1.5beta1\", out: \"go1.5\", err: false},\n\t\t{in: \"go1.6rc1\", out: \"go1.6\", err: false},\n\t\t{in: \"go1.5.1\", out: \"go1.5\", err: false},\n\t\t{in: \"devel\", out: \"devel\", err: false},\n\t\t{in: \"devel+15f7a66\", out: \"devel-15f7a66\", err: false},\n\t\t{in: \"devel-15f7a66\", out: \"devel-15f7a66\", err: false},\n\t\t{in: \"boom\", out: \"\", err: true},\n\t}\n\n\tfor _, c := range cases {\n\t\tmv, err := trimGoVersion(c.in)\n\t\tif err != nil && !c.err {\n\t\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\t}\n\t\tif mv != c.out {\n\t\t\tt.Errorf(\"Expected trimGoVersion(%s) == '%s', but got '%s'\", c.in, c.out, mv)\n\t\t}\n\t}\n}\n\nfunc TestGoVersion(t *testing.T) {\n\tvar cases = []struct {\n\t\to, r string\n\t\terr  bool\n\t}{\n\t\t{o: \"go version go1.6.2 darwin/amd64\", r: \"go1.6\", err: false},\n\t\t{o: \"go version go1.6 darwin/amd64\", r: \"go1.6\", err: false},\n\t\t{o: \"go version go1.6.2 linux/amd64\", r: \"go1.6\", err: false},\n\t\t{o: \"go version devel +da6205b Wed Apr 13 17:22:38 2016 +0000 darwin/amd64\", r: \"devel-da6205b\", err: false},\n\t}\n\n\tfor _, c := range cases {\n\t\tgoVersionTestOutput = c.o\n\t\tv, err := goVersion()\n\t\tif err != nil && !c.err {\n\t\t\tt.Errorf(\"Unexpected error: %s\", err)\n\t\t}\n\t\tif v != c.r {\n\t\t\tt.Errorf(\"Expected goVersion() == '%s', but got '%s'\", c.r, v)\n\t\t}\n\t\tgoVersionTestOutput = \"\"\n\t}\n}\n"
        },
        {
          "name": "diff.go",
          "type": "blob",
          "size": 1.353515625,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/pmezard/go-difflib/difflib\"\n)\n\nvar cmdDiff = &Command{\n\tName:  \"diff\",\n\tShort: \"shows the diff between current and previously saved set of dependencies\",\n\tLong: `\nShows the difference, in a unified diff format, between the\ncurrent set of dependencies and those generated on a\nprevious 'go save' execution.\n`,\n\tRun:          runDiff,\n\tOnlyInGOPATH: true,\n}\n\nfunc runDiff(cmd *Command, args []string) {\n\tgold, err := loadDefaultGodepsFile()\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tpkgs := []string{\".\"}\n\tdot, err := LoadPackages(pkgs...)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tgnew := &Godeps{\n\t\tImportPath: dot[0].ImportPath,\n\t\tGoVersion:  gold.GoVersion,\n\t}\n\n\terr = gnew.fill(dot, dot[0].ImportPath)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tdiff, err := diffStr(&gold, gnew)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tfmt.Println(diff)\n}\n\n// diffStr returns a unified diff string of two Godeps.\nfunc diffStr(a, b *Godeps) (string, error) {\n\tvar ab, bb bytes.Buffer\n\n\t_, err := a.writeTo(&ab)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\t_, err = b.writeTo(&bb)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\tdiff := difflib.UnifiedDiff{\n\t\tA:        difflib.SplitLines(ab.String()),\n\t\tB:        difflib.SplitLines(bb.String()),\n\t\tFromFile: b.file(),\n\t\tToFile:   \"$GOPATH\",\n\t\tContext:  10,\n\t}\n\treturn difflib.GetUnifiedDiffString(diff)\n}\n"
        },
        {
          "name": "diff_test.go",
          "type": "blob",
          "size": 2.1796875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\nvar (\n\td1 = fmt.Sprintf(`--- Godeps/Godeps.json\n+++ $GOPATH\n@@ -1,13 +1,13 @@\n {\n        \"ImportPath\": \"C\",\n        \"GoVersion\": \"go1.2\",\n        \"GodepVersion\": \"v%d\",\n        \"Deps\": [\n                {\n                        \"ImportPath\": \"D101\",\n-                       \"Comment\": \"D202\",\n+                       \"Comment\": \"D303\",\n                        \"Rev\": \"\"\n                }\n        ]\n }\n`, version)\n\n\td2 = fmt.Sprintf(`--- Godeps/Godeps.json\n+++ $GOPATH\n@@ -1,13 +1,18 @@\n {\n        \"ImportPath\": \"C\",\n        \"GoVersion\": \"go1.2\",\n        \"GodepVersion\": \"v%d\",\n        \"Deps\": [\n                {\n                        \"ImportPath\": \"D101\",\n                        \"Comment\": \"D202\",\n                        \"Rev\": \"\"\n+               },\n+               {\n+                       \"ImportPath\": \"D102\",\n+                       \"Comment\": \"D203\",\n+                       \"Rev\": \"\"\n                }\n        ]\n }\n`, version)\n)\n\nvar (\n\tdep1 = Godeps{\n\t\tImportPath: \"C\",\n\t\tGoVersion:  \"go1.2\",\n\t\tDeps: []Dependency{\n\t\t\t{ImportPath: \"D101\", Comment: \"D202\"},\n\t\t},\n\t}\n\n\tdep2 = Godeps{\n\t\tImportPath: \"C\",\n\t\tGoVersion:  \"go1.2\",\n\t\tDeps: []Dependency{\n\t\t\t{ImportPath: \"D101\", Comment: \"D202\"},\n\t\t},\n\t}\n)\n\nfunc TestDiff(t *testing.T) {\n\t// Equiv Godeps, should yield an empty diff.\n\tdiff, _ := diffStr(&dep1, &dep2)\n\tif diff != \"\" {\n\t\tt.Errorf(\"Diff is %v want ''\", diff)\n\t}\n\n\t// Test modifications in packages make it to the diff.\n\tdep2.Deps[0].Comment = \"D303\"\n\tdiff, _ = diffStr(&dep1, &dep2)\n\tif !diffsEqual(strings.Fields(diff), strings.Fields(d1)) {\n\t\tt.Errorf(\"Expecting diffs to be equal. Obs <%s>. Exp <%s>\", diff, d1)\n\t}\n\n\t// Test additional packages in new Godeps\n\tdep2.Deps[0].Comment = \"D202\"\n\tdep2.Deps = append(dep2.Deps, Dependency{ImportPath: \"D102\", Comment: \"D203\"})\n\tdiff, _ = diffStr(&dep1, &dep2)\n\n\tif !diffsEqual(strings.Fields(diff), strings.Fields(d2)) {\n\t\tt.Errorf(\"Expecting diffs to be equal. Obs <%v>. Exp <%v>\", diff, d2)\n\t}\n}\n\n// diffsEqual asserts that two slices are equivalent.\nfunc diffsEqual(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.2841796875,
          "content": "/*\n\nCommand godep helps build packages reproducibly by fixing\ntheir dependencies.\n\nExample Usage\n\nSave currently-used dependencies to file Godeps:\n\n\t$ godep save\n\nBuild project using saved dependencies:\n\n\t$ godep go install\n\nor\n\n\t$ GOPATH=`godep path`:$GOPATH\n\t$ go install\n\n*/\npackage main\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 0.44140625,
          "content": "package main\n\nimport \"errors\"\n\nvar (\n\terrorLoadingDeps         = errors.New(\"error loading dependencies\")\n\terrorLoadingPackages     = errors.New(\"error loading packages\")\n\terrorCopyingSourceCode   = errors.New(\"error copying source code\")\n\terrorNoPackagesUpdatable = errors.New(\"no packages can be updated\")\n)\n\ntype errPackageNotFound struct {\n\tpath string\n}\n\nfunc (e errPackageNotFound) Error() string {\n\treturn \"Package (\" + e.path + \") not found\"\n}\n"
        },
        {
          "name": "get.go",
          "type": "blob",
          "size": 2.0126953125,
          "content": "package main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nvar cmdGet = &Command{\n\tName:  \"get\",\n\tArgs:  \"[-t] [packages]\",\n\tShort: \"download and install packages with specified dependencies\",\n\tLong: `\nGet downloads to GOPATH the packages named by the import paths, and installs\nthem with the dependencies specified in their Godeps files.\n\nIf any of the packages do not have Godeps files, those are installed\nas if by go get.\n\nIf -t is given, dependencies of test files are also downloaded and installed.\n\nFor more about specifying packages, see 'go help packages'.\n`,\n\tRun:          runGet,\n\tOnlyInGOPATH: true,\n}\n\nvar getT bool\n\nfunc init() {\n\tcmdGet.Flag.BoolVar(&getT, \"t\", false, \"get test dependencies\")\n}\n\nfunc runGet(cmd *Command, args []string) {\n\tif len(args) == 0 {\n\t\targs = []string{\".\"}\n\t}\n\n\tcmdArgs := []interface{}{\"get\", \"-d\"}\n\tif verbose {\n\t\tcmdArgs = append(cmdArgs, \"-v\")\n\t}\n\n\tif getT {\n\t\tcmdArgs = append(cmdArgs, \"-t\")\n\t}\n\n\terr := command(\"go\", append(cmdArgs, args)...).Run()\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\t// group import paths by Godeps location\n\tgroups := make(map[string][]string)\n\tps, err := LoadPackages(args...)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tfor _, pkg := range ps {\n\t\tif pkg.Error.Err != \"\" {\n\t\t\tlog.Fatalln(pkg.Error.Err)\n\t\t}\n\t\tdir, _ := findInParents(pkg.Dir, \"Godeps\")\n\t\tgroups[dir] = append(groups[dir], pkg.ImportPath)\n\t}\n\tfor dir, packages := range groups {\n\t\tvar c *exec.Cmd\n\t\tif dir == \"\" {\n\t\t\tc = command(\"go\", \"install\", packages)\n\t\t} else {\n\t\t\tc = command(\"godep\", \"go\", \"install\", packages)\n\t\t\tc.Dir = dir\n\t\t}\n\t\tif err := c.Run(); err != nil {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t}\n}\n\n// command is like exec.Command, but the returned\n// Cmd inherits stderr from the current process, and\n// elements of args may be either string or []string.\nfunc command(name string, args ...interface{}) *exec.Cmd {\n\tvar a []string\n\tfor _, arg := range args {\n\t\tswitch v := arg.(type) {\n\t\tcase string:\n\t\t\ta = append(a, v)\n\t\tcase []string:\n\t\t\ta = append(a, v...)\n\t\t}\n\t}\n\tc := exec.Command(name, a...)\n\tc.Stderr = os.Stderr\n\treturn c\n}\n"
        },
        {
          "name": "go.go",
          "type": "blob",
          "size": 3.1982421875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nvar cmdGo = &Command{\n\tName:  \"go\",\n\tArgs:  \"command [arguments]\",\n\tShort: \"run the go tool with saved dependencies\",\n\tLong: `\nGo runs the go tool with a modified GOPATH giving access to\ndependencies saved in Godeps.\n\nAny go tool command can run this way, but \"godep go get\"\nis unnecessary and has been disabled. Instead, use\n\"godep go install\".\n`,\n\tRun:          runGo,\n\tOnlyInGOPATH: true,\n}\n\n// Find the godep GOPATH for this file tree and run the go tool.\nfunc runGo(cmd *Command, args []string) {\n\tgopath := prepareGopath()\n\tif s := os.Getenv(\"GOPATH\"); s != \"\" {\n\t\tgopath += string(os.PathListSeparator) + os.Getenv(\"GOPATH\")\n\t}\n\tif len(args) > 0 && args[0] == \"get\" {\n\t\tlog.Printf(\"invalid subcommand: %q\", \"go get\")\n\t\tfmt.Fprintln(os.Stderr, \"Use 'godep go install' instead.\")\n\t\tfmt.Fprintln(os.Stderr, \"Run 'godep help go' for usage.\")\n\t\tos.Exit(2)\n\t}\n\tc := exec.Command(\"go\", args...)\n\tc.Env = append(envNoGopath(), \"GOPATH=\"+gopath)\n\tc.Stdin = os.Stdin\n\tc.Stdout = os.Stdout\n\tc.Stderr = os.Stderr\n\terr := c.Run()\n\tif err != nil {\n\t\tlog.Fatalln(\"go\", err)\n\t}\n}\n\n// prepareGopath reads dependency information from the filesystem\n// entry name, fetches any necessary code, and returns a gopath\n// causing the specified dependencies to be used.\nfunc prepareGopath() (gopath string) {\n\tdir, isDir := findGodeps()\n\tif dir == \"\" {\n\t\tlog.Fatalln(\"No Godeps found (or in any parent directory)\")\n\t}\n\tif !isDir {\n\t\tlog.Fatalln(strings.TrimSpace(needSource))\n\t}\n\treturn filepath.Join(dir, \"Godeps\", \"_workspace\")\n}\n\n// findGodeps looks for a directory entry \"Godeps\" in the\n// current directory or any parent, and returns the containing\n// directory and whether the entry itself is a directory.\n// If Godeps can't be found, findGodeps returns \"\".\n// For any other error, it exits the program.\nfunc findGodeps() (dir string, isDir bool) {\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\treturn findInParents(wd, \"Godeps\")\n}\n\n// isRoot returns true iff a path is a root.\n// On Unix: \"/\".\n// On Windows: \"C:\\\", \"D:\\\", ...\nfunc isRoot(p string) bool {\n\tp = filepath.Clean(p)\n\tvolume := filepath.VolumeName(p)\n\n\tp = strings.TrimPrefix(p, volume)\n\tp = filepath.ToSlash(p)\n\n\treturn p == \"/\"\n}\n\n// findInParents returns the path to the directory containing name\n// in dir or any ancestor, and whether name itself is a directory.\n// If name cannot be found, findInParents returns the empty string.\nfunc findInParents(dir, name string) (container string, isDir bool) {\n\tfor {\n\t\tfi, err := os.Stat(filepath.Join(dir, name))\n\t\tif os.IsNotExist(err) && isRoot(dir) {\n\t\t\treturn \"\", false\n\t\t}\n\t\tif os.IsNotExist(err) {\n\t\t\tdir = filepath.Dir(dir)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t\treturn dir, fi.IsDir()\n\t}\n}\n\nfunc envNoGopath() (a []string) {\n\tfor _, s := range os.Environ() {\n\t\tif !strings.HasPrefix(s, \"GOPATH=\") {\n\t\t\ta = append(a, s)\n\t\t}\n\t}\n\treturn a\n}\n\nconst needSource = `\noutdated Godeps missing source code\n\nThis dependency list was created with an old version of godep.\n\nTo work around this, you have two options:\n1. Run 'godep restore', and try again.\n2. Ask the maintainer to switch to a newer version of godep,\nthen try again with the updated package.\n`\n"
        },
        {
          "name": "godepfile.go",
          "type": "blob",
          "size": 4.4765625,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nvar (\n\tgodepsFile    = filepath.Join(\"Godeps\", \"Godeps.json\")\n\toldGodepsFile = filepath.Join(\"Godeps\")\n)\n\n// Godeps describes what a package needs to be rebuilt reproducibly.\n// It's the same information stored in file Godeps.\ntype Godeps struct {\n\tImportPath   string\n\tGoVersion    string\n\tGodepVersion string\n\tPackages     []string `json:\",omitempty\"` // Arguments to save, if any.\n\tDeps         []Dependency\n\tisOldFile    bool\n}\n\nfunc loadGodepsFile(path string) (Godeps, error) {\n\tvar g Godeps\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn g, err\n\t}\n\tdefer f.Close()\n\terr = json.NewDecoder(f).Decode(&g)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"Unable to parse %s: %s\", path, err.Error())\n\t}\n\treturn g, err\n}\n\nfunc loadDefaultGodepsFile() (Godeps, error) {\n\tvar g Godeps\n\tvar err error\n\tg, err = loadGodepsFile(godepsFile)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tvar err1 error\n\t\t\tg, err1 = loadGodepsFile(oldGodepsFile)\n\t\t\tif err1 != nil {\n\t\t\t\tif os.IsNotExist(err1) {\n\t\t\t\t\treturn g, err\n\t\t\t\t}\n\t\t\t\treturn g, err1\n\t\t\t}\n\t\t\tg.isOldFile = true\n\t\t\treturn g, nil\n\t\t}\n\t}\n\treturn g, err\n}\n\n// pkgs is the list of packages to read dependencies for\nfunc (g *Godeps) fill(pkgs []*Package, destImportPath string) error {\n\tdebugln(\"fill\", destImportPath)\n\tppln(pkgs)\n\tvar err1 error\n\tvar path, testImports []string\n\tdipp := []string{destImportPath}\n\tfor _, p := range pkgs {\n\t\tif p.Standard {\n\t\t\tlog.Println(\"ignoring stdlib package:\", p.ImportPath)\n\t\t\tcontinue\n\t\t}\n\t\tif p.Error.Err != \"\" {\n\t\t\tlog.Println(p.Error.Err)\n\t\t\terr1 = errorLoadingPackages\n\t\t\tcontinue\n\t\t}\n\t\tpath = append(path, p.ImportPath)\n\t\tpath = append(path, p.Deps...)\n\t\ttestImports = append(testImports, p.TestImports...)\n\t\ttestImports = append(testImports, p.XTestImports...)\n\t}\n\tps, err := LoadPackages(testImports...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, p := range ps {\n\t\tif p.Standard {\n\t\t\tcontinue\n\t\t}\n\t\tif p.Error.Err != \"\" {\n\t\t\tlog.Println(p.Error.Err)\n\t\t\terr1 = errorLoadingPackages\n\t\t\tcontinue\n\t\t}\n\t\tpath = append(path, p.ImportPath)\n\t\tpath = append(path, p.Deps...)\n\t}\n\tdebugln(\"path\", path)\n\tfor i, p := range path {\n\t\tpath[i] = unqualify(p)\n\t}\n\tpath = uniq(path)\n\tdebugln(\"uniq, unqualify'd path\", path)\n\tps, err = LoadPackages(path...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, pkg := range ps {\n\t\tif pkg.Error.Err != \"\" {\n\t\t\tlog.Println(pkg.Error.Err)\n\t\t\terr1 = errorLoadingDeps\n\t\t\tcontinue\n\t\t}\n\t\tif pkg.Standard || containsPathPrefix(dipp, pkg.ImportPath) {\n\t\t\tdebugln(\"standard or dest skipping\", pkg.ImportPath)\n\t\t\tcontinue\n\t\t}\n\t\tvcs, reporoot, err := VCSFromDir(pkg.Dir, filepath.Join(pkg.Root, \"src\"))\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\terr1 = errorLoadingDeps\n\t\t\tcontinue\n\t\t}\n\t\tid, err := vcs.identify(pkg.Dir)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\terr1 = errorLoadingDeps\n\t\t\tcontinue\n\t\t}\n\t\tif vcs.isDirty(pkg.Dir, id) {\n\t\t\tlog.Println(\"dirty working tree (please commit changes):\", pkg.Dir)\n\t\t\terr1 = errorLoadingDeps\n\t\t\tcontinue\n\t\t}\n\t\tcomment := vcs.describe(pkg.Dir, id)\n\t\tg.Deps = append(g.Deps, Dependency{\n\t\t\tImportPath: pkg.ImportPath,\n\t\t\tRev:        id,\n\t\t\tComment:    comment,\n\t\t\tdir:        pkg.Dir,\n\t\t\tws:         pkg.Root,\n\t\t\troot:       filepath.ToSlash(reporoot),\n\t\t\tvcs:        vcs,\n\t\t})\n\t}\n\treturn err1\n}\n\nfunc (g *Godeps) copy() *Godeps {\n\th := *g\n\th.Deps = make([]Dependency, len(g.Deps))\n\tcopy(h.Deps, g.Deps)\n\treturn &h\n}\n\nfunc (g *Godeps) file() string {\n\tif g.isOldFile {\n\t\treturn oldGodepsFile\n\t}\n\treturn godepsFile\n}\n\nfunc (g *Godeps) save() (int64, error) {\n\tf, err := os.Create(g.file())\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer f.Close()\n\treturn g.writeTo(f)\n}\n\nfunc (g *Godeps) writeTo(w io.Writer) (int64, error) {\n\tg.GodepVersion = fmt.Sprintf(\"v%d\", version) // godep always writes its current version.\n\tb, err := json.MarshalIndent(g, \"\", \"\\t\")\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tn, err := w.Write(append(b, '\\n'))\n\treturn int64(n), err\n}\n\nfunc (g *Godeps) addOrUpdateDeps(deps []Dependency) {\n\tvar missing []Dependency\n\tfor _, d := range deps {\n\t\tvar found bool\n\t\tfor i := range g.Deps {\n\t\t\tif g.Deps[i].ImportPath == d.ImportPath {\n\t\t\t\tg.Deps[i] = d\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tmissing = append(missing, d)\n\t\t}\n\t}\n\tg.Deps = append(g.Deps, missing...)\n}\n\nfunc (g *Godeps) removeDeps(deps []Dependency) {\n\tvar f []Dependency\n\tfor i := range g.Deps {\n\t\tvar found bool\n\t\tfor _, d := range deps {\n\t\t\tif g.Deps[i].ImportPath == d.ImportPath {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tf = append(f, g.Deps[i])\n\t\t}\n\t}\n\tg.Deps = f\n}\n"
        },
        {
          "name": "license.go",
          "type": "blob",
          "size": 1.32421875,
          "content": "package main\n\nimport (\n\t\"strings\"\n)\n\n// LicenseFilePrefix is a list of filename prefixes that indicate it\n//  might contain a software license\nvar LicenseFilePrefix = []string{\n\t\"licence\", // UK spelling\n\t\"license\", // US spelling\n\t\"copying\",\n\t\"unlicense\",\n\t\"copyright\",\n\t\"copyleft\",\n\t\"authors\",\n\t\"contributors\",\n}\n\n// LegalFileSubstring are substrings that indicate the file is likely\n// to contain some type of legal declaration.  \"legal\" is often used\n// that it might moved to LicenseFilePrefix\nvar LegalFileSubstring = []string{\n\t\"legal\",\n\t\"notice\",\n\t\"disclaimer\",\n\t\"patent\",\n\t\"third-party\",\n\t\"thirdparty\",\n}\n\n// IsLicenseFile returns true if the filename might be contain a\n// software license\nfunc IsLicenseFile(filename string) bool {\n\tlowerfile := strings.ToLower(filename)\n\tfor _, prefix := range LicenseFilePrefix {\n\t\tif strings.HasPrefix(lowerfile, prefix) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// IsLegalFile returns true if the file is likely to contain some type\n// of of legal declaration or licensing information\nfunc IsLegalFile(filename string) bool {\n\tlowerfile := strings.ToLower(filename)\n\tfor _, prefix := range LicenseFilePrefix {\n\t\tif strings.HasPrefix(lowerfile, prefix) {\n\t\t\treturn true\n\t\t}\n\t}\n\tfor _, substring := range LegalFileSubstring {\n\t\tif strings.Contains(lowerfile, substring) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "license_test.go",
          "type": "blob",
          "size": 2.318359375,
          "content": "package main\n\nimport (\n\t\"testing\"\n)\n\n// most of these were found via google searches\n//  site:github.com FILENAME\n//\nfunc TestLicenseFiles(t *testing.T) {\n\tvar testcases = []struct {\n\t\tfilename string\n\t\tlicense  bool\n\t\tlegal    bool\n\t}{\n\t\t{\"license\", true, true},\n\t\t{\"License\", true, true},\n\t\t{\"LICENSE.md\", true, true},\n\t\t{\"LICENSE.rst\", true, true},\n\t\t{\"LICENSE.txt\", true, true},\n\t\t{\"licence\", true, true},\n\t\t{\"LICENCE.broadcom\", true, true},\n\t\t{\"LICENCE.md\", true, true},\n\t\t{\"copying\", true, true},\n\t\t{\"COPYING.txt\", true, true},\n\t\t{\"unlicense\", true, true},\n\t\t{\"copyright\", true, true},\n\t\t{\"COPYRIGHT.txt\", true, true},\n\t\t{\"copyleft\", true, true},\n\t\t{\"COPYLEFT.txt\", true, true},\n\t\t{\"copyleft.txt\", true, true},\n\t\t{\"Copyleft.txt\", true, true},\n\t\t{\"copyleft-next-0.2.1.txt\", true, true},\n\t\t{\"legal\", false, true},\n\t\t{\"notice\", false, true},\n\t\t{\"NOTICE\", false, true},\n\t\t{\"disclaimer\", false, true},\n\t\t{\"patent\", false, true},\n\t\t{\"patents\", false, true},\n\t\t{\"third-party\", false, true},\n\t\t{\"thirdparty\", false, true},\n\t\t{\"thirdparty.txt\", false, true},\n\t\t{\"license-ThirdParty.txt\", true, true},\n\t\t{\"LICENSE-ThirdParty.txt\", true, true},\n\t\t{\"THIRDPARTY.md\", false, true},\n\t\t{\"third-party.md\", false, true},\n\t\t{\"THIRD-PARTY.txt\", false, true},\n\t\t{\"extensions-third-party.md\", false, true},\n\t\t{\"ThirdParty.md\", false, true},\n\t\t{\"third-party-licenses.md\", false, true},\n\t\t{\"0070-01-01-third-party.md\", false, true},\n\t\t{\"LEGAL.txt\", false, true},\n\t\t{\"legal.txt\", false, true},\n\t\t{\"Legal.md\", false, true},\n\t\t{\"LEGAL.md\", false, true},\n\t\t{\"legal.rst\", false, true},\n\t\t{\"Legal.rtf\", false, true},\n\t\t{\"legal.rtf\", false, true},\n\t\t{\"PATENTS.TXT\", false, true},\n\t\t{\"ttf-PATENTS.txt\", false, true},\n\t\t{\"patents.txt\", false, true},\n\t\t{\"INRIA-DISCLAIMER.txt\", false, true},\n\n\t\t{\"MPL-2.0-no-copyleft-exception.txt\", false, false},\n\t}\n\n\tfor pos, tt := range testcases {\n\t\tlicense := IsLicenseFile(tt.filename)\n\t\tif tt.license != license {\n\t\t\tif license {\n\t\t\t\tt.Errorf(\"%d/file %q is not marked as license\", pos, tt.filename)\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"%d/file %q was marked incorrectly as a license\", pos, tt.filename)\n\t\t\t}\n\t\t}\n\n\t\tlegal := IsLegalFile(tt.filename)\n\t\tif tt.legal != legal {\n\t\t\tif legal {\n\t\t\t\tt.Errorf(\"%d/File %q is not marked as legal file\", pos, tt.filename)\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"%d/File %q was marked incorrectly as a legal file\", pos, tt.filename)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "list.go",
          "type": "blob",
          "size": 15.90625,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"go/build\"\n\t\"go/parser\"\n\t\"go/token\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode\"\n\n\tpathpkg \"path\"\n)\n\nvar (\n\tgorootSrc            = filepath.Join(build.Default.GOROOT, \"src\")\n\tignoreTags           = []string{\"appengine\", \"ignore\"} //TODO: appengine is a special case for now: https://github.com/tools/godep/issues/353\n\tversionMatch         = regexp.MustCompile(`\\Ago\\d+\\.\\d+\\z`)\n\tversionNegativeMatch = regexp.MustCompile(`\\A\\!go\\d+\\.\\d+\\z`)\n)\n\ntype errorMissingDep struct {\n\ti, dir string // import, dir\n}\n\nfunc (e errorMissingDep) Error() string {\n\treturn \"Unable to find dependent package \" + e.i + \" in context of \" + e.dir\n}\n\n// packageContext is used to track an import and which package imported it.\ntype packageContext struct {\n\tpkg *build.Package // package that imports the import\n\timp string         // import\n}\n\n// depScanner tracks the processed and to be processed packageContexts\ntype depScanner struct {\n\tprocessed []packageContext\n\ttodo      []packageContext\n}\n\n// Next package and import to process\nfunc (ds *depScanner) Next() (*build.Package, string) {\n\tc := ds.todo[0]\n\tds.processed = append(ds.processed, c)\n\tds.todo = ds.todo[1:]\n\treturn c.pkg, c.imp\n}\n\n// Continue looping?\nfunc (ds *depScanner) Continue() bool {\n\treturn len(ds.todo) > 0\n}\n\n// Add a package and imports to the depScanner. Skips already processed/pending package/import combos\nfunc (ds *depScanner) Add(pkg *build.Package, imports ...string) {\nNextImport:\n\tfor _, i := range imports {\n\t\tif i == \"C\" {\n\t\t\ti = \"runtime/cgo\"\n\t\t}\n\t\tfor _, epc := range ds.processed {\n\t\t\tif pkg.Dir == epc.pkg.Dir && i == epc.imp {\n\t\t\t\tdebugln(\"ctxts epc.pkg.Dir == pkg.Dir && i == epc.imp, skipping\", epc.pkg.Dir, i)\n\t\t\t\tcontinue NextImport\n\t\t\t}\n\t\t}\n\t\tfor _, epc := range ds.todo {\n\t\t\tif pkg.Dir == epc.pkg.Dir && i == epc.imp {\n\t\t\t\tdebugln(\"ctxts epc.pkg.Dir == pkg.Dir && i == epc.imp, skipping\", epc.pkg.Dir, i)\n\t\t\t\tcontinue NextImport\n\t\t\t}\n\t\t}\n\t\tpc := packageContext{pkg, i}\n\t\tdebugln(\"Adding pc:\", pc.pkg.Dir, pc.imp)\n\t\tds.todo = append(ds.todo, pc)\n\t}\n}\n\nvar (\n\tpkgCache = make(map[string]*build.Package) // dir => *build.Package\n)\n\n// returns the package in dir either from a cache or by importing it and then caching it\nfunc fullPackageInDir(dir string) (*build.Package, error) {\n\tvar err error\n\tpkg, ok := pkgCache[dir]\n\tif !ok {\n\t\tpkg, _ = build.ImportDir(dir, build.FindOnly)\n\t\tif pkg.Goroot {\n\t\t\tpkg, err = build.ImportDir(pkg.Dir, 0)\n\t\t} else {\n\t\t\terr = fillPackage(pkg)\n\t\t}\n\t\tif err == nil {\n\t\t\tpkgCache[dir] = pkg\n\t\t}\n\t}\n\treturn pkg, err\n}\n\n// listPackage specified by path\nfunc listPackage(path string) (*Package, error) {\n\tdebugln(\"listPackage\", path)\n\tvar lp *build.Package\n\tdir, err := findDirForPath(path, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlp, err = fullPackageInDir(dir)\n\tp := &Package{\n\t\tDir:            lp.Dir,\n\t\tRoot:           lp.Root,\n\t\tImportPath:     lp.ImportPath,\n\t\tXTestImports:   lp.XTestImports,\n\t\tTestImports:    lp.TestImports,\n\t\tGoFiles:        lp.GoFiles,\n\t\tCgoFiles:       lp.CgoFiles,\n\t\tTestGoFiles:    lp.TestGoFiles,\n\t\tXTestGoFiles:   lp.XTestGoFiles,\n\t\tIgnoredGoFiles: lp.IgnoredGoFiles,\n\t}\n\tp.Standard = lp.Goroot && lp.ImportPath != \"\" && !strings.Contains(lp.ImportPath, \".\")\n\tif err != nil || p.Standard {\n\t\treturn p, err\n\t}\n\tdebugln(\"Looking For Package:\", path, \"in\", dir)\n\tppln(lp)\n\n\tds := depScanner{}\n\tds.Add(lp, lp.Imports...)\n\tfor ds.Continue() {\n\t\tip, i := ds.Next()\n\n\t\tdebugf(\"Processing import %s for %s\\n\", i, ip.Dir)\n\t\tpdir, err := findDirForPath(i, ip)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdp, err := fullPackageInDir(pdir)\n\t\tif err != nil { // This really should happen in this context though\n\t\t\tppln(err)\n\t\t\treturn nil, errorMissingDep{i: i, dir: ip.Dir}\n\t\t}\n\t\tppln(dp)\n\t\tif !dp.Goroot {\n\t\t\t// Don't bother adding packages in GOROOT to the dependency scanner, they don't import things from outside of it.\n\t\t\tds.Add(dp, dp.Imports...)\n\t\t}\n\t\tdebugln(\"lp:\")\n\t\tppln(lp)\n\t\tdebugln(\"ip:\")\n\t\tppln(ip)\n\t\tif lp == ip {\n\t\t\tdebugln(\"lp == ip\")\n\t\t\tp.Imports = append(p.Imports, dp.ImportPath)\n\t\t}\n\t\tp.Deps = append(p.Deps, dp.ImportPath)\n\t\tp.Dependencies = addDependency(p.Dependencies, dp)\n\t}\n\tp.Imports = uniq(p.Imports)\n\tp.Deps = uniq(p.Deps)\n\tdebugln(\"Done Looking For Package:\", path, \"in\", dir)\n\tppln(p)\n\treturn p, nil\n}\n\nfunc addDependency(deps []build.Package, d *build.Package) []build.Package {\n\tfor i := range deps {\n\t\tif deps[i].Dir == d.Dir {\n\t\t\treturn deps\n\t\t}\n\t}\n\treturn append(deps, *d)\n}\n\n// finds the directory for the given import path in the context of the provided build.Package (if provided)\nfunc findDirForPath(path string, ip *build.Package) (string, error) {\n\tdebugln(\"findDirForPath\", path, ip)\n\tvar search []string\n\n\tif build.IsLocalImport(path) {\n\t\tdir := path\n\t\tif !filepath.IsAbs(dir) {\n\t\t\tif abs, err := filepath.Abs(dir); err == nil {\n\t\t\t\t// interpret relative to current directory\n\t\t\t\tdir = abs\n\t\t\t}\n\t\t}\n\t\treturn dir, nil\n\t}\n\n\t// We need to check to see if the import exists in vendor/ folders up the hierarchy of the importing package\n\tif VendorExperiment && ip != nil {\n\t\tdebugln(\"resolving vendor posibilities:\", ip.Dir, ip.Root)\n\t\tcr := cleanPath(ip.Root)\n\n\t\tfor base := cleanPath(ip.Dir); !pathEqual(base, cr); base = cleanPath(filepath.Dir(base)) {\n\t\t\ts := filepath.Join(base, \"vendor\", path)\n\t\t\tdebugln(\"Adding search dir:\", s)\n\t\t\tsearch = append(search, s)\n\t\t}\n\t}\n\n\tfor _, base := range build.Default.SrcDirs() {\n\t\tsearch = append(search, filepath.Join(base, path))\n\t}\n\n\tfor _, dir := range search {\n\t\tdebugln(\"searching\", dir)\n\t\tfi, err := stat(dir)\n\t\tif err == nil && fi.IsDir() {\n\t\t\treturn dir, nil\n\t\t}\n\t}\n\n\treturn \"\", errPackageNotFound{path}\n}\n\ntype statEntry struct {\n\tfi  os.FileInfo\n\terr error\n}\n\nvar (\n\tstatCache = make(map[string]statEntry)\n)\n\nfunc clearStatCache() {\n\tstatCache = make(map[string]statEntry)\n}\n\nfunc stat(p string) (os.FileInfo, error) {\n\tif e, ok := statCache[p]; ok {\n\t\treturn e.fi, e.err\n\t}\n\tfi, err := os.Stat(p)\n\tstatCache[p] = statEntry{fi, err}\n\treturn fi, err\n}\n\n// fillPackage full of info. Assumes p.Dir is set at a minimum\nfunc fillPackage(p *build.Package) error {\n\tif p.Goroot {\n\t\treturn nil\n\t}\n\n\tif p.SrcRoot == \"\" {\n\t\tfor _, base := range build.Default.SrcDirs() {\n\t\t\tif strings.HasPrefix(p.Dir, base) {\n\t\t\t\tp.SrcRoot = base\n\t\t\t}\n\t\t}\n\t}\n\n\tif p.SrcRoot == \"\" {\n\t\treturn errors.New(\"Unable to find SrcRoot for package \" + p.ImportPath)\n\t}\n\n\tif p.Root == \"\" {\n\t\tp.Root = filepath.Dir(p.SrcRoot)\n\t}\n\n\tvar buildMatch = \"+build \"\n\tvar buildFieldSplit = func(r rune) bool {\n\t\treturn unicode.IsSpace(r) || r == ','\n\t}\n\n\tdebugln(\"Filling package:\", p.ImportPath, \"from\", p.Dir)\n\tgofiles, err := filepath.Glob(filepath.Join(p.Dir, \"*.go\"))\n\tif err != nil {\n\t\tdebugln(\"Error globbing\", err)\n\t\treturn err\n\t}\n\n\tif len(gofiles) == 0 {\n\t\treturn &build.NoGoError{Dir: p.Dir}\n\t}\n\n\tvar testImports []string\n\tvar imports []string\nNextFile:\n\tfor _, file := range gofiles {\n\t\tdebugln(file)\n\t\tpf, err := parser.ParseFile(token.NewFileSet(), file, nil, parser.ImportsOnly|parser.ParseComments)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestFile := strings.HasSuffix(file, \"_test.go\")\n\t\tfname := filepath.Base(file)\n\t\tfor _, c := range pf.Comments {\n\t\t\tct := c.Text()\n\t\t\tif i := strings.Index(ct, buildMatch); i != -1 {\n\t\t\t\tfor _, t := range strings.FieldsFunc(ct[i+len(buildMatch):], buildFieldSplit) {\n\t\t\t\t\tfor _, tag := range ignoreTags {\n\t\t\t\t\t\tif t == tag {\n\t\t\t\t\t\t\tp.IgnoredGoFiles = append(p.IgnoredGoFiles, fname)\n\t\t\t\t\t\t\tcontinue NextFile\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif versionMatch.MatchString(t) && !isSameOrNewer(t, majorGoVersion) {\n\t\t\t\t\t\tdebugln(\"Adding\", fname, \"to ignored list because of version tag\", t)\n\t\t\t\t\t\tp.IgnoredGoFiles = append(p.IgnoredGoFiles, fname)\n\t\t\t\t\t\tcontinue NextFile\n\t\t\t\t\t}\n\t\t\t\t\tif versionNegativeMatch.MatchString(t) && isSameOrNewer(t[1:], majorGoVersion) {\n\t\t\t\t\t\tdebugln(\"Adding\", fname, \"to ignored list because of version tag\", t)\n\t\t\t\t\t\tp.IgnoredGoFiles = append(p.IgnoredGoFiles, fname)\n\t\t\t\t\t\tcontinue NextFile\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif testFile {\n\t\t\tp.TestGoFiles = append(p.TestGoFiles, fname)\n\t\t} else {\n\t\t\tp.GoFiles = append(p.GoFiles, fname)\n\t\t}\n\t\tfor _, is := range pf.Imports {\n\t\t\tname, err := strconv.Unquote(is.Path.Value)\n\t\t\tif err != nil {\n\t\t\t\treturn err // can't happen?\n\t\t\t}\n\t\t\tif testFile {\n\t\t\t\ttestImports = append(testImports, name)\n\t\t\t} else {\n\t\t\t\timports = append(imports, name)\n\t\t\t}\n\t\t}\n\t}\n\timports = uniq(imports)\n\ttestImports = uniq(testImports)\n\tp.Imports = imports\n\tp.TestImports = testImports\n\treturn nil\n}\n\n// All of the following functions were vendored from go proper. Locations are noted in comments, but may change in future Go versions.\n\n// importPaths returns the import paths to use for the given command line.\n// $GOROOT/src/cmd/main.go:366\nfunc importPaths(args []string) []string {\n\tdebugf(\"importPathsNoDotExpansion(%q) == \", args)\n\targs = importPathsNoDotExpansion(args)\n\tdebugf(\"%q\\n\", args)\n\tvar out []string\n\tfor _, a := range args {\n\t\tif strings.Contains(a, \"...\") {\n\t\t\tif build.IsLocalImport(a) {\n\t\t\t\tdebugf(\"build.IsLocalImport(%q) == true\\n\", a)\n\t\t\t\tpkgs := allPackagesInFS(a)\n\t\t\t\tdebugf(\"allPackagesInFS(%q) == %q\\n\", a, pkgs)\n\t\t\t\tout = append(out, pkgs...)\n\t\t\t} else {\n\t\t\t\tdebugf(\"build.IsLocalImport(%q) == false\\n\", a)\n\t\t\t\tpkgs := allPackages(a)\n\t\t\t\tdebugf(\"allPackages(%q) == %q\\n\", a, pkgs)\n\t\t\t\tout = append(out, allPackages(a)...)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tout = append(out, a)\n\t}\n\treturn out\n}\n\n// importPathsNoDotExpansion returns the import paths to use for the given\n// command line, but it does no ... expansion.\n// $GOROOT/src/cmd/main.go:332\nfunc importPathsNoDotExpansion(args []string) []string {\n\tif len(args) == 0 {\n\t\treturn []string{\".\"}\n\t}\n\tvar out []string\n\tfor _, a := range args {\n\t\t// Arguments are supposed to be import paths, but\n\t\t// as a courtesy to Windows developers, rewrite \\ to /\n\t\t// in command-line arguments.  Handles .\\... and so on.\n\t\tif filepath.Separator == '\\\\' {\n\t\t\ta = strings.Replace(a, `\\`, `/`, -1)\n\t\t}\n\n\t\t// Put argument in canonical form, but preserve leading ./.\n\t\tif strings.HasPrefix(a, \"./\") {\n\t\t\ta = \"./\" + pathpkg.Clean(a)\n\t\t\tif a == \"./.\" {\n\t\t\t\ta = \".\"\n\t\t\t}\n\t\t} else {\n\t\t\ta = pathpkg.Clean(a)\n\t\t}\n\t\tif a == \"all\" || a == \"std\" || a == \"cmd\" {\n\t\t\tout = append(out, allPackages(a)...)\n\t\t\tcontinue\n\t\t}\n\t\tout = append(out, a)\n\t}\n\treturn out\n}\n\n// allPackagesInFS is like allPackages but is passed a pattern\n// beginning ./ or ../, meaning it should scan the tree rooted\n// at the given directory.  There are ... in the pattern too.\n// $GOROOT/src/cmd/main.go:620\nfunc allPackagesInFS(pattern string) []string {\n\tpkgs := matchPackagesInFS(pattern)\n\tif len(pkgs) == 0 {\n\t\tfmt.Fprintf(os.Stderr, \"warning: %q matched no packages\\n\", pattern)\n\t}\n\treturn pkgs\n}\n\n// allPackages returns all the packages that can be found\n// under the $GOPATH directories and $GOROOT matching pattern.\n// The pattern is either \"all\" (all packages), \"std\" (standard packages),\n// \"cmd\" (standard commands), or a path including \"...\".\n// $GOROOT/src/cmd/main.go:542\nfunc allPackages(pattern string) []string {\n\tpkgs := matchPackages(pattern)\n\tif len(pkgs) == 0 {\n\t\tfmt.Fprintf(os.Stderr, \"warning: %q matched no packages\\n\", pattern)\n\t}\n\treturn pkgs\n}\n\n// $GOROOT/src/cmd/main.go:554\n// This has been changed to not use build.ImportDir\nfunc matchPackages(pattern string) []string {\n\tmatch := func(string) bool { return true }\n\ttreeCanMatch := func(string) bool { return true }\n\tif pattern != \"all\" && pattern != \"std\" && pattern != \"cmd\" {\n\t\tmatch = matchPattern(pattern)\n\t\ttreeCanMatch = treeCanMatchPattern(pattern)\n\t}\n\n\thave := map[string]bool{\n\t\t\"builtin\": true, // ignore pseudo-package that exists only for documentation\n\t}\n\tif !build.Default.CgoEnabled {\n\t\thave[\"runtime/cgo\"] = true // ignore during walk\n\t}\n\tvar pkgs []string\n\n\tfor _, src := range build.Default.SrcDirs() {\n\t\tif (pattern == \"std\" || pattern == \"cmd\") && src != gorootSrc {\n\t\t\tcontinue\n\t\t}\n\t\tsrc = filepath.Clean(src) + string(filepath.Separator)\n\t\troot := src\n\t\tif pattern == \"cmd\" {\n\t\t\troot += \"cmd\" + string(filepath.Separator)\n\t\t}\n\t\tfilepath.Walk(root, func(path string, fi os.FileInfo, err error) error {\n\t\t\tif err != nil || !fi.IsDir() || path == src {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Avoid .foo, _foo, and testdata directory trees.\n\t\t\t_, elem := filepath.Split(path)\n\t\t\tif strings.HasPrefix(elem, \".\") || strings.HasPrefix(elem, \"_\") || elem == \"testdata\" {\n\t\t\t\treturn filepath.SkipDir\n\t\t\t}\n\n\t\t\tname := filepath.ToSlash(path[len(src):])\n\t\t\tif pattern == \"std\" && (strings.Contains(name, \".\") || name == \"cmd\") {\n\t\t\t\t// The name \"std\" is only the standard library.\n\t\t\t\t// If the name has a dot, assume it's a domain name for go get,\n\t\t\t\t// and if the name is cmd, it's the root of the command tree.\n\t\t\t\treturn filepath.SkipDir\n\t\t\t}\n\t\t\tif !treeCanMatch(name) {\n\t\t\t\treturn filepath.SkipDir\n\t\t\t}\n\t\t\tif have[name] {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\thave[name] = true\n\t\t\tif !match(name) {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tap, err := filepath.Abs(path)\n\t\t\tif err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif _, err = fullPackageInDir(ap); err != nil {\n\t\t\t\tdebugf(\"matchPackage(%q) ap=%q Error: %q\\n\", ap, pattern, err)\n\t\t\t\tif _, noGo := err.(*build.NoGoError); noGo {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\tpkgs = append(pkgs, name)\n\t\t\treturn nil\n\t\t})\n\t}\n\treturn pkgs\n}\n\n// treeCanMatchPattern(pattern)(name) reports whether\n// name or children of name can possibly match pattern.\n// Pattern is the same limited glob accepted by matchPattern.\n// $GOROOT/src/cmd/main.go:527\nfunc treeCanMatchPattern(pattern string) func(name string) bool {\n\twildCard := false\n\tif i := strings.Index(pattern, \"...\"); i >= 0 {\n\t\twildCard = true\n\t\tpattern = pattern[:i]\n\t}\n\treturn func(name string) bool {\n\t\treturn len(name) <= len(pattern) && hasPathPrefix(pattern, name) ||\n\t\t\twildCard && strings.HasPrefix(name, pattern)\n\t}\n}\n\n// hasPathPrefix reports whether the path s begins with the\n// elements in prefix.\n// $GOROOT/src/cmd/main.go:489\nfunc hasPathPrefix(s, prefix string) bool {\n\tswitch {\n\tdefault:\n\t\treturn false\n\tcase len(s) == len(prefix):\n\t\treturn s == prefix\n\tcase len(s) > len(prefix):\n\t\tif prefix != \"\" && prefix[len(prefix)-1] == '/' {\n\t\t\treturn strings.HasPrefix(s, prefix)\n\t\t}\n\t\treturn s[len(prefix)] == '/' && s[:len(prefix)] == prefix\n\t}\n}\n\n// $GOROOT/src/cmd/go/main.go:631\n// This has been changed to not use build.ImportDir\nfunc matchPackagesInFS(pattern string) []string {\n\t// Find directory to begin the scan.\n\t// Could be smarter but this one optimization\n\t// is enough for now, since ... is usually at the\n\t// end of a path.\n\ti := strings.Index(pattern, \"...\")\n\tdir, _ := pathpkg.Split(pattern[:i])\n\n\t// pattern begins with ./ or ../.\n\t// path.Clean will discard the ./ but not the ../.\n\t// We need to preserve the ./ for pattern matching\n\t// and in the returned import paths.\n\tprefix := \"\"\n\tif strings.HasPrefix(pattern, \"./\") {\n\t\tprefix = \"./\"\n\t}\n\tmatch := matchPattern(pattern)\n\n\tvar pkgs []string\n\tfilepath.Walk(dir, func(path string, fi os.FileInfo, err error) error {\n\t\tif err != nil || !fi.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tif path == dir {\n\t\t\t// filepath.Walk starts at dir and recurses. For the recursive case,\n\t\t\t// the path is the result of filepath.Join, which calls filepath.Clean.\n\t\t\t// The initial case is not Cleaned, though, so we do this explicitly.\n\t\t\t//\n\t\t\t// This converts a path like \"./io/\" to \"io\". Without this step, running\n\t\t\t// \"cd $GOROOT/src; go list ./io/...\" would incorrectly skip the io\n\t\t\t// package, because prepending the prefix \"./\" to the unclean path would\n\t\t\t// result in \"././io\", and match(\"././io\") returns false.\n\t\t\tpath = filepath.Clean(path)\n\t\t}\n\n\t\t// Avoid .foo, _foo, and testdata directory trees, but do not avoid \".\" or \"..\".\n\t\t_, elem := filepath.Split(path)\n\t\tdot := strings.HasPrefix(elem, \".\") && elem != \".\" && elem != \"..\"\n\t\tif dot || strings.HasPrefix(elem, \"_\") || elem == \"testdata\" {\n\t\t\treturn filepath.SkipDir\n\t\t}\n\n\t\tname := prefix + filepath.ToSlash(path)\n\t\tif !match(name) {\n\t\t\treturn nil\n\t\t}\n\t\tap, err := filepath.Abs(path)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tif _, err = fullPackageInDir(ap); err != nil {\n\t\t\tdebugf(\"matchPackageInFS(%q) ap=%q Error: %q\\n\", ap, pattern, err)\n\t\t\tif _, noGo := err.(*build.NoGoError); !noGo {\n\t\t\t\tlog.Print(err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tpkgs = append(pkgs, name)\n\t\treturn nil\n\t})\n\treturn pkgs\n}\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 5.828125,
          "content": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"go/build\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime/pprof\"\n\t\"strings\"\n\t\"text/template\"\n)\n\nvar (\n\tcpuprofile       string\n\tverbose          bool // Verbose flag for commands that support it\n\tdebug            bool // Debug flag for commands that support it\n\tmajorGoVersion   string\n\tVendorExperiment bool\n\tsep              string\n)\n\n// Command is an implementation of a godep command\n// like godep save or godep go.\ntype Command struct {\n\t// Run runs the command.\n\t// The args are the arguments after the command name.\n\tRun func(cmd *Command, args []string)\n\n\t// Name of the command\n\tName string\n\n\t// Args the command would expect\n\tArgs string\n\n\t// Short is the short description shown in the 'godep help' output.\n\tShort string\n\n\t// Long is the long message shown in the\n\t// 'godep help <this-command>' output.\n\tLong string\n\n\t// Flag is a set of flags specific to this command.\n\tFlag flag.FlagSet\n\n\t// OnlyInGOPATH limits this command to being run only while inside of a GOPATH\n\tOnlyInGOPATH bool\n}\n\n// UsageExit prints usage information and exits.\nfunc (c *Command) UsageExit() {\n\tfmt.Fprintf(os.Stderr, \"Args: godep %s [-v] [-d] %s\\n\\n\", c.Name, c.Args)\n\tfmt.Fprintf(os.Stderr, \"Run 'godep help %s' for help.\\n\", c.Name)\n\tos.Exit(2)\n}\n\n// Commands lists the available commands and help topics.\n// The order here is the order in which they are printed\n// by 'godep help'.\nvar commands = []*Command{\n\tcmdSave,\n\tcmdGo,\n\tcmdGet,\n\tcmdPath,\n\tcmdRestore,\n\tcmdUpdate,\n\tcmdDiff,\n\tcmdVersion,\n}\n\n// VendorExperiment is the Go 1.5 vendor directory experiment flag, see\n// https://github.com/golang/go/commit/183cc0cd41f06f83cb7a2490a499e3f9101befff\n// Honor the env var unless the project already has an old school godep workspace\nfunc determineVendor(v string) bool {\n\tgo15ve := os.Getenv(\"GO15VENDOREXPERIMENT\")\n\tvar ev bool\n\tswitch v {\n\tcase \"go1\", \"go1.1\", \"go1.2\", \"go1.3\", \"go1.4\":\n\t\tev = false\n\tcase \"go1.5\":\n\t\tev = go15ve == \"1\"\n\tcase \"go1.6\":\n\t\tev = go15ve != \"0\"\n\tdefault: //go1.7+, devel*\n\t\tev = true\n\t}\n\n\tws := filepath.Join(\"Godeps\", \"_workspace\")\n\ts, err := os.Stat(ws)\n\tif err == nil && s.IsDir() {\n\t\tlog.Printf(\"WARNING: Godep workspaces (./Godeps/_workspace) are deprecated and support for them will be removed when go1.8 is released.\")\n\t\tif ev {\n\t\t\tlog.Printf(\"WARNING: Go version (%s) & $GO15VENDOREXPERIMENT=%s wants to enable the vendor experiment, but disabling because a Godep workspace (%s) exists\\n\", v, go15ve, ws)\n\t\t}\n\t\treturn false\n\t}\n\n\treturn ev\n}\n\nfunc main() {\n\tlog.SetFlags(0)\n\tlog.SetPrefix(\"godep: \")\n\tlog.SetOutput(os.Stderr)\n\n\tflag.Usage = usageExit\n\tflag.Parse()\n\targs := flag.Args()\n\tif len(args) < 1 {\n\t\tusageExit()\n\t}\n\n\tif args[0] == \"help\" {\n\t\thelp(args[1:])\n\t\treturn\n\t}\n\n\tvar err error\n\tmajorGoVersion, err = goVersion()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor _, cmd := range commands {\n\t\tif cmd.Name == args[0] {\n\t\t\tif cmd.OnlyInGOPATH {\n\t\t\t\tcheckInGOPATH()\n\t\t\t}\n\n\t\t\tVendorExperiment = determineVendor(majorGoVersion)\n\t\t\t// sep is the signature set of path elements that\n\t\t\t// precede the original path of an imported package.\n\t\t\tsep = defaultSep(VendorExperiment)\n\n\t\t\tcmd.Flag.BoolVar(&verbose, \"v\", false, \"enable verbose output\")\n\t\t\tcmd.Flag.BoolVar(&debug, \"d\", false, \"enable debug output\")\n\t\t\tcmd.Flag.StringVar(&cpuprofile, \"cpuprofile\", \"\", \"Write cpu profile to this file\")\n\t\t\tcmd.Flag.Usage = func() { cmd.UsageExit() }\n\t\t\tcmd.Flag.Parse(args[1:])\n\n\t\t\tdebugln(\"versionString()\", versionString())\n\t\t\tdebugln(\"majorGoVersion\", majorGoVersion)\n\t\t\tdebugln(\"VendorExperiment\", VendorExperiment)\n\t\t\tdebugln(\"sep\", sep)\n\n\t\t\tif cpuprofile != \"\" {\n\t\t\t\tf, err := os.Create(cpuprofile)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t\tpprof.StartCPUProfile(f)\n\t\t\t\tdefer pprof.StopCPUProfile()\n\t\t\t}\n\t\t\tcmd.Run(cmd, cmd.Flag.Args())\n\t\t\treturn\n\t\t}\n\t}\n\n\tfmt.Fprintf(os.Stderr, \"godep: unknown command %q\\n\", args[0])\n\tfmt.Fprintf(os.Stderr, \"Run 'godep help' for usage.\\n\")\n\tos.Exit(2)\n}\n\nfunc subPath(sub, path string) bool {\n\tls := strings.ToLower(sub)\n\tlp := strings.ToLower(path)\n\tif ls == lp {\n\t\treturn false\n\t}\n\treturn strings.HasPrefix(ls, lp)\n}\n\nfunc checkInGOPATH() {\n\tpwd, err := os.Getwd()\n\tif err != nil {\n\t\tlog.Fatal(\"Unable to determine current working directory\", err)\n\t}\n\tdirs := build.Default.SrcDirs()\n\tfor _, p := range dirs {\n\t\tif ok := subPath(pwd, p); ok {\n\t\t\treturn\n\t\t}\n\t}\n\n\tlog.Println(\"[WARNING]: godep should only be used inside a valid go package directory and\")\n\tlog.Println(\"[WARNING]: may not function correctly. You are probably outside of your $GOPATH.\")\n\tlog.Printf(\"[WARNING]:\\tCurrent Directory: %s\\n\", pwd)\n\tlog.Printf(\"[WARNING]:\\t$GOPATH: %s\\n\", os.Getenv(\"GOPATH\"))\n}\n\nvar usageTemplate = `\nGodep is a tool for managing Go package dependencies.\n\nUsage:\n\n\tgodep command [arguments]\n\nThe commands are:\n{{range .}}\n    {{.Name | printf \"%-8s\"}} {{.Short}}{{end}}\n\nUse \"godep help [command]\" for more information about a command.\n`\n\nvar helpTemplate = `\nArgs: godep {{.Name}} [-v] [-d] {{.Args}}\n\n{{.Long | trim}}\n\nIf -v is given, verbose output is enabled.\n\nIf -d is given, debug output is enabled (you probably don't want this, see -v).\n\n`\n\nfunc help(args []string) {\n\tif len(args) == 0 {\n\t\tprintUsage(os.Stdout)\n\t\treturn\n\t}\n\tif len(args) != 1 {\n\t\tfmt.Fprintf(os.Stderr, \"usage: godep help command\\n\\n\")\n\t\tfmt.Fprintf(os.Stderr, \"Too many arguments given.\\n\")\n\t\tos.Exit(2)\n\t}\n\tfor _, cmd := range commands {\n\t\tif cmd.Name == args[0] {\n\t\t\ttmpl(os.Stdout, helpTemplate, cmd)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc usageExit() {\n\tprintUsage(os.Stderr)\n\tos.Exit(2)\n}\n\nfunc printUsage(w io.Writer) {\n\ttmpl(w, usageTemplate, commands)\n}\n\n// tmpl executes the given template text on data, writing the result to w.\nfunc tmpl(w io.Writer, text string, data interface{}) {\n\tt := template.New(\"top\")\n\tt.Funcs(template.FuncMap{\n\t\t\"trim\": strings.TrimSpace,\n\t})\n\ttemplate.Must(t.Parse(strings.TrimSpace(text) + \"\\n\\n\"))\n\tif err := t.Execute(w, data); err != nil {\n\t\tpanic(err)\n\t}\n}\n"
        },
        {
          "name": "match_test.go",
          "type": "blob",
          "size": 3.708984375,
          "content": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\nfunc TestMatchPattern(t *testing.T) {\n\t// Test cases from $GOROOT/src/cmd/go/match_test.go.\n\tcases := []struct {\n\t\tpat  string\n\t\tpath string\n\t\twant bool\n\t}{\n\t\t{\"...\", \"foo\", true},\n\t\t{\"net\", \"net\", true},\n\t\t{\"net\", \"net/http\", false},\n\t\t{\"net/http\", \"net\", false},\n\t\t{\"net/http\", \"net/http\", true},\n\t\t{\"net...\", \"netchan\", true},\n\t\t{\"net...\", \"net\", true},\n\t\t{\"net...\", \"net/http\", true},\n\t\t{\"net...\", \"not/http\", false},\n\t\t{\"net/...\", \"netchan\", false},\n\t\t{\"net/...\", \"net\", true},\n\t\t{\"net/...\", \"net/http\", true},\n\t\t{\"net/...\", \"not/http\", false},\n\t}\n\tfor _, test := range cases {\n\t\tok := matchPattern(test.pat)(test.path)\n\t\tif ok != test.want {\n\t\t\tt.Errorf(\"matchPackages(%q)(%q) = %v want %v\", test.pat, test.path, ok, test.want)\n\t\t}\n\t}\n}\n\nfunc TestSubPath(t *testing.T) {\n\tcases := []struct {\n\t\tsub  string\n\t\tdir  string\n\t\twant bool\n\t}{\n\t\t//Basic\n\t\t{`/Users/emuller/go/src/github.com/tools/godep`, `/Users/emuller/go`, true},\n\t\t//Case insensitive filesystem used in dir\n\t\t{`/Users/emuller/go/src/github.com/tools/godep`, `/Users/Emuller/go`, true},\n\t\t{`/Users/emuller/go/Src/github.com/tools/godep`, `/Users/Emuller/go`, true},\n\t\t//spaces\n\t\t{`/Users/e muller/go/Src/github.com/tools/godep`, `/Users/E muller/go`, true},\n\t\t// ()\n\t\t{`/Users/e muller/(Personal)/go/Src/github.com/tools/godep`, `/Users/E muller/(Personal)/go`, true},\n\t\t//Not even close, but same length\n\t\t{`/foo`, `/bar`, false},\n\t\t// Same, so not sub path (same path)\n\t\t{`/foo`, `/foo`, false},\n\t\t// Windows with different cases\n\t\t{`c:\\foo\\bar`, `C:\\foo`, true},\n\t}\n\n\tfor _, test := range cases {\n\t\tok := subPath(test.sub, test.dir)\n\t\tif ok != test.want {\n\t\t\tt.Errorf(\"subdir(%s,%s) = %v want %v\", test.sub, test.dir, ok, test.want)\n\t\t}\n\t}\n}\n\nfunc TestIsSameOrNewer(t *testing.T) {\n\tcases := []struct {\n\t\tbase  string\n\t\tcheck string\n\t\twant  bool\n\t}{\n\t\t{`go1.6`, `go1.6`, true},\n\t\t{`go1.5`, `go1.6`, true},\n\t\t{`go1.7`, `go1.6`, false},\n\t\t{`go1.6`, `devel-8f48efb`, true}, // devel versions are always never\n\t}\n\n\tfor _, test := range cases {\n\t\tok := isSameOrNewer(test.base, test.check)\n\t\tif ok != test.want {\n\t\t\tt.Errorf(\"isSameOrNewer(%s,%s) = %v want %v\", test.base, test.check, ok, test.want)\n\t\t}\n\t}\n}\n\nfunc TestDetermineVersion(t *testing.T) {\n\tcases := []struct {\n\t\tv         string\n\t\tgo15ve    string\n\t\tvendorDir []string\n\t\twant      bool\n\t}{\n\t\t{\"go1.5\", \"\", nil, false},\n\t\t{\"go1.5\", \"1\", nil, true},\n\t\t{\"go1.5\", \"1\", []string{\"Godeps\", \"_workspace\"}, false},\n\t\t{\"go1.5\", \"0\", nil, false},\n\t\t{\"go1.6\", \"\", nil, true},\n\t\t{\"go1.6\", \"1\", nil, true},\n\t\t{\"go1.6\", \"1\", []string{\"Godeps\", \"_workspace\"}, false},\n\t\t{\"go1.6\", \"0\", nil, false},\n\t\t{\"devel\", \"\", nil, true},\n\t\t{\"devel-12345\", \"\", nil, true},\n\t\t{\"devel\", \"1\", nil, true},\n\t\t{\"devel-12345\", \"1\", nil, true},\n\t\t{\"devel\", \"1\", []string{\"Godeps\", \"_workspace\"}, false},\n\t\t{\"devel-12345\", \"1\", []string{\"Godeps\", \"_workspace\"}, false},\n\t\t{\"devel\", \"0\", nil, true},\n\t\t{\"devel-12345\", \"0\", nil, true},\n\t}\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\tos.Chdir(wd)\n\t}()\n\n\tove := os.Getenv(\"GO15VENDOREXPERIMENT\")\n\tdefer func() {\n\t\tos.Setenv(\"GO15VENDOREXPERIMENT\", ove)\n\t}()\n\n\tfor i, test := range cases {\n\t\tos.Setenv(\"GO15VENDOREXPERIMENT\", test.go15ve)\n\t\ttdir, err := ioutil.TempDir(\"\", \"godeptest\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer os.RemoveAll(tdir)\n\t\tos.Chdir(tdir)\n\n\t\tif len(test.vendorDir) > 0 {\n\t\t\tmd := tdir\n\t\t\tfor _, vd := range test.vendorDir {\n\t\t\t\tmd = filepath.Join(md, vd)\n\t\t\t\tif err := os.Mkdir(md, os.ModePerm); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif e := determineVendor(test.v); e != test.want {\n\t\t\tt.Errorf(\"%d GO15VENDOREXPERIMENT=%s determineVendor(%s) == %t, but wanted %t\\n\", i, test.go15ve, test.v, e, test.want)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "msg.go",
          "type": "blob",
          "size": 0.466796875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/kr/pretty\"\n)\n\nfunc debugln(a ...interface{}) (int, error) {\n\tif debug {\n\t\treturn fmt.Println(a...)\n\t}\n\treturn 0, nil\n}\n\nfunc verboseln(a ...interface{}) {\n\tif verbose {\n\t\tlog.Println(a...)\n\t}\n}\n\nfunc debugf(format string, a ...interface{}) (int, error) {\n\tif debug {\n\t\treturn fmt.Printf(format, a...)\n\t}\n\treturn 0, nil\n}\n\nfunc ppln(a ...interface{}) (int, error) {\n\tif debug {\n\t\treturn pretty.Println(a...)\n\t}\n\treturn 0, nil\n}\n"
        },
        {
          "name": "path.go",
          "type": "blob",
          "size": 0.7763671875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nvar cmdPath = &Command{\n\tName:  \"path\",\n\tShort: \"print GOPATH for dependency code\",\n\tLong: `\nCommand path prints a path for use in env var GOPATH\nthat makes available the specified version of each dependency.\n\nThe printed path does not include any GOPATH value from\nthe environment.\n\nFor more about how GOPATH works, see 'go help gopath'.\n`,\n\tRun:          runPath,\n\tOnlyInGOPATH: true,\n}\n\n// Print the gopath that points to\n// the included dependency code.\nfunc runPath(cmd *Command, args []string) {\n\tif len(args) != 0 {\n\t\tcmd.UsageExit()\n\t}\n\tif VendorExperiment {\n\t\tfmt.Fprintln(os.Stderr, \"Error: GO15VENDOREXPERIMENT is enabled and the vendor/ directory is not a valid Go workspace.\")\n\t\tos.Exit(1)\n\t}\n\tgopath := prepareGopath()\n\tfmt.Println(gopath)\n}\n"
        },
        {
          "name": "pkg.go",
          "type": "blob",
          "size": 1.8291015625,
          "content": "package main\n\nimport (\n\t\"go/build\"\n\t\"regexp\"\n\t\"strings\"\n)\n\n// Package represents a Go package.\ntype Package struct {\n\tDir        string\n\tRoot       string\n\tImportPath string\n\tDeps       []string\n\tStandard   bool\n\tProcessed  bool\n\n\tGoFiles        []string\n\tCgoFiles       []string\n\tIgnoredGoFiles []string\n\n\tTestGoFiles  []string\n\tTestImports  []string\n\tXTestGoFiles []string\n\tXTestImports []string\n\n\tError struct {\n\t\tErr string\n\t}\n\n\t// --- New stuff for now\n\tImports      []string\n\tDependencies []build.Package\n}\n\n// LoadPackages loads the named packages\n// Unlike the go tool, an empty argument list is treated as an empty list; \".\"\n// must be given explicitly if desired.\n// IgnoredGoFiles will be processed and their dependencies resolved recursively\nfunc LoadPackages(names ...string) (a []*Package, err error) {\n\tdebugln(\"LoadPackages\", names)\n\tif len(names) == 0 {\n\t\treturn nil, nil\n\t}\n\tfor _, i := range importPaths(names) {\n\t\tp, err := listPackage(i)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta = append(a, p)\n\t}\n\treturn a, nil\n}\n\nfunc (p *Package) allGoFiles() []string {\n\tvar a []string\n\ta = append(a, p.GoFiles...)\n\ta = append(a, p.CgoFiles...)\n\ta = append(a, p.TestGoFiles...)\n\ta = append(a, p.XTestGoFiles...)\n\ta = append(a, p.IgnoredGoFiles...)\n\treturn a\n}\n\n// matchPattern(pattern)(name) reports whether\n// name matches pattern.  Pattern is a limited glob\n// pattern in which '...' means 'any string' and there\n// is no other special syntax.\n// Taken from $GOROOT/src/cmd/go/main.go.\nfunc matchPattern(pattern string) func(name string) bool {\n\tre := regexp.QuoteMeta(pattern)\n\tre = strings.Replace(re, `\\.\\.\\.`, `.*`, -1)\n\t// Special case: foo/... matches foo too.\n\tif strings.HasSuffix(re, `/.*`) {\n\t\tre = re[:len(re)-len(`/.*`)] + `(/.*)?`\n\t}\n\treg := regexp.MustCompile(`^` + re + `$`)\n\treturn func(name string) bool {\n\t\treturn reg.MatchString(name)\n\t}\n}\n"
        },
        {
          "name": "restore.go",
          "type": "blob",
          "size": 4.837890625,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"go/build\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"golang.org/x/tools/go/vcs\"\n)\n\nvar cmdRestore = &Command{\n\tName:  \"restore\",\n\tShort: \"check out listed dependency versions in GOPATH\",\n\tLong: `\nRestore checks out the Godeps-specified version of each package in GOPATH.\n\nNOTE: restore leaves git repositories in a detached state. go1.6+ no longer\nchecks out the master branch when doing a \"go get\", see:\nhttps://github.com/golang/go/commit/42206598671a44111c8f726ad33dc7b265bdf669.\n\n`,\n\tRun:          runRestore,\n\tOnlyInGOPATH: true,\n}\n\n// Three phases:\n// 1. Download all deps\n// 2. Restore all deps (checkout the recorded rev)\n// 3. Attempt to load all deps as a simple consistency check\nfunc runRestore(cmd *Command, args []string) {\n\tif len(build.Default.GOPATH) == 0 {\n\t\tlog.Println(\"Error restore requires GOPATH but it is empty.\")\n\t\tos.Exit(1)\n\t}\n\n\tvar hadError bool\n\tcheckErr := func(s string) {\n\t\tif hadError {\n\t\t\tlog.Println(s)\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n\n\tg, err := loadDefaultGodepsFile()\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tfor i, dep := range g.Deps {\n\t\tverboseln(\"Downloading dependency (if needed):\", dep.ImportPath)\n\t\terr := download(&dep)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error downloading dep (%s): %s\\n\", dep.ImportPath, err)\n\t\t\thadError = true\n\t\t}\n\t\tg.Deps[i] = dep\n\t}\n\tcheckErr(\"Error downloading some deps. Aborting restore and check.\")\n\tfor _, dep := range g.Deps {\n\t\tverboseln(\"Restoring dependency (if needed):\", dep.ImportPath)\n\t\terr := restore(dep)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error restoring dep (%s): %s\\n\", dep.ImportPath, err)\n\t\t\thadError = true\n\t\t}\n\t}\n\tcheckErr(\"Error restoring some deps. Aborting check.\")\n\tfor _, dep := range g.Deps {\n\t\tverboseln(\"Checking dependency:\", dep.ImportPath)\n\t\t_, err := LoadPackages(dep.ImportPath)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Dep (%s) restored, but was unable to load it with error:\\n\\t%s\\n\", dep.ImportPath, err)\n\t\t\tif me, ok := err.(errorMissingDep); ok {\n\t\t\t\tlog.Println(\"\\tThis may be because the dependencies were saved with an older version of godep (< v33).\")\n\t\t\t\tlog.Printf(\"\\tTry `go get %s`. Then `godep save` to update deps.\\n\", me.i)\n\t\t\t}\n\t\t\thadError = true\n\t\t}\n\t}\n\tcheckErr(\"Error checking some deps.\")\n}\n\nvar downloaded = make(map[string]bool)\n\n// download the given dependency.\n// 2 Passes: 1) go get -d <pkg>, 2) git pull (if necessary)\nfunc download(dep *Dependency) error {\n\n\trr, err := vcs.RepoRootForImportPath(dep.ImportPath, debug)\n\tif err != nil {\n\t\tdebugln(\"Error determining repo root for\", dep.ImportPath)\n\t\treturn err\n\t}\n\tppln(\"rr\", rr)\n\n\tdep.vcs = cmd[rr.VCS]\n\n\t// try to find an existing directory in the GOPATHs\n\tfor _, gp := range filepath.SplitList(build.Default.GOPATH) {\n\t\tt := filepath.Join(gp, \"src\", rr.Root)\n\t\tfi, err := os.Stat(t)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif fi.IsDir() {\n\t\t\tdep.root = t\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// If none found, just pick the first GOPATH entry (AFAICT that's what go get does)\n\tif dep.root == \"\" {\n\t\tdep.root = filepath.Join(filepath.SplitList(build.Default.GOPATH)[0], \"src\", rr.Root)\n\t}\n\tppln(\"dep\", dep)\n\n\tif downloaded[rr.Repo] {\n\t\tverboseln(\"Skipping already downloaded repo\", rr.Repo)\n\t\treturn nil\n\t}\n\n\tfi, err := os.Stat(dep.root)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tif err := os.MkdirAll(filepath.Dir(dep.root), os.ModePerm); err != nil {\n\t\t\t\tdebugln(\"Error creating base dir of\", dep.root)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\terr := rr.VCS.CreateAtRev(dep.root, rr.Repo, dep.Rev)\n\t\t\tdebugln(\"CreatedAtRev\", dep.root, rr.Repo, dep.Rev)\n\t\t\tif err != nil {\n\t\t\t\tdebugln(\"CreateAtRev error\", err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdownloaded[rr.Repo] = true\n\t\t\treturn nil\n\t\t}\n\t\tdebugln(\"Error checking repo root for\", dep.ImportPath, \"at\", dep.root, \":\", err)\n\t\treturn err\n\t}\n\n\tif !fi.IsDir() {\n\t\treturn errors.New(\"repo root src dir exists, but isn't a directory for \" + dep.ImportPath + \" at \" + dep.root)\n\t}\n\n\tif !dep.vcs.exists(dep.root, dep.Rev) {\n\t\tdebugln(\"Updating existing\", dep.root)\n\t\tif dep.vcs == vcsGit {\n\t\t\tdetached, err := gitDetached(dep.root)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif detached {\n\t\t\t\tdb, err := gitDefaultBranch(dep.root)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif err := gitCheckout(dep.root, db); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdep.vcs.vcs.Download(dep.root)\n\t\tdownloaded[rr.Repo] = true\n\t}\n\n\tdebugln(\"Nothing to download\")\n\treturn nil\n}\n\nvar restored = make(map[string]string) // dep.root -> dep.Rev\n\n// restore checks out the given revision.\nfunc restore(dep Dependency) error {\n\trev, ok := restored[dep.root]\n\tdebugln(rev)\n\tdebugln(ok)\n\tdebugln(dep.root)\n\tif ok {\n\t\tif rev != dep.Rev {\n\t\t\treturn errors.New(\"Wanted to restore rev \" + dep.Rev + \", already restored rev \" + rev + \" for another package in the repo\")\n\t\t}\n\t\tverboseln(\"Skipping already restored repo\")\n\t\treturn nil\n\t}\n\n\tdebugln(\"Restoring:\", dep.ImportPath, dep.Rev)\n\terr := dep.vcs.RevSync(dep.root, dep.Rev)\n\tif err == nil {\n\t\trestored[dep.root] = dep.Rev\n\t}\n\treturn err\n}\n"
        },
        {
          "name": "rewrite.go",
          "type": "blob",
          "size": 4.109375,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"go/ast\"\n\t\"go/parser\"\n\t\"go/printer\"\n\t\"go/token\"\n\n\t\"github.com/kr/fs\"\n)\n\n// rewrite visits the go files in pkgs, plus all go files\n// in the directory tree Godeps, rewriting import statements\n// according to the rules for func qualify.\nfunc rewrite(pkgs []*Package, qual string, paths []string) error {\n\tfor _, path := range pkgFiles(pkgs) {\n\t\tdebugln(\"rewrite\", path)\n\t\terr := rewriteTree(path, qual, paths)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn rewriteTree(\"Godeps\", qual, paths)\n}\n\n// pkgFiles returns the full filesystem path to all go files in pkgs.\nfunc pkgFiles(pkgs []*Package) []string {\n\tvar a []string\n\tfor _, pkg := range pkgs {\n\t\tfor _, s := range pkg.allGoFiles() {\n\t\t\ta = append(a, filepath.Join(pkg.Dir, s))\n\t\t}\n\t}\n\treturn a\n}\n\n// rewriteTree recursively visits the go files in path, rewriting\n// import statements according to the rules for func qualify.\n// This function ignores the 'testdata' directory.\nfunc rewriteTree(path, qual string, paths []string) error {\n\tw := fs.Walk(path)\n\tfor w.Step() {\n\t\tif w.Err() != nil {\n\t\t\tlog.Println(\"rewrite:\", w.Err())\n\t\t\tcontinue\n\t\t}\n\t\ts := w.Stat()\n\t\tif s.IsDir() && s.Name() == \"testdata\" {\n\t\t\tw.SkipDir()\n\t\t\tcontinue\n\t\t}\n\t\tif strings.HasSuffix(w.Path(), \".go\") {\n\t\t\terr := rewriteGoFile(w.Path(), qual, paths)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// rewriteGoFile rewrites import statements in the named file\n// according to the rules for func qualify.\nfunc rewriteGoFile(name, qual string, paths []string) error {\n\tdebugln(\"rewriteGoFile\", name, \",\", qual, \",\", paths)\n\tprinterConfig := &printer.Config{Mode: printer.TabIndent | printer.UseSpaces, Tabwidth: 8}\n\tfset := token.NewFileSet()\n\tf, err := parser.ParseFile(fset, name, nil, parser.ParseComments)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar changed bool\n\tfor _, s := range f.Imports {\n\t\tname, err := strconv.Unquote(s.Path.Value)\n\t\tif err != nil {\n\t\t\treturn err // can't happen\n\t\t}\n\t\tq := qualify(unqualify(name), qual, paths)\n\t\tif q != name {\n\t\t\ts.Path.Value = strconv.Quote(q)\n\t\t\tchanged = true\n\t\t}\n\t}\n\tif !changed {\n\t\treturn nil\n\t}\n\tvar buffer bytes.Buffer\n\tif err = printerConfig.Fprint(&buffer, fset, f); err != nil {\n\t\treturn err\n\t}\n\tfset = token.NewFileSet()\n\tf, err = parser.ParseFile(fset, name, &buffer, parser.ParseComments)\n\tif err != nil {\n\t\treturn err\n\t}\n\tast.SortImports(fset, f)\n\ttpath := name + \".temp\"\n\tt, err := os.Create(tpath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err = printerConfig.Fprint(t, fset, f); err != nil {\n\t\treturn err\n\t}\n\tif err = t.Close(); err != nil {\n\t\treturn err\n\t}\n\t// This is required before the rename on windows.\n\tif err = os.Remove(name); err != nil {\n\t\treturn err\n\t}\n\treturn os.Rename(tpath, name)\n}\n\nfunc defaultSep(experiment bool) string {\n\tif experiment {\n\t\treturn \"/vendor/\"\n\t}\n\treturn \"/Godeps/_workspace/src/\"\n}\n\nfunc relativeVendorTarget(experiment bool) string {\n\tfull := defaultSep(experiment)\n\tif full[0] == '/' {\n\t\tfull = full[1:]\n\t}\n\treturn filepath.FromSlash(full)\n}\n\n// unqualify returns the part of importPath after the last\n// occurrence of the signature path elements\n// (Godeps/_workspace/src) that always precede imported\n// packages in rewritten import paths.\n//\n// For example,\n//   unqualify(C)                         = C\n//   unqualify(D/Godeps/_workspace/src/C) = C\nfunc unqualify(importPath string) string {\n\tif i := strings.LastIndex(importPath, sep); i != -1 {\n\t\timportPath = importPath[i+len(sep):]\n\t}\n\treturn importPath\n}\n\n// qualify qualifies importPath with its corresponding import\n// path in the Godeps src copy of package pkg. If importPath\n// is a directory lexically contained in a path in paths,\n// it will be qualified with package pkg; otherwise, it will\n// be returned unchanged.\n//\n// For example, given paths {D, T} and pkg C,\n//   importPath  returns\n//   C           C\n//   fmt         fmt\n//   D           C/Godeps/_workspace/src/D\n//   D/P         C/Godeps/_workspace/src/D/P\n//   T           C/Godeps/_workspace/src/T\nfunc qualify(importPath, pkg string, paths []string) string {\n\tif containsPathPrefix(paths, importPath) {\n\t\treturn pkg + sep + importPath\n\t}\n\treturn importPath\n}\n"
        },
        {
          "name": "rewrite_test.go",
          "type": "blob",
          "size": 6.14453125,
          "content": "package main\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\nfunc TestUnqualify(t *testing.T) {\n\tsetGlobals(false)\n\tvar cases = []struct {\n\t\tpath string\n\t\twant string\n\t}{\n\t\t{\"C\", \"C\"},\n\t\t{\"D/Godeps/_workspace/src/T\", \"T\"},\n\t\t{\"C/Godeps/_workspace/src/D/Godeps/_workspace/src/T\", \"T\"},\n\t}\n\tfor _, test := range cases {\n\t\tg := unqualify(test.path)\n\t\tif g != test.want {\n\t\t\tt.Errorf(\"qualify(%s) = %s want %s\", test.path, g, test.want)\n\t\t}\n\t}\n}\n\nfunc TestQualify(t *testing.T) {\n\tvar cases = []struct {\n\t\tpath string\n\t\twant string\n\t}{\n\t\t{\"C\", \"C\"},\n\t\t{\"C/P\", \"C/P\"},\n\t\t{\"fmt\", \"fmt\"},\n\t\t{\"DP\", \"DP\"},\n\t\t{\"D\", \"C/Godeps/_workspace/src/D\"},\n\t\t{\"D/P\", \"C/Godeps/_workspace/src/D/P\"},\n\t}\n\tfor _, test := range cases {\n\t\tg := qualify(test.path, \"C\", []string{\"D\"})\n\t\tif g != test.want {\n\t\t\tt.Errorf(\"qualify({C}, %s) = %s want %s\", test.path, g, test.want)\n\t\t}\n\t}\n}\n\nconst (\n\twhitespace = `package main\n\nimport \"D\"\n\nvar (\n\tx   int\n\tabc int\n)\n`\n\twhitespaceRewritten = `package main\n\nimport \"C/Godeps/_workspace/src/D\"\n\nvar (\n\tx   int\n\tabc int\n)\n`\n\tsortOrder = `package main\n\nimport (\n\t\"E\"\n\t\"C/Godeps/_workspace/src/D\"\n)\n`\n\tsortOrderRewritten = `package main\n\nimport (\n\t\"C/Godeps/_workspace/src/D\"\n\t\"C/Godeps/_workspace/src/E\"\n)\n`\n\tsortOrderPreserveComment = `package main\n\nimport (\n\t\"C/Godeps/_workspace/src/E\" // src E\n\t\"D\" // src D\n)\n`\n\tsortOrderPreserveCommentRewritten = `package main\n\nimport (\n\t\"C/Godeps/_workspace/src/D\" // src D\n\t\"C/Godeps/_workspace/src/E\" // src E\n)\n`\n)\n\nfunc TestRewrite(t *testing.T) {\n\tvar cases = []struct {\n\t\tcwd   string\n\t\tpaths []string\n\t\tstart []*node\n\t\twant  []*node\n\t\twerr  bool\n\t}{\n\t\t{ // simple case, one dependency\n\t\t\tcwd:   \"C\",\n\t\t\tpaths: []string{\"D\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\"), nil},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"C/Godeps/_workspace/src/D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\"), nil},\n\t\t\t},\n\t\t},\n\t\t{ // transitive dep\n\t\t\tcwd:   \"C\",\n\t\t\tpaths: []string{\"D\", \"T\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\", \"T\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/T/main.go\", pkg(\"T\"), nil},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"C/Godeps/_workspace/src/D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\", \"C/Godeps/_workspace/src/T\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/T/main.go\", pkg(\"T\"), nil},\n\t\t\t},\n\t\t},\n\t\t{ // intermediate dep that uses godep save -r\n\t\t\tcwd:   \"C\",\n\t\t\tpaths: []string{\"D\", \"T\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\", \"D/Godeps/_workspace/src/T\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/T/main.go\", pkg(\"T\"), nil},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"C/Godeps/_workspace/src/D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\", \"C/Godeps/_workspace/src/T\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/T/main.go\", pkg(\"T\"), nil},\n\t\t\t},\n\t\t},\n\t\t{ // don't qualify standard library and local imports\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"fmt\", \"C/D\"), nil},\n\t\t\t\t{\"C/D/main.go\", pkg(\"D\"), nil},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"fmt\", \"C/D\"), nil},\n\t\t\t\t{\"C/D/main.go\", pkg(\"D\"), nil},\n\t\t\t},\n\t\t},\n\t\t{ // simple case, one dependency, -r=false\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\"), nil},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\"), nil},\n\t\t\t},\n\t\t},\n\t\t{ // transitive dep, -r=false\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\", \"T\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/T/main.go\", pkg(\"T\"), nil},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\", \"T\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/T/main.go\", pkg(\"T\"), nil},\n\t\t\t},\n\t\t},\n\t\t{ // intermediate dep that uses godep save -r, -r=false\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\", \"D/Godeps/_workspace/src/T\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/T/main.go\", pkg(\"T\"), nil},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\", \"T\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/T/main.go\", pkg(\"T\"), nil},\n\t\t\t},\n\t\t},\n\t\t{ // whitespace\n\t\t\tcwd:   \"C\",\n\t\t\tpaths: []string{\"D\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\"C/main.go\", whitespace, nil},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", whitespaceRewritten, nil},\n\t\t\t},\n\t\t},\n\t\t{ // sort after rewrite\n\t\t\tcwd:   \"C\",\n\t\t\tpaths: []string{\"D\", \"E\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\"C/main.go\", sortOrder, nil},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", sortOrderRewritten, nil},\n\t\t\t},\n\t\t},\n\t\t{ // sort after rewrite\n\t\t\tcwd:   \"C\",\n\t\t\tpaths: []string{\"D\", \"E\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\"C/main.go\", sortOrderPreserveComment, nil},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", sortOrderPreserveCommentRewritten, nil},\n\t\t\t},\n\t\t},\n\t\t{ // testdata directory is copied unmodified.\n\t\t\tcwd:   \"C\",\n\t\t\tpaths: []string{\"D\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/testdata\", \"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"badpkg.go\", \"//\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"C/Godeps/_workspace/src/D\"), nil},\n\t\t\t\t{\"C/testdata\", \"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"badpkg.go\", \"//\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tconst gopath = \"godeptest\"\n\tdefer os.RemoveAll(gopath)\n\tfor pos, test := range cases {\n\t\tsetGlobals(false)\n\t\terr := os.RemoveAll(gopath)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tsrc := filepath.Join(gopath, \"src\")\n\t\tmakeTree(t, &node{src, \"\", test.start}, \"\")\n\t\terr = rewriteTree(filepath.Join(src, test.cwd), test.cwd, test.paths)\n\t\tif g := err != nil; g != test.werr {\n\t\t\tt.Errorf(\"save err = %v (%v) want %v\", g, err, test.werr)\n\t\t}\n\t\ttempFiles, err := filepath.Glob(filepath.Join(src, test.cwd) + \"/*.temp\")\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error while running glob: %s\", err.Error())\n\t\t}\n\t\tif len(tempFiles) != 0 {\n\t\t\tt.Errorf(\"Unexpected tempfiles: %+v\", tempFiles)\n\t\t}\n\n\t\tcheckTree(t, pos, &node{src, \"\", test.want})\n\t}\n}\n"
        },
        {
          "name": "save.go",
          "type": "blob",
          "size": 14.578125,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"go/build\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/kr/fs\"\n)\n\nvar cmdSave = &Command{\n\tName:  \"save\",\n\tArgs:  \"[-r] [-t] [packages]\",\n\tShort: \"list and copy dependencies into Godeps\",\n\tLong: `\n\nSave writes a list of the named packages and their dependencies along\nwith the exact source control revision of each package, and copies\ntheir source code into a subdirectory. Packages inside \".\" are excluded\nfrom the list to be copied.\n\nThe list is written to Godeps/Godeps.json, and source code for all\ndependencies is copied into either Godeps/_workspace or, if the vendor\nexperiment is turned on, vendor/.\n\nThe dependency list is a JSON document with the following structure:\n\n\ttype Godeps struct {\n\t\tImportPath string\n\t\tGoVersion  string   // Abridged output of 'go version'.\n\t\tPackages   []string // Arguments to godep save, if any.\n\t\tDeps       []struct {\n\t\t\tImportPath string\n\t\t\tComment    string // Tag or description of commit.\n\t\t\tRev        string // VCS-specific commit ID.\n\t\t}\n\t}\n\nAny packages already present in the list will be left unchanged.\nTo update a dependency to a newer revision, use 'godep update'.\n\nIf -r is given, import statements will be rewritten to refer directly\nto the copied source code. This is not compatible with the vendor\nexperiment. Note that this will not rewrite the statements in the\nfiles outside the project.\n\nIf -t is given, test files (*_test.go files + testdata directories) are\nalso saved.\n\nFor more about specifying packages, see 'go help packages'.\n`,\n\tRun:          runSave,\n\tOnlyInGOPATH: true,\n}\n\nvar (\n\tsaveR, saveT bool\n)\n\nfunc init() {\n\tcmdSave.Flag.BoolVar(&saveR, \"r\", false, \"rewrite import paths\")\n\tcmdSave.Flag.BoolVar(&saveT, \"t\", false, \"save test files\")\n\n}\n\nfunc runSave(cmd *Command, args []string) {\n\tif VendorExperiment && saveR {\n\t\tlog.Println(\"flag -r is incompatible with the vendoring experiment\")\n\t\tcmd.UsageExit()\n\t}\n\terr := save(args)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n}\n\nfunc dotPackage() (*build.Package, error) {\n\tdir, err := filepath.Abs(\".\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn build.ImportDir(dir, build.FindOnly)\n}\n\nfunc projectPackages(dDir string, a []*Package) []*Package {\n\tvar projPkgs []*Package\n\tdotDir := fmt.Sprintf(\"%s%c\", dDir, filepath.Separator)\n\tfor _, p := range a {\n\t\tpkgDir := fmt.Sprintf(\"%s%c\", p.Dir, filepath.Separator)\n\t\tif strings.HasPrefix(pkgDir, dotDir) {\n\t\t\tprojPkgs = append(projPkgs, p)\n\t\t}\n\t}\n\treturn projPkgs\n}\n\nfunc save(pkgs []string) error {\n\tvar err error\n\tdp, err := dotPackage()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdebugln(\"dotPackageImportPath:\", dp.ImportPath)\n\tdebugln(\"dotPackageDir:\", dp.Dir)\n\n\tcv, err := goVersion()\n\tif err != nil {\n\t\treturn err\n\t}\n\tverboseln(\"Go Version:\", cv)\n\n\tgold, err := loadDefaultGodepsFile()\n\tif err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\treturn err\n\t\t}\n\t\tverboseln(\"No old Godeps.json found.\")\n\t\tgold.GoVersion = cv\n\t}\n\n\tprintVersionWarnings(gold.GoVersion)\n\tif len(gold.GoVersion) == 0 {\n\t\tgold.GoVersion = majorGoVersion\n\t} else {\n\t\tmajorGoVersion, err = trimGoVersion(gold.GoVersion)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Unable to determine go major version from value specified in %s: %s\\n\", gold.file(), gold.GoVersion)\n\t\t}\n\t}\n\n\tgnew := &Godeps{\n\t\tImportPath: dp.ImportPath,\n\t\tGoVersion:  gold.GoVersion,\n\t}\n\n\tswitch len(pkgs) {\n\tcase 0:\n\t\tpkgs = []string{\".\"}\n\tdefault:\n\t\tgnew.Packages = pkgs\n\t}\n\n\tverboseln(\"Finding dependencies for\", pkgs)\n\ta, err := LoadPackages(pkgs...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, p := range a {\n\t\tverboseln(\"Found package:\", p.ImportPath)\n\t\tverboseln(\"\\tDeps:\", strings.Join(p.Deps, \" \"))\n\t}\n\tppln(a)\n\n\tprojA := projectPackages(dp.Dir, a)\n\tdebugln(\"Filtered projectPackages\")\n\tppln(projA)\n\n\tverboseln(\"Computing new Godeps.json file\")\n\terr = gnew.fill(a, dp.ImportPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdebugln(\"New Godeps Filled\")\n\tppln(gnew)\n\n\tif gnew.Deps == nil {\n\t\tgnew.Deps = make([]Dependency, 0) // produce json [], not null\n\t}\n\tgdisk := gnew.copy()\n\terr = carryVersions(&gold, gnew)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif gold.isOldFile {\n\t\t// If we are migrating from an old format file,\n\t\t// we require that the listed version of every\n\t\t// dependency must be installed in GOPATH, so it's\n\t\t// available to copy.\n\t\tif !eqDeps(gnew.Deps, gdisk.Deps) {\n\t\t\treturn errors.New(strings.TrimSpace(needRestore))\n\t\t}\n\t\tgold = Godeps{}\n\t}\n\tos.Remove(\"Godeps\") // remove regular file if present; ignore error\n\treadme := filepath.Join(\"Godeps\", \"Readme\")\n\terr = writeFile(readme, strings.TrimSpace(Readme)+\"\\n\")\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\t_, err = gnew.save()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tverboseln(\"Computing diff between old and new deps\")\n\t// We use a name starting with \"_\" so the go tool\n\t// ignores this directory when traversing packages\n\t// starting at the project's root. For example,\n\t//   godep go list ./...\n\tsrcdir := filepath.FromSlash(strings.Trim(sep, \"/\"))\n\trem := subDeps(gold.Deps, gnew.Deps)\n\tppln(rem)\n\tadd := subDeps(gnew.Deps, gold.Deps)\n\tppln(add)\n\tif len(rem) > 0 {\n\t\tverboseln(\"Deps to remove:\")\n\t\tfor _, r := range rem {\n\t\t\tverboseln(\"\\t\", r.ImportPath)\n\t\t}\n\t\tverboseln(\"Removing unused dependencies\")\n\t\terr = removeSrc(srcdir, rem)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif len(add) > 0 {\n\t\tverboseln(\"Deps to add:\")\n\t\tfor _, a := range add {\n\t\t\tverboseln(\"\\t\", a.ImportPath)\n\t\t}\n\t\tverboseln(\"Adding new dependencies\")\n\t\terr = copySrc(srcdir, add)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif !VendorExperiment {\n\t\tf, _ := filepath.Split(srcdir)\n\t\twriteVCSIgnore(f)\n\t}\n\tvar rewritePaths []string\n\tif saveR {\n\t\tfor _, dep := range gnew.Deps {\n\t\t\trewritePaths = append(rewritePaths, dep.ImportPath)\n\t\t}\n\t}\n\tverboseln(\"Rewriting paths (if necessary)\")\n\tppln(rewritePaths)\n\treturn rewrite(projA, dp.ImportPath, rewritePaths)\n}\n\nfunc printVersionWarnings(ov string) {\n\tvar warning bool\n\tcv, err := goVersion()\n\tif err != nil {\n\t\treturn\n\t}\n\t// Trim the old version because we may have saved it w/o trimming it\n\t// cv is already trimmed by goVersion()\n\ttov, err := trimGoVersion(ov)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif tov != ov {\n\t\tlog.Printf(\"WARNING: Recorded go version (%s) with minor version string found.\\n\", ov)\n\t\twarning = true\n\t}\n\tif cv != tov {\n\t\tlog.Printf(\"WARNING: Recorded major go version (%s) and in-use major go version (%s) differ.\\n\", tov, cv)\n\t\twarning = true\n\t}\n\tif warning {\n\t\tlog.Println(\"To record current major go version run `godep update -goversion`.\")\n\t}\n}\n\ntype revError struct {\n\tImportPath string\n\tWantRev    string\n\tHavePath   string\n\tHaveRev    string\n}\n\nfunc (v *revError) Error() string {\n\treturn fmt.Sprintf(\"cannot save %s at revision %s: already have %s at revision %s.\\n\"+\n\t\t\"Run `godep update %s' first.\", v.ImportPath, v.WantRev, v.HavePath, v.HaveRev, v.HavePath)\n}\n\n// carryVersions copies Rev and Comment from a to b for\n// each dependency with an identical ImportPath. For any\n// dependency in b that appears to be from the same repo\n// as one in a (for example, a parent or child directory),\n// the Rev must already match - otherwise it is an error.\nfunc carryVersions(a, b *Godeps) error {\n\tfor i := range b.Deps {\n\t\terr := carryVersion(a, &b.Deps[i])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc carryVersion(a *Godeps, db *Dependency) error {\n\t// First see if this exact package is already in the list.\n\tfor _, da := range a.Deps {\n\t\tif db.ImportPath == da.ImportPath {\n\t\t\tdb.Rev = da.Rev\n\t\t\tdb.Comment = da.Comment\n\t\t\treturn nil\n\t\t}\n\t}\n\t// No exact match, check for child or sibling package.\n\t// We can't handle mismatched versions for packages in\n\t// the same repo, so report that as an error.\n\tfor _, da := range a.Deps {\n\t\tif strings.HasPrefix(db.ImportPath, da.ImportPath+\"/\") ||\n\t\t\tstrings.HasPrefix(da.ImportPath, db.root+\"/\") {\n\t\t\tif da.Rev != db.Rev {\n\t\t\t\treturn &revError{\n\t\t\t\t\tImportPath: db.ImportPath,\n\t\t\t\t\tWantRev:    db.Rev,\n\t\t\t\t\tHavePath:   da.ImportPath,\n\t\t\t\t\tHaveRev:    da.Rev,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// No related package in the list, must be a new repo.\n\treturn nil\n}\n\n// subDeps returns a - b, using ImportPath for equality.\nfunc subDeps(a, b []Dependency) (diff []Dependency) {\nDiff:\n\tfor _, da := range a {\n\t\tfor _, db := range b {\n\t\t\tif da.ImportPath == db.ImportPath {\n\t\t\t\tcontinue Diff\n\t\t\t}\n\t\t}\n\t\tdiff = append(diff, da)\n\t}\n\treturn diff\n}\n\nfunc removeSrc(srcdir string, deps []Dependency) error {\n\tfor _, dep := range deps {\n\t\tpath := filepath.FromSlash(dep.ImportPath)\n\t\terr := os.RemoveAll(filepath.Join(srcdir, path))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc copySrc(dir string, deps []Dependency) error {\n\t// mapping to see if we visited a parent directory already\n\tvisited := make(map[string]bool)\n\tok := true\n\tfor _, dep := range deps {\n\t\tdebugln(\"copySrc for\", dep.ImportPath)\n\t\tsrcdir := filepath.Join(dep.ws, \"src\")\n\t\trel, err := filepath.Rel(srcdir, dep.dir)\n\t\tdebugln(\"srcdir\", srcdir)\n\t\tdebugln(\"rel\", rel)\n\t\tdebugln(\"err\", err)\n\t\tif err != nil { // this should never happen\n\t\t\treturn err\n\t\t}\n\t\tdstpkgroot := filepath.Join(dir, rel)\n\t\terr = os.RemoveAll(dstpkgroot)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tok = false\n\t\t}\n\n\t\t// copy actual dependency\n\t\tvf := dep.vcs.listFiles(dep.dir)\n\t\tdebugln(\"vf\", vf)\n\t\tw := fs.Walk(dep.dir)\n\t\tfor w.Step() {\n\t\t\terr = copyPkgFile(vf, dir, srcdir, w)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t\tok = false\n\t\t\t}\n\t\t}\n\n\t\t// Look for legal files in root\n\t\t//  some packages are imports as a sub-package but license info\n\t\t//  is at root:  exampleorg/common has license file in exampleorg\n\t\t//\n\t\tif dep.ImportPath == dep.root {\n\t\t\t// we are already at root\n\t\t\tcontinue\n\t\t}\n\n\t\t// prevent copying twice This could happen if we have\n\t\t//   two subpackages listed someorg/common and\n\t\t//   someorg/anotherpack which has their license in\n\t\t//   the parent dir of someorg\n\t\trootdir := filepath.Join(srcdir, filepath.FromSlash(dep.root))\n\t\tif visited[rootdir] {\n\t\t\tcontinue\n\t\t}\n\t\tvisited[rootdir] = true\n\t\tvf = dep.vcs.listFiles(rootdir)\n\t\tw = fs.Walk(rootdir)\n\t\tfor w.Step() {\n\t\t\tfname := filepath.Base(w.Path())\n\t\t\tif IsLegalFile(fname) && !strings.Contains(w.Path(), sep) {\n\t\t\t\terr = copyPkgFile(vf, dir, srcdir, w)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Println(err)\n\t\t\t\t\tok = false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif !ok {\n\t\treturn errorCopyingSourceCode\n\t}\n\n\treturn nil\n}\n\nfunc copyPkgFile(vf vcsFiles, dstroot, srcroot string, w *fs.Walker) error {\n\tif w.Err() != nil {\n\t\treturn w.Err()\n\t}\n\tname := w.Stat().Name()\n\tif w.Stat().IsDir() {\n\t\tif name[0] == '.' || name[0] == '_' || (!saveT && name == \"testdata\") {\n\t\t\t// Skip directories starting with '.' or '_' or\n\t\t\t// 'testdata' (last is only skipped if saveT is false)\n\t\t\tw.SkipDir()\n\t\t}\n\t\treturn nil\n\t}\n\trel, err := filepath.Rel(srcroot, w.Path())\n\tif err != nil { // this should never happen\n\t\treturn err\n\t}\n\tif !saveT && strings.HasSuffix(name, \"_test.go\") {\n\t\tif verbose {\n\t\t\tlog.Printf(\"save: skipping test file: %s\", w.Path())\n\t\t}\n\t\treturn nil\n\t}\n\tif !vf.Contains(w.Path()) {\n\t\tif verbose {\n\t\t\tlog.Printf(\"save: skipping untracked file: %s\", w.Path())\n\t\t}\n\t\treturn nil\n\t}\n\treturn copyFile(filepath.Join(dstroot, rel), w.Path())\n}\n\n// copyFile copies a regular file from src to dst.\n// dst is opened with os.Create.\n// If the file name ends with .go,\n// copyFile strips canonical import path annotations.\n// These are comments of the form:\n//   package foo // import \"bar/foo\"\n//   package foo /* import \"bar/foo\" */\nfunc copyFile(dst, src string) error {\n\terr := os.MkdirAll(filepath.Dir(dst), 0777)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlinkDst, err := os.Readlink(src)\n\tif err == nil {\n\t\treturn os.Symlink(linkDst, dst)\n\t}\n\n\tsi, err := stat(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tr, err := os.Open(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer r.Close()\n\n\tw, err := os.Create(dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.Chmod(dst, si.Mode()); err != nil {\n\t\treturn err\n\t}\n\n\tif strings.HasSuffix(dst, \".go\") {\n\t\tdebugln(\"Copy Without Import Comment\", w, r)\n\t\terr = copyWithoutImportComment(w, r)\n\t} else {\n\t\tdebugln(\"Copy (plain)\", w, r)\n\t\t_, err = io.Copy(w, r)\n\t}\n\terr1 := w.Close()\n\tif err == nil {\n\t\terr = err1\n\t}\n\n\treturn err\n}\n\nfunc copyWithoutImportComment(w io.Writer, r io.Reader) error {\n\tb := bufio.NewReader(r)\n\tfor {\n\t\tl, err := b.ReadBytes('\\n')\n\t\teof := err == io.EOF\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn err\n\t\t}\n\n\t\t// If we have data then write it out...\n\t\tif len(l) > 0 {\n\t\t\t// Strip off \\n if it exists because stripImportComment\n\t\t\t_, err := w.Write(append(stripImportComment(bytes.TrimRight(l, \"\\n\")), '\\n'))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif eof {\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\nconst (\n\timportAnnotation = `import\\s+(?:\"[^\"]*\"|` + \"`[^`]*`\" + `)`\n\timportComment    = `(?://\\s*` + importAnnotation + `\\s*$|/\\*\\s*` + importAnnotation + `\\s*\\*/)`\n)\n\nvar (\n\timportCommentRE = regexp.MustCompile(`^\\s*(package\\s+\\w+)\\s+` + importComment + `(.*)`)\n\tpkgPrefix       = []byte(\"package \")\n)\n\n// stripImportComment returns line with its import comment removed.\n// If s is not a package statement containing an import comment,\n// it is returned unaltered.\n// FIXME: expects lines w/o a \\n at the end\n// See also http://golang.org/s/go14customimport.\nfunc stripImportComment(line []byte) []byte {\n\tif !bytes.HasPrefix(line, pkgPrefix) {\n\t\t// Fast path; this will skip all but one line in the file.\n\t\t// This assumes there is no whitespace before the keyword.\n\t\treturn line\n\t}\n\tif m := importCommentRE.FindSubmatch(line); m != nil {\n\t\treturn append(m[1], m[2]...)\n\t}\n\treturn line\n}\n\n// Func writeVCSIgnore writes \"ignore\" files inside dir for known VCSs,\n// so that dir/pkg and dir/bin don't accidentally get committed.\n// It logs any errors it encounters.\nfunc writeVCSIgnore(dir string) {\n\t// Currently git is the only VCS for which we know how to do this.\n\t// Mercurial and Bazaar have similar mechanisms, but they apparently\n\t// require writing files outside of dir.\n\tconst ignore = \"/pkg\\n/bin\\n\"\n\tname := filepath.Join(dir, \".gitignore\")\n\terr := writeFile(name, ignore)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}\n\n// writeFile is like ioutil.WriteFile but it creates\n// intermediate directories with os.MkdirAll.\nfunc writeFile(name, body string) error {\n\terr := os.MkdirAll(filepath.Dir(name), 0777)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn ioutil.WriteFile(name, []byte(body), 0666)\n}\n\nconst (\n\t// Readme contains the README text.\n\tReadme = `\nThis directory tree is generated automatically by godep.\n\nPlease do not edit.\n\nSee https://github.com/tools/godep for more information.\n`\n\tneedRestore = `\nmismatched versions while migrating\n\nIt looks like you are switching from the old Godeps format\n(from flag -copy=false). The old format is just a file; it\ndoesn't contain source code. For this migration, godep needs\nthe appropriate version of each dependency to be installed in\nGOPATH, so that the source code is available to copy.\n\nTo fix this, run 'godep restore'.\n`\n)\n"
        },
        {
          "name": "save_test.go",
          "type": "blob",
          "size": 38.970703125,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"go/build\"\n\t\"io/ioutil\"\n\t\"math\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"text/template\"\n)\n\n// node represents a file tree or a VCS repo\ntype node struct {\n\tpath    string      // file name or commit type\n\tbody    interface{} // file contents or commit tag\n\tentries []*node     // nil if the entry is a file\n}\n\nvar (\n\tpkgtpl = template.Must(template.New(\"package\").Parse(`package {{.Name}}\n\nimport (\n{{range .Imports}}\t{{printf \"%q\" .}}\n{{end}})\n`)) // `\n)\n\nfunc pkg(name string, imports ...string) string {\n\tv := struct {\n\t\tName    string\n\t\tTags    string\n\t\tImports []string\n\t}{name, \"\", imports}\n\tvar buf bytes.Buffer\n\terr := pkgtpl.Execute(&buf, v)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn buf.String()\n}\n\nfunc license() string {\n\treturn \"I AM A LICENSE FILE\"\n}\n\nfunc pkgWithTags(name, tags string, imports ...string) string {\n\treturn \"// +build \" + tags + \"\\n\\n\" + pkg(name, imports...)\n}\n\nfunc pkgWithImpossibleTag(name string, imports ...string) string {\n\treturn pkgWithTags(name, impossibleTag(), imports...)\n}\n\nfunc impossibleTag() string {\n\treturn \"!\" + runtime.GOOS\n}\n\nfunc decl(name string) string {\n\treturn \"var \" + name + \" int\\n\"\n}\n\nfunc setGOPATH(paths ...string) {\n\tbuild.Default.GOPATH = strings.Join(paths, string(os.PathListSeparator))\n}\n\nfunc clearPkgCache() {\n\tpkgCache = make(map[string]*build.Package)\n}\n\nfunc godeps(importpath string, keyval ...string) *Godeps {\n\tg := &Godeps{\n\t\tImportPath: importpath,\n\t}\n\tfor i := 0; i < len(keyval); i += 2 {\n\t\tg.Deps = append(g.Deps, Dependency{\n\t\t\tImportPath: keyval[i],\n\t\t\tComment:    keyval[i+1],\n\t\t})\n\t}\n\treturn g\n}\n\nfunc setGlobals(vendor bool) {\n\tclearPkgCache()\n\tclearStatCache()\n\tVendorExperiment = vendor\n\tsep = defaultSep(VendorExperiment)\n\t//debug = testing.Verbose()\n\t//verbose = testing.Verbose()\n}\n\nfunc TestSave(t *testing.T) {\n\tvar cases = []struct {\n\t\tcwd      string\n\t\targs     []string\n\t\tflagR    bool\n\t\tflagT    bool\n\t\tvendor   bool\n\t\tstart    []*node\n\t\taltstart []*node\n\t\twant     []*node\n\t\twdep     Godeps\n\t\twerr     bool\n\t}{\n\t\t{ // 0 - simple case, one dependency\n\t\t\tcwd:   \"C\",\n\t\t\tflagR: false,\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 1 - strip import comment\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", `package D // import \"D\"`, nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", \"package D\\n\", nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// 2 - dependency in same repo with existing manifest\n\t\t\t// see bug https://github.com/tools/godep/issues/69\n\t\t\tcwd:  \"P\",\n\t\t\targs: []string{\"./...\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"P\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"P\", \"P/Q\"), nil},\n\t\t\t\t\t\t{\"Q/main.go\", pkg(\"Q\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", `{}`, nil},\n\t\t\t\t\t\t{\"+git\", \"C1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"P/main.go\", pkg(\"P\", \"P/Q\"), nil},\n\t\t\t\t{\"P/Q/main.go\", pkg(\"Q\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"P\",\n\t\t\t\tDeps:       []Dependency{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// 3 - dependency on parent directory in same repo\n\t\t\t// see bug https://github.com/tools/godep/issues/70\n\t\t\tcwd:  \"P\",\n\t\t\targs: []string{\"./...\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"P\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"P\"), nil},\n\t\t\t\t\t\t{\"Q/main.go\", pkg(\"Q\", \"P\"), nil},\n\t\t\t\t\t\t{\"+git\", \"C1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"P/main.go\", pkg(\"P\"), nil},\n\t\t\t\t{\"P/Q/main.go\", pkg(\"Q\", \"P\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"P\",\n\t\t\t\tDeps:       []Dependency{},\n\t\t\t},\n\t\t},\n\t\t{ // 4 - transitive dependency\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\", \"T\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"T\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"T\"), nil},\n\t\t\t\t\t\t{\"+git\", \"T1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\", \"T\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/T/main.go\", pkg(\"T\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"T\", Comment: \"T1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 5 - two packages, one in a subdirectory\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\", \"D/P\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\"), nil},\n\t\t\t\t\t\t{\"P/main.go\", pkg(\"P\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\", \"D/P\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/P/main.go\", pkg(\"P\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"D/P\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 6 - repo root is not a package (no go files)\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D/P\", \"D/Q\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"P/main.go\", pkg(\"P\"), nil},\n\t\t\t\t\t\t{\"Q/main.go\", pkg(\"Q\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D/P\", \"D/Q\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/P/main.go\", pkg(\"P\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/Q/main.go\", pkg(\"Q\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D/P\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"D/Q\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 7 - symlink\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.x\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"main.go\", \"symlink:main.x\", nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 8 - add one dependency; keep other dependency version\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"E\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"E\"), nil},\n\t\t\t\t\t\t{\"+git\", \"E1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\", \"E\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D\", \"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\", \"E\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/E/main.go\", pkg(\"E\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"E\", Comment: \"E1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 9 - remove one dependency; keep other dependency version\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"E\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"E\") + decl(\"E1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"E1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D\", \"D1\", \"E\", \"E1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/E/main.go\", pkg(\"E\") + decl(\"E1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/E/main.go\", \"(absent)\", nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 10 - add one dependency from same repo\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t\t\t\t{\"B/main.go\", pkg(\"B\") + decl(\"B1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D/A\", \"D/B\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D/A\", \"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/Godeps/_workspace/src/D/A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/B/main.go\", pkg(\"B\") + decl(\"B1\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D/A\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"D/B\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 11 - add one dependency from same repo, require same version\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t\t\t\t{\"B/main.go\", pkg(\"B\") + decl(\"B1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"A2\"), nil},\n\t\t\t\t\t\t{\"B/main.go\", pkg(\"B\") + decl(\"B2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D/A\", \"D/B\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D/A\", \"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/Godeps/_workspace/src/D/A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D/A\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twerr: true,\n\t\t},\n\t\t{ // 12 - replace dependency from same repo parent dir\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D/A\", \"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/A/main.go\", \"(absent)\", nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 13 - replace dependency from same repo parent dir, require same version\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"A2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D/A\", \"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/Godeps/_workspace/src/D/A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D/A\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twerr: true,\n\t\t},\n\t\t{ // 14 - replace dependency from same repo child dir\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D/A\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D\", \"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", \"(absent)\", nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D/A\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 15 - replace dependency from same repo child dir, require same version\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"A2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D/A\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D\", \"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twerr: true,\n\t\t},\n\t\t{ // 16 - Bug https://github.com/tools/godep/issues/85\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t\t\t\t{\"B/main.go\", pkg(\"B\") + decl(\"B1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"A2\"), nil},\n\t\t\t\t\t\t{\"B/main.go\", pkg(\"B\") + decl(\"B2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D/A\", \"D/B\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D/A\", \"D1\", \"D/B\", \"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/B/main.go\", pkg(\"B\") + decl(\"B1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/Godeps/_workspace/src/D/A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/B/main.go\", pkg(\"B\") + decl(\"B1\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D/A\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"D/B\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 17 - intermediate dependency that uses godep save -r, main -r=false\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"T\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"T\"), nil},\n\t\t\t\t\t\t{\"+git\", \"T1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\", \"D/Godeps/_workspace/src/T\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/T/main.go\", pkg(\"T\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"D\", \"T\", \"T1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\", \"T\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/T/main.go\", pkg(\"T\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"T\", Comment: \"T1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 18 - intermediate dependency that uses godep save -r, main -r too\n\t\t\tcwd:   \"C\",\n\t\t\tflagR: true,\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"T\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"T\"), nil},\n\t\t\t\t\t\t{\"+git\", \"T1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\", \"D/Godeps/_workspace/src/T\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/T/main.go\", pkg(\"T\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"D\", \"T\", \"T1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"C/Godeps/_workspace/src/D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\", \"C/Godeps/_workspace/src/T\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/T/main.go\", pkg(\"T\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"T\", Comment: \"T1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 19 - rewrite files under build constraints\n\t\t\tcwd:   \"C\",\n\t\t\tflagR: true,\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"x.go\", \"// +build x\\n\\n\" + pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"C/Godeps/_workspace/src/D\"), nil},\n\t\t\t\t{\"C/x.go\", \"// +build x\\n\\n\" + pkg(\"main\", \"C/Godeps/_workspace/src/D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 20 - include flattened, rewritten deps\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\", \"T\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"T\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"T\"), nil},\n\t\t\t\t\t\t{\"X/main.go\", pkg(\"X\"), nil},\n\t\t\t\t\t\t{\"+git\", \"T1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\", \"D/Godeps/_workspace/src/T/X\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/T/X/main.go\", pkg(\"X\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"D\", \"T/X\", \"T1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\", \"T\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\", \"T/X\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/T/main.go\", pkg(\"T\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/T/X/main.go\", pkg(\"X\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"T\", Comment: \"T1\"},\n\t\t\t\t\t{ImportPath: \"T/X\", Comment: \"T1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 21 - find transitive dependencies across roots\n\t\t\tcwd:   \"C\",\n\t\t\tflagR: true,\n\t\t\taltstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"T\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"T\"), nil},\n\t\t\t\t\t\t{\"+git\", \"T1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\", \"D/Godeps/_workspace/src/T\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/T/main.go\", pkg(\"T\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"D\", \"T\", \"T1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"C/Godeps/_workspace/src/D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\", \"C/Godeps/_workspace/src/T\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/T/main.go\", pkg(\"T\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"T\", Comment: \"T1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 22 - pull in minimal dependencies, see https://github.com/tools/godep/issues/93\n\t\t\tcwd:   \"C\",\n\t\t\tflagR: true,\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D/X\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"T\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"T\"), nil},\n\t\t\t\t\t\t{\"+git\", \"T1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\", \"D/Godeps/_workspace/src/T\"), nil},\n\t\t\t\t\t\t{\"X/main.go\", pkg(\"X\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/T/main.go\", pkg(\"T\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"D\", \"T\", \"T1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"C/Godeps/_workspace/src/D/X\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/X/main.go\", pkg(\"X\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D/X\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 23 - don't require packages contained in dest to be in VCS\n\t\t\tcwd:   \"C\",\n\t\t\tflagR: true,\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\"), nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps:       []Dependency{},\n\t\t\t},\n\t\t},\n\t\t{ // 24 - include command line packages in the set to be copied\n\t\t\tcwd:   \"C\",\n\t\t\targs:  []string{\"P\"},\n\t\t\tflagR: true,\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\"), nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"P\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"P\"), nil},\n\t\t\t\t\t\t{\"+git\", \"P1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/P/main.go\", pkg(\"P\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"P\", Comment: \"P1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 25 - don't copy untracked files in the source directory\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"untracked\", \"garbage\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/untracked\", \"(absent)\", nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 26 - don't copy _test.go files\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\"), nil},\n\t\t\t\t\t\t{\"main_test.go\", pkg(\"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 27 - do copy _test.go files\n\t\t\tcwd:   \"C\",\n\t\t\tflagT: true,\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\"), nil},\n\t\t\t\t\t\t{\"main_test.go\", pkg(\"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main_test.go\", pkg(\"D\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 28 - Copy legal files in parent and dependency directory\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D/P\", \"D/Q\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"LICENSE\", license(), nil},\n\t\t\t\t\t\t{\"P/main.go\", pkg(\"P\"), nil},\n\t\t\t\t\t\t{\"P/LICENSE\", license(), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/E/LICENSE\", license(), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/E/main.go\", pkg(\"E\"), nil},\n\t\t\t\t\t\t{\"Q/main.go\", pkg(\"Q\"), nil},\n\t\t\t\t\t\t{\"Z/main.go\", pkg(\"Z\"), nil},\n\t\t\t\t\t\t{\"Z/LICENSE\", license(), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D/P\", \"D/Q\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/LICENSE\", license(), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/P/main.go\", pkg(\"P\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/P/LICENSE\", license(), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/Q/main.go\", pkg(\"Q\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/Godeps/_workspace/src/E/LICENSE\", \"(absent)\", nil}, // E is also not used, technically this wouldn't even be here\n\t\t\t\t{\"C/Godeps/_workspace/src/Z/LICENSE\", \"(absent)\", nil},                         // Z Isn't a dep, so shouldn't have a LICENSE file.\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D/P\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"D/Q\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 29 - two packages, one in a subdirectory that's included only on other OS\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkgWithImpossibleTag(\"D\", \"D/P\"), nil},\n\t\t\t\t\t\t{\"P/main.go\", pkg(\"P\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkgWithImpossibleTag(\"D\", \"D/P\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/P/main.go\", pkg(\"P\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"D/P\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 30 - build +ignore: #345, #348\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\"), nil},\n\t\t\t\t\t\t{\"ignore.go\", pkgWithTags(\"M\", \"ignore\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/ignore.go\", pkgWithTags(\"M\", \"ignore\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 31 - No buildable . #346\n\t\t\tcwd:  \"C\",\n\t\t\targs: []string{\"./...\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"sub/main.go\", pkg(\"main\"), nil},\n\t\t\t\t\t\t{\"+git\", \"C\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/sub/main.go\", pkg(\"main\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps:       []Dependency{},\n\t\t\t\tPackages:   []string{\"./...\"},\n\t\t\t},\n\t\t},\n\t\t{ // 32 - ignore `// +build appengine` as well for now: #353\n\t\t\tcwd: \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\"), nil},\n\t\t\t\t\t\t{\"ignore.go\", pkgWithTags(\"M\", \"appengine\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/ignore.go\", pkgWithTags(\"M\", \"appengine\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 33 - -r does not modify packages outside the project\n\t\t\tcwd:   \"C\",\n\t\t\targs:  []string{\"./...\", \"P\", \"CS\"},\n\t\t\tflagR: true,\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\"), nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"CS\", // tricky name for prefix matching\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"CS1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"P\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"P1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"lib.go\", pkg(\"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/CS/main.go\", pkg(\"main\", \"C/Godeps/_workspace/src/D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/P/main.go\", pkg(\"main\", \"C/Godeps/_workspace/src/D\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/lib.go\", pkg(\"D\"), nil},\n\t\t\t\t// unmodified external projects\n\t\t\t\t{\"D/lib.go\", pkg(\"D\"), nil},\n\t\t\t\t{\"CS/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"P/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"CS\", Comment: \"CS1\"},\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"P\", Comment: \"P1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 34 - vendor (#1) on, simple case, one dependency\n\t\t\tvendor: true,\n\t\t\tcwd:    \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/vendor/D/main.go\", pkg(\"D\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 35 - vendor (#4) transitive dependency\n\t\t\tvendor: true,\n\t\t\tcwd:    \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\", \"T\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"T\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"T\"), nil},\n\t\t\t\t\t\t{\"+git\", \"T1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/vendor/D/main.go\", pkg(\"D\", \"T\"), nil},\n\t\t\t\t{\"C/vendor/T/main.go\", pkg(\"T\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"T\", Comment: \"T1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 36 vendor (#21) find transitive dependencies across roots\n\t\t\tvendor: true,\n\t\t\tcwd:    \"C\",\n\t\t\taltstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"T\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"T\"), nil},\n\t\t\t\t\t\t{\"+git\", \"T1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\", \"T\"), nil},\n\t\t\t\t\t\t{\"vendor/T/main.go\", pkg(\"T\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"D\", \"T\", \"T1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/vendor/D/main.go\", pkg(\"D\", \"T\"), nil},\n\t\t\t\t{\"C/vendor/T/main.go\", pkg(\"T\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"T\", Comment: \"T1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 37 Do not copy in sub directories that aren't required\n\t\t\tvendor: true,\n\t\t\tcwd:    \"C\",\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\"), nil},\n\t\t\t\t\t\t{\"sub/main.go\", pkg(\"sub\"), nil},\n\t\t\t\t\t\t{\"sub/sub/main.go\", pkg(\"subsub\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t{\"C/vendor/D/main.go\", pkg(\"D\"), nil},\n\t\t\t\t{\"C/vendor/D/sub/main.go\", \"(absent)\", nil},\n\t\t\t\t{\"C/vendor/D/sub/sub/main.go\", \"(absent)\", nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 38 - build +mytag: #529\n\t\t\tcwd:    \"C\",\n\t\t\targs:   []string{\"./...\"},\n\t\t\tvendor: true,\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"foo/foo.go\", pkg(\"foo\", \"D\"), nil},\n\t\t\t\t\t\t{\"bar/bar.go\", pkgWithTags(\"bar\", \"mytag\", \"E\"), nil},\n\t\t\t\t\t\t{\"+git\", \"C1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"d.go\", pkg(\"d\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"E\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"e.go\", pkg(\"e\"), nil},\n\t\t\t\t\t\t{\"+git\", \"E1\", nil},\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/foo/foo.go\", pkg(\"foo\", \"D\"), nil},\n\t\t\t\t{\"C/bar/bar.go\", pkgWithTags(\"bar\", \"mytag\", \"E\"), nil},\n\t\t\t\t{\"C/vendor/D/d.go\", pkg(\"d\"), nil},\n\t\t\t\t{\"C/vendor/E/e.go\", pkg(\"e\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"E\", Comment: \"E1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 39 - return errors from fillPackage: #531\n\t\t\tcwd:    \"C\",\n\t\t\targs:   []string{\"./...\"},\n\t\t\tvendor: true,\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"C.go\", pkg(\"C\", \"github.com/D\"), nil},\n\t\t\t\t\t\t{\"vendor/github.com/D/D.go\", pkg(\"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"C1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"github.com/D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"D.go\", pkg(\"D\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/C.go\", pkg(\"C\", \"github.com/D\"), nil},\n\t\t\t\t{\"C/vendor/github.com/D/D.go\", pkg(\"D\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tPackages:   []string{\"./...\"},\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"github.com/D\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tconst scratch = \"godeptest\"\n\tdefer os.RemoveAll(scratch)\n\tfor pos, test := range cases {\n\t\tsetGlobals(test.vendor)\n\n\t\terr = os.RemoveAll(scratch)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\taltsrc := filepath.Join(scratch, \"r2\", \"src\")\n\t\tif test.altstart != nil {\n\t\t\tmakeTree(t, &node{altsrc, \"\", test.altstart}, \"\")\n\t\t}\n\t\tsrc := filepath.Join(scratch, \"r1\", \"src\")\n\t\tmakeTree(t, &node{src, \"\", test.start}, altsrc)\n\t\tdir := filepath.Join(wd, src, test.cwd)\n\t\terr = os.Chdir(dir)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\troot1 := filepath.Join(wd, scratch, \"r1\")\n\t\troot2 := filepath.Join(wd, scratch, \"r2\")\n\t\tsetGOPATH(root1, root2)\n\t\tsaveR = test.flagR\n\t\tsaveT = test.flagT\n\t\terr = save(test.args)\n\t\tif g := err != nil; g != test.werr {\n\t\t\tif err != nil {\n\t\t\t\tt.Log(pos, err)\n\t\t\t}\n\t\t\tt.Errorf(\"%d save err = %v want %v\", pos, g, test.werr)\n\t\t}\n\t\terr = os.Chdir(wd)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tcheckTree(t, pos, &node{src, \"\", test.want})\n\n\t\tf, err := os.Open(filepath.Join(dir, \"Godeps/Godeps.json\"))\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tg := new(Godeps)\n\t\terr = json.NewDecoder(f).Decode(g)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tf.Close()\n\n\t\tif g.ImportPath != test.wdep.ImportPath {\n\t\t\tt.Errorf(\"%d ImportPath = %s want %s\", pos, g.ImportPath, test.wdep.ImportPath)\n\t\t}\n\t\tfor i := range g.Deps {\n\t\t\tg.Deps[i].Rev = \"\"\n\t\t}\n\t\tif !reflect.DeepEqual(g.Deps, test.wdep.Deps) {\n\t\t\tt.Errorf(\"%d Deps = %v want %v\", pos, g.Deps, test.wdep.Deps)\n\t\t}\n\t}\n}\n\nfunc makeTree(t *testing.T, tree *node, altpath string) (gopath string) {\n\twalkTree(tree, tree.path, func(path string, n *node) {\n\t\tg, isGodeps := n.body.(*Godeps)\n\t\tbody, _ := n.body.(string)\n\t\tswitch {\n\t\tcase isGodeps:\n\t\t\tfor i, dep := range g.Deps {\n\t\t\t\trel := filepath.FromSlash(dep.ImportPath)\n\t\t\t\tdir := filepath.Join(tree.path, rel)\n\t\t\t\tif _, err := os.Stat(dir); os.IsNotExist(err) {\n\t\t\t\t\tdir = filepath.Join(altpath, rel)\n\t\t\t\t}\n\t\t\t\ttag := dep.Comment\n\t\t\t\trev := strings.TrimSpace(run(t, dir, \"git\", \"rev-parse\", tag))\n\t\t\t\tg.Deps[i].Rev = rev\n\t\t\t}\n\t\t\tos.MkdirAll(filepath.Dir(path), 0770)\n\t\t\tf, err := os.Create(path)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"makeTree: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer f.Close()\n\t\t\terr = json.NewEncoder(f).Encode(g)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"makeTree: %v\", err)\n\t\t\t}\n\t\tcase n.path == \"+git\":\n\t\t\tdir := filepath.Dir(path)\n\t\t\trun(t, dir, \"git\", \"init\") // repo might already exist, but ok\n\t\t\trun(t, dir, \"git\", \"add\", \"-A\", \".\")\n\t\t\trun(t, dir, \"git\", \"commit\", \"-m\", \"godep\")\n\t\t\tif body != \"\" {\n\t\t\t\trun(t, dir, \"git\", \"tag\", body)\n\t\t\t}\n\t\tcase n.entries == nil && strings.HasPrefix(body, \"symlink:\"):\n\t\t\ttarget := strings.TrimPrefix(body, \"symlink:\")\n\t\t\tos.Symlink(target, path)\n\t\tcase n.entries == nil && body == \"(absent)\":\n\t\t\tpanic(\"is this gonna be forever\")\n\t\tcase n.entries == nil && body == \"(rm)\":\n\t\t\tos.RemoveAll(path)\n\t\tcase n.entries == nil:\n\t\t\tos.MkdirAll(filepath.Dir(path), 0770)\n\t\t\terr := ioutil.WriteFile(path, []byte(body), 0660)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"makeTree: %v\", err)\n\t\t\t}\n\t\tdefault:\n\t\t\tos.MkdirAll(path, 0770)\n\t\t}\n\t})\n\treturn gopath\n}\n\nfunc checkTree(t *testing.T, pos int, want *node) {\n\twalkTree(want, want.path, func(path string, n *node) {\n\t\tbody := n.body.(string)\n\t\tswitch {\n\t\tcase n.path == \"+git\":\n\t\t\tpanic(\"is this real life\")\n\t\tcase n.entries == nil && strings.HasPrefix(body, \"symlink:\"):\n\t\t\tpanic(\"why is this happening to me\")\n\t\tcase n.entries == nil && body == \"(absent)\":\n\t\t\tbody, err := ioutil.ReadFile(path)\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\tt.Errorf(\"%d checkTree: %s = %s want absent\", pos, path, string(body))\n\t\t\t\treturn\n\t\t\t}\n\t\tcase n.entries == nil:\n\t\t\tgbody, err := ioutil.ReadFile(path)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"%d checkTree: %v\", pos, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got := string(gbody); got != body {\n\t\t\t\tt.Errorf(\"%d %s = got: %q want: %q\", pos, path, got, body)\n\t\t\t}\n\t\tdefault:\n\t\t\tos.MkdirAll(path, 0770)\n\t\t}\n\t})\n}\n\nfunc walkTree(n *node, path string, f func(path string, n *node)) {\n\tf(path, n)\n\tfor _, e := range n.entries {\n\t\twalkTree(e, filepath.Join(path, filepath.FromSlash(e.path)), f)\n\t}\n}\n\nfunc run(t *testing.T, dir, name string, args ...string) string {\n\tcmd := exec.Command(name, args...)\n\tcmd.Dir = dir\n\tcmd.Stderr = os.Stderr\n\tout, err := cmd.Output()\n\tif err != nil {\n\t\tpanic(name + \" \" + strings.Join(args, \" \") + \": \" + err.Error())\n\t}\n\treturn string(out)\n}\n\nfunc TestStripImportComment(t *testing.T) {\n\tvar cases = []struct{ s, w string }{\n\t\t{`package foo`, `package foo`},\n\t\t{`anything else`, `anything else`},\n\t\t{`package foo // import \"bar/foo\"`, `package foo`},\n\t\t{`package foo /* import \"bar/foo\" */`, `package foo`},\n\t\t{`package  foo  //  import  \"bar/foo\" `, `package  foo`},\n\t\t{\"package foo // import `bar/foo`\", `package foo`},\n\t\t{`package foo /* import \"bar/foo\" */; var x int`, `package foo; var x int`},\n\t\t{`package foo // import \"bar/foo\" garbage`, `package foo // import \"bar/foo\" garbage`},\n\t\t{`package xpackage foo // import \"bar/foo\"`, `package xpackage foo // import \"bar/foo\"`},\n\t}\n\n\tfor _, test := range cases {\n\t\tg := string(stripImportComment([]byte(test.s)))\n\t\tif g != test.w {\n\t\t\tt.Errorf(\"stripImportComment(%q) = %q want %q\", test.s, g, test.w)\n\t\t}\n\t}\n}\n\nfunc TestCopyWithoutImportCommentLongLines(t *testing.T) {\n\ttmp := make([]byte, int(math.Pow(2, 16)))\n\tfor i := range tmp {\n\t\ttmp[i] = 111 // fill it with \"o\"s\n\t}\n\n\tiStr := `package foo` + string(tmp) + `\\n`\n\n\to := new(bytes.Buffer)\n\ti := strings.NewReader(iStr)\n\terr := copyWithoutImportComment(o, i)\n\tif err != nil {\n\t\tt.Fatalf(\"copyWithoutImportComment errored: %s\", err.Error())\n\t}\n}\n"
        },
        {
          "name": "update.go",
          "type": "blob",
          "size": 5.720703125,
          "content": "package main\n\nimport (\n\t\"go/parser\"\n\t\"go/token\"\n\t\"log\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar cmdUpdate = &Command{\n\tName:  \"update\",\n\tArgs:  \"[-goversion] [packages]\",\n\tShort: \"update selected packages or the go version\",\n\tLong: `\nUpdate changes the named dependency packages to use the\nrevision of each currently installed in GOPATH. New code will\nbe copied into the Godeps workspace or vendor folder and the\nnew revision will be written to the manifest.\n\nIf -goversion is specified, update the recorded go version.\n\nFor more about specifying packages, see 'go help packages'.\n`,\n\tRun:          runUpdate,\n\tOnlyInGOPATH: true,\n}\n\nvar (\n\tupdateGoVer bool\n)\n\nfunc init() {\n\tcmdUpdate.Flag.BoolVar(&saveT, \"t\", false, \"save test files during update\")\n\tcmdUpdate.Flag.BoolVar(&updateGoVer, \"goversion\", false, \"update the recorded go version\")\n}\n\nfunc runUpdate(cmd *Command, args []string) {\n\tif updateGoVer {\n\t\terr := updateGoVersion()\n\t\tif err != nil {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t}\n\tif len(args) > 0 {\n\t\terr := update(args)\n\t\tif err != nil {\n\t\t\tlog.Fatalln(err)\n\t\t}\n\t}\n}\n\nfunc updateGoVersion() error {\n\tgold, err := loadDefaultGodepsFile()\n\tif err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\treturn err\n\t\t}\n\t}\n\tcv, err := goVersion()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tgv := gold.GoVersion\n\tgold.GoVersion = cv\n\t_, err = gold.save()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif gv != cv {\n\t\tlog.Println(\"Updated major go version to\", cv)\n\t}\n\treturn nil\n\n}\n\nfunc update(args []string) error {\n\tif len(args) == 0 {\n\t\targs = []string{\".\"}\n\t}\n\tg, err := loadDefaultGodepsFile()\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, arg := range args {\n\t\targ := path.Clean(arg)\n\t\tany := markMatches(arg, g.Deps)\n\t\tif !any {\n\t\t\tlog.Println(\"not in manifest:\", arg)\n\t\t}\n\t}\n\tdeps, rdeps, err := LoadVCSAndUpdate(g.Deps)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(deps) == 0 {\n\t\treturn errorNoPackagesUpdatable\n\t}\n\tg.addOrUpdateDeps(deps)\n\tg.removeDeps(rdeps)\n\tif _, err = g.save(); err != nil {\n\t\treturn err\n\t}\n\n\tsrcdir := relativeVendorTarget(VendorExperiment)\n\tif err := removeSrc(filepath.FromSlash(strings.Trim(sep, \"/\")), rdeps); err != nil {\n\t\treturn err\n\t}\n\tcopySrc(srcdir, deps)\n\n\tok, err := needRewrite(g.Packages)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar rewritePaths []string\n\tif ok {\n\t\tfor _, dep := range g.Deps {\n\t\t\trewritePaths = append(rewritePaths, dep.ImportPath)\n\t\t}\n\t}\n\treturn rewrite(nil, g.ImportPath, rewritePaths)\n}\n\nfunc needRewrite(importPaths []string) (bool, error) {\n\tif len(importPaths) == 0 {\n\t\timportPaths = []string{\".\"}\n\t}\n\ta, err := LoadPackages(importPaths...)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tfor _, p := range a {\n\t\tfor _, name := range p.allGoFiles() {\n\t\t\tpath := filepath.Join(p.Dir, name)\n\t\t\thasSep, err := hasRewrittenImportStatement(path)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t\tif hasSep {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn false, nil\n}\n\nfunc hasRewrittenImportStatement(path string) (bool, error) {\n\tfset := token.NewFileSet()\n\tf, err := parser.ParseFile(fset, path, nil, 0)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tfor _, s := range f.Imports {\n\t\tname, _ := strconv.Unquote(s.Path.Value)\n\t\tif strings.Contains(name, sep) {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\treturn false, nil\n}\n\n// markMatches marks each entry in deps with an import path that\n// matches pat. It returns whether any matches occurred.\nfunc markMatches(pat string, deps []Dependency) (matched bool) {\n\tf := matchPattern(pat)\n\tfor i, dep := range deps {\n\t\tif f(dep.ImportPath) {\n\t\t\tdeps[i].matched = true\n\t\t\tmatched = true\n\t\t}\n\t}\n\treturn matched\n}\n\nfunc fillDeps(deps []Dependency) ([]Dependency, error) {\n\tfor i := range deps {\n\t\tif deps[i].pkg != nil {\n\t\t\tcontinue\n\t\t}\n\t\tps, err := LoadPackages(deps[i].ImportPath)\n\t\tif err != nil {\n\t\t\tif _, ok := err.(errPackageNotFound); ok {\n\t\t\t\tdeps[i].missing = true\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tif len(ps) > 1 {\n\t\t\tpanic(\"More than one package found for \" + deps[i].ImportPath)\n\t\t}\n\t\tp := ps[0]\n\t\tdeps[i].pkg = p\n\t\tdeps[i].dir = p.Dir\n\t\tdeps[i].ws = p.Root\n\n\t\tvcs, reporoot, err := VCSFromDir(p.Dir, filepath.Join(p.Root, \"src\"))\n\t\tif err != nil {\n\t\t\treturn nil, errorLoadingDeps\n\t\t}\n\t\tdeps[i].root = filepath.ToSlash(reporoot)\n\t\tdeps[i].vcs = vcs\n\t}\n\n\treturn deps, nil\n}\n\n// LoadVCSAndUpdate loads and updates a set of dependencies.\nfunc LoadVCSAndUpdate(deps []Dependency) ([]Dependency, []Dependency, error) {\n\tvar err1 error\n\n\tdeps, err := fillDeps(deps)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\trepoMask := make(map[string]bool)\n\tfor i := range deps {\n\t\tif !deps[i].matched {\n\t\t\trepoMask[deps[i].root] = true\n\t\t}\n\t}\n\n\t// Determine if we need any new packages because of new transitive imports\n\tfor _, dep := range deps {\n\t\tif !dep.matched || dep.missing {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, dp := range dep.pkg.Dependencies {\n\t\t\tif dp.Goroot {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar have bool\n\t\t\tfor _, d := range deps {\n\t\t\t\tif d.ImportPath == dp.ImportPath {\n\t\t\t\t\thave = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !have {\n\t\t\t\tdeps = append(deps, Dependency{ImportPath: dp.ImportPath, matched: true})\n\t\t\t}\n\t\t}\n\t}\n\n\tdeps, err = fillDeps(deps)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar toUpdate, toRemove []Dependency\n\tfor _, d := range deps {\n\t\tif !d.matched || repoMask[d.root] {\n\t\t\tcontinue\n\t\t}\n\t\tif d.missing {\n\t\t\ttoRemove = append(toRemove, d)\n\t\t\tcontinue\n\t\t}\n\t\ttoUpdate = append(toUpdate, d)\n\t}\n\n\tdebugln(\"toUpdate\")\n\tppln(toUpdate)\n\n\tvar toCopy []Dependency\n\tfor _, d := range toUpdate {\n\t\tid, err := d.vcs.identify(d.dir)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\terr1 = errorLoadingDeps\n\t\t\tcontinue\n\t\t}\n\t\tif d.vcs.isDirty(d.dir, id) {\n\t\t\tlog.Println(\"dirty working tree (please commit changes):\", d.dir)\n\t\t}\n\t\td.Rev = id\n\t\td.Comment = d.vcs.describe(d.dir, id)\n\t\ttoCopy = append(toCopy, d)\n\t}\n\tdebugln(\"toCopy\")\n\tppln(toCopy)\n\n\tif err1 != nil {\n\t\treturn nil, nil, err1\n\t}\n\treturn toCopy, toRemove, nil\n}\n"
        },
        {
          "name": "update_test.go",
          "type": "blob",
          "size": 17.8232421875,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestUpdate(t *testing.T) {\n\tvar cases = []struct {\n\t\tcwd    string\n\t\targs   []string\n\t\tvendor bool\n\t\tstart  []*node\n\t\twant   []*node\n\t\twdep   Godeps\n\t\twerr   bool\n\t}{\n\t\t{ // 0 - simple case, update one dependency\n\t\t\tcwd:  \"C\",\n\t\t\targs: []string{\"D\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D\", \"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\") + decl(\"D2\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D2\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 1 - simple case, update one dependency, trailing slash\n\t\t\tcwd:  \"C\",\n\t\t\targs: []string{\"D/\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D\", \"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\") + decl(\"D2\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D2\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 2 - update one dependency, keep other one, no rewrite\n\t\t\tcwd:  \"C\",\n\t\t\targs: []string{\"D\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\", \"E\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\", \"E\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"E\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"E\") + decl(\"E1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"E1\", nil},\n\t\t\t\t\t\t{\"main.go\", pkg(\"E\") + decl(\"E2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"E2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\", \"E\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D\", \"D1\", \"E\", \"E1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/main.go\", pkg(\"D\", \"E\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/E/main.go\", pkg(\"E\") + decl(\"E1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\", \"E\") + decl(\"D2\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/E/main.go\", pkg(\"E\") + decl(\"E1\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D2\"},\n\t\t\t\t\t{ImportPath: \"E\", Comment: \"E1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 3 - update one dependency, keep other one, with rewrite\n\t\t\tcwd:  \"C\",\n\t\t\targs: []string{\"D\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\", \"E\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\", \"E\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"E\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"E\") + decl(\"E1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"E1\", nil},\n\t\t\t\t\t\t{\"main.go\", pkg(\"E\") + decl(\"E2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"E2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"C/Godeps/_workspace/src/D\", \"C/Godeps/_workspace/src/E\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D\", \"D1\", \"E\", \"E1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/main.go\", pkg(\"D\", \"C/Godeps/_workspace/src/E\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/E/main.go\", pkg(\"E\") + decl(\"E1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/main.go\", pkg(\"main\", \"C/Godeps/_workspace/src/D\", \"C/Godeps/_workspace/src/E\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\", \"C/Godeps/_workspace/src/E\") + \"\\n\" + decl(\"D2\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/E/main.go\", pkg(\"E\") + decl(\"E1\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D2\"},\n\t\t\t\t\t{ImportPath: \"E\", Comment: \"E1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 4 - update all dependencies\n\t\t\tcwd:  \"C\",\n\t\t\targs: []string{\"...\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"E\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"E\") + decl(\"E1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"E1\", nil},\n\t\t\t\t\t\t{\"main.go\", pkg(\"E\") + decl(\"E2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"E2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\", \"E\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D\", \"D1\", \"E\", \"E1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/E/main.go\", pkg(\"E\") + decl(\"E1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\") + decl(\"D2\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/E/main.go\", pkg(\"E\") + decl(\"E2\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D2\"},\n\t\t\t\t\t{ImportPath: \"E\", Comment: \"E2\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 5 - one match of two patterns\n\t\t\tcwd:  \"C\",\n\t\t\targs: []string{\"D\", \"X\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D\", \"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\") + decl(\"D2\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D2\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 6 - no matches\n\t\t\tcwd:  \"C\",\n\t\t\targs: []string{\"X\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"main.go\", pkg(\"D\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D\", \"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/Godeps/_workspace/src/D/main.go\", pkg(\"D\") + decl(\"D1\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twerr: true,\n\t\t},\n\t\t{ // 7 - update just one package of two in a repo skips it\n\t\t\tcwd:  \"C\",\n\t\t\targs: []string{\"D/A\", \"E\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"B/main.go\", pkg(\"B\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"B/main.go\", pkg(\"B\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"E\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"E\") + decl(\"E1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"E1\", nil},\n\t\t\t\t\t\t{\"main.go\", pkg(\"E\") + decl(\"E2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"E2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D/A\", \"D/B\", \"E\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D/A\", \"D1\", \"D/B\", \"D1\", \"E\", \"E1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/A/main.go\", pkg(\"A\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/B/main.go\", pkg(\"B\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/E/main.go\", pkg(\"E\") + decl(\"E1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/Godeps/_workspace/src/D/A/main.go\", pkg(\"A\") + decl(\"D1\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/B/main.go\", pkg(\"B\") + decl(\"D1\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/E/main.go\", pkg(\"E\") + decl(\"E2\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D/A\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"D/B\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"E\", Comment: \"E2\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 8 - update just one package of two in a repo, none left\n\t\t\tcwd:  \"C\",\n\t\t\targs: []string{\"D/A\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"B/main.go\", pkg(\"B\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"B/main.go\", pkg(\"B\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D/A\", \"D/B\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D/A\", \"D1\", \"D/B\", \"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/A/main.go\", pkg(\"A\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"Godeps/_workspace/src/D/B/main.go\", pkg(\"B\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/Godeps/_workspace/src/D/A/main.go\", pkg(\"A\") + decl(\"D1\"), nil},\n\t\t\t\t{\"C/Godeps/_workspace/src/D/B/main.go\", pkg(\"B\") + decl(\"D1\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D/A\", Comment: \"D1\"},\n\t\t\t\t\t{ImportPath: \"D/B\", Comment: \"D1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\twerr: true,\n\t\t},\n\t\t{ // 9 - package/..., just version bump\n\t\t\tvendor: true,\n\t\t\tcwd:    \"C\",\n\t\t\targs:   []string{\"D/...\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"B/main.go\", pkg(\"B\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"B/main.go\", pkg(\"B\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D/A\", \"D/B\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D/A\", \"D1\", \"D/B\", \"D1\"), nil},\n\t\t\t\t\t\t{\"vendor/D/A/main.go\", pkg(\"A\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"vendor/D/B/main.go\", pkg(\"B\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/vendor/D/A/main.go\", pkg(\"A\") + decl(\"D2\"), nil},\n\t\t\t\t{\"C/vendor/D/B/main.go\", pkg(\"B\") + decl(\"D2\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D/A\", Comment: \"D2\"},\n\t\t\t\t\t{ImportPath: \"D/B\", Comment: \"D2\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 10 - package/..., new unrelated package that's not imported\n\t\t\tvendor: true,\n\t\t\tcwd:    \"C\",\n\t\t\targs:   []string{\"D/...\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"B/main.go\", pkg(\"B\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"B/main.go\", pkg(\"B\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"E/main.go\", pkg(\"E\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D/A\", \"D/B\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D/A\", \"D1\", \"D/B\", \"D1\"), nil},\n\t\t\t\t\t\t{\"vendor/D/A/main.go\", pkg(\"A\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"vendor/D/B/main.go\", pkg(\"B\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/vendor/D/A/main.go\", pkg(\"A\") + decl(\"D2\"), nil},\n\t\t\t\t{\"C/vendor/D/B/main.go\", pkg(\"B\") + decl(\"D2\"), nil},\n\t\t\t\t{\"C/vendor/D/E/main.go\", \"(absent)\", nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D/A\", Comment: \"D2\"},\n\t\t\t\t\t{ImportPath: \"D/B\", Comment: \"D2\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 11 - package/..., new transitive package, same repo\n\t\t\tvendor: true,\n\t\t\tcwd:    \"C\",\n\t\t\targs:   []string{\"D/...\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"B/main.go\", pkg(\"B\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"B/main.go\", pkg(\"B\", \"D/E\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"E/main.go\", pkg(\"E\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D/A\", \"D/B\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D/A\", \"D1\", \"D/B\", \"D1\"), nil},\n\t\t\t\t\t\t{\"vendor/D/A/main.go\", pkg(\"A\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"vendor/D/B/main.go\", pkg(\"B\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/vendor/D/A/main.go\", pkg(\"A\") + decl(\"D2\"), nil},\n\t\t\t\t{\"C/vendor/D/B/main.go\", pkg(\"B\", \"D/E\") + decl(\"D2\"), nil},\n\t\t\t\t{\"C/vendor/D/E/main.go\", pkg(\"E\") + decl(\"D2\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D/A\", Comment: \"D2\"},\n\t\t\t\t\t{ImportPath: \"D/B\", Comment: \"D2\"},\n\t\t\t\t\t{ImportPath: \"D/E\", Comment: \"D2\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 12 - package/..., new transitive package, different repo\n\t\t\tvendor: true,\n\t\t\tcwd:    \"C\",\n\t\t\targs:   []string{\"D/...\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"B/main.go\", pkg(\"B\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"B/main.go\", pkg(\"B\", \"E\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"E\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"E\") + decl(\"E1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"E1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D/A\", \"D/B\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D/A\", \"D1\", \"D/B\", \"D1\"), nil},\n\t\t\t\t\t\t{\"vendor/D/A/main.go\", pkg(\"A\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"vendor/D/B/main.go\", pkg(\"B\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/vendor/D/A/main.go\", pkg(\"A\") + decl(\"D2\"), nil},\n\t\t\t\t{\"C/vendor/D/B/main.go\", pkg(\"B\", \"E\") + decl(\"D2\"), nil},\n\t\t\t\t{\"C/vendor/E/main.go\", pkg(\"E\") + decl(\"E1\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D/A\", Comment: \"D2\"},\n\t\t\t\t\t{ImportPath: \"D/B\", Comment: \"D2\"},\n\t\t\t\t\t{ImportPath: \"E\", Comment: \"E1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 13 - package/..., missing packages\n\t\t\tvendor: true,\n\t\t\tcwd:    \"C\",\n\t\t\targs:   []string{\"D/...\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"B/main.go\", pkg(\"B\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"D1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"D/A\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"D/A\", \"D1\", \"D/B\", \"D1\"), nil},\n\t\t\t\t\t\t{\"vendor/D/A/main.go\", pkg(\"A\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"vendor/D/B/main.go\", pkg(\"B\") + decl(\"D1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\"D\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"A/main.go\", pkg(\"A\") + decl(\"D2\"), nil},\n\t\t\t\t\t\t{\"B\", \"(rm)\", nil},\n\t\t\t\t\t\t{\"+git\", \"D2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/vendor/D/A/main.go\", pkg(\"A\") + decl(\"D2\"), nil},\n\t\t\t\t{\"C/vendor/D/B/main.go\", \"(absent)\", nil},\n\t\t\t\t{\"C/vendor/D/E/main.go\", \"(absent)\", nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"D/A\", Comment: \"D2\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{ // 14 - Update package A, but not package B, which is missing from $GOPATH\n\t\t\tvendor: true,\n\t\t\tcwd:    \"C\",\n\t\t\targs:   []string{\"A\"},\n\t\t\tstart: []*node{\n\t\t\t\t{\n\t\t\t\t\t\"A\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"A1\", nil},\n\t\t\t\t\t\t{\"main.go\", pkg(\"A\") + decl(\"A2\"), nil},\n\t\t\t\t\t\t{\"+git\", \"A2\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{ // Create B so makeTree can resolve the rev for Godeps.json\n\t\t\t\t\t\"B\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"B\") + decl(\"B1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"B1\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"C\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"main.go\", pkg(\"main\", \"A\", \"B\"), nil},\n\t\t\t\t\t\t{\"Godeps/Godeps.json\", godeps(\"C\", \"A\", \"A1\", \"B\", \"B1\"), nil},\n\t\t\t\t\t\t{\"vendor/A/main.go\", pkg(\"A\") + decl(\"A1\"), nil},\n\t\t\t\t\t\t{\"vendor/B/main.go\", pkg(\"B\") + decl(\"B1\"), nil},\n\t\t\t\t\t\t{\"+git\", \"\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{ // Remove B so it's not in the $GOPATH\n\t\t\t\t\t\"\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t[]*node{\n\t\t\t\t\t\t{\"B\", \"(rm)\", nil},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []*node{\n\t\t\t\t{\"C/vendor/A/main.go\", pkg(\"A\") + decl(\"A2\"), nil},\n\t\t\t\t{\"C/vendor/B/main.go\", pkg(\"B\") + decl(\"B1\"), nil},\n\t\t\t},\n\t\t\twdep: Godeps{\n\t\t\t\tImportPath: \"C\",\n\t\t\t\tDeps: []Dependency{\n\t\t\t\t\t{ImportPath: \"A\", Comment: \"A2\"},\n\t\t\t\t\t{ImportPath: \"B\", Comment: \"B1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tconst gopath = \"godeptest\"\n\tdefer os.RemoveAll(gopath)\n\tfor pos, test := range cases {\n\t\tsetGlobals(test.vendor)\n\t\terr = os.RemoveAll(gopath)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tsrc := filepath.Join(gopath, \"src\")\n\t\tmakeTree(t, &node{src, \"\", test.start}, \"\")\n\n\t\tdir := filepath.Join(wd, src, test.cwd)\n\t\terr = os.Chdir(dir)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tsetGOPATH(filepath.Join(wd, gopath))\n\t\tlog.SetOutput(ioutil.Discard)\n\t\terr = update(test.args)\n\t\tlog.SetOutput(os.Stderr)\n\t\tif err != nil {\n\t\t\tt.Log(pos, \"Err:\", err)\n\t\t}\n\t\tif g := err != nil; g != test.werr {\n\t\t\tt.Errorf(\"update err = %v (%v) want %v\", g, err, test.werr)\n\t\t}\n\t\terr = os.Chdir(wd)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tcheckTree(t, pos, &node{src, \"\", test.want})\n\n\t\tf, err := os.Open(filepath.Join(dir, \"Godeps/Godeps.json\"))\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tg := new(Godeps)\n\t\terr = json.NewDecoder(f).Decode(g)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tf.Close()\n\n\t\tif g.ImportPath != test.wdep.ImportPath {\n\t\t\tt.Errorf(\"ImportPath = %s want %s\", g.ImportPath, test.wdep.ImportPath)\n\t\t}\n\t\tfor i := range g.Deps {\n\t\t\tg.Deps[i].Rev = \"\"\n\t\t}\n\t\tif !reflect.DeepEqual(g.Deps, test.wdep.Deps) {\n\t\t\tt.Errorf(\"Deps = %v want %v\", g.Deps, test.wdep.Deps)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 0.8310546875,
          "content": "package main\n\nimport (\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n)\n\n// driveLetterToUpper converts Windows path's drive letters to uppercase. This\n// is needed when comparing 2 paths with different drive letter case.\nfunc driveLetterToUpper(path string) string {\n\tif runtime.GOOS != \"windows\" || path == \"\" {\n\t\treturn path\n\t}\n\n\tp := path\n\n\t// If path's drive letter is lowercase, change it to uppercase.\n\tif len(p) >= 2 && p[1] == ':' && 'a' <= p[0] && p[0] <= 'z' {\n\t\tp = string(p[0]+'A'-'a') + p[1:]\n\t}\n\n\treturn p\n}\n\n// clean the path and ensure that a drive letter is upper case (if it exists).\nfunc cleanPath(path string) string {\n\treturn driveLetterToUpper(filepath.Clean(path))\n}\n\n// deal with case insensitive filesystems and other weirdness\nfunc pathEqual(a, b string) bool {\n\ta = cleanPath(a)\n\tb = cleanPath(b)\n\treturn strings.EqualFold(a, b)\n}\n"
        },
        {
          "name": "vcs.go",
          "type": "blob",
          "size": 7.2216796875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"golang.org/x/tools/go/vcs\"\n)\n\n// VCS represents a version control system.\ntype VCS struct {\n\tvcs *vcs.Cmd\n\n\tIdentifyCmd string\n\tDescribeCmd string\n\tDiffCmd     string\n\tListCmd     string\n\tRootCmd     string\n\n\t// run in sandbox repos\n\tExistsCmd string\n}\n\nvar vcsBzr = &VCS{\n\tvcs: vcs.ByCmd(\"bzr\"),\n\n\tIdentifyCmd: \"version-info --custom --template {revision_id}\",\n\tDescribeCmd: \"revno\", // TODO(kr): find tag names if possible\n\tDiffCmd:     \"diff -r {rev}\",\n\tListCmd:     \"ls --from-root -R\",\n\tRootCmd:     \"root\",\n}\n\nvar vcsGit = &VCS{\n\tvcs: vcs.ByCmd(\"git\"),\n\n\tIdentifyCmd: \"rev-parse HEAD\",\n\tDescribeCmd: \"describe --tags\",\n\tDiffCmd:     \"diff {rev}\",\n\tListCmd:     \"ls-files --full-name\",\n\tRootCmd:     \"rev-parse --show-cdup\",\n\n\tExistsCmd: \"cat-file -e {rev}\",\n}\n\nvar vcsHg = &VCS{\n\tvcs: vcs.ByCmd(\"hg\"),\n\n\tIdentifyCmd: \"parents --template {node}\",\n\tDescribeCmd: \"log -r . --template {latesttag}-{latesttagdistance}\",\n\tDiffCmd:     \"diff -r {rev}\",\n\tListCmd:     \"status --all --no-status\",\n\tRootCmd:     \"root\",\n\n\tExistsCmd: \"cat -r {rev} .\",\n}\n\nvar cmd = map[*vcs.Cmd]*VCS{\n\tvcsBzr.vcs: vcsBzr,\n\tvcsGit.vcs: vcsGit,\n\tvcsHg.vcs:  vcsHg,\n}\n\n// VCSFromDir returns a VCS value from a directory.\nfunc VCSFromDir(dir, srcRoot string) (*VCS, string, error) {\n\tvcscmd, reporoot, err := vcs.FromDir(dir, srcRoot)\n\tif err != nil {\n\t\treturn nil, \"\", fmt.Errorf(\"error while inspecting %q: %v\", dir, err)\n\t}\n\tvcsext := cmd[vcscmd]\n\tif vcsext == nil {\n\t\treturn nil, \"\", fmt.Errorf(\"%s is unsupported: %s\", vcscmd.Name, dir)\n\t}\n\treturn vcsext, reporoot, nil\n}\n\nfunc (v *VCS) identify(dir string) (string, error) {\n\tout, err := v.runOutput(dir, v.IdentifyCmd)\n\treturn string(bytes.TrimSpace(out)), err\n}\n\nfunc absRoot(dir, out string) string {\n\tif filepath.IsAbs(out) {\n\t\treturn filepath.Clean(out)\n\t}\n\treturn filepath.Join(dir, out)\n}\n\nfunc (v *VCS) root(dir string) (string, error) {\n\tout, err := v.runOutput(dir, v.RootCmd)\n\treturn absRoot(dir, string(bytes.TrimSpace(out))), err\n}\n\nfunc (v *VCS) describe(dir, rev string) string {\n\tout, err := v.runOutputVerboseOnly(dir, v.DescribeCmd, \"rev\", rev)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\treturn string(bytes.TrimSpace(out))\n}\n\nfunc (v *VCS) isDirty(dir, rev string) bool {\n\tout, err := v.runOutput(dir, v.DiffCmd, \"rev\", rev)\n\treturn err != nil || len(out) != 0\n}\n\ntype vcsFiles map[string]bool\n\nfunc (vf vcsFiles) Contains(path string) bool {\n\t// Fast path, we have the path\n\tif vf[path] {\n\t\treturn true\n\t}\n\n\t// Slow path for case insensitive filesystems\n\t// See #310\n\tfor f := range vf {\n\t\tif pathEqual(f, path) {\n\t\t\treturn true\n\t\t}\n\t\t// git's root command (maybe other vcs as well) resolve symlinks, so try that too\n\t\t// FIXME: rev-parse --show-cdup + extra logic will fix this for git but also need to validate the other vcs commands. This is maybe temporary.\n\t\tp, err := filepath.EvalSymlinks(path)\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\tif pathEqual(f, p) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// No matches by either method\n\treturn false\n}\n\n// listFiles tracked by the VCS in the repo that contains dir, converted to absolute path.\nfunc (v *VCS) listFiles(dir string) vcsFiles {\n\troot, err := v.root(dir)\n\tdebugln(\"vcs dir\", dir)\n\tdebugln(\"vcs root\", root)\n\tppln(v)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tout, err := v.runOutput(dir, v.ListCmd)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tfiles := make(vcsFiles)\n\tfor _, file := range bytes.Split(out, []byte{'\\n'}) {\n\t\tif len(file) > 0 {\n\t\t\tpath, err := filepath.Abs(filepath.Join(root, string(file)))\n\t\t\tif err != nil {\n\t\t\t\tpanic(err) // this should not happen\n\t\t\t}\n\n\t\t\tif pathEqual(filepath.Dir(path), dir) {\n\t\t\t\tfiles[path] = true\n\t\t\t}\n\t\t}\n\t}\n\treturn files\n}\n\nfunc (v *VCS) exists(dir, rev string) bool {\n\terr := v.runVerboseOnly(dir, v.ExistsCmd, \"rev\", rev)\n\treturn err == nil\n}\n\n// RevSync checks out the revision given by rev in dir.\n// The dir must exist and rev must be a valid revision.\nfunc (v *VCS) RevSync(dir, rev string) error {\n\treturn v.run(dir, v.vcs.TagSyncCmd, \"tag\", rev)\n}\n\n// run runs the command line cmd in the given directory.\n// keyval is a list of key, value pairs.  run expands\n// instances of {key} in cmd into value, but only after\n// splitting cmd into individual arguments.\n// If an error occurs, run prints the command line and the\n// command's combined stdout+stderr to standard error.\n// Otherwise run discards the command's output.\nfunc (v *VCS) run(dir string, cmdline string, kv ...string) error {\n\t_, err := v.run1(dir, cmdline, kv, true)\n\treturn err\n}\n\n// runVerboseOnly is like run but only generates error output to standard error in verbose mode.\nfunc (v *VCS) runVerboseOnly(dir string, cmdline string, kv ...string) error {\n\t_, err := v.run1(dir, cmdline, kv, false)\n\treturn err\n}\n\n// runOutput is like run but returns the output of the command.\nfunc (v *VCS) runOutput(dir string, cmdline string, kv ...string) ([]byte, error) {\n\treturn v.run1(dir, cmdline, kv, true)\n}\n\n// runOutputVerboseOnly is like runOutput but only generates error output to standard error in verbose mode.\nfunc (v *VCS) runOutputVerboseOnly(dir string, cmdline string, kv ...string) ([]byte, error) {\n\treturn v.run1(dir, cmdline, kv, false)\n}\n\n// run1 is the generalized implementation of run and runOutput.\nfunc (v *VCS) run1(dir string, cmdline string, kv []string, verbose bool) ([]byte, error) {\n\tm := make(map[string]string)\n\tfor i := 0; i < len(kv); i += 2 {\n\t\tm[kv[i]] = kv[i+1]\n\t}\n\targs := strings.Fields(cmdline)\n\tfor i, arg := range args {\n\t\targs[i] = expand(m, arg)\n\t}\n\n\t_, err := exec.LookPath(v.vcs.Cmd)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"godep: missing %s command.\\n\", v.vcs.Name)\n\t\treturn nil, err\n\t}\n\n\tcmd := exec.Command(v.vcs.Cmd, args...)\n\tcmd.Dir = dir\n\tvar buf bytes.Buffer\n\tcmd.Stdout = &buf\n\tcmd.Stderr = &buf\n\terr = cmd.Run()\n\tout := buf.Bytes()\n\tif err != nil {\n\t\tif verbose {\n\t\t\tfmt.Fprintf(os.Stderr, \"# cd %s; %s %s\\n\", dir, v.vcs.Cmd, strings.Join(args, \" \"))\n\t\t\tos.Stderr.Write(out)\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn out, nil\n}\n\nfunc expand(m map[string]string, s string) string {\n\tfor k, v := range m {\n\t\ts = strings.Replace(s, \"{\"+k+\"}\", v, -1)\n\t}\n\treturn s\n}\n\nfunc gitDetached(r string) (bool, error) {\n\to, err := vcsGit.runOutput(r, \"status\")\n\tif err != nil {\n\t\treturn false, errors.New(\"unable to determine git status \" + err.Error())\n\t}\n\treturn bytes.Contains(o, []byte(\"HEAD detached at\")), nil\n}\n\nfunc gitDefaultBranch(r string) (string, error) {\n\to, err := vcsGit.runOutput(r, \"remote show origin\")\n\tif err != nil {\n\t\treturn \"\", errors.New(\"Running git remote show origin errored with: \" + err.Error())\n\t}\n\treturn gitDetermineDefaultBranch(r, string(o))\n}\n\nfunc gitDetermineDefaultBranch(r, o string) (string, error) {\n\te := \"Unable to determine HEAD branch: \"\n\thb := \"HEAD branch:\"\n\tlbcfgp := \"Local branch configured for 'git pull':\"\n\ts := strings.Index(o, hb)\n\tif s < 0 {\n\t\tb := strings.Index(o, lbcfgp)\n\t\tif b < 0 {\n\t\t\treturn \"\", errors.New(e + \"Remote HEAD is ambiguous. Before godep can pull new commits you will need to:\" + `\ncd ` + r + `\ngit checkout <a HEAD branch>\nHere is what was reported:\n` + o)\n\t\t}\n\t\ts = b + len(lbcfgp)\n\t} else {\n\t\ts += len(hb)\n\t}\n\tf := strings.Fields(o[s:])\n\tif len(f) < 3 {\n\t\treturn \"\", errors.New(e + \"git output too short\")\n\t}\n\treturn f[0], nil\n}\n\nfunc gitCheckout(r, b string) error {\n\treturn vcsGit.run(r, \"checkout \"+b)\n}\n"
        },
        {
          "name": "vcs_test.go",
          "type": "blob",
          "size": 2.5224609375,
          "content": "package main\n\nimport \"testing\"\n\nfunc TestGitDetermineDefaultBranch(t *testing.T) {\n\tcases := []struct {\n\t\tr, o string\n\t\tv    string\n\t\terr  bool\n\t}{\n\t\t{\"test\",\n\t\t\t`* remote origin\n  Fetch URL: https://gopkg.in/mgo.v2\n  Push  URL: https://gopkg.in/mgo.v2\n  HEAD branch: v2\n  Remote branches:\n    master      tracked\n    v2          tracked\n    v2-unstable tracked\n  Local branches configured for 'git pull':\n    master merges with remote master\n    v2     merges with remote v2\n  Local refs configured for 'git push':\n    master pushes to master (up to date)\n    v2     pushes to v2     (local out of date)\n`, \"v2\", false},\n\t\t{\"test\",\n\t\t\t`* remote origin\n  Fetch URL: https://gopkg.in/bluesuncorp/validator.v5\n  Push  URL: https://gopkg.in/bluesuncorp/validator.v5\n  HEAD branch (remote HEAD is ambiguous, may be one of the following):\n    master\n    v5\n  Remote branches:\n    krhubert       tracked\n    master         tracked\n    v4             tracked\n    v5             tracked\n    v5-development tracked\n    v6             tracked\n    v6-development tracked\n    v7             tracked\n    v7-development tracked\n    v8             tracked\n    v8-development tracked\n  Local branch configured for 'git pull':\n    master merges with remote master\n  Local ref configured for 'git push':\n    master pushes to master (up to date)\n`, \"master\", false},\n\t\t{\"test\",\n\t\t\t`* remote origin\n  Fetch URL: https://github.com/gin-gonic/gin\n  Push  URL: https://github.com/gin-gonic/gin\n  HEAD branch: develop\n  Remote branches:\n    benchmarks            tracked\n    better-bind-errors    tracked\n    develop               tracked\n    fasthttp              tracked\n    fix-binding           tracked\n    fix-tests             tracked\n    gh-pages              tracked\n    honteng-bind_test     tracked\n    master                tracked\n    new-binding-validator tracked\n    new-catch-all         tracked\n    performance           tracked\n    routes-list           tracked\n  Local branch configured for 'git pull':\n    develop merges with remote develop\n  Local ref configured for 'git push':\n    develop pushes to develop (local out of date)\n`, \"develop\", false},\n\t\t{\"test\", \"\", \"\", true},\n\t}\n\n\tfor i, test := range cases {\n\t\tv, e := gitDetermineDefaultBranch(test.r, test.o)\n\t\tif v != test.v {\n\t\t\tt.Errorf(\"%d Unexpected value returned: %s, wanted %s\", i, v, test.v)\n\t\t}\n\t\tif e != nil {\n\t\t\tt.Log(\"Err\", e.Error())\n\t\t}\n\t\tif test.err && e == nil {\n\t\t\tt.Errorf(\"%d Test should err, but didn't\", i)\n\t\t}\n\n\t\tif !test.err && e != nil {\n\t\t\tt.Errorf(\"%d Test shouldn't err, but did with: %s\", i, e)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 1.296875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst version = 80\n\nvar cmdVersion = &Command{\n\tName:  \"version\",\n\tShort: \"show version info\",\n\tLong: `\n\nDisplays the version of godep as well as the target OS, architecture and go runtime version.\n`,\n\tRun: runVersion,\n}\n\nfunc versionString() string {\n\treturn fmt.Sprintf(\"godep v%d (%s/%s/%s)\", version, runtime.GOOS, runtime.GOARCH, runtime.Version())\n}\n\nfunc runVersion(cmd *Command, args []string) {\n\tfmt.Printf(\"%s\\n\", versionString())\n}\n\nfunc GoVersionFields(c rune) bool {\n\treturn c == 'g' || c == 'o' || c == '.'\n}\n\n// isSameOrNewer go version (goA.B)\n// go1.6 >= go1.6 == true\n// go1.5 >= go1.6 == false\nfunc isSameOrNewer(base, check string) bool {\n\tif base == check {\n\t\treturn true\n\t}\n\tif strings.HasPrefix(check, \"devel-\") {\n\t\treturn true\n\t}\n\tbp := strings.FieldsFunc(base, GoVersionFields)\n\tcp := strings.FieldsFunc(check, GoVersionFields)\n\tif len(bp) < 2 || len(cp) < 2 {\n\t\tlog.Fatalf(\"Error comparing %s to %s\\n\", base, check)\n\t}\n\tif bp[0] == cp[0] { // We only have go version 1 right now\n\t\tbm, err := strconv.Atoi(bp[1])\n\t\t// These errors are unlikely and there is nothing nice to do here anyway\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tcm, err := strconv.Atoi(cp[1])\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\treturn cm >= bm\n\t}\n\treturn false\n}\n"
        }
      ]
    }
  ]
}