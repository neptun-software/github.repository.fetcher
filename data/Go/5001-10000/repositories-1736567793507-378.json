{
  "metadata": {
    "timestamp": 1736567793507,
    "page": 378,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "c-bata/go-prompt",
      "stars": 5324,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.263671875,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\nbin/\n\n# Folders\npkg/\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n\n# Glide\nvendor/\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 2.8271484375,
          "content": "# Change Log\n\n## v0.3.0 (2018/??/??)\n\nnext release.\n\n## v0.2.3 (2018/10/25)\n\n### What's new?\n\n* Add `prompt.FuzzyFilter` for fuzzy matching at [#92](https://github.com/c-bata/go-prompt/pull/92).\n* Add `OptionShowCompletionAtStart` to show completion at start at [#100](https://github.com/c-bata/go-prompt/pull/100).\n* Add `prompt.NewStderrWriter` at [#102](https://github.com/c-bata/go-prompt/pull/102).\n\n### Fixed\n\n* Fix resetting display attributes (please see [pull #104](https://github.com/c-bata/go-prompt/pull/104) for more details).\n* Fix error handling of Flush function in ConsoleWriter (please see [pull #97](https://github.com/c-bata/go-prompt/pull/97) for more details).\n* Fix panic problem when reading from stdin before starting the prompt (please see [issue #88](https://github.com/c-bata/go-prompt/issues/88) for more details).\n\n### Removed or Deprecated\n\n* `prompt.NewStandardOutputWriter` is deprecated. Please use `prompt.NewStdoutWriter`.\n\n## v0.2.2 (2018/06/28)\n\n### What's new?\n\n* Support CJK(Chinese, Japanese and Korean) and Cyrillic characters.\n* Add OptionCompletionWordSeparator(x string) to customize insertion points for completions.\n    * To support this, text query functions by arbitrary word separator are added in Document (please see [here](https://github.com/c-bata/go-prompt/pull/79) for more details).\n* Add FilePathCompleter to complete file path on your system.\n* Add option to customize ascii code key bindings.\n* Add GetWordAfterCursor method in Document.\n\n### Removed or Deprecated\n\n* prompt.Choose shortcut function is deprecated.\n\n## v0.2.1 (2018/02/14)\n\n### What's New?\n\n* ~~It seems that windows support is almost perfect.~~\n    * A critical bug is found :( When you change a terminal window size, the layout will be broken because current implementation cannot catch signal for updating window size on Windows.\n\n### Fixed\n\n* Fix a Shift+Tab handling on Windows.\n* Fix 4-dimension arrow keys handling on Windows.\n\n## v0.2.0 (2018/02/13)\n\n### What's New?\n\n* Supports scrollbar when there are too many matched suggestions\n* Windows support (but please caution because this is still not perfect).\n* Add OptionLivePrefix to update the prefix dynamically\n* Implement clear screen by `Ctrl+L`.\n\n### Fixed\n\n* Fix the behavior of `Ctrl+W` keybind.\n* Fix the panic because when running on a docker container (please see [here](https://github.com/c-bata/go-prompt/pull/32) for details).\n* Fix panic when making terminal window small size after input 2 lines of texts. See [here](https://github.com/c-bata/go-prompt/issues/37) for details).\n* And also fixed many bugs that layout is broken when using Terminal.app, GNU Terminal and a Goland(IntelliJ).\n\n### News\n\nNew core developers are joined (alphabetical order).\n\n* Nao Yonashiro (Github @orisano)\n* Ryoma Abe (Github @Allajah)\n* Yusuke Nakamura (Github @unasuke)\n\n\n## v0.1.0 (2017/08/15)\n\nInitial Release\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.046875,
          "content": "MIT License\n\nCopyright (c) 2017 Masashi SHIBATA\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.1494140625,
          "content": ".DEFAULT_GOAL := help\n\nSOURCES := $(shell find . -prune -o -name \"*.go\" -not -name '*_test.go' -print)\n\nGOIMPORTS ?= goimports\nGOCILINT ?= golangci-lint\n\n.PHONY: setup\nsetup:  ## Setup for required tools.\n\tgo get -u golang.org/x/tools/cmd/goimports\n\tgo get -u github.com/golangci/golangci-lint/cmd/golangci-lint\n\tgo get -u golang.org/x/tools/cmd/stringer\n\n.PHONY: fmt\nfmt: $(SOURCES) ## Formatting source codes.\n\t@$(GOIMPORTS) -w $^\n\n.PHONY: lint\nlint: ## Run golangci-lint.\n\t@$(GOCILINT) run --no-config --disable-all --enable=goimports --enable=misspell ./...\n\n.PHONY: test\ntest:  ## Run tests with race condition checking.\n\t@go test -race ./...\n\n.PHONY: bench\nbench:  ## Run benchmarks.\n\t@go test -bench=. -run=- -benchmem ./...\n\n.PHONY: coverage\ncover:  ## Run the tests.\n\t@go test -coverprofile=coverage.o\n\t@go tool cover -func=coverage.o\n\n.PHONY: generate\ngenerate: ## Run go generate\n\t@go generate ./...\n\n.PHONY: build\nbuild: ## Build example command lines.\n\t./_example/build.sh\n\n.PHONY: help\nhelp: ## Show help text\n\t@echo \"Commands:\"\n\t@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = \":.*?## \"}; {printf \"  \\033[36m%-10s\\033[0m %s\\n\", $$1, $$2}'\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.0400390625,
          "content": "# go-prompt\n\n[![Go Report Card](https://goreportcard.com/badge/github.com/c-bata/go-prompt)](https://goreportcard.com/report/github.com/c-bata/go-prompt)\n![Software License](https://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat-square)\n[![GoDoc](https://godoc.org/github.com/c-bata/go-prompt?status.svg)](https://godoc.org/github.com/c-bata/go-prompt) \n![tests](https://github.com/c-bata/go-prompt/workflows/tests/badge.svg)\n\nA library for building powerful interactive prompts inspired by [python-prompt-toolkit](https://github.com/jonathanslenders/python-prompt-toolkit),\nmaking it easier to build cross-platform command line tools using Go.\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/c-bata/go-prompt\"\n)\n\nfunc completer(d prompt.Document) []prompt.Suggest {\n\ts := []prompt.Suggest{\n\t\t{Text: \"users\", Description: \"Store the username and age\"},\n\t\t{Text: \"articles\", Description: \"Store the article text posted by user\"},\n\t\t{Text: \"comments\", Description: \"Store the text commented to articles\"},\n\t}\n\treturn prompt.FilterHasPrefix(s, d.GetWordBeforeCursor(), true)\n}\n\nfunc main() {\n\tfmt.Println(\"Please select table.\")\n\tt := prompt.Input(\"> \", completer)\n\tfmt.Println(\"You selected \" + t)\n}\n```\n\n#### Projects using go-prompt\n\n* [c-bata/kube-prompt : An interactive kubernetes client featuring auto-complete written in Go.](https://github.com/c-bata/kube-prompt)\n* [rancher/cli : The Rancher Command Line Interface (CLI)is a unified tool to manage your Rancher server](https://github.com/rancher/cli)\n* [kubicorn/kubicorn : Simple, cloud native infrastructure for Kubernetes.](https://github.com/kubicorn/kubicorn)\n* [cch123/asm-cli : Interactive shell of assembly language(X86/X64) based on unicorn and rasm2](https://github.com/cch123/asm-cli)\n* [ktr0731/evans : more expressive universal gRPC client](https://github.com/ktr0731/evans)\n* [CrushedPixel/moshpit: A Command-line tool for datamoshing.](https://github.com/CrushedPixel/moshpit)\n* [last-ent/testy-go: Testy Go: A tool for easy testing!](https://github.com/last-ent/testy-go)\n* [tiagorlampert/CHAOS: a PoC that allow generate payloads and control remote operating systems.](https://github.com/tiagorlampert/CHAOS)\n* [abs-lang/abs: ABS is a scripting language that works best on terminal. It tries to combine the elegance of languages such as Python, or Ruby, to the convenience of Bash.](https://github.com/abs-lang/abs)\n* [takashabe/btcli: btcli is a CLI client for the Bigtable. Has many read options and auto-completion.](https://github.com/takashabe/btcli)\n* [ysn2233/kafka-prompt: An interactive kafka-prompt(kafka-shell) built on existing kafka command client](https://github.com/ysn2233/kafka-prompt)\n* [fishi0x01/vsh: HashiCorp Vault interactive shell](https://github.com/fishi0x01/vsh)\n* [mstrYoda/docker-shell: A simple interactive prompt for docker](https://github.com/mstrYoda/docker-shell)\n* [c-bata/gh-prompt: An interactive GitHub CLI featuring auto-complete.](https://github.com/c-bata/gh-prompt)\n* [docker-slim/docker-slim: Don't change anything in your Docker container image and minify it by up to 30x (and for compiled languages even more) making it secure too! (free and open source)](https://github.com/docker-slim/docker-slim)\n* [rueyaa332266/ezcron: Ezcron is a CLI tool, helping you deal with cron expression easier.](https://github.com/rueyaa332266/ezcron)\n* [qingstor/qsctl: Advanced command line tool for QingStor Object Storage.](https://github.com/qingstor/qsctl)\n* [segmentio/topicctl: Tool for declarative management of Kafka topics](https://github.com/segmentio/topicctl)\n* [chriswalz/bit: Bit is a modern Git CLI](https://github.com/chriswalz/bit)\n* (If you create a CLI utility using go-prompt and want your own project to be listed here, please submit a GitHub issue.)\n\n## Features\n\n### Powerful auto-completion\n\n[![demo](https://github.com/c-bata/assets/raw/master/go-prompt/kube-prompt.gif)](https://github.com/c-bata/kube-prompt)\n\n(This is a GIF animation of kube-prompt.)\n\n### Flexible options\n\ngo-prompt provides many options. Please check [option section of GoDoc](https://godoc.org/github.com/c-bata/go-prompt#Option) for more details.\n\n[![options](https://github.com/c-bata/assets/raw/master/go-prompt/prompt-options.png)](#flexible-options)\n\n### Keyboard Shortcuts\n\nEmacs-like keyboard shortcuts are available by default (these also are the default shortcuts in Bash shell).\nYou can customize and expand these shortcuts.\n\n[![keyboard shortcuts](https://github.com/c-bata/assets/raw/master/go-prompt/keyboard-shortcuts.gif)](#keyboard-shortcuts)\n\nKey Binding          | Description\n---------------------|---------------------------------------------------------\n<kbd>Ctrl + A</kbd>  | Go to the beginning of the line (Home)\n<kbd>Ctrl + E</kbd>  | Go to the end of the line (End)\n<kbd>Ctrl + P</kbd>  | Previous command (Up arrow)\n<kbd>Ctrl + N</kbd>  | Next command (Down arrow)\n<kbd>Ctrl + F</kbd>  | Forward one character\n<kbd>Ctrl + B</kbd>  | Backward one character\n<kbd>Ctrl + D</kbd>  | Delete character under the cursor\n<kbd>Ctrl + H</kbd>  | Delete character before the cursor (Backspace)\n<kbd>Ctrl + W</kbd>  | Cut the word before the cursor to the clipboard\n<kbd>Ctrl + K</kbd>  | Cut the line after the cursor to the clipboard\n<kbd>Ctrl + U</kbd>  | Cut the line before the cursor to the clipboard\n<kbd>Ctrl + L</kbd>  | Clear the screen\n\n### History\n\nYou can use <kbd>Up arrow</kbd> and <kbd>Down arrow</kbd> to walk through the history of commands executed.\n\n[![History](https://github.com/c-bata/assets/raw/master/go-prompt/history.gif)](#history)\n\n### Multiple platform support\n\nWe have confirmed go-prompt works fine in the following terminals:\n\n* iTerm2 (macOS)\n* Terminal.app (macOS)\n* Command Prompt (Windows)\n* gnome-terminal (Ubuntu)\n\n## Links\n\n* [Change Log](./CHANGELOG.md)\n* [GoDoc](http://godoc.org/github.com/c-bata/go-prompt)\n* [gocover.io](https://gocover.io/github.com/c-bata/go-prompt)\n\n## Author\n\nMasashi Shibata\n\n* Twitter: [@c\\_bata\\_](https://twitter.com/c_bata_/)\n* Github: [@c-bata](https://github.com/c-bata/)\n\n## License\n\nThis software is licensed under the MIT license, see [LICENSE](./LICENSE) for more information.\n\n"
        },
        {
          "name": "_example",
          "type": "tree",
          "content": null
        },
        {
          "name": "_tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "buffer.go",
          "type": "blob",
          "size": 5.6455078125,
          "content": "package prompt\n\nimport (\n\t\"strings\"\n\n\t\"github.com/c-bata/go-prompt/internal/debug\"\n)\n\n// Buffer emulates the console buffer.\ntype Buffer struct {\n\tworkingLines    []string // The working lines. Similar to history\n\tworkingIndex    int\n\tcursorPosition  int\n\tcacheDocument   *Document\n\tpreferredColumn int // Remember the original column for the next up/down movement.\n\tlastKeyStroke   Key\n}\n\n// Text returns string of the current line.\nfunc (b *Buffer) Text() string {\n\treturn b.workingLines[b.workingIndex]\n}\n\n// Document method to return document instance from the current text and cursor position.\nfunc (b *Buffer) Document() (d *Document) {\n\tif b.cacheDocument == nil ||\n\t\tb.cacheDocument.Text != b.Text() ||\n\t\tb.cacheDocument.cursorPosition != b.cursorPosition {\n\t\tb.cacheDocument = &Document{\n\t\t\tText:           b.Text(),\n\t\t\tcursorPosition: b.cursorPosition,\n\t\t}\n\t}\n\tb.cacheDocument.lastKey = b.lastKeyStroke\n\treturn b.cacheDocument\n}\n\n// DisplayCursorPosition returns the cursor position on rendered text on terminal emulators.\n// So if Document is \"日本(cursor)語\", DisplayedCursorPosition returns 4 because '日' and '本' are double width characters.\nfunc (b *Buffer) DisplayCursorPosition() int {\n\treturn b.Document().DisplayCursorPosition()\n}\n\n// InsertText insert string from current line.\nfunc (b *Buffer) InsertText(v string, overwrite bool, moveCursor bool) {\n\tor := []rune(b.Text())\n\toc := b.cursorPosition\n\n\tif overwrite {\n\t\toverwritten := string(or[oc : oc+len(v)])\n\t\tif strings.Contains(overwritten, \"\\n\") {\n\t\t\ti := strings.IndexAny(overwritten, \"\\n\")\n\t\t\toverwritten = overwritten[:i]\n\t\t}\n\t\tb.setText(string(or[:oc]) + v + string(or[oc+len(overwritten):]))\n\t} else {\n\t\tb.setText(string(or[:oc]) + v + string(or[oc:]))\n\t}\n\n\tif moveCursor {\n\t\tb.cursorPosition += len([]rune(v))\n\t}\n}\n\n// SetText method to set text and update cursorPosition.\n// (When doing this, make sure that the cursor_position is valid for this text.\n// text/cursor_position should be consistent at any time, otherwise set a Document instead.)\nfunc (b *Buffer) setText(v string) {\n\tdebug.Assert(b.cursorPosition <= len([]rune(v)), \"length of input should be shorter than cursor position\")\n\tb.workingLines[b.workingIndex] = v\n}\n\n// Set cursor position. Return whether it changed.\nfunc (b *Buffer) setCursorPosition(p int) {\n\tif p > 0 {\n\t\tb.cursorPosition = p\n\t} else {\n\t\tb.cursorPosition = 0\n\t}\n}\n\nfunc (b *Buffer) setDocument(d *Document) {\n\tb.cacheDocument = d\n\tb.setCursorPosition(d.cursorPosition) // Call before setText because setText check the relation between cursorPosition and line length.\n\tb.setText(d.Text)\n}\n\n// CursorLeft move to left on the current line.\nfunc (b *Buffer) CursorLeft(count int) {\n\tl := b.Document().GetCursorLeftPosition(count)\n\tb.cursorPosition += l\n}\n\n// CursorRight move to right on the current line.\nfunc (b *Buffer) CursorRight(count int) {\n\tl := b.Document().GetCursorRightPosition(count)\n\tb.cursorPosition += l\n}\n\n// CursorUp move cursor to the previous line.\n// (for multi-line edit).\nfunc (b *Buffer) CursorUp(count int) {\n\torig := b.preferredColumn\n\tif b.preferredColumn == -1 { // -1 means nil\n\t\torig = b.Document().CursorPositionCol()\n\t}\n\tb.cursorPosition += b.Document().GetCursorUpPosition(count, orig)\n\n\t// Remember the original column for the next up/down movement.\n\tb.preferredColumn = orig\n}\n\n// CursorDown move cursor to the next line.\n// (for multi-line edit).\nfunc (b *Buffer) CursorDown(count int) {\n\torig := b.preferredColumn\n\tif b.preferredColumn == -1 { // -1 means nil\n\t\torig = b.Document().CursorPositionCol()\n\t}\n\tb.cursorPosition += b.Document().GetCursorDownPosition(count, orig)\n\n\t// Remember the original column for the next up/down movement.\n\tb.preferredColumn = orig\n}\n\n// DeleteBeforeCursor delete specified number of characters before cursor and return the deleted text.\nfunc (b *Buffer) DeleteBeforeCursor(count int) (deleted string) {\n\tdebug.Assert(count >= 0, \"count should be positive\")\n\tr := []rune(b.Text())\n\n\tif b.cursorPosition > 0 {\n\t\tstart := b.cursorPosition - count\n\t\tif start < 0 {\n\t\t\tstart = 0\n\t\t}\n\t\tdeleted = string(r[start:b.cursorPosition])\n\t\tb.setDocument(&Document{\n\t\t\tText:           string(r[:start]) + string(r[b.cursorPosition:]),\n\t\t\tcursorPosition: b.cursorPosition - len([]rune(deleted)),\n\t\t})\n\t}\n\treturn\n}\n\n// NewLine means CR.\nfunc (b *Buffer) NewLine(copyMargin bool) {\n\tif copyMargin {\n\t\tb.InsertText(\"\\n\"+b.Document().leadingWhitespaceInCurrentLine(), false, true)\n\t} else {\n\t\tb.InsertText(\"\\n\", false, true)\n\t}\n}\n\n// Delete specified number of characters and Return the deleted text.\nfunc (b *Buffer) Delete(count int) (deleted string) {\n\tr := []rune(b.Text())\n\tif b.cursorPosition < len(r) {\n\t\tdeleted = b.Document().TextAfterCursor()[:count]\n\t\tb.setText(string(r[:b.cursorPosition]) + string(r[b.cursorPosition+len(deleted):]))\n\t}\n\treturn\n}\n\n// JoinNextLine joins the next line to the current one by deleting the line ending after the current line.\nfunc (b *Buffer) JoinNextLine(separator string) {\n\tif !b.Document().OnLastLine() {\n\t\tb.cursorPosition += b.Document().GetEndOfLinePosition()\n\t\tb.Delete(1)\n\t\t// Remove spaces\n\t\tb.setText(b.Document().TextBeforeCursor() + separator + strings.TrimLeft(b.Document().TextAfterCursor(), \" \"))\n\t}\n}\n\n// SwapCharactersBeforeCursor swaps the last two characters before the cursor.\nfunc (b *Buffer) SwapCharactersBeforeCursor() {\n\tif b.cursorPosition >= 2 {\n\t\tx := b.Text()[b.cursorPosition-2 : b.cursorPosition-1]\n\t\ty := b.Text()[b.cursorPosition-1 : b.cursorPosition]\n\t\tb.setText(b.Text()[:b.cursorPosition-2] + y + x + b.Text()[b.cursorPosition:])\n\t}\n}\n\n// NewBuffer is constructor of Buffer struct.\nfunc NewBuffer() (b *Buffer) {\n\tb = &Buffer{\n\t\tworkingLines:    []string{\"\"},\n\t\tworkingIndex:    0,\n\t\tpreferredColumn: -1, // -1 means nil\n\t}\n\treturn\n}\n"
        },
        {
          "name": "buffer_test.go",
          "type": "blob",
          "size": 4.8486328125,
          "content": "package prompt\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestNewBuffer(t *testing.T) {\n\tb := NewBuffer()\n\tif b.workingIndex != 0 {\n\t\tt.Errorf(\"workingIndex should be %#v, got %#v\", 0, b.workingIndex)\n\t}\n\tif !reflect.DeepEqual(b.workingLines, []string{\"\"}) {\n\t\tt.Errorf(\"workingLines should be %#v, got %#v\", []string{\"\"}, b.workingLines)\n\t}\n}\n\nfunc TestBuffer_InsertText(t *testing.T) {\n\tb := NewBuffer()\n\tb.InsertText(\"some_text\", false, true)\n\n\tif b.Text() != \"some_text\" {\n\t\tt.Errorf(\"Text should be %#v, got %#v\", \"some_text\", b.Text())\n\t}\n\n\tif b.cursorPosition != len(\"some_text\") {\n\t\tt.Errorf(\"cursorPosition should be %#v, got %#v\", len(\"some_text\"), b.cursorPosition)\n\t}\n}\n\nfunc TestBuffer_CursorMovement(t *testing.T) {\n\tb := NewBuffer()\n\tb.InsertText(\"some_text\", false, true)\n\n\tb.CursorLeft(1)\n\tb.CursorLeft(2)\n\tb.CursorRight(1)\n\tb.InsertText(\"A\", false, true)\n\tif b.Text() != \"some_teAxt\" {\n\t\tt.Errorf(\"Text should be %#v, got %#v\", \"some_teAxt\", b.Text())\n\t}\n\tif b.cursorPosition != len(\"some_teA\") {\n\t\tt.Errorf(\"Text should be %#v, got %#v\", len(\"some_teA\"), b.cursorPosition)\n\t}\n\n\t// Moving over left character counts.\n\tb.CursorLeft(100)\n\tb.InsertText(\"A\", false, true)\n\tif b.Text() != \"Asome_teAxt\" {\n\t\tt.Errorf(\"Text should be %#v, got %#v\", \"some_teAxt\", b.Text())\n\t}\n\tif b.cursorPosition != len(\"A\") {\n\t\tt.Errorf(\"Text should be %#v, got %#v\", len(\"some_teA\"), b.cursorPosition)\n\t}\n\n\t// TODO: Going right already at right end.\n}\n\nfunc TestBuffer_CursorMovement_WithMultiByte(t *testing.T) {\n\tb := NewBuffer()\n\tb.InsertText(\"あいうえお\", false, true)\n\tb.CursorLeft(1)\n\tif l := b.Document().TextAfterCursor(); l != \"お\" {\n\t\tt.Errorf(\"Should be 'お', but got %s\", l)\n\t}\n}\n\nfunc TestBuffer_CursorUp(t *testing.T) {\n\tb := NewBuffer()\n\tb.InsertText(\"long line1\\nline2\", false, true)\n\tb.CursorUp(1)\n\tif b.Document().cursorPosition != 5 {\n\t\tt.Errorf(\"Should be %#v, got %#v\", 5, b.Document().cursorPosition)\n\t}\n\n\t// Going up when already at the top.\n\tb.CursorUp(1)\n\tif b.Document().cursorPosition != 5 {\n\t\tt.Errorf(\"Should be %#v, got %#v\", 5, b.Document().cursorPosition)\n\t}\n\n\t// Going up to a line that's shorter.\n\tb.setDocument(&Document{})\n\tb.InsertText(\"line1\\nlong line2\", false, true)\n\tb.CursorUp(1)\n\tif b.Document().cursorPosition != 5 {\n\t\tt.Errorf(\"Should be %#v, got %#v\", 5, b.Document().cursorPosition)\n\t}\n}\n\nfunc TestBuffer_CursorDown(t *testing.T) {\n\tb := NewBuffer()\n\tb.InsertText(\"line1\\nline2\", false, true)\n\tb.cursorPosition = 3\n\n\t// Normally going down\n\tb.CursorDown(1)\n\tif b.Document().cursorPosition != len(\"line1\\nlin\") {\n\t\tt.Errorf(\"Should be %#v, got %#v\", len(\"line1\\nlin\"), b.Document().cursorPosition)\n\t}\n\n\t// Going down to a line that's storter.\n\tb = NewBuffer()\n\tb.InsertText(\"long line1\\na\\nb\", false, true)\n\tb.cursorPosition = 3\n\tb.CursorDown(1)\n\tif b.Document().cursorPosition != len(\"long line1\\na\") {\n\t\tt.Errorf(\"Should be %#v, got %#v\", len(\"long line1\\na\"), b.Document().cursorPosition)\n\t}\n}\n\nfunc TestBuffer_DeleteBeforeCursor(t *testing.T) {\n\tb := NewBuffer()\n\tb.InsertText(\"some_text\", false, true)\n\tb.CursorLeft(2)\n\tdeleted := b.DeleteBeforeCursor(1)\n\n\tif b.Text() != \"some_txt\" {\n\t\tt.Errorf(\"Should be %#v, got %#v\", \"some_txt\", b.Text())\n\t}\n\tif deleted != \"e\" {\n\t\tt.Errorf(\"Should be %#v, got %#v\", deleted, \"e\")\n\t}\n\tif b.cursorPosition != len(\"some_t\") {\n\t\tt.Errorf(\"Should be %#v, got %#v\", len(\"some_t\"), b.cursorPosition)\n\t}\n\n\t// Delete over the characters length before cursor.\n\tdeleted = b.DeleteBeforeCursor(100)\n\tif deleted != \"some_t\" {\n\t\tt.Errorf(\"Should be %#v, got %#v\", \"some_t\", deleted)\n\t}\n\tif b.Text() != \"xt\" {\n\t\tt.Errorf(\"Should be %#v, got %#v\", \"xt\", b.Text())\n\t}\n\n\t// If cursor position is a beginning of line, it has no effect.\n\tdeleted = b.DeleteBeforeCursor(1)\n\tif deleted != \"\" {\n\t\tt.Errorf(\"Should be empty, got %#v\", deleted)\n\t}\n}\n\nfunc TestBuffer_NewLine(t *testing.T) {\n\tb := NewBuffer()\n\tb.InsertText(\"  hello\", false, true)\n\tb.NewLine(false)\n\tac := b.Text()\n\tex := \"  hello\\n\"\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n\n\tb = NewBuffer()\n\tb.InsertText(\"  hello\", false, true)\n\tb.NewLine(true)\n\tac = b.Text()\n\tex = \"  hello\\n  \"\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n}\n\nfunc TestBuffer_JoinNextLine(t *testing.T) {\n\tb := NewBuffer()\n\tb.InsertText(\"line1\\nline2\\nline3\", false, true)\n\tb.CursorUp(1)\n\tb.JoinNextLine(\" \")\n\n\tac := b.Text()\n\tex := \"line1\\nline2 line3\"\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n\n\t// Test when there is no '\\n' in the text\n\tb = NewBuffer()\n\tb.InsertText(\"line1\", false, true)\n\tb.cursorPosition = 0\n\tb.JoinNextLine(\" \")\n\tac = b.Text()\n\tex = \"line1\"\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n}\n\nfunc TestBuffer_SwapCharactersBeforeCursor(t *testing.T) {\n\tb := NewBuffer()\n\tb.InsertText(\"hello world\", false, true)\n\tb.CursorLeft(2)\n\tb.SwapCharactersBeforeCursor()\n\tac := b.Text()\n\tex := \"hello wrold\"\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n}\n"
        },
        {
          "name": "completer",
          "type": "tree",
          "content": null
        },
        {
          "name": "completion.go",
          "type": "blob",
          "size": 4.3857421875,
          "content": "package prompt\n\nimport (\n\t\"strings\"\n\n\t\"github.com/c-bata/go-prompt/internal/debug\"\n\trunewidth \"github.com/mattn/go-runewidth\"\n)\n\nconst (\n\tshortenSuffix = \"...\"\n\tleftPrefix    = \" \"\n\tleftSuffix    = \" \"\n\trightPrefix   = \" \"\n\trightSuffix   = \" \"\n)\n\nvar (\n\tleftMargin       = runewidth.StringWidth(leftPrefix + leftSuffix)\n\trightMargin      = runewidth.StringWidth(rightPrefix + rightSuffix)\n\tcompletionMargin = leftMargin + rightMargin\n)\n\n// Suggest is printed when completing.\ntype Suggest struct {\n\tText        string\n\tDescription string\n}\n\n// CompletionManager manages which suggestion is now selected.\ntype CompletionManager struct {\n\tselected  int // -1 means nothing one is selected.\n\ttmp       []Suggest\n\tmax       uint16\n\tcompleter Completer\n\n\tverticalScroll int\n\twordSeparator  string\n\tshowAtStart    bool\n}\n\n// GetSelectedSuggestion returns the selected item.\nfunc (c *CompletionManager) GetSelectedSuggestion() (s Suggest, ok bool) {\n\tif c.selected == -1 {\n\t\treturn Suggest{}, false\n\t} else if c.selected < -1 {\n\t\tdebug.Assert(false, \"must not reach here\")\n\t\tc.selected = -1\n\t\treturn Suggest{}, false\n\t}\n\treturn c.tmp[c.selected], true\n}\n\n// GetSuggestions returns the list of suggestion.\nfunc (c *CompletionManager) GetSuggestions() []Suggest {\n\treturn c.tmp\n}\n\n// Reset to select nothing.\nfunc (c *CompletionManager) Reset() {\n\tc.selected = -1\n\tc.verticalScroll = 0\n\tc.Update(*NewDocument())\n}\n\n// Update to update the suggestions.\nfunc (c *CompletionManager) Update(in Document) {\n\tc.tmp = c.completer(in)\n}\n\n// Previous to select the previous suggestion item.\nfunc (c *CompletionManager) Previous() {\n\tif c.verticalScroll == c.selected && c.selected > 0 {\n\t\tc.verticalScroll--\n\t}\n\tc.selected--\n\tc.update()\n}\n\n// Next to select the next suggestion item.\nfunc (c *CompletionManager) Next() {\n\tif c.verticalScroll+int(c.max)-1 == c.selected {\n\t\tc.verticalScroll++\n\t}\n\tc.selected++\n\tc.update()\n}\n\n// Completing returns whether the CompletionManager selects something one.\nfunc (c *CompletionManager) Completing() bool {\n\treturn c.selected != -1\n}\n\nfunc (c *CompletionManager) update() {\n\tmax := int(c.max)\n\tif len(c.tmp) < max {\n\t\tmax = len(c.tmp)\n\t}\n\n\tif c.selected >= len(c.tmp) {\n\t\tc.Reset()\n\t} else if c.selected < -1 {\n\t\tc.selected = len(c.tmp) - 1\n\t\tc.verticalScroll = len(c.tmp) - max\n\t}\n}\n\nfunc deleteBreakLineCharacters(s string) string {\n\ts = strings.Replace(s, \"\\n\", \"\", -1)\n\ts = strings.Replace(s, \"\\r\", \"\", -1)\n\treturn s\n}\n\nfunc formatTexts(o []string, max int, prefix, suffix string) (new []string, width int) {\n\tl := len(o)\n\tn := make([]string, l)\n\n\tlenPrefix := runewidth.StringWidth(prefix)\n\tlenSuffix := runewidth.StringWidth(suffix)\n\tlenShorten := runewidth.StringWidth(shortenSuffix)\n\tmin := lenPrefix + lenSuffix + lenShorten\n\tfor i := 0; i < l; i++ {\n\t\to[i] = deleteBreakLineCharacters(o[i])\n\n\t\tw := runewidth.StringWidth(o[i])\n\t\tif width < w {\n\t\t\twidth = w\n\t\t}\n\t}\n\n\tif width == 0 {\n\t\treturn n, 0\n\t}\n\tif min >= max {\n\t\treturn n, 0\n\t}\n\tif lenPrefix+width+lenSuffix > max {\n\t\twidth = max - lenPrefix - lenSuffix\n\t}\n\n\tfor i := 0; i < l; i++ {\n\t\tx := runewidth.StringWidth(o[i])\n\t\tif x <= width {\n\t\t\tspaces := strings.Repeat(\" \", width-x)\n\t\t\tn[i] = prefix + o[i] + spaces + suffix\n\t\t} else if x > width {\n\t\t\tx := runewidth.Truncate(o[i], width, shortenSuffix)\n\t\t\t// When calling runewidth.Truncate(\"您好xxx您好xxx\", 11, \"...\") returns \"您好xxx...\"\n\t\t\t// But the length of this result is 10. So we need fill right using runewidth.FillRight.\n\t\t\tn[i] = prefix + runewidth.FillRight(x, width) + suffix\n\t\t}\n\t}\n\treturn n, lenPrefix + width + lenSuffix\n}\n\nfunc formatSuggestions(suggests []Suggest, max int) (new []Suggest, width int) {\n\tnum := len(suggests)\n\tnew = make([]Suggest, num)\n\n\tleft := make([]string, num)\n\tfor i := 0; i < num; i++ {\n\t\tleft[i] = suggests[i].Text\n\t}\n\tright := make([]string, num)\n\tfor i := 0; i < num; i++ {\n\t\tright[i] = suggests[i].Description\n\t}\n\n\tleft, leftWidth := formatTexts(left, max, leftPrefix, leftSuffix)\n\tif leftWidth == 0 {\n\t\treturn []Suggest{}, 0\n\t}\n\tright, rightWidth := formatTexts(right, max-leftWidth, rightPrefix, rightSuffix)\n\n\tfor i := 0; i < num; i++ {\n\t\tnew[i] = Suggest{Text: left[i], Description: right[i]}\n\t}\n\treturn new, leftWidth + rightWidth\n}\n\n// NewCompletionManager returns initialized CompletionManager object.\nfunc NewCompletionManager(completer Completer, max uint16) *CompletionManager {\n\treturn &CompletionManager{\n\t\tselected:  -1,\n\t\tmax:       max,\n\t\tcompleter: completer,\n\n\t\tverticalScroll: 0,\n\t}\n}\n"
        },
        {
          "name": "completion_test.go",
          "type": "blob",
          "size": 6.845703125,
          "content": "package prompt\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFormatShortSuggestion(t *testing.T) {\n\tvar scenarioTable = []struct {\n\t\tin       []Suggest\n\t\texpected []Suggest\n\t\tmax      int\n\t\texWidth  int\n\t}{\n\t\t{\n\t\t\tin: []Suggest{\n\t\t\t\t{Text: \"foo\"},\n\t\t\t\t{Text: \"bar\"},\n\t\t\t\t{Text: \"fuga\"},\n\t\t\t},\n\t\t\texpected: []Suggest{\n\t\t\t\t{Text: \" foo  \"},\n\t\t\t\t{Text: \" bar  \"},\n\t\t\t\t{Text: \" fuga \"},\n\t\t\t},\n\t\t\tmax:     100,\n\t\t\texWidth: 6,\n\t\t},\n\t\t{\n\t\t\tin: []Suggest{\n\t\t\t\t{Text: \"apple\", Description: \"This is apple.\"},\n\t\t\t\t{Text: \"banana\", Description: \"This is banana.\"},\n\t\t\t\t{Text: \"coconut\", Description: \"This is coconut.\"},\n\t\t\t},\n\t\t\texpected: []Suggest{\n\t\t\t\t{Text: \" apple   \", Description: \" This is apple.   \"},\n\t\t\t\t{Text: \" banana  \", Description: \" This is banana.  \"},\n\t\t\t\t{Text: \" coconut \", Description: \" This is coconut. \"},\n\t\t\t},\n\t\t\tmax:     100,\n\t\t\texWidth: len(\" apple   \" + \" This is apple.   \"),\n\t\t},\n\t\t{\n\t\t\tin: []Suggest{\n\t\t\t\t{Text: \"This is apple.\"},\n\t\t\t\t{Text: \"This is banana.\"},\n\t\t\t\t{Text: \"This is coconut.\"},\n\t\t\t},\n\t\t\texpected: []Suggest{\n\t\t\t\t{Text: \" Thi... \"},\n\t\t\t\t{Text: \" Thi... \"},\n\t\t\t\t{Text: \" Thi... \"},\n\t\t\t},\n\t\t\tmax:     8,\n\t\t\texWidth: 8,\n\t\t},\n\t\t{\n\t\t\tin: []Suggest{\n\t\t\t\t{Text: \"This is apple.\"},\n\t\t\t\t{Text: \"This is banana.\"},\n\t\t\t\t{Text: \"This is coconut.\"},\n\t\t\t},\n\t\t\texpected: []Suggest{},\n\t\t\tmax:      3,\n\t\t\texWidth:  0,\n\t\t},\n\t\t{\n\t\t\tin: []Suggest{\n\t\t\t\t{Text: \"--all-namespaces\", Description: \"-------------------------------------------------------------------------------------------------------------------------------------------\"},\n\t\t\t\t{Text: \"--allow-missing-template-keys\", Description: \"-----------------------------------------------------------------------------------------------------------------------------------------------\"},\n\t\t\t\t{Text: \"--export\", Description: \"----------------------------------------------------------------------------------------------------------\"},\n\t\t\t\t{Text: \"-f\", Description: \"-----------------------------------------------------------------------------------\"},\n\t\t\t\t{Text: \"--filename\", Description: \"-----------------------------------------------------------------------------------\"},\n\t\t\t\t{Text: \"--include-extended-apis\", Description: \"------------------------------------------------------------------------------------\"},\n\t\t\t},\n\t\t\texpected: []Suggest{\n\t\t\t\t{Text: \" --all-namespaces              \", Description: \" --------------... \"},\n\t\t\t\t{Text: \" --allow-missing-template-keys \", Description: \" --------------... \"},\n\t\t\t\t{Text: \" --export                      \", Description: \" --------------... \"},\n\t\t\t\t{Text: \" -f                            \", Description: \" --------------... \"},\n\t\t\t\t{Text: \" --filename                    \", Description: \" --------------... \"},\n\t\t\t\t{Text: \" --include-extended-apis       \", Description: \" --------------... \"},\n\t\t\t},\n\t\t\tmax:     50,\n\t\t\texWidth: len(\" --include-extended-apis       \" + \" ---------------...\"),\n\t\t},\n\t\t{\n\t\t\tin: []Suggest{\n\t\t\t\t{Text: \"--all-namespaces\", Description: \"If present, list the requested object(s) across all namespaces. Namespace in current context is ignored even if specified with --namespace.\"},\n\t\t\t\t{Text: \"--allow-missing-template-keys\", Description: \"If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats.\"},\n\t\t\t\t{Text: \"--export\", Description: \"If true, use 'export' for the resources.  Exported resources are stripped of cluster-specific information.\"},\n\t\t\t\t{Text: \"-f\", Description: \"Filename, directory, or URL to files identifying the resource to get from a server.\"},\n\t\t\t\t{Text: \"--filename\", Description: \"Filename, directory, or URL to files identifying the resource to get from a server.\"},\n\t\t\t\t{Text: \"--include-extended-apis\", Description: \"If true, include definitions of new APIs via calls to the API server. [default true]\"},\n\t\t\t},\n\t\t\texpected: []Suggest{\n\t\t\t\t{Text: \" --all-namespaces              \", Description: \" If present, list the requested object(s) across all namespaces. Namespace in current context is ignored even if specified with --namespace.     \"},\n\t\t\t\t{Text: \" --allow-missing-template-keys \", Description: \" If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats. \"},\n\t\t\t\t{Text: \" --export                      \", Description: \" If true, use 'export' for the resources.  Exported resources are stripped of cluster-specific information.                                      \"},\n\t\t\t\t{Text: \" -f                            \", Description: \" Filename, directory, or URL to files identifying the resource to get from a server.                                                             \"},\n\t\t\t\t{Text: \" --filename                    \", Description: \" Filename, directory, or URL to files identifying the resource to get from a server.                                                             \"},\n\t\t\t\t{Text: \" --include-extended-apis       \", Description: \" If true, include definitions of new APIs via calls to the API server. [default true]                                                            \"},\n\t\t\t},\n\t\t\tmax:     500,\n\t\t\texWidth: len(\" --include-extended-apis       \" + \" If true, include definitions of new APIs via calls to the API server. [default true]                                                            \"),\n\t\t},\n\t}\n\n\tfor i, s := range scenarioTable {\n\t\tactual, width := formatSuggestions(s.in, s.max)\n\t\tif width != s.exWidth {\n\t\t\tt.Errorf(\"[scenario %d] Want %d but got %d\\n\", i, s.exWidth, width)\n\t\t}\n\t\tif !reflect.DeepEqual(actual, s.expected) {\n\t\t\tt.Errorf(\"[scenario %d] Want %#v, but got %#v\\n\", i, s.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestFormatText(t *testing.T) {\n\tvar scenarioTable = []struct {\n\t\tin       []string\n\t\texpected []string\n\t\tmax      int\n\t\texWidth  int\n\t}{\n\t\t{\n\t\t\tin: []string{\n\t\t\t\t\"\",\n\t\t\t\t\"\",\n\t\t\t},\n\t\t\texpected: []string{\n\t\t\t\t\"\",\n\t\t\t\t\"\",\n\t\t\t},\n\t\t\tmax:     10,\n\t\t\texWidth: 0,\n\t\t},\n\t\t{\n\t\t\tin: []string{\n\t\t\t\t\"apple\",\n\t\t\t\t\"banana\",\n\t\t\t\t\"coconut\",\n\t\t\t},\n\t\t\texpected: []string{\n\t\t\t\t\"\",\n\t\t\t\t\"\",\n\t\t\t\t\"\",\n\t\t\t},\n\t\t\tmax:     2,\n\t\t\texWidth: 0,\n\t\t},\n\t\t{\n\t\t\tin: []string{\n\t\t\t\t\"apple\",\n\t\t\t\t\"banana\",\n\t\t\t\t\"coconut\",\n\t\t\t},\n\t\t\texpected: []string{\n\t\t\t\t\"\",\n\t\t\t\t\"\",\n\t\t\t\t\"\",\n\t\t\t},\n\t\t\tmax:     len(\" \" + \" \" + shortenSuffix),\n\t\t\texWidth: 0,\n\t\t},\n\t\t{\n\t\t\tin: []string{\n\t\t\t\t\"apple\",\n\t\t\t\t\"banana\",\n\t\t\t\t\"coconut\",\n\t\t\t},\n\t\t\texpected: []string{\n\t\t\t\t\" apple   \",\n\t\t\t\t\" banana  \",\n\t\t\t\t\" coconut \",\n\t\t\t},\n\t\t\tmax:     100,\n\t\t\texWidth: len(\" coconut \"),\n\t\t},\n\t\t{\n\t\t\tin: []string{\n\t\t\t\t\"apple\",\n\t\t\t\t\"banana\",\n\t\t\t\t\"coconut\",\n\t\t\t},\n\t\t\texpected: []string{\n\t\t\t\t\" a... \",\n\t\t\t\t\" b... \",\n\t\t\t\t\" c... \",\n\t\t\t},\n\t\t\tmax:     6,\n\t\t\texWidth: 6,\n\t\t},\n\t}\n\n\tfor i, s := range scenarioTable {\n\t\tactual, width := formatTexts(s.in, s.max, \" \", \" \")\n\t\tif width != s.exWidth {\n\t\t\tt.Errorf(\"[scenario %d] Want %d but got %d\\n\", i, s.exWidth, width)\n\t\t}\n\t\tif !reflect.DeepEqual(actual, s.expected) {\n\t\t\tt.Errorf(\"[scenario %d] Want %#v, but got %#v\\n\", i, s.expected, actual)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "document.go",
          "type": "blob",
          "size": 12.7900390625,
          "content": "package prompt\n\nimport (\n\t\"strings\"\n\t\"unicode/utf8\"\n\n\t\"github.com/c-bata/go-prompt/internal/bisect\"\n\tistrings \"github.com/c-bata/go-prompt/internal/strings\"\n\trunewidth \"github.com/mattn/go-runewidth\"\n)\n\n// Document has text displayed in terminal and cursor position.\ntype Document struct {\n\tText string\n\t// This represents a index in a rune array of Document.Text.\n\t// So if Document is \"日本(cursor)語\", cursorPosition is 2.\n\t// But DisplayedCursorPosition returns 4 because '日' and '本' are double width characters.\n\tcursorPosition int\n\tlastKey        Key\n}\n\n// NewDocument return the new empty document.\nfunc NewDocument() *Document {\n\treturn &Document{\n\t\tText:           \"\",\n\t\tcursorPosition: 0,\n\t}\n}\n\n// LastKeyStroke return the last key pressed in this document.\nfunc (d *Document) LastKeyStroke() Key {\n\treturn d.lastKey\n}\n\n// DisplayCursorPosition returns the cursor position on rendered text on terminal emulators.\n// So if Document is \"日本(cursor)語\", DisplayedCursorPosition returns 4 because '日' and '本' are double width characters.\nfunc (d *Document) DisplayCursorPosition() int {\n\tvar position int\n\trunes := []rune(d.Text)[:d.cursorPosition]\n\tfor i := range runes {\n\t\tposition += runewidth.RuneWidth(runes[i])\n\t}\n\treturn position\n}\n\n// GetCharRelativeToCursor return character relative to cursor position, or empty string\nfunc (d *Document) GetCharRelativeToCursor(offset int) (r rune) {\n\ts := d.Text\n\tcnt := 0\n\n\tfor len(s) > 0 {\n\t\tcnt++\n\t\tr, size := utf8.DecodeRuneInString(s)\n\t\tif cnt == d.cursorPosition+offset {\n\t\t\treturn r\n\t\t}\n\t\ts = s[size:]\n\t}\n\treturn 0\n}\n\n// TextBeforeCursor returns the text before the cursor.\nfunc (d *Document) TextBeforeCursor() string {\n\tr := []rune(d.Text)\n\treturn string(r[:d.cursorPosition])\n}\n\n// TextAfterCursor returns the text after the cursor.\nfunc (d *Document) TextAfterCursor() string {\n\tr := []rune(d.Text)\n\treturn string(r[d.cursorPosition:])\n}\n\n// GetWordBeforeCursor returns the word before the cursor.\n// If we have whitespace before the cursor this returns an empty string.\nfunc (d *Document) GetWordBeforeCursor() string {\n\tx := d.TextBeforeCursor()\n\treturn x[d.FindStartOfPreviousWord():]\n}\n\n// GetWordAfterCursor returns the word after the cursor.\n// If we have whitespace after the cursor this returns an empty string.\nfunc (d *Document) GetWordAfterCursor() string {\n\tx := d.TextAfterCursor()\n\treturn x[:d.FindEndOfCurrentWord()]\n}\n\n// GetWordBeforeCursorWithSpace returns the word before the cursor.\n// Unlike GetWordBeforeCursor, it returns string containing space\nfunc (d *Document) GetWordBeforeCursorWithSpace() string {\n\tx := d.TextBeforeCursor()\n\treturn x[d.FindStartOfPreviousWordWithSpace():]\n}\n\n// GetWordAfterCursorWithSpace returns the word after the cursor.\n// Unlike GetWordAfterCursor, it returns string containing space\nfunc (d *Document) GetWordAfterCursorWithSpace() string {\n\tx := d.TextAfterCursor()\n\treturn x[:d.FindEndOfCurrentWordWithSpace()]\n}\n\n// GetWordBeforeCursorUntilSeparator returns the text before the cursor until next separator.\nfunc (d *Document) GetWordBeforeCursorUntilSeparator(sep string) string {\n\tx := d.TextBeforeCursor()\n\treturn x[d.FindStartOfPreviousWordUntilSeparator(sep):]\n}\n\n// GetWordAfterCursorUntilSeparator returns the text after the cursor until next separator.\nfunc (d *Document) GetWordAfterCursorUntilSeparator(sep string) string {\n\tx := d.TextAfterCursor()\n\treturn x[:d.FindEndOfCurrentWordUntilSeparator(sep)]\n}\n\n// GetWordBeforeCursorUntilSeparatorIgnoreNextToCursor returns the word before the cursor.\n// Unlike GetWordBeforeCursor, it returns string containing space\nfunc (d *Document) GetWordBeforeCursorUntilSeparatorIgnoreNextToCursor(sep string) string {\n\tx := d.TextBeforeCursor()\n\treturn x[d.FindStartOfPreviousWordUntilSeparatorIgnoreNextToCursor(sep):]\n}\n\n// GetWordAfterCursorUntilSeparatorIgnoreNextToCursor returns the word after the cursor.\n// Unlike GetWordAfterCursor, it returns string containing space\nfunc (d *Document) GetWordAfterCursorUntilSeparatorIgnoreNextToCursor(sep string) string {\n\tx := d.TextAfterCursor()\n\treturn x[:d.FindEndOfCurrentWordUntilSeparatorIgnoreNextToCursor(sep)]\n}\n\n// FindStartOfPreviousWord returns an index relative to the cursor position\n// pointing to the start of the previous word. Return 0 if nothing was found.\nfunc (d *Document) FindStartOfPreviousWord() int {\n\tx := d.TextBeforeCursor()\n\ti := strings.LastIndexByte(x, ' ')\n\tif i != -1 {\n\t\treturn i + 1\n\t}\n\treturn 0\n}\n\n// FindStartOfPreviousWordWithSpace is almost the same as FindStartOfPreviousWord.\n// The only difference is to ignore contiguous spaces.\nfunc (d *Document) FindStartOfPreviousWordWithSpace() int {\n\tx := d.TextBeforeCursor()\n\tend := istrings.LastIndexNotByte(x, ' ')\n\tif end == -1 {\n\t\treturn 0\n\t}\n\n\tstart := strings.LastIndexByte(x[:end], ' ')\n\tif start == -1 {\n\t\treturn 0\n\t}\n\treturn start + 1\n}\n\n// FindStartOfPreviousWordUntilSeparator is almost the same as FindStartOfPreviousWord.\n// But this can specify Separator. Return 0 if nothing was found.\nfunc (d *Document) FindStartOfPreviousWordUntilSeparator(sep string) int {\n\tif sep == \"\" {\n\t\treturn d.FindStartOfPreviousWord()\n\t}\n\n\tx := d.TextBeforeCursor()\n\ti := strings.LastIndexAny(x, sep)\n\tif i != -1 {\n\t\treturn i + 1\n\t}\n\treturn 0\n}\n\n// FindStartOfPreviousWordUntilSeparatorIgnoreNextToCursor is almost the same as FindStartOfPreviousWordWithSpace.\n// But this can specify Separator. Return 0 if nothing was found.\nfunc (d *Document) FindStartOfPreviousWordUntilSeparatorIgnoreNextToCursor(sep string) int {\n\tif sep == \"\" {\n\t\treturn d.FindStartOfPreviousWordWithSpace()\n\t}\n\n\tx := d.TextBeforeCursor()\n\tend := istrings.LastIndexNotAny(x, sep)\n\tif end == -1 {\n\t\treturn 0\n\t}\n\tstart := strings.LastIndexAny(x[:end], sep)\n\tif start == -1 {\n\t\treturn 0\n\t}\n\treturn start + 1\n}\n\n// FindEndOfCurrentWord returns an index relative to the cursor position.\n// pointing to the end of the current word. Return 0 if nothing was found.\nfunc (d *Document) FindEndOfCurrentWord() int {\n\tx := d.TextAfterCursor()\n\ti := strings.IndexByte(x, ' ')\n\tif i != -1 {\n\t\treturn i\n\t}\n\treturn len(x)\n}\n\n// FindEndOfCurrentWordWithSpace is almost the same as FindEndOfCurrentWord.\n// The only difference is to ignore contiguous spaces.\nfunc (d *Document) FindEndOfCurrentWordWithSpace() int {\n\tx := d.TextAfterCursor()\n\n\tstart := istrings.IndexNotByte(x, ' ')\n\tif start == -1 {\n\t\treturn len(x)\n\t}\n\n\tend := strings.IndexByte(x[start:], ' ')\n\tif end == -1 {\n\t\treturn len(x)\n\t}\n\n\treturn start + end\n}\n\n// FindEndOfCurrentWordUntilSeparator is almost the same as FindEndOfCurrentWord.\n// But this can specify Separator. Return 0 if nothing was found.\nfunc (d *Document) FindEndOfCurrentWordUntilSeparator(sep string) int {\n\tif sep == \"\" {\n\t\treturn d.FindEndOfCurrentWord()\n\t}\n\n\tx := d.TextAfterCursor()\n\ti := strings.IndexAny(x, sep)\n\tif i != -1 {\n\t\treturn i\n\t}\n\treturn len(x)\n}\n\n// FindEndOfCurrentWordUntilSeparatorIgnoreNextToCursor is almost the same as FindEndOfCurrentWordWithSpace.\n// But this can specify Separator. Return 0 if nothing was found.\nfunc (d *Document) FindEndOfCurrentWordUntilSeparatorIgnoreNextToCursor(sep string) int {\n\tif sep == \"\" {\n\t\treturn d.FindEndOfCurrentWordWithSpace()\n\t}\n\n\tx := d.TextAfterCursor()\n\n\tstart := istrings.IndexNotAny(x, sep)\n\tif start == -1 {\n\t\treturn len(x)\n\t}\n\n\tend := strings.IndexAny(x[start:], sep)\n\tif end == -1 {\n\t\treturn len(x)\n\t}\n\n\treturn start + end\n}\n\n// CurrentLineBeforeCursor returns the text from the start of the line until the cursor.\nfunc (d *Document) CurrentLineBeforeCursor() string {\n\ts := strings.Split(d.TextBeforeCursor(), \"\\n\")\n\treturn s[len(s)-1]\n}\n\n// CurrentLineAfterCursor returns the text from the cursor until the end of the line.\nfunc (d *Document) CurrentLineAfterCursor() string {\n\treturn strings.Split(d.TextAfterCursor(), \"\\n\")[0]\n}\n\n// CurrentLine return the text on the line where the cursor is. (when the input\n// consists of just one line, it equals `text`.\nfunc (d *Document) CurrentLine() string {\n\treturn d.CurrentLineBeforeCursor() + d.CurrentLineAfterCursor()\n}\n\n// Array pointing to the start indexes of all the lines.\nfunc (d *Document) lineStartIndexes() []int {\n\t// TODO: Cache, because this is often reused.\n\t// (If it is used, it's often used many times.\n\t// And this has to be fast for editing big documents!)\n\tlc := d.LineCount()\n\tlengths := make([]int, lc)\n\tfor i, l := range d.Lines() {\n\t\tlengths[i] = len(l)\n\t}\n\n\t// Calculate cumulative sums.\n\tindexes := make([]int, lc+1)\n\tindexes[0] = 0 // https://github.com/jonathanslenders/python-prompt-toolkit/blob/master/prompt_toolkit/document.py#L189\n\tpos := 0\n\tfor i, l := range lengths {\n\t\tpos += l + 1\n\t\tindexes[i+1] = pos\n\t}\n\tif lc > 1 {\n\t\t// Pop the last item. (This is not a new line.)\n\t\tindexes = indexes[:lc]\n\t}\n\treturn indexes\n}\n\n// For the index of a character at a certain line, calculate the index of\n// the first character on that line.\nfunc (d *Document) findLineStartIndex(index int) (pos int, lineStartIndex int) {\n\tindexes := d.lineStartIndexes()\n\tpos = bisect.Right(indexes, index) - 1\n\tlineStartIndex = indexes[pos]\n\treturn\n}\n\n// CursorPositionRow returns the current row. (0-based.)\nfunc (d *Document) CursorPositionRow() (row int) {\n\trow, _ = d.findLineStartIndex(d.cursorPosition)\n\treturn\n}\n\n// CursorPositionCol returns the current column. (0-based.)\nfunc (d *Document) CursorPositionCol() (col int) {\n\t// Don't use self.text_before_cursor to calculate this. Creating substrings\n\t// and splitting is too expensive for getting the cursor position.\n\t_, index := d.findLineStartIndex(d.cursorPosition)\n\tcol = d.cursorPosition - index\n\treturn\n}\n\n// GetCursorLeftPosition returns the relative position for cursor left.\nfunc (d *Document) GetCursorLeftPosition(count int) int {\n\tif count < 0 {\n\t\treturn d.GetCursorRightPosition(-count)\n\t}\n\tif d.CursorPositionCol() > count {\n\t\treturn -count\n\t}\n\treturn -d.CursorPositionCol()\n}\n\n// GetCursorRightPosition returns relative position for cursor right.\nfunc (d *Document) GetCursorRightPosition(count int) int {\n\tif count < 0 {\n\t\treturn d.GetCursorLeftPosition(-count)\n\t}\n\tif len(d.CurrentLineAfterCursor()) > count {\n\t\treturn count\n\t}\n\treturn len(d.CurrentLineAfterCursor())\n}\n\n// GetCursorUpPosition return the relative cursor position (character index) where we would be\n// if the user pressed the arrow-up button.\nfunc (d *Document) GetCursorUpPosition(count int, preferredColumn int) int {\n\tvar col int\n\tif preferredColumn == -1 { // -1 means nil\n\t\tcol = d.CursorPositionCol()\n\t} else {\n\t\tcol = preferredColumn\n\t}\n\n\trow := d.CursorPositionRow() - count\n\tif row < 0 {\n\t\trow = 0\n\t}\n\treturn d.TranslateRowColToIndex(row, col) - d.cursorPosition\n}\n\n// GetCursorDownPosition return the relative cursor position (character index) where we would be if the\n// user pressed the arrow-down button.\nfunc (d *Document) GetCursorDownPosition(count int, preferredColumn int) int {\n\tvar col int\n\tif preferredColumn == -1 { // -1 means nil\n\t\tcol = d.CursorPositionCol()\n\t} else {\n\t\tcol = preferredColumn\n\t}\n\trow := d.CursorPositionRow() + count\n\treturn d.TranslateRowColToIndex(row, col) - d.cursorPosition\n}\n\n// Lines returns the array of all the lines.\nfunc (d *Document) Lines() []string {\n\t// TODO: Cache, because this one is reused very often.\n\treturn strings.Split(d.Text, \"\\n\")\n}\n\n// LineCount return the number of lines in this document. If the document ends\n// with a trailing \\n, that counts as the beginning of a new line.\nfunc (d *Document) LineCount() int {\n\treturn len(d.Lines())\n}\n\n// TranslateIndexToPosition given an index for the text, return the corresponding (row, col) tuple.\n// (0-based. Returns (0, 0) for index=0.)\nfunc (d *Document) TranslateIndexToPosition(index int) (row int, col int) {\n\trow, rowIndex := d.findLineStartIndex(index)\n\tcol = index - rowIndex\n\treturn\n}\n\n// TranslateRowColToIndex given a (row, col), return the corresponding index.\n// (Row and col params are 0-based.)\nfunc (d *Document) TranslateRowColToIndex(row int, column int) (index int) {\n\tindexes := d.lineStartIndexes()\n\tif row < 0 {\n\t\trow = 0\n\t} else if row > len(indexes) {\n\t\trow = len(indexes) - 1\n\t}\n\tindex = indexes[row]\n\tline := d.Lines()[row]\n\n\t// python) result += max(0, min(col, len(line)))\n\tif column > 0 || len(line) > 0 {\n\t\tif column > len(line) {\n\t\t\tindex += len(line)\n\t\t} else {\n\t\t\tindex += column\n\t\t}\n\t}\n\n\t// Keep in range. (len(self.text) is included, because the cursor can be\n\t// right after the end of the text as well.)\n\t// python) result = max(0, min(result, len(self.text)))\n\tif index > len(d.Text) {\n\t\tindex = len(d.Text)\n\t}\n\tif index < 0 {\n\t\tindex = 0\n\t}\n\treturn index\n}\n\n// OnLastLine returns true when we are at the last line.\nfunc (d *Document) OnLastLine() bool {\n\treturn d.CursorPositionRow() == (d.LineCount() - 1)\n}\n\n// GetEndOfLinePosition returns relative position for the end of this line.\nfunc (d *Document) GetEndOfLinePosition() int {\n\treturn len([]rune(d.CurrentLineAfterCursor()))\n}\n\nfunc (d *Document) leadingWhitespaceInCurrentLine() (margin string) {\n\ttrimmed := strings.TrimSpace(d.CurrentLine())\n\tmargin = d.CurrentLine()[:len(d.CurrentLine())-len(trimmed)]\n\treturn\n}\n"
        },
        {
          "name": "document_test.go",
          "type": "blob",
          "size": 28.259765625,
          "content": "package prompt\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\t\"unicode/utf8\"\n)\n\nfunc ExampleDocument_CurrentLine() {\n\td := &Document{\n\t\tText: `Hello! my name is c-bata.\nThis is a example of Document component.\nThis component has texts displayed in terminal and cursor position.\n`,\n\t\tcursorPosition: len(`Hello! my name is c-bata.\nThis is a exam`),\n\t}\n\tfmt.Println(d.CurrentLine())\n\t// Output:\n\t// This is a example of Document component.\n}\n\nfunc ExampleDocument_DisplayCursorPosition() {\n\td := &Document{\n\t\tText:           `Hello! my name is c-bata.`,\n\t\tcursorPosition: len(`Hello`),\n\t}\n\tfmt.Println(\"DisplayCursorPosition\", d.DisplayCursorPosition())\n\t// Output:\n\t// DisplayCursorPosition 5\n}\n\nfunc ExampleDocument_CursorPositionRow() {\n\td := &Document{\n\t\tText: `Hello! my name is c-bata.\nThis is a example of Document component.\nThis component has texts displayed in terminal and cursor position.\n`,\n\t\tcursorPosition: len(`Hello! my name is c-bata.\nThis is a exam`),\n\t}\n\tfmt.Println(\"CursorPositionRow\", d.CursorPositionRow())\n\t// Output:\n\t// CursorPositionRow 1\n}\n\nfunc ExampleDocument_CursorPositionCol() {\n\td := &Document{\n\t\tText: `Hello! my name is c-bata.\nThis is a example of Document component.\nThis component has texts displayed in terminal and cursor position.\n`,\n\t\tcursorPosition: len(`Hello! my name is c-bata.\nThis is a exam`),\n\t}\n\tfmt.Println(\"CursorPositionCol\", d.CursorPositionCol())\n\t// Output:\n\t// CursorPositionCol 14\n}\n\nfunc ExampleDocument_TextBeforeCursor() {\n\td := &Document{\n\t\tText: `Hello! my name is c-bata.\nThis is a example of Document component.\nThis component has texts displayed in terminal and cursor position.\n`,\n\t\tcursorPosition: len(`Hello! my name is c-bata.\nThis is a exam`),\n\t}\n\tfmt.Println(d.TextBeforeCursor())\n\t// Output:\n\t// Hello! my name is c-bata.\n\t// This is a exam\n}\n\nfunc ExampleDocument_TextAfterCursor() {\n\td := &Document{\n\t\tText: `Hello! my name is c-bata.\nThis is a example of Document component.\nThis component has texts displayed in terminal and cursor position.\n`,\n\t\tcursorPosition: len(`Hello! my name is c-bata.\nThis is a exam`),\n\t}\n\tfmt.Println(d.TextAfterCursor())\n\t// Output:\n\t// ple of Document component.\n\t// This component has texts displayed in terminal and cursor position.\n}\n\nfunc ExampleDocument_DisplayCursorPosition_withJapanese() {\n\td := &Document{\n\t\tText:           `こんにちは、芝田 将です。`,\n\t\tcursorPosition: 3,\n\t}\n\tfmt.Println(\"DisplayCursorPosition\", d.DisplayCursorPosition())\n\t// Output:\n\t// DisplayCursorPosition 6\n}\n\nfunc ExampleDocument_CurrentLineBeforeCursor() {\n\td := &Document{\n\t\tText: `Hello! my name is c-bata.\nThis is a example of Document component.\nThis component has texts displayed in terminal and cursor position.\n`,\n\t\tcursorPosition: len(`Hello! my name is c-bata.\nThis is a exam`),\n\t}\n\tfmt.Println(d.CurrentLineBeforeCursor())\n\t// Output:\n\t// This is a exam\n}\n\nfunc ExampleDocument_CurrentLineAfterCursor() {\n\td := &Document{\n\t\tText: `Hello! my name is c-bata.\nThis is a example of Document component.\nThis component has texts displayed in terminal and cursor position.\n`,\n\t\tcursorPosition: len(`Hello! my name is c-bata.\nThis is a exam`),\n\t}\n\tfmt.Println(d.CurrentLineAfterCursor())\n\t// Output:\n\t// ple of Document component.\n}\n\nfunc ExampleDocument_GetWordBeforeCursor() {\n\td := &Document{\n\t\tText: `Hello! my name is c-bata.\nThis is a example of Document component.\n`,\n\t\tcursorPosition: len(`Hello! my name is c-bata.\nThis is a exam`),\n\t}\n\tfmt.Println(d.GetWordBeforeCursor())\n\t// Output:\n\t// exam\n}\n\nfunc ExampleDocument_GetWordAfterCursor() {\n\td := &Document{\n\t\tText: `Hello! my name is c-bata.\nThis is a example of Document component.\n`,\n\t\tcursorPosition: len(`Hello! my name is c-bata.\nThis is a exam`),\n\t}\n\tfmt.Println(d.GetWordAfterCursor())\n\t// Output:\n\t// ple\n}\n\nfunc ExampleDocument_GetWordBeforeCursorWithSpace() {\n\td := &Document{\n\t\tText: `Hello! my name is c-bata.\nThis is a example of Document component.\n`,\n\t\tcursorPosition: len(`Hello! my name is c-bata.\nThis is a example `),\n\t}\n\tfmt.Println(d.GetWordBeforeCursorWithSpace())\n\t// Output:\n\t// example\n}\n\nfunc ExampleDocument_GetWordAfterCursorWithSpace() {\n\td := &Document{\n\t\tText: `Hello! my name is c-bata.\nThis is a example of Document component.\n`,\n\t\tcursorPosition: len(`Hello! my name is c-bata.\nThis is a`),\n\t}\n\tfmt.Println(d.GetWordAfterCursorWithSpace())\n\t// Output:\n\t//  example\n}\n\nfunc ExampleDocument_GetWordBeforeCursorUntilSeparator() {\n\td := &Document{\n\t\tText:           `hello,i am c-bata`,\n\t\tcursorPosition: len(`hello,i am c`),\n\t}\n\tfmt.Println(d.GetWordBeforeCursorUntilSeparator(\",\"))\n\t// Output:\n\t// i am c\n}\n\nfunc ExampleDocument_GetWordAfterCursorUntilSeparator() {\n\td := &Document{\n\t\tText:           `hello,i am c-bata,thank you for using go-prompt`,\n\t\tcursorPosition: len(`hello,i a`),\n\t}\n\tfmt.Println(d.GetWordAfterCursorUntilSeparator(\",\"))\n\t// Output:\n\t// m c-bata\n}\n\nfunc ExampleDocument_GetWordBeforeCursorUntilSeparatorIgnoreNextToCursor() {\n\td := &Document{\n\t\tText:           `hello,i am c-bata,thank you for using go-prompt`,\n\t\tcursorPosition: len(`hello,i am c-bata,`),\n\t}\n\tfmt.Println(d.GetWordBeforeCursorUntilSeparatorIgnoreNextToCursor(\",\"))\n\t// Output:\n\t// i am c-bata,\n}\n\nfunc ExampleDocument_GetWordAfterCursorUntilSeparatorIgnoreNextToCursor() {\n\td := &Document{\n\t\tText:           `hello,i am c-bata,thank you for using go-prompt`,\n\t\tcursorPosition: len(`hello`),\n\t}\n\tfmt.Println(d.GetWordAfterCursorUntilSeparatorIgnoreNextToCursor(\",\"))\n\t// Output:\n\t// ,i am c-bata\n}\n\nfunc TestDocument_DisplayCursorPosition(t *testing.T) {\n\tpatterns := []struct {\n\t\tdocument *Document\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"hello\",\n\t\t\t\tcursorPosition: 2,\n\t\t\t},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"こんにちは\",\n\t\t\t\tcursorPosition: 2,\n\t\t\t},\n\t\t\texpected: 4,\n\t\t},\n\t\t{\n\t\t\t// If you're facing test failure on this test case and your terminal is iTerm2,\n\t\t\t// please check 'Profile -> Text' configuration. 'Use Unicode version 9 widths'\n\t\t\t// must be checked.\n\t\t\t// https://github.com/c-bata/go-prompt/pull/99\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"Добрый день\",\n\t\t\t\tcursorPosition: 3,\n\t\t\t},\n\t\t\texpected: 3,\n\t\t},\n\t}\n\n\tfor _, p := range patterns {\n\t\tac := p.document.DisplayCursorPosition()\n\t\tif ac != p.expected {\n\t\t\tt.Errorf(\"Should be %#v, got %#v\", p.expected, ac)\n\t\t}\n\t}\n}\n\nfunc TestDocument_GetCharRelativeToCursor(t *testing.T) {\n\tpatterns := []struct {\n\t\tdocument *Document\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"line 1\\nline 2\\nline 3\\nline 4\\n\",\n\t\t\t\tcursorPosition: len([]rune(\"line 1\\n\" + \"lin\")),\n\t\t\t},\n\t\t\texpected: \"e\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"あいうえお\\nかきくけこ\\nさしすせそ\\nたちつてと\\n\",\n\t\t\t\tcursorPosition: 8,\n\t\t\t},\n\t\t\texpected: \"く\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"Добрый\\nдень\\nДобрый день\",\n\t\t\t\tcursorPosition: 9,\n\t\t\t},\n\t\t\texpected: \"н\",\n\t\t},\n\t}\n\n\tfor i, p := range patterns {\n\t\tac := p.document.GetCharRelativeToCursor(1)\n\t\tex, _ := utf8.DecodeRuneInString(p.expected)\n\t\tif ac != ex {\n\t\t\tt.Errorf(\"[%d] Should be %s, got %s\", i, string(ex), string(ac))\n\t\t}\n\t}\n}\n\nfunc TestDocument_TextBeforeCursor(t *testing.T) {\n\tpatterns := []struct {\n\t\tdocument *Document\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"line 1\\nline 2\\nline 3\\nline 4\\n\",\n\t\t\t\tcursorPosition: len(\"line 1\\n\" + \"lin\"),\n\t\t\t},\n\t\t\texpected: \"line 1\\nlin\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"あいうえお\\nかきくけこ\\nさしすせそ\\nたちつてと\\n\",\n\t\t\t\tcursorPosition: 8,\n\t\t\t},\n\t\t\texpected: \"あいうえお\\nかき\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"Добрый\\nдень\\nДобрый день\",\n\t\t\t\tcursorPosition: 9,\n\t\t\t},\n\t\t\texpected: \"Добрый\\nде\",\n\t\t},\n\t}\n\tfor i, p := range patterns {\n\t\tac := p.document.TextBeforeCursor()\n\t\tif ac != p.expected {\n\t\t\tt.Errorf(\"[%d] Should be %s, got %s\", i, p.expected, ac)\n\t\t}\n\t}\n}\n\nfunc TestDocument_TextAfterCursor(t *testing.T) {\n\tpattern := []struct {\n\t\tdocument *Document\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"line 1\\nline 2\\nline 3\\nline 4\\n\",\n\t\t\t\tcursorPosition: len(\"line 1\\n\" + \"lin\"),\n\t\t\t},\n\t\t\texpected: \"e 2\\nline 3\\nline 4\\n\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"\",\n\t\t\t\tcursorPosition: 0,\n\t\t\t},\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"あいうえお\\nかきくけこ\\nさしすせそ\\nたちつてと\\n\",\n\t\t\t\tcursorPosition: 8,\n\t\t\t},\n\t\t\texpected: \"くけこ\\nさしすせそ\\nたちつてと\\n\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"Добрый\\nдень\\nДобрый день\",\n\t\t\t\tcursorPosition: 9,\n\t\t\t},\n\t\t\texpected: \"нь\\nДобрый день\",\n\t\t},\n\t}\n\n\tfor i, p := range pattern {\n\t\tac := p.document.TextAfterCursor()\n\t\tif ac != p.expected {\n\t\t\tt.Errorf(\"[%d] Should be %#v, got %#v\", i, p.expected, ac)\n\t\t}\n\t}\n}\n\nfunc TestDocument_GetWordBeforeCursor(t *testing.T) {\n\tpattern := []struct {\n\t\tdocument *Document\n\t\texpected string\n\t\tsep      string\n\t}{\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana\",\n\t\t\t\tcursorPosition: len(\"apple bana\"),\n\t\t\t},\n\t\t\texpected: \"bana\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apply -f ./file/foo.json\",\n\t\t\t\tcursorPosition: len(\"apply -f ./file/foo.json\"),\n\t\t\t},\n\t\t\texpected: \"foo.json\",\n\t\t\tsep:      \" /\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple banana orange\",\n\t\t\t\tcursorPosition: len(\"apple ba\"),\n\t\t\t},\n\t\t\texpected: \"ba\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apply -f ./file/foo.json\",\n\t\t\t\tcursorPosition: len(\"apply -f ./fi\"),\n\t\t\t},\n\t\t\texpected: \"fi\",\n\t\t\tsep:      \" /\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple \",\n\t\t\t\tcursorPosition: len(\"apple \"),\n\t\t\t},\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"あいうえお かきくけこ さしすせそ\",\n\t\t\t\tcursorPosition: 8,\n\t\t\t},\n\t\t\texpected: \"かき\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"Добрый день Добрый день\",\n\t\t\t\tcursorPosition: 9,\n\t\t\t},\n\t\t\texpected: \"де\",\n\t\t},\n\t}\n\n\tfor i, p := range pattern {\n\t\tif p.sep == \"\" {\n\t\t\tac := p.document.GetWordBeforeCursor()\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"[%d] Should be %#v, got %#v\", i, p.expected, ac)\n\t\t\t}\n\t\t\tac = p.document.GetWordBeforeCursorUntilSeparator(\"\")\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"[%d] Should be %#v, got %#v\", i, p.expected, ac)\n\t\t\t}\n\t\t} else {\n\t\t\tac := p.document.GetWordBeforeCursorUntilSeparator(p.sep)\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"[%d] Should be %#v, got %#v\", i, p.expected, ac)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestDocument_GetWordBeforeCursorWithSpace(t *testing.T) {\n\tpattern := []struct {\n\t\tdocument *Document\n\t\texpected string\n\t\tsep      string\n\t}{\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana \",\n\t\t\t\tcursorPosition: len(\"apple bana \"),\n\t\t\t},\n\t\t\texpected: \"bana \",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apply -f /path/to/file/\",\n\t\t\t\tcursorPosition: len(\"apply -f /path/to/file/\"),\n\t\t\t},\n\t\t\texpected: \"file/\",\n\t\t\tsep:      \" /\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple \",\n\t\t\t\tcursorPosition: len(\"apple \"),\n\t\t\t},\n\t\t\texpected: \"apple \",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"path/\",\n\t\t\t\tcursorPosition: len(\"path/\"),\n\t\t\t},\n\t\t\texpected: \"path/\",\n\t\t\tsep:      \" /\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"あいうえお かきくけこ \",\n\t\t\t\tcursorPosition: 12,\n\t\t\t},\n\t\t\texpected: \"かきくけこ \",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"Добрый день \",\n\t\t\t\tcursorPosition: 12,\n\t\t\t},\n\t\t\texpected: \"день \",\n\t\t},\n\t}\n\n\tfor _, p := range pattern {\n\t\tif p.sep == \"\" {\n\t\t\tac := p.document.GetWordBeforeCursorWithSpace()\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"Should be %#v, got %#v\", p.expected, ac)\n\t\t\t}\n\t\t\tac = p.document.GetWordBeforeCursorUntilSeparatorIgnoreNextToCursor(\"\")\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"Should be %#v, got %#v\", p.expected, ac)\n\t\t\t}\n\t\t} else {\n\t\t\tac := p.document.GetWordBeforeCursorUntilSeparatorIgnoreNextToCursor(p.sep)\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"Should be %#v, got %#v\", p.expected, ac)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestDocument_FindStartOfPreviousWord(t *testing.T) {\n\tpattern := []struct {\n\t\tdocument *Document\n\t\texpected int\n\t\tsep      string\n\t}{\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana\",\n\t\t\t\tcursorPosition: len(\"apple bana\"),\n\t\t\t},\n\t\t\texpected: len(\"apple \"),\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apply -f ./file/foo.json\",\n\t\t\t\tcursorPosition: len(\"apply -f ./file/foo.json\"),\n\t\t\t},\n\t\t\texpected: len(\"apply -f ./file/\"),\n\t\t\tsep:      \" /\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple \",\n\t\t\t\tcursorPosition: len(\"apple \"),\n\t\t\t},\n\t\t\texpected: len(\"apple \"),\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apply -f ./file/foo.json\",\n\t\t\t\tcursorPosition: len(\"apply -f ./\"),\n\t\t\t},\n\t\t\texpected: len(\"apply -f ./\"),\n\t\t\tsep:      \" /\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"あいうえお かきくけこ さしすせそ\",\n\t\t\t\tcursorPosition: 8, // between 'き' and 'く'\n\t\t\t},\n\t\t\texpected: len(\"あいうえお \"), // this function returns index byte in string\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"Добрый день Добрый день\",\n\t\t\t\tcursorPosition: 9,\n\t\t\t},\n\t\t\texpected: len(\"Добрый \"), // this function returns index byte in string\n\t\t},\n\t}\n\n\tfor _, p := range pattern {\n\t\tif p.sep == \"\" {\n\t\t\tac := p.document.FindStartOfPreviousWord()\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"Should be %#v, got %#v\", p.expected, ac)\n\t\t\t}\n\t\t\tac = p.document.FindStartOfPreviousWordUntilSeparator(\"\")\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"Should be %#v, got %#v\", p.expected, ac)\n\t\t\t}\n\t\t} else {\n\t\t\tac := p.document.FindStartOfPreviousWordUntilSeparator(p.sep)\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"Should be %#v, got %#v\", p.expected, ac)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestDocument_FindStartOfPreviousWordWithSpace(t *testing.T) {\n\tpattern := []struct {\n\t\tdocument *Document\n\t\texpected int\n\t\tsep      string\n\t}{\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana \",\n\t\t\t\tcursorPosition: len(\"apple bana \"),\n\t\t\t},\n\t\t\texpected: len(\"apple \"),\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apply -f /file/foo/\",\n\t\t\t\tcursorPosition: len(\"apply -f /file/foo/\"),\n\t\t\t},\n\t\t\texpected: len(\"apply -f /file/\"),\n\t\t\tsep:      \" /\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple \",\n\t\t\t\tcursorPosition: len(\"apple \"),\n\t\t\t},\n\t\t\texpected: len(\"\"),\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"file/\",\n\t\t\t\tcursorPosition: len(\"file/\"),\n\t\t\t},\n\t\t\texpected: len(\"\"),\n\t\t\tsep:      \" /\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"あいうえお かきくけこ \",\n\t\t\t\tcursorPosition: 12, // cursor points to last\n\t\t\t},\n\t\t\texpected: len(\"あいうえお \"), // this function returns index byte in string\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"Добрый день \",\n\t\t\t\tcursorPosition: 12,\n\t\t\t},\n\t\t\texpected: len(\"Добрый \"), // this function returns index byte in string\n\t\t},\n\t}\n\n\tfor _, p := range pattern {\n\t\tif p.sep == \"\" {\n\t\t\tac := p.document.FindStartOfPreviousWordWithSpace()\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"Should be %#v, got %#v\", p.expected, ac)\n\t\t\t}\n\t\t\tac = p.document.FindStartOfPreviousWordUntilSeparatorIgnoreNextToCursor(\"\")\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"Should be %#v, got %#v\", p.expected, ac)\n\t\t\t}\n\t\t} else {\n\t\t\tac := p.document.FindStartOfPreviousWordUntilSeparatorIgnoreNextToCursor(p.sep)\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"Should be %#v, got %#v\", p.expected, ac)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestDocument_GetWordAfterCursor(t *testing.T) {\n\tpattern := []struct {\n\t\tdocument *Document\n\t\texpected string\n\t\tsep      string\n\t}{\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana\",\n\t\t\t\tcursorPosition: len(\"apple bana\"),\n\t\t\t},\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apply -f ./file/foo.json\",\n\t\t\t\tcursorPosition: len(\"apply -f ./fi\"),\n\t\t\t},\n\t\t\texpected: \"le\",\n\t\t\tsep:      \" /\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana\",\n\t\t\t\tcursorPosition: len(\"apple \"),\n\t\t\t},\n\t\t\texpected: \"bana\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana\",\n\t\t\t\tcursorPosition: len(\"apple\"),\n\t\t\t},\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apply -f ./file/foo.json\",\n\t\t\t\tcursorPosition: len(\"apply -f .\"),\n\t\t\t},\n\t\t\texpected: \"\",\n\t\t\tsep:      \" /\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana\",\n\t\t\t\tcursorPosition: len(\"ap\"),\n\t\t\t},\n\t\t\texpected: \"ple\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"あいうえお かきくけこ さしすせそ\",\n\t\t\t\tcursorPosition: 8,\n\t\t\t},\n\t\t\texpected: \"くけこ\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"Добрый день Добрый день\",\n\t\t\t\tcursorPosition: 9,\n\t\t\t},\n\t\t\texpected: \"нь\",\n\t\t},\n\t}\n\n\tfor k, p := range pattern {\n\t\tif p.sep == \"\" {\n\t\t\tac := p.document.GetWordAfterCursor()\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"[%d] Should be %#v, got %#v\", k, p.expected, ac)\n\t\t\t}\n\t\t\tac = p.document.GetWordAfterCursorUntilSeparator(\"\")\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"[%d] Should be %#v, got %#v\", k, p.expected, ac)\n\t\t\t}\n\t\t} else {\n\t\t\tac := p.document.GetWordAfterCursorUntilSeparator(p.sep)\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"[%d] Should be %#v, got %#v\", k, p.expected, ac)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestDocument_GetWordAfterCursorWithSpace(t *testing.T) {\n\tpattern := []struct {\n\t\tdocument *Document\n\t\texpected string\n\t\tsep      string\n\t}{\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana\",\n\t\t\t\tcursorPosition: len(\"apple bana\"),\n\t\t\t},\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana\",\n\t\t\t\tcursorPosition: len(\"apple \"),\n\t\t\t},\n\t\t\texpected: \"bana\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"/path/to\",\n\t\t\t\tcursorPosition: len(\"/path/\"),\n\t\t\t},\n\t\t\texpected: \"to\",\n\t\t\tsep:      \" /\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"/path/to/file\",\n\t\t\t\tcursorPosition: len(\"/path/\"),\n\t\t\t},\n\t\t\texpected: \"to\",\n\t\t\tsep:      \" /\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana\",\n\t\t\t\tcursorPosition: len(\"apple\"),\n\t\t\t},\n\t\t\texpected: \" bana\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"path/to\",\n\t\t\t\tcursorPosition: len(\"path\"),\n\t\t\t},\n\t\t\texpected: \"/to\",\n\t\t\tsep:      \" /\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana\",\n\t\t\t\tcursorPosition: len(\"ap\"),\n\t\t\t},\n\t\t\texpected: \"ple\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"あいうえお かきくけこ さしすせそ\",\n\t\t\t\tcursorPosition: 5,\n\t\t\t},\n\t\t\texpected: \" かきくけこ\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"Добрый день Добрый день\",\n\t\t\t\tcursorPosition: 6,\n\t\t\t},\n\t\t\texpected: \" день\",\n\t\t},\n\t}\n\n\tfor k, p := range pattern {\n\t\tif p.sep == \"\" {\n\t\t\tac := p.document.GetWordAfterCursorWithSpace()\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"[%d] Should be %#v, got %#v\", k, p.expected, ac)\n\t\t\t}\n\t\t\tac = p.document.GetWordAfterCursorUntilSeparatorIgnoreNextToCursor(\"\")\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"[%d] Should be %#v, got %#v\", k, p.expected, ac)\n\t\t\t}\n\t\t} else {\n\t\t\tac := p.document.GetWordAfterCursorUntilSeparatorIgnoreNextToCursor(p.sep)\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"[%d] Should be %#v, got %#v\", k, p.expected, ac)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestDocument_FindEndOfCurrentWord(t *testing.T) {\n\tpattern := []struct {\n\t\tdocument *Document\n\t\texpected int\n\t\tsep      string\n\t}{\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana\",\n\t\t\t\tcursorPosition: len(\"apple bana\"),\n\t\t\t},\n\t\t\texpected: len(\"\"),\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana\",\n\t\t\t\tcursorPosition: len(\"apple \"),\n\t\t\t},\n\t\t\texpected: len(\"bana\"),\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apply -f ./file/foo.json\",\n\t\t\t\tcursorPosition: len(\"apply -f ./\"),\n\t\t\t},\n\t\t\texpected: len(\"file\"),\n\t\t\tsep:      \" /\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana\",\n\t\t\t\tcursorPosition: len(\"apple\"),\n\t\t\t},\n\t\t\texpected: len(\"\"),\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apply -f ./file/foo.json\",\n\t\t\t\tcursorPosition: len(\"apply -f .\"),\n\t\t\t},\n\t\t\texpected: len(\"\"),\n\t\t\tsep:      \" /\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana\",\n\t\t\t\tcursorPosition: len(\"ap\"),\n\t\t\t},\n\t\t\texpected: len(\"ple\"),\n\t\t},\n\t\t{\n\t\t\t// りん(cursor)ご ばなな\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"りんご ばなな\",\n\t\t\t\tcursorPosition: 2,\n\t\t\t},\n\t\t\texpected: len(\"ご\"),\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"りんご ばなな\",\n\t\t\t\tcursorPosition: 3,\n\t\t\t},\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\t// Доб(cursor)рый день\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"Добрый день\",\n\t\t\t\tcursorPosition: 3,\n\t\t\t},\n\t\t\texpected: len(\"рый\"),\n\t\t},\n\t}\n\n\tfor k, p := range pattern {\n\t\tif p.sep == \"\" {\n\t\t\tac := p.document.FindEndOfCurrentWord()\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"[%d] Should be %#v, got %#v\", k, p.expected, ac)\n\t\t\t}\n\t\t\tac = p.document.FindEndOfCurrentWordUntilSeparator(\"\")\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"[%d] Should be %#v, got %#v\", k, p.expected, ac)\n\t\t\t}\n\t\t} else {\n\t\t\tac := p.document.FindEndOfCurrentWordUntilSeparator(p.sep)\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"[%d] Should be %#v, got %#v\", k, p.expected, ac)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestDocument_FindEndOfCurrentWordWithSpace(t *testing.T) {\n\tpattern := []struct {\n\t\tdocument *Document\n\t\texpected int\n\t\tsep      string\n\t}{\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana\",\n\t\t\t\tcursorPosition: len(\"apple bana\"),\n\t\t\t},\n\t\t\texpected: len(\"\"),\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana\",\n\t\t\t\tcursorPosition: len(\"apple \"),\n\t\t\t},\n\t\t\texpected: len(\"bana\"),\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apply -f /file/foo.json\",\n\t\t\t\tcursorPosition: len(\"apply -f /\"),\n\t\t\t},\n\t\t\texpected: len(\"file\"),\n\t\t\tsep:      \" /\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana\",\n\t\t\t\tcursorPosition: len(\"apple\"),\n\t\t\t},\n\t\t\texpected: len(\" bana\"),\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apply -f /path/to\",\n\t\t\t\tcursorPosition: len(\"apply -f /path\"),\n\t\t\t},\n\t\t\texpected: len(\"/to\"),\n\t\t\tsep:      \" /\",\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"apple bana\",\n\t\t\t\tcursorPosition: len(\"ap\"),\n\t\t\t},\n\t\t\texpected: len(\"ple\"),\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"あいうえお かきくけこ\",\n\t\t\t\tcursorPosition: 6,\n\t\t\t},\n\t\t\texpected: len(\"かきくけこ\"),\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"あいうえお かきくけこ\",\n\t\t\t\tcursorPosition: 5,\n\t\t\t},\n\t\t\texpected: len(\" かきくけこ\"),\n\t\t},\n\t\t{\n\t\t\tdocument: &Document{\n\t\t\t\tText:           \"Добрый день\",\n\t\t\t\tcursorPosition: 6,\n\t\t\t},\n\t\t\texpected: len(\" день\"),\n\t\t},\n\t}\n\n\tfor k, p := range pattern {\n\t\tif p.sep == \"\" {\n\t\t\tac := p.document.FindEndOfCurrentWordWithSpace()\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"[%d] Should be %#v, got %#v\", k, p.expected, ac)\n\t\t\t}\n\t\t\tac = p.document.FindEndOfCurrentWordUntilSeparatorIgnoreNextToCursor(\"\")\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"[%d] Should be %#v, got %#v\", k, p.expected, ac)\n\t\t\t}\n\t\t} else {\n\t\t\tac := p.document.FindEndOfCurrentWordUntilSeparatorIgnoreNextToCursor(p.sep)\n\t\t\tif ac != p.expected {\n\t\t\t\tt.Errorf(\"[%d] Should be %#v, got %#v\", k, p.expected, ac)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestDocument_CurrentLineBeforeCursor(t *testing.T) {\n\td := &Document{\n\t\tText:           \"line 1\\nline 2\\nline 3\\nline 4\\n\",\n\t\tcursorPosition: len(\"line 1\\n\" + \"lin\"),\n\t}\n\tac := d.CurrentLineBeforeCursor()\n\tex := \"lin\"\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n}\n\nfunc TestDocument_CurrentLineAfterCursor(t *testing.T) {\n\td := &Document{\n\t\tText:           \"line 1\\nline 2\\nline 3\\nline 4\\n\",\n\t\tcursorPosition: len(\"line 1\\n\" + \"lin\"),\n\t}\n\tac := d.CurrentLineAfterCursor()\n\tex := \"e 2\"\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n}\n\nfunc TestDocument_CurrentLine(t *testing.T) {\n\td := &Document{\n\t\tText:           \"line 1\\nline 2\\nline 3\\nline 4\\n\",\n\t\tcursorPosition: len(\"line 1\\n\" + \"lin\"),\n\t}\n\tac := d.CurrentLine()\n\tex := \"line 2\"\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n}\n\nfunc TestDocument_CursorPositionRowAndCol(t *testing.T) {\n\tvar cursorPositionTests = []struct {\n\t\tdocument    *Document\n\t\texpectedRow int\n\t\texpectedCol int\n\t}{\n\t\t{\n\t\t\tdocument:    &Document{Text: \"line 1\\nline 2\\nline 3\\n\", cursorPosition: len(\"line 1\\n\" + \"lin\")},\n\t\t\texpectedRow: 1,\n\t\t\texpectedCol: 3,\n\t\t},\n\t\t{\n\t\t\tdocument:    &Document{Text: \"\", cursorPosition: 0},\n\t\t\texpectedRow: 0,\n\t\t\texpectedCol: 0,\n\t\t},\n\t}\n\tfor _, test := range cursorPositionTests {\n\t\tac := test.document.CursorPositionRow()\n\t\tif ac != test.expectedRow {\n\t\t\tt.Errorf(\"Should be %#v, got %#v\", test.expectedRow, ac)\n\t\t}\n\t\tac = test.document.CursorPositionCol()\n\t\tif ac != test.expectedCol {\n\t\t\tt.Errorf(\"Should be %#v, got %#v\", test.expectedCol, ac)\n\t\t}\n\t}\n}\n\nfunc TestDocument_GetCursorLeftPosition(t *testing.T) {\n\td := &Document{\n\t\tText:           \"line 1\\nline 2\\nline 3\\nline 4\\n\",\n\t\tcursorPosition: len(\"line 1\\n\" + \"line 2\\n\" + \"lin\"),\n\t}\n\tac := d.GetCursorLeftPosition(2)\n\tex := -2\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n\tac = d.GetCursorLeftPosition(10)\n\tex = -3\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n}\n\nfunc TestDocument_GetCursorUpPosition(t *testing.T) {\n\td := &Document{\n\t\tText:           \"line 1\\nline 2\\nline 3\\nline 4\\n\",\n\t\tcursorPosition: len(\"line 1\\n\" + \"line 2\\n\" + \"lin\"),\n\t}\n\tac := d.GetCursorUpPosition(2, -1)\n\tex := len(\"lin\") - len(\"line 1\\n\"+\"line 2\\n\"+\"lin\")\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n\n\tac = d.GetCursorUpPosition(100, -1)\n\tex = len(\"lin\") - len(\"line 1\\n\"+\"line 2\\n\"+\"lin\")\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n}\n\nfunc TestDocument_GetCursorDownPosition(t *testing.T) {\n\td := &Document{\n\t\tText:           \"line 1\\nline 2\\nline 3\\nline 4\\n\",\n\t\tcursorPosition: len(\"lin\"),\n\t}\n\tac := d.GetCursorDownPosition(2, -1)\n\tex := len(\"line 1\\n\"+\"line 2\\n\"+\"lin\") - len(\"lin\")\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n\n\tac = d.GetCursorDownPosition(100, -1)\n\tex = len(\"line 1\\n\"+\"line 2\\n\"+\"line 3\\n\"+\"line 4\\n\") - len(\"lin\")\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n}\n\nfunc TestDocument_GetCursorRightPosition(t *testing.T) {\n\td := &Document{\n\t\tText:           \"line 1\\nline 2\\nline 3\\nline 4\\n\",\n\t\tcursorPosition: len(\"line 1\\n\" + \"line 2\\n\" + \"lin\"),\n\t}\n\tac := d.GetCursorRightPosition(2)\n\tex := 2\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n\tac = d.GetCursorRightPosition(10)\n\tex = 3\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n}\n\nfunc TestDocument_Lines(t *testing.T) {\n\td := &Document{\n\t\tText:           \"line 1\\nline 2\\nline 3\\nline 4\\n\",\n\t\tcursorPosition: len(\"line 1\\n\" + \"lin\"),\n\t}\n\tac := d.Lines()\n\tex := []string{\"line 1\", \"line 2\", \"line 3\", \"line 4\", \"\"}\n\tif !reflect.DeepEqual(ac, ex) {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n}\n\nfunc TestDocument_LineCount(t *testing.T) {\n\td := &Document{\n\t\tText:           \"line 1\\nline 2\\nline 3\\nline 4\\n\",\n\t\tcursorPosition: len(\"line 1\\n\" + \"lin\"),\n\t}\n\tac := d.LineCount()\n\tex := 5\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n}\n\nfunc TestDocument_TranslateIndexToPosition(t *testing.T) {\n\td := &Document{\n\t\tText:           \"line 1\\nline 2\\nline 3\\nline 4\\n\",\n\t\tcursorPosition: len(\"line 1\\n\" + \"lin\"),\n\t}\n\trow, col := d.TranslateIndexToPosition(len(\"line 1\\nline 2\\nlin\"))\n\tif row != 2 {\n\t\tt.Errorf(\"Should be %#v, got %#v\", 2, row)\n\t}\n\tif col != 3 {\n\t\tt.Errorf(\"Should be %#v, got %#v\", 3, col)\n\t}\n\trow, col = d.TranslateIndexToPosition(0)\n\tif row != 0 {\n\t\tt.Errorf(\"Should be %#v, got %#v\", 0, row)\n\t}\n\tif col != 0 {\n\t\tt.Errorf(\"Should be %#v, got %#v\", 0, col)\n\t}\n}\n\nfunc TestDocument_TranslateRowColToIndex(t *testing.T) {\n\td := &Document{\n\t\tText:           \"line 1\\nline 2\\nline 3\\nline 4\\n\",\n\t\tcursorPosition: len(\"line 1\\n\" + \"lin\"),\n\t}\n\tac := d.TranslateRowColToIndex(2, 3)\n\tex := len(\"line 1\\nline 2\\nlin\")\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n\tac = d.TranslateRowColToIndex(0, 0)\n\tex = 0\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n}\n\nfunc TestDocument_OnLastLine(t *testing.T) {\n\td := &Document{\n\t\tText:           \"line 1\\nline 2\\nline 3\",\n\t\tcursorPosition: len(\"line 1\\nline\"),\n\t}\n\tac := d.OnLastLine()\n\tif ac {\n\t\tt.Errorf(\"Should be %#v, got %#v\", false, ac)\n\t}\n\td.cursorPosition = len(\"line 1\\nline 2\\nline\")\n\tac = d.OnLastLine()\n\tif !ac {\n\t\tt.Errorf(\"Should be %#v, got %#v\", true, ac)\n\t}\n}\n\nfunc TestDocument_GetEndOfLinePosition(t *testing.T) {\n\td := &Document{\n\t\tText:           \"line 1\\nline 2\\nline 3\",\n\t\tcursorPosition: len(\"line 1\\nli\"),\n\t}\n\tac := d.GetEndOfLinePosition()\n\tex := len(\"ne 2\")\n\tif ac != ex {\n\t\tt.Errorf(\"Should be %#v, got %#v\", ex, ac)\n\t}\n}\n"
        },
        {
          "name": "emacs.go",
          "type": "blob",
          "size": 2.6123046875,
          "content": "package prompt\n\nimport \"github.com/c-bata/go-prompt/internal/debug\"\n\n/*\n\n========\nPROGRESS\n========\n\nMoving the cursor\n-----------------\n\n* [x] Ctrl + a   Go to the beginning of the line (Home)\n* [x] Ctrl + e   Go to the End of the line (End)\n* [x] Ctrl + p   Previous command (Up arrow)\n* [x] Ctrl + n   Next command (Down arrow)\n* [x] Ctrl + f   Forward one character\n* [x] Ctrl + b   Backward one character\n* [x] Ctrl + xx  Toggle between the start of line and current cursor position\n\nEditing\n-------\n\n* [x] Ctrl + L   Clear the Screen, similar to the clear command\n* [x] Ctrl + d   Delete character under the cursor\n* [x] Ctrl + h   Delete character before the cursor (Backspace)\n\n* [x] Ctrl + w   Cut the Word before the cursor to the clipboard.\n* [x] Ctrl + k   Cut the Line after the cursor to the clipboard.\n* [x] Ctrl + u   Cut/delete the Line before the cursor to the clipboard.\n\n* [ ] Ctrl + t   Swap the last two characters before the cursor (typo).\n* [ ] Esc  + t   Swap the last two words before the cursor.\n\n* [ ] ctrl + y   Paste the last thing to be cut (yank)\n* [ ] ctrl + _   Undo\n\n*/\n\nvar emacsKeyBindings = []KeyBind{\n\t// Go to the End of the line\n\t{\n\t\tKey: ControlE,\n\t\tFn: func(buf *Buffer) {\n\t\t\tx := []rune(buf.Document().TextAfterCursor())\n\t\t\tbuf.CursorRight(len(x))\n\t\t},\n\t},\n\t// Go to the beginning of the line\n\t{\n\t\tKey: ControlA,\n\t\tFn: func(buf *Buffer) {\n\t\t\tx := []rune(buf.Document().TextBeforeCursor())\n\t\t\tbuf.CursorLeft(len(x))\n\t\t},\n\t},\n\t// Cut the Line after the cursor\n\t{\n\t\tKey: ControlK,\n\t\tFn: func(buf *Buffer) {\n\t\t\tx := []rune(buf.Document().TextAfterCursor())\n\t\t\tbuf.Delete(len(x))\n\t\t},\n\t},\n\t// Cut/delete the Line before the cursor\n\t{\n\t\tKey: ControlU,\n\t\tFn: func(buf *Buffer) {\n\t\t\tx := []rune(buf.Document().TextBeforeCursor())\n\t\t\tbuf.DeleteBeforeCursor(len(x))\n\t\t},\n\t},\n\t// Delete character under the cursor\n\t{\n\t\tKey: ControlD,\n\t\tFn: func(buf *Buffer) {\n\t\t\tif buf.Text() != \"\" {\n\t\t\t\tbuf.Delete(1)\n\t\t\t}\n\t\t},\n\t},\n\t// Backspace\n\t{\n\t\tKey: ControlH,\n\t\tFn: func(buf *Buffer) {\n\t\t\tbuf.DeleteBeforeCursor(1)\n\t\t},\n\t},\n\t// Right allow: Forward one character\n\t{\n\t\tKey: ControlF,\n\t\tFn: func(buf *Buffer) {\n\t\t\tbuf.CursorRight(1)\n\t\t},\n\t},\n\t// Left allow: Backward one character\n\t{\n\t\tKey: ControlB,\n\t\tFn: func(buf *Buffer) {\n\t\t\tbuf.CursorLeft(1)\n\t\t},\n\t},\n\t// Cut the Word before the cursor.\n\t{\n\t\tKey: ControlW,\n\t\tFn: func(buf *Buffer) {\n\t\t\tbuf.DeleteBeforeCursor(len([]rune(buf.Document().GetWordBeforeCursorWithSpace())))\n\t\t},\n\t},\n\t// Clear the Screen, similar to the clear command\n\t{\n\t\tKey: ControlL,\n\t\tFn: func(buf *Buffer) {\n\t\t\tconsoleWriter.EraseScreen()\n\t\t\tconsoleWriter.CursorGoTo(0, 0)\n\t\t\tdebug.AssertNoError(consoleWriter.Flush())\n\t\t},\n\t},\n}\n"
        },
        {
          "name": "emacs_test.go",
          "type": "blob",
          "size": 0.7236328125,
          "content": "package prompt\n\nimport \"testing\"\n\nfunc TestEmacsKeyBindings(t *testing.T) {\n\tbuf := NewBuffer()\n\tbuf.InsertText(\"abcde\", false, true)\n\tif buf.cursorPosition != len(\"abcde\") {\n\t\tt.Errorf(\"Want %d, but got %d\", len(\"abcde\"), buf.cursorPosition)\n\t}\n\n\t// Go to the beginning of the line\n\tapplyEmacsKeyBind(buf, ControlA)\n\tif buf.cursorPosition != 0 {\n\t\tt.Errorf(\"Want %d, but got %d\", 0, buf.cursorPosition)\n\t}\n\n\t// Go to the end of the line\n\tapplyEmacsKeyBind(buf, ControlE)\n\tif buf.cursorPosition != len(\"abcde\") {\n\t\tt.Errorf(\"Want %d, but got %d\", len(\"abcde\"), buf.cursorPosition)\n\t}\n}\n\nfunc applyEmacsKeyBind(buf *Buffer, key Key) {\n\tfor i := range emacsKeyBindings {\n\t\tkb := emacsKeyBindings[i]\n\t\tif kb.Key == key {\n\t\t\tkb.Fn(buf)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "filter.go",
          "type": "blob",
          "size": 1.9580078125,
          "content": "package prompt\n\nimport \"strings\"\n\n// Filter is the type to filter the prompt.Suggestion array.\ntype Filter func([]Suggest, string, bool) []Suggest\n\n// FilterHasPrefix checks whether the string completions.Text begins with sub.\nfunc FilterHasPrefix(completions []Suggest, sub string, ignoreCase bool) []Suggest {\n\treturn filterSuggestions(completions, sub, ignoreCase, strings.HasPrefix)\n}\n\n// FilterHasSuffix checks whether the completion.Text ends with sub.\nfunc FilterHasSuffix(completions []Suggest, sub string, ignoreCase bool) []Suggest {\n\treturn filterSuggestions(completions, sub, ignoreCase, strings.HasSuffix)\n}\n\n// FilterContains checks whether the completion.Text contains sub.\nfunc FilterContains(completions []Suggest, sub string, ignoreCase bool) []Suggest {\n\treturn filterSuggestions(completions, sub, ignoreCase, strings.Contains)\n}\n\n// FilterFuzzy checks whether the completion.Text fuzzy matches sub.\n// Fuzzy searching for \"dog\" is equivalent to \"*d*o*g*\". This search term\n// would match, for example, \"Good food is gone\"\n//                               ^  ^      ^\nfunc FilterFuzzy(completions []Suggest, sub string, ignoreCase bool) []Suggest {\n\treturn filterSuggestions(completions, sub, ignoreCase, fuzzyMatch)\n}\n\nfunc fuzzyMatch(s, sub string) bool {\n\tsChars := []rune(s)\n\tsIdx := 0\n\n\t// https://staticcheck.io/docs/checks#S1029\n\tfor _, c := range sub {\n\t\tfound := false\n\t\tfor ; sIdx < len(sChars); sIdx++ {\n\t\t\tif sChars[sIdx] == c {\n\t\t\t\tfound = true\n\t\t\t\tsIdx++\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc filterSuggestions(suggestions []Suggest, sub string, ignoreCase bool, function func(string, string) bool) []Suggest {\n\tif sub == \"\" {\n\t\treturn suggestions\n\t}\n\tif ignoreCase {\n\t\tsub = strings.ToUpper(sub)\n\t}\n\n\tret := make([]Suggest, 0, len(suggestions))\n\tfor i := range suggestions {\n\t\tc := suggestions[i].Text\n\t\tif ignoreCase {\n\t\t\tc = strings.ToUpper(c)\n\t\t}\n\t\tif function(c, sub) {\n\t\t\tret = append(ret, suggestions[i])\n\t\t}\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "filter_test.go",
          "type": "blob",
          "size": 3.2607421875,
          "content": "package prompt\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestFilter(t *testing.T) {\n\tvar scenarioTable = []struct {\n\t\tscenario   string\n\t\tfilter     Filter\n\t\tlist       []Suggest\n\t\tsubstr     string\n\t\tignoreCase bool\n\t\texpected   []Suggest\n\t}{\n\t\t{\n\t\t\tscenario: \"Contains don't ignore case\",\n\t\t\tfilter:   FilterContains,\n\t\t\tlist: []Suggest{\n\t\t\t\t{Text: \"abcde\"},\n\t\t\t\t{Text: \"fghij\"},\n\t\t\t\t{Text: \"ABCDE\"},\n\t\t\t},\n\t\t\tsubstr:     \"cd\",\n\t\t\tignoreCase: false,\n\t\t\texpected: []Suggest{\n\t\t\t\t{Text: \"abcde\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tscenario: \"Contains ignore case\",\n\t\t\tfilter:   FilterContains,\n\t\t\tlist: []Suggest{\n\t\t\t\t{Text: \"abcde\"},\n\t\t\t\t{Text: \"fghij\"},\n\t\t\t\t{Text: \"ABCDE\"},\n\t\t\t},\n\t\t\tsubstr:     \"cd\",\n\t\t\tignoreCase: true,\n\t\t\texpected: []Suggest{\n\t\t\t\t{Text: \"abcde\"},\n\t\t\t\t{Text: \"ABCDE\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tscenario: \"HasPrefix don't ignore case\",\n\t\t\tfilter:   FilterHasPrefix,\n\t\t\tlist: []Suggest{\n\t\t\t\t{Text: \"abcde\"},\n\t\t\t\t{Text: \"fghij\"},\n\t\t\t\t{Text: \"ABCDE\"},\n\t\t\t},\n\t\t\tsubstr:     \"abc\",\n\t\t\tignoreCase: false,\n\t\t\texpected: []Suggest{\n\t\t\t\t{Text: \"abcde\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tscenario: \"HasPrefix ignore case\",\n\t\t\tfilter:   FilterHasPrefix,\n\t\t\tlist: []Suggest{\n\t\t\t\t{Text: \"abcde\"},\n\t\t\t\t{Text: \"fabcj\"},\n\t\t\t\t{Text: \"ABCDE\"},\n\t\t\t},\n\t\t\tsubstr:     \"abc\",\n\t\t\tignoreCase: true,\n\t\t\texpected: []Suggest{\n\t\t\t\t{Text: \"abcde\"},\n\t\t\t\t{Text: \"ABCDE\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tscenario: \"HasSuffix don't ignore case\",\n\t\t\tfilter:   FilterHasSuffix,\n\t\t\tlist: []Suggest{\n\t\t\t\t{Text: \"abcde\"},\n\t\t\t\t{Text: \"fcdej\"},\n\t\t\t\t{Text: \"ABCDE\"},\n\t\t\t},\n\t\t\tsubstr:     \"cde\",\n\t\t\tignoreCase: false,\n\t\t\texpected: []Suggest{\n\t\t\t\t{Text: \"abcde\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tscenario: \"HasSuffix ignore case\",\n\t\t\tfilter:   FilterHasSuffix,\n\t\t\tlist: []Suggest{\n\t\t\t\t{Text: \"abcde\"},\n\t\t\t\t{Text: \"fcdej\"},\n\t\t\t\t{Text: \"ABCDE\"},\n\t\t\t},\n\t\t\tsubstr:     \"cde\",\n\t\t\tignoreCase: true,\n\t\t\texpected: []Suggest{\n\t\t\t\t{Text: \"abcde\"},\n\t\t\t\t{Text: \"ABCDE\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tscenario: \"Fuzzy don't ignore case\",\n\t\t\tfilter:   FilterFuzzy,\n\t\t\tlist: []Suggest{\n\t\t\t\t{Text: \"abcde\"},\n\t\t\t\t{Text: \"fcdej\"},\n\t\t\t\t{Text: \"ABCDE\"},\n\t\t\t},\n\t\t\tsubstr:     \"ae\",\n\t\t\tignoreCase: false,\n\t\t\texpected: []Suggest{\n\t\t\t\t{Text: \"abcde\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tscenario: \"Fuzzy ignore case\",\n\t\t\tfilter:   FilterFuzzy,\n\t\t\tlist: []Suggest{\n\t\t\t\t{Text: \"abcde\"},\n\t\t\t\t{Text: \"fcdej\"},\n\t\t\t\t{Text: \"ABCDE\"},\n\t\t\t},\n\t\t\tsubstr:     \"ae\",\n\t\t\tignoreCase: true,\n\t\t\texpected: []Suggest{\n\t\t\t\t{Text: \"abcde\"},\n\t\t\t\t{Text: \"ABCDE\"},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, s := range scenarioTable {\n\t\tif actual := s.filter(s.list, s.substr, s.ignoreCase); !reflect.DeepEqual(actual, s.expected) {\n\t\t\tt.Errorf(\"%s: Should be %#v, but got %#v\", s.scenario, s.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestFuzzyMatch(t *testing.T) {\n\ttests := []struct {\n\t\ts     string\n\t\tsub   string\n\t\tmatch bool\n\t}{\n\t\t{\"dog house\", \"dog\", true},\n\t\t{\"dog house\", \"\", true},\n\t\t{\"\", \"\", true},\n\t\t{\"this is much longer\", \"hhg\", true},\n\t\t{\"this is much longer\", \"hhhg\", false},\n\t\t{\"long\", \"longer\", false},\n\t\t{\"can we do unicode 文字 with this 今日\", \"文字今日\", true},\n\t\t{\"can we do unicode 文字 with this 今日\", \"d文字tt今日\", true},\n\t\t{\"can we do unicode 文字 with this 今日\", \"d文字ttt今日\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tif fuzzyMatch(test.s, test.sub) != test.match {\n\t\t\tt.Errorf(\"fuzzymatch, %s in %s: expected %v, got %v\", test.sub, test.s, test.match, !test.match)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.2470703125,
          "content": "module github.com/c-bata/go-prompt\n\ngo 1.14\n\nrequire (\n\tgithub.com/mattn/go-colorable v0.1.7\n\tgithub.com/mattn/go-runewidth v0.0.9\n\tgithub.com/mattn/go-tty v0.0.3\n\tgithub.com/pkg/term v1.2.0-beta.2\n\tgolang.org/x/sys v0.0.0-20200918174421-af09f7315aff\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.1318359375,
          "content": "github.com/mattn/go-colorable v0.1.4/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=\ngithub.com/mattn/go-colorable v0.1.7 h1:bQGKb3vps/j0E9GfJQ03JyhRuxsvdAanXlT9BTw3mdw=\ngithub.com/mattn/go-colorable v0.1.7/go.mod h1:u6P/XSegPjTcexA+o6vUJrdnUu04hMope9wVRipJSqc=\ngithub.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=\ngithub.com/mattn/go-isatty v0.0.10/go.mod h1:qgIWMr58cqv1PHHyhnkY9lrL7etaEgOFcMEpPG5Rm84=\ngithub.com/mattn/go-isatty v0.0.12 h1:wuysRhFDzyxgEmMf5xjvJ2M9dZoWAXNNr5LSBS7uHXY=\ngithub.com/mattn/go-isatty v0.0.12/go.mod h1:cbi8OIDigv2wuxKPP5vlRcQ1OAZbq2CE4Kysco4FUpU=\ngithub.com/mattn/go-runewidth v0.0.6/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=\ngithub.com/mattn/go-runewidth v0.0.9 h1:Lm995f3rfxdpd6TSmuVCHVb/QhupuXlYr8sCI/QdE+0=\ngithub.com/mattn/go-runewidth v0.0.9/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=\ngithub.com/mattn/go-tty v0.0.3 h1:5OfyWorkyO7xP52Mq7tB36ajHDG5OHrmBGIS/DtakQI=\ngithub.com/mattn/go-tty v0.0.3/go.mod h1:ihxohKRERHTVzN+aSVRwACLCeqIoZAWpoICkkvrWyR0=\ngithub.com/pkg/term v1.2.0-beta.2 h1:L3y/h2jkuBVFdWiJvNfYfKmzcCnILw7mJWm2JQuMppw=\ngithub.com/pkg/term v1.2.0-beta.2/go.mod h1:E25nymQcrSllhX42Ok8MRm1+hyBdHY0dCeiKZ9jpNGw=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20191008105621-543471e840be/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191120155948-bd437916bb0e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200116001909-b77594299b42/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200909081042-eff7692f9009/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200918174421-af09f7315aff h1:1CPUrky56AcgSpxz/KfgzQWzfG09u5YOL8MvPYBlrL8=\ngolang.org/x/sys v0.0.0-20200918174421-af09f7315aff/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n"
        },
        {
          "name": "history.go",
          "type": "blob",
          "size": 1.453125,
          "content": "package prompt\n\n// History stores the texts that are entered.\ntype History struct {\n\thistories []string\n\ttmp       []string\n\tselected  int\n}\n\n// Add to add text in history.\nfunc (h *History) Add(input string) {\n\th.histories = append(h.histories, input)\n\th.Clear()\n}\n\n// Clear to clear the history.\nfunc (h *History) Clear() {\n\th.tmp = make([]string, len(h.histories))\n\tfor i := range h.histories {\n\t\th.tmp[i] = h.histories[i]\n\t}\n\th.tmp = append(h.tmp, \"\")\n\th.selected = len(h.tmp) - 1\n}\n\n// Older saves a buffer of current line and get a buffer of previous line by up-arrow.\n// The changes of line buffers are stored until new history is created.\nfunc (h *History) Older(buf *Buffer) (new *Buffer, changed bool) {\n\tif len(h.tmp) == 1 || h.selected == 0 {\n\t\treturn buf, false\n\t}\n\th.tmp[h.selected] = buf.Text()\n\n\th.selected--\n\tnew = NewBuffer()\n\tnew.InsertText(h.tmp[h.selected], false, true)\n\treturn new, true\n}\n\n// Newer saves a buffer of current line and get a buffer of next line by up-arrow.\n// The changes of line buffers are stored until new history is created.\nfunc (h *History) Newer(buf *Buffer) (new *Buffer, changed bool) {\n\tif h.selected >= len(h.tmp)-1 {\n\t\treturn buf, false\n\t}\n\th.tmp[h.selected] = buf.Text()\n\n\th.selected++\n\tnew = NewBuffer()\n\tnew.InsertText(h.tmp[h.selected], false, true)\n\treturn new, true\n}\n\n// NewHistory returns new history object.\nfunc NewHistory() *History {\n\treturn &History{\n\t\thistories: []string{},\n\t\ttmp:       []string{\"\"},\n\t\tselected:  0,\n\t}\n}\n"
        },
        {
          "name": "history_test.go",
          "type": "blob",
          "size": 1.2880859375,
          "content": "package prompt\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestHistoryClear(t *testing.T) {\n\th := NewHistory()\n\th.Add(\"foo\")\n\th.Clear()\n\texpected := &History{\n\t\thistories: []string{\"foo\"},\n\t\ttmp:       []string{\"foo\", \"\"},\n\t\tselected:  1,\n\t}\n\tif !reflect.DeepEqual(expected, h) {\n\t\tt.Errorf(\"Should be %#v, but got %#v\", expected, h)\n\t}\n}\n\nfunc TestHistoryAdd(t *testing.T) {\n\th := NewHistory()\n\th.Add(\"echo 1\")\n\texpected := &History{\n\t\thistories: []string{\"echo 1\"},\n\t\ttmp:       []string{\"echo 1\", \"\"},\n\t\tselected:  1,\n\t}\n\tif !reflect.DeepEqual(h, expected) {\n\t\tt.Errorf(\"Should be %v, but got %v\", expected, h)\n\t}\n}\n\nfunc TestHistoryOlder(t *testing.T) {\n\th := NewHistory()\n\th.Add(\"echo 1\")\n\n\t// Prepare buffer\n\tbuf := NewBuffer()\n\tbuf.InsertText(\"echo 2\", false, true)\n\n\t// [1 time] Call Older function\n\tbuf1, changed := h.Older(buf)\n\tif !changed {\n\t\tt.Error(\"Should be changed history but not changed.\")\n\t}\n\tif buf1.Text() != \"echo 1\" {\n\t\tt.Errorf(\"Should be %#v, but got %#v\", \"echo 1\", buf1.Text())\n\t}\n\n\t// [2 times] Call Older function\n\tbuf = NewBuffer()\n\tbuf.InsertText(\"echo 1\", false, true)\n\tbuf2, changed := h.Older(buf)\n\tif changed {\n\t\tt.Error(\"Should be not changed history but changed.\")\n\t}\n\tif !reflect.DeepEqual(\"echo 1\", buf2.Text()) {\n\t\tt.Errorf(\"Should be %#v, but got %#v\", \"echo 1\", buf2.Text())\n\t}\n}\n"
        },
        {
          "name": "input.go",
          "type": "blob",
          "size": 7.451171875,
          "content": "package prompt\n\nimport \"bytes\"\n\n// WinSize represents the width and height of terminal.\ntype WinSize struct {\n\tRow uint16\n\tCol uint16\n}\n\n// ConsoleParser is an interface to abstract input layer.\ntype ConsoleParser interface {\n\t// Setup should be called before starting input\n\tSetup() error\n\t// TearDown should be called after stopping input\n\tTearDown() error\n\t// GetWinSize returns WinSize object to represent width and height of terminal.\n\tGetWinSize() *WinSize\n\t// Read returns byte array.\n\tRead() ([]byte, error)\n}\n\n// GetKey returns Key correspond to input byte codes.\nfunc GetKey(b []byte) Key {\n\tfor _, k := range ASCIISequences {\n\t\tif bytes.Equal(k.ASCIICode, b) {\n\t\t\treturn k.Key\n\t\t}\n\t}\n\treturn NotDefined\n}\n\n// ASCIISequences holds mappings of the key and byte array.\nvar ASCIISequences = []*ASCIICode{\n\t{Key: Escape, ASCIICode: []byte{0x1b}},\n\n\t{Key: ControlSpace, ASCIICode: []byte{0x00}},\n\t{Key: ControlA, ASCIICode: []byte{0x1}},\n\t{Key: ControlB, ASCIICode: []byte{0x2}},\n\t{Key: ControlC, ASCIICode: []byte{0x3}},\n\t{Key: ControlD, ASCIICode: []byte{0x4}},\n\t{Key: ControlE, ASCIICode: []byte{0x5}},\n\t{Key: ControlF, ASCIICode: []byte{0x6}},\n\t{Key: ControlG, ASCIICode: []byte{0x7}},\n\t{Key: ControlH, ASCIICode: []byte{0x8}},\n\t//{Key: ControlI, ASCIICode: []byte{0x9}},\n\t//{Key: ControlJ, ASCIICode: []byte{0xa}},\n\t{Key: ControlK, ASCIICode: []byte{0xb}},\n\t{Key: ControlL, ASCIICode: []byte{0xc}},\n\t{Key: ControlM, ASCIICode: []byte{0xd}},\n\t{Key: ControlN, ASCIICode: []byte{0xe}},\n\t{Key: ControlO, ASCIICode: []byte{0xf}},\n\t{Key: ControlP, ASCIICode: []byte{0x10}},\n\t{Key: ControlQ, ASCIICode: []byte{0x11}},\n\t{Key: ControlR, ASCIICode: []byte{0x12}},\n\t{Key: ControlS, ASCIICode: []byte{0x13}},\n\t{Key: ControlT, ASCIICode: []byte{0x14}},\n\t{Key: ControlU, ASCIICode: []byte{0x15}},\n\t{Key: ControlV, ASCIICode: []byte{0x16}},\n\t{Key: ControlW, ASCIICode: []byte{0x17}},\n\t{Key: ControlX, ASCIICode: []byte{0x18}},\n\t{Key: ControlY, ASCIICode: []byte{0x19}},\n\t{Key: ControlZ, ASCIICode: []byte{0x1a}},\n\n\t{Key: ControlBackslash, ASCIICode: []byte{0x1c}},\n\t{Key: ControlSquareClose, ASCIICode: []byte{0x1d}},\n\t{Key: ControlCircumflex, ASCIICode: []byte{0x1e}},\n\t{Key: ControlUnderscore, ASCIICode: []byte{0x1f}},\n\t{Key: Backspace, ASCIICode: []byte{0x7f}},\n\n\t{Key: Up, ASCIICode: []byte{0x1b, 0x5b, 0x41}},\n\t{Key: Down, ASCIICode: []byte{0x1b, 0x5b, 0x42}},\n\t{Key: Right, ASCIICode: []byte{0x1b, 0x5b, 0x43}},\n\t{Key: Left, ASCIICode: []byte{0x1b, 0x5b, 0x44}},\n\t{Key: Home, ASCIICode: []byte{0x1b, 0x5b, 0x48}},\n\t{Key: Home, ASCIICode: []byte{0x1b, 0x30, 0x48}},\n\t{Key: End, ASCIICode: []byte{0x1b, 0x5b, 0x46}},\n\t{Key: End, ASCIICode: []byte{0x1b, 0x30, 0x46}},\n\n\t{Key: Enter, ASCIICode: []byte{0xa}},\n\t{Key: Delete, ASCIICode: []byte{0x1b, 0x5b, 0x33, 0x7e}},\n\t{Key: ShiftDelete, ASCIICode: []byte{0x1b, 0x5b, 0x33, 0x3b, 0x32, 0x7e}},\n\t{Key: ControlDelete, ASCIICode: []byte{0x1b, 0x5b, 0x33, 0x3b, 0x35, 0x7e}},\n\t{Key: Home, ASCIICode: []byte{0x1b, 0x5b, 0x31, 0x7e}},\n\t{Key: End, ASCIICode: []byte{0x1b, 0x5b, 0x34, 0x7e}},\n\t{Key: PageUp, ASCIICode: []byte{0x1b, 0x5b, 0x35, 0x7e}},\n\t{Key: PageDown, ASCIICode: []byte{0x1b, 0x5b, 0x36, 0x7e}},\n\t{Key: Home, ASCIICode: []byte{0x1b, 0x5b, 0x37, 0x7e}},\n\t{Key: End, ASCIICode: []byte{0x1b, 0x5b, 0x38, 0x7e}},\n\t{Key: Tab, ASCIICode: []byte{0x9}},\n\t{Key: BackTab, ASCIICode: []byte{0x1b, 0x5b, 0x5a}},\n\t{Key: Insert, ASCIICode: []byte{0x1b, 0x5b, 0x32, 0x7e}},\n\n\t{Key: F1, ASCIICode: []byte{0x1b, 0x4f, 0x50}},\n\t{Key: F2, ASCIICode: []byte{0x1b, 0x4f, 0x51}},\n\t{Key: F3, ASCIICode: []byte{0x1b, 0x4f, 0x52}},\n\t{Key: F4, ASCIICode: []byte{0x1b, 0x4f, 0x53}},\n\n\t{Key: F1, ASCIICode: []byte{0x1b, 0x4f, 0x50, 0x41}}, // Linux console\n\t{Key: F2, ASCIICode: []byte{0x1b, 0x5b, 0x5b, 0x42}}, // Linux console\n\t{Key: F3, ASCIICode: []byte{0x1b, 0x5b, 0x5b, 0x43}}, // Linux console\n\t{Key: F4, ASCIICode: []byte{0x1b, 0x5b, 0x5b, 0x44}}, // Linux console\n\t{Key: F5, ASCIICode: []byte{0x1b, 0x5b, 0x5b, 0x45}}, // Linux console\n\n\t{Key: F1, ASCIICode: []byte{0x1b, 0x5b, 0x11, 0x7e}}, // rxvt-unicode\n\t{Key: F2, ASCIICode: []byte{0x1b, 0x5b, 0x12, 0x7e}}, // rxvt-unicode\n\t{Key: F3, ASCIICode: []byte{0x1b, 0x5b, 0x13, 0x7e}}, // rxvt-unicode\n\t{Key: F4, ASCIICode: []byte{0x1b, 0x5b, 0x14, 0x7e}}, // rxvt-unicode\n\n\t{Key: F5, ASCIICode: []byte{0x1b, 0x5b, 0x31, 0x35, 0x7e}},\n\t{Key: F6, ASCIICode: []byte{0x1b, 0x5b, 0x31, 0x37, 0x7e}},\n\t{Key: F7, ASCIICode: []byte{0x1b, 0x5b, 0x31, 0x38, 0x7e}},\n\t{Key: F8, ASCIICode: []byte{0x1b, 0x5b, 0x31, 0x39, 0x7e}},\n\t{Key: F9, ASCIICode: []byte{0x1b, 0x5b, 0x32, 0x30, 0x7e}},\n\t{Key: F10, ASCIICode: []byte{0x1b, 0x5b, 0x32, 0x31, 0x7e}},\n\t{Key: F11, ASCIICode: []byte{0x1b, 0x5b, 0x32, 0x32, 0x7e}},\n\t{Key: F12, ASCIICode: []byte{0x1b, 0x5b, 0x32, 0x34, 0x7e, 0x8}},\n\t{Key: F13, ASCIICode: []byte{0x1b, 0x5b, 0x25, 0x7e}},\n\t{Key: F14, ASCIICode: []byte{0x1b, 0x5b, 0x26, 0x7e}},\n\t{Key: F15, ASCIICode: []byte{0x1b, 0x5b, 0x28, 0x7e}},\n\t{Key: F16, ASCIICode: []byte{0x1b, 0x5b, 0x29, 0x7e}},\n\t{Key: F17, ASCIICode: []byte{0x1b, 0x5b, 0x31, 0x7e}},\n\t{Key: F18, ASCIICode: []byte{0x1b, 0x5b, 0x32, 0x7e}},\n\t{Key: F19, ASCIICode: []byte{0x1b, 0x5b, 0x33, 0x7e}},\n\t{Key: F20, ASCIICode: []byte{0x1b, 0x5b, 0x34, 0x7e}},\n\n\t// Xterm\n\t{Key: F13, ASCIICode: []byte{0x1b, 0x5b, 0x31, 0x3b, 0x32, 0x50}},\n\t{Key: F14, ASCIICode: []byte{0x1b, 0x5b, 0x31, 0x3b, 0x32, 0x51}},\n\t// &ASCIICode{Key: F15, ASCIICode: []byte{0x1b, 0x5b, 0x31, 0x3b, 0x32, 0x52}},  // Conflicts with CPR response\n\t{Key: F16, ASCIICode: []byte{0x1b, 0x5b, 0x31, 0x3b, 0x32, 0x52}},\n\t{Key: F17, ASCIICode: []byte{0x1b, 0x5b, 0x15, 0x3b, 0x32, 0x7e}},\n\t{Key: F18, ASCIICode: []byte{0x1b, 0x5b, 0x17, 0x3b, 0x32, 0x7e}},\n\t{Key: F19, ASCIICode: []byte{0x1b, 0x5b, 0x18, 0x3b, 0x32, 0x7e}},\n\t{Key: F20, ASCIICode: []byte{0x1b, 0x5b, 0x19, 0x3b, 0x32, 0x7e}},\n\t{Key: F21, ASCIICode: []byte{0x1b, 0x5b, 0x20, 0x3b, 0x32, 0x7e}},\n\t{Key: F22, ASCIICode: []byte{0x1b, 0x5b, 0x21, 0x3b, 0x32, 0x7e}},\n\t{Key: F23, ASCIICode: []byte{0x1b, 0x5b, 0x23, 0x3b, 0x32, 0x7e}},\n\t{Key: F24, ASCIICode: []byte{0x1b, 0x5b, 0x24, 0x3b, 0x32, 0x7e}},\n\n\t{Key: ControlUp, ASCIICode: []byte{0x1b, 0x5b, 0x31, 0x3b, 0x35, 0x41}},\n\t{Key: ControlDown, ASCIICode: []byte{0x1b, 0x5b, 0x31, 0x3b, 0x35, 0x42}},\n\t{Key: ControlRight, ASCIICode: []byte{0x1b, 0x5b, 0x31, 0x3b, 0x35, 0x43}},\n\t{Key: ControlLeft, ASCIICode: []byte{0x1b, 0x5b, 0x31, 0x3b, 0x35, 0x44}},\n\n\t{Key: ShiftUp, ASCIICode: []byte{0x1b, 0x5b, 0x31, 0x3b, 0x32, 0x41}},\n\t{Key: ShiftDown, ASCIICode: []byte{0x1b, 0x5b, 0x31, 0x3b, 0x32, 0x42}},\n\t{Key: ShiftRight, ASCIICode: []byte{0x1b, 0x5b, 0x31, 0x3b, 0x32, 0x43}},\n\t{Key: ShiftLeft, ASCIICode: []byte{0x1b, 0x5b, 0x31, 0x3b, 0x32, 0x44}},\n\n\t// Tmux sends following keystrokes when control+arrow is pressed, but for\n\t// Emacs ansi-term sends the same sequences for normal arrow keys. Consider\n\t// it a normal arrow press, because that's more important.\n\t{Key: Up, ASCIICode: []byte{0x1b, 0x4f, 0x41}},\n\t{Key: Down, ASCIICode: []byte{0x1b, 0x4f, 0x42}},\n\t{Key: Right, ASCIICode: []byte{0x1b, 0x4f, 0x43}},\n\t{Key: Left, ASCIICode: []byte{0x1b, 0x4f, 0x44}},\n\n\t{Key: ControlUp, ASCIICode: []byte{0x1b, 0x5b, 0x35, 0x41}},\n\t{Key: ControlDown, ASCIICode: []byte{0x1b, 0x5b, 0x35, 0x42}},\n\t{Key: ControlRight, ASCIICode: []byte{0x1b, 0x5b, 0x35, 0x43}},\n\t{Key: ControlLeft, ASCIICode: []byte{0x1b, 0x5b, 0x35, 0x44}},\n\n\t{Key: ControlRight, ASCIICode: []byte{0x1b, 0x5b, 0x4f, 0x63}}, // rxvt\n\t{Key: ControlLeft, ASCIICode: []byte{0x1b, 0x5b, 0x4f, 0x64}},  // rxvt\n\n\t{Key: Ignore, ASCIICode: []byte{0x1b, 0x5b, 0x45}}, // Xterm\n\t{Key: Ignore, ASCIICode: []byte{0x1b, 0x5b, 0x46}}, // Linux console\n}\n"
        },
        {
          "name": "input_posix.go",
          "type": "blob",
          "size": 1.609375,
          "content": "// +build !windows\n\npackage prompt\n\nimport (\n\t\"syscall\"\n\n\t\"github.com/c-bata/go-prompt/internal/term\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst maxReadBytes = 1024\n\n// PosixParser is a ConsoleParser implementation for POSIX environment.\ntype PosixParser struct {\n\tfd          int\n\torigTermios syscall.Termios\n}\n\n// Setup should be called before starting input\nfunc (t *PosixParser) Setup() error {\n\t// Set NonBlocking mode because if syscall.Read block this goroutine, it cannot receive data from stopCh.\n\tif err := syscall.SetNonblock(t.fd, true); err != nil {\n\t\treturn err\n\t}\n\tif err := term.SetRaw(t.fd); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// TearDown should be called after stopping input\nfunc (t *PosixParser) TearDown() error {\n\tif err := syscall.SetNonblock(t.fd, false); err != nil {\n\t\treturn err\n\t}\n\tif err := term.Restore(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Read returns byte array.\nfunc (t *PosixParser) Read() ([]byte, error) {\n\tbuf := make([]byte, maxReadBytes)\n\tn, err := syscall.Read(t.fd, buf)\n\tif err != nil {\n\t\treturn []byte{}, err\n\t}\n\treturn buf[:n], nil\n}\n\n// GetWinSize returns WinSize object to represent width and height of terminal.\nfunc (t *PosixParser) GetWinSize() *WinSize {\n\tws, err := unix.IoctlGetWinsize(t.fd, unix.TIOCGWINSZ)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn &WinSize{\n\t\tRow: ws.Row,\n\t\tCol: ws.Col,\n\t}\n}\n\nvar _ ConsoleParser = &PosixParser{}\n\n// NewStandardInputParser returns ConsoleParser object to read from stdin.\nfunc NewStandardInputParser() *PosixParser {\n\tin, err := syscall.Open(\"/dev/tty\", syscall.O_RDONLY, 0)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &PosixParser{\n\t\tfd: in,\n\t}\n}\n"
        },
        {
          "name": "input_test.go",
          "type": "blob",
          "size": 0.5205078125,
          "content": "package prompt\n\nimport (\n\t\"testing\"\n)\n\nfunc TestPosixParserGetKey(t *testing.T) {\n\tscenarioTable := []struct {\n\t\tname     string\n\t\tinput    []byte\n\t\texpected Key\n\t}{\n\t\t{\n\t\t\tname:     \"escape\",\n\t\t\tinput:    []byte{0x1b},\n\t\t\texpected: Escape,\n\t\t},\n\t\t{\n\t\t\tname:     \"undefined\",\n\t\t\tinput:    []byte{'a'},\n\t\t\texpected: NotDefined,\n\t\t},\n\t}\n\n\tfor _, s := range scenarioTable {\n\t\tt.Run(s.name, func(t *testing.T) {\n\t\t\tkey := GetKey(s.input)\n\t\t\tif key != s.expected {\n\t\t\t\tt.Errorf(\"Should be %s, but got %s\", key, s.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "input_windows.go",
          "type": "blob",
          "size": 1.6396484375,
          "content": "// +build windows\n\npackage prompt\n\nimport (\n\t\"errors\"\n\t\"syscall\"\n\t\"unicode/utf8\"\n\t\"unsafe\"\n\n\ttty \"github.com/mattn/go-tty\"\n)\n\nconst maxReadBytes = 1024\n\nvar kernel32 = syscall.NewLazyDLL(\"kernel32.dll\")\n\nvar procGetNumberOfConsoleInputEvents = kernel32.NewProc(\"GetNumberOfConsoleInputEvents\")\n\n// WindowsParser is a ConsoleParser implementation for Win32 console.\ntype WindowsParser struct {\n\ttty *tty.TTY\n}\n\n// Setup should be called before starting input\nfunc (p *WindowsParser) Setup() error {\n\tt, err := tty.Open()\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.tty = t\n\treturn nil\n}\n\n// TearDown should be called after stopping input\nfunc (p *WindowsParser) TearDown() error {\n\treturn p.tty.Close()\n}\n\n// Read returns byte array.\nfunc (p *WindowsParser) Read() ([]byte, error) {\n\tvar ev uint32\n\tr0, _, err := procGetNumberOfConsoleInputEvents.Call(p.tty.Input().Fd(), uintptr(unsafe.Pointer(&ev)))\n\tif r0 == 0 {\n\t\treturn nil, err\n\t}\n\tif ev == 0 {\n\t\treturn nil, errors.New(\"EAGAIN\")\n\t}\n\n\tr, err := p.tty.ReadRune()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbuf := make([]byte, maxReadBytes)\n\tn := utf8.EncodeRune(buf[:], r)\n\tfor p.tty.Buffered() && n < maxReadBytes {\n\t\tr, err := p.tty.ReadRune()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tn += utf8.EncodeRune(buf[n:], r)\n\t}\n\treturn buf[:n], nil\n}\n\n// GetWinSize returns WinSize object to represent width and height of terminal.\nfunc (p *WindowsParser) GetWinSize() *WinSize {\n\tw, h, err := p.tty.Size()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn &WinSize{\n\t\tRow: uint16(h),\n\t\tCol: uint16(w),\n\t}\n}\n\n// NewStandardInputParser returns ConsoleParser object to read from stdin.\nfunc NewStandardInputParser() *WindowsParser {\n\treturn &WindowsParser{}\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "key.go",
          "type": "blob",
          "size": 1.705078125,
          "content": "// Code generated by hand; DO NOT EDIT.\n// This is a little bit stupid, but there are many public constants which is no value for writing godoc comment.\n\npackage prompt\n\n// Key is the type express the key inserted from user.\n//go:generate stringer -type=Key\ntype Key int\n\n// ASCIICode is the type contains Key and it's ascii byte array.\ntype ASCIICode struct {\n\tKey       Key\n\tASCIICode []byte\n}\n\nconst (\n\tEscape Key = iota\n\n\tControlA\n\tControlB\n\tControlC\n\tControlD\n\tControlE\n\tControlF\n\tControlG\n\tControlH\n\tControlI\n\tControlJ\n\tControlK\n\tControlL\n\tControlM\n\tControlN\n\tControlO\n\tControlP\n\tControlQ\n\tControlR\n\tControlS\n\tControlT\n\tControlU\n\tControlV\n\tControlW\n\tControlX\n\tControlY\n\tControlZ\n\n\tControlSpace\n\tControlBackslash\n\tControlSquareClose\n\tControlCircumflex\n\tControlUnderscore\n\tControlLeft\n\tControlRight\n\tControlUp\n\tControlDown\n\n\tUp\n\tDown\n\tRight\n\tLeft\n\n\tShiftLeft\n\tShiftUp\n\tShiftDown\n\tShiftRight\n\n\tHome\n\tEnd\n\tDelete\n\tShiftDelete\n\tControlDelete\n\tPageUp\n\tPageDown\n\tBackTab\n\tInsert\n\tBackspace\n\n\t// Aliases.\n\tTab\n\tEnter\n\t// Actually Enter equals ControlM, not ControlJ,\n\t// However, in prompt_toolkit, we made the mistake of translating\n\t// \\r into \\n during the input, so everyone is now handling the\n\t// enter key by binding ControlJ.\n\n\t// From now on, it's better to bind `ASCII_SEQUENCES.Enter` everywhere,\n\t// because that's future compatible, and will still work when we\n\t// stop replacing \\r by \\n.\n\n\tF1\n\tF2\n\tF3\n\tF4\n\tF5\n\tF6\n\tF7\n\tF8\n\tF9\n\tF10\n\tF11\n\tF12\n\tF13\n\tF14\n\tF15\n\tF16\n\tF17\n\tF18\n\tF19\n\tF20\n\tF21\n\tF22\n\tF23\n\tF24\n\n\t// Matches any key.\n\tAny\n\n\t// Special\n\tCPRResponse\n\tVt100MouseEvent\n\tWindowsMouseEvent\n\tBracketedPaste\n\n\t// Key which is ignored. (The key binding for this key should not do anything.)\n\tIgnore\n\n\t// Key is not defined\n\tNotDefined\n)\n"
        },
        {
          "name": "key_bind.go",
          "type": "blob",
          "size": 1.0830078125,
          "content": "package prompt\n\n// KeyBindFunc receives buffer and processed it.\ntype KeyBindFunc func(*Buffer)\n\n// KeyBind represents which key should do what operation.\ntype KeyBind struct {\n\tKey Key\n\tFn  KeyBindFunc\n}\n\n// ASCIICodeBind represents which []byte should do what operation\ntype ASCIICodeBind struct {\n\tASCIICode []byte\n\tFn        KeyBindFunc\n}\n\n// KeyBindMode to switch a key binding flexibly.\ntype KeyBindMode string\n\nconst (\n\t// CommonKeyBind is a mode without any keyboard shortcut\n\tCommonKeyBind KeyBindMode = \"common\"\n\t// EmacsKeyBind is a mode to use emacs-like keyboard shortcut\n\tEmacsKeyBind KeyBindMode = \"emacs\"\n)\n\nvar commonKeyBindings = []KeyBind{\n\t// Go to the End of the line\n\t{\n\t\tKey: End,\n\t\tFn:  GoLineEnd,\n\t},\n\t// Go to the beginning of the line\n\t{\n\t\tKey: Home,\n\t\tFn:  GoLineBeginning,\n\t},\n\t// Delete character under the cursor\n\t{\n\t\tKey: Delete,\n\t\tFn:  DeleteChar,\n\t},\n\t// Backspace\n\t{\n\t\tKey: Backspace,\n\t\tFn:  DeleteBeforeChar,\n\t},\n\t// Right allow: Forward one character\n\t{\n\t\tKey: Right,\n\t\tFn:  GoRightChar,\n\t},\n\t// Left allow: Backward one character\n\t{\n\t\tKey: Left,\n\t\tFn:  GoLeftChar,\n\t},\n}\n"
        },
        {
          "name": "key_bind_func.go",
          "type": "blob",
          "size": 1.1904296875,
          "content": "package prompt\n\n// GoLineEnd Go to the End of the line\nfunc GoLineEnd(buf *Buffer) {\n\tx := []rune(buf.Document().TextAfterCursor())\n\tbuf.CursorRight(len(x))\n}\n\n// GoLineBeginning Go to the beginning of the line\nfunc GoLineBeginning(buf *Buffer) {\n\tx := []rune(buf.Document().TextBeforeCursor())\n\tbuf.CursorLeft(len(x))\n}\n\n// DeleteChar Delete character under the cursor\nfunc DeleteChar(buf *Buffer) {\n\tbuf.Delete(1)\n}\n\n// DeleteWord Delete word before the cursor\nfunc DeleteWord(buf *Buffer) {\n\tbuf.DeleteBeforeCursor(len([]rune(buf.Document().TextBeforeCursor())) - buf.Document().FindStartOfPreviousWordWithSpace())\n}\n\n// DeleteBeforeChar Go to Backspace\nfunc DeleteBeforeChar(buf *Buffer) {\n\tbuf.DeleteBeforeCursor(1)\n}\n\n// GoRightChar Forward one character\nfunc GoRightChar(buf *Buffer) {\n\tbuf.CursorRight(1)\n}\n\n// GoLeftChar Backward one character\nfunc GoLeftChar(buf *Buffer) {\n\tbuf.CursorLeft(1)\n}\n\n// GoRightWord Forward one word\nfunc GoRightWord(buf *Buffer) {\n\tbuf.CursorRight(buf.Document().FindEndOfCurrentWordWithSpace())\n}\n\n// GoLeftWord Backward one word\nfunc GoLeftWord(buf *Buffer) {\n\tbuf.CursorLeft(len([]rune(buf.Document().TextBeforeCursor())) - buf.Document().FindStartOfPreviousWordWithSpace())\n}\n"
        },
        {
          "name": "key_string.go",
          "type": "blob",
          "size": 1.3271484375,
          "content": "// Code generated by \"stringer -type=Key\"; DO NOT EDIT.\n\npackage prompt\n\nimport \"strconv\"\n\nconst _Key_name = \"EscapeControlAControlBControlCControlDControlEControlFControlGControlHControlIControlJControlKControlLControlMControlNControlOControlPControlQControlRControlSControlTControlUControlVControlWControlXControlYControlZControlSpaceControlBackslashControlSquareCloseControlCircumflexControlUnderscoreControlLeftControlRightControlUpControlDownUpDownRightLeftShiftLeftShiftUpShiftDownShiftRightHomeEndDeleteShiftDeleteControlDeletePageUpPageDownBackTabInsertBackspaceTabEnterF1F2F3F4F5F6F7F8F9F10F11F12F13F14F15F16F17F18F19F20F21F22F23F24AnyCPRResponseVt100MouseEventWindowsMouseEventBracketedPasteIgnoreNotDefined\"\n\nvar _Key_index = [...]uint16{0, 6, 14, 22, 30, 38, 46, 54, 62, 70, 78, 86, 94, 102, 110, 118, 126, 134, 142, 150, 158, 166, 174, 182, 190, 198, 206, 214, 226, 242, 260, 277, 294, 305, 317, 326, 337, 339, 343, 348, 352, 361, 368, 377, 387, 391, 394, 400, 411, 424, 430, 438, 445, 451, 460, 463, 468, 470, 472, 474, 476, 478, 480, 482, 484, 486, 489, 492, 495, 498, 501, 504, 507, 510, 513, 516, 519, 522, 525, 528, 531, 534, 545, 560, 577, 591, 597, 607}\n\nfunc (i Key) String() string {\n\tif i < 0 || i >= Key(len(_Key_index)-1) {\n\t\treturn \"Key(\" + strconv.FormatInt(int64(i), 10) + \")\"\n\t}\n\treturn _Key_name[_Key_index[i]:_Key_index[i+1]]\n}\n"
        },
        {
          "name": "option.go",
          "type": "blob",
          "size": 8.5322265625,
          "content": "package prompt\n\n// Option is the type to replace default parameters.\n// prompt.New accepts any number of options (this is functional option pattern).\ntype Option func(prompt *Prompt) error\n\n// OptionParser to set a custom ConsoleParser object. An argument should implement ConsoleParser interface.\nfunc OptionParser(x ConsoleParser) Option {\n\treturn func(p *Prompt) error {\n\t\tp.in = x\n\t\treturn nil\n\t}\n}\n\n// OptionWriter to set a custom ConsoleWriter object. An argument should implement ConsoleWriter interface.\nfunc OptionWriter(x ConsoleWriter) Option {\n\treturn func(p *Prompt) error {\n\t\tregisterConsoleWriter(x)\n\t\tp.renderer.out = x\n\t\treturn nil\n\t}\n}\n\n// OptionTitle to set title displayed at the header bar of terminal.\nfunc OptionTitle(x string) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.title = x\n\t\treturn nil\n\t}\n}\n\n// OptionPrefix to set prefix string.\nfunc OptionPrefix(x string) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.prefix = x\n\t\treturn nil\n\t}\n}\n\n// OptionInitialBufferText to set the initial buffer text\nfunc OptionInitialBufferText(x string) Option {\n\treturn func(p *Prompt) error {\n\t\tp.buf.InsertText(x, false, true)\n\t\treturn nil\n\t}\n}\n\n// OptionCompletionWordSeparator to set word separators. Enable only ' ' if empty.\nfunc OptionCompletionWordSeparator(x string) Option {\n\treturn func(p *Prompt) error {\n\t\tp.completion.wordSeparator = x\n\t\treturn nil\n\t}\n}\n\n// OptionLivePrefix to change the prefix dynamically by callback function\nfunc OptionLivePrefix(f func() (prefix string, useLivePrefix bool)) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.livePrefixCallback = f\n\t\treturn nil\n\t}\n}\n\n// OptionPrefixTextColor change a text color of prefix string\nfunc OptionPrefixTextColor(x Color) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.prefixTextColor = x\n\t\treturn nil\n\t}\n}\n\n// OptionPrefixBackgroundColor to change a background color of prefix string\nfunc OptionPrefixBackgroundColor(x Color) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.prefixBGColor = x\n\t\treturn nil\n\t}\n}\n\n// OptionInputTextColor to change a color of text which is input by user\nfunc OptionInputTextColor(x Color) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.inputTextColor = x\n\t\treturn nil\n\t}\n}\n\n// OptionInputBGColor to change a color of background which is input by user\nfunc OptionInputBGColor(x Color) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.inputBGColor = x\n\t\treturn nil\n\t}\n}\n\n// OptionPreviewSuggestionTextColor to change a text color which is completed\nfunc OptionPreviewSuggestionTextColor(x Color) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.previewSuggestionTextColor = x\n\t\treturn nil\n\t}\n}\n\n// OptionPreviewSuggestionBGColor to change a background color which is completed\nfunc OptionPreviewSuggestionBGColor(x Color) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.previewSuggestionBGColor = x\n\t\treturn nil\n\t}\n}\n\n// OptionSuggestionTextColor to change a text color in drop down suggestions.\nfunc OptionSuggestionTextColor(x Color) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.suggestionTextColor = x\n\t\treturn nil\n\t}\n}\n\n// OptionSuggestionBGColor change a background color in drop down suggestions.\nfunc OptionSuggestionBGColor(x Color) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.suggestionBGColor = x\n\t\treturn nil\n\t}\n}\n\n// OptionSelectedSuggestionTextColor to change a text color for completed text which is selected inside suggestions drop down box.\nfunc OptionSelectedSuggestionTextColor(x Color) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.selectedSuggestionTextColor = x\n\t\treturn nil\n\t}\n}\n\n// OptionSelectedSuggestionBGColor to change a background color for completed text which is selected inside suggestions drop down box.\nfunc OptionSelectedSuggestionBGColor(x Color) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.selectedSuggestionBGColor = x\n\t\treturn nil\n\t}\n}\n\n// OptionDescriptionTextColor to change a background color of description text in drop down suggestions.\nfunc OptionDescriptionTextColor(x Color) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.descriptionTextColor = x\n\t\treturn nil\n\t}\n}\n\n// OptionDescriptionBGColor to change a background color of description text in drop down suggestions.\nfunc OptionDescriptionBGColor(x Color) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.descriptionBGColor = x\n\t\treturn nil\n\t}\n}\n\n// OptionSelectedDescriptionTextColor to change a text color of description which is selected inside suggestions drop down box.\nfunc OptionSelectedDescriptionTextColor(x Color) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.selectedDescriptionTextColor = x\n\t\treturn nil\n\t}\n}\n\n// OptionSelectedDescriptionBGColor to change a background color of description which is selected inside suggestions drop down box.\nfunc OptionSelectedDescriptionBGColor(x Color) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.selectedDescriptionBGColor = x\n\t\treturn nil\n\t}\n}\n\n// OptionScrollbarThumbColor to change a thumb color on scrollbar.\nfunc OptionScrollbarThumbColor(x Color) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.scrollbarThumbColor = x\n\t\treturn nil\n\t}\n}\n\n// OptionScrollbarBGColor to change a background color of scrollbar.\nfunc OptionScrollbarBGColor(x Color) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.scrollbarBGColor = x\n\t\treturn nil\n\t}\n}\n\n// OptionMaxSuggestion specify the max number of displayed suggestions.\nfunc OptionMaxSuggestion(x uint16) Option {\n\treturn func(p *Prompt) error {\n\t\tp.completion.max = x\n\t\treturn nil\n\t}\n}\n\n// OptionHistory to set history expressed by string array.\nfunc OptionHistory(x []string) Option {\n\treturn func(p *Prompt) error {\n\t\tp.history.histories = x\n\t\tp.history.Clear()\n\t\treturn nil\n\t}\n}\n\n// OptionSwitchKeyBindMode set a key bind mode.\nfunc OptionSwitchKeyBindMode(m KeyBindMode) Option {\n\treturn func(p *Prompt) error {\n\t\tp.keyBindMode = m\n\t\treturn nil\n\t}\n}\n\n// OptionCompletionOnDown allows for Down arrow key to trigger completion.\nfunc OptionCompletionOnDown() Option {\n\treturn func(p *Prompt) error {\n\t\tp.completionOnDown = true\n\t\treturn nil\n\t}\n}\n\n// SwitchKeyBindMode to set a key bind mode.\n// Deprecated: Please use OptionSwitchKeyBindMode.\nvar SwitchKeyBindMode = OptionSwitchKeyBindMode\n\n// OptionAddKeyBind to set a custom key bind.\nfunc OptionAddKeyBind(b ...KeyBind) Option {\n\treturn func(p *Prompt) error {\n\t\tp.keyBindings = append(p.keyBindings, b...)\n\t\treturn nil\n\t}\n}\n\n// OptionAddASCIICodeBind to set a custom key bind.\nfunc OptionAddASCIICodeBind(b ...ASCIICodeBind) Option {\n\treturn func(p *Prompt) error {\n\t\tp.ASCIICodeBindings = append(p.ASCIICodeBindings, b...)\n\t\treturn nil\n\t}\n}\n\n// OptionShowCompletionAtStart to set completion window is open at start.\nfunc OptionShowCompletionAtStart() Option {\n\treturn func(p *Prompt) error {\n\t\tp.completion.showAtStart = true\n\t\treturn nil\n\t}\n}\n\n// OptionBreakLineCallback to run a callback at every break line\nfunc OptionBreakLineCallback(fn func(*Document)) Option {\n\treturn func(p *Prompt) error {\n\t\tp.renderer.breakLineCallback = fn\n\t\treturn nil\n\t}\n}\n\n// OptionSetExitCheckerOnInput set an exit function which checks if go-prompt exits its Run loop\nfunc OptionSetExitCheckerOnInput(fn ExitChecker) Option {\n\treturn func(p *Prompt) error {\n\t\tp.exitChecker = fn\n\t\treturn nil\n\t}\n}\n\n// New returns a Prompt with powerful auto-completion.\nfunc New(executor Executor, completer Completer, opts ...Option) *Prompt {\n\tdefaultWriter := NewStdoutWriter()\n\tregisterConsoleWriter(defaultWriter)\n\n\tpt := &Prompt{\n\t\tin: NewStandardInputParser(),\n\t\trenderer: &Render{\n\t\t\tprefix:                       \"> \",\n\t\t\tout:                          defaultWriter,\n\t\t\tlivePrefixCallback:           func() (string, bool) { return \"\", false },\n\t\t\tprefixTextColor:              Blue,\n\t\t\tprefixBGColor:                DefaultColor,\n\t\t\tinputTextColor:               DefaultColor,\n\t\t\tinputBGColor:                 DefaultColor,\n\t\t\tpreviewSuggestionTextColor:   Green,\n\t\t\tpreviewSuggestionBGColor:     DefaultColor,\n\t\t\tsuggestionTextColor:          White,\n\t\t\tsuggestionBGColor:            Cyan,\n\t\t\tselectedSuggestionTextColor:  Black,\n\t\t\tselectedSuggestionBGColor:    Turquoise,\n\t\t\tdescriptionTextColor:         Black,\n\t\t\tdescriptionBGColor:           Turquoise,\n\t\t\tselectedDescriptionTextColor: White,\n\t\t\tselectedDescriptionBGColor:   Cyan,\n\t\t\tscrollbarThumbColor:          DarkGray,\n\t\t\tscrollbarBGColor:             Cyan,\n\t\t},\n\t\tbuf:         NewBuffer(),\n\t\texecutor:    executor,\n\t\thistory:     NewHistory(),\n\t\tcompletion:  NewCompletionManager(completer, 6),\n\t\tkeyBindMode: EmacsKeyBind, // All the above assume that bash is running in the default Emacs setting\n\t}\n\n\tfor _, opt := range opts {\n\t\tif err := opt(pt); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\treturn pt\n}\n"
        },
        {
          "name": "output.go",
          "type": "blob",
          "size": 4.21875,
          "content": "package prompt\n\nimport \"sync\"\n\nvar (\n\tconsoleWriterMu sync.Mutex\n\tconsoleWriter   ConsoleWriter\n)\n\nfunc registerConsoleWriter(f ConsoleWriter) {\n\tconsoleWriterMu.Lock()\n\tdefer consoleWriterMu.Unlock()\n\tconsoleWriter = f\n}\n\n// DisplayAttribute represents display  attributes like Blinking, Bold, Italic and so on.\ntype DisplayAttribute int\n\nconst (\n\t// DisplayReset reset all display attributes.\n\tDisplayReset DisplayAttribute = iota\n\t// DisplayBold set bold or increases intensity.\n\tDisplayBold\n\t// DisplayLowIntensity decreases intensity. Not widely supported.\n\tDisplayLowIntensity\n\t// DisplayItalic set italic. Not widely supported.\n\tDisplayItalic\n\t// DisplayUnderline set underline\n\tDisplayUnderline\n\t// DisplayBlink set blink (less than 150 per minute).\n\tDisplayBlink\n\t// DisplayRapidBlink set blink (more than 150 per minute). Not widely supported.\n\tDisplayRapidBlink\n\t// DisplayReverse swap foreground and background colors.\n\tDisplayReverse\n\t// DisplayInvisible set invisible.  Not widely supported.\n\tDisplayInvisible\n\t// DisplayCrossedOut set characters legible, but marked for deletion. Not widely supported.\n\tDisplayCrossedOut\n\t// DisplayDefaultFont set primary(default) font\n\tDisplayDefaultFont\n)\n\n// Color represents color on terminal.\ntype Color int\n\nconst (\n\t// DefaultColor represents a default color.\n\tDefaultColor Color = iota\n\n\t// Low intensity\n\n\t// Black represents a black.\n\tBlack\n\t// DarkRed represents a dark red.\n\tDarkRed\n\t// DarkGreen represents a dark green.\n\tDarkGreen\n\t// Brown represents a brown.\n\tBrown\n\t// DarkBlue represents a dark blue.\n\tDarkBlue\n\t// Purple represents a purple.\n\tPurple\n\t// Cyan represents a cyan.\n\tCyan\n\t// LightGray represents a light gray.\n\tLightGray\n\n\t// High intensity\n\n\t// DarkGray represents a dark gray.\n\tDarkGray\n\t// Red represents a red.\n\tRed\n\t// Green represents a green.\n\tGreen\n\t// Yellow represents a yellow.\n\tYellow\n\t// Blue represents a blue.\n\tBlue\n\t// Fuchsia represents a fuchsia.\n\tFuchsia\n\t// Turquoise represents a turquoise.\n\tTurquoise\n\t// White represents a white.\n\tWhite\n)\n\n// ConsoleWriter is an interface to abstract output layer.\ntype ConsoleWriter interface {\n\t/* Write */\n\n\t// WriteRaw to write raw byte array.\n\tWriteRaw(data []byte)\n\t// Write to write safety byte array by removing control sequences.\n\tWrite(data []byte)\n\t// WriteStr to write raw string.\n\tWriteRawStr(data string)\n\t// WriteStr to write safety string by removing control sequences.\n\tWriteStr(data string)\n\t// Flush to flush buffer.\n\tFlush() error\n\n\t/* Erasing */\n\n\t// EraseScreen erases the screen with the background colour and moves the cursor to home.\n\tEraseScreen()\n\t// EraseUp erases the screen from the current line up to the top of the screen.\n\tEraseUp()\n\t// EraseDown erases the screen from the current line down to the bottom of the screen.\n\tEraseDown()\n\t// EraseStartOfLine erases from the current cursor position to the start of the current line.\n\tEraseStartOfLine()\n\t// EraseEndOfLine erases from the current cursor position to the end of the current line.\n\tEraseEndOfLine()\n\t// EraseLine erases the entire current line.\n\tEraseLine()\n\n\t/* Cursor */\n\n\t// ShowCursor stops blinking cursor and show.\n\tShowCursor()\n\t// HideCursor hides cursor.\n\tHideCursor()\n\t// CursorGoTo sets the cursor position where subsequent text will begin.\n\tCursorGoTo(row, col int)\n\t// CursorUp moves the cursor up by 'n' rows; the default count is 1.\n\tCursorUp(n int)\n\t// CursorDown moves the cursor down by 'n' rows; the default count is 1.\n\tCursorDown(n int)\n\t// CursorForward moves the cursor forward by 'n' columns; the default count is 1.\n\tCursorForward(n int)\n\t// CursorBackward moves the cursor backward by 'n' columns; the default count is 1.\n\tCursorBackward(n int)\n\t// AskForCPR asks for a cursor position report (CPR).\n\tAskForCPR()\n\t// SaveCursor saves current cursor position.\n\tSaveCursor()\n\t// UnSaveCursor restores cursor position after a Save Cursor.\n\tUnSaveCursor()\n\n\t/* Scrolling */\n\n\t// ScrollDown scrolls display down one line.\n\tScrollDown()\n\t// ScrollUp scroll display up one line.\n\tScrollUp()\n\n\t/* Title */\n\n\t// SetTitle sets a title of terminal window.\n\tSetTitle(title string)\n\t// ClearTitle clears a title of terminal window.\n\tClearTitle()\n\n\t/* Font */\n\n\t// SetColor sets text and background colors. and specify whether text is bold.\n\tSetColor(fg, bg Color, bold bool)\n}\n"
        },
        {
          "name": "output_posix.go",
          "type": "blob",
          "size": 1.5087890625,
          "content": "// +build !windows\n\npackage prompt\n\nimport (\n\t\"syscall\"\n)\n\nconst flushMaxRetryCount = 3\n\n// PosixWriter is a ConsoleWriter implementation for POSIX environment.\n// To control terminal emulator, this outputs VT100 escape sequences.\ntype PosixWriter struct {\n\tVT100Writer\n\tfd int\n}\n\n// Flush to flush buffer\nfunc (w *PosixWriter) Flush() error {\n\tl := len(w.buffer)\n\toffset := 0\n\tretry := 0\n\tfor {\n\t\tn, err := syscall.Write(w.fd, w.buffer[offset:])\n\t\tif err != nil {\n\t\t\tif retry < flushMaxRetryCount {\n\t\t\t\tretry++\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\toffset += n\n\t\tif offset == l {\n\t\t\tbreak\n\t\t}\n\t}\n\tw.buffer = []byte{}\n\treturn nil\n}\n\nvar _ ConsoleWriter = &PosixWriter{}\n\nvar (\n\t// NewStandardOutputWriter returns ConsoleWriter object to write to stdout.\n\t// This generates VT100 escape sequences because almost terminal emulators\n\t// in POSIX OS built on top of a VT100 specification.\n\t// Deprecated: Please use NewStdoutWriter\n\tNewStandardOutputWriter = NewStdoutWriter\n)\n\n// NewStdoutWriter returns ConsoleWriter object to write to stdout.\n// This generates VT100 escape sequences because almost terminal emulators\n// in POSIX OS built on top of a VT100 specification.\nfunc NewStdoutWriter() ConsoleWriter {\n\treturn &PosixWriter{\n\t\tfd: syscall.Stdout,\n\t}\n}\n\n// NewStderrWriter returns ConsoleWriter object to write to stderr.\n// This generates VT100 escape sequences because almost terminal emulators\n// in POSIX OS built on top of a VT100 specification.\nfunc NewStderrWriter() ConsoleWriter {\n\treturn &PosixWriter{\n\t\tfd: syscall.Stderr,\n\t}\n}\n"
        },
        {
          "name": "output_vt100.go",
          "type": "blob",
          "size": 7.2783203125,
          "content": "package prompt\n\nimport (\n\t\"bytes\"\n\t\"strconv\"\n)\n\n// VT100Writer generates VT100 escape sequences.\ntype VT100Writer struct {\n\tbuffer []byte\n}\n\n// WriteRaw to write raw byte array\nfunc (w *VT100Writer) WriteRaw(data []byte) {\n\tw.buffer = append(w.buffer, data...)\n}\n\n// Write to write safety byte array by removing control sequences.\nfunc (w *VT100Writer) Write(data []byte) {\n\tw.WriteRaw(bytes.Replace(data, []byte{0x1b}, []byte{'?'}, -1))\n}\n\n// WriteRawStr to write raw string\nfunc (w *VT100Writer) WriteRawStr(data string) {\n\tw.WriteRaw([]byte(data))\n}\n\n// WriteStr to write safety string by removing control sequences.\nfunc (w *VT100Writer) WriteStr(data string) {\n\tw.Write([]byte(data))\n}\n\n/* Erase */\n\n// EraseScreen erases the screen with the background colour and moves the cursor to home.\nfunc (w *VT100Writer) EraseScreen() {\n\tw.WriteRaw([]byte{0x1b, '[', '2', 'J'})\n}\n\n// EraseUp erases the screen from the current line up to the top of the screen.\nfunc (w *VT100Writer) EraseUp() {\n\tw.WriteRaw([]byte{0x1b, '[', '1', 'J'})\n}\n\n// EraseDown erases the screen from the current line down to the bottom of the screen.\nfunc (w *VT100Writer) EraseDown() {\n\tw.WriteRaw([]byte{0x1b, '[', 'J'})\n}\n\n// EraseStartOfLine erases from the current cursor position to the start of the current line.\nfunc (w *VT100Writer) EraseStartOfLine() {\n\tw.WriteRaw([]byte{0x1b, '[', '1', 'K'})\n}\n\n// EraseEndOfLine erases from the current cursor position to the end of the current line.\nfunc (w *VT100Writer) EraseEndOfLine() {\n\tw.WriteRaw([]byte{0x1b, '[', 'K'})\n}\n\n// EraseLine erases the entire current line.\nfunc (w *VT100Writer) EraseLine() {\n\tw.WriteRaw([]byte{0x1b, '[', '2', 'K'})\n}\n\n/* Cursor */\n\n// ShowCursor stops blinking cursor and show.\nfunc (w *VT100Writer) ShowCursor() {\n\tw.WriteRaw([]byte{0x1b, '[', '?', '1', '2', 'l', 0x1b, '[', '?', '2', '5', 'h'})\n}\n\n// HideCursor hides cursor.\nfunc (w *VT100Writer) HideCursor() {\n\tw.WriteRaw([]byte{0x1b, '[', '?', '2', '5', 'l'})\n}\n\n// CursorGoTo sets the cursor position where subsequent text will begin.\nfunc (w *VT100Writer) CursorGoTo(row, col int) {\n\tif row == 0 && col == 0 {\n\t\t// If no row/column parameters are provided (ie. <ESC>[H), the cursor will move to the home position.\n\t\tw.WriteRaw([]byte{0x1b, '[', 'H'})\n\t\treturn\n\t}\n\tr := strconv.Itoa(row)\n\tc := strconv.Itoa(col)\n\tw.WriteRaw([]byte{0x1b, '['})\n\tw.WriteRaw([]byte(r))\n\tw.WriteRaw([]byte{';'})\n\tw.WriteRaw([]byte(c))\n\tw.WriteRaw([]byte{'H'})\n}\n\n// CursorUp moves the cursor up by 'n' rows; the default count is 1.\nfunc (w *VT100Writer) CursorUp(n int) {\n\tif n == 0 {\n\t\treturn\n\t} else if n < 0 {\n\t\tw.CursorDown(-n)\n\t\treturn\n\t}\n\ts := strconv.Itoa(n)\n\tw.WriteRaw([]byte{0x1b, '['})\n\tw.WriteRaw([]byte(s))\n\tw.WriteRaw([]byte{'A'})\n}\n\n// CursorDown moves the cursor down by 'n' rows; the default count is 1.\nfunc (w *VT100Writer) CursorDown(n int) {\n\tif n == 0 {\n\t\treturn\n\t} else if n < 0 {\n\t\tw.CursorUp(-n)\n\t\treturn\n\t}\n\ts := strconv.Itoa(n)\n\tw.WriteRaw([]byte{0x1b, '['})\n\tw.WriteRaw([]byte(s))\n\tw.WriteRaw([]byte{'B'})\n}\n\n// CursorForward moves the cursor forward by 'n' columns; the default count is 1.\nfunc (w *VT100Writer) CursorForward(n int) {\n\tif n == 0 {\n\t\treturn\n\t} else if n < 0 {\n\t\tw.CursorBackward(-n)\n\t\treturn\n\t}\n\ts := strconv.Itoa(n)\n\tw.WriteRaw([]byte{0x1b, '['})\n\tw.WriteRaw([]byte(s))\n\tw.WriteRaw([]byte{'C'})\n}\n\n// CursorBackward moves the cursor backward by 'n' columns; the default count is 1.\nfunc (w *VT100Writer) CursorBackward(n int) {\n\tif n == 0 {\n\t\treturn\n\t} else if n < 0 {\n\t\tw.CursorForward(-n)\n\t\treturn\n\t}\n\ts := strconv.Itoa(n)\n\tw.WriteRaw([]byte{0x1b, '['})\n\tw.WriteRaw([]byte(s))\n\tw.WriteRaw([]byte{'D'})\n}\n\n// AskForCPR asks for a cursor position report (CPR).\nfunc (w *VT100Writer) AskForCPR() {\n\t// CPR: Cursor Position Request.\n\tw.WriteRaw([]byte{0x1b, '[', '6', 'n'})\n}\n\n// SaveCursor saves current cursor position.\nfunc (w *VT100Writer) SaveCursor() {\n\tw.WriteRaw([]byte{0x1b, '[', 's'})\n}\n\n// UnSaveCursor restores cursor position after a Save Cursor.\nfunc (w *VT100Writer) UnSaveCursor() {\n\tw.WriteRaw([]byte{0x1b, '[', 'u'})\n}\n\n/* Scrolling */\n\n// ScrollDown scrolls display down one line.\nfunc (w *VT100Writer) ScrollDown() {\n\tw.WriteRaw([]byte{0x1b, 'D'})\n}\n\n// ScrollUp scroll display up one line.\nfunc (w *VT100Writer) ScrollUp() {\n\tw.WriteRaw([]byte{0x1b, 'M'})\n}\n\n/* Title */\n\n// SetTitle sets a title of terminal window.\nfunc (w *VT100Writer) SetTitle(title string) {\n\ttitleBytes := []byte(title)\n\tpatterns := []struct {\n\t\tfrom []byte\n\t\tto   []byte\n\t}{\n\t\t{\n\t\t\tfrom: []byte{0x13},\n\t\t\tto:   []byte{},\n\t\t},\n\t\t{\n\t\t\tfrom: []byte{0x07},\n\t\t\tto:   []byte{},\n\t\t},\n\t}\n\tfor i := range patterns {\n\t\ttitleBytes = bytes.Replace(titleBytes, patterns[i].from, patterns[i].to, -1)\n\t}\n\n\tw.WriteRaw([]byte{0x1b, ']', '2', ';'})\n\tw.WriteRaw(titleBytes)\n\tw.WriteRaw([]byte{0x07})\n}\n\n// ClearTitle clears a title of terminal window.\nfunc (w *VT100Writer) ClearTitle() {\n\tw.WriteRaw([]byte{0x1b, ']', '2', ';', 0x07})\n}\n\n/* Font */\n\n// SetColor sets text and background colors. and specify whether text is bold.\nfunc (w *VT100Writer) SetColor(fg, bg Color, bold bool) {\n\tif bold {\n\t\tw.SetDisplayAttributes(fg, bg, DisplayBold)\n\t} else {\n\t\t// If using `DisplayDefualt`, it will be broken in some environment.\n\t\t// Details are https://github.com/c-bata/go-prompt/pull/85\n\t\tw.SetDisplayAttributes(fg, bg, DisplayReset)\n\t}\n}\n\n// SetDisplayAttributes to set VT100 display attributes.\nfunc (w *VT100Writer) SetDisplayAttributes(fg, bg Color, attrs ...DisplayAttribute) {\n\tw.WriteRaw([]byte{0x1b, '['}) // control sequence introducer\n\tdefer w.WriteRaw([]byte{'m'}) // final character\n\n\tvar separator byte = ';'\n\tfor i := range attrs {\n\t\tp, ok := displayAttributeParameters[attrs[i]]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tw.WriteRaw(p)\n\t\tw.WriteRaw([]byte{separator})\n\t}\n\n\tf, ok := foregroundANSIColors[fg]\n\tif !ok {\n\t\tf = foregroundANSIColors[DefaultColor]\n\t}\n\tw.WriteRaw(f)\n\tw.WriteRaw([]byte{separator})\n\tb, ok := backgroundANSIColors[bg]\n\tif !ok {\n\t\tb = backgroundANSIColors[DefaultColor]\n\t}\n\tw.WriteRaw(b)\n}\n\nvar displayAttributeParameters = map[DisplayAttribute][]byte{\n\tDisplayReset:        {'0'},\n\tDisplayBold:         {'1'},\n\tDisplayLowIntensity: {'2'},\n\tDisplayItalic:       {'3'},\n\tDisplayUnderline:    {'4'},\n\tDisplayBlink:        {'5'},\n\tDisplayRapidBlink:   {'6'},\n\tDisplayReverse:      {'7'},\n\tDisplayInvisible:    {'8'},\n\tDisplayCrossedOut:   {'9'},\n\tDisplayDefaultFont:  {'1', '0'},\n}\n\nvar foregroundANSIColors = map[Color][]byte{\n\tDefaultColor: {'3', '9'},\n\n\t// Low intensity.\n\tBlack:     {'3', '0'},\n\tDarkRed:   {'3', '1'},\n\tDarkGreen: {'3', '2'},\n\tBrown:     {'3', '3'},\n\tDarkBlue:  {'3', '4'},\n\tPurple:    {'3', '5'},\n\tCyan:      {'3', '6'},\n\tLightGray: {'3', '7'},\n\n\t// High intensity.\n\tDarkGray:  {'9', '0'},\n\tRed:       {'9', '1'},\n\tGreen:     {'9', '2'},\n\tYellow:    {'9', '3'},\n\tBlue:      {'9', '4'},\n\tFuchsia:   {'9', '5'},\n\tTurquoise: {'9', '6'},\n\tWhite:     {'9', '7'},\n}\n\nvar backgroundANSIColors = map[Color][]byte{\n\tDefaultColor: {'4', '9'},\n\n\t// Low intensity.\n\tBlack:     {'4', '0'},\n\tDarkRed:   {'4', '1'},\n\tDarkGreen: {'4', '2'},\n\tBrown:     {'4', '3'},\n\tDarkBlue:  {'4', '4'},\n\tPurple:    {'4', '5'},\n\tCyan:      {'4', '6'},\n\tLightGray: {'4', '7'},\n\n\t// High intensity\n\tDarkGray:  {'1', '0', '0'},\n\tRed:       {'1', '0', '1'},\n\tGreen:     {'1', '0', '2'},\n\tYellow:    {'1', '0', '3'},\n\tBlue:      {'1', '0', '4'},\n\tFuchsia:   {'1', '0', '5'},\n\tTurquoise: {'1', '0', '6'},\n\tWhite:     {'1', '0', '7'},\n}\n"
        },
        {
          "name": "output_vt100_test.go",
          "type": "blob",
          "size": 1.3173828125,
          "content": "package prompt\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n)\n\nfunc TestVT100WriterWrite(t *testing.T) {\n\tscenarioTable := []struct {\n\t\tinput    []byte\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tinput:    []byte{0x1b},\n\t\t\texpected: []byte{'?'},\n\t\t},\n\t\t{\n\t\t\tinput:    []byte{'a'},\n\t\t\texpected: []byte{'a'},\n\t\t},\n\t}\n\n\tfor _, s := range scenarioTable {\n\t\tpw := &VT100Writer{}\n\t\tpw.Write(s.input)\n\n\t\tif !bytes.Equal(pw.buffer, s.expected) {\n\t\t\tt.Errorf(\"Should be %+#v, but got %+#v\", pw.buffer, s.expected)\n\t\t}\n\t}\n}\n\nfunc TestVT100WriterWriteStr(t *testing.T) {\n\tscenarioTable := []struct {\n\t\tinput    string\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tinput:    \"\\x1b\",\n\t\t\texpected: []byte{'?'},\n\t\t},\n\t\t{\n\t\t\tinput:    \"a\",\n\t\t\texpected: []byte{'a'},\n\t\t},\n\t}\n\n\tfor _, s := range scenarioTable {\n\t\tpw := &VT100Writer{}\n\t\tpw.WriteStr(s.input)\n\n\t\tif !bytes.Equal(pw.buffer, s.expected) {\n\t\t\tt.Errorf(\"Should be %+#v, but got %+#v\", pw.buffer, s.expected)\n\t\t}\n\t}\n}\n\nfunc TestVT100WriterWriteRawStr(t *testing.T) {\n\tscenarioTable := []struct {\n\t\tinput    string\n\t\texpected []byte\n\t}{\n\t\t{\n\t\t\tinput:    \"\\x1b\",\n\t\t\texpected: []byte{0x1b},\n\t\t},\n\t\t{\n\t\t\tinput:    \"a\",\n\t\t\texpected: []byte{'a'},\n\t\t},\n\t}\n\n\tfor _, s := range scenarioTable {\n\t\tpw := &VT100Writer{}\n\t\tpw.WriteRawStr(s.input)\n\n\t\tif !bytes.Equal(pw.buffer, s.expected) {\n\t\t\tt.Errorf(\"Should be %+#v, but got %+#v\", pw.buffer, s.expected)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "output_windows.go",
          "type": "blob",
          "size": 1.041015625,
          "content": "// +build windows\n\npackage prompt\n\nimport (\n\t\"io\"\n\n\tcolorable \"github.com/mattn/go-colorable\"\n)\n\n// WindowsWriter is a ConsoleWriter implementation for Win32 console.\n// Output is converted from VT100 escape sequences by mattn/go-colorable.\ntype WindowsWriter struct {\n\tVT100Writer\n\tout io.Writer\n}\n\n// Flush to flush buffer\nfunc (w *WindowsWriter) Flush() error {\n\t_, err := w.out.Write(w.buffer)\n\tif err != nil {\n\t\treturn err\n\t}\n\tw.buffer = []byte{}\n\treturn nil\n}\n\nvar _ ConsoleWriter = &WindowsWriter{}\n\nvar (\n\t// NewStandardOutputWriter is Deprecated: Please use NewStdoutWriter\n\tNewStandardOutputWriter = NewStdoutWriter\n)\n\n// NewStdoutWriter returns ConsoleWriter object to write to stdout.\n// This generates win32 control sequences.\nfunc NewStdoutWriter() ConsoleWriter {\n\treturn &WindowsWriter{\n\t\tout: colorable.NewColorableStdout(),\n\t}\n}\n\n// NewStderrWriter returns ConsoleWriter object to write to stderr.\n// This generates win32 control sequences.\nfunc NewStderrWriter() ConsoleWriter {\n\treturn &WindowsWriter{\n\t\tout: colorable.NewColorableStderr(),\n\t}\n}\n"
        },
        {
          "name": "prompt.go",
          "type": "blob",
          "size": 6.896484375,
          "content": "package prompt\n\nimport (\n\t\"bytes\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/c-bata/go-prompt/internal/debug\"\n)\n\n// Executor is called when user input something text.\ntype Executor func(string)\n\n// ExitChecker is called after user input to check if prompt must stop and exit go-prompt Run loop.\n// User input means: selecting/typing an entry, then, if said entry content matches the ExitChecker function criteria:\n// - immediate exit (if breakline is false) without executor called\n// - exit after typing <return> (meaning breakline is true), and the executor is called first, before exit.\n// Exit means exit go-prompt (not the overall Go program)\ntype ExitChecker func(in string, breakline bool) bool\n\n// Completer should return the suggest item from Document.\ntype Completer func(Document) []Suggest\n\n// Prompt is core struct of go-prompt.\ntype Prompt struct {\n\tin                ConsoleParser\n\tbuf               *Buffer\n\trenderer          *Render\n\texecutor          Executor\n\thistory           *History\n\tcompletion        *CompletionManager\n\tkeyBindings       []KeyBind\n\tASCIICodeBindings []ASCIICodeBind\n\tkeyBindMode       KeyBindMode\n\tcompletionOnDown  bool\n\texitChecker       ExitChecker\n\tskipTearDown      bool\n}\n\n// Exec is the struct contains user input context.\ntype Exec struct {\n\tinput string\n}\n\n// Run starts prompt.\nfunc (p *Prompt) Run() {\n\tp.skipTearDown = false\n\tdefer debug.Teardown()\n\tdebug.Log(\"start prompt\")\n\tp.setUp()\n\tdefer p.tearDown()\n\n\tif p.completion.showAtStart {\n\t\tp.completion.Update(*p.buf.Document())\n\t}\n\n\tp.renderer.Render(p.buf, p.completion)\n\n\tbufCh := make(chan []byte, 128)\n\tstopReadBufCh := make(chan struct{})\n\tgo p.readBuffer(bufCh, stopReadBufCh)\n\n\texitCh := make(chan int)\n\twinSizeCh := make(chan *WinSize)\n\tstopHandleSignalCh := make(chan struct{})\n\tgo p.handleSignals(exitCh, winSizeCh, stopHandleSignalCh)\n\n\tfor {\n\t\tselect {\n\t\tcase b := <-bufCh:\n\t\t\tif shouldExit, e := p.feed(b); shouldExit {\n\t\t\t\tp.renderer.BreakLine(p.buf)\n\t\t\t\tstopReadBufCh <- struct{}{}\n\t\t\t\tstopHandleSignalCh <- struct{}{}\n\t\t\t\treturn\n\t\t\t} else if e != nil {\n\t\t\t\t// Stop goroutine to run readBuffer function\n\t\t\t\tstopReadBufCh <- struct{}{}\n\t\t\t\tstopHandleSignalCh <- struct{}{}\n\n\t\t\t\t// Unset raw mode\n\t\t\t\t// Reset to Blocking mode because returned EAGAIN when still set non-blocking mode.\n\t\t\t\tdebug.AssertNoError(p.in.TearDown())\n\t\t\t\tp.executor(e.input)\n\n\t\t\t\tp.completion.Update(*p.buf.Document())\n\n\t\t\t\tp.renderer.Render(p.buf, p.completion)\n\n\t\t\t\tif p.exitChecker != nil && p.exitChecker(e.input, true) {\n\t\t\t\t\tp.skipTearDown = true\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t// Set raw mode\n\t\t\t\tdebug.AssertNoError(p.in.Setup())\n\t\t\t\tgo p.readBuffer(bufCh, stopReadBufCh)\n\t\t\t\tgo p.handleSignals(exitCh, winSizeCh, stopHandleSignalCh)\n\t\t\t} else {\n\t\t\t\tp.completion.Update(*p.buf.Document())\n\t\t\t\tp.renderer.Render(p.buf, p.completion)\n\t\t\t}\n\t\tcase w := <-winSizeCh:\n\t\t\tp.renderer.UpdateWinSize(w)\n\t\t\tp.renderer.Render(p.buf, p.completion)\n\t\tcase code := <-exitCh:\n\t\t\tp.renderer.BreakLine(p.buf)\n\t\t\tp.tearDown()\n\t\t\tos.Exit(code)\n\t\tdefault:\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t}\n\t}\n}\n\nfunc (p *Prompt) feed(b []byte) (shouldExit bool, exec *Exec) {\n\tkey := GetKey(b)\n\tp.buf.lastKeyStroke = key\n\t// completion\n\tcompleting := p.completion.Completing()\n\tp.handleCompletionKeyBinding(key, completing)\n\n\tswitch key {\n\tcase Enter, ControlJ, ControlM:\n\t\tp.renderer.BreakLine(p.buf)\n\n\t\texec = &Exec{input: p.buf.Text()}\n\t\tp.buf = NewBuffer()\n\t\tif exec.input != \"\" {\n\t\t\tp.history.Add(exec.input)\n\t\t}\n\tcase ControlC:\n\t\tp.renderer.BreakLine(p.buf)\n\t\tp.buf = NewBuffer()\n\t\tp.history.Clear()\n\tcase Up, ControlP:\n\t\tif !completing { // Don't use p.completion.Completing() because it takes double operation when switch to selected=-1.\n\t\t\tif newBuf, changed := p.history.Older(p.buf); changed {\n\t\t\t\tp.buf = newBuf\n\t\t\t}\n\t\t}\n\tcase Down, ControlN:\n\t\tif !completing { // Don't use p.completion.Completing() because it takes double operation when switch to selected=-1.\n\t\t\tif newBuf, changed := p.history.Newer(p.buf); changed {\n\t\t\t\tp.buf = newBuf\n\t\t\t}\n\t\t\treturn\n\t\t}\n\tcase ControlD:\n\t\tif p.buf.Text() == \"\" {\n\t\t\tshouldExit = true\n\t\t\treturn\n\t\t}\n\tcase NotDefined:\n\t\tif p.handleASCIICodeBinding(b) {\n\t\t\treturn\n\t\t}\n\t\tp.buf.InsertText(string(b), false, true)\n\t}\n\n\tshouldExit = p.handleKeyBinding(key)\n\treturn\n}\n\nfunc (p *Prompt) handleCompletionKeyBinding(key Key, completing bool) {\n\tswitch key {\n\tcase Down:\n\t\tif completing || p.completionOnDown {\n\t\t\tp.completion.Next()\n\t\t}\n\tcase Tab, ControlI:\n\t\tp.completion.Next()\n\tcase Up:\n\t\tif completing {\n\t\t\tp.completion.Previous()\n\t\t}\n\tcase BackTab:\n\t\tp.completion.Previous()\n\tdefault:\n\t\tif s, ok := p.completion.GetSelectedSuggestion(); ok {\n\t\t\tw := p.buf.Document().GetWordBeforeCursorUntilSeparator(p.completion.wordSeparator)\n\t\t\tif w != \"\" {\n\t\t\t\tp.buf.DeleteBeforeCursor(len([]rune(w)))\n\t\t\t}\n\t\t\tp.buf.InsertText(s.Text, false, true)\n\t\t}\n\t\tp.completion.Reset()\n\t}\n}\n\nfunc (p *Prompt) handleKeyBinding(key Key) bool {\n\tshouldExit := false\n\tfor i := range commonKeyBindings {\n\t\tkb := commonKeyBindings[i]\n\t\tif kb.Key == key {\n\t\t\tkb.Fn(p.buf)\n\t\t}\n\t}\n\n\tif p.keyBindMode == EmacsKeyBind {\n\t\tfor i := range emacsKeyBindings {\n\t\t\tkb := emacsKeyBindings[i]\n\t\t\tif kb.Key == key {\n\t\t\t\tkb.Fn(p.buf)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Custom key bindings\n\tfor i := range p.keyBindings {\n\t\tkb := p.keyBindings[i]\n\t\tif kb.Key == key {\n\t\t\tkb.Fn(p.buf)\n\t\t}\n\t}\n\tif p.exitChecker != nil && p.exitChecker(p.buf.Text(), false) {\n\t\tshouldExit = true\n\t}\n\treturn shouldExit\n}\n\nfunc (p *Prompt) handleASCIICodeBinding(b []byte) bool {\n\tchecked := false\n\tfor _, kb := range p.ASCIICodeBindings {\n\t\tif bytes.Equal(kb.ASCIICode, b) {\n\t\t\tkb.Fn(p.buf)\n\t\t\tchecked = true\n\t\t}\n\t}\n\treturn checked\n}\n\n// Input just returns user input text.\nfunc (p *Prompt) Input() string {\n\tdefer debug.Teardown()\n\tdebug.Log(\"start prompt\")\n\tp.setUp()\n\tdefer p.tearDown()\n\n\tif p.completion.showAtStart {\n\t\tp.completion.Update(*p.buf.Document())\n\t}\n\n\tp.renderer.Render(p.buf, p.completion)\n\tbufCh := make(chan []byte, 128)\n\tstopReadBufCh := make(chan struct{})\n\tgo p.readBuffer(bufCh, stopReadBufCh)\n\n\tfor {\n\t\tselect {\n\t\tcase b := <-bufCh:\n\t\t\tif shouldExit, e := p.feed(b); shouldExit {\n\t\t\t\tp.renderer.BreakLine(p.buf)\n\t\t\t\tstopReadBufCh <- struct{}{}\n\t\t\t\treturn \"\"\n\t\t\t} else if e != nil {\n\t\t\t\t// Stop goroutine to run readBuffer function\n\t\t\t\tstopReadBufCh <- struct{}{}\n\t\t\t\treturn e.input\n\t\t\t} else {\n\t\t\t\tp.completion.Update(*p.buf.Document())\n\t\t\t\tp.renderer.Render(p.buf, p.completion)\n\t\t\t}\n\t\tdefault:\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t}\n\t}\n}\n\nfunc (p *Prompt) readBuffer(bufCh chan []byte, stopCh chan struct{}) {\n\tdebug.Log(\"start reading buffer\")\n\tfor {\n\t\tselect {\n\t\tcase <-stopCh:\n\t\t\tdebug.Log(\"stop reading buffer\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tif b, err := p.in.Read(); err == nil && !(len(b) == 1 && b[0] == 0) {\n\t\t\t\tbufCh <- b\n\t\t\t}\n\t\t}\n\t\ttime.Sleep(10 * time.Millisecond)\n\t}\n}\n\nfunc (p *Prompt) setUp() {\n\tdebug.AssertNoError(p.in.Setup())\n\tp.renderer.Setup()\n\tp.renderer.UpdateWinSize(p.in.GetWinSize())\n}\n\nfunc (p *Prompt) tearDown() {\n\tif !p.skipTearDown {\n\t\tdebug.AssertNoError(p.in.TearDown())\n\t}\n\tp.renderer.TearDown()\n}\n"
        },
        {
          "name": "render.go",
          "type": "blob",
          "size": 7.83203125,
          "content": "package prompt\n\nimport (\n\t\"runtime\"\n\n\t\"github.com/c-bata/go-prompt/internal/debug\"\n\trunewidth \"github.com/mattn/go-runewidth\"\n)\n\n// Render to render prompt information from state of Buffer.\ntype Render struct {\n\tout                ConsoleWriter\n\tprefix             string\n\tlivePrefixCallback func() (prefix string, useLivePrefix bool)\n\tbreakLineCallback  func(*Document)\n\ttitle              string\n\trow                uint16\n\tcol                uint16\n\n\tpreviousCursor int\n\n\t// colors,\n\tprefixTextColor              Color\n\tprefixBGColor                Color\n\tinputTextColor               Color\n\tinputBGColor                 Color\n\tpreviewSuggestionTextColor   Color\n\tpreviewSuggestionBGColor     Color\n\tsuggestionTextColor          Color\n\tsuggestionBGColor            Color\n\tselectedSuggestionTextColor  Color\n\tselectedSuggestionBGColor    Color\n\tdescriptionTextColor         Color\n\tdescriptionBGColor           Color\n\tselectedDescriptionTextColor Color\n\tselectedDescriptionBGColor   Color\n\tscrollbarThumbColor          Color\n\tscrollbarBGColor             Color\n}\n\n// Setup to initialize console output.\nfunc (r *Render) Setup() {\n\tif r.title != \"\" {\n\t\tr.out.SetTitle(r.title)\n\t\tdebug.AssertNoError(r.out.Flush())\n\t}\n}\n\n// getCurrentPrefix to get current prefix.\n// If live-prefix is enabled, return live-prefix.\nfunc (r *Render) getCurrentPrefix() string {\n\tif prefix, ok := r.livePrefixCallback(); ok {\n\t\treturn prefix\n\t}\n\treturn r.prefix\n}\n\nfunc (r *Render) renderPrefix() {\n\tr.out.SetColor(r.prefixTextColor, r.prefixBGColor, false)\n\tr.out.WriteStr(r.getCurrentPrefix())\n\tr.out.SetColor(DefaultColor, DefaultColor, false)\n}\n\n// TearDown to clear title and erasing.\nfunc (r *Render) TearDown() {\n\tr.out.ClearTitle()\n\tr.out.EraseDown()\n\tdebug.AssertNoError(r.out.Flush())\n}\n\nfunc (r *Render) prepareArea(lines int) {\n\tfor i := 0; i < lines; i++ {\n\t\tr.out.ScrollDown()\n\t}\n\tfor i := 0; i < lines; i++ {\n\t\tr.out.ScrollUp()\n\t}\n}\n\n// UpdateWinSize called when window size is changed.\nfunc (r *Render) UpdateWinSize(ws *WinSize) {\n\tr.row = ws.Row\n\tr.col = ws.Col\n}\n\nfunc (r *Render) renderWindowTooSmall() {\n\tr.out.CursorGoTo(0, 0)\n\tr.out.EraseScreen()\n\tr.out.SetColor(DarkRed, White, false)\n\tr.out.WriteStr(\"Your console window is too small...\")\n}\n\nfunc (r *Render) renderCompletion(buf *Buffer, completions *CompletionManager) {\n\tsuggestions := completions.GetSuggestions()\n\tif len(completions.GetSuggestions()) == 0 {\n\t\treturn\n\t}\n\tprefix := r.getCurrentPrefix()\n\tformatted, width := formatSuggestions(\n\t\tsuggestions,\n\t\tint(r.col)-runewidth.StringWidth(prefix)-1, // -1 means a width of scrollbar\n\t)\n\t// +1 means a width of scrollbar.\n\twidth++\n\n\twindowHeight := len(formatted)\n\tif windowHeight > int(completions.max) {\n\t\twindowHeight = int(completions.max)\n\t}\n\tformatted = formatted[completions.verticalScroll : completions.verticalScroll+windowHeight]\n\tr.prepareArea(windowHeight)\n\n\tcursor := runewidth.StringWidth(prefix) + runewidth.StringWidth(buf.Document().TextBeforeCursor())\n\tx, _ := r.toPos(cursor)\n\tif x+width >= int(r.col) {\n\t\tcursor = r.backward(cursor, x+width-int(r.col))\n\t}\n\n\tcontentHeight := len(completions.tmp)\n\n\tfractionVisible := float64(windowHeight) / float64(contentHeight)\n\tfractionAbove := float64(completions.verticalScroll) / float64(contentHeight)\n\n\tscrollbarHeight := int(clamp(float64(windowHeight), 1, float64(windowHeight)*fractionVisible))\n\tscrollbarTop := int(float64(windowHeight) * fractionAbove)\n\n\tisScrollThumb := func(row int) bool {\n\t\treturn scrollbarTop <= row && row <= scrollbarTop+scrollbarHeight\n\t}\n\n\tselected := completions.selected - completions.verticalScroll\n\tr.out.SetColor(White, Cyan, false)\n\tfor i := 0; i < windowHeight; i++ {\n\t\tr.out.CursorDown(1)\n\t\tif i == selected {\n\t\t\tr.out.SetColor(r.selectedSuggestionTextColor, r.selectedSuggestionBGColor, true)\n\t\t} else {\n\t\t\tr.out.SetColor(r.suggestionTextColor, r.suggestionBGColor, false)\n\t\t}\n\t\tr.out.WriteStr(formatted[i].Text)\n\n\t\tif i == selected {\n\t\t\tr.out.SetColor(r.selectedDescriptionTextColor, r.selectedDescriptionBGColor, false)\n\t\t} else {\n\t\t\tr.out.SetColor(r.descriptionTextColor, r.descriptionBGColor, false)\n\t\t}\n\t\tr.out.WriteStr(formatted[i].Description)\n\n\t\tif isScrollThumb(i) {\n\t\t\tr.out.SetColor(DefaultColor, r.scrollbarThumbColor, false)\n\t\t} else {\n\t\t\tr.out.SetColor(DefaultColor, r.scrollbarBGColor, false)\n\t\t}\n\t\tr.out.WriteStr(\" \")\n\t\tr.out.SetColor(DefaultColor, DefaultColor, false)\n\n\t\tr.lineWrap(cursor + width)\n\t\tr.backward(cursor+width, width)\n\t}\n\n\tif x+width >= int(r.col) {\n\t\tr.out.CursorForward(x + width - int(r.col))\n\t}\n\n\tr.out.CursorUp(windowHeight)\n\tr.out.SetColor(DefaultColor, DefaultColor, false)\n}\n\n// Render renders to the console.\nfunc (r *Render) Render(buffer *Buffer, completion *CompletionManager) {\n\t// In situations where a pseudo tty is allocated (e.g. within a docker container),\n\t// window size via TIOCGWINSZ is not immediately available and will result in 0,0 dimensions.\n\tif r.col == 0 {\n\t\treturn\n\t}\n\tdefer func() { debug.AssertNoError(r.out.Flush()) }()\n\tr.move(r.previousCursor, 0)\n\n\tline := buffer.Text()\n\tprefix := r.getCurrentPrefix()\n\tcursor := runewidth.StringWidth(prefix) + runewidth.StringWidth(line)\n\n\t// prepare area\n\t_, y := r.toPos(cursor)\n\n\th := y + 1 + int(completion.max)\n\tif h > int(r.row) || completionMargin > int(r.col) {\n\t\tr.renderWindowTooSmall()\n\t\treturn\n\t}\n\n\t// Rendering\n\tr.out.HideCursor()\n\tdefer r.out.ShowCursor()\n\n\tr.renderPrefix()\n\tr.out.SetColor(r.inputTextColor, r.inputBGColor, false)\n\tr.out.WriteStr(line)\n\tr.out.SetColor(DefaultColor, DefaultColor, false)\n\tr.lineWrap(cursor)\n\n\tr.out.EraseDown()\n\n\tcursor = r.backward(cursor, runewidth.StringWidth(line)-buffer.DisplayCursorPosition())\n\n\tr.renderCompletion(buffer, completion)\n\tif suggest, ok := completion.GetSelectedSuggestion(); ok {\n\t\tcursor = r.backward(cursor, runewidth.StringWidth(buffer.Document().GetWordBeforeCursorUntilSeparator(completion.wordSeparator)))\n\n\t\tr.out.SetColor(r.previewSuggestionTextColor, r.previewSuggestionBGColor, false)\n\t\tr.out.WriteStr(suggest.Text)\n\t\tr.out.SetColor(DefaultColor, DefaultColor, false)\n\t\tcursor += runewidth.StringWidth(suggest.Text)\n\n\t\trest := buffer.Document().TextAfterCursor()\n\t\tr.out.WriteStr(rest)\n\t\tcursor += runewidth.StringWidth(rest)\n\t\tr.lineWrap(cursor)\n\n\t\tcursor = r.backward(cursor, runewidth.StringWidth(rest))\n\t}\n\tr.previousCursor = cursor\n}\n\n// BreakLine to break line.\nfunc (r *Render) BreakLine(buffer *Buffer) {\n\t// Erasing and Render\n\tcursor := runewidth.StringWidth(buffer.Document().TextBeforeCursor()) + runewidth.StringWidth(r.getCurrentPrefix())\n\tr.clear(cursor)\n\tr.renderPrefix()\n\tr.out.SetColor(r.inputTextColor, r.inputBGColor, false)\n\tr.out.WriteStr(buffer.Document().Text + \"\\n\")\n\tr.out.SetColor(DefaultColor, DefaultColor, false)\n\tdebug.AssertNoError(r.out.Flush())\n\tif r.breakLineCallback != nil {\n\t\tr.breakLineCallback(buffer.Document())\n\t}\n\n\tr.previousCursor = 0\n}\n\n// clear erases the screen from a beginning of input\n// even if there is line break which means input length exceeds a window's width.\nfunc (r *Render) clear(cursor int) {\n\tr.move(cursor, 0)\n\tr.out.EraseDown()\n}\n\n// backward moves cursor to backward from a current cursor position\n// regardless there is a line break.\nfunc (r *Render) backward(from, n int) int {\n\treturn r.move(from, from-n)\n}\n\n// move moves cursor to specified position from the beginning of input\n// even if there is a line break.\nfunc (r *Render) move(from, to int) int {\n\tfromX, fromY := r.toPos(from)\n\ttoX, toY := r.toPos(to)\n\n\tr.out.CursorUp(fromY - toY)\n\tr.out.CursorBackward(fromX - toX)\n\treturn to\n}\n\n// toPos returns the relative position from the beginning of the string.\nfunc (r *Render) toPos(cursor int) (x, y int) {\n\tcol := int(r.col)\n\treturn cursor % col, cursor / col\n}\n\nfunc (r *Render) lineWrap(cursor int) {\n\tif runtime.GOOS != \"windows\" && cursor > 0 && cursor%int(r.col) == 0 {\n\t\tr.out.WriteRaw([]byte{'\\n'})\n\t}\n}\n\nfunc clamp(high, low, x float64) float64 {\n\tswitch {\n\tcase high < x:\n\t\treturn high\n\tcase x < low:\n\t\treturn low\n\tdefault:\n\t\treturn x\n\t}\n}\n"
        },
        {
          "name": "render_test.go",
          "type": "blob",
          "size": 2.822265625,
          "content": "// +build !windows\n\npackage prompt\n\nimport (\n\t\"reflect\"\n\t\"syscall\"\n\t\"testing\"\n)\n\nfunc TestFormatCompletion(t *testing.T) {\n\tscenarioTable := []struct {\n\t\tscenario      string\n\t\tcompletions   []Suggest\n\t\tprefix        string\n\t\tsuffix        string\n\t\texpected      []Suggest\n\t\tmaxWidth      int\n\t\texpectedWidth int\n\t}{\n\t\t{\n\t\t\tscenario: \"\",\n\t\t\tcompletions: []Suggest{\n\t\t\t\t{Text: \"select\"},\n\t\t\t\t{Text: \"from\"},\n\t\t\t\t{Text: \"insert\"},\n\t\t\t\t{Text: \"where\"},\n\t\t\t},\n\t\t\tprefix: \" \",\n\t\t\tsuffix: \" \",\n\t\t\texpected: []Suggest{\n\t\t\t\t{Text: \" select \"},\n\t\t\t\t{Text: \" from   \"},\n\t\t\t\t{Text: \" insert \"},\n\t\t\t\t{Text: \" where  \"},\n\t\t\t},\n\t\t\tmaxWidth:      20,\n\t\t\texpectedWidth: 8,\n\t\t},\n\t\t{\n\t\t\tscenario: \"\",\n\t\t\tcompletions: []Suggest{\n\t\t\t\t{Text: \"select\", Description: \"select description\"},\n\t\t\t\t{Text: \"from\", Description: \"from description\"},\n\t\t\t\t{Text: \"insert\", Description: \"insert description\"},\n\t\t\t\t{Text: \"where\", Description: \"where description\"},\n\t\t\t},\n\t\t\tprefix: \" \",\n\t\t\tsuffix: \" \",\n\t\t\texpected: []Suggest{\n\t\t\t\t{Text: \" select \", Description: \" select description \"},\n\t\t\t\t{Text: \" from   \", Description: \" from description   \"},\n\t\t\t\t{Text: \" insert \", Description: \" insert description \"},\n\t\t\t\t{Text: \" where  \", Description: \" where description  \"},\n\t\t\t},\n\t\t\tmaxWidth:      40,\n\t\t\texpectedWidth: 28,\n\t\t},\n\t}\n\n\tfor _, s := range scenarioTable {\n\t\tac, width := formatSuggestions(s.completions, s.maxWidth)\n\t\tif !reflect.DeepEqual(ac, s.expected) {\n\t\t\tt.Errorf(\"Should be %#v, but got %#v\", s.expected, ac)\n\t\t}\n\t\tif width != s.expectedWidth {\n\t\t\tt.Errorf(\"Should be %#v, but got %#v\", s.expectedWidth, width)\n\t\t}\n\t}\n}\n\nfunc TestBreakLineCallback(t *testing.T) {\n\tvar i int\n\tr := &Render{\n\t\tprefix: \"> \",\n\t\tout: &PosixWriter{\n\t\t\tfd: syscall.Stdin, // \"write\" to stdin just so we don't mess with the output of the tests\n\t\t},\n\t\tlivePrefixCallback:           func() (string, bool) { return \"\", false },\n\t\tprefixTextColor:              Blue,\n\t\tprefixBGColor:                DefaultColor,\n\t\tinputTextColor:               DefaultColor,\n\t\tinputBGColor:                 DefaultColor,\n\t\tpreviewSuggestionTextColor:   Green,\n\t\tpreviewSuggestionBGColor:     DefaultColor,\n\t\tsuggestionTextColor:          White,\n\t\tsuggestionBGColor:            Cyan,\n\t\tselectedSuggestionTextColor:  Black,\n\t\tselectedSuggestionBGColor:    Turquoise,\n\t\tdescriptionTextColor:         Black,\n\t\tdescriptionBGColor:           Turquoise,\n\t\tselectedDescriptionTextColor: White,\n\t\tselectedDescriptionBGColor:   Cyan,\n\t\tscrollbarThumbColor:          DarkGray,\n\t\tscrollbarBGColor:             Cyan,\n\t\tcol:                          1,\n\t}\n\tb := NewBuffer()\n\tr.BreakLine(b)\n\n\tif i != 0 {\n\t\tt.Errorf(\"i should initially be 0, before applying a break line callback\")\n\t}\n\n\tr.breakLineCallback = func(doc *Document) {\n\t\ti++\n\t}\n\tr.BreakLine(b)\n\tr.BreakLine(b)\n\tr.BreakLine(b)\n\n\tif i != 3 {\n\t\tt.Errorf(\"BreakLine callback not called, i should be 3\")\n\t}\n}\n"
        },
        {
          "name": "shortcut.go",
          "type": "blob",
          "size": 1.09375,
          "content": "package prompt\n\nfunc dummyExecutor(in string) {}\n\n// Input get the input data from the user and return it.\nfunc Input(prefix string, completer Completer, opts ...Option) string {\n\tpt := New(dummyExecutor, completer)\n\tpt.renderer.prefixTextColor = DefaultColor\n\tpt.renderer.prefix = prefix\n\n\tfor _, opt := range opts {\n\t\tif err := opt(pt); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\treturn pt.Input()\n}\n\n// Choose to the shortcut of input function to select from string array.\n// Deprecated: Maybe anyone want to use this.\nfunc Choose(prefix string, choices []string, opts ...Option) string {\n\tcompleter := newChoiceCompleter(choices, FilterHasPrefix)\n\tpt := New(dummyExecutor, completer)\n\tpt.renderer.prefixTextColor = DefaultColor\n\tpt.renderer.prefix = prefix\n\n\tfor _, opt := range opts {\n\t\tif err := opt(pt); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\treturn pt.Input()\n}\n\nfunc newChoiceCompleter(choices []string, filter Filter) Completer {\n\ts := make([]Suggest, len(choices))\n\tfor i := range choices {\n\t\ts[i] = Suggest{Text: choices[i]}\n\t}\n\treturn func(x Document) []Suggest {\n\t\treturn filter(s, x.GetWordBeforeCursor(), true)\n\t}\n}\n"
        },
        {
          "name": "signal_posix.go",
          "type": "blob",
          "size": 0.8603515625,
          "content": "// +build !windows\n\npackage prompt\n\nimport (\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/c-bata/go-prompt/internal/debug\"\n)\n\nfunc (p *Prompt) handleSignals(exitCh chan int, winSizeCh chan *WinSize, stop chan struct{}) {\n\tin := p.in\n\tsigCh := make(chan os.Signal, 1)\n\tsignal.Notify(\n\t\tsigCh,\n\t\tsyscall.SIGINT,\n\t\tsyscall.SIGTERM,\n\t\tsyscall.SIGQUIT,\n\t\tsyscall.SIGWINCH,\n\t)\n\n\tfor {\n\t\tselect {\n\t\tcase <-stop:\n\t\t\tdebug.Log(\"stop handleSignals\")\n\t\t\treturn\n\t\tcase s := <-sigCh:\n\t\t\tswitch s {\n\t\t\tcase syscall.SIGINT: // kill -SIGINT XXXX or Ctrl+c\n\t\t\t\tdebug.Log(\"Catch SIGINT\")\n\t\t\t\texitCh <- 0\n\n\t\t\tcase syscall.SIGTERM: // kill -SIGTERM XXXX\n\t\t\t\tdebug.Log(\"Catch SIGTERM\")\n\t\t\t\texitCh <- 1\n\n\t\t\tcase syscall.SIGQUIT: // kill -SIGQUIT XXXX\n\t\t\t\tdebug.Log(\"Catch SIGQUIT\")\n\t\t\t\texitCh <- 0\n\n\t\t\tcase syscall.SIGWINCH:\n\t\t\t\tdebug.Log(\"Catch SIGWINCH\")\n\t\t\t\twinSizeCh <- in.GetWinSize()\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "signal_windows.go",
          "type": "blob",
          "size": 0.7392578125,
          "content": "// +build windows\n\npackage prompt\n\nimport (\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/c-bata/go-prompt/internal/debug\"\n)\n\nfunc (p *Prompt) handleSignals(exitCh chan int, winSizeCh chan *WinSize, stop chan struct{}) {\n\tsigCh := make(chan os.Signal, 1)\n\tsignal.Notify(\n\t\tsigCh,\n\t\tsyscall.SIGINT,\n\t\tsyscall.SIGTERM,\n\t\tsyscall.SIGQUIT,\n\t)\n\n\tfor {\n\t\tselect {\n\t\tcase <-stop:\n\t\t\tdebug.Log(\"stop handleSignals\")\n\t\t\treturn\n\t\tcase s := <-sigCh:\n\t\t\tswitch s {\n\n\t\t\tcase syscall.SIGINT: // kill -SIGINT XXXX or Ctrl+c\n\t\t\t\tdebug.Log(\"Catch SIGINT\")\n\t\t\t\texitCh <- 0\n\n\t\t\tcase syscall.SIGTERM: // kill -SIGTERM XXXX\n\t\t\t\tdebug.Log(\"Catch SIGTERM\")\n\t\t\t\texitCh <- 1\n\n\t\t\tcase syscall.SIGQUIT: // kill -SIGQUIT XXXX\n\t\t\t\tdebug.Log(\"Catch SIGQUIT\")\n\t\t\t\texitCh <- 0\n\t\t\t}\n\t\t}\n\t}\n}\n"
        }
      ]
    }
  ]
}