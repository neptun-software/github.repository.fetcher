{
  "metadata": {
    "timestamp": 1736567779972,
    "page": 363,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "golang/oauth2",
      "stars": 5450,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.255859375,
          "content": "language: go\n\ngo:\n  - tip\n\ninstall:\n  - export GOPATH=\"$HOME/gopath\"\n  - mkdir -p \"$GOPATH/src/golang.org/x\"\n  - mv \"$TRAVIS_BUILD_DIR\" \"$GOPATH/src/golang.org/x/oauth2\"\n  - go get -v -t -d golang.org/x/oauth2/...\n\nscript:\n  - go test -v golang.org/x/oauth2/...\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.90234375,
          "content": "# Contributing to Go\n\nGo is an open source project.\n\nIt is the work of hundreds of contributors. We appreciate your help!\n\n## Filing issues\n\nWhen [filing an issue](https://github.com/golang/oauth2/issues), make sure to answer these five questions:\n\n1.  What version of Go are you using (`go version`)?\n2.  What operating system and processor architecture are you using?\n3.  What did you do?\n4.  What did you expect to see?\n5.  What did you see instead?\n\nGeneral questions should go to the [golang-nuts mailing list](https://groups.google.com/group/golang-nuts) instead of the issue tracker.\nThe gophers there will answer or ask you to file an issue if you've tripped over a bug.\n\n## Contributing code\n\nPlease read the [Contribution Guidelines](https://golang.org/doc/contribute.html)\nbefore sending patches.\n\nUnless otherwise noted, the Go source files are distributed under\nthe BSD-style license found in the LICENSE file.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4189453125,
          "content": "Copyright 2009 The Go Authors.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google LLC nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.44921875,
          "content": "# OAuth2 for Go\n\n[![Go Reference](https://pkg.go.dev/badge/golang.org/x/oauth2.svg)](https://pkg.go.dev/golang.org/x/oauth2)\n[![Build Status](https://travis-ci.org/golang/oauth2.svg?branch=master)](https://travis-ci.org/golang/oauth2)\n\noauth2 package contains a client implementation for OAuth 2.0 spec.\n\nSee pkg.go.dev for further documentation and examples.\n\n* [pkg.go.dev/golang.org/x/oauth2](https://pkg.go.dev/golang.org/x/oauth2)\n* [pkg.go.dev/golang.org/x/oauth2/google](https://pkg.go.dev/golang.org/x/oauth2/google)\n\n## Policy for new endpoints\n\nWe no longer accept new provider-specific packages in this repo if all\nthey do is add a single endpoint variable. If you just want to add a\nsingle endpoint, add it to the\n[pkg.go.dev/golang.org/x/oauth2/endpoints](https://pkg.go.dev/golang.org/x/oauth2/endpoints)\npackage.\n\n## Report Issues / Send Patches\n\nThe main issue tracker for the oauth2 repository is located at\nhttps://github.com/golang/oauth2/issues.\n\nThis repository uses Gerrit for code changes. To learn how to submit changes to\nthis repository, see https://go.dev/doc/contribute.\n\nThe git repository is https://go.googlesource.com/oauth2.\n\nNote:\n\n* Excluding trivial changes, all contributions should be connected to an existing issue.\n* API changes must go through the [change proposal process](https://go.dev/s/proposal-process) before they can be accepted.\n* The code owners are listed at [dev.golang.org/owners](https://dev.golang.org/owners#:~:text=x/oauth2).\n"
        },
        {
          "name": "amazon",
          "type": "tree",
          "content": null
        },
        {
          "name": "authhandler",
          "type": "tree",
          "content": null
        },
        {
          "name": "bitbucket",
          "type": "tree",
          "content": null
        },
        {
          "name": "cern",
          "type": "tree",
          "content": null
        },
        {
          "name": "clientcredentials",
          "type": "tree",
          "content": null
        },
        {
          "name": "deviceauth.go",
          "type": "blob",
          "size": 5.349609375,
          "content": "package oauth2\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"golang.org/x/oauth2/internal\"\n)\n\n// https://datatracker.ietf.org/doc/html/rfc8628#section-3.5\nconst (\n\terrAuthorizationPending = \"authorization_pending\"\n\terrSlowDown             = \"slow_down\"\n\terrAccessDenied         = \"access_denied\"\n\terrExpiredToken         = \"expired_token\"\n)\n\n// DeviceAuthResponse describes a successful RFC 8628 Device Authorization Response\n// https://datatracker.ietf.org/doc/html/rfc8628#section-3.2\ntype DeviceAuthResponse struct {\n\t// DeviceCode\n\tDeviceCode string `json:\"device_code\"`\n\t// UserCode is the code the user should enter at the verification uri\n\tUserCode string `json:\"user_code\"`\n\t// VerificationURI is where user should enter the user code\n\tVerificationURI string `json:\"verification_uri\"`\n\t// VerificationURIComplete (if populated) includes the user code in the verification URI. This is typically shown to the user in non-textual form, such as a QR code.\n\tVerificationURIComplete string `json:\"verification_uri_complete,omitempty\"`\n\t// Expiry is when the device code and user code expire\n\tExpiry time.Time `json:\"expires_in,omitempty\"`\n\t// Interval is the duration in seconds that Poll should wait between requests\n\tInterval int64 `json:\"interval,omitempty\"`\n}\n\nfunc (d DeviceAuthResponse) MarshalJSON() ([]byte, error) {\n\ttype Alias DeviceAuthResponse\n\tvar expiresIn int64\n\tif !d.Expiry.IsZero() {\n\t\texpiresIn = int64(time.Until(d.Expiry).Seconds())\n\t}\n\treturn json.Marshal(&struct {\n\t\tExpiresIn int64 `json:\"expires_in,omitempty\"`\n\t\t*Alias\n\t}{\n\t\tExpiresIn: expiresIn,\n\t\tAlias:     (*Alias)(&d),\n\t})\n\n}\n\nfunc (c *DeviceAuthResponse) UnmarshalJSON(data []byte) error {\n\ttype Alias DeviceAuthResponse\n\taux := &struct {\n\t\tExpiresIn int64 `json:\"expires_in\"`\n\t\t// workaround misspelling of verification_uri\n\t\tVerificationURL string `json:\"verification_url\"`\n\t\t*Alias\n\t}{\n\t\tAlias: (*Alias)(c),\n\t}\n\tif err := json.Unmarshal(data, &aux); err != nil {\n\t\treturn err\n\t}\n\tif aux.ExpiresIn != 0 {\n\t\tc.Expiry = time.Now().UTC().Add(time.Second * time.Duration(aux.ExpiresIn))\n\t}\n\tif c.VerificationURI == \"\" {\n\t\tc.VerificationURI = aux.VerificationURL\n\t}\n\treturn nil\n}\n\n// DeviceAuth returns a device auth struct which contains a device code\n// and authorization information provided for users to enter on another device.\nfunc (c *Config) DeviceAuth(ctx context.Context, opts ...AuthCodeOption) (*DeviceAuthResponse, error) {\n\t// https://datatracker.ietf.org/doc/html/rfc8628#section-3.1\n\tv := url.Values{\n\t\t\"client_id\": {c.ClientID},\n\t}\n\tif len(c.Scopes) > 0 {\n\t\tv.Set(\"scope\", strings.Join(c.Scopes, \" \"))\n\t}\n\tfor _, opt := range opts {\n\t\topt.setValue(v)\n\t}\n\treturn retrieveDeviceAuth(ctx, c, v)\n}\n\nfunc retrieveDeviceAuth(ctx context.Context, c *Config, v url.Values) (*DeviceAuthResponse, error) {\n\tif c.Endpoint.DeviceAuthURL == \"\" {\n\t\treturn nil, errors.New(\"endpoint missing DeviceAuthURL\")\n\t}\n\n\treq, err := http.NewRequest(\"POST\", c.Endpoint.DeviceAuthURL, strings.NewReader(v.Encode()))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tt := time.Now()\n\tr, err := internal.ContextClient(ctx).Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbody, err := io.ReadAll(io.LimitReader(r.Body, 1<<20))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"oauth2: cannot auth device: %v\", err)\n\t}\n\tif code := r.StatusCode; code < 200 || code > 299 {\n\t\treturn nil, &RetrieveError{\n\t\t\tResponse: r,\n\t\t\tBody:     body,\n\t\t}\n\t}\n\n\tda := &DeviceAuthResponse{}\n\terr = json.Unmarshal(body, &da)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unmarshal %s\", err)\n\t}\n\n\tif !da.Expiry.IsZero() {\n\t\t// Make a small adjustment to account for time taken by the request\n\t\tda.Expiry = da.Expiry.Add(-time.Since(t))\n\t}\n\n\treturn da, nil\n}\n\n// DeviceAccessToken polls the server to exchange a device code for a token.\nfunc (c *Config) DeviceAccessToken(ctx context.Context, da *DeviceAuthResponse, opts ...AuthCodeOption) (*Token, error) {\n\tif !da.Expiry.IsZero() {\n\t\tvar cancel context.CancelFunc\n\t\tctx, cancel = context.WithDeadline(ctx, da.Expiry)\n\t\tdefer cancel()\n\t}\n\n\t// https://datatracker.ietf.org/doc/html/rfc8628#section-3.4\n\tv := url.Values{\n\t\t\"client_id\":   {c.ClientID},\n\t\t\"grant_type\":  {\"urn:ietf:params:oauth:grant-type:device_code\"},\n\t\t\"device_code\": {da.DeviceCode},\n\t}\n\tif len(c.Scopes) > 0 {\n\t\tv.Set(\"scope\", strings.Join(c.Scopes, \" \"))\n\t}\n\tfor _, opt := range opts {\n\t\topt.setValue(v)\n\t}\n\n\t// \"If no value is provided, clients MUST use 5 as the default.\"\n\t// https://datatracker.ietf.org/doc/html/rfc8628#section-3.2\n\tinterval := da.Interval\n\tif interval == 0 {\n\t\tinterval = 5\n\t}\n\n\tticker := time.NewTicker(time.Duration(interval) * time.Second)\n\tdefer ticker.Stop()\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\tcase <-ticker.C:\n\t\t\ttok, err := retrieveToken(ctx, c, v)\n\t\t\tif err == nil {\n\t\t\t\treturn tok, nil\n\t\t\t}\n\n\t\t\te, ok := err.(*RetrieveError)\n\t\t\tif !ok {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tswitch e.ErrorCode {\n\t\t\tcase errSlowDown:\n\t\t\t\t// https://datatracker.ietf.org/doc/html/rfc8628#section-3.5\n\t\t\t\t// \"the interval MUST be increased by 5 seconds for this and all subsequent requests\"\n\t\t\t\tinterval += 5\n\t\t\t\tticker.Reset(time.Duration(interval) * time.Second)\n\t\t\tcase errAuthorizationPending:\n\t\t\t\t// Do nothing.\n\t\t\tcase errAccessDenied, errExpiredToken:\n\t\t\t\tfallthrough\n\t\t\tdefault:\n\t\t\t\treturn tok, err\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "deviceauth_test.go",
          "type": "blob",
          "size": 2.1748046875,
          "content": "package oauth2\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-cmp/cmp/cmpopts\"\n)\n\nfunc TestDeviceAuthResponseMarshalJson(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tresponse DeviceAuthResponse\n\t\twant     string\n\t}{\n\t\t{\n\t\t\tname:     \"empty\",\n\t\t\tresponse: DeviceAuthResponse{},\n\t\t\twant:     `{\"device_code\":\"\",\"user_code\":\"\",\"verification_uri\":\"\"}`,\n\t\t},\n\t\t{\n\t\t\tname: \"soon\",\n\t\t\tresponse: DeviceAuthResponse{\n\t\t\t\tExpiry: time.Now().Add(100*time.Second + 999*time.Millisecond),\n\t\t\t},\n\t\t\twant: `{\"expires_in\":100,\"device_code\":\"\",\"user_code\":\"\",\"verification_uri\":\"\"}`,\n\t\t},\n\t}\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tbegin := time.Now()\n\t\t\tgotBytes, err := json.Marshal(tc.response)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif strings.Contains(tc.want, \"expires_in\") && time.Since(begin) > 999*time.Millisecond {\n\t\t\t\tt.Skip(\"test ran too slowly to compare `expires_in`\")\n\t\t\t}\n\t\t\tgot := string(gotBytes)\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"want=%s, got=%s\", tc.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDeviceAuthResponseUnmarshalJson(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tdata string\n\t\twant DeviceAuthResponse\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\tdata: `{}`,\n\t\t\twant: DeviceAuthResponse{},\n\t\t},\n\t\t{\n\t\t\tname: \"soon\",\n\t\t\tdata: `{\"expires_in\":100}`,\n\t\t\twant: DeviceAuthResponse{Expiry: time.Now().UTC().Add(100 * time.Second)},\n\t\t},\n\t}\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tbegin := time.Now()\n\t\t\tgot := DeviceAuthResponse{}\n\t\t\terr := json.Unmarshal([]byte(tc.data), &got)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif !cmp.Equal(got, tc.want, cmpopts.IgnoreUnexported(DeviceAuthResponse{}), cmpopts.EquateApproxTime(time.Second+time.Since(begin))) {\n\t\t\t\tt.Errorf(\"want=%#v, got=%#v\", tc.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc ExampleConfig_DeviceAuth() {\n\tvar config Config\n\tctx := context.Background()\n\tresponse, err := config.DeviceAuth(ctx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"please enter code %s at %s\\n\", response.UserCode, response.VerificationURI)\n\ttoken, err := config.DeviceAccessToken(ctx, response)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(token)\n}\n"
        },
        {
          "name": "endpoints",
          "type": "tree",
          "content": null
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 2.6005859375,
          "content": "// Copyright 2014 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage oauth2_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"golang.org/x/oauth2\"\n)\n\nfunc ExampleConfig() {\n\tctx := context.Background()\n\tconf := &oauth2.Config{\n\t\tClientID:     \"YOUR_CLIENT_ID\",\n\t\tClientSecret: \"YOUR_CLIENT_SECRET\",\n\t\tScopes:       []string{\"SCOPE1\", \"SCOPE2\"},\n\t\tEndpoint: oauth2.Endpoint{\n\t\t\tAuthURL:  \"https://provider.com/o/oauth2/auth\",\n\t\t\tTokenURL: \"https://provider.com/o/oauth2/token\",\n\t\t},\n\t}\n\n\t// use PKCE to protect against CSRF attacks\n\t// https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-22.html#name-countermeasures-6\n\tverifier := oauth2.GenerateVerifier()\n\n\t// Redirect user to consent page to ask for permission\n\t// for the scopes specified above.\n\turl := conf.AuthCodeURL(\"state\", oauth2.AccessTypeOffline, oauth2.S256ChallengeOption(verifier))\n\tfmt.Printf(\"Visit the URL for the auth dialog: %v\", url)\n\n\t// Use the authorization code that is pushed to the redirect\n\t// URL. Exchange will do the handshake to retrieve the\n\t// initial access token. The HTTP Client returned by\n\t// conf.Client will refresh the token as necessary.\n\tvar code string\n\tif _, err := fmt.Scan(&code); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\ttok, err := conf.Exchange(ctx, code, oauth2.VerifierOption(verifier))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tclient := conf.Client(ctx, tok)\n\tclient.Get(\"...\")\n}\n\nfunc ExampleConfig_customHTTP() {\n\tctx := context.Background()\n\n\tconf := &oauth2.Config{\n\t\tClientID:     \"YOUR_CLIENT_ID\",\n\t\tClientSecret: \"YOUR_CLIENT_SECRET\",\n\t\tScopes:       []string{\"SCOPE1\", \"SCOPE2\"},\n\t\tEndpoint: oauth2.Endpoint{\n\t\t\tTokenURL: \"https://provider.com/o/oauth2/token\",\n\t\t\tAuthURL:  \"https://provider.com/o/oauth2/auth\",\n\t\t},\n\t}\n\n\t// Redirect user to consent page to ask for permission\n\t// for the scopes specified above.\n\turl := conf.AuthCodeURL(\"state\", oauth2.AccessTypeOffline)\n\tfmt.Printf(\"Visit the URL for the auth dialog: %v\", url)\n\n\t// Use the authorization code that is pushed to the redirect\n\t// URL. Exchange will do the handshake to retrieve the\n\t// initial access token. The HTTP Client returned by\n\t// conf.Client will refresh the token as necessary.\n\tvar code string\n\tif _, err := fmt.Scan(&code); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Use the custom HTTP client when requesting a token.\n\thttpClient := &http.Client{Timeout: 2 * time.Second}\n\tctx = context.WithValue(ctx, oauth2.HTTPClient, httpClient)\n\n\ttok, err := conf.Exchange(ctx, code)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tclient := conf.Client(ctx, tok)\n\t_ = client\n}\n"
        },
        {
          "name": "facebook",
          "type": "tree",
          "content": null
        },
        {
          "name": "fitbit",
          "type": "tree",
          "content": null
        },
        {
          "name": "foursquare",
          "type": "tree",
          "content": null
        },
        {
          "name": "github",
          "type": "tree",
          "content": null
        },
        {
          "name": "gitlab",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1240234375,
          "content": "module golang.org/x/oauth2\n\ngo 1.18\n\nrequire (\n\tcloud.google.com/go/compute/metadata v0.3.0\n\tgithub.com/google/go-cmp v0.5.9\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.349609375,
          "content": "cloud.google.com/go/compute/metadata v0.3.0 h1:Tz+eQXMEqDIKRsmY3cHTL6FVaynIjX2QxYC4trgAKZc=\ncloud.google.com/go/compute/metadata v0.3.0/go.mod h1:zFmK7XCadkQkj6TtorcaGlCW1hT1fIilQDwofLpJ20k=\ngithub.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=\ngithub.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\n"
        },
        {
          "name": "google",
          "type": "tree",
          "content": null
        },
        {
          "name": "heroku",
          "type": "tree",
          "content": null
        },
        {
          "name": "hipchat",
          "type": "tree",
          "content": null
        },
        {
          "name": "instagram",
          "type": "tree",
          "content": null
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "jira",
          "type": "tree",
          "content": null
        },
        {
          "name": "jws",
          "type": "tree",
          "content": null
        },
        {
          "name": "jwt",
          "type": "tree",
          "content": null
        },
        {
          "name": "kakao",
          "type": "tree",
          "content": null
        },
        {
          "name": "linkedin",
          "type": "tree",
          "content": null
        },
        {
          "name": "mailchimp",
          "type": "tree",
          "content": null
        },
        {
          "name": "mailru",
          "type": "tree",
          "content": null
        },
        {
          "name": "mediamath",
          "type": "tree",
          "content": null
        },
        {
          "name": "microsoft",
          "type": "tree",
          "content": null
        },
        {
          "name": "nokiahealth",
          "type": "tree",
          "content": null
        },
        {
          "name": "oauth2.go",
          "type": "blob",
          "size": 13.6005859375,
          "content": "// Copyright 2014 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package oauth2 provides support for making\n// OAuth2 authorized and authenticated HTTP requests,\n// as specified in RFC 6749.\n// It can additionally grant authorization with Bearer JWT.\npackage oauth2 // import \"golang.org/x/oauth2\"\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"golang.org/x/oauth2/internal\"\n)\n\n// NoContext is the default context you should supply if not using\n// your own context.Context (see https://golang.org/x/net/context).\n//\n// Deprecated: Use context.Background() or context.TODO() instead.\nvar NoContext = context.TODO()\n\n// RegisterBrokenAuthHeaderProvider previously did something. It is now a no-op.\n//\n// Deprecated: this function no longer does anything. Caller code that\n// wants to avoid potential extra HTTP requests made during\n// auto-probing of the provider's auth style should set\n// Endpoint.AuthStyle.\nfunc RegisterBrokenAuthHeaderProvider(tokenURL string) {}\n\n// Config describes a typical 3-legged OAuth2 flow, with both the\n// client application information and the server's endpoint URLs.\n// For the client credentials 2-legged OAuth2 flow, see the clientcredentials\n// package (https://golang.org/x/oauth2/clientcredentials).\ntype Config struct {\n\t// ClientID is the application's ID.\n\tClientID string\n\n\t// ClientSecret is the application's secret.\n\tClientSecret string\n\n\t// Endpoint contains the resource server's token endpoint\n\t// URLs. These are constants specific to each server and are\n\t// often available via site-specific packages, such as\n\t// google.Endpoint or github.Endpoint.\n\tEndpoint Endpoint\n\n\t// RedirectURL is the URL to redirect users going through\n\t// the OAuth flow, after the resource owner's URLs.\n\tRedirectURL string\n\n\t// Scopes specifies optional requested permissions.\n\tScopes []string\n\n\t// authStyleCache caches which auth style to use when Endpoint.AuthStyle is\n\t// the zero value (AuthStyleAutoDetect).\n\tauthStyleCache internal.LazyAuthStyleCache\n}\n\n// A TokenSource is anything that can return a token.\ntype TokenSource interface {\n\t// Token returns a token or an error.\n\t// Token must be safe for concurrent use by multiple goroutines.\n\t// The returned Token must not be modified.\n\tToken() (*Token, error)\n}\n\n// Endpoint represents an OAuth 2.0 provider's authorization and token\n// endpoint URLs.\ntype Endpoint struct {\n\tAuthURL       string\n\tDeviceAuthURL string\n\tTokenURL      string\n\n\t// AuthStyle optionally specifies how the endpoint wants the\n\t// client ID & client secret sent. The zero value means to\n\t// auto-detect.\n\tAuthStyle AuthStyle\n}\n\n// AuthStyle represents how requests for tokens are authenticated\n// to the server.\ntype AuthStyle int\n\nconst (\n\t// AuthStyleAutoDetect means to auto-detect which authentication\n\t// style the provider wants by trying both ways and caching\n\t// the successful way for the future.\n\tAuthStyleAutoDetect AuthStyle = 0\n\n\t// AuthStyleInParams sends the \"client_id\" and \"client_secret\"\n\t// in the POST body as application/x-www-form-urlencoded parameters.\n\tAuthStyleInParams AuthStyle = 1\n\n\t// AuthStyleInHeader sends the client_id and client_password\n\t// using HTTP Basic Authorization. This is an optional style\n\t// described in the OAuth2 RFC 6749 section 2.3.1.\n\tAuthStyleInHeader AuthStyle = 2\n)\n\nvar (\n\t// AccessTypeOnline and AccessTypeOffline are options passed\n\t// to the Options.AuthCodeURL method. They modify the\n\t// \"access_type\" field that gets sent in the URL returned by\n\t// AuthCodeURL.\n\t//\n\t// Online is the default if neither is specified. If your\n\t// application needs to refresh access tokens when the user\n\t// is not present at the browser, then use offline. This will\n\t// result in your application obtaining a refresh token the\n\t// first time your application exchanges an authorization\n\t// code for a user.\n\tAccessTypeOnline  AuthCodeOption = SetAuthURLParam(\"access_type\", \"online\")\n\tAccessTypeOffline AuthCodeOption = SetAuthURLParam(\"access_type\", \"offline\")\n\n\t// ApprovalForce forces the users to view the consent dialog\n\t// and confirm the permissions request at the URL returned\n\t// from AuthCodeURL, even if they've already done so.\n\tApprovalForce AuthCodeOption = SetAuthURLParam(\"prompt\", \"consent\")\n)\n\n// An AuthCodeOption is passed to Config.AuthCodeURL.\ntype AuthCodeOption interface {\n\tsetValue(url.Values)\n}\n\ntype setParam struct{ k, v string }\n\nfunc (p setParam) setValue(m url.Values) { m.Set(p.k, p.v) }\n\n// SetAuthURLParam builds an AuthCodeOption which passes key/value parameters\n// to a provider's authorization endpoint.\nfunc SetAuthURLParam(key, value string) AuthCodeOption {\n\treturn setParam{key, value}\n}\n\n// AuthCodeURL returns a URL to OAuth 2.0 provider's consent page\n// that asks for permissions for the required scopes explicitly.\n//\n// State is an opaque value used by the client to maintain state between the\n// request and callback. The authorization server includes this value when\n// redirecting the user agent back to the client.\n//\n// Opts may include AccessTypeOnline or AccessTypeOffline, as well\n// as ApprovalForce.\n//\n// To protect against CSRF attacks, opts should include a PKCE challenge\n// (S256ChallengeOption). Not all servers support PKCE. An alternative is to\n// generate a random state parameter and verify it after exchange.\n// See https://datatracker.ietf.org/doc/html/rfc6749#section-10.12 (predating\n// PKCE), https://www.oauth.com/oauth2-servers/pkce/ and\n// https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-09.html#name-cross-site-request-forgery (describing both approaches)\nfunc (c *Config) AuthCodeURL(state string, opts ...AuthCodeOption) string {\n\tvar buf bytes.Buffer\n\tbuf.WriteString(c.Endpoint.AuthURL)\n\tv := url.Values{\n\t\t\"response_type\": {\"code\"},\n\t\t\"client_id\":     {c.ClientID},\n\t}\n\tif c.RedirectURL != \"\" {\n\t\tv.Set(\"redirect_uri\", c.RedirectURL)\n\t}\n\tif len(c.Scopes) > 0 {\n\t\tv.Set(\"scope\", strings.Join(c.Scopes, \" \"))\n\t}\n\tif state != \"\" {\n\t\tv.Set(\"state\", state)\n\t}\n\tfor _, opt := range opts {\n\t\topt.setValue(v)\n\t}\n\tif strings.Contains(c.Endpoint.AuthURL, \"?\") {\n\t\tbuf.WriteByte('&')\n\t} else {\n\t\tbuf.WriteByte('?')\n\t}\n\tbuf.WriteString(v.Encode())\n\treturn buf.String()\n}\n\n// PasswordCredentialsToken converts a resource owner username and password\n// pair into a token.\n//\n// Per the RFC, this grant type should only be used \"when there is a high\n// degree of trust between the resource owner and the client (e.g., the client\n// is part of the device operating system or a highly privileged application),\n// and when other authorization grant types are not available.\"\n// See https://tools.ietf.org/html/rfc6749#section-4.3 for more info.\n//\n// The provided context optionally controls which HTTP client is used. See the HTTPClient variable.\nfunc (c *Config) PasswordCredentialsToken(ctx context.Context, username, password string) (*Token, error) {\n\tv := url.Values{\n\t\t\"grant_type\": {\"password\"},\n\t\t\"username\":   {username},\n\t\t\"password\":   {password},\n\t}\n\tif len(c.Scopes) > 0 {\n\t\tv.Set(\"scope\", strings.Join(c.Scopes, \" \"))\n\t}\n\treturn retrieveToken(ctx, c, v)\n}\n\n// Exchange converts an authorization code into a token.\n//\n// It is used after a resource provider redirects the user back\n// to the Redirect URI (the URL obtained from AuthCodeURL).\n//\n// The provided context optionally controls which HTTP client is used. See the HTTPClient variable.\n//\n// The code will be in the *http.Request.FormValue(\"code\"). Before\n// calling Exchange, be sure to validate FormValue(\"state\") if you are\n// using it to protect against CSRF attacks.\n//\n// If using PKCE to protect against CSRF attacks, opts should include a\n// VerifierOption.\nfunc (c *Config) Exchange(ctx context.Context, code string, opts ...AuthCodeOption) (*Token, error) {\n\tv := url.Values{\n\t\t\"grant_type\": {\"authorization_code\"},\n\t\t\"code\":       {code},\n\t}\n\tif c.RedirectURL != \"\" {\n\t\tv.Set(\"redirect_uri\", c.RedirectURL)\n\t}\n\tfor _, opt := range opts {\n\t\topt.setValue(v)\n\t}\n\treturn retrieveToken(ctx, c, v)\n}\n\n// Client returns an HTTP client using the provided token.\n// The token will auto-refresh as necessary. The underlying\n// HTTP transport will be obtained using the provided context.\n// The returned client and its Transport should not be modified.\nfunc (c *Config) Client(ctx context.Context, t *Token) *http.Client {\n\treturn NewClient(ctx, c.TokenSource(ctx, t))\n}\n\n// TokenSource returns a TokenSource that returns t until t expires,\n// automatically refreshing it as necessary using the provided context.\n//\n// Most users will use Config.Client instead.\nfunc (c *Config) TokenSource(ctx context.Context, t *Token) TokenSource {\n\ttkr := &tokenRefresher{\n\t\tctx:  ctx,\n\t\tconf: c,\n\t}\n\tif t != nil {\n\t\ttkr.refreshToken = t.RefreshToken\n\t}\n\treturn &reuseTokenSource{\n\t\tt:   t,\n\t\tnew: tkr,\n\t}\n}\n\n// tokenRefresher is a TokenSource that makes \"grant_type\"==\"refresh_token\"\n// HTTP requests to renew a token using a RefreshToken.\ntype tokenRefresher struct {\n\tctx          context.Context // used to get HTTP requests\n\tconf         *Config\n\trefreshToken string\n}\n\n// WARNING: Token is not safe for concurrent access, as it\n// updates the tokenRefresher's refreshToken field.\n// Within this package, it is used by reuseTokenSource which\n// synchronizes calls to this method with its own mutex.\nfunc (tf *tokenRefresher) Token() (*Token, error) {\n\tif tf.refreshToken == \"\" {\n\t\treturn nil, errors.New(\"oauth2: token expired and refresh token is not set\")\n\t}\n\n\ttk, err := retrieveToken(tf.ctx, tf.conf, url.Values{\n\t\t\"grant_type\":    {\"refresh_token\"},\n\t\t\"refresh_token\": {tf.refreshToken},\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif tf.refreshToken != tk.RefreshToken {\n\t\ttf.refreshToken = tk.RefreshToken\n\t}\n\treturn tk, err\n}\n\n// reuseTokenSource is a TokenSource that holds a single token in memory\n// and validates its expiry before each call to retrieve it with\n// Token. If it's expired, it will be auto-refreshed using the\n// new TokenSource.\ntype reuseTokenSource struct {\n\tnew TokenSource // called when t is expired.\n\n\tmu sync.Mutex // guards t\n\tt  *Token\n\n\texpiryDelta time.Duration\n}\n\n// Token returns the current token if it's still valid, else will\n// refresh the current token (using r.Context for HTTP client\n// information) and return the new one.\nfunc (s *reuseTokenSource) Token() (*Token, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif s.t.Valid() {\n\t\treturn s.t, nil\n\t}\n\tt, err := s.new.Token()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tt.expiryDelta = s.expiryDelta\n\ts.t = t\n\treturn t, nil\n}\n\n// StaticTokenSource returns a TokenSource that always returns the same token.\n// Because the provided token t is never refreshed, StaticTokenSource is only\n// useful for tokens that never expire.\nfunc StaticTokenSource(t *Token) TokenSource {\n\treturn staticTokenSource{t}\n}\n\n// staticTokenSource is a TokenSource that always returns the same Token.\ntype staticTokenSource struct {\n\tt *Token\n}\n\nfunc (s staticTokenSource) Token() (*Token, error) {\n\treturn s.t, nil\n}\n\n// HTTPClient is the context key to use with golang.org/x/net/context's\n// WithValue function to associate an *http.Client value with a context.\nvar HTTPClient internal.ContextKey\n\n// NewClient creates an *http.Client from a Context and TokenSource.\n// The returned client is not valid beyond the lifetime of the context.\n//\n// Note that if a custom *http.Client is provided via the Context it\n// is used only for token acquisition and is not used to configure the\n// *http.Client returned from NewClient.\n//\n// As a special case, if src is nil, a non-OAuth2 client is returned\n// using the provided context. This exists to support related OAuth2\n// packages.\nfunc NewClient(ctx context.Context, src TokenSource) *http.Client {\n\tif src == nil {\n\t\treturn internal.ContextClient(ctx)\n\t}\n\treturn &http.Client{\n\t\tTransport: &Transport{\n\t\t\tBase:   internal.ContextClient(ctx).Transport,\n\t\t\tSource: ReuseTokenSource(nil, src),\n\t\t},\n\t}\n}\n\n// ReuseTokenSource returns a TokenSource which repeatedly returns the\n// same token as long as it's valid, starting with t.\n// When its cached token is invalid, a new token is obtained from src.\n//\n// ReuseTokenSource is typically used to reuse tokens from a cache\n// (such as a file on disk) between runs of a program, rather than\n// obtaining new tokens unnecessarily.\n//\n// The initial token t may be nil, in which case the TokenSource is\n// wrapped in a caching version if it isn't one already. This also\n// means it's always safe to wrap ReuseTokenSource around any other\n// TokenSource without adverse effects.\nfunc ReuseTokenSource(t *Token, src TokenSource) TokenSource {\n\t// Don't wrap a reuseTokenSource in itself. That would work,\n\t// but cause an unnecessary number of mutex operations.\n\t// Just build the equivalent one.\n\tif rt, ok := src.(*reuseTokenSource); ok {\n\t\tif t == nil {\n\t\t\t// Just use it directly.\n\t\t\treturn rt\n\t\t}\n\t\tsrc = rt.new\n\t}\n\treturn &reuseTokenSource{\n\t\tt:   t,\n\t\tnew: src,\n\t}\n}\n\n// ReuseTokenSourceWithExpiry returns a TokenSource that acts in the same manner as the\n// TokenSource returned by ReuseTokenSource, except the expiry buffer is\n// configurable. The expiration time of a token is calculated as\n// t.Expiry.Add(-earlyExpiry).\nfunc ReuseTokenSourceWithExpiry(t *Token, src TokenSource, earlyExpiry time.Duration) TokenSource {\n\t// Don't wrap a reuseTokenSource in itself. That would work,\n\t// but cause an unnecessary number of mutex operations.\n\t// Just build the equivalent one.\n\tif rt, ok := src.(*reuseTokenSource); ok {\n\t\tif t == nil {\n\t\t\t// Just use it directly, but set the expiryDelta to earlyExpiry,\n\t\t\t// so the behavior matches what the user expects.\n\t\t\trt.expiryDelta = earlyExpiry\n\t\t\treturn rt\n\t\t}\n\t\tsrc = rt.new\n\t}\n\tif t != nil {\n\t\tt.expiryDelta = earlyExpiry\n\t}\n\treturn &reuseTokenSource{\n\t\tt:           t,\n\t\tnew:         src,\n\t\texpiryDelta: earlyExpiry,\n\t}\n}\n"
        },
        {
          "name": "oauth2_test.go",
          "type": "blob",
          "size": 19.5478515625,
          "content": "// Copyright 2014 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage oauth2\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype mockTransport struct {\n\trt func(req *http.Request) (resp *http.Response, err error)\n}\n\nfunc (t *mockTransport) RoundTrip(req *http.Request) (resp *http.Response, err error) {\n\treturn t.rt(req)\n}\n\nfunc newConf(url string) *Config {\n\treturn &Config{\n\t\tClientID:     \"CLIENT_ID\",\n\t\tClientSecret: \"CLIENT_SECRET\",\n\t\tRedirectURL:  \"REDIRECT_URL\",\n\t\tScopes:       []string{\"scope1\", \"scope2\"},\n\t\tEndpoint: Endpoint{\n\t\t\tAuthURL:  url + \"/auth\",\n\t\t\tTokenURL: url + \"/token\",\n\t\t},\n\t}\n}\n\nfunc TestAuthCodeURL(t *testing.T) {\n\tconf := newConf(\"server\")\n\turl := conf.AuthCodeURL(\"foo\", AccessTypeOffline, ApprovalForce)\n\tconst want = \"server/auth?access_type=offline&client_id=CLIENT_ID&prompt=consent&redirect_uri=REDIRECT_URL&response_type=code&scope=scope1+scope2&state=foo\"\n\tif got := url; got != want {\n\t\tt.Errorf(\"got auth code URL = %q; want %q\", got, want)\n\t}\n}\n\nfunc TestAuthCodeURL_CustomParam(t *testing.T) {\n\tconf := newConf(\"server\")\n\tparam := SetAuthURLParam(\"foo\", \"bar\")\n\turl := conf.AuthCodeURL(\"baz\", param)\n\tconst want = \"server/auth?client_id=CLIENT_ID&foo=bar&redirect_uri=REDIRECT_URL&response_type=code&scope=scope1+scope2&state=baz\"\n\tif got := url; got != want {\n\t\tt.Errorf(\"got auth code = %q; want %q\", got, want)\n\t}\n}\n\nfunc TestAuthCodeURL_Optional(t *testing.T) {\n\tconf := &Config{\n\t\tClientID: \"CLIENT_ID\",\n\t\tEndpoint: Endpoint{\n\t\t\tAuthURL:  \"/auth-url\",\n\t\t\tTokenURL: \"/token-url\",\n\t\t},\n\t}\n\turl := conf.AuthCodeURL(\"\")\n\tconst want = \"/auth-url?client_id=CLIENT_ID&response_type=code\"\n\tif got := url; got != want {\n\t\tt.Fatalf(\"got auth code = %q; want %q\", got, want)\n\t}\n}\n\nfunc TestURLUnsafeClientConfig(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif got, want := r.Header.Get(\"Authorization\"), \"Basic Q0xJRU5UX0lEJTNGJTNGOkNMSUVOVF9TRUNSRVQlM0YlM0Y=\"; got != want {\n\t\t\tt.Errorf(\"Authorization header = %q; want %q\", got, want)\n\t\t}\n\n\t\tw.Header().Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\t\tw.Write([]byte(\"access_token=90d64460d14870c08c81352a05dedd3465940a7c&scope=user&token_type=bearer\"))\n\t}))\n\tdefer ts.Close()\n\tconf := newConf(ts.URL)\n\tconf.ClientID = \"CLIENT_ID??\"\n\tconf.ClientSecret = \"CLIENT_SECRET??\"\n\t_, err := conf.Exchange(context.Background(), \"exchange-code\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestExchangeRequest(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.String() != \"/token\" {\n\t\t\tt.Errorf(\"Unexpected exchange request URL %q\", r.URL)\n\t\t}\n\t\theaderAuth := r.Header.Get(\"Authorization\")\n\t\tif want := \"Basic Q0xJRU5UX0lEOkNMSUVOVF9TRUNSRVQ=\"; headerAuth != want {\n\t\t\tt.Errorf(\"Unexpected authorization header %q, want %q\", headerAuth, want)\n\t\t}\n\t\theaderContentType := r.Header.Get(\"Content-Type\")\n\t\tif headerContentType != \"application/x-www-form-urlencoded\" {\n\t\t\tt.Errorf(\"Unexpected Content-Type header %q\", headerContentType)\n\t\t}\n\t\tbody, err := ioutil.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed reading request body: %s.\", err)\n\t\t}\n\t\tif string(body) != \"code=exchange-code&grant_type=authorization_code&redirect_uri=REDIRECT_URL\" {\n\t\t\tt.Errorf(\"Unexpected exchange payload; got %q\", body)\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\t\tw.Write([]byte(\"access_token=90d64460d14870c08c81352a05dedd3465940a7c&scope=user&token_type=bearer\"))\n\t}))\n\tdefer ts.Close()\n\tconf := newConf(ts.URL)\n\ttok, err := conf.Exchange(context.Background(), \"exchange-code\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !tok.Valid() {\n\t\tt.Fatalf(\"Token invalid. Got: %#v\", tok)\n\t}\n\tif tok.AccessToken != \"90d64460d14870c08c81352a05dedd3465940a7c\" {\n\t\tt.Errorf(\"Unexpected access token, %#v.\", tok.AccessToken)\n\t}\n\tif tok.TokenType != \"bearer\" {\n\t\tt.Errorf(\"Unexpected token type, %#v.\", tok.TokenType)\n\t}\n\tscope := tok.Extra(\"scope\")\n\tif scope != \"user\" {\n\t\tt.Errorf(\"Unexpected value for scope: %v\", scope)\n\t}\n}\n\nfunc TestExchangeRequest_CustomParam(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.String() != \"/token\" {\n\t\t\tt.Errorf(\"Unexpected exchange request URL, %v is found.\", r.URL)\n\t\t}\n\t\theaderAuth := r.Header.Get(\"Authorization\")\n\t\tif headerAuth != \"Basic Q0xJRU5UX0lEOkNMSUVOVF9TRUNSRVQ=\" {\n\t\t\tt.Errorf(\"Unexpected authorization header, %v is found.\", headerAuth)\n\t\t}\n\t\theaderContentType := r.Header.Get(\"Content-Type\")\n\t\tif headerContentType != \"application/x-www-form-urlencoded\" {\n\t\t\tt.Errorf(\"Unexpected Content-Type header, %v is found.\", headerContentType)\n\t\t}\n\t\tbody, err := ioutil.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed reading request body: %s.\", err)\n\t\t}\n\t\tif string(body) != \"code=exchange-code&foo=bar&grant_type=authorization_code&redirect_uri=REDIRECT_URL\" {\n\t\t\tt.Errorf(\"Unexpected exchange payload, %v is found.\", string(body))\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\t\tw.Write([]byte(\"access_token=90d64460d14870c08c81352a05dedd3465940a7c&scope=user&token_type=bearer\"))\n\t}))\n\tdefer ts.Close()\n\tconf := newConf(ts.URL)\n\n\tparam := SetAuthURLParam(\"foo\", \"bar\")\n\ttok, err := conf.Exchange(context.Background(), \"exchange-code\", param)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !tok.Valid() {\n\t\tt.Fatalf(\"Token invalid. Got: %#v\", tok)\n\t}\n\tif tok.AccessToken != \"90d64460d14870c08c81352a05dedd3465940a7c\" {\n\t\tt.Errorf(\"Unexpected access token, %#v.\", tok.AccessToken)\n\t}\n\tif tok.TokenType != \"bearer\" {\n\t\tt.Errorf(\"Unexpected token type, %#v.\", tok.TokenType)\n\t}\n\tscope := tok.Extra(\"scope\")\n\tif scope != \"user\" {\n\t\tt.Errorf(\"Unexpected value for scope: %v\", scope)\n\t}\n}\n\nfunc TestExchangeRequest_JSONResponse(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.String() != \"/token\" {\n\t\t\tt.Errorf(\"Unexpected exchange request URL, %v is found.\", r.URL)\n\t\t}\n\t\theaderAuth := r.Header.Get(\"Authorization\")\n\t\tif headerAuth != \"Basic Q0xJRU5UX0lEOkNMSUVOVF9TRUNSRVQ=\" {\n\t\t\tt.Errorf(\"Unexpected authorization header, %v is found.\", headerAuth)\n\t\t}\n\t\theaderContentType := r.Header.Get(\"Content-Type\")\n\t\tif headerContentType != \"application/x-www-form-urlencoded\" {\n\t\t\tt.Errorf(\"Unexpected Content-Type header, %v is found.\", headerContentType)\n\t\t}\n\t\tbody, err := ioutil.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed reading request body: %s.\", err)\n\t\t}\n\t\tif string(body) != \"code=exchange-code&grant_type=authorization_code&redirect_uri=REDIRECT_URL\" {\n\t\t\tt.Errorf(\"Unexpected exchange payload, %v is found.\", string(body))\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write([]byte(`{\"access_token\": \"90d64460d14870c08c81352a05dedd3465940a7c\", \"scope\": \"user\", \"token_type\": \"bearer\", \"expires_in\": 86400}`))\n\t}))\n\tdefer ts.Close()\n\tconf := newConf(ts.URL)\n\ttok, err := conf.Exchange(context.Background(), \"exchange-code\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !tok.Valid() {\n\t\tt.Fatalf(\"Token invalid. Got: %#v\", tok)\n\t}\n\tif tok.AccessToken != \"90d64460d14870c08c81352a05dedd3465940a7c\" {\n\t\tt.Errorf(\"Unexpected access token, %#v.\", tok.AccessToken)\n\t}\n\tif tok.TokenType != \"bearer\" {\n\t\tt.Errorf(\"Unexpected token type, %#v.\", tok.TokenType)\n\t}\n\tscope := tok.Extra(\"scope\")\n\tif scope != \"user\" {\n\t\tt.Errorf(\"Unexpected value for scope: %v\", scope)\n\t}\n\texpiresIn := tok.Extra(\"expires_in\")\n\tif expiresIn != float64(86400) {\n\t\tt.Errorf(\"Unexpected non-numeric value for expires_in: %v\", expiresIn)\n\t}\n}\n\nfunc TestExtraValueRetrieval(t *testing.T) {\n\tvalues := url.Values{}\n\tkvmap := map[string]string{\n\t\t\"scope\": \"user\", \"token_type\": \"bearer\", \"expires_in\": \"86400.92\",\n\t\t\"server_time\": \"1443571905.5606415\", \"referer_ip\": \"10.0.0.1\",\n\t\t\"etag\": \"\\\"afZYj912P4alikMz_P11982\\\"\", \"request_id\": \"86400\",\n\t\t\"untrimmed\": \"  untrimmed  \",\n\t}\n\tfor key, value := range kvmap {\n\t\tvalues.Set(key, value)\n\t}\n\n\ttok := Token{raw: values}\n\tscope := tok.Extra(\"scope\")\n\tif got, want := scope, \"user\"; got != want {\n\t\tt.Errorf(\"got scope = %q; want %q\", got, want)\n\t}\n\tserverTime := tok.Extra(\"server_time\")\n\tif got, want := serverTime, 1443571905.5606415; got != want {\n\t\tt.Errorf(\"got server_time value = %v; want %v\", got, want)\n\t}\n\trefererIP := tok.Extra(\"referer_ip\")\n\tif got, want := refererIP, \"10.0.0.1\"; got != want {\n\t\tt.Errorf(\"got referer_ip value = %v, want %v\", got, want)\n\t}\n\texpiresIn := tok.Extra(\"expires_in\")\n\tif got, want := expiresIn, 86400.92; got != want {\n\t\tt.Errorf(\"got expires_in value = %v, want %v\", got, want)\n\t}\n\trequestID := tok.Extra(\"request_id\")\n\tif got, want := requestID, int64(86400); got != want {\n\t\tt.Errorf(\"got request_id value = %v, want %v\", got, want)\n\t}\n\tuntrimmed := tok.Extra(\"untrimmed\")\n\tif got, want := untrimmed, \"  untrimmed  \"; got != want {\n\t\tt.Errorf(\"got untrimmed = %q; want %q\", got, want)\n\t}\n}\n\nconst day = 24 * time.Hour\n\nfunc TestExchangeRequest_JSONResponse_Expiry(t *testing.T) {\n\tseconds := int32(day.Seconds())\n\tfor _, c := range []struct {\n\t\tname        string\n\t\texpires     string\n\t\twant        bool\n\t\tnullExpires bool\n\t}{\n\t\t{\"normal\", fmt.Sprintf(`\"expires_in\": %d`, seconds), true, false},\n\t\t{\"paypal\", fmt.Sprintf(`\"expires_in\": \"%d\"`, seconds), true, false},\n\t\t{\"issue_239\", fmt.Sprintf(`\"expires_in\": null`), true, true},\n\n\t\t{\"wrong_type\", `\"expires_in\": false`, false, false},\n\t\t{\"wrong_type2\", `\"expires_in\": {}`, false, false},\n\t\t{\"wrong_value\", `\"expires_in\": \"zzz\"`, false, false},\n\t} {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\ttestExchangeRequest_JSONResponse_expiry(t, c.expires, c.want, c.nullExpires)\n\t\t})\n\t}\n}\n\nfunc testExchangeRequest_JSONResponse_expiry(t *testing.T, exp string, want, nullExpires bool) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write([]byte(fmt.Sprintf(`{\"access_token\": \"90d\", \"scope\": \"user\", \"token_type\": \"bearer\", %s}`, exp)))\n\t}))\n\tdefer ts.Close()\n\tconf := newConf(ts.URL)\n\tt1 := time.Now().Add(day)\n\ttok, err := conf.Exchange(context.Background(), \"exchange-code\")\n\tt2 := t1.Add(day)\n\n\tif got := (err == nil); got != want {\n\t\tif want {\n\t\t\tt.Errorf(\"unexpected error: got %v\", err)\n\t\t} else {\n\t\t\tt.Errorf(\"unexpected success\")\n\t\t}\n\t}\n\tif !want {\n\t\treturn\n\t}\n\tif !tok.Valid() {\n\t\tt.Fatalf(\"Token invalid. Got: %#v\", tok)\n\t}\n\texpiry := tok.Expiry\n\n\tif nullExpires && expiry.IsZero() {\n\t\treturn\n\t}\n\tif expiry.Before(t1) || expiry.After(t2) {\n\t\tt.Errorf(\"Unexpected value for Expiry: %v (should be between %v and %v)\", expiry, t1, t2)\n\t}\n}\n\nfunc TestExchangeRequest_BadResponse(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write([]byte(`{\"scope\": \"user\", \"token_type\": \"bearer\"}`))\n\t}))\n\tdefer ts.Close()\n\tconf := newConf(ts.URL)\n\t_, err := conf.Exchange(context.Background(), \"code\")\n\tif err == nil {\n\t\tt.Error(\"expected error from missing access_token\")\n\t}\n}\n\nfunc TestExchangeRequest_BadResponseType(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write([]byte(`{\"access_token\":123,  \"scope\": \"user\", \"token_type\": \"bearer\"}`))\n\t}))\n\tdefer ts.Close()\n\tconf := newConf(ts.URL)\n\t_, err := conf.Exchange(context.Background(), \"exchange-code\")\n\tif err == nil {\n\t\tt.Error(\"expected error from non-string access_token\")\n\t}\n}\n\nfunc TestExchangeRequest_NonBasicAuth(t *testing.T) {\n\ttr := &mockTransport{\n\t\trt: func(r *http.Request) (w *http.Response, err error) {\n\t\t\theaderAuth := r.Header.Get(\"Authorization\")\n\t\t\tif headerAuth != \"\" {\n\t\t\t\tt.Errorf(\"Unexpected authorization header %q\", headerAuth)\n\t\t\t}\n\t\t\treturn nil, errors.New(\"no response\")\n\t\t},\n\t}\n\tc := &http.Client{Transport: tr}\n\tconf := &Config{\n\t\tClientID: \"CLIENT_ID\",\n\t\tEndpoint: Endpoint{\n\t\t\tAuthURL:   \"https://accounts.google.com/auth\",\n\t\t\tTokenURL:  \"https://accounts.google.com/token\",\n\t\t\tAuthStyle: AuthStyleInParams,\n\t\t},\n\t}\n\n\tctx := context.WithValue(context.Background(), HTTPClient, c)\n\tconf.Exchange(ctx, \"code\")\n}\n\nfunc TestPasswordCredentialsTokenRequest(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer r.Body.Close()\n\t\texpected := \"/token\"\n\t\tif r.URL.String() != expected {\n\t\t\tt.Errorf(\"URL = %q; want %q\", r.URL, expected)\n\t\t}\n\t\theaderAuth := r.Header.Get(\"Authorization\")\n\t\texpected = \"Basic Q0xJRU5UX0lEOkNMSUVOVF9TRUNSRVQ=\"\n\t\tif headerAuth != expected {\n\t\t\tt.Errorf(\"Authorization header = %q; want %q\", headerAuth, expected)\n\t\t}\n\t\theaderContentType := r.Header.Get(\"Content-Type\")\n\t\texpected = \"application/x-www-form-urlencoded\"\n\t\tif headerContentType != expected {\n\t\t\tt.Errorf(\"Content-Type header = %q; want %q\", headerContentType, expected)\n\t\t}\n\t\tbody, err := ioutil.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed reading request body: %s.\", err)\n\t\t}\n\t\texpected = \"grant_type=password&password=password1&scope=scope1+scope2&username=user1\"\n\t\tif string(body) != expected {\n\t\t\tt.Errorf(\"res.Body = %q; want %q\", string(body), expected)\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\t\tw.Write([]byte(\"access_token=90d64460d14870c08c81352a05dedd3465940a7c&scope=user&token_type=bearer\"))\n\t}))\n\tdefer ts.Close()\n\tconf := newConf(ts.URL)\n\ttok, err := conf.PasswordCredentialsToken(context.Background(), \"user1\", \"password1\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !tok.Valid() {\n\t\tt.Fatalf(\"Token invalid. Got: %#v\", tok)\n\t}\n\texpected := \"90d64460d14870c08c81352a05dedd3465940a7c\"\n\tif tok.AccessToken != expected {\n\t\tt.Errorf(\"AccessToken = %q; want %q\", tok.AccessToken, expected)\n\t}\n\texpected = \"bearer\"\n\tif tok.TokenType != expected {\n\t\tt.Errorf(\"TokenType = %q; want %q\", tok.TokenType, expected)\n\t}\n}\n\nfunc TestTokenRefreshRequest(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.String() == \"/somethingelse\" {\n\t\t\treturn\n\t\t}\n\t\tif r.URL.String() != \"/token\" {\n\t\t\tt.Errorf(\"Unexpected token refresh request URL %q\", r.URL)\n\t\t}\n\t\theaderContentType := r.Header.Get(\"Content-Type\")\n\t\tif headerContentType != \"application/x-www-form-urlencoded\" {\n\t\t\tt.Errorf(\"Unexpected Content-Type header %q\", headerContentType)\n\t\t}\n\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\tif string(body) != \"grant_type=refresh_token&refresh_token=REFRESH_TOKEN\" {\n\t\t\tt.Errorf(\"Unexpected refresh token payload %q\", body)\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tio.WriteString(w, `{\"access_token\": \"foo\", \"refresh_token\": \"bar\"}`)\n\t}))\n\tdefer ts.Close()\n\tconf := newConf(ts.URL)\n\tc := conf.Client(context.Background(), &Token{RefreshToken: \"REFRESH_TOKEN\"})\n\tc.Get(ts.URL + \"/somethingelse\")\n}\n\nfunc TestFetchWithNoRefreshToken(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.String() == \"/somethingelse\" {\n\t\t\treturn\n\t\t}\n\t\tif r.URL.String() != \"/token\" {\n\t\t\tt.Errorf(\"Unexpected token refresh request URL, %v is found.\", r.URL)\n\t\t}\n\t\theaderContentType := r.Header.Get(\"Content-Type\")\n\t\tif headerContentType != \"application/x-www-form-urlencoded\" {\n\t\t\tt.Errorf(\"Unexpected Content-Type header, %v is found.\", headerContentType)\n\t\t}\n\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\tif string(body) != \"client_id=CLIENT_ID&grant_type=refresh_token&refresh_token=REFRESH_TOKEN\" {\n\t\t\tt.Errorf(\"Unexpected refresh token payload, %v is found.\", string(body))\n\t\t}\n\t}))\n\tdefer ts.Close()\n\tconf := newConf(ts.URL)\n\tc := conf.Client(context.Background(), nil)\n\t_, err := c.Get(ts.URL + \"/somethingelse\")\n\tif err == nil {\n\t\tt.Errorf(\"Fetch should return an error if no refresh token is set\")\n\t}\n}\n\nfunc TestTokenRetrieveError(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.String() != \"/token\" {\n\t\t\tt.Errorf(\"Unexpected token refresh request URL, %v is found.\", r.URL)\n\t\t}\n\t\tw.Header().Set(\"Content-type\", \"application/json\")\n\t\t// \"The authorization server responds with an HTTP 400 (Bad Request)\" https://www.rfc-editor.org/rfc/rfc6749#section-5.2\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tw.Write([]byte(`{\"error\": \"invalid_grant\"}`))\n\t}))\n\tdefer ts.Close()\n\tconf := newConf(ts.URL)\n\t_, err := conf.Exchange(context.Background(), \"exchange-code\")\n\tif err == nil {\n\t\tt.Fatalf(\"got no error, expected one\")\n\t}\n\tre, ok := err.(*RetrieveError)\n\tif !ok {\n\t\tt.Fatalf(\"got %T error, expected *RetrieveError; error was: %v\", err, err)\n\t}\n\texpected := `oauth2: \"invalid_grant\"`\n\tif errStr := err.Error(); errStr != expected {\n\t\tt.Fatalf(\"got %#v, expected %#v\", errStr, expected)\n\t}\n\texpected = \"invalid_grant\"\n\tif re.ErrorCode != expected {\n\t\tt.Fatalf(\"got %#v, expected %#v\", re.ErrorCode, expected)\n\t}\n}\n\n// TestTokenRetrieveError200 tests handling of unorthodox server that returns 200 in error case\nfunc TestTokenRetrieveError200(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.String() != \"/token\" {\n\t\t\tt.Errorf(\"Unexpected token refresh request URL, %v is found.\", r.URL)\n\t\t}\n\t\tw.Header().Set(\"Content-type\", \"application/json\")\n\t\tw.Write([]byte(`{\"error\": \"invalid_grant\"}`))\n\t}))\n\tdefer ts.Close()\n\tconf := newConf(ts.URL)\n\t_, err := conf.Exchange(context.Background(), \"exchange-code\")\n\tif err == nil {\n\t\tt.Fatalf(\"got no error, expected one\")\n\t}\n\tre, ok := err.(*RetrieveError)\n\tif !ok {\n\t\tt.Fatalf(\"got %T error, expected *RetrieveError; error was: %v\", err, err)\n\t}\n\texpected := `oauth2: \"invalid_grant\"`\n\tif errStr := err.Error(); errStr != expected {\n\t\tt.Fatalf(\"got %#v, expected %#v\", errStr, expected)\n\t}\n\texpected = \"invalid_grant\"\n\tif re.ErrorCode != expected {\n\t\tt.Fatalf(\"got %#v, expected %#v\", re.ErrorCode, expected)\n\t}\n}\n\nfunc TestRefreshToken_RefreshTokenReplacement(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write([]byte(`{\"access_token\":\"ACCESS_TOKEN\",  \"scope\": \"user\", \"token_type\": \"bearer\", \"refresh_token\": \"NEW_REFRESH_TOKEN\"}`))\n\t\treturn\n\t}))\n\tdefer ts.Close()\n\tconf := newConf(ts.URL)\n\ttkr := conf.TokenSource(context.Background(), &Token{RefreshToken: \"OLD_REFRESH_TOKEN\"})\n\ttk, err := tkr.Token()\n\tif err != nil {\n\t\tt.Errorf(\"got err = %v; want none\", err)\n\t\treturn\n\t}\n\tif want := \"NEW_REFRESH_TOKEN\"; tk.RefreshToken != want {\n\t\tt.Errorf(\"RefreshToken = %q; want %q\", tk.RefreshToken, want)\n\t}\n}\n\nfunc TestRefreshToken_RefreshTokenPreservation(t *testing.T) {\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write([]byte(`{\"access_token\":\"ACCESS_TOKEN\",  \"scope\": \"user\", \"token_type\": \"bearer\"}`))\n\t\treturn\n\t}))\n\tdefer ts.Close()\n\tconf := newConf(ts.URL)\n\tconst oldRefreshToken = \"OLD_REFRESH_TOKEN\"\n\ttkr := conf.TokenSource(context.Background(), &Token{RefreshToken: oldRefreshToken})\n\ttk, err := tkr.Token()\n\tif err != nil {\n\t\tt.Fatalf(\"got err = %v; want none\", err)\n\t}\n\tif tk.RefreshToken != oldRefreshToken {\n\t\tt.Errorf(\"RefreshToken = %q; want %q\", tk.RefreshToken, oldRefreshToken)\n\t}\n}\n\nfunc TestConfigClientWithToken(t *testing.T) {\n\ttok := &Token{\n\t\tAccessToken: \"abc123\",\n\t}\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif got, want := r.Header.Get(\"Authorization\"), fmt.Sprintf(\"Bearer %s\", tok.AccessToken); got != want {\n\t\t\tt.Errorf(\"Authorization header = %q; want %q\", got, want)\n\t\t}\n\t\treturn\n\t}))\n\tdefer ts.Close()\n\tconf := newConf(ts.URL)\n\n\tc := conf.Client(context.Background(), tok)\n\treq, err := http.NewRequest(\"GET\", ts.URL, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\t_, err = c.Do(req)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n"
        },
        {
          "name": "odnoklassniki",
          "type": "tree",
          "content": null
        },
        {
          "name": "paypal",
          "type": "tree",
          "content": null
        },
        {
          "name": "pkce.go",
          "type": "blob",
          "size": 2.2978515625,
          "content": "// Copyright 2023 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\npackage oauth2\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"net/url\"\n)\n\nconst (\n\tcodeChallengeKey       = \"code_challenge\"\n\tcodeChallengeMethodKey = \"code_challenge_method\"\n\tcodeVerifierKey        = \"code_verifier\"\n)\n\n// GenerateVerifier generates a PKCE code verifier with 32 octets of randomness.\n// This follows recommendations in RFC 7636.\n//\n// A fresh verifier should be generated for each authorization.\n// S256ChallengeOption(verifier) should then be passed to Config.AuthCodeURL\n// (or Config.DeviceAccess) and VerifierOption(verifier) to Config.Exchange\n// (or Config.DeviceAccessToken).\nfunc GenerateVerifier() string {\n\t// \"RECOMMENDED that the output of a suitable random number generator be\n\t// used to create a 32-octet sequence.  The octet sequence is then\n\t// base64url-encoded to produce a 43-octet URL-safe string to use as the\n\t// code verifier.\"\n\t// https://datatracker.ietf.org/doc/html/rfc7636#section-4.1\n\tdata := make([]byte, 32)\n\tif _, err := rand.Read(data); err != nil {\n\t\tpanic(err)\n\t}\n\treturn base64.RawURLEncoding.EncodeToString(data)\n}\n\n// VerifierOption returns a PKCE code verifier AuthCodeOption. It should be\n// passed to Config.Exchange or Config.DeviceAccessToken only.\nfunc VerifierOption(verifier string) AuthCodeOption {\n\treturn setParam{k: codeVerifierKey, v: verifier}\n}\n\n// S256ChallengeFromVerifier returns a PKCE code challenge derived from verifier with method S256.\n//\n// Prefer to use S256ChallengeOption where possible.\nfunc S256ChallengeFromVerifier(verifier string) string {\n\tsha := sha256.Sum256([]byte(verifier))\n\treturn base64.RawURLEncoding.EncodeToString(sha[:])\n}\n\n// S256ChallengeOption derives a PKCE code challenge derived from verifier with\n// method S256. It should be passed to Config.AuthCodeURL or Config.DeviceAccess\n// only.\nfunc S256ChallengeOption(verifier string) AuthCodeOption {\n\treturn challengeOption{\n\t\tchallenge_method: \"S256\",\n\t\tchallenge:        S256ChallengeFromVerifier(verifier),\n\t}\n}\n\ntype challengeOption struct{ challenge_method, challenge string }\n\nfunc (p challengeOption) setValue(m url.Values) {\n\tm.Set(codeChallengeMethodKey, p.challenge_method)\n\tm.Set(codeChallengeKey, p.challenge)\n}\n"
        },
        {
          "name": "slack",
          "type": "tree",
          "content": null
        },
        {
          "name": "spotify",
          "type": "tree",
          "content": null
        },
        {
          "name": "stackoverflow",
          "type": "tree",
          "content": null
        },
        {
          "name": "token.go",
          "type": "blob",
          "size": 6.1279296875,
          "content": "// Copyright 2014 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage oauth2\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"golang.org/x/oauth2/internal\"\n)\n\n// defaultExpiryDelta determines how earlier a token should be considered\n// expired than its actual expiration time. It is used to avoid late\n// expirations due to client-server time mismatches.\nconst defaultExpiryDelta = 10 * time.Second\n\n// Token represents the credentials used to authorize\n// the requests to access protected resources on the OAuth 2.0\n// provider's backend.\n//\n// Most users of this package should not access fields of Token\n// directly. They're exported mostly for use by related packages\n// implementing derivative OAuth2 flows.\ntype Token struct {\n\t// AccessToken is the token that authorizes and authenticates\n\t// the requests.\n\tAccessToken string `json:\"access_token\"`\n\n\t// TokenType is the type of token.\n\t// The Type method returns either this or \"Bearer\", the default.\n\tTokenType string `json:\"token_type,omitempty\"`\n\n\t// RefreshToken is a token that's used by the application\n\t// (as opposed to the user) to refresh the access token\n\t// if it expires.\n\tRefreshToken string `json:\"refresh_token,omitempty\"`\n\n\t// Expiry is the optional expiration time of the access token.\n\t//\n\t// If zero, TokenSource implementations will reuse the same\n\t// token forever and RefreshToken or equivalent\n\t// mechanisms for that TokenSource will not be used.\n\tExpiry time.Time `json:\"expiry,omitempty\"`\n\n\t// ExpiresIn is the OAuth2 wire format \"expires_in\" field,\n\t// which specifies how many seconds later the token expires,\n\t// relative to an unknown time base approximately around \"now\".\n\t// It is the application's responsibility to populate\n\t// `Expiry` from `ExpiresIn` when required.\n\tExpiresIn int64 `json:\"expires_in,omitempty\"`\n\n\t// raw optionally contains extra metadata from the server\n\t// when updating a token.\n\traw interface{}\n\n\t// expiryDelta is used to calculate when a token is considered\n\t// expired, by subtracting from Expiry. If zero, defaultExpiryDelta\n\t// is used.\n\texpiryDelta time.Duration\n}\n\n// Type returns t.TokenType if non-empty, else \"Bearer\".\nfunc (t *Token) Type() string {\n\tif strings.EqualFold(t.TokenType, \"bearer\") {\n\t\treturn \"Bearer\"\n\t}\n\tif strings.EqualFold(t.TokenType, \"mac\") {\n\t\treturn \"MAC\"\n\t}\n\tif strings.EqualFold(t.TokenType, \"basic\") {\n\t\treturn \"Basic\"\n\t}\n\tif t.TokenType != \"\" {\n\t\treturn t.TokenType\n\t}\n\treturn \"Bearer\"\n}\n\n// SetAuthHeader sets the Authorization header to r using the access\n// token in t.\n//\n// This method is unnecessary when using Transport or an HTTP Client\n// returned by this package.\nfunc (t *Token) SetAuthHeader(r *http.Request) {\n\tr.Header.Set(\"Authorization\", t.Type()+\" \"+t.AccessToken)\n}\n\n// WithExtra returns a new Token that's a clone of t, but using the\n// provided raw extra map. This is only intended for use by packages\n// implementing derivative OAuth2 flows.\nfunc (t *Token) WithExtra(extra interface{}) *Token {\n\tt2 := new(Token)\n\t*t2 = *t\n\tt2.raw = extra\n\treturn t2\n}\n\n// Extra returns an extra field.\n// Extra fields are key-value pairs returned by the server as a\n// part of the token retrieval response.\nfunc (t *Token) Extra(key string) interface{} {\n\tif raw, ok := t.raw.(map[string]interface{}); ok {\n\t\treturn raw[key]\n\t}\n\n\tvals, ok := t.raw.(url.Values)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tv := vals.Get(key)\n\tswitch s := strings.TrimSpace(v); strings.Count(s, \".\") {\n\tcase 0: // Contains no \".\"; try to parse as int\n\t\tif i, err := strconv.ParseInt(s, 10, 64); err == nil {\n\t\t\treturn i\n\t\t}\n\tcase 1: // Contains a single \".\"; try to parse as float\n\t\tif f, err := strconv.ParseFloat(s, 64); err == nil {\n\t\t\treturn f\n\t\t}\n\t}\n\n\treturn v\n}\n\n// timeNow is time.Now but pulled out as a variable for tests.\nvar timeNow = time.Now\n\n// expired reports whether the token is expired.\n// t must be non-nil.\nfunc (t *Token) expired() bool {\n\tif t.Expiry.IsZero() {\n\t\treturn false\n\t}\n\n\texpiryDelta := defaultExpiryDelta\n\tif t.expiryDelta != 0 {\n\t\texpiryDelta = t.expiryDelta\n\t}\n\treturn t.Expiry.Round(0).Add(-expiryDelta).Before(timeNow())\n}\n\n// Valid reports whether t is non-nil, has an AccessToken, and is not expired.\nfunc (t *Token) Valid() bool {\n\treturn t != nil && t.AccessToken != \"\" && !t.expired()\n}\n\n// tokenFromInternal maps an *internal.Token struct into\n// a *Token struct.\nfunc tokenFromInternal(t *internal.Token) *Token {\n\tif t == nil {\n\t\treturn nil\n\t}\n\treturn &Token{\n\t\tAccessToken:  t.AccessToken,\n\t\tTokenType:    t.TokenType,\n\t\tRefreshToken: t.RefreshToken,\n\t\tExpiry:       t.Expiry,\n\t\traw:          t.Raw,\n\t}\n}\n\n// retrieveToken takes a *Config and uses that to retrieve an *internal.Token.\n// This token is then mapped from *internal.Token into an *oauth2.Token which is returned along\n// with an error..\nfunc retrieveToken(ctx context.Context, c *Config, v url.Values) (*Token, error) {\n\ttk, err := internal.RetrieveToken(ctx, c.ClientID, c.ClientSecret, c.Endpoint.TokenURL, v, internal.AuthStyle(c.Endpoint.AuthStyle), c.authStyleCache.Get())\n\tif err != nil {\n\t\tif rErr, ok := err.(*internal.RetrieveError); ok {\n\t\t\treturn nil, (*RetrieveError)(rErr)\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn tokenFromInternal(tk), nil\n}\n\n// RetrieveError is the error returned when the token endpoint returns a\n// non-2XX HTTP status code or populates RFC 6749's 'error' parameter.\n// https://datatracker.ietf.org/doc/html/rfc6749#section-5.2\ntype RetrieveError struct {\n\tResponse *http.Response\n\t// Body is the body that was consumed by reading Response.Body.\n\t// It may be truncated.\n\tBody []byte\n\t// ErrorCode is RFC 6749's 'error' parameter.\n\tErrorCode string\n\t// ErrorDescription is RFC 6749's 'error_description' parameter.\n\tErrorDescription string\n\t// ErrorURI is RFC 6749's 'error_uri' parameter.\n\tErrorURI string\n}\n\nfunc (r *RetrieveError) Error() string {\n\tif r.ErrorCode != \"\" {\n\t\ts := fmt.Sprintf(\"oauth2: %q\", r.ErrorCode)\n\t\tif r.ErrorDescription != \"\" {\n\t\t\ts += fmt.Sprintf(\" %q\", r.ErrorDescription)\n\t\t}\n\t\tif r.ErrorURI != \"\" {\n\t\t\ts += fmt.Sprintf(\" %q\", r.ErrorURI)\n\t\t}\n\t\treturn s\n\t}\n\treturn fmt.Sprintf(\"oauth2: cannot fetch token: %v\\nResponse: %s\", r.Response.Status, r.Body)\n}\n"
        },
        {
          "name": "token_test.go",
          "type": "blob",
          "size": 2.7314453125,
          "content": "// Copyright 2014 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage oauth2\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestTokenExtra(t *testing.T) {\n\ttype testCase struct {\n\t\tkey  string\n\t\tval  interface{}\n\t\twant interface{}\n\t}\n\tconst key = \"extra-key\"\n\tcases := []testCase{\n\t\t{key: key, val: \"abc\", want: \"abc\"},\n\t\t{key: key, val: 123, want: 123},\n\t\t{key: key, val: \"\", want: \"\"},\n\t\t{key: \"other-key\", val: \"def\", want: nil},\n\t}\n\tfor _, tc := range cases {\n\t\textra := make(map[string]interface{})\n\t\textra[tc.key] = tc.val\n\t\ttok := &Token{raw: extra}\n\t\tif got, want := tok.Extra(key), tc.want; got != want {\n\t\t\tt.Errorf(\"Extra(%q) = %q; want %q\", key, got, want)\n\t\t}\n\t}\n}\n\nfunc TestTokenExpiry(t *testing.T) {\n\tnow := time.Now()\n\ttimeNow = func() time.Time { return now }\n\tdefer func() { timeNow = time.Now }()\n\n\tcases := []struct {\n\t\tname string\n\t\ttok  *Token\n\t\twant bool\n\t}{\n\t\t{name: \"12 seconds\", tok: &Token{Expiry: now.Add(12 * time.Second)}, want: false},\n\t\t{name: \"10 seconds\", tok: &Token{Expiry: now.Add(defaultExpiryDelta)}, want: false},\n\t\t{name: \"10 seconds-1ns\", tok: &Token{Expiry: now.Add(defaultExpiryDelta - 1*time.Nanosecond)}, want: true},\n\t\t{name: \"-1 hour\", tok: &Token{Expiry: now.Add(-1 * time.Hour)}, want: true},\n\t\t{name: \"12 seconds, custom expiryDelta\", tok: &Token{Expiry: now.Add(12 * time.Second), expiryDelta: time.Second * 5}, want: false},\n\t\t{name: \"5 seconds, custom expiryDelta\", tok: &Token{Expiry: now.Add(time.Second * 5), expiryDelta: time.Second * 5}, want: false},\n\t\t{name: \"5 seconds-1ns, custom expiryDelta\", tok: &Token{Expiry: now.Add(time.Second*5 - 1*time.Nanosecond), expiryDelta: time.Second * 5}, want: true},\n\t\t{name: \"-1 hour, custom expiryDelta\", tok: &Token{Expiry: now.Add(-1 * time.Hour), expiryDelta: time.Second * 5}, want: true},\n\t}\n\tfor _, tc := range cases {\n\t\tif got, want := tc.tok.expired(), tc.want; got != want {\n\t\t\tt.Errorf(\"expired (%q) = %v; want %v\", tc.name, got, want)\n\t\t}\n\t}\n}\n\nfunc TestTokenTypeMethod(t *testing.T) {\n\tcases := []struct {\n\t\tname string\n\t\ttok  *Token\n\t\twant string\n\t}{\n\t\t{name: \"bearer-mixed_case\", tok: &Token{TokenType: \"beAREr\"}, want: \"Bearer\"},\n\t\t{name: \"default-bearer\", tok: &Token{}, want: \"Bearer\"},\n\t\t{name: \"basic\", tok: &Token{TokenType: \"basic\"}, want: \"Basic\"},\n\t\t{name: \"basic-capitalized\", tok: &Token{TokenType: \"Basic\"}, want: \"Basic\"},\n\t\t{name: \"mac\", tok: &Token{TokenType: \"mac\"}, want: \"MAC\"},\n\t\t{name: \"mac-caps\", tok: &Token{TokenType: \"MAC\"}, want: \"MAC\"},\n\t\t{name: \"mac-mixed_case\", tok: &Token{TokenType: \"mAc\"}, want: \"MAC\"},\n\t}\n\tfor _, tc := range cases {\n\t\tif got, want := tc.tok.Type(), tc.want; got != want {\n\t\t\tt.Errorf(\"TokenType(%q) = %v; want %v\", tc.name, got, want)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "transport.go",
          "type": "blob",
          "size": 2.3466796875,
          "content": "// Copyright 2014 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage oauth2\n\nimport (\n\t\"errors\"\n\t\"log\"\n\t\"net/http\"\n\t\"sync\"\n)\n\n// Transport is an http.RoundTripper that makes OAuth 2.0 HTTP requests,\n// wrapping a base RoundTripper and adding an Authorization header\n// with a token from the supplied Sources.\n//\n// Transport is a low-level mechanism. Most code will use the\n// higher-level Config.Client method instead.\ntype Transport struct {\n\t// Source supplies the token to add to outgoing requests'\n\t// Authorization headers.\n\tSource TokenSource\n\n\t// Base is the base RoundTripper used to make HTTP requests.\n\t// If nil, http.DefaultTransport is used.\n\tBase http.RoundTripper\n}\n\n// RoundTrip authorizes and authenticates the request with an\n// access token from Transport's Source.\nfunc (t *Transport) RoundTrip(req *http.Request) (*http.Response, error) {\n\treqBodyClosed := false\n\tif req.Body != nil {\n\t\tdefer func() {\n\t\t\tif !reqBodyClosed {\n\t\t\t\treq.Body.Close()\n\t\t\t}\n\t\t}()\n\t}\n\n\tif t.Source == nil {\n\t\treturn nil, errors.New(\"oauth2: Transport's Source is nil\")\n\t}\n\ttoken, err := t.Source.Token()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq2 := cloneRequest(req) // per RoundTripper contract\n\ttoken.SetAuthHeader(req2)\n\n\t// req.Body is assumed to be closed by the base RoundTripper.\n\treqBodyClosed = true\n\treturn t.base().RoundTrip(req2)\n}\n\nvar cancelOnce sync.Once\n\n// CancelRequest does nothing. It used to be a legacy cancellation mechanism\n// but now only it only logs on first use to warn that it's deprecated.\n//\n// Deprecated: use contexts for cancellation instead.\nfunc (t *Transport) CancelRequest(req *http.Request) {\n\tcancelOnce.Do(func() {\n\t\tlog.Printf(\"deprecated: golang.org/x/oauth2: Transport.CancelRequest no longer does anything; use contexts\")\n\t})\n}\n\nfunc (t *Transport) base() http.RoundTripper {\n\tif t.Base != nil {\n\t\treturn t.Base\n\t}\n\treturn http.DefaultTransport\n}\n\n// cloneRequest returns a clone of the provided *http.Request.\n// The clone is a shallow copy of the struct and its Header map.\nfunc cloneRequest(r *http.Request) *http.Request {\n\t// shallow copy of the struct\n\tr2 := new(http.Request)\n\t*r2 = *r\n\t// deep copy of the Header\n\tr2.Header = make(http.Header, len(r.Header))\n\tfor k, s := range r.Header {\n\t\tr2.Header[k] = append([]string(nil), s...)\n\t}\n\treturn r2\n}\n"
        },
        {
          "name": "transport_test.go",
          "type": "blob",
          "size": 3.98046875,
          "content": "package oauth2\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype tokenSource struct{ token *Token }\n\nfunc (t *tokenSource) Token() (*Token, error) {\n\treturn t.token, nil\n}\n\nfunc TestTransportNilTokenSource(t *testing.T) {\n\ttr := &Transport{}\n\tserver := newMockServer(func(w http.ResponseWriter, r *http.Request) {})\n\tdefer server.Close()\n\tclient := &http.Client{Transport: tr}\n\tresp, err := client.Get(server.URL)\n\tif err == nil {\n\t\tt.Errorf(\"got no errors, want an error with nil token source\")\n\t}\n\tif resp != nil {\n\t\tt.Errorf(\"Response = %v; want nil\", resp)\n\t}\n}\n\ntype readCloseCounter struct {\n\tCloseCount int\n\tReadErr    error\n}\n\nfunc (r *readCloseCounter) Read(b []byte) (int, error) {\n\treturn 0, r.ReadErr\n}\n\nfunc (r *readCloseCounter) Close() error {\n\tr.CloseCount++\n\treturn nil\n}\n\nfunc TestTransportCloseRequestBody(t *testing.T) {\n\ttr := &Transport{}\n\tserver := newMockServer(func(w http.ResponseWriter, r *http.Request) {})\n\tdefer server.Close()\n\tclient := &http.Client{Transport: tr}\n\tbody := &readCloseCounter{\n\t\tReadErr: errors.New(\"readCloseCounter.Read not implemented\"),\n\t}\n\tresp, err := client.Post(server.URL, \"application/json\", body)\n\tif err == nil {\n\t\tt.Errorf(\"got no errors, want an error with nil token source\")\n\t}\n\tif resp != nil {\n\t\tt.Errorf(\"Response = %v; want nil\", resp)\n\t}\n\tif expected := 1; body.CloseCount != expected {\n\t\tt.Errorf(\"Body was closed %d times, expected %d\", body.CloseCount, expected)\n\t}\n}\n\nfunc TestTransportCloseRequestBodySuccess(t *testing.T) {\n\ttr := &Transport{\n\t\tSource: StaticTokenSource(&Token{\n\t\t\tAccessToken: \"abc\",\n\t\t}),\n\t}\n\tserver := newMockServer(func(w http.ResponseWriter, r *http.Request) {})\n\tdefer server.Close()\n\tclient := &http.Client{Transport: tr}\n\tbody := &readCloseCounter{\n\t\tReadErr: io.EOF,\n\t}\n\tresp, err := client.Post(server.URL, \"application/json\", body)\n\tif err != nil {\n\t\tt.Errorf(\"got error %v; expected none\", err)\n\t}\n\tif resp == nil {\n\t\tt.Errorf(\"Response is nil; expected non-nil\")\n\t}\n\tif expected := 1; body.CloseCount != expected {\n\t\tt.Errorf(\"Body was closed %d times, expected %d\", body.CloseCount, expected)\n\t}\n}\n\nfunc TestTransportTokenSource(t *testing.T) {\n\tts := &tokenSource{\n\t\ttoken: &Token{\n\t\t\tAccessToken: \"abc\",\n\t\t},\n\t}\n\ttr := &Transport{\n\t\tSource: ts,\n\t}\n\tserver := newMockServer(func(w http.ResponseWriter, r *http.Request) {\n\t\tif got, want := r.Header.Get(\"Authorization\"), \"Bearer abc\"; got != want {\n\t\t\tt.Errorf(\"Authorization header = %q; want %q\", got, want)\n\t\t}\n\t})\n\tdefer server.Close()\n\tclient := &http.Client{Transport: tr}\n\tres, err := client.Get(server.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tres.Body.Close()\n}\n\n// Test for case-sensitive token types, per https://github.com/golang/oauth2/issues/113\nfunc TestTransportTokenSourceTypes(t *testing.T) {\n\tconst val = \"abc\"\n\ttests := []struct {\n\t\tkey  string\n\t\tval  string\n\t\twant string\n\t}{\n\t\t{key: \"bearer\", val: val, want: \"Bearer abc\"},\n\t\t{key: \"mac\", val: val, want: \"MAC abc\"},\n\t\t{key: \"basic\", val: val, want: \"Basic abc\"},\n\t}\n\tfor _, tc := range tests {\n\t\tts := &tokenSource{\n\t\t\ttoken: &Token{\n\t\t\t\tAccessToken: tc.val,\n\t\t\t\tTokenType:   tc.key,\n\t\t\t},\n\t\t}\n\t\ttr := &Transport{\n\t\t\tSource: ts,\n\t\t}\n\t\tserver := newMockServer(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tif got, want := r.Header.Get(\"Authorization\"), tc.want; got != want {\n\t\t\t\tt.Errorf(\"Authorization header (%q) = %q; want %q\", val, got, want)\n\t\t\t}\n\t\t})\n\t\tdefer server.Close()\n\t\tclient := &http.Client{Transport: tr}\n\t\tres, err := client.Get(server.URL)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tres.Body.Close()\n\t}\n}\n\nfunc TestTokenValidNoAccessToken(t *testing.T) {\n\ttoken := &Token{}\n\tif token.Valid() {\n\t\tt.Errorf(\"got valid with no access token; want invalid\")\n\t}\n}\n\nfunc TestExpiredWithExpiry(t *testing.T) {\n\ttoken := &Token{\n\t\tExpiry: time.Now().Add(-5 * time.Hour),\n\t}\n\tif token.Valid() {\n\t\tt.Errorf(\"got valid with expired token; want invalid\")\n\t}\n}\n\nfunc newMockServer(handler func(w http.ResponseWriter, r *http.Request)) *httptest.Server {\n\treturn httptest.NewServer(http.HandlerFunc(handler))\n}\n"
        },
        {
          "name": "twitch",
          "type": "tree",
          "content": null
        },
        {
          "name": "uber",
          "type": "tree",
          "content": null
        },
        {
          "name": "vk",
          "type": "tree",
          "content": null
        },
        {
          "name": "yahoo",
          "type": "tree",
          "content": null
        },
        {
          "name": "yandex",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}