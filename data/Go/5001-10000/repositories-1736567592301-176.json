{
  "metadata": {
    "timestamp": 1736567592301,
    "page": 176,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "twitchtv/twirp",
      "stars": 7238,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0419921875,
          "content": "*.test\nnpm-debug.log\n\n/bin\n/release\n/build\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.1083984375,
          "content": "sudo: false\nlanguage: go\ngo:\n- 1.13.x\n- 1.14.x\n- 1.15.x\n- tip\nscript:\n- go install ./...\n- go test -race ./...\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 5.7451171875,
          "content": "# Contributing\n\nThanks for helping make Twirp better! This is great!\n\n## Twirp Design Principles\n\nContributions to Twirp should align with the project’s design principles:\n\n- Maintain backwards compatibility. Twirp has been in production at Twitch since 2016 and released to the public in January 2018. It is currently used by many companies and individuals with a variety of needs. There must be a compelling use-case and solid reasoning behind a major version upgrade.\n- Simple wire protocol and minimal public API. Fewer things in the core means fewer things to break. In addition, it ensures lower friction updates and easier to maintain implementations in other languages.\n- Avoid surprising behavior. For instance, mechanisms that can alter a program’s control flow in a surprising way (such as middleware or observability hooks) should be treated with caution.\n- Prefer pragmatism over bleeding-edge. Users should be able to deploy and accept updates to Twirp even if they are conservative on updating its dependencies. This includes Go, the protobuf compiler and runtime libraries, and the HTTP protocol.\n- Keep configuration to a minimum. For example: avoid adding flags to code generation commands, so that generated code is predictable across versions and platforms.\n- Limit dependencies where possible, so that they are easier to integrate and upgrade.\n- Prefer generated code over shared libraries between services and clients, so that it is easier to implement changes without forcing a lock-step upgrade across the ecosystem.\n\nExamples of contributions that should be addressed with high priority:\n\n- Security updates.\n- Performance improvements.\n- Supporting new versions of key dependencies such as Go and Protobuf.\n- Documentation.\n- Making Twirp easier to integrate with other tools.\n\n## Report an Issue\n\nIf you have run into a bug or want to discuss a new feature, please [file an issue](https://github.com/twitchtv/twirp/issues). If you'd rather not publicly discuss the issue, please email security@twitch.tv.\n\n## Contributing Code with Pull Requests\n\nTwirp uses github pull requests. Fork, hack away at your changes and submit. Most pull requests will go through a few iterations before they get merged. Different contributors will sometimes have different opinions, and often patches will need to be revised before they can get merged.\n\n### Requirements\n\n- Add tests that cover your contribution. Overall code coverage should not decrease.\n- Twirp officially supports the last 3 releases of Go.\n- Protobuf version 3.x.x to generate code with the protoc command.\n- For linters and other tools, we use [retool](https://github.com/twitchtv/retool). If `make setup` is not able to install it, you can install it in your path with `go get github.com/twitchtv/retool` and then install tools with `retool build`.\n\n### Running tests\n\nGenerally you want to make changes and run `make`, which will install all\ndependencies we know about, build the core, and run tests. A few notes:\n\n- Clone the repo on `$GOPATH/src/github.com/twitchtv/twirp` (go modules not supported yet).\n- Run Go unit tests with `make test`.\n- Most tests of the Go server are in `internal/twirptest/service_test.go`.\n- Integration tests running the full stack in Go are in the [clientcompat](./clientcompat) directory.\n\n## Contributing Documentation\n\nTwirp's docs are generated with [Docusaurus](https://docusaurus.io/). You can safely edit anything inside the [docs](./docs) directory, adding new pages or editing them. You can edit the sidebar by editing [website/sidebars.json](./website/sidebars.json).\n\nTo render and review your changes, run docusaurus's local server. See [Install docusaurus on your machine](https://docusaurus.io/docs/en/installation.html).\n\n1. `cd website`\n2. `npm install`\n3. `npm start`\n4. Navigate to http://localhost:3000/twirp to see how it looks.\n\nPublish the new docs on the `gh-pages` branch. See [this guide](https://docusaurus.io/docs/en/tutorial-publish-site) for details.\n\n```\nGIT_USER=<your-github-username> CURRENT_BRANCH=gh-pages USE_SSH=true npm run publish-gh-pages\n```\n\n## Making a New Release\n\nReleasing versions is the responsibility of the core maintainers. Most people\ncan skip this section.\n\nTwirp uses GitHub releases. To make a new release:\n\n1.  Merge all changes that should be included in the release into the main branch.\n2.  Update the version constant in `internal/gen/version.go`. Please respect [semantic versioning](http://semver.org/): `v<major>.<minor>.<patch>`.\n3.  Run `make test_all` to re-generate code and run tests. Check that generated test files include the new version in the header comment.\n4.  Add a new commit to main with a message like \"Version vX.X.X release\" and push.\n5.  Tag the commit you just made: `git tag vX.X.X` and `git push origin --tags`.\n6.  Go to GitHub https://github.com/twitchtv/twirp/releases and \"Draft a new release\".\n7.  Make sure that all new functionality is properly documented, on code comments, PR description, and include links and/or upgrade instructions on the release. For example the [v7 release](https://github.com/twitchtv/twirp/releases/tag/v7.0.0). Minor releases can just include a link to the PR/PRs that were merged included into the release.\n\n## Code of Conduct\n\nThis project has adopted the [Amazon Open Source Code of Conduct](https://aws.github.io/code-of-conduct).\nFor more information see the [Code of Conduct FAQ](https://aws.github.io/code-of-conduct-faq) or contact\nopensource-codeofconduct@amazon.com with any additional questions or comments.\n\n## Licensing\n\nSee the [LICENSE](https://github.com/twitchtv/twirp/blob/main/LICENSE) file for our project's licensing. We will ask you to confirm the licensing of your contribution.\n\nWe may ask you to sign a [Contributor License Agreement (CLA)](http://en.wikipedia.org/wiki/Contributor_License_Agreement) for larger changes.\n"
        },
        {
          "name": "Gopkg.lock",
          "type": "blob",
          "size": 2.74609375,
          "content": "# This file is autogenerated, do not edit; changes may be undone by the next 'dep ensure'.\n\n\n[[projects]]\n  digest = \"1:a2c1d0e43bd3baaa071d1b9ed72c27d78169b2b269f71c105ac4ba34b1be4a39\"\n  name = \"github.com/davecgh/go-spew\"\n  packages = [\"spew\"]\n  pruneopts = \"NUT\"\n  revision = \"346938d642f2ec3594ed81d874461961cd0faa76\"\n  version = \"v1.1.0\"\n\n[[projects]]\n  digest = \"1:5cf3f025cbee5951a4ee961de067c8a89fc95a5adabead774f82822efabab121\"\n  name = \"github.com/pkg/errors\"\n  packages = [\".\"]\n  pruneopts = \"NUT\"\n  revision = \"645ef00459ed84a119197bfb8d8205042c6df63d\"\n  version = \"v0.8.0\"\n\n[[projects]]\n  digest = \"1:0028cb19b2e4c3112225cd871870f2d9cf49b9b4276531f03438a88e94be86fe\"\n  name = \"github.com/pmezard/go-difflib\"\n  packages = [\"difflib\"]\n  pruneopts = \"NUT\"\n  revision = \"792786c7400a136282c1664665ae0a8db921c6c2\"\n  version = \"v1.0.0\"\n\n[[projects]]\n  digest = \"1:be7d615463b5c9c5fd732a3cc028038e8643543def6e55344b52a3a4dbb667a3\"\n  name = \"github.com/stretchr/testify\"\n  packages = [\n    \"assert\",\n    \"require\",\n  ]\n  pruneopts = \"NUT\"\n  revision = \"b91bfb9ebec76498946beb6af7c0230c7cc7ba6c\"\n  version = \"v1.2.0\"\n\n[[projects]]\n  digest = \"1:acaa96db5d83347d36134c23782eda554b73fb1ac5915bbcb39c67d9a168db00\"\n  name = \"google.golang.org/protobuf\"\n  packages = [\n    \"encoding/protojson\",\n    \"encoding/prototext\",\n    \"encoding/protowire\",\n    \"internal/descfmt\",\n    \"internal/descopts\",\n    \"internal/detrand\",\n    \"internal/encoding/defval\",\n    \"internal/encoding/json\",\n    \"internal/encoding/messageset\",\n    \"internal/encoding/tag\",\n    \"internal/encoding/text\",\n    \"internal/errors\",\n    \"internal/filedesc\",\n    \"internal/filetype\",\n    \"internal/flags\",\n    \"internal/genid\",\n    \"internal/impl\",\n    \"internal/order\",\n    \"internal/pragma\",\n    \"internal/set\",\n    \"internal/strs\",\n    \"internal/version\",\n    \"proto\",\n    \"reflect/protoreflect\",\n    \"reflect/protoregistry\",\n    \"runtime/protoiface\",\n    \"runtime/protoimpl\",\n    \"types/descriptorpb\",\n    \"types/known/emptypb\",\n    \"types/known/wrapperspb\",\n    \"types/pluginpb\",\n  ]\n  pruneopts = \"NUT\"\n  revision = \"f2d1f6cbe10b90d22296ea09a7217081c2798009\"\n  version = \"v1.26.0\"\n\n[solve-meta]\n  analyzer-name = \"dep\"\n  analyzer-version = 1\n  input-imports = [\n    \"github.com/pkg/errors\",\n    \"github.com/stretchr/testify/assert\",\n    \"github.com/stretchr/testify/require\",\n    \"google.golang.org/protobuf/encoding/protojson\",\n    \"google.golang.org/protobuf/proto\",\n    \"google.golang.org/protobuf/reflect/protoreflect\",\n    \"google.golang.org/protobuf/runtime/protoimpl\",\n    \"google.golang.org/protobuf/types/descriptorpb\",\n    \"google.golang.org/protobuf/types/known/emptypb\",\n    \"google.golang.org/protobuf/types/known/wrapperspb\",\n    \"google.golang.org/protobuf/types/pluginpb\",\n  ]\n  solver-name = \"gps-cdcl\"\n  solver-version = 1\n"
        },
        {
          "name": "Gopkg.toml",
          "type": "blob",
          "size": 0.732421875,
          "content": "# The importable parts of Twirp have no external dependencies. They just use the\n# standard library. But both protoc-gen-twirp and Twirp's tests *do* have some\n# dependencies, and this manifest lists them.\n#\n# All dependencies are specified as overrides, not constraints, so that dep\n# doesn't get confused if someone imports Twirp. We don't want to falsely\n# require any particular versions of these libraries - they are *only* for\n# tests and building main packages.\n\n[[override]]\n  name = \"google.golang.org/protobuf\"\n  version = \"1.26.0\"\n\n[[override]]\n  name = \"github.com/pkg/errors\"\n  version = \"0.8.0\"\n\n[[override]]\n  name = \"github.com/stretchr/testify\"\n  version = \"1.2.0\"\n\n[prune]\n  unused-packages = true\n  go-tests = true\n  non-go = true\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.091796875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.7236328125,
          "content": "PATH := ${PWD}/_tools/bin:${PWD}/bin:${PATH}\nexport GO111MODULE=off\n\nall: setup test_all\n\n.PHONY: setup generate test_all test test_clientcompat\n\nsetup:\n\t./check_protoc_version.sh\n\tGOPATH=\"$$PWD/_tools\" GOBIN=\"$$PWD/_tools/bin\" go get github.com/twitchtv/retool\n\t./_tools/bin/retool build\n\ngenerate:\n\t# Recompile and install generator\n\tGOBIN=\"$$PWD/bin\" go install -v ./protoc-gen-twirp\n\t# Generate code from go:generate comments\n\tgo generate ./...\n\ntest_all: setup test test_clientcompat\n\ntest: generate\n\t./_tools/bin/errcheck ./internal/twirptest\n\tgo test -race ./...\n\ntest_clientcompat: generate\n\tGOBIN=\"$$PWD/bin\" go install ./clientcompat\n\tGOBIN=\"$$PWD/bin\" go install ./clientcompat/gocompat\n\t./bin/clientcompat -client ./bin/gocompat\n"
        },
        {
          "name": "NOTICE",
          "type": "blob",
          "size": 0.0673828125,
          "content": "Twirp\nCopyright 2018 Twitch Interactive, Inc.  All Rights Reserved. \n"
        },
        {
          "name": "PROTOCOL.md",
          "type": "blob",
          "size": 8.48828125,
          "content": "# Twirp Wire Protocol\n\nThis document defines the Twirp wire protocol over HTTP. The\ncurrent protocol version is v7.\n\n## Overview\n\nThe Twirp wire protocol is a simple RPC protocol based on HTTP and\nProtocol Buffers (proto). The protocol uses HTTP URLs to specify the\nRPC endpoints, and sends/receives proto messages as HTTP\nrequest/response bodies.\n\nTo use Twirp, developers first define their APIs using proto files,\nthen use Twirp tools to generate the client and the server libraries.\nThe generated libraries implement the Twirp wire protocol, using the\nstandard HTTP library provided by the programming language runtime or\nthe operating system. Once the client and the server are implemented,\nthe client can communicate with the server by making RPC calls.\n\nThe Twirp wire protocol supports both binary and JSON encodings of\nproto messages, and works with any HTTP client and any HTTP version.\n\n### URLs\n\nIn [ABNF syntax](https://tools.ietf.org/html/rfc5234), Twirp's URLs\nhave the following format:\n\n```abnf\nURL ::= Base-URL [ Prefix ] \"/\" [ Package \".\" ] Service \"/\" Method\n```\n\nThe Twirp wire protocol uses HTTP URLs to specify the RPC\nendpoints on the server for sending the requests. Such direct mapping\nmakes the request routing simple and efficient. The Twirp URLs have\nthe following components.\n\n* **Base-URL** is the virtual location of a Twirp API server, which is\n  typically published via API documentation or service discovery.\n  Currently, it should only contain URL `scheme` and `authority`. For\n  example, \"https://example.com\".\n* **Prefix** is usually \"/twirp\", but it could be empty \"\", or an\n  arbitrary path like \"/my/custom/prefix\".\n* **Package** is the proto `package` name for an API, which is often\n  considered as an API version. For example,\n  `example.calendar.v1`. This component is omitted if the API\n  definition doesn't have a package name.\n* **Service** is the proto `service` name for an API. For example,\n  `CalendarService`.\n* **Method** is the proto `rpc` name for an API method. For example,\n  `CreateEvent`.\n\n### Requests\n\nTwirp always uses HTTP POST method to send requests, because it\nclosely matches the semantics of RPC methods.\n\nThe **Request-Headers** are normal HTTP headers. The Twirp wire\nprotocol uses the following headers.\n\n* **Content-Type** header indicates the proto message encoding, which\n  should be one of \"application/protobuf\", \"application/json\". The\n  server uses this value to decide how to parse the request body,\n  and encode the response body.\n\nThe **Request-Body** is the encoded request message, contained in the\nHTTP request body. The encoding is specified by the `Content-Type`\nheader.\n\n### Responses\n\nThe **Response-Headers** are just normal HTTP response headers. The\nTwirp wire protocol uses the following headers.\n\n* **Content-Type** The value should be either \"application/protobuf\"\n  or \"application/json\" to indicate the encoding of the response\n  message. It must match the \"Content-Type\" header in the request.\n\nThe **Request-Body** is the encoded response message contained in the\nHTTP response body. The encoding is specified by the `Content-Type`\nheader.\n\n### Example\n\nThe following example shows a simple Echo API definition and its\ncorresponding wire payloads.\n\nThe example assumes the server base URL is \"https://example.com\".\n\n```proto\nsyntax = \"proto3\";\n\npackage example.echoer;\n\nservice Echo {\n  rpc Hello(HelloRequest) returns (HelloResponse);\n}\n\nmessage HelloRequest {\n  string message;\n}\n\nmessage HelloResponse {\n  string message;\n}\n```\n\n**Proto Request**\n\n```\nPOST /twirp/example.echoer.Echo/Hello HTTP/1.1\nHost: example.com\nContent-Type: application/protobuf\nContent-Length: 15\n\n<encoded HelloRequest>\n```\n\n**JSON Request**\n\n```\nPOST /twirp/example.echoer.Echo/Hello HTTP/1.1\nHost: example.com\nContent-Type: application/json\nContent-Length: 27\n\n{\"message\":\"Hello, World!\"}\n```\n\n**Proto Response**\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/protobuf\nContent-Length: 15\n\n<encoded HelloResponse>\n```\n\n**JSON Response**\n\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 27\n\n{\"message\":\"Hello, World!\"}\n```\n\n\n## Errors\n\nTwirp error responses are always JSON-encoded, regardless of\nthe request's Content-Type, with a corresponding\n`Content-Type: application/json` header. This ensures that\nthe errors are human-readable in any setting.\n\nTwirp errors are a JSON object with the keys:\n\n* **code**: One of the Twirp error codes as a string.\n* **msg**: A human-readable message describing the error\n  as a string.\n* **meta**: (optional) An object with string values holding\n  arbitrary additional metadata describing the error.\n\nExample:\n\n```json\n{\n  \"code\": \"internal\",\n  \"msg\": \"Something went wrong\"\n}\n```\n\nExample with metadata:\n\n```json\n{\n  \"code\": \"permission_denied\",\n  \"msg\": \"Thou shall not pass\",\n  \"meta\": {\n    \"target\": \"Balrog\",\n    \"power\": \"999\"\n  }\n}\n```\n\n### Error Codes\n\nTwirp errors always include an error code. This code is represented\nas a string and must be one of a fixed set of codes, listed in the\ntable below. Each code has an associated HTTP Status Code. When a\nserver responds with the given error code, it must set the\ncorresponding HTTP Status Code for the response.\n\n| Twirp Error Code    | HTTP Status | Description\n| ------------------- | ----------- | -----------\n| canceled            | 408 | The operation was cancelled.\n| unknown             | 500 | An unknown error occurred. For example, this can be used when handling errors raised by APIs that do not return any error information.\n| invalid_argument    | 400 | The client specified an invalid argument. This indicates arguments that are invalid regardless of the state of the system (i.e. a malformed file name, required argument, number out of range, etc.).\n| malformed           | 400 | The client sent a message which could not be decoded. This may mean that the message was encoded improperly or that the client and server have incompatible message definitions.\n| deadline_exceeded   | 408 | Operation expired before completion. For operations that change the state of the system, this error may be returned even if the operation has completed successfully (timeout).\n| not_found           | 404 | Some requested entity was not found.\n| bad_route           | 404 | The requested URL path wasn't routable to a Twirp service and method. This is returned by generated server code and should not be returned by application code (use \"not_found\" or \"unimplemented\" instead).\n| already_exists      | 409 | An attempt to create an entity failed because one already exists.\n| permission_denied   | 403 | The caller does not have permission to execute the specified operation. It must not be used if the caller cannot be identified (use \"unauthenticated\" instead).\n| unauthenticated     | 401 | The request does not have valid authentication credentials for the operation.\n| resource_exhausted  | 429 | Some resource has been exhausted or rate-limited, perhaps a per-user quota, or perhaps the entire file system is out of space.\n| failed_precondition | 412 | The operation was rejected because the system is not in a state required for the operation's execution. For example, doing an rmdir operation on a directory that is non-empty, or on a non-directory object, or when having conflicting read-modify-write on the same resource.\n| aborted             | 409 | The operation was aborted, typically due to a concurrency issue like sequencer check failures, transaction aborts, etc.\n| out_of_range        | 400 | The operation was attempted past the valid range. For example, seeking or reading past end of a paginated collection. Unlike \"invalid_argument\", this error indicates a problem that may be fixed if the system state changes (i.e. adding more items to the collection). There is a fair bit of overlap between \"failed_precondition\" and \"out_of_range\". We recommend using \"out_of_range\" (the more specific error) when it applies so that callers who are iterating through a space can easily look for an \"out_of_range\" error to detect when they are done.\n| unimplemented       | 501 | The operation is not implemented or not supported/enabled in this service.\n| internal            | 500 | When some invariants expected by the underlying system have been broken. In other words, something bad happened in the library or backend service. Twirp specific issues like wire and serialization problems are also reported as \"internal\" errors.\n| unavailable         | 503 | The service is currently unavailable. This is most likely a transient condition and may be corrected by retrying with a backoff.\n| data_loss            | 500 | The operation resulted in unrecoverable data loss or corruption.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.78125,
          "content": "![Twirp Logo](./logo.png) [![Build Status](https://travis-ci.org/twitchtv/twirp.svg?branch=main)](https://travis-ci.org/twitchtv/twirp) [![Go Report Card](https://goreportcard.com/badge/github.com/twitchtv/twirp)](https://goreportcard.com/report/github.com/twitchtv/twirp) [![GoDoc](https://godoc.org/github.com/twitchtv/twirp?status.svg)](https://godoc.org/github.com/twitchtv/twirp)\n\n---\n\nTwirp is a framework for service-to-service communication emphasizing simplicity\nand minimalism. It generates routing and serialization from API definition files\nand lets you focus on your application's logic instead of thinking about\nfolderol like HTTP methods and paths and JSON.\n\nTwirp is similar to [gRPC](http://www.grpc.io/), but without the custom\nHTTP server and transport implementations: it runs on the standard library's\nextremely-well-tested-and-high-performance `net/http` Server. It can run on HTTP\n1.1, not just http/2, and supports JSON serialization for easy debugging.\n\nAlong the way, you get autogenerated clients and a simple, smart framework for\npassing error messages. Nice!\n\nRead more about the motivation behind on the [announcement blog post](https://blog.twitch.tv/en/2018/01/16/twirp-a-sweet-new-rpc-framework-for-go-5f2febbf35f/).\n\n### Documentation\n\n * [Getting Started](https://twitchtv.github.io/twirp/docs/intro.html)\n * [Usage Example](https://twitchtv.github.io/twirp/docs/example.html)\n * [Errors](https://twitchtv.github.io/twirp/docs/errors.html)\n * More: https://twitchtv.github.io/twirp/\n\n### Implementations in other languages\n\nThis repo contains the generator and runtime library for the Go implementation.\n\nHere is a list of some third-party implementations in other languages.\n\n|    Language    | Clients | Servers | Repository |\n|----------------|---------|---------|------------|\n| **Crystal**    |    ✓    |    ✓    | [github.com/mloughran/twirp.cr](https://github.com/mloughran/twirp.cr)\n| **Dart**       |    ✓    |         | [github.com/apptreesoftware/protoc-gen-twirp_dart](https://github.com/apptreesoftware/protoc-gen-twirp_dart)\n| **Elixir**     |    ✓    |    ✓    | [github.com/keathley/twirp-elixir](https://github.com/keathley/twirp-elixir)\n| **Java**       |    ✓    |    ✓    | [github.com/fajran/protoc-gen-twirp_java_jaxrs](https://github.com/fajran/protoc-gen-twirp_java_jaxrs)\n| **Java**       |         |    ✓    | [github.com/devork/flit](https://github.com/devork/flit)\n| **Java**       |         |    ✓    | [github.com/github/flit](https://github.com/github/flit)\n| **JavaScript** |    ✓    |         | [github.com/thechriswalker/protoc-gen-twirp_js](https://github.com/thechriswalker/protoc-gen-twirp_js)\n| **JavaScript** |    ✓    |         | [github.com/Xe/twirp-codegens/cmd/protoc-gen-twirp_jsbrowser](https://github.com/Xe/twirp-codegens)\n| **JavaScript** |    ✓    |    ✓    | [github.com/tatethurston/TwirpScript](https://github.com/tatethurston/TwirpScript)\n| **Kotlin**     |    ✓    |         | [github.com/collectiveidea/twirp-kmm](https://github.com/collectiveidea/twirp-kmm)\n| **PHP**        |    ✓    |    ✓    | [github.com/twirphp/twirp](https://github.com/twirphp/twirp)\n| **Python3**    |    ✓    |    ✓    | [github.com/verloop/twirpy](https://github.com/verloop/twirpy)\n| **Ruby**       |    ✓    |    ✓    | [github.com/twitchtv/twirp-ruby](https://github.com/twitchtv/twirp-ruby)\n| **Rust**       |    ✓    |    ✓    | [github.com/sourcefrog/prost-twirp](https://github.com/sourcefrog/prost-twirp)\n| **Scala**      |    ✓    |    ✓    | [github.com/soundcloud/twinagle](https://github.com/soundcloud/twinagle)\n| **Swagger**    |    ✓    |    ✓    | [github.com/go-bridget/twirp-swagger-gen](https://github.com/go-bridget/twirp-swagger-gen)\n| **Swift**      |    ✓    |         | [github.com/CrazyHulk/protoc-gen-swiftwirp](https://github.com/CrazyHulk/protoc-gen-swiftwirp)\n| **Typescript** |    ✓    |    ✓    | [github.com/hopin-team/twirp-ts](https://github.com/hopin-team/twirp-ts)\n| **Typescript** |    ✓    |    ✓    | [github.com/tatethurston/TwirpScript](https://github.com/tatethurston/TwirpScript)\n| **Typescript** |    ✓    |    ✓    | [github.com/timostamm/protobuf-ts](https://github.com/timostamm/protobuf-ts)\n\n### Support and Community\n\nWe have a channel on the Gophers slack, [#twirp](https://gophers.slack.com/messages/twirp),\nwhich is the best place to get quick answers to your questions. You can join the\nGopher slack [here](https://invite.slack.golangbridge.org/).\n\n### Releases\n\nTwirp follows semantic versioning through git tags, and uses GitHub Releases for\nrelease notes and upgrade guides:\n[Twirp Releases](https://github.com/twitchtv/twirp/releases)\n\n### Contributing\n\nCheck out [CONTRIBUTING.md](./CONTRIBUTING.md) for notes on making contributions.\n\n### License\n\nThis library is licensed under the Apache 2.0 License.\n"
        },
        {
          "name": "THIRD_PARTY",
          "type": "blob",
          "size": 1.505859375,
          "content": "** Protobuf -- https://github.com/protocolbuffers/protobuf-go\nCopyright 2010 The Go Authors.  All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n    * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n"
        },
        {
          "name": "_tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "check_protoc_version.sh",
          "type": "blob",
          "size": 0.9736328125,
          "content": "#!/usr/bin/env bash\n\n# Copyright 2018 Twitch Interactive, Inc.  All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n# use this file except in compliance with the License. A copy of the License is\n# located at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# or in the \"license\" file accompanying this file. This file is distributed on\n# an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n# express or implied. See the License for the specific language governing\n# permissions and limitations under the License.\n\nwhich protoc\nPROTOC_EXISTS=$?\nif [ $PROTOC_EXISTS -eq 0 ]; then\n\tPROTOC_VERSION=`protoc --version`\n    if [[ $PROTOC_VERSION == \"libprotoc 3.\"* ]]; then\n        echo \"protoc version: $PROTOC_VERSION\"\n\t\texit 0\n\tfi\n\techo \"required protoc v3, but found: $PROTOC_VERSION\"\n\texit 1\nfi\necho \"Please install protoc v3. See https://grpc.io/docs/protoc-installation/, for example in MacOS: brew install protobuf\"\nexit 1\n"
        },
        {
          "name": "client_options.go",
          "type": "blob",
          "size": 6.9248046875,
          "content": "// Copyright 2018 Twitch Interactive, Inc.  All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n// use this file except in compliance with the License. A copy of the License is\n// located at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// or in the \"license\" file accompanying this file. This file is distributed on\n// an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n// express or implied. See the License for the specific language governing\n// permissions and limitations under the License.\npackage twirp\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"reflect\"\n)\n\n// ClientOption is a functional option for extending a Twirp client.\ntype ClientOption func(*ClientOptions)\n\n// WithClientHooks defines the hooks for a Twirp client.\nfunc WithClientHooks(hooks *ClientHooks) ClientOption {\n\treturn func(opts *ClientOptions) {\n\t\topts.Hooks = hooks\n\t}\n}\n\n// WithClientInterceptors defines the interceptors for a Twirp client.\nfunc WithClientInterceptors(interceptors ...Interceptor) ClientOption {\n\treturn func(opts *ClientOptions) {\n\t\topts.Interceptors = append(opts.Interceptors, interceptors...)\n\t}\n}\n\n// WithClientPathPrefix specifies a different prefix to use for routing.\n// If not specified, the \"/twirp\" prefix is used by default.\n// The service must be configured to serve on the same prefix.\n// An empty value \"\" can be specified to use no prefix.\n// URL format: \"<baseURL>[<prefix>]/<package>.<Service>/<Method>\"\n// More info on Twirp docs: https://twitchtv.github.io/twirp/docs/routing.html\nfunc WithClientPathPrefix(prefix string) ClientOption {\n\treturn func(opts *ClientOptions) {\n\t\topts.setOpt(\"pathPrefix\", prefix)\n\t\topts.pathPrefix = &prefix // for code generated before v8.1.0\n\t}\n}\n\n// WithClientLiteralURLs configures the Twirp client to use the exact values\n// as defined in the proto file for Service and Method names,\n// fixing the issue https://github.com/twitchtv/twirp/issues/244, which is manifested\n// when working with Twirp services implemented other languages (e.g. Python) and the proto file definitions\n// are not properly following the [Protobuf Style Guide](https://developers.google.com/protocol-buffers/docs/style#services).\n// By default (false), Go clients modify the routes by CamelCasing the values. For example,\n// with Service: `haberdasher`, Method: `make_hat`, the URLs generated by Go clients are `Haberdasher/MakeHat`,\n// but with this option enabled (true) the client will properly use `haberdasher/make_hat` instead.\nfunc WithClientLiteralURLs(b bool) ClientOption {\n\treturn func(opts *ClientOptions) {\n\t\topts.setOpt(\"literalURLs\", b)\n\t\topts.LiteralURLs = b // for code generated before v8.1.0\n\t}\n}\n\n// ClientHooks is a container for callbacks that can instrument a\n// Twirp-generated client. These callbacks all accept a context and some return\n// a context. They can use this to add to the context, appending values or\n// deadlines to it.\n//\n// The RequestPrepared hook is special because it can return errors. If it\n// returns non-nil error, handling for that request will be stopped at that\n// point. The Error hook will then be triggered.\n//\n// The RequestPrepared hook will always be called first and will be called for\n// each outgoing request from the Twirp client. The last hook to be called\n// will either be Error or ResponseReceived, so be sure to handle both cases in\n// your hooks.\ntype ClientHooks struct {\n\t// RequestPrepared is called as soon as a request has been created and before\n\t// it has been sent to the Twirp server.\n\tRequestPrepared func(context.Context, *http.Request) (context.Context, error)\n\n\t// ResponseReceived is called after a request has finished sending. Since this\n\t// is terminal, the context is not returned. ResponseReceived will not be\n\t// called in the case of an error being returned from the request.\n\tResponseReceived func(context.Context)\n\n\t// Error hook is called whenever an error occurs during the sending of a\n\t// request. The Error is passed as an argument to the hook.\n\tError func(context.Context, Error)\n}\n\n// ChainClientHooks creates a new *ClientHooks which chains the callbacks in\n// each of the constituent hooks passed in. Each hook function will be\n// called in the order of the ClientHooks values passed in.\n//\n// For the erroring hook, RequestPrepared, any returned\n// errors prevent processing by later hooks.\nfunc ChainClientHooks(hooks ...*ClientHooks) *ClientHooks {\n\tif len(hooks) == 0 {\n\t\treturn nil\n\t}\n\tif len(hooks) == 1 {\n\t\treturn hooks[0]\n\t}\n\treturn &ClientHooks{\n\t\tRequestPrepared: func(ctx context.Context, req *http.Request) (context.Context, error) {\n\t\t\tfor _, h := range hooks {\n\t\t\t\tif h != nil && h.RequestPrepared != nil {\n\t\t\t\t\tvar err error\n\t\t\t\t\tctx, err = h.RequestPrepared(ctx, req)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn ctx, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ctx, nil\n\t\t},\n\t\tResponseReceived: func(ctx context.Context) {\n\t\t\tfor _, h := range hooks {\n\t\t\t\tif h != nil && h.ResponseReceived != nil {\n\t\t\t\t\th.ResponseReceived(ctx)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tError: func(ctx context.Context, twerr Error) {\n\t\t\tfor _, h := range hooks {\n\t\t\t\tif h != nil && h.Error != nil {\n\t\t\t\t\th.Error(ctx, twerr)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t}\n}\n\n// ClientOptions encapsulate the configurable parameters on a Twirp client.\n// This type is meant to be used only by generated code.\ntype ClientOptions struct {\n\t// Untyped options map. The methods setOpt and ReadOpt are used to set\n\t// and read options. The options are untyped so when a new option is added,\n\t// newly generated code can still work with older versions of the runtime.\n\tm map[string]interface{}\n\n\tHooks        *ClientHooks\n\tInterceptors []Interceptor\n\n\t// Properties below are only used by code that was\n\t// generated by older versions of Twirp (before v8.1.0).\n\t// New options with standard types added in the future\n\t// don't need new properties, they should use ReadOpt.\n\tLiteralURLs bool\n\tpathPrefix  *string\n}\n\n// ReadOpt extracts an option to a pointer value,\n// returns true if the option exists and was extracted.\n// This method is meant to be used by generated code,\n// keeping the type dependency outside of the runtime.\n//\n// Usage example:\n//\n//     opts.setOpt(\"fooOpt\", 123)\n//     var foo int\n//     ok := opts.ReadOpt(\"fooOpt\", &int)\n//\nfunc (opts *ClientOptions) ReadOpt(key string, out interface{}) bool {\n\tval, ok := opts.m[key]\n\tif !ok {\n\t\treturn false\n\t}\n\n\trout := reflect.ValueOf(out)\n\tif rout.Kind() != reflect.Ptr {\n\t\tpanic(\"ReadOpt(key, out); out must be a pointer but it was not\")\n\t}\n\trout.Elem().Set(reflect.ValueOf(val))\n\treturn true\n}\n\n// setOpt adds an option key/value. It is used by ServerOption helpers.\n// The value can be extracted with ReadOpt by passing a pointer to the same type.\nfunc (opts *ClientOptions) setOpt(key string, val interface{}) {\n\tif opts.m == nil {\n\t\topts.m = make(map[string]interface{})\n\t}\n\topts.m[key] = val\n}\n\n// PathPrefix() is used only by clients generated before v8.1.0\nfunc (opts *ClientOptions) PathPrefix() string {\n\tif opts.pathPrefix == nil {\n\t\treturn \"/twirp\" // default prefix\n\t}\n\treturn *opts.pathPrefix\n}\n"
        },
        {
          "name": "client_options_test.go",
          "type": "blob",
          "size": 5.083984375,
          "content": "// Copyright 2018 Twitch Interactive, Inc.  All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n// use this file except in compliance with the License. A copy of the License is\n// located at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// or in the \"license\" file accompanying this file. This file is distributed on\n// an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n// express or implied. See the License for the specific language governing\n// permissions and limitations under the License.\n\npackage twirp\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestClientOptionsReadOpt(t *testing.T) {\n\topts := &ClientOptions{}\n\tok := false\n\n\tvar fooNum int\n\tok = opts.ReadOpt(\"fooNum\", &fooNum)\n\tif ok {\n\t\tt.Errorf(\"option 'fooNum' does not exist, opts.ReadOpt should have returned false\")\n\t}\n\n\topts.setOpt(\"fooNum\", 455)\n\tok = opts.ReadOpt(\"fooNum\", &fooNum)\n\tif !ok || fooNum != 455 {\n\t\tt.Errorf(\"option 'fooNum' expected to be 455\")\n\t}\n\n\tvar literalURLs bool\n\tok = opts.ReadOpt(\"literalURLs\", &literalURLs)\n\tif ok {\n\t\tt.Errorf(\"option 'literalURLs' does not exist, opts.ReadOpt should have returned false\")\n\t}\n\n\tWithClientLiteralURLs(true)(opts)\n\tok = opts.ReadOpt(\"literalURLs\", &literalURLs)\n\tif !ok || !literalURLs {\n\t\tt.Errorf(\"option 'literalURLs' expected to be true, ok: %v, val: %v\", ok, literalURLs)\n\t}\n\n\tWithClientLiteralURLs(false)(opts)\n\tok = opts.ReadOpt(\"literalURLs\", &literalURLs)\n\tif !ok || literalURLs {\n\t\tt.Errorf(\"option 'literalURLs' expected to be false, ok: %v, val: %v\", ok, literalURLs)\n\t}\n}\n\nfunc TestChainClientHooks(t *testing.T) {\n\tvar (\n\t\thook1 = new(ClientHooks)\n\t\thook2 = new(ClientHooks)\n\t\thook3 = new(ClientHooks)\n\n\t\tresponseReceivedCalled []string\n\t\terrorCalled            []string\n\t)\n\n\tconst key = \"key\"\n\n\thook1.RequestPrepared = func(ctx context.Context, req *http.Request) (context.Context, error) {\n\t\treturn context.WithValue(ctx, key, []string{\"hook1\"}), nil\n\t}\n\thook2.RequestPrepared = func(ctx context.Context, req *http.Request) (context.Context, error) {\n\t\tv := ctx.Value(key).([]string)\n\t\treturn context.WithValue(ctx, key, append(v, \"hook2\")), nil\n\t}\n\thook3.RequestPrepared = func(ctx context.Context, req *http.Request) (context.Context, error) {\n\t\tv := ctx.Value(key).([]string)\n\t\treturn context.WithValue(ctx, key, append(v, \"hook3\")), nil\n\t}\n\n\thook1.ResponseReceived = func(ctx context.Context) {\n\t\tresponseReceivedCalled = append(responseReceivedCalled, \"hook1\")\n\t}\n\n\thook2.Error = func(ctx context.Context, twerr Error) {\n\t\terrorCalled = append(errorCalled, \"hook2\")\n\t}\n\n\tchain := ChainClientHooks(hook1, hook2, hook3)\n\n\tctx := context.Background()\n\n\t// When all three chained hooks have a handler, all should be called in order.\n\twant := []string{\"hook1\", \"hook2\", \"hook3\"}\n\thaveCtx, err := chain.RequestPrepared(ctx, new(http.Request))\n\tif err != nil {\n\t\tt.Fatalf(\"RequestPrepared chain has unexpected err %v\", err)\n\t}\n\thave := haveCtx.Value(key)\n\tif !reflect.DeepEqual(have, want) {\n\t\tt.Errorf(\"RequestPrepared chain has unexpected ctx, have=%v, want=%v\", have, want)\n\t}\n\n\t// When only the first chained hook has a handler, it should be called, and\n\t// there should be no panic.\n\twant = []string{\"hook1\"}\n\tchain.ResponseReceived(ctx)\n\tif have := responseReceivedCalled; !reflect.DeepEqual(have, want) {\n\t\tt.Errorf(\"unexpected hooks called, have: %v, want: %v\", have, want)\n\t}\n\n\t// When only the second chained hook has a handler, it should be called, and\n\t// there should be no panic.\n\twant = []string{\"hook2\"}\n\tchain.Error(ctx, InternalError(\"whoops\"))\n\tif have := errorCalled; !reflect.DeepEqual(have, want) {\n\t\tt.Errorf(\"unexpected hooks called, have: %v, want: %v\", have, want)\n\t}\n\n\t// When none of the chained hooks has a handler there should be no panic.\n\terrorCalled = nil\n\thook2.Error = nil\n\tchain.Error(ctx, InternalError(\"whoops\"))\n\tif have, want := len(errorCalled), 0; have != want {\n\t\tt.Errorf(\"unexpected number of calls, have: %d, want: %d\", have, want)\n\t}\n}\n\nfunc TestWithClientPathPrefix(t *testing.T) {\n\topts := &ClientOptions{}\n\n\t// Default value\n\tif have, want := opts.PathPrefix(), \"/twirp\"; have != want {\n\t\tt.Errorf(\"unexpected default PathPrefix() on ClientOptions, have: %q, want: %q\", have, want)\n\t}\n\n\t// Set a different prefix\n\tWithClientPathPrefix(\"/newprfx/foobar\")(opts)\n\tif have, want := opts.PathPrefix(), \"/newprfx/foobar\"; have != want {\n\t\tt.Errorf(\"unexpected value after WithClientPathPrefix, have: %q, want: %q\", have, want)\n\t}\n\n\t// Use empty value for no-prefix\n\tWithClientPathPrefix(\"\")(opts)\n\tif have, want := opts.PathPrefix(), \"\"; have != want {\n\t\tt.Errorf(\"unexpected value after WithClientPathPrefix, have: %q, want: %q\", have, want)\n\t}\n}\n\nfunc TestWithClientLiteralURLs(t *testing.T) {\n\topts := &ClientOptions{}\n\n\tWithClientLiteralURLs(true)(opts)\n\tif have, want := opts.LiteralURLs, true; have != want {\n\t\tt.Errorf(\"unexpected value after WithClientLiteralURLs, have: %t, want: %t\", have, want)\n\t\treturn\n\t}\n\n\tWithClientLiteralURLs(false)(opts)\n\tif have, want := opts.LiteralURLs, false; have != want {\n\t\tt.Errorf(\"unexpected value after WithClientLiteralURLs, have: %t, want: %t\", have, want)\n\t\treturn\n\t}\n}\n"
        },
        {
          "name": "clientcompat",
          "type": "tree",
          "content": null
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 5.2314453125,
          "content": "// Copyright 2018 Twitch Interactive, Inc.  All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n// use this file except in compliance with the License. A copy of the License is\n// located at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// or in the \"license\" file accompanying this file. This file is distributed on\n// an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n// express or implied. See the License for the specific language governing\n// permissions and limitations under the License.\n\npackage twirp\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\n\t\"github.com/twitchtv/twirp/internal/contextkeys\"\n)\n\n// MethodName extracts the name of the method being handled in the given\n// context. If it is not known, it returns (\"\", false).\nfunc MethodName(ctx context.Context) (string, bool) {\n\tname, ok := ctx.Value(contextkeys.MethodNameKey).(string)\n\treturn name, ok\n}\n\n// ServiceName extracts the name of the service handling the given context. If\n// it is not known, it returns (\"\", false).\nfunc ServiceName(ctx context.Context) (string, bool) {\n\tname, ok := ctx.Value(contextkeys.ServiceNameKey).(string)\n\treturn name, ok\n}\n\n// PackageName extracts the fully-qualified protobuf package name of the service\n// handling the given context. If it is not known, it returns (\"\", false). If\n// the service comes from a proto file that does not declare a package name, it\n// returns (\"\", true).\n//\n// Note that the protobuf package name can be very different than the go package\n// name; the two are unrelated.\nfunc PackageName(ctx context.Context) (string, bool) {\n\tname, ok := ctx.Value(contextkeys.PackageNameKey).(string)\n\treturn name, ok\n}\n\n// StatusCode retrieves the status code of the response (as string like \"200\").\n// If it is known returns (status, true).\n// If it is not known, it returns (\"\", false).\nfunc StatusCode(ctx context.Context) (string, bool) {\n\tcode, ok := ctx.Value(contextkeys.StatusCodeKey).(string)\n\treturn code, ok\n}\n\n// WithHTTPRequestHeaders stores an http.Header in a context.Context. When\n// using a Twirp-generated client, you can pass the returned context\n// into any of the request methods, and the stored header will be\n// included in outbound HTTP requests.\n//\n// This can be used to set custom HTTP headers like authorization tokens or\n// client IDs. But note that HTTP headers are a Twirp implementation detail,\n// only visible by middleware, not by the server implementation.\n//\n// WithHTTPRequestHeaders returns an error if the provided http.Header\n// would overwrite a header that is needed by Twirp, like \"Content-Type\".\nfunc WithHTTPRequestHeaders(ctx context.Context, h http.Header) (context.Context, error) {\n\tif _, ok := h[\"Accept\"]; ok {\n\t\treturn nil, errors.New(\"provided header cannot set Accept\")\n\t}\n\tif _, ok := h[\"Content-Type\"]; ok {\n\t\treturn nil, errors.New(\"provided header cannot set Content-Type\")\n\t}\n\tif _, ok := h[\"Twirp-Version\"]; ok {\n\t\treturn nil, errors.New(\"provided header cannot set Twirp-Version\")\n\t}\n\n\tcopied := make(http.Header, len(h))\n\tfor k, vv := range h {\n\t\tif vv == nil {\n\t\t\tcopied[k] = nil\n\t\t\tcontinue\n\t\t}\n\t\tcopied[k] = make([]string, len(vv))\n\t\tcopy(copied[k], vv)\n\t}\n\n\treturn context.WithValue(ctx, contextkeys.RequestHeaderKey, copied), nil\n}\n\nfunc HTTPRequestHeaders(ctx context.Context) (http.Header, bool) {\n\th, ok := ctx.Value(contextkeys.RequestHeaderKey).(http.Header)\n\treturn h, ok\n}\n\n// SetHTTPResponseHeader sets an HTTP header key-value pair using a context\n// provided by a twirp-generated server, or a child of that context.\n// The server will include the header in its response for that request context.\n//\n// This can be used to respond with custom HTTP headers like \"Cache-Control\".\n// But note that HTTP headers are a Twirp implementation detail,\n// only visible by middleware, not by the clients or their responses.\n//\n// The header will be ignored (noop) if the context is invalid (i.e. using a new\n// context.Background() instead of passing the context from the handler).\n//\n// If called multiple times with the same key, it replaces any existing values\n// associated with that key.\n//\n// SetHTTPResponseHeader returns an error if the provided header key\n// would overwrite a header that is needed by Twirp, like \"Content-Type\".\nfunc SetHTTPResponseHeader(ctx context.Context, key, value string) error {\n\tif key == \"Content-Type\" {\n\t\treturn errors.New(\"header key can not be Content-Type\")\n\t}\n\n\tresponseWriter, ok := ctx.Value(contextkeys.ResponseWriterKey).(http.ResponseWriter)\n\tif ok {\n\t\tresponseWriter.Header().Set(key, value)\n\t} // invalid context is ignored, not an error, this is to allow easy unit testing with mock servers\n\n\treturn nil\n}\n\n// AddHTTPResponseHeader behaves like SetHTTPResponseHeader,\n// but it appends the key-value pair to the header (instead of replacing it).\n//\n// AddHTTPResponseHeader returns an error if the key is \"Content-Type\".\nfunc AddHTTPResponseHeader(ctx context.Context, key, value string) error {\n\tif key == \"Content-Type\" {\n\t\treturn errors.New(\"header key can not be Content-Type\")\n\t}\n\n\tresponseWriter, ok := ctx.Value(contextkeys.ResponseWriterKey).(http.ResponseWriter)\n\tif ok {\n\t\tresponseWriter.Header().Add(key, value)\n\t} // invalid context is ignored, not an error, this is to allow easy unit testing with mock servers\n\n\treturn nil\n}\n"
        },
        {
          "name": "ctxsetters",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 15.1787109375,
          "content": "// Copyright 2018 Twitch Interactive, Inc.  All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n// use this file except in compliance with the License. A copy of the License is\n// located at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// or in the \"license\" file accompanying this file. This file is distributed on\n// an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n// express or implied. See the License for the specific language governing\n// permissions and limitations under the License.\n\n// Package twirp provides core types used in generated Twirp servers and client.\n//\n// Twirp services handle errors using the `twirp.Error` interface.\n//\n// For example, a server method may return an InvalidArgumentError:\n//\n//     if req.Order != \"DESC\" && req.Order != \"ASC\" {\n//         return nil, twirp.InvalidArgumentError(\"Order\", \"must be DESC or ASC\")\n//     }\n//\n// And the same twirp.Error is returned by the client, for example:\n//\n//     resp, err := twirpClient.RPCMethod(ctx, req)\n//     if err != nil {\n//         if twerr, ok := err.(twirp.Error); ok {\n//             switch twerr.Code() {\n//             case twirp.InvalidArgument:\n//                 log.Error(\"invalid argument \"+twirp.Meta(\"argument\"))\n//             default:\n//                 log.Error(twerr.Error())\n//             }\n//         }\n//     }\n//\n// Clients may also return Internal errors if something failed on the system:\n// the server, the network, or the client itself (i.e. failure parsing\n// response).\n//\npackage twirp\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\n// Error represents an error in a Twirp service call.\ntype Error interface {\n\t// Code is of the valid error codes.\n\tCode() ErrorCode\n\n\t// Msg returns a human-readable, unstructured messages describing the error.\n\tMsg() string\n\n\t// WithMeta returns a copy of the Error with the given key-value pair attached\n\t// as metadata. If the key is already set, it is overwritten.\n\tWithMeta(key string, val string) Error\n\n\t// Meta returns the stored value for the given key. If the key has no set\n\t// value, Meta returns an empty string. There is no way to distinguish between\n\t// an unset value and an explicit empty string.\n\tMeta(key string) string\n\n\t// MetaMap returns the complete key-value metadata map stored on the error.\n\tMetaMap() map[string]string\n\n\t// Error returns a string of the form \"twirp error <Code>: <Msg>\"\n\tError() string\n}\n\n// code.Error(msg) builds a new Twirp error with code and msg. Example:\n//   twirp.NotFound.Error(\"Resource not found\")\n//   twirp.Internal.Error(\"Oops\")\nfunc (code ErrorCode) Error(msg string) Error {\n\treturn NewError(code, msg)\n}\n\n// code.Errorf(msg, args...) builds a new Twirp error with code and formatted msg.\n// The format may include \"%w\" to wrap other errors. Examples:\n//   twirp.Internal.Error(\"Oops: %w\", originalErr)\n//   twirp.NotFound.Error(\"Resource not found with id: %q\", resourceID)\nfunc (code ErrorCode) Errorf(msgFmt string, a ...interface{}) Error {\n\treturn NewErrorf(code, msgFmt, a...)\n}\n\n// WrapError allows Twirp errors to wrap other errors.\n// The wrapped error can be extracted later with (github.com/pkg/errors).Unwrap\n// or errors.Is from the standard errors package on Go 1.13+.\nfunc WrapError(twerr Error, err error) Error {\n\treturn &wrappedErr{\n\t\twrapper: twerr,\n\t\tcause:   err,\n\t}\n}\n\n// NewError builds a twirp.Error. The code must be one of the valid predefined constants.\n// To add metadata, use .WithMeta(key, value) method after building the error.\nfunc NewError(code ErrorCode, msg string) Error {\n\tif !IsValidErrorCode(code) {\n\t\treturn &twerr{code: Internal, msg: \"invalid error type \" + string(code)}\n\t}\n\treturn &twerr{code: code, msg: msg}\n}\n\n// NewErrorf builds a twirp.Error with a formatted msg.\n// The format may include \"%w\" to wrap other errors. Examples:\n//   twirp.NewErrorf(twirp.Internal, \"Oops: %w\", originalErr)\n//   twirp.NewErrorf(twirp.NotFound, \"resource with id: %q\", resourceID)\nfunc NewErrorf(code ErrorCode, msgFmt string, a ...interface{}) Error {\n\terr := fmt.Errorf(msgFmt, a...)      // format error message, may include \"%w\" with an original error\n\ttwerr := NewError(code, err.Error()) // use the error as msg\n\treturn WrapError(twerr, err)         // wrap so the original error can be identified with errors.Is\n}\n\n// NotFoundError is a convenience constructor for NotFound errors.\nfunc NotFoundError(msg string) Error {\n\treturn NewError(NotFound, msg)\n}\n\n// InvalidArgumentError is a convenience constructor for InvalidArgument errors.\n// The argument name is included on the \"argument\" metadata for convenience.\nfunc InvalidArgumentError(argument string, validationMsg string) Error {\n\terr := NewError(InvalidArgument, argument+\" \"+validationMsg)\n\terr = err.WithMeta(\"argument\", argument)\n\treturn err\n}\n\n// RequiredArgumentError builds an InvalidArgument error.\n// Useful when a request argument is expected to have a non-zero value.\nfunc RequiredArgumentError(argument string) Error {\n\treturn InvalidArgumentError(argument, \"is required\")\n}\n\n// InternalError is a convenience constructor for Internal errors.\nfunc InternalError(msg string) Error {\n\treturn NewError(Internal, msg)\n}\n\n// InternalErrorf uses the formatted message as the internal error msg.\n// The format may include \"%w\" to wrap other errors. Examples:\n//   twirp.InternalErrorf(\"database error: %w\", err)\n//   twirp.InternalErrorf(\"failed to load resource %q: %w\", resourceID, originalErr)\nfunc InternalErrorf(msgFmt string, a ...interface{}) Error {\n\treturn NewErrorf(Internal, msgFmt, a...)\n}\n\n// InternalErrorWith makes an internal error, wrapping the original error and using it\n// for the error message, and with metadata \"cause\" with the original error type.\n// This function is used by Twirp services to wrap non-Twirp errors as internal errors.\n// The wrapped error can be extracted later with (github.com/pkg/errors).Unwrap\n// or errors.Is from the standard errors package on Go 1.13+.\nfunc InternalErrorWith(err error) Error {\n\ttwerr := NewError(Internal, err.Error())\n\ttwerr = twerr.WithMeta(\"cause\", fmt.Sprintf(\"%T\", err)) // to easily tell apart wrapped internal errors from explicit ones\n\treturn WrapError(twerr, err)\n}\n\n// ErrorCode represents a Twirp error type.\ntype ErrorCode string\n\n// Valid Twirp error types. Most error types are equivalent to gRPC status codes\n// and follow the same semantics.\nconst (\n\t// Canceled indicates the operation was cancelled (typically by the caller).\n\tCanceled ErrorCode = \"canceled\"\n\n\t// Unknown error. For example when handling errors raised by APIs that do not\n\t// return enough error information.\n\tUnknown ErrorCode = \"unknown\"\n\n\t// InvalidArgument indicates client specified an invalid argument. It\n\t// indicates arguments that are problematic regardless of the state of the\n\t// system (i.e. a malformed file name, required argument, number out of range,\n\t// etc.).\n\tInvalidArgument ErrorCode = \"invalid_argument\"\n\n\t// Malformed indicates an error occurred while decoding the client's request.\n\t// This may mean that the message was encoded improperly, or that there is a\n\t// disagreement in message format between the client and server.\n\tMalformed ErrorCode = \"malformed\"\n\n\t// DeadlineExceeded means operation expired before completion. For operations\n\t// that change the state of the system, this error may be returned even if the\n\t// operation has completed successfully (timeout).\n\tDeadlineExceeded ErrorCode = \"deadline_exceeded\"\n\n\t// NotFound means some requested entity was not found.\n\tNotFound ErrorCode = \"not_found\"\n\n\t// BadRoute means that the requested URL path wasn't routable to a Twirp\n\t// service and method. This is returned by the generated server, and usually\n\t// shouldn't be returned by applications. Instead, applications should use\n\t// NotFound or Unimplemented.\n\tBadRoute ErrorCode = \"bad_route\"\n\n\t// AlreadyExists means an attempt to create an entity failed because one\n\t// already exists.\n\tAlreadyExists ErrorCode = \"already_exists\"\n\n\t// PermissionDenied indicates the caller does not have permission to execute\n\t// the specified operation. It must not be used if the caller cannot be\n\t// identified (Unauthenticated).\n\tPermissionDenied ErrorCode = \"permission_denied\"\n\n\t// Unauthenticated indicates the request does not have valid authentication\n\t// credentials for the operation.\n\tUnauthenticated ErrorCode = \"unauthenticated\"\n\n\t// ResourceExhausted indicates some resource has been exhausted or rate-limited,\n\t// perhaps a per-user quota, or perhaps the entire file system is out of space.\n\tResourceExhausted ErrorCode = \"resource_exhausted\"\n\n\t// FailedPrecondition indicates operation was rejected because the system is\n\t// not in a state required for the operation's execution. For example, doing\n\t// an rmdir operation on a directory that is non-empty, or on a non-directory\n\t// object, or when having conflicting read-modify-write on the same resource.\n\tFailedPrecondition ErrorCode = \"failed_precondition\"\n\n\t// Aborted indicates the operation was aborted, typically due to a concurrency\n\t// issue like sequencer check failures, transaction aborts, etc.\n\tAborted ErrorCode = \"aborted\"\n\n\t// OutOfRange means operation was attempted past the valid range. For example,\n\t// seeking or reading past end of a paginated collection.\n\t//\n\t// Unlike InvalidArgument, this error indicates a problem that may be fixed if\n\t// the system state changes (i.e. adding more items to the collection).\n\t//\n\t// There is a fair bit of overlap between FailedPrecondition and OutOfRange.\n\t// We recommend using OutOfRange (the more specific error) when it applies so\n\t// that callers who are iterating through a space can easily look for an\n\t// OutOfRange error to detect when they are done.\n\tOutOfRange ErrorCode = \"out_of_range\"\n\n\t// Unimplemented indicates operation is not implemented or not\n\t// supported/enabled in this service.\n\tUnimplemented ErrorCode = \"unimplemented\"\n\n\t// Internal errors. When some invariants expected by the underlying system\n\t// have been broken. In other words, something bad happened in the library or\n\t// backend service. Do not confuse with HTTP Internal Server Error; an\n\t// Internal error could also happen on the client code, i.e. when parsing a\n\t// server response.\n\tInternal ErrorCode = \"internal\"\n\n\t// Unavailable indicates the service is currently unavailable. This is a most\n\t// likely a transient condition and may be corrected by retrying with a\n\t// backoff.\n\tUnavailable ErrorCode = \"unavailable\"\n\n\t// DataLoss indicates unrecoverable data loss or corruption.\n\tDataLoss ErrorCode = \"data_loss\"\n\n\t// NoError is the zero-value, is considered an empty error and should not be\n\t// used.\n\tNoError ErrorCode = \"\"\n)\n\n// ServerHTTPStatusFromErrorCode maps a Twirp error type into a similar HTTP\n// response status. It is used by the Twirp server handler to set the HTTP\n// response status code. Returns 0 if the ErrorCode is invalid.\nfunc ServerHTTPStatusFromErrorCode(code ErrorCode) int {\n\tswitch code {\n\tcase Canceled:\n\t\treturn 408 // RequestTimeout\n\tcase Unknown:\n\t\treturn 500 // Internal Server Error\n\tcase InvalidArgument:\n\t\treturn 400 // BadRequest\n\tcase Malformed:\n\t\treturn 400 // BadRequest\n\tcase DeadlineExceeded:\n\t\treturn 408 // RequestTimeout\n\tcase NotFound:\n\t\treturn 404 // Not Found\n\tcase BadRoute:\n\t\treturn 404 // Not Found\n\tcase AlreadyExists:\n\t\treturn 409 // Conflict\n\tcase PermissionDenied:\n\t\treturn 403 // Forbidden\n\tcase Unauthenticated:\n\t\treturn 401 // Unauthorized\n\tcase ResourceExhausted:\n\t\treturn 429 // Too Many Requests\n\tcase FailedPrecondition:\n\t\treturn 412 // Precondition Failed\n\tcase Aborted:\n\t\treturn 409 // Conflict\n\tcase OutOfRange:\n\t\treturn 400 // Bad Request\n\tcase Unimplemented:\n\t\treturn 501 // Not Implemented\n\tcase Internal:\n\t\treturn 500 // Internal Server Error\n\tcase Unavailable:\n\t\treturn 503 // Service Unavailable\n\tcase DataLoss:\n\t\treturn 500 // Internal Server Error\n\tcase NoError:\n\t\treturn 200 // OK\n\tdefault:\n\t\treturn 0 // Invalid!\n\t}\n}\n\n// IsValidErrorCode returns true if is one of the valid predefined constants.\nfunc IsValidErrorCode(code ErrorCode) bool {\n\treturn ServerHTTPStatusFromErrorCode(code) != 0\n}\n\n// twirp.Error implementation\ntype twerr struct {\n\tcode ErrorCode\n\tmsg  string\n\tmeta map[string]string\n}\n\nfunc (e *twerr) Code() ErrorCode { return e.code }\nfunc (e *twerr) Msg() string     { return e.msg }\n\nfunc (e *twerr) Meta(key string) string {\n\tif e.meta != nil {\n\t\treturn e.meta[key] // also returns \"\" if key is not in meta map\n\t}\n\treturn \"\"\n}\n\nfunc (e *twerr) WithMeta(key string, value string) Error {\n\tnewErr := &twerr{\n\t\tcode: e.code,\n\t\tmsg:  e.msg,\n\t\tmeta: make(map[string]string, len(e.meta)),\n\t}\n\tfor k, v := range e.meta {\n\t\tnewErr.meta[k] = v\n\t}\n\tnewErr.meta[key] = value\n\treturn newErr\n}\n\nfunc (e *twerr) MetaMap() map[string]string {\n\treturn e.meta\n}\n\nfunc (e *twerr) Error() string {\n\treturn fmt.Sprintf(\"twirp error %s: %s\", e.code, e.msg)\n}\n\n// wrappedErr is the error returned by twirp.InternalErrorWith(err), which is used by clients.\n// Implements Unwrap() to allow go 1.13+ errors.Is/As checks,\n// and Cause() to allow (github.com/pkg/errors).Unwrap.\ntype wrappedErr struct {\n\twrapper Error\n\tcause   error\n}\n\nfunc (e *wrappedErr) Code() ErrorCode            { return e.wrapper.Code() }\nfunc (e *wrappedErr) Msg() string                { return e.wrapper.Msg() }\nfunc (e *wrappedErr) Meta(key string) string     { return e.wrapper.Meta(key) }\nfunc (e *wrappedErr) MetaMap() map[string]string { return e.wrapper.MetaMap() }\nfunc (e *wrappedErr) Error() string              { return e.wrapper.Error() }\nfunc (e *wrappedErr) WithMeta(key string, val string) Error {\n\treturn &wrappedErr{\n\t\twrapper: e.wrapper.WithMeta(key, val),\n\t\tcause:   e.cause,\n\t}\n}\nfunc (e *wrappedErr) Unwrap() error { return e.cause } // for go1.13 + errors.Is/As\nfunc (e *wrappedErr) Cause() error  { return e.cause } // for github.com/pkg/errors\n\n// WriteError writes an HTTP response with a valid Twirp error format (code, msg, meta).\n// Useful outside of the Twirp server (e.g. http middleware).\n// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)\nfunc WriteError(resp http.ResponseWriter, err error) error {\n\tvar twerr Error\n\tif !errors.As(err, &twerr) {\n\t\ttwerr = InternalErrorWith(err)\n\t}\n\n\tstatusCode := ServerHTTPStatusFromErrorCode(twerr.Code())\n\trespBody := marshalErrorToJSON(twerr)\n\n\tresp.Header().Set(\"Content-Type\", \"application/json\") // Error responses are always JSON\n\tresp.Header().Set(\"Content-Length\", strconv.Itoa(len(respBody)))\n\tresp.WriteHeader(statusCode) // set HTTP status code and send response\n\n\t_, writeErr := resp.Write(respBody)\n\tif writeErr != nil {\n\t\treturn writeErr\n\t}\n\treturn nil\n}\n\n// JSON serialization for errors\ntype twerrJSON struct {\n\tCode string            `json:\"code\"`\n\tMsg  string            `json:\"msg\"`\n\tMeta map[string]string `json:\"meta,omitempty\"`\n}\n\n// marshalErrorToJSON returns JSON from a twirp.Error, that can be used as HTTP error response body.\n// If serialization fails, it will use a descriptive Internal error instead.\nfunc marshalErrorToJSON(twerr Error) []byte {\n\t// make sure that msg is not too large\n\tmsg := twerr.Msg()\n\tif len(msg) > 1e6 {\n\t\tmsg = msg[:1e6]\n\t}\n\n\ttj := twerrJSON{\n\t\tCode: string(twerr.Code()),\n\t\tMsg:  msg,\n\t\tMeta: twerr.MetaMap(),\n\t}\n\n\tbuf, err := json.Marshal(&tj)\n\tif err != nil {\n\t\tbuf = []byte(\"{\\\"type\\\": \\\"\" + Internal + \"\\\", \\\"msg\\\": \\\"There was an error but it could not be serialized into JSON\\\"}\") // fallback\n\t}\n\n\treturn buf\n}\n"
        },
        {
          "name": "errors_test.go",
          "type": "blob",
          "size": 7.2294921875,
          "content": "// Copyright 2018 Twitch Interactive, Inc.  All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n// use this file except in compliance with the License. A copy of the License is\n// located at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// or in the \"license\" file accompanying this file. This file is distributed on\n// an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n// express or implied. See the License for the specific language governing\n// permissions and limitations under the License.\n\npackage twirp_test\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http/httptest\"\n\t\"sync\"\n\t\"testing\"\n\n\tpkgerrors \"github.com/pkg/errors\"\n\t\"github.com/twitchtv/twirp\"\n)\n\nfunc TestErrorConstructors(t *testing.T) {\n\tvar twerr twirp.Error\n\terr := errors.New(\"The OG error\")\n\n\t// code.Error\n\n\ttwerr = twirp.NotFound.Error(\"oops\")\n\tassertTwirpError(t, twerr, twirp.NotFound, \"oops\")\n\n\t// code.Errorf\n\n\ttwerr = twirp.Aborted.Errorf(\"oops %d %s\", 11, \"times\")\n\tassertTwirpError(t, twerr, twirp.Aborted, \"oops 11 times\")\n\n\ttwerr = twirp.Internal.Errorf(\"oops: %w\", err)\n\tassertTwirpError(t, twerr, twirp.Internal, \"oops: The OG error\")\n\tif !errors.Is(twerr, err) {\n\t\tt.Errorf(\"expected wrap the original error\")\n\t}\n\n\t// twirp.NewError\n\n\ttwerr = twirp.NewError(twirp.NotFound, \"oops\")\n\tassertTwirpError(t, twerr, twirp.NotFound, \"oops\")\n\n\t// twirp.NewErrorf\n\n\ttwerr = twirp.NewErrorf(twirp.Aborted, \"oops %d %s\", 11, \"times\")\n\tassertTwirpError(t, twerr, twirp.Aborted, \"oops 11 times\")\n\n\ttwerr = twirp.NewErrorf(twirp.Internal, \"oops: %w\", err)\n\tassertTwirpError(t, twerr, twirp.Internal, \"oops: The OG error\")\n\tif !errors.Is(twerr, err) {\n\t\tt.Errorf(\"expected wrap the original error\")\n\t}\n\n\t// Convenience constructors\n\n\ttwerr = twirp.NotFoundError(\"oops\")\n\tassertTwirpError(t, twerr, twirp.NotFound, \"oops\")\n\n\ttwerr = twirp.InvalidArgumentError(\"my_arg\", \"is invalid\")\n\tassertTwirpError(t, twerr, twirp.InvalidArgument, \"my_arg is invalid\")\n\tassertTwirpErrorMeta(t, twerr, \"argument\", \"my_arg\")\n\n\ttwerr = twirp.RequiredArgumentError(\"my_arg\")\n\tassertTwirpError(t, twerr, twirp.InvalidArgument, \"my_arg is required\")\n\tassertTwirpErrorMeta(t, twerr, \"argument\", \"my_arg\")\n\n\ttwerr = twirp.InternalError(\"oops\")\n\tassertTwirpError(t, twerr, twirp.Internal, \"oops\")\n\n\ttwerr = twirp.InternalErrorf(\"oops: %w\", err)\n\tassertTwirpError(t, twerr, twirp.Internal, \"oops: The OG error\")\n\tif !errors.Is(twerr, err) {\n\t\tt.Errorf(\"expected wrap the original error\")\n\t}\n\n\ttwerr = twirp.InternalErrorWith(err)\n\tassertTwirpError(t, twerr, twirp.Internal, \"The OG error\")\n\tif !errors.Is(twerr, err) {\n\t\tt.Errorf(\"expected wrap the original error\")\n\t}\n\tassertTwirpErrorMeta(t, twerr, \"cause\", \"*errors.errorString\")\n}\n\nfunc TestWithMetaRaces(t *testing.T) {\n\terr := twirp.NewError(twirp.Internal, \"msg\")\n\terr = err.WithMeta(\"k1\", \"v1\")\n\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 1000; i++ {\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\t_ = err.WithMeta(fmt.Sprintf(\"k-%d\", i), \"v\")\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\n\tif len(err.MetaMap()) != 1 {\n\t\tt.Errorf(\"err was mutated\")\n\t}\n}\n\nfunc TestPkgErrorCause(t *testing.T) {\n\trootCause := pkgerrors.New(\"this is only a test\")\n\ttwerr := twirp.InternalErrorWith(rootCause)\n\tcause := pkgerrors.Cause(twerr)\n\tif cause != rootCause {\n\t\tt.Errorf(\"got wrong cause for err. have=%q, want=%q\", cause, rootCause)\n\t}\n}\n\nfunc TestWrapError(t *testing.T) {\n\trootCause := errors.New(\"cause\")\n\ttwerr := twirp.NewError(twirp.NotFound, \"it ain't there\")\n\terr := twirp.WrapError(twerr, rootCause)\n\tcause := pkgerrors.Cause(err)\n\tif cause != rootCause {\n\t\tt.Errorf(\"got wrong cause. got=%q, want=%q\", cause, rootCause)\n\t}\n\twantMsg := \"twirp error not_found: it ain't there\"\n\tif gotMsg := err.Error(); gotMsg != wantMsg {\n\t\tt.Errorf(\"got wrong error text. got=%q, want=%q\", gotMsg, wantMsg)\n\t}\n}\n\ntype myError string\n\nfunc (e myError) Error() string {\n\treturn string(e)\n}\n\nfunc TestInternalErrorWith_Unwrap(t *testing.T) {\n\tmyErr := myError(\"myError\")\n\twrErr := fmt.Errorf(\"wrapped: %w\", myErr) // double wrap\n\ttwerr := twirp.InternalErrorWith(wrErr)\n\n\tif !errors.Is(twerr, myErr) {\n\t\tt.Errorf(\"expected errors.Is to match the error wrapped by twirp.InternalErrorWith\")\n\t}\n\n\tvar errTarget myError\n\tif !errors.As(twerr, &errTarget) {\n\t\tt.Errorf(\"expected errors.As to match the error wrapped by twirp.InternalErrorWith\")\n\t}\n\tif errTarget.Error() != myErr.Error() {\n\t\tt.Errorf(\"invalid value for errTarget.Error(). have=%q, want=%q\", errTarget.Error(), myErr.Error())\n\t}\n}\n\ntype errorResponseWriter struct {\n\t*httptest.ResponseRecorder\n}\n\nfunc (errorResponseWriter) Write([]byte) (int, error) {\n\treturn 0, errors.New(\"this is only a test\")\n}\n\ntype twerrJSON struct {\n\tCode string            `json:\"code\"`\n\tMsg  string            `json:\"msg\"`\n\tMeta map[string]string `json:\"meta,omitempty\"`\n}\n\nfunc TestWriteError(t *testing.T) {\n\tresp := httptest.NewRecorder()\n\ttwerr := twirp.NewError(twirp.Internal, \"test middleware error\")\n\terr := twirp.WriteError(resp, twerr)\n\tif err != nil {\n\t\tt.Errorf(\"got an error from WriteError when not expecting one: %s\", err)\n\t\treturn\n\t}\n\n\ttwerrCode := twirp.ServerHTTPStatusFromErrorCode(twerr.Code())\n\tif resp.Code != twerrCode {\n\t\tt.Errorf(\"got wrong status. have=%d, want=%d\", resp.Code, twerrCode)\n\t\treturn\n\t}\n\n\tvar gotTwerrJSON twerrJSON\n\terr = json.NewDecoder(resp.Body).Decode(&gotTwerrJSON)\n\tif err != nil {\n\t\tt.Errorf(\"got an error decoding response body: %s\", err)\n\t\treturn\n\t}\n\n\tif twirp.ErrorCode(gotTwerrJSON.Code) != twerr.Code() {\n\t\tt.Errorf(\"got wrong error code. have=%s, want=%s\", gotTwerrJSON.Code, twerr.Code())\n\t\treturn\n\t}\n\n\tif gotTwerrJSON.Msg != twerr.Msg() {\n\t\tt.Errorf(\"got wrong error message. have=%s, want=%s\", gotTwerrJSON.Msg, twerr.Msg())\n\t\treturn\n\t}\n\n\terrResp := &errorResponseWriter{ResponseRecorder: resp}\n\n\t// Writing again should error out as headers are being rewritten\n\terr = twirp.WriteError(errResp, twerr)\n\tif err == nil {\n\t\tt.Errorf(\"did not get error on write. have=nil, want=some error\")\n\t}\n}\n\nfunc TestWriteError_WithNonTwirpError(t *testing.T) {\n\tresp := httptest.NewRecorder()\n\tnonTwerr := errors.New(\"not a twirp error\")\n\terr := twirp.WriteError(resp, nonTwerr)\n\tif err != nil {\n\t\tt.Errorf(\"got an error from WriteError when not expecting one: %s\", err)\n\t\treturn\n\t}\n\n\tif resp.Code != 500 {\n\t\tt.Errorf(\"got wrong status. have=%d, want=%d\", resp.Code, 500)\n\t\treturn\n\t}\n\n\tvar gotTwerrJSON twerrJSON\n\terr = json.NewDecoder(resp.Body).Decode(&gotTwerrJSON)\n\tif err != nil {\n\t\tt.Errorf(\"got an error decoding response body: %s\", err)\n\t\treturn\n\t}\n\n\tif twirp.ErrorCode(gotTwerrJSON.Code) != twirp.Internal {\n\t\tt.Errorf(\"got wrong error code. have=%s, want=%s\", gotTwerrJSON.Code, twirp.Internal)\n\t\treturn\n\t}\n\n\tif gotTwerrJSON.Msg != \"\"+nonTwerr.Error() {\n\t\tt.Errorf(\"got wrong error message. have=%s, want=%s\", gotTwerrJSON.Msg, nonTwerr.Error())\n\t\treturn\n\t}\n}\n\n// Test helpers\n\nfunc assertTwirpError(t *testing.T, twerr twirp.Error, code twirp.ErrorCode, msg string) {\n\tt.Helper()\n\tif twerr.Code() != code {\n\t\tt.Errorf(\"wrong code. have=%q, want=%q\", twerr.Code(), code)\n\t}\n\tif twerr.Msg() != msg {\n\t\tt.Errorf(\"wrong msg. have=%q, want=%q\", twerr.Msg(), msg)\n\t}\n}\n\nfunc assertTwirpErrorMeta(t *testing.T, twerr twirp.Error, key string, value string) {\n\tt.Helper()\n\tif twerr.Meta(key) != value {\n\t\tt.Errorf(\"wrong meta. have=%q, want=%q\", twerr.Meta(key), value)\n\t}\n}\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "hooks",
          "type": "tree",
          "content": null
        },
        {
          "name": "interceptors.go",
          "type": "blob",
          "size": 2.6025390625,
          "content": "// Copyright 2018 Twitch Interactive, Inc.  All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n// use this file except in compliance with the License. A copy of the License is\n// located at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// or in the \"license\" file accompanying this file. This file is distributed on\n// an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n// express or implied. See the License for the specific language governing\n// permissions and limitations under the License.\npackage twirp\n\nimport (\n\t\"context\"\n)\n\n// Interceptor is a form of middleware for Twirp requests, that can be installed on both\n// clients and servers. To intercept RPC calls in the client, use the option\n// `twirp.WithClientInterceptors` on the client constructor. To intercept RPC calls in the server,\n// use the option `twirp.WithServerInterceptors` on the server constructor.\n//\n// Just like http middleware, interceptors can mutate requests and responses.\n// This can enable some powerful integrations, but it should be used with much care\n// because it may result in code that is very hard to debug.\n//\n// Example of an interceptor that logs every request and response:\n//\n//   func LogInterceptor(l *log.Logger) twirp.Interceptor {\n//     return func(next twirp.Method) twirp.Method {\n//       return func(ctx context.Context, req interface{}) (interface{}, error) {\n//         l.Printf(\"Service: %s, Method: %s, Request: %v\",\n//             twirp.ServiceName(ctx), twirp.MethodName(ctx), req)\n//         resp, err := next(ctx, req)\n//         l.Printf(\"Response: %v, Error: %v\", resp)\n//         return resp, err\n//       }\n//     }\n//   }\n//\ntype Interceptor func(Method) Method\n\n// Method is a generic representation of a Twirp-generated RPC method.\n// It is used to define Interceptors.\ntype Method func(ctx context.Context, request interface{}) (interface{}, error)\n\n// ChainInterceptors chains multiple Interceptors into a single Interceptor.\n// The first interceptor wraps the second one, and so on.\n// Returns nil if interceptors is empty. Nil interceptors are ignored.\nfunc ChainInterceptors(interceptors ...Interceptor) Interceptor {\n\tfiltered := make([]Interceptor, 0, len(interceptors))\n\tfor _, interceptor := range interceptors {\n\t\tif interceptor != nil {\n\t\t\tfiltered = append(filtered, interceptor)\n\t\t}\n\t}\n\tswitch n := len(filtered); n {\n\tcase 0:\n\t\treturn nil\n\tcase 1:\n\t\treturn filtered[0]\n\tdefault:\n\t\tfirst := filtered[0]\n\t\treturn func(next Method) Method {\n\t\t\tfor i := len(filtered) - 1; i > 0; i-- {\n\t\t\t\tnext = filtered[i](next)\n\t\t\t}\n\t\t\treturn first(next)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "interceptors_test.go",
          "type": "blob",
          "size": 2.771484375,
          "content": "// Copyright 2018 Twitch Interactive, Inc.  All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n// use this file except in compliance with the License. A copy of the License is\n// located at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// or in the \"license\" file accompanying this file. This file is distributed on\n// an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n// express or implied. See the License for the specific language governing\n// permissions and limitations under the License.\npackage twirp\n\nimport (\n\t\"context\"\n\t\"testing\"\n)\n\nfunc TestChainInterceptors(t *testing.T) {\n\tif chain := ChainInterceptors(); chain != nil {\n\t\tt.Errorf(\"ChainInterceptors(0) expected to be nil, but was %v\", chain)\n\t}\n\tif chain := ChainInterceptors(nil); chain != nil {\n\t\tt.Errorf(\"ChainInterceptors(0) expected to be nil, but was %v\", chain)\n\t}\n\tif chain := ChainInterceptors(nil, nil); chain != nil {\n\t\tt.Errorf(\"ChainInterceptors(0) expected to be nil, but was %v\", chain)\n\t}\n\n\tinterceptor1 := func(next Method) Method {\n\t\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\n\t\t\tresponse, err := next(ctx, request.(string)+\"a\")\n\t\t\treturn response.(string) + \"1\", err\n\t\t}\n\t}\n\tinterceptor2 := func(next Method) Method {\n\t\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\n\t\t\tresponse, err := next(ctx, request.(string)+\"b\")\n\t\t\treturn response.(string) + \"2\", err\n\t\t}\n\t}\n\tinterceptor3 := func(next Method) Method {\n\t\treturn func(ctx context.Context, request interface{}) (interface{}, error) {\n\t\t\tresponse, err := next(ctx, request.(string)+\"c\")\n\t\t\treturn response.(string) + \"3\", err\n\t\t}\n\t}\n\tmethod := func(ctx context.Context, request interface{}) (interface{}, error) {\n\t\treturn request.(string) + \"x\", nil\n\t}\n\tfor _, testCase := range []struct {\n\t\tinterceptors []Interceptor\n\t\twant         string\n\t}{\n\t\t{\n\t\t\tinterceptors: []Interceptor{interceptor1},\n\t\t\twant:         \"ax1\",\n\t\t},\n\t\t{\n\t\t\tinterceptors: []Interceptor{interceptor1, interceptor2},\n\t\t\twant:         \"abx21\",\n\t\t},\n\t\t{\n\t\t\tinterceptors: []Interceptor{interceptor1, interceptor2, interceptor3},\n\t\t\twant:         \"abcx321\",\n\t\t},\n\t\t{\n\t\t\tinterceptors: []Interceptor{interceptor1, interceptor2, nil, interceptor3},\n\t\t\twant:         \"abcx321\",\n\t\t},\n\t\t{\n\t\t\tinterceptors: []Interceptor{interceptor1, interceptor1, interceptor1},\n\t\t\twant:         \"aaax111\",\n\t\t},\n\t} {\n\t\tresponse, err := ChainInterceptors(testCase.interceptors...)(method)(context.Background(), \"\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"ChainInterceptors(%d) method has unexpected err %v\", len(testCase.interceptors), err)\n\t\t}\n\t\tif response != testCase.want {\n\t\t\tt.Errorf(\"ChainInterceptors(%d) has unexpected value, have=%v, want=%v\", len(testCase.interceptors), response, testCase.want)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "license_test.go",
          "type": "blob",
          "size": 2.46484375,
          "content": "// Copyright 2018 Twitch Interactive, Inc.  All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n// use this file except in compliance with the License. A copy of the License is\n// located at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// or in the \"license\" file accompanying this file. This file is distributed on\n// an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n// express or implied. See the License for the specific language governing\n// permissions and limitations under the License.\n\npackage twirp\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n)\n\nvar headerCopyright = regexp.MustCompile(`// Copyright \\d{4} Twitch Interactive, Inc.  All Rights Reserved.`)\n\nconst headerLicense = `\n// Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n// use this file except in compliance with the License. A copy of the License is\n// located at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// or in the \"license\" file accompanying this file. This file is distributed on\n// an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n// express or implied. See the License for the specific language governing\n// permissions and limitations under the License.\n`\n\nvar generatedCodeMatcher = regexp.MustCompile(\"// Code generated .* DO NOT EDIT\")\n\nfunc TestSourceCodeLicenseHeaders(t *testing.T) {\n\terr := filepath.Walk(\".\", func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif path == \"_tools\" || path == \"vendor\" {\n\t\t\treturn filepath.SkipDir\n\t\t}\n\n\t\tif !strings.HasSuffix(path, \".go\") {\n\t\t\t// Skip non-go files.\n\t\t\treturn nil\n\t\t}\n\n\t\tif strings.HasSuffix(path, \".twirp.go\") || strings.HasSuffix(path, \".pb.go\") {\n\t\t\treturn nil\n\t\t}\n\n\t\tfile, err := os.Open(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfileBytes, err := io.ReadAll(file)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfileBuf := bytes.NewReader(fileBytes)\n\n\t\tif generatedCodeMatcher.MatchReader(fileBuf) {\n\t\t\t// Skip generated files.\n\t\t\treturn nil\n\t\t}\n\n\t\t_, err = fileBuf.Seek(0, io.SeekStart)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !headerCopyright.MatchReader(fileBuf) {\n\t\t\tt.Errorf(\"%v is missing licensing header\", path)\n\t\t\treturn nil\n\t\t}\n\n\t\tif !bytes.Contains(fileBytes, []byte(headerLicense)) {\n\t\t\tt.Errorf(\"%v is missing licensing header\", path)\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatalf(\"error scanning directory for source code files: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "logo.png",
          "type": "blob",
          "size": 8.0849609375,
          "content": null
        },
        {
          "name": "protoc-gen-twirp",
          "type": "tree",
          "content": null
        },
        {
          "name": "server_options.go",
          "type": "blob",
          "size": 8.4697265625,
          "content": "// Copyright 2018 Twitch Interactive, Inc.  All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n// use this file except in compliance with the License. A copy of the License is\n// located at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// or in the \"license\" file accompanying this file. This file is distributed on\n// an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n// express or implied. See the License for the specific language governing\n// permissions and limitations under the License.\npackage twirp\n\nimport (\n\t\"context\"\n\t\"reflect\"\n)\n\n// ServerOption is a functional option for extending a Twirp service.\ntype ServerOption func(*ServerOptions)\n\n// WithServerHooks defines the hooks for a Twirp server.\nfunc WithServerHooks(hooks *ServerHooks) ServerOption {\n\treturn func(opts *ServerOptions) {\n\t\topts.Hooks = hooks\n\t}\n}\n\n// WithServerInterceptors defines the interceptors for a Twirp server.\nfunc WithServerInterceptors(interceptors ...Interceptor) ServerOption {\n\treturn func(opts *ServerOptions) {\n\t\topts.Interceptors = append(opts.Interceptors, interceptors...)\n\t}\n}\n\n// WithServerPathPrefix specifies a different prefix for routing.\n// If not specified, the \"/twirp\" prefix is used by default.\n// An empty value \"\" can be specified to use no prefix.\n// The clients must be configured to send requests using the same prefix.\n// URL format: \"<baseURL>[<prefix>]/<package>.<Service>/<Method>\"\n// More info on Twirp docs: https://twitchtv.github.io/twirp/docs/routing.html\nfunc WithServerPathPrefix(prefix string) ServerOption {\n\treturn func(opts *ServerOptions) {\n\t\topts.setOpt(\"pathPrefix\", prefix)\n\t\topts.pathPrefix = &prefix // for code generated before v8.1.0\n\t}\n}\n\n// WithServerJSONSkipDefaults configures JSON serialization to skip\n// unpopulated or default values in JSON responses, which results in\n// smaller response sizes. This was the default before v7 and can be\n// enabled for full backwards compatibility if required.\n// This is now disabled by default, because JSON serialization is\n// commonly used for manual debugging, in which case it is useful\n// to see the full shape of the response.\n// See: https://pkg.go.dev/google.golang.org/protobuf/encoding/protojson\n// See: https://developers.google.com/protocol-buffers/docs/proto3#json\nfunc WithServerJSONSkipDefaults(skipDefaults bool) ServerOption {\n\treturn func(opts *ServerOptions) {\n\t\topts.setOpt(\"jsonSkipDefaults\", skipDefaults)\n\t\topts.JSONSkipDefaults = skipDefaults // for code generated before v8.1.0\n\t}\n}\n\n// WithServerJSONCamelCaseNames configures JSON serialization to use the\n// default proto3 JSON encoding (lowerCamelCase) rather than the original\n// proto field names. Twirp uses the original proto field names by default,\n// because JSON encoding is often used for manual debugging of the API,\n// but this option allows better compatibility with other proto-json parsers.\n// See: https://pkg.go.dev/google.golang.org/protobuf/encoding/protojson\n// See: https://developers.google.com/protocol-buffers/docs/proto3#json\nfunc WithServerJSONCamelCaseNames(jsonCamelCase bool) ServerOption {\n\treturn func(opts *ServerOptions) {\n\t\topts.setOpt(\"jsonCamelCase\", jsonCamelCase)\n\t}\n}\n\n// ServerHooks is a container for callbacks that can instrument a\n// Twirp-generated server. These callbacks all accept a context and return a\n// context. They can use this to add to the request context as it threads\n// through the system, appending values or deadlines to it.\n//\n// The RequestReceived and RequestRouted hooks are special: they can return\n// errors. If they return a non-nil error, handling for that request will be\n// stopped at that point. The Error hook will be triggered, and the error will\n// be sent to the client. This can be used for stuff like auth checks before\n// deserializing a request.\n//\n// The RequestReceived hook is always called first, and it is called for every\n// request that the Twirp server handles. The last hook to be called in a\n// request's lifecycle is always ResponseSent, even in the case of an error.\n//\n// Details on the timing of each hook are documented as comments on the fields\n// of the ServerHooks type.\ntype ServerHooks struct {\n\t// RequestReceived is called as soon as a request enters the Twirp\n\t// server at the earliest available moment.\n\tRequestReceived func(context.Context) (context.Context, error)\n\n\t// RequestRouted is called when a request has been routed to a\n\t// particular method of the Twirp server.\n\tRequestRouted func(context.Context) (context.Context, error)\n\n\t// ResponsePrepared is called when a request has been handled and a\n\t// response is ready to be sent to the client.\n\tResponsePrepared func(context.Context) context.Context\n\n\t// ResponseSent is called when all bytes of a response (including an error\n\t// response) have been written. Because the ResponseSent hook is terminal, it\n\t// does not return a context.\n\tResponseSent func(context.Context)\n\n\t// Error hook is called when an error occurs while handling a request. The\n\t// Error is passed as argument to the hook.\n\tError func(context.Context, Error) context.Context\n}\n\n// ChainHooks creates a new *ServerHooks which chains the callbacks in\n// each of the constituent hooks passed in. Each hook function will be\n// called in the order of the ServerHooks values passed in.\n//\n// For the erroring hooks, RequestReceived and RequestRouted, any returned\n// errors prevent processing by later hooks.\nfunc ChainHooks(hooks ...*ServerHooks) *ServerHooks {\n\tif len(hooks) == 0 {\n\t\treturn nil\n\t}\n\tif len(hooks) == 1 {\n\t\treturn hooks[0]\n\t}\n\treturn &ServerHooks{\n\t\tRequestReceived: func(ctx context.Context) (context.Context, error) {\n\t\t\tvar err error\n\t\t\tfor _, h := range hooks {\n\t\t\t\tif h != nil && h.RequestReceived != nil {\n\t\t\t\t\tctx, err = h.RequestReceived(ctx)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn ctx, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ctx, nil\n\t\t},\n\t\tRequestRouted: func(ctx context.Context) (context.Context, error) {\n\t\t\tvar err error\n\t\t\tfor _, h := range hooks {\n\t\t\t\tif h != nil && h.RequestRouted != nil {\n\t\t\t\t\tctx, err = h.RequestRouted(ctx)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn ctx, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ctx, nil\n\t\t},\n\t\tResponsePrepared: func(ctx context.Context) context.Context {\n\t\t\tfor _, h := range hooks {\n\t\t\t\tif h != nil && h.ResponsePrepared != nil {\n\t\t\t\t\tctx = h.ResponsePrepared(ctx)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ctx\n\t\t},\n\t\tResponseSent: func(ctx context.Context) {\n\t\t\tfor _, h := range hooks {\n\t\t\t\tif h != nil && h.ResponseSent != nil {\n\t\t\t\t\th.ResponseSent(ctx)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tError: func(ctx context.Context, twerr Error) context.Context {\n\t\t\tfor _, h := range hooks {\n\t\t\t\tif h != nil && h.Error != nil {\n\t\t\t\t\tctx = h.Error(ctx, twerr)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ctx\n\t\t},\n\t}\n}\n\n// ServerOptions encapsulate the configurable parameters on a Twirp server.\n// This type is meant to be used only by generated code.\ntype ServerOptions struct {\n\t// Untyped options map. The methods setOpt and ReadOpt are used to set\n\t// and read options. The options are untyped so when a new option is added,\n\t// newly generated code can still work with older versions of the runtime.\n\tm map[string]interface{}\n\n\tHooks        *ServerHooks\n\tInterceptors []Interceptor\n\n\t// Properties below are only used by code that was\n\t// generated by older versions of Twirp (before v8.1.0).\n\t// New options with standard types added in the future\n\t// don't need new properties, they should use ReadOpt.\n\tJSONSkipDefaults bool\n\tpathPrefix       *string\n}\n\n// ReadOpt extracts an option to a pointer value,\n// returns true if the option exists and was extracted.\n// This method is meant to be used by generated code,\n// keeping the type dependency outside of the runtime.\n//\n// Usage example:\n//\n//     opts.setOpt(\"fooOpt\", 123)\n//     var foo int\n//     ok := opts.ReadOpt(\"fooOpt\", &int)\n//\nfunc (opts *ServerOptions) ReadOpt(key string, out interface{}) bool {\n\tval, ok := opts.m[key]\n\tif !ok {\n\t\treturn false\n\t}\n\n\trout := reflect.ValueOf(out)\n\tif rout.Kind() != reflect.Ptr {\n\t\tpanic(\"ReadOpt(key, out); out must be a pointer but it was not\")\n\t}\n\trout.Elem().Set(reflect.ValueOf(val))\n\treturn true\n}\n\n// setOpt adds an option key/value. It is used by ServerOption helpers.\n// The value can be extracted with ReadOpt by passing a pointer to the same type.\nfunc (opts *ServerOptions) setOpt(key string, val interface{}) {\n\tif opts.m == nil {\n\t\topts.m = make(map[string]interface{})\n\t}\n\topts.m[key] = val\n}\n\n// PathPrefix() is used only by clients generated before v8.1.0\nfunc (opts *ServerOptions) PathPrefix() string {\n\tif opts.pathPrefix == nil {\n\t\treturn \"/twirp\" // default prefix\n\t}\n\treturn *opts.pathPrefix\n}\n"
        },
        {
          "name": "server_options_test.go",
          "type": "blob",
          "size": 4.849609375,
          "content": "// Copyright 2018 Twitch Interactive, Inc.  All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n// use this file except in compliance with the License. A copy of the License is\n// located at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// or in the \"license\" file accompanying this file. This file is distributed on\n// an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n// express or implied. See the License for the specific language governing\n// permissions and limitations under the License.\n\npackage twirp\n\nimport (\n\t\"context\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestServerOptionsReadOpt(t *testing.T) {\n\topts := &ServerOptions{}\n\tok := false\n\n\tvar fooNum int\n\tok = opts.ReadOpt(\"fooNum\", &fooNum)\n\tif ok {\n\t\tt.Errorf(\"option 'fooNum' does not exist, opts.ReadOpt should have returned false\")\n\t}\n\n\topts.setOpt(\"fooNum\", 455)\n\tok = opts.ReadOpt(\"fooNum\", &fooNum)\n\tif !ok || fooNum != 455 {\n\t\tt.Errorf(\"option 'fooNum' expected to be 455\")\n\t}\n\n\tvar jsonSkipDefaults bool\n\tok = opts.ReadOpt(\"jsonSkipDefaults\", &jsonSkipDefaults)\n\tif ok {\n\t\tt.Errorf(\"option 'jsonSkipDefaults' does not exist, opts.ReadOpt should have returned false\")\n\t}\n\n\tWithServerJSONSkipDefaults(true)(opts)\n\tok = opts.ReadOpt(\"jsonSkipDefaults\", &jsonSkipDefaults)\n\tif !ok || !jsonSkipDefaults {\n\t\tt.Errorf(\"option 'jsonSkipDefaults' expected to be true, ok: %v, val: %v\", ok, jsonSkipDefaults)\n\t}\n\n\tWithServerJSONSkipDefaults(false)(opts)\n\tok = opts.ReadOpt(\"jsonSkipDefaults\", &jsonSkipDefaults)\n\tif !ok || jsonSkipDefaults {\n\t\tt.Errorf(\"option 'jsonSkipDefaults' expected to be false, ok: %v, val: %v\", ok, jsonSkipDefaults)\n\t}\n}\n\nfunc TestChainHooks(t *testing.T) {\n\tvar (\n\t\thook1 = new(ServerHooks)\n\t\thook2 = new(ServerHooks)\n\t\thook3 = new(ServerHooks)\n\t)\n\n\tconst key = \"key\"\n\n\thook1.RequestReceived = func(ctx context.Context) (context.Context, error) {\n\t\treturn context.WithValue(ctx, key, []string{\"hook1\"}), nil\n\t}\n\thook2.RequestReceived = func(ctx context.Context) (context.Context, error) {\n\t\tv := ctx.Value(key).([]string)\n\t\treturn context.WithValue(ctx, key, append(v, \"hook2\")), nil\n\t}\n\thook3.RequestReceived = func(ctx context.Context) (context.Context, error) {\n\t\tv := ctx.Value(key).([]string)\n\t\treturn context.WithValue(ctx, key, append(v, \"hook3\")), nil\n\t}\n\n\thook1.RequestRouted = func(ctx context.Context) (context.Context, error) {\n\t\treturn context.WithValue(ctx, key, []string{\"hook1\"}), nil\n\t}\n\n\thook2.ResponsePrepared = func(ctx context.Context) context.Context {\n\t\treturn context.WithValue(ctx, key, []string{\"hook2\"})\n\t}\n\n\tchain := ChainHooks(hook1, hook2, hook3)\n\n\tctx := context.Background()\n\n\t// When all three chained hooks have a handler, all should be called in order.\n\twant := []string{\"hook1\", \"hook2\", \"hook3\"}\n\thaveCtx, err := chain.RequestReceived(ctx)\n\tif err != nil {\n\t\tt.Fatalf(\"RequestReceived chain has unexpected err %v\", err)\n\t}\n\thave := haveCtx.Value(key)\n\tif !reflect.DeepEqual(want, have) {\n\t\tt.Errorf(\"RequestReceived chain has unexpected ctx, have=%v, want=%v\", have, want)\n\t}\n\n\t// When only the first chained hook has a handler, it should be called, and\n\t// there should be no panic.\n\twant = []string{\"hook1\"}\n\thaveCtx, err = chain.RequestRouted(ctx)\n\tif err != nil {\n\t\tt.Fatalf(\"RequestRouted chain has unexpected err %v\", err)\n\t}\n\thave = haveCtx.Value(key)\n\tif !reflect.DeepEqual(want, have) {\n\t\tt.Errorf(\"RequestRouted chain has unexpected ctx, have=%v, want=%v\", have, want)\n\t}\n\n\t// When only the second chained hook has a handler, it should be called, and\n\t// there should be no panic.\n\twant = []string{\"hook2\"}\n\thave = chain.ResponsePrepared(ctx).Value(key)\n\tif !reflect.DeepEqual(want, have) {\n\t\tt.Errorf(\"RequestRouted chain has unexpected ctx, have=%v, want=%v\", have, want)\n\t}\n\n\t// When none of the chained hooks has a handler there should be no panic.\n\tchain.ResponseSent(ctx)\n}\n\nfunc TestWithServerPathPrefix(t *testing.T) {\n\topts := &ServerOptions{}\n\n\t// Default value\n\tif have, want := opts.PathPrefix(), \"/twirp\"; have != want {\n\t\tt.Errorf(\"unexpected default PathPrefix() on ServerOptions, have: %q, want: %q\", have, want)\n\t}\n\n\t// Set a different prefix\n\tWithServerPathPrefix(\"/newprfx/foobar\")(opts)\n\tif have, want := opts.PathPrefix(), \"/newprfx/foobar\"; have != want {\n\t\tt.Errorf(\"unexpected value after WithServerPathPrefix, have: %q, want: %q\", have, want)\n\t}\n\n\t// Use empty value for no-prefix\n\tWithServerPathPrefix(\"\")(opts)\n\tif have, want := opts.PathPrefix(), \"\"; have != want {\n\t\tt.Errorf(\"unexpected value after WithServerPathPrefix, have: %q, want: %q\", have, want)\n\t}\n}\n\nfunc TestWithJSONSkipDefaults(t *testing.T) {\n\topts := &ServerOptions{}\n\n\tWithServerJSONSkipDefaults(true)(opts)\n\tif !opts.JSONSkipDefaults {\n\t\tt.Errorf(\"opts.JSONSkipDefaults expected to be true, but it is false\")\n\t}\n\n\tWithServerJSONSkipDefaults(false)(opts)\n\tif opts.JSONSkipDefaults {\n\t\tt.Errorf(\"opts.JSONSkipDefaults expected to be false, but it is true\")\n\t}\n}\n"
        },
        {
          "name": "tools.json",
          "type": "blob",
          "size": 0.421875,
          "content": "{\n  \"Tools\": [\n    {\n      \"Repository\": \"github.com/kisielk/errcheck\",\n      \"Commit\": \"db0ca22445717d1b2c51ac1034440e0a2a2de645\"\n    },\n    {\n      \"Repository\": \"github.com/twitchtv/retool\",\n      \"Commit\": \"6f6d4930d88c40e23d2b54d12e64f0444e1fb4ef\"\n    },\n    {\n      \"Repository\": \"google.golang.org/protobuf/cmd/protoc-gen-go\",\n      \"Commit\": \"fc9592f7ac4bade8f83e636263f8f07715c698d1\"\n    }\n  ],\n  \"RetoolVersion\": \"1.3.5\"\n}"
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        },
        {
          "name": "vendor_test.go",
          "type": "blob",
          "size": 1.9443359375,
          "content": "// Copyright 2018 Twitch Interactive, Inc.  All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n// use this file except in compliance with the License. A copy of the License is\n// located at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// or in the \"license\" file accompanying this file. This file is distributed on\n// an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n// express or implied. See the License for the specific language governing\n// permissions and limitations under the License.\n\npackage twirp\n\nimport (\n\t\"go/build\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestNoExternalDeps(t *testing.T) {\n\t// Twirp commits its vendor directory so that 'go get' works for its main\n\t// packages, but vendoring dependencies of the 'twirp' package could cause\n\t// problems for users.\n\t//\n\t// The simplest way to make things safe is to have no non-stdlib dependencies\n\t// in the twirp package.\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatalf(\"unable to get current working directory: %v\", err)\n\t}\n\n\t// Gather all imports of the current package recursively\n\tallPkgs := make(map[string]bool)\n\n\tvar walkImports func(string)\n\twalkImports = func(pkgName string) {\n\t\tif allPkgs[pkgName] {\n\t\t\t// already visited\n\t\t\treturn\n\t\t}\n\t\tallPkgs[pkgName] = true\n\n\t\tpkg, err := build.Default.Import(pkgName, wd, 0)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unable to import package %s: %s\", pkgName, err)\n\t\t}\n\t\tfor _, imported := range pkg.Imports {\n\t\t\t// Standard library packages don't have a '.' in them.\n\t\t\tif !strings.Contains(imported, \".\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// This is a non-stdlib package. It's okay if it's a twirp package - as\n\t\t\t// long as it doesn't have any external deps itself.\n\t\t\tif strings.HasPrefix(imported, \"github.com/twitchtv/twirp\") {\n\t\t\t\twalkImports(imported)\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"imported external dependency: %v, imported by %v\", imported, pkgName)\n\t\t\t}\n\t\t}\n\t}\n\twalkImports(\"github.com/twitchtv/twirp\")\n}\n"
        },
        {
          "name": "version_constant.go",
          "type": "blob",
          "size": 0.8896484375,
          "content": "// Copyright 2018 Twitch Interactive, Inc.  All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n// use this file except in compliance with the License. A copy of the License is\n// located at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// or in the \"license\" file accompanying this file. This file is distributed on\n// an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n// express or implied. See the License for the specific language governing\n// permissions and limitations under the License.\n\npackage twirp\n\n// TwirpPackageIsVersion7 is a constant referenced from generated code to\n// assert version compatibility at compile time.\nconst TwirpPackageIsVersion7 = true\n\n// TwirpPackageMinVersion_8_1_0 is required from generated code to\n// assert version compatibility at compile time.\nconst TwirpPackageMinVersion_8_1_0 = true\n"
        },
        {
          "name": "website",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}