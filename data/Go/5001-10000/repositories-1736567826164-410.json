{
  "metadata": {
    "timestamp": 1736567826164,
    "page": 410,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tetratelabs/wazero",
      "stars": 5090,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.107421875,
          "content": "root = true\n\n[*]\ncharset = utf-8\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0810546875,
          "content": "# Improves experience of commands like `make format` on Windows\n* text=auto eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.7421875,
          "content": "# If you prefer the allow list template instead of the deny list, see community template:\n# https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gitignore\n#\n# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n/wazero\nbuild\ndist\n\n# Test binary, built with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Dependency directories (remove the comment below to include it)\n# vendor/\n\n# Go workspace file\ngo.work\n\n# Goland\n.idea\n\n# AssemblyScript\nnode_modules\npackage-lock.json\n\n# codecov.io\n/coverage.txt\n\n.vagrant\n\nzig-cache/\nzig-out/\n\n.DS_Store\n\n# Ignore compiled stdlib test cases.\n/internal/integration_test/stdlibs/testdata\n/internal/integration_test/libsodium/testdata\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.1279296875,
          "content": "[submodule \"site/themes/hello-friend\"]\n\tpath = site/themes/hello-friend\n\turl = https://github.com/panr/hugo-theme-hello-friend.git\n"
        },
        {
          "name": ".netlify",
          "type": "tree",
          "content": null
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 3.630859375,
          "content": "# Contributing\n\nWe welcome contributions from the community. Please read the following guidelines carefully to maximize the chances of your PR being merged.\n\n## Coding Style\n\n- To ensure your change passes format checks, run `make check`. To format your files, you can run `make format`.\n- We follow standard Go table-driven tests and use an internal [testing library](./internal/testing/require) to assert correctness. To verify all tests pass, you can run `make test`.\n\n## DCO\n\nWe require DCO signoff line in every commit to this repo.\n\nThe sign-off is a simple line at the end of the explanation for the\npatch, which certifies that you wrote it or otherwise have the right to\npass it on as an open-source patch. The rules are pretty simple: if you\ncan certify the below (from\n[developercertificate.org](https://developercertificate.org/)):\n\n```\nDeveloper Certificate of Origin\nVersion 1.1\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n660 York Street, Suite 102,\nSan Francisco, CA 94110 USA\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\nDeveloper's Certificate of Origin 1.1\nBy making a contribution to this project, I certify that:\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.\n```\n\nthen you just add a line to every git commit message:\n\n    Signed-off-by: Joe Smith <joe@gmail.com>\n\nusing your real name (sorry, no pseudonyms or anonymous contributions.)\n\nYou can add the sign off when creating the git commit via `git commit -s`.\n\n## Code Reviews\n\n* The pull request title should describe what the change does and not embed issue numbers.\nThe pull request should only be blank when the change is minor. Any feature should include\na description of the change and what motivated it. If the change or design changes through\nreview, please keep the title and description updated accordingly.\n* A single approval is sufficient to merge. If a reviewer asks for\nchanges in a PR they should be addressed before the PR is merged,\neven if another reviewer has already approved the PR.\n* During the review, address the comments and commit the changes\n_without_ squashing the commits. This facilitates incremental reviews\nsince the reviewer does not go through all the code again to find out\nwhat has changed since the last review. When a change goes out of sync with main,\nplease rebase and force push, keeping the original commits where practical.\n* Commits are squashed prior to merging a pull request, using the title\nas commit message by default. Maintainers may request contributors to\nedit the pull request tite to ensure that it remains descriptive as a\ncommit message. Alternatively, maintainers may change the commit message directly.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0830078125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2020-2023 wazero authors\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 18.0419921875,
          "content": "\ngofumpt       := mvdan.cc/gofumpt@v0.6.0\ngosimports    := github.com/rinchsan/gosimports/cmd/gosimports@v0.3.8\ngolangci_lint := github.com/golangci/golangci-lint/cmd/golangci-lint@v1.60.0\nasmfmt        := github.com/klauspost/asmfmt/cmd/asmfmt@v1.3.2\n# sync this with netlify.toml!\nhugo          := github.com/gohugoio/hugo@v0.115.2\n\n# Make 3.81 doesn't support '**' globbing: Set explicitly instead of recursion.\nall_sources   := $(wildcard *.go */*.go */*/*.go */*/*/*.go */*/*/*.go */*/*/*/*.go)\nall_testdata  := $(wildcard testdata/* */testdata/* */*/testdata/* */*/testdata/*/* */*/*/testdata/*)\nall_testing   := $(wildcard internal/testing/* internal/testing/*/* internal/testing/*/*/*)\nall_examples  := $(wildcard examples/* examples/*/* examples/*/*/* */*/example/* */*/example/*/* */*/example/*/*/*)\nall_it        := $(wildcard internal/integration_test/* internal/integration_test/*/* internal/integration_test/*/*/*)\n# main_sources exclude any test or example related code\nmain_sources  := $(wildcard $(filter-out %_test.go $(all_testdata) $(all_testing) $(all_examples) $(all_it), $(all_sources)))\n# main_packages collect the unique main source directories (sort will dedupe).\n# Paths need to all start with ./, so we do that manually vs foreach which strips it.\nmain_packages := $(sort $(foreach f,$(dir $(main_sources)),$(if $(findstring ./,$(f)),./,./$(f))))\n\ngo_test_options ?= -timeout 300s\n\n.PHONY: test.examples\ntest.examples:\n\t@go test $(go_test_options) ./examples/... ./imports/assemblyscript/example/... ./imports/emscripten/... ./imports/wasi_snapshot_preview1/example/...\n\n.PHONY: build.examples.as\nbuild.examples.as:\n\t@cd ./imports/assemblyscript/example/testdata && npm install && npm run build\n\n%.wasm: %.zig\n\t@(cd $(@D); zig build -Doptimize=ReleaseSmall)\n\t@mv $(@D)/zig-out/*/$(@F) $(@D)\n\n.PHONY: build.examples.zig\nbuild.examples.zig: examples/allocation/zig/testdata/greet.wasm imports/wasi_snapshot_preview1/example/testdata/zig/cat.wasm imports/wasi_snapshot_preview1/testdata/zig/wasi.wasm\n\t@cd internal/testing/dwarftestdata/testdata/zig; zig build; mv zig-out/*/main.wasm ./ # Need DWARF custom sections.\n\ntinygo_sources := examples/basic/testdata/add.go examples/allocation/tinygo/testdata/greet.go examples/cli/testdata/cli.go imports/wasi_snapshot_preview1/example/testdata/tinygo/cat.go imports/wasi_snapshot_preview1/testdata/tinygo/wasi.go cmd/wazero/testdata/cat/cat.go\n.PHONY: build.examples.tinygo\nbuild.examples.tinygo: $(tinygo_sources)\n\t@for f in $^; do \\\n\t    tinygo build -o $$(echo $$f | sed -e 's/\\.go/\\.wasm/') -scheduler=none --no-debug --target=wasi $$f; \\\n\tdone\n\t@mv cmd/wazero/testdata/cat/cat.wasm cmd/wazero/testdata/cat/cat-tinygo.wasm\n\n# We use zig to build C as it is easy to install and embeds a copy of zig-cc.\n# Note: Don't use \"-Oz\" as that breaks our wasi sock example.\nc_sources := imports/wasi_snapshot_preview1/example/testdata/zig-cc/cat.c imports/wasi_snapshot_preview1/testdata/zig-cc/wasi.c internal/testing/dwarftestdata/testdata/zig-cc/main.c\n.PHONY: build.examples.zig-cc\nbuild.examples.zig-cc: $(c_sources)\n\t@for f in $^; do \\\n\t    zig cc --target=wasm32-wasi -o $$(echo $$f | sed -e 's/\\.c/\\.wasm/') $$f; \\\n\tdone\n\n# Here are the emcc args we use:\n#\n# * `-Oz` - most optimization for code size.\n# * `--profiling` - adds the name section.\n# * `-s STANDALONE_WASM` - ensures wasm is built for a non-js runtime.\n# * `-s EXPORTED_FUNCTIONS=_malloc,_free` - export allocation functions so that\n#   they can be used externally as \"malloc\" and \"free\".\n# * `-s WARN_ON_UNDEFINED_SYMBOLS=0` - imports not defined in JavaScript error\n#   otherwise. See https://github.com/emscripten-core/emscripten/issues/13641\n# * `-s TOTAL_STACK=8KB -s TOTAL_MEMORY=64KB` - reduce memory default from 16MB\n#   to one page (64KB). To do this, we have to reduce the stack size.\n# * `-s ALLOW_MEMORY_GROWTH` - allows \"memory.grow\" instructions to succeed, but\n#   requires a function import \"emscripten_notify_memory_growth\".\nemscripten_sources := $(wildcard imports/emscripten/testdata/*.cc)\n.PHONY: build.examples.emscripten\nbuild.examples.emscripten: $(emscripten_sources)\n\t@for f in $^; do \\\n\t\tem++ -Oz --profiling \\\n\t\t-s STANDALONE_WASM \\\n\t\t-s EXPORTED_FUNCTIONS=_malloc,_free \\\n\t\t-s WARN_ON_UNDEFINED_SYMBOLS=0 \\\n\t\t-s TOTAL_STACK=8KB -s TOTAL_MEMORY=64KB \\\n\t\t-s ALLOW_MEMORY_GROWTH \\\n\t\t--std=c++17 -o $$(echo $$f | sed -e 's/\\.cc/\\.wasm/') $$f; \\\n\tdone\n\n%/greet.wasm : cargo_target := wasm32-unknown-unknown\n%/cat.wasm : cargo_target := wasm32-wasi\n%/wasi.wasm : cargo_target := wasm32-wasi\n\n.PHONY: build.examples.rust\nbuild.examples.rust: examples/allocation/rust/testdata/greet.wasm imports/wasi_snapshot_preview1/example/testdata/cargo-wasi/cat.wasm imports/wasi_snapshot_preview1/testdata/cargo-wasi/wasi.wasm internal/testing/dwarftestdata/testdata/rust/main.wasm.xz\n\n# Normally, we build release because it is smaller. Testing dwarf requires the debug build.\ninternal/testing/dwarftestdata/testdata/rust/main.wasm.xz:\n\tcd $(@D) && cargo wasi build\n\tmv $(@D)/target/wasm32-wasi/debug/main.wasm $(@D)\n\tcd $(@D) && xz -k -f ./main.wasm # Rust's DWARF section is huge, so compress it.\n\n# Builds rust using cargo normally, or cargo-wasi.\n%.wasm: %.rs\n\t@(cd $(@D); cargo $(if $(findstring wasi,$(cargo_target)),wasi build,build --target $(cargo_target)) --release)\n\t@mv $(@D)/target/$(cargo_target)/release/$(@F) $(@D)\n\nspectest_base_dir := internal/integration_test/spectest\nspectest_v1_dir := $(spectest_base_dir)/v1\nspectest_v1_testdata_dir := $(spectest_v1_dir)/testdata\nspec_version_v1 := wg-1.0\nspectest_v2_dir := $(spectest_base_dir)/v2\nspectest_v2_testdata_dir := $(spectest_v2_dir)/testdata\n# Latest draft state as of March 12, 2024.\nspec_version_v2 := 1c5e5d178bd75c79b7a12881c529098beaee2a05\nspectest_threads_dir := $(spectest_base_dir)/threads\nspectest_threads_testdata_dir := $(spectest_threads_dir)/testdata\n# From https://github.com/WebAssembly/threads/tree/upstream-rebuild which has not been merged to main yet.\n# It will likely be renamed to main in the future - https://github.com/WebAssembly/threads/issues/216.\nspec_version_threads := 3635ca51a17e57e106988846c5b0e0cc48ac04fc\n\n.PHONY: build.spectest\nbuild.spectest:\n\t@$(MAKE) build.spectest.v1\n\t@$(MAKE) build.spectest.v2\n\n.PHONY: build.spectest.v1\nbuild.spectest.v1: # Note: wabt by default uses >1.0 features, so wast2json flags might drift as they include more. See WebAssembly/wabt#1878\n\t@rm -rf $(spectest_v1_testdata_dir)\n\t@mkdir -p $(spectest_v1_testdata_dir)\n\t@cd $(spectest_v1_testdata_dir) \\\n\t\t&& curl -sSL 'https://api.github.com/repos/WebAssembly/spec/contents/test/core?ref=$(spec_version_v1)' | jq -r '.[]| .download_url' | grep -E \".wast\" | xargs -Iurl curl -sJL url -O\n\t@cd $(spectest_v1_testdata_dir) && for f in `find . -name '*.wast'`; do \\\n\t\tperl -pi -e 's/\\(assert_return_canonical_nan\\s(\\(invoke\\s\"f32.demote_f64\"\\s\\((f[0-9]{2})\\.const\\s[a-z0-9.+:-]+\\)\\))\\)/\\(assert_return $$1 \\(f32.const nan:canonical\\)\\)/g' $$f; \\\n\t\tperl -pi -e 's/\\(assert_return_arithmetic_nan\\s(\\(invoke\\s\"f32.demote_f64\"\\s\\((f[0-9]{2})\\.const\\s[a-z0-9.+:-]+\\)\\))\\)/\\(assert_return $$1 \\(f32.const nan:arithmetic\\)\\)/g' $$f; \\\n\t\tperl -pi -e 's/\\(assert_return_canonical_nan\\s(\\(invoke\\s\"f64\\.promote_f32\"\\s\\((f[0-9]{2})\\.const\\s[a-z0-9.+:-]+\\)\\))\\)/\\(assert_return $$1 \\(f64.const nan:canonical\\)\\)/g' $$f; \\\n\t\tperl -pi -e 's/\\(assert_return_arithmetic_nan\\s(\\(invoke\\s\"f64\\.promote_f32\"\\s\\((f[0-9]{2})\\.const\\s[a-z0-9.+:-]+\\)\\))\\)/\\(assert_return $$1 \\(f64.const nan:arithmetic\\)\\)/g' $$f; \\\n\t\tperl -pi -e 's/\\(assert_return_canonical_nan\\s(\\(invoke\\s\"[a-z._0-9]+\"\\s\\((f[0-9]{2})\\.const\\s[a-z0-9.+:-]+\\)\\))\\)/\\(assert_return $$1 \\($$2.const nan:canonical\\)\\)/g' $$f; \\\n\t\tperl -pi -e 's/\\(assert_return_arithmetic_nan\\s(\\(invoke\\s\"[a-z._0-9]+\"\\s\\((f[0-9]{2})\\.const\\s[a-z0-9.+:-]+\\)\\))\\)/\\(assert_return $$1 \\($$2.const nan:arithmetic\\)\\)/g' $$f; \\\n\t\tperl -pi -e 's/\\(assert_return_canonical_nan\\s(\\(invoke\\s\"[a-z._0-9]+\"\\s\\((f[0-9]{2})\\.const\\s[a-z0-9.+:-]+\\)\\s\\([a-z0-9.\\s+-:]+\\)\\))\\)/\\(assert_return $$1 \\($$2.const nan:canonical\\)\\)/g' $$f; \\\n\t\tperl -pi -e 's/\\(assert_return_arithmetic_nan\\s(\\(invoke\\s\"[a-z._0-9]+\"\\s\\((f[0-9]{2})\\.const\\s[a-z0-9.+:-]+\\)\\s\\([a-z0-9.\\s+-:]+\\)\\))\\)/\\(assert_return $$1 \\($$2.const nan:arithmetic\\)\\)/g' $$f; \\\n\t\tperl -pi -e 's/\\(assert_return_canonical_nan\\s(\\(invoke\\s\"[a-z._0-9]+\"\\s\\((f[0-9]{2})\\.const\\s[a-z0-9.+:-]+\\)\\))\\)/\\(assert_return $$1 \\($$2.const nan:canonical\\)\\)/g' $$f; \\\n\t\tperl -pi -e 's/\\(assert_return_arithmetic_nan\\s(\\(invoke\\s\"[a-z._0-9]+\"\\s\\((f[0-9]{2})\\.const\\s[a-z0-9.+:-]+\\)\\))\\)/\\(assert_return $$1 \\($$2.const nan:arithmetic\\)\\)/g' $$f; \\\n\t\twast2json \\\n\t\t\t--disable-saturating-float-to-int \\\n\t\t\t--disable-sign-extension \\\n\t\t\t--disable-simd \\\n\t\t\t--disable-multi-value \\\n\t\t\t--disable-bulk-memory \\\n\t\t\t--disable-reference-types \\\n\t\t\t--debug-names $$f; \\\n\tdone\n\n.PHONY: build.spectest.v2\nbuild.spectest.v2: # Note: SIMD cases are placed in the \"simd\" subdirectory.\n\t@mkdir -p $(spectest_v2_testdata_dir)\n\t@cd $(spectest_v2_testdata_dir) \\\n\t\t&& curl -sSL 'https://api.github.com/repos/WebAssembly/spec/contents/test/core?ref=$(spec_version_v2)' | jq -r '.[]| .download_url' | grep -E \".wast\" | xargs -Iurl curl -sJL url -O\n\t@cd $(spectest_v2_testdata_dir) \\\n\t\t&& curl -sSL 'https://api.github.com/repos/WebAssembly/spec/contents/test/core/simd?ref=$(spec_version_v2)' | jq -r '.[]| .download_url' | grep -E \".wast\" | xargs -Iurl curl -sJL url -O\n\t@cd $(spectest_v2_testdata_dir) && for f in `find . -name '*.wast'`; do \\\n\t\twast2json --debug-names --no-check $$f || true; \\\n\tdone # Ignore the error here as some tests (e.g. comments.wast right now) are not supported by wast2json yet.\n\n# Note: We currently cannot build the \"threads\" subdirectory that spawns threads due to missing support in wast2json.\n# https://github.com/WebAssembly/wabt/issues/2348#issuecomment-1878003959\n.PHONY: build.spectest.threads\nbuild.spectest.threads:\n\t@mkdir -p $(spectest_threads_testdata_dir)\n\t@cd $(spectest_threads_testdata_dir) \\\n\t\t&& curl -sSL 'https://api.github.com/repos/WebAssembly/threads/contents/test/core?ref=$(spec_version_threads)' | jq -r '.[]| .download_url' | grep -E \"atomic.wast\" | xargs -Iurl curl -sJL url -O\n\t@cd $(spectest_threads_testdata_dir) && for f in `find . -name '*.wast'`; do \\\n\t\twast2json --enable-threads --debug-names $$f; \\\n\tdone\n\n.PHONY: test\ntest:\n\t@go test $(go_test_options) ./...\n\t@cd internal/version/testdata && go test $(go_test_options) ./...\n\t@cd internal/integration_test/fuzz/wazerolib && CGO_ENABLED=0 WASM_BINARY_PATH=testdata/test.wasm go test ./...\n\n.PHONY: coverage\n# replace spaces with commas\ncoverpkg = $(shell echo $(main_packages) | tr ' ' ',')\ncoverage: ## Generate test coverage\n\t@go test -coverprofile=coverage.txt -covermode=atomic --coverpkg=$(coverpkg) $(main_packages)\n\t@go tool cover -func coverage.txt\n\ngolangci_lint_path := $(shell go env GOPATH)/bin/golangci-lint\n\n$(golangci_lint_path):\n\t@go install $(golangci_lint)\n\ngolangci_lint_goarch ?= $(shell go env GOARCH)\n\n.PHONY: lint\nlint: $(golangci_lint_path)\n\t@GOARCH=$(golangci_lint_goarch) CGO_ENABLED=0 $(golangci_lint_path) run --timeout 5m -E testableexamples\n\n.PHONY: format\nformat:\n\t@go run $(gofumpt) -l -w .\n\t@go run $(gosimports) -local github.com/tetratelabs/ -w $(shell find . -name '*.go' -type f)\n\t@go run $(asmfmt) -w $(shell find . -name '*.s' -type f)\n\n.PHONY: check  # Pre-flight check for pull requests\ncheck:\n# The following checks help ensure our platform-specific code used for system\n# calls safely falls back on a platform unsupported by the compiler engine.\n# This makes sure the intepreter can be used. Most often the package that can\n# drift here is \"platform\" or \"sysfs\":\n#\n# Ensure we build on plan9. See #1578\n\t@GOARCH=amd64 GOOS=plan9 go build ./...\n# Ensure we build on gojs. See #1526.\n\t@GOARCH=wasm GOOS=js go build ./...\n# Ensure we build on wasip1. See #1526.\n\t@GOARCH=wasm GOOS=wasip1 go build ./...\n# Ensure we build on aix. See #1723\n\t@GOARCH=ppc64 GOOS=aix go build ./...\n# Ensure we build on windows:\n\t@GOARCH=amd64 GOOS=windows go build ./...\n# Ensure we build on an arbitrary operating system:\n\t@GOARCH=amd64 GOOS=dragonfly go build ./...\n# Ensure we build on solaris/illumos:\n\t@GOARCH=amd64 GOOS=illumos go build ./...\n\t@GOARCH=amd64 GOOS=solaris go build ./...\n# Ensure we build on linux arm for Dapr:\n#\tgh release view -R dapr/dapr --json assets --jq 'first(.assets[] | select(.name = \"daprd_linux_arm.tar.gz\") | {url, downloadCount})'\n\t@GOARCH=arm GOOS=linux go build ./...\n# Ensure we build on linux 386 for Trivy:\n#\tgh release view -R aquasecurity/trivy --json assets --jq 'first(.assets[] | select(.name| test(\"Linux-32bit.*tar.gz\")) | {url, downloadCount})'\n\t@GOARCH=386 GOOS=linux go build ./...\n# Ensure we build on FreeBSD amd64 for Trivy:\n#\tgh release view -R aquasecurity/trivy --json assets --jq 'first(.assets[] | select(.name| test(\"FreeBSD-64bit.*tar.gz\")) | {url, downloadCount})'\n\t@GOARCH=amd64 GOOS=freebsd go build ./...\n\t@$(MAKE) lint golangci_lint_goarch=arm64\n\t@$(MAKE) lint golangci_lint_goarch=amd64\n\t@$(MAKE) format\n\t@go mod tidy\n\t@if [ ! -z \"`git status -s`\" ]; then \\\n\t\techo \"The following differences will fail CI until committed:\"; \\\n\t\tgit diff --exit-code; \\\n\tfi\n\n.PHONY: site\nsite: ## Serve website content\n\t@git submodule update --init\n\t@cd site && go run $(hugo) server --minify --disableFastRender --baseURL localhost:1313 --cleanDestinationDir -D\n\n.PHONY: clean\nclean: ## Ensure a clean build\n\t@rm -rf dist build coverage.txt\n\t@go clean -testcache\n\nfuzz_default_flags := --no-trace-compares --sanitizer=none -- -rss_limit_mb=8192\n\nfuzz_timeout_seconds ?= 10\n.PHONY: fuzz\nfuzz:\n\t@cd internal/integration_test/fuzz && cargo test\n\t@cd internal/integration_test/fuzz && cargo fuzz run logging_no_diff $(fuzz_default_flags) -max_total_time=$(fuzz_timeout_seconds)\n\t@cd internal/integration_test/fuzz && cargo fuzz run no_diff $(fuzz_default_flags) -max_total_time=$(fuzz_timeout_seconds)\n\t@cd internal/integration_test/fuzz && cargo fuzz run memory_no_diff $(fuzz_default_flags) -max_total_time=$(fuzz_timeout_seconds)\n\t@cd internal/integration_test/fuzz && cargo fuzz run validation $(fuzz_default_flags) -max_total_time=$(fuzz_timeout_seconds)\n\nlibsodium:\n\tcd ./internal/integration_test/libsodium/testdata && \\\n\t\tcurl -s \"https://api.github.com/repos/jedisct1/webassembly-benchmarks/contents/2022-12/wasm?ref=7e86d68e99e60130899fbe3b3ab6e9dce9187a7c\" \\\n\t\t| jq -r '.[] | .download_url' | xargs -n 1 curl -LO\n\n#### CLI release related ####\n\nVERSION ?= dev\n# Default to a dummy version 0.0.1.1, which is always lower than a real release.\n# Legal version values should look like 'x.x.x.x' where x is an integer from 0 to 65534.\n# https://learn.microsoft.com/en-us/windows/win32/msi/productversion?redirectedfrom=MSDN\n# https://stackoverflow.com/questions/9312221/msi-version-numbers\nMSI_VERSION ?= 0.0.1.1\nnon_windows_platforms := darwin_amd64 darwin_arm64 linux_amd64 linux_arm64\nnon_windows_archives  := $(non_windows_platforms:%=dist/wazero_$(VERSION)_%.tar.gz)\nwindows_platforms     := windows_amd64 # TODO: add arm64 windows once we start testing on it.\nwindows_archives      := $(windows_platforms:%=dist/wazero_$(VERSION)_%.zip) $(windows_platforms:%=dist/wazero_$(VERSION)_%.msi)\nchecksum_txt          := dist/wazero_$(VERSION)_checksums.txt\n\n# define macros for multi-platform builds. these parse the filename being built\ngo-arch = $(if $(findstring amd64,$1),amd64,arm64)\ngo-os   = $(if $(findstring .exe,$1),windows,$(if $(findstring linux,$1),linux,darwin))\n# msi-arch is a macro so we can detect it based on the file naming convention\nmsi-arch     = $(if $(findstring amd64,$1),x64,arm64)\n\nbuild/wazero_%/wazero:\n\t$(call go-build,$@,$<)\n\nbuild/wazero_%/wazero.exe:\n\t$(call go-build,$@,$<)\n\ndist/wazero_$(VERSION)_%.tar.gz: build/wazero_%/wazero\n\t@echo tar.gz \"tarring $@\"\n\t@mkdir -p $(@D)\n# On Windows, we pass the special flag `--mode='+rx' to ensure that we set the executable flag.\n# This is only supported by GNU Tar, so we set it conditionally.\n\t@tar -C $(<D) -cpzf $@ $(if $(findstring Windows_NT,$(OS)),--mode='+rx',) $(<F)\n\t@echo tar.gz \"ok\"\n\ndefine go-build\n\t@echo \"building $1\"\n\t@# $(go:go=) removes the trailing 'go', so we can insert cross-build variables\n\t@$(go:go=) CGO_ENABLED=0 GOOS=$(call go-os,$1) GOARCH=$(call go-arch,$1) go build \\\n\t\t-ldflags \"-s -w -X github.com/tetratelabs/wazero/internal/version.version=$(VERSION)\" \\\n\t\t-o $1 $2 ./cmd/wazero\n\t@echo build \"ok\"\nendef\n\n# this makes a marker file ending in .signed to avoid repeatedly calling codesign\n%.signed: %\n\t$(call codesign,$<)\n\t@touch $@\n\n# This requires osslsigncode package (apt or brew) or latest windows release from mtrojnar/osslsigncode\n#\n# Default is self-signed while production should be a Digicert signing key\n#\n# Ex.\n# ```bash\n# keytool -genkey -alias wazero -storetype PKCS12 -keyalg RSA -keysize 2048 -storepass wazero-bunch \\\n# -keystore wazero.p12 -dname \"O=wazero,CN=wazero.io\" -validity 3650\n# ```\nWINDOWS_CODESIGN_P12      ?= packaging/msi/wazero.p12\nWINDOWS_CODESIGN_PASSWORD ?= wazero-bunch\ndefine codesign\n\t@printf \"$(ansi_format_dark)\" codesign \"signing $1\"\n\t@osslsigncode sign -h sha256 -pkcs12 ${WINDOWS_CODESIGN_P12} -pass \"${WINDOWS_CODESIGN_PASSWORD}\" \\\n\t-n \"wazero is the zero dependency WebAssembly runtime for Go developers\" -i https://wazero.io -t http://timestamp.digicert.com \\\n\t$(if $(findstring msi,$(1)),-add-msi-dse) -in $1 -out $1-signed\n\t@mv $1-signed $1\n\t@printf \"$(ansi_format_bright)\" codesign \"ok\"\nendef\n\n# This task is only supported on Windows, where we use candle.exe (compile wxs to wixobj) and light.exe (link to msi)\ndist/wazero_$(VERSION)_%.msi: build/wazero_%/wazero.exe.signed\nifeq ($(OS),Windows_NT)\n\t@echo msi \"building $@\"\n\t@mkdir -p $(@D)\n\t@candle -nologo -arch $(call msi-arch,$@) -dVersion=$(MSI_VERSION) -dBin=$(<:.signed=) -o build/wazero.wixobj packaging/msi/wazero.wxs\n\t@light -nologo -o $@ build/wazero.wixobj -spdb\n\t$(call codesign,$@)\n\t@echo msi \"ok\"\nendif\n\ndist/wazero_$(VERSION)_%.zip: build/wazero_%/wazero.exe.signed\n\t@echo zip \"zipping $@\"\n\t@mkdir -p $(@D)\n\t@zip -qj $@ $(<:.signed=)\n\t@echo zip \"ok\"\n\n# Darwin doesn't have sha256sum. See https://github.com/actions/virtual-environments/issues/90\nsha256sum := $(if $(findstring darwin,$(shell go env GOOS)),shasum -a 256,sha256sum)\n$(checksum_txt):\n\t@cd $(@D); touch $(@F); $(sha256sum) * >> $(@F)\n\ndist: $(non_windows_archives) $(if $(findstring Windows_NT,$(OS)),$(windows_archives),) $(checksum_txt)\n"
        },
        {
          "name": "NOTICE",
          "type": "blob",
          "size": 0.041015625,
          "content": "wazero\nCopyright 2020-2023 wazero authors\n"
        },
        {
          "name": "RATIONALE.md",
          "type": "blob",
          "size": 83.736328125,
          "content": "# Notable rationale of wazero\n\n## Zero dependencies\n\nWazero has zero dependencies to differentiate itself from other runtimes which\nhave heavy impact usually due to CGO. By avoiding CGO, wazero avoids\nprerequisites such as shared libraries or libc, and lets users keep features\nlike cross compilation.\n\nAvoiding go.mod dependencies reduces interference on Go version support, and\nsize of a statically compiled binary. However, doing so brings some\nresponsibility into the project.\n\nGo's native platform support is good: We don't need platform-specific code to\nget monotonic time, nor do we need much work to implement certain features\nneeded by our compiler such as `mmap`. That said, Go does not support all\ncommon operating systems to the same degree. For example, Go 1.18 includes\n`Mprotect` on Linux and Darwin, but not FreeBSD.\n\nThe general tradeoff the project takes from a zero dependency policy is more\nexplicit support of platforms (in the compiler runtime), as well a larger and\nmore technically difficult codebase.\n\nAt some point, we may allow extensions to supply their own platform-specific\nhooks. Until then, one end user impact/tradeoff is some glitches trying\nuntested platforms (with the Compiler runtime).\n\n### Why do we use CGO to implement system calls on darwin?\n\nwazero is dependency and CGO free by design. In some cases, we have code that\ncan optionally use CGO, but retain a fallback for when that's disabled. The only\noperating system (`GOOS`) we use CGO by default in is `darwin`.\n\nUnlike other operating systems, regardless of `CGO_ENABLED`, Go always uses\n\"CGO\" mechanisms in the runtime layer of `darwin`. This is explained in\n[Statically linked binaries on Mac OS X](https://developer.apple.com/library/archive/qa/qa1118/_index.html#//apple_ref/doc/uid/DTS10001666):\n\n> Apple does not support statically linked binaries on Mac OS X. A statically\n> linked binary assumes binary compatibility at the kernel system call\n> interface, and we do not make any guarantees on that front. Rather, we strive\n> to ensure binary compatibility in each dynamically linked system library and\n> framework.\n\nThis plays to our advantage for system calls that aren't yet exposed in the Go\nstandard library, notably `futimens` for nanosecond-precision timestamp\nmanipulation.\n\n### Why not x/sys\n\nGoing beyond Go's SDK limitations can be accomplished with their [x/sys library](https://pkg.go.dev/golang.org/x/sys/unix).\nFor example, this includes `zsyscall_freebsd_amd64.go` missing from the Go SDK.\n\nHowever, like all dependencies, x/sys is a source of conflict. For example,\nx/sys had to be in order to upgrade to Go 1.18.\n\nIf we depended on x/sys, we could get more precise functionality needed for\nfeatures such as clocks or more platform support for the compiler runtime.\n\nThat said, formally supporting an operating system may still require testing as\neven use of x/sys can require platform-specifics. For example, [mmap-go](https://github.com/edsrzf/mmap-go)\nuses x/sys, but also mentions limitations, some not surmountable with x/sys\nalone.\n\nRegardless, we may at some point introduce a separate go.mod for users to use\nx/sys as a platform plugin without forcing all users to maintain that\ndependency.\n\n## Project structure\n\nwazero uses internal packages extensively to balance API compatibility desires for end users with the need to safely\nshare internals between compilers.\n\nEnd-user packages include `wazero`, with `Config` structs, `api`, with shared types, and the built-in `wasi` library.\nEverything else is internal.\n\nWe put the main program for wazero into a directory of the same name to match conventions used in `go install`,\nnotably the name of the folder becomes the binary name. We chose to use `cmd/wazero` as it is common practice\nand less surprising than `wazero/wazero`.\n\n### Internal packages\n\nMost code in wazero is internal, and it is acknowledged that this prevents external implementation of facets such as\ncompilers or decoding. It also prevents splitting this code into separate repositories, resulting in a larger monorepo.\nThis also adds work as more code needs to be centrally reviewed.\n\nHowever, the alternative is neither secure nor viable. To allow external implementation would require exporting symbols\npublic, such as the `CodeSection`, which can easily create bugs. Moreover, there's a high drift risk for any attempt at\nexternal implementations, compounded not just by wazero's code organization, but also the fast moving Wasm and WASI\nspecifications.\n\nFor example, implementing a compiler correctly requires expertise in Wasm, Golang and assembly. This requires deep\ninsight into how internals are meant to be structured and the various tiers of testing required for `wazero` to result\nin a high quality experience. Even if someone had these skills, supporting external code would introduce variables which\nare constants in the central one. Supporting an external codebase is harder on the project team, and could starve time\nfrom the already large burden on the central codebase.\n\nThe tradeoffs of internal packages are a larger codebase and responsibility to implement all standard features. It also\nimplies thinking about extension more as forking is not viable for reasons above also. The primary mitigation of these\nrealities are friendly OSS licensing, high rigor and a collaborative spirit which aim to make contribution in the shared\ncodebase productive.\n\n### Avoiding cyclic dependencies\n\nwazero shares constants and interfaces with internal code by a sharing pattern described below:\n* shared interfaces and constants go in one package under root: `api`.\n* user APIs and structs depend on `api` and go into the root package `wazero`.\n  * e.g. `InstantiateModule` -> `/wasm.go` depends on the type `api.Module`.\n* implementation code can also depend on `api` in a corresponding package under `/internal`.\n  * Ex  package `wasm` -> `/internal/wasm/*.go` and can depend on the type `api.Module`.\n\nThe above guarantees no cyclic dependencies at the cost of having to re-define symbols that exist in both packages.\nFor example, if `wasm.Store` is a type the user needs access to, it is narrowed by a cover type in the `wazero`:\n\n```go\ntype runtime struct {\n\ts *wasm.Store\n}\n```\n\nThis is not as bad as it sounds as mutations are only available via configuration. This means exported functions are\nlimited to only a few functions.\n\n### Avoiding security bugs\n\nIn order to avoid security flaws such as code insertion, nothing in the public API is permitted to write directly to any\nmutable symbol in the internal package. For example, the package `api` is shared with internal code. To ensure\nimmutability, the `api` package cannot contain any mutable public symbol, such as a slice or a struct with an exported\nfield.\n\nIn practice, this means shared functionality like memory mutation need to be implemented by interfaces.\n\nHere are some examples:\n* `api.Memory` protects access by exposing functions like `WriteFloat64Le` instead of exporting a buffer (`[]byte`).\n* There is no exported symbol for the `[]byte` representing the `CodeSection`\n\nBesides security, this practice prevents other bugs and allows centralization of validation logic such as decoding Wasm.\n\n## API Design\n\n### Why is `context.Context` inconsistent?\n\nIt may seem strange that only certain API have an initial `context.Context`\nparameter. We originally had a `context.Context` for anything that might be\ntraced, but it turned out to be only useful for lifecycle and host functions.\n\nFor instruction-scoped aspects like memory updates, a context parameter is too\nfine-grained and also invisible in practice. For example, most users will use\nthe compiler engine, and its memory, global or table access will never use go's\ncontext.\n\n### Why does `api.ValueType` map to uint64?\n\nWebAssembly allows functions to be defined either by the guest or the host,\nwith signatures expressed as WebAssembly types. For example, `i32` is a 32-bit\ntype which might be interpreted as signed. Function signatures can have zero or\nmore parameters or results even if WebAssembly 1.0 allows up to one result.\n\nThe guest can export functions, so that the host can call it. In the case of\nwazero, the host is Go and an exported function can be called via\n`api.Function`. `api.Function` allows users to supply parameters and read\nresults as a slice of uint64. For example, if there are no results, an empty\nslice is returned. The user can learn the signature via `FunctionDescription`,\nwhich returns the `api.ValueType` corresponding to each parameter or result.\n`api.ValueType` defines the mapping of WebAssembly types to `uint64` values for\nreason described in this section. The special case of `v128` is also mentioned\nbelow.\n\nwazero maps each value type to a uint64 values because it holds the largest\ntype in WebAssembly 1.0 (i64). A slice allows you to express empty (e.g. a\nnullary signature), for example a start function.\n\nHere's an example of calling a function, noting this syntax works for both a\nsignature `(param i32 i32) (result i32)` and `(param i64 i64) (result i64)`\n```go\nx, y := uint64(1), uint64(2)\nresults, err := mod.ExportedFunction(\"add\").Call(ctx, x, y)\nif err != nil {\n\tlog.Panicln(err)\n}\nfmt.Printf(\"%d + %d = %d\\n\", x, y, results[0])\n```\n\nWebAssembly does not define an encoding strategy for host defined parameters or\nresults. This means the encoding rules above are defined by wazero instead. To\naddress this, we clarified mapping both in `api.ValueType` and added helper\nfunctions like `api.EncodeF64`. This allows users conversions typical in Go\nprogramming, and utilities to avoid ambiguity and edge cases around casting.\n\nAlternatively, we could have defined a byte buffer based approach and a binary\nencoding of value types in and out. For example, an empty byte slice would mean\nno values, while a non-empty could use a binary encoding for supported values.\nThis could work, but it is more difficult for the normal case of i32 and i64.\nIt also shares a struggle with the current approach, which is that value types\nwere added after WebAssembly 1.0 and not all of them have an encoding. More on\nthis below.\n\nIn summary, wazero chose an approach for signature mapping because there was\nnone, and the one we chose biases towards simplicity with integers and handles\nthe rest with documentation and utilities.\n\n#### Post 1.0 value types\n\nValue types added after WebAssembly 1.0 stressed the current model, as some\nhave no encoding or are larger than 64 bits. While problematic, these value\ntypes are not commonly used in exported (extern) functions. However, some\ndecisions were made and detailed below.\n\nFor example `externref` has no guest representation. wazero chose to map\nreferences to uint64 as that's the largest value needed to encode a pointer on\nsupported platforms. While there are two reference types, `externref` and\n`functype`, the latter is an internal detail of function tables, and the former\nis rarely if ever used in function signatures as of the end of 2022.\n\nThe only value larger than 64 bits is used for SIMD (`v128`). Vectorizing via\nhost functions is not used as of the end of 2022. Even if it were, it would be\ninefficient vs guest vectorization due to host function overhead. In other\nwords, the `v128` value type is unlikely to be in an exported function\nsignature. That it requires two uint64 values to encode is an internal detail\nand not worth changing the exported function interface `api.Function`, as doing\nso would break all users.\n\n### Interfaces, not structs\n\nAll exported types in public packages, regardless of configuration vs runtime, are interfaces. The primary benefits are\ninternal flexibility and avoiding people accidentally mis-initializing by instantiating the types on their own vs using\nthe `NewXxx` constructor functions. In other words, there's less support load when things can't be done incorrectly.\n\nHere's an example:\n```go\nrt := &RuntimeConfig{} // not initialized properly (fields are nil which shouldn't be)\nrt := RuntimeConfig{} // not initialized properly (should be a pointer)\nrt := wazero.NewRuntimeConfig() // initialized properly\n```\n\nThere are a few drawbacks to this, notably some work for maintainers.\n* Interfaces are decoupled from the structs implementing them, which means the signature has to be repeated twice.\n* Interfaces have to be documented and guarded at time of use, that 3rd party implementations aren't supported.\n* As of Golang 1.21, interfaces are still [not well supported](https://github.com/golang/go/issues/5860) in godoc.\n\n## Config\n\nwazero configures scopes such as Runtime and Module using `XxxConfig` types. For example, `RuntimeConfig` configures\n`Runtime` and `ModuleConfig` configure `Module` (instantiation). In all cases, config types begin defaults and can be\ncustomized by a user, e.g., selecting features or a module name override.\n\n### Why don't we make each configuration setting return an error?\nNo config types create resources that would need to be closed, nor do they return errors on use. This helps reduce\nresource leaks, and makes chaining easier. It makes it possible to parse configuration (ex by parsing yaml) independent\nof validating it.\n\nInstead of:\n```\ncfg, err = cfg.WithFS(fs)\nif err != nil {\n  return err\n}\ncfg, err = cfg.WithName(name)\nif err != nil {\n  return err\n}\nmod, err = rt.InstantiateModuleWithConfig(ctx, code, cfg)\nif err != nil {\n  return err\n}\n```\n\nThere's only one call site to handle errors:\n```\ncfg = cfg.WithFS(fs).WithName(name)\nmod, err = rt.InstantiateModuleWithConfig(ctx, code, cfg)\nif err != nil {\n  return err\n}\n```\n\nThis allows users one place to look for errors, and also the benefit that if anything internally opens a resource, but\nerrs, there's nothing they need to close. In other words, users don't need to track which resources need closing on\npartial error, as that is handled internally by the only code that can read configuration fields.\n\n### Why are configuration immutable?\nWhile it seems certain scopes like `Runtime` won't repeat within a process, they do, possibly in different goroutines.\nFor example, some users create a new runtime for each module, and some re-use the same base module configuration with\nonly small updates (ex the name) for each instantiation. Making configuration immutable allows them to be safely used in\nany goroutine.\n\nSince config are immutable, changes apply via return val, similar to `append` in a slice.\n\nFor example, both of these are the same sort of error:\n```go\nappend(slice, element) // bug as only the return value has the updated slice.\ncfg.WithName(next) // bug as only the return value has the updated name.\n```\n\nHere's an example of correct use: re-assigning explicitly or via chaining.\n```go\ncfg = cfg.WithName(name) // explicit\n\nmod, err = rt.InstantiateModuleWithConfig(ctx, code, cfg.WithName(name)) // implicit\nif err != nil {\n  return err\n}\n```\n\n### Why aren't configuration assigned with option types?\nThe option pattern is a familiar one in Go. For example, someone defines a type `func (x X) err` and uses it to update\nthe target. For example, you could imagine wazero could choose to make `ModuleConfig` from options vs chaining fields.\n\nEx instead of:\n```go\ntype ModuleConfig interface {\n\tWithName(string) ModuleConfig\n\tWithFS(fs.FS) ModuleConfig\n}\n\nstruct moduleConfig {\n\tname string\n\tfs fs.FS\n}\n\nfunc (c *moduleConfig) WithName(name string) ModuleConfig {\n    ret := *c // copy\n    ret.name = name\n    return &ret\n}\n\nfunc (c *moduleConfig) WithFS(fs fs.FS) ModuleConfig {\n    ret := *c // copy\n    ret.setFS(\"/\", fs)\n    return &ret\n}\n\nconfig := r.NewModuleConfig().WithFS(fs)\nconfigDerived := config.WithName(\"name\")\n```\n\nAn option function could be defined, then refactor each config method into an name prefixed option function:\n```go\ntype ModuleConfig interface {\n}\nstruct moduleConfig {\n    name string\n    fs fs.FS\n}\n\ntype ModuleConfigOption func(c *moduleConfig)\n\nfunc ModuleConfigName(name string) ModuleConfigOption {\n    return func(c *moduleConfig) {\n        c.name = name\n\t}\n}\n\nfunc ModuleConfigFS(fs fs.FS) ModuleConfigOption {\n    return func(c *moduleConfig) {\n        c.fs = fs\n    }\n}\n\nfunc (r *runtime) NewModuleConfig(opts ...ModuleConfigOption) ModuleConfig {\n\tret := newModuleConfig() // defaults\n    for _, opt := range opts {\n        opt(&ret.config)\n    }\n    return ret\n}\n\nfunc (c *moduleConfig) WithOptions(opts ...ModuleConfigOption) ModuleConfig {\n    ret := *c // copy base config\n    for _, opt := range opts {\n        opt(&ret.config)\n    }\n    return ret\n}\n\nconfig := r.NewModuleConfig(ModuleConfigFS(fs))\nconfigDerived := config.WithOptions(ModuleConfigName(\"name\"))\n```\n\nwazero took the path of the former design primarily due to:\n* interfaces provide natural namespaces for their methods, which is more direct than functions with name prefixes.\n* parsing config into function callbacks is more direct vs parsing config into a slice of functions to do the same.\n* in either case derived config is needed and the options pattern is more awkward to achieve that.\n\nThere are other reasons such as test and debug being simpler without options: the above list is constrained to conserve\nspace. It is accepted that the options pattern is common in Go, which is the main reason for documenting this decision.\n\n### Why aren't config types deeply structured?\nwazero's configuration types cover the two main scopes of WebAssembly use:\n* `RuntimeConfig`: This is the broadest scope, so applies also to compilation\n  and instantiation. e.g. This controls the WebAssembly Specification Version.\n* `ModuleConfig`: This affects modules instantiated after compilation and what\n  resources are allowed. e.g. This defines how or if STDOUT is captured. This\n  also allows sub-configuration of `FSConfig`.\n\nThese default to a flat definition each, with lazy sub-configuration only after\nproven to be necessary. A flat structure is easier to work with and is also\neasy to discover. Unlike the option pattern described earlier, more\nconfiguration in the interface doesn't taint the package namespace, only\n`ModuleConfig`.\n\nWe default to a flat structure to encourage simplicity. If we eagerly broke out\nall possible configurations into sub-types (e.g. ClockConfig), it would be hard\nto notice configuration sprawl. By keeping the config flat, it is easy to see\nthe cognitive load we may be adding to our users.\n\nIn other words, discomfort adding more configuration is a feature, not a bug.\nWe should only add new configuration rarely, and before doing so, ensure it\nwill be used. In fact, this is why we support using context fields for\nexperimental configuration. By letting users practice, we can find out if a\nconfiguration was a good idea or not before committing to it, and potentially\nsprawling our types.\n\nIn reflection, this approach worked well for the nearly 1.5 year period leading\nto version 1.0. We've only had to create a single sub-configuration, `FSConfig`,\nand it was well understood why when it occurred.\n\n## Why does `ModuleConfig.WithStartFunctions` default to `_start`?\n\nWe formerly had functions like `StartWASICommand` that would verify\npreconditions and start WASI's `_start` command. However, this caused confusion\nbecause both many languages compiled a WASI dependency, and many did so\ninconsistently.\n\nThe conflict is that exported functions need to use features the language\nruntime provides, such as garbage collection. There's a \"chicken-egg problem\"\nwhere `_start` needs to complete in order for exported behavior to work.\n\nFor example, unlike `GOOS=wasip1` in Go 1.21, TinyGo's \"wasi\" target supports\nfunction exports. So, the only way to use FFI style is via the \"wasi\" target.\nNot explicitly calling `_start` before an ABI such as wapc-go, would crash, due\nto setup not happening (e.g. to implement `panic`). Other embedders such as\nEnvoy also called `_start` for the same reason. To avoid a common problem for\nusers unaware of WASI, and also to simplify normal use of WASI (e.g. `main`),\nwe added `_start` to `ModuleConfig.WithStartFunctions`.\n\nIn cases of multiple initializers, such as in wapc-go, users can override this\nto add the others *after* `_start`. Users who want to explicitly control\n`_start`, such as some of our unit tests, can clear the start functions and\nremove it.\n\nThis decision was made in 2022, and holds true in 2023, even with the\nintroduction of \"wasix\". It holds because \"wasix\" is backwards compatible with\n\"wasip1\". In the future, there will be other ways to start applications, and\nmay not be backwards compatible with \"wasip1\".\n\nMost notably WASI \"Preview 2\" is not implemented in a way compatible with\nwasip1. Its start function is likely to be different, and defined in the\nwasi-cli \"world\". When the design settles, and it is implemented by compilers,\nwazero will attempt to support \"wasip2\". However, it won't do so in a way that\nbreaks existing compilers.\n\nIn other words, we won't remove `_start` if \"wasip2\" continues a path of an\nalternate function name. If we did, we'd break existing users despite our\ncompatibility promise saying we don't. The most likely case is that when we\nbuild-in something incompatible with \"wasip1\", that start function will be\nadded to the start functions list in addition to `_start`.\n\nSee http://wasix.org\nSee https://github.com/WebAssembly/wasi-cli\n\n## Runtime == Engine+Store\nwazero defines a single user-type which combines the specification concept of `Store` with the unspecified `Engine`\nwhich manages them.\n\n### Why not multi-store?\nMulti-store isn't supported as the extra tier complicates lifecycle and locking. Moreover, in practice it is unusual for\nthere to be an engine that has multiple stores which have multiple modules. More often, it is the case that there is\neither 1 engine with 1 store and multiple modules, or 1 engine with many stores, each having 1 non-host module. In worst\ncase, a user can use multiple runtimes until \"multi-store\" is better understood.\n\nIf later, we have demand for multiple stores, that can be accomplished by overload. e.g. `Runtime.InstantiateInStore` or\n`Runtime.Store(name) Store`.\n\n## Exit\n\n### Why do we only return a `sys.ExitError` on a non-zero exit code?\n\nIt is reasonable to think an exit error should be returned, even if the code is\nsuccess (zero). Even on success, the module is no longer functional. For\nexample, function exports would error later. However, wazero does not. The only\ntime `sys.ExitError` is on error (non-zero).\n\nThis decision was to improve performance and ergonomics for guests that both\nuse WASI (have a `_start` function), and also allow custom exports.\nSpecifically, Rust, TinyGo and normal wasi-libc, don't exit the module during\n`_start`. If they did, it would invalidate their function exports. This means\nit is unlikely most compilers will change this behavior.\n\n`GOOS=waspi1` from Go 1.21 does exit during `_start`. However, it doesn't\nsupport other exports besides `_start`, and `_start` is not defined to be\ncalled multiple times anyway.\n\nSince `sys.ExitError` is not always returned, we added `Module.IsClosed` for\ndefensive checks. This helps integrators avoid calling functions which will\nalways fail.\n\n### Why panic with `sys.ExitError` after a host function exits?\n\nCurrently, the only portable way to stop processing code is via panic. For\nexample, WebAssembly \"trap\" instructions, such as divide by zero, are\nimplemented via panic. This ensures code isn't executed after it.\n\nWhen code reaches the WASI `proc_exit` instruction, we need to stop processing.\nRegardless of the exit code, any code invoked after exit would be in an\ninconsistent state. This is likely why unreachable instructions are sometimes\ninserted after exit: https://github.com/emscripten-core/emscripten/issues/12322\n\n## WASI\n\nUnfortunately, (WASI Snapshot Preview 1)[https://github.com/WebAssembly/WASI/blob/snapshot-01/phases/snapshot/docs.md] is not formally defined enough, and has APIs with ambiguous semantics.\nThis section describes how Wazero interprets and implements the semantics of several WASI APIs that may be interpreted differently by different wasm runtimes.\nThose APIs may affect the portability of a WASI application.\n\n### Why don't we attempt to pass wasi-testsuite on user-defined `fs.FS`?\n\nWhile most cases work fine on an `os.File` based implementation, we won't\npromise wasi-testsuite compatibility on user defined wrappers of `os.DirFS`.\nThe only option for real systems is to use our `sysfs.FS`.\n\nThere are a lot of areas where windows behaves differently, despite the\n`os.File` abstraction. This goes well beyond file locking concerns (e.g.\n`EBUSY` errors on open files). For example, errors like `ACCESS_DENIED` aren't\nproperly mapped to `EPERM`. There are trickier parts too. `FileInfo.Sys()`\ndoesn't return enough information to build inodes needed for WASI. To rebuild\nthem requires the full path to the underlying file, not just its directory\nname, and there's no way for us to get that information. At one point we tried,\nbut in practice things became tangled and functionality such as read-only\nwrappers became untenable. Finally, there are version-specific behaviors which\nare difficult to maintain even in our own code. For example, go 1.20 opens\nfiles in a different way than versions before it.\n\n### Why aren't WASI rules enforced?\n\nThe [snapshot-01](https://github.com/WebAssembly/WASI/blob/snapshot-01/phases/snapshot/docs.md) version of WASI has a\nnumber of rules for a \"command module\", but only the memory export rule is enforced. If a \"_start\" function exists, it\nis enforced to be the correct signature and succeed, but the export itself isn't enforced. It follows that this means\nexports are not required to be contained to a \"_start\" function invocation. Finally, the \"__indirect_function_table\"\nexport is also not enforced.\n\nThe reason for the exceptions are that implementations aren't following the rules. For example, TinyGo doesn't export\n\"__indirect_function_table\", so crashing on this would make wazero unable to run TinyGo modules. Similarly, modules\nloaded by wapc-go don't always define a \"_start\" function. Since \"snapshot-01\" is not a proper version, and certainly\nnot a W3C recommendation, there's no sense in breaking users over matters like this.\n\n### Why is I/O configuration not coupled to WASI?\n\nWebAssembly System Interfaces (WASI) is a formalization of a practice that can be done anyway: Define a host function to\naccess a system interface, such as writing to STDOUT. WASI stalled at snapshot-01 and as of early 2023, is being\nrewritten entirely.\n\nThis instability implies a need to transition between WASI specs, which places wazero in a position that requires\ndecoupling. For example, if code uses two different functions to call `fd_write`, the underlying configuration must be\ncentralized and decoupled. Otherwise, calls using the same file descriptor number will end up writing to different\nplaces.\n\nIn short, wazero defined system configuration in `ModuleConfig`, not a WASI type. This allows end-users to switch from\none spec to another with minimal impact. This has other helpful benefits, as centralized resources are simpler to close\ncoherently (ex via `Module.Close`).\n\nIn reflection, this worked well as more ABI became usable in wazero.\n\n### Background on `ModuleConfig` design\n\nWebAssembly 1.0 (20191205) specifies some aspects to control isolation between modules ([sandboxing](https://en.wikipedia.org/wiki/Sandbox_(computer_security))).\nFor example, `wasm.Memory` has size constraints and each instance of it is isolated from each other. While `wasm.Memory`\ncan be shared, by exporting it, it is not exported by default. In fact a WebAssembly Module (Wasm) has no memory by\ndefault.\n\nWhile memory is defined in WebAssembly 1.0 (20191205), many aspects are not. Let's use an example of `exec.Cmd` as for\nexample, a WebAssembly System Interfaces (WASI) command is implemented as a module with a `_start` function, and in many\nways acts similar to a process with a `main` function.\n\nTo capture \"hello world\" written to the console (stdout a.k.a. file descriptor 1) in `exec.Cmd`, you would set the\n`Stdout` field accordingly, perhaps to a buffer. In WebAssembly 1.0 (20191205), the only way to perform something like\nthis is via a host function (ex `HostModuleFunctionBuilder`) and internally copy memory corresponding to that string\nto a buffer.\n\nWASI implements system interfaces with host functions. Concretely, to write to console, a WASI command `Module` imports\n\"fd_write\" from \"wasi_snapshot_preview1\" and calls it with the `fd` parameter set to 1 (STDOUT).\n\nThe [snapshot-01](https://github.com/WebAssembly/WASI/blob/snapshot-01/phases/snapshot/docs.md) version of WASI has no\nmeans to declare configuration, although its function definitions imply configuration for example if fd 1 should exist,\nand if so where should it write. Moreover, snapshot-01 was last updated in late 2020 and the specification is being\ncompletely rewritten as of early 2022. This means WASI as defined by \"snapshot-01\" will not clarify aspects like which\nfile descriptors are required. While it is possible a subsequent version may, it is too early to tell as no version of\nWASI has reached a stage near W3C recommendation. Even if it did, module authors are not required to only use WASI to\nwrite to console, as they can define their own host functions, such as they did before WASI existed.\n\nwazero aims to serve Go developers as a primary function, and help them transition between WASI specifications. In\norder to do this, we have to allow top-level configuration. To ensure isolation by default, `ModuleConfig` has WithXXX\nthat override defaults to no-op or empty. One `ModuleConfig` instance is used regardless of how many times the same WASI\nfunctions are imported. The nil defaults allow safe concurrency in these situations, as well lower the cost when they\nare never used. Finally, a one-to-one mapping with `Module` allows the module to close the `ModuleConfig` instead of\nconfusing users with another API to close.\n\nNaming, defaults and validation rules of aspects like `STDIN` and `Environ` are intentionally similar to other Go\nlibraries such as `exec.Cmd` or `syscall.SetEnv`, and differences called out where helpful. For example, there's no goal\nto emulate any operating system primitive specific to Windows (such as a 'c:\\' drive). Moreover, certain defaults\nworking with real system calls are neither relevant nor safe to inherit: For example, `exec.Cmd` defaults to read STDIN\nfrom a real file descriptor (\"/dev/null\"). Defaulting to this, vs reading `io.EOF`, would be unsafe as it can exhaust\nfile descriptors if resources aren't managed properly. In other words, blind copying of defaults isn't wise as it can\nviolate isolation or endanger the embedding process. In summary, we try to be similar to normal Go code, but often need\nact differently and document `ModuleConfig` is more about emulating, not necessarily performing real system calls.\n\n## File systems\n\n### Motivation on `sys.FS`\n\nThe `sys.FS` abstraction in wazero was created because of limitations in\n`fs.FS`, and `fs.File` in Go. Compilers targeting `wasip1` may access\nfunctionality that writes new files. The ability to overcome this was requested\neven before wazero was named this, via issue #21 in March 2021.\n\nA month later, golang/go#45757 was raised by someone else on the same topic. As\nof July 2023, this has not resolved to a writeable file system abstraction.\n\nOver the next year more use cases accumulated, consolidated in March 2022 into\n#390. This closed in January 2023 with a milestone of providing more\nfunctionality, limited to users giving a real directory. This didn't yet expose\na file abstraction for general purpose use. Internally, this used `os.File`.\nHowever, a wasm module instance is a virtual machine. Only supporting `os.File`\nbreaks sand-boxing use cases. Moreover, `os.File` is not an interface. Even\nthough this abstracts functionality, it does allow interception use cases.\n\nHence, a few days later in January 2023, we had more issues asking to expose an\nabstraction, #1013 and later #1532, on use cases like masking access to files.\nIn other words, the use case requests never stopped, and aren't solved by\nexposing only real files.\n\nIn summary, the primary motivation for exposing a replacement for `fs.FS` and\n`fs.File` was around repetitive use case requests for years, around\ninterception and the ability to create new files, both virtual and real files.\nWhile some use cases are solved with real files, not all are. Regardless, an\ninterface approach is necessary to ensure users can intercept I/O operations.\n\n### Why doesn't `sys.File` have a `Fd()` method?\n\nThere are many features we could expose. We could make File expose underlying\nfile descriptors in case they are supported, for integration of system calls\nthat accept multiple ones, namely `poll` for multiplexing. This special case is\ndescribed in a subsequent section.\n\nAs noted above, users have been asking for a file abstraction for over two\nyears, and a common answer was to wait. Making users wait is a problem,\nespecially so long. Good reasons to make people wait are stabilization. Edge\ncase features are not a great reason to hold abstractions from users.\n\nAnother reason is implementation difficulty. Go did not attempt to abstract\nfile descriptors. For example, unlike `fs.ReadFile` there is no `fs.FdFile`\ninterface. Most likely, this is because file descriptors are an implementation\ndetail of common features. Programming languages, including Go, do not require\nend users to know about file descriptors. Types such as `fs.File` can be used\nwithout any knowledge of them. Implementations may or may not have file\ndescriptors. For example, in Go, `os.DirFS` has underlying file descriptors\nwhile `embed.FS` does not.\n\nDespite this, some may want to expose a non-standard interface because\n`os.File` has `Fd() uintptr` to return a file descriptor. Mainly, this is\nhandy to integrate with `syscall` package functions (on `GOOS` values that\ndeclare them). Notice, though that `uintptr` is unsafe and not an abstraction.\nClose inspection will find some `os.File` types internally use `poll.FD`\ninstead, yet this is not possible to use abstractly because that type is not\nexposed. For example, `plan9` uses a different type than `poll.FD`. In other\nwords, even in real files, `Fd()` is not wholly portable, despite it being\nuseful on many operating systems with the `syscall` package.\n\nThe reasons above, why Go doesn't abstract `FdFile` interface are a subset of\nreasons why `sys.File` does not. If we exposed `File.Fd()` we not only would\nhave to declare all the edge cases that Go describes including impact of\nfinalizers, we would have to describe these in terms of virtualized files.\nThen, we would have to reason with this value vs our existing virtualized\n`sys.FileTable`, mapping whatever type we return to keys in that table, also\nin consideration of garbage collection impact. The combination of issues like\nthis could lead down a path of not implementing a file system abstraction at\nall, and instead a weak key mapped abstraction of the `syscall` package. Once\nwe finished with all the edge cases, we would have lost context of the original\nreason why we started.. simply to allow file write access!\n\nWhen wazero attempts to do more than what the Go programming language team, it\nhas to be carefully evaluated, to:\n* Be possible to implement at least for `os.File` backed files\n* Not be confusing or cognitively hard for virtual file systems and normal use.\n* Affordable: custom code is solely the responsible by the core team, a much\n  smaller group of individuals than who maintain the Go programming language.\n\nDue to problems well known in Go, consideration of the end users who constantly\nask for basic file system functionality, and the difficulty virtualizing file\ndescriptors at multiple levels, we don't expose `Fd()` and likely won't ever\nexpose `Fd()` on `sys.File`.\n\n### Why does `sys.File` have a `Poll()` method, while `sys.FS` does not?\n\nwazero exposes `File.Poll` which allows one-at-a-time poll use cases,\nrequested by multiple users. This not only includes abstract tests such as\nGo 1.21 `GOOS=wasip1`, but real use cases including python and container2wasm\nrepls, as well listen sockets. The main use cases is non-blocking poll on a\nsingle file. Being a single file, this has no risk of problems such as\nhead-of-line blocking, even when emulated.\n\nThe main use case of multi-poll are bidirectional network services, something\nnot used in `GOOS=wasip1` standard libraries, but could be in the future.\nMoving forward without a multi-poller allows wazero to expose its file system\nabstraction instead of continuing to hold back it back for edge cases. We'll\ncontinue discussion below regardless, as rationale was requested.\n\nYou can loop through multiple `sys.File`, using `File.Poll` to see if an event\nis ready, but there is a head-of-line blocking problem. If a long timeout is\nused, bad luck could have a file that has nothing to read or write before one\nthat does. This could cause more blocking than necessary, even if you could\npoll the others just after with a zero timeout. What's worse than this is if\nunlimited blocking was used (`timeout=-1`). The host implementations could use\ngoroutines to avoid this, but interrupting a \"forever\" poll is problematic. All\nof these are reasons to consider a multi-poll API, but do not require exporting\n`File.Fd()`.\n\nShould multi-poll becomes critical, `sys.FS` could expose a `Poll` function\nlike below, despite it being the non-portable, complicated if possible to\nimplement on all platforms and virtual file systems.\n```go\nready, errno := fs.Poll([]sys.PollFile{{f1, sys.POLLIN}, {f2, sys.POLLOUT}}, timeoutMillis)\n```\n\nA real filesystem could handle this by using an approach like the internal\n`unix.Poll` function in Go, passing file descriptors on unix platforms, or\nreturning `sys.ENOSYS` for unsupported operating systems. Implementation for\nvirtual files could have a strategy around timeout to avoid the worst case of\nhead-of-line blocking (unlimited timeout).\n\nLet's remember that when designing abstractions, it is not best to add an\ninterface for everything. Certainly, Go doesn't, as evidenced by them not\nexposing `poll.FD` in `os.File`! Such a multi-poll could be limited to\nbuilt-in filesystems in the wazero repository, avoiding complexity of trying to\nsupport and test this abstractly. This would still permit multiplexing for CLI\nusers, and also permit single file polling as exists now.\n\n### Why doesn't wazero implement the working directory?\n\nAn early design of wazero's API included a `WithWorkDirFS` which allowed\ncontrol over which file a relative path such as \"./config.yml\" resolved to,\nindependent of the root file system. This intended to help separate concerns\nlike mutability of files, but it didn't work and was removed.\n\nCompilers that target wasm act differently with regard to the working\ndirectory. For example, wasi-libc, used by TinyGo,\ntracks working directory changes in compiled wasm instead: initially \"/\" until\ncode calls `chdir`. Zig assumes the first pre-opened file descriptor is the\nworking directory.\n\nThe only place wazero can standardize a layered concern is via a host function.\nSince WASI doesn't use host functions to track the working directory, we can't\nstandardize the storage and initial value of it.\n\nMeanwhile, code may be able to affect the working directory by compiling\n`chdir` into their main function, using an argument or ENV for the initial\nvalue (possibly `PWD`). Those unable to control the compiled code should only\nuse absolute paths in configuration.\n\nSee\n* https://github.com/golang/go/blob/go1.20/src/syscall/fs_js.go#L324\n* https://github.com/WebAssembly/wasi-libc/pull/214#issue-673090117\n* https://github.com/ziglang/zig/blob/53a9ee699a35a3d245ab6d1dac1f0687a4dcb42c/src/main.zig#L32\n\n### Why ignore the error returned by io.Reader when n > 1?\n\nPer https://pkg.go.dev/io#Reader, if we receive an error, any bytes read should\nbe processed first. At the syscall abstraction (`fd_read`), the caller is the\nprocessor, so we can't process the bytes inline and also return the error (as\n`EIO`).\n\nLet's assume we want to return the bytes read on error to the caller. This\nimplies we at least temporarily ignore the error alongside them. The choice\nremaining is whether to persist the error returned with the read until a\npossible next call, or ignore the error.\n\nIf we persist an error returned, it would be coupled to a file descriptor, but\neffectively it is boolean as this case coerces to `EIO`. If we track a \"last\nerror\" on a file descriptor, it could be complicated for a couple reasons\nincluding whether the error is transient or permanent, or if the error would\napply to any FD operation, or just read. Finally, there may never be a\nsubsequent read as perhaps the bytes leading up to the error are enough to\nsatisfy the processor.\n\nThis decision boils down to whether or not to track an error bit per file\ndescriptor or not. If not, the assumption is that a subsequent operation would\nalso error, this time without reading any bytes.\n\nThe current opinion is to go with the simplest path, which is to return the\nbytes read and ignore the error the there were any. Assume a subsequent\noperation will err if it needs to. This helps reduce the complexity of the code\nin wazero and also accommodates the scenario where the bytes read are enough to\nsatisfy its processor.\n\n### File descriptor allocation strategy\n\nFile descriptor allocation currently uses a strategy similar the one implemented\nby unix systems: when opening a file, the lowest unused number is picked.\n\nThe WASI standard documents that programs cannot expect that file descriptor\nnumbers will be allocated with a lowest-first strategy, and they should instead\nassume the values will be random. Since _random_ is a very imprecise concept in\ncomputers, we technically satisfying the implementation with the descriptor\nallocation strategy we use in Wazero. We could imagine adding more _randomness_\nto the descriptor selection process, however this should never be used as a\nsecurity measure to prevent applications from guessing the next file number so\nthere are no strong incentives to complicate the logic.\n\n### Why does `FSConfig.WithDirMount` not match behaviour with `os.DirFS`?\n\nIt may seem that we should require any feature that seems like a standard\nlibrary in Go, to behave the same way as the standard library. Doing so would\npresent least surprise to Go developers. In the case of how we handle\nfilesystems, we break from that as it is incompatible with the expectations of\nWASI, the most commonly implemented filesystem ABI.\n\nThe main reason is that `os.DirFS` is a virtual filesystem abstraction while\nWASI is an abstraction over syscalls. For example, the signature of `fs.Open`\ndoes not permit use of flags. This creates conflict on what default behaviors\nto take when Go implemented `os.DirFS`. On the other hand, `path_open` can pass\nflags, and in fact tests require them to be honored in specific ways.\n\nThis conflict requires us to choose what to be more compatible with, and which\ntype of user to surprise the least. We assume there will be more developers\ncompiling code to wasm than developers of custom filesystem plugins, and those\ncompiling code to wasm will be better served if we are compatible with WASI.\nHence on conflict, we prefer WASI behavior vs the behavior of `os.DirFS`.\n\nSee https://github.com/WebAssembly/wasi-testsuite\nSee https://github.com/golang/go/issues/58141\n\n## Why is our `Readdir` function more like Go's `os.File` than POSIX `readdir`?\n\nAt one point we attempted to move from a bulk `Readdir` function to something\nmore like the POSIX `DIR` struct, exposing functions like `telldir`, `seekdir`\nand `readdir`. However, we chose the design more like `os.File.Readdir`,\nbecause it performs and fits wasip1 better.\n\n### wasip1/wasix\n\n`fd_readdir` in wasip1 (and so also wasix) is like `getdents` in Linux, not\n`readdir` in POSIX. `getdents` is more like Go's `os.File.Readdir`.\n\nWe currently have an internal type `sys.DirentCache` which only is used by\nwasip1 or wasix. When `HostModuleBuilder` adds support for instantiation state,\nwe could move this to the `wasi_snapshot_preview1` package. Meanwhile, all\nfilesystem code is internal anyway, so this special-case is acceptable.\n\n### wasip2\n\n`directory-entry-stream` in wasi-filesystem preview2 is defined in component\nmodel, not an ABI, but in wasmtime it is a consuming iterator. A consuming\niterator is easy to support with anything (like `Readdir(1)`), even if it is\ninefficient as you can neither bulk read nor skip. The implementation of the\npreview1 adapter (uses preview2) confirms this. They use a dirent cache similar\nin some ways to our `sysfs.DirentCache`. As there is no seek concept in\npreview2, they interpret the cookie as numeric and read on repeat entries when\na cache wasn't available. Note: we currently do not skip-read like this as it\nrisks buffering large directories, and no user has requested entries before the\ncache, yet.\n\nRegardless, wasip2 is not complete until the end of 2023. We can defer design\ndiscussion until after it is stable and after the reference impl wasmtime\nimplements it.\n\nSee\n * https://github.com/WebAssembly/wasi-filesystem/blob/ef9fc87c07323a6827632edeb6a7388b31266c8e/example-world.md#directory_entry_stream\n * https://github.com/bytecodealliance/wasmtime/blob/b741f7c79d72492d17ab8a29c8ffe4687715938e/crates/wasi/src/preview2/preview2/filesystem.rs#L286-L296\n * https://github.com/bytecodealliance/preview2-prototyping/blob/e4c04bcfbd11c42c27c28984948d501a3e168121/crates/wasi-preview1-component-adapter/src/lib.rs#L2131-L2137\n * https://github.com/bytecodealliance/preview2-prototyping/blob/e4c04bcfbd11c42c27c28984948d501a3e168121/crates/wasi-preview1-component-adapter/src/lib.rs#L936\n\n### wasip3\n\n`directory-entry-stream` is documented to change significantly in wasip3 moving\nfrom synchronous to synchronous streams. This is dramatically different than\nPOSIX `readdir` which is synchronous.\n\nRegardless, wasip3 is not complete until after wasip2, which means 2024 or\nlater. We can defer design discussion until after it is stable and after the\nreference impl wasmtime implements it.\n\nSee\n * https://github.com/WebAssembly/WASI/blob/ddfe3d1dda5d1473f37ecebc552ae20ce5fd319a/docs/WitInWasi.md#Streams\n * https://docs.google.com/presentation/d/1MNVOZ8hdofO3tI0szg_i-Yoy0N2QPU2C--LzVuoGSlE/edit#slide=id.g1270ef7d5b6_0_662\n\n### How do we implement `Pread` with an `fs.File`?\n\n`ReadAt` is the Go equivalent to `pread`: it does not affect, and is not\naffected by, the underlying file offset. Unfortunately, `io.ReaderAt` is not\nimplemented by all `fs.File`. For example, as of Go 1.19, `embed.openFile` does\nnot.\n\nThe initial implementation of `fd_pread` instead used `Seek`. To avoid a\nregression, we fall back to `io.Seeker` when `io.ReaderAt` is not supported.\n\nThis requires obtaining the initial file offset, seeking to the intended read\noffset, and resetting the file offset the initial state. If this final seek\nfails, the file offset is left in an undefined state. This is not thread-safe.\n\nWhile seeking per read seems expensive, the common case of `embed.openFile` is\nonly accessing a single int64 field, which is cheap.\n\n### Pre-opened files\n\nWASI includes `fd_prestat_get` and `fd_prestat_dir_name` functions used to\nlearn any directory paths for file descriptors open at initialization time.\n\nFor example, `__wasilibc_register_preopened_fd` scans any file descriptors past\nSTDERR (1) and invokes `fd_prestat_dir_name` to learn any path prefixes they\ncorrespond to. Zig's `preopensAlloc` does similar. These pre-open functions are\nnot used again after initialization.\n\nwazero supports stdio pre-opens followed by any mounts e.g `.:/`. The guest\npath is a directory and its name, e.g. \"/\" is returned by `fd_prestat_dir_name`\nfor file descriptor 3 (STDERR+1). The first longest match wins on multiple\npre-opens, which allows a path like \"/tmp\" to match regardless of order vs \"/\".\n\nSee\n * https://github.com/WebAssembly/wasi-libc/blob/a02298043ff551ce1157bc2ee7ab74c3bffe7144/libc-bottom-half/sources/preopens.c\n * https://github.com/ziglang/zig/blob/9cb06f3b8bf9ea6b5e5307711bc97328762d6a1d/lib/std/fs/wasi.zig#L50-L53\n\n### fd_prestat_dir_name\n\n`fd_prestat_dir_name` is a WASI function to return the path of the pre-opened\ndirectory of a file descriptor. It has the following three parameters, and the\nthird `path_len` has ambiguous semantics.\n\n* `fd`: a file descriptor\n* `path`: the offset for the result path\n* `path_len`: In wazero, `FdPrestatDirName` writes the result path string to\n  `path` offset for the exact length of `path_len`.\n\nWasmer considers `path_len` to be the maximum length instead of the exact\nlength that should be written.\nSee https://github.com/wasmerio/wasmer/blob/3463c51268ed551933392a4063bd4f8e7498b0f6/lib/wasi/src/syscalls/mod.rs#L764\n\nThe semantics in wazero follows that of wasmtime.\nSee https://github.com/bytecodealliance/wasmtime/blob/2ca01ae9478f199337cf743a6ab543e8c3f3b238/crates/wasi-common/src/snapshots/preview_1.rs#L578-L582\n\nTheir semantics match when `path_len` == the length of `path`, so in practice\nthis difference won't matter match.\n\n## fd_readdir\n\n### Why does \"wasi_snapshot_preview1\" require dot entries when POSIX does not?\n\nIn October 2019, WASI project knew requiring dot entries (\".\" and \"..\") was not\ndocumented in preview1, not required by POSIX and problematic to synthesize.\nFor example, Windows runtimes backed by `FindNextFileW` could not return these.\nA year later, the tag representing WASI preview 1 (`snapshot-01`) was made.\nThis did not include the requested change of making dot entries optional.\n\nThe `phases/snapshot/docs.md` document was altered in subsequent years in\nsignificant ways, often in lock-step with wasmtime or wasi-libc. In January\n2022, `sock_accept` was added to `phases/snapshot/docs.md`, a document later\nrenamed to later renamed to `legacy/preview1/docs.md`.\n\nAs a result, the ABI and behavior remained unstable: The `snapshot-01` tag was\nnot an effective basis of portability. A test suite was requested well before\nthis tag, in April 2019. Meanwhile, compliance had no meaning. Developers had\nto track changes to the latest doc, while clarifying with wasi-libc or wasmtime\nbehavior. This lack of stability could have permitted a fix to the dot entries\nproblem, just as it permitted changes desired by other users.\n\nIn November 2022, the wasi-testsuite project began and started solidifying\nexpectations. This quickly led to changes in runtimes and the spec doc. WASI\nbegan importing tests from wasmtime as required behaviors for all runtimes.\nSome changes implied changes to wasi-libc. For example, `readdir` began to\nimply inode fan-outs, which caused performance regressions. Most notably a\ntest merged in January required dot entries. Tests were merged without running\nagainst any runtime, and even when run ad-hoc only against Linux. Hence,\nportability issues mentioned over three years earlier did not trigger any\nfailure until wazero (which tests Windows) noticed.\n\nIn the same month, wazero requested to revert this change primarily because\nGo does not return them from `os.ReadDir`, and materializing them is\ncomplicated due to tests also requiring inodes. Moreover, they are discarded by\nnot just Go, but other common programming languages. This was rejected by the\nWASI lead for preview1, but considered for the completely different ABI named\npreview2.\n\nIn February 2023, the WASI chair declared that new rule requiring preview1 to\nreturn dot entries \"was decided by the subgroup as a whole\", citing meeting\nnotes. According to these notes, the WASI lead stated incorrectly that POSIX\nconformance required returning dot entries, something it explicitly says are\noptional. In other words, he said filtering them out would make Preview1\nnon-conforming, and asked if anyone objects to this. The co-chair was noted to\nsay \"Because there are existing P1 programs, we shouldn’t make changes like\nthis.\" No other were recorded to say anything.\n\nIn summary, preview1 was changed retrospectively to require dot entries and\npreview2 was changed to require their absence. This rule was reverse engineered\nfrom wasmtime tests, and affirmed on two false premises:\n\n* POSIX compliance requires dot entries\n  * POSIX literally says these are optional\n* WASI cannot make changes because there are existing P1 programs.\n  * Changes to Preview 1 happened before and after this topic.\n\nAs of June 2023, wasi-testsuite still only runs on Linux, so compliance of this\nrule on Windows is left to runtimes to decide to validate. The preview2 adapter\nuses fake cookies zero and one to refer to dot dirents, uses a real inode for\nthe dot(\".\") entry and zero inode for dot-dot(\"..\").\n\nSee https://github.com/WebAssembly/wasi-filesystem/issues/3\nSee https://github.com/WebAssembly/WASI/tree/snapshot-01\nSee https://github.com/WebAssembly/WASI/issues/9\nSee https://github.com/WebAssembly/WASI/pull/458\nSee https://github.com/WebAssembly/wasi-testsuite/pull/32\nSee https://github.com/WebAssembly/wasi-libc/pull/345\nSee https://github.com/WebAssembly/wasi-testsuite/issues/52\nSee https://github.com/WebAssembly/WASI/pull/516\nSee https://github.com/WebAssembly/meetings/blob/main/wasi/2023/WASI-02-09.md#should-preview1-fd_readdir-filter-out--and-\nSee https://github.com/bytecodealliance/preview2-prototyping/blob/e4c04bcfbd11c42c27c28984948d501a3e168121/crates/wasi-preview1-component-adapter/src/lib.rs#L1026-L1041\n\n### Why are dot (\".\") and dot-dot (\"..\") entries problematic?\n\nWhen reading a directory, dot (\".\") and dot-dot (\"..\") entries are problematic.\nFor example, Go does not return them from `os.ReadDir`, and materializing them\nis complicated (at least dot-dot is).\n\nA directory entry has stat information in it. The stat information includes\ninode which is used for comparing file equivalence. In the simple case of dot,\nwe could materialize a special entry to expose the same info as stat on the fd\nwould return. However, doing this and not doing dot-dot would cause confusion,\nand dot-dot is far more tricky. To back-fill inode information about a parent\ndirectory would be costly and subtle. For example, the pre-open (mount) of the\ndirectory may be different than its logical parent. This is easy to understand\nwhen considering the common case of mounting \"/\" and \"/tmp\" as pre-opens. To\nimplement \"..\" from \"/tmp\" requires information from a separate pre-open, this\nincludes state to even know the difference. There are easier edge cases as\nwell, such as the decision to not return \"..\" from a root path. In any case,\nthis should start to explain that faking entries when underlying stdlib doesn't\nreturn them is tricky and requires quite a lot of state.\n\nAnother issue is around the `Dirent.Off` value of a directory entry, sometimes\ncalled a \"cookie\" in Linux man pagers. When the host operating system or\nlibrary function does not return dot entries, to support functions such as\n`seekdir`, you still need a value for `Dirent.Off`. Naively, you can synthesize\nthese by choosing sequential offsets zero and one. However, POSIX strictly says\noffsets should be treated opaquely. The backing filesystem could use these to\nrepresent real entries. For example, a directory with one entry could use zero\nas the `Dirent.Off` value. If you also used zero for the \".\" dirent, there\nwould be a clash. This means if you synthesize `Dirent.Off` for any entry, you\nneed to synthesize this value for all entries. In practice, the simplest way is\nusing an incrementing number, such as done in the WASI preview2 adapter.\n\nWorking around these issues causes expense to all users of wazero, so we'd\nthen look to see if that would be justified or not. However, the most common\ncompilers involved in end user questions, as of early 2023 are TinyGo, Rust and\nZig. All of these compile code which ignores dot and dot-dot entries. In other\nwords, faking these entries would not only cost our codebase with complexity,\nbut it would also add unnecessary overhead as the values aren't commonly used.\n\nThe final reason why we might do this, is an end users or a specification\nrequiring us to. As of early 2023, no end user has raised concern over Go and\nby extension wazero not returning dot and dot-dot. The snapshot-01 spec of WASI\ndoes not mention anything on this point. Also, POSIX has the following to say,\nwhich summarizes to \"these are optional\"\n\n> The readdir() function shall not return directory entries containing empty names. If entries for dot or dot-dot exist, one entry shall be returned for dot and one entry shall be returned for dot-dot; otherwise, they shall not be returned.\n\nUnfortunately, as described above, the WASI project decided in early 2023 to\nrequire dot entries in both the spec and the wasi-testsuite. For only this\nreason, wazero adds overhead to synthesize dot entries despite it being\nunnecessary for most users.\n\nSee https://pubs.opengroup.org/onlinepubs/9699919799/functions/readdir.html\nSee https://github.com/golang/go/blob/go1.20/src/os/dir_unix.go#L108-L110\nSee https://github.com/bytecodealliance/preview2-prototyping/blob/e4c04bcfbd11c42c27c28984948d501a3e168121/crates/wasi-preview1-component-adapter/src/lib.rs#L1026-L1041\n\n### Why don't we pre-populate an inode for the dot-dot (\"..\") entry?\n\nWe only populate an inode for dot (\".\") because wasi-testsuite requires it, and\nwe likely already have it (because we cache it). We could attempt to populate\none for dot-dot (\"..\"), but chose not to.\n\nFirstly, wasi-testsuite does not require the inode of dot-dot, possibly because\nthe wasip2 adapter doesn't populate it (but we don't really know why).\n\nThe only other reason to populate it would be to avoid wasi-libc's stat fanout\nwhen it is missing. However, wasi-libc explicitly doesn't fan-out to lstat on\nthe \"..\" entry on a zero ino.\n\nFetching dot-dot's inode despite the above not only doesn't help wasi-libc, but\nit also hurts languages that don't use it, such as Go. These languages would\npay a stat syscall penalty even if they don't need the inode. In fact, Go\ndiscards both dot entries!\n\nIn summary, there are no significant upsides in attempting to pre-fetch\ndot-dot's inode, and there are downsides to doing it anyway.\n\nSee\n * https://github.com/WebAssembly/wasi-libc/blob/bd950eb128bff337153de217b11270f948d04bb4/libc-bottom-half/cloudlibc/src/libc/dirent/readdir.c#L87-L94\n * https://github.com/WebAssembly/wasi-testsuite/blob/main/tests/rust/src/bin/fd_readdir.rs#L108\n * https://github.com/bytecodealliance/preview2-prototyping/blob/e4c04bcfbd11c42c27c28984948d501a3e168121/crates/wasi-preview1-component-adapter/src/lib.rs#L1037\n\n### Why don't we require inodes to be non-zero?\n\nWe don't require a non-zero value for `Dirent.Ino` because doing so can prevent\na real one from resolving later via `Stat_t.Ino`.\n\nWe define `Ino` like `d_ino` in POSIX which doesn't special-case zero. It can\nbe zero for a few reasons:\n\n* The file is not a regular file or directory.\n* The underlying filesystem does not support inodes. e.g. embed:fs\n* A directory doesn't include inodes, but a later stat can. e.g. Windows\n* The backend is based on wasi-filesystem (a.k.a wasip2), which has\n  `directory_entry.inode` optional, and might remove it entirely.\n\nThere are other downsides to returning a zero inode in widely used compilers:\n\n* File equivalence utilities, like `os.SameFile` will not work.\n* wasi-libc's `wasip1` mode will call `lstat` and attempt to retrieve a\n  non-zero value (unless the entry is named \"..\").\n\nA new compiler may accidentally skip a `Dirent` with a zero `Ino` if emulating\na non-POSIX function and re-using `Dirent.Ino` for `d_fileno`.\n\n* Linux `getdents` doesn't define `d_fileno` must be non-zero\n* BSD `getdirentries` is implementation specific. For example, OpenBSD will\n  return dirents with a zero `d_fileno`, but Darwin will skip them.\n\nThe above shouldn't be a problem, even in the case of BSD, because `wasip1` is\ndefined more in terms of `getdents` than `getdirentries`. The bottom half of\neither should treat `wasip1` (or any similar ABI such as wasix or wasip2) as a\ndifferent operating system and either use different logic that doesn't skip, or\nsynthesize a fake non-zero `d_fileno` when `d_ino` is zero.\n\nHowever, this has been a problem. Go's `syscall.ParseDirent` utility is shared\nfor all `GOOS=unix`. For simplicity, this abstracts `direntIno` with data from\n`d_fileno` or `d_ino`, and drops if either are zero, even if `d_fileno` is the\nonly field with zero explicitly defined. This led to a change to special case\n`GOOS=wasip1` as otherwise virtual files would be unconditionally skipped.\n\nIn practice, this problem is rather unique due to so many compilers relying on\nwasi-libc, which tolerates a zero inode. For example, while issues were\nreported about the performance regression when wasi-libc began doing a fan-out\non zero `Dirent.Ino`, no issues were reported about dirents being dropped as a\nresult.\n\nIn summary, rather than complicating implementation and forcing non-zero inodes\nfor a rare case, we permit zero. We instead document this topic thoroughly, so\nthat emerging compilers can re-use the research and reference it on conflict.\nWe also document that `Ino` should be non-zero, so that users implementing that\nfield will attempt to get it.\n\nSee\n * https://github.com/WebAssembly/wasi-filesystem/pull/81\n * https://github.com/WebAssembly/wasi-libc/blob/bd950eb128bff337153de217b11270f948d04bb4/libc-bottom-half/cloudlibc/src/libc/dirent/readdir.c#L87-L94\n * https://linux.die.net/man/3/getdents\n * https://www.unix.com/man-page/osx/2/getdirentries/\n * https://man.openbsd.org/OpenBSD-5.4/getdirentries.2\n * https://github.com/golang/go/blob/go1.20/src/syscall/dirent.go#L60-L102\n * https://go-review.googlesource.com/c/go/+/507915\n\n## sys.Walltime and Nanotime\n\nThe `sys` package has two function types, `Walltime` and `Nanotime` for real\nand monotonic clock exports. The naming matches conventions used in Go.\n\n```go\nfunc time_now() (sec int64, nsec int32, mono int64) {\n\tsec, nsec = walltime()\n\treturn sec, nsec, nanotime()\n}\n```\n\nSplitting functions for wall and clock time allow implementations to choose\nwhether to implement the clock once (as in Go), or split them out.\n\nEach can be configured with a `ClockResolution`, although is it usually\nincorrect as detailed in a sub-heading below. The only reason for exposing this\nis to satisfy WASI:\n\nSee https://github.com/WebAssembly/wasi-clocks\n\n### Why default to fake time?\n\nWebAssembly has an implicit design pattern of capabilities based security. By\ndefaulting to a fake time, we reduce the chance of timing attacks, at the cost\nof requiring configuration to opt-into real clocks.\n\nSee https://gruss.cc/files/fantastictimers.pdf for an example attacks.\n\n### Why does fake time increase on reading?\n\nBoth the fake nanotime and walltime increase by 1ms on reading. Particularly in\nthe case of nanotime, this prevents spinning.\n\n### Why not `time.Clock`?\n\nwazero can't use `time.Clock` as a plugin for clock implementation as it is\nonly substitutable with build flags (`faketime`) and conflates wall and\nmonotonic time in the same call.\n\nGo's `time.Clock` was added monotonic time after the fact. For portability with\nprior APIs, a decision was made to combine readings into the same API call.\n\nSee https://go.googlesource.com/proposal/+/master/design/12914-monotonic.md\n\nWebAssembly time imports do not have the same concern. In fact even Go's\nimports for clocks split walltime from nanotime readings.\n\nSee https://github.com/golang/go/blob/go1.20/misc/wasm/wasm_exec.js#L243-L255\n\nFinally, Go's clock is not an interface. WebAssembly users who want determinism\nor security need to be able to substitute an alternative clock implementation\nfrom the host process one.\n\n### `ClockResolution`\n\nA clock's resolution is hardware and OS dependent so requires a system call to retrieve an accurate value.\nGo does not provide a function for getting resolution, so without CGO we don't have an easy way to get an actual\nvalue. For now, we return fixed values of 1us for realtime and 1ns for monotonic, assuming that realtime clocks are\noften lower precision than monotonic clocks. In the future, this could be improved by having OS+arch specific assembly\nto make syscalls.\n\nFor example, Go implements time.Now for linux-amd64 with this [assembly](https://github.com/golang/go/blob/go1.20/src/runtime/time_linux_amd64.s).\nBecause retrieving resolution is not generally called often, unlike getting time, it could be appropriate to only\nimplement the fallback logic that does not use VDSO (executing syscalls in user mode). The syscall for clock_getres\nis 229 and should be usable. https://pkg.go.dev/syscall#pkg-constants.\n\nIf implementing similar for Windows, [mingw](https://github.com/mirror/mingw-w64/blob/6a0e9165008f731bccadfc41a59719cf7c8efc02/mingw-w64-libraries/winpthreads/src/clock.c#L77\n) is often a good source to find the Windows API calls that correspond\nto a POSIX method.\n\nWriting assembly would allow making syscalls without CGO, but comes with the cost that it will require implementations\nacross many combinations of OS and architecture.\n\n## sys.Nanosleep\n\nAll major programming languages have a `sleep` mechanism to block for a\nduration. Sleep is typically implemented by a WASI `poll_oneoff` relative clock\nsubscription.\n\nFor example, the below ends up calling `wasi_snapshot_preview1.poll_oneoff`:\n\n```zig\nconst std = @import(\"std\");\npub fn main() !void {\n    std.time.sleep(std.time.ns_per_s * 5);\n}\n```\n\nBesides Zig, this is also the case with TinyGo (`-target=wasi`) and Rust\n(`--target wasm32-wasi`).\n\nWe decided to expose `sys.Nanosleep` to allow overriding the implementation\nused in the common case, even if it isn't used by Go, because this gives an\neasy and efficient closure over a common program function. We also documented\n`sys.Nanotime` to warn users that some compilers don't optimize sleep.\n\n## sys.Osyield\n\nWe expose `sys.Osyield`, to allow users to control the behavior of WASI's\n`sched_yield` without a new build of wazero. This is mainly for parity with\nall other related features which we allow users to implement, including\n`sys.Nanosleep`. Unlike others, we don't provide an out-of-box implementation\nprimarily because it will cause performance problems when accessed.\n\nFor example, the below implementation uses CGO, which might result in a 1us\ndelay per invocation depending on the platform.\n\nSee https://github.com/golang/go/issues/19409#issuecomment-284788196\n```go\n//go:noescape\n//go:linkname osyield runtime.osyield\nfunc osyield()\n```\n\nIn practice, a request to customize this is unlikely to happen until other\nthread based functions are implemented. That said, as of early 2023, there are\na few signs of implementation interest and cross-referencing:\n\nSee https://github.com/WebAssembly/stack-switching/discussions/38\nSee https://github.com/WebAssembly/wasi-threads#what-can-be-skipped\nSee https://slinkydeveloper.com/Kubernetes-controllers-A-New-Hope/\n\n## sys.Stat_t\n\nWe expose `stat` information as `sys.Stat_t`, like `syscall.Stat_t` except\ndefined without build constraints. For example, you can use `sys.Stat_t` on\n`GOOS=windows` which doesn't define `syscall.Stat_t`.\n\nThe first use case of this is to return inodes from `fs.FileInfo` without\nrelying on platform-specifics. For example, a user could return `*sys.Stat_t`\nfrom `info.Sys()` and define a non-zero inode for a virtual file, or map a\nreal inode to a virtual one.\n\nNotable choices per field are listed below, where `sys.Stat_t` is unlike\n`syscall.Stat_t` on `GOOS=linux`, or needs clarification. One common issue\nnot repeated below is that numeric fields are 64-bit when at least one platform\ndefines it that large. Also, zero values are equivalent to nil or absent.\n\n* `Dev` and `Ino` (`Inode`) are both defined unsigned as they are defined\n  opaque, and most `syscall.Stat_t` also defined them unsigned. There are\n  separate sections in this document discussing the impact of zero in `Ino`.\n* `Mode` is defined as a `fs.FileMode` even though that is not defined in POSIX\n  and will not map to all possible values. This is because the current use is\n  WASI, which doesn't define any types or features not already supported. By\n  using `fs.FileMode`, we can re-use routine experience in Go.\n* `NLink` is unsigned because it is defined that way in `syscall.Stat_t`: there\n  can never be less than zero links to a file. We suggest defaulting to 1 in\n  conversions when information is not knowable because at least that many links\n  exist.\n* `Size` is signed because it is defined that way in `syscall.Stat_t`: while\n  regular files and directories will always be non-negative, irregular files\n  are possibly negative or not defined. Notably sparse files are known to\n  return negative values.\n* `Atim`, `Mtim` and `Ctim` are signed because they are defined that way in\n  `syscall.Stat_t`: Negative values are time before 1970. The resolution is\n  nanosecond because that's the maximum resolution currently supported in Go.\n\n### Why do we use `sys.EpochNanos` instead of `time.Time` or similar?\n\nTo simplify documentation, we defined a type alias `sys.EpochNanos` for int64.\n`time.Time` is a data structure, and we could have used this for\n`syscall.Stat_t` time values. The most important reason we do not is conversion\npenalty deriving time from common types.\n\nThe most common ABI used in `wasip2`. This, and compatible ABI such as `wasix`,\nencode timestamps in memory as a 64-bit number. If we used `time.Time`, we\nwould have to convert an underlying type like `syscall.Timespec` to `time.Time`\nonly to later have to call `.UnixNano()` to convert it back to a 64-bit number.\n\nIn the future, the component model module \"wasi-filesystem\" may represent stat\ntimestamps with a type shared with \"wasi-clocks\", abstractly structured similar\nto `time.Time`. However, component model intentionally does not define an ABI.\nIt is likely that the canonical ABI for timestamp will be in two parts, but it\nis not required for it to be intermediately represented this way. A utility\nlike `syscall.NsecToTimespec` could split an int64 so that it could be written\nto memory as 96 bytes (int64, int32), without allocating a struct.\n\nFinally, some may confuse epoch nanoseconds with 32-bit epoch seconds. While\n32-bit epoch seconds has \"The year 2038\" problem, epoch nanoseconds has\n\"The Year 2262\" problem, which is even less concerning for this library. If\nthe Go programming language and wazero exist in the 2200's, we can make a major\nversion increment to adjust the `sys.EpochNanos` approach. Meanwhile, we have\nfaster code.\n\n## poll_oneoff\n\n`poll_oneoff` is a WASI API for waiting for I/O events on multiple handles.\nIt is conceptually similar to the POSIX `poll(2)` syscall.\nThe name is not `poll`, because it references [“the fact that this function is not efficient\nwhen used repeatedly with the same large set of handles”][poll_oneoff].\n\nWe chose to support this API in a handful of cases that work for regular files\nand standard input. We currently do not support other types of file descriptors such\nas socket handles.\n\n### Clock Subscriptions\n\nAs detailed above in [sys.Nanosleep](#sysnanosleep), `poll_oneoff` handles\nrelative clock subscriptions. In our implementation we use `sys.Nanosleep()`\nfor this purpose in most cases, except when polling for interactive input\nfrom `os.Stdin` (see more details below).\n\n### FdRead and FdWrite Subscriptions\n\nWhen subscribing a file descriptor (except `Stdin`) for reads or writes,\nthe implementation will generally return immediately with success, unless\nthe file descriptor is unknown. The file descriptor is not checked further\nfor new incoming data. Any timeout is cancelled, and the API call is able\nto return, unless there are subscriptions to `Stdin`: these are handled\nseparately.\n\n### FdRead and FdWrite Subscription to Stdin\n\nSubscribing `Stdin` for reads (writes make no sense and cause an error),\nrequires extra care: wazero allows to configure a custom reader for `Stdin`.\n\nIn general, if a custom reader is found, the behavior will be the same\nas for regular file descriptors: data is assumed to be present and\na success is written back to the result buffer.\n\nHowever, if the reader is detected to read from `os.Stdin`,\na special code path is followed, invoking `sysfs.poll()`.\n\n`sysfs.poll()` is a wrapper for `poll(2)` on POSIX systems,\nand it is emulated on Windows.\n\n### Poll on POSIX\n\nOn POSIX systems, `poll(2)` allows to wait for incoming data on a file\ndescriptor, and block until either data becomes available or the timeout\nexpires.\n\nUsage of `syfs.poll()` is currently only reserved for standard input, because\n\n1. it is really only necessary to handle interactive input: otherwise,\n   there is no way in Go to peek from Standard Input without actually\n   reading (and thus consuming) from it;\n\n2. if `Stdin` is connected to a pipe, it is ok in most cases to return\n   with success immediately;\n\n3. `syfs.poll()` is currently a blocking call, irrespective of goroutines,\n   because the underlying syscall is; thus, it is better to limit its usage.\n\nSo, if the subscription is for `os.Stdin` and the handle is detected\nto correspond to an interactive session, then `sysfs.poll()` will be\ninvoked with a the `Stdin` handle *and* the timeout.\n\nThis also means that in this specific case, the timeout is uninterruptible,\nunless data becomes available on `Stdin` itself.\n\n### Select on Windows\n\nOn Windows `sysfs.poll()` cannot be delegated to a single\nsyscall, because there is no single syscall to handle sockets,\npipes and regular files.\n\nInstead, we emulate its behavior for the cases that are currently\nof interest.\n\n- For regular files, we _always_ report them as ready, as\n[most operating systems do anyway][async-io-windows].\n\n- For pipes, we invoke [`PeekNamedPipe`][peeknamedpipe]\nfor each file handle we detect is a pipe open for reading.\nWe currently ignore pipes open for writing.\n\n- Notably, we include also support for sockets using the [WinSock\nimplementation of `poll`][wsapoll], but instead\nof relying on the timeout argument of the `WSAPoll` function,\nwe set a 0-duration timeout so that it behaves like a peek.\n\nThis way, we can check for regular files all at once,\nat the beginning of the function, then we poll pipes and\nsockets periodically using a cancellable `time.Tick`,\nwhich plays nicely with the rest of the Go runtime.\n\n### Impact of blocking\n\nBecause this is a blocking syscall, it will also block the carrier thread of\nthe goroutine, preventing any means to support context cancellation directly.\n\nThere are ways to obviate this issue. We outline here one idea, that is however\nnot currently implemented. A common approach to support context cancellation is\nto add a signal file descriptor to the set, e.g. the read-end of a pipe or an\neventfd on Linux. When the context is canceled, we may unblock a Select call by\nwriting to the fd, causing it to return immediately. This however requires to\ndo a bit of housekeeping to hide the \"special\" FD from the end-user.\n\n[poll_oneoff]: https://github.com/WebAssembly/wasi-poll#why-is-the-function-called-poll_oneoff\n[async-io-windows]: https://tinyclouds.org/iocp_links\n[peeknamedpipe]: https://learn.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-peeknamedpipe\n[wsapoll]: https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsapoll\n\n## Signed encoding of integer global constant initializers\n\nwazero treats integer global constant initializers signed as their interpretation is not known at declaration time. For\nexample, there is no signed integer [value type](https://www.w3.org/TR/2019/REC-wasm-core-1-20191205/#value-types%E2%91%A0).\n\nTo get at the problem, let's use an example.\n```\n(global (export \"start_epoch\") i64 (i64.const 1620216263544))\n```\n\nIn both signed and unsigned LEB128 encoding, this value is the same bit pattern. The problem is that some numbers are\nnot. For example, 16256 is `807f` encoded as unsigned, but `80ff00` encoded as signed.\n\nWhile the specification mentions uninterpreted integers are in abstract [unsigned values](https://www.w3.org/TR/2019/REC-wasm-core-1-20191205/#integers%E2%91%A0),\nthe binary encoding is clear that they are encoded [signed](https://www.w3.org/TR/2019/REC-wasm-core-1-20191205/#integers%E2%91%A4).\n\nFor consistency, we go with signed encoding in the special case of global constant initializers.\n\n## Implementation limitations\n\nWebAssembly 1.0 (20191205) specification allows runtimes to [limit certain aspects of Wasm module or execution](https://www.w3.org/TR/2019/REC-wasm-core-1-20191205/#a2-implementation-limitations).\n\nwazero limitations are imposed pragmatically and described below.\n\n### Number of functions in a module\n\nThe possible number of function instances in [a module](https://www.w3.org/TR/2019/REC-wasm-core-1-20191205/#module-instances%E2%91%A0) is not specified in the WebAssembly specifications since [`funcaddr`](https://www.w3.org/TR/2019/REC-wasm-core-1-20191205/#syntax-funcaddr) corresponding to a function instance in a store can be arbitrary number.\nwazero limits the maximum function instances to 2^27 as even that number would occupy 1GB in function pointers.\n\nThat is because not only we _believe_ that all use cases are fine with the limitation, but also we have no way to test wazero runtimes under these unusual circumstances.\n\n### Number of function types in a store\n\nThere's no limitation on the number of function types in [a store](https://www.w3.org/TR/2019/REC-wasm-core-1-20191205/#store%E2%91%A0) according to the spec. In wazero implementation, we assign each function type to a unique ID, and choose to use `uint32` to represent the IDs.\nTherefore the maximum number of function types a store can have is limited to 2^27 as even that number would occupy 512MB just to reference the function types.\n\nThis is due to the same reason for the limitation on the number of functions above.\n\n### Number of values on the stack in a function\n\nWhile the the spec does not clarify a limitation of function stack values, wazero limits this to 2^27 = 134,217,728.\nThe reason is that we internally represent all the values as 64-bit integers regardless of its types (including f32, f64), and 2^27 values means\n1 GiB = (2^30). 1 GiB is the reasonable for most applications [as we see a Goroutine has 250 MB as a limit on the stack for 32-bit arch](https://github.com/golang/go/blob/go1.20/src/runtime/proc.go#L152-L159), considering that WebAssembly is (currently) 32-bit environment.\n\nAll the functions are statically analyzed at module instantiation phase, and if a function can potentially reach this limit, an error is returned.\n\n### Number of globals in a module\n\nTheoretically, a module can declare globals (including imports) up to 2^32 times. However, wazero limits this to  2^27(134,217,728) per module.\nThat is because internally we store globals in a slice with pointer types (meaning 8 bytes on 64-bit platforms), and therefore 2^27 globals\nmeans that we have 1 GiB size of slice which seems large enough for most applications.\n\n### Number of tables in a module\n\nWhile the the spec says that a module can have up to 2^32 tables, wazero limits this to 2^27 = 134,217,728.\nOne of the reasons is even that number would occupy 1GB in the pointers tables alone. Not only that, we access tables slice by\ntable index by using 32-bit signed offset in the compiler implementation, which means that the table index of 2^27 can reach 2^27 * 8 (pointer size on 64-bit machines) = 2^30 offsets in bytes.\n\nWe _believe_ that all use cases are fine with the limitation, but also note that we have no way to test wazero runtimes under these unusual circumstances.\n\nIf a module reaches this limit, an error is returned at the compilation phase.\n\n## Compiler engine implementation\n\n### Why it's safe to execute runtime-generated machine codes against async Goroutine preemption\n\nGoroutine preemption is the mechanism of the Go runtime to switch goroutines contexts on an OS thread.\nThere are two types of preemption: cooperative preemption and async preemption. The former happens, for example,\nwhen making a function call, and it is not an issue for our runtime-generated functions as they do not make\ndirect function calls to Go-implemented functions. On the other hand, the latter, async preemption, can be problematic\nsince it tries to interrupt the execution of Goroutine at any point of function, and manipulates CPU register states.\n\nFortunately, our runtime-generated machine codes do not need to take the async preemption into account.\nAll the assembly codes are entered via the trampoline implemented as Go Assembler Function (e.g. [arch_amd64.s](./arch_amd64.s)),\nand as of Go 1.20, these assembler functions are considered as _unsafe_ for async preemption:\n- https://github.com/golang/go/blob/go1.20rc1/src/runtime/preempt.go#L406-L407\n- https://github.com/golang/go/blob/9f0234214473dfb785a5ad84a8fc62a6a395cbc3/src/runtime/traceback.go#L227\n\nFrom the Go runtime point of view, the execution of runtime-generated machine codes is considered as a part of\nthat trampoline function. Therefore, runtime-generated machine code is also correctly considered unsafe for async preemption.\n\n## Why context cancellation is handled in Go code rather than native code\n\nSince [wazero v1.0.0-pre.9](https://github.com/tetratelabs/wazero/releases/tag/v1.0.0-pre.9), the runtime\nsupports integration with Go contexts to interrupt execution after a timeout, or in response to explicit cancellation.\nThis support is internally implemented as a special opcode `builtinFunctionCheckExitCode` that triggers the execution of\na Go function (`ModuleInstance.FailIfClosed`) that atomically checks a sentinel value at strategic points in the code.\n\n[It _is indeed_ possible to check the sentinel value directly, without leaving the native world][native_check], thus sparing some cycles;\nhowever, because native code never preempts (see section above), this may lead to a state where the other goroutines\nnever get the chance to run, and thus never get the chance to set the sentinel value; effectively preventing\ncancellation from taking place.\n\n[native_check]: https://github.com/tetratelabs/wazero/issues/1409\n\n## Golang patterns\n\n### Hammer tests\nCode that uses concurrency primitives, such as locks or atomics, should include \"hammer tests\", which run large loops\ninside a bounded amount of goroutines, run by half that many `GOMAXPROCS`. These are named consistently \"hammer\", so\nthey are easy to find. The name inherits from some existing tests in [golang/go](https://github.com/golang/go/search?q=hammer&type=code).\n\nHere is an annotated description of the key pieces of a hammer test:\n1. `P` declares the count of goroutines to use, defaulting to 8 or 4 if `testing.Short`.\n   * Half this amount are the cores used, and 4 is less than a modern laptop's CPU. This allows multiple \"hammer\" tests to run in parallel.\n2. `N` declares the scale of work (loop) per goroutine, defaulting to value that finishes in ~0.1s on a modern laptop.\n   * When in doubt, try 1000 or 100 if `testing.Short`\n   * Remember, there are multiple hammer tests and CI nodes are slow. Slower tests hurt feedback loops.\n3. `defer runtime.GOMAXPROCS(runtime.GOMAXPROCS(P/2))` makes goroutines switch cores, testing visibility of shared data.\n4. To ensure goroutines execute at the same time, block them with `sync.WaitGroup`, initialized to `Add(P)`.\n   * `sync.WaitGroup` internally uses `runtime_Semacquire` not available in any other library.\n   * `sync.WaitGroup.Add` with a negative value can unblock many goroutines at the same time, e.g. without a for loop.\n5. Track goroutines progress via `finished := make(chan int)` where each goroutine in `P` defers `finished <- 1`.\n   1. Tests use `require.XXX`, so `recover()` into `t.Fail` in a `defer` function before `finished <- 1`.\n      * This makes it easier to spot larger concurrency problems as you see each failure, not just the first.\n   2. After the `defer` function, await unblocked, then run the stateful function `N` times in a normal loop.\n      * This loop should trigger shared state problems as locks or atomics are contended by `P` goroutines.\n6. After all `P` goroutines launch, atomically release all of them with `WaitGroup.Add(-P)`.\n7. Block the runner on goroutine completion, by (`<-finished`) for each `P`.\n8. When all goroutines complete, `return` if `t.Failed()`, otherwise perform follow-up state checks.\n\nThis is implemented in wazero in [hammer.go](internal/testing/hammer/hammer.go)\n\n### Lock-free, cross-goroutine observations of updates\n\nHow to achieve cross-goroutine reads of a variable are not explicitly defined in https://go.dev/ref/mem. wazero uses\natomics to implement this following unofficial practice. For example, a `Close` operation can be guarded to happen only\nonce via compare-and-swap (CAS) against a zero value. When we use this pattern, we consistently use atomics to both\nread and update the same numeric field.\n\nIn lieu of formal documentation, we infer this pattern works from other sources (besides tests):\n * `sync.WaitGroup` by definition must support calling `Add` from other goroutines. Internally, it uses atomics.\n * rsc in golang/go#5045 writes \"atomics guarantee sequential consistency among the atomic variables\".\n\nSee https://github.com/golang/go/blob/go1.20/src/sync/waitgroup.go#L64\nSee https://github.com/golang/go/issues/5045#issuecomment-252730563\nSee https://www.youtube.com/watch?v=VmrEG-3bWyM\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.0390625,
          "content": "# wazero: the zero dependency WebAssembly runtime for Go developers\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/tetratelabs/wazero.svg)](https://pkg.go.dev/github.com/tetratelabs/wazero) [![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)\n\nWebAssembly is a way to safely run code compiled in other languages. Runtimes\nexecute WebAssembly Modules (Wasm), which are most often binaries with a `.wasm`\nextension.\n\nwazero is a WebAssembly Core Specification [1.0][1] and [2.0][2] compliant\nruntime written in Go. It has *zero dependencies*, and doesn't rely on CGO.\nThis means you can run applications in other languages and still keep cross\ncompilation.\n\nImport wazero and extend your Go application with code written in any language!\n\n## Example\n\nThe best way to learn wazero is by trying one of our [examples](examples/README.md). The\nmost [basic example](examples/basic) extends a Go application with an addition\nfunction defined in WebAssembly.\n\n## Runtime\n\nThere are two runtime configurations supported in wazero: _Compiler_ is default:\n\nBy default, ex `wazero.NewRuntime(ctx)`, the Compiler is used if supported. You\ncan also force the interpreter like so:\n```go\nr := wazero.NewRuntimeWithConfig(ctx, wazero.NewRuntimeConfigInterpreter())\n```\n\n### Interpreter\nInterpreter is a naive interpreter-based implementation of Wasm virtual\nmachine. Its implementation doesn't have any platform (GOARCH, GOOS) specific\ncode, therefore _interpreter_ can be used for any compilation target available\nfor Go (such as `riscv64`).\n\n### Compiler\nCompiler compiles WebAssembly modules into machine code ahead of time (AOT),\nduring `Runtime.CompileModule`. This means your WebAssembly functions execute\nnatively at runtime. Compiler is faster than Interpreter, often by order of\nmagnitude (10x) or more. This is done without host-specific dependencies.\n\n### Conformance\n\nBoth runtimes pass WebAssembly Core [1.0][7] and [2.0][14] specification tests\non supported platforms:\n\n|   Runtime   |                 Usage                  | amd64 | arm64 | others |\n|:-----------:|:--------------------------------------:|:-----:|:-----:|:------:|\n| Interpreter | `wazero.NewRuntimeConfigInterpreter()` |   ✅   |   ✅   |   ✅    |\n|  Compiler   |  `wazero.NewRuntimeConfigCompiler()`   |   ✅   |   ✅   |   ❌    |\n\n## Support Policy\n\nThe below support policy focuses on compatibility concerns of those embedding\nwazero into their Go applications.\n\n### wazero\n\nwazero's [1.0 release][15] happened in March 2023, and is [in use][16] by many\nprojects and production sites.\n\nWe offer an API stability promise with semantic versioning. In other words, we\npromise to not break any exported function signature without incrementing the\nmajor version. This does not mean no innovation: New features and behaviors\nhappen with a minor version increment, e.g. 1.0.11 to 1.2.0. We also fix bugs\nor change internal details with a patch version, e.g. 1.0.0 to 1.0.1.\n\nYou can get the latest version of wazero like this.\n```bash\ngo get github.com/tetratelabs/wazero@latest\n```\n\nPlease give us a [star][17] if you end up using wazero!\n\n### Go\n\nwazero has no dependencies except Go, so the only source of conflict in your\nproject's use of wazero is the Go version.\n\nwazero follows the same version policy as Go's [Release Policy][10]: two\nversions. wazero will ensure these versions work and bugs are valid if there's\nan issue with a current Go version.\n\nAdditionally, wazero intentionally delays usage of language or standard library\nfeatures one additional version. For example, when Go 1.29 is released, wazero\ncan use language features or standard libraries added in 1.27. This is a\nconvenience for embedders who have a slower version policy than Go. However,\nonly supported Go versions may be used to raise support issues.\n\n### Platform\n\nwazero has two runtime modes: Interpreter and Compiler. The only supported operating\nsystems are ones we test, but that doesn't necessarily mean other operating\nsystem versions won't work.\n\nWe currently test Linux (Ubuntu and scratch), MacOS and Windows as packaged by\n[GitHub Actions][11], as well as nested VMs running on Linux for FreeBSD, NetBSD,\nOpenBSD, DragonFly BSD, illumos and Solaris.\n\nWe also test cross compilation for many `GOOS` and `GOARCH` combinations.\n\n* Interpreter\n  * Linux is tested on amd64 (native) as well arm64 and riscv64 via emulation.\n  * Windows, FreeBSD, NetBSD, OpenBSD, DragonFly BSD, illumos and Solaris are\n    tested only on amd64.\n  * macOS is tested only on arm64.\n* Compiler\n  * Linux is tested on amd64 (native) as well arm64 via emulation.\n  * Windows, FreeBSD, NetBSD, DragonFly BSD, illumos and Solaris are\n    tested only on amd64.\n  * macOS is tested only on arm64.\n\nwazero has no dependencies and doesn't require CGO. This means it can also be\nembedded in an application that doesn't use an operating system. This is a main\ndifferentiator between wazero and alternatives.\n\nWe verify zero dependencies by running tests in Docker's [scratch image][12].\nThis approach ensures compatibility with any parent image.\n\n-----\nwazero is a registered trademark of Tetrate.io, Inc. in the United States and/or other countries\n\n[1]: https://www.w3.org/TR/2019/REC-wasm-core-1-20191205/\n[2]: https://www.w3.org/TR/2022/WD-wasm-core-2-20220419/\n[4]: https://github.com/WebAssembly/meetings/blob/main/process/subgroups.md\n[5]: https://github.com/WebAssembly/WASI\n[6]: https://pkg.go.dev/golang.org/x/sys/unix\n[7]: https://github.com/WebAssembly/spec/tree/wg-1.0/test/core\n[9]: https://github.com/tetratelabs/wazero/issues/506\n[10]: https://go.dev/doc/devel/release\n[11]: https://github.com/actions/virtual-environments\n[12]: https://docs.docker.com/develop/develop-images/baseimages/#create-a-simple-parent-image-using-scratch\n[13]: https://github.com/WebAssembly/WASI/blob/snapshot-01/phases/snapshot/docs.md\n[14]: https://github.com/WebAssembly/spec/tree/d39195773112a22b245ffbe864bab6d1182ccb06/test/core\n[15]: https://tetrate.io/blog/introducing-wazero-from-tetrate/\n[16]: https://wazero.io/community/users/\n[17]: https://github.com/tetratelabs/wazero/stargazers\n"
        },
        {
          "name": "api",
          "type": "tree",
          "content": null
        },
        {
          "name": "builder.go",
          "type": "blob",
          "size": 12.7587890625,
          "content": "package wazero\n\nimport (\n\t\"context\"\n\n\t\"github.com/tetratelabs/wazero/api\"\n\t\"github.com/tetratelabs/wazero/internal/wasm\"\n)\n\n// HostFunctionBuilder defines a host function (in Go), so that a\n// WebAssembly binary (e.g. %.wasm file) can import and use it.\n//\n// Here's an example of an addition function:\n//\n//\thostModuleBuilder.NewFunctionBuilder().\n//\t\tWithFunc(func(cxt context.Context, x, y uint32) uint32 {\n//\t\t\treturn x + y\n//\t\t}).\n//\t\tExport(\"add\")\n//\n// # Memory\n//\n// All host functions act on the importing api.Module, including any memory\n// exported in its binary (%.wasm file). If you are reading or writing memory,\n// it is sand-boxed Wasm memory defined by the guest.\n//\n// Below, `m` is the importing module, defined in Wasm. `fn` is a host function\n// added via Export. This means that `x` was read from memory defined in Wasm,\n// not arbitrary memory in the process.\n//\n//\tfn := func(ctx context.Context, m api.Module, offset uint32) uint32 {\n//\t\tx, _ := m.Memory().ReadUint32Le(ctx, offset)\n//\t\treturn x\n//\t}\n//\n// # Notes\n//\n//   - This is an interface for decoupling, not third-party implementations.\n//     All implementations are in wazero.\ntype HostFunctionBuilder interface {\n\t// WithGoFunction is an advanced feature for those who need higher\n\t// performance than WithFunc at the cost of more complexity.\n\t//\n\t// Here's an example addition function:\n\t//\n\t//\tbuilder.WithGoFunction(api.GoFunc(func(ctx context.Context, stack []uint64) {\n\t//\t\tx, y := api.DecodeI32(stack[0]), api.DecodeI32(stack[1])\n\t//\t\tsum := x + y\n\t//\t\tstack[0] = api.EncodeI32(sum)\n\t//\t}), []api.ValueType{api.ValueTypeI32, api.ValueTypeI32}, []api.ValueType{api.ValueTypeI32})\n\t//\n\t// As you can see above, defining in this way implies knowledge of which\n\t// WebAssembly api.ValueType is appropriate for each parameter and result.\n\t//\n\t// See WithGoModuleFunction if you also need to access the calling module.\n\tWithGoFunction(fn api.GoFunction, params, results []api.ValueType) HostFunctionBuilder\n\n\t// WithGoModuleFunction is an advanced feature for those who need higher\n\t// performance than WithFunc at the cost of more complexity.\n\t//\n\t// Here's an example addition function that loads operands from memory:\n\t//\n\t//\tbuilder.WithGoModuleFunction(api.GoModuleFunc(func(ctx context.Context, m api.Module, stack []uint64) {\n\t//\t\tmem := m.Memory()\n\t//\t\toffset := api.DecodeU32(stack[0])\n\t//\n\t//\t\tx, _ := mem.ReadUint32Le(ctx, offset)\n\t//\t\ty, _ := mem.ReadUint32Le(ctx, offset + 4) // 32 bits == 4 bytes!\n\t//\t\tsum := x + y\n\t//\n\t//\t\tstack[0] = api.EncodeU32(sum)\n\t//\t}), []api.ValueType{api.ValueTypeI32}, []api.ValueType{api.ValueTypeI32})\n\t//\n\t// As you can see above, defining in this way implies knowledge of which\n\t// WebAssembly api.ValueType is appropriate for each parameter and result.\n\t//\n\t// See WithGoFunction if you don't need access to the calling module.\n\tWithGoModuleFunction(fn api.GoModuleFunction, params, results []api.ValueType) HostFunctionBuilder\n\n\t// WithFunc uses reflect.Value to map a go `func` to a WebAssembly\n\t// compatible Signature. An input that isn't a `func` will fail to\n\t// instantiate.\n\t//\n\t// Here's an example of an addition function:\n\t//\n\t//\tbuilder.WithFunc(func(cxt context.Context, x, y uint32) uint32 {\n\t//\t\treturn x + y\n\t//\t})\n\t//\n\t// # Defining a function\n\t//\n\t// Except for the context.Context and optional api.Module, all parameters\n\t// or result types must map to WebAssembly numeric value types. This means\n\t// uint32, int32, uint64, int64, float32 or float64.\n\t//\n\t// api.Module may be specified as the second parameter, usually to access\n\t// memory. This is important because there are only numeric types in Wasm.\n\t// The only way to share other data is via writing memory and sharing\n\t// offsets.\n\t//\n\t//\tbuilder.WithFunc(func(ctx context.Context, m api.Module, offset uint32) uint32 {\n\t//\t\tmem := m.Memory()\n\t//\t\tx, _ := mem.ReadUint32Le(ctx, offset)\n\t//\t\ty, _ := mem.ReadUint32Le(ctx, offset + 4) // 32 bits == 4 bytes!\n\t//\t\treturn x + y\n\t//\t})\n\t//\n\t// This example propagates context properly when calling other functions\n\t// exported in the api.Module:\n\t//\n\t//\tbuilder.WithFunc(func(ctx context.Context, m api.Module, offset, byteCount uint32) uint32 {\n\t//\t\tfn = m.ExportedFunction(\"__read\")\n\t//\t\tresults, err := fn(ctx, offset, byteCount)\n\t//\t--snip--\n\tWithFunc(interface{}) HostFunctionBuilder\n\n\t// WithName defines the optional module-local name of this function, e.g.\n\t// \"random_get\"\n\t//\n\t// Note: This is not required to match the Export name.\n\tWithName(name string) HostFunctionBuilder\n\n\t// WithParameterNames defines optional parameter names of the function\n\t// signature, e.x. \"buf\", \"buf_len\"\n\t//\n\t// Note: When defined, names must be provided for all parameters.\n\tWithParameterNames(names ...string) HostFunctionBuilder\n\n\t// WithResultNames defines optional result names of the function\n\t// signature, e.x. \"errno\"\n\t//\n\t// Note: When defined, names must be provided for all results.\n\tWithResultNames(names ...string) HostFunctionBuilder\n\n\t// Export exports this to the HostModuleBuilder as the given name, e.g.\n\t// \"random_get\"\n\tExport(name string) HostModuleBuilder\n}\n\n// HostModuleBuilder is a way to define host functions (in Go), so that a\n// WebAssembly binary (e.g. %.wasm file) can import and use them.\n//\n// Specifically, this implements the host side of an Application Binary\n// Interface (ABI) like WASI or AssemblyScript.\n//\n// For example, this defines and instantiates a module named \"env\" with one\n// function:\n//\n//\tctx := context.Background()\n//\tr := wazero.NewRuntime(ctx)\n//\tdefer r.Close(ctx) // This closes everything this Runtime created.\n//\n//\thello := func() {\n//\t\tprintln(\"hello!\")\n//\t}\n//\tenv, _ := r.NewHostModuleBuilder(\"env\").\n//\t\tNewFunctionBuilder().WithFunc(hello).Export(\"hello\").\n//\t\tInstantiate(ctx)\n//\n// If the same module may be instantiated multiple times, it is more efficient\n// to separate steps. Here's an example:\n//\n//\tcompiled, _ := r.NewHostModuleBuilder(\"env\").\n//\t\tNewFunctionBuilder().WithFunc(getRandomString).Export(\"get_random_string\").\n//\t\tCompile(ctx)\n//\n//\tenv1, _ := r.InstantiateModule(ctx, compiled, wazero.NewModuleConfig().WithName(\"env.1\"))\n//\tenv2, _ := r.InstantiateModule(ctx, compiled, wazero.NewModuleConfig().WithName(\"env.2\"))\n//\n// See HostFunctionBuilder for valid host function signatures and other details.\n//\n// # Notes\n//\n//   - This is an interface for decoupling, not third-party implementations.\n//     All implementations are in wazero.\n//   - HostModuleBuilder is mutable: each method returns the same instance for\n//     chaining.\n//   - methods do not return errors, to allow chaining. Any validation errors\n//     are deferred until Compile.\n//   - Functions are indexed in order of calls to NewFunctionBuilder as\n//     insertion ordering is needed by ABI such as Emscripten (invoke_*).\n//   - The semantics of host functions assumes the existence of an \"importing module\" because, for example, the host function needs access to\n//     the memory of the importing module. Therefore, direct use of ExportedFunction is forbidden for host modules.\n//     Practically speaking, it is usually meaningless to directly call a host function from Go code as it is already somewhere in Go code.\ntype HostModuleBuilder interface {\n\t// Note: until golang/go#5860, we can't use example tests to embed code in interface godocs.\n\n\t// NewFunctionBuilder begins the definition of a host function.\n\tNewFunctionBuilder() HostFunctionBuilder\n\n\t// Compile returns a CompiledModule that can be instantiated by Runtime.\n\tCompile(context.Context) (CompiledModule, error)\n\n\t// Instantiate is a convenience that calls Compile, then Runtime.InstantiateModule.\n\t// This can fail for reasons documented on Runtime.InstantiateModule.\n\t//\n\t// Here's an example:\n\t//\n\t//\tctx := context.Background()\n\t//\tr := wazero.NewRuntime(ctx)\n\t//\tdefer r.Close(ctx) // This closes everything this Runtime created.\n\t//\n\t//\thello := func() {\n\t//\t\tprintln(\"hello!\")\n\t//\t}\n\t//\tenv, _ := r.NewHostModuleBuilder(\"env\").\n\t//\t\tNewFunctionBuilder().WithFunc(hello).Export(\"hello\").\n\t//\t\tInstantiate(ctx)\n\t//\n\t// # Notes\n\t//\n\t//   - Closing the Runtime has the same effect as closing the result.\n\t//   - Fields in the builder are copied during instantiation: Later changes do not affect the instantiated result.\n\t//   - To avoid using configuration defaults, use Compile instead.\n\tInstantiate(context.Context) (api.Module, error)\n}\n\n// hostModuleBuilder implements HostModuleBuilder\ntype hostModuleBuilder struct {\n\tr              *runtime\n\tmoduleName     string\n\texportNames    []string\n\tnameToHostFunc map[string]*wasm.HostFunc\n}\n\n// NewHostModuleBuilder implements Runtime.NewHostModuleBuilder\nfunc (r *runtime) NewHostModuleBuilder(moduleName string) HostModuleBuilder {\n\treturn &hostModuleBuilder{\n\t\tr:              r,\n\t\tmoduleName:     moduleName,\n\t\tnameToHostFunc: map[string]*wasm.HostFunc{},\n\t}\n}\n\n// hostFunctionBuilder implements HostFunctionBuilder\ntype hostFunctionBuilder struct {\n\tb           *hostModuleBuilder\n\tfn          interface{}\n\tname        string\n\tparamNames  []string\n\tresultNames []string\n}\n\n// WithGoFunction implements HostFunctionBuilder.WithGoFunction\nfunc (h *hostFunctionBuilder) WithGoFunction(fn api.GoFunction, params, results []api.ValueType) HostFunctionBuilder {\n\th.fn = &wasm.HostFunc{ParamTypes: params, ResultTypes: results, Code: wasm.Code{GoFunc: fn}}\n\treturn h\n}\n\n// WithGoModuleFunction implements HostFunctionBuilder.WithGoModuleFunction\nfunc (h *hostFunctionBuilder) WithGoModuleFunction(fn api.GoModuleFunction, params, results []api.ValueType) HostFunctionBuilder {\n\th.fn = &wasm.HostFunc{ParamTypes: params, ResultTypes: results, Code: wasm.Code{GoFunc: fn}}\n\treturn h\n}\n\n// WithFunc implements HostFunctionBuilder.WithFunc\nfunc (h *hostFunctionBuilder) WithFunc(fn interface{}) HostFunctionBuilder {\n\th.fn = fn\n\treturn h\n}\n\n// WithName implements HostFunctionBuilder.WithName\nfunc (h *hostFunctionBuilder) WithName(name string) HostFunctionBuilder {\n\th.name = name\n\treturn h\n}\n\n// WithParameterNames implements HostFunctionBuilder.WithParameterNames\nfunc (h *hostFunctionBuilder) WithParameterNames(names ...string) HostFunctionBuilder {\n\th.paramNames = names\n\treturn h\n}\n\n// WithResultNames implements HostFunctionBuilder.WithResultNames\nfunc (h *hostFunctionBuilder) WithResultNames(names ...string) HostFunctionBuilder {\n\th.resultNames = names\n\treturn h\n}\n\n// Export implements HostFunctionBuilder.Export\nfunc (h *hostFunctionBuilder) Export(exportName string) HostModuleBuilder {\n\tvar hostFn *wasm.HostFunc\n\tif fn, ok := h.fn.(*wasm.HostFunc); ok {\n\t\thostFn = fn\n\t} else {\n\t\thostFn = &wasm.HostFunc{Code: wasm.Code{GoFunc: h.fn}}\n\t}\n\n\t// Assign any names from the builder\n\thostFn.ExportName = exportName\n\tif h.name != \"\" {\n\t\thostFn.Name = h.name\n\t}\n\tif len(h.paramNames) != 0 {\n\t\thostFn.ParamNames = h.paramNames\n\t}\n\tif len(h.resultNames) != 0 {\n\t\thostFn.ResultNames = h.resultNames\n\t}\n\n\th.b.ExportHostFunc(hostFn)\n\treturn h.b\n}\n\n// ExportHostFunc implements wasm.HostFuncExporter\nfunc (b *hostModuleBuilder) ExportHostFunc(fn *wasm.HostFunc) {\n\tif _, ok := b.nameToHostFunc[fn.ExportName]; !ok { // add a new name\n\t\tb.exportNames = append(b.exportNames, fn.ExportName)\n\t}\n\tb.nameToHostFunc[fn.ExportName] = fn\n}\n\n// NewFunctionBuilder implements HostModuleBuilder.NewFunctionBuilder\nfunc (b *hostModuleBuilder) NewFunctionBuilder() HostFunctionBuilder {\n\treturn &hostFunctionBuilder{b: b}\n}\n\n// Compile implements HostModuleBuilder.Compile\nfunc (b *hostModuleBuilder) Compile(ctx context.Context) (CompiledModule, error) {\n\tmodule, err := wasm.NewHostModule(b.moduleName, b.exportNames, b.nameToHostFunc, b.r.enabledFeatures)\n\tif err != nil {\n\t\treturn nil, err\n\t} else if err = module.Validate(b.r.enabledFeatures); err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := &compiledModule{module: module, compiledEngine: b.r.store.Engine}\n\tlisteners, err := buildFunctionListeners(ctx, module)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err = b.r.store.Engine.CompileModule(ctx, module, listeners, false); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// typeIDs are static and compile-time known.\n\ttypeIDs, err := b.r.store.GetFunctionTypeIDs(module.TypeSection)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.typeIDs = typeIDs\n\n\treturn c, nil\n}\n\n// hostModuleInstance is a wrapper around api.Module that prevents calling ExportedFunction.\ntype hostModuleInstance struct{ api.Module }\n\n// ExportedFunction implements api.Module ExportedFunction.\nfunc (h hostModuleInstance) ExportedFunction(name string) api.Function {\n\tpanic(\"calling ExportedFunction is forbidden on host modules. See the note on ExportedFunction interface\")\n}\n\n// Instantiate implements HostModuleBuilder.Instantiate\nfunc (b *hostModuleBuilder) Instantiate(ctx context.Context) (api.Module, error) {\n\tif compiled, err := b.Compile(ctx); err != nil {\n\t\treturn nil, err\n\t} else {\n\t\tcompiled.(*compiledModule).closeWithModule = true\n\t\tm, err := b.r.InstantiateModule(ctx, compiled, NewModuleConfig())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn hostModuleInstance{m}, nil\n\t}\n}\n"
        },
        {
          "name": "builder_test.go",
          "type": "blob",
          "size": 14.251953125,
          "content": "package wazero\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/tetratelabs/wazero/api\"\n\t\"github.com/tetratelabs/wazero/internal/testing/require\"\n\t\"github.com/tetratelabs/wazero/internal/wasm\"\n)\n\n// TestNewHostModuleBuilder_Compile only covers a few scenarios to avoid duplicating tests in internal/wasm/host_test.go\nfunc TestNewHostModuleBuilder_Compile(t *testing.T) {\n\ti32, i64 := api.ValueTypeI32, api.ValueTypeI64\n\n\tuint32_uint32 := func(context.Context, uint32) uint32 {\n\t\treturn 0\n\t}\n\tuint64_uint32 := func(context.Context, uint64) uint32 {\n\t\treturn 0\n\t}\n\n\tgofunc1 := api.GoFunc(func(ctx context.Context, stack []uint64) {\n\t\tstack[0] = 0\n\t})\n\tgofunc2 := api.GoFunc(func(ctx context.Context, stack []uint64) {\n\t\tstack[0] = 0\n\t})\n\n\ttests := []struct {\n\t\tname     string\n\t\tinput    func(Runtime) HostModuleBuilder\n\t\texpected *wasm.Module\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\tinput: func(r Runtime) HostModuleBuilder {\n\t\t\t\treturn r.NewHostModuleBuilder(\"host\")\n\t\t\t},\n\t\t\texpected: &wasm.Module{NameSection: &wasm.NameSection{ModuleName: \"host\"}},\n\t\t},\n\t\t{\n\t\t\tname: \"only name\",\n\t\t\tinput: func(r Runtime) HostModuleBuilder {\n\t\t\t\treturn r.NewHostModuleBuilder(\"env\")\n\t\t\t},\n\t\t\texpected: &wasm.Module{NameSection: &wasm.NameSection{ModuleName: \"env\"}},\n\t\t},\n\t\t{\n\t\t\tname: \"WithFunc\",\n\t\t\tinput: func(r Runtime) HostModuleBuilder {\n\t\t\t\treturn r.NewHostModuleBuilder(\"host\").\n\t\t\t\t\tNewFunctionBuilder().WithFunc(uint32_uint32).Export(\"1\")\n\t\t\t},\n\t\t\texpected: &wasm.Module{\n\t\t\t\tTypeSection: []wasm.FunctionType{\n\t\t\t\t\t{Params: []api.ValueType{i32}, Results: []api.ValueType{i32}},\n\t\t\t\t},\n\t\t\t\tFunctionSection: []wasm.Index{0},\n\t\t\t\tCodeSection:     []wasm.Code{wasm.MustParseGoReflectFuncCode(uint32_uint32)},\n\t\t\t\tExportSection: []wasm.Export{\n\t\t\t\t\t{Name: \"1\", Type: wasm.ExternTypeFunc, Index: 0},\n\t\t\t\t},\n\t\t\t\tExports: map[string]*wasm.Export{\n\t\t\t\t\t\"1\": {Name: \"1\", Type: wasm.ExternTypeFunc, Index: 0},\n\t\t\t\t},\n\t\t\t\tNameSection: &wasm.NameSection{\n\t\t\t\t\tFunctionNames: wasm.NameMap{{Index: 0, Name: \"1\"}},\n\t\t\t\t\tModuleName:    \"host\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithFunc WithName WithParameterNames\",\n\t\t\tinput: func(r Runtime) HostModuleBuilder {\n\t\t\t\treturn r.NewHostModuleBuilder(\"host\").NewFunctionBuilder().\n\t\t\t\t\tWithFunc(uint32_uint32).\n\t\t\t\t\tWithName(\"get\").WithParameterNames(\"x\").\n\t\t\t\t\tExport(\"1\")\n\t\t\t},\n\t\t\texpected: &wasm.Module{\n\t\t\t\tTypeSection: []wasm.FunctionType{\n\t\t\t\t\t{Params: []api.ValueType{i32}, Results: []api.ValueType{i32}},\n\t\t\t\t},\n\t\t\t\tFunctionSection: []wasm.Index{0},\n\t\t\t\tCodeSection:     []wasm.Code{wasm.MustParseGoReflectFuncCode(uint32_uint32)},\n\t\t\t\tExportSection: []wasm.Export{\n\t\t\t\t\t{Name: \"1\", Type: wasm.ExternTypeFunc, Index: 0},\n\t\t\t\t},\n\t\t\t\tExports: map[string]*wasm.Export{\n\t\t\t\t\t\"1\": {Name: \"1\", Type: wasm.ExternTypeFunc, Index: 0},\n\t\t\t\t},\n\t\t\t\tNameSection: &wasm.NameSection{\n\t\t\t\t\tFunctionNames: wasm.NameMap{{Index: 0, Name: \"get\"}},\n\t\t\t\t\tLocalNames:    []wasm.NameMapAssoc{{Index: 0, NameMap: wasm.NameMap{{Index: 0, Name: \"x\"}}}},\n\t\t\t\t\tModuleName:    \"host\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithFunc WithName WithResultNames\",\n\t\t\tinput: func(r Runtime) HostModuleBuilder {\n\t\t\t\treturn r.NewHostModuleBuilder(\"host\").NewFunctionBuilder().\n\t\t\t\t\tWithFunc(uint32_uint32).\n\t\t\t\t\tWithName(\"get\").WithResultNames(\"x\").\n\t\t\t\t\tExport(\"1\")\n\t\t\t},\n\t\t\texpected: &wasm.Module{\n\t\t\t\tTypeSection: []wasm.FunctionType{\n\t\t\t\t\t{Params: []api.ValueType{i32}, Results: []api.ValueType{i32}},\n\t\t\t\t},\n\t\t\t\tFunctionSection: []wasm.Index{0},\n\t\t\t\tCodeSection:     []wasm.Code{wasm.MustParseGoReflectFuncCode(uint32_uint32)},\n\t\t\t\tExportSection: []wasm.Export{\n\t\t\t\t\t{Name: \"1\", Type: wasm.ExternTypeFunc, Index: 0},\n\t\t\t\t},\n\t\t\t\tExports: map[string]*wasm.Export{\n\t\t\t\t\t\"1\": {Name: \"1\", Type: wasm.ExternTypeFunc, Index: 0},\n\t\t\t\t},\n\t\t\t\tNameSection: &wasm.NameSection{\n\t\t\t\t\tFunctionNames: wasm.NameMap{{Index: 0, Name: \"get\"}},\n\t\t\t\t\tResultNames:   []wasm.NameMapAssoc{{Index: 0, NameMap: wasm.NameMap{{Index: 0, Name: \"x\"}}}},\n\t\t\t\t\tModuleName:    \"host\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithFunc overwrites existing\",\n\t\t\tinput: func(r Runtime) HostModuleBuilder {\n\t\t\t\treturn r.NewHostModuleBuilder(\"host\").\n\t\t\t\t\tNewFunctionBuilder().WithFunc(uint32_uint32).Export(\"1\").\n\t\t\t\t\tNewFunctionBuilder().WithFunc(uint64_uint32).Export(\"1\")\n\t\t\t},\n\t\t\texpected: &wasm.Module{\n\t\t\t\tTypeSection: []wasm.FunctionType{\n\t\t\t\t\t{Params: []api.ValueType{i64}, Results: []api.ValueType{i32}},\n\t\t\t\t},\n\t\t\t\tFunctionSection: []wasm.Index{0},\n\t\t\t\tCodeSection:     []wasm.Code{wasm.MustParseGoReflectFuncCode(uint64_uint32)},\n\t\t\t\tExportSection: []wasm.Export{\n\t\t\t\t\t{Name: \"1\", Type: wasm.ExternTypeFunc, Index: 0},\n\t\t\t\t},\n\t\t\t\tExports: map[string]*wasm.Export{\n\t\t\t\t\t\"1\": {Name: \"1\", Type: wasm.ExternTypeFunc, Index: 0},\n\t\t\t\t},\n\t\t\t\tNameSection: &wasm.NameSection{\n\t\t\t\t\tFunctionNames: wasm.NameMap{{Index: 0, Name: \"1\"}},\n\t\t\t\t\tModuleName:    \"host\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithFunc twice\",\n\t\t\tinput: func(r Runtime) HostModuleBuilder {\n\t\t\t\t// Intentionally out of order\n\t\t\t\treturn r.NewHostModuleBuilder(\"host\").\n\t\t\t\t\tNewFunctionBuilder().WithFunc(uint64_uint32).Export(\"2\").\n\t\t\t\t\tNewFunctionBuilder().WithFunc(uint32_uint32).Export(\"1\")\n\t\t\t},\n\t\t\texpected: &wasm.Module{\n\t\t\t\tTypeSection: []wasm.FunctionType{\n\t\t\t\t\t{Params: []api.ValueType{i64}, Results: []api.ValueType{i32}},\n\t\t\t\t\t{Params: []api.ValueType{i32}, Results: []api.ValueType{i32}},\n\t\t\t\t},\n\t\t\t\tFunctionSection: []wasm.Index{0, 1},\n\t\t\t\tCodeSection:     []wasm.Code{wasm.MustParseGoReflectFuncCode(uint64_uint32), wasm.MustParseGoReflectFuncCode(uint32_uint32)},\n\t\t\t\tExportSection: []wasm.Export{\n\t\t\t\t\t{Name: \"2\", Type: wasm.ExternTypeFunc, Index: 0},\n\t\t\t\t\t{Name: \"1\", Type: wasm.ExternTypeFunc, Index: 1},\n\t\t\t\t},\n\t\t\t\tExports: map[string]*wasm.Export{\n\t\t\t\t\t\"2\": {Name: \"2\", Type: wasm.ExternTypeFunc, Index: 0},\n\t\t\t\t\t\"1\": {Name: \"1\", Type: wasm.ExternTypeFunc, Index: 1},\n\t\t\t\t},\n\t\t\t\tNameSection: &wasm.NameSection{\n\t\t\t\t\tFunctionNames: wasm.NameMap{{Index: 0, Name: \"2\"}, {Index: 1, Name: \"1\"}},\n\t\t\t\t\tModuleName:    \"host\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithGoFunction\",\n\t\t\tinput: func(r Runtime) HostModuleBuilder {\n\t\t\t\treturn r.NewHostModuleBuilder(\"host\").\n\t\t\t\t\tNewFunctionBuilder().\n\t\t\t\t\tWithGoFunction(gofunc1, []api.ValueType{i32}, []api.ValueType{i32}).\n\t\t\t\t\tExport(\"1\")\n\t\t\t},\n\t\t\texpected: &wasm.Module{\n\t\t\t\tTypeSection: []wasm.FunctionType{\n\t\t\t\t\t{Params: []api.ValueType{i32}, Results: []api.ValueType{i32}},\n\t\t\t\t},\n\t\t\t\tFunctionSection: []wasm.Index{0},\n\t\t\t\tCodeSection: []wasm.Code{\n\t\t\t\t\t{GoFunc: gofunc1},\n\t\t\t\t},\n\t\t\t\tExportSection: []wasm.Export{\n\t\t\t\t\t{Name: \"1\", Type: wasm.ExternTypeFunc, Index: 0},\n\t\t\t\t},\n\t\t\t\tExports: map[string]*wasm.Export{\n\t\t\t\t\t\"1\": {Name: \"1\", Type: wasm.ExternTypeFunc, Index: 0},\n\t\t\t\t},\n\t\t\t\tNameSection: &wasm.NameSection{\n\t\t\t\t\tFunctionNames: wasm.NameMap{{Index: 0, Name: \"1\"}},\n\t\t\t\t\tModuleName:    \"host\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithGoFunction WithName WithParameterNames\",\n\t\t\tinput: func(r Runtime) HostModuleBuilder {\n\t\t\t\treturn r.NewHostModuleBuilder(\"host\").NewFunctionBuilder().\n\t\t\t\t\tWithGoFunction(gofunc1, []api.ValueType{i32}, []api.ValueType{i32}).\n\t\t\t\t\tWithName(\"get\").WithParameterNames(\"x\").\n\t\t\t\t\tExport(\"1\")\n\t\t\t},\n\t\t\texpected: &wasm.Module{\n\t\t\t\tTypeSection: []wasm.FunctionType{\n\t\t\t\t\t{Params: []api.ValueType{i32}, Results: []api.ValueType{i32}},\n\t\t\t\t},\n\t\t\t\tFunctionSection: []wasm.Index{0},\n\t\t\t\tCodeSection: []wasm.Code{\n\t\t\t\t\t{GoFunc: gofunc1},\n\t\t\t\t},\n\t\t\t\tExportSection: []wasm.Export{\n\t\t\t\t\t{Name: \"1\", Type: wasm.ExternTypeFunc, Index: 0},\n\t\t\t\t},\n\t\t\t\tExports: map[string]*wasm.Export{\n\t\t\t\t\t\"1\": {Name: \"1\", Type: wasm.ExternTypeFunc, Index: 0},\n\t\t\t\t},\n\t\t\t\tNameSection: &wasm.NameSection{\n\t\t\t\t\tFunctionNames: wasm.NameMap{{Index: 0, Name: \"get\"}},\n\t\t\t\t\tLocalNames:    []wasm.NameMapAssoc{{Index: 0, NameMap: wasm.NameMap{{Index: 0, Name: \"x\"}}}},\n\t\t\t\t\tModuleName:    \"host\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithGoFunction overwrites existing\",\n\t\t\tinput: func(r Runtime) HostModuleBuilder {\n\t\t\t\treturn r.NewHostModuleBuilder(\"host\").\n\t\t\t\t\tNewFunctionBuilder().\n\t\t\t\t\tWithGoFunction(gofunc1, []api.ValueType{i32}, []api.ValueType{i32}).\n\t\t\t\t\tExport(\"1\").\n\t\t\t\t\tNewFunctionBuilder().\n\t\t\t\t\tWithGoFunction(gofunc2, []api.ValueType{i64}, []api.ValueType{i32}).\n\t\t\t\t\tExport(\"1\")\n\t\t\t},\n\t\t\texpected: &wasm.Module{\n\t\t\t\tTypeSection: []wasm.FunctionType{\n\t\t\t\t\t{Params: []api.ValueType{i64}, Results: []api.ValueType{i32}},\n\t\t\t\t},\n\t\t\t\tFunctionSection: []wasm.Index{0},\n\t\t\t\tCodeSection: []wasm.Code{\n\t\t\t\t\t{GoFunc: gofunc2},\n\t\t\t\t},\n\t\t\t\tExportSection: []wasm.Export{\n\t\t\t\t\t{Name: \"1\", Type: wasm.ExternTypeFunc, Index: 0},\n\t\t\t\t},\n\t\t\t\tExports: map[string]*wasm.Export{\n\t\t\t\t\t\"1\": {Name: \"1\", Type: wasm.ExternTypeFunc, Index: 0},\n\t\t\t\t},\n\t\t\t\tNameSection: &wasm.NameSection{\n\t\t\t\t\tFunctionNames: wasm.NameMap{{Index: 0, Name: \"1\"}},\n\t\t\t\t\tModuleName:    \"host\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithGoFunction twice\",\n\t\t\tinput: func(r Runtime) HostModuleBuilder {\n\t\t\t\t// Intentionally not in lexicographic order\n\t\t\t\treturn r.NewHostModuleBuilder(\"host\").\n\t\t\t\t\tNewFunctionBuilder().\n\t\t\t\t\tWithGoFunction(gofunc2, []api.ValueType{i64}, []api.ValueType{i32}).\n\t\t\t\t\tExport(\"2\").\n\t\t\t\t\tNewFunctionBuilder().\n\t\t\t\t\tWithGoFunction(gofunc1, []api.ValueType{i32}, []api.ValueType{i32}).\n\t\t\t\t\tExport(\"1\")\n\t\t\t},\n\t\t\texpected: &wasm.Module{\n\t\t\t\tTypeSection: []wasm.FunctionType{\n\t\t\t\t\t{Params: []api.ValueType{i64}, Results: []api.ValueType{i32}},\n\t\t\t\t\t{Params: []api.ValueType{i32}, Results: []api.ValueType{i32}},\n\t\t\t\t},\n\t\t\t\tFunctionSection: []wasm.Index{0, 1},\n\t\t\t\tCodeSection: []wasm.Code{\n\t\t\t\t\t{GoFunc: gofunc2},\n\t\t\t\t\t{GoFunc: gofunc1},\n\t\t\t\t},\n\t\t\t\tExportSection: []wasm.Export{\n\t\t\t\t\t{Name: \"2\", Type: wasm.ExternTypeFunc, Index: 0},\n\t\t\t\t\t{Name: \"1\", Type: wasm.ExternTypeFunc, Index: 1},\n\t\t\t\t},\n\t\t\t\tExports: map[string]*wasm.Export{\n\t\t\t\t\t\"2\": {Name: \"2\", Type: wasm.ExternTypeFunc, Index: 0},\n\t\t\t\t\t\"1\": {Name: \"1\", Type: wasm.ExternTypeFunc, Index: 1},\n\t\t\t\t},\n\t\t\t\tNameSection: &wasm.NameSection{\n\t\t\t\t\tFunctionNames: wasm.NameMap{{Index: 0, Name: \"2\"}, {Index: 1, Name: \"1\"}},\n\t\t\t\t\tModuleName:    \"host\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttc := tt\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tb := tc.input(NewRuntime(testCtx)).(*hostModuleBuilder)\n\t\t\tcompiled, err := b.Compile(testCtx)\n\t\t\trequire.NoError(t, err)\n\t\t\tm := compiled.(*compiledModule)\n\n\t\t\trequireHostModuleEquals(t, tc.expected, m.module)\n\n\t\t\trequire.Equal(t, b.r.store.Engine, m.compiledEngine)\n\n\t\t\t// TypeIDs must be assigned to compiledModule.\n\t\t\texpTypeIDs, err := b.r.store.GetFunctionTypeIDs(tc.expected.TypeSection)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, expTypeIDs, m.typeIDs)\n\n\t\t\t// Built module must be instantiable by Engine.\n\t\t\tmod, err := b.r.InstantiateModule(testCtx, m, NewModuleConfig())\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Closing the module shouldn't remove the compiler cache\n\t\t\trequire.NoError(t, mod.Close(testCtx))\n\t\t\trequire.Equal(t, uint32(1), b.r.store.Engine.CompiledModuleCount())\n\t\t})\n\t}\n}\n\n// TestNewHostModuleBuilder_Compile_Errors only covers a few scenarios to avoid\n// duplicating tests in internal/wasm/host_test.go\nfunc TestNewHostModuleBuilder_Compile_Errors(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tinput       func(Runtime) HostModuleBuilder\n\t\texpectedErr string\n\t}{\n\t\t{\n\t\t\tname: \"error compiling\", // should fail due to invalid param.\n\t\t\tinput: func(rt Runtime) HostModuleBuilder {\n\t\t\t\treturn rt.NewHostModuleBuilder(\"host\").NewFunctionBuilder().\n\t\t\t\t\tWithFunc(&wasm.HostFunc{ExportName: \"fn\", Code: wasm.Code{GoFunc: func(string) {}}}).\n\t\t\t\t\tExport(\"fn\")\n\t\t\t},\n\t\t\texpectedErr: `func[host.fn] param[0] is unsupported: string`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttc := tt\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t_, e := tc.input(NewRuntime(testCtx)).Compile(testCtx)\n\t\t\trequire.EqualError(t, e, tc.expectedErr)\n\t\t})\n\t}\n}\n\n// TestNewHostModuleBuilder_Instantiate ensures Runtime.InstantiateModule is called on success.\nfunc TestNewHostModuleBuilder_Instantiate(t *testing.T) {\n\tr := NewRuntime(testCtx)\n\tm, err := r.NewHostModuleBuilder(\"env\").Instantiate(testCtx)\n\trequire.NoError(t, err)\n\n\t// Calling ExportedFunction should fail.\n\terr = require.CapturePanic(func() { m.ExportedFunction(\"any\") })\n\trequire.EqualError(t, err, `calling ExportedFunction is forbidden on host modules. See the note on ExportedFunction interface`)\n\n\t// If this was instantiated, it would be added to the store under the same name\n\trequire.Equal(t, r.Module(\"env\"), m)\n\n\t// Closing the module should remove the compiler cache\n\trequire.NoError(t, m.Close(testCtx))\n\trequire.Zero(t, r.(*runtime).store.Engine.CompiledModuleCount())\n}\n\n// TestNewHostModuleBuilder_Instantiate_Errors ensures errors propagate from Runtime.InstantiateModule\nfunc TestNewHostModuleBuilder_Instantiate_Errors(t *testing.T) {\n\tr := NewRuntime(testCtx)\n\t_, err := r.NewHostModuleBuilder(\"env\").Instantiate(testCtx)\n\trequire.NoError(t, err)\n\n\t_, err = r.NewHostModuleBuilder(\"env\").Instantiate(testCtx)\n\trequire.EqualError(t, err, \"module[env] has already been instantiated\")\n}\n\n// requireHostModuleEquals is redefined from internal/wasm/host_test.go to avoid an import cycle extracting it.\nfunc requireHostModuleEquals(t *testing.T, expected, actual *wasm.Module) {\n\t// `require.Equal(t, expected, actual)` fails reflect pointers don't match, so brute compare:\n\tfor i := range expected.TypeSection {\n\t\ttp := &expected.TypeSection[i]\n\t\ttp.CacheNumInUint64()\n\t\t// When creating the compiled module, we get the type IDs for types, which results in caching type keys.\n\t\t_ = tp.String()\n\t}\n\trequire.Equal(t, expected.TypeSection, actual.TypeSection)\n\trequire.Equal(t, expected.ImportSection, actual.ImportSection)\n\trequire.Equal(t, expected.FunctionSection, actual.FunctionSection)\n\trequire.Equal(t, expected.TableSection, actual.TableSection)\n\trequire.Equal(t, expected.MemorySection, actual.MemorySection)\n\trequire.Equal(t, expected.GlobalSection, actual.GlobalSection)\n\trequire.Equal(t, expected.ExportSection, actual.ExportSection)\n\trequire.Equal(t, expected.Exports, actual.Exports)\n\trequire.Equal(t, expected.StartSection, actual.StartSection)\n\trequire.Equal(t, expected.ElementSection, actual.ElementSection)\n\trequire.Equal(t, expected.DataSection, actual.DataSection)\n\trequire.Equal(t, expected.NameSection, actual.NameSection)\n\n\t// Special case because reflect.Value can't be compared with Equals\n\t// TODO: This is copy/paste with /internal/wasm/host_test.go\n\trequire.Equal(t, len(expected.CodeSection), len(actual.CodeSection))\n\tfor i, c := range expected.CodeSection {\n\t\tactualCode := actual.CodeSection[i]\n\t\trequire.Equal(t, c.GoFunc, actualCode.GoFunc)\n\n\t\t// Not wasm\n\t\trequire.Nil(t, actualCode.Body)\n\t\trequire.Nil(t, actualCode.LocalTypes)\n\t}\n}\n"
        },
        {
          "name": "cache.go",
          "type": "blob",
          "size": 4.37109375,
          "content": "package wazero\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\tgoruntime \"runtime\"\n\t\"sync\"\n\n\t\"github.com/tetratelabs/wazero/api\"\n\t\"github.com/tetratelabs/wazero/internal/filecache\"\n\t\"github.com/tetratelabs/wazero/internal/version\"\n\t\"github.com/tetratelabs/wazero/internal/wasm\"\n)\n\n// CompilationCache reduces time spent compiling (Runtime.CompileModule) the same wasm module.\n//\n// # Notes\n//\n//   - This is an interface for decoupling, not third-party implementations.\n//     All implementations are in wazero.\n//   - Instances of this can be reused across multiple runtimes, if configured\n//     via RuntimeConfig.\n//   - The cache check happens before the compilation, so if multiple Goroutines are\n//     trying to compile the same module simultaneously, it is possible that they\n//     all compile the module. The design here is that the lock isn't held for the action \"Compile\"\n//     but only for checking and saving the compiled result. Therefore, we strongly recommend that the embedder\n//     does the centralized compilation in a single Goroutines (or multiple Goroutines per Wasm binary) to generate cache rather than\n//     trying to Compile in parallel for a single module. In other words, we always recommend to produce CompiledModule\n//     share it across multiple Goroutines to avoid trying to compile the same module simultaneously.\ntype CompilationCache interface{ api.Closer }\n\n// NewCompilationCache returns a new CompilationCache to be passed to RuntimeConfig.\n// This configures only in-memory cache, and doesn't persist to the file system. See wazero.NewCompilationCacheWithDir for detail.\n//\n// The returned CompilationCache can be used to share the in-memory compilation results across multiple instances of wazero.Runtime.\nfunc NewCompilationCache() CompilationCache {\n\treturn &cache{}\n}\n\n// NewCompilationCacheWithDir is like wazero.NewCompilationCache except the result also writes\n// state into the directory specified by `dirname` parameter.\n//\n// If the dirname doesn't exist, this creates it or returns an error.\n//\n// Those running wazero as a CLI or frequently restarting a process using the same wasm should\n// use this feature to reduce time waiting to compile the same module a second time.\n//\n// The contents written into dirname are wazero-version specific, meaning different versions of\n// wazero will duplicate entries for the same input wasm.\n//\n// Note: The embedder must safeguard this directory from external changes.\nfunc NewCompilationCacheWithDir(dirname string) (CompilationCache, error) {\n\tc := &cache{}\n\terr := c.ensuresFileCache(dirname, version.GetWazeroVersion())\n\treturn c, err\n}\n\n// cache implements Cache interface.\ntype cache struct {\n\t// eng is the engine for this cache. If the cache is configured, the engine is shared across multiple instances of\n\t// Runtime, and its lifetime is not bound to them. Instead, the engine is alive until Cache.Close is called.\n\tengs      [engineKindCount]wasm.Engine\n\tfileCache filecache.Cache\n\tinitOnces [engineKindCount]sync.Once\n}\n\nfunc (c *cache) initEngine(ek engineKind, ne newEngine, ctx context.Context, features api.CoreFeatures) wasm.Engine {\n\tc.initOnces[ek].Do(func() { c.engs[ek] = ne(ctx, features, c.fileCache) })\n\treturn c.engs[ek]\n}\n\n// Close implements the same method on the Cache interface.\nfunc (c *cache) Close(_ context.Context) (err error) {\n\tfor _, eng := range c.engs {\n\t\tif eng != nil {\n\t\t\tif err = eng.Close(); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\nfunc (c *cache) ensuresFileCache(dir string, wazeroVersion string) error {\n\t// Resolve a potentially relative directory into an absolute one.\n\tvar err error\n\tdir, err = filepath.Abs(dir)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Ensure the user-supplied directory.\n\tif err = mkdir(dir); err != nil {\n\t\treturn err\n\t}\n\n\t// Create a version-specific directory to avoid conflicts.\n\tdirname := path.Join(dir, \"wazero-\"+wazeroVersion+\"-\"+goruntime.GOARCH+\"-\"+goruntime.GOOS)\n\tif err = mkdir(dirname); err != nil {\n\t\treturn err\n\t}\n\n\tc.fileCache = filecache.New(dirname)\n\treturn nil\n}\n\nfunc mkdir(dirname string) error {\n\tif st, err := os.Stat(dirname); errors.Is(err, os.ErrNotExist) {\n\t\t// If the directory not found, create the cache dir.\n\t\tif err = os.MkdirAll(dirname, 0o700); err != nil {\n\t\t\treturn fmt.Errorf(\"create directory %s: %v\", dirname, err)\n\t\t}\n\t} else if err != nil {\n\t\treturn err\n\t} else if !st.IsDir() {\n\t\treturn fmt.Errorf(\"%s is not dir\", dirname)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "cache_example_test.go",
          "type": "blob",
          "size": 1.7744140625,
          "content": "package wazero_test\n\nimport (\n\t\"context\"\n\t_ \"embed\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/tetratelabs/wazero\"\n)\n\n// This is a basic example of using the file system compilation cache via wazero.NewCompilationCacheWithDir.\n// The main goal is to show how it is configured.\nfunc Example_compileCache() {\n\t// Prepare a cache directory.\n\tcacheDir, err := os.MkdirTemp(\"\", \"example\")\n\tif err != nil {\n\t\tlog.Panicln(err)\n\t}\n\tdefer os.RemoveAll(cacheDir)\n\n\tctx := context.Background()\n\n\t// Create a runtime config which shares a compilation cache directory.\n\tcache := newCompilationCacheWithDir(cacheDir)\n\tdefer cache.Close(ctx)\n\tconfig := wazero.NewRuntimeConfig().WithCompilationCache(cache)\n\n\t// Using the same wazero.CompilationCache instance allows the in-memory cache sharing.\n\tnewRuntimeCompileClose(ctx, config)\n\tnewRuntimeCompileClose(ctx, config)\n\n\t// Since the above stored compiled functions to disk as well, below won't compile from scratch.\n\t// Instead, compilation result stored in the directory is re-used.\n\tnewRuntimeCompileClose(ctx, config.WithCompilationCache(newCompilationCacheWithDir(cacheDir)))\n\tnewRuntimeCompileClose(ctx, config.WithCompilationCache(newCompilationCacheWithDir(cacheDir)))\n\n\t// Output:\n\t//\n}\n\nfunc newCompilationCacheWithDir(cacheDir string) wazero.CompilationCache {\n\tcache, err := wazero.NewCompilationCacheWithDir(cacheDir)\n\tif err != nil {\n\t\tlog.Panicln(err)\n\t}\n\treturn cache\n}\n\n// newRuntimeCompileClose creates a new wazero.Runtime, compile a binary, and then delete the runtime.\nfunc newRuntimeCompileClose(ctx context.Context, config wazero.RuntimeConfig) {\n\tr := wazero.NewRuntimeWithConfig(ctx, config)\n\tdefer r.Close(ctx) // This closes everything this Runtime created except the file system cache.\n\n\t_, err := r.CompileModule(ctx, addWasm)\n\tif err != nil {\n\t\tlog.Panicln(err)\n\t}\n}\n"
        },
        {
          "name": "cache_test.go",
          "type": "blob",
          "size": 8.7744140625,
          "content": "package wazero\n\nimport (\n\t\"context\"\n\t_ \"embed\"\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\tgoruntime \"runtime\"\n\t\"testing\"\n\n\t\"github.com/tetratelabs/wazero/internal/platform\"\n\t\"github.com/tetratelabs/wazero/internal/testing/require\"\n\t\"github.com/tetratelabs/wazero/internal/wasm\"\n)\n\n//go:embed testdata/fac.wasm\nvar facWasm []byte\n\n//go:embed testdata/mem_grow.wasm\nvar memGrowWasm []byte\n\nfunc TestCompilationCache(t *testing.T) {\n\tctx := context.Background()\n\t// Ensures the normal Wasm module compilation cache works.\n\tt.Run(\"non-host module\", func(t *testing.T) {\n\t\tfoo, bar := getCacheSharedRuntimes(ctx, t)\n\t\tcacheInst := foo.cache\n\n\t\t// Create a different type id on the bar's store so that we can emulate that bar instantiated the module before facWasm.\n\t\t_, err := bar.store.GetFunctionTypeIDs(\n\t\t\t// Arbitrary one is fine as long as it is not used in facWasm.\n\t\t\t[]wasm.FunctionType{{Params: []wasm.ValueType{\n\t\t\t\twasm.ValueTypeI32, wasm.ValueTypeI32, wasm.ValueTypeI32, wasm.ValueTypeI32, wasm.ValueTypeI32, wasm.ValueTypeI32,\n\t\t\t\twasm.ValueTypeI32, wasm.ValueTypeV128, wasm.ValueTypeI32, wasm.ValueTypeV128, wasm.ValueTypeI32, wasm.ValueTypeI32,\n\t\t\t\twasm.ValueTypeI32, wasm.ValueTypeV128, wasm.ValueTypeI32, wasm.ValueTypeV128, wasm.ValueTypeI32, wasm.ValueTypeI32,\n\t\t\t\twasm.ValueTypeI32, wasm.ValueTypeV128, wasm.ValueTypeI32, wasm.ValueTypeV128, wasm.ValueTypeI32, wasm.ValueTypeI32,\n\t\t\t\twasm.ValueTypeI32, wasm.ValueTypeI32, wasm.ValueTypeI32, wasm.ValueTypeI32, wasm.ValueTypeI32, wasm.ValueTypeI32,\n\t\t\t}}})\n\t\trequire.NoError(t, err)\n\n\t\t// add interpreter first, to ensure compiler support isn't order dependent\n\t\teng := foo.cache.engs[engineKindInterpreter]\n\t\tif platform.CompilerSupported() {\n\t\t\teng = foo.cache.engs[engineKindCompiler]\n\t\t}\n\n\t\t// Try compiling.\n\t\tcompiled, err := foo.CompileModule(ctx, facWasm)\n\t\trequire.NoError(t, err)\n\t\t// Also check it is actually cached.\n\t\trequire.Equal(t, uint32(1), eng.CompiledModuleCount())\n\t\tbarCompiled, err := bar.CompileModule(ctx, facWasm)\n\t\trequire.NoError(t, err)\n\n\t\t// Ensures compiled modules are the same modulo type IDs, which is unique per store.\n\t\trequire.Equal(t, compiled.(*compiledModule).module, barCompiled.(*compiledModule).module)\n\t\trequire.Equal(t, compiled.(*compiledModule).closeWithModule, barCompiled.(*compiledModule).closeWithModule)\n\t\trequire.Equal(t, compiled.(*compiledModule).compiledEngine, barCompiled.(*compiledModule).compiledEngine)\n\t\t// TypeIDs must be different as we create a different type ID on bar beforehand.\n\t\trequire.NotEqual(t, compiled.(*compiledModule).typeIDs, barCompiled.(*compiledModule).typeIDs)\n\n\t\t// Two runtimes are completely separate except the compilation cache,\n\t\t// therefore it should be ok to instantiate the same name module for each of them.\n\t\tfooInst, err := foo.InstantiateModule(ctx, compiled, NewModuleConfig().WithName(\"same_name\"))\n\t\trequire.NoError(t, err)\n\t\tbarInst, err := bar.InstantiateModule(ctx, compiled, NewModuleConfig().WithName(\"same_name\"))\n\t\trequire.NoError(t, err)\n\t\t// Two instances are not equal.\n\t\trequire.NotEqual(t, fooInst, barInst)\n\n\t\t// Closing two runtimes shouldn't clear the cache as cache.Close must be explicitly called to clear the cache.\n\t\terr = foo.Close(ctx)\n\t\trequire.NoError(t, err)\n\t\terr = bar.Close(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, uint32(1), eng.CompiledModuleCount())\n\n\t\t// Close the cache, and ensure the engine is closed.\n\t\terr = cacheInst.Close(ctx)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, uint32(0), eng.CompiledModuleCount())\n\t})\n\n\t// Even when cache is configured, compiled host modules must be different as that's the way\n\t// to provide per-runtime isolation on Go functions.\n\tt.Run(\"host module\", func(t *testing.T) {\n\t\tfoo, bar := getCacheSharedRuntimes(ctx, t)\n\n\t\tgoFn := func() (dummy uint32) { return }\n\t\tfooCompiled, err := foo.NewHostModuleBuilder(\"env\").\n\t\t\tNewFunctionBuilder().WithFunc(goFn).Export(\"go_fn\").\n\t\t\tCompile(testCtx)\n\t\trequire.NoError(t, err)\n\t\tbarCompiled, err := bar.NewHostModuleBuilder(\"env\").\n\t\t\tNewFunctionBuilder().WithFunc(goFn).Export(\"go_fn\").\n\t\t\tCompile(testCtx)\n\t\trequire.NoError(t, err)\n\n\t\t// Ensures they are different.\n\t\trequire.NotEqual(t, fooCompiled, barCompiled)\n\t})\n\n\tt.Run(\"memory limit should not affect caches\", func(t *testing.T) {\n\t\t// Creates new cache instance and pass it to the config.\n\t\tc := NewCompilationCache()\n\t\tconfig := NewRuntimeConfig().WithCompilationCache(c)\n\n\t\t// create two different runtimes with separate memory limits\n\t\trt0 := NewRuntimeWithConfig(ctx, config)\n\t\trt1 := NewRuntimeWithConfig(ctx, config.WithMemoryLimitPages(2))\n\t\trt2 := NewRuntimeWithConfig(ctx, config.WithMemoryLimitPages(4))\n\n\t\t// the compiled module is not equal because the memory limits are applied to the Memory instance\n\t\tmodule0, _ := rt0.CompileModule(ctx, memGrowWasm)\n\t\tmodule1, _ := rt1.CompileModule(ctx, memGrowWasm)\n\t\tmodule2, _ := rt2.CompileModule(ctx, memGrowWasm)\n\n\t\tmax0, _ := module0.ExportedMemories()[\"memory\"].Max()\n\t\tmax1, _ := module1.ExportedMemories()[\"memory\"].Max()\n\t\tmax2, _ := module2.ExportedMemories()[\"memory\"].Max()\n\t\trequire.Equal(t, uint32(5), max0)\n\t\trequire.Equal(t, uint32(2), max1)\n\t\trequire.Equal(t, uint32(4), max2)\n\n\t\tcompiledModule0 := module0.(*compiledModule)\n\t\tcompiledModule1 := module1.(*compiledModule)\n\t\tcompiledModule2 := module2.(*compiledModule)\n\n\t\t// compare the compiled engine which contains the underlying \"codes\"\n\t\trequire.Equal(t, compiledModule0.compiledEngine, compiledModule1.compiledEngine)\n\t\trequire.Equal(t, compiledModule1.compiledEngine, compiledModule2.compiledEngine)\n\t})\n}\n\nfunc getCacheSharedRuntimes(ctx context.Context, t *testing.T) (foo, bar *runtime) {\n\t// Creates new cache instance and pass it to the config.\n\tc := NewCompilationCache()\n\tconfig := NewRuntimeConfig().WithCompilationCache(c)\n\n\t_foo := NewRuntimeWithConfig(ctx, config)\n\t_bar := NewRuntimeWithConfig(ctx, config)\n\n\tvar ok bool\n\tfoo, ok = _foo.(*runtime)\n\trequire.True(t, ok)\n\tbar, ok = _bar.(*runtime)\n\trequire.True(t, ok)\n\n\t// Make sure that two runtimes share the same cache instance.\n\trequire.Equal(t, foo.cache, bar.cache)\n\treturn\n}\n\nfunc TestCache_ensuresFileCache(t *testing.T) {\n\tconst version = \"dev\"\n\t// We expect to create a version-specific subdirectory.\n\texpectedSubdir := fmt.Sprintf(\"wazero-dev-%s-%s\", goruntime.GOARCH, goruntime.GOOS)\n\n\tt.Run(\"ok\", func(t *testing.T) {\n\t\tdir := t.TempDir()\n\t\tc := &cache{}\n\t\terr := c.ensuresFileCache(dir, version)\n\t\trequire.NoError(t, err)\n\t})\n\tt.Run(\"create dir\", func(t *testing.T) {\n\t\ttmpDir := path.Join(t.TempDir(), \"1\", \"2\", \"3\")\n\t\tdir := path.Join(tmpDir, \"foo\") // Non-existent directory.\n\n\t\tc := &cache{}\n\t\terr := c.ensuresFileCache(dir, version)\n\t\trequire.NoError(t, err)\n\n\t\trequireContainsDir(t, tmpDir, \"foo\")\n\t})\n\tt.Run(\"create relative dir\", func(t *testing.T) {\n\t\ttmpDir, oldwd := requireChdirToTemp(t)\n\t\tdefer os.Chdir(oldwd) //nolint\n\t\tdir := \"foo\"\n\n\t\tc := &cache{}\n\t\terr := c.ensuresFileCache(dir, version)\n\t\trequire.NoError(t, err)\n\n\t\trequireContainsDir(t, tmpDir, dir)\n\t})\n\tt.Run(\"basedir is not a dir\", func(t *testing.T) {\n\t\tf, err := os.CreateTemp(t.TempDir(), \"nondir\")\n\t\trequire.NoError(t, err)\n\t\tdefer f.Close()\n\n\t\tc := &cache{}\n\t\terr = c.ensuresFileCache(f.Name(), version)\n\t\trequire.Contains(t, err.Error(), \"is not dir\")\n\t})\n\tt.Run(\"versiondir is not a dir\", func(t *testing.T) {\n\t\tdir := t.TempDir()\n\t\trequire.NoError(t, os.WriteFile(path.Join(dir, expectedSubdir), []byte{}, 0o600))\n\t\tc := &cache{}\n\t\terr := c.ensuresFileCache(dir, version)\n\t\trequire.Contains(t, err.Error(), \"is not dir\")\n\t})\n}\n\n// requireContainsDir ensures the directory was created in the correct path,\n// as file.Abs can return slightly different answers for a temp directory. For\n// example, /var/folders/... vs /private/var/folders/...\nfunc requireContainsDir(t *testing.T, parent, dir string) {\n\tentries, err := os.ReadDir(parent)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 1, len(entries))\n\trequire.Equal(t, dir, entries[0].Name())\n\trequire.True(t, entries[0].IsDir())\n}\n\nfunc requireChdirToTemp(t *testing.T) (string, string) {\n\ttmpDir := t.TempDir()\n\toldwd, err := os.Getwd()\n\trequire.NoError(t, err)\n\trequire.NoError(t, os.Chdir(tmpDir))\n\treturn tmpDir, oldwd\n}\n\nfunc TestCache_Close(t *testing.T) {\n\tt.Run(\"all engines\", func(t *testing.T) {\n\t\tc := &cache{engs: [engineKindCount]wasm.Engine{&mockEngine{}, &mockEngine{}}}\n\t\terr := c.Close(testCtx)\n\t\trequire.NoError(t, err)\n\t\tfor i := engineKind(0); i < engineKindCount; i++ {\n\t\t\trequire.True(t, c.engs[i].(*mockEngine).closed)\n\t\t}\n\t})\n\tt.Run(\"only interp\", func(t *testing.T) {\n\t\tc := &cache{engs: [engineKindCount]wasm.Engine{nil, &mockEngine{}}}\n\t\terr := c.Close(testCtx)\n\t\trequire.NoError(t, err)\n\t\trequire.True(t, c.engs[engineKindInterpreter].(*mockEngine).closed)\n\t})\n\tt.Run(\"only compiler\", func(t *testing.T) {\n\t\tc := &cache{engs: [engineKindCount]wasm.Engine{&mockEngine{}, nil}}\n\t\terr := c.Close(testCtx)\n\t\trequire.NoError(t, err)\n\t\trequire.True(t, c.engs[engineKindCompiler].(*mockEngine).closed)\n\t})\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.275390625,
          "content": "# Codecov for main is visible here https://app.codecov.io/gh/tetratelabs/wazero\n\n# We use codecov only as a UI, so we disable PR comments and commit status.\n# See https://docs.codecov.com/docs/pull-request-comments\ncomment: false\ncoverage:\n  status:\n    project: off\n    patch: off\n"
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 33.9228515625,
          "content": "package wazero\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"math\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/tetratelabs/wazero/api\"\n\texperimentalsys \"github.com/tetratelabs/wazero/experimental/sys\"\n\t\"github.com/tetratelabs/wazero/internal/engine/interpreter\"\n\t\"github.com/tetratelabs/wazero/internal/engine/wazevo\"\n\t\"github.com/tetratelabs/wazero/internal/filecache\"\n\t\"github.com/tetratelabs/wazero/internal/internalapi\"\n\t\"github.com/tetratelabs/wazero/internal/platform\"\n\tinternalsock \"github.com/tetratelabs/wazero/internal/sock\"\n\tinternalsys \"github.com/tetratelabs/wazero/internal/sys\"\n\t\"github.com/tetratelabs/wazero/internal/wasm\"\n\t\"github.com/tetratelabs/wazero/sys\"\n)\n\n// RuntimeConfig controls runtime behavior, with the default implementation as\n// NewRuntimeConfig\n//\n// The example below explicitly limits to Wasm Core 1.0 features as opposed to\n// relying on defaults:\n//\n//\trConfig = wazero.NewRuntimeConfig().WithCoreFeatures(api.CoreFeaturesV1)\n//\n// # Notes\n//\n//   - This is an interface for decoupling, not third-party implementations.\n//     All implementations are in wazero.\n//   - RuntimeConfig is immutable. Each WithXXX function returns a new instance\n//     including the corresponding change.\ntype RuntimeConfig interface {\n\t// WithCoreFeatures sets the WebAssembly Core specification features this\n\t// runtime supports. Defaults to api.CoreFeaturesV2.\n\t//\n\t// Example of disabling a specific feature:\n\t//\tfeatures := api.CoreFeaturesV2.SetEnabled(api.CoreFeatureMutableGlobal, false)\n\t//\trConfig = wazero.NewRuntimeConfig().WithCoreFeatures(features)\n\t//\n\t// # Why default to version 2.0?\n\t//\n\t// Many compilers that target WebAssembly require features after\n\t// api.CoreFeaturesV1 by default. For example, TinyGo v0.24+ requires\n\t// api.CoreFeatureBulkMemoryOperations. To avoid runtime errors, wazero\n\t// defaults to api.CoreFeaturesV2, even though it is not yet a Web\n\t// Standard (REC).\n\tWithCoreFeatures(api.CoreFeatures) RuntimeConfig\n\n\t// WithMemoryLimitPages overrides the maximum pages allowed per memory. The\n\t// default is 65536, allowing 4GB total memory per instance if the maximum is\n\t// not encoded in a Wasm binary. Setting a value larger than default will panic.\n\t//\n\t// This example reduces the largest possible memory size from 4GB to 128KB:\n\t//\trConfig = wazero.NewRuntimeConfig().WithMemoryLimitPages(2)\n\t//\n\t// Note: Wasm has 32-bit memory and each page is 65536 (2^16) bytes. This\n\t// implies a max of 65536 (2^16) addressable pages.\n\t// See https://www.w3.org/TR/2019/REC-wasm-core-1-20191205/#grow-mem\n\tWithMemoryLimitPages(memoryLimitPages uint32) RuntimeConfig\n\n\t// WithMemoryCapacityFromMax eagerly allocates max memory, unless max is\n\t// not defined. The default is false, which means minimum memory is\n\t// allocated and any call to grow memory results in re-allocations.\n\t//\n\t// This example ensures any memory.grow instruction will never re-allocate:\n\t//\trConfig = wazero.NewRuntimeConfig().WithMemoryCapacityFromMax(true)\n\t//\n\t// See https://www.w3.org/TR/2019/REC-wasm-core-1-20191205/#grow-mem\n\t//\n\t// Note: if the memory maximum is not encoded in a Wasm binary, this\n\t// results in allocating 4GB. See the doc on WithMemoryLimitPages for detail.\n\tWithMemoryCapacityFromMax(memoryCapacityFromMax bool) RuntimeConfig\n\n\t// WithDebugInfoEnabled toggles DWARF based stack traces in the face of\n\t// runtime errors. Defaults to true.\n\t//\n\t// Those who wish to disable this, can like so:\n\t//\n\t//\tr := wazero.NewRuntimeWithConfig(wazero.NewRuntimeConfig().WithDebugInfoEnabled(false)\n\t//\n\t// When disabled, a stack trace message looks like:\n\t//\n\t//\twasm stack trace:\n\t//\t\t.runtime._panic(i32)\n\t//\t\t.myFunc()\n\t//\t\t.main.main()\n\t//\t\t.runtime.run()\n\t//\t\t._start()\n\t//\n\t// When enabled, the stack trace includes source code information:\n\t//\n\t//\twasm stack trace:\n\t//\t\t.runtime._panic(i32)\n\t//\t\t  0x16e2: /opt/homebrew/Cellar/tinygo/0.26.0/src/runtime/runtime_tinygowasm.go:73:6\n\t//\t\t.myFunc()\n\t//\t\t  0x190b: /Users/XXXXX/wazero/internal/testing/dwarftestdata/testdata/main.go:19:7\n\t//\t\t.main.main()\n\t//\t\t  0x18ed: /Users/XXXXX/wazero/internal/testing/dwarftestdata/testdata/main.go:4:3\n\t//\t\t.runtime.run()\n\t//\t\t  0x18cc: /opt/homebrew/Cellar/tinygo/0.26.0/src/runtime/scheduler_none.go:26:10\n\t//\t\t._start()\n\t//\t\t  0x18b6: /opt/homebrew/Cellar/tinygo/0.26.0/src/runtime/runtime_wasm_wasi.go:22:5\n\t//\n\t// Note: This only takes into effect when the original Wasm binary has the\n\t// DWARF \"custom sections\" that are often stripped, depending on\n\t// optimization flags passed to the compiler.\n\tWithDebugInfoEnabled(bool) RuntimeConfig\n\n\t// WithCompilationCache configures how runtime caches the compiled modules. In the default configuration, compilation results are\n\t// only in-memory until Runtime.Close is closed, and not shareable by multiple Runtime.\n\t//\n\t// Below defines the shared cache across multiple instances of Runtime:\n\t//\n\t//\t// Creates the new Cache and the runtime configuration with it.\n\t//\tcache := wazero.NewCompilationCache()\n\t//\tdefer cache.Close()\n\t//\tconfig := wazero.NewRuntimeConfig().WithCompilationCache(c)\n\t//\n\t//\t// Creates two runtimes while sharing compilation caches.\n\t//\tfoo := wazero.NewRuntimeWithConfig(context.Background(), config)\n\t// \tbar := wazero.NewRuntimeWithConfig(context.Background(), config)\n\t//\n\t// # Cache Key\n\t//\n\t// Cached files are keyed on the version of wazero. This is obtained from go.mod of your application,\n\t// and we use it to verify the compatibility of caches against the currently-running wazero.\n\t// However, if you use this in tests of a package not named as `main`, then wazero cannot obtain the correct\n\t// version of wazero due to the known issue of debug.BuildInfo function: https://github.com/golang/go/issues/33976.\n\t// As a consequence, your cache won't contain the correct version information and always be treated as `dev` version.\n\t// To avoid this issue, you can pass -ldflags \"-X github.com/tetratelabs/wazero/internal/version.version=foo\" when running tests.\n\tWithCompilationCache(CompilationCache) RuntimeConfig\n\n\t// WithCustomSections toggles parsing of \"custom sections\". Defaults to false.\n\t//\n\t// When enabled, it is possible to retrieve custom sections from a CompiledModule:\n\t//\n\t//\tconfig := wazero.NewRuntimeConfig().WithCustomSections(true)\n\t//\tr := wazero.NewRuntimeWithConfig(ctx, config)\n\t//\tc, err := r.CompileModule(ctx, wasm)\n\t//\tcustomSections := c.CustomSections()\n\tWithCustomSections(bool) RuntimeConfig\n\n\t// WithCloseOnContextDone ensures the executions of functions to be terminated under one of the following circumstances:\n\t//\n\t// \t- context.Context passed to the Call method of api.Function is canceled during execution. (i.e. ctx by context.WithCancel)\n\t// \t- context.Context passed to the Call method of api.Function reaches timeout during execution. (i.e. ctx by context.WithTimeout or context.WithDeadline)\n\t// \t- Close or CloseWithExitCode of api.Module is explicitly called during execution.\n\t//\n\t// This is especially useful when one wants to run untrusted Wasm binaries since otherwise, any invocation of\n\t// api.Function can potentially block the corresponding Goroutine forever. Moreover, it might block the\n\t// entire underlying OS thread which runs the api.Function call. See \"Why it's safe to execute runtime-generated\n\t// machine codes against async Goroutine preemption\" section in RATIONALE.md for detail.\n\t//\n\t// Upon the termination of the function executions, api.Module is closed.\n\t//\n\t// Note that this comes with a bit of extra cost when enabled. The reason is that internally this forces\n\t// interpreter and compiler runtimes to insert the periodical checks on the conditions above. For that reason,\n\t// this is disabled by default.\n\t//\n\t// See examples in context_done_example_test.go for the end-to-end demonstrations.\n\t//\n\t// When the invocations of api.Function are closed due to this, sys.ExitError is raised to the callers and\n\t// the api.Module from which the functions are derived is made closed.\n\tWithCloseOnContextDone(bool) RuntimeConfig\n}\n\n// NewRuntimeConfig returns a RuntimeConfig using the compiler if it is supported in this environment,\n// or the interpreter otherwise.\nfunc NewRuntimeConfig() RuntimeConfig {\n\treturn newRuntimeConfig()\n}\n\ntype newEngine func(context.Context, api.CoreFeatures, filecache.Cache) wasm.Engine\n\ntype runtimeConfig struct {\n\tenabledFeatures       api.CoreFeatures\n\tmemoryLimitPages      uint32\n\tmemoryCapacityFromMax bool\n\tengineKind            engineKind\n\tdwarfDisabled         bool // negative as defaults to enabled\n\tnewEngine             newEngine\n\tcache                 CompilationCache\n\tstoreCustomSections   bool\n\tensureTermination     bool\n}\n\n// engineLessConfig helps avoid copy/pasting the wrong defaults.\nvar engineLessConfig = &runtimeConfig{\n\tenabledFeatures:       api.CoreFeaturesV2,\n\tmemoryLimitPages:      wasm.MemoryLimitPages,\n\tmemoryCapacityFromMax: false,\n\tdwarfDisabled:         false,\n}\n\ntype engineKind int\n\nconst (\n\tengineKindCompiler engineKind = iota\n\tengineKindInterpreter\n\tengineKindCount\n)\n\n// NewRuntimeConfigCompiler compiles WebAssembly modules into\n// runtime.GOARCH-specific assembly for optimal performance.\n//\n// The default implementation is AOT (Ahead of Time) compilation, applied at\n// Runtime.CompileModule. This allows consistent runtime performance, as well\n// the ability to reduce any first request penalty.\n//\n// Note: While this is technically AOT, this does not imply any action on your\n// part. wazero automatically performs ahead-of-time compilation as needed when\n// Runtime.CompileModule is invoked.\n//\n// # Warning\n//\n//   - This panics at runtime if the runtime.GOOS or runtime.GOARCH does not\n//     support compiler. Use NewRuntimeConfig to safely detect and fallback to\n//     NewRuntimeConfigInterpreter if needed.\n//\n//   - If you are using wazero in buildmode=c-archive or c-shared, make sure that you set up the alternate signal stack\n//     by using, e.g. `sigaltstack` combined with `SA_ONSTACK` flag on `sigaction` on Linux,\n//     before calling any api.Function. This is because the Go runtime does not set up the alternate signal stack\n//     for c-archive or c-shared modes, and wazero uses the different stack than the calling Goroutine.\n//     Hence, the signal handler might get invoked on the wazero's stack, which may cause a stack overflow.\n//     https://github.com/tetratelabs/wazero/blob/2092c0a879f30d49d7b37f333f4547574b8afe0d/internal/integration_test/fuzz/fuzz/tests/sigstack.rs#L19-L36\nfunc NewRuntimeConfigCompiler() RuntimeConfig {\n\tret := engineLessConfig.clone()\n\tret.engineKind = engineKindCompiler\n\tret.newEngine = wazevo.NewEngine\n\treturn ret\n}\n\n// NewRuntimeConfigInterpreter interprets WebAssembly modules instead of compiling them into assembly.\nfunc NewRuntimeConfigInterpreter() RuntimeConfig {\n\tret := engineLessConfig.clone()\n\tret.engineKind = engineKindInterpreter\n\tret.newEngine = interpreter.NewEngine\n\treturn ret\n}\n\n// clone makes a deep copy of this runtime config.\nfunc (c *runtimeConfig) clone() *runtimeConfig {\n\tret := *c // copy except maps which share a ref\n\treturn &ret\n}\n\n// WithCoreFeatures implements RuntimeConfig.WithCoreFeatures\nfunc (c *runtimeConfig) WithCoreFeatures(features api.CoreFeatures) RuntimeConfig {\n\tret := c.clone()\n\tret.enabledFeatures = features\n\treturn ret\n}\n\n// WithCloseOnContextDone implements RuntimeConfig.WithCloseOnContextDone\nfunc (c *runtimeConfig) WithCloseOnContextDone(ensure bool) RuntimeConfig {\n\tret := c.clone()\n\tret.ensureTermination = ensure\n\treturn ret\n}\n\n// WithMemoryLimitPages implements RuntimeConfig.WithMemoryLimitPages\nfunc (c *runtimeConfig) WithMemoryLimitPages(memoryLimitPages uint32) RuntimeConfig {\n\tret := c.clone()\n\t// This panics instead of returning an error as it is unlikely.\n\tif memoryLimitPages > wasm.MemoryLimitPages {\n\t\tpanic(fmt.Errorf(\"memoryLimitPages invalid: %d > %d\", memoryLimitPages, wasm.MemoryLimitPages))\n\t}\n\tret.memoryLimitPages = memoryLimitPages\n\treturn ret\n}\n\n// WithCompilationCache implements RuntimeConfig.WithCompilationCache\nfunc (c *runtimeConfig) WithCompilationCache(ca CompilationCache) RuntimeConfig {\n\tret := c.clone()\n\tret.cache = ca\n\treturn ret\n}\n\n// WithMemoryCapacityFromMax implements RuntimeConfig.WithMemoryCapacityFromMax\nfunc (c *runtimeConfig) WithMemoryCapacityFromMax(memoryCapacityFromMax bool) RuntimeConfig {\n\tret := c.clone()\n\tret.memoryCapacityFromMax = memoryCapacityFromMax\n\treturn ret\n}\n\n// WithDebugInfoEnabled implements RuntimeConfig.WithDebugInfoEnabled\nfunc (c *runtimeConfig) WithDebugInfoEnabled(dwarfEnabled bool) RuntimeConfig {\n\tret := c.clone()\n\tret.dwarfDisabled = !dwarfEnabled\n\treturn ret\n}\n\n// WithCustomSections implements RuntimeConfig.WithCustomSections\nfunc (c *runtimeConfig) WithCustomSections(storeCustomSections bool) RuntimeConfig {\n\tret := c.clone()\n\tret.storeCustomSections = storeCustomSections\n\treturn ret\n}\n\n// CompiledModule is a WebAssembly module ready to be instantiated (Runtime.InstantiateModule) as an api.Module.\n//\n// In WebAssembly terminology, this is a decoded, validated, and possibly also compiled module. wazero avoids using\n// the name \"Module\" for both before and after instantiation as the name conflation has caused confusion.\n// See https://www.w3.org/TR/2019/REC-wasm-core-1-20191205/#semantic-phases%E2%91%A0\n//\n// # Notes\n//\n//   - This is an interface for decoupling, not third-party implementations.\n//     All implementations are in wazero.\n//   - Closing the wazero.Runtime closes any CompiledModule it compiled.\ntype CompiledModule interface {\n\t// Name returns the module name encoded into the binary or empty if not.\n\tName() string\n\n\t// ImportedFunctions returns all the imported functions\n\t// (api.FunctionDefinition) in this module or nil if there are none.\n\t//\n\t// Note: Unlike ExportedFunctions, there is no unique constraint on\n\t// imports.\n\tImportedFunctions() []api.FunctionDefinition\n\n\t// ExportedFunctions returns all the exported functions\n\t// (api.FunctionDefinition) in this module keyed on export name.\n\tExportedFunctions() map[string]api.FunctionDefinition\n\n\t// ImportedMemories returns all the imported memories\n\t// (api.MemoryDefinition) in this module or nil if there are none.\n\t//\n\t// ## Notes\n\t//   - As of WebAssembly Core Specification 2.0, there can be at most one\n\t//     memory.\n\t//   - Unlike ExportedMemories, there is no unique constraint on imports.\n\tImportedMemories() []api.MemoryDefinition\n\n\t// ExportedMemories returns all the exported memories\n\t// (api.MemoryDefinition) in this module keyed on export name.\n\t//\n\t// Note: As of WebAssembly Core Specification 2.0, there can be at most one\n\t// memory.\n\tExportedMemories() map[string]api.MemoryDefinition\n\n\t// CustomSections returns all the custom sections\n\t// (api.CustomSection) in this module keyed on the section name.\n\tCustomSections() []api.CustomSection\n\n\t// Close releases all the allocated resources for this CompiledModule.\n\t//\n\t// Note: It is safe to call Close while having outstanding calls from an\n\t// api.Module instantiated from this.\n\tClose(context.Context) error\n}\n\n// compile-time check to ensure compiledModule implements CompiledModule\nvar _ CompiledModule = &compiledModule{}\n\ntype compiledModule struct {\n\tmodule *wasm.Module\n\t// compiledEngine holds an engine on which `module` is compiled.\n\tcompiledEngine wasm.Engine\n\t// closeWithModule prevents leaking compiled code when a module is compiled implicitly.\n\tcloseWithModule bool\n\ttypeIDs         []wasm.FunctionTypeID\n}\n\n// Name implements CompiledModule.Name\nfunc (c *compiledModule) Name() (moduleName string) {\n\tif ns := c.module.NameSection; ns != nil {\n\t\tmoduleName = ns.ModuleName\n\t}\n\treturn\n}\n\n// Close implements CompiledModule.Close\nfunc (c *compiledModule) Close(context.Context) error {\n\tc.compiledEngine.DeleteCompiledModule(c.module)\n\t// It is possible the underlying may need to return an error later, but in any case this matches api.Module.Close.\n\treturn nil\n}\n\n// ImportedFunctions implements CompiledModule.ImportedFunctions\nfunc (c *compiledModule) ImportedFunctions() []api.FunctionDefinition {\n\treturn c.module.ImportedFunctions()\n}\n\n// ExportedFunctions implements CompiledModule.ExportedFunctions\nfunc (c *compiledModule) ExportedFunctions() map[string]api.FunctionDefinition {\n\treturn c.module.ExportedFunctions()\n}\n\n// ImportedMemories implements CompiledModule.ImportedMemories\nfunc (c *compiledModule) ImportedMemories() []api.MemoryDefinition {\n\treturn c.module.ImportedMemories()\n}\n\n// ExportedMemories implements CompiledModule.ExportedMemories\nfunc (c *compiledModule) ExportedMemories() map[string]api.MemoryDefinition {\n\treturn c.module.ExportedMemories()\n}\n\n// CustomSections implements CompiledModule.CustomSections\nfunc (c *compiledModule) CustomSections() []api.CustomSection {\n\tret := make([]api.CustomSection, len(c.module.CustomSections))\n\tfor i, d := range c.module.CustomSections {\n\t\tret[i] = &customSection{data: d.Data, name: d.Name}\n\t}\n\treturn ret\n}\n\n// customSection implements wasm.CustomSection\ntype customSection struct {\n\tinternalapi.WazeroOnlyType\n\tname string\n\tdata []byte\n}\n\n// Name implements wasm.CustomSection.Name\nfunc (c *customSection) Name() string {\n\treturn c.name\n}\n\n// Data implements wasm.CustomSection.Data\nfunc (c *customSection) Data() []byte {\n\treturn c.data\n}\n\n// ModuleConfig configures resources needed by functions that have low-level interactions with the host operating\n// system. Using this, resources such as STDIN can be isolated, so that the same module can be safely instantiated\n// multiple times.\n//\n// Here's an example:\n//\n//\t// Initialize base configuration:\n//\tconfig := wazero.NewModuleConfig().WithStdout(buf).WithSysNanotime()\n//\n//\t// Assign different configuration on each instantiation\n//\tmod, _ := r.InstantiateModule(ctx, compiled, config.WithName(\"rotate\").WithArgs(\"rotate\", \"angle=90\", \"dir=cw\"))\n//\n// While wazero supports Windows as a platform, host functions using ModuleConfig follow a UNIX dialect.\n// See RATIONALE.md for design background and relationship to WebAssembly System Interfaces (WASI).\n//\n// # Notes\n//\n//   - This is an interface for decoupling, not third-party implementations.\n//     All implementations are in wazero.\n//   - ModuleConfig is immutable. Each WithXXX function returns a new instance\n//     including the corresponding change.\ntype ModuleConfig interface {\n\t// WithArgs assigns command-line arguments visible to an imported function that reads an arg vector (argv). Defaults to\n\t// none. Runtime.InstantiateModule errs if any arg is empty.\n\t//\n\t// These values are commonly read by the functions like \"args_get\" in \"wasi_snapshot_preview1\" although they could be\n\t// read by functions imported from other modules.\n\t//\n\t// Similar to os.Args and exec.Cmd Env, many implementations would expect a program name to be argv[0]. However, neither\n\t// WebAssembly nor WebAssembly System Interfaces (WASI) define this. Regardless, you may choose to set the first\n\t// argument to the same value set via WithName.\n\t//\n\t// Note: This does not default to os.Args as that violates sandboxing.\n\t//\n\t// See https://linux.die.net/man/3/argv and https://en.wikipedia.org/wiki/Null-terminated_string\n\tWithArgs(...string) ModuleConfig\n\n\t// WithEnv sets an environment variable visible to a Module that imports functions. Defaults to none.\n\t// Runtime.InstantiateModule errs if the key is empty or contains a NULL(0) or equals(\"\") character.\n\t//\n\t// Validation is the same as os.Setenv on Linux and replaces any existing value. Unlike exec.Cmd Env, this does not\n\t// default to the current process environment as that would violate sandboxing. This also does not preserve order.\n\t//\n\t// Environment variables are commonly read by the functions like \"environ_get\" in \"wasi_snapshot_preview1\" although\n\t// they could be read by functions imported from other modules.\n\t//\n\t// While similar to process configuration, there are no assumptions that can be made about anything OS-specific. For\n\t// example, neither WebAssembly nor WebAssembly System Interfaces (WASI) define concerns processes have, such as\n\t// case-sensitivity on environment keys. For portability, define entries with case-insensitively unique keys.\n\t//\n\t// See https://linux.die.net/man/3/environ and https://en.wikipedia.org/wiki/Null-terminated_string\n\tWithEnv(key, value string) ModuleConfig\n\n\t// WithFS is a convenience that calls WithFSConfig with an FSConfig of the\n\t// input for the root (\"/\") guest path.\n\tWithFS(fs.FS) ModuleConfig\n\n\t// WithFSConfig configures the filesystem available to each guest\n\t// instantiated with this configuration. By default, no file access is\n\t// allowed, so functions like `path_open` result in unsupported errors\n\t// (e.g. syscall.ENOSYS).\n\tWithFSConfig(FSConfig) ModuleConfig\n\n\t// WithName configures the module name. Defaults to what was decoded from\n\t// the name section. Duplicate names are not allowed in a single Runtime.\n\t//\n\t// Calling this with the empty string \"\" makes the module anonymous.\n\t// That is useful when you want to instantiate the same CompiledModule multiple times like below:\n\t//\n\t// \tfor i := 0; i < N; i++ {\n\t//\t\t// Instantiate a new Wasm module from the already compiled `compiledWasm` anonymously without a name.\n\t//\t\tinstance, err := r.InstantiateModule(ctx, compiledWasm, wazero.NewModuleConfig().WithName(\"\"))\n\t//\t\t// ....\n\t//\t}\n\t//\n\t// See the `concurrent-instantiation` example for a complete usage.\n\t//\n\t// Non-empty named modules are available for other modules to import by name.\n\tWithName(string) ModuleConfig\n\n\t// WithStartFunctions configures the functions to call after the module is\n\t// instantiated. Defaults to \"_start\".\n\t//\n\t// Clearing the default is supported, via `WithStartFunctions()`.\n\t//\n\t// # Notes\n\t//\n\t//   - If a start function doesn't exist, it is skipped. However, any that\n\t//     do exist are called in order.\n\t//   - Start functions are not intended to be called multiple times.\n\t//     Functions that should be called multiple times should be invoked\n\t//     manually via api.Module's `ExportedFunction` method.\n\t//   - Start functions commonly exit the module during instantiation,\n\t//     preventing use of any functions later. This is the case in \"wasip1\",\n\t//     which defines the default value \"_start\".\n\t//   - See /RATIONALE.md for motivation of this feature.\n\tWithStartFunctions(...string) ModuleConfig\n\n\t// WithStderr configures where standard error (file descriptor 2) is written. Defaults to io.Discard.\n\t//\n\t// This writer is most commonly used by the functions like \"fd_write\" in \"wasi_snapshot_preview1\" although it could\n\t// be used by functions imported from other modules.\n\t//\n\t// # Notes\n\t//\n\t//   - The caller is responsible to close any io.Writer they supply: It is not closed on api.Module Close.\n\t//   - This does not default to os.Stderr as that both violates sandboxing and prevents concurrent modules.\n\t//\n\t// See https://linux.die.net/man/3/stderr\n\tWithStderr(io.Writer) ModuleConfig\n\n\t// WithStdin configures where standard input (file descriptor 0) is read. Defaults to return io.EOF.\n\t//\n\t// This reader is most commonly used by the functions like \"fd_read\" in \"wasi_snapshot_preview1\" although it could\n\t// be used by functions imported from other modules.\n\t//\n\t// # Notes\n\t//\n\t//   - The caller is responsible to close any io.Reader they supply: It is not closed on api.Module Close.\n\t//   - This does not default to os.Stdin as that both violates sandboxing and prevents concurrent modules.\n\t//\n\t// See https://linux.die.net/man/3/stdin\n\tWithStdin(io.Reader) ModuleConfig\n\n\t// WithStdout configures where standard output (file descriptor 1) is written. Defaults to io.Discard.\n\t//\n\t// This writer is most commonly used by the functions like \"fd_write\" in \"wasi_snapshot_preview1\" although it could\n\t// be used by functions imported from other modules.\n\t//\n\t// # Notes\n\t//\n\t//   - The caller is responsible to close any io.Writer they supply: It is not closed on api.Module Close.\n\t//   - This does not default to os.Stdout as that both violates sandboxing and prevents concurrent modules.\n\t//\n\t// See https://linux.die.net/man/3/stdout\n\tWithStdout(io.Writer) ModuleConfig\n\n\t// WithWalltime configures the wall clock, sometimes referred to as the\n\t// real time clock. sys.Walltime returns the current unix/epoch time,\n\t// seconds since midnight UTC 1 January 1970, with a nanosecond fraction.\n\t// This defaults to a fake result that increases by 1ms on each reading.\n\t//\n\t// Here's an example that uses a custom clock:\n\t//\tmoduleConfig = moduleConfig.\n\t//\t\tWithWalltime(func(context.Context) (sec int64, nsec int32) {\n\t//\t\t\treturn clock.walltime()\n\t//\t\t}, sys.ClockResolution(time.Microsecond.Nanoseconds()))\n\t//\n\t// # Notes:\n\t//   - This does not default to time.Now as that violates sandboxing.\n\t//   - This is used to implement host functions such as WASI\n\t//     `clock_time_get` with the `realtime` clock ID.\n\t//   - Use WithSysWalltime for a usable implementation.\n\tWithWalltime(sys.Walltime, sys.ClockResolution) ModuleConfig\n\n\t// WithSysWalltime uses time.Now for sys.Walltime with a resolution of 1us\n\t// (1000ns).\n\t//\n\t// See WithWalltime\n\tWithSysWalltime() ModuleConfig\n\n\t// WithNanotime configures the monotonic clock, used to measure elapsed\n\t// time in nanoseconds. Defaults to a fake result that increases by 1ms\n\t// on each reading.\n\t//\n\t// Here's an example that uses a custom clock:\n\t//\tmoduleConfig = moduleConfig.\n\t//\t\tWithNanotime(func(context.Context) int64 {\n\t//\t\t\treturn clock.nanotime()\n\t//\t\t}, sys.ClockResolution(time.Microsecond.Nanoseconds()))\n\t//\n\t// # Notes:\n\t//   - This does not default to time.Since as that violates sandboxing.\n\t//   - This is used to implement host functions such as WASI\n\t//     `clock_time_get` with the `monotonic` clock ID.\n\t//   - Some compilers implement sleep by looping on sys.Nanotime (e.g. Go).\n\t//   - If you set this, you should probably set WithNanosleep also.\n\t//   - Use WithSysNanotime for a usable implementation.\n\tWithNanotime(sys.Nanotime, sys.ClockResolution) ModuleConfig\n\n\t// WithSysNanotime uses time.Now for sys.Nanotime with a resolution of 1us.\n\t//\n\t// See WithNanotime\n\tWithSysNanotime() ModuleConfig\n\n\t// WithNanosleep configures the how to pause the current goroutine for at\n\t// least the configured nanoseconds. Defaults to return immediately.\n\t//\n\t// This example uses a custom sleep function:\n\t//\tmoduleConfig = moduleConfig.\n\t//\t\tWithNanosleep(func(ns int64) {\n\t//\t\t\trel := unix.NsecToTimespec(ns)\n\t//\t\t\tremain := unix.Timespec{}\n\t//\t\t\tfor { // loop until no more time remaining\n\t//\t\t\t\terr := unix.ClockNanosleep(unix.CLOCK_MONOTONIC, 0, &rel, &remain)\n\t//\t\t\t--snip--\n\t//\n\t// # Notes:\n\t//   - This does not default to time.Sleep as that violates sandboxing.\n\t//   - This is used to implement host functions such as WASI `poll_oneoff`.\n\t//   - Some compilers implement sleep by looping on sys.Nanotime (e.g. Go).\n\t//   - If you set this, you should probably set WithNanotime also.\n\t//   - Use WithSysNanosleep for a usable implementation.\n\tWithNanosleep(sys.Nanosleep) ModuleConfig\n\n\t// WithOsyield yields the processor, typically to implement spin-wait\n\t// loops. Defaults to return immediately.\n\t//\n\t// # Notes:\n\t//   - This primarily supports `sched_yield` in WASI\n\t//   - This does not default to runtime.osyield as that violates sandboxing.\n\tWithOsyield(sys.Osyield) ModuleConfig\n\n\t// WithSysNanosleep uses time.Sleep for sys.Nanosleep.\n\t//\n\t// See WithNanosleep\n\tWithSysNanosleep() ModuleConfig\n\n\t// WithRandSource configures a source of random bytes. Defaults to return a\n\t// deterministic source. You might override this with crypto/rand.Reader\n\t//\n\t// This reader is most commonly used by the functions like \"random_get\" in\n\t// \"wasi_snapshot_preview1\", \"seed\" in AssemblyScript standard \"env\", and\n\t// \"getRandomData\" when runtime.GOOS is \"js\".\n\t//\n\t// Note: The caller is responsible to close any io.Reader they supply: It\n\t// is not closed on api.Module Close.\n\tWithRandSource(io.Reader) ModuleConfig\n}\n\ntype moduleConfig struct {\n\tname               string\n\tnameSet            bool\n\tstartFunctions     []string\n\tstdin              io.Reader\n\tstdout             io.Writer\n\tstderr             io.Writer\n\trandSource         io.Reader\n\twalltime           sys.Walltime\n\twalltimeResolution sys.ClockResolution\n\tnanotime           sys.Nanotime\n\tnanotimeResolution sys.ClockResolution\n\tnanosleep          sys.Nanosleep\n\tosyield            sys.Osyield\n\targs               [][]byte\n\t// environ is pair-indexed to retain order similar to os.Environ.\n\tenviron [][]byte\n\t// environKeys allow overwriting of existing values.\n\tenvironKeys map[string]int\n\t// fsConfig is the file system configuration for ABI like WASI.\n\tfsConfig FSConfig\n\t// sockConfig is the network listener configuration for ABI like WASI.\n\tsockConfig *internalsock.Config\n}\n\n// NewModuleConfig returns a ModuleConfig that can be used for configuring module instantiation.\nfunc NewModuleConfig() ModuleConfig {\n\treturn &moduleConfig{\n\t\tstartFunctions: []string{\"_start\"},\n\t\tenvironKeys:    map[string]int{},\n\t}\n}\n\n// clone makes a deep copy of this module config.\nfunc (c *moduleConfig) clone() *moduleConfig {\n\tret := *c // copy except maps which share a ref\n\tret.environKeys = make(map[string]int, len(c.environKeys))\n\tfor key, value := range c.environKeys {\n\t\tret.environKeys[key] = value\n\t}\n\treturn &ret\n}\n\n// WithArgs implements ModuleConfig.WithArgs\nfunc (c *moduleConfig) WithArgs(args ...string) ModuleConfig {\n\tret := c.clone()\n\tret.args = toByteSlices(args)\n\treturn ret\n}\n\nfunc toByteSlices(strings []string) (result [][]byte) {\n\tif len(strings) == 0 {\n\t\treturn\n\t}\n\tresult = make([][]byte, len(strings))\n\tfor i, a := range strings {\n\t\tresult[i] = []byte(a)\n\t}\n\treturn\n}\n\n// WithEnv implements ModuleConfig.WithEnv\nfunc (c *moduleConfig) WithEnv(key, value string) ModuleConfig {\n\tret := c.clone()\n\t// Check to see if this key already exists and update it.\n\tif i, ok := ret.environKeys[key]; ok {\n\t\tret.environ[i+1] = []byte(value) // environ is pair-indexed, so the value is 1 after the key.\n\t} else {\n\t\tret.environKeys[key] = len(ret.environ)\n\t\tret.environ = append(ret.environ, []byte(key), []byte(value))\n\t}\n\treturn ret\n}\n\n// WithFS implements ModuleConfig.WithFS\nfunc (c *moduleConfig) WithFS(fs fs.FS) ModuleConfig {\n\tvar config FSConfig\n\tif fs != nil {\n\t\tconfig = NewFSConfig().WithFSMount(fs, \"\")\n\t}\n\treturn c.WithFSConfig(config)\n}\n\n// WithFSConfig implements ModuleConfig.WithFSConfig\nfunc (c *moduleConfig) WithFSConfig(config FSConfig) ModuleConfig {\n\tret := c.clone()\n\tret.fsConfig = config\n\treturn ret\n}\n\n// WithName implements ModuleConfig.WithName\nfunc (c *moduleConfig) WithName(name string) ModuleConfig {\n\tret := c.clone()\n\tret.nameSet = true\n\tret.name = name\n\treturn ret\n}\n\n// WithStartFunctions implements ModuleConfig.WithStartFunctions\nfunc (c *moduleConfig) WithStartFunctions(startFunctions ...string) ModuleConfig {\n\tret := c.clone()\n\tret.startFunctions = startFunctions\n\treturn ret\n}\n\n// WithStderr implements ModuleConfig.WithStderr\nfunc (c *moduleConfig) WithStderr(stderr io.Writer) ModuleConfig {\n\tret := c.clone()\n\tret.stderr = stderr\n\treturn ret\n}\n\n// WithStdin implements ModuleConfig.WithStdin\nfunc (c *moduleConfig) WithStdin(stdin io.Reader) ModuleConfig {\n\tret := c.clone()\n\tret.stdin = stdin\n\treturn ret\n}\n\n// WithStdout implements ModuleConfig.WithStdout\nfunc (c *moduleConfig) WithStdout(stdout io.Writer) ModuleConfig {\n\tret := c.clone()\n\tret.stdout = stdout\n\treturn ret\n}\n\n// WithWalltime implements ModuleConfig.WithWalltime\nfunc (c *moduleConfig) WithWalltime(walltime sys.Walltime, resolution sys.ClockResolution) ModuleConfig {\n\tret := c.clone()\n\tret.walltime = walltime\n\tret.walltimeResolution = resolution\n\treturn ret\n}\n\n// We choose arbitrary resolutions here because there's no perfect alternative. For example, according to the\n// source in time.go, windows monotonic resolution can be 15ms. This chooses arbitrarily 1us for wall time and\n// 1ns for monotonic. See RATIONALE.md for more context.\n\n// WithSysWalltime implements ModuleConfig.WithSysWalltime\nfunc (c *moduleConfig) WithSysWalltime() ModuleConfig {\n\treturn c.WithWalltime(platform.Walltime, sys.ClockResolution(time.Microsecond.Nanoseconds()))\n}\n\n// WithNanotime implements ModuleConfig.WithNanotime\nfunc (c *moduleConfig) WithNanotime(nanotime sys.Nanotime, resolution sys.ClockResolution) ModuleConfig {\n\tret := c.clone()\n\tret.nanotime = nanotime\n\tret.nanotimeResolution = resolution\n\treturn ret\n}\n\n// WithSysNanotime implements ModuleConfig.WithSysNanotime\nfunc (c *moduleConfig) WithSysNanotime() ModuleConfig {\n\treturn c.WithNanotime(platform.Nanotime, sys.ClockResolution(1))\n}\n\n// WithNanosleep implements ModuleConfig.WithNanosleep\nfunc (c *moduleConfig) WithNanosleep(nanosleep sys.Nanosleep) ModuleConfig {\n\tret := *c // copy\n\tret.nanosleep = nanosleep\n\treturn &ret\n}\n\n// WithOsyield implements ModuleConfig.WithOsyield\nfunc (c *moduleConfig) WithOsyield(osyield sys.Osyield) ModuleConfig {\n\tret := *c // copy\n\tret.osyield = osyield\n\treturn &ret\n}\n\n// WithSysNanosleep implements ModuleConfig.WithSysNanosleep\nfunc (c *moduleConfig) WithSysNanosleep() ModuleConfig {\n\treturn c.WithNanosleep(platform.Nanosleep)\n}\n\n// WithRandSource implements ModuleConfig.WithRandSource\nfunc (c *moduleConfig) WithRandSource(source io.Reader) ModuleConfig {\n\tret := c.clone()\n\tret.randSource = source\n\treturn ret\n}\n\n// toSysContext creates a baseline wasm.Context configured by ModuleConfig.\nfunc (c *moduleConfig) toSysContext() (sysCtx *internalsys.Context, err error) {\n\tvar environ [][]byte // Intentionally doesn't pre-allocate to reduce logic to default to nil.\n\t// Same validation as syscall.Setenv for Linux\n\tfor i := 0; i < len(c.environ); i += 2 {\n\t\tkey, value := c.environ[i], c.environ[i+1]\n\t\tkeyLen := len(key)\n\t\tif keyLen == 0 {\n\t\t\terr = errors.New(\"environ invalid: empty key\")\n\t\t\treturn\n\t\t}\n\t\tvalueLen := len(value)\n\t\tresult := make([]byte, keyLen+valueLen+1)\n\t\tj := 0\n\t\tfor ; j < keyLen; j++ {\n\t\t\tif k := key[j]; k == '=' { // NUL enforced in NewContext\n\t\t\t\terr = errors.New(\"environ invalid: key contains '=' character\")\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\tresult[j] = k\n\t\t\t}\n\t\t}\n\t\tresult[j] = '='\n\t\tcopy(result[j+1:], value)\n\t\tenviron = append(environ, result)\n\t}\n\n\tvar fs []experimentalsys.FS\n\tvar guestPaths []string\n\tif f, ok := c.fsConfig.(*fsConfig); ok {\n\t\tfs, guestPaths = f.preopens()\n\t}\n\n\tvar listeners []*net.TCPListener\n\tif n := c.sockConfig; n != nil {\n\t\tif listeners, err = n.BuildTCPListeners(); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn internalsys.NewContext(\n\t\tmath.MaxUint32,\n\t\tc.args,\n\t\tenviron,\n\t\tc.stdin,\n\t\tc.stdout,\n\t\tc.stderr,\n\t\tc.randSource,\n\t\tc.walltime, c.walltimeResolution,\n\t\tc.nanotime, c.nanotimeResolution,\n\t\tc.nanosleep, c.osyield,\n\t\tfs, guestPaths,\n\t\tlisteners,\n\t)\n}\n"
        },
        {
          "name": "config_example_test.go",
          "type": "blob",
          "size": 0.8828125,
          "content": "package wazero_test\n\nimport (\n\t\"context\"\n\t_ \"embed\"\n\t\"log\"\n\n\t\"github.com/tetratelabs/wazero\"\n\t\"github.com/tetratelabs/wazero/api\"\n)\n\n// This is a basic example of retrieving custom sections using RuntimeConfig.WithCustomSections.\nfunc Example_runtimeConfig_WithCustomSections() {\n\tctx := context.Background()\n\tconfig := wazero.NewRuntimeConfig().WithCustomSections(true)\n\n\tr := wazero.NewRuntimeWithConfig(ctx, config)\n\tdefer r.Close(ctx)\n\n\tm, err := r.CompileModule(ctx, addWasm)\n\tif err != nil {\n\t\tlog.Panicln(err)\n\t}\n\n\tif m.CustomSections() == nil {\n\t\tlog.Panicln(\"Custom sections should not be nil\")\n\t}\n\n\tmustContain(m.CustomSections(), \"producers\")\n\tmustContain(m.CustomSections(), \"target_features\")\n\n\t// Output:\n\t//\n}\n\nfunc mustContain(ss []api.CustomSection, name string) {\n\tfor _, s := range ss {\n\t\tif s.Name() == name {\n\t\t\treturn\n\t\t}\n\t}\n\tlog.Panicf(\"Could not find section named %s\\n\", name)\n}\n"
        },
        {
          "name": "config_supported.go",
          "type": "blob",
          "size": 0.654296875,
          "content": "// Note: The build constraints here are about the compiler, which is more\n// narrow than the architectures supported by the assembler.\n//\n// Constraints here must match platform.CompilerSupported.\n//\n// Meanwhile, users who know their runtime.GOOS can operate with the compiler\n// may choose to use NewRuntimeConfigCompiler explicitly.\n//go:build (amd64 || arm64) && (linux || darwin || freebsd || netbsd || dragonfly || solaris || windows)\n\npackage wazero\n\nimport \"github.com/tetratelabs/wazero/internal/platform\"\n\nfunc newRuntimeConfig() RuntimeConfig {\n\tif platform.CompilerSupported() {\n\t\treturn NewRuntimeConfigCompiler()\n\t}\n\treturn NewRuntimeConfigInterpreter()\n}\n"
        },
        {
          "name": "config_test.go",
          "type": "blob",
          "size": 17.9921875,
          "content": "package wazero\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t_ \"embed\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/tetratelabs/wazero/api\"\n\t\"github.com/tetratelabs/wazero/internal/fstest\"\n\t\"github.com/tetratelabs/wazero/internal/platform\"\n\tinternalsys \"github.com/tetratelabs/wazero/internal/sys\"\n\t\"github.com/tetratelabs/wazero/internal/testing/require\"\n\t\"github.com/tetratelabs/wazero/internal/wasm\"\n\t\"github.com/tetratelabs/wazero/sys\"\n)\n\nfunc TestRuntimeConfig(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\twith     func(RuntimeConfig) RuntimeConfig\n\t\texpected RuntimeConfig\n\t}{\n\t\t{\n\t\t\tname: \"features\",\n\t\t\twith: func(c RuntimeConfig) RuntimeConfig {\n\t\t\t\treturn c.WithCoreFeatures(api.CoreFeaturesV1)\n\t\t\t},\n\t\t\texpected: &runtimeConfig{\n\t\t\t\tenabledFeatures: api.CoreFeaturesV1,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"memoryLimitPages\",\n\t\t\twith: func(c RuntimeConfig) RuntimeConfig {\n\t\t\t\treturn c.WithMemoryLimitPages(10)\n\t\t\t},\n\t\t\texpected: &runtimeConfig{\n\t\t\t\tmemoryLimitPages: 10,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"memoryCapacityFromMax\",\n\t\t\twith: func(c RuntimeConfig) RuntimeConfig {\n\t\t\t\treturn c.WithMemoryCapacityFromMax(true)\n\t\t\t},\n\t\t\texpected: &runtimeConfig{\n\t\t\t\tmemoryCapacityFromMax: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithDebugInfoEnabled\",\n\t\t\twith: func(c RuntimeConfig) RuntimeConfig {\n\t\t\t\treturn c.WithDebugInfoEnabled(false)\n\t\t\t},\n\t\t\texpected: &runtimeConfig{\n\t\t\t\tdwarfDisabled: true, // dwarf is a more technical name and ok here.\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithCustomSections\",\n\t\t\twith: func(c RuntimeConfig) RuntimeConfig {\n\t\t\t\treturn c.WithCustomSections(true)\n\t\t\t},\n\t\t\texpected: &runtimeConfig{\n\t\t\t\tstoreCustomSections: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"WithCloseOnContextDone\",\n\t\t\twith:     func(c RuntimeConfig) RuntimeConfig { return c.WithCloseOnContextDone(true) },\n\t\t\texpected: &runtimeConfig{ensureTermination: true},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttc := tt\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tinput := &runtimeConfig{}\n\t\t\trc := tc.with(input)\n\t\t\trequire.Equal(t, tc.expected, rc)\n\t\t\t// The source wasn't modified\n\t\t\trequire.Equal(t, &runtimeConfig{}, input)\n\t\t})\n\t}\n\n\tt.Run(\"memoryLimitPages invalid panics\", func(t *testing.T) {\n\t\terr := require.CapturePanic(func() {\n\t\t\tinput := &runtimeConfig{}\n\t\t\tinput.WithMemoryLimitPages(wasm.MemoryLimitPages + 1)\n\t\t})\n\t\trequire.EqualError(t, err, \"memoryLimitPages invalid: 65537 > 65536\")\n\t})\n}\n\nfunc TestModuleConfig(t *testing.T) {\n\ttests := []struct {\n\t\tname          string\n\t\twith          func(ModuleConfig) ModuleConfig\n\t\texpectNameSet bool\n\t\texpectedName  string\n\t}{\n\t\t{\n\t\t\tname: \"WithName default\",\n\t\t\twith: func(c ModuleConfig) ModuleConfig {\n\t\t\t\treturn c\n\t\t\t},\n\t\t\texpectNameSet: false,\n\t\t\texpectedName:  \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"WithName\",\n\t\t\twith: func(c ModuleConfig) ModuleConfig {\n\t\t\t\treturn c.WithName(\"wazero\")\n\t\t\t},\n\t\t\texpectNameSet: true,\n\t\t\texpectedName:  \"wazero\",\n\t\t},\n\t\t{\n\t\t\tname: \"WithName empty\",\n\t\t\twith: func(c ModuleConfig) ModuleConfig {\n\t\t\t\treturn c.WithName(\"\")\n\t\t\t},\n\t\t\texpectNameSet: true,\n\t\t\texpectedName:  \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"WithName twice\",\n\t\t\twith: func(c ModuleConfig) ModuleConfig {\n\t\t\t\treturn c.WithName(\"wazero\").WithName(\"wa0\")\n\t\t\t},\n\t\t\texpectNameSet: true,\n\t\t\texpectedName:  \"wa0\",\n\t\t},\n\t\t{\n\t\t\tname: \"WithName can clear\",\n\t\t\twith: func(c ModuleConfig) ModuleConfig {\n\t\t\t\treturn c.WithName(\"wazero\").WithName(\"\")\n\t\t\t},\n\t\t\texpectNameSet: true,\n\t\t\texpectedName:  \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\ttc := tt\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tinput := NewModuleConfig()\n\t\t\trc := tc.with(input)\n\t\t\trequire.Equal(t, tc.expectNameSet, rc.(*moduleConfig).nameSet)\n\t\t\trequire.Equal(t, tc.expectedName, rc.(*moduleConfig).name)\n\t\t\t// The source wasn't modified\n\t\t\trequire.Equal(t, NewModuleConfig(), input)\n\t\t})\n\t}\n}\n\n// TestModuleConfig_toSysContext only tests the cases that change the inputs to\n// sys.NewContext.\nfunc TestModuleConfig_toSysContext(t *testing.T) {\n\tbase := NewModuleConfig()\n\n\ttests := []struct {\n\t\tname  string\n\t\tinput func() (mc ModuleConfig, verify func(t *testing.T, sys *internalsys.Context))\n\t}{\n\t\t{\n\t\t\tname: \"empty\",\n\t\t\tinput: func() (ModuleConfig, func(t *testing.T, sys *internalsys.Context)) {\n\t\t\t\treturn base, func(t *testing.T, sys *internalsys.Context) { require.NotNil(t, sys) }\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithNanotime\",\n\t\t\tinput: func() (ModuleConfig, func(t *testing.T, sys *internalsys.Context)) {\n\t\t\t\tconfig := base.WithNanotime(func() int64 { return 1234567 }, 54321)\n\t\t\t\treturn config, func(t *testing.T, sys *internalsys.Context) {\n\t\t\t\t\trequire.Equal(t, 1234567, int(sys.Nanotime()))\n\t\t\t\t\trequire.Equal(t, 54321, int(sys.NanotimeResolution()))\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithSysNanotime\",\n\t\t\tinput: func() (ModuleConfig, func(t *testing.T, sys *internalsys.Context)) {\n\t\t\t\tconfig := base.WithSysNanotime()\n\t\t\t\treturn config, func(t *testing.T, sys *internalsys.Context) {\n\t\t\t\t\trequire.Equal(t, int(1), int(sys.NanotimeResolution()))\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithWalltime\",\n\t\t\tinput: func() (ModuleConfig, func(t *testing.T, sys *internalsys.Context)) {\n\t\t\t\tconfig := base.WithWalltime(func() (sec int64, nsec int32) { return 5, 10 }, 54321)\n\t\t\t\treturn config, func(t *testing.T, sys *internalsys.Context) {\n\t\t\t\t\tactualSec, actualNano := sys.Walltime()\n\t\t\t\t\trequire.Equal(t, 5, int(actualSec))\n\t\t\t\t\trequire.Equal(t, 10, int(actualNano))\n\t\t\t\t\trequire.Equal(t, 54321, int(sys.WalltimeResolution()))\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithSysWalltime\",\n\t\t\tinput: func() (ModuleConfig, func(t *testing.T, sys *internalsys.Context)) {\n\t\t\t\tconfig := base.WithSysWalltime()\n\t\t\t\treturn config, func(t *testing.T, sys *internalsys.Context) {\n\t\t\t\t\trequire.Equal(t, int(time.Microsecond.Nanoseconds()), int(sys.WalltimeResolution()))\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithArgs empty\",\n\t\t\tinput: func() (ModuleConfig, func(t *testing.T, sys *internalsys.Context)) {\n\t\t\t\tconfig := base.WithArgs()\n\t\t\t\treturn config, func(t *testing.T, sys *internalsys.Context) {\n\t\t\t\t\targs := sys.Args()\n\t\t\t\t\trequire.Equal(t, 0, len(args))\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithArgs\",\n\t\t\tinput: func() (ModuleConfig, func(t *testing.T, sys *internalsys.Context)) {\n\t\t\t\tconfig := base.WithArgs(\"a\", \"bc\")\n\t\t\t\treturn config, func(t *testing.T, sys *internalsys.Context) {\n\t\t\t\t\targs := sys.Args()\n\t\t\t\t\trequire.Equal(t, 2, len(args))\n\t\t\t\t\trequire.Equal(t, \"a\", string(args[0]))\n\t\t\t\t\trequire.Equal(t, \"bc\", string(args[1]))\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithArgs empty ok\", // Particularly argv[0] can be empty, and we have no rules about others.\n\t\t\tinput: func() (ModuleConfig, func(t *testing.T, sys *internalsys.Context)) {\n\t\t\t\tconfig := base.WithArgs(\"\", \"bc\")\n\t\t\t\treturn config, func(t *testing.T, sys *internalsys.Context) {\n\t\t\t\t\targs := sys.Args()\n\t\t\t\t\trequire.Equal(t, 2, len(args))\n\t\t\t\t\trequire.Equal(t, \"\", string(args[0]))\n\t\t\t\t\trequire.Equal(t, \"bc\", string(args[1]))\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithArgs second call overwrites\",\n\t\t\tinput: func() (ModuleConfig, func(t *testing.T, sys *internalsys.Context)) {\n\t\t\t\tconfig := base.WithArgs(\"a\", \"bc\").WithArgs(\"bc\", \"a\")\n\t\t\t\treturn config, func(t *testing.T, sys *internalsys.Context) {\n\t\t\t\t\targs := sys.Args()\n\t\t\t\t\trequire.Equal(t, 2, len(args))\n\t\t\t\t\trequire.Equal(t, \"bc\", string(args[0]))\n\t\t\t\t\trequire.Equal(t, \"a\", string(args[1]))\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithEnv\",\n\t\t\tinput: func() (ModuleConfig, func(t *testing.T, sys *internalsys.Context)) {\n\t\t\t\tconfig := base.WithEnv(\"a\", \"b\")\n\t\t\t\treturn config, func(t *testing.T, sys *internalsys.Context) {\n\t\t\t\t\tenvs := sys.Environ()\n\t\t\t\t\trequire.Equal(t, 1, len(envs))\n\t\t\t\t\trequire.Equal(t, \"a=b\", string(envs[0]))\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithEnv empty value\",\n\t\t\tinput: func() (ModuleConfig, func(t *testing.T, sys *internalsys.Context)) {\n\t\t\t\tconfig := base.WithEnv(\"a\", \"\")\n\t\t\t\treturn config, func(t *testing.T, sys *internalsys.Context) {\n\t\t\t\t\tenvs := sys.Environ()\n\t\t\t\t\trequire.Equal(t, 1, len(envs))\n\t\t\t\t\trequire.Equal(t, \"a=\", string(envs[0]))\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithEnv twice\",\n\t\t\tinput: func() (ModuleConfig, func(t *testing.T, sys *internalsys.Context)) {\n\t\t\t\tconfig := base.WithEnv(\"a\", \"b\").WithEnv(\"c\", \"de\")\n\t\t\t\treturn config, func(t *testing.T, sys *internalsys.Context) {\n\t\t\t\t\tenvs := sys.Environ()\n\t\t\t\t\trequire.Equal(t, 2, len(envs))\n\t\t\t\t\trequire.Equal(t, \"a=b\", string(envs[0]))\n\t\t\t\t\trequire.Equal(t, \"c=de\", string(envs[1]))\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithEnv overwrites\",\n\t\t\tinput: func() (ModuleConfig, func(t *testing.T, sys *internalsys.Context)) {\n\t\t\t\tconfig := base.WithEnv(\"a\", \"bc\").WithEnv(\"c\", \"de\").WithEnv(\"a\", \"ff\")\n\t\t\t\treturn config, func(t *testing.T, sys *internalsys.Context) {\n\t\t\t\t\tenvs := sys.Environ()\n\t\t\t\t\trequire.Equal(t, 2, len(envs))\n\t\t\t\t\trequire.Equal(t, \"a=ff\", string(envs[0]))\n\t\t\t\t\trequire.Equal(t, \"c=de\", string(envs[1]))\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithEnv twice\",\n\t\t\tinput: func() (ModuleConfig, func(t *testing.T, sys *internalsys.Context)) {\n\t\t\t\tconfig := base.WithEnv(\"a\", \"b\").WithEnv(\"c\", \"de\")\n\t\t\t\treturn config, func(t *testing.T, sys *internalsys.Context) {\n\t\t\t\t\tenvs := sys.Environ()\n\t\t\t\t\trequire.Equal(t, 2, len(envs))\n\t\t\t\t\trequire.Equal(t, \"a=b\", string(envs[0]))\n\t\t\t\t\trequire.Equal(t, \"c=de\", string(envs[1]))\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithRandSource\",\n\t\t\tinput: func() (ModuleConfig, func(t *testing.T, sys *internalsys.Context)) {\n\t\t\t\tr := bytes.NewReader([]byte{1, 2, 3, 4})\n\t\t\t\tconfig := base.WithRandSource(r)\n\t\t\t\treturn config, func(t *testing.T, sys *internalsys.Context) {\n\t\t\t\t\tactual := sys.RandSource()\n\t\t\t\t\trequire.Equal(t, r, actual)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithRandSource nil\",\n\t\t\tinput: func() (ModuleConfig, func(t *testing.T, sys *internalsys.Context)) {\n\t\t\t\tconfig := base.WithRandSource(nil)\n\t\t\t\treturn config, func(t *testing.T, sys *internalsys.Context) {\n\t\t\t\t\tactual := sys.RandSource()\n\t\t\t\t\trequire.Equal(t, platform.NewFakeRandSource(), actual)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttc := tt\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tconfig, verify := tc.input()\n\t\t\tactual, err := config.(*moduleConfig).toSysContext()\n\t\t\trequire.NoError(t, err)\n\t\t\tverify(t, actual)\n\t\t})\n\t}\n}\n\n// TestModuleConfig_toSysContext_WithWalltime has to test differently because we can't\n// compare function pointers when functions are passed by value.\nfunc TestModuleConfig_toSysContext_WithWalltime(t *testing.T) {\n\ttests := []struct {\n\t\tname               string\n\t\tinput              ModuleConfig\n\t\texpectedSec        int64\n\t\texpectedNsec       int32\n\t\texpectedResolution sys.ClockResolution\n\t\texpectedErr        string\n\t}{\n\t\t{\n\t\t\tname: \"ok\",\n\t\t\tinput: NewModuleConfig().\n\t\t\t\tWithWalltime(func() (sec int64, nsec int32) {\n\t\t\t\t\treturn 1, 2\n\t\t\t\t}, 3),\n\t\t\texpectedSec:        1,\n\t\t\texpectedNsec:       2,\n\t\t\texpectedResolution: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"overwrites\",\n\t\t\tinput: NewModuleConfig().\n\t\t\t\tWithWalltime(func() (sec int64, nsec int32) {\n\t\t\t\t\treturn 3, 4\n\t\t\t\t}, 5).\n\t\t\t\tWithWalltime(func() (sec int64, nsec int32) {\n\t\t\t\t\treturn 1, 2\n\t\t\t\t}, 3),\n\t\t\texpectedSec:        1,\n\t\t\texpectedNsec:       2,\n\t\t\texpectedResolution: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid resolution\",\n\t\t\tinput: NewModuleConfig().\n\t\t\t\tWithWalltime(func() (sec int64, nsec int32) {\n\t\t\t\t\treturn 1, 2\n\t\t\t\t}, 0),\n\t\t\texpectedErr: \"invalid Walltime resolution: 0\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttc := tt\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tsysCtx, err := tc.input.(*moduleConfig).toSysContext()\n\t\t\tif tc.expectedErr == \"\" {\n\t\t\t\trequire.Nil(t, err)\n\t\t\t\tsec, nsec := sysCtx.Walltime()\n\t\t\t\trequire.Equal(t, tc.expectedSec, sec)\n\t\t\t\trequire.Equal(t, tc.expectedNsec, nsec)\n\t\t\t\trequire.Equal(t, tc.expectedResolution, sysCtx.WalltimeResolution())\n\t\t\t} else {\n\t\t\t\trequire.EqualError(t, err, tc.expectedErr)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"context\", func(t *testing.T) {\n\t\tsysCtx, err := NewModuleConfig().\n\t\t\tWithWalltime(func() (sec int64, nsec int32) {\n\t\t\t\treturn 1, 2\n\t\t\t}, 3).(*moduleConfig).toSysContext()\n\t\trequire.NoError(t, err)\n\t\tsec, nsec := sysCtx.Walltime()\n\t\t// If below pass, the context was correct!\n\t\trequire.Equal(t, int64(1), sec)\n\t\trequire.Equal(t, int32(2), nsec)\n\t})\n}\n\n// TestModuleConfig_toSysContext_WithNanotime has to test differently because we can't\n// compare function pointers when functions are passed by value.\nfunc TestModuleConfig_toSysContext_WithNanotime(t *testing.T) {\n\ttests := []struct {\n\t\tname               string\n\t\tinput              ModuleConfig\n\t\texpectedNanos      int64\n\t\texpectedResolution sys.ClockResolution\n\t\texpectedErr        string\n\t}{\n\t\t{\n\t\t\tname: \"ok\",\n\t\t\tinput: NewModuleConfig().\n\t\t\t\tWithNanotime(func() int64 {\n\t\t\t\t\treturn 1\n\t\t\t\t}, 2),\n\t\t\texpectedNanos:      1,\n\t\t\texpectedResolution: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"overwrites\",\n\t\t\tinput: NewModuleConfig().\n\t\t\t\tWithNanotime(func() int64 {\n\t\t\t\t\treturn 3\n\t\t\t\t}, 4).\n\t\t\t\tWithNanotime(func() int64 {\n\t\t\t\t\treturn 1\n\t\t\t\t}, 2),\n\t\t\texpectedNanos:      1,\n\t\t\texpectedResolution: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid resolution\",\n\t\t\tinput: NewModuleConfig().\n\t\t\t\tWithNanotime(func() int64 {\n\t\t\t\t\treturn 1\n\t\t\t\t}, 0),\n\t\t\texpectedErr: \"invalid Nanotime resolution: 0\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttc := tt\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tsysCtx, err := tc.input.(*moduleConfig).toSysContext()\n\t\t\tif tc.expectedErr == \"\" {\n\t\t\t\trequire.Nil(t, err)\n\t\t\t\tnanos := sysCtx.Nanotime()\n\t\t\t\trequire.Equal(t, tc.expectedNanos, nanos)\n\t\t\t\trequire.Equal(t, tc.expectedResolution, sysCtx.NanotimeResolution())\n\t\t\t} else {\n\t\t\t\trequire.EqualError(t, err, tc.expectedErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestModuleConfig_toSysContext_WithNanosleep has to test differently because\n// we can't compare function pointers when functions are passed by value.\nfunc TestModuleConfig_toSysContext_WithNanosleep(t *testing.T) {\n\tsysCtx, err := NewModuleConfig().\n\t\tWithNanosleep(func(ns int64) {\n\t\t\trequire.Equal(t, int64(2), ns)\n\t\t}).(*moduleConfig).toSysContext()\n\trequire.NoError(t, err)\n\tsysCtx.Nanosleep(2)\n}\n\n// TestModuleConfig_toSysContext_WithOsyield has to test differently because\n// we can't compare function pointers when functions are passed by value.\nfunc TestModuleConfig_toSysContext_WithOsyield(t *testing.T) {\n\tvar yielded bool\n\tsysCtx, err := NewModuleConfig().\n\t\tWithOsyield(func() {\n\t\t\tyielded = true\n\t\t}).(*moduleConfig).toSysContext()\n\trequire.NoError(t, err)\n\tsysCtx.Osyield()\n\trequire.True(t, yielded)\n}\n\nfunc TestModuleConfig_toSysContext_Errors(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tinput       ModuleConfig\n\t\texpectedErr string\n\t}{\n\t\t{\n\t\t\tname:        \"WithArgs arg contains NUL\",\n\t\t\tinput:       NewModuleConfig().WithArgs(\"\", string([]byte{'a', 0})),\n\t\t\texpectedErr: \"args invalid: contains NUL character\",\n\t\t},\n\t\t{\n\t\t\tname:        \"WithEnv key contains NUL\",\n\t\t\tinput:       NewModuleConfig().WithEnv(string([]byte{'a', 0}), \"a\"),\n\t\t\texpectedErr: \"environ invalid: contains NUL character\",\n\t\t},\n\t\t{\n\t\t\tname:        \"WithEnv value contains NUL\",\n\t\t\tinput:       NewModuleConfig().WithEnv(\"a\", string([]byte{'a', 0})),\n\t\t\texpectedErr: \"environ invalid: contains NUL character\",\n\t\t},\n\t\t{\n\t\t\tname:        \"WithEnv key contains equals\",\n\t\t\tinput:       NewModuleConfig().WithEnv(\"a=\", \"a\"),\n\t\t\texpectedErr: \"environ invalid: key contains '=' character\",\n\t\t},\n\t\t{\n\t\t\tname:        \"WithEnv empty key\",\n\t\t\tinput:       NewModuleConfig().WithEnv(\"\", \"a\"),\n\t\t\texpectedErr: \"environ invalid: empty key\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\ttc := tt\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t_, err := tc.input.(*moduleConfig).toSysContext()\n\t\t\trequire.EqualError(t, err, tc.expectedErr)\n\t\t})\n\t}\n}\n\nfunc TestModuleConfig_clone(t *testing.T) {\n\tmc := NewModuleConfig().(*moduleConfig)\n\tcloned := mc.clone()\n\n\t// Make post-clone changes\n\tmc.fsConfig = NewFSConfig().WithFSMount(fstest.FS, \"/\")\n\tmc.environKeys[\"2\"] = 2\n\n\tcloned.environKeys[\"1\"] = 1\n\n\t// Ensure the maps are not shared\n\trequire.Equal(t, map[string]int{\"2\": 2}, mc.environKeys)\n\trequire.Equal(t, map[string]int{\"1\": 1}, cloned.environKeys)\n\n\t// Ensure the fs is not shared\n\trequire.Nil(t, cloned.fsConfig)\n}\n\nfunc Test_compiledModule_Name(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *compiledModule\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:  \"no name section\",\n\t\t\tinput: &compiledModule{module: &wasm.Module{}},\n\t\t},\n\t\t{\n\t\t\tname:  \"empty name\",\n\t\t\tinput: &compiledModule{module: &wasm.Module{NameSection: &wasm.NameSection{}}},\n\t\t},\n\t\t{\n\t\t\tname:     \"name\",\n\t\t\tinput:    &compiledModule{module: &wasm.Module{NameSection: &wasm.NameSection{ModuleName: \"foo\"}}},\n\t\t\texpected: \"foo\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttc := tt\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\trequire.Equal(t, tc.expected, tc.input.Name())\n\t\t})\n\t}\n}\n\nfunc Test_compiledModule_CustomSections(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    *compiledModule\n\t\texpected []string\n\t}{\n\t\t{\n\t\t\tname:     \"no custom section\",\n\t\t\tinput:    &compiledModule{module: &wasm.Module{}},\n\t\t\texpected: []string{},\n\t\t},\n\t\t{\n\t\t\tname: \"name\",\n\t\t\tinput: &compiledModule{module: &wasm.Module{\n\t\t\t\tCustomSections: []*wasm.CustomSection{\n\t\t\t\t\t{Name: \"custom1\"},\n\t\t\t\t\t{Name: \"custom2\"},\n\t\t\t\t\t{Name: \"customDup\"},\n\t\t\t\t\t{Name: \"customDup\"},\n\t\t\t\t},\n\t\t\t}},\n\t\t\texpected: []string{\n\t\t\t\t\"custom1\",\n\t\t\t\t\"custom2\",\n\t\t\t\t\"customDup\",\n\t\t\t\t\"customDup\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttc := tt\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tcustomSections := tc.input.CustomSections()\n\t\t\trequire.Equal(t, len(tc.expected), len(customSections))\n\t\t\tfor i := 0; i < len(tc.expected); i++ {\n\t\t\t\trequire.Equal(t, tc.expected[i], customSections[i].Name())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_compiledModule_Close(t *testing.T) {\n\tfor _, ctx := range []context.Context{nil, testCtx} { // Ensure it doesn't crash on nil!\n\t\te := &mockEngine{name: \"1\", cachedModules: map[*wasm.Module]struct{}{}}\n\n\t\tvar cs []*compiledModule\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tm := &wasm.Module{}\n\t\t\terr := e.CompileModule(ctx, m, nil, false)\n\t\t\trequire.NoError(t, err)\n\t\t\tcs = append(cs, &compiledModule{module: m, compiledEngine: e})\n\t\t}\n\n\t\t// Before Close.\n\t\trequire.Equal(t, 10, len(e.cachedModules))\n\n\t\tfor _, c := range cs {\n\t\t\trequire.NoError(t, c.Close(ctx))\n\t\t}\n\n\t\t// After Close.\n\t\trequire.Zero(t, len(e.cachedModules))\n\t}\n}\n\nfunc TestNewRuntimeConfig(t *testing.T) {\n\tc, ok := NewRuntimeConfig().(*runtimeConfig)\n\trequire.True(t, ok)\n\t// Should be cloned from the source.\n\trequire.NotEqual(t, engineLessConfig, c)\n\t// Ensures if the correct engine is selected.\n\tif platform.CompilerSupported() {\n\t\trequire.Equal(t, engineKindCompiler, c.engineKind)\n\t} else {\n\t\trequire.Equal(t, engineKindInterpreter, c.engineKind)\n\t}\n}\n"
        },
        {
          "name": "config_unsupported.go",
          "type": "blob",
          "size": 0.255859375,
          "content": "// This is the opposite constraint of config_supported.go\n//go:build !(amd64 || arm64) || !(linux || darwin || freebsd || netbsd || dragonfly || solaris || windows)\n\npackage wazero\n\nfunc newRuntimeConfig() RuntimeConfig {\n\treturn NewRuntimeConfigInterpreter()\n}\n"
        },
        {
          "name": "context_done_example_test.go",
          "type": "blob",
          "size": 3.8427734375,
          "content": "package wazero_test\n\nimport (\n\t\"context\"\n\t_ \"embed\"\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/tetratelabs/wazero\"\n)\n\n// infiniteLoopWasm exports a function named \"infinite_loop\" that never exits.\n//\n//go:embed internal/integration_test/engine/testdata/infinite_loop.wasm\nvar infiniteLoopWasm []byte\n\n// ExampleRuntimeConfig_WithCloseOnContextDone_context_timeout demonstrates how to ensure the termination\n// of infinite loop function with context.Context created by context.WithTimeout powered by\n// RuntimeConfig.WithEnsureTermination configuration.\nfunc ExampleRuntimeConfig_WithCloseOnContextDone_context_timeout() {\n\tctx := context.Background()\n\n\tr := wazero.NewRuntimeWithConfig(ctx,\n\t\t// Enables the WithCloseOnContextDone option.\n\t\twazero.NewRuntimeConfig().WithCloseOnContextDone(true))\n\tdefer r.Close(ctx)\n\n\tmoduleInstance, err := r.InstantiateWithConfig(ctx, infiniteLoopWasm,\n\t\twazero.NewModuleConfig().WithName(\"malicious_wasm\"))\n\tif err != nil {\n\t\tlog.Panicln(err)\n\t}\n\n\tinfiniteLoop := moduleInstance.ExportedFunction(\"infinite_loop\")\n\n\t// Create the context.Context to be passed to the invocation of infinite_loop.\n\tctx, cancel := context.WithTimeout(ctx, time.Second)\n\tdefer cancel()\n\n\t// Invoke the infinite loop with the timeout context.\n\t_, err = infiniteLoop.Call(ctx)\n\n\t// Timeout is correctly handled and triggers the termination of infinite loop.\n\tfmt.Println(err)\n\n\t// Output:\n\t//\tmodule closed with context deadline exceeded\n}\n\n// ExampleRuntimeConfig_WithCloseOnContextDone_context_cancel demonstrates how to ensure the termination\n// of infinite loop function with context.Context created by context.WithCancel powered by\n// RuntimeConfig.WithEnsureTermination configuration.\nfunc ExampleRuntimeConfig_WithCloseOnContextDone_context_cancel() {\n\tctx := context.Background()\n\n\tr := wazero.NewRuntimeWithConfig(ctx,\n\t\t// Enables the WithCloseOnContextDone option.\n\t\twazero.NewRuntimeConfig().WithCloseOnContextDone(true))\n\tdefer r.Close(ctx)\n\n\tmoduleInstance, err := r.InstantiateWithConfig(ctx, infiniteLoopWasm,\n\t\twazero.NewModuleConfig().WithName(\"malicious_wasm\"))\n\tif err != nil {\n\t\tlog.Panicln(err)\n\t}\n\n\tinfiniteLoop := moduleInstance.ExportedFunction(\"infinite_loop\")\n\n\t// Create the context.Context to be passed to the invocation of infinite_loop.\n\tctx, cancel := context.WithCancel(ctx)\n\tgo func() {\n\t\t// After 2 seconds, cancel the invocation of infinite loop.\n\t\ttime.Sleep(2 * time.Second)\n\t\tcancel()\n\t}()\n\n\t// Invoke the infinite loop with the timeout context.\n\t_, err = infiniteLoop.Call(ctx)\n\n\t// context Cancellation is correctly handled and triggers the termination of infinite loop.\n\tfmt.Println(err)\n\n\t// Output:\n\t//\tmodule closed with context canceled\n}\n\n// ExampleRuntimeConfig_WithCloseOnContextDone_moduleClose demonstrates how to ensure the termination\n// of infinite loop function with api.Module's CloseWithExitCode method powered by\n// RuntimeConfig.WithEnsureTermination configuration.\nfunc ExampleRuntimeConfig_WithCloseOnContextDone_moduleClose() {\n\tctx := context.Background()\n\n\tr := wazero.NewRuntimeWithConfig(ctx,\n\t\t// Enables the WithCloseOnContextDone option.\n\t\twazero.NewRuntimeConfig().WithCloseOnContextDone(true))\n\tdefer r.Close(ctx)\n\n\tmoduleInstance, err := r.InstantiateWithConfig(ctx, infiniteLoopWasm,\n\t\twazero.NewModuleConfig().WithName(\"malicious_wasm\"))\n\tif err != nil {\n\t\tlog.Panicln(err)\n\t}\n\n\tinfiniteLoop := moduleInstance.ExportedFunction(\"infinite_loop\")\n\n\tgo func() {\n\t\t// After 2 seconds, close the module instance with CloseWithExitCode, which triggers the termination\n\t\t// of infinite loop.\n\t\ttime.Sleep(2 * time.Second)\n\t\tif err := moduleInstance.CloseWithExitCode(ctx, 1); err != nil {\n\t\t\tlog.Panicln(err)\n\t\t}\n\t}()\n\n\t// Invoke the infinite loop with the timeout context.\n\t_, err = infiniteLoop.Call(ctx)\n\n\t// The exit code is correctly handled and triggers the termination of infinite loop.\n\tfmt.Println(err)\n\n\t// Output:\n\t//\tmodule closed with exit_code(1)\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 1.5224609375,
          "content": "package wazero_test\n\nimport (\n\t\"context\"\n\t_ \"embed\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/tetratelabs/wazero\"\n\t\"github.com/tetratelabs/wazero/imports/wasi_snapshot_preview1\"\n)\n\n// addWasm was generated by the following:\n//\n//\tcd examples/basic/testdata; tinygo build -o add.wasm -target=wasi add.go\n//\n//go:embed examples/basic/testdata/add.wasm\nvar addWasm []byte\n\n// This is an example of how to extend a Go application with an addition\n// function defined in WebAssembly.\n//\n// Since addWasm was compiled with TinyGo's `wasi` target, we need to configure\n// WASI host imports.\n//\n// A complete project that does the same as this is available here:\n// https://github.com/tetratelabs/wazero/tree/main/examples/basic\nfunc Example() {\n\t// Choose the context to use for function calls.\n\tctx := context.Background()\n\n\t// Create a new WebAssembly Runtime.\n\tr := wazero.NewRuntime(ctx)\n\tdefer r.Close(ctx) // This closes everything this Runtime created.\n\n\t// Instantiate WASI, which implements host functions needed for TinyGo to\n\t// implement `panic`.\n\twasi_snapshot_preview1.MustInstantiate(ctx, r)\n\n\t// Instantiate the guest Wasm into the same runtime. It exports the `add`\n\t// function, implemented in WebAssembly.\n\tmod, err := r.Instantiate(ctx, addWasm)\n\tif err != nil {\n\t\tlog.Panicln(err)\n\t}\n\n\t// Call the `add` function and print the results to the console.\n\tx, y := uint64(1), uint64(2)\n\tresults, err := mod.ExportedFunction(\"add\").Call(ctx, x, y)\n\tif err != nil {\n\t\tlog.Panicln(err)\n\t}\n\n\tfmt.Printf(\"%d + %d = %d\\n\", x, y, results[0])\n\n\t// Output:\n\t// 1 + 2 = 3\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "experimental",
          "type": "tree",
          "content": null
        },
        {
          "name": "fsconfig.go",
          "type": "blob",
          "size": 7.9150390625,
          "content": "package wazero\n\nimport (\n\t\"io/fs\"\n\n\texperimentalsys \"github.com/tetratelabs/wazero/experimental/sys\"\n\t\"github.com/tetratelabs/wazero/internal/sys\"\n\t\"github.com/tetratelabs/wazero/internal/sysfs\"\n)\n\n// FSConfig configures filesystem paths the embedding host allows the wasm\n// guest to access. Unconfigured paths are not allowed, so functions like\n// `path_open` result in unsupported errors (e.g. syscall.ENOSYS).\n//\n// # Guest Path\n//\n// `guestPath` is the name of the path the guest should use a filesystem for, or\n// empty for any files.\n//\n// All `guestPath` paths are normalized, specifically removing any leading or\n// trailing slashes. This means \"/\", \"./\" or \".\" all coerce to empty \"\".\n//\n// Multiple `guestPath` values can be configured, but the last longest match\n// wins. For example, if \"tmp\", then \"\" were added, a request to open\n// \"tmp/foo.txt\" use the filesystem associated with \"tmp\" even though a wider\n// path, \"\" (all files), was added later.\n//\n// A `guestPath` of \".\" coerces to the empty string \"\" because the current\n// directory is handled by the guest. In other words, the guest resolves ites\n// current directory prior to requesting files.\n//\n// More notes on `guestPath`\n//   - Working directories are typically tracked in wasm, though possible some\n//     relative paths are requested. For example, TinyGo may attempt to resolve\n//     a path \"../..\" in unit tests.\n//   - Zig uses the first path name it sees as the initial working directory of\n//     the process.\n//\n// # Scope\n//\n// Configuration here is module instance scoped. This means you can use the\n// same configuration for multiple calls to Runtime.InstantiateModule. Each\n// module will have a different file descriptor table. Any errors accessing\n// resources allowed here are deferred to instantiation time of each module.\n//\n// Any host resources present at the time of configuration, but deleted before\n// Runtime.InstantiateModule will trap/panic when the guest wasm initializes or\n// calls functions like `fd_read`.\n//\n// # Windows\n//\n// While wazero supports Windows as a platform, all known compilers use POSIX\n// conventions at runtime. For example, even when running on Windows, paths\n// used by wasm are separated by forward slash (/), not backslash (\\).\n//\n// # Notes\n//\n//   - This is an interface for decoupling, not third-party implementations.\n//     All implementations are in wazero.\n//   - FSConfig is immutable. Each WithXXX function returns a new instance\n//     including the corresponding change.\n//   - RATIONALE.md includes design background and relationship to WebAssembly\n//     System Interfaces (WASI).\ntype FSConfig interface {\n\t// WithDirMount assigns a directory at `dir` to any paths beginning at\n\t// `guestPath`.\n\t//\n\t// For example, `dirPath` as / (or c:\\ in Windows), makes the entire host\n\t// volume writeable to the path on the guest. The `guestPath` is always a\n\t// POSIX style path, slash (/) delimited, even if run on Windows.\n\t//\n\t// If the same `guestPath` was assigned before, this overrides its value,\n\t// retaining the original precedence. See the documentation of FSConfig for\n\t// more details on `guestPath`.\n\t//\n\t// # Isolation\n\t//\n\t// The guest will have full access to this directory including escaping it\n\t// via relative path lookups like \"../../\". Full access includes operations\n\t// such as creating or deleting files, limited to any host level access\n\t// controls.\n\t//\n\t// # os.DirFS\n\t//\n\t// This configuration optimizes for WASI compatibility which is sometimes\n\t// at odds with the behavior of os.DirFS. Hence, this will not behave\n\t// exactly the same as os.DirFS. See /RATIONALE.md for more.\n\tWithDirMount(dir, guestPath string) FSConfig\n\n\t// WithReadOnlyDirMount assigns a directory at `dir` to any paths\n\t// beginning at `guestPath`.\n\t//\n\t// This is the same as WithDirMount except only read operations are\n\t// permitted. However, escaping the directory via relative path lookups\n\t// like \"../../\" is still allowed.\n\tWithReadOnlyDirMount(dir, guestPath string) FSConfig\n\n\t// WithFSMount assigns a fs.FS file system for any paths beginning at\n\t// `guestPath`.\n\t//\n\t// If the same `guestPath` was assigned before, this overrides its value,\n\t// retaining the original precedence. See the documentation of FSConfig for\n\t// more details on `guestPath`.\n\t//\n\t// # Isolation\n\t//\n\t// fs.FS does not restrict the ability to overwrite returned files via\n\t// io.Writer. Moreover, os.DirFS documentation includes important notes\n\t// about isolation, which also applies to fs.Sub. As of Go 1.19, the\n\t// built-in file-systems are not jailed (chroot). See\n\t// https://github.com/golang/go/issues/42322\n\t//\n\t// # os.DirFS\n\t//\n\t// Due to limited control and functionality available in os.DirFS, we\n\t// advise using WithDirMount instead. There will be behavior differences\n\t// between os.DirFS and WithDirMount, as the latter biases towards what's\n\t// expected from WASI implementations.\n\t//\n\t// # Custom fs.FileInfo\n\t//\n\t// The underlying implementation supports data not usually in fs.FileInfo\n\t// when `info.Sys` returns *sys.Stat_t. For example, a custom fs.FS can use\n\t// this approach to generate or mask sys.Inode data. Such a filesystem\n\t// needs to decorate any functions that can return fs.FileInfo:\n\t//\n\t//   - `Stat` as defined on `fs.File` (always)\n\t//   - `Readdir` as defined on `os.File` (if defined)\n\t//\n\t// See sys.NewStat_t for examples.\n\tWithFSMount(fs fs.FS, guestPath string) FSConfig\n}\n\ntype fsConfig struct {\n\t// fs are the currently configured filesystems.\n\tfs []experimentalsys.FS\n\t// guestPaths are the user-supplied names of the filesystems, retained for\n\t// error messages and fmt.Stringer.\n\tguestPaths []string\n\t// guestPathToFS are the normalized paths to the currently configured\n\t// filesystems, used for de-duplicating.\n\tguestPathToFS map[string]int\n}\n\n// NewFSConfig returns a FSConfig that can be used for configuring module instantiation.\nfunc NewFSConfig() FSConfig {\n\treturn &fsConfig{guestPathToFS: map[string]int{}}\n}\n\n// clone makes a deep copy of this module config.\nfunc (c *fsConfig) clone() *fsConfig {\n\tret := *c // copy except slice and maps which share a ref\n\tret.fs = make([]experimentalsys.FS, 0, len(c.fs))\n\tret.fs = append(ret.fs, c.fs...)\n\tret.guestPaths = make([]string, 0, len(c.guestPaths))\n\tret.guestPaths = append(ret.guestPaths, c.guestPaths...)\n\tret.guestPathToFS = make(map[string]int, len(c.guestPathToFS))\n\tfor key, value := range c.guestPathToFS {\n\t\tret.guestPathToFS[key] = value\n\t}\n\treturn &ret\n}\n\n// WithDirMount implements FSConfig.WithDirMount\nfunc (c *fsConfig) WithDirMount(dir, guestPath string) FSConfig {\n\treturn c.WithSysFSMount(sysfs.DirFS(dir), guestPath)\n}\n\n// WithReadOnlyDirMount implements FSConfig.WithReadOnlyDirMount\nfunc (c *fsConfig) WithReadOnlyDirMount(dir, guestPath string) FSConfig {\n\treturn c.WithSysFSMount(&sysfs.ReadFS{FS: sysfs.DirFS(dir)}, guestPath)\n}\n\n// WithFSMount implements FSConfig.WithFSMount\nfunc (c *fsConfig) WithFSMount(fs fs.FS, guestPath string) FSConfig {\n\tvar adapted experimentalsys.FS\n\tif fs != nil {\n\t\tadapted = &sysfs.AdaptFS{FS: fs}\n\t}\n\treturn c.WithSysFSMount(adapted, guestPath)\n}\n\n// WithSysFSMount implements sysfs.FSConfig\nfunc (c *fsConfig) WithSysFSMount(fs experimentalsys.FS, guestPath string) FSConfig {\n\tif _, ok := fs.(experimentalsys.UnimplementedFS); ok {\n\t\treturn c // don't add fake paths.\n\t}\n\tcleaned := sys.StripPrefixesAndTrailingSlash(guestPath)\n\tret := c.clone()\n\tif i, ok := ret.guestPathToFS[cleaned]; ok {\n\t\tret.fs[i] = fs\n\t\tret.guestPaths[i] = guestPath\n\t} else if fs != nil {\n\t\tret.guestPathToFS[cleaned] = len(ret.fs)\n\t\tret.fs = append(ret.fs, fs)\n\t\tret.guestPaths = append(ret.guestPaths, guestPath)\n\t}\n\treturn ret\n}\n\n// preopens returns the possible nil index-correlated preopened filesystems\n// with guest paths.\nfunc (c *fsConfig) preopens() ([]experimentalsys.FS, []string) {\n\tpreopenCount := len(c.fs)\n\tif preopenCount == 0 {\n\t\treturn nil, nil\n\t}\n\tfs := make([]experimentalsys.FS, len(c.fs))\n\tcopy(fs, c.fs)\n\tguestPaths := make([]string, len(c.guestPaths))\n\tcopy(guestPaths, c.guestPaths)\n\treturn fs, guestPaths\n}\n"
        },
        {
          "name": "fsconfig_example_test.go",
          "type": "blob",
          "size": 0.5654296875,
          "content": "package wazero_test\n\nimport (\n\t\"embed\"\n\t\"io/fs\"\n\t\"log\"\n\n\t\"github.com/tetratelabs/wazero\"\n)\n\n//go:embed testdata/index.html\nvar testdataIndex embed.FS\n\nvar moduleConfig wazero.ModuleConfig\n\n// This example shows how to configure an embed.FS.\nfunc Example_fsConfig() {\n\t// Strip the embedded path testdata/\n\trooted, err := fs.Sub(testdataIndex, \"testdata\")\n\tif err != nil {\n\t\tlog.Panicln(err)\n\t}\n\n\tmoduleConfig = wazero.NewModuleConfig().\n\t\t// Make \"index.html\" accessible to the guest as \"/index.html\".\n\t\tWithFSConfig(wazero.NewFSConfig().WithFSMount(rooted, \"/\"))\n\n\t// Output:\n}\n"
        },
        {
          "name": "fsconfig_test.go",
          "type": "blob",
          "size": 2.3203125,
          "content": "package wazero\n\nimport (\n\t\"testing\"\n\n\t\"github.com/tetratelabs/wazero/experimental/sys\"\n\t\"github.com/tetratelabs/wazero/internal/sysfs\"\n\ttestfs \"github.com/tetratelabs/wazero/internal/testing/fs\"\n\t\"github.com/tetratelabs/wazero/internal/testing/require\"\n)\n\n// TestFSConfig only tests the cases that change the inputs to sysfs.ValidatePreopens.\nfunc TestFSConfig(t *testing.T) {\n\tbase := NewFSConfig()\n\n\ttestFS := testfs.FS{}\n\ttestFS2 := testfs.FS{\"/\": &testfs.File{}}\n\n\ttests := []struct {\n\t\tname               string\n\t\tinput              FSConfig\n\t\texpectedFS         []sys.FS\n\t\texpectedGuestPaths []string\n\t}{\n\t\t{\n\t\t\tname:  \"empty\",\n\t\t\tinput: base,\n\t\t},\n\t\t{\n\t\t\tname:               \"WithFSMount\",\n\t\t\tinput:              base.WithFSMount(testFS, \"/\"),\n\t\t\texpectedFS:         []sys.FS{&sysfs.AdaptFS{FS: testFS}},\n\t\t\texpectedGuestPaths: []string{\"/\"},\n\t\t},\n\t\t{\n\t\t\tname:               \"WithFSMount overwrites\",\n\t\t\tinput:              base.WithFSMount(testFS, \"/\").WithFSMount(testFS2, \"/\"),\n\t\t\texpectedFS:         []sys.FS{&sysfs.AdaptFS{FS: testFS2}},\n\t\t\texpectedGuestPaths: []string{\"/\"},\n\t\t},\n\t\t{\n\t\t\tname:  \"WithFsMount nil\",\n\t\t\tinput: base.WithFSMount(nil, \"/\"),\n\t\t},\n\t\t{\n\t\t\tname:               \"WithDirMount overwrites\",\n\t\t\tinput:              base.WithFSMount(testFS, \"/\").WithDirMount(\".\", \"/\"),\n\t\t\texpectedFS:         []sys.FS{sysfs.DirFS(\".\")},\n\t\t\texpectedGuestPaths: []string{\"/\"},\n\t\t},\n\t\t{\n\t\t\tname:               \"multiple\",\n\t\t\tinput:              base.WithReadOnlyDirMount(\".\", \"/\").WithDirMount(\"/tmp\", \"/tmp\"),\n\t\t\texpectedFS:         []sys.FS{&sysfs.ReadFS{FS: sysfs.DirFS(\".\")}, sysfs.DirFS(\"/tmp\")},\n\t\t\texpectedGuestPaths: []string{\"/\", \"/tmp\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttc := tt\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tfs, guestPaths := tc.input.(*fsConfig).preopens()\n\t\t\trequire.Equal(t, tc.expectedFS, fs)\n\t\t\trequire.Equal(t, tc.expectedGuestPaths, guestPaths)\n\t\t})\n\t}\n}\n\nfunc TestFSConfig_clone(t *testing.T) {\n\tfc := NewFSConfig().(*fsConfig)\n\tfc.guestPathToFS[\"/\"] = 0\n\n\tcloned := fc.clone()\n\n\t// Make post-clone changes\n\tfc.guestPaths = []string{\"/\"}\n\tfc.guestPathToFS[\"/\"] = 1\n\n\t// Ensure the guestPathToFS map is not shared\n\trequire.Equal(t, map[string]int{\"/\": 1}, fc.guestPathToFS)\n\trequire.Equal(t, map[string]int{\"/\": 0}, cloned.guestPathToFS)\n\n\t// Ensure the guestPaths slice is not shared\n\trequire.Zero(t, len(cloned.guestPaths))\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.2861328125,
          "content": "module github.com/tetratelabs/wazero\n\n// Floor Go version of wazero (current - 2)\ngo 1.21\n\n// All the beta tags are retracted and replaced with \"pre\" to prevent users\n// from accidentally upgrading into the broken beta 1.\nretract (\n\tv1.0.0-beta1\n\tv1.0.0-beta.3\n\tv1.0.0-beta.2\n\tv1.0.0-beta.1\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "imports",
          "type": "tree",
          "content": null
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "netlify.toml",
          "type": "blob",
          "size": 0.390625,
          "content": "[build]\n  base = \"site\"\n  publish = \"public\"\n\n[build.environment]\n  HUGO_VERSION = \"0.115.2\"\n\n[context.production]\n  command = \"git submodule update --init && hugo --gc --minify\"\n\n[context.deploy-preview]\n  command = \"git submodule update --init && hugo --gc --minify -b $DEPLOY_PRIME_URL\"\n\n[context.branch-deploy]\n  command = \"git submodule update --init && hugo --gc --minify -b $DEPLOY_PRIME_URL\"\n"
        },
        {
          "name": "packaging",
          "type": "tree",
          "content": null
        },
        {
          "name": "runtime.go",
          "type": "blob",
          "size": 13.0419921875,
          "content": "package wazero\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync/atomic\"\n\n\t\"github.com/tetratelabs/wazero/api\"\n\texperimentalapi \"github.com/tetratelabs/wazero/experimental\"\n\t\"github.com/tetratelabs/wazero/internal/expctxkeys\"\n\tinternalsock \"github.com/tetratelabs/wazero/internal/sock\"\n\tinternalsys \"github.com/tetratelabs/wazero/internal/sys\"\n\t\"github.com/tetratelabs/wazero/internal/wasm\"\n\tbinaryformat \"github.com/tetratelabs/wazero/internal/wasm/binary\"\n\t\"github.com/tetratelabs/wazero/sys\"\n)\n\n// Runtime allows embedding of WebAssembly modules.\n//\n// The below is an example of basic initialization:\n//\n//\tctx := context.Background()\n//\tr := wazero.NewRuntime(ctx)\n//\tdefer r.Close(ctx) // This closes everything this Runtime created.\n//\n//\tmod, _ := r.Instantiate(ctx, wasm)\n//\n// # Notes\n//\n//   - This is an interface for decoupling, not third-party implementations.\n//     All implementations are in wazero.\n//   - Closing this closes any CompiledModule or Module it instantiated.\ntype Runtime interface {\n\t// Instantiate instantiates a module from the WebAssembly binary (%.wasm)\n\t// with default configuration, which notably calls the \"_start\" function,\n\t// if it exists.\n\t//\n\t// Here's an example:\n\t//\tctx := context.Background()\n\t//\tr := wazero.NewRuntime(ctx)\n\t//\tdefer r.Close(ctx) // This closes everything this Runtime created.\n\t//\n\t//\tmod, _ := r.Instantiate(ctx, wasm)\n\t//\n\t// # Notes\n\t//\n\t//   - See notes on InstantiateModule for error scenarios.\n\t//   - See InstantiateWithConfig for configuration overrides.\n\tInstantiate(ctx context.Context, source []byte) (api.Module, error)\n\n\t// InstantiateWithConfig instantiates a module from the WebAssembly binary\n\t// (%.wasm) or errs for reasons including exit or validation.\n\t//\n\t// Here's an example:\n\t//\tctx := context.Background()\n\t//\tr := wazero.NewRuntime(ctx)\n\t//\tdefer r.Close(ctx) // This closes everything this Runtime created.\n\t//\n\t//\tmod, _ := r.InstantiateWithConfig(ctx, wasm,\n\t//\t\twazero.NewModuleConfig().WithName(\"rotate\"))\n\t//\n\t// # Notes\n\t//\n\t//   - See notes on InstantiateModule for error scenarios.\n\t//   - If you aren't overriding defaults, use Instantiate.\n\t//   - This is a convenience utility that chains CompileModule with\n\t//     InstantiateModule. To instantiate the same source multiple times,\n\t//     use CompileModule as InstantiateModule avoids redundant decoding\n\t//     and/or compilation.\n\tInstantiateWithConfig(ctx context.Context, source []byte, config ModuleConfig) (api.Module, error)\n\n\t// NewHostModuleBuilder lets you create modules out of functions defined in Go.\n\t//\n\t// Below defines and instantiates a module named \"env\" with one function:\n\t//\n\t//\tctx := context.Background()\n\t//\thello := func() {\n\t//\t\tfmt.Fprintln(stdout, \"hello!\")\n\t//\t}\n\t//\t_, err := r.NewHostModuleBuilder(\"env\").\n\t//\t\tNewFunctionBuilder().WithFunc(hello).Export(\"hello\").\n\t//\t\tInstantiate(ctx, r)\n\t//\n\t// Note: empty `moduleName` is not allowed.\n\tNewHostModuleBuilder(moduleName string) HostModuleBuilder\n\n\t// CompileModule decodes the WebAssembly binary (%.wasm) or errs if invalid.\n\t// Any pre-compilation done after decoding wasm is dependent on RuntimeConfig.\n\t//\n\t// There are two main reasons to use CompileModule instead of Instantiate:\n\t//   - Improve performance when the same module is instantiated multiple times under different names\n\t//   - Reduce the amount of errors that can occur during InstantiateModule.\n\t//\n\t// # Notes\n\t//\n\t//   - The resulting module name defaults to what was binary from the custom name section.\n\t//   - Any pre-compilation done after decoding the source is dependent on RuntimeConfig.\n\t//\n\t// See https://www.w3.org/TR/2019/REC-wasm-core-1-20191205/#name-section%E2%91%A0\n\tCompileModule(ctx context.Context, binary []byte) (CompiledModule, error)\n\n\t// InstantiateModule instantiates the module or errs for reasons including\n\t// exit or validation.\n\t//\n\t// Here's an example:\n\t//\tmod, _ := n.InstantiateModule(ctx, compiled, wazero.NewModuleConfig().\n\t//\t\tWithName(\"prod\"))\n\t//\n\t// # Errors\n\t//\n\t// While CompiledModule is pre-validated, there are a few situations which\n\t// can cause an error:\n\t//   - The module name is already in use.\n\t//   - The module has a table element initializer that resolves to an index\n\t//     outside the Table minimum size.\n\t//   - The module has a start function, and it failed to execute.\n\t//   - The module was compiled to WASI and exited with a non-zero exit\n\t//     code, you'll receive a sys.ExitError.\n\t//   - RuntimeConfig.WithCloseOnContextDone was enabled and a context\n\t//     cancellation or deadline triggered before a start function returned.\n\tInstantiateModule(ctx context.Context, compiled CompiledModule, config ModuleConfig) (api.Module, error)\n\n\t// CloseWithExitCode closes all the modules that have been initialized in this Runtime with the provided exit code.\n\t// An error is returned if any module returns an error when closed.\n\t//\n\t// Here's an example:\n\t//\tctx := context.Background()\n\t//\tr := wazero.NewRuntime(ctx)\n\t//\tdefer r.CloseWithExitCode(ctx, 2) // This closes everything this Runtime created.\n\t//\n\t//\t// Everything below here can be closed, but will anyway due to above.\n\t//\t_, _ = wasi_snapshot_preview1.InstantiateSnapshotPreview1(ctx, r)\n\t//\tmod, _ := r.Instantiate(ctx, wasm)\n\tCloseWithExitCode(ctx context.Context, exitCode uint32) error\n\n\t// Module returns an instantiated module in this runtime or nil if there aren't any.\n\tModule(moduleName string) api.Module\n\n\t// Closer closes all compiled code by delegating to CloseWithExitCode with an exit code of zero.\n\tapi.Closer\n}\n\n// NewRuntime returns a runtime with a configuration assigned by NewRuntimeConfig.\nfunc NewRuntime(ctx context.Context) Runtime {\n\treturn NewRuntimeWithConfig(ctx, NewRuntimeConfig())\n}\n\n// NewRuntimeWithConfig returns a runtime with the given configuration.\nfunc NewRuntimeWithConfig(ctx context.Context, rConfig RuntimeConfig) Runtime {\n\tconfig := rConfig.(*runtimeConfig)\n\tvar engine wasm.Engine\n\tvar cacheImpl *cache\n\tif c := config.cache; c != nil {\n\t\t// If the Cache is configured, we share the engine.\n\t\tcacheImpl = c.(*cache)\n\t\tengine = cacheImpl.initEngine(config.engineKind, config.newEngine, ctx, config.enabledFeatures)\n\t} else {\n\t\t// Otherwise, we create a new engine.\n\t\tengine = config.newEngine(ctx, config.enabledFeatures, nil)\n\t}\n\tstore := wasm.NewStore(config.enabledFeatures, engine)\n\treturn &runtime{\n\t\tcache:                 cacheImpl,\n\t\tstore:                 store,\n\t\tenabledFeatures:       config.enabledFeatures,\n\t\tmemoryLimitPages:      config.memoryLimitPages,\n\t\tmemoryCapacityFromMax: config.memoryCapacityFromMax,\n\t\tdwarfDisabled:         config.dwarfDisabled,\n\t\tstoreCustomSections:   config.storeCustomSections,\n\t\tensureTermination:     config.ensureTermination,\n\t}\n}\n\n// runtime allows decoupling of public interfaces from internal representation.\ntype runtime struct {\n\tstore                 *wasm.Store\n\tcache                 *cache\n\tenabledFeatures       api.CoreFeatures\n\tmemoryLimitPages      uint32\n\tmemoryCapacityFromMax bool\n\tdwarfDisabled         bool\n\tstoreCustomSections   bool\n\n\t// closed is the pointer used both to guard moduleEngine.CloseWithExitCode and to store the exit code.\n\t//\n\t// The update value is 1 + exitCode << 32. This ensures an exit code of zero isn't mistaken for never closed.\n\t//\n\t// Note: Exclusively reading and updating this with atomics guarantees cross-goroutine observations.\n\t// See /RATIONALE.md\n\tclosed atomic.Uint64\n\n\tensureTermination bool\n}\n\n// Module implements Runtime.Module.\nfunc (r *runtime) Module(moduleName string) api.Module {\n\tif len(moduleName) == 0 {\n\t\treturn nil\n\t}\n\tm := r.store.Module(moduleName)\n\tif m == nil {\n\t\treturn nil\n\t} else if m.Source.IsHostModule {\n\t\treturn hostModuleInstance{m}\n\t}\n\treturn m\n}\n\n// CompileModule implements Runtime.CompileModule\nfunc (r *runtime) CompileModule(ctx context.Context, binary []byte) (CompiledModule, error) {\n\tif err := r.failIfClosed(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tinternal, err := binaryformat.DecodeModule(binary, r.enabledFeatures,\n\t\tr.memoryLimitPages, r.memoryCapacityFromMax, !r.dwarfDisabled, r.storeCustomSections)\n\tif err != nil {\n\t\treturn nil, err\n\t} else if err = internal.Validate(r.enabledFeatures); err != nil {\n\t\t// TODO: decoders should validate before returning, as that allows\n\t\t// them to err with the correct position in the wasm binary.\n\t\treturn nil, err\n\t}\n\n\t// Now that the module is validated, cache the memory definitions.\n\t// TODO: lazy initialization of memory definition.\n\tinternal.BuildMemoryDefinitions()\n\n\tc := &compiledModule{module: internal, compiledEngine: r.store.Engine}\n\n\t// typeIDs are static and compile-time known.\n\ttypeIDs, err := r.store.GetFunctionTypeIDs(internal.TypeSection)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.typeIDs = typeIDs\n\n\tlisteners, err := buildFunctionListeners(ctx, internal)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tinternal.AssignModuleID(binary, listeners, r.ensureTermination)\n\tif err = r.store.Engine.CompileModule(ctx, internal, listeners, r.ensureTermination); err != nil {\n\t\treturn nil, err\n\t}\n\treturn c, nil\n}\n\nfunc buildFunctionListeners(ctx context.Context, internal *wasm.Module) ([]experimentalapi.FunctionListener, error) {\n\t// Test to see if internal code are using an experimental feature.\n\tfnlf := ctx.Value(expctxkeys.FunctionListenerFactoryKey{})\n\tif fnlf == nil {\n\t\treturn nil, nil\n\t}\n\tfactory := fnlf.(experimentalapi.FunctionListenerFactory)\n\timportCount := internal.ImportFunctionCount\n\tlisteners := make([]experimentalapi.FunctionListener, len(internal.FunctionSection))\n\tfor i := 0; i < len(listeners); i++ {\n\t\tlisteners[i] = factory.NewFunctionListener(internal.FunctionDefinition(uint32(i) + importCount))\n\t}\n\treturn listeners, nil\n}\n\n// failIfClosed returns an error if CloseWithExitCode was called implicitly (by Close) or explicitly.\nfunc (r *runtime) failIfClosed() error {\n\tif closed := r.closed.Load(); closed != 0 {\n\t\treturn fmt.Errorf(\"runtime closed with exit_code(%d)\", uint32(closed>>32))\n\t}\n\treturn nil\n}\n\n// Instantiate implements Runtime.Instantiate\nfunc (r *runtime) Instantiate(ctx context.Context, binary []byte) (api.Module, error) {\n\treturn r.InstantiateWithConfig(ctx, binary, NewModuleConfig())\n}\n\n// InstantiateWithConfig implements Runtime.InstantiateWithConfig\nfunc (r *runtime) InstantiateWithConfig(ctx context.Context, binary []byte, config ModuleConfig) (api.Module, error) {\n\tif compiled, err := r.CompileModule(ctx, binary); err != nil {\n\t\treturn nil, err\n\t} else {\n\t\tcompiled.(*compiledModule).closeWithModule = true\n\t\treturn r.InstantiateModule(ctx, compiled, config)\n\t}\n}\n\n// InstantiateModule implements Runtime.InstantiateModule.\nfunc (r *runtime) InstantiateModule(\n\tctx context.Context,\n\tcompiled CompiledModule,\n\tmConfig ModuleConfig,\n) (mod api.Module, err error) {\n\tif err = r.failIfClosed(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tcode := compiled.(*compiledModule)\n\tconfig := mConfig.(*moduleConfig)\n\n\t// Only add guest module configuration to guests.\n\tif !code.module.IsHostModule {\n\t\tif sockConfig, ok := ctx.Value(internalsock.ConfigKey{}).(*internalsock.Config); ok {\n\t\t\tconfig.sockConfig = sockConfig\n\t\t}\n\t}\n\n\tvar sysCtx *internalsys.Context\n\tif sysCtx, err = config.toSysContext(); err != nil {\n\t\treturn\n\t}\n\n\tname := config.name\n\tif !config.nameSet && code.module.NameSection != nil && code.module.NameSection.ModuleName != \"\" {\n\t\tname = code.module.NameSection.ModuleName\n\t}\n\n\t// Instantiate the module.\n\tmod, err = r.store.Instantiate(ctx, code.module, name, sysCtx, code.typeIDs)\n\tif err != nil {\n\t\t// If there was an error, don't leak the compiled module.\n\t\tif code.closeWithModule {\n\t\t\t_ = code.Close(ctx) // don't overwrite the error\n\t\t}\n\t\treturn\n\t}\n\n\tif closeNotifier, ok := ctx.Value(expctxkeys.CloseNotifierKey{}).(experimentalapi.CloseNotifier); ok {\n\t\tmod.(*wasm.ModuleInstance).CloseNotifier = closeNotifier\n\t}\n\n\t// Attach the code closer so that anything afterward closes the compiled\n\t// code when closing the module.\n\tif code.closeWithModule {\n\t\tmod.(*wasm.ModuleInstance).CodeCloser = code\n\t}\n\n\t// Now, invoke any start functions, failing at first error.\n\tfor _, fn := range config.startFunctions {\n\t\tstart := mod.ExportedFunction(fn)\n\t\tif start == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif _, err = start.Call(ctx); err != nil {\n\t\t\t_ = mod.Close(ctx) // Don't leak the module on error.\n\n\t\t\tif se, ok := err.(*sys.ExitError); ok {\n\t\t\t\tif se.ExitCode() == 0 { // Don't err on success.\n\t\t\t\t\terr = nil\n\t\t\t\t}\n\t\t\t\treturn // Don't wrap an exit error\n\t\t\t}\n\t\t\terr = fmt.Errorf(\"module[%s] function[%s] failed: %w\", name, fn, err)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\n// Close implements api.Closer embedded in Runtime.\nfunc (r *runtime) Close(ctx context.Context) error {\n\treturn r.CloseWithExitCode(ctx, 0)\n}\n\n// CloseWithExitCode implements Runtime.CloseWithExitCode\n//\n// Note: it also marks the internal `closed` field\nfunc (r *runtime) CloseWithExitCode(ctx context.Context, exitCode uint32) error {\n\tclosed := uint64(1) + uint64(exitCode)<<32 // Store exitCode as high-order bits.\n\tif !r.closed.CompareAndSwap(0, closed) {\n\t\treturn nil\n\t}\n\terr := r.store.CloseWithExitCode(ctx, exitCode)\n\tif r.cache == nil {\n\t\t// Close the engine if the cache is not configured, which means that this engine is scoped in this runtime.\n\t\tif errCloseEngine := r.store.Engine.Close(); errCloseEngine != nil {\n\t\t\treturn errCloseEngine\n\t\t}\n\t}\n\treturn err\n}\n"
        },
        {
          "name": "runtime_test.go",
          "type": "blob",
          "size": 23.619140625,
          "content": "package wazero\n\nimport (\n\t\"context\"\n\t_ \"embed\"\n\t\"errors\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/tetratelabs/wazero/api\"\n\t\"github.com/tetratelabs/wazero/experimental\"\n\t\"github.com/tetratelabs/wazero/internal/filecache\"\n\t\"github.com/tetratelabs/wazero/internal/leb128\"\n\t\"github.com/tetratelabs/wazero/internal/platform\"\n\t\"github.com/tetratelabs/wazero/internal/testing/binaryencoding\"\n\t\"github.com/tetratelabs/wazero/internal/testing/require\"\n\t\"github.com/tetratelabs/wazero/internal/wasm\"\n\t\"github.com/tetratelabs/wazero/sys\"\n)\n\ntype arbitrary struct{}\n\nvar (\n\tbinaryNamedZero = binaryencoding.EncodeModule(&wasm.Module{NameSection: &wasm.NameSection{ModuleName: \"0\"}})\n\t// testCtx is an arbitrary, non-default context. Non-nil also prevents linter errors.\n\ttestCtx = context.WithValue(context.Background(), arbitrary{}, \"arbitrary\")\n)\n\nvar _ context.Context = &HostContext{}\n\n// HostContext contain the content will be used in host function call\ntype HostContext struct {\n\tContent string\n}\n\nfunc (h *HostContext) Deadline() (deadline time.Time, ok bool) { return }\n\nfunc (h *HostContext) Done() <-chan struct{} { return nil }\n\nfunc (h *HostContext) Err() error { return nil }\n\nfunc (h *HostContext) Value(key interface{}) interface{} { return nil }\n\nfunc TestRuntime_CompileModule(t *testing.T) {\n\ttests := []struct {\n\t\tname          string\n\t\truntime       Runtime\n\t\twasm          *wasm.Module\n\t\tmoduleBuilder HostModuleBuilder\n\t\texpected      func(CompiledModule)\n\t}{\n\t\t{\n\t\t\tname: \"no name section\",\n\t\t\twasm: &wasm.Module{},\n\t\t},\n\t\t{\n\t\t\tname: \"empty NameSection.ModuleName\",\n\t\t\twasm: &wasm.Module{NameSection: &wasm.NameSection{}},\n\t\t},\n\t\t{\n\t\t\tname: \"NameSection.ModuleName\",\n\t\t\twasm: &wasm.Module{NameSection: &wasm.NameSection{ModuleName: \"test\"}},\n\t\t\texpected: func(compiled CompiledModule) {\n\t\t\t\trequire.Equal(t, \"test\", compiled.Name())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"FunctionSection, but not exported\",\n\t\t\twasm: &wasm.Module{\n\t\t\t\tTypeSection:     []wasm.FunctionType{{Params: []api.ValueType{api.ValueTypeI32}}},\n\t\t\t\tFunctionSection: []wasm.Index{0},\n\t\t\t\tCodeSection:     []wasm.Code{{Body: []byte{wasm.OpcodeEnd}}},\n\t\t\t},\n\t\t\texpected: func(compiled CompiledModule) {\n\t\t\t\trequire.Nil(t, compiled.ImportedFunctions())\n\t\t\t\trequire.Zero(t, len(compiled.ExportedFunctions()))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"FunctionSection exported\",\n\t\t\twasm: &wasm.Module{\n\t\t\t\tTypeSection:     []wasm.FunctionType{{Params: []api.ValueType{api.ValueTypeI32}}},\n\t\t\t\tFunctionSection: []wasm.Index{0},\n\t\t\t\tCodeSection:     []wasm.Code{{Body: []byte{wasm.OpcodeEnd}}},\n\t\t\t\tExportSection: []wasm.Export{{\n\t\t\t\t\tType:  wasm.ExternTypeFunc,\n\t\t\t\t\tName:  \"function\",\n\t\t\t\t\tIndex: 0,\n\t\t\t\t}},\n\t\t\t},\n\t\t\texpected: func(compiled CompiledModule) {\n\t\t\t\trequire.Nil(t, compiled.ImportedFunctions())\n\t\t\t\tf := compiled.ExportedFunctions()[\"function\"]\n\t\t\t\trequire.Equal(t, []api.ValueType{api.ValueTypeI32}, f.ParamTypes())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"MemorySection, but not exported\",\n\t\t\twasm: &wasm.Module{\n\t\t\t\tMemorySection: &wasm.Memory{Min: 2, Max: 3, IsMaxEncoded: true},\n\t\t\t},\n\t\t\texpected: func(compiled CompiledModule) {\n\t\t\t\trequire.Nil(t, compiled.ImportedMemories())\n\t\t\t\trequire.Zero(t, len(compiled.ExportedMemories()))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"MemorySection exported\",\n\t\t\twasm: &wasm.Module{\n\t\t\t\tMemorySection: &wasm.Memory{Min: 2, Max: 3, IsMaxEncoded: true},\n\t\t\t\tExportSection: []wasm.Export{{\n\t\t\t\t\tType:  wasm.ExternTypeMemory,\n\t\t\t\t\tName:  \"memory\",\n\t\t\t\t\tIndex: 0,\n\t\t\t\t}},\n\t\t\t},\n\t\t\texpected: func(compiled CompiledModule) {\n\t\t\t\trequire.Nil(t, compiled.ImportedMemories())\n\t\t\t\tmem := compiled.ExportedMemories()[\"memory\"]\n\t\t\t\trequire.Equal(t, uint32(2), mem.Min())\n\t\t\t\tmax, ok := mem.Max()\n\t\t\t\trequire.Equal(t, uint32(3), max)\n\t\t\t\trequire.True(t, ok)\n\t\t\t},\n\t\t},\n\t}\n\n\t_r := NewRuntime(testCtx)\n\tdefer _r.Close(testCtx)\n\n\tr := _r.(*runtime)\n\n\tfor _, tt := range tests {\n\t\ttc := tt\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tbin := binaryencoding.EncodeModule(tc.wasm)\n\n\t\t\tm, err := r.CompileModule(testCtx, bin)\n\t\t\trequire.NoError(t, err)\n\t\t\tif tc.expected == nil {\n\t\t\t\ttc.expected = func(CompiledModule) {}\n\t\t\t}\n\t\t\ttc.expected(m)\n\t\t\trequire.Equal(t, r.store.Engine, m.(*compiledModule).compiledEngine)\n\n\t\t\t// TypeIDs must be assigned to compiledModule.\n\t\t\texpTypeIDs, err := r.store.GetFunctionTypeIDs(tc.wasm.TypeSection)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, expTypeIDs, m.(*compiledModule).typeIDs)\n\t\t})\n\t}\n}\n\nfunc TestRuntime_CompileModule_Errors(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\twasm        []byte\n\t\texpectedErr string\n\t}{\n\t\t{\n\t\t\tname:        \"nil\",\n\t\t\texpectedErr: \"invalid magic number\",\n\t\t},\n\t\t{\n\t\t\tname:        \"invalid binary\",\n\t\t\twasm:        append(binaryencoding.Magic, []byte(\"yolo\")...),\n\t\t\texpectedErr: \"invalid version header\",\n\t\t},\n\t\t{\n\t\t\tname:        \"memory has too many pages\",\n\t\t\twasm:        binaryencoding.EncodeModule(&wasm.Module{MemorySection: &wasm.Memory{Min: 2, Cap: 2, Max: 70000, IsMaxEncoded: true}}),\n\t\t\texpectedErr: \"section memory: max 70000 pages (4 Gi) over limit of 65536 pages (4 Gi)\",\n\t\t},\n\t}\n\n\tr := NewRuntime(testCtx)\n\tdefer r.Close(testCtx)\n\n\tfor _, tt := range tests {\n\t\ttc := tt\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t_, err := r.CompileModule(testCtx, tc.wasm)\n\t\t\trequire.EqualError(t, err, tc.expectedErr)\n\t\t})\n\t}\n}\n\n// TestModule_Memory only covers a couple cases to avoid duplication of internal/wasm/runtime_test.go\nfunc TestModule_Memory(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\twasm        []byte\n\t\texpected    bool\n\t\texpectedLen uint32\n\t}{\n\t\t{\n\t\t\tname: \"no memory\",\n\t\t\twasm: binaryencoding.EncodeModule(&wasm.Module{}),\n\t\t},\n\t\t{\n\t\t\tname: \"memory exported, one page\",\n\t\t\twasm: binaryencoding.EncodeModule(&wasm.Module{\n\t\t\t\tMemorySection: &wasm.Memory{Min: 1},\n\t\t\t\tExportSection: []wasm.Export{{Name: \"memory\", Type: api.ExternTypeMemory}},\n\t\t\t}),\n\t\t\texpected:    true,\n\t\t\texpectedLen: 65536,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttc := tt\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tr := NewRuntime(testCtx)\n\t\t\tdefer r.Close(testCtx)\n\n\t\t\t// Instantiate the module and get the export of the above memory\n\t\t\tmodule, err := r.Instantiate(testCtx, tc.wasm)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tmem := module.ExportedMemory(\"memory\")\n\t\t\tif tc.expected {\n\t\t\t\trequire.Equal(t, tc.expectedLen, mem.Size())\n\t\t\t\tdefs := module.ExportedMemoryDefinitions()\n\t\t\t\trequire.Equal(t, 1, len(defs))\n\t\t\t\tdef := defs[\"memory\"]\n\t\t\t\trequire.Equal(t, tc.expectedLen>>16, def.Min())\n\t\t\t} else {\n\t\t\t\trequire.Nil(t, mem)\n\t\t\t\trequire.Zero(t, len(module.ExportedMemoryDefinitions()))\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestModule_Global only covers a couple cases to avoid duplication of internal/wasm/global_test.go\nfunc TestModule_Global(t *testing.T) {\n\tglobalVal := int64(100) // intentionally a value that differs in signed vs unsigned encoding\n\n\ttests := []struct {\n\t\tname                      string\n\t\tmodule                    *wasm.Module // module as wat doesn't yet support globals\n\t\texpected, expectedMutable bool\n\t}{\n\t\t{\n\t\t\tname:   \"no global\",\n\t\t\tmodule: &wasm.Module{},\n\t\t},\n\t\t{\n\t\t\tname: \"global not exported\",\n\t\t\tmodule: &wasm.Module{\n\t\t\t\tGlobalSection: []wasm.Global{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: wasm.GlobalType{ValType: wasm.ValueTypeI64, Mutable: true},\n\t\t\t\t\t\tInit: wasm.ConstantExpression{Opcode: wasm.OpcodeI64Const, Data: leb128.EncodeInt64(globalVal)},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"global exported\",\n\t\t\tmodule: &wasm.Module{\n\t\t\t\tGlobalSection: []wasm.Global{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: wasm.GlobalType{ValType: wasm.ValueTypeI64},\n\t\t\t\t\t\tInit: wasm.ConstantExpression{Opcode: wasm.OpcodeI64Const, Data: leb128.EncodeInt64(globalVal)},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tExports: map[string]*wasm.Export{\n\t\t\t\t\t\"global\": {Type: wasm.ExternTypeGlobal, Name: \"global\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"global exported and mutable\",\n\t\t\tmodule: &wasm.Module{\n\t\t\t\tGlobalSection: []wasm.Global{\n\t\t\t\t\t{\n\t\t\t\t\t\tType: wasm.GlobalType{ValType: wasm.ValueTypeI64, Mutable: true},\n\t\t\t\t\t\tInit: wasm.ConstantExpression{Opcode: wasm.OpcodeI64Const, Data: leb128.EncodeInt64(globalVal)},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tExports: map[string]*wasm.Export{\n\t\t\t\t\t\"global\": {Type: wasm.ExternTypeGlobal, Name: \"global\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected:        true,\n\t\t\texpectedMutable: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttc := tt\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tr := NewRuntime(testCtx).(*runtime)\n\t\t\tdefer r.Close(testCtx)\n\n\t\t\tcode := &compiledModule{module: tc.module}\n\n\t\t\terr := r.store.Engine.CompileModule(testCtx, code.module, nil, false)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Instantiate the module and get the export of the above global\n\t\t\tmodule, err := r.InstantiateModule(testCtx, code, NewModuleConfig())\n\t\t\trequire.NoError(t, err)\n\n\t\t\tglobal := module.ExportedGlobal(\"global\")\n\t\t\tif !tc.expected {\n\t\t\t\trequire.Nil(t, global)\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.Equal(t, uint64(globalVal), global.Get())\n\n\t\t\tmutable, ok := global.(api.MutableGlobal)\n\t\t\trequire.Equal(t, tc.expectedMutable, ok)\n\t\t\tif ok {\n\t\t\t\tmutable.Set(2)\n\t\t\t\trequire.Equal(t, uint64(2), global.Get())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRuntime_InstantiateModule_UsesContext(t *testing.T) {\n\tr := NewRuntime(testCtx)\n\tdefer r.Close(testCtx)\n\n\t// Define a function that will be set as the start function\n\tvar calledStart bool\n\tstart := func(ctx context.Context) {\n\t\tcalledStart = true\n\t\trequire.Equal(t, testCtx, ctx)\n\t}\n\n\t_, err := r.NewHostModuleBuilder(\"env\").\n\t\tNewFunctionBuilder().WithFunc(start).Export(\"start\").\n\t\tInstantiate(testCtx)\n\trequire.NoError(t, err)\n\n\tone := uint32(1)\n\tbinary := binaryencoding.EncodeModule(&wasm.Module{\n\t\tTypeSection:     []wasm.FunctionType{{}},\n\t\tImportSection:   []wasm.Import{{Module: \"env\", Name: \"start\", Type: wasm.ExternTypeFunc, DescFunc: 0}},\n\t\tFunctionSection: []wasm.Index{0},\n\t\tCodeSection: []wasm.Code{\n\t\t\t{Body: []byte{wasm.OpcodeCall, 0, wasm.OpcodeEnd}}, // Call the imported env.start.\n\t\t},\n\t\tStartSection: &one,\n\t})\n\n\tcode, err := r.CompileModule(testCtx, binary)\n\trequire.NoError(t, err)\n\n\t// Instantiate the module, which calls the start function. This will fail if the context wasn't as intended.\n\tmod, err := r.InstantiateModule(testCtx, code, NewModuleConfig())\n\trequire.NoError(t, err)\n\n\trequire.True(t, calledStart)\n\n\t// Closing the module shouldn't remove the compiler cache\n\trequire.NoError(t, mod.Close(testCtx))\n\trequire.Equal(t, uint32(2), r.(*runtime).store.Engine.CompiledModuleCount())\n}\n\n// TestRuntime_Instantiate_DoesntEnforce_Start ensures wapc-go work when modules import WASI, but don't\n// export \"_start\".\nfunc TestRuntime_Instantiate_DoesntEnforce_Start(t *testing.T) {\n\tr := NewRuntime(testCtx)\n\tdefer r.Close(testCtx)\n\n\tbinary := binaryencoding.EncodeModule(&wasm.Module{\n\t\tMemorySection: &wasm.Memory{Min: 1},\n\t\tExportSection: []wasm.Export{{Name: \"memory\", Type: wasm.ExternTypeMemory, Index: 0}},\n\t})\n\n\tmod, err := r.Instantiate(testCtx, binary)\n\trequire.NoError(t, err)\n\trequire.NoError(t, mod.Close(testCtx))\n}\n\nfunc TestRuntime_Instantiate_ErrorOnStart(t *testing.T) {\n\ttests := []struct {\n\t\tname, wasm string\n\t}{\n\t\t{\n\t\t\tname: \"_start function\",\n\t\t\twasm: `(module\n\t(import \"\" \"start\" (func $start))\n\t(export \"_start\" (func $start))\n)`,\n\t\t},\n\t\t{\n\t\t\tname: \".start function\",\n\t\t\twasm: `(module\n\t(import \"\" \"start\" (func $start))\n\t(start $start)\n)`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttc := tt\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tr := NewRuntime(testCtx)\n\t\t\tdefer r.Close(testCtx)\n\n\t\t\tstart := func() {\n\t\t\t\tpanic(errors.New(\"ice cream\"))\n\t\t\t}\n\n\t\t\thost, err := r.NewHostModuleBuilder(\"host\").\n\t\t\t\tNewFunctionBuilder().WithFunc(start).Export(\"start\").\n\t\t\t\tInstantiate(testCtx)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Start the module as a WASI command. We expect it to fail.\n\t\t\t_, err = r.Instantiate(testCtx, []byte(tc.wasm))\n\t\t\trequire.Error(t, err)\n\n\t\t\t// Close the imported module, which should remove its compiler cache.\n\t\t\trequire.NoError(t, host.Close(testCtx))\n\n\t\t\t// The compiler cache of the importing module should be removed on error.\n\t\t\trequire.Zero(t, r.(*runtime).store.Engine.CompiledModuleCount())\n\t\t})\n\t}\n}\n\n// TestRuntime_InstantiateModule_WithName tests that we can pre-validate (cache) a module and instantiate it under\n// different names. This pattern is used in wapc-go.\nfunc TestRuntime_InstantiateModule_WithName(t *testing.T) {\n\tr := NewRuntime(testCtx)\n\tdefer r.Close(testCtx)\n\n\tbase, err := r.CompileModule(testCtx, binaryNamedZero)\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, \"0\", base.(*compiledModule).module.NameSection.ModuleName)\n\n\t// Use the same runtime to instantiate multiple modules\n\tinternal := r.(*runtime)\n\tm1, err := r.InstantiateModule(testCtx, base, NewModuleConfig().WithName(\"1\"))\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"1\", m1.Name())\n\n\trequire.Nil(t, internal.Module(\"0\"))\n\trequire.Equal(t, internal.Module(\"1\"), m1)\n\n\tm2, err := r.InstantiateModule(testCtx, base, NewModuleConfig().WithName(\"2\"))\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"2\", m2.Name())\n\n\trequire.Nil(t, internal.Module(\"0\"))\n\trequire.Equal(t, internal.Module(\"2\"), m2)\n\n\t// Empty name module shouldn't be returned via Module() for future optimization.\n\tm3, err := r.InstantiateModule(testCtx, base, NewModuleConfig().WithName(\"\"))\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"\", m3.Name())\n\n\tret := internal.Module(\"\")\n\trequire.Nil(t, ret)\n}\n\nfunc TestRuntime_InstantiateModule_ExitError(t *testing.T) {\n\tr := NewRuntime(testCtx)\n\tdefer r.Close(testCtx)\n\n\ttests := []struct {\n\t\tname        string\n\t\texitCode    uint32\n\t\texport      bool\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\tname:        \"start: exit code 0\",\n\t\t\texitCode:    0,\n\t\t\texpectedErr: sys.NewExitError(0),\n\t\t},\n\t\t{\n\t\t\tname:        \"start: exit code 2\",\n\t\t\texitCode:    2,\n\t\t\texpectedErr: sys.NewExitError(2),\n\t\t},\n\t\t{\n\t\t\tname:     \"_start: exit code 0\",\n\t\t\texitCode: 0,\n\t\t\texport:   true,\n\t\t},\n\t\t{\n\t\t\tname:        \"_start: exit code 2\",\n\t\t\texitCode:    2,\n\t\t\texport:      true,\n\t\t\texpectedErr: sys.NewExitError(2),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttc := tt\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tstart := func(ctx context.Context, m api.Module) {\n\t\t\t\trequire.NoError(t, m.CloseWithExitCode(ctx, tc.exitCode))\n\t\t\t}\n\n\t\t\tenv, err := r.NewHostModuleBuilder(\"env\").\n\t\t\t\tNewFunctionBuilder().WithFunc(start).Export(\"exit\").\n\t\t\t\tInstantiate(testCtx)\n\t\t\trequire.NoError(t, err)\n\t\t\tdefer env.Close(testCtx)\n\n\t\t\tmod := &wasm.Module{\n\t\t\t\tTypeSection:     []wasm.FunctionType{{}},\n\t\t\t\tImportSection:   []wasm.Import{{Module: \"env\", Name: \"exit\", Type: wasm.ExternTypeFunc, DescFunc: 0}},\n\t\t\t\tFunctionSection: []wasm.Index{0},\n\t\t\t\tCodeSection: []wasm.Code{\n\t\t\t\t\t{Body: []byte{wasm.OpcodeCall, 0, wasm.OpcodeEnd}}, // Call the imported env.start.\n\t\t\t\t},\n\t\t\t}\n\t\t\tif tc.export {\n\t\t\t\tmod.ExportSection = []wasm.Export{\n\t\t\t\t\t{Name: \"_start\", Type: wasm.ExternTypeFunc, Index: 1},\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tone := uint32(1)\n\t\t\t\tmod.StartSection = &one\n\t\t\t}\n\t\t\tbinary := binaryencoding.EncodeModule(mod)\n\n\t\t\t// Instantiate the module, which calls the start function.\n\t\t\tm, err := r.InstantiateWithConfig(testCtx, binary,\n\t\t\t\tNewModuleConfig().WithName(\"call-exit\"))\n\n\t\t\t// Ensure the exit error propagated and didn't wrap.\n\t\t\trequire.Equal(t, tc.expectedErr, err)\n\n\t\t\t// Ensure calling close again doesn't break\n\t\t\tif err == nil {\n\t\t\t\trequire.NoError(t, m.Close(testCtx))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRuntime_CloseWithExitCode(t *testing.T) {\n\tbin := binaryencoding.EncodeModule(&wasm.Module{\n\t\tTypeSection:     []wasm.FunctionType{{}},\n\t\tFunctionSection: []wasm.Index{0},\n\t\tCodeSection:     []wasm.Code{{Body: []byte{wasm.OpcodeEnd}}},\n\t\tExportSection:   []wasm.Export{{Type: wasm.ExternTypeFunc, Index: 0, Name: \"func\"}},\n\t})\n\n\ttests := []struct {\n\t\tname     string\n\t\texitCode uint32\n\t}{\n\t\t{\n\t\t\tname:     \"exit code 0\",\n\t\t\texitCode: uint32(0),\n\t\t},\n\t\t{\n\t\t\tname:     \"exit code 2\",\n\t\t\texitCode: uint32(2),\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttc := tt\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tr := NewRuntime(testCtx)\n\n\t\t\tcode, err := r.CompileModule(testCtx, bin)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Instantiate two modules.\n\t\t\tm1, err := r.InstantiateModule(testCtx, code, NewModuleConfig().WithName(\"mod1\"))\n\t\t\trequire.NoError(t, err)\n\t\t\tm2, err := r.InstantiateModule(testCtx, code, NewModuleConfig().WithName(\"mod2\"))\n\t\t\trequire.NoError(t, err)\n\n\t\t\tfunc1 := m1.ExportedFunction(\"func\")\n\t\t\trequire.Equal(t, map[string]api.FunctionDefinition{\"func\": func1.Definition()},\n\t\t\t\tm1.ExportedFunctionDefinitions())\n\t\t\tfunc2 := m2.ExportedFunction(\"func\")\n\t\t\trequire.Equal(t, map[string]api.FunctionDefinition{\"func\": func2.Definition()},\n\t\t\t\tm2.ExportedFunctionDefinitions())\n\n\t\t\t// Modules not closed so calls succeed\n\n\t\t\t_, err = func1.Call(testCtx)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t_, err = func2.Call(testCtx)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tif tc.exitCode == 0 {\n\t\t\t\terr = r.Close(testCtx)\n\t\t\t} else {\n\t\t\t\terr = r.CloseWithExitCode(testCtx, tc.exitCode)\n\t\t\t}\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Modules closed so calls fail\n\t\t\t_, err = func1.Call(testCtx)\n\t\t\trequire.ErrorIs(t, err, sys.NewExitError(tc.exitCode))\n\n\t\t\t_, err = func2.Call(testCtx)\n\t\t\trequire.ErrorIs(t, err, sys.NewExitError(tc.exitCode))\n\t\t})\n\t}\n}\n\nfunc TestHostFunctionWithCustomContext(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tname   string\n\t\tconfig RuntimeConfig\n\t}{\n\t\t{name: \"compiler\", config: NewRuntimeConfigCompiler()},\n\t\t{name: \"interpreter\", config: NewRuntimeConfigInterpreter()},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tconst fistString = \"hello\"\n\t\t\tconst secondString = \"hello call\"\n\t\t\thostCtx := &HostContext{fistString}\n\t\t\tr := NewRuntimeWithConfig(hostCtx, tc.config)\n\t\t\tdefer r.Close(hostCtx)\n\n\t\t\t// Define a function that will be set as the start function\n\t\t\tvar calledStart bool\n\t\t\tvar calledCall bool\n\t\t\tstart := func(ctx context.Context, module api.Module) {\n\t\t\t\thts, ok := ctx.(*HostContext)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Fatal(\"decorate call context could effect host ctx cast failed, please consider it.\")\n\t\t\t\t}\n\t\t\t\tcalledStart = true\n\t\t\t\trequire.NotNil(t, hts)\n\t\t\t\trequire.Equal(t, fistString, hts.Content)\n\t\t\t}\n\n\t\t\tcallFunc := func(ctx context.Context, module api.Module) {\n\t\t\t\thts, ok := ctx.(*HostContext)\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Fatal(\"decorate call context could effect host ctx cast failed, please consider it.\")\n\t\t\t\t}\n\t\t\t\tcalledCall = true\n\t\t\t\trequire.NotNil(t, hts)\n\t\t\t\trequire.Equal(t, secondString, hts.Content)\n\t\t\t}\n\n\t\t\t_, err := r.NewHostModuleBuilder(\"env\").\n\t\t\t\tNewFunctionBuilder().WithFunc(start).Export(\"host\").\n\t\t\t\tNewFunctionBuilder().WithFunc(callFunc).Export(\"host2\").\n\t\t\t\tInstantiate(hostCtx)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tstartFnIndex := uint32(2)\n\t\t\tbinary := binaryencoding.EncodeModule(&wasm.Module{\n\t\t\t\tTypeSection: []wasm.FunctionType{{}},\n\t\t\t\tImportSection: []wasm.Import{\n\t\t\t\t\t{Module: \"env\", Name: \"host\", Type: wasm.ExternTypeFunc, DescFunc: 0},\n\t\t\t\t\t{Module: \"env\", Name: \"host2\", Type: wasm.ExternTypeFunc, DescFunc: 0},\n\t\t\t\t},\n\t\t\t\tFunctionSection: []wasm.Index{0, 0},\n\t\t\t\tCodeSection: []wasm.Code{\n\t\t\t\t\t{Body: []byte{wasm.OpcodeCall, 0, wasm.OpcodeEnd}}, // Call the imported env.host.\n\t\t\t\t\t{Body: []byte{wasm.OpcodeCall, 1, wasm.OpcodeEnd}}, // Call the imported env.host.\n\t\t\t\t},\n\t\t\t\tExportSection: []wasm.Export{\n\t\t\t\t\t{Type: api.ExternTypeFunc, Name: \"callHost\", Index: uint32(3)},\n\t\t\t\t},\n\t\t\t\tStartSection: &startFnIndex,\n\t\t\t})\n\n\t\t\t// Instantiate the module, which calls the start function. This will fail if the context wasn't as intended.\n\t\t\tins, err := r.Instantiate(hostCtx, binary)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.True(t, calledStart)\n\n\t\t\t// add the new context content for call with used in host function\n\t\t\thostCtx.Content = secondString\n\t\t\t_, err = ins.ExportedFunction(\"callHost\").Call(hostCtx)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.True(t, calledCall)\n\t\t})\n\t}\n}\n\nfunc TestRuntime_Close_ClosesCompiledModules(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tname                 string\n\t\twithCompilationCache bool\n\t}{\n\t\t{name: \"with cache\", withCompilationCache: true},\n\t\t{name: \"without cache\", withCompilationCache: false},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tengine := &mockEngine{name: \"mock\", cachedModules: map[*wasm.Module]struct{}{}}\n\t\t\tconf := *engineLessConfig\n\t\t\tconf.newEngine = func(context.Context, api.CoreFeatures, filecache.Cache) wasm.Engine { return engine }\n\t\t\tif tc.withCompilationCache {\n\t\t\t\tconf.cache = NewCompilationCache()\n\t\t\t}\n\t\t\tr := NewRuntimeWithConfig(testCtx, &conf)\n\t\t\tdefer r.Close(testCtx)\n\n\t\t\t// Normally compiled modules are closed when instantiated but this is never instantiated.\n\t\t\t_, err := r.CompileModule(testCtx, binaryNamedZero)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, uint32(1), engine.CompiledModuleCount())\n\n\t\t\terr = r.Close(testCtx)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Closing the runtime should remove the compiler cache if cache is not configured.\n\t\t\trequire.Equal(t, !tc.withCompilationCache, engine.closed)\n\t\t})\n\t}\n}\n\n// TestRuntime_Closed ensures invocation of closed Runtime's methods is safe.\nfunc TestRuntime_Closed(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tname    string\n\t\terrFunc func(r Runtime, mod CompiledModule) error\n\t}{\n\t\t{\n\t\t\tname: \"InstantiateModule\",\n\t\t\terrFunc: func(r Runtime, mod CompiledModule) error {\n\t\t\t\t_, err := r.InstantiateModule(testCtx, mod, NewModuleConfig())\n\t\t\t\treturn err\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Instantiate\",\n\t\t\terrFunc: func(r Runtime, mod CompiledModule) error {\n\t\t\t\t_, err := r.Instantiate(testCtx, binaryNamedZero)\n\t\t\t\treturn err\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"CompileModule\",\n\t\t\terrFunc: func(r Runtime, mod CompiledModule) error {\n\t\t\t\t_, err := r.CompileModule(testCtx, binaryNamedZero)\n\t\t\t\treturn err\n\t\t\t},\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tengine := &mockEngine{name: \"mock\", cachedModules: map[*wasm.Module]struct{}{}}\n\t\t\tconf := *engineLessConfig\n\t\t\tconf.newEngine = func(context.Context, api.CoreFeatures, filecache.Cache) wasm.Engine { return engine }\n\t\t\tr := NewRuntimeWithConfig(testCtx, &conf)\n\t\t\tdefer r.Close(testCtx)\n\n\t\t\t// Normally compiled modules are closed when instantiated but this is never instantiated.\n\t\t\tmod, err := r.CompileModule(testCtx, binaryNamedZero)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, uint32(1), engine.CompiledModuleCount())\n\n\t\t\terr = r.Close(testCtx)\n\t\t\trequire.NoError(t, err)\n\n\t\t\t// Closing the runtime should remove the compiler cache if cache is not configured.\n\t\t\trequire.True(t, engine.closed)\n\n\t\t\trequire.EqualError(t, tc.errFunc(r, mod), \"runtime closed with exit_code(0)\")\n\t\t})\n\t}\n}\n\ntype mockEngine struct {\n\tname          string\n\tcachedModules map[*wasm.Module]struct{}\n\tclosed        bool\n}\n\n// CompileModule implements the same method as documented on wasm.Engine.\nfunc (e *mockEngine) CompileModule(_ context.Context, module *wasm.Module, _ []experimental.FunctionListener, _ bool) error {\n\te.cachedModules[module] = struct{}{}\n\treturn nil\n}\n\n// CompiledModuleCount implements the same method as documented on wasm.Engine.\nfunc (e *mockEngine) CompiledModuleCount() uint32 {\n\treturn uint32(len(e.cachedModules))\n}\n\n// DeleteCompiledModule implements the same method as documented on wasm.Engine.\nfunc (e *mockEngine) DeleteCompiledModule(module *wasm.Module) {\n\tdelete(e.cachedModules, module)\n}\n\n// NewModuleEngine implements the same method as documented on wasm.Engine.\nfunc (e *mockEngine) NewModuleEngine(_ *wasm.Module, _ *wasm.ModuleInstance) (wasm.ModuleEngine, error) {\n\treturn nil, nil\n}\n\n// NewModuleEngine implements the same method as documented on wasm.Close.\nfunc (e *mockEngine) Close() (err error) {\n\te.closed = true\n\treturn\n}\n\n// TestNewRuntime_concurrent ensures that concurrent execution of NewRuntime is race-free.\n// This depends on -race flag.\nfunc TestNewRuntime_concurrent(t *testing.T) {\n\tconst num = 100\n\tvar wg sync.WaitGroup\n\tc := NewCompilationCache()\n\t// If available, uses two engine configurations for the single compilation cache.\n\tconfigs := [2]RuntimeConfig{NewRuntimeConfigInterpreter().WithCompilationCache(c)}\n\tif platform.CompilerSupported() {\n\t\tconfigs[1] = NewRuntimeConfigCompiler().WithCompilationCache(c)\n\t} else {\n\t\tconfigs[1] = NewRuntimeConfigInterpreter().WithCompilationCache(c)\n\t}\n\twg.Add(num)\n\tfor i := 0; i < num; i++ {\n\t\ti := i\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tr := NewRuntimeWithConfig(testCtx, configs[i%2])\n\t\t\terr := r.Close(testCtx)\n\t\t\trequire.NoError(t, err)\n\t\t}()\n\t}\n\twg.Wait()\n}\n"
        },
        {
          "name": "site",
          "type": "tree",
          "content": null
        },
        {
          "name": "sys",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}