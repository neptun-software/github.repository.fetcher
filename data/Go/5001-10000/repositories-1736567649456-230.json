{
  "metadata": {
    "timestamp": 1736567649456,
    "page": 230,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "expr-lang/expr",
      "stars": 6452,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0830078125,
          "content": "*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n*.test\n*.out\n*.html\ncustom_tests.json\npro/\ntest/avs/\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0458984375,
          "content": "MIT License\n\nCopyright (c) 2018 Anton Medvedev\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.2265625,
          "content": "<h1><a href=\"https://expr-lang.org\"><img src=\"https://expr-lang.org/img/logo.png\" alt=\"Zx logo\" height=\"48\"align=\"right\"></a> Expr</h1>\n\n> [!IMPORTANT]\n> The repository [github.com/antonmedv/expr](https://github.com/antonmedv/expr) moved to [github.com/**expr-lang**/expr](https://github.com/expr-lang/expr).\n\n[![test](https://github.com/expr-lang/expr/actions/workflows/test.yml/badge.svg)](https://github.com/expr-lang/expr/actions/workflows/test.yml) \n[![Go Report Card](https://goreportcard.com/badge/github.com/expr-lang/expr)](https://goreportcard.com/report/github.com/expr-lang/expr) \n[![Fuzzing Status](https://oss-fuzz-build-logs.storage.googleapis.com/badges/expr.svg)](https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&can=1&q=proj:expr)\n[![GoDoc](https://godoc.org/github.com/expr-lang/expr?status.svg)](https://godoc.org/github.com/expr-lang/expr)\n\n**Expr** is a Go-centric expression language designed to deliver dynamic configurations with unparalleled accuracy, safety, and speed. \n**Expr** combines simple [syntax](https://expr-lang.org/docs/language-definition) with powerful features for ease of use:\n\n```js\n// Allow only admins and moderators to moderate comments.\nuser.Group in [\"admin\", \"moderator\"] || user.Id == comment.UserId\n```\n\n```js\n// Determine whether the request is in the permitted time window.\nrequest.Time - resource.Age < duration(\"24h\")\n```\n\n```js\n// Ensure all tweets are less than 240 characters.\nall(tweets, len(.Content) <= 240)\n```\n\n## Features\n\n**Expr** is a safe, fast, and intuitive expression evaluator optimized for the Go language. \nHere are its standout features:\n\n### Safety and Isolation\n* **Memory-Safe**: Expr is designed with a focus on safety, ensuring that programs do not access unrelated memory or introduce memory vulnerabilities.\n* **Side-Effect-Free**: Expressions evaluated in Expr only compute outputs from their inputs, ensuring no side-effects that can change state or produce unintended results.\n* **Always Terminating**: Expr is designed to prevent infinite loops, ensuring that every program will conclude in a reasonable amount of time.\n\n### Go Integration\n* **Seamless with Go**: Integrate Expr into your Go projects without the need to redefine types.\n\n### Static Typing\n* Ensures type correctness and prevents runtime type errors.\n  ```go\n  out, err := expr.Compile(`name + age`)\n  // err: invalid operation + (mismatched types string and int)\n  // | name + age\n  // | .....^\n  ```\n\n### User-Friendly\n* Provides user-friendly error messages to assist with debugging and development.\n\n### Flexibility and Utility\n* **Rich Operators**: Offers a reasonable set of basic operators for a variety of applications.\n* **Built-in Functions**: Functions like `all`, `none`, `any`, `one`, `filter`, and `map` are provided out-of-the-box.\n\n### Performance\n* **Optimized for Speed**: Expr stands out in its performance, utilizing an optimizing compiler and a bytecode virtual machine. Check out these [benchmarks](https://github.com/antonmedv/golang-expression-evaluation-comparison#readme) for more details.\n\n## Install\n\n```\ngo get github.com/expr-lang/expr\n```\n\n## Documentation\n\n* See [Getting Started](https://expr-lang.org/docs/Getting-Started) page for developer documentation.\n* See [Language Definition](https://expr-lang.org/docs/language-definition) page to learn the syntax.\n\n## Examples\n\n[Play Online](https://go.dev/play/p/XCoNXEjm3TS)\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/expr-lang/expr\"\n)\n\nfunc main() {\n\tenv := map[string]interface{}{\n\t\t\"greet\":   \"Hello, %v!\",\n\t\t\"names\":   []string{\"world\", \"you\"},\n\t\t\"sprintf\": fmt.Sprintf,\n\t}\n\n\tcode := `sprintf(greet, names[0])`\n\n\tprogram, err := expr.Compile(code, expr.Env(env))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\toutput, err := expr.Run(program, env)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(output)\n}\n```\n\n[Play Online](https://go.dev/play/p/tz-ZneBfSuw)\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/expr-lang/expr\"\n)\n\ntype Tweet struct {\n\tLen int\n}\n\ntype Env struct {\n\tTweets []Tweet\n}\n\nfunc main() {\n\tcode := `all(Tweets, {.Len <= 240})`\n\n\tprogram, err := expr.Compile(code, expr.Env(Env{}))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tenv := Env{\n\t\tTweets: []Tweet{{42}, {98}, {69}},\n\t}\n\toutput, err := expr.Run(program, env)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(output)\n}\n```\n\n## Who uses Expr?\n\n* [Google](https://google.com) uses Expr as one of its expression languages on the [Google Cloud Platform](https://cloud.google.com).\n* [Uber](https://uber.com) uses Expr to allow customization of its Uber Eats marketplace.\n* [GoDaddy](https://godaddy.com) employs Expr for the customization of its GoDaddy Pro product.\n* [ByteDance](https://bytedance.com) incorporates Expr into its internal business rule engine.\n* [Aviasales](https://aviasales.ru) utilizes Expr as a business rule engine for its flight search engine.\n* [Wish.com](https://www.wish.com) employs Expr in its decision-making rule engine for the Wish Assistant.\n* [Argo](https://argoproj.github.io) integrates Expr into Argo Rollouts and Argo Workflows for Kubernetes.\n* [OpenTelemetry](https://opentelemetry.io) integrates Expr into the OpenTelemetry Collector.\n* [Philips Labs](https://github.com/philips-labs/tabia) employs Expr in Tabia, a tool designed to collect insights on their code bases.\n* [CrowdSec](https://crowdsec.net) incorporates Expr into its security automation tool.\n* [CoreDNS](https://coredns.io) uses Expr in CoreDNS, which is a DNS server.\n* [qiniu](https://www.qiniu.com) implements Expr in its trade systems.\n* [Junglee Games](https://www.jungleegames.com/) uses Expr for its in-house marketing retention tool, Project Audience.\n* [Faceit](https://www.faceit.com) uses Expr to enhance customization of its eSports matchmaking algorithm.\n* [Chaos Mesh](https://chaos-mesh.org) incorporates Expr into Chaos Mesh, a cloud-native Chaos Engineering platform.\n* [Visually.io](https://visually.io) employs Expr as a business rule engine for its personalization targeting algorithm.\n* [Akvorado](https://github.com/akvorado/akvorado) utilizes Expr to classify exporters and interfaces in network flows.\n* [keda.sh](https://keda.sh) uses Expr to allow customization of its Kubernetes-based event-driven autoscaling.\n* [Span Digital](https://spandigital.com/) uses Expr in its Knowledge Management products.\n* [Xiaohongshu](https://www.xiaohongshu.com/) combining yaml with Expr for dynamically policies delivery.\n* [Melrōse](https://melrōse.org) uses Expr to implement its music programming language.\n* [Tork](https://www.tork.run/) integrates Expr into its workflow execution.\n* [Critical Moments](https://criticalmoments.io) uses Expr for its mobile realtime conditional targeting system.\n* [WoodpeckerCI](https://woodpecker-ci.org) uses Expr for [filtering workflows/steps](https://woodpecker-ci.org/docs/usage/workflow-syntax#evaluate).\n* [FastSchema](https://github.com/fastschema/fastschema) - A BaaS leveraging Expr for its customizable and dynamic Access Control system.\n* [WunderGraph Cosmo](https://github.com/wundergraph/cosmo) - GraphQL Federeration Router uses Expr to customize Middleware behaviour\n\n[Add your company too](https://github.com/expr-lang/expr/edit/master/README.md)\n\n## License\n\n[MIT](https://github.com/expr-lang/expr/blob/master/LICENSE)\n\n<p align=\"center\"><img src=\"https://expr-lang.org/img/gopher-small.png\" width=\"150\" /></p>\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.8759765625,
          "content": "# Security Policy\n\n## Supported Versions\n\nExpr is generally backwards compatible with very few exceptions, so we\nrecommend users to always use the latest version to experience stability,\nperformance and security.\n\nWe generally backport security issues to a single previous minor version,\nunless this is not possible or feasible with a reasonable effort.\n\n| Version | Supported          |\n|---------|--------------------|\n| 1.16    | :white_check_mark: |\n| 1.15    | :white_check_mark: |\n| 1.14    | :white_check_mark: |\n| 1.13    | :white_check_mark: |\n| < 1.13  | :x:                |\n\n## Reporting a Vulnerability\n\nIf you believe you've discovered a serious vulnerability, please contact the\nExpr core team at anton+security@medv.io. We will evaluate your report and if\nnecessary issue a fix and an advisory. If the issue was previously undisclosed,\nwe'll also mention your name in the credits.\n"
        },
        {
          "name": "ast",
          "type": "tree",
          "content": null
        },
        {
          "name": "bench_test.go",
          "type": "blob",
          "size": 10.2578125,
          "content": "package expr_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/expr-lang/expr/internal/testify/require\"\n\n\t\"github.com/expr-lang/expr\"\n\t\"github.com/expr-lang/expr/vm\"\n)\n\nfunc Benchmark_expr(b *testing.B) {\n\tparams := make(map[string]any)\n\tparams[\"Origin\"] = \"MOW\"\n\tparams[\"Country\"] = \"RU\"\n\tparams[\"Adults\"] = 1\n\tparams[\"Value\"] = 100\n\n\tprogram, err := expr.Compile(`(Origin == \"MOW\" || Country == \"RU\") && (Value >= 100 || Adults == 1)`, expr.Env(params))\n\trequire.NoError(b, err)\n\n\tvar out any\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = vm.Run(program, params)\n\t}\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.True(b, out.(bool))\n}\n\nfunc Benchmark_expr_reuseVm(b *testing.B) {\n\tparams := make(map[string]any)\n\tparams[\"Origin\"] = \"MOW\"\n\tparams[\"Country\"] = \"RU\"\n\tparams[\"Adults\"] = 1\n\tparams[\"Value\"] = 100\n\n\tprogram, err := expr.Compile(`(Origin == \"MOW\" || Country == \"RU\") && (Value >= 100 || Adults == 1)`, expr.Env(params))\n\trequire.NoError(b, err)\n\n\tvar out any\n\tv := vm.VM{}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = v.Run(program, params)\n\t}\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.True(b, out.(bool))\n}\n\nfunc Benchmark_len(b *testing.B) {\n\tenv := map[string]any{\n\t\t\"arr\": make([]int, 100),\n\t}\n\n\tprogram, err := expr.Compile(`len(arr)`, expr.Env(env))\n\trequire.NoError(b, err)\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = vm.Run(program, env)\n\t}\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, 100, out)\n}\n\nfunc Benchmark_filter(b *testing.B) {\n\ttype Env struct {\n\t\tInts []int\n\t}\n\tenv := Env{\n\t\tInts: make([]int, 1000),\n\t}\n\tfor i := 1; i <= len(env.Ints); i++ {\n\t\tenv.Ints[i-1] = i\n\t}\n\n\tprogram, err := expr.Compile(`filter(Ints, # % 7 == 0)`, expr.Env(Env{}))\n\trequire.NoError(b, err)\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = vm.Run(program, env)\n\t}\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.Len(b, out.([]any), 142)\n}\n\nfunc Benchmark_filterLen(b *testing.B) {\n\ttype Env struct {\n\t\tInts []int\n\t}\n\tenv := Env{\n\t\tInts: make([]int, 1000),\n\t}\n\tfor i := 1; i <= len(env.Ints); i++ {\n\t\tenv.Ints[i-1] = i\n\t}\n\n\tprogram, err := expr.Compile(`len(filter(Ints, # % 7 == 0))`, expr.Env(Env{}))\n\trequire.NoError(b, err)\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = vm.Run(program, env)\n\t}\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, 142, out)\n}\n\nfunc Benchmark_filterFirst(b *testing.B) {\n\ttype Env struct {\n\t\tInts []int\n\t}\n\tenv := Env{\n\t\tInts: make([]int, 1000),\n\t}\n\tfor i := 1; i <= len(env.Ints); i++ {\n\t\tenv.Ints[i-1] = i\n\t}\n\n\tprogram, err := expr.Compile(`filter(Ints, # % 7 == 0)[0]`, expr.Env(Env{}))\n\trequire.NoError(b, err)\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = vm.Run(program, env)\n\t}\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, 7, out)\n}\n\nfunc Benchmark_filterLast(b *testing.B) {\n\ttype Env struct {\n\t\tInts []int\n\t}\n\tenv := Env{\n\t\tInts: make([]int, 1000),\n\t}\n\tfor i := 1; i <= len(env.Ints); i++ {\n\t\tenv.Ints[i-1] = i\n\t}\n\n\tprogram, err := expr.Compile(`filter(Ints, # % 7 == 0)[-1]`, expr.Env(Env{}))\n\trequire.NoError(b, err)\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = vm.Run(program, env)\n\t}\n\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, 994, out)\n}\n\nfunc Benchmark_filterMap(b *testing.B) {\n\ttype Env struct {\n\t\tInts []int\n\t}\n\tenv := Env{\n\t\tInts: make([]int, 100),\n\t}\n\tfor i := 1; i <= len(env.Ints); i++ {\n\t\tenv.Ints[i-1] = i\n\t}\n\n\tprogram, err := expr.Compile(`map(filter(Ints, # % 7 == 0), # * 2)`, expr.Env(Env{}))\n\trequire.NoError(b, err)\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = vm.Run(program, env)\n\t}\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.Len(b, out.([]any), 14)\n\trequire.Equal(b, 14, out.([]any)[0])\n}\n\nfunc Benchmark_arrayIndex(b *testing.B) {\n\tenv := map[string]any{\n\t\t\"arr\": make([]int, 100),\n\t}\n\tfor i := 0; i < 100; i++ {\n\t\tenv[\"arr\"].([]int)[i] = i\n\t}\n\n\tprogram, err := expr.Compile(`arr[50]`, expr.Env(env))\n\trequire.NoError(b, err)\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = vm.Run(program, env)\n\t}\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, 50, out)\n}\n\nfunc Benchmark_envStruct(b *testing.B) {\n\ttype Price struct {\n\t\tValue int\n\t}\n\ttype Env struct {\n\t\tPrice Price\n\t}\n\n\tprogram, err := expr.Compile(`Price.Value > 0`, expr.Env(Env{}))\n\trequire.NoError(b, err)\n\n\tenv := Env{Price: Price{Value: 1}}\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = vm.Run(program, env)\n\t}\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.True(b, out.(bool))\n}\n\nfunc Benchmark_envMap(b *testing.B) {\n\ttype Price struct {\n\t\tValue int\n\t}\n\tenv := map[string]any{\n\t\t\"price\": Price{Value: 1},\n\t}\n\n\tprogram, err := expr.Compile(`price.Value > 0`, expr.Env(env))\n\trequire.NoError(b, err)\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = vm.Run(program, env)\n\t}\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.True(b, out.(bool))\n}\n\ntype CallEnv struct {\n\tA      int\n\tB      int\n\tC      int\n\tFn     func() bool\n\tFnFast func(...any) any\n\tFoo    CallFoo\n}\n\nfunc (CallEnv) Func() string {\n\treturn \"func\"\n}\n\ntype CallFoo struct {\n\tD int\n\tE int\n\tF int\n}\n\nfunc (CallFoo) Method() string {\n\treturn \"method\"\n}\n\nfunc Benchmark_callFunc(b *testing.B) {\n\tprogram, err := expr.Compile(`Func()`, expr.Env(CallEnv{}))\n\trequire.NoError(b, err)\n\n\tenv := CallEnv{}\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = vm.Run(program, env)\n\t}\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"func\", out)\n}\n\nfunc Benchmark_callMethod(b *testing.B) {\n\tprogram, err := expr.Compile(`Foo.Method()`, expr.Env(CallEnv{}))\n\trequire.NoError(b, err)\n\n\tenv := CallEnv{}\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = vm.Run(program, env)\n\t}\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"method\", out)\n}\n\nfunc Benchmark_callField(b *testing.B) {\n\tprogram, err := expr.Compile(`Fn()`, expr.Env(CallEnv{}))\n\trequire.NoError(b, err)\n\n\tenv := CallEnv{\n\t\tFn: func() bool {\n\t\t\treturn true\n\t\t},\n\t}\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = vm.Run(program, env)\n\t}\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.True(b, out.(bool))\n}\n\nfunc Benchmark_callFast(b *testing.B) {\n\tprogram, err := expr.Compile(`FnFast()`, expr.Env(CallEnv{}))\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tenv := CallEnv{\n\t\tFnFast: func(s ...any) any {\n\t\t\treturn \"fn_fast\"\n\t\t},\n\t}\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = vm.Run(program, env)\n\t}\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"fn_fast\", out)\n}\n\nfunc Benchmark_callConstExpr(b *testing.B) {\n\tprogram, err := expr.Compile(`Func()`, expr.Env(CallEnv{}), expr.ConstExpr(\"Func\"))\n\trequire.NoError(b, err)\n\n\tenv := CallEnv{}\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = vm.Run(program, env)\n\t}\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.Equal(b, \"func\", out)\n}\n\nfunc Benchmark_largeStructAccess(b *testing.B) {\n\ttype Env struct {\n\t\tData  [1024 * 1024 * 10]byte\n\t\tField int\n\t}\n\n\tprogram, err := expr.Compile(`Field > 0 && Field > 1 && Field < 99`, expr.Env(Env{}))\n\trequire.NoError(b, err)\n\n\tenv := Env{Field: 21}\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = vm.Run(program, &env)\n\t}\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.True(b, out.(bool))\n}\n\nfunc Benchmark_largeNestedStructAccess(b *testing.B) {\n\ttype Env struct {\n\t\tInner struct {\n\t\t\tData  [1024 * 1024 * 10]byte\n\t\t\tField int\n\t\t}\n\t}\n\n\tprogram, err := expr.Compile(`Inner.Field > 0 && Inner.Field > 1 && Inner.Field < 99`, expr.Env(Env{}))\n\trequire.NoError(b, err)\n\n\tenv := Env{}\n\tenv.Inner.Field = 21\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = vm.Run(program, &env)\n\t}\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.True(b, out.(bool))\n}\n\nfunc Benchmark_largeNestedArrayAccess(b *testing.B) {\n\ttype Env struct {\n\t\tData [1][1024 * 1024 * 10]byte\n\t}\n\n\tprogram, err := expr.Compile(`Data[0][0] > 0`, expr.Env(Env{}))\n\trequire.NoError(b, err)\n\n\tenv := Env{}\n\tenv.Data[0][0] = 1\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, err = vm.Run(program, &env)\n\t}\n\tb.StopTimer()\n\n\trequire.NoError(b, err)\n\trequire.True(b, out.(bool))\n}\n\nfunc Benchmark_sort(b *testing.B) {\n\tenv := map[string]any{\n\t\t\"arr\": []any{55, 58, 42, 61, 75, 52, 64, 62, 16, 79, 40, 14, 50, 76, 23, 2, 5, 80, 89, 51, 21, 96, 91, 13, 71, 82, 65, 63, 11, 17, 94, 81, 74, 4, 97, 1, 39, 3, 28, 8, 84, 90, 47, 85, 7, 56, 49, 93, 33, 12, 19, 60, 86, 100, 44, 45, 36, 72, 95, 77, 34, 92, 24, 73, 18, 38, 43, 26, 41, 69, 67, 57, 9, 27, 66, 87, 46, 35, 59, 70, 10, 20, 53, 15, 32, 98, 68, 31, 54, 25, 83, 88, 22, 48, 29, 37, 6, 78, 99, 30},\n\t}\n\n\tprogram, err := expr.Compile(`sort(arr)`, expr.Env(env))\n\trequire.NoError(b, err)\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, _ = vm.Run(program, env)\n\t}\n\tb.StopTimer()\n\n\trequire.Equal(b, 1, out.([]any)[0])\n\trequire.Equal(b, 100, out.([]any)[99])\n}\n\nfunc Benchmark_sortBy(b *testing.B) {\n\ttype Foo struct {\n\t\tValue int\n\t}\n\tarr := []any{55, 58, 42, 61, 75, 52, 64, 62, 16, 79, 40, 14, 50, 76, 23, 2, 5, 80, 89, 51, 21, 96, 91, 13, 71, 82, 65, 63, 11, 17, 94, 81, 74, 4, 97, 1, 39, 3, 28, 8, 84, 90, 47, 85, 7, 56, 49, 93, 33, 12, 19, 60, 86, 100, 44, 45, 36, 72, 95, 77, 34, 92, 24, 73, 18, 38, 43, 26, 41, 69, 67, 57, 9, 27, 66, 87, 46, 35, 59, 70, 10, 20, 53, 15, 32, 98, 68, 31, 54, 25, 83, 88, 22, 48, 29, 37, 6, 78, 99, 30}\n\tenv := map[string]any{\n\t\t\"arr\": make([]Foo, len(arr)),\n\t}\n\tfor i, v := range arr {\n\t\tenv[\"arr\"].([]Foo)[i] = Foo{Value: v.(int)}\n\t}\n\n\tprogram, err := expr.Compile(`sortBy(arr, .Value)`, expr.Env(env))\n\trequire.NoError(b, err)\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, _ = vm.Run(program, env)\n\t}\n\tb.StopTimer()\n\n\trequire.Equal(b, 1, out.([]any)[0].(Foo).Value)\n\trequire.Equal(b, 100, out.([]any)[99].(Foo).Value)\n}\n\nfunc Benchmark_groupBy(b *testing.B) {\n\tprogram, err := expr.Compile(`groupBy(1..100, # % 7)[6]`)\n\trequire.NoError(b, err)\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, _ = vm.Run(program, nil)\n\t}\n\tb.StopTimer()\n\n\trequire.Equal(b, 6, out.([]any)[0])\n}\n\nfunc Benchmark_reduce(b *testing.B) {\n\tprogram, err := expr.Compile(`reduce(1..100, # + #acc)`)\n\trequire.NoError(b, err)\n\n\tvar out any\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tout, _ = vm.Run(program, nil)\n\t}\n\tb.StopTimer()\n\n\trequire.Equal(b, 5050, out.(int))\n}\n"
        },
        {
          "name": "builtin",
          "type": "tree",
          "content": null
        },
        {
          "name": "checker",
          "type": "tree",
          "content": null
        },
        {
          "name": "compiler",
          "type": "tree",
          "content": null
        },
        {
          "name": "conf",
          "type": "tree",
          "content": null
        },
        {
          "name": "debug",
          "type": "tree",
          "content": null
        },
        {
          "name": "docgen",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "expr.go",
          "type": "blob",
          "size": 5.8564453125,
          "content": "package expr\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"time\"\n\n\t\"github.com/expr-lang/expr/ast\"\n\t\"github.com/expr-lang/expr/builtin\"\n\t\"github.com/expr-lang/expr/checker\"\n\t\"github.com/expr-lang/expr/compiler\"\n\t\"github.com/expr-lang/expr/conf\"\n\t\"github.com/expr-lang/expr/file\"\n\t\"github.com/expr-lang/expr/optimizer\"\n\t\"github.com/expr-lang/expr/patcher\"\n\t\"github.com/expr-lang/expr/vm\"\n)\n\n// Option for configuring config.\ntype Option func(c *conf.Config)\n\n// Env specifies expected input of env for type checks.\n// If struct is passed, all fields will be treated as variables,\n// as well as all fields of embedded structs and struct itself.\n// If map is passed, all items will be treated as variables.\n// Methods defined on this type will be available as functions.\nfunc Env(env any) Option {\n\treturn func(c *conf.Config) {\n\t\tc.WithEnv(env)\n\t}\n}\n\n// AllowUndefinedVariables allows to use undefined variables inside expressions.\n// This can be used with expr.Env option to partially define a few variables.\nfunc AllowUndefinedVariables() Option {\n\treturn func(c *conf.Config) {\n\t\tc.Strict = false\n\t}\n}\n\n// Operator allows to replace a binary operator with a function.\nfunc Operator(operator string, fn ...string) Option {\n\treturn func(c *conf.Config) {\n\t\tp := &patcher.OperatorOverloading{\n\t\t\tOperator:  operator,\n\t\t\tOverloads: fn,\n\t\t\tEnv:       &c.Env,\n\t\t\tFunctions: c.Functions,\n\t\t}\n\t\tc.Visitors = append(c.Visitors, p)\n\t}\n}\n\n// ConstExpr defines func expression as constant. If all argument to this function is constants,\n// then it can be replaced by result of this func call on compile step.\nfunc ConstExpr(fn string) Option {\n\treturn func(c *conf.Config) {\n\t\tc.ConstExpr(fn)\n\t}\n}\n\n// AsAny tells the compiler to expect any result.\nfunc AsAny() Option {\n\treturn func(c *conf.Config) {\n\t\tc.ExpectAny = true\n\t}\n}\n\n// AsKind tells the compiler to expect kind of the result.\nfunc AsKind(kind reflect.Kind) Option {\n\treturn func(c *conf.Config) {\n\t\tc.Expect = kind\n\t\tc.ExpectAny = true\n\t}\n}\n\n// AsBool tells the compiler to expect a boolean result.\nfunc AsBool() Option {\n\treturn func(c *conf.Config) {\n\t\tc.Expect = reflect.Bool\n\t\tc.ExpectAny = true\n\t}\n}\n\n// AsInt tells the compiler to expect an int result.\nfunc AsInt() Option {\n\treturn func(c *conf.Config) {\n\t\tc.Expect = reflect.Int\n\t\tc.ExpectAny = true\n\t}\n}\n\n// AsInt64 tells the compiler to expect an int64 result.\nfunc AsInt64() Option {\n\treturn func(c *conf.Config) {\n\t\tc.Expect = reflect.Int64\n\t\tc.ExpectAny = true\n\t}\n}\n\n// AsFloat64 tells the compiler to expect a float64 result.\nfunc AsFloat64() Option {\n\treturn func(c *conf.Config) {\n\t\tc.Expect = reflect.Float64\n\t\tc.ExpectAny = true\n\t}\n}\n\n// WarnOnAny tells the compiler to warn if expression return any type.\nfunc WarnOnAny() Option {\n\treturn func(c *conf.Config) {\n\t\tif c.Expect == reflect.Invalid {\n\t\t\tpanic(\"WarnOnAny() works only with combination with AsInt(), AsBool(), etc. options\")\n\t\t}\n\t\tc.ExpectAny = false\n\t}\n}\n\n// Optimize turns optimizations on or off.\nfunc Optimize(b bool) Option {\n\treturn func(c *conf.Config) {\n\t\tc.Optimize = b\n\t}\n}\n\n// Patch adds visitor to list of visitors what will be applied before compiling AST to bytecode.\nfunc Patch(visitor ast.Visitor) Option {\n\treturn func(c *conf.Config) {\n\t\tc.Visitors = append(c.Visitors, visitor)\n\t}\n}\n\n// Function adds function to list of functions what will be available in expressions.\nfunc Function(name string, fn func(params ...any) (any, error), types ...any) Option {\n\treturn func(c *conf.Config) {\n\t\tts := make([]reflect.Type, len(types))\n\t\tfor i, t := range types {\n\t\t\tt := reflect.TypeOf(t)\n\t\t\tif t.Kind() == reflect.Ptr {\n\t\t\t\tt = t.Elem()\n\t\t\t}\n\t\t\tif t.Kind() != reflect.Func {\n\t\t\t\tpanic(fmt.Sprintf(\"expr: type of %s is not a function\", name))\n\t\t\t}\n\t\t\tts[i] = t\n\t\t}\n\t\tc.Functions[name] = &builtin.Function{\n\t\t\tName:  name,\n\t\t\tFunc:  fn,\n\t\t\tTypes: ts,\n\t\t}\n\t}\n}\n\n// DisableAllBuiltins disables all builtins.\nfunc DisableAllBuiltins() Option {\n\treturn func(c *conf.Config) {\n\t\tfor name := range c.Builtins {\n\t\t\tc.Disabled[name] = true\n\t\t}\n\t}\n}\n\n// DisableBuiltin disables builtin function.\nfunc DisableBuiltin(name string) Option {\n\treturn func(c *conf.Config) {\n\t\tc.Disabled[name] = true\n\t}\n}\n\n// EnableBuiltin enables builtin function.\nfunc EnableBuiltin(name string) Option {\n\treturn func(c *conf.Config) {\n\t\tdelete(c.Disabled, name)\n\t}\n}\n\n// WithContext passes context to all functions calls with a context.Context argument.\nfunc WithContext(name string) Option {\n\treturn Patch(patcher.WithContext{\n\t\tName: name,\n\t})\n}\n\n// Timezone sets default timezone for date() and now() builtin functions.\nfunc Timezone(name string) Option {\n\ttz, err := time.LoadLocation(name)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn Patch(patcher.WithTimezone{\n\t\tLocation: tz,\n\t})\n}\n\n// Compile parses and compiles given input expression to bytecode program.\nfunc Compile(input string, ops ...Option) (*vm.Program, error) {\n\tconfig := conf.CreateNew()\n\tfor _, op := range ops {\n\t\top(config)\n\t}\n\tfor name := range config.Disabled {\n\t\tdelete(config.Builtins, name)\n\t}\n\tconfig.Check()\n\n\ttree, err := checker.ParseCheck(input, config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif config.Optimize {\n\t\terr = optimizer.Optimize(&tree.Node, config)\n\t\tif err != nil {\n\t\t\tvar fileError *file.Error\n\t\t\tif errors.As(err, &fileError) {\n\t\t\t\treturn nil, fileError.Bind(tree.Source)\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tprogram, err := compiler.Compile(tree, config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn program, nil\n}\n\n// Run evaluates given bytecode program.\nfunc Run(program *vm.Program, env any) (any, error) {\n\treturn vm.Run(program, env)\n}\n\n// Eval parses, compiles and runs given input.\nfunc Eval(input string, env any) (any, error) {\n\tif _, ok := env.(Option); ok {\n\t\treturn nil, fmt.Errorf(\"misused expr.Eval: second argument (env) should be passed without expr.Env\")\n\t}\n\n\tprogram, err := Compile(input)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\toutput, err := Run(program, env)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn output, nil\n}\n"
        },
        {
          "name": "expr_test.go",
          "type": "blob",
          "size": 50.2783203125,
          "content": "package expr_test\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"reflect\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/expr-lang/expr/internal/testify/assert\"\n\t\"github.com/expr-lang/expr/internal/testify/require\"\n\t\"github.com/expr-lang/expr/types\"\n\n\t\"github.com/expr-lang/expr\"\n\t\"github.com/expr-lang/expr/ast\"\n\t\"github.com/expr-lang/expr/file\"\n\t\"github.com/expr-lang/expr/test/mock\"\n)\n\nfunc ExampleEval() {\n\toutput, err := expr.Eval(\"greet + name\", map[string]any{\n\t\t\"greet\": \"Hello, \",\n\t\t\"name\":  \"world!\",\n\t})\n\tif err != nil {\n\t\tfmt.Printf(\"err: %v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%v\", output)\n\n\t// Output: Hello, world!\n}\n\nfunc ExampleEval_runtime_error() {\n\t_, err := expr.Eval(`map(1..3, {1 % (# - 3)})`, nil)\n\tfmt.Print(err)\n\n\t// Output: runtime error: integer divide by zero (1:14)\n\t//  | map(1..3, {1 % (# - 3)})\n\t//  | .............^\n}\n\nfunc ExampleCompile() {\n\tenv := map[string]any{\n\t\t\"foo\": 1,\n\t\t\"bar\": 99,\n\t}\n\n\tprogram, err := expr.Compile(\"foo in 1..99 and bar in 1..99\", expr.Env(env))\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\toutput, err := expr.Run(program, env)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%v\", output)\n\n\t// Output: true\n}\n\nfunc ExampleEnv() {\n\ttype Segment struct {\n\t\tOrigin string\n\t}\n\ttype Passengers struct {\n\t\tAdults int\n\t}\n\ttype Meta struct {\n\t\tTags map[string]string\n\t}\n\ttype Env struct {\n\t\tMeta\n\t\tSegments   []*Segment\n\t\tPassengers *Passengers\n\t\tMarker     string\n\t}\n\n\tcode := `all(Segments, {.Origin == \"MOW\"}) && Passengers.Adults > 0 && Tags[\"foo\"] startsWith \"bar\"`\n\n\tprogram, err := expr.Compile(code, expr.Env(Env{}))\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\tenv := Env{\n\t\tMeta: Meta{\n\t\t\tTags: map[string]string{\n\t\t\t\t\"foo\": \"bar\",\n\t\t\t},\n\t\t},\n\t\tSegments: []*Segment{\n\t\t\t{Origin: \"MOW\"},\n\t\t},\n\t\tPassengers: &Passengers{\n\t\t\tAdults: 2,\n\t\t},\n\t\tMarker: \"test\",\n\t}\n\n\toutput, err := expr.Run(program, env)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%v\", output)\n\n\t// Output: true\n}\n\nfunc ExampleEnv_tagged_field_names() {\n\tenv := struct {\n\t\tFirstWord  string\n\t\tSeparator  string `expr:\"Space\"`\n\t\tSecondWord string `expr:\"second_word\"`\n\t}{\n\t\tFirstWord:  \"Hello\",\n\t\tSeparator:  \" \",\n\t\tSecondWord: \"World\",\n\t}\n\n\toutput, err := expr.Eval(`FirstWord + Space + second_word`, env)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%v\", output)\n\n\t// Output : Hello World\n}\n\nfunc ExampleAsKind() {\n\tprogram, err := expr.Compile(\"{a: 1, b: 2}\", expr.AsKind(reflect.Map))\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\toutput, err := expr.Run(program, nil)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%v\", output)\n\n\t// Output: map[a:1 b:2]\n}\n\nfunc ExampleAsBool() {\n\tenv := map[string]int{\n\t\t\"foo\": 0,\n\t}\n\n\tprogram, err := expr.Compile(\"foo >= 0\", expr.Env(env), expr.AsBool())\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\toutput, err := expr.Run(program, env)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%v\", output.(bool))\n\n\t// Output: true\n}\n\nfunc ExampleAsBool_error() {\n\tenv := map[string]any{\n\t\t\"foo\": 0,\n\t}\n\n\t_, err := expr.Compile(\"foo + 42\", expr.Env(env), expr.AsBool())\n\n\tfmt.Printf(\"%v\", err)\n\n\t// Output: expected bool, but got int\n}\n\nfunc ExampleAsInt() {\n\tprogram, err := expr.Compile(\"42\", expr.AsInt())\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\toutput, err := expr.Run(program, nil)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%T(%v)\", output, output)\n\n\t// Output: int(42)\n}\n\nfunc ExampleAsInt64() {\n\tenv := map[string]any{\n\t\t\"rating\": 5.5,\n\t}\n\n\tprogram, err := expr.Compile(\"rating\", expr.Env(env), expr.AsInt64())\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\toutput, err := expr.Run(program, env)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%v\", output.(int64))\n\n\t// Output: 5\n}\n\nfunc ExampleAsFloat64() {\n\tprogram, err := expr.Compile(\"42\", expr.AsFloat64())\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\toutput, err := expr.Run(program, nil)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%v\", output.(float64))\n\n\t// Output: 42\n}\n\nfunc ExampleAsFloat64_error() {\n\t_, err := expr.Compile(`!!true`, expr.AsFloat64())\n\n\tfmt.Printf(\"%v\", err)\n\n\t// Output: expected float64, but got bool\n}\n\nfunc ExampleWarnOnAny() {\n\t// Arrays always have []any type. The expression return type is any.\n\t// AsInt() instructs compiler to expect int or any, and cast to int,\n\t// if possible. WarnOnAny() instructs to return an error on any type.\n\t_, err := expr.Compile(`[42, true, \"yes\"][0]`, expr.AsInt(), expr.WarnOnAny())\n\n\tfmt.Printf(\"%v\", err)\n\n\t// Output: expected int, but got interface {}\n}\n\nfunc ExampleOperator() {\n\tcode := `\n\t\tNow() > CreatedAt &&\n\t\t(Now() - CreatedAt).Hours() > 24\n\t`\n\n\ttype Env struct {\n\t\tCreatedAt time.Time\n\t\tNow       func() time.Time\n\t\tSub       func(a, b time.Time) time.Duration\n\t\tAfter     func(a, b time.Time) bool\n\t}\n\n\toptions := []expr.Option{\n\t\texpr.Env(Env{}),\n\t\texpr.Operator(\">\", \"After\"),\n\t\texpr.Operator(\"-\", \"Sub\"),\n\t}\n\n\tprogram, err := expr.Compile(code, options...)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\tenv := Env{\n\t\tCreatedAt: time.Date(2018, 7, 14, 0, 0, 0, 0, time.UTC),\n\t\tNow:       func() time.Time { return time.Now() },\n\t\tSub:       func(a, b time.Time) time.Duration { return a.Sub(b) },\n\t\tAfter:     func(a, b time.Time) bool { return a.After(b) },\n\t}\n\n\toutput, err := expr.Run(program, env)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%v\", output)\n\n\t// Output: true\n}\n\nfunc ExampleOperator_Decimal() {\n\ttype Decimal struct{ N float64 }\n\tcode := `A + B - C`\n\n\ttype Env struct {\n\t\tA, B, C Decimal\n\t\tSub     func(a, b Decimal) Decimal\n\t\tAdd     func(a, b Decimal) Decimal\n\t}\n\n\toptions := []expr.Option{\n\t\texpr.Env(Env{}),\n\t\texpr.Operator(\"+\", \"Add\"),\n\t\texpr.Operator(\"-\", \"Sub\"),\n\t}\n\n\tprogram, err := expr.Compile(code, options...)\n\tif err != nil {\n\t\tfmt.Printf(\"Compile error: %v\", err)\n\t\treturn\n\t}\n\n\tenv := Env{\n\t\tA:   Decimal{3},\n\t\tB:   Decimal{2},\n\t\tC:   Decimal{1},\n\t\tSub: func(a, b Decimal) Decimal { return Decimal{a.N - b.N} },\n\t\tAdd: func(a, b Decimal) Decimal { return Decimal{a.N + b.N} },\n\t}\n\n\toutput, err := expr.Run(program, env)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%v\", output)\n\n\t// Output: {4}\n}\n\nfunc fib(n int) int {\n\tif n <= 1 {\n\t\treturn n\n\t}\n\treturn fib(n-1) + fib(n-2)\n}\n\nfunc ExampleConstExpr() {\n\tcode := `[fib(5), fib(3+3), fib(dyn)]`\n\n\tenv := map[string]any{\n\t\t\"fib\": fib,\n\t\t\"dyn\": 0,\n\t}\n\n\toptions := []expr.Option{\n\t\texpr.Env(env),\n\t\texpr.ConstExpr(\"fib\"), // Mark fib func as constant expression.\n\t}\n\n\tprogram, err := expr.Compile(code, options...)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\t// Only fib(5) and fib(6) calculated on Compile, fib(dyn) can be called at runtime.\n\tenv[\"dyn\"] = 7\n\n\toutput, err := expr.Run(program, env)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%v\\n\", output)\n\n\t// Output: [5 8 13]\n}\n\nfunc ExampleAllowUndefinedVariables() {\n\tcode := `name == nil ? \"Hello, world!\" : sprintf(\"Hello, %v!\", name)`\n\n\tenv := map[string]any{\n\t\t\"sprintf\": fmt.Sprintf,\n\t}\n\n\toptions := []expr.Option{\n\t\texpr.Env(env),\n\t\texpr.AllowUndefinedVariables(), // Allow to use undefined variables.\n\t}\n\n\tprogram, err := expr.Compile(code, options...)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\toutput, err := expr.Run(program, env)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"%v\\n\", output)\n\n\tenv[\"name\"] = \"you\" // Define variables later on.\n\n\toutput, err = expr.Run(program, env)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"%v\\n\", output)\n\n\t// Output: Hello, world!\n\t// Hello, you!\n}\n\nfunc ExampleAllowUndefinedVariables_zero_value() {\n\tcode := `name == \"\" ? foo + bar : foo + name`\n\n\t// If environment has different zero values, then undefined variables\n\t// will have it as default value.\n\tenv := map[string]string{}\n\n\toptions := []expr.Option{\n\t\texpr.Env(env),\n\t\texpr.AllowUndefinedVariables(), // Allow to use undefined variables.\n\t}\n\n\tprogram, err := expr.Compile(code, options...)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\tenv = map[string]string{\n\t\t\"foo\": \"Hello, \",\n\t\t\"bar\": \"world!\",\n\t}\n\n\toutput, err := expr.Run(program, env)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"%v\", output)\n\n\t// Output: Hello, world!\n}\n\nfunc ExampleAllowUndefinedVariables_zero_value_functions() {\n\tcode := `words == \"\" ? Split(\"foo,bar\", \",\") : Split(words, \",\")`\n\n\t// Env is map[string]string type on which methods are defined.\n\tenv := mock.MapStringStringEnv{}\n\n\toptions := []expr.Option{\n\t\texpr.Env(env),\n\t\texpr.AllowUndefinedVariables(), // Allow to use undefined variables.\n\t}\n\n\tprogram, err := expr.Compile(code, options...)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\toutput, err := expr.Run(program, env)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"%v\", output)\n\n\t// Output: [foo bar]\n}\n\ntype patcher struct{}\n\nfunc (p *patcher) Visit(node *ast.Node) {\n\tswitch n := (*node).(type) {\n\tcase *ast.MemberNode:\n\t\tast.Patch(node, &ast.CallNode{\n\t\t\tCallee:    &ast.IdentifierNode{Value: \"get\"},\n\t\t\tArguments: []ast.Node{n.Node, n.Property},\n\t\t})\n\t}\n}\n\nfunc ExamplePatch() {\n\t/*\n\t\ttype patcher struct{}\n\n\t\tfunc (p *patcher) Visit(node *ast.Node) {\n\t\t\tswitch n := (*node).(type) {\n\t\t\tcase *ast.MemberNode:\n\t\t\t\tast.Patch(node, &ast.CallNode{\n\t\t\t\t\tCallee:    &ast.IdentifierNode{Value: \"get\"},\n\t\t\t\t\tArguments: []ast.Node{n.Node, n.Property},\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t*/\n\n\tprogram, err := expr.Compile(\n\t\t`greet.you.world + \"!\"`,\n\t\texpr.Patch(&patcher{}),\n\t)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\tenv := map[string]any{\n\t\t\"greet\": \"Hello\",\n\t\t\"get\": func(a, b string) string {\n\t\t\treturn a + \", \" + b\n\t\t},\n\t}\n\n\toutput, err := expr.Run(program, env)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"%v\", output)\n\n\t// Output : Hello, you, world!\n}\n\nfunc ExampleWithContext() {\n\tenv := map[string]any{\n\t\t\"fn\": func(ctx context.Context, _, _ int) int {\n\t\t\t// An infinite loop that can be canceled by context.\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn 42\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"ctx\": context.TODO(), // Context should be passed as a variable.\n\t}\n\n\tprogram, err := expr.Compile(`fn(1, 2)`,\n\t\texpr.Env(env),\n\t\texpr.WithContext(\"ctx\"), // Pass context variable name.\n\t)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\t// Cancel context after 100 milliseconds.\n\tctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*100)\n\tdefer cancel()\n\n\t// After program is compiled, context can be passed to Run.\n\tenv[\"ctx\"] = ctx\n\n\t// Run will return 42 after 100 milliseconds.\n\toutput, err := expr.Run(program, env)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%v\", output)\n\t// Output: 42\n}\n\nfunc ExampleWithTimezone() {\n\tprogram, err := expr.Compile(`now().Location().String()`, expr.Timezone(\"Asia/Kamchatka\"))\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\toutput, err := expr.Run(program, nil)\n\tif err != nil {\n\t\tfmt.Printf(\"%v\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"%v\", output)\n\t// Output: Asia/Kamchatka\n}\n\nfunc TestExpr_readme_example(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"greet\":   \"Hello, %v!\",\n\t\t\"names\":   []string{\"world\", \"you\"},\n\t\t\"sprintf\": fmt.Sprintf,\n\t}\n\n\tcode := `sprintf(greet, names[0])`\n\n\tprogram, err := expr.Compile(code, expr.Env(env))\n\trequire.NoError(t, err)\n\n\toutput, err := expr.Run(program, env)\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, \"Hello, world!\", output)\n}\n\nfunc TestExpr(t *testing.T) {\n\tdate := time.Date(2017, time.October, 23, 18, 30, 0, 0, time.UTC)\n\toneDay, _ := time.ParseDuration(\"24h\")\n\ttimeNowPlusOneDay := date.Add(oneDay)\n\n\tenv := mock.Env{\n\t\tEmbed:     mock.Embed{},\n\t\tAmbiguous: \"\",\n\t\tAny:       nil,\n\t\tBool:      true,\n\t\tFloat:     0,\n\t\tInt64:     0,\n\t\tInt32:     0,\n\t\tInt:       0,\n\t\tOne:       1,\n\t\tTwo:       2,\n\t\tUint32:    0,\n\t\tString:    \"string\",\n\t\tBoolPtr:   nil,\n\t\tFloatPtr:  nil,\n\t\tIntPtr:    nil,\n\t\tIntPtrPtr: nil,\n\t\tStringPtr: nil,\n\t\tFoo: mock.Foo{\n\t\t\tValue: \"foo\",\n\t\t\tBar: mock.Bar{\n\t\t\t\tBaz: \"baz\",\n\t\t\t},\n\t\t},\n\t\tAbstract:           nil,\n\t\tArrayOfAny:         nil,\n\t\tArrayOfInt:         []int{1, 2, 3, 4, 5},\n\t\tArrayOfFoo:         []*mock.Foo{{Value: \"foo\"}, {Value: \"bar\"}, {Value: \"baz\"}},\n\t\tMapOfFoo:           nil,\n\t\tMapOfAny:           nil,\n\t\tFuncParam:          nil,\n\t\tFuncParamAny:       nil,\n\t\tFuncTooManyReturns: nil,\n\t\tFuncNamed:          nil,\n\t\tNilAny:             nil,\n\t\tNilFn:              nil,\n\t\tNilStruct:          nil,\n\t\tVariadic: func(head int, xs ...int) bool {\n\t\t\tsum := 0\n\t\t\tfor _, x := range xs {\n\t\t\t\tsum += x\n\t\t\t}\n\t\t\treturn head == sum\n\t\t},\n\t\tFast:        nil,\n\t\tTime:        date,\n\t\tTimePlusDay: timeNowPlusOneDay,\n\t\tDuration:    oneDay,\n\t}\n\n\ttests := []struct {\n\t\tcode string\n\t\twant any\n\t}{\n\t\t{\n\t\t\t`1`,\n\t\t\t1,\n\t\t},\n\t\t{\n\t\t\t`-.5`,\n\t\t\t-.5,\n\t\t},\n\t\t{\n\t\t\t`true && false || false`,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t`Int == 0 && Int32 == 0 && Int64 == 0 && Float64 == 0 && Bool && String == \"string\"`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`-Int64 == 0`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`\"a\" != \"b\"`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`\"a\" != \"b\" || 1 == 2`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`Int + 0`,\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t`Uint64 + 0`,\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t`Uint64 + Int64`,\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t`Int32 + Int64`,\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t`Float64 + 0`,\n\t\t\tfloat64(0),\n\t\t},\n\t\t{\n\t\t\t`0 + Float64`,\n\t\t\tfloat64(0),\n\t\t},\n\t\t{\n\t\t\t`0 <= Float64`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`Float64 < 1`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`Int < 1`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`2 + 2 == 4`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`8 % 3`,\n\t\t\t2,\n\t\t},\n\t\t{\n\t\t\t`2 ** 8`,\n\t\t\tfloat64(256),\n\t\t},\n\t\t{\n\t\t\t`2 ^ 8`,\n\t\t\tfloat64(256),\n\t\t},\n\t\t{\n\t\t\t`-(2-5)**3-2/(+4-3)+-2`,\n\t\t\tfloat64(23),\n\t\t},\n\t\t{\n\t\t\t`\"hello\" + \" \" + \"world\"`,\n\t\t\t\"hello world\",\n\t\t},\n\t\t{\n\t\t\t`0 in -1..1 and 1 in 1..1`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`Int in 0..1`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`Int32 in 0..1`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`Int64 in 0..1`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`1 in [1, 2, 3] && \"foo\" in {foo: 0, bar: 1} && \"Bar\" in Foo`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`1 in [1.5] || 1 not in [1]`,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t`One in 0..1 && Two not in 0..1`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`Two not in 0..1`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`Two not    in 0..1`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`-1 not in [1]`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`Int32 in [10, 20]`,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t`String matches \"s.+\"`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`String matches (\"^\" + String + \"$\")`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`'foo' + 'bar' not matches 'foobar'`,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t`\"foobar\" contains \"bar\"`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`\"foobar\" startsWith \"foo\"`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`\"foobar\" endsWith \"bar\"`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`(0..10)[5]`,\n\t\t\t5,\n\t\t},\n\t\t{\n\t\t\t`Foo.Bar.Baz`,\n\t\t\t\"baz\",\n\t\t},\n\t\t{\n\t\t\t`Add(10, 5) + GetInt()`,\n\t\t\t15,\n\t\t},\n\t\t{\n\t\t\t`Foo.Method().Baz`,\n\t\t\t`baz (from Foo.Method)`,\n\t\t},\n\t\t{\n\t\t\t`Foo.MethodWithArgs(\"prefix \")`,\n\t\t\t\"prefix foo\",\n\t\t},\n\t\t{\n\t\t\t`len([1, 2, 3])`,\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t`len([1, Two, 3])`,\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t`len([\"hello\", \"world\"])`,\n\t\t\t2,\n\t\t},\n\t\t{\n\t\t\t`len(\"hello, world\")`,\n\t\t\t12,\n\t\t},\n\t\t{\n\t\t\t`len(ArrayOfInt)`,\n\t\t\t5,\n\t\t},\n\t\t{\n\t\t\t`len({a: 1, b: 2, c: 2})`,\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t`max([1, 2, 3])`,\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t`max(1, 2, 3)`,\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t`min([1, 2, 3])`,\n\t\t\t1,\n\t\t},\n\t\t{\n\t\t\t`min(1, 2, 3)`,\n\t\t\t1,\n\t\t},\n\t\t{\n\t\t\t`{foo: 0, bar: 1}`,\n\t\t\tmap[string]any{\"foo\": 0, \"bar\": 1},\n\t\t},\n\t\t{\n\t\t\t`{foo: 0, bar: 1}`,\n\t\t\tmap[string]any{\"foo\": 0, \"bar\": 1},\n\t\t},\n\t\t{\n\t\t\t`(true ? 0+1 : 2+3) + (false ? -1 : -2)`,\n\t\t\t-1,\n\t\t},\n\t\t{\n\t\t\t`filter(1..9, {# > 7})`,\n\t\t\t[]any{8, 9},\n\t\t},\n\t\t{\n\t\t\t`map(1..3, {# * #})`,\n\t\t\t[]any{1, 4, 9},\n\t\t},\n\t\t{\n\t\t\t`all(1..3, {# > 0})`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`count(1..30, {# % 3 == 0})`,\n\t\t\t10,\n\t\t},\n\t\t{\n\t\t\t`count([true, true, false])`,\n\t\t\t2,\n\t\t},\n\t\t{\n\t\t\t`\"a\" < \"b\"`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`Time.Sub(Time).String() == \"0s\"`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`1 + 1`,\n\t\t\t2,\n\t\t},\n\t\t{\n\t\t\t`(One * Two) * 3 == One * (Two * 3)`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`ArrayOfInt[1]`,\n\t\t\t2,\n\t\t},\n\t\t{\n\t\t\t`ArrayOfInt[0] < ArrayOfInt[1]`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`ArrayOfInt[-1]`,\n\t\t\t5,\n\t\t},\n\t\t{\n\t\t\t`ArrayOfInt[1:2]`,\n\t\t\t[]int{2},\n\t\t},\n\t\t{\n\t\t\t`ArrayOfInt[1:4]`,\n\t\t\t[]int{2, 3, 4},\n\t\t},\n\t\t{\n\t\t\t`ArrayOfInt[-4:-1]`,\n\t\t\t[]int{2, 3, 4},\n\t\t},\n\t\t{\n\t\t\t`ArrayOfInt[:3]`,\n\t\t\t[]int{1, 2, 3},\n\t\t},\n\t\t{\n\t\t\t`ArrayOfInt[3:]`,\n\t\t\t[]int{4, 5},\n\t\t},\n\t\t{\n\t\t\t`ArrayOfInt[0:5] == ArrayOfInt`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`ArrayOfInt[0:] == ArrayOfInt`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`ArrayOfInt[:5] == ArrayOfInt`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`ArrayOfInt[:] == ArrayOfInt`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`4 in 5..1`,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t`4..0`,\n\t\t\t[]int{},\n\t\t},\n\t\t{\n\t\t\t`NilStruct`,\n\t\t\t(*mock.Foo)(nil),\n\t\t},\n\t\t{\n\t\t\t`NilAny == nil && nil == NilAny && nil == nil && NilAny == NilAny && NilInt == nil && NilSlice == nil && NilStruct == nil`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`0 == nil || \"str\" == nil || true == nil`,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t`Variadic(6, 1, 2, 3)`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`Variadic(0)`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`String[:]`,\n\t\t\t\"string\",\n\t\t},\n\t\t{\n\t\t\t`String[:3]`,\n\t\t\t\"str\",\n\t\t},\n\t\t{\n\t\t\t`String[:9]`,\n\t\t\t\"string\",\n\t\t},\n\t\t{\n\t\t\t`String[3:9]`,\n\t\t\t\"ing\",\n\t\t},\n\t\t{\n\t\t\t`String[7:9]`,\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t`map(filter(ArrayOfInt, # >= 3), # + 1)`,\n\t\t\t[]any{4, 5, 6},\n\t\t},\n\t\t{\n\t\t\t`Time < Time + Duration`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`Time + Duration > Time`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`Time == Time`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`Time >= Time`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`Time <= Time`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`Time == Time + Duration`,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t`Time != Time`,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t`TimePlusDay - Duration`,\n\t\t\tdate,\n\t\t},\n\t\t{\n\t\t\t`duration(\"1h\") == duration(\"1h\")`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`TimePlusDay - Time >= duration(\"24h\")`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`duration(\"1h\") > duration(\"1m\")`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`duration(\"1h\") < duration(\"1m\")`,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t`duration(\"1h\") >= duration(\"1m\")`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`duration(\"1h\") <= duration(\"1m\")`,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t`duration(\"1h\") > duration(\"1m\")`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`duration(\"1h\") + duration(\"1m\")`,\n\t\t\ttime.Hour + time.Minute,\n\t\t},\n\t\t{\n\t\t\t`7 * duration(\"1h\")`,\n\t\t\t7 * time.Hour,\n\t\t},\n\t\t{\n\t\t\t`duration(\"1h\") * 7`,\n\t\t\t7 * time.Hour,\n\t\t},\n\t\t{\n\t\t\t`duration(\"1s\") * .5`,\n\t\t\t5e8,\n\t\t},\n\t\t{\n\t\t\t`1 /* one */ + 2 // two`,\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t`let x = 1; x + 2`,\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t`map(1..3, let x = #; let y = x * x; y * y)`,\n\t\t\t[]any{1, 16, 81},\n\t\t},\n\t\t{\n\t\t\t`map(1..2, let x = #; map(2..3, let y = #; x + y))`,\n\t\t\t[]any{[]any{3, 4}, []any{4, 5}},\n\t\t},\n\t\t{\n\t\t\t`len(filter(1..99, # % 7 == 0))`,\n\t\t\t14,\n\t\t},\n\t\t{\n\t\t\t`find(ArrayOfFoo, .Value == \"baz\")`,\n\t\t\tenv.ArrayOfFoo[2],\n\t\t},\n\t\t{\n\t\t\t`findIndex(ArrayOfFoo, .Value == \"baz\")`,\n\t\t\t2,\n\t\t},\n\t\t{\n\t\t\t`filter(ArrayOfFoo, .Value == \"baz\")[0]`,\n\t\t\tenv.ArrayOfFoo[2],\n\t\t},\n\t\t{\n\t\t\t`first(filter(ArrayOfFoo, .Value == \"baz\"))`,\n\t\t\tenv.ArrayOfFoo[2],\n\t\t},\n\t\t{\n\t\t\t`first(filter(ArrayOfFoo, false))`,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t`findLast(1..9, # % 2 == 0)`,\n\t\t\t8,\n\t\t},\n\t\t{\n\t\t\t`findLastIndex(1..9, # % 2 == 0)`,\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t`filter(1..9, # % 2 == 0)[-1]`,\n\t\t\t8,\n\t\t},\n\t\t{\n\t\t\t`last(filter(1..9, # % 2 == 0))`,\n\t\t\t8,\n\t\t},\n\t\t{\n\t\t\t`map(filter(1..9, # % 2 == 0), # * 2)`,\n\t\t\t[]any{4, 8, 12, 16},\n\t\t},\n\t\t{\n\t\t\t`map(map(filter(1..9, # % 2 == 0), # * 2), # * 2)`,\n\t\t\t[]any{8, 16, 24, 32},\n\t\t},\n\t\t{\n\t\t\t`first(map(filter(1..9, # % 2 == 0), # * 2))`,\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t`map(filter(1..9, # % 2 == 0), # * 2)[-1]`,\n\t\t\t16,\n\t\t},\n\t\t{\n\t\t\t`len(map(filter(1..9, # % 2 == 0), # * 2))`,\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t`len(filter(map(1..9, # * 2), # % 2 == 0))`,\n\t\t\t9,\n\t\t},\n\t\t{\n\t\t\t`first(filter(map(1..9, # * 2), # % 2 == 0))`,\n\t\t\t2,\n\t\t},\n\t\t{\n\t\t\t`first(map(filter(1..9, # % 2 == 0), # * 2))`,\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t`2^3 == 8`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`4/2 == 2`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`.5 in 0..1`,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t`.5 in ArrayOfInt`,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t`bitnot(10)`,\n\t\t\t-11,\n\t\t},\n\t\t{\n\t\t\t`bitxor(15, 32)`,\n\t\t\t47,\n\t\t},\n\t\t{\n\t\t\t`bitand(90, 34)`,\n\t\t\t2,\n\t\t},\n\t\t{\n\t\t\t`bitnand(35, 9)`,\n\t\t\t34,\n\t\t},\n\t\t{\n\t\t\t`bitor(10, 5)`,\n\t\t\t15,\n\t\t},\n\t\t{\n\t\t\t`bitshr(7, 2)`,\n\t\t\t1,\n\t\t},\n\t\t{\n\t\t\t`bitshl(7, 2)`,\n\t\t\t28,\n\t\t},\n\t\t{\n\t\t\t`bitushr(-100, 5)`,\n\t\t\t576460752303423484,\n\t\t},\n\t\t{\n\t\t\t`\"hello\"[1:3]`,\n\t\t\t\"el\",\n\t\t},\n\t\t{\n\t\t\t`[1, 2, 3]?.[0]`,\n\t\t\t1,\n\t\t},\n\t\t{\n\t\t\t`[[1, 2], 3, 4]?.[0]?.[1]`,\n\t\t\t2,\n\t\t},\n\t\t{\n\t\t\t`[nil, 3, 4]?.[0]?.[1]`,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t`1 > 2 < 3`,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t`1 < 2 < 3`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`1 < 2 < 3 > 4`,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t`1 < 2 < 3 > 2`,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t`1 < 2 < 3 == true`,\n\t\t\ttrue,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.code, func(t *testing.T) {\n\t\t\t{\n\t\t\t\tprogram, err := expr.Compile(tt.code, expr.Env(mock.Env{}))\n\t\t\t\trequire.NoError(t, err, \"compile error\")\n\n\t\t\t\tgot, err := expr.Run(program, env)\n\t\t\t\trequire.NoError(t, err, \"run error\")\n\t\t\t\tassert.Equal(t, tt.want, got)\n\t\t\t}\n\t\t\t{\n\t\t\t\tprogram, err := expr.Compile(tt.code, expr.Optimize(false))\n\t\t\t\trequire.NoError(t, err, \"unoptimized\")\n\n\t\t\t\tgot, err := expr.Run(program, env)\n\t\t\t\trequire.NoError(t, err, \"unoptimized\")\n\t\t\t\tassert.Equal(t, tt.want, got, \"unoptimized\")\n\t\t\t}\n\t\t\t{\n\t\t\t\tgot, err := expr.Eval(tt.code, env)\n\t\t\t\trequire.NoError(t, err, \"eval\")\n\t\t\t\tassert.Equal(t, tt.want, got, \"eval\")\n\t\t\t}\n\t\t\t{\n\t\t\t\tprogram, err := expr.Compile(tt.code, expr.Env(mock.Env{}), expr.Optimize(false))\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tcode := program.Node().String()\n\t\t\t\tgot, err := expr.Eval(code, env)\n\t\t\t\trequire.NoError(t, err, code)\n\t\t\t\tassert.Equal(t, tt.want, got, code)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExpr_error(t *testing.T) {\n\tenv := mock.Env{\n\t\tArrayOfAny: []any{1, \"2\", 3, true},\n\t}\n\n\ttests := []struct {\n\t\tcode string\n\t\twant string\n\t}{\n\t\t{\n\t\t\t`filter(1..9, # > 9)[0]`,\n\t\t\t`reflect: slice index out of range (1:20)\n | filter(1..9, # > 9)[0]\n | ...................^`,\n\t\t},\n\t\t{\n\t\t\t`ArrayOfAny[-7]`,\n\t\t\t`index out of range: -3 (array length is 4) (1:11)\n | ArrayOfAny[-7]\n | ..........^`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.code, func(t *testing.T) {\n\t\t\tprogram, err := expr.Compile(tt.code, expr.Env(mock.Env{}))\n\t\t\trequire.NoError(t, err)\n\n\t\t\t_, err = expr.Run(program, env)\n\t\t\trequire.Error(t, err)\n\t\t\tassert.Equal(t, tt.want, err.Error())\n\t\t})\n\t}\n}\n\nfunc TestExpr_optional_chaining(t *testing.T) {\n\tenv := map[string]any{}\n\tprogram, err := expr.Compile(\"foo?.bar.baz\", expr.Env(env), expr.AllowUndefinedVariables())\n\trequire.NoError(t, err)\n\n\tgot, err := expr.Run(program, env)\n\trequire.NoError(t, err)\n\tassert.Equal(t, nil, got)\n}\n\nfunc TestExpr_optional_chaining_property(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"foo\": map[string]any{},\n\t}\n\tprogram, err := expr.Compile(\"foo.bar?.baz\", expr.Env(env))\n\trequire.NoError(t, err)\n\n\tgot, err := expr.Run(program, env)\n\trequire.NoError(t, err)\n\tassert.Equal(t, nil, got)\n}\n\nfunc TestExpr_optional_chaining_nested_chains(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"foo\": map[string]any{\n\t\t\t\"id\": 1,\n\t\t\t\"bar\": []map[string]any{\n\t\t\t\t1: {\n\t\t\t\t\t\"baz\": \"baz\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tprogram, err := expr.Compile(\"foo?.bar[foo?.id]?.baz\", expr.Env(env))\n\trequire.NoError(t, err)\n\n\tgot, err := expr.Run(program, env)\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"baz\", got)\n}\n\nfunc TestExpr_optional_chaining_array(t *testing.T) {\n\tenv := map[string]any{}\n\tprogram, err := expr.Compile(\"foo?.[1]?.[2]?.[3]\", expr.Env(env), expr.AllowUndefinedVariables())\n\trequire.NoError(t, err)\n\n\tgot, err := expr.Run(program, env)\n\trequire.NoError(t, err)\n\tassert.Equal(t, nil, got)\n}\n\nfunc TestExpr_eval_with_env(t *testing.T) {\n\t_, err := expr.Eval(\"true\", expr.Env(map[string]any{}))\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"misused\")\n}\n\nfunc TestExpr_fetch_from_func(t *testing.T) {\n\t_, err := expr.Eval(\"foo.Value\", map[string]any{\n\t\t\"foo\": func() {},\n\t})\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"cannot fetch Value from func()\")\n}\n\nfunc TestExpr_map_default_values(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"foo\": map[string]string{},\n\t\t\"bar\": map[string]*string{},\n\t}\n\n\tinput := `foo['missing'] == '' && bar['missing'] == nil`\n\n\tprogram, err := expr.Compile(input, expr.Env(env))\n\trequire.NoError(t, err)\n\n\toutput, err := expr.Run(program, env)\n\trequire.NoError(t, err)\n\trequire.Equal(t, true, output)\n}\n\nfunc TestExpr_map_default_values_compile_check(t *testing.T) {\n\ttests := []struct {\n\t\tenv   any\n\t\tinput string\n\t}{\n\t\t{\n\t\t\tmock.MapStringStringEnv{\"foo\": \"bar\"},\n\t\t\t`Split(foo, sep)`,\n\t\t},\n\t\t{\n\t\t\tmock.MapStringIntEnv{\"foo\": 1},\n\t\t\t`foo / bar`,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\t_, err := expr.Compile(tt.input, expr.Env(tt.env), expr.AllowUndefinedVariables())\n\t\trequire.NoError(t, err)\n\t}\n}\n\nfunc TestExpr_calls_with_nil(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"equals\": func(a, b any) any {\n\t\t\tassert.Nil(t, a, \"a is not nil\")\n\t\t\tassert.Nil(t, b, \"b is not nil\")\n\t\t\treturn a == b\n\t\t},\n\t\t\"is\": mock.Is{},\n\t}\n\n\tp, err := expr.Compile(\n\t\t\"a == nil && equals(b, nil) && is.Nil(c)\",\n\t\texpr.Env(env),\n\t\texpr.Operator(\"==\", \"equals\"),\n\t\texpr.AllowUndefinedVariables(),\n\t)\n\trequire.NoError(t, err)\n\n\tout, err := expr.Run(p, env)\n\trequire.NoError(t, err)\n\trequire.Equal(t, true, out)\n}\n\nfunc TestExpr_call_float_arg_func_with_int(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"cnv\": func(f float64) any {\n\t\t\treturn f\n\t\t},\n\t}\n\ttests := []struct {\n\t\tinput    string\n\t\texpected float64\n\t}{\n\t\t{\"-1\", -1.0},\n\t\t{\"1+1\", 2.0},\n\t\t{\"+1\", 1.0},\n\t\t{\"1-1\", 0.0},\n\t\t{\"1/1\", 1.0},\n\t\t{\"1*1\", 1.0},\n\t\t{\"1^1\", 1.0},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tp, err := expr.Compile(fmt.Sprintf(\"cnv(%s)\", tt.input), expr.Env(env))\n\t\t\trequire.NoError(t, err)\n\n\t\t\tout, err := expr.Run(p, env)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, tt.expected, out)\n\t\t})\n\t}\n}\n\nfunc TestConstExpr_error_panic(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"divide\": func(a, b int) int { return a / b },\n\t}\n\n\t_, err := expr.Compile(\n\t\t`1 + divide(1, 0)`,\n\t\texpr.Env(env),\n\t\texpr.ConstExpr(\"divide\"),\n\t)\n\trequire.Error(t, err)\n\trequire.Equal(t, \"compile error: integer divide by zero (1:5)\\n | 1 + divide(1, 0)\\n | ....^\", err.Error())\n}\n\ntype divideError struct{ Message string }\n\nfunc (e divideError) Error() string {\n\treturn e.Message\n}\n\nfunc TestConstExpr_error_as_error(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"divide\": func(a, b int) (int, error) {\n\t\t\tif b == 0 {\n\t\t\t\treturn 0, divideError{\"integer divide by zero\"}\n\t\t\t}\n\t\t\treturn a / b, nil\n\t\t},\n\t}\n\n\t_, err := expr.Compile(\n\t\t`1 + divide(1, 0)`,\n\t\texpr.Env(env),\n\t\texpr.ConstExpr(\"divide\"),\n\t)\n\trequire.Error(t, err)\n\trequire.Equal(t, \"integer divide by zero\", err.Error())\n\trequire.IsType(t, divideError{}, err)\n}\n\nfunc TestConstExpr_error_wrong_type(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"divide\": 0,\n\t}\n\tassert.Panics(t, func() {\n\t\t_, _ = expr.Compile(\n\t\t\t`1 + divide(1, 0)`,\n\t\t\texpr.Env(env),\n\t\t\texpr.ConstExpr(\"divide\"),\n\t\t)\n\t})\n}\n\nfunc TestConstExpr_error_no_env(t *testing.T) {\n\tassert.Panics(t, func() {\n\t\t_, _ = expr.Compile(\n\t\t\t`1 + divide(1, 0)`,\n\t\t\texpr.ConstExpr(\"divide\"),\n\t\t)\n\t})\n}\n\nvar stringer = reflect.TypeOf((*fmt.Stringer)(nil)).Elem()\n\ntype stringerPatcher struct{}\n\nfunc (p *stringerPatcher) Visit(node *ast.Node) {\n\tt := (*node).Type()\n\tif t == nil {\n\t\treturn\n\t}\n\tif t.Implements(stringer) {\n\t\tast.Patch(node, &ast.CallNode{\n\t\t\tCallee: &ast.MemberNode{\n\t\t\t\tNode:     *node,\n\t\t\t\tProperty: &ast.StringNode{Value: \"String\"},\n\t\t\t},\n\t\t})\n\t}\n}\n\nfunc TestPatch(t *testing.T) {\n\tprogram, err := expr.Compile(\n\t\t`Foo == \"Foo.String\"`,\n\t\texpr.Env(mock.Env{}),\n\t\texpr.Patch(&mock.StringerPatcher{}),\n\t)\n\trequire.NoError(t, err)\n\n\toutput, err := expr.Run(program, mock.Env{})\n\trequire.NoError(t, err)\n\trequire.Equal(t, true, output)\n}\n\nfunc TestCompile_exposed_error(t *testing.T) {\n\t_, err := expr.Compile(`1 == true`)\n\trequire.Error(t, err)\n\n\tfileError, ok := err.(*file.Error)\n\trequire.True(t, ok, \"error should be of type *file.Error\")\n\trequire.Equal(t, \"invalid operation: == (mismatched types int and bool) (1:3)\\n | 1 == true\\n | ..^\", fileError.Error())\n\trequire.Equal(t, 2, fileError.Column)\n\trequire.Equal(t, 1, fileError.Line)\n\n\tb, err := json.Marshal(err)\n\trequire.NoError(t, err)\n\trequire.Equal(t,\n\t\t`{\"from\":2,\"to\":4,\"line\":1,\"column\":2,\"message\":\"invalid operation: == (mismatched types int and bool)\",\"snippet\":\"\\n | 1 == true\\n | ..^\",\"prev\":null}`,\n\t\tstring(b),\n\t)\n}\n\nfunc TestAsBool_exposed_error(t *testing.T) {\n\t_, err := expr.Compile(`42`, expr.AsBool())\n\trequire.Error(t, err)\n\n\t_, ok := err.(*file.Error)\n\trequire.False(t, ok, \"error must not be of type *file.Error\")\n\trequire.Equal(t, \"expected bool, but got int\", err.Error())\n}\n\nfunc TestEval_exposed_error(t *testing.T) {\n\t_, err := expr.Eval(`1 % 0`, nil)\n\trequire.Error(t, err)\n\n\tfileError, ok := err.(*file.Error)\n\trequire.True(t, ok, \"error should be of type *file.Error\")\n\trequire.Equal(t, \"integer divide by zero (1:3)\\n | 1 % 0\\n | ..^\", fileError.Error())\n\trequire.Equal(t, 2, fileError.Column)\n\trequire.Equal(t, 1, fileError.Line)\n}\n\nfunc TestIssue105(t *testing.T) {\n\ttype A struct {\n\t\tField string\n\t}\n\ttype B struct {\n\t\tField int\n\t}\n\ttype C struct {\n\t\tA\n\t\tB\n\t}\n\ttype Env struct {\n\t\tC\n\t}\n\n\tcode := `\n\t\tA.Field == '' &&\n\t\tC.A.Field == '' &&\n\t\tB.Field == 0 &&\n\t\tC.B.Field == 0\n\t`\n\n\t_, err := expr.Compile(code, expr.Env(Env{}))\n\trequire.NoError(t, err)\n}\n\nfunc TestIssue_nested_closures(t *testing.T) {\n\tcode := `all(1..3, { all(1..3, { # > 0 }) and # > 0 })`\n\n\tprogram, err := expr.Compile(code)\n\trequire.NoError(t, err)\n\n\toutput, err := expr.Run(program, nil)\n\trequire.NoError(t, err)\n\trequire.True(t, output.(bool))\n}\n\nfunc TestIssue138(t *testing.T) {\n\tenv := map[string]any{}\n\n\t_, err := expr.Compile(`1 / (1 - 1)`, expr.Env(env))\n\trequire.NoError(t, err)\n\n\t_, err = expr.Compile(`1 % 0`, expr.Env(env))\n\trequire.Error(t, err)\n\trequire.Equal(t, \"integer divide by zero (1:3)\\n | 1 % 0\\n | ..^\", err.Error())\n}\n\nfunc TestIssue154(t *testing.T) {\n\ttype Data struct {\n\t\tArray  *[2]any\n\t\tSlice  *[]any\n\t\tMap    *map[string]any\n\t\tString *string\n\t}\n\n\ttype Env struct {\n\t\tData *Data\n\t}\n\n\tb := true\n\ti := 10\n\ts := \"value\"\n\n\tArray := [2]any{\n\t\t&b,\n\t\t&i,\n\t}\n\n\tSlice := []any{\n\t\t&b,\n\t\t&i,\n\t}\n\n\tMap := map[string]any{\n\t\t\"Bool\": &b,\n\t\t\"Int\":  &i,\n\t}\n\n\tenv := Env{\n\t\tData: &Data{\n\t\t\tArray:  &Array,\n\t\t\tSlice:  &Slice,\n\t\t\tMap:    &Map,\n\t\t\tString: &s,\n\t\t},\n\t}\n\n\ttests := []string{\n\t\t`Data.Array[0] == true`,\n\t\t`Data.Array[1] == 10`,\n\t\t`Data.Slice[0] == true`,\n\t\t`Data.Slice[1] == 10`,\n\t\t`Data.Map[\"Bool\"] == true`,\n\t\t`Data.Map[\"Int\"] == 10`,\n\t\t`Data.String == \"value\"`,\n\t}\n\n\tfor _, input := range tests {\n\t\tprogram, err := expr.Compile(input, expr.Env(env))\n\t\trequire.NoError(t, err, input)\n\n\t\toutput, err := expr.Run(program, env)\n\t\trequire.NoError(t, err)\n\t\tassert.True(t, output.(bool), input)\n\t}\n}\n\nfunc TestIssue270(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"int8\":     int8(1),\n\t\t\"int16\":    int16(3),\n\t\t\"int32\":    int32(5),\n\t\t\"int64\":    int64(7),\n\t\t\"uint8\":    uint8(11),\n\t\t\"uint16\":   uint16(13),\n\t\t\"uint32\":   uint32(17),\n\t\t\"uint64\":   uint64(19),\n\t\t\"int8a\":    uint(23),\n\t\t\"int8b\":    uint(29),\n\t\t\"int16a\":   uint(31),\n\t\t\"int16b\":   uint(37),\n\t\t\"int32a\":   uint(41),\n\t\t\"int32b\":   uint(43),\n\t\t\"int64a\":   uint(47),\n\t\t\"int64b\":   uint(53),\n\t\t\"uint8a\":   uint(59),\n\t\t\"uint8b\":   uint(61),\n\t\t\"uint16a\":  uint(67),\n\t\t\"uint16b\":  uint(71),\n\t\t\"uint32a\":  uint(73),\n\t\t\"uint32b\":  uint(79),\n\t\t\"uint64a\":  uint(83),\n\t\t\"uint64b\":  uint(89),\n\t\t\"float32a\": float32(97),\n\t\t\"float32b\": float32(101),\n\t\t\"float64a\": float64(103),\n\t\t\"float64b\": float64(107),\n\t}\n\tfor _, each := range []struct {\n\t\tinput string\n\t}{\n\t\t{\"int8 / int16\"},\n\t\t{\"int32 / int64\"},\n\t\t{\"uint8 / uint16\"},\n\t\t{\"uint32 / uint64\"},\n\t\t{\"int8 / uint64\"},\n\t\t{\"int64 / uint8\"},\n\t\t{\"int8a / int8b\"},\n\t\t{\"int16a / int16b\"},\n\t\t{\"int32a / int32b\"},\n\t\t{\"int64a / int64b\"},\n\t\t{\"uint8a / uint8b\"},\n\t\t{\"uint16a / uint16b\"},\n\t\t{\"uint32a / uint32b\"},\n\t\t{\"uint64a / uint64b\"},\n\t\t{\"float32a / float32b\"},\n\t\t{\"float64a / float64b\"},\n\t} {\n\t\tp, err := expr.Compile(each.input, expr.Env(env))\n\t\trequire.NoError(t, err)\n\n\t\tout, err := expr.Run(p, env)\n\t\trequire.NoError(t, err)\n\t\trequire.IsType(t, float64(0), out)\n\t}\n}\n\nfunc TestIssue271(t *testing.T) {\n\ttype BarArray []float64\n\n\ttype Foo struct {\n\t\tBar BarArray\n\t\tBaz int\n\t}\n\n\ttype Env struct {\n\t\tFoo Foo\n\t}\n\n\tcode := `Foo.Bar[0]`\n\n\tprogram, err := expr.Compile(code, expr.Env(Env{}))\n\trequire.NoError(t, err)\n\n\toutput, err := expr.Run(program, Env{\n\t\tFoo: Foo{\n\t\t\tBar: BarArray{1.0, 2.0, 3.0},\n\t\t},\n\t})\n\trequire.NoError(t, err)\n\trequire.Equal(t, 1.0, output)\n}\n\ntype Issue346Array []Issue346Type\n\ntype Issue346Type struct {\n\tBar string\n}\n\nfunc (i Issue346Array) Len() int {\n\treturn len(i)\n}\n\nfunc TestIssue346(t *testing.T) {\n\tcode := `Foo[0].Bar`\n\n\tenv := map[string]any{\n\t\t\"Foo\": Issue346Array{\n\t\t\t{Bar: \"bar\"},\n\t\t},\n\t}\n\tprogram, err := expr.Compile(code, expr.Env(env))\n\trequire.NoError(t, err)\n\n\toutput, err := expr.Run(program, env)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"bar\", output)\n}\n\nfunc TestCompile_allow_to_use_interface_to_get_an_element_from_map(t *testing.T) {\n\tcode := `{\"value\": \"ok\"}[vars.key]`\n\tenv := map[string]any{\n\t\t\"vars\": map[string]any{\n\t\t\t\"key\": \"value\",\n\t\t},\n\t}\n\n\tprogram, err := expr.Compile(code, expr.Env(env))\n\tassert.NoError(t, err)\n\n\tout, err := expr.Run(program, env)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"ok\", out)\n\n\tt.Run(\"with allow undefined variables\", func(t *testing.T) {\n\t\tcode := `{'key': 'value'}[Key]`\n\t\tenv := mock.MapStringStringEnv{}\n\t\toptions := []expr.Option{\n\t\t\texpr.AllowUndefinedVariables(),\n\t\t}\n\n\t\tprogram, err := expr.Compile(code, options...)\n\t\tassert.NoError(t, err)\n\n\t\tout, err := expr.Run(program, env)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, nil, out)\n\t})\n}\n\nfunc TestFastCall(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"func\": func(in any) float64 {\n\t\t\treturn 8\n\t\t},\n\t}\n\tcode := `func(\"8\")`\n\n\tprogram, err := expr.Compile(code, expr.Env(env))\n\tassert.NoError(t, err)\n\n\tout, err := expr.Run(program, env)\n\tassert.NoError(t, err)\n\tassert.Equal(t, float64(8), out)\n}\n\nfunc TestFastCall_OpCallFastErr(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"func\": func(...any) (any, error) {\n\t\t\treturn 8, nil\n\t\t},\n\t}\n\tcode := `func(\"8\")`\n\n\tprogram, err := expr.Compile(code, expr.Env(env))\n\tassert.NoError(t, err)\n\n\tout, err := expr.Run(program, env)\n\tassert.NoError(t, err)\n\tassert.Equal(t, 8, out)\n}\n\nfunc TestRun_custom_func_returns_an_error_as_second_arg(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"semver\": func(value string, cmp string) (bool, error) { return true, nil },\n\t}\n\n\tp, err := expr.Compile(`semver(\"1.2.3\", \"= 1.2.3\")`, expr.Env(env))\n\tassert.NoError(t, err)\n\n\tout, err := expr.Run(p, env)\n\tassert.NoError(t, err)\n\tassert.Equal(t, true, out)\n}\n\nfunc TestFunction(t *testing.T) {\n\tadd := expr.Function(\n\t\t\"add\",\n\t\tfunc(p ...any) (any, error) {\n\t\t\tout := 0\n\t\t\tfor _, each := range p {\n\t\t\t\tout += each.(int)\n\t\t\t}\n\t\t\treturn out, nil\n\t\t},\n\t\tnew(func(...int) int),\n\t)\n\n\tp, err := expr.Compile(`add() + add(1) + add(1, 2) + add(1, 2, 3) + add(1, 2, 3, 4)`, add)\n\tassert.NoError(t, err)\n\n\tout, err := expr.Run(p, nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, 20, out)\n}\n\n// Nil coalescing operator\nfunc TestRun_NilCoalescingOperator(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"foo\": map[string]any{\n\t\t\t\"bar\": \"value\",\n\t\t},\n\t}\n\n\tt.Run(\"value\", func(t *testing.T) {\n\t\tp, err := expr.Compile(`foo.bar ?? \"default\"`, expr.Env(env))\n\t\tassert.NoError(t, err)\n\n\t\tout, err := expr.Run(p, env)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"value\", out)\n\t})\n\n\tt.Run(\"default\", func(t *testing.T) {\n\t\tp, err := expr.Compile(`foo.baz ?? \"default\"`, expr.Env(env))\n\t\tassert.NoError(t, err)\n\n\t\tout, err := expr.Run(p, env)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"default\", out)\n\t})\n\n\tt.Run(\"default with chain\", func(t *testing.T) {\n\t\tp, err := expr.Compile(`foo?.bar ?? \"default\"`, expr.Env(env))\n\t\tassert.NoError(t, err)\n\n\t\tout, err := expr.Run(p, map[string]any{})\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"default\", out)\n\t})\n}\n\nfunc TestEval_nil_in_maps(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"m\":     map[any]any{nil: \"bar\"},\n\t\t\"empty\": map[any]any{},\n\t}\n\tt.Run(\"nil key exists\", func(t *testing.T) {\n\t\tp, err := expr.Compile(`m[nil]`, expr.Env(env))\n\t\tassert.NoError(t, err)\n\n\t\tout, err := expr.Run(p, env)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"bar\", out)\n\t})\n\tt.Run(\"no nil key\", func(t *testing.T) {\n\t\tp, err := expr.Compile(`empty[nil]`, expr.Env(env))\n\t\tassert.NoError(t, err)\n\n\t\tout, err := expr.Run(p, env)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, nil, out)\n\t})\n\tt.Run(\"nil in m\", func(t *testing.T) {\n\t\tp, err := expr.Compile(`nil in m`, expr.Env(env))\n\t\tassert.NoError(t, err)\n\n\t\tout, err := expr.Run(p, env)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, true, out)\n\t})\n\tt.Run(\"nil in empty\", func(t *testing.T) {\n\t\tp, err := expr.Compile(`nil in empty`, expr.Env(env))\n\t\tassert.NoError(t, err)\n\n\t\tout, err := expr.Run(p, env)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, false, out)\n\t})\n}\n\n// Test the use of env keyword.  Forms env[] and env[”] are valid.\n// The enclosed identifier must be in the expression env.\nfunc TestEnv_keyword(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"space test\":                       \"ok\",\n\t\t\"space_test\":                       \"not ok\", // Seems to be some underscore substituting happening, check that.\n\t\t\"Section 1-2a\":                     \"ok\",\n\t\t`c:\\ndrive\\2015 Information Table`: \"ok\",\n\t\t\"%*worst function name ever!!\": func() string {\n\t\t\treturn \"ok\"\n\t\t}(),\n\t\t\"1\":      \"o\",\n\t\t\"2\":      \"k\",\n\t\t\"num\":    10,\n\t\t\"mylist\": []int{1, 2, 3, 4, 5},\n\t\t\"MIN\": func(a, b int) int {\n\t\t\tif a < b {\n\t\t\t\treturn a\n\t\t\t} else {\n\t\t\t\treturn b\n\t\t\t}\n\t\t},\n\t\t\"red\":   \"n\",\n\t\t\"irect\": \"um\",\n\t\t\"String Map\": map[string]string{\n\t\t\t\"one\":   \"two\",\n\t\t\t\"three\": \"four\",\n\t\t},\n\t\t\"OtherMap\": map[string]string{\n\t\t\t\"a\": \"b\",\n\t\t\t\"c\": \"d\",\n\t\t},\n\t}\n\n\t// No error cases\n\tvar tests = []struct {\n\t\tcode string\n\t\twant any\n\t}{\n\t\t{\"$env['space test']\", \"ok\"},\n\t\t{\"$env['Section 1-2a']\", \"ok\"},\n\t\t{`$env[\"c:\\\\ndrive\\\\2015 Information Table\"]`, \"ok\"},\n\t\t{\"$env['%*worst function name ever!!']\", \"ok\"},\n\t\t{\"$env['String Map'].one\", \"two\"},\n\t\t{\"$env['1'] + $env['2']\", \"ok\"},\n\t\t{\"1 + $env['num'] + $env['num']\", 21},\n\t\t{\"MIN($env['num'],0)\", 0},\n\t\t{\"$env['nu' + 'm']\", 10},\n\t\t{\"$env[red + irect]\", 10},\n\t\t{\"$env['String Map']?.five\", \"\"},\n\t\t{\"$env.red\", \"n\"},\n\t\t{\"$env?.unknown\", nil},\n\t\t{\"$env.mylist[1]\", 2},\n\t\t{\"$env?.OtherMap?.a\", \"b\"},\n\t\t{\"$env?.OtherMap?.d\", \"\"},\n\t\t{\"'num' in $env\", true},\n\t\t{\"get($env, 'num')\", 10},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.code, func(t *testing.T) {\n\n\t\t\tprogram, err := expr.Compile(tt.code, expr.Env(env))\n\t\t\trequire.NoError(t, err, \"compile error\")\n\n\t\t\tgot, err := expr.Run(program, env)\n\t\t\trequire.NoError(t, err, \"execution error\")\n\n\t\t\tassert.Equal(t, tt.want, got, tt.code)\n\t\t})\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.code, func(t *testing.T) {\n\t\t\tgot, err := expr.Eval(tt.code, env)\n\t\t\trequire.NoError(t, err, \"eval error: \"+tt.code)\n\n\t\t\tassert.Equal(t, tt.want, got, \"eval: \"+tt.code)\n\t\t})\n\t}\n\n\t// error cases\n\ttests = []struct {\n\t\tcode string\n\t\twant any\n\t}{\n\t\t{\"env()\", \"bad\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.code, func(t *testing.T) {\n\t\t\t_, err := expr.Eval(tt.code, expr.Env(env))\n\t\t\trequire.Error(t, err, \"compile error\")\n\n\t\t})\n\t}\n}\n\nfunc TestEnv_keyword_with_custom_functions(t *testing.T) {\n\tfn := expr.Function(\"fn\", func(params ...any) (any, error) {\n\t\treturn \"ok\", nil\n\t})\n\n\tvar tests = []struct {\n\t\tcode  string\n\t\terror bool\n\t}{\n\t\t{`fn()`, false},\n\t\t{`$env.fn()`, true},\n\t\t{`$env[\"fn\"]`, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.code, func(t *testing.T) {\n\t\t\t_, err := expr.Compile(tt.code, expr.Env(mock.Env{}), fn)\n\t\t\tif tt.error {\n\t\t\t\trequire.Error(t, err)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestIssue401(t *testing.T) {\n\tprogram, err := expr.Compile(\"(a - b + c) / d\", expr.AllowUndefinedVariables())\n\trequire.NoError(t, err, \"compile error\")\n\n\toutput, err := expr.Run(program, map[string]any{\n\t\t\"a\": 1,\n\t\t\"b\": 2,\n\t\t\"c\": 3,\n\t\t\"d\": 4,\n\t})\n\trequire.NoError(t, err, \"run error\")\n\trequire.Equal(t, 0.5, output)\n}\n\nfunc TestEval_slices_out_of_bound(t *testing.T) {\n\ttests := []struct {\n\t\tcode string\n\t\twant any\n\t}{\n\t\t{\"[1, 2, 3][:99]\", []any{1, 2, 3}},\n\t\t{\"[1, 2, 3][99:]\", []any{}},\n\t\t{\"[1, 2, 3][:-99]\", []any{}},\n\t\t{\"[1, 2, 3][-99:]\", []any{1, 2, 3}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.code, func(t *testing.T) {\n\t\t\tgot, err := expr.Eval(tt.code, nil)\n\t\t\trequire.NoError(t, err, \"eval error: \"+tt.code)\n\t\t\tassert.Equal(t, tt.want, got, \"eval: \"+tt.code)\n\t\t})\n\t}\n}\n\nfunc TestMemoryBudget(t *testing.T) {\n\ttests := []struct {\n\t\tcode string\n\t}{\n\t\t{`map(1..100, {map(1..100, {map(1..100, {0})})})`},\n\t\t{`len(1..10000000)`},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.code, func(t *testing.T) {\n\t\t\tprogram, err := expr.Compile(tt.code)\n\t\t\trequire.NoError(t, err, \"compile error\")\n\n\t\t\t_, err = expr.Run(program, nil)\n\t\t\tassert.Error(t, err, \"run error\")\n\t\t\tassert.Contains(t, err.Error(), \"memory budget exceeded\")\n\t\t})\n\t}\n}\n\nfunc TestExpr_custom_tests(t *testing.T) {\n\tf, err := os.Open(\"custom_tests.json\")\n\tif os.IsNotExist(err) {\n\t\tt.Skip(\"no custom tests\")\n\t\treturn\n\t}\n\n\trequire.NoError(t, err, \"open file error\")\n\tdefer f.Close()\n\n\tvar tests []string\n\terr = json.NewDecoder(f).Decode(&tests)\n\trequire.NoError(t, err, \"decode json error\")\n\n\tfor id, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"line %v\", id+2), func(t *testing.T) {\n\t\t\tprogram, err := expr.Compile(tt)\n\t\t\trequire.NoError(t, err)\n\n\t\t\ttimeout := make(chan bool, 1)\n\t\t\tgo func() {\n\t\t\t\ttime.Sleep(time.Second)\n\t\t\t\ttimeout <- true\n\t\t\t}()\n\n\t\t\tdone := make(chan bool, 1)\n\t\t\tgo func() {\n\t\t\t\tout, err := expr.Run(program, nil)\n\t\t\t\t// Make sure out is used.\n\t\t\t\t_ = fmt.Sprintf(\"%v\", out)\n\t\t\t\tassert.Error(t, err)\n\t\t\t\tdone <- true\n\t\t\t}()\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\t// Success.\n\t\t\tcase <-timeout:\n\t\t\t\tt.Fatal(\"timeout\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestIssue432(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"func\": func(\n\t\t\tparamUint32 uint32,\n\t\t\tparamUint16 uint16,\n\t\t\tparamUint8 uint8,\n\t\t\tparamUint uint,\n\t\t\tparamInt32 int32,\n\t\t\tparamInt16 int16,\n\t\t\tparamInt8 int8,\n\t\t\tparamInt int,\n\t\t\tparamFloat64 float64,\n\t\t\tparamFloat32 float32,\n\t\t) float64 {\n\t\t\treturn float64(paramUint32) + float64(paramUint16) + float64(paramUint8) + float64(paramUint) +\n\t\t\t\tfloat64(paramInt32) + float64(paramInt16) + float64(paramInt8) + float64(paramInt) +\n\t\t\t\tfloat64(paramFloat64) + float64(paramFloat32)\n\t\t},\n\t}\n\tcode := `func(1,1,1,1,1,1,1,1,1,1)`\n\n\tprogram, err := expr.Compile(code, expr.Env(env))\n\tassert.NoError(t, err)\n\n\tout, err := expr.Run(program, env)\n\tassert.NoError(t, err)\n\tassert.Equal(t, float64(10), out)\n}\n\nfunc TestIssue461(t *testing.T) {\n\ttype EnvStr string\n\ttype EnvField struct {\n\t\tS   EnvStr\n\t\tStr string\n\t}\n\ttype Env struct {\n\t\tS        EnvStr\n\t\tStr      string\n\t\tEnvField EnvField\n\t}\n\tvar tests = []struct {\n\t\tinput string\n\t\tenv   Env\n\t\twant  bool\n\t}{\n\t\t{\n\t\t\tinput: \"Str == S\",\n\t\t\tenv:   Env{S: \"string\", Str: \"string\"},\n\t\t\twant:  false,\n\t\t},\n\t\t{\n\t\t\tinput: \"Str == Str\",\n\t\t\tenv:   Env{Str: \"string\"},\n\t\t\twant:  true,\n\t\t},\n\t\t{\n\t\t\tinput: \"S == S\",\n\t\t\tenv:   Env{Str: \"string\"},\n\t\t\twant:  true,\n\t\t},\n\t\t{\n\t\t\tinput: `Str == \"string\"`,\n\t\t\tenv:   Env{Str: \"string\"},\n\t\t\twant:  true,\n\t\t},\n\t\t{\n\t\t\tinput: `S == \"string\"`,\n\t\t\tenv:   Env{Str: \"string\"},\n\t\t\twant:  false,\n\t\t},\n\t\t{\n\t\t\tinput: \"EnvField.Str == EnvField.S\",\n\t\t\tenv:   Env{EnvField: EnvField{S: \"string\", Str: \"string\"}},\n\t\t\twant:  false,\n\t\t},\n\t\t{\n\t\t\tinput: \"EnvField.Str == EnvField.Str\",\n\t\t\tenv:   Env{EnvField: EnvField{Str: \"string\"}},\n\t\t\twant:  true,\n\t\t},\n\t\t{\n\t\t\tinput: \"EnvField.S == EnvField.S\",\n\t\t\tenv:   Env{EnvField: EnvField{Str: \"string\"}},\n\t\t\twant:  true,\n\t\t},\n\t\t{\n\t\t\tinput: `EnvField.Str == \"string\"`,\n\t\t\tenv:   Env{EnvField: EnvField{Str: \"string\"}},\n\t\t\twant:  true,\n\t\t},\n\t\t{\n\t\t\tinput: `EnvField.S == \"string\"`,\n\t\t\tenv:   Env{EnvField: EnvField{Str: \"string\"}},\n\t\t\twant:  false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tprogram, err := expr.Compile(tt.input, expr.Env(tt.env), expr.AsBool())\n\n\t\t\tout, err := expr.Run(program, tt.env)\n\t\t\trequire.NoError(t, err)\n\n\t\t\trequire.Equal(t, tt.want, out)\n\t\t})\n\t}\n}\n\nfunc TestIssue462(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"foo\": func() (string, error) {\n\t\t\treturn \"bar\", nil\n\t\t},\n\t}\n\t_, err := expr.Compile(`$env.unknown(int())`, expr.Env(env))\n\trequire.Error(t, err)\n}\n\nfunc TestIssue_embedded_pointer_struct(t *testing.T) {\n\tvar tests = []struct {\n\t\tinput string\n\t\tenv   mock.Env\n\t\twant  any\n\t}{\n\t\t{\n\t\t\tinput: \"EmbedPointerEmbedInt > 0\",\n\t\t\tenv: mock.Env{\n\t\t\t\tEmbed: mock.Embed{\n\t\t\t\t\tEmbedPointerEmbed: &mock.EmbedPointerEmbed{\n\t\t\t\t\t\tEmbedPointerEmbedInt: 123,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tinput: \"(Embed).EmbedPointerEmbedInt > 0\",\n\t\t\tenv: mock.Env{\n\t\t\t\tEmbed: mock.Embed{\n\t\t\t\t\tEmbedPointerEmbed: &mock.EmbedPointerEmbed{\n\t\t\t\t\t\tEmbedPointerEmbedInt: 123,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tinput: \"(Embed).EmbedPointerEmbedInt > 0\",\n\t\t\tenv: mock.Env{\n\t\t\t\tEmbed: mock.Embed{\n\t\t\t\t\tEmbedPointerEmbed: &mock.EmbedPointerEmbed{\n\t\t\t\t\t\tEmbedPointerEmbedInt: 0,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tinput: \"(Embed).EmbedPointerEmbedMethod(0)\",\n\t\t\tenv: mock.Env{\n\t\t\t\tEmbed: mock.Embed{\n\t\t\t\t\tEmbedPointerEmbed: &mock.EmbedPointerEmbed{\n\t\t\t\t\t\tEmbedPointerEmbedInt: 0,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t\t{\n\t\t\tinput: \"(Embed).EmbedPointerEmbedPointerReceiverMethod(0)\",\n\t\t\tenv: mock.Env{\n\t\t\t\tEmbed: mock.Embed{\n\t\t\t\t\tEmbedPointerEmbed: nil,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.input, func(t *testing.T) {\n\t\t\tprogram, err := expr.Compile(tt.input, expr.Env(tt.env))\n\t\t\trequire.NoError(t, err)\n\n\t\t\tout, err := expr.Run(program, tt.env)\n\t\t\trequire.NoError(t, err)\n\n\t\t\trequire.Equal(t, tt.want, out)\n\t\t})\n\t}\n}\n\nfunc TestIssue474(t *testing.T) {\n\ttestCases := []struct {\n\t\tcode string\n\t\tfail bool\n\t}{\n\t\t{\n\t\t\tcode: `func(\"invalid\")`,\n\t\t\tfail: true,\n\t\t},\n\t\t{\n\t\t\tcode: `func(true)`,\n\t\t\tfail: true,\n\t\t},\n\t\t{\n\t\t\tcode: `func([])`,\n\t\t\tfail: true,\n\t\t},\n\t\t{\n\t\t\tcode: `func({})`,\n\t\t\tfail: true,\n\t\t},\n\t\t{\n\t\t\tcode: `func(1)`,\n\t\t\tfail: false,\n\t\t},\n\t\t{\n\t\t\tcode: `func(1.5)`,\n\t\t\tfail: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tltc := tc\n\t\tt.Run(ltc.code, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tfunction := expr.Function(\"func\", func(params ...any) (any, error) {\n\t\t\t\treturn true, nil\n\t\t\t}, new(func(float64) bool))\n\t\t\t_, err := expr.Compile(ltc.code, function)\n\t\t\tif ltc.fail {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Error(\"expected an error, but it was nil\")\n\t\t\t\t\tt.FailNow()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"expected nil, but it was %v\", err)\n\t\t\t\t\tt.FailNow()\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRaceCondition_variables(t *testing.T) {\n\tprogram, err := expr.Compile(`let foo = 1; foo + 1`, expr.Env(mock.Env{}))\n\trequire.NoError(t, err)\n\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tout, err := expr.Run(program, mock.Env{})\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, 2, out)\n\t\t}()\n\t}\n\n\twg.Wait()\n}\n\nfunc TestOperatorDependsOnEnv(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"plus\": func(a, b int) int {\n\t\t\treturn 42\n\t\t},\n\t}\n\tprogram, err := expr.Compile(`1 + 2`, expr.Operator(\"+\", \"plus\"), expr.Env(env))\n\trequire.NoError(t, err)\n\n\tout, err := expr.Run(program, env)\n\trequire.NoError(t, err)\n\tassert.Equal(t, 42, out)\n}\n\nfunc TestIssue624(t *testing.T) {\n\ttype tag struct {\n\t\tName string\n\t}\n\n\ttype item struct {\n\t\tTags []tag\n\t}\n\n\ti := item{\n\t\tTags: []tag{\n\t\t\t{Name: \"one\"},\n\t\t\t{Name: \"two\"},\n\t\t},\n\t}\n\n\trule := `[\ntrue && true, \none(Tags, .Name in [\"one\"]), \none(Tags, .Name in [\"two\"]), \none(Tags, .Name in [\"one\"]) && one(Tags, .Name in [\"two\"])\n]`\n\tresp, err := expr.Eval(rule, i)\n\trequire.NoError(t, err)\n\trequire.Equal(t, []interface{}{true, true, true, true}, resp)\n}\n\nfunc TestPredicateCombination(t *testing.T) {\n\ttests := []struct {\n\t\tcode1 string\n\t\tcode2 string\n\t}{\n\t\t{\"all(1..3, {# > 0}) && all(1..3, {# < 4})\", \"all(1..3, {# > 0 && # < 4})\"},\n\t\t{\"all(1..3, {# > 1}) && all(1..3, {# < 4})\", \"all(1..3, {# > 1 && # < 4})\"},\n\t\t{\"all(1..3, {# > 0}) && all(1..3, {# < 2})\", \"all(1..3, {# > 0 && # < 2})\"},\n\t\t{\"all(1..3, {# > 1}) && all(1..3, {# < 2})\", \"all(1..3, {# > 1 && # < 2})\"},\n\n\t\t{\"any(1..3, {# > 0}) || any(1..3, {# < 4})\", \"any(1..3, {# > 0 || # < 4})\"},\n\t\t{\"any(1..3, {# > 1}) || any(1..3, {# < 4})\", \"any(1..3, {# > 1 || # < 4})\"},\n\t\t{\"any(1..3, {# > 0}) || any(1..3, {# < 2})\", \"any(1..3, {# > 0 || # < 2})\"},\n\t\t{\"any(1..3, {# > 1}) || any(1..3, {# < 2})\", \"any(1..3, {# > 1 || # < 2})\"},\n\n\t\t{\"none(1..3, {# > 0}) && none(1..3, {# < 4})\", \"none(1..3, {# > 0 || # < 4})\"},\n\t\t{\"none(1..3, {# > 1}) && none(1..3, {# < 4})\", \"none(1..3, {# > 1 || # < 4})\"},\n\t\t{\"none(1..3, {# > 0}) && none(1..3, {# < 2})\", \"none(1..3, {# > 0 || # < 2})\"},\n\t\t{\"none(1..3, {# > 1}) && none(1..3, {# < 2})\", \"none(1..3, {# > 1 || # < 2})\"},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.code1, func(t *testing.T) {\n\t\t\tout1, err := expr.Eval(tt.code1, nil)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tout2, err := expr.Eval(tt.code2, nil)\n\t\t\trequire.NoError(t, err)\n\n\t\t\trequire.Equal(t, out1, out2)\n\t\t})\n\t}\n}\n\nfunc TestArrayComparison(t *testing.T) {\n\ttests := []struct {\n\t\tenv  any\n\t\tcode string\n\t}{\n\t\t{[]string{\"A\", \"B\"}, \"foo == ['A', 'B']\"},\n\t\t{[]int{1, 2}, \"foo == [1, 2]\"},\n\t\t{[]uint8{1, 2}, \"foo == [1, 2]\"},\n\t\t{[]float64{1.1, 2.2}, \"foo == [1.1, 2.2]\"},\n\t\t{[]any{\"A\", 1, 1.1, true}, \"foo == ['A', 1, 1.1, true]\"},\n\t\t{[]string{\"A\", \"B\"}, \"foo != [1, 2]\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.code, func(t *testing.T) {\n\t\t\tenv := map[string]any{\"foo\": tt.env}\n\t\t\tprogram, err := expr.Compile(tt.code, expr.Env(env))\n\t\t\trequire.NoError(t, err)\n\n\t\t\tout, err := expr.Run(program, env)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, true, out)\n\t\t})\n\t}\n}\n\nfunc TestIssue_570(t *testing.T) {\n\ttype Student struct {\n\t\tName string\n\t}\n\n\tenv := map[string]any{\n\t\t\"student\": (*Student)(nil),\n\t}\n\n\tprogram, err := expr.Compile(\"student?.Name\", expr.Env(env))\n\trequire.NoError(t, err)\n\n\tout, err := expr.Run(program, env)\n\trequire.NoError(t, err)\n\trequire.IsType(t, nil, out)\n}\n\nfunc TestIssue_integer_truncated_by_compiler(t *testing.T) {\n\tenv := map[string]any{\n\t\t\"fn\": func(x byte) byte {\n\t\t\treturn x\n\t\t},\n\t}\n\n\t_, err := expr.Compile(\"fn(255)\", expr.Env(env))\n\trequire.NoError(t, err)\n\n\t_, err = expr.Compile(\"fn(256)\", expr.Env(env))\n\trequire.Error(t, err)\n}\n\nfunc TestExpr_crash(t *testing.T) {\n\tcontent, err := os.ReadFile(\"testdata/crash.txt\")\n\trequire.NoError(t, err)\n\n\t_, err = expr.Compile(string(content))\n\trequire.Error(t, err)\n}\n\nfunc TestExpr_nil_op_str(t *testing.T) {\n\t// Let's test operators, which do `.(string)` in VM, also check for nil.\n\n\tvar str *string = nil\n\tenv := map[string]any{\n\t\t\"nilString\": str,\n\t}\n\n\ttests := []struct{ code string }{\n\t\t{`nilString == \"str\"`},\n\t\t{`nilString contains \"str\"`},\n\t\t{`nilString matches \"str\"`},\n\t\t{`nilString startsWith \"str\"`},\n\t\t{`nilString endsWith \"str\"`},\n\n\t\t{`\"str\" == nilString`},\n\t\t{`\"str\" contains nilString`},\n\t\t{`\"str\" matches nilString`},\n\t\t{`\"str\" startsWith nilString`},\n\t\t{`\"str\" endsWith nilString`},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.code, func(t *testing.T) {\n\t\t\tprogram, err := expr.Compile(tt.code)\n\t\t\trequire.NoError(t, err)\n\n\t\t\toutput, err := expr.Run(program, env)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, false, output)\n\t\t})\n\t}\n}\n\nfunc TestExpr_env_types_map(t *testing.T) {\n\tenvTypes := types.Map{\n\t\t\"foo\": types.Map{\n\t\t\t\"bar\": types.String,\n\t\t},\n\t}\n\n\tprogram, err := expr.Compile(`foo.bar`, expr.Env(envTypes))\n\trequire.NoError(t, err)\n\n\tenv := map[string]any{\n\t\t\"foo\": map[string]any{\n\t\t\t\"bar\": \"value\",\n\t\t},\n\t}\n\n\toutput, err := expr.Run(program, env)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"value\", output)\n}\n\nfunc TestExpr_env_types_map_error(t *testing.T) {\n\tenvTypes := types.Map{\n\t\t\"foo\": types.Map{\n\t\t\t\"bar\": types.String,\n\t\t},\n\t}\n\n\tprogram, err := expr.Compile(`foo.bar`, expr.Env(envTypes))\n\trequire.NoError(t, err)\n\n\t_, err = expr.Run(program, envTypes)\n\trequire.Error(t, err)\n}\n"
        },
        {
          "name": "file",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.041015625,
          "content": "module github.com/expr-lang/expr\n\ngo 1.18\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "optimizer",
          "type": "tree",
          "content": null
        },
        {
          "name": "parser",
          "type": "tree",
          "content": null
        },
        {
          "name": "patcher",
          "type": "tree",
          "content": null
        },
        {
          "name": "repl",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "types",
          "type": "tree",
          "content": null
        },
        {
          "name": "vm",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}