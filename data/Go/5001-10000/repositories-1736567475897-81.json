{
  "metadata": {
    "timestamp": 1736567475897,
    "page": 81,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "onsi/ginkgo",
      "stars": 8464,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.064453125,
          "content": ".DS_Store\nTODO\ntmp/**/*\n*.coverprofile\n.vscode\n.idea/\n*.log\n*.test"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 43.8818359375,
          "content": "## 2.22.2\n\n### Maintenance\n- Bump github.com/onsi/gomega from 1.36.1 to 1.36.2 (#1499) [cc553ce]\n- Bump golang.org/x/crypto (#1498) [2170370]\n- Bump golang.org/x/net from 0.32.0 to 0.33.0 (#1496) [a96c44f]\n\n## 2.22.1\n\n### Fixes\nFix CSV encoding\n- Update tests [aab3da6]\n- Properly encode CSV rows [c09df39]\n- Add test case for proper csv escaping [96a80fc]\n- Add meta-test [43dad69]\n\n### Maintenance\n- ensure *.test files are gitignored so we don't accidentally commit compiled tests again [c88c634]\n- remove golang.org/x/net/context in favour of stdlib context [4df44bf]\n\n## 2.22.0\n\n### Features\n- Add label to serial nodes [0fcaa08]\n\nThis allows serial tests to be filtered using the `label-filter`\n\n### Maintenance\nVarious doc fixes\n\n## 2.21.0\n\n\n  ### Features\n  - add support for GINKGO_TIME_FORMAT [a69eb39]\n  - add GINKGO_NO_COLOR to disable colors via environment variables [bcab9c8]\n\n  ### Fixes\n  - increase threshold in timeline matcher [e548367]\n  - Fix the document by replacing `SpecsThatWillBeRun` with `SpecsThatWillRun`\n  [c2c4d3c]\n\n  ### Maintenance\n  - bump various dependencies [7e65a00]\n\n## 2.20.2\n\nRequire Go 1.22+\n\n### Maintenance\n- bump go to v1.22 [a671816]\n\n## 2.20.1\n\n### Fixes\n- make BeSpecEvent duration matcher more forgiving [d6f9640]\n\n## 2.20.0\n\n### Features\n- Add buildvcs flag [be5ab95]\n\n### Maintenance\n- Add update-deps to makefile [d303d14]\n- bump all dependencies [7a50221]\n\n## 2.19.1\n\n### Fixes\n- update supported platforms for race conditions [63c8c30]\n- [build] Allow custom name for binaries. [ff41e27]\n\n### Maintenance\n- bump gomega [76f4e0c]\n- Bump rexml from 3.2.6 to 3.2.8 in /docs (#1417) [b69c00d]\n- Bump golang.org/x/sys from 0.20.0 to 0.21.0 (#1425) [f097741]\n\n## 2.19.0\n\n### Features\n\n[Label Sets](https://onsi.github.io/ginkgo/#label-sets) allow for more expressive and flexible label filtering.\n\n## 2.18.0\n\n### Features\n- Add --slience-skips and --force-newlines [f010b65]\n- fail when no tests were run and --fail-on-empty was set [d80eebe]\n\n### Fixes\n- Fix table entry context edge case [42013d6]\n\n### Maintenance\n- Bump golang.org/x/tools from 0.20.0 to 0.21.0 (#1406) [fcf1fd7]\n- Bump github.com/onsi/gomega from 1.33.0 to 1.33.1 (#1399) [8bb14fd]\n- Bump golang.org/x/net from 0.24.0 to 0.25.0 (#1407) [04bfad7]\n\n## 2.17.3\n\n### Fixes\n`ginkgo watch` now ignores hidden files [bde6e00]\n\n## 2.17.2\n\n### Fixes\n- fix: close files [32259c8]\n- fix github output log level for skipped specs [780e7a3]\n\n### Maintenance\n- Bump github.com/google/pprof [d91fe4e]\n- Bump github.com/go-task/slim-sprig to v3 [8cb662e]\n- Bump golang.org/x/net in /integration/_fixtures/version_mismatch_fixture (#1391) [3134422]\n- Bump github-pages from 230 to 231 in /docs (#1384) [eca81b4]\n- Bump golang.org/x/tools from 0.19.0 to 0.20.0 (#1383) [760def8]\n- Bump golang.org/x/net from 0.23.0 to 0.24.0 (#1381) [4ce33f4]\n- Fix test for gomega version bump [f2fcd97]\n- Bump github.com/onsi/gomega from 1.30.0 to 1.33.0 (#1390) [fd622d2]\n- Bump golang.org/x/tools from 0.17.0 to 0.19.0 (#1368) [5474a26]\n- Bump github-pages from 229 to 230 in /docs (#1359) [e6d1170]\n- Bump google.golang.org/protobuf from 1.28.0 to 1.33.0 (#1374) [7f447b2]\n- Bump golang.org/x/net from 0.20.0 to 0.23.0 (#1380) [f15239a]\n\n## 2.17.1\n\n### Fixes\n- If the user sets --seed=0, make sure all parallel nodes get the same seed [af0330d]\n\n## 2.17.0\n\n### Features\n\n- add `--github-output` for nicer output in github actions [e8a2056]\n\n### Maintenance\n\n- fix typo in core_dsl.go [977bc6f]\n- Fix typo in docs [e297e7b]\n\n## 2.16.0\n\n### Features\n- add SpecContext to reporting nodes\n\n### Fixes\n- merge coverages instead of combining them (#1329) (#1340) [23f0cc5]\n- core_dsl: disable Getwd() with environment variable (#1357) [cd418b7]\n\n### Maintenance\n- docs/index.md: Typo [2cebe8d]\n- fix docs [06de431]\n- chore: test with Go 1.22 (#1352) [898cba9]\n- Bump golang.org/x/tools from 0.16.1 to 0.17.0 (#1336) [17ae120]\n- Bump golang.org/x/sys from 0.15.0 to 0.16.0 (#1327) [5a179ed]\n- Bump github.com/go-logr/logr from 1.3.0 to 1.4.1 (#1321) [a1e6b69]\n- Bump github-pages and jekyll-feed in /docs (#1351) [d52951d]\n- Fix docs for handling failures in goroutines (#1339) [4471b2e]\n\n## 2.15.0\n\n### Features\n\n- JUnit reports now interpret Label(owner:X) and set owner to X. [8f3bd70]\n- include cancellation reason when cancelling spec context [96e915c]\n\n### Fixes\n\n- emit output of failed go tool cover invocation so users can try to debug things for themselves [c245d09]\n- fix outline when using nodot in ginkgo v2 [dca77c8]\n- Document areas where GinkgoT() behaves differently from testing.T [dbaf18f]\n- bugfix(docs): use Unsetenv instead of Clearenv (#1337) [6f67a14]\n\n### Maintenance\n\n- Bump to go 1.20 [4fcd0b3]\n\n## 2.14.0\n\n### Features\nYou can now use `GinkgoTB()` when you need an instance of `testing.TB` to pass to a library.\n\nPrior to this release table testing only supported generating individual `It`s for each test entry.  `DescribeTableSubtree` extends table testing support to entire testing subtrees - under the hood `DescrieTableSubtree` generates a new container for each entry and invokes your function to fill our the container.  See the [docs](https://onsi.github.io/ginkgo/#generating-subtree-tables) to learn more.\n\n- Introduce DescribeTableSubtree [65ec56d]\n- add GinkgoTB() to docs [4a2c832]\n- Add GinkgoTB() function (#1333) [92b6744]\n\n### Fixes\n- Fix typo in internal/suite.go (#1332) [beb9507]\n- Fix typo in docs/index.md (#1319) [4ac3a13]\n- allow wasm to compile with ginkgo present (#1311) [b2e5bc5]\n\n### Maintenance\n- Bump golang.org/x/tools from 0.16.0 to 0.16.1 (#1316) [465a8ec]\n- Bump actions/setup-go from 4 to 5 (#1313) [eab0e40]\n- Bump github/codeql-action from 2 to 3 (#1317) [fbf9724]\n- Bump golang.org/x/crypto (#1318) [3ee80ee]\n- Bump golang.org/x/tools from 0.14.0 to 0.16.0 (#1306) [123e1d5]\n- Bump github.com/onsi/gomega from 1.29.0 to 1.30.0 (#1297) [558f6e0]\n- Bump golang.org/x/net from 0.17.0 to 0.19.0 (#1307) [84ff7f3]\n\n## 2.13.2\n\n### Fixes\n- Fix file handler leak (#1309) [e2e81c8]\n- Avoid allocations with `(*regexp.Regexp).MatchString` (#1302) [3b2a2a7]\n\n## 2.13.1\n\n### Fixes\n- # 1296 fix(precompiled test guite): exec bit check omitted on Windows (#1301) [26eea01]\n\n### Maintenance\n- Bump github.com/go-logr/logr from 1.2.4 to 1.3.0 (#1291) [7161a9d]\n- Bump golang.org/x/sys from 0.13.0 to 0.14.0 (#1295) [7fc7b10]\n- Bump golang.org/x/tools from 0.12.0 to 0.14.0 (#1282) [74bbd65]\n- Bump github.com/onsi/gomega from 1.27.10 to 1.29.0 (#1290) [9373633]\n- Bump golang.org/x/net in /integration/_fixtures/version_mismatch_fixture (#1286) [6e3cf65]\n\n## 2.13.0\n\n### Features\n\nAdd PreviewSpect() to enable programmatic preview access to the suite report (fixes #1225)\n\n## 2.12.1\n\n### Fixes\n- Print logr prefix if it exists (#1275) [90d4846]\n\n### Maintenance\n- Bump actions/checkout from 3 to 4 (#1271) [555f543]\n- Bump golang.org/x/sys from 0.11.0 to 0.12.0 (#1270) [d867b7d]\n\n## 2.12.0\n\n### Features\n\n- feat: allow MustPassRepeatedly decorator to be set at suite level (#1266) [05de518]\n\n### Fixes\n\n- fix-errors-in-readme (#1244) [27c2f5d]\n\n### Maintenance\n\nVarious chores/dependency bumps.\n\n## 2.11.0\n\nIn prior versions of Ginkgo specs the CLI filter flags (e.g. `--focus`, `--label-filter`) would _override_ any programmatic focus.  This behavior has proved surprising and confusing in at least the following ways:\n\n- users cannot combine programmatic filters and CLI filters to more efficiently select subsets of tests\n- CLI filters can override programmatic focus on CI systems resulting in an exit code of 0 despite the presence of (incorrectly!) committed focused specs.\n\nGoing forward Ginkgo will AND all programmatic and CLI filters.  Moreover, the presence of any programmatic focused tests will always result in a non-zero exit code.\n\nThis change is technically a change in Ginkgo's external contract and may require some users to make changes to successfully adopt. Specifically: it's possible some users were intentionally using CLI filters to override programmatic focus.  If this is you please open an issue so we can explore solutions to the underlying problem you are trying to solve.\n\n### Fixes\n- Programmatic focus is no longer overwrriten by CLI filters [d6bba86]\n\n### Maintenance\n- Bump github.com/onsi/gomega from 1.27.7 to 1.27.8 (#1218) [4a70a38]\n- Bump golang.org/x/sys from 0.8.0 to 0.9.0 (#1219) [97eda4d]\n\n## 2.10.0\n\n### Features\n- feat(ginkgo/generators): add --tags flag (#1216) [a782a77]\n  adds a new --tags flag to ginkgo generate\n\n### Fixes\n- Fix broken link of MIGRATING_TO_V2.md (#1217) [548d78e]\n\n### Maintenance\n- Bump golang.org/x/tools from 0.9.1 to 0.9.3 (#1215) [2b76a5e]\n\n## 2.9.7\n\n### Fixes\n- fix race when multiple defercleanups are called in goroutines [07fc3a0]\n\n## 2.9.6\n\n### Fixes\n- fix: create parent directory before report files (#1212) [0ac65de]\n\n### Maintenance\n- Bump github.com/onsi/gomega from 1.27.6 to 1.27.7 (#1202) [3e39231]\n\n## 2.9.5\n\n### Fixes\n- ensure the correct deterministic sort order is produced when ordered specs are generated by a helper function [7fa0b6b]\n\n### Maintenance\n- fix generators link (#1200) [9f9d8b9]\n- Bump golang.org/x/tools from 0.8.0 to 0.9.1 (#1196) [150e3f2]\n- fix spelling err in docs (#1199) [0013b1a]\n- Bump golang.org/x/sys from 0.7.0 to 0.8.0 (#1193) [9e9e3e5]\n\n## 2.9.4\n\n### Fixes\n- fix hang with ginkgo -p (#1192) [15d4bdc] - this addresses a _long_ standing issue related to Ginkgo hanging when a child process spawned by the test does not exit.\n\n- fix: fail fast may cause Serial spec or cleanup Node interrupted (#1178) [8dea88b] - prior to this there was a small gap in which specs on other processes might start even if one process has tried to abort the suite.\n\n\n### Maintenance\n- Document run order when multiple setup nodes are at the same nesting level [903be81]\n\n## 2.9.3\n\n### Features\n- Add RenderTimeline to GinkgoT() [c0c77b6]\n\n### Fixes\n- update Measure deprecation message. fixes #1176 [227c662]\n- add newlines to GinkgoLogr (#1170) (#1171) [0de0e7c]\n\n### Maintenance\n- Bump commonmarker from 0.23.8 to 0.23.9 in /docs (#1183) [8b925ab]\n- Bump nokogiri from 1.14.1 to 1.14.3 in /docs (#1184) [e3795a4]\n- Bump golang.org/x/tools from 0.7.0 to 0.8.0 (#1182) [b453793]\n- Bump actions/setup-go from 3 to 4 (#1164) [73ed75b]\n- Bump github.com/onsi/gomega from 1.27.4 to 1.27.6 (#1173) [0a2bc64]\n- Bump github.com/go-logr/logr from 1.2.3 to 1.2.4 (#1174) [f41c557]\n- Bump golang.org/x/sys from 0.6.0 to 0.7.0 (#1179) [8e423e5]\n\n## 2.9.2\n\n### Maintenance\n- Bump github.com/go-task/slim-sprig (#1167) [3fcc5bf]\n- Bump github.com/onsi/gomega from 1.27.3 to 1.27.4 (#1163) [6143ffe]\n\n## 2.9.1\n\n### Fixes\nThis release fixes a longstanding issue where `ginkgo -coverpkg=./...` would not work.  This is now resolved and fixes [#1161](https://github.com/onsi/ginkgo/issues/1161) and [#995](https://github.com/onsi/ginkgo/issues/995)\n- Support -coverpkg=./... [26ca1b5]\n- document coverpkg a bit more clearly [fc44c3b]\n\n### Maintenance\n- bump various dependencies\n- Improve Documentation and fix typo (#1158) [93de676]\n\n## 2.9.0\n\n### Features\n- AttachProgressReporter is an experimental feature that allows users to provide arbitrary information when a ProgressReport is requested [28801fe]\n\n- GinkgoT() has been expanded to include several Ginkgo-specific methods [2bd5a3b]\n\n  The intent is to enable the development of third-party libraries that integrate deeply with Ginkgo using `GinkgoT()` to access Ginkgo's functionality.\n\n## 2.8.4\n\n### Features\n- Add OmitSuiteSetupNodes to JunitReportConfig (#1147) [979fbc2]\n- Add a reference to ginkgolinter in docs.index.md (#1143) [8432589]\n\n### Fixes\n- rename tools hack to see if it fixes things for downstream users [a8bb39a]\n\n### Maintenance\n- Bump golang.org/x/text (#1144) [41b2a8a]\n- Bump github.com/onsi/gomega from 1.27.0 to 1.27.1 (#1142) [7c4f583]\n\n## 2.8.3\n\nReleased to fix security issue in golang.org/x/net dependency\n\n### Maintenance\n\n- Bump golang.org/x/net from 0.6.0 to 0.7.0 (#1141) [fc1a02e]\n- remove tools.go hack from documentation [0718693]\n\n## 2.8.2\n\nGinkgo now includes a `tools.go` file in the root directory of the `ginkgo` package.  This should allow modules that simply `go get github.com/onsi/ginkgo/v2` to also pull in the CLI dependencies.  This obviates the need for consumers of Ginkgo to have their own `tools.go` file and makes it simpler to ensure that the version of the `ginkgo` CLI being used matches the version of the library.  You can simply run `go run github.com/onsi/ginkgo/v2/ginkgo` to run the version of the cli associated with your package go.mod.\n\n### Maintenance\n\n- Bump github.com/onsi/gomega from 1.26.0 to 1.27.0 (#1139) [5767b0a]\n- Fix minor typos (#1138) [e1e9723]\n- Fix link in V2 Migration Guide (#1137) [a588f60]\n\n## 2.8.1\n\n### Fixes\n- lock around default report output to avoid triggering the race detector when calling By from goroutines [2d5075a]\n- don't run ReportEntries through sprintf [febbe38]\n\n### Maintenance\n- Bump golang.org/x/tools from 0.5.0 to 0.6.0 (#1135) [11a4860]\n- test: update matrix for Go 1.20 (#1130) [4890a62]\n- Bump golang.org/x/sys from 0.4.0 to 0.5.0 (#1133) [a774638]\n- Bump github.com/onsi/gomega from 1.25.0 to 1.26.0 (#1120) [3f233bd]\n- Bump github-pages from 227 to 228 in /docs (#1131) [f9b8649]\n- Bump activesupport from 6.0.6 to 6.0.6.1 in /docs (#1127) [6f8c042]\n- Update index.md with instructions on how to upgrade Ginkgo [833a75e]\n\n## 2.8.0\n\n### Features\n\n- Introduce GinkgoHelper() to track and exclude helper functions from potential CodeLocations [e19f556]\n\nModeled after `testing.T.Helper()`.  Now, rather than write code like:\n\n```go\nfunc helper(model Model) {\n    Expect(model).WithOffset(1).To(BeValid())\n    Expect(model.SerialNumber).WithOffset(1).To(MatchRegexp(/[a-f0-9]*/))\n}\n```\n\nyou can stop tracking offsets (which makes nesting composing helpers nearly impossible) and simply write:\n\n```go\nfunc helper(model Model) {\n    GinkgoHelper()\n    Expect(model).To(BeValid())\n    Expect(model.SerialNumber).To(MatchRegexp(/[a-f0-9]*/))\n}\n```\n\n- Introduce GinkgoLabelFilter() and Label().MatchesLabelFilter() to make it possible to programmatically match filters (fixes #1119) [2f6597c]\n\nYou can now write code like this:\n\n```go\nBeforeSuite(func() {\n\tif Label(\"slow\").MatchesLabelFilter(GinkgoLabelFilter()) {\n\t\t// do slow setup\n\t}\n\n\tif Label(\"fast\").MatchesLabelFilter(GinkgoLabelFilter()) {\n\t\t// do fast setup\n\t}\n})\n```\n\nto programmatically check whether a given set of labels will match the configured `--label-filter`.\n\n### Maintenance\n\n- Bump webrick from 1.7.0 to 1.8.1 in /docs (#1125) [ea4966e]\n- cdeql: add ruby language (#1124) [9dd275b]\n- dependabot: add bundler package-ecosystem for docs (#1123) [14e7bdd]\n\n## 2.7.1\n\n### Fixes\n- Bring back SuiteConfig.EmitSpecProgress to avoid compilation issue for consumers that set it manually [d2a1cb0]\n\n### Maintenance\n- Bump github.com/onsi/gomega from 1.24.2 to 1.25.0 (#1118) [cafece6]\n- Bump golang.org/x/tools from 0.4.0 to 0.5.0 (#1111) [eda66c2]\n- Bump golang.org/x/sys from 0.3.0 to 0.4.0 (#1112) [ac5ccaa]\n- Bump github.com/onsi/gomega from 1.24.1 to 1.24.2 (#1097) [eee6480]\n\n## 2.7.0\n\n### Features\n- Introduce ContinueOnFailure for Ordered containers [e0123ca] - Ordered containers that are also decorated with ContinueOnFailure will not stop running specs after the first spec fails.\n- Support for bootstrap commands to use custom data for templates (#1110) [7a2b242]\n- Support for labels and pending decorator in ginkgo outline output (#1113) [e6e3b98]\n- Color aliases for custom color support (#1101) [49fab7a]\n\n### Fixes\n- correctly ensure deterministic spec order, even if specs are generated by iterating over a map [89dda20]\n- Fix a bug where timedout specs were not correctly treated as failures when determining whether or not to run AfterAlls in an Ordered container.\n- Ensure go test coverprofile outputs to the expected location (#1105) [b0bd77b]\n\n## 2.6.1\n\n### Features\n- Override formatter colors from envvars - this is a new feature but an alternative approach involving config files might be taken in the future (#1095) [60240d1]\n\n### Fixes\n- GinkgoRecover now supports ignoring panics that match a specific, hidden, interface [301f3e2]\n\n### Maintenance\n- Bump github.com/onsi/gomega from 1.24.0 to 1.24.1 (#1077) [3643823]\n- Bump golang.org/x/tools from 0.2.0 to 0.4.0 (#1090) [f9f856e]\n- Bump nokogiri from 1.13.9 to 1.13.10 in /docs (#1091) [0d7087e]\n\n## 2.6.0\n\n### Features\n- `ReportBeforeSuite` provides access to the suite report before the suite begins.\n- Add junit config option for omitting leafnodetype (#1088) [956e6d2]\n- Add support to customize junit report config to omit spec labels (#1087) [de44005]\n\n### Fixes\n- Fix stack trace pruning so that it has a chance of working on windows [2165648]\n\n## 2.5.1\n\n### Fixes\n- skipped tests only show as 'S' when running with -v [3ab38ae]\n- Fix typo in docs/index.md (#1082) [55fc58d]\n- Fix typo in docs/index.md (#1081) [8a14f1f]\n- Fix link notation in docs/index.md (#1080) [2669612]\n- Fix typo in `--progress` deprecation message (#1076) [b4b7edc]\n\n### Maintenance\n- chore: Included githubactions in the dependabot config (#976) [baea341]\n- Bump golang.org/x/sys from 0.1.0 to 0.2.0 (#1075) [9646297]\n\n## 2.5.0\n\n### Ginkgo output now includes a timeline-view of the spec\n\nThis commit changes Ginkgo's default output.  Spec details are now\npresented as a **timeline** that includes events that occur during the spec\nlifecycle interleaved with any GinkgoWriter content.  This makes is much easier\nto understand the flow of a spec and where a given failure occurs.\n\nThe --progress, --slow-spec-threshold, --always-emit-ginkgo-writer flags\nand the SuppressProgressReporting decorator have all been deprecated.  Instead\nthe existing -v and -vv flags better capture the level of verbosity to display.  However,\na new --show-node-events flag is added to include node `> Enter` and `< Exit` events\nin the spec timeline.\n\nIn addition, JUnit reports now include the timeline (rendered with -vv) and custom JUnit\nreports can be configured and generated using\n`GenerateJUnitReportWithConfig(report types.Report, dst string, config JunitReportConfig)`\n\nCode should continue to work unchanged with this version of Ginkgo - however if you have tooling that\nwas relying on the specific output format of Ginkgo you _may_ run into issues.  Ginkgo's console output is not guaranteed to be stable for tooling and automation purposes.  You should, instead, use Ginkgo's JSON format\nto build tooling on top of as it has stronger guarantees to be stable from version to version.\n\n### Features\n- Provide details about which timeout expired [0f2fa27]\n\n### Fixes\n- Add Support Policy to docs [c70867a]\n\n### Maintenance\n- Bump github.com/onsi/gomega from 1.22.1 to 1.23.0 (#1070) [bb3b4e2]\n\n## 2.4.0\n\n### Features\n\n- DeferCleanup supports functions with multiple-return values [5e33c75]\n- Add GinkgoLogr (#1067) [bf78c28]\n- Introduction of 'MustPassRepeatedly' decorator (#1051) [047c02f]\n\n### Fixes\n- correcting some typos (#1064) [1403d3c]\n- fix flaky internal_integration interrupt specs [2105ba3]\n- Correct busted link in README [be6b5b9]\n\n### Maintenance\n- Bump actions/checkout from 2 to 3 (#1062) [8a2f483]\n- Bump golang.org/x/tools from 0.1.12 to 0.2.0 (#1065) [529c4e8]\n- Bump github/codeql-action from 1 to 2 (#1061) [da09146]\n- Bump actions/setup-go from 2 to 3 (#1060) [918040d]\n- Bump github.com/onsi/gomega from 1.22.0 to 1.22.1 (#1053) [2098e4d]\n- Bump nokogiri from 1.13.8 to 1.13.9 in /docs (#1066) [1d74122]\n- Add GHA to dependabot config [4442772]\n\n## 2.3.1\n\n## Fixes\nSeveral users were invoking `ginkgo` by installing the latest version of the cli via `go install github.com/onsi/ginkgo/v2/ginkgo@latest`.  When 2.3.0 was released this resulted in an influx of issues as CI systems failed due to a change in the internal contract between the Ginkgo CLI and the Ginkgo library.  Ginkgo only supports running the same version of the library as the cli (which is why both are packaged in the same repository).\n\nWith this patch release, the ginkgo CLI can now identify a version mismatch and emit a helpful error message.\n\n- Ginkgo cli can identify version mismatches and emit a helpful error message [bc4ae2f]\n- further emphasize that a version match is required when running Ginkgo on CI and/or locally [2691dd8]\n\n### Maintenance\n- bump gomega to v1.22.0 [822a937]\n\n## 2.3.0\n\n### Interruptible Nodes and Timeouts\n\nGinkgo now supports per-node and per-spec timeouts on interruptible nodes.  Check out the [documentation for all the details](https://onsi.github.io/ginkgo/#spec-timeouts-and-interruptible-nodes) but the gist is you can now write specs like this:\n\n```go\nIt(\"is interruptible\", func(ctx SpecContext) { // or context.Context instead of SpecContext, both are valid.\n    // do things until `ctx.Done()` is closed, for example:\n    req, err := http.NewRequestWithContext(ctx, \"POST\", \"/build-widgets\", nil)\n    Expect(err).NotTo(HaveOccured())\n    _, err := http.DefaultClient.Do(req)\n    Expect(err).NotTo(HaveOccured())\n\n    Eventually(client.WidgetCount).WithContext(ctx).Should(Equal(17))\n}, NodeTimeout(time.Second*20), GracePeriod(5*time.Second))\n```\n\nand have Ginkgo ensure that the node completes before the timeout elapses.  If it does elapse, or if an external interrupt is received (e.g. `^C`) then Ginkgo will cancel the context and wait for the Grace Period for the node to exit before proceeding with any cleanup nodes associated with the spec.  The `ctx` provided by Ginkgo can also be passed down to Gomega's `Eventually` to have all assertions within the node governed by a single deadline.\n\n### Features\n\n- Ginkgo now records any additional failures that occur during the cleanup of a failed spec.  In prior versions this information was quietly discarded, but the introduction of a more rigorous approach to timeouts and interruptions allows Ginkgo to better track subsequent failures.\n- `SpecContext` also provides a mechanism for third-party libraries to provide additional information when a Progress Report is generated.  Gomega uses this to provide the current state of an `Eventually().WithContext()` assertion when a Progress Report is requested.\n- DescribeTable now exits with an error if it is not passed any Entries [a4c9865]\n\n## Fixes\n- fixes crashes on newer Ruby 3 installations by upgrading github-pages gem dependency [92c88d5]\n- Make the outline command able to use the DSL import [1be2427]\n\n## Maintenance\n- chore(docs): delete no meaning d [57c373c]\n- chore(docs): Fix hyperlinks [30526d5]\n- chore(docs): fix code blocks without language settings [cf611c4]\n- fix intra-doc link [b541bcb]\n\n## 2.2.0\n\n### Generate real-time Progress Reports [f91377c]\n\nGinkgo can now generate Progress Reports to point users at the current running line of code (including a preview of the actual source code) and a best guess at the most relevant subroutines.\n\nThese Progress Reports allow users to debug stuck or slow tests without exiting the Ginkgo process.  A Progress Report can be generated at any time by sending Ginkgo a `SIGINFO` (`^T` on MacOS/BSD) or `SIGUSR1`.\n\nIn addition, the user can specify `--poll-progress-after` and `--poll-progress-interval` to have Ginkgo start periodically emitting progress reports if a given node takes too long.  These can be overriden/set on a per-node basis with the `PollProgressAfter` and `PollProgressInterval` decorators.\n\nProgress Reports are emitted to stdout, and also stored in the machine-redable report formats that Ginkgo supports.\n\nGinkgo also uses this progress reporting infrastructure under the hood when handling timeouts and interrupts.  This yields much more focused, useful, and informative stack traces than previously.\n\n### Features\n- `BeforeSuite`, `AfterSuite`, `SynchronizedBeforeSuite`, `SynchronizedAfterSuite`, and `ReportAfterSuite` now support (the relevant subset of) decorators.  These can be passed in _after_ the callback functions that are usually passed into these nodes.\n\n  As a result the **signature of these methods has changed** and now includes a trailing `args ...any`.  For most users simply using the DSL, this change is transparent.  However if you were assigning one of these functions to a custom variable (or passing it around) then your code may need to change to reflect the new signature.\n\n### Maintenance\n- Modernize the invocation of Ginkgo in github actions [0ffde58]\n- Update reocmmended CI settings in docs [896bbb9]\n- Speed up unnecessarily slow integration test [6d3a90e]\n\n## 2.1.6\n\n### Fixes\n- Add `SuppressProgressReporting` decorator to turn off --progress announcements for a given node [dfef62a]\n- chore: remove duplicate word in comments [7373214]\n\n## 2.1.5\n\n### Fixes\n- drop -mod=mod instructions; fixes #1026 [6ad7138]\n- Ensure `CurrentSpecReport` and `AddReportEntry` are thread-safe [817c09b]\n- remove stale importmap gcflags flag test [3cd8b93]\n- Always emit spec summary [5cf23e2] - even when only one spec has failed\n- Fix ReportAfterSuite usage in docs [b1864ad]\n- fixed typo (#997) [219cc00]\n- TrimRight is not designed to trim Suffix [71ebb74]\n- refactor: replace strings.Replace with strings.ReplaceAll (#978) [143d208]\n- fix syntax in examples (#975) [b69554f]\n\n### Maintenance\n- Bump github.com/onsi/gomega from 1.20.0 to 1.20.1 (#1027) [e5dfce4]\n- Bump tzinfo from 1.2.9 to 1.2.10 in /docs (#1006) [7ae91c4]\n- Bump github.com/onsi/gomega from 1.19.0 to 1.20.0 (#1005) [e87a85a]\n- test: add new Go 1.19 to test matrix (#1014) [bbefe12]\n- Bump golang.org/x/tools from 0.1.11 to 0.1.12 (#1012) [9327906]\n- Bump golang.org/x/tools from 0.1.10 to 0.1.11 (#993) [f44af96]\n- Bump nokogiri from 1.13.3 to 1.13.6 in /docs (#981) [ef336aa]\n\n## 2.1.4\n\n### Fixes\n- Numerous documentation typos\n- Prepend `when` when using `When` (this behavior was in 1.x but unintentionally lost during the 2.0 rewrite) [efce903]\n- improve error message when a parallel process fails to report back [a7bd1fe]\n- guard against concurrent map writes in DeprecationTracker [0976569]\n- Invoke reporting nodes during dry-run (fixes #956 and #935) [aae4480]\n- Fix ginkgo import circle [f779385]\n\n## 2.1.3\n\nSee [https://onsi.github.io/ginkgo/MIGRATING_TO_V2](https://onsi.github.io/ginkgo/MIGRATING_TO_V2) for details on V2.\n\n### Fixes\n- Calling By in a container node now emits a useful error. [ff12cee]\n\n## 2.1.2\n\n### Fixes\n\n- Track location of focused specs correctly in `ginkgo unfocus` [a612ff1]\n- Profiling suites with focused specs no longer generates an erroneous failure message [8fbfa02]\n- Several documentation typos fixed.  Big thanks to everyone who helped catch them and report/fix them!\n\n## 2.1.1\n\nSee [https://onsi.github.io/ginkgo/MIGRATING_TO_V2](https://onsi.github.io/ginkgo/MIGRATING_TO_V2) for details on V2.\n\n### Fixes\n- Suites that only import the new dsl packages are now correctly identified as Ginkgo suites [ec17e17]\n\n## 2.1.0\n\nSee [https://onsi.github.io/ginkgo/MIGRATING_TO_V2](https://onsi.github.io/ginkgo/MIGRATING_TO_V2) for details on V2.\n\n2.1.0 is a minor release with a few tweaks:\n\n- Introduce new DSL packages to enable users to pick-and-choose which portions of the DSL to dot-import. [90868e2]  More details [here](https://onsi.github.io/ginkgo/#alternatives-to-dot-importing-ginkgo).\n- Add error check for invalid/nil parameters to DescribeTable [6f8577e]\n- Myriad docs typos fixed (thanks everyone!) [718542a, ecb7098, 146654c, a8f9913, 6bdffde, 03dcd7e]\n\n## 2.0.0\n\nSee [https://onsi.github.io/ginkgo/MIGRATING_TO_V2](https://onsi.github.io/ginkgo/MIGRATING_TO_V2)\n\n## 1.16.5\n\nGinkgo 2.0 now has a Release Candidate.  1.16.5 advertises the existence of the RC.\n1.16.5 deprecates GinkgoParallelNode in favor of GinkgoParallelProcess\n\nYou can silence the RC advertisement by setting an `ACK_GINKGO_RC=true` environment variable or creating a file in your home directory called `.ack-ginkgo-rc`\n\n## 1.16.4\n\n### Fixes\n1.16.4 retracts 1.16.3.  There are no code changes.  The 1.16.3 tag was associated with the wrong commit and an attempt to change it after-the-fact has proven problematic.  1.16.4 retracts 1.16.3 in Ginkgo's go.mod and creates a new, correctly tagged, release.\n\n## 1.16.3\n\n### Features\n- Measure is now deprecated and emits a deprecation warning.\n\n## 1.16.2\n\n### Fixes\n- Deprecations can be suppressed by setting an `ACK_GINKGO_DEPRECATIONS=<semver>` environment variable.\n\n## 1.16.1\n\n### Fixes\n- Suppress --stream deprecation warning on windows (#793)\n\n## 1.16.0\n\n### Features\n- Advertise Ginkgo 2.0.  Introduce deprecations. [9ef1913]\n    - Update README.md to advertise that Ginkgo 2.0 is coming.\n    - Backport the 2.0 DeprecationTracker and start alerting users\n    about upcoming deprecations.\n\n- Add slim-sprig template functions to bootstrap/generate (#775) [9162b86]\n\n- Fix accidental reference to 1488 (#784) [9fb7fe4]\n\n## 1.15.2\n\n### Fixes\n- ignore blank `-focus` and `-skip` flags (#780) [e90a4a0]\n\n## 1.15.1\n\n### Fixes\n- reporters/junit: Use `system-out` element instead of `passed` (#769) [9eda305]\n\n## 1.15.0\n\n### Features\n- Adds 'outline' command to print the outline of specs/containers in a file (#754) [071c369] [6803cc3] [935b538] [06744e8] [0c40583]\n- Add support for using template to generate tests (#752) [efb9e69]\n- Add a Chinese Doc #755 (#756) [5207632]\n- cli: allow multiple -focus and -skip flags (#736) [9a782fb]\n\n### Fixes\n- Add _internal to filename of tests created with internal flag (#751) [43c12da]\n\n## 1.14.2\n\n### Fixes\n- correct handling windows backslash in import path (#721) [97f3d51]\n- Add additional methods to GinkgoT() to improve compatibility with the testing.TB interface [b5fe44d]\n\n## 1.14.1\n\n### Fixes\n- Discard exported method declaration when running ginkgo bootstrap (#558) [f4b0240]\n\n## 1.14.0\n\n### Features\n- Defer running top-level container nodes until RunSpecs is called [d44dedf]\n- [Document Ginkgo lifecycle](http://onsi.github.io/ginkgo/#understanding-ginkgos-lifecycle)\n- Add `extensions/globals` package (#692) [3295c8f] - this can be helpful in contexts where you are test-driving your test-generation code (see [#692](https://github.com/onsi/ginkgo/pull/692))\n- Print Skip reason in JUnit reporter if one was provided [820dfab]\n\n## 1.13.0\n\n### Features\n- Add a version of table.Entry that allows dumping the entry parameters. (#689) [21eaef2]\n\n### Fixes\n- Ensure integration tests pass in an environment sans GOPATH [606fba2]\n- Add books package (#568) [fc0e44e]\n- doc(readme): installation via \"tools package\" (#677) [83bb20e]\n- Solve the undefined: unix.Dup2 compile error on mips64le (#680) [0624f75]\n- Import package without dot (#687) [6321024]\n- Fix integration tests to stop require GOPATH (#686) [a912ec5]\n\n## 1.12.3\n\n### Fixes\n- Print correct code location of failing table test (#666) [c6d7afb]\n\n## 1.12.2\n\n### Fixes\n- Update dependencies [ea4a036]\n\n## 1.12.1\n\n### Fixes\n- Make unfocus (\"blur\") much faster (#674) [8b18061]\n- Fix typo (#673) [7fdcbe8]\n- Test against 1.14 and remove 1.12 [d5c2ad6]\n- Test if a coverprofile content is empty before checking its latest character (#670) [14d9fa2]\n- replace tail package with maintained one. this fixes go get errors (#667) [4ba33d4]\n- improve ginkgo performance - makes progress on #644 [a14f98e]\n- fix convert integration tests [1f8ba69]\n- fix typo successful -> successful (#663) [1ea49cf]\n- Fix invalid link (#658) [b886136]\n- convert utility : Include comments from source (#657) [1077c6d]\n- Explain what BDD means [d79e7fb]\n- skip race detector test on unsupported platform (#642) [f8ab89d]\n- Use Dup2 from golang.org/x/sys/unix instead of syscallDup (#638) [5d53c55]\n- Fix missing newline in combined coverage file (#641) [6a07ea2]\n- check if a spec is run before returning SpecSummary (#645) [8850000]\n\n## 1.12.0\n\n### Features\n- Add module definition (#630) [78916ab]\n\n## 1.11.0\n\n### Features\n- Add syscall for riscv64 architecture [f66e896]\n- teamcity reporter: output location of test failure as well as test definition (#626) [9869142]\n- teamcity reporter: output newline after every service message (#625) [3cfa02d]\n- Add support for go module when running `generate` command (#578) [9c89e3f]\n\n## 1.10.3\n\n### Fixes\n- Set go_import_path in travis.yml to allow internal packages in forks (#607) [3b721db]\n- Add integration test [d90e0dc]\n- Fix coverage files combining [e5dde8c]\n- A new CLI option: -ginkgo.reportFile <file path> (#601) [034fd25]\n\n## 1.10.2\n\n### Fixes\n- speed up table entry generateIt() (#609) [5049dc5]\n- Fix. Write errors to stderr instead of stdout (#610) [7bb3091]\n\n## 1.10.1\n\n### Fixes\n- stack backtrace: fix skipping (#600) [2a4c0bd]\n\n## 1.10.0\n\n### Fixes\n- stack backtrace: fix alignment and skipping [66915d6]\n- fix typo in documentation [8f97b93]\n\n## 1.9.0\n\n### Features\n- Option to print output into report, when tests have passed [0545415]\n\n### Fixes\n- Fixed typos in comments [0ecbc58]\n- gofmt code [a7f8bfb]\n- Simplify code [7454d00]\n- Simplify concatenation, incrementation and function assignment [4825557]\n- Avoid unnecessary conversions [9d9403c]\n- JUnit: include more detailed information about panic [19cca4b]\n- Print help to stdout when the user asks for help [4cb7441]\n\n\n## 1.8.0\n\n### New Features\n- allow config of the vet flag for `go test` (#562) [3cd45fa]\n- Support projects using go modules [d56ee76]\n\n### Fixes and Minor Improvements\n- chore(godoc): fixes typos in Measurement funcs [dbaca8e]\n- Optimize focus to avoid allocations [f493786]\n- Ensure generated test file names are underscored [505cc35]\n\n## 1.7.0\n\n### New Features\n- Add JustAfterEach (#484) [0d4f080]\n\n### Fixes\n- Correctly round suite time in junit reporter [2445fc1]\n- Avoid using -i argument to go test for Golang 1.10+ [46bbc26]\n\n## 1.6.0\n\n### New Features\n- add --debug flag to emit node output to files (#499) [39febac]\n\n### Fixes\n- fix: for `go vet` to pass [69338ec]\n- docs: fix for contributing instructions [7004cb1]\n- consolidate and streamline contribution docs (#494) [d848015]\n- Make generated Junit file compatible with \"Maven Surefire\" (#488) [e51bee6]\n- all: gofmt [000d317]\n- Increase eventually timeout to 30s [c73579c]\n- Clarify asynchronous test behavior [294d8f4]\n- Travis badge should only show master [26d2143]\n\n## 1.5.0 5/10/2018\n\n### New Features\n- Supports go v1.10 (#443, #446, #451) [e873237, 468e89e, e37dbfe, a37f4c0, c0b857d, bca5260, 4177ca8]\n- Add a When() synonym for Context() (#386) [747514b, 7484dad, 7354a07, dd826c8]\n- Re-add noisySkippings flag [652e15c]\n- Allow coverage to be displayed for focused specs (#367) [11459a8]\n- Handle -outputdir flag (#364) [228e3a8]\n- Handle -coverprofile flag (#355) [43392d5]\n\n### Fixes\n- When using custom reporters register the custom reporters *before* the default reporter.  This allows users to see the output of any print statements in their customer reporters. (#365) [8382b23]\n- When running a test and calculating the coverage using the `-coverprofile` and `-outputdir` flags, Ginkgo fails with an error if the directory does not exist. This is due to an [issue in go 1.10](https://github.com/golang/go/issues/24588) (#446) [b36a6e0]\n- `unfocus` command ignores vendor folder (#459) [e5e551c, c556e43, a3b6351, 9a820dd]\n- Ignore packages whose tests are all ignored by go (#456) [7430ca7, 6d8be98]\n- Increase the threshold when checking time measurements (#455) [2f714bf, 68f622c]\n- Fix race condition in coverage tests (#423) [a5a8ff7, ab9c08b]\n- Add an extra new line after reporting spec run completion for test2json [874520d]\n- added name name field to junit reported testsuite [ae61c63]\n- Do not set the run time of a spec when the dryRun flag is used (#438) [457e2d9, ba8e856]\n- Process FWhen and FSpecify when unfocusing (#434) [9008c7b, ee65bd, df87dfe]\n- Synchronies the access to the state of specs to avoid race conditions (#430) [7d481bc, ae6829d]\n- Added Duration on GinkgoTestDescription (#383) [5f49dad, 528417e, 0747408, 329d7ed]\n- Fix Ginkgo stack trace on failure for Specify (#415) [b977ede, 65ca40e, 6c46eb8]\n- Update README with Go 1.6+, Golang -> Go (#409) [17f6b97, bc14b66, 20d1598]\n- Use fmt.Errorf instead of errors.New(fmt.Sprintf (#401) [a299f56, 44e2eaa]\n- Imports in generated code should follow conventions (#398) [0bec0b0, e8536d8]\n- Prevent data race error when Recording a benchmark value from multiple go routines (#390) [c0c4881, 7a241e9]\n- Replace GOPATH in Environment [4b883f0]\n\n\n## 1.4.0 7/16/2017\n\n- `ginkgo` now provides a hint if you accidentally forget to run `ginkgo bootstrap` to generate a `*_suite_test.go` file that actually invokes the Ginkgo test runner. [#345](https://github.com/onsi/ginkgo/pull/345)\n- thanks to improvements in `go test -c` `ginkgo` no longer needs to fix Go's compilation output to ensure compilation errors are expressed relative to the CWD. [#357]\n- `ginkgo watch -watchRegExp=...` allows you to specify a custom regular expression to watch.  Only files matching the regular expression are watched for changes (the default is `\\.go$`) [#356]\n- `ginkgo` now always emits compilation output.  Previously, only failed compilation output was printed out. [#277]\n- `ginkgo -requireSuite` now fails the test run if there are `*_test.go` files but `go test` fails to detect any tests.  Typically this means you forgot to run `ginkgo bootstrap` to generate a suite file. [#344]\n- `ginkgo -timeout=DURATION` allows you to adjust the timeout for the entire test suite (default is 24 hours) [#248]\n\n## 1.3.0 3/28/2017\n\nImprovements:\n\n- Significantly improved parallel test distribution.  Now instead of pre-sharding test cases across workers (which can result in idle workers and poor test performance) Ginkgo uses a shared queue to keep all workers busy until all tests are complete.  This improves test-time performance and consistency.\n- `Skip(message)` can be used to skip the current test.\n- Added `extensions/table` - a Ginkgo DSL for [Table Driven Tests](http://onsi.github.io/ginkgo/#table-driven-tests)\n- Add `GinkgoRandomSeed()` - shorthand for `config.GinkgoConfig.RandomSeed`\n- Support for retrying flaky tests with `--flakeAttempts`\n- `ginkgo ./...` now recurses as you'd expect\n- Added `Specify` a synonym for `It`\n- Support colorise on Windows\n- Broader support for various go compilation flags in the `ginkgo` CLI\n\nBug Fixes:\n\n- Ginkgo tests now fail when you `panic(nil)` (#167)\n\n## 1.2.0 5/31/2015\n\nImprovements\n\n- `ginkgo -coverpkg` calls down to `go test -coverpkg` (#160)\n- `ginkgo -afterSuiteHook COMMAND` invokes the passed-in `COMMAND` after a test suite completes (#152)\n- Relaxed requirement for Go 1.4+.  `ginkgo` now works with Go v1.3+ (#166)\n\n## 1.2.0-beta\n\nGinkgo now requires Go 1.4+\n\nImprovements:\n\n- Call reporters in reverse order when announcing spec completion -- allows custom reporters to emit output before the default reporter does.\n- Improved focus behavior.  Now, this:\n\n    ```golang\n    FDescribe(\"Some describe\", func() {\n        It(\"A\", func() {})\n\n        FIt(\"B\", func() {})\n    })\n    ```\n\n  will run `B` but *not* `A`.  This tends to be a common usage pattern when in the thick of writing and debugging tests.\n- When `SIGINT` is received, Ginkgo will emit the contents of the `GinkgoWriter` before running the `AfterSuite`.  Useful for debugging stuck tests.\n- When `--progress` is set, Ginkgo will write test progress (in particular, Ginkgo will say when it is about to run a BeforeEach, AfterEach, It, etc...) to the `GinkgoWriter`.  This is useful for debugging stuck tests and tests that generate many logs.\n- Improved output when an error occurs in a setup or teardown block.\n- When `--dryRun` is set, Ginkgo will walk the spec tree and emit to its reporter *without* actually running anything.  Best paired with `-v` to understand which specs will run in which order.\n- Add `By` to help document long `It`s.  `By` simply writes to the `GinkgoWriter`.\n- Add support for precompiled tests:\n    - `ginkgo build <path-to-package>` will now compile the package, producing a file named `package.test`\n    - The compiled `package.test` file can be run directly.  This runs the tests in series.\n    - To run precompiled tests in parallel, you can run: `ginkgo -p package.test`\n- Support `bootstrap`ping and `generate`ing [Agouti](http://agouti.org) specs.\n- `ginkgo generate` and `ginkgo bootstrap` now honor the package name already defined in a given directory\n- The `ginkgo` CLI ignores `SIGQUIT`.  Prevents its stack dump from interlacing with the underlying test suite's stack dump.\n- The `ginkgo` CLI now compiles tests into a temporary directory instead of the package directory.  This necessitates upgrading to Go v1.4+.\n- `ginkgo -notify` now works on Linux\n\nBug Fixes:\n\n- If --skipPackages is used and all packages are skipped, Ginkgo should exit 0.\n- Fix tempfile leak when running in parallel\n- Fix incorrect failure message when a panic occurs during a parallel test run\n- Fixed an issue where a pending test within a focused context (or a focused test within a pending context) would skip all other tests.\n- Be more consistent about handling SIGTERM as well as SIGINT\n- When interrupted while concurrently compiling test suites in the background, Ginkgo now cleans up the compiled artifacts.\n- Fixed a long standing bug where `ginkgo -p` would hang if a process spawned by one of the Ginkgo parallel nodes does not exit. (Hooray!)\n\n## 1.1.0 (8/2/2014)\n\nNo changes, just dropping the beta.\n\n## 1.1.0-beta (7/22/2014)\nNew Features:\n\n- `ginkgo watch` now monitors packages *and their dependencies* for changes.  The depth of the dependency tree can be modified with the `-depth` flag.\n- Test suites with a programmatic focus (`FIt`, `FDescribe`, etc...) exit with non-zero status code, even when they pass.  This allows CI systems to detect accidental commits of focused test suites.\n- `ginkgo -p` runs the testsuite in parallel with an auto-detected number of nodes.\n- `ginkgo -tags=TAG_LIST` passes a list of tags down to the `go build` command.\n- `ginkgo --failFast` aborts the test suite after the first failure.\n- `ginkgo generate file_1 file_2` can take multiple file arguments.\n- Ginkgo now summarizes any spec failures that occurred at the end of the test run.\n- `ginkgo --randomizeSuites` will run tests *suites* in random order using the generated/passed-in seed.\n\nImprovements:\n\n- `ginkgo -skipPackage` now takes a comma-separated list of strings.  If the *relative path* to a package matches one of the entries in the comma-separated list, that package is skipped.\n- `ginkgo --untilItFails` no longer recompiles between attempts.\n- Ginkgo now panics when a runnable node (`It`, `BeforeEach`, `JustBeforeEach`, `AfterEach`, `Measure`) is nested within another runnable node.  This is always a mistake.  Any test suites that panic because of this change should be fixed.\n\nBug Fixes:\n\n- `ginkgo boostrap` and `ginkgo generate` no longer fail when dealing with `hyphen-separated-packages`.\n- parallel specs are now better distributed across nodes - fixed a crashing bug where (for example) distributing 11 tests across 7 nodes would panic\n\n## 1.0.0 (5/24/2014)\nNew Features:\n\n- Add `GinkgoParallelNode()` - shorthand for `config.GinkgoConfig.ParallelNode`\n\nImprovements:\n\n- When compilation fails, the compilation output is rewritten to present a correct *relative* path.  Allows ⌘-clicking in iTerm open the file in your text editor.\n- `--untilItFails` and `ginkgo watch` now generate new random seeds between test runs, unless a particular random seed is specified.\n\nBug Fixes:\n\n- `-cover` now generates a correctly combined coverprofile when running with in parallel with multiple `-node`s.\n- Print out the contents of the `GinkgoWriter` when `BeforeSuite` or `AfterSuite` fail.\n- Fix all remaining race conditions in Ginkgo's test suite.\n\n## 1.0.0-beta (4/14/2014)\nBreaking changes:\n\n- `thirdparty/gomocktestreporter` is gone.  Use `GinkgoT()` instead\n- Modified the Reporter interface\n- `watch` is now a subcommand, not a flag.\n\nDSL changes:\n\n- `BeforeSuite` and `AfterSuite` for setting up and tearing down test suites.\n- `AfterSuite` is triggered on interrupt (`^C`) as well as exit.\n- `SynchronizedBeforeSuite` and `SynchronizedAfterSuite` for setting up and tearing down singleton resources across parallel nodes.\n\nCLI changes:\n\n- `watch` is now a subcommand, not a flag\n- `--nodot` flag can be passed to `ginkgo generate` and `ginkgo bootstrap` to avoid dot imports.  This explicitly imports all exported identifiers in Ginkgo and Gomega.  Refreshing this list can be done by running `ginkgo nodot`\n- Additional arguments can be passed to specs.  Pass them after the `--` separator\n- `--skipPackage` flag takes a regexp and ignores any packages with package names passing said regexp.\n- `--trace` flag prints out full stack traces when errors occur, not just the line at which the error occurs.\n\nMisc:\n\n- Start using semantic versioning\n- Start maintaining changelog\n\nMajor refactor:\n\n- Pull out Ginkgo's internal to `internal`\n- Rename `example` everywhere to `spec`\n- Much more!\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.9111328125,
          "content": "# Contributing to Ginkgo\n\nYour contributions to Ginkgo are essential for its long-term maintenance and improvement.\n\n- Please **open an issue first** - describe what problem you are trying to solve and give the community a forum for input and feedback ahead of investing time in writing code!\n- Ensure adequate test coverage:\n    - When adding to the Ginkgo library, add unit and/or integration tests (under the `integration` folder).\n    - When adding to the Ginkgo CLI, note that there are very few unit tests.  Please add an integration test.\n- Run `make` or:\n  - Install ginkgo locally via `go install ./...`\n  - Make sure all the tests succeed via `ginkgo -r -p`\n  - Vet your changes via `go vet ./...`\n- Update the documentation. Ginkgo uses `godoc` comments and documentation in `docs/index.md`.  You can run `bundle && bundle exec jekyll serve` in the `docs` directory to preview your changes.\n\nThanks for supporting Ginkgo!\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.037109375,
          "content": "Copyright (c) 2013-2014 Onsi Fakhouri\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.2421875,
          "content": "# default task since it's first\n.PHONY: all\nall:  vet test\n\n.PHONY: test\ntest:\n\tgo run github.com/onsi/ginkgo/v2/ginkgo -r -p -randomize-all -keep-going\n\n.PHONY: vet\nvet:\n\tgo vet ./...\n\n.PHONY: update-deps\nupdate-deps:\n\tgo get -u ./...\n\tgo mod tidy"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.3701171875,
          "content": "![Ginkgo](https://onsi.github.io/ginkgo/images/ginkgo.png)\n\n[![test](https://github.com/onsi/ginkgo/workflows/test/badge.svg?branch=master)](https://github.com/onsi/ginkgo/actions?query=workflow%3Atest+branch%3Amaster) | [Ginkgo Docs](https://onsi.github.io/ginkgo/)\n\n---\n\n# Ginkgo\n\nGinkgo is a mature testing framework for Go designed to help you write expressive specs.  Ginkgo builds on top of Go's `testing` foundation and is complemented by the [Gomega](https://github.com/onsi/gomega) matcher library.  Together, Ginkgo and Gomega let you express the intent behind your specs clearly:\n\n```go\nimport (\n    . \"github.com/onsi/ginkgo/v2\"\n    . \"github.com/onsi/gomega\"\n    ...\n)\n\nvar _ = Describe(\"Checking books out of the library\", Label(\"library\"), func() {\n    var library *libraries.Library\n    var book *books.Book\n    var valjean *users.User\n    BeforeEach(func() {\n        library = libraries.NewClient()\n        book = &books.Book{\n            Title: \"Les Miserables\",\n            Author: \"Victor Hugo\",\n        }\n        valjean = users.NewUser(\"Jean Valjean\")\n    })\n\n    When(\"the library has the book in question\", func() {\n        BeforeEach(func(ctx SpecContext) {\n            Expect(library.Store(ctx, book)).To(Succeed())\n        })\n\n        Context(\"and the book is available\", func() {\n            It(\"lends it to the reader\", func(ctx SpecContext) {\n                Expect(valjean.Checkout(ctx, library, \"Les Miserables\")).To(Succeed())\n                Expect(valjean.Books()).To(ContainElement(book))\n                Expect(library.UserWithBook(ctx, book)).To(Equal(valjean))\n            }, SpecTimeout(time.Second * 5))\n        })\n\n        Context(\"but the book has already been checked out\", func() {\n            var javert *users.User\n            BeforeEach(func(ctx SpecContext) {\n                javert = users.NewUser(\"Javert\")\n                Expect(javert.Checkout(ctx, library, \"Les Miserables\")).To(Succeed())\n            })\n\n            It(\"tells the user\", func(ctx SpecContext) {\n                err := valjean.Checkout(ctx, library, \"Les Miserables\")\n                Expect(err).To(MatchError(\"Les Miserables is currently checked out\"))\n            }, SpecTimeout(time.Second * 5))\n\n            It(\"lets the user place a hold and get notified later\", func(ctx SpecContext) {\n                Expect(valjean.Hold(ctx, library, \"Les Miserables\")).To(Succeed())\n                Expect(valjean.Holds(ctx)).To(ContainElement(book))\n\n                By(\"when Javert returns the book\")\n                Expect(javert.Return(ctx, library, book)).To(Succeed())\n\n                By(\"it eventually informs Valjean\")\n                notification := \"Les Miserables is ready for pick up\"\n                Eventually(ctx, valjean.Notifications).Should(ContainElement(notification))\n\n                Expect(valjean.Checkout(ctx, library, \"Les Miserables\")).To(Succeed())\n                Expect(valjean.Books(ctx)).To(ContainElement(book))\n                Expect(valjean.Holds(ctx)).To(BeEmpty())\n            }, SpecTimeout(time.Second * 10))\n        })  \n    })\n\n    When(\"the library does not have the book in question\", func() {\n        It(\"tells the reader the book is unavailable\", func(ctx SpecContext) {\n            err := valjean.Checkout(ctx, library, \"Les Miserables\")\n            Expect(err).To(MatchError(\"Les Miserables is not in the library catalog\"))\n        }, SpecTimeout(time.Second * 5))\n    })\n})\n```\n\nJump to the [docs](https://onsi.github.io/ginkgo/) to learn more.  It's easy to [bootstrap](https://onsi.github.io/ginkgo/#bootstrapping-a-suite) and start writing your [first specs](https://onsi.github.io/ginkgo/#adding-specs-to-a-suite).\n\nIf you have a question, comment, bug report, feature request, etc. please open a [GitHub issue](https://github.com/onsi/ginkgo/issues/new), or visit the [Ginkgo Slack channel](https://app.slack.com/client/T029RQSE6/CQQ50BBNW).\n\n## Capabilities\n\nWhether writing basic unit specs, complex integration specs, or even performance specs - Ginkgo gives you an expressive Domain-Specific Language (DSL) that will be familiar to users coming from frameworks such as [Quick](https://github.com/Quick/Quick), [RSpec](https://rspec.info), [Jasmine](https://jasmine.github.io), and [Busted](https://lunarmodules.github.io/busted/).  This style of testing is sometimes referred to as \"Behavior-Driven Development\" (BDD) though Ginkgo's utility extends beyond acceptance-level testing.\n\nWith Ginkgo's DSL you can use nestable [`Describe`, `Context` and `When` container nodes](https://onsi.github.io/ginkgo/#organizing-specs-with-container-nodes) to help you organize your specs.  [`BeforeEach` and `AfterEach` setup nodes](https://onsi.github.io/ginkgo/#extracting-common-setup-beforeeach) for setup and cleanup.  [`It` and `Specify` subject nodes](https://onsi.github.io/ginkgo/#spec-subjects-it) that hold your assertions. [`BeforeSuite` and `AfterSuite` nodes](https://onsi.github.io/ginkgo/#suite-setup-and-cleanup-beforesuite-and-aftersuite) to prep for and cleanup after a suite... and [much more!](https://onsi.github.io/ginkgo/#writing-specs).\n\nAt runtime, Ginkgo can run your specs in reproducibly [random order](https://onsi.github.io/ginkgo/#spec-randomization) and has sophisticated support for [spec parallelization](https://onsi.github.io/ginkgo/#spec-parallelization).  In fact, running specs in parallel is as easy as\n\n```bash\nginkgo -p\n```\n\nBy following [established patterns for writing parallel specs](https://onsi.github.io/ginkgo/#patterns-for-parallel-integration-specs) you can build even large, complex integration suites that parallelize cleanly and run performantly.  And you don't have to worry about your spec suite hanging or leaving a mess behind - Ginkgo provides a per-node `context.Context` and the capability to interrupt the spec after a set period of time - and then clean up.\n\nAs your suites grow Ginkgo helps you keep your specs organized with [labels](https://onsi.github.io/ginkgo/#spec-labels) and lets you easily run [subsets of specs](https://onsi.github.io/ginkgo/#filtering-specs), either [programmatically](https://onsi.github.io/ginkgo/#focused-specs) or on the [command line](https://onsi.github.io/ginkgo/#combining-filters).  And Ginkgo's reporting infrastructure generates machine-readable output in a [variety of formats](https://onsi.github.io/ginkgo/#generating-machine-readable-reports) _and_ allows you to build your own [custom reporting infrastructure](https://onsi.github.io/ginkgo/#generating-reports-programmatically).\n\nGinkgo ships with `ginkgo`, a [command line tool](https://onsi.github.io/ginkgo/#ginkgo-cli-overview) with support for generating, running, filtering, and profiling Ginkgo suites.  You can even have Ginkgo automatically run your specs when it detects a change with `ginkgo watch`, enabling rapid feedback loops during test-driven development.\n\nAnd that's just Ginkgo!  [Gomega](https://onsi.github.io/gomega/) brings a rich, mature, family of [assertions and matchers](https://onsi.github.io/gomega/#provided-matchers) to your suites.  With Gomega you can easily mix [synchronous and asynchronous assertions](https://onsi.github.io/ginkgo/#patterns-for-asynchronous-testing) in your specs.  You can even build your own set of expressive domain-specific matchers quickly and easily by composing Gomega's [existing building blocks](https://onsi.github.io/ginkgo/#building-custom-matchers).\n\nHappy Testing!\n\n## License\n\nGinkgo is MIT-Licensed\n\n## Contributing\n\nSee [CONTRIBUTING.md](CONTRIBUTING.md)\n"
        },
        {
          "name": "RELEASING.md",
          "type": "blob",
          "size": 0.837890625,
          "content": "A Ginkgo release is a tagged git sha and a GitHub release.  To cut a release:\n\n1. Ensure CHANGELOG.md is up to date.\n  - Use \n    ```bash\n    LAST_VERSION=$(git tag --sort=version:refname | tail -n1)\n    CHANGES=$(git log --pretty=format:'- %s [%h]' HEAD...$LAST_VERSION)\n    echo -e \"## NEXT\\n\\n$CHANGES\\n\\n### Features\\n\\n### Fixes\\n\\n### Maintenance\\n\\n$(cat CHANGELOG.md)\" > CHANGELOG.md\n    ```\n   to update the changelog\n  - Categorize the changes into\n    - Breaking Changes (requires a major version)\n    - New Features (minor version)\n    - Fixes (fix version)\n    - Maintenance (which in general should not be mentioned in `CHANGELOG.md` as they have no user impact)\n1. Update `VERSION` in `types/version.go`\n1. Commit, push, and release:\n  ```\n  git commit -m \"vM.m.p\"\n  git push\n  gh release create \"vM.m.p\"\n  git fetch --tags origin master\n  ```"
        },
        {
          "name": "config",
          "type": "tree",
          "content": null
        },
        {
          "name": "core_dsl.go",
          "type": "blob",
          "size": 36.05859375,
          "content": "/*\nGinkgo is a testing framework for Go designed to help you write expressive tests.\nhttps://github.com/onsi/ginkgo\nMIT-Licensed\n\nThe godoc documentation outlines Ginkgo's API.  Since Ginkgo is a Domain-Specific Language it is important to\nbuild a mental model for Ginkgo - the narrative documentation at https://onsi.github.io/ginkgo/ is designed to help you do that.\nYou should start there - even a brief skim will be helpful.  At minimum you should skim through the https://onsi.github.io/ginkgo/#getting-started chapter.\n\nGinkgo's is best paired with the Gomega matcher library: https://github.com/onsi/gomega\n\nYou can run Ginkgo specs with go test - however we recommend using the ginkgo cli.  It enables functionality\nthat go test does not (especially running suites in parallel).  You can learn more at https://onsi.github.io/ginkgo/#ginkgo-cli-overview\nor by running 'ginkgo help'.\n*/\npackage ginkgo\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/go-logr/logr\"\n\t\"github.com/onsi/ginkgo/v2/formatter\"\n\t\"github.com/onsi/ginkgo/v2/internal\"\n\t\"github.com/onsi/ginkgo/v2/internal/global\"\n\t\"github.com/onsi/ginkgo/v2/internal/interrupt_handler\"\n\t\"github.com/onsi/ginkgo/v2/internal/parallel_support\"\n\t\"github.com/onsi/ginkgo/v2/reporters\"\n\t\"github.com/onsi/ginkgo/v2/types\"\n)\n\nconst GINKGO_VERSION = types.VERSION\n\nvar flagSet types.GinkgoFlagSet\nvar deprecationTracker = types.NewDeprecationTracker()\nvar suiteConfig = types.NewDefaultSuiteConfig()\nvar reporterConfig = types.NewDefaultReporterConfig()\nvar suiteDidRun = false\nvar outputInterceptor internal.OutputInterceptor\nvar client parallel_support.Client\n\nfunc init() {\n\tvar err error\n\tflagSet, err = types.BuildTestSuiteFlagSet(&suiteConfig, &reporterConfig)\n\texitIfErr(err)\n\twriter := internal.NewWriter(os.Stdout)\n\tGinkgoWriter = writer\n\tGinkgoLogr = internal.GinkgoLogrFunc(writer)\n}\n\nfunc exitIfErr(err error) {\n\tif err != nil {\n\t\tif outputInterceptor != nil {\n\t\t\toutputInterceptor.Shutdown()\n\t\t}\n\t\tif client != nil {\n\t\t\tclient.Close()\n\t\t}\n\t\tfmt.Fprintln(formatter.ColorableStdErr, err.Error())\n\t\tos.Exit(1)\n\t}\n}\n\nfunc exitIfErrors(errors []error) {\n\tif len(errors) > 0 {\n\t\tif outputInterceptor != nil {\n\t\t\toutputInterceptor.Shutdown()\n\t\t}\n\t\tif client != nil {\n\t\t\tclient.Close()\n\t\t}\n\t\tfor _, err := range errors {\n\t\t\tfmt.Fprintln(formatter.ColorableStdErr, err.Error())\n\t\t}\n\t\tos.Exit(1)\n\t}\n}\n\n// The interface implemented by GinkgoWriter\ntype GinkgoWriterInterface interface {\n\tio.Writer\n\n\tPrint(a ...any)\n\tPrintf(format string, a ...any)\n\tPrintln(a ...any)\n\n\tTeeTo(writer io.Writer)\n\tClearTeeWriters()\n}\n\n/*\nSpecContext is the context object passed into nodes that are subject to a timeout or need to be notified of an interrupt.  It implements the standard context.Context interface but also contains additional helpers to provide an extensibility point for Ginkgo.  (As an example, Gomega's Eventually can use the methods defined on SpecContext to provide deeper integration with Ginkgo).\n\nYou can do anything with SpecContext that you do with a typical context.Context including wrapping it with any of the context.With* methods.\n\nGinkgo will cancel the SpecContext when a node is interrupted (e.g. by the user sending an interrupt signal) or when a node has exceeded its allowed run-time.  Note, however, that even in cases where a node has a deadline, SpecContext will not return a deadline via .Deadline().  This is because Ginkgo does not use a WithDeadline() context to model node deadlines as Ginkgo needs control over the precise timing of the context cancellation to ensure it can provide an accurate progress report at the moment of cancellation.\n*/\ntype SpecContext = internal.SpecContext\n\n/*\nGinkgoWriter implements a GinkgoWriterInterface and io.Writer\n\nWhen running in verbose mode (ginkgo -v) any writes to GinkgoWriter will be immediately printed\nto stdout.  Otherwise, GinkgoWriter will buffer any writes produced during the current test and flush them to screen\nonly if the current test fails.\n\nGinkgoWriter also provides convenience Print, Printf and Println methods and allows you to tee to a custom writer via GinkgoWriter.TeeTo(writer).\nWrites to GinkgoWriter are immediately sent to any registered TeeTo() writers.  You can unregister all TeeTo() Writers with GinkgoWriter.ClearTeeWriters()\n\nYou can learn more at https://onsi.github.io/ginkgo/#logging-output\n*/\nvar GinkgoWriter GinkgoWriterInterface\n\n/*\nGinkgoLogr is a logr.Logger that writes to GinkgoWriter\n*/\nvar GinkgoLogr logr.Logger\n\n// The interface by which Ginkgo receives *testing.T\ntype GinkgoTestingT interface {\n\tFail()\n}\n\n/*\nGinkgoConfiguration returns the configuration of the current suite.\n\nThe first return value is the SuiteConfig which controls aspects of how the suite runs,\nthe second return value is the ReporterConfig which controls aspects of how Ginkgo's default\nreporter emits output.\n\nMutating the returned configurations has no effect.  To reconfigure Ginkgo programmatically you need\nto pass in your mutated copies into RunSpecs().\n\nYou can learn more at https://onsi.github.io/ginkgo/#overriding-ginkgos-command-line-configuration-in-the-suite\n*/\nfunc GinkgoConfiguration() (types.SuiteConfig, types.ReporterConfig) {\n\treturn suiteConfig, reporterConfig\n}\n\n/*\nGinkgoRandomSeed returns the seed used to randomize spec execution order.  It is\nuseful for seeding your own pseudorandom number generators to ensure\nconsistent executions from run to run, where your tests contain variability (for\nexample, when selecting random spec data).\n\nYou can learn more at https://onsi.github.io/ginkgo/#spec-randomization\n*/\nfunc GinkgoRandomSeed() int64 {\n\treturn suiteConfig.RandomSeed\n}\n\n/*\nGinkgoParallelProcess returns the parallel process number for the current ginkgo process\nThe process number is 1-indexed.  You can use GinkgoParallelProcess() to shard access to shared\nresources across your suites.  You can learn more about patterns for sharding at https://onsi.github.io/ginkgo/#patterns-for-parallel-integration-specs\n\nFor more on how specs are parallelized in Ginkgo, see http://onsi.github.io/ginkgo/#spec-parallelization\n*/\nfunc GinkgoParallelProcess() int {\n\treturn suiteConfig.ParallelProcess\n}\n\n/*\nGinkgoHelper marks the function it's called in as a test helper.  When a failure occurs inside a helper function, Ginkgo will skip the helper when analyzing the stack trace to identify where the failure occurred.\n\nThis is an alternative, simpler, mechanism to passing in a skip offset when calling Fail or using Gomega.\n*/\nfunc GinkgoHelper() {\n\ttypes.MarkAsHelper(1)\n}\n\n/*\nGinkgoLabelFilter() returns the label filter configured for this suite via `--label-filter`.\n\nYou can use this to manually check if a set of labels would satisfy the filter via:\n\n\tif (Label(\"cat\", \"dog\").MatchesLabelFilter(GinkgoLabelFilter())) {\n\t\t//...\n\t}\n*/\nfunc GinkgoLabelFilter() string {\n\tsuiteConfig, _ := GinkgoConfiguration()\n\treturn suiteConfig.LabelFilter\n}\n\n/*\nPauseOutputInterception() pauses Ginkgo's output interception.  This is only relevant\nwhen running in parallel and output to stdout/stderr is being intercepted.  You generally\ndon't need to call this function - however there are cases when Ginkgo's output interception\nmechanisms can interfere with external processes launched by the test process.\n\nIn particular, if an external process is launched that has cmd.Stdout/cmd.Stderr set to os.Stdout/os.Stderr\nthen Ginkgo's output interceptor will hang.  To circumvent this, set cmd.Stdout/cmd.Stderr to GinkgoWriter.\nIf, for some reason, you aren't able to do that, you can PauseOutputInterception() before starting the process\nthen ResumeOutputInterception() after starting it.\n\nNote that PauseOutputInterception() does not cause stdout writes to print to the console -\nthis simply stops intercepting and storing stdout writes to an internal buffer.\n*/\nfunc PauseOutputInterception() {\n\tif outputInterceptor == nil {\n\t\treturn\n\t}\n\toutputInterceptor.PauseIntercepting()\n}\n\n// ResumeOutputInterception() - see docs for PauseOutputInterception()\nfunc ResumeOutputInterception() {\n\tif outputInterceptor == nil {\n\t\treturn\n\t}\n\toutputInterceptor.ResumeIntercepting()\n}\n\n/*\nRunSpecs is the entry point for the Ginkgo spec runner.\n\nYou must call this within a Golang testing TestX(t *testing.T) function.\nIf you bootstrapped your suite with \"ginkgo bootstrap\" this is already\ndone for you.\n\nGinkgo is typically configured via command-line flags.  This configuration\ncan be overridden, however, and passed into RunSpecs as optional arguments:\n\n\tfunc TestMySuite(t *testing.T)  {\n\t\tRegisterFailHandler(gomega.Fail)\n\t\t// fetch the current config\n\t\tsuiteConfig, reporterConfig := GinkgoConfiguration()\n\t\t// adjust it\n\t\tsuiteConfig.SkipStrings = []string{\"NEVER-RUN\"}\n\t\treporterConfig.FullTrace = true\n\t\t// pass it in to RunSpecs\n\t\tRunSpecs(t, \"My Suite\", suiteConfig, reporterConfig)\n\t}\n\nNote that some configuration changes can lead to undefined behavior.  For example,\nyou should not change ParallelProcess or ParallelTotal as the Ginkgo CLI is responsible\nfor setting these and orchestrating parallel specs across the parallel processes.  See http://onsi.github.io/ginkgo/#spec-parallelization\nfor more on how specs are parallelized in Ginkgo.\n\nYou can also pass suite-level Label() decorators to RunSpecs.  The passed-in labels will apply to all specs in the suite.\n*/\nfunc RunSpecs(t GinkgoTestingT, description string, args ...any) bool {\n\tif suiteDidRun {\n\t\texitIfErr(types.GinkgoErrors.RerunningSuite())\n\t}\n\tsuiteDidRun = true\n\terr := global.PushClone()\n\tif err != nil {\n\t\texitIfErr(err)\n\t}\n\tdefer global.PopClone()\n\n\tsuiteLabels := extractSuiteConfiguration(args)\n\n\tvar reporter reporters.Reporter\n\tif suiteConfig.ParallelTotal == 1 {\n\t\treporter = reporters.NewDefaultReporter(reporterConfig, formatter.ColorableStdOut)\n\t\toutputInterceptor = internal.NoopOutputInterceptor{}\n\t\tclient = nil\n\t} else {\n\t\treporter = reporters.NoopReporter{}\n\t\tswitch strings.ToLower(suiteConfig.OutputInterceptorMode) {\n\t\tcase \"swap\":\n\t\t\toutputInterceptor = internal.NewOSGlobalReassigningOutputInterceptor()\n\t\tcase \"none\":\n\t\t\toutputInterceptor = internal.NoopOutputInterceptor{}\n\t\tdefault:\n\t\t\toutputInterceptor = internal.NewOutputInterceptor()\n\t\t}\n\t\tclient = parallel_support.NewClient(suiteConfig.ParallelHost)\n\t\tif !client.Connect() {\n\t\t\tclient = nil\n\t\t\texitIfErr(types.GinkgoErrors.UnreachableParallelHost(suiteConfig.ParallelHost))\n\t\t}\n\t\tdefer client.Close()\n\t}\n\n\twriter := GinkgoWriter.(*internal.Writer)\n\tif reporterConfig.Verbosity().GTE(types.VerbosityLevelVerbose) && suiteConfig.ParallelTotal == 1 {\n\t\twriter.SetMode(internal.WriterModeStreamAndBuffer)\n\t} else {\n\t\twriter.SetMode(internal.WriterModeBufferOnly)\n\t}\n\n\tif reporterConfig.WillGenerateReport() {\n\t\tregisterReportAfterSuiteNodeForAutogeneratedReports(reporterConfig)\n\t}\n\n\terr = global.Suite.BuildTree()\n\texitIfErr(err)\n\tsuitePath, err := getwd()\n\texitIfErr(err)\n\tsuitePath, err = filepath.Abs(suitePath)\n\texitIfErr(err)\n\n\tpassed, hasFocusedTests := global.Suite.Run(description, suiteLabels, suitePath, global.Failer, reporter, writer, outputInterceptor, interrupt_handler.NewInterruptHandler(client), client, internal.RegisterForProgressSignal, suiteConfig)\n\toutputInterceptor.Shutdown()\n\n\tflagSet.ValidateDeprecations(deprecationTracker)\n\tif deprecationTracker.DidTrackDeprecations() {\n\t\tfmt.Fprintln(formatter.ColorableStdErr, deprecationTracker.DeprecationsReport())\n\t}\n\n\tif !passed {\n\t\tt.Fail()\n\t}\n\n\tif passed && hasFocusedTests && strings.TrimSpace(os.Getenv(\"GINKGO_EDITOR_INTEGRATION\")) == \"\" {\n\t\tfmt.Println(\"PASS | FOCUSED\")\n\t\tos.Exit(types.GINKGO_FOCUS_EXIT_CODE)\n\t}\n\treturn passed\n}\n\nfunc extractSuiteConfiguration(args []any) Labels {\n\tsuiteLabels := Labels{}\n\tconfigErrors := []error{}\n\tfor _, arg := range args {\n\t\tswitch arg := arg.(type) {\n\t\tcase types.SuiteConfig:\n\t\t\tsuiteConfig = arg\n\t\tcase types.ReporterConfig:\n\t\t\treporterConfig = arg\n\t\tcase Labels:\n\t\t\tsuiteLabels = append(suiteLabels, arg...)\n\t\tdefault:\n\t\t\tconfigErrors = append(configErrors, types.GinkgoErrors.UnknownTypePassedToRunSpecs(arg))\n\t\t}\n\t}\n\texitIfErrors(configErrors)\n\n\tconfigErrors = types.VetConfig(flagSet, suiteConfig, reporterConfig)\n\tif len(configErrors) > 0 {\n\t\tfmt.Fprintf(formatter.ColorableStdErr, formatter.F(\"{{red}}Ginkgo detected configuration issues:{{/}}\\n\"))\n\t\tfor _, err := range configErrors {\n\t\t\tfmt.Fprintf(formatter.ColorableStdErr, err.Error())\n\t\t}\n\t\tos.Exit(1)\n\t}\n\n\treturn suiteLabels\n}\n\nfunc getwd() (string, error) {\n\tif !strings.EqualFold(os.Getenv(\"GINKGO_PRESERVE_CACHE\"), \"true\") {\n\t\t// Getwd calls os.Getenv(\"PWD\"), which breaks test caching if the cache\n\t\t// is shared between two different directories with the same test code.\n\t\treturn os.Getwd()\n\t}\n\treturn \"\", nil\n}\n\n/*\nPreviewSpecs walks the testing tree and produces a report without actually invoking the specs.\nSee http://onsi.github.io/ginkgo/#previewing-specs for more information.\n*/\nfunc PreviewSpecs(description string, args ...any) Report {\n\terr := global.PushClone()\n\tif err != nil {\n\t\texitIfErr(err)\n\t}\n\tdefer global.PopClone()\n\n\tsuiteLabels := extractSuiteConfiguration(args)\n\tpriorDryRun, priorParallelTotal, priorParallelProcess := suiteConfig.DryRun, suiteConfig.ParallelTotal, suiteConfig.ParallelProcess\n\tsuiteConfig.DryRun, suiteConfig.ParallelTotal, suiteConfig.ParallelProcess = true, 1, 1\n\tdefer func() {\n\t\tsuiteConfig.DryRun, suiteConfig.ParallelTotal, suiteConfig.ParallelProcess = priorDryRun, priorParallelTotal, priorParallelProcess\n\t}()\n\treporter := reporters.NoopReporter{}\n\toutputInterceptor = internal.NoopOutputInterceptor{}\n\tclient = nil\n\twriter := GinkgoWriter.(*internal.Writer)\n\n\terr = global.Suite.BuildTree()\n\texitIfErr(err)\n\tsuitePath, err := getwd()\n\texitIfErr(err)\n\tsuitePath, err = filepath.Abs(suitePath)\n\texitIfErr(err)\n\n\tglobal.Suite.Run(description, suiteLabels, suitePath, global.Failer, reporter, writer, outputInterceptor, interrupt_handler.NewInterruptHandler(client), client, internal.RegisterForProgressSignal, suiteConfig)\n\n\treturn global.Suite.GetPreviewReport()\n}\n\n/*\nSkip instructs Ginkgo to skip the current spec\n\nYou can call Skip in any Setup or Subject node closure.\n\nFor more on how to filter specs in Ginkgo see https://onsi.github.io/ginkgo/#filtering-specs\n*/\nfunc Skip(message string, callerSkip ...int) {\n\tskip := 0\n\tif len(callerSkip) > 0 {\n\t\tskip = callerSkip[0]\n\t}\n\tcl := types.NewCodeLocationWithStackTrace(skip + 1)\n\tglobal.Failer.Skip(message, cl)\n\tpanic(types.GinkgoErrors.UncaughtGinkgoPanic(cl))\n}\n\n/*\nFail notifies Ginkgo that the current spec has failed. (Gomega will call Fail for you automatically when an assertion fails.)\n\nUnder the hood, Fail panics to end execution of the current spec.  Ginkgo will catch this panic and proceed with\nthe subsequent spec.  If you call Fail, or make an assertion, within a goroutine launched by your spec you must\nadd defer GinkgoRecover() to the goroutine to catch the panic emitted by Fail.\n\nYou can call Fail in any Setup or Subject node closure.\n\nYou can learn more about how Ginkgo manages failures here: https://onsi.github.io/ginkgo/#mental-model-how-ginkgo-handles-failure\n*/\nfunc Fail(message string, callerSkip ...int) {\n\tskip := 0\n\tif len(callerSkip) > 0 {\n\t\tskip = callerSkip[0]\n\t}\n\n\tcl := types.NewCodeLocationWithStackTrace(skip + 1)\n\tglobal.Failer.Fail(message, cl)\n\tpanic(types.GinkgoErrors.UncaughtGinkgoPanic(cl))\n}\n\n/*\nAbortSuite instructs Ginkgo to fail the current spec and skip all subsequent specs, thereby aborting the suite.\n\nYou can call AbortSuite in any Setup or Subject node closure.\n\nYou can learn more about how Ginkgo handles suite interruptions here: https://onsi.github.io/ginkgo/#interrupting-aborting-and-timing-out-suites\n*/\nfunc AbortSuite(message string, callerSkip ...int) {\n\tskip := 0\n\tif len(callerSkip) > 0 {\n\t\tskip = callerSkip[0]\n\t}\n\n\tcl := types.NewCodeLocationWithStackTrace(skip + 1)\n\tglobal.Failer.AbortSuite(message, cl)\n\tpanic(types.GinkgoErrors.UncaughtGinkgoPanic(cl))\n}\n\n/*\nignorablePanic is used by Gomega to signal to GinkgoRecover that Goemga is handling\nthe error associated with this panic.  It i used when Eventually/Consistently are passed a func(g Gomega) and the resulting function launches a goroutines that makes a failed assertion.  That failed assertion is registered by Gomega and then panics.  Ordinarily the panic is captured by Gomega.  In the case of a goroutine Gomega can't capture the panic - so we piggy back on GinkgoRecover so users have a single defer GinkgoRecover() pattern to follow.  To do that we need to tell Ginkgo to ignore this panic and not register it as a panic on the global Failer.\n*/\ntype ignorablePanic interface{ GinkgoRecoverShouldIgnoreThisPanic() }\n\n/*\nGinkgoRecover should be deferred at the top of any spawned goroutine that (may) call `Fail`\nSince Gomega assertions call fail, you should throw a `defer GinkgoRecover()` at the top of any goroutine that\ncalls out to Gomega\n\nHere's why: Ginkgo's `Fail` method records the failure and then panics to prevent\nfurther assertions from running.  This panic must be recovered.  Normally, Ginkgo recovers the panic for you,\nhowever if a panic originates on a goroutine *launched* from one of your specs there's no\nway for Ginkgo to rescue the panic.  To do this, you must remember to `defer GinkgoRecover()` at the top of such a goroutine.\n\nYou can learn more about how Ginkgo manages failures here: https://onsi.github.io/ginkgo/#mental-model-how-ginkgo-handles-failure\n*/\nfunc GinkgoRecover() {\n\te := recover()\n\tif e != nil {\n\t\tif _, ok := e.(ignorablePanic); ok {\n\t\t\treturn\n\t\t}\n\t\tglobal.Failer.Panic(types.NewCodeLocationWithStackTrace(1), e)\n\t}\n}\n\n// pushNode is used by the various test construction DSL methods to push nodes onto the suite\n// it handles returned errors, emits a detailed error message to help the user learn what they may have done wrong, then exits\nfunc pushNode(node internal.Node, errors []error) bool {\n\texitIfErrors(errors)\n\texitIfErr(global.Suite.PushNode(node))\n\treturn true\n}\n\n/*\nDescribe nodes are Container nodes that allow you to organize your specs.  A Describe node's closure can contain any number of\nSetup nodes (e.g. BeforeEach, AfterEach, JustBeforeEach), and Subject nodes (i.e. It).\n\nContext and When nodes are aliases for Describe - use whichever gives your suite a better narrative flow.  It is idomatic\nto Describe the behavior of an object or function and, within that Describe, outline a number of Contexts and Whens.\n\nYou can learn more at https://onsi.github.io/ginkgo/#organizing-specs-with-container-nodes\nIn addition, container nodes can be decorated with a variety of decorators.  You can learn more here: https://onsi.github.io/ginkgo/#decorator-reference\n*/\nfunc Describe(text string, args ...any) bool {\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeContainer, text, args...))\n}\n\n/*\nFDescribe focuses specs within the Describe block.\n*/\nfunc FDescribe(text string, args ...any) bool {\n\targs = append(args, internal.Focus)\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeContainer, text, args...))\n}\n\n/*\nPDescribe marks specs within the Describe block as pending.\n*/\nfunc PDescribe(text string, args ...any) bool {\n\targs = append(args, internal.Pending)\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeContainer, text, args...))\n}\n\n/*\nXDescribe marks specs within the Describe block as pending.\n\nXDescribe is an alias for PDescribe\n*/\nvar XDescribe = PDescribe\n\n/* Context is an alias for Describe - it generates the exact same kind of Container node */\nvar Context, FContext, PContext, XContext = Describe, FDescribe, PDescribe, XDescribe\n\n/* When is an alias for Describe - it generates the exact same kind of Container node */\nfunc When(text string, args ...any) bool {\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeContainer, \"when \"+text, args...))\n}\n\n/* When is an alias for Describe - it generates the exact same kind of Container node */\nfunc FWhen(text string, args ...any) bool {\n\targs = append(args, internal.Focus)\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeContainer, \"when \"+text, args...))\n}\n\n/* When is an alias for Describe - it generates the exact same kind of Container node */\nfunc PWhen(text string, args ...any) bool {\n\targs = append(args, internal.Pending)\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeContainer, \"when \"+text, args...))\n}\n\nvar XWhen = PWhen\n\n/*\nIt nodes are Subject nodes that contain your spec code and assertions.\n\nEach It node corresponds to an individual Ginkgo spec.  You cannot nest any other Ginkgo nodes within an It node's closure.\n\nYou can pass It nodes bare functions (func() {}) or functions that receive a SpecContext or context.Context: func(ctx SpecContext) {} and func (ctx context.Context) {}. If the function takes a context then the It is deemed interruptible and Ginkgo will cancel the context in the event of a timeout (configured via the SpecTimeout() or NodeTimeout() decorators) or of an interrupt signal.\n\nYou can learn more at https://onsi.github.io/ginkgo/#spec-subjects-it\nIn addition, subject nodes can be decorated with a variety of decorators.  You can learn more here: https://onsi.github.io/ginkgo/#decorator-reference\n*/\nfunc It(text string, args ...any) bool {\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeIt, text, args...))\n}\n\n/*\nFIt allows you to focus an individual It.\n*/\nfunc FIt(text string, args ...any) bool {\n\targs = append(args, internal.Focus)\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeIt, text, args...))\n}\n\n/*\nPIt allows you to mark an individual It as pending.\n*/\nfunc PIt(text string, args ...any) bool {\n\targs = append(args, internal.Pending)\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeIt, text, args...))\n}\n\n/*\nXIt allows you to mark an individual It as pending.\n\nXIt is an alias for PIt\n*/\nvar XIt = PIt\n\n/*\nSpecify is an alias for It - it can allow for more natural wording in some context.\n*/\nvar Specify, FSpecify, PSpecify, XSpecify = It, FIt, PIt, XIt\n\n/*\nBy allows you to better document complex Specs.\n\nGenerally you should try to keep your Its short and to the point.  This is not always possible, however,\nespecially in the context of integration tests that capture complex or lengthy workflows.\n\nBy allows you to document such flows.  By may be called within a Setup or Subject node (It, BeforeEach, etc...)\nand will simply log the passed in text to the GinkgoWriter.  If By is handed a function it will immediately run the function.\n\nBy will also generate and attach a ReportEntry to the spec.  This will ensure that By annotations appear in Ginkgo's machine-readable reports.\n\nNote that By does not generate a new Ginkgo node - rather it is simply syntactic sugar around GinkgoWriter and AddReportEntry\nYou can learn more about By here: https://onsi.github.io/ginkgo/#documenting-complex-specs-by\n*/\nfunc By(text string, callback ...func()) {\n\texitIfErr(global.Suite.By(text, callback...))\n}\n\n/*\nBeforeSuite nodes are suite-level Setup nodes that run just once before any specs are run.\nWhen running in parallel, each parallel process will call BeforeSuite.\n\nYou may only register *one* BeforeSuite handler per test suite.  You typically do so in your bootstrap file at the top level.\n\nBeforeSuite can take a func() body, or an interruptible func(SpecContext)/func(context.Context) body.\n\nYou cannot nest any other Ginkgo nodes within a BeforeSuite node's closure.\nYou can learn more here: https://onsi.github.io/ginkgo/#suite-setup-and-cleanup-beforesuite-and-aftersuite\n*/\nfunc BeforeSuite(body any, args ...any) bool {\n\tcombinedArgs := []any{body}\n\tcombinedArgs = append(combinedArgs, args...)\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeBeforeSuite, \"\", combinedArgs...))\n}\n\n/*\nAfterSuite nodes are suite-level Setup nodes run after all specs have finished - regardless of whether specs have passed or failed.\nAfterSuite node closures always run, even if Ginkgo receives an interrupt signal (^C), in order to ensure cleanup occurs.\n\nWhen running in parallel, each parallel process will call AfterSuite.\n\nYou may only register *one* AfterSuite handler per test suite.  You typically do so in your bootstrap file at the top level.\n\nAfterSuite can take a func() body, or an interruptible func(SpecContext)/func(context.Context) body.\n\nYou cannot nest any other Ginkgo nodes within an AfterSuite node's closure.\nYou can learn more here: https://onsi.github.io/ginkgo/#suite-setup-and-cleanup-beforesuite-and-aftersuite\n*/\nfunc AfterSuite(body any, args ...any) bool {\n\tcombinedArgs := []any{body}\n\tcombinedArgs = append(combinedArgs, args...)\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeAfterSuite, \"\", combinedArgs...))\n}\n\n/*\nSynchronizedBeforeSuite nodes allow you to perform some of the suite setup just once - on parallel process #1 - and then pass information\nfrom that setup to the rest of the suite setup on all processes.  This is useful for performing expensive or singleton setup once, then passing\ninformation from that setup to all parallel processes.\n\nSynchronizedBeforeSuite accomplishes this by taking *two* function arguments and passing data between them.\nThe first function is only run on parallel process #1.  The second is run on all processes, but *only* after the first function completes successfully.  The functions have the following signatures:\n\nThe first function (which only runs on process #1) can have any of the following the signatures:\n\n\tfunc()\n\tfunc(ctx context.Context)\n\tfunc(ctx SpecContext)\n\tfunc() []byte\n\tfunc(ctx context.Context) []byte\n\tfunc(ctx SpecContext) []byte\n\nThe byte array returned by the first function (if present) is then passed to the second function, which can have any of the following signature:\n\n\tfunc()\n\tfunc(ctx context.Context)\n\tfunc(ctx SpecContext)\n\tfunc(data []byte)\n\tfunc(ctx context.Context, data []byte)\n\tfunc(ctx SpecContext, data []byte)\n\nIf either function receives a context.Context/SpecContext it is considered interruptible.\n\nYou cannot nest any other Ginkgo nodes within an SynchronizedBeforeSuite node's closure.\nYou can learn more, and see some examples, here: https://onsi.github.io/ginkgo/#parallel-suite-setup-and-cleanup-synchronizedbeforesuite-and-synchronizedaftersuite\n*/\nfunc SynchronizedBeforeSuite(process1Body any, allProcessBody any, args ...any) bool {\n\tcombinedArgs := []any{process1Body, allProcessBody}\n\tcombinedArgs = append(combinedArgs, args...)\n\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeSynchronizedBeforeSuite, \"\", combinedArgs...))\n}\n\n/*\nSynchronizedAfterSuite nodes complement the SynchronizedBeforeSuite nodes in solving the problem of splitting clean up into a piece that runs on all processes\nand a piece that must only run once - on process #1.\n\nSynchronizedAfterSuite accomplishes this by taking *two* function arguments.  The first runs on all processes.  The second runs only on parallel process #1\nand *only* after all other processes have finished and exited.  This ensures that process #1, and any resources it is managing, remain alive until\nall other processes are finished.  These two functions can be bare functions (func()) or interruptible (func(context.Context)/func(SpecContext))\n\nNote that you can also use DeferCleanup() in SynchronizedBeforeSuite to accomplish similar results.\n\nYou cannot nest any other Ginkgo nodes within an SynchronizedAfterSuite node's closure.\nYou can learn more, and see some examples, here: https://onsi.github.io/ginkgo/#parallel-suite-setup-and-cleanup-synchronizedbeforesuite-and-synchronizedaftersuite\n*/\nfunc SynchronizedAfterSuite(allProcessBody any, process1Body any, args ...any) bool {\n\tcombinedArgs := []any{allProcessBody, process1Body}\n\tcombinedArgs = append(combinedArgs, args...)\n\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeSynchronizedAfterSuite, \"\", combinedArgs...))\n}\n\n/*\nBeforeEach nodes are Setup nodes whose closures run before It node closures.  When multiple BeforeEach nodes\nare defined in nested Container nodes the outermost BeforeEach node closures are run first.\n\nBeforeEach can take a func() body, or an interruptible func(SpecContext)/func(context.Context) body.\n\nYou cannot nest any other Ginkgo nodes within a BeforeEach node's closure.\nYou can learn more here: https://onsi.github.io/ginkgo/#extracting-common-setup-beforeeach\n*/\nfunc BeforeEach(args ...any) bool {\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeBeforeEach, \"\", args...))\n}\n\n/*\nJustBeforeEach nodes are similar to BeforeEach nodes, however they are guaranteed to run *after* all BeforeEach node closures - just before the It node closure.\nThis can allow you to separate configuration from creation of resources for a spec.\n\nJustBeforeEach can take a func() body, or an interruptible func(SpecContext)/func(context.Context) body.\n\nYou cannot nest any other Ginkgo nodes within a JustBeforeEach node's closure.\nYou can learn more and see some examples here: https://onsi.github.io/ginkgo/#separating-creation-and-configuration-justbeforeeach\n*/\nfunc JustBeforeEach(args ...any) bool {\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeJustBeforeEach, \"\", args...))\n}\n\n/*\nAfterEach nodes are Setup nodes whose closures run after It node closures.  When multiple AfterEach nodes\nare defined in nested Container nodes the innermost AfterEach node closures are run first.\n\nNote that you can also use DeferCleanup() in other Setup or Subject nodes to accomplish similar results.\n\nAfterEach can take a func() body, or an interruptible func(SpecContext)/func(context.Context) body.\n\nYou cannot nest any other Ginkgo nodes within an AfterEach node's closure.\nYou can learn more here: https://onsi.github.io/ginkgo/#spec-cleanup-aftereach-and-defercleanup\n*/\nfunc AfterEach(args ...any) bool {\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeAfterEach, \"\", args...))\n}\n\n/*\nJustAfterEach nodes are similar to AfterEach nodes, however they are guaranteed to run *before* all AfterEach node closures - just after the It node closure. This can allow you to separate diagnostics collection from teardown for a spec.\n\nJustAfterEach can take a func() body, or an interruptible func(SpecContext)/func(context.Context) body.\n\nYou cannot nest any other Ginkgo nodes within a JustAfterEach node's closure.\nYou can learn more and see some examples here: https://onsi.github.io/ginkgo/#separating-diagnostics-collection-and-teardown-justaftereach\n*/\nfunc JustAfterEach(args ...any) bool {\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeJustAfterEach, \"\", args...))\n}\n\n/*\nBeforeAll nodes are Setup nodes that can occur inside Ordered containers.  They run just once before any specs in the Ordered container run.\n\nMultiple BeforeAll nodes can be defined in a given Ordered container however they cannot be nested inside any other container.\n\nBeforeAll can take a func() body, or an interruptible func(SpecContext)/func(context.Context) body.\n\nYou cannot nest any other Ginkgo nodes within a BeforeAll node's closure.\nYou can learn more about Ordered Containers at: https://onsi.github.io/ginkgo/#ordered-containers\nAnd you can learn more about BeforeAll at: https://onsi.github.io/ginkgo/#setup-in-ordered-containers-beforeall-and-afterall\n*/\nfunc BeforeAll(args ...any) bool {\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeBeforeAll, \"\", args...))\n}\n\n/*\nAfterAll nodes are Setup nodes that can occur inside Ordered containers.  They run just once after all specs in the Ordered container have run.\n\nMultiple AfterAll nodes can be defined in a given Ordered container however they cannot be nested inside any other container.\n\nNote that you can also use DeferCleanup() in a BeforeAll node to accomplish similar behavior.\n\nAfterAll can take a func() body, or an interruptible func(SpecContext)/func(context.Context) body.\n\nYou cannot nest any other Ginkgo nodes within an AfterAll node's closure.\nYou can learn more about Ordered Containers at: https://onsi.github.io/ginkgo/#ordered-containers\nAnd you can learn more about AfterAll at: https://onsi.github.io/ginkgo/#setup-in-ordered-containers-beforeall-and-afterall\n*/\nfunc AfterAll(args ...any) bool {\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeAfterAll, \"\", args...))\n}\n\n/*\nDeferCleanup can be called within any Setup or Subject node to register a cleanup callback that Ginkgo will call at the appropriate time to cleanup after the spec.\n\nDeferCleanup can be passed:\n1. A function that takes no arguments and returns no values.\n2. A function that returns multiple values.  `DeferCleanup` will ignore all these return values except for the last one.  If this last return value is a non-nil error `DeferCleanup` will fail the spec).\n3. A function that takes a context.Context or SpecContext (and optionally returns multiple values).  The resulting cleanup node is deemed interruptible and the passed-in context will be cancelled in the event of a timeout or interrupt.\n4. A function that takes arguments (and optionally returns multiple values) followed by a list of arguments to pass to the function.\n5. A function that takes SpecContext and a list of arguments (and optionally returns multiple values) followed by a list of arguments to pass to the function.\n\nFor example:\n\n\tBeforeEach(func() {\n\t    DeferCleanup(os.Setenv, \"FOO\", os.GetEnv(\"FOO\"))\n\t    os.Setenv(\"FOO\", \"BAR\")\n\t})\n\nwill register a cleanup handler that will set the environment variable \"FOO\" to its current value (obtained by os.GetEnv(\"FOO\")) after the spec runs and then sets the environment variable \"FOO\" to \"BAR\" for the current spec.\n\nSimilarly:\n\n\tBeforeEach(func() {\n\t    DeferCleanup(func(ctx SpecContext, path) {\n\t    \treq, err := http.NewRequestWithContext(ctx, \"POST\", path, nil)\n\t    \tExpect(err).NotTo(HaveOccured())\n\t    \t_, err := http.DefaultClient.Do(req)\n\t    \tExpect(err).NotTo(HaveOccured())\n\t    }, \"example.com/cleanup\", NodeTimeout(time.Second*3))\n\t})\n\nwill register a cleanup handler that will have three seconds to successfully complete a request to the specified path. Note that we do not specify a context in the list of arguments passed to DeferCleanup - only in the signature of the function we pass in.  Ginkgo will detect the requested context and supply a SpecContext when it invokes the cleanup node.  If you want to pass in your own context in addition to the Ginkgo-provided SpecContext you must specify the SpecContext as the first argument (e.g. func(ctx SpecContext, otherCtx context.Context)).\n\nWhen DeferCleanup is called in BeforeEach, JustBeforeEach, It, AfterEach, or JustAfterEach the registered callback will be invoked when the spec completes (i.e. it will behave like an AfterEach node)\nWhen DeferCleanup is called in BeforeAll or AfterAll the registered callback will be invoked when the ordered container completes (i.e. it will behave like an AfterAll node)\nWhen DeferCleanup is called in BeforeSuite, SynchronizedBeforeSuite, AfterSuite, or SynchronizedAfterSuite the registered callback will be invoked when the suite completes (i.e. it will behave like an AfterSuite node)\n\nNote that DeferCleanup does not represent a node but rather dynamically generates the appropriate type of cleanup node based on the context in which it is called.  As such you must call DeferCleanup within a Setup or Subject node, and not within a Container node.\nYou can learn more about DeferCleanup here: https://onsi.github.io/ginkgo/#cleaning-up-our-cleanup-code-defercleanup\n*/\nfunc DeferCleanup(args ...any) {\n\tfail := func(message string, cl types.CodeLocation) {\n\t\tglobal.Failer.Fail(message, cl)\n\t}\n\tpushNode(internal.NewCleanupNode(deprecationTracker, fail, args...))\n}\n\n/*\nAttachProgressReporter allows you to register a function that will be called whenever Ginkgo generates a Progress Report.  The contents returned by the function will be included in the report.\n\n**This is an experimental feature and the public-facing interface may change in a future minor version of Ginkgo**\n\nProgress Reports are generated:\n- whenever the user explicitly requests one (via `SIGINFO` or `SIGUSR1`)\n- on nodes decorated  with PollProgressAfter\n- on suites run with --poll-progress-after\n- whenever a test times out\n\nGinkgo uses Progress Reports to convey the current state of the test suite, including any running goroutines.  By attaching a progress reporter you are able to supplement these reports with additional information.\n\n# AttachProgressReporter returns a function that can be called to detach the progress reporter\n\nYou can learn more about AttachProgressReporter here: https://onsi.github.io/ginkgo/#attaching-additional-information-to-progress-reports\n*/\nfunc AttachProgressReporter(reporter func() string) func() {\n\treturn global.Suite.AttachProgressReporter(reporter)\n}\n"
        },
        {
          "name": "decorator_dsl.go",
          "type": "blob",
          "size": 7.92578125,
          "content": "package ginkgo\n\nimport (\n\t\"github.com/onsi/ginkgo/v2/internal\"\n)\n\n/*\nOffset(uint) is a decorator that allows you to change the stack-frame offset used when computing the line number of the node in question.\n\nYou can learn more here: https://onsi.github.io/ginkgo/#the-offset-decorator\nYou can learn more about decorators here: https://onsi.github.io/ginkgo/#decorator-reference\n*/\ntype Offset = internal.Offset\n\n/*\nFlakeAttempts(uint N) is a decorator that allows you to mark individual specs or spec containers as flaky. Ginkgo will run them up to `N` times until they pass.\n\nYou can learn more here: https://onsi.github.io/ginkgo/#the-flakeattempts-decorator\nYou can learn more about decorators here: https://onsi.github.io/ginkgo/#decorator-reference\n*/\ntype FlakeAttempts = internal.FlakeAttempts\n\n/*\nMustPassRepeatedly(uint N) is a decorator that allows you to repeat the execution of individual specs or spec containers. Ginkgo will run them up to `N` times until they fail.\n\nYou can learn more here: https://onsi.github.io/ginkgo/#the-mustpassrepeatedly-decorator\nYou can learn more about decorators here: https://onsi.github.io/ginkgo/#decorator-reference\n*/\ntype MustPassRepeatedly = internal.MustPassRepeatedly\n\n/*\nFocus is a decorator that allows you to mark a spec or container as focused.  Identical to FIt and FDescribe.\n\nYou can learn more here: https://onsi.github.io/ginkgo/#filtering-specs\nYou can learn more about decorators here: https://onsi.github.io/ginkgo/#decorator-reference\n*/\nconst Focus = internal.Focus\n\n/*\nPending is a decorator that allows you to mark a spec or container as pending.  Identical to PIt and PDescribe.\n\nYou can learn more here: https://onsi.github.io/ginkgo/#filtering-specs\nYou can learn more about decorators here: https://onsi.github.io/ginkgo/#decorator-reference\n*/\nconst Pending = internal.Pending\n\n/*\nSerial is a decorator that allows you to mark a spec or container as serial.  These specs will never run in parallel with other specs.\nSpecs in ordered containers cannot be marked as serial - mark the ordered container instead.\n\nYou can learn more here: https://onsi.github.io/ginkgo/#serial-specs\nYou can learn more about decorators here: https://onsi.github.io/ginkgo/#decorator-reference\n*/\nconst Serial = internal.Serial\n\n/*\nOrdered is a decorator that allows you to mark a container as ordered.  Specs in the container will always run in the order they appear.\nThey will never be randomized and they will never run in parallel with one another, though they may run in parallel with other specs.\n\nYou can learn more here: https://onsi.github.io/ginkgo/#ordered-containers\nYou can learn more about decorators here: https://onsi.github.io/ginkgo/#decorator-reference\n*/\nconst Ordered = internal.Ordered\n\n/*\nContinueOnFailure is a decorator that allows you to mark an Ordered container to continue running specs even if failures occur.  Ordinarily an ordered container will stop running specs after the first failure occurs.  Note that if a BeforeAll or a BeforeEach/JustBeforeEach annotated with OncePerOrdered fails then no specs will run as the precondition for the Ordered container will consider to be failed.\n\nContinueOnFailure only applies to the outermost Ordered container.  Attempting to place ContinueOnFailure in a nested container will result in an error.\n\nYou can learn more here: https://onsi.github.io/ginkgo/#ordered-containers\nYou can learn more about decorators here: https://onsi.github.io/ginkgo/#decorator-reference\n*/\nconst ContinueOnFailure = internal.ContinueOnFailure\n\n/*\nOncePerOrdered is a decorator that allows you to mark outer BeforeEach, AfterEach, JustBeforeEach, and JustAfterEach setup nodes to run once\nper ordered context.  Normally these setup nodes run around each individual spec, with OncePerOrdered they will run once around the set of specs in an ordered container.\nThe behavior for non-Ordered containers/specs is unchanged.\n\nYou can learn more here: https://onsi.github.io/ginkgo/#setup-around-ordered-containers-the-onceperordered-decorator\nYou can learn more about decorators here: https://onsi.github.io/ginkgo/#decorator-reference\n*/\nconst OncePerOrdered = internal.OncePerOrdered\n\n/*\nLabel decorates specs with Labels.  Multiple labels can be passed to Label and these can be arbitrary strings but must not include the following characters: \"&|!,()/\".\nLabels can be applied to container and subject nodes, but not setup nodes.  You can provide multiple Labels to a given node and a spec's labels is the union of all labels in its node hierarchy.\n\nYou can learn more here: https://onsi.github.io/ginkgo/#spec-labels\nYou can learn more about decorators here: https://onsi.github.io/ginkgo/#decorator-reference\n*/\nfunc Label(labels ...string) Labels {\n\treturn Labels(labels)\n}\n\n/*\nLabels are the type for spec Label decorators.  Use Label(...) to construct Labels.\nYou can learn more here: https://onsi.github.io/ginkgo/#spec-labels\n*/\ntype Labels = internal.Labels\n\n/*\nPollProgressAfter allows you to override the configured value for --poll-progress-after for a particular node.\n\nGinkgo will start emitting node progress if the node is still running after a duration of PollProgressAfter.  This allows you to get quicker feedback about the state of a long-running spec.\n*/\ntype PollProgressAfter = internal.PollProgressAfter\n\n/*\nPollProgressInterval allows you to override the configured value for --poll-progress-interval for a particular node.\n\nOnce a node has been running for longer than PollProgressAfter Ginkgo will emit node progress periodically at an interval of PollProgresInterval.\n*/\ntype PollProgressInterval = internal.PollProgressInterval\n\n/*\nNodeTimeout allows you to specify a timeout for an indivdiual node.  The node cannot be a container and must be interruptible (i.e. it must be passed a function that accepts a SpecContext or context.Context).\n\nIf the node does not exit within the specified NodeTimeout its context will be cancelled.  The node wil then have a period of time controlled by the GracePeriod decorator (or global --grace-period command-line argument) to exit.  If the node does not exit within GracePeriod Ginkgo will leak the node and proceed to any clean-up nodes associated with the current spec.\n*/\ntype NodeTimeout = internal.NodeTimeout\n\n/*\nSpecTimeout allows you to specify a timeout for an indivdiual spec.  SpecTimeout can only decorate interruptible It nodes.\n\nAll nodes associated with the It node will need to complete before the SpecTimeout has elapsed.  Individual nodes (e.g. BeforeEach) may be decorated with different NodeTimeouts - but these can only serve to provide a more stringent deadline for the node in question; they cannot extend the deadline past the SpecTimeout.\n\nIf the spec does not complete within the specified SpecTimeout the currently running node will have its context cancelled.  The node wil then have a period of time controlled by that node's GracePeriod decorator (or global --grace-period command-line argument) to exit.  If the node does not exit within GracePeriod Ginkgo will leak the node and proceed to any clean-up nodes associated with the current spec.\n*/\ntype SpecTimeout = internal.SpecTimeout\n\n/*\nGracePeriod denotes the period of time Ginkgo will wait for an interruptible node to exit once an interruption (whether due to a timeout or a user-invoked signal) has occurred.  If both the global --grace-period cli flag and a GracePeriod decorator are specified the value in the decorator will take precedence.\n\nNodes that do not finish within a GracePeriod will be leaked and Ginkgo will proceed to run subsequent nodes.  In the event of a timeout, such leaks will be reported to the user.\n*/\ntype GracePeriod = internal.GracePeriod\n\n/*\nSuppressProgressReporting is a decorator that allows you to disable progress reporting of a particular node.  This is useful if `ginkgo -v -progress` is generating too much noise; particularly\nif you have a `ReportAfterEach` node that is running for every skipped spec and is generating lots of progress reports.\n*/\nconst SuppressProgressReporting = internal.SuppressProgressReporting\n"
        },
        {
          "name": "deprecated_dsl.go",
          "type": "blob",
          "size": 4.7470703125,
          "content": "package ginkgo\n\nimport (\n\t\"time\"\n\n\t\"github.com/onsi/ginkgo/v2/internal\"\n\t\"github.com/onsi/ginkgo/v2/internal/global\"\n\t\"github.com/onsi/ginkgo/v2/reporters\"\n\t\"github.com/onsi/ginkgo/v2/types\"\n)\n\n/*\nDeprecated: Done Channel for asynchronous testing\n\nThe Done channel pattern is no longer supported in Ginkgo 2.0.\nSee here for better patterns for asynchronous testing: https://onsi.github.io/ginkgo/#patterns-for-asynchronous-testing\n\nFor a migration guide see: https://onsi.github.io/ginkgo/MIGRATING_TO_V2#removed-async-testing\n*/\ntype Done = internal.Done\n\n/*\nDeprecated: Custom Ginkgo test reporters are deprecated in Ginkgo 2.0.\n\nUse Ginkgo's reporting nodes instead and 2.0 reporting infrastructure instead. You can learn more here: https://onsi.github.io/ginkgo/#reporting-infrastructure\nFor a migration guide see: https://onsi.github.io/ginkgo/MIGRATING_TO_V2#removed-custom-reporters\n*/\ntype Reporter = reporters.DeprecatedReporter\n\n/*\nDeprecated: Custom Reporters have been removed in Ginkgo 2.0.  RunSpecsWithDefaultAndCustomReporters will simply call RunSpecs()\n\nUse Ginkgo's reporting nodes instead and 2.0 reporting infrastructure instead. You can learn more here: https://onsi.github.io/ginkgo/#reporting-infrastructure\nFor a migration guide see: https://onsi.github.io/ginkgo/MIGRATING_TO_V2#removed-custom-reporters\n*/\nfunc RunSpecsWithDefaultAndCustomReporters(t GinkgoTestingT, description string, _ []Reporter) bool {\n\tdeprecationTracker.TrackDeprecation(types.Deprecations.CustomReporter())\n\treturn RunSpecs(t, description)\n}\n\n/*\nDeprecated: Custom Reporters have been removed in Ginkgo 2.0.  RunSpecsWithCustomReporters will simply call RunSpecs()\n\nUse Ginkgo's reporting nodes instead and 2.0 reporting infrastructure instead. You can learn more here: https://onsi.github.io/ginkgo/#reporting-infrastructure\nFor a migration guide see: https://onsi.github.io/ginkgo/MIGRATING_TO_V2#removed-custom-reporters\n*/\nfunc RunSpecsWithCustomReporters(t GinkgoTestingT, description string, _ []Reporter) bool {\n\tdeprecationTracker.TrackDeprecation(types.Deprecations.CustomReporter())\n\treturn RunSpecs(t, description)\n}\n\n/*\nDeprecated: GinkgoTestDescription has been replaced with SpecReport.\n\nUse CurrentSpecReport() instead.\nYou can learn more here: https://onsi.github.io/ginkgo/#getting-a-report-for-the-current-spec\nThe SpecReport type is documented here: https://pkg.go.dev/github.com/onsi/ginkgo/v2/types#SpecReport\n*/\ntype DeprecatedGinkgoTestDescription struct {\n\tFullTestText   string\n\tComponentTexts []string\n\tTestText       string\n\n\tFileName   string\n\tLineNumber int\n\n\tFailed   bool\n\tDuration time.Duration\n}\ntype GinkgoTestDescription = DeprecatedGinkgoTestDescription\n\n/*\nDeprecated: CurrentGinkgoTestDescription has been replaced with CurrentSpecReport.\n\nUse CurrentSpecReport() instead.\nYou can learn more here: https://onsi.github.io/ginkgo/#getting-a-report-for-the-current-spec\nThe SpecReport type is documented here: https://pkg.go.dev/github.com/onsi/ginkgo/v2/types#SpecReport\n*/\nfunc CurrentGinkgoTestDescription() DeprecatedGinkgoTestDescription {\n\tdeprecationTracker.TrackDeprecation(\n\t\ttypes.Deprecations.CurrentGinkgoTestDescription(),\n\t\ttypes.NewCodeLocation(1),\n\t)\n\treport := global.Suite.CurrentSpecReport()\n\tif report.State == types.SpecStateInvalid {\n\t\treturn GinkgoTestDescription{}\n\t}\n\tcomponentTexts := []string{}\n\tcomponentTexts = append(componentTexts, report.ContainerHierarchyTexts...)\n\tcomponentTexts = append(componentTexts, report.LeafNodeText)\n\n\treturn DeprecatedGinkgoTestDescription{\n\t\tComponentTexts: componentTexts,\n\t\tFullTestText:   report.FullText(),\n\t\tTestText:       report.LeafNodeText,\n\t\tFileName:       report.LeafNodeLocation.FileName,\n\t\tLineNumber:     report.LeafNodeLocation.LineNumber,\n\t\tFailed:         report.State.Is(types.SpecStateFailureStates),\n\t\tDuration:       report.RunTime,\n\t}\n}\n\n/*\nDeprecated: GinkgoParallelNode() has been renamed to GinkgoParallelProcess()\n*/\nfunc GinkgoParallelNode() int {\n\tdeprecationTracker.TrackDeprecation(\n\t\ttypes.Deprecations.ParallelNode(),\n\t\ttypes.NewCodeLocation(1),\n\t)\n\treturn GinkgoParallelProcess()\n}\n\n/*\nDeprecated: Benchmarker has been removed from Ginkgo 2.0\n\nUse Gomega's gmeasure package instead.\nYou can learn more here: https://onsi.github.io/ginkgo/#benchmarking-code\n*/\ntype Benchmarker interface {\n\tTime(name string, body func(), info ...any) (elapsedTime time.Duration)\n\tRecordValue(name string, value float64, info ...any)\n\tRecordValueWithPrecision(name string, value float64, units string, precision int, info ...any)\n}\n\n/*\nDeprecated: Measure() has been removed from Ginkgo 2.0\n\nUse Gomega's gmeasure package instead.\nYou can learn more here: https://onsi.github.io/ginkgo/#benchmarking-code\n*/\nfunc Measure(_ ...any) bool {\n\tdeprecationTracker.TrackDeprecation(types.Deprecations.Measure(), types.NewCodeLocation(1))\n\treturn true\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "dsl",
          "type": "tree",
          "content": null
        },
        {
          "name": "extensions",
          "type": "tree",
          "content": null
        },
        {
          "name": "formatter",
          "type": "tree",
          "content": null
        },
        {
          "name": "ginkgo",
          "type": "tree",
          "content": null
        },
        {
          "name": "ginkgo_cli_dependencies.go",
          "type": "blob",
          "size": 0.1279296875,
          "content": "//go:build ginkgoclidependencies\n// +build ginkgoclidependencies\n\npackage ginkgo\n\nimport (\n\t_ \"github.com/onsi/ginkgo/v2/ginkgo\"\n)\n"
        },
        {
          "name": "ginkgo_t_dsl.go",
          "type": "blob",
          "size": 5.2978515625,
          "content": "package ginkgo\n\nimport (\n\t\"testing\"\n\n\t\"github.com/onsi/ginkgo/v2/internal/testingtproxy\"\n\t\"github.com/onsi/ginkgo/v2/types\"\n)\n\n/*\nGinkgoT() implements an interface that allows third party libraries to integrate with and build on top of Ginkgo.\n\nGinkgoT() is analogous to *testing.T and implements the majority of *testing.T's methods.  It can be typically be used a a drop-in replacement with third-party libraries that accept *testing.T through an interface.\n\nGinkgoT() takes an optional offset argument that can be used to get the\ncorrect line number associated with the failure - though you do not need to use this if you call GinkgoHelper() or GinkgoT().Helper() appropriately\n\nGinkgoT() attempts to mimic the behavior of `testing.T` with the exception of the following:\n\n- Error/Errorf: failures in Ginkgo always immediately stop execution and there is no mechanism to log a failure without aborting the test.  As such Error/Errorf are equivalent to Fatal/Fatalf.\n- Parallel() is a no-op as Ginkgo's multi-process parallelism model is substantially different from go test's in-process model.\n\nYou can learn more here: https://onsi.github.io/ginkgo/#using-third-party-libraries\n*/\nfunc GinkgoT(optionalOffset ...int) FullGinkgoTInterface {\n\toffset := 1\n\tif len(optionalOffset) > 0 {\n\t\toffset = optionalOffset[0]\n\t}\n\treturn testingtproxy.New(\n\t\tGinkgoWriter,\n\t\tFail,\n\t\tSkip,\n\t\tDeferCleanup,\n\t\tCurrentSpecReport,\n\t\tAddReportEntry,\n\t\tGinkgoRecover,\n\t\tAttachProgressReporter,\n\t\tsuiteConfig.RandomSeed,\n\t\tsuiteConfig.ParallelProcess,\n\t\tsuiteConfig.ParallelTotal,\n\t\treporterConfig.NoColor,\n\t\toffset)\n}\n\n/*\nThe portion of the interface returned by GinkgoT() that maps onto methods in the testing package's T.\n*/\ntype GinkgoTInterface interface {\n\tCleanup(func())\n\tSetenv(kev, value string)\n\tError(args ...any)\n\tErrorf(format string, args ...any)\n\tFail()\n\tFailNow()\n\tFailed() bool\n\tFatal(args ...any)\n\tFatalf(format string, args ...any)\n\tHelper()\n\tLog(args ...any)\n\tLogf(format string, args ...any)\n\tName() string\n\tParallel()\n\tSkip(args ...any)\n\tSkipNow()\n\tSkipf(format string, args ...any)\n\tSkipped() bool\n\tTempDir() string\n}\n\n/*\nAdditional methods returned by GinkgoT() that provide deeper integration points into Ginkgo\n*/\ntype FullGinkgoTInterface interface {\n\tGinkgoTInterface\n\n\tAddReportEntryVisibilityAlways(name string, args ...any)\n\tAddReportEntryVisibilityFailureOrVerbose(name string, args ...any)\n\tAddReportEntryVisibilityNever(name string, args ...any)\n\n\t//Prints to the GinkgoWriter\n\tPrint(a ...any)\n\tPrintf(format string, a ...any)\n\tPrintln(a ...any)\n\n\t//Provides access to Ginkgo's color formatting, correctly configured to match the color settings specified in the invocation of ginkgo\n\tF(format string, args ...any) string\n\tFi(indentation uint, format string, args ...any) string\n\tFiw(indentation uint, maxWidth uint, format string, args ...any) string\n\n\t//Generates a formatted string version of the current spec's timeline\n\tRenderTimeline() string\n\n\tGinkgoRecover()\n\tDeferCleanup(args ...any)\n\n\tRandomSeed() int64\n\tParallelProcess() int\n\tParallelTotal() int\n\n\tAttachProgressReporter(func() string) func()\n}\n\n/*\nGinkgoTB() implements a wrapper that exactly matches the testing.TB interface.\n\nIn go 1.18 a new private() function was added to the testing.TB interface. Any function which accepts testing.TB as input needs to be passed in something that directly implements testing.TB.\n\nThis wrapper satisfies the testing.TB interface and intended to be used as a drop-in replacement with third party libraries that accept testing.TB.\n\nSimilar to GinkgoT(), GinkgoTB() takes an optional offset argument that can be used to get the\ncorrect line number associated with the failure - though you do not need to use this if you call GinkgoHelper() or GinkgoT().Helper() appropriately\n*/\nfunc GinkgoTB(optionalOffset ...int) *GinkgoTBWrapper {\n\toffset := 2\n\tif len(optionalOffset) > 0 {\n\t\toffset = optionalOffset[0]\n\t}\n\treturn &GinkgoTBWrapper{GinkgoT: GinkgoT(offset)}\n}\n\ntype GinkgoTBWrapper struct {\n\ttesting.TB\n\tGinkgoT FullGinkgoTInterface\n}\n\nfunc (g *GinkgoTBWrapper) Cleanup(f func()) {\n\tg.GinkgoT.Cleanup(f)\n}\nfunc (g *GinkgoTBWrapper) Error(args ...any) {\n\tg.GinkgoT.Error(args...)\n}\nfunc (g *GinkgoTBWrapper) Errorf(format string, args ...any) {\n\tg.GinkgoT.Errorf(format, args...)\n}\nfunc (g *GinkgoTBWrapper) Fail() {\n\tg.GinkgoT.Fail()\n}\nfunc (g *GinkgoTBWrapper) FailNow() {\n\tg.GinkgoT.FailNow()\n}\nfunc (g *GinkgoTBWrapper) Failed() bool {\n\treturn g.GinkgoT.Failed()\n}\nfunc (g *GinkgoTBWrapper) Fatal(args ...any) {\n\tg.GinkgoT.Fatal(args...)\n}\nfunc (g *GinkgoTBWrapper) Fatalf(format string, args ...any) {\n\tg.GinkgoT.Fatalf(format, args...)\n}\nfunc (g *GinkgoTBWrapper) Helper() {\n\ttypes.MarkAsHelper(1)\n}\nfunc (g *GinkgoTBWrapper) Log(args ...any) {\n\tg.GinkgoT.Log(args...)\n}\nfunc (g *GinkgoTBWrapper) Logf(format string, args ...any) {\n\tg.GinkgoT.Logf(format, args...)\n}\nfunc (g *GinkgoTBWrapper) Name() string {\n\treturn g.GinkgoT.Name()\n}\nfunc (g *GinkgoTBWrapper) Setenv(key, value string) {\n\tg.GinkgoT.Setenv(key, value)\n}\nfunc (g *GinkgoTBWrapper) Skip(args ...any) {\n\tg.GinkgoT.Skip(args...)\n}\nfunc (g *GinkgoTBWrapper) SkipNow() {\n\tg.GinkgoT.SkipNow()\n}\nfunc (g *GinkgoTBWrapper) Skipf(format string, args ...any) {\n\tg.GinkgoT.Skipf(format, args...)\n}\nfunc (g *GinkgoTBWrapper) Skipped() bool {\n\treturn g.GinkgoT.Skipped()\n}\nfunc (g *GinkgoTBWrapper) TempDir() string {\n\treturn g.GinkgoT.TempDir()\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.50390625,
          "content": "module github.com/onsi/ginkgo/v2\n\ngo 1.22.0\n\ntoolchain go1.23.0\n\nrequire (\n\tgithub.com/go-logr/logr v1.4.2\n\tgithub.com/go-task/slim-sprig/v3 v3.0.0\n\tgithub.com/google/pprof v0.0.0-20241210010833-40e02aabc2ad\n\tgithub.com/onsi/gomega v1.36.2\n\tgolang.org/x/sys v0.28.0\n\tgolang.org/x/tools v0.28.0\n)\n\nrequire (\n\tgithub.com/google/go-cmp v0.6.0 // indirect\n\tgolang.org/x/net v0.33.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n\tgoogle.golang.org/protobuf v1.36.1 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.5126953125,
          "content": "github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=\ngithub.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=\ngithub.com/go-task/slim-sprig/v3 v3.0.0 h1:sUs3vkvUymDpBKi3qH1YSqBQk9+9D/8M2mN1vB6EwHI=\ngithub.com/go-task/slim-sprig/v3 v3.0.0/go.mod h1:W848ghGpv3Qj3dhTPRyJypKRiqCdHZiAzKg9hl15HA8=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/pprof v0.0.0-20241210010833-40e02aabc2ad h1:a6HEuzUHeKH6hwfN/ZoQgRgVIWFJljSWa/zetS2WTvg=\ngithub.com/google/pprof v0.0.0-20241210010833-40e02aabc2ad/go.mod h1:vavhavw2zAxS5dIdcRluK6cSGGPlZynqzFM8NdvU144=\ngithub.com/onsi/gomega v1.36.2 h1:koNYke6TVk6ZmnyHrCXba/T/MoLBXFjeC1PtvYgw0A8=\ngithub.com/onsi/gomega v1.36.2/go.mod h1:DdwyADRjrc825LhMEkD76cHR5+pUnjhUN8GlHlRPHzY=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/tools v0.28.0 h1:WuB6qZ4RPCQo5aP3WdKZS7i595EdWqWR8vqJTlwTVK8=\ngolang.org/x/tools v0.28.0/go.mod h1:dcIOrVd3mfQKTgrDVQHqCPMWy6lnhfhtX3hLXYVLfRw=\ngoogle.golang.org/protobuf v1.36.1 h1:yBPeRvTftaleIgM3PZ/WBIZ7XM/eEYAaEyCwvyjq/gk=\ngoogle.golang.org/protobuf v1.36.1/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "integration",
          "type": "tree",
          "content": null
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "reporters",
          "type": "tree",
          "content": null
        },
        {
          "name": "reporting_dsl.go",
          "type": "blob",
          "size": 9.6484375,
          "content": "package ginkgo\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/onsi/ginkgo/v2/internal\"\n\t\"github.com/onsi/ginkgo/v2/internal/global\"\n\t\"github.com/onsi/ginkgo/v2/reporters\"\n\t\"github.com/onsi/ginkgo/v2/types\"\n)\n\n/*\nReport represents the report for a Suite.\nIt is documented here: https://pkg.go.dev/github.com/onsi/ginkgo/v2/types#Report\n*/\ntype Report = types.Report\n\n/*\nReport represents the report for a Spec.\nIt is documented here: https://pkg.go.dev/github.com/onsi/ginkgo/v2/types#SpecReport\n*/\ntype SpecReport = types.SpecReport\n\n/*\nCurrentSpecReport returns information about the current running spec.\nThe returned object is a types.SpecReport which includes helper methods\nto make extracting information about the spec easier.\n\nYou can learn more about SpecReport here: https://pkg.go.dev/github.com/onsi/ginkgo/types#SpecReport\nYou can learn more about CurrentSpecReport() here: https://onsi.github.io/ginkgo/#getting-a-report-for-the-current-spec\n*/\nfunc CurrentSpecReport() SpecReport {\n\treturn global.Suite.CurrentSpecReport()\n}\n\n/*\n\tReportEntryVisibility governs the visibility of ReportEntries in Ginkgo's console reporter\n\n- ReportEntryVisibilityAlways: the default behavior - the ReportEntry is always emitted.\n- ReportEntryVisibilityFailureOrVerbose: the ReportEntry is only emitted if the spec fails or if the tests are run with -v (similar to GinkgoWriters behavior).\n- ReportEntryVisibilityNever: the ReportEntry is never emitted though it appears in any generated machine-readable reports (e.g. by setting `--json-report`).\n\nYou can learn more about Report Entries here: https://onsi.github.io/ginkgo/#attaching-data-to-reports\n*/\ntype ReportEntryVisibility = types.ReportEntryVisibility\n\nconst ReportEntryVisibilityAlways, ReportEntryVisibilityFailureOrVerbose, ReportEntryVisibilityNever = types.ReportEntryVisibilityAlways, types.ReportEntryVisibilityFailureOrVerbose, types.ReportEntryVisibilityNever\n\n/*\nAddReportEntry generates and adds a new ReportEntry to the current spec's SpecReport.\nIt can take any of the following arguments:\n  - A single arbitrary object to attach as the Value of the ReportEntry.  This object will be included in any generated reports and will be emitted to the console when the report is emitted.\n  - A ReportEntryVisibility enum to control the visibility of the ReportEntry\n  - An Offset or CodeLocation decoration to control the reported location of the ReportEntry\n\nIf the Value object implements `fmt.Stringer`, it's `String()` representation is used when emitting to the console.\n\nAddReportEntry() must be called within a Subject or Setup node - not in a Container node.\n\nYou can learn more about Report Entries here: https://onsi.github.io/ginkgo/#attaching-data-to-reports\n*/\nfunc AddReportEntry(name string, args ...any) {\n\tcl := types.NewCodeLocation(1)\n\treportEntry, err := internal.NewReportEntry(name, cl, args...)\n\tif err != nil {\n\t\tFail(fmt.Sprintf(\"Failed to generate Report Entry:\\n%s\", err.Error()), 1)\n\t}\n\terr = global.Suite.AddReportEntry(reportEntry)\n\tif err != nil {\n\t\tFail(fmt.Sprintf(\"Failed to add Report Entry:\\n%s\", err.Error()), 1)\n\t}\n}\n\n/*\nReportBeforeEach nodes are run for each spec, even if the spec is skipped or pending.  ReportBeforeEach nodes take a function that\nreceives a SpecReport or both SpecContext and Report for interruptible behavior. They are called before the spec starts.\n\nExample:\n\n\tReportBeforeEach(func(report SpecReport) { // process report  })\n\tReportBeforeEach(func(ctx SpecContext, report SpecReport) {\n\t\t// process report\n\t}), NodeTimeout(1 * time.Minute))\n\nYou cannot nest any other Ginkgo nodes within a ReportBeforeEach node's closure.\nYou can learn more about ReportBeforeEach here: https://onsi.github.io/ginkgo/#generating-reports-programmatically\n\nYou can learn about interruptible nodes here: https://onsi.github.io/ginkgo/#spec-timeouts-and-interruptible-nodes\n*/\nfunc ReportBeforeEach(body any, args ...any) bool {\n\tcombinedArgs := []any{body}\n\tcombinedArgs = append(combinedArgs, args...)\n\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeReportBeforeEach, \"\", combinedArgs...))\n}\n\n/*\nReportAfterEach nodes are run for each spec, even if the spec is skipped or pending.\nReportAfterEach nodes take a function that receives a SpecReport or both SpecContext and Report for interruptible behavior.\nThey are called after the spec has completed and receive the final report for the spec.\n\nExample:\n\n\tReportAfterEach(func(report SpecReport) { // process report  })\n\tReportAfterEach(func(ctx SpecContext, report SpecReport) {\n\t\t// process report\n\t}), NodeTimeout(1 * time.Minute))\n\nYou cannot nest any other Ginkgo nodes within a ReportAfterEach node's closure.\nYou can learn more about ReportAfterEach here: https://onsi.github.io/ginkgo/#generating-reports-programmatically\n\nYou can learn about interruptible nodes here: https://onsi.github.io/ginkgo/#spec-timeouts-and-interruptible-nodes\n*/\nfunc ReportAfterEach(body any, args ...any) bool {\n\tcombinedArgs := []any{body}\n\tcombinedArgs = append(combinedArgs, args...)\n\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeReportAfterEach, \"\", combinedArgs...))\n}\n\n/*\nReportBeforeSuite nodes are run at the beginning of the suite.  ReportBeforeSuite nodes take a function\nthat can either receive Report or both SpecContext and Report for interruptible behavior.\n\nExample Usage:\n\n\tReportBeforeSuite(func(r Report) { // process report })\n\tReportBeforeSuite(func(ctx SpecContext, r Report) {\n\t\t// process report\n\t}, NodeTimeout(1 * time.Minute))\n\nThey are called at the beginning of the suite, before any specs have run and any BeforeSuite or SynchronizedBeforeSuite nodes, and are passed in the initial report for the suite.\nReportBeforeSuite nodes must be created at the top-level (i.e. not nested in a Context/Describe/When node)\n\n# When running in parallel, Ginkgo ensures that only one of the parallel nodes runs the ReportBeforeSuite\n\nYou cannot nest any other Ginkgo nodes within a ReportAfterSuite node's closure.\nYou can learn more about ReportAfterSuite here: https://onsi.github.io/ginkgo/#generating-reports-programmatically\n\nYou can learn more about Ginkgo's reporting infrastructure, including generating reports with the CLI here: https://onsi.github.io/ginkgo/#generating-machine-readable-reports\n\nYou can learn about interruptible nodes here: https://onsi.github.io/ginkgo/#spec-timeouts-and-interruptible-nodes\n*/\nfunc ReportBeforeSuite(body any, args ...any) bool {\n\tcombinedArgs := []any{body}\n\tcombinedArgs = append(combinedArgs, args...)\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeReportBeforeSuite, \"\", combinedArgs...))\n}\n\n/*\nReportAfterSuite nodes are run at the end of the suite. ReportAfterSuite nodes execute at the suite's conclusion,\nand accept a function that can either receive Report or both SpecContext and Report for interruptible behavior.\n\nExample Usage:\n\n\tReportAfterSuite(\"Non-interruptible ReportAfterSuite\", func(r Report) { // process report })\n\tReportAfterSuite(\"Interruptible ReportAfterSuite\", func(ctx SpecContext, r Report) {\n\t\t// process report\n\t}, NodeTimeout(1 * time.Minute))\n\nThey are called at the end of the suite, after all specs have run and any AfterSuite or SynchronizedAfterSuite nodes, and are passed in the final report for the suite.\nReportAfterSuite nodes must be created at the top-level (i.e. not nested in a Context/Describe/When node)\n\nWhen running in parallel, Ginkgo ensures that only one of the parallel nodes runs the ReportAfterSuite and that it is passed a report that is aggregated across\nall parallel nodes\n\nIn addition to using ReportAfterSuite to programmatically generate suite reports, you can also generate JSON, JUnit, and Teamcity formatted reports using the --json-report, --junit-report, and --teamcity-report ginkgo CLI flags.\n\nYou cannot nest any other Ginkgo nodes within a ReportAfterSuite node's closure.\nYou can learn more about ReportAfterSuite here: https://onsi.github.io/ginkgo/#generating-reports-programmatically\n\nYou can learn more about Ginkgo's reporting infrastructure, including generating reports with the CLI here: https://onsi.github.io/ginkgo/#generating-machine-readable-reports\n\nYou can learn about interruptible nodes here: https://onsi.github.io/ginkgo/#spec-timeouts-and-interruptible-nodes\n*/\nfunc ReportAfterSuite(text string, body any, args ...any) bool {\n\tcombinedArgs := []any{body}\n\tcombinedArgs = append(combinedArgs, args...)\n\treturn pushNode(internal.NewNode(deprecationTracker, types.NodeTypeReportAfterSuite, text, combinedArgs...))\n}\n\nfunc registerReportAfterSuiteNodeForAutogeneratedReports(reporterConfig types.ReporterConfig) {\n\tbody := func(report Report) {\n\t\tif reporterConfig.JSONReport != \"\" {\n\t\t\terr := reporters.GenerateJSONReport(report, reporterConfig.JSONReport)\n\t\t\tif err != nil {\n\t\t\t\tFail(fmt.Sprintf(\"Failed to generate JSON report:\\n%s\", err.Error()))\n\t\t\t}\n\t\t}\n\t\tif reporterConfig.JUnitReport != \"\" {\n\t\t\terr := reporters.GenerateJUnitReport(report, reporterConfig.JUnitReport)\n\t\t\tif err != nil {\n\t\t\t\tFail(fmt.Sprintf(\"Failed to generate JUnit report:\\n%s\", err.Error()))\n\t\t\t}\n\t\t}\n\t\tif reporterConfig.TeamcityReport != \"\" {\n\t\t\terr := reporters.GenerateTeamcityReport(report, reporterConfig.TeamcityReport)\n\t\t\tif err != nil {\n\t\t\t\tFail(fmt.Sprintf(\"Failed to generate Teamcity report:\\n%s\", err.Error()))\n\t\t\t}\n\t\t}\n\t}\n\n\tflags := []string{}\n\tif reporterConfig.JSONReport != \"\" {\n\t\tflags = append(flags, \"--json-report\")\n\t}\n\tif reporterConfig.JUnitReport != \"\" {\n\t\tflags = append(flags, \"--junit-report\")\n\t}\n\tif reporterConfig.TeamcityReport != \"\" {\n\t\tflags = append(flags, \"--teamcity-report\")\n\t}\n\tpushNode(internal.NewNode(\n\t\tdeprecationTracker, types.NodeTypeReportAfterSuite,\n\t\tfmt.Sprintf(\"Autogenerated ReportAfterSuite for %s\", strings.Join(flags, \" \")),\n\t\tbody,\n\t\ttypes.NewCustomCodeLocation(\"autogenerated by Ginkgo\"),\n\t))\n}\n"
        },
        {
          "name": "table_dsl.go",
          "type": "blob",
          "size": 12.3486328125,
          "content": "package ginkgo\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"github.com/onsi/ginkgo/v2/internal\"\n\t\"github.com/onsi/ginkgo/v2/types\"\n)\n\n/*\nThe EntryDescription decorator allows you to pass a format string to DescribeTable() and Entry().  This format string is used to generate entry names via:\n\n\tfmt.Sprintf(formatString, parameters...)\n\nwhere parameters are the parameters passed into the entry.\n\nWhen passed into an Entry the EntryDescription is used to generate the name or that entry.  When passed to DescribeTable, the EntryDescription is used to generate the names for any entries that have `nil` descriptions.\n\nYou can learn more about generating EntryDescriptions here: https://onsi.github.io/ginkgo/#generating-entry-descriptions\n*/\ntype EntryDescription string\n\nfunc (ed EntryDescription) render(args ...any) string {\n\treturn fmt.Sprintf(string(ed), args...)\n}\n\n/*\nDescribeTable describes a table-driven spec.\n\nFor example:\n\n\tDescribeTable(\"a simple table\",\n\t    func(x int, y int, expected bool) {\n\t        Ω(x > y).Should(Equal(expected))\n\t    },\n\t    Entry(\"x > y\", 1, 0, true),\n\t    Entry(\"x == y\", 0, 0, false),\n\t    Entry(\"x < y\", 0, 1, false),\n\t)\n\nYou can learn more about DescribeTable here: https://onsi.github.io/ginkgo/#table-specs\nAnd can explore some Table patterns here: https://onsi.github.io/ginkgo/#table-specs-patterns\n*/\nfunc DescribeTable(description string, args ...any) bool {\n\tGinkgoHelper()\n\tgenerateTable(description, false, args...)\n\treturn true\n}\n\n/*\nYou can focus a table with `FDescribeTable`.  This is equivalent to `FDescribe`.\n*/\nfunc FDescribeTable(description string, args ...any) bool {\n\tGinkgoHelper()\n\targs = append(args, internal.Focus)\n\tgenerateTable(description, false, args...)\n\treturn true\n}\n\n/*\nYou can mark a table as pending with `PDescribeTable`.  This is equivalent to `PDescribe`.\n*/\nfunc PDescribeTable(description string, args ...any) bool {\n\tGinkgoHelper()\n\targs = append(args, internal.Pending)\n\tgenerateTable(description, false, args...)\n\treturn true\n}\n\n/*\nYou can mark a table as pending with `XDescribeTable`.  This is equivalent to `XDescribe`.\n*/\nvar XDescribeTable = PDescribeTable\n\n/*\nDescribeTableSubtree describes a table-driven spec that generates a set of tests for each entry.\n\nFor example:\n\n\tDescribeTableSubtree(\"a subtree table\",\n\t    func(url string, code int, message string) {\n\t\t\tvar resp *http.Response\n\t\t\tBeforeEach(func() {\n\t\t\t\tvar err error\n\t\t\t\tresp, err = http.Get(url)\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tDeferCleanup(resp.Body.Close)\n\t\t\t})\n\n\t\t\tIt(\"should return the expected status code\", func() {\n\t\t\t\tExpect(resp.StatusCode).To(Equal(code))\n\t\t\t})\n\n\t\t\tIt(\"should return the expected message\", func() {\n\t\t\t\tbody, err := io.ReadAll(resp.Body)\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(string(body)).To(Equal(message))\n\t\t\t})\n\t    },\n\t    Entry(\"default response\", \"example.com/response\", http.StatusOK, \"hello world\"),\n\t    Entry(\"missing response\", \"example.com/missing\", http.StatusNotFound, \"wat?\"),\n\t)\n\nNote that you **must** place define an It inside the body function.\n\nYou can learn more about DescribeTableSubtree here: https://onsi.github.io/ginkgo/#table-specs\nAnd can explore some Table patterns here: https://onsi.github.io/ginkgo/#table-specs-patterns\n*/\nfunc DescribeTableSubtree(description string, args ...any) bool {\n\tGinkgoHelper()\n\tgenerateTable(description, true, args...)\n\treturn true\n}\n\n/*\nYou can focus a table with `FDescribeTableSubtree`.  This is equivalent to `FDescribe`.\n*/\nfunc FDescribeTableSubtree(description string, args ...any) bool {\n\tGinkgoHelper()\n\targs = append(args, internal.Focus)\n\tgenerateTable(description, true, args...)\n\treturn true\n}\n\n/*\nYou can mark a table as pending with `PDescribeTableSubtree`.  This is equivalent to `PDescribe`.\n*/\nfunc PDescribeTableSubtree(description string, args ...any) bool {\n\tGinkgoHelper()\n\targs = append(args, internal.Pending)\n\tgenerateTable(description, true, args...)\n\treturn true\n}\n\n/*\nYou can mark a table as pending with `XDescribeTableSubtree`.  This is equivalent to `XDescribe`.\n*/\nvar XDescribeTableSubtree = PDescribeTableSubtree\n\n/*\nTableEntry represents an entry in a table test.  You generally use the `Entry` constructor.\n*/\ntype TableEntry struct {\n\tdescription  any\n\tdecorations  []any\n\tparameters   []any\n\tcodeLocation types.CodeLocation\n}\n\n/*\nEntry constructs a TableEntry.\n\nThe first argument is a description.  This can be a string, a function that accepts the parameters passed to the TableEntry and returns a string, an EntryDescription format string, or nil.  If nil is provided then the name of the Entry is derived using the table-level entry description.\nSubsequent arguments accept any Ginkgo decorators.  These are filtered out and the remaining arguments are passed into the Spec function associated with the table.\n\nEach Entry ends up generating an individual Ginkgo It.  The body of the it is the Table Body function with the Entry parameters passed in.\n\nIf you want to generate interruptible specs simply write a Table function that accepts a SpecContext as its first argument.  You can then decorate individual Entrys with the NodeTimeout and SpecTimeout decorators.\n\nYou can learn more about Entry here: https://onsi.github.io/ginkgo/#table-specs\n*/\nfunc Entry(description any, args ...any) TableEntry {\n\tGinkgoHelper()\n\tdecorations, parameters := internal.PartitionDecorations(args...)\n\treturn TableEntry{description: description, decorations: decorations, parameters: parameters, codeLocation: types.NewCodeLocation(0)}\n}\n\n/*\nYou can focus a particular entry with FEntry.  This is equivalent to FIt.\n*/\nfunc FEntry(description any, args ...any) TableEntry {\n\tGinkgoHelper()\n\tdecorations, parameters := internal.PartitionDecorations(args...)\n\tdecorations = append(decorations, internal.Focus)\n\treturn TableEntry{description: description, decorations: decorations, parameters: parameters, codeLocation: types.NewCodeLocation(0)}\n}\n\n/*\nYou can mark a particular entry as pending with PEntry.  This is equivalent to PIt.\n*/\nfunc PEntry(description any, args ...any) TableEntry {\n\tGinkgoHelper()\n\tdecorations, parameters := internal.PartitionDecorations(args...)\n\tdecorations = append(decorations, internal.Pending)\n\treturn TableEntry{description: description, decorations: decorations, parameters: parameters, codeLocation: types.NewCodeLocation(0)}\n}\n\n/*\nYou can mark a particular entry as pending with XEntry.  This is equivalent to XIt.\n*/\nvar XEntry = PEntry\n\nvar contextType = reflect.TypeOf(new(context.Context)).Elem()\nvar specContextType = reflect.TypeOf(new(SpecContext)).Elem()\n\nfunc generateTable(description string, isSubtree bool, args ...any) {\n\tGinkgoHelper()\n\tcl := types.NewCodeLocation(0)\n\tcontainerNodeArgs := []any{cl}\n\n\tentries := []TableEntry{}\n\tvar internalBody any\n\tvar internalBodyType reflect.Type\n\n\tvar tableLevelEntryDescription any\n\ttableLevelEntryDescription = func(args ...any) string {\n\t\tout := []string{}\n\t\tfor _, arg := range args {\n\t\t\tout = append(out, fmt.Sprint(arg))\n\t\t}\n\t\treturn \"Entry: \" + strings.Join(out, \", \")\n\t}\n\n\tif len(args) == 1 {\n\t\texitIfErr(types.GinkgoErrors.MissingParametersForTableFunction(cl))\n\t}\n\n\tfor i, arg := range args {\n\t\tswitch t := reflect.TypeOf(arg); {\n\t\tcase t == nil:\n\t\t\texitIfErr(types.GinkgoErrors.IncorrectParameterTypeForTable(i, \"nil\", cl))\n\t\tcase t == reflect.TypeOf(TableEntry{}):\n\t\t\tentries = append(entries, arg.(TableEntry))\n\t\tcase t == reflect.TypeOf([]TableEntry{}):\n\t\t\tentries = append(entries, arg.([]TableEntry)...)\n\t\tcase t == reflect.TypeOf(EntryDescription(\"\")):\n\t\t\ttableLevelEntryDescription = arg.(EntryDescription).render\n\t\tcase t.Kind() == reflect.Func && t.NumOut() == 1 && t.Out(0) == reflect.TypeOf(\"\"):\n\t\t\ttableLevelEntryDescription = arg\n\t\tcase t.Kind() == reflect.Func:\n\t\t\tif internalBody != nil {\n\t\t\t\texitIfErr(types.GinkgoErrors.MultipleEntryBodyFunctionsForTable(cl))\n\t\t\t}\n\t\t\tinternalBody = arg\n\t\t\tinternalBodyType = reflect.TypeOf(internalBody)\n\t\tdefault:\n\t\t\tcontainerNodeArgs = append(containerNodeArgs, arg)\n\t\t}\n\t}\n\n\tcontainerNodeArgs = append(containerNodeArgs, func() {\n\t\tfor _, entry := range entries {\n\t\t\tvar err error\n\t\t\tentry := entry\n\t\t\tvar description string\n\t\t\tswitch t := reflect.TypeOf(entry.description); {\n\t\t\tcase t == nil:\n\t\t\t\terr = validateParameters(tableLevelEntryDescription, entry.parameters, \"Entry Description function\", entry.codeLocation, false)\n\t\t\t\tif err == nil {\n\t\t\t\t\tdescription = invokeFunction(tableLevelEntryDescription, entry.parameters)[0].String()\n\t\t\t\t}\n\t\t\tcase t == reflect.TypeOf(EntryDescription(\"\")):\n\t\t\t\tdescription = entry.description.(EntryDescription).render(entry.parameters...)\n\t\t\tcase t == reflect.TypeOf(\"\"):\n\t\t\t\tdescription = entry.description.(string)\n\t\t\tcase t.Kind() == reflect.Func && t.NumOut() == 1 && t.Out(0) == reflect.TypeOf(\"\"):\n\t\t\t\terr = validateParameters(entry.description, entry.parameters, \"Entry Description function\", entry.codeLocation, false)\n\t\t\t\tif err == nil {\n\t\t\t\t\tdescription = invokeFunction(entry.description, entry.parameters)[0].String()\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\terr = types.GinkgoErrors.InvalidEntryDescription(entry.codeLocation)\n\t\t\t}\n\n\t\t\tinternalNodeArgs := []any{entry.codeLocation}\n\t\t\tinternalNodeArgs = append(internalNodeArgs, entry.decorations...)\n\n\t\t\thasContext := false\n\t\t\tif internalBodyType.NumIn() > 0 {\n\t\t\t\tif internalBodyType.In(0).Implements(specContextType) {\n\t\t\t\t\thasContext = true\n\t\t\t\t} else if internalBodyType.In(0).Implements(contextType) {\n\t\t\t\t\thasContext = true\n\t\t\t\t\tif len(entry.parameters) > 0 && reflect.TypeOf(entry.parameters[0]) != nil && reflect.TypeOf(entry.parameters[0]).Implements(contextType) {\n\t\t\t\t\t\t// we allow you to pass in a non-nil context\n\t\t\t\t\t\thasContext = false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif err == nil {\n\t\t\t\terr = validateParameters(internalBody, entry.parameters, \"Table Body function\", entry.codeLocation, hasContext)\n\t\t\t}\n\n\t\t\tif hasContext {\n\t\t\t\tinternalNodeArgs = append(internalNodeArgs, func(c SpecContext) {\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tpanic(err)\n\t\t\t\t\t}\n\t\t\t\t\tinvokeFunction(internalBody, append([]any{c}, entry.parameters...))\n\t\t\t\t})\n\t\t\t\tif isSubtree {\n\t\t\t\t\texitIfErr(types.GinkgoErrors.ContextsCannotBeUsedInSubtreeTables(cl))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tinternalNodeArgs = append(internalNodeArgs, func() {\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tpanic(err)\n\t\t\t\t\t}\n\t\t\t\t\tinvokeFunction(internalBody, entry.parameters)\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tinternalNodeType := types.NodeTypeIt\n\t\t\tif isSubtree {\n\t\t\t\tinternalNodeType = types.NodeTypeContainer\n\t\t\t}\n\n\t\t\tpushNode(internal.NewNode(deprecationTracker, internalNodeType, description, internalNodeArgs...))\n\t\t}\n\t})\n\n\tpushNode(internal.NewNode(deprecationTracker, types.NodeTypeContainer, description, containerNodeArgs...))\n}\n\nfunc invokeFunction(function any, parameters []any) []reflect.Value {\n\tinValues := make([]reflect.Value, len(parameters))\n\n\tfuncType := reflect.TypeOf(function)\n\tlimit := funcType.NumIn()\n\tif funcType.IsVariadic() {\n\t\tlimit = limit - 1\n\t}\n\n\tfor i := 0; i < limit && i < len(parameters); i++ {\n\t\tinValues[i] = computeValue(parameters[i], funcType.In(i))\n\t}\n\n\tif funcType.IsVariadic() {\n\t\tvariadicType := funcType.In(limit).Elem()\n\t\tfor i := limit; i < len(parameters); i++ {\n\t\t\tinValues[i] = computeValue(parameters[i], variadicType)\n\t\t}\n\t}\n\n\treturn reflect.ValueOf(function).Call(inValues)\n}\n\nfunc validateParameters(function any, parameters []any, kind string, cl types.CodeLocation, hasContext bool) error {\n\tfuncType := reflect.TypeOf(function)\n\tlimit := funcType.NumIn()\n\toffset := 0\n\tif hasContext {\n\t\tlimit = limit - 1\n\t\toffset = 1\n\t}\n\tif funcType.IsVariadic() {\n\t\tlimit = limit - 1\n\t}\n\tif len(parameters) < limit {\n\t\treturn types.GinkgoErrors.TooFewParametersToTableFunction(limit, len(parameters), kind, cl)\n\t}\n\tif len(parameters) > limit && !funcType.IsVariadic() {\n\t\treturn types.GinkgoErrors.TooManyParametersToTableFunction(limit, len(parameters), kind, cl)\n\t}\n\tvar i = 0\n\tfor ; i < limit; i++ {\n\t\tactual := reflect.TypeOf(parameters[i])\n\t\texpected := funcType.In(i + offset)\n\t\tif !(actual == nil) && !actual.AssignableTo(expected) {\n\t\t\treturn types.GinkgoErrors.IncorrectParameterTypeToTableFunction(i+1, expected, actual, kind, cl)\n\t\t}\n\t}\n\tif funcType.IsVariadic() {\n\t\texpected := funcType.In(limit + offset).Elem()\n\t\tfor ; i < len(parameters); i++ {\n\t\t\tactual := reflect.TypeOf(parameters[i])\n\t\t\tif !(actual == nil) && !actual.AssignableTo(expected) {\n\t\t\t\treturn types.GinkgoErrors.IncorrectVariadicParameterTypeToTableFunction(expected, actual, kind, cl)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc computeValue(parameter any, t reflect.Type) reflect.Value {\n\tif parameter == nil {\n\t\treturn reflect.Zero(t)\n\t} else {\n\t\treturn reflect.ValueOf(parameter)\n\t}\n}\n"
        },
        {
          "name": "types",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}