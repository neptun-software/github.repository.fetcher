{
  "metadata": {
    "timestamp": 1736567561506,
    "page": 159,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "fatih/color",
      "stars": 7459,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0537109375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2013 Fatih Arslan\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.37890625,
          "content": "# color [![](https://github.com/fatih/color/workflows/build/badge.svg)](https://github.com/fatih/color/actions) [![PkgGoDev](https://pkg.go.dev/badge/github.com/fatih/color)](https://pkg.go.dev/github.com/fatih/color)\n\nColor lets you use colorized outputs in terms of [ANSI Escape\nCodes](http://en.wikipedia.org/wiki/ANSI_escape_code#Colors) in Go (Golang). It\nhas support for Windows too! The API can be used in several ways, pick one that\nsuits you.\n\n![Color](https://user-images.githubusercontent.com/438920/96832689-03b3e000-13f4-11eb-9803-46f4c4de3406.jpg)\n\n## Install\n\n```\ngo get github.com/fatih/color\n```\n\n## Examples\n\n### Standard colors\n\n```go\n// Print with default helper functions\ncolor.Cyan(\"Prints text in cyan.\")\n\n// A newline will be appended automatically\ncolor.Blue(\"Prints %s in blue.\", \"text\")\n\n// These are using the default foreground colors\ncolor.Red(\"We have red\")\ncolor.Magenta(\"And many others ..\")\n\n```\n\n### RGB colors\n\nIf your terminal supports 24-bit colors, you can use RGB color codes.\n\n```go\ncolor.RGB(255, 128, 0).Println(\"foreground orange\")\ncolor.RGB(230, 42, 42).Println(\"foreground red\")\n\ncolor.BgRGB(255, 128, 0).Println(\"background orange\")\ncolor.BgRGB(230, 42, 42).Println(\"background red\")\n```\n\n### Mix and reuse colors\n\n```go\n// Create a new color object\nc := color.New(color.FgCyan).Add(color.Underline)\nc.Println(\"Prints cyan text with an underline.\")\n\n// Or just add them to New()\nd := color.New(color.FgCyan, color.Bold)\nd.Printf(\"This prints bold cyan %s\\n\", \"too!.\")\n\n// Mix up foreground and background colors, create new mixes!\nred := color.New(color.FgRed)\n\nboldRed := red.Add(color.Bold)\nboldRed.Println(\"This will print text in bold red.\")\n\nwhiteBackground := red.Add(color.BgWhite)\nwhiteBackground.Println(\"Red text with white background.\")\n\n// Mix with RGB color codes\ncolor.RGB(255, 128, 0).AddBgRGB(0, 0, 0).Println(\"orange with black background\")\n\ncolor.BgRGB(255, 128, 0).AddRGB(255, 255, 255).Println(\"orange background with white foreground\")\n```\n\n### Use your own output (io.Writer)\n\n```go\n// Use your own io.Writer output\ncolor.New(color.FgBlue).Fprintln(myWriter, \"blue color!\")\n\nblue := color.New(color.FgBlue)\nblue.Fprint(writer, \"This will print text in blue.\")\n```\n\n### Custom print functions (PrintFunc)\n\n```go\n// Create a custom print function for convenience\nred := color.New(color.FgRed).PrintfFunc()\nred(\"Warning\")\nred(\"Error: %s\", err)\n\n// Mix up multiple attributes\nnotice := color.New(color.Bold, color.FgGreen).PrintlnFunc()\nnotice(\"Don't forget this...\")\n```\n\n### Custom fprint functions (FprintFunc)\n\n```go\nblue := color.New(color.FgBlue).FprintfFunc()\nblue(myWriter, \"important notice: %s\", stars)\n\n// Mix up with multiple attributes\nsuccess := color.New(color.Bold, color.FgGreen).FprintlnFunc()\nsuccess(myWriter, \"Don't forget this...\")\n```\n\n### Insert into noncolor strings (SprintFunc)\n\n```go\n// Create SprintXxx functions to mix strings with other non-colorized strings:\nyellow := color.New(color.FgYellow).SprintFunc()\nred := color.New(color.FgRed).SprintFunc()\nfmt.Printf(\"This is a %s and this is %s.\\n\", yellow(\"warning\"), red(\"error\"))\n\ninfo := color.New(color.FgWhite, color.BgGreen).SprintFunc()\nfmt.Printf(\"This %s rocks!\\n\", info(\"package\"))\n\n// Use helper functions\nfmt.Println(\"This\", color.RedString(\"warning\"), \"should be not neglected.\")\nfmt.Printf(\"%v %v\\n\", color.GreenString(\"Info:\"), \"an important message.\")\n\n// Windows supported too! Just don't forget to change the output to color.Output\nfmt.Fprintf(color.Output, \"Windows support: %s\", color.GreenString(\"PASS\"))\n```\n\n### Plug into existing code\n\n```go\n// Use handy standard colors\ncolor.Set(color.FgYellow)\n\nfmt.Println(\"Existing text will now be in yellow\")\nfmt.Printf(\"This one %s\\n\", \"too\")\n\ncolor.Unset() // Don't forget to unset\n\n// You can mix up parameters\ncolor.Set(color.FgMagenta, color.Bold)\ndefer color.Unset() // Use it in your function\n\nfmt.Println(\"All text will now be bold magenta.\")\n```\n\n### Disable/Enable color\n\nThere might be a case where you want to explicitly disable/enable color output. the \n`go-isatty` package will automatically disable color output for non-tty output streams \n(for example if the output were piped directly to `less`).\n\nThe `color` package also disables color output if the [`NO_COLOR`](https://no-color.org) environment\nvariable is set to a non-empty string.\n\n`Color` has support to disable/enable colors programmatically both globally and\nfor single color definitions. For example suppose you have a CLI app and a\n`-no-color` bool flag. You can easily disable the color output with:\n\n```go\nvar flagNoColor = flag.Bool(\"no-color\", false, \"Disable color output\")\n\nif *flagNoColor {\n\tcolor.NoColor = true // disables colorized output\n}\n```\n\nIt also has support for single color definitions (local). You can\ndisable/enable color output on the fly:\n\n```go\nc := color.New(color.FgCyan)\nc.Println(\"Prints cyan text\")\n\nc.DisableColor()\nc.Println(\"This is printed without any color\")\n\nc.EnableColor()\nc.Println(\"This prints again cyan...\")\n```\n\n## GitHub Actions\n\nTo output color in GitHub Actions (or other CI systems that support ANSI colors), make sure to set `color.NoColor = false` so that it bypasses the check for non-tty output streams. \n\n\n## Credits\n\n* [Fatih Arslan](https://github.com/fatih)\n* Windows support via @mattn: [colorable](https://github.com/mattn/go-colorable)\n\n## License\n\nThe MIT License (MIT) - see [`LICENSE.md`](https://github.com/fatih/color/blob/master/LICENSE.md) for more details\n"
        },
        {
          "name": "color.go",
          "type": "blob",
          "size": 20.5263671875,
          "content": "package color\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/mattn/go-colorable\"\n\t\"github.com/mattn/go-isatty\"\n)\n\nvar (\n\t// NoColor defines if the output is colorized or not. It's dynamically set to\n\t// false or true based on the stdout's file descriptor referring to a terminal\n\t// or not. It's also set to true if the NO_COLOR environment variable is\n\t// set (regardless of its value). This is a global option and affects all\n\t// colors. For more control over each color block use the methods\n\t// DisableColor() individually.\n\tNoColor = noColorIsSet() || os.Getenv(\"TERM\") == \"dumb\" ||\n\t\t(!isatty.IsTerminal(os.Stdout.Fd()) && !isatty.IsCygwinTerminal(os.Stdout.Fd()))\n\n\t// Output defines the standard output of the print functions. By default,\n\t// os.Stdout is used.\n\tOutput = colorable.NewColorableStdout()\n\n\t// Error defines a color supporting writer for os.Stderr.\n\tError = colorable.NewColorableStderr()\n\n\t// colorsCache is used to reduce the count of created Color objects and\n\t// allows to reuse already created objects with required Attribute.\n\tcolorsCache   = make(map[Attribute]*Color)\n\tcolorsCacheMu sync.Mutex // protects colorsCache\n)\n\n// noColorIsSet returns true if the environment variable NO_COLOR is set to a non-empty string.\nfunc noColorIsSet() bool {\n\treturn os.Getenv(\"NO_COLOR\") != \"\"\n}\n\n// Color defines a custom color object which is defined by SGR parameters.\ntype Color struct {\n\tparams  []Attribute\n\tnoColor *bool\n}\n\n// Attribute defines a single SGR Code\ntype Attribute int\n\nconst escape = \"\\x1b\"\n\n// Base attributes\nconst (\n\tReset Attribute = iota\n\tBold\n\tFaint\n\tItalic\n\tUnderline\n\tBlinkSlow\n\tBlinkRapid\n\tReverseVideo\n\tConcealed\n\tCrossedOut\n)\n\nconst (\n\tResetBold Attribute = iota + 22\n\tResetItalic\n\tResetUnderline\n\tResetBlinking\n\t_\n\tResetReversed\n\tResetConcealed\n\tResetCrossedOut\n)\n\nvar mapResetAttributes map[Attribute]Attribute = map[Attribute]Attribute{\n\tBold:         ResetBold,\n\tFaint:        ResetBold,\n\tItalic:       ResetItalic,\n\tUnderline:    ResetUnderline,\n\tBlinkSlow:    ResetBlinking,\n\tBlinkRapid:   ResetBlinking,\n\tReverseVideo: ResetReversed,\n\tConcealed:    ResetConcealed,\n\tCrossedOut:   ResetCrossedOut,\n}\n\n// Foreground text colors\nconst (\n\tFgBlack Attribute = iota + 30\n\tFgRed\n\tFgGreen\n\tFgYellow\n\tFgBlue\n\tFgMagenta\n\tFgCyan\n\tFgWhite\n\n\t// used internally for 256 and 24-bit coloring\n\tforeground\n)\n\n// Foreground Hi-Intensity text colors\nconst (\n\tFgHiBlack Attribute = iota + 90\n\tFgHiRed\n\tFgHiGreen\n\tFgHiYellow\n\tFgHiBlue\n\tFgHiMagenta\n\tFgHiCyan\n\tFgHiWhite\n)\n\n// Background text colors\nconst (\n\tBgBlack Attribute = iota + 40\n\tBgRed\n\tBgGreen\n\tBgYellow\n\tBgBlue\n\tBgMagenta\n\tBgCyan\n\tBgWhite\n\n\t// used internally for 256 and 24-bit coloring\n\tbackground\n)\n\n// Background Hi-Intensity text colors\nconst (\n\tBgHiBlack Attribute = iota + 100\n\tBgHiRed\n\tBgHiGreen\n\tBgHiYellow\n\tBgHiBlue\n\tBgHiMagenta\n\tBgHiCyan\n\tBgHiWhite\n)\n\n// New returns a newly created color object.\nfunc New(value ...Attribute) *Color {\n\tc := &Color{\n\t\tparams: make([]Attribute, 0),\n\t}\n\n\tif noColorIsSet() {\n\t\tc.noColor = boolPtr(true)\n\t}\n\n\tc.Add(value...)\n\treturn c\n}\n\n// RGB returns a new foreground color in 24-bit RGB.\nfunc RGB(r, g, b int) *Color {\n\treturn New(foreground, 2, Attribute(r), Attribute(g), Attribute(b))\n}\n\n// BgRGB returns a new background color in 24-bit RGB.\nfunc BgRGB(r, g, b int) *Color {\n\treturn New(background, 2, Attribute(r), Attribute(g), Attribute(b))\n}\n\n// AddRGB is used to chain foreground RGB SGR parameters. Use as many as parameters to combine\n// and create custom color objects. Example: .Add(34, 0, 12).Add(255, 128, 0).\nfunc (c *Color) AddRGB(r, g, b int) *Color {\n\tc.params = append(c.params, foreground, 2, Attribute(r), Attribute(g), Attribute(b))\n\treturn c\n}\n\n// AddRGB is used to chain background RGB SGR parameters. Use as many as parameters to combine\n// and create custom color objects. Example: .Add(34, 0, 12).Add(255, 128, 0).\nfunc (c *Color) AddBgRGB(r, g, b int) *Color {\n\tc.params = append(c.params, background, 2, Attribute(r), Attribute(g), Attribute(b))\n\treturn c\n}\n\n// Set sets the given parameters immediately. It will change the color of\n// output with the given SGR parameters until color.Unset() is called.\nfunc Set(p ...Attribute) *Color {\n\tc := New(p...)\n\tc.Set()\n\treturn c\n}\n\n// Unset resets all escape attributes and clears the output. Usually should\n// be called after Set().\nfunc Unset() {\n\tif NoColor {\n\t\treturn\n\t}\n\n\tfmt.Fprintf(Output, \"%s[%dm\", escape, Reset)\n}\n\n// Set sets the SGR sequence.\nfunc (c *Color) Set() *Color {\n\tif c.isNoColorSet() {\n\t\treturn c\n\t}\n\n\tfmt.Fprint(Output, c.format())\n\treturn c\n}\n\nfunc (c *Color) unset() {\n\tif c.isNoColorSet() {\n\t\treturn\n\t}\n\n\tUnset()\n}\n\n// SetWriter is used to set the SGR sequence with the given io.Writer. This is\n// a low-level function, and users should use the higher-level functions, such\n// as color.Fprint, color.Print, etc.\nfunc (c *Color) SetWriter(w io.Writer) *Color {\n\tif c.isNoColorSet() {\n\t\treturn c\n\t}\n\n\tfmt.Fprint(w, c.format())\n\treturn c\n}\n\n// UnsetWriter resets all escape attributes and clears the output with the give\n// io.Writer. Usually should be called after SetWriter().\nfunc (c *Color) UnsetWriter(w io.Writer) {\n\tif c.isNoColorSet() {\n\t\treturn\n\t}\n\n\tfmt.Fprintf(w, \"%s[%dm\", escape, Reset)\n}\n\n// Add is used to chain SGR parameters. Use as many as parameters to combine\n// and create custom color objects. Example: Add(color.FgRed, color.Underline).\nfunc (c *Color) Add(value ...Attribute) *Color {\n\tc.params = append(c.params, value...)\n\treturn c\n}\n\n// Fprint formats using the default formats for its operands and writes to w.\n// Spaces are added between operands when neither is a string.\n// It returns the number of bytes written and any write error encountered.\n// On Windows, users should wrap w with colorable.NewColorable() if w is of\n// type *os.File.\nfunc (c *Color) Fprint(w io.Writer, a ...interface{}) (n int, err error) {\n\tc.SetWriter(w)\n\tdefer c.UnsetWriter(w)\n\n\treturn fmt.Fprint(w, a...)\n}\n\n// Print formats using the default formats for its operands and writes to\n// standard output. Spaces are added between operands when neither is a\n// string. It returns the number of bytes written and any write error\n// encountered. This is the standard fmt.Print() method wrapped with the given\n// color.\nfunc (c *Color) Print(a ...interface{}) (n int, err error) {\n\tc.Set()\n\tdefer c.unset()\n\n\treturn fmt.Fprint(Output, a...)\n}\n\n// Fprintf formats according to a format specifier and writes to w.\n// It returns the number of bytes written and any write error encountered.\n// On Windows, users should wrap w with colorable.NewColorable() if w is of\n// type *os.File.\nfunc (c *Color) Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {\n\tc.SetWriter(w)\n\tdefer c.UnsetWriter(w)\n\n\treturn fmt.Fprintf(w, format, a...)\n}\n\n// Printf formats according to a format specifier and writes to standard output.\n// It returns the number of bytes written and any write error encountered.\n// This is the standard fmt.Printf() method wrapped with the given color.\nfunc (c *Color) Printf(format string, a ...interface{}) (n int, err error) {\n\tc.Set()\n\tdefer c.unset()\n\n\treturn fmt.Fprintf(Output, format, a...)\n}\n\n// Fprintln formats using the default formats for its operands and writes to w.\n// Spaces are always added between operands and a newline is appended.\n// On Windows, users should wrap w with colorable.NewColorable() if w is of\n// type *os.File.\nfunc (c *Color) Fprintln(w io.Writer, a ...interface{}) (n int, err error) {\n\treturn fmt.Fprintln(w, c.wrap(sprintln(a...)))\n}\n\n// Println formats using the default formats for its operands and writes to\n// standard output. Spaces are always added between operands and a newline is\n// appended. It returns the number of bytes written and any write error\n// encountered. This is the standard fmt.Print() method wrapped with the given\n// color.\nfunc (c *Color) Println(a ...interface{}) (n int, err error) {\n\treturn fmt.Fprintln(Output, c.wrap(sprintln(a...)))\n}\n\n// Sprint is just like Print, but returns a string instead of printing it.\nfunc (c *Color) Sprint(a ...interface{}) string {\n\treturn c.wrap(fmt.Sprint(a...))\n}\n\n// Sprintln is just like Println, but returns a string instead of printing it.\nfunc (c *Color) Sprintln(a ...interface{}) string {\n\treturn c.wrap(sprintln(a...)) + \"\\n\"\n}\n\n// Sprintf is just like Printf, but returns a string instead of printing it.\nfunc (c *Color) Sprintf(format string, a ...interface{}) string {\n\treturn c.wrap(fmt.Sprintf(format, a...))\n}\n\n// FprintFunc returns a new function that prints the passed arguments as\n// colorized with color.Fprint().\nfunc (c *Color) FprintFunc() func(w io.Writer, a ...interface{}) {\n\treturn func(w io.Writer, a ...interface{}) {\n\t\tc.Fprint(w, a...)\n\t}\n}\n\n// PrintFunc returns a new function that prints the passed arguments as\n// colorized with color.Print().\nfunc (c *Color) PrintFunc() func(a ...interface{}) {\n\treturn func(a ...interface{}) {\n\t\tc.Print(a...)\n\t}\n}\n\n// FprintfFunc returns a new function that prints the passed arguments as\n// colorized with color.Fprintf().\nfunc (c *Color) FprintfFunc() func(w io.Writer, format string, a ...interface{}) {\n\treturn func(w io.Writer, format string, a ...interface{}) {\n\t\tc.Fprintf(w, format, a...)\n\t}\n}\n\n// PrintfFunc returns a new function that prints the passed arguments as\n// colorized with color.Printf().\nfunc (c *Color) PrintfFunc() func(format string, a ...interface{}) {\n\treturn func(format string, a ...interface{}) {\n\t\tc.Printf(format, a...)\n\t}\n}\n\n// FprintlnFunc returns a new function that prints the passed arguments as\n// colorized with color.Fprintln().\nfunc (c *Color) FprintlnFunc() func(w io.Writer, a ...interface{}) {\n\treturn func(w io.Writer, a ...interface{}) {\n\t\tc.Fprintln(w, a...)\n\t}\n}\n\n// PrintlnFunc returns a new function that prints the passed arguments as\n// colorized with color.Println().\nfunc (c *Color) PrintlnFunc() func(a ...interface{}) {\n\treturn func(a ...interface{}) {\n\t\tc.Println(a...)\n\t}\n}\n\n// SprintFunc returns a new function that returns colorized strings for the\n// given arguments with fmt.Sprint(). Useful to put into or mix into other\n// string. Windows users should use this in conjunction with color.Output, example:\n//\n//\tput := New(FgYellow).SprintFunc()\n//\tfmt.Fprintf(color.Output, \"This is a %s\", put(\"warning\"))\nfunc (c *Color) SprintFunc() func(a ...interface{}) string {\n\treturn func(a ...interface{}) string {\n\t\treturn c.wrap(fmt.Sprint(a...))\n\t}\n}\n\n// SprintfFunc returns a new function that returns colorized strings for the\n// given arguments with fmt.Sprintf(). Useful to put into or mix into other\n// string. Windows users should use this in conjunction with color.Output.\nfunc (c *Color) SprintfFunc() func(format string, a ...interface{}) string {\n\treturn func(format string, a ...interface{}) string {\n\t\treturn c.wrap(fmt.Sprintf(format, a...))\n\t}\n}\n\n// SprintlnFunc returns a new function that returns colorized strings for the\n// given arguments with fmt.Sprintln(). Useful to put into or mix into other\n// string. Windows users should use this in conjunction with color.Output.\nfunc (c *Color) SprintlnFunc() func(a ...interface{}) string {\n\treturn func(a ...interface{}) string {\n\t\treturn c.wrap(sprintln(a...)) + \"\\n\"\n\t}\n}\n\n// sequence returns a formatted SGR sequence to be plugged into a \"\\x1b[...m\"\n// an example output might be: \"1;36\" -> bold cyan\nfunc (c *Color) sequence() string {\n\tformat := make([]string, len(c.params))\n\tfor i, v := range c.params {\n\t\tformat[i] = strconv.Itoa(int(v))\n\t}\n\n\treturn strings.Join(format, \";\")\n}\n\n// wrap wraps the s string with the colors attributes. The string is ready to\n// be printed.\nfunc (c *Color) wrap(s string) string {\n\tif c.isNoColorSet() {\n\t\treturn s\n\t}\n\n\treturn c.format() + s + c.unformat()\n}\n\nfunc (c *Color) format() string {\n\treturn fmt.Sprintf(\"%s[%sm\", escape, c.sequence())\n}\n\nfunc (c *Color) unformat() string {\n\t//return fmt.Sprintf(\"%s[%dm\", escape, Reset)\n\t//for each element in sequence let's use the specific reset escape, or the generic one if not found\n\tformat := make([]string, len(c.params))\n\tfor i, v := range c.params {\n\t\tformat[i] = strconv.Itoa(int(Reset))\n\t\tra, ok := mapResetAttributes[v]\n\t\tif ok {\n\t\t\tformat[i] = strconv.Itoa(int(ra))\n\t\t}\n\t}\n\n\treturn fmt.Sprintf(\"%s[%sm\", escape, strings.Join(format, \";\"))\n}\n\n// DisableColor disables the color output. Useful to not change any existing\n// code and still being able to output. Can be used for flags like\n// \"--no-color\". To enable back use EnableColor() method.\nfunc (c *Color) DisableColor() {\n\tc.noColor = boolPtr(true)\n}\n\n// EnableColor enables the color output. Use it in conjunction with\n// DisableColor(). Otherwise, this method has no side effects.\nfunc (c *Color) EnableColor() {\n\tc.noColor = boolPtr(false)\n}\n\nfunc (c *Color) isNoColorSet() bool {\n\t// check first if we have user set action\n\tif c.noColor != nil {\n\t\treturn *c.noColor\n\t}\n\n\t// if not return the global option, which is disabled by default\n\treturn NoColor\n}\n\n// Equals returns a boolean value indicating whether two colors are equal.\nfunc (c *Color) Equals(c2 *Color) bool {\n\tif c == nil && c2 == nil {\n\t\treturn true\n\t}\n\tif c == nil || c2 == nil {\n\t\treturn false\n\t}\n\tif len(c.params) != len(c2.params) {\n\t\treturn false\n\t}\n\n\tfor _, attr := range c.params {\n\t\tif !c2.attrExists(attr) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (c *Color) attrExists(a Attribute) bool {\n\tfor _, attr := range c.params {\n\t\tif attr == a {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc boolPtr(v bool) *bool {\n\treturn &v\n}\n\nfunc getCachedColor(p Attribute) *Color {\n\tcolorsCacheMu.Lock()\n\tdefer colorsCacheMu.Unlock()\n\n\tc, ok := colorsCache[p]\n\tif !ok {\n\t\tc = New(p)\n\t\tcolorsCache[p] = c\n\t}\n\n\treturn c\n}\n\nfunc colorPrint(format string, p Attribute, a ...interface{}) {\n\tc := getCachedColor(p)\n\n\tif !strings.HasSuffix(format, \"\\n\") {\n\t\tformat += \"\\n\"\n\t}\n\n\tif len(a) == 0 {\n\t\tc.Print(format)\n\t} else {\n\t\tc.Printf(format, a...)\n\t}\n}\n\nfunc colorString(format string, p Attribute, a ...interface{}) string {\n\tc := getCachedColor(p)\n\n\tif len(a) == 0 {\n\t\treturn c.SprintFunc()(format)\n\t}\n\n\treturn c.SprintfFunc()(format, a...)\n}\n\n// Black is a convenient helper function to print with black foreground. A\n// newline is appended to format by default.\nfunc Black(format string, a ...interface{}) { colorPrint(format, FgBlack, a...) }\n\n// Red is a convenient helper function to print with red foreground. A\n// newline is appended to format by default.\nfunc Red(format string, a ...interface{}) { colorPrint(format, FgRed, a...) }\n\n// Green is a convenient helper function to print with green foreground. A\n// newline is appended to format by default.\nfunc Green(format string, a ...interface{}) { colorPrint(format, FgGreen, a...) }\n\n// Yellow is a convenient helper function to print with yellow foreground.\n// A newline is appended to format by default.\nfunc Yellow(format string, a ...interface{}) { colorPrint(format, FgYellow, a...) }\n\n// Blue is a convenient helper function to print with blue foreground. A\n// newline is appended to format by default.\nfunc Blue(format string, a ...interface{}) { colorPrint(format, FgBlue, a...) }\n\n// Magenta is a convenient helper function to print with magenta foreground.\n// A newline is appended to format by default.\nfunc Magenta(format string, a ...interface{}) { colorPrint(format, FgMagenta, a...) }\n\n// Cyan is a convenient helper function to print with cyan foreground. A\n// newline is appended to format by default.\nfunc Cyan(format string, a ...interface{}) { colorPrint(format, FgCyan, a...) }\n\n// White is a convenient helper function to print with white foreground. A\n// newline is appended to format by default.\nfunc White(format string, a ...interface{}) { colorPrint(format, FgWhite, a...) }\n\n// BlackString is a convenient helper function to return a string with black\n// foreground.\nfunc BlackString(format string, a ...interface{}) string { return colorString(format, FgBlack, a...) }\n\n// RedString is a convenient helper function to return a string with red\n// foreground.\nfunc RedString(format string, a ...interface{}) string { return colorString(format, FgRed, a...) }\n\n// GreenString is a convenient helper function to return a string with green\n// foreground.\nfunc GreenString(format string, a ...interface{}) string { return colorString(format, FgGreen, a...) }\n\n// YellowString is a convenient helper function to return a string with yellow\n// foreground.\nfunc YellowString(format string, a ...interface{}) string { return colorString(format, FgYellow, a...) }\n\n// BlueString is a convenient helper function to return a string with blue\n// foreground.\nfunc BlueString(format string, a ...interface{}) string { return colorString(format, FgBlue, a...) }\n\n// MagentaString is a convenient helper function to return a string with magenta\n// foreground.\nfunc MagentaString(format string, a ...interface{}) string {\n\treturn colorString(format, FgMagenta, a...)\n}\n\n// CyanString is a convenient helper function to return a string with cyan\n// foreground.\nfunc CyanString(format string, a ...interface{}) string { return colorString(format, FgCyan, a...) }\n\n// WhiteString is a convenient helper function to return a string with white\n// foreground.\nfunc WhiteString(format string, a ...interface{}) string { return colorString(format, FgWhite, a...) }\n\n// HiBlack is a convenient helper function to print with hi-intensity black foreground. A\n// newline is appended to format by default.\nfunc HiBlack(format string, a ...interface{}) { colorPrint(format, FgHiBlack, a...) }\n\n// HiRed is a convenient helper function to print with hi-intensity red foreground. A\n// newline is appended to format by default.\nfunc HiRed(format string, a ...interface{}) { colorPrint(format, FgHiRed, a...) }\n\n// HiGreen is a convenient helper function to print with hi-intensity green foreground. A\n// newline is appended to format by default.\nfunc HiGreen(format string, a ...interface{}) { colorPrint(format, FgHiGreen, a...) }\n\n// HiYellow is a convenient helper function to print with hi-intensity yellow foreground.\n// A newline is appended to format by default.\nfunc HiYellow(format string, a ...interface{}) { colorPrint(format, FgHiYellow, a...) }\n\n// HiBlue is a convenient helper function to print with hi-intensity blue foreground. A\n// newline is appended to format by default.\nfunc HiBlue(format string, a ...interface{}) { colorPrint(format, FgHiBlue, a...) }\n\n// HiMagenta is a convenient helper function to print with hi-intensity magenta foreground.\n// A newline is appended to format by default.\nfunc HiMagenta(format string, a ...interface{}) { colorPrint(format, FgHiMagenta, a...) }\n\n// HiCyan is a convenient helper function to print with hi-intensity cyan foreground. A\n// newline is appended to format by default.\nfunc HiCyan(format string, a ...interface{}) { colorPrint(format, FgHiCyan, a...) }\n\n// HiWhite is a convenient helper function to print with hi-intensity white foreground. A\n// newline is appended to format by default.\nfunc HiWhite(format string, a ...interface{}) { colorPrint(format, FgHiWhite, a...) }\n\n// HiBlackString is a convenient helper function to return a string with hi-intensity black\n// foreground.\nfunc HiBlackString(format string, a ...interface{}) string {\n\treturn colorString(format, FgHiBlack, a...)\n}\n\n// HiRedString is a convenient helper function to return a string with hi-intensity red\n// foreground.\nfunc HiRedString(format string, a ...interface{}) string { return colorString(format, FgHiRed, a...) }\n\n// HiGreenString is a convenient helper function to return a string with hi-intensity green\n// foreground.\nfunc HiGreenString(format string, a ...interface{}) string {\n\treturn colorString(format, FgHiGreen, a...)\n}\n\n// HiYellowString is a convenient helper function to return a string with hi-intensity yellow\n// foreground.\nfunc HiYellowString(format string, a ...interface{}) string {\n\treturn colorString(format, FgHiYellow, a...)\n}\n\n// HiBlueString is a convenient helper function to return a string with hi-intensity blue\n// foreground.\nfunc HiBlueString(format string, a ...interface{}) string { return colorString(format, FgHiBlue, a...) }\n\n// HiMagentaString is a convenient helper function to return a string with hi-intensity magenta\n// foreground.\nfunc HiMagentaString(format string, a ...interface{}) string {\n\treturn colorString(format, FgHiMagenta, a...)\n}\n\n// HiCyanString is a convenient helper function to return a string with hi-intensity cyan\n// foreground.\nfunc HiCyanString(format string, a ...interface{}) string { return colorString(format, FgHiCyan, a...) }\n\n// HiWhiteString is a convenient helper function to return a string with hi-intensity white\n// foreground.\nfunc HiWhiteString(format string, a ...interface{}) string {\n\treturn colorString(format, FgHiWhite, a...)\n}\n\n// sprintln is a helper function to format a string with fmt.Sprintln and trim the trailing newline.\nfunc sprintln(a ...interface{}) string {\n\treturn strings.TrimSuffix(fmt.Sprintln(a...), \"\\n\")\n}\n"
        },
        {
          "name": "color_test.go",
          "type": "blob",
          "size": 13.25390625,
          "content": "package color\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/mattn/go-colorable\"\n)\n\n// Testing colors is kinda different. First we test for given colors and their\n// escaped formatted results. Next we create some visual tests to be tested.\n// Each visual test includes the color name to be compared.\nfunc TestColor(t *testing.T) {\n\trb := new(bytes.Buffer)\n\tOutput = rb\n\n\tNoColor = false\n\n\ttestColors := []struct {\n\t\ttext string\n\t\tcode Attribute\n\t}{\n\t\t{text: \"black\", code: FgBlack},\n\t\t{text: \"red\", code: FgRed},\n\t\t{text: \"green\", code: FgGreen},\n\t\t{text: \"yellow\", code: FgYellow},\n\t\t{text: \"blue\", code: FgBlue},\n\t\t{text: \"magent\", code: FgMagenta},\n\t\t{text: \"cyan\", code: FgCyan},\n\t\t{text: \"white\", code: FgWhite},\n\t\t{text: \"hblack\", code: FgHiBlack},\n\t\t{text: \"hred\", code: FgHiRed},\n\t\t{text: \"hgreen\", code: FgHiGreen},\n\t\t{text: \"hyellow\", code: FgHiYellow},\n\t\t{text: \"hblue\", code: FgHiBlue},\n\t\t{text: \"hmagent\", code: FgHiMagenta},\n\t\t{text: \"hcyan\", code: FgHiCyan},\n\t\t{text: \"hwhite\", code: FgHiWhite},\n\t}\n\n\tfor _, c := range testColors {\n\t\tNew(c.code).Print(c.text)\n\n\t\tline, _ := rb.ReadString('\\n')\n\t\tscannedLine := fmt.Sprintf(\"%q\", line)\n\t\tcolored := fmt.Sprintf(\"\\x1b[%dm%s\\x1b[0m\", c.code, c.text)\n\t\tescapedForm := fmt.Sprintf(\"%q\", colored)\n\n\t\tfmt.Printf(\"%s\\t: %s\\n\", c.text, line)\n\n\t\tif scannedLine != escapedForm {\n\t\t\tt.Errorf(\"Expecting %s, got '%s'\\n\", escapedForm, scannedLine)\n\t\t}\n\t}\n\n\tfor _, c := range testColors {\n\t\tline := New(c.code).Sprintf(\"%s\", c.text)\n\t\tscannedLine := fmt.Sprintf(\"%q\", line)\n\t\tcolored := fmt.Sprintf(\"\\x1b[%dm%s\\x1b[0m\", c.code, c.text)\n\t\tescapedForm := fmt.Sprintf(\"%q\", colored)\n\n\t\tfmt.Printf(\"%s\\t: %s\\n\", c.text, line)\n\n\t\tif scannedLine != escapedForm {\n\t\t\tt.Errorf(\"Expecting %s, got '%s'\\n\", escapedForm, scannedLine)\n\t\t}\n\t}\n}\n\nfunc TestColorEquals(t *testing.T) {\n\tfgblack1 := New(FgBlack)\n\tfgblack2 := New(FgBlack)\n\tbgblack := New(BgBlack)\n\tfgbgblack := New(FgBlack, BgBlack)\n\tfgblackbgred := New(FgBlack, BgRed)\n\tfgred := New(FgRed)\n\tbgred := New(BgRed)\n\n\tif !fgblack1.Equals(fgblack2) {\n\t\tt.Error(\"Two black colors are not equal\")\n\t}\n\n\tif fgblack1.Equals(bgblack) {\n\t\tt.Error(\"Fg and bg black colors are equal\")\n\t}\n\n\tif fgblack1.Equals(fgbgblack) {\n\t\tt.Error(\"Fg black equals fg/bg black color\")\n\t}\n\n\tif fgblack1.Equals(fgred) {\n\t\tt.Error(\"Fg black equals Fg red\")\n\t}\n\n\tif fgblack1.Equals(bgred) {\n\t\tt.Error(\"Fg black equals Bg red\")\n\t}\n\n\tif fgblack1.Equals(fgblackbgred) {\n\t\tt.Error(\"Fg black equals fg black bg red\")\n\t}\n}\n\nfunc TestNoColor(t *testing.T) {\n\trb := new(bytes.Buffer)\n\tOutput = rb\n\n\ttestColors := []struct {\n\t\ttext string\n\t\tcode Attribute\n\t}{\n\t\t{text: \"black\", code: FgBlack},\n\t\t{text: \"red\", code: FgRed},\n\t\t{text: \"green\", code: FgGreen},\n\t\t{text: \"yellow\", code: FgYellow},\n\t\t{text: \"blue\", code: FgBlue},\n\t\t{text: \"magent\", code: FgMagenta},\n\t\t{text: \"cyan\", code: FgCyan},\n\t\t{text: \"white\", code: FgWhite},\n\t\t{text: \"hblack\", code: FgHiBlack},\n\t\t{text: \"hred\", code: FgHiRed},\n\t\t{text: \"hgreen\", code: FgHiGreen},\n\t\t{text: \"hyellow\", code: FgHiYellow},\n\t\t{text: \"hblue\", code: FgHiBlue},\n\t\t{text: \"hmagent\", code: FgHiMagenta},\n\t\t{text: \"hcyan\", code: FgHiCyan},\n\t\t{text: \"hwhite\", code: FgHiWhite},\n\t}\n\n\tfor _, c := range testColors {\n\t\tp := New(c.code)\n\t\tp.DisableColor()\n\t\tp.Print(c.text)\n\n\t\tline, _ := rb.ReadString('\\n')\n\t\tif line != c.text {\n\t\t\tt.Errorf(\"Expecting %s, got '%s'\\n\", c.text, line)\n\t\t}\n\t}\n\n\t// global check\n\tNoColor = true\n\tt.Cleanup(func() {\n\t\tNoColor = false\n\t})\n\n\tfor _, c := range testColors {\n\t\tp := New(c.code)\n\t\tp.Print(c.text)\n\n\t\tline, _ := rb.ReadString('\\n')\n\t\tif line != c.text {\n\t\t\tt.Errorf(\"Expecting %s, got '%s'\\n\", c.text, line)\n\t\t}\n\t}\n}\n\nfunc TestNoColor_Env(t *testing.T) {\n\trb := new(bytes.Buffer)\n\tOutput = rb\n\n\ttestColors := []struct {\n\t\ttext string\n\t\tcode Attribute\n\t}{\n\t\t{text: \"black\", code: FgBlack},\n\t\t{text: \"red\", code: FgRed},\n\t\t{text: \"green\", code: FgGreen},\n\t\t{text: \"yellow\", code: FgYellow},\n\t\t{text: \"blue\", code: FgBlue},\n\t\t{text: \"magent\", code: FgMagenta},\n\t\t{text: \"cyan\", code: FgCyan},\n\t\t{text: \"white\", code: FgWhite},\n\t\t{text: \"hblack\", code: FgHiBlack},\n\t\t{text: \"hred\", code: FgHiRed},\n\t\t{text: \"hgreen\", code: FgHiGreen},\n\t\t{text: \"hyellow\", code: FgHiYellow},\n\t\t{text: \"hblue\", code: FgHiBlue},\n\t\t{text: \"hmagent\", code: FgHiMagenta},\n\t\t{text: \"hcyan\", code: FgHiCyan},\n\t\t{text: \"hwhite\", code: FgHiWhite},\n\t}\n\n\tos.Setenv(\"NO_COLOR\", \"1\")\n\tt.Cleanup(func() {\n\t\tos.Unsetenv(\"NO_COLOR\")\n\t})\n\n\tfor _, c := range testColors {\n\t\tp := New(c.code)\n\t\tp.Print(c.text)\n\n\t\tline, _ := rb.ReadString('\\n')\n\t\tif line != c.text {\n\t\t\tt.Errorf(\"Expecting %s, got '%s'\\n\", c.text, line)\n\t\t}\n\t}\n}\n\nfunc Test_noColorIsSet(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tact  func()\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"default\",\n\t\t\tact:  func() {},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NO_COLOR=1\",\n\t\t\tact:  func() { os.Setenv(\"NO_COLOR\", \"1\") },\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"NO_COLOR=\",\n\t\t\tact:  func() { os.Setenv(\"NO_COLOR\", \"\") },\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Cleanup(func() {\n\t\t\t\tos.Unsetenv(\"NO_COLOR\")\n\t\t\t})\n\t\t\ttt.act()\n\t\t\tif got := noColorIsSet(); got != tt.want {\n\t\t\t\tt.Errorf(\"noColorIsSet() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestColorVisual(t *testing.T) {\n\t// First Visual Test\n\tOutput = colorable.NewColorableStdout()\n\n\tNew(FgRed).Printf(\"red\\t\")\n\tNew(BgRed).Print(\"         \")\n\tNew(FgRed, Bold).Println(\" red\")\n\n\tNew(FgGreen).Printf(\"green\\t\")\n\tNew(BgGreen).Print(\"         \")\n\tNew(FgGreen, Bold).Println(\" green\")\n\n\tNew(FgYellow).Printf(\"yellow\\t\")\n\tNew(BgYellow).Print(\"         \")\n\tNew(FgYellow, Bold).Println(\" yellow\")\n\n\tNew(FgBlue).Printf(\"blue\\t\")\n\tNew(BgBlue).Print(\"         \")\n\tNew(FgBlue, Bold).Println(\" blue\")\n\n\tNew(FgMagenta).Printf(\"magenta\\t\")\n\tNew(BgMagenta).Print(\"         \")\n\tNew(FgMagenta, Bold).Println(\" magenta\")\n\n\tNew(FgCyan).Printf(\"cyan\\t\")\n\tNew(BgCyan).Print(\"         \")\n\tNew(FgCyan, Bold).Println(\" cyan\")\n\n\tNew(FgWhite).Printf(\"white\\t\")\n\tNew(BgWhite).Print(\"         \")\n\tNew(FgWhite, Bold).Println(\" white\")\n\tfmt.Println(\"\")\n\n\t// Second Visual test\n\tBlack(\"black\")\n\tRed(\"red\")\n\tGreen(\"green\")\n\tYellow(\"yellow\")\n\tBlue(\"blue\")\n\tMagenta(\"magenta\")\n\tCyan(\"cyan\")\n\tWhite(\"white\")\n\tHiBlack(\"hblack\")\n\tHiRed(\"hred\")\n\tHiGreen(\"hgreen\")\n\tHiYellow(\"hyellow\")\n\tHiBlue(\"hblue\")\n\tHiMagenta(\"hmagenta\")\n\tHiCyan(\"hcyan\")\n\tHiWhite(\"hwhite\")\n\n\t// Third visual test\n\tfmt.Println()\n\tSet(FgBlue)\n\tfmt.Println(\"is this blue?\")\n\tUnset()\n\n\tSet(FgMagenta)\n\tfmt.Println(\"and this magenta?\")\n\tUnset()\n\n\t// Fourth Visual test\n\tfmt.Println()\n\tblue := New(FgBlue).PrintlnFunc()\n\tblue(\"blue text with custom print func\")\n\n\tred := New(FgRed).PrintfFunc()\n\tred(\"red text with a printf func: %d\\n\", 123)\n\n\tput := New(FgYellow).SprintFunc()\n\twarn := New(FgRed).SprintFunc()\n\n\tfmt.Fprintf(Output, \"this is a %s and this is %s.\\n\", put(\"warning\"), warn(\"error\"))\n\n\tinfo := New(FgWhite, BgGreen).SprintFunc()\n\tfmt.Fprintf(Output, \"this %s rocks!\\n\", info(\"package\"))\n\n\tnotice := New(FgBlue).FprintFunc()\n\tnotice(os.Stderr, \"just a blue notice to stderr\")\n\n\t// Fifth Visual Test\n\tfmt.Println()\n\n\tfmt.Fprintln(Output, BlackString(\"black\"))\n\tfmt.Fprintln(Output, RedString(\"red\"))\n\tfmt.Fprintln(Output, GreenString(\"green\"))\n\tfmt.Fprintln(Output, YellowString(\"yellow\"))\n\tfmt.Fprintln(Output, BlueString(\"blue\"))\n\tfmt.Fprintln(Output, MagentaString(\"magenta\"))\n\tfmt.Fprintln(Output, CyanString(\"cyan\"))\n\tfmt.Fprintln(Output, WhiteString(\"white\"))\n\tfmt.Fprintln(Output, HiBlackString(\"hblack\"))\n\tfmt.Fprintln(Output, HiRedString(\"hred\"))\n\tfmt.Fprintln(Output, HiGreenString(\"hgreen\"))\n\tfmt.Fprintln(Output, HiYellowString(\"hyellow\"))\n\tfmt.Fprintln(Output, HiBlueString(\"hblue\"))\n\tfmt.Fprintln(Output, HiMagentaString(\"hmagenta\"))\n\tfmt.Fprintln(Output, HiCyanString(\"hcyan\"))\n\tfmt.Fprintln(Output, HiWhiteString(\"hwhite\"))\n}\n\nfunc TestNoFormat(t *testing.T) {\n\tfmt.Printf(\"%s   %%s = \", BlackString(\"Black\"))\n\tBlack(\"%s\")\n\n\tfmt.Printf(\"%s     %%s = \", RedString(\"Red\"))\n\tRed(\"%s\")\n\n\tfmt.Printf(\"%s   %%s = \", GreenString(\"Green\"))\n\tGreen(\"%s\")\n\n\tfmt.Printf(\"%s  %%s = \", YellowString(\"Yellow\"))\n\tYellow(\"%s\")\n\n\tfmt.Printf(\"%s    %%s = \", BlueString(\"Blue\"))\n\tBlue(\"%s\")\n\n\tfmt.Printf(\"%s %%s = \", MagentaString(\"Magenta\"))\n\tMagenta(\"%s\")\n\n\tfmt.Printf(\"%s    %%s = \", CyanString(\"Cyan\"))\n\tCyan(\"%s\")\n\n\tfmt.Printf(\"%s   %%s = \", WhiteString(\"White\"))\n\tWhite(\"%s\")\n\n\tfmt.Printf(\"%s   %%s = \", HiBlackString(\"HiBlack\"))\n\tHiBlack(\"%s\")\n\n\tfmt.Printf(\"%s     %%s = \", HiRedString(\"HiRed\"))\n\tHiRed(\"%s\")\n\n\tfmt.Printf(\"%s   %%s = \", HiGreenString(\"HiGreen\"))\n\tHiGreen(\"%s\")\n\n\tfmt.Printf(\"%s  %%s = \", HiYellowString(\"HiYellow\"))\n\tHiYellow(\"%s\")\n\n\tfmt.Printf(\"%s    %%s = \", HiBlueString(\"HiBlue\"))\n\tHiBlue(\"%s\")\n\n\tfmt.Printf(\"%s %%s = \", HiMagentaString(\"HiMagenta\"))\n\tHiMagenta(\"%s\")\n\n\tfmt.Printf(\"%s    %%s = \", HiCyanString(\"HiCyan\"))\n\tHiCyan(\"%s\")\n\n\tfmt.Printf(\"%s   %%s = \", HiWhiteString(\"HiWhite\"))\n\tHiWhite(\"%s\")\n}\n\nfunc TestNoFormatString(t *testing.T) {\n\ttests := []struct {\n\t\tf      func(string, ...interface{}) string\n\t\tformat string\n\t\targs   []interface{}\n\t\twant   string\n\t}{\n\t\t{BlackString, \"%s\", nil, \"\\x1b[30m%s\\x1b[0m\"},\n\t\t{RedString, \"%s\", nil, \"\\x1b[31m%s\\x1b[0m\"},\n\t\t{GreenString, \"%s\", nil, \"\\x1b[32m%s\\x1b[0m\"},\n\t\t{YellowString, \"%s\", nil, \"\\x1b[33m%s\\x1b[0m\"},\n\t\t{BlueString, \"%s\", nil, \"\\x1b[34m%s\\x1b[0m\"},\n\t\t{MagentaString, \"%s\", nil, \"\\x1b[35m%s\\x1b[0m\"},\n\t\t{CyanString, \"%s\", nil, \"\\x1b[36m%s\\x1b[0m\"},\n\t\t{WhiteString, \"%s\", nil, \"\\x1b[37m%s\\x1b[0m\"},\n\t\t{HiBlackString, \"%s\", nil, \"\\x1b[90m%s\\x1b[0m\"},\n\t\t{HiRedString, \"%s\", nil, \"\\x1b[91m%s\\x1b[0m\"},\n\t\t{HiGreenString, \"%s\", nil, \"\\x1b[92m%s\\x1b[0m\"},\n\t\t{HiYellowString, \"%s\", nil, \"\\x1b[93m%s\\x1b[0m\"},\n\t\t{HiBlueString, \"%s\", nil, \"\\x1b[94m%s\\x1b[0m\"},\n\t\t{HiMagentaString, \"%s\", nil, \"\\x1b[95m%s\\x1b[0m\"},\n\t\t{HiCyanString, \"%s\", nil, \"\\x1b[96m%s\\x1b[0m\"},\n\t\t{HiWhiteString, \"%s\", nil, \"\\x1b[97m%s\\x1b[0m\"},\n\t}\n\n\tfor i, test := range tests {\n\t\ts := test.f(test.format, test.args...)\n\n\t\tif s != test.want {\n\t\t\tt.Errorf(\"[%d] want: %q, got: %q\", i, test.want, s)\n\t\t}\n\t}\n}\n\nfunc TestColor_Println_Newline(t *testing.T) {\n\trb := new(bytes.Buffer)\n\tOutput = rb\n\n\tc := New(FgRed)\n\tc.Println(\"foo\")\n\n\tgot := readRaw(t, rb)\n\twant := \"\\x1b[31mfoo\\x1b[0m\\n\"\n\n\tif want != got {\n\t\tt.Errorf(\"Println newline error\\n\\nwant: %q\\n got: %q\", want, got)\n\t}\n}\n\nfunc TestColor_Sprintln_Newline(t *testing.T) {\n\tc := New(FgRed)\n\n\tgot := c.Sprintln(\"foo\")\n\twant := \"\\x1b[31mfoo\\x1b[0m\\n\"\n\n\tif want != got {\n\t\tt.Errorf(\"Println newline error\\n\\nwant: %q\\n got: %q\", want, got)\n\t}\n}\n\nfunc TestColor_Fprintln_Newline(t *testing.T) {\n\trb := new(bytes.Buffer)\n\tc := New(FgRed)\n\tc.Fprintln(rb, \"foo\")\n\n\tgot := readRaw(t, rb)\n\twant := \"\\x1b[31mfoo\\x1b[0m\\n\"\n\n\tif want != got {\n\t\tt.Errorf(\"Println newline error\\n\\nwant: %q\\n got: %q\", want, got)\n\t}\n}\n\nfunc readRaw(t *testing.T, r io.Reader) string {\n\tt.Helper()\n\n\tout, err := io.ReadAll(r)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn string(out)\n}\n\nfunc TestIssue206_1(t *testing.T) {\n\t// visual test, go test -v .\n\t// to  see the string with escape codes, use go test -v . > c:\\temp\\test.txt\n\tunderline := New(Underline).Sprint\n\n\tline := fmt.Sprintf(\"%s %s %s %s\", \"word1\", underline(\"word2\"), \"word3\", underline(\"word4\"))\n\n\tline = CyanString(line)\n\n\tfmt.Println(line)\n\n\tresult := fmt.Sprintf(\"%v\", line)\n\tconst expectedResult = \"\\x1b[36mword1 \\x1b[4mword2\\x1b[24m word3 \\x1b[4mword4\\x1b[24m\\x1b[0m\"\n\n\tif !bytes.Equal([]byte(result), []byte(expectedResult)) {\n\t\tt.Errorf(\"Expecting %v, got '%v'\\n\", expectedResult, result)\n\t}\n}\n\nfunc TestIssue206_2(t *testing.T) {\n\tunderline := New(Underline).Sprint\n\tbold := New(Bold).Sprint\n\n\tline := fmt.Sprintf(\"%s %s\", GreenString(underline(\"underlined regular green\")), RedString(bold(\"bold red\")))\n\n\tfmt.Println(line)\n\n\tresult := fmt.Sprintf(\"%v\", line)\n\tconst expectedResult = \"\\x1b[32m\\x1b[4munderlined regular green\\x1b[24m\\x1b[0m \\x1b[31m\\x1b[1mbold red\\x1b[22m\\x1b[0m\"\n\n\tif !bytes.Equal([]byte(result), []byte(expectedResult)) {\n\t\tt.Errorf(\"Expecting %v, got '%v'\\n\", expectedResult, result)\n\t}\n}\n\nfunc TestIssue218(t *testing.T) {\n\t// Adds a newline to the end of the last string to make sure it isn't trimmed.\n\tparams := []interface{}{\"word1\", \"word2\", \"word3\", \"word4\\n\"}\n\n\tc := New(FgCyan)\n\tc.Println(params...)\n\n\tresult := c.Sprintln(params...)\n\tfmt.Println(params...)\n\tfmt.Print(result)\n\n\tconst expectedResult = \"\\x1b[36mword1 word2 word3 word4\\n\\x1b[0m\\n\"\n\n\tif !bytes.Equal([]byte(result), []byte(expectedResult)) {\n\t\tt.Errorf(\"Sprintln: Expecting %v (%v), got '%v (%v)'\\n\", expectedResult, []byte(expectedResult), result, []byte(result))\n\t}\n\n\tfn := c.SprintlnFunc()\n\tresult = fn(params...)\n\tif !bytes.Equal([]byte(result), []byte(expectedResult)) {\n\t\tt.Errorf(\"SprintlnFunc: Expecting %v (%v), got '%v (%v)'\\n\", expectedResult, []byte(expectedResult), result, []byte(result))\n\t}\n\n\tvar buf bytes.Buffer\n\tc.Fprintln(&buf, params...)\n\tresult = buf.String()\n\tif !bytes.Equal([]byte(result), []byte(expectedResult)) {\n\t\tt.Errorf(\"Fprintln: Expecting %v (%v), got '%v (%v)'\\n\", expectedResult, []byte(expectedResult), result, []byte(result))\n\t}\n}\n\nfunc TestRGB(t *testing.T) {\n\ttests := []struct {\n\t\tr, g, b int\n\t}{\n\t\t{255, 128, 0}, // orange\n\t\t{230, 42, 42}, // red\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"%d\", i), func(t *testing.T) {\n\t\t\tRGB(tt.r, tt.g, tt.b).Println(\"foreground\")\n\t\t\tRGB(tt.r, tt.g, tt.b).AddBgRGB(0, 0, 0).Println(\"with background\")\n\t\t\tBgRGB(tt.r, tt.g, tt.b).Println(\"background\")\n\t\t\tBgRGB(tt.r, tt.g, tt.b).AddRGB(255, 255, 255).Println(\"with foreground\")\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "color_windows.go",
          "type": "blob",
          "size": 0.4921875,
          "content": "package color\n\nimport (\n\t\"os\"\n\n\t\"golang.org/x/sys/windows\"\n)\n\nfunc init() {\n\t// Opt-in for ansi color support for current process.\n\t// https://learn.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences#output-sequences\n\tvar outMode uint32\n\tout := windows.Handle(os.Stdout.Fd())\n\tif err := windows.GetConsoleMode(out, &outMode); err != nil {\n\t\treturn\n\t}\n\toutMode |= windows.ENABLE_PROCESSED_OUTPUT | windows.ENABLE_VIRTUAL_TERMINAL_PROCESSING\n\t_ = windows.SetConsoleMode(out, outMode)\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 4.18359375,
          "content": "/*\nPackage color is an ANSI color package to output colorized or SGR defined\noutput to the standard output. The API can be used in several way, pick one\nthat suits you.\n\nUse simple and default helper functions with predefined foreground colors:\n\n\tcolor.Cyan(\"Prints text in cyan.\")\n\n\t// a newline will be appended automatically\n\tcolor.Blue(\"Prints %s in blue.\", \"text\")\n\n\t// More default foreground colors..\n\tcolor.Red(\"We have red\")\n\tcolor.Yellow(\"Yellow color too!\")\n\tcolor.Magenta(\"And many others ..\")\n\n\t// Hi-intensity colors\n\tcolor.HiGreen(\"Bright green color.\")\n\tcolor.HiBlack(\"Bright black means gray..\")\n\tcolor.HiWhite(\"Shiny white color!\")\n\nHowever, there are times when custom color mixes are required. Below are some\nexamples to create custom color objects and use the print functions of each\nseparate color object.\n\n\t// Create a new color object\n\tc := color.New(color.FgCyan).Add(color.Underline)\n\tc.Println(\"Prints cyan text with an underline.\")\n\n\t// Or just add them to New()\n\td := color.New(color.FgCyan, color.Bold)\n\td.Printf(\"This prints bold cyan %s\\n\", \"too!.\")\n\n\n\t// Mix up foreground and background colors, create new mixes!\n\tred := color.New(color.FgRed)\n\n\tboldRed := red.Add(color.Bold)\n\tboldRed.Println(\"This will print text in bold red.\")\n\n\twhiteBackground := red.Add(color.BgWhite)\n\twhiteBackground.Println(\"Red text with White background.\")\n\n\t// Use your own io.Writer output\n\tcolor.New(color.FgBlue).Fprintln(myWriter, \"blue color!\")\n\n\tblue := color.New(color.FgBlue)\n\tblue.Fprint(myWriter, \"This will print text in blue.\")\n\nYou can create PrintXxx functions to simplify even more:\n\n\t// Create a custom print function for convenient\n\tred := color.New(color.FgRed).PrintfFunc()\n\tred(\"warning\")\n\tred(\"error: %s\", err)\n\n\t// Mix up multiple attributes\n\tnotice := color.New(color.Bold, color.FgGreen).PrintlnFunc()\n\tnotice(\"don't forget this...\")\n\nYou can also FprintXxx functions to pass your own io.Writer:\n\n\tblue := color.New(FgBlue).FprintfFunc()\n\tblue(myWriter, \"important notice: %s\", stars)\n\n\t// Mix up with multiple attributes\n\tsuccess := color.New(color.Bold, color.FgGreen).FprintlnFunc()\n\tsuccess(myWriter, don't forget this...\")\n\nOr create SprintXxx functions to mix strings with other non-colorized strings:\n\n\tyellow := New(FgYellow).SprintFunc()\n\tred := New(FgRed).SprintFunc()\n\n\tfmt.Printf(\"this is a %s and this is %s.\\n\", yellow(\"warning\"), red(\"error\"))\n\n\tinfo := New(FgWhite, BgGreen).SprintFunc()\n\tfmt.Printf(\"this %s rocks!\\n\", info(\"package\"))\n\nWindows support is enabled by default. All Print functions work as intended.\nHowever, only for color.SprintXXX functions, user should use fmt.FprintXXX and\nset the output to color.Output:\n\n\tfmt.Fprintf(color.Output, \"Windows support: %s\", color.GreenString(\"PASS\"))\n\n\tinfo := New(FgWhite, BgGreen).SprintFunc()\n\tfmt.Fprintf(color.Output, \"this %s rocks!\\n\", info(\"package\"))\n\nUsing with existing code is possible. Just use the Set() method to set the\nstandard output to the given parameters. That way a rewrite of an existing\ncode is not required.\n\n\t// Use handy standard colors.\n\tcolor.Set(color.FgYellow)\n\n\tfmt.Println(\"Existing text will be now in Yellow\")\n\tfmt.Printf(\"This one %s\\n\", \"too\")\n\n\tcolor.Unset() // don't forget to unset\n\n\t// You can mix up parameters\n\tcolor.Set(color.FgMagenta, color.Bold)\n\tdefer color.Unset() // use it in your function\n\n\tfmt.Println(\"All text will be now bold magenta.\")\n\nThere might be a case where you want to disable color output (for example to\npipe the standard output of your app to somewhere else). `Color` has support to\ndisable colors both globally and for single color definition. For example\nsuppose you have a CLI app and a `--no-color` bool flag. You can easily disable\nthe color output with:\n\n\tvar flagNoColor = flag.Bool(\"no-color\", false, \"Disable color output\")\n\n\tif *flagNoColor {\n\t\tcolor.NoColor = true // disables colorized output\n\t}\n\nYou can also disable the color by setting the NO_COLOR environment variable to any value.\n\nIt also has support for single color definitions (local). You can\ndisable/enable color output on the fly:\n\n\tc := color.New(color.FgCyan)\n\tc.Println(\"Prints cyan text\")\n\n\tc.DisableColor()\n\tc.Println(\"This is printed without any color\")\n\n\tc.EnableColor()\n\tc.Println(\"This prints again cyan...\")\n*/\npackage color\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1494140625,
          "content": "module github.com/fatih/color\n\ngo 1.17\n\nrequire (\n\tgithub.com/mattn/go-colorable v0.1.13\n\tgithub.com/mattn/go-isatty v0.0.20\n\tgolang.org/x/sys v0.28.0\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.7626953125,
          "content": "github.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n"
        }
      ]
    }
  ]
}