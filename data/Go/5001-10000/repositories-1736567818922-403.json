{
  "metadata": {
    "timestamp": 1736567818922,
    "page": 403,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "lni/dragonboat",
      "stars": 5108,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".codecov.yml",
          "type": "blob",
          "size": 0.111328125,
          "content": "coverage:\n  precision: 2\n  round: up\n  range: \"70...100\"\n\n  status:\n    project: no\n    patch: no\n    changes: no\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.201171875,
          "content": "/build\n**/checkdisk\n/multiraft-monkey-testing\n*safe_to_delete*\n*safe-to-delete*\nout.txt\ncoverage.out\ncoverage.txt\n*.pprof\n*.swp\n*.tmp\n*.o\n*.a\n*-fuzz.zip\n*.bin\n*.win\ngitversion.go\ndrummer-data\nnodehost-data\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.498046875,
          "content": "Dragonboat was originally created by Lei Ni (nilei81@gmail.com) in 2017. \n\nBelow is a list of authors who contributed on major features and improvements.\n\nJasonYuchen (jasonyuchen@foxmail.com)\nBoyang Chen (bchen11@outlook.com)\n\nBelow is an inevitably incomplete list of other contributors who also helped to\nmake Dragonboat better (alphabetically sorted by names):\n\nBoyang Chen (bchen11@outlook.com)\ndcosmos \ngensmusic (gensmusic@163.com)\nJasonYuchen (jasonyuchen@foxmail.com)\nshijiayun\nstffab (stffabi@pm.me)\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 6.87890625,
          "content": "## v4.0 (TBD)\n\nDragonboat v4.0 is a major release with new features, improvements and API changes.\n\n### New features\n\n- Experimental Raft Pre-Vote support.\n- Experimental LogDB implementation called tan, it is significantly faster than Key-Value store based approach.\n\n### Improvements\n\n- Better error handling.\n- Simplified snapshot compaction.\n- Removed dependency on protobuf.\n- Fixed snapshot notification.\n- Fixed unreachable notification.\n- Upgraded to a more recent version of pebble.\n- Non-voting node (used to be called observer node) support has been marked as production ready.\n- Made the experimental gossip feature a first class citizen of the library.\n\n### Other changes\n\n- Raft observer node has been renamed as non-voting node.\n- RocksDB support has been removed as Pebble provides bidirectional compatible with RocksDB. \n- ClusterID/NodeID has been renamed as ShardID/ReplicaID.\n- Deprecated v3.x features and APIs have been removed. \n\n## v3.3 (2021-01-20)\n\nDragonboat v3.3 is a major release that comes with new features and improvements. All v3.2.x users are recommended to upgrade.\n\n### New features\n\n- Pebble, which is bidirectional compatible with RocksDB, has been made the default engine for storing Raft Logs. RocksDB and CGO are no longer required.\n- Added the ability to slow down incoming proposals when the Raft Logs engine is highly loaded.\n- Added the option to get notified when proposals and config changes are committed.\n- Added an experimental gossip service to allow NodeHosts to use dynamically assigned IP addresses as RaftAddress.\n- Added the ability to better control memory footprint.\n- Added ARM64/Linux as a new targeted platform.\n\nNote that Pebble provides bidirectional compatibility with RocksDB v6.2.1. Existing Dragonboat applications can upgrade to v3.3 without any conversion unless a newer version of RocksDB was used. RocksDB v6.4.x has been briefly tested and it seems to be compatible with Pebble as well. \n\n### Improvements\n\n- Optimized the read index implementation.\n- Reduced LogDB restart delays.\n- Made LogDB configurations accessible programmatically.\n- Added protobuf workaround to allow Dragonboat and etcd to be used in the same project.\n- Fixed a few data race issues.\n- Fixed a potential Raft election deadlock issue when nodes are highly loaded.\n- Allow incoming proposals to be rate limited when LogDB is busy.\n- Simplified many aspects of the library.\n\n### Breaking changes\n\n- The signature of config.LogDBFactoryFunc has been changed. Your application is not affected unless it uses a custom LogDB implementation.\n- Due to lack of user interests, C++ binding is no longer supported.\n- LevelDB based LogDB is no longer supported.\n- NodeHostConfig's FS and SystemTickerPrecision fields have been moved into NodeHostConfig.Expert.\n\n## v3.2 (2020-03-05)\n\nDragonboat v3.2 comes with new features and improvements. All v3.1.x users are recommended to upgrade. \n\n### New features\n\n- Added snappy compression support for Raft entries and snapshots.\n- Added experimental witness support.\n- Added new API to allow LogDB compaction to be manually triggered.\n- Added event listener support to allow users to be notified for certain Raft events.\n- Added system event listener support to allow users to be notified for certain system events.\n- Added Raft related metrics to exported.\n- Added rate limit support to control the maximum bandwidth used for snapshot streaming.\n- Updated the C++ binding to cover all v3.1 features. Thanks JasonYuchen for working on that.\n- Added a virtual filesystem layer to support more filesystem related tests.\n- Added experimental Windows and FreeBSD support.\n\n### Improvements\n\n- Removed the restriction on max proposal payload size.\n- Re-enabled the range delete support in LogDB.\n- Better handling of concurrent snapshot streams.\n- Extensive testing have been done on a high performance native Go KV store called Pebble.\n- TolerateCorruptedTailRecords is now the default WAL recovery mode in the RocksDB based LogDB.\n\n### Breaking changes\n\nThere is no breaking change for regular users. However, \n\n - If you have built customized transport module implementing the raftio.IRaftRPC interface, there is minor change to the config.RaftRPCFactoryFunc type. See github.com/lni/dragoboat/config/config.go for details.\n - The default transport module has been updated, it is no longer compatible with earlier versions of dragonboat. \n - The default LogDB data format is no longer backward compatible with v3.1 or earlier. \n\n### Other changes\n\n - LevelDB support has been marked as depreciated. It will be removed from dragonboat in the next major release. \n\n## v3.1 (2019-07-04)\n\nDragonboat v3.1 is a maintenance release with breaking change. All v3.0.x users are recommended to upgrade. Please make sure to carefully read the CHANGELOG below before upgrading.\n\n### Bug fixes\n\n- Fixed ImportSnapshot. \n\n### New features\n\n- Added NodeHostConfig.RaftEventListener to allow user applications to be notified for certain Raft events.\n\n### Improvements\n\n- Made restarting an existing node faster.\n- Immediately return ErrClusterNotReady when requests are dropped for not having a leader.\n\n### Breaking changes\n\n- When upgrading to v3.1.x from v3.0.x, dragonboat requires all streamed or imported snapshots to have been applied. github.com/lni/dragonboat/tools/upgrade310 is provided to check that. See the godoc in github.com/lni/dragonboat/tools/upgrade310 for more details. For users who use NodeHost.RequestSnapshot to export snapshots for backup purposes, we recommend to re-generate all exported snapshots once upgraded to v3.1.\n\n## v3.0 (2019-06-21)\n\nDragonboat v3.0 is a major release with breaking changes. Please make sure to carefully read the CHANGELOG below before upgrading.\n\n### New features\n\n- Added on disk state machine (statemachine.IOnDiskStateMachine) support. The on disk state machine is close to the concept described in the section 5.2 of Diego Ongaro's Raft thesis. \n- Added new API for requesting a snapshot to be created or exported.\n- Added the ability to use exported snapshot to repair permanently damaged cluster that no longer has majority quorum.\n- Added new API for cleaning up data and release disk spaces after a node is removed from its Raft cluster.\n- Added the ability to limit peak memory usage when disk or network is slow.\n- Added Go module support. Go 1.12 is required.\n\n### Improvements\n\n- Further improved self checking on configurations.\n- Added snapshot binary format version 2 with block base checksum.\n- Synchronous variants have been provided for all asynchronous user request APIs in NodeHost.\n\n### Breaking changes\n\n- The Drummer package has been made invisible from user applications.\n- The statemachine.IStateMachine interface has been upgraded to reflect the fact that not all state machine data is stored in memory ([#46](https://github.com/lni/dragonboat/issues/46)).\n\n## v2.1 (2019-02-20)\n\n### New features\n\n- Added support to store Raft Logs in LevelDB.\n\n## v2.0 (2019-01-04)\n\nInitial open source release. \n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.5068359375,
          "content": "# Contributing to Dragonboat\n\n* Please read the included LICENSE file to understand the licensing and copyright arrangements.\n* It is always good to raise an issue or draft pull request to discuss your proposed changes first.\n* Please prepare some automated tests to cover your changes, Go code should be formatted using gofmt.\n* When reporting a bug, please provide detailed steps on how it can be reproduced, full execution log is also recommended. Reported bugs without enough supporting information will be closed.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.091796875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 6.76171875,
          "content": "# Copyright 2018-2021 Lei Ni (nilei81@gmail.com) and other contributors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nGOEXEC ?= go\n# Dragonboat is known to work on - \n# Linux AMD64, Linux ARM64, MacOS, Windows/MinGW and FreeBSD AMD64\n# only Linux AMD64 is officially supported\nOS := $(shell uname)\n# the location of this Makefile\nPKGROOT=$(shell dirname $(realpath $(lastword $(MAKEFILE_LIST))))\n# name of the package\nPKGNAME=$(shell go list)\n\nifeq ($(DRAGONBOAT_LOGDB),rocksdb)\n$(error rocksdb is no longer supported)\nelse ifeq ($(DRAGONBOAT_LOGDB),)\nifneq ($(MEMFS_TEST),)\n$(info using memfs based pebble)\nLOGDB_TAG=dragonboat_memfs_test\nelse\nifneq ($(MEMFS_TEST_TO_RUN),)\n$(info using memfs based pebble)\nLOGDB_TAG=dragonboat_memfs_test\nelse\n$(info using pebble based log storage)\nendif\nendif\nelse\n$(error LOGDB type $(DRAGONBOAT_LOGDB) not supported)\nendif\n\n# verbosity, use -v to see details of go build\nVERBOSE ?= -v\nifeq ($(VERBOSE),)\nGO=@$(GOEXEC)\nelse\nGO=$(GOEXEC)\nendif\n\nifeq ($(RACE),1)\nRACE_DETECTOR_FLAG=-race\n$(warning \"data race detector enabled\")\nendif\n\nifeq ($(COVER),1)\nCOVER_FLAG=-coverprofile=coverage.out\n$(warning \"coverage enabled, `go tool cover -html=coverage.out` to see results\")\nendif\n\nifneq ($(TEST_TO_RUN),)\n$(info Running selected tests $(TEST_TO_RUN))\nSELECTED_TEST_OPTION=-run $(TEST_TO_RUN)\nendif\n\nifneq ($(MEMFS_TEST_TO_RUN),)\n$(info Running selected tests $(MEMFS_TEST_TO_RUN))\nSELECTED_TEST_OPTION=-run $(MEMFS_TEST_TO_RUN)\nendif\n\nifneq ($(BENCHMARK_TO_RUN),)\n$(info Running selected benchmarks $(BENCHMARK_TO_RUN))\nSELECTED_BENCH_OPTION=-run ^$$ -bench=$(BENCHMARK_TO_RUN)\nelse\nSELECTED_BENCH_OPTION=-run ^$$ -bench=.\nendif\n\n# go build tags\nGOBUILDTAGVALS+=$(LOGDB_TAG)\nGOBUILDTAGS=\"$(GOBUILDTAGVALS)\"\nTESTTAGVALS+=$(GOBUILDTAGVALS)\nTESTTAGS=\"$(TESTTAGVALS)\"\nEXTNAME=linux\n\n.PHONY: all\nall: unit-test-bin\n.PHONY: rebuild-all\nrebuild-all: clean unit-test-bin\n\n###############################################################################\n# tests\n###############################################################################\nifneq ($(TESTTAGS),\"\")\nGOCMDTAGS=-tags=$(TESTTAGS)\nendif\n\nTEST_OPTIONS=test $(GOCMDTAGS) -timeout=2400s -count=1 $(VERBOSE) \\\n  $(RACE_DETECTOR_FLAG) $(COVER_FLAG) $(SELECTED_TEST_OPTION)\n.PHONY: dragonboat-test\ndragonboat-test: test-raft test-raftpb test-rsm test-logdb test-transport    \\\n\ttest-multiraft test-config test-client test-server test-tools test-fs   \t \\\n\ttest-id test-utils test-tan test-registry\n.PHONY: ci-test\nci-test: test-raft test-raftpb test-rsm test-logdb test-transport \t\t       \\\n  test-config test-client test-server test-tests test-tools test-fs \t\t\t\t \\\n\ttest-id test-utils test-tan test-registry\n.PHONY: test\ntest: dragonboat-test test-tests\n.PHONY: dev-test\ndev-test: test\n.PHONY: actions-test\nactions-test: ci-test test-cov\n\n###############################################################################\n# build unit tests\n###############################################################################\n.PHONY: unit-test-bin\nunit-test-bin: TEST_OPTIONS=test -c -o $@.bin -tags=$(TESTTAGS) \t\t\t\t\t\t \\\n\t-count=1 $(VERBOSE) $(RACE_DETECTOR_FLAG) $(SELECTED_TEST_OPTION) \n.PHONY: unit-test-bin\nunit-test-bin: test-raft test-raftpb test-rsm test-logdb test-transport \t\t \\\n  test-multiraft test-config test-client test-server test-tools \\\n\ttest-tests test-fs test-id test-utils test-tan test-registry\n\n###############################################################################\n# fast tests executed for every git push\n###############################################################################\n.PHONY: benchmark\nbenchmark:\n\t$(GOTEST) $(SELECTED_BENCH_OPTION)\n.PHONY: benchmark-tan\nbenchmark-tan:\n\t$(GOTEST) $(SELECTED_BENCH_OPTION) $(PKGNAME)/internal/tan\n.PHONY: benchmark-fsync\nbenchmark-fsync:\n\t$(GOTEST)\t-run ^$$ -bench=BenchmarkFSyncLatency\n\nGOTEST=$(GO) $(TEST_OPTIONS)\n.PHONY: slow-test\nslow-test:\n\tSLOW_TEST=1 $(GOTEST) $(PKGNAME)\n.PHONY: test-server\ntest-server:\n\t$(GOTEST) $(PKGNAME)/internal/server\n.PHONY: test-config\ntest-config:\n\t$(GOTEST) $(PKGNAME)/config\n.PHONY: test-client\ntest-client:\n\t$(GOTEST) $(PKGNAME)/client\n.PHONY: test-raft\ntest-raft:\n\t$(GOTEST) $(PKGNAME)/internal/raft\n.PHONY: test-raftpb\ntest-raftpb:\n\t$(GOTEST) $(PKGNAME)/raftpb\n.PHONY: test-rsm\ntest-rsm:\n\t$(GOTEST) $(PKGNAME)/internal/rsm\n.PHONY: test-logdb\ntest-logdb:\n\t$(GOTEST) $(PKGNAME)/internal/logdb\n.PHONY: test-transport\ntest-transport:\n\t$(GOTEST) $(PKGNAME)/internal/transport\n.PHONY: test-multiraft\ntest-multiraft:\n\t$(GOTEST) $(PKGNAME)\n.PHONY: test-tests\ntest-tests:\n\t$(GOTEST) $(PKGNAME)/internal/tests\n.PHONY: test-fs\ntest-fs:\n\t$(GOTEST) $(PKGNAME)/internal/fileutil\n.PHONY: test-tools\ntest-tools:\n\t$(GOTEST) $(PKGNAME)/tools\n.PHONY: test-id\ntest-id:\n\t$(GOTEST) $(PKGNAME)/internal/id\n.PHONY: test-utils\ntest-utils:\n\t$(GOTEST) $(PKGNAME)/internal/utils/dio\n.PHONY: test-tan\ntest-tan:\n\t$(GOTEST) $(PKGNAME)/internal/tan\n.PHONY: test-registry\ntest-registry:\n\t$(GOTEST) $(PKGNAME)/internal/registry\n.PHONY: test-cov\ntest-cov:\n\t$(GOTEST) -coverprofile=coverage.txt -covermode=atomic\n\n###############################################################################\n# tools\n###############################################################################\n.PHONY: tools\ntools: tools-checkdisk\n\n.PHONY: tools-checkdisk\ntools-checkdisk:\n\t$(GO) build $(PKGNAME)/tools/checkdisk\n\n###############################################################################\n# static checks\n###############################################################################\n.PHONY: install-static-check-tools\ninstall-static-check-tools:\n\t@go install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.53.2\n\nCHECKED_PKGS=$(shell go list ./...)\nCHECKED_DIRS=$(subst $(PKGNAME), ,$(subst $(PKGNAME)/, ,$(CHECKED_PKGS))) .\nEXTRA_LINTERS=-E misspell -E rowserrcheck -E unconvert \\\n\t-E prealloc -E stylecheck\n.PHONY: static-check\nstatic-check:\n\t@for p in $(CHECKED_DIRS); do \\\n\t\tgolangci-lint run $(EXTRA_LINTERS) $$p; \\\n\tdone;\n\nextra-static-check: override EXTRA_LINTERS :=-E dupl\nextra-static-check: static-check\n\n###############################################################################\n# clean\n###############################################################################\n.PHONY: clean\nclean:\n\t@find . -type d -name \"*safe_to_delete\" -print | xargs rm -rf\n\t@rm -f gitversion.go \n\t@rm -f test-*.*\n\t@rm -f checkdisk\n\t@$(GO) clean -i -testcache $(PKG)\n"
        },
        {
          "name": "NOTICE",
          "type": "blob",
          "size": 0.1708984375,
          "content": "Dragonboat Project (https://github.com/lni/dragonboat)\nCopyright 2017-2019 Lei Ni (nilei81@gmail.com)\n\nThis product includes software developed by Lei Ni (nilei81@gmail.com).\n"
        },
        {
          "name": "README.CHS.md",
          "type": "blob",
          "size": 7.009765625,
          "content": "![dragonboat](./docs/dragonboat.jpg)\n# Dragonboat - Go多组Raft库 #\n[![license](http://img.shields.io/badge/license-Apache2-blue.svg)](https://github.com/lni/dragonboat/blob/master/LICENSE)\n![Build status](https://github.com/lni/dragonboat/workflows/Test/badge.svg?branch=master)\n[![Go Report Card](https://goreportcard.com/badge/github.com/lni/dragonboat)](https://goreportcard.com/report/github.com/lni/dragonboat)\n[![codecov](https://codecov.io/gh/lni/dragonboat/branch/master/graph/badge.svg)](https://codecov.io/gh/lni/dragonboat)\n[![Godoc](http://img.shields.io/badge/go-documentation-blue.svg)](https://godoc.org/github.com/lni/dragonboat)\n[![Join the chat at https://gitter.im/lni/dragonboat](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/lni/dragonboat?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n## 项目新闻 ##\n* 2022-06-03 Dragonboat v4.0 版本正在开发中，master分支已经是v4的API，具体变化请见[CHANGELOG](CHANGELOG.md)。\n* 2021-01-20 Dragonboat v3.3 已发布，请查看[CHANGELOG](CHANGELOG.md)获知所有更新情况。\n\n## 关于 ##\nDragonboat是一个高性能纯[Go](https://golang.org)语言实现的多组[Raft](https://raft.github.io/) [共识算法](https://en.wikipedia.org/wiki/Consensus_(computer_science))库。\n\nRaft这样的共识算法使得只要系统中的多数成员在线便可使得系统持续运行。比如，一个拥有5台服务器的Raft集群中即使有两台服务器故障依旧可以工作。它同时向客户端展现一个单机节点，始终提供强一致保证的数据访存。同时，所有在线的成员节点都可用来提供读操作，从而提供更高的读吞吐总和。\n\n所有Raft相关的技术难点都会由Dragonboat来承担，用户从而可以只关注他们各自的应用领域。Dragonboats[使用十分简便](docs/overview.CHS.md)，详细的[例程](https://github.com/lni/dragonboat-example)可使新用户在半小时内完全掌握它。\n\n## 功能 ##\n* 便于使用的可构建单组与多组Raft应用的纯Go语言API\n* 功能完备的多组Raft协议的实现，同机支持数千Raft组\n* 完备的测试确保[正确性](/docs/test.md)，这包括[Jepsen](https://aphyr.com/tags/jepsen)所带的[Knossos](https://github.com/jepsen-io/knossos)强一致性检查，部分测试日志[在此](https://github.com/lni/knossos-data)\n* 全流水线设计、TLS支持，适合被部署于跨地域的高网络延时公网环境\n* 在中档硬件上即可获得约300万/秒的写或1000万/秒的强一致读的性能\n* 支持定制的Raft log存储与通讯模块，可方便整合最新IO类技术产品\n* 基于Prometheus的健康度metrics支持\n* 内建的用于修复已永久丢失多数派节点的Raft组的工具\n* 多Raft组由自带的[Drummer](/drummer)服务器组件管理以获得良好的高可用\n\nDiego Ongaro的[Raft博士学位论文](https://github.com/ongardie/dissertation/blob/master/stanford.pdf)中提及的所有功能都已实现：\n* 选主、log复制、状态机快照与log清理\n* Raft组成员变更\n* Pre-Vote扩展\n* 基于ReadIndex协议的只读查询\n* 主节点转移\n* 无投票权成员\n* Witness成员\n* 应用透明的幂等更新支持\n* 成组处理优化与流水化处理\n* 基于磁盘的状态机\n\n## 性能 ##\nDragonboat是目前Github网站上最快的开源多组Raft实现。\n\n在三节点系统上，使用中端硬件（具体信息[在此](/docs/test.md)）与基于内存的状态机，在16字节的荷载下，当使用RocksDB做为存储引擎，Dragonboat可持续每秒900万次写或在9:1的高读写比场景下提供每秒1100万次的混合读写操作。高吞吐在跨地域分布环境依旧被保持，在使用更多的clients的情况下，在RTT为30ms时依旧能实现200万次每秒的IO操作。\n![throughput](./docs/throughput.png)\n\n每个服务器上可轻易承载数千Raft组。并发的活跃Raft组数量对吞吐有直接影响，而大量的闲置Raft组对系统性能并无巨大影响。\n![nodes](./docs/nodes.png)\n\n下表是毫秒为单位的写延迟数据。Dragonboat可以在处理每秒800万次写（16字节荷载）的时候做到P99的写延迟小于5ms。读延迟低于写延迟，因为用于linearizable读的ReadIndex协议无需对每个读请求做落盘写。\n\n|每秒请求数|荷载大小|99.9% percentile|99% percentile|平均|\n|:-:|:----------:|:--:|:-:|:-:|\n|100万|16|2.24|1.19|0.79|\n|100万|128|11.11|1.37|0.92|\n|100万|1024|71.61|25.91|3.75|\n|500万|16|4.64|1.95|1.16|\n|500万|128|36.61|6.55|1.96|\n|800万|16|12.01|4.65|2.13|\n\n当测试单组性能时，Dragonboat可以在16字节负载下持续每秒完成125万次写，此时平均写延迟是1.3毫秒，P99写延迟为2.6毫秒。上述性能是在平均单机占用三个2.8Ghz的核心的情况下实现的。\n\n即使在很高的系统负载下，Go 1.11的GC所带来的Stop-the-World停顿也显著低于1毫秒。在Go 1.12版中，GC的Stop-the-World停顿时间又进一步大幅减低。Golang的runtime.ReadMemStats显示即使在很高的系统负载下，GC也仅占用了少于1%的可利用CPU时间。\n![stw](./docs/stw.png)\n\n## 系统需求 ##\n* x86_64/Linux, x86_64/MacOS或ARM64/Linux, Go 1.15或1.14\n\n## 开始使用 ##\n__Master是用于开发的非稳定branch。生产环境请使用已发布版本__。如您使用v3.3.x版本，请参考v3.3.x版本的[README.CHS.md](https://github.com/lni/dragonboat/blob/release-3.3/README.CHS.md)。\n\n首先请确保Go 1.14或者更新的版本已被安装以获得[Go module](https://github.com/golang/go/wiki/Modules)支持。\n\n使用下列命令将Dragonboat v3稳定版加入您的项目：\n\n```\ngo get github.com/lni/dragonboat/v3@latest\n```\n或者使用下列命令将开发中的Dragonboat v4版加入您的项目：\n```\ngo get github.com/lni/dragonboat/v4@master\n```\n\n[Pebble](https://github.com/cockroachdb/pebble)是默认的用于存储Raft Log的存储引擎。RocksDB与自定义存储引擎的使用方法可参考[这里](docs/storage.CHS.md)。\n\n同时可参考[例程](https://github.com/lni/dragonboat-example)以了解更多Dragonboat使用信息。\n\n## 文档与资料 ##\n\n首先建议您阅读项目的[综述文档](docs/overview.CHS.md)与[运维注意事项](docs/devops.CHS.md)。\n\n欢迎阅读[godoc文档](https://godoc.org/github.com/lni/dragonboat)，[中文例程](https://github.com/lni/dragonboat-example)，[常见问题](https://github.com/lni/dragonboat/wiki/FAQ)，[CHANGELOG](CHANGELOG.md)和在线[讨论组](https://gitter.im/lni/dragonboat)。\n\n## 中文例程 ##\n中文例程在[这里](https://github.com/lni/dragonboat-example)。\n\n## 项目状态 ##\nDragonboat适用于生产环境。\n\n## 参与 ##\n报告bugs, 请提交一个[issue](https://github.com/lni/dragonboat/issues/new)。参与贡献改进及新功能, 请提交pull request并创建一个[issue](https://github.com/lni/dragonboat/issues/new)以便讨论与进度追踪。\n\n## 开源许可协议 ##\n本项目以Apache License Version 2.0授权开源，请参考LICENSE文件。\n\n本项目所使用的第三方代码与它们的开源许可证信息的列表[在此](docs/COPYRIGHT)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.9912109375,
          "content": "![dragonboat](./docs/dragonboat.jpg)\n# Dragonboat - A Multi-Group Raft library in Go / [中文版](README.CHS.md) ##\n[![license](http://img.shields.io/badge/license-Apache2-blue.svg)](https://github.com/lni/dragonboat/blob/master/LICENSE)\n![Build status](https://github.com/lni/dragonboat/workflows/Test/badge.svg?branch=master)\n[![Go Report Card](https://goreportcard.com/badge/github.com/lni/dragonboat)](https://goreportcard.com/report/github.com/lni/dragonboat)\n[![codecov](https://codecov.io/gh/lni/dragonboat/branch/master/graph/badge.svg)](https://codecov.io/gh/lni/dragonboat)\n[![Godoc](http://img.shields.io/badge/go-documentation-blue.svg)](https://godoc.org/github.com/lni/dragonboat/v3)\n[![Join the chat at https://gitter.im/lni/dragonboat](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/lni/dragonboat?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n## News ##\n* 2022-06-03 We are working towards a v4.0 release which will come with API changes. See [CHANGELOG](CHANGELOG.md) for details. \n* 2021-01-20 Dragonboat v3.3 has been released, please check [CHANGELOG](CHANGELOG.md) for all changes.\n\n## About ##\nDragonboat is a high performance multi-group [Raft](https://raft.github.io/) [consensus](https://en.wikipedia.org/wiki/Consensus_(computer_science)) library in pure [Go](https://golang.org/).\n\nConsensus algorithms such as Raft provides fault-tolerance by alllowing a system continue to operate as long as the majority member servers are available. For example, a Raft shard of 5 servers can make progress even if 2 servers fail. It also appears to clients as a single entity with strong data consistency always provided. All Raft replicas can be used to handle read requests for aggregated read throughput.\n\nDragonboat handles all technical difficulties associated with Raft to allow users to just focus on their application domains. It is also very easy to use, our step-by-step [examples](https://github.com/lni/dragonboat-example) can help new users to master it in half an hour.\n\n## Features ##\n* Easy to use pure-Go APIs for building Raft based applications\n* Feature complete and scalable multi-group Raft implementation\n* Disk based and memory based state machine support\n* Fully pipelined and TLS mutual authentication support, ready for high latency open environment\n* Custom Raft log storage and transport support, easy to integrate with latest I/O techs\n* Prometheus based health metrics support\n* Built-in tool to repair Raft shards that permanently lost the quorum\n* [Extensively tested](/docs/test.md) including using [Jepsen](https://aphyr.com/tags/jepsen)'s [Knossos](https://github.com/jepsen-io/knossos) linearizability checker, some results are [here](https://github.com/lni/knossos-data)\n\nAll major features covered in Diego Ongaro's [Raft thesis](https://github.com/ongardie/dissertation/blob/master/stanford.pdf) have been supported -\n* leader election, log replication, snapshotting and log compaction\n* membership change\n* pre-vote\n* ReadIndex protocol for read-only queries\n* leadership transfer\n* non-voting member\n* witness member\n* idempotent update transparent to applications\n* batching and pipelining\n* disk based state machine\n\n## Performance ##\nDragonboat is the __fastest__ open source multi-group Raft implementation on Github. \n\nFor 3-nodes system using mid-range hardware (details [here](docs/test.md)) and in-memory state machine, when RocksDB is used as the storage engine, Dragonboat can sustain at 9 million writes per second when the payload is 16bytes each or 11 million mixed I/O per second at 9:1 read:write ratio. High throughput is maintained in geographically distributed environment. When the RTT between nodes is 30ms, 2 million I/O per second can still be achieved using a much larger number of clients.\n![throughput](./docs/throughput.png)\n\nThe number of concurrent active Raft groups affects the overall throughput as requests become harder to be batched. On the other hand, having thousands of idle Raft groups has a much smaller impact on throughput.\n![nodes](./docs/nodes.png)\n\nTable below shows write latencies in millisecond, Dragonboat has <5ms P99 write latency when handling 8 million writes per second at 16 bytes each. Read latency is lower than writes as the ReadIndex protocol employed for linearizable reads doesn't require fsync-ed disk I/O.\n\n|Ops|Payload Size|99.9% percentile|99% percentile|AVG|\n|:-:|:----------:|:--:|:-:|:-:|\n|1m|16|2.24|1.19|0.79|\n|1m|128|11.11|1.37|0.92|\n|1m|1024|71.61|25.91|3.75|\n|5m|16|4.64|1.95|1.16|\n|5m|128|36.61|6.55|1.96|\n|8m|16|12.01|4.65|2.13|\n\nWhen tested on a single Raft group, Dragonboat can sustain writes at 1.25 million per second when payload is 16 bytes each, average latency is 1.3ms and the P99 latency is 2.6ms. This is achieved when using an average of 3 cores (2.8GHz) on each server.\n\nAs visualized below, Stop-the-World pauses caused by Go1.11's GC are sub-millisecond on highly loaded systems. Such very short Stop-the-World pause time is further significantly reduced in Go 1.12. Golang's runtime.ReadMemStats reports that less than 1% of the available CPU time is used by GC on highly loaded system.\n![stw](./docs/stw.png)\n\n## Requirements ##\n* x86_64/Linux, x86_64/MacOS or ARM64/Linux, Go 1.15 or 1.14\n\n## Getting Started ##\n__Master is our unstable branch for development, it is current working towards the v4.0 release. Please use the latest released versions for any production purposes.__ For Dragonboat v3.3.x, please follow the instructions in v3.3.x's [README.md](https://github.com/lni/dragonboat/blob/release-3.3/README.md). \n\nGo 1.17 or above with [Go module](https://github.com/golang/go/wiki/Modules) support is required.\n\nUse the following command to add Dragonboat v3 into your project. \n\n```\ngo get github.com/lni/dragonboat/v3@latest\n```\n\nOr you can use the following command to start using the development version of the Dragonboat, which is current at v4 for its APIs. \n\n```\ngo get github.com/lni/dragonboat/v4@master\n```\n\n\nBy default, [Pebble](https://github.com/cockroachdb/pebble) is used for storing Raft Logs in Dragonboat. RocksDB and other storage engines are also supported, more info [here](docs/storage.md).\n\nYou can also follow our [examples](https://github.com/lni/dragonboat-example) on how to use Dragonboat. \n\n## Documents ##\n[FAQ](https://github.com/lni/dragonboat/wiki/FAQ), [docs](https://godoc.org/github.com/lni/dragonboat), step-by-step [examples](https://github.com/lni/dragonboat-example), [DevOps doc](docs/devops.md), [CHANGELOG](CHANGELOG.md) and [online chat](https://gitter.im/lni/dragonboat) are available.\n\n## Examples ##\nDragonboat examples are [here](https://github.com/lni/dragonboat-example).\n\n## Status ##\nDragonboat is production ready.\n\n## Contributing ##\nFor reporting bugs, please open an [issue](https://github.com/lni/dragonboat/issues/new). For contributing improvements or new features, please send in the pull request.\n\n## License ##\nDragonboat is licensed under the Apache License Version 2.0. See LICENSE for details.\n\nThird party code used in Dragonboat and their licenses is summarized [here](docs/COPYRIGHT).\n"
        },
        {
          "name": "benchmark_test.go",
          "type": "blob",
          "size": 16.396484375,
          "content": "// Copyright 2017-2021 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dragonboat\n\nimport (\n\t\"math/rand\"\n\t\"os\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\n\t\"github.com/golang/snappy\"\n\t\"github.com/lni/goutils/random\"\n\n\t\"github.com/lni/dragonboat/v4/client\"\n\t\"github.com/lni/dragonboat/v4/config\"\n\t\"github.com/lni/dragonboat/v4/internal/logdb\"\n\t\"github.com/lni/dragonboat/v4/internal/registry\"\n\t\"github.com/lni/dragonboat/v4/internal/rsm\"\n\t\"github.com/lni/dragonboat/v4/internal/server\"\n\t\"github.com/lni/dragonboat/v4/internal/settings\"\n\t\"github.com/lni/dragonboat/v4/internal/tests\"\n\t\"github.com/lni/dragonboat/v4/internal/transport\"\n\t\"github.com/lni/dragonboat/v4/internal/utils/dio\"\n\t\"github.com/lni/dragonboat/v4/internal/vfs\"\n\t\"github.com/lni/dragonboat/v4/logger\"\n\tpb \"github.com/lni/dragonboat/v4/raftpb\"\n\tsm \"github.com/lni/dragonboat/v4/statemachine\"\n)\n\nfunc benchmarkAllocs(b *testing.B, sz uint64) {\n\tb.ReportAllocs()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tm := make([]byte, sz)\n\t\t\tb.SetBytes(int64(sz))\n\t\t\tif uint64(len(m)) < sz {\n\t\t\t\tb.Errorf(\"len(m) < %d\", sz)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkAllocs16Bytes(b *testing.B) {\n\tbenchmarkAllocs(b, 16)\n}\n\nfunc BenchmarkAllocs512Bytes(b *testing.B) {\n\tbenchmarkAllocs(b, 512)\n}\n\nfunc BenchmarkAllocs4096Bytes(b *testing.B) {\n\tbenchmarkAllocs(b, 4096)\n}\n\nfunc benchmarkEncodedPayload(b *testing.B, ct dio.CompressionType, sz uint64) {\n\tb.ReportAllocs()\n\tb.SetBytes(int64(sz))\n\tinput := make([]byte, sz)\n\trand.Read(input)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\trsm.GetEncoded(ct, input, nil)\n\t}\n}\n\nfunc BenchmarkSnappyEncodedPayload16Bytes(b *testing.B) {\n\tbenchmarkEncodedPayload(b, dio.Snappy, 16)\n}\n\nfunc BenchmarkSnappyEncodedPayload512Bytes(b *testing.B) {\n\tbenchmarkEncodedPayload(b, dio.Snappy, 512)\n}\n\nfunc BenchmarkSnappyEncodedPayload4096Bytes(b *testing.B) {\n\tbenchmarkEncodedPayload(b, dio.Snappy, 4096)\n}\n\nfunc BenchmarkNoCompressionEncodedPayload16Bytes(b *testing.B) {\n\tbenchmarkEncodedPayload(b, dio.NoCompression, 16)\n}\n\nfunc BenchmarkNoCompressionEncodedPayload512Bytes(b *testing.B) {\n\tbenchmarkEncodedPayload(b, dio.NoCompression, 512)\n}\n\nfunc BenchmarkNoCompressionEncodedPayload4096Bytes(b *testing.B) {\n\tbenchmarkEncodedPayload(b, dio.NoCompression, 4096)\n}\n\nfunc BenchmarkAddToEntryQueue(b *testing.B) {\n\tb.ReportAllocs()\n\tq := newEntryQueue(1000000, 0)\n\ttotal := uint32(0)\n\tentry := pb.Entry{}\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tt := atomic.AddUint32(&total, 1)\n\t\t\tif t%2048 == 0 {\n\t\t\t\tatomic.StoreUint32(&total, 0)\n\t\t\t\tq.get(false)\n\t\t\t} else {\n\t\t\t\tq.add(entry)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc benchmarkProposeN(b *testing.B, sz int) {\n\tb.ReportAllocs()\n\tdata := make([]byte, sz)\n\tp := &sync.Pool{}\n\tp.New = func() interface{} {\n\t\tobj := &RequestState{}\n\t\tobj.CompletedC = make(chan RequestResult, 1)\n\t\tobj.pool = p\n\t\treturn obj\n\t}\n\ttotal := uint32(0)\n\tq := newEntryQueue(2048, 0)\n\tcfg := config.Config{ShardID: 1, ReplicaID: 1}\n\tpp := newPendingProposal(cfg, false, p, q)\n\tsession := client.NewNoOPSession(1, random.LockGuardedRand)\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tv := atomic.AddUint32(&total, 1)\n\t\t\tb.SetBytes(int64(sz))\n\t\t\trs, err := pp.propose(session, data, 100)\n\t\t\tif err != nil {\n\t\t\t\tb.Errorf(\"%v\", err)\n\t\t\t}\n\t\t\tif v%128 == 0 {\n\t\t\t\tatomic.StoreUint32(&total, 0)\n\t\t\t\tq.get(false)\n\t\t\t}\n\t\t\tpp.applied(rs.key, rs.clientID, rs.seriesID, sm.Result{Value: 1}, false)\n\t\t\trs.readyToRelease.set()\n\t\t\trs.Release()\n\t\t}\n\t})\n}\n\nfunc BenchmarkPropose16(b *testing.B) {\n\tbenchmarkProposeN(b, 16)\n}\n\nfunc BenchmarkPropose128(b *testing.B) {\n\tbenchmarkProposeN(b, 128)\n}\n\nfunc BenchmarkPropose1024(b *testing.B) {\n\tbenchmarkProposeN(b, 1024)\n}\n\nfunc BenchmarkPendingProposalNextKey(b *testing.B) {\n\tb.ReportAllocs()\n\tp := &sync.Pool{}\n\tp.New = func() interface{} {\n\t\tobj := &RequestState{}\n\t\tobj.CompletedC = make(chan RequestResult, 1)\n\t\tobj.pool = p\n\t\treturn obj\n\t}\n\tq := newEntryQueue(2048, 0)\n\tcfg := config.Config{ShardID: 1, ReplicaID: 1}\n\tpp := newPendingProposal(cfg, false, p, q)\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tclientID := rand.Uint64()\n\t\tfor pb.Next() {\n\t\t\tpp.nextKey(clientID)\n\t\t}\n\t})\n}\n\nfunc BenchmarkReadIndexRead(b *testing.B) {\n\tb.ReportAllocs()\n\tp := &sync.Pool{}\n\tp.New = func() interface{} {\n\t\tobj := &RequestState{}\n\t\tobj.CompletedC = make(chan RequestResult, 1)\n\t\tobj.pool = p\n\t\treturn obj\n\t}\n\ttotal := uint32(0)\n\tq := newReadIndexQueue(2048)\n\tpri := newPendingReadIndex(p, q)\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tv := atomic.AddUint32(&total, 1)\n\t\t\trs, err := pri.read(100)\n\t\t\tif err != nil {\n\t\t\t\tb.Errorf(\"%v\", err)\n\t\t\t}\n\t\t\tif v%128 == 0 {\n\t\t\t\tatomic.StoreUint32(&total, 0)\n\t\t\t\tq.get()\n\t\t\t}\n\t\t\trs.readyToRelease.set()\n\t\t\trs.Release()\n\t\t}\n\t})\n}\n\nfunc benchmarkMarshalEntryN(b *testing.B, sz int) {\n\tb.ReportAllocs()\n\te := pb.Entry{\n\t\tIndex:       12843560,\n\t\tTerm:        123,\n\t\tType:        pb.ApplicationEntry,\n\t\tKey:         13563799145,\n\t\tClientID:    234926831800,\n\t\tSeriesID:    12843560,\n\t\tRespondedTo: 12843550,\n\t\tCmd:         make([]byte, sz),\n\t}\n\tdata := make([]byte, e.Size())\n\tfor i := 0; i < b.N; i++ {\n\t\tn, err := e.MarshalTo(data)\n\t\tif n > len(data) {\n\t\t\tb.Errorf(\"n > len(data)\")\n\t\t}\n\t\tb.SetBytes(int64(n))\n\t\tif err != nil {\n\t\t\tb.Errorf(\"%v\", err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkMarshalEntry16(b *testing.B) {\n\tbenchmarkMarshalEntryN(b, 16)\n}\n\nfunc BenchmarkMarshalEntry128(b *testing.B) {\n\tbenchmarkMarshalEntryN(b, 128)\n}\n\nfunc BenchmarkMarshalEntry1024(b *testing.B) {\n\tbenchmarkMarshalEntryN(b, 1024)\n}\n\nfunc BenchmarkWorkerReady(b *testing.B) {\n\tb.ReportAllocs()\n\trc := newWorkReady(1)\n\tb.RunParallel(func(pbt *testing.PB) {\n\t\tfor pbt.Next() {\n\t\t\trc.shardReady(1)\n\t\t}\n\t})\n}\n\nfunc BenchmarkReadyShard(b *testing.B) {\n\tb.ReportAllocs()\n\trc := newReadyShard()\n\tb.RunParallel(func(pbt *testing.PB) {\n\t\tfor pbt.Next() {\n\t\t\trc.setShardReady(1)\n\t\t}\n\t})\n}\n\nfunc BenchmarkFSyncLatency(b *testing.B) {\n\tb.StopTimer()\n\tl := logger.GetLogger(\"logdb\")\n\tl.SetLevel(logger.WARNING)\n\tdb := getNewTestDB(\"db\", \"lldb\", vfs.DefaultFS)\n\tdefer os.RemoveAll(rdbTestDirectory)\n\tdefer db.Close()\n\te := pb.Entry{\n\t\tIndex:       12843560,\n\t\tTerm:        123,\n\t\tType:        pb.ApplicationEntry,\n\t\tKey:         13563799145,\n\t\tClientID:    234926831800,\n\t\tSeriesID:    12843560,\n\t\tRespondedTo: 12843550,\n\t\tCmd:         make([]byte, 8*1024),\n\t}\n\tu := pb.Update{\n\t\tShardID:       1,\n\t\tReplicaID:     1,\n\t\tEntriesToSave: []pb.Entry{e},\n\t}\n\tb.StartTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tif err := db.SaveRaftState([]pb.Update{u}, 1); err != nil {\n\t\t\tb.Fatalf(\"%v\", err)\n\t\t}\n\t}\n}\n\nfunc benchmarkSaveRaftState(b *testing.B, sz int) {\n\tb.ReportAllocs()\n\tb.StopTimer()\n\tl := logger.GetLogger(\"logdb\")\n\tl.SetLevel(logger.WARNING)\n\tdb := getNewTestDB(\"db\", \"lldb\", vfs.DefaultFS)\n\tdefer os.RemoveAll(rdbTestDirectory)\n\tdefer db.Close()\n\tshardID := uint32(1)\n\tb.StartTimer()\n\tb.RunParallel(func(pbt *testing.PB) {\n\t\tldb, ok := db.(*logdb.ShardedDB)\n\t\tif !ok {\n\t\t\tb.Fatalf(\"not a logdb.ShardedDB instance\")\n\t\t}\n\t\trdbctx := ldb.GetLogDBThreadContext()\n\t\te := pb.Entry{\n\t\t\tIndex:       12843560,\n\t\t\tTerm:        123,\n\t\t\tType:        pb.ApplicationEntry,\n\t\t\tKey:         13563799145,\n\t\t\tClientID:    234926831800,\n\t\t\tSeriesID:    12843560,\n\t\t\tRespondedTo: 12843550,\n\t\t\tCmd:         make([]byte, sz),\n\t\t}\n\t\tcid := uint64(atomic.AddUint32(&shardID, 1))\n\t\tbytes := e.Size() * 128\n\t\tu := pb.Update{\n\t\t\tShardID:   cid,\n\t\t\tReplicaID: 1,\n\t\t}\n\t\tiidx := e.Index\n\t\tfor i := uint64(0); i < 128; i++ {\n\t\t\te.Index = iidx + i\n\t\t\tu.EntriesToSave = append(u.EntriesToSave, e)\n\t\t}\n\t\tfor pbt.Next() {\n\t\t\trdbctx.Reset()\n\t\t\tif err := ldb.SaveRaftStateCtx([]pb.Update{u}, rdbctx); err != nil {\n\t\t\t\tb.Errorf(\"%v\", err)\n\t\t\t}\n\t\t\tb.SetBytes(int64(bytes))\n\t\t}\n\t})\n}\n\nfunc BenchmarkSaveRaftState16(b *testing.B) {\n\tbenchmarkSaveRaftState(b, 16)\n}\n\nfunc BenchmarkSaveRaftState128(b *testing.B) {\n\tbenchmarkSaveRaftState(b, 128)\n}\n\nfunc BenchmarkSaveRaftState1024(b *testing.B) {\n\tbenchmarkSaveRaftState(b, 1024)\n}\n\ntype benchmarkMessageHandler struct {\n\texpected uint64\n\tcount    uint64\n\tch       chan struct{}\n}\n\nfunc (h *benchmarkMessageHandler) wait() {\n\t<-h.ch\n}\n\nfunc (h *benchmarkMessageHandler) reset() {\n\tatomic.StoreUint64(&h.count, 0)\n}\n\nfunc (h *benchmarkMessageHandler) HandleMessageBatch(batch pb.MessageBatch) (uint64, uint64) {\n\tv := atomic.AddUint64(&h.count, uint64(len(batch.Requests)))\n\tif v >= h.expected {\n\t\th.ch <- struct{}{}\n\t}\n\treturn 0, 0\n}\n\nfunc (h *benchmarkMessageHandler) HandleUnreachable(shardID uint64, replicaID uint64) {\n}\n\nfunc (h *benchmarkMessageHandler) HandleSnapshotStatus(shardID uint64,\n\treplicaID uint64, rejected bool) {\n}\n\nfunc (h *benchmarkMessageHandler) HandleSnapshot(shardID uint64,\n\treplicaID uint64, from uint64) {\n}\n\ntype dummyTransportEvent struct{}\n\nfunc (d *dummyTransportEvent) ConnectionEstablished(addr string, snapshot bool) {}\nfunc (d *dummyTransportEvent) ConnectionFailed(addr string, snapshot bool)      {}\n\nfunc benchmarkTransport(b *testing.B, sz int) {\n\tb.ReportAllocs()\n\tb.StopTimer()\n\tl := logger.GetLogger(\"transport\")\n\tl.SetLevel(logger.ERROR)\n\tl = logger.GetLogger(\"grpc\")\n\tl.SetLevel(logger.ERROR)\n\taddr1 := \"localhost:43567\"\n\taddr2 := \"localhost:43568\"\n\tnhc1 := config.NodeHostConfig{\n\t\tRaftAddress: addr1,\n\t\tExpert: config.ExpertConfig{\n\t\t\tFS: vfs.DefaultFS,\n\t\t},\n\t}\n\tenv1, err := server.NewEnv(nhc1, vfs.DefaultFS)\n\tif err != nil {\n\t\tb.Fatalf(\"failed to new context %v\", err)\n\t}\n\tnhc2 := config.NodeHostConfig{\n\t\tRaftAddress: addr2,\n\t\tExpert: config.ExpertConfig{\n\t\t\tFS: vfs.DefaultFS,\n\t\t},\n\t}\n\tenv2, err := server.NewEnv(nhc2, vfs.DefaultFS)\n\tif err != nil {\n\t\tb.Fatalf(\"failed to new context %v\", err)\n\t}\n\tnodes1 := registry.NewNodeRegistry(settings.Soft.StreamConnections, nil)\n\tnodes2 := registry.NewNodeRegistry(settings.Soft.StreamConnections, nil)\n\tnodes1.Add(1, 2, addr2)\n\thandler1 := &benchmarkMessageHandler{\n\t\tch:       make(chan struct{}, 1),\n\t\texpected: 128,\n\t}\n\thandler2 := &benchmarkMessageHandler{\n\t\tch:       make(chan struct{}, 1),\n\t\texpected: 128,\n\t}\n\tt1, err := transport.NewTransport(nhc1,\n\t\thandler1, env1, nodes1, nil, &dummyTransportEvent{}, vfs.DefaultFS)\n\tif err != nil {\n\t\tb.Fatalf(\"failed to create transport %v\", err)\n\t}\n\tt2, err := transport.NewTransport(nhc2,\n\t\thandler2, env2, nodes2, nil, &dummyTransportEvent{}, vfs.DefaultFS)\n\tif err != nil {\n\t\tb.Fatalf(\"failed to create transport %v\", err)\n\t}\n\tdefer func() {\n\t\tif err := t2.Close(); err != nil {\n\t\t\tb.Fatalf(\"failed to stop the transport module %v\", err)\n\t\t}\n\t}()\n\tdefer func() {\n\t\tif err := t1.Close(); err != nil {\n\t\t\tb.Fatalf(\"failed to stop the transport module %v\", err)\n\t\t}\n\t}()\n\tmsgs := make([]pb.Message, 0)\n\te := pb.Entry{\n\t\tIndex:       12843560,\n\t\tTerm:        123,\n\t\tType:        pb.ApplicationEntry,\n\t\tKey:         13563799145,\n\t\tClientID:    234926831800,\n\t\tSeriesID:    12843560,\n\t\tRespondedTo: 12843550,\n\t\tCmd:         make([]byte, sz),\n\t}\n\tfor i := 0; i < 128; i++ {\n\t\tm := pb.Message{\n\t\t\tType:     pb.Replicate,\n\t\t\tTo:       2,\n\t\t\tFrom:     1,\n\t\t\tShardID:  1,\n\t\t\tTerm:     100,\n\t\t\tLogTerm:  100,\n\t\t\tLogIndex: 123456789,\n\t\t\tCommit:   123456789,\n\t\t}\n\t\tfor j := 0; j < 64; j++ {\n\t\t\tm.Entries = append(m.Entries, e)\n\t\t}\n\t\tmsgs = append(msgs, m)\n\t}\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\thandler1.reset()\n\t\tfor _, msg := range msgs {\n\t\t\tt1.Send(msg)\n\t\t}\n\t\thandler1.wait()\n\t}\n}\n\nfunc BenchmarkTransport16(b *testing.B) {\n\tbenchmarkTransport(b, 16)\n}\n\nfunc BenchmarkTransport128(b *testing.B) {\n\tbenchmarkTransport(b, 128)\n}\n\nfunc BenchmarkTransport1024(b *testing.B) {\n\tbenchmarkTransport(b, 1024)\n}\n\nfunc BenchmarkLookup(b *testing.B) {\n\tb.ReportAllocs()\n\tb.StopTimer()\n\tds := &tests.NoOP{}\n\tdone := make(chan struct{})\n\tconfig := config.Config{ShardID: 1, ReplicaID: 1}\n\tnds := rsm.NewNativeSM(config, rsm.NewInMemStateMachine(ds), done)\n\tinput := make([]byte, 1)\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tresult, err := nds.Lookup(input)\n\t\tif err != nil {\n\t\t\tb.Fatalf(\"lookup failed %v\", err)\n\t\t}\n\t\tif result == nil || len(result.([]byte)) != 1 {\n\t\t\tb.Fatalf(\"unexpected result\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkNALookup(b *testing.B) {\n\tb.ReportAllocs()\n\tb.StopTimer()\n\tds := &tests.NoOP{}\n\tdone := make(chan struct{})\n\tconfig := config.Config{ShardID: 1, ReplicaID: 1}\n\tnds := rsm.NewNativeSM(config, rsm.NewInMemStateMachine(ds), done)\n\tinput := make([]byte, 1)\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tresult, err := nds.NALookup(input)\n\t\tif err != nil {\n\t\t\tb.Fatalf(\"lookup failed %v\", err)\n\t\t}\n\t\tif len(result) != 1 {\n\t\t\tb.Fatalf(\"unexpected result\")\n\t\t}\n\t}\n}\n\nfunc benchmarkStateMachineStep(b *testing.B, sz int, noopSession bool) {\n\tb.ReportAllocs()\n\tb.StopTimer()\n\tds := &tests.NoOP{NoAlloc: true}\n\tdone := make(chan struct{})\n\tconfig := config.Config{ShardID: 1, ReplicaID: 1}\n\tnds := rsm.NewNativeSM(config, rsm.NewInMemStateMachine(ds), done)\n\tsmo := rsm.NewStateMachine(nds, nil, config, &testDummyNodeProxy{}, vfs.DefaultFS)\n\tidx := uint64(0)\n\tvar s *client.Session\n\tif noopSession {\n\t\ts = client.NewNoOPSession(1, random.LockGuardedRand)\n\t} else {\n\t\ts = &client.Session{\n\t\t\tShardID:  1,\n\t\t\tClientID: 1234576,\n\t\t}\n\t}\n\te := pb.Entry{\n\t\tTerm:        123,\n\t\tType:        pb.ApplicationEntry,\n\t\tKey:         13563799145,\n\t\tClientID:    s.ClientID,\n\t\tSeriesID:    s.SeriesID,\n\t\tRespondedTo: s.RespondedTo,\n\t\tCmd:         make([]byte, sz),\n\t}\n\tentries := make([]pb.Entry, 0)\n\tbatch := make([]rsm.Task, 0, 100000)\n\tsmEntries := make([]sm.Entry, 0)\n\ttask := rsm.Task{Recover: false}\n\tif !noopSession {\n\t\tidx++\n\t\te.Index = idx\n\t\te.SeriesID = client.SeriesIDForRegister\n\t\tentries = append(entries, e)\n\t\ttask.Entries = entries\n\t\tsmo.TaskQ().Add(task)\n\t\tif _, err := smo.Handle(batch, smEntries); err != nil {\n\t\t\tb.Fatalf(\"handle failed %v\", err)\n\t\t}\n\t}\n\tb.StartTimer()\n\tfor x := 0; x < b.N; x++ {\n\t\tentries = entries[:0]\n\t\tfor i := uint64(0); i < 128; i++ {\n\t\t\tidx++\n\t\t\te.Index = idx\n\t\t\tentries = append(entries, e)\n\t\t}\n\t\ttask.Entries = entries\n\t\tsmo.TaskQ().Add(task)\n\t\tif _, err := smo.Handle(batch, smEntries); err != nil {\n\t\t\tb.Fatalf(\"handle failed %v\", err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkStateMachineStepNoOPSession16(b *testing.B) {\n\tbenchmarkStateMachineStep(b, 16, true)\n}\n\nfunc BenchmarkStateMachineStepNoOPSession128(b *testing.B) {\n\tbenchmarkStateMachineStep(b, 128, true)\n}\n\nfunc BenchmarkStateMachineStepNoOPSession1024(b *testing.B) {\n\tbenchmarkStateMachineStep(b, 1024, true)\n}\n\nfunc BenchmarkStateMachineStep16(b *testing.B) {\n\tbenchmarkStateMachineStep(b, 16, false)\n}\n\nfunc BenchmarkStateMachineStep128(b *testing.B) {\n\tbenchmarkStateMachineStep(b, 128, false)\n}\n\nfunc BenchmarkStateMachineStep1024(b *testing.B) {\n\tbenchmarkStateMachineStep(b, 1024, false)\n}\n\ntype noopSink struct{}\n\nfunc (n *noopSink) Receive(pb.Chunk) (bool, bool) { return true, false }\nfunc (n *noopSink) Close() error                  { return nil }\nfunc (n *noopSink) ShardID() uint64               { return 1 }\nfunc (n *noopSink) ToReplicaID() uint64           { return 1 }\n\nfunc BenchmarkChunkWriter(b *testing.B) {\n\tsink := &noopSink{}\n\tmeta := rsm.SSMeta{}\n\tcw := rsm.NewChunkWriter(sink, meta)\n\tsz := int64(1024 * 256)\n\tdata := make([]byte, sz)\n\trand.Read(data)\n\tb.ReportAllocs()\n\tb.SetBytes(sz)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif _, err := cw.Write(data); err != nil {\n\t\t\tb.Fatalf(\"failed to write %v\", err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkSnappyCompressedChunkWriter(b *testing.B) {\n\tsink := &noopSink{}\n\tmeta := rsm.SSMeta{}\n\tcw := rsm.NewChunkWriter(sink, meta)\n\tw := snappy.NewBufferedWriter(cw)\n\tsz := int64(1024 * 256)\n\tdata := make([]byte, sz)\n\trand.Read(data)\n\tb.ReportAllocs()\n\tb.SetBytes(sz)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif _, err := w.Write(data); err != nil {\n\t\t\tb.Fatalf(\"failed to write %v\", err)\n\t\t}\n\t}\n}\n\ntype marshaler interface {\n\tMarshal() ([]byte, error)\n}\n\nfunc mustMarshal(m marshaler) []byte {\n\tresult, err := m.Marshal()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn result\n}\n\nfunc marshalData(e pb.Entry) {\n\t_, err := e.Marshal()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc mustMarshalData(e pb.Entry) {\n\tmustMarshal(&e)\n}\n\nfunc BenchmarkMarshal(b *testing.B) {\n\tb.ReportAllocs()\n\te := pb.Entry{}\n\tfor i := 0; i < b.N; i++ {\n\t\tmarshalData(e)\n\t}\n}\n\nfunc BenchmarkMustMarshal(b *testing.B) {\n\tb.ReportAllocs()\n\te := pb.Entry{}\n\tfor i := 0; i < b.N; i++ {\n\t\tmustMarshalData(e)\n\t}\n}\n"
        },
        {
          "name": "client",
          "type": "tree",
          "content": null
        },
        {
          "name": "config",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "engine.go",
          "type": "blob",
          "size": 34.2724609375,
          "content": "// Copyright 2017-2021 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dragonboat\n\nimport (\n\t\"reflect\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/lni/goutils/syncutil\"\n\n\t\"github.com/lni/dragonboat/v4/config\"\n\t\"github.com/lni/dragonboat/v4/internal/rsm\"\n\t\"github.com/lni/dragonboat/v4/internal/server\"\n\t\"github.com/lni/dragonboat/v4/internal/settings\"\n\t\"github.com/lni/dragonboat/v4/raftio\"\n\tpb \"github.com/lni/dragonboat/v4/raftpb\"\n\tsm \"github.com/lni/dragonboat/v4/statemachine\"\n)\n\nvar (\n\treloadTime           = settings.Soft.NodeReloadMillisecond\n\ttimedCloseWaitSecond = settings.Soft.CloseWorkerTimedWaitSecond\n\ttimedCloseWait       = time.Second * time.Duration(timedCloseWaitSecond)\n\tnodeReloadInterval   = time.Millisecond * time.Duration(reloadTime)\n\ttaskBatchSize        = settings.Soft.TaskBatchSize\n)\n\ntype bitmap struct {\n\tv uint64\n}\n\nfunc (b *bitmap) contains(v uint64) bool {\n\tif v >= 64 {\n\t\tpanic(\"invalid v\")\n\t}\n\treturn b.v&(1<<v) > 0\n}\n\nfunc (b *bitmap) add(v uint64) {\n\tif v >= 64 {\n\t\tpanic(\"invalid v\")\n\t}\n\tb.v = b.v | (1 << v)\n}\n\ntype from uint64\n\nconst (\n\tfromStepWorker from = iota\n\tfromCommitWorker\n\tfromApplyWorker\n\tfromWorkerPool\n\tfromWorker\n)\n\ntype nodeLoader interface {\n\tdescribe() string\n\tgetShardSetIndex() uint64\n\tforEachShard(f func(uint64, *node) bool) uint64\n}\n\ntype nodeType struct {\n\tworkerID uint64\n\tfrom     from\n}\n\ntype loadedNodes struct {\n\tnodes map[nodeType]map[uint64]*node\n\tmu    sync.Mutex\n}\n\nfunc newLoadedNodes() *loadedNodes {\n\treturn &loadedNodes{\n\t\tnodes: make(map[nodeType]map[uint64]*node),\n\t}\n}\n\nfunc (l *loadedNodes) get(shardID uint64, replicaID uint64) *node {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tfor _, m := range l.nodes {\n\t\tif n, ok := m[shardID]; ok && n.replicaID == replicaID {\n\t\t\treturn n\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (l *loadedNodes) update(workerID uint64,\n\tfrom from, nodes map[uint64]*node) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tnt := nodeType{workerID: workerID, from: from}\n\tl.nodes[nt] = nodes\n}\n\n// nodes is a map of workerID -> *node\nfunc (l *loadedNodes) updateFromBusySSNodes(nodes map[uint64]*node) {\n\tl.updateFromLoadedSSNodes(fromWorker, nodes)\n}\n\n// nodes is a map of shardID -> *node\nfunc (l *loadedNodes) updateFromLoadedSSNodes(from from,\n\tnodes map[uint64]*node) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tnt := nodeType{workerID: 0, from: from}\n\tnm := make(map[uint64]*node, len(nodes))\n\tfor _, n := range nodes {\n\t\tnm[n.shardID] = n\n\t}\n\tl.nodes[nt] = nm\n}\n\ntype workReady struct {\n\tpartitioner server.IPartitioner\n\tmaps        []*readyShard\n\tchannels    []chan struct{}\n\tcount       uint64\n}\n\nfunc newWorkReady(count uint64) *workReady {\n\twr := &workReady{\n\t\tpartitioner: server.NewFixedPartitioner(count),\n\t\tcount:       count,\n\t\tmaps:        make([]*readyShard, count),\n\t\tchannels:    make([]chan struct{}, count),\n\t}\n\tfor i := uint64(0); i < count; i++ {\n\t\twr.channels[i] = make(chan struct{}, 1)\n\t\twr.maps[i] = newReadyShard()\n\t}\n\treturn wr\n}\n\nfunc (wr *workReady) getPartitioner() server.IPartitioner {\n\treturn wr.partitioner\n}\n\nfunc (wr *workReady) notify(idx uint64) {\n\tselect {\n\tcase wr.channels[idx] <- struct{}{}:\n\tdefault:\n\t}\n}\n\nfunc (wr *workReady) shardReadyByUpdates(updates []pb.Update) {\n\tvar notified bitmap\n\tfor _, ud := range updates {\n\t\tif len(ud.CommittedEntries) > 0 {\n\t\t\tidx := wr.partitioner.GetPartitionID(ud.ShardID)\n\t\t\treadyMap := wr.maps[idx]\n\t\t\treadyMap.setShardReady(ud.ShardID)\n\t\t}\n\t}\n\tfor _, ud := range updates {\n\t\tif len(ud.CommittedEntries) > 0 {\n\t\t\tidx := wr.partitioner.GetPartitionID(ud.ShardID)\n\t\t\tif !notified.contains(idx) {\n\t\t\t\tnotified.add(idx)\n\t\t\t\twr.notify(idx)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (wr *workReady) shardReadyByMessageBatch(mb pb.MessageBatch) {\n\tvar notified bitmap\n\tfor _, req := range mb.Requests {\n\t\tidx := wr.partitioner.GetPartitionID(req.ShardID)\n\t\treadyMap := wr.maps[idx]\n\t\treadyMap.setShardReady(req.ShardID)\n\t}\n\tfor _, req := range mb.Requests {\n\t\tidx := wr.partitioner.GetPartitionID(req.ShardID)\n\t\tif !notified.contains(idx) {\n\t\t\tnotified.add(idx)\n\t\t\twr.notify(idx)\n\t\t}\n\t}\n}\n\nfunc (wr *workReady) allShardsReady(nodes []*node) {\n\tvar notified bitmap\n\tfor _, n := range nodes {\n\t\tidx := wr.partitioner.GetPartitionID(n.shardID)\n\t\treadyMap := wr.maps[idx]\n\t\treadyMap.setShardReady(n.shardID)\n\t}\n\tfor _, n := range nodes {\n\t\tidx := wr.partitioner.GetPartitionID(n.shardID)\n\t\tif !notified.contains(idx) {\n\t\t\tnotified.add(idx)\n\t\t\twr.notify(idx)\n\t\t}\n\t}\n}\n\nfunc (wr *workReady) shardReady(shardID uint64) {\n\tidx := wr.partitioner.GetPartitionID(shardID)\n\treadyMap := wr.maps[idx]\n\treadyMap.setShardReady(shardID)\n\twr.notify(idx)\n}\n\nfunc (wr *workReady) waitCh(workerID uint64) chan struct{} {\n\treturn wr.channels[workerID-1]\n}\n\nfunc (wr *workReady) getReadyMap(workerID uint64) map[uint64]struct{} {\n\treadyMap := wr.maps[workerID-1]\n\treturn readyMap.getReadyShards()\n}\n\ntype job struct {\n\tnode       *node\n\tsink       getSink\n\ttask       rsm.Task\n\tinstanceID uint64\n\tshardID    uint64\n}\n\ntype ssWorker struct {\n\tstopper    *syncutil.Stopper\n\trequestC   chan job\n\tcompletedC chan struct{}\n\tworkerID   uint64\n}\n\nfunc newSSWorker(workerID uint64, stopper *syncutil.Stopper) *ssWorker {\n\tw := &ssWorker{\n\t\tworkerID:   workerID,\n\t\tstopper:    stopper,\n\t\trequestC:   make(chan job, 1),\n\t\tcompletedC: make(chan struct{}, 1),\n\t}\n\tstopper.RunWorker(func() {\n\t\tw.workerMain()\n\t})\n\treturn w\n}\n\nfunc (w *ssWorker) workerMain() {\n\tfor {\n\t\tselect {\n\t\tcase <-w.stopper.ShouldStop():\n\t\t\treturn\n\t\tcase job := <-w.requestC:\n\t\t\tif job.node == nil {\n\t\t\t\tpanic(\"req.node == nil\")\n\t\t\t}\n\t\t\tif err := w.handle(job); err != nil {\n\t\t\t\tpanicNow(err)\n\t\t\t}\n\t\t\tw.completed()\n\t\t}\n\t}\n}\n\nfunc (w *ssWorker) completed() {\n\tw.completedC <- struct{}{}\n}\n\nfunc (w *ssWorker) handle(j job) error {\n\tif j.task.Recover {\n\t\treturn w.recover(j)\n\t} else if j.task.Save {\n\t\treturn w.save(j)\n\t} else if j.task.Stream {\n\t\treturn w.stream(j)\n\t}\n\tpanic(\"unknown snapshot task type\")\n}\n\nfunc (w *ssWorker) recover(j job) error {\n\tvar err error\n\tvar index uint64\n\tif index, err = j.node.recover(j.task); err != nil {\n\t\treturn err\n\t}\n\tj.node.recoverDone(index)\n\treturn nil\n}\n\nfunc (w *ssWorker) save(j job) error {\n\tif err := j.node.save(j.task); err != nil {\n\t\treturn err\n\t}\n\tj.node.saveDone()\n\treturn nil\n}\n\nfunc (w *ssWorker) stream(j job) error {\n\tif err := j.node.stream(j.sink()); err != nil {\n\t\treturn err\n\t}\n\tj.node.streamDone()\n\treturn nil\n}\n\ntype workerPool struct {\n\tnh            nodeLoader\n\tsaving        map[uint64]struct{}\n\tcciReady      *workReady\n\tsaveReady     *workReady\n\trecoverReady  *workReady\n\tstreamReady   *workReady\n\tworkerStopper *syncutil.Stopper\n\tbusy          map[uint64]*node\n\tloaded        *loadedNodes\n\trecovering    map[uint64]struct{}\n\tstreaming     map[uint64]uint64\n\tnodes         map[uint64]*node\n\tpoolStopper   *syncutil.Stopper\n\tpending       []job\n\tworkers       []*ssWorker\n\tcci           uint64\n}\n\nfunc newWorkerPool(nh nodeLoader,\n\tsnapshotWorkerCount uint64, loaded *loadedNodes) *workerPool {\n\tw := &workerPool{\n\t\tnh:            nh,\n\t\tloaded:        loaded,\n\t\tcciReady:      newWorkReady(1),\n\t\tsaveReady:     newWorkReady(1),\n\t\trecoverReady:  newWorkReady(1),\n\t\tstreamReady:   newWorkReady(1),\n\t\tnodes:         make(map[uint64]*node),\n\t\tworkers:       make([]*ssWorker, snapshotWorkerCount),\n\t\tbusy:          make(map[uint64]*node, snapshotWorkerCount),\n\t\tsaving:        make(map[uint64]struct{}, snapshotWorkerCount),\n\t\trecovering:    make(map[uint64]struct{}, snapshotWorkerCount),\n\t\tstreaming:     make(map[uint64]uint64, snapshotWorkerCount),\n\t\tpending:       make([]job, 0),\n\t\tworkerStopper: syncutil.NewStopper(),\n\t\tpoolStopper:   syncutil.NewStopper(),\n\t}\n\tfor workerID := uint64(0); workerID < snapshotWorkerCount; workerID++ {\n\t\tw.workers[workerID] = newSSWorker(workerID, w.workerStopper)\n\t}\n\tw.poolStopper.RunWorker(func() {\n\t\tw.workerPoolMain()\n\t})\n\treturn w\n}\n\nfunc (p *workerPool) close() error {\n\tp.poolStopper.Stop()\n\treturn nil\n}\n\nfunc (p *workerPool) getWorker() *ssWorker {\n\tfor _, w := range p.workers {\n\t\tif _, busy := p.busy[w.workerID]; !busy {\n\t\t\treturn w\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *workerPool) workerPoolMain() {\n\tticker := time.NewTicker(200 * time.Millisecond)\n\tdefer ticker.Stop()\n\tcases := make([]reflect.SelectCase, len(p.workers)+6)\n\tfor {\n\t\ttoSchedule := false\n\t\t// 0 - pool stopper stopc\n\t\t// 1 - p.saveReady.waitCh(1)\n\t\t// 2 - p.recoverReady.waitCh(1)\n\t\t// 3 - p.streamReady.waitCh(1)\n\t\t// 4 - p.cciReady.waitCh(1)\n\t\t// 5 - worker completedC\n\t\t// 5 + len(workers) - ticker.C\n\t\tcases[0] = reflect.SelectCase{\n\t\t\tDir:  reflect.SelectRecv,\n\t\t\tChan: reflect.ValueOf(p.poolStopper.ShouldStop()),\n\t\t}\n\t\tcases[1] = reflect.SelectCase{\n\t\t\tDir:  reflect.SelectRecv,\n\t\t\tChan: reflect.ValueOf(p.saveReady.waitCh(1)),\n\t\t}\n\t\tcases[2] = reflect.SelectCase{\n\t\t\tDir:  reflect.SelectRecv,\n\t\t\tChan: reflect.ValueOf(p.recoverReady.waitCh(1)),\n\t\t}\n\t\tcases[3] = reflect.SelectCase{\n\t\t\tDir:  reflect.SelectRecv,\n\t\t\tChan: reflect.ValueOf(p.streamReady.waitCh(1)),\n\t\t}\n\t\tcases[4] = reflect.SelectCase{\n\t\t\tDir:  reflect.SelectRecv,\n\t\t\tChan: reflect.ValueOf(p.cciReady.waitCh(1)),\n\t\t}\n\t\tfor idx, w := range p.workers {\n\t\t\tcases[5+idx] = reflect.SelectCase{\n\t\t\t\tDir:  reflect.SelectRecv,\n\t\t\t\tChan: reflect.ValueOf(w.completedC),\n\t\t\t}\n\t\t}\n\t\tcases[5+len(p.workers)] = reflect.SelectCase{\n\t\t\tDir:  reflect.SelectRecv,\n\t\t\tChan: reflect.ValueOf(ticker.C),\n\t\t}\n\t\tchosen, _, _ := reflect.Select(cases)\n\t\tif chosen == 0 {\n\t\t\tp.workerStopper.Stop()\n\t\t\tp.unloadNodes()\n\t\t\treturn\n\t\t} else if chosen == 1 {\n\t\t\tshards := p.saveReady.getReadyMap(1)\n\t\t\tp.loadNodes()\n\t\t\tfor cid := range shards {\n\t\t\t\tif j, ok := p.getSaveJob(cid); ok {\n\t\t\t\t\tplog.Debugf(\"%s saveRequested for %d\", p.nh.describe(), cid)\n\t\t\t\t\tp.pending = append(p.pending, j)\n\t\t\t\t\ttoSchedule = true\n\t\t\t\t}\n\t\t\t}\n\t\t} else if chosen == 2 {\n\t\t\tshards := p.recoverReady.getReadyMap(1)\n\t\t\tp.loadNodes()\n\t\t\tfor cid := range shards {\n\t\t\t\tif j, ok := p.getRecoverJob(cid); ok {\n\t\t\t\t\tplog.Debugf(\"%s recoverRequested for %d\", p.nh.describe(), cid)\n\t\t\t\t\tp.pending = append(p.pending, j)\n\t\t\t\t\ttoSchedule = true\n\t\t\t\t}\n\t\t\t}\n\t\t} else if chosen == 3 {\n\t\t\tshards := p.streamReady.getReadyMap(1)\n\t\t\tp.loadNodes()\n\t\t\tfor cid := range shards {\n\t\t\t\tif j, ok := p.getStreamJob(cid); ok {\n\t\t\t\t\tplog.Debugf(\"%s streamRequested for %d\", p.nh.describe(), cid)\n\t\t\t\t\tp.pending = append(p.pending, j)\n\t\t\t\t\ttoSchedule = true\n\t\t\t\t}\n\t\t\t}\n\t\t} else if chosen == 4 {\n\t\t\tp.loadNodes()\n\t\t} else if chosen >= 5 && chosen <= 5+len(p.workers)-1 {\n\t\t\tworkerID := uint64(chosen - 5)\n\t\t\tp.completed(workerID)\n\t\t\ttoSchedule = true\n\t\t} else if chosen == len(cases)-1 {\n\t\t\tp.loadNodes()\n\t\t} else {\n\t\t\tplog.Panicf(\"chosen %d, unexpected case\", chosen)\n\t\t}\n\t\tif toSchedule {\n\t\t\tp.loadNodes()\n\t\t\tp.schedule()\n\t\t}\n\t}\n}\n\nfunc (p *workerPool) unloadNodes() {\n\tfor _, n := range p.nodes {\n\t\tn.offloaded()\n\t}\n\tfor _, n := range p.busy {\n\t\tn.offloaded()\n\t}\n}\n\nfunc (p *workerPool) updateLoadedBusyNodes() {\n\tp.loaded.updateFromBusySSNodes(p.busy)\n}\n\nfunc (p *workerPool) loadNodes() {\n\tif p.nh.getShardSetIndex() != p.cci {\n\t\tnewNodes := make(map[uint64]*node)\n\t\tloaded := make([]*node, 0)\n\t\tp.cci = p.nh.forEachShard(func(cid uint64, n *node) bool {\n\t\t\tif on, ok := p.nodes[cid]; ok {\n\t\t\t\tif on.instanceID != n.instanceID {\n\t\t\t\t\tplog.Panicf(\"%s from two incarnations found\", n.id())\n\t\t\t\t}\n\t\t\t\tnewNodes[cid] = on\n\t\t\t} else {\n\t\t\t\tloaded = append(loaded, n)\n\t\t\t\tnewNodes[cid] = n\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\t\tp.loaded.updateFromLoadedSSNodes(fromWorkerPool, newNodes)\n\t\tfor cid, n := range p.nodes {\n\t\t\tif _, ok := newNodes[cid]; !ok {\n\t\t\t\tn.offloaded()\n\t\t\t}\n\t\t}\n\t\tfor _, n := range loaded {\n\t\t\tn.loaded()\n\t\t}\n\t\tp.nodes = newNodes\n\t}\n}\n\nfunc (p *workerPool) completed(workerID uint64) {\n\tcount := 0\n\tn, ok := p.busy[workerID]\n\tif !ok {\n\t\tplog.Panicf(\"worker %d is not busy\", workerID)\n\t}\n\tif _, ok := p.saving[n.shardID]; ok {\n\t\tplog.Debugf(\"%s completed saveRequested\", n.id())\n\t\tdelete(p.saving, n.shardID)\n\t\tcount++\n\t}\n\tif _, ok := p.recovering[n.shardID]; ok {\n\t\tplog.Debugf(\"%s completed recoverRequested\", n.id())\n\t\tdelete(p.recovering, n.shardID)\n\t\tcount++\n\t}\n\tif sc, ok := p.streaming[n.shardID]; ok {\n\t\tplog.Debugf(\"%s completed streamRequested\", n.id())\n\t\tif sc == 0 {\n\t\t\tplog.Panicf(\"node completed streaming when not streaming\")\n\t\t} else if sc == 1 {\n\t\t\tdelete(p.streaming, n.shardID)\n\t\t} else {\n\t\t\tp.streaming[n.shardID] = sc - 1\n\t\t}\n\t\tcount++\n\t}\n\tif count == 0 {\n\t\tplog.Panicf(\"not sure what got completed\")\n\t}\n\tif count > 1 {\n\t\tplog.Panicf(\"completed more than one type of snapshot op\")\n\t}\n\tp.setIdle(workerID)\n}\n\nfunc (p *workerPool) inProgress(shardID uint64) bool {\n\t_, ok1 := p.saving[shardID]\n\t_, ok2 := p.recovering[shardID]\n\t_, ok3 := p.streaming[shardID]\n\treturn ok1 || ok2 || ok3\n}\n\nfunc (p *workerPool) canStream(shardID uint64) bool {\n\tif _, ok := p.saving[shardID]; ok {\n\t\treturn false\n\t}\n\t_, ok := p.recovering[shardID]\n\treturn !ok\n}\n\nfunc (p *workerPool) canSave(shardID uint64) bool {\n\treturn !p.inProgress(shardID)\n}\n\nfunc (p *workerPool) canRecover(shardID uint64) bool {\n\treturn !p.inProgress(shardID)\n}\n\nfunc (p *workerPool) canSchedule(j job) bool {\n\tif j.task.Recover {\n\t\treturn p.canRecover(j.shardID)\n\t} else if j.task.Save {\n\t\treturn p.canSave(j.shardID)\n\t} else if j.task.Stream {\n\t\treturn p.canStream(j.shardID)\n\t} else {\n\t\tplog.Panicf(\"unknown task type %+v\", j.task)\n\t}\n\tpanic(\"not suppose to reach here\")\n}\n\nfunc (p *workerPool) setIdle(workerID uint64) {\n\tn, ok := p.busy[workerID]\n\tif !ok {\n\t\tplog.Panicf(\"worker %d is not busy\", workerID)\n\t}\n\tdelete(p.busy, workerID)\n\tp.updateLoadedBusyNodes()\n\tn.offloaded()\n}\n\nfunc (p *workerPool) setBusy(n *node, workerID uint64) {\n\tif _, ok := p.busy[workerID]; ok {\n\t\tplog.Panicf(\"trying to use a busy worker\")\n\t}\n\tn.loaded()\n\tp.busy[workerID] = n\n\tp.updateLoadedBusyNodes()\n}\n\nfunc (p *workerPool) startStreaming(n *node) {\n\tif count, ok := p.streaming[n.shardID]; !ok {\n\t\tp.streaming[n.shardID] = 1\n\t} else {\n\t\tp.streaming[n.shardID] = count + 1\n\t}\n}\n\nfunc (p *workerPool) startSaving(n *node) {\n\tif _, ok := p.saving[n.shardID]; ok {\n\t\tplog.Panicf(\"%s trying to start saving again\", n.id())\n\t}\n\tp.saving[n.shardID] = struct{}{}\n}\n\nfunc (p *workerPool) startRecovering(n *node) {\n\tif _, ok := p.recovering[n.shardID]; ok {\n\t\tplog.Panicf(\"%s trying to start recovering again\", n.id())\n\t}\n\tp.recovering[n.shardID] = struct{}{}\n}\n\nfunc (p *workerPool) start(j job, n *node, workerID uint64) {\n\tp.setBusy(n, workerID)\n\tif j.task.Recover {\n\t\tp.startRecovering(n)\n\t} else if j.task.Save {\n\t\tp.startSaving(n)\n\t} else if j.task.Stream {\n\t\tp.startStreaming(n)\n\t} else {\n\t\tplog.Panicf(\"unknown task type %+v\", j.task)\n\t}\n}\n\nfunc (p *workerPool) schedule() {\n\tfor {\n\t\tif !p.scheduleWorker() {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (p *workerPool) scheduleWorker() bool {\n\tif len(p.pending) == 0 {\n\t\treturn false\n\t}\n\tw := p.getWorker()\n\tif w == nil {\n\t\tplog.Debugf(\"%s no more worker\", p.nh.describe())\n\t\treturn false\n\t}\n\tfor idx, j := range p.pending {\n\t\tn, ok := p.nodes[j.shardID]\n\t\tif !ok {\n\t\t\tp.removeFromPending(idx)\n\t\t\treturn true\n\t\t}\n\t\tif p.canSchedule(j) {\n\t\t\tp.scheduleTask(j, n, w)\n\t\t\tp.removeFromPending(idx)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (p *workerPool) removeFromPending(idx int) {\n\tsz := len(p.pending)\n\tcopy(p.pending[idx:], p.pending[idx+1:])\n\tp.pending = p.pending[:sz-1]\n}\n\nfunc (p *workerPool) getSaveJob(shardID uint64) (job, bool) {\n\tn, ok := p.nodes[shardID]\n\tif !ok {\n\t\treturn job{}, false\n\t}\n\treq, ok := n.ss.getSaveReq()\n\tif !ok {\n\t\treturn job{}, false\n\t}\n\treturn job{\n\t\ttask:       req,\n\t\tnode:       n,\n\t\tinstanceID: n.instanceID,\n\t\tshardID:    shardID,\n\t}, true\n}\n\nfunc (p *workerPool) getRecoverJob(shardID uint64) (job, bool) {\n\tn, ok := p.nodes[shardID]\n\tif !ok {\n\t\treturn job{}, false\n\t}\n\treq, ok := n.ss.getRecoverReq()\n\tif !ok {\n\t\treturn job{}, false\n\t}\n\treturn job{\n\t\ttask:       req,\n\t\tnode:       n,\n\t\tinstanceID: n.instanceID,\n\t\tshardID:    shardID,\n\t}, true\n}\n\nfunc (p *workerPool) getStreamJob(shardID uint64) (job, bool) {\n\tn, ok := p.nodes[shardID]\n\tif !ok {\n\t\treturn job{}, false\n\t}\n\treq, sinkFn, ok := n.ss.getStreamReq()\n\tif !ok {\n\t\treturn job{}, false\n\t}\n\treturn job{\n\t\ttask:       req,\n\t\tnode:       n,\n\t\tsink:       sinkFn,\n\t\tinstanceID: n.instanceID,\n\t\tshardID:    shardID,\n\t}, true\n}\n\nfunc (p *workerPool) scheduleTask(j job, n *node, w *ssWorker) {\n\tif n.instanceID == j.instanceID {\n\t\tp.start(j, n, w.workerID)\n\t\tselect {\n\t\tcase w.requestC <- j:\n\t\tdefault:\n\t\t\tpanic(\"worker received multiple jobs\")\n\t\t}\n\t}\n}\n\ntype closeReq struct {\n\tnode *node\n}\n\ntype closeWorker struct {\n\tstopper    *syncutil.Stopper\n\trequestC   chan closeReq\n\tcompletedC chan struct{}\n\tworkerID   uint64\n}\n\nfunc newCloseWorker(workerID uint64, stopper *syncutil.Stopper) *closeWorker {\n\tw := &closeWorker{\n\t\tworkerID:   workerID,\n\t\tstopper:    stopper,\n\t\trequestC:   make(chan closeReq, 1),\n\t\tcompletedC: make(chan struct{}, 1),\n\t}\n\tstopper.RunWorker(func() {\n\t\tw.workerMain()\n\t})\n\treturn w\n}\n\nfunc (w *closeWorker) workerMain() {\n\tfor {\n\t\tselect {\n\t\tcase <-w.stopper.ShouldStop():\n\t\t\treturn\n\t\tcase req := <-w.requestC:\n\t\t\tif err := w.handle(req); err != nil {\n\t\t\t\tpanicNow(err)\n\t\t\t}\n\t\t\tw.completed()\n\t\t}\n\t}\n}\n\nfunc (w *closeWorker) completed() {\n\tw.completedC <- struct{}{}\n}\n\nfunc (w *closeWorker) handle(req closeReq) error {\n\tif req.node.destroyed() {\n\t\treturn nil\n\t}\n\treturn req.node.destroy()\n}\n\ntype closeWorkerPool struct {\n\tready         chan closeReq\n\tbusy          map[uint64]uint64\n\tprocessing    map[uint64]struct{}\n\tworkerStopper *syncutil.Stopper\n\tpoolStopper   *syncutil.Stopper\n\tworkers       []*closeWorker\n\tpending       []*node\n}\n\nfunc newCloseWorkerPool(closeWorkerCount uint64) *closeWorkerPool {\n\tw := &closeWorkerPool{\n\t\tworkers:       make([]*closeWorker, closeWorkerCount),\n\t\tready:         make(chan closeReq, 1),\n\t\tbusy:          make(map[uint64]uint64, closeWorkerCount),\n\t\tprocessing:    make(map[uint64]struct{}, closeWorkerCount),\n\t\tpending:       make([]*node, 0),\n\t\tworkerStopper: syncutil.NewStopper(),\n\t\tpoolStopper:   syncutil.NewStopper(),\n\t}\n\n\tfor workerID := uint64(0); workerID < closeWorkerCount; workerID++ {\n\t\tw.workers[workerID] = newCloseWorker(workerID, w.workerStopper)\n\t}\n\tw.poolStopper.RunWorker(func() {\n\t\tw.workerPoolMain()\n\t})\n\treturn w\n}\n\nfunc (p *closeWorkerPool) close() error {\n\tp.poolStopper.Stop()\n\treturn nil\n}\n\nfunc (p *closeWorkerPool) workerPoolMain() {\n\tcases := make([]reflect.SelectCase, len(p.workers)+2)\n\tfor {\n\t\t// 0 - pool stopper stopc\n\t\t// 1 - node ready for destroy\n\t\tcases[0] = reflect.SelectCase{\n\t\t\tDir:  reflect.SelectRecv,\n\t\t\tChan: reflect.ValueOf(p.poolStopper.ShouldStop()),\n\t\t}\n\t\tcases[1] = reflect.SelectCase{\n\t\t\tDir:  reflect.SelectRecv,\n\t\t\tChan: reflect.ValueOf(p.ready),\n\t\t}\n\t\tfor idx, w := range p.workers {\n\t\t\tcases[2+idx] = reflect.SelectCase{\n\t\t\t\tDir:  reflect.SelectRecv,\n\t\t\t\tChan: reflect.ValueOf(w.completedC),\n\t\t\t}\n\t\t}\n\t\tchosen, v, _ := reflect.Select(cases)\n\t\tif chosen == 0 {\n\t\t\tp.timedWait()\n\t\t\treturn\n\t\t} else if chosen == 1 {\n\t\t\tnode := v.Interface().(closeReq).node\n\t\t\tp.pending = append(p.pending, node)\n\t\t} else if chosen > 1 && chosen < len(p.workers)+2 {\n\t\t\tworkerID := uint64(chosen - 2)\n\t\t\tp.completed(workerID)\n\t\t} else {\n\t\t\tplog.Panicf(\"chosen %d, unknown case\", chosen)\n\t\t}\n\t\tp.schedule()\n\t}\n}\n\nfunc (p *closeWorkerPool) timedWait() {\n\ttimer := time.NewTimer(timedCloseWait)\n\ttimeout := false\n\tdefer timer.Stop()\n\tdefer p.workerStopper.Stop()\n\tdefer func() {\n\t\tif timeout {\n\t\t\tplog.Infof(\"timedWait ready to exit, busy %d, pending %d\",\n\t\t\t\tlen(p.busy), len(p.pending))\n\t\t}\n\t}()\n\t// p.ready is buffered, don't ignore that buffered close req\n\tselect {\n\tcase v := <-p.ready:\n\t\tp.pending = append(p.pending, v.node)\n\tdefault:\n\t}\n\tp.schedule()\n\tcases := make([]reflect.SelectCase, len(p.workers)+1)\n\tfor !p.isIdle() {\n\t\tcases[0] = reflect.SelectCase{\n\t\t\tDir:  reflect.SelectRecv,\n\t\t\tChan: reflect.ValueOf(timer.C),\n\t\t}\n\t\tfor idx, w := range p.workers {\n\t\t\tcases[1+idx] = reflect.SelectCase{\n\t\t\t\tDir:  reflect.SelectRecv,\n\t\t\t\tChan: reflect.ValueOf(w.completedC),\n\t\t\t}\n\t\t}\n\t\tchosen, _, _ := reflect.Select(cases)\n\t\tif chosen == 0 {\n\t\t\ttimeout = true\n\t\t\treturn\n\t\t} else if chosen > 0 && chosen < len(p.workers)+1 {\n\t\t\tselect {\n\t\t\tcase <-timer.C:\n\t\t\t\ttimeout = true\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t}\n\t\t\tworkerID := uint64(chosen - 1)\n\t\t\tp.completed(workerID)\n\t\t\tp.schedule()\n\t\t} else {\n\t\t\tplog.Panicf(\"chosen %d, unknown case\", chosen)\n\t\t}\n\t}\n}\n\nfunc (p *closeWorkerPool) isIdle() bool {\n\treturn len(p.busy) == 0 && len(p.pending) == 0\n}\n\nfunc (p *closeWorkerPool) completed(workerID uint64) {\n\tshardID, ok := p.busy[workerID]\n\tif !ok {\n\t\tplog.Panicf(\"close worker %d is not in busy state\", workerID)\n\t}\n\tif _, ok := p.processing[shardID]; !ok {\n\t\tplog.Panicf(\"shard %d is not being processed\", shardID)\n\t}\n\tdelete(p.processing, shardID)\n\tdelete(p.busy, workerID)\n}\n\nfunc (p *closeWorkerPool) setBusy(workerID uint64, shardID uint64) {\n\tp.processing[shardID] = struct{}{}\n\tp.busy[workerID] = shardID\n}\n\nfunc (p *closeWorkerPool) getWorker() *closeWorker {\n\tfor _, w := range p.workers {\n\t\tif _, busy := p.busy[w.workerID]; !busy {\n\t\t\treturn w\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *closeWorkerPool) schedule() {\n\tfor {\n\t\tif !p.scheduleWorker() {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (p *closeWorkerPool) canSchedule(n *node) bool {\n\t_, ok := p.processing[n.shardID]\n\treturn !ok\n}\n\nfunc (p *closeWorkerPool) scheduleWorker() bool {\n\tw := p.getWorker()\n\tif w == nil {\n\t\treturn false\n\t}\n\n\tfor i := 0; i < len(p.pending); i++ {\n\t\tnode := p.pending[0]\n\t\tp.removeFromPending(0)\n\t\tif p.canSchedule(node) {\n\t\t\tp.scheduleReq(node, w)\n\t\t\treturn true\n\t\t} else {\n\t\t\tp.pending = append(p.pending, node)\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (p *closeWorkerPool) scheduleReq(n *node, w *closeWorker) {\n\tp.setBusy(w.workerID, n.shardID)\n\tselect {\n\tcase w.requestC <- closeReq{node: n}:\n\tdefault:\n\t\tpanic(\"worker received multiple jobs\")\n\t}\n}\n\nfunc (p *closeWorkerPool) removeFromPending(idx int) {\n\tsz := len(p.pending)\n\tcopy(p.pending[idx:], p.pending[idx+1:])\n\tp.pending = p.pending[:sz-1]\n}\n\ntype engine struct {\n\tnodeStopper     *syncutil.Stopper\n\tcommitStopper   *syncutil.Stopper\n\ttaskStopper     *syncutil.Stopper\n\tnh              nodeLoader\n\tloaded          *loadedNodes\n\tenv             *server.Env\n\tlogdb           raftio.ILogDB\n\tstepWorkReady   *workReady\n\tstepCCIReady    *workReady\n\tcommitWorkReady *workReady\n\tcommitCCIReady  *workReady\n\tapplyWorkReady  *workReady\n\tapplyCCIReady   *workReady\n\twp              *workerPool\n\tcp              *closeWorkerPool\n\tec              chan error\n\tnotifyCommit    bool\n}\n\nfunc newExecEngine(nh nodeLoader, cfg config.EngineConfig, notifyCommit bool,\n\terrorInjection bool, env *server.Env, logdb raftio.ILogDB) *engine {\n\tif cfg.ExecShards == 0 {\n\t\tpanic(\"ExecShards == 0\")\n\t}\n\tloaded := newLoadedNodes()\n\ts := &engine{\n\t\tnh:              nh,\n\t\tenv:             env,\n\t\tlogdb:           logdb,\n\t\tloaded:          loaded,\n\t\tnodeStopper:     syncutil.NewStopper(),\n\t\tcommitStopper:   syncutil.NewStopper(),\n\t\ttaskStopper:     syncutil.NewStopper(),\n\t\tstepWorkReady:   newWorkReady(cfg.ExecShards),\n\t\tstepCCIReady:    newWorkReady(cfg.ExecShards),\n\t\tcommitWorkReady: newWorkReady(cfg.CommitShards),\n\t\tcommitCCIReady:  newWorkReady(cfg.CommitShards),\n\t\tapplyWorkReady:  newWorkReady(cfg.ApplyShards),\n\t\tapplyCCIReady:   newWorkReady(cfg.ApplyShards),\n\t\twp:              newWorkerPool(nh, cfg.SnapshotShards, loaded),\n\t\tcp:              newCloseWorkerPool(cfg.CloseShards),\n\t\tnotifyCommit:    notifyCommit,\n\t}\n\tif errorInjection {\n\t\ts.ec = make(chan error, 1)\n\t}\n\tfor i := uint64(1); i <= cfg.ExecShards; i++ {\n\t\tworkerID := i\n\t\ts.nodeStopper.RunWorker(func() {\n\t\t\tif errorInjection {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t\tif ce, ok := r.(error); ok {\n\t\t\t\t\t\t\ts.crash(ce)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\ts.stepWorkerMain(workerID)\n\t\t})\n\t}\n\tif notifyCommit {\n\t\tfor i := uint64(1); i <= cfg.CommitShards; i++ {\n\t\t\tcommitWorkerID := i\n\t\t\ts.commitStopper.RunWorker(func() {\n\t\t\t\ts.commitWorkerMain(commitWorkerID)\n\t\t\t})\n\t\t}\n\t}\n\tfor i := uint64(1); i <= cfg.ApplyShards; i++ {\n\t\tapplyWorkerID := i\n\t\ts.taskStopper.RunWorker(func() {\n\t\t\ts.applyWorkerMain(applyWorkerID)\n\t\t})\n\t}\n\treturn s\n}\n\nfunc (e *engine) crash(err error) {\n\tselect {\n\tcase e.ec <- err:\n\tdefault:\n\t}\n}\n\nfunc (e *engine) close() error {\n\te.nodeStopper.Stop()\n\te.commitStopper.Stop()\n\te.taskStopper.Stop()\n\tvar err error\n\terr = firstError(err, e.wp.close())\n\treturn firstError(err, e.cp.close())\n}\n\nfunc (e *engine) nodeLoaded(shardID uint64, replicaID uint64) bool {\n\treturn e.loaded.get(shardID, replicaID) != nil\n}\n\nfunc (e *engine) destroyedC(shardID uint64, replicaID uint64) <-chan struct{} {\n\tif n := e.loaded.get(shardID, replicaID); n != nil {\n\t\treturn n.sm.DestroyedC()\n\t}\n\treturn nil\n}\n\nfunc (e *engine) load(workerID uint64,\n\tcci uint64, nodes map[uint64]*node,\n\tfrom from, ready *workReady) (map[uint64]*node, uint64) {\n\tresult, offloaded, cci := e.loadBucketNodes(workerID, cci, nodes,\n\t\tready.getPartitioner(), from)\n\te.loaded.update(workerID, from, result)\n\tfor _, n := range offloaded {\n\t\tn.offloaded()\n\t}\n\treturn result, cci\n}\n\nfunc (e *engine) commitWorkerMain(workerID uint64) {\n\tnodes := make(map[uint64]*node)\n\tticker := time.NewTicker(nodeReloadInterval)\n\tdefer ticker.Stop()\n\tcci := uint64(0)\n\tfor {\n\t\tselect {\n\t\tcase <-e.commitStopper.ShouldStop():\n\t\t\te.offloadNodeMap(nodes)\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\tnodes, cci = e.loadCommitNodes(workerID, cci, nodes)\n\t\t\te.processCommits(make(map[uint64]struct{}), nodes)\n\t\tcase <-e.commitCCIReady.waitCh(workerID):\n\t\t\tnodes, cci = e.loadCommitNodes(workerID, cci, nodes)\n\t\tcase <-e.commitWorkReady.waitCh(workerID):\n\t\t\tif cci == 0 || len(nodes) == 0 {\n\t\t\t\tnodes, cci = e.loadCommitNodes(workerID, cci, nodes)\n\t\t\t}\n\t\t\tactive := e.commitWorkReady.getReadyMap(workerID)\n\t\t\te.processCommits(active, nodes)\n\t\t}\n\t}\n}\n\nfunc (e *engine) loadCommitNodes(workerID uint64, cci uint64,\n\tnodes map[uint64]*node) (map[uint64]*node, uint64) {\n\treturn e.load(workerID, cci, nodes, fromCommitWorker, e.commitWorkReady)\n}\n\nfunc (e *engine) processCommits(idmap map[uint64]struct{},\n\tnodes map[uint64]*node) {\n\tif len(idmap) == 0 {\n\t\tfor k := range nodes {\n\t\t\tidmap[k] = struct{}{}\n\t\t}\n\t}\n\tfor shardID := range idmap {\n\t\tnode, ok := nodes[shardID]\n\t\tif !ok || node.stopped() {\n\t\t\tcontinue\n\t\t}\n\t\tnode.notifyCommittedEntries()\n\t}\n}\n\nfunc (e *engine) applyWorkerMain(workerID uint64) {\n\tnodes := make(map[uint64]*node)\n\tticker := time.NewTicker(nodeReloadInterval)\n\tdefer ticker.Stop()\n\tbatch := make([]rsm.Task, 0, taskBatchSize)\n\tentries := make([]sm.Entry, 0, taskBatchSize)\n\tcci := uint64(0)\n\tcount := uint64(0)\n\tfor {\n\t\tselect {\n\t\tcase <-e.taskStopper.ShouldStop():\n\t\t\te.offloadNodeMap(nodes)\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\tnodes, cci = e.loadApplyNodes(workerID, cci, nodes)\n\t\t\ta := make(map[uint64]struct{})\n\t\t\tif err := e.processApplies(a, nodes, batch, entries); err != nil {\n\t\t\t\tpanicNow(err)\n\t\t\t}\n\t\t\tcount++\n\t\t\tif count%200 == 0 {\n\t\t\t\tbatch = make([]rsm.Task, 0, taskBatchSize)\n\t\t\t\tentries = make([]sm.Entry, 0, taskBatchSize)\n\t\t\t}\n\t\tcase <-e.applyCCIReady.waitCh(workerID):\n\t\t\tnodes, cci = e.loadApplyNodes(workerID, cci, nodes)\n\t\tcase <-e.applyWorkReady.waitCh(workerID):\n\t\t\tif cci == 0 || len(nodes) == 0 {\n\t\t\t\tnodes, cci = e.loadApplyNodes(workerID, cci, nodes)\n\t\t\t}\n\t\t\ta := e.applyWorkReady.getReadyMap(workerID)\n\t\t\tif err := e.processApplies(a, nodes, batch, entries); err != nil {\n\t\t\t\tpanicNow(err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (e *engine) loadApplyNodes(workerID uint64, cci uint64,\n\tnodes map[uint64]*node) (map[uint64]*node, uint64) {\n\treturn e.load(workerID, cci, nodes, fromApplyWorker, e.applyWorkReady)\n}\n\n// S: save snapshot\n// R: recover from snapshot\n// existing op, new op, action\n// S, S, ignore the new op\n// S, R, R is queued as node state, will be handled when S is done\n// R, R, won't happen, when in R state, processApplies will not process the node\n// R, S, won't happen, when in R state, processApplies will not process the node\n\nfunc (e *engine) processApplies(idmap map[uint64]struct{},\n\tnodes map[uint64]*node, batch []rsm.Task, entries []sm.Entry) error {\n\tif len(idmap) == 0 {\n\t\tfor k := range nodes {\n\t\t\tidmap[k] = struct{}{}\n\t\t}\n\t}\n\tfor shardID := range idmap {\n\t\tnode, ok := nodes[shardID]\n\t\tif !ok || node.stopped() {\n\t\t\tcontinue\n\t\t}\n\t\tif node.processStatusTransition() {\n\t\t\tcontinue\n\t\t}\n\t\ttask, err := node.handleTask(batch, entries)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif task.IsSnapshotTask() {\n\t\t\tnode.handleSnapshotTask(task)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (e *engine) stepWorkerMain(workerID uint64) {\n\tnodes := make(map[uint64]*node)\n\tticker := time.NewTicker(nodeReloadInterval)\n\tdefer ticker.Stop()\n\tcci := uint64(0)\n\tstopC := e.nodeStopper.ShouldStop()\n\tupdates := make([]pb.Update, 0)\n\tfor {\n\t\tselect {\n\t\tcase <-stopC:\n\t\t\te.offloadNodeMap(nodes)\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\tnodes, cci = e.loadStepNodes(workerID, cci, nodes)\n\t\t\ta := make(map[uint64]struct{})\n\t\t\tif err := e.processSteps(workerID, a, nodes, updates, stopC); err != nil {\n\t\t\t\tpanicNow(err)\n\t\t\t}\n\t\tcase <-e.stepCCIReady.waitCh(workerID):\n\t\t\tnodes, cci = e.loadStepNodes(workerID, cci, nodes)\n\t\tcase <-e.stepWorkReady.waitCh(workerID):\n\t\t\tif cci == 0 || len(nodes) == 0 {\n\t\t\t\tnodes, cci = e.loadStepNodes(workerID, cci, nodes)\n\t\t\t}\n\t\t\ta := e.stepWorkReady.getReadyMap(workerID)\n\t\t\tif err := e.processSteps(workerID, a, nodes, updates, stopC); err != nil {\n\t\t\t\tpanicNow(err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (e *engine) loadStepNodes(workerID uint64,\n\tcci uint64, nodes map[uint64]*node) (map[uint64]*node, uint64) {\n\treturn e.load(workerID, cci, nodes, fromStepWorker, e.stepWorkReady)\n}\n\nfunc (e *engine) loadBucketNodes(workerID uint64,\n\tcsi uint64, nodes map[uint64]*node, partitioner server.IPartitioner,\n\tfrom from) (map[uint64]*node, []*node, uint64) {\n\tbucket := workerID - 1\n\tnewCSI := e.nh.getShardSetIndex()\n\tvar offloaded []*node\n\tif newCSI != csi {\n\t\tnewNodes := make(map[uint64]*node)\n\t\tloaded := make([]*node, 0)\n\t\tnewCSI = e.nh.forEachShard(func(cid uint64, v *node) bool {\n\t\t\tif n, ok := nodes[cid]; ok {\n\t\t\t\tif n.instanceID != v.instanceID {\n\t\t\t\t\tplog.Panicf(\"%s from two incarnations found\", n.id())\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif partitioner.GetPartitionID(cid) == bucket {\n\t\t\t\t\tloaded = append(loaded, v)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif partitioner.GetPartitionID(cid) == bucket {\n\t\t\t\tnewNodes[cid] = v\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\t\tfor cid, node := range nodes {\n\t\t\tif _, ok := newNodes[cid]; !ok {\n\t\t\t\toffloaded = append(offloaded, node)\n\t\t\t}\n\t\t}\n\t\tfor _, n := range loaded {\n\t\t\tn.loaded()\n\t\t}\n\t\treturn newNodes, offloaded, newCSI\n\t}\n\treturn nodes, offloaded, csi\n}\n\nfunc (e *engine) processSteps(workerID uint64,\n\tactive map[uint64]struct{},\n\tnodes map[uint64]*node, nodeUpdates []pb.Update, stopC chan struct{}) error {\n\tif len(nodes) == 0 {\n\t\treturn nil\n\t}\n\tif len(active) == 0 {\n\t\tfor cid := range nodes {\n\t\t\tactive[cid] = struct{}{}\n\t\t}\n\t}\n\tnodeUpdates = nodeUpdates[:0]\n\tfor cid := range active {\n\t\tnode, ok := nodes[cid]\n\t\tif !ok || node.stopped() {\n\t\t\tcontinue\n\t\t}\n\t\tud, hasUpdate, err := node.stepNode()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif hasUpdate {\n\t\t\tnodeUpdates = append(nodeUpdates, ud)\n\t\t}\n\t}\n\tif err := e.applySnapshotAndUpdate(nodeUpdates, nodes, true); err != nil {\n\t\treturn err\n\t}\n\t// see raft thesis section 10.2.1 on details why we send Replicate message\n\t// before those entries are persisted to disk\n\tfor _, ud := range nodeUpdates {\n\t\tnode := nodes[ud.ShardID]\n\t\tnode.sendReplicateMessages(ud)\n\t\tnode.processReadyToRead(ud)\n\t\tnode.processDroppedEntries(ud)\n\t\tnode.processDroppedReadIndexes(ud)\n\t\tnode.processLogQuery(ud.LogQueryResult)\n\t\tnode.processLeaderUpdate(ud.LeaderUpdate)\n\t}\n\tif err := e.logdb.SaveRaftState(nodeUpdates, workerID); err != nil {\n\t\treturn err\n\t}\n\tif err := e.onSnapshotSaved(nodeUpdates, nodes); err != nil {\n\t\treturn err\n\t}\n\tif err := e.applySnapshotAndUpdate(nodeUpdates, nodes, false); err != nil {\n\t\treturn err\n\t}\n\tfor _, ud := range nodeUpdates {\n\t\tnode := nodes[ud.ShardID]\n\t\tif err := node.processRaftUpdate(ud); err != nil {\n\t\t\treturn err\n\t\t}\n\t\te.processMoreCommittedEntries(ud)\n\t\tnode.commitRaftUpdate(ud)\n\t}\n\tif lazyFreeCycle > 0 {\n\t\tresetNodeUpdate(nodeUpdates)\n\t}\n\treturn nil\n}\n\nfunc resetNodeUpdate(nodeUpdates []pb.Update) {\n\tfor i := range nodeUpdates {\n\t\tnodeUpdates[i].EntriesToSave = nil\n\t\tnodeUpdates[i].CommittedEntries = nil\n\t\tfor j := range nodeUpdates[i].Messages {\n\t\t\tnodeUpdates[i].Messages[j].Entries = nil\n\t\t}\n\t}\n}\n\nfunc (e *engine) processMoreCommittedEntries(ud pb.Update) {\n\tif ud.MoreCommittedEntries {\n\t\te.setStepReady(ud.ShardID)\n\t}\n}\n\nfunc (e *engine) applySnapshotAndUpdate(updates []pb.Update,\n\tnodes map[uint64]*node, fastApply bool) error {\n\tnotifyCommit := false\n\tfor _, ud := range updates {\n\t\tif ud.FastApply != fastApply {\n\t\t\tcontinue\n\t\t}\n\t\tnode := nodes[ud.ShardID]\n\t\tif node.notifyCommit {\n\t\t\tnotifyCommit = true\n\t\t}\n\t\tif err := node.processSnapshot(ud); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnode.applyRaftUpdates(ud)\n\t}\n\tif !notifyCommit {\n\t\te.setApplyReadyByUpdates(updates)\n\t} else {\n\t\te.setCommitReadyByUpdates(updates)\n\t}\n\treturn nil\n}\n\nfunc (e *engine) onSnapshotSaved(updates []pb.Update,\n\tnodes map[uint64]*node) error {\n\tfor _, ud := range updates {\n\t\tif !pb.IsEmptySnapshot(ud.Snapshot) {\n\t\t\tnode := nodes[ud.ShardID]\n\t\t\tif err := node.removeSnapshotFlagFile(ud.Snapshot.Index); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (e *engine) setCloseReady(n *node) {\n\te.cp.ready <- closeReq{node: n}\n}\n\nfunc (e *engine) setStepReadyByMessageBatch(mb pb.MessageBatch) {\n\te.stepWorkReady.shardReadyByMessageBatch(mb)\n}\n\nfunc (e *engine) setAllStepReady(nodes []*node) {\n\te.stepWorkReady.allShardsReady(nodes)\n}\n\nfunc (e *engine) setStepReady(shardID uint64) {\n\te.stepWorkReady.shardReady(shardID)\n}\n\nfunc (e *engine) setCommitReadyByUpdates(updates []pb.Update) {\n\te.commitWorkReady.shardReadyByUpdates(updates)\n}\n\nfunc (e *engine) setCommitReady(shardID uint64) {\n\te.commitWorkReady.shardReady(shardID)\n}\n\nfunc (e *engine) setApplyReadyByUpdates(updates []pb.Update) {\n\te.applyWorkReady.shardReadyByUpdates(updates)\n}\n\nfunc (e *engine) setApplyReady(shardID uint64) {\n\te.applyWorkReady.shardReady(shardID)\n}\n\nfunc (e *engine) setStreamReady(shardID uint64) {\n\te.wp.streamReady.shardReady(shardID)\n}\n\nfunc (e *engine) setSaveReady(shardID uint64) {\n\te.wp.saveReady.shardReady(shardID)\n}\n\nfunc (e *engine) setRecoverReady(shardID uint64) {\n\te.wp.recoverReady.shardReady(shardID)\n}\n\nfunc (e *engine) setCCIReady(shardID uint64) {\n\te.stepCCIReady.shardReady(shardID)\n\te.commitCCIReady.shardReady(shardID)\n\te.applyCCIReady.shardReady(shardID)\n\te.wp.cciReady.shardReady(shardID)\n}\n\nfunc (e *engine) offloadNodeMap(nodes map[uint64]*node) {\n\tfor _, node := range nodes {\n\t\tnode.offloaded()\n\t}\n}\n"
        },
        {
          "name": "engine_test.go",
          "type": "blob",
          "size": 5.669921875,
          "content": "// Copyright 2017-2021 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dragonboat\n\nimport (\n\t\"testing\"\n)\n\nfunc TestBitmapAdd(t *testing.T) {\n\tvar b bitmap\n\tfor i := uint64(0); i < 64; i++ {\n\t\tif b.contains(i) {\n\t\t\tt.Errorf(\"unexpectedly contains value %d\", i)\n\t\t}\n\t\tb.add(i)\n\t\tif !b.contains(i) {\n\t\t\tt.Errorf(\"failed to add value %d\", i)\n\t\t}\n\t}\n}\n\nfunc TestBitmapContains(t *testing.T) {\n\tvar b bitmap\n\tb.add(1)\n\tb.add(3)\n\tif !b.contains(1) {\n\t\tt.Errorf(\"contains 1 failed\")\n\t}\n\tif !b.contains(3) {\n\t\tt.Errorf(\"contains 3 failed\")\n\t}\n\tif b.contains(2) {\n\t\tt.Errorf(\"contains 2 failed\")\n\t}\n}\n\nfunc TestWorkReadyCanBeCreated(t *testing.T) {\n\twr := newWorkReady(4)\n\tif len(wr.maps) != 4 || len(wr.channels) != 4 {\n\t\tt.Errorf(\"unexpected ready list len\")\n\t}\n\tif wr.count != 4 {\n\t\tt.Errorf(\"unexpected count value\")\n\t}\n}\n\nfunc TestPartitionerWorksAsExpected(t *testing.T) {\n\twr := newWorkReady(4)\n\tp := wr.getPartitioner()\n\tvals := make(map[uint64]struct{})\n\tfor i := uint64(0); i < uint64(128); i++ {\n\t\tidx := p.GetPartitionID(i)\n\t\tvals[idx] = struct{}{}\n\t}\n\tif len(vals) != 4 {\n\t\tt.Errorf(\"unexpected partitioner outcome\")\n\t}\n}\n\nfunc TestAllShardsReady(t *testing.T) {\n\twr := newWorkReady(4)\n\tnodes := make([]*node, 0)\n\tfor i := uint64(0); i < uint64(4); i++ {\n\t\tnodes = append(nodes, &node{shardID: i})\n\t}\n\twr.allShardsReady(nodes)\n\tfor i := uint64(0); i < uint64(4); i++ {\n\t\tch := wr.channels[i]\n\t\tselect {\n\t\tcase <-ch:\n\t\tdefault:\n\t\t\tt.Errorf(\"channel not ready\")\n\t\t}\n\t\trc := wr.maps[i]\n\t\tm := rc.getReadyShards()\n\t\tif len(m) != 1 {\n\t\t\tt.Errorf(\"unexpected map size\")\n\t\t}\n\t\tif _, ok := m[i]; !ok {\n\t\t\tt.Errorf(\"shard not set\")\n\t\t}\n\t}\n\tnodes = nodes[:0]\n\tnodes = append(nodes, []*node{{shardID: 0}, {shardID: 2}, {shardID: 3}}...)\n\twr.allShardsReady(nodes)\n\tch := wr.channels[1]\n\tselect {\n\tcase <-ch:\n\t\tt.Errorf(\"channel unexpectedly set as ready\")\n\tdefault:\n\t}\n\trc := wr.maps[1]\n\tm := rc.getReadyShards()\n\tif len(m) != 0 {\n\t\tt.Errorf(\"shard map unexpected set\")\n\t}\n}\n\nfunc TestWorkCanBeSetAsReady(t *testing.T) {\n\twr := newWorkReady(4)\n\tselect {\n\tcase <-wr.waitCh(1):\n\t\tt.Errorf(\"ready signaled\")\n\tcase <-wr.waitCh(2):\n\t\tt.Errorf(\"ready signaled\")\n\tcase <-wr.waitCh(3):\n\t\tt.Errorf(\"ready signaled\")\n\tcase <-wr.waitCh(4):\n\t\tt.Errorf(\"ready signaled\")\n\tdefault:\n\t}\n\twr.shardReady(0)\n\tselect {\n\tcase <-wr.waitCh(1):\n\tcase <-wr.waitCh(2):\n\t\tt.Errorf(\"ready signaled\")\n\tcase <-wr.waitCh(3):\n\t\tt.Errorf(\"ready signaled\")\n\tcase <-wr.waitCh(4):\n\t\tt.Errorf(\"ready signaled\")\n\tdefault:\n\t\tt.Errorf(\"ready not signaled\")\n\t}\n\twr.shardReady(9)\n\tselect {\n\tcase <-wr.waitCh(1):\n\t\tt.Errorf(\"ready signaled\")\n\tcase <-wr.waitCh(2):\n\tcase <-wr.waitCh(3):\n\t\tt.Errorf(\"ready signaled\")\n\tcase <-wr.waitCh(4):\n\t\tt.Errorf(\"ready signaled\")\n\tdefault:\n\t\tt.Errorf(\"ready not signaled\")\n\t}\n}\n\nfunc TestReturnedReadyMapContainsReadyShardID(t *testing.T) {\n\twr := newWorkReady(4)\n\twr.shardReady(0)\n\twr.shardReady(4)\n\twr.shardReady(129)\n\tready := wr.getReadyMap(1)\n\tif len(ready) != 2 {\n\t\tt.Errorf(\"unexpected ready map size, sz: %d\", len(ready))\n\t}\n\t_, ok := ready[0]\n\t_, ok2 := ready[4]\n\tif !ok || !ok2 {\n\t\tt.Errorf(\"missing shard id\")\n\t}\n\tready = wr.getReadyMap(2)\n\tif len(ready) != 1 {\n\t\tt.Errorf(\"unexpected ready map size\")\n\t}\n\t_, ok = ready[129]\n\tif !ok {\n\t\tt.Errorf(\"missing shard id\")\n\t}\n\tready = wr.getReadyMap(3)\n\tif len(ready) != 0 {\n\t\tt.Errorf(\"unexpected ready map size\")\n\t}\n}\n\nfunc TestLoadedNodes(t *testing.T) {\n\tlns := newLoadedNodes()\n\tif lns.get(2, 3) != nil {\n\t\tt.Errorf(\"unexpectedly returned true\")\n\t}\n\tnodes := make(map[uint64]*node)\n\tn := &node{}\n\tn.replicaID = 3\n\tnodes[2] = n\n\tlns.update(1, fromStepWorker, nodes)\n\tif lns.get(2, 3) == nil {\n\t\tt.Errorf(\"unexpectedly returned false\")\n\t}\n\tn.replicaID = 4\n\tlns.update(1, fromStepWorker, nodes)\n\tif lns.get(2, 3) != nil {\n\t\tt.Errorf(\"unexpectedly returned true\")\n\t}\n\tnodes = make(map[uint64]*node)\n\tnodes[5] = n\n\tn.replicaID = 3\n\tlns.update(1, fromStepWorker, nodes)\n\tif lns.get(2, 3) != nil {\n\t\tt.Errorf(\"unexpectedly returned true\")\n\t}\n}\n\nfunc TestBusyMapKeyIsIgnoredWhenUpdatingLoadedNodes(t *testing.T) {\n\tm := make(map[uint64]*node)\n\tm[1] = &node{shardID: 100, replicaID: 100}\n\tm[2] = &node{shardID: 200, replicaID: 200}\n\tl := newLoadedNodes()\n\tl.updateFromBusySSNodes(m)\n\tnm := l.nodes[nodeType{workerID: 0, from: fromWorker}]\n\tif len(nm) != 2 {\n\t\tt.Errorf(\"unexpected map len\")\n\t}\n\tif n, ok := nm[100]; !ok || n.shardID != 100 {\n\t\tt.Errorf(\"failed to locate the node\")\n\t}\n\tif n, ok := nm[200]; !ok || n.shardID != 200 {\n\t\tt.Errorf(\"failed to locate the node\")\n\t}\n}\n\n/*\nfunc TestWPRemoveFromPending(t *testing.T) {\n\ttests := []struct {\n\t\tlength uint64\n\t\tidx    uint64\n\t}{\n\t\t{1, 0},\n\t\t{5, 0},\n\t\t{5, 1},\n\t\t{5, 4},\n\t}\n\tfor idx, tt := range tests {\n\t\tw := &workerPool{}\n\t\tfor i := uint64(0); i < tt.length; i++ {\n\t\t\tcid := uint64(1)\n\t\t\tif i == tt.idx {\n\t\t\t\tcid = uint64(0)\n\t\t\t}\n\t\t\tr := tsn{task: rsm.Task{ShardID: cid}}\n\t\t\tw.pending = append(w.pending, r)\n\t\t}\n\t\tif uint64(len(w.pending)) != tt.length {\n\t\t\tt.Errorf(\"unexpected length\")\n\t\t}\n\t\tw.removeFromPending(int(tt.idx))\n\t\tif uint64(len(w.pending)) != tt.length-1 {\n\t\t\tt.Errorf(\"unexpected length\")\n\t\t}\n\t\tfor _, p := range w.pending {\n\t\t\tif p.task.ShardID == 0 {\n\t\t\t\tt.Errorf(\"%d, pending not removed, %+v\", idx, w.pending)\n\t\t\t}\n\t\t}\n\t}\n}*/\n"
        },
        {
          "name": "event.go",
          "type": "blob",
          "size": 6.6650390625,
          "content": "// Copyright 2017-2020 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dragonboat\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"sync/atomic\"\n\n\t\"github.com/VictoriaMetrics/metrics\"\n\n\t\"github.com/lni/dragonboat/v4/internal/server\"\n\t\"github.com/lni/dragonboat/v4/raftio\"\n)\n\n// WriteHealthMetrics writes all health metrics in Prometheus format to the\n// specified writer. This function is typically called by the metrics http\n// handler.\nfunc WriteHealthMetrics(w io.Writer) {\n\tmetrics.WritePrometheus(w, false)\n}\n\ntype raftEventListener struct {\n\treadIndexDropped    *metrics.Counter\n\tproposalDropped     *metrics.Counter\n\treplicationRejected *metrics.Counter\n\tsnapshotRejected    *metrics.Counter\n\tqueue               *leaderInfoQueue\n\thasLeader           *metrics.Gauge\n\tterm                *metrics.Gauge\n\tcampaignLaunched    *metrics.Counter\n\tcampaignSkipped     *metrics.Counter\n\tleaderID            uint64\n\ttermValue           uint64\n\treplicaID           uint64\n\tshardID             uint64\n\tmetrics             bool\n}\n\nvar _ server.IRaftEventListener = (*raftEventListener)(nil)\n\nfunc newRaftEventListener(shardID uint64, replicaID uint64,\n\tuseMetrics bool, queue *leaderInfoQueue) *raftEventListener {\n\tel := &raftEventListener{\n\t\tshardID:   shardID,\n\t\treplicaID: replicaID,\n\t\tmetrics:   useMetrics,\n\t\tqueue:     queue,\n\t}\n\tif useMetrics {\n\t\tlabel := fmt.Sprintf(`{shardid=\"%d\",replicaid=\"%d\"}`, shardID, replicaID)\n\t\tname := fmt.Sprintf(`dragonboat_raftnode_campaign_launched_total%s`, label)\n\t\tel.campaignLaunched = metrics.GetOrCreateCounter(name)\n\t\tname = fmt.Sprintf(`dragonboat_raftnode_campaign_skipped_total%s`, label)\n\t\tel.campaignSkipped = metrics.GetOrCreateCounter(name)\n\t\tname = fmt.Sprintf(`dragonboat_raftnode_snapshot_rejected_total%s`, label)\n\t\tel.snapshotRejected = metrics.GetOrCreateCounter(name)\n\t\tname = fmt.Sprintf(`dragonboat_raftnode_replication_rejected_total%s`, label)\n\t\tel.replicationRejected = metrics.GetOrCreateCounter(name)\n\t\tname = fmt.Sprintf(`dragonboat_raftnode_proposal_dropped_total%s`, label)\n\t\tel.proposalDropped = metrics.GetOrCreateCounter(name)\n\t\tname = fmt.Sprintf(`dragonboat_raftnode_read_index_dropped_total%s`, label)\n\t\tel.readIndexDropped = metrics.GetOrCreateCounter(name)\n\t\tname = fmt.Sprintf(`dragonboat_raftnode_has_leader%s`, label)\n\t\tel.hasLeader = metrics.GetOrCreateGauge(name, func() float64 {\n\t\t\tif atomic.LoadUint64(&el.leaderID) == raftio.NoLeader {\n\t\t\t\treturn 0.0\n\t\t\t}\n\t\t\treturn 1.0\n\t\t})\n\t\tname = fmt.Sprintf(`dragonboat_raftnode_term%s`, label)\n\t\tel.term = metrics.GetOrCreateGauge(name, func() float64 {\n\t\t\treturn float64(atomic.LoadUint64(&el.termValue))\n\t\t})\n\t}\n\treturn el\n}\n\nfunc (e *raftEventListener) close() {\n}\n\nfunc (e *raftEventListener) LeaderUpdated(info server.LeaderInfo) {\n\tatomic.StoreUint64(&e.leaderID, info.LeaderID)\n\tatomic.StoreUint64(&e.termValue, info.Term)\n\tif e.queue != nil {\n\t\tui := raftio.LeaderInfo{\n\t\t\tShardID:   info.ShardID,\n\t\t\tReplicaID: info.ReplicaID,\n\t\t\tTerm:      info.Term,\n\t\t\tLeaderID:  info.LeaderID,\n\t\t}\n\t\te.queue.addLeaderInfo(ui)\n\t}\n}\n\nfunc (e *raftEventListener) CampaignLaunched(info server.CampaignInfo) {\n\tif e.metrics {\n\t\te.campaignLaunched.Add(1)\n\t}\n}\n\nfunc (e *raftEventListener) CampaignSkipped(info server.CampaignInfo) {\n\tif e.metrics {\n\t\te.campaignSkipped.Add(1)\n\t}\n}\n\nfunc (e *raftEventListener) SnapshotRejected(info server.SnapshotInfo) {\n\tif e.metrics {\n\t\te.snapshotRejected.Add(1)\n\t}\n}\n\nfunc (e *raftEventListener) ReplicationRejected(info server.ReplicationInfo) {\n\tif e.metrics {\n\t\te.replicationRejected.Add(1)\n\t}\n}\n\nfunc (e *raftEventListener) ProposalDropped(info server.ProposalInfo) {\n\tif e.metrics {\n\t\te.proposalDropped.Add(len(info.Entries))\n\t}\n}\n\nfunc (e *raftEventListener) ReadIndexDropped(info server.ReadIndexInfo) {\n\tif e.metrics {\n\t\te.readIndexDropped.Add(1)\n\t}\n}\n\ntype sysEventListener struct {\n\tstopc  chan struct{}\n\tevents chan server.SystemEvent\n\tul     raftio.ISystemEventListener\n}\n\nfunc newSysEventListener(l raftio.ISystemEventListener,\n\tstopc chan struct{}) *sysEventListener {\n\treturn &sysEventListener{\n\t\tstopc:  stopc,\n\t\tevents: make(chan server.SystemEvent),\n\t\tul:     l,\n\t}\n}\n\nfunc (l *sysEventListener) Publish(e server.SystemEvent) {\n\tif l.ul == nil {\n\t\treturn\n\t}\n\tselect {\n\tcase l.events <- e:\n\tcase <-l.stopc:\n\t\treturn\n\t}\n}\n\nfunc (l *sysEventListener) handle(e server.SystemEvent) {\n\tif l.ul == nil {\n\t\treturn\n\t}\n\tswitch e.Type {\n\tcase server.NodeHostShuttingDown:\n\t\tl.ul.NodeHostShuttingDown()\n\tcase server.NodeReady:\n\t\tl.ul.NodeReady(getNodeInfo(e))\n\tcase server.NodeUnloaded:\n\t\tl.ul.NodeUnloaded(getNodeInfo(e))\n\tcase server.NodeDeleted:\n\t\tl.ul.NodeDeleted(getNodeInfo(e))\n\tcase server.MembershipChanged:\n\t\tl.ul.MembershipChanged(getNodeInfo(e))\n\tcase server.ConnectionEstablished:\n\t\tl.ul.ConnectionEstablished(getConnectionInfo(e))\n\tcase server.ConnectionFailed:\n\t\tl.ul.ConnectionFailed(getConnectionInfo(e))\n\tcase server.SendSnapshotStarted:\n\t\tl.ul.SendSnapshotStarted(getSnapshotInfo(e))\n\tcase server.SendSnapshotCompleted:\n\t\tl.ul.SendSnapshotCompleted(getSnapshotInfo(e))\n\tcase server.SendSnapshotAborted:\n\t\tl.ul.SendSnapshotAborted(getSnapshotInfo(e))\n\tcase server.SnapshotReceived:\n\t\tl.ul.SnapshotReceived(getSnapshotInfo(e))\n\tcase server.SnapshotRecovered:\n\t\tl.ul.SnapshotRecovered(getSnapshotInfo(e))\n\tcase server.SnapshotCreated:\n\t\tl.ul.SnapshotCreated(getSnapshotInfo(e))\n\tcase server.SnapshotCompacted:\n\t\tl.ul.SnapshotCompacted(getSnapshotInfo(e))\n\tcase server.LogCompacted:\n\t\tl.ul.LogCompacted(getEntryInfo(e))\n\tcase server.LogDBCompacted:\n\t\tl.ul.LogDBCompacted(getEntryInfo(e))\n\tdefault:\n\t\tpanic(\"unknown event type\")\n\t}\n}\n\nfunc getSnapshotInfo(e server.SystemEvent) raftio.SnapshotInfo {\n\treturn raftio.SnapshotInfo{\n\t\tShardID:   e.ShardID,\n\t\tReplicaID: e.ReplicaID,\n\t\tFrom:      e.From,\n\t\tIndex:     e.Index,\n\t}\n}\n\nfunc getNodeInfo(e server.SystemEvent) raftio.NodeInfo {\n\treturn raftio.NodeInfo{\n\t\tShardID:   e.ShardID,\n\t\tReplicaID: e.ReplicaID,\n\t}\n}\n\nfunc getEntryInfo(e server.SystemEvent) raftio.EntryInfo {\n\treturn raftio.EntryInfo{\n\t\tShardID:   e.ShardID,\n\t\tReplicaID: e.ReplicaID,\n\t\tIndex:     e.Index,\n\t}\n}\n\nfunc getConnectionInfo(e server.SystemEvent) raftio.ConnectionInfo {\n\treturn raftio.ConnectionInfo{\n\t\tAddress:            e.Address,\n\t\tSnapshotConnection: e.SnapshotConnection,\n\t}\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.9951171875,
          "content": "module github.com/lni/dragonboat/v4\n\nrequire (\n\tgithub.com/VictoriaMetrics/metrics v1.18.1\n\tgithub.com/cespare/xxhash/v2 v2.1.2\n\tgithub.com/cockroachdb/errors v1.9.0\n\tgithub.com/cockroachdb/pebble v0.0.0-20221207173255-0f086d933dac\n\tgithub.com/golang/snappy v0.0.4\n\tgithub.com/google/uuid v1.3.0\n\tgithub.com/hashicorp/memberlist v0.3.1\n\tgithub.com/kr/pretty v0.3.0\n\tgithub.com/lni/goutils v1.4.0\n\tgithub.com/lni/vfs v0.2.1-0.20220616104132-8852fd867376\n\tgithub.com/pierrec/lz4/v4 v4.1.14\n\tgithub.com/stretchr/testify v1.7.0\n\tgolang.org/x/exp v0.0.0-20200513190911-00229845015e\n\tgolang.org/x/sys v0.12.0\n)\n\nrequire (\n\tgithub.com/DataDog/zstd v1.4.5 // indirect\n\tgithub.com/HdrHistogram/hdrhistogram-go v1.1.2 // indirect\n\tgithub.com/armon/go-metrics v0.0.0-20180917152333-f0300d1749da // indirect\n\tgithub.com/cockroachdb/logtags v0.0.0-20211118104740-dabe8e521a4f // indirect\n\tgithub.com/cockroachdb/redact v1.1.3 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/getsentry/sentry-go v0.12.0 // indirect\n\tgithub.com/gogo/protobuf v1.3.2 // indirect\n\tgithub.com/google/btree v1.0.0 // indirect\n\tgithub.com/hashicorp/errwrap v1.0.0 // indirect\n\tgithub.com/hashicorp/go-immutable-radix v1.0.0 // indirect\n\tgithub.com/hashicorp/go-msgpack v0.5.3 // indirect\n\tgithub.com/hashicorp/go-multierror v1.0.0 // indirect\n\tgithub.com/hashicorp/go-sockaddr v1.0.0 // indirect\n\tgithub.com/hashicorp/golang-lru v0.5.1 // indirect\n\tgithub.com/klauspost/compress v1.11.13 // indirect\n\tgithub.com/kr/text v0.2.0 // indirect\n\tgithub.com/miekg/dns v1.1.26 // indirect\n\tgithub.com/pkg/errors v0.9.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/rogpeppe/go-internal v1.8.1 // indirect\n\tgithub.com/sean-/seed v0.0.0-20170313163322-e2103e2c3529 // indirect\n\tgithub.com/valyala/fastrand v1.1.0 // indirect\n\tgithub.com/valyala/histogram v1.2.0 // indirect\n\tgolang.org/x/crypto v0.13.0 // indirect\n\tgolang.org/x/net v0.15.0 // indirect\n\tgolang.org/x/sync v0.1.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n\ngo 1.20\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 47.671875,
          "content": "cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ndmitri.shuralyov.com/gpu/mtl v0.0.0-20190408044501-666a987793e9/go.mod h1:H6x//7gZCb22OMCxBHrMx7a5I7Hp++hsVxbQ4BYO7hU=\ngithub.com/AndreasBriese/bbloom v0.0.0-20190306092124-e2d15f34fcf9/go.mod h1:bOvUY6CB00SOBii9/FifXqc0awNKxLFCL/+pkDPuyl8=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=\ngithub.com/CloudyKit/fastprinter v0.0.0-20170127035650-74b38d55f37a/go.mod h1:EFZQ978U7x8IRnstaskI3IysnWY5Ao3QgZUKOXlsAdw=\ngithub.com/CloudyKit/fastprinter v0.0.0-20200109182630-33d98a066a53/go.mod h1:+3IMCy2vIlbG1XG/0ggNQv0SvxCAIpPM5b1nCz56Xno=\ngithub.com/CloudyKit/jet v2.1.3-0.20180809161101-62edd43e4f88+incompatible/go.mod h1:HPYO+50pSWkPoj9Q/eq0aRGByCL6ScRlUmiEX5Zgm+w=\ngithub.com/CloudyKit/jet/v3 v3.0.0/go.mod h1:HKQPgSJmdK8hdoAbKUUWajkHyHo4RaU5rMdUywE7VMo=\ngithub.com/DataDog/zstd v1.4.5 h1:EndNeuB0l9syBZhut0wns3gV1hL8zX8LIu6ZiVHWLIQ=\ngithub.com/DataDog/zstd v1.4.5/go.mod h1:1jcaCB/ufaK+sKp1NBhlGmpz41jOoPQ35bpF36t7BBo=\ngithub.com/HdrHistogram/hdrhistogram-go v1.1.2 h1:5IcZpTvzydCQeHzK4Ef/D5rrSqwxob0t8PQPMybUNFM=\ngithub.com/HdrHistogram/hdrhistogram-go v1.1.2/go.mod h1:yDgFjdqOqDEKOvasDdhWNXYg9BVp4O+o5f6V/ehm6Oo=\ngithub.com/Joker/hpp v1.0.0/go.mod h1:8x5n+M1Hp5hC0g8okX3sR3vFQwynaX/UgSOM9MeBKzY=\ngithub.com/Joker/jade v1.0.1-0.20190614124447-d475f43051e7/go.mod h1:6E6s8o2AE4KhCrqr6GRJjdC/gNfTdxkIXvuGZZda2VM=\ngithub.com/Shopify/goreferrer v0.0.0-20181106222321-ec9c9a553398/go.mod h1:a1uqRtAwp2Xwc6WNPJEufxJ7fx3npB4UV/JOLmbu5I0=\ngithub.com/VictoriaMetrics/metrics v1.18.1 h1:OZ0+kTTto8oPfHnVAnTOoyl0XlRhRkoQrD2n2cOuRw0=\ngithub.com/VictoriaMetrics/metrics v1.18.1/go.mod h1:ArjwVz7WpgpegX/JpB0zpNF2h2232kErkEnzH1sxMmA=\ngithub.com/ajg/form v1.5.1/go.mod h1:uL1WgH+h2mgNtvBq0339dVnzXdBETtL2LeUXaIv25UY=\ngithub.com/ajstarks/svgo v0.0.0-20180226025133-644b8db467af/go.mod h1:K08gAheRH3/J6wwsYMMT4xOr94bZjxIelGM0+d/wbFw=\ngithub.com/armon/consul-api v0.0.0-20180202201655-eb2c6b5be1b6/go.mod h1:grANhF5doyWs3UAsr3K4I6qtAmlQcZDesFNEHPZAzj8=\ngithub.com/armon/go-metrics v0.0.0-20180917152333-f0300d1749da h1:8GUt8eRujhVEGZFFEjBj46YV4rDjvGrNxb0KMWYkL2I=\ngithub.com/armon/go-metrics v0.0.0-20180917152333-f0300d1749da/go.mod h1:Q73ZrmVTwzkszR9V5SSuryQ31EELlFMUz1kKyl939pY=\ngithub.com/aymerick/raymond v2.0.3-0.20180322193309-b565731e1464+incompatible/go.mod h1:osfaiScAUVup+UC9Nfq76eWqDhXlp+4UYaA8uhTBO6g=\ngithub.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=\ngithub.com/cespare/xxhash/v2 v2.1.1/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/cespare/xxhash/v2 v2.1.2 h1:YRXhKfTDauu4ajMg1TPgFO5jnlC2HCbmLXMcTG5cbYE=\ngithub.com/cespare/xxhash/v2 v2.1.2/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=\ngithub.com/cncf/udpa/go v0.0.0-20201120205902-5459f2c99403/go.mod h1:WmhPx2Nbnhtbo57+VJT5O0JRkEi1Wbu0z5j0R8u5Hbk=\ngithub.com/cockroachdb/datadriven v1.0.0/go.mod h1:5Ib8Meh+jk1RlHIXej6Pzevx/NLlNvQB9pmSBZErGA4=\ngithub.com/cockroachdb/datadriven v1.0.1-0.20211007161720-b558070c3be0/go.mod h1:5Ib8Meh+jk1RlHIXej6Pzevx/NLlNvQB9pmSBZErGA4=\ngithub.com/cockroachdb/datadriven v1.0.1-0.20220214170620-9913f5bc19b7/go.mod h1:hi0MtSY3AYDQNDi83kDkMH5/yqM/CsIrsOITkSoH7KI=\ngithub.com/cockroachdb/errors v1.6.1/go.mod h1:tm6FTP5G81vwJ5lC0SizQo374JNCOPrHyXGitRJoDqM=\ngithub.com/cockroachdb/errors v1.8.1/go.mod h1:qGwQn6JmZ+oMjuLwjWzUNqblqk0xl4CVV3SQbGwK7Ac=\ngithub.com/cockroachdb/errors v1.8.8/go.mod h1:z6VnEL3hZ/2ONZEvG7S5Ym0bU2AqPcEKnIiA1wbsSu0=\ngithub.com/cockroachdb/errors v1.9.0 h1:B48dYem5SlAY7iU8AKsgedb4gH6mo+bDkbtLIvM/a88=\ngithub.com/cockroachdb/errors v1.9.0/go.mod h1:vaNcEYYqbIqB5JhKBhFV9CneUqeuEbB2OYJBK4GBNYQ=\ngithub.com/cockroachdb/logtags v0.0.0-20190617123548-eb05cc24525f/go.mod h1:i/u985jwjWRlyHXQbwatDASoW0RMlZ/3i9yJHE2xLkI=\ngithub.com/cockroachdb/logtags v0.0.0-20211118104740-dabe8e521a4f h1:6jduT9Hfc0njg5jJ1DdKCFPdMBrp/mdZfCpa5h+WM74=\ngithub.com/cockroachdb/logtags v0.0.0-20211118104740-dabe8e521a4f/go.mod h1:Vz9DsVWQQhf3vs21MhPMZpMGSht7O/2vFW2xusFUVOs=\ngithub.com/cockroachdb/pebble v0.0.0-20221207173255-0f086d933dac h1:pwyQPbghSh6PC4MgXNvMZjf19LTugkIIPUSRzAD5LEE=\ngithub.com/cockroachdb/pebble v0.0.0-20221207173255-0f086d933dac/go.mod h1:890yq1fUb9b6dGNwssgeUO5vQV9qfXnCPxAJhBQfXw0=\ngithub.com/cockroachdb/redact v1.0.8/go.mod h1:BVNblN9mBWFyMyqK1k3AAiSxhvhfK2oOZZ2lK+dpvRg=\ngithub.com/cockroachdb/redact v1.1.3 h1:AKZds10rFSIj7qADf0g46UixK8NNLwWTNdCIGS5wfSQ=\ngithub.com/cockroachdb/redact v1.1.3/go.mod h1:BVNblN9mBWFyMyqK1k3AAiSxhvhfK2oOZZ2lK+dpvRg=\ngithub.com/cockroachdb/sentry-go v0.6.1-cockroachdb.2/go.mod h1:8BT+cPK6xvFOcRlk0R8eg+OTkcqI6baNH4xAkpiYVvQ=\ngithub.com/codegangsta/inject v0.0.0-20150114235600-33e0aa1cb7c0/go.mod h1:4Zcjuz89kmFXt9morQgcfYZAYZ5n8WHjt81YYWIwtTM=\ngithub.com/coreos/etcd v3.3.10+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=\ngithub.com/coreos/go-etcd v2.0.0+incompatible/go.mod h1:Jez6KQU2B/sWsbdaef3ED8NzMklzPG4d5KIOhIy30Tk=\ngithub.com/coreos/go-semver v0.2.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=\ngithub.com/cpuguy83/go-md2man v1.0.10/go.mod h1:SmD6nW6nTyfqj6ABTjUi3V3JVMnlJmwcJI5acqYI6dE=\ngithub.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dgraph-io/badger v1.6.0/go.mod h1:zwt7syl517jmP8s94KqSxTlM6IMsdhYy6psNgSztDR4=\ngithub.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=\ngithub.com/dgryski/go-farm v0.0.0-20190423205320-6a90982ecee2/go.mod h1:SqUrOPUnsFjfmXRMNPybcSiG0BgUW2AuFH8PAnS2iTw=\ngithub.com/dustin/go-humanize v1.0.0/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=\ngithub.com/eknkc/amber v0.0.0-20171010120322-cdade1c07385/go.mod h1:0vRUJqYpeSZifjYj7uP3BG/gKcuzL9xWVV/Y+cK33KM=\ngithub.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=\ngithub.com/envoyproxy/go-control-plane v0.9.9-0.20210217033140-668b12f5399d/go.mod h1:cXg6YxExXjJnVBQHBLXeUAgxn2UodCpnH306RInaBQk=\ngithub.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=\ngithub.com/etcd-io/bbolt v1.3.3/go.mod h1:ZF2nL25h33cCyBtcyWeZ2/I3HQOfTP+0PIEvHjkjCrw=\ngithub.com/fasthttp-contrib/websocket v0.0.0-20160511215533-1f3b11f56072/go.mod h1:duJ4Jxv5lDcvg4QuQr0oowTf7dz4/CR8NtyCooz9HL8=\ngithub.com/fatih/structs v1.1.0/go.mod h1:9NiDSp5zOcgEDl+j00MP/WkGVPOlPRLejGD8Ga6PJ7M=\ngithub.com/flosch/pongo2 v0.0.0-20190707114632-bbf5a6c351f4/go.mod h1:T9YF2M40nIgbVgp3rreNmTged+9HrbNTIQf1PsaIiTA=\ngithub.com/fogleman/gg v1.2.1-0.20190220221249-0403632d5b90/go.mod h1:R/bRT+9gY/C5z7JzPU0zXsXHKM4/ayA+zqcVNZzPa1k=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/fsnotify/fsnotify v1.4.9/go.mod h1:znqG4EE+3YCdAaPaxE2ZRY/06pZUdp0tY4IgpuI1SZQ=\ngithub.com/gavv/httpexpect v2.0.0+incompatible/go.mod h1:x+9tiU1YnrOvnB725RkpoLv1M62hOWzwo5OXotisrKc=\ngithub.com/getsentry/sentry-go v0.12.0 h1:era7g0re5iY13bHSdN/xMkyV+5zZppjRVQhZrXCaEIk=\ngithub.com/getsentry/sentry-go v0.12.0/go.mod h1:NSap0JBYWzHND8oMbyi0+XZhUalc1TBdRL1M71JZW2c=\ngithub.com/ghemawat/stream v0.0.0-20171120220530-696b145b53b9/go.mod h1:106OIgooyS7OzLDOpUGgm9fA3bQENb/cFSyyBmMoJDs=\ngithub.com/gin-contrib/sse v0.0.0-20190301062529-5545eab6dad3/go.mod h1:VJ0WA2NBN22VlZ2dKZQPAPnyWw5XTlK1KymzLKsr59s=\ngithub.com/gin-gonic/gin v1.4.0/go.mod h1:OW2EZn3DO8Ln9oIKOvM++LBO+5UPHJJDH72/q/3rZdM=\ngithub.com/go-check/check v0.0.0-20180628173108-788fd7840127/go.mod h1:9ES+weclKsC9YodN5RgxqK/VD9HM9JsCSh7rNhMZE98=\ngithub.com/go-errors/errors v1.0.1 h1:LUHzmkK3GUKUrL/1gfBUxAHzcev3apQlezX/+O7ma6w=\ngithub.com/go-errors/errors v1.0.1/go.mod h1:f4zRHt4oKfwPJE5k8C9vpYG+aDHdBFUsgrm6/TyX73Q=\ngithub.com/go-gl/glfw v0.0.0-20190409004039-e6da0acd62b1/go.mod h1:vR7hzQXu2zJy9AVAgeJqvqgH9Q5CA+iKCZ2gyEVpxRU=\ngithub.com/go-gl/glfw/v3.3/glfw v0.0.0-20200222043503-6f7a984d4dc4/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=\ngithub.com/go-martini/martini v0.0.0-20170121215854-22fa46961aab/go.mod h1:/P9AEU963A2AYjv4d1V5eVL1CQbEJq6aCNHDDjibzu8=\ngithub.com/gobwas/httphead v0.0.0-20180130184737-2c6c146eadee/go.mod h1:L0fX3K22YWvt/FAX9NnzrNzcI4wNYi9Yku4O0LKYflo=\ngithub.com/gobwas/pool v0.2.0/go.mod h1:q8bcK0KcYlCgd9e7WYLm9LpyS+YeLd8JVDW6WezmKEw=\ngithub.com/gobwas/ws v1.0.2/go.mod h1:szmBTxLgaFppYjEmNtny/v3w89xOydFnnZMcgRRu/EM=\ngithub.com/gogo/googleapis v0.0.0-20180223154316-0cd9801be74a/go.mod h1:gf4bu3Q80BeJ6H1S1vYPm8/ELATdvryBaNFGgqEef3s=\ngithub.com/gogo/googleapis v1.4.1/go.mod h1:2lpHqI5OcWCtVElxXnPt+s8oJvMpySlOyM6xDCrzib4=\ngithub.com/gogo/protobuf v1.2.0/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/gogo/protobuf v1.3.1/go.mod h1:SlYgWuQ5SjCEi6WLHjHCa1yvBfUnHcTbrrZtXPKa29o=\ngithub.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=\ngithub.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=\ngithub.com/gogo/status v1.1.0/go.mod h1:BFv9nrluPLmrS0EmGVvLaPNmRosr9KapBYd5/hpY1WM=\ngithub.com/golang-jwt/jwt v3.2.2+incompatible/go.mod h1:8pz2t5EyA70fFQQSrl6XZXzqecmYZeUEB8OUGHkxJ+I=\ngithub.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0/go.mod h1:E/TSTwGwJL78qG/PmXZO1EjYhfJinVAhrmmHX6Z8B9k=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=\ngithub.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=\ngithub.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=\ngithub.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=\ngithub.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=\ngithub.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=\ngithub.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=\ngithub.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=\ngithub.com/golang/protobuf v1.5.2/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/golang/snappy v0.0.3/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=\ngithub.com/golang/snappy v0.0.4 h1:yAGX7huGHXlcLOEtBnF4w7FQwA26wojNCwOYAEhLjQM=\ngithub.com/golang/snappy v0.0.4/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=\ngithub.com/gomodule/redigo v1.7.1-0.20190724094224-574c33c3df38/go.mod h1:B4C85qUVwatsJoIUNIfCRsp7qO0iAmpGFZ4EELWSbC4=\ngithub.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/btree v1.0.0 h1:0udJVsspx3VBr5FwtLhQQtuAsVc79tTq0ocGIPAU6qo=\ngithub.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.4/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.5 h1:Khx7svrCpmxxtHBq5j2mp/xVjsi8hQMfNLvJFAlrGgU=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-querystring v1.0.0/go.mod h1:odCYkC5MyYFN7vkCjXpyrEuKhc/BUO6wN/zVPAxq5ck=\ngithub.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/google/uuid v1.3.0 h1:t6JiXgmwXMjEs8VusXIJk2BXHsn+wx8BZdTaoZ5fu7I=\ngithub.com/google/uuid v1.3.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=\ngithub.com/gorilla/websocket v1.4.0/go.mod h1:E7qHFY5m1UJ88s3WnNqhKjPHQ0heANvMoAMk2YaljkQ=\ngithub.com/gorilla/websocket v1.4.1/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\ngithub.com/hashicorp/errwrap v1.0.0 h1:hLrqtEDnRye3+sgx6z4qVLNuviH3MR5aQ0ykNJa/UYA=\ngithub.com/hashicorp/errwrap v1.0.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=\ngithub.com/hashicorp/go-immutable-radix v1.0.0 h1:AKDB1HM5PWEA7i4nhcpwOrO2byshxBjXVn/J/3+z5/0=\ngithub.com/hashicorp/go-immutable-radix v1.0.0/go.mod h1:0y9vanUI8NX6FsYoO3zeMjhV/C5i9g4Q3DwcSNZ4P60=\ngithub.com/hashicorp/go-msgpack v0.5.3 h1:zKjpN5BK/P5lMYrLmBHdBULWbJ0XpYR+7NGzqkZzoD4=\ngithub.com/hashicorp/go-msgpack v0.5.3/go.mod h1:ahLV/dePpqEmjfWmKiqvPkv/twdG7iPBM1vqhUKIvfM=\ngithub.com/hashicorp/go-multierror v1.0.0 h1:iVjPR7a6H0tWELX5NxNe7bYopibicUzc7uPribsnS6o=\ngithub.com/hashicorp/go-multierror v1.0.0/go.mod h1:dHtQlpGsu+cZNNAkkCN/P3hoUDHhCYQXV3UM06sGGrk=\ngithub.com/hashicorp/go-sockaddr v1.0.0 h1:GeH6tui99pF4NJgfnhp+L6+FfobzVW3Ah46sLo0ICXs=\ngithub.com/hashicorp/go-sockaddr v1.0.0/go.mod h1:7Xibr9yA9JjQq1JpNB2Vw7kxv8xerXegt+ozgdvDeDU=\ngithub.com/hashicorp/go-uuid v1.0.0 h1:RS8zrF7PhGwyNPOtxSClXXj9HA8feRnJzgnI1RJCSnM=\ngithub.com/hashicorp/go-uuid v1.0.0/go.mod h1:6SBZvOh/SIDV7/2o3Jml5SYk/TvGqwFJ/bN7x4byOro=\ngithub.com/hashicorp/go-version v1.2.0/go.mod h1:fltr4n8CU8Ke44wwGCBoEymUuxUHl09ZGVZPK5anwXA=\ngithub.com/hashicorp/go-version v1.6.0/go.mod h1:fltr4n8CU8Ke44wwGCBoEymUuxUHl09ZGVZPK5anwXA=\ngithub.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/hashicorp/golang-lru v0.5.1 h1:0hERBMJE1eitiLkihrMvRVBYAkpHzc/J3QdDN+dAcgU=\ngithub.com/hashicorp/golang-lru v0.5.1/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=\ngithub.com/hashicorp/memberlist v0.3.1 h1:MXgUXLqva1QvpVEDQW1IQLG0wivQAtmFlHRQ+1vWZfM=\ngithub.com/hashicorp/memberlist v0.3.1/go.mod h1:MS2lj3INKhZjWNqd3N0m3J+Jxf3DAOnAH9VT3Sh9MUE=\ngithub.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=\ngithub.com/hydrogen18/memlistener v0.0.0-20141126152155-54553eb933fb/go.mod h1:qEIFzExnS6016fRpRfxrExeVn2gbClQA99gQhnIcdhE=\ngithub.com/hydrogen18/memlistener v0.0.0-20200120041712-dcc25e7acd91/go.mod h1:qEIFzExnS6016fRpRfxrExeVn2gbClQA99gQhnIcdhE=\ngithub.com/imkira/go-interpol v1.1.0/go.mod h1:z0h2/2T3XF8kyEPpRgJ3kmNv+C43p+I/CoI+jC3w2iA=\ngithub.com/inconshreveable/mousetrap v1.0.0/go.mod h1:PxqpIevigyE2G7u3NXJIT2ANytuPF1OarO4DADm73n8=\ngithub.com/iris-contrib/blackfriday v2.0.0+incompatible/go.mod h1:UzZ2bDEoaSGPbkg6SAB4att1aAwTmVIx/5gCVqeyUdI=\ngithub.com/iris-contrib/go.uuid v2.0.0+incompatible/go.mod h1:iz2lgM/1UnEf1kP0L/+fafWORmlnuysV2EMP8MW+qe0=\ngithub.com/iris-contrib/i18n v0.0.0-20171121225848-987a633949d0/go.mod h1:pMCz62A0xJL6I+umB2YTlFRwWXaDFA0jy+5HzGiJjqI=\ngithub.com/iris-contrib/jade v1.1.3/go.mod h1:H/geBymxJhShH5kecoiOCSssPX7QWYH7UaeZTSWddIk=\ngithub.com/iris-contrib/pongo2 v0.0.1/go.mod h1:Ssh+00+3GAZqSQb30AvBRNxBx7rf0GqwkjqxNd0u65g=\ngithub.com/iris-contrib/schema v0.0.1/go.mod h1:urYA3uvUNG1TIIjOSCzHr9/LmbQo8LrOcOqfqxa4hXw=\ngithub.com/json-iterator/go v1.1.6/go.mod h1:+SdeFBvtyEkXs7REEP0seUULqWtbJapLOCVDaaPEHmU=\ngithub.com/json-iterator/go v1.1.9/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=\ngithub.com/jtolds/gls v4.20.0+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=\ngithub.com/juju/errors v0.0.0-20181118221551-089d3ea4e4d5/go.mod h1:W54LbzXuIE0boCoNJfwqpmkKJ1O4TCTZMetAt6jGk7Q=\ngithub.com/juju/loggo v0.0.0-20180524022052-584905176618/go.mod h1:vgyd7OREkbtVEN/8IXZe5Ooef3LQePvuBm9UWj6ZL8U=\ngithub.com/juju/testing v0.0.0-20180920084828-472a3e8b2073/go.mod h1:63prj8cnj0tU0S9OHjGJn+b1h0ZghCndfnbQolrYTwA=\ngithub.com/jung-kurt/gofpdf v1.0.3-0.20190309125859-24315acbbda5/go.mod h1:7Id9E/uU8ce6rXgefFLlgrJj/GYY22cpxn+r32jIOes=\ngithub.com/k0kubun/colorstring v0.0.0-20150214042306-9440f1994b88/go.mod h1:3w7q1U84EfirKl04SVQ/s7nPm1ZPhiXd34z40TNz36k=\ngithub.com/kataras/golog v0.0.9/go.mod h1:12HJgwBIZFNGL0EJnMRhmvGA0PQGx8VFwrZtM4CqbAk=\ngithub.com/kataras/golog v0.0.10/go.mod h1:yJ8YKCmyL+nWjERB90Qwn+bdyBZsaQwU3bTVFgkFIp8=\ngithub.com/kataras/iris/v12 v12.0.1/go.mod h1:udK4vLQKkdDqMGJJVd/msuMtN6hpYJhg/lSzuxjhO+U=\ngithub.com/kataras/iris/v12 v12.1.8/go.mod h1:LMYy4VlP67TQ3Zgriz8RE2h2kMZV2SgMYbq3UhfoFmE=\ngithub.com/kataras/neffos v0.0.10/go.mod h1:ZYmJC07hQPW67eKuzlfY7SO3bC0mw83A3j6im82hfqw=\ngithub.com/kataras/neffos v0.0.14/go.mod h1:8lqADm8PnbeFfL7CLXh1WHw53dG27MC3pgi2R1rmoTE=\ngithub.com/kataras/pio v0.0.0-20190103105442-ea782b38602d/go.mod h1:NV88laa9UiiDuX9AhMbDPkGYSPugBOV6yTZB1l2K9Z0=\ngithub.com/kataras/pio v0.0.2/go.mod h1:hAoW0t9UmXi4R5Oyq5Z4irTbaTsOemSrDGUtaTl7Dro=\ngithub.com/kataras/sitemap v0.0.5/go.mod h1:KY2eugMKiPwsJgx7+U103YZehfvNGOXURubcGyk0Bz8=\ngithub.com/kisielk/errcheck v1.2.0/go.mod h1:/BMXB+zMLi60iA8Vv6Ksmxu/1UDYcXs4uQLJ+jE2L00=\ngithub.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/klauspost/compress v1.8.2/go.mod h1:RyIbtBH6LamlWaDj8nUwkbUhJ87Yi3uG0guNDohfE1A=\ngithub.com/klauspost/compress v1.9.0/go.mod h1:RyIbtBH6LamlWaDj8nUwkbUhJ87Yi3uG0guNDohfE1A=\ngithub.com/klauspost/compress v1.9.7/go.mod h1:RyIbtBH6LamlWaDj8nUwkbUhJ87Yi3uG0guNDohfE1A=\ngithub.com/klauspost/compress v1.11.7/go.mod h1:aoV0uJVorq1K+umq18yTdKaF57EivdYsUV+/s2qKfXs=\ngithub.com/klauspost/compress v1.11.13 h1:eSvu8Tmq6j2psUJqJrLcWH6K3w5Dwc+qipbaA6eVEN4=\ngithub.com/klauspost/compress v1.11.13/go.mod h1:aoV0uJVorq1K+umq18yTdKaF57EivdYsUV+/s2qKfXs=\ngithub.com/klauspost/cpuid v1.2.1/go.mod h1:Pj4uuM528wm8OyEC2QMXAi2YiTZ96dNQPGgoMS4s3ek=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pretty v0.3.0 h1:WgNl7dwNpEZ6jJ9k1snq4pZsg7DOEN8hP9Xw0Tsjwk0=\ngithub.com/kr/pretty v0.3.0/go.mod h1:640gp4NfQd8pI5XOwp5fnNeVWj67G7CFk/SaSQn7NBk=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/labstack/echo/v4 v4.1.11/go.mod h1:i541M3Fj6f76NZtHSj7TXnyM8n2gaodfvfxNnFqi74g=\ngithub.com/labstack/echo/v4 v4.5.0/go.mod h1:czIriw4a0C1dFun+ObrXp7ok03xON0N1awStJ6ArI7Y=\ngithub.com/labstack/gommon v0.3.0/go.mod h1:MULnywXg0yavhxWKc+lOruYdAhDwPK9wf0OL7NoOu+k=\ngithub.com/lni/goutils v1.4.0 h1:e1tNN+4zsbTpNvhG5cxirkH9Pdz96QAZ2j6+5tmjvqg=\ngithub.com/lni/goutils v1.4.0/go.mod h1:LIHvF0fflR+zyXUQFQOiHPpKANf3UIr7DFIv5CBPOoU=\ngithub.com/lni/vfs v0.2.1-0.20220616104132-8852fd867376 h1:jX9CoRWNPwrZ2yY3RJFTSwa49qDQqtXglrCByGdQGZg=\ngithub.com/lni/vfs v0.2.1-0.20220616104132-8852fd867376/go.mod h1:LOatfyR8Xeej1jbXybwYGVfCccR0u+BQRG9xg7BD7xo=\ngithub.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=\ngithub.com/mattn/go-colorable v0.1.2/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=\ngithub.com/mattn/go-colorable v0.1.8/go.mod h1:u6P/XSegPjTcexA+o6vUJrdnUu04hMope9wVRipJSqc=\ngithub.com/mattn/go-colorable v0.1.11/go.mod h1:u5H1YNBxpqRaxsYJYSkiCWKzEfiAb1Gb520KVy5xxl4=\ngithub.com/mattn/go-isatty v0.0.7/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=\ngithub.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=\ngithub.com/mattn/go-isatty v0.0.9/go.mod h1:YNRxwqDuOph6SZLI9vUUz6OYw3QyUt7WiY2yME+cCiQ=\ngithub.com/mattn/go-isatty v0.0.12/go.mod h1:cbi8OIDigv2wuxKPP5vlRcQ1OAZbq2CE4Kysco4FUpU=\ngithub.com/mattn/go-isatty v0.0.14/go.mod h1:7GGIvUiUoEMVVmxf/4nioHXj79iQHKdU27kJ6hsGG94=\ngithub.com/mattn/goveralls v0.0.2/go.mod h1:8d1ZMHsd7fW6IRPKQh46F2WRpyib5/X4FOpevwGNQEw=\ngithub.com/mediocregopher/mediocre-go-lib v0.0.0-20181029021733-cb65787f37ed/go.mod h1:dSsfyI2zABAdhcbvkXqgxOxrCsbYeHCPgrZkku60dSg=\ngithub.com/mediocregopher/radix/v3 v3.3.0/go.mod h1:EmfVyvspXz1uZEyPBMyGK+kjWiKQGvsUt6O3Pj+LDCQ=\ngithub.com/mediocregopher/radix/v3 v3.4.2/go.mod h1:8FL3F6UQRXHXIBSPUs5h0RybMF8i4n7wVopoX3x7Bv8=\ngithub.com/microcosm-cc/bluemonday v1.0.2/go.mod h1:iVP4YcDBq+n/5fb23BhYFvIMq/leAFZyRl6bYmGDlGc=\ngithub.com/miekg/dns v1.1.26 h1:gPxPSwALAeHJSjarOs00QjVdV9QoBvc1D2ujQUr5BzU=\ngithub.com/miekg/dns v1.1.26/go.mod h1:bPDLeHnStXmXAq1m/Ch/hvfNHr14JKNPMBo3VZKjuso=\ngithub.com/mitchellh/go-homedir v1.1.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=\ngithub.com/mitchellh/mapstructure v1.1.2/go.mod h1:FVVH3fgwuzCH5S8UJGiWEs2h04kUh9fWfEaFds41c1Y=\ngithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/modern-go/reflect2 v1.0.1/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/moul/http2curl v1.0.0/go.mod h1:8UbvGypXm98wA/IqH45anm5Y2Z6ep6O31QGOAZ3H0fQ=\ngithub.com/nats-io/jwt v0.3.0/go.mod h1:fRYCDE99xlTsqUzISS1Bi75UBJ6ljOJQOAAu5VglpSg=\ngithub.com/nats-io/nats.go v1.8.1/go.mod h1:BrFz9vVn0fU3AcH9Vn4Kd7W0NpJ651tD5omQ3M8LwxM=\ngithub.com/nats-io/nats.go v1.9.1/go.mod h1:ZjDU1L/7fJ09jvUSRVBR2e7+RnLiiIQyqyzEE/Zbp4w=\ngithub.com/nats-io/nkeys v0.0.2/go.mod h1:dab7URMsZm6Z/jp9Z5UGa87Uutgc2mVpXLC4B7TDb/4=\ngithub.com/nats-io/nkeys v0.1.0/go.mod h1:xpnFELMwJABBLVhffcfd1MZx6VsNRFpEugbxziKVo7w=\ngithub.com/nats-io/nuid v1.0.1/go.mod h1:19wcPz3Ph3q0Jbyiqsd0kePYG7A95tJPxeL+1OSON2c=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e h1:fD57ERR4JtEqsWbfPhv4DMiApHyliiK5xCTNVSPiaAs=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e/go.mod h1:zD1mROLANZcx1PVRCS0qkT7pwLkGfwJo4zjcN/Tysno=\ngithub.com/nxadm/tail v1.4.4/go.mod h1:kenIhsEOeOJmVchQTgglprH7qJGnHDVpk1VPCcaMI8A=\ngithub.com/onsi/ginkgo v1.6.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo v1.10.3/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo v1.12.1/go.mod h1:zj2OWP4+oCPe1qIXoGWkgMRwljMUYCdkwsT2108oapk=\ngithub.com/onsi/ginkgo v1.13.0/go.mod h1:+REjRxOmWfHCjfv9TTWB1jD1Frx4XydAD3zm1lskyM0=\ngithub.com/onsi/gomega v1.7.1/go.mod h1:XdKZgCCFLUoM/7CFJVPcG8C1xQ1AJ0vpAezJrB7JYyY=\ngithub.com/onsi/gomega v1.10.1/go.mod h1:iN09h71vgCQne3DLsj+A5owkum+a2tYe+TOCB1ybHNo=\ngithub.com/pascaldekloe/goe v0.0.0-20180627143212-57f6aae5913c h1:Lgl0gzECD8GnQ5QCWA8o6BtfL6mDH5rQgM4/fX3avOs=\ngithub.com/pascaldekloe/goe v0.0.0-20180627143212-57f6aae5913c/go.mod h1:lzWF7FIEvWOWxwDKqyGYQf6ZUaNfKdP144TG7ZOy1lc=\ngithub.com/pelletier/go-toml v1.2.0/go.mod h1:5z9KED0ma1S8pY6P1sdut58dfprrGBbd/94hg7ilaic=\ngithub.com/pierrec/lz4/v4 v4.1.14 h1:+fL8AQEZtz/ijeNnpduH0bROTu0O3NZAlPjQxGn8LwE=\ngithub.com/pierrec/lz4/v4 v4.1.14/go.mod h1:gZWDp/Ze/IJXGXf23ltt2EXimqmTUXEy0GFuRQyBid4=\ngithub.com/pingcap/errors v0.11.4 h1:lFuQV/oaUMGcD2tqt+01ROSmJs75VG1ToEOkZIZ4nE4=\ngithub.com/pingcap/errors v0.11.4/go.mod h1:Oi8TUi2kEtXXLMJk9l1cGmz20kV3TaQ0usTwv5KuLY8=\ngithub.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/rogpeppe/go-internal v1.6.1/go.mod h1:xXDCJY+GAPziupqXw64V24skbSoqbTEfhy4qGm1nDQc=\ngithub.com/rogpeppe/go-internal v1.8.1 h1:geMPLpDpQOgVyCg5z5GoRwLHepNdb71NXb67XFkP+Eg=\ngithub.com/rogpeppe/go-internal v1.8.1/go.mod h1:JeRgkft04UBgHMgCIwADu4Pn6Mtm5d4nPKWu0nJ5d+o=\ngithub.com/russross/blackfriday v1.5.2/go.mod h1:JO/DiYxRf+HjHt06OyowR9PTA263kcR/rfWxYHBV53g=\ngithub.com/ryanuber/columnize v2.1.0+incompatible/go.mod h1:sm1tb6uqfes/u+d4ooFouqFdy9/2g9QGwK3SQygK0Ts=\ngithub.com/schollz/closestmatch v2.1.0+incompatible/go.mod h1:RtP1ddjLong6gTkbtmuhtR2uUrrJOpYzYRvbcPAid+g=\ngithub.com/sclevine/agouti v3.0.0+incompatible/go.mod h1:b4WX9W9L1sfQKXeJf1mUTLZKJ48R1S7H23Ji7oFO5Bw=\ngithub.com/sean-/seed v0.0.0-20170313163322-e2103e2c3529 h1:nn5Wsu0esKSJiIVhscUtVbo7ada43DJhG55ua/hjS5I=\ngithub.com/sean-/seed v0.0.0-20170313163322-e2103e2c3529/go.mod h1:DxrIzT+xaE7yg65j358z/aeFdxmN0P9QXhEzd20vsDc=\ngithub.com/sergi/go-diff v1.0.0/go.mod h1:0CfEIISq7TuYL3j771MWULgwwjU+GofnZX9QAmXWZgo=\ngithub.com/sergi/go-diff v1.1.0/go.mod h1:STckp+ISIX8hZLjrqAeVduY0gWCT9IjLuqbuNXdaHfM=\ngithub.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=\ngithub.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=\ngithub.com/smartystreets/goconvey v1.6.4/go.mod h1:syvi0/a8iFYH4r/RixwvyeAJjdLS9QV7WQ/tjFTllLA=\ngithub.com/spf13/afero v1.1.2/go.mod h1:j4pytiNVoe2o6bmDsKpLACNPDBIoEAkihy7loJ1B0CQ=\ngithub.com/spf13/cast v1.3.0/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=\ngithub.com/spf13/cobra v0.0.5/go.mod h1:3K3wKZymM7VvHMDS9+Akkh4K60UwM26emMESw8tLCHU=\ngithub.com/spf13/jwalterweatherman v1.0.0/go.mod h1:cQK4TGJAtQXfYWX+Ddv3mKDzgVb68N+wFjFa4jdeBTo=\ngithub.com/spf13/pflag v1.0.3/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=\ngithub.com/spf13/viper v1.3.2/go.mod h1:ZiWeW+zYFKm7srdB9IoDzzZXaJaI5eL9QjNiN/DMA2s=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=\ngithub.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/ugorji/go v1.1.4/go.mod h1:uQMGLiO92mf5W77hV/PUCpI3pbzQx3CRekS0kk+RGrc=\ngithub.com/ugorji/go v1.1.7/go.mod h1:kZn38zHttfInRq0xu/PH0az30d+z6vm202qpg1oXVMw=\ngithub.com/ugorji/go/codec v0.0.0-20181204163529-d75b2dcb6bc8/go.mod h1:VFNgLljTbGfSG7qAOspJ7OScBnGdDN/yBr0sguwnwf0=\ngithub.com/ugorji/go/codec v1.1.7/go.mod h1:Ax+UKWsSmolVDwsd+7N3ZtXu+yMGCf907BLYF3GoBXY=\ngithub.com/urfave/negroni v1.0.0/go.mod h1:Meg73S6kFm/4PpbYdq35yYWoCZ9mS/YSx+lKnmiohz4=\ngithub.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=\ngithub.com/valyala/fasthttp v1.6.0/go.mod h1:FstJa9V+Pj9vQ7OJie2qMHdwemEDaDiSdBnvPM1Su9w=\ngithub.com/valyala/fastrand v1.1.0 h1:f+5HkLW4rsgzdNoleUOB69hyT9IlD2ZQh9GyDMfb5G8=\ngithub.com/valyala/fastrand v1.1.0/go.mod h1:HWqCzkrkg6QXT8V2EXWvXCoow7vLwOFN002oeRzjapQ=\ngithub.com/valyala/fasttemplate v1.0.1/go.mod h1:UQGH1tvbgY+Nz5t2n7tXsz52dQxojPUpymEIMZ47gx8=\ngithub.com/valyala/fasttemplate v1.2.1/go.mod h1:KHLXt3tVN2HBp8eijSv/kGJopbvo7S+qRAEEKiv+SiQ=\ngithub.com/valyala/histogram v1.2.0 h1:wyYGAZZt3CpwUiIb9AU/Zbllg1llXyrtApRS815OLoQ=\ngithub.com/valyala/histogram v1.2.0/go.mod h1:Hb4kBwb4UxsaNbbbh+RRz8ZR6pdodR57tzWUS3BUzXY=\ngithub.com/valyala/tcplisten v0.0.0-20161114210144-ceec8f93295a/go.mod h1:v3UYOV9WzVtRmSR+PDvWpU/qWl4Wa5LApYYX4ZtKbio=\ngithub.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f/go.mod h1:N2zxlSyiKSe5eX1tZViRH5QA0qijqEDrYZiPEAiq3wU=\ngithub.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415/go.mod h1:GwrjFmJcFw6At/Gs6z4yjiIwzuJ1/+UwLxMQDVQXShQ=\ngithub.com/xeipuuv/gojsonschema v1.2.0/go.mod h1:anYRn/JVcOK2ZgGU+IjEV4nwlhoK5sQluxsYJ78Id3Y=\ngithub.com/xordataexchange/crypt v0.0.3-0.20170626215501-b2862e3d0a77/go.mod h1:aYKd//L2LvnjZzWKhF00oedf4jCCReLcmhLdhm1A27Q=\ngithub.com/yalp/jsonpath v0.0.0-20180802001716-5cc68e5049a0/go.mod h1:/LWChgwKmvncFJFHJ7Gvn9wZArjbV5/FppcK2fKk/tI=\ngithub.com/yudai/gojsondiff v1.0.0/go.mod h1:AY32+k2cwILAkW1fbgxQ5mUmMiZFgLIV+FBNExI05xg=\ngithub.com/yudai/golcs v0.0.0-20170316035057-ecda9a501e82/go.mod h1:lgjkn3NuSvDfVJdfcVVdX+jpBxNmX4rDAzaS45IcYoM=\ngithub.com/yudai/pp v2.0.1+incompatible/go.mod h1:PuxR/8QJ7cyCkFp/aUDS+JY727OFEZkTdatxwunjIkc=\ngithub.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.3.5/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=\ngolang.org/x/crypto v0.0.0-20181203042331-505ab145d0a9/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190510104115-cbcb75029529/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190701094942-4def268fd1a4/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190923035154-9ee001bba392/go.mod h1:/lpIB1dKB+9EgE3H3cr1v9wB50oz8l4C4h62xy7jSTY=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20191227163750-53104e6ec876/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20210322153248-0c34fe9e7dc2/go.mod h1:T9bdIzuCu7OtxOm1hfPfRQxPLYneinmdGuTeoZ9dtd4=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.13.0 h1:mvySKfSWJ+UKUii46M40LOvyWfN0s2U+46/jDd0e6Ck=\ngolang.org/x/crypto v0.13.0/go.mod h1:y6Z2r+Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliYc=\ngolang.org/x/exp v0.0.0-20180321215751-8460e604b9de/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20180807140117-3d87b88a115f/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190125153040-c74c464bbbf2/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20191030013958-a1ab85dbe136/go.mod h1:JXzH8nQsPlswgeRAPE3MuO9GYsAcnJvJ4vnMwN/5qkY=\ngolang.org/x/exp v0.0.0-20200513190911-00229845015e h1:rMqLP+9XLy+LdbCXHjJHAmTfXCr93W7oruWA6Hq1Alc=\ngolang.org/x/exp v0.0.0-20200513190911-00229845015e/go.mod h1:4M0jN8W1tt0AVLNr8HDosyJCDCDuyL9N9+3m7wDWgKw=\ngolang.org/x/image v0.0.0-20180708004352-c73c2afc3b81/go.mod h1:ux5Hcp/YLpHSI86hEcLt0YII63i6oz57MZXIpbrjZUs=\ngolang.org/x/image v0.0.0-20190227222117-0694c2d4d067/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=\ngolang.org/x/image v0.0.0-20190802002840-cff245a6509b/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20210508222113-6edffad5e616/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/mobile v0.0.0-20190719004257-d2bd2a29d028/go.mod h1:E/iHnbuqvinMTCcRqshq8CkpyQDoeVncDDYHnLhea+o=\ngolang.org/x/mod v0.1.0/go.mod h1:0QHyrYULN0/3qlju5TqG8bIK38QM8yzMo5ekMj3DlcY=\ngolang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=\ngolang.org/x/mod v0.1.1-0.20191107180719-034126e5016b/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=\ngolang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181220203305-927f97764cc3/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190327091125-710a502c58a2/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190503192946-f4e77d36d62c/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190827160401-ba9fcec4b297/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190923162816-aa69164e4478/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20191209160850-c0dbc17a3553/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200520004742-59133d7f0dd7/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20210405180319-a5a99cb37ef4/go.mod h1:p54w0d4576C0XHj96bSt6lcn1PtDYWL6XObtHCRCNQM=\ngolang.org/x/net v0.0.0-20211008194852-3b03d305991f/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.15.0 h1:ugBLEUaxABaB5AJqW9enI0ACdci2RUd4eP51NTBvuJ8=\ngolang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0 h1:wsuoTGHzEhffawBOhz5CYhcrV4IdKZbEyZjBMuTp12o=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181205085412-a5c9d58dba9a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190312061237-fead79001313/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190626221950-04f50cda93cb/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190813064441-fde4db37ae7a/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190904154756-749cb33beabd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190922100055-0a153f010e69/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190924154521-2837fb4f24fe/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191001151750-bb3f8db39f24/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191005200804-aed5e4c7ecf9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191120155948-bd437916bb0e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200116001909-b77594299b42/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200519105757-fe76b779f299/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210403161142-5e06dd20ab57/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210909193231-528a39cd75f3/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210927094055-39ccf1dd6fa6/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20211007075335-d3039528d8ac/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220209214540-3681064d5158/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.12.0 h1:CM0HF96J0hcLAwsHPJZjfdNzs0gftsLfgKt57wWHJ0o=\ngolang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.5/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/time v0.0.0-20201208040808-7e3f01d25324/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/tools v0.0.0-20180525024113-a5b4c53f6e8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20181030221726-6c7e314b6563/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20181221001348-537d06c36207/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190206041539-40960b6deb8e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190327201419-c70d86f8b7cf/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190328211700-ab21143f2384/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190907020128-2ca718005c18/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191012152004-8de300cfc20a/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200207183749-b753a1ba74fa/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.1.3/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1 h1:go1bK/D/BFZV2I8cIQd1NKEZ+0owSTG1fDTci4IqFcE=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngonum.org/v1/gonum v0.0.0-20180816165407-929014505bf4/go.mod h1:Y+Yx5eoAFn32cQvJDxZx5Dpnq+c3wtXuadVZAcxbbBo=\ngonum.org/v1/gonum v0.8.2 h1:CCXrcPKiGGotvnN6jfUsKk4rRqm7q09/YbKb5xCEvtM=\ngonum.org/v1/gonum v0.8.2/go.mod h1:oe/vMfY3deqTw+1EZJhuvEW2iwGF1bW9wwu7XCu0+v0=\ngonum.org/v1/netlib v0.0.0-20190313105609-8cb42192e0e0/go.mod h1:wa6Ws7BG/ESfp6dHfk7C6KdzKA7wR7u/rKwOGE66zvw=\ngonum.org/v1/plot v0.0.0-20190515093506-e2840ee46a6b/go.mod h1:Wt8AAjI+ypCyYX3nZBvf6cAIx93T+c/OS2HFAYskSZc=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/genproto v0.0.0-20180518175338-11a468237815/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=\ngoogle.golang.org/genproto v0.0.0-20210624195500-8bfb893ecb84/go.mod h1:SzzZ/N+nwJDaO1kznhnlzqS8ocJICar6hYhVyhi++24=\ngoogle.golang.org/grpc v1.12.0/go.mod h1:yo6s7OP7yaDglbqo1J04qKzAhqBH6lvTonzMVmEdcZw=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=\ngoogle.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=\ngoogle.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=\ngoogle.golang.org/grpc v1.29.1/go.mod h1:itym6AZVZYACWQqET3MqgPpjcuV5QH3BxFS3IjizoKk=\ngoogle.golang.org/grpc v1.38.0/go.mod h1:NREThFqKR1f3iQ6oBuvc5LadQuXVGo9rkm5ZGrQdJfM=\ngoogle.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=\ngoogle.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=\ngoogle.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=\ngoogle.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=\ngoogle.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=\ngoogle.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f h1:BLraFXnmrev5lT+xlilqcH8XK9/i0At2xKjWk4p6zsU=\ngopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=\ngopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=\ngopkg.in/go-playground/assert.v1 v1.2.1/go.mod h1:9RXL0bg/zibRAgZUYszZSwO/z8Y/a8bDuhia5mkpMnE=\ngopkg.in/go-playground/validator.v8 v8.18.2/go.mod h1:RX2a/7Ha8BgOhfk7j780h4/u/RRjR0eouCJSH80/M2Y=\ngopkg.in/ini.v1 v1.51.1/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=\ngopkg.in/mgo.v2 v2.0.0-20180705113604-9856a29383ce/go.mod h1:yeKp02qBN3iKW1OzL3MGk2IdtZzaj7SFntXj72NppTA=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v3 v3.0.0-20191120175047-4206685974f2/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nrsc.io/pdf v0.1.1/go.mod h1:n8OzWcQ6Sp37PL01nO98y4iUCRdTGarVfzxY20ICaU4=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "issue_template.md",
          "type": "blob",
          "size": 0.25,
          "content": "> Note: for reported bugs, please fill in the following details. bug reports without detailed steps on how to reproduce will be automatically closed. \n\n### Dragonboat version\n\n### Expected behavior\n\n### Actual behavior\n\n### Steps to reproduce the behavior\n"
        },
        {
          "name": "logger",
          "type": "tree",
          "content": null
        },
        {
          "name": "monkey.go",
          "type": "blob",
          "size": 4.810546875,
          "content": "// Copyright 2017-2019 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build dragonboat_monkeytest\n// +build dragonboat_monkeytest\n\npackage dragonboat\n\nimport (\n\t\"sync/atomic\"\n\n\t\"github.com/lni/dragonboat/v4/config\"\n\t\"github.com/lni/dragonboat/v4/internal/server\"\n\t\"github.com/lni/dragonboat/v4/internal/transport\"\n\t\"github.com/lni/dragonboat/v4/internal/vfs\"\n\t\"github.com/lni/dragonboat/v4/raftio\"\n)\n\nfunc ApplyMonkeySettings() {\n\ttransport.ApplyMonkeySettings()\n}\n\n//\n// code here is used in testing only.\n//\n\n// MemFS is a in memory vfs intended to be used in testing. User applications\n// can usually ignore such vfs related types and fields.\ntype MemFS = vfs.MemFS\n\n// GetTestFS returns a vfs instance that can be used in testing. User\n// applications can usually ignore such vfs related types and fields.\nfunc GetTestFS() config.IFS {\n\treturn vfs.GetTestFS()\n}\n\n// Shards returns a list of raft nodes managed by the nodehost instance.\nfunc (nh *NodeHost) Shards() []*node {\n\tresult := make([]*node, 0)\n\tnh.mu.RLock()\n\tnh.mu.shards.Range(func(k, v interface{}) bool {\n\t\tresult = append(result, v.(*node))\n\t\treturn true\n\t})\n\tnh.mu.RUnlock()\n\treturn result\n}\n\nfunc SetPendingProposalShards(sz uint64) {\n\tpendingProposalShards = sz\n}\n\nfunc SetTaskBatchSize(sz uint64) {\n\ttaskBatchSize = sz\n}\n\nfunc SetIncomingProposalsMaxLen(sz uint64) {\n\tincomingProposalsMaxLen = sz\n}\n\nfunc SetIncomingReadIndexMaxLen(sz uint64) {\n\tincomingReadIndexMaxLen = sz\n}\n\nfunc SetReceiveQueueLen(v uint64) {\n\treceiveQueueLen = v\n}\n\nfunc (nh *NodeHost) Stopped() bool {\n\treturn atomic.LoadInt32(&nh.closed) != 0\n}\n\nfunc (nh *NodeHost) SetTransportDropBatchHook(f transport.SendMessageBatchFunc) {\n\tnh.transport.(*transport.Transport).SetPreSendBatchHook(f)\n}\n\nfunc (nh *NodeHost) SetPreStreamChunkSendHook(f transport.StreamChunkSendFunc) {\n\tnh.transport.(*transport.Transport).SetPreStreamChunkSendHook(f)\n}\n\nfunc (nh *NodeHost) GetLogDB() raftio.ILogDB {\n\treturn nh.mu.logdb\n}\n\nfunc (n *node) GetLastApplied() uint64 {\n\treturn n.sm.GetLastApplied()\n}\n\nfunc (n *node) DumpRaftInfoToLog() {\n\tn.raftMu.Lock()\n\tdefer n.raftMu.Unlock()\n\tn.dumpRaftInfoToLog()\n}\n\nfunc (n *node) IsLeader() bool {\n\treturn n.isLeader()\n}\n\nfunc (n *node) IsFollower() bool {\n\treturn n.isFollower()\n}\n\nfunc (n *node) GetStateMachineHash() uint64 {\n\treturn n.getStateMachineHash()\n}\n\nfunc (n *node) GetSessionHash() uint64 {\n\treturn n.getSessionHash()\n}\n\nfunc (n *node) GetMembershipHash() uint64 {\n\treturn n.getMembershipHash()\n}\n\nfunc (n *node) GetRateLimiter() *server.InMemRateLimiter {\n\treturn n.p.GetRateLimiter()\n}\n\nfunc (n *node) GetInMemLogSize() uint64 {\n\tn.raftMu.Lock()\n\tdefer n.raftMu.Unlock()\n\treturn n.p.GetInMemLogSize()\n}\n\nfunc (n *node) getStateMachineHash() uint64 {\n\tif v, err := n.sm.GetHash(); err != nil {\n\t\tpanic(err)\n\t} else {\n\t\treturn v\n\t}\n}\n\nfunc (n *node) getSessionHash() uint64 {\n\treturn n.sm.GetSessionHash()\n}\n\nfunc (n *node) getMembershipHash() uint64 {\n\treturn n.sm.GetMembershipHash()\n}\n\nfunc (n *node) dumpRaftInfoToLog() {\n\taddrMap := make(map[uint64]string)\n\tm := n.sm.GetMembership()\n\tfor replicaID := range m.Addresses {\n\t\tif replicaID == n.replicaID {\n\t\t\taddrMap[replicaID] = n.getRaftAddress()\n\t\t} else {\n\t\t\tv, _, err := n.nodeRegistry.Resolve(n.shardID, replicaID)\n\t\t\tif err == nil {\n\t\t\t\taddrMap[replicaID] = v\n\t\t\t}\n\t\t}\n\t}\n\tn.p.DumpRaftInfoToLog(addrMap)\n}\n\n// PartitionNode puts the node into test partition mode. All connectivity to\n// the outside world should be stopped.\nfunc (nh *NodeHost) PartitionNode() {\n\tplog.Infof(\"entered partition test mode\")\n\tatomic.StoreInt32(&nh.partitioned, 1)\n}\n\n// RestorePartitionedNode removes the node from test partition mode. No other\n// change is going to be made on the local node. It is up to the local node it\n// self to repair/restore any other state.\nfunc (nh *NodeHost) RestorePartitionedNode() {\n\tplog.Infof(\"restored from partition test mode\")\n\tatomic.StoreInt32(&nh.partitioned, 0)\n}\n\n// IsPartitioned indicates whether the local node is in partitioned mode. This\n// function is only implemented in the monkey test build mode. It always\n// returns false in a regular build.\nfunc (nh *NodeHost) IsPartitioned() bool {\n\treturn nh.isPartitioned()\n}\n\n// IsPartitioned indicates whether the local node is in partitioned mode.\nfunc (nh *NodeHost) isPartitioned() bool {\n\treturn atomic.LoadInt32(&nh.partitioned) == 1\n}\n"
        },
        {
          "name": "monkeynoop.go",
          "type": "blob",
          "size": 0.8203125,
          "content": "// Copyright 2017-2019 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build !dragonboat_monkeytest\n// +build !dragonboat_monkeytest\n\npackage dragonboat\n\nimport (\n\t\"sync/atomic\"\n)\n\nfunc (nh *NodeHost) isPartitioned() bool {\n\treturn atomic.LoadInt32(&nh.partitioned) == 1\n}\n"
        },
        {
          "name": "node.go",
          "type": "blob",
          "size": 41.4404296875,
          "content": "// Copyright 2017-2021 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dragonboat\n\nimport (\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"github.com/cockroachdb/errors\"\n\t\"github.com/lni/goutils/logutil\"\n\n\t\"github.com/lni/dragonboat/v4/client\"\n\t\"github.com/lni/dragonboat/v4/config\"\n\t\"github.com/lni/dragonboat/v4/internal/fileutil\"\n\t\"github.com/lni/dragonboat/v4/internal/logdb\"\n\t\"github.com/lni/dragonboat/v4/internal/raft\"\n\t\"github.com/lni/dragonboat/v4/internal/rsm\"\n\t\"github.com/lni/dragonboat/v4/internal/server\"\n\t\"github.com/lni/dragonboat/v4/internal/settings\"\n\t\"github.com/lni/dragonboat/v4/internal/transport\"\n\t\"github.com/lni/dragonboat/v4/raftio\"\n\tpb \"github.com/lni/dragonboat/v4/raftpb\"\n\tsm \"github.com/lni/dragonboat/v4/statemachine\"\n)\n\nvar (\n\tincomingProposalsMaxLen = settings.Soft.IncomingProposalQueueLength\n\tincomingReadIndexMaxLen = settings.Soft.IncomingReadIndexQueueLength\n\tsyncTaskInterval        = settings.Soft.SyncTaskInterval\n\tlazyFreeCycle           = settings.Soft.LazyFreeCycle\n)\n\ntype pipeline interface {\n\tsetCloseReady(*node)\n\tsetStepReady(shardID uint64)\n\tsetCommitReady(shardID uint64)\n\tsetApplyReady(shardID uint64)\n\tsetStreamReady(shardID uint64)\n\tsetSaveReady(shardID uint64)\n\tsetRecoverReady(shardID uint64)\n}\n\ntype logDBMetrics struct {\n\tbusy int32\n}\n\nfunc (l *logDBMetrics) update(busy bool) {\n\tv := int32(0)\n\tif busy {\n\t\tv = int32(1)\n\t}\n\tatomic.StoreInt32(&l.busy, v)\n}\n\nfunc (l *logDBMetrics) isBusy() bool {\n\treturn atomic.LoadInt32(&l.busy) != 0\n}\n\ntype leaderInfo struct {\n\tleaderID uint64\n\tterm     uint64\n}\n\ntype node struct {\n\tshardInfo             atomic.Value\n\tleaderInfo            atomic.Value\n\tnodeRegistry          raftio.INodeRegistry\n\tlogdb                 raftio.ILogDB\n\tpipeline              pipeline\n\tgetStreamSink         func(uint64, uint64) *transport.Sink\n\tss                    snapshotState\n\tconfigChangeC         <-chan configChangeRequest\n\tsnapshotC             <-chan rsm.SSRequest\n\ttoApplyQ              *rsm.TaskQueue\n\ttoCommitQ             *rsm.TaskQueue\n\tsyncTask              task\n\tmetrics               *logDBMetrics\n\tstopC                 chan struct{}\n\tsysEvents             *sysEventListener\n\traftEvents            *raftEventListener\n\thandleSnapshotStatus  func(uint64, uint64, bool)\n\tsendRaftMessage       func(pb.Message)\n\tvalidateTarget        func(string) bool\n\tsm                    *rsm.StateMachine\n\tincomingReadIndexes   *readIndexQueue\n\tincomingProposals     *entryQueue\n\tsnapshotLock          sync.Mutex\n\tpendingProposals      pendingProposal\n\tpendingReadIndexes    pendingReadIndex\n\tpendingConfigChange   pendingConfigChange\n\tpendingSnapshot       pendingSnapshot\n\tpendingLeaderTransfer pendingLeaderTransfer\n\tpendingRaftLogQuery   pendingRaftLogQuery\n\tinitializedC          chan struct{}\n\tp                     raft.Peer\n\tlogReader             *logdb.LogReader\n\tsnapshotter           *snapshotter\n\tmq                    *server.MessageQueue\n\tqs                    *quiesceState\n\traftAddress           string\n\tconfig                config.Config\n\tcurrentTick           uint64\n\tgcTick                uint64\n\tappliedIndex          uint64\n\tpushedIndex           uint64\n\tconfirmedIndex        uint64\n\ttickMillisecond       uint64\n\tshardID               uint64\n\treplicaID             uint64\n\tinstanceID            uint64\n\tinitializedFlag       uint64\n\tcloseOnce             sync.Once\n\traftMu                sync.Mutex\n\tnew                   bool\n\tlogDBLimited          bool\n\trateLimited           bool\n\tnotifyCommit          bool\n}\n\nvar _ rsm.INode = (*node)(nil)\n\nvar instanceID uint64\n\nfunc newNode(peers map[uint64]string,\n\tinitialMember bool,\n\tconfig config.Config,\n\tnhConfig config.NodeHostConfig,\n\tcreateSM rsm.ManagedStateMachineFactory,\n\tsnapshotter *snapshotter,\n\tlogReader *logdb.LogReader,\n\tpipeline pipeline,\n\tliQueue *leaderInfoQueue,\n\tgetStreamSink func(uint64, uint64) *transport.Sink,\n\thandleSnapshotStatus func(uint64, uint64, bool),\n\tsendMessage func(pb.Message),\n\tnodeRegistry raftio.INodeRegistry,\n\tpool *sync.Pool,\n\tldb raftio.ILogDB,\n\tmetrics *logDBMetrics,\n\tsysEvents *sysEventListener) (*node, error) {\n\tnotifyCommit := nhConfig.NotifyCommit\n\tproposals := newEntryQueue(incomingProposalsMaxLen, lazyFreeCycle)\n\treadIndexes := newReadIndexQueue(incomingReadIndexMaxLen)\n\tconfigChangeC := make(chan configChangeRequest, 1)\n\tsnapshotC := make(chan rsm.SSRequest, 1)\n\tstopC := make(chan struct{})\n\tmq := server.NewMessageQueue(receiveQueueLen,\n\t\tfalse, lazyFreeCycle, nhConfig.MaxReceiveQueueSize)\n\trn := &node{\n\t\tshardID:               config.ShardID,\n\t\treplicaID:             config.ReplicaID,\n\t\traftAddress:           nhConfig.RaftAddress,\n\t\tinstanceID:            atomic.AddUint64(&instanceID, 1),\n\t\ttickMillisecond:       nhConfig.RTTMillisecond,\n\t\tconfig:                config,\n\t\tincomingProposals:     proposals,\n\t\tincomingReadIndexes:   readIndexes,\n\t\tconfigChangeC:         configChangeC,\n\t\tsnapshotC:             snapshotC,\n\t\tpipeline:              pipeline,\n\t\tgetStreamSink:         getStreamSink,\n\t\thandleSnapshotStatus:  handleSnapshotStatus,\n\t\tstopC:                 stopC,\n\t\tpendingProposals:      newPendingProposal(config, notifyCommit, pool, proposals),\n\t\tpendingReadIndexes:    newPendingReadIndex(pool, readIndexes),\n\t\tpendingConfigChange:   newPendingConfigChange(configChangeC, notifyCommit),\n\t\tpendingSnapshot:       newPendingSnapshot(snapshotC),\n\t\tpendingLeaderTransfer: newPendingLeaderTransfer(),\n\t\tpendingRaftLogQuery:   newPendingRaftLogQuery(),\n\t\tnodeRegistry:          nodeRegistry,\n\t\tsnapshotter:           snapshotter,\n\t\tlogReader:             logReader,\n\t\tsendRaftMessage:       sendMessage,\n\t\tmq:                    mq,\n\t\tlogdb:                 ldb,\n\t\tsyncTask:              newTask(syncTaskInterval),\n\t\tsysEvents:             sysEvents,\n\t\tnotifyCommit:          notifyCommit,\n\t\tmetrics:               metrics,\n\t\tinitializedC:          make(chan struct{}),\n\t\tss:                    snapshotState{},\n\t\tvalidateTarget:        nhConfig.GetTargetValidator(),\n\t\tqs: &quiesceState{\n\t\t\telectionTick: config.ElectionRTT * 2,\n\t\t\tenabled:      config.Quiesce,\n\t\t\tshardID:      config.ShardID,\n\t\t\treplicaID:    config.ReplicaID,\n\t\t},\n\t}\n\tds := createSM(config.ShardID, config.ReplicaID, stopC)\n\tsm := rsm.NewStateMachine(ds, snapshotter, config, rn, snapshotter.fs)\n\tif notifyCommit {\n\t\trn.toCommitQ = rsm.NewTaskQueue()\n\t}\n\trn.toApplyQ = sm.TaskQ()\n\trn.sm = sm\n\trn.raftEvents = newRaftEventListener(config.ShardID,\n\t\tconfig.ReplicaID, nhConfig.EnableMetrics, liQueue)\n\tnew, err := rn.startRaft(config, peers, initialMember)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trn.new = new\n\treturn rn, nil\n}\n\nfunc (n *node) ReplicaID() uint64 {\n\treturn n.replicaID\n}\n\nfunc (n *node) ShardID() uint64 {\n\treturn n.shardID\n}\n\nfunc (n *node) ShouldStop() <-chan struct{} {\n\treturn n.stopC\n}\n\nfunc (n *node) StepReady() {\n\tn.pipeline.setStepReady(n.shardID)\n}\n\nfunc (n *node) applyReady() {\n\tn.pipeline.setApplyReady(n.shardID)\n}\n\nfunc (n *node) commitReady() {\n\tn.pipeline.setCommitReady(n.shardID)\n}\n\nfunc (n *node) ApplyUpdate(e pb.Entry,\n\tresult sm.Result, rejected bool, ignored bool, notifyRead bool) {\n\tif n.isWitness() {\n\t\treturn\n\t}\n\tif notifyRead {\n\t\tn.pendingReadIndexes.applied(e.Index)\n\t}\n\tif !ignored {\n\t\tif e.Key == 0 {\n\t\t\tplog.Panicf(\"key is 0\")\n\t\t}\n\t\tn.pendingProposals.applied(e.ClientID, e.SeriesID, e.Key, result, rejected)\n\t}\n}\n\nfunc (n *node) ApplyConfigChange(cc pb.ConfigChange,\n\tkey uint64, rejected bool) error {\n\tn.raftMu.Lock()\n\tdefer n.raftMu.Unlock()\n\tif !rejected {\n\t\tif err := n.applyConfigChange(cc); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn n.configChangeProcessed(key, rejected)\n}\n\nfunc (n *node) applyConfigChange(cc pb.ConfigChange) error {\n\tif err := n.p.ApplyConfigChange(cc); err != nil {\n\t\treturn err\n\t}\n\tswitch cc.Type {\n\tcase pb.AddNode, pb.AddNonVoting, pb.AddWitness:\n\t\tn.nodeRegistry.Add(n.shardID, cc.ReplicaID, cc.Address)\n\tcase pb.RemoveNode:\n\t\tif cc.ReplicaID == n.replicaID {\n\t\t\tplog.Infof(\"%s applied ConfChange Remove for itself\", n.id())\n\t\t\tn.nodeRegistry.RemoveShard(n.shardID)\n\t\t\tn.requestRemoval()\n\t\t\tn.notifySelfRemove()\n\t\t} else {\n\t\t\tn.nodeRegistry.Remove(n.shardID, cc.ReplicaID)\n\t\t}\n\tdefault:\n\t\tplog.Panicf(\"unknown config change type, %s\", cc.Type)\n\t}\n\treturn nil\n}\n\nfunc (n *node) configChangeProcessed(key uint64, rejected bool) error {\n\tif n.isWitness() {\n\t\treturn nil\n\t}\n\tif rejected {\n\t\tif err := n.p.RejectConfigChange(); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tn.notifyConfigChange()\n\t}\n\tn.pendingConfigChange.apply(key, rejected)\n\treturn nil\n}\n\nfunc (n *node) processLeaderUpdate(u pb.LeaderUpdate) {\n\tif u.Term == 0 {\n\t\treturn\n\t}\n\tleaderInfo := &leaderInfo{\n\t\tleaderID: u.LeaderID,\n\t\tterm:     u.Term,\n\t}\n\tn.leaderInfo.Store(leaderInfo)\n}\n\nfunc (n *node) processLogQuery(r pb.LogQueryResult) {\n\tif r.IsEmpty() {\n\t\treturn\n\t}\n\toutOfRange := false\n\tif r.Error != nil {\n\t\tif errors.Is(r.Error, raft.ErrCompacted) {\n\t\t\toutOfRange = true\n\t\t} else {\n\t\t\tpanic(r.Error)\n\t\t}\n\t}\n\tn.pendingRaftLogQuery.returned(outOfRange,\n\t\tLogRange{FirstIndex: r.FirstIndex, LastIndex: r.LastIndex}, r.Entries)\n}\n\nfunc (n *node) RestoreRemotes(snapshot pb.Snapshot) error {\n\tif snapshot.Membership.ConfigChangeId == 0 {\n\t\tplog.Panicf(\"invalid ConfChangeId\")\n\t}\n\tn.raftMu.Lock()\n\tdefer n.raftMu.Unlock()\n\tfor nid, addr := range snapshot.Membership.Addresses {\n\t\tn.nodeRegistry.Add(n.shardID, nid, addr)\n\t}\n\tfor nid, addr := range snapshot.Membership.NonVotings {\n\t\tn.nodeRegistry.Add(n.shardID, nid, addr)\n\t}\n\tfor nid, addr := range snapshot.Membership.Witnesses {\n\t\tn.nodeRegistry.Add(n.shardID, nid, addr)\n\t}\n\tfor nid := range snapshot.Membership.Removed {\n\t\tif nid == n.replicaID {\n\t\t\tn.nodeRegistry.RemoveShard(n.shardID)\n\t\t\tn.requestRemoval()\n\t\t\tn.notifySelfRemove()\n\t\t}\n\t}\n\tplog.Debugf(\"%s is restoring remotes\", n.id())\n\tif err := n.p.RestoreRemotes(snapshot); err != nil {\n\t\treturn err\n\t}\n\tn.notifyConfigChange()\n\treturn nil\n}\n\nfunc (n *node) startRaft(cfg config.Config,\n\tpeers map[uint64]string, initial bool) (bool, error) {\n\tnewNode, err := n.replayLog(cfg.ShardID, cfg.ReplicaID)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tpas := make([]raft.PeerAddress, 0)\n\tfor k, v := range peers {\n\t\tpas = append(pas, raft.PeerAddress{ReplicaID: k, Address: v})\n\t}\n\tn.p = raft.Launch(cfg, n.logReader, n.raftEvents, pas, initial, newNode)\n\treturn newNode, nil\n}\n\nfunc (n *node) close() {\n\tn.requestRemoval()\n\tn.raftEvents.close()\n\tn.mq.Close()\n\tn.pendingReadIndexes.close()\n\tn.pendingProposals.close()\n\tn.pendingConfigChange.close()\n\tn.pendingSnapshot.close()\n\tn.pendingRaftLogQuery.close()\n}\n\nfunc (n *node) stopped() bool {\n\tselect {\n\tcase <-n.stopC:\n\t\treturn true\n\tdefault:\n\t}\n\treturn false\n}\n\nfunc (n *node) requestRemoval() {\n\tn.closeOnce.Do(func() {\n\t\tclose(n.stopC)\n\t})\n\tplog.Debugf(\"%s called requestRemoval()\", n.id())\n}\n\nfunc (n *node) concurrentSnapshot() bool {\n\treturn n.sm.Concurrent()\n}\n\nfunc (n *node) supportClientSession() bool {\n\treturn !n.OnDiskStateMachine() && !n.isWitness()\n}\n\nfunc (n *node) isWitness() bool {\n\treturn n.config.IsWitness\n}\n\nfunc (n *node) OnDiskStateMachine() bool {\n\treturn n.sm.OnDiskStateMachine()\n}\n\nfunc (n *node) proposeSession(session *client.Session,\n\ttimeout uint64) (*RequestState, error) {\n\tif !n.initialized() {\n\t\treturn nil, ErrShardNotReady\n\t}\n\tif n.isWitness() {\n\t\treturn nil, ErrInvalidOperation\n\t}\n\tif !session.ValidForSessionOp(n.shardID) {\n\t\treturn nil, ErrInvalidSession\n\t}\n\treturn n.pendingProposals.propose(session, nil, timeout)\n}\n\nfunc (n *node) payloadTooBig(sz int) bool {\n\tif n.config.MaxInMemLogSize == 0 {\n\t\treturn false\n\t}\n\treturn uint64(sz+settings.EntryNonCmdFieldsSize) > n.config.MaxInMemLogSize\n}\n\nfunc (n *node) propose(session *client.Session,\n\tcmd []byte, timeout uint64) (*RequestState, error) {\n\tif !n.initialized() {\n\t\treturn nil, ErrShardNotReady\n\t}\n\tif n.isWitness() {\n\t\treturn nil, ErrInvalidOperation\n\t}\n\tif !session.ValidForProposal(n.shardID) {\n\t\treturn nil, ErrInvalidSession\n\t}\n\tif n.payloadTooBig(len(cmd)) {\n\t\treturn nil, ErrPayloadTooBig\n\t}\n\treturn n.pendingProposals.propose(session, cmd, timeout)\n}\n\nfunc (n *node) read(timeout uint64) (*RequestState, error) {\n\tif !n.initialized() {\n\t\treturn nil, ErrShardNotReady\n\t}\n\tif n.isWitness() {\n\t\treturn nil, ErrInvalidOperation\n\t}\n\trs, err := n.pendingReadIndexes.read(timeout)\n\tif err == nil {\n\t\trs.node = n\n\t}\n\treturn rs, err\n}\n\nfunc (n *node) requestLeaderTransfer(replicaID uint64) error {\n\tif !n.initialized() {\n\t\treturn ErrShardNotReady\n\t}\n\tif n.isWitness() {\n\t\treturn ErrInvalidOperation\n\t}\n\treturn n.pendingLeaderTransfer.request(replicaID)\n}\n\nfunc (n *node) requestSnapshot(opt SnapshotOption,\n\ttimeout uint64) (*RequestState, error) {\n\tif !n.initialized() {\n\t\treturn nil, ErrShardNotReady\n\t}\n\tif n.isWitness() {\n\t\treturn nil, ErrInvalidOperation\n\t}\n\tst := rsm.UserRequested\n\tif opt.Exported {\n\t\tplog.Debugf(\"%s called export snapshot\", n.id())\n\t\tst = rsm.Exported\n\t\texist, err := fileutil.Exist(opt.ExportPath, n.snapshotter.fs)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif !exist {\n\t\t\treturn nil, ErrDirNotExist\n\t\t}\n\t} else {\n\t\tif len(opt.ExportPath) > 0 {\n\t\t\tplog.Warningf(\"opt.ExportPath set when not exporting a snapshot\")\n\t\t\topt.ExportPath = \"\"\n\t\t}\n\t}\n\treturn n.pendingSnapshot.request(st,\n\t\topt.ExportPath,\n\t\topt.OverrideCompactionOverhead,\n\t\topt.CompactionOverhead,\n\t\topt.CompactionIndex,\n\t\ttimeout)\n}\n\nfunc (n *node) queryRaftLog(firstIndex uint64,\n\tlastIndex uint64, maxSize uint64) (*RequestState, error) {\n\tif !n.initialized() {\n\t\treturn nil, ErrShardNotReady\n\t}\n\tif n.isWitness() {\n\t\treturn nil, ErrInvalidOperation\n\t}\n\treturn n.pendingRaftLogQuery.add(firstIndex, lastIndex, maxSize)\n}\n\nfunc (n *node) reportIgnoredSnapshotRequest(key uint64) {\n\tn.pendingSnapshot.apply(key, true, false, 0)\n}\n\nfunc (n *node) requestConfigChange(cct pb.ConfigChangeType,\n\treplicaID uint64, target string, orderID uint64,\n\ttimeout uint64) (*RequestState, error) {\n\tif !n.initialized() {\n\t\treturn nil, ErrShardNotReady\n\t}\n\tif n.isWitness() {\n\t\treturn nil, ErrInvalidOperation\n\t}\n\tif cct != pb.RemoveNode && !n.validateTarget(target) {\n\t\treturn nil, ErrInvalidAddress\n\t}\n\tcc := pb.ConfigChange{\n\t\tType:           cct,\n\t\tReplicaID:      replicaID,\n\t\tConfigChangeId: orderID,\n\t\tAddress:        target,\n\t}\n\treturn n.pendingConfigChange.request(cc, timeout)\n}\n\nfunc (n *node) requestDeleteNodeWithOrderID(replicaID uint64,\n\torder uint64, timeout uint64) (*RequestState, error) {\n\treturn n.requestConfigChange(pb.RemoveNode, replicaID, \"\", order, timeout)\n}\n\nfunc (n *node) requestAddNodeWithOrderID(replicaID uint64,\n\ttarget string, order uint64, timeout uint64) (*RequestState, error) {\n\treturn n.requestConfigChange(pb.AddNode, replicaID, target, order, timeout)\n}\n\nfunc (n *node) requestAddNonVotingWithOrderID(replicaID uint64,\n\ttarget string, order uint64, timeout uint64) (*RequestState, error) {\n\treturn n.requestConfigChange(pb.AddNonVoting, replicaID, target, order, timeout)\n}\n\nfunc (n *node) requestAddWitnessWithOrderID(replicaID uint64,\n\ttarget string, order uint64, timeout uint64) (*RequestState, error) {\n\treturn n.requestConfigChange(pb.AddWitness, replicaID, target, order, timeout)\n}\n\nfunc (n *node) getLeaderID() (uint64, uint64, bool) {\n\tlv := n.leaderInfo.Load()\n\tif lv == nil {\n\t\treturn 0, 0, false\n\t}\n\tleaderInfo := lv.(*leaderInfo)\n\treturn leaderInfo.leaderID, leaderInfo.term, leaderInfo.leaderID != raft.NoLeader\n}\n\nfunc (n *node) destroy() error {\n\treturn n.sm.Close()\n}\n\nfunc (n *node) destroyed() bool {\n\tselect {\n\tcase <-n.sm.DestroyedC():\n\t\treturn true\n\tdefault:\n\t}\n\n\treturn false\n}\n\nfunc (n *node) offloaded() {\n\tif n.sm.Offloaded() {\n\t\tn.pipeline.setCloseReady(n)\n\t\tn.sysEvents.Publish(server.SystemEvent{\n\t\t\tType:      server.NodeUnloaded,\n\t\t\tShardID:   n.shardID,\n\t\t\tReplicaID: n.replicaID,\n\t\t})\n\t}\n}\n\nfunc (n *node) loaded() {\n\tn.sm.Loaded()\n}\n\nfunc (n *node) pushTask(rec rsm.Task, notify bool) {\n\tif n.notifyCommit {\n\t\tn.toCommitQ.Add(rec)\n\t\tif notify {\n\t\t\tn.commitReady()\n\t\t}\n\t} else {\n\t\tn.toApplyQ.Add(rec)\n\t\tif notify {\n\t\t\tn.applyReady()\n\t\t}\n\t}\n}\n\nfunc (n *node) pushEntries(ents []pb.Entry) {\n\tif len(ents) == 0 {\n\t\treturn\n\t}\n\tn.pushTask(rsm.Task{Entries: ents}, false)\n\tn.pushedIndex = ents[len(ents)-1].Index\n}\n\nfunc (n *node) pushStreamSnapshotRequest(shardID uint64, replicaID uint64) {\n\tn.pushTask(rsm.Task{\n\t\tShardID:   shardID,\n\t\tReplicaID: replicaID,\n\t\tStream:    true,\n\t}, true)\n}\n\nfunc (n *node) pushTakeSnapshotRequest(req rsm.SSRequest) {\n\tn.pushTask(rsm.Task{\n\t\tSave:      true,\n\t\tSSRequest: req,\n\t}, true)\n}\n\nfunc (n *node) pushSnapshot(ss pb.Snapshot, applied uint64) {\n\tif pb.IsEmptySnapshot(ss) {\n\t\treturn\n\t}\n\tif ss.Index < n.pushedIndex ||\n\t\tss.Index < n.ss.getIndex() ||\n\t\tss.Index < applied {\n\t\tplog.Panicf(\"out of date snapshot, index %d, pushed %d, applied %d, ss %d\",\n\t\t\tss.Index, n.pushedIndex, applied, n.ss.getIndex())\n\t}\n\tn.pushTask(rsm.Task{\n\t\tRecover: true,\n\t\tIndex:   ss.Index,\n\t}, true)\n\tn.ss.setIndex(ss.Index)\n\tn.pushedIndex = ss.Index\n}\n\nfunc (n *node) replayLog(shardID uint64, replicaID uint64) (bool, error) {\n\tplog.Infof(\"%s replaying raft logs\", n.id())\n\tss, err := n.snapshotter.GetSnapshotFromLogDB()\n\tif err != nil && !n.snapshotter.IsNoSnapshotError(err) {\n\t\treturn false, errors.Wrapf(err, \"%s failed to get latest snapshot\", n.id())\n\t}\n\tif !pb.IsEmptySnapshot(ss) {\n\t\tif err = n.logReader.ApplySnapshot(ss); err != nil {\n\t\t\treturn false, errors.Wrapf(err, \"%s failed to apply snapshot\", n.id())\n\t\t}\n\t}\n\trs, err := n.logdb.ReadRaftState(shardID, replicaID, ss.Index)\n\tif errors.Is(err, raftio.ErrNoSavedLog) {\n\t\treturn true, nil\n\t}\n\tif err != nil {\n\t\treturn false, errors.Wrapf(err, \"%s ReadRaftState failed\", n.id())\n\t}\n\thasRaftState := !pb.IsEmptyState(rs.State)\n\tif hasRaftState {\n\t\tplog.Infof(\"%s logdb first entry %d size %d commit %d term %d\",\n\t\t\tn.id(), rs.FirstIndex, rs.EntryCount, rs.State.Commit, rs.State.Term)\n\t\tn.logReader.SetState(rs.State)\n\t}\n\tn.logReader.SetRange(rs.FirstIndex, rs.EntryCount)\n\treturn !(ss.Index > 0 || rs.EntryCount > 0 || hasRaftState), nil\n}\n\nfunc (n *node) saveSnapshotRequired(applied uint64) bool {\n\tif n.config.SnapshotEntries == 0 {\n\t\treturn false\n\t}\n\tindex := n.ss.getIndex()\n\tif n.pushedIndex <= n.config.SnapshotEntries+index ||\n\t\tapplied <= n.config.SnapshotEntries+index ||\n\t\tapplied <= n.config.SnapshotEntries+n.ss.getReqIndex() {\n\t\treturn false\n\t}\n\tif n.isBusySnapshotting() {\n\t\treturn false\n\t}\n\tplog.Debugf(\"%s requested to create %s\", n.id(), n.ssid(applied))\n\tn.ss.setReqIndex(applied)\n\treturn true\n}\n\nfunc isSoftSnapshotError(err error) bool {\n\treturn errors.Is(err, raft.ErrCompacted) ||\n\t\terrors.Is(err, raft.ErrSnapshotOutOfDate)\n}\n\nfunc saveAborted(err error) bool {\n\treturn errors.Is(err, sm.ErrSnapshotStopped) ||\n\t\terrors.Is(err, sm.ErrSnapshotAborted)\n}\n\nfunc snapshotCommitAborted(err error) bool {\n\treturn errors.Is(err, errSnapshotOutOfDate)\n}\n\nfunc streamAborted(err error) bool {\n\treturn saveAborted(err) || errors.Is(err, sm.ErrSnapshotStreaming)\n}\n\nfunc openAborted(err error) bool {\n\treturn errors.Is(err, sm.ErrOpenStopped)\n}\n\nfunc recoverAborted(err error) bool {\n\treturn errors.Is(err, sm.ErrSnapshotStopped) ||\n\t\terrors.Is(err, raft.ErrSnapshotOutOfDate)\n}\n\nfunc (n *node) save(rec rsm.Task) error {\n\tindex, err := n.doSave(rec.SSRequest)\n\tif err != nil {\n\t\treturn err\n\t}\n\tn.pendingSnapshot.apply(rec.SSRequest.Key, index == 0, false, index)\n\tn.sysEvents.Publish(server.SystemEvent{\n\t\tType:      server.SnapshotCreated,\n\t\tShardID:   n.shardID,\n\t\tReplicaID: n.replicaID,\n\t})\n\treturn nil\n}\n\nfunc (n *node) doSave(req rsm.SSRequest) (uint64, error) {\n\tn.snapshotLock.Lock()\n\tdefer n.snapshotLock.Unlock()\n\tif !req.Exported() && n.sm.GetLastApplied() <= n.ss.getIndex() {\n\t\t// a snapshot has been pushed to the sm but not applied yet\n\t\t// or the snapshot has been applied and there is no further progress\n\t\treturn 0, nil\n\t}\n\tss, ssenv, err := n.sm.Save(req)\n\tif err != nil {\n\t\tif saveAborted(err) {\n\t\t\tplog.Warningf(\"%s save snapshot aborted, %v\", n.id(), err)\n\t\t\tssenv.MustRemoveTempDir()\n\t\t\tn.pendingSnapshot.apply(req.Key, false, true, 0)\n\t\t\treturn 0, nil\n\t\t} else if isSoftSnapshotError(err) {\n\t\t\t// e.g. trying to save a snapshot at the same index twice\n\t\t\treturn 0, nil\n\t\t}\n\t\treturn 0, errors.Wrapf(err, \"%s save snapshot failed\", n.id())\n\t}\n\tplog.Infof(\"%s saved %s, term %d, file count %d\",\n\t\tn.id(), n.ssid(ss.Index), ss.Term, len(ss.Files))\n\tif err := n.snapshotter.Commit(ss, req); err != nil {\n\t\tif snapshotCommitAborted(err) || saveAborted(err) {\n\t\t\t// saveAborted() will only be true in monkey test\n\t\t\t// commit abort happens when the final dir already exists, probably due to\n\t\t\t// incoming snapshot\n\t\t\tssenv.MustRemoveTempDir()\n\t\t\treturn 0, nil\n\t\t}\n\t\treturn 0, errors.Wrapf(err, \"%s commit snapshot failed\", n.id())\n\t}\n\tif req.Exported() {\n\t\treturn ss.Index, nil\n\t}\n\tif !ss.Validate(n.snapshotter.fs) {\n\t\tplog.Panicf(\"%s generated invalid snapshot %v\", n.id(), ss)\n\t}\n\tif err = n.logReader.CreateSnapshot(ss); err != nil {\n\t\tif isSoftSnapshotError(err) {\n\t\t\treturn 0, nil\n\t\t}\n\t\treturn 0, errors.Wrapf(err, \"%s create snapshot failed\", n.id())\n\t}\n\tn.compactLog(req, ss.Index)\n\tn.ss.setIndex(ss.Index)\n\treturn ss.Index, nil\n}\n\nfunc (n *node) compactLog(req rsm.SSRequest, index uint64) {\n\tif compactionIndex, ok := n.getCompactionIndex(req, index); ok {\n\t\tn.ss.setCompactLogTo(compactionIndex)\n\t}\n}\n\nfunc (n *node) getCompactionIndex(req rsm.SSRequest, index uint64) (uint64, bool) {\n\tif req.OverrideCompaction {\n\t\tif req.CompactionIndex > 0 {\n\t\t\tif index >= req.CompactionIndex+1 {\n\t\t\t\treturn req.CompactionIndex, true\n\t\t\t}\n\t\t\treturn 0, false\n\t\t}\n\t\tif index > req.CompactionOverhead {\n\t\t\treturn index - req.CompactionOverhead, true\n\t\t}\n\t\treturn 0, false\n\t}\n\tif index > n.config.CompactionOverhead {\n\t\treturn index - n.config.CompactionOverhead, true\n\t}\n\n\treturn 0, false\n}\n\nfunc (n *node) stream(sink pb.IChunkSink) error {\n\tif sink != nil {\n\t\tplog.Infof(\"%s requested to stream to %d\", n.id(), sink.ToReplicaID())\n\t\tif err := n.sm.Stream(sink); err != nil {\n\t\t\tif !streamAborted(err) {\n\t\t\t\treturn errors.Wrapf(err, \"%s stream failed\", n.id())\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (n *node) recover(rec rsm.Task) (_ uint64, err error) {\n\tn.snapshotLock.Lock()\n\tdefer n.snapshotLock.Unlock()\n\tif rec.Initial && n.OnDiskStateMachine() {\n\t\tplog.Debugf(\"%s on disk SM is beng initialized\", n.id())\n\t\tidx, err := n.sm.OpenOnDiskStateMachine()\n\t\tif err != nil {\n\t\t\tif openAborted(err) {\n\t\t\t\tplog.Warningf(\"%s aborted OpenOnDiskStateMachine\", n.id())\n\t\t\t\treturn 0, nil\n\t\t\t}\n\t\t\treturn 0, errors.Wrapf(err, \"%s OpenOnDiskStateMachine failed\", n.id())\n\t\t}\n\t\tif idx > 0 && rec.NewNode {\n\t\t\tplog.Panicf(\"%s new node at non-zero index %d\", n.id(), idx)\n\t\t}\n\t}\n\tss, err := n.sm.Recover(rec)\n\tif err != nil {\n\t\tif recoverAborted(err) {\n\t\t\tplog.Warningf(\"%s aborted recovery\", n.id())\n\t\t\treturn 0, nil\n\t\t}\n\t\treturn 0, errors.Wrapf(err, \"%s recover failed\", n.id())\n\t}\n\tif !pb.IsEmptySnapshot(ss) {\n\t\tdefer func() {\n\t\t\terr = firstError(err, ss.Unref())\n\t\t}()\n\t\tplog.Infof(\"%s recovered from %s\", n.id(), n.ssid(ss.Index))\n\t\tif n.OnDiskStateMachine() {\n\t\t\tif err := n.sm.Sync(); err != nil {\n\t\t\t\treturn 0, errors.Wrapf(err, \"%s sync failed\", n.id())\n\t\t\t}\n\t\t\tif err := n.snapshotter.Shrink(ss.Index); err != nil {\n\t\t\t\treturn 0, errors.Wrapf(err, \"%s shrink failed\", n.id())\n\t\t\t}\n\t\t}\n\t\tn.compactLog(rsm.DefaultSSRequest, ss.Index)\n\t}\n\tn.sysEvents.Publish(server.SystemEvent{\n\t\tType:      server.SnapshotRecovered,\n\t\tShardID:   n.shardID,\n\t\tReplicaID: n.replicaID,\n\t\tIndex:     ss.Index,\n\t})\n\treturn ss.Index, nil\n}\n\nfunc (n *node) streamDone() {\n\tn.ss.notifySnapshotStatus(false, false, true, false, 0)\n\tn.applyReady()\n}\n\nfunc (n *node) saveDone() {\n\tn.ss.notifySnapshotStatus(true, false, false, false, 0)\n\tn.applyReady()\n}\n\nfunc (n *node) recoverDone(index uint64) {\n\tif !n.initialized() {\n\t\tn.initialSnapshotDone(index)\n\t} else {\n\t\tn.recoverFromSnapshotDone()\n\t}\n}\n\nfunc (n *node) initialSnapshotDone(index uint64) {\n\tn.ss.notifySnapshotStatus(false, true, false, true, index)\n\tn.applyReady()\n}\n\nfunc (n *node) recoverFromSnapshotDone() {\n\tn.ss.notifySnapshotStatus(false, true, false, false, 0)\n\tn.applyReady()\n}\n\nfunc (n *node) handleTask(ts []rsm.Task, es []sm.Entry) (rsm.Task, error) {\n\treturn n.sm.Handle(ts, es)\n}\n\nfunc (n *node) removeSnapshotFlagFile(index uint64) error {\n\treturn n.snapshotter.removeFlagFile(index)\n}\n\nfunc (n *node) runSyncTask() {\n\tif !n.sm.OnDiskStateMachine() {\n\t\treturn\n\t}\n\tif !n.syncTask.timeToRun(n.millisecondSinceStart()) {\n\t\treturn\n\t}\n\tif !n.sm.TaskChanBusy() {\n\t\tn.pushTask(rsm.Task{PeriodicSync: true}, true)\n\t}\n}\n\nfunc (n *node) removeLog() error {\n\tif n.ss.hasCompactLogTo() {\n\t\tcompactTo := n.ss.getCompactLogTo()\n\t\tif compactTo == 0 {\n\t\t\tpanic(\"racy compact log to value?\")\n\t\t}\n\t\tif err := n.logReader.Compact(compactTo); err != nil {\n\t\t\tif err != raft.ErrCompacted {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif err := n.logdb.RemoveEntriesTo(n.shardID,\n\t\t\tn.replicaID, compactTo); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tplog.Infof(\"%s compacted log up to index %d\", n.id(), compactTo)\n\t\tn.ss.setCompactedTo(compactTo)\n\t\tn.sysEvents.Publish(server.SystemEvent{\n\t\t\tType:      server.LogCompacted,\n\t\t\tShardID:   n.shardID,\n\t\t\tReplicaID: n.replicaID,\n\t\t\tIndex:     compactTo,\n\t\t})\n\t\tif !n.config.DisableAutoCompactions {\n\t\t\tif _, err := n.requestCompaction(); err != nil {\n\t\t\t\tif err != ErrRejected {\n\t\t\t\t\treturn errors.Wrapf(err, \"%s failed to request compaction\", n.id())\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (n *node) requestCompaction() (*SysOpState, error) {\n\tif compactTo := n.ss.getCompactedTo(); compactTo > 0 {\n\t\tdone, err := n.logdb.CompactEntriesTo(n.shardID, n.replicaID, compactTo)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tn.sysEvents.Publish(server.SystemEvent{\n\t\t\tType:      server.LogDBCompacted,\n\t\t\tShardID:   n.shardID,\n\t\t\tReplicaID: n.replicaID,\n\t\t\tIndex:     compactTo,\n\t\t})\n\t\treturn &SysOpState{completedC: done}, nil\n\t}\n\treturn nil, ErrRejected\n}\n\nfunc isFreeOrderMessage(m pb.Message) bool {\n\treturn m.Type == pb.Replicate || m.Type == pb.Ping\n}\n\nfunc (n *node) sendEnterQuiesceMessages() {\n\tfor replicaID := range n.sm.GetMembership().Addresses {\n\t\tif replicaID != n.replicaID {\n\t\t\tmsg := pb.Message{\n\t\t\t\tType:    pb.Quiesce,\n\t\t\t\tFrom:    n.replicaID,\n\t\t\t\tTo:      replicaID,\n\t\t\t\tShardID: n.shardID,\n\t\t\t}\n\t\t\tn.sendRaftMessage(msg)\n\t\t}\n\t}\n}\n\nfunc (n *node) sendMessages(msgs []pb.Message) {\n\tfor _, msg := range msgs {\n\t\tif !isFreeOrderMessage(msg) {\n\t\t\tmsg.ShardID = n.shardID\n\t\t\tn.sendRaftMessage(msg)\n\t\t}\n\t}\n}\n\nfunc (n *node) sendReplicateMessages(ud pb.Update) {\n\tfor _, msg := range ud.Messages {\n\t\tif isFreeOrderMessage(msg) {\n\t\t\tmsg.ShardID = n.shardID\n\t\t\tn.sendRaftMessage(msg)\n\t\t}\n\t}\n}\n\nfunc (n *node) getUpdate() (pb.Update, bool, error) {\n\tmoreEntries := n.moreEntriesToApply()\n\tif n.p.HasUpdate(moreEntries) ||\n\t\tn.confirmedIndex != n.appliedIndex ||\n\t\tn.ss.hasCompactLogTo() || n.ss.hasCompactedTo() {\n\t\tif n.appliedIndex < n.confirmedIndex {\n\t\t\tplog.Panicf(\"applied index moving backwards, %d, now %d\",\n\t\t\t\tn.confirmedIndex, n.appliedIndex)\n\t\t}\n\t\tud, err := n.p.GetUpdate(moreEntries, n.appliedIndex)\n\t\tif err != nil {\n\t\t\treturn pb.Update{}, false, err\n\t\t}\n\t\tn.confirmedIndex = n.appliedIndex\n\t\treturn ud, true, nil\n\t}\n\treturn pb.Update{}, false, nil\n}\n\nfunc (n *node) processDroppedReadIndexes(ud pb.Update) {\n\tfor _, sysctx := range ud.DroppedReadIndexes {\n\t\tn.pendingReadIndexes.dropped(sysctx)\n\t}\n}\n\nfunc (n *node) processDroppedEntries(ud pb.Update) {\n\tfor _, e := range ud.DroppedEntries {\n\t\tif e.IsProposal() {\n\t\t\tn.pendingProposals.dropped(e.ClientID, e.SeriesID, e.Key)\n\t\t} else if e.Type == pb.ConfigChangeEntry {\n\t\t\tn.pendingConfigChange.dropped(e.Key)\n\t\t} else {\n\t\t\tplog.Panicf(\"unknown entry type %s\", e.Type)\n\t\t}\n\t}\n}\n\nfunc (n *node) notifyCommittedEntries() {\n\ttasks := n.toCommitQ.GetAll()\n\tfor _, t := range tasks {\n\t\tfor _, e := range t.Entries {\n\t\t\tif e.IsProposal() {\n\t\t\t\tn.pendingProposals.committed(e.ClientID, e.SeriesID, e.Key)\n\t\t\t} else if e.Type == pb.ConfigChangeEntry {\n\t\t\t\tn.pendingConfigChange.committed(e.Key)\n\t\t\t} else {\n\t\t\t\tplog.Panicf(\"unknown entry type %s\", e.Type)\n\t\t\t}\n\t\t}\n\t\tn.toApplyQ.Add(t)\n\t}\n\tif len(tasks) > 0 {\n\t\tn.applyReady()\n\t}\n}\n\nfunc (n *node) processReadyToRead(ud pb.Update) {\n\tif len(ud.ReadyToReads) > 0 {\n\t\tn.pendingReadIndexes.addReady(ud.ReadyToReads)\n\t\tn.pendingReadIndexes.applied(ud.LastApplied)\n\t}\n}\n\nfunc (n *node) processSnapshot(ud pb.Update) error {\n\tif !pb.IsEmptySnapshot(ud.Snapshot) {\n\t\terr := n.logReader.ApplySnapshot(ud.Snapshot)\n\t\tif err != nil && !isSoftSnapshotError(err) {\n\t\t\treturn errors.Wrapf(err, \"%s failed to apply snapshot\", n.id())\n\t\t}\n\t\tplog.Debugf(\"%s, push snapshot %d\", n.id(), ud.Snapshot.Index)\n\t\tn.pushSnapshot(ud.Snapshot, ud.LastApplied)\n\t}\n\treturn nil\n}\n\nfunc (n *node) applyRaftUpdates(ud pb.Update) {\n\tn.pushEntries(pb.EntriesToApply(ud.CommittedEntries, n.pushedIndex, true))\n}\n\nfunc (n *node) processRaftUpdate(ud pb.Update) error {\n\tif err := n.logReader.Append(ud.EntriesToSave); err != nil {\n\t\treturn err\n\t}\n\tn.sendMessages(ud.Messages)\n\tif err := n.removeLog(); err != nil {\n\t\treturn err\n\t}\n\tn.runSyncTask()\n\tif n.saveSnapshotRequired(ud.LastApplied) {\n\t\tn.pushTakeSnapshotRequest(rsm.SSRequest{})\n\t}\n\treturn nil\n}\n\nfunc (n *node) commitRaftUpdate(ud pb.Update) {\n\tn.raftMu.Lock()\n\tn.p.Commit(ud)\n\tn.raftMu.Unlock()\n}\n\nfunc (n *node) moreEntriesToApply() bool {\n\treturn n.toApplyQ.MoreEntryToApply()\n}\n\nfunc (n *node) hasEntryToApply() bool {\n\treturn n.p.HasEntryToApply()\n}\n\nfunc (n *node) updateAppliedIndex() uint64 {\n\tn.appliedIndex = n.sm.GetLastApplied()\n\tn.p.NotifyRaftLastApplied(n.appliedIndex)\n\treturn n.appliedIndex\n}\n\nfunc (n *node) stepNode() (pb.Update, bool, error) {\n\tn.raftMu.Lock()\n\tdefer n.raftMu.Unlock()\n\tif n.initialized() {\n\t\thasEvent, err := n.handleEvents()\n\t\tif err != nil {\n\t\t\treturn pb.Update{}, false, err\n\t\t}\n\t\tif hasEvent {\n\t\t\tif n.qs.newQuiesceState() {\n\t\t\t\tn.sendEnterQuiesceMessages()\n\t\t\t}\n\t\t\tud, hasUpdate, err := n.getUpdate()\n\t\t\tif err != nil {\n\t\t\t\treturn pb.Update{}, false, err\n\t\t\t}\n\t\t\treturn ud, hasUpdate, nil\n\t\t}\n\t}\n\treturn pb.Update{}, false, nil\n}\n\nfunc (n *node) handleEvents() (bool, error) {\n\thasEvent := false\n\tlastApplied := n.updateAppliedIndex()\n\tif lastApplied != n.confirmedIndex {\n\t\thasEvent = true\n\t}\n\tif n.hasEntryToApply() {\n\t\thasEvent = true\n\t}\n\tevent, err := n.handleReadIndex()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif event {\n\t\thasEvent = true\n\t}\n\tevent, err = n.handleReceivedMessages()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif event {\n\t\thasEvent = true\n\t}\n\tevent, err = n.handleConfigChange()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif event {\n\t\thasEvent = true\n\t}\n\tevent, err = n.handleProposals()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif event {\n\t\thasEvent = true\n\t}\n\tevent, err = n.handleLeaderTransfer()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif event {\n\t\thasEvent = true\n\t}\n\tif n.handleSnapshot(lastApplied) {\n\t\thasEvent = true\n\t}\n\tif n.handleCompaction() {\n\t\thasEvent = true\n\t}\n\tevent, err = n.handleLogQuery()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif event {\n\t\thasEvent = true\n\t}\n\tn.gc()\n\tif hasEvent {\n\t\tn.pendingReadIndexes.applied(lastApplied)\n\t}\n\treturn hasEvent, nil\n}\n\nfunc (n *node) gc() {\n\tif n.gcTick != n.currentTick {\n\t\tn.pendingProposals.gc()\n\t\tn.pendingConfigChange.gc()\n\t\tn.pendingSnapshot.gc()\n\t\tn.gcTick = n.currentTick\n\t}\n}\n\nfunc (n *node) handleCompaction() bool {\n\treturn n.ss.hasCompactedTo() || n.ss.hasCompactLogTo()\n}\n\nfunc (n *node) handleLogQuery() (bool, error) {\n\tif req := n.pendingRaftLogQuery.get(); req != nil {\n\t\tif err := n.p.QueryRaftLog(req.logRange.FirstIndex,\n\t\t\treq.logRange.LastIndex, req.maxSize); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\treturn true, nil\n\t}\n\treturn false, nil\n}\n\nfunc (n *node) handleLeaderTransfer() (bool, error) {\n\ttarget, ok := n.pendingLeaderTransfer.get()\n\tif ok {\n\t\tif err := n.p.RequestLeaderTransfer(target); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\treturn ok, nil\n}\n\nfunc (n *node) handleSnapshot(lastApplied uint64) bool {\n\tvar req rsm.SSRequest\n\tselect {\n\tcase req = <-n.snapshotC:\n\tdefault:\n\t\treturn false\n\t}\n\tif !req.Exported() && lastApplied == n.ss.getReqIndex() {\n\t\tn.reportIgnoredSnapshotRequest(req.Key)\n\t\treturn false\n\t}\n\tn.ss.setReqIndex(lastApplied)\n\tn.pushTakeSnapshotRequest(req)\n\treturn true\n}\n\nfunc (n *node) handleProposals() (bool, error) {\n\trateLimited := n.p.RateLimited()\n\tif n.rateLimited != rateLimited {\n\t\tn.rateLimited = rateLimited\n\t\tplog.Infof(\"%s new rate limit state is %t\", n.id(), rateLimited)\n\t}\n\tlogDBBusy := n.logDBBusy()\n\tif n.logDBLimited != logDBBusy {\n\t\tn.logDBLimited = logDBBusy\n\t\tplog.Infof(\"%s new LogDB busy state is %t\", n.id(), logDBBusy)\n\t}\n\tpaused := logDBBusy || n.rateLimited\n\tif entries := n.incomingProposals.get(paused); len(entries) > 0 {\n\t\tif err := n.p.ProposeEntries(entries); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\treturn true, nil\n\t}\n\treturn false, nil\n}\n\nfunc (n *node) handleReadIndex() (bool, error) {\n\tif reqs := n.incomingReadIndexes.get(); len(reqs) > 0 {\n\t\tn.qs.record(pb.ReadIndex)\n\t\tctx := n.pendingReadIndexes.nextCtx()\n\t\tn.pendingReadIndexes.add(ctx, reqs)\n\t\tif err := n.p.ReadIndex(ctx); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\treturn true, nil\n\t}\n\treturn false, nil\n}\n\nfunc (n *node) handleConfigChange() (bool, error) {\n\tif len(n.configChangeC) == 0 {\n\t\treturn false, nil\n\t}\n\tselect {\n\tcase req, ok := <-n.configChangeC:\n\t\tif !ok {\n\t\t\tn.configChangeC = nil\n\t\t} else {\n\t\t\tn.qs.record(pb.ConfigChangeEvent)\n\t\t\tvar cc pb.ConfigChange\n\t\t\tpb.MustUnmarshal(&cc, req.data)\n\t\t\tif err := n.p.ProposeConfigChange(cc, req.key); err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t}\n\tdefault:\n\t\treturn false, nil\n\t}\n\treturn true, nil\n}\n\nfunc (n *node) isBusySnapshotting() bool {\n\tsnapshotting := n.ss.recovering()\n\tif !n.concurrentSnapshot() {\n\t\tsnapshotting = snapshotting || n.ss.saving()\n\t}\n\treturn snapshotting && n.sm.TaskChanBusy()\n}\n\nfunc (n *node) recordMessage(m pb.Message) {\n\tif (m.Type == pb.Heartbeat || m.Type == pb.HeartbeatResp) && m.Hint > 0 {\n\t\tn.qs.record(pb.ReadIndex)\n\t} else {\n\t\tn.qs.record(m.Type)\n\t}\n}\n\nfunc (n *node) handleReceivedMessages() (bool, error) {\n\tcount := uint64(0)\n\tbusy := n.isBusySnapshotting()\n\tmsgs := n.mq.Get()\n\tfor _, m := range msgs {\n\t\tif m.Type == pb.LocalTick {\n\t\t\tcount++\n\t\t} else if m.Type == pb.Replicate && busy {\n\t\t\tcontinue\n\t\t}\n\t\tdone, err := n.handleMessage(m)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif !done {\n\t\t\tn.recordMessage(m)\n\t\t\tif err := n.p.Handle(m); err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t}\n\t}\n\tif count > n.config.ElectionRTT/2 {\n\t\tplog.Warningf(\"%s had %d LocalTick msgs in one batch\", n.id(), count)\n\t}\n\tif lazyFreeCycle > 0 {\n\t\tfor i := range msgs {\n\t\t\tmsgs[i].Entries = nil\n\t\t}\n\t}\n\treturn len(msgs) > 0, nil\n}\n\nfunc (n *node) handleMessage(m pb.Message) (bool, error) {\n\tswitch m.Type {\n\tcase pb.LocalTick:\n\t\tif err := n.tick(m.Hint); err != nil {\n\t\t\treturn false, err\n\t\t}\n\tcase pb.Quiesce:\n\t\tn.qs.tryEnterQuiesce()\n\tcase pb.SnapshotStatus:\n\t\tplog.Debugf(\"%s got ReportSnapshot from %d, rejected %t\",\n\t\t\tn.id(), m.From, m.Reject)\n\t\tif err := n.p.ReportSnapshotStatus(m.From, m.Reject); err != nil {\n\t\t\treturn false, err\n\t\t}\n\tcase pb.Unreachable:\n\t\tif err := n.p.ReportUnreachableNode(m.From); err != nil {\n\t\t\treturn false, err\n\t\t}\n\tdefault:\n\t\treturn false, nil\n\t}\n\treturn true, nil\n}\n\nfunc (n *node) setInitialStatus(index uint64) {\n\tif n.initialized() {\n\t\tplog.Panicf(\"setInitialStatus called twice\")\n\t}\n\tplog.Infof(\"%s initial index set to %d\", n.id(), index)\n\tn.ss.setIndex(index)\n\tn.pushedIndex = index\n\tn.setInitialized()\n}\n\nfunc (n *node) handleSnapshotTask(task rsm.Task) {\n\tif n.ss.recovering() {\n\t\tplog.Panicf(\"%s recovering from snapshot again on %s\",\n\t\t\tn.id(), n.getRaftAddress())\n\t}\n\tif task.Recover {\n\t\tn.reportRecoverSnapshot(task)\n\t} else if task.Save {\n\t\tif n.ss.saving() {\n\t\t\tplog.Warningf(\"%s taking snapshot, ignored new snapshot req\", n.id())\n\t\t\tn.reportIgnoredSnapshotRequest(task.SSRequest.Key)\n\t\t\treturn\n\t\t}\n\t\tn.reportSaveSnapshot(task)\n\t} else if task.Stream {\n\t\tif !n.canStream() {\n\t\t\tn.reportSnapshotStatus(task.ShardID, task.ReplicaID, true)\n\t\t\treturn\n\t\t}\n\t\tn.reportStreamSnapshot(task)\n\t} else {\n\t\tplog.Panicf(\"unknown task type %+v\", task)\n\t}\n}\n\nfunc (n *node) reportSnapshotStatus(shardID uint64,\n\treplicaID uint64, failed bool) {\n\tn.handleSnapshotStatus(shardID, replicaID, failed)\n}\n\nfunc (n *node) reportStreamSnapshot(rec rsm.Task) {\n\tn.ss.setStreaming()\n\tgetSinkFn := func() pb.IChunkSink {\n\t\tconn := n.getStreamSink(rec.ShardID, rec.ReplicaID)\n\t\tif conn == nil {\n\t\t\tplog.Errorf(\"failed to connect to %s\", dn(rec.ShardID, rec.ReplicaID))\n\t\t\treturn nil\n\t\t}\n\t\treturn conn\n\t}\n\tn.ss.setStreamReq(rec, getSinkFn)\n\tn.pipeline.setStreamReady(n.shardID)\n}\n\nfunc (n *node) canStream() bool {\n\tif n.ss.streaming() {\n\t\tplog.Warningf(\"%s ignored task.StreamSnapshot\", n.id())\n\t\treturn false\n\t}\n\tif !n.sm.ReadyToStream() {\n\t\tplog.Warningf(\"%s is not ready to stream snapshot\", n.id())\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (n *node) reportSaveSnapshot(rec rsm.Task) {\n\tn.ss.setSaving()\n\tn.ss.setSaveReq(rec)\n\tn.pipeline.setSaveReady(n.shardID)\n}\n\nfunc (n *node) reportRecoverSnapshot(rec rsm.Task) {\n\tn.ss.setRecovering()\n\tn.ss.setRecoverReq(rec)\n\tn.pipeline.setRecoverReady(n.shardID)\n}\n\n// returns a boolean flag indicating whether to skip task handling for the\n// current node\nfunc (n *node) processStatusTransition() bool {\n\tif n.processSaveStatus() {\n\t\treturn true\n\t}\n\tif n.processStreamStatus() {\n\t\treturn true\n\t}\n\tif n.processRecoverStatus() {\n\t\treturn true\n\t}\n\tif n.processUninitializedNodeStatus() {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (n *node) processUninitializedNodeStatus() bool {\n\tif !n.initialized() {\n\t\tplog.Debugf(\"%s checking initial snapshot\", n.id())\n\t\tn.reportRecoverSnapshot(rsm.Task{\n\t\t\tRecover: true,\n\t\t\tInitial: true,\n\t\t\tNewNode: n.new,\n\t\t})\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (n *node) processRecoverStatus() bool {\n\tif n.ss.recovering() {\n\t\trec, ok := n.ss.getRecoverCompleted()\n\t\tif !ok {\n\t\t\treturn true\n\t\t}\n\t\tif rec.Save {\n\t\t\tplog.Panicf(\"got a completed.SnapshotRequested\")\n\t\t}\n\t\tif rec.Initial {\n\t\t\tplog.Infof(\"%s initialized using %s\", n.id(), n.ssid(rec.Index))\n\t\t\tn.setInitialStatus(rec.Index)\n\t\t\tn.sysEvents.Publish(server.SystemEvent{\n\t\t\t\tType:      server.NodeReady,\n\t\t\t\tShardID:   n.shardID,\n\t\t\t\tReplicaID: n.replicaID,\n\t\t\t})\n\t\t}\n\t\tn.ss.clearRecovering()\n\t}\n\treturn false\n}\n\nfunc (n *node) processSaveStatus() bool {\n\tif n.ss.saving() {\n\t\trec, ok := n.ss.getSaveCompleted()\n\t\tif !ok {\n\t\t\treturn !n.concurrentSnapshot()\n\t\t}\n\t\tif rec.Save && !n.initialized() {\n\t\t\tplog.Panicf(\"%s taking snapshot when uninitialized\", n.id())\n\t\t}\n\t\tn.ss.clearSaving()\n\t}\n\treturn false\n}\n\nfunc (n *node) processStreamStatus() bool {\n\tif n.ss.streaming() {\n\t\tif !n.OnDiskStateMachine() {\n\t\t\tplog.Panicf(\"non-on disk sm is streaming snapshot\")\n\t\t}\n\t\tif _, ok := n.ss.getStreamCompleted(); !ok {\n\t\t\treturn false\n\t\t}\n\t\tn.ss.clearStreaming()\n\t}\n\treturn false\n}\n\nfunc (n *node) tick(tick uint64) error {\n\tn.currentTick++\n\tn.qs.tick()\n\tif n.qs.quiesced() {\n\t\tif err := n.p.QuiescedTick(); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := n.p.Tick(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tn.pendingSnapshot.tick(tick)\n\tn.pendingProposals.tick(tick)\n\tn.pendingReadIndexes.tick(tick)\n\tn.pendingConfigChange.tick(tick)\n\treturn nil\n}\n\nfunc (n *node) notifySelfRemove() {\n\tn.sysEvents.Publish(server.SystemEvent{\n\t\tType:      server.NodeDeleted,\n\t\tShardID:   n.shardID,\n\t\tReplicaID: n.replicaID,\n\t})\n}\n\nfunc (n *node) notifyConfigChange() {\n\tm := n.sm.GetMembership()\n\tif len(m.Addresses) == 0 {\n\t\tplog.Panicf(\"empty nodes %s\", n.id())\n\t}\n\t_, isNonVoting := m.NonVotings[n.replicaID]\n\t_, isWitness := m.Witnesses[n.replicaID]\n\tci := &ShardInfo{\n\t\tShardID:           n.shardID,\n\t\tReplicaID:         n.replicaID,\n\t\tIsNonVoting:       isNonVoting,\n\t\tIsWitness:         isWitness,\n\t\tConfigChangeIndex: m.ConfigChangeId,\n\t\tReplicas:          m.Addresses,\n\t}\n\tn.shardInfo.Store(ci)\n\tn.sysEvents.Publish(server.SystemEvent{\n\t\tType:      server.MembershipChanged,\n\t\tShardID:   n.shardID,\n\t\tReplicaID: n.replicaID,\n\t})\n}\n\nfunc (n *node) getShardInfo() ShardInfo {\n\tv := n.shardInfo.Load()\n\tif v == nil {\n\t\treturn ShardInfo{\n\t\t\tShardID:          n.shardID,\n\t\t\tReplicaID:        n.replicaID,\n\t\t\tPending:          true,\n\t\t\tStateMachineType: sm.Type(n.sm.Type()),\n\t\t}\n\t}\n\tinfo := v.(*ShardInfo)\n\n\tleaderID := uint64(0)\n\tterm := uint64(0)\n\tlv := n.leaderInfo.Load()\n\tif lv != nil {\n\t\tleaderInfo := lv.(*leaderInfo)\n\t\tleaderID = leaderInfo.leaderID\n\t\tterm = leaderInfo.term\n\t}\n\n\treturn ShardInfo{\n\t\tShardID:           info.ShardID,\n\t\tReplicaID:         info.ReplicaID,\n\t\tLeaderID:          leaderID,\n\t\tTerm:              term,\n\t\tIsNonVoting:       info.IsNonVoting,\n\t\tConfigChangeIndex: info.ConfigChangeIndex,\n\t\tReplicas:          info.Replicas,\n\t\tStateMachineType:  sm.Type(n.sm.Type()),\n\t}\n}\n\nfunc (n *node) logDBBusy() bool {\n\tif n.metrics == nil {\n\t\t// only happens in tests\n\t\treturn false\n\t}\n\treturn n.metrics.isBusy()\n}\n\nfunc (n *node) id() string {\n\treturn dn(n.shardID, n.replicaID)\n}\n\nfunc (n *node) ssid(index uint64) string {\n\treturn logutil.DescribeSS(n.shardID, n.replicaID, index)\n}\n\nfunc (n *node) isLeader() bool {\n\tv := n.leaderInfo.Load()\n\tif v == nil {\n\t\treturn false\n\t}\n\tleaderInfo := v.(*leaderInfo)\n\tif leaderInfo.term == 0 {\n\t\treturn false\n\t}\n\treturn n.replicaID == leaderInfo.leaderID\n}\n\nfunc (n *node) isFollower() bool {\n\tv := n.leaderInfo.Load()\n\tif v == nil {\n\t\treturn false\n\t}\n\tleaderInfo := v.(*leaderInfo)\n\tif leaderInfo.term == 0 {\n\t\treturn false\n\t}\n\treturn n.replicaID != leaderInfo.leaderID\n}\n\nfunc (n *node) initialized() bool {\n\tif atomic.LoadUint64(&n.initializedFlag) != 0 {\n\t\treturn true\n\t}\n\tselect {\n\tcase <-n.initializedC:\n\t\tatomic.StoreUint64(&n.initializedFlag, 1)\n\t\treturn true\n\tdefault:\n\t}\n\treturn false\n}\n\nfunc (n *node) setInitialized() {\n\tclose(n.initializedC)\n}\n\nfunc (n *node) millisecondSinceStart() uint64 {\n\treturn n.tickMillisecond * n.currentTick\n}\n\nfunc (n *node) getRaftAddress() string {\n\treturn n.raftAddress\n}\n"
        },
        {
          "name": "node_test.go",
          "type": "blob",
          "size": 50.5087890625,
          "content": "// Copyright 2017-2021 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dragonboat\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/lni/goutils/leaktest\"\n\t\"github.com/lni/goutils/random\"\n\n\t\"github.com/lni/dragonboat/v4/client\"\n\t\"github.com/lni/dragonboat/v4/config\"\n\t\"github.com/lni/dragonboat/v4/internal/logdb\"\n\t\"github.com/lni/dragonboat/v4/internal/raft\"\n\t\"github.com/lni/dragonboat/v4/internal/registry\"\n\t\"github.com/lni/dragonboat/v4/internal/rsm\"\n\t\"github.com/lni/dragonboat/v4/internal/server\"\n\t\"github.com/lni/dragonboat/v4/internal/settings\"\n\t\"github.com/lni/dragonboat/v4/internal/tests\"\n\t\"github.com/lni/dragonboat/v4/internal/vfs\"\n\t\"github.com/lni/dragonboat/v4/raftio\"\n\tpb \"github.com/lni/dragonboat/v4/raftpb\"\n\tsm \"github.com/lni/dragonboat/v4/statemachine\"\n)\n\nconst (\n\traftTestTopDir            = \"raft_node_test_safe_to_delete\"\n\tlogdbDir                  = \"logdb_test_dir_safe_to_delete\"\n\tlowLatencyLogDBDir        = \"logdb_ll_test_dir_safe_to_delete\"\n\tsnapDir                   = \"snap_test_dir_safe_to_delete/snap-%d-%d\"\n\ttestShardID        uint64 = 1100\n\ttickMillisecond    uint64 = 50\n)\n\nfunc getMemberNodes(r *rsm.StateMachine) []uint64 {\n\tm := r.GetMembership()\n\tn := make([]uint64, 0)\n\tfor nid := range m.Addresses {\n\t\tn = append(n, nid)\n\t}\n\treturn n\n}\n\nfunc mustComplete(rs *RequestState, t *testing.T) {\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif !v.Completed() {\n\t\t\tt.Fatalf(\"got %v, want %v\", v.code, requestCompleted)\n\t\t}\n\tdefault:\n\t\tt.Fatalf(\"failed to complete the proposal\")\n\t}\n}\n\nfunc mustReject(rs *RequestState, t *testing.T) {\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif !v.Rejected() {\n\t\t\tt.Errorf(\"got %v, want %d\", v, requestRejected)\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"failed to complete the add node request\")\n\t}\n}\n\nfunc mustHasLeaderNode(nodes []*node, t *testing.T) *node {\n\tfor _, node := range nodes {\n\t\tif node.isLeader() {\n\t\t\treturn node\n\t\t}\n\t}\n\tt.Fatalf(\"no leader\")\n\treturn nil\n}\n\ntype testRouter struct {\n\tshardID  uint64\n\tqm       map[uint64]*server.MessageQueue\n\tdropRate uint8\n}\n\nfunc newTestRouter(shardID uint64, replicaIDList []uint64) *testRouter {\n\tm := make(map[uint64]*server.MessageQueue)\n\tfor _, replicaID := range replicaIDList {\n\t\tm[replicaID] = server.NewMessageQueue(1000, false, 0, 1024*1024*256)\n\t}\n\treturn &testRouter{qm: m, shardID: shardID}\n}\n\nfunc (r *testRouter) shouldDrop(msg pb.Message) bool {\n\tif raft.IsLocalMessageType(msg.Type) {\n\t\treturn false\n\t}\n\tif r.dropRate == 0 {\n\t\treturn false\n\t}\n\tif rand.Uint32()%100 < uint32(r.dropRate) {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (r *testRouter) send(msg pb.Message) {\n\tif msg.ShardID != r.shardID {\n\t\tpanic(\"shard id does not match\")\n\t}\n\tif r.shouldDrop(msg) {\n\t\treturn\n\t}\n\tif q, ok := r.qm[msg.To]; ok {\n\t\tq.Add(msg)\n\t}\n}\n\nfunc (r *testRouter) getQ(shardID uint64,\n\treplicaID uint64) *server.MessageQueue {\n\tif shardID != r.shardID {\n\t\tpanic(\"shard id does not match\")\n\t}\n\tq, ok := r.qm[replicaID]\n\tif !ok {\n\t\tpanic(\"node id not found in the test msg router\")\n\t}\n\treturn q\n}\n\nfunc (r *testRouter) addQ(replicaID uint64, q *server.MessageQueue) {\n\tr.qm[replicaID] = q\n}\n\nfunc cleanupTestDir(fs vfs.IFS) {\n\tif err := fs.RemoveAll(raftTestTopDir); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc getTestRaftNodes(count int, ordered bool,\n\tfs vfs.IFS) ([]*node, []*rsm.StateMachine, *testRouter, raftio.ILogDB) {\n\treturn doGetTestRaftNodes(1, count, ordered, nil, fs)\n}\n\ntype dummyEngine struct {\n}\n\nfunc (d *dummyEngine) setCloseReady(n *node)          {}\nfunc (d *dummyEngine) setStepReady(shardID uint64)    {}\nfunc (d *dummyEngine) setCommitReady(shardID uint64)  {}\nfunc (d *dummyEngine) setApplyReady(shardID uint64)   {}\nfunc (d *dummyEngine) setStreamReady(shardID uint64)  {}\nfunc (d *dummyEngine) setSaveReady(shardID uint64)    {}\nfunc (d *dummyEngine) setRecoverReady(shardID uint64) {}\n\nfunc doGetTestRaftNodes(startID uint64, count int, ordered bool,\n\tldb raftio.ILogDB, fs vfs.IFS) ([]*node, []*rsm.StateMachine,\n\t*testRouter, raftio.ILogDB) {\n\tnodes := make([]*node, 0)\n\tsmList := make([]*rsm.StateMachine, 0)\n\treplicaIDList := make([]uint64, 0)\n\t// peers map\n\tpeers := make(map[uint64]string)\n\tendID := startID + uint64(count-1)\n\tfor i := startID; i <= endID; i++ {\n\t\treplicaIDList = append(replicaIDList, i)\n\t\tpeers[i] = fmt.Sprintf(\"peer:%d\", 12345+i)\n\t}\n\t// pools\n\trequestStatePool := &sync.Pool{}\n\trequestStatePool.New = func() interface{} {\n\t\tobj := &RequestState{}\n\t\tobj.CompletedC = make(chan RequestResult, 1)\n\t\tobj.pool = requestStatePool\n\t\treturn obj\n\t}\n\tvar err error\n\tif ldb == nil {\n\t\tnodeLogDir := fs.PathJoin(raftTestTopDir, logdbDir)\n\t\tnodeLowLatencyLogDir := fs.PathJoin(raftTestTopDir, lowLatencyLogDBDir)\n\t\tif err := fs.MkdirAll(nodeLogDir, 0755); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif err := fs.MkdirAll(nodeLowLatencyLogDir, 0755); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tcfg := config.NodeHostConfig{\n\t\t\tExpert: config.GetDefaultExpertConfig(),\n\t\t}\n\t\tcfg.Expert.LogDB.Shards = 2\n\t\tcfg.Expert.FS = fs\n\t\tldb, err = logdb.NewDefaultLogDB(cfg,\n\t\t\tnil, []string{nodeLogDir}, []string{nodeLowLatencyLogDir})\n\t\tif err != nil {\n\t\t\tplog.Panicf(\"failed to open logdb, %+v\", err)\n\t\t}\n\t}\n\t// message router\n\trouter := newTestRouter(testShardID, replicaIDList)\n\tfor i := startID; i <= endID; i++ {\n\t\t// create the snapshotter object\n\t\tnodeSnapDir := fmt.Sprintf(snapDir, testShardID, i)\n\t\tsnapdir := fs.PathJoin(raftTestTopDir, nodeSnapDir)\n\t\tif err := fs.MkdirAll(snapdir, 0755); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\trootDirFunc := func(cid uint64, nid uint64) string {\n\t\t\treturn snapdir\n\t\t}\n\t\tlr := logdb.NewLogReader(testShardID, i, ldb)\n\t\tsnapshotter := newSnapshotter(testShardID, i, rootDirFunc, ldb, lr, fs)\n\t\tlr.SetCompactor(snapshotter)\n\t\t// create the sm\n\t\tnoopSM := &tests.NoOP{}\n\t\tcfg := config.Config{\n\t\t\tReplicaID:           i,\n\t\t\tShardID:             testShardID,\n\t\t\tElectionRTT:         20,\n\t\t\tHeartbeatRTT:        2,\n\t\t\tCheckQuorum:         true,\n\t\t\tSnapshotEntries:     10,\n\t\t\tCompactionOverhead:  10,\n\t\t\tOrderedConfigChange: ordered,\n\t\t}\n\t\tcreate := func(shardID uint64, replicaID uint64,\n\t\t\tdone <-chan struct{}) rsm.IManagedStateMachine {\n\t\t\treturn rsm.NewNativeSM(cfg, rsm.NewInMemStateMachine(noopSM), done)\n\t\t}\n\t\t// node registry\n\t\tnr := registry.NewNodeRegistry(settings.Soft.StreamConnections, nil)\n\t\tch := router.getQ(testShardID, i)\n\t\tnhConfig := config.NodeHostConfig{RTTMillisecond: tickMillisecond}\n\t\tnode, err := newNode(peers,\n\t\t\ttrue,\n\t\t\tcfg,\n\t\t\tnhConfig,\n\t\t\tcreate,\n\t\t\tsnapshotter,\n\t\t\tlr,\n\t\t\t&dummyEngine{},\n\t\t\tnil,\n\t\t\tnil,\n\t\t\tnil,\n\t\t\trouter.send,\n\t\t\tnr,\n\t\t\trequestStatePool,\n\t\t\tldb,\n\t\t\tnil,\n\t\t\tnewSysEventListener(nil, nil))\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tnode.mq = ch\n\t\tnodes = append(nodes, node)\n\t\tsmList = append(smList, node.sm)\n\t}\n\treturn nodes, smList, router, ldb\n}\n\nfunc step(nodes []*node) bool {\n\thasEvent := false\n\tnodeUpdates := make([]pb.Update, 0)\n\tactiveNodes := make([]*node, 0)\n\t// step the events, collect all ready structs\n\tfor _, node := range nodes {\n\t\tif !node.initialized() {\n\t\t\tcommit := rsm.Task{Initial: true}\n\t\t\tss, _ := node.sm.Recover(commit)\n\t\t\tnode.setInitialStatus(ss.Index)\n\t\t}\n\t\tif node.initialized() {\n\t\t\thasEvent, err := node.handleEvents()\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tif hasEvent {\n\t\t\t\tud, ok, err := node.getUpdate()\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t\tif ok {\n\t\t\t\t\tnodeUpdates = append(nodeUpdates, ud)\n\t\t\t\t\tactiveNodes = append(activeNodes, node)\n\t\t\t\t}\n\t\t\t\t// quiesce state\n\t\t\t\tif node.qs.newQuiesceState() {\n\t\t\t\t\tnode.sendEnterQuiesceMessages()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// batch the snapshot records together and store them into the logdb\n\tif err := nodes[0].logdb.SaveSnapshots(nodeUpdates); err != nil {\n\t\tpanic(err)\n\t}\n\tfor idx, ud := range nodeUpdates {\n\t\tnode := activeNodes[idx]\n\t\tif err := node.processSnapshot(ud); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tnode.applyRaftUpdates(ud)\n\t\tnode.sendReplicateMessages(ud)\n\t\tnode.processReadyToRead(ud)\n\t\tnode.processLeaderUpdate(ud.LeaderUpdate)\n\t}\n\t// persistent state and entries are saved first\n\t// then the snapshot. order can not be changed.\n\tif err := nodes[0].logdb.SaveRaftState(nodeUpdates, 1); err != nil {\n\t\tpanic(err)\n\t}\n\tfor idx, ud := range nodeUpdates {\n\t\tnode := activeNodes[idx]\n\t\tif err := node.processRaftUpdate(ud); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tnode.commitRaftUpdate(ud)\n\t\tif ud.LastApplied-node.ss.getReqIndex() > node.config.SnapshotEntries {\n\t\t\tif err := node.save(rsm.Task{}); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t\trec, err := node.sm.Handle(make([]rsm.Task, 0), nil)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif rec.IsSnapshotTask() {\n\t\t\tif rec.Recover || rec.Initial {\n\t\t\t\tif _, err := node.sm.Recover(rec); err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t} else if rec.Save {\n\t\t\t\tif err := node.save(rsm.Task{}); err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn hasEvent\n}\n\nfunc singleStepNodes(nodes []*node, smList []*rsm.StateMachine,\n\tr *testRouter) {\n\tfor _, node := range nodes {\n\t\ttick := node.pendingReadIndexes.getTick() + 1\n\t\ttickMsg := pb.Message{Type: pb.LocalTick, To: node.replicaID, Hint: tick}\n\t\ttickMsg.ShardID = testShardID\n\t\tr.send(tickMsg)\n\t}\n\tstep(nodes)\n}\n\nfunc stepNodes(nodes []*node, smList []*rsm.StateMachine,\n\tr *testRouter, ticks uint64) {\n\ts := ticks + 10\n\tfor i := uint64(0); i < s; i++ {\n\t\tfor _, node := range nodes {\n\t\t\ttick := node.pendingReadIndexes.getTick() + 1\n\t\t\ttickMsg := pb.Message{\n\t\t\t\tType:    pb.LocalTick,\n\t\t\t\tTo:      node.replicaID,\n\t\t\t\tShardID: testShardID,\n\t\t\t\tHint:    tick,\n\t\t\t}\n\t\t\tr.send(tickMsg)\n\t\t}\n\t\tstep(nodes)\n\t}\n}\n\nfunc stepNodesUntilThereIsLeader(nodes []*node, smList []*rsm.StateMachine,\n\tr *testRouter) {\n\tcount := 0\n\tfor {\n\t\tstepNodes(nodes, smList, r, 1)\n\t\tcount++\n\t\tif isStableGroup(nodes) {\n\t\t\tstepNodes(nodes, smList, r, 10)\n\t\t\tif isStableGroup(nodes) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif count > 200 {\n\t\t\tpanic(\"failed to has any leader after 200 second\")\n\t\t}\n\t}\n}\n\nfunc isStableGroup(nodes []*node) bool {\n\thasLeader := false\n\tinElection := false\n\tfor _, node := range nodes {\n\t\tif node.isLeader() {\n\t\t\thasLeader = true\n\t\t\tcontinue\n\t\t}\n\t\tif !node.isFollower() {\n\t\t\tinElection = true\n\t\t}\n\t}\n\treturn hasLeader && !inElection\n}\n\nfunc stopNodes(nodes []*node) {\n\tfor _, node := range nodes {\n\t\tnode.close()\n\t}\n}\n\nfunc TestNodeCanBeCreatedAndStarted(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tdefer leaktest.AfterTest(t)()\n\tdefer cleanupTestDir(fs)\n\tnodes, smList, router, ldb := getTestRaftNodes(3, false, fs)\n\tif len(nodes) != 3 {\n\t\tt.Errorf(\"len(nodes)=%d, want 3\", len(nodes))\n\t}\n\tif len(smList) != 3 {\n\t\tt.Errorf(\"len(smList)=%d, want 3\", len(smList))\n\t}\n\tdefer stopNodes(nodes)\n\tdefer ldb.Close()\n\tstepNodesUntilThereIsLeader(nodes, smList, router)\n}\n\nfunc getMaxLastApplied(smList []*rsm.StateMachine) uint64 {\n\tmaxLastApplied := uint64(0)\n\tfor _, sm := range smList {\n\t\tla := sm.GetLastApplied()\n\t\tif la > maxLastApplied {\n\t\t\tmaxLastApplied = la\n\t\t}\n\t}\n\treturn maxLastApplied\n}\n\nfunc getProposalTestClient(n *node,\n\tnodes []*node, smList []*rsm.StateMachine,\n\trouter *testRouter) (*client.Session, bool) {\n\tcs := client.NewSession(n.shardID, random.NewLockedRand())\n\tcs.PrepareForRegister()\n\trs, err := n.pendingProposals.propose(cs, nil, 50)\n\tif err != nil {\n\t\tplog.Errorf(\"error: %v\", err)\n\t\treturn nil, false\n\t}\n\tstepNodes(nodes, smList, router, 50)\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif v.Completed() && v.GetResult().Value == cs.ClientID {\n\t\t\tcs.PrepareForPropose()\n\t\t\treturn cs, true\n\t\t}\n\t\tplog.Infof(\"unknown result/code: %v\", v)\n\tcase <-n.stopC:\n\t\tplog.Errorf(\"stopc triggered\")\n\t\treturn nil, false\n\t}\n\tplog.Errorf(\"failed get test client\")\n\treturn nil, false\n}\n\nfunc closeProposalTestClient(n *node,\n\tnodes []*node, smList []*rsm.StateMachine,\n\trouter *testRouter, session *client.Session) {\n\tsession.PrepareForUnregister()\n\trs, err := n.pendingProposals.propose(session, nil, 50)\n\tif err != nil {\n\t\treturn\n\t}\n\tstepNodes(nodes, smList, router, 50)\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif v.Completed() && v.GetResult().Value == session.ClientID {\n\t\t\treturn\n\t\t}\n\tcase <-n.stopC:\n\t\treturn\n\t}\n}\n\nfunc makeCheckedTestProposal(t *testing.T, session *client.Session,\n\tdata []byte, timeoutInMillisecond uint64,\n\tnodes []*node, smList []*rsm.StateMachine, router *testRouter,\n\texpectedCode RequestResultCode, checkResult bool, expectedResult uint64) {\n\tn := mustHasLeaderNode(nodes, t)\n\ttick := uint64(50)\n\trs, err := n.propose(session, data, tick)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to make proposal\")\n\t}\n\tstepNodes(nodes, smList, router, tick)\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif v.code != expectedCode {\n\t\t\tt.Errorf(\"got %v, want %d\", v, expectedCode)\n\t\t}\n\t\tif checkResult {\n\t\t\tif v.GetResult().Value != expectedResult {\n\t\t\t\tt.Errorf(\"result %d, want %d\", v.GetResult(), expectedResult)\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"failed to complete the proposal\")\n\t}\n}\n\nfunc runRaftNodeTest(t *testing.T, quiesce bool, ordered bool,\n\ttf func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB), fs vfs.IFS) {\n\tdefer leaktest.AfterTest(t)()\n\tdefer cleanupTestDir(fs)\n\tnodes, smList, router, ldb := getTestRaftNodes(3, ordered, fs)\n\tif quiesce {\n\t\tfor idx := range nodes {\n\t\t\t(nodes[idx]).qs.enabled = true\n\t\t}\n\t\tfor _, node := range nodes {\n\t\t\tif node.qs.quiesced() {\n\t\t\t\tt.Errorf(\"node quiesced on startup\")\n\t\t\t}\n\t\t}\n\t}\n\tstepNodesUntilThereIsLeader(nodes, smList, router)\n\tif len(nodes) != 3 {\n\t\tt.Fatalf(\"failed to get 3 nodes\")\n\t}\n\tdefer stopNodes(nodes)\n\tdefer ldb.Close()\n\ttf(t, nodes, smList, router, ldb)\n}\n\nfunc TestLastAppliedValueCanBeReturned(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\tsm := smList[0]\n\t\tfor i := uint64(5); i <= 100; i++ {\n\t\t\tsm.SetLastApplied(i)\n\t\t\thasEvent, err := n.handleEvents()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t\t}\n\t\t\tif !hasEvent {\n\t\t\t\tt.Errorf(\"handle events reported no event\")\n\t\t\t}\n\t\t\tud, ok, err := n.getUpdate()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t\t}\n\t\t\tif !ok {\n\t\t\t\tt.Errorf(\"no update\")\n\t\t\t} else {\n\t\t\t\tif ud.LastApplied != i {\n\t\t\t\t\tt.Errorf(\"last applied value not returned, got %d want %d\",\n\t\t\t\t\t\tud.LastApplied, i)\n\t\t\t\t}\n\t\t\t}\n\t\t\tud.UpdateCommit.LastApplied = 0\n\t\t\tn.p.Commit(ud)\n\t\t}\n\t\thasEvents, err := n.handleEvents()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t}\n\t\tif hasEvents {\n\t\t\tt.Errorf(\"unexpected event\")\n\t\t}\n\t\tud, ok, err := n.getUpdate()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t}\n\t\tif ok {\n\t\t\tt.Errorf(\"unexpected update, %+v\", ud)\n\t\t}\n\t}\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestLastAppliedValueIsAlwaysOneWayIncreasing(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Fatalf(\"not panic\")\n\t\t\t}\n\t\t}()\n\t\tn := nodes[0]\n\t\tsm := smList[0]\n\t\tsm.SetLastApplied(1)\n\t\tif _, err := n.handleEvents(); err != nil {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t}\n\t\tif _, _, err := n.getUpdate(); err != nil {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t}\n\t}\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestProposalCanBeMadeWithMessageDrops(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\trouter.dropRate = 3\n\t\tn := mustHasLeaderNode(nodes, t)\n\t\tvar ok bool\n\t\tvar session *client.Session\n\t\tfor i := 0; i < 3; i++ {\n\t\t\tsession, ok = getProposalTestClient(n, nodes, smList, router)\n\t\t\tif ok {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif session == nil {\n\t\t\tt.Errorf(\"failed to get session\")\n\t\t\treturn\n\t\t}\n\t\tfor i := 0; i < 20; i++ {\n\t\t\tmaxLastApplied := getMaxLastApplied(smList)\n\t\t\tmakeCheckedTestProposal(t, session, []byte(\"test-data\"), 4000,\n\t\t\t\tnodes, smList, router, requestCompleted, false, 0)\n\t\t\tsession.ProposalCompleted()\n\t\t\tif getMaxLastApplied(smList) != maxLastApplied+1 {\n\t\t\t\tt.Errorf(\"didn't move the last applied value in smList\")\n\t\t\t}\n\t\t}\n\t\tcloseProposalTestClient(n, nodes, smList, router, session)\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestLeaderIDCanBeQueried(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\tv, _, ok := n.getLeaderID()\n\t\tif !ok {\n\t\t\tt.Errorf(\"failed to get leader id\")\n\t\t}\n\t\tif v < 1 || v > 3 {\n\t\t\tt.Errorf(\"unexpected leader id %d\", v)\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestMembershipCanBeLocallyRead(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\tm := n.sm.GetMembership()\n\t\tv := m.Addresses\n\t\tif len(v) != 3 {\n\t\t\tt.Errorf(\"unexpected member count %d\", len(v))\n\t\t}\n\t\taddr1, ok := v[1]\n\t\tif !ok || addr1 != \"peer:12346\" {\n\t\t\tt.Errorf(\"unexpected membership data %v\", v)\n\t\t}\n\t\taddr2, ok := v[2]\n\t\tif !ok || addr2 != \"peer:12347\" {\n\t\t\tt.Errorf(\"unexpected membership data %v\", v)\n\t\t}\n\t\taddr3, ok := v[3]\n\t\tif !ok || addr3 != \"peer:12348\" {\n\t\t\tt.Errorf(\"unexpected membership data %v\", v)\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestConfigChangeOnWitnessWillBeRejected(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\tn.config.IsWitness = true\n\t\t_, err := n.requestConfigChange(pb.AddNode, 100, \"noidea:9090\", 0, 10)\n\t\tif err != ErrInvalidOperation {\n\t\t\tt.Errorf(\"config change not rejected\")\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestReadOnWitnessWillBeRejected(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\tn.config.IsWitness = true\n\t\t_, err := n.read(10)\n\t\tif err != ErrInvalidOperation {\n\t\t\tt.Errorf(\"read not rejected\")\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestMakingProposalOnWitnessNodeWillBeRejected(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\tn.config.IsWitness = true\n\t\tcs := client.NewNoOPSession(n.shardID, random.NewLockedRand())\n\t\t_, err := n.propose(cs, make([]byte, 1), 10)\n\t\tif err != ErrInvalidOperation {\n\t\t\tt.Errorf(\"making proposal not rejected\")\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestProposingSessionOnWitnessNodeWillBeRejected(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\tn.config.IsWitness = true\n\t\t_, err := n.proposeSession(nil, 10)\n\t\tif err != ErrInvalidOperation {\n\t\t\tt.Errorf(\"proposing session not rejected\")\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestRequestingSnapshotOnWitnessWillBeRejected(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\tn.config.IsWitness = true\n\t\t_, err := n.requestSnapshot(SnapshotOption{}, 10)\n\t\tif err != ErrInvalidOperation {\n\t\t\tt.Errorf(\"requesting snapshot not rejected\")\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestProposalWithClientSessionCanBeMade(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\tsession, ok := getProposalTestClient(n, nodes, smList, router)\n\t\tif !ok {\n\t\t\tt.Errorf(\"failed to get session\")\n\t\t\treturn\n\t\t}\n\t\tdata := []byte(\"test-data\")\n\t\tmaxLastApplied := getMaxLastApplied(smList)\n\t\tmakeCheckedTestProposal(t, session, data, 4000,\n\t\t\tnodes, smList, router, requestCompleted, true, uint64(len(data)))\n\n\t\tif getMaxLastApplied(smList) != maxLastApplied+1 {\n\t\t\tt.Errorf(\"didn't move the last applied value in smList\")\n\t\t}\n\t\tcloseProposalTestClient(n, nodes, smList, router, session)\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestProposalWithNotRegisteredClientWillBeRejected(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\tsession, ok := getProposalTestClient(n, nodes, smList, router)\n\t\tif !ok {\n\t\t\tt.Errorf(\"failed to get session\")\n\t\t\treturn\n\t\t}\n\t\tsession.ClientID = 123456789\n\t\tdata := []byte(\"test-data\")\n\t\tmaxLastApplied := getMaxLastApplied(smList)\n\t\tmakeCheckedTestProposal(t, session, data, 2000,\n\t\t\tnodes, smList, router, requestRejected, true, 0)\n\t\tif getMaxLastApplied(smList) != maxLastApplied+1 {\n\t\t\tt.Errorf(\"didn't move the last applied value in smList\")\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestDuplicatedProposalReturnsTheSameResult(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\tsession, ok := getProposalTestClient(n, nodes, smList, router)\n\t\tif !ok {\n\t\t\tt.Errorf(\"failed to get session\")\n\t\t\treturn\n\t\t}\n\t\tdata := []byte(\"test-data\")\n\t\tmaxLastApplied := getMaxLastApplied(smList)\n\t\tmakeCheckedTestProposal(t, session, data, 2000,\n\t\t\tnodes, smList, router, requestCompleted, true, uint64(len(data)))\n\t\tif getMaxLastApplied(smList) != maxLastApplied+1 {\n\t\t\tt.Errorf(\"didn't move the last applied value in smList\")\n\t\t}\n\t\tdata = []byte(\"test-data-2\")\n\t\tmaxLastApplied = getMaxLastApplied(smList)\n\t\tmakeCheckedTestProposal(t, session, data, 2000,\n\t\t\tnodes, smList, router, requestCompleted, true, uint64(len(data)-2))\n\t\tif getMaxLastApplied(smList) != maxLastApplied+1 {\n\t\t\tt.Errorf(\"didn't move the last applied value in smList\")\n\t\t}\n\t\tcloseProposalTestClient(n, nodes, smList, router, session)\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestReproposeRespondedDataWillTimeout(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\tsession, ok := getProposalTestClient(n, nodes, smList, router)\n\t\tif !ok {\n\t\t\tt.Errorf(\"failed to get session\")\n\t\t\treturn\n\t\t}\n\t\tdata := []byte(\"test-data\")\n\t\tmaxLastApplied := getMaxLastApplied(smList)\n\t\t_, err := n.propose(session, data, 10)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to make proposal\")\n\t\t}\n\t\tstepNodes(nodes, smList, router, 10)\n\t\tif getMaxLastApplied(smList) != maxLastApplied+1 {\n\t\t\tt.Errorf(\"didn't move the last applied value in smList\")\n\t\t}\n\t\trespondedSeriesID := session.SeriesID\n\t\tsession.ProposalCompleted()\n\t\tfor i := 0; i < 3; i++ {\n\t\t\tmakeCheckedTestProposal(t, session, data, 2000,\n\t\t\t\tnodes, smList, router, requestCompleted, true, uint64(len(data)))\n\t\t\tsession.ProposalCompleted()\n\t\t\trespondedSeriesID = session.RespondedTo\n\t\t}\n\t\tsession.SeriesID = respondedSeriesID\n\t\tplog.Infof(\"series id %d, responded to %d\",\n\t\t\tsession.SeriesID, session.RespondedTo)\n\t\trs, _ := n.propose(session, data, 10)\n\t\tstepNodes(nodes, smList, router, 10)\n\t\tselect {\n\t\tcase v := <-rs.ResultC():\n\t\t\tif !v.Timeout() {\n\t\t\t\tt.Errorf(\"didn't timeout, v: %d\", v.code)\n\t\t\t}\n\t\tdefault:\n\t\t\tt.Errorf(\"failed to complete the proposal\")\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestProposalsWithIllFormedSessionAreChecked(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\ts1 := client.NewSession(n.shardID, random.NewLockedRand())\n\t\ts1.SeriesID = client.SeriesIDForRegister\n\t\t_, err := n.propose(s1, nil, 10)\n\t\tif err != ErrInvalidSession {\n\t\t\tt.Errorf(\"not rejected\")\n\t\t}\n\t\ts1 = client.NewSession(n.shardID, random.NewLockedRand())\n\t\ts1.SeriesID = client.SeriesIDForUnregister\n\t\t_, err = n.propose(s1, nil, 10)\n\t\tif err != ErrInvalidSession {\n\t\t\tt.Errorf(\"not rejected\")\n\t\t}\n\t\ts1 = client.NewSession(n.shardID, random.NewLockedRand())\n\t\ts1.SeriesID = 100\n\t\ts1.ShardID = 123456\n\t\t_, err = n.propose(s1, nil, 10)\n\t\tif err != ErrInvalidSession {\n\t\t\tt.Errorf(\"not rejected\")\n\t\t}\n\t\ts1 = client.NewSession(n.shardID, random.NewLockedRand())\n\t\ts1.SeriesID = 1\n\t\ts1.ClientID = 0\n\t\t_, err = n.propose(s1, nil, 10)\n\t\tif err != ErrInvalidSession {\n\t\t\tt.Errorf(\"not rejected\")\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestProposalsWithCorruptedSessionWillPanic(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\ts1 := client.NewSession(n.shardID, random.NewLockedRand())\n\t\ts1.SeriesID = 100\n\t\ts1.RespondedTo = 200\n\t\tdefer func() {\n\t\t\tr := recover()\n\t\t\tif r == nil {\n\t\t\t\tt.Errorf(\"panic not triggered\")\n\t\t\t}\n\t\t}()\n\t\t_, err := n.propose(s1, nil, 10)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to make proposal %v\", err)\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestRaftNodeQuiesceCanBeDisabled(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tdefer leaktest.AfterTest(t)()\n\t// quiesce is disabled by default\n\tdefer cleanupTestDir(fs)\n\tnodes, smList, router, ldb := getTestRaftNodes(3, false, fs)\n\tif len(nodes) != 3 {\n\t\tt.Fatalf(\"failed to get 3 nodes\")\n\t}\n\tfor _, node := range nodes {\n\t\tif node.qs.quiesced() {\n\t\t\tt.Errorf(\"node quiesced on startup\")\n\t\t}\n\t}\n\tstepNodesUntilThereIsLeader(nodes, smList, router)\n\tdefer stopNodes(nodes)\n\tdefer ldb.Close()\n\t// need to step more than quiesce.threshold() as the startup\n\t// config change messages are going to be recorded as activities\n\tfor i := uint64(0); i <= nodes[0].qs.threshold()*2; i++ {\n\t\tsingleStepNodes(nodes, smList, router)\n\t}\n\tfor _, node := range nodes {\n\t\tif node.qs.quiesced() {\n\t\t\tt.Errorf(\"node is quiesced when quiesce is not enabled\")\n\t\t}\n\t}\n}\n\nfunc TestNodesCanEnterQuiesce(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\t// need to step more than quiesce.threshold() as the startup\n\t\t// config change messages are going to be recorded as activities\n\t\tfor i := uint64(0); i <= nodes[0].qs.threshold()*2; i++ {\n\t\t\tsingleStepNodes(nodes, smList, router)\n\t\t}\n\t\tfor _, node := range nodes {\n\t\t\tif !node.qs.quiesced() {\n\t\t\t\tt.Errorf(\"node failed to enter quiesced\")\n\t\t\t}\n\t\t}\n\t\t// step more, nodes should stay in quiesce state.\n\t\tfor i := uint64(0); i <= nodes[0].qs.threshold()*3; i++ {\n\t\t\tsingleStepNodes(nodes, smList, router)\n\t\t}\n\t\tfor _, node := range nodes {\n\t\t\tif !node.qs.quiesced() {\n\t\t\t\tt.Errorf(\"node failed to enter quiesced\")\n\t\t\t}\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, true, false, tf, fs)\n}\n\nfunc TestNodesCanExitQuiesceByMakingProposal(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\t// need to step more than quiesce.threshold() as the startup\n\t\t// config change messages are going to be recorded as activities\n\t\tfor i := uint64(0); i <= nodes[0].qs.threshold()*2; i++ {\n\t\t\tsingleStepNodes(nodes, smList, router)\n\t\t}\n\t\tfor _, node := range nodes {\n\t\t\tif !node.qs.quiesced() {\n\t\t\t\tt.Errorf(\"node failed to enter quiesced\")\n\t\t\t}\n\t\t}\n\t\tn := nodes[0]\n\t\tdone := false\n\t\tfor i := 0; i < 5; i++ {\n\t\t\t_, ok := getProposalTestClient(n, nodes, smList, router)\n\t\t\tif ok {\n\t\t\t\tdone = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !done {\n\t\t\tt.Errorf(\"failed to get proposal client -- didn't exit from quiesce?\")\n\t\t}\n\t\tfor i := uint64(0); i <= 3; i++ {\n\t\t\tsingleStepNodes(nodes, smList, router)\n\t\t}\n\t\tfor _, node := range nodes {\n\t\t\tif node.qs.quiesced() {\n\t\t\t\tt.Errorf(\"node failed to exit from quiesced\")\n\t\t\t}\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, true, false, tf, fs)\n}\n\nfunc TestNodesCanExitQuiesceByReadIndex(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\t// need to step more than quiesce.threshold() as the startup\n\t\t// config change messages are going to be recorded as activities\n\t\tfor i := uint64(0); i <= nodes[0].qs.threshold()*2; i++ {\n\t\t\tsingleStepNodes(nodes, smList, router)\n\t\t}\n\t\tfor _, node := range nodes {\n\t\t\tif !node.qs.quiesced() {\n\t\t\t\tt.Errorf(\"node failed to enter quiesced\")\n\t\t\t}\n\t\t}\n\t\tn := nodes[0]\n\t\trs, err := n.read(10)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to read\")\n\t\t}\n\t\tvar done bool\n\t\tfor i := uint64(0); i <= 5; i++ {\n\t\t\tsingleStepNodes(nodes, smList, router)\n\t\t\tselect {\n\t\t\tcase <-rs.ResultC():\n\t\t\t\tdone = true\n\t\t\tdefault:\n\t\t\t}\n\t\t\tif done {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tfor _, node := range nodes {\n\t\t\tif node.qs.quiesced() {\n\t\t\t\tt.Errorf(\"node failed to exit from quiesced\")\n\t\t\t}\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, true, false, tf, fs)\n}\n\nfunc TestNodesCanExitQuiesceByConfigChange(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\t// need to step more than quiesce.threshold() as the startup\n\t\t// config change messages are going to be recorded as activities\n\t\tfor i := uint64(0); i <= nodes[0].qs.threshold()*2; i++ {\n\t\t\tsingleStepNodes(nodes, smList, router)\n\t\t}\n\t\tfor _, node := range nodes {\n\t\t\tif !node.qs.quiesced() {\n\t\t\t\tt.Errorf(\"node failed to enter quiesced\")\n\t\t\t}\n\t\t}\n\t\tn := nodes[0]\n\t\tdone := false\n\t\tfor i := 0; i < 5; i++ {\n\t\t\trs, err := n.requestAddNodeWithOrderID(24680, \"localhost:12345\", 0, 10)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"request to add node failed, %v\", err)\n\t\t\t}\n\t\t\thasResp := false\n\t\t\tfor i := uint64(0); i < 25; i++ {\n\t\t\t\tsingleStepNodes(nodes, smList, router)\n\t\t\t\tselect {\n\t\t\t\tcase v := <-rs.ResultC():\n\t\t\t\t\tif v.Completed() {\n\t\t\t\t\t\tdone = true\n\t\t\t\t\t}\n\t\t\t\t\thasResp = true\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !hasResp {\n\t\t\t\tt.Errorf(\"config change timeout not fired\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif done {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tfor i := uint64(0); i < 20; i++ {\n\t\t\tsingleStepNodes(nodes, smList, router)\n\t\t}\n\t\tfor _, node := range nodes {\n\t\t\tif node.qs.quiesced() {\n\t\t\t\tt.Errorf(\"node failed to exit from quiesced\")\n\t\t\t}\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, true, false, tf, fs)\n}\n\nfunc TestLinearizableReadCanBeMade(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\tsession, ok := getProposalTestClient(n, nodes, smList, router)\n\t\tif !ok {\n\t\t\tt.Errorf(\"failed to get session\")\n\t\t\treturn\n\t\t}\n\t\trs, err := n.propose(session, []byte(\"test-data\"), 10)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to make proposal\")\n\t\t}\n\t\tstepNodes(nodes, smList, router, 10)\n\t\tmustComplete(rs, t)\n\t\tcloseProposalTestClient(n, nodes, smList, router, session)\n\t\trs, err = n.read(10)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"\")\n\t\t}\n\t\tif rs.node == nil {\n\t\t\tt.Fatalf(\"rs.node not set\")\n\t\t}\n\t\tstepNodes(nodes, smList, router, 10)\n\t\tmustComplete(rs, t)\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc testNodeCanBeAdded(t *testing.T, fs vfs.IFS) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\trouter.dropRate = 3\n\t\tn := mustHasLeaderNode(nodes, t)\n\t\trs, err := n.requestAddNodeWithOrderID(4, \"a4:4\", 0, 10)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"request to delete node failed\")\n\t\t}\n\t\tstepNodes(nodes, smList, router, 10)\n\t\tmustComplete(rs, t)\n\t\tfor _, node := range nodes {\n\t\t\tif !sliceEqual([]uint64{1, 2, 3, 4}, getMemberNodes(node.sm)) {\n\t\t\t\tt.Errorf(\"failed to delete the node, %v\", getMemberNodes(node.sm))\n\t\t\t}\n\t\t}\n\t}\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestNodeCanBeAddedWithMessageDrops(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tdefer leaktest.AfterTest(t)()\n\tfor i := 0; i < 10; i++ {\n\t\ttestNodeCanBeAdded(t, fs)\n\t}\n}\n\nfunc TestNodeCanBeDeleted(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\trs, err := n.requestDeleteNodeWithOrderID(2, 0, 10)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"request to delete node failed\")\n\t\t}\n\t\tstepNodes(nodes, smList, router, 10)\n\t\tmustComplete(rs, t)\n\t\tif nodes[0].stopped() {\n\t\t\tt.Errorf(\"node id 1 is not suppose to be in stopped state\")\n\t\t}\n\t\tif !nodes[1].stopped() {\n\t\t\tt.Errorf(\"node is not stopped\")\n\t\t}\n\t\tif nodes[2].stopped() {\n\t\t\tt.Errorf(\"node id 3 is not suppose to be in stopped state\")\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc sliceEqual(s1 []uint64, s2 []uint64) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tsort.Slice(s1, func(i, j int) bool { return s1[i] < s1[j] })\n\tsort.Slice(s2, func(i, j int) bool { return s2[i] < s2[j] })\n\tfor idx, v := range s1 {\n\t\tif v != s2[idx] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc TestNodeCanBeAdded2(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tfs := vfs.GetTestFS()\n\t\tn := nodes[0]\n\t\tsession, ok := getProposalTestClient(n, nodes, smList, router)\n\t\tif !ok {\n\t\t\tt.Errorf(\"failed to get session\")\n\t\t\treturn\n\t\t}\n\t\tfor i := 0; i < 5; i++ {\n\t\t\trs, err := n.propose(session, []byte(\"test-data\"), 10)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"\")\n\t\t\t}\n\t\t\tstepNodes(nodes, smList, router, 10)\n\t\t\tmustComplete(rs, t)\n\t\t\tsession.ProposalCompleted()\n\t\t}\n\t\tcloseProposalTestClient(n, nodes, smList, router, session)\n\t\trs, err := n.requestAddNodeWithOrderID(4, \"a4:4\", 0, 10)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"request to add node failed\")\n\t\t}\n\t\tstepNodes(nodes, smList, router, 10)\n\t\tmustComplete(rs, t)\n\t\tfor _, node := range nodes {\n\t\t\tif node.stopped() {\n\t\t\t\tt.Errorf(\"node %d is stopped, this is unexpected\", node.replicaID)\n\t\t\t}\n\t\t\tif !sliceEqual([]uint64{1, 2, 3, 4}, getMemberNodes(node.sm)) {\n\t\t\t\tt.Errorf(\"node members not expected: %v\", getMemberNodes(node.sm))\n\t\t\t}\n\t\t}\n\t\t// now bring the node 5 online\n\t\tnewNodes, newSMList, newRouter, _ := doGetTestRaftNodes(4, 1, true, ldb, fs)\n\t\tif len(newNodes) != 1 {\n\t\t\tt.Fatalf(\"failed to get 1 nodes\")\n\t\t}\n\t\trouter.addQ(4, newRouter.qm[4])\n\t\tnodes = append(nodes, newNodes[0])\n\t\tsmList = append(smList, newSMList[0])\n\t\tnodes[3].sendRaftMessage = router.send\n\t\tstepNodes(nodes, smList, router, 100)\n\t\tif smList[0].GetLastApplied() != newSMList[0].GetLastApplied() {\n\t\t\tt.Errorf(\"last applied: %d, want %d\",\n\t\t\t\tnewSMList[0].GetLastApplied(), smList[0].GetLastApplied())\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestNodeCanBeAddedWhenOrderIsEnforced(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\trs, err := n.requestAddNodeWithOrderID(5, \"a5:5\", 0, 10)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"request to add node failed\")\n\t\t}\n\t\tstepNodes(nodes, smList, router, 10)\n\t\tmustReject(rs, t)\n\t\tfor _, node := range nodes {\n\t\t\tif node.stopped() {\n\t\t\t\tt.Errorf(\"node %d is stopped, this is unexpected\", node.replicaID)\n\t\t\t}\n\t\t\tif !sliceEqual([]uint64{1, 2, 3}, getMemberNodes(node.sm)) {\n\t\t\t\tt.Errorf(\"node members not expected: %v\", getMemberNodes(node.sm))\n\t\t\t}\n\t\t}\n\t\tm := n.sm.GetMembership()\n\t\tccid := m.ConfigChangeId\n\t\trs, err = n.requestAddNodeWithOrderID(5, \"a5:5\", ccid, 10)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"request to add node failed\")\n\t\t}\n\t\tstepNodes(nodes, smList, router, 10)\n\t\tmustComplete(rs, t)\n\t\tfor _, node := range nodes {\n\t\t\tif node.stopped() {\n\t\t\t\tt.Errorf(\"node %d is stopped, this is unexpected\", node.replicaID)\n\t\t\t}\n\t\t\tif !sliceEqual([]uint64{1, 2, 3, 5}, getMemberNodes(node.sm)) {\n\t\t\t\tt.Errorf(\"node members not expected: %v\", getMemberNodes(node.sm))\n\t\t\t}\n\t\t}\n\t}\n\trunRaftNodeTest(t, false, true, tf, fs)\n}\n\nfunc TestNodeCanBeDeletedWhenOrderIsEnforced(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\trs, err := n.requestDeleteNodeWithOrderID(2, 0, 10)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"request to delete node failed\")\n\t\t}\n\t\tstepNodes(nodes, smList, router, 10)\n\t\tmustReject(rs, t)\n\t\tfor _, node := range nodes {\n\t\t\tif node.stopped() {\n\t\t\t\tt.Errorf(\"node %d is stopped, this is unexpected\", node.replicaID)\n\t\t\t}\n\t\t\tif !sliceEqual([]uint64{1, 2, 3}, getMemberNodes(node.sm)) {\n\t\t\t\tt.Errorf(\"node members not expected: %v\", getMemberNodes(node.sm))\n\t\t\t}\n\t\t}\n\t\tm := n.sm.GetMembership()\n\t\tccid := m.ConfigChangeId\n\t\trs, err = n.requestDeleteNodeWithOrderID(2, ccid, 10)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"request to add node failed\")\n\t\t}\n\t\tstepNodes(nodes, smList, router, 10)\n\t\tmustComplete(rs, t)\n\t\tfor _, node := range nodes {\n\t\t\tif node.replicaID == 2 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !sliceEqual([]uint64{1, 3}, getMemberNodes(node.sm)) {\n\t\t\t\tt.Errorf(\"node members not expected: %v\", getMemberNodes(node.sm))\n\t\t\t}\n\t\t}\n\t}\n\trunRaftNodeTest(t, false, true, tf, fs)\n}\n\nfunc getSnapshotFileCount(dir string, fs vfs.IFS) (int, error) {\n\tfiList, err := fs.List(dir)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tcount := 0\n\tfor _, fn := range fiList {\n\t\tfi, err := fs.Stat(fs.PathJoin(dir, fn))\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tif !fi.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.HasPrefix(fi.Name(), \"snapshot-\") {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count, nil\n}\n\nfunc TestSnapshotCanBeMade(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\tsession, ok := getProposalTestClient(n, nodes, smList, router)\n\t\tif !ok {\n\t\t\tt.Errorf(\"failed to get session\")\n\t\t\treturn\n\t\t}\n\t\tmaxLastApplied := getMaxLastApplied(smList)\n\t\tproposalCount := 50\n\t\tfor i := 0; i < proposalCount; i++ {\n\t\t\tdata := fmt.Sprintf(\"test-data-%d\", i)\n\t\t\trs, err := n.propose(session, []byte(data), 10)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to make proposal\")\n\t\t\t}\n\t\t\tstepNodes(nodes, smList, router, 10)\n\t\t\tmustComplete(rs, t)\n\t\t\tsession.ProposalCompleted()\n\t\t}\n\t\tif getMaxLastApplied(smList) != maxLastApplied+uint64(proposalCount) {\n\t\t\tt.Errorf(\"not all %d proposals applied\", proposalCount)\n\t\t}\n\t\tcloseProposalTestClient(n, nodes, smList, router, session)\n\t\t// check we do have snapshots saved on disk\n\t\tfor _, node := range nodes {\n\t\t\tsd := fmt.Sprintf(snapDir, testShardID, node.replicaID)\n\t\t\tdir := fs.PathJoin(raftTestTopDir, sd)\n\t\t\tcount, err := getSnapshotFileCount(dir, fs)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to get snapshot count\")\n\t\t\t}\n\t\t\tif count == 0 {\n\t\t\t\tt.Errorf(\"no snapshot image\")\n\t\t\t}\n\t\t}\n\t}\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestSnapshotCanBeMadeTwice(t *testing.T) {\n\ttf := func(t *testing.T, nodes []*node,\n\t\tsmList []*rsm.StateMachine, router *testRouter, ldb raftio.ILogDB) {\n\t\tn := nodes[0]\n\t\tsession, ok := getProposalTestClient(n, nodes, smList, router)\n\t\tif !ok {\n\t\t\tt.Errorf(\"failed to get session\")\n\t\t\treturn\n\t\t}\n\t\tmaxLastApplied := getMaxLastApplied(smList)\n\t\tproposalCount := 50\n\t\tfor i := 0; i < proposalCount; i++ {\n\t\t\tdata := fmt.Sprintf(\"test-data-%d\", i)\n\t\t\trs, err := n.propose(session, []byte(data), 10)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to make proposal\")\n\t\t\t}\n\t\t\tstepNodes(nodes, smList, router, 10)\n\t\t\tmustComplete(rs, t)\n\t\t\tsession.ProposalCompleted()\n\t\t}\n\t\tif getMaxLastApplied(smList) != maxLastApplied+uint64(proposalCount) {\n\t\t\tt.Errorf(\"not all %d proposals applied\", proposalCount)\n\t\t}\n\t\tcloseProposalTestClient(n, nodes, smList, router, session)\n\t\t// check we do have snapshots saved on disk\n\t\tfor _, node := range nodes {\n\t\t\tif err := node.save(rsm.Task{}); err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif err := node.save(rsm.Task{}); err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunRaftNodeTest(t, false, false, tf, fs)\n}\n\nfunc TestNodesCanBeRestarted(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tdefer leaktest.AfterTest(t)()\n\tdefer cleanupTestDir(fs)\n\tnodes, smList, router, ldb := getTestRaftNodes(3, false, fs)\n\tif len(nodes) != 3 {\n\t\tt.Fatalf(\"failed to get 3 nodes\")\n\t}\n\tstepNodesUntilThereIsLeader(nodes, smList, router)\n\tn := mustHasLeaderNode(nodes, t)\n\tsession, ok := getProposalTestClient(n, nodes, smList, router)\n\tif !ok {\n\t\tt.Errorf(\"failed to get session\")\n\t\treturn\n\t}\n\tmaxLastApplied := getMaxLastApplied(smList)\n\tfor i := 0; i < 25; i++ {\n\t\trs, err := n.propose(session, []byte(\"test-data\"), 10)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"\")\n\t\t}\n\t\tstepNodes(nodes, smList, router, 10)\n\t\tmustComplete(rs, t)\n\t\tsession.ProposalCompleted()\n\t}\n\tif getMaxLastApplied(smList) != maxLastApplied+25 {\n\t\tt.Errorf(\"not all %d proposals applied\", 25)\n\t}\n\tcloseProposalTestClient(n, nodes, smList, router, session)\n\tfor _, node := range nodes {\n\t\tsd := fmt.Sprintf(snapDir, testShardID, node.replicaID)\n\t\tdir := fs.PathJoin(raftTestTopDir, sd)\n\t\tcount, err := getSnapshotFileCount(dir, fs)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to get snapshot count\")\n\t\t}\n\t\tif count == 0 {\n\t\t\tt.Fatalf(\"no snapshot available, count: %d\", count)\n\t\t}\n\t}\n\t// stop the whole thing\n\tfor _, node := range nodes {\n\t\tnode.close()\n\t}\n\tldb.Close()\n\t// restart\n\tnodes, smList, router, ldb = getTestRaftNodes(3, false, fs)\n\tdefer stopNodes(nodes)\n\tdefer ldb.Close()\n\tif len(nodes) != 3 {\n\t\tt.Fatalf(\"failed to get 3 nodes\")\n\t}\n\tstepNodesUntilThereIsLeader(nodes, smList, router)\n\tstepNodes(nodes, smList, router, 100)\n\tif getMaxLastApplied(smList) < maxLastApplied+5 {\n\t\tt.Errorf(\"not recovered from snapshot, got %d, marker %d\",\n\t\t\tgetMaxLastApplied(smList), maxLastApplied+5)\n\t}\n}\n\nfunc TestGetTimeoutMillisecondFromContext(t *testing.T) {\n\tdefer leaktest.AfterTest(t)()\n\t_, err := getTimeoutFromContext(context.Background())\n\tif err != ErrDeadlineNotSet {\n\t\tt.Errorf(\"err %v, want ErrDeadlineNotSet\", err)\n\t}\n\td := time.Now()\n\ttime.Sleep(100 * time.Millisecond)\n\tctx, cancel := context.WithDeadline(context.Background(), d)\n\tdefer cancel()\n\t_, err = getTimeoutFromContext(ctx)\n\tif err != ErrInvalidDeadline {\n\t\tt.Errorf(\"err %v, want ErrInvalidDeadline\", err)\n\t}\n\tctx, cancel = context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\tv, err := getTimeoutFromContext(ctx)\n\tif err != nil {\n\t\tt.Errorf(\"err %v, want nil\", err)\n\t}\n\ttimeout := v.Milliseconds()\n\tif timeout <= 4500 || timeout > 5000 {\n\t\tt.Errorf(\"v %d, want [4500,5000]\", timeout)\n\t}\n}\n\nfunc TestPayloadTooBig(t *testing.T) {\n\ttests := []struct {\n\t\tmaxInMemLogSize uint64\n\t\tpayloadSize     uint64\n\t\ttooBig          bool\n\t}{\n\t\t{0, 1, false},\n\t\t{0, 1024 * 1024 * 1024, false},\n\t\t{settings.EntryNonCmdFieldsSize + 1, 1, false},\n\t\t{settings.EntryNonCmdFieldsSize + 1, 2, true},\n\t\t{settings.EntryNonCmdFieldsSize * 2, settings.EntryNonCmdFieldsSize, false},\n\t\t{settings.EntryNonCmdFieldsSize * 2, settings.EntryNonCmdFieldsSize + 1, true},\n\t}\n\tfor idx, tt := range tests {\n\t\tcfg := config.Config{\n\t\t\tReplicaID:       1,\n\t\t\tHeartbeatRTT:    1,\n\t\t\tElectionRTT:     10,\n\t\t\tMaxInMemLogSize: tt.maxInMemLogSize,\n\t\t}\n\t\tif err := cfg.Validate(); err != nil {\n\t\t\tt.Fatalf(\"invalid cfg %v\", err)\n\t\t}\n\t\tn := node{config: cfg}\n\t\tif n.payloadTooBig(int(tt.payloadSize)) != tt.tooBig {\n\t\t\tt.Errorf(\"%d, unexpected too big result %t\", idx, tt.tooBig)\n\t\t}\n\t}\n}\n\n//\n// node states\n//\n\ntype dummyPipeline struct{}\n\nfunc (d *dummyPipeline) setCloseReady(*node)            {}\nfunc (d *dummyPipeline) setStepReady(shardID uint64)    {}\nfunc (d *dummyPipeline) setCommitReady(shardID uint64)  {}\nfunc (d *dummyPipeline) setApplyReady(shardID uint64)   {}\nfunc (d *dummyPipeline) setStreamReady(shardID uint64)  {}\nfunc (d *dummyPipeline) setSaveReady(shardID uint64)    {}\nfunc (d *dummyPipeline) setRecoverReady(shardID uint64) {}\n\nfunc TestProcessUninitilizedNode(t *testing.T) {\n\tn := &node{ss: snapshotState{}, pipeline: &dummyPipeline{}}\n\tif !n.processUninitializedNodeStatus() {\n\t\tt.Errorf(\"failed to returned the recover request\")\n\t}\n\tif !n.ss.recovering() {\n\t\tt.Errorf(\"not in recovering mode\")\n\t}\n\treq, ok := n.ss.getRecoverReq()\n\tif !ok {\n\t\tt.Fatalf(\"failed to set recover req\")\n\t}\n\tif !req.Initial || !req.Recover {\n\t\tt.Errorf(\"unexpected req\")\n\t}\n\tn2 := &node{ss: snapshotState{}, initializedC: make(chan struct{})}\n\tn2.setInitialized()\n\tif n2.processUninitializedNodeStatus() {\n\t\tt.Errorf(\"unexpected recover from snapshot request\")\n\t}\n}\n\nfunc TestProcessRecoveringNodeCanBeSkipped(t *testing.T) {\n\tn := &node{ss: snapshotState{}}\n\tif n.processRecoverStatus() {\n\t\tt.Errorf(\"processRecoveringNode not skipped\")\n\t}\n}\n\nfunc TestProcessTakingSnapshotNodeCanBeSkipped(t *testing.T) {\n\tn := &node{ss: snapshotState{}}\n\tif n.processSaveStatus() {\n\t\tt.Errorf(\"processTakingSnapshotNode not skipped\")\n\t}\n}\n\nfunc TestRecoveringFromSnapshotNodeCanComplete(t *testing.T) {\n\tn := &node{\n\t\tss:           snapshotState{},\n\t\tsysEvents:    newSysEventListener(nil, nil),\n\t\tinitializedC: make(chan struct{}),\n\t}\n\tn.ss.setRecovering()\n\tn.ss.notifySnapshotStatus(false, true, false, true, 100)\n\tif n.processRecoverStatus() {\n\t\tt.Errorf(\"node unexpectedly skipped\")\n\t}\n\tif n.ss.recovering() {\n\t\tt.Errorf(\"still recovering\")\n\t}\n\tif !n.initialized() {\n\t\tt.Errorf(\"not marked as initialized\")\n\t}\n\tif n.ss.snapshotIndex != 100 {\n\t\tt.Errorf(\"unexpected snapshot index %d, want 100\", n.ss.snapshotIndex)\n\t}\n}\n\nfunc TestNotReadyRecoveringFromSnapshotNode(t *testing.T) {\n\tn := &node{ss: snapshotState{}, sysEvents: newSysEventListener(nil, nil)}\n\tn.ss.setRecovering()\n\tif !n.processRecoverStatus() {\n\t\tt.Errorf(\"not skipped\")\n\t}\n}\n\nfunc TestTakingSnapshotNodeCanComplete(t *testing.T) {\n\tn := &node{ss: snapshotState{}, initializedC: make(chan struct{})}\n\tn.ss.setSaving()\n\tn.ss.notifySnapshotStatus(true, false, false, false, 0)\n\tn.setInitialized()\n\tif n.processSaveStatus() {\n\t\tt.Errorf(\"node unexpectedly skipped\")\n\t}\n\tif n.ss.saving() {\n\t\tt.Errorf(\"still taking snapshot\")\n\t}\n}\n\nfunc TestTakingSnapshotOnUninitializedNodeWillPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Fatalf(\"panic not triggered\")\n\t\t}\n\t}()\n\tn := &node{ss: snapshotState{}}\n\tn.ss.setSaving()\n\tn.ss.notifySnapshotStatus(true, false, false, false, 0)\n\tn.processSaveStatus()\n}\n\nfunc TestGetCompactionIndex(t *testing.T) {\n\tcfg := config.Config{\n\t\tCompactionOverhead: 234,\n\t}\n\tn := node{config: cfg}\n\treq1 := rsm.SSRequest{\n\t\tOverrideCompaction: true,\n\t\tCompactionOverhead: 123,\n\t}\n\treq2 := rsm.SSRequest{\n\t\tOverrideCompaction: false,\n\t\tCompactionOverhead: 456,\n\t}\n\treq3 := rsm.SSRequest{\n\t\tOverrideCompaction: true,\n\t\tCompactionIndex:    300,\n\t}\n\tif v, _ := n.getCompactionIndex(req1, 200); v != 77 {\n\t\tt.Errorf(\"snapshot overhead override not applied\")\n\t}\n\tif v, _ := n.getCompactionIndex(req2, 500); v != 266 {\n\t\tt.Errorf(\"snapshot overhead override unexpectedly applied\")\n\t}\n\tif v, _ := n.getCompactionIndex(req3, 500); v != 300 {\n\t\tt.Errorf(\"snapshot index not correctly set\")\n\t}\n\tif v, ok := n.getCompactionIndex(req3, 299); v != 0 || ok {\n\t\tt.Errorf(\"snapshot index unexpectedly set\")\n\t}\n}\n\ntype testDummyNodeProxy struct{}\n\nfunc (np *testDummyNodeProxy) StepReady()                                            {}\nfunc (np *testDummyNodeProxy) RestoreRemotes(pb.Snapshot) error                      { return nil }\nfunc (np *testDummyNodeProxy) ApplyUpdate(pb.Entry, sm.Result, bool, bool, bool)     {}\nfunc (np *testDummyNodeProxy) ApplyConfigChange(pb.ConfigChange, uint64, bool) error { return nil }\nfunc (np *testDummyNodeProxy) ReplicaID() uint64                                     { return 1 }\nfunc (np *testDummyNodeProxy) ShardID() uint64                                       { return 1 }\nfunc (np *testDummyNodeProxy) ShouldStop() <-chan struct{}                           { return nil }\n\nfunc TestNotReadyTakingSnapshotNodeIsSkippedWhenConcurrencyIsNotSupported(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tn := &node{ss: snapshotState{}, initializedC: make(chan struct{})}\n\tconfig := config.Config{ShardID: 1, ReplicaID: 1}\n\tn.sm = rsm.NewStateMachine(\n\t\trsm.NewNativeSM(config, &rsm.InMemStateMachine{}, nil),\n\t\tnil, config, &testDummyNodeProxy{}, fs)\n\tif n.concurrentSnapshot() {\n\t\tt.Errorf(\"concurrency not suppose to be supported\")\n\t}\n\tn.ss.setSaving()\n\tn.setInitialized()\n\tif !n.processSaveStatus() {\n\t\tt.Fatalf(\"node not skipped\")\n\t}\n}\n\nfunc TestNotReadyTakingSnapshotConcurrentNodeIsNotSkipped(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tn := &node{ss: snapshotState{}, initializedC: make(chan struct{})}\n\tconfig := config.Config{ShardID: 1, ReplicaID: 1}\n\tn.sm = rsm.NewStateMachine(\n\t\trsm.NewNativeSM(config, &rsm.ConcurrentStateMachine{}, nil),\n\t\tnil, config, &testDummyNodeProxy{}, fs)\n\tif !n.concurrentSnapshot() {\n\t\tt.Errorf(\"concurrency not supported\")\n\t}\n\tn.ss.setSaving()\n\tn.setInitialized()\n\tif n.processSaveStatus() {\n\t\tt.Fatalf(\"node unexpectedly skipped\")\n\t}\n}\n\nfunc TestIsWitnessNode(t *testing.T) {\n\tn1 := node{config: config.Config{}}\n\tif n1.isWitness() {\n\t\tt.Errorf(\"not expect to be witness\")\n\t}\n\tn2 := node{config: config.Config{IsWitness: true}}\n\tif !n2.isWitness() {\n\t\tt.Errorf(\"not reported as witness\")\n\t}\n}\n\nfunc TestSaveSnapshotAborted(t *testing.T) {\n\ttests := []struct {\n\t\terr     error\n\t\taborted bool\n\t}{\n\t\t{sm.ErrSnapshotStopped, true},\n\t\t{sm.ErrSnapshotAborted, true},\n\t\t{nil, false},\n\t\t{sm.ErrSnapshotStreaming, false},\n\t}\n\n\tfor idx, tt := range tests {\n\t\tif saveAborted(tt.err) != tt.aborted {\n\t\t\tt.Errorf(\"%d, saveSnapshotAborted failed\", idx)\n\t\t}\n\t}\n}\n\nfunc TestLogDBMetrics(t *testing.T) {\n\tl := logDBMetrics{}\n\tl.update(true)\n\tif !l.isBusy() {\n\t\tt.Errorf(\"unexpected value\")\n\t}\n\tl.update(false)\n\tif l.isBusy() {\n\t\tt.Errorf(\"unexpected value\")\n\t}\n}\n\nfunc TestUninitializedNodeNotAllowedToMakeRequests(t *testing.T) {\n\tn := node{}\n\tif n.initialized() {\n\t\tt.Fatalf(\"already initialized\")\n\t}\n\tif _, err := n.propose(nil, nil, 1); err != ErrShardNotReady {\n\t\tt.Fatalf(\"making proposal not rejected\")\n\t}\n\tif _, err := n.proposeSession(nil, 1); err != ErrShardNotReady {\n\t\tt.Fatalf(\"propose session not rejected\")\n\t}\n\tif _, err := n.read(1); err != ErrShardNotReady {\n\t\tt.Fatalf(\"read not rejected\")\n\t}\n\tif err := n.requestLeaderTransfer(1); err != ErrShardNotReady {\n\t\tt.Fatalf(\"leader transfer request not rejected\")\n\t}\n\tif _, err := n.requestSnapshot(SnapshotOption{}, 1); err != ErrShardNotReady {\n\t\tt.Fatalf(\"snapshot request not rejected\")\n\t}\n\tif _, err := n.requestConfigChange(pb.ConfigChangeType(0),\n\t\t1, \"localhost:1\", 1, 1); err != ErrShardNotReady {\n\t\tt.Fatalf(\"config change request not rejected\")\n\t}\n}\n\nfunc TestEntriesToApply(t *testing.T) {\n\ttests := []struct {\n\t\tinputIndex   uint64\n\t\tinputLength  uint64\n\t\tcrash        bool\n\t\tresultIndex  uint64\n\t\tresultLength uint64\n\t}{\n\t\t{1, 5, true, 0, 0},\n\t\t{1, 10, false, 0, 0},\n\t\t{1, 11, false, 11, 1},\n\t\t{1, 20, false, 11, 10},\n\t\t{10, 6, false, 11, 5},\n\t\t{11, 5, false, 11, 5},\n\t\t{12, 5, true, 0, 0},\n\t}\n\tfor idx, tt := range tests {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil && tt.crash {\n\t\t\t\t\tt.Fatalf(\"%d, didn't panic\", idx)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tinputs := make([]pb.Entry, 0)\n\t\t\tfor i := tt.inputIndex; i < tt.inputIndex+tt.inputLength; i++ {\n\t\t\t\tinputs = append(inputs, pb.Entry{Index: i})\n\t\t\t}\n\t\t\tn := &node{pushedIndex: 10}\n\t\t\tresults := pb.EntriesToApply(inputs, n.pushedIndex, true)\n\t\t\tif uint64(len(results)) != tt.resultLength {\n\t\t\t\tt.Errorf(\"%d, result len %d, want %d\", idx, len(results), tt.resultLength)\n\t\t\t}\n\t\t\tif len(results) > 0 {\n\t\t\t\tif results[0].Index != tt.resultIndex {\n\t\t\t\t\tt.Errorf(\"%d, first result index %d, want %d\",\n\t\t\t\t\t\tidx, results[0].Index, tt.resultIndex)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n}\n"
        },
        {
          "name": "nodehost.go",
          "type": "blob",
          "size": 72.900390625,
          "content": "// Copyright 2017-2021 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/*\nPackage dragonboat is a feature complete and highly optimized multi-group Raft\nimplementation for providing consensus in distributed systems.\n\nThe NodeHost struct is the facade interface for all features provided by the\ndragonboat package. Each NodeHost instance usually runs on a separate server\nmanaging CPU, storage and network resources used for achieving consensus. Each\nNodeHost manages Raft nodes from different Raft groups known as Raft shards.\nEach Raft shard is identified by its ShardID, it usually consists of\nmultiple nodes (also known as replicas) each identified by a ReplicaID value.\nNodes from the same Raft shard suppose to be distributed on different NodeHost\ninstances across the network, this brings fault tolerance for machine and\nnetwork failures as application data stored in the Raft shard will be\navailable as long as the majority of its managing NodeHost instances (i.e. its\nunderlying servers) are accessible.\n\nArbitrary number of Raft shards can be launched across the network to\naggregate distributed processing and storage capacities. Users can also make\nmembership change requests to add or remove nodes from selected Raft shard.\n\nUser applications can leverage the power of the Raft protocol by implementing\nthe IStateMachine or IOnDiskStateMachine component, as defined in\ngithub.com/lni/dragonboat/v4/statemachine. Known as user state machines, each\nIStateMachine or IOnDiskStateMachine instance is in charge of updating, querying\nand snapshotting application data with minimum exposure to the Raft protocol\nitself.\n\nDragonboat guarantees the linearizability of your I/O when interacting with the\nIStateMachine or IOnDiskStateMachine instances. In plain English, writes (via\nmaking proposals) to your Raft shard appears to be instantaneous, once a write\nis completed, all later reads (via linearizable read based on Raft's ReadIndex\nprotocol) should return the value of that write or a later write. Once a value\nis returned by a linearizable read, all later reads should return the same value\nor the result of a later write.\n\nTo strictly provide such guarantee, we need to implement the at-most-once\nsemantic. For a client, when it retries the proposal that failed to complete by\nits deadline, it faces the risk of having the same proposal committed and\napplied twice into the user state machine. Dragonboat prevents this by\nimplementing the client session concept described in Diego Ongaro's PhD thesis.\n*/\npackage dragonboat // github.com/lni/dragonboat/v4\n\nimport (\n\t\"context\"\n\t\"math\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/cockroachdb/errors\"\n\t\"github.com/lni/goutils/logutil\"\n\t\"github.com/lni/goutils/syncutil\"\n\n\t\"github.com/lni/dragonboat/v4/client\"\n\t\"github.com/lni/dragonboat/v4/config\"\n\t\"github.com/lni/dragonboat/v4/internal/id\"\n\t\"github.com/lni/dragonboat/v4/internal/invariants\"\n\t\"github.com/lni/dragonboat/v4/internal/logdb\"\n\t\"github.com/lni/dragonboat/v4/internal/registry\"\n\t\"github.com/lni/dragonboat/v4/internal/rsm\"\n\t\"github.com/lni/dragonboat/v4/internal/server\"\n\t\"github.com/lni/dragonboat/v4/internal/settings\"\n\t\"github.com/lni/dragonboat/v4/internal/transport\"\n\t\"github.com/lni/dragonboat/v4/internal/utils\"\n\t\"github.com/lni/dragonboat/v4/internal/vfs\"\n\t\"github.com/lni/dragonboat/v4/raftio\"\n\tpb \"github.com/lni/dragonboat/v4/raftpb\"\n\tsm \"github.com/lni/dragonboat/v4/statemachine\"\n)\n\nconst (\n\t// DragonboatMajor is the major version number\n\tDragonboatMajor = 4\n\t// DragonboatMinor is the minor version number\n\tDragonboatMinor = 0\n\t// DragonboatPatch is the patch version number\n\tDragonboatPatch = 0\n\t// DEVVersion is a boolean flag indicating whether this is a dev version\n\tDEVVersion = true\n)\n\nvar (\n\treceiveQueueLen   = settings.Soft.ReceiveQueueLength\n\trequestPoolShards = settings.Soft.NodeHostRequestStatePoolShards\n\tstreamConnections = settings.Soft.StreamConnections\n)\n\nvar (\n\t// ErrClosed is returned when a request is made on closed NodeHost instance.\n\tErrClosed = errors.New(\"dragonboat: closed\")\n\t// ErrReplicaRemoved indictes that the requested node has been removed.\n\tErrReplicaRemoved = errors.New(\"node removed\")\n\t// ErrShardNotFound indicates that the specified shard is not found.\n\tErrShardNotFound = errors.New(\"shard not found\")\n\t// ErrShardAlreadyExist indicates that the specified shard already exist.\n\tErrShardAlreadyExist = errors.New(\"shard already exist\")\n\t// ErrShardNotStopped indicates that the specified shard is still running\n\t// and thus prevented the requested operation to be completed.\n\tErrShardNotStopped = errors.New(\"shard not stopped\")\n\t// ErrInvalidShardSettings indicates that shard settings specified for\n\t// the StartReplica method are invalid.\n\tErrInvalidShardSettings = errors.New(\"shard settings are invalid\")\n\t// ErrShardNotBootstrapped indicates that the specified shard has not\n\t// been boostrapped yet. When starting this node, depending on whether this\n\t// node is an initial member of the Raft shard, you must either specify\n\t// all of its initial members or set the join flag to true.\n\t// When used correctly, dragonboat only returns this error in the rare\n\t// situation when you try to restart a node crashed during its previous\n\t// bootstrap attempt.\n\tErrShardNotBootstrapped = errors.New(\"shard not bootstrapped\")\n\t// ErrDeadlineNotSet indicates that the context parameter provided does not\n\t// carry a deadline.\n\tErrDeadlineNotSet = errors.New(\"deadline not set\")\n\t// ErrInvalidDeadline indicates that the specified deadline is invalid, e.g.\n\t// time in the past.\n\tErrInvalidDeadline = errors.New(\"invalid deadline\")\n\t// ErrDirNotExist indicates that the specified dir does not exist.\n\tErrDirNotExist = errors.New(\"specified dir does not exist\")\n\t// ErrLogDBNotCreatedOrClosed indicates that the logdb is not created yet or closed already.\n\tErrLogDBNotCreatedOrClosed = errors.New(\"logdb is not created yet or closed already\")\n\t// ErrInvalidRange indicates that the specified log range is invalid.\n\tErrInvalidRange = errors.New(\"invalid log range\")\n)\n\n// ShardInfo is a record for representing the state of a Raft shard based\n// on the knowledge of the local NodeHost instance.\ntype ShardInfo = registry.ShardInfo\n\n// ShardView is a record for representing the state of a Raft shard based\n// on the knowledge of distributed NodeHost instances as shared by gossip.\ntype ShardView = registry.ShardView\n\n// GossipInfo contains details of the gossip service.\ntype GossipInfo struct {\n\t// AdvertiseAddress is the advertise address used by the gossip service.\n\tAdvertiseAddress string\n\t// NumOfKnownNodeHosts is the number of current live NodeHost instances known\n\t// to the gossip service. Note that the gossip service always knowns the\n\t// local NodeHost instance itself. When the NumOfKnownNodeHosts value is 1,\n\t// it means the gossip service doesn't know any other NodeHost instance that\n\t// is considered as live.\n\tNumOfKnownNodeHosts int\n\t// Enabled is a boolean flag indicating whether the gossip service is enabled.\n\tEnabled bool\n}\n\n// NodeHostInfo provides info about the NodeHost, including its managed Raft\n// shard nodes and available Raft logs saved in its local persistent storage.\ntype NodeHostInfo struct {\n\t// NodeHostID is the unique identifier of the NodeHost instance.\n\tNodeHostID string\n\t// RaftAddress is the public address of the NodeHost used for exchanging Raft\n\t// messages, snapshots and other metadata with other NodeHost instances.\n\tRaftAddress string\n\t// Gossip contains gossip service related information.\n\tGossip GossipInfo\n\t// ShardInfo is a list of all Raft shards managed by the NodeHost\n\tShardInfoList []ShardInfo\n\t// LogInfo is a list of raftio.NodeInfo values representing all Raft logs\n\t// stored on the NodeHost.\n\tLogInfo []raftio.NodeInfo\n}\n\n// NodeHostInfoOption is the option type used when querying NodeHostInfo.\ntype NodeHostInfoOption struct {\n\t// SkipLogInfo is the boolean flag indicating whether Raft Log info should be\n\t// skipped when querying the NodeHostInfo.\n\tSkipLogInfo bool\n}\n\n// DefaultNodeHostInfoOption is the default NodeHostInfoOption value. It\n// requests the GetNodeHostInfo method to return all supported info.\nvar DefaultNodeHostInfoOption NodeHostInfoOption\n\n// SnapshotOption is the options supported when requesting a snapshot to be\n// generated.\ntype SnapshotOption struct {\n\t// ExportPath is the path where the exported snapshot should be stored, it\n\t// must point to an existing directory for which the current user has write\n\t// permission.\n\tExportPath string\n\t// CompactionOverhead is the compaction overhead value to use for the\n\t// requested snapshot operation when OverrideCompactionOverhead is set to\n\t// true. This field is ignored when exporting a snapshot. ErrInvalidOption\n\t// will be returned if both CompactionOverhead and CompactionIndex are set.\n\tCompactionOverhead uint64\n\t// CompactionIndex specifies the raft log index before which all log entries\n\t// can be compacted after creating the snapshot. This option is only considered\n\t// when OverrideCompactionOverhead is set to true, ErrInvalidOption will be\n\t// returned if both CompactionOverhead and CompactionIndex are set.\n\tCompactionIndex uint64\n\t// Exported is a boolean flag indicating whether to export the requested\n\t// snapshot. For an exported snapshot, users are responsible for managing the\n\t// snapshot files. An exported snapshot is usually used to repair the shard\n\t// when it permanently loses its majority quorum. See the ImportSnapshot method\n\t// in the tools package for more details.\n\tExported bool\n\t// OverrideCompactionOverhead defines whether the requested snapshot operation\n\t// should override the compaction overhead setting specified in node's config.\n\t// This field is ignored when exporting a snapshot.\n\tOverrideCompactionOverhead bool\n}\n\n// Validate checks the SnapshotOption and return error when there is any\n// invalid option found.\nfunc (o SnapshotOption) Validate() error {\n\tif o.OverrideCompactionOverhead {\n\t\tif o.CompactionOverhead > 0 && o.CompactionIndex > 0 {\n\t\t\tplog.Errorf(\"both CompactionOverhead and CompactionIndex are set\")\n\t\t\treturn ErrInvalidOption\n\t\t}\n\t} else {\n\t\tif o.CompactionOverhead > 0 || o.CompactionIndex > 0 {\n\t\t\tplog.Warningf(\"CompactionOverhead and CompactionIndex will be ignored\")\n\t\t}\n\t}\n\treturn nil\n}\n\n// ReadonlyLogReader provides safe readonly access to the underlying logdb.\ntype ReadonlyLogReader interface {\n\t// GetRange returns the range of the entries in LogDB.\n\tGetRange() (uint64, uint64)\n\t// NodeState returns the state of the node persistent in LogDB.\n\tNodeState() (pb.State, pb.Membership)\n\t// Term returns the entry term of the specified entry.\n\tTerm(index uint64) (uint64, error)\n\t// Entries returns entries between [low, high) with total size of entries\n\t// limited to maxSize bytes.\n\tEntries(low uint64, high uint64, maxSize uint64) ([]pb.Entry, error)\n\t// Snapshot returns the metadata for the most recent snapshot known to the\n\t// LogDB.\n\tSnapshot() pb.Snapshot\n}\n\n// DefaultSnapshotOption is the default SnapshotOption value to use when\n// requesting a snapshot to be generated. This default option causes a regular\n// snapshot to be generated.\nvar DefaultSnapshotOption SnapshotOption\n\n// Target is the type used to specify where a node is running. Target is remote\n// NodeHost's RaftAddress value when NodeHostConfig.DefaultNodeRegistryEnabled is not\n// set. Target will use NodeHost's ID value when\n// NodeHostConfig.DefaultNodeRegistryEnabled is set.\ntype Target = string\n\n// NodeHost manages Raft shards and enables them to share resources such as\n// transport and persistent storage etc. NodeHost is also the central thread\n// safe access point for accessing Dragonboat functionalities.\ntype NodeHost struct {\n\tmu struct {\n\t\tsync.RWMutex\n\t\tcci    uint64\n\t\tcciCh  chan struct{}\n\t\tshards sync.Map\n\t\tlm     sync.Map\n\t\tlogdb  raftio.ILogDB\n\t}\n\tevents struct {\n\t\tleaderInfoQ *leaderInfoQueue\n\t\traft        raftio.IRaftEventListener\n\t\tsys         *sysEventListener\n\t}\n\tregistry     INodeHostRegistry\n\tnodes        raftio.INodeRegistry\n\tfs           vfs.IFS\n\ttransport    transport.ITransport\n\tid           *id.UUID\n\tstopper      *syncutil.Stopper\n\tmsgHandler   *messageHandler\n\tenv          *server.Env\n\tengine       *engine\n\tnhConfig     config.NodeHostConfig\n\trequestPools []*sync.Pool\n\tpartitioned  int32\n\tclosed       int32\n}\n\nvar _ nodeLoader = (*NodeHost)(nil)\n\nvar dn = logutil.DescribeNode\n\nvar firstError = utils.FirstError\n\n// NewNodeHost creates a new NodeHost instance. In a typical application, it is\n// expected to have one NodeHost on each server.\nfunc NewNodeHost(nhConfig config.NodeHostConfig) (*NodeHost, error) {\n\tlogBuildTagsAndVersion()\n\tif err := nhConfig.Validate(); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := nhConfig.Prepare(); err != nil {\n\t\treturn nil, err\n\t}\n\tenv, err := server.NewEnv(nhConfig, nhConfig.Expert.FS)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tnh := &NodeHost{\n\t\tenv:      env,\n\t\tnhConfig: nhConfig,\n\t\tstopper:  syncutil.NewStopper(),\n\t\tfs:       nhConfig.Expert.FS,\n\t}\n\t// make static check happy\n\t_ = nh.partitioned\n\tnh.events.raft = nhConfig.RaftEventListener\n\tnh.events.sys = newSysEventListener(nhConfig.SystemEventListener,\n\t\tnh.stopper.ShouldStop())\n\tnh.mu.cciCh = make(chan struct{}, 1)\n\tif nhConfig.RaftEventListener != nil {\n\t\tnh.events.leaderInfoQ = newLeaderInfoQueue()\n\t}\n\tif nhConfig.RaftEventListener != nil || nhConfig.SystemEventListener != nil {\n\t\tnh.stopper.RunWorker(func() {\n\t\t\tnh.handleListenerEvents()\n\t\t})\n\t}\n\tnh.msgHandler = newNodeHostMessageHandler(nh)\n\tnh.createPools()\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tnh.Close()\n\t\t\tif r, ok := r.(error); ok {\n\t\t\t\tpanicNow(r)\n\t\t\t}\n\t\t}\n\t}()\n\tdid := nh.nhConfig.GetDeploymentID()\n\tplog.Infof(\"DeploymentID set to %d\", did)\n\tif err := nh.createLogDB(); err != nil {\n\t\tnh.Close()\n\t\treturn nil, err\n\t}\n\tif err := nh.loadNodeHostID(); err != nil {\n\t\tnh.Close()\n\t\treturn nil, err\n\t}\n\tplog.Infof(\"NodeHost ID: %s\", nh.id.String())\n\tif err := nh.createNodeRegistry(); err != nil {\n\t\tnh.Close()\n\t\treturn nil, err\n\t}\n\terrorInjection := false\n\tif nhConfig.Expert.FS != nil {\n\t\t_, errorInjection = nhConfig.Expert.FS.(*vfs.ErrorFS)\n\t\tplog.Infof(\"filesystem error injection mode enabled: %t\", errorInjection)\n\t}\n\tnh.engine = newExecEngine(nh, nhConfig.Expert.Engine,\n\t\tnh.nhConfig.NotifyCommit, errorInjection, nh.env, nh.mu.logdb)\n\tif err := nh.createTransport(); err != nil {\n\t\tnh.Close()\n\t\treturn nil, err\n\t}\n\tnh.stopper.RunWorker(func() {\n\t\tnh.nodeMonitorMain()\n\t})\n\tnh.stopper.RunWorker(func() {\n\t\tnh.tickWorkerMain()\n\t})\n\tnh.logNodeHostDetails()\n\treturn nh, nil\n}\n\n// Close stops all managed Raft nodes and releases all resources owned by the\n// NodeHost instance.\nfunc (nh *NodeHost) Close() {\n\tnh.events.sys.Publish(server.SystemEvent{\n\t\tType: server.NodeHostShuttingDown,\n\t})\n\tnh.mu.Lock()\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\tpanic(\"NodeHost.Stop called twice\")\n\t}\n\tatomic.StoreInt32(&nh.closed, 1)\n\tnh.mu.Unlock()\n\tnodes := make([]raftio.NodeInfo, 0)\n\tnh.forEachShard(func(cid uint64, node *node) bool {\n\t\tnodes = append(nodes, raftio.NodeInfo{\n\t\t\tShardID:   node.shardID,\n\t\t\tReplicaID: node.replicaID,\n\t\t})\n\t\treturn true\n\t})\n\tfor _, node := range nodes {\n\t\tif err := nh.stopNode(node.ShardID, node.ReplicaID, true); err != nil {\n\t\t\tplog.Errorf(\"failed to remove shard %s\",\n\t\t\t\tlogutil.ShardID(node.ShardID))\n\t\t}\n\t}\n\tplog.Debugf(\"%s is stopping the nh stopper\", nh.describe())\n\tnh.stopper.Stop()\n\tvar err error\n\tplog.Debugf(\"%s is stopping the tranport module\", nh.describe())\n\tif nh.transport != nil {\n\t\terr = firstError(err, nh.transport.Close())\n\t}\n\tif nh.nodes != nil {\n\t\terr = firstError(err, nh.nodes.Close())\n\t\tnh.nodes = nil\n\t}\n\tplog.Debugf(\"%s is stopping the engine module\", nh.describe())\n\tif nh.engine != nil {\n\t\terr = firstError(err, nh.engine.close())\n\t\tnh.engine = nil\n\t\tnh.transport = nil\n\t}\n\tplog.Debugf(\"%s is stopping the logdb module\", nh.describe())\n\tif nh.mu.logdb != nil {\n\t\terr = firstError(err, nh.mu.logdb.Close())\n\t\tnh.mu.logdb = nil\n\t}\n\tplog.Debugf(\"%s is stopping the env module\", nh.describe())\n\terr = firstError(err, nh.env.Close())\n\tplog.Debugf(\"NodeHost %s stopped\", nh.describe())\n\tif err != nil {\n\t\tpanicNow(err)\n\t}\n}\n\n// NodeHostConfig returns the NodeHostConfig instance used for configuring this\n// NodeHost instance.\nfunc (nh *NodeHost) NodeHostConfig() config.NodeHostConfig {\n\treturn nh.nhConfig\n}\n\n// RaftAddress returns the Raft address of the NodeHost instance, it is the\n// network address by which the NodeHost can be reached by other NodeHost\n// instances for exchanging Raft messages, snapshots and other metadata.\nfunc (nh *NodeHost) RaftAddress() string {\n\treturn nh.nhConfig.RaftAddress\n}\n\n// ID returns the string representation of the NodeHost ID value. The NodeHost\n// ID is assigned to each NodeHost on its initial creation and it can be used\n// to uniquely identify the NodeHost instance for its entire life cycle. When\n// the system is running in the AddressByNodeHost mode, it is used as the target\n// value when calling the StartReplica, RequestAddReplica, RequestAddNonVoting,\n// RequestAddWitness methods.\nfunc (nh *NodeHost) ID() string {\n\treturn nh.id.String()\n}\n\n// GetNodeHostRegistry returns the NodeHostRegistry instance that can be used\n// to query NodeHost details shared between NodeHost instances by gossip.\nfunc (nh *NodeHost) GetNodeHostRegistry() (INodeHostRegistry, bool) {\n\treturn nh.registry, nh.nhConfig.DefaultNodeRegistryEnabled\n}\n\n// StartReplica adds the specified Raft replica node to the NodeHost and starts\n// the node to make it ready for accepting incoming requests. The node to be\n// started is backed by a regular state machine that implements the\n// sm.IStateMachine interface.\n//\n// The input parameter initialMembers is a map of replica ID to replica target for all\n// Raft shard's initial member nodes. By default, the target is the\n// RaftAddress value of the NodeHost where the node will be running. When running\n// in the DefaultNodeRegistryEnabled mode, target should be set to the NodeHostID value\n// of the NodeHost where the node will be running. See the godoc of NodeHost's ID\n// method for the full definition of NodeHostID. For the same Raft shard, the\n// same initialMembers map should be specified when starting its initial member\n// nodes on distributed NodeHost instances.\n//\n// The join flag indicates whether the node is a new node joining an existing\n// shard. create is a factory function for creating the IStateMachine instance,\n// cfg is the configuration instance that will be passed to the underlying Raft\n// node object, the shard ID and replica ID of the involved node are specified in\n// the ShardID and ReplicaID fields of the provided cfg parameter.\n//\n// Note that this method is not for changing the membership of the specified\n// Raft shard, it launches a node that is already a member of the Raft shard.\n//\n// As a summary, when -\n//   - starting a brand new Raft shard, set join to false and specify all initial\n//     member node details in the initialMembers map.\n//   - joining a new node to an existing Raft shard, set join to true and leave\n//     the initialMembers map empty. This requires the joining node to have already\n//     been added as a member node of the Raft shard.\n//   - restarting a crashed or stopped node, set join to false and leave the\n//     initialMembers map to be empty. This applies to both initial member nodes\n//     and those joined later.\nfunc (nh *NodeHost) StartReplica(initialMembers map[uint64]Target,\n\tjoin bool, create sm.CreateStateMachineFunc, cfg config.Config) error {\n\tcf := func(shardID uint64, replicaID uint64,\n\t\tdone <-chan struct{}) rsm.IManagedStateMachine {\n\t\tsm := create(shardID, replicaID)\n\t\treturn rsm.NewNativeSM(cfg, rsm.NewInMemStateMachine(sm), done)\n\t}\n\treturn nh.startShard(initialMembers, join, cf, cfg, pb.RegularStateMachine)\n}\n\n// StartConcurrentReplica is similar to the StartReplica method but it is used\n// to start a Raft node backed by a concurrent state machine.\nfunc (nh *NodeHost) StartConcurrentReplica(initialMembers map[uint64]Target,\n\tjoin bool, create sm.CreateConcurrentStateMachineFunc, cfg config.Config) error {\n\tcf := func(shardID uint64, replicaID uint64,\n\t\tdone <-chan struct{}) rsm.IManagedStateMachine {\n\t\tsm := create(shardID, replicaID)\n\t\treturn rsm.NewNativeSM(cfg, rsm.NewConcurrentStateMachine(sm), done)\n\t}\n\treturn nh.startShard(initialMembers,\n\t\tjoin, cf, cfg, pb.ConcurrentStateMachine)\n}\n\n// StartOnDiskReplica is similar to the StartReplica method but it is used to\n// start a Raft node backed by an IOnDiskStateMachine.\nfunc (nh *NodeHost) StartOnDiskReplica(initialMembers map[uint64]Target,\n\tjoin bool, create sm.CreateOnDiskStateMachineFunc, cfg config.Config) error {\n\tcf := func(shardID uint64, replicaID uint64,\n\t\tdone <-chan struct{}) rsm.IManagedStateMachine {\n\t\tsm := create(shardID, replicaID)\n\t\treturn rsm.NewNativeSM(cfg, rsm.NewOnDiskStateMachine(sm), done)\n\t}\n\treturn nh.startShard(initialMembers,\n\t\tjoin, cf, cfg, pb.OnDiskStateMachine)\n}\n\n// StopShard stops the local Raft replica associated with the specified Raft\n// shard.\n//\n// Note that this is not the membership change operation required to remove the\n// node from the Raft shard.\nfunc (nh *NodeHost) StopShard(shardID uint64) error {\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn ErrClosed\n\t}\n\treturn nh.stopNode(shardID, 0, false)\n}\n\n// StopReplica stops the specified Raft replica.\n//\n// Note that this is not the membership change operation required to remove the\n// node from the Raft shard.\nfunc (nh *NodeHost) StopReplica(shardID uint64, replicaID uint64) error {\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn ErrClosed\n\t}\n\treturn nh.stopNode(shardID, replicaID, true)\n}\n\n// SyncPropose makes a synchronous proposal on the Raft shard specified by\n// the input client session object. The specified context parameter must have\n// the timeout value set.\n//\n// SyncPropose returns the result returned by IStateMachine or\n// IOnDiskStateMachine's Update method, or the error encountered. The input\n// byte slice can be reused for other purposes immediate after the return of\n// this method.\n//\n// After calling SyncPropose, unless NO-OP client session is used, it is\n// caller's responsibility to update the client session instance accordingly\n// based on SyncPropose's outcome. Basically, when a ErrTimeout error is\n// returned, application can retry the same proposal without updating the\n// client session instance. When ErrInvalidSession error is returned, it\n// usually means the session instance has been evicted from the server side,\n// the Raft paper recommends to crash the client in this highly unlikely\n// event. When the proposal completed successfully, caller must call\n// client.ProposalCompleted() to get it ready to be used in future proposals.\nfunc (nh *NodeHost) SyncPropose(ctx context.Context,\n\tsession *client.Session, cmd []byte) (sm.Result, error) {\n\ttimeout, err := getTimeoutFromContext(ctx)\n\tif err != nil {\n\t\treturn sm.Result{}, err\n\t}\n\trs, err := nh.Propose(session, cmd, timeout)\n\tif err != nil {\n\t\treturn sm.Result{}, err\n\t}\n\tresult, err := getRequestState(ctx, rs)\n\tif err != nil {\n\t\treturn sm.Result{}, err\n\t}\n\trs.Release()\n\treturn result, nil\n}\n\n// SyncRead performs a synchronous linearizable read on the specified Raft\n// shard. The specified context parameter must have the timeout value set. The\n// query interface{} specifies what to query, it will be passed to the Lookup\n// method of the IStateMachine or IOnDiskStateMachine after the system\n// determines that it is safe to perform the local read. It returns the query\n// result from the Lookup method or the error encountered.\nfunc (nh *NodeHost) SyncRead(ctx context.Context, shardID uint64,\n\tquery interface{}) (interface{}, error) {\n\tv, err := nh.linearizableRead(ctx, shardID,\n\t\tfunc(node *node) (interface{}, error) {\n\t\t\tdata, err := node.sm.Lookup(query)\n\t\t\tif errors.Is(err, rsm.ErrShardClosed) {\n\t\t\t\treturn nil, ErrShardClosed\n\t\t\t}\n\t\t\treturn data, err\n\t\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn v, nil\n}\n\n// GetLogReader returns a read-only LogDB reader.\nfunc (nh *NodeHost) GetLogReader(shardID uint64) (ReadonlyLogReader, error) {\n\tnh.mu.RLock()\n\tdefer nh.mu.RUnlock()\n\tif nh.mu.logdb == nil {\n\t\treturn nil, ErrLogDBNotCreatedOrClosed\n\t}\n\tn, ok := nh.getShard(shardID)\n\tif !ok {\n\t\treturn nil, ErrLogDBNotCreatedOrClosed\n\t}\n\treturn n.logReader, nil\n}\n\n// Membership is the struct used to describe Raft shard membership.\ntype Membership struct {\n\t// ConfigChangeID is the Raft entry index of the last applied membership\n\t// change entry.\n\tConfigChangeID uint64\n\t// Nodes is a map of ReplicaID values to NodeHost Raft addresses for all regular\n\t// Raft nodes.\n\tNodes map[uint64]string\n\t// NonVotings is a map of ReplicaID values to NodeHost Raft addresses for all\n\t// nonVotings in the Raft shard.\n\tNonVotings map[uint64]string\n\t// Witnesses is a map of ReplicaID values to NodeHost Raft addresses for all\n\t// witnesses in the Raft shard.\n\tWitnesses map[uint64]string\n\t// Removed is a set of ReplicaID values that have been removed from the Raft\n\t// shard. They are not allowed to be added back to the shard.\n\tRemoved map[uint64]struct{}\n}\n\n// SyncGetShardMembership is a synchronous method that queries the membership\n// information from the specified Raft shard. The specified context parameter\n// must have the timeout value set.\nfunc (nh *NodeHost) SyncGetShardMembership(ctx context.Context,\n\tshardID uint64) (*Membership, error) {\n\tv, err := nh.linearizableRead(ctx, shardID,\n\t\tfunc(node *node) (interface{}, error) {\n\t\t\tm := node.sm.GetMembership()\n\t\t\tcm := func(input map[uint64]bool) map[uint64]struct{} {\n\t\t\t\tresult := make(map[uint64]struct{})\n\t\t\t\tfor k := range input {\n\t\t\t\t\tresult[k] = struct{}{}\n\t\t\t\t}\n\t\t\t\treturn result\n\t\t\t}\n\t\t\treturn &Membership{\n\t\t\t\tNodes:          m.Addresses,\n\t\t\t\tNonVotings:     m.NonVotings,\n\t\t\t\tWitnesses:      m.Witnesses,\n\t\t\t\tRemoved:        cm(m.Removed),\n\t\t\t\tConfigChangeID: m.ConfigChangeId,\n\t\t\t}, nil\n\t\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn v.(*Membership), nil\n}\n\n// GetLeaderID returns the leader replica ID of the specified Raft shard based\n// on local node's knowledge. The returned boolean value indicates whether the\n// leader information is available.\nfunc (nh *NodeHost) GetLeaderID(shardID uint64) (uint64, uint64, bool, error) {\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn 0, 0, false, ErrClosed\n\t}\n\tv, ok := nh.getShard(shardID)\n\tif !ok {\n\t\treturn 0, 0, false, ErrShardNotFound\n\t}\n\tleaderID, term, valid := v.getLeaderID()\n\treturn leaderID, term, valid, nil\n}\n\n// GetNoOPSession returns a NO-OP client session ready to be used for making\n// proposals. The NO-OP client session is a dummy client session that will not\n// be checked or enforced. Use this No-OP client session when you want to ignore\n// features provided by client sessions. A NO-OP client session is not\n// registered on the server side and thus not required to be closed at the end\n// of its life cycle.\n//\n// Returned NO-OP client session instance can be concurrently used in multiple\n// goroutines.\n//\n// Use this NO-OP client session when your IStateMachine provides idempotence in\n// its own implementation.\n//\n// NO-OP client session must be used for making proposals on IOnDiskStateMachine\n// based user state machines.\nfunc (nh *NodeHost) GetNoOPSession(shardID uint64) *client.Session {\n\treturn client.NewNoOPSession(shardID, nh.env.GetRandomSource())\n}\n\n// SyncGetSession starts a synchronous proposal to create, register and return\n// a new client session object for the specified Raft shard. The specified\n// context parameter must have the timeout value set.\n//\n// A client session object is used to ensure that a retried proposal, e.g.\n// proposal retried after timeout, will not be applied more than once into the\n// state machine.\n//\n// Returned client session instance is not thread safe.\n//\n// Client session is not supported by IOnDiskStateMachine based user state\n// machines. NO-OP client session must be used on IOnDiskStateMachine based\n// state machines.\nfunc (nh *NodeHost) SyncGetSession(ctx context.Context,\n\tshardID uint64) (*client.Session, error) {\n\ttimeout, err := getTimeoutFromContext(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcs := client.NewSession(shardID, nh.env.GetRandomSource())\n\tcs.PrepareForRegister()\n\trs, err := nh.ProposeSession(cs, timeout)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresult, err := getRequestState(ctx, rs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif result.Value != cs.ClientID {\n\t\tplog.Panicf(\"unexpected result %d, want %d\", result.Value, cs.ClientID)\n\t}\n\tcs.PrepareForPropose()\n\treturn cs, nil\n}\n\n// SyncCloseSession closes the specified client session by unregistering it\n// from the system in a synchronous manner. The specified context parameter\n// must have the timeout value set.\n//\n// Closed client session should not be used in future proposals.\nfunc (nh *NodeHost) SyncCloseSession(ctx context.Context,\n\tcs *client.Session) error {\n\ttimeout, err := getTimeoutFromContext(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcs.PrepareForUnregister()\n\trs, err := nh.ProposeSession(cs, timeout)\n\tif err != nil {\n\t\treturn err\n\t}\n\tresult, err := getRequestState(ctx, rs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif result.Value != cs.ClientID {\n\t\tplog.Panicf(\"unexpected result %d, want %d\", result.Value, cs.ClientID)\n\t}\n\treturn nil\n}\n\n// QueryRaftLog starts an asynchronous query for raft logs in the specified\n// range [firstIndex, lastIndex) on the given Raft shard. The returned\n// raft log entries are limited to maxSize in bytes.\n//\n// This method returns a RequestState instance or an error immediately. User\n// can use the CompletedC channel of the returned RequestState to get notified\n// when the query result becomes available.\nfunc (nh *NodeHost) QueryRaftLog(shardID uint64, firstIndex uint64,\n\tlastIndex uint64, maxSize uint64) (*RequestState, error) {\n\treturn nh.queryRaftLog(shardID, firstIndex, lastIndex, maxSize)\n}\n\n// Propose starts an asynchronous proposal on the Raft shard specified by the\n// Session object. The input byte slice can be reused for other purposes\n// immediate after the return of this method.\n//\n// This method returns a RequestState instance or an error immediately. User can\n// wait on the ResultC() channel of the returned RequestState instance to get\n// notified for the outcome of the proposal.\n//\n// After the proposal is completed, i.e. RequestResult is received from the\n// ResultC() channel of the returned RequestState, unless NO-OP client session\n// is used, it is caller's responsibility to update the Session instance\n// accordingly. Basically, when RequestTimeout is returned, you can retry the\n// same proposal without updating your client session instance, when a\n// RequestRejected value is returned, it usually means the session instance has\n// been evicted from the server side as there are too many ongoing client\n// sessions, the Raft paper recommends users to crash the client in such highly\n// unlikely event. When the proposal completed successfully with a\n// RequestCompleted value, application must call client.ProposalCompleted() to\n// get the client session ready to be used in future proposals.\nfunc (nh *NodeHost) Propose(session *client.Session, cmd []byte,\n\ttimeout time.Duration) (*RequestState, error) {\n\treturn nh.propose(session, cmd, timeout)\n}\n\n// ProposeSession starts an asynchronous proposal on the specified shard\n// for client session related operations. Depending on the state of the specified\n// client session object, the supported operations are for registering or\n// unregistering a client session. Application can select on the ResultC()\n// channel of the returned RequestState instance to get notified for the\n// completion (RequestResult.Completed() is true) of the operation.\nfunc (nh *NodeHost) ProposeSession(session *client.Session,\n\ttimeout time.Duration) (*RequestState, error) {\n\tn, ok := nh.getShard(session.ShardID)\n\tif !ok {\n\t\treturn nil, ErrShardNotFound\n\t}\n\t// witness node is not expected to propose anything\n\tif n.isWitness() {\n\t\treturn nil, ErrInvalidOperation\n\t}\n\tif !n.supportClientSession() && !session.IsNoOPSession() {\n\t\tplog.Panicf(\"IOnDiskStateMachine based nodes must use NoOPSession\")\n\t}\n\tdefer nh.engine.setStepReady(session.ShardID)\n\treturn n.proposeSession(session, nh.getTimeoutTick(timeout))\n}\n\n// ReadIndex starts the asynchronous ReadIndex protocol used for linearizable\n// read on the specified shard. This method returns a RequestState instance\n// or an error immediately. Application should wait on the ResultC() channel\n// of the returned RequestState object to get notified on the outcome of the\n// ReadIndex operation. On a successful completion, the ReadLocalNode method\n// can then be invoked to query the state of the IStateMachine or\n// IOnDiskStateMachine with linearizability guarantee.\nfunc (nh *NodeHost) ReadIndex(shardID uint64,\n\ttimeout time.Duration) (*RequestState, error) {\n\trs, _, err := nh.readIndex(shardID, timeout)\n\treturn rs, err\n}\n\n// ReadLocalNode queries the Raft node identified by the input RequestState\n// instance. ReadLocalNode is only allowed to be called after receiving a\n// RequestCompleted notification from the ReadIndex method.\nfunc (nh *NodeHost) ReadLocalNode(rs *RequestState,\n\tquery interface{}) (interface{}, error) {\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn nil, ErrClosed\n\t}\n\trs.mustBeReadyForLocalRead()\n\t// translate the rsm.ErrShardClosed to ErrShardClosed\n\t// internally, the IManagedStateMachine might obtain a RLock before performing\n\t// the local read. The critical section is used to make sure we don't read\n\t// from a destroyed C++ StateMachine object\n\tdata, err := rs.node.sm.Lookup(query)\n\tif errors.Is(err, rsm.ErrShardClosed) {\n\t\treturn nil, ErrShardClosed\n\t}\n\treturn data, err\n}\n\n// NAReadLocalNode is a no extra heap allocation variant of ReadLocalNode, it\n// uses byte slice as its input and output data to avoid extra heap allocations\n// caused by using interface{}. Users are recommended to use the ReadLocalNode\n// method unless performance is the top priority.\n//\n// As an optional feature of the state machine, NAReadLocalNode returns\n// statemachine.ErrNotImplemented if the underlying state machine does not\n// implement the statemachine.IExtended interface.\n//\n// Similar to ReadLocalNode, NAReadLocalNode is only allowed to be called after\n// receiving a RequestCompleted notification from the ReadIndex method.\nfunc (nh *NodeHost) NAReadLocalNode(rs *RequestState,\n\tquery []byte) ([]byte, error) {\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn nil, ErrClosed\n\t}\n\trs.mustBeReadyForLocalRead()\n\tdata, err := rs.node.sm.NALookup(query)\n\tif errors.Is(err, rsm.ErrShardClosed) {\n\t\treturn nil, ErrShardClosed\n\t}\n\treturn data, err\n}\n\nvar staleReadCalled uint32\n\n// StaleRead queries the specified Raft node directly without any\n// linearizability guarantee.\nfunc (nh *NodeHost) StaleRead(shardID uint64,\n\tquery interface{}) (interface{}, error) {\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn nil, ErrClosed\n\t}\n\tif atomic.CompareAndSwapUint32(&staleReadCalled, 0, 1) {\n\t\tplog.Warningf(\"StaleRead called, linearizability not guaranteed for stale read\")\n\t}\n\tn, ok := nh.getShard(shardID)\n\tif !ok {\n\t\treturn nil, ErrShardNotFound\n\t}\n\tif !n.initialized() {\n\t\treturn nil, ErrShardNotInitialized\n\t}\n\tif n.isWitness() {\n\t\treturn nil, ErrInvalidOperation\n\t}\n\tdata, err := n.sm.Lookup(query)\n\tif errors.Is(err, rsm.ErrShardClosed) {\n\t\treturn nil, ErrShardClosed\n\t}\n\treturn data, err\n}\n\n// SyncRequestSnapshot is the synchronous variant of the RequestSnapshot\n// method. See RequestSnapshot for more details.\n//\n// The input context object must have deadline set.\n//\n// SyncRequestSnapshot returns the index of the created snapshot or the error\n// encountered.\nfunc (nh *NodeHost) SyncRequestSnapshot(ctx context.Context,\n\tshardID uint64, opt SnapshotOption) (uint64, error) {\n\ttimeout, err := getTimeoutFromContext(ctx)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\trs, err := nh.RequestSnapshot(shardID, opt, timeout)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tv, err := getRequestState(ctx, rs)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn v.Value, nil\n}\n\n// RequestSnapshot requests a snapshot to be created asynchronously for the\n// specified shard node. For each node, only one ongoing snapshot operation\n// is allowed.\n//\n// Each requested snapshot will also trigger Raft log and snapshot compactions\n// similar to automatic snapshotting. Users need to subsequently call\n// RequestCompaction(), which can be far more I/O intensive, at suitable time to\n// actually reclaim disk spaces used by Raft log entries and snapshot metadata\n// records.\n//\n// RequestSnapshot returns a RequestState instance or an error immediately.\n// Applications can wait on the ResultC() channel of the returned RequestState\n// instance to get notified for the outcome of the create snasphot operation.\n// The RequestResult instance returned by the ResultC() channel tells the\n// outcome of the snapshot operation, when successful, the SnapshotIndex method\n// of the returned RequestResult instance reports the index of the created\n// snapshot.\n//\n// Requested snapshot operation will be rejected if there is already an existing\n// snapshot in the system at the same Raft log index.\nfunc (nh *NodeHost) RequestSnapshot(shardID uint64,\n\topt SnapshotOption, timeout time.Duration) (*RequestState, error) {\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn nil, ErrClosed\n\t}\n\tn, ok := nh.getShard(shardID)\n\tif !ok {\n\t\treturn nil, ErrShardNotFound\n\t}\n\tif err := opt.Validate(); err != nil {\n\t\treturn nil, err\n\t}\n\tdefer nh.engine.setStepReady(shardID)\n\treturn n.requestSnapshot(opt, nh.getTimeoutTick(timeout))\n}\n\n// RequestCompaction requests a compaction operation to be asynchronously\n// executed in the background to reclaim disk spaces used by Raft Log entries\n// that have already been marked as removed. This includes Raft Log entries\n// that have already been included in created snapshots and Raft Log entries\n// that belong to nodes already permanently removed via NodeHost.RemoveData().\n//\n// By default, compaction is automatically issued after each snapshot is\n// captured. RequestCompaction can be used to manually trigger such compaction\n// when auto compaction is disabled by the DisableAutoCompactions option in\n// config.Config.\n//\n// The returned *SysOpState instance can be used to get notified when the\n// requested compaction is completed. ErrRejected is returned when there is\n// nothing to be reclaimed.\nfunc (nh *NodeHost) RequestCompaction(shardID uint64,\n\treplicaID uint64) (*SysOpState, error) {\n\tnh.mu.Lock()\n\tdefer nh.mu.Unlock()\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn nil, ErrClosed\n\t}\n\tn, ok := nh.getShard(shardID)\n\tif !ok {\n\t\t// assume this is a node that has already been removed via RemoveData\n\t\tdone, err := nh.mu.logdb.CompactEntriesTo(shardID, replicaID, math.MaxUint64)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &SysOpState{completedC: done}, nil\n\t}\n\tif n.replicaID != replicaID {\n\t\treturn nil, ErrShardNotFound\n\t}\n\tdefer nh.engine.setStepReady(shardID)\n\treturn n.requestCompaction()\n}\n\n// SyncRequestDeleteReplica is the synchronous variant of the RequestDeleteReplica\n// method. See RequestDeleteReplica for more details.\n//\n// The input context object must have its deadline set.\nfunc (nh *NodeHost) SyncRequestDeleteReplica(ctx context.Context,\n\tshardID uint64, replicaID uint64, configChangeIndex uint64) error {\n\ttimeout, err := getTimeoutFromContext(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\trs, err := nh.RequestDeleteReplica(shardID, replicaID, configChangeIndex, timeout)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = getRequestState(ctx, rs)\n\treturn err\n}\n\n// SyncRequestAddReplica is the synchronous variant of the RequestAddReplica method.\n// See RequestAddReplica for more details.\n//\n// The input context object must have its deadline set.\nfunc (nh *NodeHost) SyncRequestAddReplica(ctx context.Context,\n\tshardID uint64, replicaID uint64,\n\ttarget string, configChangeIndex uint64) error {\n\ttimeout, err := getTimeoutFromContext(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\trs, err := nh.RequestAddReplica(shardID,\n\t\treplicaID, target, configChangeIndex, timeout)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = getRequestState(ctx, rs)\n\treturn err\n}\n\n// SyncRequestAddNonVoting is the synchronous variant of the RequestAddNonVoting\n// method. See RequestAddNonVoting for more details.\n//\n// The input context object must have its deadline set.\nfunc (nh *NodeHost) SyncRequestAddNonVoting(ctx context.Context,\n\tshardID uint64, replicaID uint64,\n\ttarget string, configChangeIndex uint64) error {\n\ttimeout, err := getTimeoutFromContext(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\trs, err := nh.RequestAddNonVoting(shardID,\n\t\treplicaID, target, configChangeIndex, timeout)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = getRequestState(ctx, rs)\n\treturn err\n}\n\n// SyncRequestAddWitness is the synchronous variant of the RequestAddWitness\n// method. See RequestAddWitness for more details.\n//\n// The input context object must have its deadline set.\nfunc (nh *NodeHost) SyncRequestAddWitness(ctx context.Context,\n\tshardID uint64, replicaID uint64,\n\ttarget string, configChangeIndex uint64) error {\n\ttimeout, err := getTimeoutFromContext(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\trs, err := nh.RequestAddWitness(shardID,\n\t\treplicaID, target, configChangeIndex, timeout)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = getRequestState(ctx, rs)\n\treturn err\n}\n\n// RequestDeleteReplica is a Raft shard membership change method for requesting\n// the specified node to be removed from the specified Raft shard. It starts\n// an asynchronous request to remove the node from the Raft shard membership\n// list. Application can wait on the ResultC() channel of the returned\n// RequestState instance to get notified for the outcome.\n//\n// It is not guaranteed that deleted node will automatically close itself and\n// be removed from its managing NodeHost instance. It is application's\n// responsibility to call StopShard on the right NodeHost instance to actually\n// have the shard node removed from its managing NodeHost instance.\n//\n// Once a node is successfully deleted from a Raft shard, it will not be\n// allowed to be added back to the shard with the same node identity.\n//\n// When the Raft shard is created with the OrderedConfigChange config flag\n// set as false, the configChangeIndex parameter is ignored. Otherwise, it\n// should be set to the most recent Config Change Index value returned by the\n// SyncGetShardMembership method. The requested delete node operation will be\n// rejected if other membership change has been applied since that earlier call\n// to the SyncGetShardMembership method.\nfunc (nh *NodeHost) RequestDeleteReplica(shardID uint64,\n\treplicaID uint64,\n\tconfigChangeIndex uint64, timeout time.Duration) (*RequestState, error) {\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn nil, ErrClosed\n\t}\n\tn, ok := nh.getShard(shardID)\n\tif !ok {\n\t\treturn nil, ErrShardNotFound\n\t}\n\ttt := nh.getTimeoutTick(timeout)\n\tdefer nh.engine.setStepReady(shardID)\n\treturn n.requestDeleteNodeWithOrderID(replicaID, configChangeIndex, tt)\n}\n\n// RequestAddReplica is a Raft shard membership change method for requesting the\n// specified node to be added to the specified Raft shard. It starts an\n// asynchronous request to add the node to the Raft shard membership list.\n// Application can wait on the ResultC() channel of the returned RequestState\n// instance to get notified for the outcome.\n//\n// If there is already an nonVoting with the same replicaID in the shard, it will\n// be promoted to a regular node with voting power. The target parameter of the\n// RequestAddReplica call is ignored when promoting an nonVoting to a regular node.\n//\n// After the node is successfully added to the Raft shard, it is application's\n// responsibility to call StartReplica on the target NodeHost instance to\n// actually start the Raft shard node.\n//\n// Requesting a removed node back to the Raft shard will always be rejected.\n//\n// By default, the target parameter is the RaftAddress of the NodeHost instance\n// where the new Raft node will be running. Note that fixed IP or static DNS\n// name should be used in RaftAddress in such default mode. When running in the\n// DefaultNodeRegistryEnabled mode, target should be set to NodeHost's ID value which\n// can be obtained by calling the ID() method.\n//\n// When the Raft shard is created with the OrderedConfigChange config flag\n// set as false, the configChangeIndex parameter is ignored. Otherwise, it\n// should be set to the most recent Config Change Index value returned by the\n// SyncGetShardMembership method. The requested add node operation will be\n// rejected if other membership change has been applied since that earlier call\n// to the SyncGetShardMembership method.\nfunc (nh *NodeHost) RequestAddReplica(shardID uint64,\n\treplicaID uint64, target Target, configChangeIndex uint64,\n\ttimeout time.Duration) (*RequestState, error) {\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn nil, ErrClosed\n\t}\n\tn, ok := nh.getShard(shardID)\n\tif !ok {\n\t\treturn nil, ErrShardNotFound\n\t}\n\tdefer nh.engine.setStepReady(shardID)\n\treturn n.requestAddNodeWithOrderID(replicaID,\n\t\ttarget, configChangeIndex, nh.getTimeoutTick(timeout))\n}\n\n// RequestAddNonVoting is a Raft shard membership change method for requesting\n// the specified node to be added to the specified Raft shard as an non-voting\n// member without voting power. It starts an asynchronous request to add the\n// specified node as an non-voting member.\n//\n// Such nonVoting is able to receive replicated states from the leader node, but\n// it is neither allowed to vote for leader, nor considered as a part of the\n// quorum when replicating state. An nonVoting can be promoted to a regular node\n// with voting power by making a RequestAddReplica call using its shardID and\n// replicaID values. An nonVoting can be removed from the shard by calling\n// RequestDeleteReplica with its shardID and replicaID values.\n//\n// Application should later call StartReplica with config.Config.IsNonVoting\n// set to true on the right NodeHost to actually start the nonVoting instance.\n//\n// See the godoc of the RequestAddReplica method for the details of the target and\n// configChangeIndex parameters.\nfunc (nh *NodeHost) RequestAddNonVoting(shardID uint64,\n\treplicaID uint64, target Target, configChangeIndex uint64,\n\ttimeout time.Duration) (*RequestState, error) {\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn nil, ErrClosed\n\t}\n\tn, ok := nh.getShard(shardID)\n\tif !ok {\n\t\treturn nil, ErrShardNotFound\n\t}\n\tdefer nh.engine.setStepReady(shardID)\n\treturn n.requestAddNonVotingWithOrderID(replicaID,\n\t\ttarget, configChangeIndex, nh.getTimeoutTick(timeout))\n}\n\n// RequestAddWitness is a Raft shard membership change method for requesting\n// the specified node to be added as a witness to the given Raft shard. It\n// starts an asynchronous request to add the specified node as an witness.\n//\n// A witness can vote in elections but it doesn't have any Raft log or\n// application state machine associated. The witness node can not be used\n// to initiate read, write or membership change operations on its Raft shard.\n// Section 11.7.2 of Diego Ongaro's thesis contains more info on such witness\n// role.\n//\n// Application should later call StartReplica with config.Config.IsWitness\n// set to true on the right NodeHost to actually start the witness node.\n//\n// See the godoc of the RequestAddReplica method for the details of the target and\n// configChangeIndex parameters.\nfunc (nh *NodeHost) RequestAddWitness(shardID uint64,\n\treplicaID uint64, target Target, configChangeIndex uint64,\n\ttimeout time.Duration) (*RequestState, error) {\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn nil, ErrClosed\n\t}\n\tn, ok := nh.getShard(shardID)\n\tif !ok {\n\t\treturn nil, ErrShardNotFound\n\t}\n\tdefer nh.engine.setStepReady(shardID)\n\treturn n.requestAddWitnessWithOrderID(replicaID,\n\t\ttarget, configChangeIndex, nh.getTimeoutTick(timeout))\n}\n\n// RequestLeaderTransfer makes a request to transfer the leadership of the\n// specified Raft shard to the target node identified by targetReplicaID. It\n// returns an error if the request fails to be started. There is no guarantee\n// that such request can be fulfilled.\nfunc (nh *NodeHost) RequestLeaderTransfer(shardID uint64,\n\ttargetReplicaID uint64) error {\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn ErrClosed\n\t}\n\tn, ok := nh.getShard(shardID)\n\tif !ok {\n\t\treturn ErrShardNotFound\n\t}\n\tplog.Debugf(\"RequestLeaderTransfer called on shard %d target replicaID %d\",\n\t\tshardID, targetReplicaID)\n\tdefer nh.engine.setStepReady(shardID)\n\treturn n.requestLeaderTransfer(targetReplicaID)\n}\n\n// SyncRemoveData is the synchronous variant of the RemoveData. It waits for\n// the specified node to be fully offloaded or until the context object instance\n// is cancelled or timeout.\n//\n// Similar to RemoveData, calling SyncRemoveData on a node that is still a Raft\n// shard member will corrupt the Raft shard.\nfunc (nh *NodeHost) SyncRemoveData(ctx context.Context,\n\tshardID uint64, replicaID uint64) error {\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn ErrClosed\n\t}\n\tif _, ok := ctx.Deadline(); !ok {\n\t\treturn ErrDeadlineNotSet\n\t}\n\tif _, ok := nh.getShard(shardID); ok {\n\t\treturn ErrShardNotStopped\n\t}\n\tif ch := nh.engine.destroyedC(shardID, replicaID); ch != nil {\n\t\tselect {\n\t\tcase <-ch:\n\t\tcase <-ctx.Done():\n\t\t\tif ctx.Err() == context.Canceled {\n\t\t\t\treturn ErrCanceled\n\t\t\t} else if ctx.Err() == context.DeadlineExceeded {\n\t\t\t\treturn ErrTimeout\n\t\t\t}\n\t\t}\n\t}\n\terr := nh.RemoveData(shardID, replicaID)\n\tif errors.Is(err, ErrShardNotStopped) {\n\t\tpanic(\"node not stopped\")\n\t}\n\treturn err\n}\n\n// RemoveData tries to remove all data associated with the specified node. This\n// method should only be used after the node has been deleted from its Raft\n// shard. Calling RemoveData on a node that is still a Raft shard member\n// will corrupt the Raft shard.\n//\n// RemoveData returns ErrShardNotStopped when the specified node has not been\n// fully offloaded from the NodeHost instance.\nfunc (nh *NodeHost) RemoveData(shardID uint64, replicaID uint64) error {\n\tn, ok := nh.getShard(shardID)\n\tif ok && n.replicaID == replicaID {\n\t\treturn ErrShardNotStopped\n\t}\n\tnh.mu.Lock()\n\tdefer nh.mu.Unlock()\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn ErrClosed\n\t}\n\tif nh.engine.nodeLoaded(shardID, replicaID) {\n\t\treturn ErrShardNotStopped\n\t}\n\tplog.Debugf(\"%s called RemoveData\", dn(shardID, replicaID))\n\tif err := nh.mu.logdb.RemoveNodeData(shardID, replicaID); err != nil {\n\t\tpanicNow(err)\n\t}\n\t// mark the snapshot dir as removed\n\tdid := nh.nhConfig.GetDeploymentID()\n\tif err := nh.env.RemoveSnapshotDir(did, shardID, replicaID); err != nil {\n\t\tpanicNow(err)\n\t}\n\treturn nil\n}\n\n// GetNodeUser returns an INodeUser instance ready to be used to directly make\n// proposals or read index operations without locating the node repeatedly in\n// the NodeHost. A possible use case is when loading a large data set say with\n// billions of proposals into the dragonboat based system.\nfunc (nh *NodeHost) GetNodeUser(shardID uint64) (INodeUser, error) {\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn nil, ErrClosed\n\t}\n\tn, ok := nh.getShard(shardID)\n\tif !ok {\n\t\treturn nil, ErrShardNotFound\n\t}\n\treturn &nodeUser{\n\t\tnh:           nh,\n\t\tnode:         n,\n\t\tsetStepReady: nh.engine.setStepReady,\n\t}, nil\n}\n\n// HasNodeInfo returns a boolean value indicating whether the specified node\n// has been bootstrapped on the current NodeHost instance.\nfunc (nh *NodeHost) HasNodeInfo(shardID uint64, replicaID uint64) bool {\n\tnh.mu.Lock()\n\tdefer nh.mu.Unlock()\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn false\n\t}\n\tif _, err := nh.mu.logdb.GetBootstrapInfo(shardID, replicaID); err != nil {\n\t\tif errors.Is(err, raftio.ErrNoBootstrapInfo) {\n\t\t\treturn false\n\t\t}\n\t\tpanicNow(err)\n\t}\n\treturn true\n}\n\n// GetNodeHostInfo returns a NodeHostInfo instance that contains all details\n// of the NodeHost, this includes details of all Raft shards managed by the\n// the NodeHost instance.\nfunc (nh *NodeHost) GetNodeHostInfo(opt NodeHostInfoOption) *NodeHostInfo {\n\tnhi := &NodeHostInfo{\n\t\tNodeHostID:    nh.ID(),\n\t\tRaftAddress:   nh.RaftAddress(),\n\t\tGossip:        nh.getGossipInfo(),\n\t\tShardInfoList: nh.getShardInfo(),\n\t}\n\tnh.mu.Lock()\n\tdefer nh.mu.Unlock()\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn nil\n\t}\n\tif !opt.SkipLogInfo {\n\t\tlogInfo, err := nh.mu.logdb.ListNodeInfo()\n\t\tif err != nil {\n\t\t\tpanicNow(err)\n\t\t}\n\t\tnhi.LogInfo = logInfo\n\t}\n\treturn nhi\n}\n\nfunc (nh *NodeHost) getGossipInfo() GossipInfo {\n\tif r, ok := nh.nodes.(*registry.GossipRegistry); ok {\n\t\treturn GossipInfo{\n\t\t\tEnabled:             true,\n\t\t\tAdvertiseAddress:    r.AdvertiseAddress(),\n\t\t\tNumOfKnownNodeHosts: r.NumMembers(),\n\t\t}\n\t}\n\treturn GossipInfo{}\n}\n\nfunc (nh *NodeHost) propose(s *client.Session,\n\tcmd []byte, timeout time.Duration) (*RequestState, error) {\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn nil, ErrClosed\n\t}\n\tv, ok := nh.getShard(s.ShardID)\n\tif !ok {\n\t\treturn nil, ErrShardNotFound\n\t}\n\tif !v.supportClientSession() && !s.IsNoOPSession() {\n\t\tpanic(\"IOnDiskStateMachine based nodes must use NoOPSession\")\n\t}\n\treq, err := v.propose(s, cmd, nh.getTimeoutTick(timeout))\n\tnh.engine.setStepReady(s.ShardID)\n\treturn req, err\n}\n\nfunc (nh *NodeHost) readIndex(shardID uint64,\n\ttimeout time.Duration) (*RequestState, *node, error) {\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn nil, nil, ErrClosed\n\t}\n\tn, ok := nh.getShard(shardID)\n\tif !ok {\n\t\treturn nil, nil, ErrShardNotFound\n\t}\n\treq, err := n.read(nh.getTimeoutTick(timeout))\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tnh.engine.setStepReady(shardID)\n\treturn req, n, err\n}\n\nfunc (nh *NodeHost) queryRaftLog(shardID uint64,\n\tfirstIndex uint64, lastIndex uint64, maxSize uint64) (*RequestState, error) {\n\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\treturn nil, ErrClosed\n\t}\n\tv, ok := nh.getShard(shardID)\n\tif !ok {\n\t\treturn nil, ErrShardNotFound\n\t}\n\tif lastIndex <= firstIndex {\n\t\treturn nil, ErrInvalidRange\n\t}\n\treq, err := v.queryRaftLog(firstIndex, lastIndex, maxSize)\n\tnh.engine.setStepReady(shardID)\n\treturn req, err\n}\n\nfunc (nh *NodeHost) linearizableRead(ctx context.Context,\n\tshardID uint64, f func(n *node) (interface{}, error)) (interface{}, error) {\n\ttimeout, err := getTimeoutFromContext(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trs, node, err := nh.readIndex(shardID, timeout)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif _, err := getRequestState(ctx, rs); err != nil {\n\t\treturn nil, err\n\t}\n\trs.Release()\n\treturn f(node)\n}\n\nfunc (nh *NodeHost) getShard(shardID uint64) (*node, bool) {\n\tn, ok := nh.mu.shards.Load(shardID)\n\tif !ok {\n\t\treturn nil, false\n\t}\n\treturn n.(*node), true\n}\n\nfunc (nh *NodeHost) forEachShard(f func(uint64, *node) bool) uint64 {\n\tnh.mu.RLock()\n\tdefer nh.mu.RUnlock()\n\tnh.mu.shards.Range(func(k, v interface{}) bool {\n\t\treturn f(k.(uint64), v.(*node))\n\t})\n\treturn nh.mu.cci\n}\n\nfunc (nh *NodeHost) getShardSetIndex() uint64 {\n\tnh.mu.RLock()\n\tdefer nh.mu.RUnlock()\n\treturn nh.mu.cci\n}\n\n// there are three major reasons to bootstrap the shard -\n//\n//  1. when possible, we check whether user incorrectly specified parameters\n//     for the startShard method, e.g. call startShard with join=true first,\n//     then restart the NodeHost instance and call startShard again with\n//     join=false and len(nodes) > 0\n//  2. when restarting a node which is a part of the initial shard members,\n//     for user convenience, we allow the caller not to provide the details of\n//     initial members. when the initial shard member info is required, however\n//     we still need to get the initial member info from somewhere. bootstrap is\n//     the procedure that records such info.\n//  3. the bootstrap record is used as a marker record in our default LogDB\n//     implementation to indicate that a certain node exists here\nfunc (nh *NodeHost) bootstrapShard(initialMembers map[uint64]Target,\n\tjoin bool, cfg config.Config,\n\tsmType pb.StateMachineType) (map[uint64]string, bool, error) {\n\tbi, err := nh.mu.logdb.GetBootstrapInfo(cfg.ShardID, cfg.ReplicaID)\n\tif errors.Is(err, raftio.ErrNoBootstrapInfo) {\n\t\tif !join && len(initialMembers) == 0 {\n\t\t\treturn nil, false, ErrShardNotBootstrapped\n\t\t}\n\t\tvar members map[uint64]string\n\t\tif !join {\n\t\t\tmembers = initialMembers\n\t\t}\n\t\tbi = pb.NewBootstrapInfo(join, smType, initialMembers)\n\t\terr := nh.mu.logdb.SaveBootstrapInfo(cfg.ShardID, cfg.ReplicaID, bi)\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t\treturn members, !join, nil\n\t} else if err != nil {\n\t\treturn nil, false, err\n\t}\n\tif !bi.Validate(initialMembers, join, smType) {\n\t\tplog.Errorf(\"bootstrap info validation failed, %s, %v, %t, %v, %t\",\n\t\t\tdn(cfg.ShardID, cfg.ReplicaID),\n\t\t\tbi.Addresses, bi.Join, initialMembers, join)\n\t\treturn nil, false, ErrInvalidShardSettings\n\t}\n\treturn bi.Addresses, !bi.Join, nil\n}\n\nfunc (nh *NodeHost) startShard(initialMembers map[uint64]Target,\n\tjoin bool, createStateMachine rsm.ManagedStateMachineFactory,\n\tcfg config.Config, smType pb.StateMachineType) error {\n\tshardID := cfg.ShardID\n\treplicaID := cfg.ReplicaID\n\tvalidator := nh.nhConfig.GetTargetValidator()\n\tfor _, target := range initialMembers {\n\t\tif !validator(target) {\n\t\t\treturn ErrInvalidTarget\n\t\t}\n\t}\n\n\tdoStart := func() (*node, error) {\n\t\tnh.mu.Lock()\n\t\tdefer nh.mu.Unlock()\n\n\t\tif atomic.LoadInt32(&nh.closed) != 0 {\n\t\t\treturn nil, ErrClosed\n\t\t}\n\t\tif _, ok := nh.mu.shards.Load(shardID); ok {\n\t\t\treturn nil, ErrShardAlreadyExist\n\t\t}\n\t\tif nh.engine.nodeLoaded(shardID, replicaID) {\n\t\t\t// node is still loaded in the execution engine, e.g. processing snapshot\n\t\t\treturn nil, ErrShardAlreadyExist\n\t\t}\n\t\tif join && len(initialMembers) > 0 {\n\t\t\treturn nil, ErrInvalidShardSettings\n\t\t}\n\t\tpeers, im, err := nh.bootstrapShard(initialMembers, join, cfg, smType)\n\t\tif errors.Is(err, ErrInvalidShardSettings) {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err != nil {\n\t\t\tpanicNow(err)\n\t\t}\n\t\tfor k, v := range peers {\n\t\t\tif k != replicaID {\n\t\t\t\tnh.nodes.Add(shardID, k, v)\n\t\t\t}\n\t\t}\n\t\tdid := nh.nhConfig.GetDeploymentID()\n\t\tif err := nh.env.CreateSnapshotDir(did, shardID, replicaID); err != nil {\n\t\t\tif errors.Is(err, server.ErrDirMarkedAsDeleted) {\n\t\t\t\treturn nil, ErrReplicaRemoved\n\t\t\t}\n\t\t\tpanicNow(err)\n\t\t}\n\t\tgetSnapshotDir := func(cid uint64, nid uint64) string {\n\t\t\treturn nh.env.GetSnapshotDir(did, cid, nid)\n\t\t}\n\t\tlogReader := logdb.NewLogReader(shardID, replicaID, nh.mu.logdb)\n\t\tss := newSnapshotter(shardID, replicaID,\n\t\t\tgetSnapshotDir, nh.mu.logdb, logReader, nh.fs)\n\t\tlogReader.SetCompactor(ss)\n\t\tif err := ss.processOrphans(); err != nil {\n\t\t\tpanicNow(err)\n\t\t}\n\t\tp := server.NewDoubleFixedPartitioner(nh.nhConfig.Expert.Engine.ExecShards,\n\t\t\tnh.nhConfig.Expert.LogDB.Shards)\n\t\tshard := p.GetPartitionID(shardID)\n\t\trn, err := newNode(peers,\n\t\t\tim,\n\t\t\tcfg,\n\t\t\tnh.nhConfig,\n\t\t\tcreateStateMachine,\n\t\t\tss,\n\t\t\tlogReader,\n\t\t\tnh.engine,\n\t\t\tnh.events.leaderInfoQ,\n\t\t\tnh.transport.GetStreamSink,\n\t\t\tnh.msgHandler.HandleSnapshotStatus,\n\t\t\tnh.sendMessage,\n\t\t\tnh.nodes,\n\t\t\tnh.requestPools[replicaID%requestPoolShards],\n\t\t\tnh.mu.logdb,\n\t\t\tnh.getLogDBMetrics(shard),\n\t\t\tnh.events.sys)\n\t\tif err != nil {\n\t\t\tpanicNow(err)\n\t\t}\n\t\trn.loaded()\n\t\tnh.mu.shards.Store(shardID, rn)\n\t\tnh.mu.cci++\n\t\tnh.cciUpdated()\n\t\tnh.engine.setCCIReady(shardID)\n\t\tnh.engine.setApplyReady(shardID)\n\n\t\treturn rn, nil\n\t}\n\n\trn, err := doStart()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif cfg.WaitReady {\n\t\tselect {\n\t\tcase <-rn.initializedC:\n\t\tcase <-rn.stopC:\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (nh *NodeHost) cciUpdated() {\n\tselect {\n\tcase nh.mu.cciCh <- struct{}{}:\n\tdefault:\n\t}\n}\n\nfunc (nh *NodeHost) loadNodeHostID() error {\n\tv, err := nh.env.PrepareNodeHostID(nh.nhConfig.NodeHostID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnh.id = v\n\treturn nil\n}\n\nfunc (nh *NodeHost) createPools() {\n\tnh.requestPools = make([]*sync.Pool, requestPoolShards)\n\tfor i := uint64(0); i < requestPoolShards; i++ {\n\t\tp := &sync.Pool{}\n\t\tp.New = func() interface{} {\n\t\t\tobj := &RequestState{}\n\t\t\tobj.CompletedC = make(chan RequestResult, 1)\n\t\t\tobj.pool = p\n\t\t\tif nh.nhConfig.NotifyCommit {\n\t\t\t\tobj.committedC = make(chan RequestResult, 1)\n\t\t\t}\n\t\t\treturn obj\n\t\t}\n\t\tnh.requestPools[i] = p\n\t}\n}\n\nfunc (nh *NodeHost) createLogDB() error {\n\tdid := nh.nhConfig.GetDeploymentID()\n\tnhDir, walDir, err := nh.env.CreateNodeHostDir(did)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := nh.env.LockNodeHostDir(); err != nil {\n\t\treturn err\n\t}\n\tvar lf config.LogDBFactory\n\tif nh.nhConfig.Expert.LogDBFactory != nil {\n\t\tlf = nh.nhConfig.Expert.LogDBFactory\n\t} else {\n\t\tlf = logdb.NewDefaultFactory()\n\t}\n\tname := lf.Name()\n\tif err := nh.env.CheckLogDBType(nh.nhConfig, name); err != nil {\n\t\treturn err\n\t}\n\tldb, err := lf.Create(nh.nhConfig,\n\t\tnh.handleLogDBInfo, []string{nhDir}, []string{walDir})\n\tif err != nil {\n\t\treturn err\n\t}\n\tnh.mu.logdb = ldb\n\tver := ldb.BinaryFormat()\n\tif err := nh.env.CheckNodeHostDir(nh.nhConfig, ver, name); err != nil {\n\t\treturn err\n\t}\n\tif shardedrdb, ok := ldb.(*logdb.ShardedDB); ok {\n\t\tfailed, err := shardedrdb.SelfCheckFailed()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif failed {\n\t\t\treturn server.ErrLogDBBrokenChange\n\t\t}\n\t}\n\tplog.Infof(\"logdb memory limit: %d MBytes\",\n\t\tnh.nhConfig.Expert.LogDB.MemorySizeMB())\n\treturn nil\n}\n\nfunc (nh *NodeHost) handleLogDBInfo(info config.LogDBInfo) {\n\tplog.Infof(\"LogDB info received, shard %d, busy %t\", info.Shard, info.Busy)\n\tnh.mu.Lock()\n\tdefer nh.mu.Unlock()\n\tlm := nh.getLogDBMetrics(info.Shard)\n\tlm.update(info.Busy)\n}\n\nfunc (nh *NodeHost) getLogDBMetrics(shard uint64) *logDBMetrics {\n\tif v, ok := nh.mu.lm.Load(shard); ok {\n\t\treturn v.(*logDBMetrics)\n\t}\n\tlm := &logDBMetrics{}\n\tnh.mu.lm.Store(shard, lm)\n\treturn lm\n}\n\ntype transportEvent struct {\n\tnh *NodeHost\n}\n\nfunc (te *transportEvent) ConnectionEstablished(addr string, snapshot bool) {\n\tte.nh.events.sys.Publish(server.SystemEvent{\n\t\tType:               server.ConnectionEstablished,\n\t\tAddress:            addr,\n\t\tSnapshotConnection: snapshot,\n\t})\n}\n\nfunc (te *transportEvent) ConnectionFailed(addr string, snapshot bool) {\n\tte.nh.events.sys.Publish(server.SystemEvent{\n\t\tType:               server.ConnectionFailed,\n\t\tAddress:            addr,\n\t\tSnapshotConnection: snapshot,\n\t})\n}\n\nfunc (nh *NodeHost) createNodeRegistry() error {\n\tvalidator := nh.nhConfig.GetTargetValidator()\n\t// TODO:\n\t// more tests here required\n\tif nh.nhConfig.DefaultNodeRegistryEnabled {\n\t\t// DefaultNodeRegistryEnabled should not be set if a Expert.NodeRegistryFactory\n\t\t// is also set.\n\t\tif nh.nhConfig.Expert.NodeRegistryFactory != nil {\n\t\t\treturn errors.New(\"DefaultNodeRegistryEnabled and Expert.NodeRegistryFactory should not both be set\")\n\t\t}\n\t\tplog.Infof(\"DefaultNodeRegistryEnabled: true, use gossip based node registry\")\n\t\tr, err := registry.NewGossipRegistry(nh.ID(), nh.getShardInfo,\n\t\t\tnh.nhConfig, streamConnections, validator)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnh.registry = r.GetNodeHostRegistry()\n\t\tnh.nodes = r\n\t} else if nh.nhConfig.Expert.NodeRegistryFactory != nil {\n\t\tplog.Infof(\"Expert.NodeRegistryFactory was set: using custom registry\")\n\t\tr, err := nh.nhConfig.Expert.NodeRegistryFactory.Create(nh.ID(), streamConnections, validator)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnh.nodes = r\n\t} else {\n\t\tplog.Infof(\"using regular node registry\")\n\t\tnh.nodes = registry.NewNodeRegistry(streamConnections, validator)\n\t}\n\treturn nil\n}\n\nfunc (nh *NodeHost) createTransport() error {\n\tgetSnapshotDir := func(cid uint64, nid uint64) string {\n\t\treturn nh.env.GetSnapshotDir(nh.nhConfig.GetDeploymentID(), cid, nid)\n\t}\n\ttsp, err := transport.NewTransport(nh.nhConfig,\n\t\tnh.msgHandler, nh.env, nh.nodes, getSnapshotDir,\n\t\t&transportEvent{nh: nh}, nh.fs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnh.transport = tsp\n\treturn nil\n}\n\nfunc (nh *NodeHost) stopNode(shardID uint64, replicaID uint64, check bool) error {\n\tnh.mu.Lock()\n\tdefer nh.mu.Unlock()\n\tv, ok := nh.mu.shards.Load(shardID)\n\tif !ok {\n\t\treturn ErrShardNotFound\n\t}\n\tn := v.(*node)\n\tif check && n.replicaID != replicaID {\n\t\treturn ErrShardNotFound\n\t}\n\tnh.mu.shards.Delete(shardID)\n\tnh.mu.cci++\n\tnh.cciUpdated()\n\tnh.engine.setCCIReady(shardID)\n\tn.close()\n\tn.offloaded()\n\tnh.engine.setStepReady(shardID)\n\tnh.engine.setCommitReady(shardID)\n\tnh.engine.setApplyReady(shardID)\n\tnh.engine.setRecoverReady(shardID)\n\treturn nil\n}\n\nfunc (nh *NodeHost) getShardInfo() []ShardInfo {\n\tshardInfoList := make([]ShardInfo, 0)\n\tnh.forEachShard(func(cid uint64, node *node) bool {\n\t\tshardInfoList = append(shardInfoList, node.getShardInfo())\n\t\treturn true\n\t})\n\treturn shardInfoList\n}\n\nfunc (nh *NodeHost) tickWorkerMain() {\n\ttick := uint64(0)\n\tidx := uint64(0)\n\tnodes := make([]*node, 0)\n\ttf := func() {\n\t\ttick++\n\t\tif idx != nh.getShardSetIndex() {\n\t\t\tnodes = nodes[:0]\n\t\t\tidx = nh.forEachShard(func(cid uint64, n *node) bool {\n\t\t\t\tnodes = append(nodes, n)\n\t\t\t\treturn true\n\t\t\t})\n\t\t}\n\t\tnh.sendTickMessage(nodes, tick)\n\t\tnh.engine.setAllStepReady(nodes)\n\t}\n\ttd := time.Duration(nh.nhConfig.RTTMillisecond) * time.Millisecond\n\tticker := time.NewTicker(td)\n\tdefer ticker.Stop()\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\ttf()\n\t\tcase <-nh.stopper.ShouldStop():\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (nh *NodeHost) handleListenerEvents() {\n\tvar ch chan struct{}\n\tif nh.events.leaderInfoQ != nil {\n\t\tch = nh.events.leaderInfoQ.workReady()\n\t}\n\tfor {\n\t\tselect {\n\t\tcase <-nh.stopper.ShouldStop():\n\t\t\treturn\n\t\tcase <-ch:\n\t\t\tfor {\n\t\t\t\tv, ok := nh.events.leaderInfoQ.getLeaderInfo()\n\t\t\t\tif !ok {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tnh.events.raft.LeaderUpdated(v)\n\t\t\t}\n\t\tcase e := <-nh.events.sys.events:\n\t\t\tnh.events.sys.handle(e)\n\t\t}\n\t}\n}\n\nfunc (nh *NodeHost) sendMessage(msg pb.Message) {\n\tif nh.isPartitioned() {\n\t\treturn\n\t}\n\tif msg.Type != pb.InstallSnapshot {\n\t\tnh.transport.Send(msg)\n\t} else {\n\t\twitness := msg.Snapshot.Witness\n\t\tplog.Debugf(\"%s is sending snapshot to %s, witness %t, index %d, size %d\",\n\t\t\tdn(msg.ShardID, msg.From), dn(msg.ShardID, msg.To),\n\t\t\twitness, msg.Snapshot.Index, msg.Snapshot.FileSize)\n\t\tif n, ok := nh.getShard(msg.ShardID); ok {\n\t\t\tif witness || !n.OnDiskStateMachine() {\n\t\t\t\tnh.transport.SendSnapshot(msg)\n\t\t\t} else {\n\t\t\t\tn.pushStreamSnapshotRequest(msg.ShardID, msg.To)\n\t\t\t}\n\t\t}\n\t\tnh.events.sys.Publish(server.SystemEvent{\n\t\t\tType:      server.SendSnapshotStarted,\n\t\t\tShardID:   msg.ShardID,\n\t\t\tReplicaID: msg.To,\n\t\t\tFrom:      msg.From,\n\t\t})\n\t}\n}\n\nfunc (nh *NodeHost) sendTickMessage(shards []*node, tick uint64) {\n\tfor _, n := range shards {\n\t\tm := pb.Message{\n\t\t\tType: pb.LocalTick,\n\t\t\tTo:   n.replicaID,\n\t\t\tFrom: n.replicaID,\n\t\t\tHint: tick,\n\t\t}\n\t\tn.mq.Tick()\n\t\tn.mq.Add(m)\n\t}\n}\n\nfunc (nh *NodeHost) nodeMonitorMain() {\n\tfor {\n\t\tnodes := make([]*node, 0)\n\t\tnh.forEachShard(func(cid uint64, node *node) bool {\n\t\t\tnodes = append(nodes, node)\n\t\t\treturn true\n\t\t})\n\t\tcases := make([]reflect.SelectCase, len(nodes)+2)\n\t\tfor i, n := range nodes {\n\t\t\tcases[i] = reflect.SelectCase{\n\t\t\t\tDir:  reflect.SelectRecv,\n\t\t\t\tChan: reflect.ValueOf(n.ShouldStop()),\n\t\t\t}\n\t\t}\n\t\tcases[len(nodes)] = reflect.SelectCase{\n\t\t\tDir:  reflect.SelectRecv,\n\t\t\tChan: reflect.ValueOf(nh.mu.cciCh),\n\t\t}\n\t\tcases[len(nodes)+1] = reflect.SelectCase{\n\t\t\tDir:  reflect.SelectRecv,\n\t\t\tChan: reflect.ValueOf(nh.stopper.ShouldStop()),\n\t\t}\n\t\tindex, _, ok := reflect.Select(cases)\n\t\tif !ok && index < len(nodes) {\n\t\t\t// node closed\n\t\t\tn := nodes[index]\n\t\t\tif err := nh.stopNode(n.shardID, n.replicaID, true); err != nil {\n\t\t\t\tplog.Debugf(\"stopNode failed %v\", err)\n\t\t\t}\n\t\t} else if index == len(nodes) {\n\t\t\t// cci change\n\t\t\tcontinue\n\t\t} else if index == len(nodes)+1 {\n\t\t\t// stopped\n\t\t\treturn\n\t\t} else {\n\t\t\tplog.Panicf(\"unknown node list change state, %d, %t\", index, ok)\n\t\t}\n\t}\n}\n\nfunc (nh *NodeHost) getTimeoutTick(timeout time.Duration) uint64 {\n\treturn uint64(timeout.Milliseconds()) / nh.nhConfig.RTTMillisecond\n}\n\nfunc (nh *NodeHost) describe() string {\n\treturn nh.RaftAddress()\n}\n\nfunc (nh *NodeHost) logNodeHostDetails() {\n\tplog.Infof(\"transport type: %s\", nh.transport.Name())\n\tplog.Infof(\"logdb type: %s\", nh.mu.logdb.Name())\n\tplog.Infof(\"nodehost address: %s\", nh.nhConfig.RaftAddress)\n}\n\nfunc getRequestState(ctx context.Context, rs *RequestState) (sm.Result, error) {\n\tselect {\n\tcase r := <-rs.AppliedC():\n\t\tif r.Completed() {\n\t\t\treturn r.GetResult(), nil\n\t\t} else if r.Rejected() {\n\t\t\treturn sm.Result{}, ErrRejected\n\t\t} else if r.Timeout() {\n\t\t\treturn sm.Result{}, ErrTimeout\n\t\t} else if r.Terminated() {\n\t\t\treturn sm.Result{}, ErrShardClosed\n\t\t} else if r.Dropped() {\n\t\t\treturn sm.Result{}, ErrShardNotReady\n\t\t} else if r.Aborted() {\n\t\t\treturn sm.Result{}, ErrAborted\n\t\t}\n\t\tplog.Panicf(\"unknown v code %v\", r)\n\tcase <-ctx.Done():\n\t\tif ctx.Err() == context.Canceled {\n\t\t\treturn sm.Result{}, ErrCanceled\n\t\t} else if ctx.Err() == context.DeadlineExceeded {\n\t\t\treturn sm.Result{}, ErrTimeout\n\t\t}\n\t}\n\tpanic(\"should never reach here\")\n}\n\n// INodeUser is the interface implemented by a Raft node user type. A Raft node\n// user can be used to directly initiate proposals or read index operations\n// without locating the Raft node in NodeHost's node list first. It is useful\n// when doing bulk load operations on selected shards.\ntype INodeUser interface {\n\t// ShardID is the shard ID of the node.\n\tShardID() uint64\n\t// ReplicaID is the replica ID of the node.\n\tReplicaID() uint64\n\t// Propose starts an asynchronous proposal on the Raft shard represented by\n\t// the INodeUser instance. Its semantics is the same as the Propose() method\n\t// in NodeHost.\n\tPropose(s *client.Session,\n\t\tcmd []byte, timeout time.Duration) (*RequestState, error)\n\t// ReadIndex starts the asynchronous ReadIndex protocol used for linearizable\n\t// reads on the Raft shard represented by the INodeUser instance. Its\n\t// semantics is the same as the ReadIndex() method in NodeHost.\n\tReadIndex(timeout time.Duration) (*RequestState, error)\n}\n\ntype nodeUser struct {\n\tnh           *NodeHost\n\tnode         *node\n\tsetStepReady func(shardID uint64)\n}\n\nvar _ INodeUser = (*nodeUser)(nil)\n\nfunc (nu *nodeUser) ShardID() uint64 {\n\treturn nu.node.shardID\n}\n\nfunc (nu *nodeUser) ReplicaID() uint64 {\n\treturn nu.node.replicaID\n}\n\nfunc (nu *nodeUser) Propose(s *client.Session,\n\tcmd []byte, timeout time.Duration) (*RequestState, error) {\n\treq, err := nu.node.propose(s, cmd, nu.nh.getTimeoutTick(timeout))\n\tnu.setStepReady(s.ShardID)\n\treturn req, err\n}\n\nfunc (nu *nodeUser) ReadIndex(timeout time.Duration) (*RequestState, error) {\n\treturn nu.node.read(nu.nh.getTimeoutTick(timeout))\n}\n\nfunc getTimeoutFromContext(ctx context.Context) (time.Duration, error) {\n\td, ok := ctx.Deadline()\n\tif !ok {\n\t\treturn 0, ErrDeadlineNotSet\n\t}\n\tnow := time.Now()\n\tif now.After(d) {\n\t\treturn 0, ErrInvalidDeadline\n\t}\n\treturn d.Sub(now), nil\n}\n\nvar (\n\tstreamPushDelayTick      uint64 = 10\n\tstreamConfirmedDelayTick uint64 = 2\n)\n\ntype messageHandler struct {\n\tnh *NodeHost\n}\n\nvar _ transport.IMessageHandler = (*messageHandler)(nil)\n\nfunc newNodeHostMessageHandler(nh *NodeHost) *messageHandler {\n\treturn &messageHandler{nh: nh}\n}\n\nfunc (h *messageHandler) HandleMessageBatch(msg pb.MessageBatch) (uint64, uint64) {\n\tnh := h.nh\n\tsnapshotCount := uint64(0)\n\tmsgCount := uint64(0)\n\tif nh.isPartitioned() {\n\t\tkeep := false\n\t\t// InstallSnapshot is a in-memory local message type that will never be\n\t\t// dropped in production as it will never be sent via networks\n\t\tfor _, req := range msg.Requests {\n\t\t\tif req.Type == pb.InstallSnapshot {\n\t\t\t\tkeep = true\n\t\t\t}\n\t\t}\n\t\tif !keep {\n\t\t\treturn 0, 0\n\t\t}\n\t}\n\tfor _, req := range msg.Requests {\n\t\tif req.To == 0 {\n\t\t\tplog.Panicf(\"to field not set, %s\", req.Type)\n\t\t}\n\t\tif n, ok := nh.getShard(req.ShardID); ok {\n\t\t\tif n.replicaID != req.To {\n\t\t\t\tplog.Warningf(\"ignored a %s message sent to %s but received by %s\",\n\t\t\t\t\treq.Type, dn(req.ShardID, req.To), dn(req.ShardID, n.replicaID))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif req.Type == pb.InstallSnapshot {\n\t\t\t\tn.mq.MustAdd(req)\n\t\t\t\tsnapshotCount++\n\t\t\t} else if req.Type == pb.SnapshotReceived {\n\t\t\t\tplog.Debugf(\"SnapshotReceived received, shard id %d, replica id %d\",\n\t\t\t\t\treq.ShardID, req.From)\n\t\t\t\tn.mq.AddDelayed(pb.Message{\n\t\t\t\t\tType: pb.SnapshotStatus,\n\t\t\t\t\tFrom: req.From,\n\t\t\t\t}, streamConfirmedDelayTick)\n\t\t\t\tmsgCount++\n\t\t\t} else {\n\t\t\t\tif added, stopped := n.mq.Add(req); !added || stopped {\n\t\t\t\t\tplog.Warningf(\"dropped an incoming message\")\n\t\t\t\t} else {\n\t\t\t\t\tmsgCount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnh.engine.setStepReadyByMessageBatch(msg)\n\treturn snapshotCount, msgCount\n}\n\nfunc (h *messageHandler) HandleSnapshotStatus(shardID uint64,\n\treplicaID uint64, failed bool) {\n\teventType := server.SendSnapshotCompleted\n\tif failed {\n\t\teventType = server.SendSnapshotAborted\n\t}\n\th.nh.events.sys.Publish(server.SystemEvent{\n\t\tType:      eventType,\n\t\tShardID:   shardID,\n\t\tReplicaID: replicaID,\n\t})\n\tif n, ok := h.nh.getShard(shardID); ok {\n\t\tn.mq.AddDelayed(pb.Message{\n\t\t\tType:   pb.SnapshotStatus,\n\t\t\tFrom:   replicaID,\n\t\t\tReject: failed,\n\t\t}, streamPushDelayTick)\n\t\th.nh.engine.setStepReady(shardID)\n\t}\n}\n\nfunc (h *messageHandler) HandleUnreachable(shardID uint64, replicaID uint64) {\n\tif n, ok := h.nh.getShard(shardID); ok {\n\t\tm := pb.Message{\n\t\t\tType: pb.Unreachable,\n\t\t\tFrom: replicaID,\n\t\t\tTo:   n.replicaID,\n\t\t}\n\t\tn.mq.MustAdd(m)\n\t\th.nh.engine.setStepReady(shardID)\n\t}\n}\n\nfunc (h *messageHandler) HandleSnapshot(shardID uint64,\n\treplicaID uint64, from uint64) {\n\tm := pb.Message{\n\t\tTo:      from,\n\t\tFrom:    replicaID,\n\t\tShardID: shardID,\n\t\tType:    pb.SnapshotReceived,\n\t}\n\th.nh.sendMessage(m)\n\tplog.Debugf(\"%s sent SnapshotReceived to %d\", dn(shardID, replicaID), from)\n\th.nh.events.sys.Publish(server.SystemEvent{\n\t\tType:      server.SnapshotReceived,\n\t\tShardID:   shardID,\n\t\tReplicaID: replicaID,\n\t\tFrom:      from,\n\t})\n}\n\nfunc logBuildTagsAndVersion() {\n\tdevstr := \"Rel\"\n\tif DEVVersion {\n\t\tdevstr = \"Dev\"\n\t}\n\tplog.Infof(\"go version: %s, %s/%s\",\n\t\truntime.Version(), runtime.GOOS, runtime.GOARCH)\n\tplog.Infof(\"dragonboat version: %d.%d.%d (%s)\",\n\t\tDragonboatMajor, DragonboatMinor, DragonboatPatch, devstr)\n\tif !invariants.IsSupportedOS() || !invariants.IsSupportedArch() {\n\t\tplog.Warningf(\"unsupported OS/ARCH %s/%s, don't use for production\",\n\t\t\truntime.GOOS, runtime.GOARCH)\n\t}\n}\n\nfunc panicNow(err error) {\n\tif err == nil {\n\t\tpanic(\"panicNow called with nil error\")\n\t}\n\tplog.Panicf(\"%+v\", err)\n\tpanic(err)\n}\n"
        },
        {
          "name": "nodehost_test.go",
          "type": "blob",
          "size": 165.6181640625,
          "content": "// Copyright 2017-2021 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dragonboat\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/binary\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"math/rand\"\n\t\"os\"\n\t\"os/exec\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/cockroachdb/errors\"\n\t\"github.com/lni/goutils/leaktest\"\n\t\"github.com/lni/goutils/random\"\n\t\"github.com/lni/goutils/syncutil\"\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"github.com/lni/dragonboat/v4/client\"\n\t\"github.com/lni/dragonboat/v4/config\"\n\t\"github.com/lni/dragonboat/v4/internal/fileutil\"\n\t\"github.com/lni/dragonboat/v4/internal/id\"\n\t\"github.com/lni/dragonboat/v4/internal/invariants\"\n\t\"github.com/lni/dragonboat/v4/internal/logdb\"\n\t\"github.com/lni/dragonboat/v4/internal/registry\"\n\t\"github.com/lni/dragonboat/v4/internal/rsm\"\n\t\"github.com/lni/dragonboat/v4/internal/server\"\n\t\"github.com/lni/dragonboat/v4/internal/settings\"\n\t\"github.com/lni/dragonboat/v4/internal/tests\"\n\t\"github.com/lni/dragonboat/v4/internal/transport\"\n\t\"github.com/lni/dragonboat/v4/internal/vfs\"\n\tchantrans \"github.com/lni/dragonboat/v4/plugin/chan\"\n\t\"github.com/lni/dragonboat/v4/raftio\"\n\tpb \"github.com/lni/dragonboat/v4/raftpb\"\n\tsm \"github.com/lni/dragonboat/v4/statemachine\"\n\t\"github.com/lni/dragonboat/v4/tools\"\n\t\"github.com/lni/dragonboat/v4/tools/upgrade310\"\n)\n\nconst (\n\tdefaultTestPort = 26001\n\ttestNodeHostID1 = \"123e4567-e89b-12d3-a456-426614174000\"\n\ttestNodeHostID2 = \"123e4567-e89b-12d3-a456-426614174001\"\n)\n\nfunc getTestPort() int {\n\tpv := os.Getenv(\"DRAGONBOAT_TEST_PORT\")\n\tif len(pv) > 0 {\n\t\tport, err := strconv.Atoi(pv)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\treturn port\n\t}\n\treturn defaultTestPort\n}\n\nvar rttMillisecond uint64\nvar mu sync.Mutex\n\nvar rttValues = []uint64{10, 20, 30, 50, 100, 200, 500}\n\nfunc getRTTMillisecond(fs vfs.IFS, dir string) uint64 {\n\tmu.Lock()\n\tdefer mu.Unlock()\n\tif rttMillisecond > 0 {\n\t\treturn rttMillisecond\n\t}\n\trttMillisecond = calcRTTMillisecond(fs, dir)\n\treturn rttMillisecond\n}\n\nfunc calcRTTMillisecond(fs vfs.IFS, dir string) uint64 {\n\ttestFile := fs.PathJoin(dir, \".dragonboat_test_file_safe_to_delete\")\n\tdefer func() {\n\t\t_ = fs.RemoveAll(testFile)\n\t}()\n\t_ = fs.MkdirAll(dir, 0755)\n\tf, err := fs.Create(testFile)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer func() {\n\t\tf.Close()\n\t}()\n\tdata := make([]byte, 512)\n\ttotal := uint64(0)\n\trepeat := 5\n\tfor i := 0; i < repeat; i++ {\n\t\tif _, err := f.Write(data); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tstart := time.Now()\n\t\tif err := f.Sync(); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\ttotal += uint64(time.Since(start).Milliseconds())\n\t}\n\trtt := total / uint64(repeat)\n\tfor i := range rttValues {\n\t\tif rttValues[i] > rtt {\n\t\t\tif i == 0 {\n\t\t\t\treturn rttValues[0]\n\t\t\t}\n\t\t\treturn rttValues[i-1]\n\t\t}\n\t}\n\treturn rttValues[len(rttValues)-1]\n}\n\n// typical proposal timeout\nfunc pto(nh *NodeHost) time.Duration {\n\trtt := nh.NodeHostConfig().RTTMillisecond\n\tif invariants.Race {\n\t\treturn 5 * time.Second\n\t}\n\treturn time.Duration(rtt*45) * time.Millisecond\n}\n\nfunc lpto(nh *NodeHost) time.Duration {\n\trtt := nh.NodeHostConfig().RTTMillisecond\n\tif invariants.Race {\n\t\treturn 30 * time.Second\n\t}\n\treturn time.Duration(rtt*100) * time.Millisecond\n}\n\nfunc getTestExpertConfig(fs vfs.IFS) config.ExpertConfig {\n\tcfg := config.GetDefaultExpertConfig()\n\tcfg.LogDB.Shards = 4\n\tcfg.FS = fs\n\treturn cfg\n}\n\nfunc reportLeakedFD(fs vfs.IFS, t *testing.T) {\n\tvfs.ReportLeakedFD(fs, t)\n}\n\nfunc getTestNodeHostConfig(fs vfs.IFS) *config.NodeHostConfig {\n\tcfg := &config.NodeHostConfig{\n\t\tWALDir:              singleNodeHostTestDir,\n\t\tNodeHostDir:         singleNodeHostTestDir,\n\t\tRTTMillisecond:      getRTTMillisecond(fs, singleNodeHostTestDir),\n\t\tRaftAddress:         singleNodeHostTestAddr,\n\t\tExpert:              getTestExpertConfig(fs),\n\t\tSystemEventListener: &testSysEventListener{},\n\t}\n\treturn cfg\n}\n\nfunc getTestConfig() *config.Config {\n\treturn &config.Config{\n\t\tReplicaID:    1,\n\t\tShardID:      1,\n\t\tElectionRTT:  3,\n\t\tHeartbeatRTT: 1,\n\t\tCheckQuorum:  true,\n\t}\n}\n\nfunc waitNodeInfoEvent(t *testing.T, f func() []raftio.NodeInfo, count int) {\n\tfor i := 0; i < 1000; i++ {\n\t\tif len(f()) == count {\n\t\t\treturn\n\t\t}\n\t\ttime.Sleep(10 * time.Millisecond)\n\t}\n\tt.Fatalf(\"failed to get node info event\")\n}\n\nfunc waitSnapshotInfoEvent(t *testing.T, f func() []raftio.SnapshotInfo, count int) {\n\tfor i := 0; i < 1000; i++ {\n\t\tif len(f()) == count {\n\t\t\treturn\n\t\t}\n\t\ttime.Sleep(10 * time.Millisecond)\n\t}\n\tt.Fatalf(\"failed to get snapshot info event\")\n}\n\ntype testSysEventListener struct {\n\tmu                    sync.Mutex\n\tnodeHostShuttingdown  uint64\n\tnodeUnloaded          []raftio.NodeInfo\n\tnodeReady             []raftio.NodeInfo\n\tmembershipChanged     []raftio.NodeInfo\n\tsnapshotCreated       []raftio.SnapshotInfo\n\tsnapshotRecovered     []raftio.SnapshotInfo\n\tsnapshotReceived      []raftio.SnapshotInfo\n\tsendSnapshotStarted   []raftio.SnapshotInfo\n\tsendSnapshotCompleted []raftio.SnapshotInfo\n\tsnapshotCompacted     []raftio.SnapshotInfo\n\tlogCompacted          []raftio.EntryInfo\n\tlogdbCompacted        []raftio.EntryInfo\n\tconnectionEstablished uint64\n}\n\nfunc copyNodeInfo(info []raftio.NodeInfo) []raftio.NodeInfo {\n\treturn append([]raftio.NodeInfo{}, info...)\n}\n\nfunc (t *testSysEventListener) NodeHostShuttingDown() {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.nodeHostShuttingdown++\n}\n\nfunc (t *testSysEventListener) NodeReady(info raftio.NodeInfo) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.nodeReady = append(t.nodeReady, info)\n}\n\nfunc (t *testSysEventListener) getNodeReady() []raftio.NodeInfo {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn copyNodeInfo(t.nodeReady)\n}\n\nfunc (t *testSysEventListener) NodeUnloaded(info raftio.NodeInfo) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.nodeUnloaded = append(t.nodeUnloaded, info)\n}\n\nfunc (t *testSysEventListener) getNodeUnloaded() []raftio.NodeInfo {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn copyNodeInfo(t.nodeUnloaded)\n}\n\nfunc (t *testSysEventListener) NodeDeleted(info raftio.NodeInfo) {}\n\nfunc (t *testSysEventListener) MembershipChanged(info raftio.NodeInfo) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.membershipChanged = append(t.membershipChanged, info)\n}\n\nfunc (t *testSysEventListener) getMembershipChanged() []raftio.NodeInfo {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn copyNodeInfo(t.membershipChanged)\n}\n\nfunc (t *testSysEventListener) ConnectionEstablished(info raftio.ConnectionInfo) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.connectionEstablished++\n}\n\nfunc (t *testSysEventListener) getConnectionEstablished() uint64 {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn t.connectionEstablished\n}\n\nfunc (t *testSysEventListener) ConnectionFailed(info raftio.ConnectionInfo) {}\n\nfunc copySnapshotInfo(info []raftio.SnapshotInfo) []raftio.SnapshotInfo {\n\treturn append([]raftio.SnapshotInfo{}, info...)\n}\n\nfunc (t *testSysEventListener) SendSnapshotStarted(info raftio.SnapshotInfo) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.sendSnapshotStarted = append(t.sendSnapshotStarted, info)\n}\n\nfunc (t *testSysEventListener) getSendSnapshotStarted() []raftio.SnapshotInfo {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn copySnapshotInfo(t.sendSnapshotStarted)\n}\n\nfunc (t *testSysEventListener) SendSnapshotCompleted(info raftio.SnapshotInfo) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.sendSnapshotCompleted = append(t.sendSnapshotCompleted, info)\n}\n\nfunc (t *testSysEventListener) getSendSnapshotCompleted() []raftio.SnapshotInfo {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn copySnapshotInfo(t.sendSnapshotCompleted)\n}\n\nfunc (t *testSysEventListener) SendSnapshotAborted(info raftio.SnapshotInfo) {}\nfunc (t *testSysEventListener) SnapshotReceived(info raftio.SnapshotInfo) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.snapshotReceived = append(t.snapshotReceived, info)\n}\n\nfunc (t *testSysEventListener) getSnapshotReceived() []raftio.SnapshotInfo {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn copySnapshotInfo(t.snapshotReceived)\n}\n\nfunc (t *testSysEventListener) SnapshotRecovered(info raftio.SnapshotInfo) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.snapshotRecovered = append(t.snapshotRecovered, info)\n}\n\nfunc (t *testSysEventListener) getSnapshotRecovered() []raftio.SnapshotInfo {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn copySnapshotInfo(t.snapshotRecovered)\n}\n\nfunc (t *testSysEventListener) SnapshotCreated(info raftio.SnapshotInfo) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.snapshotCreated = append(t.snapshotCreated, info)\n}\n\nfunc (t *testSysEventListener) getSnapshotCreated() []raftio.SnapshotInfo {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn copySnapshotInfo(t.snapshotCreated)\n}\n\nfunc (t *testSysEventListener) SnapshotCompacted(info raftio.SnapshotInfo) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.snapshotCompacted = append(t.snapshotCompacted, info)\n}\n\nfunc copyEntryInfo(info []raftio.EntryInfo) []raftio.EntryInfo {\n\treturn append([]raftio.EntryInfo{}, info...)\n}\n\nfunc (t *testSysEventListener) LogCompacted(info raftio.EntryInfo) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.logCompacted = append(t.logCompacted, info)\n}\n\nfunc (t *testSysEventListener) getLogCompacted() []raftio.EntryInfo {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn copyEntryInfo(t.logCompacted)\n}\n\nfunc (t *testSysEventListener) LogDBCompacted(info raftio.EntryInfo) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.logdbCompacted = append(t.logdbCompacted, info)\n}\n\ntype TimeoutStateMachine struct {\n\tupdateDelay   uint64\n\tlookupDelay   uint64\n\tsnapshotDelay uint64\n\tclosed        bool\n}\n\nfunc (t *TimeoutStateMachine) Update(e sm.Entry) (sm.Result, error) {\n\tif t.updateDelay > 0 {\n\t\ttime.Sleep(time.Duration(t.updateDelay) * time.Millisecond)\n\t}\n\treturn sm.Result{}, nil\n}\n\nfunc (t *TimeoutStateMachine) Lookup(data interface{}) (interface{}, error) {\n\tif t.lookupDelay > 0 {\n\t\ttime.Sleep(time.Duration(t.lookupDelay) * time.Millisecond)\n\t}\n\treturn data, nil\n}\n\nfunc (t *TimeoutStateMachine) SaveSnapshot(w io.Writer,\n\tfc sm.ISnapshotFileCollection, stopc <-chan struct{}) error {\n\tif t.snapshotDelay > 0 {\n\t\ttime.Sleep(time.Duration(t.snapshotDelay) * time.Millisecond)\n\t}\n\t_, err := w.Write([]byte(\"done\"))\n\treturn err\n}\n\nfunc (t *TimeoutStateMachine) RecoverFromSnapshot(r io.Reader,\n\tfc []sm.SnapshotFile, stopc <-chan struct{}) error {\n\treturn nil\n}\n\nfunc (t *TimeoutStateMachine) Close() error {\n\tt.closed = true\n\treturn nil\n}\n\ntype noopLogDB struct {\n}\n\nfunc (n *noopLogDB) BinaryFormat() uint32                                       { return 0 }\nfunc (n *noopLogDB) Name() string                                               { return \"noopLogDB\" }\nfunc (n *noopLogDB) Close() error                                               { return nil }\nfunc (n *noopLogDB) HasNodeInfo(shardID uint64, replicaID uint64) (bool, error) { return true, nil }\nfunc (n *noopLogDB) CreateNodeInfo(shardID uint64, replicaID uint64) error      { return nil }\nfunc (n *noopLogDB) ListNodeInfo() ([]raftio.NodeInfo, error)                   { return nil, nil }\nfunc (n *noopLogDB) SaveBootstrapInfo(shardID uint64, replicaID uint64, bs pb.Bootstrap) error {\n\treturn nil\n}\nfunc (n *noopLogDB) GetBootstrapInfo(shardID uint64, replicaID uint64) (pb.Bootstrap, error) {\n\treturn pb.Bootstrap{}, nil\n}\nfunc (n *noopLogDB) SaveRaftState(updates []pb.Update, workerID uint64) error { return nil }\nfunc (n *noopLogDB) IterateEntries(ents []pb.Entry,\n\tsize uint64, shardID uint64, replicaID uint64, low uint64,\n\thigh uint64, maxSize uint64) ([]pb.Entry, uint64, error) {\n\treturn nil, 0, nil\n}\nfunc (n *noopLogDB) ReadRaftState(shardID uint64, replicaID uint64,\n\tlastIndex uint64) (raftio.RaftState, error) {\n\treturn raftio.RaftState{}, nil\n}\nfunc (n *noopLogDB) RemoveEntriesTo(shardID uint64, replicaID uint64, index uint64) error { return nil }\nfunc (n *noopLogDB) CompactEntriesTo(shardID uint64,\n\treplicaID uint64, index uint64) (<-chan struct{}, error) {\n\treturn nil, nil\n}\nfunc (n *noopLogDB) RemoveNodeData(shardID uint64, replicaID uint64) error { return nil }\nfunc (n *noopLogDB) SaveSnapshots([]pb.Update) error                       { return nil }\nfunc (n *noopLogDB) GetSnapshot(shardID uint64, replicaID uint64) (pb.Snapshot, error) {\n\treturn pb.Snapshot{}, nil\n}\nfunc (n *noopLogDB) ImportSnapshot(snapshot pb.Snapshot, replicaID uint64) error {\n\treturn nil\n}\n\ntype updateConfig func(*config.Config) *config.Config\ntype updateNodeHostConfig func(*config.NodeHostConfig) *config.NodeHostConfig\ntype testFunc func(*NodeHost)\ntype beforeTest func()\ntype afterTest func(*NodeHost)\n\ntype testOption struct {\n\tupdateConfig         updateConfig\n\tupdateNodeHostConfig updateNodeHostConfig\n\ttf                   testFunc\n\trf                   testFunc\n\tbt                   beforeTest\n\tat                   afterTest\n\tdefaultTestNode      bool\n\tfakeDiskNode         bool\n\tfakeDiskInitialIndex uint64\n\tcreateSM             sm.CreateStateMachineFunc\n\tcreateConcurrentSM   sm.CreateConcurrentStateMachineFunc\n\tcreateOnDiskSM       sm.CreateOnDiskStateMachineFunc\n\tjoin                 bool\n\tnewNodeHostToFail    bool\n\trestartNodeHost      bool\n\tnoElection           bool\n\tcompressed           bool\n\tfsErrorInjection     bool\n}\n\nfunc createSingleTestNode(t *testing.T, to *testOption, nh *NodeHost) {\n\tif to.createSM == nil &&\n\t\tto.createConcurrentSM == nil &&\n\t\tto.createOnDiskSM == nil && !to.defaultTestNode && !to.fakeDiskNode {\n\t\treturn\n\t}\n\tif to.defaultTestNode {\n\t\tto.createSM = func(uint64, uint64) sm.IStateMachine {\n\t\t\treturn &PST{}\n\t\t}\n\t}\n\tif to.fakeDiskNode {\n\t\tto.createOnDiskSM = func(uint64, uint64) sm.IOnDiskStateMachine {\n\t\t\treturn tests.NewFakeDiskSM(to.fakeDiskInitialIndex)\n\t\t}\n\t}\n\tcfg := getTestConfig()\n\tif to.updateConfig != nil {\n\t\tcfg = to.updateConfig(cfg)\n\t}\n\tif to.compressed {\n\t\tcfg.SnapshotCompressionType = config.Snappy\n\t\tcfg.EntryCompressionType = config.Snappy\n\t}\n\tpeers := make(map[uint64]string)\n\tif !to.join {\n\t\tif !nh.nhConfig.DefaultNodeRegistryEnabled {\n\t\t\tpeers[cfg.ShardID] = nh.RaftAddress()\n\t\t} else {\n\t\t\tpeers[cfg.ShardID] = nh.ID()\n\t\t}\n\t}\n\tif to.createSM != nil {\n\t\tif err := nh.StartReplica(peers, to.join, to.createSM, *cfg); err != nil {\n\t\t\tt.Fatalf(\"start shard failed: %v\", err)\n\t\t}\n\t} else if to.createConcurrentSM != nil {\n\t\tif err := nh.StartConcurrentReplica(peers,\n\t\t\tto.join, to.createConcurrentSM, *cfg); err != nil {\n\t\t\tt.Fatalf(\"start concurrent shard failed: %v\", err)\n\t\t}\n\t} else if to.createOnDiskSM != nil {\n\t\tif err := nh.StartOnDiskReplica(peers,\n\t\t\tto.join, to.createOnDiskSM, *cfg); err != nil {\n\t\t\tt.Fatalf(\"start on disk shard fail: %v\", err)\n\t\t}\n\t} else {\n\t\tt.Fatalf(\"?!?\")\n\t}\n}\n\nfunc runNodeHostTest(t *testing.T, to *testOption, fs vfs.IFS) {\n\tfunc() {\n\t\tif !to.fsErrorInjection {\n\t\t\tdefer leaktest.AfterTest(t)()\n\t\t}\n\t\t// FIXME:\n\t\t// the following RemoveAll call will fail on windows after running error\n\t\t// injection tests as some pebble log files are not closed\n\t\t_ = fs.RemoveAll(singleNodeHostTestDir)\n\t\tif to.bt != nil {\n\t\t\tto.bt()\n\t\t}\n\t\tnhc := getTestNodeHostConfig(fs)\n\t\tif to.updateNodeHostConfig != nil {\n\t\t\tnhc = to.updateNodeHostConfig(nhc)\n\t\t}\n\t\tnh, err := NewNodeHost(*nhc)\n\t\tif err != nil && !to.newNodeHostToFail {\n\t\t\tt.Fatalf(\"failed to create nodehost: %v\", err)\n\t\t}\n\t\tif err != nil && to.newNodeHostToFail {\n\t\t\treturn\n\t\t}\n\t\tif err == nil && to.newNodeHostToFail {\n\t\t\tt.Fatalf(\"NewNodeHost didn't fail as expected\")\n\t\t}\n\t\tif !to.restartNodeHost {\n\t\t\tdefer func() {\n\t\t\t\tfunc() {\n\t\t\t\t\tdefer func() {\n\t\t\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t\t\tif to.fsErrorInjection {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpanicNow(r.(error))\n\t\t\t\t\t\t}\n\t\t\t\t\t}()\n\t\t\t\t\tnh.Close()\n\t\t\t\t}()\n\t\t\t\tif to.at != nil {\n\t\t\t\t\tto.at(nh)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tcreateSingleTestNode(t, to, nh)\n\t\tif !to.noElection {\n\t\t\twaitForLeaderToBeElected(t, nh, 1)\n\t\t}\n\t\tif to.tf != nil {\n\t\t\tto.tf(nh)\n\t\t}\n\t\tif to.restartNodeHost {\n\t\t\tnh.Close()\n\t\t\tnh, err = NewNodeHost(*nhc)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to create nodehost: %v\", err)\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\tnh.Close()\n\t\t\t\tif to.at != nil {\n\t\t\t\t\tto.at(nh)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tcreateSingleTestNode(t, to, nh)\n\t\t\tif to.rf != nil {\n\t\t\t\tto.rf(nh)\n\t\t\t}\n\t\t}\n\t}()\n\treportLeakedFD(fs, t)\n}\n\nfunc createProposalsToTriggerSnapshot(t *testing.T,\n\tnh *NodeHost, count uint64, timeoutExpected bool) {\n\tfor i := uint64(0); i < count; i++ {\n\t\tpto := lpto(nh)\n\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\tcs, err := nh.SyncGetSession(ctx, 1)\n\t\tif err != nil {\n\t\t\tif err == ErrTimeout {\n\t\t\t\tcancel()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t}\n\t\t//time.Sleep(100 * time.Millisecond)\n\t\tif err := nh.SyncCloseSession(ctx, cs); err != nil {\n\t\t\tif err == ErrTimeout {\n\t\t\t\tcancel()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tt.Fatalf(\"failed to close client session %v\", err)\n\t\t}\n\t\tcancel()\n\t}\n\tif timeoutExpected {\n\t\tt.Fatalf(\"failed to trigger \")\n\t}\n}\n\nfunc runNodeHostTestDC(t *testing.T, f func(), removeDir bool, fs vfs.IFS) {\n\tdefer leaktest.AfterTest(t)()\n\tdefer func() {\n\t\tif err := fs.RemoveAll(singleNodeHostTestDir); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t}()\n\tif removeDir {\n\t\tif err := fs.RemoveAll(singleNodeHostTestDir); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t}\n\tf()\n\treportLeakedFD(fs, t)\n}\n\ntype testLogDBFactory struct {\n\tldb raftio.ILogDB\n}\n\nfunc (t *testLogDBFactory) Create(cfg config.NodeHostConfig,\n\tcb config.LogDBCallback, dirs []string, wals []string) (raftio.ILogDB, error) {\n\treturn t.ldb, nil\n}\n\nfunc (t *testLogDBFactory) Name() string {\n\treturn t.ldb.Name()\n}\n\nfunc TestLogDBCanBeExtended(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tldb := &noopLogDB{}\n\tto := &testOption{\n\t\tupdateNodeHostConfig: func(nhc *config.NodeHostConfig) *config.NodeHostConfig {\n\t\t\tnhc.Expert.LogDBFactory = &testLogDBFactory{ldb: ldb}\n\t\t\treturn nhc\n\t\t},\n\n\t\ttf: func(nh *NodeHost) {\n\t\t\tif nh.mu.logdb.Name() != ldb.Name() {\n\t\t\t\tt.Errorf(\"logdb type name %s, expect %s\", nh.mu.logdb.Name(), ldb.Name())\n\t\t\t}\n\t\t},\n\t\tnoElection: true,\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestTCPTransportIsUsedByDefault(t *testing.T) {\n\tif vfs.GetTestFS() != vfs.DefaultFS {\n\t\tt.Skip(\"memfs test mode, skipped\")\n\t}\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\ttf: func(nh *NodeHost) {\n\t\t\ttt := nh.transport.(*transport.Transport)\n\t\t\tif tt.GetTrans().Name() != transport.TCPTransportName {\n\t\t\t\tt.Errorf(\"transport type name %s, expect %s\",\n\t\t\t\t\ttt.GetTrans().Name(), transport.TCPTransportName)\n\t\t\t}\n\t\t},\n\t\tnoElection: true,\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\ntype noopTransportFactory struct{}\n\nfunc (noopTransportFactory) Create(cfg config.NodeHostConfig,\n\th raftio.MessageHandler, ch raftio.ChunkHandler) raftio.ITransport {\n\treturn transport.NewNOOPTransport(cfg, h, ch)\n}\n\nfunc (noopTransportFactory) Validate(string) bool {\n\treturn true\n}\n\nfunc TestTransportFactoryIsStillHonored(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tupdateNodeHostConfig: func(nhc *config.NodeHostConfig) *config.NodeHostConfig {\n\t\t\tnhc.Expert.TransportFactory = noopTransportFactory{}\n\t\t\treturn nhc\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\ttt := nh.transport.(*transport.Transport)\n\t\t\tif tt.GetTrans().Name() != transport.NOOPRaftName {\n\t\t\t\tt.Errorf(\"transport type name %s, expect %s\",\n\t\t\t\t\ttt.GetTrans().Name(), transport.NOOPRaftName)\n\t\t\t}\n\t\t},\n\t\tnoElection: true,\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestTransportFactoryCanBeSet(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tupdateNodeHostConfig: func(nhc *config.NodeHostConfig) *config.NodeHostConfig {\n\t\t\tnhc.Expert.TransportFactory = &transport.NOOPTransportFactory{}\n\t\t\treturn nhc\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\ttt := nh.transport.(*transport.Transport)\n\t\t\tif tt.GetTrans().Name() != transport.NOOPRaftName {\n\t\t\t\tt.Errorf(\"transport type name %s, expect %s\",\n\t\t\t\t\ttt.GetTrans().Name(), transport.NOOPRaftName)\n\t\t\t}\n\t\t},\n\t\tnoElection: true,\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\ntype validatorTestModule struct {\n}\n\nfunc (tm *validatorTestModule) Create(nhConfig config.NodeHostConfig,\n\thandler raftio.MessageHandler,\n\tchunkHandler raftio.ChunkHandler) raftio.ITransport {\n\treturn transport.NewNOOPTransport(nhConfig, handler, chunkHandler)\n}\n\nfunc (tm *validatorTestModule) Validate(addr string) bool {\n\treturn addr == \"localhost:12346\" || addr == \"localhost:26001\"\n}\n\nfunc TestAddressValidatorCanBeSet(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\tupdateNodeHostConfig: func(nhc *config.NodeHostConfig) *config.NodeHostConfig {\n\t\t\tnhc.Expert.TransportFactory = &validatorTestModule{}\n\t\t\treturn nhc\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := lpto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\terr := nh.SyncRequestAddReplica(ctx, 1, 100, \"localhost:12345\", 0)\n\t\t\tcancel()\n\t\t\tif err != ErrInvalidAddress {\n\t\t\t\tt.Fatalf(\"failed to return ErrInvalidAddress, %v\", err)\n\t\t\t}\n\t\t\tctx, cancel = context.WithTimeout(context.Background(), pto)\n\t\t\terr = nh.SyncRequestAddReplica(ctx, 1, 100, \"localhost:12346\", 0)\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to add node, %v\", err)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\ntype chanTransportFactory struct{}\n\nfunc (*chanTransportFactory) Create(nhConfig config.NodeHostConfig,\n\thandler raftio.MessageHandler,\n\tchunkHandler raftio.ChunkHandler) raftio.ITransport {\n\treturn chantrans.NewChanTransport(nhConfig, handler, chunkHandler)\n}\n\nfunc (tm *chanTransportFactory) Validate(addr string) bool {\n\treturn addr == nodeHostTestAddr1 || addr == nodeHostTestAddr2\n}\n\nfunc TestGossip(t *testing.T) {\n\ttestDefaultNodeRegistryEnabled(t, true, nil)\n}\n\nfunc TestMediumSizedClusterGossip(t *testing.T) {\n\tif os.Getenv(\"LONG_TEST\") == \"\" {\n\t\tt.Skip(\"Skipping long test\")\n\t}\n\tdefer leaktest.AfterTest(t)()\n\tfor i := 0; i < 16; i++ {\n\t\tfs := vfs.GetTestFS()\n\t\tdir := fs.PathJoin(singleNodeHostTestDir, fmt.Sprintf(\"nh%d\", i))\n\t\tcfg := config.NodeHostConfig{\n\t\t\tNodeHostDir:                dir,\n\t\t\tRTTMillisecond:             getRTTMillisecond(fs, dir),\n\t\t\tRaftAddress:                fmt.Sprintf(\"127.0.0.1:%d\", 25000+i*10),\n\t\t\tDefaultNodeRegistryEnabled: true,\n\t\t\tExpert: config.ExpertConfig{\n\t\t\t\tFS:                      fs,\n\t\t\t\tTestGossipProbeInterval: 50 * time.Millisecond,\n\t\t\t},\n\t\t\tGossip: config.GossipConfig{\n\t\t\t\tBindAddress:      fmt.Sprintf(\"127.0.0.1:%d\", 25000+i*10+1),\n\t\t\t\tAdvertiseAddress: fmt.Sprintf(\"127.0.0.1:%d\", 25000+i*10+1),\n\t\t\t\tSeed:             []string{\"127.0.0.1:25001\", \"127.0.0.1:25011\"},\n\t\t\t},\n\t\t}\n\t\tnh, err := NewNodeHost(cfg)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to create nh, %v\", err)\n\t\t}\n\t\tdefer nh.Close()\n\t}\n}\n\nfunc TestCustomTransportCanUseNodeHostID(t *testing.T) {\n\tfactory := &chanTransportFactory{}\n\ttestDefaultNodeRegistryEnabled(t, true, factory)\n}\n\nfunc TestCustomTransportCanGoWithoutNodeHostID(t *testing.T) {\n\tfactory := &chanTransportFactory{}\n\ttestDefaultNodeRegistryEnabled(t, false, factory)\n}\n\nfunc testDefaultNodeRegistryEnabled(t *testing.T,\n\taddressByNodeHostID bool, factory config.TransportFactory) {\n\tfs := vfs.GetTestFS()\n\tdatadir1 := fs.PathJoin(singleNodeHostTestDir, \"nh1\")\n\tdatadir2 := fs.PathJoin(singleNodeHostTestDir, \"nh2\")\n\tos.RemoveAll(singleNodeHostTestDir)\n\tdefer os.RemoveAll(singleNodeHostTestDir)\n\taddr1 := nodeHostTestAddr1\n\taddr2 := nodeHostTestAddr2\n\tnhc1 := config.NodeHostConfig{\n\t\tNodeHostDir:                datadir1,\n\t\tRTTMillisecond:             getRTTMillisecond(fs, datadir1),\n\t\tRaftAddress:                addr1,\n\t\tDefaultNodeRegistryEnabled: addressByNodeHostID,\n\t\tExpert: config.ExpertConfig{\n\t\t\tFS:                      fs,\n\t\t\tTestGossipProbeInterval: 50 * time.Millisecond,\n\t\t},\n\t}\n\tif addressByNodeHostID {\n\t\tnhc1.Gossip = config.GossipConfig{\n\t\t\tBindAddress:      \"127.0.0.1:25001\",\n\t\t\tAdvertiseAddress: \"127.0.0.1:25001\",\n\t\t\tSeed:             []string{\"127.0.0.1:25002\"},\n\t\t}\n\t}\n\tnhc2 := config.NodeHostConfig{\n\t\tNodeHostDir:                datadir2,\n\t\tRTTMillisecond:             getRTTMillisecond(fs, datadir2),\n\t\tRaftAddress:                addr2,\n\t\tDefaultNodeRegistryEnabled: addressByNodeHostID,\n\t\tExpert: config.ExpertConfig{\n\t\t\tFS:                      fs,\n\t\t\tTestGossipProbeInterval: 50 * time.Millisecond,\n\t\t},\n\t}\n\tif addressByNodeHostID {\n\t\tnhc2.Gossip = config.GossipConfig{\n\t\t\tBindAddress:      \"127.0.0.1:25002\",\n\t\t\tAdvertiseAddress: \"127.0.0.1:25002\",\n\t\t\tSeed:             []string{\"127.0.0.1:25001\"},\n\t\t}\n\t}\n\tnhid1, err := id.NewUUID(testNodeHostID1)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to parse nhid\")\n\t}\n\tnhc1.NodeHostID = nhid1.String()\n\tnhid2, err := id.NewUUID(testNodeHostID2)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to parse nhid\")\n\t}\n\tnhc2.NodeHostID = nhid2.String()\n\tnhc1.Expert.TransportFactory = factory\n\tnhc2.Expert.TransportFactory = factory\n\tnh1, err := NewNodeHost(nhc1)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create nh, %v\", err)\n\t}\n\tdefer nh1.Close()\n\tnh2, err := NewNodeHost(nhc2)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create nh2, %v\", err)\n\t}\n\tdefer nh2.Close()\n\tpeers := make(map[uint64]string)\n\tif addressByNodeHostID {\n\t\tpeers[1] = testNodeHostID1\n\t\tpeers[2] = testNodeHostID2\n\t} else {\n\t\tpeers[1] = addr1\n\t\tpeers[2] = addr2\n\t}\n\tcreateSM := func(uint64, uint64) sm.IStateMachine {\n\t\treturn &PST{}\n\t}\n\trc := config.Config{\n\t\tShardID:         1,\n\t\tReplicaID:       1,\n\t\tElectionRTT:     10,\n\t\tHeartbeatRTT:    1,\n\t\tSnapshotEntries: 0,\n\t}\n\tif err := nh1.StartReplica(peers, false, createSM, rc); err != nil {\n\t\tt.Fatalf(\"failed to start node %v\", err)\n\t}\n\trc.ReplicaID = 2\n\tif err := nh2.StartReplica(peers, false, createSM, rc); err != nil {\n\t\tt.Fatalf(\"failed to start node %v\", err)\n\t}\n\twaitForLeaderToBeElected(t, nh1, 1)\n\twaitForLeaderToBeElected(t, nh2, 1)\n\tpto := lpto(nh1)\n\tsession := nh1.GetNoOPSession(1)\n\tfor i := 0; i < 1000; i++ {\n\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\tif _, err := nh1.SyncPropose(ctx, session, make([]byte, 0)); err == nil {\n\t\t\tcancel()\n\t\t\treturn\n\t\t}\n\t\tcancel()\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n\tt.Fatalf(\"failed to make proposal\")\n}\n\nfunc TestNodeHostRegistry(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tdatadir1 := fs.PathJoin(singleNodeHostTestDir, \"nh1\")\n\tdatadir2 := fs.PathJoin(singleNodeHostTestDir, \"nh2\")\n\tos.RemoveAll(singleNodeHostTestDir)\n\tdefer os.RemoveAll(singleNodeHostTestDir)\n\taddr1 := nodeHostTestAddr1\n\taddr2 := nodeHostTestAddr2\n\tnhc1 := config.NodeHostConfig{\n\t\tNodeHostDir:                datadir1,\n\t\tRTTMillisecond:             getRTTMillisecond(fs, datadir1),\n\t\tRaftAddress:                addr1,\n\t\tDefaultNodeRegistryEnabled: true,\n\t\tExpert: config.ExpertConfig{\n\t\t\tFS:                      fs,\n\t\t\tTestGossipProbeInterval: 50 * time.Millisecond,\n\t\t},\n\t}\n\tnhc1.Gossip = config.GossipConfig{\n\t\tBindAddress:      \"127.0.0.1:25001\",\n\t\tAdvertiseAddress: \"127.0.0.1:25001\",\n\t\tSeed:             []string{\"127.0.0.1:25002\"},\n\t}\n\tnhc2 := config.NodeHostConfig{\n\t\tNodeHostDir:                datadir2,\n\t\tRTTMillisecond:             getRTTMillisecond(fs, datadir2),\n\t\tRaftAddress:                addr2,\n\t\tDefaultNodeRegistryEnabled: true,\n\t\tExpert: config.ExpertConfig{\n\t\t\tFS:                      fs,\n\t\t\tTestGossipProbeInterval: 50 * time.Millisecond,\n\t\t},\n\t}\n\tnhc2.Gossip = config.GossipConfig{\n\t\tBindAddress:      \"127.0.0.1:25002\",\n\t\tAdvertiseAddress: \"127.0.0.1:25002\",\n\t\tSeed:             []string{\"127.0.0.1:25001\"},\n\t}\n\tnhid1, err := id.NewUUID(testNodeHostID1)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to parse nhid\")\n\t}\n\tnhc1.NodeHostID = nhid1.String()\n\tnhc1.Gossip.Meta = []byte(testNodeHostID1)\n\tnhid2, err := id.NewUUID(testNodeHostID2)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to parse nhid\")\n\t}\n\tnhc2.NodeHostID = nhid2.String()\n\tnhc2.Gossip.Meta = []byte(testNodeHostID2)\n\tnh1, err := NewNodeHost(nhc1)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create nh, %v\", err)\n\t}\n\tdefer nh1.Close()\n\tnh2, err := NewNodeHost(nhc2)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create nh2, %v\", err)\n\t}\n\tdefer nh2.Close()\n\tpeers := make(map[uint64]string)\n\tpeers[1] = testNodeHostID1\n\tcreateSM := func(uint64, uint64) sm.IStateMachine {\n\t\treturn &PST{}\n\t}\n\trc := config.Config{\n\t\tShardID:         1,\n\t\tReplicaID:       1,\n\t\tElectionRTT:     10,\n\t\tHeartbeatRTT:    1,\n\t\tSnapshotEntries: 0,\n\t}\n\tif err := nh1.StartReplica(peers, false, createSM, rc); err != nil {\n\t\tt.Fatalf(\"failed to start node %v\", err)\n\t}\n\trc.ShardID = 2\n\tpeers[1] = testNodeHostID2\n\tif err := nh2.StartReplica(peers, false, createSM, rc); err != nil {\n\t\tt.Fatalf(\"failed to start node %v\", err)\n\t}\n\trc.ShardID = 3\n\tif err := nh2.StartReplica(peers, false, createSM, rc); err != nil {\n\t\tt.Fatalf(\"failed to start node %v\", err)\n\t}\n\twaitForLeaderToBeElected(t, nh1, 1)\n\twaitForLeaderToBeElected(t, nh2, 2)\n\twaitForLeaderToBeElected(t, nh2, 3)\n\tgood := false\n\tfor i := 0; i < 1000; i++ {\n\t\tr1, ok := nh1.GetNodeHostRegistry()\n\t\tassert.True(t, ok)\n\t\tr2, ok := nh2.GetNodeHostRegistry()\n\t\tassert.True(t, ok)\n\t\tif r1.NumOfShards() != 3 || r2.NumOfShards() != 3 {\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t} else {\n\t\t\tgood = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !good {\n\t\tt.Fatalf(\"registry failed to report the expected num of shards\")\n\t}\n\trc.ShardID = 100\n\tif err := nh2.StartReplica(peers, false, createSM, rc); err != nil {\n\t\tt.Fatalf(\"failed to start node %v\", err)\n\t}\n\twaitForLeaderToBeElected(t, nh2, 100)\n\tfor i := 0; i < 1000; i++ {\n\t\tr1, ok := nh1.GetNodeHostRegistry()\n\t\tassert.True(t, ok)\n\t\tr2, ok := nh2.GetNodeHostRegistry()\n\t\tassert.True(t, ok)\n\t\tif r1.NumOfShards() != 4 || r2.NumOfShards() != 4 {\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t} else {\n\t\t\tv1, ok := r1.GetMeta(testNodeHostID1)\n\t\t\tassert.True(t, ok)\n\t\t\tassert.Equal(t, testNodeHostID1, string(v1))\n\t\t\tv2, ok := r1.GetMeta(testNodeHostID2)\n\t\t\tassert.True(t, ok)\n\t\t\tassert.Equal(t, testNodeHostID2, string(v2))\n\t\t\treturn\n\t\t}\n\t}\n\tt.Fatalf(\"failed to report the expected num of shards\")\n}\n\nfunc TestGossipCanHandleDynamicRaftAddress(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tdatadir1 := fs.PathJoin(singleNodeHostTestDir, \"nh1\")\n\tdatadir2 := fs.PathJoin(singleNodeHostTestDir, \"nh2\")\n\tos.RemoveAll(singleNodeHostTestDir)\n\tdefer os.RemoveAll(singleNodeHostTestDir)\n\taddr1 := nodeHostTestAddr1\n\taddr2 := nodeHostTestAddr2\n\tnhc1 := config.NodeHostConfig{\n\t\tNodeHostDir:                datadir1,\n\t\tRTTMillisecond:             getRTTMillisecond(fs, datadir1),\n\t\tRaftAddress:                addr1,\n\t\tDefaultNodeRegistryEnabled: true,\n\t\tExpert: config.ExpertConfig{\n\t\t\tFS:                      fs,\n\t\t\tTestGossipProbeInterval: 50 * time.Millisecond,\n\t\t},\n\t}\n\tnhc2 := config.NodeHostConfig{\n\t\tNodeHostDir:                datadir2,\n\t\tRTTMillisecond:             getRTTMillisecond(fs, datadir2),\n\t\tRaftAddress:                addr2,\n\t\tDefaultNodeRegistryEnabled: true,\n\t\tExpert: config.ExpertConfig{\n\t\t\tFS:                      fs,\n\t\t\tTestGossipProbeInterval: 50 * time.Millisecond,\n\t\t},\n\t}\n\tnhid1, err := id.NewUUID(testNodeHostID1)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to parse nhid\")\n\t}\n\tnhc1.NodeHostID = nhid1.String()\n\tnhid2, err := id.NewUUID(testNodeHostID2)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to parse nhid\")\n\t}\n\tnhc2.NodeHostID = nhid2.String()\n\tnhc1.Gossip = config.GossipConfig{\n\t\tBindAddress:      \"127.0.0.1:25001\",\n\t\tAdvertiseAddress: \"127.0.0.1:25001\",\n\t\tSeed:             []string{\"127.0.0.1:25002\"},\n\t}\n\tnhc2.Gossip = config.GossipConfig{\n\t\tBindAddress:      \"127.0.0.1:25002\",\n\t\tAdvertiseAddress: \"127.0.0.1:25002\",\n\t\tSeed:             []string{\"127.0.0.1:25001\"},\n\t}\n\tnh1, err := NewNodeHost(nhc1)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create nh, %v\", err)\n\t}\n\tdefer nh1.Close()\n\tnh2, err := NewNodeHost(nhc2)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create nh2, %v\", err)\n\t}\n\tnh2NodeHostID := nh2.ID()\n\tpeers := make(map[uint64]string)\n\tpeers[1] = testNodeHostID1\n\tpeers[2] = testNodeHostID2\n\tcreateSM := func(uint64, uint64) sm.IStateMachine {\n\t\treturn &PST{}\n\t}\n\trc := config.Config{\n\t\tShardID:         1,\n\t\tReplicaID:       1,\n\t\tElectionRTT:     3,\n\t\tHeartbeatRTT:    1,\n\t\tSnapshotEntries: 0,\n\t}\n\tif err := nh1.StartReplica(peers, false, createSM, rc); err != nil {\n\t\tt.Fatalf(\"failed to start node %v\", err)\n\t}\n\trc.ReplicaID = 2\n\tif err := nh2.StartReplica(peers, false, createSM, rc); err != nil {\n\t\tt.Fatalf(\"failed to start node %v\", err)\n\t}\n\twaitForLeaderToBeElected(t, nh1, 1)\n\twaitForLeaderToBeElected(t, nh2, 1)\n\tpto := lpto(nh1)\n\tsession := nh1.GetNoOPSession(1)\n\ttestProposal := func() {\n\t\tdone := false\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t_, err := nh1.SyncPropose(ctx, session, make([]byte, 0))\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdone = true\n\t\t\tbreak\n\t\t}\n\t\tif !done {\n\t\t\tt.Fatalf(\"failed to make proposal\")\n\t\t}\n\t}\n\ttestProposal()\n\tnh2.Close()\n\tnhc2.RaftAddress = nodeHostTestAddr3\n\tnh2, err = NewNodeHost(nhc2)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to restart nh2, %v\", err)\n\t}\n\tdefer nh2.Close()\n\tif nh2.ID() != nh2NodeHostID {\n\t\tt.Fatalf(\"NodeHostID changed, got %s, want %s\", nh2.ID(), nh2NodeHostID)\n\t}\n\tif err := nh2.StartReplica(peers, false, createSM, rc); err != nil {\n\t\tt.Fatalf(\"failed to start node %v\", err)\n\t}\n\twaitForLeaderToBeElected(t, nh2, 1)\n\ttestProposal()\n}\n\ntype testRegistry struct {\n\t*registry.Registry\n\n\tmu *sync.Mutex // PROTECTS(nodeAddrs)\n\t// map of nhid -> host:port\n\tnodeAddrs map[string]string\n}\n\nfunc (tr *testRegistry) Resolve(shardID uint64, replicaID uint64) (string, string, error) {\n\tnhid, ck, err := tr.Registry.Resolve(shardID, replicaID)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\ttr.mu.Lock()\n\tdefer tr.mu.Unlock()\n\treturn tr.nodeAddrs[nhid], ck, nil\n}\n\ntype testRegistryFactory struct {\n\tmu sync.Mutex // PROTECTS(nodeAddrs)\n\t// map of nhid -> host:port\n\tnodeAddrs map[string]string\n}\n\nfunc (trf *testRegistryFactory) Set(nhid, addr string) {\n\ttrf.mu.Lock()\n\tdefer trf.mu.Unlock()\n\ttrf.nodeAddrs[nhid] = addr\n}\n\nfunc (trf *testRegistryFactory) Create(nhid string, streamConnections uint64, v config.TargetValidator) (raftio.INodeRegistry, error) {\n\treturn &testRegistry{\n\t\tregistry.NewNodeRegistry(streamConnections, v),\n\t\t&trf.mu,\n\t\ttrf.nodeAddrs,\n\t}, nil\n}\n\nfunc TestExternalNodeRegistryFunction(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tdatadir1 := fs.PathJoin(singleNodeHostTestDir, \"nh1\")\n\tdatadir2 := fs.PathJoin(singleNodeHostTestDir, \"nh2\")\n\tos.RemoveAll(singleNodeHostTestDir)\n\tdefer os.RemoveAll(singleNodeHostTestDir)\n\taddr1 := nodeHostTestAddr1\n\taddr2 := nodeHostTestAddr2\n\tnhc1 := config.NodeHostConfig{\n\t\tNodeHostDir:    datadir1,\n\t\tRTTMillisecond: getRTTMillisecond(fs, datadir1),\n\t\tRaftAddress:    addr1,\n\t\tExpert: config.ExpertConfig{\n\t\t\tFS: fs,\n\t\t},\n\t}\n\tnhc2 := config.NodeHostConfig{\n\t\tNodeHostDir:    datadir2,\n\t\tRTTMillisecond: getRTTMillisecond(fs, datadir2),\n\t\tRaftAddress:    addr2,\n\t\tExpert: config.ExpertConfig{\n\t\t\tFS: fs,\n\t\t},\n\t}\n\tnhid1, err := id.NewUUID(testNodeHostID1)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to parse nhid\")\n\t}\n\tnhc1.NodeHostID = nhid1.String()\n\tnhid2, err := id.NewUUID(testNodeHostID2)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to parse nhid\")\n\t}\n\tnhc2.NodeHostID = nhid2.String()\n\ttestRegistryFactory := &testRegistryFactory{\n\t\tnodeAddrs: map[string]string{\n\t\t\tnhc1.NodeHostID: nodeHostTestAddr1,\n\t\t\tnhc2.NodeHostID: nodeHostTestAddr2,\n\t\t},\n\t}\n\tnhc1.Expert.NodeRegistryFactory = testRegistryFactory\n\tnhc2.Expert.NodeRegistryFactory = testRegistryFactory\n\n\tnh1, err := NewNodeHost(nhc1)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create nh, %v\", err)\n\t}\n\tdefer nh1.Close()\n\tnh2, err := NewNodeHost(nhc2)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create nh2, %v\", err)\n\t}\n\tnh2NodeHostID := nh2.ID()\n\tpeers := make(map[uint64]string)\n\tpeers[1] = testNodeHostID1\n\tpeers[2] = testNodeHostID2\n\tcreateSM := func(uint64, uint64) sm.IStateMachine {\n\t\treturn &PST{}\n\t}\n\trc := config.Config{\n\t\tShardID:         1,\n\t\tReplicaID:       1,\n\t\tElectionRTT:     3,\n\t\tHeartbeatRTT:    1,\n\t\tSnapshotEntries: 0,\n\t}\n\tif err := nh1.StartReplica(peers, false, createSM, rc); err != nil {\n\t\tt.Fatalf(\"failed to start node %v\", err)\n\t}\n\trc.ReplicaID = 2\n\tif err := nh2.StartReplica(peers, false, createSM, rc); err != nil {\n\t\tt.Fatalf(\"failed to start node %v\", err)\n\t}\n\twaitForLeaderToBeElected(t, nh1, 1)\n\twaitForLeaderToBeElected(t, nh2, 1)\n\tpto := lpto(nh1)\n\tsession := nh1.GetNoOPSession(1)\n\ttestProposal := func() {\n\t\tdone := false\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t_, err := nh1.SyncPropose(ctx, session, make([]byte, 0))\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdone = true\n\t\t\tbreak\n\t\t}\n\t\tif !done {\n\t\t\tt.Fatalf(\"failed to make proposal\")\n\t\t}\n\t}\n\ttestProposal()\n\tnh2.Close()\n\tnhc2.RaftAddress = nodeHostTestAddr3\n\ttestRegistryFactory.Set(nh2NodeHostID, nodeHostTestAddr3)\n\tnh2, err = NewNodeHost(nhc2)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to restart nh2, %v\", err)\n\t}\n\tdefer nh2.Close()\n\tif nh2.ID() != nh2NodeHostID {\n\t\tt.Fatalf(\"NodeHostID changed, got %s, want %s\", nh2.ID(), nh2NodeHostID)\n\t}\n\tif err := nh2.StartReplica(peers, false, createSM, rc); err != nil {\n\t\tt.Fatalf(\"failed to start node %v\", err)\n\t}\n\twaitForLeaderToBeElected(t, nh2, 1)\n\ttestProposal()\n}\n\nfunc TestNewNodeHostReturnErrorOnInvalidConfig(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tupdateNodeHostConfig: func(nhc *config.NodeHostConfig) *config.NodeHostConfig {\n\t\t\tnhc.RaftAddress = \"12345\"\n\t\t\tif err := nhc.Validate(); err == nil {\n\t\t\t\tt.Fatalf(\"config is not considered as invalid\")\n\t\t\t}\n\t\t\treturn nhc\n\t\t},\n\t\tnewNodeHostToFail: true,\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestDeploymentIDCanBeSetUsingNodeHostConfig(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tupdateNodeHostConfig: func(nhc *config.NodeHostConfig) *config.NodeHostConfig {\n\t\t\tnhc.DeploymentID = 1000\n\t\t\treturn nhc\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tnhc := nh.NodeHostConfig()\n\t\t\tif did := nhc.GetDeploymentID(); did != 1000 {\n\t\t\t\tt.Errorf(\"unexpected did: %d\", did)\n\t\t\t}\n\t\t},\n\t\tnoElection: true,\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nvar (\n\tsingleNodeHostTestAddr = fmt.Sprintf(\"localhost:%d\", getTestPort())\n\tnodeHostTestAddr1      = fmt.Sprintf(\"localhost:%d\", getTestPort())\n\tnodeHostTestAddr2      = fmt.Sprintf(\"localhost:%d\", getTestPort()+1)\n\tnodeHostTestAddr3      = fmt.Sprintf(\"localhost:%d\", getTestPort()+2)\n\tsingleNodeHostTestDir  = \"single_nodehost_test_dir_safe_to_delete\"\n)\n\ntype PST struct {\n\tmu       sync.Mutex\n\tstopped  bool\n\tsaved    bool\n\trestored bool\n\tslowSave bool\n}\n\nfunc (n *PST) setRestored(v bool) {\n\tn.mu.Lock()\n\tdefer n.mu.Unlock()\n\tn.restored = v\n}\n\nfunc (n *PST) getRestored() bool {\n\tn.mu.Lock()\n\tdefer n.mu.Unlock()\n\treturn n.restored\n}\n\nfunc (n *PST) Close() error { return nil }\n\n// Lookup locally looks up the data.\nfunc (n *PST) Lookup(key interface{}) (interface{}, error) {\n\treturn make([]byte, 1), nil\n}\n\n// Update updates the object.\nfunc (n *PST) Update(e sm.Entry) (sm.Result, error) {\n\treturn sm.Result{Value: uint64(len(e.Cmd))}, nil\n}\n\n// SaveSnapshot saves the state of the object to the provided io.Writer object.\nfunc (n *PST) SaveSnapshot(w io.Writer,\n\tfileCollection sm.ISnapshotFileCollection,\n\tdone <-chan struct{}) error {\n\tn.saved = true\n\tif !n.slowSave {\n\t\t_, err := w.Write([]byte(\"random-data\"))\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\treturn nil\n\t}\n\tfor {\n\t\ttime.Sleep(10 * time.Millisecond)\n\t\tselect {\n\t\tcase <-done:\n\t\t\tn.stopped = true\n\t\t\treturn sm.ErrSnapshotStopped\n\t\tdefault:\n\t\t}\n\t}\n}\n\n// RecoverFromSnapshot recovers the object from the snapshot specified by the\n// io.Reader object.\nfunc (n *PST) RecoverFromSnapshot(r io.Reader,\n\tfiles []sm.SnapshotFile, done <-chan struct{}) error {\n\tn.setRestored(true)\n\tfor {\n\t\ttime.Sleep(10 * time.Millisecond)\n\t\tselect {\n\t\tcase <-done:\n\t\t\tn.stopped = true\n\t\t\treturn sm.ErrSnapshotStopped\n\t\tdefault:\n\t\t}\n\t}\n}\n\n// GetHash returns a uint64 value representing the current state of the object.\nfunc (n *PST) GetHash() (uint64, error) {\n\treturn 0, nil\n}\n\nfunc createConcurrentTestNodeHost(addr string,\n\tdatadir string, snapshotEntry uint64,\n\tconcurrent bool, fs vfs.IFS) (*NodeHost, error) {\n\t// config for raft\n\trc := config.Config{\n\t\tReplicaID:          uint64(1),\n\t\tElectionRTT:        3,\n\t\tHeartbeatRTT:       1,\n\t\tCheckQuorum:        true,\n\t\tSnapshotEntries:    snapshotEntry,\n\t\tCompactionOverhead: 100,\n\t}\n\tpeers := make(map[uint64]string)\n\tpeers[1] = addr\n\tnhc := config.NodeHostConfig{\n\t\tWALDir:         datadir,\n\t\tNodeHostDir:    datadir,\n\t\tRTTMillisecond: getRTTMillisecond(fs, datadir),\n\t\tRaftAddress:    peers[1],\n\t\tExpert:         getTestExpertConfig(fs),\n\t}\n\tnh, err := NewNodeHost(nhc)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar newConcurrentSM func(uint64, uint64) sm.IConcurrentStateMachine\n\tvar newSM func(uint64, uint64) sm.IStateMachine\n\tif snapshotEntry == 0 {\n\t\tnewConcurrentSM = func(uint64, uint64) sm.IConcurrentStateMachine {\n\t\t\treturn &tests.ConcurrentUpdate{}\n\t\t}\n\t\tnewSM = func(uint64, uint64) sm.IStateMachine {\n\t\t\treturn &tests.TestUpdate{}\n\t\t}\n\t} else {\n\t\tnewConcurrentSM = func(uint64, uint64) sm.IConcurrentStateMachine {\n\t\t\treturn &tests.ConcurrentSnapshot{}\n\t\t}\n\t\tnewSM = func(uint64, uint64) sm.IStateMachine {\n\t\t\treturn &tests.TestSnapshot{}\n\t\t}\n\t}\n\trc.ShardID = 1 + nhc.Expert.Engine.ApplyShards\n\tif err := nh.StartConcurrentReplica(peers, false, newConcurrentSM, rc); err != nil {\n\t\treturn nil, err\n\t}\n\trc.ShardID = 1\n\tif err := nh.StartReplica(peers, false, newSM, rc); err != nil {\n\t\treturn nil, err\n\t}\n\treturn nh, nil\n}\n\nfunc singleConcurrentNodeHostTest(t *testing.T,\n\ttf func(t *testing.T, nh *NodeHost),\n\tsnapshotEntry uint64, concurrent bool, fs vfs.IFS) {\n\tdefer func() {\n\t\tif err := fs.RemoveAll(singleNodeHostTestDir); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t}()\n\tfunc() {\n\t\tdefer leaktest.AfterTest(t)()\n\t\tif err := fs.RemoveAll(singleNodeHostTestDir); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t\tnh, err := createConcurrentTestNodeHost(singleNodeHostTestAddr,\n\t\t\tsingleNodeHostTestDir, snapshotEntry, concurrent, fs)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to create nodehost %v\", err)\n\t\t}\n\t\tdefer func() {\n\t\t\tnh.Close()\n\t\t}()\n\t\tnhc := nh.NodeHostConfig()\n\t\twaitForLeaderToBeElected(t, nh, 1)\n\t\twaitForLeaderToBeElected(t, nh, 1+nhc.Expert.Engine.ApplyShards)\n\t\ttf(t, nh)\n\t}()\n\treportLeakedFD(fs, t)\n}\n\nfunc twoFakeDiskNodeHostTest(t *testing.T,\n\ttf func(t *testing.T, nh1 *NodeHost, nh2 *NodeHost), fs vfs.IFS) {\n\tdefer func() {\n\t\tif err := fs.RemoveAll(singleNodeHostTestDir); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t}()\n\tfunc() {\n\t\tdefer leaktest.AfterTest(t)()\n\t\tnh1dir := fs.PathJoin(singleNodeHostTestDir, \"nh1\")\n\t\tnh2dir := fs.PathJoin(singleNodeHostTestDir, \"nh2\")\n\t\tif err := fs.RemoveAll(singleNodeHostTestDir); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t\tnh1, nh2, err := createFakeDiskTwoTestNodeHosts(nodeHostTestAddr1,\n\t\t\tnodeHostTestAddr2, nh1dir, nh2dir, fs)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to create nodehost %v\", err)\n\t\t}\n\t\tdefer func() {\n\t\t\tnh1.Close()\n\t\t\tnh2.Close()\n\t\t}()\n\t\ttf(t, nh1, nh2)\n\t}()\n\treportLeakedFD(fs, t)\n}\n\nfunc createFakeDiskTwoTestNodeHosts(addr1 string, addr2 string,\n\tdatadir1 string, datadir2 string, fs vfs.IFS) (*NodeHost, *NodeHost, error) {\n\tpeers := make(map[uint64]string)\n\tpeers[1] = addr1\n\tnhc1 := config.NodeHostConfig{\n\t\tWALDir:              datadir1,\n\t\tNodeHostDir:         datadir1,\n\t\tRTTMillisecond:      getRTTMillisecond(fs, datadir1),\n\t\tRaftAddress:         addr1,\n\t\tSystemEventListener: &testSysEventListener{},\n\t\tExpert:              getTestExpertConfig(fs),\n\t}\n\tnhc2 := config.NodeHostConfig{\n\t\tWALDir:              datadir2,\n\t\tNodeHostDir:         datadir2,\n\t\tRTTMillisecond:      getRTTMillisecond(fs, datadir2),\n\t\tRaftAddress:         addr2,\n\t\tSystemEventListener: &testSysEventListener{},\n\t\tExpert:              getTestExpertConfig(fs),\n\t}\n\tnh1, err := NewNodeHost(nhc1)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tnh2, err := NewNodeHost(nhc2)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn nh1, nh2, nil\n}\n\nfunc createRateLimitedTwoTestNodeHosts(addr1 string, addr2 string,\n\tdatadir1 string, datadir2 string,\n\tfs vfs.IFS) (*NodeHost, *NodeHost, *tests.NoOP, *tests.NoOP, error) {\n\trc := config.Config{\n\t\tShardID:         1,\n\t\tElectionRTT:     3,\n\t\tHeartbeatRTT:    1,\n\t\tCheckQuorum:     true,\n\t\tMaxInMemLogSize: 1024 * 3,\n\t}\n\tpeers := make(map[uint64]string)\n\tpeers[1] = addr1\n\tpeers[2] = addr2\n\tnhc1 := config.NodeHostConfig{\n\t\tWALDir:         datadir1,\n\t\tNodeHostDir:    datadir1,\n\t\tRTTMillisecond: getRTTMillisecond(fs, datadir1),\n\t\tRaftAddress:    peers[1],\n\t\tExpert:         getTestExpertConfig(fs),\n\t}\n\tnhc2 := config.NodeHostConfig{\n\t\tWALDir:         datadir2,\n\t\tNodeHostDir:    datadir2,\n\t\tRTTMillisecond: getRTTMillisecond(fs, datadir2),\n\t\tRaftAddress:    peers[2],\n\t\tExpert:         getTestExpertConfig(fs),\n\t}\n\tnh1, err := NewNodeHost(nhc1)\n\tif err != nil {\n\t\treturn nil, nil, nil, nil, err\n\t}\n\tnh2, err := NewNodeHost(nhc2)\n\tif err != nil {\n\t\treturn nil, nil, nil, nil, err\n\t}\n\tsm1 := &tests.NoOP{}\n\tsm2 := &tests.NoOP{}\n\tnewRSM1 := func(shardID uint64, replicaID uint64) sm.IStateMachine {\n\t\treturn sm1\n\t}\n\tnewRSM2 := func(shardID uint64, replicaID uint64) sm.IStateMachine {\n\t\treturn sm2\n\t}\n\trc.ReplicaID = 1\n\tif err := nh1.StartReplica(peers, false, newRSM1, rc); err != nil {\n\t\treturn nil, nil, nil, nil, err\n\t}\n\trc.ReplicaID = 2\n\tif err := nh2.StartReplica(peers, false, newRSM2, rc); err != nil {\n\t\treturn nil, nil, nil, nil, err\n\t}\n\tvar leaderNh *NodeHost\n\tvar followerNh *NodeHost\n\n\tfor i := 0; i < 200; i++ {\n\t\tleaderID, _, ready, err := nh1.GetLeaderID(1)\n\t\tif err == nil && ready {\n\t\t\tif leaderID == 1 {\n\t\t\t\tleaderNh = nh1\n\t\t\t\tfollowerNh = nh2\n\t\t\t\tsm2.SetSleepTime(nhc1.RTTMillisecond * 10)\n\t\t\t} else {\n\t\t\t\tleaderNh = nh2\n\t\t\t\tfollowerNh = nh1\n\t\t\t\tsm1.SetSleepTime(nhc1.RTTMillisecond * 10)\n\t\t\t}\n\t\t\treturn leaderNh, followerNh, sm1, sm2, nil\n\t\t}\n\t\t// wait for leader to be elected\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n\treturn nil, nil, nil, nil, errors.New(\"failed to get usable nodehosts\")\n}\n\nfunc rateLimitedTwoNodeHostTest(t *testing.T,\n\ttf func(t *testing.T, leaderNh *NodeHost, followerNh *NodeHost,\n\t\tn1 *tests.NoOP, n2 *tests.NoOP), fs vfs.IFS) {\n\tdefer func() {\n\t\tif err := fs.RemoveAll(singleNodeHostTestDir); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t}()\n\tfunc() {\n\t\tnh1dir := fs.PathJoin(singleNodeHostTestDir, \"nh1\")\n\t\tnh2dir := fs.PathJoin(singleNodeHostTestDir, \"nh2\")\n\t\tdefer leaktest.AfterTest(t)()\n\t\tif err := fs.RemoveAll(singleNodeHostTestDir); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t\tnh1, nh2, n1, n2, err := createRateLimitedTwoTestNodeHosts(nodeHostTestAddr1,\n\t\t\tnodeHostTestAddr2, nh1dir, nh2dir, fs)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to create nodehost2 %v\", err)\n\t\t}\n\t\tdefer func() {\n\t\t\tnh1.Close()\n\t\t\tnh2.Close()\n\t\t}()\n\t\ttf(t, nh1, nh2, n1, n2)\n\t}()\n\treportLeakedFD(fs, t)\n}\n\nfunc waitForLeaderToBeElected(t *testing.T, nh *NodeHost, shardID uint64) {\n\tfor i := 0; i < 200; i++ {\n\t\t_, term, ready, err := nh.GetLeaderID(shardID)\n\t\tif err == nil && ready {\n\t\t\tif term == 0 {\n\t\t\t\tpanic(\"term is 0\")\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n\tt.Fatalf(\"failed to elect leader\")\n}\n\nfunc TestJoinedShardCanBeRestartedOrJoinedAgain(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tcfg := getTestConfig()\n\t\t\tpeers := make(map[uint64]string)\n\t\t\tnewPST := func(uint64, uint64) sm.IStateMachine { return &PST{} }\n\t\t\tif err := nh.StopShard(1); err != nil {\n\t\t\t\tt.Fatalf(\"failed to stop the shard: %v\", err)\n\t\t\t}\n\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\terr := nh.StartReplica(peers, true, newPST, *cfg)\n\t\t\t\tif err == nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err == ErrShardAlreadyExist {\n\t\t\t\t\ttime.Sleep(5 * time.Millisecond)\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\tt.Fatalf(\"failed to join the shard again, %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tjoin:       true,\n\t\tnoElection: true,\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestCompactionCanBeRequested(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\tupdateConfig: func(c *config.Config) *config.Config {\n\t\t\tc.SnapshotEntries = 10\n\t\t\tc.CompactionOverhead = 5\n\t\t\tc.DisableAutoCompactions = true\n\t\t\treturn c\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := lpto(nh)\n\t\t\tsession := nh.GetNoOPSession(1)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tdefer cancel()\n\t\t\t_, err := nh.SyncPropose(ctx, session, []byte(\"test-data\"))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to make proposal, %v\", err)\n\t\t\t}\n\t\t\topt := SnapshotOption{\n\t\t\t\tOverrideCompactionOverhead: true,\n\t\t\t\tCompactionOverhead:         0,\n\t\t\t}\n\t\t\tif _, err := nh.SyncRequestSnapshot(ctx, 1, opt); err != nil {\n\t\t\t\tt.Fatalf(\"failed to request snapshot %v\", err)\n\t\t\t}\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\top, err := nh.RequestCompaction(1, 1)\n\t\t\t\tif err == ErrRejected {\n\t\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"failed to request compaction %v\", err)\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase <-op.ResultC():\n\t\t\t\t\tbreak\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\tt.Fatalf(\"failed to complete the compaction\")\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif _, err = nh.RequestCompaction(1, 1); err != ErrRejected {\n\t\t\t\tt.Fatalf(\"not rejected\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestSnapshotCanBeStopped(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tpst := &PST{slowSave: true}\n\tto := &testOption{\n\t\tupdateConfig: func(c *config.Config) *config.Config {\n\t\t\tc.SnapshotEntries = 10\n\t\t\treturn c\n\t\t},\n\t\tcreateSM: func(shardID uint64, replicaID uint64) sm.IStateMachine {\n\t\t\treturn pst\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tcreateProposalsToTriggerSnapshot(t, nh, 50, true)\n\t\t},\n\t\tat: func(*NodeHost) {\n\t\t\tif !pst.saved || !pst.stopped {\n\t\t\t\tt.Errorf(\"snapshot not stopped\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestRecoverFromSnapshotCanBeStopped(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tpst := &PST{slowSave: false}\n\tto := &testOption{\n\t\tupdateConfig: func(c *config.Config) *config.Config {\n\t\t\tc.SnapshotEntries = 10\n\t\t\treturn c\n\t\t},\n\t\tcreateSM: func(shardID uint64, replicaID uint64) sm.IStateMachine {\n\t\t\treturn pst\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tcreateProposalsToTriggerSnapshot(t, nh, 50, false)\n\t\t},\n\t\trf: func(nh *NodeHost) {\n\t\t\twait := 0\n\t\t\tfor !pst.getRestored() {\n\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t\twait++\n\t\t\t\tif wait > 1000 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tat: func(*NodeHost) {\n\t\t\twait := 0\n\t\t\tfor !pst.stopped {\n\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t\twait++\n\t\t\t\tif wait > 1000 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !pst.getRestored() {\n\t\t\t\tt.Errorf(\"not restored\")\n\t\t\t}\n\t\t\tif !pst.stopped {\n\t\t\t\tt.Errorf(\"not stopped\")\n\t\t\t}\n\t\t},\n\t\trestartNodeHost: true,\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestGetRequestState(t *testing.T) {\n\ttests := []struct {\n\t\tcode RequestResultCode\n\t\terr  error\n\t}{\n\t\t{requestCompleted, nil},\n\t\t{requestRejected, ErrRejected},\n\t\t{requestTimeout, ErrTimeout},\n\t\t{requestTerminated, ErrShardClosed},\n\t\t{requestDropped, ErrShardNotReady},\n\t\t{requestAborted, ErrAborted},\n\t}\n\n\tfor _, tt := range tests {\n\t\trs := &RequestState{\n\t\t\tCompletedC: make(chan RequestResult, 1),\n\t\t}\n\t\tresult := RequestResult{code: tt.code}\n\t\trs.notify(result)\n\t\tif _, err := getRequestState(context.TODO(), rs); !errors.Is(err, tt.err) {\n\t\t\tt.Errorf(\"expect error %v, got %v\", tt.err, err)\n\t\t}\n\t}\n}\n\nfunc TestGetRequestStateTimeoutAndCancel(t *testing.T) {\n\tfunc() {\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Millisecond)\n\t\tdefer cancel()\n\t\ttime.Sleep(2 * time.Millisecond)\n\t\trs := &RequestState{\n\t\t\tCompletedC: make(chan RequestResult, 1),\n\t\t}\n\t\tif _, err := getRequestState(ctx, rs); !errors.Is(err, ErrTimeout) {\n\t\t\tt.Errorf(\"got %v\", err)\n\t\t}\n\t}()\n\n\tfunc() {\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Hour)\n\t\tcancel()\n\t\trs := &RequestState{\n\t\t\tCompletedC: make(chan RequestResult, 1),\n\t\t}\n\t\tif _, err := getRequestState(ctx, rs); !errors.Is(err, ErrCanceled) {\n\t\t\tt.Errorf(\"got %v\", err)\n\t\t}\n\t}()\n}\n\nfunc TestNodeHostIDIsStatic(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tid := \"\"\n\tto := &testOption{\n\t\trestartNodeHost: true,\n\t\tnoElection:      true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tid = nh.ID()\n\t\t},\n\t\trf: func(nh *NodeHost) {\n\t\t\tif nh.ID() != id {\n\t\t\t\tt.Fatalf(\"NodeHost ID value changed\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestNodeHostIDCanBeSet(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tnhid := testNodeHostID1\n\tto := &testOption{\n\t\tupdateNodeHostConfig: func(c *config.NodeHostConfig) *config.NodeHostConfig {\n\t\t\tc.NodeHostID = nhid\n\t\t\treturn c\n\t\t},\n\t\tnoElection: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tnhid, err := id.NewUUID(nhid)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to create NodeHostID\")\n\t\t\t}\n\t\t\tif nh.ID() != nhid.String() {\n\t\t\t\tt.Fatalf(\"failed to set nhid\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestInvalidAddressIsRejected(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := pto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tdefer cancel()\n\t\t\terr := nh.SyncRequestAddReplica(ctx, 1, 100, \"a1\", 0)\n\t\t\tif err != ErrInvalidAddress {\n\t\t\t\tt.Errorf(\"failed to return ErrInvalidAddress, %v\", err)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestInvalidContextDeadlineIsReported(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := lpto(nh)\n\t\t\trctx, rcancel := context.WithTimeout(context.Background(), pto)\n\t\t\trcs, err := nh.SyncGetSession(rctx, 1)\n\t\t\trcancel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to get regular session\")\n\t\t\t}\n\t\t\t// 8 * time.Millisecond is smaller than the smallest possible RTTMillisecond\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), 8*time.Millisecond)\n\t\t\tdefer cancel()\n\t\t\tcs := nh.GetNoOPSession(1)\n\t\t\t_, err = nh.SyncPropose(ctx, cs, make([]byte, 1))\n\t\t\tif err != ErrTimeoutTooSmall {\n\t\t\t\tt.Errorf(\"failed to return ErrTimeoutTooSmall, %v\", err)\n\t\t\t}\n\t\t\t_, err = nh.SyncRead(ctx, 1, nil)\n\t\t\tif err != ErrTimeoutTooSmall {\n\t\t\t\tt.Errorf(\"failed to return ErrTimeoutTooSmall, %v\", err)\n\t\t\t}\n\t\t\t_, err = nh.SyncGetSession(ctx, 1)\n\t\t\tif err != ErrTimeoutTooSmall {\n\t\t\t\tt.Errorf(\"failed to return ErrTimeoutTooSmall, %v\", err)\n\t\t\t}\n\t\t\terr = nh.SyncCloseSession(ctx, rcs)\n\t\t\tif err != ErrTimeoutTooSmall {\n\t\t\t\tt.Errorf(\"failed to return ErrTimeoutTooSmall, %v\", err)\n\t\t\t}\n\t\t\t_, err = nh.SyncRequestSnapshot(ctx, 1, DefaultSnapshotOption)\n\t\t\tif err != ErrTimeoutTooSmall {\n\t\t\t\tt.Errorf(\"failed to return ErrTimeoutTooSmall, %v\", err)\n\t\t\t}\n\t\t\terr = nh.SyncRequestDeleteReplica(ctx, 1, 1, 0)\n\t\t\tif err != ErrTimeoutTooSmall {\n\t\t\t\tt.Errorf(\"failed to return ErrTimeoutTooSmall, %v\", err)\n\t\t\t}\n\t\t\terr = nh.SyncRequestAddReplica(ctx, 1, 100, \"a1.com:12345\", 0)\n\t\t\tif err != ErrTimeoutTooSmall {\n\t\t\t\tt.Errorf(\"failed to return ErrTimeoutTooSmall, %v\", err)\n\t\t\t}\n\t\t\terr = nh.SyncRequestAddNonVoting(ctx, 1, 100, \"a1.com:12345\", 0)\n\t\t\tif err != ErrTimeoutTooSmall {\n\t\t\t\tt.Errorf(\"failed to return ErrTimeoutTooSmall, %v\", err)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestErrShardNotFoundCanBeReturned(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := lpto(nh)\n\t\t\t_, _, _, err := nh.GetLeaderID(1234)\n\t\t\tif err != ErrShardNotFound {\n\t\t\t\tt.Errorf(\"failed to return ErrShardNotFound, %v\", err)\n\t\t\t}\n\t\t\t_, err = nh.StaleRead(1234, nil)\n\t\t\tif err != ErrShardNotFound {\n\t\t\t\tt.Errorf(\"failed to return ErrShardNotFound, %v\", err)\n\t\t\t}\n\t\t\t_, err = nh.RequestSnapshot(1234, DefaultSnapshotOption, pto)\n\t\t\tif err != ErrShardNotFound {\n\t\t\t\tt.Errorf(\"failed to return ErrShardNotFound, %v\", err)\n\t\t\t}\n\t\t\t_, err = nh.RequestDeleteReplica(1234, 10, 0, pto)\n\t\t\tif err != ErrShardNotFound {\n\t\t\t\tt.Errorf(\"failed to return ErrShardNotFound, %v\", err)\n\t\t\t}\n\t\t\t_, err = nh.RequestAddReplica(1234, 10, \"a1\", 0, pto)\n\t\t\tif err != ErrShardNotFound {\n\t\t\t\tt.Errorf(\"failed to return ErrShardNotFound, %v\", err)\n\t\t\t}\n\t\t\t_, err = nh.RequestAddNonVoting(1234, 10, \"a1\", 0, pto)\n\t\t\tif err != ErrShardNotFound {\n\t\t\t\tt.Errorf(\"failed to return ErrShardNotFound, %v\", err)\n\t\t\t}\n\t\t\terr = nh.RequestLeaderTransfer(1234, 10)\n\t\t\tif err != ErrShardNotFound {\n\t\t\t\tt.Errorf(\"failed to return ErrShardNotFound, %v\", err)\n\t\t\t}\n\t\t\t_, err = nh.GetNodeUser(1234)\n\t\t\tif err != ErrShardNotFound {\n\t\t\t\tt.Errorf(\"failed to return ErrShardNotFound, %v\", err)\n\t\t\t}\n\t\t\tcs := nh.GetNoOPSession(1234)\n\t\t\t_, err = nh.propose(cs, make([]byte, 1), pto)\n\t\t\tif err != ErrShardNotFound {\n\t\t\t\tt.Errorf(\"failed to return ErrShardNotFound, %v\", err)\n\t\t\t}\n\t\t\t_, _, err = nh.readIndex(1234, pto)\n\t\t\tif err != ErrShardNotFound {\n\t\t\t\tt.Errorf(\"failed to return ErrShardNotFound, %v\", err)\n\t\t\t}\n\t\t\terr = nh.stopNode(1234, 1, true)\n\t\t\tif err != ErrShardNotFound {\n\t\t\t\tt.Errorf(\"failed to return ErrShardNotFound, %v\", err)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestGetShardMembership(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := pto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tdefer cancel()\n\t\t\t_, err := nh.SyncGetShardMembership(ctx, 1)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to get shard membership\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestRegisterASessionTwiceWillBeReported(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := lpto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tdefer cancel()\n\t\t\tcs, err := nh.SyncGetSession(ctx, 1)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to get client session %v\", err)\n\t\t\t}\n\t\t\tcs.PrepareForRegister()\n\t\t\trs, err := nh.ProposeSession(cs, pto)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to propose client session %v\", err)\n\t\t\t}\n\t\t\tr := <-rs.ResultC()\n\t\t\tif !r.Rejected() {\n\t\t\t\tt.Errorf(\"failed to reject the cs registeration\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestUnregisterNotRegisterClientSessionWillBeReported(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := lpto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tdefer cancel()\n\t\t\tcs, err := nh.SyncGetSession(ctx, 1)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to get client session %v\", err)\n\t\t\t}\n\t\t\terr = nh.SyncCloseSession(ctx, cs)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to unregister the client session %v\", err)\n\t\t\t}\n\t\t\terr = nh.SyncCloseSession(ctx, cs)\n\t\t\tif err != ErrRejected {\n\t\t\t\tt.Errorf(\"failed to reject the request %v\", err)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestSnapshotFilePayloadChecksumIsSaved(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\tupdateConfig: func(c *config.Config) *config.Config {\n\t\t\tc.SnapshotEntries = 10\n\t\t\treturn c\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tcs := nh.GetNoOPSession(1)\n\t\t\tlogdb := nh.mu.logdb\n\t\t\tsnapshotted := false\n\t\t\tvar snapshot pb.Snapshot\n\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\tpto := pto(nh)\n\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t\t_, err := nh.SyncPropose(ctx, cs, []byte(\"test-data\"))\n\t\t\t\tcancel()\n\t\t\t\tif err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tss, err := logdb.GetSnapshot(1, 1)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"failed to list snapshots\")\n\t\t\t\t}\n\t\t\t\tif !pb.IsEmptySnapshot(ss) {\n\t\t\t\t\tsnapshotted = true\n\t\t\t\t\tsnapshot = ss\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !snapshotted {\n\t\t\t\tt.Fatalf(\"snapshot not triggered\")\n\t\t\t}\n\t\t\tcrc, err := rsm.GetV2PayloadChecksum(snapshot.Filepath, fs)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to get payload checksum\")\n\t\t\t}\n\t\t\tif !bytes.Equal(crc, snapshot.Checksum) {\n\t\t\t\tt.Errorf(\"checksum changed\")\n\t\t\t}\n\t\t\tss := pb.Snapshot{}\n\t\t\tif err := fileutil.GetFlagFileContent(fs.PathDir(snapshot.Filepath),\n\t\t\t\t\"snapshot.metadata\", &ss, fs); err != nil {\n\t\t\t\tt.Fatalf(\"failed to get content %v\", err)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(&ss, &snapshot) {\n\t\t\t\tt.Errorf(\"snapshot record changed\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc testZombieSnapshotDirWillBeDeletedDuringAddShard(t *testing.T, dirName string, fs vfs.IFS) {\n\tvar z1 string\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tdid := nh.nhConfig.GetDeploymentID()\n\t\t\tif err := nh.env.CreateSnapshotDir(did, 1, 1); err != nil {\n\t\t\t\tt.Fatalf(\"failed to get snap dir\")\n\t\t\t}\n\t\t\tsnapDir := nh.env.GetSnapshotDir(did, 1, 1)\n\t\t\tz1 = fs.PathJoin(snapDir, dirName)\n\t\t\tif err := fs.MkdirAll(z1, 0755); err != nil {\n\t\t\t\tt.Fatalf(\"failed to create dir %v\", err)\n\t\t\t}\n\t\t},\n\t\trf: func(nh *NodeHost) {\n\t\t\t_, err := fs.Stat(z1)\n\t\t\tif !vfs.IsNotExist(err) {\n\t\t\t\tt.Fatalf(\"failed to delete zombie dir\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestZombieSnapshotDirWillBeDeletedDuringAddShard(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tdefer leaktest.AfterTest(t)()\n\ttestZombieSnapshotDirWillBeDeletedDuringAddShard(t, \"snapshot-AB-01.receiving\", fs)\n\ttestZombieSnapshotDirWillBeDeletedDuringAddShard(t, \"snapshot-AB-10.generating\", fs)\n}\n\nfunc TestNodeHostReadIndex(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := lpto(nh)\n\t\t\trs, err := nh.ReadIndex(1, pto)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to read index %v\", err)\n\t\t\t}\n\t\t\tif rs.node == nil {\n\t\t\t\tt.Fatal(\"rs.node not set\")\n\t\t\t}\n\t\t\tv := <-rs.ResultC()\n\t\t\tif !v.Completed() {\n\t\t\t\tt.Errorf(\"failed to complete read index\")\n\t\t\t}\n\t\t\t_, err = nh.ReadLocalNode(rs, make([]byte, 128))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"read local failed %v\", err)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestNALookupCanReturnErrNotImplemented(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := lpto(nh)\n\t\t\trs, err := nh.ReadIndex(1, pto)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to read index %v\", err)\n\t\t\t}\n\t\t\tv := <-rs.ResultC()\n\t\t\tif !v.Completed() {\n\t\t\t\tt.Errorf(\"failed to complete read index\")\n\t\t\t}\n\t\t\t_, err = nh.NAReadLocalNode(rs, make([]byte, 128))\n\t\t\tif err != sm.ErrNotImplemented {\n\t\t\t\tt.Errorf(\"failed to return sm.ErrNotImplemented, got %v\", err)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestNodeHostSyncIOAPIs(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tcs := nh.GetNoOPSession(1)\n\t\t\tpto := lpto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tdefer cancel()\n\t\t\tv, err := nh.SyncPropose(ctx, cs, make([]byte, 128))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"make proposal failed %v\", err)\n\t\t\t}\n\t\t\tif v.Value != 128 {\n\t\t\t\tt.Errorf(\"unexpected result\")\n\t\t\t}\n\t\t\tdata, err := nh.SyncRead(ctx, 1, make([]byte, 128))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"make linearizable read failed %v\", err)\n\t\t\t}\n\t\t\tif data == nil || len(data.([]byte)) == 0 {\n\t\t\t\tt.Errorf(\"failed to get result\")\n\t\t\t}\n\t\t\tif err := nh.StopShard(1); err != nil {\n\t\t\t\tt.Errorf(\"failed to stop shard 2 %v\", err)\n\t\t\t}\n\t\t\tlistener, ok := nh.events.sys.ul.(*testSysEventListener)\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"failed to get the system event listener\")\n\t\t\t}\n\t\t\twaitNodeInfoEvent(t, listener.getNodeReady, 1)\n\t\t\tni := listener.getNodeReady()[0]\n\t\t\tif ni.ShardID != 1 || ni.ReplicaID != 1 {\n\t\t\t\tt.Fatalf(\"incorrect node ready info\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestEntryCompression(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\tupdateConfig: func(c *config.Config) *config.Config {\n\t\t\tc.EntryCompressionType = config.Snappy\n\t\t\treturn c\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tcs := nh.GetNoOPSession(1)\n\t\t\tpto := pto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tdefer cancel()\n\t\t\t_, err := nh.SyncPropose(ctx, cs, make([]byte, 1024))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"make proposal failed %v\", err)\n\t\t\t}\n\t\t\tlogdb := nh.mu.logdb\n\t\t\tents, _, err := logdb.IterateEntries(nil, 0, 1, 1, 1, 100, math.MaxUint64)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to get entries %v\", err)\n\t\t\t}\n\t\t\thasEncodedEntry := false\n\t\t\tfor _, e := range ents {\n\t\t\t\tif e.Type == pb.EncodedEntry {\n\t\t\t\t\thasEncodedEntry = true\n\t\t\t\t\tpayload, err := rsm.GetPayload(e)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Fatalf(\"failed to get payload %v\", err)\n\t\t\t\t\t}\n\t\t\t\t\tif !bytes.Equal(payload, make([]byte, 1024)) {\n\t\t\t\t\t\tt.Errorf(\"payload changed\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !hasEncodedEntry {\n\t\t\t\tt.Errorf(\"failed to locate any encoded entry\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestOrderedMembershipChange(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\tupdateConfig: func(c *config.Config) *config.Config {\n\t\t\tc.OrderedConfigChange = true\n\t\t\treturn c\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := pto(nh)\n\t\t\t{\n\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), 2*pto)\n\t\t\t\tdefer cancel()\n\t\t\t\tm, err := nh.SyncGetShardMembership(ctx, 1)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"get membership failed, %v\", err)\n\t\t\t\t}\n\t\t\t\tif err := nh.SyncRequestAddReplica(ctx, 1, 2, \"localhost:25000\", m.ConfigChangeID+1); err == nil {\n\t\t\t\t\tt.Fatalf(\"unexpectedly completed\")\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), 2*pto)\n\t\t\t\tdefer cancel()\n\t\t\t\tm, err := nh.SyncGetShardMembership(ctx, 1)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"get membership failed, %v\", err)\n\t\t\t\t}\n\t\t\t\tif err := nh.SyncRequestAddReplica(ctx, 1, 2, \"localhost:25000\", m.ConfigChangeID); err != nil {\n\t\t\t\t\tt.Fatalf(\"failed to add node %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestSyncRequestDeleteReplica(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := lpto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tdefer cancel()\n\t\t\terr := nh.SyncRequestDeleteReplica(ctx, 1, 2, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to delete node %v\", err)\n\t\t\t}\n\t\t\tlistener, ok := nh.events.sys.ul.(*testSysEventListener)\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"failed to get the system event listener\")\n\t\t\t}\n\t\t\twaitNodeInfoEvent(t, listener.getMembershipChanged, 2)\n\t\t\tni := listener.getMembershipChanged()[1]\n\t\t\tif ni.ShardID != 1 || ni.ReplicaID != 1 {\n\t\t\t\tt.Fatalf(\"incorrect membership changed info\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestSyncRequestAddReplica(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := pto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tdefer cancel()\n\t\t\terr := nh.SyncRequestAddReplica(ctx, 1, 2, \"localhost:25000\", 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to add node %v\", err)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestSyncRequestAddNonVoting(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := pto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tdefer cancel()\n\t\t\terr := nh.SyncRequestAddNonVoting(ctx, 1, 2, \"localhost:25000\", 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to add nonVoting %v\", err)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestNodeHostAddReplica(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := pto(nh)\n\t\t\trs, err := nh.RequestAddReplica(1, 2, \"localhost:25000\", 0, pto)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to add node %v\", err)\n\t\t\t}\n\t\t\tv := <-rs.ResultC()\n\t\t\tif !v.Completed() {\n\t\t\t\tt.Errorf(\"failed to complete add node\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestNodeHostGetNodeUser(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tn, err := nh.GetNodeUser(1)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to get NodeUser\")\n\t\t\t}\n\t\t\tif n == nil {\n\t\t\t\tt.Errorf(\"got a nil NodeUser\")\n\t\t\t}\n\t\t\tn, err = nh.GetNodeUser(123)\n\t\t\tif err != ErrShardNotFound {\n\t\t\t\tt.Errorf(\"didn't return expected err\")\n\t\t\t}\n\t\t\tif n != nil {\n\t\t\t\tt.Errorf(\"got unexpected node user\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestNodeHostNodeUserPropose(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := pto(nh)\n\t\t\tn, err := nh.GetNodeUser(1)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to get NodeUser\")\n\t\t\t}\n\t\t\tcs := nh.GetNoOPSession(1)\n\t\t\trs, err := n.Propose(cs, make([]byte, 16), pto)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to make propose %v\", err)\n\t\t\t}\n\t\t\tv := <-rs.ResultC()\n\t\t\tif !v.Completed() {\n\t\t\t\tt.Errorf(\"failed to complete proposal\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestNodeHostNodeUserRead(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := pto(nh)\n\t\t\tn, err := nh.GetNodeUser(1)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to get NodeUser\")\n\t\t\t}\n\t\t\trs, err := n.ReadIndex(pto)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to read index %v\", err)\n\t\t\t}\n\t\t\tv := <-rs.ResultC()\n\t\t\tif !v.Completed() {\n\t\t\t\tt.Errorf(\"failed to complete read index\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestNodeHostAddNonVotingRemoveNode(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := pto(nh)\n\t\t\trs, err := nh.RequestAddNonVoting(1, 2, \"localhost:25000\", 0, pto)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to add node %v\", err)\n\t\t\t}\n\t\t\tv := <-rs.ResultC()\n\t\t\tif !v.Completed() {\n\t\t\t\tt.Errorf(\"failed to complete add node\")\n\t\t\t}\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tdefer cancel()\n\t\t\tmembership, err := nh.SyncGetShardMembership(ctx, 1)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to get shard membership %v\", err)\n\t\t\t}\n\t\t\tif len(membership.Nodes) != 1 || len(membership.Removed) != 0 {\n\t\t\t\tt.Errorf(\"unexpected nodes/removed len\")\n\t\t\t}\n\t\t\tif len(membership.NonVotings) != 1 {\n\t\t\t\tt.Errorf(\"unexpected nodes len\")\n\t\t\t}\n\t\t\t_, ok := membership.NonVotings[2]\n\t\t\tif !ok {\n\t\t\t\tt.Errorf(\"node 2 not added\")\n\t\t\t}\n\t\t\t// remove it\n\t\t\trs, err = nh.RequestDeleteReplica(1, 2, 0, pto)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to remove node %v\", err)\n\t\t\t}\n\t\t\tv = <-rs.ResultC()\n\t\t\tif !v.Completed() {\n\t\t\t\tt.Errorf(\"failed to complete remove node\")\n\t\t\t}\n\t\t\tctx, cancel = context.WithTimeout(context.Background(), pto)\n\t\t\tdefer cancel()\n\t\t\tmembership, err = nh.SyncGetShardMembership(ctx, 1)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to get shard membership %v\", err)\n\t\t\t}\n\t\t\tif len(membership.Nodes) != 1 || len(membership.Removed) != 1 {\n\t\t\t\tt.Errorf(\"unexpected nodes/removed len\")\n\t\t\t}\n\t\t\tif len(membership.NonVotings) != 0 {\n\t\t\t\tt.Errorf(\"unexpected nodes len\")\n\t\t\t}\n\t\t\t_, ok = membership.Removed[2]\n\t\t\tif !ok {\n\t\t\t\tt.Errorf(\"node 2 not removed\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\n// FIXME:\n// Leadership transfer is not actually tested\nfunc TestNodeHostLeadershipTransfer(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tif err := nh.RequestLeaderTransfer(1, 1); err != nil {\n\t\t\t\tt.Errorf(\"leader transfer failed %v\", err)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestNodeHostHasNodeInfo(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tif ok := nh.HasNodeInfo(1, 1); !ok {\n\t\t\t\tt.Errorf(\"node info missing\")\n\t\t\t}\n\t\t\tif ok := nh.HasNodeInfo(1, 2); ok {\n\t\t\t\tt.Errorf(\"unexpected node info\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestOnDiskStateMachineDoesNotSupportClientSession(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tfakeDiskNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Fatalf(\"no panic when proposing session on disk SM\")\n\t\t\t\t}\n\t\t\t}()\n\t\t\tpto := pto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t_, err := nh.SyncGetSession(ctx, 1)\n\t\t\tcancel()\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"managed to get new session\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestStaleReadOnUninitializedNodeReturnError(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tfakeDiskSM := tests.NewFakeDiskSM(0)\n\tatomic.StoreUint32(&fakeDiskSM.SlowOpen, 1)\n\tto := &testOption{\n\t\tcreateOnDiskSM: func(uint64, uint64) sm.IOnDiskStateMachine {\n\t\t\treturn fakeDiskSM\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tn, ok := nh.getShard(1)\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"failed to get the node\")\n\t\t\t}\n\t\t\tif n.initialized() {\n\t\t\t\tt.Fatalf(\"node unexpectedly initialized\")\n\t\t\t}\n\t\t\tif _, err := nh.StaleRead(1, nil); err != ErrShardNotInitialized {\n\t\t\t\tt.Fatalf(\"expected to return ErrShardNotInitialized\")\n\t\t\t}\n\t\t\tatomic.StoreUint32(&fakeDiskSM.SlowOpen, 0)\n\t\t\tfor !n.initialized() {\n\t\t\t\truntime.Gosched()\n\t\t\t}\n\t\t\tv, err := nh.StaleRead(1, nil)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"stale read failed %v\", err)\n\t\t\t}\n\t\t\tif len(v.([]byte)) != 8 {\n\t\t\t\tt.Fatalf(\"unexpected result %v\", v)\n\t\t\t}\n\t\t},\n\t\tnoElection: true,\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestStartReplicaWaitForReadiness(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tfakeDiskSM := tests.NewFakeDiskSM(0)\n\tatomic.StoreUint32(&fakeDiskSM.SlowOpen, 1)\n\tto := &testOption{\n\t\tdefaultTestNode: false,\n\t\tnoElection:      true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tcfg := getTestConfig()\n\t\t\tcfg.WaitReady = true\n\n\t\t\tgo func() {\n\t\t\t\tdefer atomic.StoreUint32(&fakeDiskSM.SlowOpen, 0)\n\t\t\t\tvar n *node\n\t\t\t\tvar ok bool\n\n\t\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\t\tn, ok = nh.getShard(cfg.ShardID)\n\t\t\t\t\tif ok {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t\t\t}\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Errorf(\"failed to get the node\")\n\t\t\t\t}\n\t\t\t\tif n.initialized() {\n\t\t\t\t\tt.Errorf(\"node unexpectedly initialized\")\n\t\t\t\t}\n\t\t\t\tif _, err := nh.StaleRead(1, nil); err != ErrShardNotInitialized {\n\t\t\t\t\tt.Errorf(\"expected to return ErrShardNotInitialized\")\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tinitialMembers := map[uint64]Target{\n\t\t\t\t1: nh.RaftAddress(),\n\t\t\t}\n\n\t\t\terr := nh.StartOnDiskReplica(initialMembers, false, func(shardID uint64, replicaID uint64) sm.IOnDiskStateMachine {\n\t\t\t\treturn fakeDiskSM\n\t\t\t}, *cfg)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to StartOnDiskReplica: %v\", err)\n\t\t\t}\n\n\t\t\tv, err := nh.StaleRead(1, nil)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"stale read failed %v\", err)\n\t\t\t}\n\t\t\tif len(v.([]byte)) != 8 {\n\t\t\t\tt.Fatalf(\"unexpected result %v\", v)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc testOnDiskStateMachineCanTakeDummySnapshot(t *testing.T, compressed bool) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tfakeDiskNode: true,\n\t\tcompressed:   compressed,\n\t\tupdateConfig: func(c *config.Config) *config.Config {\n\t\t\tc.SnapshotEntries = 30\n\t\t\tc.CompactionOverhead = 30\n\t\t\treturn c\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tsession := nh.GetNoOPSession(1)\n\t\t\tlogdb := nh.mu.logdb\n\t\t\tsnapshotted := false\n\t\t\tvar ss pb.Snapshot\n\t\t\tfor i := uint64(2); i < 1000; i++ {\n\t\t\t\tpto := pto(nh)\n\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t\t_, err := nh.SyncPropose(ctx, session, []byte(\"test-data\"))\n\t\t\t\tcancel()\n\t\t\t\tif err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tsnapshot, err := logdb.GetSnapshot(1, 1)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"list snapshot failed %v\", err)\n\t\t\t\t}\n\t\t\t\tif !pb.IsEmptySnapshot(snapshot) {\n\t\t\t\t\tsnapshotted = true\n\t\t\t\t\tss = snapshot\n\t\t\t\t\tif !ss.Dummy {\n\t\t\t\t\t\tt.Fatalf(\"dummy snapshot is not recorded as dummy\")\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t} else if i%100 == 0 {\n\t\t\t\t\t// this is an ugly hack to workaround RocksDB's incorrect fsync\n\t\t\t\t\t// implementation on macos.\n\t\t\t\t\t// fcntl(fd, F_FULLFSYNC) is required for a proper fsync on macos,\n\t\t\t\t\t// sadly rocksdb is not doing that. this means we can make proposals\n\t\t\t\t\t// very fast as they are not actually fsynced on macos but making\n\t\t\t\t\t// snapshots are going to be much much slower as dragonboat properly\n\t\t\t\t\t// fsyncs its snapshot data. we can end up completing all required\n\t\t\t\t\t// proposals even before completing the first ongoing snapshotting\n\t\t\t\t\t// operation.\n\t\t\t\t\ttime.Sleep(200 * time.Millisecond)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !snapshotted {\n\t\t\t\tt.Fatalf(\"failed to snapshot\")\n\t\t\t}\n\t\t\tfi, err := fs.Stat(ss.Filepath)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to get file st %v\", err)\n\t\t\t}\n\t\t\tif fi.Size() != 1060 {\n\t\t\t\tt.Fatalf(\"unexpected dummy snapshot file size %d\", fi.Size())\n\t\t\t}\n\t\t\treader, h, err := rsm.NewSnapshotReader(ss.Filepath, fs)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to read snapshot %v\", err)\n\t\t\t}\n\t\t\t// dummy snapshot is always not compressed\n\t\t\tif h.CompressionType != config.NoCompression {\n\t\t\t\tt.Errorf(\"dummy snapshot compressed\")\n\t\t\t}\n\t\t\tif rsm.SSVersion(h.Version) != rsm.DefaultVersion {\n\t\t\t\tt.Errorf(\"unexpected snapshot version, got %d, want %d\",\n\t\t\t\t\th.Version, rsm.DefaultVersion)\n\t\t\t}\n\t\t\treader.Close()\n\t\t\tshrunk, err := rsm.IsShrunkSnapshotFile(ss.Filepath, fs)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to check shrunk %v\", err)\n\t\t\t}\n\t\t\tif !shrunk {\n\t\t\t\tt.Errorf(\"not a dummy snapshot\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestOnDiskStateMachineCanTakeDummySnapshot(t *testing.T) {\n\ttestOnDiskStateMachineCanTakeDummySnapshot(t, true)\n\ttestOnDiskStateMachineCanTakeDummySnapshot(t, false)\n}\n\nfunc TestOnDiskSMCanStreamSnapshot(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\ttf := func(t *testing.T, nh1 *NodeHost, nh2 *NodeHost) {\n\t\trc := config.Config{\n\t\t\tShardID:                 1,\n\t\t\tReplicaID:               1,\n\t\t\tElectionRTT:             3,\n\t\t\tHeartbeatRTT:            1,\n\t\t\tCheckQuorum:             true,\n\t\t\tSnapshotEntries:         5,\n\t\t\tCompactionOverhead:      2,\n\t\t\tSnapshotCompressionType: config.Snappy,\n\t\t\tEntryCompressionType:    config.Snappy,\n\t\t}\n\t\tsm1 := tests.NewFakeDiskSM(0)\n\t\tsm1.SetAborted()\n\t\tpeers := make(map[uint64]string)\n\t\tpeers[1] = nodeHostTestAddr1\n\t\tnewSM := func(uint64, uint64) sm.IOnDiskStateMachine {\n\t\t\treturn sm1\n\t\t}\n\t\tif err := nh1.StartOnDiskReplica(peers, false, newSM, rc); err != nil {\n\t\t\tt.Fatalf(\"failed to start shard %v\", err)\n\t\t}\n\t\twaitForLeaderToBeElected(t, nh1, 1)\n\t\tlogdb := nh1.mu.logdb\n\t\tsnapshotted := false\n\t\tsession := nh1.GetNoOPSession(1)\n\t\tfor i := uint64(2); i < 1000; i++ {\n\t\t\tpto := pto(nh1)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t_, err := nh1.SyncPropose(ctx, session, []byte(\"test-data\"))\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsnapshot, err := logdb.GetSnapshot(1, 1)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"list snapshot failed %v\", err)\n\t\t\t}\n\t\t\tif !pb.IsEmptySnapshot(snapshot) {\n\t\t\t\tsnapshotted = true\n\t\t\t\tbreak\n\t\t\t} else if i%50 == 0 {\n\t\t\t\t// see comments in testOnDiskStateMachineCanTakeDummySnapshot\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t}\n\t\t}\n\t\tif !snapshotted {\n\t\t\tt.Fatalf(\"failed to take 3 snapshots\")\n\t\t}\n\t\tpto := pto(nh1)\n\t\trs, err := nh1.RequestAddReplica(1, 2, nodeHostTestAddr2, 0, pto)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to add node %v\", err)\n\t\t}\n\t\ts := <-rs.ResultC()\n\t\tif !s.Completed() {\n\t\t\tt.Fatalf(\"failed to complete the add node request\")\n\t\t}\n\t\trc = config.Config{\n\t\t\tShardID:            1,\n\t\t\tReplicaID:          2,\n\t\t\tElectionRTT:        3,\n\t\t\tHeartbeatRTT:       1,\n\t\t\tCheckQuorum:        true,\n\t\t\tSnapshotEntries:    5,\n\t\t\tCompactionOverhead: 2,\n\t\t}\n\t\tsm2 := tests.NewFakeDiskSM(0)\n\t\tsm2.SetAborted()\n\t\tnewSM2 := func(uint64, uint64) sm.IOnDiskStateMachine {\n\t\t\treturn sm2\n\t\t}\n\t\tsm1.ClearAborted()\n\t\tif err := nh2.StartOnDiskReplica(nil, true, newSM2, rc); err != nil {\n\t\t\tt.Fatalf(\"failed to start shard %v\", err)\n\t\t}\n\t\tssIndex := uint64(0)\n\t\tlogdb = nh2.mu.logdb\n\t\twaitForLeaderToBeElected(t, nh2, 1)\n\t\tfor i := uint64(2); i < 1000; i++ {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t_, err := nh2.SyncPropose(ctx, session, []byte(\"test-data\"))\n\t\t\tcancel()\n\t\t\tplog.Infof(\"nh2 proposal result: %v\", err)\n\t\t\tif err != nil {\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tss, err := logdb.GetSnapshot(1, 2)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"list snapshot failed %v\", err)\n\t\t\t}\n\t\t\tif !pb.IsEmptySnapshot(ss) {\n\t\t\t\tif !sm2.Recovered() {\n\t\t\t\t\tt.Fatalf(\"not recovered\")\n\t\t\t\t}\n\t\t\t\tif !sm1.Aborted() {\n\t\t\t\t\tt.Fatalf(\"not aborted\")\n\t\t\t\t}\n\t\t\t\tif ss.OnDiskIndex == 0 {\n\t\t\t\t\tt.Errorf(\"on disk index not recorded in ss\")\n\t\t\t\t}\n\t\t\t\tshrunk, err := rsm.IsShrunkSnapshotFile(ss.Filepath, fs)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"failed to check whether snapshot is shrunk %v\", err)\n\t\t\t\t}\n\t\t\t\tif !shrunk {\n\t\t\t\t\tt.Errorf(\"snapshot %d is not shrunk\", ss.Index)\n\t\t\t\t}\n\t\t\t\tif ssIndex == 0 {\n\t\t\t\t\tssIndex = ss.Index\n\t\t\t\t} else {\n\t\t\t\t\tif ssIndex != ss.Index {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if i%50 == 0 {\n\t\t\t\t// see comments in testOnDiskStateMachineCanTakeDummySnapshot\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t}\n\t\t}\n\t\tif ssIndex == 0 {\n\t\t\tt.Fatalf(\"failed to take 2 snapshots\")\n\t\t}\n\t\tlistener, ok := nh2.events.sys.ul.(*testSysEventListener)\n\t\tif !ok {\n\t\t\tt.Fatalf(\"failed to get the system event listener\")\n\t\t}\n\t\tif len(listener.getSnapshotReceived()) == 0 {\n\t\t\tt.Fatalf(\"snapshot received not notified\")\n\t\t}\n\t\tif len(listener.getSnapshotRecovered()) == 0 {\n\t\t\tt.Fatalf(\"failed to be notified for recovered snapshot\")\n\t\t}\n\t\tif len(listener.getLogCompacted()) == 0 {\n\t\t\tt.Fatalf(\"log compaction not notified\")\n\t\t}\n\t\tlistener, ok = nh1.events.sys.ul.(*testSysEventListener)\n\t\tif !ok {\n\t\t\tt.Fatalf(\"failed to get the system event listener\")\n\t\t}\n\t\tif len(listener.getSendSnapshotStarted()) == 0 {\n\t\t\tt.Fatalf(\"send snapshot started not notified\")\n\t\t}\n\t\tif len(listener.getSendSnapshotCompleted()) == 0 {\n\t\t\tt.Fatalf(\"send snapshot completed not notified\")\n\t\t}\n\t\tif listener.getConnectionEstablished() == 0 {\n\t\t\tt.Fatalf(\"connection established not notified\")\n\t\t}\n\t}\n\ttwoFakeDiskNodeHostTest(t, tf, fs)\n}\n\nfunc TestConcurrentStateMachineLookup(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tdone := uint32(0)\n\ttf := func(t *testing.T, nh *NodeHost) {\n\t\tnhc := nh.NodeHostConfig()\n\t\tshardID := 1 + nhc.Expert.Engine.ApplyShards\n\t\tcount := uint32(0)\n\t\tstopper := syncutil.NewStopper()\n\t\tpto := pto(nh)\n\t\tstopper.RunWorker(func() {\n\t\t\tfor i := 0; i < 10000; i++ {\n\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t\tsession := nh.GetNoOPSession(shardID)\n\t\t\t\t_, err := nh.SyncPropose(ctx, session, []byte(\"test\"))\n\t\t\t\tcancel()\n\t\t\t\tif err == ErrTimeout {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"failed to make proposal %v\", err)\n\t\t\t\t}\n\t\t\t\tif atomic.LoadUint32(&count) > 0 {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tstopper.RunWorker(func() {\n\t\t\tfor i := 0; i < 10000; i++ {\n\t\t\t\tif i%5 == 0 {\n\t\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t\t}\n\t\t\t\trs, err := nh.ReadIndex(shardID, pto)\n\t\t\t\tif err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\ts := <-rs.ResultC()\n\t\t\t\tif !s.Completed() {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tst := random.LockGuardedRand.Uint64()%7 + 1\n\t\t\t\ttime.Sleep(time.Duration(st) * time.Millisecond)\n\t\t\t\tresult, err := nh.ReadLocalNode(rs, []byte(\"test\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tv := binary.LittleEndian.Uint32(result.([]byte))\n\t\t\t\tif v%2 == 1 {\n\t\t\t\t\tatomic.AddUint32(&count, 1)\n\t\t\t\t\tatomic.StoreUint32(&done, 1)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tstopper.Stop()\n\t\tif atomic.LoadUint32(&done) == 0 {\n\t\t\tt.Fatalf(\"failed to have any concurrent read\")\n\t\t}\n\t}\n\tsingleConcurrentNodeHostTest(t, tf, 0, true, fs)\n}\n\nfunc TestConcurrentStateMachineSaveSnapshot(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\ttf := func(t *testing.T, nh *NodeHost) {\n\t\tnhc := nh.NodeHostConfig()\n\t\tshardID := 1 + nhc.Expert.Engine.ApplyShards\n\t\tnhi := nh.GetNodeHostInfo(DefaultNodeHostInfoOption)\n\t\tfor _, ci := range nhi.ShardInfoList {\n\t\t\tif ci.ShardID == shardID {\n\t\t\t\tif ci.StateMachineType != sm.ConcurrentStateMachine {\n\t\t\t\t\tt.Errorf(\"unexpected state machine type\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ci.IsNonVoting {\n\t\t\t\tt.Errorf(\"unexpected IsNonVoting value\")\n\t\t\t}\n\t\t}\n\t\tresult := make(map[uint64]struct{})\n\t\tsession := nh.GetNoOPSession(shardID)\n\t\tpto := pto(nh)\n\t\tfor i := 0; i < 10000; i++ {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tv, err := nh.SyncPropose(ctx, session, []byte(\"test\"))\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to make proposal %v\", err)\n\t\t\t}\n\t\t\tresult[v.Value] = struct{}{}\n\t\t\tif len(result) > 1 {\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttime.Sleep(time.Millisecond)\n\t\t}\n\t\tt.Fatalf(\"failed to make proposal when saving snapshots\")\n\t}\n\tsingleConcurrentNodeHostTest(t, tf, 10, true, fs)\n}\n\nfunc TestErrorCanBeReturnedWhenLookingUpConcurrentStateMachine(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\ttf := func(t *testing.T, nh *NodeHost) {\n\t\tnhc := nh.NodeHostConfig()\n\t\tshardID := 1 + nhc.Expert.Engine.ApplyShards\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tpto := pto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t_, err := nh.SyncRead(ctx, shardID, []byte(\"test\"))\n\t\t\tcancel()\n\t\t\tif err != sm.ErrSnapshotStopped {\n\t\t\t\tt.Fatalf(\"error not returned\")\n\t\t\t}\n\t\t}\n\t}\n\tsingleConcurrentNodeHostTest(t, tf, 10, true, fs)\n}\n\nfunc TestRegularStateMachineDoesNotAllowConucrrentUpdate(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tfailed := uint32(0)\n\ttf := func(t *testing.T, nh *NodeHost) {\n\t\tnhi := nh.GetNodeHostInfo(DefaultNodeHostInfoOption)\n\t\tfor _, ci := range nhi.ShardInfoList {\n\t\t\tif ci.ShardID == 1 {\n\t\t\t\tif ci.StateMachineType != sm.RegularStateMachine {\n\t\t\t\t\tt.Errorf(\"unexpected state machine type\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ci.IsNonVoting {\n\t\t\t\tt.Errorf(\"unexpected IsNonVoting value\")\n\t\t\t}\n\t\t}\n\t\tstopper := syncutil.NewStopper()\n\t\tpto := pto(nh)\n\t\tstopper.RunWorker(func() {\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t\tsession := nh.GetNoOPSession(1)\n\t\t\t\t_, err := nh.SyncPropose(ctx, session, []byte(\"test\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\tplog.Infof(\"failed to make proposal %v\\n\", err)\n\t\t\t\t}\n\t\t\t\tcancel()\n\t\t\t\tif atomic.LoadUint32(&failed) == 1 {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tstopper.RunWorker(func() {\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t\tresult, err := nh.SyncRead(ctx, 1, []byte(\"test\"))\n\t\t\t\tcancel()\n\t\t\t\tif err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tv := binary.LittleEndian.Uint32(result.([]byte))\n\t\t\t\tif v == 1 {\n\t\t\t\t\tatomic.StoreUint32(&failed, 1)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tstopper.Stop()\n\t\tif atomic.LoadUint32(&failed) == 1 {\n\t\t\tt.Fatalf(\"unexpected concurrent update observed\")\n\t\t}\n\t}\n\tsingleConcurrentNodeHostTest(t, tf, 0, false, fs)\n}\n\nfunc TestRegularStateMachineDoesNotAllowConcurrentSaveSnapshot(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\ttf := func(t *testing.T, nh *NodeHost) {\n\t\tresult := make(map[uint64]struct{})\n\t\tsession := nh.GetNoOPSession(1)\n\t\tpto := pto(nh)\n\t\tfor i := 0; i < 50; i++ {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tv, err := nh.SyncPropose(ctx, session, []byte(\"test\"))\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tresult[v.Value] = struct{}{}\n\t\t\tif len(result) > 1 {\n\t\t\t\tt.Fatalf(\"unexpected concurrent save snapshot observed\")\n\t\t\t}\n\t\t}\n\t}\n\tsingleConcurrentNodeHostTest(t, tf, 10, false, fs)\n}\n\nfunc TestLogDBRateLimit(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\tupdateConfig: func(c *config.Config) *config.Config {\n\t\t\tc.MaxInMemLogSize = 1024 * 3\n\t\t\treturn c\n\t\t},\n\t\tupdateNodeHostConfig: func(c *config.NodeHostConfig) *config.NodeHostConfig {\n\t\t\tlogDBConfig := config.GetDefaultLogDBConfig()\n\t\t\tlogDBConfig.KVMaxWriteBufferNumber = 2\n\t\t\tlogDBConfig.KVWriteBufferSize = 1024 * 8\n\t\t\tc.Expert.LogDB = logDBConfig\n\t\t\treturn c\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tif nh.mu.logdb.Name() == \"Tan\" {\n\t\t\t\tt.Skip(\"skipped, using tan logdb\")\n\t\t\t}\n\t\t\tfor i := 0; i < 10240; i++ {\n\t\t\t\tpto := pto(nh)\n\t\t\t\tsession := nh.GetNoOPSession(1)\n\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t\t_, err := nh.SyncPropose(ctx, session, make([]byte, 512))\n\t\t\t\tcancel()\n\t\t\t\tif err == ErrSystemBusy {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.Fatalf(\"failed to return ErrSystemBusy\")\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestTooBigPayloadIsRejectedWhenRateLimited(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tupdateConfig: func(c *config.Config) *config.Config {\n\t\t\tc.MaxInMemLogSize = 1024 * 3\n\t\t\treturn c\n\t\t},\n\t\tcreateSM: func(uint64, uint64) sm.IStateMachine {\n\t\t\treturn &tests.NoOP{MillisecondToSleep: 20}\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tbigPayload := make([]byte, 1024*1024)\n\t\t\tsession := nh.GetNoOPSession(1)\n\t\t\tpto := pto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t_, err := nh.SyncPropose(ctx, session, bigPayload)\n\t\t\tcancel()\n\t\t\tif err != ErrPayloadTooBig {\n\t\t\t\tt.Errorf(\"failed to return ErrPayloadTooBig\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestProposalsCanBeMadeWhenRateLimited(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tupdateConfig: func(c *config.Config) *config.Config {\n\t\t\tc.MaxInMemLogSize = 1024 * 3\n\t\t\treturn c\n\t\t},\n\t\tcreateSM: func(uint64, uint64) sm.IStateMachine {\n\t\t\treturn &tests.NoOP{MillisecondToSleep: 20}\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tsession := nh.GetNoOPSession(1)\n\t\t\tfor i := 0; i < 16; i++ {\n\t\t\t\tpto := pto(nh)\n\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t\t_, err := nh.SyncPropose(ctx, session, make([]byte, 16))\n\t\t\t\tcancel()\n\t\t\t\tif err == ErrTimeout {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"failed to make proposal %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc makeTestProposal(nh *NodeHost, count int) bool {\n\tsession := nh.GetNoOPSession(1)\n\tfor i := 0; i < count; i++ {\n\t\tpto := pto(nh)\n\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t_, err := nh.SyncPropose(ctx, session, make([]byte, 1024))\n\t\tcancel()\n\t\tif err == nil {\n\t\t\treturn true\n\t\t}\n\t\ttime.Sleep(20 * time.Millisecond)\n\t}\n\treturn false\n}\n\nfunc TestRateLimitCanBeTriggered(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tlimited := uint32(0)\n\tstopper := syncutil.NewStopper()\n\tto := &testOption{\n\t\tupdateConfig: func(c *config.Config) *config.Config {\n\t\t\tc.MaxInMemLogSize = 1024 * 3\n\t\t\treturn c\n\t\t},\n\t\tcreateSM: func(uint64, uint64) sm.IStateMachine {\n\t\t\treturn &tests.NoOP{MillisecondToSleep: 20}\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := pto(nh)\n\t\t\tsession := nh.GetNoOPSession(1)\n\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\tstopper.RunWorker(func() {\n\t\t\t\t\tfor j := 0; j < 16; j++ {\n\t\t\t\t\t\tif atomic.LoadUint32(&limited) == 1 {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t\t\t\t_, err := nh.SyncPropose(ctx, session, make([]byte, 1024))\n\t\t\t\t\t\tcancel()\n\t\t\t\t\t\tif err == ErrSystemBusy {\n\t\t\t\t\t\t\tatomic.StoreUint32(&limited, 1)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t\tstopper.Stop()\n\t\t\tif atomic.LoadUint32(&limited) != 1 {\n\t\t\t\tt.Fatalf(\"failed to observe ErrSystemBusy\")\n\t\t\t}\n\t\t\tif makeTestProposal(nh, 10000) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tt.Fatalf(\"failed to make proposal again\")\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestRateLimitCanUseFollowerFeedback(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\ttf := func(t *testing.T, nh1 *NodeHost, nh2 *NodeHost,\n\t\tn1 *tests.NoOP, n2 *tests.NoOP) {\n\t\tsession := nh1.GetNoOPSession(1)\n\t\tlimited := false\n\t\tfor i := 0; i < 2000; i++ {\n\t\t\tpto := pto(nh1)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t_, err := nh1.SyncPropose(ctx, session, make([]byte, 1024))\n\t\t\tcancel()\n\t\t\tif err == ErrShardNotReady {\n\t\t\t\ttime.Sleep(20 * time.Millisecond)\n\t\t\t} else if err == ErrSystemBusy {\n\t\t\t\tlimited = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !limited {\n\t\t\tt.Fatalf(\"failed to observe rate limited\")\n\t\t}\n\t\tn1.SetSleepTime(0)\n\t\tn2.SetSleepTime(0)\n\t\tif makeTestProposal(nh1, 2000) {\n\t\t\tplog.Infof(\"rate limit lifted, all good\")\n\t\t\treturn\n\t\t}\n\t\tt.Fatalf(\"failed to make proposal again\")\n\t}\n\trateLimitedTwoNodeHostTest(t, tf, fs)\n}\n\nfunc TestUpdateResultIsReturnedToCaller(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tupdateConfig: func(c *config.Config) *config.Config {\n\t\t\tc.MaxInMemLogSize = 1024 * 3\n\t\t\treturn c\n\t\t},\n\t\tcreateSM: func(uint64, uint64) sm.IStateMachine {\n\t\t\treturn &tests.NoOP{MillisecondToSleep: 20}\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tsession := nh.GetNoOPSession(1)\n\t\t\tpto := pto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tcmd := make([]byte, 1518)\n\t\t\trand.Read(cmd)\n\t\t\tresult, err := nh.SyncPropose(ctx, session, cmd)\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to make proposal %v\", err)\n\t\t\t}\n\t\t\tif result.Value != uint64(1518) {\n\t\t\t\tt.Errorf(\"unexpected result value\")\n\t\t\t}\n\t\t\tif !bytes.Equal(result.Data, cmd) {\n\t\t\t\tt.Errorf(\"unexpected result data\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestRaftLogQuery(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\tmakeTestProposal(nh, 10)\n\t\t\t}\n\t\t\t_, err := nh.QueryRaftLog(1, 2, 1, math.MaxUint64)\n\t\t\tassert.Equal(t, ErrInvalidRange, err)\n\n\t\t\trs, err := nh.QueryRaftLog(1, 1, 11, math.MaxUint64)\n\t\t\tassert.NoError(t, err)\n\t\t\tticker := time.NewTicker(2 * time.Second)\n\t\t\tdefer ticker.Stop()\n\t\t\tselect {\n\t\t\tcase v := <-rs.CompletedC:\n\t\t\t\tassert.True(t, v.Completed())\n\t\t\t\tentries, logRange := v.RaftLogs()\n\t\t\t\tassert.Equal(t, 10, len(entries))\n\t\t\t\tassert.Equal(t, LogRange{FirstIndex: 1, LastIndex: 13}, logRange)\n\t\t\tcase <-ticker.C:\n\t\t\t\tt.Fatalf(\"no results\")\n\t\t\t}\n\t\t\trs.Release()\n\n\t\t\t// this should be fine\n\t\t\trs, err = nh.QueryRaftLog(1, 1, 1000, math.MaxUint64)\n\t\t\tassert.NoError(t, err)\n\t\t\tselect {\n\t\t\tcase v := <-rs.CompletedC:\n\t\t\t\tassert.True(t, v.Completed())\n\t\t\t\tentries, logRange := v.RaftLogs()\n\t\t\t\tassert.Equal(t, 12, len(entries))\n\t\t\t\tassert.Equal(t, LogRange{FirstIndex: 1, LastIndex: 13}, logRange)\n\t\t\tcase <-ticker.C:\n\t\t\t\tt.Fatalf(\"no results\")\n\t\t\t}\n\t\t\trs.Release()\n\n\t\t\t// OutOfRange expected\n\t\t\trs, err = nh.QueryRaftLog(1, 13, 1000, math.MaxUint64)\n\t\t\tassert.NoError(t, err)\n\t\t\tselect {\n\t\t\tcase v := <-rs.CompletedC:\n\t\t\t\tassert.True(t, v.RequestOutOfRange())\n\t\t\t\tentries, logRange := v.RaftLogs()\n\t\t\t\tassert.Equal(t, 0, len(entries))\n\t\t\t\tassert.Equal(t, LogRange{FirstIndex: 1, LastIndex: 13}, logRange)\n\t\t\tcase <-ticker.C:\n\t\t\t\tt.Fatalf(\"no results\")\n\t\t\t}\n\t\t\trs.Release()\n\n\t\t\t// generate a snapshot, a compaction will be requested in the background\n\t\t\t// then query compacted log will fail.\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\t\tdefer cancel()\n\t\t\topts := SnapshotOption{\n\t\t\t\tCompactionIndex:            10,\n\t\t\t\tOverrideCompactionOverhead: true,\n\t\t\t}\n\t\t\t_, err = nh.SyncRequestSnapshot(ctx, 1, opts)\n\t\t\tassert.NoError(t, err)\n\t\t\tdone := false\n\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\tfunc() {\n\t\t\t\t\trs, err := nh.QueryRaftLog(1, 1, 11, math.MaxUint64)\n\t\t\t\t\tassert.NoError(t, err)\n\t\t\t\t\tticker := time.NewTicker(2 * time.Second)\n\t\t\t\t\tdefer ticker.Stop()\n\t\t\t\t\tselect {\n\t\t\t\t\tcase v := <-rs.CompletedC:\n\t\t\t\t\t\tif v.Completed() {\n\t\t\t\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tassert.True(t, v.RequestOutOfRange())\n\t\t\t\t\t\tentries, logRange := v.RaftLogs()\n\t\t\t\t\t\tassert.Equal(t, 0, len(entries))\n\t\t\t\t\t\tassert.Equal(t, LogRange{FirstIndex: 11, LastIndex: 13}, logRange)\n\t\t\t\t\t\tdone = true\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase <-ticker.C:\n\t\t\t\t\t\tt.Fatalf(\"no results\")\n\t\t\t\t\t}\n\t\t\t\t\trs.Release()\n\t\t\t\t}()\n\t\t\t\tif done {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif i == 999 {\n\t\t\t\t\tt.Fatalf(\"failed to observe RequestOutOfRange error\")\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestIsNonVotingIsReturnedWhenNodeIsNonVoting(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\ttf := func(t *testing.T, nh1 *NodeHost, nh2 *NodeHost) {\n\t\trc := config.Config{\n\t\t\tShardID:                 1,\n\t\t\tReplicaID:               1,\n\t\t\tElectionRTT:             3,\n\t\t\tHeartbeatRTT:            1,\n\t\t\tCheckQuorum:             true,\n\t\t\tSnapshotEntries:         5,\n\t\t\tCompactionOverhead:      2,\n\t\t\tSnapshotCompressionType: config.NoCompression,\n\t\t}\n\t\tnewSM := func(uint64, uint64) sm.IOnDiskStateMachine {\n\t\t\treturn tests.NewFakeDiskSM(0)\n\t\t}\n\t\tpeers := make(map[uint64]string)\n\t\tpeers[1] = nodeHostTestAddr1\n\t\tif err := nh1.StartOnDiskReplica(peers, false, newSM, rc); err != nil {\n\t\t\tt.Errorf(\"failed to start nonVoting %v\", err)\n\t\t}\n\t\twaitForLeaderToBeElected(t, nh1, 1)\n\t\trc = config.Config{\n\t\t\tShardID:            1,\n\t\t\tReplicaID:          2,\n\t\t\tElectionRTT:        3,\n\t\t\tHeartbeatRTT:       1,\n\t\t\tIsNonVoting:        true,\n\t\t\tCheckQuorum:        true,\n\t\t\tSnapshotEntries:    5,\n\t\t\tCompactionOverhead: 2,\n\t\t}\n\t\tnewSM2 := func(uint64, uint64) sm.IOnDiskStateMachine {\n\t\t\treturn tests.NewFakeDiskSM(0)\n\t\t}\n\t\tpto := pto(nh1)\n\t\trs, err := nh1.RequestAddNonVoting(1, 2, nodeHostTestAddr2, 0, pto)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to add nonVoting %v\", err)\n\t\t}\n\t\t<-rs.ResultC()\n\t\tif err := nh2.StartOnDiskReplica(nil, true, newSM2, rc); err != nil {\n\t\t\tt.Errorf(\"failed to start nonVoting %v\", err)\n\t\t}\n\t\tfor i := 0; i < 10000; i++ {\n\t\t\tnhi := nh2.GetNodeHostInfo(DefaultNodeHostInfoOption)\n\t\t\tfor _, ci := range nhi.ShardInfoList {\n\t\t\t\tif ci.Pending {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif ci.IsNonVoting && ci.ReplicaID == 2 {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t}\n\t\tt.Errorf(\"failed to get is nonVoting flag\")\n\t}\n\ttwoFakeDiskNodeHostTest(t, tf, fs)\n}\n\nfunc TestSnapshotIndexWillPanicOnRegularRequestResult(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tcs := nh.GetNoOPSession(1)\n\t\t\tpto := pto(nh)\n\t\t\trs, err := nh.Propose(cs, make([]byte, 1), pto)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"propose failed %v\", err)\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Fatalf(\"no panic\")\n\t\t\t\t}\n\t\t\t}()\n\t\t\tv := <-rs.ResultC()\n\t\t\tplog.Infof(\"%d\", v.SnapshotIndex())\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestSyncRequestSnapshot(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tsession := nh.GetNoOPSession(1)\n\t\t\tpto := lpto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tcmd := make([]byte, 1518)\n\t\t\t_, err := nh.SyncPropose(ctx, session, cmd)\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to make proposal %v\", err)\n\t\t\t}\n\t\t\tctx, cancel = context.WithTimeout(context.Background(), pto)\n\t\t\tidx, err := nh.SyncRequestSnapshot(ctx, 1, DefaultSnapshotOption)\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif idx == 0 {\n\t\t\t\tt.Errorf(\"unexpected index %d\", idx)\n\t\t\t}\n\t\t\tlistener, ok := nh.events.sys.ul.(*testSysEventListener)\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"failed to get the system event listener\")\n\t\t\t}\n\t\t\twaitSnapshotInfoEvent(t, listener.getSnapshotCreated, 1)\n\t\t\tsi := listener.getSnapshotCreated()[0]\n\t\t\tif si.ShardID != 1 || si.ReplicaID != 1 {\n\t\t\t\tt.Fatalf(\"incorrect created snapshot info\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestSnapshotCanBeExportedAfterSnapshotting(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tsession := nh.GetNoOPSession(1)\n\t\t\tpto := lpto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tcmd := make([]byte, 1518)\n\t\t\t_, err := nh.SyncPropose(ctx, session, cmd)\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to make proposal %v\", err)\n\t\t\t}\n\t\t\tctx, cancel = context.WithTimeout(context.Background(), pto)\n\t\t\tidx, err := nh.SyncRequestSnapshot(ctx, 1, DefaultSnapshotOption)\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif idx == 0 {\n\t\t\t\tt.Errorf(\"unexpected index %d\", idx)\n\t\t\t}\n\t\t\tsspath := \"exported_snapshot_safe_to_delete\"\n\t\t\tif err := fs.RemoveAll(sspath); err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif err := fs.MkdirAll(sspath, 0755); err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\tif err := fs.RemoveAll(sspath); err != nil {\n\t\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t\t}\n\t\t\t}()\n\t\t\topt := SnapshotOption{\n\t\t\t\tExported:   true,\n\t\t\t\tExportPath: sspath,\n\t\t\t}\n\t\t\tctx, cancel = context.WithTimeout(context.Background(), pto)\n\t\t\texportIdx, err := nh.SyncRequestSnapshot(ctx, 1, opt)\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif exportIdx != idx {\n\t\t\t\tt.Errorf(\"unexpected index %d, want %d\", exportIdx, idx)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestCanOverrideSnapshotOverhead(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tsession := nh.GetNoOPSession(1)\n\t\t\tcmd := make([]byte, 1)\n\t\t\tpto := pto(nh)\n\t\t\tfor i := 0; i < 16; i++ {\n\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t\t_, err := nh.SyncPropose(ctx, session, cmd)\n\t\t\t\tcancel()\n\t\t\t\tif err != nil {\n\t\t\t\t\t// see comments in testOnDiskStateMachineCanTakeDummySnapshot\n\t\t\t\t\tif err == ErrTimeout {\n\t\t\t\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tt.Fatalf(\"failed to make proposal %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\topt := SnapshotOption{\n\t\t\t\tOverrideCompactionOverhead: true,\n\t\t\t\tCompactionOverhead:         0,\n\t\t\t}\n\t\t\tlpto := lpto(nh)\n\t\t\tsr, err := nh.RequestSnapshot(1, opt, lpto)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to request snapshot\")\n\t\t\t}\n\t\t\tv := <-sr.ResultC()\n\t\t\tif !v.Completed() {\n\t\t\t\tt.Errorf(\"failed to complete the requested snapshot\")\n\t\t\t}\n\t\t\tif v.SnapshotIndex() < 16 {\n\t\t\t\tt.Fatalf(\"unexpected snapshot index %d\", v.SnapshotIndex())\n\t\t\t}\n\t\t\tlogdb := nh.mu.logdb\n\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\tif i == 999 {\n\t\t\t\t\tt.Fatalf(\"failed to compact the entries\")\n\t\t\t\t}\n\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t\top, err := nh.RequestCompaction(1, 1)\n\t\t\t\tif err == nil {\n\t\t\t\t\t<-op.ResultC()\n\t\t\t\t}\n\t\t\t\tents, _, err := logdb.IterateEntries(nil, 0, 1, 1, 12, 14, math.MaxUint64)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"failed to iterate entries, %v\", err)\n\t\t\t\t}\n\t\t\t\tif len(ents) != 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestSnapshotCanBeRequested(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := lpto(nh)\n\t\t\tsession := nh.GetNoOPSession(1)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tcmd := make([]byte, 1518)\n\t\t\t_, err := nh.SyncPropose(ctx, session, cmd)\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to make proposal %v\", err)\n\t\t\t}\n\t\t\tsr, err := nh.RequestSnapshot(1, SnapshotOption{}, pto)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to request snapshot\")\n\t\t\t}\n\t\t\tvar index uint64\n\t\t\tv := <-sr.ResultC()\n\t\t\tif !v.Completed() {\n\t\t\t\tt.Errorf(\"failed to complete the requested snapshot\")\n\t\t\t}\n\t\t\tindex = v.SnapshotIndex()\n\t\t\tsr, err = nh.RequestSnapshot(1, SnapshotOption{}, pto)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to request snapshot\")\n\t\t\t}\n\t\t\tv = <-sr.ResultC()\n\t\t\tif !v.Rejected() {\n\t\t\t\tt.Errorf(\"failed to complete the requested snapshot\")\n\t\t\t}\n\t\t\tlogdb := nh.mu.logdb\n\t\t\tsnapshot, err := logdb.GetSnapshot(1, 1)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif pb.IsEmptySnapshot(snapshot) {\n\t\t\t\tt.Fatalf(\"failed to save snapshots\")\n\t\t\t}\n\t\t\tif snapshot.Index != index {\n\t\t\t\tt.Errorf(\"unexpected index value\")\n\t\t\t}\n\t\t\treader, header, err := rsm.NewSnapshotReader(snapshot.Filepath, fs)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to new snapshot reader %v\", err)\n\t\t\t}\n\t\t\tdefer reader.Close()\n\t\t\tif rsm.SSVersion(header.Version) != rsm.V2 {\n\t\t\t\tt.Errorf(\"unexpected snapshot version\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestClientCanBeNotifiedOnCommittedConfigChange(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\tupdateNodeHostConfig: func(c *config.NodeHostConfig) *config.NodeHostConfig {\n\t\t\tc.NotifyCommit = true\n\t\t\treturn c\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := pto(nh)\n\t\t\trs, err := nh.RequestAddReplica(1, 2, \"localhost:3456\", 0, pto)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to request add node\")\n\t\t\t}\n\t\t\tif rs.committedC == nil {\n\t\t\t\tt.Fatalf(\"committedC not set\")\n\t\t\t}\n\t\t\tcn := <-rs.ResultC()\n\t\t\tif !cn.Committed() {\n\t\t\t\tt.Fatalf(\"failed to get committed notification\")\n\t\t\t}\n\t\t\tcn = <-rs.ResultC()\n\t\t\tif !cn.Completed() {\n\t\t\t\tt.Fatalf(\"failed to get completed notification\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestClientCanBeNotifiedOnCommittedProposals(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\tupdateNodeHostConfig: func(c *config.NodeHostConfig) *config.NodeHostConfig {\n\t\t\tc.NotifyCommit = true\n\t\t\treturn c\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := pto(nh)\n\t\t\tcmd := make([]byte, 128)\n\t\t\tsession := nh.GetNoOPSession(1)\n\t\t\trs, err := nh.Propose(session, cmd, pto)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to make proposal %v\", err)\n\t\t\t}\n\t\t\tif rs.committedC == nil {\n\t\t\t\tt.Fatalf(\"committedC not set\")\n\t\t\t}\n\t\t\tcn := <-rs.ResultC()\n\t\t\tif !cn.Committed() {\n\t\t\t\tt.Fatalf(\"failed to get committed notification\")\n\t\t\t}\n\t\t\tcn = <-rs.ResultC()\n\t\t\tif !cn.Completed() {\n\t\t\t\tt.Fatalf(\"failed to get completed notification\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestRequestSnapshotTimeoutWillBeReported(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tpst := &PST{slowSave: true}\n\tto := &testOption{\n\t\tcreateSM: func(uint64, uint64) sm.IStateMachine {\n\t\t\treturn pst\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := pto(nh)\n\t\t\tsr, err := nh.RequestSnapshot(1, SnapshotOption{}, pto)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to request snapshot\")\n\t\t\t}\n\t\t\tv := <-sr.ResultC()\n\t\t\tif !v.Timeout() {\n\t\t\t\tt.Errorf(\"failed to report timeout\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestSyncRemoveData(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tif err := nh.StopShard(1); err != nil {\n\t\t\t\tt.Fatalf(\"failed to remove shard %v\", err)\n\t\t\t}\n\t\t\tpto := lpto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tdefer cancel()\n\t\t\tif err := nh.SyncRemoveData(ctx, 1, 1); err != nil {\n\t\t\t\tt.Fatalf(\"sync remove data failed: %v\", err)\n\t\t\t}\n\t\t\tlistener, ok := nh.events.sys.ul.(*testSysEventListener)\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"failed to get the system event listener\")\n\t\t\t}\n\t\t\twaitNodeInfoEvent(t, listener.getNodeUnloaded, 1)\n\t\t\tni := listener.getNodeUnloaded()[0]\n\t\t\tif ni.ShardID != 1 || ni.ReplicaID != 1 {\n\t\t\t\tt.Fatalf(\"incorrect node unloaded info\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestRemoveNodeDataWillFailWhenNodeIsStillRunning(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tif err := nh.RemoveData(1, 1); err != ErrShardNotStopped {\n\t\t\t\tt.Errorf(\"remove data didn't fail\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestRestartingAnNodeWithRemovedDataWillBeRejected(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tif err := nh.StopShard(1); err != nil {\n\t\t\t\tt.Fatalf(\"failed to remove shard %v\", err)\n\t\t\t}\n\t\t\tfor {\n\t\t\t\tif err := nh.RemoveData(1, 1); err != nil {\n\t\t\t\t\tif err == ErrShardNotStopped {\n\t\t\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.Errorf(\"remove data failed %v\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\trc := getTestConfig()\n\t\t\tpeers := make(map[uint64]string)\n\t\t\tpeers[1] = nh.RaftAddress()\n\t\t\tnewPST := func(shardID uint64, replicaID uint64) sm.IStateMachine {\n\t\t\t\treturn &PST{}\n\t\t\t}\n\t\t\tif err := nh.StartReplica(peers, false, newPST, *rc); err != ErrReplicaRemoved {\n\t\t\t\tt.Errorf(\"start shard failed %v\", err)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestRemoveNodeDataRemovesAllNodeData(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tsession := nh.GetNoOPSession(1)\n\t\t\tpto := lpto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tcmd := make([]byte, 1518)\n\t\t\t_, err := nh.SyncPropose(ctx, session, cmd)\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to make proposal %v\", err)\n\t\t\t}\n\t\t\tsr, err := nh.RequestSnapshot(1, SnapshotOption{}, pto)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to request snapshot\")\n\t\t\t}\n\t\t\tv := <-sr.ResultC()\n\t\t\tif !v.Completed() {\n\t\t\t\tt.Errorf(\"failed to complete the requested snapshot\")\n\t\t\t}\n\t\t\tif err := nh.StopShard(1); err != nil {\n\t\t\t\tt.Fatalf(\"failed to stop shard %v\", err)\n\t\t\t}\n\t\t\tlogdb := nh.mu.logdb\n\t\t\tsnapshot, err := logdb.GetSnapshot(1, 1)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif pb.IsEmptySnapshot(snapshot) {\n\t\t\t\tt.Fatalf(\"failed to save snapshots\")\n\t\t\t}\n\t\t\tsnapshotDir := nh.env.GetSnapshotDir(nh.nhConfig.GetDeploymentID(), 1, 1)\n\t\t\texist, err := fileutil.Exist(snapshotDir, fs)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif !exist {\n\t\t\t\tt.Fatalf(\"snapshot dir %s does not exist\", snapshotDir)\n\t\t\t}\n\t\t\tfiles, err := fs.List(snapshotDir)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to read dir %v\", err)\n\t\t\t}\n\t\t\tsscount := 0\n\t\t\tfor _, fn := range files {\n\t\t\t\tfi, err := fs.Stat(fs.PathJoin(snapshotDir, fn))\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"failed to get stat for %s\", fn)\n\t\t\t\t}\n\t\t\t\tif !fi.IsDir() {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif server.SnapshotDirNameRe.Match([]byte(fi.Name())) {\n\t\t\t\t\tsscount++\n\t\t\t\t}\n\t\t\t}\n\t\t\tif sscount == 0 {\n\t\t\t\tt.Fatalf(\"no snapshot dir found\")\n\t\t\t}\n\t\t\tremoved := false\n\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\terr := nh.RemoveData(1, 1)\n\t\t\t\tif err == ErrShardNotStopped {\n\t\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"failed to remove data %v\", err)\n\t\t\t\t}\n\t\t\t\tif err == nil {\n\t\t\t\t\tremoved = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !removed {\n\t\t\t\tt.Fatalf(\"failed to remove node data\")\n\t\t\t}\n\t\t\tmarked, err := fileutil.IsDirMarkedAsDeleted(snapshotDir, fs)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif !marked {\n\t\t\t\tt.Fatalf(\"snapshot dir %s still exist\", snapshotDir)\n\t\t\t}\n\t\t\tfiles, err = fs.List(snapshotDir)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to read dir %v\", err)\n\t\t\t}\n\t\t\tfor _, fn := range files {\n\t\t\t\tfi, err := fs.Stat(fs.PathJoin(snapshotDir, fn))\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"failed to get stat for %s\", fn)\n\t\t\t\t}\n\t\t\t\tif !fi.IsDir() {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif server.SnapshotDirNameRe.Match([]byte(fi.Name())) {\n\t\t\t\t\tt.Fatalf(\"failed to delete the snapshot dir %s\", fi.Name())\n\t\t\t\t}\n\t\t\t}\n\t\t\tbs, err := logdb.GetBootstrapInfo(1, 1)\n\t\t\tif !errors.Is(err, raftio.ErrNoBootstrapInfo) {\n\t\t\t\tt.Fatalf(\"failed to delete bootstrap %v\", err)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(bs, pb.Bootstrap{}) {\n\t\t\t\tt.Fatalf(\"bs not nil\")\n\t\t\t}\n\t\t\tents, sz, err := logdb.IterateEntries(nil, 0, 1, 1, 0,\n\t\t\t\tmath.MaxUint64, math.MaxUint64)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to get entries %v\", err)\n\t\t\t}\n\t\t\tif len(ents) != 0 || sz != 0 {\n\t\t\t\tt.Fatalf(\"entry returned\")\n\t\t\t}\n\t\t\tsnapshot, err = logdb.GetSnapshot(1, 1)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif !pb.IsEmptySnapshot(snapshot) {\n\t\t\t\tt.Fatalf(\"snapshot not deleted\")\n\t\t\t}\n\t\t\t_, err = logdb.ReadRaftState(1, 1, 1)\n\t\t\tif !errors.Is(err, raftio.ErrNoSavedLog) {\n\t\t\t\tt.Fatalf(\"raft state not deleted %v\", err)\n\t\t\t}\n\t\t\tsysop, err := nh.RequestCompaction(1, 1)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to request compaction %v\", err)\n\t\t\t}\n\t\t\t<-sysop.ResultC()\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestSnapshotOptionIsChecked(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\topts := SnapshotOption{\n\t\t\t\tOverrideCompactionOverhead: true,\n\t\t\t\tCompactionIndex:            100,\n\t\t\t\tCompactionOverhead:         10,\n\t\t\t}\n\t\t\tassert.Equal(t, ErrInvalidOption, opts.Validate())\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\t\t\tdefer cancel()\n\t\t\t_, err := nh.SyncRequestSnapshot(ctx, 1, opts)\n\t\t\tassert.Equal(t, ErrInvalidOption, err)\n\t\t\trs, err := nh.RequestSnapshot(1, opts, time.Second)\n\t\t\tassert.Equal(t, ErrInvalidOption, err)\n\t\t\tassert.Nil(t, rs)\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestSnapshotCanBeExported(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tsspath := \"exported_snapshot_safe_to_delete\"\n\t\t\tif err := fs.RemoveAll(sspath); err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif err := fs.MkdirAll(sspath, 0755); err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\tif err := fs.RemoveAll(sspath); err != nil {\n\t\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tsession := nh.GetNoOPSession(1)\n\t\t\tpto := lpto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tcmd := make([]byte, 1518)\n\t\t\t_, err := nh.SyncPropose(ctx, session, cmd)\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to make proposal %v\", err)\n\t\t\t}\n\t\t\topt := SnapshotOption{\n\t\t\t\tExported:   true,\n\t\t\t\tExportPath: sspath,\n\t\t\t}\n\t\t\tsr, err := nh.RequestSnapshot(1, opt, pto)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to request snapshot\")\n\t\t\t}\n\t\t\tvar index uint64\n\t\t\tv := <-sr.ResultC()\n\t\t\tif !v.Completed() {\n\t\t\t\tt.Fatalf(\"failed to complete the requested snapshot\")\n\t\t\t}\n\t\t\tindex = v.SnapshotIndex()\n\t\t\tlogdb := nh.mu.logdb\n\t\t\tsnapshot, err := logdb.GetSnapshot(1, 1)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\t// exported snapshot is not managed by the system\n\t\t\tif !pb.IsEmptySnapshot(snapshot) {\n\t\t\t\tt.Fatalf(\"snapshot record unexpectedly inserted into the system\")\n\t\t\t}\n\t\t\tsnapshotDir := fmt.Sprintf(\"snapshot-%016X\", index)\n\t\t\tsnapshotFile := fmt.Sprintf(\"snapshot-%016X.gbsnap\", index)\n\t\t\tfp := fs.PathJoin(sspath, snapshotDir, snapshotFile)\n\t\t\texist, err := fileutil.Exist(fp, fs)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif !exist {\n\t\t\t\tt.Errorf(\"snapshot file not saved\")\n\t\t\t}\n\t\t\tmetafp := fs.PathJoin(sspath, snapshotDir, \"snapshot.metadata\")\n\t\t\texist, err = fileutil.Exist(metafp, fs)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif !exist {\n\t\t\t\tt.Errorf(\"snapshot metadata not saved\")\n\t\t\t}\n\t\t\tvar ss pb.Snapshot\n\t\t\tif err := fileutil.GetFlagFileContent(fs.PathJoin(sspath, snapshotDir),\n\t\t\t\t\"snapshot.metadata\", &ss, fs); err != nil {\n\t\t\t\tt.Fatalf(\"failed to get snapshot from its metadata file\")\n\t\t\t}\n\t\t\tif ss.OnDiskIndex != 0 {\n\t\t\t\tt.Errorf(\"on disk index is not 0\")\n\t\t\t}\n\t\t\tif ss.Imported {\n\t\t\t\tt.Errorf(\"incorrectly recorded as imported\")\n\t\t\t}\n\t\t\tif ss.Type != pb.RegularStateMachine {\n\t\t\t\tt.Errorf(\"incorrect type\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestOnDiskStateMachineCanExportSnapshot(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tfakeDiskNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tsession := nh.GetNoOPSession(1)\n\t\t\tproposed := false\n\t\t\tfor i := 0; i < 16; i++ {\n\t\t\t\tpto := pto(nh)\n\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t\t_, err := nh.SyncPropose(ctx, session, []byte(\"test-data\"))\n\t\t\t\tcancel()\n\t\t\t\tif err == nil {\n\t\t\t\t\tproposed = true\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !proposed {\n\t\t\t\tt.Fatalf(\"failed to make proposal\")\n\t\t\t}\n\t\t\tsspath := \"exported_snapshot_safe_to_delete\"\n\t\t\tif err := fs.RemoveAll(sspath); err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif err := fs.MkdirAll(sspath, 0755); err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\tif err := fs.RemoveAll(sspath); err != nil {\n\t\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t\t}\n\t\t\t}()\n\t\t\topt := SnapshotOption{\n\t\t\t\tExported:   true,\n\t\t\t\tExportPath: sspath,\n\t\t\t}\n\t\t\taborted := false\n\t\t\tindex := uint64(0)\n\t\t\tpto := lpto(nh)\n\t\t\tfor {\n\t\t\t\tsr, err := nh.RequestSnapshot(1, opt, pto)\n\t\t\t\tif err == ErrRejected {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"failed to request snapshot %v\", err)\n\t\t\t\t}\n\t\t\t\tv := <-sr.ResultC()\n\t\t\t\tif v.Aborted() {\n\t\t\t\t\taborted = true\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif v.code == requestRejected {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif !v.Completed() {\n\t\t\t\t\tt.Fatalf(\"failed to complete the requested snapshot, %s\", v.code)\n\t\t\t\t}\n\t\t\t\tindex = v.SnapshotIndex()\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif !aborted {\n\t\t\t\tt.Fatalf(\"never aborted\")\n\t\t\t}\n\t\t\tlogdb := nh.mu.logdb\n\t\t\tsnapshot, err := logdb.GetSnapshot(1, 1)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif !pb.IsEmptySnapshot(snapshot) {\n\t\t\t\tt.Fatalf(\"snapshot record unexpectedly inserted into the system\")\n\t\t\t}\n\t\t\tsnapshotDir := fmt.Sprintf(\"snapshot-%016X\", index)\n\t\t\tsnapshotFile := fmt.Sprintf(\"snapshot-%016X.gbsnap\", index)\n\t\t\tfp := fs.PathJoin(sspath, snapshotDir, snapshotFile)\n\t\t\texist, err := fileutil.Exist(fp, fs)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif !exist {\n\t\t\t\tt.Errorf(\"snapshot file not saved\")\n\t\t\t}\n\t\t\tmetafp := fs.PathJoin(sspath, snapshotDir, \"snapshot.metadata\")\n\t\t\texist, err = fileutil.Exist(metafp, fs)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif !exist {\n\t\t\t\tt.Errorf(\"snapshot metadata not saved\")\n\t\t\t}\n\t\t\tshrunk, err := rsm.IsShrunkSnapshotFile(fp, fs)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif shrunk {\n\t\t\t\tt.Errorf(\"exported snapshot is considered as shrunk\")\n\t\t\t}\n\t\t\tvar ss pb.Snapshot\n\t\t\tif err := fileutil.GetFlagFileContent(fs.PathJoin(sspath, snapshotDir),\n\t\t\t\t\"snapshot.metadata\", &ss, fs); err != nil {\n\t\t\t\tt.Fatalf(\"failed to get snapshot from its metadata file\")\n\t\t\t}\n\t\t\tif ss.OnDiskIndex == 0 {\n\t\t\t\tt.Errorf(\"on disk index is not recorded\")\n\t\t\t}\n\t\t\tif ss.Imported {\n\t\t\t\tt.Errorf(\"incorrectly recorded as imported\")\n\t\t\t}\n\t\t\tif ss.Type != pb.OnDiskStateMachine {\n\t\t\t\tt.Errorf(\"incorrect type\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc testImportedSnapshotIsAlwaysRestored(t *testing.T,\n\tnewDir bool, ct config.CompressionType, fs vfs.IFS) {\n\ttf := func() {\n\t\trc := config.Config{\n\t\t\tShardID:                 1,\n\t\t\tReplicaID:               1,\n\t\t\tElectionRTT:             3,\n\t\t\tHeartbeatRTT:            1,\n\t\t\tCheckQuorum:             true,\n\t\t\tSnapshotEntries:         5,\n\t\t\tCompactionOverhead:      2,\n\t\t\tSnapshotCompressionType: ct,\n\t\t}\n\t\tpeers := make(map[uint64]string)\n\t\tpeers[1] = nodeHostTestAddr1\n\t\tnhc := config.NodeHostConfig{\n\t\t\tNodeHostDir:    singleNodeHostTestDir,\n\t\t\tRTTMillisecond: getRTTMillisecond(fs, singleNodeHostTestDir),\n\t\t\tRaftAddress:    nodeHostTestAddr1,\n\t\t\tExpert:         getTestExpertConfig(fs),\n\t\t}\n\t\tnh, err := NewNodeHost(nhc)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to create node host %v\", err)\n\t\t}\n\t\tpto := lpto(nh)\n\t\tnewSM := func(uint64, uint64) sm.IOnDiskStateMachine {\n\t\t\treturn tests.NewSimDiskSM(0)\n\t\t}\n\t\tif err := nh.StartOnDiskReplica(peers, false, newSM, rc); err != nil {\n\t\t\tt.Fatalf(\"failed to start shard %v\", err)\n\t\t}\n\t\twaitForLeaderToBeElected(t, nh, 1)\n\t\tmakeProposals := func(nn *NodeHost) {\n\t\t\tsession := nn.GetNoOPSession(1)\n\t\t\tfor i := 0; i < 16; i++ {\n\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t\t_, err := nn.SyncPropose(ctx, session, []byte(\"test-data\"))\n\t\t\t\tcancel()\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"failed to make proposal %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmakeProposals(nh)\n\t\tsspath := \"exported_snapshot_safe_to_delete\"\n\t\tif err := fs.RemoveAll(sspath); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t\tif err := fs.MkdirAll(sspath, 0755); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t\tdefer func() {\n\t\t\tif err := fs.RemoveAll(sspath); err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t}()\n\t\topt := SnapshotOption{\n\t\t\tExported:   true,\n\t\t\tExportPath: sspath,\n\t\t}\n\t\tvar index uint64\n\t\tfor i := 0; i < 1000; i++ {\n\t\t\tif i == 999 {\n\t\t\t\tt.Fatalf(\"failed to export snapshot\")\n\t\t\t}\n\t\t\tsr, err := nh.RequestSnapshot(1, opt, pto)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to request snapshot %v\", err)\n\t\t\t}\n\t\t\tv := <-sr.ResultC()\n\t\t\tif v.Rejected() {\n\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif v.Completed() {\n\t\t\t\tindex = v.SnapshotIndex()\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tmakeProposals(nh)\n\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\trv, err := nh.SyncRead(ctx, 1, nil)\n\t\tcancel()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to read applied value %v\", err)\n\t\t}\n\t\tapplied := rv.(uint64)\n\t\tif applied <= index {\n\t\t\tt.Fatalf(\"invalid applied value %d\", applied)\n\t\t}\n\t\tctx, cancel = context.WithTimeout(context.Background(), pto)\n\t\tif err := nh.SyncRequestAddReplica(ctx, 1, 2, \"noidea:8080\", 0); err != nil {\n\t\t\tt.Fatalf(\"failed to add node %v\", err)\n\t\t}\n\t\tnh.Close()\n\t\tsnapshotDir := fmt.Sprintf(\"snapshot-%016X\", index)\n\t\tdir := fs.PathJoin(sspath, snapshotDir)\n\t\tmembers := make(map[uint64]string)\n\t\tmembers[1] = nhc.RaftAddress\n\t\tif newDir {\n\t\t\tnhc.NodeHostDir = fs.PathJoin(nhc.NodeHostDir, \"newdir\")\n\t\t}\n\t\tif err := tools.ImportSnapshot(nhc, dir, members, 1); err != nil {\n\t\t\tt.Fatalf(\"failed to import snapshot %v\", err)\n\t\t}\n\t\tok, err := upgrade310.CanUpgradeToV310(nhc)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to check whether upgrade is possible\")\n\t\t}\n\t\tif ok {\n\t\t\tt.Errorf(\"should not be considered as ok to upgrade\")\n\t\t}\n\t\tfunc() {\n\t\t\trnh, err := NewNodeHost(nhc)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to create node host %v\", err)\n\t\t\t}\n\t\t\tdefer rnh.Close()\n\t\t\trnewSM := func(uint64, uint64) sm.IOnDiskStateMachine {\n\t\t\t\treturn tests.NewSimDiskSM(applied)\n\t\t\t}\n\t\t\tif err := rnh.StartOnDiskReplica(nil, false, rnewSM, rc); err != nil {\n\t\t\t\tt.Fatalf(\"failed to start shard %v\", err)\n\t\t\t}\n\t\t\twaitForLeaderToBeElected(t, rnh, 1)\n\t\t\tctx, cancel = context.WithTimeout(context.Background(), pto)\n\t\t\trv, err = rnh.SyncRead(ctx, 1, nil)\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to read applied value %v\", err)\n\t\t\t}\n\t\t\tif index != rv.(uint64) {\n\t\t\t\tt.Fatalf(\"invalid returned value %d\", rv.(uint64))\n\t\t\t}\n\t\t\tmakeProposals(rnh)\n\t\t}()\n\t\tok, err = upgrade310.CanUpgradeToV310(nhc)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to check whether upgrade is possible\")\n\t\t}\n\t\tif !ok {\n\t\t\tt.Errorf(\"can not upgrade\")\n\t\t}\n\t}\n\trunNodeHostTestDC(t, tf, true, fs)\n}\n\nfunc TestImportedSnapshotIsAlwaysRestored(t *testing.T) {\n\tif vfs.GetTestFS() != vfs.DefaultFS {\n\t\tt.Skip(\"not using the default fs\")\n\t} else {\n\t\tfs := vfs.GetTestFS()\n\t\ttestImportedSnapshotIsAlwaysRestored(t, true, config.NoCompression, fs)\n\t\ttestImportedSnapshotIsAlwaysRestored(t, false, config.NoCompression, fs)\n\t\ttestImportedSnapshotIsAlwaysRestored(t, false, config.Snappy, fs)\n\t}\n}\n\nfunc TestShardWithoutQuorumCanBeRestoreByImportingSnapshot(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\ttf := func() {\n\t\tnh1dir := fs.PathJoin(singleNodeHostTestDir, \"nh1\")\n\t\tnh2dir := fs.PathJoin(singleNodeHostTestDir, \"nh2\")\n\t\trc := config.Config{\n\t\t\tShardID:            1,\n\t\t\tReplicaID:          1,\n\t\t\tElectionRTT:        10,\n\t\t\tHeartbeatRTT:       1,\n\t\t\tCheckQuorum:        true,\n\t\t\tSnapshotEntries:    5,\n\t\t\tCompactionOverhead: 2,\n\t\t}\n\t\tpeers := make(map[uint64]string)\n\t\tpeers[1] = nodeHostTestAddr1\n\t\tnhc1 := config.NodeHostConfig{\n\t\t\tWALDir:         nh1dir,\n\t\t\tNodeHostDir:    nh1dir,\n\t\t\tRTTMillisecond: getRTTMillisecond(fs, nh1dir),\n\t\t\tRaftAddress:    nodeHostTestAddr1,\n\t\t\tExpert:         getTestExpertConfig(fs),\n\t\t}\n\t\tnhc2 := config.NodeHostConfig{\n\t\t\tWALDir:         nh2dir,\n\t\t\tNodeHostDir:    nh2dir,\n\t\t\tRTTMillisecond: getRTTMillisecond(fs, nh2dir),\n\t\t\tRaftAddress:    nodeHostTestAddr2,\n\t\t\tExpert:         getTestExpertConfig(fs),\n\t\t}\n\t\tvar once sync.Once\n\t\tnh1, err := NewNodeHost(nhc1)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to create node host %v\", err)\n\t\t}\n\t\tnh2, err := NewNodeHost(nhc2)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to create node host %v\", err)\n\t\t}\n\t\tsm1 := tests.NewFakeDiskSM(0)\n\t\tsm1.SetAborted()\n\t\tnewSM := func(uint64, uint64) sm.IOnDiskStateMachine {\n\t\t\treturn sm1\n\t\t}\n\t\tnewSM2 := func(uint64, uint64) sm.IOnDiskStateMachine {\n\t\t\treturn tests.NewFakeDiskSM(0)\n\t\t}\n\t\tif err := nh1.StartOnDiskReplica(peers, false, newSM, rc); err != nil {\n\t\t\tt.Fatalf(\"failed to start shard %v\", err)\n\t\t}\n\t\twaitForLeaderToBeElected(t, nh1, 1)\n\t\tdefer func() {\n\t\t\tif err := fs.RemoveAll(singleNodeHostTestDir); err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t}()\n\t\tdefer once.Do(func() {\n\t\t\tnh1.Close()\n\t\t\tnh2.Close()\n\t\t})\n\t\tsession := nh1.GetNoOPSession(1)\n\t\tmkproposal := func(nh *NodeHost) {\n\t\t\tdone := false\n\t\t\tpto := pto(nh)\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t\t_, err := nh.SyncPropose(ctx, session, []byte(\"test-data\"))\n\t\t\t\tcancel()\n\t\t\t\tif err == nil {\n\t\t\t\t\tdone = true\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\ttime.Sleep(200 * time.Millisecond)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !done {\n\t\t\t\tt.Fatalf(\"failed to make proposal on restored shard\")\n\t\t\t}\n\t\t}\n\t\tmkproposal(nh1)\n\t\tsspath := \"exported_snapshot_safe_to_delete\"\n\t\tif err := fs.RemoveAll(sspath); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t\tif err := fs.MkdirAll(sspath, 0755); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t\tdefer func() {\n\t\t\tif err := fs.RemoveAll(sspath); err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t}()\n\t\topt := SnapshotOption{\n\t\t\tExported:   true,\n\t\t\tExportPath: sspath,\n\t\t}\n\t\tpto := lpto(nh1)\n\t\tsr, err := nh1.RequestSnapshot(1, opt, pto)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to request snapshot %v\", err)\n\t\t}\n\t\tvar index uint64\n\t\tv := <-sr.ResultC()\n\t\tif !v.Completed() {\n\t\t\tt.Fatalf(\"failed to complete the requested snapshot\")\n\t\t}\n\t\tindex = v.SnapshotIndex()\n\t\tsnapshotDir := fmt.Sprintf(\"snapshot-%016X\", index)\n\t\tdir := fs.PathJoin(sspath, snapshotDir)\n\t\tmembers := make(map[uint64]string)\n\t\tmembers[1] = nhc1.RaftAddress\n\t\tmembers[10] = nhc2.RaftAddress\n\t\tonce.Do(func() {\n\t\t\tnh1.Close()\n\t\t\tnh2.Close()\n\t\t})\n\t\tif err := tools.ImportSnapshot(nhc1, dir, members, 1); err != nil {\n\t\t\tt.Fatalf(\"failed to import snapshot %v\", err)\n\t\t}\n\t\tif err := tools.ImportSnapshot(nhc2, dir, members, 10); err != nil {\n\t\t\tt.Fatalf(\"failed to import snapshot %v\", err)\n\t\t}\n\t\trnh1, err := NewNodeHost(nhc1)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to create node host %v\", err)\n\t\t}\n\t\trnh2, err := NewNodeHost(nhc2)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to create node host %v\", err)\n\t\t}\n\t\tdefer func() {\n\t\t\trnh1.Close()\n\t\t\trnh2.Close()\n\t\t}()\n\t\tif err := rnh1.StartOnDiskReplica(nil, false, newSM, rc); err != nil {\n\t\t\tt.Fatalf(\"failed to start shard %v\", err)\n\t\t}\n\t\trc.ReplicaID = 10\n\t\tif err := rnh2.StartOnDiskReplica(nil, false, newSM2, rc); err != nil {\n\t\t\tt.Fatalf(\"failed to start shard %v\", err)\n\t\t}\n\t\twaitForLeaderToBeElected(t, rnh1, 1)\n\t\tmkproposal(rnh1)\n\t\tmkproposal(rnh2)\n\t}\n\trunNodeHostTestDC(t, tf, true, fs)\n}\n\ntype chunks struct {\n\treceived  uint64\n\tconfirmed uint64\n}\n\nvar (\n\ttestSnapshotDir = \"test_snapshot_dir_safe_to_delete\"\n)\n\nfunc (c *chunks) onReceive(pb.MessageBatch) {\n\tc.received++\n}\n\nfunc (c *chunks) confirm(shardID uint64, replicaID uint64, index uint64) {\n\tc.confirmed++\n}\n\nfunc (c *chunks) getSnapshotDirFunc(shardID uint64, replicaID uint64) string {\n\treturn testSnapshotDir\n}\n\ntype testSink2 struct {\n\treceiver chunkReceiver\n}\n\nfunc (s *testSink2) Receive(chunk pb.Chunk) (bool, bool) {\n\ts.receiver.Add(chunk)\n\treturn true, false\n}\n\nfunc (s *testSink2) Close() error {\n\ts.Receive(pb.Chunk{ChunkCount: pb.PoisonChunkCount})\n\treturn nil\n}\n\nfunc (s *testSink2) ShardID() uint64 {\n\treturn 2000\n}\n\nfunc (s *testSink2) ToReplicaID() uint64 {\n\treturn 300\n}\n\ntype dataCorruptionSink struct {\n\treceiver chunkReceiver\n\tenabled  bool\n}\n\nfunc (s *dataCorruptionSink) Receive(chunk pb.Chunk) (bool, bool) {\n\tif s.enabled && len(chunk.Data) > 0 {\n\t\tidx := rand.Uint64() % uint64(len(chunk.Data))\n\t\tchunk.Data[idx] = chunk.Data[idx] + 1\n\t}\n\ts.receiver.Add(chunk)\n\treturn true, false\n}\n\nfunc (s *dataCorruptionSink) Close() error {\n\ts.Receive(pb.Chunk{ChunkCount: pb.PoisonChunkCount})\n\treturn nil\n}\n\nfunc (s *dataCorruptionSink) ShardID() uint64 {\n\treturn 2000\n}\n\nfunc (s *dataCorruptionSink) ToReplicaID() uint64 {\n\treturn 300\n}\n\ntype chunkReceiver interface {\n\tAdd(chunk pb.Chunk) bool\n}\n\nfunc getTestSSMeta() rsm.SSMeta {\n\treturn rsm.SSMeta{\n\t\tIndex: 1000,\n\t\tTerm:  5,\n\t\tFrom:  150,\n\t}\n}\n\nfunc testCorruptedChunkWriterOutputCanBeHandledByChunk(t *testing.T,\n\tenabled bool, exp uint64, fs vfs.IFS) {\n\tif err := fs.RemoveAll(testSnapshotDir); err != nil {\n\t\tt.Fatalf(\"%v\", err)\n\t}\n\tc := &chunks{}\n\tif err := fs.MkdirAll(c.getSnapshotDirFunc(0, 0), 0755); err != nil {\n\t\tt.Fatalf(\"%v\", err)\n\t}\n\tcks := transport.NewChunk(c.onReceive,\n\t\tc.confirm, c.getSnapshotDirFunc, 0, fs)\n\tsink := &dataCorruptionSink{receiver: cks, enabled: enabled}\n\tmeta := getTestSSMeta()\n\tcw := rsm.NewChunkWriter(sink, meta)\n\tdefer func() {\n\t\tif err := fs.RemoveAll(testSnapshotDir); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t}()\n\tfor i := 0; i < 10; i++ {\n\t\tdata := make([]byte, rsm.ChunkSize)\n\t\trand.Read(data)\n\t\tif _, err := cw.Write(data); err != nil {\n\t\t\tt.Fatalf(\"failed to write the data %v\", err)\n\t\t}\n\t}\n\tif err := cw.Close(); err != nil {\n\t\tt.Fatalf(\"failed to flush %v\", err)\n\t}\n\tif c.received != exp {\n\t\tt.Fatalf(\"unexpected received count: %d, want %d\", c.received, exp)\n\t}\n\tif c.confirmed != exp {\n\t\tt.Fatalf(\"unexpected confirmed count: %d, want %d\", c.confirmed, exp)\n\t}\n}\n\nfunc TestCorruptedChunkWriterOutputCanBeHandledByChunk(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\ttestCorruptedChunkWriterOutputCanBeHandledByChunk(t, false, 1, fs)\n\ttestCorruptedChunkWriterOutputCanBeHandledByChunk(t, true, 0, fs)\n}\n\nfunc TestChunkWriterOutputCanBeHandledByChunk(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tif err := fs.RemoveAll(testSnapshotDir); err != nil {\n\t\tt.Fatalf(\"%v\", err)\n\t}\n\tc := &chunks{}\n\tif err := fs.MkdirAll(c.getSnapshotDirFunc(0, 0), 0755); err != nil {\n\t\tt.Fatalf(\"%v\", err)\n\t}\n\tcks := transport.NewChunk(c.onReceive,\n\t\tc.confirm, c.getSnapshotDirFunc, 0, fs)\n\tsink := &testSink2{receiver: cks}\n\tmeta := getTestSSMeta()\n\tcw := rsm.NewChunkWriter(sink, meta)\n\tif _, err := cw.Write(rsm.GetEmptyLRUSession()); err != nil {\n\t\tt.Fatalf(\"write failed %v\", err)\n\t}\n\tdefer func() {\n\t\tif err := fs.RemoveAll(testSnapshotDir); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t}()\n\tpayload := make([]byte, 0)\n\tpayload = append(payload, rsm.GetEmptyLRUSession()...)\n\tfor i := 0; i < 10; i++ {\n\t\tdata := make([]byte, rsm.ChunkSize)\n\t\trand.Read(data)\n\t\tpayload = append(payload, data...)\n\t\tif _, err := cw.Write(data); err != nil {\n\t\t\tt.Fatalf(\"failed to write the data %v\", err)\n\t\t}\n\t}\n\tif err := cw.Close(); err != nil {\n\t\tt.Fatalf(\"failed to flush %v\", err)\n\t}\n\tif c.received != 1 {\n\t\tt.Fatalf(\"failed to receive the snapshot\")\n\t}\n\tif c.confirmed != 1 {\n\t\tt.Fatalf(\"failed to confirm\")\n\t}\n\tfp := fs.PathJoin(testSnapshotDir,\n\t\t\"snapshot-00000000000003E8\", \"snapshot-00000000000003E8.gbsnap\")\n\treader, _, err := rsm.NewSnapshotReader(fp, fs)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get a snapshot reader %v\", err)\n\t}\n\tdefer reader.Close()\n\tgot := make([]byte, 0)\n\tbuf := make([]byte, 1024*256)\n\tfor {\n\t\tn, err := reader.Read(buf)\n\t\tif n > 0 {\n\t\t\tgot = append(got, buf[:n]...)\n\t\t}\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t}\n\tif !bytes.Equal(got, payload) {\n\t\tt.Errorf(\"snapshot content changed\")\n\t}\n}\n\nfunc TestNodeHostReturnsErrorWhenTransportCanNotBeCreated(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tif fs != vfs.DefaultFS {\n\t\tt.Skip(\"memfs test mode, skipped\")\n\t}\n\tto := &testOption{\n\t\tupdateNodeHostConfig: func(c *config.NodeHostConfig) *config.NodeHostConfig {\n\t\t\tc.RaftAddress = \"microsoft.com:12345\"\n\t\t\treturn c\n\t\t},\n\t\tnewNodeHostToFail: true,\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestNodeHostChecksLogDBType(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tldb := &noopLogDB{}\n\tto := &testOption{\n\t\tupdateNodeHostConfig: func(c *config.NodeHostConfig) *config.NodeHostConfig {\n\t\t\tc.Expert.LogDBFactory = &testLogDBFactory{ldb: ldb}\n\t\t\treturn c\n\t\t},\n\t\tat: func(*NodeHost) {\n\t\t\tnhc := getTestNodeHostConfig(fs)\n\t\t\t_, err := NewNodeHost(*nhc)\n\t\t\tif err != server.ErrLogDBType {\n\t\t\t\tt.Fatalf(\"didn't report logdb type error %v\", err)\n\t\t\t}\n\t\t},\n\t\tnoElection: true,\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nvar spawnChild = flag.Bool(\"spawn-child\", false, \"spawned child\")\n\nfunc spawn(execName string) ([]byte, error) {\n\treturn exec.Command(execName, \"-spawn-child\",\n\t\t\"-test.v\", \"-test.run=TestNodeHostFileLock$\").CombinedOutput()\n}\n\nfunc TestNodeHostFileLock(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tif fs != vfs.DefaultFS {\n\t\tt.Skip(\"not using the default fs, skipped\")\n\t}\n\ttf := func() {\n\t\tchild := *spawnChild\n\t\tnhc := config.NodeHostConfig{\n\t\t\tNodeHostDir:    singleNodeHostTestDir,\n\t\t\tRTTMillisecond: getRTTMillisecond(fs, singleNodeHostTestDir),\n\t\t\tRaftAddress:    nodeHostTestAddr1,\n\t\t\tExpert:         getTestExpertConfig(fs),\n\t\t}\n\t\tif !child {\n\t\t\tnh, err := NewNodeHost(nhc)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to create nodehost %v\", err)\n\t\t\t}\n\t\t\tdefer nh.Close()\n\t\t\tout, err := spawn(os.Args[0])\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"file lock didn't prevent the second nh to start, %s\", out)\n\t\t\t}\n\t\t\tif !bytes.Contains(out, []byte(\"returned ErrLockDirectory\")) {\n\t\t\t\tt.Fatalf(\"unexpected output: %s\", out)\n\t\t\t}\n\t\t} else {\n\t\t\tnhc.RaftAddress = nodeHostTestAddr2\n\t\t\tcnh, err := NewNodeHost(nhc)\n\t\t\tif err == server.ErrLockDirectory {\n\t\t\t\tt.Fatalf(\"returned ErrLockDirectory\")\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\tdefer cnh.Close()\n\t\t\t}\n\t\t}\n\t}\n\trunNodeHostTestDC(t, tf, !*spawnChild, fs)\n}\n\nfunc TestChangeNodeHostID(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\ttf := func() {\n\t\tnhc := config.NodeHostConfig{\n\t\t\tNodeHostDir:    singleNodeHostTestDir,\n\t\t\tRTTMillisecond: getRTTMillisecond(fs, singleNodeHostTestDir),\n\t\t\tRaftAddress:    nodeHostTestAddr1,\n\t\t\tExpert:         getTestExpertConfig(fs),\n\t\t}\n\t\tnh, err := NewNodeHost(nhc)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to create nodehost %v\", err)\n\t\t}\n\t\tnh.Close()\n\t\tv := id.New()\n\t\tnhc.NodeHostID = v.String()\n\t\t_, err = NewNodeHost(nhc)\n\t\tif err == nil || !errors.Is(err, server.ErrNodeHostIDChanged) {\n\t\t\tt.Fatalf(\"failed to reject changed NodeHostID %v\", err)\n\t\t}\n\t}\n\trunNodeHostTestDC(t, tf, !*spawnChild, fs)\n}\n\ntype testLogDBFactory2 struct {\n\tf func(config.NodeHostConfig,\n\t\tconfig.LogDBCallback, []string, []string) (raftio.ILogDB, error)\n\tname string\n}\n\nfunc (t *testLogDBFactory2) Create(cfg config.NodeHostConfig, cb config.LogDBCallback,\n\tdirs []string, wals []string) (raftio.ILogDB, error) {\n\treturn t.f(cfg, cb, dirs, wals)\n}\n\nfunc (t *testLogDBFactory2) Name() string {\n\treturn t.name\n}\n\nfunc TestNodeHostReturnsErrLogDBBrokenChangeWhenLogDBTypeChanges(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tbff := func(config config.NodeHostConfig, cb config.LogDBCallback,\n\t\tdirs []string, lldirs []string) (raftio.ILogDB, error) {\n\t\treturn logdb.NewDefaultBatchedLogDB(config, cb, dirs, lldirs)\n\t}\n\tnff := func(config config.NodeHostConfig, cb config.LogDBCallback,\n\t\tdirs []string, lldirs []string) (raftio.ILogDB, error) {\n\t\treturn logdb.NewDefaultLogDB(config, cb, dirs, lldirs)\n\t}\n\tto := &testOption{\n\t\tat: func(*NodeHost) {\n\t\t\tnhc := getTestNodeHostConfig(fs)\n\t\t\tnhc.Expert.LogDBFactory = &testLogDBFactory2{f: nff}\n\t\t\tif _, err := NewNodeHost(*nhc); err != server.ErrLogDBBrokenChange {\n\t\t\t\tt.Errorf(\"failed to return ErrLogDBBrokenChange\")\n\t\t\t}\n\t\t},\n\t\tupdateNodeHostConfig: func(c *config.NodeHostConfig) *config.NodeHostConfig {\n\t\t\tc.Expert.LogDBFactory = &testLogDBFactory2{f: bff}\n\t\t\treturn c\n\t\t},\n\t\tnoElection: true,\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestNodeHostByDefaultUsePlainEntryLogDB(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tbff := func(config config.NodeHostConfig, cb config.LogDBCallback,\n\t\tdirs []string, lldirs []string) (raftio.ILogDB, error) {\n\t\treturn logdb.NewDefaultBatchedLogDB(config, cb, dirs, lldirs)\n\t}\n\tnff := func(config config.NodeHostConfig, cb config.LogDBCallback,\n\t\tdirs []string, lldirs []string) (raftio.ILogDB, error) {\n\t\treturn logdb.NewDefaultLogDB(config, cb, dirs, lldirs)\n\t}\n\tto := &testOption{\n\t\tupdateNodeHostConfig: func(c *config.NodeHostConfig) *config.NodeHostConfig {\n\t\t\tc.Expert.LogDBFactory = &testLogDBFactory2{f: nff}\n\t\t\treturn c\n\t\t},\n\t\tnoElection: true,\n\t\tat: func(*NodeHost) {\n\t\t\tnhc := getTestNodeHostConfig(fs)\n\t\t\tnhc.Expert.LogDBFactory = &testLogDBFactory2{f: bff}\n\t\t\tif _, err := NewNodeHost(*nhc); err != server.ErrIncompatibleData {\n\t\t\t\tt.Errorf(\"failed to return server.ErrIncompatibleData\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestNodeHostByDefaultChecksWhetherToUseBatchedLogDB(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tbff := func(config config.NodeHostConfig, cb config.LogDBCallback,\n\t\tdirs []string, lldirs []string) (raftio.ILogDB, error) {\n\t\treturn logdb.NewDefaultBatchedLogDB(config, cb, dirs, lldirs)\n\t}\n\tnff := func(config config.NodeHostConfig, cb config.LogDBCallback,\n\t\tdirs []string, lldirs []string) (raftio.ILogDB, error) {\n\t\treturn logdb.NewDefaultLogDB(config, cb, dirs, lldirs)\n\t}\n\tto := &testOption{\n\t\tupdateNodeHostConfig: func(c *config.NodeHostConfig) *config.NodeHostConfig {\n\t\t\tc.Expert.LogDBFactory = &testLogDBFactory2{f: bff}\n\t\t\treturn c\n\t\t},\n\t\tcreateSM: func(uint64, uint64) sm.IStateMachine {\n\t\t\treturn &PST{}\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := pto(nh)\n\t\t\tcs := nh.GetNoOPSession(1)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t_, err := nh.SyncPropose(ctx, cs, []byte(\"test-data\"))\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to make proposal %v\", err)\n\t\t\t}\n\t\t},\n\t\tat: func(*NodeHost) {\n\t\t\tnhc := getTestNodeHostConfig(fs)\n\t\t\tnhc.Expert.LogDBFactory = &testLogDBFactory2{f: nff}\n\t\t\tif nh, err := NewNodeHost(*nhc); err != nil {\n\t\t\t\tt.Errorf(\"failed to create node host\")\n\t\t\t} else {\n\t\t\t\tnh.Close()\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestNodeHostWithUnexpectedDeploymentIDWillBeDetected(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tnoElection: true,\n\t\tat: func(*NodeHost) {\n\t\t\tnhc := getTestNodeHostConfig(fs)\n\t\t\tnhc.DeploymentID = 200\n\t\t\t_, err := NewNodeHost(*nhc)\n\t\t\tif err != server.ErrDeploymentIDChanged {\n\t\t\t\tt.Errorf(\"failed to return ErrDeploymentIDChanged, got %v\", err)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestGossipInfoIsReported(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tadvertiseAddress := \"202.96.1.2:12345\"\n\tto := &testOption{\n\t\tnoElection: true,\n\t\tupdateNodeHostConfig: func(c *config.NodeHostConfig) *config.NodeHostConfig {\n\t\t\tc.DefaultNodeRegistryEnabled = true\n\t\t\tc.Gossip = config.GossipConfig{\n\t\t\t\tBindAddress:      \"localhost:23001\",\n\t\t\t\tAdvertiseAddress: advertiseAddress,\n\t\t\t\tSeed:             []string{\"localhost:23002\"},\n\t\t\t}\n\t\t\treturn c\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tnhi := nh.GetNodeHostInfo(DefaultNodeHostInfoOption)\n\t\t\tif nhi.Gossip.AdvertiseAddress != advertiseAddress {\n\t\t\t\tt.Errorf(\"unexpected advertise address, got %s, want %s\",\n\t\t\t\t\tnhi.Gossip.AdvertiseAddress, advertiseAddress)\n\t\t\t}\n\t\t\tif !nhi.Gossip.Enabled {\n\t\t\t\tt.Errorf(\"gossip info not marked as enabled\")\n\t\t\t}\n\t\t\tif nhi.Gossip.NumOfKnownNodeHosts != 1 {\n\t\t\t\tt.Errorf(\"unexpected NumOfKnownNodeHosts, got %d, want 1\",\n\t\t\t\t\tnhi.Gossip.NumOfKnownNodeHosts)\n\t\t\t}\n\t\t\tif nhi.NodeHostID != nh.ID() {\n\t\t\t\tt.Errorf(\"unexpected NodeHostID, got %s, want %s\", nhi.NodeHostID, nh.ID())\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestLeaderInfoIsReported(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tleaderAvailable := false\n\t\t\tfor i := 0; i < 500; i++ {\n\t\t\t\tnhi := nh.GetNodeHostInfo(DefaultNodeHostInfoOption)\n\t\t\t\tif len(nhi.ShardInfoList) != 1 {\n\t\t\t\t\tt.Errorf(\"unexpected len: %d\", len(nhi.ShardInfoList))\n\t\t\t\t}\n\t\t\t\tif nhi.ShardInfoList[0].ShardID != 1 {\n\t\t\t\t\tt.Fatalf(\"unexpected shard id\")\n\t\t\t\t}\n\t\t\t\tif nhi.ShardInfoList[0].LeaderID != 1 {\n\t\t\t\t\ttime.Sleep(20 * time.Millisecond)\n\t\t\t\t} else {\n\t\t\t\t\tleaderAvailable = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !leaderAvailable {\n\t\t\t\tt.Fatalf(\"failed to get leader info\")\n\t\t\t}\n\t\t\tpto := pto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tdefer cancel()\n\t\t\tif err := nh.SyncRequestAddReplica(ctx, 1, 2, \"noidea:8080\", 0); err != nil {\n\t\t\t\tt.Fatalf(\"failed to add node %v\", err)\n\t\t\t}\n\t\t\tfor i := 0; i < 500; i++ {\n\t\t\t\tnhi := nh.GetNodeHostInfo(DefaultNodeHostInfoOption)\n\t\t\t\tif len(nhi.ShardInfoList) != 1 {\n\t\t\t\t\tt.Errorf(\"unexpected len: %d\", len(nhi.ShardInfoList))\n\t\t\t\t}\n\t\t\t\tif nhi.ShardInfoList[0].LeaderID == 1 {\n\t\t\t\t\ttime.Sleep(20 * time.Millisecond)\n\t\t\t\t} else {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.Fatalf(\"no leader info change\")\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestDroppedRequestsAreReported(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := lpto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tdefer cancel()\n\t\t\tif err := nh.SyncRequestAddReplica(ctx, 1, 2, \"noidea:8080\", 0); err != nil {\n\t\t\t\tt.Fatalf(\"failed to add node %v\", err)\n\t\t\t}\n\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\t_, _, ok, err := nh.GetLeaderID(1)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"failed to get leader id %v\", err)\n\t\t\t\t}\n\t\t\t\tif err == nil && !ok {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t\tif i == 999 {\n\t\t\t\t\tt.Fatalf(\"leader failed to step down\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlimited := 30 * time.Minute\n\t\t\tfunc() {\n\t\t\t\tnctx, ncancel := context.WithTimeout(context.Background(), unlimited)\n\t\t\t\tdefer ncancel()\n\t\t\t\tcs := nh.GetNoOPSession(1)\n\t\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\t\tif _, err := nh.SyncPropose(nctx, cs, make([]byte, 1)); err != ErrShardNotReady {\n\t\t\t\t\t\tt.Errorf(\"failed to get ErrShardNotReady, got %v\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tfunc() {\n\t\t\t\tnctx, ncancel := context.WithTimeout(context.Background(), unlimited)\n\t\t\t\tdefer ncancel()\n\t\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\t\tif err := nh.SyncRequestAddReplica(nctx, 1, 3, \"noidea:8080\", 0); err != ErrShardNotReady {\n\t\t\t\t\t\tt.Errorf(\"failed to get ErrShardNotReady, got %v\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tfunc() {\n\t\t\t\tnctx, ncancel := context.WithTimeout(context.Background(), unlimited)\n\t\t\t\tdefer ncancel()\n\t\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\t\tif _, err := nh.SyncRead(nctx, 1, nil); err != ErrShardNotReady {\n\t\t\t\t\t\tt.Errorf(\"failed to get ErrShardNotReady, got %v\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\ntype testRaftEventListener struct {\n\tmu       sync.Mutex\n\treceived []raftio.LeaderInfo\n}\n\nfunc (rel *testRaftEventListener) LeaderUpdated(info raftio.LeaderInfo) {\n\trel.mu.Lock()\n\tdefer rel.mu.Unlock()\n\trel.received = append(rel.received, info)\n}\n\nfunc (rel *testRaftEventListener) get() []raftio.LeaderInfo {\n\trel.mu.Lock()\n\tdefer rel.mu.Unlock()\n\tr := make([]raftio.LeaderInfo, 0)\n\treturn append(r, rel.received...)\n}\n\nfunc TestRaftEventsAreReported(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\trel := &testRaftEventListener{\n\t\treceived: make([]raftio.LeaderInfo, 0),\n\t}\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\tupdateNodeHostConfig: func(nh *config.NodeHostConfig) *config.NodeHostConfig {\n\t\t\tnh.RaftEventListener = rel\n\t\t\treturn nh\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := pto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tif err := nh.SyncRequestAddReplica(ctx, 1, 2, \"127.0.0.1:8080\", 0); err != nil {\n\t\t\t\tt.Fatalf(\"add node failed %v\", err)\n\t\t\t}\n\t\t\tcancel()\n\t\t\tvar received []raftio.LeaderInfo\n\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\treceived = rel.get()\n\t\t\t\tif len(received) >= 4 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t\tif i == 999 {\n\t\t\t\t\tt.Fatalf(\"failed to get the second LeaderUpdated notification\")\n\t\t\t\t}\n\t\t\t}\n\t\t\texp0 := raftio.LeaderInfo{\n\t\t\t\tShardID:   1,\n\t\t\t\tReplicaID: 1,\n\t\t\t\tLeaderID:  raftio.NoLeader,\n\t\t\t\tTerm:      1,\n\t\t\t}\n\t\t\texp1 := raftio.LeaderInfo{\n\t\t\t\tShardID:   1,\n\t\t\t\tReplicaID: 1,\n\t\t\t\tLeaderID:  raftio.NoLeader,\n\t\t\t\tTerm:      2,\n\t\t\t}\n\t\t\texp2 := raftio.LeaderInfo{\n\t\t\t\tShardID:   1,\n\t\t\t\tReplicaID: 1,\n\t\t\t\tLeaderID:  1,\n\t\t\t\tTerm:      2,\n\t\t\t}\n\t\t\texp3 := raftio.LeaderInfo{\n\t\t\t\tShardID:   1,\n\t\t\t\tReplicaID: 1,\n\t\t\t\tLeaderID:  raftio.NoLeader,\n\t\t\t\tTerm:      2,\n\t\t\t}\n\t\t\texpected := []raftio.LeaderInfo{exp0, exp1, exp2, exp3}\n\t\t\tfor idx := range expected {\n\t\t\t\tif !reflect.DeepEqual(&(received[idx]), &expected[idx]) {\n\t\t\t\t\tt.Errorf(\"unexpecded leader info, %d, %v, %v\",\n\t\t\t\t\t\tidx, received[idx], expected[idx])\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestV2DataCanBeHandled(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tif vfs.GetTestFS() != vfs.DefaultFS {\n\t\tt.Skip(\"skipped as not using the default fs\")\n\t}\n\tv2datafp := \"internal/logdb/testdata/v2-rocksdb-batched.tar.bz2\"\n\ttargetDir := \"test-v2-data-safe-to-remove\"\n\tif err := fs.RemoveAll(targetDir); err != nil {\n\t\tt.Fatalf(\"%v\", err)\n\t}\n\tdefer func() {\n\t\tif err := fs.RemoveAll(targetDir); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t}()\n\ttopDirName := \"single_nodehost_test_dir_safe_to_delete\"\n\ttestHostname := \"lindfield.local\"\n\tif err := fileutil.ExtractTarBz2(v2datafp, targetDir, fs); err != nil {\n\t\tt.Fatalf(\"%v\", err)\n\t}\n\thostname, err := os.Hostname()\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get hostname %v\", err)\n\t}\n\ttestPath := fs.PathJoin(targetDir, topDirName, testHostname)\n\texpPath := fs.PathJoin(targetDir, topDirName, hostname)\n\tif expPath != testPath {\n\t\tif err := fs.Rename(testPath, expPath); err != nil {\n\t\t\tt.Fatalf(\"failed to rename the dir %v\", err)\n\t\t}\n\t}\n\tv2dataDir := fs.PathJoin(targetDir, topDirName)\n\tto := &testOption{\n\t\tnoElection: true,\n\t\tupdateNodeHostConfig: func(c *config.NodeHostConfig) *config.NodeHostConfig {\n\t\t\tc.WALDir = v2dataDir\n\t\t\tc.NodeHostDir = v2dataDir\n\t\t\treturn c\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tname := nh.mu.logdb.Name()\n\t\t\tif name != \"sharded-pebble\" {\n\t\t\t\t// v2-rocksdb-batched.tar.bz2 contains rocksdb format data\n\t\t\t\tt.Skip(\"skipped as not using rocksdb compatible logdb\")\n\t\t\t}\n\t\t\tlogdb := nh.mu.logdb\n\t\t\trs, err := logdb.ReadRaftState(2, 1, 0)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to get raft state %v\", err)\n\t\t\t}\n\t\t\tif rs.EntryCount != 3 || rs.State.Commit != 3 {\n\t\t\t\tt.Errorf(\"unexpected rs value\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestSnapshotCanBeCompressed(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tcompressed: true,\n\t\tcreateSM: func(uint64, uint64) sm.IStateMachine {\n\t\t\treturn &tests.VerboseSnapshotSM{}\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\tpto := lpto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\t_, err := nh.SyncRequestSnapshot(ctx, 1, DefaultSnapshotOption)\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to request snapshot %v\", err)\n\t\t\t}\n\t\t\tlogdb := nh.mu.logdb\n\t\t\tss, err := logdb.GetSnapshot(1, 1)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to list snapshots: %v\", err)\n\t\t\t}\n\t\t\tif pb.IsEmptySnapshot(ss) {\n\t\t\t\tt.Fatalf(\"failed to get snapshot rec\")\n\t\t\t}\n\t\t\tfi, err := fs.Stat(ss.Filepath)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to get file path %v\", err)\n\t\t\t}\n\t\t\tif fi.Size() > 1024*364 {\n\t\t\t\tt.Errorf(\"snapshot file not compressed, sz %d\", fi.Size())\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc makeProposals(nh *NodeHost) {\n\tsession := nh.GetNoOPSession(1)\n\tpto := pto(nh)\n\tfor i := 0; i < 16; i++ {\n\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t_, err := nh.SyncPropose(ctx, session, []byte(\"test-data\"))\n\t\tcancel()\n\t\tif err != nil {\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t}\n\t}\n}\n\nfunc testWitnessIO(t *testing.T,\n\twitnessTestFunc func(*NodeHost, *NodeHost, *tests.SimDiskSM), fs vfs.IFS) {\n\ttf := func() {\n\t\trc := config.Config{\n\t\t\tShardID:      1,\n\t\t\tReplicaID:    1,\n\t\t\tElectionRTT:  3,\n\t\t\tHeartbeatRTT: 1,\n\t\t\tCheckQuorum:  true,\n\t\t}\n\t\tpeers := make(map[uint64]string)\n\t\tpeers[1] = nodeHostTestAddr1\n\t\tdir := fs.PathJoin(singleNodeHostTestDir, \"nh1\")\n\t\tnhc1 := config.NodeHostConfig{\n\t\t\tNodeHostDir:    dir,\n\t\t\tRTTMillisecond: getRTTMillisecond(fs, dir),\n\t\t\tRaftAddress:    nodeHostTestAddr1,\n\t\t\tExpert:         getTestExpertConfig(fs),\n\t\t}\n\t\tnh1, err := NewNodeHost(nhc1)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to create node host %v\", err)\n\t\t}\n\t\tdefer nh1.Close()\n\t\tnewSM := func(uint64, uint64) sm.IOnDiskStateMachine {\n\t\t\treturn tests.NewSimDiskSM(0)\n\t\t}\n\t\tif err := nh1.StartOnDiskReplica(peers, false, newSM, rc); err != nil {\n\t\t\tt.Fatalf(\"failed to start shard %v\", err)\n\t\t}\n\t\twaitForLeaderToBeElected(t, nh1, 1)\n\t\tfor i := 0; i < 8; i++ {\n\t\t\tmakeProposals(nh1)\n\t\t\tpto := lpto(nh1)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\topt := SnapshotOption{OverrideCompactionOverhead: true, CompactionOverhead: 1}\n\t\t\tif _, err := nh1.SyncRequestSnapshot(ctx, 1, opt); err != nil {\n\t\t\t\tt.Fatalf(\"failed to request snapshot %v\", err)\n\t\t\t}\n\t\t\tcancel()\n\t\t}\n\t\tpto := pto(nh1)\n\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\tif err := nh1.SyncRequestAddWitness(ctx, 1, 2, nodeHostTestAddr2, 0); err != nil {\n\t\t\tt.Fatalf(\"failed to add witness %v\", err)\n\t\t}\n\t\tcancel()\n\t\trc2 := rc\n\t\trc2.ReplicaID = 2\n\t\trc2.IsWitness = true\n\t\tnhc2 := nhc1\n\t\tnhc2.RaftAddress = nodeHostTestAddr2\n\t\tnhc2.NodeHostDir = fs.PathJoin(singleNodeHostTestDir, \"nh2\")\n\t\tnh2, err := NewNodeHost(nhc2)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to create node host %v\", err)\n\t\t}\n\t\tdefer nh2.Close()\n\t\twitness := tests.NewSimDiskSM(0)\n\t\tnewWitness := func(uint64, uint64) sm.IOnDiskStateMachine {\n\t\t\treturn witness\n\t\t}\n\t\tif err := nh2.StartOnDiskReplica(nil, true, newWitness, rc2); err != nil {\n\t\t\tt.Fatalf(\"failed to start shard %v\", err)\n\t\t}\n\t\twaitForLeaderToBeElected(t, nh2, 1)\n\t\twitnessTestFunc(nh1, nh2, witness)\n\t}\n\trunNodeHostTestDC(t, tf, true, fs)\n}\n\nfunc TestWitnessSnapshotIsCorrectlyHandled(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\ttf := func(nh1 *NodeHost, nh2 *NodeHost, witness *tests.SimDiskSM) {\n\t\tfor {\n\t\t\tif witness.GetRecovered() > 0 {\n\t\t\t\tt.Fatalf(\"unexpected recovered count %d\", witness.GetRecovered())\n\t\t\t}\n\t\t\tsnapshot, err := nh2.mu.logdb.GetSnapshot(1, 2)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%v\", err)\n\t\t\t}\n\t\t\tif pb.IsEmptySnapshot(snapshot) {\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t} else {\n\t\t\t\tif !snapshot.Witness {\n\t\t\t\t\tt.Errorf(\"not a witness snapshot\")\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\ttestWitnessIO(t, tf, fs)\n}\n\nfunc TestWitnessCanReplicateEntries(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\ttf := func(nh1 *NodeHost, nh2 *NodeHost, witness *tests.SimDiskSM) {\n\t\tfor i := 0; i < 8; i++ {\n\t\t\tmakeProposals(nh1)\n\t\t}\n\t\tif witness.GetApplied() > 0 {\n\t\t\tt.Fatalf(\"unexpected applied count %d\", witness.GetApplied())\n\t\t}\n\t}\n\ttestWitnessIO(t, tf, fs)\n}\n\nfunc TestWitnessCanNotInitiateIORequest(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\ttf := func(nh1 *NodeHost, nh2 *NodeHost, witness *tests.SimDiskSM) {\n\t\tpto := lpto(nh1)\n\t\topt := SnapshotOption{OverrideCompactionOverhead: true, CompactionOverhead: 1}\n\t\tif _, err := nh2.RequestSnapshot(1, opt, pto); err != ErrInvalidOperation {\n\t\t\tt.Fatalf(\"requesting snapshot on witness not rejected\")\n\t\t}\n\t\tsession := nh2.GetNoOPSession(1)\n\t\tif _, err := nh2.Propose(session, []byte(\"test-data\"), pto); err != ErrInvalidOperation {\n\t\t\tt.Fatalf(\"proposal not rejected on witness\")\n\t\t}\n\t\tsession = client.NewSession(1, nh2.env.GetRandomSource())\n\t\tsession.PrepareForRegister()\n\t\tif _, err := nh2.ProposeSession(session, pto); err != ErrInvalidOperation {\n\t\t\tt.Fatalf(\"propose session not rejected on witness\")\n\t\t}\n\t\tif _, err := nh2.ReadIndex(1, pto); err != ErrInvalidOperation {\n\t\t\tt.Fatalf(\"sync read not rejected on witness\")\n\t\t}\n\t\tif _, err := nh2.RequestAddReplica(1, 3, \"a3.com:12345\", 0, pto); err != ErrInvalidOperation {\n\t\t\tt.Fatalf(\"add node not rejected on witness\")\n\t\t}\n\t\tif _, err := nh2.RequestDeleteReplica(1, 3, 0, pto); err != ErrInvalidOperation {\n\t\t\tt.Fatalf(\"delete node not rejected on witness\")\n\t\t}\n\t\tif _, err := nh2.RequestAddNonVoting(1, 3, \"a3.com:12345\", 0, pto); err != ErrInvalidOperation {\n\t\t\tt.Fatalf(\"add nonVoting not rejected on witness\")\n\t\t}\n\t\tif _, err := nh2.RequestAddWitness(1, 3, \"a3.com:12345\", 0, pto); err != ErrInvalidOperation {\n\t\t\tt.Fatalf(\"add witness not rejected on witness\")\n\t\t}\n\t\tif err := nh2.RequestLeaderTransfer(1, 3); err != ErrInvalidOperation {\n\t\t\tt.Fatalf(\"leader transfer not rejected on witness\")\n\t\t}\n\t\tif _, err := nh2.StaleRead(1, nil); err != ErrInvalidOperation {\n\t\t\tt.Fatalf(\"stale read not rejected on witness\")\n\t\t}\n\t}\n\ttestWitnessIO(t, tf, fs)\n}\n\nfunc TestStateMachineIsClosedAfterOffloaded(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\ttsm := &TimeoutStateMachine{}\n\tto := &testOption{\n\t\tcreateSM: func(uint64, uint64) sm.IStateMachine {\n\t\t\treturn tsm\n\t\t},\n\t\tat: func(nh *NodeHost) {\n\t\t\tif !tsm.closed {\n\t\t\t\tt.Fatalf(\"sm not closed\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestTimeoutCanBeReturned(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\trtt := getRTTMillisecond(fs, singleNodeHostTestDir)\n\tto := &testOption{\n\t\tcreateSM: func(uint64, uint64) sm.IStateMachine {\n\t\t\treturn &TimeoutStateMachine{\n\t\t\t\tupdateDelay:   rtt * 10,\n\t\t\t\tsnapshotDelay: rtt * 10,\n\t\t\t}\n\t\t},\n\t\ttf: func(nh *NodeHost) {\n\t\t\ttimeout := time.Duration(rtt*5) * time.Millisecond\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\t\t\tsession := nh.GetNoOPSession(1)\n\t\t\t_, err := nh.SyncPropose(ctx, session, []byte(\"test\"))\n\t\t\tcancel()\n\t\t\tif err != ErrTimeout {\n\t\t\t\tt.Errorf(\"failed to return ErrTimeout, %v\", err)\n\t\t\t}\n\t\t\tctx, cancel = context.WithTimeout(context.Background(), timeout)\n\t\t\t_, err = nh.SyncRequestSnapshot(ctx, 1, SnapshotOption{})\n\t\t\tcancel()\n\t\t\tif err != ErrTimeout {\n\t\t\t\tt.Errorf(\"failed to return ErrTimeout, %v\", err)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc testIOErrorIsHandled(t *testing.T, op vfs.Op) {\n\tinj := vfs.OnIndex(-1, op)\n\tfs := vfs.Wrap(vfs.GetTestFS(), inj)\n\tto := &testOption{\n\t\tfsErrorInjection: true,\n\t\tdefaultTestNode:  true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tif nh.mu.logdb.Name() == \"Tan\" {\n\t\t\t\tt.Skip(\"skipped, using tan logdb\")\n\t\t\t}\n\t\t\tinj.SetIndex(0)\n\t\t\tpto := pto(nh)\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), pto)\n\t\t\tsession := nh.GetNoOPSession(1)\n\t\t\t_, err := nh.SyncPropose(ctx, session, []byte(\"test\"))\n\t\t\tcancel()\n\t\t\tif err != ErrTimeout {\n\t\t\t\tt.Fatalf(\"proposal unexpectedly completed, %v\", err)\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase e := <-nh.engine.ec:\n\t\t\t\tif e != vfs.ErrInjected && e.Error() != vfs.ErrInjected.Error() {\n\t\t\t\t\tt.Fatalf(\"failed to return the expected error, %v\", e)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tt.Fatalf(\"failed to trigger error\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestIOErrorIsHandled(t *testing.T) {\n\ttestIOErrorIsHandled(t, vfs.OpWrite)\n\ttestIOErrorIsHandled(t, vfs.OpSync)\n}\n\nfunc TestInstallSnapshotMessageIsNeverDropped(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tnh.partitioned = 1\n\t\t\thandler := newNodeHostMessageHandler(nh)\n\t\t\tmsg := pb.Message{Type: pb.InstallSnapshot, ShardID: 1, To: 1}\n\t\t\tbatch := pb.MessageBatch{Requests: []pb.Message{msg}}\n\t\t\ts, m := handler.HandleMessageBatch(batch)\n\t\t\tif s != 1 {\n\t\t\t\tt.Errorf(\"snapshot message dropped, %d\", s)\n\t\t\t}\n\t\t\tif m != 0 {\n\t\t\t\tt.Errorf(\"unexpected message count %d\", m)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestMessageToUnknownNodeIsIgnored(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\thandler := newNodeHostMessageHandler(nh)\n\t\t\tmsg1 := pb.Message{Type: pb.Ping, ShardID: 1, To: 1}\n\t\t\tmsg2 := pb.Message{Type: pb.Pong, ShardID: 1, To: 1}\n\t\t\tmsg3 := pb.Message{Type: pb.Pong, ShardID: 1, To: 2}\n\t\t\tbatch := pb.MessageBatch{Requests: []pb.Message{msg1, msg2, msg3}}\n\t\t\ts, m := handler.HandleMessageBatch(batch)\n\t\t\tif s != 0 {\n\t\t\t\tt.Errorf(\"unexpected snapshot count, %d\", s)\n\t\t\t}\n\t\t\tif m != 2 {\n\t\t\t\tt.Errorf(\"unexpected message count %d\", m)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestNodeCanBeUnloadedOnceClosed(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tcountNodes := func(nh *NodeHost) uint64 {\n\t\t\t\tcount := uint64(0)\n\t\t\t\tnh.mu.shards.Range(func(key, value interface{}) bool {\n\t\t\t\t\tcount++\n\t\t\t\t\treturn true\n\t\t\t\t})\n\t\t\t\treturn count\n\t\t\t}\n\t\t\tnode, ok := nh.getShard(1)\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"failed to get node\")\n\t\t\t}\n\t\t\tnode.requestRemoval()\n\t\t\tretry := 1000\n\t\t\tfor retry > 0 {\n\t\t\t\tretry--\n\t\t\t\tif countNodes(nh) == 0 {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t}\n\t\t\tt.Fatalf(\"failed to unload the node\")\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestUsingClosedNodeHostIsNotAllowed(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\tat: func(nh *NodeHost) {\n\t\t\tplog.Infof(\"hello\")\n\t\t\tif err := nh.StartReplica(nil, false, nil, config.Config{}); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif err := nh.StartConcurrentReplica(nil, false, nil, config.Config{}); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif err := nh.StartOnDiskReplica(nil, false, nil, config.Config{}); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif err := nh.StopShard(1); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif err := nh.StopReplica(1, 1); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Second)\n\t\t\tdefer cancel()\n\t\t\tif _, err := nh.SyncPropose(ctx, nil, nil); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif _, err := nh.SyncRead(ctx, 1, nil); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif _, err := nh.SyncGetShardMembership(ctx, 1); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif _, _, _, err := nh.GetLeaderID(1); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif _, err := nh.Propose(nil, nil, time.Second); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif _, err := nh.ReadIndex(1, time.Second); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif _, err := nh.ReadLocalNode(nil, nil); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif _, err := nh.NAReadLocalNode(nil, nil); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif _, err := nh.StaleRead(1, nil); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif _, err := nh.SyncRequestSnapshot(ctx, 1, DefaultSnapshotOption); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif _, err := nh.RequestSnapshot(1, DefaultSnapshotOption, time.Second); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif _, err := nh.RequestCompaction(1, 1); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif err := nh.SyncRequestDeleteReplica(ctx, 1, 1, 0); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif err := nh.SyncRequestAddReplica(ctx, 1, 1, \"\", 0); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif err := nh.SyncRequestAddNonVoting(ctx, 1, 1, \"\", 0); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif err := nh.SyncRequestAddWitness(ctx, 1, 1, \"\", 0); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif _, err := nh.RequestDeleteReplica(1, 1, 0, time.Second); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif _, err := nh.RequestAddReplica(1, 1, \"\", 0, time.Second); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif _, err := nh.RequestAddNonVoting(1, 1, \"\", 0, time.Second); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif _, err := nh.RequestAddWitness(1, 1, \"\", 0, time.Second); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif err := nh.RequestLeaderTransfer(1, 2); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif err := nh.SyncRemoveData(ctx, 1, 1); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif err := nh.RemoveData(1, 1); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif _, err := nh.GetNodeUser(1); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t\tif _, err := nh.QueryRaftLog(1, 1, 2, 100); err != ErrClosed {\n\t\t\t\tt.Errorf(\"failed to return ErrClosed\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestContextDeadlineIsChecked(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tctx := context.Background()\n\t\t\tif _, err := nh.SyncPropose(ctx, nil, nil); err != ErrDeadlineNotSet {\n\t\t\t\tt.Errorf(\"ctx deadline not checked\")\n\t\t\t}\n\t\t\tif _, err := nh.SyncRead(ctx, 1, nil); err != ErrDeadlineNotSet {\n\t\t\t\tt.Errorf(\"ctx deadline not checked\")\n\t\t\t}\n\t\t\tif _, err := nh.SyncGetShardMembership(ctx, 1); err != ErrDeadlineNotSet {\n\t\t\t\tt.Errorf(\"ctx deadline not checked\")\n\t\t\t}\n\t\t\tif err := nh.SyncCloseSession(ctx, nil); err != ErrDeadlineNotSet {\n\t\t\t\tt.Errorf(\"ctx deadline not checked\")\n\t\t\t}\n\t\t\tif _, err := nh.SyncGetSession(ctx, 1); err != ErrDeadlineNotSet {\n\t\t\t\tt.Errorf(\"ctx deadline not checked\")\n\t\t\t}\n\t\t\tif err := nh.SyncCloseSession(ctx, nil); err != ErrDeadlineNotSet {\n\t\t\t\tt.Errorf(\"ctx deadline not checked\")\n\t\t\t}\n\t\t\tif _, err := nh.SyncRequestSnapshot(ctx, 1, DefaultSnapshotOption); err != ErrDeadlineNotSet {\n\t\t\t\tt.Errorf(\"ctx deadline not checked\")\n\t\t\t}\n\t\t\tif err := nh.SyncRequestDeleteReplica(ctx, 1, 1, 0); err != ErrDeadlineNotSet {\n\t\t\t\tt.Errorf(\"ctx deadline not checked\")\n\t\t\t}\n\t\t\tif err := nh.SyncRequestAddReplica(ctx, 1, 2, \"\", 0); err != ErrDeadlineNotSet {\n\t\t\t\tt.Errorf(\"ctx deadline not checked\")\n\t\t\t}\n\t\t\tif err := nh.SyncRequestAddNonVoting(ctx, 1, 2, \"\", 0); err != ErrDeadlineNotSet {\n\t\t\t\tt.Errorf(\"ctx deadline not checked\")\n\t\t\t}\n\t\t\tif err := nh.SyncRequestAddWitness(ctx, 1, 2, \"\", 0); err != ErrDeadlineNotSet {\n\t\t\t\tt.Errorf(\"ctx deadline not checked\")\n\t\t\t}\n\t\t\tif err := nh.SyncRemoveData(ctx, 1, 1); err != ErrDeadlineNotSet {\n\t\t\t\tt.Errorf(\"ctx deadline not checked\")\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestGetTimeoutFromContext(t *testing.T) {\n\tdefer leaktest.AfterTest(t)()\n\tif _, err := getTimeoutFromContext(context.Background()); err != ErrDeadlineNotSet {\n\t\tt.Errorf(\"failed to return ErrDeadlineNotSet, %v\", err)\n\t}\n\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\tdefer cancel()\n\td, err := getTimeoutFromContext(ctx)\n\tif err != nil {\n\t\tt.Errorf(\"failed to get timeout, %v\", err)\n\t}\n\tif d < 55*time.Second {\n\t\tt.Errorf(\"unexpected result\")\n\t}\n}\n\nfunc TestHandleSnapshotStatus(t *testing.T) {\n\tdefer leaktest.AfterTest(t)()\n\tnh := &NodeHost{stopper: syncutil.NewStopper()}\n\tengine := newExecEngine(nh, config.GetDefaultEngineConfig(), false, false, nil, nil)\n\tdefer func() {\n\t\tif err := engine.close(); err != nil {\n\t\t\tt.Fatalf(\"failed to close engine %v\", err)\n\t\t}\n\t}()\n\tnh.engine = engine\n\tnh.events.sys = newSysEventListener(nil, nh.stopper.ShouldStop())\n\th := messageHandler{nh: nh}\n\tmq := server.NewMessageQueue(1024, false, lazyFreeCycle, 1024)\n\tnode := &node{shardID: 1, replicaID: 1, mq: mq}\n\th.nh.mu.shards.Store(uint64(1), node)\n\th.HandleSnapshotStatus(1, 2, true)\n\tfor i := uint64(0); i <= streamPushDelayTick; i++ {\n\t\tnode.mq.Tick()\n\t}\n\tmsgs := node.mq.Get()\n\tif len(msgs) != 1 {\n\t\tt.Fatalf(\"no msg\")\n\t}\n\tif msgs[0].Type != pb.SnapshotStatus || !msgs[0].Reject {\n\t\tt.Fatalf(\"unexpected message\")\n\t}\n}\n\nfunc TestSnapshotReceivedMessageCanBeConverted(t *testing.T) {\n\tdefer leaktest.AfterTest(t)()\n\tnh := &NodeHost{stopper: syncutil.NewStopper()}\n\tengine := newExecEngine(nh, config.GetDefaultEngineConfig(), false, false, nil, nil)\n\tdefer func() {\n\t\tif err := engine.close(); err != nil {\n\t\t\tt.Fatalf(\"failed to close engine %v\", err)\n\t\t}\n\t}()\n\tnh.engine = engine\n\tnh.events.sys = newSysEventListener(nil, nh.stopper.ShouldStop())\n\th := messageHandler{nh: nh}\n\tmq := server.NewMessageQueue(1024, false, lazyFreeCycle, 1024)\n\tnode := &node{shardID: 1, replicaID: 1, mq: mq}\n\th.nh.mu.shards.Store(uint64(1), node)\n\tmb := pb.MessageBatch{\n\t\tRequests: []pb.Message{{To: 1, From: 2, ShardID: 1, Type: pb.SnapshotReceived}},\n\t}\n\tsc, mc := h.HandleMessageBatch(mb)\n\tif sc != 0 || mc != 1 {\n\t\tt.Errorf(\"failed to handle message batch\")\n\t}\n\tfor i := uint64(0); i <= streamConfirmedDelayTick; i++ {\n\t\tnode.mq.Tick()\n\t}\n\tmsgs := node.mq.Get()\n\tif len(msgs) != 1 {\n\t\tt.Fatalf(\"no msg\")\n\t}\n\tif msgs[0].Type != pb.SnapshotStatus || msgs[0].Reject {\n\t\tt.Fatalf(\"unexpected message\")\n\t}\n}\n\nfunc TestIncorrectlyRoutedMessagesAreIgnored(t *testing.T) {\n\tdefer leaktest.AfterTest(t)()\n\tnh := &NodeHost{stopper: syncutil.NewStopper()}\n\tengine := newExecEngine(nh, config.GetDefaultEngineConfig(), false, false, nil, nil)\n\tdefer func() {\n\t\tif err := engine.close(); err != nil {\n\t\t\tt.Fatalf(\"failed to close engine %v\", err)\n\t\t}\n\t}()\n\tnh.engine = engine\n\tnh.events.sys = newSysEventListener(nil, nh.stopper.ShouldStop())\n\th := messageHandler{nh: nh}\n\tmq := server.NewMessageQueue(1024, false, lazyFreeCycle, 1024)\n\tnode := &node{shardID: 1, replicaID: 1, mq: mq}\n\th.nh.mu.shards.Store(uint64(1), node)\n\tmb := pb.MessageBatch{\n\t\tRequests: []pb.Message{{To: 3, From: 2, ShardID: 1, Type: pb.SnapshotReceived}},\n\t}\n\tsc, mc := h.HandleMessageBatch(mb)\n\tif sc != 0 || mc != 0 {\n\t\tt.Errorf(\"failed to ignore the message\")\n\t}\n\tmsgs := node.mq.Get()\n\tif len(msgs) != 0 {\n\t\tt.Fatalf(\"received unexpected message\")\n\t}\n}\n\nfunc TestProposeOnClosedNode(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tu, err := nh.GetNodeUser(1)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to get node, %v\", err)\n\t\t\t}\n\t\t\tif err := nh.StopReplica(1, 1); err != nil {\n\t\t\t\tt.Fatalf(\"failed to stop node, %v\", err)\n\t\t\t}\n\t\t\tcs := nh.GetNoOPSession(1)\n\t\t\tif _, err := u.Propose(cs, nil, time.Second); err == nil {\n\t\t\t\tt.Errorf(\"propose on closed node didn't cause error\")\n\t\t\t} else {\n\t\t\t\tplog.Infof(\"%v returned from closed node\", err)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestReadIndexOnClosedNode(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tu, err := nh.GetNodeUser(1)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to get node, %v\", err)\n\t\t\t}\n\t\t\tif err := nh.StopReplica(1, 1); err != nil {\n\t\t\t\tt.Fatalf(\"failed to stop node, %v\", err)\n\t\t\t}\n\t\t\tif _, err := u.ReadIndex(time.Second); err == nil {\n\t\t\t\tt.Errorf(\"ReadIndex on closed node didn't cause error\")\n\t\t\t} else {\n\t\t\t\tplog.Infof(\"%v returned from closed node\", err)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestNodeCanNotStartWhenStillLoadedInEngine(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tnodes := make(map[uint64]*node)\n\t\t\tnodes[2] = &node{shardID: 2, replicaID: 1}\n\t\t\tnh.engine.loaded.update(1, fromStepWorker, nodes)\n\t\t\tif err := nh.startShard(nil, false, nil,\n\t\t\t\tconfig.Config{ShardID: 2, ReplicaID: 1},\n\t\t\t\tpb.RegularStateMachine); err != ErrShardAlreadyExist {\n\t\t\t\tt.Errorf(\"failed to return ErrShardAlreadyExist, %v\", err)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\nfunc TestBootstrapInfoIsValidated(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tto := &testOption{\n\t\tdefaultTestNode: true,\n\t\ttf: func(nh *NodeHost) {\n\t\t\tif _, _, err := nh.bootstrapShard(nil, false,\n\t\t\t\tconfig.Config{ShardID: 1, ReplicaID: 1},\n\t\t\t\tpb.OnDiskStateMachine); err != ErrInvalidShardSettings {\n\t\t\t\tt.Errorf(\"failed to fail the boostrap, %v\", err)\n\t\t\t}\n\t\t},\n\t}\n\trunNodeHostTest(t, to, fs)\n}\n\n// slow tests\n\ntype stressRSM struct{}\n\nfunc (s *stressRSM) Update(sm.Entry) (sm.Result, error) {\n\tplog.Infof(\"updated\")\n\treturn sm.Result{}, nil\n}\n\nfunc (s *stressRSM) Lookup(interface{}) (interface{}, error) {\n\treturn nil, nil\n}\n\nfunc (s *stressRSM) SaveSnapshot(w io.Writer,\n\tf sm.ISnapshotFileCollection, c <-chan struct{}) error {\n\tdata := make([]byte, settings.SnapshotChunkSize*3)\n\t_, err := w.Write(data)\n\treturn err\n}\n\nfunc (s *stressRSM) RecoverFromSnapshot(r io.Reader,\n\tf []sm.SnapshotFile, c <-chan struct{}) error {\n\tplog.Infof(\"RecoverFromSnapshot called\")\n\tdata := make([]byte, settings.SnapshotChunkSize*3)\n\tn, err := io.ReadFull(r, data)\n\tif uint64(n) != settings.SnapshotChunkSize*3 {\n\t\treturn errors.New(\"unexpected size\")\n\t}\n\treturn err\n}\n\nfunc (s *stressRSM) Close() error {\n\treturn nil\n}\n\n// this test takes around 6 minutes on mbp and 30 seconds on a linux box with\n// proper SSD\nfunc TestSlowTestStressedSnapshotWorker(t *testing.T) {\n\tif len(os.Getenv(\"SLOW_TEST\")) == 0 {\n\t\tt.Skip(\"skipped TestSlowTestStressedSnapshotWorker, SLOW_TEST not set\")\n\t}\n\tfs := vfs.GetTestFS()\n\tif err := fs.RemoveAll(singleNodeHostTestDir); err != nil {\n\t\tt.Fatalf(\"%v\", err)\n\t}\n\tdefer func() {\n\t\tif err := fs.RemoveAll(singleNodeHostTestDir); err != nil {\n\t\t\tt.Fatalf(\"%v\", err)\n\t\t}\n\t}()\n\tnh1dir := fs.PathJoin(singleNodeHostTestDir, \"nh1\")\n\tnh2dir := fs.PathJoin(singleNodeHostTestDir, \"nh2\")\n\trc := config.Config{\n\t\tShardID:            1,\n\t\tReplicaID:          1,\n\t\tElectionRTT:        10,\n\t\tHeartbeatRTT:       1,\n\t\tCheckQuorum:        true,\n\t\tSnapshotEntries:    5,\n\t\tCompactionOverhead: 1,\n\t}\n\tpeers := make(map[uint64]string)\n\tpeers[1] = nodeHostTestAddr1\n\tnhc1 := config.NodeHostConfig{\n\t\tWALDir:         nh1dir,\n\t\tNodeHostDir:    nh1dir,\n\t\tRTTMillisecond: 5 * getRTTMillisecond(fs, nh1dir),\n\t\tRaftAddress:    nodeHostTestAddr1,\n\t\tExpert:         getTestExpertConfig(fs),\n\t}\n\tnh1, err := NewNodeHost(nhc1)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create node host %v\", err)\n\t}\n\tdefer nh1.Close()\n\tnewRSM := func(uint64, uint64) sm.IStateMachine {\n\t\treturn &stressRSM{}\n\t}\n\tfor i := uint64(1); i <= uint64(96); i++ {\n\t\trc.ShardID = i\n\t\tif err := nh1.StartReplica(peers, false, newRSM, rc); err != nil {\n\t\t\tt.Fatalf(\"failed to start shard %v\", err)\n\t\t}\n\t\tcs := nh1.GetNoOPSession(i)\n\t\ttotal := 20\n\t\tfor {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n\t\t\t_, err := nh1.SyncPropose(ctx, cs, make([]byte, 1))\n\t\t\tcancel()\n\t\t\tif err == ErrTimeout || err == ErrShardNotReady {\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttotal--\n\t\t\tif total == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\t// add another node\n\tfor i := uint64(1); i <= uint64(96); i++ {\n\t\tfor {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n\t\t\terr := nh1.SyncRequestAddReplica(ctx, i, 2, nodeHostTestAddr2, 0)\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tif err == ErrTimeout || err == ErrShardNotReady {\n\t\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\tt.Fatalf(\"failed to add node %v\", err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tplog.Infof(\"all nodes added\")\n\tnhc2 := config.NodeHostConfig{\n\t\tWALDir:         nh2dir,\n\t\tNodeHostDir:    nh2dir,\n\t\tRTTMillisecond: 5 * getRTTMillisecond(fs, nh2dir),\n\t\tRaftAddress:    nodeHostTestAddr2,\n\t\tExpert:         getTestExpertConfig(fs),\n\t}\n\tnh2, err := NewNodeHost(nhc2)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create node host 2 %v\", err)\n\t}\n\t// start new nodes\n\tdefer nh2.Close()\n\tfor i := uint64(1); i <= uint64(96); i++ {\n\t\trc.ShardID = i\n\t\trc.ReplicaID = 2\n\t\tpeers := make(map[uint64]string)\n\t\tif err := nh2.StartReplica(peers, true, newRSM, rc); err != nil {\n\t\t\tt.Fatalf(\"failed to start shard %v\", err)\n\t\t}\n\t}\n\tfor i := uint64(1); i <= uint64(96); i++ {\n\t\tcs := nh2.GetNoOPSession(i)\n\t\ttotal := 1000\n\t\tfor {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n\t\t\t_, err := nh2.SyncPropose(ctx, cs, make([]byte, 1))\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tif err == ErrTimeout || err == ErrShardNotReady {\n\t\t\t\t\ttotal--\n\t\t\t\t\tif total == 0 {\n\t\t\t\t\t\tt.Fatalf(\"failed to make proposal on shard %d\", i)\n\t\t\t\t\t}\n\t\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\tt.Fatalf(\"failed to make proposal %v\", err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "plugin",
          "type": "tree",
          "content": null
        },
        {
          "name": "queue.go",
          "type": "blob",
          "size": 4.7177734375,
          "content": "// Copyright 2017-2021 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dragonboat\n\nimport (\n\t\"sync\"\n\n\t\"github.com/lni/dragonboat/v4/raftio\"\n\tpb \"github.com/lni/dragonboat/v4/raftpb\"\n)\n\ntype entryQueue struct {\n\tsize          uint64\n\tleft          []pb.Entry\n\tright         []pb.Entry\n\tleftInWrite   bool\n\tstopped       bool\n\tpaused        bool\n\tidx           uint64\n\toldIdx        uint64\n\tcycle         uint64\n\tlazyFreeCycle uint64\n\tmu            sync.Mutex\n}\n\nfunc newEntryQueue(size uint64, lazyFreeCycle uint64) *entryQueue {\n\treturn &entryQueue{\n\t\tsize:          size,\n\t\tlazyFreeCycle: lazyFreeCycle,\n\t\tleft:          make([]pb.Entry, size),\n\t\tright:         make([]pb.Entry, size),\n\t}\n}\n\nfunc (q *entryQueue) close() {\n\tq.mu.Lock()\n\tdefer q.mu.Unlock()\n\tq.stopped = true\n}\n\nfunc (q *entryQueue) targetQueue() []pb.Entry {\n\tif q.leftInWrite {\n\t\treturn q.left\n\t}\n\treturn q.right\n}\n\nfunc (q *entryQueue) add(ent pb.Entry) (bool, bool) {\n\tq.mu.Lock()\n\tdefer q.mu.Unlock()\n\tif q.paused || q.idx >= q.size {\n\t\treturn false, q.stopped\n\t}\n\tif q.stopped {\n\t\treturn false, true\n\t}\n\tw := q.targetQueue()\n\tw[q.idx] = ent\n\tq.idx++\n\treturn true, false\n}\n\nfunc (q *entryQueue) gc() {\n\tif q.lazyFreeCycle > 0 {\n\t\toldq := q.targetQueue()\n\t\tif q.lazyFreeCycle == 1 {\n\t\t\tfor i := uint64(0); i < q.oldIdx; i++ {\n\t\t\t\toldq[i].Cmd = nil\n\t\t\t}\n\t\t} else if q.cycle%q.lazyFreeCycle == 0 {\n\t\t\tfor i := uint64(0); i < q.size; i++ {\n\t\t\t\toldq[i].Cmd = nil\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (q *entryQueue) get(paused bool) []pb.Entry {\n\tq.mu.Lock()\n\tdefer q.mu.Unlock()\n\tq.paused = paused\n\tq.cycle++\n\tsz := q.idx\n\tq.idx = 0\n\tt := q.targetQueue()\n\tq.leftInWrite = !q.leftInWrite\n\tq.gc()\n\tq.oldIdx = sz\n\treturn t[:sz]\n}\n\ntype readIndexQueue struct {\n\tsize        uint64\n\tleft        []*RequestState\n\tright       []*RequestState\n\tleftInWrite bool\n\tstopped     bool\n\tidx         uint64\n\tmu          sync.Mutex\n}\n\nfunc newReadIndexQueue(size uint64) *readIndexQueue {\n\treturn &readIndexQueue{\n\t\tsize:  size,\n\t\tleft:  make([]*RequestState, size),\n\t\tright: make([]*RequestState, size),\n\t}\n}\n\nfunc (q *readIndexQueue) pendingSize() uint64 {\n\tq.mu.Lock()\n\tdefer q.mu.Unlock()\n\treturn q.idx\n}\n\nfunc (q *readIndexQueue) close() {\n\tq.mu.Lock()\n\tdefer q.mu.Unlock()\n\tq.stopped = true\n}\n\nfunc (q *readIndexQueue) targetQueue() []*RequestState {\n\tif q.leftInWrite {\n\t\treturn q.left\n\t}\n\treturn q.right\n}\n\nfunc (q *readIndexQueue) add(rs *RequestState) (bool, bool) {\n\tq.mu.Lock()\n\tdefer q.mu.Unlock()\n\tif q.idx >= q.size {\n\t\treturn false, q.stopped\n\t}\n\tif q.stopped {\n\t\treturn false, true\n\t}\n\tw := q.targetQueue()\n\tw[q.idx] = rs\n\tq.idx++\n\treturn true, false\n}\n\nfunc (q *readIndexQueue) get() []*RequestState {\n\tq.mu.Lock()\n\tdefer q.mu.Unlock()\n\tsz := q.idx\n\tq.idx = 0\n\tt := q.targetQueue()\n\tq.leftInWrite = !q.leftInWrite\n\treturn t[:sz]\n}\n\ntype readyShard struct {\n\tmu    sync.Mutex\n\tready map[uint64]struct{}\n\tmaps  [2]map[uint64]struct{}\n\tindex uint8\n}\n\nfunc newReadyShard() *readyShard {\n\tr := &readyShard{}\n\tr.maps[0] = make(map[uint64]struct{})\n\tr.maps[1] = make(map[uint64]struct{})\n\tr.ready = r.maps[0]\n\treturn r\n}\n\nfunc (r *readyShard) setShardReady(shardID uint64) {\n\tr.mu.Lock()\n\tr.ready[shardID] = struct{}{}\n\tr.mu.Unlock()\n}\n\nfunc (r *readyShard) getReadyShards() map[uint64]struct{} {\n\tm := r.maps[(r.index+1)%2]\n\tfor k := range m {\n\t\tdelete(m, k)\n\t}\n\tr.mu.Lock()\n\tv := r.ready\n\tr.index++\n\tr.ready = r.maps[r.index%2]\n\tr.mu.Unlock()\n\treturn v\n}\n\ntype leaderInfoQueue struct {\n\tmu            sync.Mutex\n\tnotifications []raftio.LeaderInfo\n\tworkCh        chan struct{}\n}\n\nfunc newLeaderInfoQueue() *leaderInfoQueue {\n\treturn &leaderInfoQueue{\n\t\tworkCh:        make(chan struct{}, 1),\n\t\tnotifications: make([]raftio.LeaderInfo, 0),\n\t}\n}\n\nfunc (li *leaderInfoQueue) workReady() chan struct{} {\n\treturn li.workCh\n}\n\nfunc (li *leaderInfoQueue) addLeaderInfo(info raftio.LeaderInfo) {\n\tfunc() {\n\t\tli.mu.Lock()\n\t\tdefer li.mu.Unlock()\n\t\tli.notifications = append(li.notifications, info)\n\t}()\n\tselect {\n\tcase li.workCh <- struct{}{}:\n\tdefault:\n\t}\n}\n\nfunc (li *leaderInfoQueue) getLeaderInfo() (raftio.LeaderInfo, bool) {\n\tli.mu.Lock()\n\tdefer li.mu.Unlock()\n\tif len(li.notifications) > 0 {\n\t\tv := li.notifications[0]\n\t\tli.notifications = li.notifications[1:]\n\t\treturn v, true\n\t}\n\treturn raftio.LeaderInfo{}, false\n}\n"
        },
        {
          "name": "queue_test.go",
          "type": "blob",
          "size": 7.8037109375,
          "content": "// Copyright 2017-2020 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dragonboat\n\nimport (\n\t\"testing\"\n\n\t\"github.com/lni/dragonboat/v4/raftio\"\n\t\"github.com/lni/dragonboat/v4/raftpb\"\n)\n\nfunc TestEntryQueueCanBeCreated(t *testing.T) {\n\tq := newEntryQueue(5, 0)\n\tif q.size != 5 || len(q.left) != 5 || len(q.right) != 5 {\n\t\tt.Errorf(\"size unexpected\")\n\t}\n\tif q.idx != 0 {\n\t\tt.Errorf(\"idx %d, want 0\", q.idx)\n\t}\n}\n\nfunc TestLazyFreeCanBeDisabled(t *testing.T) {\n\tq := newEntryQueue(5, 0)\n\tq.add(raftpb.Entry{Cmd: make([]byte, 16)})\n\tq.add(raftpb.Entry{Cmd: make([]byte, 16)})\n\tq.add(raftpb.Entry{Cmd: make([]byte, 16)})\n\tq.get(false)\n\tq.get(false)\n\ttq := q.targetQueue()\n\tfor i := 0; i < 3; i++ {\n\t\tif tq[i].Cmd == nil {\n\t\t\tt.Errorf(\"data unexpectedly freed\")\n\t\t}\n\t}\n}\n\nfunc TestLazyFreeCanBeUsed(t *testing.T) {\n\tq := newEntryQueue(5, 1)\n\tq.add(raftpb.Entry{Cmd: make([]byte, 16)})\n\tq.add(raftpb.Entry{Cmd: make([]byte, 16)})\n\tq.add(raftpb.Entry{Cmd: make([]byte, 16)})\n\tq.get(false)\n\tq.get(false)\n\ttq := q.targetQueue()\n\tfor i := 0; i < 3; i++ {\n\t\tif tq[i].Cmd != nil {\n\t\t\tt.Errorf(\"data unexpectedly not freed\")\n\t\t}\n\t}\n}\n\nfunc TestLazyFreeCycleCanBeSet(t *testing.T) {\n\tq := newEntryQueue(5, 6)\n\tq.add(raftpb.Entry{Cmd: make([]byte, 16)})\n\tq.add(raftpb.Entry{Cmd: make([]byte, 16)})\n\tq.add(raftpb.Entry{Cmd: make([]byte, 16)})\n\tq.get(false)\n\tq.get(false)\n\ttq := q.targetQueue()\n\tfor i := 0; i < 3; i++ {\n\t\tif tq[i].Cmd == nil {\n\t\t\tt.Errorf(\"data unexpectedly freed\")\n\t\t}\n\t}\n\tq.get(false)\n\tq.get(false)\n\ttq = q.targetQueue()\n\tfor i := 0; i < 3; i++ {\n\t\tif tq[i].Cmd == nil {\n\t\t\tt.Errorf(\"data unexpectedly freed\")\n\t\t}\n\t}\n\tq.get(false)\n\tq.get(false)\n\ttq = q.targetQueue()\n\tfor i := 0; i < 3; i++ {\n\t\tif tq[i].Cmd != nil {\n\t\t\tt.Errorf(\"data not freed at the expected cycle\")\n\t\t}\n\t}\n}\n\nfunc TestEntryQueueCanBePaused(t *testing.T) {\n\tq := newEntryQueue(5, 0)\n\tif q.paused {\n\t\tt.Errorf(\"entry queue is paused by default\")\n\t}\n\tfor i := 0; i < 5; i++ {\n\t\tok, stopped := q.add(raftpb.Entry{})\n\t\tif !ok || stopped {\n\t\t\tt.Errorf(\"failed to add new entry\")\n\t\t}\n\t\tif q.stopped {\n\t\t\tt.Errorf(\"stopped too early\")\n\t\t}\n\t}\n\tv := q.get(true)\n\tif len(v) != 5 {\n\t\tt.Errorf(\"failed to get all entries\")\n\t}\n\tif !q.paused {\n\t\tt.Errorf(\"not paused\")\n\t}\n\tok, stopped := q.add(raftpb.Entry{})\n\tif ok {\n\t\tt.Errorf(\"entry added to paused queue\")\n\t}\n\tif stopped {\n\t\tt.Errorf(\"entry queue unexpectedly stopped\")\n\t}\n}\n\nfunc TestEntryQueueCanBeClosed(t *testing.T) {\n\tq := newEntryQueue(5, 0)\n\tif q.stopped {\n\t\tt.Errorf(\"entry queue is stopped by default\")\n\t}\n\tfor i := 0; i < 5; i++ {\n\t\tok, stopped := q.add(raftpb.Entry{})\n\t\tif !ok || stopped {\n\t\t\tt.Errorf(\"failed to add new entry\")\n\t\t}\n\t\tif q.stopped {\n\t\t\tt.Errorf(\"stopped too early\")\n\t\t}\n\t}\n\tok, _ := q.add(raftpb.Entry{})\n\tif ok {\n\t\tt.Errorf(\"not expect to add more\")\n\t}\n\tq = newEntryQueue(5, 0)\n\tq.close()\n\tif !q.stopped {\n\t\tt.Errorf(\"entry queue is not marked as stopped\")\n\t}\n\tif q.idx != 0 {\n\t\tt.Errorf(\"idx %d, want 0\", q.idx)\n\t}\n\tok, stopped := q.add(raftpb.Entry{})\n\tif ok {\n\t\tt.Errorf(\"not expect to add more\")\n\t}\n\tif !stopped {\n\t\tt.Errorf(\"stopped flag is not returned\")\n\t}\n}\n\nfunc TestEntryQueueAllowEntriesToBeAdded(t *testing.T) {\n\tq := newEntryQueue(5, 0)\n\tfor i := uint64(0); i < 5; i++ {\n\t\tok, stopped := q.add(raftpb.Entry{Index: i + 1})\n\t\tif !ok || stopped {\n\t\t\tt.Errorf(\"failed to add new entry\")\n\t\t}\n\t\tif q.idx != i+1 {\n\t\t\tt.Errorf(\"idx %d, want %d\", q.idx, i+1)\n\t\t}\n\t\tvar r []raftpb.Entry\n\t\tif q.leftInWrite {\n\t\t\tr = q.left\n\t\t} else {\n\t\t\tr = q.right\n\t\t}\n\t\tif r[i].Index != i+1 {\n\t\t\tt.Errorf(\"index %d, want %d\", r[i].Index, i+1)\n\t\t}\n\t}\n}\n\nfunc TestEntryQueueAllowAddedEntriesToBeReturned(t *testing.T) {\n\tq := newEntryQueue(5, 0)\n\tfor i := 0; i < 3; i++ {\n\t\tok, stopped := q.add(raftpb.Entry{Index: uint64(i + 1)})\n\t\tif !ok || stopped {\n\t\t\tt.Errorf(\"failed to add new entry\")\n\t\t}\n\t}\n\tr := q.get(false)\n\tif len(r) != 3 {\n\t\tt.Errorf(\"len %d, want %d\", len(r), 3)\n\t}\n\tif q.idx != 0 {\n\t\tt.Errorf(\"idx %d, want %d\", q.idx, 0)\n\t}\n\t// check whether we can keep adding entries as long as we keep getting\n\t// previously written entries.\n\texpectedIndex := uint64(1)\n\tq = newEntryQueue(5, 0)\n\tfor i := 0; i < 1000; i++ {\n\t\tok, stopped := q.add(raftpb.Entry{Index: uint64(i + 1)})\n\t\tif !ok || stopped {\n\t\t\tt.Errorf(\"failed to add new entry\")\n\t\t}\n\t\tif q.idx == q.size {\n\t\t\tr := q.get(false)\n\t\t\tif len(r) != 5 {\n\t\t\t\tt.Errorf(\"len %d, want %d\", len(r), 5)\n\t\t\t}\n\t\t\tfor _, e := range r {\n\t\t\t\tif e.Index != expectedIndex {\n\t\t\t\t\tt.Errorf(\"index %d, expected %d\", e.Index, expectedIndex)\n\t\t\t\t}\n\t\t\t\texpectedIndex++\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShardCanBeSetAsReady(t *testing.T) {\n\trc := newReadyShard()\n\tif len(rc.ready) != 0 {\n\t\tt.Errorf(\"ready map not empty\")\n\t}\n\trc.setShardReady(1)\n\trc.setShardReady(2)\n\trc.setShardReady(2)\n\tif len(rc.ready) != 2 {\n\t\tt.Errorf(\"ready map sz %d, want 2\", len(rc.ready))\n\t}\n\t_, ok := rc.ready[1]\n\tif !ok {\n\t\tt.Errorf(\"shard 1 not set as ready\")\n\t}\n\t_, ok = rc.ready[2]\n\tif !ok {\n\t\tt.Errorf(\"shard 2 not set as ready\")\n\t}\n}\n\nfunc TestReadyShardCanBeReturnedAndCleared(t *testing.T) {\n\trc := newReadyShard()\n\tif len(rc.ready) != 0 {\n\t\tt.Errorf(\"ready map not empty\")\n\t}\n\trc.setShardReady(1)\n\trc.setShardReady(2)\n\trc.setShardReady(2)\n\tif len(rc.ready) != 2 {\n\t\tt.Errorf(\"ready map sz %d, want 2\", len(rc.ready))\n\t}\n\tr := rc.getReadyShards()\n\tif len(r) != 2 {\n\t\tt.Errorf(\"ready map sz %d, want 2\", len(r))\n\t}\n\tif len(rc.ready) != 0 {\n\t\tt.Errorf(\"shard ready map not cleared\")\n\t}\n\tr = rc.getReadyShards()\n\tif len(r) != 0 {\n\t\tt.Errorf(\"shard ready map not cleared\")\n\t}\n\trc.setShardReady(4)\n\tr = rc.getReadyShards()\n\tif len(r) != 1 {\n\t\tt.Errorf(\"shard ready not set\")\n\t}\n}\n\nfunc TestLeaderInfoQueueCanBeCreated(t *testing.T) {\n\tq := newLeaderInfoQueue()\n\tif cap(q.workCh) != 1 {\n\t\tt.Errorf(\"unexpected queue cap\")\n\t}\n\tif len(q.workCh) != 0 {\n\t\tt.Errorf(\"unexpected queue length\")\n\t}\n\tif len(q.notifications) != 0 {\n\t\tt.Errorf(\"unexpected notifications length\")\n\t}\n\tch := q.workReady()\n\tif ch == nil {\n\t\tt.Errorf(\"failed to return work ready chan\")\n\t}\n}\n\nfunc TestAddToLeaderInfoQueue(t *testing.T) {\n\tq := newLeaderInfoQueue()\n\tq.addLeaderInfo(raftio.LeaderInfo{})\n\tq.addLeaderInfo(raftio.LeaderInfo{})\n\tif len(q.workCh) != 1 {\n\t\tt.Errorf(\"unexpected workCh len\")\n\t}\n\tif len(q.notifications) != 2 {\n\t\tt.Errorf(\"unexpected notifications len\")\n\t}\n}\n\nfunc TestGetFromLeaderInfoQueue(t *testing.T) {\n\tq := newLeaderInfoQueue()\n\t_, ok := q.getLeaderInfo()\n\tif ok {\n\t\tt.Errorf(\"unexpectedly returned leader info\")\n\t}\n\tv1 := raftio.LeaderInfo{ShardID: 101}\n\tv2 := raftio.LeaderInfo{ShardID: 2002}\n\tq.addLeaderInfo(v1)\n\tq.addLeaderInfo(v2)\n\trv1, ok1 := q.getLeaderInfo()\n\trv2, ok2 := q.getLeaderInfo()\n\t_, ok3 := q.getLeaderInfo()\n\tif !ok1 || rv1.ShardID != v1.ShardID {\n\t\tt.Errorf(\"unexpected result\")\n\t}\n\tif !ok2 || rv2.ShardID != v2.ShardID {\n\t\tt.Errorf(\"unexpected result\")\n\t}\n\tif ok3 {\n\t\tt.Errorf(\"unexpectedly return third reader info rec\")\n\t}\n}\n\nfunc TestReadIndexQueueCanHandleAddFailure(t *testing.T) {\n\tq := newReadIndexQueue(1)\n\tadded, stopped := q.add(&RequestState{})\n\tif !added || stopped {\n\t\tt.Errorf(\"unexpected failure\")\n\t}\n\tadded, stopped = q.add(&RequestState{})\n\tif added {\n\t\tt.Errorf(\"unexpectedly added the rs\")\n\t}\n\tif stopped {\n\t\tt.Errorf(\"unexpectedly reported state as stopped\")\n\t}\n\tq.close()\n\tadded, stopped = q.add(&RequestState{})\n\tif added {\n\t\tt.Errorf(\"unexpectedly added the rs\")\n\t}\n\tif !stopped {\n\t\tt.Errorf(\"failed to report state as stopped\")\n\t}\n\n}\n"
        },
        {
          "name": "quiesce.go",
          "type": "blob",
          "size": 2.7626953125,
          "content": "// Copyright 2017-2020 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dragonboat\n\nimport (\n\t\"sync/atomic\"\n\n\tpb \"github.com/lni/dragonboat/v4/raftpb\"\n)\n\ntype quiesceState struct {\n\tshardID             uint64\n\treplicaID           uint64\n\tcurrentTick         uint64\n\telectionTick        uint64\n\tquiescedSince       uint64\n\tidleSince           uint64\n\texitQuiesceTick     uint64\n\tenabled             bool\n\tnewQuiesceStateFlag uint32\n}\n\nfunc (q *quiesceState) setNewQuiesceStateFlag() {\n\tatomic.StoreUint32(&q.newQuiesceStateFlag, 1)\n}\n\nfunc (q *quiesceState) newQuiesceState() bool {\n\treturn atomic.SwapUint32(&q.newQuiesceStateFlag, 0) == 1\n}\n\nfunc (q *quiesceState) tick() uint64 {\n\tif !q.enabled {\n\t\treturn 0\n\t}\n\tthreshold := q.threshold()\n\tq.currentTick++\n\tif !q.quiesced() {\n\t\tif (q.currentTick - q.idleSince) > threshold {\n\t\t\tq.enterQuiesce()\n\t\t}\n\t}\n\treturn q.currentTick\n}\n\nfunc (q *quiesceState) quiesced() bool {\n\treturn q.enabled && q.quiescedSince > 0\n}\n\nfunc (q *quiesceState) record(msgType pb.MessageType) {\n\tif !q.enabled {\n\t\treturn\n\t}\n\tif msgType == pb.Heartbeat || msgType == pb.HeartbeatResp {\n\t\tif !q.quiesced() {\n\t\t\treturn\n\t\t}\n\t\tif q.newToQuiesce() {\n\t\t\treturn\n\t\t}\n\t}\n\tq.idleSince = q.currentTick\n\tif q.quiesced() {\n\t\tq.exitQuiesce()\n\t\tplog.Infof(\"%s exited from quiesce, msg type %s, current tick %d\",\n\t\t\tdn(q.shardID, q.replicaID), msgType, q.currentTick)\n\t}\n}\n\nfunc (q *quiesceState) threshold() uint64 {\n\treturn q.electionTick * 10\n}\n\nfunc (q *quiesceState) newToQuiesce() bool {\n\tif !q.quiesced() {\n\t\treturn false\n\t}\n\treturn q.currentTick-q.quiescedSince < q.electionTick\n}\n\nfunc (q *quiesceState) justExitedQuiesce() bool {\n\tif q.quiesced() {\n\t\treturn false\n\t}\n\treturn q.currentTick-q.exitQuiesceTick < q.threshold()\n}\n\nfunc (q *quiesceState) tryEnterQuiesce() {\n\tif q.justExitedQuiesce() {\n\t\treturn\n\t}\n\tif !q.quiesced() {\n\t\tplog.Infof(\"%s going to enter quiesce due to quiesce message\",\n\t\t\tdn(q.shardID, q.replicaID))\n\t\tq.enterQuiesce()\n\t}\n}\n\nfunc (q *quiesceState) enterQuiesce() {\n\tq.quiescedSince = q.currentTick\n\tq.idleSince = q.currentTick\n\tq.setNewQuiesceStateFlag()\n\tplog.Infof(\"%s entered quiesce\", dn(q.shardID, q.replicaID))\n}\n\nfunc (q *quiesceState) exitQuiesce() {\n\tq.quiescedSince = 0\n\tq.exitQuiesceTick = q.currentTick\n}\n"
        },
        {
          "name": "quiesce_test.go",
          "type": "blob",
          "size": 3.455078125,
          "content": "// Copyright 2017-2020 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dragonboat\n\nimport (\n\t\"testing\"\n\n\tpb \"github.com/lni/dragonboat/v4/raftpb\"\n)\n\nfunc getTestQuiesce() quiesceState {\n\treturn quiesceState{\n\t\telectionTick: 10,\n\t\tenabled:      true,\n\t}\n}\n\nfunc TestIncreaseTickCanEnterQuiesce(t *testing.T) {\n\tq := getTestQuiesce()\n\tthreshold := q.threshold()\n\ttests := []struct {\n\t\ttick     uint64\n\t\tquiesced bool\n\t}{\n\t\t{threshold / 2, false},\n\t\t{threshold, false},\n\t\t{threshold + 1, true},\n\t}\n\tfor i, tt := range tests {\n\t\tq := getTestQuiesce()\n\t\tfor k := uint64(0); k < tt.tick; k++ {\n\t\t\tq.tick()\n\t\t}\n\t\tif q.quiesced() != tt.quiesced {\n\t\t\tt.Errorf(\"i %d, got %t, want %t\", i, q.quiesced(), tt.quiesced)\n\t\t}\n\t}\n}\n\nfunc TestQuiesceCanBeDisabled(t *testing.T) {\n\tq := getTestQuiesce()\n\tthreshold := q.threshold()\n\ttests := []struct {\n\t\ttick     uint64\n\t\tquiesced bool\n\t}{\n\t\t{threshold / 2, false},\n\t\t{threshold, false},\n\t\t{threshold + 1, false},\n\t}\n\tfor i, tt := range tests {\n\t\tq := getTestQuiesce()\n\t\t// disable it\n\t\tq.enabled = false\n\t\tfor k := uint64(0); k < tt.tick; k++ {\n\t\t\tq.tick()\n\t\t}\n\t\tif q.quiesced() != tt.quiesced {\n\t\t\tt.Errorf(\"i %d, got %t, want %t\", i, q.quiesced(), tt.quiesced)\n\t\t}\n\t}\n}\n\nfunc TestExitFromQuiesceWhenActivityIsRecorded(t *testing.T) {\n\ttests := []pb.MessageType{\n\t\tpb.Replicate,\n\t\tpb.ReplicateResp,\n\t\tpb.RequestVote,\n\t\tpb.RequestVoteResp,\n\t\tpb.InstallSnapshot,\n\t\tpb.Propose,\n\t\tpb.ReadIndex,\n\t\tpb.ConfigChangeEvent,\n\t}\n\tfor i, tt := range tests {\n\t\tq := getTestQuiesce()\n\t\tfor k := uint64(0); k < q.threshold()+1; k++ {\n\t\t\tq.tick()\n\t\t}\n\t\tif !q.quiesced() {\n\t\t\tt.Errorf(\"i %d, got %t, want %t\", i, q.quiesced(), true)\n\t\t}\n\t\tq.record(tt)\n\t\tif q.quiesced() {\n\t\t\tt.Errorf(\"i %d, got %t, want %t\", i, q.quiesced(), false)\n\t\t}\n\t\tif q.idleSince != q.currentTick {\n\t\t\tt.Errorf(\"i %d, q.idleSince %d, want %d\", i, q.idleSince, q.currentTick)\n\t\t}\n\t}\n}\n\nfunc TestMsgHeartbeatWillNotStopEnteringQuiesce(t *testing.T) {\n\tq := getTestQuiesce()\n\tthreshold := q.threshold()\n\ttests := []struct {\n\t\ttick     uint64\n\t\tquiesced bool\n\t}{\n\t\t{threshold / 2, false},\n\t\t{threshold, false},\n\t\t{threshold + 1, true},\n\t}\n\tfor i, tt := range tests {\n\t\tq := getTestQuiesce()\n\t\tfor k := uint64(0); k < tt.tick; k++ {\n\t\t\tq.tick()\n\t\t\tq.record(pb.Heartbeat)\n\t\t}\n\t\tif q.quiesced() != tt.quiesced {\n\t\t\tt.Errorf(\"i %d, got %t, want %t\", i, q.quiesced(), tt.quiesced)\n\t\t}\n\t}\n}\n\nfunc TestWillNotExitFromQuiesceForDelayedMsgHeartbeatMsg(t *testing.T) {\n\tq := getTestQuiesce()\n\tfor k := uint64(0); k < q.threshold()+1; k++ {\n\t\tq.tick()\n\t}\n\tif !q.quiesced() {\n\t\tt.Errorf(\"got %t, want %t\", q.quiesced(), true)\n\t}\n\tif !q.newToQuiesce() {\n\t\tt.Errorf(\"got %t, want %t\", q.newToQuiesce(), true)\n\t}\n\tfor q.newToQuiesce() {\n\t\tq.record(pb.Heartbeat)\n\t\tif !q.quiesced() {\n\t\t\tt.Errorf(\"got %t, want true\", q.quiesced())\n\t\t}\n\t\tq.tick()\n\t}\n\t// no longer considered as recently entered quiesce\n\tq.record(pb.Heartbeat)\n\tif q.quiesced() {\n\t\tt.Errorf(\"got %t, want false\", q.quiesced())\n\t}\n}\n"
        },
        {
          "name": "raftio",
          "type": "tree",
          "content": null
        },
        {
          "name": "raftpb",
          "type": "tree",
          "content": null
        },
        {
          "name": "registry.go",
          "type": "blob",
          "size": 0.875,
          "content": "// Copyright 2017-2022 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dragonboat\n\n// INodeHostRegistry provides APIs for querying data shared between NodeHost\n// instances via gossip.\ntype INodeHostRegistry interface {\n\tNumOfShards() int\n\tGetMeta(nhID string) ([]byte, bool)\n\tGetShardInfo(shardID uint64) (ShardView, bool)\n}\n"
        },
        {
          "name": "request.go",
          "type": "blob",
          "size": 31.400390625,
          "content": "// Copyright 2017-2021 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dragonboat\n\nimport (\n\t\"crypto/sha512\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/cockroachdb/errors\"\n\t\"github.com/lni/goutils/random\"\n\n\t\"github.com/lni/dragonboat/v4/client\"\n\t\"github.com/lni/dragonboat/v4/config\"\n\t\"github.com/lni/dragonboat/v4/internal/fileutil\"\n\t\"github.com/lni/dragonboat/v4/internal/rsm\"\n\t\"github.com/lni/dragonboat/v4/internal/settings\"\n\t\"github.com/lni/dragonboat/v4/logger\"\n\tpb \"github.com/lni/dragonboat/v4/raftpb\"\n\tsm \"github.com/lni/dragonboat/v4/statemachine\"\n)\n\nvar (\n\tdefaultGCTick         uint64 = 2\n\tpendingProposalShards        = settings.Soft.PendingProposalShards\n)\n\nvar (\n\tplog = logger.GetLogger(\"dragonboat\")\n)\n\nvar (\n\t// ErrInvalidOption indicates that the specified option is invalid.\n\tErrInvalidOption = errors.New(\"invalid option\")\n\t// ErrInvalidOperation indicates that the requested operation is not allowed.\n\t// e.g. making read or write requests on witness node are not allowed.\n\tErrInvalidOperation = errors.New(\"invalid operation\")\n\t// ErrInvalidAddress indicates that the specified address is invalid.\n\tErrInvalidAddress = errors.New(\"invalid address\")\n\t// ErrInvalidSession indicates that the specified client session is invalid.\n\tErrInvalidSession = errors.New(\"invalid session\")\n\t// ErrTimeoutTooSmall indicates that the specified timeout value is too small.\n\tErrTimeoutTooSmall = errors.New(\"specified timeout value is too small\")\n\t// ErrPayloadTooBig indicates that the payload is too big.\n\tErrPayloadTooBig = errors.New(\"payload is too big\")\n\t// ErrSystemBusy indicates that the system is too busy to handle the request.\n\t// This might be caused when the Raft node reached its MaxInMemLogSize limit\n\t// or other system limits. For a requested snapshot, leadership transfer or\n\t// Raft config change operation, ErrSystemBusy means there is already such a\n\t// request waiting to be processed.\n\tErrSystemBusy = errors.New(\"system is too busy try again later\")\n\t// ErrShardClosed indicates that the requested shard is being shut down.\n\tErrShardClosed = errors.New(\"raft shard already closed\")\n\t// ErrShardNotInitialized indicates that the requested operation can not be\n\t// completed as the involved raft shard has not been initialized yet.\n\tErrShardNotInitialized = errors.New(\"raft shard not initialized yet\")\n\t// ErrTimeout indicates that the operation timed out.\n\tErrTimeout = errors.New(\"timeout\")\n\t// ErrCanceled indicates that the request has been canceled.\n\tErrCanceled = errors.New(\"request canceled\")\n\t// ErrRejected indicates that the request has been rejected.\n\tErrRejected = errors.New(\"request rejected\")\n\t// ErrAborted indicates that the request has been aborted, usually by user\n\t// defined behaviours.\n\tErrAborted = errors.New(\"request aborted\")\n\t// ErrShardNotReady indicates that the request has been dropped as the\n\t// specified raft shard is not ready to handle the request. Unknown leader\n\t// is the most common cause of this Error, trying to use a shard not fully\n\t// initialized is another major cause of ErrShardNotReady.\n\tErrShardNotReady = errors.New(\"request dropped as the shard is not ready\")\n\t// ErrInvalidTarget indicates that the specified node id invalid.\n\tErrInvalidTarget = errors.New(\"invalid target node ID\")\n)\n\n// IsTempError returns a boolean value indicating whether the specified error\n// is a temporary error that worth to be retried later with the exact same\n// input, potentially on a more suitable NodeHost instance.\nfunc IsTempError(err error) bool {\n\treturn errors.Is(err, ErrSystemBusy) ||\n\t\terrors.Is(err, ErrShardClosed) ||\n\t\terrors.Is(err, ErrShardNotInitialized) ||\n\t\terrors.Is(err, ErrShardNotReady) ||\n\t\terrors.Is(err, ErrTimeout) ||\n\t\terrors.Is(err, ErrClosed) ||\n\t\terrors.Is(err, ErrAborted)\n}\n\n// LogRange defines the range [FirstIndex, lastIndex) of the raft log.\ntype LogRange struct {\n\tFirstIndex uint64\n\tLastIndex  uint64\n}\n\n// RequestResultCode is the result code returned to the client to indicate the\n// outcome of the request.\ntype RequestResultCode int\n\n// RequestResult is the result struct returned for the request.\ntype RequestResult struct {\n\t// code is the result state of the request.\n\tcode RequestResultCode\n\t// Result is the returned result from the Update method of the state machine\n\t// instance. Result is only available when making a proposal and the Code\n\t// value is RequestCompleted.\n\tresult         sm.Result\n\tentries        []pb.Entry\n\tlogRange       LogRange\n\tsnapshotResult bool\n\tlogQueryResult bool\n}\n\n// RequestOutOfRange returns a boolean value indicating whether the request\n// is out of range.\nfunc (rr *RequestResult) RequestOutOfRange() bool {\n\treturn rr.code == requestOutOfRange\n}\n\n// Timeout returns a boolean value indicating whether the request timed out.\nfunc (rr *RequestResult) Timeout() bool {\n\treturn rr.code == requestTimeout\n}\n\n// Committed returns a boolean value indicating whether the request has been\n// committed by Raft.\nfunc (rr *RequestResult) Committed() bool {\n\treturn rr.code == requestCompleted || rr.code == requestCommitted\n}\n\n// Completed returns a boolean value indicating whether the request completed\n// successfully. For proposals, it means the proposal has been committed by the\n// Raft shard and applied on the local node. For ReadIndex operation, it means\n// the shard is now ready for a local read.\nfunc (rr *RequestResult) Completed() bool {\n\treturn rr.code == requestCompleted\n}\n\n// Terminated returns a boolean value indicating the request terminated due to\n// the requested Raft shard is being shut down.\nfunc (rr *RequestResult) Terminated() bool {\n\treturn rr.code == requestTerminated\n}\n\n// Aborted returns a boolean value indicating the request is aborted.\nfunc (rr *RequestResult) Aborted() bool {\n\treturn rr.code == requestAborted\n}\n\n// Rejected returns a boolean value indicating the request is rejected. For a\n// proposal, it means that the used client session instance is not registered\n// or it has been evicted on the server side. When requesting a client session\n// to be registered, Rejected means the another client session with the same\n// client ID has already been registered. When requesting a client session to\n// be unregistered, Rejected means the specified client session is not found\n// on the server side. For a membership change request, it means the request\n// is out of order and thus not applied.\nfunc (rr *RequestResult) Rejected() bool {\n\treturn rr.code == requestRejected\n}\n\n// Dropped returns a boolean flag indicating whether the request has been\n// dropped as the leader is unavailable or not ready yet. Such dropped requests\n// can usually be retried once the leader is ready.\nfunc (rr *RequestResult) Dropped() bool {\n\treturn rr.code == requestDropped\n}\n\n// SnapshotIndex returns the index of the generated snapshot when the\n// RequestResult is from a snapshot related request. Invoking this method on\n// RequestResult instances not related to snapshots will cause panic.\nfunc (rr *RequestResult) SnapshotIndex() uint64 {\n\tif !rr.snapshotResult {\n\t\tplog.Panicf(\"not a snapshot request result\")\n\t}\n\treturn rr.result.Value\n}\n\n// RaftLogs returns the raft log query result.\nfunc (rr *RequestResult) RaftLogs() ([]pb.Entry, LogRange) {\n\tif !rr.logQueryResult {\n\t\tpanic(\"not a raft log query result\")\n\t}\n\treturn rr.entries, rr.logRange\n}\n\n// GetResult returns the result value of the request. When making a proposal,\n// the returned result is the value returned by the Update method of the\n// IStateMachine instance. Returned result is only valid if the RequestResultCode\n// value is RequestCompleted.\nfunc (rr *RequestResult) GetResult() sm.Result {\n\treturn rr.result\n}\n\nconst (\n\trequestTimeout RequestResultCode = iota\n\trequestCompleted\n\trequestTerminated\n\trequestRejected\n\trequestDropped\n\trequestAborted\n\trequestCommitted\n\trequestOutOfRange\n)\n\nvar requestResultCodeName = [...]string{\n\t\"RequestTimeout\",\n\t\"RequestCompleted\",\n\t\"RequestTerminated\",\n\t\"RequestRejected\",\n\t\"RequestDropped\",\n\t\"RequestAborted\",\n\t\"RequestCommitted\",\n\t\"RequestOutOfRange\",\n}\n\nfunc (c RequestResultCode) String() string {\n\treturn requestResultCodeName[uint64(c)]\n}\n\ntype logicalClock struct {\n\tltick      uint64\n\tlastGcTime uint64\n\tgcTick     uint64\n}\n\nfunc newLogicalClock() logicalClock {\n\tif defaultGCTick == 0 || defaultGCTick > 3 {\n\t\tplog.Panicf(\"invalid defaultGCTick %d\", defaultGCTick)\n\t}\n\treturn logicalClock{gcTick: defaultGCTick}\n}\n\nfunc (p *logicalClock) tick(tick uint64) {\n\tatomic.StoreUint64(&p.ltick, tick)\n}\n\nfunc (p *logicalClock) getTick() uint64 {\n\treturn atomic.LoadUint64(&p.ltick)\n}\n\ntype ready struct {\n\tval uint32\n}\n\nfunc (r *ready) ready() bool {\n\treturn atomic.LoadUint32(&r.val) == 1\n}\n\nfunc (r *ready) clear() {\n\tatomic.StoreUint32(&r.val, 0)\n}\n\nfunc (r *ready) set() {\n\tatomic.StoreUint32(&r.val, 1)\n}\n\n// SysOpState is the object used to provide system maintenance operation result\n// to users.\ntype SysOpState struct {\n\tcompletedC <-chan struct{}\n}\n\n// CompletedC returns a struct{} chan that is closed when the requested\n// operation is completed.\n//\n// Deprecated: CompletedC() has been deprecated. Use ResultC() instead.\nfunc (o *SysOpState) CompletedC() <-chan struct{} {\n\treturn o.completedC\n}\n\n// ResultC returns a struct{} chan that is closed when the requested\n// operation is completed.\nfunc (o *SysOpState) ResultC() <-chan struct{} {\n\treturn o.completedC\n}\n\n// RequestState is the object used to provide request result to users.\ntype RequestState struct {\n\tkey            uint64\n\tclientID       uint64\n\tseriesID       uint64\n\trespondedTo    uint64\n\tdeadline       uint64\n\tlogRange       LogRange\n\tmaxSize        uint64\n\treadyToRead    ready\n\treadyToRelease ready\n\taggrC          chan RequestResult\n\tcommittedC     chan RequestResult\n\t// CompletedC is a channel for delivering request result to users.\n\t//\n\t// Deprecated: CompletedC has been deprecated. Use ResultC() or AppliedC()\n\t// instead.\n\tCompletedC   chan RequestResult\n\tnode         *node\n\tpool         *sync.Pool\n\tnotifyCommit bool\n\ttestErr      chan struct{}\n}\n\n// AppliedC returns a channel of RequestResult for delivering request result.\n// The returned channel reports the final outcomes of proposals and config\n// changes, the return value can be of one of the Completed(), Dropped(),\n// Timeout(), Rejected(), Terminated() or Aborted() values.\n//\n// Use ResultC() when the client wants to be notified when proposals or config\n// changes are committed.\nfunc (r *RequestState) AppliedC() chan RequestResult {\n\treturn r.CompletedC\n}\n\n// ResultC returns a channel of RequestResult for delivering request results to\n// users. When NotifyCommit is not enabled, the behaviour of the returned\n// channel is the same as the one returned by the AppliedC() method. When\n// NotifyCommit is enabled, up to two RequestResult values can be received from\n// the returned channel. For example, for a successful proposal that is\n// eventually committed and applied, the returned chan RequestResult will return\n// a RequestResult value to indicate the proposal is committed first, it will be\n// followed by another RequestResult value indicating the proposal has been\n// applied into the state machine.\n//\n// Use AppliedC() when your client don't need extra notification when proposals\n// and config changes are committed.\nfunc (r *RequestState) ResultC() chan RequestResult {\n\tif !r.notifyCommit {\n\t\treturn r.CompletedC\n\t}\n\tif r.committedC == nil {\n\t\tplog.Panicf(\"committedC is nil\")\n\t}\n\tif r.aggrC != nil {\n\t\treturn r.aggrC\n\t}\n\tr.aggrC = make(chan RequestResult, 2)\n\ttryBridgeCommittedC := func() {\n\t\tselect {\n\t\tcase cn := <-r.committedC:\n\t\t\tif cn.code != requestCommitted {\n\t\t\t\tplog.Panicf(\"unexpected requestResult, %s\", cn.code)\n\t\t\t}\n\t\t\tr.aggrC <- cn\n\t\tdefault:\n\t\t}\n\t}\n\tgo func() {\n\t\tif r.testErr != nil {\n\t\t\tdefer func() {\n\t\t\t\tif rr := recover(); rr != nil {\n\t\t\t\t\tclose(r.testErr)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tselect {\n\t\tcase cn := <-r.committedC:\n\t\t\tif cn.code != requestCommitted {\n\t\t\t\tplog.Panicf(\"unexpected requestResult, %s\", cn.code)\n\t\t\t}\n\t\t\tr.aggrC <- cn\n\t\t\tcc := <-r.CompletedC\n\t\t\tif cc.Dropped() {\n\t\t\t\tplog.Panicf(\"committed entry dropped\")\n\t\t\t}\n\t\t\tif cc.Aborted() {\n\t\t\t\tplog.Panicf(\"committed entry aborted\")\n\t\t\t}\n\t\t\tif cc.code == requestCommitted {\n\t\t\t\tplog.Panicf(\"entry committed notified twice\")\n\t\t\t}\n\t\t\tr.aggrC <- cc\n\t\tcase cc := <-r.CompletedC:\n\t\t\tif cc.Aborted() {\n\t\t\t\t// this select is to make the test TestResultCCanReceiveRequestResults\n\t\t\t\t// easier to implement for the input\n\t\t\t\t// {true, true, requestAborted, true}\n\t\t\t\ttryBridgeCommittedC()\n\t\t\t\tplog.Panicf(\"requestAborted sent to CompletedC\")\n\t\t\t}\n\t\t\tif cc.code == requestCommitted {\n\t\t\t\ttryBridgeCommittedC()\n\t\t\t\tplog.Panicf(\"requestCommitted sent to CompletedC\")\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase ccn := <-r.committedC:\n\t\t\t\tif cc.Dropped() {\n\t\t\t\t\tr.aggrC <- ccn\n\t\t\t\t\tplog.Panicf(\"applied entry dropped\")\n\t\t\t\t}\n\t\t\t\tr.aggrC <- ccn\n\t\t\tdefault:\n\t\t\t}\n\t\t\tr.aggrC <- cc\n\t\t}\n\t}()\n\treturn r.aggrC\n}\n\nfunc (r *RequestState) committed() {\n\tif !r.notifyCommit {\n\t\tplog.Panicf(\"notify commit not allowed\")\n\t}\n\tif r.committedC == nil {\n\t\tplog.Panicf(\"committedC is nil\")\n\t}\n\tselect {\n\tcase r.committedC <- RequestResult{code: requestCommitted}:\n\tdefault:\n\t\tplog.Panicf(\"RequestState.committedC is full\")\n\t}\n}\n\nfunc (r *RequestState) timeout() {\n\tr.notify(RequestResult{code: requestTimeout})\n}\n\nfunc (r *RequestState) terminated() {\n\tr.notify(RequestResult{code: requestTerminated})\n}\n\nfunc (r *RequestState) dropped() {\n\tr.notify(RequestResult{code: requestDropped})\n}\n\nfunc (r *RequestState) notify(result RequestResult) {\n\tselect {\n\tcase r.CompletedC <- result:\n\t\tr.readyToRelease.set()\n\tdefault:\n\t\tplog.Panicf(\"RequestState.CompletedC is full\")\n\t}\n}\n\n// Release puts the RequestState instance back to an internal pool so it can be\n// reused. Release is normally called after all RequestResult values have been\n// received from the ResultC() channel.\nfunc (r *RequestState) Release() {\n\tif r.pool != nil {\n\t\tif !r.readyToRelease.ready() {\n\t\t\treturn\n\t\t}\n\t\tr.notifyCommit = false\n\t\tr.logRange = LogRange{}\n\t\tr.maxSize = 0\n\t\tr.deadline = 0\n\t\tr.key = 0\n\t\tr.seriesID = 0\n\t\tr.clientID = 0\n\t\tr.respondedTo = 0\n\t\tr.node = nil\n\t\tr.readyToRead.clear()\n\t\tr.readyToRelease.clear()\n\t\tr.aggrC = nil\n\t\tr.pool.Put(r)\n\t}\n}\n\nfunc (r *RequestState) reuse(notifyCommit bool) {\n\tif r.aggrC != nil {\n\t\tplog.Panicf(\"aggrC not nil\")\n\t}\n\tif len(r.CompletedC) > 0 || r.CompletedC == nil {\n\t\tr.CompletedC = make(chan RequestResult, 1)\n\t}\n\tif notifyCommit {\n\t\tif len(r.committedC) > 0 || r.committedC == nil {\n\t\t\tr.committedC = make(chan RequestResult, 1)\n\t\t}\n\t} else {\n\t\tr.committedC = nil\n\t}\n}\n\nfunc (r *RequestState) mustBeReadyForLocalRead() {\n\tif r.node == nil {\n\t\tplog.Panicf(\"invalid rs\")\n\t}\n\tif !r.node.initialized() {\n\t\tplog.Panicf(\"%s not initialized\", r.node.id())\n\t}\n\tif !r.readyToRead.ready() {\n\t\tplog.Panicf(\"not ready for local read\")\n\t}\n}\n\ntype proposalShard struct {\n\tmu             sync.Mutex\n\tproposals      *entryQueue\n\tpending        map[uint64]*RequestState\n\tpool           *sync.Pool\n\tcfg            config.Config\n\tstopped        bool\n\tnotifyCommit   bool\n\texpireNotified uint64\n\tlogicalClock\n}\n\ntype keyGenerator struct {\n\trandMu sync.Mutex\n\trand   *rand.Rand\n}\n\nfunc (k *keyGenerator) nextKey() uint64 {\n\tk.randMu.Lock()\n\tv := k.rand.Uint64()\n\tk.randMu.Unlock()\n\treturn v\n}\n\ntype pendingProposal struct {\n\tshards []*proposalShard\n\tkeyg   []*keyGenerator\n\tps     uint64\n}\n\ntype readBatch struct {\n\tindex    uint64\n\trequests []*RequestState\n}\n\ntype pendingReadIndex struct {\n\tmu       sync.Mutex\n\tbatches  map[pb.SystemCtx]readBatch\n\trequests *readIndexQueue\n\tstopped  bool\n\tpool     *sync.Pool\n\tlogicalClock\n}\n\ntype configChangeRequest struct {\n\tdata []byte\n\tkey  uint64\n}\n\ntype pendingConfigChange struct {\n\tmu           sync.Mutex\n\tpending      *RequestState\n\tconfChangeC  chan<- configChangeRequest\n\tnotifyCommit bool\n\tlogicalClock\n}\n\ntype pendingSnapshot struct {\n\tmu        sync.Mutex\n\tpending   *RequestState\n\tsnapshotC chan<- rsm.SSRequest\n\tlogicalClock\n}\n\ntype pendingLeaderTransfer struct {\n\tleaderTransferC chan uint64\n}\n\nfunc newPendingLeaderTransfer() pendingLeaderTransfer {\n\treturn pendingLeaderTransfer{\n\t\tleaderTransferC: make(chan uint64, 1),\n\t}\n}\n\nfunc (l *pendingLeaderTransfer) request(target uint64) error {\n\tif target == pb.NoNode {\n\t\treturn ErrInvalidTarget\n\t}\n\tselect {\n\tcase l.leaderTransferC <- target:\n\tdefault:\n\t\treturn ErrSystemBusy\n\t}\n\treturn nil\n}\n\nfunc (l *pendingLeaderTransfer) get() (uint64, bool) {\n\tselect {\n\tcase v := <-l.leaderTransferC:\n\t\treturn v, true\n\tdefault:\n\t}\n\treturn 0, false\n}\n\nfunc newPendingSnapshot(snapshotC chan<- rsm.SSRequest) pendingSnapshot {\n\treturn pendingSnapshot{\n\t\tlogicalClock: newLogicalClock(),\n\t\tsnapshotC:    snapshotC,\n\t}\n}\n\nfunc (p *pendingSnapshot) notify(r RequestResult) {\n\tr.snapshotResult = true\n\tp.pending.notify(r)\n}\n\nfunc (p *pendingSnapshot) close() {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tp.snapshotC = nil\n\tif p.pending != nil {\n\t\tp.pending.terminated()\n\t\tp.pending = nil\n\t}\n}\n\nfunc (p *pendingSnapshot) request(st rsm.SSReqType,\n\tpath string, override bool, overhead uint64, index uint64,\n\ttimeoutTick uint64) (*RequestState, error) {\n\tif timeoutTick == 0 {\n\t\treturn nil, ErrTimeoutTooSmall\n\t}\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.pending != nil {\n\t\treturn nil, ErrSystemBusy\n\t}\n\tif p.snapshotC == nil {\n\t\treturn nil, ErrShardClosed\n\t}\n\tssreq := rsm.SSRequest{\n\t\tType:               st,\n\t\tPath:               path,\n\t\tKey:                random.LockGuardedRand.Uint64(),\n\t\tOverrideCompaction: override,\n\t\tCompactionOverhead: overhead,\n\t\tCompactionIndex:    index,\n\t}\n\treq := &RequestState{\n\t\tkey:          ssreq.Key,\n\t\tdeadline:     p.getTick() + timeoutTick,\n\t\tCompletedC:   make(chan RequestResult, 1),\n\t\tnotifyCommit: false,\n\t}\n\tselect {\n\tcase p.snapshotC <- ssreq:\n\t\tp.pending = req\n\t\treturn req, nil\n\tdefault:\n\t}\n\treturn nil, ErrSystemBusy\n}\n\nfunc (p *pendingSnapshot) gc() {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.pending == nil {\n\t\treturn\n\t}\n\tnow := p.getTick()\n\t// FIXME:\n\t// golangci-lint v1.23 complains that lastGcTime is not used unless lastGcTime\n\t// is accessed as a member of the logicalClock. v1.33's typecheck is pretty\n\t// broken, preventing us from upgrading.\n\tif now-p.logicalClock.lastGcTime < p.gcTick {\n\t\treturn\n\t}\n\tp.lastGcTime = now\n\tif p.pending.deadline < now {\n\t\tp.pending.timeout()\n\t\tp.pending = nil\n\t}\n}\n\nfunc (p *pendingSnapshot) apply(key uint64,\n\tignored bool, aborted bool, index uint64) {\n\tif ignored && aborted {\n\t\tplog.Panicf(\"ignored && aborted\")\n\t}\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.pending == nil {\n\t\treturn\n\t}\n\tif p.pending.key == key {\n\t\tr := RequestResult{}\n\t\tif ignored {\n\t\t\tr.code = requestRejected\n\t\t} else if aborted {\n\t\t\tr.code = requestAborted\n\t\t} else {\n\t\t\tr.code = requestCompleted\n\t\t\tr.result.Value = index\n\t\t}\n\t\tp.notify(r)\n\t\tp.pending = nil\n\t}\n}\n\nfunc newPendingConfigChange(confChangeC chan<- configChangeRequest,\n\tnotifyCommit bool) pendingConfigChange {\n\treturn pendingConfigChange{\n\t\tconfChangeC:  confChangeC,\n\t\tlogicalClock: newLogicalClock(),\n\t\tnotifyCommit: notifyCommit,\n\t}\n}\n\nfunc (p *pendingConfigChange) close() {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.confChangeC != nil {\n\t\tif p.pending != nil {\n\t\t\tp.pending.terminated()\n\t\t\tp.pending = nil\n\t\t}\n\t\tclose(p.confChangeC)\n\t\tp.confChangeC = nil\n\t}\n}\n\nfunc (p *pendingConfigChange) request(cc pb.ConfigChange,\n\ttimeoutTick uint64) (*RequestState, error) {\n\tif timeoutTick == 0 {\n\t\treturn nil, ErrTimeoutTooSmall\n\t}\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.pending != nil {\n\t\treturn nil, ErrSystemBusy\n\t}\n\tif p.confChangeC == nil {\n\t\treturn nil, ErrShardClosed\n\t}\n\tdata := pb.MustMarshal(&cc)\n\tccreq := configChangeRequest{\n\t\tkey:  random.LockGuardedRand.Uint64(),\n\t\tdata: data,\n\t}\n\treq := &RequestState{\n\t\tkey:          ccreq.key,\n\t\tdeadline:     p.getTick() + timeoutTick,\n\t\tCompletedC:   make(chan RequestResult, 1),\n\t\tnotifyCommit: p.notifyCommit,\n\t}\n\tif p.notifyCommit {\n\t\treq.committedC = make(chan RequestResult, 1)\n\t}\n\tselect {\n\tcase p.confChangeC <- ccreq:\n\t\tp.pending = req\n\t\treturn req, nil\n\tdefault:\n\t}\n\treturn nil, ErrSystemBusy\n}\n\nfunc (p *pendingConfigChange) gc() {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.pending == nil {\n\t\treturn\n\t}\n\tnow := p.getTick()\n\tif now-p.lastGcTime < p.gcTick {\n\t\treturn\n\t}\n\tp.lastGcTime = now\n\tif p.pending.deadline < now {\n\t\tp.pending.timeout()\n\t\tp.pending = nil\n\t}\n}\n\nfunc (p *pendingConfigChange) committed(key uint64) {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.pending == nil {\n\t\treturn\n\t}\n\tif p.pending.key == key {\n\t\tp.pending.committed()\n\t}\n}\n\nfunc (p *pendingConfigChange) dropped(key uint64) {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.pending == nil {\n\t\treturn\n\t}\n\tif p.pending.key == key {\n\t\tp.pending.dropped()\n\t\tp.pending = nil\n\t}\n}\n\nfunc (p *pendingConfigChange) apply(key uint64, rejected bool) {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.pending == nil {\n\t\treturn\n\t}\n\tvar v RequestResult\n\tif rejected {\n\t\tv.code = requestRejected\n\t} else {\n\t\tv.code = requestCompleted\n\t}\n\tif p.pending.key == key {\n\t\tp.pending.notify(v)\n\t\tp.pending = nil\n\t}\n}\n\nfunc newPendingReadIndex(pool *sync.Pool, r *readIndexQueue) pendingReadIndex {\n\treturn pendingReadIndex{\n\t\tbatches:      make(map[pb.SystemCtx]readBatch),\n\t\trequests:     r,\n\t\tlogicalClock: newLogicalClock(),\n\t\tpool:         pool,\n\t}\n}\n\nfunc (p *pendingReadIndex) close() {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tp.stopped = true\n\tif p.requests != nil {\n\t\tp.requests.close()\n\t\treqs := p.requests.get()\n\t\tfor _, rec := range reqs {\n\t\t\trec.terminated()\n\t\t}\n\t}\n\tfor _, rb := range p.batches {\n\t\tfor _, req := range rb.requests {\n\t\t\tif req != nil {\n\t\t\t\treq.terminated()\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (p *pendingReadIndex) read(timeoutTick uint64) (*RequestState, error) {\n\tif timeoutTick == 0 {\n\t\treturn nil, ErrTimeoutTooSmall\n\t}\n\treq := p.pool.Get().(*RequestState)\n\treq.reuse(false)\n\treq.notifyCommit = false\n\treq.deadline = p.getTick() + timeoutTick\n\n\tok, closed := p.requests.add(req)\n\tif closed {\n\t\treturn nil, ErrShardClosed\n\t}\n\tif !ok {\n\t\treturn nil, ErrSystemBusy\n\t}\n\treturn req, nil\n}\n\nfunc (p *pendingReadIndex) genCtx() pb.SystemCtx {\n\tet := p.getTick() + 30\n\tfor {\n\t\tv := pb.SystemCtx{\n\t\t\tLow:  random.LockGuardedRand.Uint64(),\n\t\t\tHigh: et,\n\t\t}\n\t\tif v.Low != 0 {\n\t\t\treturn v\n\t\t}\n\t}\n}\n\nfunc (p *pendingReadIndex) nextCtx() pb.SystemCtx {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\treturn p.genCtx()\n}\n\nfunc (p *pendingReadIndex) addReady(reads []pb.ReadyToRead) {\n\tif len(reads) == 0 {\n\t\treturn\n\t}\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tfor _, v := range reads {\n\t\tif rb, ok := p.batches[v.SystemCtx]; ok {\n\t\t\trb.index = v.Index\n\t\t\tp.batches[v.SystemCtx] = rb\n\t\t}\n\t}\n}\n\nfunc (p *pendingReadIndex) add(sys pb.SystemCtx, reqs []*RequestState) {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.stopped {\n\t\treturn\n\t}\n\tif _, ok := p.batches[sys]; ok {\n\t\tplog.Panicf(\"same system ctx added again %v\", sys)\n\t} else {\n\t\trs := make([]*RequestState, len(reqs))\n\t\tcopy(rs, reqs)\n\t\tp.batches[sys] = readBatch{\n\t\t\trequests: rs,\n\t\t}\n\t}\n}\n\nfunc (p *pendingReadIndex) dropped(system pb.SystemCtx) {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.stopped {\n\t\treturn\n\t}\n\tif rb, ok := p.batches[system]; ok {\n\t\tfor _, req := range rb.requests {\n\t\t\tif req != nil {\n\t\t\t\treq.dropped()\n\t\t\t}\n\t\t}\n\t\tdelete(p.batches, system)\n\t}\n}\n\nfunc (p *pendingReadIndex) applied(applied uint64) {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.stopped || len(p.batches) == 0 {\n\t\treturn\n\t}\n\tnow := p.getTick()\n\tfor sys, rb := range p.batches {\n\t\tif rb.index > 0 && rb.index <= applied {\n\t\t\tfor _, req := range rb.requests {\n\t\t\t\tif req != nil {\n\t\t\t\t\tvar v RequestResult\n\t\t\t\t\tif req.deadline > now {\n\t\t\t\t\t\treq.readyToRead.set()\n\t\t\t\t\t\tv.code = requestCompleted\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv.code = requestTimeout\n\t\t\t\t\t}\n\t\t\t\t\treq.notify(v)\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete(p.batches, sys)\n\t\t}\n\t}\n\tif now-p.lastGcTime < p.gcTick {\n\t\treturn\n\t}\n\tp.lastGcTime = now\n\tp.gc(now)\n}\n\nfunc (p *pendingReadIndex) gc(now uint64) {\n\tif len(p.batches) == 0 {\n\t\treturn\n\t}\n\tfor sys, rb := range p.batches {\n\t\tfor idx, req := range rb.requests {\n\t\t\tif req != nil && req.deadline < now {\n\t\t\t\treq.timeout()\n\t\t\t\trb.requests[idx] = nil\n\t\t\t\tp.batches[sys] = rb\n\t\t\t}\n\t\t}\n\t}\n\tfor sys, rb := range p.batches {\n\t\tif sys.High < now {\n\t\t\tempty := true\n\t\t\tfor _, req := range rb.requests {\n\t\t\t\tif req != nil {\n\t\t\t\t\tempty = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif empty {\n\t\t\t\tdelete(p.batches, sys)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc getRng(shardID uint64, replicaID uint64, shard uint64) *keyGenerator {\n\tpid := os.Getpid()\n\tnano := time.Now().UnixNano()\n\tseedStr := fmt.Sprintf(\"%d-%d-%d-%d-%d\", pid, nano, shardID, replicaID, shard)\n\tm := sha512.New()\n\tfileutil.MustWrite(m, []byte(seedStr))\n\tsum := m.Sum(nil)\n\tseed := binary.LittleEndian.Uint64(sum)\n\treturn &keyGenerator{rand: rand.New(rand.NewSource(int64(seed)))}\n}\n\nfunc newPendingProposal(cfg config.Config,\n\tnotifyCommit bool, pool *sync.Pool, proposals *entryQueue) pendingProposal {\n\tps := pendingProposalShards\n\tp := pendingProposal{\n\t\tshards: make([]*proposalShard, ps),\n\t\tkeyg:   make([]*keyGenerator, ps),\n\t\tps:     ps,\n\t}\n\tfor i := uint64(0); i < ps; i++ {\n\t\tp.shards[i] = newPendingProposalShard(cfg, notifyCommit, pool, proposals)\n\t\tp.keyg[i] = getRng(cfg.ShardID, cfg.ReplicaID, i)\n\t}\n\treturn p\n}\n\nfunc (p *pendingProposal) propose(session *client.Session,\n\tcmd []byte, timeoutTick uint64) (*RequestState, error) {\n\tkey := p.nextKey(session.ClientID)\n\tpp := p.shards[key%p.ps]\n\treturn pp.propose(session, cmd, key, timeoutTick)\n}\n\nfunc (p *pendingProposal) close() {\n\tfor _, pp := range p.shards {\n\t\tpp.close()\n\t}\n}\n\nfunc (p *pendingProposal) committed(clientID uint64,\n\tseriesID uint64, key uint64) {\n\tpp := p.shards[key%p.ps]\n\tpp.committed(clientID, seriesID, key)\n}\n\nfunc (p *pendingProposal) dropped(clientID uint64,\n\tseriesID uint64, key uint64) {\n\tpp := p.shards[key%p.ps]\n\tpp.dropped(clientID, seriesID, key)\n}\n\nfunc (p *pendingProposal) applied(clientID uint64,\n\tseriesID uint64, key uint64, result sm.Result, rejected bool) {\n\tpp := p.shards[key%p.ps]\n\tpp.applied(clientID, seriesID, key, result, rejected)\n}\n\nfunc (p *pendingProposal) nextKey(clientID uint64) uint64 {\n\treturn p.keyg[clientID%p.ps].nextKey()\n}\n\nfunc (p *pendingProposal) tick(tick uint64) {\n\tfor i := uint64(0); i < p.ps; i++ {\n\t\tp.shards[i].tick(tick)\n\t}\n}\n\nfunc (p *pendingProposal) gc() {\n\tfor i := uint64(0); i < p.ps; i++ {\n\t\tpp := p.shards[i]\n\t\tpp.gc()\n\t}\n}\n\nfunc newPendingProposalShard(cfg config.Config,\n\tnotifyCommit bool, pool *sync.Pool, proposals *entryQueue) *proposalShard {\n\tp := &proposalShard{\n\t\tproposals:    proposals,\n\t\tpending:      make(map[uint64]*RequestState),\n\t\tlogicalClock: newLogicalClock(),\n\t\tpool:         pool,\n\t\tcfg:          cfg,\n\t\tnotifyCommit: notifyCommit,\n\t}\n\treturn p\n}\n\nfunc (p *proposalShard) propose(session *client.Session,\n\tcmd []byte, key uint64, timeoutTick uint64) (*RequestState, error) {\n\tif timeoutTick == 0 {\n\t\treturn nil, ErrTimeoutTooSmall\n\t}\n\tif rsm.GetMaxBlockSize(p.cfg.EntryCompressionType) < uint64(len(cmd)) {\n\t\treturn nil, ErrPayloadTooBig\n\t}\n\tentry := pb.Entry{\n\t\tKey:         key,\n\t\tClientID:    session.ClientID,\n\t\tSeriesID:    session.SeriesID,\n\t\tRespondedTo: session.RespondedTo,\n\t}\n\tif len(cmd) == 0 {\n\t\tentry.Type = pb.ApplicationEntry\n\t} else {\n\t\tentry.Type = pb.EncodedEntry\n\t\tentry.Cmd = preparePayload(p.cfg.EntryCompressionType, cmd)\n\t}\n\treq := p.pool.Get().(*RequestState)\n\treq.reuse(p.notifyCommit)\n\treq.clientID = session.ClientID\n\treq.seriesID = session.SeriesID\n\treq.key = entry.Key\n\treq.deadline = p.getTick() + timeoutTick\n\treq.notifyCommit = p.notifyCommit\n\n\tp.mu.Lock()\n\tp.pending[entry.Key] = req\n\tp.mu.Unlock()\n\n\tadded, stopped := p.proposals.add(entry)\n\tif stopped {\n\t\tplog.Warningf(\"%s dropped proposal, shard stopped\",\n\t\t\tdn(p.cfg.ShardID, p.cfg.ReplicaID))\n\t\tp.mu.Lock()\n\t\tdelete(p.pending, entry.Key)\n\t\tp.mu.Unlock()\n\t\treturn nil, ErrShardClosed\n\t}\n\tif !added {\n\t\tp.mu.Lock()\n\t\tdelete(p.pending, entry.Key)\n\t\tp.mu.Unlock()\n\t\tplog.Debugf(\"%s dropped proposal, overloaded\",\n\t\t\tdn(p.cfg.ShardID, p.cfg.ReplicaID))\n\t\treturn nil, ErrSystemBusy\n\t}\n\treturn req, nil\n}\n\nfunc (p *proposalShard) close() {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tp.stopped = true\n\tif p.proposals != nil {\n\t\tp.proposals.close()\n\t}\n\tfor _, rec := range p.pending {\n\t\trec.terminated()\n\t}\n}\n\nfunc (p *proposalShard) getProposal(clientID uint64,\n\tseriesID uint64, key uint64, now uint64) *RequestState {\n\treturn p.takeProposal(clientID, seriesID, key, now, true)\n}\n\nfunc (p *proposalShard) borrowProposal(clientID uint64,\n\tseriesID uint64, key uint64, now uint64) *RequestState {\n\treturn p.takeProposal(clientID, seriesID, key, now, false)\n}\n\nfunc (p *proposalShard) takeProposal(clientID uint64,\n\tseriesID uint64, key uint64, now uint64, remove bool) *RequestState {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.stopped {\n\t\treturn nil\n\t}\n\tps, ok := p.pending[key]\n\tif ok && ps.deadline >= now {\n\t\tif ps.clientID == clientID && ps.seriesID == seriesID {\n\t\t\tif remove {\n\t\t\t\tdelete(p.pending, key)\n\t\t\t}\n\t\t\treturn ps\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *proposalShard) committed(clientID uint64, seriesID uint64, key uint64) {\n\tif ps := p.borrowProposal(clientID, seriesID, key, p.getTick()); ps != nil {\n\t\tps.committed()\n\t}\n}\n\nfunc (p *proposalShard) dropped(clientID uint64, seriesID uint64, key uint64) {\n\tif ps := p.getProposal(clientID, seriesID, key, p.getTick()); ps != nil {\n\t\tps.dropped()\n\t}\n}\n\nfunc (p *proposalShard) applied(clientID uint64,\n\tseriesID uint64, key uint64, result sm.Result, rejected bool) {\n\tnow := p.getTick()\n\tvar code RequestResultCode\n\tif rejected {\n\t\tcode = requestRejected\n\t} else {\n\t\tcode = requestCompleted\n\t}\n\tif ps := p.getProposal(clientID, seriesID, key, now); ps != nil {\n\t\tps.notify(RequestResult{code: code, result: result})\n\t}\n\tif now != p.expireNotified {\n\t\tp.gcAt(now)\n\t\tp.expireNotified = now\n\t}\n}\n\nfunc (p *proposalShard) gc() {\n\tp.gcAt(p.getTick())\n}\n\nfunc (p *proposalShard) gcAt(now uint64) {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.stopped {\n\t\treturn\n\t}\n\tif now-p.lastGcTime < p.gcTick {\n\t\treturn\n\t}\n\tp.lastGcTime = now\n\tfor key, rec := range p.pending {\n\t\tif rec.deadline < now {\n\t\t\trec.timeout()\n\t\t\tdelete(p.pending, key)\n\t\t}\n\t}\n}\n\nfunc preparePayload(ct config.CompressionType, cmd []byte) []byte {\n\treturn rsm.GetEncoded(rsm.ToDioType(ct), cmd, nil)\n}\n\ntype pendingRaftLogQuery struct {\n\tmu struct {\n\t\tsync.Mutex\n\t\tpending *RequestState\n\t}\n}\n\nfunc newPendingRaftLogQuery() pendingRaftLogQuery {\n\treturn pendingRaftLogQuery{}\n}\n\nfunc (p *pendingRaftLogQuery) close() {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.mu.pending != nil {\n\t\tp.mu.pending.terminated()\n\t\tp.mu.pending = nil\n\t}\n}\n\nfunc (p *pendingRaftLogQuery) add(firstIndex uint64,\n\tlastIndex uint64, maxSize uint64) (*RequestState, error) {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.mu.pending != nil {\n\t\treturn nil, ErrSystemBusy\n\t}\n\treq := &RequestState{\n\t\tlogRange:   LogRange{FirstIndex: firstIndex, LastIndex: lastIndex},\n\t\tmaxSize:    maxSize,\n\t\tCompletedC: make(chan RequestResult, 1),\n\t}\n\tp.mu.pending = req\n\n\treturn req, nil\n}\n\nfunc (p *pendingRaftLogQuery) get() *RequestState {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\treturn p.mu.pending\n}\n\nfunc (p *pendingRaftLogQuery) returned(outOfRange bool,\n\tlogRange LogRange, entries []pb.Entry) {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif p.mu.pending == nil {\n\t\tpanic(\"no pending raft log query\")\n\t}\n\n\treq := p.mu.pending\n\tp.mu.pending = nil\n\n\tif outOfRange {\n\t\treq.notify(RequestResult{\n\t\t\tlogQueryResult: true,\n\t\t\tcode:           requestOutOfRange,\n\t\t\tlogRange:       logRange,\n\t\t})\n\t} else {\n\t\treq.notify(RequestResult{\n\t\t\tlogQueryResult: true,\n\t\t\tcode:           requestCompleted,\n\t\t\tlogRange:       logRange,\n\t\t\tentries:        entries,\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "request_test.go",
          "type": "blob",
          "size": 35.8212890625,
          "content": "// Copyright 2017-2020 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dragonboat\n\nimport (\n\t\"math/rand\"\n\t\"reflect\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"github.com/lni/dragonboat/v4/client\"\n\t\"github.com/lni/dragonboat/v4/config\"\n\t\"github.com/lni/dragonboat/v4/internal/rsm\"\n\tpb \"github.com/lni/dragonboat/v4/raftpb\"\n\tsm \"github.com/lni/dragonboat/v4/statemachine\"\n\t\"github.com/lni/goutils/random\"\n)\n\nfunc TestIsTempError(t *testing.T) {\n\ttests := []struct {\n\t\terr  error\n\t\ttemp bool\n\t}{\n\t\t{ErrInvalidOperation, false},\n\t\t{ErrInvalidAddress, false},\n\t\t{ErrInvalidSession, false},\n\t\t{ErrTimeoutTooSmall, false},\n\t\t{ErrPayloadTooBig, false},\n\t\t{ErrSystemBusy, true},\n\t\t{ErrShardClosed, true},\n\t\t{ErrShardNotInitialized, true},\n\t\t{ErrTimeout, true},\n\t\t{ErrCanceled, false},\n\t\t{ErrRejected, false},\n\t\t{ErrAborted, true},\n\t\t{ErrShardNotReady, true},\n\t\t{ErrInvalidTarget, false},\n\t\t{ErrInvalidRange, false},\n\t}\n\tfor idx, tt := range tests {\n\t\tif tmp := IsTempError(tt.err); tmp != tt.temp {\n\t\t\tt.Errorf(\"%d, IsTempError failed\", idx)\n\t\t}\n\t}\n}\n\nfunc TestRequestCodeName(t *testing.T) {\n\tcode := requestTimeout\n\tif code.String() != \"RequestTimeout\" {\n\t\tt.Errorf(\"unexpected request code name\")\n\t}\n}\n\nfunc TestRequestStateCommitted(t *testing.T) {\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"no panic\")\n\t\t\t}\n\t\t}()\n\t\trs := &RequestState{}\n\t\trs.committed()\n\t}()\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"no panic\")\n\t\t\t}\n\t\t}()\n\t\trs := &RequestState{notifyCommit: true}\n\t\trs.committed()\n\t}()\n\tfunc() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"no panic\")\n\t\t\t}\n\t\t}()\n\t\trs := &RequestState{\n\t\t\tnotifyCommit: true,\n\t\t\tcommittedC:   make(chan RequestResult, 1),\n\t\t}\n\t\trs.committed()\n\t\trs.committed()\n\t}()\n\trs := &RequestState{\n\t\tnotifyCommit: true,\n\t\tcommittedC:   make(chan RequestResult, 1),\n\t}\n\trs.committed()\n\tselect {\n\tcase cc := <-rs.committedC:\n\t\tif cc.code != requestCommitted {\n\t\t\tt.Errorf(\"not requestedCommitted\")\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"nothing in the committedC\")\n\t}\n}\n\nfunc TestRequestStateReuse(t *testing.T) {\n\trs := &RequestState{}\n\trs.reuse(false)\n\tif rs.CompletedC == nil || cap(rs.CompletedC) != 1 {\n\t\tt.Errorf(\"completedC not ready\")\n\t}\n\tif rs.committedC != nil {\n\t\tt.Errorf(\"committedC unexpectedly created\")\n\t}\n\trs = &RequestState{}\n\trs.reuse(true)\n\tif rs.committedC == nil || cap(rs.committedC) != 1 {\n\t\tt.Errorf(\"committedC not ready\")\n\t}\n}\n\nfunc TestResultCReturnsCompleteCWhenNotifyCommitNotSet(t *testing.T) {\n\trs := &RequestState{\n\t\tCompletedC: make(chan RequestResult),\n\t}\n\tif rs.ResultC() != rs.CompletedC {\n\t\tt.Errorf(\"chan not equal\")\n\t}\n}\n\nfunc TestResultCPanicWhenCommittedCIsNil(t *testing.T) {\n\trs := &RequestState{\n\t\tCompletedC:   make(chan RequestResult),\n\t\tnotifyCommit: true,\n\t}\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Fatalf(\"no panic\")\n\t\t}\n\t}()\n\trs.ResultC()\n}\n\nfunc TestResultCCanReceiveRequestResults(t *testing.T) {\n\ttests := []struct {\n\t\tnotifyCommit        bool\n\t\thasCommittedCResult bool\n\t\tcompletedCCode      RequestResultCode\n\t\tcrash               bool\n\t}{\n\t\t{false, false, requestTimeout, false},\n\t\t{false, false, requestCompleted, false},\n\t\t{false, false, requestTerminated, false},\n\t\t{false, false, requestRejected, false},\n\t\t{false, false, requestDropped, false},\n\t\t{false, false, requestAborted, false},\n\t\t{false, false, requestCommitted, false},\n\n\t\t{true, false, requestTimeout, false},\n\t\t{true, false, requestCompleted, false},\n\t\t{true, false, requestTerminated, false},\n\t\t{true, false, requestRejected, false},\n\t\t{true, false, requestDropped, false},\n\t\t{true, false, requestAborted, true},\n\t\t{true, false, requestCommitted, true},\n\n\t\t{true, true, requestTimeout, false},\n\t\t{true, true, requestCompleted, false},\n\t\t{true, true, requestTerminated, false},\n\t\t{true, true, requestRejected, false},\n\t\t{true, true, requestDropped, true},\n\t\t{true, true, requestAborted, true},\n\t\t{true, true, requestCommitted, true},\n\t}\n\tfor idx, tt := range tests {\n\t\tfunc() {\n\t\t\trs := &RequestState{\n\t\t\t\tCompletedC:   make(chan RequestResult, 1),\n\t\t\t\tnotifyCommit: tt.notifyCommit,\n\t\t\t}\n\t\t\tif tt.crash {\n\t\t\t\trs.testErr = make(chan struct{})\n\t\t\t}\n\t\t\tif tt.notifyCommit {\n\t\t\t\trs.committedC = make(chan RequestResult, 1)\n\t\t\t}\n\t\t\tif tt.hasCommittedCResult {\n\t\t\t\trs.committed()\n\t\t\t}\n\t\t\trs.notify(RequestResult{code: tt.completedCCode})\n\t\t\tch := rs.ResultC()\n\t\t\tcrashed := false\n\t\t\tif tt.hasCommittedCResult {\n\t\t\t\tselect {\n\t\t\t\tcase cc := <-ch:\n\t\t\t\t\tif cc.code != requestCommitted {\n\t\t\t\t\t\tt.Errorf(\"%d, not the expected committed result\", idx)\n\t\t\t\t\t}\n\t\t\t\tcase <-rs.testErr:\n\t\t\t\t\tcrashed = true\n\t\t\t\t\tcc := <-ch\n\t\t\t\t\tif cc.code != requestCommitted {\n\t\t\t\t\t\tt.Errorf(\"%d, not the expected committed result\", idx)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase cc := <-ch:\n\t\t\t\tif cc.code != tt.completedCCode {\n\t\t\t\t\tt.Errorf(\"%d, unexpected completedC value, got %s, want %s\",\n\t\t\t\t\t\tidx, cc.code, tt.completedCCode)\n\t\t\t\t}\n\t\t\t\tif rs.testErr != nil {\n\t\t\t\t\t<-rs.testErr\n\t\t\t\t\tcrashed = true\n\t\t\t\t}\n\t\t\tcase <-rs.testErr:\n\t\t\t\tcrashed = true\n\t\t\t}\n\t\t\tif tt.crash && !crashed {\n\t\t\t\tt.Errorf(\"%d, didn't crash\", idx)\n\t\t\t}\n\t\t\tif ch != rs.ResultC() {\n\t\t\t\tt.Errorf(\"%d, ch changed\", idx)\n\t\t\t}\n\t\t}()\n\t}\n}\n\nfunc TestPendingLeaderTransferCanBeCreated(t *testing.T) {\n\tp := newPendingLeaderTransfer()\n\tif len(p.leaderTransferC) != 0 || p.leaderTransferC == nil {\n\t\tt.Errorf(\"leaderTransferC not ready\")\n\t}\n}\n\nfunc TestLeaderTransferCanBeRequested(t *testing.T) {\n\tp := newPendingLeaderTransfer()\n\tif err := p.request(1); err != nil {\n\t\tt.Errorf(\"failed to request leadership transfer %v\", err)\n\t}\n\tif len(p.leaderTransferC) != 1 {\n\t\tt.Errorf(\"leader transfer not requested\")\n\t}\n}\n\nfunc TestInvalidLeaderTransferIsNotAllowed(t *testing.T) {\n\tp := newPendingLeaderTransfer()\n\tif err := p.request(0); err != ErrInvalidTarget {\n\t\tt.Errorf(\"failed to reject invalid target node id\")\n\t}\n\tif err := p.request(1); err != nil {\n\t\tt.Errorf(\"failed to request %v\", err)\n\t}\n\tif err := p.request(2); err != ErrSystemBusy {\n\t\tt.Errorf(\"failed to reject\")\n\t}\n}\n\nfunc TestCanGetExitingLeaderTransferRequest(t *testing.T) {\n\tp := newPendingLeaderTransfer()\n\t_, ok := p.get()\n\tif ok {\n\t\tt.Errorf(\"unexpectedly returned request\")\n\t}\n\tif err := p.request(1); err != nil {\n\t\tt.Errorf(\"failed to request leadership transfer %v\", err)\n\t}\n\tv, ok := p.get()\n\tif !ok || v != 1 {\n\t\tt.Errorf(\"failed to get request\")\n\t}\n\tv, ok = p.get()\n\tif ok || v != 0 {\n\t\tt.Errorf(\"unexpectedly returned request\")\n\t}\n}\n\nfunc TestRequestStatePanicWhenNotReadyForRead(t *testing.T) {\n\tfn := func(rs *RequestState) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Fatalf(\"failed to trigger panic\")\n\t\t\t}\n\t\t}()\n\t\trs.mustBeReadyForLocalRead()\n\t}\n\tr1 := &RequestState{}\n\tr2 := &RequestState{node: &node{}}\n\tr3 := &RequestState{node: &node{initializedC: make(chan struct{})}}\n\tr3.node.setInitialized()\n\tfn(r1)\n\tfn(r2)\n\tfn(r3)\n\tr4 := &RequestState{node: &node{initializedC: make(chan struct{})}}\n\tr4.node.setInitialized()\n\tr4.readyToRead.set()\n\tr4.mustBeReadyForLocalRead()\n}\n\nfunc TestPendingSnapshotCanBeCreatedAndClosed(t *testing.T) {\n\tsnapshotC := make(chan<- rsm.SSRequest, 1)\n\tps := newPendingSnapshot(snapshotC)\n\tif len(ps.snapshotC) != 0 {\n\t\tt.Errorf(\"snapshotC not empty\")\n\t}\n\tif ps.pending != nil {\n\t\tt.Errorf(\"pending not nil\")\n\t}\n\tpending := &RequestState{\n\t\tCompletedC: make(chan RequestResult, 1),\n\t}\n\tps.pending = pending\n\tps.close()\n\tif ps.pending != nil {\n\t\tt.Errorf(\"pending not cleared\")\n\t}\n\tselect {\n\tcase v := <-pending.ResultC():\n\t\tif !v.Terminated() {\n\t\t\tt.Errorf(\"unexpected code\")\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"close() didn't set pending to terminated\")\n\t}\n}\n\nfunc TestPendingSnapshotCanBeRequested(t *testing.T) {\n\tsnapshotC := make(chan rsm.SSRequest, 1)\n\tps := newPendingSnapshot(snapshotC)\n\tss, err := ps.request(rsm.UserRequested, \"\", false, 0, 0, 10)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to request snapshot\")\n\t}\n\tif ss == nil {\n\t\tt.Fatalf(\"nil ss returned\")\n\t\treturn\n\t}\n\tif ps.pending == nil {\n\t\tt.Errorf(\"pending not set\")\n\t}\n\tif ss.deadline <= ps.getTick() {\n\t\tt.Errorf(\"deadline not set\")\n\t}\n\tselect {\n\tcase <-snapshotC:\n\tdefault:\n\t\tt.Errorf(\"requested snapshot is not pushed\")\n\t}\n}\n\nfunc TestPendingSnapshotCanReturnBusy(t *testing.T) {\n\tsnapshotC := make(chan rsm.SSRequest, 1)\n\tps := newPendingSnapshot(snapshotC)\n\tif _, err := ps.request(rsm.UserRequested, \"\", false, 0, 0, 10); err != nil {\n\t\tt.Errorf(\"failed to request snapshot\")\n\t}\n\tif _, err := ps.request(rsm.UserRequested, \"\", false, 0, 0, 10); err != ErrSystemBusy {\n\t\tt.Errorf(\"failed to return ErrSystemBusy\")\n\t}\n}\n\nfunc TestTooSmallSnapshotTimeoutIsRejected(t *testing.T) {\n\tsnapshotC := make(chan<- rsm.SSRequest, 1)\n\tps := newPendingSnapshot(snapshotC)\n\tss, err := ps.request(rsm.UserRequested, \"\", false, 0, 0, 0)\n\tif err != ErrTimeoutTooSmall {\n\t\tt.Errorf(\"request not rejected\")\n\t}\n\tif ss != nil {\n\t\tt.Errorf(\"returned ss is not nil\")\n\t}\n}\n\nfunc TestMultiplePendingSnapshotIsNotAllowed(t *testing.T) {\n\tsnapshotC := make(chan<- rsm.SSRequest, 1)\n\tps := newPendingSnapshot(snapshotC)\n\tss, err := ps.request(rsm.UserRequested, \"\", false, 0, 0, 100)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to request snapshot\")\n\t}\n\tif ss == nil {\n\t\tt.Fatalf(\"nil ss returned\")\n\t\treturn\n\t}\n\tss, err = ps.request(rsm.UserRequested, \"\", false, 0, 0, 100)\n\tif err != ErrSystemBusy {\n\t\tt.Errorf(\"request not rejected\")\n\t}\n\tif ss != nil {\n\t\tt.Errorf(\"returned ss is not nil\")\n\t}\n}\n\nfunc TestPendingSnapshotCanBeGCed(t *testing.T) {\n\tsnapshotC := make(chan rsm.SSRequest, 1)\n\tps := newPendingSnapshot(snapshotC)\n\tss, err := ps.request(rsm.UserRequested, \"\", false, 0, 0, 20)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to request snapshot\")\n\t}\n\tif ss == nil {\n\t\tt.Fatalf(\"nil ss returned\")\n\t}\n\tif ps.pending == nil {\n\t\tt.Errorf(\"pending not set\")\n\t}\n\tfor i := uint64(1); i < 22; i++ {\n\t\tps.tick(i)\n\t\tps.gc()\n\t\tif ps.pending == nil {\n\t\t\tt.Errorf(\"pending cleared\")\n\t\t}\n\t}\n\tps.tick(uint64(22))\n\tps.gc()\n\tif ps.pending != nil {\n\t\tt.Errorf(\"pending is not cleared\")\n\t}\n\tselect {\n\tcase v := <-ss.ResultC():\n\t\tif !v.Timeout() {\n\t\t\tt.Errorf(\"not timeout\")\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"not notify as timed out\")\n\t}\n}\n\nfunc TestPendingSnapshotCanBeApplied(t *testing.T) {\n\tsnapshotC := make(chan rsm.SSRequest, 1)\n\tps := newPendingSnapshot(snapshotC)\n\tss, err := ps.request(rsm.UserRequested, \"\", false, 0, 0, 100)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to request snapshot\")\n\t}\n\tif ss == nil {\n\t\tt.Fatalf(\"nil ss returned\")\n\t\treturn\n\t}\n\tps.apply(ss.key, false, false, 123)\n\tselect {\n\tcase v := <-ss.ResultC():\n\t\tif v.SnapshotIndex() != 123 {\n\t\t\tt.Errorf(\"index value not returned\")\n\t\t}\n\t\tif !v.Completed() {\n\t\t\tt.Errorf(\"not completed\")\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"ss is not applied\")\n\t}\n}\n\nfunc TestPendingSnapshotCanBeIgnored(t *testing.T) {\n\tsnapshotC := make(chan rsm.SSRequest, 1)\n\tps := newPendingSnapshot(snapshotC)\n\tss, err := ps.request(rsm.UserRequested, \"\", false, 0, 0, 100)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to request snapshot\")\n\t}\n\tif ss == nil {\n\t\tt.Fatalf(\"nil ss returned\")\n\t\treturn\n\t}\n\tps.apply(ss.key, true, false, 123)\n\tselect {\n\tcase v := <-ss.ResultC():\n\t\tif v.SnapshotIndex() != 0 {\n\t\t\tt.Errorf(\"index value incorrectly set\")\n\t\t}\n\t\tif !v.Rejected() {\n\t\t\tt.Errorf(\"not rejected\")\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"ss is not applied\")\n\t}\n}\n\nfunc TestPendingSnapshotIsIdentifiedByTheKey(t *testing.T) {\n\tsnapshotC := make(chan rsm.SSRequest, 1)\n\tps := newPendingSnapshot(snapshotC)\n\tss, err := ps.request(rsm.UserRequested, \"\", false, 0, 0, 100)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to request snapshot\")\n\t\treturn\n\t}\n\tif ss == nil {\n\t\tt.Fatalf(\"nil ss returned\")\n\t\treturn\n\t}\n\tif ps.pending == nil {\n\t\tt.Fatalf(\"pending not set\")\n\t}\n\tps.apply(ss.key+1, false, false, 123)\n\tif ps.pending == nil {\n\t\tt.Errorf(\"pending unexpectedly cleared\")\n\t}\n\tselect {\n\tcase <-ss.ResultC():\n\t\tt.Fatalf(\"unexpectedly notified\")\n\tdefault:\n\t}\n}\n\nfunc TestSnapshotCanNotBeRequestedAfterClose(t *testing.T) {\n\tsnapshotC := make(chan rsm.SSRequest, 1)\n\tps := newPendingSnapshot(snapshotC)\n\tps.close()\n\tss, err := ps.request(rsm.UserRequested, \"\", false, 0, 0, 100)\n\tif err != ErrShardClosed {\n\t\tt.Errorf(\"not report as closed\")\n\t}\n\tif ss != nil {\n\t\tt.Errorf(\"snapshot state returned\")\n\t}\n}\n\nfunc TestCompactionOverheadDetailsIsRecorded(t *testing.T) {\n\tsnapshotC := make(chan rsm.SSRequest, 1)\n\tps := newPendingSnapshot(snapshotC)\n\t_, err := ps.request(rsm.UserRequested, \"\", true, 123, 0, 100)\n\tif err != nil {\n\t\tt.Errorf(\"failed to request snapshot\")\n\t}\n\tselect {\n\tcase req := <-snapshotC:\n\t\tif !req.OverrideCompaction || req.CompactionOverhead != 123 {\n\t\t\tt.Errorf(\"compaction details not recorded\")\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"snapshot request not available\")\n\t}\n}\n\nfunc getPendingConfigChange(notifyCommit bool) (pendingConfigChange,\n\tchan configChangeRequest) {\n\tc := make(chan configChangeRequest, 1)\n\treturn newPendingConfigChange(c, notifyCommit), c\n}\n\nfunc TestRequestStateRelease(t *testing.T) {\n\trs := RequestState{\n\t\tkey:         100,\n\t\tclientID:    200,\n\t\tseriesID:    300,\n\t\trespondedTo: 400,\n\t\tdeadline:    500,\n\t\tnode:        &node{},\n\t\tpool:        &sync.Pool{},\n\t}\n\trs.readyToRead.set()\n\trs.readyToRelease.set()\n\texp := RequestState{pool: rs.pool}\n\trs.Release()\n\tif !reflect.DeepEqual(&exp, &rs) {\n\t\tt.Errorf(\"unexpected state, got %+v, want %+v\", rs, exp)\n\t}\n}\n\nfunc TestRequestStateSetToReadyToReleaseOnceNotified(t *testing.T) {\n\trs := RequestState{\n\t\tCompletedC: make(chan RequestResult, 1),\n\t}\n\tif rs.readyToRelease.ready() {\n\t\tt.Errorf(\"already ready?\")\n\t}\n\trs.notify(RequestResult{})\n\tif !rs.readyToRelease.ready() {\n\t\tt.Errorf(\"failed to set ready to release to ready\")\n\t}\n}\n\nfunc TestReleasingNotReadyRequestStateWillBeIgnored(t *testing.T) {\n\trs := RequestState{\n\t\tkey:         100,\n\t\tclientID:    200,\n\t\tseriesID:    300,\n\t\trespondedTo: 400,\n\t\tdeadline:    500,\n\t\tnode:        &node{},\n\t\tpool:        &sync.Pool{},\n\t}\n\trs.Release()\n\tif rs.key != 100 || rs.deadline != 500 {\n\t\tt.Fatalf(\"unexpectedly released\")\n\t}\n}\n\nfunc TestPendingConfigChangeCanBeCreatedAndClosed(t *testing.T) {\n\tpcc, c := getPendingConfigChange(false)\n\tselect {\n\tcase <-c:\n\t\tt.Errorf(\"unexpected content in confChangeC\")\n\tdefault:\n\t}\n\tpcc.close()\n\tselect {\n\tcase _, ok := <-c:\n\t\tif ok {\n\t\t\tt.Errorf(\"suppose to be closed\")\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"missing closed signal\")\n\t}\n}\n\nfunc TestCanNotMakeRequestOnClosedPendingConfigChange(t *testing.T) {\n\tpcc, _ := getPendingConfigChange(false)\n\tpcc.close()\n\tif _, err := pcc.request(pb.ConfigChange{}, 100); err != ErrShardClosed {\n\t\tt.Errorf(\"failed to return ErrShardClosed, %v\", err)\n\t}\n}\n\nfunc TestConfigChangeCanBeRequested(t *testing.T) {\n\tpcc, c := getPendingConfigChange(false)\n\tvar cc pb.ConfigChange\n\trs, err := pcc.request(cc, 100)\n\tif err != nil {\n\t\tt.Errorf(\"RequestConfigChange failed: %v\", err)\n\t}\n\tif rs == nil {\n\t\tt.Errorf(\"returned rs is nil\")\n\t}\n\tif pcc.pending == nil {\n\t\tt.Errorf(\"request not internally recorded\")\n\t}\n\tif len(c) != 1 {\n\t\tt.Errorf(\"len(c) = %d, want 1\", len(c))\n\t}\n\t_, err = pcc.request(cc, 100)\n\tif err == nil {\n\t\tt.Errorf(\"not expect to be success\")\n\t}\n\tif err != ErrSystemBusy {\n\t\tt.Errorf(\"expected ErrSystemBusy, %v\", err)\n\t}\n\tpcc.close()\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif !v.Terminated() {\n\t\t\tt.Errorf(\"returned %v, want %d\", v, requestTerminated)\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"expect to return something\")\n\t}\n}\n\nfunc TestPendingConfigChangeCanReturnBusy(t *testing.T) {\n\tpcc, _ := getPendingConfigChange(false)\n\tvar cc pb.ConfigChange\n\tif _, err := pcc.request(cc, 100); err != nil {\n\t\tt.Errorf(\"RequestConfigChange failed: %v\", err)\n\t}\n\tif _, err := pcc.request(cc, 100); err != ErrSystemBusy {\n\t\tt.Errorf(\"failed to return busy: %v\", err)\n\t}\n}\n\nfunc TestConfigChangeCanExpire(t *testing.T) {\n\tpcc, _ := getPendingConfigChange(false)\n\tvar cc pb.ConfigChange\n\ttickCount := uint64(100)\n\trs, err := pcc.request(cc, tickCount)\n\tif err != nil {\n\t\tt.Errorf(\"RequestConfigChange failed: %v\", err)\n\t}\n\tfor i := uint64(0); i < tickCount; i++ {\n\t\tpcc.tick(i)\n\t\tpcc.gc()\n\t}\n\tselect {\n\tcase <-rs.ResultC():\n\t\tt.Errorf(\"not suppose to has anything at this stage\")\n\tdefault:\n\t}\n\tfor i := uint64(0); i < defaultGCTick+1; i++ {\n\t\tpcc.tick(i + tickCount)\n\t\tpcc.gc()\n\t}\n\tselect {\n\tcase v, ok := <-rs.ResultC():\n\t\tif ok {\n\t\t\tif !v.Timeout() {\n\t\t\t\tt.Errorf(\"v: %v, expect %d\", v, requestTimeout)\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"expect to be expired\")\n\t}\n}\n\nfunc TestCommittedConfigChangeRequestCanBeNotified(t *testing.T) {\n\tpcc, _ := getPendingConfigChange(true)\n\tvar cc pb.ConfigChange\n\trs, err := pcc.request(cc, 100)\n\tif err != nil {\n\t\tt.Errorf(\"RequestConfigChange failed: %v\", err)\n\t}\n\tpcc.committed(rs.key)\n\tselect {\n\tcase <-rs.committedC:\n\tdefault:\n\t\tt.Fatalf(\"committedC not signalled\")\n\t}\n}\n\nfunc TestCompletedConfigChangeRequestCanBeNotified(t *testing.T) {\n\tpcc, _ := getPendingConfigChange(false)\n\tvar cc pb.ConfigChange\n\trs, err := pcc.request(cc, 100)\n\tif err != nil {\n\t\tt.Errorf(\"RequestConfigChange failed: %v\", err)\n\t}\n\tselect {\n\tcase <-rs.ResultC():\n\t\tt.Errorf(\"not suppose to return anything yet\")\n\tdefault:\n\t}\n\tpcc.apply(rs.key, false)\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif !v.Completed() {\n\t\t\tt.Errorf(\"returned %v, want %d\", v, requestCompleted)\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"suppose to return something\")\n\t}\n\tif pcc.pending != nil {\n\t\tt.Errorf(\"pending rec not cleared\")\n\t}\n}\n\nfunc TestConfigChangeRequestCanNotBeNotifiedWithDifferentKey(t *testing.T) {\n\tpcc, _ := getPendingConfigChange(false)\n\tvar cc pb.ConfigChange\n\trs, err := pcc.request(cc, 100)\n\tif err != nil {\n\t\tt.Errorf(\"RequestConfigChange failed: %v\", err)\n\t}\n\tselect {\n\tcase <-rs.ResultC():\n\t\tt.Errorf(\"not suppose to return anything yet\")\n\tdefault:\n\t}\n\tpcc.apply(rs.key+1, false)\n\tselect {\n\tcase <-rs.ResultC():\n\t\tt.Errorf(\"unexpectedly notified\")\n\tdefault:\n\t}\n\tif pcc.pending == nil {\n\t\tt.Errorf(\"pending rec unexpectedly cleared\")\n\t}\n}\n\nfunc TestConfigChangeCanBeDropped(t *testing.T) {\n\tpcc, _ := getPendingConfigChange(false)\n\tvar cc pb.ConfigChange\n\trs, err := pcc.request(cc, 100)\n\tif err != nil {\n\t\tt.Errorf(\"RequestConfigChange failed: %v\", err)\n\t}\n\tselect {\n\tcase <-rs.ResultC():\n\t\tt.Errorf(\"not suppose to return anything yet\")\n\tdefault:\n\t}\n\tpcc.dropped(rs.key)\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif !v.Dropped() {\n\t\t\tt.Errorf(\"Dropped() is false\")\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"not dropped\")\n\t}\n\tif pcc.pending != nil {\n\t\tt.Errorf(\"pending rec not cleared\")\n\t}\n}\n\nfunc TestConfigChangeWithDifferentKeyWillNotBeDropped(t *testing.T) {\n\tpcc, _ := getPendingConfigChange(false)\n\tvar cc pb.ConfigChange\n\trs, err := pcc.request(cc, 100)\n\tif err != nil {\n\t\tt.Errorf(\"RequestConfigChange failed: %v\", err)\n\t}\n\tselect {\n\tcase <-rs.ResultC():\n\t\tt.Errorf(\"not suppose to return anything yet\")\n\tdefault:\n\t}\n\tpcc.dropped(rs.key + 1)\n\tselect {\n\tcase <-rs.ResultC():\n\t\tt.Errorf(\"CompletedC unexpectedly set\")\n\tdefault:\n\t}\n\tif pcc.pending == nil {\n\t\tt.Errorf(\"pending rec unexpectedly cleared\")\n\t}\n}\n\n//\n// pending proposal\n//\n\nfunc getPendingProposal(notifyCommit bool) (pendingProposal, *entryQueue) {\n\tc := newEntryQueue(5, 0)\n\tp := &sync.Pool{}\n\tp.New = func() interface{} {\n\t\tobj := &RequestState{}\n\t\tobj.pool = p\n\t\tobj.CompletedC = make(chan RequestResult, 1)\n\t\tif notifyCommit {\n\t\t\tobj.committedC = make(chan RequestResult, 1)\n\t\t}\n\t\treturn obj\n\t}\n\tcfg := config.Config{ShardID: 100, ReplicaID: 120}\n\treturn newPendingProposal(cfg, notifyCommit, p, c), c\n}\n\nfunc getBlankTestSession() *client.Session {\n\treturn &client.Session{}\n}\n\nfunc TestPendingProposalCanBeCreatedAndClosed(t *testing.T) {\n\tpp, c := getPendingProposal(false)\n\tif len(c.get(false)) > 0 {\n\t\tt.Errorf(\"unexpected item in entry queue\")\n\t}\n\tpp.close()\n\tif !c.stopped {\n\t\tt.Errorf(\"entry queue not closed\")\n\t}\n}\n\nfunc countPendingProposal(p pendingProposal) int {\n\ttotal := 0\n\tfor i := uint64(0); i < p.ps; i++ {\n\t\ttotal += len(p.shards[i].pending)\n\t}\n\treturn total\n}\n\n// TODO:\n// the test below uses at least 8GBs RAM, move it to a more suitable place\n// and re-enable it\n\n/*\nfunc TestLargeProposalCanBeProposed(t *testing.T) {\n\tpp, _ := getPendingProposal()\n\tdata := make([]byte, 8*1024*1024*1024)\n\t_, err := pp.propose(getBlankTestSession(), data, nil, time.Second)\n\tif err != nil {\n\t\tt.Errorf(\"failed to make proposal, %v\", err)\n\t}\n\tpp, _ = getPendingProposal()\n\tfor idx := range pp.shards {\n\t\tpp.shards[idx].cfg = config.Config{EntryCompressionType: config.Snappy}\n\t}\n\tdata = make([]byte, 6*(0xffffffff-32)/7)\n\t_, err = pp.propose(getBlankTestSession(), data, nil, time.Second)\n\tif err != nil {\n\t\tt.Errorf(\"failed to make proposal, %v\", err)\n\t}\n\tdata = make([]byte, 6*(0xffffffff-32)/7+1)\n\t_, err = pp.propose(getBlankTestSession(), data, nil, time.Second)\n\tif err != ErrPayloadTooBig {\n\t\tt.Errorf(\"failed to return the expected error, %v\", err)\n\t}\n}*/\n\nfunc TestProposalCanBeProposed(t *testing.T) {\n\tpp, c := getPendingProposal(false)\n\trs, err := pp.propose(getBlankTestSession(), []byte(\"test data\"), 100)\n\tif err != nil {\n\t\tt.Errorf(\"failed to make proposal, %v\", err)\n\t}\n\tif countPendingProposal(pp) != 1 {\n\t\tt.Errorf(\"len(pending)=%d, want 1\", countPendingProposal(pp))\n\t}\n\tselect {\n\tcase <-rs.ResultC():\n\t\tt.Errorf(\"not suppose to have anything completed\")\n\tdefault:\n\t}\n\tq := c.get(false)\n\tif len(q) != 1 {\n\t\tt.Errorf(\"len(c)=%d, want 1\", len(q))\n\t}\n\tpp.close()\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif !v.Terminated() {\n\t\t\tt.Errorf(\"get %v, want %d\", v, requestTerminated)\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"suppose to return terminated\")\n\t}\n}\n\nfunc TestProposeOnClosedPendingProposalReturnError(t *testing.T) {\n\tpp, _ := getPendingProposal(false)\n\tpp.close()\n\t_, err := pp.propose(getBlankTestSession(), []byte(\"test data\"), 100)\n\tif err != ErrShardClosed {\n\t\tt.Errorf(\"unexpected err %v\", err)\n\t}\n}\n\nfunc TestProposalCanBeCompleted(t *testing.T) {\n\tpp, _ := getPendingProposal(false)\n\trs, err := pp.propose(getBlankTestSession(), []byte(\"test data\"), 100)\n\tif err != nil {\n\t\tt.Errorf(\"failed to make proposal, %v\", err)\n\t}\n\tpp.applied(rs.clientID, rs.seriesID, rs.key+1, sm.Result{}, false)\n\tselect {\n\tcase <-rs.ResultC():\n\t\tt.Errorf(\"unexpected applied proposal with invalid client ID\")\n\tdefault:\n\t}\n\tif countPendingProposal(pp) == 0 {\n\t\tt.Errorf(\"pending is empty\")\n\t}\n\tpp.applied(rs.clientID, rs.seriesID, rs.key, sm.Result{}, false)\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif !v.Completed() {\n\t\t\tt.Errorf(\"get %v, want %d\", v, requestCompleted)\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"expect to get complete signal\")\n\t}\n\tif countPendingProposal(pp) != 0 {\n\t\tt.Errorf(\"pending is not empty\")\n\t}\n}\n\nfunc TestProposalCanBeDropped(t *testing.T) {\n\tpp, _ := getPendingProposal(false)\n\trs, err := pp.propose(getBlankTestSession(), []byte(\"test data\"), 100)\n\tif err != nil {\n\t\tt.Errorf(\"failed to make proposal, %v\", err)\n\t}\n\tpp.dropped(rs.clientID, rs.seriesID, rs.key)\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif !v.Dropped() {\n\t\t\tt.Errorf(\"not dropped\")\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"not notified\")\n\t}\n\tfor _, shard := range pp.shards {\n\t\tif len(shard.pending) > 0 {\n\t\t\tt.Errorf(\"pending request not cleared\")\n\t\t}\n\t}\n}\n\nfunc TestProposalResultCanBeObtainedByCaller(t *testing.T) {\n\tpp, _ := getPendingProposal(false)\n\trs, err := pp.propose(getBlankTestSession(), []byte(\"test data\"), 100)\n\tif err != nil {\n\t\tt.Errorf(\"failed to make proposal, %v\", err)\n\t}\n\tresult := sm.Result{\n\t\tValue: 1234,\n\t\tData:  make([]byte, 128),\n\t}\n\trand.Read(result.Data)\n\tpp.applied(rs.clientID, rs.seriesID, rs.key, result, false)\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif !v.Completed() {\n\t\t\tt.Errorf(\"get %v, want %d\", v, requestCompleted)\n\t\t}\n\t\tr := v.GetResult()\n\t\tif !reflect.DeepEqual(&r, &result) {\n\t\t\tt.Errorf(\"result changed\")\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"expect to get complete signal\")\n\t}\n}\n\nfunc TestClientIDIsCheckedWhenApplyingProposal(t *testing.T) {\n\tpp, _ := getPendingProposal(false)\n\trs, err := pp.propose(getBlankTestSession(), []byte(\"test data\"), 100)\n\tif err != nil {\n\t\tt.Errorf(\"failed to make proposal, %v\", err)\n\t}\n\tpp.applied(rs.clientID+1, rs.seriesID, rs.key, sm.Result{}, false)\n\tselect {\n\tcase <-rs.ResultC():\n\t\tt.Errorf(\"unexpected applied proposal with invalid client ID\")\n\tdefault:\n\t}\n\tif countPendingProposal(pp) == 0 {\n\t\tt.Errorf(\"pending is empty\")\n\t}\n\tpp.applied(rs.clientID, rs.seriesID, rs.key, sm.Result{}, false)\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif !v.Completed() {\n\t\t\tt.Errorf(\"get %v, want %d\", v, requestCompleted)\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"expect to get complete signal\")\n\t}\n\tif countPendingProposal(pp) != 0 {\n\t\tt.Errorf(\"pending is not empty\")\n\t}\n}\n\nfunc TestSeriesIDIsCheckedWhenApplyingProposal(t *testing.T) {\n\tpp, _ := getPendingProposal(false)\n\trs, err := pp.propose(getBlankTestSession(), []byte(\"test data\"), 100)\n\tif err != nil {\n\t\tt.Errorf(\"failed to make proposal, %v\", err)\n\t}\n\tpp.applied(rs.clientID, rs.seriesID+1, rs.key, sm.Result{}, false)\n\tselect {\n\tcase <-rs.ResultC():\n\t\tt.Errorf(\"unexpected applied proposal with invalid client ID\")\n\tdefault:\n\t}\n\tif countPendingProposal(pp) == 0 {\n\t\tt.Errorf(\"pending is empty\")\n\t}\n\tpp.applied(rs.clientID, rs.seriesID, rs.key, sm.Result{}, false)\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif !v.Completed() {\n\t\t\tt.Errorf(\"get %v, want %d\", v, requestCompleted)\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"expect to get complete signal\")\n\t}\n\tif countPendingProposal(pp) != 0 {\n\t\tt.Errorf(\"pending is not empty\")\n\t}\n}\n\nfunc TestProposalCanBeCommitted(t *testing.T) {\n\tpp, _ := getPendingProposal(true)\n\trs, err := pp.propose(getBlankTestSession(), []byte(\"test data\"), 100)\n\tif err != nil {\n\t\tt.Errorf(\"failed to make proposal, %v\", err)\n\t}\n\tpp.committed(rs.clientID, rs.seriesID, rs.key)\n\tselect {\n\tcase <-rs.committedC:\n\tdefault:\n\t\tt.Errorf(\"not committed\")\n\t}\n\tif countPendingProposal(pp) == 0 {\n\t\tt.Errorf(\"pending is empty\")\n\t}\n\tpp.applied(rs.clientID, rs.seriesID, rs.key, sm.Result{}, false)\n\tselect {\n\tcase v := <-rs.AppliedC():\n\t\tif !v.Completed() {\n\t\t\tt.Errorf(\"get %v, want %d\", v, requestCompleted)\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"expect to get complete signal\")\n\t}\n\tif countPendingProposal(pp) != 0 {\n\t\tt.Errorf(\"pending is not empty\")\n\t}\n}\n\nfunc TestProposalCanBeExpired(t *testing.T) {\n\tpp, _ := getPendingProposal(false)\n\ttickCount := uint64(100)\n\trs, err := pp.propose(getBlankTestSession(), []byte(\"test data\"), tickCount)\n\tif err != nil {\n\t\tt.Errorf(\"failed to make proposal, %v\", err)\n\t}\n\tfor i := uint64(0); i < tickCount; i++ {\n\t\tpp.tick(i)\n\t\tpp.gc()\n\t}\n\tselect {\n\tcase <-rs.ResultC():\n\t\tt.Errorf(\"not suppose to return anything\")\n\tdefault:\n\t}\n\tfor i := uint64(0); i < defaultGCTick+1; i++ {\n\t\tpp.tick(i + tickCount)\n\t\tpp.gc()\n\t}\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif !v.Timeout() {\n\t\t\tt.Errorf(\"got %v, want %d\", v, requestTimeout)\n\t\t}\n\tdefault:\n\t}\n\tif countPendingProposal(pp) != 0 {\n\t\tt.Errorf(\"pending/keys is not empty\")\n\t}\n}\n\nfunc TestProposalErrorsAreReported(t *testing.T) {\n\tpp, c := getPendingProposal(false)\n\tfor i := 0; i < 5; i++ {\n\t\t_, err := pp.propose(getBlankTestSession(), []byte(\"test data\"), 100)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"propose failed\")\n\t\t}\n\t}\n\tvar cq []pb.Entry\n\tif c.leftInWrite {\n\t\tcq = c.left\n\t} else {\n\t\tcq = c.right\n\t}\n\tsz := len(cq)\n\t_, err := pp.propose(getBlankTestSession(), []byte(\"test data\"), 100)\n\tif err != ErrSystemBusy {\n\t\tt.Errorf(\"suppose to return ErrSystemBusy\")\n\t}\n\tif c.leftInWrite {\n\t\tcq = c.left\n\t} else {\n\t\tcq = c.right\n\t}\n\tif len(cq) != sz {\n\t\tt.Errorf(\"len(c)=%d, want %d\", len(cq), sz)\n\t}\n}\n\nfunc TestClosePendingProposalIgnoresStepEngineActivities(t *testing.T) {\n\tpp, _ := getPendingProposal(false)\n\tsession := &client.Session{\n\t\tClientID:    100,\n\t\tSeriesID:    200,\n\t\tRespondedTo: 199,\n\t}\n\trs, _ := pp.propose(session, nil, 100)\n\tselect {\n\tcase <-rs.ResultC():\n\t\tt.Fatalf(\"completedC is already signalled\")\n\tdefault:\n\t}\n\tfor i := uint64(0); i < pp.ps; i++ {\n\t\tpp.shards[i].stopped = true\n\t}\n\tpp.applied(rs.clientID, rs.seriesID, rs.key, sm.Result{Value: 1}, false)\n\tselect {\n\tcase <-rs.ResultC():\n\t\tt.Fatalf(\"completedC unexpectedly signaled\")\n\tdefault:\n\t}\n}\n\nfunc getPendingReadIndex() (pendingReadIndex, *readIndexQueue) {\n\tq := newReadIndexQueue(5)\n\tp := &sync.Pool{}\n\tp.New = func() interface{} {\n\t\tobj := &RequestState{}\n\t\tobj.pool = p\n\t\tobj.CompletedC = make(chan RequestResult, 1)\n\t\treturn obj\n\t}\n\treturn newPendingReadIndex(p, q), q\n}\n\nfunc TestPendingReadIndexCanBeCreatedAndClosed(t *testing.T) {\n\tpp, c := getPendingReadIndex()\n\tif len(c.get()) > 0 {\n\t\tt.Errorf(\"unexpected content\")\n\t}\n\tpp.close()\n\tif !c.stopped {\n\t\tt.Errorf(\"not closed\")\n\t}\n}\n\nfunc TestCanNotMakeRequestOnClosedPendingReadIndex(t *testing.T) {\n\tpp, _ := getPendingReadIndex()\n\tpp.close()\n\tif _, err := pp.read(100); err != ErrShardClosed {\n\t\tt.Errorf(\"failed to return ErrShardClosed %v\", err)\n\t}\n}\n\nfunc TestPendingReadIndexCanRead(t *testing.T) {\n\tpp, c := getPendingReadIndex()\n\trs, err := pp.read(100)\n\tif err != nil {\n\t\tt.Errorf(\"failed to do read\")\n\t}\n\tselect {\n\tcase <-rs.ResultC():\n\t\tt.Errorf(\"not suppose to return anything\")\n\tdefault:\n\t}\n\tvar q []*RequestState\n\tif c.leftInWrite {\n\t\tq = c.left[:c.idx]\n\t} else {\n\t\tq = c.right[:c.idx]\n\t}\n\tif len(q) != 1 {\n\t\tt.Errorf(\"read request not sent\")\n\t}\n\tif pp.requests.pendingSize() != 1 {\n\t\tt.Errorf(\"req not recorded in temp\")\n\t}\n\tif len(pp.batches) != 0 {\n\t\tt.Errorf(\"pending is expected to be empty\")\n\t}\n\tpp.close()\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif !v.Terminated() {\n\t\t\tt.Errorf(\"got %v, want %d\", v, requestTerminated)\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"not expected to be signaled\")\n\t}\n}\n\nfunc TestPendingReadIndexCanReturnBusy(t *testing.T) {\n\tpri, _ := getPendingReadIndex()\n\tfor i := 0; i < 6; i++ {\n\t\t_, err := pri.read(100)\n\t\tif i != 5 && err != nil {\n\t\t\tt.Errorf(\"failed to do read\")\n\t\t}\n\t\tif i == 5 && err != ErrSystemBusy {\n\t\t\tt.Errorf(\"failed to return ErrSystemBusy\")\n\t\t}\n\t}\n}\n\nfunc TestPendingReadIndexCanComplete(t *testing.T) {\n\tpp, _ := getPendingReadIndex()\n\trs, err := pp.read(100)\n\tif err != nil {\n\t\tt.Errorf(\"failed to do read\")\n\t}\n\ts := pp.nextCtx()\n\tpp.add(s, []*RequestState{rs})\n\treadState := pb.ReadyToRead{Index: 500, SystemCtx: s}\n\tpp.addReady([]pb.ReadyToRead{readState})\n\tpp.applied(499)\n\tselect {\n\tcase <-rs.ResultC():\n\t\tt.Errorf(\"not expected to be signaled\")\n\tdefault:\n\t}\n\tif rs.readyToRead.ready() {\n\t\tt.Errorf(\"ready is already set\")\n\t}\n\tpp.applied(500)\n\tif !rs.readyToRead.ready() {\n\t\tt.Errorf(\"ready not set\")\n\t}\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif !v.Completed() {\n\t\t\tt.Errorf(\"got %v, want %d\", v, requestCompleted)\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"expect to complete\")\n\t}\n\tif len(pp.batches) != 0 {\n\t\tt.Errorf(\"leaking records\")\n\t}\n}\n\nfunc TestPendingReadIndexCanBeDropped(t *testing.T) {\n\tpp, _ := getPendingReadIndex()\n\trs, err := pp.read(100)\n\tif err != nil {\n\t\tt.Errorf(\"failed to do read\")\n\t}\n\ts := pp.nextCtx()\n\tpp.add(s, []*RequestState{rs})\n\tpp.dropped(s)\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif !v.Dropped() {\n\t\t\tt.Errorf(\"got %v, want %d\", v, requestDropped)\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"expect to complete\")\n\t}\n\tif len(pp.batches) > 0 {\n\t\tt.Errorf(\"not cleared\")\n\t}\n}\n\nfunc testPendingReadIndexCanExpire(t *testing.T, addReady bool) {\n\tpp, _ := getPendingReadIndex()\n\trs, err := pp.read(100)\n\tif err != nil {\n\t\tt.Errorf(\"failed to do read\")\n\t}\n\ts := pp.nextCtx()\n\tpp.add(s, []*RequestState{rs})\n\tif addReady {\n\t\treadState := pb.ReadyToRead{Index: 500, SystemCtx: s}\n\t\tpp.addReady([]pb.ReadyToRead{readState})\n\t}\n\ttickToWait := 100 + defaultGCTick + 1\n\tfor i := uint64(0); i < tickToWait; i++ {\n\t\tpp.tick(i)\n\t\tpp.applied(499)\n\t}\n\tselect {\n\tcase v := <-rs.ResultC():\n\t\tif !v.Timeout() {\n\t\t\tt.Errorf(\"got %v, want %d\", v, requestTimeout)\n\t\t}\n\tdefault:\n\t\tt.Errorf(\"expect to complete\")\n\t}\n\tif len(pp.batches) != 0 {\n\t\tt.Errorf(\"leaking records\")\n\t}\n}\n\nfunc TestPendingReadIndexCanExpire(t *testing.T) {\n\ttestPendingReadIndexCanExpire(t, true)\n}\n\nfunc TestPendingReadIndexCanExpireWithoutCallingAddReady(t *testing.T) {\n\ttestPendingReadIndexCanExpire(t, false)\n}\n\nfunc TestNonEmptyReadBatchIsNeverExpired(t *testing.T) {\n\tpp, _ := getPendingReadIndex()\n\trs, err := pp.read(10000)\n\tif err != nil {\n\t\tt.Errorf(\"failed to do read\")\n\t}\n\ts := pp.nextCtx()\n\tpp.add(s, []*RequestState{rs})\n\tif len(pp.batches) != 1 {\n\t\tt.Fatalf(\"unexpected batch count\")\n\t}\n\ttickToWait := defaultGCTick * 10\n\tfor i := uint64(0); i < tickToWait; i++ {\n\t\tpp.tick(i)\n\t\tpp.applied(499)\n\t}\n\tif len(pp.batches) == 0 {\n\t\tt.Fatalf(\"unexpectedly removed batch\")\n\t}\n}\n\nfunc TestProposalAllocationCount(t *testing.T) {\n\tsz := 128\n\tdata := make([]byte, sz)\n\tp := &sync.Pool{}\n\tp.New = func() interface{} {\n\t\tobj := &RequestState{}\n\t\tobj.CompletedC = make(chan RequestResult, 1)\n\t\tobj.pool = p\n\t\treturn obj\n\t}\n\ttotal := uint32(0)\n\tq := newEntryQueue(2048, 0)\n\tcfg := config.Config{ShardID: 1, ReplicaID: 1}\n\tpp := newPendingProposal(cfg, false, p, q)\n\tsession := client.NewNoOPSession(1, random.LockGuardedRand)\n\tac := testing.AllocsPerRun(10000, func() {\n\t\tv := atomic.AddUint32(&total, 1)\n\t\trs, err := pp.propose(session, data, 100)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%v\", err)\n\t\t}\n\t\tif v%128 == 0 {\n\t\t\tatomic.StoreUint32(&total, 0)\n\t\t\tq.get(false)\n\t\t}\n\t\tpp.applied(rs.key, rs.clientID, rs.seriesID, sm.Result{Value: 1}, false)\n\t\trs.readyToRelease.set()\n\t\trs.Release()\n\t})\n\tif ac > 1 {\n\t\tt.Fatalf(\"ac %f, want <=1\", ac)\n\t}\n}\n\nfunc TestReadIndexAllocationCount(t *testing.T) {\n\tp := &sync.Pool{}\n\tp.New = func() interface{} {\n\t\tobj := &RequestState{}\n\t\tobj.CompletedC = make(chan RequestResult, 1)\n\t\tobj.pool = p\n\t\treturn obj\n\t}\n\ttotal := uint32(0)\n\tq := newReadIndexQueue(2048)\n\tpri := newPendingReadIndex(p, q)\n\tac := testing.AllocsPerRun(10000, func() {\n\t\tv := atomic.AddUint32(&total, 1)\n\t\trs, err := pri.read(100)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%v\", err)\n\t\t}\n\t\tif v%128 == 0 {\n\t\t\tatomic.StoreUint32(&total, 0)\n\t\t\tq.get()\n\t\t}\n\t\trs.readyToRelease.set()\n\t\trs.Release()\n\t})\n\tif ac != 0 {\n\t\tt.Fatalf(\"ac %f, want 0\", ac)\n\t}\n}\n\nfunc TestPendingRaftLogQueryCanBeCreated(t *testing.T) {\n\tp := newPendingRaftLogQuery()\n\tassert.Nil(t, p.mu.pending)\n}\n\nfunc TestPendingRaftLogQueryCanBeClosed(t *testing.T) {\n\tp := newPendingRaftLogQuery()\n\trs, err := p.add(100, 200, 300)\n\tassert.NoError(t, err)\n\tassert.NotNil(t, p.mu.pending)\n\tp.close()\n\tassert.Nil(t, p.mu.pending)\n\tselect {\n\tcase v := <-rs.CompletedC:\n\t\tassert.True(t, v.Terminated())\n\tdefault:\n\t\tt.Fatalf(\"not terminated\")\n\t}\n}\n\nfunc TestPendingRaftLogQueryCanAddRequest(t *testing.T) {\n\tp := newPendingRaftLogQuery()\n\trs, err := p.add(100, 200, 300)\n\tassert.NotNil(t, rs)\n\tassert.NoError(t, err)\n\trs, err = p.add(200, 200, 300)\n\tassert.Equal(t, ErrSystemBusy, err)\n\tassert.Nil(t, rs)\n\tassert.NotNil(t, p.mu.pending)\n\tassert.Equal(t, LogRange{FirstIndex: 100, LastIndex: 200}, p.mu.pending.logRange)\n\tassert.Equal(t, uint64(300), p.mu.pending.maxSize)\n\tassert.NotNil(t, p.mu.pending.CompletedC)\n}\n\nfunc TestPendingRaftLogQueryGet(t *testing.T) {\n\tp := newPendingRaftLogQuery()\n\tassert.Nil(t, p.get())\n\trs, err := p.add(100, 200, 300)\n\tassert.NoError(t, err)\n\tassert.NotNil(t, p.mu.pending)\n\tresult := p.get()\n\tassert.Equal(t, rs, result)\n\tassert.Equal(t, LogRange{FirstIndex: 100, LastIndex: 200}, result.logRange)\n\tassert.Equal(t, uint64(300), result.maxSize)\n\tassert.NotNil(t, result.CompletedC)\n}\n\nfunc TestPendingRaftLogQueryGetWhenReturnedIsCalledWithoutPendingRequest(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Fatalf(\"failed to panic\")\n\t\t}\n\t}()\n\tp := newPendingRaftLogQuery()\n\tp.returned(false, LogRange{}, nil)\n}\n\nfunc TestPendingRaftLogQueryCanReturnOutOfRangeError(t *testing.T) {\n\tp := newPendingRaftLogQuery()\n\trs, err := p.add(100, 200, 300)\n\tassert.NoError(t, err)\n\tlr := LogRange{FirstIndex: 150, LastIndex: 200}\n\tp.returned(true, lr, nil)\n\tselect {\n\tcase v := <-rs.CompletedC:\n\t\tassert.True(t, v.RequestOutOfRange())\n\t\t_, rrl := v.RaftLogs()\n\t\tassert.Equal(t, lr, rrl)\n\tdefault:\n\t\tt.Fatalf(\"no result available\")\n\t}\n}\n\nfunc TestPendingRaftLogQueryCanReturnResults(t *testing.T) {\n\tp := newPendingRaftLogQuery()\n\trs, err := p.add(100, 200, 300)\n\tassert.NoError(t, err)\n\tentries := []pb.Entry{{Index: 1}, {Index: 2}}\n\tlr := LogRange{FirstIndex: 100, LastIndex: 180}\n\tp.returned(false, lr, entries)\n\tselect {\n\tcase v := <-rs.CompletedC:\n\t\tassert.True(t, v.Completed())\n\t\trentries, rrl := v.RaftLogs()\n\t\tassert.Equal(t, lr, rrl)\n\t\tassert.Equal(t, entries, rentries)\n\tdefault:\n\t\tt.Fatalf(\"no result available\")\n\t}\n}\n"
        },
        {
          "name": "snapshotstate.go",
          "type": "blob",
          "size": 5.5224609375,
          "content": "// Copyright 2017-2020 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dragonboat\n\nimport (\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"github.com/lni/goutils/random\"\n\n\t\"github.com/lni/dragonboat/v4/internal/rsm\"\n\tpb \"github.com/lni/dragonboat/v4/raftpb\"\n)\n\ntype getSink func() pb.IChunkSink\n\ntype snapshotTask struct {\n\tmu        sync.Mutex\n\tgetSinkFn getSink\n\tt         rsm.Task\n\thasTask   bool\n}\n\nfunc (sr *snapshotTask) setStreamTask(t rsm.Task, getSinkFn getSink) {\n\tsr.mu.Lock()\n\tdefer sr.mu.Unlock()\n\tif sr.hasTask {\n\t\tplog.Panicf(\"setting stream snapshot task again %+v\\n%+v\", sr.t, t)\n\t}\n\tsr.hasTask = true\n\tsr.t = t\n\tsr.getSinkFn = getSinkFn\n}\n\nfunc (sr *snapshotTask) setTask(t rsm.Task) {\n\tsr.mu.Lock()\n\tdefer sr.mu.Unlock()\n\tif sr.hasTask {\n\t\tplog.Panicf(\"setting snapshot task again %+v\\n%+v\", sr.t, t)\n\t}\n\tsr.hasTask = true\n\tsr.t = t\n}\n\nfunc (sr *snapshotTask) getTask() (rsm.Task, bool) {\n\tsr.mu.Lock()\n\tdefer sr.mu.Unlock()\n\thasTask := sr.hasTask\n\tsr.hasTask = false\n\treturn sr.t, hasTask\n}\n\ntype snapshotState struct {\n\tsnapshotIndex    uint64\n\treqSnapshotIndex uint64\n\tcompactLogTo     uint64\n\tcompactedTo      uint64\n\tsavingFlag       uint32\n\trecoveringFlag   uint32\n\tstreamingFlag    uint32\n\trecoverReady     snapshotTask\n\tsaveReady        snapshotTask\n\tstreamReady      snapshotTask\n\trecoverCompleted snapshotTask\n\tsaveCompleted    snapshotTask\n\tstreamCompleted  snapshotTask\n}\n\nfunc (rs *snapshotState) recovering() bool {\n\treturn atomic.LoadUint32(&rs.recoveringFlag) == 1\n}\n\nfunc (rs *snapshotState) setRecovering() {\n\tatomic.StoreUint32(&rs.recoveringFlag, 1)\n}\n\nfunc (rs *snapshotState) clearRecovering() {\n\tatomic.StoreUint32(&rs.recoveringFlag, 0)\n}\n\nfunc (rs *snapshotState) streaming() bool {\n\treturn atomic.LoadUint32(&rs.streamingFlag) == 1\n}\n\nfunc (rs *snapshotState) setStreaming() {\n\tatomic.StoreUint32(&rs.streamingFlag, 1)\n}\n\nfunc (rs *snapshotState) clearStreaming() {\n\tatomic.StoreUint32(&rs.streamingFlag, 0)\n}\n\nfunc (rs *snapshotState) saving() bool {\n\treturn atomic.LoadUint32(&rs.savingFlag) == 1\n}\n\nfunc (rs *snapshotState) setSaving() {\n\tatomic.StoreUint32(&rs.savingFlag, 1)\n}\n\nfunc (rs *snapshotState) clearSaving() {\n\tatomic.StoreUint32(&rs.savingFlag, 0)\n}\n\nfunc (rs *snapshotState) setIndex(index uint64) {\n\tatomic.StoreUint64(&rs.snapshotIndex, index)\n}\n\nfunc (rs *snapshotState) getIndex() uint64 {\n\treturn atomic.LoadUint64(&rs.snapshotIndex)\n}\n\nfunc (rs *snapshotState) getReqIndex() uint64 {\n\treturn atomic.LoadUint64(&rs.reqSnapshotIndex)\n}\n\nfunc (rs *snapshotState) setReqIndex(idx uint64) {\n\tatomic.StoreUint64(&rs.reqSnapshotIndex, idx)\n}\n\nfunc (rs *snapshotState) hasCompactLogTo() bool {\n\treturn atomic.LoadUint64(&rs.compactLogTo) > 0\n}\n\nfunc (rs *snapshotState) getCompactLogTo() uint64 {\n\treturn atomic.SwapUint64(&rs.compactLogTo, 0)\n}\n\nfunc (rs *snapshotState) setCompactLogTo(v uint64) {\n\tatomic.StoreUint64(&rs.compactLogTo, v)\n}\n\nfunc (rs *snapshotState) setCompactedTo(v uint64) {\n\tatomic.StoreUint64(&rs.compactedTo, v)\n}\n\nfunc (rs *snapshotState) getCompactedTo() uint64 {\n\treturn atomic.SwapUint64(&rs.compactedTo, 0)\n}\n\nfunc (rs *snapshotState) hasCompactedTo() bool {\n\treturn atomic.LoadUint64(&rs.compactedTo) > 0\n}\n\nfunc (rs *snapshotState) setStreamReq(t rsm.Task, fn getSink) {\n\trs.streamReady.setStreamTask(t, fn)\n}\n\nfunc (rs *snapshotState) setRecoverReq(t rsm.Task) {\n\trs.recoverReady.setTask(t)\n}\n\nfunc (rs *snapshotState) getRecoverReq() (rsm.Task, bool) {\n\treturn rs.recoverReady.getTask()\n}\n\nfunc (rs *snapshotState) setSaveReq(t rsm.Task) {\n\trs.saveReady.setTask(t)\n}\n\nfunc (rs *snapshotState) getSaveReq() (rsm.Task, bool) {\n\treturn rs.saveReady.getTask()\n}\n\nfunc (rs *snapshotState) getStreamReq() (rsm.Task, getSink, bool) {\n\tr, ok := rs.streamReady.getTask()\n\tif !ok {\n\t\treturn rsm.Task{}, nil, false\n\t}\n\treturn r, rs.streamReady.getSinkFn, true\n}\n\nfunc (rs *snapshotState) notifySnapshotStatus(save bool,\n\trecover bool, stream bool, initial bool, index uint64) {\n\tcount := 0\n\tif save {\n\t\tcount++\n\t}\n\tif recover {\n\t\tcount++\n\t}\n\tif stream {\n\t\tcount++\n\t}\n\tif count != 1 {\n\t\tplog.Panicf(\"invalid request, save %t, recover %t, stream %t\",\n\t\t\tsave, recover, stream)\n\t}\n\tt := rsm.Task{\n\t\tSave:    save,\n\t\tRecover: recover,\n\t\tStream:  stream,\n\t\tInitial: initial,\n\t\tIndex:   index,\n\t}\n\tif save {\n\t\trs.saveCompleted.setTask(t)\n\t} else if recover {\n\t\trs.recoverCompleted.setTask(t)\n\t} else {\n\t\trs.streamCompleted.setTask(t)\n\t}\n}\n\nfunc (rs *snapshotState) getStreamCompleted() (rsm.Task, bool) {\n\treturn rs.streamCompleted.getTask()\n}\n\nfunc (rs *snapshotState) getRecoverCompleted() (rsm.Task, bool) {\n\treturn rs.recoverCompleted.getTask()\n}\n\nfunc (rs *snapshotState) getSaveCompleted() (rsm.Task, bool) {\n\treturn rs.saveCompleted.getTask()\n}\n\ntype task struct {\n\tintervalMs uint64\n\tlastRun    uint64\n}\n\nfunc newTask(interval uint64) task {\n\tif interval == 0 {\n\t\tpanic(\"invalid interval\")\n\t}\n\treturn task{\n\t\tintervalMs: interval,\n\t\tlastRun:    random.LockGuardedRand.Uint64() % interval,\n\t}\n}\n\nfunc (t *task) timeToRun(tt uint64) bool {\n\tif tt-t.lastRun >= t.intervalMs {\n\t\tt.lastRun = tt\n\t\treturn true\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "snapshotstate_test.go",
          "type": "blob",
          "size": 2.248046875,
          "content": "// Copyright 2017-2020 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dragonboat\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/lni/goutils/leaktest\"\n\n\t\"github.com/lni/dragonboat/v4/internal/rsm\"\n\tpb \"github.com/lni/dragonboat/v4/raftpb\"\n)\n\nfunc TestSnapshotTaskCanBeSet(t *testing.T) {\n\tdefer leaktest.AfterTest(t)()\n\tsr := snapshotTask{}\n\trec := rsm.Task{}\n\tsr.setTask(rec)\n\tif !sr.hasTask {\n\t\tt.Errorf(\"rec not set\")\n\t}\n}\n\nfunc TestSnapshotTaskCanNotBeSetTwice(t *testing.T) {\n\tdefer leaktest.AfterTest(t)()\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\treturn\n\t\t}\n\t\tt.Errorf(\"panic not triggered\")\n\t}()\n\tsr := snapshotTask{}\n\trec := rsm.Task{}\n\tsr.setTask(rec)\n\tsr.setTask(rec)\n}\n\nfunc TestCanGetSnapshotTask(t *testing.T) {\n\tdefer leaktest.AfterTest(t)()\n\tsr := snapshotTask{}\n\tif _, ok := sr.getTask(); ok {\n\t\tt.Errorf(\"unexpected record\")\n\t}\n\trec := rsm.Task{}\n\tsr.setTask(rec)\n\tr, ok := sr.getTask()\n\tif !ok {\n\t\tt.Errorf(\"no record to get\")\n\t}\n\tif !reflect.DeepEqual(&rec, &r) {\n\t\tt.Errorf(\"unexpected rec\")\n\t}\n\trec, ok = sr.getTask()\n\tif ok {\n\t\tt.Errorf(\"record is still available\")\n\t}\n}\n\nfunc TestStreamTaskCanBeSet(t *testing.T) {\n\tdefer leaktest.AfterTest(t)()\n\tsr := snapshotTask{}\n\trec := rsm.Task{}\n\tfn := func() pb.IChunkSink { return nil }\n\tsr.setStreamTask(rec, fn)\n\tif !sr.hasTask || !reflect.DeepEqual(&(sr.t), &rec) || sr.getSinkFn == nil {\n\t\tt.Errorf(\"failed to set stream task\")\n\t}\n}\n\nfunc TestStreamTaskCanNotBeSetTwice(t *testing.T) {\n\tdefer leaktest.AfterTest(t)()\n\tsr := snapshotTask{}\n\trec := rsm.Task{}\n\tfn := func() pb.IChunkSink { return nil }\n\tsr.setStreamTask(rec, fn)\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Fatalf(\"failed to trigger panic\")\n\t\t}\n\t}()\n\tsr.setStreamTask(rec, fn)\n}\n"
        },
        {
          "name": "snapshotter.go",
          "type": "blob",
          "size": 10.4169921875,
          "content": "// Copyright 2017-2021 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dragonboat\n\nimport (\n\t\"strconv\"\n\n\t\"github.com/cockroachdb/errors\"\n\t\"github.com/lni/goutils/logutil\"\n\n\t\"github.com/lni/dragonboat/v4/internal/fileutil\"\n\t\"github.com/lni/dragonboat/v4/internal/logdb\"\n\t\"github.com/lni/dragonboat/v4/internal/rsm\"\n\t\"github.com/lni/dragonboat/v4/internal/server\"\n\t\"github.com/lni/dragonboat/v4/internal/utils/dio\"\n\t\"github.com/lni/dragonboat/v4/internal/vfs\"\n\t\"github.com/lni/dragonboat/v4/raftio\"\n\tpb \"github.com/lni/dragonboat/v4/raftpb\"\n\tsm \"github.com/lni/dragonboat/v4/statemachine\"\n)\n\nfunc compressionType(ct pb.CompressionType) dio.CompressionType {\n\tif ct == pb.NoCompression {\n\t\treturn dio.NoCompression\n\t} else if ct == pb.Snappy {\n\t\treturn dio.Snappy\n\t} else {\n\t\tplog.Panicf(\"unknown compression type: %d\", ct)\n\t}\n\tpanic(\"will never reach here\")\n}\n\nvar (\n\t// ErrNoSnapshot is the error used to indicate that there is no snapshot\n\t// available.\n\tErrNoSnapshot        = errors.New(\"no snapshot available\")\n\terrSnapshotOutOfDate = errors.New(\"snapshot being generated is out of date\")\n)\n\ntype snapshotter struct {\n\troot      server.SnapshotDirFunc\n\tdir       string\n\tshardID   uint64\n\treplicaID uint64\n\tlogdb     raftio.ILogDB\n\tlogReader *logdb.LogReader\n\tfs        vfs.IFS\n}\n\nvar _ rsm.ISnapshotter = (*snapshotter)(nil)\n\nfunc newSnapshotter(shardID uint64, replicaID uint64,\n\troot server.SnapshotDirFunc, ldb raftio.ILogDB,\n\tlogReader *logdb.LogReader, fs vfs.IFS) *snapshotter {\n\treturn &snapshotter{\n\t\tshardID:   shardID,\n\t\treplicaID: replicaID,\n\t\troot:      root,\n\t\tdir:       root(shardID, replicaID),\n\t\tlogdb:     ldb,\n\t\tlogReader: logReader,\n\t\tfs:        fs,\n\t}\n}\n\nfunc (s *snapshotter) id() string {\n\treturn dn(s.shardID, s.replicaID)\n}\n\nfunc (s *snapshotter) ssid(index uint64) string {\n\treturn logutil.DescribeSS(s.shardID, s.replicaID, index)\n}\n\nfunc (s *snapshotter) Shrunk(ss pb.Snapshot) (bool, error) {\n\treturn rsm.IsShrunkSnapshotFile(s.getFilePath(ss.Index), s.fs)\n}\n\nfunc (s *snapshotter) Stream(streamable rsm.IStreamable,\n\tmeta rsm.SSMeta, sink pb.IChunkSink) error {\n\tct := compressionType(meta.CompressionType)\n\tcw := dio.NewCompressor(ct, rsm.NewChunkWriter(sink, meta))\n\tif err := streamable.Stream(meta.Ctx, cw); err != nil {\n\t\tif cerr := sink.Close(); cerr != nil {\n\t\t\tplog.Errorf(\"failed to close the sink %v\", cerr)\n\t\t}\n\t\treturn err\n\t}\n\treturn cw.Close()\n}\n\nfunc (s *snapshotter) Save(savable rsm.ISavable,\n\tmeta rsm.SSMeta) (ss pb.Snapshot, env server.SSEnv, err error) {\n\tenv = s.getCustomEnv(meta)\n\tif err := env.CreateTempDir(); err != nil {\n\t\treturn pb.Snapshot{}, env, err\n\t}\n\tfiles := rsm.NewFileCollection()\n\tfp := env.GetTempFilepath()\n\tct := compressionType(meta.CompressionType)\n\tw, err := rsm.NewSnapshotWriter(fp, meta.CompressionType, s.fs)\n\tif err != nil {\n\t\treturn pb.Snapshot{}, env, err\n\t}\n\tcw := dio.NewCountedWriter(w)\n\tsw := dio.NewCompressor(ct, cw)\n\tdefer func() {\n\t\terr = firstError(err, sw.Close())\n\t\tif ss.Index > 0 {\n\t\t\ttotal := cw.BytesWritten()\n\t\t\tss.Checksum = w.GetPayloadChecksum()\n\t\t\tss.FileSize = w.GetPayloadSize(total) + rsm.HeaderSize\n\t\t}\n\t}()\n\tsession := meta.Session.Bytes()\n\tdummy, err := savable.Save(meta, sw, session, files)\n\tif err != nil {\n\t\treturn pb.Snapshot{}, env, err\n\t}\n\tfs, err := files.PrepareFiles(env.GetTempDir(), env.GetFinalDir())\n\tif err != nil {\n\t\treturn pb.Snapshot{}, env, err\n\t}\n\treturn pb.Snapshot{\n\t\tShardID:     s.shardID,\n\t\tFilepath:    env.GetFilepath(),\n\t\tMembership:  meta.Membership,\n\t\tIndex:       meta.Index,\n\t\tTerm:        meta.Term,\n\t\tOnDiskIndex: meta.OnDiskIndex,\n\t\tFiles:       fs,\n\t\tDummy:       dummy,\n\t\tType:        meta.Type,\n\t}, env, nil\n}\n\nfunc (s *snapshotter) Load(ss pb.Snapshot,\n\tsessions rsm.ILoadable, asm rsm.IRecoverable) (err error) {\n\tfp := s.getFilePath(ss.Index)\n\tfs := make([]sm.SnapshotFile, 0)\n\tfor _, f := range ss.Files {\n\t\tfs = append(fs, sm.SnapshotFile{\n\t\t\tFileID:   f.FileId,\n\t\t\tFilepath: f.Filepath,\n\t\t\tMetadata: f.Metadata,\n\t\t})\n\t}\n\treader, header, err := rsm.NewSnapshotReader(fp, s.fs)\n\tif err != nil {\n\t\treturn err\n\t}\n\tct := compressionType(header.CompressionType)\n\tcr := dio.NewDecompressor(ct, reader)\n\tdefer func() {\n\t\terr = firstError(err, cr.Close())\n\t}()\n\tv := rsm.SSVersion(header.Version)\n\tif err := sessions.LoadSessions(cr, v); err != nil {\n\t\treturn err\n\t}\n\tif err := asm.Recover(cr, fs); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (s *snapshotter) GetSnapshot() (pb.Snapshot, error) {\n\tss := s.logReader.Snapshot()\n\tif pb.IsEmptySnapshot(ss) {\n\t\treturn pb.Snapshot{}, ErrNoSnapshot\n\t}\n\treturn ss, nil\n}\n\n// TODO: update this once the LogDB interface is updated to have the ability to\n// query latest snapshot.\nfunc (s *snapshotter) GetSnapshotFromLogDB() (pb.Snapshot, error) {\n\tsnapshot, err := s.logdb.GetSnapshot(s.shardID, s.replicaID)\n\tif err != nil {\n\t\treturn pb.Snapshot{}, err\n\t}\n\tif !pb.IsEmptySnapshot(snapshot) {\n\t\treturn snapshot, nil\n\t}\n\treturn pb.Snapshot{}, ErrNoSnapshot\n}\n\nfunc (s *snapshotter) Shrink(index uint64) error {\n\tss, err := s.logdb.GetSnapshot(s.shardID, s.replicaID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif ss.Index < index {\n\t\treturn nil\n\t}\n\tif !ss.Dummy && !ss.Witness {\n\t\tenv := s.getEnv(index)\n\t\tfp := env.GetFilepath()\n\t\tshrunk := env.GetShrinkedFilepath()\n\t\tplog.Infof(\"%s shrinking %s\", s.id(), s.ssid(index))\n\t\tif err := rsm.ShrinkSnapshot(fp, shrunk, s.fs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn rsm.ReplaceSnapshot(shrunk, fp, s.fs)\n\t}\n\treturn nil\n}\n\nfunc (s *snapshotter) Compact(index uint64) error {\n\tss, err := s.logdb.GetSnapshot(s.shardID, s.replicaID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif ss.Index <= index {\n\t\tplog.Panicf(\"%s invalid compaction, LogDB snapshot %d, index %d\",\n\t\t\ts.id(), ss.Index, index)\n\t}\n\tplog.Debugf(\"%s called Compact, latest %d, to compact %d\",\n\t\ts.id(), ss.Index, index)\n\tif err := s.remove(index); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (s *snapshotter) IsNoSnapshotError(err error) bool {\n\treturn errors.Is(err, ErrNoSnapshot)\n}\n\nfunc (s *snapshotter) Commit(ss pb.Snapshot, req rsm.SSRequest) error {\n\tenv := s.getCustomEnv(rsm.SSMeta{\n\t\tIndex:   ss.Index,\n\t\tRequest: req,\n\t})\n\tif err := env.SaveSSMetadata(&ss); err != nil {\n\t\treturn err\n\t}\n\tif err := env.FinalizeSnapshot(&ss); err != nil {\n\t\tif errors.Is(err, server.ErrSnapshotOutOfDate) {\n\t\t\treturn errSnapshotOutOfDate\n\t\t}\n\t\treturn err\n\t}\n\tif !req.Exported() {\n\t\tif err := s.saveSnapshot(ss); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn env.RemoveFlagFile()\n}\n\nfunc (s *snapshotter) getFilePath(index uint64) string {\n\tenv := s.getEnv(index)\n\treturn env.GetFilepath()\n}\n\nfunc (s *snapshotter) processOrphans() error {\n\tfiles, err := s.fs.List(s.dir)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnoss := false\n\tmrss, err := s.GetSnapshotFromLogDB()\n\tif err != nil {\n\t\tif errors.Is(err, ErrNoSnapshot) {\n\t\t\tnoss = true\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\tremoveFolder := func(fdir string) error {\n\t\tif err := s.fs.RemoveAll(fdir); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn fileutil.SyncDir(s.dir, s.fs)\n\t}\n\tfor _, n := range files {\n\t\tfi, err := s.fs.Stat(s.fs.PathJoin(s.dir, n))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !fi.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tfdir := s.fs.PathJoin(s.dir, fi.Name())\n\t\tif s.isOrphan(fi.Name()) {\n\t\t\tvar ss pb.Snapshot\n\t\t\tif err := fileutil.GetFlagFileContent(fdir,\n\t\t\t\tfileutil.SnapshotFlagFilename, &ss, s.fs); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif pb.IsEmptySnapshot(ss) {\n\t\t\t\tplog.Panicf(\"empty snapshot found in %s\", fdir)\n\t\t\t}\n\t\t\tremove := false\n\t\t\tif noss {\n\t\t\t\tremove = true\n\t\t\t} else {\n\t\t\t\tif mrss.Index != ss.Index {\n\t\t\t\t\tremove = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif remove {\n\t\t\t\tif err := s.remove(ss.Index); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tenv := s.getEnv(ss.Index)\n\t\t\t\tif err := env.RemoveFlagFile(); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t} else if s.isZombie(fi.Name()) {\n\t\t\tif err := removeFolder(fdir); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if s.isSnapshot(fi.Name()) {\n\t\t\tindex := s.parseIndex(fi.Name())\n\t\t\tif noss || index != mrss.Index {\n\t\t\t\tif err := removeFolder(fdir); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (s *snapshotter) remove(index uint64) error {\n\tenv := s.getEnv(index)\n\treturn env.RemoveFinalDir()\n}\n\nfunc (s *snapshotter) removeFlagFile(index uint64) error {\n\tenv := s.getEnv(index)\n\treturn env.RemoveFlagFile()\n}\n\nfunc (s *snapshotter) getEnv(index uint64) server.SSEnv {\n\treturn server.NewSSEnv(s.root,\n\t\ts.shardID, s.replicaID, index, s.replicaID, server.SnapshotMode, s.fs)\n}\n\nfunc (s *snapshotter) getCustomEnv(meta rsm.SSMeta) server.SSEnv {\n\tif meta.Request.Exported() {\n\t\tif len(meta.Request.Path) == 0 {\n\t\t\tplog.Panicf(\"Path is empty when exporting snapshot\")\n\t\t}\n\t\tgp := func(shardID uint64, replicaID uint64) string {\n\t\t\treturn meta.Request.Path\n\t\t}\n\t\treturn server.NewSSEnv(gp,\n\t\t\ts.shardID, s.replicaID, meta.Index, s.replicaID, server.SnapshotMode, s.fs)\n\t}\n\treturn s.getEnv(meta.Index)\n}\n\nfunc (s *snapshotter) saveSnapshot(snapshot pb.Snapshot) error {\n\treturn s.logdb.SaveSnapshots([]pb.Update{{\n\t\tShardID:   s.shardID,\n\t\tReplicaID: s.replicaID,\n\t\tSnapshot:  snapshot,\n\t}})\n}\n\nfunc (s *snapshotter) dirMatch(dir string) bool {\n\treturn server.SnapshotDirNameRe.Match([]byte(dir))\n}\n\nfunc (s *snapshotter) parseIndex(dir string) uint64 {\n\tif parts := server.SnapshotDirNamePartsRe.FindStringSubmatch(dir); len(parts) == 2 {\n\t\tindex, err := strconv.ParseUint(parts[1], 16, 64)\n\t\tif err != nil {\n\t\t\tplog.Panicf(\"failed to parse index %s\", parts[1])\n\t\t}\n\t\treturn index\n\t}\n\tplog.Panicf(\"unknown snapshot fold name: %s\", dir)\n\treturn 0\n}\n\nfunc (s *snapshotter) isSnapshot(dir string) bool {\n\tif !s.dirMatch(dir) {\n\t\treturn false\n\t}\n\tfdir := s.fs.PathJoin(s.dir, dir)\n\treturn !fileutil.HasFlagFile(fdir, fileutil.SnapshotFlagFilename, s.fs)\n}\n\nfunc (s *snapshotter) isZombie(dir string) bool {\n\treturn server.GenSnapshotDirNameRe.Match([]byte(dir)) ||\n\t\tserver.RecvSnapshotDirNameRe.Match([]byte(dir))\n}\n\nfunc (s *snapshotter) isOrphan(dir string) bool {\n\tif !s.dirMatch(dir) {\n\t\treturn false\n\t}\n\tfdir := s.fs.PathJoin(s.dir, dir)\n\treturn fileutil.HasFlagFile(fdir, fileutil.SnapshotFlagFilename, s.fs)\n}\n"
        },
        {
          "name": "snapshotter_test.go",
          "type": "blob",
          "size": 17.748046875,
          "content": "// Copyright 2017-2021 Lei Ni (nilei81@gmail.com) and other contributors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage dragonboat\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/cockroachdb/errors\"\n\t\"github.com/lni/goutils/leaktest\"\n\n\t\"github.com/lni/dragonboat/v4/config\"\n\t\"github.com/lni/dragonboat/v4/internal/fileutil\"\n\t\"github.com/lni/dragonboat/v4/internal/logdb\"\n\t\"github.com/lni/dragonboat/v4/internal/rsm\"\n\t\"github.com/lni/dragonboat/v4/internal/vfs\"\n\t\"github.com/lni/dragonboat/v4/raftio\"\n\tpb \"github.com/lni/dragonboat/v4/raftpb\"\n)\n\nconst (\n\ttmpSnapshotDirSuffix = \"generating\"\n\trecvTmpDirSuffix     = \"receiving\"\n\trdbTestDirectory     = \"rdb_test_dir_safe_to_delete\"\n)\n\nfunc getNewTestDB(dir string, lldir string, fs vfs.IFS) raftio.ILogDB {\n\td := fs.PathJoin(rdbTestDirectory, dir)\n\tlld := fs.PathJoin(rdbTestDirectory, lldir)\n\tif err := fs.MkdirAll(d, 0777); err != nil {\n\t\tpanic(err)\n\t}\n\tif err := fs.MkdirAll(lld, 0777); err != nil {\n\t\tpanic(err)\n\t}\n\tcfg := config.NodeHostConfig{\n\t\tExpert: config.GetDefaultExpertConfig(),\n\t}\n\tcfg.Expert.FS = fs\n\tdb, err := logdb.NewDefaultLogDB(cfg, nil, []string{d}, []string{lld})\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn db\n}\n\nfunc deleteTestRDB(fs vfs.IFS) {\n\tif err := fs.RemoveAll(rdbTestDirectory); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc getTestSnapshotter(ldb raftio.ILogDB, fs vfs.IFS) *snapshotter {\n\tfp := fs.PathJoin(rdbTestDirectory, \"snapshot\")\n\tif err := fs.MkdirAll(fp, 0777); err != nil {\n\t\tpanic(err)\n\t}\n\tf := func(cid uint64, nid uint64) string {\n\t\treturn fp\n\t}\n\tlr := logdb.NewLogReader(1, 1, ldb)\n\treturn newSnapshotter(1, 1, f, ldb, lr, fs)\n}\n\nfunc runSnapshotterTest(t *testing.T,\n\tfn func(t *testing.T, logdb raftio.ILogDB, snapshotter *snapshotter), fs vfs.IFS) {\n\tdefer leaktest.AfterTest(t)()\n\tdir := \"db-dir\"\n\tlldir := \"wal-db-dir\"\n\tdeleteTestRDB(fs)\n\tldb := getNewTestDB(dir, lldir, fs)\n\ts := getTestSnapshotter(ldb, fs)\n\tdefer deleteTestRDB(fs)\n\tdefer ldb.Close()\n\tfn(t, ldb, s)\n}\n\nfunc TestFinalizeSnapshotReturnExpectedErrorWhenOutOfDate(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tfn := func(t *testing.T, ldb raftio.ILogDB, s *snapshotter) {\n\t\tss := pb.Snapshot{\n\t\t\tFileSize: 1234,\n\t\t\tFilepath: \"f2\",\n\t\t\tIndex:    100,\n\t\t\tTerm:     200,\n\t\t}\n\t\tenv := s.getEnv(ss.Index)\n\t\tfinalSnapDir := env.GetFinalDir()\n\t\tif err := fs.MkdirAll(finalSnapDir, 0755); err != nil {\n\t\t\tt.Errorf(\"failed to create final snap dir\")\n\t\t}\n\t\tif err := env.CreateTempDir(); err != nil {\n\t\t\tt.Errorf(\"create tmp snapshot dir failed %v\", err)\n\t\t}\n\t\tif err := s.Commit(ss, rsm.SSRequest{}); !errors.Is(err, errSnapshotOutOfDate) {\n\t\t\tt.Errorf(\"unexpected error result %v\", err)\n\t\t}\n\t}\n\trunSnapshotterTest(t, fn, fs)\n}\n\nfunc TestSnapshotCanBeFinalized(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tfn := func(t *testing.T, ldb raftio.ILogDB, s *snapshotter) {\n\t\tss := pb.Snapshot{\n\t\t\tFileSize: 1234,\n\t\t\tFilepath: \"f2\",\n\t\t\tIndex:    100,\n\t\t\tTerm:     200,\n\t\t}\n\t\tenv := s.getEnv(ss.Index)\n\t\tfinalSnapDir := env.GetFinalDir()\n\t\ttmpDir := env.GetTempDir()\n\t\terr := env.CreateTempDir()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"create tmp snapshot dir failed %v\", err)\n\t\t}\n\t\t_, err = fs.Stat(tmpDir)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to get stat for tmp dir, %v\", err)\n\t\t}\n\t\ttestfp := fs.PathJoin(tmpDir, \"test.data\")\n\t\tf, err := fs.Create(testfp)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to create test file\")\n\t\t}\n\t\tif _, err := f.Write(make([]byte, 12)); err != nil {\n\t\t\tt.Fatalf(\"write failed %v\", err)\n\t\t}\n\t\tf.Close()\n\t\tif err = s.Commit(ss, rsm.SSRequest{}); err != nil {\n\t\t\tt.Errorf(\"finalize snapshot failed %v\", err)\n\t\t}\n\t\tsnapshot, err := ldb.GetSnapshot(1, 1)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to list snapshot\")\n\t\t}\n\t\tif pb.IsEmptySnapshot(snapshot) {\n\t\t\tt.Errorf(\"failed to get snapshot\")\n\t\t}\n\t\trs, err := s.GetSnapshotFromLogDB()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to get snapshot\")\n\t\t}\n\t\tif rs.Index != 100 {\n\t\t\tt.Errorf(\"returned an unexpected snapshot\")\n\t\t}\n\t\tif _, err = fs.Stat(tmpDir); !vfs.IsNotExist(err) {\n\t\t\tt.Errorf(\"tmp dir not removed, %v\", err)\n\t\t}\n\t\tfi, err := fs.Stat(finalSnapDir)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to get stats, %v\", err)\n\t\t}\n\t\tif !fi.IsDir() {\n\t\t\tt.Errorf(\"not a dir\")\n\t\t}\n\t\tif fileutil.HasFlagFile(finalSnapDir, fileutil.SnapshotFlagFilename, fs) {\n\t\t\tt.Errorf(\"flag file not removed\")\n\t\t}\n\t\tvfp := fs.PathJoin(finalSnapDir, \"test.data\")\n\t\tfi, err = fs.Stat(vfp)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to get stat %v\", err)\n\t\t}\n\t\tif fi.IsDir() || fi.Size() != 12 {\n\t\t\tt.Errorf(\"not the same test file. \")\n\t\t}\n\t}\n\trunSnapshotterTest(t, fn, fs)\n}\n\nfunc TestSnapshotCanBeSavedToLogDB(t *testing.T) {\n\tfn := func(t *testing.T, ldb raftio.ILogDB, s *snapshotter) {\n\t\ts1 := pb.Snapshot{\n\t\t\tFileSize: 1234,\n\t\t\tFilepath: \"f2\",\n\t\t\tIndex:    1,\n\t\t\tTerm:     2,\n\t\t}\n\t\tif err := s.saveSnapshot(s1); err != nil {\n\t\t\tt.Errorf(\"failed to save snapshot record %v\", err)\n\t\t}\n\t\tsnapshot, err := ldb.GetSnapshot(1, 1)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to list snapshot\")\n\t\t}\n\t\tif !reflect.DeepEqual(s1, snapshot) {\n\t\t\tt.Errorf(\"snapshot record changed\")\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunSnapshotterTest(t, fn, fs)\n}\n\nfunc TestZombieSnapshotDirsCanBeRemoved(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tfn := func(t *testing.T, ldb raftio.ILogDB, s *snapshotter) {\n\t\tenv1 := s.getEnv(100)\n\t\tenv2 := s.getEnv(200)\n\t\tfd1 := env1.GetFinalDir()\n\t\tfd2 := env2.GetFinalDir()\n\t\tfd1 = fd1 + \"-100.\" + tmpSnapshotDirSuffix\n\t\tfd2 = fd2 + \"-100.\" + recvTmpDirSuffix\n\t\tif err := fs.MkdirAll(fd1, 0755); err != nil {\n\t\t\tt.Errorf(\"failed to create dir %v\", err)\n\t\t}\n\t\tif err := fs.MkdirAll(fd2, 0755); err != nil {\n\t\t\tt.Errorf(\"failed to create dir %v\", err)\n\t\t}\n\t\tif err := s.processOrphans(); err != nil {\n\t\t\tt.Errorf(\"failed to process orphaned snapshtos %s\", err)\n\t\t}\n\t\tif _, err := fs.Stat(fd1); !vfs.IsNotExist(err) {\n\t\t\tt.Errorf(\"fd1 not removed\")\n\t\t}\n\t\tif _, err := fs.Stat(fd2); !vfs.IsNotExist(err) {\n\t\t\tt.Errorf(\"fd2 not removed\")\n\t\t}\n\t}\n\trunSnapshotterTest(t, fn, fs)\n}\n\nfunc TestSnapshotsNotInLogDBAreRemoved(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tfn := func(t *testing.T, ldb raftio.ILogDB, s *snapshotter) {\n\t\tenv1 := s.getEnv(100)\n\t\tenv2 := s.getEnv(200)\n\t\tfd1 := env1.GetFinalDir()\n\t\tfd2 := env2.GetFinalDir()\n\t\tif err := fs.MkdirAll(fd1, 0755); err != nil {\n\t\t\tt.Errorf(\"failed to create dir %v\", err)\n\t\t}\n\t\tif err := fs.MkdirAll(fd2, 0755); err != nil {\n\t\t\tt.Errorf(\"failed to create dir %v\", err)\n\t\t}\n\t\tif err := s.processOrphans(); err != nil {\n\t\t\tt.Errorf(\"failed to process orphaned snapshtos %s\", err)\n\t\t}\n\t\tif _, err := fs.Stat(fd1); !vfs.IsNotExist(err) {\n\t\t\tt.Errorf(\"fd1 %s not removed\", fd1)\n\t\t}\n\t\tif _, err := fs.Stat(fd2); !vfs.IsNotExist(err) {\n\t\t\tt.Errorf(\"fd2 %s not removed\", fd2)\n\t\t}\n\t}\n\trunSnapshotterTest(t, fn, fs)\n}\n\nfunc TestOnlyMostRecentSnapshotIsKept(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tfn := func(t *testing.T, ldb raftio.ILogDB, s *snapshotter) {\n\t\tenv1 := s.getEnv(100)\n\t\tenv2 := s.getEnv(200)\n\t\tenv3 := s.getEnv(300)\n\t\ts1 := pb.Snapshot{\n\t\t\tFileSize: 1234,\n\t\t\tFilepath: \"f2\",\n\t\t\tIndex:    200,\n\t\t\tTerm:     200,\n\t\t}\n\t\tfd1 := env1.GetFinalDir()\n\t\tfd2 := env2.GetFinalDir()\n\t\tfd3 := env3.GetFinalDir()\n\t\tif err := s.saveSnapshot(s1); err != nil {\n\t\t\tt.Errorf(\"failed to save snapshot to logdb\")\n\t\t}\n\t\tif err := fs.MkdirAll(fd1, 0755); err != nil {\n\t\t\tt.Errorf(\"failed to create dir %v\", err)\n\t\t}\n\t\tif err := fs.MkdirAll(fd2, 0755); err != nil {\n\t\t\tt.Errorf(\"failed to create dir %v\", err)\n\t\t}\n\t\tif err := fs.MkdirAll(fd3, 0755); err != nil {\n\t\t\tt.Errorf(\"failed to create dir %v\", err)\n\t\t}\n\t\tif err := s.processOrphans(); err != nil {\n\t\t\tt.Errorf(\"failed to process orphaned snapshtos %s\", err)\n\t\t}\n\t\tif _, err := fs.Stat(fd1); !vfs.IsNotExist(err) {\n\t\t\tt.Errorf(\"fd1 %s not removed\", fd1)\n\t\t}\n\t\tif _, err := fs.Stat(fd2); vfs.IsNotExist(err) {\n\t\t\tt.Errorf(\"fd2 %s removed by mistake\", fd2)\n\t\t}\n\t\tif _, err := fs.Stat(fd3); !vfs.IsNotExist(err) {\n\t\t\tt.Errorf(\"fd3 %s not removed\", fd3)\n\t\t}\n\t}\n\trunSnapshotterTest(t, fn, fs)\n}\n\nfunc TestFirstSnapshotBecomeOrphanedIsHandled(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tfn := func(t *testing.T, ldb raftio.ILogDB, s *snapshotter) {\n\t\ts1 := pb.Snapshot{\n\t\t\tFileSize: 1234,\n\t\t\tFilepath: \"f2\",\n\t\t\tIndex:    100,\n\t\t\tTerm:     200,\n\t\t}\n\t\tenv := s.getEnv(100)\n\t\tfd1 := env.GetFinalDir()\n\t\tif err := fs.MkdirAll(fd1, 0755); err != nil {\n\t\t\tt.Errorf(\"failed to create dir %v\", err)\n\t\t}\n\t\tif err := fileutil.CreateFlagFile(fd1, fileutil.SnapshotFlagFilename, &s1, fs); err != nil {\n\t\t\tt.Errorf(\"failed to create flag file %s\", err)\n\t\t}\n\t\tif err := s.processOrphans(); err != nil {\n\t\t\tt.Errorf(\"failed to process orphaned snapshtos %s\", err)\n\t\t}\n\t\tif _, err := fs.Stat(fd1); !vfs.IsNotExist(err) {\n\t\t\tt.Errorf(\"fd1 not removed\")\n\t\t}\n\t}\n\trunSnapshotterTest(t, fn, fs)\n}\n\nfunc TestOrphanedSnapshotRecordIsRemoved(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tfn := func(t *testing.T, ldb raftio.ILogDB, s *snapshotter) {\n\t\ts1 := pb.Snapshot{\n\t\t\tFileSize: 1234,\n\t\t\tFilepath: \"f2\",\n\t\t\tIndex:    100,\n\t\t\tTerm:     200,\n\t\t}\n\t\ts2 := pb.Snapshot{\n\t\t\tFileSize: 1234,\n\t\t\tFilepath: \"f2\",\n\t\t\tIndex:    200,\n\t\t\tTerm:     200,\n\t\t}\n\t\tenv1 := s.getEnv(s1.Index)\n\t\tenv2 := s.getEnv(s2.Index)\n\t\tfd1 := env1.GetFinalDir()\n\t\tfd2 := env2.GetFinalDir()\n\t\tif err := fs.MkdirAll(fd1, 0755); err != nil {\n\t\t\tt.Errorf(\"failed to create dir %v\", err)\n\t\t}\n\t\tif err := fs.MkdirAll(fd2, 0755); err != nil {\n\t\t\tt.Errorf(\"failed to create dir %v\", err)\n\t\t}\n\t\tif err := fileutil.CreateFlagFile(fd1, fileutil.SnapshotFlagFilename, &s1, fs); err != nil {\n\t\t\tt.Errorf(\"failed to create flag file %s\", err)\n\t\t}\n\t\tif err := fileutil.CreateFlagFile(fd2, fileutil.SnapshotFlagFilename, &s2, fs); err != nil {\n\t\t\tt.Errorf(\"failed to create flag file %s\", err)\n\t\t}\n\t\tif err := s.saveSnapshot(s1); err != nil {\n\t\t\tt.Errorf(\"failed to save snapshot to logdb\")\n\t\t}\n\t\tif err := s.saveSnapshot(s2); err != nil {\n\t\t\tt.Errorf(\"failed to save snapshot to logdb\")\n\t\t}\n\t\t// two orphane snapshots, kept the most recent one, and remove the older\n\t\t// one including its logdb record.\n\t\tif err := s.processOrphans(); err != nil {\n\t\t\tt.Errorf(\"failed to process orphaned snapshtos %s\", err)\n\t\t}\n\t\tif _, err := fs.Stat(fd1); vfs.IsExist(err) {\n\t\t\tt.Errorf(\"failed to remove fd1\")\n\t\t}\n\t\tif _, err := fs.Stat(fd2); vfs.IsNotExist(err) {\n\t\t\tt.Errorf(\"unexpectedly removed fd2\")\n\t\t}\n\t\tif fileutil.HasFlagFile(fd2, fileutil.SnapshotFlagFilename, fs) {\n\t\t\tt.Errorf(\"flag for fd2 not removed\")\n\t\t}\n\t\tsnapshot, err := s.logdb.GetSnapshot(1, 1)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to list snapshot %v\", err)\n\t\t}\n\t\tif snapshot.Index != 200 {\n\t\t\tt.Fatalf(\"unexpected record %v\", snapshot)\n\t\t}\n\t}\n\trunSnapshotterTest(t, fn, fs)\n}\n\nfunc TestOrphanedSnapshotsCanBeProcessed(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tfn := func(t *testing.T, ldb raftio.ILogDB, s *snapshotter) {\n\t\ts1 := pb.Snapshot{\n\t\t\tFileSize: 1234,\n\t\t\tFilepath: \"f2\",\n\t\t\tIndex:    100,\n\t\t\tTerm:     200,\n\t\t}\n\t\ts2 := pb.Snapshot{\n\t\t\tFileSize: 1234,\n\t\t\tFilepath: \"f2\",\n\t\t\tIndex:    200,\n\t\t\tTerm:     200,\n\t\t}\n\t\ts3 := pb.Snapshot{\n\t\t\tFileSize: 1234,\n\t\t\tFilepath: \"f2\",\n\t\t\tIndex:    300,\n\t\t\tTerm:     200,\n\t\t}\n\t\tenv1 := s.getEnv(s1.Index)\n\t\tenv2 := s.getEnv(s2.Index)\n\t\tenv3 := s.getEnv(s3.Index)\n\t\tfd1 := env1.GetFinalDir()\n\t\tfd2 := env2.GetFinalDir()\n\t\tfd3 := env3.GetFinalDir()\n\t\tfd4 := fmt.Sprintf(\"%s%s\", fd3, \"xx\")\n\t\tif err := fs.MkdirAll(fd1, 0755); err != nil {\n\t\t\tt.Errorf(\"failed to create dir %v\", err)\n\t\t}\n\t\tif err := fs.MkdirAll(fd2, 0755); err != nil {\n\t\t\tt.Errorf(\"failed to create dir %v\", err)\n\t\t}\n\t\tif err := fs.MkdirAll(fd4, 0755); err != nil {\n\t\t\tt.Errorf(\"failed to create dir %v\", err)\n\t\t}\n\t\tif err := fileutil.CreateFlagFile(fd1, fileutil.SnapshotFlagFilename, &s1, fs); err != nil {\n\t\t\tt.Errorf(\"failed to create flag file %s\", err)\n\t\t}\n\t\tif err := fileutil.CreateFlagFile(fd2, fileutil.SnapshotFlagFilename, &s2, fs); err != nil {\n\t\t\tt.Errorf(\"failed to create flag file %s\", err)\n\t\t}\n\t\tif err := fileutil.CreateFlagFile(fd4, fileutil.SnapshotFlagFilename, &s3, fs); err != nil {\n\t\t\tt.Errorf(\"failed to create flag file %s\", err)\n\t\t}\n\t\tif err := s.saveSnapshot(s1); err != nil {\n\t\t\tt.Errorf(\"failed to save snapshot to logdb\")\n\t\t}\n\t\t// fd1 has record in logdb. flag file expected to be removed while the fd1\n\t\t// foler is expected to be kept\n\t\t// fd2 doesn't has its record in logdb, while the most recent snapshot record\n\t\t// in logdb is not for fd2, fd2 will be entirely removed\n\t\tif err := s.processOrphans(); err != nil {\n\t\t\tt.Errorf(\"failed to process orphaned snapshtos %s\", err)\n\t\t}\n\t\tif fileutil.HasFlagFile(fd1, fileutil.SnapshotFlagFilename, fs) {\n\t\t\tt.Errorf(\"flag for fd1 not removed\")\n\t\t}\n\t\tif fileutil.HasFlagFile(fd2, fileutil.SnapshotFlagFilename, fs) {\n\t\t\tt.Errorf(\"flag for fd2 not removed\")\n\t\t}\n\t\tif !fileutil.HasFlagFile(fd4, fileutil.SnapshotFlagFilename, fs) {\n\t\t\tt.Errorf(\"flag for fd4 is missing\")\n\t\t}\n\t\tif _, err := fs.Stat(fd1); vfs.IsNotExist(err) {\n\t\t\tt.Errorf(\"fd1 removed by mistake\")\n\t\t}\n\t\tif _, err := fs.Stat(fd2); !vfs.IsNotExist(err) {\n\t\t\tt.Errorf(\"fd2 not removed\")\n\t\t}\n\t}\n\trunSnapshotterTest(t, fn, fs)\n}\n\nfunc TestSnapshotterCompact(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tfn := func(t *testing.T, ldb raftio.ILogDB, snapshotter *snapshotter) {\n\t\tfor i := uint64(1); i <= uint64(3); i++ {\n\t\t\tfn := fmt.Sprintf(\"f%d.data\", i)\n\t\t\ts := pb.Snapshot{\n\t\t\t\tFileSize: 1234,\n\t\t\t\tFilepath: fn,\n\t\t\t\tIndex:    i,\n\t\t\t\tTerm:     2,\n\t\t\t}\n\t\t\tenv := snapshotter.getEnv(s.Index)\n\t\t\tif err := env.CreateTempDir(); err != nil {\n\t\t\t\tt.Errorf(\"failed to create snapshot dir\")\n\t\t\t}\n\t\t\tif err := snapshotter.Commit(s, rsm.SSRequest{}); err != nil {\n\t\t\t\tt.Errorf(\"failed to save snapshot record\")\n\t\t\t}\n\t\t\tfp := snapshotter.getFilePath(s.Index)\n\t\t\tf, err := fs.Create(fp)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to create the file, %v\", err)\n\t\t\t}\n\t\t\tf.Close()\n\t\t}\n\t\tif err := snapshotter.Compact(2); err != nil {\n\t\t\tt.Errorf(\"failed to remove unused snapshots, %v\", err)\n\t\t}\n\t\tcheck := func(index uint64, exist bool) {\n\t\t\tenv := snapshotter.getEnv(index)\n\t\t\tsnapDir := env.GetFinalDir()\n\t\t\t_, err := fs.Stat(snapDir)\n\t\t\tif exist && vfs.IsNotExist(err) {\n\t\t\t\tt.Errorf(\"snapshot dir didn't get removed\")\n\t\t\t}\n\t\t\tif !exist && !vfs.IsNotExist(err) {\n\t\t\t\tt.Errorf(\"failed to be removed\")\n\t\t\t}\n\t\t}\n\t\tcheck(1, true)\n\t\tcheck(2, false)\n\t\tcheck(3, true)\n\t}\n\trunSnapshotterTest(t, fn, fs)\n}\n\nfunc TestShrinkSnapshots(t *testing.T) {\n\tfs := vfs.GetTestFS()\n\tfn := func(t *testing.T, ldb raftio.ILogDB, snapshotter *snapshotter) {\n\t\tfor i := uint64(1); i <= 3; i++ {\n\t\t\tindex := i * 10\n\t\t\tenv := snapshotter.getEnv(index)\n\t\t\tfp := env.GetFilepath()\n\t\t\ts := pb.Snapshot{\n\t\t\t\tIndex:    index,\n\t\t\t\tTerm:     2,\n\t\t\t\tFileSize: 1234,\n\t\t\t\tFilepath: fp,\n\t\t\t}\n\t\t\tif err := env.CreateTempDir(); err != nil {\n\t\t\t\tt.Errorf(\"failed to create snapshot dir\")\n\t\t\t}\n\t\t\tif err := snapshotter.Commit(s, rsm.SSRequest{}); err != nil {\n\t\t\t\tt.Errorf(\"failed to save snapshot record\")\n\t\t\t}\n\t\t\tfp = snapshotter.getFilePath(s.Index)\n\t\t\twriter, err := rsm.NewSnapshotWriter(fp, pb.NoCompression, fs)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to create the snapshot %v\", err)\n\t\t\t}\n\t\t\tsz := make([]byte, 8)\n\t\t\tbinary.LittleEndian.PutUint64(sz, 0)\n\t\t\tif _, err := writer.Write(sz); err != nil {\n\t\t\t\tt.Fatalf(\"failed to write %v\", err)\n\t\t\t}\n\t\t\tfor j := 0; j < 10; j++ {\n\t\t\t\tdata := make([]byte, 1024*1024)\n\t\t\t\tif _, err := writer.Write(data); err != nil {\n\t\t\t\t\tt.Fatalf(\"failed to write %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := writer.Close(); err != nil {\n\t\t\t\tt.Fatalf(\"close failed %v\", err)\n\t\t\t}\n\t\t}\n\t\tif err := snapshotter.Shrink(20); err != nil {\n\t\t\tt.Fatalf(\"shrink snapshots failed %v\", err)\n\t\t}\n\t\tenv1 := snapshotter.getEnv(10)\n\t\tenv2 := snapshotter.getEnv(20)\n\t\tenv3 := snapshotter.getEnv(30)\n\t\tcf := func(p string, esz uint64) {\n\t\t\tfi, err := fs.Stat(p)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to get file st %v\", err)\n\t\t\t}\n\t\t\tif uint64(fi.Size()) != esz {\n\t\t\t\t// 1024 header, 8 size client session size, 8 bytes client session\n\t\t\t\t// count, 4 bytes crc, 16 bytes tails 1052 bytes in total\n\t\t\t\tt.Fatalf(\"unexpected size %d, want %d\", fi.Size(), esz)\n\t\t\t}\n\t\t}\n\t\tcf(env1.GetFilepath(), 10486832)\n\t\tcf(env2.GetFilepath(), 1060)\n\t\tcf(env3.GetFilepath(), 10486832)\n\t}\n\trunSnapshotterTest(t, fn, fs)\n}\n\nfunc TestSnapshotDirNameMatchWorks(t *testing.T) {\n\tfn := func(t *testing.T, ldb raftio.ILogDB, s *snapshotter) {\n\t\ttests := []struct {\n\t\t\tdirName string\n\t\t\tvalid   bool\n\t\t}{\n\t\t\t{\"snapshot-AB\", true},\n\t\t\t{\"snapshot\", false},\n\t\t\t{\"xxxsnapshot-AB\", false},\n\t\t\t{\"snapshot-ABd\", false},\n\t\t\t{\"snapshot-\", false},\n\t\t}\n\t\tfor idx, tt := range tests {\n\t\t\tv := s.dirMatch(tt.dirName)\n\t\t\tif v != tt.valid {\n\t\t\t\tt.Errorf(\"dir name %s (%d) failed to match\", tt.dirName, idx)\n\t\t\t}\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunSnapshotterTest(t, fn, fs)\n}\n\nfunc TestZombieSnapshotDirNameMatchWorks(t *testing.T) {\n\tfn := func(t *testing.T, ldb raftio.ILogDB, s *snapshotter) {\n\t\ttests := []struct {\n\t\t\tdirName string\n\t\t\tvalid   bool\n\t\t}{\n\t\t\t{\"snapshot-AB\", false},\n\t\t\t{\"snapshot\", false},\n\t\t\t{\"xxxsnapshot-AB\", false},\n\t\t\t{\"snapshot-\", false},\n\t\t\t{\"snapshot-AB-01.receiving\", true},\n\t\t\t{\"snapshot-AB-1G.receiving\", false},\n\t\t\t{\"snapshot-AB.receiving\", false},\n\t\t\t{\"snapshot-XX.receiving\", false},\n\t\t\t{\"snapshot-AB.receivingd\", false},\n\t\t\t{\"dsnapshot-AB.receiving\", false},\n\t\t\t{\"snapshot-AB.generating\", false},\n\t\t\t{\"snapshot-AB-01.generating\", true},\n\t\t\t{\"snapshot-AB-0G.generating\", false},\n\t\t\t{\"snapshot-XX.generating\", false},\n\t\t\t{\"snapshot-AB.generatingd\", false},\n\t\t\t{\"dsnapshot-AB.generating\", false},\n\t\t}\n\t\tfor idx, tt := range tests {\n\t\t\tv := s.isZombie(tt.dirName)\n\t\t\tif v != tt.valid {\n\t\t\t\tt.Errorf(\"dir name %s (%d) failed to match\", tt.dirName, idx)\n\t\t\t}\n\t\t}\n\t}\n\tfs := vfs.GetTestFS()\n\trunSnapshotterTest(t, fn, fs)\n}\n"
        },
        {
          "name": "statemachine",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}