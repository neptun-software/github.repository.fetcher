{
  "metadata": {
    "timestamp": 1736567789278,
    "page": 374,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "name5566/leaf",
      "stars": 5336,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 10.5078125,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   Copyright 2014-2020 Name5566.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.509765625,
          "content": "Leaf\n====\nA pragmatic game server framework in Go (golang).\n\nFeatures\n---------\n\n* Extremely easy to use\n* Reliable\n* Multicore support\n* Modularity\n\nCommunity\n---------\n\n\n\nDocumentation\n---------\n\n* [中文文档](https://github.com/name5566/leaf/blob/master/TUTORIAL_ZH.md)\n* [English](https://github.com/name5566/leaf/blob/master/TUTORIAL_EN.md)\n\nLicensing\n---------\n\nLeaf is licensed under the Apache License, Version 2.0. See [LICENSE](https://github.com/name5566/leaf/blob/master/LICENSE) for the full license text.\n"
        },
        {
          "name": "TUTORIAL_EN.md",
          "type": "blob",
          "size": 15.083984375,
          "content": "Brief introduction to Leaf\n==========================\n\nLeaf, written in Go, is a open source game server framework aiming to boost the efficiency both in development and runtime.\n\nLeaf champions below philosophies:\n\n* Simple APIs. Leaf tends to provide simple and plain interfaces which are always best for use.\n* Self-healing. Leaf always tries to salvage the process from runtime errors instead of leaving it to crash.\n* Multi-core support. Leaf utilize its modules and [leaf/go](https://github.com/name5566/leaf/tree/master/go) to make use of CPU resouces at maximum while avoiding varieties of side effects may be caused.\n\n* Module-based.\n\nLeaf's Modules\n--------------\n\nA game server implemented with Leaf may include many modules (e.g. [LeafServer](https://github.com/name5566/leafserver)) which all share below traits:\n\n* Each module runs inside a separate goroutine\n* Modules communicate with one another via a light weight RPC channel([leaf/chanrpc](https://github.com/name5566/leaf/tree/master/chanrpc))\n\nLeaf suggests not to take in too many modules in your game server implementation.\n\nModules are registered at the beginning of program as below\n\n```go\nleaf.Run(\n    game.Module,\n    gate.Module,\n    login.Module,\n)\n```\n\nThe modules of `game`, `gate` and `login` are registered consecutively. They are required to implement a `Module` interface.\n\n```go\ntype Module interface {\n    OnInit()\n    OnDestroy()\n    Run(closeSig chan bool)\n}\n```\n\nLeaf follows below steps to manage modules:\n\n1. Takes turns (FIFO) to register the given modules by calling `OnInit()`' in a parent goroutine\n2. Starts a new goroutine for each module to run `Run()`\n3. When the parent goroutine is being closed (like by a SIGINT), the modules will be unregistered by calling `OnDestroy()` in the reverse order when they get registered.\n\nLeaf source code directories\n----------------------------\n\n* leaf/chanrpc : RPC channel for inter-modules communication\n* leaf/db : Database Utilities with [MongoDB](https://www.mongodb.org/) support\n* leaf/gate : Gate module that connects to client\n* leaf/go : Factory of goroutine that manageable for Leaf\n* leaf/log : Logging\n* leaf/network : Networking through TCP or WebSocket with a customized message encoding. There are two built-in encodings, [protobuf](https://developers.google.com/protocol-buffers) and JSON.\n* leaf/recordfile : To manage game related data.\n* leaf/timer : Timer\n* leaf/util : Utilities\n\nHow to use Leaf\n---------------\n\n[LeafServer](https://github.com/name5566/leafserver) is a game server developped with Leaf. Let's start with it.\n\nDownload the source code of LeafServer：\n\n```\ngit clone https://github.com/name5566/leafserver\n```\n\nDownload and install leafserver to GOPATH:\n\n```\ngo get github.com/name5566/leaf\n```\n\nCompile LeafServer：\n\n```\ngo install server\n```\n\nRun `server` you will get below screen output if everything is successful.\n\n```\n2015/08/26 22:11:27 [release] Leaf 1.1.2 starting up\n```\n\nPress Ctrl + C to terminate the process, you'll see\n\n```\n2015/08/26 22:12:30 [release] Leaf closing down (signal: interrupt)\n```\n\n### Hello Leaf\n\nNow with the acknowledge of LeafServer, we come to see how server receives and handles messages.\n\n\nFirstly we define a JSON-encoded message(likely the protobuf). Open LeafServer msg/msg.go then you will see below:\n\n```go\npackage msg\n\nimport (\n    \"github.com/name5566/leaf/network\"\n)\n\nvar Processor network.Processor\n\nfunc init() {\n\n}\n```\n\nProcessor is the message handler. Here we use the handler of JSON, the default message encoding, and create a Hello message.\n\n```go\npackage msg\n\nimport (\n    \"github.com/name5566/leaf/network/json\"\n)\n\n// Create a JSON Processor（or protobuf if you like）\nvar Processor = json.NewProcessor()\n\nfunc init() {\n    // Register message Hello\n    Processor.Register(&Hello{})\n}\n\n// One struct for one message\n// Contains a string member\ntype Hello struct {\n    Name string\n}\n```\n\nEvery message sent from client to server will be flown to `gate` module for routing. Just in brief, `gate` determines which message will be handled by which modules. We want to feed `game` module with `Hello` here, so open LeafServer gate/router.go and write below:\n\n```go\npackage gate\n\nimport (\n    \"server/game\"\n    \"server/msg\"\n)\n\nfunc init() {\n    // Route Hello to game\n    // All communication are through ChanRPC including the management messages\n    msg.Processor.SetRouter(&msg.Hello{}, game.ChanRPC)\n}\n```\n\nIt is ready to handle `Hello` message in `game` module. Open LeafServer game/internal/handler.go and write:\n\n```go\npackage internal\n\nimport (\n    \"github.com/name5566/leaf/log\"\n    \"github.com/name5566/leaf/gate\"\n    \"reflect\"\n    \"server/msg\"\n)\n\nfunc init() {\n    // Register the handler of `Hello` message to `game` module handleHello\n    handler(&msg.Hello{}, handleHello)\n}\n\nfunc handler(m interface{}, h interface{}) {\n    skeleton.RegisterChanRPC(reflect.TypeOf(m), h)\n}\n\nfunc handleHello(args []interface{}) {\n    // Send \"Hello\"\n    m := args[0].(*msg.Hello)\n    // The receiver\n    a := args[1].(gate.Agent)\n\n    // The content of the message\n    log.Debug(\"hello %v\", m.Name)\n\n    // Reply with a `Hello`\n    a.WriteMsg(&msg.Hello{\n        Name: \"client\",\n    })\n}\n```\n\nBy here we've finished a simplest example for server. Now we will write a client from scratch for testing to understand the message structure better.\n\nWhen we choose TCP over the others, the message in transition will be all formated like below:\n\n```\n--------------\n| len | data |\n--------------\n```\n\nTo be more specific:\n\n1. len means the size of data by bytes. len itself takes space(2 bytes by default, configurable). The minimum size of len equals the the minimum size of a single message.\n2. data part is encoded with JSON or protobuf (or a customized one)\n\nWrite the client:\n```go\npackage main\n\nimport (\n    \"encoding/binary\"\n    \"net\"\n)\n\nfunc main() {\n    conn, err := net.Dial(\"tcp\", \"127.0.0.1:3563\")\n    if err != nil {\n        panic(err)\n    }\n\n    // Hello message (JSON-encoded)\n    // The structure of the message\n    data := []byte(`{\n        \"Hello\": {\n            \"Name\": \"leaf\"\n        }\n    }`)\n\n    // len + data\n    m := make([]byte, 2+len(data))\n\n    // BigEndian encoded\n    binary.BigEndian.PutUint16(m, uint16(len(data)))\n\n    copy(m[2:], data)\n\n    // Send message\n    conn.Write(m)\n}\n```\n\nRun the client to send the message, then server will display it as received\n\n```\n2015/09/25 07:41:03 [debug  ] hello leaf\n2015/09/25 07:41:03 [debug  ] read message: read tcp 127.0.0.1:3563->127.0.0.1:54599: wsarecv: An existing connection was forcibly closed by the remote host.\n```\n\nClient will exit after send out the message, and then disconnect with server. Thus server displays the event message of disconnection(the second, the event message might be dependant on the version of Go environment).\n\nBeside TCP, WebSocket is another choice of protocol and ideal for HTML5 web game. Leaf uses TCP or WebSocket separately or jointly. In other words, server can handle TCP messages and WebSocket messages at the same time. They are \"transparent\" for developers. From now on we will demonstrate how to use a client based on WebSocket:\n```html\n<script type=\"text/javascript\">\nvar ws = new WebSocket('ws://127.0.0.1:3653')\n\nws.onopen = function() {\n    // Send Hello message\n    ws.send(JSON.stringify({Hello: {\n        Name: 'leaf'\n    }}))\n}\n</script>\n```\n\nSave above to a HTML file and open it in a browser (with WebSocket support). Before that, we still have to update the configuration for LeafServer in bin/conf/server.json by adding WebSocket listenning address：\n```json\n{\n    \"LogLevel\": \"debug\",\n    \"LogPath\": \"\",\n    \"TCPAddr\": \"127.0.0.1:3563\",\n    \"WSAddr\": \"127.0.0.1:3653\",\n    \"MaxConnNum\": 20000\n}\n```\n\nRestart server then we get the first WebSocket message:\n\n```\n2015/09/25 07:50:03 [debug  ] hello leaf\n```\n\nPlease to be noted: Within WebSocket, Leaf always send binary messages rather text messages.\n\n### Leaf in details\n\nLeafServer includes three modules, they are:\n\n* gate module: for management of connection\n* login module: for the user authentication\n* game module: for the main business\n\nThe structure of a Leaf module is suggested (but not forced) to:\n\n1. Be located in a separate directory\n2. Have its internal implementation located under `./internal`\n3. Have a file external.go to expose its interfaces. For instance of external.go:\n\n```go\npackage game\n\nimport (\n    \"server/game/internal\"\n)\n\nvar (\n    // Instantiate game module\n    Module = new(internal.Module)\n    // Expose ChanRPC\n    ChanRPC = internal.ChanRPC\n)\n```\n\nInstantiation of game module must be done before its registration to Leaf framework(detailed in LeafServer main.go). Besides ChanRPC needs to be exposed for inter-module communication.\n\nEnter into game module's internal（LeafServer game/internal/module.go）：\n\n```go\npackage internal\n\nimport (\n    \"github.com/name5566/leaf/module\"\n    \"server/base\"\n)\n\nvar (\n    skeleton = base.NewSkeleton()\n    ChanRPC  = skeleton.ChanRPCServer\n)\n\ntype Module struct {\n    *module.Skeleton\n}\n\nfunc (m *Module) OnInit() {\n    m.Skeleton = skeleton\n}\n\nfunc (m *Module) OnDestroy() {\n\n}\n```\n\nskeleton is the key which implements `Run()` and provides:\n\n* ChanRPC\n* goroutine\n* Timer\n\n### Leaf ChanRPC\n\nSince in Leaf, every module runs in a separate goroutine, a RPC channel is needed to support the communication between modules. The representing object ChanRPC needs to be registered when the game server is being started and actually it is not safe. For example, in LeafServer, game module registers two ChanRPC objects: NewAgent and CloseAgent.\n\n```go\npackage internal\n\nimport (\n    \"github.com/name5566/leaf/gate\"\n)\n\nfunc init() {\n    skeleton.RegisterChanRPC(\"NewAgent\", rpcNewAgent)\n    skeleton.RegisterChanRPC(\"CloseAgent\", rpcCloseAgent)\n}\n\nfunc rpcNewAgent(args []interface{}) {\n\n}\n\nfunc rpcCloseAgent(args []interface{}) {\n\n}\n```\n\nskeleton is used to register ChanRPC. RegisterChanRPC's first parameter is the string name of ChanRPC and the second is the function that implements ChanRPC. NewAgent and CloseAgent will be called by gate module respectively when connection is set up or broken. The calling of ChanRPC includes 3 modes:\n\n1. Synchronous mode : called waiting for ChanRPC is yielded\n2. Asynchronous mode : called with a callback function where you can handle the returned ChanRPC\n3. \"Go mode\" : return immediately ignoring any return values or errors\n\nThis is how gate module call game module's NewAgent ChanRPC (This snippet is simplified for demonstration):\n\n```go\ngame.ChanRPC.Go(\"NewAgent\", a)\n```\n\nHere NewAgent will be called with a parameter a which can be retrieved from args[0], the rest can be done in the same manner.\n\nMore references are at [leaf/chanrpc](https://github.com/name5566/leaf/blob/master/chanrpc). Please be noted, no matter how delicate the encapsulation is, calling function across goroutines cannot be that straight. Try not to create too many modules and interactions. Modules designed in Leaf are supposed to decouple the businesses from others rather make most use of CPU cores. The correct way to make most use of CPU cores is to use goroutine properly.\n\n### Leaf Go\n\nUse goroutine properly can make better use of CPU cores. Leaf implements its own Go() for below reasons:\n\n* Errors within goroutine can be handled\n* Game server needs to wait for all goroutines' execution\n* The results of goroutine can be obtained more easily\n* goroutine will follow the order to be exercised. It is very important in some occasion\n\nHere is an example which can be tested in OnInit() in LeafServer's module.\n\n```go\nlog.Debug(\"1\")\n\n// Define res to make the result watchable\nvar res string\n\nskeleton.Go(func() {\n    // Simulate a slow operation\n    time.Sleep(1 * time.Second)\n\n    // res is modified\n    res = \"3\"\n}, func() {\n    log.Debug(res)\n})\n\nlog.Debug(\"2\")\n```\n\nThe result are:\n\n```go\n2015/08/27 20:37:17 [debug  ] 1\n2015/08/27 20:37:17 [debug  ] 2\n2015/08/27 20:37:18 [debug  ] 3\n```\n\nskeleton.Go() accepts two function parameters, first one will be exercised in a separate goroutine and afterwards the second be exercised within the same goroutine. And res can only be used by one goroutine at one moment so nothing more need to be done for synchronization. This implementation makes CPU can be fully used while no need to block goroutines. It is quite convenient when shared resources are used.\n\nMore references are at [leaf/go](https://github.com/name5566/leaf/blob/master/go)。\n\n### Leaf timer\n\nGo has a built-in implementation in its standard library:\n\n```go\nfunc AfterFunc(d Duration, f func()) *Timer\n```\n\nAfterFunc() will wait for a duration of d then exercises f() in a separate goroutine. Leaf also implement AfterFunc(), and in this version f() will be exercised but within the same goroutine. It will prevent synchronization from happening.\n\n```go\nskeleton.AfterFunc(5 * time.Second, func() {\n    // ...\n})\n```\n\nBesides, Leaf timer support [cron expressions](https://en.wikipedia.org/wiki/Cron) to support scheduled jobs like start at 9am daily or Sunday 6pm weekly.\n\nMore references are at [leaf/timer](https://github.com/name5566/leaf/blob/master/timer)。\n\n### Leaf log\n\nLeaf support below log level:\n\n1. Debug level: Not critical\n2. Release level: Critical\n3. Error level: Errors\n4. Fatal level: Fatal errors\n\nDebug < Release < Error < Fatal (In priority level)\n\nFor LeafServer, bin/conf/server.json is used to configure log level which will filter out the lower level log information. Fatal level log is sort of different and comes only when the game server exit. Usually it records the information when the game server is failed to start up.\n\nSet LogFlag (LeafServer conf/conf.go) to output the file name and the line number:\n\n```\nLogFlag = log.Lshortfile\n```\n\nLogFlag：[https://golang.org/pkg/log/#pkg-constants](https://golang.org/pkg/log/#pkg-constants)\n\n\nMore references are at [leaf/log](https://github.com/name5566/leaf/blob/master/log).\n\n### Leaf recordfile\n\nLeaf recordfile is formatted in CSV([Example](https://github.com/name5566/leaf/blob/master/recordfile/test.txt)). recordfile is to manage the configuration for game. The usage of recordfile in LeafServer is quite simple:\n\n1. Create a CSV file under bin/gamedata\n2. Call readRf() to read it in gamedata module\n\nSamples:\n\n```go\n// Make sure Test.txt is located in bin/gamedata\n// The file name must match the name of the struct, and all characters are case sensitive.\n// Every instance of defined struct maps to one specific row in recordfile\ntype Test struct {\n    // The type of first column is int\n    // \"index\" means this column will be indexed(exclusively)\n    Id  int \"index\"\n    // The type of second column is an array of int with a length of 4\n    Arr [4]int\n    // The type of third column is string\n    Str string\n}\n\n// Load recordfile Test.txt into memory\n// RfTest is the object that represents Test.txt in memory\nvar RfTest = readRf(Test{})\n\nfunc init() {\n    // Search in index\n    // Fetch the row with id equals 1 in Test.txt\n    r := RfTest.Index(1)\n\n    if r != nil {\n        row := r.(*Test)\n\n        // Log this row\n        log.Debug(\"%v %v %v\", row.Id, row.Arr, row.Str)\n    }\n}\n```\n\nRefer to [leaf/recordfile](https://github.com/name5566/leaf/blob/master/recordfile) for more details.\n\nLearn more\n----------\n\nMore references are at Wiki [https://github.com/name5566/leaf/wiki](https://github.com/name5566/leaf/wiki)\n"
        },
        {
          "name": "TUTORIAL_ZH.md",
          "type": "blob",
          "size": 15.83984375,
          "content": "Leaf 游戏服务器框架简介\n==================\n\nLeaf 是一个由 Go 语言（golang）编写的开发效率和执行效率并重的开源游戏服务器框架。Leaf 适用于各类游戏服务器的开发，包括 H5（HTML5）游戏服务器。\n\nLeaf 的关注点：\n\n* 良好的使用体验。Leaf 总是尽可能的提供简洁和易用的接口，尽可能的提升开发的效率\n* 稳定性。Leaf 总是尽可能的恢复运行过程中的错误，避免崩溃\n* 多核支持。Leaf 通过模块机制和 [leaf/go](https://github.com/name5566/leaf/tree/master/go) 尽可能的利用多核资源，同时又尽量避免各种副作用\n* 模块机制。\n\nLeaf 的模块机制\n---------------\n\n一个 Leaf 开发的游戏服务器由多个模块组成（例如 [LeafServer](https://github.com/name5566/leafserver)），模块有以下特点：\n\n* 每个模块运行在一个单独的 goroutine 中\n* 模块间通过一套轻量的 RPC 机制通讯（[leaf/chanrpc](https://github.com/name5566/leaf/tree/master/chanrpc)）\n\nLeaf 不建议在游戏服务器中设计过多的模块。\n\n游戏服务器在启动时进行模块的注册，例如：\n\n```go\nleaf.Run(\n\tgame.Module,\n\tgate.Module,\n\tlogin.Module,\n)\n```\n\n这里按顺序注册了 game、gate、login 三个模块。每个模块都需要实现接口：\n\n```go\ntype Module interface {\n\tOnInit()\n\tOnDestroy()\n\tRun(closeSig chan bool)\n}\n```\n\nLeaf 首先会在同一个 goroutine 中按模块注册顺序执行模块的 OnInit 方法，等到所有模块 OnInit 方法执行完成后则为每一个模块启动一个 goroutine 并执行模块的 Run 方法。最后，游戏服务器关闭时（Ctrl + C 关闭游戏服务器）将按模块注册相反顺序在同一个 goroutine 中执行模块的 OnDestroy 方法。\n\nLeaf 源码概览\n---------------\n\n* leaf/chanrpc 提供了一套基于 channel 的 RPC 机制，用于游戏服务器模块间通讯\n* leaf/db 数据库相关，目前支持 [MongoDB](https://www.mongodb.org/)\n* leaf/gate 网关模块，负责游戏客户端的接入\n* leaf/go 用于创建能够被 Leaf 管理的 goroutine\n* leaf/log 日志相关\n* leaf/network 网络相关，使用 TCP 和 WebSocket 协议，可自定义消息格式，默认 Leaf 提供了基于 [protobuf](https://developers.google.com/protocol-buffers) 和 JSON 的消息格式\n* leaf/recordfile 用于管理游戏数据\n* leaf/timer 定时器相关\n* leaf/util 辅助库\n\n使用 Leaf 开发游戏服务器\n---------------\n\n[LeafServer](https://github.com/name5566/leafserver) 是一个基于 Leaf 开发的游戏服务器，我们以 LeafServer 作为起点。\n\n获取 LeafServer：\n\n```\ngit clone https://github.com/name5566/leafserver\n```\n\n设置 leafserver 目录到 GOPATH 环境变量后获取 Leaf：\n\n```\ngo get github.com/name5566/leaf\n```\n\n编译 LeafServer：\n\n```\ngo install server\n```\n\n如果一切顺利，运行 server 你可以获得以下输出：\n\n```\n2015/08/26 22:11:27 [release] Leaf 1.1.2 starting up\n```\n\n敲击 Ctrl + C 关闭游戏服务器，服务器正常关闭输出：\n\n```\n2015/08/26 22:12:30 [release] Leaf closing down (signal: interrupt)\n```\n\n### Hello Leaf\n\n现在，在 LeafServer 的基础上，我们来看看游戏服务器如何接收和处理网络消息。\n\n首先定义一个 JSON 格式的消息（protobuf 类似）。打开 LeafServer msg/msg.go 文件可以看到如下代码：\n\n```go\npackage msg\n\nimport (\n\t\"github.com/name5566/leaf/network\"\n)\n\nvar Processor network.Processor\n\nfunc init() {\n\n}\n```\n\nProcessor 为消息的处理器（可由用户自定义），这里我们使用 Leaf 默认提供的 JSON 消息处理器并尝试添加一个名字为 Hello 的消息：\n\n```go\npackage msg\n\nimport (\n\t\"github.com/name5566/leaf/network/json\"\n)\n\n// 使用默认的 JSON 消息处理器（默认还提供了 protobuf 消息处理器）\nvar Processor = json.NewProcessor()\n\nfunc init() {\n\t// 这里我们注册了一个 JSON 消息 Hello\n\tProcessor.Register(&Hello{})\n}\n\n// 一个结构体定义了一个 JSON 消息的格式\n// 消息名为 Hello\ntype Hello struct {\n\tName string\n}\n```\n\n客户端发送到游戏服务器的消息需要通过 gate 模块路由，简而言之，gate 模块决定了某个消息具体交给内部的哪个模块来处理。这里，我们将 Hello 消息路由到 game 模块中。打开 LeafServer gate/router.go，敲入如下代码：\n\n```go\npackage gate\n\nimport (\n\t\"server/game\"\n\t\"server/msg\"\n)\n\nfunc init() {\n\t// 这里指定消息 Hello 路由到 game 模块\n\t// 模块间使用 ChanRPC 通讯，消息路由也不例外\n\tmsg.Processor.SetRouter(&msg.Hello{}, game.ChanRPC)\n}\n```\n\n一切就绪，我们现在可以在 game 模块中处理 Hello 消息了。打开 LeafServer game/internal/handler.go，敲入如下代码：\n\n```go\npackage internal\n\nimport (\n\t\"github.com/name5566/leaf/log\"\n\t\"github.com/name5566/leaf/gate\"\n\t\"reflect\"\n\t\"server/msg\"\n)\n\nfunc init() {\n\t// 向当前模块（game 模块）注册 Hello 消息的消息处理函数 handleHello\n\thandler(&msg.Hello{}, handleHello)\n}\n\nfunc handler(m interface{}, h interface{}) {\n\tskeleton.RegisterChanRPC(reflect.TypeOf(m), h)\n}\n\nfunc handleHello(args []interface{}) {\n\t// 收到的 Hello 消息\n\tm := args[0].(*msg.Hello)\n\t// 消息的发送者\n\ta := args[1].(gate.Agent)\n\n\t// 输出收到的消息的内容\n\tlog.Debug(\"hello %v\", m.Name)\n\n\t// 给发送者回应一个 Hello 消息\n\ta.WriteMsg(&msg.Hello{\n\t\tName: \"client\",\n\t})\n}\n```\n\n到这里，一个简单的范例就完成了。为了更加清楚的了解消息的格式，我们从 0 编写一个最简单的测试客户端。\n\nLeaf 中，当选择使用 TCP 协议时，在网络中传输的消息都会使用以下格式：\n\n```\n--------------\n| len | data |\n--------------\n```\n\n其中：\n\n1. len 表示了 data 部分的长度（字节数）。len 本身也有长度，默认为 2 字节（可配置），len 本身的长度决定了单个消息的最大大小\n2. data 部分使用 JSON 或者 protobuf 编码（也可自定义其他编码方式）\n\n测试客户端同样使用 Go 语言编写：\n```go\npackage main\n\nimport (\n\t\"encoding/binary\"\n\t\"net\"\n)\n\nfunc main() {\n\tconn, err := net.Dial(\"tcp\", \"127.0.0.1:3563\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Hello 消息（JSON 格式）\n\t// 对应游戏服务器 Hello 消息结构体\n\tdata := []byte(`{\n\t\t\"Hello\": {\n\t\t\t\"Name\": \"leaf\"\n\t\t}\n\t}`)\n\n\t// len + data\n\tm := make([]byte, 2+len(data))\n\n\t// 默认使用大端序\n\tbinary.BigEndian.PutUint16(m, uint16(len(data)))\n\n\tcopy(m[2:], data)\n\n\t// 发送消息\n\tconn.Write(m)\n}\n```\n\n执行此测试客户端，游戏服务器输出：\n\n```\n2015/09/25 07:41:03 [debug  ] hello leaf\n2015/09/25 07:41:03 [debug  ] read message: read tcp 127.0.0.1:3563->127.0.0.1:54599: wsarecv: An existing connection was forcibly closed by the remote host.\n```\n\n测试客户端发送完消息以后就退出了，此时和游戏服务器的连接断开，相应的，游戏服务器输出连接断开的提示日志（第二条日志，日志的具体内容和 Go 语言版本有关）。\n\n除了使用 TCP 协议外，还可以选择使用 WebSocket 协议（例如开发 H5 游戏）。Leaf 可以单独使用 TCP 协议或 WebSocket 协议，也可以同时使用两者，换而言之，服务器可以同时接受 TCP 连接和 WebSocket 连接，对开发者而言消息来自 TCP 还是 WebSocket 是完全透明的。现在，我们来编写一个对应上例的使用 WebSocket 协议的客户端：\n```html\n<script type=\"text/javascript\">\nvar ws = new WebSocket('ws://127.0.0.1:3653')\n\nws.onopen = function() {\n    // 发送 Hello 消息\n    ws.send(JSON.stringify({Hello: {\n        Name: 'leaf'\n    }}))\n}\n</script>\n```\n\n保存上述代码到某 HTML 文件中并使用（任意支持 WebSocket 协议的）浏览器打开。在打开此 HTML 文件前，首先需要配置一下 LeafServer 的 bin/conf/server.json 文件，增加 WebSocket 监听地址（WSAddr）：\n```json\n{\n    \"LogLevel\": \"debug\",\n    \"LogPath\": \"\",\n    \"TCPAddr\": \"127.0.0.1:3563\",\n    \"WSAddr\": \"127.0.0.1:3653\",\n    \"MaxConnNum\": 20000\n}\n```\n\n重启游戏服务器后，方可接受 WebSocket 消息：\n\n```\n2015/09/25 07:50:03 [debug  ] hello leaf\n```\n\n在 Leaf 中使用 WebSocket 需要注意的一点是：Leaf 总是发送二进制消息而非文本消息。\n\n### Leaf 模块详解\n\nLeafServer 中包含了 3 个模块，它们分别是：\n\n* gate 模块，负责游戏客户端的接入\n* login 模块，负责登录流程\n* game 模块，负责游戏主逻辑\n\n一般来说（而非强制规定），从代码结构上，一个 Leaf 模块：\n\n1. 放置于一个目录中（例如 game 模块放置于 game 目录中）\n2. 模块的具体实现放置于 internal 包中（例如 game 模块的具体实现放置于 game/internal 包中）\n\n每个模块下一般有一个 external.go 的文件，顾名思义表示模块对外暴露的接口，这里以 game 模块的 external.go 文件为例：\n\n```go\npackage game\n\nimport (\n\t\"server/game/internal\"\n)\n\nvar (\n\t// 实例化 game 模块\n\tModule  = new(internal.Module)\n\t// 暴露 ChanRPC\n\tChanRPC = internal.ChanRPC\n)\n```\n\n首先，模块会被实例化，这样才能注册到 Leaf 框架中（详见 LeafServer main.go），另外，模块暴露的 ChanRPC 被用于模块间通讯。\n\n进入 game 模块的内部（LeafServer game/internal/module.go）：\n\n```go\npackage internal\n\nimport (\n\t\"github.com/name5566/leaf/module\"\n\t\"server/base\"\n)\n\nvar (\n\tskeleton = base.NewSkeleton()\n\tChanRPC  = skeleton.ChanRPCServer\n)\n\ntype Module struct {\n\t*module.Skeleton\n}\n\nfunc (m *Module) OnInit() {\n\tm.Skeleton = skeleton\n}\n\nfunc (m *Module) OnDestroy() {\n\n}\n```\n\n模块中最关键的就是 skeleton（骨架），skeleton 实现了 Module 接口的 Run 方法并提供了：\n\n* ChanRPC\n* goroutine\n* 定时器\n\n### Leaf ChanRPC\n\n由于 Leaf 中，每个模块跑在独立的 goroutine 上，为了模块间方便的相互调用就有了基于 channel 的 RPC 机制。一个 ChanRPC 需要在游戏服务器初始化的时候进行注册（注册过程不是 goroutine 安全的），例如 LeafServer 中 game 模块注册了 NewAgent 和 CloseAgent 两个 ChanRPC：\n\n```go\npackage internal\n\nimport (\n\t\"github.com/name5566/leaf/gate\"\n)\n\nfunc init() {\n\tskeleton.RegisterChanRPC(\"NewAgent\", rpcNewAgent)\n\tskeleton.RegisterChanRPC(\"CloseAgent\", rpcCloseAgent)\n}\n\nfunc rpcNewAgent(args []interface{}) {\n\n}\n\nfunc rpcCloseAgent(args []interface{}) {\n\n}\n```\n\n使用 skeleton 来注册 ChanRPC。RegisterChanRPC 的第一个参数是 ChanRPC 的名字，第二个参数是 ChanRPC 的实现。这里的 NewAgent 和 CloseAgent 会被 LeafServer 的 gate 模块在连接建立和连接中断时调用。ChanRPC 的调用方有 3 种调用模式：\n\n1. 同步模式，调用并等待 ChanRPC 返回\n2. 异步模式，调用并提供回调函数，回调函数会在 ChanRPC 返回后被调用\n3. Go 模式，调用并立即返回，忽略任何返回值和错误\n\ngate 模块这样调用 game 模块的 NewAgent ChanRPC（这仅仅是一个示例，实际的代码细节复杂的多）：\n\n```go\ngame.ChanRPC.Go(\"NewAgent\", a)\n```\n\n这里调用 NewAgent 并传递参数 a，我们在 rpcNewAgent 的参数 args[0] 中可以取到 a（args[1] 表示第二个参数，以此类推）。\n\n更加详细的用法可以参考 [leaf/chanrpc](https://github.com/name5566/leaf/blob/master/chanrpc)。需要注意的是，无论封装多么精巧，跨 goroutine 的调用总不能像直接的函数调用那样简单直接，因此除非必要我们不要构建太多的模块，模块间不要太频繁的交互。模块在 Leaf 中被设计出来最主要是用于划分功能而非利用多核，Leaf 认为在模块内按需使用 goroutine 才是多核利用率问题的解决之道。\n\n### Leaf Go\n\n善用 goroutine 能够充分利用多核资源，Leaf 提供的 Go 机制解决了原生 goroutine 存在的一些问题：\n\n* 能够恢复 goroutine 运行过程中的错误\n* 游戏服务器会等待所有 goroutine 执行结束后才关闭\n* 非常方便的获取 goroutine 执行的结果数据\n* 在一些特殊场合保证 goroutine 按创建顺序执行\n\n我们来看一个例子（可以在 LeafServer 的模块的 OnInit 方法中测试）：\n\n```go\nlog.Debug(\"1\")\n\n// 定义变量 res 接收结果\nvar res string\n\nskeleton.Go(func() {\n\t// 这里使用 Sleep 来模拟一个很慢的操作\n\ttime.Sleep(1 * time.Second)\n\n\t// 假定得到结果\n\tres = \"3\"\n}, func() {\n\tlog.Debug(res)\n})\n\nlog.Debug(\"2\")\n```\n\n上面代码执行结果如下：\n\n```go\n2015/08/27 20:37:17 [debug  ] 1\n2015/08/27 20:37:17 [debug  ] 2\n2015/08/27 20:37:18 [debug  ] 3\n```\n\n这里的 Go 方法接收 2 个函数作为参数，第一个函数会被放置在一个新创建的 goroutine 中执行，在其执行完成之后，第二个函数会在当前 goroutine 中被执行。由此，我们可以看到变量 res 同一时刻总是只被一个 goroutine 访问，这就避免了同步机制的使用。Go 的设计使得 CPU 得到充分利用，避免操作阻塞当前 goroutine，同时又无需为共享资源同步而忧心。\n\n更加详细的用法可以参考 [leaf/go](https://github.com/name5566/leaf/blob/master/go)。\n\n### Leaf timer\n\nGo 语言标准库提供了定时器的支持：\n\n```go\nfunc AfterFunc(d Duration, f func()) *Timer\n```\n\nAfterFunc 会等待 d 时长后调用 f 函数，这里的 f 函数将在另外一个 goroutine 中执行。Leaf 提供了一个相同的 AfterFunc 函数，相比之下，f 函数在 AfterFunc 的调用 goroutine 中执行，这样就避免了同步机制的使用：\n\n```go\nskeleton.AfterFunc(5 * time.Second, func() {\n\t// ...\n})\n```\n\n另外，Leaf timer 还支持 [cron 表达式](https://en.wikipedia.org/wiki/Cron)，用于实现诸如“每天 9 点执行”、“每周末 6 点执行”的逻辑。\n\n更加详细的用法可以参考 [leaf/timer](https://github.com/name5566/leaf/blob/master/timer)。\n\n### Leaf log\n\nLeaf 的 log 系统支持多种日志级别：\n\n1. Debug 日志，非关键日志\n2. Release 日志，关键日志\n3. Error 日志，错误日志\n4. Fatal 日志，致命错误日志\n\nDebug < Release < Error < Fatal（日志级别高低）\n\n在 LeafServer 中，bin/conf/server.json 可以配置日志级别，低于配置的日志级别的日志将不会输出。Fatal 日志比较特殊，每次输出 Fatal 日志之后游戏服务器进程就会结束，通常来说，只在游戏服务器初始化失败时使用 Fatal 日志。\n\n我们还可以通过配置 LeafServer conf/conf.go 的 LogFlag 来在日志中输出文件名和行号：\n\n```\nLogFlag = log.Lshortfile\n```\n\n可用的 LogFlag 见：[https://golang.org/pkg/log/#pkg-constants](https://golang.org/pkg/log/#pkg-constants)\n\n\n更加详细的用法可以参考 [leaf/log](https://github.com/name5566/leaf/blob/master/log)。\n\n### Leaf recordfile\n\nLeaf 的 recordfile 是基于 CSV 格式（范例见[这里](https://github.com/name5566/leaf/blob/master/recordfile/test.txt)）。recordfile 用于管理游戏配置数据。在 LeafServer 中使用 recordfile 非常简单：\n\n1. 将 CSV 文件放置于 bin/gamedata 目录中\n2. 在 gamedata 模块中调用函数 readRf 读取 CSV 文件\n\n范例：\n\n```go\n// 确保 bin/gamedata 目录中存在 Test.txt 文件\n// 文件名必须和此结构体名称相同（大小写敏感）\n// 结构体的一个实例映射 recordfile 中的一行\ntype Test struct {\n\t// 将第一列按 int 类型解析\n\t// \"index\" 表明在此列上建立唯一索引\n\tId  int \"index\"\n\t// 将第二列解析为长度为 4 的整型数组\n\tArr [4]int\n\t// 将第三列解析为字符串\n\tStr string\n}\n\n// 读取 recordfile Test.txt 到内存中\n// RfTest 即为 Test.txt 的内存镜像\nvar RfTest = readRf(Test{})\n\nfunc init() {\n\t// 按索引查找\n\t// 获取 Test.txt 中 Id 为 1 的那一行\n\tr := RfTest.Index(1)\n\n\tif r != nil {\n\t\trow := r.(*Test)\n\n\t\t// 输出此行的所有列的数据\n\t\tlog.Debug(\"%v %v %v\", row.Id, row.Arr, row.Str)\n\t}\n}\n```\n\n更加详细的用法可以参考 [leaf/recordfile](https://github.com/name5566/leaf/blob/master/recordfile)。\n\n了解更多\n---------------\n\n阅读 Wiki 获取更多的帮助：[https://github.com/name5566/leaf/wiki](https://github.com/name5566/leaf/wiki)\n"
        },
        {
          "name": "chanrpc",
          "type": "tree",
          "content": null
        },
        {
          "name": "cluster",
          "type": "tree",
          "content": null
        },
        {
          "name": "conf",
          "type": "tree",
          "content": null
        },
        {
          "name": "console",
          "type": "tree",
          "content": null
        },
        {
          "name": "db",
          "type": "tree",
          "content": null
        },
        {
          "name": "gate",
          "type": "tree",
          "content": null
        },
        {
          "name": "go",
          "type": "tree",
          "content": null
        },
        {
          "name": "leaf.go",
          "type": "blob",
          "size": 0.818359375,
          "content": "package leaf\n\nimport (\n\t\"github.com/name5566/leaf/cluster\"\n\t\"github.com/name5566/leaf/conf\"\n\t\"github.com/name5566/leaf/console\"\n\t\"github.com/name5566/leaf/log\"\n\t\"github.com/name5566/leaf/module\"\n\t\"os\"\n\t\"os/signal\"\n)\n\nfunc Run(mods ...module.Module) {\n\t// logger\n\tif conf.LogLevel != \"\" {\n\t\tlogger, err := log.New(conf.LogLevel, conf.LogPath, conf.LogFlag)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tlog.Export(logger)\n\t\tdefer logger.Close()\n\t}\n\n\tlog.Release(\"Leaf %v starting up\", version)\n\n\t// module\n\tfor i := 0; i < len(mods); i++ {\n\t\tmodule.Register(mods[i])\n\t}\n\tmodule.Init()\n\n\t// cluster\n\tcluster.Init()\n\n\t// console\n\tconsole.Init()\n\n\t// close\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, os.Interrupt, os.Kill)\n\tsig := <-c\n\tlog.Release(\"Leaf closing down (signal: %v)\", sig)\n\tconsole.Destroy()\n\tcluster.Destroy()\n\tmodule.Destroy()\n}\n"
        },
        {
          "name": "log",
          "type": "tree",
          "content": null
        },
        {
          "name": "module",
          "type": "tree",
          "content": null
        },
        {
          "name": "network",
          "type": "tree",
          "content": null
        },
        {
          "name": "recordfile",
          "type": "tree",
          "content": null
        },
        {
          "name": "timer",
          "type": "tree",
          "content": null
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.037109375,
          "content": "package leaf\n\nconst version = \"1.1.3\"\n"
        }
      ]
    }
  ]
}