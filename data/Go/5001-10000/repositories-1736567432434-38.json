{
  "metadata": {
    "timestamp": 1736567432434,
    "page": 38,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "lib/pq",
      "stars": 9245,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0322265625,
          "content": ".db\n*.test\n*~\n*.swp\n.idea\n.vscode"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.083984375,
          "content": "Copyright (c) 2011-2013, 'pq' Contributors\nPortions Copyright (C) 2011 Blake Mizerany\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.224609375,
          "content": "# pq - A pure Go postgres driver for Go's database/sql package\n\n[![GoDoc](https://godoc.org/github.com/lib/pq?status.svg)](https://pkg.go.dev/github.com/lib/pq?tab=doc)\n\n## Install\n\n\tgo get github.com/lib/pq\n\n## Features\n\n* SSL\n* Handles bad connections for `database/sql`\n* Scan `time.Time` correctly (i.e. `timestamp[tz]`, `time[tz]`, `date`)\n* Scan binary blobs correctly (i.e. `bytea`)\n* Package for `hstore` support\n* COPY FROM support\n* pq.ParseURL for converting urls to connection strings for sql.Open.\n* Many libpq compatible environment variables\n* Unix socket support\n* Notifications: `LISTEN`/`NOTIFY`\n* pgpass support\n* GSS (Kerberos) auth\n\n## Tests\n\n`go test` is used for testing.  See [TESTS.md](TESTS.md) for more details.\n\n## Status\n\nThis package is currently in maintenance mode, which means:\n1.   It generally does not accept new features.\n2.   It does accept bug fixes and version compatability changes provided by the community.\n3.   Maintainers usually do not resolve reported issues.\n4.   Community members are encouraged to help each other with reported issues.\n\nFor users that require new features or reliable resolution of reported bugs, we recommend using [pgx](https://github.com/jackc/pgx) which is under active development.\n"
        },
        {
          "name": "TESTS.md",
          "type": "blob",
          "size": 0.642578125,
          "content": "# Tests\n\n## Running Tests\n\n`go test` is used for testing. A running PostgreSQL\nserver is required, with the ability to log in. The\ndatabase to connect to test with is \"pqgotest,\" on\n\"localhost\" but these can be overridden using [environment\nvariables](https://www.postgresql.org/docs/9.3/static/libpq-envars.html).\n\nExample:\n\n\tPGHOST=/run/postgresql go test\n\n## Benchmarks\n\nA benchmark suite can be run as part of the tests:\n\n\tgo test -bench .\n\n## Example setup (Docker)\n\nRun a postgres container:\n\n```\ndocker run --expose 5432:5432 postgres\n```\n\nRun tests:\n\n```\nPGHOST=localhost PGPORT=5432 PGUSER=postgres PGSSLMODE=disable PGDATABASE=postgres go test\n```\n"
        },
        {
          "name": "array.go",
          "type": "blob",
          "size": 20.2353515625,
          "content": "package pq\n\nimport (\n\t\"bytes\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar typeByteSlice = reflect.TypeOf([]byte{})\nvar typeDriverValuer = reflect.TypeOf((*driver.Valuer)(nil)).Elem()\nvar typeSQLScanner = reflect.TypeOf((*sql.Scanner)(nil)).Elem()\n\n// Array returns the optimal driver.Valuer and sql.Scanner for an array or\n// slice of any dimension.\n//\n// For example:\n//  db.Query(`SELECT * FROM t WHERE id = ANY($1)`, pq.Array([]int{235, 401}))\n//\n//  var x []sql.NullInt64\n//  db.QueryRow(`SELECT ARRAY[235, 401]`).Scan(pq.Array(&x))\n//\n// Scanning multi-dimensional arrays is not supported.  Arrays where the lower\n// bound is not one (such as `[0:0]={1}') are not supported.\nfunc Array(a interface{}) interface {\n\tdriver.Valuer\n\tsql.Scanner\n} {\n\tswitch a := a.(type) {\n\tcase []bool:\n\t\treturn (*BoolArray)(&a)\n\tcase []float64:\n\t\treturn (*Float64Array)(&a)\n\tcase []float32:\n\t\treturn (*Float32Array)(&a)\n\tcase []int64:\n\t\treturn (*Int64Array)(&a)\n\tcase []int32:\n\t\treturn (*Int32Array)(&a)\n\tcase []string:\n\t\treturn (*StringArray)(&a)\n\tcase [][]byte:\n\t\treturn (*ByteaArray)(&a)\n\n\tcase *[]bool:\n\t\treturn (*BoolArray)(a)\n\tcase *[]float64:\n\t\treturn (*Float64Array)(a)\n\tcase *[]float32:\n\t\treturn (*Float32Array)(a)\n\tcase *[]int64:\n\t\treturn (*Int64Array)(a)\n\tcase *[]int32:\n\t\treturn (*Int32Array)(a)\n\tcase *[]string:\n\t\treturn (*StringArray)(a)\n\tcase *[][]byte:\n\t\treturn (*ByteaArray)(a)\n\t}\n\n\treturn GenericArray{a}\n}\n\n// ArrayDelimiter may be optionally implemented by driver.Valuer or sql.Scanner\n// to override the array delimiter used by GenericArray.\ntype ArrayDelimiter interface {\n\t// ArrayDelimiter returns the delimiter character(s) for this element's type.\n\tArrayDelimiter() string\n}\n\n// BoolArray represents a one-dimensional array of the PostgreSQL boolean type.\ntype BoolArray []bool\n\n// Scan implements the sql.Scanner interface.\nfunc (a *BoolArray) Scan(src interface{}) error {\n\tswitch src := src.(type) {\n\tcase []byte:\n\t\treturn a.scanBytes(src)\n\tcase string:\n\t\treturn a.scanBytes([]byte(src))\n\tcase nil:\n\t\t*a = nil\n\t\treturn nil\n\t}\n\n\treturn fmt.Errorf(\"pq: cannot convert %T to BoolArray\", src)\n}\n\nfunc (a *BoolArray) scanBytes(src []byte) error {\n\telems, err := scanLinearArray(src, []byte{','}, \"BoolArray\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif *a != nil && len(elems) == 0 {\n\t\t*a = (*a)[:0]\n\t} else {\n\t\tb := make(BoolArray, len(elems))\n\t\tfor i, v := range elems {\n\t\t\tif len(v) != 1 {\n\t\t\t\treturn fmt.Errorf(\"pq: could not parse boolean array index %d: invalid boolean %q\", i, v)\n\t\t\t}\n\t\t\tswitch v[0] {\n\t\t\tcase 't':\n\t\t\t\tb[i] = true\n\t\t\tcase 'f':\n\t\t\t\tb[i] = false\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"pq: could not parse boolean array index %d: invalid boolean %q\", i, v)\n\t\t\t}\n\t\t}\n\t\t*a = b\n\t}\n\treturn nil\n}\n\n// Value implements the driver.Valuer interface.\nfunc (a BoolArray) Value() (driver.Value, error) {\n\tif a == nil {\n\t\treturn nil, nil\n\t}\n\n\tif n := len(a); n > 0 {\n\t\t// There will be exactly two curly brackets, N bytes of values,\n\t\t// and N-1 bytes of delimiters.\n\t\tb := make([]byte, 1+2*n)\n\n\t\tfor i := 0; i < n; i++ {\n\t\t\tb[2*i] = ','\n\t\t\tif a[i] {\n\t\t\t\tb[1+2*i] = 't'\n\t\t\t} else {\n\t\t\t\tb[1+2*i] = 'f'\n\t\t\t}\n\t\t}\n\n\t\tb[0] = '{'\n\t\tb[2*n] = '}'\n\n\t\treturn string(b), nil\n\t}\n\n\treturn \"{}\", nil\n}\n\n// ByteaArray represents a one-dimensional array of the PostgreSQL bytea type.\ntype ByteaArray [][]byte\n\n// Scan implements the sql.Scanner interface.\nfunc (a *ByteaArray) Scan(src interface{}) error {\n\tswitch src := src.(type) {\n\tcase []byte:\n\t\treturn a.scanBytes(src)\n\tcase string:\n\t\treturn a.scanBytes([]byte(src))\n\tcase nil:\n\t\t*a = nil\n\t\treturn nil\n\t}\n\n\treturn fmt.Errorf(\"pq: cannot convert %T to ByteaArray\", src)\n}\n\nfunc (a *ByteaArray) scanBytes(src []byte) error {\n\telems, err := scanLinearArray(src, []byte{','}, \"ByteaArray\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif *a != nil && len(elems) == 0 {\n\t\t*a = (*a)[:0]\n\t} else {\n\t\tb := make(ByteaArray, len(elems))\n\t\tfor i, v := range elems {\n\t\t\tb[i], err = parseBytea(v)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"could not parse bytea array index %d: %s\", i, err.Error())\n\t\t\t}\n\t\t}\n\t\t*a = b\n\t}\n\treturn nil\n}\n\n// Value implements the driver.Valuer interface. It uses the \"hex\" format which\n// is only supported on PostgreSQL 9.0 or newer.\nfunc (a ByteaArray) Value() (driver.Value, error) {\n\tif a == nil {\n\t\treturn nil, nil\n\t}\n\n\tif n := len(a); n > 0 {\n\t\t// There will be at least two curly brackets, 2*N bytes of quotes,\n\t\t// 3*N bytes of hex formatting, and N-1 bytes of delimiters.\n\t\tsize := 1 + 6*n\n\t\tfor _, x := range a {\n\t\t\tsize += hex.EncodedLen(len(x))\n\t\t}\n\n\t\tb := make([]byte, size)\n\n\t\tfor i, s := 0, b; i < n; i++ {\n\t\t\to := copy(s, `,\"\\\\x`)\n\t\t\to += hex.Encode(s[o:], a[i])\n\t\t\ts[o] = '\"'\n\t\t\ts = s[o+1:]\n\t\t}\n\n\t\tb[0] = '{'\n\t\tb[size-1] = '}'\n\n\t\treturn string(b), nil\n\t}\n\n\treturn \"{}\", nil\n}\n\n// Float64Array represents a one-dimensional array of the PostgreSQL double\n// precision type.\ntype Float64Array []float64\n\n// Scan implements the sql.Scanner interface.\nfunc (a *Float64Array) Scan(src interface{}) error {\n\tswitch src := src.(type) {\n\tcase []byte:\n\t\treturn a.scanBytes(src)\n\tcase string:\n\t\treturn a.scanBytes([]byte(src))\n\tcase nil:\n\t\t*a = nil\n\t\treturn nil\n\t}\n\n\treturn fmt.Errorf(\"pq: cannot convert %T to Float64Array\", src)\n}\n\nfunc (a *Float64Array) scanBytes(src []byte) error {\n\telems, err := scanLinearArray(src, []byte{','}, \"Float64Array\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif *a != nil && len(elems) == 0 {\n\t\t*a = (*a)[:0]\n\t} else {\n\t\tb := make(Float64Array, len(elems))\n\t\tfor i, v := range elems {\n\t\t\tif b[i], err = strconv.ParseFloat(string(v), 64); err != nil {\n\t\t\t\treturn fmt.Errorf(\"pq: parsing array element index %d: %v\", i, err)\n\t\t\t}\n\t\t}\n\t\t*a = b\n\t}\n\treturn nil\n}\n\n// Value implements the driver.Valuer interface.\nfunc (a Float64Array) Value() (driver.Value, error) {\n\tif a == nil {\n\t\treturn nil, nil\n\t}\n\n\tif n := len(a); n > 0 {\n\t\t// There will be at least two curly brackets, N bytes of values,\n\t\t// and N-1 bytes of delimiters.\n\t\tb := make([]byte, 1, 1+2*n)\n\t\tb[0] = '{'\n\n\t\tb = strconv.AppendFloat(b, a[0], 'f', -1, 64)\n\t\tfor i := 1; i < n; i++ {\n\t\t\tb = append(b, ',')\n\t\t\tb = strconv.AppendFloat(b, a[i], 'f', -1, 64)\n\t\t}\n\n\t\treturn string(append(b, '}')), nil\n\t}\n\n\treturn \"{}\", nil\n}\n\n// Float32Array represents a one-dimensional array of the PostgreSQL double\n// precision type.\ntype Float32Array []float32\n\n// Scan implements the sql.Scanner interface.\nfunc (a *Float32Array) Scan(src interface{}) error {\n\tswitch src := src.(type) {\n\tcase []byte:\n\t\treturn a.scanBytes(src)\n\tcase string:\n\t\treturn a.scanBytes([]byte(src))\n\tcase nil:\n\t\t*a = nil\n\t\treturn nil\n\t}\n\n\treturn fmt.Errorf(\"pq: cannot convert %T to Float32Array\", src)\n}\n\nfunc (a *Float32Array) scanBytes(src []byte) error {\n\telems, err := scanLinearArray(src, []byte{','}, \"Float32Array\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif *a != nil && len(elems) == 0 {\n\t\t*a = (*a)[:0]\n\t} else {\n\t\tb := make(Float32Array, len(elems))\n\t\tfor i, v := range elems {\n\t\t\tvar x float64\n\t\t\tif x, err = strconv.ParseFloat(string(v), 32); err != nil {\n\t\t\t\treturn fmt.Errorf(\"pq: parsing array element index %d: %v\", i, err)\n\t\t\t}\n\t\t\tb[i] = float32(x)\n\t\t}\n\t\t*a = b\n\t}\n\treturn nil\n}\n\n// Value implements the driver.Valuer interface.\nfunc (a Float32Array) Value() (driver.Value, error) {\n\tif a == nil {\n\t\treturn nil, nil\n\t}\n\n\tif n := len(a); n > 0 {\n\t\t// There will be at least two curly brackets, N bytes of values,\n\t\t// and N-1 bytes of delimiters.\n\t\tb := make([]byte, 1, 1+2*n)\n\t\tb[0] = '{'\n\n\t\tb = strconv.AppendFloat(b, float64(a[0]), 'f', -1, 32)\n\t\tfor i := 1; i < n; i++ {\n\t\t\tb = append(b, ',')\n\t\t\tb = strconv.AppendFloat(b, float64(a[i]), 'f', -1, 32)\n\t\t}\n\n\t\treturn string(append(b, '}')), nil\n\t}\n\n\treturn \"{}\", nil\n}\n\n// GenericArray implements the driver.Valuer and sql.Scanner interfaces for\n// an array or slice of any dimension.\ntype GenericArray struct{ A interface{} }\n\nfunc (GenericArray) evaluateDestination(rt reflect.Type) (reflect.Type, func([]byte, reflect.Value) error, string) {\n\tvar assign func([]byte, reflect.Value) error\n\tvar del = \",\"\n\n\t// TODO calculate the assign function for other types\n\t// TODO repeat this section on the element type of arrays or slices (multidimensional)\n\t{\n\t\tif reflect.PtrTo(rt).Implements(typeSQLScanner) {\n\t\t\t// dest is always addressable because it is an element of a slice.\n\t\t\tassign = func(src []byte, dest reflect.Value) (err error) {\n\t\t\t\tss := dest.Addr().Interface().(sql.Scanner)\n\t\t\t\tif src == nil {\n\t\t\t\t\terr = ss.Scan(nil)\n\t\t\t\t} else {\n\t\t\t\t\terr = ss.Scan(src)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgoto FoundType\n\t\t}\n\n\t\tassign = func([]byte, reflect.Value) error {\n\t\t\treturn fmt.Errorf(\"pq: scanning to %s is not implemented; only sql.Scanner\", rt)\n\t\t}\n\t}\n\nFoundType:\n\n\tif ad, ok := reflect.Zero(rt).Interface().(ArrayDelimiter); ok {\n\t\tdel = ad.ArrayDelimiter()\n\t}\n\n\treturn rt, assign, del\n}\n\n// Scan implements the sql.Scanner interface.\nfunc (a GenericArray) Scan(src interface{}) error {\n\tdpv := reflect.ValueOf(a.A)\n\tswitch {\n\tcase dpv.Kind() != reflect.Ptr:\n\t\treturn fmt.Errorf(\"pq: destination %T is not a pointer to array or slice\", a.A)\n\tcase dpv.IsNil():\n\t\treturn fmt.Errorf(\"pq: destination %T is nil\", a.A)\n\t}\n\n\tdv := dpv.Elem()\n\tswitch dv.Kind() {\n\tcase reflect.Slice:\n\tcase reflect.Array:\n\tdefault:\n\t\treturn fmt.Errorf(\"pq: destination %T is not a pointer to array or slice\", a.A)\n\t}\n\n\tswitch src := src.(type) {\n\tcase []byte:\n\t\treturn a.scanBytes(src, dv)\n\tcase string:\n\t\treturn a.scanBytes([]byte(src), dv)\n\tcase nil:\n\t\tif dv.Kind() == reflect.Slice {\n\t\t\tdv.Set(reflect.Zero(dv.Type()))\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"pq: cannot convert %T to %s\", src, dv.Type())\n}\n\nfunc (a GenericArray) scanBytes(src []byte, dv reflect.Value) error {\n\tdtype, assign, del := a.evaluateDestination(dv.Type().Elem())\n\tdims, elems, err := parseArray(src, []byte(del))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// TODO allow multidimensional\n\n\tif len(dims) > 1 {\n\t\treturn fmt.Errorf(\"pq: scanning from multidimensional ARRAY%s is not implemented\",\n\t\t\tstrings.Replace(fmt.Sprint(dims), \" \", \"][\", -1))\n\t}\n\n\t// Treat a zero-dimensional array like an array with a single dimension of zero.\n\tif len(dims) == 0 {\n\t\tdims = append(dims, 0)\n\t}\n\n\tfor i, rt := 0, dv.Type(); i < len(dims); i, rt = i+1, rt.Elem() {\n\t\tswitch rt.Kind() {\n\t\tcase reflect.Slice:\n\t\tcase reflect.Array:\n\t\t\tif rt.Len() != dims[i] {\n\t\t\t\treturn fmt.Errorf(\"pq: cannot convert ARRAY%s to %s\",\n\t\t\t\t\tstrings.Replace(fmt.Sprint(dims), \" \", \"][\", -1), dv.Type())\n\t\t\t}\n\t\tdefault:\n\t\t\t// TODO handle multidimensional\n\t\t}\n\t}\n\n\tvalues := reflect.MakeSlice(reflect.SliceOf(dtype), len(elems), len(elems))\n\tfor i, e := range elems {\n\t\tif err := assign(e, values.Index(i)); err != nil {\n\t\t\treturn fmt.Errorf(\"pq: parsing array element index %d: %v\", i, err)\n\t\t}\n\t}\n\n\t// TODO handle multidimensional\n\n\tswitch dv.Kind() {\n\tcase reflect.Slice:\n\t\tdv.Set(values.Slice(0, dims[0]))\n\tcase reflect.Array:\n\t\tfor i := 0; i < dims[0]; i++ {\n\t\t\tdv.Index(i).Set(values.Index(i))\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Value implements the driver.Valuer interface.\nfunc (a GenericArray) Value() (driver.Value, error) {\n\tif a.A == nil {\n\t\treturn nil, nil\n\t}\n\n\trv := reflect.ValueOf(a.A)\n\n\tswitch rv.Kind() {\n\tcase reflect.Slice:\n\t\tif rv.IsNil() {\n\t\t\treturn nil, nil\n\t\t}\n\tcase reflect.Array:\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"pq: Unable to convert %T to array\", a.A)\n\t}\n\n\tif n := rv.Len(); n > 0 {\n\t\t// There will be at least two curly brackets, N bytes of values,\n\t\t// and N-1 bytes of delimiters.\n\t\tb := make([]byte, 0, 1+2*n)\n\n\t\tb, _, err := appendArray(b, rv, n)\n\t\treturn string(b), err\n\t}\n\n\treturn \"{}\", nil\n}\n\n// Int64Array represents a one-dimensional array of the PostgreSQL integer types.\ntype Int64Array []int64\n\n// Scan implements the sql.Scanner interface.\nfunc (a *Int64Array) Scan(src interface{}) error {\n\tswitch src := src.(type) {\n\tcase []byte:\n\t\treturn a.scanBytes(src)\n\tcase string:\n\t\treturn a.scanBytes([]byte(src))\n\tcase nil:\n\t\t*a = nil\n\t\treturn nil\n\t}\n\n\treturn fmt.Errorf(\"pq: cannot convert %T to Int64Array\", src)\n}\n\nfunc (a *Int64Array) scanBytes(src []byte) error {\n\telems, err := scanLinearArray(src, []byte{','}, \"Int64Array\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif *a != nil && len(elems) == 0 {\n\t\t*a = (*a)[:0]\n\t} else {\n\t\tb := make(Int64Array, len(elems))\n\t\tfor i, v := range elems {\n\t\t\tif b[i], err = strconv.ParseInt(string(v), 10, 64); err != nil {\n\t\t\t\treturn fmt.Errorf(\"pq: parsing array element index %d: %v\", i, err)\n\t\t\t}\n\t\t}\n\t\t*a = b\n\t}\n\treturn nil\n}\n\n// Value implements the driver.Valuer interface.\nfunc (a Int64Array) Value() (driver.Value, error) {\n\tif a == nil {\n\t\treturn nil, nil\n\t}\n\n\tif n := len(a); n > 0 {\n\t\t// There will be at least two curly brackets, N bytes of values,\n\t\t// and N-1 bytes of delimiters.\n\t\tb := make([]byte, 1, 1+2*n)\n\t\tb[0] = '{'\n\n\t\tb = strconv.AppendInt(b, a[0], 10)\n\t\tfor i := 1; i < n; i++ {\n\t\t\tb = append(b, ',')\n\t\t\tb = strconv.AppendInt(b, a[i], 10)\n\t\t}\n\n\t\treturn string(append(b, '}')), nil\n\t}\n\n\treturn \"{}\", nil\n}\n\n// Int32Array represents a one-dimensional array of the PostgreSQL integer types.\ntype Int32Array []int32\n\n// Scan implements the sql.Scanner interface.\nfunc (a *Int32Array) Scan(src interface{}) error {\n\tswitch src := src.(type) {\n\tcase []byte:\n\t\treturn a.scanBytes(src)\n\tcase string:\n\t\treturn a.scanBytes([]byte(src))\n\tcase nil:\n\t\t*a = nil\n\t\treturn nil\n\t}\n\n\treturn fmt.Errorf(\"pq: cannot convert %T to Int32Array\", src)\n}\n\nfunc (a *Int32Array) scanBytes(src []byte) error {\n\telems, err := scanLinearArray(src, []byte{','}, \"Int32Array\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif *a != nil && len(elems) == 0 {\n\t\t*a = (*a)[:0]\n\t} else {\n\t\tb := make(Int32Array, len(elems))\n\t\tfor i, v := range elems {\n\t\t\tx, err := strconv.ParseInt(string(v), 10, 32)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"pq: parsing array element index %d: %v\", i, err)\n\t\t\t}\n\t\t\tb[i] = int32(x)\n\t\t}\n\t\t*a = b\n\t}\n\treturn nil\n}\n\n// Value implements the driver.Valuer interface.\nfunc (a Int32Array) Value() (driver.Value, error) {\n\tif a == nil {\n\t\treturn nil, nil\n\t}\n\n\tif n := len(a); n > 0 {\n\t\t// There will be at least two curly brackets, N bytes of values,\n\t\t// and N-1 bytes of delimiters.\n\t\tb := make([]byte, 1, 1+2*n)\n\t\tb[0] = '{'\n\n\t\tb = strconv.AppendInt(b, int64(a[0]), 10)\n\t\tfor i := 1; i < n; i++ {\n\t\t\tb = append(b, ',')\n\t\t\tb = strconv.AppendInt(b, int64(a[i]), 10)\n\t\t}\n\n\t\treturn string(append(b, '}')), nil\n\t}\n\n\treturn \"{}\", nil\n}\n\n// StringArray represents a one-dimensional array of the PostgreSQL character types.\ntype StringArray []string\n\n// Scan implements the sql.Scanner interface.\nfunc (a *StringArray) Scan(src interface{}) error {\n\tswitch src := src.(type) {\n\tcase []byte:\n\t\treturn a.scanBytes(src)\n\tcase string:\n\t\treturn a.scanBytes([]byte(src))\n\tcase nil:\n\t\t*a = nil\n\t\treturn nil\n\t}\n\n\treturn fmt.Errorf(\"pq: cannot convert %T to StringArray\", src)\n}\n\nfunc (a *StringArray) scanBytes(src []byte) error {\n\telems, err := scanLinearArray(src, []byte{','}, \"StringArray\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif *a != nil && len(elems) == 0 {\n\t\t*a = (*a)[:0]\n\t} else {\n\t\tb := make(StringArray, len(elems))\n\t\tfor i, v := range elems {\n\t\t\tif b[i] = string(v); v == nil {\n\t\t\t\treturn fmt.Errorf(\"pq: parsing array element index %d: cannot convert nil to string\", i)\n\t\t\t}\n\t\t}\n\t\t*a = b\n\t}\n\treturn nil\n}\n\n// Value implements the driver.Valuer interface.\nfunc (a StringArray) Value() (driver.Value, error) {\n\tif a == nil {\n\t\treturn nil, nil\n\t}\n\n\tif n := len(a); n > 0 {\n\t\t// There will be at least two curly brackets, 2*N bytes of quotes,\n\t\t// and N-1 bytes of delimiters.\n\t\tb := make([]byte, 1, 1+3*n)\n\t\tb[0] = '{'\n\n\t\tb = appendArrayQuotedBytes(b, []byte(a[0]))\n\t\tfor i := 1; i < n; i++ {\n\t\t\tb = append(b, ',')\n\t\t\tb = appendArrayQuotedBytes(b, []byte(a[i]))\n\t\t}\n\n\t\treturn string(append(b, '}')), nil\n\t}\n\n\treturn \"{}\", nil\n}\n\n// appendArray appends rv to the buffer, returning the extended buffer and\n// the delimiter used between elements.\n//\n// It panics when n <= 0 or rv's Kind is not reflect.Array nor reflect.Slice.\nfunc appendArray(b []byte, rv reflect.Value, n int) ([]byte, string, error) {\n\tvar del string\n\tvar err error\n\n\tb = append(b, '{')\n\n\tif b, del, err = appendArrayElement(b, rv.Index(0)); err != nil {\n\t\treturn b, del, err\n\t}\n\n\tfor i := 1; i < n; i++ {\n\t\tb = append(b, del...)\n\t\tif b, del, err = appendArrayElement(b, rv.Index(i)); err != nil {\n\t\t\treturn b, del, err\n\t\t}\n\t}\n\n\treturn append(b, '}'), del, nil\n}\n\n// appendArrayElement appends rv to the buffer, returning the extended buffer\n// and the delimiter to use before the next element.\n//\n// When rv's Kind is neither reflect.Array nor reflect.Slice, it is converted\n// using driver.DefaultParameterConverter and the resulting []byte or string\n// is double-quoted.\n//\n// See http://www.postgresql.org/docs/current/static/arrays.html#ARRAYS-IO\nfunc appendArrayElement(b []byte, rv reflect.Value) ([]byte, string, error) {\n\tif k := rv.Kind(); k == reflect.Array || k == reflect.Slice {\n\t\tif t := rv.Type(); t != typeByteSlice && !t.Implements(typeDriverValuer) {\n\t\t\tif n := rv.Len(); n > 0 {\n\t\t\t\treturn appendArray(b, rv, n)\n\t\t\t}\n\n\t\t\treturn b, \"\", nil\n\t\t}\n\t}\n\n\tvar del = \",\"\n\tvar err error\n\tvar iv interface{} = rv.Interface()\n\n\tif ad, ok := iv.(ArrayDelimiter); ok {\n\t\tdel = ad.ArrayDelimiter()\n\t}\n\n\tif iv, err = driver.DefaultParameterConverter.ConvertValue(iv); err != nil {\n\t\treturn b, del, err\n\t}\n\n\tswitch v := iv.(type) {\n\tcase nil:\n\t\treturn append(b, \"NULL\"...), del, nil\n\tcase []byte:\n\t\treturn appendArrayQuotedBytes(b, v), del, nil\n\tcase string:\n\t\treturn appendArrayQuotedBytes(b, []byte(v)), del, nil\n\t}\n\n\tb, err = appendValue(b, iv)\n\treturn b, del, err\n}\n\nfunc appendArrayQuotedBytes(b, v []byte) []byte {\n\tb = append(b, '\"')\n\tfor {\n\t\ti := bytes.IndexAny(v, `\"\\`)\n\t\tif i < 0 {\n\t\t\tb = append(b, v...)\n\t\t\tbreak\n\t\t}\n\t\tif i > 0 {\n\t\t\tb = append(b, v[:i]...)\n\t\t}\n\t\tb = append(b, '\\\\', v[i])\n\t\tv = v[i+1:]\n\t}\n\treturn append(b, '\"')\n}\n\nfunc appendValue(b []byte, v driver.Value) ([]byte, error) {\n\treturn append(b, encode(nil, v, 0)...), nil\n}\n\n// parseArray extracts the dimensions and elements of an array represented in\n// text format. Only representations emitted by the backend are supported.\n// Notably, whitespace around brackets and delimiters is significant, and NULL\n// is case-sensitive.\n//\n// See http://www.postgresql.org/docs/current/static/arrays.html#ARRAYS-IO\nfunc parseArray(src, del []byte) (dims []int, elems [][]byte, err error) {\n\tvar depth, i int\n\n\tif len(src) < 1 || src[0] != '{' {\n\t\treturn nil, nil, fmt.Errorf(\"pq: unable to parse array; expected %q at offset %d\", '{', 0)\n\t}\n\nOpen:\n\tfor i < len(src) {\n\t\tswitch src[i] {\n\t\tcase '{':\n\t\t\tdepth++\n\t\t\ti++\n\t\tcase '}':\n\t\t\telems = make([][]byte, 0)\n\t\t\tgoto Close\n\t\tdefault:\n\t\t\tbreak Open\n\t\t}\n\t}\n\tdims = make([]int, i)\n\nElement:\n\tfor i < len(src) {\n\t\tswitch src[i] {\n\t\tcase '{':\n\t\t\tif depth == len(dims) {\n\t\t\t\tbreak Element\n\t\t\t}\n\t\t\tdepth++\n\t\t\tdims[depth-1] = 0\n\t\t\ti++\n\t\tcase '\"':\n\t\t\tvar elem = []byte{}\n\t\t\tvar escape bool\n\t\t\tfor i++; i < len(src); i++ {\n\t\t\t\tif escape {\n\t\t\t\t\telem = append(elem, src[i])\n\t\t\t\t\tescape = false\n\t\t\t\t} else {\n\t\t\t\t\tswitch src[i] {\n\t\t\t\t\tdefault:\n\t\t\t\t\t\telem = append(elem, src[i])\n\t\t\t\t\tcase '\\\\':\n\t\t\t\t\t\tescape = true\n\t\t\t\t\tcase '\"':\n\t\t\t\t\t\telems = append(elems, elem)\n\t\t\t\t\t\ti++\n\t\t\t\t\t\tbreak Element\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tfor start := i; i < len(src); i++ {\n\t\t\t\tif bytes.HasPrefix(src[i:], del) || src[i] == '}' {\n\t\t\t\t\telem := src[start:i]\n\t\t\t\t\tif len(elem) == 0 {\n\t\t\t\t\t\treturn nil, nil, fmt.Errorf(\"pq: unable to parse array; unexpected %q at offset %d\", src[i], i)\n\t\t\t\t\t}\n\t\t\t\t\tif bytes.Equal(elem, []byte(\"NULL\")) {\n\t\t\t\t\t\telem = nil\n\t\t\t\t\t}\n\t\t\t\t\telems = append(elems, elem)\n\t\t\t\t\tbreak Element\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor i < len(src) {\n\t\tif bytes.HasPrefix(src[i:], del) && depth > 0 {\n\t\t\tdims[depth-1]++\n\t\t\ti += len(del)\n\t\t\tgoto Element\n\t\t} else if src[i] == '}' && depth > 0 {\n\t\t\tdims[depth-1]++\n\t\t\tdepth--\n\t\t\ti++\n\t\t} else {\n\t\t\treturn nil, nil, fmt.Errorf(\"pq: unable to parse array; unexpected %q at offset %d\", src[i], i)\n\t\t}\n\t}\n\nClose:\n\tfor i < len(src) {\n\t\tif src[i] == '}' && depth > 0 {\n\t\t\tdepth--\n\t\t\ti++\n\t\t} else {\n\t\t\treturn nil, nil, fmt.Errorf(\"pq: unable to parse array; unexpected %q at offset %d\", src[i], i)\n\t\t}\n\t}\n\tif depth > 0 {\n\t\terr = fmt.Errorf(\"pq: unable to parse array; expected %q at offset %d\", '}', i)\n\t}\n\tif err == nil {\n\t\tfor _, d := range dims {\n\t\t\tif (len(elems) % d) != 0 {\n\t\t\t\terr = fmt.Errorf(\"pq: multidimensional arrays must have elements with matching dimensions\")\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\nfunc scanLinearArray(src, del []byte, typ string) (elems [][]byte, err error) {\n\tdims, elems, err := parseArray(src, del)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(dims) > 1 {\n\t\treturn nil, fmt.Errorf(\"pq: cannot convert ARRAY%s to %s\", strings.Replace(fmt.Sprint(dims), \" \", \"][\", -1), typ)\n\t}\n\treturn elems, err\n}\n"
        },
        {
          "name": "array_test.go",
          "type": "blob",
          "size": 40.955078125,
          "content": "package pq\n\nimport (\n\t\"bytes\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestParseArray(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tinput string\n\t\tdelim string\n\t\tdims  []int\n\t\telems [][]byte\n\t}{\n\t\t{`{}`, `,`, nil, [][]byte{}},\n\t\t{`{NULL}`, `,`, []int{1}, [][]byte{nil}},\n\t\t{`{a}`, `,`, []int{1}, [][]byte{{'a'}}},\n\t\t{`{a,b}`, `,`, []int{2}, [][]byte{{'a'}, {'b'}}},\n\t\t{`{{a,b}}`, `,`, []int{1, 2}, [][]byte{{'a'}, {'b'}}},\n\t\t{`{{a},{b}}`, `,`, []int{2, 1}, [][]byte{{'a'}, {'b'}}},\n\t\t{`{{{a,b},{c,d},{e,f}}}`, `,`, []int{1, 3, 2}, [][]byte{\n\t\t\t{'a'}, {'b'}, {'c'}, {'d'}, {'e'}, {'f'},\n\t\t}},\n\t\t{`{\"\"}`, `,`, []int{1}, [][]byte{{}}},\n\t\t{`{\",\"}`, `,`, []int{1}, [][]byte{{','}}},\n\t\t{`{\",\",\",\"}`, `,`, []int{2}, [][]byte{{','}, {','}}},\n\t\t{`{{\",\",\",\"}}`, `,`, []int{1, 2}, [][]byte{{','}, {','}}},\n\t\t{`{{\",\"},{\",\"}}`, `,`, []int{2, 1}, [][]byte{{','}, {','}}},\n\t\t{`{{{\",\",\",\"},{\",\",\",\"},{\",\",\",\"}}}`, `,`, []int{1, 3, 2}, [][]byte{\n\t\t\t{','}, {','}, {','}, {','}, {','}, {','},\n\t\t}},\n\t\t{`{\"\\\"}\"}`, `,`, []int{1}, [][]byte{{'\"', '}'}}},\n\t\t{`{\"\\\"\",\"\\\"\"}`, `,`, []int{2}, [][]byte{{'\"'}, {'\"'}}},\n\t\t{`{{\"\\\"\",\"\\\"\"}}`, `,`, []int{1, 2}, [][]byte{{'\"'}, {'\"'}}},\n\t\t{`{{\"\\\"\"},{\"\\\"\"}}`, `,`, []int{2, 1}, [][]byte{{'\"'}, {'\"'}}},\n\t\t{`{{{\"\\\"\",\"\\\"\"},{\"\\\"\",\"\\\"\"},{\"\\\"\",\"\\\"\"}}}`, `,`, []int{1, 3, 2}, [][]byte{\n\t\t\t{'\"'}, {'\"'}, {'\"'}, {'\"'}, {'\"'}, {'\"'},\n\t\t}},\n\t\t{`{axyzb}`, `xyz`, []int{2}, [][]byte{{'a'}, {'b'}}},\n\t} {\n\t\tdims, elems, err := parseArray([]byte(tt.input), []byte(tt.delim))\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error for %q, got %q\", tt.input, err)\n\t\t}\n\t\tif !reflect.DeepEqual(dims, tt.dims) {\n\t\t\tt.Errorf(\"Expected %v dimensions for %q, got %v\", tt.dims, tt.input, dims)\n\t\t}\n\t\tif !reflect.DeepEqual(elems, tt.elems) {\n\t\t\tt.Errorf(\"Expected %v elements for %q, got %v\", tt.elems, tt.input, elems)\n\t\t}\n\t}\n}\n\nfunc TestParseArrayError(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tinput, err string\n\t}{\n\t\t{``, \"expected '{' at offset 0\"},\n\t\t{`x`, \"expected '{' at offset 0\"},\n\t\t{`}`, \"expected '{' at offset 0\"},\n\t\t{`{`, \"expected '}' at offset 1\"},\n\t\t{`{{}`, \"expected '}' at offset 3\"},\n\t\t{`{}}`, \"unexpected '}' at offset 2\"},\n\t\t{`{,}`, \"unexpected ',' at offset 1\"},\n\t\t{`{,x}`, \"unexpected ',' at offset 1\"},\n\t\t{`{x,}`, \"unexpected '}' at offset 3\"},\n\t\t{`{x,{`, \"unexpected '{' at offset 3\"},\n\t\t{`{x},`, \"unexpected ',' at offset 3\"},\n\t\t{`{x}}`, \"unexpected '}' at offset 3\"},\n\t\t{`{{x}`, \"expected '}' at offset 4\"},\n\t\t{`{\"\"x}`, \"unexpected 'x' at offset 3\"},\n\t\t{`{{a},{b,c}}`, \"multidimensional arrays must have elements with matching dimensions\"},\n\t} {\n\t\t_, _, err := parseArray([]byte(tt.input), []byte{','})\n\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Expected error for %q, got none\", tt.input)\n\t\t}\n\t\tif !strings.Contains(err.Error(), tt.err) {\n\t\t\tt.Errorf(\"Expected error to contain %q for %q, got %q\", tt.err, tt.input, err)\n\t\t}\n\t}\n}\n\nfunc TestArrayScanner(t *testing.T) {\n\tvar s sql.Scanner = Array(&[]bool{})\n\tif _, ok := s.(*BoolArray); !ok {\n\t\tt.Errorf(\"Expected *BoolArray, got %T\", s)\n\t}\n\n\ts = Array(&[]float64{})\n\tif _, ok := s.(*Float64Array); !ok {\n\t\tt.Errorf(\"Expected *Float64Array, got %T\", s)\n\t}\n\n\ts = Array(&[]int64{})\n\tif _, ok := s.(*Int64Array); !ok {\n\t\tt.Errorf(\"Expected *Int64Array, got %T\", s)\n\t}\n\n\ts = Array(&[]float32{})\n\tif _, ok := s.(*Float32Array); !ok {\n\t\tt.Errorf(\"Expected *Float32Array, got %T\", s)\n\t}\n\n\ts = Array(&[]int32{})\n\tif _, ok := s.(*Int32Array); !ok {\n\t\tt.Errorf(\"Expected *Int32Array, got %T\", s)\n\t}\n\n\ts = Array(&[]string{})\n\tif _, ok := s.(*StringArray); !ok {\n\t\tt.Errorf(\"Expected *StringArray, got %T\", s)\n\t}\n\n\ts = Array(&[][]byte{})\n\tif _, ok := s.(*ByteaArray); !ok {\n\t\tt.Errorf(\"Expected *ByteaArray, got %T\", s)\n\t}\n\n\tfor _, tt := range []interface{}{\n\t\t&[]sql.Scanner{},\n\t\t&[][]bool{},\n\t\t&[][]float64{},\n\t\t&[][]int64{},\n\t\t&[][]float32{},\n\t\t&[][]int32{},\n\t\t&[][]string{},\n\t} {\n\t\ts = Array(tt)\n\t\tif _, ok := s.(GenericArray); !ok {\n\t\t\tt.Errorf(\"Expected GenericArray for %T, got %T\", tt, s)\n\t\t}\n\t}\n}\n\nfunc TestArrayValuer(t *testing.T) {\n\tvar v driver.Valuer = Array([]bool{})\n\tif _, ok := v.(*BoolArray); !ok {\n\t\tt.Errorf(\"Expected *BoolArray, got %T\", v)\n\t}\n\n\tv = Array([]float64{})\n\tif _, ok := v.(*Float64Array); !ok {\n\t\tt.Errorf(\"Expected *Float64Array, got %T\", v)\n\t}\n\n\tv = Array([]int64{})\n\tif _, ok := v.(*Int64Array); !ok {\n\t\tt.Errorf(\"Expected *Int64Array, got %T\", v)\n\t}\n\n\tv = Array([]float32{})\n\tif _, ok := v.(*Float32Array); !ok {\n\t\tt.Errorf(\"Expected *Float32Array, got %T\", v)\n\t}\n\n\tv = Array([]int32{})\n\tif _, ok := v.(*Int32Array); !ok {\n\t\tt.Errorf(\"Expected *Int32Array, got %T\", v)\n\t}\n\n\tv = Array([]string{})\n\tif _, ok := v.(*StringArray); !ok {\n\t\tt.Errorf(\"Expected *StringArray, got %T\", v)\n\t}\n\n\tv = Array([][]byte{})\n\tif _, ok := v.(*ByteaArray); !ok {\n\t\tt.Errorf(\"Expected *ByteaArray, got %T\", v)\n\t}\n\n\tfor _, tt := range []interface{}{\n\t\tnil,\n\t\t[]driver.Value{},\n\t\t[][]bool{},\n\t\t[][]float64{},\n\t\t[][]int64{},\n\t\t[][]float32{},\n\t\t[][]int32{},\n\t\t[][]string{},\n\t} {\n\t\tv = Array(tt)\n\t\tif _, ok := v.(GenericArray); !ok {\n\t\t\tt.Errorf(\"Expected GenericArray for %T, got %T\", tt, v)\n\t\t}\n\t}\n}\n\nfunc TestBoolArrayScanUnsupported(t *testing.T) {\n\tvar arr BoolArray\n\terr := arr.Scan(1)\n\n\tif err == nil {\n\t\tt.Fatal(\"Expected error when scanning from int\")\n\t}\n\tif !strings.Contains(err.Error(), \"int to BoolArray\") {\n\t\tt.Errorf(\"Expected type to be mentioned when scanning, got %q\", err)\n\t}\n}\n\nfunc TestBoolArrayScanEmpty(t *testing.T) {\n\tvar arr BoolArray\n\terr := arr.Scan(`{}`)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif arr == nil || len(arr) != 0 {\n\t\tt.Errorf(\"Expected empty, got %#v\", arr)\n\t}\n}\n\nfunc TestBoolArrayScanNil(t *testing.T) {\n\tarr := BoolArray{true, true, true}\n\terr := arr.Scan(nil)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif arr != nil {\n\t\tt.Errorf(\"Expected nil, got %+v\", arr)\n\t}\n}\n\nvar BoolArrayStringTests = []struct {\n\tstr string\n\tarr BoolArray\n}{\n\t{`{}`, BoolArray{}},\n\t{`{t}`, BoolArray{true}},\n\t{`{f,t}`, BoolArray{false, true}},\n}\n\nfunc TestBoolArrayScanBytes(t *testing.T) {\n\tfor _, tt := range BoolArrayStringTests {\n\t\tbytes := []byte(tt.str)\n\t\tarr := BoolArray{true, true, true}\n\t\terr := arr.Scan(bytes)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error for %q, got %v\", bytes, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, tt.arr) {\n\t\t\tt.Errorf(\"Expected %+v for %q, got %+v\", tt.arr, bytes, arr)\n\t\t}\n\t}\n}\n\nfunc BenchmarkBoolArrayScanBytes(b *testing.B) {\n\tvar a BoolArray\n\tvar x interface{} = []byte(`{t,f,t,f,t,f,t,f,t,f}`)\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta = BoolArray{}\n\t\ta.Scan(x)\n\t}\n}\n\nfunc TestBoolArrayScanString(t *testing.T) {\n\tfor _, tt := range BoolArrayStringTests {\n\t\tarr := BoolArray{true, true, true}\n\t\terr := arr.Scan(tt.str)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error for %q, got %v\", tt.str, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, tt.arr) {\n\t\t\tt.Errorf(\"Expected %+v for %q, got %+v\", tt.arr, tt.str, arr)\n\t\t}\n\t}\n}\n\nfunc TestBoolArrayScanError(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tinput, err string\n\t}{\n\t\t{``, \"unable to parse array\"},\n\t\t{`{`, \"unable to parse array\"},\n\t\t{`{{t},{f}}`, \"cannot convert ARRAY[2][1] to BoolArray\"},\n\t\t{`{NULL}`, `could not parse boolean array index 0: invalid boolean \"\"`},\n\t\t{`{a}`, `could not parse boolean array index 0: invalid boolean \"a\"`},\n\t\t{`{t,b}`, `could not parse boolean array index 1: invalid boolean \"b\"`},\n\t\t{`{t,f,cd}`, `could not parse boolean array index 2: invalid boolean \"cd\"`},\n\t} {\n\t\tarr := BoolArray{true, true, true}\n\t\terr := arr.Scan(tt.input)\n\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Expected error for %q, got none\", tt.input)\n\t\t}\n\t\tif !strings.Contains(err.Error(), tt.err) {\n\t\t\tt.Errorf(\"Expected error to contain %q for %q, got %q\", tt.err, tt.input, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, BoolArray{true, true, true}) {\n\t\t\tt.Errorf(\"Expected destination not to change for %q, got %+v\", tt.input, arr)\n\t\t}\n\t}\n}\n\nfunc TestBoolArrayValue(t *testing.T) {\n\tresult, err := BoolArray(nil).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error for nil, got %v\", err)\n\t}\n\tif result != nil {\n\t\tt.Errorf(\"Expected nil, got %q\", result)\n\t}\n\n\tresult, err = BoolArray([]bool{}).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error for empty, got %v\", err)\n\t}\n\tif expected := `{}`; !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected empty, got %q\", result)\n\t}\n\n\tresult, err = BoolArray([]bool{false, true, false}).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif expected := `{f,t,f}`; !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected %q, got %q\", expected, result)\n\t}\n}\n\nfunc BenchmarkBoolArrayValue(b *testing.B) {\n\trand.Seed(1)\n\tx := make([]bool, 10)\n\tfor i := 0; i < len(x); i++ {\n\t\tx[i] = rand.Intn(2) == 0\n\t}\n\ta := BoolArray(x)\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta.Value()\n\t}\n}\n\nfunc TestByteaArrayScanUnsupported(t *testing.T) {\n\tvar arr ByteaArray\n\terr := arr.Scan(1)\n\n\tif err == nil {\n\t\tt.Fatal(\"Expected error when scanning from int\")\n\t}\n\tif !strings.Contains(err.Error(), \"int to ByteaArray\") {\n\t\tt.Errorf(\"Expected type to be mentioned when scanning, got %q\", err)\n\t}\n}\n\nfunc TestByteaArrayScanEmpty(t *testing.T) {\n\tvar arr ByteaArray\n\terr := arr.Scan(`{}`)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif arr == nil || len(arr) != 0 {\n\t\tt.Errorf(\"Expected empty, got %#v\", arr)\n\t}\n}\n\nfunc TestByteaArrayScanNil(t *testing.T) {\n\tarr := ByteaArray{{2}, {6}, {0, 0}}\n\terr := arr.Scan(nil)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif arr != nil {\n\t\tt.Errorf(\"Expected nil, got %+v\", arr)\n\t}\n}\n\nvar ByteaArrayStringTests = []struct {\n\tstr string\n\tarr ByteaArray\n}{\n\t{`{}`, ByteaArray{}},\n\t{`{NULL}`, ByteaArray{nil}},\n\t{`{\"\\\\xfeff\"}`, ByteaArray{{'\\xFE', '\\xFF'}}},\n\t{`{\"\\\\xdead\",\"\\\\xbeef\"}`, ByteaArray{{'\\xDE', '\\xAD'}, {'\\xBE', '\\xEF'}}},\n}\n\nfunc TestByteaArrayScanBytes(t *testing.T) {\n\tfor _, tt := range ByteaArrayStringTests {\n\t\tbytes := []byte(tt.str)\n\t\tarr := ByteaArray{{2}, {6}, {0, 0}}\n\t\terr := arr.Scan(bytes)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error for %q, got %v\", bytes, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, tt.arr) {\n\t\t\tt.Errorf(\"Expected %+v for %q, got %+v\", tt.arr, bytes, arr)\n\t\t}\n\t}\n}\n\nfunc BenchmarkByteaArrayScanBytes(b *testing.B) {\n\tvar a ByteaArray\n\tvar x interface{} = []byte(`{\"\\\\xfe\",\"\\\\xff\",\"\\\\xdead\",\"\\\\xbeef\",\"\\\\xfe\",\"\\\\xff\",\"\\\\xdead\",\"\\\\xbeef\",\"\\\\xfe\",\"\\\\xff\"}`)\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta = ByteaArray{}\n\t\ta.Scan(x)\n\t}\n}\n\nfunc TestByteaArrayScanString(t *testing.T) {\n\tfor _, tt := range ByteaArrayStringTests {\n\t\tarr := ByteaArray{{2}, {6}, {0, 0}}\n\t\terr := arr.Scan(tt.str)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error for %q, got %v\", tt.str, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, tt.arr) {\n\t\t\tt.Errorf(\"Expected %+v for %q, got %+v\", tt.arr, tt.str, arr)\n\t\t}\n\t}\n}\n\nfunc TestByteaArrayScanError(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tinput, err string\n\t}{\n\t\t{``, \"unable to parse array\"},\n\t\t{`{`, \"unable to parse array\"},\n\t\t{`{{\"\\\\xfeff\"},{\"\\\\xbeef\"}}`, \"cannot convert ARRAY[2][1] to ByteaArray\"},\n\t\t{`{\"\\\\abc\"}`, \"could not parse bytea array index 0: could not parse bytea value\"},\n\t} {\n\t\tarr := ByteaArray{{2}, {6}, {0, 0}}\n\t\terr := arr.Scan(tt.input)\n\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Expected error for %q, got none\", tt.input)\n\t\t}\n\t\tif !strings.Contains(err.Error(), tt.err) {\n\t\t\tt.Errorf(\"Expected error to contain %q for %q, got %q\", tt.err, tt.input, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, ByteaArray{{2}, {6}, {0, 0}}) {\n\t\t\tt.Errorf(\"Expected destination not to change for %q, got %+v\", tt.input, arr)\n\t\t}\n\t}\n}\n\nfunc TestByteaArrayValue(t *testing.T) {\n\tresult, err := ByteaArray(nil).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error for nil, got %v\", err)\n\t}\n\tif result != nil {\n\t\tt.Errorf(\"Expected nil, got %q\", result)\n\t}\n\n\tresult, err = ByteaArray([][]byte{}).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error for empty, got %v\", err)\n\t}\n\tif expected := `{}`; !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected empty, got %q\", result)\n\t}\n\n\tresult, err = ByteaArray([][]byte{{'\\xDE', '\\xAD', '\\xBE', '\\xEF'}, {'\\xFE', '\\xFF'}, {}}).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif expected := `{\"\\\\xdeadbeef\",\"\\\\xfeff\",\"\\\\x\"}`; !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected %q, got %q\", expected, result)\n\t}\n}\n\nfunc BenchmarkByteaArrayValue(b *testing.B) {\n\trand.Seed(1)\n\tx := make([][]byte, 10)\n\tfor i := 0; i < len(x); i++ {\n\t\tx[i] = make([]byte, len(x))\n\t\tfor j := 0; j < len(x); j++ {\n\t\t\tx[i][j] = byte(rand.Int())\n\t\t}\n\t}\n\ta := ByteaArray(x)\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta.Value()\n\t}\n}\n\nfunc TestFloat64ArrayScanUnsupported(t *testing.T) {\n\tvar arr Float64Array\n\terr := arr.Scan(true)\n\n\tif err == nil {\n\t\tt.Fatal(\"Expected error when scanning from bool\")\n\t}\n\tif !strings.Contains(err.Error(), \"bool to Float64Array\") {\n\t\tt.Errorf(\"Expected type to be mentioned when scanning, got %q\", err)\n\t}\n}\n\nfunc TestFloat64ArrayScanEmpty(t *testing.T) {\n\tvar arr Float64Array\n\terr := arr.Scan(`{}`)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif arr == nil || len(arr) != 0 {\n\t\tt.Errorf(\"Expected empty, got %#v\", arr)\n\t}\n}\n\nfunc TestFloat64ArrayScanNil(t *testing.T) {\n\tarr := Float64Array{5, 5, 5}\n\terr := arr.Scan(nil)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif arr != nil {\n\t\tt.Errorf(\"Expected nil, got %+v\", arr)\n\t}\n}\n\nvar Float64ArrayStringTests = []struct {\n\tstr string\n\tarr Float64Array\n}{\n\t{`{}`, Float64Array{}},\n\t{`{1.2}`, Float64Array{1.2}},\n\t{`{3.456,7.89}`, Float64Array{3.456, 7.89}},\n\t{`{3,1,2}`, Float64Array{3, 1, 2}},\n}\n\nfunc TestFloat64ArrayScanBytes(t *testing.T) {\n\tfor _, tt := range Float64ArrayStringTests {\n\t\tbytes := []byte(tt.str)\n\t\tarr := Float64Array{5, 5, 5}\n\t\terr := arr.Scan(bytes)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error for %q, got %v\", bytes, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, tt.arr) {\n\t\t\tt.Errorf(\"Expected %+v for %q, got %+v\", tt.arr, bytes, arr)\n\t\t}\n\t}\n}\n\nfunc BenchmarkFloat64ArrayScanBytes(b *testing.B) {\n\tvar a Float64Array\n\tvar x interface{} = []byte(`{1.2,3.4,5.6,7.8,9.01,2.34,5.67,8.90,1.234,5.678}`)\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta = Float64Array{}\n\t\ta.Scan(x)\n\t}\n}\n\nfunc TestFloat64ArrayScanString(t *testing.T) {\n\tfor _, tt := range Float64ArrayStringTests {\n\t\tarr := Float64Array{5, 5, 5}\n\t\terr := arr.Scan(tt.str)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error for %q, got %v\", tt.str, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, tt.arr) {\n\t\t\tt.Errorf(\"Expected %+v for %q, got %+v\", tt.arr, tt.str, arr)\n\t\t}\n\t}\n}\n\nfunc TestFloat64ArrayScanError(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tinput, err string\n\t}{\n\t\t{``, \"unable to parse array\"},\n\t\t{`{`, \"unable to parse array\"},\n\t\t{`{{5.6},{7.8}}`, \"cannot convert ARRAY[2][1] to Float64Array\"},\n\t\t{`{NULL}`, \"parsing array element index 0:\"},\n\t\t{`{a}`, \"parsing array element index 0:\"},\n\t\t{`{5.6,a}`, \"parsing array element index 1:\"},\n\t\t{`{5.6,7.8,a}`, \"parsing array element index 2:\"},\n\t} {\n\t\tarr := Float64Array{5, 5, 5}\n\t\terr := arr.Scan(tt.input)\n\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Expected error for %q, got none\", tt.input)\n\t\t}\n\t\tif !strings.Contains(err.Error(), tt.err) {\n\t\t\tt.Errorf(\"Expected error to contain %q for %q, got %q\", tt.err, tt.input, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, Float64Array{5, 5, 5}) {\n\t\t\tt.Errorf(\"Expected destination not to change for %q, got %+v\", tt.input, arr)\n\t\t}\n\t}\n}\n\nfunc TestFloat64ArrayValue(t *testing.T) {\n\tresult, err := Float64Array(nil).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error for nil, got %v\", err)\n\t}\n\tif result != nil {\n\t\tt.Errorf(\"Expected nil, got %q\", result)\n\t}\n\n\tresult, err = Float64Array([]float64{}).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error for empty, got %v\", err)\n\t}\n\tif expected := `{}`; !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected empty, got %q\", result)\n\t}\n\n\tresult, err = Float64Array([]float64{1.2, 3.4, 5.6}).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif expected := `{1.2,3.4,5.6}`; !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected %q, got %q\", expected, result)\n\t}\n}\n\nfunc BenchmarkFloat64ArrayValue(b *testing.B) {\n\trand.Seed(1)\n\tx := make([]float64, 10)\n\tfor i := 0; i < len(x); i++ {\n\t\tx[i] = rand.NormFloat64()\n\t}\n\ta := Float64Array(x)\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta.Value()\n\t}\n}\n\nfunc TestInt64ArrayScanUnsupported(t *testing.T) {\n\tvar arr Int64Array\n\terr := arr.Scan(true)\n\n\tif err == nil {\n\t\tt.Fatal(\"Expected error when scanning from bool\")\n\t}\n\tif !strings.Contains(err.Error(), \"bool to Int64Array\") {\n\t\tt.Errorf(\"Expected type to be mentioned when scanning, got %q\", err)\n\t}\n}\n\nfunc TestInt64ArrayScanEmpty(t *testing.T) {\n\tvar arr Int64Array\n\terr := arr.Scan(`{}`)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif arr == nil || len(arr) != 0 {\n\t\tt.Errorf(\"Expected empty, got %#v\", arr)\n\t}\n}\n\nfunc TestInt64ArrayScanNil(t *testing.T) {\n\tarr := Int64Array{5, 5, 5}\n\terr := arr.Scan(nil)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif arr != nil {\n\t\tt.Errorf(\"Expected nil, got %+v\", arr)\n\t}\n}\n\nvar Int64ArrayStringTests = []struct {\n\tstr string\n\tarr Int64Array\n}{\n\t{`{}`, Int64Array{}},\n\t{`{12}`, Int64Array{12}},\n\t{`{345,678}`, Int64Array{345, 678}},\n}\n\nfunc TestInt64ArrayScanBytes(t *testing.T) {\n\tfor _, tt := range Int64ArrayStringTests {\n\t\tbytes := []byte(tt.str)\n\t\tarr := Int64Array{5, 5, 5}\n\t\terr := arr.Scan(bytes)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error for %q, got %v\", bytes, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, tt.arr) {\n\t\t\tt.Errorf(\"Expected %+v for %q, got %+v\", tt.arr, bytes, arr)\n\t\t}\n\t}\n}\n\nfunc BenchmarkInt64ArrayScanBytes(b *testing.B) {\n\tvar a Int64Array\n\tvar x interface{} = []byte(`{1,2,3,4,5,6,7,8,9,0}`)\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta = Int64Array{}\n\t\ta.Scan(x)\n\t}\n}\n\nfunc TestInt64ArrayScanString(t *testing.T) {\n\tfor _, tt := range Int64ArrayStringTests {\n\t\tarr := Int64Array{5, 5, 5}\n\t\terr := arr.Scan(tt.str)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error for %q, got %v\", tt.str, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, tt.arr) {\n\t\t\tt.Errorf(\"Expected %+v for %q, got %+v\", tt.arr, tt.str, arr)\n\t\t}\n\t}\n}\n\nfunc TestInt64ArrayScanError(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tinput, err string\n\t}{\n\t\t{``, \"unable to parse array\"},\n\t\t{`{`, \"unable to parse array\"},\n\t\t{`{{5},{6}}`, \"cannot convert ARRAY[2][1] to Int64Array\"},\n\t\t{`{NULL}`, \"parsing array element index 0:\"},\n\t\t{`{a}`, \"parsing array element index 0:\"},\n\t\t{`{5,a}`, \"parsing array element index 1:\"},\n\t\t{`{5,6,a}`, \"parsing array element index 2:\"},\n\t} {\n\t\tarr := Int64Array{5, 5, 5}\n\t\terr := arr.Scan(tt.input)\n\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Expected error for %q, got none\", tt.input)\n\t\t}\n\t\tif !strings.Contains(err.Error(), tt.err) {\n\t\t\tt.Errorf(\"Expected error to contain %q for %q, got %q\", tt.err, tt.input, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, Int64Array{5, 5, 5}) {\n\t\t\tt.Errorf(\"Expected destination not to change for %q, got %+v\", tt.input, arr)\n\t\t}\n\t}\n}\n\nfunc TestInt64ArrayValue(t *testing.T) {\n\tresult, err := Int64Array(nil).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error for nil, got %v\", err)\n\t}\n\tif result != nil {\n\t\tt.Errorf(\"Expected nil, got %q\", result)\n\t}\n\n\tresult, err = Int64Array([]int64{}).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error for empty, got %v\", err)\n\t}\n\tif expected := `{}`; !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected empty, got %q\", result)\n\t}\n\n\tresult, err = Int64Array([]int64{1, 2, 3}).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif expected := `{1,2,3}`; !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected %q, got %q\", expected, result)\n\t}\n}\n\nfunc BenchmarkInt64ArrayValue(b *testing.B) {\n\trand.Seed(1)\n\tx := make([]int64, 10)\n\tfor i := 0; i < len(x); i++ {\n\t\tx[i] = rand.Int63()\n\t}\n\ta := Int64Array(x)\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta.Value()\n\t}\n}\n\nfunc TestFloat32ArrayScanUnsupported(t *testing.T) {\n\tvar arr Float32Array\n\terr := arr.Scan(true)\n\n\tif err == nil {\n\t\tt.Fatal(\"Expected error when scanning from bool\")\n\t}\n\tif !strings.Contains(err.Error(), \"bool to Float32Array\") {\n\t\tt.Errorf(\"Expected type to be mentioned when scanning, got %q\", err)\n\t}\n}\n\nfunc TestFloat32ArrayScanEmpty(t *testing.T) {\n\tvar arr Float32Array\n\terr := arr.Scan(`{}`)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif arr == nil || len(arr) != 0 {\n\t\tt.Errorf(\"Expected empty, got %#v\", arr)\n\t}\n}\n\nfunc TestFloat32ArrayScanNil(t *testing.T) {\n\tarr := Float32Array{5, 5, 5}\n\terr := arr.Scan(nil)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif arr != nil {\n\t\tt.Errorf(\"Expected nil, got %+v\", arr)\n\t}\n}\n\nvar Float32ArrayStringTests = []struct {\n\tstr string\n\tarr Float32Array\n}{\n\t{`{}`, Float32Array{}},\n\t{`{1.2}`, Float32Array{1.2}},\n\t{`{3.456,7.89}`, Float32Array{3.456, 7.89}},\n\t{`{3,1,2}`, Float32Array{3, 1, 2}},\n}\n\nfunc TestFloat32ArrayScanBytes(t *testing.T) {\n\tfor _, tt := range Float32ArrayStringTests {\n\t\tbytes := []byte(tt.str)\n\t\tarr := Float32Array{5, 5, 5}\n\t\terr := arr.Scan(bytes)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error for %q, got %v\", bytes, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, tt.arr) {\n\t\t\tt.Errorf(\"Expected %+v for %q, got %+v\", tt.arr, bytes, arr)\n\t\t}\n\t}\n}\n\nfunc BenchmarkFloat32ArrayScanBytes(b *testing.B) {\n\tvar a Float32Array\n\tvar x interface{} = []byte(`{1.2,3.4,5.6,7.8,9.01,2.34,5.67,8.90,1.234,5.678}`)\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta = Float32Array{}\n\t\ta.Scan(x)\n\t}\n}\n\nfunc TestFloat32ArrayScanString(t *testing.T) {\n\tfor _, tt := range Float32ArrayStringTests {\n\t\tarr := Float32Array{5, 5, 5}\n\t\terr := arr.Scan(tt.str)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error for %q, got %v\", tt.str, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, tt.arr) {\n\t\t\tt.Errorf(\"Expected %+v for %q, got %+v\", tt.arr, tt.str, arr)\n\t\t}\n\t}\n}\n\nfunc TestFloat32ArrayScanError(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tinput, err string\n\t}{\n\t\t{``, \"unable to parse array\"},\n\t\t{`{`, \"unable to parse array\"},\n\t\t{`{{5.6},{7.8}}`, \"cannot convert ARRAY[2][1] to Float32Array\"},\n\t\t{`{NULL}`, \"parsing array element index 0:\"},\n\t\t{`{a}`, \"parsing array element index 0:\"},\n\t\t{`{5.6,a}`, \"parsing array element index 1:\"},\n\t\t{`{5.6,7.8,a}`, \"parsing array element index 2:\"},\n\t} {\n\t\tarr := Float32Array{5, 5, 5}\n\t\terr := arr.Scan(tt.input)\n\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Expected error for %q, got none\", tt.input)\n\t\t}\n\t\tif !strings.Contains(err.Error(), tt.err) {\n\t\t\tt.Errorf(\"Expected error to contain %q for %q, got %q\", tt.err, tt.input, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, Float32Array{5, 5, 5}) {\n\t\t\tt.Errorf(\"Expected destination not to change for %q, got %+v\", tt.input, arr)\n\t\t}\n\t}\n}\n\nfunc TestFloat32ArrayValue(t *testing.T) {\n\tresult, err := Float32Array(nil).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error for nil, got %v\", err)\n\t}\n\tif result != nil {\n\t\tt.Errorf(\"Expected nil, got %q\", result)\n\t}\n\n\tresult, err = Float32Array([]float32{}).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error for empty, got %v\", err)\n\t}\n\tif expected := `{}`; !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected empty, got %q\", result)\n\t}\n\n\tresult, err = Float32Array([]float32{1.2, 3.4, 5.6}).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif expected := `{1.2,3.4,5.6}`; !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected %q, got %q\", expected, result)\n\t}\n}\n\nfunc BenchmarkFloat32ArrayValue(b *testing.B) {\n\trand.Seed(1)\n\tx := make([]float32, 10)\n\tfor i := 0; i < len(x); i++ {\n\t\tx[i] = rand.Float32()\n\t}\n\ta := Float32Array(x)\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta.Value()\n\t}\n}\n\nfunc TestInt32ArrayScanUnsupported(t *testing.T) {\n\tvar arr Int32Array\n\terr := arr.Scan(true)\n\n\tif err == nil {\n\t\tt.Fatal(\"Expected error when scanning from bool\")\n\t}\n\tif !strings.Contains(err.Error(), \"bool to Int32Array\") {\n\t\tt.Errorf(\"Expected type to be mentioned when scanning, got %q\", err)\n\t}\n}\n\nfunc TestInt32ArrayScanEmpty(t *testing.T) {\n\tvar arr Int32Array\n\terr := arr.Scan(`{}`)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif arr == nil || len(arr) != 0 {\n\t\tt.Errorf(\"Expected empty, got %#v\", arr)\n\t}\n}\n\nfunc TestInt32ArrayScanNil(t *testing.T) {\n\tarr := Int32Array{5, 5, 5}\n\terr := arr.Scan(nil)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif arr != nil {\n\t\tt.Errorf(\"Expected nil, got %+v\", arr)\n\t}\n}\n\nvar Int32ArrayStringTests = []struct {\n\tstr string\n\tarr Int32Array\n}{\n\t{`{}`, Int32Array{}},\n\t{`{12}`, Int32Array{12}},\n\t{`{345,678}`, Int32Array{345, 678}},\n}\n\nfunc TestInt32ArrayScanBytes(t *testing.T) {\n\tfor _, tt := range Int32ArrayStringTests {\n\t\tbytes := []byte(tt.str)\n\t\tarr := Int32Array{5, 5, 5}\n\t\terr := arr.Scan(bytes)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error for %q, got %v\", bytes, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, tt.arr) {\n\t\t\tt.Errorf(\"Expected %+v for %q, got %+v\", tt.arr, bytes, arr)\n\t\t}\n\t}\n}\n\nfunc BenchmarkInt32ArrayScanBytes(b *testing.B) {\n\tvar a Int32Array\n\tvar x interface{} = []byte(`{1,2,3,4,5,6,7,8,9,0}`)\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta = Int32Array{}\n\t\ta.Scan(x)\n\t}\n}\n\nfunc TestInt32ArrayScanString(t *testing.T) {\n\tfor _, tt := range Int32ArrayStringTests {\n\t\tarr := Int32Array{5, 5, 5}\n\t\terr := arr.Scan(tt.str)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error for %q, got %v\", tt.str, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, tt.arr) {\n\t\t\tt.Errorf(\"Expected %+v for %q, got %+v\", tt.arr, tt.str, arr)\n\t\t}\n\t}\n}\n\nfunc TestInt32ArrayScanError(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tinput, err string\n\t}{\n\t\t{``, \"unable to parse array\"},\n\t\t{`{`, \"unable to parse array\"},\n\t\t{`{{5},{6}}`, \"cannot convert ARRAY[2][1] to Int32Array\"},\n\t\t{`{NULL}`, \"parsing array element index 0:\"},\n\t\t{`{a}`, \"parsing array element index 0:\"},\n\t\t{`{5,a}`, \"parsing array element index 1:\"},\n\t\t{`{5,6,a}`, \"parsing array element index 2:\"},\n\t} {\n\t\tarr := Int32Array{5, 5, 5}\n\t\terr := arr.Scan(tt.input)\n\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Expected error for %q, got none\", tt.input)\n\t\t}\n\t\tif !strings.Contains(err.Error(), tt.err) {\n\t\t\tt.Errorf(\"Expected error to contain %q for %q, got %q\", tt.err, tt.input, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, Int32Array{5, 5, 5}) {\n\t\t\tt.Errorf(\"Expected destination not to change for %q, got %+v\", tt.input, arr)\n\t\t}\n\t}\n}\n\nfunc TestInt32ArrayValue(t *testing.T) {\n\tresult, err := Int32Array(nil).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error for nil, got %v\", err)\n\t}\n\tif result != nil {\n\t\tt.Errorf(\"Expected nil, got %q\", result)\n\t}\n\n\tresult, err = Int32Array([]int32{}).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error for empty, got %v\", err)\n\t}\n\tif expected := `{}`; !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected empty, got %q\", result)\n\t}\n\n\tresult, err = Int32Array([]int32{1, 2, 3}).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif expected := `{1,2,3}`; !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected %q, got %q\", expected, result)\n\t}\n}\n\nfunc BenchmarkInt32ArrayValue(b *testing.B) {\n\trand.Seed(1)\n\tx := make([]int32, 10)\n\tfor i := 0; i < len(x); i++ {\n\t\tx[i] = rand.Int31()\n\t}\n\ta := Int32Array(x)\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta.Value()\n\t}\n}\n\nfunc TestStringArrayScanUnsupported(t *testing.T) {\n\tvar arr StringArray\n\terr := arr.Scan(true)\n\n\tif err == nil {\n\t\tt.Fatal(\"Expected error when scanning from bool\")\n\t}\n\tif !strings.Contains(err.Error(), \"bool to StringArray\") {\n\t\tt.Errorf(\"Expected type to be mentioned when scanning, got %q\", err)\n\t}\n}\n\nfunc TestStringArrayScanEmpty(t *testing.T) {\n\tvar arr StringArray\n\terr := arr.Scan(`{}`)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif arr == nil || len(arr) != 0 {\n\t\tt.Errorf(\"Expected empty, got %#v\", arr)\n\t}\n}\n\nfunc TestStringArrayScanNil(t *testing.T) {\n\tarr := StringArray{\"x\", \"x\", \"x\"}\n\terr := arr.Scan(nil)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif arr != nil {\n\t\tt.Errorf(\"Expected nil, got %+v\", arr)\n\t}\n}\n\nvar StringArrayStringTests = []struct {\n\tstr string\n\tarr StringArray\n}{\n\t{`{}`, StringArray{}},\n\t{`{t}`, StringArray{\"t\"}},\n\t{`{f,1}`, StringArray{\"f\", \"1\"}},\n\t{`{\"a\\\\b\",\"c d\",\",\"}`, StringArray{\"a\\\\b\", \"c d\", \",\"}},\n}\n\nfunc TestStringArrayScanBytes(t *testing.T) {\n\tfor _, tt := range StringArrayStringTests {\n\t\tbytes := []byte(tt.str)\n\t\tarr := StringArray{\"x\", \"x\", \"x\"}\n\t\terr := arr.Scan(bytes)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error for %q, got %v\", bytes, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, tt.arr) {\n\t\t\tt.Errorf(\"Expected %+v for %q, got %+v\", tt.arr, bytes, arr)\n\t\t}\n\t}\n}\n\nfunc BenchmarkStringArrayScanBytes(b *testing.B) {\n\tvar a StringArray\n\tvar x interface{} = []byte(`{a,b,c,d,e,f,g,h,i,j}`)\n\tvar y interface{} = []byte(`{\"\\a\",\"\\b\",\"\\c\",\"\\d\",\"\\e\",\"\\f\",\"\\g\",\"\\h\",\"\\i\",\"\\j\"}`)\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta = StringArray{}\n\t\ta.Scan(x)\n\t\ta = StringArray{}\n\t\ta.Scan(y)\n\t}\n}\n\nfunc TestStringArrayScanString(t *testing.T) {\n\tfor _, tt := range StringArrayStringTests {\n\t\tarr := StringArray{\"x\", \"x\", \"x\"}\n\t\terr := arr.Scan(tt.str)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error for %q, got %v\", tt.str, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, tt.arr) {\n\t\t\tt.Errorf(\"Expected %+v for %q, got %+v\", tt.arr, tt.str, arr)\n\t\t}\n\t}\n}\n\nfunc TestStringArrayScanError(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tinput, err string\n\t}{\n\t\t{``, \"unable to parse array\"},\n\t\t{`{`, \"unable to parse array\"},\n\t\t{`{{a},{b}}`, \"cannot convert ARRAY[2][1] to StringArray\"},\n\t\t{`{NULL}`, \"parsing array element index 0: cannot convert nil to string\"},\n\t\t{`{a,NULL}`, \"parsing array element index 1: cannot convert nil to string\"},\n\t\t{`{a,b,NULL}`, \"parsing array element index 2: cannot convert nil to string\"},\n\t} {\n\t\tarr := StringArray{\"x\", \"x\", \"x\"}\n\t\terr := arr.Scan(tt.input)\n\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Expected error for %q, got none\", tt.input)\n\t\t}\n\t\tif !strings.Contains(err.Error(), tt.err) {\n\t\t\tt.Errorf(\"Expected error to contain %q for %q, got %q\", tt.err, tt.input, err)\n\t\t}\n\t\tif !reflect.DeepEqual(arr, StringArray{\"x\", \"x\", \"x\"}) {\n\t\t\tt.Errorf(\"Expected destination not to change for %q, got %+v\", tt.input, arr)\n\t\t}\n\t}\n}\n\nfunc TestStringArrayValue(t *testing.T) {\n\tresult, err := StringArray(nil).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error for nil, got %v\", err)\n\t}\n\tif result != nil {\n\t\tt.Errorf(\"Expected nil, got %q\", result)\n\t}\n\n\tresult, err = StringArray([]string{}).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error for empty, got %v\", err)\n\t}\n\tif expected := `{}`; !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected empty, got %q\", result)\n\t}\n\n\tresult, err = StringArray([]string{`a`, `\\b`, `c\"`, `d,e`}).Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif expected := `{\"a\",\"\\\\b\",\"c\\\"\",\"d,e\"}`; !reflect.DeepEqual(result, expected) {\n\t\tt.Errorf(\"Expected %q, got %q\", expected, result)\n\t}\n}\n\nfunc BenchmarkStringArrayValue(b *testing.B) {\n\tx := make([]string, 10)\n\tfor i := 0; i < len(x); i++ {\n\t\tx[i] = strings.Repeat(`abc\"def\\ghi`, 5)\n\t}\n\ta := StringArray(x)\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta.Value()\n\t}\n}\n\nfunc TestGenericArrayScanUnsupported(t *testing.T) {\n\tvar s string\n\tvar ss []string\n\tvar nsa [1]sql.NullString\n\n\tfor _, tt := range []struct {\n\t\tsrc, dest interface{}\n\t\terr       string\n\t}{\n\t\t{nil, nil, \"destination <nil> is not a pointer to array or slice\"},\n\t\t{nil, true, \"destination bool is not a pointer to array or slice\"},\n\t\t{nil, &s, \"destination *string is not a pointer to array or slice\"},\n\t\t{nil, ss, \"destination []string is not a pointer to array or slice\"},\n\t\t{nil, &nsa, \"<nil> to [1]sql.NullString\"},\n\t\t{true, &ss, \"bool to []string\"},\n\t\t{`{{x}}`, &ss, \"multidimensional ARRAY[1][1] is not implemented\"},\n\t\t{`{{x},{x}}`, &ss, \"multidimensional ARRAY[2][1] is not implemented\"},\n\t\t{`{x}`, &ss, \"scanning to string is not implemented\"},\n\t} {\n\t\terr := GenericArray{tt.dest}.Scan(tt.src)\n\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Expected error for [%#v %#v]\", tt.src, tt.dest)\n\t\t}\n\t\tif !strings.Contains(err.Error(), tt.err) {\n\t\t\tt.Errorf(\"Expected error to contain %q for [%#v %#v], got %q\", tt.err, tt.src, tt.dest, err)\n\t\t}\n\t}\n}\n\nfunc TestGenericArrayScanScannerArrayBytes(t *testing.T) {\n\tsrc, expected, nsa := []byte(`{NULL,abc,\"\\\"\"}`),\n\t\t[3]sql.NullString{{}, {String: `abc`, Valid: true}, {String: `\"`, Valid: true}},\n\t\t[3]sql.NullString{{String: ``, Valid: true}, {}, {}}\n\n\tif err := (GenericArray{&nsa}).Scan(src); err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif !reflect.DeepEqual(nsa, expected) {\n\t\tt.Errorf(\"Expected %v, got %v\", expected, nsa)\n\t}\n}\n\nfunc TestGenericArrayScanScannerArrayString(t *testing.T) {\n\tsrc, expected, nsa := `{NULL,\"\\\"\",xyz}`,\n\t\t[3]sql.NullString{{}, {String: `\"`, Valid: true}, {String: `xyz`, Valid: true}},\n\t\t[3]sql.NullString{{String: ``, Valid: true}, {}, {}}\n\n\tif err := (GenericArray{&nsa}).Scan(src); err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif !reflect.DeepEqual(nsa, expected) {\n\t\tt.Errorf(\"Expected %v, got %v\", expected, nsa)\n\t}\n}\n\nfunc TestGenericArrayScanScannerSliceEmpty(t *testing.T) {\n\tvar nss []sql.NullString\n\n\tif err := (GenericArray{&nss}).Scan(`{}`); err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif nss == nil || len(nss) != 0 {\n\t\tt.Errorf(\"Expected empty, got %#v\", nss)\n\t}\n}\n\nfunc TestGenericArrayScanScannerSliceNil(t *testing.T) {\n\tnss := []sql.NullString{{String: ``, Valid: true}, {}}\n\n\tif err := (GenericArray{&nss}).Scan(nil); err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif nss != nil {\n\t\tt.Errorf(\"Expected nil, got %+v\", nss)\n\t}\n}\n\nfunc TestGenericArrayScanScannerSliceBytes(t *testing.T) {\n\tsrc, expected, nss := []byte(`{NULL,abc,\"\\\"\"}`),\n\t\t[]sql.NullString{{}, {String: `abc`, Valid: true}, {String: `\"`, Valid: true}},\n\t\t[]sql.NullString{{String: ``, Valid: true}, {}, {}, {}, {}}\n\n\tif err := (GenericArray{&nss}).Scan(src); err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif !reflect.DeepEqual(nss, expected) {\n\t\tt.Errorf(\"Expected %v, got %v\", expected, nss)\n\t}\n}\n\nfunc BenchmarkGenericArrayScanScannerSliceBytes(b *testing.B) {\n\tvar a GenericArray\n\tvar x interface{} = []byte(`{a,b,c,d,e,f,g,h,i,j}`)\n\tvar y interface{} = []byte(`{\"\\a\",\"\\b\",\"\\c\",\"\\d\",\"\\e\",\"\\f\",\"\\g\",\"\\h\",\"\\i\",\"\\j\"}`)\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta = GenericArray{new([]sql.NullString)}\n\t\ta.Scan(x)\n\t\ta = GenericArray{new([]sql.NullString)}\n\t\ta.Scan(y)\n\t}\n}\n\nfunc TestGenericArrayScanScannerSliceString(t *testing.T) {\n\tsrc, expected, nss := `{NULL,\"\\\"\",xyz}`,\n\t\t[]sql.NullString{{}, {String: `\"`, Valid: true}, {String: `xyz`, Valid: true}},\n\t\t[]sql.NullString{{String: ``, Valid: true}, {}, {}}\n\n\tif err := (GenericArray{&nss}).Scan(src); err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif !reflect.DeepEqual(nss, expected) {\n\t\tt.Errorf(\"Expected %v, got %v\", expected, nss)\n\t}\n}\n\ntype TildeNullInt64 struct{ sql.NullInt64 }\n\nfunc (TildeNullInt64) ArrayDelimiter() string { return \"~\" }\n\nfunc TestGenericArrayScanDelimiter(t *testing.T) {\n\tsrc, expected, tnis := `{12~NULL~76}`,\n\t\t[]TildeNullInt64{{sql.NullInt64{Int64: 12, Valid: true}}, {}, {sql.NullInt64{Int64: 76, Valid: true}}},\n\t\t[]TildeNullInt64{{sql.NullInt64{Int64: 0, Valid: true}}, {}}\n\n\tif err := (GenericArray{&tnis}).Scan(src); err != nil {\n\t\tt.Fatalf(\"Expected no error for %#v, got %v\", src, err)\n\t}\n\tif !reflect.DeepEqual(tnis, expected) {\n\t\tt.Errorf(\"Expected %v for %#v, got %v\", expected, src, tnis)\n\t}\n}\n\nfunc TestGenericArrayScanErrors(t *testing.T) {\n\tvar sa [1]string\n\tvar nis []sql.NullInt64\n\tvar pss *[]string\n\n\tfor _, tt := range []struct {\n\t\tsrc, dest interface{}\n\t\terr       string\n\t}{\n\t\t{nil, pss, \"destination *[]string is nil\"},\n\t\t{`{`, &sa, \"unable to parse\"},\n\t\t{`{}`, &sa, \"cannot convert ARRAY[0] to [1]string\"},\n\t\t{`{x,x}`, &sa, \"cannot convert ARRAY[2] to [1]string\"},\n\t\t{`{x}`, &nis, `parsing array element index 0: converting`},\n\t} {\n\t\terr := GenericArray{tt.dest}.Scan(tt.src)\n\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Expected error for [%#v %#v]\", tt.src, tt.dest)\n\t\t}\n\t\tif !strings.Contains(err.Error(), tt.err) {\n\t\t\tt.Errorf(\"Expected error to contain %q for [%#v %#v], got %q\", tt.err, tt.src, tt.dest, err)\n\t\t}\n\t}\n}\n\nfunc TestGenericArrayValueUnsupported(t *testing.T) {\n\t_, err := GenericArray{true}.Value()\n\n\tif err == nil {\n\t\tt.Fatal(\"Expected error for bool\")\n\t}\n\tif !strings.Contains(err.Error(), \"bool to array\") {\n\t\tt.Errorf(\"Expected type to be mentioned, got %q\", err)\n\t}\n}\n\ntype ByteArrayValuer [1]byte\ntype ByteSliceValuer []byte\ntype FuncArrayValuer struct {\n\tdelimiter func() string\n\tvalue     func() (driver.Value, error)\n}\n\nfunc (a ByteArrayValuer) Value() (driver.Value, error) { return a[:], nil }\nfunc (b ByteSliceValuer) Value() (driver.Value, error) { return []byte(b), nil }\nfunc (f FuncArrayValuer) ArrayDelimiter() string       { return f.delimiter() }\nfunc (f FuncArrayValuer) Value() (driver.Value, error) { return f.value() }\n\nfunc TestGenericArrayValue(t *testing.T) {\n\tresult, err := GenericArray{nil}.Value()\n\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error for nil, got %v\", err)\n\t}\n\tif result != nil {\n\t\tt.Errorf(\"Expected nil, got %q\", result)\n\t}\n\n\tfor _, tt := range []interface{}{\n\t\t[]bool(nil),\n\t\t[][]int(nil),\n\t\t[]*int(nil),\n\t\t[]sql.NullString(nil),\n\t} {\n\t\tresult, err := GenericArray{tt}.Value()\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error for %#v, got %v\", tt, err)\n\t\t}\n\t\tif result != nil {\n\t\t\tt.Errorf(\"Expected nil for %#v, got %q\", tt, result)\n\t\t}\n\t}\n\n\tTilde := func(v driver.Value) FuncArrayValuer {\n\t\treturn FuncArrayValuer{\n\t\t\tfunc() string { return \"~\" },\n\t\t\tfunc() (driver.Value, error) { return v, nil }}\n\t}\n\n\tfor _, tt := range []struct {\n\t\tresult string\n\t\tinput  interface{}\n\t}{\n\t\t{`{}`, []bool{}},\n\t\t{`{true}`, []bool{true}},\n\t\t{`{true,false}`, []bool{true, false}},\n\t\t{`{true,false}`, [2]bool{true, false}},\n\n\t\t{`{}`, [][]int{{}}},\n\t\t{`{}`, [][]int{{}, {}}},\n\t\t{`{{1}}`, [][]int{{1}}},\n\t\t{`{{1},{2}}`, [][]int{{1}, {2}}},\n\t\t{`{{1,2},{3,4}}`, [][]int{{1, 2}, {3, 4}}},\n\t\t{`{{1,2},{3,4}}`, [2][2]int{{1, 2}, {3, 4}}},\n\n\t\t{`{\"a\",\"\\\\b\",\"c\\\"\",\"d,e\"}`, []string{`a`, `\\b`, `c\"`, `d,e`}},\n\t\t{`{\"a\",\"\\\\b\",\"c\\\"\",\"d,e\"}`, [][]byte{{'a'}, {'\\\\', 'b'}, {'c', '\"'}, {'d', ',', 'e'}}},\n\n\t\t{`{NULL}`, []*int{nil}},\n\t\t{`{0,NULL}`, []*int{new(int), nil}},\n\n\t\t{`{NULL}`, []sql.NullString{{}}},\n\t\t{`{\"\\\"\",NULL}`, []sql.NullString{{String: `\"`, Valid: true}, {}}},\n\n\t\t{`{\"a\",\"b\"}`, []ByteArrayValuer{{'a'}, {'b'}}},\n\t\t{`{{\"a\",\"b\"},{\"c\",\"d\"}}`, [][]ByteArrayValuer{{{'a'}, {'b'}}, {{'c'}, {'d'}}}},\n\n\t\t{`{\"e\",\"f\"}`, []ByteSliceValuer{{'e'}, {'f'}}},\n\t\t{`{{\"e\",\"f\"},{\"g\",\"h\"}}`, [][]ByteSliceValuer{{{'e'}, {'f'}}, {{'g'}, {'h'}}}},\n\n\t\t{`{1~2}`, []FuncArrayValuer{Tilde(int64(1)), Tilde(int64(2))}},\n\t\t{`{{1~2}~{3~4}}`, [][]FuncArrayValuer{{Tilde(int64(1)), Tilde(int64(2))}, {Tilde(int64(3)), Tilde(int64(4))}}},\n\t} {\n\t\tresult, err := GenericArray{tt.input}.Value()\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error for %q, got %v\", tt.input, err)\n\t\t}\n\t\tif !reflect.DeepEqual(result, tt.result) {\n\t\t\tt.Errorf(\"Expected %q for %q, got %q\", tt.result, tt.input, result)\n\t\t}\n\t}\n}\n\nfunc TestGenericArrayValueErrors(t *testing.T) {\n\tv := []interface{}{func() {}}\n\tif _, err := (GenericArray{v}).Value(); err == nil {\n\t\tt.Errorf(\"Expected error for %q, got nil\", v)\n\t}\n\n\tv = []interface{}{nil, func() {}}\n\tif _, err := (GenericArray{v}).Value(); err == nil {\n\t\tt.Errorf(\"Expected error for %q, got nil\", v)\n\t}\n}\n\nfunc BenchmarkGenericArrayValueBools(b *testing.B) {\n\trand.Seed(1)\n\tx := make([]bool, 10)\n\tfor i := 0; i < len(x); i++ {\n\t\tx[i] = rand.Intn(2) == 0\n\t}\n\ta := GenericArray{x}\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta.Value()\n\t}\n}\n\nfunc BenchmarkGenericArrayValueFloat64s(b *testing.B) {\n\trand.Seed(1)\n\tx := make([]float64, 10)\n\tfor i := 0; i < len(x); i++ {\n\t\tx[i] = rand.NormFloat64()\n\t}\n\ta := GenericArray{x}\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta.Value()\n\t}\n}\n\nfunc BenchmarkGenericArrayValueInt64s(b *testing.B) {\n\trand.Seed(1)\n\tx := make([]int64, 10)\n\tfor i := 0; i < len(x); i++ {\n\t\tx[i] = rand.Int63()\n\t}\n\ta := GenericArray{x}\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta.Value()\n\t}\n}\n\nfunc BenchmarkGenericArrayValueByteSlices(b *testing.B) {\n\tx := make([][]byte, 10)\n\tfor i := 0; i < len(x); i++ {\n\t\tx[i] = bytes.Repeat([]byte(`abc\"def\\ghi`), 5)\n\t}\n\ta := GenericArray{x}\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta.Value()\n\t}\n}\n\nfunc BenchmarkGenericArrayValueStrings(b *testing.B) {\n\tx := make([]string, 10)\n\tfor i := 0; i < len(x); i++ {\n\t\tx[i] = strings.Repeat(`abc\"def\\ghi`, 5)\n\t}\n\ta := GenericArray{x}\n\n\tfor i := 0; i < b.N; i++ {\n\t\ta.Value()\n\t}\n}\n\nfunc TestArrayScanBackend(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tfor _, tt := range []struct {\n\t\ts string\n\t\td sql.Scanner\n\t\te interface{}\n\t}{\n\t\t{`ARRAY[true, false]`, new(BoolArray), &BoolArray{true, false}},\n\t\t{`ARRAY[E'\\\\xdead', E'\\\\xbeef']`, new(ByteaArray), &ByteaArray{{'\\xDE', '\\xAD'}, {'\\xBE', '\\xEF'}}},\n\t\t{`ARRAY[1.2, 3.4]`, new(Float64Array), &Float64Array{1.2, 3.4}},\n\t\t{`ARRAY[1, 2, 3]`, new(Int64Array), &Int64Array{1, 2, 3}},\n\t\t{`ARRAY['a', E'\\\\b', 'c\"', 'd,e']`, new(StringArray), &StringArray{`a`, `\\b`, `c\"`, `d,e`}},\n\t} {\n\t\terr := db.QueryRow(`SELECT ` + tt.s).Scan(tt.d)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Expected no error when scanning %s into %T, got %v\", tt.s, tt.d, err)\n\t\t}\n\t\tif !reflect.DeepEqual(tt.d, tt.e) {\n\t\t\tt.Errorf(\"Expected %v when scanning %s into %T, got %v\", tt.e, tt.s, tt.d, tt.d)\n\t\t}\n\t}\n}\n\nfunc TestArrayValueBackend(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tfor _, tt := range []struct {\n\t\ts string\n\t\tv driver.Valuer\n\t}{\n\t\t{`ARRAY[true, false]`, BoolArray{true, false}},\n\t\t{`ARRAY[E'\\\\xdead', E'\\\\xbeef']`, ByteaArray{{'\\xDE', '\\xAD'}, {'\\xBE', '\\xEF'}}},\n\t\t{`ARRAY[1.2, 3.4]`, Float64Array{1.2, 3.4}},\n\t\t{`ARRAY[1, 2, 3]`, Int64Array{1, 2, 3}},\n\t\t{`ARRAY['a', E'\\\\b', 'c\"', 'd,e']`, StringArray{`a`, `\\b`, `c\"`, `d,e`}},\n\t} {\n\t\tvar x int\n\t\terr := db.QueryRow(`SELECT 1 WHERE `+tt.s+` <> $1`, tt.v).Scan(&x)\n\t\tif err != sql.ErrNoRows {\n\t\t\tt.Errorf(\"Expected %v to equal %s, got %v\", tt.v, tt.s, err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "auth",
          "type": "tree",
          "content": null
        },
        {
          "name": "bench_test.go",
          "type": "blob",
          "size": 10.07421875,
          "content": "package pq\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"io\"\n\t\"math/rand\"\n\t\"net\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/lib/pq/oid\"\n)\n\nvar (\n\tselectStringQuery = \"SELECT '\" + strings.Repeat(\"0123456789\", 10) + \"'\"\n\tselectSeriesQuery = \"SELECT generate_series(1, 100)\"\n)\n\nfunc BenchmarkSelectString(b *testing.B) {\n\tvar result string\n\tbenchQuery(b, selectStringQuery, &result)\n}\n\nfunc BenchmarkSelectSeries(b *testing.B) {\n\tvar result int\n\tbenchQuery(b, selectSeriesQuery, &result)\n}\n\nfunc benchQuery(b *testing.B, query string, result interface{}) {\n\tb.StopTimer()\n\tdb := openTestConn(b)\n\tdefer db.Close()\n\tb.StartTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tbenchQueryLoop(b, db, query, result)\n\t}\n}\n\nfunc benchQueryLoop(b *testing.B, db *sql.DB, query string, result interface{}) {\n\trows, err := db.Query(query)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tdefer rows.Close()\n\tfor rows.Next() {\n\t\terr = rows.Scan(result)\n\t\tif err != nil {\n\t\t\tb.Fatal(\"failed to scan\", err)\n\t\t}\n\t}\n}\n\n// reading from circularConn yields content[:prefixLen] once, followed by\n// content[prefixLen:] over and over again. It never returns EOF.\ntype circularConn struct {\n\tcontent   string\n\tprefixLen int\n\tpos       int\n\tnet.Conn  // for all other net.Conn methods that will never be called\n}\n\nfunc (r *circularConn) Read(b []byte) (n int, err error) {\n\tn = copy(b, r.content[r.pos:])\n\tr.pos += n\n\tif r.pos >= len(r.content) {\n\t\tr.pos = r.prefixLen\n\t}\n\treturn\n}\n\nfunc (r *circularConn) Write(b []byte) (n int, err error) { return len(b), nil }\n\nfunc (r *circularConn) Close() error { return nil }\n\nfunc fakeConn(content string, prefixLen int) *conn {\n\tc := &circularConn{content: content, prefixLen: prefixLen}\n\treturn &conn{buf: bufio.NewReader(c), c: c}\n}\n\n// This benchmark is meant to be the same as BenchmarkSelectString, but takes\n// out some of the factors this package can't control. The numbers are less noisy,\n// but also the costs of network communication aren't accurately represented.\nfunc BenchmarkMockSelectString(b *testing.B) {\n\tb.StopTimer()\n\t// taken from a recorded run of BenchmarkSelectString\n\t// See: http://www.postgresql.org/docs/current/static/protocol-message-formats.html\n\tconst response = \"1\\x00\\x00\\x00\\x04\" +\n\t\t\"t\\x00\\x00\\x00\\x06\\x00\\x00\" +\n\t\t\"T\\x00\\x00\\x00!\\x00\\x01?column?\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\xc1\\xff\\xfe\\xff\\xff\\xff\\xff\\x00\\x00\" +\n\t\t\"Z\\x00\\x00\\x00\\x05I\" +\n\t\t\"2\\x00\\x00\\x00\\x04\" +\n\t\t\"D\\x00\\x00\\x00n\\x00\\x01\\x00\\x00\\x00d0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\" +\n\t\t\"C\\x00\\x00\\x00\\rSELECT 1\\x00\" +\n\t\t\"Z\\x00\\x00\\x00\\x05I\" +\n\t\t\"3\\x00\\x00\\x00\\x04\" +\n\t\t\"Z\\x00\\x00\\x00\\x05I\"\n\tc := fakeConn(response, 0)\n\tb.StartTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tbenchMockQuery(b, c, selectStringQuery)\n\t}\n}\n\nvar seriesRowData = func() string {\n\tvar buf bytes.Buffer\n\tfor i := 1; i <= 100; i++ {\n\t\tdigits := byte(2)\n\t\tif i >= 100 {\n\t\t\tdigits = 3\n\t\t} else if i < 10 {\n\t\t\tdigits = 1\n\t\t}\n\t\tbuf.WriteString(\"D\\x00\\x00\\x00\")\n\t\tbuf.WriteByte(10 + digits)\n\t\tbuf.WriteString(\"\\x00\\x01\\x00\\x00\\x00\")\n\t\tbuf.WriteByte(digits)\n\t\tbuf.WriteString(strconv.Itoa(i))\n\t}\n\treturn buf.String()\n}()\n\nfunc BenchmarkMockSelectSeries(b *testing.B) {\n\tb.StopTimer()\n\tvar response = \"1\\x00\\x00\\x00\\x04\" +\n\t\t\"t\\x00\\x00\\x00\\x06\\x00\\x00\" +\n\t\t\"T\\x00\\x00\\x00!\\x00\\x01?column?\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\xc1\\xff\\xfe\\xff\\xff\\xff\\xff\\x00\\x00\" +\n\t\t\"Z\\x00\\x00\\x00\\x05I\" +\n\t\t\"2\\x00\\x00\\x00\\x04\" +\n\t\tseriesRowData +\n\t\t\"C\\x00\\x00\\x00\\x0fSELECT 100\\x00\" +\n\t\t\"Z\\x00\\x00\\x00\\x05I\" +\n\t\t\"3\\x00\\x00\\x00\\x04\" +\n\t\t\"Z\\x00\\x00\\x00\\x05I\"\n\tc := fakeConn(response, 0)\n\tb.StartTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tbenchMockQuery(b, c, selectSeriesQuery)\n\t}\n}\n\nfunc benchMockQuery(b *testing.B, c *conn, query string) {\n\tstmt, err := c.Prepare(query)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tdefer stmt.Close()\n\trows, err := stmt.(driver.StmtQueryContext).QueryContext(context.Background(), nil)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tdefer rows.Close()\n\tvar dest [1]driver.Value\n\tfor {\n\t\tif err := rows.Next(dest[:]); err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkPreparedSelectString(b *testing.B) {\n\tvar result string\n\tbenchPreparedQuery(b, selectStringQuery, &result)\n}\n\nfunc BenchmarkPreparedSelectSeries(b *testing.B) {\n\tvar result int\n\tbenchPreparedQuery(b, selectSeriesQuery, &result)\n}\n\nfunc benchPreparedQuery(b *testing.B, query string, result interface{}) {\n\tb.StopTimer()\n\tdb := openTestConn(b)\n\tdefer db.Close()\n\tstmt, err := db.Prepare(query)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tdefer stmt.Close()\n\tb.StartTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tbenchPreparedQueryLoop(b, db, stmt, result)\n\t}\n}\n\nfunc benchPreparedQueryLoop(b *testing.B, db *sql.DB, stmt *sql.Stmt, result interface{}) {\n\trows, err := stmt.Query()\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tif !rows.Next() {\n\t\trows.Close()\n\t\tb.Fatal(\"no rows\")\n\t}\n\tdefer rows.Close()\n\tfor rows.Next() {\n\t\terr = rows.Scan(&result)\n\t\tif err != nil {\n\t\t\tb.Fatal(\"failed to scan\")\n\t\t}\n\t}\n}\n\n// See the comment for BenchmarkMockSelectString.\nfunc BenchmarkMockPreparedSelectString(b *testing.B) {\n\tb.StopTimer()\n\tconst parseResponse = \"1\\x00\\x00\\x00\\x04\" +\n\t\t\"t\\x00\\x00\\x00\\x06\\x00\\x00\" +\n\t\t\"T\\x00\\x00\\x00!\\x00\\x01?column?\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\xc1\\xff\\xfe\\xff\\xff\\xff\\xff\\x00\\x00\" +\n\t\t\"Z\\x00\\x00\\x00\\x05I\"\n\tconst responses = parseResponse +\n\t\t\"2\\x00\\x00\\x00\\x04\" +\n\t\t\"D\\x00\\x00\\x00n\\x00\\x01\\x00\\x00\\x00d0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\" +\n\t\t\"C\\x00\\x00\\x00\\rSELECT 1\\x00\" +\n\t\t\"Z\\x00\\x00\\x00\\x05I\"\n\tc := fakeConn(responses, len(parseResponse))\n\n\tstmt, err := c.Prepare(selectStringQuery)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tb.StartTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tbenchPreparedMockQuery(b, c, stmt)\n\t}\n}\n\nfunc BenchmarkMockPreparedSelectSeries(b *testing.B) {\n\tb.StopTimer()\n\tconst parseResponse = \"1\\x00\\x00\\x00\\x04\" +\n\t\t\"t\\x00\\x00\\x00\\x06\\x00\\x00\" +\n\t\t\"T\\x00\\x00\\x00!\\x00\\x01?column?\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\xc1\\xff\\xfe\\xff\\xff\\xff\\xff\\x00\\x00\" +\n\t\t\"Z\\x00\\x00\\x00\\x05I\"\n\tvar responses = parseResponse +\n\t\t\"2\\x00\\x00\\x00\\x04\" +\n\t\tseriesRowData +\n\t\t\"C\\x00\\x00\\x00\\x0fSELECT 100\\x00\" +\n\t\t\"Z\\x00\\x00\\x00\\x05I\"\n\tc := fakeConn(responses, len(parseResponse))\n\n\tstmt, err := c.Prepare(selectSeriesQuery)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tb.StartTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tbenchPreparedMockQuery(b, c, stmt)\n\t}\n}\n\nfunc benchPreparedMockQuery(b *testing.B, c *conn, stmt driver.Stmt) {\n\trows, err := stmt.(driver.StmtQueryContext).QueryContext(context.Background(), nil)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tdefer rows.Close()\n\tvar dest [1]driver.Value\n\tfor {\n\t\tif err := rows.Next(dest[:]); err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkEncodeInt64(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tencode(&parameterStatus{}, int64(1234), oid.T_int8)\n\t}\n}\n\nfunc BenchmarkEncodeFloat64(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tencode(&parameterStatus{}, 3.14159, oid.T_float8)\n\t}\n}\n\nvar testByteString = []byte(\"abcdefghijklmnopqrstuvwxyz\")\n\nfunc BenchmarkEncodeByteaHex(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tencode(&parameterStatus{serverVersion: 90000}, testByteString, oid.T_bytea)\n\t}\n}\nfunc BenchmarkEncodeByteaEscape(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tencode(&parameterStatus{serverVersion: 84000}, testByteString, oid.T_bytea)\n\t}\n}\n\nfunc BenchmarkEncodeBool(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tencode(&parameterStatus{}, true, oid.T_bool)\n\t}\n}\n\nvar testTimestamptz = time.Date(2001, time.January, 1, 0, 0, 0, 0, time.Local)\n\nfunc BenchmarkEncodeTimestamptz(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tencode(&parameterStatus{}, testTimestamptz, oid.T_timestamptz)\n\t}\n}\n\nvar testIntBytes = []byte(\"1234\")\n\nfunc BenchmarkDecodeInt64(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tdecode(&parameterStatus{}, testIntBytes, oid.T_int8, formatText)\n\t}\n}\n\nvar testFloatBytes = []byte(\"3.14159\")\n\nfunc BenchmarkDecodeFloat64(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tdecode(&parameterStatus{}, testFloatBytes, oid.T_float8, formatText)\n\t}\n}\n\nvar testBoolBytes = []byte{'t'}\n\nfunc BenchmarkDecodeBool(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tdecode(&parameterStatus{}, testBoolBytes, oid.T_bool, formatText)\n\t}\n}\n\nfunc TestDecodeBool(t *testing.T) {\n\tdb := openTestConn(t)\n\trows, err := db.Query(\"select true\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trows.Close()\n}\n\nvar testTimestamptzBytes = []byte(\"2013-09-17 22:15:32.360754-07\")\n\nfunc BenchmarkDecodeTimestamptz(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tdecode(&parameterStatus{}, testTimestamptzBytes, oid.T_timestamptz, formatText)\n\t}\n}\n\nfunc BenchmarkDecodeTimestamptzMultiThread(b *testing.B) {\n\toldProcs := runtime.GOMAXPROCS(0)\n\tdefer runtime.GOMAXPROCS(oldProcs)\n\truntime.GOMAXPROCS(runtime.NumCPU())\n\tglobalLocationCache = newLocationCache()\n\n\tf := func(wg *sync.WaitGroup, loops int) {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < loops; i++ {\n\t\t\tdecode(&parameterStatus{}, testTimestamptzBytes, oid.T_timestamptz, formatText)\n\t\t}\n\t}\n\n\twg := &sync.WaitGroup{}\n\tb.ResetTimer()\n\tfor j := 0; j < 10; j++ {\n\t\twg.Add(1)\n\t\tgo f(wg, b.N/10)\n\t}\n\twg.Wait()\n}\n\nfunc BenchmarkLocationCache(b *testing.B) {\n\tglobalLocationCache = newLocationCache()\n\tfor i := 0; i < b.N; i++ {\n\t\tglobalLocationCache.getLocation(rand.Intn(10000))\n\t}\n}\n\nfunc BenchmarkLocationCacheMultiThread(b *testing.B) {\n\toldProcs := runtime.GOMAXPROCS(0)\n\tdefer runtime.GOMAXPROCS(oldProcs)\n\truntime.GOMAXPROCS(runtime.NumCPU())\n\tglobalLocationCache = newLocationCache()\n\n\tf := func(wg *sync.WaitGroup, loops int) {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < loops; i++ {\n\t\t\tglobalLocationCache.getLocation(rand.Intn(10000))\n\t\t}\n\t}\n\n\twg := &sync.WaitGroup{}\n\tb.ResetTimer()\n\tfor j := 0; j < 10; j++ {\n\t\twg.Add(1)\n\t\tgo f(wg, b.N/10)\n\t}\n\twg.Wait()\n}\n\n// Stress test the performance of parsing results from the wire.\nfunc BenchmarkResultParsing(b *testing.B) {\n\tb.StopTimer()\n\n\tdb := openTestConn(b)\n\tdefer db.Close()\n\t_, err := db.Exec(\"BEGIN\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tres, err := db.Query(\"SELECT generate_series(1, 50000)\")\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tres.Close()\n\t}\n}\n"
        },
        {
          "name": "buf.go",
          "type": "blob",
          "size": 1.583984375,
          "content": "package pq\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\n\t\"github.com/lib/pq/oid\"\n)\n\ntype readBuf []byte\n\nfunc (b *readBuf) int32() (n int) {\n\tn = int(int32(binary.BigEndian.Uint32(*b)))\n\t*b = (*b)[4:]\n\treturn\n}\n\nfunc (b *readBuf) oid() (n oid.Oid) {\n\tn = oid.Oid(binary.BigEndian.Uint32(*b))\n\t*b = (*b)[4:]\n\treturn\n}\n\n// N.B: this is actually an unsigned 16-bit integer, unlike int32\nfunc (b *readBuf) int16() (n int) {\n\tn = int(binary.BigEndian.Uint16(*b))\n\t*b = (*b)[2:]\n\treturn\n}\n\nfunc (b *readBuf) string() string {\n\ti := bytes.IndexByte(*b, 0)\n\tif i < 0 {\n\t\terrorf(\"invalid message format; expected string terminator\")\n\t}\n\ts := (*b)[:i]\n\t*b = (*b)[i+1:]\n\treturn string(s)\n}\n\nfunc (b *readBuf) next(n int) (v []byte) {\n\tv = (*b)[:n]\n\t*b = (*b)[n:]\n\treturn\n}\n\nfunc (b *readBuf) byte() byte {\n\treturn b.next(1)[0]\n}\n\ntype writeBuf struct {\n\tbuf []byte\n\tpos int\n}\n\nfunc (b *writeBuf) int32(n int) {\n\tx := make([]byte, 4)\n\tbinary.BigEndian.PutUint32(x, uint32(n))\n\tb.buf = append(b.buf, x...)\n}\n\nfunc (b *writeBuf) int16(n int) {\n\tx := make([]byte, 2)\n\tbinary.BigEndian.PutUint16(x, uint16(n))\n\tb.buf = append(b.buf, x...)\n}\n\nfunc (b *writeBuf) string(s string) {\n\tb.buf = append(append(b.buf, s...), '\\000')\n}\n\nfunc (b *writeBuf) byte(c byte) {\n\tb.buf = append(b.buf, c)\n}\n\nfunc (b *writeBuf) bytes(v []byte) {\n\tb.buf = append(b.buf, v...)\n}\n\nfunc (b *writeBuf) wrap() []byte {\n\tp := b.buf[b.pos:]\n\tbinary.BigEndian.PutUint32(p, uint32(len(p)))\n\treturn b.buf\n}\n\nfunc (b *writeBuf) next(c byte) {\n\tp := b.buf[b.pos:]\n\tbinary.BigEndian.PutUint32(p, uint32(len(p)))\n\tb.pos = len(b.buf) + 1\n\tb.buf = append(b.buf, c, 0, 0, 0, 0)\n}\n"
        },
        {
          "name": "buf_test.go",
          "type": "blob",
          "size": 0.2158203125,
          "content": "package pq\n\nimport \"testing\"\n\nfunc Benchmark_writeBuf_string(b *testing.B) {\n\tvar buf writeBuf\n\tconst s = \"foo\"\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tbuf.string(s)\n\t\tbuf.buf = buf.buf[:0]\n\t}\n}\n"
        },
        {
          "name": "certs",
          "type": "tree",
          "content": null
        },
        {
          "name": "conn.go",
          "type": "blob",
          "size": 49.5478515625,
          "content": "package pq\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/md5\"\n\t\"crypto/sha256\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"os/user\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\t\"unicode\"\n\n\t\"github.com/lib/pq/oid\"\n\t\"github.com/lib/pq/scram\"\n)\n\n// Common error types\nvar (\n\tErrNotSupported              = errors.New(\"pq: Unsupported command\")\n\tErrInFailedTransaction       = errors.New(\"pq: Could not complete operation in a failed transaction\")\n\tErrSSLNotSupported           = errors.New(\"pq: SSL is not enabled on the server\")\n\tErrSSLKeyUnknownOwnership    = errors.New(\"pq: Could not get owner information for private key, may not be properly protected\")\n\tErrSSLKeyHasWorldPermissions = errors.New(\"pq: Private key has world access. Permissions should be u=rw,g=r (0640) if owned by root, or u=rw (0600), or less\")\n\n\tErrCouldNotDetectUsername = errors.New(\"pq: Could not detect default username. Please provide one explicitly\")\n\n\terrUnexpectedReady = errors.New(\"unexpected ReadyForQuery\")\n\terrNoRowsAffected  = errors.New(\"no RowsAffected available after the empty statement\")\n\terrNoLastInsertID  = errors.New(\"no LastInsertId available after the empty statement\")\n)\n\n// Compile time validation that our types implement the expected interfaces\nvar (\n\t_ driver.Driver = Driver{}\n)\n\n// Driver is the Postgres database driver.\ntype Driver struct{}\n\n// Open opens a new connection to the database. name is a connection string.\n// Most users should only use it through database/sql package from the standard\n// library.\nfunc (d Driver) Open(name string) (driver.Conn, error) {\n\treturn Open(name)\n}\n\nfunc init() {\n\tsql.Register(\"postgres\", &Driver{})\n}\n\ntype parameterStatus struct {\n\t// server version in the same format as server_version_num, or 0 if\n\t// unavailable\n\tserverVersion int\n\n\t// the current location based on the TimeZone value of the session, if\n\t// available\n\tcurrentLocation *time.Location\n}\n\ntype transactionStatus byte\n\nconst (\n\ttxnStatusIdle                transactionStatus = 'I'\n\ttxnStatusIdleInTransaction   transactionStatus = 'T'\n\ttxnStatusInFailedTransaction transactionStatus = 'E'\n)\n\nfunc (s transactionStatus) String() string {\n\tswitch s {\n\tcase txnStatusIdle:\n\t\treturn \"idle\"\n\tcase txnStatusIdleInTransaction:\n\t\treturn \"idle in transaction\"\n\tcase txnStatusInFailedTransaction:\n\t\treturn \"in a failed transaction\"\n\tdefault:\n\t\terrorf(\"unknown transactionStatus %d\", s)\n\t}\n\n\tpanic(\"not reached\")\n}\n\n// Dialer is the dialer interface. It can be used to obtain more control over\n// how pq creates network connections.\ntype Dialer interface {\n\tDial(network, address string) (net.Conn, error)\n\tDialTimeout(network, address string, timeout time.Duration) (net.Conn, error)\n}\n\n// DialerContext is the context-aware dialer interface.\ntype DialerContext interface {\n\tDialContext(ctx context.Context, network, address string) (net.Conn, error)\n}\n\ntype defaultDialer struct {\n\td net.Dialer\n}\n\nfunc (d defaultDialer) Dial(network, address string) (net.Conn, error) {\n\treturn d.d.Dial(network, address)\n}\nfunc (d defaultDialer) DialTimeout(\n\tnetwork, address string, timeout time.Duration,\n) (net.Conn, error) {\n\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\tdefer cancel()\n\treturn d.DialContext(ctx, network, address)\n}\nfunc (d defaultDialer) DialContext(ctx context.Context, network, address string) (net.Conn, error) {\n\treturn d.d.DialContext(ctx, network, address)\n}\n\ntype conn struct {\n\tc         net.Conn\n\tbuf       *bufio.Reader\n\tnamei     int\n\tscratch   [512]byte\n\ttxnStatus transactionStatus\n\ttxnFinish func()\n\n\t// Save connection arguments to use during CancelRequest.\n\tdialer Dialer\n\topts   values\n\n\t// Cancellation key data for use with CancelRequest messages.\n\tprocessID int\n\tsecretKey int\n\n\tparameterStatus parameterStatus\n\n\tsaveMessageType   byte\n\tsaveMessageBuffer []byte\n\n\t// If an error is set, this connection is bad and all public-facing\n\t// functions should return the appropriate error by calling get()\n\t// (ErrBadConn) or getForNext().\n\terr syncErr\n\n\t// If set, this connection should never use the binary format when\n\t// receiving query results from prepared statements.  Only provided for\n\t// debugging.\n\tdisablePreparedBinaryResult bool\n\n\t// Whether to always send []byte parameters over as binary.  Enables single\n\t// round-trip mode for non-prepared Query calls.\n\tbinaryParameters bool\n\n\t// If true this connection is in the middle of a COPY\n\tinCopy bool\n\n\t// If not nil, notices will be synchronously sent here\n\tnoticeHandler func(*Error)\n\n\t// If not nil, notifications will be synchronously sent here\n\tnotificationHandler func(*Notification)\n\n\t// GSSAPI context\n\tgss GSS\n}\n\ntype syncErr struct {\n\terr error\n\tsync.Mutex\n}\n\n// Return ErrBadConn if connection is bad.\nfunc (e *syncErr) get() error {\n\te.Lock()\n\tdefer e.Unlock()\n\tif e.err != nil {\n\t\treturn driver.ErrBadConn\n\t}\n\treturn nil\n}\n\n// Return the error set on the connection. Currently only used by rows.Next.\nfunc (e *syncErr) getForNext() error {\n\te.Lock()\n\tdefer e.Unlock()\n\treturn e.err\n}\n\n// Set error, only if it isn't set yet.\nfunc (e *syncErr) set(err error) {\n\tif err == nil {\n\t\tpanic(\"attempt to set nil err\")\n\t}\n\te.Lock()\n\tdefer e.Unlock()\n\tif e.err == nil {\n\t\te.err = err\n\t}\n}\n\n// Handle driver-side settings in parsed connection string.\nfunc (cn *conn) handleDriverSettings(o values) (err error) {\n\tboolSetting := func(key string, val *bool) error {\n\t\tif value, ok := o[key]; ok {\n\t\t\tif value == \"yes\" {\n\t\t\t\t*val = true\n\t\t\t} else if value == \"no\" {\n\t\t\t\t*val = false\n\t\t\t} else {\n\t\t\t\treturn fmt.Errorf(\"unrecognized value %q for %s\", value, key)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\terr = boolSetting(\"disable_prepared_binary_result\", &cn.disablePreparedBinaryResult)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn boolSetting(\"binary_parameters\", &cn.binaryParameters)\n}\n\nfunc (cn *conn) handlePgpass(o values) {\n\t// if a password was supplied, do not process .pgpass\n\tif _, ok := o[\"password\"]; ok {\n\t\treturn\n\t}\n\t// Get passfile from the options\n\tfilename := o[\"passfile\"]\n\tif filename == \"\" {\n\t\t// XXX this code doesn't work on Windows where the default filename is\n\t\t// XXX %APPDATA%\\postgresql\\pgpass.conf\n\t\t// Prefer $HOME over user.Current due to glibc bug: golang.org/issue/13470\n\t\tuserHome := os.Getenv(\"HOME\")\n\t\tif userHome == \"\" {\n\t\t\tuser, err := user.Current()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tuserHome = user.HomeDir\n\t\t}\n\t\tfilename = filepath.Join(userHome, \".pgpass\")\n\t}\n\tfileinfo, err := os.Stat(filename)\n\tif err != nil {\n\t\treturn\n\t}\n\tmode := fileinfo.Mode()\n\tif mode&(0x77) != 0 {\n\t\t// XXX should warn about incorrect .pgpass permissions as psql does\n\t\treturn\n\t}\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer file.Close()\n\tscanner := bufio.NewScanner(io.Reader(file))\n\t// From: https://github.com/tg/pgpass/blob/master/reader.go\n\tfor scanner.Scan() {\n\t\tif scanText(scanner.Text(), o) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// GetFields is a helper function for scanText.\nfunc getFields(s string) []string {\n\tfs := make([]string, 0, 5)\n\tf := make([]rune, 0, len(s))\n\n\tvar esc bool\n\tfor _, c := range s {\n\t\tswitch {\n\t\tcase esc:\n\t\t\tf = append(f, c)\n\t\t\tesc = false\n\t\tcase c == '\\\\':\n\t\t\tesc = true\n\t\tcase c == ':':\n\t\t\tfs = append(fs, string(f))\n\t\t\tf = f[:0]\n\t\tdefault:\n\t\t\tf = append(f, c)\n\t\t}\n\t}\n\treturn append(fs, string(f))\n}\n\n// ScanText assists HandlePgpass in it's objective.\nfunc scanText(line string, o values) bool {\n\thostname := o[\"host\"]\n\tntw, _ := network(o)\n\tport := o[\"port\"]\n\tdb := o[\"dbname\"]\n\tusername := o[\"user\"]\n\tif len(line) == 0 || line[0] == '#' {\n\t\treturn false\n\t}\n\tsplit := getFields(line)\n\tif len(split) != 5 {\n\t\treturn false\n\t}\n\tif (split[0] == \"*\" || split[0] == hostname || (split[0] == \"localhost\" && (hostname == \"\" || ntw == \"unix\"))) && (split[1] == \"*\" || split[1] == port) && (split[2] == \"*\" || split[2] == db) && (split[3] == \"*\" || split[3] == username) {\n\t\to[\"password\"] = split[4]\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (cn *conn) writeBuf(b byte) *writeBuf {\n\tcn.scratch[0] = b\n\treturn &writeBuf{\n\t\tbuf: cn.scratch[:5],\n\t\tpos: 1,\n\t}\n}\n\n// Open opens a new connection to the database. dsn is a connection string.\n// Most users should only use it through database/sql package from the standard\n// library.\nfunc Open(dsn string) (_ driver.Conn, err error) {\n\treturn DialOpen(defaultDialer{}, dsn)\n}\n\n// DialOpen opens a new connection to the database using a dialer.\nfunc DialOpen(d Dialer, dsn string) (_ driver.Conn, err error) {\n\tc, err := NewConnector(dsn)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.Dialer(d)\n\treturn c.open(context.Background())\n}\n\nfunc (c *Connector) open(ctx context.Context) (cn *conn, err error) {\n\t// Handle any panics during connection initialization.  Note that we\n\t// specifically do *not* want to use errRecover(), as that would turn any\n\t// connection errors into ErrBadConns, hiding the real error message from\n\t// the user.\n\tdefer errRecoverNoErrBadConn(&err)\n\n\t// Create a new values map (copy). This makes it so maps in different\n\t// connections do not reference the same underlying data structure, so it\n\t// is safe for multiple connections to concurrently write to their opts.\n\to := make(values)\n\tfor k, v := range c.opts {\n\t\to[k] = v\n\t}\n\n\tcn = &conn{\n\t\topts:   o,\n\t\tdialer: c.dialer,\n\t}\n\terr = cn.handleDriverSettings(o)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcn.handlePgpass(o)\n\n\tcn.c, err = dial(ctx, c.dialer, o)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = cn.ssl(o)\n\tif err != nil {\n\t\tif cn.c != nil {\n\t\t\tcn.c.Close()\n\t\t}\n\t\treturn nil, err\n\t}\n\n\t// cn.startup panics on error. Make sure we don't leak cn.c.\n\tpanicking := true\n\tdefer func() {\n\t\tif panicking {\n\t\t\tcn.c.Close()\n\t\t}\n\t}()\n\n\tcn.buf = bufio.NewReader(cn.c)\n\tcn.startup(o)\n\n\t// reset the deadline, in case one was set (see dial)\n\tif timeout, ok := o[\"connect_timeout\"]; ok && timeout != \"0\" {\n\t\terr = cn.c.SetDeadline(time.Time{})\n\t}\n\tpanicking = false\n\treturn cn, err\n}\n\nfunc dial(ctx context.Context, d Dialer, o values) (net.Conn, error) {\n\tnetwork, address := network(o)\n\n\t// Zero or not specified means wait indefinitely.\n\tif timeout, ok := o[\"connect_timeout\"]; ok && timeout != \"0\" {\n\t\tseconds, err := strconv.ParseInt(timeout, 10, 0)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid value for parameter connect_timeout: %s\", err)\n\t\t}\n\t\tduration := time.Duration(seconds) * time.Second\n\n\t\t// connect_timeout should apply to the entire connection establishment\n\t\t// procedure, so we both use a timeout for the TCP connection\n\t\t// establishment and set a deadline for doing the initial handshake.\n\t\t// The deadline is then reset after startup() is done.\n\t\tdeadline := time.Now().Add(duration)\n\t\tvar conn net.Conn\n\t\tif dctx, ok := d.(DialerContext); ok {\n\t\t\tctx, cancel := context.WithTimeout(ctx, duration)\n\t\t\tdefer cancel()\n\t\t\tconn, err = dctx.DialContext(ctx, network, address)\n\t\t} else {\n\t\t\tconn, err = d.DialTimeout(network, address, duration)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\terr = conn.SetDeadline(deadline)\n\t\treturn conn, err\n\t}\n\tif dctx, ok := d.(DialerContext); ok {\n\t\treturn dctx.DialContext(ctx, network, address)\n\t}\n\treturn d.Dial(network, address)\n}\n\nfunc network(o values) (string, string) {\n\thost := o[\"host\"]\n\n\t// UNIX domain sockets are either represented by an (absolute) file system\n\t// path or they live in the abstract name space (starting with an @).\n\tif filepath.IsAbs(host) || strings.HasPrefix(host, \"@\") {\n\t\tsockPath := filepath.Join(host, \".s.PGSQL.\"+o[\"port\"])\n\t\treturn \"unix\", sockPath\n\t}\n\n\treturn \"tcp\", net.JoinHostPort(host, o[\"port\"])\n}\n\ntype values map[string]string\n\n// scanner implements a tokenizer for libpq-style option strings.\ntype scanner struct {\n\ts []rune\n\ti int\n}\n\n// newScanner returns a new scanner initialized with the option string s.\nfunc newScanner(s string) *scanner {\n\treturn &scanner{[]rune(s), 0}\n}\n\n// Next returns the next rune.\n// It returns 0, false if the end of the text has been reached.\nfunc (s *scanner) Next() (rune, bool) {\n\tif s.i >= len(s.s) {\n\t\treturn 0, false\n\t}\n\tr := s.s[s.i]\n\ts.i++\n\treturn r, true\n}\n\n// SkipSpaces returns the next non-whitespace rune.\n// It returns 0, false if the end of the text has been reached.\nfunc (s *scanner) SkipSpaces() (rune, bool) {\n\tr, ok := s.Next()\n\tfor unicode.IsSpace(r) && ok {\n\t\tr, ok = s.Next()\n\t}\n\treturn r, ok\n}\n\n// parseOpts parses the options from name and adds them to the values.\n//\n// The parsing code is based on conninfo_parse from libpq's fe-connect.c\nfunc parseOpts(name string, o values) error {\n\ts := newScanner(name)\n\n\tfor {\n\t\tvar (\n\t\t\tkeyRunes, valRunes []rune\n\t\t\tr                  rune\n\t\t\tok                 bool\n\t\t)\n\n\t\tif r, ok = s.SkipSpaces(); !ok {\n\t\t\tbreak\n\t\t}\n\n\t\t// Scan the key\n\t\tfor !unicode.IsSpace(r) && r != '=' {\n\t\t\tkeyRunes = append(keyRunes, r)\n\t\t\tif r, ok = s.Next(); !ok {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Skip any whitespace if we're not at the = yet\n\t\tif r != '=' {\n\t\t\tr, ok = s.SkipSpaces()\n\t\t}\n\n\t\t// The current character should be =\n\t\tif r != '=' || !ok {\n\t\t\treturn fmt.Errorf(`missing \"=\" after %q in connection info string\"`, string(keyRunes))\n\t\t}\n\n\t\t// Skip any whitespace after the =\n\t\tif r, ok = s.SkipSpaces(); !ok {\n\t\t\t// If we reach the end here, the last value is just an empty string as per libpq.\n\t\t\to[string(keyRunes)] = \"\"\n\t\t\tbreak\n\t\t}\n\n\t\tif r != '\\'' {\n\t\t\tfor !unicode.IsSpace(r) {\n\t\t\t\tif r == '\\\\' {\n\t\t\t\t\tif r, ok = s.Next(); !ok {\n\t\t\t\t\t\treturn fmt.Errorf(`missing character after backslash`)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvalRunes = append(valRunes, r)\n\n\t\t\t\tif r, ok = s.Next(); !ok {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\tquote:\n\t\t\tfor {\n\t\t\t\tif r, ok = s.Next(); !ok {\n\t\t\t\t\treturn fmt.Errorf(`unterminated quoted string literal in connection string`)\n\t\t\t\t}\n\t\t\t\tswitch r {\n\t\t\t\tcase '\\'':\n\t\t\t\t\tbreak quote\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tr, _ = s.Next()\n\t\t\t\t\tfallthrough\n\t\t\t\tdefault:\n\t\t\t\t\tvalRunes = append(valRunes, r)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\to[string(keyRunes)] = string(valRunes)\n\t}\n\n\treturn nil\n}\n\nfunc (cn *conn) isInTransaction() bool {\n\treturn cn.txnStatus == txnStatusIdleInTransaction ||\n\t\tcn.txnStatus == txnStatusInFailedTransaction\n}\n\nfunc (cn *conn) checkIsInTransaction(intxn bool) {\n\tif cn.isInTransaction() != intxn {\n\t\tcn.err.set(driver.ErrBadConn)\n\t\terrorf(\"unexpected transaction status %v\", cn.txnStatus)\n\t}\n}\n\nfunc (cn *conn) Begin() (_ driver.Tx, err error) {\n\treturn cn.begin(\"\")\n}\n\nfunc (cn *conn) begin(mode string) (_ driver.Tx, err error) {\n\tif err := cn.err.get(); err != nil {\n\t\treturn nil, err\n\t}\n\tdefer cn.errRecover(&err)\n\n\tcn.checkIsInTransaction(false)\n\t_, commandTag, err := cn.simpleExec(\"BEGIN\" + mode)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif commandTag != \"BEGIN\" {\n\t\tcn.err.set(driver.ErrBadConn)\n\t\treturn nil, fmt.Errorf(\"unexpected command tag %s\", commandTag)\n\t}\n\tif cn.txnStatus != txnStatusIdleInTransaction {\n\t\tcn.err.set(driver.ErrBadConn)\n\t\treturn nil, fmt.Errorf(\"unexpected transaction status %v\", cn.txnStatus)\n\t}\n\treturn cn, nil\n}\n\nfunc (cn *conn) closeTxn() {\n\tif finish := cn.txnFinish; finish != nil {\n\t\tfinish()\n\t}\n}\n\nfunc (cn *conn) Commit() (err error) {\n\tdefer cn.closeTxn()\n\tif err := cn.err.get(); err != nil {\n\t\treturn err\n\t}\n\tdefer cn.errRecover(&err)\n\n\tcn.checkIsInTransaction(true)\n\t// We don't want the client to think that everything is okay if it tries\n\t// to commit a failed transaction.  However, no matter what we return,\n\t// database/sql will release this connection back into the free connection\n\t// pool so we have to abort the current transaction here.  Note that you\n\t// would get the same behaviour if you issued a COMMIT in a failed\n\t// transaction, so it's also the least surprising thing to do here.\n\tif cn.txnStatus == txnStatusInFailedTransaction {\n\t\tif err := cn.rollback(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn ErrInFailedTransaction\n\t}\n\n\t_, commandTag, err := cn.simpleExec(\"COMMIT\")\n\tif err != nil {\n\t\tif cn.isInTransaction() {\n\t\t\tcn.err.set(driver.ErrBadConn)\n\t\t}\n\t\treturn err\n\t}\n\tif commandTag != \"COMMIT\" {\n\t\tcn.err.set(driver.ErrBadConn)\n\t\treturn fmt.Errorf(\"unexpected command tag %s\", commandTag)\n\t}\n\tcn.checkIsInTransaction(false)\n\treturn nil\n}\n\nfunc (cn *conn) Rollback() (err error) {\n\tdefer cn.closeTxn()\n\tif err := cn.err.get(); err != nil {\n\t\treturn err\n\t}\n\tdefer cn.errRecover(&err)\n\treturn cn.rollback()\n}\n\nfunc (cn *conn) rollback() (err error) {\n\tcn.checkIsInTransaction(true)\n\t_, commandTag, err := cn.simpleExec(\"ROLLBACK\")\n\tif err != nil {\n\t\tif cn.isInTransaction() {\n\t\t\tcn.err.set(driver.ErrBadConn)\n\t\t}\n\t\treturn err\n\t}\n\tif commandTag != \"ROLLBACK\" {\n\t\treturn fmt.Errorf(\"unexpected command tag %s\", commandTag)\n\t}\n\tcn.checkIsInTransaction(false)\n\treturn nil\n}\n\nfunc (cn *conn) gname() string {\n\tcn.namei++\n\treturn strconv.FormatInt(int64(cn.namei), 10)\n}\n\nfunc (cn *conn) simpleExec(q string) (res driver.Result, commandTag string, err error) {\n\tb := cn.writeBuf('Q')\n\tb.string(q)\n\tcn.send(b)\n\n\tfor {\n\t\tt, r := cn.recv1()\n\t\tswitch t {\n\t\tcase 'C':\n\t\t\tres, commandTag = cn.parseComplete(r.string())\n\t\tcase 'Z':\n\t\t\tcn.processReadyForQuery(r)\n\t\t\tif res == nil && err == nil {\n\t\t\t\terr = errUnexpectedReady\n\t\t\t}\n\t\t\t// done\n\t\t\treturn\n\t\tcase 'E':\n\t\t\terr = parseError(r)\n\t\tcase 'I':\n\t\t\tres = emptyRows\n\t\tcase 'T', 'D':\n\t\t\t// ignore any results\n\t\tdefault:\n\t\t\tcn.err.set(driver.ErrBadConn)\n\t\t\terrorf(\"unknown response for simple query: %q\", t)\n\t\t}\n\t}\n}\n\nfunc (cn *conn) simpleQuery(q string) (res *rows, err error) {\n\tdefer cn.errRecover(&err)\n\n\tb := cn.writeBuf('Q')\n\tb.string(q)\n\tcn.send(b)\n\n\tfor {\n\t\tt, r := cn.recv1()\n\t\tswitch t {\n\t\tcase 'C', 'I':\n\t\t\t// We allow queries which don't return any results through Query as\n\t\t\t// well as Exec.  We still have to give database/sql a rows object\n\t\t\t// the user can close, though, to avoid connections from being\n\t\t\t// leaked.  A \"rows\" with done=true works fine for that purpose.\n\t\t\tif err != nil {\n\t\t\t\tcn.err.set(driver.ErrBadConn)\n\t\t\t\terrorf(\"unexpected message %q in simple query execution\", t)\n\t\t\t}\n\t\t\tif res == nil {\n\t\t\t\tres = &rows{\n\t\t\t\t\tcn: cn,\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Set the result and tag to the last command complete if there wasn't a\n\t\t\t// query already run. Although queries usually return from here and cede\n\t\t\t// control to Next, a query with zero results does not.\n\t\t\tif t == 'C' {\n\t\t\t\tres.result, res.tag = cn.parseComplete(r.string())\n\t\t\t\tif res.colNames != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.done = true\n\t\tcase 'Z':\n\t\t\tcn.processReadyForQuery(r)\n\t\t\t// done\n\t\t\treturn\n\t\tcase 'E':\n\t\t\tres = nil\n\t\t\terr = parseError(r)\n\t\tcase 'D':\n\t\t\tif res == nil {\n\t\t\t\tcn.err.set(driver.ErrBadConn)\n\t\t\t\terrorf(\"unexpected DataRow in simple query execution\")\n\t\t\t}\n\t\t\t// the query didn't fail; kick off to Next\n\t\t\tcn.saveMessage(t, r)\n\t\t\treturn\n\t\tcase 'T':\n\t\t\t// res might be non-nil here if we received a previous\n\t\t\t// CommandComplete, but that's fine; just overwrite it\n\t\t\tres = &rows{cn: cn}\n\t\t\tres.rowsHeader = parsePortalRowDescribe(r)\n\n\t\t\t// To work around a bug in QueryRow in Go 1.2 and earlier, wait\n\t\t\t// until the first DataRow has been received.\n\t\tdefault:\n\t\t\tcn.err.set(driver.ErrBadConn)\n\t\t\terrorf(\"unknown response for simple query: %q\", t)\n\t\t}\n\t}\n}\n\ntype noRows struct{}\n\nvar emptyRows noRows\n\nvar _ driver.Result = noRows{}\n\nfunc (noRows) LastInsertId() (int64, error) {\n\treturn 0, errNoLastInsertID\n}\n\nfunc (noRows) RowsAffected() (int64, error) {\n\treturn 0, errNoRowsAffected\n}\n\n// Decides which column formats to use for a prepared statement.  The input is\n// an array of type oids, one element per result column.\nfunc decideColumnFormats(\n\tcolTyps []fieldDesc, forceText bool,\n) (colFmts []format, colFmtData []byte) {\n\tif len(colTyps) == 0 {\n\t\treturn nil, colFmtDataAllText\n\t}\n\n\tcolFmts = make([]format, len(colTyps))\n\tif forceText {\n\t\treturn colFmts, colFmtDataAllText\n\t}\n\n\tallBinary := true\n\tallText := true\n\tfor i, t := range colTyps {\n\t\tswitch t.OID {\n\t\t// This is the list of types to use binary mode for when receiving them\n\t\t// through a prepared statement.  If a type appears in this list, it\n\t\t// must also be implemented in binaryDecode in encode.go.\n\t\tcase oid.T_bytea:\n\t\t\tfallthrough\n\t\tcase oid.T_int8:\n\t\t\tfallthrough\n\t\tcase oid.T_int4:\n\t\t\tfallthrough\n\t\tcase oid.T_int2:\n\t\t\tfallthrough\n\t\tcase oid.T_uuid:\n\t\t\tcolFmts[i] = formatBinary\n\t\t\tallText = false\n\n\t\tdefault:\n\t\t\tallBinary = false\n\t\t}\n\t}\n\n\tif allBinary {\n\t\treturn colFmts, colFmtDataAllBinary\n\t} else if allText {\n\t\treturn colFmts, colFmtDataAllText\n\t} else {\n\t\tcolFmtData = make([]byte, 2+len(colFmts)*2)\n\t\tbinary.BigEndian.PutUint16(colFmtData, uint16(len(colFmts)))\n\t\tfor i, v := range colFmts {\n\t\t\tbinary.BigEndian.PutUint16(colFmtData[2+i*2:], uint16(v))\n\t\t}\n\t\treturn colFmts, colFmtData\n\t}\n}\n\nfunc (cn *conn) prepareTo(q, stmtName string) *stmt {\n\tst := &stmt{cn: cn, name: stmtName}\n\n\tb := cn.writeBuf('P')\n\tb.string(st.name)\n\tb.string(q)\n\tb.int16(0)\n\n\tb.next('D')\n\tb.byte('S')\n\tb.string(st.name)\n\n\tb.next('S')\n\tcn.send(b)\n\n\tcn.readParseResponse()\n\tst.paramTyps, st.colNames, st.colTyps = cn.readStatementDescribeResponse()\n\tst.colFmts, st.colFmtData = decideColumnFormats(st.colTyps, cn.disablePreparedBinaryResult)\n\tcn.readReadyForQuery()\n\treturn st\n}\n\nfunc (cn *conn) Prepare(q string) (_ driver.Stmt, err error) {\n\tif err := cn.err.get(); err != nil {\n\t\treturn nil, err\n\t}\n\tdefer cn.errRecover(&err)\n\n\tif len(q) >= 4 && strings.EqualFold(q[:4], \"COPY\") {\n\t\ts, err := cn.prepareCopyIn(q)\n\t\tif err == nil {\n\t\t\tcn.inCopy = true\n\t\t}\n\t\treturn s, err\n\t}\n\treturn cn.prepareTo(q, cn.gname()), nil\n}\n\nfunc (cn *conn) Close() (err error) {\n\t// Skip cn.bad return here because we always want to close a connection.\n\tdefer cn.errRecover(&err)\n\n\t// Ensure that cn.c.Close is always run. Since error handling is done with\n\t// panics and cn.errRecover, the Close must be in a defer.\n\tdefer func() {\n\t\tcerr := cn.c.Close()\n\t\tif err == nil {\n\t\t\terr = cerr\n\t\t}\n\t}()\n\n\t// Don't go through send(); ListenerConn relies on us not scribbling on the\n\t// scratch buffer of this connection.\n\treturn cn.sendSimpleMessage('X')\n}\n\n// Implement the \"Queryer\" interface\nfunc (cn *conn) Query(query string, args []driver.Value) (driver.Rows, error) {\n\treturn cn.query(query, args)\n}\n\nfunc (cn *conn) query(query string, args []driver.Value) (_ *rows, err error) {\n\tif err := cn.err.get(); err != nil {\n\t\treturn nil, err\n\t}\n\tif cn.inCopy {\n\t\treturn nil, errCopyInProgress\n\t}\n\tdefer cn.errRecover(&err)\n\n\t// Check to see if we can use the \"simpleQuery\" interface, which is\n\t// *much* faster than going through prepare/exec\n\tif len(args) == 0 {\n\t\treturn cn.simpleQuery(query)\n\t}\n\n\tif cn.binaryParameters {\n\t\tcn.sendBinaryModeQuery(query, args)\n\n\t\tcn.readParseResponse()\n\t\tcn.readBindResponse()\n\t\trows := &rows{cn: cn}\n\t\trows.rowsHeader = cn.readPortalDescribeResponse()\n\t\tcn.postExecuteWorkaround()\n\t\treturn rows, nil\n\t}\n\tst := cn.prepareTo(query, \"\")\n\tst.exec(args)\n\treturn &rows{\n\t\tcn:         cn,\n\t\trowsHeader: st.rowsHeader,\n\t}, nil\n}\n\n// Implement the optional \"Execer\" interface for one-shot queries\nfunc (cn *conn) Exec(query string, args []driver.Value) (res driver.Result, err error) {\n\tif err := cn.err.get(); err != nil {\n\t\treturn nil, err\n\t}\n\tdefer cn.errRecover(&err)\n\n\t// Check to see if we can use the \"simpleExec\" interface, which is\n\t// *much* faster than going through prepare/exec\n\tif len(args) == 0 {\n\t\t// ignore commandTag, our caller doesn't care\n\t\tr, _, err := cn.simpleExec(query)\n\t\treturn r, err\n\t}\n\n\tif cn.binaryParameters {\n\t\tcn.sendBinaryModeQuery(query, args)\n\n\t\tcn.readParseResponse()\n\t\tcn.readBindResponse()\n\t\tcn.readPortalDescribeResponse()\n\t\tcn.postExecuteWorkaround()\n\t\tres, _, err = cn.readExecuteResponse(\"Execute\")\n\t\treturn res, err\n\t}\n\t// Use the unnamed statement to defer planning until bind\n\t// time, or else value-based selectivity estimates cannot be\n\t// used.\n\tst := cn.prepareTo(query, \"\")\n\tr, err := st.Exec(args)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn r, err\n}\n\ntype safeRetryError struct {\n\tErr error\n}\n\nfunc (se *safeRetryError) Error() string {\n\treturn se.Err.Error()\n}\n\nfunc (cn *conn) send(m *writeBuf) {\n\tn, err := cn.c.Write(m.wrap())\n\tif err != nil {\n\t\tif n == 0 {\n\t\t\terr = &safeRetryError{Err: err}\n\t\t}\n\t\tpanic(err)\n\t}\n}\n\nfunc (cn *conn) sendStartupPacket(m *writeBuf) error {\n\t_, err := cn.c.Write((m.wrap())[1:])\n\treturn err\n}\n\n// Send a message of type typ to the server on the other end of cn.  The\n// message should have no payload.  This method does not use the scratch\n// buffer.\nfunc (cn *conn) sendSimpleMessage(typ byte) (err error) {\n\t_, err = cn.c.Write([]byte{typ, '\\x00', '\\x00', '\\x00', '\\x04'})\n\treturn err\n}\n\n// saveMessage memorizes a message and its buffer in the conn struct.\n// recvMessage will then return these values on the next call to it.  This\n// method is useful in cases where you have to see what the next message is\n// going to be (e.g. to see whether it's an error or not) but you can't handle\n// the message yourself.\nfunc (cn *conn) saveMessage(typ byte, buf *readBuf) {\n\tif cn.saveMessageType != 0 {\n\t\tcn.err.set(driver.ErrBadConn)\n\t\terrorf(\"unexpected saveMessageType %d\", cn.saveMessageType)\n\t}\n\tcn.saveMessageType = typ\n\tcn.saveMessageBuffer = *buf\n}\n\n// recvMessage receives any message from the backend, or returns an error if\n// a problem occurred while reading the message.\nfunc (cn *conn) recvMessage(r *readBuf) (byte, error) {\n\t// workaround for a QueryRow bug, see exec\n\tif cn.saveMessageType != 0 {\n\t\tt := cn.saveMessageType\n\t\t*r = cn.saveMessageBuffer\n\t\tcn.saveMessageType = 0\n\t\tcn.saveMessageBuffer = nil\n\t\treturn t, nil\n\t}\n\n\tx := cn.scratch[:5]\n\t_, err := io.ReadFull(cn.buf, x)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// read the type and length of the message that follows\n\tt := x[0]\n\tn := int(binary.BigEndian.Uint32(x[1:])) - 4\n\tvar y []byte\n\tif n <= len(cn.scratch) {\n\t\ty = cn.scratch[:n]\n\t} else {\n\t\ty = make([]byte, n)\n\t}\n\t_, err = io.ReadFull(cn.buf, y)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\t*r = y\n\treturn t, nil\n}\n\n// recv receives a message from the backend, but if an error happened while\n// reading the message or the received message was an ErrorResponse, it panics.\n// NoticeResponses are ignored.  This function should generally be used only\n// during the startup sequence.\nfunc (cn *conn) recv() (t byte, r *readBuf) {\n\tfor {\n\t\tvar err error\n\t\tr = &readBuf{}\n\t\tt, err = cn.recvMessage(r)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tswitch t {\n\t\tcase 'E':\n\t\t\tpanic(parseError(r))\n\t\tcase 'N':\n\t\t\tif n := cn.noticeHandler; n != nil {\n\t\t\t\tn(parseError(r))\n\t\t\t}\n\t\tcase 'A':\n\t\t\tif n := cn.notificationHandler; n != nil {\n\t\t\t\tn(recvNotification(r))\n\t\t\t}\n\t\tdefault:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// recv1Buf is exactly equivalent to recv1, except it uses a buffer supplied by\n// the caller to avoid an allocation.\nfunc (cn *conn) recv1Buf(r *readBuf) byte {\n\tfor {\n\t\tt, err := cn.recvMessage(r)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tswitch t {\n\t\tcase 'A':\n\t\t\tif n := cn.notificationHandler; n != nil {\n\t\t\t\tn(recvNotification(r))\n\t\t\t}\n\t\tcase 'N':\n\t\t\tif n := cn.noticeHandler; n != nil {\n\t\t\t\tn(parseError(r))\n\t\t\t}\n\t\tcase 'S':\n\t\t\tcn.processParameterStatus(r)\n\t\tdefault:\n\t\t\treturn t\n\t\t}\n\t}\n}\n\n// recv1 receives a message from the backend, panicking if an error occurs\n// while attempting to read it.  All asynchronous messages are ignored, with\n// the exception of ErrorResponse.\nfunc (cn *conn) recv1() (t byte, r *readBuf) {\n\tr = &readBuf{}\n\tt = cn.recv1Buf(r)\n\treturn t, r\n}\n\nfunc (cn *conn) ssl(o values) error {\n\tupgrade, err := ssl(o)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif upgrade == nil {\n\t\t// Nothing to do\n\t\treturn nil\n\t}\n\n\tw := cn.writeBuf(0)\n\tw.int32(80877103)\n\tif err = cn.sendStartupPacket(w); err != nil {\n\t\treturn err\n\t}\n\n\tb := cn.scratch[:1]\n\t_, err = io.ReadFull(cn.c, b)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif b[0] != 'S' {\n\t\treturn ErrSSLNotSupported\n\t}\n\n\tcn.c, err = upgrade(cn.c)\n\treturn err\n}\n\n// isDriverSetting returns true iff a setting is purely for configuring the\n// driver's options and should not be sent to the server in the connection\n// startup packet.\nfunc isDriverSetting(key string) bool {\n\tswitch key {\n\tcase \"host\", \"port\":\n\t\treturn true\n\tcase \"password\":\n\t\treturn true\n\tcase \"sslmode\", \"sslcert\", \"sslkey\", \"sslrootcert\", \"sslinline\", \"sslsni\":\n\t\treturn true\n\tcase \"fallback_application_name\":\n\t\treturn true\n\tcase \"connect_timeout\":\n\t\treturn true\n\tcase \"disable_prepared_binary_result\":\n\t\treturn true\n\tcase \"binary_parameters\":\n\t\treturn true\n\tcase \"krbsrvname\":\n\t\treturn true\n\tcase \"krbspn\":\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (cn *conn) startup(o values) {\n\tw := cn.writeBuf(0)\n\tw.int32(196608)\n\t// Send the backend the name of the database we want to connect to, and the\n\t// user we want to connect as.  Additionally, we send over any run-time\n\t// parameters potentially included in the connection string.  If the server\n\t// doesn't recognize any of them, it will reply with an error.\n\tfor k, v := range o {\n\t\tif isDriverSetting(k) {\n\t\t\t// skip options which can't be run-time parameters\n\t\t\tcontinue\n\t\t}\n\t\t// The protocol requires us to supply the database name as \"database\"\n\t\t// instead of \"dbname\".\n\t\tif k == \"dbname\" {\n\t\t\tk = \"database\"\n\t\t}\n\t\tw.string(k)\n\t\tw.string(v)\n\t}\n\tw.string(\"\")\n\tif err := cn.sendStartupPacket(w); err != nil {\n\t\tpanic(err)\n\t}\n\n\tfor {\n\t\tt, r := cn.recv()\n\t\tswitch t {\n\t\tcase 'K':\n\t\t\tcn.processBackendKeyData(r)\n\t\tcase 'S':\n\t\t\tcn.processParameterStatus(r)\n\t\tcase 'R':\n\t\t\tcn.auth(r, o)\n\t\tcase 'Z':\n\t\t\tcn.processReadyForQuery(r)\n\t\t\treturn\n\t\tdefault:\n\t\t\terrorf(\"unknown response for startup: %q\", t)\n\t\t}\n\t}\n}\n\nfunc (cn *conn) auth(r *readBuf, o values) {\n\tswitch code := r.int32(); code {\n\tcase 0:\n\t\t// OK\n\tcase 3:\n\t\tw := cn.writeBuf('p')\n\t\tw.string(o[\"password\"])\n\t\tcn.send(w)\n\n\t\tt, r := cn.recv()\n\t\tif t != 'R' {\n\t\t\terrorf(\"unexpected password response: %q\", t)\n\t\t}\n\n\t\tif r.int32() != 0 {\n\t\t\terrorf(\"unexpected authentication response: %q\", t)\n\t\t}\n\tcase 5:\n\t\ts := string(r.next(4))\n\t\tw := cn.writeBuf('p')\n\t\tw.string(\"md5\" + md5s(md5s(o[\"password\"]+o[\"user\"])+s))\n\t\tcn.send(w)\n\n\t\tt, r := cn.recv()\n\t\tif t != 'R' {\n\t\t\terrorf(\"unexpected password response: %q\", t)\n\t\t}\n\n\t\tif r.int32() != 0 {\n\t\t\terrorf(\"unexpected authentication response: %q\", t)\n\t\t}\n\tcase 7: // GSSAPI, startup\n\t\tif newGss == nil {\n\t\t\terrorf(\"kerberos error: no GSSAPI provider registered (import github.com/lib/pq/auth/kerberos if you need Kerberos support)\")\n\t\t}\n\t\tcli, err := newGss()\n\t\tif err != nil {\n\t\t\terrorf(\"kerberos error: %s\", err.Error())\n\t\t}\n\n\t\tvar token []byte\n\n\t\tif spn, ok := o[\"krbspn\"]; ok {\n\t\t\t// Use the supplied SPN if provided..\n\t\t\ttoken, err = cli.GetInitTokenFromSpn(spn)\n\t\t} else {\n\t\t\t// Allow the kerberos service name to be overridden\n\t\t\tservice := \"postgres\"\n\t\t\tif val, ok := o[\"krbsrvname\"]; ok {\n\t\t\t\tservice = val\n\t\t\t}\n\n\t\t\ttoken, err = cli.GetInitToken(o[\"host\"], service)\n\t\t}\n\n\t\tif err != nil {\n\t\t\terrorf(\"failed to get Kerberos ticket: %q\", err)\n\t\t}\n\n\t\tw := cn.writeBuf('p')\n\t\tw.bytes(token)\n\t\tcn.send(w)\n\n\t\t// Store for GSSAPI continue message\n\t\tcn.gss = cli\n\n\tcase 8: // GSSAPI continue\n\n\t\tif cn.gss == nil {\n\t\t\terrorf(\"GSSAPI protocol error\")\n\t\t}\n\n\t\tb := []byte(*r)\n\n\t\tdone, tokOut, err := cn.gss.Continue(b)\n\t\tif err == nil && !done {\n\t\t\tw := cn.writeBuf('p')\n\t\t\tw.bytes(tokOut)\n\t\t\tcn.send(w)\n\t\t}\n\n\t\t// Errors fall through and read the more detailed message\n\t\t// from the server..\n\n\tcase 10:\n\t\tsc := scram.NewClient(sha256.New, o[\"user\"], o[\"password\"])\n\t\tsc.Step(nil)\n\t\tif sc.Err() != nil {\n\t\t\terrorf(\"SCRAM-SHA-256 error: %s\", sc.Err().Error())\n\t\t}\n\t\tscOut := sc.Out()\n\n\t\tw := cn.writeBuf('p')\n\t\tw.string(\"SCRAM-SHA-256\")\n\t\tw.int32(len(scOut))\n\t\tw.bytes(scOut)\n\t\tcn.send(w)\n\n\t\tt, r := cn.recv()\n\t\tif t != 'R' {\n\t\t\terrorf(\"unexpected password response: %q\", t)\n\t\t}\n\n\t\tif r.int32() != 11 {\n\t\t\terrorf(\"unexpected authentication response: %q\", t)\n\t\t}\n\n\t\tnextStep := r.next(len(*r))\n\t\tsc.Step(nextStep)\n\t\tif sc.Err() != nil {\n\t\t\terrorf(\"SCRAM-SHA-256 error: %s\", sc.Err().Error())\n\t\t}\n\n\t\tscOut = sc.Out()\n\t\tw = cn.writeBuf('p')\n\t\tw.bytes(scOut)\n\t\tcn.send(w)\n\n\t\tt, r = cn.recv()\n\t\tif t != 'R' {\n\t\t\terrorf(\"unexpected password response: %q\", t)\n\t\t}\n\n\t\tif r.int32() != 12 {\n\t\t\terrorf(\"unexpected authentication response: %q\", t)\n\t\t}\n\n\t\tnextStep = r.next(len(*r))\n\t\tsc.Step(nextStep)\n\t\tif sc.Err() != nil {\n\t\t\terrorf(\"SCRAM-SHA-256 error: %s\", sc.Err().Error())\n\t\t}\n\n\tdefault:\n\t\terrorf(\"unknown authentication response: %d\", code)\n\t}\n}\n\ntype format int\n\nconst formatText format = 0\nconst formatBinary format = 1\n\n// One result-column format code with the value 1 (i.e. all binary).\nvar colFmtDataAllBinary = []byte{0, 1, 0, 1}\n\n// No result-column format codes (i.e. all text).\nvar colFmtDataAllText = []byte{0, 0}\n\ntype stmt struct {\n\tcn   *conn\n\tname string\n\trowsHeader\n\tcolFmtData []byte\n\tparamTyps  []oid.Oid\n\tclosed     bool\n}\n\nfunc (st *stmt) Close() (err error) {\n\tif st.closed {\n\t\treturn nil\n\t}\n\tif err := st.cn.err.get(); err != nil {\n\t\treturn err\n\t}\n\tdefer st.cn.errRecover(&err)\n\n\tw := st.cn.writeBuf('C')\n\tw.byte('S')\n\tw.string(st.name)\n\tst.cn.send(w)\n\n\tst.cn.send(st.cn.writeBuf('S'))\n\n\tt, _ := st.cn.recv1()\n\tif t != '3' {\n\t\tst.cn.err.set(driver.ErrBadConn)\n\t\terrorf(\"unexpected close response: %q\", t)\n\t}\n\tst.closed = true\n\n\tt, r := st.cn.recv1()\n\tif t != 'Z' {\n\t\tst.cn.err.set(driver.ErrBadConn)\n\t\terrorf(\"expected ready for query, but got: %q\", t)\n\t}\n\tst.cn.processReadyForQuery(r)\n\n\treturn nil\n}\n\nfunc (st *stmt) Query(v []driver.Value) (r driver.Rows, err error) {\n\treturn st.query(v)\n}\n\nfunc (st *stmt) query(v []driver.Value) (r *rows, err error) {\n\tif err := st.cn.err.get(); err != nil {\n\t\treturn nil, err\n\t}\n\tdefer st.cn.errRecover(&err)\n\n\tst.exec(v)\n\treturn &rows{\n\t\tcn:         st.cn,\n\t\trowsHeader: st.rowsHeader,\n\t}, nil\n}\n\nfunc (st *stmt) Exec(v []driver.Value) (res driver.Result, err error) {\n\tif err := st.cn.err.get(); err != nil {\n\t\treturn nil, err\n\t}\n\tdefer st.cn.errRecover(&err)\n\n\tst.exec(v)\n\tres, _, err = st.cn.readExecuteResponse(\"simple query\")\n\treturn res, err\n}\n\nfunc (st *stmt) exec(v []driver.Value) {\n\tif len(v) >= 65536 {\n\t\terrorf(\"got %d parameters but PostgreSQL only supports 65535 parameters\", len(v))\n\t}\n\tif len(v) != len(st.paramTyps) {\n\t\terrorf(\"got %d parameters but the statement requires %d\", len(v), len(st.paramTyps))\n\t}\n\n\tcn := st.cn\n\tw := cn.writeBuf('B')\n\tw.byte(0) // unnamed portal\n\tw.string(st.name)\n\n\tif cn.binaryParameters {\n\t\tcn.sendBinaryParameters(w, v)\n\t} else {\n\t\tw.int16(0)\n\t\tw.int16(len(v))\n\t\tfor i, x := range v {\n\t\t\tif x == nil {\n\t\t\t\tw.int32(-1)\n\t\t\t} else {\n\t\t\t\tb := encode(&cn.parameterStatus, x, st.paramTyps[i])\n\t\t\t\tw.int32(len(b))\n\t\t\t\tw.bytes(b)\n\t\t\t}\n\t\t}\n\t}\n\tw.bytes(st.colFmtData)\n\n\tw.next('E')\n\tw.byte(0)\n\tw.int32(0)\n\n\tw.next('S')\n\tcn.send(w)\n\n\tcn.readBindResponse()\n\tcn.postExecuteWorkaround()\n\n}\n\nfunc (st *stmt) NumInput() int {\n\treturn len(st.paramTyps)\n}\n\n// parseComplete parses the \"command tag\" from a CommandComplete message, and\n// returns the number of rows affected (if applicable) and a string\n// identifying only the command that was executed, e.g. \"ALTER TABLE\".  If the\n// command tag could not be parsed, parseComplete panics.\nfunc (cn *conn) parseComplete(commandTag string) (driver.Result, string) {\n\tcommandsWithAffectedRows := []string{\n\t\t\"SELECT \",\n\t\t// INSERT is handled below\n\t\t\"UPDATE \",\n\t\t\"DELETE \",\n\t\t\"FETCH \",\n\t\t\"MOVE \",\n\t\t\"COPY \",\n\t}\n\n\tvar affectedRows *string\n\tfor _, tag := range commandsWithAffectedRows {\n\t\tif strings.HasPrefix(commandTag, tag) {\n\t\t\tt := commandTag[len(tag):]\n\t\t\taffectedRows = &t\n\t\t\tcommandTag = tag[:len(tag)-1]\n\t\t\tbreak\n\t\t}\n\t}\n\t// INSERT also includes the oid of the inserted row in its command tag.\n\t// Oids in user tables are deprecated, and the oid is only returned when\n\t// exactly one row is inserted, so it's unlikely to be of value to any\n\t// real-world application and we can ignore it.\n\tif affectedRows == nil && strings.HasPrefix(commandTag, \"INSERT \") {\n\t\tparts := strings.Split(commandTag, \" \")\n\t\tif len(parts) != 3 {\n\t\t\tcn.err.set(driver.ErrBadConn)\n\t\t\terrorf(\"unexpected INSERT command tag %s\", commandTag)\n\t\t}\n\t\taffectedRows = &parts[len(parts)-1]\n\t\tcommandTag = \"INSERT\"\n\t}\n\t// There should be no affected rows attached to the tag, just return it\n\tif affectedRows == nil {\n\t\treturn driver.RowsAffected(0), commandTag\n\t}\n\tn, err := strconv.ParseInt(*affectedRows, 10, 64)\n\tif err != nil {\n\t\tcn.err.set(driver.ErrBadConn)\n\t\terrorf(\"could not parse commandTag: %s\", err)\n\t}\n\treturn driver.RowsAffected(n), commandTag\n}\n\ntype rowsHeader struct {\n\tcolNames []string\n\tcolTyps  []fieldDesc\n\tcolFmts  []format\n}\n\ntype rows struct {\n\tcn     *conn\n\tfinish func()\n\trowsHeader\n\tdone   bool\n\trb     readBuf\n\tresult driver.Result\n\ttag    string\n\n\tnext *rowsHeader\n}\n\nfunc (rs *rows) Close() error {\n\tif finish := rs.finish; finish != nil {\n\t\tdefer finish()\n\t}\n\t// no need to look at cn.bad as Next() will\n\tfor {\n\t\terr := rs.Next(nil)\n\t\tswitch err {\n\t\tcase nil:\n\t\tcase io.EOF:\n\t\t\t// rs.Next can return io.EOF on both 'Z' (ready for query) and 'T' (row\n\t\t\t// description, used with HasNextResultSet). We need to fetch messages until\n\t\t\t// we hit a 'Z', which is done by waiting for done to be set.\n\t\t\tif rs.done {\n\t\t\t\treturn nil\n\t\t\t}\n\t\tdefault:\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (rs *rows) Columns() []string {\n\treturn rs.colNames\n}\n\nfunc (rs *rows) Result() driver.Result {\n\tif rs.result == nil {\n\t\treturn emptyRows\n\t}\n\treturn rs.result\n}\n\nfunc (rs *rows) Tag() string {\n\treturn rs.tag\n}\n\nfunc (rs *rows) Next(dest []driver.Value) (err error) {\n\tif rs.done {\n\t\treturn io.EOF\n\t}\n\n\tconn := rs.cn\n\tif err := conn.err.getForNext(); err != nil {\n\t\treturn err\n\t}\n\tdefer conn.errRecover(&err)\n\n\tfor {\n\t\tt := conn.recv1Buf(&rs.rb)\n\t\tswitch t {\n\t\tcase 'E':\n\t\t\terr = parseError(&rs.rb)\n\t\tcase 'C', 'I':\n\t\t\tif t == 'C' {\n\t\t\t\trs.result, rs.tag = conn.parseComplete(rs.rb.string())\n\t\t\t}\n\t\t\tcontinue\n\t\tcase 'Z':\n\t\t\tconn.processReadyForQuery(&rs.rb)\n\t\t\trs.done = true\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn io.EOF\n\t\tcase 'D':\n\t\t\tn := rs.rb.int16()\n\t\t\tif err != nil {\n\t\t\t\tconn.err.set(driver.ErrBadConn)\n\t\t\t\terrorf(\"unexpected DataRow after error %s\", err)\n\t\t\t}\n\t\t\tif n < len(dest) {\n\t\t\t\tdest = dest[:n]\n\t\t\t}\n\t\t\tfor i := range dest {\n\t\t\t\tl := rs.rb.int32()\n\t\t\t\tif l == -1 {\n\t\t\t\t\tdest[i] = nil\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tdest[i] = decode(&conn.parameterStatus, rs.rb.next(l), rs.colTyps[i].OID, rs.colFmts[i])\n\t\t\t}\n\t\t\treturn\n\t\tcase 'T':\n\t\t\tnext := parsePortalRowDescribe(&rs.rb)\n\t\t\trs.next = &next\n\t\t\treturn io.EOF\n\t\tdefault:\n\t\t\terrorf(\"unexpected message after execute: %q\", t)\n\t\t}\n\t}\n}\n\nfunc (rs *rows) HasNextResultSet() bool {\n\thasNext := rs.next != nil && !rs.done\n\treturn hasNext\n}\n\nfunc (rs *rows) NextResultSet() error {\n\tif rs.next == nil {\n\t\treturn io.EOF\n\t}\n\trs.rowsHeader = *rs.next\n\trs.next = nil\n\treturn nil\n}\n\n// QuoteIdentifier quotes an \"identifier\" (e.g. a table or a column name) to be\n// used as part of an SQL statement.  For example:\n//\n//\ttblname := \"my_table\"\n//\tdata := \"my_data\"\n//\tquoted := pq.QuoteIdentifier(tblname)\n//\terr := db.Exec(fmt.Sprintf(\"INSERT INTO %s VALUES ($1)\", quoted), data)\n//\n// Any double quotes in name will be escaped.  The quoted identifier will be\n// case sensitive when used in a query.  If the input string contains a zero\n// byte, the result will be truncated immediately before it.\nfunc QuoteIdentifier(name string) string {\n\tend := strings.IndexRune(name, 0)\n\tif end > -1 {\n\t\tname = name[:end]\n\t}\n\treturn `\"` + strings.Replace(name, `\"`, `\"\"`, -1) + `\"`\n}\n\n// BufferQuoteIdentifier satisfies the same purpose as QuoteIdentifier, but backed by a\n// byte buffer.\nfunc BufferQuoteIdentifier(name string, buffer *bytes.Buffer) {\n\tend := strings.IndexRune(name, 0)\n\tif end > -1 {\n\t\tname = name[:end]\n\t}\n\tbuffer.WriteRune('\"')\n\tbuffer.WriteString(strings.Replace(name, `\"`, `\"\"`, -1))\n\tbuffer.WriteRune('\"')\n}\n\n// QuoteLiteral quotes a 'literal' (e.g. a parameter, often used to pass literal\n// to DDL and other statements that do not accept parameters) to be used as part\n// of an SQL statement.  For example:\n//\n//\texp_date := pq.QuoteLiteral(\"2023-01-05 15:00:00Z\")\n//\terr := db.Exec(fmt.Sprintf(\"CREATE ROLE my_user VALID UNTIL %s\", exp_date))\n//\n// Any single quotes in name will be escaped. Any backslashes (i.e. \"\\\") will be\n// replaced by two backslashes (i.e. \"\\\\\") and the C-style escape identifier\n// that PostgreSQL provides ('E') will be prepended to the string.\nfunc QuoteLiteral(literal string) string {\n\t// This follows the PostgreSQL internal algorithm for handling quoted literals\n\t// from libpq, which can be found in the \"PQEscapeStringInternal\" function,\n\t// which is found in the libpq/fe-exec.c source file:\n\t// https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/interfaces/libpq/fe-exec.c\n\t//\n\t// substitute any single-quotes (') with two single-quotes ('')\n\tliteral = strings.Replace(literal, `'`, `''`, -1)\n\t// determine if the string has any backslashes (\\) in it.\n\t// if it does, replace any backslashes (\\) with two backslashes (\\\\)\n\t// then, we need to wrap the entire string with a PostgreSQL\n\t// C-style escape. Per how \"PQEscapeStringInternal\" handles this case, we\n\t// also add a space before the \"E\"\n\tif strings.Contains(literal, `\\`) {\n\t\tliteral = strings.Replace(literal, `\\`, `\\\\`, -1)\n\t\tliteral = ` E'` + literal + `'`\n\t} else {\n\t\t// otherwise, we can just wrap the literal with a pair of single quotes\n\t\tliteral = `'` + literal + `'`\n\t}\n\treturn literal\n}\n\nfunc md5s(s string) string {\n\th := md5.New()\n\th.Write([]byte(s))\n\treturn fmt.Sprintf(\"%x\", h.Sum(nil))\n}\n\nfunc (cn *conn) sendBinaryParameters(b *writeBuf, args []driver.Value) {\n\t// Do one pass over the parameters to see if we're going to send any of\n\t// them over in binary.  If we are, create a paramFormats array at the\n\t// same time.\n\tvar paramFormats []int\n\tfor i, x := range args {\n\t\t_, ok := x.([]byte)\n\t\tif ok {\n\t\t\tif paramFormats == nil {\n\t\t\t\tparamFormats = make([]int, len(args))\n\t\t\t}\n\t\t\tparamFormats[i] = 1\n\t\t}\n\t}\n\tif paramFormats == nil {\n\t\tb.int16(0)\n\t} else {\n\t\tb.int16(len(paramFormats))\n\t\tfor _, x := range paramFormats {\n\t\t\tb.int16(x)\n\t\t}\n\t}\n\n\tb.int16(len(args))\n\tfor _, x := range args {\n\t\tif x == nil {\n\t\t\tb.int32(-1)\n\t\t} else {\n\t\t\tdatum := binaryEncode(&cn.parameterStatus, x)\n\t\t\tb.int32(len(datum))\n\t\t\tb.bytes(datum)\n\t\t}\n\t}\n}\n\nfunc (cn *conn) sendBinaryModeQuery(query string, args []driver.Value) {\n\tif len(args) >= 65536 {\n\t\terrorf(\"got %d parameters but PostgreSQL only supports 65535 parameters\", len(args))\n\t}\n\n\tb := cn.writeBuf('P')\n\tb.byte(0) // unnamed statement\n\tb.string(query)\n\tb.int16(0)\n\n\tb.next('B')\n\tb.int16(0) // unnamed portal and statement\n\tcn.sendBinaryParameters(b, args)\n\tb.bytes(colFmtDataAllText)\n\n\tb.next('D')\n\tb.byte('P')\n\tb.byte(0) // unnamed portal\n\n\tb.next('E')\n\tb.byte(0)\n\tb.int32(0)\n\n\tb.next('S')\n\tcn.send(b)\n}\n\nfunc (cn *conn) processParameterStatus(r *readBuf) {\n\tvar err error\n\n\tparam := r.string()\n\tswitch param {\n\tcase \"server_version\":\n\t\tvar major1 int\n\t\tvar major2 int\n\t\t_, err = fmt.Sscanf(r.string(), \"%d.%d\", &major1, &major2)\n\t\tif err == nil {\n\t\t\tcn.parameterStatus.serverVersion = major1*10000 + major2*100\n\t\t}\n\n\tcase \"TimeZone\":\n\t\tcn.parameterStatus.currentLocation, err = time.LoadLocation(r.string())\n\t\tif err != nil {\n\t\t\tcn.parameterStatus.currentLocation = nil\n\t\t}\n\n\tdefault:\n\t\t// ignore\n\t}\n}\n\nfunc (cn *conn) processReadyForQuery(r *readBuf) {\n\tcn.txnStatus = transactionStatus(r.byte())\n}\n\nfunc (cn *conn) readReadyForQuery() {\n\tt, r := cn.recv1()\n\tswitch t {\n\tcase 'Z':\n\t\tcn.processReadyForQuery(r)\n\t\treturn\n\tdefault:\n\t\tcn.err.set(driver.ErrBadConn)\n\t\terrorf(\"unexpected message %q; expected ReadyForQuery\", t)\n\t}\n}\n\nfunc (cn *conn) processBackendKeyData(r *readBuf) {\n\tcn.processID = r.int32()\n\tcn.secretKey = r.int32()\n}\n\nfunc (cn *conn) readParseResponse() {\n\tt, r := cn.recv1()\n\tswitch t {\n\tcase '1':\n\t\treturn\n\tcase 'E':\n\t\terr := parseError(r)\n\t\tcn.readReadyForQuery()\n\t\tpanic(err)\n\tdefault:\n\t\tcn.err.set(driver.ErrBadConn)\n\t\terrorf(\"unexpected Parse response %q\", t)\n\t}\n}\n\nfunc (cn *conn) readStatementDescribeResponse() (\n\tparamTyps []oid.Oid,\n\tcolNames []string,\n\tcolTyps []fieldDesc,\n) {\n\tfor {\n\t\tt, r := cn.recv1()\n\t\tswitch t {\n\t\tcase 't':\n\t\t\tnparams := r.int16()\n\t\t\tparamTyps = make([]oid.Oid, nparams)\n\t\t\tfor i := range paramTyps {\n\t\t\t\tparamTyps[i] = r.oid()\n\t\t\t}\n\t\tcase 'n':\n\t\t\treturn paramTyps, nil, nil\n\t\tcase 'T':\n\t\t\tcolNames, colTyps = parseStatementRowDescribe(r)\n\t\t\treturn paramTyps, colNames, colTyps\n\t\tcase 'E':\n\t\t\terr := parseError(r)\n\t\t\tcn.readReadyForQuery()\n\t\t\tpanic(err)\n\t\tdefault:\n\t\t\tcn.err.set(driver.ErrBadConn)\n\t\t\terrorf(\"unexpected Describe statement response %q\", t)\n\t\t}\n\t}\n}\n\nfunc (cn *conn) readPortalDescribeResponse() rowsHeader {\n\tt, r := cn.recv1()\n\tswitch t {\n\tcase 'T':\n\t\treturn parsePortalRowDescribe(r)\n\tcase 'n':\n\t\treturn rowsHeader{}\n\tcase 'E':\n\t\terr := parseError(r)\n\t\tcn.readReadyForQuery()\n\t\tpanic(err)\n\tdefault:\n\t\tcn.err.set(driver.ErrBadConn)\n\t\terrorf(\"unexpected Describe response %q\", t)\n\t}\n\tpanic(\"not reached\")\n}\n\nfunc (cn *conn) readBindResponse() {\n\tt, r := cn.recv1()\n\tswitch t {\n\tcase '2':\n\t\treturn\n\tcase 'E':\n\t\terr := parseError(r)\n\t\tcn.readReadyForQuery()\n\t\tpanic(err)\n\tdefault:\n\t\tcn.err.set(driver.ErrBadConn)\n\t\terrorf(\"unexpected Bind response %q\", t)\n\t}\n}\n\nfunc (cn *conn) postExecuteWorkaround() {\n\t// Work around a bug in sql.DB.QueryRow: in Go 1.2 and earlier it ignores\n\t// any errors from rows.Next, which masks errors that happened during the\n\t// execution of the query.  To avoid the problem in common cases, we wait\n\t// here for one more message from the database.  If it's not an error the\n\t// query will likely succeed (or perhaps has already, if it's a\n\t// CommandComplete), so we push the message into the conn struct; recv1\n\t// will return it as the next message for rows.Next or rows.Close.\n\t// However, if it's an error, we wait until ReadyForQuery and then return\n\t// the error to our caller.\n\tfor {\n\t\tt, r := cn.recv1()\n\t\tswitch t {\n\t\tcase 'E':\n\t\t\terr := parseError(r)\n\t\t\tcn.readReadyForQuery()\n\t\t\tpanic(err)\n\t\tcase 'C', 'D', 'I':\n\t\t\t// the query didn't fail, but we can't process this message\n\t\t\tcn.saveMessage(t, r)\n\t\t\treturn\n\t\tdefault:\n\t\t\tcn.err.set(driver.ErrBadConn)\n\t\t\terrorf(\"unexpected message during extended query execution: %q\", t)\n\t\t}\n\t}\n}\n\n// Only for Exec(), since we ignore the returned data\nfunc (cn *conn) readExecuteResponse(\n\tprotocolState string,\n) (res driver.Result, commandTag string, err error) {\n\tfor {\n\t\tt, r := cn.recv1()\n\t\tswitch t {\n\t\tcase 'C':\n\t\t\tif err != nil {\n\t\t\t\tcn.err.set(driver.ErrBadConn)\n\t\t\t\terrorf(\"unexpected CommandComplete after error %s\", err)\n\t\t\t}\n\t\t\tres, commandTag = cn.parseComplete(r.string())\n\t\tcase 'Z':\n\t\t\tcn.processReadyForQuery(r)\n\t\t\tif res == nil && err == nil {\n\t\t\t\terr = errUnexpectedReady\n\t\t\t}\n\t\t\treturn res, commandTag, err\n\t\tcase 'E':\n\t\t\terr = parseError(r)\n\t\tcase 'T', 'D', 'I':\n\t\t\tif err != nil {\n\t\t\t\tcn.err.set(driver.ErrBadConn)\n\t\t\t\terrorf(\"unexpected %q after error %s\", t, err)\n\t\t\t}\n\t\t\tif t == 'I' {\n\t\t\t\tres = emptyRows\n\t\t\t}\n\t\t\t// ignore any results\n\t\tdefault:\n\t\t\tcn.err.set(driver.ErrBadConn)\n\t\t\terrorf(\"unknown %s response: %q\", protocolState, t)\n\t\t}\n\t}\n}\n\nfunc parseStatementRowDescribe(r *readBuf) (colNames []string, colTyps []fieldDesc) {\n\tn := r.int16()\n\tcolNames = make([]string, n)\n\tcolTyps = make([]fieldDesc, n)\n\tfor i := range colNames {\n\t\tcolNames[i] = r.string()\n\t\tr.next(6)\n\t\tcolTyps[i].OID = r.oid()\n\t\tcolTyps[i].Len = r.int16()\n\t\tcolTyps[i].Mod = r.int32()\n\t\t// format code not known when describing a statement; always 0\n\t\tr.next(2)\n\t}\n\treturn\n}\n\nfunc parsePortalRowDescribe(r *readBuf) rowsHeader {\n\tn := r.int16()\n\tcolNames := make([]string, n)\n\tcolFmts := make([]format, n)\n\tcolTyps := make([]fieldDesc, n)\n\tfor i := range colNames {\n\t\tcolNames[i] = r.string()\n\t\tr.next(6)\n\t\tcolTyps[i].OID = r.oid()\n\t\tcolTyps[i].Len = r.int16()\n\t\tcolTyps[i].Mod = r.int32()\n\t\tcolFmts[i] = format(r.int16())\n\t}\n\treturn rowsHeader{\n\t\tcolNames: colNames,\n\t\tcolFmts:  colFmts,\n\t\tcolTyps:  colTyps,\n\t}\n}\n\n// parseEnviron tries to mimic some of libpq's environment handling\n//\n// To ease testing, it does not directly reference os.Environ, but is\n// designed to accept its output.\n//\n// Environment-set connection information is intended to have a higher\n// precedence than a library default but lower than any explicitly\n// passed information (such as in the URL or connection string).\nfunc parseEnviron(env []string) (out map[string]string) {\n\tout = make(map[string]string)\n\n\tfor _, v := range env {\n\t\tparts := strings.SplitN(v, \"=\", 2)\n\n\t\taccrue := func(keyname string) {\n\t\t\tout[keyname] = parts[1]\n\t\t}\n\t\tunsupported := func() {\n\t\t\tpanic(fmt.Sprintf(\"setting %v not supported\", parts[0]))\n\t\t}\n\n\t\t// The order of these is the same as is seen in the\n\t\t// PostgreSQL 9.1 manual. Unsupported but well-defined\n\t\t// keys cause a panic; these should be unset prior to\n\t\t// execution. Options which pq expects to be set to a\n\t\t// certain value are allowed, but must be set to that\n\t\t// value if present (they can, of course, be absent).\n\t\tswitch parts[0] {\n\t\tcase \"PGHOST\":\n\t\t\taccrue(\"host\")\n\t\tcase \"PGHOSTADDR\":\n\t\t\tunsupported()\n\t\tcase \"PGPORT\":\n\t\t\taccrue(\"port\")\n\t\tcase \"PGDATABASE\":\n\t\t\taccrue(\"dbname\")\n\t\tcase \"PGUSER\":\n\t\t\taccrue(\"user\")\n\t\tcase \"PGPASSWORD\":\n\t\t\taccrue(\"password\")\n\t\tcase \"PGPASSFILE\":\n\t\t\taccrue(\"passfile\")\n\t\tcase \"PGSERVICE\", \"PGSERVICEFILE\", \"PGREALM\":\n\t\t\tunsupported()\n\t\tcase \"PGOPTIONS\":\n\t\t\taccrue(\"options\")\n\t\tcase \"PGAPPNAME\":\n\t\t\taccrue(\"application_name\")\n\t\tcase \"PGSSLMODE\":\n\t\t\taccrue(\"sslmode\")\n\t\tcase \"PGSSLCERT\":\n\t\t\taccrue(\"sslcert\")\n\t\tcase \"PGSSLKEY\":\n\t\t\taccrue(\"sslkey\")\n\t\tcase \"PGSSLROOTCERT\":\n\t\t\taccrue(\"sslrootcert\")\n\t\tcase \"PGSSLSNI\":\n\t\t\taccrue(\"sslsni\")\n\t\tcase \"PGREQUIRESSL\", \"PGSSLCRL\":\n\t\t\tunsupported()\n\t\tcase \"PGREQUIREPEER\":\n\t\t\tunsupported()\n\t\tcase \"PGKRBSRVNAME\", \"PGGSSLIB\":\n\t\t\tunsupported()\n\t\tcase \"PGCONNECT_TIMEOUT\":\n\t\t\taccrue(\"connect_timeout\")\n\t\tcase \"PGCLIENTENCODING\":\n\t\t\taccrue(\"client_encoding\")\n\t\tcase \"PGDATESTYLE\":\n\t\t\taccrue(\"datestyle\")\n\t\tcase \"PGTZ\":\n\t\t\taccrue(\"timezone\")\n\t\tcase \"PGGEQO\":\n\t\t\taccrue(\"geqo\")\n\t\tcase \"PGSYSCONFDIR\", \"PGLOCALEDIR\":\n\t\t\tunsupported()\n\t\t}\n\t}\n\n\treturn out\n}\n\n// isUTF8 returns whether name is a fuzzy variation of the string \"UTF-8\".\nfunc isUTF8(name string) bool {\n\t// Recognize all sorts of silly things as \"UTF-8\", like Postgres does\n\ts := strings.Map(alnumLowerASCII, name)\n\treturn s == \"utf8\" || s == \"unicode\"\n}\n\nfunc alnumLowerASCII(ch rune) rune {\n\tif 'A' <= ch && ch <= 'Z' {\n\t\treturn ch + ('a' - 'A')\n\t}\n\tif 'a' <= ch && ch <= 'z' || '0' <= ch && ch <= '9' {\n\t\treturn ch\n\t}\n\treturn -1 // discard\n}\n\n// The database/sql/driver package says:\n// All Conn implementations should implement the following interfaces: Pinger, SessionResetter, and Validator.\nvar _ driver.Pinger = &conn{}\nvar _ driver.SessionResetter = &conn{}\n\nfunc (cn *conn) ResetSession(ctx context.Context) error {\n\t// Ensure bad connections are reported: From database/sql/driver:\n\t// If a connection is never returned to the connection pool but immediately reused, then\n\t// ResetSession is called prior to reuse but IsValid is not called.\n\treturn cn.err.get()\n}\n\nfunc (cn *conn) IsValid() bool {\n\treturn cn.err.get() == nil\n}\n"
        },
        {
          "name": "conn_go115.go",
          "type": "blob",
          "size": 0.1083984375,
          "content": "//go:build go1.15\n// +build go1.15\n\npackage pq\n\nimport \"database/sql/driver\"\n\nvar _ driver.Validator = &conn{}\n"
        },
        {
          "name": "conn_go18.go",
          "type": "blob",
          "size": 5.6318359375,
          "content": "package pq\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"time\"\n)\n\nconst (\n\twatchCancelDialContextTimeout = time.Second * 10\n)\n\n// Implement the \"QueryerContext\" interface\nfunc (cn *conn) QueryContext(ctx context.Context, query string, args []driver.NamedValue) (driver.Rows, error) {\n\tlist := make([]driver.Value, len(args))\n\tfor i, nv := range args {\n\t\tlist[i] = nv.Value\n\t}\n\tfinish := cn.watchCancel(ctx)\n\tr, err := cn.query(query, list)\n\tif err != nil {\n\t\tif finish != nil {\n\t\t\tfinish()\n\t\t}\n\t\treturn nil, err\n\t}\n\tr.finish = finish\n\treturn r, nil\n}\n\n// Implement the \"ExecerContext\" interface\nfunc (cn *conn) ExecContext(ctx context.Context, query string, args []driver.NamedValue) (driver.Result, error) {\n\tlist := make([]driver.Value, len(args))\n\tfor i, nv := range args {\n\t\tlist[i] = nv.Value\n\t}\n\n\tif finish := cn.watchCancel(ctx); finish != nil {\n\t\tdefer finish()\n\t}\n\n\treturn cn.Exec(query, list)\n}\n\n// Implement the \"ConnPrepareContext\" interface\nfunc (cn *conn) PrepareContext(ctx context.Context, query string) (driver.Stmt, error) {\n\tif finish := cn.watchCancel(ctx); finish != nil {\n\t\tdefer finish()\n\t}\n\treturn cn.Prepare(query)\n}\n\n// Implement the \"ConnBeginTx\" interface\nfunc (cn *conn) BeginTx(ctx context.Context, opts driver.TxOptions) (driver.Tx, error) {\n\tvar mode string\n\n\tswitch sql.IsolationLevel(opts.Isolation) {\n\tcase sql.LevelDefault:\n\t\t// Don't touch mode: use the server's default\n\tcase sql.LevelReadUncommitted:\n\t\tmode = \" ISOLATION LEVEL READ UNCOMMITTED\"\n\tcase sql.LevelReadCommitted:\n\t\tmode = \" ISOLATION LEVEL READ COMMITTED\"\n\tcase sql.LevelRepeatableRead:\n\t\tmode = \" ISOLATION LEVEL REPEATABLE READ\"\n\tcase sql.LevelSerializable:\n\t\tmode = \" ISOLATION LEVEL SERIALIZABLE\"\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"pq: isolation level not supported: %d\", opts.Isolation)\n\t}\n\n\tif opts.ReadOnly {\n\t\tmode += \" READ ONLY\"\n\t} else {\n\t\tmode += \" READ WRITE\"\n\t}\n\n\ttx, err := cn.begin(mode)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcn.txnFinish = cn.watchCancel(ctx)\n\treturn tx, nil\n}\n\nfunc (cn *conn) Ping(ctx context.Context) error {\n\tif finish := cn.watchCancel(ctx); finish != nil {\n\t\tdefer finish()\n\t}\n\trows, err := cn.simpleQuery(\";\")\n\tif err != nil {\n\t\treturn driver.ErrBadConn // https://golang.org/pkg/database/sql/driver/#Pinger\n\t}\n\trows.Close()\n\treturn nil\n}\n\nfunc (cn *conn) watchCancel(ctx context.Context) func() {\n\tif done := ctx.Done(); done != nil {\n\t\tfinished := make(chan struct{}, 1)\n\t\tgo func() {\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\tselect {\n\t\t\t\tcase finished <- struct{}{}:\n\t\t\t\tdefault:\n\t\t\t\t\t// We raced with the finish func, let the next query handle this with the\n\t\t\t\t\t// context.\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Set the connection state to bad so it does not get reused.\n\t\t\t\tcn.err.set(ctx.Err())\n\n\t\t\t\t// At this point the function level context is canceled,\n\t\t\t\t// so it must not be used for the additional network\n\t\t\t\t// request to cancel the query.\n\t\t\t\t// Create a new context to pass into the dial.\n\t\t\t\tctxCancel, cancel := context.WithTimeout(context.Background(), watchCancelDialContextTimeout)\n\t\t\t\tdefer cancel()\n\n\t\t\t\t_ = cn.cancel(ctxCancel)\n\t\t\tcase <-finished:\n\t\t\t}\n\t\t}()\n\t\treturn func() {\n\t\t\tselect {\n\t\t\tcase <-finished:\n\t\t\t\tcn.err.set(ctx.Err())\n\t\t\t\tcn.Close()\n\t\t\tcase finished <- struct{}{}:\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (cn *conn) cancel(ctx context.Context) error {\n\t// Create a new values map (copy). This makes sure the connection created\n\t// in this method cannot write to the same underlying data, which could\n\t// cause a concurrent map write panic. This is necessary because cancel\n\t// is called from a goroutine in watchCancel.\n\to := make(values)\n\tfor k, v := range cn.opts {\n\t\to[k] = v\n\t}\n\n\tc, err := dial(ctx, cn.dialer, o)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer c.Close()\n\n\t{\n\t\tcan := conn{\n\t\t\tc: c,\n\t\t}\n\t\terr = can.ssl(o)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tw := can.writeBuf(0)\n\t\tw.int32(80877102) // cancel request code\n\t\tw.int32(cn.processID)\n\t\tw.int32(cn.secretKey)\n\n\t\tif err := can.sendStartupPacket(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Read until EOF to ensure that the server received the cancel.\n\t{\n\t\t_, err := io.Copy(ioutil.Discard, c)\n\t\treturn err\n\t}\n}\n\n// Implement the \"StmtQueryContext\" interface\nfunc (st *stmt) QueryContext(ctx context.Context, args []driver.NamedValue) (driver.Rows, error) {\n\tlist := make([]driver.Value, len(args))\n\tfor i, nv := range args {\n\t\tlist[i] = nv.Value\n\t}\n\tfinish := st.watchCancel(ctx)\n\tr, err := st.query(list)\n\tif err != nil {\n\t\tif finish != nil {\n\t\t\tfinish()\n\t\t}\n\t\treturn nil, err\n\t}\n\tr.finish = finish\n\treturn r, nil\n}\n\n// Implement the \"StmtExecContext\" interface\nfunc (st *stmt) ExecContext(ctx context.Context, args []driver.NamedValue) (driver.Result, error) {\n\tlist := make([]driver.Value, len(args))\n\tfor i, nv := range args {\n\t\tlist[i] = nv.Value\n\t}\n\n\tif finish := st.watchCancel(ctx); finish != nil {\n\t\tdefer finish()\n\t}\n\n\treturn st.Exec(list)\n}\n\n// watchCancel is implemented on stmt in order to not mark the parent conn as bad\nfunc (st *stmt) watchCancel(ctx context.Context) func() {\n\tif done := ctx.Done(); done != nil {\n\t\tfinished := make(chan struct{})\n\t\tgo func() {\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\t// At this point the function level context is canceled,\n\t\t\t\t// so it must not be used for the additional network\n\t\t\t\t// request to cancel the query.\n\t\t\t\t// Create a new context to pass into the dial.\n\t\t\t\tctxCancel, cancel := context.WithTimeout(context.Background(), watchCancelDialContextTimeout)\n\t\t\t\tdefer cancel()\n\n\t\t\t\t_ = st.cancel(ctxCancel)\n\t\t\t\tfinished <- struct{}{}\n\t\t\tcase <-finished:\n\t\t\t}\n\t\t}()\n\t\treturn func() {\n\t\t\tselect {\n\t\t\tcase <-finished:\n\t\t\tcase finished <- struct{}{}:\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (st *stmt) cancel(ctx context.Context) error {\n\treturn st.cn.cancel(ctx)\n}\n"
        },
        {
          "name": "conn_go19.go",
          "type": "blob",
          "size": 0.6357421875,
          "content": "//go:build go1.9\n// +build go1.9\n\npackage pq\n\nimport (\n\t\"database/sql/driver\"\n\t\"reflect\"\n)\n\nvar _ driver.NamedValueChecker = (*conn)(nil)\n\nfunc (c *conn) CheckNamedValue(nv *driver.NamedValue) error {\n\tif _, ok := nv.Value.(driver.Valuer); ok {\n\t\t// Ignore Valuer, for backward compatibility with pq.Array().\n\t\treturn driver.ErrSkip\n\t}\n\n\t// Ignoring []byte / []uint8.\n\tif _, ok := nv.Value.([]uint8); ok {\n\t\treturn driver.ErrSkip\n\t}\n\n\tv := reflect.ValueOf(nv.Value)\n\tif v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\tif v.Kind() == reflect.Slice {\n\t\tvar err error\n\t\tnv.Value, err = Array(v.Interface()).Value()\n\t\treturn err\n\t}\n\n\treturn driver.ErrSkip\n}\n"
        },
        {
          "name": "conn_go19_test.go",
          "type": "blob",
          "size": 1.37890625,
          "content": "//go:build go1.9\n// +build go1.9\n\npackage pq\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestArrayArg(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tfor _, tc := range []struct {\n\t\tpgType  string\n\t\tin, out interface{}\n\t}{\n\t\t{\n\t\t\tpgType: \"int[]\",\n\t\t\tin:     []int{245, 231},\n\t\t\tout:    []int64{245, 231},\n\t\t},\n\t\t{\n\t\t\tpgType: \"int[]\",\n\t\t\tin:     &[]int{245, 231},\n\t\t\tout:    []int64{245, 231},\n\t\t},\n\t\t{\n\t\t\tpgType: \"int[]\",\n\t\t\tin:     []int64{245, 231},\n\t\t},\n\t\t{\n\t\t\tpgType: \"int[]\",\n\t\t\tin:     &[]int64{245, 231},\n\t\t\tout:    []int64{245, 231},\n\t\t},\n\t\t{\n\t\t\tpgType: \"varchar[]\",\n\t\t\tin:     []string{\"hello\", \"world\"},\n\t\t},\n\t\t{\n\t\t\tpgType: \"varchar[]\",\n\t\t\tin:     &[]string{\"hello\", \"world\"},\n\t\t\tout:    []string{\"hello\", \"world\"},\n\t\t},\n\t} {\n\t\tif tc.out == nil {\n\t\t\ttc.out = tc.in\n\t\t}\n\t\tt.Run(fmt.Sprintf(\"%#v\", tc.in), func(t *testing.T) {\n\t\t\tr, err := db.Query(fmt.Sprintf(\"SELECT $1::%s\", tc.pgType), tc.in)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tdefer r.Close()\n\n\t\t\tif !r.Next() {\n\t\t\t\tif r.Err() != nil {\n\t\t\t\t\tt.Fatal(r.Err())\n\t\t\t\t}\n\t\t\t\tt.Fatal(\"expected row\")\n\t\t\t}\n\n\t\t\tdefer func() {\n\t\t\t\tif r.Next() {\n\t\t\t\t\tt.Fatal(\"unexpected row\")\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tgot := reflect.New(reflect.TypeOf(tc.out))\n\t\t\tif err := r.Scan(Array(got.Interface())); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(tc.out, got.Elem().Interface()) {\n\t\t\t\tt.Errorf(\"got %v, want %v\", got, tc.out)\n\t\t\t}\n\t\t})\n\t}\n\n}\n"
        },
        {
          "name": "conn_test.go",
          "type": "blob",
          "size": 44.2939453125,
          "content": "package pq\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype Fatalistic interface {\n\tFatal(args ...interface{})\n}\n\nfunc forceBinaryParameters() bool {\n\tbp := os.Getenv(\"PQTEST_BINARY_PARAMETERS\")\n\tif bp == \"yes\" {\n\t\treturn true\n\t} else if bp == \"\" || bp == \"no\" {\n\t\treturn false\n\t} else {\n\t\tpanic(\"unexpected value for PQTEST_BINARY_PARAMETERS\")\n\t}\n}\n\nfunc testConninfo(conninfo string) string {\n\tdefaultTo := func(envvar string, value string) {\n\t\tif os.Getenv(envvar) == \"\" {\n\t\t\tos.Setenv(envvar, value)\n\t\t}\n\t}\n\tdefaultTo(\"PGDATABASE\", \"pqgotest\")\n\tdefaultTo(\"PGSSLMODE\", \"disable\")\n\tdefaultTo(\"PGCONNECT_TIMEOUT\", \"20\")\n\n\tif forceBinaryParameters() &&\n\t\t!strings.HasPrefix(conninfo, \"postgres://\") &&\n\t\t!strings.HasPrefix(conninfo, \"postgresql://\") {\n\t\tconninfo += \" binary_parameters=yes\"\n\t}\n\treturn conninfo\n}\n\nfunc openTestConnConninfo(conninfo string) (*sql.DB, error) {\n\treturn sql.Open(\"postgres\", testConninfo(conninfo))\n}\n\nfunc openTestConn(t Fatalistic) *sql.DB {\n\tconn, err := openTestConnConninfo(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn conn\n}\n\nfunc getServerVersion(t *testing.T, db *sql.DB) int {\n\tvar version int\n\terr := db.QueryRow(\"SHOW server_version_num\").Scan(&version)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn version\n}\n\nfunc TestReconnect(t *testing.T) {\n\tdb1 := openTestConn(t)\n\tdefer db1.Close()\n\ttx, err := db1.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar pid1 int\n\terr = tx.QueryRow(\"SELECT pg_backend_pid()\").Scan(&pid1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdb2 := openTestConn(t)\n\tdefer db2.Close()\n\t_, err = db2.Exec(\"SELECT pg_terminate_backend($1)\", pid1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// The rollback will probably \"fail\" because we just killed\n\t// its connection above\n\t_ = tx.Rollback()\n\n\tconst expected int = 42\n\tvar result int\n\terr = db1.QueryRow(fmt.Sprintf(\"SELECT %d\", expected)).Scan(&result)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif result != expected {\n\t\tt.Errorf(\"got %v; expected %v\", result, expected)\n\t}\n}\n\nfunc TestCommitInFailedTransaction(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttxn, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trows, err := txn.Query(\"SELECT error\")\n\tif err == nil {\n\t\trows.Close()\n\t\tt.Fatal(\"expected failure\")\n\t}\n\terr = txn.Commit()\n\tif err != ErrInFailedTransaction {\n\t\tt.Fatalf(\"expected ErrInFailedTransaction; got %#v\", err)\n\t}\n}\n\nfunc TestOpenURL(t *testing.T) {\n\ttestURL := func(url string) {\n\t\tdb, err := openTestConnConninfo(url)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer db.Close()\n\t\t// database/sql might not call our Open at all unless we do something with\n\t\t// the connection\n\t\ttxn, err := db.Begin()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\ttxn.Rollback()\n\t}\n\ttestURL(\"postgres://\")\n\ttestURL(\"postgresql://\")\n}\n\nconst pgpassFile = \"/tmp/pqgotest_pgpass\"\n\nfunc TestPgpass(t *testing.T) {\n\ttestAssert := func(conninfo string, expected string, reason string) {\n\t\tconn, err := openTestConnConninfo(conninfo)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer conn.Close()\n\n\t\ttxn, err := conn.Begin()\n\t\tif err != nil {\n\t\t\tif expected != \"fail\" {\n\t\t\t\tt.Fatalf(reason, err)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\trows, err := txn.Query(\"SELECT USER\")\n\t\tif err != nil {\n\t\t\ttxn.Rollback()\n\t\t\tif expected != \"fail\" {\n\t\t\t\tt.Fatalf(reason, err)\n\t\t\t}\n\t\t} else {\n\t\t\trows.Close()\n\t\t\tif expected != \"ok\" {\n\t\t\t\tt.Fatalf(reason, err)\n\t\t\t}\n\t\t}\n\t\ttxn.Rollback()\n\t}\n\ttestAssert(\"\", \"ok\", \"missing .pgpass, unexpected error %#v\")\n\tos.Setenv(\"PGPASSFILE\", pgpassFile)\n\tdefer os.Unsetenv(\"PGPASSFILE\")\n\ttestAssert(\"host=/tmp\", \"fail\", \", unexpected error %#v\")\n\tos.Unsetenv(\"PGPASSFILE\")\n\n\tos.Remove(pgpassFile)\n\tpgpass, err := os.OpenFile(pgpassFile, os.O_RDWR|os.O_CREATE, 0644)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error writing pgpass file %#v\", err)\n\t}\n\t_, err = pgpass.WriteString(`# comment\nserver:5432:some_db:some_user:pass_A\n*:5432:some_db:some_user:pass_B\nlocalhost:*:*:*:pass_C\n*:*:*:*:pass_fallback\n`)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error writing pgpass file %#v\", err)\n\t}\n\tdefer os.Remove(pgpassFile)\n\tpgpass.Close()\n\n\tassertPassword := func(extra values, expected string) {\n\t\to := values{\n\t\t\t\"host\":               \"localhost\",\n\t\t\t\"sslmode\":            \"disable\",\n\t\t\t\"connect_timeout\":    \"20\",\n\t\t\t\"user\":               \"majid\",\n\t\t\t\"port\":               \"5432\",\n\t\t\t\"extra_float_digits\": \"2\",\n\t\t\t\"dbname\":             \"pqgotest\",\n\t\t\t\"client_encoding\":    \"UTF8\",\n\t\t\t\"datestyle\":          \"ISO, MDY\",\n\t\t}\n\t\tfor k, v := range extra {\n\t\t\to[k] = v\n\t\t}\n\t\t(&conn{}).handlePgpass(o)\n\t\tif pw := o[\"password\"]; pw != expected {\n\t\t\tt.Fatalf(\"For %v expected %s got %s\", extra, expected, pw)\n\t\t}\n\t}\n\t// missing passfile means empty psasword\n\tassertPassword(values{\"host\": \"server\", \"dbname\": \"some_db\", \"user\": \"some_user\"}, \"\")\n\t// wrong permissions for the pgpass file means it should be ignored\n\tassertPassword(values{\"host\": \"example.com\", \"passfile\": pgpassFile, \"user\": \"foo\"}, \"\")\n\t// fix the permissions and check if it has taken effect\n\tos.Chmod(pgpassFile, 0600)\n\n\tassertPassword(values{\"host\": \"server\", \"passfile\": pgpassFile, \"dbname\": \"some_db\", \"user\": \"some_user\"}, \"pass_A\")\n\tassertPassword(values{\"host\": \"example.com\", \"passfile\": pgpassFile, \"user\": \"foo\"}, \"pass_fallback\")\n\tassertPassword(values{\"host\": \"example.com\", \"passfile\": pgpassFile, \"dbname\": \"some_db\", \"user\": \"some_user\"}, \"pass_B\")\n\t// localhost also matches the default \"\" and UNIX sockets\n\tassertPassword(values{\"host\": \"\", \"passfile\": pgpassFile, \"user\": \"some_user\"}, \"pass_C\")\n\tassertPassword(values{\"host\": \"/tmp\", \"passfile\": pgpassFile, \"user\": \"some_user\"}, \"pass_C\")\n\t// passfile connection parameter takes precedence\n\tos.Setenv(\"PGPASSFILE\", \"/tmp\")\n\tassertPassword(values{\"host\": \"server\", \"passfile\": pgpassFile, \"dbname\": \"some_db\", \"user\": \"some_user\"}, \"pass_A\")\n}\n\nfunc TestExec(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\t_, err := db.Exec(\"CREATE TEMP TABLE temp (a int)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tr, err := db.Exec(\"INSERT INTO temp VALUES (1)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif n, _ := r.RowsAffected(); n != 1 {\n\t\tt.Fatalf(\"expected 1 row affected, not %d\", n)\n\t}\n\n\tr, err = db.Exec(\"INSERT INTO temp VALUES ($1), ($2), ($3)\", 1, 2, 3)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif n, _ := r.RowsAffected(); n != 3 {\n\t\tt.Fatalf(\"expected 3 rows affected, not %d\", n)\n\t}\n\n\t// SELECT doesn't send the number of returned rows in the command tag\n\t// before 9.0\n\tif getServerVersion(t, db) >= 90000 {\n\t\tr, err = db.Exec(\"SELECT g FROM generate_series(1, 2) g\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif n, _ := r.RowsAffected(); n != 2 {\n\t\t\tt.Fatalf(\"expected 2 rows affected, not %d\", n)\n\t\t}\n\n\t\tr, err = db.Exec(\"SELECT g FROM generate_series(1, $1) g\", 3)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif n, _ := r.RowsAffected(); n != 3 {\n\t\t\tt.Fatalf(\"expected 3 rows affected, not %d\", n)\n\t\t}\n\t}\n}\n\nfunc TestStatment(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tst, err := db.Prepare(\"SELECT 1\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tst1, err := db.Prepare(\"SELECT 2\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tr, err := st.Query()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer r.Close()\n\n\tif !r.Next() {\n\t\tt.Fatal(\"expected row\")\n\t}\n\n\tvar i int\n\terr = r.Scan(&i)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif i != 1 {\n\t\tt.Fatalf(\"expected 1, got %d\", i)\n\t}\n\n\t// st1\n\n\tr1, err := st1.Query()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer r1.Close()\n\n\tif !r1.Next() {\n\t\tif r.Err() != nil {\n\t\t\tt.Fatal(r.Err())\n\t\t}\n\t\tt.Fatal(\"expected row\")\n\t}\n\n\terr = r1.Scan(&i)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif i != 2 {\n\t\tt.Fatalf(\"expected 2, got %d\", i)\n\t}\n}\n\nfunc TestRowsCloseBeforeDone(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tr, err := db.Query(\"SELECT 1\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = r.Close()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif r.Next() {\n\t\tt.Fatal(\"unexpected row\")\n\t}\n\n\tif r.Err() != nil {\n\t\tt.Fatal(r.Err())\n\t}\n}\n\nfunc TestParameterCountMismatch(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tvar notused int\n\terr := db.QueryRow(\"SELECT false\", 1).Scan(&notused)\n\tif err == nil {\n\t\tt.Fatal(\"expected err\")\n\t}\n\t// make sure we clean up correctly\n\terr = db.QueryRow(\"SELECT 1\").Scan(&notused)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = db.QueryRow(\"SELECT $1\").Scan(&notused)\n\tif err == nil {\n\t\tt.Fatal(\"expected err\")\n\t}\n\t// make sure we clean up correctly\n\terr = db.QueryRow(\"SELECT 1\").Scan(&notused)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Test that EmptyQueryResponses are handled correctly.\nfunc TestEmptyQuery(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tres, err := db.Exec(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := res.RowsAffected(); err != errNoRowsAffected {\n\t\tt.Fatalf(\"expected %s, got %v\", errNoRowsAffected, err)\n\t}\n\tif _, err := res.LastInsertId(); err != errNoLastInsertID {\n\t\tt.Fatalf(\"expected %s, got %v\", errNoLastInsertID, err)\n\t}\n\trows, err := db.Query(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcols, err := rows.Columns()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(cols) != 0 {\n\t\tt.Fatalf(\"unexpected number of columns %d in response to an empty query\", len(cols))\n\t}\n\tif rows.Next() {\n\t\tt.Fatal(\"unexpected row\")\n\t}\n\tif rows.Err() != nil {\n\t\tt.Fatal(rows.Err())\n\t}\n\n\tstmt, err := db.Prepare(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tres, err = stmt.Exec()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := res.RowsAffected(); err != errNoRowsAffected {\n\t\tt.Fatalf(\"expected %s, got %v\", errNoRowsAffected, err)\n\t}\n\tif _, err := res.LastInsertId(); err != errNoLastInsertID {\n\t\tt.Fatalf(\"expected %s, got %v\", errNoLastInsertID, err)\n\t}\n\trows, err = stmt.Query()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcols, err = rows.Columns()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(cols) != 0 {\n\t\tt.Fatalf(\"unexpected number of columns %d in response to an empty query\", len(cols))\n\t}\n\tif rows.Next() {\n\t\tt.Fatal(\"unexpected row\")\n\t}\n\tif rows.Err() != nil {\n\t\tt.Fatal(rows.Err())\n\t}\n}\n\n// Test that rows.Columns() is correct even if there are no result rows.\nfunc TestEmptyResultSetColumns(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\trows, err := db.Query(\"SELECT 1 AS a, text 'bar' AS bar WHERE FALSE\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcols, err := rows.Columns()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(cols) != 2 {\n\t\tt.Fatalf(\"unexpected number of columns %d in response to an empty query\", len(cols))\n\t}\n\tif rows.Next() {\n\t\tt.Fatal(\"unexpected row\")\n\t}\n\tif rows.Err() != nil {\n\t\tt.Fatal(rows.Err())\n\t}\n\tif cols[0] != \"a\" || cols[1] != \"bar\" {\n\t\tt.Fatalf(\"unexpected Columns result %v\", cols)\n\t}\n\n\tstmt, err := db.Prepare(\"SELECT $1::int AS a, text 'bar' AS bar WHERE FALSE\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trows, err = stmt.Query(1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcols, err = rows.Columns()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(cols) != 2 {\n\t\tt.Fatalf(\"unexpected number of columns %d in response to an empty query\", len(cols))\n\t}\n\tif rows.Next() {\n\t\tt.Fatal(\"unexpected row\")\n\t}\n\tif rows.Err() != nil {\n\t\tt.Fatal(rows.Err())\n\t}\n\tif cols[0] != \"a\" || cols[1] != \"bar\" {\n\t\tt.Fatalf(\"unexpected Columns result %v\", cols)\n\t}\n\n}\n\nfunc TestEncodeDecode(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tq := `\n\t\tSELECT\n\t\t\tE'\\\\000\\\\001\\\\002'::bytea,\n\t\t\t'foobar'::text,\n\t\t\tNULL::integer,\n\t\t\t'2000-1-1 01:02:03.04-7'::timestamptz,\n\t\t\t0::boolean,\n\t\t\t123,\n\t\t\t-321,\n\t\t\t3.14::float8\n\t\tWHERE\n\t\t\t    E'\\\\000\\\\001\\\\002'::bytea = $1\n\t\t\tAND 'foobar'::text = $2\n\t\t\tAND $3::integer is NULL\n\t`\n\t// AND '2000-1-1 12:00:00.000000-7'::timestamp = $3\n\n\texp1 := []byte{0, 1, 2}\n\texp2 := \"foobar\"\n\n\tr, err := db.Query(q, exp1, exp2, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer r.Close()\n\n\tif !r.Next() {\n\t\tif r.Err() != nil {\n\t\t\tt.Fatal(r.Err())\n\t\t}\n\t\tt.Fatal(\"expected row\")\n\t}\n\n\tvar got1 []byte\n\tvar got2 string\n\tvar got3 = sql.NullInt64{Valid: true}\n\tvar got4 time.Time\n\tvar got5, got6, got7, got8 interface{}\n\n\terr = r.Scan(&got1, &got2, &got3, &got4, &got5, &got6, &got7, &got8)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !reflect.DeepEqual(exp1, got1) {\n\t\tt.Errorf(\"expected %q byte: %q\", exp1, got1)\n\t}\n\n\tif !reflect.DeepEqual(exp2, got2) {\n\t\tt.Errorf(\"expected %q byte: %q\", exp2, got2)\n\t}\n\n\tif got3.Valid {\n\t\tt.Fatal(\"expected invalid\")\n\t}\n\n\tif got4.Year() != 2000 {\n\t\tt.Fatal(\"wrong year\")\n\t}\n\n\tif got5 != false {\n\t\tt.Fatalf(\"expected false, got %q\", got5)\n\t}\n\n\tif got6 != int64(123) {\n\t\tt.Fatalf(\"expected 123, got %d\", got6)\n\t}\n\n\tif got7 != int64(-321) {\n\t\tt.Fatalf(\"expected -321, got %d\", got7)\n\t}\n\n\tif got8 != float64(3.14) {\n\t\tt.Fatalf(\"expected 3.14, got %f\", got8)\n\t}\n}\n\nfunc TestNoData(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tst, err := db.Prepare(\"SELECT 1 WHERE true = false\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer st.Close()\n\n\tr, err := st.Query()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer r.Close()\n\n\tif r.Next() {\n\t\tif r.Err() != nil {\n\t\t\tt.Fatal(r.Err())\n\t\t}\n\t\tt.Fatal(\"unexpected row\")\n\t}\n\n\t_, err = db.Query(\"SELECT * FROM nonexistenttable WHERE age=$1\", 20)\n\tif err == nil {\n\t\tt.Fatal(\"Should have raised an error on non existent table\")\n\t}\n\n\t_, err = db.Query(\"SELECT * FROM nonexistenttable\")\n\tif err == nil {\n\t\tt.Fatal(\"Should have raised an error on non existent table\")\n\t}\n}\n\nfunc TestErrorDuringStartup(t *testing.T) {\n\t// Don't use the normal connection setup, this is intended to\n\t// blow up in the startup packet from a non-existent user.\n\tdb, err := openTestConnConninfo(\"user=thisuserreallydoesntexist\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t_, err = db.Begin()\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n\n\te, ok := err.(*Error)\n\tif !ok {\n\t\tt.Fatalf(\"expected Error, got %#v\", err)\n\t} else if e.Code.Name() != \"invalid_authorization_specification\" && e.Code.Name() != \"invalid_password\" {\n\t\tt.Fatalf(\"expected invalid_authorization_specification or invalid_password, got %s (%+v)\", e.Code.Name(), err)\n\t}\n}\n\ntype testConn struct {\n\tclosed bool\n\tnet.Conn\n}\n\nfunc (c *testConn) Close() error {\n\tc.closed = true\n\treturn c.Conn.Close()\n}\n\ntype testDialer struct {\n\tconns []*testConn\n}\n\nfunc (d *testDialer) Dial(ntw, addr string) (net.Conn, error) {\n\tc, err := net.Dial(ntw, addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttc := &testConn{Conn: c}\n\td.conns = append(d.conns, tc)\n\treturn tc, nil\n}\n\nfunc (d *testDialer) DialTimeout(ntw, addr string, timeout time.Duration) (net.Conn, error) {\n\tc, err := net.DialTimeout(ntw, addr, timeout)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttc := &testConn{Conn: c}\n\td.conns = append(d.conns, tc)\n\treturn tc, nil\n}\n\nfunc TestErrorDuringStartupClosesConn(t *testing.T) {\n\t// Don't use the normal connection setup, this is intended to\n\t// blow up in the startup packet from a non-existent user.\n\tvar d testDialer\n\tc, err := DialOpen(&d, testConninfo(\"user=thisuserreallydoesntexist\"))\n\tif err == nil {\n\t\tc.Close()\n\t\tt.Fatal(\"expected dial error\")\n\t}\n\tif len(d.conns) != 1 {\n\t\tt.Fatalf(\"got len(d.conns) = %d, want = %d\", len(d.conns), 1)\n\t}\n\tif !d.conns[0].closed {\n\t\tt.Error(\"connection leaked\")\n\t}\n}\n\nfunc TestBadConn(t *testing.T) {\n\tvar err error\n\n\tcn := conn{}\n\tfunc() {\n\t\tdefer cn.errRecover(&err)\n\t\tpanic(io.EOF)\n\t}()\n\tif err != driver.ErrBadConn {\n\t\tt.Fatalf(\"expected driver.ErrBadConn, got: %#v\", err)\n\t}\n\tif err := cn.err.get(); err != driver.ErrBadConn {\n\t\tt.Fatalf(\"expected driver.ErrBadConn, got %#v\", err)\n\t}\n\n\tcn = conn{}\n\tfunc() {\n\t\tdefer cn.errRecover(&err)\n\t\te := &Error{Severity: Efatal}\n\t\tpanic(e)\n\t}()\n\tif err != driver.ErrBadConn {\n\t\tt.Fatalf(\"expected driver.ErrBadConn, got: %#v\", err)\n\t}\n\tif err := cn.err.get(); err != driver.ErrBadConn {\n\t\tt.Fatalf(\"expected driver.ErrBadConn, got %#v\", err)\n\t}\n}\n\n// TestCloseBadConn tests that the underlying connection can be closed with\n// Close after an error.\nfunc TestCloseBadConn(t *testing.T) {\n\thost := os.Getenv(\"PGHOST\")\n\tif host == \"\" {\n\t\thost = \"localhost\"\n\t}\n\tport := os.Getenv(\"PGPORT\")\n\tif port == \"\" {\n\t\tport = \"5432\"\n\t}\n\tnc, err := net.Dial(\"tcp\", host+\":\"+port)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcn := conn{c: nc}\n\tfunc() {\n\t\tdefer cn.errRecover(&err)\n\t\tpanic(io.EOF)\n\t}()\n\t// Verify we can write before closing.\n\tif _, err := nc.Write(nil); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// First close should close the connection.\n\tif err := cn.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// During the Go 1.9 cycle, https://github.com/golang/go/commit/3792db5\n\t// changed this error from\n\t//\n\t// net.errClosing = errors.New(\"use of closed network connection\")\n\t//\n\t// to\n\t//\n\t// internal/poll.ErrClosing = errors.New(\"use of closed file or network connection\")\n\tconst errClosing = \"use of closed\"\n\n\t// Verify write after closing fails.\n\tif _, err := nc.Write(nil); err == nil {\n\t\tt.Fatal(\"expected error\")\n\t} else if !strings.Contains(err.Error(), errClosing) {\n\t\tt.Fatalf(\"expected %s error, got %s\", errClosing, err)\n\t}\n\t// Verify second close fails.\n\tif err := cn.Close(); err == nil {\n\t\tt.Fatal(\"expected error\")\n\t} else if !strings.Contains(err.Error(), errClosing) {\n\t\tt.Fatalf(\"expected %s error, got %s\", errClosing, err)\n\t}\n}\n\nfunc TestErrorOnExec(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttxn, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer txn.Rollback()\n\n\t_, err = txn.Exec(\"CREATE TEMPORARY TABLE foo(f1 int PRIMARY KEY)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = txn.Exec(\"INSERT INTO foo VALUES (0), (0)\")\n\tif err == nil {\n\t\tt.Fatal(\"Should have raised error\")\n\t}\n\n\te, ok := err.(*Error)\n\tif !ok {\n\t\tt.Fatalf(\"expected Error, got %#v\", err)\n\t} else if e.Code.Name() != \"unique_violation\" {\n\t\tt.Fatalf(\"expected unique_violation, got %s (%+v)\", e.Code.Name(), err)\n\t}\n}\n\nfunc TestErrorOnQuery(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttxn, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer txn.Rollback()\n\n\t_, err = txn.Exec(\"CREATE TEMPORARY TABLE foo(f1 int PRIMARY KEY)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = txn.Query(\"INSERT INTO foo VALUES (0), (0)\")\n\tif err == nil {\n\t\tt.Fatal(\"Should have raised error\")\n\t}\n\n\te, ok := err.(*Error)\n\tif !ok {\n\t\tt.Fatalf(\"expected Error, got %#v\", err)\n\t} else if e.Code.Name() != \"unique_violation\" {\n\t\tt.Fatalf(\"expected unique_violation, got %s (%+v)\", e.Code.Name(), err)\n\t}\n}\n\nfunc TestErrorOnQueryRowSimpleQuery(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttxn, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer txn.Rollback()\n\n\t_, err = txn.Exec(\"CREATE TEMPORARY TABLE foo(f1 int PRIMARY KEY)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar v int\n\terr = txn.QueryRow(\"INSERT INTO foo VALUES (0), (0)\").Scan(&v)\n\tif err == nil {\n\t\tt.Fatal(\"Should have raised error\")\n\t}\n\n\te, ok := err.(*Error)\n\tif !ok {\n\t\tt.Fatalf(\"expected Error, got %#v\", err)\n\t} else if e.Code.Name() != \"unique_violation\" {\n\t\tt.Fatalf(\"expected unique_violation, got %s (%+v)\", e.Code.Name(), err)\n\t}\n}\n\n// Test the QueryRow bug workarounds in stmt.exec() and simpleQuery()\nfunc TestQueryRowBugWorkaround(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\t// stmt.exec()\n\t_, err := db.Exec(\"CREATE TEMP TABLE notnulltemp (a varchar(10) not null)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar a string\n\terr = db.QueryRow(\"INSERT INTO notnulltemp(a) values($1) RETURNING a\", nil).Scan(&a)\n\tif err == sql.ErrNoRows {\n\t\tt.Fatalf(\"expected constraint violation error; got: %v\", err)\n\t}\n\tpge, ok := err.(*Error)\n\tif !ok {\n\t\tt.Fatalf(\"expected *Error; got: %#v\", err)\n\t}\n\tif pge.Code.Name() != \"not_null_violation\" {\n\t\tt.Fatalf(\"expected not_null_violation; got: %s (%+v)\", pge.Code.Name(), err)\n\t}\n\n\t// Test workaround in simpleQuery()\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error %s in Begin\", err)\n\t}\n\tdefer tx.Rollback()\n\n\t_, err = tx.Exec(\"SET LOCAL check_function_bodies TO FALSE\")\n\tif err != nil {\n\t\tt.Fatalf(\"could not disable check_function_bodies: %s\", err)\n\t}\n\t_, err = tx.Exec(`\nCREATE OR REPLACE FUNCTION bad_function()\nRETURNS integer\n-- hack to prevent the function from being inlined\nSET check_function_bodies TO TRUE\nAS $$\n\tSELECT text 'bad'\n$$ LANGUAGE sql`)\n\tif err != nil {\n\t\tt.Fatalf(\"could not create function: %s\", err)\n\t}\n\n\terr = tx.QueryRow(\"SELECT * FROM bad_function()\").Scan(&a)\n\tif err == nil {\n\t\tt.Fatalf(\"expected error\")\n\t}\n\tpge, ok = err.(*Error)\n\tif !ok {\n\t\tt.Fatalf(\"expected *Error; got: %#v\", err)\n\t}\n\tif pge.Code.Name() != \"invalid_function_definition\" {\n\t\tt.Fatalf(\"expected invalid_function_definition; got: %s (%+v)\", pge.Code.Name(), err)\n\t}\n\n\terr = tx.Rollback()\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error %s in Rollback\", err)\n\t}\n\n\t// Also test that simpleQuery()'s workaround works when the query fails\n\t// after a row has been received.\n\trows, err := db.Query(`\nselect\n\t(select generate_series(1, ss.i))\nfrom (select gs.i\n      from generate_series(1, 2) gs(i)\n      order by gs.i limit 2) ss`)\n\tif err != nil {\n\t\tt.Fatalf(\"query failed: %s\", err)\n\t}\n\tif !rows.Next() {\n\t\tt.Fatalf(\"expected at least one result row; got %s\", rows.Err())\n\t}\n\tvar i int\n\terr = rows.Scan(&i)\n\tif err != nil {\n\t\tt.Fatalf(\"rows.Scan() failed: %s\", err)\n\t}\n\tif i != 1 {\n\t\tt.Fatalf(\"unexpected value for i: %d\", i)\n\t}\n\tif rows.Next() {\n\t\tt.Fatalf(\"unexpected row\")\n\t}\n\tpge, ok = rows.Err().(*Error)\n\tif !ok {\n\t\tt.Fatalf(\"expected *Error; got: %#v\", err)\n\t}\n\tif pge.Code.Name() != \"cardinality_violation\" {\n\t\tt.Fatalf(\"expected cardinality_violation; got: %s (%+v)\", pge.Code.Name(), rows.Err())\n\t}\n}\n\nfunc TestSimpleQuery(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tr, err := db.Query(\"select 1\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer r.Close()\n\n\tif !r.Next() {\n\t\tt.Fatal(\"expected row\")\n\t}\n}\n\nfunc TestBindError(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\t_, err := db.Exec(\"create temp table test (i integer)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = db.Query(\"select * from test where i=$1\", \"hhh\")\n\tif err == nil {\n\t\tt.Fatal(\"expected an error\")\n\t}\n\n\t// Should not get error here\n\tr, err := db.Query(\"select * from test where i=$1\", 1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer r.Close()\n}\n\nfunc TestParseErrorInExtendedQuery(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\t_, err := db.Query(\"PARSE_ERROR $1\", 1)\n\tpqErr, _ := err.(*Error)\n\t// Expecting a syntax error.\n\tif err == nil || pqErr == nil || pqErr.Code != \"42601\" {\n\t\tt.Fatalf(\"expected syntax error, got %s\", err)\n\t}\n\n\trows, err := db.Query(\"SELECT 1\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trows.Close()\n}\n\n// TestReturning tests that an INSERT query using the RETURNING clause returns a row.\nfunc TestReturning(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\t_, err := db.Exec(\"CREATE TEMP TABLE distributors (did integer default 0, dname text)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trows, err := db.Query(\"INSERT INTO distributors (did, dname) VALUES (DEFAULT, 'XYZ Widgets') \" +\n\t\t\"RETURNING did;\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !rows.Next() {\n\t\tt.Fatal(\"no rows\")\n\t}\n\tvar did int\n\terr = rows.Scan(&did)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif did != 0 {\n\t\tt.Fatalf(\"bad value for did: got %d, want %d\", did, 0)\n\t}\n\n\tif rows.Next() {\n\t\tt.Fatal(\"unexpected next row\")\n\t}\n\terr = rows.Err()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestIssue186(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\t// Exec() a query which returns results\n\t_, err := db.Exec(\"VALUES (1), (2), (3)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = db.Exec(\"VALUES ($1), ($2), ($3)\", 1, 2, 3)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Query() a query which doesn't return any results\n\ttxn, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer txn.Rollback()\n\n\trows, err := txn.Query(\"CREATE TEMP TABLE foo(f1 int)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = rows.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// small trick to get NoData from a parameterized query\n\t_, err = txn.Exec(\"CREATE RULE nodata AS ON INSERT TO foo DO INSTEAD NOTHING\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trows, err = txn.Query(\"INSERT INTO foo VALUES ($1)\", 1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err = rows.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestIssue196(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\trow := db.QueryRow(\"SELECT float4 '0.10000122' = $1, float8 '35.03554004971999' = $2\",\n\t\tfloat32(0.10000122), float64(35.03554004971999))\n\n\tvar float4match, float8match bool\n\terr := row.Scan(&float4match, &float8match)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !float4match {\n\t\tt.Errorf(\"Expected float4 fidelity to be maintained; got no match\")\n\t}\n\tif !float8match {\n\t\tt.Errorf(\"Expected float8 fidelity to be maintained; got no match\")\n\t}\n}\n\n// Test that any CommandComplete messages sent before the query results are\n// ignored.\nfunc TestIssue282(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tvar searchPath string\n\terr := db.QueryRow(`\n\t\tSET LOCAL search_path TO pg_catalog;\n\t\tSET LOCAL search_path TO pg_catalog;\n\t\tSHOW search_path`).Scan(&searchPath)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif searchPath != \"pg_catalog\" {\n\t\tt.Fatalf(\"unexpected search_path %s\", searchPath)\n\t}\n}\n\nfunc TestReadFloatPrecision(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\trow := db.QueryRow(\"SELECT float4 '0.10000122', float8 '35.03554004971999', float4 '1.2'\")\n\tvar float4val float32\n\tvar float8val float64\n\tvar float4val2 float64\n\terr := row.Scan(&float4val, &float8val, &float4val2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif float4val != float32(0.10000122) {\n\t\tt.Errorf(\"Expected float4 fidelity to be maintained; got no match\")\n\t}\n\tif float8val != float64(35.03554004971999) {\n\t\tt.Errorf(\"Expected float8 fidelity to be maintained; got no match\")\n\t}\n\tif float4val2 != float64(1.2) {\n\t\tt.Errorf(\"Expected float4 fidelity into a float64 to be maintained; got no match\")\n\t}\n}\n\nfunc TestXactMultiStmt(t *testing.T) {\n\t// minified test case based on bug reports from\n\t// pico303@gmail.com and rangelspam@gmail.com\n\tt.Skip(\"Skipping failing test\")\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer tx.Commit()\n\n\trows, err := tx.Query(\"select 1\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif rows.Next() {\n\t\tvar val int32\n\t\tif err = rows.Scan(&val); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t} else {\n\t\tt.Fatal(\"Expected at least one row in first query in xact\")\n\t}\n\n\trows2, err := tx.Query(\"select 2\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif rows2.Next() {\n\t\tvar val2 int32\n\t\tif err := rows2.Scan(&val2); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t} else {\n\t\tt.Fatal(\"Expected at least one row in second query in xact\")\n\t}\n\n\tif err = rows.Err(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err = rows2.Err(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err = tx.Commit(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nvar envParseTests = []struct {\n\tExpected map[string]string\n\tEnv      []string\n}{\n\t{\n\t\tEnv:      []string{\"PGDATABASE=hello\", \"PGUSER=goodbye\"},\n\t\tExpected: map[string]string{\"dbname\": \"hello\", \"user\": \"goodbye\"},\n\t},\n\t{\n\t\tEnv:      []string{\"PGDATESTYLE=ISO, MDY\"},\n\t\tExpected: map[string]string{\"datestyle\": \"ISO, MDY\"},\n\t},\n\t{\n\t\tEnv:      []string{\"PGCONNECT_TIMEOUT=30\"},\n\t\tExpected: map[string]string{\"connect_timeout\": \"30\"},\n\t},\n}\n\nfunc TestParseEnviron(t *testing.T) {\n\tfor i, tt := range envParseTests {\n\t\tresults := parseEnviron(tt.Env)\n\t\tif !reflect.DeepEqual(tt.Expected, results) {\n\t\t\tt.Errorf(\"%d: Expected: %#v Got: %#v\", i, tt.Expected, results)\n\t\t}\n\t}\n}\n\nfunc TestParseComplete(t *testing.T) {\n\ttpc := func(commandTag string, command string, affectedRows int64, shouldFail bool) {\n\t\tdefer func() {\n\t\t\tif p := recover(); p != nil {\n\t\t\t\tif !shouldFail {\n\t\t\t\t\tt.Error(p)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tcn := &conn{}\n\t\tres, c := cn.parseComplete(commandTag)\n\t\tif c != command {\n\t\t\tt.Errorf(\"Expected %v, got %v\", command, c)\n\t\t}\n\t\tn, err := res.RowsAffected()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif n != affectedRows {\n\t\t\tt.Errorf(\"Expected %d, got %d\", affectedRows, n)\n\t\t}\n\t}\n\n\ttpc(\"ALTER TABLE\", \"ALTER TABLE\", 0, false)\n\ttpc(\"INSERT 0 1\", \"INSERT\", 1, false)\n\ttpc(\"UPDATE 100\", \"UPDATE\", 100, false)\n\ttpc(\"SELECT 100\", \"SELECT\", 100, false)\n\ttpc(\"FETCH 100\", \"FETCH\", 100, false)\n\t// allow COPY (and others) without row count\n\ttpc(\"COPY\", \"COPY\", 0, false)\n\t// don't fail on command tags we don't recognize\n\ttpc(\"UNKNOWNCOMMANDTAG\", \"UNKNOWNCOMMANDTAG\", 0, false)\n\n\t// failure cases\n\ttpc(\"INSERT 1\", \"\", 0, true)   // missing oid\n\ttpc(\"UPDATE 0 1\", \"\", 0, true) // too many numbers\n\ttpc(\"SELECT foo\", \"\", 0, true) // invalid row count\n}\n\n// Test interface conformance.\nvar (\n\t_ driver.ExecerContext  = (*conn)(nil)\n\t_ driver.QueryerContext = (*conn)(nil)\n)\n\nfunc TestNullAfterNonNull(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tr, err := db.Query(\"SELECT 9::integer UNION SELECT NULL::integer\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar n sql.NullInt64\n\n\tif !r.Next() {\n\t\tif r.Err() != nil {\n\t\t\tt.Fatal(r.Err())\n\t\t}\n\t\tt.Fatal(\"expected row\")\n\t}\n\n\tif err := r.Scan(&n); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif n.Int64 != 9 {\n\t\tt.Fatalf(\"expected 2, not %d\", n.Int64)\n\t}\n\n\tif !r.Next() {\n\t\tif r.Err() != nil {\n\t\t\tt.Fatal(r.Err())\n\t\t}\n\t\tt.Fatal(\"expected row\")\n\t}\n\n\tif err := r.Scan(&n); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif n.Valid {\n\t\tt.Fatal(\"expected n to be invalid\")\n\t}\n\n\tif n.Int64 != 0 {\n\t\tt.Fatalf(\"expected n to 2, not %d\", n.Int64)\n\t}\n}\n\nfunc Test64BitErrorChecking(t *testing.T) {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tt.Fatal(\"panic due to 0xFFFFFFFF != -1 \" +\n\t\t\t\t\"when int is 64 bits\")\n\t\t}\n\t}()\n\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tr, err := db.Query(`SELECT *\nFROM (VALUES (0::integer, NULL::text), (1, 'test string')) AS t;`)\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdefer r.Close()\n\n\tfor r.Next() {\n\t}\n}\n\nfunc TestCommit(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\t_, err := db.Exec(\"CREATE TEMP TABLE temp (a int)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsqlInsert := \"INSERT INTO temp VALUES (1)\"\n\tsqlSelect := \"SELECT * FROM temp\"\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t_, err = tx.Exec(sqlInsert)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = tx.Commit()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar i int\n\terr = db.QueryRow(sqlSelect).Scan(&i)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif i != 1 {\n\t\tt.Fatalf(\"expected 1, got %d\", i)\n\t}\n}\n\nfunc TestErrorClass(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\t_, err := db.Query(\"SELECT int 'notint'\")\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n\tpge, ok := err.(*Error)\n\tif !ok {\n\t\tt.Fatalf(\"expected *pq.Error, got %#+v\", err)\n\t}\n\tif pge.Code.Class() != \"22\" {\n\t\tt.Fatalf(\"expected class 28, got %v\", pge.Code.Class())\n\t}\n\tif pge.Code.Class().Name() != \"data_exception\" {\n\t\tt.Fatalf(\"expected data_exception, got %v\", pge.Code.Class().Name())\n\t}\n}\n\nfunc TestParseOpts(t *testing.T) {\n\ttests := []struct {\n\t\tin       string\n\t\texpected values\n\t\tvalid    bool\n\t}{\n\t\t{\"dbname=hello user=goodbye\", values{\"dbname\": \"hello\", \"user\": \"goodbye\"}, true},\n\t\t{\"dbname=hello user=goodbye  \", values{\"dbname\": \"hello\", \"user\": \"goodbye\"}, true},\n\t\t{\"dbname = hello user=goodbye\", values{\"dbname\": \"hello\", \"user\": \"goodbye\"}, true},\n\t\t{\"dbname=hello user =goodbye\", values{\"dbname\": \"hello\", \"user\": \"goodbye\"}, true},\n\t\t{\"dbname=hello user= goodbye\", values{\"dbname\": \"hello\", \"user\": \"goodbye\"}, true},\n\t\t{\"host=localhost password='correct horse battery staple'\", values{\"host\": \"localhost\", \"password\": \"correct horse battery staple\"}, true},\n\t\t{\"dbname= password=\", values{\"dbname\": \"\", \"password\": \"\"}, true},\n\t\t{\"dbname=hello user=''\", values{\"dbname\": \"hello\", \"user\": \"\"}, true},\n\t\t{\"user='' dbname=hello\", values{\"dbname\": \"hello\", \"user\": \"\"}, true},\n\t\t// The last option value is an empty string if there's no non-whitespace after its =\n\t\t{\"dbname=hello user=   \", values{\"dbname\": \"hello\", \"user\": \"\"}, true},\n\n\t\t// The parser ignores spaces after = and interprets the next set of non-whitespace characters as the value.\n\t\t{\"user= password=foo\", values{\"user\": \"password=foo\"}, true},\n\n\t\t// Backslash escapes next char\n\t\t{`user=a\\ \\'\\\\b`, values{\"user\": `a '\\b`}, true},\n\t\t{`user='a \\'b'`, values{\"user\": `a 'b`}, true},\n\n\t\t// Incomplete escape\n\t\t{`user=x\\`, values{}, false},\n\n\t\t// No '=' after the key\n\t\t{\"postgre://marko@internet\", values{}, false},\n\t\t{\"dbname user=goodbye\", values{}, false},\n\t\t{\"user=foo blah\", values{}, false},\n\t\t{\"user=foo blah   \", values{}, false},\n\n\t\t// Unterminated quoted value\n\t\t{\"dbname=hello user='unterminated\", values{}, false},\n\t}\n\n\tfor _, test := range tests {\n\t\to := make(values)\n\t\terr := parseOpts(test.in, o)\n\n\t\tswitch {\n\t\tcase err != nil && test.valid:\n\t\t\tt.Errorf(\"%q got unexpected error: %s\", test.in, err)\n\t\tcase err == nil && test.valid && !reflect.DeepEqual(test.expected, o):\n\t\t\tt.Errorf(\"%q got: %#v want: %#v\", test.in, o, test.expected)\n\t\tcase err == nil && !test.valid:\n\t\t\tt.Errorf(\"%q expected an error\", test.in)\n\t\t}\n\t}\n}\n\nfunc TestRuntimeParameters(t *testing.T) {\n\ttests := []struct {\n\t\tconninfo string\n\t\tparam    string\n\t\texpected string\n\t\tsuccess  bool\n\t}{\n\t\t// invalid parameter\n\t\t{\"DOESNOTEXIST=foo\", \"\", \"\", false},\n\t\t// we can only work with a specific value for these two\n\t\t{\"client_encoding=SQL_ASCII\", \"\", \"\", false},\n\t\t{\"datestyle='ISO, YDM'\", \"\", \"\", false},\n\t\t// \"options\" should work exactly as it does in libpq\n\t\t{\"options='-c search_path=pqgotest'\", \"search_path\", \"pqgotest\", true},\n\t\t// pq should override client_encoding in this case\n\t\t{\"options='-c client_encoding=SQL_ASCII'\", \"client_encoding\", \"UTF8\", true},\n\t\t// allow client_encoding to be set explicitly\n\t\t{\"client_encoding=UTF8\", \"client_encoding\", \"UTF8\", true},\n\t\t// test a runtime parameter not supported by libpq\n\t\t{\"work_mem='139kB'\", \"work_mem\", \"139kB\", true},\n\t\t// test fallback_application_name\n\t\t{\"application_name=foo fallback_application_name=bar\", \"application_name\", \"foo\", true},\n\t\t{\"application_name='' fallback_application_name=bar\", \"application_name\", \"\", true},\n\t\t{\"fallback_application_name=bar\", \"application_name\", \"bar\", true},\n\t}\n\n\tfor _, test := range tests {\n\t\tdb, err := openTestConnConninfo(test.conninfo)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// application_name didn't exist before 9.0\n\t\tif test.param == \"application_name\" && getServerVersion(t, db) < 90000 {\n\t\t\tdb.Close()\n\t\t\tcontinue\n\t\t}\n\n\t\ttryGetParameterValue := func() (value string, success bool) {\n\t\t\tdefer db.Close()\n\t\t\trow := db.QueryRow(\"SELECT current_setting($1)\", test.param)\n\t\t\terr = row.Scan(&value)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", false\n\t\t\t}\n\t\t\treturn value, true\n\t\t}\n\n\t\tvalue, success := tryGetParameterValue()\n\t\tif success != test.success && !success {\n\t\t\tt.Fatalf(\"%v: unexpected error: %v\", test.conninfo, err)\n\t\t}\n\t\tif success != test.success {\n\t\t\tt.Fatalf(\"unexpected outcome %v (was expecting %v) for conninfo \\\"%s\\\"\",\n\t\t\t\tsuccess, test.success, test.conninfo)\n\t\t}\n\t\tif value != test.expected {\n\t\t\tt.Fatalf(\"bad value for %s: got %s, want %s with conninfo \\\"%s\\\"\",\n\t\t\t\ttest.param, value, test.expected, test.conninfo)\n\t\t}\n\t}\n}\n\nfunc TestIsUTF8(t *testing.T) {\n\tvar cases = []struct {\n\t\tname string\n\t\twant bool\n\t}{\n\t\t{\"unicode\", true},\n\t\t{\"utf-8\", true},\n\t\t{\"utf_8\", true},\n\t\t{\"UTF-8\", true},\n\t\t{\"UTF8\", true},\n\t\t{\"utf8\", true},\n\t\t{\"u n ic_ode\", true},\n\t\t{\"ut_f%8\", true},\n\t\t{\"ubf8\", false},\n\t\t{\"punycode\", false},\n\t}\n\n\tfor _, test := range cases {\n\t\tif g := isUTF8(test.name); g != test.want {\n\t\t\tt.Errorf(\"isUTF8(%q) = %v want %v\", test.name, g, test.want)\n\t\t}\n\t}\n}\n\nfunc TestQuoteIdentifier(t *testing.T) {\n\tvar cases = []struct {\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{`foo`, `\"foo\"`},\n\t\t{`foo bar baz`, `\"foo bar baz\"`},\n\t\t{`foo\"bar`, `\"foo\"\"bar\"`},\n\t\t{\"foo\\x00bar\", `\"foo\"`},\n\t\t{\"\\x00foo\", `\"\"`},\n\t}\n\n\tfor _, test := range cases {\n\t\tgot := QuoteIdentifier(test.input)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"QuoteIdentifier(%q) = %v want %v\", test.input, got, test.want)\n\t\t}\n\t}\n}\n\nfunc TestQuoteLiteral(t *testing.T) {\n\tvar cases = []struct {\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{`foo`, `'foo'`},\n\t\t{`foo bar baz`, `'foo bar baz'`},\n\t\t{`foo'bar`, `'foo''bar'`},\n\t\t{`foo\\bar`, ` E'foo\\\\bar'`},\n\t\t{`foo\\ba'r`, ` E'foo\\\\ba''r'`},\n\t\t{`foo\"bar`, `'foo\"bar'`},\n\t\t{`foo\\x00bar`, ` E'foo\\\\x00bar'`},\n\t\t{`\\x00foo`, ` E'\\\\x00foo'`},\n\t\t{`'`, `''''`},\n\t\t{`''`, `''''''`},\n\t\t{`\\`, ` E'\\\\'`},\n\t\t{`'abc'; DROP TABLE users;`, `'''abc''; DROP TABLE users;'`},\n\t\t{`\\'`, ` E'\\\\'''`},\n\t\t{`E'\\''`, ` E'E''\\\\'''''`},\n\t\t{`e'\\''`, ` E'e''\\\\'''''`},\n\t\t{`E'\\'abc\\'; DROP TABLE users;'`, ` E'E''\\\\''abc\\\\''; DROP TABLE users;'''`},\n\t\t{`e'\\'abc\\'; DROP TABLE users;'`, ` E'e''\\\\''abc\\\\''; DROP TABLE users;'''`},\n\t}\n\n\tfor _, test := range cases {\n\t\tgot := QuoteLiteral(test.input)\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"QuoteLiteral(%q) = %v want %v\", test.input, got, test.want)\n\t\t}\n\t}\n}\n\nfunc TestRowsResultTag(t *testing.T) {\n\ttype ResultTag interface {\n\t\tResult() driver.Result\n\t\tTag() string\n\t}\n\n\ttests := []struct {\n\t\tquery string\n\t\ttag   string\n\t\tra    int64\n\t}{\n\t\t{\n\t\t\tquery: \"CREATE TEMP TABLE temp (a int)\",\n\t\t\ttag:   \"CREATE TABLE\",\n\t\t},\n\t\t{\n\t\t\tquery: \"INSERT INTO temp VALUES (1), (2)\",\n\t\t\ttag:   \"INSERT\",\n\t\t\tra:    2,\n\t\t},\n\t\t{\n\t\t\tquery: \"SELECT 1\",\n\t\t},\n\t\t// A SELECT anywhere should take precedent.\n\t\t{\n\t\t\tquery: \"SELECT 1; INSERT INTO temp VALUES (1), (2)\",\n\t\t},\n\t\t{\n\t\t\tquery: \"INSERT INTO temp VALUES (1), (2); SELECT 1\",\n\t\t},\n\t\t// Multiple statements that don't return rows should return the last tag.\n\t\t{\n\t\t\tquery: \"CREATE TEMP TABLE t (a int); DROP TABLE t\",\n\t\t\ttag:   \"DROP TABLE\",\n\t\t},\n\t\t// Ensure a rows-returning query in any position among various tags-returing\n\t\t// statements will prefer the rows.\n\t\t{\n\t\t\tquery: \"SELECT 1; CREATE TEMP TABLE t (a int); DROP TABLE t\",\n\t\t},\n\t\t{\n\t\t\tquery: \"CREATE TEMP TABLE t (a int); SELECT 1; DROP TABLE t\",\n\t\t},\n\t\t{\n\t\t\tquery: \"CREATE TEMP TABLE t (a int); DROP TABLE t; SELECT 1\",\n\t\t},\n\t}\n\n\t// If this is the only test run, this will correct the connection string.\n\topenTestConn(t).Close()\n\n\tconn, err := Open(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer conn.Close()\n\tq := conn.(driver.QueryerContext)\n\n\tfor _, test := range tests {\n\t\tif rows, err := q.QueryContext(context.Background(), test.query, nil); err != nil {\n\t\t\tt.Fatalf(\"%s: %s\", test.query, err)\n\t\t} else {\n\t\t\tr := rows.(ResultTag)\n\t\t\tif tag := r.Tag(); tag != test.tag {\n\t\t\t\tt.Fatalf(\"%s: unexpected tag %q\", test.query, tag)\n\t\t\t}\n\t\t\tres := r.Result()\n\t\t\tif ra, _ := res.RowsAffected(); ra != test.ra {\n\t\t\t\tt.Fatalf(\"%s: unexpected rows affected: %d\", test.query, ra)\n\t\t\t}\n\t\t\trows.Close()\n\t\t}\n\t}\n}\n\n// TestQuickClose tests that closing a query early allows a subsequent query to work.\nfunc TestQuickClose(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trows, err := tx.Query(\"SELECT 1; SELECT 2;\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := rows.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar id int\n\tif err := tx.QueryRow(\"SELECT 3\").Scan(&id); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif id != 3 {\n\t\tt.Fatalf(\"unexpected %d\", id)\n\t}\n\tif err := tx.Commit(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestMultipleResult(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\trows, err := db.Query(`\n\t\tbegin;\n\t\t\tselect * from information_schema.tables limit 1;\n\t\t\tselect * from information_schema.columns limit 2;\n\t\tcommit;\n\t`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttype set struct {\n\t\tcols     []string\n\t\trowCount int\n\t}\n\tbuf := []*set{}\n\tfor {\n\t\tcols, err := rows.Columns()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\ts := &set{\n\t\t\tcols: cols,\n\t\t}\n\t\tbuf = append(buf, s)\n\n\t\tfor rows.Next() {\n\t\t\ts.rowCount++\n\t\t}\n\t\tif !rows.NextResultSet() {\n\t\t\tbreak\n\t\t}\n\t}\n\tif len(buf) != 2 {\n\t\tt.Fatalf(\"got %d sets, expected 2\", len(buf))\n\t}\n\tif len(buf[0].cols) == len(buf[1].cols) || len(buf[1].cols) == 0 {\n\t\tt.Fatal(\"invalid cols size, expected different column count and greater then zero\")\n\t}\n\tif buf[0].rowCount != 1 || buf[1].rowCount != 2 {\n\t\tt.Fatal(\"incorrect number of rows returned\")\n\t}\n}\n\nfunc TestMultipleEmptyResult(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\trows, err := db.Query(\"select 1 where false; select 2\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tt.Fatal(\"unexpected row\")\n\t}\n\tif !rows.NextResultSet() {\n\t\tt.Fatal(\"expected more result sets\", rows.Err())\n\t}\n\tfor rows.Next() {\n\t\tvar i int\n\t\tif err := rows.Scan(&i); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif i != 2 {\n\t\t\tt.Fatalf(\"expected 2, got %d\", i)\n\t\t}\n\t}\n\tif rows.NextResultSet() {\n\t\tt.Fatal(\"unexpected result set\")\n\t}\n}\n\nfunc TestCopyInStmtAffectedRows(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\t_, err := db.Exec(\"CREATE TEMP TABLE temp (a int)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttxn, err := db.BeginTx(context.TODO(), nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcopyStmt, err := txn.Prepare(CopyIn(\"temp\", \"a\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tres, err := copyStmt.Exec()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tres.RowsAffected()\n\tres.LastInsertId()\n}\n\nfunc TestConnPrepareContext(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttests := []struct {\n\t\tname string\n\t\tctx  func() (context.Context, context.CancelFunc)\n\t\tsql  string\n\t\terr  error\n\t}{\n\t\t{\n\t\t\tname: \"context.Background\",\n\t\t\tctx: func() (context.Context, context.CancelFunc) {\n\t\t\t\treturn context.Background(), nil\n\t\t\t},\n\t\t\tsql: \"SELECT 1\",\n\t\t\terr: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"context.WithTimeout exceeded\",\n\t\t\tctx: func() (context.Context, context.CancelFunc) {\n\t\t\t\treturn context.WithTimeout(context.Background(), -time.Minute)\n\t\t\t},\n\t\t\tsql: \"SELECT 1\",\n\t\t\terr: context.DeadlineExceeded,\n\t\t},\n\t\t{\n\t\t\tname: \"context.WithTimeout\",\n\t\t\tctx: func() (context.Context, context.CancelFunc) {\n\t\t\t\treturn context.WithTimeout(context.Background(), time.Minute)\n\t\t\t},\n\t\t\tsql: \"SELECT 1\",\n\t\t\terr: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctx, cancel := tt.ctx()\n\t\t\tif cancel != nil {\n\t\t\t\tdefer cancel()\n\t\t\t}\n\t\t\t_, err := db.PrepareContext(ctx, tt.sql)\n\t\t\tswitch {\n\t\t\tcase (err != nil) != (tt.err != nil):\n\t\t\t\tt.Fatalf(\"conn.PrepareContext() unexpected nil err got = %v, expected = %v\", err, tt.err)\n\t\t\tcase (err != nil && tt.err != nil) && (err.Error() != tt.err.Error()):\n\t\t\t\tt.Errorf(\"conn.PrepareContext() got = %v, expected = %v\", err.Error(), tt.err.Error())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestStmtQueryContext(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttests := []struct {\n\t\tname           string\n\t\tctx            func() (context.Context, context.CancelFunc)\n\t\tsql            string\n\t\tcancelExpected bool\n\t}{\n\t\t{\n\t\t\tname: \"context.Background\",\n\t\t\tctx: func() (context.Context, context.CancelFunc) {\n\t\t\t\treturn context.Background(), nil\n\t\t\t},\n\t\t\tsql:            \"SELECT pg_sleep(1);\",\n\t\t\tcancelExpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"context.WithTimeout exceeded\",\n\t\t\tctx: func() (context.Context, context.CancelFunc) {\n\t\t\t\treturn context.WithTimeout(context.Background(), 1*time.Second)\n\t\t\t},\n\t\t\tsql:            \"SELECT pg_sleep(10);\",\n\t\t\tcancelExpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"context.WithTimeout\",\n\t\t\tctx: func() (context.Context, context.CancelFunc) {\n\t\t\t\treturn context.WithTimeout(context.Background(), time.Minute)\n\t\t\t},\n\t\t\tsql:            \"SELECT pg_sleep(1);\",\n\t\t\tcancelExpected: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctx, cancel := tt.ctx()\n\t\t\tif cancel != nil {\n\t\t\t\tdefer cancel()\n\t\t\t}\n\t\t\tstmt, err := db.PrepareContext(ctx, tt.sql)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\t_, err = stmt.QueryContext(ctx)\n\t\t\tpgErr := (*Error)(nil)\n\t\t\tswitch {\n\t\t\tcase (err != nil) != tt.cancelExpected:\n\t\t\t\tt.Fatalf(\"stmt.QueryContext() unexpected nil err got = %v, cancelExpected = %v\", err, tt.cancelExpected)\n\t\t\tcase (err != nil && tt.cancelExpected) && !(errors.As(err, &pgErr) && pgErr.Code == cancelErrorCode):\n\t\t\t\tt.Errorf(\"stmt.QueryContext() got = %v, cancelExpected = %v\", err.Error(), tt.cancelExpected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestStmtExecContext(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttests := []struct {\n\t\tname           string\n\t\tctx            func() (context.Context, context.CancelFunc)\n\t\tsql            string\n\t\tcancelExpected bool\n\t}{\n\t\t{\n\t\t\tname: \"context.Background\",\n\t\t\tctx: func() (context.Context, context.CancelFunc) {\n\t\t\t\treturn context.Background(), nil\n\t\t\t},\n\t\t\tsql:            \"SELECT pg_sleep(1);\",\n\t\t\tcancelExpected: false,\n\t\t},\n\t\t{\n\t\t\tname: \"context.WithTimeout exceeded\",\n\t\t\tctx: func() (context.Context, context.CancelFunc) {\n\t\t\t\treturn context.WithTimeout(context.Background(), 1*time.Second)\n\t\t\t},\n\t\t\tsql:            \"SELECT pg_sleep(10);\",\n\t\t\tcancelExpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"context.WithTimeout\",\n\t\t\tctx: func() (context.Context, context.CancelFunc) {\n\t\t\t\treturn context.WithTimeout(context.Background(), time.Minute)\n\t\t\t},\n\t\t\tsql:            \"SELECT pg_sleep(1);\",\n\t\t\tcancelExpected: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctx, cancel := tt.ctx()\n\t\t\tif cancel != nil {\n\t\t\t\tdefer cancel()\n\t\t\t}\n\t\t\tstmt, err := db.PrepareContext(ctx, tt.sql)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\t_, err = stmt.ExecContext(ctx)\n\t\t\tpgErr := (*Error)(nil)\n\t\t\tswitch {\n\t\t\tcase (err != nil) != tt.cancelExpected:\n\t\t\t\tt.Fatalf(\"stmt.QueryContext() unexpected nil err got = %v, cancelExpected = %v\", err, tt.cancelExpected)\n\t\t\tcase (err != nil && tt.cancelExpected) && !(errors.As(err, &pgErr) && pgErr.Code == cancelErrorCode):\n\t\t\t\tt.Errorf(\"stmt.QueryContext() got = %v, cancelExpected = %v\", err.Error(), tt.cancelExpected)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "connector.go",
          "type": "blob",
          "size": 3.572265625,
          "content": "package pq\n\nimport (\n\t\"context\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\n// Connector represents a fixed configuration for the pq driver with a given\n// name. Connector satisfies the database/sql/driver Connector interface and\n// can be used to create any number of DB Conn's via the database/sql OpenDB\n// function.\n//\n// See https://golang.org/pkg/database/sql/driver/#Connector.\n// See https://golang.org/pkg/database/sql/#OpenDB.\ntype Connector struct {\n\topts   values\n\tdialer Dialer\n}\n\n// Connect returns a connection to the database using the fixed configuration\n// of this Connector. Context is not used.\nfunc (c *Connector) Connect(ctx context.Context) (driver.Conn, error) {\n\treturn c.open(ctx)\n}\n\n// Dialer allows change the dialer used to open connections.\nfunc (c *Connector) Dialer(dialer Dialer) {\n\tc.dialer = dialer\n}\n\n// Driver returns the underlying driver of this Connector.\nfunc (c *Connector) Driver() driver.Driver {\n\treturn &Driver{}\n}\n\n// NewConnector returns a connector for the pq driver in a fixed configuration\n// with the given dsn. The returned connector can be used to create any number\n// of equivalent Conn's. The returned connector is intended to be used with\n// database/sql.OpenDB.\n//\n// See https://golang.org/pkg/database/sql/driver/#Connector.\n// See https://golang.org/pkg/database/sql/#OpenDB.\nfunc NewConnector(dsn string) (*Connector, error) {\n\tvar err error\n\to := make(values)\n\n\t// A number of defaults are applied here, in this order:\n\t//\n\t// * Very low precedence defaults applied in every situation\n\t// * Environment variables\n\t// * Explicitly passed connection information\n\to[\"host\"] = \"localhost\"\n\to[\"port\"] = \"5432\"\n\t// N.B.: Extra float digits should be set to 3, but that breaks\n\t// Postgres 8.4 and older, where the max is 2.\n\to[\"extra_float_digits\"] = \"2\"\n\tfor k, v := range parseEnviron(os.Environ()) {\n\t\to[k] = v\n\t}\n\n\tif strings.HasPrefix(dsn, \"postgres://\") || strings.HasPrefix(dsn, \"postgresql://\") {\n\t\tdsn, err = ParseURL(dsn)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif err := parseOpts(dsn, o); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Use the \"fallback\" application name if necessary\n\tif fallback, ok := o[\"fallback_application_name\"]; ok {\n\t\tif _, ok := o[\"application_name\"]; !ok {\n\t\t\to[\"application_name\"] = fallback\n\t\t}\n\t}\n\n\t// We can't work with any client_encoding other than UTF-8 currently.\n\t// However, we have historically allowed the user to set it to UTF-8\n\t// explicitly, and there's no reason to break such programs, so allow that.\n\t// Note that the \"options\" setting could also set client_encoding, but\n\t// parsing its value is not worth it.  Instead, we always explicitly send\n\t// client_encoding as a separate run-time parameter, which should override\n\t// anything set in options.\n\tif enc, ok := o[\"client_encoding\"]; ok && !isUTF8(enc) {\n\t\treturn nil, errors.New(\"client_encoding must be absent or 'UTF8'\")\n\t}\n\to[\"client_encoding\"] = \"UTF8\"\n\t// DateStyle needs a similar treatment.\n\tif datestyle, ok := o[\"datestyle\"]; ok {\n\t\tif datestyle != \"ISO, MDY\" {\n\t\t\treturn nil, fmt.Errorf(\"setting datestyle must be absent or %v; got %v\", \"ISO, MDY\", datestyle)\n\t\t}\n\t} else {\n\t\to[\"datestyle\"] = \"ISO, MDY\"\n\t}\n\n\t// If a user is not provided by any other means, the last\n\t// resort is to use the current operating system provided user\n\t// name.\n\tif _, ok := o[\"user\"]; !ok {\n\t\tu, err := userCurrent()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\to[\"user\"] = u\n\t}\n\n\t// SSL is not necessary or supported over UNIX domain sockets\n\tif network, _ := network(o); network == \"unix\" {\n\t\to[\"sslmode\"] = \"disable\"\n\t}\n\n\treturn &Connector{opts: o, dialer: defaultDialer{}}, nil\n}\n"
        },
        {
          "name": "connector_example_test.go",
          "type": "blob",
          "size": 0.3837890625,
          "content": "//go:build go1.10\n// +build go1.10\n\npackage pq_test\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\n\t\"github.com/lib/pq\"\n)\n\nfunc ExampleNewConnector() {\n\tname := \"\"\n\tconnector, err := pq.NewConnector(name)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdb := sql.OpenDB(connector)\n\tdefer db.Close()\n\n\t// Use the DB\n\ttxn, err := db.Begin()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\ttxn.Rollback()\n}\n"
        },
        {
          "name": "connector_test.go",
          "type": "blob",
          "size": 1.7646484375,
          "content": "//go:build go1.10\n// +build go1.10\n\npackage pq\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestNewConnector_WorksWithOpenDB(t *testing.T) {\n\tname := \"\"\n\tc, err := NewConnector(name)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdb := sql.OpenDB(c)\n\tdefer db.Close()\n\t// database/sql might not call our Open at all unless we do something with\n\t// the connection\n\ttxn, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttxn.Rollback()\n}\n\nfunc TestNewConnector_Connect(t *testing.T) {\n\tname := \"\"\n\tc, err := NewConnector(name)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdb, err := c.Connect(context.Background())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\t// database/sql might not call our Open at all unless we do something with\n\t// the connection\n\ttxn, err := db.(driver.ConnBeginTx).BeginTx(context.Background(), driver.TxOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttxn.Rollback()\n}\n\nfunc TestNewConnector_Driver(t *testing.T) {\n\tname := \"\"\n\tc, err := NewConnector(name)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdb, err := c.Driver().Open(name)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\t// database/sql might not call our Open at all unless we do something with\n\t// the connection\n\ttxn, err := db.(driver.ConnBeginTx).BeginTx(context.Background(), driver.TxOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttxn.Rollback()\n}\n\nfunc TestNewConnector_Environ(t *testing.T) {\n\tname := \"\"\n\tos.Setenv(\"PGPASSFILE\", \"/tmp/.pgpass\")\n\tdefer os.Unsetenv(\"PGPASSFILE\")\n\tc, err := NewConnector(name)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor key, expected := range map[string]string{\n\t\t\"passfile\": \"/tmp/.pgpass\",\n\t} {\n\t\tif got := c.opts[key]; got != expected {\n\t\t\tt.Fatalf(\"Getting values from environment variables, for %v expected %s got %s\", key, expected, got)\n\t\t}\n\t}\n\n}\n"
        },
        {
          "name": "copy.go",
          "type": "blob",
          "size": 7.470703125,
          "content": "package pq\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"database/sql/driver\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n)\n\nvar (\n\terrCopyInClosed               = errors.New(\"pq: copyin statement has already been closed\")\n\terrBinaryCopyNotSupported     = errors.New(\"pq: only text format supported for COPY\")\n\terrCopyToNotSupported         = errors.New(\"pq: COPY TO is not supported\")\n\terrCopyNotSupportedOutsideTxn = errors.New(\"pq: COPY is only allowed inside a transaction\")\n\terrCopyInProgress             = errors.New(\"pq: COPY in progress\")\n)\n\n// CopyIn creates a COPY FROM statement which can be prepared with\n// Tx.Prepare().  The target table should be visible in search_path.\nfunc CopyIn(table string, columns ...string) string {\n\tbuffer := bytes.NewBufferString(\"COPY \")\n\tBufferQuoteIdentifier(table, buffer)\n\tbuffer.WriteString(\" (\")\n\tmakeStmt(buffer, columns...)\n\treturn buffer.String()\n}\n\n// MakeStmt makes the stmt string for CopyIn and CopyInSchema.\nfunc makeStmt(buffer *bytes.Buffer, columns ...string) {\n\t//s := bytes.NewBufferString()\n\tfor i, col := range columns {\n\t\tif i != 0 {\n\t\t\tbuffer.WriteString(\", \")\n\t\t}\n\t\tBufferQuoteIdentifier(col, buffer)\n\t}\n\tbuffer.WriteString(\") FROM STDIN\")\n}\n\n// CopyInSchema creates a COPY FROM statement which can be prepared with\n// Tx.Prepare().\nfunc CopyInSchema(schema, table string, columns ...string) string {\n\tbuffer := bytes.NewBufferString(\"COPY \")\n\tBufferQuoteIdentifier(schema, buffer)\n\tbuffer.WriteRune('.')\n\tBufferQuoteIdentifier(table, buffer)\n\tbuffer.WriteString(\" (\")\n\tmakeStmt(buffer, columns...)\n\treturn buffer.String()\n}\n\ntype copyin struct {\n\tcn      *conn\n\tbuffer  []byte\n\trowData chan []byte\n\tdone    chan bool\n\n\tclosed bool\n\n\tmu struct {\n\t\tsync.Mutex\n\t\terr error\n\t\tdriver.Result\n\t}\n}\n\nconst ciBufferSize = 64 * 1024\n\n// flush buffer before the buffer is filled up and needs reallocation\nconst ciBufferFlushSize = 63 * 1024\n\nfunc (cn *conn) prepareCopyIn(q string) (_ driver.Stmt, err error) {\n\tif !cn.isInTransaction() {\n\t\treturn nil, errCopyNotSupportedOutsideTxn\n\t}\n\n\tci := &copyin{\n\t\tcn:      cn,\n\t\tbuffer:  make([]byte, 0, ciBufferSize),\n\t\trowData: make(chan []byte),\n\t\tdone:    make(chan bool, 1),\n\t}\n\t// add CopyData identifier + 4 bytes for message length\n\tci.buffer = append(ci.buffer, 'd', 0, 0, 0, 0)\n\n\tb := cn.writeBuf('Q')\n\tb.string(q)\n\tcn.send(b)\n\nawaitCopyInResponse:\n\tfor {\n\t\tt, r := cn.recv1()\n\t\tswitch t {\n\t\tcase 'G':\n\t\t\tif r.byte() != 0 {\n\t\t\t\terr = errBinaryCopyNotSupported\n\t\t\t\tbreak awaitCopyInResponse\n\t\t\t}\n\t\t\tgo ci.resploop()\n\t\t\treturn ci, nil\n\t\tcase 'H':\n\t\t\terr = errCopyToNotSupported\n\t\t\tbreak awaitCopyInResponse\n\t\tcase 'E':\n\t\t\terr = parseError(r)\n\t\tcase 'Z':\n\t\t\tif err == nil {\n\t\t\t\tci.setBad(driver.ErrBadConn)\n\t\t\t\terrorf(\"unexpected ReadyForQuery in response to COPY\")\n\t\t\t}\n\t\t\tcn.processReadyForQuery(r)\n\t\t\treturn nil, err\n\t\tdefault:\n\t\t\tci.setBad(driver.ErrBadConn)\n\t\t\terrorf(\"unknown response for copy query: %q\", t)\n\t\t}\n\t}\n\n\t// something went wrong, abort COPY before we return\n\tb = cn.writeBuf('f')\n\tb.string(err.Error())\n\tcn.send(b)\n\n\tfor {\n\t\tt, r := cn.recv1()\n\t\tswitch t {\n\t\tcase 'c', 'C', 'E':\n\t\tcase 'Z':\n\t\t\t// correctly aborted, we're done\n\t\t\tcn.processReadyForQuery(r)\n\t\t\treturn nil, err\n\t\tdefault:\n\t\t\tci.setBad(driver.ErrBadConn)\n\t\t\terrorf(\"unknown response for CopyFail: %q\", t)\n\t\t}\n\t}\n}\n\nfunc (ci *copyin) flush(buf []byte) {\n\t// set message length (without message identifier)\n\tbinary.BigEndian.PutUint32(buf[1:], uint32(len(buf)-1))\n\n\t_, err := ci.cn.c.Write(buf)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (ci *copyin) resploop() {\n\tfor {\n\t\tvar r readBuf\n\t\tt, err := ci.cn.recvMessage(&r)\n\t\tif err != nil {\n\t\t\tci.setBad(driver.ErrBadConn)\n\t\t\tci.setError(err)\n\t\t\tci.done <- true\n\t\t\treturn\n\t\t}\n\t\tswitch t {\n\t\tcase 'C':\n\t\t\t// complete\n\t\t\tres, _ := ci.cn.parseComplete(r.string())\n\t\t\tci.setResult(res)\n\t\tcase 'N':\n\t\t\tif n := ci.cn.noticeHandler; n != nil {\n\t\t\t\tn(parseError(&r))\n\t\t\t}\n\t\tcase 'Z':\n\t\t\tci.cn.processReadyForQuery(&r)\n\t\t\tci.done <- true\n\t\t\treturn\n\t\tcase 'E':\n\t\t\terr := parseError(&r)\n\t\t\tci.setError(err)\n\t\tdefault:\n\t\t\tci.setBad(driver.ErrBadConn)\n\t\t\tci.setError(fmt.Errorf(\"unknown response during CopyIn: %q\", t))\n\t\t\tci.done <- true\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (ci *copyin) setBad(err error) {\n\tci.cn.err.set(err)\n}\n\nfunc (ci *copyin) getBad() error {\n\treturn ci.cn.err.get()\n}\n\nfunc (ci *copyin) err() error {\n\tci.mu.Lock()\n\terr := ci.mu.err\n\tci.mu.Unlock()\n\treturn err\n}\n\n// setError() sets ci.err if one has not been set already.  Caller must not be\n// holding ci.Mutex.\nfunc (ci *copyin) setError(err error) {\n\tci.mu.Lock()\n\tif ci.mu.err == nil {\n\t\tci.mu.err = err\n\t}\n\tci.mu.Unlock()\n}\n\nfunc (ci *copyin) setResult(result driver.Result) {\n\tci.mu.Lock()\n\tci.mu.Result = result\n\tci.mu.Unlock()\n}\n\nfunc (ci *copyin) getResult() driver.Result {\n\tci.mu.Lock()\n\tresult := ci.mu.Result\n\tci.mu.Unlock()\n\tif result == nil {\n\t\treturn driver.RowsAffected(0)\n\t}\n\treturn result\n}\n\nfunc (ci *copyin) NumInput() int {\n\treturn -1\n}\n\nfunc (ci *copyin) Query(v []driver.Value) (r driver.Rows, err error) {\n\treturn nil, ErrNotSupported\n}\n\n// Exec inserts values into the COPY stream. The insert is asynchronous\n// and Exec can return errors from previous Exec calls to the same\n// COPY stmt.\n//\n// You need to call Exec(nil) to sync the COPY stream and to get any\n// errors from pending data, since Stmt.Close() doesn't return errors\n// to the user.\nfunc (ci *copyin) Exec(v []driver.Value) (r driver.Result, err error) {\n\tif ci.closed {\n\t\treturn nil, errCopyInClosed\n\t}\n\n\tif err := ci.getBad(); err != nil {\n\t\treturn nil, err\n\t}\n\tdefer ci.cn.errRecover(&err)\n\n\tif err := ci.err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(v) == 0 {\n\t\tif err := ci.Close(); err != nil {\n\t\t\treturn driver.RowsAffected(0), err\n\t\t}\n\n\t\treturn ci.getResult(), nil\n\t}\n\n\tnumValues := len(v)\n\tfor i, value := range v {\n\t\tci.buffer = appendEncodedText(&ci.cn.parameterStatus, ci.buffer, value)\n\t\tif i < numValues-1 {\n\t\t\tci.buffer = append(ci.buffer, '\\t')\n\t\t}\n\t}\n\n\tci.buffer = append(ci.buffer, '\\n')\n\n\tif len(ci.buffer) > ciBufferFlushSize {\n\t\tci.flush(ci.buffer)\n\t\t// reset buffer, keep bytes for message identifier and length\n\t\tci.buffer = ci.buffer[:5]\n\t}\n\n\treturn driver.RowsAffected(0), nil\n}\n\n// CopyData inserts a raw string into the COPY stream. The insert is\n// asynchronous and CopyData can return errors from previous CopyData calls to\n// the same COPY stmt.\n//\n// You need to call Exec(nil) to sync the COPY stream and to get any\n// errors from pending data, since Stmt.Close() doesn't return errors\n// to the user.\nfunc (ci *copyin) CopyData(ctx context.Context, line string) (r driver.Result, err error) {\n\tif ci.closed {\n\t\treturn nil, errCopyInClosed\n\t}\n\n\tif finish := ci.cn.watchCancel(ctx); finish != nil {\n\t\tdefer finish()\n\t}\n\n\tif err := ci.getBad(); err != nil {\n\t\treturn nil, err\n\t}\n\tdefer ci.cn.errRecover(&err)\n\n\tif err := ci.err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tci.buffer = append(ci.buffer, []byte(line)...)\n\tci.buffer = append(ci.buffer, '\\n')\n\n\tif len(ci.buffer) > ciBufferFlushSize {\n\t\tci.flush(ci.buffer)\n\t\t// reset buffer, keep bytes for message identifier and length\n\t\tci.buffer = ci.buffer[:5]\n\t}\n\n\treturn driver.RowsAffected(0), nil\n}\n\nfunc (ci *copyin) Close() (err error) {\n\tif ci.closed { // Don't do anything, we're already closed\n\t\treturn nil\n\t}\n\tci.closed = true\n\n\tif err := ci.getBad(); err != nil {\n\t\treturn err\n\t}\n\tdefer ci.cn.errRecover(&err)\n\n\tif len(ci.buffer) > 0 {\n\t\tci.flush(ci.buffer)\n\t}\n\t// Avoid touching the scratch buffer as resploop could be using it.\n\terr = ci.cn.sendSimpleMessage('c')\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t<-ci.done\n\tci.cn.inCopy = false\n\n\tif err := ci.err(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "copy_test.go",
          "type": "blob",
          "size": 15.3486328125,
          "content": "package pq\n\nimport (\n\t\"bytes\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestCopyInStmt(t *testing.T) {\n\tstmt := CopyIn(\"table name\")\n\tif stmt != `COPY \"table name\" () FROM STDIN` {\n\t\tt.Fatal(stmt)\n\t}\n\n\tstmt = CopyIn(\"table name\", \"column 1\", \"column 2\")\n\tif stmt != `COPY \"table name\" (\"column 1\", \"column 2\") FROM STDIN` {\n\t\tt.Fatal(stmt)\n\t}\n\n\tstmt = CopyIn(`table \" name \"\"\"`, `co\"lumn\"\"`)\n\tif stmt != `COPY \"table \"\" name \"\"\"\"\"\"\" (\"co\"\"lumn\"\"\"\"\") FROM STDIN` {\n\t\tt.Fatal(stmt)\n\t}\n}\n\nfunc TestCopyInSchemaStmt(t *testing.T) {\n\tstmt := CopyInSchema(\"schema name\", \"table name\")\n\tif stmt != `COPY \"schema name\".\"table name\" () FROM STDIN` {\n\t\tt.Fatal(stmt)\n\t}\n\n\tstmt = CopyInSchema(\"schema name\", \"table name\", \"column 1\", \"column 2\")\n\tif stmt != `COPY \"schema name\".\"table name\" (\"column 1\", \"column 2\") FROM STDIN` {\n\t\tt.Fatal(stmt)\n\t}\n\n\tstmt = CopyInSchema(`schema \" name \"\"\"`, `table \" name \"\"\"`, `co\"lumn\"\"`)\n\tif stmt != `COPY \"schema \"\" name \"\"\"\"\"\"\".`+\n\t\t`\"table \"\" name \"\"\"\"\"\"\" (\"co\"\"lumn\"\"\"\"\") FROM STDIN` {\n\t\tt.Fatal(stmt)\n\t}\n}\n\nfunc TestCopyInMultipleValues(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttxn, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer txn.Rollback()\n\n\t_, err = txn.Exec(\"CREATE TEMP TABLE temp (a int, b varchar)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tstmt, err := txn.Prepare(CopyIn(\"temp\", \"a\", \"b\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlongString := strings.Repeat(\"#\", 500)\n\n\tfor i := 0; i < 500; i++ {\n\t\t_, err = stmt.Exec(int64(i), longString)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tresult, err := stmt.Exec()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trowsAffected, err := result.RowsAffected()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif rowsAffected != 500 {\n\t\tt.Fatalf(\"expected 500 rows affected, not %d\", rowsAffected)\n\t}\n\n\terr = stmt.Close()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar num int\n\terr = txn.QueryRow(\"SELECT COUNT(*) FROM temp\").Scan(&num)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif num != 500 {\n\t\tt.Fatalf(\"expected 500 items, not %d\", num)\n\t}\n}\n\nfunc TestCopyInRaiseStmtTrigger(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tif getServerVersion(t, db) < 90000 {\n\t\tvar exists int\n\t\terr := db.QueryRow(\"SELECT 1 FROM pg_language WHERE lanname = 'plpgsql'\").Scan(&exists)\n\t\tif err == sql.ErrNoRows {\n\t\t\tt.Skip(\"language PL/PgSQL does not exist; skipping TestCopyInRaiseStmtTrigger\")\n\t\t} else if err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\ttxn, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer txn.Rollback()\n\n\t_, err = txn.Exec(\"CREATE TEMP TABLE temp (a int, b varchar)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = txn.Exec(`\n\t\t\tCREATE OR REPLACE FUNCTION pg_temp.temptest()\n\t\t\tRETURNS trigger AS\n\t\t\t$BODY$ begin\n\t\t\t\traise notice 'Hello world';\n\t\t\t\treturn new;\n\t\t\tend $BODY$\n\t\t\tLANGUAGE plpgsql`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = txn.Exec(`\n\t\t\tCREATE TRIGGER temptest_trigger\n\t\t\tBEFORE INSERT\n\t\t\tON temp\n\t\t\tFOR EACH ROW\n\t\t\tEXECUTE PROCEDURE pg_temp.temptest()`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tstmt, err := txn.Prepare(CopyIn(\"temp\", \"a\", \"b\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tlongString := strings.Repeat(\"#\", 500)\n\n\t_, err = stmt.Exec(int64(1), longString)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = stmt.Exec()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = stmt.Close()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar num int\n\terr = txn.QueryRow(\"SELECT COUNT(*) FROM temp\").Scan(&num)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif num != 1 {\n\t\tt.Fatalf(\"expected 1 items, not %d\", num)\n\t}\n}\n\nfunc TestCopyInTypes(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttxn, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer txn.Rollback()\n\n\t_, err = txn.Exec(\"CREATE TEMP TABLE temp (num INTEGER, text VARCHAR, blob BYTEA, nothing VARCHAR)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tstmt, err := txn.Prepare(CopyIn(\"temp\", \"num\", \"text\", \"blob\", \"nothing\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = stmt.Exec(int64(1234567890), \"Hll\\n !\\r\\t\\\\\", []byte{0, 255, 9, 10, 13}, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = stmt.Exec()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = stmt.Close()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar num int\n\tvar text string\n\tvar blob []byte\n\tvar nothing sql.NullString\n\n\terr = txn.QueryRow(\"SELECT * FROM temp\").Scan(&num, &text, &blob, &nothing)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif num != 1234567890 {\n\t\tt.Fatal(\"unexpected result\", num)\n\t}\n\tif text != \"Hll\\n !\\r\\t\\\\\" {\n\t\tt.Fatal(\"unexpected result\", text)\n\t}\n\tif !bytes.Equal(blob, []byte{0, 255, 9, 10, 13}) {\n\t\tt.Fatal(\"unexpected result\", blob)\n\t}\n\tif nothing.Valid {\n\t\tt.Fatal(\"unexpected result\", nothing.String)\n\t}\n}\n\nfunc TestCopyInWrongType(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttxn, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer txn.Rollback()\n\n\t_, err = txn.Exec(\"CREATE TEMP TABLE temp (num INTEGER)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tstmt, err := txn.Prepare(CopyIn(\"temp\", \"num\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer stmt.Close()\n\n\t_, err = stmt.Exec(\"Hll\\n !\\r\\t\\\\\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = stmt.Exec()\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n\tif pge := err.(*Error); pge.Code.Name() != \"invalid_text_representation\" {\n\t\tt.Fatalf(\"expected 'invalid input syntax for integer' error, got %s (%+v)\", pge.Code.Name(), pge)\n\t}\n}\n\nfunc TestCopyOutsideOfTxnError(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\t_, err := db.Prepare(CopyIn(\"temp\", \"num\"))\n\tif err == nil {\n\t\tt.Fatal(\"COPY outside of transaction did not return an error\")\n\t}\n\tif err != errCopyNotSupportedOutsideTxn {\n\t\tt.Fatalf(\"expected %s, got %s\", err, err.Error())\n\t}\n}\n\nfunc TestCopyInBinaryError(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttxn, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer txn.Rollback()\n\n\t_, err = txn.Exec(\"CREATE TEMP TABLE temp (num INTEGER)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t_, err = txn.Prepare(\"COPY temp (num) FROM STDIN WITH binary\")\n\tif err != errBinaryCopyNotSupported {\n\t\tt.Fatalf(\"expected %s, got %+v\", errBinaryCopyNotSupported, err)\n\t}\n\t// check that the protocol is in a valid state\n\terr = txn.Rollback()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestCopyFromError(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttxn, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer txn.Rollback()\n\n\t_, err = txn.Exec(\"CREATE TEMP TABLE temp (num INTEGER)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t_, err = txn.Prepare(\"COPY temp (num) TO STDOUT\")\n\tif err != errCopyToNotSupported {\n\t\tt.Fatalf(\"expected %s, got %+v\", errCopyToNotSupported, err)\n\t}\n\t// check that the protocol is in a valid state\n\terr = txn.Rollback()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestCopySyntaxError(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttxn, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer txn.Rollback()\n\n\t_, err = txn.Prepare(\"COPY \")\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n\tif pge := err.(*Error); pge.Code.Name() != \"syntax_error\" {\n\t\tt.Fatalf(\"expected syntax error, got %s (%+v)\", pge.Code.Name(), pge)\n\t}\n\t// check that the protocol is in a valid state\n\terr = txn.Rollback()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Tests for connection errors in copyin.resploop()\nfunc TestCopyRespLoopConnectionError(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttxn, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer txn.Rollback()\n\n\tvar pid int\n\terr = txn.QueryRow(\"SELECT pg_backend_pid()\").Scan(&pid)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = txn.Exec(\"CREATE TEMP TABLE temp (a int)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tstmt, err := txn.Prepare(CopyIn(\"temp\", \"a\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer stmt.Close()\n\n\t_, err = db.Exec(\"SELECT pg_terminate_backend($1)\", pid)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif getServerVersion(t, db) < 90500 {\n\t\t// We have to try and send something over, since postgres before\n\t\t// version 9.5 won't process SIGTERMs while it's waiting for\n\t\t// CopyData/CopyEnd messages; see tcop/postgres.c.\n\t\t_, err = stmt.Exec(1)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\tretry(t, time.Second*5, func() error {\n\t\t_, err = stmt.Exec()\n\t\tif err == nil {\n\t\t\treturn fmt.Errorf(\"expected error\")\n\t\t}\n\t\treturn nil\n\t})\n\tswitch pge := err.(type) {\n\tcase *Error:\n\t\tif pge.Code.Name() != \"admin_shutdown\" {\n\t\t\tt.Fatalf(\"expected admin_shutdown, got %s\", pge.Code.Name())\n\t\t}\n\tcase *net.OpError:\n\t\t// ignore\n\tdefault:\n\t\tif err == driver.ErrBadConn {\n\t\t\t// likely an EPIPE\n\t\t} else if err == errCopyInClosed {\n\t\t\t// ignore\n\t\t} else {\n\t\t\tt.Fatalf(\"unexpected error, got %+#v\", err)\n\t\t}\n\t}\n\n\t_ = stmt.Close()\n}\n\n// retry executes f in a backoff loop until it doesn't return an error. If this\n// doesn't happen within duration, t.Fatal is called with the latest error.\nfunc retry(t *testing.T, duration time.Duration, f func() error) {\n\tstart := time.Now()\n\tnext := time.Millisecond * 100\n\tfor {\n\t\terr := f()\n\t\tif err == nil {\n\t\t\treturn\n\t\t}\n\t\tif time.Since(start) > duration {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\ttime.Sleep(next)\n\t\tnext *= 2\n\t}\n}\n\nfunc BenchmarkCopyIn(b *testing.B) {\n\tdb := openTestConn(b)\n\tdefer db.Close()\n\n\ttxn, err := db.Begin()\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tdefer txn.Rollback()\n\n\t_, err = txn.Exec(\"CREATE TEMP TABLE temp (a int, b varchar)\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tstmt, err := txn.Prepare(CopyIn(\"temp\", \"a\", \"b\"))\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err = stmt.Exec(int64(i), \"hello world!\")\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n\n\t_, err = stmt.Exec()\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\terr = stmt.Close()\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tvar num int\n\terr = txn.QueryRow(\"SELECT COUNT(*) FROM temp\").Scan(&num)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tif num != b.N {\n\t\tb.Fatalf(\"expected %d items, not %d\", b.N, num)\n\t}\n}\n\nvar bigTableColumns = []string{\"ABIOGENETICALLY\", \"ABORIGINALITIES\", \"ABSORBABILITIES\", \"ABSORBEFACIENTS\", \"ABSORPTIOMETERS\", \"ABSTRACTIONISMS\", \"ABSTRACTIONISTS\", \"ACANTHOCEPHALAN\", \"ACCEPTABILITIES\", \"ACCEPTINGNESSES\", \"ACCESSARINESSES\", \"ACCESSIBILITIES\", \"ACCESSORINESSES\", \"ACCIDENTALITIES\", \"ACCIDENTOLOGIES\", \"ACCLIMATISATION\", \"ACCLIMATIZATION\", \"ACCOMMODATINGLY\", \"ACCOMMODATIONAL\", \"ACCOMPLISHMENTS\", \"ACCOUNTABLENESS\", \"ACCOUNTANTSHIPS\", \"ACCULTURATIONAL\", \"ACETOPHENETIDIN\", \"ACETYLSALICYLIC\", \"ACHONDROPLASIAS\", \"ACHONDROPLASTIC\", \"ACHROMATICITIES\", \"ACHROMATISATION\", \"ACHROMATIZATION\", \"ACIDIMETRICALLY\", \"ACKNOWLEDGEABLE\", \"ACKNOWLEDGEABLY\", \"ACKNOWLEDGEMENT\", \"ACKNOWLEDGMENTS\", \"ACQUIRABILITIES\", \"ACQUISITIVENESS\", \"ACRIMONIOUSNESS\", \"ACROPARESTHESIA\", \"ACTINOBIOLOGIES\", \"ACTINOCHEMISTRY\", \"ACTINOTHERAPIES\", \"ADAPTABLENESSES\", \"ADDITIONALITIES\", \"ADENOCARCINOMAS\", \"ADENOHYPOPHYSES\", \"ADENOHYPOPHYSIS\", \"ADENOIDECTOMIES\", \"ADIATHERMANCIES\", \"ADJUSTABILITIES\", \"ADMINISTRATIONS\", \"ADMIRABLENESSES\", \"ADMISSIBILITIES\", \"ADRENALECTOMIES\", \"ADSORBABILITIES\", \"ADVENTUROUSNESS\", \"ADVERSARINESSES\", \"ADVISABLENESSES\", \"AERODYNAMICALLY\", \"AERODYNAMICISTS\", \"AEROELASTICIANS\", \"AEROHYDROPLANES\", \"AEROLITHOLOGIES\", \"AEROSOLISATIONS\", \"AEROSOLIZATIONS\", \"AFFECTABILITIES\", \"AFFECTIVENESSES\", \"AFFORDABILITIES\", \"AFFRANCHISEMENT\", \"AFTERSENSATIONS\", \"AGGLUTINABILITY\", \"AGGRANDISEMENTS\", \"AGGRANDIZEMENTS\", \"AGGREGATENESSES\", \"AGRANULOCYTOSES\", \"AGRANULOCYTOSIS\", \"AGREEABLENESSES\", \"AGRIBUSINESSMAN\", \"AGRIBUSINESSMEN\", \"AGRICULTURALIST\", \"AIRWORTHINESSES\", \"ALCOHOLISATIONS\", \"ALCOHOLIZATIONS\", \"ALCOHOLOMETRIES\", \"ALEXIPHARMAKONS\", \"ALGORITHMICALLY\", \"ALKALINISATIONS\", \"ALKALINIZATIONS\", \"ALLEGORICALNESS\", \"ALLEGORISATIONS\", \"ALLEGORIZATIONS\", \"ALLELOMORPHISMS\", \"ALLERGENICITIES\", \"ALLOTETRAPLOIDS\", \"ALLOTETRAPLOIDY\", \"ALLOTRIOMORPHIC\", \"ALLOWABLENESSES\", \"ALPHABETISATION\", \"ALPHABETIZATION\", \"ALTERNATIVENESS\", \"ALTITUDINARIANS\", \"ALUMINOSILICATE\", \"ALUMINOTHERMIES\", \"AMARYLLIDACEOUS\", \"AMBASSADORSHIPS\", \"AMBIDEXTERITIES\", \"AMBIGUOUSNESSES\", \"AMBISEXUALITIES\", \"AMBITIOUSNESSES\", \"AMINOPEPTIDASES\", \"AMINOPHENAZONES\", \"AMMONIFICATIONS\", \"AMORPHOUSNESSES\", \"AMPHIDIPLOIDIES\", \"AMPHITHEATRICAL\", \"ANACOLUTHICALLY\", \"ANACREONTICALLY\", \"ANAESTHESIOLOGY\", \"ANAESTHETICALLY\", \"ANAGRAMMATISING\", \"ANAGRAMMATIZING\", \"ANALOGOUSNESSES\", \"ANALYZABILITIES\", \"ANAMORPHOSCOPES\", \"ANCYLOSTOMIASES\", \"ANCYLOSTOMIASIS\", \"ANDROGYNOPHORES\", \"ANDROMEDOTOXINS\", \"ANDROMONOECIOUS\", \"ANDROMONOECISMS\", \"ANESTHETIZATION\", \"ANFRACTUOSITIES\", \"ANGUSTIROSTRATE\", \"ANIMATRONICALLY\", \"ANISOTROPICALLY\", \"ANKYLOSTOMIASES\", \"ANKYLOSTOMIASIS\", \"ANNIHILATIONISM\", \"ANOMALISTICALLY\", \"ANOMALOUSNESSES\", \"ANONYMOUSNESSES\", \"ANSWERABILITIES\", \"ANTAGONISATIONS\", \"ANTAGONIZATIONS\", \"ANTAPHRODISIACS\", \"ANTEPENULTIMATE\", \"ANTHROPOBIOLOGY\", \"ANTHROPOCENTRIC\", \"ANTHROPOGENESES\", \"ANTHROPOGENESIS\", \"ANTHROPOGENETIC\", \"ANTHROPOLATRIES\", \"ANTHROPOLOGICAL\", \"ANTHROPOLOGISTS\", \"ANTHROPOMETRIES\", \"ANTHROPOMETRIST\", \"ANTHROPOMORPHIC\", \"ANTHROPOPATHIES\", \"ANTHROPOPATHISM\", \"ANTHROPOPHAGIES\", \"ANTHROPOPHAGITE\", \"ANTHROPOPHAGOUS\", \"ANTHROPOPHOBIAS\", \"ANTHROPOPHOBICS\", \"ANTHROPOPHUISMS\", \"ANTHROPOPSYCHIC\", \"ANTHROPOSOPHIES\", \"ANTHROPOSOPHIST\", \"ANTIABORTIONIST\", \"ANTIALCOHOLISMS\", \"ANTIAPHRODISIAC\", \"ANTIARRHYTHMICS\", \"ANTICAPITALISMS\", \"ANTICAPITALISTS\", \"ANTICARCINOGENS\", \"ANTICHOLESTEROL\", \"ANTICHOLINERGIC\", \"ANTICHRISTIANLY\", \"ANTICLERICALISM\", \"ANTICLIMACTICAL\", \"ANTICOINCIDENCE\", \"ANTICOLONIALISM\", \"ANTICOLONIALIST\", \"ANTICOMPETITIVE\", \"ANTICONVULSANTS\", \"ANTICONVULSIVES\", \"ANTIDEPRESSANTS\", \"ANTIDERIVATIVES\", \"ANTIDEVELOPMENT\", \"ANTIEDUCATIONAL\", \"ANTIEGALITARIAN\", \"ANTIFASHIONABLE\", \"ANTIFEDERALISTS\", \"ANTIFERROMAGNET\", \"ANTIFORECLOSURE\", \"ANTIHELMINTHICS\", \"ANTIHISTAMINICS\", \"ANTILIBERALISMS\", \"ANTILIBERTARIAN\", \"ANTILOGARITHMIC\", \"ANTIMATERIALISM\", \"ANTIMATERIALIST\", \"ANTIMETABOLITES\", \"ANTIMILITARISMS\", \"ANTIMILITARISTS\", \"ANTIMONARCHICAL\", \"ANTIMONARCHISTS\", \"ANTIMONOPOLISTS\", \"ANTINATIONALIST\", \"ANTINUCLEARISTS\", \"ANTIODONTALGICS\", \"ANTIPERISTALSES\", \"ANTIPERISTALSIS\", \"ANTIPERISTALTIC\", \"ANTIPERSPIRANTS\", \"ANTIPHLOGISTICS\", \"ANTIPORNOGRAPHY\", \"ANTIPROGRESSIVE\", \"ANTIQUARIANISMS\", \"ANTIRADICALISMS\", \"ANTIRATIONALISM\", \"ANTIRATIONALIST\", \"ANTIRATIONALITY\", \"ANTIREPUBLICANS\", \"ANTIROMANTICISM\", \"ANTISEGREGATION\", \"ANTISENTIMENTAL\", \"ANTISEPARATISTS\", \"ANTISEPTICISING\", \"ANTISEPTICIZING\", \"ANTISEXUALITIES\", \"ANTISHOPLIFTING\", \"ANTISOCIALITIES\", \"ANTISPECULATION\", \"ANTISPECULATIVE\", \"ANTISYPHILITICS\", \"ANTITHEORETICAL\", \"ANTITHROMBOTICS\", \"ANTITRADITIONAL\", \"ANTITRANSPIRANT\", \"ANTITRINITARIAN\", \"ANTITUBERCULOUS\", \"ANTIVIVISECTION\", \"APHELIOTROPISMS\", \"APOCALYPTICALLY\", \"APOCALYPTICISMS\", \"APOLIPOPROTEINS\", \"APOLITICALITIES\", \"APOPHTHEGMATISE\", \"APOPHTHEGMATIST\", \"APOPHTHEGMATIZE\", \"APOTHEGMATISING\", \"APOTHEGMATIZING\", \"APPEALABILITIES\", \"APPEALINGNESSES\", \"APPENDICULARIAN\", \"APPLICABILITIES\", \"APPRENTICEHOODS\", \"APPRENTICEMENTS\", \"APPRENTICESHIPS\", \"APPROACHABILITY\", \"APPROPINQUATING\", \"APPROPINQUATION\", \"APPROPINQUITIES\", \"APPROPRIATENESS\", \"ARACHNOIDITISES\", \"ARBITRARINESSES\", \"ARBORICULTURIST\", \"ARCHAEBACTERIUM\", \"ARCHAEOBOTANIES\", \"ARCHAEOBOTANIST\", \"ARCHAEOMETRISTS\", \"ARCHAEOPTERYXES\", \"ARCHAEZOOLOGIES\", \"ARCHEOASTRONOMY\", \"ARCHEOBOTANISTS\", \"ARCHEOLOGICALLY\", \"ARCHEOMAGNETISM\", \"ARCHEOZOOLOGIES\", \"ARCHEOZOOLOGIST\", \"ARCHGENETHLIACS\", \"ARCHIDIACONATES\", \"ARCHIEPISCOPACY\", \"ARCHIEPISCOPATE\", \"ARCHITECTURALLY\", \"ARCHPRIESTHOODS\", \"ARCHPRIESTSHIPS\", \"ARGUMENTATIVELY\", \"ARIBOFLAVINOSES\", \"ARIBOFLAVINOSIS\", \"AROMATHERAPISTS\", \"ARRONDISSEMENTS\", \"ARTERIALISATION\", \"ARTERIALIZATION\", \"ARTERIOGRAPHIES\", \"ARTIFICIALISING\", \"ARTIFICIALITIES\", \"ARTIFICIALIZING\", \"ASCLEPIADACEOUS\", \"ASSENTIVENESSES\"}\n\nfunc BenchmarkCopy(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCopyIn(\"temp\", bigTableColumns...)\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 9.3896484375,
          "content": "/*\nPackage pq is a pure Go Postgres driver for the database/sql package.\n\nIn most cases clients will use the database/sql package instead of\nusing this package directly. For example:\n\n\timport (\n\t\t\"database/sql\"\n\n\t\t_ \"github.com/lib/pq\"\n\t)\n\n\tfunc main() {\n\t\tconnStr := \"user=pqgotest dbname=pqgotest sslmode=verify-full\"\n\t\tdb, err := sql.Open(\"postgres\", connStr)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tage := 21\n\t\trows, err := db.Query(\"SELECT name FROM users WHERE age = $1\", age)\n\t\t\n\t}\n\nYou can also connect to a database using a URL. For example:\n\n\tconnStr := \"postgres://pqgotest:password@localhost/pqgotest?sslmode=verify-full\"\n\tdb, err := sql.Open(\"postgres\", connStr)\n\n\nConnection String Parameters\n\n\nSimilarly to libpq, when establishing a connection using pq you are expected to\nsupply a connection string containing zero or more parameters.\nA subset of the connection parameters supported by libpq are also supported by pq.\nAdditionally, pq also lets you specify run-time parameters (such as search_path or work_mem)\ndirectly in the connection string.  This is different from libpq, which does not allow\nrun-time parameters in the connection string, instead requiring you to supply\nthem in the options parameter.\n\nFor compatibility with libpq, the following special connection parameters are\nsupported:\n\n\t* dbname - The name of the database to connect to\n\t* user - The user to sign in as\n\t* password - The user's password\n\t* host - The host to connect to. Values that start with / are for unix\n\t  domain sockets. (default is localhost)\n\t* port - The port to bind to. (default is 5432)\n\t* sslmode - Whether or not to use SSL (default is require, this is not\n\t  the default for libpq)\n\t* fallback_application_name - An application_name to fall back to if one isn't provided.\n\t* connect_timeout - Maximum wait for connection, in seconds. Zero or\n\t  not specified means wait indefinitely.\n\t* sslcert - Cert file location. The file must contain PEM encoded data.\n\t* sslkey - Key file location. The file must contain PEM encoded data.\n\t* sslrootcert - The location of the root certificate file. The file\n\t  must contain PEM encoded data.\n\nValid values for sslmode are:\n\n\t* disable - No SSL\n\t* require - Always SSL (skip verification)\n\t* verify-ca - Always SSL (verify that the certificate presented by the\n\t  server was signed by a trusted CA)\n\t* verify-full - Always SSL (verify that the certification presented by\n\t  the server was signed by a trusted CA and the server host name\n\t  matches the one in the certificate)\n\nSee http://www.postgresql.org/docs/current/static/libpq-connect.html#LIBPQ-CONNSTRING\nfor more information about connection string parameters.\n\nUse single quotes for values that contain whitespace:\n\n    \"user=pqgotest password='with spaces'\"\n\nA backslash will escape the next character in values:\n\n    \"user=space\\ man password='it\\'s valid'\"\n\nNote that the connection parameter client_encoding (which sets the\ntext encoding for the connection) may be set but must be \"UTF8\",\nmatching with the same rules as Postgres. It is an error to provide\nany other value.\n\nIn addition to the parameters listed above, any run-time parameter that can be\nset at backend start time can be set in the connection string.  For more\ninformation, see\nhttp://www.postgresql.org/docs/current/static/runtime-config.html.\n\nMost environment variables as specified at http://www.postgresql.org/docs/current/static/libpq-envars.html\nsupported by libpq are also supported by pq.  If any of the environment\nvariables not supported by pq are set, pq will panic during connection\nestablishment.  Environment variables have a lower precedence than explicitly\nprovided connection parameters.\n\nThe pgpass mechanism as described in http://www.postgresql.org/docs/current/static/libpq-pgpass.html\nis supported, but on Windows PGPASSFILE must be specified explicitly.\n\n\nQueries\n\n\ndatabase/sql does not dictate any specific format for parameter\nmarkers in query strings, and pq uses the Postgres-native ordinal markers,\nas shown above. The same marker can be reused for the same parameter:\n\n\trows, err := db.Query(`SELECT name FROM users WHERE favorite_fruit = $1\n\t\tOR age BETWEEN $2 AND $2 + 3`, \"orange\", 64)\n\npq does not support the LastInsertId() method of the Result type in database/sql.\nTo return the identifier of an INSERT (or UPDATE or DELETE), use the Postgres\nRETURNING clause with a standard Query or QueryRow call:\n\n\tvar userid int\n\terr := db.QueryRow(`INSERT INTO users(name, favorite_fruit, age)\n\t\tVALUES('beatrice', 'starfruit', 93) RETURNING id`).Scan(&userid)\n\nFor more details on RETURNING, see the Postgres documentation:\n\n\thttp://www.postgresql.org/docs/current/static/sql-insert.html\n\thttp://www.postgresql.org/docs/current/static/sql-update.html\n\thttp://www.postgresql.org/docs/current/static/sql-delete.html\n\nFor additional instructions on querying see the documentation for the database/sql package.\n\n\nData Types\n\n\nParameters pass through driver.DefaultParameterConverter before they are handled\nby this package. When the binary_parameters connection option is enabled,\n[]byte values are sent directly to the backend as data in binary format.\n\nThis package returns the following types for values from the PostgreSQL backend:\n\n\t- integer types smallint, integer, and bigint are returned as int64\n\t- floating-point types real and double precision are returned as float64\n\t- character types char, varchar, and text are returned as string\n\t- temporal types date, time, timetz, timestamp, and timestamptz are\n\t  returned as time.Time\n\t- the boolean type is returned as bool\n\t- the bytea type is returned as []byte\n\nAll other types are returned directly from the backend as []byte values in text format.\n\n\nErrors\n\n\npq may return errors of type *pq.Error which can be interrogated for error details:\n\n        if err, ok := err.(*pq.Error); ok {\n            fmt.Println(\"pq error:\", err.Code.Name())\n        }\n\nSee the pq.Error type for details.\n\n\nBulk imports\n\nYou can perform bulk imports by preparing a statement returned by pq.CopyIn (or\npq.CopyInSchema) in an explicit transaction (sql.Tx). The returned statement\nhandle can then be repeatedly \"executed\" to copy data into the target table.\nAfter all data has been processed you should call Exec() once with no arguments\nto flush all buffered data. Any call to Exec() might return an error which\nshould be handled appropriately, but because of the internal buffering an error\nreturned by Exec() might not be related to the data passed in the call that\nfailed.\n\nCopyIn uses COPY FROM internally. It is not possible to COPY outside of an\nexplicit transaction in pq.\n\nUsage example:\n\n\ttxn, err := db.Begin()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tstmt, err := txn.Prepare(pq.CopyIn(\"users\", \"name\", \"age\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor _, user := range users {\n\t\t_, err = stmt.Exec(user.Name, int64(user.Age))\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n\n\t_, err = stmt.Exec()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = stmt.Close()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\terr = txn.Commit()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\nNotifications\n\n\nPostgreSQL supports a simple publish/subscribe model over database\nconnections.  See http://www.postgresql.org/docs/current/static/sql-notify.html\nfor more information about the general mechanism.\n\nTo start listening for notifications, you first have to open a new connection\nto the database by calling NewListener.  This connection can not be used for\nanything other than LISTEN / NOTIFY.  Calling Listen will open a \"notification\nchannel\"; once a notification channel is open, a notification generated on that\nchannel will effect a send on the Listener.Notify channel.  A notification\nchannel will remain open until Unlisten is called, though connection loss might\nresult in some notifications being lost.  To solve this problem, Listener sends\na nil pointer over the Notify channel any time the connection is re-established\nfollowing a connection loss.  The application can get information about the\nstate of the underlying connection by setting an event callback in the call to\nNewListener.\n\nA single Listener can safely be used from concurrent goroutines, which means\nthat there is often no need to create more than one Listener in your\napplication.  However, a Listener is always connected to a single database, so\nyou will need to create a new Listener instance for every database you want to\nreceive notifications in.\n\nThe channel name in both Listen and Unlisten is case sensitive, and can contain\nany characters legal in an identifier (see\nhttp://www.postgresql.org/docs/current/static/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS\nfor more information).  Note that the channel name will be truncated to 63\nbytes by the PostgreSQL server.\n\nYou can find a complete, working example of Listener usage at\nhttps://godoc.org/github.com/lib/pq/example/listen.\n\n\nKerberos Support\n\n\nIf you need support for Kerberos authentication, add the following to your main\npackage:\n\n\timport \"github.com/lib/pq/auth/kerberos\"\n\n\tfunc init() {\n\t\tpq.RegisterGSSProvider(func() (pq.Gss, error) { return kerberos.NewGSS() })\n\t}\n\nThis package is in a separate module so that users who don't need Kerberos\ndon't have to download unnecessary dependencies.\n\nWhen imported, additional connection string parameters are supported:\n\n\t* krbsrvname - GSS (Kerberos) service name when constructing the\n\t  SPN (default is `postgres`). This will be combined with the host\n\t  to form the full SPN: `krbsrvname/host`.\n\t* krbspn - GSS (Kerberos) SPN. This takes priority over\n\t  `krbsrvname` if present.\n*/\npackage pq\n"
        },
        {
          "name": "encode.go",
          "type": "blob",
          "size": 16.36328125,
          "content": "package pq\n\nimport (\n\t\"bytes\"\n\t\"database/sql/driver\"\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/lib/pq/oid\"\n)\n\nvar time2400Regex = regexp.MustCompile(`^(24:00(?::00(?:\\.0+)?)?)(?:[Z+-].*)?$`)\n\nfunc binaryEncode(parameterStatus *parameterStatus, x interface{}) []byte {\n\tswitch v := x.(type) {\n\tcase []byte:\n\t\treturn v\n\tdefault:\n\t\treturn encode(parameterStatus, x, oid.T_unknown)\n\t}\n}\n\nfunc encode(parameterStatus *parameterStatus, x interface{}, pgtypOid oid.Oid) []byte {\n\tswitch v := x.(type) {\n\tcase int64:\n\t\treturn strconv.AppendInt(nil, v, 10)\n\tcase float64:\n\t\treturn strconv.AppendFloat(nil, v, 'f', -1, 64)\n\tcase []byte:\n\t\tif pgtypOid == oid.T_bytea {\n\t\t\treturn encodeBytea(parameterStatus.serverVersion, v)\n\t\t}\n\n\t\treturn v\n\tcase string:\n\t\tif pgtypOid == oid.T_bytea {\n\t\t\treturn encodeBytea(parameterStatus.serverVersion, []byte(v))\n\t\t}\n\n\t\treturn []byte(v)\n\tcase bool:\n\t\treturn strconv.AppendBool(nil, v)\n\tcase time.Time:\n\t\treturn formatTs(v)\n\n\tdefault:\n\t\terrorf(\"encode: unknown type for %T\", v)\n\t}\n\n\tpanic(\"not reached\")\n}\n\nfunc decode(parameterStatus *parameterStatus, s []byte, typ oid.Oid, f format) interface{} {\n\tswitch f {\n\tcase formatBinary:\n\t\treturn binaryDecode(parameterStatus, s, typ)\n\tcase formatText:\n\t\treturn textDecode(parameterStatus, s, typ)\n\tdefault:\n\t\tpanic(\"not reached\")\n\t}\n}\n\nfunc binaryDecode(parameterStatus *parameterStatus, s []byte, typ oid.Oid) interface{} {\n\tswitch typ {\n\tcase oid.T_bytea:\n\t\treturn s\n\tcase oid.T_int8:\n\t\treturn int64(binary.BigEndian.Uint64(s))\n\tcase oid.T_int4:\n\t\treturn int64(int32(binary.BigEndian.Uint32(s)))\n\tcase oid.T_int2:\n\t\treturn int64(int16(binary.BigEndian.Uint16(s)))\n\tcase oid.T_uuid:\n\t\tb, err := decodeUUIDBinary(s)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\treturn b\n\n\tdefault:\n\t\terrorf(\"don't know how to decode binary parameter of type %d\", uint32(typ))\n\t}\n\n\tpanic(\"not reached\")\n}\n\nfunc textDecode(parameterStatus *parameterStatus, s []byte, typ oid.Oid) interface{} {\n\tswitch typ {\n\tcase oid.T_char, oid.T_varchar, oid.T_text:\n\t\treturn string(s)\n\tcase oid.T_bytea:\n\t\tb, err := parseBytea(s)\n\t\tif err != nil {\n\t\t\terrorf(\"%s\", err)\n\t\t}\n\t\treturn b\n\tcase oid.T_timestamptz:\n\t\treturn parseTs(parameterStatus.currentLocation, string(s))\n\tcase oid.T_timestamp, oid.T_date:\n\t\treturn parseTs(nil, string(s))\n\tcase oid.T_time:\n\t\treturn mustParse(\"15:04:05\", typ, s)\n\tcase oid.T_timetz:\n\t\treturn mustParse(\"15:04:05-07\", typ, s)\n\tcase oid.T_bool:\n\t\treturn s[0] == 't'\n\tcase oid.T_int8, oid.T_int4, oid.T_int2:\n\t\ti, err := strconv.ParseInt(string(s), 10, 64)\n\t\tif err != nil {\n\t\t\terrorf(\"%s\", err)\n\t\t}\n\t\treturn i\n\tcase oid.T_float4, oid.T_float8:\n\t\t// We always use 64 bit parsing, regardless of whether the input text is for\n\t\t// a float4 or float8, because clients expect float64s for all float datatypes\n\t\t// and returning a 32-bit parsed float64 produces lossy results.\n\t\tf, err := strconv.ParseFloat(string(s), 64)\n\t\tif err != nil {\n\t\t\terrorf(\"%s\", err)\n\t\t}\n\t\treturn f\n\t}\n\n\treturn s\n}\n\n// appendEncodedText encodes item in text format as required by COPY\n// and appends to buf\nfunc appendEncodedText(parameterStatus *parameterStatus, buf []byte, x interface{}) []byte {\n\tswitch v := x.(type) {\n\tcase int64:\n\t\treturn strconv.AppendInt(buf, v, 10)\n\tcase float64:\n\t\treturn strconv.AppendFloat(buf, v, 'f', -1, 64)\n\tcase []byte:\n\t\tencodedBytea := encodeBytea(parameterStatus.serverVersion, v)\n\t\treturn appendEscapedText(buf, string(encodedBytea))\n\tcase string:\n\t\treturn appendEscapedText(buf, v)\n\tcase bool:\n\t\treturn strconv.AppendBool(buf, v)\n\tcase time.Time:\n\t\treturn append(buf, formatTs(v)...)\n\tcase nil:\n\t\treturn append(buf, \"\\\\N\"...)\n\tdefault:\n\t\terrorf(\"encode: unknown type for %T\", v)\n\t}\n\n\tpanic(\"not reached\")\n}\n\nfunc appendEscapedText(buf []byte, text string) []byte {\n\tescapeNeeded := false\n\tstartPos := 0\n\tvar c byte\n\n\t// check if we need to escape\n\tfor i := 0; i < len(text); i++ {\n\t\tc = text[i]\n\t\tif c == '\\\\' || c == '\\n' || c == '\\r' || c == '\\t' {\n\t\t\tescapeNeeded = true\n\t\t\tstartPos = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif !escapeNeeded {\n\t\treturn append(buf, text...)\n\t}\n\n\t// copy till first char to escape, iterate the rest\n\tresult := append(buf, text[:startPos]...)\n\tfor i := startPos; i < len(text); i++ {\n\t\tc = text[i]\n\t\tswitch c {\n\t\tcase '\\\\':\n\t\t\tresult = append(result, '\\\\', '\\\\')\n\t\tcase '\\n':\n\t\t\tresult = append(result, '\\\\', 'n')\n\t\tcase '\\r':\n\t\t\tresult = append(result, '\\\\', 'r')\n\t\tcase '\\t':\n\t\t\tresult = append(result, '\\\\', 't')\n\t\tdefault:\n\t\t\tresult = append(result, c)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc mustParse(f string, typ oid.Oid, s []byte) time.Time {\n\tstr := string(s)\n\n\t// Check for a minute and second offset in the timezone.\n\tif typ == oid.T_timestamptz || typ == oid.T_timetz {\n\t\tfor i := 3; i <= 6; i += 3 {\n\t\t\tif str[len(str)-i] == ':' {\n\t\t\t\tf += \":00\"\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Special case for 24:00 time.\n\t// Unfortunately, golang does not parse 24:00 as a proper time.\n\t// In this case, we want to try \"round to the next day\", to differentiate.\n\t// As such, we find if the 24:00 time matches at the beginning; if so,\n\t// we default it back to 00:00 but add a day later.\n\tvar is2400Time bool\n\tswitch typ {\n\tcase oid.T_timetz, oid.T_time:\n\t\tif matches := time2400Regex.FindStringSubmatch(str); matches != nil {\n\t\t\t// Concatenate timezone information at the back.\n\t\t\tstr = \"00:00:00\" + str[len(matches[1]):]\n\t\t\tis2400Time = true\n\t\t}\n\t}\n\tt, err := time.Parse(f, str)\n\tif err != nil {\n\t\terrorf(\"decode: %s\", err)\n\t}\n\tif is2400Time {\n\t\tt = t.Add(24 * time.Hour)\n\t}\n\treturn t\n}\n\nvar errInvalidTimestamp = errors.New(\"invalid timestamp\")\n\ntype timestampParser struct {\n\terr error\n}\n\nfunc (p *timestampParser) expect(str string, char byte, pos int) {\n\tif p.err != nil {\n\t\treturn\n\t}\n\tif pos+1 > len(str) {\n\t\tp.err = errInvalidTimestamp\n\t\treturn\n\t}\n\tif c := str[pos]; c != char && p.err == nil {\n\t\tp.err = fmt.Errorf(\"expected '%v' at position %v; got '%v'\", char, pos, c)\n\t}\n}\n\nfunc (p *timestampParser) mustAtoi(str string, begin int, end int) int {\n\tif p.err != nil {\n\t\treturn 0\n\t}\n\tif begin < 0 || end < 0 || begin > end || end > len(str) {\n\t\tp.err = errInvalidTimestamp\n\t\treturn 0\n\t}\n\tresult, err := strconv.Atoi(str[begin:end])\n\tif err != nil {\n\t\tif p.err == nil {\n\t\t\tp.err = fmt.Errorf(\"expected number; got '%v'\", str)\n\t\t}\n\t\treturn 0\n\t}\n\treturn result\n}\n\n// The location cache caches the time zones typically used by the client.\ntype locationCache struct {\n\tcache map[int]*time.Location\n\tlock  sync.Mutex\n}\n\n// All connections share the same list of timezones. Benchmarking shows that\n// about 5% speed could be gained by putting the cache in the connection and\n// losing the mutex, at the cost of a small amount of memory and a somewhat\n// significant increase in code complexity.\nvar globalLocationCache = newLocationCache()\n\nfunc newLocationCache() *locationCache {\n\treturn &locationCache{cache: make(map[int]*time.Location)}\n}\n\n// Returns the cached timezone for the specified offset, creating and caching\n// it if necessary.\nfunc (c *locationCache) getLocation(offset int) *time.Location {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tlocation, ok := c.cache[offset]\n\tif !ok {\n\t\tlocation = time.FixedZone(\"\", offset)\n\t\tc.cache[offset] = location\n\t}\n\n\treturn location\n}\n\nvar infinityTsEnabled = false\nvar infinityTsNegative time.Time\nvar infinityTsPositive time.Time\n\nconst (\n\tinfinityTsEnabledAlready        = \"pq: infinity timestamp enabled already\"\n\tinfinityTsNegativeMustBeSmaller = \"pq: infinity timestamp: negative value must be smaller (before) than positive\"\n)\n\n// EnableInfinityTs controls the handling of Postgres' \"-infinity\" and\n// \"infinity\" \"timestamp\"s.\n//\n// If EnableInfinityTs is not called, \"-infinity\" and \"infinity\" will return\n// []byte(\"-infinity\") and []byte(\"infinity\") respectively, and potentially\n// cause error \"sql: Scan error on column index 0: unsupported driver -> Scan\n// pair: []uint8 -> *time.Time\", when scanning into a time.Time value.\n//\n// Once EnableInfinityTs has been called, all connections created using this\n// driver will decode Postgres' \"-infinity\" and \"infinity\" for \"timestamp\",\n// \"timestamp with time zone\" and \"date\" types to the predefined minimum and\n// maximum times, respectively.  When encoding time.Time values, any time which\n// equals or precedes the predefined minimum time will be encoded to\n// \"-infinity\".  Any values at or past the maximum time will similarly be\n// encoded to \"infinity\".\n//\n// If EnableInfinityTs is called with negative >= positive, it will panic.\n// Calling EnableInfinityTs after a connection has been established results in\n// undefined behavior.  If EnableInfinityTs is called more than once, it will\n// panic.\nfunc EnableInfinityTs(negative time.Time, positive time.Time) {\n\tif infinityTsEnabled {\n\t\tpanic(infinityTsEnabledAlready)\n\t}\n\tif !negative.Before(positive) {\n\t\tpanic(infinityTsNegativeMustBeSmaller)\n\t}\n\tinfinityTsEnabled = true\n\tinfinityTsNegative = negative\n\tinfinityTsPositive = positive\n}\n\n/*\n * Testing might want to toggle infinityTsEnabled\n */\nfunc disableInfinityTs() {\n\tinfinityTsEnabled = false\n}\n\n// This is a time function specific to the Postgres default DateStyle\n// setting (\"ISO, MDY\"), the only one we currently support. This\n// accounts for the discrepancies between the parsing available with\n// time.Parse and the Postgres date formatting quirks.\nfunc parseTs(currentLocation *time.Location, str string) interface{} {\n\tswitch str {\n\tcase \"-infinity\":\n\t\tif infinityTsEnabled {\n\t\t\treturn infinityTsNegative\n\t\t}\n\t\treturn []byte(str)\n\tcase \"infinity\":\n\t\tif infinityTsEnabled {\n\t\t\treturn infinityTsPositive\n\t\t}\n\t\treturn []byte(str)\n\t}\n\tt, err := ParseTimestamp(currentLocation, str)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn t\n}\n\n// ParseTimestamp parses Postgres' text format. It returns a time.Time in\n// currentLocation iff that time's offset agrees with the offset sent from the\n// Postgres server. Otherwise, ParseTimestamp returns a time.Time with the\n// fixed offset offset provided by the Postgres server.\nfunc ParseTimestamp(currentLocation *time.Location, str string) (time.Time, error) {\n\tp := timestampParser{}\n\n\tmonSep := strings.IndexRune(str, '-')\n\t// this is Gregorian year, not ISO Year\n\t// In Gregorian system, the year 1 BC is followed by AD 1\n\tyear := p.mustAtoi(str, 0, monSep)\n\tdaySep := monSep + 3\n\tmonth := p.mustAtoi(str, monSep+1, daySep)\n\tp.expect(str, '-', daySep)\n\ttimeSep := daySep + 3\n\tday := p.mustAtoi(str, daySep+1, timeSep)\n\n\tminLen := monSep + len(\"01-01\") + 1\n\n\tisBC := strings.HasSuffix(str, \" BC\")\n\tif isBC {\n\t\tminLen += 3\n\t}\n\n\tvar hour, minute, second int\n\tif len(str) > minLen {\n\t\tp.expect(str, ' ', timeSep)\n\t\tminSep := timeSep + 3\n\t\tp.expect(str, ':', minSep)\n\t\thour = p.mustAtoi(str, timeSep+1, minSep)\n\t\tsecSep := minSep + 3\n\t\tp.expect(str, ':', secSep)\n\t\tminute = p.mustAtoi(str, minSep+1, secSep)\n\t\tsecEnd := secSep + 3\n\t\tsecond = p.mustAtoi(str, secSep+1, secEnd)\n\t}\n\tremainderIdx := monSep + len(\"01-01 00:00:00\") + 1\n\t// Three optional (but ordered) sections follow: the\n\t// fractional seconds, the time zone offset, and the BC\n\t// designation. We set them up here and adjust the other\n\t// offsets if the preceding sections exist.\n\n\tnanoSec := 0\n\ttzOff := 0\n\n\tif remainderIdx < len(str) && str[remainderIdx] == '.' {\n\t\tfracStart := remainderIdx + 1\n\t\tfracOff := strings.IndexAny(str[fracStart:], \"-+Z \")\n\t\tif fracOff < 0 {\n\t\t\tfracOff = len(str) - fracStart\n\t\t}\n\t\tfracSec := p.mustAtoi(str, fracStart, fracStart+fracOff)\n\t\tnanoSec = fracSec * (1000000000 / int(math.Pow(10, float64(fracOff))))\n\n\t\tremainderIdx += fracOff + 1\n\t}\n\tif tzStart := remainderIdx; tzStart < len(str) && (str[tzStart] == '-' || str[tzStart] == '+') {\n\t\t// time zone separator is always '-' or '+' or 'Z' (UTC is +00)\n\t\tvar tzSign int\n\t\tswitch c := str[tzStart]; c {\n\t\tcase '-':\n\t\t\ttzSign = -1\n\t\tcase '+':\n\t\t\ttzSign = +1\n\t\tdefault:\n\t\t\treturn time.Time{}, fmt.Errorf(\"expected '-' or '+' at position %v; got %v\", tzStart, c)\n\t\t}\n\t\ttzHours := p.mustAtoi(str, tzStart+1, tzStart+3)\n\t\tremainderIdx += 3\n\t\tvar tzMin, tzSec int\n\t\tif remainderIdx < len(str) && str[remainderIdx] == ':' {\n\t\t\ttzMin = p.mustAtoi(str, remainderIdx+1, remainderIdx+3)\n\t\t\tremainderIdx += 3\n\t\t}\n\t\tif remainderIdx < len(str) && str[remainderIdx] == ':' {\n\t\t\ttzSec = p.mustAtoi(str, remainderIdx+1, remainderIdx+3)\n\t\t\tremainderIdx += 3\n\t\t}\n\t\ttzOff = tzSign * ((tzHours * 60 * 60) + (tzMin * 60) + tzSec)\n\t} else if tzStart < len(str) && str[tzStart] == 'Z' {\n\t\t// time zone Z separator indicates UTC is +00\n\t\tremainderIdx += 1\n\t}\n\n\tvar isoYear int\n\n\tif isBC {\n\t\tisoYear = 1 - year\n\t\tremainderIdx += 3\n\t} else {\n\t\tisoYear = year\n\t}\n\tif remainderIdx < len(str) {\n\t\treturn time.Time{}, fmt.Errorf(\"expected end of input, got %v\", str[remainderIdx:])\n\t}\n\tt := time.Date(isoYear, time.Month(month), day,\n\t\thour, minute, second, nanoSec,\n\t\tglobalLocationCache.getLocation(tzOff))\n\n\tif currentLocation != nil {\n\t\t// Set the location of the returned Time based on the session's\n\t\t// TimeZone value, but only if the local time zone database agrees with\n\t\t// the remote database on the offset.\n\t\tlt := t.In(currentLocation)\n\t\t_, newOff := lt.Zone()\n\t\tif newOff == tzOff {\n\t\t\tt = lt\n\t\t}\n\t}\n\n\treturn t, p.err\n}\n\n// formatTs formats t into a format postgres understands.\nfunc formatTs(t time.Time) []byte {\n\tif infinityTsEnabled {\n\t\t// t <= -infinity : ! (t > -infinity)\n\t\tif !t.After(infinityTsNegative) {\n\t\t\treturn []byte(\"-infinity\")\n\t\t}\n\t\t// t >= infinity : ! (!t < infinity)\n\t\tif !t.Before(infinityTsPositive) {\n\t\t\treturn []byte(\"infinity\")\n\t\t}\n\t}\n\treturn FormatTimestamp(t)\n}\n\n// FormatTimestamp formats t into Postgres' text format for timestamps.\nfunc FormatTimestamp(t time.Time) []byte {\n\t// Need to send dates before 0001 A.D. with \" BC\" suffix, instead of the\n\t// minus sign preferred by Go.\n\t// Beware, \"0000\" in ISO is \"1 BC\", \"-0001\" is \"2 BC\" and so on\n\tbc := false\n\tif t.Year() <= 0 {\n\t\t// flip year sign, and add 1, e.g: \"0\" will be \"1\", and \"-10\" will be \"11\"\n\t\tt = t.AddDate((-t.Year())*2+1, 0, 0)\n\t\tbc = true\n\t}\n\tb := []byte(t.Format(\"2006-01-02 15:04:05.999999999Z07:00\"))\n\n\t_, offset := t.Zone()\n\toffset %= 60\n\tif offset != 0 {\n\t\t// RFC3339Nano already printed the minus sign\n\t\tif offset < 0 {\n\t\t\toffset = -offset\n\t\t}\n\n\t\tb = append(b, ':')\n\t\tif offset < 10 {\n\t\t\tb = append(b, '0')\n\t\t}\n\t\tb = strconv.AppendInt(b, int64(offset), 10)\n\t}\n\n\tif bc {\n\t\tb = append(b, \" BC\"...)\n\t}\n\treturn b\n}\n\n// Parse a bytea value received from the server.  Both \"hex\" and the legacy\n// \"escape\" format are supported.\nfunc parseBytea(s []byte) (result []byte, err error) {\n\tif len(s) >= 2 && bytes.Equal(s[:2], []byte(\"\\\\x\")) {\n\t\t// bytea_output = hex\n\t\ts = s[2:] // trim off leading \"\\\\x\"\n\t\tresult = make([]byte, hex.DecodedLen(len(s)))\n\t\t_, err := hex.Decode(result, s)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\t// bytea_output = escape\n\t\tfor len(s) > 0 {\n\t\t\tif s[0] == '\\\\' {\n\t\t\t\t// escaped '\\\\'\n\t\t\t\tif len(s) >= 2 && s[1] == '\\\\' {\n\t\t\t\t\tresult = append(result, '\\\\')\n\t\t\t\t\ts = s[2:]\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// '\\\\' followed by an octal number\n\t\t\t\tif len(s) < 4 {\n\t\t\t\t\treturn nil, fmt.Errorf(\"invalid bytea sequence %v\", s)\n\t\t\t\t}\n\t\t\t\tr, err := strconv.ParseUint(string(s[1:4]), 8, 8)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"could not parse bytea value: %s\", err.Error())\n\t\t\t\t}\n\t\t\t\tresult = append(result, byte(r))\n\t\t\t\ts = s[4:]\n\t\t\t} else {\n\t\t\t\t// We hit an unescaped, raw byte.  Try to read in as many as\n\t\t\t\t// possible in one go.\n\t\t\t\ti := bytes.IndexByte(s, '\\\\')\n\t\t\t\tif i == -1 {\n\t\t\t\t\tresult = append(result, s...)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tresult = append(result, s[:i]...)\n\t\t\t\ts = s[i:]\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result, nil\n}\n\nfunc encodeBytea(serverVersion int, v []byte) (result []byte) {\n\tif serverVersion >= 90000 {\n\t\t// Use the hex format if we know that the server supports it\n\t\tresult = make([]byte, 2+hex.EncodedLen(len(v)))\n\t\tresult[0] = '\\\\'\n\t\tresult[1] = 'x'\n\t\thex.Encode(result[2:], v)\n\t} else {\n\t\t// .. or resort to \"escape\"\n\t\tfor _, b := range v {\n\t\t\tif b == '\\\\' {\n\t\t\t\tresult = append(result, '\\\\', '\\\\')\n\t\t\t} else if b < 0x20 || b > 0x7e {\n\t\t\t\tresult = append(result, []byte(fmt.Sprintf(\"\\\\%03o\", b))...)\n\t\t\t} else {\n\t\t\t\tresult = append(result, b)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}\n\n// NullTime represents a time.Time that may be null. NullTime implements the\n// sql.Scanner interface so it can be used as a scan destination, similar to\n// sql.NullString.\ntype NullTime struct {\n\tTime  time.Time\n\tValid bool // Valid is true if Time is not NULL\n}\n\n// Scan implements the Scanner interface.\nfunc (nt *NullTime) Scan(value interface{}) error {\n\tnt.Time, nt.Valid = value.(time.Time)\n\treturn nil\n}\n\n// Value implements the driver Valuer interface.\nfunc (nt NullTime) Value() (driver.Value, error) {\n\tif !nt.Valid {\n\t\treturn nil, nil\n\t}\n\treturn nt.Time, nil\n}\n"
        },
        {
          "name": "encode_test.go",
          "type": "blob",
          "size": 26.783203125,
          "content": "package pq\n\nimport (\n\t\"bytes\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/lib/pq/oid\"\n)\n\nfunc TestScanTimestamp(t *testing.T) {\n\tvar nt NullTime\n\ttn := time.Now()\n\tnt.Scan(tn)\n\tif !nt.Valid {\n\t\tt.Errorf(\"Expected Valid=false\")\n\t}\n\tif nt.Time != tn {\n\t\tt.Errorf(\"Time value mismatch\")\n\t}\n}\n\nfunc TestScanNilTimestamp(t *testing.T) {\n\tvar nt NullTime\n\tnt.Scan(nil)\n\tif nt.Valid {\n\t\tt.Errorf(\"Expected Valid=false\")\n\t}\n}\n\nvar timeTests = []struct {\n\tstr     string\n\ttimeval time.Time\n}{\n\t{\"22001-02-03\", time.Date(22001, time.February, 3, 0, 0, 0, 0, time.FixedZone(\"\", 0))},\n\t{\"2001-02-03\", time.Date(2001, time.February, 3, 0, 0, 0, 0, time.FixedZone(\"\", 0))},\n\t{\"0001-12-31 BC\", time.Date(0, time.December, 31, 0, 0, 0, 0, time.FixedZone(\"\", 0))},\n\t{\"2001-02-03 BC\", time.Date(-2000, time.February, 3, 0, 0, 0, 0, time.FixedZone(\"\", 0))},\n\t{\"2001-02-03 04:05:06\", time.Date(2001, time.February, 3, 4, 5, 6, 0, time.FixedZone(\"\", 0))},\n\t{\"2001-02-03 04:05:06.000001\", time.Date(2001, time.February, 3, 4, 5, 6, 1000, time.FixedZone(\"\", 0))},\n\t{\"2001-02-03 04:05:06.00001\", time.Date(2001, time.February, 3, 4, 5, 6, 10000, time.FixedZone(\"\", 0))},\n\t{\"2001-02-03 04:05:06.0001\", time.Date(2001, time.February, 3, 4, 5, 6, 100000, time.FixedZone(\"\", 0))},\n\t{\"2001-02-03 04:05:06.001\", time.Date(2001, time.February, 3, 4, 5, 6, 1000000, time.FixedZone(\"\", 0))},\n\t{\"2001-02-03 04:05:06.01\", time.Date(2001, time.February, 3, 4, 5, 6, 10000000, time.FixedZone(\"\", 0))},\n\t{\"2001-02-03 04:05:06.1\", time.Date(2001, time.February, 3, 4, 5, 6, 100000000, time.FixedZone(\"\", 0))},\n\t{\"2001-02-03 04:05:06.12\", time.Date(2001, time.February, 3, 4, 5, 6, 120000000, time.FixedZone(\"\", 0))},\n\t{\"2001-02-03 04:05:06.123\", time.Date(2001, time.February, 3, 4, 5, 6, 123000000, time.FixedZone(\"\", 0))},\n\t{\"2001-02-03 04:05:06.1234\", time.Date(2001, time.February, 3, 4, 5, 6, 123400000, time.FixedZone(\"\", 0))},\n\t{\"2001-02-03 04:05:06.12345\", time.Date(2001, time.February, 3, 4, 5, 6, 123450000, time.FixedZone(\"\", 0))},\n\t{\"2001-02-03 04:05:06.123456\", time.Date(2001, time.February, 3, 4, 5, 6, 123456000, time.FixedZone(\"\", 0))},\n\t{\"2001-02-03 04:05:06.123-07\", time.Date(2001, time.February, 3, 4, 5, 6, 123000000,\n\t\ttime.FixedZone(\"\", -7*60*60))},\n\t{\"2001-02-03 04:05:06-07\", time.Date(2001, time.February, 3, 4, 5, 6, 0,\n\t\ttime.FixedZone(\"\", -7*60*60))},\n\t{\"2001-02-03 04:05:06-07:42\", time.Date(2001, time.February, 3, 4, 5, 6, 0,\n\t\ttime.FixedZone(\"\", -(7*60*60+42*60)))},\n\t{\"2001-02-03 04:05:06-07:30:09\", time.Date(2001, time.February, 3, 4, 5, 6, 0,\n\t\ttime.FixedZone(\"\", -(7*60*60+30*60+9)))},\n\t{\"2001-02-03 04:05:06+07:30:09\", time.Date(2001, time.February, 3, 4, 5, 6, 0,\n\t\ttime.FixedZone(\"\", +(7*60*60+30*60+9)))},\n\t{\"2001-02-03 04:05:06+07\", time.Date(2001, time.February, 3, 4, 5, 6, 0,\n\t\ttime.FixedZone(\"\", 7*60*60))},\n\t{\"0011-02-03 04:05:06 BC\", time.Date(-10, time.February, 3, 4, 5, 6, 0, time.FixedZone(\"\", 0))},\n\t{\"0011-02-03 04:05:06.123 BC\", time.Date(-10, time.February, 3, 4, 5, 6, 123000000, time.FixedZone(\"\", 0))},\n\t{\"0011-02-03 04:05:06.123-07 BC\", time.Date(-10, time.February, 3, 4, 5, 6, 123000000,\n\t\ttime.FixedZone(\"\", -7*60*60))},\n\t{\"0001-02-03 04:05:06.123\", time.Date(1, time.February, 3, 4, 5, 6, 123000000, time.FixedZone(\"\", 0))},\n\t{\"0001-02-03 04:05:06.123 BC\", time.Date(1, time.February, 3, 4, 5, 6, 123000000, time.FixedZone(\"\", 0)).AddDate(-1, 0, 0)},\n\t{\"0001-02-03 04:05:06.123 BC\", time.Date(0, time.February, 3, 4, 5, 6, 123000000, time.FixedZone(\"\", 0))},\n\t{\"0002-02-03 04:05:06.123 BC\", time.Date(0, time.February, 3, 4, 5, 6, 123000000, time.FixedZone(\"\", 0)).AddDate(-1, 0, 0)},\n\t{\"0002-02-03 04:05:06.123 BC\", time.Date(-1, time.February, 3, 4, 5, 6, 123000000, time.FixedZone(\"\", 0))},\n\t{\"12345-02-03 04:05:06.1\", time.Date(12345, time.February, 3, 4, 5, 6, 100000000, time.FixedZone(\"\", 0))},\n\t{\"123456-02-03 04:05:06.1\", time.Date(123456, time.February, 3, 4, 5, 6, 100000000, time.FixedZone(\"\", 0))},\n}\n\n// Test that parsing the string results in the expected value.\nfunc TestParseTs(t *testing.T) {\n\tfor i, tt := range timeTests {\n\t\tval, err := ParseTimestamp(nil, tt.str)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%d: got error: %v\", i, err)\n\t\t} else if val.String() != tt.timeval.String() {\n\t\t\tt.Errorf(\"%d: expected to parse %q into %q; got %q\",\n\t\t\t\ti, tt.str, tt.timeval, val)\n\t\t}\n\t}\n}\n\nvar timeErrorTests = []string{\n\t\"BC\",\n\t\" BC\",\n\t\"2001\",\n\t\"2001-2-03\",\n\t\"2001-02-3\",\n\t\"2001-02-03 \",\n\t\"2001-02-03 B\",\n\t\"2001-02-03 04\",\n\t\"2001-02-03 04:\",\n\t\"2001-02-03 04:05\",\n\t\"2001-02-03 04:05 B\",\n\t\"2001-02-03 04:05 BC\",\n\t\"2001-02-03 04:05:\",\n\t\"2001-02-03 04:05:6\",\n\t\"2001-02-03 04:05:06 B\",\n\t\"2001-02-03 04:05:06BC\",\n\t\"2001-02-03 04:05:06.123 B\",\n}\n\n// Test that parsing the string results in an error.\nfunc TestParseTsErrors(t *testing.T) {\n\tfor i, tt := range timeErrorTests {\n\t\t_, err := ParseTimestamp(nil, tt)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"%d: expected an error from parsing: %v\", i, tt)\n\t\t}\n\t}\n}\n\n// Now test that sending the value into the database and parsing it back\n// returns the same time.Time value.\nfunc TestEncodeAndParseTs(t *testing.T) {\n\tdb, err := openTestConnConninfo(\"timezone='Etc/UTC'\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\tfor i, tt := range timeTests {\n\t\tvar dbstr string\n\t\terr = db.QueryRow(\"SELECT ($1::timestamptz)::text\", tt.timeval).Scan(&dbstr)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%d: could not send value %q to the database: %s\", i, tt.timeval, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tval, err := ParseTimestamp(nil, dbstr)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%d: could not parse value %q: %s\", i, dbstr, err)\n\t\t\tcontinue\n\t\t}\n\t\tval = val.In(tt.timeval.Location())\n\t\tif val.String() != tt.timeval.String() {\n\t\t\tt.Errorf(\"%d: expected to parse %q into %q; got %q\", i, dbstr, tt.timeval, val)\n\t\t}\n\t}\n}\n\nvar formatTimeTests = []struct {\n\ttime     time.Time\n\texpected string\n}{\n\t{time.Time{}, \"0001-01-01 00:00:00Z\"},\n\t{time.Date(2001, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", 0)), \"2001-02-03 04:05:06.123456789Z\"},\n\t{time.Date(2001, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", 2*60*60)), \"2001-02-03 04:05:06.123456789+02:00\"},\n\t{time.Date(2001, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", -6*60*60)), \"2001-02-03 04:05:06.123456789-06:00\"},\n\t{time.Date(2001, time.February, 3, 4, 5, 6, 0, time.FixedZone(\"\", -(7*60*60+30*60+9))), \"2001-02-03 04:05:06-07:30:09\"},\n\n\t{time.Date(1, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", 0)), \"0001-02-03 04:05:06.123456789Z\"},\n\t{time.Date(1, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", 2*60*60)), \"0001-02-03 04:05:06.123456789+02:00\"},\n\t{time.Date(1, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", -6*60*60)), \"0001-02-03 04:05:06.123456789-06:00\"},\n\n\t{time.Date(0, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", 0)), \"0001-02-03 04:05:06.123456789Z BC\"},\n\t{time.Date(0, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", 2*60*60)), \"0001-02-03 04:05:06.123456789+02:00 BC\"},\n\t{time.Date(0, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", -6*60*60)), \"0001-02-03 04:05:06.123456789-06:00 BC\"},\n\n\t{time.Date(1, time.February, 3, 4, 5, 6, 0, time.FixedZone(\"\", -(7*60*60+30*60+9))), \"0001-02-03 04:05:06-07:30:09\"},\n\t{time.Date(0, time.February, 3, 4, 5, 6, 0, time.FixedZone(\"\", -(7*60*60+30*60+9))), \"0001-02-03 04:05:06-07:30:09 BC\"},\n}\n\nfunc TestFormatTs(t *testing.T) {\n\tfor i, tt := range formatTimeTests {\n\t\tval := string(formatTs(tt.time))\n\t\tif val != tt.expected {\n\t\t\tt.Errorf(\"%d: incorrect time format %q, want %q\", i, val, tt.expected)\n\t\t}\n\t}\n}\n\nfunc TestFormatTsBackend(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tvar str string\n\terr := db.QueryRow(\"SELECT '2001-02-03T04:05:06.007-08:09:10'::time::text\").Scan(&str)\n\tif err == nil {\n\t\tt.Fatalf(\"PostgreSQL is accepting an ISO timestamp input for time\")\n\t}\n\n\tfor i, tt := range formatTimeTests {\n\t\tfor _, typ := range []string{\"date\", \"time\", \"timetz\", \"timestamp\", \"timestamptz\"} {\n\t\t\terr = db.QueryRow(\"SELECT $1::\"+typ+\"::text\", tt.time).Scan(&str)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"%d: incorrect time format for %v on the backend: %v\", i, typ, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestTimeWithoutTimezone(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer tx.Rollback()\n\n\tfor _, tc := range []struct {\n\t\trefTime      string\n\t\texpectedTime time.Time\n\t}{\n\t\t{\"11:59:59\", time.Date(0, 1, 1, 11, 59, 59, 0, time.UTC)},\n\t\t{\"24:00\", time.Date(0, 1, 2, 0, 0, 0, 0, time.UTC)},\n\t\t{\"24:00:00\", time.Date(0, 1, 2, 0, 0, 0, 0, time.UTC)},\n\t\t{\"24:00:00.0\", time.Date(0, 1, 2, 0, 0, 0, 0, time.UTC)},\n\t\t{\"24:00:00.000000\", time.Date(0, 1, 2, 0, 0, 0, 0, time.UTC)},\n\t} {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"%s => %s\", tc.refTime, tc.expectedTime.Format(time.RFC3339)),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tvar gotTime time.Time\n\t\t\t\trow := tx.QueryRow(\"select $1::time\", tc.refTime)\n\t\t\t\terr = row.Scan(&gotTime)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\tif !tc.expectedTime.Equal(gotTime) {\n\t\t\t\t\tt.Errorf(\"timestamps not equal: %s != %s\", tc.expectedTime, gotTime)\n\t\t\t\t}\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc TestTimeWithTimezone(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer tx.Rollback()\n\n\tfor _, tc := range []struct {\n\t\trefTime      string\n\t\texpectedTime time.Time\n\t}{\n\t\t{\"11:59:59+00:00\", time.Date(0, 1, 1, 11, 59, 59, 0, time.UTC)},\n\t\t{\"11:59:59+04:00\", time.Date(0, 1, 1, 11, 59, 59, 0, time.FixedZone(\"+04\", 4*60*60))},\n\t\t{\"11:59:59+04:01:02\", time.Date(0, 1, 1, 11, 59, 59, 0, time.FixedZone(\"+04:01:02\", 4*60*60+1*60+2))},\n\t\t{\"11:59:59-04:01:02\", time.Date(0, 1, 1, 11, 59, 59, 0, time.FixedZone(\"-04:01:02\", -(4*60*60+1*60+2)))},\n\t\t{\"24:00+00\", time.Date(0, 1, 2, 0, 0, 0, 0, time.UTC)},\n\t\t{\"24:00Z\", time.Date(0, 1, 2, 0, 0, 0, 0, time.UTC)},\n\t\t{\"24:00-04:00\", time.Date(0, 1, 2, 0, 0, 0, 0, time.FixedZone(\"-04\", -4*60*60))},\n\t\t{\"24:00:00+00\", time.Date(0, 1, 2, 0, 0, 0, 0, time.UTC)},\n\t\t{\"24:00:00.0+00\", time.Date(0, 1, 2, 0, 0, 0, 0, time.UTC)},\n\t\t{\"24:00:00.000000+00\", time.Date(0, 1, 2, 0, 0, 0, 0, time.UTC)},\n\t} {\n\t\tt.Run(\n\t\t\tfmt.Sprintf(\"%s => %s\", tc.refTime, tc.expectedTime.Format(time.RFC3339)),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tvar gotTime time.Time\n\t\t\t\trow := tx.QueryRow(\"select $1::timetz\", tc.refTime)\n\t\t\t\terr = row.Scan(&gotTime)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\tif !tc.expectedTime.Equal(gotTime) {\n\t\t\t\t\tt.Errorf(\"timestamps not equal: %s != %s\", tc.expectedTime, gotTime)\n\t\t\t\t}\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc TestTimestampWithTimeZone(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer tx.Rollback()\n\n\t// try several different locations, all included in Go's zoneinfo.zip\n\tfor _, locName := range []string{\n\t\t\"UTC\",\n\t\t\"America/Chicago\",\n\t\t\"America/New_York\",\n\t\t\"Australia/Darwin\",\n\t\t\"Australia/Perth\",\n\t} {\n\t\tloc, err := time.LoadLocation(locName)\n\t\tif err != nil {\n\t\t\tt.Logf(\"Could not load time zone %s - skipping\", locName)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Postgres timestamps have a resolution of 1 microsecond, so don't\n\t\t// use the full range of the Nanosecond argument\n\t\trefTime := time.Date(2012, 11, 6, 10, 23, 42, 123456000, loc)\n\n\t\tfor _, pgTimeZone := range []string{\"US/Eastern\", \"Australia/Darwin\"} {\n\t\t\t// Switch Postgres's timezone to test different output timestamp formats\n\t\t\t_, err = tx.Exec(fmt.Sprintf(\"set time zone '%s'\", pgTimeZone))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tvar gotTime time.Time\n\t\t\trow := tx.QueryRow(\"select $1::timestamp with time zone\", refTime)\n\t\t\terr = row.Scan(&gotTime)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif !refTime.Equal(gotTime) {\n\t\t\t\tt.Errorf(\"timestamps not equal: %s != %s\", refTime, gotTime)\n\t\t\t}\n\n\t\t\t// check that the time zone is set correctly based on TimeZone\n\t\t\tpgLoc, err := time.LoadLocation(pgTimeZone)\n\t\t\tif err != nil {\n\t\t\t\tt.Logf(\"Could not load time zone %s - skipping\", pgLoc)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttranslated := refTime.In(pgLoc)\n\t\t\tif translated.String() != gotTime.String() {\n\t\t\t\tt.Errorf(\"timestamps not equal: %s != %s\", translated, gotTime)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestTimestampWithOutTimezone(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ttest := func(ts, pgts string) {\n\t\tr, err := db.Query(\"SELECT $1::timestamp\", pgts)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not run query: %v\", err)\n\t\t}\n\n\t\tif !r.Next() {\n\t\t\tt.Fatal(\"Expected at least one row\")\n\t\t}\n\n\t\tvar result time.Time\n\t\terr = r.Scan(&result)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Did not expect error scanning row: %v\", err)\n\t\t}\n\n\t\texpected, err := time.Parse(time.RFC3339, ts)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Could not parse test time literal: %v\", err)\n\t\t}\n\n\t\tif !result.Equal(expected) {\n\t\t\tt.Fatalf(\"Expected time to match %v: got mismatch %v\",\n\t\t\t\texpected, result)\n\t\t}\n\n\t\tif r.Next() {\n\t\t\tt.Fatal(\"Expected only one row\")\n\t\t}\n\t}\n\n\ttest(\"2000-01-01T00:00:00Z\", \"2000-01-01T00:00:00\")\n\n\t// Test higher precision time\n\ttest(\"2013-01-04T20:14:58.80033Z\", \"2013-01-04 20:14:58.80033\")\n}\n\nfunc TestInfinityTimestamp(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\tvar err error\n\tvar resultT time.Time\n\n\texpectedErrorStrRegexp := regexp.MustCompile(\n\t\t`^sql: Scan error on column index 0(, name \"timestamp(tz)?\"|): unsupported`)\n\n\ttype testCases []struct {\n\t\tQuery                  string\n\t\tParam                  string\n\t\tExpectedErrorStrRegexp *regexp.Regexp\n\t\tExpectedVal            interface{}\n\t}\n\ttc := testCases{\n\t\t{\"SELECT $1::timestamp\", \"-infinity\", expectedErrorStrRegexp, \"-infinity\"},\n\t\t{\"SELECT $1::timestamptz\", \"-infinity\", expectedErrorStrRegexp, \"-infinity\"},\n\t\t{\"SELECT $1::timestamp\", \"infinity\", expectedErrorStrRegexp, \"infinity\"},\n\t\t{\"SELECT $1::timestamptz\", \"infinity\", expectedErrorStrRegexp, \"infinity\"},\n\t}\n\t// try to assert []byte to time.Time\n\tfor _, q := range tc {\n\t\terr = db.QueryRow(q.Query, q.Param).Scan(&resultT)\n\t\tif err == nil || !q.ExpectedErrorStrRegexp.MatchString(err.Error()) {\n\t\t\tt.Errorf(\"Scanning -/+infinity, expected error to match regexp %q, got %q\",\n\t\t\t\tq.ExpectedErrorStrRegexp, err)\n\t\t}\n\t}\n\t// yield []byte\n\tfor _, q := range tc {\n\t\tvar resultI interface{}\n\t\terr = db.QueryRow(q.Query, q.Param).Scan(&resultI)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Scanning -/+infinity, expected no error, got %q\", err)\n\t\t}\n\t\tresult, ok := resultI.([]byte)\n\t\tif !ok {\n\t\t\tt.Errorf(\"Scanning -/+infinity, expected []byte, got %#v\", resultI)\n\t\t}\n\t\tif string(result) != q.ExpectedVal {\n\t\t\tt.Errorf(\"Scanning -/+infinity, expected %q, got %q\", q.ExpectedVal, result)\n\t\t}\n\t}\n\n\ty1500 := time.Date(1500, time.January, 1, 0, 0, 0, 0, time.UTC)\n\ty2500 := time.Date(2500, time.January, 1, 0, 0, 0, 0, time.UTC)\n\tEnableInfinityTs(y1500, y2500)\n\n\terr = db.QueryRow(\"SELECT $1::timestamp\", \"infinity\").Scan(&resultT)\n\tif err != nil {\n\t\tt.Errorf(\"Scanning infinity, expected no error, got %q\", err)\n\t}\n\tif !resultT.Equal(y2500) {\n\t\tt.Errorf(\"Scanning infinity, expected %q, got %q\", y2500, resultT)\n\t}\n\n\terr = db.QueryRow(\"SELECT $1::timestamptz\", \"infinity\").Scan(&resultT)\n\tif err != nil {\n\t\tt.Errorf(\"Scanning infinity, expected no error, got %q\", err)\n\t}\n\tif !resultT.Equal(y2500) {\n\t\tt.Errorf(\"Scanning Infinity, expected time %q, got %q\", y2500, resultT.String())\n\t}\n\n\terr = db.QueryRow(\"SELECT $1::timestamp\", \"-infinity\").Scan(&resultT)\n\tif err != nil {\n\t\tt.Errorf(\"Scanning -infinity, expected no error, got %q\", err)\n\t}\n\tif !resultT.Equal(y1500) {\n\t\tt.Errorf(\"Scanning -infinity, expected time %q, got %q\", y1500, resultT.String())\n\t}\n\n\terr = db.QueryRow(\"SELECT $1::timestamptz\", \"-infinity\").Scan(&resultT)\n\tif err != nil {\n\t\tt.Errorf(\"Scanning -infinity, expected no error, got %q\", err)\n\t}\n\tif !resultT.Equal(y1500) {\n\t\tt.Errorf(\"Scanning -infinity, expected time %q, got %q\", y1500, resultT.String())\n\t}\n\n\tym1500 := time.Date(-1500, time.January, 1, 0, 0, 0, 0, time.UTC)\n\ty11500 := time.Date(11500, time.January, 1, 0, 0, 0, 0, time.UTC)\n\tvar s string\n\terr = db.QueryRow(\"SELECT $1::timestamp::text\", ym1500).Scan(&s)\n\tif err != nil {\n\t\tt.Errorf(\"Encoding -infinity, expected no error, got %q\", err)\n\t}\n\tif s != \"-infinity\" {\n\t\tt.Errorf(\"Encoding -infinity, expected %q, got %q\", \"-infinity\", s)\n\t}\n\terr = db.QueryRow(\"SELECT $1::timestamptz::text\", ym1500).Scan(&s)\n\tif err != nil {\n\t\tt.Errorf(\"Encoding -infinity, expected no error, got %q\", err)\n\t}\n\tif s != \"-infinity\" {\n\t\tt.Errorf(\"Encoding -infinity, expected %q, got %q\", \"-infinity\", s)\n\t}\n\n\terr = db.QueryRow(\"SELECT $1::timestamp::text\", y11500).Scan(&s)\n\tif err != nil {\n\t\tt.Errorf(\"Encoding infinity, expected no error, got %q\", err)\n\t}\n\tif s != \"infinity\" {\n\t\tt.Errorf(\"Encoding infinity, expected %q, got %q\", \"infinity\", s)\n\t}\n\terr = db.QueryRow(\"SELECT $1::timestamptz::text\", y11500).Scan(&s)\n\tif err != nil {\n\t\tt.Errorf(\"Encoding infinity, expected no error, got %q\", err)\n\t}\n\tif s != \"infinity\" {\n\t\tt.Errorf(\"Encoding infinity, expected %q, got %q\", \"infinity\", s)\n\t}\n\n\tdisableInfinityTs()\n\n\tvar panicErrorString string\n\tfunc() {\n\t\tdefer func() {\n\t\t\tpanicErrorString, _ = recover().(string)\n\t\t}()\n\t\tEnableInfinityTs(y2500, y1500)\n\t}()\n\tif panicErrorString != infinityTsNegativeMustBeSmaller {\n\t\tt.Errorf(\"Expected error, %q, got %q\", infinityTsNegativeMustBeSmaller, panicErrorString)\n\t}\n}\n\nfunc TestStringWithNul(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\thello0world := string(\"hello\\x00world\")\n\t_, err := db.Query(\"SELECT $1::text\", &hello0world)\n\tif err == nil {\n\t\tt.Fatal(\"Postgres accepts a string with nul in it; \" +\n\t\t\t\"injection attacks may be plausible\")\n\t}\n}\n\nfunc TestByteSliceToText(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tb := []byte(\"hello world\")\n\trow := db.QueryRow(\"SELECT $1::text\", b)\n\n\tvar result []byte\n\terr := row.Scan(&result)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif string(result) != string(b) {\n\t\tt.Fatalf(\"expected %v but got %v\", b, result)\n\t}\n}\n\nfunc TestStringToBytea(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tb := \"hello world\"\n\trow := db.QueryRow(\"SELECT $1::bytea\", b)\n\n\tvar result []byte\n\terr := row.Scan(&result)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !bytes.Equal(result, []byte(b)) {\n\t\tt.Fatalf(\"expected %v but got %v\", b, result)\n\t}\n}\n\nfunc TestTextByteSliceToUUID(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tb := []byte(\"a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11\")\n\trow := db.QueryRow(\"SELECT $1::uuid\", b)\n\n\tvar result string\n\terr := row.Scan(&result)\n\tif forceBinaryParameters() {\n\t\tpqErr := err.(*Error)\n\t\tif pqErr == nil {\n\t\t\tt.Errorf(\"Expected to get error\")\n\t\t} else if pqErr.Code != \"22P03\" {\n\t\t\tt.Fatalf(\"Expected to get invalid binary encoding error (22P03), got %s\", pqErr.Code)\n\t\t}\n\t} else {\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif result != string(b) {\n\t\t\tt.Fatalf(\"expected %v but got %v\", b, result)\n\t\t}\n\t}\n}\n\nfunc TestBinaryByteSlicetoUUID(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tb := []byte{'\\xa0', '\\xee', '\\xbc', '\\x99',\n\t\t'\\x9c', '\\x0b',\n\t\t'\\x4e', '\\xf8',\n\t\t'\\xbb', '\\x00', '\\x6b',\n\t\t'\\xb9', '\\xbd', '\\x38', '\\x0a', '\\x11'}\n\trow := db.QueryRow(\"SELECT $1::uuid\", b)\n\n\tvar result string\n\terr := row.Scan(&result)\n\tif forceBinaryParameters() {\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif result != string(\"a0eebc99-9c0b-4ef8-bb00-6bb9bd380a11\") {\n\t\t\tt.Fatalf(\"expected %v but got %v\", b, result)\n\t\t}\n\t} else {\n\t\tpqErr := err.(*Error)\n\t\tif pqErr == nil {\n\t\t\tt.Errorf(\"Expected to get error\")\n\t\t} else if pqErr.Code != \"22021\" {\n\t\t\tt.Fatalf(\"Expected to get invalid byte sequence for encoding error (22021), got %s\", pqErr.Code)\n\t\t}\n\t}\n}\n\nfunc TestStringToUUID(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\ts := \"a0eebc99-9c0b-4ef8-bb00-6bb9bd380a11\"\n\trow := db.QueryRow(\"SELECT $1::uuid\", s)\n\n\tvar result string\n\terr := row.Scan(&result)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif result != s {\n\t\tt.Fatalf(\"expected %v but got %v\", s, result)\n\t}\n}\n\nfunc TestTextByteSliceToInt(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\texpected := 12345678\n\tb := []byte(fmt.Sprintf(\"%d\", expected))\n\trow := db.QueryRow(\"SELECT $1::int\", b)\n\n\tvar result int\n\terr := row.Scan(&result)\n\tif forceBinaryParameters() {\n\t\tpqErr := err.(*Error)\n\t\tif pqErr == nil {\n\t\t\tt.Errorf(\"Expected to get error\")\n\t\t} else if pqErr.Code != \"22P03\" {\n\t\t\tt.Fatalf(\"Expected to get invalid binary encoding error (22P03), got %s\", pqErr.Code)\n\t\t}\n\t} else {\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif result != expected {\n\t\t\tt.Fatalf(\"expected %v but got %v\", expected, result)\n\t\t}\n\t}\n}\n\nfunc TestBinaryByteSliceToInt(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\texpected := 12345678\n\tb := []byte{'\\x00', '\\xbc', '\\x61', '\\x4e'}\n\trow := db.QueryRow(\"SELECT $1::int\", b)\n\n\tvar result int\n\terr := row.Scan(&result)\n\tif forceBinaryParameters() {\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif result != expected {\n\t\t\tt.Fatalf(\"expected %v but got %v\", expected, result)\n\t\t}\n\t} else {\n\t\tpqErr := err.(*Error)\n\t\tif pqErr == nil {\n\t\t\tt.Errorf(\"Expected to get error\")\n\t\t} else if pqErr.Code != \"22021\" {\n\t\t\tt.Fatalf(\"Expected to get invalid byte sequence for encoding error (22021), got %s\", pqErr.Code)\n\t\t}\n\t}\n}\n\nfunc TestTextDecodeIntoString(t *testing.T) {\n\tinput := []byte(\"hello world\")\n\twant := string(input)\n\tfor _, typ := range []oid.Oid{oid.T_char, oid.T_varchar, oid.T_text} {\n\t\tgot := decode(&parameterStatus{}, input, typ, formatText)\n\t\tif got != want {\n\t\t\tt.Errorf(\"invalid string decoding output for %T(%+v), got %v but expected %v\", typ, typ, got, want)\n\t\t}\n\t}\n}\n\nfunc TestByteaOutputFormatEncoding(t *testing.T) {\n\tinput := []byte(\"\\\\x\\x00\\x01\\x02\\xFF\\xFEabcdefg0123\")\n\twant := []byte(\"\\\\x5c78000102fffe6162636465666730313233\")\n\tgot := encode(&parameterStatus{serverVersion: 90000}, input, oid.T_bytea)\n\tif !bytes.Equal(want, got) {\n\t\tt.Errorf(\"invalid hex bytea output, got %v but expected %v\", got, want)\n\t}\n\n\twant = []byte(\"\\\\\\\\x\\\\000\\\\001\\\\002\\\\377\\\\376abcdefg0123\")\n\tgot = encode(&parameterStatus{serverVersion: 84000}, input, oid.T_bytea)\n\tif !bytes.Equal(want, got) {\n\t\tt.Errorf(\"invalid escape bytea output, got %v but expected %v\", got, want)\n\t}\n}\n\nfunc TestByteaOutputFormats(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tif getServerVersion(t, db) < 90000 {\n\t\t// skip\n\t\treturn\n\t}\n\n\ttestByteaOutputFormat := func(f string, usePrepared bool) {\n\t\texpectedData := []byte(\"\\x5c\\x78\\x00\\xff\\x61\\x62\\x63\\x01\\x08\")\n\t\tsqlQuery := \"SELECT decode('5c7800ff6162630108', 'hex')\"\n\n\t\tvar data []byte\n\n\t\t// use a txn to avoid relying on getting the same connection\n\t\ttxn, err := db.Begin()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer txn.Rollback()\n\n\t\t_, err = txn.Exec(\"SET LOCAL bytea_output TO \" + f)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tvar rows *sql.Rows\n\t\tvar stmt *sql.Stmt\n\t\tif usePrepared {\n\t\t\tstmt, err = txn.Prepare(sqlQuery)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\trows, err = stmt.Query()\n\t\t} else {\n\t\t\t// use Query; QueryRow would hide the actual error\n\t\t\trows, err = txn.Query(sqlQuery)\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !rows.Next() {\n\t\t\tif rows.Err() != nil {\n\t\t\t\tt.Fatal(rows.Err())\n\t\t\t}\n\t\t\tt.Fatal(\"shouldn't happen\")\n\t\t}\n\t\terr = rows.Scan(&data)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr = rows.Close()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif stmt != nil {\n\t\t\terr = stmt.Close()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t\tif !bytes.Equal(data, expectedData) {\n\t\t\tt.Errorf(\"unexpected bytea value %v for format %s; expected %v\", data, f, expectedData)\n\t\t}\n\t}\n\n\ttestByteaOutputFormat(\"hex\", false)\n\ttestByteaOutputFormat(\"escape\", false)\n\ttestByteaOutputFormat(\"hex\", true)\n\ttestByteaOutputFormat(\"escape\", true)\n}\n\nfunc TestAppendEncodedText(t *testing.T) {\n\tvar buf []byte\n\n\tbuf = appendEncodedText(&parameterStatus{serverVersion: 90000}, buf, int64(10))\n\tbuf = append(buf, '\\t')\n\tbuf = appendEncodedText(&parameterStatus{serverVersion: 90000}, buf, 42.0000000001)\n\tbuf = append(buf, '\\t')\n\tbuf = appendEncodedText(&parameterStatus{serverVersion: 90000}, buf, \"hello\\tworld\")\n\tbuf = append(buf, '\\t')\n\tbuf = appendEncodedText(&parameterStatus{serverVersion: 90000}, buf, []byte{0, 128, 255})\n\n\tif string(buf) != \"10\\t42.0000000001\\thello\\\\tworld\\t\\\\\\\\x0080ff\" {\n\t\tt.Fatal(string(buf))\n\t}\n}\n\nfunc TestAppendEscapedText(t *testing.T) {\n\tif esc := appendEscapedText(nil, \"hallo\\tescape\"); string(esc) != \"hallo\\\\tescape\" {\n\t\tt.Fatal(string(esc))\n\t}\n\tif esc := appendEscapedText(nil, \"hallo\\\\tescape\\n\"); string(esc) != \"hallo\\\\\\\\tescape\\\\n\" {\n\t\tt.Fatal(string(esc))\n\t}\n\tif esc := appendEscapedText(nil, \"\\n\\r\\t\\f\"); string(esc) != \"\\\\n\\\\r\\\\t\\f\" {\n\t\tt.Fatal(string(esc))\n\t}\n}\n\nfunc TestAppendEscapedTextExistingBuffer(t *testing.T) {\n\tbuf := []byte(\"123\\t\")\n\tif esc := appendEscapedText(buf, \"hallo\\tescape\"); string(esc) != \"123\\thallo\\\\tescape\" {\n\t\tt.Fatal(string(esc))\n\t}\n\tbuf = []byte(\"123\\t\")\n\tif esc := appendEscapedText(buf, \"hallo\\\\tescape\\n\"); string(esc) != \"123\\thallo\\\\\\\\tescape\\\\n\" {\n\t\tt.Fatal(string(esc))\n\t}\n\tbuf = []byte(\"123\\t\")\n\tif esc := appendEscapedText(buf, \"\\n\\r\\t\\f\"); string(esc) != \"123\\t\\\\n\\\\r\\\\t\\f\" {\n\t\tt.Fatal(string(esc))\n\t}\n}\n\nvar formatAndParseTimestamp = []struct {\n\ttime     time.Time\n\texpected string\n}{\n\t{time.Time{}, \"0001-01-01 00:00:00Z\"},\n\t{time.Date(2001, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", 0)), \"2001-02-03 04:05:06.123456789Z\"},\n\t{time.Date(2001, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", 2*60*60)), \"2001-02-03 04:05:06.123456789+02:00\"},\n\t{time.Date(2001, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", -6*60*60)), \"2001-02-03 04:05:06.123456789-06:00\"},\n\t{time.Date(2001, time.February, 3, 4, 5, 6, 0, time.FixedZone(\"\", -(7*60*60+30*60+9))), \"2001-02-03 04:05:06-07:30:09\"},\n\n\t{time.Date(1, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", 0)), \"0001-02-03 04:05:06.123456789Z\"},\n\t{time.Date(1, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", 2*60*60)), \"0001-02-03 04:05:06.123456789+02:00\"},\n\t{time.Date(1, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", -6*60*60)), \"0001-02-03 04:05:06.123456789-06:00\"},\n\n\t{time.Date(0, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", 0)), \"0001-02-03 04:05:06.123456789Z BC\"},\n\t{time.Date(0, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", 2*60*60)), \"0001-02-03 04:05:06.123456789+02:00 BC\"},\n\t{time.Date(0, time.February, 3, 4, 5, 6, 123456789, time.FixedZone(\"\", -6*60*60)), \"0001-02-03 04:05:06.123456789-06:00 BC\"},\n\n\t{time.Date(1, time.February, 3, 4, 5, 6, 0, time.FixedZone(\"\", -(7*60*60+30*60+9))), \"0001-02-03 04:05:06-07:30:09\"},\n\t{time.Date(0, time.February, 3, 4, 5, 6, 0, time.FixedZone(\"\", -(7*60*60+30*60+9))), \"0001-02-03 04:05:06-07:30:09 BC\"},\n}\n\nfunc TestFormatAndParseTimestamp(t *testing.T) {\n\tfor _, val := range formatAndParseTimestamp {\n\t\tformattedTime := FormatTimestamp(val.time)\n\t\tparsedTime, err := ParseTimestamp(nil, string(formattedTime))\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"invalid parsing, err: %v\", err.Error())\n\t\t}\n\n\t\tif val.time.UTC() != parsedTime.UTC() {\n\t\t\tt.Errorf(\"invalid parsing from formatted timestamp, got %v; expected %v\", parsedTime.String(), val.time.String())\n\t\t}\n\t}\n}\n\nfunc BenchmarkAppendEscapedText(b *testing.B) {\n\tlongString := \"\"\n\tfor i := 0; i < 100; i++ {\n\t\tlongString += \"123456789\\n\"\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\tappendEscapedText(nil, longString)\n\t}\n}\n\nfunc BenchmarkAppendEscapedTextNoEscape(b *testing.B) {\n\tlongString := \"\"\n\tfor i := 0; i < 100; i++ {\n\t\tlongString += \"1234567890\"\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\tappendEscapedText(nil, longString)\n\t}\n}\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 15.4716796875,
          "content": "package pq\n\nimport (\n\t\"database/sql/driver\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"runtime\"\n)\n\n// Error severities\nconst (\n\tEfatal   = \"FATAL\"\n\tEpanic   = \"PANIC\"\n\tEwarning = \"WARNING\"\n\tEnotice  = \"NOTICE\"\n\tEdebug   = \"DEBUG\"\n\tEinfo    = \"INFO\"\n\tElog     = \"LOG\"\n)\n\n// Error represents an error communicating with the server.\n//\n// See http://www.postgresql.org/docs/current/static/protocol-error-fields.html for details of the fields\ntype Error struct {\n\tSeverity         string\n\tCode             ErrorCode\n\tMessage          string\n\tDetail           string\n\tHint             string\n\tPosition         string\n\tInternalPosition string\n\tInternalQuery    string\n\tWhere            string\n\tSchema           string\n\tTable            string\n\tColumn           string\n\tDataTypeName     string\n\tConstraint       string\n\tFile             string\n\tLine             string\n\tRoutine          string\n}\n\n// ErrorCode is a five-character error code.\ntype ErrorCode string\n\n// Name returns a more human friendly rendering of the error code, namely the\n// \"condition name\".\n//\n// See http://www.postgresql.org/docs/9.3/static/errcodes-appendix.html for\n// details.\nfunc (ec ErrorCode) Name() string {\n\treturn errorCodeNames[ec]\n}\n\n// ErrorClass is only the class part of an error code.\ntype ErrorClass string\n\n// Name returns the condition name of an error class.  It is equivalent to the\n// condition name of the \"standard\" error code (i.e. the one having the last\n// three characters \"000\").\nfunc (ec ErrorClass) Name() string {\n\treturn errorCodeNames[ErrorCode(ec+\"000\")]\n}\n\n// Class returns the error class, e.g. \"28\".\n//\n// See http://www.postgresql.org/docs/9.3/static/errcodes-appendix.html for\n// details.\nfunc (ec ErrorCode) Class() ErrorClass {\n\treturn ErrorClass(ec[0:2])\n}\n\n// errorCodeNames is a mapping between the five-character error codes and the\n// human readable \"condition names\". It is derived from the list at\n// http://www.postgresql.org/docs/9.3/static/errcodes-appendix.html\nvar errorCodeNames = map[ErrorCode]string{\n\t// Class 00 - Successful Completion\n\t\"00000\": \"successful_completion\",\n\t// Class 01 - Warning\n\t\"01000\": \"warning\",\n\t\"0100C\": \"dynamic_result_sets_returned\",\n\t\"01008\": \"implicit_zero_bit_padding\",\n\t\"01003\": \"null_value_eliminated_in_set_function\",\n\t\"01007\": \"privilege_not_granted\",\n\t\"01006\": \"privilege_not_revoked\",\n\t\"01004\": \"string_data_right_truncation\",\n\t\"01P01\": \"deprecated_feature\",\n\t// Class 02 - No Data (this is also a warning class per the SQL standard)\n\t\"02000\": \"no_data\",\n\t\"02001\": \"no_additional_dynamic_result_sets_returned\",\n\t// Class 03 - SQL Statement Not Yet Complete\n\t\"03000\": \"sql_statement_not_yet_complete\",\n\t// Class 08 - Connection Exception\n\t\"08000\": \"connection_exception\",\n\t\"08003\": \"connection_does_not_exist\",\n\t\"08006\": \"connection_failure\",\n\t\"08001\": \"sqlclient_unable_to_establish_sqlconnection\",\n\t\"08004\": \"sqlserver_rejected_establishment_of_sqlconnection\",\n\t\"08007\": \"transaction_resolution_unknown\",\n\t\"08P01\": \"protocol_violation\",\n\t// Class 09 - Triggered Action Exception\n\t\"09000\": \"triggered_action_exception\",\n\t// Class 0A - Feature Not Supported\n\t\"0A000\": \"feature_not_supported\",\n\t// Class 0B - Invalid Transaction Initiation\n\t\"0B000\": \"invalid_transaction_initiation\",\n\t// Class 0F - Locator Exception\n\t\"0F000\": \"locator_exception\",\n\t\"0F001\": \"invalid_locator_specification\",\n\t// Class 0L - Invalid Grantor\n\t\"0L000\": \"invalid_grantor\",\n\t\"0LP01\": \"invalid_grant_operation\",\n\t// Class 0P - Invalid Role Specification\n\t\"0P000\": \"invalid_role_specification\",\n\t// Class 0Z - Diagnostics Exception\n\t\"0Z000\": \"diagnostics_exception\",\n\t\"0Z002\": \"stacked_diagnostics_accessed_without_active_handler\",\n\t// Class 20 - Case Not Found\n\t\"20000\": \"case_not_found\",\n\t// Class 21 - Cardinality Violation\n\t\"21000\": \"cardinality_violation\",\n\t// Class 22 - Data Exception\n\t\"22000\": \"data_exception\",\n\t\"2202E\": \"array_subscript_error\",\n\t\"22021\": \"character_not_in_repertoire\",\n\t\"22008\": \"datetime_field_overflow\",\n\t\"22012\": \"division_by_zero\",\n\t\"22005\": \"error_in_assignment\",\n\t\"2200B\": \"escape_character_conflict\",\n\t\"22022\": \"indicator_overflow\",\n\t\"22015\": \"interval_field_overflow\",\n\t\"2201E\": \"invalid_argument_for_logarithm\",\n\t\"22014\": \"invalid_argument_for_ntile_function\",\n\t\"22016\": \"invalid_argument_for_nth_value_function\",\n\t\"2201F\": \"invalid_argument_for_power_function\",\n\t\"2201G\": \"invalid_argument_for_width_bucket_function\",\n\t\"22018\": \"invalid_character_value_for_cast\",\n\t\"22007\": \"invalid_datetime_format\",\n\t\"22019\": \"invalid_escape_character\",\n\t\"2200D\": \"invalid_escape_octet\",\n\t\"22025\": \"invalid_escape_sequence\",\n\t\"22P06\": \"nonstandard_use_of_escape_character\",\n\t\"22010\": \"invalid_indicator_parameter_value\",\n\t\"22023\": \"invalid_parameter_value\",\n\t\"2201B\": \"invalid_regular_expression\",\n\t\"2201W\": \"invalid_row_count_in_limit_clause\",\n\t\"2201X\": \"invalid_row_count_in_result_offset_clause\",\n\t\"22009\": \"invalid_time_zone_displacement_value\",\n\t\"2200C\": \"invalid_use_of_escape_character\",\n\t\"2200G\": \"most_specific_type_mismatch\",\n\t\"22004\": \"null_value_not_allowed\",\n\t\"22002\": \"null_value_no_indicator_parameter\",\n\t\"22003\": \"numeric_value_out_of_range\",\n\t\"2200H\": \"sequence_generator_limit_exceeded\",\n\t\"22026\": \"string_data_length_mismatch\",\n\t\"22001\": \"string_data_right_truncation\",\n\t\"22011\": \"substring_error\",\n\t\"22027\": \"trim_error\",\n\t\"22024\": \"unterminated_c_string\",\n\t\"2200F\": \"zero_length_character_string\",\n\t\"22P01\": \"floating_point_exception\",\n\t\"22P02\": \"invalid_text_representation\",\n\t\"22P03\": \"invalid_binary_representation\",\n\t\"22P04\": \"bad_copy_file_format\",\n\t\"22P05\": \"untranslatable_character\",\n\t\"2200L\": \"not_an_xml_document\",\n\t\"2200M\": \"invalid_xml_document\",\n\t\"2200N\": \"invalid_xml_content\",\n\t\"2200S\": \"invalid_xml_comment\",\n\t\"2200T\": \"invalid_xml_processing_instruction\",\n\t// Class 23 - Integrity Constraint Violation\n\t\"23000\": \"integrity_constraint_violation\",\n\t\"23001\": \"restrict_violation\",\n\t\"23502\": \"not_null_violation\",\n\t\"23503\": \"foreign_key_violation\",\n\t\"23505\": \"unique_violation\",\n\t\"23514\": \"check_violation\",\n\t\"23P01\": \"exclusion_violation\",\n\t// Class 24 - Invalid Cursor State\n\t\"24000\": \"invalid_cursor_state\",\n\t// Class 25 - Invalid Transaction State\n\t\"25000\": \"invalid_transaction_state\",\n\t\"25001\": \"active_sql_transaction\",\n\t\"25002\": \"branch_transaction_already_active\",\n\t\"25008\": \"held_cursor_requires_same_isolation_level\",\n\t\"25003\": \"inappropriate_access_mode_for_branch_transaction\",\n\t\"25004\": \"inappropriate_isolation_level_for_branch_transaction\",\n\t\"25005\": \"no_active_sql_transaction_for_branch_transaction\",\n\t\"25006\": \"read_only_sql_transaction\",\n\t\"25007\": \"schema_and_data_statement_mixing_not_supported\",\n\t\"25P01\": \"no_active_sql_transaction\",\n\t\"25P02\": \"in_failed_sql_transaction\",\n\t// Class 26 - Invalid SQL Statement Name\n\t\"26000\": \"invalid_sql_statement_name\",\n\t// Class 27 - Triggered Data Change Violation\n\t\"27000\": \"triggered_data_change_violation\",\n\t// Class 28 - Invalid Authorization Specification\n\t\"28000\": \"invalid_authorization_specification\",\n\t\"28P01\": \"invalid_password\",\n\t// Class 2B - Dependent Privilege Descriptors Still Exist\n\t\"2B000\": \"dependent_privilege_descriptors_still_exist\",\n\t\"2BP01\": \"dependent_objects_still_exist\",\n\t// Class 2D - Invalid Transaction Termination\n\t\"2D000\": \"invalid_transaction_termination\",\n\t// Class 2F - SQL Routine Exception\n\t\"2F000\": \"sql_routine_exception\",\n\t\"2F005\": \"function_executed_no_return_statement\",\n\t\"2F002\": \"modifying_sql_data_not_permitted\",\n\t\"2F003\": \"prohibited_sql_statement_attempted\",\n\t\"2F004\": \"reading_sql_data_not_permitted\",\n\t// Class 34 - Invalid Cursor Name\n\t\"34000\": \"invalid_cursor_name\",\n\t// Class 38 - External Routine Exception\n\t\"38000\": \"external_routine_exception\",\n\t\"38001\": \"containing_sql_not_permitted\",\n\t\"38002\": \"modifying_sql_data_not_permitted\",\n\t\"38003\": \"prohibited_sql_statement_attempted\",\n\t\"38004\": \"reading_sql_data_not_permitted\",\n\t// Class 39 - External Routine Invocation Exception\n\t\"39000\": \"external_routine_invocation_exception\",\n\t\"39001\": \"invalid_sqlstate_returned\",\n\t\"39004\": \"null_value_not_allowed\",\n\t\"39P01\": \"trigger_protocol_violated\",\n\t\"39P02\": \"srf_protocol_violated\",\n\t// Class 3B - Savepoint Exception\n\t\"3B000\": \"savepoint_exception\",\n\t\"3B001\": \"invalid_savepoint_specification\",\n\t// Class 3D - Invalid Catalog Name\n\t\"3D000\": \"invalid_catalog_name\",\n\t// Class 3F - Invalid Schema Name\n\t\"3F000\": \"invalid_schema_name\",\n\t// Class 40 - Transaction Rollback\n\t\"40000\": \"transaction_rollback\",\n\t\"40002\": \"transaction_integrity_constraint_violation\",\n\t\"40001\": \"serialization_failure\",\n\t\"40003\": \"statement_completion_unknown\",\n\t\"40P01\": \"deadlock_detected\",\n\t// Class 42 - Syntax Error or Access Rule Violation\n\t\"42000\": \"syntax_error_or_access_rule_violation\",\n\t\"42601\": \"syntax_error\",\n\t\"42501\": \"insufficient_privilege\",\n\t\"42846\": \"cannot_coerce\",\n\t\"42803\": \"grouping_error\",\n\t\"42P20\": \"windowing_error\",\n\t\"42P19\": \"invalid_recursion\",\n\t\"42830\": \"invalid_foreign_key\",\n\t\"42602\": \"invalid_name\",\n\t\"42622\": \"name_too_long\",\n\t\"42939\": \"reserved_name\",\n\t\"42804\": \"datatype_mismatch\",\n\t\"42P18\": \"indeterminate_datatype\",\n\t\"42P21\": \"collation_mismatch\",\n\t\"42P22\": \"indeterminate_collation\",\n\t\"42809\": \"wrong_object_type\",\n\t\"42703\": \"undefined_column\",\n\t\"42883\": \"undefined_function\",\n\t\"42P01\": \"undefined_table\",\n\t\"42P02\": \"undefined_parameter\",\n\t\"42704\": \"undefined_object\",\n\t\"42701\": \"duplicate_column\",\n\t\"42P03\": \"duplicate_cursor\",\n\t\"42P04\": \"duplicate_database\",\n\t\"42723\": \"duplicate_function\",\n\t\"42P05\": \"duplicate_prepared_statement\",\n\t\"42P06\": \"duplicate_schema\",\n\t\"42P07\": \"duplicate_table\",\n\t\"42712\": \"duplicate_alias\",\n\t\"42710\": \"duplicate_object\",\n\t\"42702\": \"ambiguous_column\",\n\t\"42725\": \"ambiguous_function\",\n\t\"42P08\": \"ambiguous_parameter\",\n\t\"42P09\": \"ambiguous_alias\",\n\t\"42P10\": \"invalid_column_reference\",\n\t\"42611\": \"invalid_column_definition\",\n\t\"42P11\": \"invalid_cursor_definition\",\n\t\"42P12\": \"invalid_database_definition\",\n\t\"42P13\": \"invalid_function_definition\",\n\t\"42P14\": \"invalid_prepared_statement_definition\",\n\t\"42P15\": \"invalid_schema_definition\",\n\t\"42P16\": \"invalid_table_definition\",\n\t\"42P17\": \"invalid_object_definition\",\n\t// Class 44 - WITH CHECK OPTION Violation\n\t\"44000\": \"with_check_option_violation\",\n\t// Class 53 - Insufficient Resources\n\t\"53000\": \"insufficient_resources\",\n\t\"53100\": \"disk_full\",\n\t\"53200\": \"out_of_memory\",\n\t\"53300\": \"too_many_connections\",\n\t\"53400\": \"configuration_limit_exceeded\",\n\t// Class 54 - Program Limit Exceeded\n\t\"54000\": \"program_limit_exceeded\",\n\t\"54001\": \"statement_too_complex\",\n\t\"54011\": \"too_many_columns\",\n\t\"54023\": \"too_many_arguments\",\n\t// Class 55 - Object Not In Prerequisite State\n\t\"55000\": \"object_not_in_prerequisite_state\",\n\t\"55006\": \"object_in_use\",\n\t\"55P02\": \"cant_change_runtime_param\",\n\t\"55P03\": \"lock_not_available\",\n\t// Class 57 - Operator Intervention\n\t\"57000\": \"operator_intervention\",\n\t\"57014\": \"query_canceled\",\n\t\"57P01\": \"admin_shutdown\",\n\t\"57P02\": \"crash_shutdown\",\n\t\"57P03\": \"cannot_connect_now\",\n\t\"57P04\": \"database_dropped\",\n\t// Class 58 - System Error (errors external to PostgreSQL itself)\n\t\"58000\": \"system_error\",\n\t\"58030\": \"io_error\",\n\t\"58P01\": \"undefined_file\",\n\t\"58P02\": \"duplicate_file\",\n\t// Class F0 - Configuration File Error\n\t\"F0000\": \"config_file_error\",\n\t\"F0001\": \"lock_file_exists\",\n\t// Class HV - Foreign Data Wrapper Error (SQL/MED)\n\t\"HV000\": \"fdw_error\",\n\t\"HV005\": \"fdw_column_name_not_found\",\n\t\"HV002\": \"fdw_dynamic_parameter_value_needed\",\n\t\"HV010\": \"fdw_function_sequence_error\",\n\t\"HV021\": \"fdw_inconsistent_descriptor_information\",\n\t\"HV024\": \"fdw_invalid_attribute_value\",\n\t\"HV007\": \"fdw_invalid_column_name\",\n\t\"HV008\": \"fdw_invalid_column_number\",\n\t\"HV004\": \"fdw_invalid_data_type\",\n\t\"HV006\": \"fdw_invalid_data_type_descriptors\",\n\t\"HV091\": \"fdw_invalid_descriptor_field_identifier\",\n\t\"HV00B\": \"fdw_invalid_handle\",\n\t\"HV00C\": \"fdw_invalid_option_index\",\n\t\"HV00D\": \"fdw_invalid_option_name\",\n\t\"HV090\": \"fdw_invalid_string_length_or_buffer_length\",\n\t\"HV00A\": \"fdw_invalid_string_format\",\n\t\"HV009\": \"fdw_invalid_use_of_null_pointer\",\n\t\"HV014\": \"fdw_too_many_handles\",\n\t\"HV001\": \"fdw_out_of_memory\",\n\t\"HV00P\": \"fdw_no_schemas\",\n\t\"HV00J\": \"fdw_option_name_not_found\",\n\t\"HV00K\": \"fdw_reply_handle\",\n\t\"HV00Q\": \"fdw_schema_not_found\",\n\t\"HV00R\": \"fdw_table_not_found\",\n\t\"HV00L\": \"fdw_unable_to_create_execution\",\n\t\"HV00M\": \"fdw_unable_to_create_reply\",\n\t\"HV00N\": \"fdw_unable_to_establish_connection\",\n\t// Class P0 - PL/pgSQL Error\n\t\"P0000\": \"plpgsql_error\",\n\t\"P0001\": \"raise_exception\",\n\t\"P0002\": \"no_data_found\",\n\t\"P0003\": \"too_many_rows\",\n\t// Class XX - Internal Error\n\t\"XX000\": \"internal_error\",\n\t\"XX001\": \"data_corrupted\",\n\t\"XX002\": \"index_corrupted\",\n}\n\nfunc parseError(r *readBuf) *Error {\n\terr := new(Error)\n\tfor t := r.byte(); t != 0; t = r.byte() {\n\t\tmsg := r.string()\n\t\tswitch t {\n\t\tcase 'S':\n\t\t\terr.Severity = msg\n\t\tcase 'C':\n\t\t\terr.Code = ErrorCode(msg)\n\t\tcase 'M':\n\t\t\terr.Message = msg\n\t\tcase 'D':\n\t\t\terr.Detail = msg\n\t\tcase 'H':\n\t\t\terr.Hint = msg\n\t\tcase 'P':\n\t\t\terr.Position = msg\n\t\tcase 'p':\n\t\t\terr.InternalPosition = msg\n\t\tcase 'q':\n\t\t\terr.InternalQuery = msg\n\t\tcase 'W':\n\t\t\terr.Where = msg\n\t\tcase 's':\n\t\t\terr.Schema = msg\n\t\tcase 't':\n\t\t\terr.Table = msg\n\t\tcase 'c':\n\t\t\terr.Column = msg\n\t\tcase 'd':\n\t\t\terr.DataTypeName = msg\n\t\tcase 'n':\n\t\t\terr.Constraint = msg\n\t\tcase 'F':\n\t\t\terr.File = msg\n\t\tcase 'L':\n\t\t\terr.Line = msg\n\t\tcase 'R':\n\t\t\terr.Routine = msg\n\t\t}\n\t}\n\treturn err\n}\n\n// Fatal returns true if the Error Severity is fatal.\nfunc (err *Error) Fatal() bool {\n\treturn err.Severity == Efatal\n}\n\n// SQLState returns the SQLState of the error.\nfunc (err *Error) SQLState() string {\n\treturn string(err.Code)\n}\n\n// Get implements the legacy PGError interface. New code should use the fields\n// of the Error struct directly.\nfunc (err *Error) Get(k byte) (v string) {\n\tswitch k {\n\tcase 'S':\n\t\treturn err.Severity\n\tcase 'C':\n\t\treturn string(err.Code)\n\tcase 'M':\n\t\treturn err.Message\n\tcase 'D':\n\t\treturn err.Detail\n\tcase 'H':\n\t\treturn err.Hint\n\tcase 'P':\n\t\treturn err.Position\n\tcase 'p':\n\t\treturn err.InternalPosition\n\tcase 'q':\n\t\treturn err.InternalQuery\n\tcase 'W':\n\t\treturn err.Where\n\tcase 's':\n\t\treturn err.Schema\n\tcase 't':\n\t\treturn err.Table\n\tcase 'c':\n\t\treturn err.Column\n\tcase 'd':\n\t\treturn err.DataTypeName\n\tcase 'n':\n\t\treturn err.Constraint\n\tcase 'F':\n\t\treturn err.File\n\tcase 'L':\n\t\treturn err.Line\n\tcase 'R':\n\t\treturn err.Routine\n\t}\n\treturn \"\"\n}\n\nfunc (err *Error) Error() string {\n\treturn \"pq: \" + err.Message\n}\n\n// PGError is an interface used by previous versions of pq. It is provided\n// only to support legacy code. New code should use the Error type.\ntype PGError interface {\n\tError() string\n\tFatal() bool\n\tGet(k byte) (v string)\n}\n\nfunc errorf(s string, args ...interface{}) {\n\tpanic(fmt.Errorf(\"pq: %s\", fmt.Sprintf(s, args...)))\n}\n\n// TODO(ainar-g) Rename to errorf after removing panics.\nfunc fmterrorf(s string, args ...interface{}) error {\n\treturn fmt.Errorf(\"pq: %s\", fmt.Sprintf(s, args...))\n}\n\nfunc errRecoverNoErrBadConn(err *error) {\n\te := recover()\n\tif e == nil {\n\t\t// Do nothing\n\t\treturn\n\t}\n\tvar ok bool\n\t*err, ok = e.(error)\n\tif !ok {\n\t\t*err = fmt.Errorf(\"pq: unexpected error: %#v\", e)\n\t}\n}\n\nfunc (cn *conn) errRecover(err *error) {\n\te := recover()\n\tswitch v := e.(type) {\n\tcase nil:\n\t\t// Do nothing\n\tcase runtime.Error:\n\t\tcn.err.set(driver.ErrBadConn)\n\t\tpanic(v)\n\tcase *Error:\n\t\tif v.Fatal() {\n\t\t\t*err = driver.ErrBadConn\n\t\t} else {\n\t\t\t*err = v\n\t\t}\n\tcase *net.OpError:\n\t\tcn.err.set(driver.ErrBadConn)\n\t\t*err = v\n\tcase *safeRetryError:\n\t\tcn.err.set(driver.ErrBadConn)\n\t\t*err = driver.ErrBadConn\n\tcase error:\n\t\tif v == io.EOF || v.Error() == \"remote error: handshake failure\" {\n\t\t\t*err = driver.ErrBadConn\n\t\t} else {\n\t\t\t*err = v\n\t\t}\n\n\tdefault:\n\t\tcn.err.set(driver.ErrBadConn)\n\t\tpanic(fmt.Sprintf(\"unknown error: %#v\", e))\n\t}\n\n\t// Any time we return ErrBadConn, we need to remember it since *Tx doesn't\n\t// mark the connection bad in database/sql.\n\tif *err == driver.ErrBadConn {\n\t\tcn.err.set(driver.ErrBadConn)\n\t}\n}\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.033203125,
          "content": "module github.com/lib/pq\n\ngo 1.13\n"
        },
        {
          "name": "go18_test.go",
          "type": "blob",
          "size": 8.4765625,
          "content": "package pq\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestMultipleSimpleQuery(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\trows, err := db.Query(\"select 1; set time zone default; select 2; select 3\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer rows.Close()\n\n\tvar i int\n\tfor rows.Next() {\n\t\tif err := rows.Scan(&i); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif i != 1 {\n\t\t\tt.Fatalf(\"expected 1, got %d\", i)\n\t\t}\n\t}\n\tif !rows.NextResultSet() {\n\t\tt.Fatal(\"expected more result sets\", rows.Err())\n\t}\n\tfor rows.Next() {\n\t\tif err := rows.Scan(&i); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif i != 2 {\n\t\t\tt.Fatalf(\"expected 2, got %d\", i)\n\t\t}\n\t}\n\n\t// Make sure that if we ignore a result we can still query.\n\n\trows, err = db.Query(\"select 4; select 5\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\tif err := rows.Scan(&i); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif i != 4 {\n\t\t\tt.Fatalf(\"expected 4, got %d\", i)\n\t\t}\n\t}\n\tif !rows.NextResultSet() {\n\t\tt.Fatal(\"expected more result sets\", rows.Err())\n\t}\n\tfor rows.Next() {\n\t\tif err := rows.Scan(&i); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif i != 5 {\n\t\t\tt.Fatalf(\"expected 5, got %d\", i)\n\t\t}\n\t}\n\tif rows.NextResultSet() {\n\t\tt.Fatal(\"unexpected result set\")\n\t}\n}\n\nconst contextRaceIterations = 100\n\nconst cancelErrorCode ErrorCode = \"57014\"\n\nfunc TestContextCancelExec(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\t// Delay execution for just a bit until db.ExecContext has begun.\n\tdefer time.AfterFunc(time.Millisecond*10, cancel).Stop()\n\n\t// Not canceled until after the exec has started.\n\tif _, err := db.ExecContext(ctx, \"select pg_sleep(1)\"); err == nil {\n\t\tt.Fatal(\"expected error\")\n\t} else if pgErr := (*Error)(nil); !(errors.As(err, &pgErr) && pgErr.Code == cancelErrorCode) {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\t// Context is already canceled, so error should come before execution.\n\tif _, err := db.ExecContext(ctx, \"select pg_sleep(1)\"); err == nil {\n\t\tt.Fatal(\"expected error\")\n\t} else if err.Error() != \"context canceled\" {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\tfor i := 0; i < contextRaceIterations; i++ {\n\t\tfunc() {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tdefer cancel()\n\t\t\tif _, err := db.ExecContext(ctx, \"select 1\"); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}()\n\n\t\tif _, err := db.Exec(\"select 1\"); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc TestContextCancelQuery(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\t// Delay execution for just a bit until db.QueryContext has begun.\n\tdefer time.AfterFunc(time.Millisecond*10, cancel).Stop()\n\n\t// Not canceled until after the exec has started.\n\tif _, err := db.QueryContext(ctx, \"select pg_sleep(1)\"); err == nil {\n\t\tt.Fatal(\"expected error\")\n\t} else if pgErr := (*Error)(nil); !(errors.As(err, &pgErr) && pgErr.Code == cancelErrorCode) {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\t// Context is already canceled, so error should come before execution.\n\tif _, err := db.QueryContext(ctx, \"select pg_sleep(1)\"); err == nil {\n\t\tt.Fatal(\"expected error\")\n\t} else if err.Error() != \"context canceled\" {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\tfor i := 0; i < contextRaceIterations; i++ {\n\t\tfunc() {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\trows, err := db.QueryContext(ctx, \"select 1\")\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t} else if err := rows.Close(); err != nil && err != driver.ErrBadConn && err != context.Canceled {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}()\n\n\t\tif rows, err := db.Query(\"select 1\"); err != nil {\n\t\t\tt.Fatal(err)\n\t\t} else if err := rows.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n\n// TestIssue617 tests that a failed query in QueryContext doesn't lead to a\n// goroutine leak.\nfunc TestIssue617(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tconst N = 10\n\n\tnumGoroutineStart := runtime.NumGoroutine()\n\tfor i := 0; i < N; i++ {\n\t\tfunc() {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tdefer cancel()\n\t\t\t_, err := db.QueryContext(ctx, `SELECT * FROM DOESNOTEXIST`)\n\t\t\tpqErr, _ := err.(*Error)\n\t\t\t// Expecting \"pq: relation \\\"doesnotexist\\\" does not exist\" error.\n\t\t\tif err == nil || pqErr == nil || pqErr.Code != \"42P01\" {\n\t\t\t\tt.Fatalf(\"expected undefined table error, got %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Give time for goroutines to terminate\n\tdelayTime := time.Millisecond * 50\n\twaitTime := time.Second\n\titerations := int(waitTime / delayTime)\n\n\tvar numGoroutineFinish int\n\tfor i := 0; i < iterations; i++ {\n\t\ttime.Sleep(delayTime)\n\n\t\tnumGoroutineFinish = runtime.NumGoroutine()\n\n\t\t// We use N/2 and not N because the GC and other actors may increase or\n\t\t// decrease the number of goroutines.\n\t\tif numGoroutineFinish-numGoroutineStart < N/2 {\n\t\t\treturn\n\t\t}\n\t}\n\n\tt.Errorf(\"goroutine leak detected, was %d, now %d\", numGoroutineStart, numGoroutineFinish)\n}\n\nfunc TestContextCancelBegin(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\ttx, err := db.BeginTx(ctx, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Delay execution for just a bit until tx.Exec has begun.\n\tdefer time.AfterFunc(time.Millisecond*10, cancel).Stop()\n\n\t// Not canceled until after the exec has started.\n\tif _, err := tx.Exec(\"select pg_sleep(1)\"); err == nil {\n\t\tt.Fatal(\"expected error\")\n\t} else if pgErr := (*Error)(nil); !(errors.As(err, &pgErr) && pgErr.Code == cancelErrorCode) {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\t// Transaction is canceled, so expect an error.\n\tif _, err := tx.Query(\"select pg_sleep(1)\"); err == nil {\n\t\tt.Fatal(\"expected error\")\n\t} else if err != sql.ErrTxDone {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\t// Context is canceled, so cannot begin a transaction.\n\tif _, err := db.BeginTx(ctx, nil); err == nil {\n\t\tt.Fatal(\"expected error\")\n\t} else if err.Error() != \"context canceled\" {\n\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t}\n\n\tfor i := 0; i < contextRaceIterations; i++ {\n\t\tfunc() {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\ttx, err := db.BeginTx(ctx, nil)\n\t\t\tcancel()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t} else if err, pgErr := tx.Rollback(), (*Error)(nil); err != nil &&\n\t\t\t\t!(errors.As(err, &pgErr) && pgErr.Code == cancelErrorCode) &&\n\t\t\t\terr != sql.ErrTxDone && err != driver.ErrBadConn && err != context.Canceled {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}()\n\n\t\tif tx, err := db.Begin(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t} else if err := tx.Rollback(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc TestTxOptions(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\tctx := context.Background()\n\n\ttests := []struct {\n\t\tlevel     sql.IsolationLevel\n\t\tisolation string\n\t}{\n\t\t{\n\t\t\tlevel:     sql.LevelDefault,\n\t\t\tisolation: \"\",\n\t\t},\n\t\t{\n\t\t\tlevel:     sql.LevelReadUncommitted,\n\t\t\tisolation: \"read uncommitted\",\n\t\t},\n\t\t{\n\t\t\tlevel:     sql.LevelReadCommitted,\n\t\t\tisolation: \"read committed\",\n\t\t},\n\t\t{\n\t\t\tlevel:     sql.LevelRepeatableRead,\n\t\t\tisolation: \"repeatable read\",\n\t\t},\n\t\t{\n\t\t\tlevel:     sql.LevelSerializable,\n\t\t\tisolation: \"serializable\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tfor _, ro := range []bool{true, false} {\n\t\t\ttx, err := db.BeginTx(ctx, &sql.TxOptions{\n\t\t\t\tIsolation: test.level,\n\t\t\t\tReadOnly:  ro,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tvar isolation string\n\t\t\terr = tx.QueryRow(\"select current_setting('transaction_isolation')\").Scan(&isolation)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif test.isolation != \"\" && isolation != test.isolation {\n\t\t\t\tt.Errorf(\"wrong isolation level: %s != %s\", isolation, test.isolation)\n\t\t\t}\n\n\t\t\tvar isRO string\n\t\t\terr = tx.QueryRow(\"select current_setting('transaction_read_only')\").Scan(&isRO)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif ro != (isRO == \"on\") {\n\t\t\t\tt.Errorf(\"read/[write,only] not set: %t != %s for level %s\",\n\t\t\t\t\tro, isRO, test.isolation)\n\t\t\t}\n\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\t_, err := db.BeginTx(ctx, &sql.TxOptions{\n\t\tIsolation: sql.LevelLinearizable,\n\t})\n\tif err == nil {\n\t\tt.Fatal(\"expected LevelLinearizable to fail\")\n\t}\n\tif !strings.Contains(err.Error(), \"isolation level not supported\") {\n\t\tt.Errorf(\"Expected error to mention isolation level, got %q\", err)\n\t}\n}\n\nfunc TestErrorSQLState(t *testing.T) {\n\tr := readBuf([]byte{67, 52, 48, 48, 48, 49, 0, 0}) // 40001\n\terr := parseError(&r)\n\tvar sqlErr errWithSQLState\n\tif !errors.As(err, &sqlErr) {\n\t\tt.Fatal(\"SQLState interface not satisfied\")\n\t}\n\tif state := err.SQLState(); state != \"40001\" {\n\t\tt.Fatalf(\"unexpected SQL state %v\", state)\n\t}\n}\n\ntype errWithSQLState interface {\n\tSQLState() string\n}\n"
        },
        {
          "name": "go19_test.go",
          "type": "blob",
          "size": 2.078125,
          "content": "//go:build go1.9\n// +build go1.9\n\npackage pq\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestPing(t *testing.T) {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tif _, ok := reflect.TypeOf(db).MethodByName(\"Conn\"); !ok {\n\t\tt.Skipf(\"Conn method undefined on type %T, skipping test (requires at least go1.9)\", db)\n\t}\n\n\tif err := db.PingContext(ctx); err != nil {\n\t\tt.Fatal(\"expected Ping to succeed\")\n\t}\n\tdefer cancel()\n\n\t// grab a connection\n\tconn, err := db.Conn(ctx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// start a transaction and read backend pid of our connection\n\ttx, err := conn.BeginTx(ctx, &sql.TxOptions{\n\t\tIsolation: sql.LevelDefault,\n\t\tReadOnly:  true,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trows, err := tx.Query(\"SELECT pg_backend_pid()\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer rows.Close()\n\n\t// read the pid from result\n\tvar pid int\n\tfor rows.Next() {\n\t\tif err := rows.Scan(&pid); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\tif rows.Err() != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Fail the transaction and make sure we can still ping.\n\tif _, err := tx.Query(\"INVALID SQL\"); err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n\tif err := conn.PingContext(ctx); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := tx.Rollback(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// kill the process which handles our connection and test if the ping fails\n\tif _, err := db.Exec(\"SELECT pg_terminate_backend($1)\", pid); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := conn.PingContext(ctx); err != driver.ErrBadConn {\n\t\tt.Fatalf(\"expected error %s, instead got %s\", driver.ErrBadConn, err)\n\t}\n}\n\nfunc TestCommitInFailedTransactionWithCancelContext(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\ttxn, err := db.BeginTx(ctx, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trows, err := txn.Query(\"SELECT error\")\n\tif err == nil {\n\t\trows.Close()\n\t\tt.Fatal(\"expected failure\")\n\t}\n\terr = txn.Commit()\n\tif err != ErrInFailedTransaction {\n\t\tt.Fatalf(\"expected ErrInFailedTransaction; got %#v\", err)\n\t}\n}\n"
        },
        {
          "name": "hstore",
          "type": "tree",
          "content": null
        },
        {
          "name": "issues_test.go",
          "type": "blob",
          "size": 3.474609375,
          "content": "package pq\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestIssue494(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tquery := `CREATE TEMP TABLE t (i INT PRIMARY KEY)`\n\tif _, err := db.Exec(query); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttxn, err := db.Begin()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif _, err := txn.Prepare(CopyIn(\"t\", \"i\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif _, err := txn.Query(\"SELECT 1\"); err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\nfunc TestIssue1046(t *testing.T) {\n\tctxTimeout := time.Second * 2\n\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tctx, cancel := context.WithTimeout(context.Background(), ctxTimeout)\n\tdefer cancel()\n\n\tstmt, err := db.PrepareContext(ctx, `SELECT pg_sleep(10) AS id`)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar d []uint8\n\terr = stmt.QueryRowContext(ctx).Scan(&d)\n\tdl, _ := ctx.Deadline()\n\tsince := time.Since(dl)\n\tif since > ctxTimeout {\n\t\tt.Logf(\"FAIL %s: query returned after context deadline: %v\\n\", t.Name(), since)\n\t\tt.Fail()\n\t}\n\tif pgErr := (*Error)(nil); !(errors.As(err, &pgErr) && pgErr.Code == cancelErrorCode) {\n\t\tt.Logf(\"ctx.Err(): [%T]%+v\\n\", ctx.Err(), ctx.Err())\n\t\tt.Logf(\"got err: [%T] %+v expected errCode: %v\", err, err, cancelErrorCode)\n\t\tt.Fail()\n\t}\n}\n\nfunc TestIssue1062(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\t// Ensure that cancelling a QueryRowContext does not result in an ErrBadConn.\n\n\tfor i := 0; i < 100; i++ {\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tgo cancel()\n\t\trow := db.QueryRowContext(ctx, \"select 1\")\n\n\t\tvar v int\n\t\terr := row.Scan(&v)\n\t\tif pgErr := (*Error)(nil); err != nil &&\n\t\t\terr != context.Canceled &&\n\t\t\t!(errors.As(err, &pgErr) && pgErr.Code == cancelErrorCode) {\n\t\t\tt.Fatalf(\"Scan resulted in unexpected error %v for canceled QueryRowContext at attempt %d\", err, i+1)\n\t\t}\n\t}\n}\n\nfunc connIsValid(t *testing.T, db *sql.DB) {\n\tt.Helper()\n\n\tctx := context.Background()\n\tconn, err := db.Conn(ctx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer conn.Close()\n\n\t// the connection must be valid\n\terr = conn.PingContext(ctx)\n\tif err != nil {\n\t\tt.Errorf(\"PingContext err=%#v\", err)\n\t}\n\t// close must not return an error\n\terr = conn.Close()\n\tif err != nil {\n\t\tt.Errorf(\"Close err=%#v\", err)\n\t}\n}\n\nfunc TestQueryCancelRace(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\t// cancel a query while executing on Postgres: must return the cancelled error code\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo func() {\n\t\ttime.Sleep(10 * time.Millisecond)\n\t\tcancel()\n\t}()\n\trow := db.QueryRowContext(ctx, \"select pg_sleep(0.5)\")\n\tvar pgSleepVoid string\n\terr := row.Scan(&pgSleepVoid)\n\tif pgErr := (*Error)(nil); !(errors.As(err, &pgErr) && pgErr.Code == cancelErrorCode) {\n\t\tt.Fatalf(\"expected cancelled error; err=%#v\", err)\n\t}\n\n\t// get a connection: it must be a valid\n\tconnIsValid(t, db)\n}\n\n// Test cancelling a scan after it is started. This broke with 1.10.4.\nfunc TestQueryCancelledReused(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\t// run a query that returns a lot of data\n\trows, err := db.QueryContext(ctx, \"select generate_series(1, 10000)\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// scan the first value\n\tif !rows.Next() {\n\t\tt.Error(\"expected rows.Next() to return true\")\n\t}\n\tvar i int\n\terr = rows.Scan(&i)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif i != 1 {\n\t\tt.Error(i)\n\t}\n\n\t// cancel the context and close rows, ignoring errors\n\tcancel()\n\trows.Close()\n\n\t// get a connection: it must be valid\n\tconnIsValid(t, db)\n}\n"
        },
        {
          "name": "krb.go",
          "type": "blob",
          "size": 0.7958984375,
          "content": "package pq\n\n// NewGSSFunc creates a GSS authentication provider, for use with\n// RegisterGSSProvider.\ntype NewGSSFunc func() (GSS, error)\n\nvar newGss NewGSSFunc\n\n// RegisterGSSProvider registers a GSS authentication provider. For example, if\n// you need to use Kerberos to authenticate with your server, add this to your\n// main package:\n//\n//\timport \"github.com/lib/pq/auth/kerberos\"\n//\n//\tfunc init() {\n//\t\tpq.RegisterGSSProvider(func() (pq.GSS, error) { return kerberos.NewGSS() })\n//\t}\nfunc RegisterGSSProvider(newGssArg NewGSSFunc) {\n\tnewGss = newGssArg\n}\n\n// GSS provides GSSAPI authentication (e.g., Kerberos).\ntype GSS interface {\n\tGetInitToken(host string, service string) ([]byte, error)\n\tGetInitTokenFromSpn(spn string) ([]byte, error)\n\tContinue(inToken []byte) (done bool, outToken []byte, err error)\n}\n"
        },
        {
          "name": "notice.go",
          "type": "blob",
          "size": 2.49609375,
          "content": "//go:build go1.10\n// +build go1.10\n\npackage pq\n\nimport (\n\t\"context\"\n\t\"database/sql/driver\"\n)\n\n// NoticeHandler returns the notice handler on the given connection, if any. A\n// runtime panic occurs if c is not a pq connection. This is rarely used\n// directly, use ConnectorNoticeHandler and ConnectorWithNoticeHandler instead.\nfunc NoticeHandler(c driver.Conn) func(*Error) {\n\treturn c.(*conn).noticeHandler\n}\n\n// SetNoticeHandler sets the given notice handler on the given connection. A\n// runtime panic occurs if c is not a pq connection. A nil handler may be used\n// to unset it. This is rarely used directly, use ConnectorNoticeHandler and\n// ConnectorWithNoticeHandler instead.\n//\n// Note: Notice handlers are executed synchronously by pq meaning commands\n// won't continue to be processed until the handler returns.\nfunc SetNoticeHandler(c driver.Conn, handler func(*Error)) {\n\tc.(*conn).noticeHandler = handler\n}\n\n// NoticeHandlerConnector wraps a regular connector and sets a notice handler\n// on it.\ntype NoticeHandlerConnector struct {\n\tdriver.Connector\n\tnoticeHandler func(*Error)\n}\n\n// Connect calls the underlying connector's connect method and then sets the\n// notice handler.\nfunc (n *NoticeHandlerConnector) Connect(ctx context.Context) (driver.Conn, error) {\n\tc, err := n.Connector.Connect(ctx)\n\tif err == nil {\n\t\tSetNoticeHandler(c, n.noticeHandler)\n\t}\n\treturn c, err\n}\n\n// ConnectorNoticeHandler returns the currently set notice handler, if any. If\n// the given connector is not a result of ConnectorWithNoticeHandler, nil is\n// returned.\nfunc ConnectorNoticeHandler(c driver.Connector) func(*Error) {\n\tif c, ok := c.(*NoticeHandlerConnector); ok {\n\t\treturn c.noticeHandler\n\t}\n\treturn nil\n}\n\n// ConnectorWithNoticeHandler creates or sets the given handler for the given\n// connector. If the given connector is a result of calling this function\n// previously, it is simply set on the given connector and returned. Otherwise,\n// this returns a new connector wrapping the given one and setting the notice\n// handler. A nil notice handler may be used to unset it.\n//\n// The returned connector is intended to be used with database/sql.OpenDB.\n//\n// Note: Notice handlers are executed synchronously by pq meaning commands\n// won't continue to be processed until the handler returns.\nfunc ConnectorWithNoticeHandler(c driver.Connector, handler func(*Error)) *NoticeHandlerConnector {\n\tif c, ok := c.(*NoticeHandlerConnector); ok {\n\t\tc.noticeHandler = handler\n\t\treturn c\n\t}\n\treturn &NoticeHandlerConnector{Connector: c, noticeHandler: handler}\n}\n"
        },
        {
          "name": "notice_example_test.go",
          "type": "blob",
          "size": 0.681640625,
          "content": "//go:build go1.10\n// +build go1.10\n\npackage pq_test\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/lib/pq\"\n)\n\nfunc ExampleConnectorWithNoticeHandler() {\n\tname := \"\"\n\t// Base connector to wrap\n\tbase, err := pq.NewConnector(name)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// Wrap the connector to simply print out the message\n\tconnector := pq.ConnectorWithNoticeHandler(base, func(notice *pq.Error) {\n\t\tfmt.Println(\"Notice sent: \" + notice.Message)\n\t})\n\tdb := sql.OpenDB(connector)\n\tdefer db.Close()\n\t// Raise a notice\n\tsql := \"DO language plpgsql $$ BEGIN RAISE NOTICE 'test notice'; END $$\"\n\tif _, err := db.Exec(sql); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// Output:\n\t// Notice sent: test notice\n}\n"
        },
        {
          "name": "notice_test.go",
          "type": "blob",
          "size": 1.421875,
          "content": "//go:build go1.10\n// +build go1.10\n\npackage pq\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"testing\"\n)\n\nfunc TestConnectorWithNoticeHandler_Simple(t *testing.T) {\n\tb, err := NewConnector(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar notice *Error\n\t// Make connector w/ handler to set the local var\n\tc := ConnectorWithNoticeHandler(b, func(n *Error) { notice = n })\n\traiseNotice(c, t, \"Test notice #1\")\n\tif notice == nil || notice.Message != \"Test notice #1\" {\n\t\tt.Fatalf(\"Expected notice w/ message, got %v\", notice)\n\t}\n\t// Unset the handler on the same connector\n\tprevC := c\n\tif c = ConnectorWithNoticeHandler(c, nil); c != prevC {\n\t\tt.Fatalf(\"Expected to not create new connector but did\")\n\t}\n\traiseNotice(c, t, \"Test notice #2\")\n\tif notice == nil || notice.Message != \"Test notice #1\" {\n\t\tt.Fatalf(\"Expected notice to not change, got %v\", notice)\n\t}\n\t// Set it back on the same connector\n\tif c = ConnectorWithNoticeHandler(c, func(n *Error) { notice = n }); c != prevC {\n\t\tt.Fatal(\"Expected to not create new connector but did\")\n\t}\n\traiseNotice(c, t, \"Test notice #3\")\n\tif notice == nil || notice.Message != \"Test notice #3\" {\n\t\tt.Fatalf(\"Expected notice w/ message, got %v\", notice)\n\t}\n}\n\nfunc raiseNotice(c driver.Connector, t *testing.T, escapedNotice string) {\n\tdb := sql.OpenDB(c)\n\tdefer db.Close()\n\tsql := \"DO language plpgsql $$ BEGIN RAISE NOTICE '\" + escapedNotice + \"'; END $$\"\n\tif _, err := db.Exec(sql); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n"
        },
        {
          "name": "notify.go",
          "type": "blob",
          "size": 24.994140625,
          "content": "package pq\n\n// Package pq is a pure Go Postgres driver for the database/sql package.\n// This module contains support for Postgres LISTEN/NOTIFY.\n\nimport (\n\t\"context\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\n// Notification represents a single notification from the database.\ntype Notification struct {\n\t// Process ID (PID) of the notifying postgres backend.\n\tBePid int\n\t// Name of the channel the notification was sent on.\n\tChannel string\n\t// Payload, or the empty string if unspecified.\n\tExtra string\n}\n\nfunc recvNotification(r *readBuf) *Notification {\n\tbePid := r.int32()\n\tchannel := r.string()\n\textra := r.string()\n\n\treturn &Notification{bePid, channel, extra}\n}\n\n// SetNotificationHandler sets the given notification handler on the given\n// connection. A runtime panic occurs if c is not a pq connection. A nil handler\n// may be used to unset it.\n//\n// Note: Notification handlers are executed synchronously by pq meaning commands\n// won't continue to be processed until the handler returns.\nfunc SetNotificationHandler(c driver.Conn, handler func(*Notification)) {\n\tc.(*conn).notificationHandler = handler\n}\n\n// NotificationHandlerConnector wraps a regular connector and sets a notification handler\n// on it.\ntype NotificationHandlerConnector struct {\n\tdriver.Connector\n\tnotificationHandler func(*Notification)\n}\n\n// Connect calls the underlying connector's connect method and then sets the\n// notification handler.\nfunc (n *NotificationHandlerConnector) Connect(ctx context.Context) (driver.Conn, error) {\n\tc, err := n.Connector.Connect(ctx)\n\tif err == nil {\n\t\tSetNotificationHandler(c, n.notificationHandler)\n\t}\n\treturn c, err\n}\n\n// ConnectorNotificationHandler returns the currently set notification handler, if any. If\n// the given connector is not a result of ConnectorWithNotificationHandler, nil is\n// returned.\nfunc ConnectorNotificationHandler(c driver.Connector) func(*Notification) {\n\tif c, ok := c.(*NotificationHandlerConnector); ok {\n\t\treturn c.notificationHandler\n\t}\n\treturn nil\n}\n\n// ConnectorWithNotificationHandler creates or sets the given handler for the given\n// connector. If the given connector is a result of calling this function\n// previously, it is simply set on the given connector and returned. Otherwise,\n// this returns a new connector wrapping the given one and setting the notification\n// handler. A nil notification handler may be used to unset it.\n//\n// The returned connector is intended to be used with database/sql.OpenDB.\n//\n// Note: Notification handlers are executed synchronously by pq meaning commands\n// won't continue to be processed until the handler returns.\nfunc ConnectorWithNotificationHandler(c driver.Connector, handler func(*Notification)) *NotificationHandlerConnector {\n\tif c, ok := c.(*NotificationHandlerConnector); ok {\n\t\tc.notificationHandler = handler\n\t\treturn c\n\t}\n\treturn &NotificationHandlerConnector{Connector: c, notificationHandler: handler}\n}\n\nconst (\n\tconnStateIdle int32 = iota\n\tconnStateExpectResponse\n\tconnStateExpectReadyForQuery\n)\n\ntype message struct {\n\ttyp byte\n\terr error\n}\n\nvar errListenerConnClosed = errors.New(\"pq: ListenerConn has been closed\")\n\n// ListenerConn is a low-level interface for waiting for notifications.  You\n// should use Listener instead.\ntype ListenerConn struct {\n\t// guards cn and err\n\tconnectionLock sync.Mutex\n\tcn             *conn\n\terr            error\n\n\tconnState int32\n\n\t// the sending goroutine will be holding this lock\n\tsenderLock sync.Mutex\n\n\tnotificationChan chan<- *Notification\n\n\treplyChan chan message\n}\n\n// NewListenerConn creates a new ListenerConn. Use NewListener instead.\nfunc NewListenerConn(name string, notificationChan chan<- *Notification) (*ListenerConn, error) {\n\treturn newDialListenerConn(defaultDialer{}, name, notificationChan)\n}\n\nfunc newDialListenerConn(d Dialer, name string, c chan<- *Notification) (*ListenerConn, error) {\n\tcn, err := DialOpen(d, name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tl := &ListenerConn{\n\t\tcn:               cn.(*conn),\n\t\tnotificationChan: c,\n\t\tconnState:        connStateIdle,\n\t\treplyChan:        make(chan message, 2),\n\t}\n\n\tgo l.listenerConnMain()\n\n\treturn l, nil\n}\n\n// We can only allow one goroutine at a time to be running a query on the\n// connection for various reasons, so the goroutine sending on the connection\n// must be holding senderLock.\n//\n// Returns an error if an unrecoverable error has occurred and the ListenerConn\n// should be abandoned.\nfunc (l *ListenerConn) acquireSenderLock() error {\n\t// we must acquire senderLock first to avoid deadlocks; see ExecSimpleQuery\n\tl.senderLock.Lock()\n\n\tl.connectionLock.Lock()\n\terr := l.err\n\tl.connectionLock.Unlock()\n\tif err != nil {\n\t\tl.senderLock.Unlock()\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (l *ListenerConn) releaseSenderLock() {\n\tl.senderLock.Unlock()\n}\n\n// setState advances the protocol state to newState.  Returns false if moving\n// to that state from the current state is not allowed.\nfunc (l *ListenerConn) setState(newState int32) bool {\n\tvar expectedState int32\n\n\tswitch newState {\n\tcase connStateIdle:\n\t\texpectedState = connStateExpectReadyForQuery\n\tcase connStateExpectResponse:\n\t\texpectedState = connStateIdle\n\tcase connStateExpectReadyForQuery:\n\t\texpectedState = connStateExpectResponse\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unexpected listenerConnState %d\", newState))\n\t}\n\n\treturn atomic.CompareAndSwapInt32(&l.connState, expectedState, newState)\n}\n\n// Main logic is here: receive messages from the postgres backend, forward\n// notifications and query replies and keep the internal state in sync with the\n// protocol state.  Returns when the connection has been lost, is about to go\n// away or should be discarded because we couldn't agree on the state with the\n// server backend.\nfunc (l *ListenerConn) listenerConnLoop() (err error) {\n\tdefer errRecoverNoErrBadConn(&err)\n\n\tr := &readBuf{}\n\tfor {\n\t\tt, err := l.cn.recvMessage(r)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch t {\n\t\tcase 'A':\n\t\t\t// recvNotification copies all the data so we don't need to worry\n\t\t\t// about the scratch buffer being overwritten.\n\t\t\tl.notificationChan <- recvNotification(r)\n\n\t\tcase 'T', 'D':\n\t\t\t// only used by tests; ignore\n\n\t\tcase 'E':\n\t\t\t// We might receive an ErrorResponse even when not in a query; it\n\t\t\t// is expected that the server will close the connection after\n\t\t\t// that, but we should make sure that the error we display is the\n\t\t\t// one from the stray ErrorResponse, not io.ErrUnexpectedEOF.\n\t\t\tif !l.setState(connStateExpectReadyForQuery) {\n\t\t\t\treturn parseError(r)\n\t\t\t}\n\t\t\tl.replyChan <- message{t, parseError(r)}\n\n\t\tcase 'C', 'I':\n\t\t\tif !l.setState(connStateExpectReadyForQuery) {\n\t\t\t\t// protocol out of sync\n\t\t\t\treturn fmt.Errorf(\"unexpected CommandComplete\")\n\t\t\t}\n\t\t\t// ExecSimpleQuery doesn't need to know about this message\n\n\t\tcase 'Z':\n\t\t\tif !l.setState(connStateIdle) {\n\t\t\t\t// protocol out of sync\n\t\t\t\treturn fmt.Errorf(\"unexpected ReadyForQuery\")\n\t\t\t}\n\t\t\tl.replyChan <- message{t, nil}\n\n\t\tcase 'S':\n\t\t\t// ignore\n\t\tcase 'N':\n\t\t\tif n := l.cn.noticeHandler; n != nil {\n\t\t\t\tn(parseError(r))\n\t\t\t}\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unexpected message %q from server in listenerConnLoop\", t)\n\t\t}\n\t}\n}\n\n// This is the main routine for the goroutine receiving on the database\n// connection.  Most of the main logic is in listenerConnLoop.\nfunc (l *ListenerConn) listenerConnMain() {\n\terr := l.listenerConnLoop()\n\n\t// listenerConnLoop terminated; we're done, but we still have to clean up.\n\t// Make sure nobody tries to start any new queries by making sure the err\n\t// pointer is set.  It is important that we do not overwrite its value; a\n\t// connection could be closed by either this goroutine or one sending on\n\t// the connection -- whoever closes the connection is assumed to have the\n\t// more meaningful error message (as the other one will probably get\n\t// net.errClosed), so that goroutine sets the error we expose while the\n\t// other error is discarded.  If the connection is lost while two\n\t// goroutines are operating on the socket, it probably doesn't matter which\n\t// error we expose so we don't try to do anything more complex.\n\tl.connectionLock.Lock()\n\tif l.err == nil {\n\t\tl.err = err\n\t}\n\tl.cn.Close()\n\tl.connectionLock.Unlock()\n\n\t// There might be a query in-flight; make sure nobody's waiting for a\n\t// response to it, since there's not going to be one.\n\tclose(l.replyChan)\n\n\t// let the listener know we're done\n\tclose(l.notificationChan)\n\n\t// this ListenerConn is done\n}\n\n// Listen sends a LISTEN query to the server. See ExecSimpleQuery.\nfunc (l *ListenerConn) Listen(channel string) (bool, error) {\n\treturn l.ExecSimpleQuery(\"LISTEN \" + QuoteIdentifier(channel))\n}\n\n// Unlisten sends an UNLISTEN query to the server. See ExecSimpleQuery.\nfunc (l *ListenerConn) Unlisten(channel string) (bool, error) {\n\treturn l.ExecSimpleQuery(\"UNLISTEN \" + QuoteIdentifier(channel))\n}\n\n// UnlistenAll sends an `UNLISTEN *` query to the server. See ExecSimpleQuery.\nfunc (l *ListenerConn) UnlistenAll() (bool, error) {\n\treturn l.ExecSimpleQuery(\"UNLISTEN *\")\n}\n\n// Ping the remote server to make sure it's alive.  Non-nil error means the\n// connection has failed and should be abandoned.\nfunc (l *ListenerConn) Ping() error {\n\tsent, err := l.ExecSimpleQuery(\"\")\n\tif !sent {\n\t\treturn err\n\t}\n\tif err != nil {\n\t\t// shouldn't happen\n\t\tpanic(err)\n\t}\n\treturn nil\n}\n\n// Attempt to send a query on the connection.  Returns an error if sending the\n// query failed, and the caller should initiate closure of this connection.\n// The caller must be holding senderLock (see acquireSenderLock and\n// releaseSenderLock).\nfunc (l *ListenerConn) sendSimpleQuery(q string) (err error) {\n\tdefer errRecoverNoErrBadConn(&err)\n\n\t// must set connection state before sending the query\n\tif !l.setState(connStateExpectResponse) {\n\t\tpanic(\"two queries running at the same time\")\n\t}\n\n\t// Can't use l.cn.writeBuf here because it uses the scratch buffer which\n\t// might get overwritten by listenerConnLoop.\n\tb := &writeBuf{\n\t\tbuf: []byte(\"Q\\x00\\x00\\x00\\x00\"),\n\t\tpos: 1,\n\t}\n\tb.string(q)\n\tl.cn.send(b)\n\n\treturn nil\n}\n\n// ExecSimpleQuery executes a \"simple query\" (i.e. one with no bindable\n// parameters) on the connection. The possible return values are:\n//   1) \"executed\" is true; the query was executed to completion on the\n//      database server.  If the query failed, err will be set to the error\n//      returned by the database, otherwise err will be nil.\n//   2) If \"executed\" is false, the query could not be executed on the remote\n//      server.  err will be non-nil.\n//\n// After a call to ExecSimpleQuery has returned an executed=false value, the\n// connection has either been closed or will be closed shortly thereafter, and\n// all subsequently executed queries will return an error.\nfunc (l *ListenerConn) ExecSimpleQuery(q string) (executed bool, err error) {\n\tif err = l.acquireSenderLock(); err != nil {\n\t\treturn false, err\n\t}\n\tdefer l.releaseSenderLock()\n\n\terr = l.sendSimpleQuery(q)\n\tif err != nil {\n\t\t// We can't know what state the protocol is in, so we need to abandon\n\t\t// this connection.\n\t\tl.connectionLock.Lock()\n\t\t// Set the error pointer if it hasn't been set already; see\n\t\t// listenerConnMain.\n\t\tif l.err == nil {\n\t\t\tl.err = err\n\t\t}\n\t\tl.connectionLock.Unlock()\n\t\tl.cn.c.Close()\n\t\treturn false, err\n\t}\n\n\t// now we just wait for a reply..\n\tfor {\n\t\tm, ok := <-l.replyChan\n\t\tif !ok {\n\t\t\t// We lost the connection to server, don't bother waiting for a\n\t\t\t// a response.  err should have been set already.\n\t\t\tl.connectionLock.Lock()\n\t\t\terr := l.err\n\t\t\tl.connectionLock.Unlock()\n\t\t\treturn false, err\n\t\t}\n\t\tswitch m.typ {\n\t\tcase 'Z':\n\t\t\t// sanity check\n\t\t\tif m.err != nil {\n\t\t\t\tpanic(\"m.err != nil\")\n\t\t\t}\n\t\t\t// done; err might or might not be set\n\t\t\treturn true, err\n\n\t\tcase 'E':\n\t\t\t// sanity check\n\t\t\tif m.err == nil {\n\t\t\t\tpanic(\"m.err == nil\")\n\t\t\t}\n\t\t\t// server responded with an error; ReadyForQuery to follow\n\t\t\terr = m.err\n\n\t\tdefault:\n\t\t\treturn false, fmt.Errorf(\"unknown response for simple query: %q\", m.typ)\n\t\t}\n\t}\n}\n\n// Close closes the connection.\nfunc (l *ListenerConn) Close() error {\n\tl.connectionLock.Lock()\n\tif l.err != nil {\n\t\tl.connectionLock.Unlock()\n\t\treturn errListenerConnClosed\n\t}\n\tl.err = errListenerConnClosed\n\tl.connectionLock.Unlock()\n\t// We can't send anything on the connection without holding senderLock.\n\t// Simply close the net.Conn to wake up everyone operating on it.\n\treturn l.cn.c.Close()\n}\n\n// Err returns the reason the connection was closed. It is not safe to call\n// this function until l.Notify has been closed.\nfunc (l *ListenerConn) Err() error {\n\treturn l.err\n}\n\nvar errListenerClosed = errors.New(\"pq: Listener has been closed\")\n\n// ErrChannelAlreadyOpen is returned from Listen when a channel is already\n// open.\nvar ErrChannelAlreadyOpen = errors.New(\"pq: channel is already open\")\n\n// ErrChannelNotOpen is returned from Unlisten when a channel is not open.\nvar ErrChannelNotOpen = errors.New(\"pq: channel is not open\")\n\n// ListenerEventType is an enumeration of listener event types.\ntype ListenerEventType int\n\nconst (\n\t// ListenerEventConnected is emitted only when the database connection\n\t// has been initially initialized. The err argument of the callback\n\t// will always be nil.\n\tListenerEventConnected ListenerEventType = iota\n\n\t// ListenerEventDisconnected is emitted after a database connection has\n\t// been lost, either because of an error or because Close has been\n\t// called. The err argument will be set to the reason the database\n\t// connection was lost.\n\tListenerEventDisconnected\n\n\t// ListenerEventReconnected is emitted after a database connection has\n\t// been re-established after connection loss. The err argument of the\n\t// callback will always be nil. After this event has been emitted, a\n\t// nil pq.Notification is sent on the Listener.Notify channel.\n\tListenerEventReconnected\n\n\t// ListenerEventConnectionAttemptFailed is emitted after a connection\n\t// to the database was attempted, but failed. The err argument will be\n\t// set to an error describing why the connection attempt did not\n\t// succeed.\n\tListenerEventConnectionAttemptFailed\n)\n\n// EventCallbackType is the event callback type. See also ListenerEventType\n// constants' documentation.\ntype EventCallbackType func(event ListenerEventType, err error)\n\n// Listener provides an interface for listening to notifications from a\n// PostgreSQL database.  For general usage information, see section\n// \"Notifications\".\n//\n// Listener can safely be used from concurrently running goroutines.\ntype Listener struct {\n\t// Channel for receiving notifications from the database.  In some cases a\n\t// nil value will be sent.  See section \"Notifications\" above.\n\tNotify chan *Notification\n\n\tname                 string\n\tminReconnectInterval time.Duration\n\tmaxReconnectInterval time.Duration\n\tdialer               Dialer\n\teventCallback        EventCallbackType\n\n\tlock                 sync.Mutex\n\tisClosed             bool\n\treconnectCond        *sync.Cond\n\tcn                   *ListenerConn\n\tconnNotificationChan <-chan *Notification\n\tchannels             map[string]struct{}\n}\n\n// NewListener creates a new database connection dedicated to LISTEN / NOTIFY.\n//\n// name should be set to a connection string to be used to establish the\n// database connection (see section \"Connection String Parameters\" above).\n//\n// minReconnectInterval controls the duration to wait before trying to\n// re-establish the database connection after connection loss.  After each\n// consecutive failure this interval is doubled, until maxReconnectInterval is\n// reached.  Successfully completing the connection establishment procedure\n// resets the interval back to minReconnectInterval.\n//\n// The last parameter eventCallback can be set to a function which will be\n// called by the Listener when the state of the underlying database connection\n// changes.  This callback will be called by the goroutine which dispatches the\n// notifications over the Notify channel, so you should try to avoid doing\n// potentially time-consuming operations from the callback.\nfunc NewListener(name string,\n\tminReconnectInterval time.Duration,\n\tmaxReconnectInterval time.Duration,\n\teventCallback EventCallbackType) *Listener {\n\treturn NewDialListener(defaultDialer{}, name, minReconnectInterval, maxReconnectInterval, eventCallback)\n}\n\n// NewDialListener is like NewListener but it takes a Dialer.\nfunc NewDialListener(d Dialer,\n\tname string,\n\tminReconnectInterval time.Duration,\n\tmaxReconnectInterval time.Duration,\n\teventCallback EventCallbackType) *Listener {\n\n\tl := &Listener{\n\t\tname:                 name,\n\t\tminReconnectInterval: minReconnectInterval,\n\t\tmaxReconnectInterval: maxReconnectInterval,\n\t\tdialer:               d,\n\t\teventCallback:        eventCallback,\n\n\t\tchannels: make(map[string]struct{}),\n\n\t\tNotify: make(chan *Notification, 32),\n\t}\n\tl.reconnectCond = sync.NewCond(&l.lock)\n\n\tgo l.listenerMain()\n\n\treturn l\n}\n\n// NotificationChannel returns the notification channel for this listener.\n// This is the same channel as Notify, and will not be recreated during the\n// life time of the Listener.\nfunc (l *Listener) NotificationChannel() <-chan *Notification {\n\treturn l.Notify\n}\n\n// Listen starts listening for notifications on a channel.  Calls to this\n// function will block until an acknowledgement has been received from the\n// server.  Note that Listener automatically re-establishes the connection\n// after connection loss, so this function may block indefinitely if the\n// connection can not be re-established.\n//\n// Listen will only fail in three conditions:\n//   1) The channel is already open.  The returned error will be\n//      ErrChannelAlreadyOpen.\n//   2) The query was executed on the remote server, but PostgreSQL returned an\n//      error message in response to the query.  The returned error will be a\n//      pq.Error containing the information the server supplied.\n//   3) Close is called on the Listener before the request could be completed.\n//\n// The channel name is case-sensitive.\nfunc (l *Listener) Listen(channel string) error {\n\tl.lock.Lock()\n\tdefer l.lock.Unlock()\n\n\tif l.isClosed {\n\t\treturn errListenerClosed\n\t}\n\n\t// The server allows you to issue a LISTEN on a channel which is already\n\t// open, but it seems useful to be able to detect this case to spot for\n\t// mistakes in application logic.  If the application genuinely does't\n\t// care, it can check the exported error and ignore it.\n\t_, exists := l.channels[channel]\n\tif exists {\n\t\treturn ErrChannelAlreadyOpen\n\t}\n\n\tif l.cn != nil {\n\t\t// If gotResponse is true but error is set, the query was executed on\n\t\t// the remote server, but resulted in an error.  This should be\n\t\t// relatively rare, so it's fine if we just pass the error to our\n\t\t// caller.  However, if gotResponse is false, we could not complete the\n\t\t// query on the remote server and our underlying connection is about\n\t\t// to go away, so we only add relname to l.channels, and wait for\n\t\t// resync() to take care of the rest.\n\t\tgotResponse, err := l.cn.Listen(channel)\n\t\tif gotResponse && err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tl.channels[channel] = struct{}{}\n\tfor l.cn == nil {\n\t\tl.reconnectCond.Wait()\n\t\t// we let go of the mutex for a while\n\t\tif l.isClosed {\n\t\t\treturn errListenerClosed\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Unlisten removes a channel from the Listener's channel list.  Returns\n// ErrChannelNotOpen if the Listener is not listening on the specified channel.\n// Returns immediately with no error if there is no connection.  Note that you\n// might still get notifications for this channel even after Unlisten has\n// returned.\n//\n// The channel name is case-sensitive.\nfunc (l *Listener) Unlisten(channel string) error {\n\tl.lock.Lock()\n\tdefer l.lock.Unlock()\n\n\tif l.isClosed {\n\t\treturn errListenerClosed\n\t}\n\n\t// Similarly to LISTEN, this is not an error in Postgres, but it seems\n\t// useful to distinguish from the normal conditions.\n\t_, exists := l.channels[channel]\n\tif !exists {\n\t\treturn ErrChannelNotOpen\n\t}\n\n\tif l.cn != nil {\n\t\t// Similarly to Listen (see comment in that function), the caller\n\t\t// should only be bothered with an error if it came from the backend as\n\t\t// a response to our query.\n\t\tgotResponse, err := l.cn.Unlisten(channel)\n\t\tif gotResponse && err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Don't bother waiting for resync if there's no connection.\n\tdelete(l.channels, channel)\n\treturn nil\n}\n\n// UnlistenAll removes all channels from the Listener's channel list.  Returns\n// immediately with no error if there is no connection.  Note that you might\n// still get notifications for any of the deleted channels even after\n// UnlistenAll has returned.\nfunc (l *Listener) UnlistenAll() error {\n\tl.lock.Lock()\n\tdefer l.lock.Unlock()\n\n\tif l.isClosed {\n\t\treturn errListenerClosed\n\t}\n\n\tif l.cn != nil {\n\t\t// Similarly to Listen (see comment in that function), the caller\n\t\t// should only be bothered with an error if it came from the backend as\n\t\t// a response to our query.\n\t\tgotResponse, err := l.cn.UnlistenAll()\n\t\tif gotResponse && err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Don't bother waiting for resync if there's no connection.\n\tl.channels = make(map[string]struct{})\n\treturn nil\n}\n\n// Ping the remote server to make sure it's alive.  Non-nil return value means\n// that there is no active connection.\nfunc (l *Listener) Ping() error {\n\tl.lock.Lock()\n\tdefer l.lock.Unlock()\n\n\tif l.isClosed {\n\t\treturn errListenerClosed\n\t}\n\tif l.cn == nil {\n\t\treturn errors.New(\"no connection\")\n\t}\n\n\treturn l.cn.Ping()\n}\n\n// Clean up after losing the server connection.  Returns l.cn.Err(), which\n// should have the reason the connection was lost.\nfunc (l *Listener) disconnectCleanup() error {\n\tl.lock.Lock()\n\tdefer l.lock.Unlock()\n\n\t// sanity check; can't look at Err() until the channel has been closed\n\tselect {\n\tcase _, ok := <-l.connNotificationChan:\n\t\tif ok {\n\t\t\tpanic(\"connNotificationChan not closed\")\n\t\t}\n\tdefault:\n\t\tpanic(\"connNotificationChan not closed\")\n\t}\n\n\terr := l.cn.Err()\n\tl.cn.Close()\n\tl.cn = nil\n\treturn err\n}\n\n// Synchronize the list of channels we want to be listening on with the server\n// after the connection has been established.\nfunc (l *Listener) resync(cn *ListenerConn, notificationChan <-chan *Notification) error {\n\tdoneChan := make(chan error)\n\tgo func(notificationChan <-chan *Notification) {\n\t\tfor channel := range l.channels {\n\t\t\t// If we got a response, return that error to our caller as it's\n\t\t\t// going to be more descriptive than cn.Err().\n\t\t\tgotResponse, err := cn.Listen(channel)\n\t\t\tif gotResponse && err != nil {\n\t\t\t\tdoneChan <- err\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// If we couldn't reach the server, wait for notificationChan to\n\t\t\t// close and then return the error message from the connection, as\n\t\t\t// per ListenerConn's interface.\n\t\t\tif err != nil {\n\t\t\t\tfor range notificationChan {\n\t\t\t\t}\n\t\t\t\tdoneChan <- cn.Err()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tdoneChan <- nil\n\t}(notificationChan)\n\n\t// Ignore notifications while synchronization is going on to avoid\n\t// deadlocks.  We have to send a nil notification over Notify anyway as\n\t// we can't possibly know which notifications (if any) were lost while\n\t// the connection was down, so there's no reason to try and process\n\t// these messages at all.\n\tfor {\n\t\tselect {\n\t\tcase _, ok := <-notificationChan:\n\t\t\tif !ok {\n\t\t\t\tnotificationChan = nil\n\t\t\t}\n\n\t\tcase err := <-doneChan:\n\t\t\treturn err\n\t\t}\n\t}\n}\n\n// caller should NOT be holding l.lock\nfunc (l *Listener) closed() bool {\n\tl.lock.Lock()\n\tdefer l.lock.Unlock()\n\n\treturn l.isClosed\n}\n\nfunc (l *Listener) connect() error {\n\tnotificationChan := make(chan *Notification, 32)\n\tcn, err := newDialListenerConn(l.dialer, l.name, notificationChan)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tl.lock.Lock()\n\tdefer l.lock.Unlock()\n\n\terr = l.resync(cn, notificationChan)\n\tif err != nil {\n\t\tcn.Close()\n\t\treturn err\n\t}\n\n\tl.cn = cn\n\tl.connNotificationChan = notificationChan\n\tl.reconnectCond.Broadcast()\n\n\treturn nil\n}\n\n// Close disconnects the Listener from the database and shuts it down.\n// Subsequent calls to its methods will return an error.  Close returns an\n// error if the connection has already been closed.\nfunc (l *Listener) Close() error {\n\tl.lock.Lock()\n\tdefer l.lock.Unlock()\n\n\tif l.isClosed {\n\t\treturn errListenerClosed\n\t}\n\n\tif l.cn != nil {\n\t\tl.cn.Close()\n\t}\n\tl.isClosed = true\n\n\t// Unblock calls to Listen()\n\tl.reconnectCond.Broadcast()\n\n\treturn nil\n}\n\nfunc (l *Listener) emitEvent(event ListenerEventType, err error) {\n\tif l.eventCallback != nil {\n\t\tl.eventCallback(event, err)\n\t}\n}\n\n// Main logic here: maintain a connection to the server when possible, wait\n// for notifications and emit events.\nfunc (l *Listener) listenerConnLoop() {\n\tvar nextReconnect time.Time\n\n\treconnectInterval := l.minReconnectInterval\n\tfor {\n\t\tfor {\n\t\t\terr := l.connect()\n\t\t\tif err == nil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif l.closed() {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tl.emitEvent(ListenerEventConnectionAttemptFailed, err)\n\n\t\t\ttime.Sleep(reconnectInterval)\n\t\t\treconnectInterval *= 2\n\t\t\tif reconnectInterval > l.maxReconnectInterval {\n\t\t\t\treconnectInterval = l.maxReconnectInterval\n\t\t\t}\n\t\t}\n\n\t\tif nextReconnect.IsZero() {\n\t\t\tl.emitEvent(ListenerEventConnected, nil)\n\t\t} else {\n\t\t\tl.emitEvent(ListenerEventReconnected, nil)\n\t\t\tl.Notify <- nil\n\t\t}\n\n\t\treconnectInterval = l.minReconnectInterval\n\t\tnextReconnect = time.Now().Add(reconnectInterval)\n\n\t\tfor {\n\t\t\tnotification, ok := <-l.connNotificationChan\n\t\t\tif !ok {\n\t\t\t\t// lost connection, loop again\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tl.Notify <- notification\n\t\t}\n\n\t\terr := l.disconnectCleanup()\n\t\tif l.closed() {\n\t\t\treturn\n\t\t}\n\t\tl.emitEvent(ListenerEventDisconnected, err)\n\n\t\ttime.Sleep(time.Until(nextReconnect))\n\t}\n}\n\nfunc (l *Listener) listenerMain() {\n\tl.listenerConnLoop()\n\tclose(l.Notify)\n}\n"
        },
        {
          "name": "notify_test.go",
          "type": "blob",
          "size": 12.150390625,
          "content": "package pq\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar errNilNotification = errors.New(\"nil notification\")\n\nfunc expectNotification(t *testing.T, ch <-chan *Notification, relname string, extra string) error {\n\tselect {\n\tcase n := <-ch:\n\t\tif n == nil {\n\t\t\treturn errNilNotification\n\t\t}\n\t\tif n.Channel != relname || n.Extra != extra {\n\t\t\treturn fmt.Errorf(\"unexpected notification %v\", n)\n\t\t}\n\t\treturn nil\n\tcase <-time.After(1500 * time.Millisecond):\n\t\treturn fmt.Errorf(\"timeout\")\n\t}\n}\n\nfunc expectNoNotification(t *testing.T, ch <-chan *Notification) error {\n\tselect {\n\tcase n := <-ch:\n\t\treturn fmt.Errorf(\"unexpected notification %v\", n)\n\tcase <-time.After(100 * time.Millisecond):\n\t\treturn nil\n\t}\n}\n\nfunc expectEvent(t *testing.T, eventch <-chan ListenerEventType, et ListenerEventType) error {\n\tselect {\n\tcase e := <-eventch:\n\t\tif e != et {\n\t\t\treturn fmt.Errorf(\"unexpected event %v\", e)\n\t\t}\n\t\treturn nil\n\tcase <-time.After(1500 * time.Millisecond):\n\t\tpanic(\"expectEvent timeout\")\n\t}\n}\n\nfunc expectNoEvent(t *testing.T, eventch <-chan ListenerEventType) error {\n\tselect {\n\tcase e := <-eventch:\n\t\treturn fmt.Errorf(\"unexpected event %v\", e)\n\tcase <-time.After(100 * time.Millisecond):\n\t\treturn nil\n\t}\n}\n\nfunc newTestListenerConn(t *testing.T) (*ListenerConn, <-chan *Notification) {\n\tdatname := os.Getenv(\"PGDATABASE\")\n\tsslmode := os.Getenv(\"PGSSLMODE\")\n\n\tif datname == \"\" {\n\t\tos.Setenv(\"PGDATABASE\", \"pqgotest\")\n\t}\n\n\tif sslmode == \"\" {\n\t\tos.Setenv(\"PGSSLMODE\", \"disable\")\n\t}\n\n\tnotificationChan := make(chan *Notification)\n\tl, err := NewListenerConn(\"\", notificationChan)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn l, notificationChan\n}\n\nfunc TestNewListenerConn(t *testing.T) {\n\tl, _ := newTestListenerConn(t)\n\n\tdefer l.Close()\n}\n\nfunc TestConnListen(t *testing.T) {\n\tl, channel := newTestListenerConn(t)\n\n\tdefer l.Close()\n\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tok, err := l.Listen(\"notify_test\")\n\tif !ok || err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = db.Exec(\"NOTIFY notify_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = expectNotification(t, channel, \"notify_test\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestConnUnlisten(t *testing.T) {\n\tl, channel := newTestListenerConn(t)\n\n\tdefer l.Close()\n\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tok, err := l.Listen(\"notify_test\")\n\tif !ok || err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = db.Exec(\"NOTIFY notify_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = expectNotification(t, channel, \"notify_test\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tok, err = l.Unlisten(\"notify_test\")\n\tif !ok || err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = db.Exec(\"NOTIFY notify_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = expectNoNotification(t, channel)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestConnUnlistenAll(t *testing.T) {\n\tl, channel := newTestListenerConn(t)\n\n\tdefer l.Close()\n\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tok, err := l.Listen(\"notify_test\")\n\tif !ok || err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = db.Exec(\"NOTIFY notify_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = expectNotification(t, channel, \"notify_test\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tok, err = l.UnlistenAll()\n\tif !ok || err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = db.Exec(\"NOTIFY notify_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = expectNoNotification(t, channel)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestConnClose(t *testing.T) {\n\tl, _ := newTestListenerConn(t)\n\tdefer l.Close()\n\n\terr := l.Close()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = l.Close()\n\tif err != errListenerConnClosed {\n\t\tt.Fatalf(\"expected errListenerConnClosed; got %v\", err)\n\t}\n}\n\nfunc TestConnPing(t *testing.T) {\n\tl, _ := newTestListenerConn(t)\n\tdefer l.Close()\n\terr := l.Ping()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = l.Close()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = l.Ping()\n\tif err != errListenerConnClosed {\n\t\tt.Fatalf(\"expected errListenerConnClosed; got %v\", err)\n\t}\n}\n\n// Test for deadlock where a query fails while another one is queued\nfunc TestConnExecDeadlock(t *testing.T) {\n\tl, _ := newTestListenerConn(t)\n\tdefer l.Close()\n\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tl.ExecSimpleQuery(\"SELECT pg_sleep(60)\")\n\t\twg.Done()\n\t}()\n\truntime.Gosched()\n\tgo func() {\n\t\tl.ExecSimpleQuery(\"SELECT 1\")\n\t\twg.Done()\n\t}()\n\t// give the two goroutines some time to get into position\n\truntime.Gosched()\n\t// calls Close on the net.Conn; equivalent to a network failure\n\tl.Close()\n\n\tdefer time.AfterFunc(10*time.Second, func() {\n\t\tpanic(\"timed out\")\n\t}).Stop()\n\twg.Wait()\n}\n\n// Test for ListenerConn being closed while a slow query is executing\nfunc TestListenerConnCloseWhileQueryIsExecuting(t *testing.T) {\n\tl, _ := newTestListenerConn(t)\n\tdefer l.Close()\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\n\tgo func() {\n\t\tsent, err := l.ExecSimpleQuery(\"SELECT pg_sleep(60)\")\n\t\tif sent {\n\t\t\tpanic(\"expected sent=false\")\n\t\t}\n\t\t// could be any of a number of errors\n\t\tif err == nil {\n\t\t\tpanic(\"expected error\")\n\t\t}\n\t\twg.Done()\n\t}()\n\t// give the above goroutine some time to get into position\n\truntime.Gosched()\n\terr := l.Close()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdefer time.AfterFunc(10*time.Second, func() {\n\t\tpanic(\"timed out\")\n\t}).Stop()\n\twg.Wait()\n}\n\nfunc TestNotifyExtra(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tif getServerVersion(t, db) < 90000 {\n\t\tt.Skip(\"skipping NOTIFY payload test since the server does not appear to support it\")\n\t}\n\n\tl, channel := newTestListenerConn(t)\n\tdefer l.Close()\n\n\tok, err := l.Listen(\"notify_test\")\n\tif !ok || err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = db.Exec(\"NOTIFY notify_test, 'something'\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = expectNotification(t, channel, \"notify_test\", \"something\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// create a new test listener and also set the timeouts\nfunc newTestListenerTimeout(t *testing.T, min time.Duration, max time.Duration) (*Listener, <-chan ListenerEventType) {\n\tdatname := os.Getenv(\"PGDATABASE\")\n\tsslmode := os.Getenv(\"PGSSLMODE\")\n\n\tif datname == \"\" {\n\t\tos.Setenv(\"PGDATABASE\", \"pqgotest\")\n\t}\n\n\tif sslmode == \"\" {\n\t\tos.Setenv(\"PGSSLMODE\", \"disable\")\n\t}\n\n\teventch := make(chan ListenerEventType, 16)\n\tl := NewListener(\"\", min, max, func(t ListenerEventType, err error) { eventch <- t })\n\terr := expectEvent(t, eventch, ListenerEventConnected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn l, eventch\n}\n\nfunc newTestListener(t *testing.T) (*Listener, <-chan ListenerEventType) {\n\treturn newTestListenerTimeout(t, time.Hour, time.Hour)\n}\n\nfunc TestListenerListen(t *testing.T) {\n\tl, _ := newTestListener(t)\n\tdefer l.Close()\n\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\terr := l.Listen(\"notify_listen_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = db.Exec(\"NOTIFY notify_listen_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = expectNotification(t, l.Notify, \"notify_listen_test\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestListenerUnlisten(t *testing.T) {\n\tl, _ := newTestListener(t)\n\tdefer l.Close()\n\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\terr := l.Listen(\"notify_listen_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = db.Exec(\"NOTIFY notify_listen_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = l.Unlisten(\"notify_listen_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = expectNotification(t, l.Notify, \"notify_listen_test\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = db.Exec(\"NOTIFY notify_listen_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = expectNoNotification(t, l.Notify)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestListenerUnlistenAll(t *testing.T) {\n\tl, _ := newTestListener(t)\n\tdefer l.Close()\n\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\terr := l.Listen(\"notify_listen_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = db.Exec(\"NOTIFY notify_listen_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = l.UnlistenAll()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = expectNotification(t, l.Notify, \"notify_listen_test\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = db.Exec(\"NOTIFY notify_listen_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = expectNoNotification(t, l.Notify)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestListenerFailedQuery(t *testing.T) {\n\tl, eventch := newTestListener(t)\n\tdefer l.Close()\n\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\terr := l.Listen(\"notify_listen_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = db.Exec(\"NOTIFY notify_listen_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = expectNotification(t, l.Notify, \"notify_listen_test\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// shouldn't cause a disconnect\n\tok, err := l.cn.ExecSimpleQuery(\"SELECT error\")\n\tif !ok {\n\t\tt.Fatalf(\"could not send query to server: %v\", err)\n\t}\n\t_, ok = err.(PGError)\n\tif !ok {\n\t\tt.Fatalf(\"unexpected error %v\", err)\n\t}\n\terr = expectNoEvent(t, eventch)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// should still work\n\t_, err = db.Exec(\"NOTIFY notify_listen_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = expectNotification(t, l.Notify, \"notify_listen_test\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestListenerReconnect(t *testing.T) {\n\tl, eventch := newTestListenerTimeout(t, 20*time.Millisecond, time.Hour)\n\tdefer l.Close()\n\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\terr := l.Listen(\"notify_listen_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = db.Exec(\"NOTIFY notify_listen_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = expectNotification(t, l.Notify, \"notify_listen_test\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// kill the connection and make sure it comes back up\n\tok, err := l.cn.ExecSimpleQuery(\"SELECT pg_terminate_backend(pg_backend_pid())\")\n\tif ok {\n\t\tt.Fatalf(\"could not kill the connection: %v\", err)\n\t}\n\tif err != io.EOF {\n\t\tt.Fatalf(\"unexpected error %v\", err)\n\t}\n\terr = expectEvent(t, eventch, ListenerEventDisconnected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = expectEvent(t, eventch, ListenerEventReconnected)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// should still work\n\t_, err = db.Exec(\"NOTIFY notify_listen_test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// should get nil after Reconnected\n\terr = expectNotification(t, l.Notify, \"\", \"\")\n\tif err != errNilNotification {\n\t\tt.Fatal(err)\n\t}\n\n\terr = expectNotification(t, l.Notify, \"notify_listen_test\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestListenerClose(t *testing.T) {\n\tl, _ := newTestListenerTimeout(t, 20*time.Millisecond, time.Hour)\n\tdefer l.Close()\n\n\terr := l.Close()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = l.Close()\n\tif err != errListenerClosed {\n\t\tt.Fatalf(\"expected errListenerClosed; got %v\", err)\n\t}\n}\n\nfunc TestListenerPing(t *testing.T) {\n\tl, _ := newTestListenerTimeout(t, 20*time.Millisecond, time.Hour)\n\tdefer l.Close()\n\n\terr := l.Ping()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = l.Close()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = l.Ping()\n\tif err != errListenerClosed {\n\t\tt.Fatalf(\"expected errListenerClosed; got %v\", err)\n\t}\n}\n\nfunc TestConnectorWithNotificationHandler_Simple(t *testing.T) {\n\tb, err := NewConnector(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar notification *Notification\n\t// Make connector w/ handler to set the local var\n\tc := ConnectorWithNotificationHandler(b, func(n *Notification) { notification = n })\n\tsendNotification(c, t, \"Test notification #1\")\n\tif notification == nil || notification.Extra != \"Test notification #1\" {\n\t\tt.Fatalf(\"Expected notification w/ message, got %v\", notification)\n\t}\n\t// Unset the handler on the same connector\n\tprevC := c\n\tif c = ConnectorWithNotificationHandler(c, nil); c != prevC {\n\t\tt.Fatalf(\"Expected to not create new connector but did\")\n\t}\n\tsendNotification(c, t, \"Test notification #2\")\n\tif notification == nil || notification.Extra != \"Test notification #1\" {\n\t\tt.Fatalf(\"Expected notification to not change, got %v\", notification)\n\t}\n\t// Set it back on the same connector\n\tif c = ConnectorWithNotificationHandler(c, func(n *Notification) { notification = n }); c != prevC {\n\t\tt.Fatal(\"Expected to not create new connector but did\")\n\t}\n\tsendNotification(c, t, \"Test notification #3\")\n\tif notification == nil || notification.Extra != \"Test notification #3\" {\n\t\tt.Fatalf(\"Expected notification w/ message, got %v\", notification)\n\t}\n}\n\nfunc sendNotification(c driver.Connector, t *testing.T, escapedNotification string) {\n\tdb := sql.OpenDB(c)\n\tdefer db.Close()\n\tsql := fmt.Sprintf(\"LISTEN foo; NOTIFY foo, '%s';\", escapedNotification)\n\tif _, err := db.Exec(sql); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n"
        },
        {
          "name": "oid",
          "type": "tree",
          "content": null
        },
        {
          "name": "rows.go",
          "type": "blob",
          "size": 2.3994140625,
          "content": "package pq\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"time\"\n\n\t\"github.com/lib/pq/oid\"\n)\n\nconst headerSize = 4\n\ntype fieldDesc struct {\n\t// The object ID of the data type.\n\tOID oid.Oid\n\t// The data type size (see pg_type.typlen).\n\t// Note that negative values denote variable-width types.\n\tLen int\n\t// The type modifier (see pg_attribute.atttypmod).\n\t// The meaning of the modifier is type-specific.\n\tMod int\n}\n\nfunc (fd fieldDesc) Type() reflect.Type {\n\tswitch fd.OID {\n\tcase oid.T_int8:\n\t\treturn reflect.TypeOf(int64(0))\n\tcase oid.T_int4:\n\t\treturn reflect.TypeOf(int32(0))\n\tcase oid.T_int2:\n\t\treturn reflect.TypeOf(int16(0))\n\tcase oid.T_varchar, oid.T_text:\n\t\treturn reflect.TypeOf(\"\")\n\tcase oid.T_bool:\n\t\treturn reflect.TypeOf(false)\n\tcase oid.T_date, oid.T_time, oid.T_timetz, oid.T_timestamp, oid.T_timestamptz:\n\t\treturn reflect.TypeOf(time.Time{})\n\tcase oid.T_bytea:\n\t\treturn reflect.TypeOf([]byte(nil))\n\tdefault:\n\t\treturn reflect.TypeOf(new(interface{})).Elem()\n\t}\n}\n\nfunc (fd fieldDesc) Name() string {\n\treturn oid.TypeName[fd.OID]\n}\n\nfunc (fd fieldDesc) Length() (length int64, ok bool) {\n\tswitch fd.OID {\n\tcase oid.T_text, oid.T_bytea:\n\t\treturn math.MaxInt64, true\n\tcase oid.T_varchar, oid.T_bpchar:\n\t\treturn int64(fd.Mod - headerSize), true\n\tdefault:\n\t\treturn 0, false\n\t}\n}\n\nfunc (fd fieldDesc) PrecisionScale() (precision, scale int64, ok bool) {\n\tswitch fd.OID {\n\tcase oid.T_numeric, oid.T__numeric:\n\t\tmod := fd.Mod - headerSize\n\t\tprecision = int64((mod >> 16) & 0xffff)\n\t\tscale = int64(mod & 0xffff)\n\t\treturn precision, scale, true\n\tdefault:\n\t\treturn 0, 0, false\n\t}\n}\n\n// ColumnTypeScanType returns the value type that can be used to scan types into.\nfunc (rs *rows) ColumnTypeScanType(index int) reflect.Type {\n\treturn rs.colTyps[index].Type()\n}\n\n// ColumnTypeDatabaseTypeName return the database system type name.\nfunc (rs *rows) ColumnTypeDatabaseTypeName(index int) string {\n\treturn rs.colTyps[index].Name()\n}\n\n// ColumnTypeLength returns the length of the column type if the column is a\n// variable length type. If the column is not a variable length type ok\n// should return false.\nfunc (rs *rows) ColumnTypeLength(index int) (length int64, ok bool) {\n\treturn rs.colTyps[index].Length()\n}\n\n// ColumnTypePrecisionScale should return the precision and scale for decimal\n// types. If not applicable, ok should be false.\nfunc (rs *rows) ColumnTypePrecisionScale(index int) (precision, scale int64, ok bool) {\n\treturn rs.colTyps[index].PrecisionScale()\n}\n"
        },
        {
          "name": "rows_test.go",
          "type": "blob",
          "size": 4.60546875,
          "content": "package pq\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/lib/pq/oid\"\n)\n\nfunc TestDataTypeName(t *testing.T) {\n\ttts := []struct {\n\t\ttyp  oid.Oid\n\t\tname string\n\t}{\n\t\t{oid.T_int8, \"INT8\"},\n\t\t{oid.T_int4, \"INT4\"},\n\t\t{oid.T_int2, \"INT2\"},\n\t\t{oid.T_varchar, \"VARCHAR\"},\n\t\t{oid.T_text, \"TEXT\"},\n\t\t{oid.T_bool, \"BOOL\"},\n\t\t{oid.T_numeric, \"NUMERIC\"},\n\t\t{oid.T_date, \"DATE\"},\n\t\t{oid.T_time, \"TIME\"},\n\t\t{oid.T_timetz, \"TIMETZ\"},\n\t\t{oid.T_timestamp, \"TIMESTAMP\"},\n\t\t{oid.T_timestamptz, \"TIMESTAMPTZ\"},\n\t\t{oid.T_bytea, \"BYTEA\"},\n\t}\n\n\tfor i, tt := range tts {\n\t\tdt := fieldDesc{OID: tt.typ}\n\t\tif name := dt.Name(); name != tt.name {\n\t\t\tt.Errorf(\"(%d) got: %s want: %s\", i, name, tt.name)\n\t\t}\n\t}\n}\n\nfunc TestDataType(t *testing.T) {\n\ttts := []struct {\n\t\ttyp  oid.Oid\n\t\tkind reflect.Kind\n\t}{\n\t\t{oid.T_int8, reflect.Int64},\n\t\t{oid.T_int4, reflect.Int32},\n\t\t{oid.T_int2, reflect.Int16},\n\t\t{oid.T_varchar, reflect.String},\n\t\t{oid.T_text, reflect.String},\n\t\t{oid.T_bool, reflect.Bool},\n\t\t{oid.T_date, reflect.Struct},\n\t\t{oid.T_time, reflect.Struct},\n\t\t{oid.T_timetz, reflect.Struct},\n\t\t{oid.T_timestamp, reflect.Struct},\n\t\t{oid.T_timestamptz, reflect.Struct},\n\t\t{oid.T_bytea, reflect.Slice},\n\t}\n\n\tfor i, tt := range tts {\n\t\tdt := fieldDesc{OID: tt.typ}\n\t\tif kind := dt.Type().Kind(); kind != tt.kind {\n\t\t\tt.Errorf(\"(%d) got: %s want: %s\", i, kind, tt.kind)\n\t\t}\n\t}\n}\n\nfunc TestDataTypeLength(t *testing.T) {\n\ttts := []struct {\n\t\ttyp    oid.Oid\n\t\tlen    int\n\t\tmod    int\n\t\tlength int64\n\t\tok     bool\n\t}{\n\t\t{oid.T_int4, 0, -1, 0, false},\n\t\t{oid.T_varchar, 65535, 9, 5, true},\n\t\t{oid.T_text, 65535, -1, math.MaxInt64, true},\n\t\t{oid.T_bytea, 65535, -1, math.MaxInt64, true},\n\t}\n\n\tfor i, tt := range tts {\n\t\tdt := fieldDesc{OID: tt.typ, Len: tt.len, Mod: tt.mod}\n\t\tif l, k := dt.Length(); k != tt.ok || l != tt.length {\n\t\t\tt.Errorf(\"(%d) got: %d, %t want: %d, %t\", i, l, k, tt.length, tt.ok)\n\t\t}\n\t}\n}\n\nfunc TestDataTypePrecisionScale(t *testing.T) {\n\ttts := []struct {\n\t\ttyp              oid.Oid\n\t\tmod              int\n\t\tprecision, scale int64\n\t\tok               bool\n\t}{\n\t\t{oid.T_int4, -1, 0, 0, false},\n\t\t{oid.T_numeric, 589830, 9, 2, true},\n\t\t{oid.T_text, -1, 0, 0, false},\n\t}\n\n\tfor i, tt := range tts {\n\t\tdt := fieldDesc{OID: tt.typ, Mod: tt.mod}\n\t\tp, s, k := dt.PrecisionScale()\n\t\tif k != tt.ok {\n\t\t\tt.Errorf(\"(%d) got: %t want: %t\", i, k, tt.ok)\n\t\t}\n\t\tif p != tt.precision {\n\t\t\tt.Errorf(\"(%d) wrong precision got: %d want: %d\", i, p, tt.precision)\n\t\t}\n\t\tif s != tt.scale {\n\t\t\tt.Errorf(\"(%d) wrong scale got: %d want: %d\", i, s, tt.scale)\n\t\t}\n\t}\n}\n\nfunc TestRowsColumnTypes(t *testing.T) {\n\tcolumnTypesTests := []struct {\n\t\tName     string\n\t\tTypeName string\n\t\tLength   struct {\n\t\t\tLen int64\n\t\t\tOK  bool\n\t\t}\n\t\tDecimalSize struct {\n\t\t\tPrecision int64\n\t\t\tScale     int64\n\t\t\tOK        bool\n\t\t}\n\t\tScanType reflect.Type\n\t}{\n\t\t{\n\t\t\tName:     \"a\",\n\t\t\tTypeName: \"INT4\",\n\t\t\tLength: struct {\n\t\t\t\tLen int64\n\t\t\t\tOK  bool\n\t\t\t}{\n\t\t\t\tLen: 0,\n\t\t\t\tOK:  false,\n\t\t\t},\n\t\t\tDecimalSize: struct {\n\t\t\t\tPrecision int64\n\t\t\t\tScale     int64\n\t\t\t\tOK        bool\n\t\t\t}{\n\t\t\t\tPrecision: 0,\n\t\t\t\tScale:     0,\n\t\t\t\tOK:        false,\n\t\t\t},\n\t\t\tScanType: reflect.TypeOf(int32(0)),\n\t\t}, {\n\t\t\tName:     \"bar\",\n\t\t\tTypeName: \"TEXT\",\n\t\t\tLength: struct {\n\t\t\t\tLen int64\n\t\t\t\tOK  bool\n\t\t\t}{\n\t\t\t\tLen: math.MaxInt64,\n\t\t\t\tOK:  true,\n\t\t\t},\n\t\t\tDecimalSize: struct {\n\t\t\t\tPrecision int64\n\t\t\t\tScale     int64\n\t\t\t\tOK        bool\n\t\t\t}{\n\t\t\t\tPrecision: 0,\n\t\t\t\tScale:     0,\n\t\t\t\tOK:        false,\n\t\t\t},\n\t\t\tScanType: reflect.TypeOf(\"\"),\n\t\t},\n\t}\n\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\trows, err := db.Query(\"SELECT 1 AS a, text 'bar' AS bar, 1.28::numeric(9, 2) AS dec\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcolumns, err := rows.ColumnTypes()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(columns) != 3 {\n\t\tt.Errorf(\"expected 3 columns found %d\", len(columns))\n\t}\n\n\tfor i, tt := range columnTypesTests {\n\t\tc := columns[i]\n\t\tif c.Name() != tt.Name {\n\t\t\tt.Errorf(\"(%d) got: %s, want: %s\", i, c.Name(), tt.Name)\n\t\t}\n\t\tif c.DatabaseTypeName() != tt.TypeName {\n\t\t\tt.Errorf(\"(%d) got: %s, want: %s\", i, c.DatabaseTypeName(), tt.TypeName)\n\t\t}\n\t\tl, ok := c.Length()\n\t\tif l != tt.Length.Len {\n\t\t\tt.Errorf(\"(%d) got: %d, want: %d\", i, l, tt.Length.Len)\n\t\t}\n\t\tif ok != tt.Length.OK {\n\t\t\tt.Errorf(\"(%d) got: %t, want: %t\", i, ok, tt.Length.OK)\n\t\t}\n\t\tp, s, ok := c.DecimalSize()\n\t\tif p != tt.DecimalSize.Precision {\n\t\t\tt.Errorf(\"(%d) got: %d, want: %d\", i, p, tt.DecimalSize.Precision)\n\t\t}\n\t\tif s != tt.DecimalSize.Scale {\n\t\t\tt.Errorf(\"(%d) got: %d, want: %d\", i, s, tt.DecimalSize.Scale)\n\t\t}\n\t\tif ok != tt.DecimalSize.OK {\n\t\t\tt.Errorf(\"(%d) got: %t, want: %t\", i, ok, tt.DecimalSize.OK)\n\t\t}\n\t\tif c.ScanType() != tt.ScanType {\n\t\t\tt.Errorf(\"(%d) got: %v, want: %v\", i, c.ScanType(), tt.ScanType)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "scram",
          "type": "tree",
          "content": null
        },
        {
          "name": "ssl.go",
          "type": "blob",
          "size": 6.3056640625,
          "content": "package pq\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"os/user\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// ssl generates a function to upgrade a net.Conn based on the \"sslmode\" and\n// related settings. The function is nil when no upgrade should take place.\nfunc ssl(o values) (func(net.Conn) (net.Conn, error), error) {\n\tverifyCaOnly := false\n\ttlsConf := tls.Config{}\n\tswitch mode := o[\"sslmode\"]; mode {\n\t// \"require\" is the default.\n\tcase \"\", \"require\":\n\t\t// We must skip TLS's own verification since it requires full\n\t\t// verification since Go 1.3.\n\t\ttlsConf.InsecureSkipVerify = true\n\n\t\t// From http://www.postgresql.org/docs/current/static/libpq-ssl.html:\n\t\t//\n\t\t// Note: For backwards compatibility with earlier versions of\n\t\t// PostgreSQL, if a root CA file exists, the behavior of\n\t\t// sslmode=require will be the same as that of verify-ca, meaning the\n\t\t// server certificate is validated against the CA. Relying on this\n\t\t// behavior is discouraged, and applications that need certificate\n\t\t// validation should always use verify-ca or verify-full.\n\t\tif sslrootcert, ok := o[\"sslrootcert\"]; ok {\n\t\t\tif _, err := os.Stat(sslrootcert); err == nil {\n\t\t\t\tverifyCaOnly = true\n\t\t\t} else {\n\t\t\t\tdelete(o, \"sslrootcert\")\n\t\t\t}\n\t\t}\n\tcase \"verify-ca\":\n\t\t// We must skip TLS's own verification since it requires full\n\t\t// verification since Go 1.3.\n\t\ttlsConf.InsecureSkipVerify = true\n\t\tverifyCaOnly = true\n\tcase \"verify-full\":\n\t\ttlsConf.ServerName = o[\"host\"]\n\tcase \"disable\":\n\t\treturn nil, nil\n\tdefault:\n\t\treturn nil, fmterrorf(`unsupported sslmode %q; only \"require\" (default), \"verify-full\", \"verify-ca\", and \"disable\" supported`, mode)\n\t}\n\n\t// Set Server Name Indication (SNI), if enabled by connection parameters.\n\t// By default SNI is on, any value which is not starting with \"1\" disables\n\t// SNI -- that is the same check vanilla libpq uses.\n\tif sslsni := o[\"sslsni\"]; sslsni == \"\" || strings.HasPrefix(sslsni, \"1\") {\n\t\t// RFC 6066 asks to not set SNI if the host is a literal IP address (IPv4\n\t\t// or IPv6). This check is coded already crypto.tls.hostnameInSNI, so\n\t\t// just always set ServerName here and let crypto/tls do the filtering.\n\t\ttlsConf.ServerName = o[\"host\"]\n\t}\n\n\terr := sslClientCertificates(&tlsConf, o)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = sslCertificateAuthority(&tlsConf, o)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Accept renegotiation requests initiated by the backend.\n\t//\n\t// Renegotiation was deprecated then removed from PostgreSQL 9.5, but\n\t// the default configuration of older versions has it enabled. Redshift\n\t// also initiates renegotiations and cannot be reconfigured.\n\ttlsConf.Renegotiation = tls.RenegotiateFreelyAsClient\n\n\treturn func(conn net.Conn) (net.Conn, error) {\n\t\tclient := tls.Client(conn, &tlsConf)\n\t\tif verifyCaOnly {\n\t\t\terr := sslVerifyCertificateAuthority(client, &tlsConf)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\treturn client, nil\n\t}, nil\n}\n\n// sslClientCertificates adds the certificate specified in the \"sslcert\" and\n// \"sslkey\" settings, or if they aren't set, from the .postgresql directory\n// in the user's home directory. The configured files must exist and have\n// the correct permissions.\nfunc sslClientCertificates(tlsConf *tls.Config, o values) error {\n\tsslinline := o[\"sslinline\"]\n\tif sslinline == \"true\" {\n\t\tcert, err := tls.X509KeyPair([]byte(o[\"sslcert\"]), []byte(o[\"sslkey\"]))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttlsConf.Certificates = []tls.Certificate{cert}\n\t\treturn nil\n\t}\n\n\t// user.Current() might fail when cross-compiling. We have to ignore the\n\t// error and continue without home directory defaults, since we wouldn't\n\t// know from where to load them.\n\tuser, _ := user.Current()\n\n\t// In libpq, the client certificate is only loaded if the setting is not blank.\n\t//\n\t// https://github.com/postgres/postgres/blob/REL9_6_2/src/interfaces/libpq/fe-secure-openssl.c#L1036-L1037\n\tsslcert := o[\"sslcert\"]\n\tif len(sslcert) == 0 && user != nil {\n\t\tsslcert = filepath.Join(user.HomeDir, \".postgresql\", \"postgresql.crt\")\n\t}\n\t// https://github.com/postgres/postgres/blob/REL9_6_2/src/interfaces/libpq/fe-secure-openssl.c#L1045\n\tif len(sslcert) == 0 {\n\t\treturn nil\n\t}\n\t// https://github.com/postgres/postgres/blob/REL9_6_2/src/interfaces/libpq/fe-secure-openssl.c#L1050:L1054\n\tif _, err := os.Stat(sslcert); os.IsNotExist(err) {\n\t\treturn nil\n\t} else if err != nil {\n\t\treturn err\n\t}\n\n\t// In libpq, the ssl key is only loaded if the setting is not blank.\n\t//\n\t// https://github.com/postgres/postgres/blob/REL9_6_2/src/interfaces/libpq/fe-secure-openssl.c#L1123-L1222\n\tsslkey := o[\"sslkey\"]\n\tif len(sslkey) == 0 && user != nil {\n\t\tsslkey = filepath.Join(user.HomeDir, \".postgresql\", \"postgresql.key\")\n\t}\n\n\tif len(sslkey) > 0 {\n\t\tif err := sslKeyPermissions(sslkey); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcert, err := tls.LoadX509KeyPair(sslcert, sslkey)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttlsConf.Certificates = []tls.Certificate{cert}\n\treturn nil\n}\n\n// sslCertificateAuthority adds the RootCA specified in the \"sslrootcert\" setting.\nfunc sslCertificateAuthority(tlsConf *tls.Config, o values) error {\n\t// In libpq, the root certificate is only loaded if the setting is not blank.\n\t//\n\t// https://github.com/postgres/postgres/blob/REL9_6_2/src/interfaces/libpq/fe-secure-openssl.c#L950-L951\n\tif sslrootcert := o[\"sslrootcert\"]; len(sslrootcert) > 0 {\n\t\ttlsConf.RootCAs = x509.NewCertPool()\n\n\t\tsslinline := o[\"sslinline\"]\n\n\t\tvar cert []byte\n\t\tif sslinline == \"true\" {\n\t\t\tcert = []byte(sslrootcert)\n\t\t} else {\n\t\t\tvar err error\n\t\t\tcert, err = ioutil.ReadFile(sslrootcert)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif !tlsConf.RootCAs.AppendCertsFromPEM(cert) {\n\t\t\treturn fmterrorf(\"couldn't parse pem in sslrootcert\")\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// sslVerifyCertificateAuthority carries out a TLS handshake to the server and\n// verifies the presented certificate against the CA, i.e. the one specified in\n// sslrootcert or the system CA if sslrootcert was not specified.\nfunc sslVerifyCertificateAuthority(client *tls.Conn, tlsConf *tls.Config) error {\n\terr := client.Handshake()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcerts := client.ConnectionState().PeerCertificates\n\topts := x509.VerifyOptions{\n\t\tDNSName:       client.ConnectionState().ServerName,\n\t\tIntermediates: x509.NewCertPool(),\n\t\tRoots:         tlsConf.RootCAs,\n\t}\n\tfor i, cert := range certs {\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\topts.Intermediates.AddCert(cert)\n\t}\n\t_, err = certs[0].Verify(opts)\n\treturn err\n}\n"
        },
        {
          "name": "ssl_permissions.go",
          "type": "blob",
          "size": 2.89453125,
          "content": "//go:build !windows\n// +build !windows\n\npackage pq\n\nimport (\n\t\"errors\"\n\t\"os\"\n\t\"syscall\"\n)\n\nconst (\n\trootUserID = uint32(0)\n\n\t// The maximum permissions that a private key file owned by a regular user\n\t// is allowed to have. This translates to u=rw.\n\tmaxUserOwnedKeyPermissions os.FileMode = 0600\n\n\t// The maximum permissions that a private key file owned by root is allowed\n\t// to have. This translates to u=rw,g=r.\n\tmaxRootOwnedKeyPermissions os.FileMode = 0640\n)\n\nvar (\n\terrSSLKeyHasUnacceptableUserPermissions = errors.New(\"permissions for files not owned by root should be u=rw (0600) or less\")\n\terrSSLKeyHasUnacceptableRootPermissions = errors.New(\"permissions for root owned files should be u=rw,g=r (0640) or less\")\n)\n\n// sslKeyPermissions checks the permissions on user-supplied ssl key files.\n// The key file should have very little access.\n//\n// libpq does not check key file permissions on Windows.\nfunc sslKeyPermissions(sslkey string) error {\n\tinfo, err := os.Stat(sslkey)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = hasCorrectPermissions(info)\n\n\t// return ErrSSLKeyHasWorldPermissions for backwards compatability with\n\t// existing code.\n\tif err == errSSLKeyHasUnacceptableUserPermissions || err == errSSLKeyHasUnacceptableRootPermissions {\n\t\terr = ErrSSLKeyHasWorldPermissions\n\t}\n\treturn err\n}\n\n// hasCorrectPermissions checks the file info (and the unix-specific stat_t\n// output) to verify that the permissions on the file are correct.\n//\n// If the file is owned by the same user the process is running as,\n// the file should only have 0600 (u=rw). If the file is owned by root,\n// and the group matches the group that the process is running in, the\n// permissions cannot be more than 0640 (u=rw,g=r). The file should\n// never have world permissions.\n//\n// Returns an error when the permission check fails.\nfunc hasCorrectPermissions(info os.FileInfo) error {\n\t// if file's permission matches 0600, allow access.\n\tuserPermissionMask := (os.FileMode(0777) ^ maxUserOwnedKeyPermissions)\n\n\t// regardless of if we're running as root or not, 0600 is acceptable,\n\t// so we return if we match the regular user permission mask.\n\tif info.Mode().Perm()&userPermissionMask == 0 {\n\t\treturn nil\n\t}\n\n\t// We need to pull the Unix file information to get the file's owner.\n\t// If we can't access it, there's some sort of operating system level error\n\t// and we should fail rather than attempting to use faulty information.\n\tsysInfo := info.Sys()\n\tif sysInfo == nil {\n\t\treturn ErrSSLKeyUnknownOwnership\n\t}\n\n\tunixStat, ok := sysInfo.(*syscall.Stat_t)\n\tif !ok {\n\t\treturn ErrSSLKeyUnknownOwnership\n\t}\n\n\t// if the file is owned by root, we allow 0640 (u=rw,g=r) to match what\n\t// Postgres does.\n\tif unixStat.Uid == rootUserID {\n\t\trootPermissionMask := (os.FileMode(0777) ^ maxRootOwnedKeyPermissions)\n\t\tif info.Mode().Perm()&rootPermissionMask != 0 {\n\t\t\treturn errSSLKeyHasUnacceptableRootPermissions\n\t\t}\n\t\treturn nil\n\t}\n\n\treturn errSSLKeyHasUnacceptableUserPermissions\n}\n"
        },
        {
          "name": "ssl_permissions_test.go",
          "type": "blob",
          "size": 1.91015625,
          "content": "//go:build !windows\n// +build !windows\n\npackage pq\n\nimport (\n\t\"os\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype stat_t_wrapper struct {\n\tstat syscall.Stat_t\n}\n\nfunc (stat_t *stat_t_wrapper) Name() string {\n\treturn \"pem.key\"\n}\n\nfunc (stat_t *stat_t_wrapper) Size() int64 {\n\treturn int64(100)\n}\n\nfunc (stat_t *stat_t_wrapper) Mode() os.FileMode {\n\treturn os.FileMode(stat_t.stat.Mode)\n}\n\nfunc (stat_t *stat_t_wrapper) ModTime() time.Time {\n\treturn time.Now()\n}\n\nfunc (stat_t *stat_t_wrapper) IsDir() bool {\n\treturn true\n}\n\nfunc (stat_t *stat_t_wrapper) Sys() interface{} {\n\treturn &stat_t.stat\n}\n\nfunc TestHasCorrectRootGroupPermissions(t *testing.T) {\n\tcurrentUID := uint32(os.Getuid())\n\tcurrentGID := uint32(os.Getgid())\n\n\ttestData := []struct {\n\t\texpectedError error\n\t\tstat          syscall.Stat_t\n\t}{\n\t\t{\n\t\t\texpectedError: nil,\n\t\t\tstat: syscall.Stat_t{\n\t\t\t\tMode: 0600,\n\t\t\t\tUid:  currentUID,\n\t\t\t\tGid:  currentGID,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\texpectedError: nil,\n\t\t\tstat: syscall.Stat_t{\n\t\t\t\tMode: 0640,\n\t\t\t\tUid:  0,\n\t\t\t\tGid:  currentGID,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\texpectedError: errSSLKeyHasUnacceptableUserPermissions,\n\t\t\tstat: syscall.Stat_t{\n\t\t\t\tMode: 0666,\n\t\t\t\tUid:  currentUID,\n\t\t\t\tGid:  currentGID,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\texpectedError: errSSLKeyHasUnacceptableRootPermissions,\n\t\t\tstat: syscall.Stat_t{\n\t\t\t\tMode: 0666,\n\t\t\t\tUid:  0,\n\t\t\t\tGid:  currentGID,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range testData {\n\t\twrapper := &stat_t_wrapper{\n\t\t\tstat: test.stat,\n\t\t}\n\n\t\tif test.expectedError != hasCorrectPermissions(wrapper) {\n\t\t\tif test.expectedError == nil {\n\t\t\t\tt.Errorf(\n\t\t\t\t\t\"file owned by %d:%d with %s should not have failed check with error \\\"%s\\\"\",\n\t\t\t\t\ttest.stat.Uid,\n\t\t\t\t\ttest.stat.Gid,\n\t\t\t\t\twrapper.Mode(),\n\t\t\t\t\thasCorrectPermissions(wrapper),\n\t\t\t\t)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tt.Errorf(\n\t\t\t\t\"file owned by %d:%d with %s, expected \\\"%s\\\", got \\\"%s\\\"\",\n\t\t\t\ttest.stat.Uid,\n\t\t\t\ttest.stat.Gid,\n\t\t\t\twrapper.Mode(),\n\t\t\t\ttest.expectedError,\n\t\t\t\thasCorrectPermissions(wrapper),\n\t\t\t)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "ssl_test.go",
          "type": "blob",
          "size": 11.95703125,
          "content": "package pq\n\n// This file contains SSL tests\n\nimport (\n\t\"bytes\"\n\t_ \"crypto/sha256\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc maybeSkipSSLTests(t *testing.T) {\n\t// Require some special variables for testing certificates\n\tif os.Getenv(\"PQSSLCERTTEST_PATH\") == \"\" {\n\t\tt.Skip(\"PQSSLCERTTEST_PATH not set, skipping SSL tests\")\n\t}\n\n\tvalue := os.Getenv(\"PQGOSSLTESTS\")\n\tif value == \"\" || value == \"0\" {\n\t\tt.Skip(\"PQGOSSLTESTS not enabled, skipping SSL tests\")\n\t} else if value != \"1\" {\n\t\tt.Fatalf(\"unexpected value %q for PQGOSSLTESTS\", value)\n\t}\n}\n\nfunc openSSLConn(t *testing.T, conninfo string) (*sql.DB, error) {\n\tdb, err := openTestConnConninfo(conninfo)\n\tif err != nil {\n\t\t// should never fail\n\t\tt.Fatal(err)\n\t}\n\t// Do something with the connection to see whether it's working or not.\n\ttx, err := db.Begin()\n\tif err == nil {\n\t\treturn db, tx.Rollback()\n\t}\n\t_ = db.Close()\n\treturn nil, err\n}\n\nfunc checkSSLSetup(t *testing.T, conninfo string) {\n\t_, err := openSSLConn(t, conninfo)\n\tif pge, ok := err.(*Error); ok {\n\t\tif pge.Code.Name() != \"invalid_authorization_specification\" {\n\t\t\tt.Fatalf(\"unexpected error code '%s'\", pge.Code.Name())\n\t\t}\n\t} else {\n\t\tt.Fatalf(\"expected %T, got %v\", (*Error)(nil), err)\n\t}\n}\n\n// Connect over SSL and run a simple query to test the basics\nfunc TestSSLConnection(t *testing.T) {\n\tmaybeSkipSSLTests(t)\n\t// Environment sanity check: should fail without SSL\n\tcheckSSLSetup(t, \"sslmode=disable user=pqgossltest\")\n\n\tdb, err := openSSLConn(t, \"sslmode=require user=pqgossltest\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trows, err := db.Query(\"SELECT 1\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trows.Close()\n}\n\n// Test sslmode=verify-full\nfunc TestSSLVerifyFull(t *testing.T) {\n\tmaybeSkipSSLTests(t)\n\t// Environment sanity check: should fail without SSL\n\tcheckSSLSetup(t, \"sslmode=disable user=pqgossltest\")\n\n\t// Not OK according to the system CA\n\t_, err := openSSLConn(t, \"host=postgres sslmode=verify-full user=pqgossltest\")\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n\t{\n\t\tvar x509err x509.UnknownAuthorityError\n\t\tif !errors.As(err, &x509err) {\n\t\t\tvar x509err x509.HostnameError\n\t\t\tif !errors.As(err, &x509err) {\n\t\t\t\tt.Fatalf(\"expected x509.UnknownAuthorityError or x509.HostnameError, got %#+v\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\trootCertPath := filepath.Join(os.Getenv(\"PQSSLCERTTEST_PATH\"), \"root.crt\")\n\trootCert := \"sslrootcert=\" + rootCertPath + \" \"\n\t// No match on Common Name\n\t_, err = openSSLConn(t, rootCert+\"host=127.0.0.1 sslmode=verify-full user=pqgossltest\")\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n\t{\n\t\tvar x509err x509.HostnameError\n\t\tif !errors.As(err, &x509err) {\n\t\t\tt.Fatalf(\"expected x509.HostnameError, got %#+v\", err)\n\t\t}\n\t}\n\t// OK\n\t_, err = openSSLConn(t, rootCert+\"host=postgres sslmode=verify-full user=pqgossltest\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Test sslmode=require sslrootcert=rootCertPath\nfunc TestSSLRequireWithRootCert(t *testing.T) {\n\tmaybeSkipSSLTests(t)\n\t// Environment sanity check: should fail without SSL\n\tcheckSSLSetup(t, \"sslmode=disable user=pqgossltest\")\n\n\tbogusRootCertPath := filepath.Join(os.Getenv(\"PQSSLCERTTEST_PATH\"), \"bogus_root.crt\")\n\tbogusRootCert := \"sslrootcert=\" + bogusRootCertPath + \" \"\n\n\t// Not OK according to the bogus CA\n\t_, err := openSSLConn(t, bogusRootCert+\"host=postgres sslmode=require user=pqgossltest\")\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n\t{\n\t\tvar x509err x509.UnknownAuthorityError\n\t\tif !errors.As(err, &x509err) {\n\t\t\tt.Fatalf(\"expected x509.UnknownAuthorityError, got %s, %#+v\", err, err)\n\t\t}\n\t}\n\n\tnonExistentCertPath := filepath.Join(os.Getenv(\"PQSSLCERTTEST_PATH\"), \"non_existent.crt\")\n\tnonExistentCert := \"sslrootcert=\" + nonExistentCertPath + \" \"\n\n\t// No match on Common Name, but that's OK because we're not validating anything.\n\t_, err = openSSLConn(t, nonExistentCert+\"host=127.0.0.1 sslmode=require user=pqgossltest\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trootCertPath := filepath.Join(os.Getenv(\"PQSSLCERTTEST_PATH\"), \"root.crt\")\n\trootCert := \"sslrootcert=\" + rootCertPath + \" \"\n\n\t// No match on Common Name, but that's OK because we're not validating the CN.\n\t_, err = openSSLConn(t, rootCert+\"host=127.0.0.1 sslmode=require user=pqgossltest\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Everything OK\n\t_, err = openSSLConn(t, rootCert+\"host=postgres sslmode=require user=pqgossltest\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Test sslmode=verify-ca\nfunc TestSSLVerifyCA(t *testing.T) {\n\tmaybeSkipSSLTests(t)\n\t// Environment sanity check: should fail without SSL\n\tcheckSSLSetup(t, \"sslmode=disable user=pqgossltest\")\n\n\t// Not OK according to the system CA\n\t{\n\t\t_, err := openSSLConn(t, \"host=postgres sslmode=verify-ca user=pqgossltest\")\n\t\tvar x509err x509.UnknownAuthorityError\n\t\tif !errors.As(err, &x509err) {\n\t\t\tt.Fatalf(\"expected %T, got %#+v\", x509.UnknownAuthorityError{}, err)\n\t\t}\n\t}\n\n\t// Still not OK according to the system CA; empty sslrootcert is treated as unspecified.\n\t{\n\t\t_, err := openSSLConn(t, \"host=postgres sslmode=verify-ca user=pqgossltest sslrootcert=''\")\n\t\tvar x509err x509.UnknownAuthorityError\n\t\tif !errors.As(err, &x509err) {\n\t\t\tt.Fatalf(\"expected %T, got %#+v\", x509.UnknownAuthorityError{}, err)\n\t\t}\n\t}\n\n\trootCertPath := filepath.Join(os.Getenv(\"PQSSLCERTTEST_PATH\"), \"root.crt\")\n\trootCert := \"sslrootcert=\" + rootCertPath + \" \"\n\t// No match on Common Name, but that's OK\n\tif _, err := openSSLConn(t, rootCert+\"host=127.0.0.1 sslmode=verify-ca user=pqgossltest\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Everything OK\n\tif _, err := openSSLConn(t, rootCert+\"host=postgres sslmode=verify-ca user=pqgossltest\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Authenticate over SSL using client certificates\nfunc TestSSLClientCertificates(t *testing.T) {\n\tmaybeSkipSSLTests(t)\n\t// Environment sanity check: should fail without SSL\n\tcheckSSLSetup(t, \"sslmode=disable user=pqgossltest\")\n\n\tconst baseinfo = \"sslmode=require user=pqgosslcert\"\n\n\t// Certificate not specified, should fail\n\t{\n\t\t_, err := openSSLConn(t, baseinfo)\n\t\tif pge, ok := err.(*Error); ok {\n\t\t\tif pge.Code.Name() != \"invalid_authorization_specification\" {\n\t\t\t\tt.Fatalf(\"unexpected error code '%s'\", pge.Code.Name())\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatalf(\"expected %T, got %v\", (*Error)(nil), err)\n\t\t}\n\t}\n\n\t// Empty certificate specified, should fail\n\t{\n\t\t_, err := openSSLConn(t, baseinfo+\" sslcert=''\")\n\t\tif pge, ok := err.(*Error); ok {\n\t\t\tif pge.Code.Name() != \"invalid_authorization_specification\" {\n\t\t\t\tt.Fatalf(\"unexpected error code '%s'\", pge.Code.Name())\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatalf(\"expected %T, got %v\", (*Error)(nil), err)\n\t\t}\n\t}\n\n\t// Non-existent certificate specified, should fail\n\t{\n\t\t_, err := openSSLConn(t, baseinfo+\" sslcert=/tmp/filedoesnotexist\")\n\t\tif pge, ok := err.(*Error); ok {\n\t\t\tif pge.Code.Name() != \"invalid_authorization_specification\" {\n\t\t\t\tt.Fatalf(\"unexpected error code '%s'\", pge.Code.Name())\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatalf(\"expected %T, got %v\", (*Error)(nil), err)\n\t\t}\n\t}\n\n\tcertpath, ok := os.LookupEnv(\"PQSSLCERTTEST_PATH\")\n\tif !ok {\n\t\tt.Fatalf(\"PQSSLCERTTEST_PATH not present in environment\")\n\t}\n\n\tsslcert := filepath.Join(certpath, \"postgresql.crt\")\n\n\t// Cert present, key not specified, should fail\n\t{\n\t\t_, err := openSSLConn(t, baseinfo+\" sslcert=\"+sslcert)\n\t\tvar pathErr *os.PathError\n\t\tif !errors.As(err, &pathErr) {\n\t\t\tt.Fatalf(\"expected %T, got %#+v\", (*os.PathError)(nil), err)\n\t\t}\n\t}\n\n\t// Cert present, empty key specified, should fail\n\t{\n\t\t_, err := openSSLConn(t, baseinfo+\" sslcert=\"+sslcert+\" sslkey=''\")\n\t\tvar pathErr *os.PathError\n\t\tif !errors.As(err, &pathErr) {\n\t\t\tt.Fatalf(\"expected %T, got %#+v\", (*os.PathError)(nil), err)\n\t\t}\n\t}\n\n\t// Cert present, non-existent key, should fail\n\t{\n\t\t_, err := openSSLConn(t, baseinfo+\" sslcert=\"+sslcert+\" sslkey=/tmp/filedoesnotexist\")\n\t\tvar pathErr *os.PathError\n\t\tif !errors.As(err, &pathErr) {\n\t\t\tt.Fatalf(\"expected %T, got %#+v\", (*os.PathError)(nil), err)\n\t\t}\n\t}\n\n\t// Key has wrong permissions (passing the cert as the key), should fail\n\tif _, err := openSSLConn(t, baseinfo+\" sslcert=\"+sslcert+\" sslkey=\"+sslcert); err != ErrSSLKeyHasWorldPermissions {\n\t\tt.Fatalf(\"expected %s, got %#+v\", ErrSSLKeyHasWorldPermissions, err)\n\t}\n\n\tsslkey := filepath.Join(certpath, \"postgresql.key\")\n\n\t// Should work\n\tif db, err := openSSLConn(t, baseinfo+\" sslcert=\"+sslcert+\" sslkey=\"+sslkey); err != nil {\n\t\tt.Fatal(err)\n\t} else {\n\t\trows, err := db.Query(\"SELECT 1\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := rows.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := db.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n\n// Check that clint sends SNI data when `sslsni` is not disabled\nfunc TestSNISupport(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname         string\n\t\tconn_param   string\n\t\thostname     string\n\t\texpected_sni string\n\t}{\n\t\t{\n\t\t\tname:         \"SNI is set by default\",\n\t\t\tconn_param:   \"\",\n\t\t\thostname:     \"localhost\",\n\t\t\texpected_sni: \"localhost\",\n\t\t},\n\t\t{\n\t\t\tname:         \"SNI is passed when asked for\",\n\t\t\tconn_param:   \"sslsni=1\",\n\t\t\thostname:     \"localhost\",\n\t\t\texpected_sni: \"localhost\",\n\t\t},\n\t\t{\n\t\t\tname:         \"SNI is not passed when disabled\",\n\t\t\tconn_param:   \"sslsni=0\",\n\t\t\thostname:     \"localhost\",\n\t\t\texpected_sni: \"\",\n\t\t},\n\t\t{\n\t\t\tname:         \"SNI is not set for IPv4\",\n\t\t\tconn_param:   \"\",\n\t\t\thostname:     \"127.0.0.1\",\n\t\t\texpected_sni: \"\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t// Start mock postgres server on OS-provided port\n\t\t\tlistener, err := net.Listen(\"tcp\", \"127.0.0.1:\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tserverErrChan := make(chan error, 1)\n\t\t\tserverSNINameChan := make(chan string, 1)\n\t\t\tgo mockPostgresSSL(listener, serverErrChan, serverSNINameChan)\n\n\t\t\tdefer listener.Close()\n\t\t\tdefer close(serverErrChan)\n\t\t\tdefer close(serverSNINameChan)\n\n\t\t\t// Try to establish a connection with the mock server. Connection will error out after TLS\n\t\t\t// clientHello, but it is enough to catch SNI data on the server side\n\t\t\tport := strings.Split(listener.Addr().String(), \":\")[1]\n\t\t\tconnStr := fmt.Sprintf(\"sslmode=require host=%s port=%s %s\", tt.hostname, port, tt.conn_param)\n\n\t\t\t// We are okay to skip this error as we are polling serverErrChan and we'll get an error\n\t\t\t// or timeout from the server side in case of problems here.\n\t\t\tdb, _ := sql.Open(\"postgres\", connStr)\n\t\t\t_, _ = db.Exec(\"SELECT 1\")\n\n\t\t\t// Check SNI data\n\t\t\tselect {\n\t\t\tcase sniHost := <-serverSNINameChan:\n\t\t\t\tif sniHost != tt.expected_sni {\n\t\t\t\t\tt.Fatalf(\"Expected SNI to be 'localhost', got '%+v' instead\", sniHost)\n\t\t\t\t}\n\t\t\tcase err = <-serverErrChan:\n\t\t\t\tt.Fatalf(\"mock server failed with error: %+v\", err)\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\tt.Fatal(\"exceeded connection timeout without erroring out\")\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Make a postgres mock server to test TLS SNI\n//\n// Accepts postgres StartupMessage and handles TLS clientHello, then closes a connection.\n// While reading clientHello catch passed SNI data and report it to nameChan.\nfunc mockPostgresSSL(listener net.Listener, errChan chan error, nameChan chan string) {\n\tvar sniHost string\n\n\tconn, err := listener.Accept()\n\tif err != nil {\n\t\terrChan <- err\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\terr = conn.SetDeadline(time.Now().Add(time.Second))\n\tif err != nil {\n\t\terrChan <- err\n\t\treturn\n\t}\n\n\t// Receive StartupMessage with SSL Request\n\tstartupMessage := make([]byte, 8)\n\tif _, err := io.ReadFull(conn, startupMessage); err != nil {\n\t\terrChan <- err\n\t\treturn\n\t}\n\t// StartupMessage: first four bytes -- total len = 8, last four bytes SslRequestNumber\n\tif !bytes.Equal(startupMessage, []byte{0, 0, 0, 0x8, 0x4, 0xd2, 0x16, 0x2f}) {\n\t\terrChan <- fmt.Errorf(\"unexpected startup message: %#v\", startupMessage)\n\t\treturn\n\t}\n\n\t// Respond with SSLOk\n\t_, err = conn.Write([]byte(\"S\"))\n\tif err != nil {\n\t\terrChan <- err\n\t\treturn\n\t}\n\n\t// Set up TLS context to catch clientHello. It will always error out during handshake\n\t// as no certificate is set.\n\tsrv := tls.Server(conn, &tls.Config{\n\t\tGetConfigForClient: func(argHello *tls.ClientHelloInfo) (*tls.Config, error) {\n\t\t\tsniHost = argHello.ServerName\n\t\t\treturn nil, nil\n\t\t},\n\t})\n\tdefer srv.Close()\n\n\t// Do the TLS handshake ignoring errors\n\t_ = srv.Handshake()\n\n\tnameChan <- sniHost\n}\n"
        },
        {
          "name": "ssl_windows.go",
          "type": "blob",
          "size": 0.279296875,
          "content": "//go:build windows\n// +build windows\n\npackage pq\n\n// sslKeyPermissions checks the permissions on user-supplied ssl key files.\n// The key file should have very little access.\n//\n// libpq does not check key file permissions on Windows.\nfunc sslKeyPermissions(string) error { return nil }\n"
        },
        {
          "name": "url.go",
          "type": "blob",
          "size": 1.6162109375,
          "content": "package pq\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\tnurl \"net/url\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// ParseURL no longer needs to be used by clients of this library since supplying a URL as a\n// connection string to sql.Open() is now supported:\n//\n//\tsql.Open(\"postgres\", \"postgres://bob:secret@1.2.3.4:5432/mydb?sslmode=verify-full\")\n//\n// It remains exported here for backwards-compatibility.\n//\n// ParseURL converts a url to a connection string for driver.Open.\n// Example:\n//\n//\t\"postgres://bob:secret@1.2.3.4:5432/mydb?sslmode=verify-full\"\n//\n// converts to:\n//\n//\t\"user=bob password=secret host=1.2.3.4 port=5432 dbname=mydb sslmode=verify-full\"\n//\n// A minimal example:\n//\n//\t\"postgres://\"\n//\n// This will be blank, causing driver.Open to use all of the defaults\nfunc ParseURL(url string) (string, error) {\n\tu, err := nurl.Parse(url)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif u.Scheme != \"postgres\" && u.Scheme != \"postgresql\" {\n\t\treturn \"\", fmt.Errorf(\"invalid connection protocol: %s\", u.Scheme)\n\t}\n\n\tvar kvs []string\n\tescaper := strings.NewReplacer(`'`, `\\'`, `\\`, `\\\\`)\n\taccrue := func(k, v string) {\n\t\tif v != \"\" {\n\t\t\tkvs = append(kvs, k+\"='\"+escaper.Replace(v)+\"'\")\n\t\t}\n\t}\n\n\tif u.User != nil {\n\t\tv := u.User.Username()\n\t\taccrue(\"user\", v)\n\n\t\tv, _ = u.User.Password()\n\t\taccrue(\"password\", v)\n\t}\n\n\tif host, port, err := net.SplitHostPort(u.Host); err != nil {\n\t\taccrue(\"host\", u.Host)\n\t} else {\n\t\taccrue(\"host\", host)\n\t\taccrue(\"port\", port)\n\t}\n\n\tif u.Path != \"\" {\n\t\taccrue(\"dbname\", u.Path[1:])\n\t}\n\n\tq := u.Query()\n\tfor k := range q {\n\t\taccrue(k, q.Get(k))\n\t}\n\n\tsort.Strings(kvs) // Makes testing easier (not a performance concern)\n\treturn strings.Join(kvs, \" \"), nil\n}\n"
        },
        {
          "name": "url_test.go",
          "type": "blob",
          "size": 1.4423828125,
          "content": "package pq\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSimpleParseURL(t *testing.T) {\n\texpected := \"host='hostname.remote'\"\n\tstr, err := ParseURL(\"postgres://hostname.remote\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif str != expected {\n\t\tt.Fatalf(\"unexpected result from ParseURL:\\n+ %v\\n- %v\", str, expected)\n\t}\n}\n\nfunc TestIPv6LoopbackParseURL(t *testing.T) {\n\texpected := \"host='::1' port='1234'\"\n\tstr, err := ParseURL(\"postgres://[::1]:1234\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif str != expected {\n\t\tt.Fatalf(\"unexpected result from ParseURL:\\n+ %v\\n- %v\", str, expected)\n\t}\n}\n\nfunc TestFullParseURL(t *testing.T) {\n\texpected := `dbname='database' host='hostname.remote' password='top secret' port='1234' user='username'`\n\tstr, err := ParseURL(\"postgres://username:top%20secret@hostname.remote:1234/database\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif str != expected {\n\t\tt.Fatalf(\"unexpected result from ParseURL:\\n+ %s\\n- %s\", str, expected)\n\t}\n}\n\nfunc TestInvalidProtocolParseURL(t *testing.T) {\n\t_, err := ParseURL(\"http://hostname.remote\")\n\tswitch err {\n\tcase nil:\n\t\tt.Fatal(\"Expected an error from parsing invalid protocol\")\n\tdefault:\n\t\tmsg := \"invalid connection protocol: http\"\n\t\tif err.Error() != msg {\n\t\t\tt.Fatalf(\"Unexpected error message:\\n+ %s\\n- %s\",\n\t\t\t\terr.Error(), msg)\n\t\t}\n\t}\n}\n\nfunc TestMinimalURL(t *testing.T) {\n\tcs, err := ParseURL(\"postgres://\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif cs != \"\" {\n\t\tt.Fatalf(\"expected blank connection string, got: %q\", cs)\n\t}\n}\n"
        },
        {
          "name": "user_other.go",
          "type": "blob",
          "size": 0.228515625,
          "content": "// Package pq is a pure Go Postgres driver for the database/sql package.\n\n//go:build js || android || hurd || zos\n// +build js android hurd zos\n\npackage pq\n\nfunc userCurrent() (string, error) {\n\treturn \"\", ErrCouldNotDetectUsername\n}\n"
        },
        {
          "name": "user_posix.go",
          "type": "blob",
          "size": 0.5654296875,
          "content": "// Package pq is a pure Go Postgres driver for the database/sql package.\n\n//go:build aix || darwin || dragonfly || freebsd || (linux && !android) || nacl || netbsd || openbsd || plan9 || solaris || rumprun || illumos\n// +build aix darwin dragonfly freebsd linux,!android nacl netbsd openbsd plan9 solaris rumprun illumos\n\npackage pq\n\nimport (\n\t\"os\"\n\t\"os/user\"\n)\n\nfunc userCurrent() (string, error) {\n\tu, err := user.Current()\n\tif err == nil {\n\t\treturn u.Username, nil\n\t}\n\n\tname := os.Getenv(\"USER\")\n\tif name != \"\" {\n\t\treturn name, nil\n\t}\n\n\treturn \"\", ErrCouldNotDetectUsername\n}\n"
        },
        {
          "name": "user_windows.go",
          "type": "blob",
          "size": 0.8505859375,
          "content": "// Package pq is a pure Go Postgres driver for the database/sql package.\npackage pq\n\nimport (\n\t\"path/filepath\"\n\t\"syscall\"\n)\n\n// Perform Windows user name lookup identically to libpq.\n//\n// The PostgreSQL code makes use of the legacy Win32 function\n// GetUserName, and that function has not been imported into stock Go.\n// GetUserNameEx is available though, the difference being that a\n// wider range of names are available.  To get the output to be the\n// same as GetUserName, only the base (or last) component of the\n// result is returned.\nfunc userCurrent() (string, error) {\n\tpw_name := make([]uint16, 128)\n\tpwname_size := uint32(len(pw_name)) - 1\n\terr := syscall.GetUserNameEx(syscall.NameSamCompatible, &pw_name[0], &pwname_size)\n\tif err != nil {\n\t\treturn \"\", ErrCouldNotDetectUsername\n\t}\n\ts := syscall.UTF16ToString(pw_name)\n\tu := filepath.Base(s)\n\treturn u, nil\n}\n"
        },
        {
          "name": "uuid.go",
          "type": "blob",
          "size": 0.5419921875,
          "content": "package pq\n\nimport (\n\t\"encoding/hex\"\n\t\"fmt\"\n)\n\n// decodeUUIDBinary interprets the binary format of a uuid, returning it in text format.\nfunc decodeUUIDBinary(src []byte) ([]byte, error) {\n\tif len(src) != 16 {\n\t\treturn nil, fmt.Errorf(\"pq: unable to decode uuid; bad length: %d\", len(src))\n\t}\n\n\tdst := make([]byte, 36)\n\tdst[8], dst[13], dst[18], dst[23] = '-', '-', '-', '-'\n\thex.Encode(dst[0:], src[0:4])\n\thex.Encode(dst[9:], src[4:6])\n\thex.Encode(dst[14:], src[6:8])\n\thex.Encode(dst[19:], src[8:10])\n\thex.Encode(dst[24:], src[10:16])\n\n\treturn dst, nil\n}\n"
        },
        {
          "name": "uuid_test.go",
          "type": "blob",
          "size": 1.060546875,
          "content": "package pq\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestDecodeUUIDBinaryError(t *testing.T) {\n\tt.Parallel()\n\t_, err := decodeUUIDBinary([]byte{0x12, 0x34})\n\n\tif err == nil {\n\t\tt.Fatal(\"Expected error, got none\")\n\t}\n\tif !strings.HasPrefix(err.Error(), \"pq:\") {\n\t\tt.Errorf(\"Expected error to start with %q, got %q\", \"pq:\", err.Error())\n\t}\n\tif !strings.Contains(err.Error(), \"bad length: 2\") {\n\t\tt.Errorf(\"Expected error to contain length, got %q\", err.Error())\n\t}\n}\n\nfunc BenchmarkDecodeUUIDBinary(b *testing.B) {\n\tx := []byte{0x03, 0xa3, 0x52, 0x2f, 0x89, 0x28, 0x49, 0x87, 0x84, 0xd6, 0x93, 0x7b, 0x36, 0xec, 0x27, 0x6f}\n\n\tfor i := 0; i < b.N; i++ {\n\t\tdecodeUUIDBinary(x)\n\t}\n}\n\nfunc TestDecodeUUIDBackend(t *testing.T) {\n\tdb := openTestConn(t)\n\tdefer db.Close()\n\n\tvar s = \"a0ecc91d-a13f-4fe4-9fce-7e09777cc70a\"\n\tvar scanned interface{}\n\n\terr := db.QueryRow(`SELECT $1::uuid`, s).Scan(&scanned)\n\tif err != nil {\n\t\tt.Fatalf(\"Expected no error, got %v\", err)\n\t}\n\tif !reflect.DeepEqual(scanned, []byte(s)) {\n\t\tt.Errorf(\"Expected []byte(%q), got %T(%q)\", s, scanned, scanned)\n\t}\n}\n"
        }
      ]
    }
  ]
}