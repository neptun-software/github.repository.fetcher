{
  "metadata": {
    "timestamp": 1736567703337,
    "page": 287,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "go-telegram-bot-api/telegram-bot-api",
      "stars": 5921,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0302734375,
          "content": ".idea/\ncoverage.out\ntmp/\nbook/\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0478515625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Syfaro\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.34765625,
          "content": "# Golang bindings for the Telegram Bot API\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/go-telegram-bot-api/telegram-bot-api/v5.svg)](https://pkg.go.dev/github.com/go-telegram-bot-api/telegram-bot-api/v5)\n[![Test](https://github.com/go-telegram-bot-api/telegram-bot-api/actions/workflows/test.yml/badge.svg)](https://github.com/go-telegram-bot-api/telegram-bot-api/actions/workflows/test.yml)\n\nAll methods are fairly self-explanatory, and reading the [godoc](https://pkg.go.dev/github.com/go-telegram-bot-api/telegram-bot-api/v5) page should\nexplain everything. If something isn't clear, open an issue or submit\na pull request.\n\nThere are more tutorials and high-level information on the website, [go-telegram-bot-api.dev](https://go-telegram-bot-api.dev).\n\nThe scope of this project is just to provide a wrapper around the API\nwithout any additional features. There are other projects for creating\nsomething with plugins and command handlers without having to design\nall that yourself.\n\nJoin [the development group](https://telegram.me/go_telegram_bot_api) if\nyou want to ask questions or discuss development.\n\n## Example\n\nFirst, ensure the library is installed and up to date by running\n`go get -u github.com/go-telegram-bot-api/telegram-bot-api/v5`.\n\nThis is a very simple bot that just displays any gotten updates,\nthen replies it to that chat.\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\n\ttgbotapi \"github.com/go-telegram-bot-api/telegram-bot-api/v5\"\n)\n\nfunc main() {\n\tbot, err := tgbotapi.NewBotAPI(\"MyAwesomeBotToken\")\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tbot.Debug = true\n\n\tlog.Printf(\"Authorized on account %s\", bot.Self.UserName)\n\n\tu := tgbotapi.NewUpdate(0)\n\tu.Timeout = 60\n\n\tupdates := bot.GetUpdatesChan(u)\n\n\tfor update := range updates {\n\t\tif update.Message != nil { // If we got a message\n\t\t\tlog.Printf(\"[%s] %s\", update.Message.From.UserName, update.Message.Text)\n\n\t\t\tmsg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text)\n\t\t\tmsg.ReplyToMessageID = update.Message.MessageID\n\n\t\t\tbot.Send(msg)\n\t\t}\n\t}\n}\n```\n\nIf you need to use webhooks (if you wish to run on Google App Engine),\nyou may use a slightly different method.\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/go-telegram-bot-api/telegram-bot-api/v5\"\n)\n\nfunc main() {\n\tbot, err := tgbotapi.NewBotAPI(\"MyAwesomeBotToken\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tbot.Debug = true\n\n\tlog.Printf(\"Authorized on account %s\", bot.Self.UserName)\n\n\twh, _ := tgbotapi.NewWebhookWithCert(\"https://www.example.com:8443/\"+bot.Token, \"cert.pem\")\n\n\t_, err = bot.Request(wh)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tinfo, err := bot.GetWebhookInfo()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif info.LastErrorDate != 0 {\n\t\tlog.Printf(\"Telegram callback failed: %s\", info.LastErrorMessage)\n\t}\n\n\tupdates := bot.ListenForWebhook(\"/\" + bot.Token)\n\tgo http.ListenAndServeTLS(\"0.0.0.0:8443\", \"cert.pem\", \"key.pem\", nil)\n\n\tfor update := range updates {\n\t\tlog.Printf(\"%+v\\n\", update)\n\t}\n}\n```\n\nIf you need, you may generate a self-signed certificate, as this requires\nHTTPS / TLS. The above example tells Telegram that this is your\ncertificate and that it should be trusted, even though it is not\nproperly signed.\n\n    openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 3560 -subj \"//O=Org\\CN=Test\" -nodes\n\nNow that [Let's Encrypt](https://letsencrypt.org) is available,\nyou may wish to generate your free TLS certificate there.\n"
        },
        {
          "name": "book.toml",
          "type": "blob",
          "size": 0.197265625,
          "content": "[book]\nauthors = [\"Syfaro\"]\nlanguage = \"en\"\nmultilingual = false\nsrc = \"docs\"\ntitle = \"Go Telegram Bot API\"\n\n[output.html]\ngit-repository-url = \"https://github.com/go-telegram-bot-api/telegram-bot-api\"\n"
        },
        {
          "name": "bot.go",
          "type": "blob",
          "size": 18.359375,
          "content": "// Package tgbotapi has functions and types used for interacting with\n// the Telegram Bot API.\npackage tgbotapi\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n)\n\n// HTTPClient is the type needed for the bot to perform HTTP requests.\ntype HTTPClient interface {\n\tDo(req *http.Request) (*http.Response, error)\n}\n\n// BotAPI allows you to interact with the Telegram Bot API.\ntype BotAPI struct {\n\tToken  string `json:\"token\"`\n\tDebug  bool   `json:\"debug\"`\n\tBuffer int    `json:\"buffer\"`\n\n\tSelf            User       `json:\"-\"`\n\tClient          HTTPClient `json:\"-\"`\n\tshutdownChannel chan interface{}\n\n\tapiEndpoint string\n}\n\n// NewBotAPI creates a new BotAPI instance.\n//\n// It requires a token, provided by @BotFather on Telegram.\nfunc NewBotAPI(token string) (*BotAPI, error) {\n\treturn NewBotAPIWithClient(token, APIEndpoint, &http.Client{})\n}\n\n// NewBotAPIWithAPIEndpoint creates a new BotAPI instance\n// and allows you to pass API endpoint.\n//\n// It requires a token, provided by @BotFather on Telegram and API endpoint.\nfunc NewBotAPIWithAPIEndpoint(token, apiEndpoint string) (*BotAPI, error) {\n\treturn NewBotAPIWithClient(token, apiEndpoint, &http.Client{})\n}\n\n// NewBotAPIWithClient creates a new BotAPI instance\n// and allows you to pass a http.Client.\n//\n// It requires a token, provided by @BotFather on Telegram and API endpoint.\nfunc NewBotAPIWithClient(token, apiEndpoint string, client HTTPClient) (*BotAPI, error) {\n\tbot := &BotAPI{\n\t\tToken:           token,\n\t\tClient:          client,\n\t\tBuffer:          100,\n\t\tshutdownChannel: make(chan interface{}),\n\n\t\tapiEndpoint: apiEndpoint,\n\t}\n\n\tself, err := bot.GetMe()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbot.Self = self\n\n\treturn bot, nil\n}\n\n// SetAPIEndpoint changes the Telegram Bot API endpoint used by the instance.\nfunc (bot *BotAPI) SetAPIEndpoint(apiEndpoint string) {\n\tbot.apiEndpoint = apiEndpoint\n}\n\nfunc buildParams(in Params) url.Values {\n\tif in == nil {\n\t\treturn url.Values{}\n\t}\n\n\tout := url.Values{}\n\n\tfor key, value := range in {\n\t\tout.Set(key, value)\n\t}\n\n\treturn out\n}\n\n// MakeRequest makes a request to a specific endpoint with our token.\nfunc (bot *BotAPI) MakeRequest(endpoint string, params Params) (*APIResponse, error) {\n\tif bot.Debug {\n\t\tlog.Printf(\"Endpoint: %s, params: %v\\n\", endpoint, params)\n\t}\n\n\tmethod := fmt.Sprintf(bot.apiEndpoint, bot.Token, endpoint)\n\n\tvalues := buildParams(params)\n\n\treq, err := http.NewRequest(\"POST\", method, strings.NewReader(values.Encode()))\n\tif err != nil {\n\t\treturn &APIResponse{}, err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\tresp, err := bot.Client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar apiResp APIResponse\n\tbytes, err := bot.decodeAPIResponse(resp.Body, &apiResp)\n\tif err != nil {\n\t\treturn &apiResp, err\n\t}\n\n\tif bot.Debug {\n\t\tlog.Printf(\"Endpoint: %s, response: %s\\n\", endpoint, string(bytes))\n\t}\n\n\tif !apiResp.Ok {\n\t\tvar parameters ResponseParameters\n\n\t\tif apiResp.Parameters != nil {\n\t\t\tparameters = *apiResp.Parameters\n\t\t}\n\n\t\treturn &apiResp, &Error{\n\t\t\tCode:               apiResp.ErrorCode,\n\t\t\tMessage:            apiResp.Description,\n\t\t\tResponseParameters: parameters,\n\t\t}\n\t}\n\n\treturn &apiResp, nil\n}\n\n// decodeAPIResponse decode response and return slice of bytes if debug enabled.\n// If debug disabled, just decode http.Response.Body stream to APIResponse struct\n// for efficient memory usage\nfunc (bot *BotAPI) decodeAPIResponse(responseBody io.Reader, resp *APIResponse) ([]byte, error) {\n\tif !bot.Debug {\n\t\tdec := json.NewDecoder(responseBody)\n\t\terr := dec.Decode(resp)\n\t\treturn nil, err\n\t}\n\n\t// if debug, read response body\n\tdata, err := io.ReadAll(responseBody)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = json.Unmarshal(data, resp)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn data, nil\n}\n\n// UploadFiles makes a request to the API with files.\nfunc (bot *BotAPI) UploadFiles(endpoint string, params Params, files []RequestFile) (*APIResponse, error) {\n\tr, w := io.Pipe()\n\tm := multipart.NewWriter(w)\n\n\t// This code modified from the very helpful @HirbodBehnam\n\t// https://github.com/go-telegram-bot-api/telegram-bot-api/issues/354#issuecomment-663856473\n\tgo func() {\n\t\tdefer w.Close()\n\t\tdefer m.Close()\n\n\t\tfor field, value := range params {\n\t\t\tif err := m.WriteField(field, value); err != nil {\n\t\t\t\tw.CloseWithError(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tfor _, file := range files {\n\t\t\tif file.Data.NeedsUpload() {\n\t\t\t\tname, reader, err := file.Data.UploadData()\n\t\t\t\tif err != nil {\n\t\t\t\t\tw.CloseWithError(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tpart, err := m.CreateFormFile(file.Name, name)\n\t\t\t\tif err != nil {\n\t\t\t\t\tw.CloseWithError(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif _, err := io.Copy(part, reader); err != nil {\n\t\t\t\t\tw.CloseWithError(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif closer, ok := reader.(io.ReadCloser); ok {\n\t\t\t\t\tif err = closer.Close(); err != nil {\n\t\t\t\t\t\tw.CloseWithError(err)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvalue := file.Data.SendData()\n\n\t\t\t\tif err := m.WriteField(file.Name, value); err != nil {\n\t\t\t\t\tw.CloseWithError(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tif bot.Debug {\n\t\tlog.Printf(\"Endpoint: %s, params: %v, with %d files\\n\", endpoint, params, len(files))\n\t}\n\n\tmethod := fmt.Sprintf(bot.apiEndpoint, bot.Token, endpoint)\n\n\treq, err := http.NewRequest(\"POST\", method, r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Content-Type\", m.FormDataContentType())\n\n\tresp, err := bot.Client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tvar apiResp APIResponse\n\tbytes, err := bot.decodeAPIResponse(resp.Body, &apiResp)\n\tif err != nil {\n\t\treturn &apiResp, err\n\t}\n\n\tif bot.Debug {\n\t\tlog.Printf(\"Endpoint: %s, response: %s\\n\", endpoint, string(bytes))\n\t}\n\n\tif !apiResp.Ok {\n\t\tvar parameters ResponseParameters\n\n\t\tif apiResp.Parameters != nil {\n\t\t\tparameters = *apiResp.Parameters\n\t\t}\n\n\t\treturn &apiResp, &Error{\n\t\t\tMessage:            apiResp.Description,\n\t\t\tResponseParameters: parameters,\n\t\t}\n\t}\n\n\treturn &apiResp, nil\n}\n\n// GetFileDirectURL returns direct URL to file\n//\n// It requires the FileID.\nfunc (bot *BotAPI) GetFileDirectURL(fileID string) (string, error) {\n\tfile, err := bot.GetFile(FileConfig{fileID})\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn file.Link(bot.Token), nil\n}\n\n// GetMe fetches the currently authenticated bot.\n//\n// This method is called upon creation to validate the token,\n// and so you may get this data from BotAPI.Self without the need for\n// another request.\nfunc (bot *BotAPI) GetMe() (User, error) {\n\tresp, err := bot.MakeRequest(\"getMe\", nil)\n\tif err != nil {\n\t\treturn User{}, err\n\t}\n\n\tvar user User\n\terr = json.Unmarshal(resp.Result, &user)\n\n\treturn user, err\n}\n\n// IsMessageToMe returns true if message directed to this bot.\n//\n// It requires the Message.\nfunc (bot *BotAPI) IsMessageToMe(message Message) bool {\n\treturn strings.Contains(message.Text, \"@\"+bot.Self.UserName)\n}\n\nfunc hasFilesNeedingUpload(files []RequestFile) bool {\n\tfor _, file := range files {\n\t\tif file.Data.NeedsUpload() {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// Request sends a Chattable to Telegram, and returns the APIResponse.\nfunc (bot *BotAPI) Request(c Chattable) (*APIResponse, error) {\n\tparams, err := c.params()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif t, ok := c.(Fileable); ok {\n\t\tfiles := t.files()\n\n\t\t// If we have files that need to be uploaded, we should delegate the\n\t\t// request to UploadFile.\n\t\tif hasFilesNeedingUpload(files) {\n\t\t\treturn bot.UploadFiles(t.method(), params, files)\n\t\t}\n\n\t\t// However, if there are no files to be uploaded, there's likely things\n\t\t// that need to be turned into params instead.\n\t\tfor _, file := range files {\n\t\t\tparams[file.Name] = file.Data.SendData()\n\t\t}\n\t}\n\n\treturn bot.MakeRequest(c.method(), params)\n}\n\n// Send will send a Chattable item to Telegram and provides the\n// returned Message.\nfunc (bot *BotAPI) Send(c Chattable) (Message, error) {\n\tresp, err := bot.Request(c)\n\tif err != nil {\n\t\treturn Message{}, err\n\t}\n\n\tvar message Message\n\terr = json.Unmarshal(resp.Result, &message)\n\n\treturn message, err\n}\n\n// SendMediaGroup sends a media group and returns the resulting messages.\nfunc (bot *BotAPI) SendMediaGroup(config MediaGroupConfig) ([]Message, error) {\n\tresp, err := bot.Request(config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar messages []Message\n\terr = json.Unmarshal(resp.Result, &messages)\n\n\treturn messages, err\n}\n\n// GetUserProfilePhotos gets a user's profile photos.\n//\n// It requires UserID.\n// Offset and Limit are optional.\nfunc (bot *BotAPI) GetUserProfilePhotos(config UserProfilePhotosConfig) (UserProfilePhotos, error) {\n\tresp, err := bot.Request(config)\n\tif err != nil {\n\t\treturn UserProfilePhotos{}, err\n\t}\n\n\tvar profilePhotos UserProfilePhotos\n\terr = json.Unmarshal(resp.Result, &profilePhotos)\n\n\treturn profilePhotos, err\n}\n\n// GetFile returns a File which can download a file from Telegram.\n//\n// Requires FileID.\nfunc (bot *BotAPI) GetFile(config FileConfig) (File, error) {\n\tresp, err := bot.Request(config)\n\tif err != nil {\n\t\treturn File{}, err\n\t}\n\n\tvar file File\n\terr = json.Unmarshal(resp.Result, &file)\n\n\treturn file, err\n}\n\n// GetUpdates fetches updates.\n// If a WebHook is set, this will not return any data!\n//\n// Offset, Limit, Timeout, and AllowedUpdates are optional.\n// To avoid stale items, set Offset to one higher than the previous item.\n// Set Timeout to a large number to reduce requests, so you can get updates\n// instantly instead of having to wait between requests.\nfunc (bot *BotAPI) GetUpdates(config UpdateConfig) ([]Update, error) {\n\tresp, err := bot.Request(config)\n\tif err != nil {\n\t\treturn []Update{}, err\n\t}\n\n\tvar updates []Update\n\terr = json.Unmarshal(resp.Result, &updates)\n\n\treturn updates, err\n}\n\n// GetWebhookInfo allows you to fetch information about a webhook and if\n// one currently is set, along with pending update count and error messages.\nfunc (bot *BotAPI) GetWebhookInfo() (WebhookInfo, error) {\n\tresp, err := bot.MakeRequest(\"getWebhookInfo\", nil)\n\tif err != nil {\n\t\treturn WebhookInfo{}, err\n\t}\n\n\tvar info WebhookInfo\n\terr = json.Unmarshal(resp.Result, &info)\n\n\treturn info, err\n}\n\n// GetUpdatesChan starts and returns a channel for getting updates.\nfunc (bot *BotAPI) GetUpdatesChan(config UpdateConfig) UpdatesChannel {\n\tch := make(chan Update, bot.Buffer)\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-bot.shutdownChannel:\n\t\t\t\tclose(ch)\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t}\n\n\t\t\tupdates, err := bot.GetUpdates(config)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t\tlog.Println(\"Failed to get updates, retrying in 3 seconds...\")\n\t\t\t\ttime.Sleep(time.Second * 3)\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor _, update := range updates {\n\t\t\t\tif update.UpdateID >= config.Offset {\n\t\t\t\t\tconfig.Offset = update.UpdateID + 1\n\t\t\t\t\tch <- update\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn ch\n}\n\n// StopReceivingUpdates stops the go routine which receives updates\nfunc (bot *BotAPI) StopReceivingUpdates() {\n\tif bot.Debug {\n\t\tlog.Println(\"Stopping the update receiver routine...\")\n\t}\n\tclose(bot.shutdownChannel)\n}\n\n// ListenForWebhook registers a http handler for a webhook.\nfunc (bot *BotAPI) ListenForWebhook(pattern string) UpdatesChannel {\n\tch := make(chan Update, bot.Buffer)\n\n\thttp.HandleFunc(pattern, func(w http.ResponseWriter, r *http.Request) {\n\t\tupdate, err := bot.HandleUpdate(r)\n\t\tif err != nil {\n\t\t\terrMsg, _ := json.Marshal(map[string]string{\"error\": err.Error()})\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\t_, _ = w.Write(errMsg)\n\t\t\treturn\n\t\t}\n\n\t\tch <- *update\n\t})\n\n\treturn ch\n}\n\n// ListenForWebhookRespReqFormat registers a http handler for a single incoming webhook.\nfunc (bot *BotAPI) ListenForWebhookRespReqFormat(w http.ResponseWriter, r *http.Request) UpdatesChannel {\n\tch := make(chan Update, bot.Buffer)\n\n\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\tdefer close(ch)\n\n\t\tupdate, err := bot.HandleUpdate(r)\n\t\tif err != nil {\n\t\t\terrMsg, _ := json.Marshal(map[string]string{\"error\": err.Error()})\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\t_, _ = w.Write(errMsg)\n\t\t\treturn\n\t\t}\n\n\t\tch <- *update\n\t}(w, r)\n\n\treturn ch\n}\n\n// HandleUpdate parses and returns update received via webhook\nfunc (bot *BotAPI) HandleUpdate(r *http.Request) (*Update, error) {\n\tif r.Method != http.MethodPost {\n\t\terr := errors.New(\"wrong HTTP method required POST\")\n\t\treturn nil, err\n\t}\n\n\tvar update Update\n\terr := json.NewDecoder(r.Body).Decode(&update)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &update, nil\n}\n\n// WriteToHTTPResponse writes the request to the HTTP ResponseWriter.\n//\n// It doesn't support uploading files.\n//\n// See https://core.telegram.org/bots/api#making-requests-when-getting-updates\n// for details.\nfunc WriteToHTTPResponse(w http.ResponseWriter, c Chattable) error {\n\tparams, err := c.params()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif t, ok := c.(Fileable); ok {\n\t\tif hasFilesNeedingUpload(t.files()) {\n\t\t\treturn errors.New(\"unable to use http response to upload files\")\n\t\t}\n\t}\n\n\tvalues := buildParams(params)\n\tvalues.Set(\"method\", c.method())\n\n\tw.Header().Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\t_, err = w.Write([]byte(values.Encode()))\n\treturn err\n}\n\n// GetChat gets information about a chat.\nfunc (bot *BotAPI) GetChat(config ChatInfoConfig) (Chat, error) {\n\tresp, err := bot.Request(config)\n\tif err != nil {\n\t\treturn Chat{}, err\n\t}\n\n\tvar chat Chat\n\terr = json.Unmarshal(resp.Result, &chat)\n\n\treturn chat, err\n}\n\n// GetChatAdministrators gets a list of administrators in the chat.\n//\n// If none have been appointed, only the creator will be returned.\n// Bots are not shown, even if they are an administrator.\nfunc (bot *BotAPI) GetChatAdministrators(config ChatAdministratorsConfig) ([]ChatMember, error) {\n\tresp, err := bot.Request(config)\n\tif err != nil {\n\t\treturn []ChatMember{}, err\n\t}\n\n\tvar members []ChatMember\n\terr = json.Unmarshal(resp.Result, &members)\n\n\treturn members, err\n}\n\n// GetChatMembersCount gets the number of users in a chat.\nfunc (bot *BotAPI) GetChatMembersCount(config ChatMemberCountConfig) (int, error) {\n\tresp, err := bot.Request(config)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\tvar count int\n\terr = json.Unmarshal(resp.Result, &count)\n\n\treturn count, err\n}\n\n// GetChatMember gets a specific chat member.\nfunc (bot *BotAPI) GetChatMember(config GetChatMemberConfig) (ChatMember, error) {\n\tresp, err := bot.Request(config)\n\tif err != nil {\n\t\treturn ChatMember{}, err\n\t}\n\n\tvar member ChatMember\n\terr = json.Unmarshal(resp.Result, &member)\n\n\treturn member, err\n}\n\n// GetGameHighScores allows you to get the high scores for a game.\nfunc (bot *BotAPI) GetGameHighScores(config GetGameHighScoresConfig) ([]GameHighScore, error) {\n\tresp, err := bot.Request(config)\n\tif err != nil {\n\t\treturn []GameHighScore{}, err\n\t}\n\n\tvar highScores []GameHighScore\n\terr = json.Unmarshal(resp.Result, &highScores)\n\n\treturn highScores, err\n}\n\n// GetInviteLink get InviteLink for a chat\nfunc (bot *BotAPI) GetInviteLink(config ChatInviteLinkConfig) (string, error) {\n\tresp, err := bot.Request(config)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar inviteLink string\n\terr = json.Unmarshal(resp.Result, &inviteLink)\n\n\treturn inviteLink, err\n}\n\n// GetStickerSet returns a StickerSet.\nfunc (bot *BotAPI) GetStickerSet(config GetStickerSetConfig) (StickerSet, error) {\n\tresp, err := bot.Request(config)\n\tif err != nil {\n\t\treturn StickerSet{}, err\n\t}\n\n\tvar stickers StickerSet\n\terr = json.Unmarshal(resp.Result, &stickers)\n\n\treturn stickers, err\n}\n\n// StopPoll stops a poll and returns the result.\nfunc (bot *BotAPI) StopPoll(config StopPollConfig) (Poll, error) {\n\tresp, err := bot.Request(config)\n\tif err != nil {\n\t\treturn Poll{}, err\n\t}\n\n\tvar poll Poll\n\terr = json.Unmarshal(resp.Result, &poll)\n\n\treturn poll, err\n}\n\n// GetMyCommands gets the currently registered commands.\nfunc (bot *BotAPI) GetMyCommands() ([]BotCommand, error) {\n\treturn bot.GetMyCommandsWithConfig(GetMyCommandsConfig{})\n}\n\n// GetMyCommandsWithConfig gets the currently registered commands with a config.\nfunc (bot *BotAPI) GetMyCommandsWithConfig(config GetMyCommandsConfig) ([]BotCommand, error) {\n\tresp, err := bot.Request(config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar commands []BotCommand\n\terr = json.Unmarshal(resp.Result, &commands)\n\n\treturn commands, err\n}\n\n// CopyMessage copy messages of any kind. The method is analogous to the method\n// forwardMessage, but the copied message doesn't have a link to the original\n// message. Returns the MessageID of the sent message on success.\nfunc (bot *BotAPI) CopyMessage(config CopyMessageConfig) (MessageID, error) {\n\tresp, err := bot.Request(config)\n\tif err != nil {\n\t\treturn MessageID{}, err\n\t}\n\n\tvar messageID MessageID\n\terr = json.Unmarshal(resp.Result, &messageID)\n\n\treturn messageID, err\n}\n\n// AnswerWebAppQuery sets the result of an interaction with a Web App and send a\n// corresponding message on behalf of the user to the chat from which the query originated.\nfunc (bot *BotAPI) AnswerWebAppQuery(config AnswerWebAppQueryConfig) (SentWebAppMessage, error) {\n\tvar sentWebAppMessage SentWebAppMessage\n\n\tresp, err := bot.Request(config)\n\tif err != nil {\n\t\treturn sentWebAppMessage, err\n\t}\n\n\terr = json.Unmarshal(resp.Result, &sentWebAppMessage)\n\treturn sentWebAppMessage, err\n}\n\n// GetMyDefaultAdministratorRights gets the current default administrator rights of the bot.\nfunc (bot *BotAPI) GetMyDefaultAdministratorRights(config GetMyDefaultAdministratorRightsConfig) (ChatAdministratorRights, error) {\n\tvar rights ChatAdministratorRights\n\n\tresp, err := bot.Request(config)\n\tif err != nil {\n\t\treturn rights, err\n\t}\n\n\terr = json.Unmarshal(resp.Result, &rights)\n\treturn rights, err\n}\n\n// EscapeText takes an input text and escape Telegram markup symbols.\n// In this way we can send a text without being afraid of having to escape the characters manually.\n// Note that you don't have to include the formatting style in the input text, or it will be escaped too.\n// If there is an error, an empty string will be returned.\n//\n// parseMode is the text formatting mode (ModeMarkdown, ModeMarkdownV2 or ModeHTML)\n// text is the input string that will be escaped\nfunc EscapeText(parseMode string, text string) string {\n\tvar replacer *strings.Replacer\n\n\tif parseMode == ModeHTML {\n\t\treplacer = strings.NewReplacer(\"<\", \"&lt;\", \">\", \"&gt;\", \"&\", \"&amp;\")\n\t} else if parseMode == ModeMarkdown {\n\t\treplacer = strings.NewReplacer(\"_\", \"\\\\_\", \"*\", \"\\\\*\", \"`\", \"\\\\`\", \"[\", \"\\\\[\")\n\t} else if parseMode == ModeMarkdownV2 {\n\t\treplacer = strings.NewReplacer(\n\t\t\t\"_\", \"\\\\_\", \"*\", \"\\\\*\", \"[\", \"\\\\[\", \"]\", \"\\\\]\", \"(\",\n\t\t\t\"\\\\(\", \")\", \"\\\\)\", \"~\", \"\\\\~\", \"`\", \"\\\\`\", \">\", \"\\\\>\",\n\t\t\t\"#\", \"\\\\#\", \"+\", \"\\\\+\", \"-\", \"\\\\-\", \"=\", \"\\\\=\", \"|\",\n\t\t\t\"\\\\|\", \"{\", \"\\\\{\", \"}\", \"\\\\}\", \".\", \"\\\\.\", \"!\", \"\\\\!\",\n\t\t)\n\t} else {\n\t\treturn \"\"\n\t}\n\n\treturn replacer.Replace(text)\n}\n"
        },
        {
          "name": "bot_test.go",
          "type": "blob",
          "size": 20.515625,
          "content": "package tgbotapi\n\nimport (\n\t\"net/http\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n)\n\nconst (\n\tTestToken               = \"153667468:AAHlSHlMqSt1f_uFmVRJbm5gntu2HI4WW8I\"\n\tChatID                  = 76918703\n\tChannel                 = \"@tgbotapitest\"\n\tSupergroupChatID        = -1001120141283\n\tReplyToMessageID        = 35\n\tExistingPhotoFileID     = \"AgACAgIAAxkDAAEBFUZhIALQ9pZN4BUe8ZSzUU_2foSo1AACnrMxG0BucEhezsBWOgcikQEAAwIAA20AAyAE\"\n\tExistingDocumentFileID  = \"BQADAgADOQADjMcoCcioX1GrDvp3Ag\"\n\tExistingAudioFileID     = \"BQADAgADRgADjMcoCdXg3lSIN49lAg\"\n\tExistingVoiceFileID     = \"AwADAgADWQADjMcoCeul6r_q52IyAg\"\n\tExistingVideoFileID     = \"BAADAgADZgADjMcoCav432kYe0FRAg\"\n\tExistingVideoNoteFileID = \"DQADAgADdQAD70cQSUK41dLsRMqfAg\"\n\tExistingStickerFileID   = \"BQADAgADcwADjMcoCbdl-6eB--YPAg\"\n)\n\ntype testLogger struct {\n\tt *testing.T\n}\n\nfunc (t testLogger) Println(v ...interface{}) {\n\tt.t.Log(v...)\n}\n\nfunc (t testLogger) Printf(format string, v ...interface{}) {\n\tt.t.Logf(format, v...)\n}\n\nfunc getBot(t *testing.T) (*BotAPI, error) {\n\tbot, err := NewBotAPI(TestToken)\n\tbot.Debug = true\n\n\tlogger := testLogger{t}\n\tSetLogger(logger)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\treturn bot, err\n}\n\nfunc TestNewBotAPI_notoken(t *testing.T) {\n\t_, err := NewBotAPI(\"\")\n\n\tif err == nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestGetUpdates(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tu := NewUpdate(0)\n\n\t_, err := bot.GetUpdates(u)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithMessage(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewMessage(ChatID, \"A test message from the test library in telegram-bot-api\")\n\tmsg.ParseMode = ModeMarkdown\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithMessageReply(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewMessage(ChatID, \"A test message from the test library in telegram-bot-api\")\n\tmsg.ReplyToMessageID = ReplyToMessageID\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithMessageForward(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewForward(ChatID, ChatID, ReplyToMessageID)\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestCopyMessage(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewMessage(ChatID, \"A test message from the test library in telegram-bot-api\")\n\tmessage, err := bot.Send(msg)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tcopyMessageConfig := NewCopyMessage(SupergroupChatID, message.Chat.ID, message.MessageID)\n\tmessageID, err := bot.CopyMessage(copyMessageConfig)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif messageID.MessageID == message.MessageID {\n\t\tt.Error(\"copied message ID was the same as original message\")\n\t}\n}\n\nfunc TestSendWithNewPhoto(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewPhoto(ChatID, FilePath(\"tests/image.jpg\"))\n\tmsg.Caption = \"Test\"\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithNewPhotoWithFileBytes(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tdata, _ := os.ReadFile(\"tests/image.jpg\")\n\tb := FileBytes{Name: \"image.jpg\", Bytes: data}\n\n\tmsg := NewPhoto(ChatID, b)\n\tmsg.Caption = \"Test\"\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithNewPhotoWithFileReader(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tf, _ := os.Open(\"tests/image.jpg\")\n\treader := FileReader{Name: \"image.jpg\", Reader: f}\n\n\tmsg := NewPhoto(ChatID, reader)\n\tmsg.Caption = \"Test\"\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithNewPhotoReply(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewPhoto(ChatID, FilePath(\"tests/image.jpg\"))\n\tmsg.ReplyToMessageID = ReplyToMessageID\n\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendNewPhotoToChannel(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewPhotoToChannel(Channel, FilePath(\"tests/image.jpg\"))\n\tmsg.Caption = \"Test\"\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t\tt.Fail()\n\t}\n}\n\nfunc TestSendNewPhotoToChannelFileBytes(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tdata, _ := os.ReadFile(\"tests/image.jpg\")\n\tb := FileBytes{Name: \"image.jpg\", Bytes: data}\n\n\tmsg := NewPhotoToChannel(Channel, b)\n\tmsg.Caption = \"Test\"\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t\tt.Fail()\n\t}\n}\n\nfunc TestSendNewPhotoToChannelFileReader(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tf, _ := os.Open(\"tests/image.jpg\")\n\treader := FileReader{Name: \"image.jpg\", Reader: f}\n\n\tmsg := NewPhotoToChannel(Channel, reader)\n\tmsg.Caption = \"Test\"\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t\tt.Fail()\n\t}\n}\n\nfunc TestSendWithExistingPhoto(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewPhoto(ChatID, FileID(ExistingPhotoFileID))\n\tmsg.Caption = \"Test\"\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithNewDocument(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewDocument(ChatID, FilePath(\"tests/image.jpg\"))\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithNewDocumentAndThumb(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewDocument(ChatID, FilePath(\"tests/voice.ogg\"))\n\tmsg.Thumb = FilePath(\"tests/image.jpg\")\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithExistingDocument(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewDocument(ChatID, FileID(ExistingDocumentFileID))\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithNewAudio(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewAudio(ChatID, FilePath(\"tests/audio.mp3\"))\n\tmsg.Title = \"TEST\"\n\tmsg.Duration = 10\n\tmsg.Performer = \"TEST\"\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithExistingAudio(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewAudio(ChatID, FileID(ExistingAudioFileID))\n\tmsg.Title = \"TEST\"\n\tmsg.Duration = 10\n\tmsg.Performer = \"TEST\"\n\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithNewVoice(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewVoice(ChatID, FilePath(\"tests/voice.ogg\"))\n\tmsg.Duration = 10\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithExistingVoice(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewVoice(ChatID, FileID(ExistingVoiceFileID))\n\tmsg.Duration = 10\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithContact(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tcontact := NewContact(ChatID, \"5551234567\", \"Test\")\n\n\tif _, err := bot.Send(contact); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithLocation(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\t_, err := bot.Send(NewLocation(ChatID, 40, 40))\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithVenue(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tvenue := NewVenue(ChatID, \"A Test Location\", \"123 Test Street\", 40, 40)\n\n\tif _, err := bot.Send(venue); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithNewVideo(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewVideo(ChatID, FilePath(\"tests/video.mp4\"))\n\tmsg.Duration = 10\n\tmsg.Caption = \"TEST\"\n\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithExistingVideo(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewVideo(ChatID, FileID(ExistingVideoFileID))\n\tmsg.Duration = 10\n\tmsg.Caption = \"TEST\"\n\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithNewVideoNote(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewVideoNote(ChatID, 240, FilePath(\"tests/videonote.mp4\"))\n\tmsg.Duration = 10\n\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithExistingVideoNote(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewVideoNote(ChatID, 240, FileID(ExistingVideoNoteFileID))\n\tmsg.Duration = 10\n\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithNewSticker(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewSticker(ChatID, FilePath(\"tests/image.jpg\"))\n\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithExistingSticker(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewSticker(ChatID, FileID(ExistingStickerFileID))\n\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithNewStickerAndKeyboardHide(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewSticker(ChatID, FilePath(\"tests/image.jpg\"))\n\tmsg.ReplyMarkup = ReplyKeyboardRemove{\n\t\tRemoveKeyboard: true,\n\t\tSelective:      false,\n\t}\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithExistingStickerAndKeyboardHide(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewSticker(ChatID, FileID(ExistingStickerFileID))\n\tmsg.ReplyMarkup = ReplyKeyboardRemove{\n\t\tRemoveKeyboard: true,\n\t\tSelective:      false,\n\t}\n\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendWithDice(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewDice(ChatID)\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t\tt.Fail()\n\t}\n\n}\n\nfunc TestSendWithDiceWithEmoji(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewDiceWithEmoji(ChatID, \"🏀\")\n\t_, err := bot.Send(msg)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t\tt.Fail()\n\t}\n\n}\n\nfunc TestGetFile(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tfile := FileConfig{\n\t\tFileID: ExistingPhotoFileID,\n\t}\n\n\t_, err := bot.GetFile(file)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSendChatConfig(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\t_, err := bot.Request(NewChatAction(ChatID, ChatTyping))\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\n// TODO: identify why this isn't working\n// func TestSendEditMessage(t *testing.T) {\n// \tbot, _ := getBot(t)\n\n// \tmsg, err := bot.Send(NewMessage(ChatID, \"Testing editing.\"))\n// \tif err != nil {\n// \t\tt.Error(err)\n// \t}\n\n// \tedit := EditMessageTextConfig{\n// \t\tBaseEdit: BaseEdit{\n// \t\t\tChatID:    ChatID,\n// \t\t\tMessageID: msg.MessageID,\n// \t\t},\n// \t\tText: \"Updated text.\",\n// \t}\n\n// \t_, err = bot.Send(edit)\n// \tif err != nil {\n// \t\tt.Error(err)\n// \t}\n// }\n\nfunc TestGetUserProfilePhotos(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\t_, err := bot.GetUserProfilePhotos(NewUserProfilePhotos(ChatID))\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestSetWebhookWithCert(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\ttime.Sleep(time.Second * 2)\n\n\tbot.Request(DeleteWebhookConfig{})\n\n\twh, err := NewWebhookWithCert(\"https://example.com/tgbotapi-test/\"+bot.Token, FilePath(\"tests/cert.pem\"))\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\t_, err = bot.Request(wh)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\t_, err = bot.GetWebhookInfo()\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tbot.Request(DeleteWebhookConfig{})\n}\n\nfunc TestSetWebhookWithoutCert(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\ttime.Sleep(time.Second * 2)\n\n\tbot.Request(DeleteWebhookConfig{})\n\n\twh, err := NewWebhook(\"https://example.com/tgbotapi-test/\" + bot.Token)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\t_, err = bot.Request(wh)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tinfo, err := bot.GetWebhookInfo()\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif info.MaxConnections == 0 {\n\t\tt.Errorf(\"Expected maximum connections to be greater than 0\")\n\t}\n\tif info.LastErrorDate != 0 {\n\t\tt.Errorf(\"failed to set webhook: %s\", info.LastErrorMessage)\n\t}\n\n\tbot.Request(DeleteWebhookConfig{})\n}\n\nfunc TestSendWithMediaGroupPhotoVideo(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tcfg := NewMediaGroup(ChatID, []interface{}{\n\t\tNewInputMediaPhoto(FileURL(\"https://github.com/go-telegram-bot-api/telegram-bot-api/raw/0a3a1c8716c4cd8d26a262af9f12dcbab7f3f28c/tests/image.jpg\")),\n\t\tNewInputMediaPhoto(FilePath(\"tests/image.jpg\")),\n\t\tNewInputMediaVideo(FilePath(\"tests/video.mp4\")),\n\t})\n\n\tmessages, err := bot.SendMediaGroup(cfg)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif messages == nil {\n\t\tt.Error(\"No received messages\")\n\t}\n\n\tif len(messages) != len(cfg.Media) {\n\t\tt.Errorf(\"Different number of messages: %d\", len(messages))\n\t}\n}\n\nfunc TestSendWithMediaGroupDocument(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tcfg := NewMediaGroup(ChatID, []interface{}{\n\t\tNewInputMediaDocument(FileURL(\"https://i.imgur.com/unQLJIb.jpg\")),\n\t\tNewInputMediaDocument(FilePath(\"tests/image.jpg\")),\n\t})\n\n\tmessages, err := bot.SendMediaGroup(cfg)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif messages == nil {\n\t\tt.Error(\"No received messages\")\n\t}\n\n\tif len(messages) != len(cfg.Media) {\n\t\tt.Errorf(\"Different number of messages: %d\", len(messages))\n\t}\n}\n\nfunc TestSendWithMediaGroupAudio(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tcfg := NewMediaGroup(ChatID, []interface{}{\n\t\tNewInputMediaAudio(FilePath(\"tests/audio.mp3\")),\n\t\tNewInputMediaAudio(FilePath(\"tests/audio.mp3\")),\n\t})\n\n\tmessages, err := bot.SendMediaGroup(cfg)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif messages == nil {\n\t\tt.Error(\"No received messages\")\n\t}\n\n\tif len(messages) != len(cfg.Media) {\n\t\tt.Errorf(\"Different number of messages: %d\", len(messages))\n\t}\n}\n\nfunc ExampleNewBotAPI() {\n\tbot, err := NewBotAPI(\"MyAwesomeBotToken\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tbot.Debug = true\n\n\tlog.Printf(\"Authorized on account %s\", bot.Self.UserName)\n\n\tu := NewUpdate(0)\n\tu.Timeout = 60\n\n\tupdates := bot.GetUpdatesChan(u)\n\n\t// Optional: wait for updates and clear them if you don't want to handle\n\t// a large backlog of old messages\n\ttime.Sleep(time.Millisecond * 500)\n\tupdates.Clear()\n\n\tfor update := range updates {\n\t\tif update.Message == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tlog.Printf(\"[%s] %s\", update.Message.From.UserName, update.Message.Text)\n\n\t\tmsg := NewMessage(update.Message.Chat.ID, update.Message.Text)\n\t\tmsg.ReplyToMessageID = update.Message.MessageID\n\n\t\tbot.Send(msg)\n\t}\n}\n\nfunc ExampleNewWebhook() {\n\tbot, err := NewBotAPI(\"MyAwesomeBotToken\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tbot.Debug = true\n\n\tlog.Printf(\"Authorized on account %s\", bot.Self.UserName)\n\n\twh, err := NewWebhookWithCert(\"https://www.google.com:8443/\"+bot.Token, FilePath(\"cert.pem\"))\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t_, err = bot.Request(wh)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tinfo, err := bot.GetWebhookInfo()\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif info.LastErrorDate != 0 {\n\t\tlog.Printf(\"failed to set webhook: %s\", info.LastErrorMessage)\n\t}\n\n\tupdates := bot.ListenForWebhook(\"/\" + bot.Token)\n\tgo http.ListenAndServeTLS(\"0.0.0.0:8443\", \"cert.pem\", \"key.pem\", nil)\n\n\tfor update := range updates {\n\t\tlog.Printf(\"%+v\\n\", update)\n\t}\n}\n\nfunc ExampleWebhookHandler() {\n\tbot, err := NewBotAPI(\"MyAwesomeBotToken\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tbot.Debug = true\n\n\tlog.Printf(\"Authorized on account %s\", bot.Self.UserName)\n\n\twh, err := NewWebhookWithCert(\"https://www.google.com:8443/\"+bot.Token, FilePath(\"cert.pem\"))\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t_, err = bot.Request(wh)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tinfo, err := bot.GetWebhookInfo()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tif info.LastErrorDate != 0 {\n\t\tlog.Printf(\"[Telegram callback failed]%s\", info.LastErrorMessage)\n\t}\n\n\thttp.HandleFunc(\"/\"+bot.Token, func(w http.ResponseWriter, r *http.Request) {\n\t\tupdate, err := bot.HandleUpdate(r)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"%+v\\n\", err.Error())\n\t\t} else {\n\t\t\tlog.Printf(\"%+v\\n\", *update)\n\t\t}\n\t})\n\n\tgo http.ListenAndServeTLS(\"0.0.0.0:8443\", \"cert.pem\", \"key.pem\", nil)\n}\n\nfunc ExampleInlineConfig() {\n\tbot, err := NewBotAPI(\"MyAwesomeBotToken\") // create new bot\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tlog.Printf(\"Authorized on account %s\", bot.Self.UserName)\n\n\tu := NewUpdate(0)\n\tu.Timeout = 60\n\n\tupdates := bot.GetUpdatesChan(u)\n\n\tfor update := range updates {\n\t\tif update.InlineQuery == nil { // if no inline query, ignore it\n\t\t\tcontinue\n\t\t}\n\n\t\tarticle := NewInlineQueryResultArticle(update.InlineQuery.ID, \"Echo\", update.InlineQuery.Query)\n\t\tarticle.Description = update.InlineQuery.Query\n\n\t\tinlineConf := InlineConfig{\n\t\t\tInlineQueryID: update.InlineQuery.ID,\n\t\t\tIsPersonal:    true,\n\t\t\tCacheTime:     0,\n\t\t\tResults:       []interface{}{article},\n\t\t}\n\n\t\tif _, err := bot.Request(inlineConf); err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t}\n}\n\nfunc TestDeleteMessage(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewMessage(ChatID, \"A test message from the test library in telegram-bot-api\")\n\tmsg.ParseMode = ModeMarkdown\n\tmessage, _ := bot.Send(msg)\n\n\tdeleteMessageConfig := DeleteMessageConfig{\n\t\tChatID:    message.Chat.ID,\n\t\tMessageID: message.MessageID,\n\t}\n\t_, err := bot.Request(deleteMessageConfig)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestPinChatMessage(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewMessage(SupergroupChatID, \"A test message from the test library in telegram-bot-api\")\n\tmsg.ParseMode = ModeMarkdown\n\tmessage, _ := bot.Send(msg)\n\n\tpinChatMessageConfig := PinChatMessageConfig{\n\t\tChatID:              message.Chat.ID,\n\t\tMessageID:           message.MessageID,\n\t\tDisableNotification: false,\n\t}\n\t_, err := bot.Request(pinChatMessageConfig)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestUnpinChatMessage(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewMessage(SupergroupChatID, \"A test message from the test library in telegram-bot-api\")\n\tmsg.ParseMode = ModeMarkdown\n\tmessage, _ := bot.Send(msg)\n\n\t// We need pin message to unpin something\n\tpinChatMessageConfig := PinChatMessageConfig{\n\t\tChatID:              message.Chat.ID,\n\t\tMessageID:           message.MessageID,\n\t\tDisableNotification: false,\n\t}\n\n\tif _, err := bot.Request(pinChatMessageConfig); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tunpinChatMessageConfig := UnpinChatMessageConfig{\n\t\tChatID:    message.Chat.ID,\n\t\tMessageID: message.MessageID,\n\t}\n\n\tif _, err := bot.Request(unpinChatMessageConfig); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestUnpinAllChatMessages(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tmsg := NewMessage(SupergroupChatID, \"A test message from the test library in telegram-bot-api\")\n\tmsg.ParseMode = ModeMarkdown\n\tmessage, _ := bot.Send(msg)\n\n\tpinChatMessageConfig := PinChatMessageConfig{\n\t\tChatID:              message.Chat.ID,\n\t\tMessageID:           message.MessageID,\n\t\tDisableNotification: true,\n\t}\n\n\tif _, err := bot.Request(pinChatMessageConfig); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tunpinAllChatMessagesConfig := UnpinAllChatMessagesConfig{\n\t\tChatID: message.Chat.ID,\n\t}\n\n\tif _, err := bot.Request(unpinAllChatMessagesConfig); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestPolls(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tpoll := NewPoll(SupergroupChatID, \"Are polls working?\", \"Yes\", \"No\")\n\n\tmsg, err := bot.Send(poll)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tresult, err := bot.StopPoll(NewStopPoll(SupergroupChatID, msg.MessageID))\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif result.Question != \"Are polls working?\" {\n\t\tt.Error(\"Poll question did not match\")\n\t}\n\n\tif !result.IsClosed {\n\t\tt.Error(\"Poll did not end\")\n\t}\n\n\tif result.Options[0].Text != \"Yes\" || result.Options[0].VoterCount != 0 || result.Options[1].Text != \"No\" || result.Options[1].VoterCount != 0 {\n\t\tt.Error(\"Poll options were incorrect\")\n\t}\n}\n\nfunc TestSendDice(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tdice := NewDice(ChatID)\n\n\tmsg, err := bot.Send(dice)\n\tif err != nil {\n\t\tt.Error(\"Unable to send dice roll\")\n\t}\n\n\tif msg.Dice == nil {\n\t\tt.Error(\"Dice roll was not received\")\n\t}\n}\n\nfunc TestCommands(t *testing.T) {\n\tbot, _ := getBot(t)\n\n\tsetCommands := NewSetMyCommands(BotCommand{\n\t\tCommand:     \"test\",\n\t\tDescription: \"a test command\",\n\t})\n\n\tif _, err := bot.Request(setCommands); err != nil {\n\t\tt.Error(\"Unable to set commands\")\n\t}\n\n\tcommands, err := bot.GetMyCommands()\n\tif err != nil {\n\t\tt.Error(\"Unable to get commands\")\n\t}\n\n\tif len(commands) != 1 {\n\t\tt.Error(\"Incorrect number of commands returned\")\n\t}\n\n\tif commands[0].Command != \"test\" || commands[0].Description != \"a test command\" {\n\t\tt.Error(\"Commands were incorrectly set\")\n\t}\n\n\tsetCommands = NewSetMyCommandsWithScope(NewBotCommandScopeAllPrivateChats(), BotCommand{\n\t\tCommand:     \"private\",\n\t\tDescription: \"a private command\",\n\t})\n\n\tif _, err := bot.Request(setCommands); err != nil {\n\t\tt.Error(\"Unable to set commands\")\n\t}\n\n\tcommands, err = bot.GetMyCommandsWithConfig(NewGetMyCommandsWithScope(NewBotCommandScopeAllPrivateChats()))\n\tif err != nil {\n\t\tt.Error(\"Unable to get commands\")\n\t}\n\n\tif len(commands) != 1 {\n\t\tt.Error(\"Incorrect number of commands returned\")\n\t}\n\n\tif commands[0].Command != \"private\" || commands[0].Description != \"a private command\" {\n\t\tt.Error(\"Commands were incorrectly set\")\n\t}\n}\n\n// TODO: figure out why test is failing\n//\n// func TestEditMessageMedia(t *testing.T) {\n// \tbot, _ := getBot(t)\n\n// \tmsg := NewPhoto(ChatID, \"tests/image.jpg\")\n// \tmsg.Caption = \"Test\"\n// \tm, err := bot.Send(msg)\n\n// \tif err != nil {\n// \t\tt.Error(err)\n// \t}\n\n// \tedit := EditMessageMediaConfig{\n// \t\tBaseEdit: BaseEdit{\n// \t\t\tChatID:    ChatID,\n// \t\t\tMessageID: m.MessageID,\n// \t\t},\n// \t\tMedia: NewInputMediaVideo(FilePath(\"tests/video.mp4\")),\n// \t}\n\n// \t_, err = bot.Request(edit)\n// \tif err != nil {\n// \t\tt.Error(err)\n// \t}\n// }\n\nfunc TestPrepareInputMediaForParams(t *testing.T) {\n\tmedia := []interface{}{\n\t\tNewInputMediaPhoto(FilePath(\"tests/image.jpg\")),\n\t\tNewInputMediaVideo(FileID(\"test\")),\n\t}\n\n\tprepared := prepareInputMediaForParams(media)\n\n\tif media[0].(InputMediaPhoto).Media != FilePath(\"tests/image.jpg\") {\n\t\tt.Error(\"Original media was changed\")\n\t}\n\n\tif prepared[0].(InputMediaPhoto).Media != fileAttach(\"attach://file-0\") {\n\t\tt.Error(\"New media was not replaced\")\n\t}\n\n\tif prepared[1].(InputMediaVideo).Media != FileID(\"test\") {\n\t\tt.Error(\"Passthrough value was not the same\")\n\t}\n}\n"
        },
        {
          "name": "configs.go",
          "type": "blob",
          "size": 65.0791015625,
          "content": "package tgbotapi\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/url\"\n\t\"os\"\n\t\"strconv\"\n)\n\n// Telegram constants\nconst (\n\t// APIEndpoint is the endpoint for all API methods,\n\t// with formatting for Sprintf.\n\tAPIEndpoint = \"https://api.telegram.org/bot%s/%s\"\n\t// FileEndpoint is the endpoint for downloading a file from Telegram.\n\tFileEndpoint = \"https://api.telegram.org/file/bot%s/%s\"\n)\n\n// Constant values for ChatActions\nconst (\n\tChatTyping          = \"typing\"\n\tChatUploadPhoto     = \"upload_photo\"\n\tChatRecordVideo     = \"record_video\"\n\tChatUploadVideo     = \"upload_video\"\n\tChatRecordVoice     = \"record_voice\"\n\tChatUploadVoice     = \"upload_voice\"\n\tChatUploadDocument  = \"upload_document\"\n\tChatChooseSticker   = \"choose_sticker\"\n\tChatFindLocation    = \"find_location\"\n\tChatRecordVideoNote = \"record_video_note\"\n\tChatUploadVideoNote = \"upload_video_note\"\n)\n\n// API errors\nconst (\n\t// ErrAPIForbidden happens when a token is bad\n\tErrAPIForbidden = \"forbidden\"\n)\n\n// Constant values for ParseMode in MessageConfig\nconst (\n\tModeMarkdown   = \"Markdown\"\n\tModeMarkdownV2 = \"MarkdownV2\"\n\tModeHTML       = \"HTML\"\n)\n\n// Constant values for update types\nconst (\n\t// UpdateTypeMessage is new incoming message of any kind — text, photo, sticker, etc.\n\tUpdateTypeMessage = \"message\"\n\n\t// UpdateTypeEditedMessage is new version of a message that is known to the bot and was edited\n\tUpdateTypeEditedMessage = \"edited_message\"\n\n\t// UpdateTypeChannelPost is new incoming channel post of any kind — text, photo, sticker, etc.\n\tUpdateTypeChannelPost = \"channel_post\"\n\n\t// UpdateTypeEditedChannelPost is new version of a channel post that is known to the bot and was edited\n\tUpdateTypeEditedChannelPost = \"edited_channel_post\"\n\n\t// UpdateTypeInlineQuery is new incoming inline query\n\tUpdateTypeInlineQuery = \"inline_query\"\n\n\t// UpdateTypeChosenInlineResult i the result of an inline query that was chosen by a user and sent to their\n\t// chat partner. Please see the documentation on the feedback collecting for\n\t// details on how to enable these updates for your bot.\n\tUpdateTypeChosenInlineResult = \"chosen_inline_result\"\n\n\t// UpdateTypeCallbackQuery is new incoming callback query\n\tUpdateTypeCallbackQuery = \"callback_query\"\n\n\t// UpdateTypeShippingQuery is new incoming shipping query. Only for invoices with flexible price\n\tUpdateTypeShippingQuery = \"shipping_query\"\n\n\t// UpdateTypePreCheckoutQuery is new incoming pre-checkout query. Contains full information about checkout\n\tUpdateTypePreCheckoutQuery = \"pre_checkout_query\"\n\n\t// UpdateTypePoll is new poll state. Bots receive only updates about stopped polls and polls\n\t// which are sent by the bot\n\tUpdateTypePoll = \"poll\"\n\n\t// UpdateTypePollAnswer is when user changed their answer in a non-anonymous poll. Bots receive new votes\n\t// only in polls that were sent by the bot itself.\n\tUpdateTypePollAnswer = \"poll_answer\"\n\n\t// UpdateTypeMyChatMember is when the bot's chat member status was updated in a chat. For private chats, this\n\t// update is received only when the bot is blocked or unblocked by the user.\n\tUpdateTypeMyChatMember = \"my_chat_member\"\n\n\t// UpdateTypeChatMember is when the bot must be an administrator in the chat and must explicitly specify\n\t// this update in the list of allowed_updates to receive these updates.\n\tUpdateTypeChatMember = \"chat_member\"\n)\n\n// Library errors\nconst (\n\tErrBadURL = \"bad or empty url\"\n)\n\n// Chattable is any config type that can be sent.\ntype Chattable interface {\n\tparams() (Params, error)\n\tmethod() string\n}\n\n// Fileable is any config type that can be sent that includes a file.\ntype Fileable interface {\n\tChattable\n\tfiles() []RequestFile\n}\n\n// RequestFile represents a file associated with a field name.\ntype RequestFile struct {\n\t// The file field name.\n\tName string\n\t// The file data to include.\n\tData RequestFileData\n}\n\n// RequestFileData represents the data to be used for a file.\ntype RequestFileData interface {\n\t// NeedsUpload shows if the file needs to be uploaded.\n\tNeedsUpload() bool\n\n\t// UploadData gets the file name and an `io.Reader` for the file to be uploaded. This\n\t// must only be called when the file needs to be uploaded.\n\tUploadData() (string, io.Reader, error)\n\t// SendData gets the file data to send when a file does not need to be uploaded. This\n\t// must only be called when the file does not need to be uploaded.\n\tSendData() string\n}\n\n// FileBytes contains information about a set of bytes to upload\n// as a File.\ntype FileBytes struct {\n\tName  string\n\tBytes []byte\n}\n\nfunc (fb FileBytes) NeedsUpload() bool {\n\treturn true\n}\n\nfunc (fb FileBytes) UploadData() (string, io.Reader, error) {\n\treturn fb.Name, bytes.NewReader(fb.Bytes), nil\n}\n\nfunc (fb FileBytes) SendData() string {\n\tpanic(\"FileBytes must be uploaded\")\n}\n\n// FileReader contains information about a reader to upload as a File.\ntype FileReader struct {\n\tName   string\n\tReader io.Reader\n}\n\nfunc (fr FileReader) NeedsUpload() bool {\n\treturn true\n}\n\nfunc (fr FileReader) UploadData() (string, io.Reader, error) {\n\treturn fr.Name, fr.Reader, nil\n}\n\nfunc (fr FileReader) SendData() string {\n\tpanic(\"FileReader must be uploaded\")\n}\n\n// FilePath is a path to a local file.\ntype FilePath string\n\nfunc (fp FilePath) NeedsUpload() bool {\n\treturn true\n}\n\nfunc (fp FilePath) UploadData() (string, io.Reader, error) {\n\tfileHandle, err := os.Open(string(fp))\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\tname := fileHandle.Name()\n\treturn name, fileHandle, err\n}\n\nfunc (fp FilePath) SendData() string {\n\tpanic(\"FilePath must be uploaded\")\n}\n\n// FileURL is a URL to use as a file for a request.\ntype FileURL string\n\nfunc (fu FileURL) NeedsUpload() bool {\n\treturn false\n}\n\nfunc (fu FileURL) UploadData() (string, io.Reader, error) {\n\tpanic(\"FileURL cannot be uploaded\")\n}\n\nfunc (fu FileURL) SendData() string {\n\treturn string(fu)\n}\n\n// FileID is an ID of a file already uploaded to Telegram.\ntype FileID string\n\nfunc (fi FileID) NeedsUpload() bool {\n\treturn false\n}\n\nfunc (fi FileID) UploadData() (string, io.Reader, error) {\n\tpanic(\"FileID cannot be uploaded\")\n}\n\nfunc (fi FileID) SendData() string {\n\treturn string(fi)\n}\n\n// fileAttach is an internal file type used for processed media groups.\ntype fileAttach string\n\nfunc (fa fileAttach) NeedsUpload() bool {\n\treturn false\n}\n\nfunc (fa fileAttach) UploadData() (string, io.Reader, error) {\n\tpanic(\"fileAttach cannot be uploaded\")\n}\n\nfunc (fa fileAttach) SendData() string {\n\treturn string(fa)\n}\n\n// LogOutConfig is a request to log out of the cloud Bot API server.\n//\n// Note that you may not log back in for at least 10 minutes.\ntype LogOutConfig struct{}\n\nfunc (LogOutConfig) method() string {\n\treturn \"logOut\"\n}\n\nfunc (LogOutConfig) params() (Params, error) {\n\treturn nil, nil\n}\n\n// CloseConfig is a request to close the bot instance on a local server.\n//\n// Note that you may not close an instance for the first 10 minutes after the\n// bot has started.\ntype CloseConfig struct{}\n\nfunc (CloseConfig) method() string {\n\treturn \"close\"\n}\n\nfunc (CloseConfig) params() (Params, error) {\n\treturn nil, nil\n}\n\n// BaseChat is base type for all chat config types.\ntype BaseChat struct {\n\tChatID                   int64 // required\n\tChannelUsername          string\n\tProtectContent           bool\n\tReplyToMessageID         int\n\tReplyMarkup              interface{}\n\tDisableNotification      bool\n\tAllowSendingWithoutReply bool\n}\n\nfunc (chat *BaseChat) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", chat.ChatID, chat.ChannelUsername)\n\tparams.AddNonZero(\"reply_to_message_id\", chat.ReplyToMessageID)\n\tparams.AddBool(\"disable_notification\", chat.DisableNotification)\n\tparams.AddBool(\"allow_sending_without_reply\", chat.AllowSendingWithoutReply)\n\tparams.AddBool(\"protect_content\", chat.ProtectContent)\n\n\terr := params.AddInterface(\"reply_markup\", chat.ReplyMarkup)\n\n\treturn params, err\n}\n\n// BaseFile is a base type for all file config types.\ntype BaseFile struct {\n\tBaseChat\n\tFile RequestFileData\n}\n\nfunc (file BaseFile) params() (Params, error) {\n\treturn file.BaseChat.params()\n}\n\n// BaseEdit is base type of all chat edits.\ntype BaseEdit struct {\n\tChatID          int64\n\tChannelUsername string\n\tMessageID       int\n\tInlineMessageID string\n\tReplyMarkup     *InlineKeyboardMarkup\n}\n\nfunc (edit BaseEdit) params() (Params, error) {\n\tparams := make(Params)\n\n\tif edit.InlineMessageID != \"\" {\n\t\tparams[\"inline_message_id\"] = edit.InlineMessageID\n\t} else {\n\t\tparams.AddFirstValid(\"chat_id\", edit.ChatID, edit.ChannelUsername)\n\t\tparams.AddNonZero(\"message_id\", edit.MessageID)\n\t}\n\n\terr := params.AddInterface(\"reply_markup\", edit.ReplyMarkup)\n\n\treturn params, err\n}\n\n// MessageConfig contains information about a SendMessage request.\ntype MessageConfig struct {\n\tBaseChat\n\tText                  string\n\tParseMode             string\n\tEntities              []MessageEntity\n\tDisableWebPagePreview bool\n}\n\nfunc (config MessageConfig) params() (Params, error) {\n\tparams, err := config.BaseChat.params()\n\tif err != nil {\n\t\treturn params, err\n\t}\n\n\tparams.AddNonEmpty(\"text\", config.Text)\n\tparams.AddBool(\"disable_web_page_preview\", config.DisableWebPagePreview)\n\tparams.AddNonEmpty(\"parse_mode\", config.ParseMode)\n\terr = params.AddInterface(\"entities\", config.Entities)\n\n\treturn params, err\n}\n\nfunc (config MessageConfig) method() string {\n\treturn \"sendMessage\"\n}\n\n// ForwardConfig contains information about a ForwardMessage request.\ntype ForwardConfig struct {\n\tBaseChat\n\tFromChatID          int64 // required\n\tFromChannelUsername string\n\tMessageID           int // required\n}\n\nfunc (config ForwardConfig) params() (Params, error) {\n\tparams, err := config.BaseChat.params()\n\tif err != nil {\n\t\treturn params, err\n\t}\n\n\tparams.AddNonZero64(\"from_chat_id\", config.FromChatID)\n\tparams.AddNonZero(\"message_id\", config.MessageID)\n\n\treturn params, nil\n}\n\nfunc (config ForwardConfig) method() string {\n\treturn \"forwardMessage\"\n}\n\n// CopyMessageConfig contains information about a copyMessage request.\ntype CopyMessageConfig struct {\n\tBaseChat\n\tFromChatID          int64\n\tFromChannelUsername string\n\tMessageID           int\n\tCaption             string\n\tParseMode           string\n\tCaptionEntities     []MessageEntity\n}\n\nfunc (config CopyMessageConfig) params() (Params, error) {\n\tparams, err := config.BaseChat.params()\n\tif err != nil {\n\t\treturn params, err\n\t}\n\n\tparams.AddFirstValid(\"from_chat_id\", config.FromChatID, config.FromChannelUsername)\n\tparams.AddNonZero(\"message_id\", config.MessageID)\n\tparams.AddNonEmpty(\"caption\", config.Caption)\n\tparams.AddNonEmpty(\"parse_mode\", config.ParseMode)\n\terr = params.AddInterface(\"caption_entities\", config.CaptionEntities)\n\n\treturn params, err\n}\n\nfunc (config CopyMessageConfig) method() string {\n\treturn \"copyMessage\"\n}\n\n// PhotoConfig contains information about a SendPhoto request.\ntype PhotoConfig struct {\n\tBaseFile\n\tThumb           RequestFileData\n\tCaption         string\n\tParseMode       string\n\tCaptionEntities []MessageEntity\n}\n\nfunc (config PhotoConfig) params() (Params, error) {\n\tparams, err := config.BaseFile.params()\n\tif err != nil {\n\t\treturn params, err\n\t}\n\n\tparams.AddNonEmpty(\"caption\", config.Caption)\n\tparams.AddNonEmpty(\"parse_mode\", config.ParseMode)\n\terr = params.AddInterface(\"caption_entities\", config.CaptionEntities)\n\n\treturn params, err\n}\n\nfunc (config PhotoConfig) method() string {\n\treturn \"sendPhoto\"\n}\n\nfunc (config PhotoConfig) files() []RequestFile {\n\tfiles := []RequestFile{{\n\t\tName: \"photo\",\n\t\tData: config.File,\n\t}}\n\n\tif config.Thumb != nil {\n\t\tfiles = append(files, RequestFile{\n\t\t\tName: \"thumb\",\n\t\t\tData: config.Thumb,\n\t\t})\n\t}\n\n\treturn files\n}\n\n// AudioConfig contains information about a SendAudio request.\ntype AudioConfig struct {\n\tBaseFile\n\tThumb           RequestFileData\n\tCaption         string\n\tParseMode       string\n\tCaptionEntities []MessageEntity\n\tDuration        int\n\tPerformer       string\n\tTitle           string\n}\n\nfunc (config AudioConfig) params() (Params, error) {\n\tparams, err := config.BaseChat.params()\n\tif err != nil {\n\t\treturn params, err\n\t}\n\n\tparams.AddNonZero(\"duration\", config.Duration)\n\tparams.AddNonEmpty(\"performer\", config.Performer)\n\tparams.AddNonEmpty(\"title\", config.Title)\n\tparams.AddNonEmpty(\"caption\", config.Caption)\n\tparams.AddNonEmpty(\"parse_mode\", config.ParseMode)\n\terr = params.AddInterface(\"caption_entities\", config.CaptionEntities)\n\n\treturn params, err\n}\n\nfunc (config AudioConfig) method() string {\n\treturn \"sendAudio\"\n}\n\nfunc (config AudioConfig) files() []RequestFile {\n\tfiles := []RequestFile{{\n\t\tName: \"audio\",\n\t\tData: config.File,\n\t}}\n\n\tif config.Thumb != nil {\n\t\tfiles = append(files, RequestFile{\n\t\t\tName: \"thumb\",\n\t\t\tData: config.Thumb,\n\t\t})\n\t}\n\n\treturn files\n}\n\n// DocumentConfig contains information about a SendDocument request.\ntype DocumentConfig struct {\n\tBaseFile\n\tThumb                       RequestFileData\n\tCaption                     string\n\tParseMode                   string\n\tCaptionEntities             []MessageEntity\n\tDisableContentTypeDetection bool\n}\n\nfunc (config DocumentConfig) params() (Params, error) {\n\tparams, err := config.BaseFile.params()\n\n\tparams.AddNonEmpty(\"caption\", config.Caption)\n\tparams.AddNonEmpty(\"parse_mode\", config.ParseMode)\n\tparams.AddBool(\"disable_content_type_detection\", config.DisableContentTypeDetection)\n\n\treturn params, err\n}\n\nfunc (config DocumentConfig) method() string {\n\treturn \"sendDocument\"\n}\n\nfunc (config DocumentConfig) files() []RequestFile {\n\tfiles := []RequestFile{{\n\t\tName: \"document\",\n\t\tData: config.File,\n\t}}\n\n\tif config.Thumb != nil {\n\t\tfiles = append(files, RequestFile{\n\t\t\tName: \"thumb\",\n\t\t\tData: config.Thumb,\n\t\t})\n\t}\n\n\treturn files\n}\n\n// StickerConfig contains information about a SendSticker request.\ntype StickerConfig struct {\n\tBaseFile\n}\n\nfunc (config StickerConfig) params() (Params, error) {\n\treturn config.BaseChat.params()\n}\n\nfunc (config StickerConfig) method() string {\n\treturn \"sendSticker\"\n}\n\nfunc (config StickerConfig) files() []RequestFile {\n\treturn []RequestFile{{\n\t\tName: \"sticker\",\n\t\tData: config.File,\n\t}}\n}\n\n// VideoConfig contains information about a SendVideo request.\ntype VideoConfig struct {\n\tBaseFile\n\tThumb             RequestFileData\n\tDuration          int\n\tCaption           string\n\tParseMode         string\n\tCaptionEntities   []MessageEntity\n\tSupportsStreaming bool\n}\n\nfunc (config VideoConfig) params() (Params, error) {\n\tparams, err := config.BaseChat.params()\n\tif err != nil {\n\t\treturn params, err\n\t}\n\n\tparams.AddNonZero(\"duration\", config.Duration)\n\tparams.AddNonEmpty(\"caption\", config.Caption)\n\tparams.AddNonEmpty(\"parse_mode\", config.ParseMode)\n\tparams.AddBool(\"supports_streaming\", config.SupportsStreaming)\n\terr = params.AddInterface(\"caption_entities\", config.CaptionEntities)\n\n\treturn params, err\n}\n\nfunc (config VideoConfig) method() string {\n\treturn \"sendVideo\"\n}\n\nfunc (config VideoConfig) files() []RequestFile {\n\tfiles := []RequestFile{{\n\t\tName: \"video\",\n\t\tData: config.File,\n\t}}\n\n\tif config.Thumb != nil {\n\t\tfiles = append(files, RequestFile{\n\t\t\tName: \"thumb\",\n\t\t\tData: config.Thumb,\n\t\t})\n\t}\n\n\treturn files\n}\n\n// AnimationConfig contains information about a SendAnimation request.\ntype AnimationConfig struct {\n\tBaseFile\n\tDuration        int\n\tThumb           RequestFileData\n\tCaption         string\n\tParseMode       string\n\tCaptionEntities []MessageEntity\n}\n\nfunc (config AnimationConfig) params() (Params, error) {\n\tparams, err := config.BaseChat.params()\n\tif err != nil {\n\t\treturn params, err\n\t}\n\n\tparams.AddNonZero(\"duration\", config.Duration)\n\tparams.AddNonEmpty(\"caption\", config.Caption)\n\tparams.AddNonEmpty(\"parse_mode\", config.ParseMode)\n\terr = params.AddInterface(\"caption_entities\", config.CaptionEntities)\n\n\treturn params, err\n}\n\nfunc (config AnimationConfig) method() string {\n\treturn \"sendAnimation\"\n}\n\nfunc (config AnimationConfig) files() []RequestFile {\n\tfiles := []RequestFile{{\n\t\tName: \"animation\",\n\t\tData: config.File,\n\t}}\n\n\tif config.Thumb != nil {\n\t\tfiles = append(files, RequestFile{\n\t\t\tName: \"thumb\",\n\t\t\tData: config.Thumb,\n\t\t})\n\t}\n\n\treturn files\n}\n\n// VideoNoteConfig contains information about a SendVideoNote request.\ntype VideoNoteConfig struct {\n\tBaseFile\n\tThumb    RequestFileData\n\tDuration int\n\tLength   int\n}\n\nfunc (config VideoNoteConfig) params() (Params, error) {\n\tparams, err := config.BaseChat.params()\n\n\tparams.AddNonZero(\"duration\", config.Duration)\n\tparams.AddNonZero(\"length\", config.Length)\n\n\treturn params, err\n}\n\nfunc (config VideoNoteConfig) method() string {\n\treturn \"sendVideoNote\"\n}\n\nfunc (config VideoNoteConfig) files() []RequestFile {\n\tfiles := []RequestFile{{\n\t\tName: \"video_note\",\n\t\tData: config.File,\n\t}}\n\n\tif config.Thumb != nil {\n\t\tfiles = append(files, RequestFile{\n\t\t\tName: \"thumb\",\n\t\t\tData: config.Thumb,\n\t\t})\n\t}\n\n\treturn files\n}\n\n// VoiceConfig contains information about a SendVoice request.\ntype VoiceConfig struct {\n\tBaseFile\n\tThumb           RequestFileData\n\tCaption         string\n\tParseMode       string\n\tCaptionEntities []MessageEntity\n\tDuration        int\n}\n\nfunc (config VoiceConfig) params() (Params, error) {\n\tparams, err := config.BaseChat.params()\n\tif err != nil {\n\t\treturn params, err\n\t}\n\n\tparams.AddNonZero(\"duration\", config.Duration)\n\tparams.AddNonEmpty(\"caption\", config.Caption)\n\tparams.AddNonEmpty(\"parse_mode\", config.ParseMode)\n\terr = params.AddInterface(\"caption_entities\", config.CaptionEntities)\n\n\treturn params, err\n}\n\nfunc (config VoiceConfig) method() string {\n\treturn \"sendVoice\"\n}\n\nfunc (config VoiceConfig) files() []RequestFile {\n\tfiles := []RequestFile{{\n\t\tName: \"voice\",\n\t\tData: config.File,\n\t}}\n\n\tif config.Thumb != nil {\n\t\tfiles = append(files, RequestFile{\n\t\t\tName: \"thumb\",\n\t\t\tData: config.Thumb,\n\t\t})\n\t}\n\n\treturn files\n}\n\n// LocationConfig contains information about a SendLocation request.\ntype LocationConfig struct {\n\tBaseChat\n\tLatitude             float64 // required\n\tLongitude            float64 // required\n\tHorizontalAccuracy   float64 // optional\n\tLivePeriod           int     // optional\n\tHeading              int     // optional\n\tProximityAlertRadius int     // optional\n}\n\nfunc (config LocationConfig) params() (Params, error) {\n\tparams, err := config.BaseChat.params()\n\n\tparams.AddNonZeroFloat(\"latitude\", config.Latitude)\n\tparams.AddNonZeroFloat(\"longitude\", config.Longitude)\n\tparams.AddNonZeroFloat(\"horizontal_accuracy\", config.HorizontalAccuracy)\n\tparams.AddNonZero(\"live_period\", config.LivePeriod)\n\tparams.AddNonZero(\"heading\", config.Heading)\n\tparams.AddNonZero(\"proximity_alert_radius\", config.ProximityAlertRadius)\n\n\treturn params, err\n}\n\nfunc (config LocationConfig) method() string {\n\treturn \"sendLocation\"\n}\n\n// EditMessageLiveLocationConfig allows you to update a live location.\ntype EditMessageLiveLocationConfig struct {\n\tBaseEdit\n\tLatitude             float64 // required\n\tLongitude            float64 // required\n\tHorizontalAccuracy   float64 // optional\n\tHeading              int     // optional\n\tProximityAlertRadius int     // optional\n}\n\nfunc (config EditMessageLiveLocationConfig) params() (Params, error) {\n\tparams, err := config.BaseEdit.params()\n\n\tparams.AddNonZeroFloat(\"latitude\", config.Latitude)\n\tparams.AddNonZeroFloat(\"longitude\", config.Longitude)\n\tparams.AddNonZeroFloat(\"horizontal_accuracy\", config.HorizontalAccuracy)\n\tparams.AddNonZero(\"heading\", config.Heading)\n\tparams.AddNonZero(\"proximity_alert_radius\", config.ProximityAlertRadius)\n\n\treturn params, err\n}\n\nfunc (config EditMessageLiveLocationConfig) method() string {\n\treturn \"editMessageLiveLocation\"\n}\n\n// StopMessageLiveLocationConfig stops updating a live location.\ntype StopMessageLiveLocationConfig struct {\n\tBaseEdit\n}\n\nfunc (config StopMessageLiveLocationConfig) params() (Params, error) {\n\treturn config.BaseEdit.params()\n}\n\nfunc (config StopMessageLiveLocationConfig) method() string {\n\treturn \"stopMessageLiveLocation\"\n}\n\n// VenueConfig contains information about a SendVenue request.\ntype VenueConfig struct {\n\tBaseChat\n\tLatitude        float64 // required\n\tLongitude       float64 // required\n\tTitle           string  // required\n\tAddress         string  // required\n\tFoursquareID    string\n\tFoursquareType  string\n\tGooglePlaceID   string\n\tGooglePlaceType string\n}\n\nfunc (config VenueConfig) params() (Params, error) {\n\tparams, err := config.BaseChat.params()\n\n\tparams.AddNonZeroFloat(\"latitude\", config.Latitude)\n\tparams.AddNonZeroFloat(\"longitude\", config.Longitude)\n\tparams[\"title\"] = config.Title\n\tparams[\"address\"] = config.Address\n\tparams.AddNonEmpty(\"foursquare_id\", config.FoursquareID)\n\tparams.AddNonEmpty(\"foursquare_type\", config.FoursquareType)\n\tparams.AddNonEmpty(\"google_place_id\", config.GooglePlaceID)\n\tparams.AddNonEmpty(\"google_place_type\", config.GooglePlaceType)\n\n\treturn params, err\n}\n\nfunc (config VenueConfig) method() string {\n\treturn \"sendVenue\"\n}\n\n// ContactConfig allows you to send a contact.\ntype ContactConfig struct {\n\tBaseChat\n\tPhoneNumber string\n\tFirstName   string\n\tLastName    string\n\tVCard       string\n}\n\nfunc (config ContactConfig) params() (Params, error) {\n\tparams, err := config.BaseChat.params()\n\n\tparams[\"phone_number\"] = config.PhoneNumber\n\tparams[\"first_name\"] = config.FirstName\n\n\tparams.AddNonEmpty(\"last_name\", config.LastName)\n\tparams.AddNonEmpty(\"vcard\", config.VCard)\n\n\treturn params, err\n}\n\nfunc (config ContactConfig) method() string {\n\treturn \"sendContact\"\n}\n\n// SendPollConfig allows you to send a poll.\ntype SendPollConfig struct {\n\tBaseChat\n\tQuestion              string\n\tOptions               []string\n\tIsAnonymous           bool\n\tType                  string\n\tAllowsMultipleAnswers bool\n\tCorrectOptionID       int64\n\tExplanation           string\n\tExplanationParseMode  string\n\tExplanationEntities   []MessageEntity\n\tOpenPeriod            int\n\tCloseDate             int\n\tIsClosed              bool\n}\n\nfunc (config SendPollConfig) params() (Params, error) {\n\tparams, err := config.BaseChat.params()\n\tif err != nil {\n\t\treturn params, err\n\t}\n\n\tparams[\"question\"] = config.Question\n\tif err = params.AddInterface(\"options\", config.Options); err != nil {\n\t\treturn params, err\n\t}\n\tparams[\"is_anonymous\"] = strconv.FormatBool(config.IsAnonymous)\n\tparams.AddNonEmpty(\"type\", config.Type)\n\tparams[\"allows_multiple_answers\"] = strconv.FormatBool(config.AllowsMultipleAnswers)\n\tparams[\"correct_option_id\"] = strconv.FormatInt(config.CorrectOptionID, 10)\n\tparams.AddBool(\"is_closed\", config.IsClosed)\n\tparams.AddNonEmpty(\"explanation\", config.Explanation)\n\tparams.AddNonEmpty(\"explanation_parse_mode\", config.ExplanationParseMode)\n\tparams.AddNonZero(\"open_period\", config.OpenPeriod)\n\tparams.AddNonZero(\"close_date\", config.CloseDate)\n\terr = params.AddInterface(\"explanation_entities\", config.ExplanationEntities)\n\n\treturn params, err\n}\n\nfunc (SendPollConfig) method() string {\n\treturn \"sendPoll\"\n}\n\n// GameConfig allows you to send a game.\ntype GameConfig struct {\n\tBaseChat\n\tGameShortName string\n}\n\nfunc (config GameConfig) params() (Params, error) {\n\tparams, err := config.BaseChat.params()\n\n\tparams[\"game_short_name\"] = config.GameShortName\n\n\treturn params, err\n}\n\nfunc (config GameConfig) method() string {\n\treturn \"sendGame\"\n}\n\n// SetGameScoreConfig allows you to update the game score in a chat.\ntype SetGameScoreConfig struct {\n\tUserID             int64\n\tScore              int\n\tForce              bool\n\tDisableEditMessage bool\n\tChatID             int64\n\tChannelUsername    string\n\tMessageID          int\n\tInlineMessageID    string\n}\n\nfunc (config SetGameScoreConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddNonZero64(\"user_id\", config.UserID)\n\tparams.AddNonZero(\"scrore\", config.Score)\n\tparams.AddBool(\"disable_edit_message\", config.DisableEditMessage)\n\n\tif config.InlineMessageID != \"\" {\n\t\tparams[\"inline_message_id\"] = config.InlineMessageID\n\t} else {\n\t\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.ChannelUsername)\n\t\tparams.AddNonZero(\"message_id\", config.MessageID)\n\t}\n\n\treturn params, nil\n}\n\nfunc (config SetGameScoreConfig) method() string {\n\treturn \"setGameScore\"\n}\n\n// GetGameHighScoresConfig allows you to fetch the high scores for a game.\ntype GetGameHighScoresConfig struct {\n\tUserID          int64\n\tChatID          int64\n\tChannelUsername string\n\tMessageID       int\n\tInlineMessageID string\n}\n\nfunc (config GetGameHighScoresConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddNonZero64(\"user_id\", config.UserID)\n\n\tif config.InlineMessageID != \"\" {\n\t\tparams[\"inline_message_id\"] = config.InlineMessageID\n\t} else {\n\t\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.ChannelUsername)\n\t\tparams.AddNonZero(\"message_id\", config.MessageID)\n\t}\n\n\treturn params, nil\n}\n\nfunc (config GetGameHighScoresConfig) method() string {\n\treturn \"getGameHighScores\"\n}\n\n// ChatActionConfig contains information about a SendChatAction request.\ntype ChatActionConfig struct {\n\tBaseChat\n\tAction string // required\n}\n\nfunc (config ChatActionConfig) params() (Params, error) {\n\tparams, err := config.BaseChat.params()\n\n\tparams[\"action\"] = config.Action\n\n\treturn params, err\n}\n\nfunc (config ChatActionConfig) method() string {\n\treturn \"sendChatAction\"\n}\n\n// EditMessageTextConfig allows you to modify the text in a message.\ntype EditMessageTextConfig struct {\n\tBaseEdit\n\tText                  string\n\tParseMode             string\n\tEntities              []MessageEntity\n\tDisableWebPagePreview bool\n}\n\nfunc (config EditMessageTextConfig) params() (Params, error) {\n\tparams, err := config.BaseEdit.params()\n\tif err != nil {\n\t\treturn params, err\n\t}\n\n\tparams[\"text\"] = config.Text\n\tparams.AddNonEmpty(\"parse_mode\", config.ParseMode)\n\tparams.AddBool(\"disable_web_page_preview\", config.DisableWebPagePreview)\n\terr = params.AddInterface(\"entities\", config.Entities)\n\n\treturn params, err\n}\n\nfunc (config EditMessageTextConfig) method() string {\n\treturn \"editMessageText\"\n}\n\n// EditMessageCaptionConfig allows you to modify the caption of a message.\ntype EditMessageCaptionConfig struct {\n\tBaseEdit\n\tCaption         string\n\tParseMode       string\n\tCaptionEntities []MessageEntity\n}\n\nfunc (config EditMessageCaptionConfig) params() (Params, error) {\n\tparams, err := config.BaseEdit.params()\n\tif err != nil {\n\t\treturn params, err\n\t}\n\n\tparams[\"caption\"] = config.Caption\n\tparams.AddNonEmpty(\"parse_mode\", config.ParseMode)\n\terr = params.AddInterface(\"caption_entities\", config.CaptionEntities)\n\n\treturn params, err\n}\n\nfunc (config EditMessageCaptionConfig) method() string {\n\treturn \"editMessageCaption\"\n}\n\n// EditMessageMediaConfig allows you to make an editMessageMedia request.\ntype EditMessageMediaConfig struct {\n\tBaseEdit\n\n\tMedia interface{}\n}\n\nfunc (EditMessageMediaConfig) method() string {\n\treturn \"editMessageMedia\"\n}\n\nfunc (config EditMessageMediaConfig) params() (Params, error) {\n\tparams, err := config.BaseEdit.params()\n\tif err != nil {\n\t\treturn params, err\n\t}\n\n\terr = params.AddInterface(\"media\", prepareInputMediaParam(config.Media, 0))\n\n\treturn params, err\n}\n\nfunc (config EditMessageMediaConfig) files() []RequestFile {\n\treturn prepareInputMediaFile(config.Media, 0)\n}\n\n// EditMessageReplyMarkupConfig allows you to modify the reply markup\n// of a message.\ntype EditMessageReplyMarkupConfig struct {\n\tBaseEdit\n}\n\nfunc (config EditMessageReplyMarkupConfig) params() (Params, error) {\n\treturn config.BaseEdit.params()\n}\n\nfunc (config EditMessageReplyMarkupConfig) method() string {\n\treturn \"editMessageReplyMarkup\"\n}\n\n// StopPollConfig allows you to stop a poll sent by the bot.\ntype StopPollConfig struct {\n\tBaseEdit\n}\n\nfunc (config StopPollConfig) params() (Params, error) {\n\treturn config.BaseEdit.params()\n}\n\nfunc (StopPollConfig) method() string {\n\treturn \"stopPoll\"\n}\n\n// UserProfilePhotosConfig contains information about a\n// GetUserProfilePhotos request.\ntype UserProfilePhotosConfig struct {\n\tUserID int64\n\tOffset int\n\tLimit  int\n}\n\nfunc (UserProfilePhotosConfig) method() string {\n\treturn \"getUserProfilePhotos\"\n}\n\nfunc (config UserProfilePhotosConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddNonZero64(\"user_id\", config.UserID)\n\tparams.AddNonZero(\"offset\", config.Offset)\n\tparams.AddNonZero(\"limit\", config.Limit)\n\n\treturn params, nil\n}\n\n// FileConfig has information about a file hosted on Telegram.\ntype FileConfig struct {\n\tFileID string\n}\n\nfunc (FileConfig) method() string {\n\treturn \"getFile\"\n}\n\nfunc (config FileConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams[\"file_id\"] = config.FileID\n\n\treturn params, nil\n}\n\n// UpdateConfig contains information about a GetUpdates request.\ntype UpdateConfig struct {\n\tOffset         int\n\tLimit          int\n\tTimeout        int\n\tAllowedUpdates []string\n}\n\nfunc (UpdateConfig) method() string {\n\treturn \"getUpdates\"\n}\n\nfunc (config UpdateConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddNonZero(\"offset\", config.Offset)\n\tparams.AddNonZero(\"limit\", config.Limit)\n\tparams.AddNonZero(\"timeout\", config.Timeout)\n\tparams.AddInterface(\"allowed_updates\", config.AllowedUpdates)\n\n\treturn params, nil\n}\n\n// WebhookConfig contains information about a SetWebhook request.\ntype WebhookConfig struct {\n\tURL                *url.URL\n\tCertificate        RequestFileData\n\tIPAddress          string\n\tMaxConnections     int\n\tAllowedUpdates     []string\n\tDropPendingUpdates bool\n}\n\nfunc (config WebhookConfig) method() string {\n\treturn \"setWebhook\"\n}\n\nfunc (config WebhookConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tif config.URL != nil {\n\t\tparams[\"url\"] = config.URL.String()\n\t}\n\n\tparams.AddNonEmpty(\"ip_address\", config.IPAddress)\n\tparams.AddNonZero(\"max_connections\", config.MaxConnections)\n\terr := params.AddInterface(\"allowed_updates\", config.AllowedUpdates)\n\tparams.AddBool(\"drop_pending_updates\", config.DropPendingUpdates)\n\n\treturn params, err\n}\n\nfunc (config WebhookConfig) files() []RequestFile {\n\tif config.Certificate != nil {\n\t\treturn []RequestFile{{\n\t\t\tName: \"certificate\",\n\t\t\tData: config.Certificate,\n\t\t}}\n\t}\n\n\treturn nil\n}\n\n// DeleteWebhookConfig is a helper to delete a webhook.\ntype DeleteWebhookConfig struct {\n\tDropPendingUpdates bool\n}\n\nfunc (config DeleteWebhookConfig) method() string {\n\treturn \"deleteWebhook\"\n}\n\nfunc (config DeleteWebhookConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddBool(\"drop_pending_updates\", config.DropPendingUpdates)\n\n\treturn params, nil\n}\n\n// InlineConfig contains information on making an InlineQuery response.\ntype InlineConfig struct {\n\tInlineQueryID     string        `json:\"inline_query_id\"`\n\tResults           []interface{} `json:\"results\"`\n\tCacheTime         int           `json:\"cache_time\"`\n\tIsPersonal        bool          `json:\"is_personal\"`\n\tNextOffset        string        `json:\"next_offset\"`\n\tSwitchPMText      string        `json:\"switch_pm_text\"`\n\tSwitchPMParameter string        `json:\"switch_pm_parameter\"`\n}\n\nfunc (config InlineConfig) method() string {\n\treturn \"answerInlineQuery\"\n}\n\nfunc (config InlineConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams[\"inline_query_id\"] = config.InlineQueryID\n\tparams.AddNonZero(\"cache_time\", config.CacheTime)\n\tparams.AddBool(\"is_personal\", config.IsPersonal)\n\tparams.AddNonEmpty(\"next_offset\", config.NextOffset)\n\tparams.AddNonEmpty(\"switch_pm_text\", config.SwitchPMText)\n\tparams.AddNonEmpty(\"switch_pm_parameter\", config.SwitchPMParameter)\n\terr := params.AddInterface(\"results\", config.Results)\n\n\treturn params, err\n}\n\n// AnswerWebAppQueryConfig is used to set the result of an interaction with a\n// Web App and send a corresponding message on behalf of the user to the chat\n// from which the query originated.\ntype AnswerWebAppQueryConfig struct {\n\t// WebAppQueryID is the unique identifier for the query to be answered.\n\tWebAppQueryID string `json:\"web_app_query_id\"`\n\t// Result is an InlineQueryResult object describing the message to be sent.\n\tResult interface{} `json:\"result\"`\n}\n\nfunc (config AnswerWebAppQueryConfig) method() string {\n\treturn \"answerWebAppQuery\"\n}\n\nfunc (config AnswerWebAppQueryConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams[\"web_app_query_id\"] = config.WebAppQueryID\n\terr := params.AddInterface(\"result\", config.Result)\n\n\treturn params, err\n}\n\n// CallbackConfig contains information on making a CallbackQuery response.\ntype CallbackConfig struct {\n\tCallbackQueryID string `json:\"callback_query_id\"`\n\tText            string `json:\"text\"`\n\tShowAlert       bool   `json:\"show_alert\"`\n\tURL             string `json:\"url\"`\n\tCacheTime       int    `json:\"cache_time\"`\n}\n\nfunc (config CallbackConfig) method() string {\n\treturn \"answerCallbackQuery\"\n}\n\nfunc (config CallbackConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams[\"callback_query_id\"] = config.CallbackQueryID\n\tparams.AddNonEmpty(\"text\", config.Text)\n\tparams.AddBool(\"show_alert\", config.ShowAlert)\n\tparams.AddNonEmpty(\"url\", config.URL)\n\tparams.AddNonZero(\"cache_time\", config.CacheTime)\n\n\treturn params, nil\n}\n\n// ChatMemberConfig contains information about a user in a chat for use\n// with administrative functions such as kicking or unbanning a user.\ntype ChatMemberConfig struct {\n\tChatID             int64\n\tSuperGroupUsername string\n\tChannelUsername    string\n\tUserID             int64\n}\n\n// UnbanChatMemberConfig allows you to unban a user.\ntype UnbanChatMemberConfig struct {\n\tChatMemberConfig\n\tOnlyIfBanned bool\n}\n\nfunc (config UnbanChatMemberConfig) method() string {\n\treturn \"unbanChatMember\"\n}\n\nfunc (config UnbanChatMemberConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.SuperGroupUsername, config.ChannelUsername)\n\tparams.AddNonZero64(\"user_id\", config.UserID)\n\tparams.AddBool(\"only_if_banned\", config.OnlyIfBanned)\n\n\treturn params, nil\n}\n\n// BanChatMemberConfig contains extra fields to kick user.\ntype BanChatMemberConfig struct {\n\tChatMemberConfig\n\tUntilDate      int64\n\tRevokeMessages bool\n}\n\nfunc (config BanChatMemberConfig) method() string {\n\treturn \"banChatMember\"\n}\n\nfunc (config BanChatMemberConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.SuperGroupUsername)\n\tparams.AddNonZero64(\"user_id\", config.UserID)\n\tparams.AddNonZero64(\"until_date\", config.UntilDate)\n\tparams.AddBool(\"revoke_messages\", config.RevokeMessages)\n\n\treturn params, nil\n}\n\n// KickChatMemberConfig contains extra fields to ban user.\n//\n// This was renamed to BanChatMember in later versions of the Telegram Bot API.\ntype KickChatMemberConfig = BanChatMemberConfig\n\n// RestrictChatMemberConfig contains fields to restrict members of chat\ntype RestrictChatMemberConfig struct {\n\tChatMemberConfig\n\tUntilDate   int64\n\tPermissions *ChatPermissions\n}\n\nfunc (config RestrictChatMemberConfig) method() string {\n\treturn \"restrictChatMember\"\n}\n\nfunc (config RestrictChatMemberConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.SuperGroupUsername, config.ChannelUsername)\n\tparams.AddNonZero64(\"user_id\", config.UserID)\n\n\terr := params.AddInterface(\"permissions\", config.Permissions)\n\tparams.AddNonZero64(\"until_date\", config.UntilDate)\n\n\treturn params, err\n}\n\n// PromoteChatMemberConfig contains fields to promote members of chat\ntype PromoteChatMemberConfig struct {\n\tChatMemberConfig\n\tIsAnonymous         bool\n\tCanManageChat       bool\n\tCanChangeInfo       bool\n\tCanPostMessages     bool\n\tCanEditMessages     bool\n\tCanDeleteMessages   bool\n\tCanManageVideoChats bool\n\tCanInviteUsers      bool\n\tCanRestrictMembers  bool\n\tCanPinMessages      bool\n\tCanPromoteMembers   bool\n}\n\nfunc (config PromoteChatMemberConfig) method() string {\n\treturn \"promoteChatMember\"\n}\n\nfunc (config PromoteChatMemberConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.SuperGroupUsername, config.ChannelUsername)\n\tparams.AddNonZero64(\"user_id\", config.UserID)\n\n\tparams.AddBool(\"is_anonymous\", config.IsAnonymous)\n\tparams.AddBool(\"can_manage_chat\", config.CanManageChat)\n\tparams.AddBool(\"can_change_info\", config.CanChangeInfo)\n\tparams.AddBool(\"can_post_messages\", config.CanPostMessages)\n\tparams.AddBool(\"can_edit_messages\", config.CanEditMessages)\n\tparams.AddBool(\"can_delete_messages\", config.CanDeleteMessages)\n\tparams.AddBool(\"can_manage_video_chats\", config.CanManageVideoChats)\n\tparams.AddBool(\"can_invite_users\", config.CanInviteUsers)\n\tparams.AddBool(\"can_restrict_members\", config.CanRestrictMembers)\n\tparams.AddBool(\"can_pin_messages\", config.CanPinMessages)\n\tparams.AddBool(\"can_promote_members\", config.CanPromoteMembers)\n\n\treturn params, nil\n}\n\n// SetChatAdministratorCustomTitle sets the title of an administrative user\n// promoted by the bot for a chat.\ntype SetChatAdministratorCustomTitle struct {\n\tChatMemberConfig\n\tCustomTitle string\n}\n\nfunc (SetChatAdministratorCustomTitle) method() string {\n\treturn \"setChatAdministratorCustomTitle\"\n}\n\nfunc (config SetChatAdministratorCustomTitle) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.SuperGroupUsername, config.ChannelUsername)\n\tparams.AddNonZero64(\"user_id\", config.UserID)\n\tparams.AddNonEmpty(\"custom_title\", config.CustomTitle)\n\n\treturn params, nil\n}\n\n// BanChatSenderChatConfig bans a channel chat in a supergroup or a channel. The\n// owner of the chat will not be able to send messages and join live streams on\n// behalf of the chat, unless it is unbanned first. The bot must be an\n// administrator in the supergroup or channel for this to work and must have the\n// appropriate administrator rights.\ntype BanChatSenderChatConfig struct {\n\tChatID          int64\n\tChannelUsername string\n\tSenderChatID    int64\n\tUntilDate       int\n}\n\nfunc (config BanChatSenderChatConfig) method() string {\n\treturn \"banChatSenderChat\"\n}\n\nfunc (config BanChatSenderChatConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\t_ = params.AddFirstValid(\"chat_id\", config.ChatID, config.ChannelUsername)\n\tparams.AddNonZero64(\"sender_chat_id\", config.SenderChatID)\n\tparams.AddNonZero(\"until_date\", config.UntilDate)\n\n\treturn params, nil\n}\n\n// UnbanChatSenderChatConfig unbans a previously banned channel chat in a\n// supergroup or channel. The bot must be an administrator for this to work and\n// must have the appropriate administrator rights.\ntype UnbanChatSenderChatConfig struct {\n\tChatID          int64\n\tChannelUsername string\n\tSenderChatID    int64\n}\n\nfunc (config UnbanChatSenderChatConfig) method() string {\n\treturn \"unbanChatSenderChat\"\n}\n\nfunc (config UnbanChatSenderChatConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\t_ = params.AddFirstValid(\"chat_id\", config.ChatID, config.ChannelUsername)\n\tparams.AddNonZero64(\"sender_chat_id\", config.SenderChatID)\n\n\treturn params, nil\n}\n\n// ChatConfig contains information about getting information on a chat.\ntype ChatConfig struct {\n\tChatID             int64\n\tSuperGroupUsername string\n}\n\nfunc (config ChatConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.SuperGroupUsername)\n\n\treturn params, nil\n}\n\n// ChatInfoConfig contains information about getting chat information.\ntype ChatInfoConfig struct {\n\tChatConfig\n}\n\nfunc (ChatInfoConfig) method() string {\n\treturn \"getChat\"\n}\n\n// ChatMemberCountConfig contains information about getting the number of users in a chat.\ntype ChatMemberCountConfig struct {\n\tChatConfig\n}\n\nfunc (ChatMemberCountConfig) method() string {\n\treturn \"getChatMembersCount\"\n}\n\n// ChatAdministratorsConfig contains information about getting chat administrators.\ntype ChatAdministratorsConfig struct {\n\tChatConfig\n}\n\nfunc (ChatAdministratorsConfig) method() string {\n\treturn \"getChatAdministrators\"\n}\n\n// SetChatPermissionsConfig allows you to set default permissions for the\n// members in a group. The bot must be an administrator and have rights to\n// restrict members.\ntype SetChatPermissionsConfig struct {\n\tChatConfig\n\tPermissions *ChatPermissions\n}\n\nfunc (SetChatPermissionsConfig) method() string {\n\treturn \"setChatPermissions\"\n}\n\nfunc (config SetChatPermissionsConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.SuperGroupUsername)\n\terr := params.AddInterface(\"permissions\", config.Permissions)\n\n\treturn params, err\n}\n\n// ChatInviteLinkConfig contains information about getting a chat link.\n//\n// Note that generating a new link will revoke any previous links.\ntype ChatInviteLinkConfig struct {\n\tChatConfig\n}\n\nfunc (ChatInviteLinkConfig) method() string {\n\treturn \"exportChatInviteLink\"\n}\n\nfunc (config ChatInviteLinkConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.SuperGroupUsername)\n\n\treturn params, nil\n}\n\n// CreateChatInviteLinkConfig allows you to create an additional invite link for\n// a chat. The bot must be an administrator in the chat for this to work and\n// must have the appropriate admin rights. The link can be revoked using the\n// RevokeChatInviteLinkConfig.\ntype CreateChatInviteLinkConfig struct {\n\tChatConfig\n\tName               string\n\tExpireDate         int\n\tMemberLimit        int\n\tCreatesJoinRequest bool\n}\n\nfunc (CreateChatInviteLinkConfig) method() string {\n\treturn \"createChatInviteLink\"\n}\n\nfunc (config CreateChatInviteLinkConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddNonEmpty(\"name\", config.Name)\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.SuperGroupUsername)\n\tparams.AddNonZero(\"expire_date\", config.ExpireDate)\n\tparams.AddNonZero(\"member_limit\", config.MemberLimit)\n\tparams.AddBool(\"creates_join_request\", config.CreatesJoinRequest)\n\n\treturn params, nil\n}\n\n// EditChatInviteLinkConfig allows you to edit a non-primary invite link created\n// by the bot. The bot must be an administrator in the chat for this to work and\n// must have the appropriate admin rights.\ntype EditChatInviteLinkConfig struct {\n\tChatConfig\n\tInviteLink         string\n\tName               string\n\tExpireDate         int\n\tMemberLimit        int\n\tCreatesJoinRequest bool\n}\n\nfunc (EditChatInviteLinkConfig) method() string {\n\treturn \"editChatInviteLink\"\n}\n\nfunc (config EditChatInviteLinkConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.SuperGroupUsername)\n\tparams.AddNonEmpty(\"name\", config.Name)\n\tparams[\"invite_link\"] = config.InviteLink\n\tparams.AddNonZero(\"expire_date\", config.ExpireDate)\n\tparams.AddNonZero(\"member_limit\", config.MemberLimit)\n\tparams.AddBool(\"creates_join_request\", config.CreatesJoinRequest)\n\n\treturn params, nil\n}\n\n// RevokeChatInviteLinkConfig allows you to revoke an invite link created by the\n// bot. If the primary link is revoked, a new link is automatically generated.\n// The bot must be an administrator in the chat for this to work and must have\n// the appropriate admin rights.\ntype RevokeChatInviteLinkConfig struct {\n\tChatConfig\n\tInviteLink string\n}\n\nfunc (RevokeChatInviteLinkConfig) method() string {\n\treturn \"revokeChatInviteLink\"\n}\n\nfunc (config RevokeChatInviteLinkConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.SuperGroupUsername)\n\tparams[\"invite_link\"] = config.InviteLink\n\n\treturn params, nil\n}\n\n// ApproveChatJoinRequestConfig allows you to approve a chat join request.\ntype ApproveChatJoinRequestConfig struct {\n\tChatConfig\n\tUserID int64\n}\n\nfunc (ApproveChatJoinRequestConfig) method() string {\n\treturn \"approveChatJoinRequest\"\n}\n\nfunc (config ApproveChatJoinRequestConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.SuperGroupUsername)\n\tparams.AddNonZero(\"user_id\", int(config.UserID))\n\n\treturn params, nil\n}\n\n// DeclineChatJoinRequest allows you to decline a chat join request.\ntype DeclineChatJoinRequest struct {\n\tChatConfig\n\tUserID int64\n}\n\nfunc (DeclineChatJoinRequest) method() string {\n\treturn \"declineChatJoinRequest\"\n}\n\nfunc (config DeclineChatJoinRequest) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.SuperGroupUsername)\n\tparams.AddNonZero(\"user_id\", int(config.UserID))\n\n\treturn params, nil\n}\n\n// LeaveChatConfig allows you to leave a chat.\ntype LeaveChatConfig struct {\n\tChatID          int64\n\tChannelUsername string\n}\n\nfunc (config LeaveChatConfig) method() string {\n\treturn \"leaveChat\"\n}\n\nfunc (config LeaveChatConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.ChannelUsername)\n\n\treturn params, nil\n}\n\n// ChatConfigWithUser contains information about a chat and a user.\ntype ChatConfigWithUser struct {\n\tChatID             int64\n\tSuperGroupUsername string\n\tUserID             int64\n}\n\nfunc (config ChatConfigWithUser) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.SuperGroupUsername)\n\tparams.AddNonZero64(\"user_id\", config.UserID)\n\n\treturn params, nil\n}\n\n// GetChatMemberConfig is information about getting a specific member in a chat.\ntype GetChatMemberConfig struct {\n\tChatConfigWithUser\n}\n\nfunc (GetChatMemberConfig) method() string {\n\treturn \"getChatMember\"\n}\n\n// InvoiceConfig contains information for sendInvoice request.\ntype InvoiceConfig struct {\n\tBaseChat\n\tTitle                     string         // required\n\tDescription               string         // required\n\tPayload                   string         // required\n\tProviderToken             string         // required\n\tCurrency                  string         // required\n\tPrices                    []LabeledPrice // required\n\tMaxTipAmount              int\n\tSuggestedTipAmounts       []int\n\tStartParameter            string\n\tProviderData              string\n\tPhotoURL                  string\n\tPhotoSize                 int\n\tPhotoWidth                int\n\tPhotoHeight               int\n\tNeedName                  bool\n\tNeedPhoneNumber           bool\n\tNeedEmail                 bool\n\tNeedShippingAddress       bool\n\tSendPhoneNumberToProvider bool\n\tSendEmailToProvider       bool\n\tIsFlexible                bool\n}\n\nfunc (config InvoiceConfig) params() (Params, error) {\n\tparams, err := config.BaseChat.params()\n\tif err != nil {\n\t\treturn params, err\n\t}\n\n\tparams[\"title\"] = config.Title\n\tparams[\"description\"] = config.Description\n\tparams[\"payload\"] = config.Payload\n\tparams[\"provider_token\"] = config.ProviderToken\n\tparams[\"currency\"] = config.Currency\n\tif err = params.AddInterface(\"prices\", config.Prices); err != nil {\n\t\treturn params, err\n\t}\n\n\tparams.AddNonZero(\"max_tip_amount\", config.MaxTipAmount)\n\terr = params.AddInterface(\"suggested_tip_amounts\", config.SuggestedTipAmounts)\n\tparams.AddNonEmpty(\"start_parameter\", config.StartParameter)\n\tparams.AddNonEmpty(\"provider_data\", config.ProviderData)\n\tparams.AddNonEmpty(\"photo_url\", config.PhotoURL)\n\tparams.AddNonZero(\"photo_size\", config.PhotoSize)\n\tparams.AddNonZero(\"photo_width\", config.PhotoWidth)\n\tparams.AddNonZero(\"photo_height\", config.PhotoHeight)\n\tparams.AddBool(\"need_name\", config.NeedName)\n\tparams.AddBool(\"need_phone_number\", config.NeedPhoneNumber)\n\tparams.AddBool(\"need_email\", config.NeedEmail)\n\tparams.AddBool(\"need_shipping_address\", config.NeedShippingAddress)\n\tparams.AddBool(\"is_flexible\", config.IsFlexible)\n\tparams.AddBool(\"send_phone_number_to_provider\", config.SendPhoneNumberToProvider)\n\tparams.AddBool(\"send_email_to_provider\", config.SendEmailToProvider)\n\n\treturn params, err\n}\n\nfunc (config InvoiceConfig) method() string {\n\treturn \"sendInvoice\"\n}\n\n// ShippingConfig contains information for answerShippingQuery request.\ntype ShippingConfig struct {\n\tShippingQueryID string // required\n\tOK              bool   // required\n\tShippingOptions []ShippingOption\n\tErrorMessage    string\n}\n\nfunc (config ShippingConfig) method() string {\n\treturn \"answerShippingQuery\"\n}\n\nfunc (config ShippingConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams[\"shipping_query_id\"] = config.ShippingQueryID\n\tparams.AddBool(\"ok\", config.OK)\n\terr := params.AddInterface(\"shipping_options\", config.ShippingOptions)\n\tparams.AddNonEmpty(\"error_message\", config.ErrorMessage)\n\n\treturn params, err\n}\n\n// PreCheckoutConfig contains information for answerPreCheckoutQuery request.\ntype PreCheckoutConfig struct {\n\tPreCheckoutQueryID string // required\n\tOK                 bool   // required\n\tErrorMessage       string\n}\n\nfunc (config PreCheckoutConfig) method() string {\n\treturn \"answerPreCheckoutQuery\"\n}\n\nfunc (config PreCheckoutConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams[\"pre_checkout_query_id\"] = config.PreCheckoutQueryID\n\tparams.AddBool(\"ok\", config.OK)\n\tparams.AddNonEmpty(\"error_message\", config.ErrorMessage)\n\n\treturn params, nil\n}\n\n// DeleteMessageConfig contains information of a message in a chat to delete.\ntype DeleteMessageConfig struct {\n\tChannelUsername string\n\tChatID          int64\n\tMessageID       int\n}\n\nfunc (config DeleteMessageConfig) method() string {\n\treturn \"deleteMessage\"\n}\n\nfunc (config DeleteMessageConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.ChannelUsername)\n\tparams.AddNonZero(\"message_id\", config.MessageID)\n\n\treturn params, nil\n}\n\n// PinChatMessageConfig contains information of a message in a chat to pin.\ntype PinChatMessageConfig struct {\n\tChatID              int64\n\tChannelUsername     string\n\tMessageID           int\n\tDisableNotification bool\n}\n\nfunc (config PinChatMessageConfig) method() string {\n\treturn \"pinChatMessage\"\n}\n\nfunc (config PinChatMessageConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.ChannelUsername)\n\tparams.AddNonZero(\"message_id\", config.MessageID)\n\tparams.AddBool(\"disable_notification\", config.DisableNotification)\n\n\treturn params, nil\n}\n\n// UnpinChatMessageConfig contains information of a chat message to unpin.\n//\n// If MessageID is not specified, it will unpin the most recent pin.\ntype UnpinChatMessageConfig struct {\n\tChatID          int64\n\tChannelUsername string\n\tMessageID       int\n}\n\nfunc (config UnpinChatMessageConfig) method() string {\n\treturn \"unpinChatMessage\"\n}\n\nfunc (config UnpinChatMessageConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.ChannelUsername)\n\tparams.AddNonZero(\"message_id\", config.MessageID)\n\n\treturn params, nil\n}\n\n// UnpinAllChatMessagesConfig contains information of all messages to unpin in\n// a chat.\ntype UnpinAllChatMessagesConfig struct {\n\tChatID          int64\n\tChannelUsername string\n}\n\nfunc (config UnpinAllChatMessagesConfig) method() string {\n\treturn \"unpinAllChatMessages\"\n}\n\nfunc (config UnpinAllChatMessagesConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.ChannelUsername)\n\n\treturn params, nil\n}\n\n// SetChatPhotoConfig allows you to set a group, supergroup, or channel's photo.\ntype SetChatPhotoConfig struct {\n\tBaseFile\n}\n\nfunc (config SetChatPhotoConfig) method() string {\n\treturn \"setChatPhoto\"\n}\n\nfunc (config SetChatPhotoConfig) files() []RequestFile {\n\treturn []RequestFile{{\n\t\tName: \"photo\",\n\t\tData: config.File,\n\t}}\n}\n\n// DeleteChatPhotoConfig allows you to delete a group, supergroup, or channel's photo.\ntype DeleteChatPhotoConfig struct {\n\tChatID          int64\n\tChannelUsername string\n}\n\nfunc (config DeleteChatPhotoConfig) method() string {\n\treturn \"deleteChatPhoto\"\n}\n\nfunc (config DeleteChatPhotoConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.ChannelUsername)\n\n\treturn params, nil\n}\n\n// SetChatTitleConfig allows you to set the title of something other than a private chat.\ntype SetChatTitleConfig struct {\n\tChatID          int64\n\tChannelUsername string\n\n\tTitle string\n}\n\nfunc (config SetChatTitleConfig) method() string {\n\treturn \"setChatTitle\"\n}\n\nfunc (config SetChatTitleConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.ChannelUsername)\n\tparams[\"title\"] = config.Title\n\n\treturn params, nil\n}\n\n// SetChatDescriptionConfig allows you to set the description of a supergroup or channel.\ntype SetChatDescriptionConfig struct {\n\tChatID          int64\n\tChannelUsername string\n\n\tDescription string\n}\n\nfunc (config SetChatDescriptionConfig) method() string {\n\treturn \"setChatDescription\"\n}\n\nfunc (config SetChatDescriptionConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.ChannelUsername)\n\tparams[\"description\"] = config.Description\n\n\treturn params, nil\n}\n\n// GetStickerSetConfig allows you to get the stickers in a set.\ntype GetStickerSetConfig struct {\n\tName string\n}\n\nfunc (config GetStickerSetConfig) method() string {\n\treturn \"getStickerSet\"\n}\n\nfunc (config GetStickerSetConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams[\"name\"] = config.Name\n\n\treturn params, nil\n}\n\n// UploadStickerConfig allows you to upload a sticker for use in a set later.\ntype UploadStickerConfig struct {\n\tUserID     int64\n\tPNGSticker RequestFileData\n}\n\nfunc (config UploadStickerConfig) method() string {\n\treturn \"uploadStickerFile\"\n}\n\nfunc (config UploadStickerConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddNonZero64(\"user_id\", config.UserID)\n\n\treturn params, nil\n}\n\nfunc (config UploadStickerConfig) files() []RequestFile {\n\treturn []RequestFile{{\n\t\tName: \"png_sticker\",\n\t\tData: config.PNGSticker,\n\t}}\n}\n\n// NewStickerSetConfig allows creating a new sticker set.\n//\n// You must set either PNGSticker or TGSSticker.\ntype NewStickerSetConfig struct {\n\tUserID        int64\n\tName          string\n\tTitle         string\n\tPNGSticker    RequestFileData\n\tTGSSticker    RequestFileData\n\tEmojis        string\n\tContainsMasks bool\n\tMaskPosition  *MaskPosition\n}\n\nfunc (config NewStickerSetConfig) method() string {\n\treturn \"createNewStickerSet\"\n}\n\nfunc (config NewStickerSetConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddNonZero64(\"user_id\", config.UserID)\n\tparams[\"name\"] = config.Name\n\tparams[\"title\"] = config.Title\n\n\tparams[\"emojis\"] = config.Emojis\n\n\tparams.AddBool(\"contains_masks\", config.ContainsMasks)\n\n\terr := params.AddInterface(\"mask_position\", config.MaskPosition)\n\n\treturn params, err\n}\n\nfunc (config NewStickerSetConfig) files() []RequestFile {\n\tif config.PNGSticker != nil {\n\t\treturn []RequestFile{{\n\t\t\tName: \"png_sticker\",\n\t\t\tData: config.PNGSticker,\n\t\t}}\n\t}\n\n\treturn []RequestFile{{\n\t\tName: \"tgs_sticker\",\n\t\tData: config.TGSSticker,\n\t}}\n}\n\n// AddStickerConfig allows you to add a sticker to a set.\ntype AddStickerConfig struct {\n\tUserID       int64\n\tName         string\n\tPNGSticker   RequestFileData\n\tTGSSticker   RequestFileData\n\tEmojis       string\n\tMaskPosition *MaskPosition\n}\n\nfunc (config AddStickerConfig) method() string {\n\treturn \"addStickerToSet\"\n}\n\nfunc (config AddStickerConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddNonZero64(\"user_id\", config.UserID)\n\tparams[\"name\"] = config.Name\n\tparams[\"emojis\"] = config.Emojis\n\n\terr := params.AddInterface(\"mask_position\", config.MaskPosition)\n\n\treturn params, err\n}\n\nfunc (config AddStickerConfig) files() []RequestFile {\n\tif config.PNGSticker != nil {\n\t\treturn []RequestFile{{\n\t\t\tName: \"png_sticker\",\n\t\t\tData: config.PNGSticker,\n\t\t}}\n\t}\n\n\treturn []RequestFile{{\n\t\tName: \"tgs_sticker\",\n\t\tData: config.TGSSticker,\n\t}}\n\n}\n\n// SetStickerPositionConfig allows you to change the position of a sticker in a set.\ntype SetStickerPositionConfig struct {\n\tSticker  string\n\tPosition int\n}\n\nfunc (config SetStickerPositionConfig) method() string {\n\treturn \"setStickerPositionInSet\"\n}\n\nfunc (config SetStickerPositionConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams[\"sticker\"] = config.Sticker\n\tparams.AddNonZero(\"position\", config.Position)\n\n\treturn params, nil\n}\n\n// DeleteStickerConfig allows you to delete a sticker from a set.\ntype DeleteStickerConfig struct {\n\tSticker string\n}\n\nfunc (config DeleteStickerConfig) method() string {\n\treturn \"deleteStickerFromSet\"\n}\n\nfunc (config DeleteStickerConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams[\"sticker\"] = config.Sticker\n\n\treturn params, nil\n}\n\n// SetStickerSetThumbConfig allows you to set the thumbnail for a sticker set.\ntype SetStickerSetThumbConfig struct {\n\tName   string\n\tUserID int64\n\tThumb  RequestFileData\n}\n\nfunc (config SetStickerSetThumbConfig) method() string {\n\treturn \"setStickerSetThumb\"\n}\n\nfunc (config SetStickerSetThumbConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams[\"name\"] = config.Name\n\tparams.AddNonZero64(\"user_id\", config.UserID)\n\n\treturn params, nil\n}\n\nfunc (config SetStickerSetThumbConfig) files() []RequestFile {\n\treturn []RequestFile{{\n\t\tName: \"thumb\",\n\t\tData: config.Thumb,\n\t}}\n}\n\n// SetChatStickerSetConfig allows you to set the sticker set for a supergroup.\ntype SetChatStickerSetConfig struct {\n\tChatID             int64\n\tSuperGroupUsername string\n\n\tStickerSetName string\n}\n\nfunc (config SetChatStickerSetConfig) method() string {\n\treturn \"setChatStickerSet\"\n}\n\nfunc (config SetChatStickerSetConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.SuperGroupUsername)\n\tparams[\"sticker_set_name\"] = config.StickerSetName\n\n\treturn params, nil\n}\n\n// DeleteChatStickerSetConfig allows you to remove a supergroup's sticker set.\ntype DeleteChatStickerSetConfig struct {\n\tChatID             int64\n\tSuperGroupUsername string\n}\n\nfunc (config DeleteChatStickerSetConfig) method() string {\n\treturn \"deleteChatStickerSet\"\n}\n\nfunc (config DeleteChatStickerSetConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.SuperGroupUsername)\n\n\treturn params, nil\n}\n\n// MediaGroupConfig allows you to send a group of media.\n//\n// Media consist of InputMedia items (InputMediaPhoto, InputMediaVideo).\ntype MediaGroupConfig struct {\n\tChatID          int64\n\tChannelUsername string\n\n\tMedia               []interface{}\n\tDisableNotification bool\n\tReplyToMessageID    int\n}\n\nfunc (config MediaGroupConfig) method() string {\n\treturn \"sendMediaGroup\"\n}\n\nfunc (config MediaGroupConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddFirstValid(\"chat_id\", config.ChatID, config.ChannelUsername)\n\tparams.AddBool(\"disable_notification\", config.DisableNotification)\n\tparams.AddNonZero(\"reply_to_message_id\", config.ReplyToMessageID)\n\n\terr := params.AddInterface(\"media\", prepareInputMediaForParams(config.Media))\n\n\treturn params, err\n}\n\nfunc (config MediaGroupConfig) files() []RequestFile {\n\treturn prepareInputMediaForFiles(config.Media)\n}\n\n// DiceConfig contains information about a sendDice request.\ntype DiceConfig struct {\n\tBaseChat\n\t// Emoji on which the dice throw animation is based.\n\t// Currently, must be one of 🎲, 🎯, 🏀, ⚽, 🎳, or 🎰.\n\t// Dice can have values 1-6 for 🎲, 🎯, and 🎳, values 1-5 for 🏀 and ⚽,\n\t// and values 1-64 for 🎰.\n\t// Defaults to “🎲”\n\tEmoji string\n}\n\nfunc (config DiceConfig) method() string {\n\treturn \"sendDice\"\n}\n\nfunc (config DiceConfig) params() (Params, error) {\n\tparams, err := config.BaseChat.params()\n\tif err != nil {\n\t\treturn params, err\n\t}\n\n\tparams.AddNonEmpty(\"emoji\", config.Emoji)\n\n\treturn params, err\n}\n\n// GetMyCommandsConfig gets a list of the currently registered commands.\ntype GetMyCommandsConfig struct {\n\tScope        *BotCommandScope\n\tLanguageCode string\n}\n\nfunc (config GetMyCommandsConfig) method() string {\n\treturn \"getMyCommands\"\n}\n\nfunc (config GetMyCommandsConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\terr := params.AddInterface(\"scope\", config.Scope)\n\tparams.AddNonEmpty(\"language_code\", config.LanguageCode)\n\n\treturn params, err\n}\n\n// SetMyCommandsConfig sets a list of commands the bot understands.\ntype SetMyCommandsConfig struct {\n\tCommands     []BotCommand\n\tScope        *BotCommandScope\n\tLanguageCode string\n}\n\nfunc (config SetMyCommandsConfig) method() string {\n\treturn \"setMyCommands\"\n}\n\nfunc (config SetMyCommandsConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tif err := params.AddInterface(\"commands\", config.Commands); err != nil {\n\t\treturn params, err\n\t}\n\terr := params.AddInterface(\"scope\", config.Scope)\n\tparams.AddNonEmpty(\"language_code\", config.LanguageCode)\n\n\treturn params, err\n}\n\ntype DeleteMyCommandsConfig struct {\n\tScope        *BotCommandScope\n\tLanguageCode string\n}\n\nfunc (config DeleteMyCommandsConfig) method() string {\n\treturn \"deleteMyCommands\"\n}\n\nfunc (config DeleteMyCommandsConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\terr := params.AddInterface(\"scope\", config.Scope)\n\tparams.AddNonEmpty(\"language_code\", config.LanguageCode)\n\n\treturn params, err\n}\n\n// SetChatMenuButtonConfig changes the bot's menu button in a private chat,\n// or the default menu button.\ntype SetChatMenuButtonConfig struct {\n\tChatID          int64\n\tChannelUsername string\n\n\tMenuButton *MenuButton\n}\n\nfunc (config SetChatMenuButtonConfig) method() string {\n\treturn \"setChatMenuButton\"\n}\n\nfunc (config SetChatMenuButtonConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tif err := params.AddFirstValid(\"chat_id\", config.ChatID, config.ChannelUsername); err != nil {\n\t\treturn params, err\n\t}\n\terr := params.AddInterface(\"menu_button\", config.MenuButton)\n\n\treturn params, err\n}\n\ntype GetChatMenuButtonConfig struct {\n\tChatID          int64\n\tChannelUsername string\n}\n\nfunc (config GetChatMenuButtonConfig) method() string {\n\treturn \"getChatMenuButton\"\n}\n\nfunc (config GetChatMenuButtonConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\terr := params.AddFirstValid(\"chat_id\", config.ChatID, config.ChannelUsername)\n\n\treturn params, err\n}\n\ntype SetMyDefaultAdministratorRightsConfig struct {\n\tRights      ChatAdministratorRights\n\tForChannels bool\n}\n\nfunc (config SetMyDefaultAdministratorRightsConfig) method() string {\n\treturn \"setMyDefaultAdministratorRights\"\n}\n\nfunc (config SetMyDefaultAdministratorRightsConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\terr := params.AddInterface(\"rights\", config.Rights)\n\tparams.AddBool(\"for_channels\", config.ForChannels)\n\n\treturn params, err\n}\n\ntype GetMyDefaultAdministratorRightsConfig struct {\n\tForChannels bool\n}\n\nfunc (config GetMyDefaultAdministratorRightsConfig) method() string {\n\treturn \"getMyDefaultAdministratorRights\"\n}\n\nfunc (config GetMyDefaultAdministratorRightsConfig) params() (Params, error) {\n\tparams := make(Params)\n\n\tparams.AddBool(\"for_channels\", config.ForChannels)\n\n\treturn params, nil\n}\n\n// prepareInputMediaParam evaluates a single InputMedia and determines if it\n// needs to be modified for a successful upload. If it returns nil, then the\n// value does not need to be included in the params. Otherwise, it will return\n// the same type as was originally provided.\n//\n// The idx is used to calculate the file field name. If you only have a single\n// file, 0 may be used. It is formatted into \"attach://file-%d\" for the primary\n// media and \"attach://file-%d-thumb\" for thumbnails.\n//\n// It is expected to be used in conjunction with prepareInputMediaFile.\nfunc prepareInputMediaParam(inputMedia interface{}, idx int) interface{} {\n\tswitch m := inputMedia.(type) {\n\tcase InputMediaPhoto:\n\t\tif m.Media.NeedsUpload() {\n\t\t\tm.Media = fileAttach(fmt.Sprintf(\"attach://file-%d\", idx))\n\t\t}\n\n\t\treturn m\n\tcase InputMediaVideo:\n\t\tif m.Media.NeedsUpload() {\n\t\t\tm.Media = fileAttach(fmt.Sprintf(\"attach://file-%d\", idx))\n\t\t}\n\n\t\tif m.Thumb != nil && m.Thumb.NeedsUpload() {\n\t\t\tm.Thumb = fileAttach(fmt.Sprintf(\"attach://file-%d-thumb\", idx))\n\t\t}\n\n\t\treturn m\n\tcase InputMediaAudio:\n\t\tif m.Media.NeedsUpload() {\n\t\t\tm.Media = fileAttach(fmt.Sprintf(\"attach://file-%d\", idx))\n\t\t}\n\n\t\tif m.Thumb != nil && m.Thumb.NeedsUpload() {\n\t\t\tm.Thumb = fileAttach(fmt.Sprintf(\"attach://file-%d-thumb\", idx))\n\t\t}\n\n\t\treturn m\n\tcase InputMediaDocument:\n\t\tif m.Media.NeedsUpload() {\n\t\t\tm.Media = fileAttach(fmt.Sprintf(\"attach://file-%d\", idx))\n\t\t}\n\n\t\tif m.Thumb != nil && m.Thumb.NeedsUpload() {\n\t\t\tm.Thumb = fileAttach(fmt.Sprintf(\"attach://file-%d-thumb\", idx))\n\t\t}\n\n\t\treturn m\n\t}\n\n\treturn nil\n}\n\n// prepareInputMediaFile generates an array of RequestFile to provide for\n// Fileable's files method. It returns an array as a single InputMedia may have\n// multiple files, for the primary media and a thumbnail.\n//\n// The idx parameter is used to generate file field names. It uses the names\n// \"file-%d\" for the main file and \"file-%d-thumb\" for the thumbnail.\n//\n// It is expected to be used in conjunction with prepareInputMediaParam.\nfunc prepareInputMediaFile(inputMedia interface{}, idx int) []RequestFile {\n\tfiles := []RequestFile{}\n\n\tswitch m := inputMedia.(type) {\n\tcase InputMediaPhoto:\n\t\tif m.Media.NeedsUpload() {\n\t\t\tfiles = append(files, RequestFile{\n\t\t\t\tName: fmt.Sprintf(\"file-%d\", idx),\n\t\t\t\tData: m.Media,\n\t\t\t})\n\t\t}\n\tcase InputMediaVideo:\n\t\tif m.Media.NeedsUpload() {\n\t\t\tfiles = append(files, RequestFile{\n\t\t\t\tName: fmt.Sprintf(\"file-%d\", idx),\n\t\t\t\tData: m.Media,\n\t\t\t})\n\t\t}\n\n\t\tif m.Thumb != nil && m.Thumb.NeedsUpload() {\n\t\t\tfiles = append(files, RequestFile{\n\t\t\t\tName: fmt.Sprintf(\"file-%d\", idx),\n\t\t\t\tData: m.Thumb,\n\t\t\t})\n\t\t}\n\tcase InputMediaDocument:\n\t\tif m.Media.NeedsUpload() {\n\t\t\tfiles = append(files, RequestFile{\n\t\t\t\tName: fmt.Sprintf(\"file-%d\", idx),\n\t\t\t\tData: m.Media,\n\t\t\t})\n\t\t}\n\n\t\tif m.Thumb != nil && m.Thumb.NeedsUpload() {\n\t\t\tfiles = append(files, RequestFile{\n\t\t\t\tName: fmt.Sprintf(\"file-%d\", idx),\n\t\t\t\tData: m.Thumb,\n\t\t\t})\n\t\t}\n\tcase InputMediaAudio:\n\t\tif m.Media.NeedsUpload() {\n\t\t\tfiles = append(files, RequestFile{\n\t\t\t\tName: fmt.Sprintf(\"file-%d\", idx),\n\t\t\t\tData: m.Media,\n\t\t\t})\n\t\t}\n\n\t\tif m.Thumb != nil && m.Thumb.NeedsUpload() {\n\t\t\tfiles = append(files, RequestFile{\n\t\t\t\tName: fmt.Sprintf(\"file-%d\", idx),\n\t\t\t\tData: m.Thumb,\n\t\t\t})\n\t\t}\n\t}\n\n\treturn files\n}\n\n// prepareInputMediaForParams calls prepareInputMediaParam for each item\n// provided and returns a new array with the correct params for a request.\n//\n// It is expected that files will get data from the associated function,\n// prepareInputMediaForFiles.\nfunc prepareInputMediaForParams(inputMedia []interface{}) []interface{} {\n\tnewMedia := make([]interface{}, len(inputMedia))\n\tcopy(newMedia, inputMedia)\n\n\tfor idx, media := range inputMedia {\n\t\tif param := prepareInputMediaParam(media, idx); param != nil {\n\t\t\tnewMedia[idx] = param\n\t\t}\n\t}\n\n\treturn newMedia\n}\n\n// prepareInputMediaForFiles calls prepareInputMediaFile for each item\n// provided and returns a new array with the correct files for a request.\n//\n// It is expected that params will get data from the associated function,\n// prepareInputMediaForParams.\nfunc prepareInputMediaForFiles(inputMedia []interface{}) []RequestFile {\n\tfiles := []RequestFile{}\n\n\tfor idx, media := range inputMedia {\n\t\tif file := prepareInputMediaFile(media, idx); file != nil {\n\t\t\tfiles = append(files, file...)\n\t\t}\n\t}\n\n\treturn files\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0654296875,
          "content": "module github.com/go-telegram-bot-api/telegram-bot-api/v5\n\ngo 1.16\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "helpers.go",
          "type": "blob",
          "size": 26.3076171875,
          "content": "package tgbotapi\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// NewMessage creates a new Message.\n//\n// chatID is where to send it, text is the message text.\nfunc NewMessage(chatID int64, text string) MessageConfig {\n\treturn MessageConfig{\n\t\tBaseChat: BaseChat{\n\t\t\tChatID:           chatID,\n\t\t\tReplyToMessageID: 0,\n\t\t},\n\t\tText:                  text,\n\t\tDisableWebPagePreview: false,\n\t}\n}\n\n// NewDeleteMessage creates a request to delete a message.\nfunc NewDeleteMessage(chatID int64, messageID int) DeleteMessageConfig {\n\treturn DeleteMessageConfig{\n\t\tChatID:    chatID,\n\t\tMessageID: messageID,\n\t}\n}\n\n// NewMessageToChannel creates a new Message that is sent to a channel\n// by username.\n//\n// username is the username of the channel, text is the message text,\n// and the username should be in the form of `@username`.\nfunc NewMessageToChannel(username string, text string) MessageConfig {\n\treturn MessageConfig{\n\t\tBaseChat: BaseChat{\n\t\t\tChannelUsername: username,\n\t\t},\n\t\tText: text,\n\t}\n}\n\n// NewForward creates a new forward.\n//\n// chatID is where to send it, fromChatID is the source chat,\n// and messageID is the ID of the original message.\nfunc NewForward(chatID int64, fromChatID int64, messageID int) ForwardConfig {\n\treturn ForwardConfig{\n\t\tBaseChat:   BaseChat{ChatID: chatID},\n\t\tFromChatID: fromChatID,\n\t\tMessageID:  messageID,\n\t}\n}\n\n// NewCopyMessage creates a new copy message.\n//\n// chatID is where to send it, fromChatID is the source chat,\n// and messageID is the ID of the original message.\nfunc NewCopyMessage(chatID int64, fromChatID int64, messageID int) CopyMessageConfig {\n\treturn CopyMessageConfig{\n\t\tBaseChat:   BaseChat{ChatID: chatID},\n\t\tFromChatID: fromChatID,\n\t\tMessageID:  messageID,\n\t}\n}\n\n// NewPhoto creates a new sendPhoto request.\n//\n// chatID is where to send it, file is a string path to the file,\n// FileReader, or FileBytes.\n//\n// Note that you must send animated GIFs as a document.\nfunc NewPhoto(chatID int64, file RequestFileData) PhotoConfig {\n\treturn PhotoConfig{\n\t\tBaseFile: BaseFile{\n\t\t\tBaseChat: BaseChat{ChatID: chatID},\n\t\t\tFile:     file,\n\t\t},\n\t}\n}\n\n// NewPhotoToChannel creates a new photo uploader to send a photo to a channel.\n//\n// Note that you must send animated GIFs as a document.\nfunc NewPhotoToChannel(username string, file RequestFileData) PhotoConfig {\n\treturn PhotoConfig{\n\t\tBaseFile: BaseFile{\n\t\t\tBaseChat: BaseChat{\n\t\t\t\tChannelUsername: username,\n\t\t\t},\n\t\t\tFile: file,\n\t\t},\n\t}\n}\n\n// NewAudio creates a new sendAudio request.\nfunc NewAudio(chatID int64, file RequestFileData) AudioConfig {\n\treturn AudioConfig{\n\t\tBaseFile: BaseFile{\n\t\t\tBaseChat: BaseChat{ChatID: chatID},\n\t\t\tFile:     file,\n\t\t},\n\t}\n}\n\n// NewDocument creates a new sendDocument request.\nfunc NewDocument(chatID int64, file RequestFileData) DocumentConfig {\n\treturn DocumentConfig{\n\t\tBaseFile: BaseFile{\n\t\t\tBaseChat: BaseChat{ChatID: chatID},\n\t\t\tFile:     file,\n\t\t},\n\t}\n}\n\n// NewSticker creates a new sendSticker request.\nfunc NewSticker(chatID int64, file RequestFileData) StickerConfig {\n\treturn StickerConfig{\n\t\tBaseFile: BaseFile{\n\t\t\tBaseChat: BaseChat{ChatID: chatID},\n\t\t\tFile:     file,\n\t\t},\n\t}\n}\n\n// NewVideo creates a new sendVideo request.\nfunc NewVideo(chatID int64, file RequestFileData) VideoConfig {\n\treturn VideoConfig{\n\t\tBaseFile: BaseFile{\n\t\t\tBaseChat: BaseChat{ChatID: chatID},\n\t\t\tFile:     file,\n\t\t},\n\t}\n}\n\n// NewAnimation creates a new sendAnimation request.\nfunc NewAnimation(chatID int64, file RequestFileData) AnimationConfig {\n\treturn AnimationConfig{\n\t\tBaseFile: BaseFile{\n\t\t\tBaseChat: BaseChat{ChatID: chatID},\n\t\t\tFile:     file,\n\t\t},\n\t}\n}\n\n// NewVideoNote creates a new sendVideoNote request.\n//\n// chatID is where to send it, file is a string path to the file,\n// FileReader, or FileBytes.\nfunc NewVideoNote(chatID int64, length int, file RequestFileData) VideoNoteConfig {\n\treturn VideoNoteConfig{\n\t\tBaseFile: BaseFile{\n\t\t\tBaseChat: BaseChat{ChatID: chatID},\n\t\t\tFile:     file,\n\t\t},\n\t\tLength: length,\n\t}\n}\n\n// NewVoice creates a new sendVoice request.\nfunc NewVoice(chatID int64, file RequestFileData) VoiceConfig {\n\treturn VoiceConfig{\n\t\tBaseFile: BaseFile{\n\t\t\tBaseChat: BaseChat{ChatID: chatID},\n\t\t\tFile:     file,\n\t\t},\n\t}\n}\n\n// NewMediaGroup creates a new media group. Files should be an array of\n// two to ten InputMediaPhoto or InputMediaVideo.\nfunc NewMediaGroup(chatID int64, files []interface{}) MediaGroupConfig {\n\treturn MediaGroupConfig{\n\t\tChatID: chatID,\n\t\tMedia:  files,\n\t}\n}\n\n// NewInputMediaPhoto creates a new InputMediaPhoto.\nfunc NewInputMediaPhoto(media RequestFileData) InputMediaPhoto {\n\treturn InputMediaPhoto{\n\t\tBaseInputMedia{\n\t\t\tType:  \"photo\",\n\t\t\tMedia: media,\n\t\t},\n\t}\n}\n\n// NewInputMediaVideo creates a new InputMediaVideo.\nfunc NewInputMediaVideo(media RequestFileData) InputMediaVideo {\n\treturn InputMediaVideo{\n\t\tBaseInputMedia: BaseInputMedia{\n\t\t\tType:  \"video\",\n\t\t\tMedia: media,\n\t\t},\n\t}\n}\n\n// NewInputMediaAnimation creates a new InputMediaAnimation.\nfunc NewInputMediaAnimation(media RequestFileData) InputMediaAnimation {\n\treturn InputMediaAnimation{\n\t\tBaseInputMedia: BaseInputMedia{\n\t\t\tType:  \"animation\",\n\t\t\tMedia: media,\n\t\t},\n\t}\n}\n\n// NewInputMediaAudio creates a new InputMediaAudio.\nfunc NewInputMediaAudio(media RequestFileData) InputMediaAudio {\n\treturn InputMediaAudio{\n\t\tBaseInputMedia: BaseInputMedia{\n\t\t\tType:  \"audio\",\n\t\t\tMedia: media,\n\t\t},\n\t}\n}\n\n// NewInputMediaDocument creates a new InputMediaDocument.\nfunc NewInputMediaDocument(media RequestFileData) InputMediaDocument {\n\treturn InputMediaDocument{\n\t\tBaseInputMedia: BaseInputMedia{\n\t\t\tType:  \"document\",\n\t\t\tMedia: media,\n\t\t},\n\t}\n}\n\n// NewContact allows you to send a shared contact.\nfunc NewContact(chatID int64, phoneNumber, firstName string) ContactConfig {\n\treturn ContactConfig{\n\t\tBaseChat: BaseChat{\n\t\t\tChatID: chatID,\n\t\t},\n\t\tPhoneNumber: phoneNumber,\n\t\tFirstName:   firstName,\n\t}\n}\n\n// NewLocation shares your location.\n//\n// chatID is where to send it, latitude and longitude are coordinates.\nfunc NewLocation(chatID int64, latitude float64, longitude float64) LocationConfig {\n\treturn LocationConfig{\n\t\tBaseChat: BaseChat{\n\t\t\tChatID: chatID,\n\t\t},\n\t\tLatitude:  latitude,\n\t\tLongitude: longitude,\n\t}\n}\n\n// NewVenue allows you to send a venue and its location.\nfunc NewVenue(chatID int64, title, address string, latitude, longitude float64) VenueConfig {\n\treturn VenueConfig{\n\t\tBaseChat: BaseChat{\n\t\t\tChatID: chatID,\n\t\t},\n\t\tTitle:     title,\n\t\tAddress:   address,\n\t\tLatitude:  latitude,\n\t\tLongitude: longitude,\n\t}\n}\n\n// NewChatAction sets a chat action.\n// Actions last for 5 seconds, or until your next action.\n//\n// chatID is where to send it, action should be set via Chat constants.\nfunc NewChatAction(chatID int64, action string) ChatActionConfig {\n\treturn ChatActionConfig{\n\t\tBaseChat: BaseChat{ChatID: chatID},\n\t\tAction:   action,\n\t}\n}\n\n// NewUserProfilePhotos gets user profile photos.\n//\n// userID is the ID of the user you wish to get profile photos from.\nfunc NewUserProfilePhotos(userID int64) UserProfilePhotosConfig {\n\treturn UserProfilePhotosConfig{\n\t\tUserID: userID,\n\t\tOffset: 0,\n\t\tLimit:  0,\n\t}\n}\n\n// NewUpdate gets updates since the last Offset.\n//\n// offset is the last Update ID to include.\n// You likely want to set this to the last Update ID plus 1.\nfunc NewUpdate(offset int) UpdateConfig {\n\treturn UpdateConfig{\n\t\tOffset:  offset,\n\t\tLimit:   0,\n\t\tTimeout: 0,\n\t}\n}\n\n// NewWebhook creates a new webhook.\n//\n// link is the url parsable link you wish to get the updates.\nfunc NewWebhook(link string) (WebhookConfig, error) {\n\tu, err := url.Parse(link)\n\n\tif err != nil {\n\t\treturn WebhookConfig{}, err\n\t}\n\n\treturn WebhookConfig{\n\t\tURL: u,\n\t}, nil\n}\n\n// NewWebhookWithCert creates a new webhook with a certificate.\n//\n// link is the url you wish to get webhooks,\n// file contains a string to a file, FileReader, or FileBytes.\nfunc NewWebhookWithCert(link string, file RequestFileData) (WebhookConfig, error) {\n\tu, err := url.Parse(link)\n\n\tif err != nil {\n\t\treturn WebhookConfig{}, err\n\t}\n\n\treturn WebhookConfig{\n\t\tURL:         u,\n\t\tCertificate: file,\n\t}, nil\n}\n\n// NewInlineQueryResultArticle creates a new inline query article.\nfunc NewInlineQueryResultArticle(id, title, messageText string) InlineQueryResultArticle {\n\treturn InlineQueryResultArticle{\n\t\tType:  \"article\",\n\t\tID:    id,\n\t\tTitle: title,\n\t\tInputMessageContent: InputTextMessageContent{\n\t\t\tText: messageText,\n\t\t},\n\t}\n}\n\n// NewInlineQueryResultArticleMarkdown creates a new inline query article with Markdown parsing.\nfunc NewInlineQueryResultArticleMarkdown(id, title, messageText string) InlineQueryResultArticle {\n\treturn InlineQueryResultArticle{\n\t\tType:  \"article\",\n\t\tID:    id,\n\t\tTitle: title,\n\t\tInputMessageContent: InputTextMessageContent{\n\t\t\tText:      messageText,\n\t\t\tParseMode: \"Markdown\",\n\t\t},\n\t}\n}\n\n// NewInlineQueryResultArticleMarkdownV2 creates a new inline query article with MarkdownV2 parsing.\nfunc NewInlineQueryResultArticleMarkdownV2(id, title, messageText string) InlineQueryResultArticle {\n\treturn InlineQueryResultArticle{\n\t\tType:  \"article\",\n\t\tID:    id,\n\t\tTitle: title,\n\t\tInputMessageContent: InputTextMessageContent{\n\t\t\tText:      messageText,\n\t\t\tParseMode: \"MarkdownV2\",\n\t\t},\n\t}\n}\n\n// NewInlineQueryResultArticleHTML creates a new inline query article with HTML parsing.\nfunc NewInlineQueryResultArticleHTML(id, title, messageText string) InlineQueryResultArticle {\n\treturn InlineQueryResultArticle{\n\t\tType:  \"article\",\n\t\tID:    id,\n\t\tTitle: title,\n\t\tInputMessageContent: InputTextMessageContent{\n\t\t\tText:      messageText,\n\t\t\tParseMode: \"HTML\",\n\t\t},\n\t}\n}\n\n// NewInlineQueryResultGIF creates a new inline query GIF.\nfunc NewInlineQueryResultGIF(id, url string) InlineQueryResultGIF {\n\treturn InlineQueryResultGIF{\n\t\tType: \"gif\",\n\t\tID:   id,\n\t\tURL:  url,\n\t}\n}\n\n// NewInlineQueryResultCachedGIF create a new inline query with cached photo.\nfunc NewInlineQueryResultCachedGIF(id, gifID string) InlineQueryResultCachedGIF {\n\treturn InlineQueryResultCachedGIF{\n\t\tType:  \"gif\",\n\t\tID:    id,\n\t\tGIFID: gifID,\n\t}\n}\n\n// NewInlineQueryResultMPEG4GIF creates a new inline query MPEG4 GIF.\nfunc NewInlineQueryResultMPEG4GIF(id, url string) InlineQueryResultMPEG4GIF {\n\treturn InlineQueryResultMPEG4GIF{\n\t\tType: \"mpeg4_gif\",\n\t\tID:   id,\n\t\tURL:  url,\n\t}\n}\n\n// NewInlineQueryResultCachedMPEG4GIF create a new inline query with cached MPEG4 GIF.\nfunc NewInlineQueryResultCachedMPEG4GIF(id, MPEG4GIFID string) InlineQueryResultCachedMPEG4GIF {\n\treturn InlineQueryResultCachedMPEG4GIF{\n\t\tType:        \"mpeg4_gif\",\n\t\tID:          id,\n\t\tMPEG4FileID: MPEG4GIFID,\n\t}\n}\n\n// NewInlineQueryResultPhoto creates a new inline query photo.\nfunc NewInlineQueryResultPhoto(id, url string) InlineQueryResultPhoto {\n\treturn InlineQueryResultPhoto{\n\t\tType: \"photo\",\n\t\tID:   id,\n\t\tURL:  url,\n\t}\n}\n\n// NewInlineQueryResultPhotoWithThumb creates a new inline query photo.\nfunc NewInlineQueryResultPhotoWithThumb(id, url, thumb string) InlineQueryResultPhoto {\n\treturn InlineQueryResultPhoto{\n\t\tType:     \"photo\",\n\t\tID:       id,\n\t\tURL:      url,\n\t\tThumbURL: thumb,\n\t}\n}\n\n// NewInlineQueryResultCachedPhoto create a new inline query with cached photo.\nfunc NewInlineQueryResultCachedPhoto(id, photoID string) InlineQueryResultCachedPhoto {\n\treturn InlineQueryResultCachedPhoto{\n\t\tType:    \"photo\",\n\t\tID:      id,\n\t\tPhotoID: photoID,\n\t}\n}\n\n// NewInlineQueryResultVideo creates a new inline query video.\nfunc NewInlineQueryResultVideo(id, url string) InlineQueryResultVideo {\n\treturn InlineQueryResultVideo{\n\t\tType: \"video\",\n\t\tID:   id,\n\t\tURL:  url,\n\t}\n}\n\n// NewInlineQueryResultCachedVideo create a new inline query with cached video.\nfunc NewInlineQueryResultCachedVideo(id, videoID, title string) InlineQueryResultCachedVideo {\n\treturn InlineQueryResultCachedVideo{\n\t\tType:    \"video\",\n\t\tID:      id,\n\t\tVideoID: videoID,\n\t\tTitle:   title,\n\t}\n}\n\n// NewInlineQueryResultCachedSticker create a new inline query with cached sticker.\nfunc NewInlineQueryResultCachedSticker(id, stickerID, title string) InlineQueryResultCachedSticker {\n\treturn InlineQueryResultCachedSticker{\n\t\tType:      \"sticker\",\n\t\tID:        id,\n\t\tStickerID: stickerID,\n\t\tTitle:     title,\n\t}\n}\n\n// NewInlineQueryResultAudio creates a new inline query audio.\nfunc NewInlineQueryResultAudio(id, url, title string) InlineQueryResultAudio {\n\treturn InlineQueryResultAudio{\n\t\tType:  \"audio\",\n\t\tID:    id,\n\t\tURL:   url,\n\t\tTitle: title,\n\t}\n}\n\n// NewInlineQueryResultCachedAudio create a new inline query with cached photo.\nfunc NewInlineQueryResultCachedAudio(id, audioID string) InlineQueryResultCachedAudio {\n\treturn InlineQueryResultCachedAudio{\n\t\tType:    \"audio\",\n\t\tID:      id,\n\t\tAudioID: audioID,\n\t}\n}\n\n// NewInlineQueryResultVoice creates a new inline query voice.\nfunc NewInlineQueryResultVoice(id, url, title string) InlineQueryResultVoice {\n\treturn InlineQueryResultVoice{\n\t\tType:  \"voice\",\n\t\tID:    id,\n\t\tURL:   url,\n\t\tTitle: title,\n\t}\n}\n\n// NewInlineQueryResultCachedVoice create a new inline query with cached photo.\nfunc NewInlineQueryResultCachedVoice(id, voiceID, title string) InlineQueryResultCachedVoice {\n\treturn InlineQueryResultCachedVoice{\n\t\tType:    \"voice\",\n\t\tID:      id,\n\t\tVoiceID: voiceID,\n\t\tTitle:   title,\n\t}\n}\n\n// NewInlineQueryResultDocument creates a new inline query document.\nfunc NewInlineQueryResultDocument(id, url, title, mimeType string) InlineQueryResultDocument {\n\treturn InlineQueryResultDocument{\n\t\tType:     \"document\",\n\t\tID:       id,\n\t\tURL:      url,\n\t\tTitle:    title,\n\t\tMimeType: mimeType,\n\t}\n}\n\n// NewInlineQueryResultCachedDocument create a new inline query with cached photo.\nfunc NewInlineQueryResultCachedDocument(id, documentID, title string) InlineQueryResultCachedDocument {\n\treturn InlineQueryResultCachedDocument{\n\t\tType:       \"document\",\n\t\tID:         id,\n\t\tDocumentID: documentID,\n\t\tTitle:      title,\n\t}\n}\n\n// NewInlineQueryResultLocation creates a new inline query location.\nfunc NewInlineQueryResultLocation(id, title string, latitude, longitude float64) InlineQueryResultLocation {\n\treturn InlineQueryResultLocation{\n\t\tType:      \"location\",\n\t\tID:        id,\n\t\tTitle:     title,\n\t\tLatitude:  latitude,\n\t\tLongitude: longitude,\n\t}\n}\n\n// NewInlineQueryResultVenue creates a new inline query venue.\nfunc NewInlineQueryResultVenue(id, title, address string, latitude, longitude float64) InlineQueryResultVenue {\n\treturn InlineQueryResultVenue{\n\t\tType:      \"venue\",\n\t\tID:        id,\n\t\tTitle:     title,\n\t\tAddress:   address,\n\t\tLatitude:  latitude,\n\t\tLongitude: longitude,\n\t}\n}\n\n// NewEditMessageText allows you to edit the text of a message.\nfunc NewEditMessageText(chatID int64, messageID int, text string) EditMessageTextConfig {\n\treturn EditMessageTextConfig{\n\t\tBaseEdit: BaseEdit{\n\t\t\tChatID:    chatID,\n\t\t\tMessageID: messageID,\n\t\t},\n\t\tText: text,\n\t}\n}\n\n// NewEditMessageTextAndMarkup allows you to edit the text and reply markup of a message.\nfunc NewEditMessageTextAndMarkup(chatID int64, messageID int, text string, replyMarkup InlineKeyboardMarkup) EditMessageTextConfig {\n\treturn EditMessageTextConfig{\n\t\tBaseEdit: BaseEdit{\n\t\t\tChatID:      chatID,\n\t\t\tMessageID:   messageID,\n\t\t\tReplyMarkup: &replyMarkup,\n\t\t},\n\t\tText: text,\n\t}\n}\n\n// NewEditMessageCaption allows you to edit the caption of a message.\nfunc NewEditMessageCaption(chatID int64, messageID int, caption string) EditMessageCaptionConfig {\n\treturn EditMessageCaptionConfig{\n\t\tBaseEdit: BaseEdit{\n\t\t\tChatID:    chatID,\n\t\t\tMessageID: messageID,\n\t\t},\n\t\tCaption: caption,\n\t}\n}\n\n// NewEditMessageReplyMarkup allows you to edit the inline\n// keyboard markup.\nfunc NewEditMessageReplyMarkup(chatID int64, messageID int, replyMarkup InlineKeyboardMarkup) EditMessageReplyMarkupConfig {\n\treturn EditMessageReplyMarkupConfig{\n\t\tBaseEdit: BaseEdit{\n\t\t\tChatID:      chatID,\n\t\t\tMessageID:   messageID,\n\t\t\tReplyMarkup: &replyMarkup,\n\t\t},\n\t}\n}\n\n// NewRemoveKeyboard hides the keyboard, with the option for being selective\n// or hiding for everyone.\nfunc NewRemoveKeyboard(selective bool) ReplyKeyboardRemove {\n\treturn ReplyKeyboardRemove{\n\t\tRemoveKeyboard: true,\n\t\tSelective:      selective,\n\t}\n}\n\n// NewKeyboardButton creates a regular keyboard button.\nfunc NewKeyboardButton(text string) KeyboardButton {\n\treturn KeyboardButton{\n\t\tText: text,\n\t}\n}\n\n// NewKeyboardButtonWebApp creates a keyboard button with text\n// which goes to a WebApp.\nfunc NewKeyboardButtonWebApp(text string, webapp WebAppInfo) KeyboardButton {\n\treturn KeyboardButton{\n\t\tText:   text,\n\t\tWebApp: &webapp,\n\t}\n}\n\n// NewKeyboardButtonContact creates a keyboard button that requests\n// user contact information upon click.\nfunc NewKeyboardButtonContact(text string) KeyboardButton {\n\treturn KeyboardButton{\n\t\tText:           text,\n\t\tRequestContact: true,\n\t}\n}\n\n// NewKeyboardButtonLocation creates a keyboard button that requests\n// user location information upon click.\nfunc NewKeyboardButtonLocation(text string) KeyboardButton {\n\treturn KeyboardButton{\n\t\tText:            text,\n\t\tRequestLocation: true,\n\t}\n}\n\n// NewKeyboardButtonRow creates a row of keyboard buttons.\nfunc NewKeyboardButtonRow(buttons ...KeyboardButton) []KeyboardButton {\n\tvar row []KeyboardButton\n\n\trow = append(row, buttons...)\n\n\treturn row\n}\n\n// NewReplyKeyboard creates a new regular keyboard with sane defaults.\nfunc NewReplyKeyboard(rows ...[]KeyboardButton) ReplyKeyboardMarkup {\n\tvar keyboard [][]KeyboardButton\n\n\tkeyboard = append(keyboard, rows...)\n\n\treturn ReplyKeyboardMarkup{\n\t\tResizeKeyboard: true,\n\t\tKeyboard:       keyboard,\n\t}\n}\n\n// NewOneTimeReplyKeyboard creates a new one time keyboard.\nfunc NewOneTimeReplyKeyboard(rows ...[]KeyboardButton) ReplyKeyboardMarkup {\n\tmarkup := NewReplyKeyboard(rows...)\n\tmarkup.OneTimeKeyboard = true\n\treturn markup\n}\n\n// NewInlineKeyboardButtonData creates an inline keyboard button with text\n// and data for a callback.\nfunc NewInlineKeyboardButtonData(text, data string) InlineKeyboardButton {\n\treturn InlineKeyboardButton{\n\t\tText:         text,\n\t\tCallbackData: &data,\n\t}\n}\n\n// NewInlineKeyboardButtonWebApp creates an inline keyboard button with text\n// which goes to a WebApp.\nfunc NewInlineKeyboardButtonWebApp(text string, webapp WebAppInfo) InlineKeyboardButton {\n\treturn InlineKeyboardButton{\n\t\tText:   text,\n\t\tWebApp: &webapp,\n\t}\n}\n\n// NewInlineKeyboardButtonLoginURL creates an inline keyboard button with text\n// which goes to a LoginURL.\nfunc NewInlineKeyboardButtonLoginURL(text string, loginURL LoginURL) InlineKeyboardButton {\n\treturn InlineKeyboardButton{\n\t\tText:     text,\n\t\tLoginURL: &loginURL,\n\t}\n}\n\n// NewInlineKeyboardButtonURL creates an inline keyboard button with text\n// which goes to a URL.\nfunc NewInlineKeyboardButtonURL(text, url string) InlineKeyboardButton {\n\treturn InlineKeyboardButton{\n\t\tText: text,\n\t\tURL:  &url,\n\t}\n}\n\n// NewInlineKeyboardButtonSwitch creates an inline keyboard button with\n// text which allows the user to switch to a chat or return to a chat.\nfunc NewInlineKeyboardButtonSwitch(text, sw string) InlineKeyboardButton {\n\treturn InlineKeyboardButton{\n\t\tText:              text,\n\t\tSwitchInlineQuery: &sw,\n\t}\n}\n\n// NewInlineKeyboardRow creates an inline keyboard row with buttons.\nfunc NewInlineKeyboardRow(buttons ...InlineKeyboardButton) []InlineKeyboardButton {\n\tvar row []InlineKeyboardButton\n\n\trow = append(row, buttons...)\n\n\treturn row\n}\n\n// NewInlineKeyboardMarkup creates a new inline keyboard.\nfunc NewInlineKeyboardMarkup(rows ...[]InlineKeyboardButton) InlineKeyboardMarkup {\n\tvar keyboard [][]InlineKeyboardButton\n\n\tkeyboard = append(keyboard, rows...)\n\n\treturn InlineKeyboardMarkup{\n\t\tInlineKeyboard: keyboard,\n\t}\n}\n\n// NewCallback creates a new callback message.\nfunc NewCallback(id, text string) CallbackConfig {\n\treturn CallbackConfig{\n\t\tCallbackQueryID: id,\n\t\tText:            text,\n\t\tShowAlert:       false,\n\t}\n}\n\n// NewCallbackWithAlert creates a new callback message that alerts\n// the user.\nfunc NewCallbackWithAlert(id, text string) CallbackConfig {\n\treturn CallbackConfig{\n\t\tCallbackQueryID: id,\n\t\tText:            text,\n\t\tShowAlert:       true,\n\t}\n}\n\n// NewInvoice creates a new Invoice request to the user.\nfunc NewInvoice(chatID int64, title, description, payload, providerToken, startParameter, currency string, prices []LabeledPrice) InvoiceConfig {\n\treturn InvoiceConfig{\n\t\tBaseChat:       BaseChat{ChatID: chatID},\n\t\tTitle:          title,\n\t\tDescription:    description,\n\t\tPayload:        payload,\n\t\tProviderToken:  providerToken,\n\t\tStartParameter: startParameter,\n\t\tCurrency:       currency,\n\t\tPrices:         prices}\n}\n\n// NewChatTitle allows you to update the title of a chat.\nfunc NewChatTitle(chatID int64, title string) SetChatTitleConfig {\n\treturn SetChatTitleConfig{\n\t\tChatID: chatID,\n\t\tTitle:  title,\n\t}\n}\n\n// NewChatDescription allows you to update the description of a chat.\nfunc NewChatDescription(chatID int64, description string) SetChatDescriptionConfig {\n\treturn SetChatDescriptionConfig{\n\t\tChatID:      chatID,\n\t\tDescription: description,\n\t}\n}\n\n// NewChatPhoto allows you to update the photo for a chat.\nfunc NewChatPhoto(chatID int64, photo RequestFileData) SetChatPhotoConfig {\n\treturn SetChatPhotoConfig{\n\t\tBaseFile: BaseFile{\n\t\t\tBaseChat: BaseChat{\n\t\t\t\tChatID: chatID,\n\t\t\t},\n\t\t\tFile: photo,\n\t\t},\n\t}\n}\n\n// NewDeleteChatPhoto allows you to delete the photo for a chat.\nfunc NewDeleteChatPhoto(chatID int64) DeleteChatPhotoConfig {\n\treturn DeleteChatPhotoConfig{\n\t\tChatID: chatID,\n\t}\n}\n\n// NewPoll allows you to create a new poll.\nfunc NewPoll(chatID int64, question string, options ...string) SendPollConfig {\n\treturn SendPollConfig{\n\t\tBaseChat: BaseChat{\n\t\t\tChatID: chatID,\n\t\t},\n\t\tQuestion:    question,\n\t\tOptions:     options,\n\t\tIsAnonymous: true, // This is Telegram's default.\n\t}\n}\n\n// NewStopPoll allows you to stop a poll.\nfunc NewStopPoll(chatID int64, messageID int) StopPollConfig {\n\treturn StopPollConfig{\n\t\tBaseEdit{\n\t\t\tChatID:    chatID,\n\t\t\tMessageID: messageID,\n\t\t},\n\t}\n}\n\n// NewDice allows you to send a random dice roll.\nfunc NewDice(chatID int64) DiceConfig {\n\treturn DiceConfig{\n\t\tBaseChat: BaseChat{\n\t\t\tChatID: chatID,\n\t\t},\n\t}\n}\n\n// NewDiceWithEmoji allows you to send a random roll of one of many types.\n//\n// Emoji may be 🎲 (1-6), 🎯 (1-6), or 🏀 (1-5).\nfunc NewDiceWithEmoji(chatID int64, emoji string) DiceConfig {\n\treturn DiceConfig{\n\t\tBaseChat: BaseChat{\n\t\t\tChatID: chatID,\n\t\t},\n\t\tEmoji: emoji,\n\t}\n}\n\n// NewBotCommandScopeDefault represents the default scope of bot commands.\nfunc NewBotCommandScopeDefault() BotCommandScope {\n\treturn BotCommandScope{Type: \"default\"}\n}\n\n// NewBotCommandScopeAllPrivateChats represents the scope of bot commands,\n// covering all private chats.\nfunc NewBotCommandScopeAllPrivateChats() BotCommandScope {\n\treturn BotCommandScope{Type: \"all_private_chats\"}\n}\n\n// NewBotCommandScopeAllGroupChats represents the scope of bot commands,\n// covering all group and supergroup chats.\nfunc NewBotCommandScopeAllGroupChats() BotCommandScope {\n\treturn BotCommandScope{Type: \"all_group_chats\"}\n}\n\n// NewBotCommandScopeAllChatAdministrators represents the scope of bot commands,\n// covering all group and supergroup chat administrators.\nfunc NewBotCommandScopeAllChatAdministrators() BotCommandScope {\n\treturn BotCommandScope{Type: \"all_chat_administrators\"}\n}\n\n// NewBotCommandScopeChat represents the scope of bot commands, covering a\n// specific chat.\nfunc NewBotCommandScopeChat(chatID int64) BotCommandScope {\n\treturn BotCommandScope{\n\t\tType:   \"chat\",\n\t\tChatID: chatID,\n\t}\n}\n\n// NewBotCommandScopeChatAdministrators represents the scope of bot commands,\n// covering all administrators of a specific group or supergroup chat.\nfunc NewBotCommandScopeChatAdministrators(chatID int64) BotCommandScope {\n\treturn BotCommandScope{\n\t\tType:   \"chat_administrators\",\n\t\tChatID: chatID,\n\t}\n}\n\n// NewBotCommandScopeChatMember represents the scope of bot commands, covering a\n// specific member of a group or supergroup chat.\nfunc NewBotCommandScopeChatMember(chatID, userID int64) BotCommandScope {\n\treturn BotCommandScope{\n\t\tType:   \"chat_member\",\n\t\tChatID: chatID,\n\t\tUserID: userID,\n\t}\n}\n\n// NewGetMyCommandsWithScope allows you to set the registered commands for a\n// given scope.\nfunc NewGetMyCommandsWithScope(scope BotCommandScope) GetMyCommandsConfig {\n\treturn GetMyCommandsConfig{Scope: &scope}\n}\n\n// NewGetMyCommandsWithScopeAndLanguage allows you to set the registered\n// commands for a given scope and language code.\nfunc NewGetMyCommandsWithScopeAndLanguage(scope BotCommandScope, languageCode string) GetMyCommandsConfig {\n\treturn GetMyCommandsConfig{Scope: &scope, LanguageCode: languageCode}\n}\n\n// NewSetMyCommands allows you to set the registered commands.\nfunc NewSetMyCommands(commands ...BotCommand) SetMyCommandsConfig {\n\treturn SetMyCommandsConfig{Commands: commands}\n}\n\n// NewSetMyCommandsWithScope allows you to set the registered commands for a given scope.\nfunc NewSetMyCommandsWithScope(scope BotCommandScope, commands ...BotCommand) SetMyCommandsConfig {\n\treturn SetMyCommandsConfig{Commands: commands, Scope: &scope}\n}\n\n// NewSetMyCommandsWithScopeAndLanguage allows you to set the registered commands for a given scope\n// and language code.\nfunc NewSetMyCommandsWithScopeAndLanguage(scope BotCommandScope, languageCode string, commands ...BotCommand) SetMyCommandsConfig {\n\treturn SetMyCommandsConfig{Commands: commands, Scope: &scope, LanguageCode: languageCode}\n}\n\n// NewDeleteMyCommands allows you to delete the registered commands.\nfunc NewDeleteMyCommands() DeleteMyCommandsConfig {\n\treturn DeleteMyCommandsConfig{}\n}\n\n// NewDeleteMyCommandsWithScope allows you to delete the registered commands for a given\n// scope.\nfunc NewDeleteMyCommandsWithScope(scope BotCommandScope) DeleteMyCommandsConfig {\n\treturn DeleteMyCommandsConfig{Scope: &scope}\n}\n\n// NewDeleteMyCommandsWithScopeAndLanguage allows you to delete the registered commands for a given\n// scope and language code.\nfunc NewDeleteMyCommandsWithScopeAndLanguage(scope BotCommandScope, languageCode string) DeleteMyCommandsConfig {\n\treturn DeleteMyCommandsConfig{Scope: &scope, LanguageCode: languageCode}\n}\n\n// ValidateWebAppData validate data received via the Web App\n// https://core.telegram.org/bots/webapps#validating-data-received-via-the-web-app\nfunc ValidateWebAppData(token, telegramInitData string) (bool, error) {\n\tinitData, err := url.ParseQuery(telegramInitData)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"error parsing data %w\", err)\n\t}\n\n\tdataCheckString := make([]string, 0, len(initData))\n\tfor k, v := range initData {\n\t\tif k == \"hash\" {\n\t\t\tcontinue\n\t\t}\n\t\tif len(v) > 0 {\n\t\t\tdataCheckString = append(dataCheckString, fmt.Sprintf(\"%s=%s\", k, v[0]))\n\t\t}\n\t}\n\n\tsort.Strings(dataCheckString)\n\n\tsecret := hmac.New(sha256.New, []byte(\"WebAppData\"))\n\tsecret.Write([]byte(token))\n\n\thHash := hmac.New(sha256.New, secret.Sum(nil))\n\thHash.Write([]byte(strings.Join(dataCheckString, \"\\n\")))\n\n\thash := hex.EncodeToString(hHash.Sum(nil))\n\n\tif initData.Get(\"hash\") != hash {\n\t\treturn false, errors.New(\"hash not equal\")\n\t}\n\n\treturn true, nil\n}\n"
        },
        {
          "name": "helpers_test.go",
          "type": "blob",
          "size": 6.2890625,
          "content": "package tgbotapi\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNewWebhook(t *testing.T) {\n\tresult, err := NewWebhook(\"https://example.com/token\")\n\n\tif err != nil ||\n\t\tresult.URL.String() != \"https://example.com/token\" ||\n\t\tresult.Certificate != interface{}(nil) ||\n\t\tresult.MaxConnections != 0 ||\n\t\tlen(result.AllowedUpdates) != 0 {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestNewWebhookWithCert(t *testing.T) {\n\texampleFile := FileID(\"123\")\n\tresult, err := NewWebhookWithCert(\"https://example.com/token\", exampleFile)\n\n\tif err != nil ||\n\t\tresult.URL.String() != \"https://example.com/token\" ||\n\t\tresult.Certificate != exampleFile ||\n\t\tresult.MaxConnections != 0 ||\n\t\tlen(result.AllowedUpdates) != 0 {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestNewInlineQueryResultArticle(t *testing.T) {\n\tresult := NewInlineQueryResultArticle(\"id\", \"title\", \"message\")\n\n\tif result.Type != \"article\" ||\n\t\tresult.ID != \"id\" ||\n\t\tresult.Title != \"title\" ||\n\t\tresult.InputMessageContent.(InputTextMessageContent).Text != \"message\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestNewInlineQueryResultArticleMarkdown(t *testing.T) {\n\tresult := NewInlineQueryResultArticleMarkdown(\"id\", \"title\", \"*message*\")\n\n\tif result.Type != \"article\" ||\n\t\tresult.ID != \"id\" ||\n\t\tresult.Title != \"title\" ||\n\t\tresult.InputMessageContent.(InputTextMessageContent).Text != \"*message*\" ||\n\t\tresult.InputMessageContent.(InputTextMessageContent).ParseMode != \"Markdown\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestNewInlineQueryResultArticleHTML(t *testing.T) {\n\tresult := NewInlineQueryResultArticleHTML(\"id\", \"title\", \"<b>message</b>\")\n\n\tif result.Type != \"article\" ||\n\t\tresult.ID != \"id\" ||\n\t\tresult.Title != \"title\" ||\n\t\tresult.InputMessageContent.(InputTextMessageContent).Text != \"<b>message</b>\" ||\n\t\tresult.InputMessageContent.(InputTextMessageContent).ParseMode != \"HTML\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestNewInlineQueryResultGIF(t *testing.T) {\n\tresult := NewInlineQueryResultGIF(\"id\", \"google.com\")\n\n\tif result.Type != \"gif\" ||\n\t\tresult.ID != \"id\" ||\n\t\tresult.URL != \"google.com\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestNewInlineQueryResultMPEG4GIF(t *testing.T) {\n\tresult := NewInlineQueryResultMPEG4GIF(\"id\", \"google.com\")\n\n\tif result.Type != \"mpeg4_gif\" ||\n\t\tresult.ID != \"id\" ||\n\t\tresult.URL != \"google.com\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestNewInlineQueryResultPhoto(t *testing.T) {\n\tresult := NewInlineQueryResultPhoto(\"id\", \"google.com\")\n\n\tif result.Type != \"photo\" ||\n\t\tresult.ID != \"id\" ||\n\t\tresult.URL != \"google.com\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestNewInlineQueryResultPhotoWithThumb(t *testing.T) {\n\tresult := NewInlineQueryResultPhotoWithThumb(\"id\", \"google.com\", \"thumb.com\")\n\n\tif result.Type != \"photo\" ||\n\t\tresult.ID != \"id\" ||\n\t\tresult.URL != \"google.com\" ||\n\t\tresult.ThumbURL != \"thumb.com\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestNewInlineQueryResultVideo(t *testing.T) {\n\tresult := NewInlineQueryResultVideo(\"id\", \"google.com\")\n\n\tif result.Type != \"video\" ||\n\t\tresult.ID != \"id\" ||\n\t\tresult.URL != \"google.com\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestNewInlineQueryResultAudio(t *testing.T) {\n\tresult := NewInlineQueryResultAudio(\"id\", \"google.com\", \"title\")\n\n\tif result.Type != \"audio\" ||\n\t\tresult.ID != \"id\" ||\n\t\tresult.URL != \"google.com\" ||\n\t\tresult.Title != \"title\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestNewInlineQueryResultVoice(t *testing.T) {\n\tresult := NewInlineQueryResultVoice(\"id\", \"google.com\", \"title\")\n\n\tif result.Type != \"voice\" ||\n\t\tresult.ID != \"id\" ||\n\t\tresult.URL != \"google.com\" ||\n\t\tresult.Title != \"title\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestNewInlineQueryResultDocument(t *testing.T) {\n\tresult := NewInlineQueryResultDocument(\"id\", \"google.com\", \"title\", \"mime/type\")\n\n\tif result.Type != \"document\" ||\n\t\tresult.ID != \"id\" ||\n\t\tresult.URL != \"google.com\" ||\n\t\tresult.Title != \"title\" ||\n\t\tresult.MimeType != \"mime/type\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestNewInlineQueryResultLocation(t *testing.T) {\n\tresult := NewInlineQueryResultLocation(\"id\", \"name\", 40, 50)\n\n\tif result.Type != \"location\" ||\n\t\tresult.ID != \"id\" ||\n\t\tresult.Title != \"name\" ||\n\t\tresult.Latitude != 40 ||\n\t\tresult.Longitude != 50 {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestNewInlineKeyboardButtonLoginURL(t *testing.T) {\n\tresult := NewInlineKeyboardButtonLoginURL(\"text\", LoginURL{\n\t\tURL:                \"url\",\n\t\tForwardText:        \"ForwardText\",\n\t\tBotUsername:        \"username\",\n\t\tRequestWriteAccess: false,\n\t})\n\n\tif result.Text != \"text\" ||\n\t\tresult.LoginURL.URL != \"url\" ||\n\t\tresult.LoginURL.ForwardText != \"ForwardText\" ||\n\t\tresult.LoginURL.BotUsername != \"username\" ||\n\t\tresult.LoginURL.RequestWriteAccess != false {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestNewEditMessageText(t *testing.T) {\n\tedit := NewEditMessageText(ChatID, ReplyToMessageID, \"new text\")\n\n\tif edit.Text != \"new text\" ||\n\t\tedit.BaseEdit.ChatID != ChatID ||\n\t\tedit.BaseEdit.MessageID != ReplyToMessageID {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestNewEditMessageCaption(t *testing.T) {\n\tedit := NewEditMessageCaption(ChatID, ReplyToMessageID, \"new caption\")\n\n\tif edit.Caption != \"new caption\" ||\n\t\tedit.BaseEdit.ChatID != ChatID ||\n\t\tedit.BaseEdit.MessageID != ReplyToMessageID {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestNewEditMessageReplyMarkup(t *testing.T) {\n\tmarkup := InlineKeyboardMarkup{\n\t\tInlineKeyboard: [][]InlineKeyboardButton{\n\t\t\t{\n\t\t\t\t{Text: \"test\"},\n\t\t\t},\n\t\t},\n\t}\n\n\tedit := NewEditMessageReplyMarkup(ChatID, ReplyToMessageID, markup)\n\n\tif edit.ReplyMarkup.InlineKeyboard[0][0].Text != \"test\" ||\n\t\tedit.BaseEdit.ChatID != ChatID ||\n\t\tedit.BaseEdit.MessageID != ReplyToMessageID {\n\t\tt.Fail()\n\t}\n\n}\n\nfunc TestNewDice(t *testing.T) {\n\tdice := NewDice(42)\n\n\tif dice.ChatID != 42 ||\n\t\tdice.Emoji != \"\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestNewDiceWithEmoji(t *testing.T) {\n\tdice := NewDiceWithEmoji(42, \"🏀\")\n\n\tif dice.ChatID != 42 ||\n\t\tdice.Emoji != \"🏀\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestValidateWebAppData(t *testing.T) {\n\tt.Run(\"success\", func(t *testing.T) {\n\t\ttoken := \"5473903189:AAFnHnISQMP5UQQ5MEaoEWvxeiwNgz2CN2U\"\n\t\tinitData := \"query_id=AAG1bpMJAAAAALVukwmZ_H2t&user=%7B%22id%22%3A160657077%2C%22first_name%22%3A%22Yury%20R%22%2C%22last_name%22%3A%22%22%2C%22username%22%3A%22crashiura%22%2C%22language_code%22%3A%22en%22%7D&auth_date=1656804462&hash=8d6960760a573d3212deb05e20d1a34959c83d24c1bc44bb26dde49a42aa9b34\"\n\t\tresult, err := ValidateWebAppData(token, initData)\n\t\tif err != nil {\n\t\t\tt.Fail()\n\t\t}\n\t\tif !result {\n\t\t\tt.Fail()\n\t\t}\n\t})\n\n\tt.Run(\"error\", func(t *testing.T) {\n\t\ttoken := \"5473903189:AAFnHnISQMP5UQQ5MEaoEWvxeiwNgz2CN2U\"\n\t\tinitData := \"asdfasdfasdfasdfasdf\"\n\t\tresult, err := ValidateWebAppData(token, initData)\n\t\tif err == nil {\n\t\t\tt.Fail()\n\t\t}\n\t\tif result {\n\t\t\tt.Fail()\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "log.go",
          "type": "blob",
          "size": 0.625,
          "content": "package tgbotapi\n\nimport (\n\t\"errors\"\n\tstdlog \"log\"\n\t\"os\"\n)\n\n// BotLogger is an interface that represents the required methods to log data.\n//\n// Instead of requiring the standard logger, we can just specify the methods we\n// use and allow users to pass anything that implements these.\ntype BotLogger interface {\n\tPrintln(v ...interface{})\n\tPrintf(format string, v ...interface{})\n}\n\nvar log BotLogger = stdlog.New(os.Stderr, \"\", stdlog.LstdFlags)\n\n// SetLogger specifies the logger that the package should use.\nfunc SetLogger(logger BotLogger) error {\n\tif logger == nil {\n\t\treturn errors.New(\"logger is nil\")\n\t}\n\tlog = logger\n\treturn nil\n}\n"
        },
        {
          "name": "params.go",
          "type": "blob",
          "size": 1.9755859375,
          "content": "package tgbotapi\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n\t\"strconv\"\n)\n\n// Params represents a set of parameters that gets passed to a request.\ntype Params map[string]string\n\n// AddNonEmpty adds a value if it not an empty string.\nfunc (p Params) AddNonEmpty(key, value string) {\n\tif value != \"\" {\n\t\tp[key] = value\n\t}\n}\n\n// AddNonZero adds a value if it is not zero.\nfunc (p Params) AddNonZero(key string, value int) {\n\tif value != 0 {\n\t\tp[key] = strconv.Itoa(value)\n\t}\n}\n\n// AddNonZero64 is the same as AddNonZero except uses an int64.\nfunc (p Params) AddNonZero64(key string, value int64) {\n\tif value != 0 {\n\t\tp[key] = strconv.FormatInt(value, 10)\n\t}\n}\n\n// AddBool adds a value of a bool if it is true.\nfunc (p Params) AddBool(key string, value bool) {\n\tif value {\n\t\tp[key] = strconv.FormatBool(value)\n\t}\n}\n\n// AddNonZeroFloat adds a floating point value that is not zero.\nfunc (p Params) AddNonZeroFloat(key string, value float64) {\n\tif value != 0 {\n\t\tp[key] = strconv.FormatFloat(value, 'f', 6, 64)\n\t}\n}\n\n// AddInterface adds an interface if it is not nil and can be JSON marshalled.\nfunc (p Params) AddInterface(key string, value interface{}) error {\n\tif value == nil || (reflect.ValueOf(value).Kind() == reflect.Ptr && reflect.ValueOf(value).IsNil()) {\n\t\treturn nil\n\t}\n\n\tb, err := json.Marshal(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tp[key] = string(b)\n\n\treturn nil\n}\n\n// AddFirstValid attempts to add the first item that is not a default value.\n//\n// For example, AddFirstValid(0, \"\", \"test\") would add \"test\".\nfunc (p Params) AddFirstValid(key string, args ...interface{}) error {\n\tfor _, arg := range args {\n\t\tswitch v := arg.(type) {\n\t\tcase int:\n\t\t\tif v != 0 {\n\t\t\t\tp[key] = strconv.Itoa(v)\n\t\t\t\treturn nil\n\t\t\t}\n\t\tcase int64:\n\t\t\tif v != 0 {\n\t\t\t\tp[key] = strconv.FormatInt(v, 10)\n\t\t\t\treturn nil\n\t\t\t}\n\t\tcase string:\n\t\t\tif v != \"\" {\n\t\t\t\tp[key] = v\n\t\t\t\treturn nil\n\t\t\t}\n\t\tcase nil:\n\t\tdefault:\n\t\t\tb, err := json.Marshal(arg)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tp[key] = string(b)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "params_test.go",
          "type": "blob",
          "size": 2.171875,
          "content": "package tgbotapi\n\nimport (\n\t\"testing\"\n)\n\nfunc assertLen(t *testing.T, params Params, l int) {\n\tactual := len(params)\n\tif actual != l {\n\t\tt.Fatalf(\"Incorrect number of params, expected %d but found %d\\n\", l, actual)\n\t}\n}\n\nfunc assertEq(t *testing.T, a interface{}, b interface{}) {\n\tif a != b {\n\t\tt.Fatalf(\"Values did not match, a: %v, b: %v\\n\", a, b)\n\t}\n}\n\nfunc TestAddNonEmpty(t *testing.T) {\n\tparams := make(Params)\n\tparams.AddNonEmpty(\"value\", \"value\")\n\tassertLen(t, params, 1)\n\tassertEq(t, params[\"value\"], \"value\")\n\tparams.AddNonEmpty(\"test\", \"\")\n\tassertLen(t, params, 1)\n\tassertEq(t, params[\"test\"], \"\")\n}\n\nfunc TestAddNonZero(t *testing.T) {\n\tparams := make(Params)\n\tparams.AddNonZero(\"value\", 1)\n\tassertLen(t, params, 1)\n\tassertEq(t, params[\"value\"], \"1\")\n\tparams.AddNonZero(\"test\", 0)\n\tassertLen(t, params, 1)\n\tassertEq(t, params[\"test\"], \"\")\n}\n\nfunc TestAddNonZero64(t *testing.T) {\n\tparams := make(Params)\n\tparams.AddNonZero64(\"value\", 1)\n\tassertLen(t, params, 1)\n\tassertEq(t, params[\"value\"], \"1\")\n\tparams.AddNonZero64(\"test\", 0)\n\tassertLen(t, params, 1)\n\tassertEq(t, params[\"test\"], \"\")\n}\n\nfunc TestAddBool(t *testing.T) {\n\tparams := make(Params)\n\tparams.AddBool(\"value\", true)\n\tassertLen(t, params, 1)\n\tassertEq(t, params[\"value\"], \"true\")\n\tparams.AddBool(\"test\", false)\n\tassertLen(t, params, 1)\n\tassertEq(t, params[\"test\"], \"\")\n}\n\nfunc TestAddNonZeroFloat(t *testing.T) {\n\tparams := make(Params)\n\tparams.AddNonZeroFloat(\"value\", 1)\n\tassertLen(t, params, 1)\n\tassertEq(t, params[\"value\"], \"1.000000\")\n\tparams.AddNonZeroFloat(\"test\", 0)\n\tassertLen(t, params, 1)\n\tassertEq(t, params[\"test\"], \"\")\n}\n\nfunc TestAddInterface(t *testing.T) {\n\tparams := make(Params)\n\tdata := struct {\n\t\tName string `json:\"name\"`\n\t}{\n\t\tName: \"test\",\n\t}\n\tparams.AddInterface(\"value\", data)\n\tassertLen(t, params, 1)\n\tassertEq(t, params[\"value\"], `{\"name\":\"test\"}`)\n\tparams.AddInterface(\"test\", nil)\n\tassertLen(t, params, 1)\n\tassertEq(t, params[\"test\"], \"\")\n}\n\nfunc TestAddFirstValid(t *testing.T) {\n\tparams := make(Params)\n\tparams.AddFirstValid(\"value\", 0, \"\", \"test\")\n\tassertLen(t, params, 1)\n\tassertEq(t, params[\"value\"], \"test\")\n\tparams.AddFirstValid(\"value2\", 3, \"test\")\n\tassertLen(t, params, 2)\n\tassertEq(t, params[\"value2\"], \"3\")\n}\n"
        },
        {
          "name": "passport.go",
          "type": "blob",
          "size": 11.53125,
          "content": "package tgbotapi\n\n// PassportRequestInfoConfig allows you to request passport info\ntype PassportRequestInfoConfig struct {\n\tBotID     int            `json:\"bot_id\"`\n\tScope     *PassportScope `json:\"scope\"`\n\tNonce     string         `json:\"nonce\"`\n\tPublicKey string         `json:\"public_key\"`\n}\n\n// PassportScopeElement supports using one or one of several elements.\ntype PassportScopeElement interface {\n\tScopeType() string\n}\n\n// PassportScope is the requested scopes of data.\ntype PassportScope struct {\n\tV    int                    `json:\"v\"`\n\tData []PassportScopeElement `json:\"data\"`\n}\n\n// PassportScopeElementOneOfSeveral allows you to request any one of the\n// requested documents.\ntype PassportScopeElementOneOfSeveral struct {\n}\n\n// ScopeType is the scope type.\nfunc (eo *PassportScopeElementOneOfSeveral) ScopeType() string {\n\treturn \"one_of\"\n}\n\n// PassportScopeElementOne requires the specified element be provided.\ntype PassportScopeElementOne struct {\n\tType        string `json:\"type\"` // One of “personal_details”, “passport”, “driver_license”, “identity_card”, “internal_passport”, “address”, “utility_bill”, “bank_statement”, “rental_agreement”, “passport_registration”, “temporary_registration”, “phone_number”, “email”\n\tSelfie      bool   `json:\"selfie\"`\n\tTranslation bool   `json:\"translation\"`\n\tNativeNames bool   `json:\"native_name\"`\n}\n\n// ScopeType is the scope type.\nfunc (eo *PassportScopeElementOne) ScopeType() string {\n\treturn \"one\"\n}\n\ntype (\n\t// PassportData contains information about Telegram Passport data shared with\n\t// the bot by the user.\n\tPassportData struct {\n\t\t// Array with information about documents and other Telegram Passport\n\t\t// elements that was shared with the bot\n\t\tData []EncryptedPassportElement `json:\"data\"`\n\n\t\t// Encrypted credentials required to decrypt the data\n\t\tCredentials *EncryptedCredentials `json:\"credentials\"`\n\t}\n\n\t// PassportFile represents a file uploaded to Telegram Passport. Currently, all\n\t// Telegram Passport files are in JPEG format when decrypted and don't exceed\n\t// 10MB.\n\tPassportFile struct {\n\t\t// Unique identifier for this file\n\t\tFileID string `json:\"file_id\"`\n\n\t\tFileUniqueID string `json:\"file_unique_id\"`\n\n\t\t// File size\n\t\tFileSize int `json:\"file_size\"`\n\n\t\t// Unix time when the file was uploaded\n\t\tFileDate int64 `json:\"file_date\"`\n\t}\n\n\t// EncryptedPassportElement contains information about documents or other\n\t// Telegram Passport elements shared with the bot by the user.\n\tEncryptedPassportElement struct {\n\t\t// Element type.\n\t\tType string `json:\"type\"`\n\n\t\t// Base64-encoded encrypted Telegram Passport element data provided by\n\t\t// the user, available for \"personal_details\", \"passport\",\n\t\t// \"driver_license\", \"identity_card\", \"identity_passport\" and \"address\"\n\t\t// types. Can be decrypted and verified using the accompanying\n\t\t// EncryptedCredentials.\n\t\tData string `json:\"data,omitempty\"`\n\n\t\t// User's verified phone number, available only for \"phone_number\" type\n\t\tPhoneNumber string `json:\"phone_number,omitempty\"`\n\n\t\t// User's verified email address, available only for \"email\" type\n\t\tEmail string `json:\"email,omitempty\"`\n\n\t\t// Array of encrypted files with documents provided by the user,\n\t\t// available for \"utility_bill\", \"bank_statement\", \"rental_agreement\",\n\t\t// \"passport_registration\" and \"temporary_registration\" types. Files can\n\t\t// be decrypted and verified using the accompanying EncryptedCredentials.\n\t\tFiles []PassportFile `json:\"files,omitempty\"`\n\n\t\t// Encrypted file with the front side of the document, provided by the\n\t\t// user. Available for \"passport\", \"driver_license\", \"identity_card\" and\n\t\t// \"internal_passport\". The file can be decrypted and verified using the\n\t\t// accompanying EncryptedCredentials.\n\t\tFrontSide *PassportFile `json:\"front_side,omitempty\"`\n\n\t\t// Encrypted file with the reverse side of the document, provided by the\n\t\t// user. Available for \"driver_license\" and \"identity_card\". The file can\n\t\t// be decrypted and verified using the accompanying EncryptedCredentials.\n\t\tReverseSide *PassportFile `json:\"reverse_side,omitempty\"`\n\n\t\t// Encrypted file with the selfie of the user holding a document,\n\t\t// provided by the user; available for \"passport\", \"driver_license\",\n\t\t// \"identity_card\" and \"internal_passport\". The file can be decrypted\n\t\t// and verified using the accompanying EncryptedCredentials.\n\t\tSelfie *PassportFile `json:\"selfie,omitempty\"`\n\t}\n\n\t// EncryptedCredentials contains data required for decrypting and\n\t// authenticating EncryptedPassportElement. See the Telegram Passport\n\t// Documentation for a complete description of the data decryption and\n\t// authentication processes.\n\tEncryptedCredentials struct {\n\t\t// Base64-encoded encrypted JSON-serialized data with unique user's\n\t\t// payload, data hashes and secrets required for EncryptedPassportElement\n\t\t// decryption and authentication\n\t\tData string `json:\"data\"`\n\n\t\t// Base64-encoded data hash for data authentication\n\t\tHash string `json:\"hash\"`\n\n\t\t// Base64-encoded secret, encrypted with the bot's public RSA key,\n\t\t// required for data decryption\n\t\tSecret string `json:\"secret\"`\n\t}\n\n\t// PassportElementError represents an error in the Telegram Passport element\n\t// which was submitted that should be resolved by the user.\n\tPassportElementError interface{}\n\n\t// PassportElementErrorDataField represents an issue in one of the data\n\t// fields that was provided by the user. The error is considered resolved\n\t// when the field's value changes.\n\tPassportElementErrorDataField struct {\n\t\t// Error source, must be data\n\t\tSource string `json:\"source\"`\n\n\t\t// The section of the user's Telegram Passport which has the error, one\n\t\t// of \"personal_details\", \"passport\", \"driver_license\", \"identity_card\",\n\t\t// \"internal_passport\", \"address\"\n\t\tType string `json:\"type\"`\n\n\t\t// Name of the data field which has the error\n\t\tFieldName string `json:\"field_name\"`\n\n\t\t// Base64-encoded data hash\n\t\tDataHash string `json:\"data_hash\"`\n\n\t\t// Error message\n\t\tMessage string `json:\"message\"`\n\t}\n\n\t// PassportElementErrorFrontSide represents an issue with the front side of\n\t// a document. The error is considered resolved when the file with the front\n\t// side of the document changes.\n\tPassportElementErrorFrontSide struct {\n\t\t// Error source, must be front_side\n\t\tSource string `json:\"source\"`\n\n\t\t// The section of the user's Telegram Passport which has the issue, one\n\t\t// of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\"\n\t\tType string `json:\"type\"`\n\n\t\t// Base64-encoded hash of the file with the front side of the document\n\t\tFileHash string `json:\"file_hash\"`\n\n\t\t// Error message\n\t\tMessage string `json:\"message\"`\n\t}\n\n\t// PassportElementErrorReverseSide represents an issue with the reverse side\n\t// of a document. The error is considered resolved when the file with reverse\n\t// side of the document changes.\n\tPassportElementErrorReverseSide struct {\n\t\t// Error source, must be reverse_side\n\t\tSource string `json:\"source\"`\n\n\t\t// The section of the user's Telegram Passport which has the issue, one\n\t\t// of \"driver_license\", \"identity_card\"\n\t\tType string `json:\"type\"`\n\n\t\t// Base64-encoded hash of the file with the reverse side of the document\n\t\tFileHash string `json:\"file_hash\"`\n\n\t\t// Error message\n\t\tMessage string `json:\"message\"`\n\t}\n\n\t// PassportElementErrorSelfie represents an issue with the selfie with a\n\t// document. The error is considered resolved when the file with the selfie\n\t// changes.\n\tPassportElementErrorSelfie struct {\n\t\t// Error source, must be selfie\n\t\tSource string `json:\"source\"`\n\n\t\t// The section of the user's Telegram Passport which has the issue, one\n\t\t// of \"passport\", \"driver_license\", \"identity_card\", \"internal_passport\"\n\t\tType string `json:\"type\"`\n\n\t\t// Base64-encoded hash of the file with the selfie\n\t\tFileHash string `json:\"file_hash\"`\n\n\t\t// Error message\n\t\tMessage string `json:\"message\"`\n\t}\n\n\t// PassportElementErrorFile represents an issue with a document scan. The\n\t// error is considered resolved when the file with the document scan changes.\n\tPassportElementErrorFile struct {\n\t\t// Error source, must be a file\n\t\tSource string `json:\"source\"`\n\n\t\t// The section of the user's Telegram Passport which has the issue, one\n\t\t// of \"utility_bill\", \"bank_statement\", \"rental_agreement\",\n\t\t// \"passport_registration\", \"temporary_registration\"\n\t\tType string `json:\"type\"`\n\n\t\t// Base64-encoded file hash\n\t\tFileHash string `json:\"file_hash\"`\n\n\t\t// Error message\n\t\tMessage string `json:\"message\"`\n\t}\n\n\t// PassportElementErrorFiles represents an issue with a list of scans. The\n\t// error is considered resolved when the list of files containing the scans\n\t// changes.\n\tPassportElementErrorFiles struct {\n\t\t// Error source, must be files\n\t\tSource string `json:\"source\"`\n\n\t\t// The section of the user's Telegram Passport which has the issue, one\n\t\t// of \"utility_bill\", \"bank_statement\", \"rental_agreement\",\n\t\t// \"passport_registration\", \"temporary_registration\"\n\t\tType string `json:\"type\"`\n\n\t\t// List of base64-encoded file hashes\n\t\tFileHashes []string `json:\"file_hashes\"`\n\n\t\t// Error message\n\t\tMessage string `json:\"message\"`\n\t}\n\n\t// Credentials contains encrypted data.\n\tCredentials struct {\n\t\tData SecureData `json:\"secure_data\"`\n\t\t// Nonce the same nonce given in the request\n\t\tNonce string `json:\"nonce\"`\n\t}\n\n\t// SecureData is a map of the fields and their encrypted values.\n\tSecureData map[string]*SecureValue\n\t// PersonalDetails       *SecureValue `json:\"personal_details\"`\n\t// Passport              *SecureValue `json:\"passport\"`\n\t// InternalPassport      *SecureValue `json:\"internal_passport\"`\n\t// DriverLicense         *SecureValue `json:\"driver_license\"`\n\t// IdentityCard          *SecureValue `json:\"identity_card\"`\n\t// Address               *SecureValue `json:\"address\"`\n\t// UtilityBill           *SecureValue `json:\"utility_bill\"`\n\t// BankStatement         *SecureValue `json:\"bank_statement\"`\n\t// RentalAgreement       *SecureValue `json:\"rental_agreement\"`\n\t// PassportRegistration  *SecureValue `json:\"passport_registration\"`\n\t// TemporaryRegistration *SecureValue `json:\"temporary_registration\"`\n\n\t// SecureValue contains encrypted values for a SecureData item.\n\tSecureValue struct {\n\t\tData        *DataCredentials   `json:\"data\"`\n\t\tFrontSide   *FileCredentials   `json:\"front_side\"`\n\t\tReverseSide *FileCredentials   `json:\"reverse_side\"`\n\t\tSelfie      *FileCredentials   `json:\"selfie\"`\n\t\tTranslation []*FileCredentials `json:\"translation\"`\n\t\tFiles       []*FileCredentials `json:\"files\"`\n\t}\n\n\t// DataCredentials contains information required to decrypt data.\n\tDataCredentials struct {\n\t\t// DataHash checksum of encrypted data\n\t\tDataHash string `json:\"data_hash\"`\n\t\t// Secret of encrypted data\n\t\tSecret string `json:\"secret\"`\n\t}\n\n\t// FileCredentials contains information required to decrypt files.\n\tFileCredentials struct {\n\t\t// FileHash checksum of encrypted data\n\t\tFileHash string `json:\"file_hash\"`\n\t\t// Secret of encrypted data\n\t\tSecret string `json:\"secret\"`\n\t}\n\n\t// PersonalDetails https://core.telegram.org/passport#personaldetails\n\tPersonalDetails struct {\n\t\tFirstName            string `json:\"first_name\"`\n\t\tLastName             string `json:\"last_name\"`\n\t\tMiddleName           string `json:\"middle_name\"`\n\t\tBirthDate            string `json:\"birth_date\"`\n\t\tGender               string `json:\"gender\"`\n\t\tCountryCode          string `json:\"country_code\"`\n\t\tResidenceCountryCode string `json:\"residence_country_code\"`\n\t\tFirstNameNative      string `json:\"first_name_native\"`\n\t\tLastNameNative       string `json:\"last_name_native\"`\n\t\tMiddleNameNative     string `json:\"middle_name_native\"`\n\t}\n\n\t// IDDocumentData https://core.telegram.org/passport#iddocumentdata\n\tIDDocumentData struct {\n\t\tDocumentNumber string `json:\"document_no\"`\n\t\tExpiryDate     string `json:\"expiry_date\"`\n\t}\n)\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "types.go",
          "type": "blob",
          "size": 116.4765625,
          "content": "package tgbotapi\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n)\n\n// APIResponse is a response from the Telegram API with the result\n// stored raw.\ntype APIResponse struct {\n\tOk          bool                `json:\"ok\"`\n\tResult      json.RawMessage     `json:\"result,omitempty\"`\n\tErrorCode   int                 `json:\"error_code,omitempty\"`\n\tDescription string              `json:\"description,omitempty\"`\n\tParameters  *ResponseParameters `json:\"parameters,omitempty\"`\n}\n\n// Error is an error containing extra information returned by the Telegram API.\ntype Error struct {\n\tCode    int\n\tMessage string\n\tResponseParameters\n}\n\n// Error message string.\nfunc (e Error) Error() string {\n\treturn e.Message\n}\n\n// Update is an update response, from GetUpdates.\ntype Update struct {\n\t// UpdateID is the update's unique identifier.\n\t// Update identifiers start from a certain positive number and increase\n\t// sequentially.\n\t// This ID becomes especially handy if you're using Webhooks,\n\t// since it allows you to ignore repeated updates or to restore\n\t// the correct update sequence, should they get out of order.\n\t// If there are no new updates for at least a week, then identifier\n\t// of the next update will be chosen randomly instead of sequentially.\n\tUpdateID int `json:\"update_id\"`\n\t// Message new incoming message of any kind — text, photo, sticker, etc.\n\t//\n\t// optional\n\tMessage *Message `json:\"message,omitempty\"`\n\t// EditedMessage new version of a message that is known to the bot and was\n\t// edited\n\t//\n\t// optional\n\tEditedMessage *Message `json:\"edited_message,omitempty\"`\n\t// ChannelPost new version of a message that is known to the bot and was\n\t// edited\n\t//\n\t// optional\n\tChannelPost *Message `json:\"channel_post,omitempty\"`\n\t// EditedChannelPost new incoming channel post of any kind — text, photo,\n\t// sticker, etc.\n\t//\n\t// optional\n\tEditedChannelPost *Message `json:\"edited_channel_post,omitempty\"`\n\t// InlineQuery new incoming inline query\n\t//\n\t// optional\n\tInlineQuery *InlineQuery `json:\"inline_query,omitempty\"`\n\t// ChosenInlineResult is the result of an inline query\n\t// that was chosen by a user and sent to their chat partner.\n\t// Please see our documentation on the feedback collecting\n\t// for details on how to enable these updates for your bot.\n\t//\n\t// optional\n\tChosenInlineResult *ChosenInlineResult `json:\"chosen_inline_result,omitempty\"`\n\t// CallbackQuery new incoming callback query\n\t//\n\t// optional\n\tCallbackQuery *CallbackQuery `json:\"callback_query,omitempty\"`\n\t// ShippingQuery new incoming shipping query. Only for invoices with\n\t// flexible price\n\t//\n\t// optional\n\tShippingQuery *ShippingQuery `json:\"shipping_query,omitempty\"`\n\t// PreCheckoutQuery new incoming pre-checkout query. Contains full\n\t// information about checkout\n\t//\n\t// optional\n\tPreCheckoutQuery *PreCheckoutQuery `json:\"pre_checkout_query,omitempty\"`\n\t// Pool new poll state. Bots receive only updates about stopped polls and\n\t// polls, which are sent by the bot\n\t//\n\t// optional\n\tPoll *Poll `json:\"poll,omitempty\"`\n\t// PollAnswer user changed their answer in a non-anonymous poll. Bots\n\t// receive new votes only in polls that were sent by the bot itself.\n\t//\n\t// optional\n\tPollAnswer *PollAnswer `json:\"poll_answer,omitempty\"`\n\t// MyChatMember is the bot's chat member status was updated in a chat. For\n\t// private chats, this update is received only when the bot is blocked or\n\t// unblocked by the user.\n\t//\n\t// optional\n\tMyChatMember *ChatMemberUpdated `json:\"my_chat_member,omitempty\"`\n\t// ChatMember is a chat member's status was updated in a chat. The bot must\n\t// be an administrator in the chat and must explicitly specify \"chat_member\"\n\t// in the list of allowed_updates to receive these updates.\n\t//\n\t// optional\n\tChatMember *ChatMemberUpdated `json:\"chat_member,omitempty\"`\n\t// ChatJoinRequest is a request to join the chat has been sent. The bot must\n\t// have the can_invite_users administrator right in the chat to receive\n\t// these updates.\n\t//\n\t// optional\n\tChatJoinRequest *ChatJoinRequest `json:\"chat_join_request,omitempty\"`\n}\n\n// SentFrom returns the user who sent an update. Can be nil, if Telegram did not provide information\n// about the user in the update object.\nfunc (u *Update) SentFrom() *User {\n\tswitch {\n\tcase u.Message != nil:\n\t\treturn u.Message.From\n\tcase u.EditedMessage != nil:\n\t\treturn u.EditedMessage.From\n\tcase u.InlineQuery != nil:\n\t\treturn u.InlineQuery.From\n\tcase u.ChosenInlineResult != nil:\n\t\treturn u.ChosenInlineResult.From\n\tcase u.CallbackQuery != nil:\n\t\treturn u.CallbackQuery.From\n\tcase u.ShippingQuery != nil:\n\t\treturn u.ShippingQuery.From\n\tcase u.PreCheckoutQuery != nil:\n\t\treturn u.PreCheckoutQuery.From\n\tdefault:\n\t\treturn nil\n\t}\n}\n\n// CallbackData returns the callback query data, if it exists.\nfunc (u *Update) CallbackData() string {\n\tif u.CallbackQuery != nil {\n\t\treturn u.CallbackQuery.Data\n\t}\n\treturn \"\"\n}\n\n// FromChat returns the chat where an update occurred.\nfunc (u *Update) FromChat() *Chat {\n\tswitch {\n\tcase u.Message != nil:\n\t\treturn u.Message.Chat\n\tcase u.EditedMessage != nil:\n\t\treturn u.EditedMessage.Chat\n\tcase u.ChannelPost != nil:\n\t\treturn u.ChannelPost.Chat\n\tcase u.EditedChannelPost != nil:\n\t\treturn u.EditedChannelPost.Chat\n\tcase u.CallbackQuery != nil:\n\t\treturn u.CallbackQuery.Message.Chat\n\tdefault:\n\t\treturn nil\n\t}\n}\n\n// UpdatesChannel is the channel for getting updates.\ntype UpdatesChannel <-chan Update\n\n// Clear discards all unprocessed incoming updates.\nfunc (ch UpdatesChannel) Clear() {\n\tfor len(ch) != 0 {\n\t\t<-ch\n\t}\n}\n\n// User represents a Telegram user or bot.\ntype User struct {\n\t// ID is a unique identifier for this user or bot\n\tID int64 `json:\"id\"`\n\t// IsBot true, if this user is a bot\n\t//\n\t// optional\n\tIsBot bool `json:\"is_bot,omitempty\"`\n\t// IsPremium true, if user has Telegram Premium\n\t//\n\t// optional\n\tIsPremium bool `json:\"is_premium,omitempty\"`\n\t// FirstName user's or bot's first name\n\tFirstName string `json:\"first_name\"`\n\t// LastName user's or bot's last name\n\t//\n\t// optional\n\tLastName string `json:\"last_name,omitempty\"`\n\t// UserName user's or bot's username\n\t//\n\t// optional\n\tUserName string `json:\"username,omitempty\"`\n\t// LanguageCode IETF language tag of the user's language\n\t// more info: https://en.wikipedia.org/wiki/IETF_language_tag\n\t//\n\t// optional\n\tLanguageCode string `json:\"language_code,omitempty\"`\n\t// CanJoinGroups is true, if the bot can be invited to groups.\n\t// Returned only in getMe.\n\t//\n\t// optional\n\tCanJoinGroups bool `json:\"can_join_groups,omitempty\"`\n\t// CanReadAllGroupMessages is true, if privacy mode is disabled for the bot.\n\t// Returned only in getMe.\n\t//\n\t// optional\n\tCanReadAllGroupMessages bool `json:\"can_read_all_group_messages,omitempty\"`\n\t// SupportsInlineQueries is true, if the bot supports inline queries.\n\t// Returned only in getMe.\n\t//\n\t// optional\n\tSupportsInlineQueries bool `json:\"supports_inline_queries,omitempty\"`\n}\n\n// String displays a simple text version of a user.\n//\n// It is normally a user's username, but falls back to a first/last\n// name as available.\nfunc (u *User) String() string {\n\tif u == nil {\n\t\treturn \"\"\n\t}\n\tif u.UserName != \"\" {\n\t\treturn u.UserName\n\t}\n\n\tname := u.FirstName\n\tif u.LastName != \"\" {\n\t\tname += \" \" + u.LastName\n\t}\n\n\treturn name\n}\n\n// Chat represents a chat.\ntype Chat struct {\n\t// ID is a unique identifier for this chat\n\tID int64 `json:\"id\"`\n\t// Type of chat, can be either “private”, “group”, “supergroup” or “channel”\n\tType string `json:\"type\"`\n\t// Title for supergroups, channels and group chats\n\t//\n\t// optional\n\tTitle string `json:\"title,omitempty\"`\n\t// UserName for private chats, supergroups and channels if available\n\t//\n\t// optional\n\tUserName string `json:\"username,omitempty\"`\n\t// FirstName of the other party in a private chat\n\t//\n\t// optional\n\tFirstName string `json:\"first_name,omitempty\"`\n\t// LastName of the other party in a private chat\n\t//\n\t// optional\n\tLastName string `json:\"last_name,omitempty\"`\n\t// Photo is a chat photo\n\tPhoto *ChatPhoto `json:\"photo\"`\n\t// Bio is the bio of the other party in a private chat. Returned only in\n\t// getChat\n\t//\n\t// optional\n\tBio string `json:\"bio,omitempty\"`\n\t// HasPrivateForwards is true if privacy settings of the other party in the\n\t// private chat allows to use tg://user?id=<user_id> links only in chats\n\t// with the user. Returned only in getChat.\n\t//\n\t// optional\n\tHasPrivateForwards bool `json:\"has_private_forwards,omitempty\"`\n\t// Description for groups, supergroups and channel chats\n\t//\n\t// optional\n\tDescription string `json:\"description,omitempty\"`\n\t// InviteLink is a chat invite link, for groups, supergroups and channel chats.\n\t// Each administrator in a chat generates their own invite links,\n\t// so the bot must first generate the link using exportChatInviteLink\n\t//\n\t// optional\n\tInviteLink string `json:\"invite_link,omitempty\"`\n\t// PinnedMessage is the pinned message, for groups, supergroups and channels\n\t//\n\t// optional\n\tPinnedMessage *Message `json:\"pinned_message,omitempty\"`\n\t// Permissions are default chat member permissions, for groups and\n\t// supergroups. Returned only in getChat.\n\t//\n\t// optional\n\tPermissions *ChatPermissions `json:\"permissions,omitempty\"`\n\t// SlowModeDelay is for supergroups, the minimum allowed delay between\n\t// consecutive messages sent by each unprivileged user. Returned only in\n\t// getChat.\n\t//\n\t// optional\n\tSlowModeDelay int `json:\"slow_mode_delay,omitempty\"`\n\t// MessageAutoDeleteTime is the time after which all messages sent to the\n\t// chat will be automatically deleted; in seconds. Returned only in getChat.\n\t//\n\t// optional\n\tMessageAutoDeleteTime int `json:\"message_auto_delete_time,omitempty\"`\n\t// HasProtectedContent is true if messages from the chat can't be forwarded\n\t// to other chats. Returned only in getChat.\n\t//\n\t// optional\n\tHasProtectedContent bool `json:\"has_protected_content,omitempty\"`\n\t// StickerSetName is for supergroups, name of group sticker set.Returned\n\t// only in getChat.\n\t//\n\t// optional\n\tStickerSetName string `json:\"sticker_set_name,omitempty\"`\n\t// CanSetStickerSet is true, if the bot can change the group sticker set.\n\t// Returned only in getChat.\n\t//\n\t// optional\n\tCanSetStickerSet bool `json:\"can_set_sticker_set,omitempty\"`\n\t// LinkedChatID is a unique identifier for the linked chat, i.e. the\n\t// discussion group identifier for a channel and vice versa; for supergroups\n\t// and channel chats.\n\t//\n\t// optional\n\tLinkedChatID int64 `json:\"linked_chat_id,omitempty\"`\n\t// Location is for supergroups, the location to which the supergroup is\n\t// connected. Returned only in getChat.\n\t//\n\t// optional\n\tLocation *ChatLocation `json:\"location,omitempty\"`\n}\n\n// IsPrivate returns if the Chat is a private conversation.\nfunc (c Chat) IsPrivate() bool {\n\treturn c.Type == \"private\"\n}\n\n// IsGroup returns if the Chat is a group.\nfunc (c Chat) IsGroup() bool {\n\treturn c.Type == \"group\"\n}\n\n// IsSuperGroup returns if the Chat is a supergroup.\nfunc (c Chat) IsSuperGroup() bool {\n\treturn c.Type == \"supergroup\"\n}\n\n// IsChannel returns if the Chat is a channel.\nfunc (c Chat) IsChannel() bool {\n\treturn c.Type == \"channel\"\n}\n\n// ChatConfig returns a ChatConfig struct for chat related methods.\nfunc (c Chat) ChatConfig() ChatConfig {\n\treturn ChatConfig{ChatID: c.ID}\n}\n\n// Message represents a message.\ntype Message struct {\n\t// MessageID is a unique message identifier inside this chat\n\tMessageID int `json:\"message_id\"`\n\t// From is a sender, empty for messages sent to channels;\n\t//\n\t// optional\n\tFrom *User `json:\"from,omitempty\"`\n\t// SenderChat is the sender of the message, sent on behalf of a chat. The\n\t// channel itself for channel messages. The supergroup itself for messages\n\t// from anonymous group administrators. The linked channel for messages\n\t// automatically forwarded to the discussion group\n\t//\n\t// optional\n\tSenderChat *Chat `json:\"sender_chat,omitempty\"`\n\t// Date of the message was sent in Unix time\n\tDate int `json:\"date\"`\n\t// Chat is the conversation the message belongs to\n\tChat *Chat `json:\"chat\"`\n\t// ForwardFrom for forwarded messages, sender of the original message;\n\t//\n\t// optional\n\tForwardFrom *User `json:\"forward_from,omitempty\"`\n\t// ForwardFromChat for messages forwarded from channels,\n\t// information about the original channel;\n\t//\n\t// optional\n\tForwardFromChat *Chat `json:\"forward_from_chat,omitempty\"`\n\t// ForwardFromMessageID for messages forwarded from channels,\n\t// identifier of the original message in the channel;\n\t//\n\t// optional\n\tForwardFromMessageID int `json:\"forward_from_message_id,omitempty\"`\n\t// ForwardSignature for messages forwarded from channels, signature of the\n\t// post author if present\n\t//\n\t// optional\n\tForwardSignature string `json:\"forward_signature,omitempty\"`\n\t// ForwardSenderName is the sender's name for messages forwarded from users\n\t// who disallow adding a link to their account in forwarded messages\n\t//\n\t// optional\n\tForwardSenderName string `json:\"forward_sender_name,omitempty\"`\n\t// ForwardDate for forwarded messages, date the original message was sent in Unix time;\n\t//\n\t// optional\n\tForwardDate int `json:\"forward_date,omitempty\"`\n\t// IsAutomaticForward is true if the message is a channel post that was\n\t// automatically forwarded to the connected discussion group.\n\t//\n\t// optional\n\tIsAutomaticForward bool `json:\"is_automatic_forward,omitempty\"`\n\t// ReplyToMessage for replies, the original message.\n\t// Note that the Message object in this field will not contain further ReplyToMessage fields\n\t// even if it itself is a reply;\n\t//\n\t// optional\n\tReplyToMessage *Message `json:\"reply_to_message,omitempty\"`\n\t// ViaBot through which the message was sent;\n\t//\n\t// optional\n\tViaBot *User `json:\"via_bot,omitempty\"`\n\t// EditDate of the message was last edited in Unix time;\n\t//\n\t// optional\n\tEditDate int `json:\"edit_date,omitempty\"`\n\t// HasProtectedContent is true if the message can't be forwarded.\n\t//\n\t// optional\n\tHasProtectedContent bool `json:\"has_protected_content,omitempty\"`\n\t// MediaGroupID is the unique identifier of a media message group this message belongs to;\n\t//\n\t// optional\n\tMediaGroupID string `json:\"media_group_id,omitempty\"`\n\t// AuthorSignature is the signature of the post author for messages in channels;\n\t//\n\t// optional\n\tAuthorSignature string `json:\"author_signature,omitempty\"`\n\t// Text is for text messages, the actual UTF-8 text of the message, 0-4096 characters;\n\t//\n\t// optional\n\tText string `json:\"text,omitempty\"`\n\t// Entities are for text messages, special entities like usernames,\n\t// URLs, bot commands, etc. that appear in the text;\n\t//\n\t// optional\n\tEntities []MessageEntity `json:\"entities,omitempty\"`\n\t// Animation message is an animation, information about the animation.\n\t// For backward compatibility, when this field is set, the document field will also be set;\n\t//\n\t// optional\n\tAnimation *Animation `json:\"animation,omitempty\"`\n\t// PremiumAnimation message is an animation, information about the animation.\n\t// For backward compatibility, when this field is set, the document field will also be set;\n\t//\n\t// optional\n\tPremiumAnimation *Animation `json:\"premium_animation,omitempty\"`\n\t// Audio message is an audio file, information about the file;\n\t//\n\t// optional\n\tAudio *Audio `json:\"audio,omitempty\"`\n\t// Document message is a general file, information about the file;\n\t//\n\t// optional\n\tDocument *Document `json:\"document,omitempty\"`\n\t// Photo message is a photo, available sizes of the photo;\n\t//\n\t// optional\n\tPhoto []PhotoSize `json:\"photo,omitempty\"`\n\t// Sticker message is a sticker, information about the sticker;\n\t//\n\t// optional\n\tSticker *Sticker `json:\"sticker,omitempty\"`\n\t// Video message is a video, information about the video;\n\t//\n\t// optional\n\tVideo *Video `json:\"video,omitempty\"`\n\t// VideoNote message is a video note, information about the video message;\n\t//\n\t// optional\n\tVideoNote *VideoNote `json:\"video_note,omitempty\"`\n\t// Voice message is a voice message, information about the file;\n\t//\n\t// optional\n\tVoice *Voice `json:\"voice,omitempty\"`\n\t// Caption for the animation, audio, document, photo, video or voice, 0-1024 characters;\n\t//\n\t// optional\n\tCaption string `json:\"caption,omitempty\"`\n\t// CaptionEntities;\n\t//\n\t// optional\n\tCaptionEntities []MessageEntity `json:\"caption_entities,omitempty\"`\n\t// Contact message is a shared contact, information about the contact;\n\t//\n\t// optional\n\tContact *Contact `json:\"contact,omitempty\"`\n\t// Dice is a dice with random value;\n\t//\n\t// optional\n\tDice *Dice `json:\"dice,omitempty\"`\n\t// Game message is a game, information about the game;\n\t//\n\t// optional\n\tGame *Game `json:\"game,omitempty\"`\n\t// Poll is a native poll, information about the poll;\n\t//\n\t// optional\n\tPoll *Poll `json:\"poll,omitempty\"`\n\t// Venue message is a venue, information about the venue.\n\t// For backward compatibility, when this field is set, the location field\n\t// will also be set;\n\t//\n\t// optional\n\tVenue *Venue `json:\"venue,omitempty\"`\n\t// Location message is a shared location, information about the location;\n\t//\n\t// optional\n\tLocation *Location `json:\"location,omitempty\"`\n\t// NewChatMembers that were added to the group or supergroup\n\t// and information about them (the bot itself may be one of these members);\n\t//\n\t// optional\n\tNewChatMembers []User `json:\"new_chat_members,omitempty\"`\n\t// LeftChatMember is a member was removed from the group,\n\t// information about them (this member may be the bot itself);\n\t//\n\t// optional\n\tLeftChatMember *User `json:\"left_chat_member,omitempty\"`\n\t// NewChatTitle is a chat title was changed to this value;\n\t//\n\t// optional\n\tNewChatTitle string `json:\"new_chat_title,omitempty\"`\n\t// NewChatPhoto is a chat photo was change to this value;\n\t//\n\t// optional\n\tNewChatPhoto []PhotoSize `json:\"new_chat_photo,omitempty\"`\n\t// DeleteChatPhoto is a service message: the chat photo was deleted;\n\t//\n\t// optional\n\tDeleteChatPhoto bool `json:\"delete_chat_photo,omitempty\"`\n\t// GroupChatCreated is a service message: the group has been created;\n\t//\n\t// optional\n\tGroupChatCreated bool `json:\"group_chat_created,omitempty\"`\n\t// SuperGroupChatCreated is a service message: the supergroup has been created.\n\t// This field can't be received in a message coming through updates,\n\t// because bot can't be a member of a supergroup when it is created.\n\t// It can only be found in ReplyToMessage if someone replies to a very first message\n\t// in a directly created supergroup;\n\t//\n\t// optional\n\tSuperGroupChatCreated bool `json:\"supergroup_chat_created,omitempty\"`\n\t// ChannelChatCreated is a service message: the channel has been created.\n\t// This field can't be received in a message coming through updates,\n\t// because bot can't be a member of a channel when it is created.\n\t// It can only be found in ReplyToMessage\n\t// if someone replies to a very first message in a channel;\n\t//\n\t// optional\n\tChannelChatCreated bool `json:\"channel_chat_created,omitempty\"`\n\t// MessageAutoDeleteTimerChanged is a service message: auto-delete timer\n\t// settings changed in the chat.\n\t//\n\t// optional\n\tMessageAutoDeleteTimerChanged *MessageAutoDeleteTimerChanged `json:\"message_auto_delete_timer_changed,omitempty\"`\n\t// MigrateToChatID is the group has been migrated to a supergroup with the specified identifier.\n\t// This number may be greater than 32 bits and some programming languages\n\t// may have difficulty/silent defects in interpreting it.\n\t// But it is smaller than 52 bits, so a signed 64-bit integer\n\t// or double-precision float type are safe for storing this identifier;\n\t//\n\t// optional\n\tMigrateToChatID int64 `json:\"migrate_to_chat_id,omitempty\"`\n\t// MigrateFromChatID is the supergroup has been migrated from a group with the specified identifier.\n\t// This number may be greater than 32 bits and some programming languages\n\t// may have difficulty/silent defects in interpreting it.\n\t// But it is smaller than 52 bits, so a signed 64-bit integer\n\t// or double-precision float type are safe for storing this identifier;\n\t//\n\t// optional\n\tMigrateFromChatID int64 `json:\"migrate_from_chat_id,omitempty\"`\n\t// PinnedMessage is a specified message was pinned.\n\t// Note that the Message object in this field will not contain further ReplyToMessage\n\t// fields even if it is itself a reply;\n\t//\n\t// optional\n\tPinnedMessage *Message `json:\"pinned_message,omitempty\"`\n\t// Invoice message is an invoice for a payment;\n\t//\n\t// optional\n\tInvoice *Invoice `json:\"invoice,omitempty\"`\n\t// SuccessfulPayment message is a service message about a successful payment,\n\t// information about the payment;\n\t//\n\t// optional\n\tSuccessfulPayment *SuccessfulPayment `json:\"successful_payment,omitempty\"`\n\t// ConnectedWebsite is the domain name of the website on which the user has\n\t// logged in;\n\t//\n\t// optional\n\tConnectedWebsite string `json:\"connected_website,omitempty\"`\n\t// PassportData is a Telegram Passport data;\n\t//\n\t// optional\n\tPassportData *PassportData `json:\"passport_data,omitempty\"`\n\t// ProximityAlertTriggered is a service message. A user in the chat\n\t// triggered another user's proximity alert while sharing Live Location\n\t//\n\t// optional\n\tProximityAlertTriggered *ProximityAlertTriggered `json:\"proximity_alert_triggered,omitempty\"`\n\t// VideoChatScheduled is a service message: video chat scheduled.\n\t//\n\t// optional\n\tVideoChatScheduled *VideoChatScheduled `json:\"video_chat_scheduled,omitempty\"`\n\t// VideoChatStarted is a service message: video chat started.\n\t//\n\t// optional\n\tVideoChatStarted *VideoChatStarted `json:\"video_chat_started,omitempty\"`\n\t// VideoChatEnded is a service message: video chat ended.\n\t//\n\t// optional\n\tVideoChatEnded *VideoChatEnded `json:\"video_chat_ended,omitempty\"`\n\t// VideoChatParticipantsInvited is a service message: new participants\n\t// invited to a video chat.\n\t//\n\t// optional\n\tVideoChatParticipantsInvited *VideoChatParticipantsInvited `json:\"video_chat_participants_invited,omitempty\"`\n\t// WebAppData is a service message: data sent by a Web App.\n\t//\n\t// optional\n\tWebAppData *WebAppData `json:\"web_app_data,omitempty\"`\n\t// ReplyMarkup is the Inline keyboard attached to the message.\n\t// login_url buttons are represented as ordinary url buttons.\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n}\n\n// Time converts the message timestamp into a Time.\nfunc (m *Message) Time() time.Time {\n\treturn time.Unix(int64(m.Date), 0)\n}\n\n// IsCommand returns true if message starts with a \"bot_command\" entity.\nfunc (m *Message) IsCommand() bool {\n\tif m.Entities == nil || len(m.Entities) == 0 {\n\t\treturn false\n\t}\n\n\tentity := m.Entities[0]\n\treturn entity.Offset == 0 && entity.IsCommand()\n}\n\n// Command checks if the message was a command and if it was, returns the\n// command. If the Message was not a command, it returns an empty string.\n//\n// If the command contains the at name syntax, it is removed. Use\n// CommandWithAt() if you do not want that.\nfunc (m *Message) Command() string {\n\tcommand := m.CommandWithAt()\n\n\tif i := strings.Index(command, \"@\"); i != -1 {\n\t\tcommand = command[:i]\n\t}\n\n\treturn command\n}\n\n// CommandWithAt checks if the message was a command and if it was, returns the\n// command. If the Message was not a command, it returns an empty string.\n//\n// If the command contains the at name syntax, it is not removed. Use Command()\n// if you want that.\nfunc (m *Message) CommandWithAt() string {\n\tif !m.IsCommand() {\n\t\treturn \"\"\n\t}\n\n\t// IsCommand() checks that the message begins with a bot_command entity\n\tentity := m.Entities[0]\n\treturn m.Text[1:entity.Length]\n}\n\n// CommandArguments checks if the message was a command and if it was,\n// returns all text after the command name. If the Message was not a\n// command, it returns an empty string.\n//\n// Note: The first character after the command name is omitted:\n// - \"/foo bar baz\" yields \"bar baz\", not \" bar baz\"\n// - \"/foo-bar baz\" yields \"bar baz\", too\n// Even though the latter is not a command conforming to the spec, the API\n// marks \"/foo\" as command entity.\nfunc (m *Message) CommandArguments() string {\n\tif !m.IsCommand() {\n\t\treturn \"\"\n\t}\n\n\t// IsCommand() checks that the message begins with a bot_command entity\n\tentity := m.Entities[0]\n\n\tif len(m.Text) == entity.Length {\n\t\treturn \"\" // The command makes up the whole message\n\t}\n\n\treturn m.Text[entity.Length+1:]\n}\n\n// MessageID represents a unique message identifier.\ntype MessageID struct {\n\tMessageID int `json:\"message_id\"`\n}\n\n// MessageEntity represents one special entity in a text message.\ntype MessageEntity struct {\n\t// Type of the entity.\n\t// Can be:\n\t//  “mention” (@username),\n\t//  “hashtag” (#hashtag),\n\t//  “cashtag” ($USD),\n\t//  “bot_command” (/start@jobs_bot),\n\t//  “url” (https://telegram.org),\n\t//  “email” (do-not-reply@telegram.org),\n\t//  “phone_number” (+1-212-555-0123),\n\t//  “bold” (bold text),\n\t//  “italic” (italic text),\n\t//  “underline” (underlined text),\n\t//  “strikethrough” (strikethrough text),\n\t//  \"spoiler\" (spoiler message),\n\t//  “code” (monowidth string),\n\t//  “pre” (monowidth block),\n\t//  “text_link” (for clickable text URLs),\n\t//  “text_mention” (for users without usernames)\n\tType string `json:\"type\"`\n\t// Offset in UTF-16 code units to the start of the entity\n\tOffset int `json:\"offset\"`\n\t// Length\n\tLength int `json:\"length\"`\n\t// URL for “text_link” only, url that will be opened after user taps on the text\n\t//\n\t// optional\n\tURL string `json:\"url,omitempty\"`\n\t// User for “text_mention” only, the mentioned user\n\t//\n\t// optional\n\tUser *User `json:\"user,omitempty\"`\n\t// Language for “pre” only, the programming language of the entity text\n\t//\n\t// optional\n\tLanguage string `json:\"language,omitempty\"`\n}\n\n// ParseURL attempts to parse a URL contained within a MessageEntity.\nfunc (e MessageEntity) ParseURL() (*url.URL, error) {\n\tif e.URL == \"\" {\n\t\treturn nil, errors.New(ErrBadURL)\n\t}\n\n\treturn url.Parse(e.URL)\n}\n\n// IsMention returns true if the type of the message entity is \"mention\" (@username).\nfunc (e MessageEntity) IsMention() bool {\n\treturn e.Type == \"mention\"\n}\n\n// IsTextMention returns true if the type of the message entity is \"text_mention\"\n// (At this time, the user field exists, and occurs when tagging a member without a username)\nfunc (e MessageEntity) IsTextMention() bool {\n\treturn e.Type == \"text_mention\"\n}\n\n// IsHashtag returns true if the type of the message entity is \"hashtag\".\nfunc (e MessageEntity) IsHashtag() bool {\n\treturn e.Type == \"hashtag\"\n}\n\n// IsCommand returns true if the type of the message entity is \"bot_command\".\nfunc (e MessageEntity) IsCommand() bool {\n\treturn e.Type == \"bot_command\"\n}\n\n// IsURL returns true if the type of the message entity is \"url\".\nfunc (e MessageEntity) IsURL() bool {\n\treturn e.Type == \"url\"\n}\n\n// IsEmail returns true if the type of the message entity is \"email\".\nfunc (e MessageEntity) IsEmail() bool {\n\treturn e.Type == \"email\"\n}\n\n// IsBold returns true if the type of the message entity is \"bold\" (bold text).\nfunc (e MessageEntity) IsBold() bool {\n\treturn e.Type == \"bold\"\n}\n\n// IsItalic returns true if the type of the message entity is \"italic\" (italic text).\nfunc (e MessageEntity) IsItalic() bool {\n\treturn e.Type == \"italic\"\n}\n\n// IsCode returns true if the type of the message entity is \"code\" (monowidth string).\nfunc (e MessageEntity) IsCode() bool {\n\treturn e.Type == \"code\"\n}\n\n// IsPre returns true if the type of the message entity is \"pre\" (monowidth block).\nfunc (e MessageEntity) IsPre() bool {\n\treturn e.Type == \"pre\"\n}\n\n// IsTextLink returns true if the type of the message entity is \"text_link\" (clickable text URL).\nfunc (e MessageEntity) IsTextLink() bool {\n\treturn e.Type == \"text_link\"\n}\n\n// PhotoSize represents one size of a photo or a file / sticker thumbnail.\ntype PhotoSize struct {\n\t// FileID identifier for this file, which can be used to download or reuse\n\t// the file\n\tFileID string `json:\"file_id\"`\n\t// FileUniqueID is the unique identifier for this file, which is supposed to\n\t// be the same over time and for different bots. Can't be used to download\n\t// or reuse the file.\n\tFileUniqueID string `json:\"file_unique_id\"`\n\t// Width photo width\n\tWidth int `json:\"width\"`\n\t// Height photo height\n\tHeight int `json:\"height\"`\n\t// FileSize file size\n\t//\n\t// optional\n\tFileSize int `json:\"file_size,omitempty\"`\n}\n\n// Animation represents an animation file.\ntype Animation struct {\n\t// FileID is the identifier for this file, which can be used to download or reuse\n\t// the file\n\tFileID string `json:\"file_id\"`\n\t// FileUniqueID is the unique identifier for this file, which is supposed to\n\t// be the same over time and for different bots. Can't be used to download\n\t// or reuse the file.\n\tFileUniqueID string `json:\"file_unique_id\"`\n\t// Width video width as defined by sender\n\tWidth int `json:\"width\"`\n\t// Height video height as defined by sender\n\tHeight int `json:\"height\"`\n\t// Duration of the video in seconds as defined by sender\n\tDuration int `json:\"duration\"`\n\t// Thumbnail animation thumbnail as defined by sender\n\t//\n\t// optional\n\tThumbnail *PhotoSize `json:\"thumb,omitempty\"`\n\t// FileName original animation filename as defined by sender\n\t//\n\t// optional\n\tFileName string `json:\"file_name,omitempty\"`\n\t// MimeType of the file as defined by sender\n\t//\n\t// optional\n\tMimeType string `json:\"mime_type,omitempty\"`\n\t// FileSize file size\n\t//\n\t// optional\n\tFileSize int `json:\"file_size,omitempty\"`\n}\n\n// Audio represents an audio file to be treated as music by the Telegram clients.\ntype Audio struct {\n\t// FileID is an identifier for this file, which can be used to download or\n\t// reuse the file\n\tFileID string `json:\"file_id\"`\n\t// FileUniqueID is the unique identifier for this file, which is supposed to\n\t// be the same over time and for different bots. Can't be used to download\n\t// or reuse the file.\n\tFileUniqueID string `json:\"file_unique_id\"`\n\t// Duration of the audio in seconds as defined by sender\n\tDuration int `json:\"duration\"`\n\t// Performer of the audio as defined by sender or by audio tags\n\t//\n\t// optional\n\tPerformer string `json:\"performer,omitempty\"`\n\t// Title of the audio as defined by sender or by audio tags\n\t//\n\t// optional\n\tTitle string `json:\"title,omitempty\"`\n\t// FileName is the original filename as defined by sender\n\t//\n\t// optional\n\tFileName string `json:\"file_name,omitempty\"`\n\t// MimeType of the file as defined by sender\n\t//\n\t// optional\n\tMimeType string `json:\"mime_type,omitempty\"`\n\t// FileSize file size\n\t//\n\t// optional\n\tFileSize int `json:\"file_size,omitempty\"`\n\t// Thumbnail is the album cover to which the music file belongs\n\t//\n\t// optional\n\tThumbnail *PhotoSize `json:\"thumb,omitempty\"`\n}\n\n// Document represents a general file.\ntype Document struct {\n\t// FileID is an identifier for this file, which can be used to download or\n\t// reuse the file\n\tFileID string `json:\"file_id\"`\n\t// FileUniqueID is the unique identifier for this file, which is supposed to\n\t// be the same over time and for different bots. Can't be used to download\n\t// or reuse the file.\n\tFileUniqueID string `json:\"file_unique_id\"`\n\t// Thumbnail document thumbnail as defined by sender\n\t//\n\t// optional\n\tThumbnail *PhotoSize `json:\"thumb,omitempty\"`\n\t// FileName original filename as defined by sender\n\t//\n\t// optional\n\tFileName string `json:\"file_name,omitempty\"`\n\t// MimeType  of the file as defined by sender\n\t//\n\t// optional\n\tMimeType string `json:\"mime_type,omitempty\"`\n\t// FileSize file size\n\t//\n\t// optional\n\tFileSize int `json:\"file_size,omitempty\"`\n}\n\n// Video represents a video file.\ntype Video struct {\n\t// FileID identifier for this file, which can be used to download or reuse\n\t// the file\n\tFileID string `json:\"file_id\"`\n\t// FileUniqueID is the unique identifier for this file, which is supposed to\n\t// be the same over time and for different bots. Can't be used to download\n\t// or reuse the file.\n\tFileUniqueID string `json:\"file_unique_id\"`\n\t// Width video width as defined by sender\n\tWidth int `json:\"width\"`\n\t// Height video height as defined by sender\n\tHeight int `json:\"height\"`\n\t// Duration of the video in seconds as defined by sender\n\tDuration int `json:\"duration\"`\n\t// Thumbnail video thumbnail\n\t//\n\t// optional\n\tThumbnail *PhotoSize `json:\"thumb,omitempty\"`\n\t// FileName is the original filename as defined by sender\n\t//\n\t// optional\n\tFileName string `json:\"file_name,omitempty\"`\n\t// MimeType of a file as defined by sender\n\t//\n\t// optional\n\tMimeType string `json:\"mime_type,omitempty\"`\n\t// FileSize file size\n\t//\n\t// optional\n\tFileSize int `json:\"file_size,omitempty\"`\n}\n\n// VideoNote object represents a video message.\ntype VideoNote struct {\n\t// FileID identifier for this file, which can be used to download or reuse the file\n\tFileID string `json:\"file_id\"`\n\t// FileUniqueID is the unique identifier for this file, which is supposed to\n\t// be the same over time and for different bots. Can't be used to download\n\t// or reuse the file.\n\tFileUniqueID string `json:\"file_unique_id\"`\n\t// Length video width and height (diameter of the video message) as defined by sender\n\tLength int `json:\"length\"`\n\t// Duration of the video in seconds as defined by sender\n\tDuration int `json:\"duration\"`\n\t// Thumbnail video thumbnail\n\t//\n\t// optional\n\tThumbnail *PhotoSize `json:\"thumb,omitempty\"`\n\t// FileSize file size\n\t//\n\t// optional\n\tFileSize int `json:\"file_size,omitempty\"`\n}\n\n// Voice represents a voice note.\ntype Voice struct {\n\t// FileID identifier for this file, which can be used to download or reuse the file\n\tFileID string `json:\"file_id\"`\n\t// FileUniqueID is the unique identifier for this file, which is supposed to\n\t// be the same over time and for different bots. Can't be used to download\n\t// or reuse the file.\n\tFileUniqueID string `json:\"file_unique_id\"`\n\t// Duration of the audio in seconds as defined by sender\n\tDuration int `json:\"duration\"`\n\t// MimeType of the file as defined by sender\n\t//\n\t// optional\n\tMimeType string `json:\"mime_type,omitempty\"`\n\t// FileSize file size\n\t//\n\t// optional\n\tFileSize int `json:\"file_size,omitempty\"`\n}\n\n// Contact represents a phone contact.\n//\n// Note that LastName and UserID may be empty.\ntype Contact struct {\n\t// PhoneNumber contact's phone number\n\tPhoneNumber string `json:\"phone_number\"`\n\t// FirstName contact's first name\n\tFirstName string `json:\"first_name\"`\n\t// LastName contact's last name\n\t//\n\t// optional\n\tLastName string `json:\"last_name,omitempty\"`\n\t// UserID contact's user identifier in Telegram\n\t//\n\t// optional\n\tUserID int64 `json:\"user_id,omitempty\"`\n\t// VCard is additional data about the contact in the form of a vCard.\n\t//\n\t// optional\n\tVCard string `json:\"vcard,omitempty\"`\n}\n\n// Dice represents an animated emoji that displays a random value.\ntype Dice struct {\n\t// Emoji on which the dice throw animation is based\n\tEmoji string `json:\"emoji\"`\n\t// Value of the dice\n\tValue int `json:\"value\"`\n}\n\n// PollOption contains information about one answer option in a poll.\ntype PollOption struct {\n\t// Text is the option text, 1-100 characters\n\tText string `json:\"text\"`\n\t// VoterCount is the number of users that voted for this option\n\tVoterCount int `json:\"voter_count\"`\n}\n\n// PollAnswer represents an answer of a user in a non-anonymous poll.\ntype PollAnswer struct {\n\t// PollID is the unique poll identifier\n\tPollID string `json:\"poll_id\"`\n\t// User who changed the answer to the poll\n\tUser User `json:\"user\"`\n\t// OptionIDs is the 0-based identifiers of poll options chosen by the user.\n\t// May be empty if user retracted vote.\n\tOptionIDs []int `json:\"option_ids\"`\n}\n\n// Poll contains information about a poll.\ntype Poll struct {\n\t// ID is the unique poll identifier\n\tID string `json:\"id\"`\n\t// Question is the poll question, 1-255 characters\n\tQuestion string `json:\"question\"`\n\t// Options is the list of poll options\n\tOptions []PollOption `json:\"options\"`\n\t// TotalVoterCount is the total numbers of users who voted in the poll\n\tTotalVoterCount int `json:\"total_voter_count\"`\n\t// IsClosed is if the poll is closed\n\tIsClosed bool `json:\"is_closed\"`\n\t// IsAnonymous is if the poll is anonymous\n\tIsAnonymous bool `json:\"is_anonymous\"`\n\t// Type is the poll type, currently can be \"regular\" or \"quiz\"\n\tType string `json:\"type\"`\n\t// AllowsMultipleAnswers is true, if the poll allows multiple answers\n\tAllowsMultipleAnswers bool `json:\"allows_multiple_answers\"`\n\t// CorrectOptionID is the 0-based identifier of the correct answer option.\n\t// Available only for polls in quiz mode, which are closed, or was sent (not\n\t// forwarded) by the bot or to the private chat with the bot.\n\t//\n\t// optional\n\tCorrectOptionID int `json:\"correct_option_id,omitempty\"`\n\t// Explanation is text that is shown when a user chooses an incorrect answer\n\t// or taps on the lamp icon in a quiz-style poll, 0-200 characters\n\t//\n\t// optional\n\tExplanation string `json:\"explanation,omitempty\"`\n\t// ExplanationEntities are special entities like usernames, URLs, bot\n\t// commands, etc. that appear in the explanation\n\t//\n\t// optional\n\tExplanationEntities []MessageEntity `json:\"explanation_entities,omitempty\"`\n\t// OpenPeriod is the amount of time in seconds the poll will be active\n\t// after creation\n\t//\n\t// optional\n\tOpenPeriod int `json:\"open_period,omitempty\"`\n\t// CloseDate is the point in time (unix timestamp) when the poll will be\n\t// automatically closed\n\t//\n\t// optional\n\tCloseDate int `json:\"close_date,omitempty\"`\n}\n\n// Location represents a point on the map.\ntype Location struct {\n\t// Longitude as defined by sender\n\tLongitude float64 `json:\"longitude\"`\n\t// Latitude as defined by sender\n\tLatitude float64 `json:\"latitude\"`\n\t// HorizontalAccuracy is the radius of uncertainty for the location,\n\t// measured in meters; 0-1500\n\t//\n\t// optional\n\tHorizontalAccuracy float64 `json:\"horizontal_accuracy,omitempty\"`\n\t// LivePeriod is time relative to the message sending date, during which the\n\t// location can be updated, in seconds. For active live locations only.\n\t//\n\t// optional\n\tLivePeriod int `json:\"live_period,omitempty\"`\n\t// Heading is the direction in which user is moving, in degrees; 1-360. For\n\t// active live locations only.\n\t//\n\t// optional\n\tHeading int `json:\"heading,omitempty\"`\n\t// ProximityAlertRadius is the maximum distance for proximity alerts about\n\t// approaching another chat member, in meters. For sent live locations only.\n\t//\n\t// optional\n\tProximityAlertRadius int `json:\"proximity_alert_radius,omitempty\"`\n}\n\n// Venue represents a venue.\ntype Venue struct {\n\t// Location is the venue location\n\tLocation Location `json:\"location\"`\n\t// Title is the name of the venue\n\tTitle string `json:\"title\"`\n\t// Address of the venue\n\tAddress string `json:\"address\"`\n\t// FoursquareID is the foursquare identifier of the venue\n\t//\n\t// optional\n\tFoursquareID string `json:\"foursquare_id,omitempty\"`\n\t// FoursquareType is the foursquare type of the venue\n\t//\n\t// optional\n\tFoursquareType string `json:\"foursquare_type,omitempty\"`\n\t// GooglePlaceID is the Google Places identifier of the venue\n\t//\n\t// optional\n\tGooglePlaceID string `json:\"google_place_id,omitempty\"`\n\t// GooglePlaceType is the Google Places type of the venue\n\t//\n\t// optional\n\tGooglePlaceType string `json:\"google_place_type,omitempty\"`\n}\n\n// WebAppData Contains data sent from a Web App to the bot.\ntype WebAppData struct {\n\t// Data is the data. Be aware that a bad client can send arbitrary data in this field.\n\tData string `json:\"data\"`\n\t// ButtonText is the text of the web_app keyboard button, from which the Web App\n\t// was opened. Be aware that a bad client can send arbitrary data in this field.\n\tButtonText string `json:\"button_text\"`\n}\n\n// ProximityAlertTriggered represents a service message sent when a user in the\n// chat triggers a proximity alert sent by another user.\ntype ProximityAlertTriggered struct {\n\t// Traveler is the user that triggered the alert\n\tTraveler User `json:\"traveler\"`\n\t// Watcher is the user that set the alert\n\tWatcher User `json:\"watcher\"`\n\t// Distance is the distance between the users\n\tDistance int `json:\"distance\"`\n}\n\n// MessageAutoDeleteTimerChanged represents a service message about a change in\n// auto-delete timer settings.\ntype MessageAutoDeleteTimerChanged struct {\n\t// New auto-delete time for messages in the chat.\n\tMessageAutoDeleteTime int `json:\"message_auto_delete_time\"`\n}\n\n// VideoChatScheduled represents a service message about a voice chat scheduled\n// in the chat.\ntype VideoChatScheduled struct {\n\t// Point in time (Unix timestamp) when the voice chat is supposed to be\n\t// started by a chat administrator\n\tStartDate int `json:\"start_date\"`\n}\n\n// Time converts the scheduled start date into a Time.\nfunc (m *VideoChatScheduled) Time() time.Time {\n\treturn time.Unix(int64(m.StartDate), 0)\n}\n\n// VideoChatStarted represents a service message about a voice chat started in\n// the chat.\ntype VideoChatStarted struct{}\n\n// VideoChatEnded represents a service message about a voice chat ended in the\n// chat.\ntype VideoChatEnded struct {\n\t// Voice chat duration; in seconds.\n\tDuration int `json:\"duration\"`\n}\n\n// VideoChatParticipantsInvited represents a service message about new members\n// invited to a voice chat.\ntype VideoChatParticipantsInvited struct {\n\t// New members that were invited to the voice chat.\n\t//\n\t// optional\n\tUsers []User `json:\"users,omitempty\"`\n}\n\n// UserProfilePhotos contains a set of user profile photos.\ntype UserProfilePhotos struct {\n\t// TotalCount total number of profile pictures the target user has\n\tTotalCount int `json:\"total_count\"`\n\t// Photos requested profile pictures (in up to 4 sizes each)\n\tPhotos [][]PhotoSize `json:\"photos\"`\n}\n\n// File contains information about a file to download from Telegram.\ntype File struct {\n\t// FileID identifier for this file, which can be used to download or reuse\n\t// the file\n\tFileID string `json:\"file_id\"`\n\t// FileUniqueID is the unique identifier for this file, which is supposed to\n\t// be the same over time and for different bots. Can't be used to download\n\t// or reuse the file.\n\tFileUniqueID string `json:\"file_unique_id\"`\n\t// FileSize file size, if known\n\t//\n\t// optional\n\tFileSize int `json:\"file_size,omitempty\"`\n\t// FilePath file path\n\t//\n\t// optional\n\tFilePath string `json:\"file_path,omitempty\"`\n}\n\n// Link returns a full path to the download URL for a File.\n//\n// It requires the Bot token to create the link.\nfunc (f *File) Link(token string) string {\n\treturn fmt.Sprintf(FileEndpoint, token, f.FilePath)\n}\n\n// WebAppInfo contains information about a Web App.\ntype WebAppInfo struct {\n\t// URL is the HTTPS URL of a Web App to be opened with additional data as\n\t// specified in Initializing Web Apps.\n\tURL string `json:\"url\"`\n}\n\n// ReplyKeyboardMarkup represents a custom keyboard with reply options.\ntype ReplyKeyboardMarkup struct {\n\t// Keyboard is an array of button rows, each represented by an Array of KeyboardButton objects\n\tKeyboard [][]KeyboardButton `json:\"keyboard\"`\n\t// ResizeKeyboard requests clients to resize the keyboard vertically for optimal fit\n\t// (e.g., make the keyboard smaller if there are just two rows of buttons).\n\t// Defaults to false, in which case the custom keyboard\n\t// is always of the same height as the app's standard keyboard.\n\t//\n\t// optional\n\tResizeKeyboard bool `json:\"resize_keyboard,omitempty\"`\n\t// OneTimeKeyboard requests clients to hide the keyboard as soon as it's been used.\n\t// The keyboard will still be available, but clients will automatically display\n\t// the usual letter-keyboard in the chat – the user can press a special button\n\t// in the input field to see the custom keyboard again.\n\t// Defaults to false.\n\t//\n\t// optional\n\tOneTimeKeyboard bool `json:\"one_time_keyboard,omitempty\"`\n\t// InputFieldPlaceholder is the placeholder to be shown in the input field when\n\t// the keyboard is active; 1-64 characters.\n\t//\n\t// optional\n\tInputFieldPlaceholder string `json:\"input_field_placeholder,omitempty\"`\n\t// Selective use this parameter if you want to show the keyboard to specific users only.\n\t// Targets:\n\t//  1) users that are @mentioned in the text of the Message object;\n\t//  2) if the bot's message is a reply (has Message.ReplyToMessage not nil), sender of the original message.\n\t//\n\t// Example: A user requests to change the bot's language,\n\t// bot replies to the request with a keyboard to select the new language.\n\t// Other users in the group don't see the keyboard.\n\t//\n\t// optional\n\tSelective bool `json:\"selective,omitempty\"`\n}\n\n// KeyboardButton represents one button of the reply keyboard. For simple text\n// buttons String can be used instead of this object to specify text of the\n// button. Optional fields request_contact, request_location, and request_poll\n// are mutually exclusive.\ntype KeyboardButton struct {\n\t// Text of the button. If none of the optional fields are used,\n\t// it will be sent as a message when the button is pressed.\n\tText string `json:\"text\"`\n\t// RequestContact if True, the user's phone number will be sent\n\t// as a contact when the button is pressed.\n\t// Available in private chats only.\n\t//\n\t// optional\n\tRequestContact bool `json:\"request_contact,omitempty\"`\n\t// RequestLocation if True, the user's current location will be sent when\n\t// the button is pressed.\n\t// Available in private chats only.\n\t//\n\t// optional\n\tRequestLocation bool `json:\"request_location,omitempty\"`\n\t// RequestPoll if specified, the user will be asked to create a poll and send it\n\t// to the bot when the button is pressed. Available in private chats only\n\t//\n\t// optional\n\tRequestPoll *KeyboardButtonPollType `json:\"request_poll,omitempty\"`\n\t// WebApp if specified, the described Web App will be launched when the button\n\t// is pressed. The Web App will be able to send a “web_app_data” service\n\t// message. Available in private chats only.\n\t//\n\t// optional\n\tWebApp *WebAppInfo `json:\"web_app,omitempty\"`\n}\n\n// KeyboardButtonPollType represents type of poll, which is allowed to\n// be created and sent when the corresponding button is pressed.\ntype KeyboardButtonPollType struct {\n\t// Type is if quiz is passed, the user will be allowed to create only polls\n\t// in the quiz mode. If regular is passed, only regular polls will be\n\t// allowed. Otherwise, the user will be allowed to create a poll of any type.\n\tType string `json:\"type\"`\n}\n\n// ReplyKeyboardRemove Upon receiving a message with this object, Telegram\n// clients will remove the current custom keyboard and display the default\n// letter-keyboard. By default, custom keyboards are displayed until a new\n// keyboard is sent by a bot. An exception is made for one-time keyboards\n// that are hidden immediately after the user presses a button.\ntype ReplyKeyboardRemove struct {\n\t// RemoveKeyboard requests clients to remove the custom keyboard\n\t// (user will not be able to summon this keyboard;\n\t// if you want to hide the keyboard from sight but keep it accessible,\n\t// use one_time_keyboard in ReplyKeyboardMarkup).\n\tRemoveKeyboard bool `json:\"remove_keyboard\"`\n\t// Selective use this parameter if you want to remove the keyboard for specific users only.\n\t// Targets:\n\t//  1) users that are @mentioned in the text of the Message object;\n\t//  2) if the bot's message is a reply (has Message.ReplyToMessage not nil), sender of the original message.\n\t//\n\t// Example: A user votes in a poll, bot returns confirmation message\n\t// in reply to the vote and removes the keyboard for that user,\n\t// while still showing the keyboard with poll options to users who haven't voted yet.\n\t//\n\t// optional\n\tSelective bool `json:\"selective,omitempty\"`\n}\n\n// InlineKeyboardMarkup represents an inline keyboard that appears right next to\n// the message it belongs to.\ntype InlineKeyboardMarkup struct {\n\t// InlineKeyboard array of button rows, each represented by an Array of\n\t// InlineKeyboardButton objects\n\tInlineKeyboard [][]InlineKeyboardButton `json:\"inline_keyboard\"`\n}\n\n// InlineKeyboardButton represents one button of an inline keyboard. You must\n// use exactly one of the optional fields.\n//\n// Note that some values are references as even an empty string\n// will change behavior.\n//\n// CallbackGame, if set, MUST be first button in first row.\ntype InlineKeyboardButton struct {\n\t// Text label text on the button\n\tText string `json:\"text\"`\n\t// URL HTTP or tg:// url to be opened when button is pressed.\n\t//\n\t// optional\n\tURL *string `json:\"url,omitempty\"`\n\t// LoginURL is an HTTP URL used to automatically authorize the user. Can be\n\t// used as a replacement for the Telegram Login Widget\n\t//\n\t// optional\n\tLoginURL *LoginURL `json:\"login_url,omitempty\"`\n\t// CallbackData data to be sent in a callback query to the bot when button is pressed, 1-64 bytes.\n\t//\n\t// optional\n\tCallbackData *string `json:\"callback_data,omitempty\"`\n\t// WebApp is the Description of the Web App that will be launched when the user presses the button.\n\t// The Web App will be able to send an arbitrary message on behalf of the user using the method\n\t// answerWebAppQuery. Available only in private chats between a user and the bot.\n\t//\n\t// optional\n\tWebApp *WebAppInfo `json:\"web_app,omitempty\"`\n\t// SwitchInlineQuery if set, pressing the button will prompt the user to select one of their chats,\n\t// open that chat and insert the bot's username and the specified inline query in the input field.\n\t// Can be empty, in which case just the bot's username will be inserted.\n\t//\n\t// This offers an easy way for users to start using your bot\n\t// in inline mode when they are currently in a private chat with it.\n\t// Especially useful when combined with switch_pm… actions – in this case\n\t// the user will be automatically returned to the chat they switched from,\n\t// skipping the chat selection screen.\n\t//\n\t// optional\n\tSwitchInlineQuery *string `json:\"switch_inline_query,omitempty\"`\n\t// SwitchInlineQueryCurrentChat if set, pressing the button will insert the bot's username\n\t// and the specified inline query in the current chat's input field.\n\t// Can be empty, in which case only the bot's username will be inserted.\n\t//\n\t// This offers a quick way for the user to open your bot in inline mode\n\t// in the same chat – good for selecting something from multiple options.\n\t//\n\t// optional\n\tSwitchInlineQueryCurrentChat *string `json:\"switch_inline_query_current_chat,omitempty\"`\n\t// CallbackGame description of the game that will be launched when the user presses the button.\n\t//\n\t// optional\n\tCallbackGame *CallbackGame `json:\"callback_game,omitempty\"`\n\t// Pay specify True, to send a Pay button.\n\t//\n\t// NOTE: This type of button must always be the first button in the first row.\n\t//\n\t// optional\n\tPay bool `json:\"pay,omitempty\"`\n}\n\n// LoginURL represents a parameter of the inline keyboard button used to\n// automatically authorize a user. Serves as a great replacement for the\n// Telegram Login Widget when the user is coming from Telegram. All the user\n// needs to do is tap/click a button and confirm that they want to log in.\ntype LoginURL struct {\n\t// URL is an HTTP URL to be opened with user authorization data added to the\n\t// query string when the button is pressed. If the user refuses to provide\n\t// authorization data, the original URL without information about the user\n\t// will be opened. The data added is the same as described in Receiving\n\t// authorization data.\n\t//\n\t// NOTE: You must always check the hash of the received data to verify the\n\t// authentication and the integrity of the data as described in Checking\n\t// authorization.\n\tURL string `json:\"url\"`\n\t// ForwardText is the new text of the button in forwarded messages\n\t//\n\t// optional\n\tForwardText string `json:\"forward_text,omitempty\"`\n\t// BotUsername is the username of a bot, which will be used for user\n\t// authorization. See Setting up a bot for more details. If not specified,\n\t// the current bot's username will be assumed. The url's domain must be the\n\t// same as the domain linked with the bot. See Linking your domain to the\n\t// bot for more details.\n\t//\n\t// optional\n\tBotUsername string `json:\"bot_username,omitempty\"`\n\t// RequestWriteAccess if true requests permission for your bot to send\n\t// messages to the user\n\t//\n\t// optional\n\tRequestWriteAccess bool `json:\"request_write_access,omitempty\"`\n}\n\n// CallbackQuery represents an incoming callback query from a callback button in\n// an inline keyboard. If the button that originated the query was attached to a\n// message sent by the bot, the field message will be present. If the button was\n// attached to a message sent via the bot (in inline mode), the field\n// inline_message_id will be present. Exactly one of the fields data or\n// game_short_name will be present.\ntype CallbackQuery struct {\n\t// ID unique identifier for this query\n\tID string `json:\"id\"`\n\t// From sender\n\tFrom *User `json:\"from\"`\n\t// Message with the callback button that originated the query.\n\t// Note that message content and message date will not be available if the\n\t// message is too old.\n\t//\n\t// optional\n\tMessage *Message `json:\"message,omitempty\"`\n\t// InlineMessageID identifier of the message sent via the bot in inline\n\t// mode, that originated the query.\n\t//\n\t// optional\n\tInlineMessageID string `json:\"inline_message_id,omitempty\"`\n\t// ChatInstance global identifier, uniquely corresponding to the chat to\n\t// which the message with the callback button was sent. Useful for high\n\t// scores in games.\n\tChatInstance string `json:\"chat_instance\"`\n\t// Data associated with the callback button. Be aware that\n\t// a bad client can send arbitrary data in this field.\n\t//\n\t// optional\n\tData string `json:\"data,omitempty\"`\n\t// GameShortName short name of a Game to be returned, serves as the unique identifier for the game.\n\t//\n\t// optional\n\tGameShortName string `json:\"game_short_name,omitempty\"`\n}\n\n// ForceReply when receiving a message with this object, Telegram clients will\n// display a reply interface to the user (act as if the user has selected the\n// bot's message and tapped 'Reply'). This can be extremely useful if you  want\n// to create user-friendly step-by-step interfaces without having to sacrifice\n// privacy mode.\ntype ForceReply struct {\n\t// ForceReply shows reply interface to the user,\n\t// as if they manually selected the bot's message and tapped 'Reply'.\n\tForceReply bool `json:\"force_reply\"`\n\t// InputFieldPlaceholder is the placeholder to be shown in the input field when\n\t// the reply is active; 1-64 characters.\n\t//\n\t// optional\n\tInputFieldPlaceholder string `json:\"input_field_placeholder,omitempty\"`\n\t// Selective use this parameter if you want to force reply from specific users only.\n\t// Targets:\n\t//  1) users that are @mentioned in the text of the Message object;\n\t//  2) if the bot's message is a reply (has Message.ReplyToMessage not nil), sender of the original message.\n\t//\n\t// optional\n\tSelective bool `json:\"selective,omitempty\"`\n}\n\n// ChatPhoto represents a chat photo.\ntype ChatPhoto struct {\n\t// SmallFileID is a file identifier of small (160x160) chat photo.\n\t// This file_id can be used only for photo download and\n\t// only for as long as the photo is not changed.\n\tSmallFileID string `json:\"small_file_id\"`\n\t// SmallFileUniqueID is a unique file identifier of small (160x160) chat\n\t// photo, which is supposed to be the same over time and for different bots.\n\t// Can't be used to download or reuse the file.\n\tSmallFileUniqueID string `json:\"small_file_unique_id\"`\n\t// BigFileID is a file identifier of big (640x640) chat photo.\n\t// This file_id can be used only for photo download and\n\t// only for as long as the photo is not changed.\n\tBigFileID string `json:\"big_file_id\"`\n\t// BigFileUniqueID is a file identifier of big (640x640) chat photo, which\n\t// is supposed to be the same over time and for different bots. Can't be\n\t// used to download or reuse the file.\n\tBigFileUniqueID string `json:\"big_file_unique_id\"`\n}\n\n// ChatInviteLink represents an invite link for a chat.\ntype ChatInviteLink struct {\n\t// InviteLink is the invite link. If the link was created by another chat\n\t// administrator, then the second part of the link will be replaced with “…”.\n\tInviteLink string `json:\"invite_link\"`\n\t// Creator of the link.\n\tCreator User `json:\"creator\"`\n\t// CreatesJoinRequest is true if users joining the chat via the link need to\n\t// be approved by chat administrators.\n\t//\n\t// optional\n\tCreatesJoinRequest bool `json:\"creates_join_request,omitempty\"`\n\t// IsPrimary is true, if the link is primary.\n\tIsPrimary bool `json:\"is_primary\"`\n\t// IsRevoked is true, if the link is revoked.\n\tIsRevoked bool `json:\"is_revoked\"`\n\t// Name is the name of the invite link.\n\t//\n\t// optional\n\tName string `json:\"name,omitempty\"`\n\t// ExpireDate is the point in time (Unix timestamp) when the link will\n\t// expire or has been expired.\n\t//\n\t// optional\n\tExpireDate int `json:\"expire_date,omitempty\"`\n\t// MemberLimit is the maximum number of users that can be members of the\n\t// chat simultaneously after joining the chat via this invite link; 1-99999.\n\t//\n\t// optional\n\tMemberLimit int `json:\"member_limit,omitempty\"`\n\t// PendingJoinRequestCount is the number of pending join requests created\n\t// using this link.\n\t//\n\t// optional\n\tPendingJoinRequestCount int `json:\"pending_join_request_count,omitempty\"`\n}\n\ntype ChatAdministratorRights struct {\n\tIsAnonymous         bool `json:\"is_anonymous\"`\n\tCanManageChat       bool `json:\"can_manage_chat\"`\n\tCanDeleteMessages   bool `json:\"can_delete_messages\"`\n\tCanManageVideoChats bool `json:\"can_manage_video_chats\"`\n\tCanRestrictMembers  bool `json:\"can_restrict_members\"`\n\tCanPromoteMembers   bool `json:\"can_promote_members\"`\n\tCanChangeInfo       bool `json:\"can_change_info\"`\n\tCanInviteUsers      bool `json:\"can_invite_users\"`\n\tCanPostMessages     bool `json:\"can_post_messages\"`\n\tCanEditMessages     bool `json:\"can_edit_messages\"`\n\tCanPinMessages      bool `json:\"can_pin_messages\"`\n}\n\n// ChatMember contains information about one member of a chat.\ntype ChatMember struct {\n\t// User information about the user\n\tUser *User `json:\"user\"`\n\t// Status the member's status in the chat.\n\t// Can be\n\t//  “creator”,\n\t//  “administrator”,\n\t//  “member”,\n\t//  “restricted”,\n\t//  “left” or\n\t//  “kicked”\n\tStatus string `json:\"status\"`\n\t// CustomTitle owner and administrators only. Custom title for this user\n\t//\n\t// optional\n\tCustomTitle string `json:\"custom_title,omitempty\"`\n\t// IsAnonymous owner and administrators only. True, if the user's presence\n\t// in the chat is hidden\n\t//\n\t// optional\n\tIsAnonymous bool `json:\"is_anonymous,omitempty\"`\n\t// UntilDate restricted and kicked only.\n\t// Date when restrictions will be lifted for this user;\n\t// unix time.\n\t//\n\t// optional\n\tUntilDate int64 `json:\"until_date,omitempty\"`\n\t// CanBeEdited administrators only.\n\t// True, if the bot is allowed to edit administrator privileges of that user.\n\t//\n\t// optional\n\tCanBeEdited bool `json:\"can_be_edited,omitempty\"`\n\t// CanManageChat administrators only.\n\t// True, if the administrator can access the chat event log, chat\n\t// statistics, message statistics in channels, see channel members, see\n\t// anonymous administrators in supergroups and ignore slow mode. Implied by\n\t// any other administrator privilege.\n\t//\n\t// optional\n\tCanManageChat bool `json:\"can_manage_chat,omitempty\"`\n\t// CanPostMessages administrators only.\n\t// True, if the administrator can post in the channel;\n\t// channels only.\n\t//\n\t// optional\n\tCanPostMessages bool `json:\"can_post_messages,omitempty\"`\n\t// CanEditMessages administrators only.\n\t// True, if the administrator can edit messages of other users and can pin messages;\n\t// channels only.\n\t//\n\t// optional\n\tCanEditMessages bool `json:\"can_edit_messages,omitempty\"`\n\t// CanDeleteMessages administrators only.\n\t// True, if the administrator can delete messages of other users.\n\t//\n\t// optional\n\tCanDeleteMessages bool `json:\"can_delete_messages,omitempty\"`\n\t// CanManageVideoChats administrators only.\n\t// True, if the administrator can manage video chats.\n\t//\n\t// optional\n\tCanManageVideoChats bool `json:\"can_manage_video_chats,omitempty\"`\n\t// CanRestrictMembers administrators only.\n\t// True, if the administrator can restrict, ban or unban chat members.\n\t//\n\t// optional\n\tCanRestrictMembers bool `json:\"can_restrict_members,omitempty\"`\n\t// CanPromoteMembers administrators only.\n\t// True, if the administrator can add new administrators\n\t// with a subset of their own privileges or demote administrators that he has promoted,\n\t// directly or indirectly (promoted by administrators that were appointed by the user).\n\t//\n\t// optional\n\tCanPromoteMembers bool `json:\"can_promote_members,omitempty\"`\n\t// CanChangeInfo administrators and restricted only.\n\t// True, if the user is allowed to change the chat title, photo and other settings.\n\t//\n\t// optional\n\tCanChangeInfo bool `json:\"can_change_info,omitempty\"`\n\t// CanInviteUsers administrators and restricted only.\n\t// True, if the user is allowed to invite new users to the chat.\n\t//\n\t// optional\n\tCanInviteUsers bool `json:\"can_invite_users,omitempty\"`\n\t// CanPinMessages administrators and restricted only.\n\t// True, if the user is allowed to pin messages; groups and supergroups only\n\t//\n\t// optional\n\tCanPinMessages bool `json:\"can_pin_messages,omitempty\"`\n\t// IsMember is true, if the user is a member of the chat at the moment of\n\t// the request\n\tIsMember bool `json:\"is_member\"`\n\t// CanSendMessages\n\t//\n\t// optional\n\tCanSendMessages bool `json:\"can_send_messages,omitempty\"`\n\t// CanSendMediaMessages restricted only.\n\t// True, if the user is allowed to send text messages, contacts, locations and venues\n\t//\n\t// optional\n\tCanSendMediaMessages bool `json:\"can_send_media_messages,omitempty\"`\n\t// CanSendPolls restricted only.\n\t// True, if the user is allowed to send polls\n\t//\n\t// optional\n\tCanSendPolls bool `json:\"can_send_polls,omitempty\"`\n\t// CanSendOtherMessages restricted only.\n\t// True, if the user is allowed to send audios, documents,\n\t// photos, videos, video notes and voice notes.\n\t//\n\t// optional\n\tCanSendOtherMessages bool `json:\"can_send_other_messages,omitempty\"`\n\t// CanAddWebPagePreviews restricted only.\n\t// True, if the user is allowed to add web page previews to their messages.\n\t//\n\t// optional\n\tCanAddWebPagePreviews bool `json:\"can_add_web_page_previews,omitempty\"`\n}\n\n// IsCreator returns if the ChatMember was the creator of the chat.\nfunc (chat ChatMember) IsCreator() bool { return chat.Status == \"creator\" }\n\n// IsAdministrator returns if the ChatMember is a chat administrator.\nfunc (chat ChatMember) IsAdministrator() bool { return chat.Status == \"administrator\" }\n\n// HasLeft returns if the ChatMember left the chat.\nfunc (chat ChatMember) HasLeft() bool { return chat.Status == \"left\" }\n\n// WasKicked returns if the ChatMember was kicked from the chat.\nfunc (chat ChatMember) WasKicked() bool { return chat.Status == \"kicked\" }\n\n// ChatMemberUpdated represents changes in the status of a chat member.\ntype ChatMemberUpdated struct {\n\t// Chat the user belongs to.\n\tChat Chat `json:\"chat\"`\n\t// From is the performer of the action, which resulted in the change.\n\tFrom User `json:\"from\"`\n\t// Date the change was done in Unix time.\n\tDate int `json:\"date\"`\n\t// Previous information about the chat member.\n\tOldChatMember ChatMember `json:\"old_chat_member\"`\n\t// New information about the chat member.\n\tNewChatMember ChatMember `json:\"new_chat_member\"`\n\t// InviteLink is the link which was used by the user to join the chat;\n\t// for joining by invite link events only.\n\t//\n\t// optional\n\tInviteLink *ChatInviteLink `json:\"invite_link,omitempty\"`\n}\n\n// ChatJoinRequest represents a join request sent to a chat.\ntype ChatJoinRequest struct {\n\t// Chat to which the request was sent.\n\tChat Chat `json:\"chat\"`\n\t// User that sent the join request.\n\tFrom User `json:\"from\"`\n\t// Date the request was sent in Unix time.\n\tDate int `json:\"date\"`\n\t// Bio of the user.\n\t//\n\t// optional\n\tBio string `json:\"bio,omitempty\"`\n\t// InviteLink is the link that was used by the user to send the join request.\n\t//\n\t// optional\n\tInviteLink *ChatInviteLink `json:\"invite_link,omitempty\"`\n}\n\n// ChatPermissions describes actions that a non-administrator user is\n// allowed to take in a chat. All fields are optional.\ntype ChatPermissions struct {\n\t// CanSendMessages is true, if the user is allowed to send text messages,\n\t// contacts, locations and venues\n\t//\n\t// optional\n\tCanSendMessages bool `json:\"can_send_messages,omitempty\"`\n\t// CanSendMediaMessages is true, if the user is allowed to send audios,\n\t// documents, photos, videos, video notes and voice notes, implies\n\t// can_send_messages\n\t//\n\t// optional\n\tCanSendMediaMessages bool `json:\"can_send_media_messages,omitempty\"`\n\t// CanSendPolls is true, if the user is allowed to send polls, implies\n\t// can_send_messages\n\t//\n\t// optional\n\tCanSendPolls bool `json:\"can_send_polls,omitempty\"`\n\t// CanSendOtherMessages is true, if the user is allowed to send animations,\n\t// games, stickers and use inline bots, implies can_send_media_messages\n\t//\n\t// optional\n\tCanSendOtherMessages bool `json:\"can_send_other_messages,omitempty\"`\n\t// CanAddWebPagePreviews is true, if the user is allowed to add web page\n\t// previews to their messages, implies can_send_media_messages\n\t//\n\t// optional\n\tCanAddWebPagePreviews bool `json:\"can_add_web_page_previews,omitempty\"`\n\t// CanChangeInfo is true, if the user is allowed to change the chat title,\n\t// photo and other settings. Ignored in public supergroups\n\t//\n\t// optional\n\tCanChangeInfo bool `json:\"can_change_info,omitempty\"`\n\t// CanInviteUsers is true, if the user is allowed to invite new users to the\n\t// chat\n\t//\n\t// optional\n\tCanInviteUsers bool `json:\"can_invite_users,omitempty\"`\n\t// CanPinMessages is true, if the user is allowed to pin messages. Ignored\n\t// in public supergroups\n\t//\n\t// optional\n\tCanPinMessages bool `json:\"can_pin_messages,omitempty\"`\n}\n\n// ChatLocation represents a location to which a chat is connected.\ntype ChatLocation struct {\n\t// Location is the location to which the supergroup is connected. Can't be a\n\t// live location.\n\tLocation Location `json:\"location\"`\n\t// Address is the location address; 1-64 characters, as defined by the chat\n\t// owner\n\tAddress string `json:\"address\"`\n}\n\n// BotCommand represents a bot command.\ntype BotCommand struct {\n\t// Command text of the command, 1-32 characters.\n\t// Can contain only lowercase English letters, digits and underscores.\n\tCommand string `json:\"command\"`\n\t// Description of the command, 3-256 characters.\n\tDescription string `json:\"description\"`\n}\n\n// BotCommandScope represents the scope to which bot commands are applied.\n//\n// It contains the fields for all types of scopes, different types only support\n// specific (or no) fields.\ntype BotCommandScope struct {\n\tType   string `json:\"type\"`\n\tChatID int64  `json:\"chat_id,omitempty\"`\n\tUserID int64  `json:\"user_id,omitempty\"`\n}\n\n// MenuButton describes the bot's menu button in a private chat.\ntype MenuButton struct {\n\t// Type is the type of menu button, must be one of:\n\t// - `commands`\n\t// - `web_app`\n\t// - `default`\n\tType string `json:\"type\"`\n\t// Text is the text on the button, for `web_app` type.\n\tText string `json:\"text,omitempty\"`\n\t// WebApp is the description of the Web App that will be launched when the\n\t// user presses the button for the `web_app` type.\n\tWebApp *WebAppInfo `json:\"web_app,omitempty\"`\n}\n\n// ResponseParameters are various errors that can be returned in APIResponse.\ntype ResponseParameters struct {\n\t// The group has been migrated to a supergroup with the specified identifier.\n\t//\n\t// optional\n\tMigrateToChatID int64 `json:\"migrate_to_chat_id,omitempty\"`\n\t// In case of exceeding flood control, the number of seconds left to wait\n\t// before the request can be repeated.\n\t//\n\t// optional\n\tRetryAfter int `json:\"retry_after,omitempty\"`\n}\n\n// BaseInputMedia is a base type for the InputMedia types.\ntype BaseInputMedia struct {\n\t// Type of the result.\n\tType string `json:\"type\"`\n\t// Media file to send. Pass a file_id to send a file\n\t// that exists on the Telegram servers (recommended),\n\t// pass an HTTP URL for Telegram to get a file from the Internet,\n\t// or pass “attach://<file_attach_name>” to upload a new one\n\t// using multipart/form-data under <file_attach_name> name.\n\tMedia RequestFileData `json:\"media\"`\n\t// thumb intentionally missing as it is not currently compatible\n\n\t// Caption of the video to be sent, 0-1024 characters after entities parsing.\n\t//\n\t// optional\n\tCaption string `json:\"caption,omitempty\"`\n\t// ParseMode mode for parsing entities in the video caption.\n\t// See formatting options for more details\n\t// (https://core.telegram.org/bots/api#formatting-options).\n\t//\n\t// optional\n\tParseMode string `json:\"parse_mode,omitempty\"`\n\t// CaptionEntities is a list of special entities that appear in the caption,\n\t// which can be specified instead of parse_mode\n\t//\n\t// optional\n\tCaptionEntities []MessageEntity `json:\"caption_entities,omitempty\"`\n}\n\n// InputMediaPhoto is a photo to send as part of a media group.\ntype InputMediaPhoto struct {\n\tBaseInputMedia\n}\n\n// InputMediaVideo is a video to send as part of a media group.\ntype InputMediaVideo struct {\n\tBaseInputMedia\n\t// Thumbnail of the file sent; can be ignored if thumbnail generation for\n\t// the file is supported server-side.\n\t//\n\t// optional\n\tThumb RequestFileData `json:\"thumb,omitempty\"`\n\t// Width video width\n\t//\n\t// optional\n\tWidth int `json:\"width,omitempty\"`\n\t// Height video height\n\t//\n\t// optional\n\tHeight int `json:\"height,omitempty\"`\n\t// Duration video duration\n\t//\n\t// optional\n\tDuration int `json:\"duration,omitempty\"`\n\t// SupportsStreaming pass True, if the uploaded video is suitable for streaming.\n\t//\n\t// optional\n\tSupportsStreaming bool `json:\"supports_streaming,omitempty\"`\n}\n\n// InputMediaAnimation is an animation to send as part of a media group.\ntype InputMediaAnimation struct {\n\tBaseInputMedia\n\t// Thumbnail of the file sent; can be ignored if thumbnail generation for\n\t// the file is supported server-side.\n\t//\n\t// optional\n\tThumb RequestFileData `json:\"thumb,omitempty\"`\n\t// Width video width\n\t//\n\t// optional\n\tWidth int `json:\"width,omitempty\"`\n\t// Height video height\n\t//\n\t// optional\n\tHeight int `json:\"height,omitempty\"`\n\t// Duration video duration\n\t//\n\t// optional\n\tDuration int `json:\"duration,omitempty\"`\n}\n\n// InputMediaAudio is an audio to send as part of a media group.\ntype InputMediaAudio struct {\n\tBaseInputMedia\n\t// Thumbnail of the file sent; can be ignored if thumbnail generation for\n\t// the file is supported server-side.\n\t//\n\t// optional\n\tThumb RequestFileData `json:\"thumb,omitempty\"`\n\t// Duration of the audio in seconds\n\t//\n\t// optional\n\tDuration int `json:\"duration,omitempty\"`\n\t// Performer of the audio\n\t//\n\t// optional\n\tPerformer string `json:\"performer,omitempty\"`\n\t// Title of the audio\n\t//\n\t// optional\n\tTitle string `json:\"title,omitempty\"`\n}\n\n// InputMediaDocument is a general file to send as part of a media group.\ntype InputMediaDocument struct {\n\tBaseInputMedia\n\t// Thumbnail of the file sent; can be ignored if thumbnail generation for\n\t// the file is supported server-side.\n\t//\n\t// optional\n\tThumb RequestFileData `json:\"thumb,omitempty\"`\n\t// DisableContentTypeDetection disables automatic server-side content type\n\t// detection for files uploaded using multipart/form-data. Always true, if\n\t// the document is sent as part of an album\n\t//\n\t// optional\n\tDisableContentTypeDetection bool `json:\"disable_content_type_detection,omitempty\"`\n}\n\n// Sticker represents a sticker.\ntype Sticker struct {\n\t// FileID is an identifier for this file, which can be used to download or\n\t// reuse the file\n\tFileID string `json:\"file_id\"`\n\t// FileUniqueID is a unique identifier for this file,\n\t// which is supposed to be the same over time and for different bots.\n\t// Can't be used to download or reuse the file.\n\tFileUniqueID string `json:\"file_unique_id\"`\n\t// Width sticker width\n\tWidth int `json:\"width\"`\n\t// Height sticker height\n\tHeight int `json:\"height\"`\n\t// IsAnimated true, if the sticker is animated\n\t//\n\t// optional\n\tIsAnimated bool `json:\"is_animated,omitempty\"`\n\t// IsVideo true, if the sticker is a video sticker\n\t//\n\t// optional\n\tIsVideo bool `json:\"is_video,omitempty\"`\n\t// Thumbnail sticker thumbnail in the .WEBP or .JPG format\n\t//\n\t// optional\n\tThumbnail *PhotoSize `json:\"thumb,omitempty\"`\n\t// Emoji associated with the sticker\n\t//\n\t// optional\n\tEmoji string `json:\"emoji,omitempty\"`\n\t// SetName of the sticker set to which the sticker belongs\n\t//\n\t// optional\n\tSetName string `json:\"set_name,omitempty\"`\n\t// PremiumAnimation for premium regular stickers, premium animation for the sticker\n\t//\n\t// optional\n\tPremiumAnimation *File `json:\"premium_animation,omitempty\"`\n\t// MaskPosition is for mask stickers, the position where the mask should be\n\t// placed\n\t//\n\t// optional\n\tMaskPosition *MaskPosition `json:\"mask_position,omitempty\"`\n\t// CustomEmojiID for custom emoji stickers, unique identifier of the custom emoji\n\t//\n\t// optional\n\tCustomEmojiID string `json:\"custom_emoji_id,omitempty\"`\n\t// FileSize\n\t//\n\t// optional\n\tFileSize int `json:\"file_size,omitempty\"`\n}\n\n// StickerSet represents a sticker set.\ntype StickerSet struct {\n\t// Name sticker set name\n\tName string `json:\"name\"`\n\t// Title sticker set title\n\tTitle string `json:\"title\"`\n\t// StickerType of stickers in the set, currently one of “regular”, “mask”, “custom_emoji”\n\tStickerType string `json:\"sticker_type\"`\n\t// IsAnimated true, if the sticker set contains animated stickers\n\tIsAnimated bool `json:\"is_animated\"`\n\t// IsVideo true, if the sticker set contains video stickers\n\tIsVideo bool `json:\"is_video\"`\n\t// ContainsMasks true, if the sticker set contains masks\n\tContainsMasks bool `json:\"contains_masks\"`\n\t// Stickers list of all set stickers\n\tStickers []Sticker `json:\"stickers\"`\n\t// Thumb is the sticker set thumbnail in the .WEBP or .TGS format\n\tThumbnail *PhotoSize `json:\"thumb\"`\n}\n\n// MaskPosition describes the position on faces where a mask should be placed\n// by default.\ntype MaskPosition struct {\n\t// The part of the face relative to which the mask should be placed.\n\t// One of “forehead”, “eyes”, “mouth”, or “chin”.\n\tPoint string `json:\"point\"`\n\t// Shift by X-axis measured in widths of the mask scaled to the face size,\n\t// from left to right. For example, choosing -1.0 will place mask just to\n\t// the left of the default mask position.\n\tXShift float64 `json:\"x_shift\"`\n\t// Shift by Y-axis measured in heights of the mask scaled to the face size,\n\t// from top to bottom. For example, 1.0 will place the mask just below the\n\t// default mask position.\n\tYShift float64 `json:\"y_shift\"`\n\t// Mask scaling coefficient. For example, 2.0 means double size.\n\tScale float64 `json:\"scale\"`\n}\n\n// Game represents a game. Use BotFather to create and edit games, their short\n// names will act as unique identifiers.\ntype Game struct {\n\t// Title of the game\n\tTitle string `json:\"title\"`\n\t// Description of the game\n\tDescription string `json:\"description\"`\n\t// Photo that will be displayed in the game message in chats.\n\tPhoto []PhotoSize `json:\"photo\"`\n\t// Text a brief description of the game or high scores included in the game message.\n\t// Can be automatically edited to include current high scores for the game\n\t// when the bot calls setGameScore, or manually edited using editMessageText. 0-4096 characters.\n\t//\n\t// optional\n\tText string `json:\"text,omitempty\"`\n\t// TextEntities special entities that appear in text, such as usernames, URLs, bot commands, etc.\n\t//\n\t// optional\n\tTextEntities []MessageEntity `json:\"text_entities,omitempty\"`\n\t// Animation is an animation that will be displayed in the game message in chats.\n\t// Upload via BotFather (https://t.me/botfather).\n\t//\n\t// optional\n\tAnimation Animation `json:\"animation,omitempty\"`\n}\n\n// GameHighScore is a user's score and position on the leaderboard.\ntype GameHighScore struct {\n\t// Position in high score table for the game\n\tPosition int `json:\"position\"`\n\t// User user\n\tUser User `json:\"user\"`\n\t// Score score\n\tScore int `json:\"score\"`\n}\n\n// CallbackGame is for starting a game in an inline keyboard button.\ntype CallbackGame struct{}\n\n// WebhookInfo is information about a currently set webhook.\ntype WebhookInfo struct {\n\t// URL webhook URL, may be empty if webhook is not set up.\n\tURL string `json:\"url\"`\n\t// HasCustomCertificate true, if a custom certificate was provided for webhook certificate checks.\n\tHasCustomCertificate bool `json:\"has_custom_certificate\"`\n\t// PendingUpdateCount number of updates awaiting delivery.\n\tPendingUpdateCount int `json:\"pending_update_count\"`\n\t// IPAddress is the currently used webhook IP address\n\t//\n\t// optional\n\tIPAddress string `json:\"ip_address,omitempty\"`\n\t// LastErrorDate unix time for the most recent error\n\t// that happened when trying to deliver an update via webhook.\n\t//\n\t// optional\n\tLastErrorDate int `json:\"last_error_date,omitempty\"`\n\t// LastErrorMessage error message in human-readable format for the most recent error\n\t// that happened when trying to deliver an update via webhook.\n\t//\n\t// optional\n\tLastErrorMessage string `json:\"last_error_message,omitempty\"`\n\t// LastSynchronizationErrorDate is the unix time of the most recent error that\n\t// happened when trying to synchronize available updates with Telegram datacenters.\n\tLastSynchronizationErrorDate int `json:\"last_synchronization_error_date,omitempty\"`\n\t// MaxConnections maximum allowed number of simultaneous\n\t// HTTPS connections to the webhook for update delivery.\n\t//\n\t// optional\n\tMaxConnections int `json:\"max_connections,omitempty\"`\n\t// AllowedUpdates is a list of update types the bot is subscribed to.\n\t// Defaults to all update types\n\t//\n\t// optional\n\tAllowedUpdates []string `json:\"allowed_updates,omitempty\"`\n}\n\n// IsSet returns true if a webhook is currently set.\nfunc (info WebhookInfo) IsSet() bool {\n\treturn info.URL != \"\"\n}\n\n// InlineQuery is a Query from Telegram for an inline request.\ntype InlineQuery struct {\n\t// ID unique identifier for this query\n\tID string `json:\"id\"`\n\t// From sender\n\tFrom *User `json:\"from\"`\n\t// Query text of the query (up to 256 characters).\n\tQuery string `json:\"query\"`\n\t// Offset of the results to be returned, can be controlled by the bot.\n\tOffset string `json:\"offset\"`\n\t// Type of the chat, from which the inline query was sent. Can be either\n\t// “sender” for a private chat with the inline query sender, “private”,\n\t// “group”, “supergroup”, or “channel”. The chat type should be always known\n\t// for requests sent from official clients and most third-party clients,\n\t// unless the request was sent from a secret chat\n\t//\n\t// optional\n\tChatType string `json:\"chat_type,omitempty\"`\n\t// Location sender location, only for bots that request user location.\n\t//\n\t// optional\n\tLocation *Location `json:\"location,omitempty\"`\n}\n\n// InlineQueryResultCachedAudio is an inline query response with cached audio.\ntype InlineQueryResultCachedAudio struct {\n\t// Type of the result, must be audio\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 bytes\n\tID string `json:\"id\"`\n\t// AudioID a valid file identifier for the audio file\n\tAudioID string `json:\"audio_file_id\"`\n\t// Caption 0-1024 characters after entities parsing\n\t//\n\t// optional\n\tCaption string `json:\"caption,omitempty\"`\n\t// ParseMode mode for parsing entities in the video caption.\n\t// See formatting options for more details\n\t// (https://core.telegram.org/bots/api#formatting-options).\n\t//\n\t// optional\n\tParseMode string `json:\"parse_mode,omitempty\"`\n\t// CaptionEntities is a list of special entities that appear in the caption,\n\t// which can be specified instead of parse_mode\n\t//\n\t// optional\n\tCaptionEntities []MessageEntity `json:\"caption_entities,omitempty\"`\n\t// ReplyMarkup inline keyboard attached to the message\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\t// InputMessageContent content of the message to be sent instead of the audio\n\t//\n\t// optional\n\tInputMessageContent interface{} `json:\"input_message_content,omitempty\"`\n}\n\n// InlineQueryResultCachedDocument is an inline query response with cached document.\ntype InlineQueryResultCachedDocument struct {\n\t// Type of the result, must be a document\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 bytes\n\tID string `json:\"id\"`\n\t// DocumentID a valid file identifier for the file\n\tDocumentID string `json:\"document_file_id\"`\n\t// Title for the result\n\t//\n\t// optional\n\tTitle string `json:\"title,omitempty\"`\n\t// Caption of the document to be sent, 0-1024 characters after entities parsing\n\t//\n\t// optional\n\tCaption string `json:\"caption,omitempty\"`\n\t// Description short description of the result\n\t//\n\t// optional\n\tDescription string `json:\"description,omitempty\"`\n\t// ParseMode mode for parsing entities in the video caption.\n\t//\t// See formatting options for more details\n\t//\t// (https://core.telegram.org/bots/api#formatting-options).\n\t//\n\t// optional\n\tParseMode string `json:\"parse_mode,omitempty\"`\n\t// CaptionEntities is a list of special entities that appear in the caption,\n\t// which can be specified instead of parse_mode\n\t//\n\t// optional\n\tCaptionEntities []MessageEntity `json:\"caption_entities,omitempty\"`\n\t// ReplyMarkup inline keyboard attached to the message\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\t// InputMessageContent content of the message to be sent instead of the file\n\t//\n\t// optional\n\tInputMessageContent interface{} `json:\"input_message_content,omitempty\"`\n}\n\n// InlineQueryResultCachedGIF is an inline query response with cached gif.\ntype InlineQueryResultCachedGIF struct {\n\t// Type of the result, must be gif.\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 bytes.\n\tID string `json:\"id\"`\n\t// GifID a valid file identifier for the GIF file.\n\tGIFID string `json:\"gif_file_id\"`\n\t// Title for the result\n\t//\n\t// optional\n\tTitle string `json:\"title,omitempty\"`\n\t// Caption of the GIF file to be sent, 0-1024 characters after entities parsing.\n\t//\n\t// optional\n\tCaption string `json:\"caption,omitempty\"`\n\t// ParseMode mode for parsing entities in the caption.\n\t// See formatting options for more details\n\t// (https://core.telegram.org/bots/api#formatting-options).\n\t//\n\t// optional\n\tParseMode string `json:\"parse_mode,omitempty\"`\n\t// CaptionEntities is a list of special entities that appear in the caption,\n\t// which can be specified instead of parse_mode\n\t//\n\t// optional\n\tCaptionEntities []MessageEntity `json:\"caption_entities,omitempty\"`\n\t// ReplyMarkup inline keyboard attached to the message.\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\t// InputMessageContent content of the message to be sent instead of the GIF animation.\n\t//\n\t// optional\n\tInputMessageContent interface{} `json:\"input_message_content,omitempty\"`\n}\n\n// InlineQueryResultCachedMPEG4GIF is an inline query response with cached\n// H.264/MPEG-4 AVC video without sound gif.\ntype InlineQueryResultCachedMPEG4GIF struct {\n\t// Type of the result, must be mpeg4_gif\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 bytes\n\tID string `json:\"id\"`\n\t// MPEG4FileID a valid file identifier for the MP4 file\n\tMPEG4FileID string `json:\"mpeg4_file_id\"`\n\t// Title for the result\n\t//\n\t// optional\n\tTitle string `json:\"title,omitempty\"`\n\t// Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing.\n\t//\n\t// optional\n\tCaption string `json:\"caption,omitempty\"`\n\t// ParseMode mode for parsing entities in the caption.\n\t// See formatting options for more details\n\t// (https://core.telegram.org/bots/api#formatting-options).\n\t//\n\t// optional\n\tParseMode string `json:\"parse_mode,omitempty\"`\n\t// ParseMode mode for parsing entities in the video caption.\n\t// See formatting options for more details\n\t// (https://core.telegram.org/bots/api#formatting-options).\n\t//\n\t// optional\n\tCaptionEntities []MessageEntity `json:\"caption_entities,omitempty\"`\n\t// ReplyMarkup inline keyboard attached to the message.\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\t// InputMessageContent content of the message to be sent instead of the video animation.\n\t//\n\t// optional\n\tInputMessageContent interface{} `json:\"input_message_content,omitempty\"`\n}\n\n// InlineQueryResultCachedPhoto is an inline query response with cached photo.\ntype InlineQueryResultCachedPhoto struct {\n\t// Type of the result, must be a photo.\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 bytes.\n\tID string `json:\"id\"`\n\t// PhotoID a valid file identifier of the photo.\n\tPhotoID string `json:\"photo_file_id\"`\n\t// Title for the result.\n\t//\n\t// optional\n\tTitle string `json:\"title,omitempty\"`\n\t// Description short description of the result.\n\t//\n\t// optional\n\tDescription string `json:\"description,omitempty\"`\n\t// Caption of the photo to be sent, 0-1024 characters after entities parsing.\n\t//\n\t// optional\n\tCaption string `json:\"caption,omitempty\"`\n\t// ParseMode mode for parsing entities in the photo caption.\n\t// See formatting options for more details\n\t// (https://core.telegram.org/bots/api#formatting-options).\n\t//\n\t// optional\n\tParseMode string `json:\"parse_mode,omitempty\"`\n\t// CaptionEntities is a list of special entities that appear in the caption,\n\t// which can be specified instead of parse_mode\n\t//\n\t// optional\n\tCaptionEntities []MessageEntity `json:\"caption_entities,omitempty\"`\n\t// ReplyMarkup inline keyboard attached to the message.\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\t// InputMessageContent content of the message to be sent instead of the photo.\n\t//\n\t// optional\n\tInputMessageContent interface{} `json:\"input_message_content,omitempty\"`\n}\n\n// InlineQueryResultCachedSticker is an inline query response with cached sticker.\ntype InlineQueryResultCachedSticker struct {\n\t// Type of the result, must be a sticker\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 bytes\n\tID string `json:\"id\"`\n\t// StickerID a valid file identifier of the sticker\n\tStickerID string `json:\"sticker_file_id\"`\n\t// Title is a title\n\tTitle string `json:\"title\"`\n\t// ReplyMarkup inline keyboard attached to the message\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\t// InputMessageContent content of the message to be sent instead of the sticker\n\t//\n\t// optional\n\tInputMessageContent interface{} `json:\"input_message_content,omitempty\"`\n}\n\n// InlineQueryResultCachedVideo is an inline query response with cached video.\ntype InlineQueryResultCachedVideo struct {\n\t// Type of the result, must be video\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 bytes\n\tID string `json:\"id\"`\n\t// VideoID a valid file identifier for the video file\n\tVideoID string `json:\"video_file_id\"`\n\t// Title for the result\n\tTitle string `json:\"title\"`\n\t// Description short description of the result\n\t//\n\t// optional\n\tDescription string `json:\"description,omitempty\"`\n\t// Caption of the video to be sent, 0-1024 characters after entities parsing\n\t//\n\t// optional\n\tCaption string `json:\"caption,omitempty\"`\n\t// ParseMode mode for parsing entities in the video caption.\n\t// See formatting options for more details\n\t// (https://core.telegram.org/bots/api#formatting-options).\n\t//\n\t// optional\n\tParseMode string `json:\"parse_mode,omitempty\"`\n\t// CaptionEntities is a list of special entities that appear in the caption,\n\t// which can be specified instead of parse_mode\n\t//\n\t// optional\n\tCaptionEntities []MessageEntity `json:\"caption_entities,omitempty\"`\n\t// ReplyMarkup inline keyboard attached to the message\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\t// InputMessageContent content of the message to be sent instead of the video\n\t//\n\t// optional\n\tInputMessageContent interface{} `json:\"input_message_content,omitempty\"`\n}\n\n// InlineQueryResultCachedVoice is an inline query response with cached voice.\ntype InlineQueryResultCachedVoice struct {\n\t// Type of the result, must be voice\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 bytes\n\tID string `json:\"id\"`\n\t// VoiceID a valid file identifier for the voice message\n\tVoiceID string `json:\"voice_file_id\"`\n\t// Title voice message title\n\tTitle string `json:\"title\"`\n\t// Caption 0-1024 characters after entities parsing\n\t//\n\t// optional\n\tCaption string `json:\"caption,omitempty\"`\n\t// ParseMode mode for parsing entities in the video caption.\n\t// See formatting options for more details\n\t// (https://core.telegram.org/bots/api#formatting-options).\n\t//\n\t// optional\n\tParseMode string `json:\"parse_mode,omitempty\"`\n\t// CaptionEntities is a list of special entities that appear in the caption,\n\t// which can be specified instead of parse_mode\n\t//\n\t// optional\n\tCaptionEntities []MessageEntity `json:\"caption_entities,omitempty\"`\n\t// ReplyMarkup inline keyboard attached to the message\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\t// InputMessageContent content of the message to be sent instead of the voice message\n\t//\n\t// optional\n\tInputMessageContent interface{} `json:\"input_message_content,omitempty\"`\n}\n\n// InlineQueryResultArticle represents a link to an article or web page.\ntype InlineQueryResultArticle struct {\n\t// Type of the result, must be article.\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 Bytes.\n\tID string `json:\"id\"`\n\t// Title of the result\n\tTitle string `json:\"title\"`\n\t// InputMessageContent content of the message to be sent.\n\tInputMessageContent interface{} `json:\"input_message_content,omitempty\"`\n\t// ReplyMarkup Inline keyboard attached to the message.\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\t// URL of the result.\n\t//\n\t// optional\n\tURL string `json:\"url,omitempty\"`\n\t// HideURL pass True, if you don't want the URL to be shown in the message.\n\t//\n\t// optional\n\tHideURL bool `json:\"hide_url,omitempty\"`\n\t// Description short description of the result.\n\t//\n\t// optional\n\tDescription string `json:\"description,omitempty\"`\n\t// ThumbURL url of the thumbnail for the result\n\t//\n\t// optional\n\tThumbURL string `json:\"thumb_url,omitempty\"`\n\t// ThumbWidth thumbnail width\n\t//\n\t// optional\n\tThumbWidth int `json:\"thumb_width,omitempty\"`\n\t// ThumbHeight thumbnail height\n\t//\n\t// optional\n\tThumbHeight int `json:\"thumb_height,omitempty\"`\n}\n\n// InlineQueryResultAudio is an inline query response audio.\ntype InlineQueryResultAudio struct {\n\t// Type of the result, must be audio\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 bytes\n\tID string `json:\"id\"`\n\t// URL a valid url for the audio file\n\tURL string `json:\"audio_url\"`\n\t// Title is a title\n\tTitle string `json:\"title\"`\n\t// Caption 0-1024 characters after entities parsing\n\t//\n\t// optional\n\tCaption string `json:\"caption,omitempty\"`\n\t// ParseMode mode for parsing entities in the video caption.\n\t// See formatting options for more details\n\t// (https://core.telegram.org/bots/api#formatting-options).\n\t//\n\t// optional\n\tParseMode string `json:\"parse_mode,omitempty\"`\n\t// CaptionEntities is a list of special entities that appear in the caption,\n\t// which can be specified instead of parse_mode\n\t//\n\t// optional\n\tCaptionEntities []MessageEntity `json:\"caption_entities,omitempty\"`\n\t// Performer is a performer\n\t//\n\t// optional\n\tPerformer string `json:\"performer,omitempty\"`\n\t// Duration audio duration in seconds\n\t//\n\t// optional\n\tDuration int `json:\"audio_duration,omitempty\"`\n\t// ReplyMarkup inline keyboard attached to the message\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\t// InputMessageContent content of the message to be sent instead of the audio\n\t//\n\t// optional\n\tInputMessageContent interface{} `json:\"input_message_content,omitempty\"`\n}\n\n// InlineQueryResultContact is an inline query response contact.\ntype InlineQueryResultContact struct {\n\tType                string                `json:\"type\"`         // required\n\tID                  string                `json:\"id\"`           // required\n\tPhoneNumber         string                `json:\"phone_number\"` // required\n\tFirstName           string                `json:\"first_name\"`   // required\n\tLastName            string                `json:\"last_name\"`\n\tVCard               string                `json:\"vcard\"`\n\tReplyMarkup         *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\tInputMessageContent interface{}           `json:\"input_message_content,omitempty\"`\n\tThumbURL            string                `json:\"thumb_url\"`\n\tThumbWidth          int                   `json:\"thumb_width\"`\n\tThumbHeight         int                   `json:\"thumb_height\"`\n}\n\n// InlineQueryResultGame is an inline query response game.\ntype InlineQueryResultGame struct {\n\t// Type of the result, must be game\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 bytes\n\tID string `json:\"id\"`\n\t// GameShortName short name of the game\n\tGameShortName string `json:\"game_short_name\"`\n\t// ReplyMarkup inline keyboard attached to the message\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n}\n\n// InlineQueryResultDocument is an inline query response document.\ntype InlineQueryResultDocument struct {\n\t// Type of the result, must be a document\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 bytes\n\tID string `json:\"id\"`\n\t// Title for the result\n\tTitle string `json:\"title\"`\n\t// Caption of the document to be sent, 0-1024 characters after entities parsing\n\t//\n\t// optional\n\tCaption string `json:\"caption,omitempty\"`\n\t// URL a valid url for the file\n\tURL string `json:\"document_url\"`\n\t// MimeType of the content of the file, either “application/pdf” or “application/zip”\n\tMimeType string `json:\"mime_type\"`\n\t// Description short description of the result\n\t//\n\t// optional\n\tDescription string `json:\"description,omitempty\"`\n\t// ReplyMarkup inline keyboard attached to the message\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\t// InputMessageContent content of the message to be sent instead of the file\n\t//\n\t// optional\n\tInputMessageContent interface{} `json:\"input_message_content,omitempty\"`\n\t// ThumbURL url of the thumbnail (jpeg only) for the file\n\t//\n\t// optional\n\tThumbURL string `json:\"thumb_url,omitempty\"`\n\t// ThumbWidth thumbnail width\n\t//\n\t// optional\n\tThumbWidth int `json:\"thumb_width,omitempty\"`\n\t// ThumbHeight thumbnail height\n\t//\n\t// optional\n\tThumbHeight int `json:\"thumb_height,omitempty\"`\n}\n\n// InlineQueryResultGIF is an inline query response GIF.\ntype InlineQueryResultGIF struct {\n\t// Type of the result, must be gif.\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 bytes.\n\tID string `json:\"id\"`\n\t// URL a valid URL for the GIF file. File size must not exceed 1MB.\n\tURL string `json:\"gif_url\"`\n\t// ThumbURL url of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result.\n\tThumbURL string `json:\"thumb_url\"`\n\t// Width of the GIF\n\t//\n\t// optional\n\tWidth int `json:\"gif_width,omitempty\"`\n\t// Height of the GIF\n\t//\n\t// optional\n\tHeight int `json:\"gif_height,omitempty\"`\n\t// Duration of the GIF\n\t//\n\t// optional\n\tDuration int `json:\"gif_duration,omitempty\"`\n\t// Title for the result\n\t//\n\t// optional\n\tTitle string `json:\"title,omitempty\"`\n\t// Caption of the GIF file to be sent, 0-1024 characters after entities parsing.\n\t//\n\t// optional\n\tCaption string `json:\"caption,omitempty\"`\n\t// ParseMode mode for parsing entities in the video caption.\n\t// See formatting options for more details\n\t// (https://core.telegram.org/bots/api#formatting-options).\n\t//\n\t// optional\n\tParseMode string `json:\"parse_mode,omitempty\"`\n\t// CaptionEntities is a list of special entities that appear in the caption,\n\t// which can be specified instead of parse_mode\n\t//\n\t// optional\n\tCaptionEntities []MessageEntity `json:\"caption_entities,omitempty\"`\n\t// ReplyMarkup inline keyboard attached to the message\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\t// InputMessageContent content of the message to be sent instead of the GIF animation.\n\t//\n\t// optional\n\tInputMessageContent interface{} `json:\"input_message_content,omitempty\"`\n}\n\n// InlineQueryResultLocation is an inline query response location.\ntype InlineQueryResultLocation struct {\n\t// Type of the result, must be location\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 Bytes\n\tID string `json:\"id\"`\n\t// Latitude  of the location in degrees\n\tLatitude float64 `json:\"latitude\"`\n\t// Longitude of the location in degrees\n\tLongitude float64 `json:\"longitude\"`\n\t// Title of the location\n\tTitle string `json:\"title\"`\n\t// HorizontalAccuracy is the radius of uncertainty for the location,\n\t// measured in meters; 0-1500\n\t//\n\t// optional\n\tHorizontalAccuracy float64 `json:\"horizontal_accuracy,omitempty\"`\n\t// LivePeriod is the period in seconds for which the location can be\n\t// updated, should be between 60 and 86400.\n\t//\n\t// optional\n\tLivePeriod int `json:\"live_period,omitempty\"`\n\t// Heading is for live locations, a direction in which the user is moving,\n\t// in degrees. Must be between 1 and 360 if specified.\n\t//\n\t// optional\n\tHeading int `json:\"heading,omitempty\"`\n\t// ProximityAlertRadius is for live locations, a maximum distance for\n\t// proximity alerts about approaching another chat member, in meters. Must\n\t// be between 1 and 100000 if specified.\n\t//\n\t// optional\n\tProximityAlertRadius int `json:\"proximity_alert_radius,omitempty\"`\n\t// ReplyMarkup inline keyboard attached to the message\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\t// InputMessageContent content of the message to be sent instead of the location\n\t//\n\t// optional\n\tInputMessageContent interface{} `json:\"input_message_content,omitempty\"`\n\t// ThumbURL url of the thumbnail for the result\n\t//\n\t// optional\n\tThumbURL string `json:\"thumb_url,omitempty\"`\n\t// ThumbWidth thumbnail width\n\t//\n\t// optional\n\tThumbWidth int `json:\"thumb_width,omitempty\"`\n\t// ThumbHeight thumbnail height\n\t//\n\t// optional\n\tThumbHeight int `json:\"thumb_height,omitempty\"`\n}\n\n// InlineQueryResultMPEG4GIF is an inline query response MPEG4 GIF.\ntype InlineQueryResultMPEG4GIF struct {\n\t// Type of the result, must be mpeg4_gif\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 bytes\n\tID string `json:\"id\"`\n\t// URL a valid URL for the MP4 file. File size must not exceed 1MB\n\tURL string `json:\"mpeg4_url\"`\n\t// Width video width\n\t//\n\t// optional\n\tWidth int `json:\"mpeg4_width,omitempty\"`\n\t// Height vVideo height\n\t//\n\t// optional\n\tHeight int `json:\"mpeg4_height,omitempty\"`\n\t// Duration video duration\n\t//\n\t// optional\n\tDuration int `json:\"mpeg4_duration,omitempty\"`\n\t// ThumbURL url of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result.\n\tThumbURL string `json:\"thumb_url\"`\n\t// Title for the result\n\t//\n\t// optional\n\tTitle string `json:\"title,omitempty\"`\n\t// Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing.\n\t//\n\t// optional\n\tCaption string `json:\"caption,omitempty\"`\n\t// ParseMode mode for parsing entities in the video caption.\n\t// See formatting options for more details\n\t// (https://core.telegram.org/bots/api#formatting-options).\n\t//\n\t// optional\n\tParseMode string `json:\"parse_mode,omitempty\"`\n\t// CaptionEntities is a list of special entities that appear in the caption,\n\t// which can be specified instead of parse_mode\n\t//\n\t// optional\n\tCaptionEntities []MessageEntity `json:\"caption_entities,omitempty\"`\n\t// ReplyMarkup inline keyboard attached to the message\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\t// InputMessageContent content of the message to be sent instead of the video animation\n\t//\n\t// optional\n\tInputMessageContent interface{} `json:\"input_message_content,omitempty\"`\n}\n\n// InlineQueryResultPhoto is an inline query response photo.\ntype InlineQueryResultPhoto struct {\n\t// Type of the result, must be article.\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 Bytes.\n\tID string `json:\"id\"`\n\t// URL a valid URL of the photo. Photo must be in jpeg format.\n\t// Photo size must not exceed 5MB.\n\tURL string `json:\"photo_url\"`\n\t// MimeType\n\tMimeType string `json:\"mime_type\"`\n\t// Width of the photo\n\t//\n\t// optional\n\tWidth int `json:\"photo_width,omitempty\"`\n\t// Height of the photo\n\t//\n\t// optional\n\tHeight int `json:\"photo_height,omitempty\"`\n\t// ThumbURL url of the thumbnail for the photo.\n\t//\n\t// optional\n\tThumbURL string `json:\"thumb_url,omitempty\"`\n\t// Title for the result\n\t//\n\t// optional\n\tTitle string `json:\"title,omitempty\"`\n\t// Description short description of the result\n\t//\n\t// optional\n\tDescription string `json:\"description,omitempty\"`\n\t// Caption of the photo to be sent, 0-1024 characters after entities parsing.\n\t//\n\t// optional\n\tCaption string `json:\"caption,omitempty\"`\n\t// ParseMode mode for parsing entities in the photo caption.\n\t// See formatting options for more details\n\t// (https://core.telegram.org/bots/api#formatting-options).\n\t//\n\t// optional\n\tParseMode string `json:\"parse_mode,omitempty\"`\n\t// ReplyMarkup inline keyboard attached to the message.\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\t// CaptionEntities is a list of special entities that appear in the caption,\n\t// which can be specified instead of parse_mode\n\t//\n\t// optional\n\tCaptionEntities []MessageEntity `json:\"caption_entities,omitempty\"`\n\t// InputMessageContent content of the message to be sent instead of the photo.\n\t//\n\t// optional\n\tInputMessageContent interface{} `json:\"input_message_content,omitempty\"`\n}\n\n// InlineQueryResultVenue is an inline query response venue.\ntype InlineQueryResultVenue struct {\n\t// Type of the result, must be venue\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 Bytes\n\tID string `json:\"id\"`\n\t// Latitude of the venue location in degrees\n\tLatitude float64 `json:\"latitude\"`\n\t// Longitude of the venue location in degrees\n\tLongitude float64 `json:\"longitude\"`\n\t// Title of the venue\n\tTitle string `json:\"title\"`\n\t// Address of the venue\n\tAddress string `json:\"address\"`\n\t// FoursquareID foursquare identifier of the venue if known\n\t//\n\t// optional\n\tFoursquareID string `json:\"foursquare_id,omitempty\"`\n\t// FoursquareType foursquare type of the venue, if known.\n\t// (For example, “arts_entertainment/default”, “arts_entertainment/aquarium” or “food/icecream”.)\n\t//\n\t// optional\n\tFoursquareType string `json:\"foursquare_type,omitempty\"`\n\t// GooglePlaceID is the Google Places identifier of the venue\n\t//\n\t// optional\n\tGooglePlaceID string `json:\"google_place_id,omitempty\"`\n\t// GooglePlaceType is the Google Places type of the venue\n\t//\n\t// optional\n\tGooglePlaceType string `json:\"google_place_type,omitempty\"`\n\t// ReplyMarkup inline keyboard attached to the message\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\t// InputMessageContent content of the message to be sent instead of the venue\n\t//\n\t// optional\n\tInputMessageContent interface{} `json:\"input_message_content,omitempty\"`\n\t// ThumbURL url of the thumbnail for the result\n\t//\n\t// optional\n\tThumbURL string `json:\"thumb_url,omitempty\"`\n\t// ThumbWidth thumbnail width\n\t//\n\t// optional\n\tThumbWidth int `json:\"thumb_width,omitempty\"`\n\t// ThumbHeight thumbnail height\n\t//\n\t// optional\n\tThumbHeight int `json:\"thumb_height,omitempty\"`\n}\n\n// InlineQueryResultVideo is an inline query response video.\ntype InlineQueryResultVideo struct {\n\t// Type of the result, must be video\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 bytes\n\tID string `json:\"id\"`\n\t// URL a valid url for the embedded video player or video file\n\tURL string `json:\"video_url\"`\n\t// MimeType of the content of video url, “text/html” or “video/mp4”\n\tMimeType string `json:\"mime_type\"`\n\t//\n\t// ThumbURL url of the thumbnail (jpeg only) for the video\n\t// optional\n\tThumbURL string `json:\"thumb_url,omitempty\"`\n\t// Title for the result\n\tTitle string `json:\"title\"`\n\t// Caption of the video to be sent, 0-1024 characters after entities parsing\n\t//\n\t// optional\n\tCaption string `json:\"caption,omitempty\"`\n\t// Width video width\n\t//\n\t// optional\n\tWidth int `json:\"video_width,omitempty\"`\n\t// Height video height\n\t//\n\t// optional\n\tHeight int `json:\"video_height,omitempty\"`\n\t// Duration video duration in seconds\n\t//\n\t// optional\n\tDuration int `json:\"video_duration,omitempty\"`\n\t// Description short description of the result\n\t//\n\t// optional\n\tDescription string `json:\"description,omitempty\"`\n\t// ReplyMarkup inline keyboard attached to the message\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\t// InputMessageContent content of the message to be sent instead of the video.\n\t// This field is required if InlineQueryResultVideo is used to send\n\t// an HTML-page as a result (e.g., a YouTube video).\n\t//\n\t// optional\n\tInputMessageContent interface{} `json:\"input_message_content,omitempty\"`\n}\n\n// InlineQueryResultVoice is an inline query response voice.\ntype InlineQueryResultVoice struct {\n\t// Type of the result, must be voice\n\tType string `json:\"type\"`\n\t// ID unique identifier for this result, 1-64 bytes\n\tID string `json:\"id\"`\n\t// URL a valid URL for the voice recording\n\tURL string `json:\"voice_url\"`\n\t// Title recording title\n\tTitle string `json:\"title\"`\n\t// Caption 0-1024 characters after entities parsing\n\t//\n\t// optional\n\tCaption string `json:\"caption,omitempty\"`\n\t// ParseMode mode for parsing entities in the video caption.\n\t// See formatting options for more details\n\t// (https://core.telegram.org/bots/api#formatting-options).\n\t//\n\t// optional\n\tParseMode string `json:\"parse_mode,omitempty\"`\n\t// CaptionEntities is a list of special entities that appear in the caption,\n\t// which can be specified instead of parse_mode\n\t//\n\t// optional\n\tCaptionEntities []MessageEntity `json:\"caption_entities,omitempty\"`\n\t// Duration recording duration in seconds\n\t//\n\t// optional\n\tDuration int `json:\"voice_duration,omitempty\"`\n\t// ReplyMarkup inline keyboard attached to the message\n\t//\n\t// optional\n\tReplyMarkup *InlineKeyboardMarkup `json:\"reply_markup,omitempty\"`\n\t// InputMessageContent content of the message to be sent instead of the voice recording\n\t//\n\t// optional\n\tInputMessageContent interface{} `json:\"input_message_content,omitempty\"`\n}\n\n// ChosenInlineResult is an inline query result chosen by a User\ntype ChosenInlineResult struct {\n\t// ResultID the unique identifier for the result that was chosen\n\tResultID string `json:\"result_id\"`\n\t// From the user that chose the result\n\tFrom *User `json:\"from\"`\n\t// Location sender location, only for bots that require user location\n\t//\n\t// optional\n\tLocation *Location `json:\"location,omitempty\"`\n\t// InlineMessageID identifier of the sent inline message.\n\t// Available only if there is an inline keyboard attached to the message.\n\t// Will be also received in callback queries and can be used to edit the message.\n\t//\n\t// optional\n\tInlineMessageID string `json:\"inline_message_id,omitempty\"`\n\t// Query the query that was used to obtain the result\n\tQuery string `json:\"query\"`\n}\n\n// SentWebAppMessage contains information about an inline message sent by a Web App\n// on behalf of a user.\ntype SentWebAppMessage struct {\n\t// Identifier of the sent inline message. Available only if there is an inline\n\t// keyboard attached to the message.\n\t//\n\t// optional\n\tInlineMessageID string `json:\"inline_message_id,omitempty\"`\n}\n\n// InputTextMessageContent contains text for displaying\n// as an inline query result.\ntype InputTextMessageContent struct {\n\t// Text of the message to be sent, 1-4096 characters\n\tText string `json:\"message_text\"`\n\t// ParseMode mode for parsing entities in the message text.\n\t// See formatting options for more details\n\t// (https://core.telegram.org/bots/api#formatting-options).\n\t//\n\t// optional\n\tParseMode string `json:\"parse_mode,omitempty\"`\n\t// Entities is a list of special entities that appear in message text, which\n\t// can be specified instead of parse_mode\n\t//\n\t// optional\n\tEntities []MessageEntity `json:\"entities,omitempty\"`\n\t// DisableWebPagePreview disables link previews for links in the sent message\n\t//\n\t// optional\n\tDisableWebPagePreview bool `json:\"disable_web_page_preview,omitempty\"`\n}\n\n// InputLocationMessageContent contains a location for displaying\n// as an inline query result.\ntype InputLocationMessageContent struct {\n\t// Latitude of the location in degrees\n\tLatitude float64 `json:\"latitude\"`\n\t// Longitude of the location in degrees\n\tLongitude float64 `json:\"longitude\"`\n\t// HorizontalAccuracy is the radius of uncertainty for the location,\n\t// measured in meters; 0-1500\n\t//\n\t// optional\n\tHorizontalAccuracy float64 `json:\"horizontal_accuracy,omitempty\"`\n\t// LivePeriod is the period in seconds for which the location can be\n\t// updated, should be between 60 and 86400\n\t//\n\t// optional\n\tLivePeriod int `json:\"live_period,omitempty\"`\n\t// Heading is for live locations, a direction in which the user is moving,\n\t// in degrees. Must be between 1 and 360 if specified.\n\t//\n\t// optional\n\tHeading int `json:\"heading,omitempty\"`\n\t// ProximityAlertRadius is for live locations, a maximum distance for\n\t// proximity alerts about approaching another chat member, in meters. Must\n\t// be between 1 and 100000 if specified.\n\t//\n\t// optional\n\tProximityAlertRadius int `json:\"proximity_alert_radius,omitempty\"`\n}\n\n// InputVenueMessageContent contains a venue for displaying\n// as an inline query result.\ntype InputVenueMessageContent struct {\n\t// Latitude of the venue in degrees\n\tLatitude float64 `json:\"latitude\"`\n\t// Longitude of the venue in degrees\n\tLongitude float64 `json:\"longitude\"`\n\t// Title name of the venue\n\tTitle string `json:\"title\"`\n\t// Address of the venue\n\tAddress string `json:\"address\"`\n\t// FoursquareID foursquare identifier of the venue, if known\n\t//\n\t// optional\n\tFoursquareID string `json:\"foursquare_id,omitempty\"`\n\t// FoursquareType Foursquare type of the venue, if known\n\t//\n\t// optional\n\tFoursquareType string `json:\"foursquare_type,omitempty\"`\n\t// GooglePlaceID is the Google Places identifier of the venue\n\t//\n\t// optional\n\tGooglePlaceID string `json:\"google_place_id,omitempty\"`\n\t// GooglePlaceType is the Google Places type of the venue\n\t//\n\t// optional\n\tGooglePlaceType string `json:\"google_place_type,omitempty\"`\n}\n\n// InputContactMessageContent contains a contact for displaying\n// as an inline query result.\ntype InputContactMessageContent struct {\n\t// \tPhoneNumber contact's phone number\n\tPhoneNumber string `json:\"phone_number\"`\n\t// FirstName contact's first name\n\tFirstName string `json:\"first_name\"`\n\t// LastName contact's last name\n\t//\n\t// optional\n\tLastName string `json:\"last_name,omitempty\"`\n\t// Additional data about the contact in the form of a vCard\n\t//\n\t// optional\n\tVCard string `json:\"vcard,omitempty\"`\n}\n\n// InputInvoiceMessageContent represents the content of an invoice message to be\n// sent as the result of an inline query.\ntype InputInvoiceMessageContent struct {\n\t// Product name, 1-32 characters\n\tTitle string `json:\"title\"`\n\t// Product description, 1-255 characters\n\tDescription string `json:\"description\"`\n\t// Bot-defined invoice payload, 1-128 bytes. This will not be displayed to\n\t// the user, use for your internal processes.\n\tPayload string `json:\"payload\"`\n\t// Payment provider token, obtained via Botfather\n\tProviderToken string `json:\"provider_token\"`\n\t// Three-letter ISO 4217 currency code\n\tCurrency string `json:\"currency\"`\n\t// Price breakdown, a JSON-serialized list of components (e.g. product\n\t// price, tax, discount, delivery cost, delivery tax, bonus, etc.)\n\tPrices []LabeledPrice `json:\"prices\"`\n\t// The maximum accepted amount for tips in the smallest units of the\n\t// currency (integer, not float/double).\n\t//\n\t// optional\n\tMaxTipAmount int `json:\"max_tip_amount,omitempty\"`\n\t// An array of suggested amounts of tip in the smallest units of the\n\t// currency (integer, not float/double). At most 4 suggested tip amounts can\n\t// be specified. The suggested tip amounts must be positive, passed in a\n\t// strictly increased order and must not exceed max_tip_amount.\n\t//\n\t// optional\n\tSuggestedTipAmounts []int `json:\"suggested_tip_amounts,omitempty\"`\n\t// A JSON-serialized object for data about the invoice, which will be shared\n\t// with the payment provider. A detailed description of the required fields\n\t// should be provided by the payment provider.\n\t//\n\t// optional\n\tProviderData string `json:\"provider_data,omitempty\"`\n\t// URL of the product photo for the invoice. Can be a photo of the goods or\n\t// a marketing image for a service. People like it better when they see what\n\t// they are paying for.\n\t//\n\t// optional\n\tPhotoURL string `json:\"photo_url,omitempty\"`\n\t// Photo size\n\t//\n\t// optional\n\tPhotoSize int `json:\"photo_size,omitempty\"`\n\t// Photo width\n\t//\n\t// optional\n\tPhotoWidth int `json:\"photo_width,omitempty\"`\n\t// Photo height\n\t//\n\t// optional\n\tPhotoHeight int `json:\"photo_height,omitempty\"`\n\t// Pass True, if you require the user's full name to complete the order\n\t//\n\t// optional\n\tNeedName bool `json:\"need_name,omitempty\"`\n\t// Pass True, if you require the user's phone number to complete the order\n\t//\n\t// optional\n\tNeedPhoneNumber bool `json:\"need_phone_number,omitempty\"`\n\t// Pass True, if you require the user's email address to complete the order\n\t//\n\t// optional\n\tNeedEmail bool `json:\"need_email,omitempty\"`\n\t// Pass True, if you require the user's shipping address to complete the order\n\t//\n\t// optional\n\tNeedShippingAddress bool `json:\"need_shipping_address,omitempty\"`\n\t// Pass True, if user's phone number should be sent to provider\n\t//\n\t// optional\n\tSendPhoneNumberToProvider bool `json:\"send_phone_number_to_provider,omitempty\"`\n\t// Pass True, if user's email address should be sent to provider\n\t//\n\t// optional\n\tSendEmailToProvider bool `json:\"send_email_to_provider,omitempty\"`\n\t// Pass True, if the final price depends on the shipping method\n\t//\n\t// optional\n\tIsFlexible bool `json:\"is_flexible,omitempty\"`\n}\n\n// LabeledPrice represents a portion of the price for goods or services.\ntype LabeledPrice struct {\n\t// Label portion label\n\tLabel string `json:\"label\"`\n\t// Amount price of the product in the smallest units of the currency (integer, not float/double).\n\t// For example, for a price of US$ 1.45 pass amount = 145.\n\t// See the exp parameter in currencies.json\n\t// (https://core.telegram.org/bots/payments/currencies.json),\n\t// it shows the number of digits past the decimal point\n\t// for each currency (2 for the majority of currencies).\n\tAmount int `json:\"amount\"`\n}\n\n// Invoice contains basic information about an invoice.\ntype Invoice struct {\n\t// Title product name\n\tTitle string `json:\"title\"`\n\t// Description product description\n\tDescription string `json:\"description\"`\n\t// StartParameter unique bot deep-linking parameter that can be used to generate this invoice\n\tStartParameter string `json:\"start_parameter\"`\n\t// Currency three-letter ISO 4217 currency code\n\t// (see https://core.telegram.org/bots/payments#supported-currencies)\n\tCurrency string `json:\"currency\"`\n\t// TotalAmount total price in the smallest units of the currency (integer, not float/double).\n\t// For example, for a price of US$ 1.45 pass amount = 145.\n\t// See the exp parameter in currencies.json\n\t// (https://core.telegram.org/bots/payments/currencies.json),\n\t// it shows the number of digits past the decimal point\n\t// for each currency (2 for the majority of currencies).\n\tTotalAmount int `json:\"total_amount\"`\n}\n\n// ShippingAddress represents a shipping address.\ntype ShippingAddress struct {\n\t// CountryCode ISO 3166-1 alpha-2 country code\n\tCountryCode string `json:\"country_code\"`\n\t// State if applicable\n\tState string `json:\"state\"`\n\t// City city\n\tCity string `json:\"city\"`\n\t// StreetLine1 first line for the address\n\tStreetLine1 string `json:\"street_line1\"`\n\t// StreetLine2 second line for the address\n\tStreetLine2 string `json:\"street_line2\"`\n\t// PostCode address post code\n\tPostCode string `json:\"post_code\"`\n}\n\n// OrderInfo represents information about an order.\ntype OrderInfo struct {\n\t// Name user name\n\t//\n\t// optional\n\tName string `json:\"name,omitempty\"`\n\t// PhoneNumber user's phone number\n\t//\n\t// optional\n\tPhoneNumber string `json:\"phone_number,omitempty\"`\n\t// Email user email\n\t//\n\t// optional\n\tEmail string `json:\"email,omitempty\"`\n\t// ShippingAddress user shipping address\n\t//\n\t// optional\n\tShippingAddress *ShippingAddress `json:\"shipping_address,omitempty\"`\n}\n\n// ShippingOption represents one shipping option.\ntype ShippingOption struct {\n\t// ID shipping option identifier\n\tID string `json:\"id\"`\n\t// Title option title\n\tTitle string `json:\"title\"`\n\t// Prices list of price portions\n\tPrices []LabeledPrice `json:\"prices\"`\n}\n\n// SuccessfulPayment contains basic information about a successful payment.\ntype SuccessfulPayment struct {\n\t// Currency three-letter ISO 4217 currency code\n\t// (see https://core.telegram.org/bots/payments#supported-currencies)\n\tCurrency string `json:\"currency\"`\n\t// TotalAmount total price in the smallest units of the currency (integer, not float/double).\n\t// For example, for a price of US$ 1.45 pass amount = 145.\n\t// See the exp parameter in currencies.json,\n\t// (https://core.telegram.org/bots/payments/currencies.json)\n\t// it shows the number of digits past the decimal point\n\t// for each currency (2 for the majority of currencies).\n\tTotalAmount int `json:\"total_amount\"`\n\t// InvoicePayload bot specified invoice payload\n\tInvoicePayload string `json:\"invoice_payload\"`\n\t// ShippingOptionID identifier of the shipping option chosen by the user\n\t//\n\t// optional\n\tShippingOptionID string `json:\"shipping_option_id,omitempty\"`\n\t// OrderInfo order info provided by the user\n\t//\n\t// optional\n\tOrderInfo *OrderInfo `json:\"order_info,omitempty\"`\n\t// TelegramPaymentChargeID telegram payment identifier\n\tTelegramPaymentChargeID string `json:\"telegram_payment_charge_id\"`\n\t// ProviderPaymentChargeID provider payment identifier\n\tProviderPaymentChargeID string `json:\"provider_payment_charge_id\"`\n}\n\n// ShippingQuery contains information about an incoming shipping query.\ntype ShippingQuery struct {\n\t// ID unique query identifier\n\tID string `json:\"id\"`\n\t// From user who sent the query\n\tFrom *User `json:\"from\"`\n\t// InvoicePayload bot specified invoice payload\n\tInvoicePayload string `json:\"invoice_payload\"`\n\t// ShippingAddress user specified shipping address\n\tShippingAddress *ShippingAddress `json:\"shipping_address\"`\n}\n\n// PreCheckoutQuery contains information about an incoming pre-checkout query.\ntype PreCheckoutQuery struct {\n\t// ID unique query identifier\n\tID string `json:\"id\"`\n\t// From user who sent the query\n\tFrom *User `json:\"from\"`\n\t// Currency three-letter ISO 4217 currency code\n\t//\t// (see https://core.telegram.org/bots/payments#supported-currencies)\n\tCurrency string `json:\"currency\"`\n\t// TotalAmount total price in the smallest units of the currency (integer, not float/double).\n\t//\t// For example, for a price of US$ 1.45 pass amount = 145.\n\t//\t// See the exp parameter in currencies.json,\n\t//\t// (https://core.telegram.org/bots/payments/currencies.json)\n\t//\t// it shows the number of digits past the decimal point\n\t//\t// for each currency (2 for the majority of currencies).\n\tTotalAmount int `json:\"total_amount\"`\n\t// InvoicePayload bot specified invoice payload\n\tInvoicePayload string `json:\"invoice_payload\"`\n\t// ShippingOptionID identifier of the shipping option chosen by the user\n\t//\n\t// optional\n\tShippingOptionID string `json:\"shipping_option_id,omitempty\"`\n\t// OrderInfo order info provided by the user\n\t//\n\t// optional\n\tOrderInfo *OrderInfo `json:\"order_info,omitempty\"`\n}\n"
        },
        {
          "name": "types_test.go",
          "type": "blob",
          "size": 8.5546875,
          "content": "package tgbotapi\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestUserStringWith(t *testing.T) {\n\tuser := User{\n\t\tID:           0,\n\t\tFirstName:    \"Test\",\n\t\tLastName:     \"Test\",\n\t\tUserName:     \"\",\n\t\tLanguageCode: \"en\",\n\t\tIsBot:        false,\n\t}\n\n\tif user.String() != \"Test Test\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestUserStringWithUserName(t *testing.T) {\n\tuser := User{\n\t\tID:           0,\n\t\tFirstName:    \"Test\",\n\t\tLastName:     \"Test\",\n\t\tUserName:     \"@test\",\n\t\tLanguageCode: \"en\",\n\t}\n\n\tif user.String() != \"@test\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestMessageTime(t *testing.T) {\n\tmessage := Message{Date: 0}\n\n\tdate := time.Unix(0, 0)\n\tif message.Time() != date {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestMessageIsCommandWithCommand(t *testing.T) {\n\tmessage := Message{Text: \"/command\"}\n\tmessage.Entities = []MessageEntity{{Type: \"bot_command\", Offset: 0, Length: 8}}\n\n\tif !message.IsCommand() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestIsCommandWithText(t *testing.T) {\n\tmessage := Message{Text: \"some text\"}\n\n\tif message.IsCommand() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestIsCommandWithEmptyText(t *testing.T) {\n\tmessage := Message{Text: \"\"}\n\n\tif message.IsCommand() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestCommandWithCommand(t *testing.T) {\n\tmessage := Message{Text: \"/command\"}\n\tmessage.Entities = []MessageEntity{{Type: \"bot_command\", Offset: 0, Length: 8}}\n\n\tif message.Command() != \"command\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestCommandWithEmptyText(t *testing.T) {\n\tmessage := Message{Text: \"\"}\n\n\tif message.Command() != \"\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestCommandWithNonCommand(t *testing.T) {\n\tmessage := Message{Text: \"test text\"}\n\n\tif message.Command() != \"\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestCommandWithBotName(t *testing.T) {\n\tmessage := Message{Text: \"/command@testbot\"}\n\tmessage.Entities = []MessageEntity{{Type: \"bot_command\", Offset: 0, Length: 16}}\n\n\tif message.Command() != \"command\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestCommandWithAtWithBotName(t *testing.T) {\n\tmessage := Message{Text: \"/command@testbot\"}\n\tmessage.Entities = []MessageEntity{{Type: \"bot_command\", Offset: 0, Length: 16}}\n\n\tif message.CommandWithAt() != \"command@testbot\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestMessageCommandArgumentsWithArguments(t *testing.T) {\n\tmessage := Message{Text: \"/command with arguments\"}\n\tmessage.Entities = []MessageEntity{{Type: \"bot_command\", Offset: 0, Length: 8}}\n\tif message.CommandArguments() != \"with arguments\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestMessageCommandArgumentsWithMalformedArguments(t *testing.T) {\n\tmessage := Message{Text: \"/command-without argument space\"}\n\tmessage.Entities = []MessageEntity{{Type: \"bot_command\", Offset: 0, Length: 8}}\n\tif message.CommandArguments() != \"without argument space\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestMessageCommandArgumentsWithoutArguments(t *testing.T) {\n\tmessage := Message{Text: \"/command\"}\n\tif message.CommandArguments() != \"\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestMessageCommandArgumentsForNonCommand(t *testing.T) {\n\tmessage := Message{Text: \"test text\"}\n\tif message.CommandArguments() != \"\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestMessageEntityParseURLGood(t *testing.T) {\n\tentity := MessageEntity{URL: \"https://www.google.com\"}\n\n\tif _, err := entity.ParseURL(); err != nil {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestMessageEntityParseURLBad(t *testing.T) {\n\tentity := MessageEntity{URL: \"\"}\n\n\tif _, err := entity.ParseURL(); err == nil {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestChatIsPrivate(t *testing.T) {\n\tchat := Chat{ID: 10, Type: \"private\"}\n\n\tif !chat.IsPrivate() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestChatIsGroup(t *testing.T) {\n\tchat := Chat{ID: 10, Type: \"group\"}\n\n\tif !chat.IsGroup() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestChatIsChannel(t *testing.T) {\n\tchat := Chat{ID: 10, Type: \"channel\"}\n\n\tif !chat.IsChannel() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestChatIsSuperGroup(t *testing.T) {\n\tchat := Chat{ID: 10, Type: \"supergroup\"}\n\n\tif !chat.IsSuperGroup() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestMessageEntityIsMention(t *testing.T) {\n\tentity := MessageEntity{Type: \"mention\"}\n\n\tif !entity.IsMention() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestMessageEntityIsHashtag(t *testing.T) {\n\tentity := MessageEntity{Type: \"hashtag\"}\n\n\tif !entity.IsHashtag() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestMessageEntityIsBotCommand(t *testing.T) {\n\tentity := MessageEntity{Type: \"bot_command\"}\n\n\tif !entity.IsCommand() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestMessageEntityIsUrl(t *testing.T) {\n\tentity := MessageEntity{Type: \"url\"}\n\n\tif !entity.IsURL() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestMessageEntityIsEmail(t *testing.T) {\n\tentity := MessageEntity{Type: \"email\"}\n\n\tif !entity.IsEmail() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestMessageEntityIsBold(t *testing.T) {\n\tentity := MessageEntity{Type: \"bold\"}\n\n\tif !entity.IsBold() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestMessageEntityIsItalic(t *testing.T) {\n\tentity := MessageEntity{Type: \"italic\"}\n\n\tif !entity.IsItalic() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestMessageEntityIsCode(t *testing.T) {\n\tentity := MessageEntity{Type: \"code\"}\n\n\tif !entity.IsCode() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestMessageEntityIsPre(t *testing.T) {\n\tentity := MessageEntity{Type: \"pre\"}\n\n\tif !entity.IsPre() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestMessageEntityIsTextLink(t *testing.T) {\n\tentity := MessageEntity{Type: \"text_link\"}\n\n\tif !entity.IsTextLink() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestFileLink(t *testing.T) {\n\tfile := File{FilePath: \"test/test.txt\"}\n\n\tif file.Link(\"token\") != \"https://api.telegram.org/file/bottoken/test/test.txt\" {\n\t\tt.Fail()\n\t}\n}\n\n// Ensure all configs are sendable\nvar (\n\t_ Chattable = AnimationConfig{}\n\t_ Chattable = AnswerWebAppQueryConfig{}\n\t_ Chattable = AudioConfig{}\n\t_ Chattable = BanChatMemberConfig{}\n\t_ Chattable = BanChatSenderChatConfig{}\n\t_ Chattable = CallbackConfig{}\n\t_ Chattable = ChatActionConfig{}\n\t_ Chattable = ChatAdministratorsConfig{}\n\t_ Chattable = ChatInfoConfig{}\n\t_ Chattable = ChatInviteLinkConfig{}\n\t_ Chattable = CloseConfig{}\n\t_ Chattable = ContactConfig{}\n\t_ Chattable = CopyMessageConfig{}\n\t_ Chattable = CreateChatInviteLinkConfig{}\n\t_ Chattable = DeleteChatPhotoConfig{}\n\t_ Chattable = DeleteChatStickerSetConfig{}\n\t_ Chattable = DeleteMessageConfig{}\n\t_ Chattable = DeleteMyCommandsConfig{}\n\t_ Chattable = DeleteWebhookConfig{}\n\t_ Chattable = DocumentConfig{}\n\t_ Chattable = EditChatInviteLinkConfig{}\n\t_ Chattable = EditMessageCaptionConfig{}\n\t_ Chattable = EditMessageLiveLocationConfig{}\n\t_ Chattable = EditMessageMediaConfig{}\n\t_ Chattable = EditMessageReplyMarkupConfig{}\n\t_ Chattable = EditMessageTextConfig{}\n\t_ Chattable = FileConfig{}\n\t_ Chattable = ForwardConfig{}\n\t_ Chattable = GameConfig{}\n\t_ Chattable = GetChatMemberConfig{}\n\t_ Chattable = GetChatMenuButtonConfig{}\n\t_ Chattable = GetGameHighScoresConfig{}\n\t_ Chattable = GetMyDefaultAdministratorRightsConfig{}\n\t_ Chattable = InlineConfig{}\n\t_ Chattable = InvoiceConfig{}\n\t_ Chattable = KickChatMemberConfig{}\n\t_ Chattable = LeaveChatConfig{}\n\t_ Chattable = LocationConfig{}\n\t_ Chattable = LogOutConfig{}\n\t_ Chattable = MediaGroupConfig{}\n\t_ Chattable = MessageConfig{}\n\t_ Chattable = PhotoConfig{}\n\t_ Chattable = PinChatMessageConfig{}\n\t_ Chattable = PreCheckoutConfig{}\n\t_ Chattable = PromoteChatMemberConfig{}\n\t_ Chattable = RestrictChatMemberConfig{}\n\t_ Chattable = RevokeChatInviteLinkConfig{}\n\t_ Chattable = SendPollConfig{}\n\t_ Chattable = SetChatDescriptionConfig{}\n\t_ Chattable = SetChatMenuButtonConfig{}\n\t_ Chattable = SetChatPhotoConfig{}\n\t_ Chattable = SetChatTitleConfig{}\n\t_ Chattable = SetGameScoreConfig{}\n\t_ Chattable = SetMyDefaultAdministratorRightsConfig{}\n\t_ Chattable = ShippingConfig{}\n\t_ Chattable = StickerConfig{}\n\t_ Chattable = StopMessageLiveLocationConfig{}\n\t_ Chattable = StopPollConfig{}\n\t_ Chattable = UnbanChatMemberConfig{}\n\t_ Chattable = UnbanChatSenderChatConfig{}\n\t_ Chattable = UnpinChatMessageConfig{}\n\t_ Chattable = UpdateConfig{}\n\t_ Chattable = UserProfilePhotosConfig{}\n\t_ Chattable = VenueConfig{}\n\t_ Chattable = VideoConfig{}\n\t_ Chattable = VideoNoteConfig{}\n\t_ Chattable = VoiceConfig{}\n\t_ Chattable = WebhookConfig{}\n)\n\n// Ensure all Fileable types are correct.\nvar (\n\t_ Fileable = (*PhotoConfig)(nil)\n\t_ Fileable = (*AudioConfig)(nil)\n\t_ Fileable = (*DocumentConfig)(nil)\n\t_ Fileable = (*StickerConfig)(nil)\n\t_ Fileable = (*VideoConfig)(nil)\n\t_ Fileable = (*AnimationConfig)(nil)\n\t_ Fileable = (*VideoNoteConfig)(nil)\n\t_ Fileable = (*VoiceConfig)(nil)\n\t_ Fileable = (*SetChatPhotoConfig)(nil)\n\t_ Fileable = (*EditMessageMediaConfig)(nil)\n\t_ Fileable = (*SetChatPhotoConfig)(nil)\n\t_ Fileable = (*UploadStickerConfig)(nil)\n\t_ Fileable = (*NewStickerSetConfig)(nil)\n\t_ Fileable = (*AddStickerConfig)(nil)\n\t_ Fileable = (*MediaGroupConfig)(nil)\n\t_ Fileable = (*WebhookConfig)(nil)\n\t_ Fileable = (*SetStickerSetThumbConfig)(nil)\n)\n\n// Ensure all RequestFileData types are correct.\nvar (\n\t_ RequestFileData = (*FilePath)(nil)\n\t_ RequestFileData = (*FileBytes)(nil)\n\t_ RequestFileData = (*FileReader)(nil)\n\t_ RequestFileData = (*FileURL)(nil)\n\t_ RequestFileData = (*FileID)(nil)\n\t_ RequestFileData = (*fileAttach)(nil)\n)\n"
        }
      ]
    }
  ]
}