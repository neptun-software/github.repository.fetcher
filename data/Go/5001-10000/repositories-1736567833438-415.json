{
  "metadata": {
    "timestamp": 1736567833438,
    "page": 415,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "emicklei/go-restful",
      "stars": 5053,
      "defaultBranch": "v3",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.890625,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n\nrestful.html\n\n*.out\n\ntmp.prof\n\ngo-restful.test\n\nexamples/restful-basic-authentication\n\nexamples/restful-encoding-filter\n\nexamples/restful-filters\n\nexamples/restful-hello-world\n\nexamples/restful-resource-functions\n\nexamples/restful-serve-static\n\nexamples/restful-user-service\n\n*.DS_Store\nexamples/restful-user-resource\n\nexamples/restful-multi-containers\n\nexamples/restful-form-handling\n\nexamples/restful-CORS-filter\n\nexamples/restful-options-filter\n\nexamples/restful-curly-router\n\nexamples/restful-cpuprofiler-service\n\nexamples/restful-pre-post-filters\n\ncurly.prof\n\nexamples/restful-NCSA-logging\n\nexamples/restful-html-template\n\ns.html\nrestful-path-tail\n.idea\n"
        },
        {
          "name": ".goconvey",
          "type": "blob",
          "size": 0.005859375,
          "content": "ignore"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.1845703125,
          "content": "language: go\n\ngo:\n  - 1.x\n\nbefore_install:\n  - go test -v\n\nscript:\n  - go test -race -coverprofile=coverage.txt -covermode=atomic\n\nafter_success:\n  - bash <(curl -s https://codecov.io/bash)"
        },
        {
          "name": "CHANGES.md",
          "type": "blob",
          "size": 10.7861328125,
          "content": "# Change history of go-restful\n\n\n## [v3.12.1] - 2024-05-28\n\n-  fix misroute when dealing multiple webservice with regex (#549) (thanks Haitao Chen)\n\n## [v3.12.0] - 2024-03-11\n\n- add Flush method #529 (#538)\n- fix: Improper handling of empty POST requests (#543)\n\n## [v3.11.3] - 2024-01-09\n\n- better not have 2 tags on one commit\n\n## [v3.11.1, v3.11.2] - 2024-01-09\n\n- fix by restoring custom JSON handler functions (Mike Beaumont #540)\n\n## [v3.11.0] - 2023-08-19\n\n- restored behavior as <= v3.9.0 with option to change path strategy using TrimRightSlashEnabled. \n\n## [v3.10.2] - 2023-03-09 - DO NOT USE\n\n- introduced MergePathStrategy to be able to revert behaviour of path concatenation to 3.9.0\n  see comment in Readme how to customize this behaviour.\n\n## [v3.10.1] - 2022-11-19 - DO NOT USE\n\n- fix broken 3.10.0 by using path package for joining paths\n\n## [v3.10.0] - 2022-10-11 - BROKEN\n\n- changed tokenizer to match std route match behavior; do not trimright the path (#511)\n- Add MIME_ZIP (#512)\n- Add MIME_ZIP and HEADER_ContentDisposition (#513)\n- Changed how to get query parameter issue #510\n\n## [v3.9.0] - 2022-07-21\n\n- add support for http.Handler implementations to work as FilterFunction, issue #504 (thanks to https://github.com/ggicci)\n\n## [v3.8.0] - 2022-06-06\n\n- use exact matching of allowed domain entries, issue #489 (#493)\n\t- this changes fixes [security] Authorization Bypass Through User-Controlled Key\n\t  by changing the behaviour of the AllowedDomains setting in the CORS filter.\n\t  To support the previous behaviour, the CORS filter type now has a AllowedDomainFunc\n\t  callback mechanism which is called when a simple domain match fails. \n- add test and fix for POST without body and Content-type, issue #492 (#496)\n- [Minor] Bad practice to have a mix of Receiver types. (#491)\n\n## [v3.7.2] - 2021-11-24\n\n- restored FilterChain (#482 by SVilgelm)\n\n\n## [v3.7.1] - 2021-10-04\n\n- fix problem with contentEncodingEnabled setting (#479)\n\n## [v3.7.0] - 2021-09-24\n\n- feat(parameter): adds additional openapi mappings (#478)\n\n## [v3.6.0] - 2021-09-18\n\n- add support for vendor extensions (#477 thx erraggy)\n\n## [v3.5.2] - 2021-07-14\n\n- fix removing absent route from webservice (#472)\n\n## [v3.5.1] - 2021-04-12\n\n- fix handling no match access selected path\n- remove obsolete field\n\n## [v3.5.0] - 2021-04-10\n\n- add check for wildcard (#463) in CORS\n- add access to Route from Request, issue #459 (#462)\n\n## [v3.4.0] - 2020-11-10\n\n- Added OPTIONS to WebService\n\n## [v3.3.2] - 2020-01-23\n\n- Fixed duplicate compression in dispatch. #449\n\n\n## [v3.3.1] - 2020-08-31\n\n- Added check on writer to prevent compression of response twice. #447\n\n## [v3.3.0] - 2020-08-19\n\n- Enable content encoding on Handle and ServeHTTP (#446)\n- List available representations in 406 body (#437)\n- Convert to string using rune() (#443)\n\n## [v3.2.0] - 2020-06-21\n\n- 405 Method Not Allowed must have Allow header (#436) (thx Bracken <abdawson@gmail.com>)\n- add field allowedMethodsWithoutContentType (#424)\n\n## [v3.1.0]\n\n- support describing response headers (#426)\n- fix openapi examples (#425)\n\nv3.0.0\n\n- fix: use request/response resulting from filter chain\n- add Go module\n  Module consumer should use github.com/emicklei/go-restful/v3 as import path\n\nv2.10.0\n\n- support for Custom Verbs (thanks Vinci Xu <277040271@qq.com>)\n- fixed static example (thanks Arthur <yang_yapo@126.com>)\n- simplify code (thanks Christian Muehlhaeuser <muesli@gmail.com>)\n- added JWT HMAC with SHA-512 authentication code example (thanks Amim Knabben <amim.knabben@gmail.com>)\n\nv2.9.6\n\n- small optimization in filter code\n\nv2.11.1\n\n- fix WriteError return value (#415)\n\nv2.11.0 \n\n- allow prefix and suffix in path variable expression (#414)\n\nv2.9.6\n\n- support google custome verb (#413)\n\nv2.9.5\n\n- fix panic in Response.WriteError if err == nil\n\nv2.9.4\n\n- fix issue #400 , parsing mime type quality\n- Route Builder added option for contentEncodingEnabled (#398)\n\nv2.9.3\n\n- Avoid return of 415 Unsupported Media Type when request body is empty (#396)\n\nv2.9.2\n\n- Reduce allocations in per-request methods to improve performance (#395)\n\nv2.9.1\n\n- Fix issue with default responses and invalid status code 0. (#393)\n\nv2.9.0\n\n- add per Route content encoding setting (overrides container setting)\n\nv2.8.0\n\n- add Request.QueryParameters()\n- add json-iterator (via build tag)\n- disable vgo module (until log is moved)\n\nv2.7.1\n\n- add vgo module\n\nv2.6.1\n\n- add JSONNewDecoderFunc to allow custom JSON Decoder usage (go 1.10+)\n\nv2.6.0\n\n- Make JSR 311 routing and path param processing consistent\n- Adding description to RouteBuilder.Reads()\n- Update example for Swagger12 and OpenAPI\n\n2017-09-13\n\n- added route condition functions using `.If(func)` in route building.\n\n2017-02-16\n\n- solved issue #304, make operation names unique\n\n2017-01-30\n \n\t[IMPORTANT] For swagger users, change your import statement to:\t\n\tswagger \"github.com/emicklei/go-restful-swagger12\"\n\n- moved swagger 1.2 code to go-restful-swagger12\n- created TAG 2.0.0\n\n2017-01-27\n\n- remove defer request body close\n- expose Dispatch for testing filters and Routefunctions\n- swagger response model cannot be array \n- created TAG 1.0.0\n\n2016-12-22\n\n- (API change) Remove code related to caching request content. Removes SetCacheReadEntity(doCache bool)\n\n2016-11-26\n\n- Default change! now use CurlyRouter (was RouterJSR311)\n- Default change! no more caching of request content\n- Default change! do not recover from panics\n\n2016-09-22\n\n- fix the DefaultRequestContentType feature\n\n2016-02-14\n\n- take the qualify factor of the Accept header mediatype into account when deciding the contentype of the response\n- add constructors for custom entity accessors for xml and json \n\n2015-09-27\n\n- rename new WriteStatusAnd... to WriteHeaderAnd... for consistency\n\n2015-09-25\n\n- fixed problem with changing Header after WriteHeader (issue 235)\n\n2015-09-14\n\n- changed behavior of WriteHeader (immediate write) and WriteEntity (no status write)\n- added support for custom EntityReaderWriters.\n\n2015-08-06\n\n- add support for reading entities from compressed request content\n- use sync.Pool for compressors of http response and request body\n- add Description to Parameter for documentation in Swagger UI\n\n2015-03-20\n\n- add configurable logging\n\n2015-03-18\n\n- if not specified, the Operation is derived from the Route function\n\n2015-03-17\n\n- expose Parameter creation functions\n- make trace logger an interface\n- fix OPTIONSFilter\n- customize rendering of ServiceError\n- JSR311 router now handles wildcards\n- add Notes to Route\n\n2014-11-27\n\n- (api add) PrettyPrint per response. (as proposed in #167)\n\n2014-11-12\n\n- (api add) ApiVersion(.) for documentation in Swagger UI\n\n2014-11-10\n\n- (api change) struct fields tagged with \"description\" show up in Swagger UI\n\n2014-10-31\n\n- (api change) ReturnsError -> Returns\n- (api add)    RouteBuilder.Do(aBuilder) for DRY use of RouteBuilder\n- fix swagger nested structs\n- sort Swagger response messages by code\n\n2014-10-23\n\n- (api add) ReturnsError allows you to document Http codes in swagger\n- fixed problem with greedy CurlyRouter\n- (api add) Access-Control-Max-Age in CORS\n- add tracing functionality (injectable) for debugging purposes\n- support JSON parse 64bit int \n- fix empty parameters for swagger\n- WebServicesUrl is now optional for swagger\n- fixed duplicate AccessControlAllowOrigin in CORS\n- (api change) expose ServeMux in container\n- (api add) added AllowedDomains in CORS\n- (api add) ParameterNamed for detailed documentation\n\n2014-04-16\n\n- (api add) expose constructor of Request for testing.\n\n2014-06-27\n\n- (api add) ParameterNamed gives access to a Parameter definition and its data (for further specification).\n- (api add) SetCacheReadEntity allow scontrol over whether or not the request body is being cached (default true for compatibility reasons).\n\n2014-07-03\n\n- (api add) CORS can be configured with a list of allowed domains\n\n2014-03-12\n\n- (api add) Route path parameters can use wildcard or regular expressions. (requires CurlyRouter)\n\n2014-02-26\n\n- (api add) Request now provides information about the matched Route, see method SelectedRoutePath \n\n2014-02-17\n\n- (api change) renamed parameter constants (go-lint checks)\n\n2014-01-10\n\n- (api add) support for CloseNotify, see http://golang.org/pkg/net/http/#CloseNotifier\n\n2014-01-07\n\n- (api change) Write* methods in Response now return the error or nil.\n- added example of serving HTML from a Go template.\n- fixed comparing Allowed headers in CORS (is now case-insensitive)\n\n2013-11-13\n\n- (api add) Response knows how many bytes are written to the response body.\n\n2013-10-29\n\n- (api add) RecoverHandler(handler RecoverHandleFunction) to change how panic recovery is handled. Default behavior is to log and return a stacktrace. This may be a security issue as it exposes sourcecode information.\n\n2013-10-04\n\n- (api add) Response knows what HTTP status has been written\n- (api add) Request can have attributes (map of string->interface, also called request-scoped variables\n\n2013-09-12\n\n- (api change) Router interface simplified\n- Implemented CurlyRouter, a Router that does not use|allow regular expressions in paths\n\n2013-08-05\n - add OPTIONS support\n - add CORS support\n\n2013-08-27\n\n- fixed some reported issues (see github)\n- (api change) deprecated use of WriteError; use WriteErrorString instead\n\n2014-04-15\n\n- (fix) v1.0.1 tag: fix Issue 111: WriteErrorString\n\n2013-08-08\n\n- (api add) Added implementation Container: a WebServices collection with its own http.ServeMux allowing multiple endpoints per program. Existing uses of go-restful will register their services to the DefaultContainer.\n- (api add) the swagger package has be extended to have a UI per container.\n- if panic is detected then a small stack trace is printed (thanks to runner-mei)\n- (api add) WriteErrorString to Response\n\nImportant API changes:\n\n- (api remove) package variable DoNotRecover no longer works ; use restful.DefaultContainer.DoNotRecover(true) instead.\n- (api remove) package variable EnableContentEncoding no longer works ; use restful.DefaultContainer.EnableContentEncoding(true) instead.\n \n \n2013-07-06\n\n- (api add) Added support for response encoding (gzip and deflate(zlib)). This feature is disabled on default (for backwards compatibility). Use restful.EnableContentEncoding = true in your initialization to enable this feature.\n\n2013-06-19\n\n- (improve) DoNotRecover option, moved request body closer, improved ReadEntity\n\n2013-06-03\n\n- (api change) removed Dispatcher interface, hide PathExpression\n- changed receiver names of type functions to be more idiomatic Go\n\n2013-06-02\n\n- (optimize) Cache the RegExp compilation of Paths.\n\n2013-05-22\n\t\n- (api add) Added support for request/response filter functions\n\n2013-05-18\n\n\n- (api add) Added feature to change the default Http Request Dispatch function (travis cline)\n- (api change) Moved Swagger Webservice to swagger package (see example restful-user)\n\n[2012-11-14 .. 2013-05-18>\n \n- See https://github.com/emicklei/go-restful/commits\n\n2012-11-14\n\n- Initial commit\n\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0498046875,
          "content": "Copyright (c) 2012,2013 Ernest Micklei\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.1279296875,
          "content": "all: test\n\ntest:\n\tgo vet .\n\tgo test -cover -v .\n\nex:\n\tfind ./examples -type f -name \"*.go\" | xargs -I {} go build -o /tmp/ignore {}"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.880859375,
          "content": "go-restful\n==========\npackage for building REST-style Web Services using Google Go\n\n[![Go Report Card](https://goreportcard.com/badge/github.com/emicklei/go-restful)](https://goreportcard.com/report/github.com/emicklei/go-restful)\n[![Go Reference](https://pkg.go.dev/badge/github.com/emicklei/go-restful.svg)](https://pkg.go.dev/github.com/emicklei/go-restful/v3)\n[![codecov](https://codecov.io/gh/emicklei/go-restful/branch/master/graph/badge.svg)](https://codecov.io/gh/emicklei/go-restful)\n\n- [Code examples use v3](https://github.com/emicklei/go-restful/tree/v3/examples)\n\nREST asks developers to use HTTP methods explicitly and in a way that's consistent with the protocol definition. This basic REST design principle establishes a one-to-one mapping between create, read, update, and delete (CRUD) operations and HTTP methods. According to this mapping:\n\n- GET = Retrieve a representation of a resource\n- POST = Create if you are sending content to the server to create a subordinate of the specified resource collection, using some server-side algorithm.\n- PUT = Create if you are sending the full content of the specified resource (URI).\n- PUT = Update if you are updating the full content of the specified resource.\n- DELETE = Delete if you are requesting the server to delete the resource\n- PATCH = Update partial content of a resource\n- OPTIONS = Get information about the communication options for the request URI\n    \n### Usage\n\n#### Without Go Modules\n\nAll versions up to `v2.*.*` (on the master) are not supporting Go modules.\n\n```\nimport (\n\trestful \"github.com/emicklei/go-restful\"\n)\n```\n\n#### Using Go Modules\n\nAs of version `v3.0.0` (on the v3 branch), this package supports Go modules.\n\n```\nimport (\n\trestful \"github.com/emicklei/go-restful/v3\"\n)\n```\n\n### Example\n\n```Go\nws := new(restful.WebService)\nws.\n\tPath(\"/users\").\n\tConsumes(restful.MIME_XML, restful.MIME_JSON).\n\tProduces(restful.MIME_JSON, restful.MIME_XML)\n\nws.Route(ws.GET(\"/{user-id}\").To(u.findUser).\n\tDoc(\"get a user\").\n\tParam(ws.PathParameter(\"user-id\", \"identifier of the user\").DataType(\"string\")).\n\tWrites(User{}))\t\t\n...\n\t\nfunc (u UserResource) findUser(request *restful.Request, response *restful.Response) {\n\tid := request.PathParameter(\"user-id\")\n\t...\n}\n```\n\t\n[Full API of a UserResource](https://github.com/emicklei/go-restful/blob/v3/examples/user-resource/restful-user-resource.go) \n\t\t\n### Features\n\n- Routes for request &#8594; function mapping with path parameter (e.g. {id} but also prefix_{var} and {var}_suffix) support\n- Configurable router:\n\t- (default) Fast routing algorithm that allows static elements, [google custom method](https://cloud.google.com/apis/design/custom_methods), regular expressions and dynamic parameters in the URL path (e.g. /resource/name:customVerb, /meetings/{id} or /static/{subpath:*})\n\t- Routing algorithm after [JSR311](http://jsr311.java.net/nonav/releases/1.1/spec/spec.html) that is implemented using (but does **not** accept) regular expressions\n- Request API for reading structs from JSON/XML and accessing parameters (path,query,header)\n- Response API for writing structs to JSON/XML and setting headers\n- Customizable encoding using EntityReaderWriter registration\n- Filters for intercepting the request &#8594; response flow on Service or Route level\n- Request-scoped variables using attributes\n- Containers for WebServices on different HTTP endpoints\n- Content encoding (gzip,deflate) of request and response payloads\n- Automatic responses on OPTIONS (using a filter)\n- Automatic CORS request handling (using a filter)\n- API declaration for Swagger UI ([go-restful-openapi](https://github.com/emicklei/go-restful-openapi))\n- Panic recovery to produce HTTP 500, customizable using RecoverHandler(...)\n- Route errors produce HTTP 404/405/406/415 errors, customizable using ServiceErrorHandler(...)\n- Configurable (trace) logging\n- Customizable gzip/deflate readers and writers using CompressorProvider registration\n- Inject your own http.Handler using the `HttpMiddlewareHandlerToFilter` function\n\n## How to customize\nThere are several hooks to customize the behavior of the go-restful package.\n\n- Router algorithm\n- Panic recovery\n- JSON decoder\n- Trace logging\n- Compression\n- Encoders for other serializers\n- Use the package variable `TrimRightSlashEnabled` (default true) to control the behavior of matching routes that end with a slash `/`\n\n## Resources\n\n- [Example programs](./examples)\n- [Example posted on blog](http://ernestmicklei.com/2012/11/go-restful-first-working-example/)\n- [Design explained on blog](http://ernestmicklei.com/2012/11/go-restful-api-design/)\n- [sourcegraph](https://sourcegraph.com/github.com/emicklei/go-restful)\n- [showcase: Zazkia - tcp proxy for testing resiliency](https://github.com/emicklei/zazkia)\n- [showcase: Mora - MongoDB REST Api server](https://github.com/emicklei/mora)\n\nType ```git shortlog -s``` for a full list of contributors.\n\n© 2012 - 2023, http://ernestmicklei.com. MIT License. Contributions are welcome.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.3486328125,
          "content": "# Security Policy\n\n## Supported Versions\n\n| Version | Supported          |\n| ------- | ------------------ |\n| v3.7.x     | :white_check_mark: |\n| < v3.0.1   | :x:                |\n\n## Reporting a Vulnerability\n\nCreate an Issue and put the label `[security]` in the title of the issue.\nValid reported security issues are expected to be solved within a week.\n"
        },
        {
          "name": "Srcfile",
          "type": "blob",
          "size": 0.0263671875,
          "content": "{\"SkipDirs\": [\"examples\"]}\n"
        },
        {
          "name": "bench_curly_test.go",
          "type": "blob",
          "size": 1.2646484375,
          "content": "package restful\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\nfunc setupCurly(container *Container) []string {\n\twsCount := 26\n\trtCount := 26\n\turisCurly := []string{}\n\n\tcontainer.Router(CurlyRouter{})\n\tfor i := 0; i < wsCount; i++ {\n\t\troot := fmt.Sprintf(\"/%s/{%s}/\", string(rune(i+97)), string(rune(i+97)))\n\t\tws := new(WebService).Path(root)\n\t\tfor j := 0; j < rtCount; j++ {\n\t\t\tsub := fmt.Sprintf(\"/%s2/{%s2}\", string(rune(j+97)), string(rune(j+97)))\n\t\t\tws.Route(ws.GET(sub).Consumes(\"application/xml\").Produces(\"application/xml\").To(echoCurly))\n\t\t}\n\t\tcontainer.Add(ws)\n\t\tfor _, each := range ws.Routes() {\n\t\t\turisCurly = append(urisCurly, \"http://bench.com\"+each.Path)\n\t\t}\n\t}\n\treturn urisCurly\n}\n\nfunc echoCurly(req *Request, resp *Response) {}\n\nfunc BenchmarkManyCurly(b *testing.B) {\n\tcontainer := NewContainer()\n\turisCurly := setupCurly(container)\n\tb.ResetTimer()\n\tfor t := 0; t < b.N; t++ {\n\t\tfor r := 0; r < 1000; r++ {\n\t\t\tfor _, each := range urisCurly {\n\t\t\t\tsendNoReturnTo(each, container, t)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc sendNoReturnTo(address string, container *Container, t int) {\n\thttpRequest, _ := http.NewRequest(\"GET\", address, nil)\n\thttpRequest.Header.Set(\"Accept\", \"application/xml\")\n\thttpWriter := httptest.NewRecorder()\n\tcontainer.dispatch(httpWriter, httpRequest)\n}\n"
        },
        {
          "name": "bench_test.go",
          "type": "blob",
          "size": 0.8349609375,
          "content": "package restful\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"testing\"\n)\n\nvar uris = []string{}\n\nfunc setup(container *Container) {\n\twsCount := 26\n\trtCount := 26\n\n\tfor i := 0; i < wsCount; i++ {\n\t\troot := fmt.Sprintf(\"/%s/{%s}/\", string(rune(i+97)), string(rune(i+97)))\n\t\tws := new(WebService).Path(root)\n\t\tfor j := 0; j < rtCount; j++ {\n\t\t\tsub := fmt.Sprintf(\"/%s2/{%s2}\", string(rune(j+97)), string(rune(j+97)))\n\t\t\tws.Route(ws.GET(sub).To(echo))\n\t\t}\n\t\tcontainer.Add(ws)\n\t\tfor _, each := range ws.Routes() {\n\t\t\turis = append(uris, \"http://bench.com\"+each.Path)\n\t\t}\n\t}\n}\n\nfunc echo(req *Request, resp *Response) {\n\tio.WriteString(resp.ResponseWriter, \"echo\")\n}\n\nfunc BenchmarkMany(b *testing.B) {\n\tcontainer := NewContainer()\n\tsetup(container)\n\tb.ResetTimer()\n\tfor t := 0; t < b.N; t++ {\n\t\tfor _, each := range uris {\n\t\t\t// println(each)\n\t\t\tsendItTo(each, container)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "bench_test.sh",
          "type": "blob",
          "size": 0.3447265625,
          "content": "#go test -run=none -file bench_test.go -test.bench . -cpuprofile=bench_test.out\n\ngo test -c\n./go-restful.test -test.run=none -test.cpuprofile=tmp.prof -test.bench=BenchmarkMany\n./go-restful.test -test.run=none -test.cpuprofile=curly.prof -test.bench=BenchmarkManyCurly\n\n#go tool pprof go-restful.test tmp.prof\ngo tool pprof go-restful.test curly.prof\n\n\n"
        },
        {
          "name": "compress.go",
          "type": "blob",
          "size": 4.189453125,
          "content": "package restful\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport (\n\t\"bufio\"\n\t\"compress/gzip\"\n\t\"compress/zlib\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n)\n\n// OBSOLETE : use restful.DefaultContainer.EnableContentEncoding(true) to change this setting.\nvar EnableContentEncoding = false\n\n// CompressingResponseWriter is a http.ResponseWriter that can perform content encoding (gzip and zlib)\ntype CompressingResponseWriter struct {\n\twriter     http.ResponseWriter\n\tcompressor io.WriteCloser\n\tencoding   string\n}\n\n// Header is part of http.ResponseWriter interface\nfunc (c *CompressingResponseWriter) Header() http.Header {\n\treturn c.writer.Header()\n}\n\n// WriteHeader is part of http.ResponseWriter interface\nfunc (c *CompressingResponseWriter) WriteHeader(status int) {\n\tc.writer.WriteHeader(status)\n}\n\n// Write is part of http.ResponseWriter interface\n// It is passed through the compressor\nfunc (c *CompressingResponseWriter) Write(bytes []byte) (int, error) {\n\tif c.isCompressorClosed() {\n\t\treturn -1, errors.New(\"Compressing error: tried to write data using closed compressor\")\n\t}\n\treturn c.compressor.Write(bytes)\n}\n\n// CloseNotify is part of http.CloseNotifier interface\nfunc (c *CompressingResponseWriter) CloseNotify() <-chan bool {\n\treturn c.writer.(http.CloseNotifier).CloseNotify()\n}\n\n// Flush is part of http.Flusher interface. Noop if the underlying writer doesn't support it.\nfunc (c *CompressingResponseWriter) Flush() {\n\tflusher, ok := c.writer.(http.Flusher)\n\tif !ok {\n\t\t// writer doesn't support http.Flusher interface\n\t\treturn\n\t}\n\tflusher.Flush()\n}\n\n// Close the underlying compressor\nfunc (c *CompressingResponseWriter) Close() error {\n\tif c.isCompressorClosed() {\n\t\treturn errors.New(\"Compressing error: tried to close already closed compressor\")\n\t}\n\n\tc.compressor.Close()\n\tif ENCODING_GZIP == c.encoding {\n\t\tcurrentCompressorProvider.ReleaseGzipWriter(c.compressor.(*gzip.Writer))\n\t}\n\tif ENCODING_DEFLATE == c.encoding {\n\t\tcurrentCompressorProvider.ReleaseZlibWriter(c.compressor.(*zlib.Writer))\n\t}\n\t// gc hint needed?\n\tc.compressor = nil\n\treturn nil\n}\n\nfunc (c *CompressingResponseWriter) isCompressorClosed() bool {\n\treturn nil == c.compressor\n}\n\n// Hijack implements the Hijacker interface\n// This is especially useful when combining Container.EnabledContentEncoding\n// in combination with websockets (for instance gorilla/websocket)\nfunc (c *CompressingResponseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\thijacker, ok := c.writer.(http.Hijacker)\n\tif !ok {\n\t\treturn nil, nil, errors.New(\"ResponseWriter doesn't support Hijacker interface\")\n\t}\n\treturn hijacker.Hijack()\n}\n\n// WantsCompressedResponse reads the Accept-Encoding header to see if and which encoding is requested.\n// It also inspects the httpWriter whether its content-encoding is already set (non-empty).\nfunc wantsCompressedResponse(httpRequest *http.Request, httpWriter http.ResponseWriter) (bool, string) {\n\tif contentEncoding := httpWriter.Header().Get(HEADER_ContentEncoding); contentEncoding != \"\" {\n\t\treturn false, \"\"\n\t}\n\theader := httpRequest.Header.Get(HEADER_AcceptEncoding)\n\tgi := strings.Index(header, ENCODING_GZIP)\n\tzi := strings.Index(header, ENCODING_DEFLATE)\n\t// use in order of appearance\n\tif gi == -1 {\n\t\treturn zi != -1, ENCODING_DEFLATE\n\t} else if zi == -1 {\n\t\treturn gi != -1, ENCODING_GZIP\n\t} else {\n\t\tif gi < zi {\n\t\t\treturn true, ENCODING_GZIP\n\t\t}\n\t\treturn true, ENCODING_DEFLATE\n\t}\n}\n\n// NewCompressingResponseWriter create a CompressingResponseWriter for a known encoding = {gzip,deflate}\nfunc NewCompressingResponseWriter(httpWriter http.ResponseWriter, encoding string) (*CompressingResponseWriter, error) {\n\thttpWriter.Header().Set(HEADER_ContentEncoding, encoding)\n\tc := new(CompressingResponseWriter)\n\tc.writer = httpWriter\n\tvar err error\n\tif ENCODING_GZIP == encoding {\n\t\tw := currentCompressorProvider.AcquireGzipWriter()\n\t\tw.Reset(httpWriter)\n\t\tc.compressor = w\n\t\tc.encoding = ENCODING_GZIP\n\t} else if ENCODING_DEFLATE == encoding {\n\t\tw := currentCompressorProvider.AcquireZlibWriter()\n\t\tw.Reset(httpWriter)\n\t\tc.compressor = w\n\t\tc.encoding = ENCODING_DEFLATE\n\t} else {\n\t\treturn nil, errors.New(\"Unknown encoding:\" + encoding)\n\t}\n\treturn c, err\n}\n"
        },
        {
          "name": "compress_test.go",
          "type": "blob",
          "size": 3.42578125,
          "content": "package restful\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"compress/zlib\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\n// go test -v -test.run TestGzip ...restful\nfunc TestGzip(t *testing.T) {\n\tEnableContentEncoding = true\n\thttpRequest, _ := http.NewRequest(\"GET\", \"/test\", nil)\n\thttpRequest.Header.Set(\"Accept-Encoding\", \"gzip,deflate\")\n\thttpWriter := httptest.NewRecorder()\n\twanted, encoding := wantsCompressedResponse(httpRequest, httpWriter)\n\tif !wanted {\n\t\tt.Fatal(\"should accept gzip\")\n\t}\n\tif encoding != \"gzip\" {\n\t\tt.Fatal(\"expected gzip\")\n\t}\n\tc, err := NewCompressingResponseWriter(httpWriter, encoding)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\tc.Write([]byte(\"Hello World\"))\n\tc.Close()\n\tif httpWriter.Header().Get(\"Content-Encoding\") != \"gzip\" {\n\t\tt.Fatal(\"Missing gzip header\")\n\t}\n\treader, err := gzip.NewReader(httpWriter.Body)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\tdata, err := ioutil.ReadAll(reader)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\tif got, want := string(data), \"Hello World\"; got != want {\n\t\tt.Errorf(\"got %v want %v\", got, want)\n\t}\n}\n\nfunc TestDeflate(t *testing.T) {\n\tEnableContentEncoding = true\n\thttpRequest, _ := http.NewRequest(\"GET\", \"/test\", nil)\n\thttpRequest.Header.Set(\"Accept-Encoding\", \"deflate,gzip\")\n\thttpWriter := httptest.NewRecorder()\n\twanted, encoding := wantsCompressedResponse(httpRequest, httpWriter)\n\tif !wanted {\n\t\tt.Fatal(\"should accept deflate\")\n\t}\n\tif encoding != \"deflate\" {\n\t\tt.Fatal(\"expected deflate\")\n\t}\n\tc, err := NewCompressingResponseWriter(httpWriter, encoding)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\tc.Write([]byte(\"Hello World\"))\n\tc.Close()\n\tif httpWriter.Header().Get(\"Content-Encoding\") != \"deflate\" {\n\t\tt.Fatal(\"Missing deflate header\")\n\t}\n\treader, err := zlib.NewReader(httpWriter.Body)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\tdata, err := ioutil.ReadAll(reader)\n\tif err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\tif got, want := string(data), \"Hello World\"; got != want {\n\t\tt.Errorf(\"got %v want %v\", got, want)\n\t}\n}\n\nfunc TestGzipDecompressRequestBody(t *testing.T) {\n\tb := new(bytes.Buffer)\n\tw := newGzipWriter()\n\tw.Reset(b)\n\tio.WriteString(w, `{\"msg\":\"hi\"}`)\n\tw.Flush()\n\tw.Close()\n\n\treq := new(Request)\n\thttpRequest, _ := http.NewRequest(\"GET\", \"/\", bytes.NewReader(b.Bytes()))\n\thttpRequest.Header.Set(\"Content-Type\", \"application/json\")\n\thttpRequest.Header.Set(\"Content-Encoding\", \"gzip\")\n\treq.Request = httpRequest\n\n\tdoc := make(map[string]interface{})\n\treq.ReadEntity(&doc)\n\n\tif got, want := doc[\"msg\"], \"hi\"; got != want {\n\t\tt.Errorf(\"got %v want %v\", got, want)\n\t}\n}\n\nfunc TestZlibDecompressRequestBody(t *testing.T) {\n\tb := new(bytes.Buffer)\n\tw := newZlibWriter()\n\tw.Reset(b)\n\tio.WriteString(w, `{\"msg\":\"hi\"}`)\n\tw.Flush()\n\tw.Close()\n\n\treq := new(Request)\n\thttpRequest, _ := http.NewRequest(\"GET\", \"/\", bytes.NewReader(b.Bytes()))\n\thttpRequest.Header.Set(\"Content-Type\", \"application/json\")\n\thttpRequest.Header.Set(\"Content-Encoding\", \"deflate\")\n\treq.Request = httpRequest\n\n\tdoc := make(map[string]interface{})\n\treq.ReadEntity(&doc)\n\n\tif got, want := doc[\"msg\"], \"hi\"; got != want {\n\t\tt.Errorf(\"got %v want %v\", got, want)\n\t}\n}\n\nfunc TestNoDuplicateCompressedResponse(t *testing.T) {\n\tEnableContentEncoding = true\n\thttpRequest, _ := http.NewRequest(\"GET\", \"/test\", nil)\n\thttpRequest.Header.Set(\"Accept-Encoding\", \"deflate,gzip\")\n\thttpWriter := httptest.NewRecorder()\n\thttpWriter.HeaderMap.Set(\"content-encoding\", \"gzip\")\n\tdo, _ := wantsCompressedResponse(httpRequest, httpWriter)\n\tif do {\n\t\tt.Fail()\n\t}\n}\n"
        },
        {
          "name": "compressor_cache.go",
          "type": "blob",
          "size": 3.1220703125,
          "content": "package restful\n\n// Copyright 2015 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport (\n\t\"compress/gzip\"\n\t\"compress/zlib\"\n)\n\n// BoundedCachedCompressors is a CompressorProvider that uses a cache with a fixed amount\n// of writers and readers (resources).\n// If a new resource is acquired and all are in use, it will return a new unmanaged resource.\ntype BoundedCachedCompressors struct {\n\tgzipWriters     chan *gzip.Writer\n\tgzipReaders     chan *gzip.Reader\n\tzlibWriters     chan *zlib.Writer\n\twritersCapacity int\n\treadersCapacity int\n}\n\n// NewBoundedCachedCompressors returns a new, with filled cache,  BoundedCachedCompressors.\nfunc NewBoundedCachedCompressors(writersCapacity, readersCapacity int) *BoundedCachedCompressors {\n\tb := &BoundedCachedCompressors{\n\t\tgzipWriters:     make(chan *gzip.Writer, writersCapacity),\n\t\tgzipReaders:     make(chan *gzip.Reader, readersCapacity),\n\t\tzlibWriters:     make(chan *zlib.Writer, writersCapacity),\n\t\twritersCapacity: writersCapacity,\n\t\treadersCapacity: readersCapacity,\n\t}\n\tfor ix := 0; ix < writersCapacity; ix++ {\n\t\tb.gzipWriters <- newGzipWriter()\n\t\tb.zlibWriters <- newZlibWriter()\n\t}\n\tfor ix := 0; ix < readersCapacity; ix++ {\n\t\tb.gzipReaders <- newGzipReader()\n\t}\n\treturn b\n}\n\n// AcquireGzipWriter returns an resettable *gzip.Writer. Needs to be released.\nfunc (b *BoundedCachedCompressors) AcquireGzipWriter() *gzip.Writer {\n\tvar writer *gzip.Writer\n\tselect {\n\tcase writer, _ = <-b.gzipWriters:\n\tdefault:\n\t\t// return a new unmanaged one\n\t\twriter = newGzipWriter()\n\t}\n\treturn writer\n}\n\n// ReleaseGzipWriter accepts a writer (does not have to be one that was cached)\n// only when the cache has room for it. It will ignore it otherwise.\nfunc (b *BoundedCachedCompressors) ReleaseGzipWriter(w *gzip.Writer) {\n\t// forget the unmanaged ones\n\tif len(b.gzipWriters) < b.writersCapacity {\n\t\tb.gzipWriters <- w\n\t}\n}\n\n// AcquireGzipReader returns a *gzip.Reader. Needs to be released.\nfunc (b *BoundedCachedCompressors) AcquireGzipReader() *gzip.Reader {\n\tvar reader *gzip.Reader\n\tselect {\n\tcase reader, _ = <-b.gzipReaders:\n\tdefault:\n\t\t// return a new unmanaged one\n\t\treader = newGzipReader()\n\t}\n\treturn reader\n}\n\n// ReleaseGzipReader accepts a reader (does not have to be one that was cached)\n// only when the cache has room for it. It will ignore it otherwise.\nfunc (b *BoundedCachedCompressors) ReleaseGzipReader(r *gzip.Reader) {\n\t// forget the unmanaged ones\n\tif len(b.gzipReaders) < b.readersCapacity {\n\t\tb.gzipReaders <- r\n\t}\n}\n\n// AcquireZlibWriter returns an resettable *zlib.Writer. Needs to be released.\nfunc (b *BoundedCachedCompressors) AcquireZlibWriter() *zlib.Writer {\n\tvar writer *zlib.Writer\n\tselect {\n\tcase writer, _ = <-b.zlibWriters:\n\tdefault:\n\t\t// return a new unmanaged one\n\t\twriter = newZlibWriter()\n\t}\n\treturn writer\n}\n\n// ReleaseZlibWriter accepts a writer (does not have to be one that was cached)\n// only when the cache has room for it. It will ignore it otherwise.\nfunc (b *BoundedCachedCompressors) ReleaseZlibWriter(w *zlib.Writer) {\n\t// forget the unmanaged ones\n\tif len(b.zlibWriters) < b.writersCapacity {\n\t\tb.zlibWriters <- w\n\t}\n}\n"
        },
        {
          "name": "compressor_pools.go",
          "type": "blob",
          "size": 2.34375,
          "content": "package restful\n\n// Copyright 2015 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"compress/zlib\"\n\t\"sync\"\n)\n\n// SyncPoolCompessors is a CompressorProvider that use the standard sync.Pool.\ntype SyncPoolCompessors struct {\n\tGzipWriterPool *sync.Pool\n\tGzipReaderPool *sync.Pool\n\tZlibWriterPool *sync.Pool\n}\n\n// NewSyncPoolCompessors returns a new (\"empty\") SyncPoolCompessors.\nfunc NewSyncPoolCompessors() *SyncPoolCompessors {\n\treturn &SyncPoolCompessors{\n\t\tGzipWriterPool: &sync.Pool{\n\t\t\tNew: func() interface{} { return newGzipWriter() },\n\t\t},\n\t\tGzipReaderPool: &sync.Pool{\n\t\t\tNew: func() interface{} { return newGzipReader() },\n\t\t},\n\t\tZlibWriterPool: &sync.Pool{\n\t\t\tNew: func() interface{} { return newZlibWriter() },\n\t\t},\n\t}\n}\n\nfunc (s *SyncPoolCompessors) AcquireGzipWriter() *gzip.Writer {\n\treturn s.GzipWriterPool.Get().(*gzip.Writer)\n}\n\nfunc (s *SyncPoolCompessors) ReleaseGzipWriter(w *gzip.Writer) {\n\ts.GzipWriterPool.Put(w)\n}\n\nfunc (s *SyncPoolCompessors) AcquireGzipReader() *gzip.Reader {\n\treturn s.GzipReaderPool.Get().(*gzip.Reader)\n}\n\nfunc (s *SyncPoolCompessors) ReleaseGzipReader(r *gzip.Reader) {\n\ts.GzipReaderPool.Put(r)\n}\n\nfunc (s *SyncPoolCompessors) AcquireZlibWriter() *zlib.Writer {\n\treturn s.ZlibWriterPool.Get().(*zlib.Writer)\n}\n\nfunc (s *SyncPoolCompessors) ReleaseZlibWriter(w *zlib.Writer) {\n\ts.ZlibWriterPool.Put(w)\n}\n\nfunc newGzipWriter() *gzip.Writer {\n\t// create with an empty bytes writer; it will be replaced before using the gzipWriter\n\twriter, err := gzip.NewWriterLevel(new(bytes.Buffer), gzip.BestSpeed)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn writer\n}\n\nfunc newGzipReader() *gzip.Reader {\n\t// create with an empty reader (but with GZIP header); it will be replaced before using the gzipReader\n\t// we can safely use currentCompressProvider because it is set on package initialization.\n\tw := currentCompressorProvider.AcquireGzipWriter()\n\tdefer currentCompressorProvider.ReleaseGzipWriter(w)\n\tb := new(bytes.Buffer)\n\tw.Reset(b)\n\tw.Flush()\n\tw.Close()\n\treader, err := gzip.NewReader(bytes.NewReader(b.Bytes()))\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn reader\n}\n\nfunc newZlibWriter() *zlib.Writer {\n\twriter, err := zlib.NewWriterLevel(new(bytes.Buffer), gzip.BestSpeed)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn writer\n}\n"
        },
        {
          "name": "compressors.go",
          "type": "blob",
          "size": 1.5361328125,
          "content": "package restful\n\n// Copyright 2015 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport (\n\t\"compress/gzip\"\n\t\"compress/zlib\"\n)\n\n// CompressorProvider describes a component that can provider compressors for the std methods.\ntype CompressorProvider interface {\n\t// Returns a *gzip.Writer which needs to be released later.\n\t// Before using it, call Reset().\n\tAcquireGzipWriter() *gzip.Writer\n\n\t// Releases an acquired *gzip.Writer.\n\tReleaseGzipWriter(w *gzip.Writer)\n\n\t// Returns a *gzip.Reader which needs to be released later.\n\tAcquireGzipReader() *gzip.Reader\n\n\t// Releases an acquired *gzip.Reader.\n\tReleaseGzipReader(w *gzip.Reader)\n\n\t// Returns a *zlib.Writer which needs to be released later.\n\t// Before using it, call Reset().\n\tAcquireZlibWriter() *zlib.Writer\n\n\t// Releases an acquired *zlib.Writer.\n\tReleaseZlibWriter(w *zlib.Writer)\n}\n\n// DefaultCompressorProvider is the actual provider of compressors (zlib or gzip).\nvar currentCompressorProvider CompressorProvider\n\nfunc init() {\n\tcurrentCompressorProvider = NewSyncPoolCompessors()\n}\n\n// CurrentCompressorProvider returns the current CompressorProvider.\n// It is initialized using a SyncPoolCompessors.\nfunc CurrentCompressorProvider() CompressorProvider {\n\treturn currentCompressorProvider\n}\n\n// SetCompressorProvider sets the actual provider of compressors (zlib or gzip).\nfunc SetCompressorProvider(p CompressorProvider) {\n\tif p == nil {\n\t\tpanic(\"cannot set compressor provider to nil\")\n\t}\n\tcurrentCompressorProvider = p\n}\n"
        },
        {
          "name": "constants.go",
          "type": "blob",
          "size": 1.6171875,
          "content": "package restful\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nconst (\n\tMIME_XML   = \"application/xml\"          // Accept or Content-Type used in Consumes() and/or Produces()\n\tMIME_JSON  = \"application/json\"         // Accept or Content-Type used in Consumes() and/or Produces()\n\tMIME_ZIP   = \"application/zip\"          // Accept or Content-Type used in Consumes() and/or Produces()\n\tMIME_OCTET = \"application/octet-stream\" // If Content-Type is not present in request, use the default\n\n\tHEADER_Allow                         = \"Allow\"\n\tHEADER_Accept                        = \"Accept\"\n\tHEADER_Origin                        = \"Origin\"\n\tHEADER_ContentType                   = \"Content-Type\"\n\tHEADER_ContentDisposition            = \"Content-Disposition\"\n\tHEADER_LastModified                  = \"Last-Modified\"\n\tHEADER_AcceptEncoding                = \"Accept-Encoding\"\n\tHEADER_ContentEncoding               = \"Content-Encoding\"\n\tHEADER_AccessControlExposeHeaders    = \"Access-Control-Expose-Headers\"\n\tHEADER_AccessControlRequestMethod    = \"Access-Control-Request-Method\"\n\tHEADER_AccessControlRequestHeaders   = \"Access-Control-Request-Headers\"\n\tHEADER_AccessControlAllowMethods     = \"Access-Control-Allow-Methods\"\n\tHEADER_AccessControlAllowOrigin      = \"Access-Control-Allow-Origin\"\n\tHEADER_AccessControlAllowCredentials = \"Access-Control-Allow-Credentials\"\n\tHEADER_AccessControlAllowHeaders     = \"Access-Control-Allow-Headers\"\n\tHEADER_AccessControlMaxAge           = \"Access-Control-Max-Age\"\n\n\tENCODING_GZIP    = \"gzip\"\n\tENCODING_DEFLATE = \"deflate\"\n)\n"
        },
        {
          "name": "container.go",
          "type": "blob",
          "size": 15.1630859375,
          "content": "package restful\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/emicklei/go-restful/v3/log\"\n)\n\n// Container holds a collection of WebServices and a http.ServeMux to dispatch http requests.\n// The requests are further dispatched to routes of WebServices using a RouteSelector\ntype Container struct {\n\twebServicesLock        sync.RWMutex\n\twebServices            []*WebService\n\tServeMux               *http.ServeMux\n\tisRegisteredOnRoot     bool\n\tcontainerFilters       []FilterFunction\n\tdoNotRecover           bool // default is true\n\trecoverHandleFunc      RecoverHandleFunction\n\tserviceErrorHandleFunc ServiceErrorHandleFunction\n\trouter                 RouteSelector // default is a CurlyRouter (RouterJSR311 is a slower alternative)\n\tcontentEncodingEnabled bool          // default is false\n}\n\n// NewContainer creates a new Container using a new ServeMux and default router (CurlyRouter)\nfunc NewContainer() *Container {\n\treturn &Container{\n\t\twebServices:            []*WebService{},\n\t\tServeMux:               http.NewServeMux(),\n\t\tisRegisteredOnRoot:     false,\n\t\tcontainerFilters:       []FilterFunction{},\n\t\tdoNotRecover:           true,\n\t\trecoverHandleFunc:      logStackOnRecover,\n\t\tserviceErrorHandleFunc: writeServiceError,\n\t\trouter:                 CurlyRouter{},\n\t\tcontentEncodingEnabled: false}\n}\n\n// RecoverHandleFunction declares functions that can be used to handle a panic situation.\n// The first argument is what recover() returns. The second must be used to communicate an error response.\ntype RecoverHandleFunction func(interface{}, http.ResponseWriter)\n\n// RecoverHandler changes the default function (logStackOnRecover) to be called\n// when a panic is detected. DoNotRecover must be have its default value (=false).\nfunc (c *Container) RecoverHandler(handler RecoverHandleFunction) {\n\tc.recoverHandleFunc = handler\n}\n\n// ServiceErrorHandleFunction declares functions that can be used to handle a service error situation.\n// The first argument is the service error, the second is the request that resulted in the error and\n// the third must be used to communicate an error response.\ntype ServiceErrorHandleFunction func(ServiceError, *Request, *Response)\n\n// ServiceErrorHandler changes the default function (writeServiceError) to be called\n// when a ServiceError is detected.\nfunc (c *Container) ServiceErrorHandler(handler ServiceErrorHandleFunction) {\n\tc.serviceErrorHandleFunc = handler\n}\n\n// DoNotRecover controls whether panics will be caught to return HTTP 500.\n// If set to true, Route functions are responsible for handling any error situation.\n// Default value is true.\nfunc (c *Container) DoNotRecover(doNot bool) {\n\tc.doNotRecover = doNot\n}\n\n// Router changes the default Router (currently CurlyRouter)\nfunc (c *Container) Router(aRouter RouteSelector) {\n\tc.router = aRouter\n}\n\n// EnableContentEncoding (default=false) allows for GZIP or DEFLATE encoding of responses.\nfunc (c *Container) EnableContentEncoding(enabled bool) {\n\tc.contentEncodingEnabled = enabled\n}\n\n// Add a WebService to the Container. It will detect duplicate root paths and exit in that case.\nfunc (c *Container) Add(service *WebService) *Container {\n\tc.webServicesLock.Lock()\n\tdefer c.webServicesLock.Unlock()\n\n\t// if rootPath was not set then lazy initialize it\n\tif len(service.rootPath) == 0 {\n\t\tservice.Path(\"/\")\n\t}\n\n\t// cannot have duplicate root paths\n\tfor _, each := range c.webServices {\n\t\tif each.RootPath() == service.RootPath() {\n\t\t\tlog.Printf(\"WebService with duplicate root path detected:['%v']\", each)\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n\n\t// If not registered on root then add specific mapping\n\tif !c.isRegisteredOnRoot {\n\t\tc.isRegisteredOnRoot = c.addHandler(service, c.ServeMux)\n\t}\n\tc.webServices = append(c.webServices, service)\n\treturn c\n}\n\n// addHandler may set a new HandleFunc for the serveMux\n// this function must run inside the critical region protected by the webServicesLock.\n// returns true if the function was registered on root (\"/\")\nfunc (c *Container) addHandler(service *WebService, serveMux *http.ServeMux) bool {\n\tpattern := fixedPrefixPath(service.RootPath())\n\t// check if root path registration is needed\n\tif \"/\" == pattern || \"\" == pattern {\n\t\tserveMux.HandleFunc(\"/\", c.dispatch)\n\t\treturn true\n\t}\n\t// detect if registration already exists\n\talreadyMapped := false\n\tfor _, each := range c.webServices {\n\t\tif each.RootPath() == service.RootPath() {\n\t\t\talreadyMapped = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !alreadyMapped {\n\t\tserveMux.HandleFunc(pattern, c.dispatch)\n\t\tif !strings.HasSuffix(pattern, \"/\") {\n\t\t\tserveMux.HandleFunc(pattern+\"/\", c.dispatch)\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (c *Container) Remove(ws *WebService) error {\n\tif c.ServeMux == http.DefaultServeMux {\n\t\terrMsg := fmt.Sprintf(\"cannot remove a WebService from a Container using the DefaultServeMux: ['%v']\", ws)\n\t\tlog.Print(errMsg)\n\t\treturn errors.New(errMsg)\n\t}\n\tc.webServicesLock.Lock()\n\tdefer c.webServicesLock.Unlock()\n\t// build a new ServeMux and re-register all WebServices\n\tnewServeMux := http.NewServeMux()\n\tnewServices := []*WebService{}\n\tnewIsRegisteredOnRoot := false\n\tfor _, each := range c.webServices {\n\t\tif each.rootPath != ws.rootPath {\n\t\t\t// If not registered on root then add specific mapping\n\t\t\tif !newIsRegisteredOnRoot {\n\t\t\t\tnewIsRegisteredOnRoot = c.addHandler(each, newServeMux)\n\t\t\t}\n\t\t\tnewServices = append(newServices, each)\n\t\t}\n\t}\n\tc.webServices, c.ServeMux, c.isRegisteredOnRoot = newServices, newServeMux, newIsRegisteredOnRoot\n\treturn nil\n}\n\n// logStackOnRecover is the default RecoverHandleFunction and is called\n// when DoNotRecover is false and the recoverHandleFunc is not set for the container.\n// Default implementation logs the stacktrace and writes the stacktrace on the response.\n// This may be a security issue as it exposes sourcecode information.\nfunc logStackOnRecover(panicReason interface{}, httpWriter http.ResponseWriter) {\n\tvar buffer bytes.Buffer\n\tbuffer.WriteString(fmt.Sprintf(\"recover from panic situation: - %v\\r\\n\", panicReason))\n\tfor i := 2; ; i += 1 {\n\t\t_, file, line, ok := runtime.Caller(i)\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tbuffer.WriteString(fmt.Sprintf(\"    %s:%d\\r\\n\", file, line))\n\t}\n\tlog.Print(buffer.String())\n\thttpWriter.WriteHeader(http.StatusInternalServerError)\n\thttpWriter.Write(buffer.Bytes())\n}\n\n// writeServiceError is the default ServiceErrorHandleFunction and is called\n// when a ServiceError is returned during route selection. Default implementation\n// calls resp.WriteErrorString(err.Code, err.Message)\nfunc writeServiceError(err ServiceError, req *Request, resp *Response) {\n\tfor header, values := range err.Header {\n\t\tfor _, value := range values {\n\t\t\tresp.Header().Add(header, value)\n\t\t}\n\t}\n\tresp.WriteErrorString(err.Code, err.Message)\n}\n\n// Dispatch the incoming Http Request to a matching WebService.\nfunc (c *Container) Dispatch(httpWriter http.ResponseWriter, httpRequest *http.Request) {\n\tif httpWriter == nil {\n\t\tpanic(\"httpWriter cannot be nil\")\n\t}\n\tif httpRequest == nil {\n\t\tpanic(\"httpRequest cannot be nil\")\n\t}\n\tc.dispatch(httpWriter, httpRequest)\n}\n\n// Dispatch the incoming Http Request to a matching WebService.\nfunc (c *Container) dispatch(httpWriter http.ResponseWriter, httpRequest *http.Request) {\n\t// so we can assign a compressing one later\n\twriter := httpWriter\n\n\t// CompressingResponseWriter should be closed after all operations are done\n\tdefer func() {\n\t\tif compressWriter, ok := writer.(*CompressingResponseWriter); ok {\n\t\t\tcompressWriter.Close()\n\t\t}\n\t}()\n\n\t// Instal panic recovery unless told otherwise\n\tif !c.doNotRecover { // catch all for 500 response\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tc.recoverHandleFunc(r, writer)\n\t\t\t\treturn\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Find best match Route ; err is non nil if no match was found\n\tvar webService *WebService\n\tvar route *Route\n\tvar err error\n\tfunc() {\n\t\tc.webServicesLock.RLock()\n\t\tdefer c.webServicesLock.RUnlock()\n\t\twebService, route, err = c.router.SelectRoute(\n\t\t\tc.webServices,\n\t\t\thttpRequest)\n\t}()\n\tif err != nil {\n\t\t// a non-200 response (may be compressed) has already been written\n\t\t// run container filters anyway ; they should not touch the response...\n\t\tchain := FilterChain{Filters: c.containerFilters, Target: func(req *Request, resp *Response) {\n\t\t\tswitch err.(type) {\n\t\t\tcase ServiceError:\n\t\t\t\tser := err.(ServiceError)\n\t\t\t\tc.serviceErrorHandleFunc(ser, req, resp)\n\t\t\t}\n\t\t\t// TODO\n\t\t}}\n\t\tchain.ProcessFilter(NewRequest(httpRequest), NewResponse(writer))\n\t\treturn\n\t}\n\n\t// Unless httpWriter is already an CompressingResponseWriter see if we need to install one\n\tif _, isCompressing := httpWriter.(*CompressingResponseWriter); !isCompressing {\n\t\t// Detect if compression is needed\n\t\t// assume without compression, test for override\n\t\tcontentEncodingEnabled := c.contentEncodingEnabled\n\t\tif route != nil && route.contentEncodingEnabled != nil {\n\t\t\tcontentEncodingEnabled = *route.contentEncodingEnabled\n\t\t}\n\t\tif contentEncodingEnabled {\n\t\t\tdoCompress, encoding := wantsCompressedResponse(httpRequest, httpWriter)\n\t\t\tif doCompress {\n\t\t\t\tvar err error\n\t\t\t\twriter, err = NewCompressingResponseWriter(httpWriter, encoding)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Print(\"unable to install compressor: \", err)\n\t\t\t\t\thttpWriter.WriteHeader(http.StatusInternalServerError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpathProcessor, routerProcessesPath := c.router.(PathProcessor)\n\tif !routerProcessesPath {\n\t\tpathProcessor = defaultPathProcessor{}\n\t}\n\tpathParams := pathProcessor.ExtractParameters(route, webService, httpRequest.URL.Path)\n\twrappedRequest, wrappedResponse := route.wrapRequestResponse(writer, httpRequest, pathParams)\n\t// pass through filters (if any)\n\tif size := len(c.containerFilters) + len(webService.filters) + len(route.Filters); size > 0 {\n\t\t// compose filter chain\n\t\tallFilters := make([]FilterFunction, 0, size)\n\t\tallFilters = append(allFilters, c.containerFilters...)\n\t\tallFilters = append(allFilters, webService.filters...)\n\t\tallFilters = append(allFilters, route.Filters...)\n\t\tchain := FilterChain{\n\t\t\tFilters:       allFilters,\n\t\t\tTarget:        route.Function,\n\t\t\tParameterDocs: route.ParameterDocs,\n\t\t\tOperation:     route.Operation,\n\t\t}\n\t\tchain.ProcessFilter(wrappedRequest, wrappedResponse)\n\t} else {\n\t\t// no filters, handle request by route\n\t\troute.Function(wrappedRequest, wrappedResponse)\n\t}\n}\n\n// fixedPrefixPath returns the fixed part of the partspec ; it may include template vars {}\nfunc fixedPrefixPath(pathspec string) string {\n\tvarBegin := strings.Index(pathspec, \"{\")\n\tif -1 == varBegin {\n\t\treturn pathspec\n\t}\n\treturn pathspec[:varBegin]\n}\n\n// ServeHTTP implements net/http.Handler therefore a Container can be a Handler in a http.Server\nfunc (c *Container) ServeHTTP(httpWriter http.ResponseWriter, httpRequest *http.Request) {\n\t// Skip, if content encoding is disabled\n\tif !c.contentEncodingEnabled {\n\t\tc.ServeMux.ServeHTTP(httpWriter, httpRequest)\n\t\treturn\n\t}\n\t// content encoding is enabled\n\n\t// Skip, if httpWriter is already an CompressingResponseWriter\n\tif _, ok := httpWriter.(*CompressingResponseWriter); ok {\n\t\tc.ServeMux.ServeHTTP(httpWriter, httpRequest)\n\t\treturn\n\t}\n\n\twriter := httpWriter\n\t// CompressingResponseWriter should be closed after all operations are done\n\tdefer func() {\n\t\tif compressWriter, ok := writer.(*CompressingResponseWriter); ok {\n\t\t\tcompressWriter.Close()\n\t\t}\n\t}()\n\n\tdoCompress, encoding := wantsCompressedResponse(httpRequest, httpWriter)\n\tif doCompress {\n\t\tvar err error\n\t\twriter, err = NewCompressingResponseWriter(httpWriter, encoding)\n\t\tif err != nil {\n\t\t\tlog.Print(\"unable to install compressor: \", err)\n\t\t\thttpWriter.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t}\n\n\tc.ServeMux.ServeHTTP(writer, httpRequest)\n}\n\n// Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics.\nfunc (c *Container) Handle(pattern string, handler http.Handler) {\n\tc.ServeMux.Handle(pattern, http.HandlerFunc(func(httpWriter http.ResponseWriter, httpRequest *http.Request) {\n\t\t// Skip, if httpWriter is already an CompressingResponseWriter\n\t\tif _, ok := httpWriter.(*CompressingResponseWriter); ok {\n\t\t\thandler.ServeHTTP(httpWriter, httpRequest)\n\t\t\treturn\n\t\t}\n\n\t\twriter := httpWriter\n\n\t\t// CompressingResponseWriter should be closed after all operations are done\n\t\tdefer func() {\n\t\t\tif compressWriter, ok := writer.(*CompressingResponseWriter); ok {\n\t\t\t\tcompressWriter.Close()\n\t\t\t}\n\t\t}()\n\n\t\tif c.contentEncodingEnabled {\n\t\t\tdoCompress, encoding := wantsCompressedResponse(httpRequest, httpWriter)\n\t\t\tif doCompress {\n\t\t\t\tvar err error\n\t\t\t\twriter, err = NewCompressingResponseWriter(httpWriter, encoding)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Print(\"unable to install compressor: \", err)\n\t\t\t\t\thttpWriter.WriteHeader(http.StatusInternalServerError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\thandler.ServeHTTP(writer, httpRequest)\n\t}))\n}\n\n// HandleWithFilter registers the handler for the given pattern.\n// Container's filter chain is applied for handler.\n// If a handler already exists for pattern, HandleWithFilter panics.\nfunc (c *Container) HandleWithFilter(pattern string, handler http.Handler) {\n\tf := func(httpResponse http.ResponseWriter, httpRequest *http.Request) {\n\t\tif len(c.containerFilters) == 0 {\n\t\t\thandler.ServeHTTP(httpResponse, httpRequest)\n\t\t\treturn\n\t\t}\n\n\t\tchain := FilterChain{Filters: c.containerFilters, Target: func(req *Request, resp *Response) {\n\t\t\thandler.ServeHTTP(resp, req.Request)\n\t\t}}\n\t\tchain.ProcessFilter(NewRequest(httpRequest), NewResponse(httpResponse))\n\t}\n\n\tc.Handle(pattern, http.HandlerFunc(f))\n}\n\n// Filter appends a container FilterFunction. These are called before dispatching\n// a http.Request to a WebService from the container\nfunc (c *Container) Filter(filter FilterFunction) {\n\tc.containerFilters = append(c.containerFilters, filter)\n}\n\n// RegisteredWebServices returns the collections of added WebServices\nfunc (c *Container) RegisteredWebServices() []*WebService {\n\tc.webServicesLock.RLock()\n\tdefer c.webServicesLock.RUnlock()\n\tresult := make([]*WebService, len(c.webServices))\n\tfor ix := range c.webServices {\n\t\tresult[ix] = c.webServices[ix]\n\t}\n\treturn result\n}\n\n// computeAllowedMethods returns a list of HTTP methods that are valid for a Request\nfunc (c *Container) computeAllowedMethods(req *Request) []string {\n\t// Go through all RegisteredWebServices() and all its Routes to collect the options\n\tmethods := []string{}\n\trequestPath := req.Request.URL.Path\n\tfor _, ws := range c.RegisteredWebServices() {\n\t\tmatches := ws.pathExpr.Matcher.FindStringSubmatch(requestPath)\n\t\tif matches != nil {\n\t\t\tfinalMatch := matches[len(matches)-1]\n\t\t\tfor _, rt := range ws.Routes() {\n\t\t\t\tmatches := rt.pathExpr.Matcher.FindStringSubmatch(finalMatch)\n\t\t\t\tif matches != nil {\n\t\t\t\t\tlastMatch := matches[len(matches)-1]\n\t\t\t\t\tif lastMatch == \"\" || lastMatch == \"/\" { // do not include if value is neither empty nor ‘/’.\n\t\t\t\t\t\tmethods = append(methods, rt.Method)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// methods = append(methods, \"OPTIONS\")  not sure about this\n\treturn methods\n}\n\n// newBasicRequestResponse creates a pair of Request,Response from its http versions.\n// It is basic because no parameter or (produces) content-type information is given.\nfunc newBasicRequestResponse(httpWriter http.ResponseWriter, httpRequest *http.Request) (*Request, *Response) {\n\tresp := NewResponse(httpWriter)\n\tresp.requestAccept = httpRequest.Header.Get(HEADER_Accept)\n\treturn NewRequest(httpRequest), resp\n}\n"
        },
        {
          "name": "container_test.go",
          "type": "blob",
          "size": 4.94921875,
          "content": "package restful\n\nimport (\n\t\"context\"\n\t\"encoding/hex\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\n// go test -v -test.run TestContainer_computeAllowedMethods ...restful\nfunc TestContainer_computeAllowedMethods(t *testing.T) {\n\twc := NewContainer()\n\tws1 := new(WebService).Path(\"/users\")\n\tws1.Route(ws1.GET(\"{i}\").To(dummy))\n\tws1.Route(ws1.POST(\"{i}\").To(dummy))\n\twc.Add(ws1)\n\thttpRequest, _ := http.NewRequest(\"GET\", \"http://api.his.com/users/1\", nil)\n\trreq := Request{Request: httpRequest}\n\tm := wc.computeAllowedMethods(&rreq)\n\tif len(m) != 2 {\n\t\tt.Errorf(\"got %d expected 2 methods, %v\", len(m), m)\n\t}\n}\n\nfunc TestContainer_HandleWithFilter(t *testing.T) {\n\tprefilterCalled := false\n\tpostfilterCalled := false\n\thttpHandlerCalled := false\n\n\tcontextAvailable := false\n\n\twc := NewContainer()\n\twc.Filter(func(request *Request, response *Response, chain *FilterChain) {\n\t\tprefilterCalled = true\n\t\trequest.Request = request.Request.WithContext(context.WithValue(request.Request.Context(), \"prefilterContextSet\", \"true\"))\n\t\tchain.ProcessFilter(request, response)\n\t})\n\twc.HandleWithFilter(\"/\", http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n\t\thttpHandlerCalled = true\n\t\t_, ok1 := req.Context().Value(\"prefilterContextSet\").(string)\n\t\t_, ok2 := req.Context().Value(\"postfilterContextSet\").(string)\n\t\tif ok1 && ok2 {\n\t\t\tcontextAvailable = true\n\t\t}\n\n\t\tw.Write([]byte(\"ok\"))\n\t}))\n\twc.Filter(func(request *Request, response *Response, chain *FilterChain) {\n\t\tpostfilterCalled = true\n\t\trequest.Request = request.Request.WithContext(context.WithValue(request.Request.Context(), \"postfilterContextSet\", \"true\"))\n\t\tchain.ProcessFilter(request, response)\n\t})\n\n\trecorder := httptest.NewRecorder()\n\trequest, _ := http.NewRequest(\"GET\", \"/\", nil)\n\twc.ServeHTTP(recorder, request)\n\tif recorder.Code != http.StatusOK {\n\t\tt.Errorf(\"unexpected code %d\", recorder.Code)\n\t}\n\tif recorder.Body.String() != \"ok\" {\n\t\tt.Errorf(\"unexpected body %s\", recorder.Body.String())\n\t}\n\tif !prefilterCalled {\n\t\tt.Errorf(\"filter added before calling HandleWithFilter wasn't called\")\n\t}\n\tif !postfilterCalled {\n\t\tt.Errorf(\"filter added after calling HandleWithFilter wasn't called\")\n\t}\n\tif !httpHandlerCalled {\n\t\tt.Errorf(\"handler added by calling HandleWithFilter wasn't called\")\n\t}\n\tif !contextAvailable {\n\t\tt.Errorf(\"Context not available in http handler\")\n\t}\n}\n\nfunc TestContainerAddAndRemove(t *testing.T) {\n\tws1 := new(WebService).Path(\"/\")\n\tws2 := new(WebService).Path(\"/users\")\n\twc := NewContainer()\n\twc.Add(ws1)\n\twc.Add(ws2)\n\twc.Remove(ws2)\n\tif len(wc.webServices) != 1 {\n\t\tt.Errorf(\"expected one webservices\")\n\t}\n\tif !wc.isRegisteredOnRoot {\n\t\tt.Errorf(\"expected on root registered\")\n\t}\n\twc.Remove(ws1)\n\tif len(wc.webServices) > 0 {\n\t\tt.Errorf(\"expected zero webservices\")\n\t}\n\tif wc.isRegisteredOnRoot {\n\t\tt.Errorf(\"expected not on root registered\")\n\t}\n}\n\nfunc TestContainerCompressResponse(t *testing.T) {\n\twc := NewContainer()\n\tws := new(WebService).Path(\"/\")\n\tws.Route(ws.GET(\"/\").To(dummy))\n\twc.Add(ws)\n\n\t// no accept header, encoding disabled\n\t{\n\t\trecorder := httptest.NewRecorder()\n\t\trequest, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\twc.ServeHTTP(recorder, request)\n\t\tif recorder.Code != http.StatusOK {\n\t\t\tt.Errorf(\"unexpected code %d\", recorder.Code)\n\t\t}\n\t\tif recorder.Body.String() != \"dummy\" {\n\t\t\tt.Errorf(\"unexpected body %s\", recorder.Body.String())\n\t\t}\n\t}\n\n\t// with gzip accept header, encoding disabled\n\t{\n\t\trecorder := httptest.NewRecorder()\n\t\trequest, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\trequest.Header.Set(\"accept-encoding\", \"gzip\")\n\t\twc.ServeHTTP(recorder, request)\n\t\tif recorder.Code != http.StatusOK {\n\t\t\tt.Errorf(\"unexpected code %d\", recorder.Code)\n\t\t}\n\t\tif recorder.Body.String() != \"dummy\" {\n\t\t\tt.Errorf(\"unexpected body %s\", recorder.Body.String())\n\t\t}\n\t}\n\n\t// no accept header, encoding enabled\n\t{\n\t\twc.EnableContentEncoding(true)\n\t\trecorder := httptest.NewRecorder()\n\t\trequest, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\twc.ServeHTTP(recorder, request)\n\t\tif recorder.Code != http.StatusOK {\n\t\t\tt.Errorf(\"unexpected code %d\", recorder.Code)\n\t\t}\n\t\tif recorder.Body.String() != \"dummy\" {\n\t\t\tt.Errorf(\"unexpected body %s\", recorder.Body.String())\n\t\t}\n\t}\n\n\t// with accept gzip header, encoding enabled\n\t{\n\t\twc.EnableContentEncoding(true)\n\t\trecorder := httptest.NewRecorder()\n\t\trequest, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\trequest.Header.Set(\"accept-encoding\", \"gzip\")\n\t\twc.ServeHTTP(recorder, request)\n\t\tif recorder.Code != http.StatusOK {\n\t\t\tt.Errorf(\"unexpected code %d\", recorder.Code)\n\t\t}\n\t\tif hex.EncodeToString(recorder.Body.Bytes()) == hex.EncodeToString(gzippedDummy()) {\n\t\t\tt.Errorf(\"unexpected body %v\", recorder.Body.Bytes())\n\t\t}\n\t}\n\t// response says it is already compressed\n\t{\n\t\twc.EnableContentEncoding(true)\n\t\trecorder := httptest.NewRecorder()\n\t\trequest, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\trequest.Header.Set(\"accept-encoding\", \"gzip\")\n\t\trecorder.HeaderMap.Set(\"content-encoding\", \"gzip\")\n\t\twc.ServeHTTP(recorder, request)\n\t\tif recorder.Body.String() != \"dummy\" {\n\t\t\tt.Errorf(\"unexpected body %s\", recorder.Body.String())\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "cors_filter.go",
          "type": "blob",
          "size": 5.8857421875,
          "content": "package restful\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport (\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// CrossOriginResourceSharing is used to create a Container Filter that implements CORS.\n// Cross-origin resource sharing (CORS) is a mechanism that allows JavaScript on a web page\n// to make XMLHttpRequests to another domain, not the domain the JavaScript originated from.\n//\n// http://en.wikipedia.org/wiki/Cross-origin_resource_sharing\n// http://enable-cors.org/server.html\n// http://www.html5rocks.com/en/tutorials/cors/#toc-handling-a-not-so-simple-request\ntype CrossOriginResourceSharing struct {\n\tExposeHeaders []string // list of Header names\n\n\t// AllowedHeaders is alist of Header names. Checking is case-insensitive.\n\t// The list may contain the special wildcard string \".*\" ; all is allowed\n\tAllowedHeaders []string\n\n\t// AllowedDomains is a list of allowed values for Http Origin.\n\t// The list may contain the special wildcard string \".*\" ; all is allowed\n\t// If empty all are allowed.\n\tAllowedDomains []string\n\n\t// AllowedDomainFunc is optional and is a function that will do the check\n\t// when the origin is not part of the AllowedDomains and it does not contain the wildcard \".*\".\n\tAllowedDomainFunc func(origin string) bool\n\n\t// AllowedMethods is either empty or has a list of http methods names. Checking is case-insensitive.\n\tAllowedMethods []string\n\tMaxAge         int // number of seconds before requiring new Options request\n\tCookiesAllowed bool\n\tContainer      *Container\n\n\tallowedOriginPatterns []*regexp.Regexp // internal field for origin regexp check.\n}\n\n// Filter is a filter function that implements the CORS flow as documented on http://enable-cors.org/server.html\n// and http://www.html5rocks.com/static/images/cors_server_flowchart.png\nfunc (c CrossOriginResourceSharing) Filter(req *Request, resp *Response, chain *FilterChain) {\n\torigin := req.Request.Header.Get(HEADER_Origin)\n\tif len(origin) == 0 {\n\t\tif trace {\n\t\t\ttraceLogger.Print(\"no Http header Origin set\")\n\t\t}\n\t\tchain.ProcessFilter(req, resp)\n\t\treturn\n\t}\n\tif !c.isOriginAllowed(origin) { // check whether this origin is allowed\n\t\tif trace {\n\t\t\ttraceLogger.Printf(\"HTTP Origin:%s is not part of %v, neither matches any part of %v\", origin, c.AllowedDomains, c.allowedOriginPatterns)\n\t\t}\n\t\tchain.ProcessFilter(req, resp)\n\t\treturn\n\t}\n\tif req.Request.Method != \"OPTIONS\" {\n\t\tc.doActualRequest(req, resp)\n\t\tchain.ProcessFilter(req, resp)\n\t\treturn\n\t}\n\tif acrm := req.Request.Header.Get(HEADER_AccessControlRequestMethod); acrm != \"\" {\n\t\tc.doPreflightRequest(req, resp)\n\t} else {\n\t\tc.doActualRequest(req, resp)\n\t\tchain.ProcessFilter(req, resp)\n\t\treturn\n\t}\n}\n\nfunc (c CrossOriginResourceSharing) doActualRequest(req *Request, resp *Response) {\n\tc.setOptionsHeaders(req, resp)\n\t// continue processing the response\n}\n\nfunc (c *CrossOriginResourceSharing) doPreflightRequest(req *Request, resp *Response) {\n\tif len(c.AllowedMethods) == 0 {\n\t\tif c.Container == nil {\n\t\t\tc.AllowedMethods = DefaultContainer.computeAllowedMethods(req)\n\t\t} else {\n\t\t\tc.AllowedMethods = c.Container.computeAllowedMethods(req)\n\t\t}\n\t}\n\n\tacrm := req.Request.Header.Get(HEADER_AccessControlRequestMethod)\n\tif !c.isValidAccessControlRequestMethod(acrm, c.AllowedMethods) {\n\t\tif trace {\n\t\t\ttraceLogger.Printf(\"Http header %s:%s is not in %v\",\n\t\t\t\tHEADER_AccessControlRequestMethod,\n\t\t\t\tacrm,\n\t\t\t\tc.AllowedMethods)\n\t\t}\n\t\treturn\n\t}\n\tacrhs := req.Request.Header.Get(HEADER_AccessControlRequestHeaders)\n\tif len(acrhs) > 0 {\n\t\tfor _, each := range strings.Split(acrhs, \",\") {\n\t\t\tif !c.isValidAccessControlRequestHeader(strings.Trim(each, \" \")) {\n\t\t\t\tif trace {\n\t\t\t\t\ttraceLogger.Printf(\"Http header %s:%s is not in %v\",\n\t\t\t\t\t\tHEADER_AccessControlRequestHeaders,\n\t\t\t\t\t\tacrhs,\n\t\t\t\t\t\tc.AllowedHeaders)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\tresp.AddHeader(HEADER_AccessControlAllowMethods, strings.Join(c.AllowedMethods, \",\"))\n\tresp.AddHeader(HEADER_AccessControlAllowHeaders, acrhs)\n\tc.setOptionsHeaders(req, resp)\n\n\t// return http 200 response, no body\n}\n\nfunc (c CrossOriginResourceSharing) setOptionsHeaders(req *Request, resp *Response) {\n\tc.checkAndSetExposeHeaders(resp)\n\tc.setAllowOriginHeader(req, resp)\n\tc.checkAndSetAllowCredentials(resp)\n\tif c.MaxAge > 0 {\n\t\tresp.AddHeader(HEADER_AccessControlMaxAge, strconv.Itoa(c.MaxAge))\n\t}\n}\n\nfunc (c CrossOriginResourceSharing) isOriginAllowed(origin string) bool {\n\tif len(origin) == 0 {\n\t\treturn false\n\t}\n\tlowerOrigin := strings.ToLower(origin)\n\tif len(c.AllowedDomains) == 0 {\n\t\tif c.AllowedDomainFunc != nil {\n\t\t\treturn c.AllowedDomainFunc(lowerOrigin)\n\t\t}\n\t\treturn true\n\t}\n\n\t// exact match on each allowed domain\n\tfor _, domain := range c.AllowedDomains {\n\t\tif domain == \".*\" || strings.ToLower(domain) == lowerOrigin {\n\t\t\treturn true\n\t\t}\n\t}\n\tif c.AllowedDomainFunc != nil {\n\t\treturn c.AllowedDomainFunc(origin)\n\t}\n\treturn false\n}\n\nfunc (c CrossOriginResourceSharing) setAllowOriginHeader(req *Request, resp *Response) {\n\torigin := req.Request.Header.Get(HEADER_Origin)\n\tif c.isOriginAllowed(origin) {\n\t\tresp.AddHeader(HEADER_AccessControlAllowOrigin, origin)\n\t}\n}\n\nfunc (c CrossOriginResourceSharing) checkAndSetExposeHeaders(resp *Response) {\n\tif len(c.ExposeHeaders) > 0 {\n\t\tresp.AddHeader(HEADER_AccessControlExposeHeaders, strings.Join(c.ExposeHeaders, \",\"))\n\t}\n}\n\nfunc (c CrossOriginResourceSharing) checkAndSetAllowCredentials(resp *Response) {\n\tif c.CookiesAllowed {\n\t\tresp.AddHeader(HEADER_AccessControlAllowCredentials, \"true\")\n\t}\n}\n\nfunc (c CrossOriginResourceSharing) isValidAccessControlRequestMethod(method string, allowedMethods []string) bool {\n\tfor _, each := range allowedMethods {\n\t\tif each == method {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (c CrossOriginResourceSharing) isValidAccessControlRequestHeader(header string) bool {\n\tfor _, each := range c.AllowedHeaders {\n\t\tif strings.ToLower(each) == strings.ToLower(header) {\n\t\t\treturn true\n\t\t}\n\t\tif each == \"*\" {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "cors_filter_test.go",
          "type": "blob",
          "size": 5.3935546875,
          "content": "package restful\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\n// go test -v -test.run TestCORSFilter_Preflight ...restful\n// http://www.html5rocks.com/en/tutorials/cors/#toc-handling-a-not-so-simple-request\nfunc TestCORSFilter_Preflight(t *testing.T) {\n\ttearDown()\n\tws := new(WebService)\n\tws.Route(ws.PUT(\"/cors\").To(dummy))\n\tAdd(ws)\n\n\tcors := CrossOriginResourceSharing{\n\t\tExposeHeaders:  []string{\"X-Custom-Header\"},\n\t\tAllowedHeaders: []string{\"X-Custom-Header\", \"X-Additional-Header\"},\n\t\tCookiesAllowed: true,\n\t\tContainer:      DefaultContainer}\n\tFilter(cors.Filter)\n\n\t// Preflight\n\thttpRequest, _ := http.NewRequest(\"OPTIONS\", \"http://api.alice.com/cors\", nil)\n\thttpRequest.Method = \"OPTIONS\"\n\thttpRequest.Header.Set(HEADER_Origin, \"http://api.bob.com\")\n\thttpRequest.Header.Set(HEADER_AccessControlRequestMethod, \"PUT\")\n\thttpRequest.Header.Set(HEADER_AccessControlRequestHeaders, \"X-Custom-Header, X-Additional-Header\")\n\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.Dispatch(httpWriter, httpRequest)\n\n\tactual := httpWriter.Header().Get(HEADER_AccessControlAllowOrigin)\n\tif \"http://api.bob.com\" != actual {\n\t\tt.Fatal(\"expected: http://api.bob.com but got:\" + actual)\n\t}\n\tactual = httpWriter.Header().Get(HEADER_AccessControlAllowMethods)\n\tif \"PUT\" != actual {\n\t\tt.Fatal(\"expected: PUT but got:\" + actual)\n\t}\n\tactual = httpWriter.Header().Get(HEADER_AccessControlAllowHeaders)\n\tif \"X-Custom-Header, X-Additional-Header\" != actual {\n\t\tt.Fatal(\"expected: X-Custom-Header, X-Additional-Header but got:\" + actual)\n\t}\n\n\tif !cors.isOriginAllowed(\"somewhere\") {\n\t\tt.Fatal(\"origin expected to be allowed\")\n\t}\n\tcors.AllowedDomains = []string{\"overthere.com\"}\n\tif cors.isOriginAllowed(\"somewhere\") {\n\t\tt.Fatal(\"origin [somewhere] expected NOT to be allowed\")\n\t}\n\tif !cors.isOriginAllowed(\"overthere.com\") {\n\t\tt.Fatal(\"origin [overthere] expected to be allowed\")\n\t}\n\n}\n\n// go test -v -test.run TestCORSFilter_Actual ...restful\n// http://www.html5rocks.com/en/tutorials/cors/#toc-handling-a-not-so-simple-request\nfunc TestCORSFilter_Actual(t *testing.T) {\n\ttearDown()\n\tws := new(WebService)\n\tws.Route(ws.PUT(\"/cors\").To(dummy))\n\tAdd(ws)\n\n\tcors := CrossOriginResourceSharing{\n\t\tExposeHeaders:  []string{\"X-Custom-Header\"},\n\t\tAllowedHeaders: []string{\"X-Custom-Header\", \"X-Additional-Header\"},\n\t\tCookiesAllowed: true,\n\t\tContainer:      DefaultContainer}\n\tFilter(cors.Filter)\n\n\t// Actual\n\thttpRequest, _ := http.NewRequest(\"PUT\", \"http://api.alice.com/cors\", nil)\n\thttpRequest.Header.Set(HEADER_Origin, \"http://api.bob.com\")\n\thttpRequest.Header.Set(\"X-Custom-Header\", \"value\")\n\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.Dispatch(httpWriter, httpRequest)\n\tactual := httpWriter.Header().Get(HEADER_AccessControlAllowOrigin)\n\tif \"http://api.bob.com\" != actual {\n\t\tt.Fatal(\"expected: http://api.bob.com but got:\" + actual)\n\t}\n\tif httpWriter.Body.String() != \"dummy\" {\n\t\tt.Fatal(\"expected: dummy but got:\" + httpWriter.Body.String())\n\t}\n}\n\nvar allowedDomainInput = []struct {\n\tdomains []string\n\torigin  string\n\tallowed bool\n}{\n\t{[]string{}, \"http://anything.com\", true},\n\t{[]string{\"example.com\"}, \"example.com\", true},\n\t{[]string{\"example.com\"}, \"not-allowed\", false},\n\t{[]string{\"not-matching.com\", \"example.com\"}, \"example.com\", true},\n\t{[]string{\".*\"}, \"example.com\", true},\n}\n\n// go test -v -test.run TestCORSFilter_AllowedDomains ...restful\nfunc TestCORSFilter_AllowedDomains(t *testing.T) {\n\tfor _, each := range allowedDomainInput {\n\t\ttearDown()\n\t\tws := new(WebService)\n\t\tws.Route(ws.PUT(\"/cors\").To(dummy))\n\t\tAdd(ws)\n\n\t\tcors := CrossOriginResourceSharing{\n\t\t\tAllowedDomains: each.domains,\n\t\t\tCookiesAllowed: true,\n\t\t\tContainer:      DefaultContainer}\n\t\tFilter(cors.Filter)\n\n\t\thttpRequest, _ := http.NewRequest(\"PUT\", \"http://api.his.com/cors\", nil)\n\t\thttpRequest.Header.Set(HEADER_Origin, each.origin)\n\t\thttpWriter := httptest.NewRecorder()\n\t\tDefaultContainer.Dispatch(httpWriter, httpRequest)\n\t\tactual := httpWriter.Header().Get(HEADER_AccessControlAllowOrigin)\n\t\tif actual != each.origin && each.allowed {\n\t\t\tt.Error(\"expected to be accepted\", each)\n\t\t}\n\t\tif actual == each.origin && !each.allowed {\n\t\t\tt.Error(\"did not expect to be accepted\")\n\t\t}\n\t}\n}\n\nfunc TestCORSFilter_AllowedDomainFunc(t *testing.T) {\n\tcors := CrossOriginResourceSharing{\n\t\tAllowedDomains: []string{\"here\", \"there\"},\n\t\tAllowedDomainFunc: func(origin string) bool {\n\t\t\treturn \"where\" == origin\n\t\t},\n\t}\n\tif got, want := cors.isOriginAllowed(\"here\"), true; got != want {\n\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t}\n\tif got, want := cors.isOriginAllowed(\"HERE\"), true; got != want {\n\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t}\n\tif got, want := cors.isOriginAllowed(\"there\"), true; got != want {\n\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t}\n\tif got, want := cors.isOriginAllowed(\"where\"), true; got != want {\n\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t}\n\tif got, want := cors.isOriginAllowed(\"nowhere\"), false; got != want {\n\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t}\n\t// just func\n\tcors.AllowedDomains = []string{}\n\tif got, want := cors.isOriginAllowed(\"here\"), false; got != want {\n\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t}\n\tif got, want := cors.isOriginAllowed(\"where\"), true; got != want {\n\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t}\n\t// empty domain\n\tif got, want := cors.isOriginAllowed(\"\"), false; got != want {\n\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t}\n}\n"
        },
        {
          "name": "coverage.sh",
          "type": "blob",
          "size": 0.0654296875,
          "content": "go test -coverprofile=coverage.out\ngo tool cover -html=coverage.out"
        },
        {
          "name": "curly.go",
          "type": "blob",
          "size": 6.1416015625,
          "content": "package restful\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport (\n\t\"net/http\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// CurlyRouter expects Routes with paths that contain zero or more parameters in curly brackets.\ntype CurlyRouter struct{}\n\n// SelectRoute is part of the Router interface and returns the best match\n// for the WebService and its Route for the given Request.\nfunc (c CurlyRouter) SelectRoute(\n\twebServices []*WebService,\n\thttpRequest *http.Request) (selectedService *WebService, selected *Route, err error) {\n\n\trequestTokens := tokenizePath(httpRequest.URL.Path)\n\n\tdetectedService := c.detectWebService(requestTokens, webServices)\n\tif detectedService == nil {\n\t\tif trace {\n\t\t\ttraceLogger.Printf(\"no WebService was found to match URL path:%s\\n\", httpRequest.URL.Path)\n\t\t}\n\t\treturn nil, nil, NewError(http.StatusNotFound, \"404: Page Not Found\")\n\t}\n\tcandidateRoutes := c.selectRoutes(detectedService, requestTokens)\n\tif len(candidateRoutes) == 0 {\n\t\tif trace {\n\t\t\ttraceLogger.Printf(\"no Route in WebService with path %s was found to match URL path:%s\\n\", detectedService.rootPath, httpRequest.URL.Path)\n\t\t}\n\t\treturn detectedService, nil, NewError(http.StatusNotFound, \"404: Page Not Found\")\n\t}\n\tselectedRoute, err := c.detectRoute(candidateRoutes, httpRequest)\n\tif selectedRoute == nil {\n\t\treturn detectedService, nil, err\n\t}\n\treturn detectedService, selectedRoute, nil\n}\n\n// selectRoutes return a collection of Route from a WebService that matches the path tokens from the request.\nfunc (c CurlyRouter) selectRoutes(ws *WebService, requestTokens []string) sortableCurlyRoutes {\n\tcandidates := make(sortableCurlyRoutes, 0, 8)\n\tfor _, eachRoute := range ws.routes {\n\t\tmatches, paramCount, staticCount := c.matchesRouteByPathTokens(eachRoute.pathParts, requestTokens, eachRoute.hasCustomVerb)\n\t\tif matches {\n\t\t\tcandidates.add(curlyRoute{eachRoute, paramCount, staticCount}) // TODO make sure Routes() return pointers?\n\t\t}\n\t}\n\tsort.Sort(candidates)\n\treturn candidates\n}\n\n// matchesRouteByPathTokens computes whether it matches, howmany parameters do match and what the number of static path elements are.\nfunc (c CurlyRouter) matchesRouteByPathTokens(routeTokens, requestTokens []string, routeHasCustomVerb bool) (matches bool, paramCount int, staticCount int) {\n\tif len(routeTokens) < len(requestTokens) {\n\t\t// proceed in matching only if last routeToken is wildcard\n\t\tcount := len(routeTokens)\n\t\tif count == 0 || !strings.HasSuffix(routeTokens[count-1], \"*}\") {\n\t\t\treturn false, 0, 0\n\t\t}\n\t\t// proceed\n\t}\n\tfor i, routeToken := range routeTokens {\n\t\tif i == len(requestTokens) {\n\t\t\t// reached end of request path\n\t\t\treturn false, 0, 0\n\t\t}\n\t\trequestToken := requestTokens[i]\n\t\tif routeHasCustomVerb && hasCustomVerb(routeToken) {\n\t\t\tif !isMatchCustomVerb(routeToken, requestToken) {\n\t\t\t\treturn false, 0, 0\n\t\t\t}\n\t\t\tstaticCount++\n\t\t\trequestToken = removeCustomVerb(requestToken)\n\t\t\trouteToken = removeCustomVerb(routeToken)\n\t\t}\n\n\t\tif strings.HasPrefix(routeToken, \"{\") {\n\t\t\tparamCount++\n\t\t\tif colon := strings.Index(routeToken, \":\"); colon != -1 {\n\t\t\t\t// match by regex\n\t\t\t\tmatchesToken, matchesRemainder := c.regularMatchesPathToken(routeToken, colon, requestToken)\n\t\t\t\tif !matchesToken {\n\t\t\t\t\treturn false, 0, 0\n\t\t\t\t}\n\t\t\t\tif matchesRemainder {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t} else { // no { prefix\n\t\t\tif requestToken != routeToken {\n\t\t\t\treturn false, 0, 0\n\t\t\t}\n\t\t\tstaticCount++\n\t\t}\n\t}\n\treturn true, paramCount, staticCount\n}\n\n// regularMatchesPathToken tests whether the regular expression part of routeToken matches the requestToken or all remaining tokens\n// format routeToken is {someVar:someExpression}, e.g. {zipcode:[\\d][\\d][\\d][\\d][A-Z][A-Z]}\nfunc (c CurlyRouter) regularMatchesPathToken(routeToken string, colon int, requestToken string) (matchesToken bool, matchesRemainder bool) {\n\tregPart := routeToken[colon+1 : len(routeToken)-1]\n\tif regPart == \"*\" {\n\t\tif trace {\n\t\t\ttraceLogger.Printf(\"wildcard parameter detected in route token %s that matches %s\\n\", routeToken, requestToken)\n\t\t}\n\t\treturn true, true\n\t}\n\tmatched, err := regexp.MatchString(regPart, requestToken)\n\treturn (matched && err == nil), false\n}\n\nvar jsr311Router = RouterJSR311{}\n\n// detectRoute selectes from a list of Route the first match by inspecting both the Accept and Content-Type\n// headers of the Request. See also RouterJSR311 in jsr311.go\nfunc (c CurlyRouter) detectRoute(candidateRoutes sortableCurlyRoutes, httpRequest *http.Request) (*Route, error) {\n\t// tracing is done inside detectRoute\n\treturn jsr311Router.detectRoute(candidateRoutes.routes(), httpRequest)\n}\n\n// detectWebService returns the best matching webService given the list of path tokens.\n// see also computeWebserviceScore\nfunc (c CurlyRouter) detectWebService(requestTokens []string, webServices []*WebService) *WebService {\n\tvar bestWs *WebService\n\tscore := -1\n\tfor _, eachWS := range webServices {\n\t\tmatches, eachScore := c.computeWebserviceScore(requestTokens, eachWS.pathExpr.tokens)\n\t\tif matches && (eachScore > score) {\n\t\t\tbestWs = eachWS\n\t\t\tscore = eachScore\n\t\t}\n\t}\n\treturn bestWs\n}\n\n// computeWebserviceScore returns whether tokens match and\n// the weighted score of the longest matching consecutive tokens from the beginning.\nfunc (c CurlyRouter) computeWebserviceScore(requestTokens []string, routeTokens []string) (bool, int) {\n\tif len(routeTokens) > len(requestTokens) {\n\t\treturn false, 0\n\t}\n\tscore := 0\n\tfor i := 0; i < len(routeTokens); i++ {\n\t\teachRequestToken := requestTokens[i]\n\t\teachRouteToken := routeTokens[i]\n\t\tif len(eachRequestToken) == 0 && len(eachRouteToken) == 0 {\n\t\t\tscore++\n\t\t\tcontinue\n\t\t}\n\t\tif len(eachRouteToken) > 0 && strings.HasPrefix(eachRouteToken, \"{\") {\n\t\t\t// no empty match\n\t\t\tif len(eachRequestToken) == 0 {\n\t\t\t\treturn false, score\n\t\t\t}\n\t\t\tscore++\n\n\t\t\tif colon := strings.Index(eachRouteToken, \":\"); colon != -1 {\n\t\t\t\t// match by regex\n\t\t\t\tmatchesToken, _ := c.regularMatchesPathToken(eachRouteToken, colon, eachRequestToken)\n\t\t\t\tif matchesToken {\n\t\t\t\t\tscore++ // extra score for regex match\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t} else {\n\t\t\t// not a parameter\n\t\t\tif eachRequestToken != eachRouteToken {\n\t\t\t\treturn false, score\n\t\t\t}\n\t\t\tscore += (len(routeTokens) - i) * 10 //fuzzy\n\t\t}\n\t}\n\treturn true, score\n}\n"
        },
        {
          "name": "curly_route.go",
          "type": "blob",
          "size": 1.2275390625,
          "content": "package restful\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\n// curlyRoute exits for sorting Routes by the CurlyRouter based on number of parameters and number of static path elements.\ntype curlyRoute struct {\n\troute       Route\n\tparamCount  int\n\tstaticCount int\n}\n\n// sortableCurlyRoutes orders by most parameters and path elements first.\ntype sortableCurlyRoutes []curlyRoute\n\nfunc (s *sortableCurlyRoutes) add(route curlyRoute) {\n\t*s = append(*s, route)\n}\n\nfunc (s sortableCurlyRoutes) routes() (routes []Route) {\n\troutes = make([]Route, 0, len(s))\n\tfor _, each := range s {\n\t\troutes = append(routes, each.route) // TODO change return type\n\t}\n\treturn routes\n}\n\nfunc (s sortableCurlyRoutes) Len() int {\n\treturn len(s)\n}\nfunc (s sortableCurlyRoutes) Swap(i, j int) {\n\ts[i], s[j] = s[j], s[i]\n}\nfunc (s sortableCurlyRoutes) Less(i, j int) bool {\n\ta := s[j]\n\tb := s[i]\n\n\t// primary key\n\tif a.staticCount < b.staticCount {\n\t\treturn true\n\t}\n\tif a.staticCount > b.staticCount {\n\t\treturn false\n\t}\n\t// secundary key\n\tif a.paramCount < b.paramCount {\n\t\treturn true\n\t}\n\tif a.paramCount > b.paramCount {\n\t\treturn false\n\t}\n\treturn a.route.Path < b.route.Path\n}\n"
        },
        {
          "name": "curly_test.go",
          "type": "blob",
          "size": 8.1953125,
          "content": "package restful\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"testing\"\n)\n\nvar requestPaths = []struct {\n\t// url with path (1) is handled by service with root (2) and remainder has value final (3)\n\tpath, root string\n}{\n\t{\"/\", \"/\"},\n\t{\"/p\", \"/p\"},\n\t{\"/p/x\", \"/p/{q}\"},\n\t{\"/q/x\", \"/q\"},\n\t{\"/p/x/\", \"/p/{q}\"},\n\t{\"/p/x/y\", \"/p/{q}\"},\n\t{\"/q/x/y\", \"/q\"},\n\t{\"/z/q\", \"/{p}/q\"},\n\t{\"/a/b/c/q\", \"/\"},\n}\n\n// go test -v -test.run TestCurlyDetectWebService ...restful\nfunc TestCurlyDetectWebService(t *testing.T) {\n\tws1 := new(WebService).Path(\"/\")\n\tws2 := new(WebService).Path(\"/p\")\n\tws3 := new(WebService).Path(\"/q\")\n\tws4 := new(WebService).Path(\"/p/q\")\n\tws5 := new(WebService).Path(\"/p/{q}\")\n\tws7 := new(WebService).Path(\"/{p}/q\")\n\tvar wss = []*WebService{ws1, ws2, ws3, ws4, ws5, ws7}\n\n\tfor _, each := range wss {\n\t\tt.Logf(\"path=%s,toks=%v\\n\", each.pathExpr.Source, each.pathExpr.tokens)\n\t}\n\n\trouter := CurlyRouter{}\n\n\tok := true\n\tfor i, fixture := range requestPaths {\n\t\trequestTokens := tokenizePath(fixture.path)\n\t\twho := router.detectWebService(requestTokens, wss)\n\t\tif who != nil && who.RootPath() != fixture.root {\n\t\t\tt.Logf(\"[line:%v] Unexpected dispatcher, expected:%v, actual:%v\", i, fixture.root, who.RootPath())\n\t\t\tok = false\n\t\t}\n\t}\n\tif !ok {\n\t\tt.Fail()\n\t}\n}\n\nvar serviceDetects = []struct {\n\tpath  string\n\tfound bool\n\troot  string\n}{\n\t{\"/a/b\", true, \"/{p}/{q}/{r}\"},\n\t{\"/p/q\", true, \"/p/q\"},\n\t{\"/q/p\", true, \"/q\"},\n\t{\"/\", true, \"/\"},\n\t{\"/p/q/r\", true, \"/p/q\"},\n}\n\n// go test -v -test.run Test_detectWebService ...restful\nfunc Test_detectWebService(t *testing.T) {\n\trouter := CurlyRouter{}\n\tws1 := new(WebService).Path(\"/\")\n\tws2 := new(WebService).Path(\"/p\")\n\tws3 := new(WebService).Path(\"/q\")\n\tws4 := new(WebService).Path(\"/p/q\")\n\tws5 := new(WebService).Path(\"/p/{q}\")\n\tws6 := new(WebService).Path(\"/p/{q}/\")\n\tws7 := new(WebService).Path(\"/{p}/q\")\n\tws8 := new(WebService).Path(\"/{p}/{q}/{r}\")\n\tvar wss = []*WebService{ws8, ws7, ws6, ws5, ws4, ws3, ws2, ws1}\n\tfor _, fix := range serviceDetects {\n\t\trequestPath := fix.path\n\t\trequestTokens := tokenizePath(requestPath)\n\t\tfor _, ws := range wss {\n\t\t\tserviceTokens := ws.pathExpr.tokens\n\t\t\tmatches, score := router.computeWebserviceScore(requestTokens, serviceTokens)\n\t\t\tt.Logf(\"req=%s,toks:%v,ws=%s,toks:%v,score=%d,matches=%v\", requestPath, requestTokens, ws.RootPath(), serviceTokens, score, matches)\n\t\t}\n\t\tbest := router.detectWebService(requestTokens, wss)\n\t\tif best != nil {\n\t\t\tif fix.found {\n\t\t\t\tt.Logf(\"best=%s\", best.RootPath())\n\t\t\t} else {\n\t\t\t\tt.Fatalf(\"should have found:%s\", fix.root)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc Test_detectWebServiceWithRegexPath(t *testing.T) {\n\trouter := CurlyRouter{}\n\tholaWS := new(WebService).Path(\"/{:hola}\")\n\thelloWS := new(WebService).Path(\"/{:hello}\")\n\n\tvar wss = []*WebService{holaWS, helloWS}\n\n\tholaJuanInTokens := tokenizePath(\"/hola/juan\")\n\tselected := router.detectWebService(holaJuanInTokens, wss)\n\tif selected != holaWS {\n\t\tt.Fatalf(\"expected holaWS, got %v\", selected.rootPath)\n\t}\n\n\thelloJuanInTokens := tokenizePath(\"/hello/juan\")\n\tselected = router.detectWebService(helloJuanInTokens, wss)\n\tif selected != helloWS {\n\t\tt.Fatalf(\"expected helloWS, got %v\", selected.rootPath)\n\t}\n}\n\nvar routeMatchers = []struct {\n\troute         string\n\tpath          string\n\tmatches       bool\n\tparamCount    int\n\tstaticCount   int\n\thasCustomVerb bool\n}{\n\t// route, request-path\n\t{\"/a\", \"/a\", true, 0, 1, false},\n\t{\"/a\", \"/b\", false, 0, 0, false},\n\t{\"/a\", \"/b\", false, 0, 0, false},\n\t{\"/a/{b}/c/\", \"/a/2/c\", true, 1, 2, false},\n\t{\"/{a}/{b}/{c}/\", \"/a/b\", false, 0, 0, false},\n\t{\"/{x:*}\", \"/\", false, 0, 0, false},\n\t{\"/{x:*}\", \"/a\", true, 1, 0, false},\n\t{\"/{x:*}\", \"/a/b\", true, 1, 0, false},\n\t{\"/a/{x:*}\", \"/a/b\", true, 1, 1, false},\n\t{\"/a/{x:[A-Z][A-Z]}\", \"/a/ZX\", true, 1, 1, false},\n\t{\"/basepath/{resource:*}\", \"/basepath/some/other/location/test.xml\", true, 1, 1, false},\n\t{\"/resources:run\", \"/resources:run\", true, 0, 2, true},\n\t{\"/resources:run\", \"/user:run\", false, 0, 0, true},\n\t{\"/resources:run\", \"/resources\", false, 0, 0, true},\n\t{\"/users/{userId:^prefix-}:start\", \"/users/prefix-}:startUserId\", false, 0, 0, true},\n\t{\"/users/{userId:^prefix-}:start\", \"/users/prefix-userId:start\", true, 1, 2, true},\n}\n\n// clear && go test -v -test.run Test_matchesRouteByPathTokens ...restful\nfunc Test_matchesRouteByPathTokens(t *testing.T) {\n\trouter := CurlyRouter{}\n\tfor i, each := range routeMatchers {\n\t\trouteToks := tokenizePath(each.route)\n\t\treqToks := tokenizePath(each.path)\n\t\tmatches, pCount, sCount := router.matchesRouteByPathTokens(routeToks, reqToks, each.hasCustomVerb)\n\t\tif matches != each.matches {\n\t\t\tt.Fatalf(\"[%d] unexpected matches outcome route:%s, path:%s, matches:%v\", i, each.route, each.path, matches)\n\t\t}\n\t\tif pCount != each.paramCount {\n\t\t\tt.Fatalf(\"[%d] unexpected paramCount got:%d want:%d \", i, pCount, each.paramCount)\n\t\t}\n\t\tif sCount != each.staticCount {\n\t\t\tt.Fatalf(\"[%d] unexpected staticCount got:%d want:%d \", i, sCount, each.staticCount)\n\t\t}\n\t}\n}\n\n// clear && go test -v -test.run TestExtractParameters_Wildcard1 ...restful\nfunc TestExtractParameters_Wildcard1(t *testing.T) {\n\tparams := doExtractParams(\"/fixed/{var:*}\", 2, \"/fixed/remainder\", t)\n\tif params[\"var\"] != \"remainder\" {\n\t\tt.Errorf(\"parameter mismatch var: %s\", params[\"var\"])\n\t}\n}\n\n// clear && go test -v -test.run TestExtractParameters_Wildcard2 ...restful\nfunc TestExtractParameters_Wildcard2(t *testing.T) {\n\tparams := doExtractParams(\"/fixed/{var:*}\", 2, \"/fixed/remain/der\", t)\n\tif params[\"var\"] != \"remain/der\" {\n\t\tt.Errorf(\"parameter mismatch var: %s\", params[\"var\"])\n\t}\n}\n\n// clear && go test -v -test.run TestExtractParameters_Wildcard3 ...restful\nfunc TestExtractParameters_Wildcard3(t *testing.T) {\n\tparams := doExtractParams(\"/static/{var:*}\", 2, \"/static/test/sub/hi.html\", t)\n\tif params[\"var\"] != \"test/sub/hi.html\" {\n\t\tt.Errorf(\"parameter mismatch var: %s\", params[\"var\"])\n\t}\n}\n\nfunc TestExtractParameters_Wildcard4(t *testing.T) {\n\tparams := doExtractParams(\"/static/{var:*}/sub\", 3, \"/static/test/sub\", t)\n\tif params[\"var\"] != \"test/sub\" {\n\t\tt.Errorf(\"parameter mismatch var: %s\", params[\"var\"])\n\t}\n}\n\n// clear && go test -v -test.run TestCurly_ISSUE_34 ...restful\nfunc TestCurly_ISSUE_34(t *testing.T) {\n\tws1 := new(WebService).Path(\"/\")\n\tws1.Route(ws1.GET(\"/{type}/{id}\").To(curlyDummy))\n\tws1.Route(ws1.GET(\"/network/{id}\").To(curlyDummy))\n\tcroutes := CurlyRouter{}.selectRoutes(ws1, tokenizePath(\"/network/12\"))\n\tif len(croutes) != 2 {\n\t\tt.Fatal(\"expected 2 routes\")\n\t}\n\tif got, want := croutes[0].route.Path, \"/network/{id}\"; got != want {\n\t\tt.Errorf(\"got %v want %v\", got, want)\n\t}\n}\n\n// clear && go test -v -test.run TestCurly_ISSUE_34_2 ...restful\nfunc TestCurly_ISSUE_34_2(t *testing.T) {\n\tws1 := new(WebService)\n\tws1.Route(ws1.GET(\"/network/{id}\").To(curlyDummy))\n\tws1.Route(ws1.GET(\"/{type}/{id}\").To(curlyDummy))\n\tcroutes := CurlyRouter{}.selectRoutes(ws1, tokenizePath(\"/network/12\"))\n\tif len(croutes) != 2 {\n\t\tt.Fatal(\"expected 2 routes\")\n\t}\n\tif got, want := croutes[0].route.Path, \"/network/{id}\"; got != want {\n\t\tt.Errorf(\"got %v want %v\", got, want)\n\t}\n}\n\n// clear && go test -v -test.run TestCurly_JsonHtml ...restful\nfunc TestCurly_JsonHtml(t *testing.T) {\n\tws1 := new(WebService)\n\tws1.Path(\"/\")\n\tws1.Route(ws1.GET(\"/some.html\").To(curlyDummy).Consumes(\"*/*\").Produces(\"text/html\"))\n\treq, _ := http.NewRequest(\"GET\", \"/some.html\", nil)\n\treq.Header.Set(\"Accept\", \"application/json\")\n\t_, route, err := CurlyRouter{}.SelectRoute([]*WebService{ws1}, req)\n\tif err == nil {\n\t\tt.Error(\"error expected\")\n\t}\n\tif route != nil {\n\t\tt.Error(\"no route expected\")\n\t}\n}\n\n// go test -v -test.run TestCurly_ISSUE_137 ...restful\nfunc TestCurly_ISSUE_137(t *testing.T) {\n\tws1 := new(WebService)\n\tws1.Route(ws1.GET(\"/hello\").To(curlyDummy))\n\tws1.Path(\"/\")\n\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t_, route, _ := CurlyRouter{}.SelectRoute([]*WebService{ws1}, req)\n\tt.Log(route)\n\tif route != nil {\n\t\tt.Error(\"no route expected\")\n\t}\n}\n\n// go test -v -test.run TestCurly_ISSUE_137_2 ...restful\nfunc TestCurly_ISSUE_137_2(t *testing.T) {\n\tws1 := new(WebService)\n\tws1.Route(ws1.GET(\"/hello\").To(curlyDummy))\n\tws1.Path(\"/\")\n\treq, _ := http.NewRequest(\"GET\", \"/hello/bob\", nil)\n\t_, route, _ := CurlyRouter{}.SelectRoute([]*WebService{ws1}, req)\n\tt.Log(route)\n\tif route != nil {\n\t\tt.Errorf(\"no route expected, got %v\", route)\n\t}\n}\n\nfunc curlyDummy(req *Request, resp *Response) { io.WriteString(resp.ResponseWriter, \"curlyDummy\") }\n"
        },
        {
          "name": "custom_verb.go",
          "type": "blob",
          "size": 0.580078125,
          "content": "package restful\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\nvar (\n\tcustomVerbReg = regexp.MustCompile(\":([A-Za-z]+)$\")\n)\n\nfunc hasCustomVerb(routeToken string) bool {\n\treturn customVerbReg.MatchString(routeToken)\n}\n\nfunc isMatchCustomVerb(routeToken string, pathToken string) bool {\n\trs := customVerbReg.FindStringSubmatch(routeToken)\n\tif len(rs) < 2 {\n\t\treturn false\n\t}\n\n\tcustomVerb := rs[1]\n\tspecificVerbReg := regexp.MustCompile(fmt.Sprintf(\":%s$\", customVerb))\n\treturn specificVerbReg.MatchString(pathToken)\n}\n\nfunc removeCustomVerb(str string) string {\n\treturn customVerbReg.ReplaceAllString(str, \"\")\n}\n"
        },
        {
          "name": "custom_verb_test.go",
          "type": "blob",
          "size": 1.447265625,
          "content": "package restful\n\nimport \"testing\"\n\nfunc TestHasCustomVerb(t *testing.T) {\n\ttestCase := []struct {\n\t\tpath string\n\t\thas  bool\n\t}{\n\t\t{\"/{userId}:init\", true},\n\t\t{\"/{userId:init}\", false},\n\t\t{\"/users/{id:init}:init\", true},\n\t\t{\"/users/{id}\", false},\n\t}\n\n\tfor _, v := range testCase {\n\t\trs := hasCustomVerb(v.path)\n\t\tif rs != v.has {\n\t\t\tt.Errorf(\"path: %v should has no custom verb\", v.path)\n\t\t}\n\t}\n}\n\nfunc TestRemoveCustomVerb(t *testing.T) {\n\ttestCase := []struct {\n\t\tpath         string\n\t\texpectedPath string\n\t}{\n\t\t{\"/{userId}:init\", \"/{userId}\"},\n\t\t{\"/{userId:init}\", \"/{userId:init}\"},\n\t\t{\"/users/{id:init}:init\", \"/users/{id:init}\"},\n\t\t{\"/users/{id}\", \"/users/{id}\"},\n\t\t{\"/init/users/{id:init}:init\", \"/init/users/{id:init}\"},\n\t}\n\n\tfor _, v := range testCase {\n\t\trs := removeCustomVerb(v.path)\n\t\tif rs != v.expectedPath {\n\t\t\tt.Errorf(\"expected value: %v, actual: %v\", v.expectedPath, rs)\n\t\t}\n\t}\n}\nfunc TestMatchCustomVerb(t *testing.T) {\n\ttestCase := []struct {\n\t\trouteToken string\n\t\tpathToken  string\n\t\texpected   bool\n\t}{\n\t\t{\"{userId:regex}:init\", \"creator-123456789gWe:init\", true},\n\t\t{\"{userId:regex}:init\", \"creator-123456789gWe\", false},\n\t\t{\"{userId:regex}\", \"creator-123456789gWe:init\", false},\n\t\t{\"users:init\", \"users:init\", true},\n\t\t{\"users:init\", \"tokens:init\", true},\n\t}\n\n\tfor idx, v := range testCase {\n\t\trs := isMatchCustomVerb(v.routeToken, v.pathToken)\n\t\tif rs != v.expected {\n\t\t\tt.Errorf(\"expected value: %v, actual: %v, index: [%v]\", v.expected, rs, idx)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 7.345703125,
          "content": "/*\nPackage restful , a lean package for creating REST-style WebServices without magic.\n\nWebServices and Routes\n\nA WebService has a collection of Route objects that dispatch incoming Http Requests to a function calls.\nTypically, a WebService has a root path (e.g. /users) and defines common MIME types for its routes.\nWebServices must be added to a container (see below) in order to handler Http requests from a server.\n\nA Route is defined by a HTTP method, an URL path and (optionally) the MIME types it consumes (Content-Type) and produces (Accept).\nThis package has the logic to find the best matching Route and if found, call its Function.\n\n\tws := new(restful.WebService)\n\tws.\n\t\tPath(\"/users\").\n\t\tConsumes(restful.MIME_JSON, restful.MIME_XML).\n\t\tProduces(restful.MIME_JSON, restful.MIME_XML)\n\n\tws.Route(ws.GET(\"/{user-id}\").To(u.findUser))  // u is a UserResource\n\n\t...\n\n\t// GET http://localhost:8080/users/1\n\tfunc (u UserResource) findUser(request *restful.Request, response *restful.Response) {\n\t\tid := request.PathParameter(\"user-id\")\n\t\t...\n\t}\n\nThe (*Request, *Response) arguments provide functions for reading information from the request and writing information back to the response.\n\nSee the example https://github.com/emicklei/go-restful/blob/v3/examples/user-resource/restful-user-resource.go with a full implementation.\n\nRegular expression matching Routes\n\nA Route parameter can be specified using the format \"uri/{var[:regexp]}\" or the special version \"uri/{var:*}\" for matching the tail of the path.\nFor example, /persons/{name:[A-Z][A-Z]} can be used to restrict values for the parameter \"name\" to only contain capital alphabetic characters.\nRegular expressions must use the standard Go syntax as described in the regexp package. (https://code.google.com/p/re2/wiki/Syntax)\nThis feature requires the use of a CurlyRouter.\n\nContainers\n\nA Container holds a collection of WebServices, Filters and a http.ServeMux for multiplexing http requests.\nUsing the statements \"restful.Add(...) and restful.Filter(...)\" will register WebServices and Filters to the Default Container.\nThe Default container of go-restful uses the http.DefaultServeMux.\nYou can create your own Container and create a new http.Server for that particular container.\n\n\tcontainer := restful.NewContainer()\n\tserver := &http.Server{Addr: \":8081\", Handler: container}\n\nFilters\n\nA filter dynamically intercepts requests and responses to transform or use the information contained in the requests or responses.\nYou can use filters to perform generic logging, measurement, authentication, redirect, set response headers etc.\nIn the restful package there are three hooks into the request,response flow where filters can be added.\nEach filter must define a FilterFunction:\n\n\tfunc (req *restful.Request, resp *restful.Response, chain *restful.FilterChain)\n\nUse the following statement to pass the request,response pair to the next filter or RouteFunction\n\n\tchain.ProcessFilter(req, resp)\n\nContainer Filters\n\nThese are processed before any registered WebService.\n\n\t// install a (global) filter for the default container (processed before any webservice)\n\trestful.Filter(globalLogging)\n\nWebService Filters\n\nThese are processed before any Route of a WebService.\n\n\t// install a webservice filter (processed before any route)\n\tws.Filter(webserviceLogging).Filter(measureTime)\n\n\nRoute Filters\n\nThese are processed before calling the function associated with the Route.\n\n\t// install 2 chained route filters (processed before calling findUser)\n\tws.Route(ws.GET(\"/{user-id}\").Filter(routeLogging).Filter(NewCountFilter().routeCounter).To(findUser))\n\nSee the example https://github.com/emicklei/go-restful/blob/v3/examples/filters/restful-filters.go with full implementations.\n\nResponse Encoding\n\nTwo encodings are supported: gzip and deflate. To enable this for all responses:\n\n\trestful.DefaultContainer.EnableContentEncoding(true)\n\nIf a Http request includes the Accept-Encoding header then the response content will be compressed using the specified encoding.\nAlternatively, you can create a Filter that performs the encoding and install it per WebService or Route.\n\nSee the example https://github.com/emicklei/go-restful/blob/v3/examples/encoding/restful-encoding-filter.go\n\nOPTIONS support\n\nBy installing a pre-defined container filter, your Webservice(s) can respond to the OPTIONS Http request.\n\n\tFilter(OPTIONSFilter())\n\nCORS\n\nBy installing the filter of a CrossOriginResourceSharing (CORS), your WebService(s) can handle CORS requests.\n\n\tcors := CrossOriginResourceSharing{ExposeHeaders: []string{\"X-My-Header\"}, CookiesAllowed: false, Container: DefaultContainer}\n\tFilter(cors.Filter)\n\nError Handling\n\nUnexpected things happen. If a request cannot be processed because of a failure, your service needs to tell via the response what happened and why.\nFor this reason HTTP status codes exist and it is important to use the correct code in every exceptional situation.\n\n\t400: Bad Request\n\nIf path or query parameters are not valid (content or type) then use http.StatusBadRequest.\n\n\t404: Not Found\n\nDespite a valid URI, the resource requested may not be available\n\n\t500: Internal Server Error\n\nIf the application logic could not process the request (or write the response) then use http.StatusInternalServerError.\n\n\t405: Method Not Allowed\n\nThe request has a valid URL but the method (GET,PUT,POST,...) is not allowed.\n\n\t406: Not Acceptable\n\nThe request does not have or has an unknown Accept Header set for this operation.\n\n\t415: Unsupported Media Type\n\nThe request does not have or has an unknown Content-Type Header set for this operation.\n\nServiceError\n\nIn addition to setting the correct (error) Http status code, you can choose to write a ServiceError message on the response.\n\nPerformance options\n\nThis package has several options that affect the performance of your service. It is important to understand them and how you can change it.\n\n\trestful.DefaultContainer.DoNotRecover(false)\n\nDoNotRecover controls whether panics will be caught to return HTTP 500.\nIf set to false, the container will recover from panics.\nDefault value is true\n\n\trestful.SetCompressorProvider(NewBoundedCachedCompressors(20, 20))\n\nIf content encoding is enabled then the default strategy for getting new gzip/zlib writers and readers is to use a sync.Pool.\nBecause writers are expensive structures, performance is even more improved when using a preloaded cache. You can also inject your own implementation.\n\nTrouble shooting\n\nThis package has the means to produce detail logging of the complete Http request matching process and filter invocation.\nEnabling this feature requires you to set an implementation of restful.StdLogger (e.g. log.Logger) instance such as:\n\n\trestful.TraceLogger(log.New(os.Stdout, \"[restful] \", log.LstdFlags|log.Lshortfile))\n\nLogging\n\nThe restful.SetLogger() method allows you to override the logger used by the package. By default restful\nuses the standard library `log` package and logs to stdout. Different logging packages are supported as\nlong as they conform to `StdLogger` interface defined in the `log` sub-package, writing an adapter for your\npreferred package is simple.\n\nResources\n\n[project]: https://github.com/emicklei/go-restful\n\n[examples]: https://github.com/emicklei/go-restful/blob/master/examples\n\n[design]:  http://ernestmicklei.com/2012/11/11/go-restful-api-design/\n\n[showcases]: https://github.com/emicklei/mora, https://github.com/emicklei/landskape\n\n(c) 2012-2015, http://ernestmicklei.com. MIT License\n*/\npackage restful\n"
        },
        {
          "name": "doc_examples_test.go",
          "type": "blob",
          "size": 1.3046875,
          "content": "package restful\n\nimport \"net/http\"\n\nfunc ExampleOPTIONSFilter() {\n\t// Install the OPTIONS filter on the default Container\n\tFilter(OPTIONSFilter())\n}\nfunc ExampleContainer_OPTIONSFilter() {\n\t// Install the OPTIONS filter on a Container\n\tmyContainer := new(Container)\n\tmyContainer.Filter(myContainer.OPTIONSFilter)\n}\n\nfunc ExampleContainer() {\n\t// The Default container of go-restful uses the http.DefaultServeMux.\n\t// You can create your own Container using restful.NewContainer() and create a new http.Server for that particular container\n\n\tws := new(WebService)\n\twsContainer := NewContainer()\n\twsContainer.Add(ws)\n\tserver := &http.Server{Addr: \":8080\", Handler: wsContainer}\n\tserver.ListenAndServe()\n}\n\nfunc ExampleCrossOriginResourceSharing() {\n\t// To install this filter on the Default Container use:\n\tcors := CrossOriginResourceSharing{ExposeHeaders: []string{\"X-My-Header\"}, CookiesAllowed: false, Container: DefaultContainer}\n\tFilter(cors.Filter)\n}\n\nfunc ExampleServiceError() {\n\tresp := new(Response)\n\tresp.WriteEntity(NewError(http.StatusBadRequest, \"Non-integer {id} path parameter\"))\n}\n\nfunc ExampleBoundedCachedCompressors() {\n\t// Register a compressor provider (gzip/deflate read/write) that uses\n\t// a bounded cache with a maximum of 20 writers and 20 readers.\n\tSetCompressorProvider(NewBoundedCachedCompressors(20, 20))\n}\n"
        },
        {
          "name": "entity_accessors.go",
          "type": "blob",
          "size": 5.1728515625,
          "content": "package restful\n\n// Copyright 2015 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport (\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"strings\"\n\t\"sync\"\n)\n\nvar (\n\tMarshalIndent = json.MarshalIndent\n\tNewDecoder    = json.NewDecoder\n\tNewEncoder    = json.NewEncoder\n)\n\n// EntityReaderWriter can read and write values using an encoding such as JSON,XML.\ntype EntityReaderWriter interface {\n\t// Read a serialized version of the value from the request.\n\t// The Request may have a decompressing reader. Depends on Content-Encoding.\n\tRead(req *Request, v interface{}) error\n\n\t// Write a serialized version of the value on the response.\n\t// The Response may have a compressing writer. Depends on Accept-Encoding.\n\t// status should be a valid Http Status code\n\tWrite(resp *Response, status int, v interface{}) error\n}\n\n// entityAccessRegistry is a singleton\nvar entityAccessRegistry = &entityReaderWriters{\n\tprotection: new(sync.RWMutex),\n\taccessors:  map[string]EntityReaderWriter{},\n}\n\n// entityReaderWriters associates MIME to an EntityReaderWriter\ntype entityReaderWriters struct {\n\tprotection *sync.RWMutex\n\taccessors  map[string]EntityReaderWriter\n}\n\nfunc init() {\n\tRegisterEntityAccessor(MIME_JSON, NewEntityAccessorJSON(MIME_JSON))\n\tRegisterEntityAccessor(MIME_XML, NewEntityAccessorXML(MIME_XML))\n}\n\n// RegisterEntityAccessor add/overrides the ReaderWriter for encoding content with this MIME type.\nfunc RegisterEntityAccessor(mime string, erw EntityReaderWriter) {\n\tentityAccessRegistry.protection.Lock()\n\tdefer entityAccessRegistry.protection.Unlock()\n\tentityAccessRegistry.accessors[mime] = erw\n}\n\n// NewEntityAccessorJSON returns a new EntityReaderWriter for accessing JSON content.\n// This package is already initialized with such an accessor using the MIME_JSON contentType.\nfunc NewEntityAccessorJSON(contentType string) EntityReaderWriter {\n\treturn entityJSONAccess{ContentType: contentType}\n}\n\n// NewEntityAccessorXML returns a new EntityReaderWriter for accessing XML content.\n// This package is already initialized with such an accessor using the MIME_XML contentType.\nfunc NewEntityAccessorXML(contentType string) EntityReaderWriter {\n\treturn entityXMLAccess{ContentType: contentType}\n}\n\n// accessorAt returns the registered ReaderWriter for this MIME type.\nfunc (r *entityReaderWriters) accessorAt(mime string) (EntityReaderWriter, bool) {\n\tr.protection.RLock()\n\tdefer r.protection.RUnlock()\n\ter, ok := r.accessors[mime]\n\tif !ok {\n\t\t// retry with reverse lookup\n\t\t// more expensive but we are in an exceptional situation anyway\n\t\tfor k, v := range r.accessors {\n\t\t\tif strings.Contains(mime, k) {\n\t\t\t\treturn v, true\n\t\t\t}\n\t\t}\n\t}\n\treturn er, ok\n}\n\n// entityXMLAccess is a EntityReaderWriter for XML encoding\ntype entityXMLAccess struct {\n\t// This is used for setting the Content-Type header when writing\n\tContentType string\n}\n\n// Read unmarshalls the value from XML\nfunc (e entityXMLAccess) Read(req *Request, v interface{}) error {\n\treturn xml.NewDecoder(req.Request.Body).Decode(v)\n}\n\n// Write marshalls the value to JSON and set the Content-Type Header.\nfunc (e entityXMLAccess) Write(resp *Response, status int, v interface{}) error {\n\treturn writeXML(resp, status, e.ContentType, v)\n}\n\n// writeXML marshalls the value to JSON and set the Content-Type Header.\nfunc writeXML(resp *Response, status int, contentType string, v interface{}) error {\n\tif v == nil {\n\t\tresp.WriteHeader(status)\n\t\t// do not write a nil representation\n\t\treturn nil\n\t}\n\tif resp.prettyPrint {\n\t\t// pretty output must be created and written explicitly\n\t\toutput, err := xml.MarshalIndent(v, \" \", \" \")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tresp.Header().Set(HEADER_ContentType, contentType)\n\t\tresp.WriteHeader(status)\n\t\t_, err = resp.Write([]byte(xml.Header))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = resp.Write(output)\n\t\treturn err\n\t}\n\t// not-so-pretty\n\tresp.Header().Set(HEADER_ContentType, contentType)\n\tresp.WriteHeader(status)\n\treturn xml.NewEncoder(resp).Encode(v)\n}\n\n// entityJSONAccess is a EntityReaderWriter for JSON encoding\ntype entityJSONAccess struct {\n\t// This is used for setting the Content-Type header when writing\n\tContentType string\n}\n\n// Read unmarshalls the value from JSON\nfunc (e entityJSONAccess) Read(req *Request, v interface{}) error {\n\tdecoder := NewDecoder(req.Request.Body)\n\tdecoder.UseNumber()\n\treturn decoder.Decode(v)\n}\n\n// Write marshalls the value to JSON and set the Content-Type Header.\nfunc (e entityJSONAccess) Write(resp *Response, status int, v interface{}) error {\n\treturn writeJSON(resp, status, e.ContentType, v)\n}\n\n// write marshalls the value to JSON and set the Content-Type Header.\nfunc writeJSON(resp *Response, status int, contentType string, v interface{}) error {\n\tif v == nil {\n\t\tresp.WriteHeader(status)\n\t\t// do not write a nil representation\n\t\treturn nil\n\t}\n\tif resp.prettyPrint {\n\t\t// pretty output must be created and written explicitly\n\t\toutput, err := MarshalIndent(v, \"\", \" \")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tresp.Header().Set(HEADER_ContentType, contentType)\n\t\tresp.WriteHeader(status)\n\t\t_, err = resp.Write(output)\n\t\treturn err\n\t}\n\t// not-so-pretty\n\tresp.Header().Set(HEADER_ContentType, contentType)\n\tresp.WriteHeader(status)\n\treturn NewEncoder(resp).Encode(v)\n}\n"
        },
        {
          "name": "entity_accessors_test.go",
          "type": "blob",
          "size": 1.6318359375,
          "content": "package restful\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"testing\"\n)\n\ntype keyvalue struct {\n\treadCalled  bool\n\twriteCalled bool\n}\n\nfunc (kv *keyvalue) Read(req *Request, v interface{}) error {\n\t//t := reflect.TypeOf(v)\n\t//rv := reflect.ValueOf(v)\n\tkv.readCalled = true\n\treturn nil\n}\n\nfunc (kv *keyvalue) Write(resp *Response, status int, v interface{}) error {\n\tt := reflect.TypeOf(v)\n\trv := reflect.ValueOf(v)\n\tfor ix := 0; ix < t.NumField(); ix++ {\n\t\tsf := t.Field(ix)\n\t\tio.WriteString(resp, sf.Name)\n\t\tio.WriteString(resp, \"=\")\n\t\tio.WriteString(resp, fmt.Sprintf(\"%v\\n\", rv.Field(ix).Interface()))\n\t}\n\tkv.writeCalled = true\n\treturn nil\n}\n\n// go test -v -test.run TestKeyValueEncoding ...restful\nfunc TestKeyValueEncoding(t *testing.T) {\n\ttype Book struct {\n\t\tTitle         string\n\t\tAuthor        string\n\t\tPublishedYear int\n\t}\n\tkv := new(keyvalue)\n\tRegisterEntityAccessor(\"application/kv\", kv)\n\tb := Book{\"Singing for Dummies\", \"john doe\", 2015}\n\n\t// Write\n\thttpWriter := httptest.NewRecorder()\n\t//\t\t\t\t\t\t\t\tAccept\t\t\t\t\t\t\t\t\tProduces\n\tresp := Response{ResponseWriter: httpWriter, requestAccept: \"application/kv,*/*;q=0.8\", routeProduces: []string{\"application/kv\"}, prettyPrint: true}\n\tresp.WriteEntity(b)\n\tt.Log(string(httpWriter.Body.Bytes()))\n\tif !kv.writeCalled {\n\t\tt.Error(\"Write never called\")\n\t}\n\n\t// Read\n\tbodyReader := bytes.NewReader(httpWriter.Body.Bytes())\n\thttpRequest, _ := http.NewRequest(\"GET\", \"/test\", bodyReader)\n\thttpRequest.Header.Set(\"Content-Type\", \"application/kv; charset=UTF-8\")\n\trequest := NewRequest(httpRequest)\n\tvar bb Book\n\trequest.ReadEntity(&bb)\n\tif !kv.readCalled {\n\t\tt.Error(\"Read never called\")\n\t}\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "extensions.go",
          "type": "blob",
          "size": 0.7060546875,
          "content": "package restful\n\n// Copyright 2021 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\n// ExtensionProperties provides storage of vendor extensions for entities\ntype ExtensionProperties struct {\n\t// Extensions vendor extensions used to describe extra functionality\n\t// (https://swagger.io/docs/specification/2-0/swagger-extensions/)\n\tExtensions map[string]interface{}\n}\n\n// AddExtension adds or updates a key=value pair to the extension map.\nfunc (ep *ExtensionProperties) AddExtension(key string, value interface{}) {\n\tif ep.Extensions == nil {\n\t\tep.Extensions = map[string]interface{}{key: value}\n\t} else {\n\t\tep.Extensions[key] = value\n\t}\n}\n"
        },
        {
          "name": "filter.go",
          "type": "blob",
          "size": 1.71875,
          "content": "package restful\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\n// FilterChain is a request scoped object to process one or more filters before calling the target RouteFunction.\ntype FilterChain struct {\n\tFilters       []FilterFunction // ordered list of FilterFunction\n\tIndex         int              // index into filters that is currently in progress\n\tTarget        RouteFunction    // function to call after passing all filters\n\tParameterDocs []*Parameter     // the parameter docs for the route\n\tOperation     string           // the name of the operation\n}\n\n// ProcessFilter passes the request,response pair through the next of Filters.\n// Each filter can decide to proceed to the next Filter or handle the Response itself.\nfunc (f *FilterChain) ProcessFilter(request *Request, response *Response) {\n\tif f.Index < len(f.Filters) {\n\t\tf.Index++\n\t\tf.Filters[f.Index-1](request, response, f)\n\t} else {\n\t\tf.Target(request, response)\n\t}\n}\n\n// FilterFunction definitions must call ProcessFilter on the FilterChain to pass on the control and eventually call the RouteFunction\ntype FilterFunction func(*Request, *Response, *FilterChain)\n\n// NoBrowserCacheFilter is a filter function to set HTTP headers that disable browser caching\n// See examples/restful-no-cache-filter.go for usage\nfunc NoBrowserCacheFilter(req *Request, resp *Response, chain *FilterChain) {\n\tresp.Header().Set(\"Cache-Control\", \"no-cache, no-store, must-revalidate\") // HTTP 1.1.\n\tresp.Header().Set(\"Pragma\", \"no-cache\")                                   // HTTP 1.0.\n\tresp.Header().Set(\"Expires\", \"0\")                                         // Proxies.\n\tchain.ProcessFilter(req, resp)\n}\n"
        },
        {
          "name": "filter_adapter.go",
          "type": "blob",
          "size": 0.6455078125,
          "content": "package restful\n\nimport (\n\t\"net/http\"\n)\n\n// HttpMiddlewareHandler is a function that takes a http.Handler and returns a http.Handler\ntype HttpMiddlewareHandler func(http.Handler) http.Handler\n\n// HttpMiddlewareHandlerToFilter converts a HttpMiddlewareHandler to a FilterFunction.\nfunc HttpMiddlewareHandlerToFilter(middleware HttpMiddlewareHandler) FilterFunction {\n\treturn func(req *Request, resp *Response, chain *FilterChain) {\n\t\tnext := http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {\n\t\t\treq.Request = r\n\t\t\tresp.ResponseWriter = rw\n\t\t\tchain.ProcessFilter(req, resp)\n\t\t})\n\n\t\tmiddleware(next).ServeHTTP(resp.ResponseWriter, req.Request)\n\t}\n}\n"
        },
        {
          "name": "filter_adapter_test.go",
          "type": "blob",
          "size": 2.607421875,
          "content": "package restful\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\nfunc auth(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\") != \"admin\" {\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc newTrace(logger io.Writer) HttpMiddlewareHandler {\n\treturn func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\ttraceId := \"TRACE-ID-01234\"\n\t\t\tw.Header().Set(\"x-trace-id\", traceId)\n\t\t\tnext.ServeHTTP(w, r)\n\t\t\tio.WriteString(logger, traceId)\n\t\t})\n\t}\n\n}\n\nfunc listUsers(request *Request, response *Response) {\n\tio.WriteString(response, \"alice,bob\")\n}\n\nfunc TestHttpMiddlewareHandlerToFilter(t *testing.T) {\n\tws := new(WebService)\n\tws.Route(ws.GET(\"/users\").Filter(\n\t\tHttpMiddlewareHandlerToFilter(auth),\n\t).To(listUsers))\n\n\tvar testLogger = bytes.NewBuffer(nil)\n\tws.Route(ws.GET(\"/v2/users\").Filter(\n\t\tHttpMiddlewareHandlerToFilter(newTrace(testLogger)),\n\t).Filter(\n\t\tHttpMiddlewareHandlerToFilter(auth),\n\t).To(listUsers))\n\tcontainer := NewContainer()\n\tcontainer.Add(ws)\n\n\t// test /users, chain: auth\n\tr, _ := http.NewRequest(\"GET\", \"/users\", io.NopCloser(nil))\n\tr.Header.Set(\"Authorization\", \"guest\")\n\trw := httptest.NewRecorder()\n\tcontainer.ServeHTTP(rw, r)\n\tif rw.Code != http.StatusUnauthorized {\n\t\tt.Errorf(\"expected status code %d, but got %d\", http.StatusUnauthorized, rw.Code)\n\t}\n\n\tr, _ = http.NewRequest(\"GET\", \"/users\", io.NopCloser(nil))\n\tr.Header.Set(\"Authorization\", \"admin\")\n\trw = httptest.NewRecorder()\n\tcontainer.ServeHTTP(rw, r)\n\tif rw.Code != http.StatusOK {\n\t\tt.Errorf(\"expected status code %d, but got %d\", http.StatusOK, rw.Code)\n\t}\n\tif rw.Body.String() != \"alice,bob\" {\n\t\tt.Errorf(\"expected response body %q, but got %q\", \"alice,bob\", rw.Body.String())\n\t}\n\n\t// test /v2/users, chain: trace + auth\n\tr, _ = http.NewRequest(\"GET\", \"/v2/users\", io.NopCloser(nil))\n\tr.Header.Set(\"Authorization\", \"admin\")\n\trw = httptest.NewRecorder()\n\tcontainer.ServeHTTP(rw, r)\n\tif rw.Code != http.StatusOK {\n\t\tt.Errorf(\"expected status code %d, but got %d\", http.StatusOK, rw.Code)\n\t}\n\tif rw.Body.String() != \"alice,bob\" {\n\t\tt.Errorf(\"expected response body %q, but got %q\", \"alice,bob\", rw.Body.String())\n\t}\n\tif rw.Header().Get(\"x-trace-id\") != \"TRACE-ID-01234\" {\n\t\tt.Errorf(\"expected trace id %q, but got %q\", \"TRACE-ID-01234\", rw.Header().Get(\"x-trace-id\"))\n\t}\n\n\tloggerOutput := testLogger.String()\n\tif loggerOutput != \"TRACE-ID-01234\" {\n\t\tt.Errorf(\"expected logger %q, but got %q\", \"TRACE-ID-01234\", loggerOutput)\n\t}\n}\n"
        },
        {
          "name": "filter_test.go",
          "type": "blob",
          "size": 3.556640625,
          "content": "package restful\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\nfunc setupServices(addGlobalFilter bool, addServiceFilter bool, addRouteFilter bool) {\n\tif addGlobalFilter {\n\t\tFilter(globalFilter)\n\t}\n\tAdd(newTestService(addServiceFilter, addRouteFilter))\n}\n\nfunc tearDown() {\n\tDefaultContainer.webServices = []*WebService{}\n\tDefaultContainer.isRegisteredOnRoot = true // this allows for setupServices multiple times\n\tDefaultContainer.containerFilters = []FilterFunction{}\n}\n\nfunc newTestService(addServiceFilter bool, addRouteFilter bool) *WebService {\n\tws := new(WebService).Path(\"\")\n\tif addServiceFilter {\n\t\tws.Filter(serviceFilter)\n\t}\n\trb := ws.GET(\"/foo\").To(foo)\n\tif addRouteFilter {\n\t\trb.Filter(routeFilter)\n\t}\n\tws.Route(rb)\n\tws.Route(ws.GET(\"/bar\").To(bar))\n\treturn ws\n}\n\nfunc foo(req *Request, resp *Response) {\n\tio.WriteString(resp.ResponseWriter, \"foo\")\n}\n\nfunc bar(req *Request, resp *Response) {\n\tio.WriteString(resp.ResponseWriter, \"bar\")\n}\n\nfunc fail(req *Request, resp *Response) {\n\thttp.Error(resp.ResponseWriter, \"something failed\", http.StatusInternalServerError)\n}\n\nfunc globalFilter(req *Request, resp *Response, chain *FilterChain) {\n\tio.WriteString(resp.ResponseWriter, \"global-\")\n\tchain.ProcessFilter(req, resp)\n}\n\nfunc serviceFilter(req *Request, resp *Response, chain *FilterChain) {\n\tio.WriteString(resp.ResponseWriter, \"service-\")\n\tchain.ProcessFilter(req, resp)\n}\n\nfunc routeFilter(req *Request, resp *Response, chain *FilterChain) {\n\tio.WriteString(resp.ResponseWriter, \"route-\")\n\tchain.ProcessFilter(req, resp)\n}\n\nfunc TestNoFilter(t *testing.T) {\n\ttearDown()\n\tsetupServices(false, false, false)\n\tactual := sendIt(\"http://example.com/foo\")\n\tif \"foo\" != actual {\n\t\tt.Fatal(\"expected: foo but got:\" + actual)\n\t}\n}\n\nfunc TestGlobalFilter(t *testing.T) {\n\ttearDown()\n\tsetupServices(true, false, false)\n\tactual := sendIt(\"http://example.com/foo\")\n\tif \"global-foo\" != actual {\n\t\tt.Fatal(\"expected: global-foo but got:\" + actual)\n\t}\n}\n\nfunc TestWebServiceFilter(t *testing.T) {\n\ttearDown()\n\tsetupServices(true, true, false)\n\tactual := sendIt(\"http://example.com/foo\")\n\tif \"global-service-foo\" != actual {\n\t\tt.Fatal(\"expected: global-service-foo but got:\" + actual)\n\t}\n}\n\nfunc TestRouteFilter(t *testing.T) {\n\ttearDown()\n\tsetupServices(true, true, true)\n\tactual := sendIt(\"http://example.com/foo\")\n\tif \"global-service-route-foo\" != actual {\n\t\tt.Fatal(\"expected: global-service-route-foo but got:\" + actual)\n\t}\n}\n\nfunc TestRouteFilterOnly(t *testing.T) {\n\ttearDown()\n\tsetupServices(false, false, true)\n\tactual := sendIt(\"http://example.com/foo\")\n\tif \"route-foo\" != actual {\n\t\tt.Fatal(\"expected: route-foo but got:\" + actual)\n\t}\n}\n\nfunc TestBar(t *testing.T) {\n\ttearDown()\n\tsetupServices(false, true, false)\n\tactual := sendIt(\"http://example.com/bar\")\n\tif \"service-bar\" != actual {\n\t\tt.Fatal(\"expected: service-bar but got:\" + actual)\n\t}\n}\n\nfunc TestAllFiltersBar(t *testing.T) {\n\ttearDown()\n\tsetupServices(true, true, true)\n\tactual := sendIt(\"http://example.com/bar\")\n\tif \"global-service-bar\" != actual {\n\t\tt.Fatal(\"expected: global-service-bar but got:\" + actual)\n\t}\n}\n\nfunc sendIt(address string) string {\n\thttpRequest, _ := http.NewRequest(\"GET\", address, nil)\n\thttpRequest.Header.Set(\"Accept\", \"*/*\")\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\treturn httpWriter.Body.String()\n}\n\nfunc sendItTo(address string, container *Container) string {\n\thttpRequest, _ := http.NewRequest(\"GET\", address, nil)\n\thttpRequest.Header.Set(\"Accept\", \"*/*\")\n\thttpWriter := httptest.NewRecorder()\n\tcontainer.dispatch(httpWriter, httpRequest)\n\treturn httpWriter.Body.String()\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.048828125,
          "content": "module github.com/emicklei/go-restful/v3\n\ngo 1.13\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "jsr311.go",
          "type": "blob",
          "size": 10.3408203125,
          "content": "package restful\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// RouterJSR311 implements the flow for matching Requests to Routes (and consequently Resource Functions)\n// as specified by the JSR311 http://jsr311.java.net/nonav/releases/1.1/spec/spec.html.\n// RouterJSR311 implements the Router interface.\n// Concept of locators is not implemented.\ntype RouterJSR311 struct{}\n\n// SelectRoute is part of the Router interface and returns the best match\n// for the WebService and its Route for the given Request.\nfunc (r RouterJSR311) SelectRoute(\n\twebServices []*WebService,\n\thttpRequest *http.Request) (selectedService *WebService, selectedRoute *Route, err error) {\n\n\t// Identify the root resource class (WebService)\n\tdispatcher, finalMatch, err := r.detectDispatcher(httpRequest.URL.Path, webServices)\n\tif err != nil {\n\t\treturn nil, nil, NewError(http.StatusNotFound, \"\")\n\t}\n\t// Obtain the set of candidate methods (Routes)\n\troutes := r.selectRoutes(dispatcher, finalMatch)\n\tif len(routes) == 0 {\n\t\treturn dispatcher, nil, NewError(http.StatusNotFound, \"404: Page Not Found\")\n\t}\n\n\t// Identify the method (Route) that will handle the request\n\troute, ok := r.detectRoute(routes, httpRequest)\n\treturn dispatcher, route, ok\n}\n\n// ExtractParameters is used to obtain the path parameters from the route using the same matching\n// engine as the JSR 311 router.\nfunc (r RouterJSR311) ExtractParameters(route *Route, webService *WebService, urlPath string) map[string]string {\n\twebServiceExpr := webService.pathExpr\n\twebServiceMatches := webServiceExpr.Matcher.FindStringSubmatch(urlPath)\n\tpathParameters := r.extractParams(webServiceExpr, webServiceMatches)\n\trouteExpr := route.pathExpr\n\trouteMatches := routeExpr.Matcher.FindStringSubmatch(webServiceMatches[len(webServiceMatches)-1])\n\trouteParams := r.extractParams(routeExpr, routeMatches)\n\tfor key, value := range routeParams {\n\t\tpathParameters[key] = value\n\t}\n\treturn pathParameters\n}\n\nfunc (RouterJSR311) extractParams(pathExpr *pathExpression, matches []string) map[string]string {\n\tparams := map[string]string{}\n\tfor i := 1; i < len(matches); i++ {\n\t\tif len(pathExpr.VarNames) >= i {\n\t\t\tparams[pathExpr.VarNames[i-1]] = matches[i]\n\t\t}\n\t}\n\treturn params\n}\n\n// http://jsr311.java.net/nonav/releases/1.1/spec/spec3.html#x3-360003.7.2\nfunc (r RouterJSR311) detectRoute(routes []Route, httpRequest *http.Request) (*Route, error) {\n\tcandidates := make([]*Route, 0, 8)\n\tfor i, each := range routes {\n\t\tok := true\n\t\tfor _, fn := range each.If {\n\t\t\tif !fn(httpRequest) {\n\t\t\t\tok = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif ok {\n\t\t\tcandidates = append(candidates, &routes[i])\n\t\t}\n\t}\n\tif len(candidates) == 0 {\n\t\tif trace {\n\t\t\ttraceLogger.Printf(\"no Route found (from %d) that passes conditional checks\", len(routes))\n\t\t}\n\t\treturn nil, NewError(http.StatusNotFound, \"404: Not Found\")\n\t}\n\n\t// http method\n\tprevious := candidates\n\tcandidates = candidates[:0]\n\tfor _, each := range previous {\n\t\tif httpRequest.Method == each.Method {\n\t\t\tcandidates = append(candidates, each)\n\t\t}\n\t}\n\tif len(candidates) == 0 {\n\t\tif trace {\n\t\t\ttraceLogger.Printf(\"no Route found (in %d routes) that matches HTTP method %s\\n\", len(previous), httpRequest.Method)\n\t\t}\n\t\tallowed := []string{}\n\tallowedLoop:\n\t\tfor _, candidate := range previous {\n\t\t\tfor _, method := range allowed {\n\t\t\t\tif method == candidate.Method {\n\t\t\t\t\tcontinue allowedLoop\n\t\t\t\t}\n\t\t\t}\n\t\t\tallowed = append(allowed, candidate.Method)\n\t\t}\n\t\theader := http.Header{\"Allow\": []string{strings.Join(allowed, \", \")}}\n\t\treturn nil, NewErrorWithHeader(http.StatusMethodNotAllowed, \"405: Method Not Allowed\", header)\n\t}\n\n\t// content-type\n\tcontentType := httpRequest.Header.Get(HEADER_ContentType)\n\tprevious = candidates\n\tcandidates = candidates[:0]\n\tfor _, each := range previous {\n\t\tif each.matchesContentType(contentType) {\n\t\t\tcandidates = append(candidates, each)\n\t\t}\n\t}\n\tif len(candidates) == 0 {\n\t\tif trace {\n\t\t\ttraceLogger.Printf(\"no Route found (from %d) that matches HTTP Content-Type: %s\\n\", len(previous), contentType)\n\t\t}\n\t\tif httpRequest.ContentLength > 0 {\n\t\t\treturn nil, NewError(http.StatusUnsupportedMediaType, \"415: Unsupported Media Type\")\n\t\t}\n\t}\n\n\t// accept\n\tprevious = candidates\n\tcandidates = candidates[:0]\n\taccept := httpRequest.Header.Get(HEADER_Accept)\n\tif len(accept) == 0 {\n\t\taccept = \"*/*\"\n\t}\n\tfor _, each := range previous {\n\t\tif each.matchesAccept(accept) {\n\t\t\tcandidates = append(candidates, each)\n\t\t}\n\t}\n\tif len(candidates) == 0 {\n\t\tif trace {\n\t\t\ttraceLogger.Printf(\"no Route found (from %d) that matches HTTP Accept: %s\\n\", len(previous), accept)\n\t\t}\n\t\tavailable := []string{}\n\t\tfor _, candidate := range previous {\n\t\t\tavailable = append(available, candidate.Produces...)\n\t\t}\n\t\t// if POST,PUT,PATCH without body\n\t\tmethod, length := httpRequest.Method, httpRequest.Header.Get(\"Content-Length\")\n\t\tif (method == http.MethodPost ||\n\t\t\tmethod == http.MethodPut ||\n\t\t\tmethod == http.MethodPatch) && (length == \"\" || length == \"0\") {\n\t\t\treturn nil, NewError(\n\t\t\t\thttp.StatusUnsupportedMediaType,\n\t\t\t\tfmt.Sprintf(\"415: Unsupported Media Type\\n\\nAvailable representations: %s\", strings.Join(available, \", \")),\n\t\t\t)\n\t\t}\n\t\treturn nil, NewError(\n\t\t\thttp.StatusNotAcceptable,\n\t\t\tfmt.Sprintf(\"406: Not Acceptable\\n\\nAvailable representations: %s\", strings.Join(available, \", \")),\n\t\t)\n\t}\n\t// return r.bestMatchByMedia(outputMediaOk, contentType, accept), nil\n\treturn candidates[0], nil\n}\n\n// http://jsr311.java.net/nonav/releases/1.1/spec/spec3.html#x3-360003.7.2\n// n/m > n/* > */*\nfunc (r RouterJSR311) bestMatchByMedia(routes []Route, contentType string, accept string) *Route {\n\t// TODO\n\treturn &routes[0]\n}\n\n// http://jsr311.java.net/nonav/releases/1.1/spec/spec3.html#x3-360003.7.2  (step 2)\nfunc (r RouterJSR311) selectRoutes(dispatcher *WebService, pathRemainder string) []Route {\n\tfiltered := &sortableRouteCandidates{}\n\tfor _, each := range dispatcher.Routes() {\n\t\tpathExpr := each.pathExpr\n\t\tmatches := pathExpr.Matcher.FindStringSubmatch(pathRemainder)\n\t\tif matches != nil {\n\t\t\tlastMatch := matches[len(matches)-1]\n\t\t\tif len(lastMatch) == 0 || lastMatch == \"/\" { // do not include if value is neither empty nor ‘/’.\n\t\t\t\tfiltered.candidates = append(filtered.candidates,\n\t\t\t\t\trouteCandidate{each, len(matches) - 1, pathExpr.LiteralCount, pathExpr.VarCount})\n\t\t\t}\n\t\t}\n\t}\n\tif len(filtered.candidates) == 0 {\n\t\tif trace {\n\t\t\ttraceLogger.Printf(\"WebService on path %s has no routes that match URL path remainder:%s\\n\", dispatcher.rootPath, pathRemainder)\n\t\t}\n\t\treturn []Route{}\n\t}\n\tsort.Sort(sort.Reverse(filtered))\n\n\t// select other routes from candidates whoes expression matches rmatch\n\tmatchingRoutes := []Route{filtered.candidates[0].route}\n\tfor c := 1; c < len(filtered.candidates); c++ {\n\t\teach := filtered.candidates[c]\n\t\tif each.route.pathExpr.Matcher.MatchString(pathRemainder) {\n\t\t\tmatchingRoutes = append(matchingRoutes, each.route)\n\t\t}\n\t}\n\treturn matchingRoutes\n}\n\n// http://jsr311.java.net/nonav/releases/1.1/spec/spec3.html#x3-360003.7.2 (step 1)\nfunc (r RouterJSR311) detectDispatcher(requestPath string, dispatchers []*WebService) (*WebService, string, error) {\n\tfiltered := &sortableDispatcherCandidates{}\n\tfor _, each := range dispatchers {\n\t\tmatches := each.pathExpr.Matcher.FindStringSubmatch(requestPath)\n\t\tif matches != nil {\n\t\t\tfiltered.candidates = append(filtered.candidates,\n\t\t\t\tdispatcherCandidate{each, matches[len(matches)-1], len(matches), each.pathExpr.LiteralCount, each.pathExpr.VarCount})\n\t\t}\n\t}\n\tif len(filtered.candidates) == 0 {\n\t\tif trace {\n\t\t\ttraceLogger.Printf(\"no WebService was found to match URL path:%s\\n\", requestPath)\n\t\t}\n\t\treturn nil, \"\", errors.New(\"not found\")\n\t}\n\tsort.Sort(sort.Reverse(filtered))\n\treturn filtered.candidates[0].dispatcher, filtered.candidates[0].finalMatch, nil\n}\n\n// Types and functions to support the sorting of Routes\n\ntype routeCandidate struct {\n\troute           Route\n\tmatchesCount    int // the number of capturing groups\n\tliteralCount    int // the number of literal characters (means those not resulting from template variable substitution)\n\tnonDefaultCount int // the number of capturing groups with non-default regular expressions (i.e. not ‘([^  /]+?)’)\n}\n\nfunc (r routeCandidate) expressionToMatch() string {\n\treturn r.route.pathExpr.Source\n}\n\nfunc (r routeCandidate) String() string {\n\treturn fmt.Sprintf(\"(m=%d,l=%d,n=%d)\", r.matchesCount, r.literalCount, r.nonDefaultCount)\n}\n\ntype sortableRouteCandidates struct {\n\tcandidates []routeCandidate\n}\n\nfunc (rcs *sortableRouteCandidates) Len() int {\n\treturn len(rcs.candidates)\n}\nfunc (rcs *sortableRouteCandidates) Swap(i, j int) {\n\trcs.candidates[i], rcs.candidates[j] = rcs.candidates[j], rcs.candidates[i]\n}\nfunc (rcs *sortableRouteCandidates) Less(i, j int) bool {\n\tci := rcs.candidates[i]\n\tcj := rcs.candidates[j]\n\t// primary key\n\tif ci.literalCount < cj.literalCount {\n\t\treturn true\n\t}\n\tif ci.literalCount > cj.literalCount {\n\t\treturn false\n\t}\n\t// secundary key\n\tif ci.matchesCount < cj.matchesCount {\n\t\treturn true\n\t}\n\tif ci.matchesCount > cj.matchesCount {\n\t\treturn false\n\t}\n\t// tertiary key\n\tif ci.nonDefaultCount < cj.nonDefaultCount {\n\t\treturn true\n\t}\n\tif ci.nonDefaultCount > cj.nonDefaultCount {\n\t\treturn false\n\t}\n\t// quaternary key (\"source\" is interpreted as Path)\n\treturn ci.route.Path < cj.route.Path\n}\n\n// Types and functions to support the sorting of Dispatchers\n\ntype dispatcherCandidate struct {\n\tdispatcher      *WebService\n\tfinalMatch      string\n\tmatchesCount    int // the number of capturing groups\n\tliteralCount    int // the number of literal characters (means those not resulting from template variable substitution)\n\tnonDefaultCount int // the number of capturing groups with non-default regular expressions (i.e. not ‘([^  /]+?)’)\n}\ntype sortableDispatcherCandidates struct {\n\tcandidates []dispatcherCandidate\n}\n\nfunc (dc *sortableDispatcherCandidates) Len() int {\n\treturn len(dc.candidates)\n}\nfunc (dc *sortableDispatcherCandidates) Swap(i, j int) {\n\tdc.candidates[i], dc.candidates[j] = dc.candidates[j], dc.candidates[i]\n}\nfunc (dc *sortableDispatcherCandidates) Less(i, j int) bool {\n\tci := dc.candidates[i]\n\tcj := dc.candidates[j]\n\t// primary key\n\tif ci.matchesCount < cj.matchesCount {\n\t\treturn true\n\t}\n\tif ci.matchesCount > cj.matchesCount {\n\t\treturn false\n\t}\n\t// secundary key\n\tif ci.literalCount < cj.literalCount {\n\t\treturn true\n\t}\n\tif ci.literalCount > cj.literalCount {\n\t\treturn false\n\t}\n\t// tertiary key\n\treturn ci.nonDefaultCount < cj.nonDefaultCount\n}\n"
        },
        {
          "name": "jsr311_test.go",
          "type": "blob",
          "size": 11.2001953125,
          "content": "package restful\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"io\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"sort\"\n\t\"testing\"\n)\n\n//\n// Step 1 tests\n//\nvar paths = []struct {\n\t// url with path (1) is handled by service with root (2) and last capturing group has value final (3)\n\tpath, root, final string\n\tparams            map[string]string\n}{\n\t{\"/\", \"/\", \"/\", map[string]string{}},\n\t{\"/p\", \"/p\", \"\", map[string]string{}},\n\t{\"/p/x\", \"/p/{q}\", \"\", map[string]string{\"q\": \"x\"}},\n\t{\"/q/x\", \"/q\", \"/x\", map[string]string{}},\n\t{\"/p/x/\", \"/p/{q}\", \"/\", map[string]string{\"q\": \"x\"}},\n\t{\"/p/x/y\", \"/p/{q}\", \"/y\", map[string]string{\"q\": \"x\"}},\n\t{\"/q/x/y\", \"/q\", \"/x/y\", map[string]string{}},\n\t{\"/z/q\", \"/{p}/q\", \"\", map[string]string{\"p\": \"z\"}},\n\t{\"/a/b/c/q\", \"/\", \"/a/b/c/q\", map[string]string{}},\n}\n\nfunc TestDetectDispatcher(t *testing.T) {\n\tws1 := new(WebService).Path(\"/\")\n\tws2 := new(WebService).Path(\"/p\")\n\tws3 := new(WebService).Path(\"/q\")\n\tws4 := new(WebService).Path(\"/p/q\")\n\tws5 := new(WebService).Path(\"/p/{q}\")\n\tws6 := new(WebService).Path(\"/p/{q}/\")\n\tws7 := new(WebService).Path(\"/{p}/q\")\n\tvar dispatchers = []*WebService{ws1, ws2, ws3, ws4, ws5, ws6, ws7}\n\n\twc := NewContainer()\n\tfor _, each := range dispatchers {\n\t\teach.Route(each.GET(\"\").To(dummy))\n\t\twc.Add(each)\n\t}\n\n\trouter := RouterJSR311{}\n\n\tok := true\n\tfor i, fixture := range paths {\n\t\twho, final, err := router.detectDispatcher(fixture.path, dispatchers)\n\t\tif err != nil {\n\t\t\tt.Logf(\"error in detection:%v\", err)\n\t\t\tok = false\n\t\t}\n\t\tif who.RootPath() != fixture.root {\n\t\t\tt.Logf(\"[line:%v] Unexpected dispatcher, expected:%v, actual:%v\", i, fixture.root, who.RootPath())\n\t\t\tok = false\n\t\t}\n\t\tif final != fixture.final {\n\t\t\tt.Logf(\"[line:%v] Unexpected final, expected:%v, actual:%v\", i, fixture.final, final)\n\t\t\tok = false\n\t\t}\n\t\tparams := router.ExtractParameters(&who.Routes()[0], who, fixture.path)\n\t\tif !reflect.DeepEqual(params, fixture.params) {\n\t\t\tt.Logf(\"[line:%v] Unexpected params, expected:%v, actual:%v\", i, fixture.params, params)\n\t\t\tok = false\n\t\t}\n\t}\n\tif !ok {\n\t\tt.Fail()\n\t}\n}\n\n//\n// Step 2 tests\n//\n\n// go test -v -test.run TestISSUE_179 ...restful\nfunc TestISSUE_179(t *testing.T) {\n\tws1 := new(WebService)\n\tws1.Route(ws1.GET(\"/v1/category/{param:*}\").To(dummy))\n\troutes := RouterJSR311{}.selectRoutes(ws1, \"/v1/category/sub/sub\")\n\tt.Logf(\"%v\", routes)\n}\n\n// go test -v -test.run TestISSUE_30 ...restful\nfunc TestISSUE_30(t *testing.T) {\n\tws1 := new(WebService).Path(\"/users\")\n\tws1.Route(ws1.GET(\"/{id}\").To(dummy))\n\tws1.Route(ws1.POST(\"/login\").To(dummy))\n\troutes := RouterJSR311{}.selectRoutes(ws1, \"/login\")\n\tif len(routes) != 2 {\n\t\tt.Fatal(\"expected 2 routes\")\n\t}\n\tif routes[0].Path != \"/users/login\" {\n\t\tt.Error(\"first is\", routes[0].Path)\n\t\tt.Logf(\"routes:%v\", routes)\n\t}\n}\n\n// go test -v -test.run TestISSUE_34 ...restful\nfunc TestISSUE_34(t *testing.T) {\n\tws1 := new(WebService).Path(\"/\")\n\tws1.Route(ws1.GET(\"/{type}/{id}\").To(dummy))\n\tws1.Route(ws1.GET(\"/network/{id}\").To(dummy))\n\troutes := RouterJSR311{}.selectRoutes(ws1, \"/network/12\")\n\tif len(routes) != 2 {\n\t\tt.Fatal(\"expected 2 routes\")\n\t}\n\tif routes[0].Path != \"/network/{id}\" {\n\t\tt.Error(\"first is\", routes[0].Path)\n\t\tt.Logf(\"routes:%v\", routes)\n\t}\n}\n\n// go test -v -test.run TestISSUE_34_2 ...restful\nfunc TestISSUE_34_2(t *testing.T) {\n\tws1 := new(WebService).Path(\"/\")\n\t// change the registration order\n\tws1.Route(ws1.GET(\"/network/{id}\").To(dummy))\n\tws1.Route(ws1.GET(\"/{type}/{id}\").To(dummy))\n\troutes := RouterJSR311{}.selectRoutes(ws1, \"/network/12\")\n\tif len(routes) != 2 {\n\t\tt.Fatal(\"expected 2 routes\")\n\t}\n\tif routes[0].Path != \"/network/{id}\" {\n\t\tt.Error(\"first is\", routes[0].Path)\n\t}\n}\n\n// go test -v -test.run TestISSUE_137 ...restful\nfunc TestISSUE_137(t *testing.T) {\n\tws1 := new(WebService)\n\tws1.Route(ws1.GET(\"/hello\").To(dummy))\n\troutes := RouterJSR311{}.selectRoutes(ws1, \"/\")\n\tt.Log(routes)\n\tif len(routes) > 0 {\n\t\tt.Error(\"no route expected\")\n\t}\n}\n\nfunc TestSelectRoutesSlash(t *testing.T) {\n\tws1 := new(WebService).Path(\"/\")\n\tws1.Route(ws1.GET(\"\").To(dummy))\n\tws1.Route(ws1.GET(\"/\").To(dummy))\n\tws1.Route(ws1.GET(\"/u\").To(dummy))\n\tws1.Route(ws1.POST(\"/u\").To(dummy))\n\tws1.Route(ws1.POST(\"/u/v\").To(dummy))\n\tws1.Route(ws1.POST(\"/u/{w}\").To(dummy))\n\tws1.Route(ws1.POST(\"/u/{w}/z\").To(dummy))\n\troutes := RouterJSR311{}.selectRoutes(ws1, \"/u\")\n\tcheckRoutesContains(routes, \"/u\", t)\n\tcheckRoutesContainsNo(routes, \"/u/v\", t)\n\tcheckRoutesContainsNo(routes, \"/\", t)\n\tcheckRoutesContainsNo(routes, \"/u/{w}/z\", t)\n}\nfunc TestSelectRoutesU(t *testing.T) {\n\tws1 := new(WebService).Path(\"/u\")\n\tws1.Route(ws1.GET(\"\").To(dummy))\n\tws1.Route(ws1.GET(\"/\").To(dummy))\n\tws1.Route(ws1.GET(\"/v\").To(dummy))\n\tws1.Route(ws1.POST(\"/{w}\").To(dummy))\n\tws1.Route(ws1.POST(\"/{w}/z\").To(dummy))          // so full path = /u/{w}/z\n\troutes := RouterJSR311{}.selectRoutes(ws1, \"/v\") // test against /u/v\n\tcheckRoutesContains(routes, \"/u/{w}\", t)\n}\n\nfunc TestSelectRoutesUsers1(t *testing.T) {\n\tws1 := new(WebService).Path(\"/users\")\n\tws1.Route(ws1.POST(\"\").To(dummy))\n\tws1.Route(ws1.POST(\"/\").To(dummy))\n\tws1.Route(ws1.PUT(\"/{id}\").To(dummy))\n\troutes := RouterJSR311{}.selectRoutes(ws1, \"/1\")\n\tcheckRoutesContains(routes, \"/users/{id}\", t)\n}\nfunc checkRoutesContains(routes []Route, path string, t *testing.T) {\n\tif !containsRoutePath(routes, path, t) {\n\t\tfor _, r := range routes {\n\t\t\tt.Logf(\"route %v %v\", r.Method, r.Path)\n\t\t}\n\t\tt.Fatalf(\"routes should include [%v]:\", path)\n\t}\n}\nfunc checkRoutesContainsNo(routes []Route, path string, t *testing.T) {\n\tif containsRoutePath(routes, path, t) {\n\t\tfor _, r := range routes {\n\t\t\tt.Logf(\"route %v %v\", r.Method, r.Path)\n\t\t}\n\t\tt.Fatalf(\"routes should not include [%v]:\", path)\n\t}\n}\nfunc containsRoutePath(routes []Route, path string, t *testing.T) bool {\n\tfor _, each := range routes {\n\t\tif each.Path == path {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// go test -v -test.run TestSortableRouteCandidates ...restful\nfunc TestSortableRouteCandidates(t *testing.T) {\n\tfixture := &sortableRouteCandidates{}\n\tr1 := routeCandidate{matchesCount: 0, literalCount: 0, nonDefaultCount: 0}\n\tr2 := routeCandidate{matchesCount: 0, literalCount: 0, nonDefaultCount: 1}\n\tr3 := routeCandidate{matchesCount: 0, literalCount: 1, nonDefaultCount: 1}\n\tr4 := routeCandidate{matchesCount: 1, literalCount: 1, nonDefaultCount: 0}\n\tr5 := routeCandidate{matchesCount: 1, literalCount: 0, nonDefaultCount: 0}\n\tfixture.candidates = append(fixture.candidates, r5, r4, r3, r2, r1)\n\tsort.Sort(sort.Reverse(fixture))\n\tfirst := fixture.candidates[0]\n\tif first.matchesCount != 1 && first.literalCount != 1 && first.nonDefaultCount != 0 {\n\t\tt.Fatal(\"expected r4\")\n\t}\n\tlast := fixture.candidates[len(fixture.candidates)-1]\n\tif last.matchesCount != 0 && last.literalCount != 0 && last.nonDefaultCount != 0 {\n\t\tt.Fatal(\"expected r1\")\n\t}\n}\n\nfunc TestDetectRouteReturns404IfNoRoutePassesConditions(t *testing.T) {\n\tcalled := false\n\tshouldNotBeCalledButWas := false\n\n\troutes := []Route{\n\t\tnew(RouteBuilder).To(dummy).\n\t\t\tIf(func(req *http.Request) bool { return false }).\n\t\t\tBuild(),\n\n\t\t// check that condition functions are called in order\n\t\tnew(RouteBuilder).\n\t\t\tTo(dummy).\n\t\t\tIf(func(req *http.Request) bool { return true }).\n\t\t\tIf(func(req *http.Request) bool { called = true; return false }).\n\t\t\tBuild(),\n\n\t\t// check that condition functions short circuit\n\t\tnew(RouteBuilder).\n\t\t\tTo(dummy).\n\t\t\tIf(func(req *http.Request) bool { return false }).\n\t\t\tIf(func(req *http.Request) bool { shouldNotBeCalledButWas = true; return false }).\n\t\t\tBuild(),\n\t}\n\n\t_, err := RouterJSR311{}.detectRoute(routes, (*http.Request)(nil))\n\tif se := err.(ServiceError); se.Code != 404 {\n\t\tt.Fatalf(\"expected 404, got %d\", se.Code)\n\t}\n\n\tif !called {\n\t\tt.Fatal(\"expected condition function to get called, but it wasn't\")\n\t}\n\n\tif shouldNotBeCalledButWas {\n\t\tt.Fatal(\"expected condition function to not be called, but it was\")\n\t}\n}\n\nvar extractParams = []struct {\n\tname           string\n\troutePath      string\n\turlPath        string\n\texpectedParams map[string]string\n}{\n\t{\"wildcardLastPart\", \"/fixed/{var:*}\", \"/fixed/remainder\", map[string]string{\"var\": \"remainder\"}},\n\t{\"wildcardMultipleParts\", \"/fixed/{var:*}\", \"/fixed/remain/der\", map[string]string{\"var\": \"remain/der\"}},\n\t{\"wildcardManyParts\", \"/fixed/{var:*}\", \"/fixed/test/sub/hi.html\", map[string]string{\"var\": \"test/sub/hi.html\"}},\n\t{\"wildcardInMiddle\", \"/fixed/{var:*}/morefixed\", \"/fixed/middle/stuff/morefixed\", map[string]string{\"var\": \"middle/stuff\"}},\n\t{\"wildcardFollowedByVar\", \"/fixed/{var:*}/morefixed/{otherVar}\", \"/fixed/middle/stuff/morefixed/end\", map[string]string{\"var\": \"middle/stuff\", \"otherVar\": \"end\"}},\n\t{\"singleParam\", \"/fixed/{var}\", \"/fixed/remainder\", map[string]string{\"var\": \"remainder\"}},\n\t{\"slash\", \"/\", \"/\", map[string]string{}},\n\t{\"NoVars\", \"/fixed\", \"/fixed\", map[string]string{}},\n\t{\"TwoVars\", \"/from/{source}/to/{destination}\", \"/from/LHR/to/AMS\", map[string]string{\"source\": \"LHR\", \"destination\": \"AMS\"}},\n\t{\"VarOnFront\", \"/{what}/from/{source}\", \"/who/from/SOS\", map[string]string{\"what\": \"who\", \"source\": \"SOS\"}},\n}\n\nfunc TestExtractParams(t *testing.T) {\n\tfor _, testCase := range extractParams {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tws1 := new(WebService).Path(\"/\")\n\t\t\tws1.Route(ws1.GET(testCase.routePath).To(dummy))\n\t\t\trouter := RouterJSR311{}\n\t\t\treq, _ := http.NewRequest(http.MethodGet, testCase.urlPath, nil)\n\t\t\tparams := router.ExtractParameters(&ws1.Routes()[0], ws1, req.URL.Path)\n\t\t\tif len(params) != len(testCase.expectedParams) {\n\t\t\t\tt.Fatalf(\"Wrong length of params on selected route, expected: %v, got: %v\", testCase.expectedParams, params)\n\t\t\t}\n\t\t\tfor expectedParamKey, expectedParamValue := range testCase.expectedParams {\n\t\t\t\tif expectedParamValue != params[expectedParamKey] {\n\t\t\t\t\tt.Errorf(\"Wrong parameter for key '%v', expected: %v, got: %v\", expectedParamKey, expectedParamValue, params[expectedParamKey])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSelectRouteInvalidMethod(t *testing.T) {\n\tws1 := new(WebService).Path(\"/\")\n\tws1.Route(ws1.GET(\"/simple\").To(dummy))\n\trouter := RouterJSR311{}\n\treq, _ := http.NewRequest(http.MethodPost, \"/simple\", nil)\n\t_, _, err := router.SelectRoute([]*WebService{ws1}, req)\n\tif err == nil {\n\t\tt.Fatal(\"Expected an error as the wrong method is used but was nil\")\n\t}\n}\n\nfunc TestParameterInWebService(t *testing.T) {\n\tfor _, testCase := range extractParams {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tws1 := new(WebService).Path(\"/{wsParam}\")\n\t\t\tws1.Route(ws1.GET(testCase.routePath).To(dummy))\n\t\t\trouter := RouterJSR311{}\n\t\t\treq, _ := http.NewRequest(http.MethodGet, \"/wsValue\"+testCase.urlPath, nil)\n\t\t\tparams := router.ExtractParameters(&ws1.Routes()[0], ws1, req.URL.Path)\n\t\t\texpectedParams := map[string]string{\"wsParam\": \"wsValue\"}\n\t\t\tfor key, value := range testCase.expectedParams {\n\t\t\t\texpectedParams[key] = value\n\t\t\t}\n\t\t\tif len(params) != len(expectedParams) {\n\t\t\t\tt.Fatalf(\"Wrong length of params on selected route, expected: %v, got: %v\", testCase.expectedParams, params)\n\t\t\t}\n\t\t\tfor expectedParamKey, expectedParamValue := range testCase.expectedParams {\n\t\t\t\tif expectedParamValue != params[expectedParamKey] {\n\t\t\t\t\tt.Errorf(\"Wrong parameter for key '%v', expected: %v, got: %v\", expectedParamKey, expectedParamValue, params[expectedParamKey])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc dummy(req *Request, resp *Response) { io.WriteString(resp.ResponseWriter, \"dummy\") }\n\nfunc gzippedDummy() []byte {\n\tvar buf bytes.Buffer\n\tzw := gzip.NewWriter(&buf)\n\tzw.Write([]byte(\"dummy\"))\n\tzw.Flush()\n\tzw.Close()\n\treturn buf.Bytes()\n}\n"
        },
        {
          "name": "log",
          "type": "tree",
          "content": null
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 0.90234375,
          "content": "package restful\n\n// Copyright 2014 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\nimport (\n\t\"github.com/emicklei/go-restful/v3/log\"\n)\n\nvar trace bool = false\nvar traceLogger log.StdLogger\n\nfunc init() {\n\ttraceLogger = log.Logger // use the package logger by default\n}\n\n// TraceLogger enables detailed logging of Http request matching and filter invocation. Default no logger is set.\n// You may call EnableTracing() directly to enable trace logging to the package-wide logger.\nfunc TraceLogger(logger log.StdLogger) {\n\ttraceLogger = logger\n\tEnableTracing(logger != nil)\n}\n\n// SetLogger exposes the setter for the global logger on the top-level package\nfunc SetLogger(customLogger log.StdLogger) {\n\tlog.SetLogger(customLogger)\n}\n\n// EnableTracing can be used to Trace logging on and off.\nfunc EnableTracing(enabled bool) {\n\ttrace = enabled\n}\n"
        },
        {
          "name": "mime.go",
          "type": "blob",
          "size": 1.4013671875,
          "content": "package restful\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype mime struct {\n\tmedia   string\n\tquality float64\n}\n\n// insertMime adds a mime to a list and keeps it sorted by quality.\nfunc insertMime(l []mime, e mime) []mime {\n\tfor i, each := range l {\n\t\t// if current mime has lower quality then insert before\n\t\tif e.quality > each.quality {\n\t\t\tleft := append([]mime{}, l[0:i]...)\n\t\t\treturn append(append(left, e), l[i:]...)\n\t\t}\n\t}\n\treturn append(l, e)\n}\n\nconst qFactorWeightingKey = \"q\"\n\n// sortedMimes returns a list of mime sorted (desc) by its specified quality.\n// e.g. text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\nfunc sortedMimes(accept string) (sorted []mime) {\n\tfor _, each := range strings.Split(accept, \",\") {\n\t\ttypeAndQuality := strings.Split(strings.Trim(each, \" \"), \";\")\n\t\tif len(typeAndQuality) == 1 {\n\t\t\tsorted = insertMime(sorted, mime{typeAndQuality[0], 1.0})\n\t\t} else {\n\t\t\t// take factor\n\t\t\tqAndWeight := strings.Split(typeAndQuality[1], \"=\")\n\t\t\tif len(qAndWeight) == 2 && strings.Trim(qAndWeight[0], \" \") == qFactorWeightingKey {\n\t\t\t\tf, err := strconv.ParseFloat(qAndWeight[1], 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\ttraceLogger.Printf(\"unable to parse quality in %s, %v\", each, err)\n\t\t\t\t} else {\n\t\t\t\t\tsorted = insertMime(sorted, mime{typeAndQuality[0], f})\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsorted = insertMime(sorted, mime{typeAndQuality[0], 1.0})\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n"
        },
        {
          "name": "mime_test.go",
          "type": "blob",
          "size": 0.744140625,
          "content": "package restful\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\n// go test -v -test.run TestSortMimes ...restful\nfunc TestSortMimes(t *testing.T) {\n\taccept := \"text/html; q=0.8, text/plain, image/gif,  */*; q=0.01, image/jpeg\"\n\tresult := sortedMimes(accept)\n\tgot := fmt.Sprintf(\"%v\", result)\n\twant := \"[{text/plain 1} {image/gif 1} {image/jpeg 1} {text/html 0.8} {*/* 0.01}]\"\n\tif got != want {\n\t\tt.Errorf(\"bad sort order of mime types:%s\", got)\n\t}\n}\n\nfunc TestNonNumberQualityInAccept_issue400(t *testing.T) {\n\taccept := `text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3`\n\tresult := sortedMimes(accept)\n\tif got, want := len(result), 7; got != want {\n\t\tt.Errorf(\"got %d want %d quality mimes\", got, want)\n\t}\n}\n"
        },
        {
          "name": "options_filter.go",
          "type": "blob",
          "size": 1.412109375,
          "content": "package restful\n\nimport \"strings\"\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\n// OPTIONSFilter is a filter function that inspects the Http Request for the OPTIONS method\n// and provides the response with a set of allowed methods for the request URL Path.\n// As for any filter, you can also install it for a particular WebService within a Container.\n// Note: this filter is not needed when using CrossOriginResourceSharing (for CORS).\nfunc (c *Container) OPTIONSFilter(req *Request, resp *Response, chain *FilterChain) {\n\tif \"OPTIONS\" != req.Request.Method {\n\t\tchain.ProcessFilter(req, resp)\n\t\treturn\n\t}\n\n\tarchs := req.Request.Header.Get(HEADER_AccessControlRequestHeaders)\n\tmethods := strings.Join(c.computeAllowedMethods(req), \",\")\n\torigin := req.Request.Header.Get(HEADER_Origin)\n\n\tresp.AddHeader(HEADER_Allow, methods)\n\tresp.AddHeader(HEADER_AccessControlAllowOrigin, origin)\n\tresp.AddHeader(HEADER_AccessControlAllowHeaders, archs)\n\tresp.AddHeader(HEADER_AccessControlAllowMethods, methods)\n}\n\n// OPTIONSFilter is a filter function that inspects the Http Request for the OPTIONS method\n// and provides the response with a set of allowed methods for the request URL Path.\n// Note: this filter is not needed when using CrossOriginResourceSharing (for CORS).\nfunc OPTIONSFilter() FilterFunction {\n\treturn DefaultContainer.OPTIONSFilter\n}\n"
        },
        {
          "name": "options_filter_test.go",
          "type": "blob",
          "size": 0.9365234375,
          "content": "package restful\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\n// go test -v -test.run TestOptionsFilter ...restful\nfunc TestOptionsFilter(t *testing.T) {\n\ttearDown()\n\tws := new(WebService)\n\tws.Route(ws.GET(\"/candy/{kind}\").To(dummy))\n\tws.Route(ws.DELETE(\"/candy/{kind}\").To(dummy))\n\tws.Route(ws.POST(\"/candies\").To(dummy))\n\tAdd(ws)\n\tFilter(OPTIONSFilter())\n\n\thttpRequest, _ := http.NewRequest(\"OPTIONS\", \"http://here.io/candy/gum\", nil)\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tactual := httpWriter.Header().Get(HEADER_Allow)\n\tif \"GET,DELETE\" != actual {\n\t\tt.Fatal(\"expected: GET,DELETE but got:\" + actual)\n\t}\n\n\thttpRequest, _ = http.NewRequest(\"OPTIONS\", \"http://here.io/candies\", nil)\n\thttpWriter = httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tactual = httpWriter.Header().Get(HEADER_Allow)\n\tif \"POST\" != actual {\n\t\tt.Fatal(\"expected: POST but got:\" + actual)\n\t}\n}\n"
        },
        {
          "name": "parameter.go",
          "type": "blob",
          "size": 6.7041015625,
          "content": "package restful\n\nimport \"sort\"\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nconst (\n\t// PathParameterKind = indicator of Request parameter type \"path\"\n\tPathParameterKind = iota\n\n\t// QueryParameterKind = indicator of Request parameter type \"query\"\n\tQueryParameterKind\n\n\t// BodyParameterKind = indicator of Request parameter type \"body\"\n\tBodyParameterKind\n\n\t// HeaderParameterKind = indicator of Request parameter type \"header\"\n\tHeaderParameterKind\n\n\t// FormParameterKind = indicator of Request parameter type \"form\"\n\tFormParameterKind\n\n\t// MultiPartFormParameterKind = indicator of Request parameter type \"multipart/form-data\"\n\tMultiPartFormParameterKind\n\n\t// CollectionFormatCSV comma separated values `foo,bar`\n\tCollectionFormatCSV = CollectionFormat(\"csv\")\n\n\t// CollectionFormatSSV space separated values `foo bar`\n\tCollectionFormatSSV = CollectionFormat(\"ssv\")\n\n\t// CollectionFormatTSV tab separated values `foo\\tbar`\n\tCollectionFormatTSV = CollectionFormat(\"tsv\")\n\n\t// CollectionFormatPipes pipe separated values `foo|bar`\n\tCollectionFormatPipes = CollectionFormat(\"pipes\")\n\n\t// CollectionFormatMulti corresponds to multiple parameter instances instead of multiple values for a single\n\t// instance `foo=bar&foo=baz`. This is valid only for QueryParameters and FormParameters\n\tCollectionFormatMulti = CollectionFormat(\"multi\")\n)\n\ntype CollectionFormat string\n\nfunc (cf CollectionFormat) String() string {\n\treturn string(cf)\n}\n\n// Parameter is for documententing the parameter used in a Http Request\n// ParameterData kinds are Path,Query and Body\ntype Parameter struct {\n\tdata *ParameterData\n}\n\n// ParameterData represents the state of a Parameter.\n// It is made public to make it accessible to e.g. the Swagger package.\ntype ParameterData struct {\n\tExtensionProperties\n\tName, Description, DataType, DataFormat string\n\tKind                                    int\n\tRequired                                bool\n\t// AllowableValues is deprecated. Use PossibleValues instead\n\tAllowableValues  map[string]string\n\tPossibleValues   []string\n\tAllowMultiple    bool\n\tAllowEmptyValue  bool\n\tDefaultValue     string\n\tCollectionFormat string\n\tPattern          string\n\tMinimum          *float64\n\tMaximum          *float64\n\tMinLength        *int64\n\tMaxLength        *int64\n\tMinItems         *int64\n\tMaxItems         *int64\n\tUniqueItems      bool\n}\n\n// Data returns the state of the Parameter\nfunc (p *Parameter) Data() ParameterData {\n\treturn *p.data\n}\n\n// Kind returns the parameter type indicator (see const for valid values)\nfunc (p *Parameter) Kind() int {\n\treturn p.data.Kind\n}\n\nfunc (p *Parameter) bePath() *Parameter {\n\tp.data.Kind = PathParameterKind\n\treturn p\n}\nfunc (p *Parameter) beQuery() *Parameter {\n\tp.data.Kind = QueryParameterKind\n\treturn p\n}\nfunc (p *Parameter) beBody() *Parameter {\n\tp.data.Kind = BodyParameterKind\n\treturn p\n}\n\nfunc (p *Parameter) beHeader() *Parameter {\n\tp.data.Kind = HeaderParameterKind\n\treturn p\n}\n\nfunc (p *Parameter) beForm() *Parameter {\n\tp.data.Kind = FormParameterKind\n\treturn p\n}\n\nfunc (p *Parameter) beMultiPartForm() *Parameter {\n\tp.data.Kind = MultiPartFormParameterKind\n\treturn p\n}\n\n// Required sets the required field and returns the receiver\nfunc (p *Parameter) Required(required bool) *Parameter {\n\tp.data.Required = required\n\treturn p\n}\n\n// AllowMultiple sets the allowMultiple field and returns the receiver\nfunc (p *Parameter) AllowMultiple(multiple bool) *Parameter {\n\tp.data.AllowMultiple = multiple\n\treturn p\n}\n\n// AddExtension adds or updates a key=value pair to the extension map\nfunc (p *Parameter) AddExtension(key string, value interface{}) *Parameter {\n\tp.data.AddExtension(key, value)\n\treturn p\n}\n\n// AllowEmptyValue sets the AllowEmptyValue field and returns the receiver\nfunc (p *Parameter) AllowEmptyValue(multiple bool) *Parameter {\n\tp.data.AllowEmptyValue = multiple\n\treturn p\n}\n\n// AllowableValues is deprecated. Use PossibleValues instead. Both will be set.\nfunc (p *Parameter) AllowableValues(values map[string]string) *Parameter {\n\tp.data.AllowableValues = values\n\n\tallowableSortedKeys := make([]string, 0, len(values))\n\tfor k := range values {\n\t\tallowableSortedKeys = append(allowableSortedKeys, k)\n\t}\n\tsort.Strings(allowableSortedKeys)\n\n\tp.data.PossibleValues = make([]string, 0, len(values))\n\tfor _, k := range allowableSortedKeys {\n\t\tp.data.PossibleValues = append(p.data.PossibleValues, values[k])\n\t}\n\treturn p\n}\n\n// PossibleValues sets the possible values field and returns the receiver\nfunc (p *Parameter) PossibleValues(values []string) *Parameter {\n\tp.data.PossibleValues = values\n\treturn p\n}\n\n// DataType sets the dataType field and returns the receiver\nfunc (p *Parameter) DataType(typeName string) *Parameter {\n\tp.data.DataType = typeName\n\treturn p\n}\n\n// DataFormat sets the dataFormat field for Swagger UI\nfunc (p *Parameter) DataFormat(formatName string) *Parameter {\n\tp.data.DataFormat = formatName\n\treturn p\n}\n\n// DefaultValue sets the default value field and returns the receiver\nfunc (p *Parameter) DefaultValue(stringRepresentation string) *Parameter {\n\tp.data.DefaultValue = stringRepresentation\n\treturn p\n}\n\n// Description sets the description value field and returns the receiver\nfunc (p *Parameter) Description(doc string) *Parameter {\n\tp.data.Description = doc\n\treturn p\n}\n\n// CollectionFormat sets the collection format for an array type\nfunc (p *Parameter) CollectionFormat(format CollectionFormat) *Parameter {\n\tp.data.CollectionFormat = format.String()\n\treturn p\n}\n\n// Pattern sets the pattern field and returns the receiver\nfunc (p *Parameter) Pattern(pattern string) *Parameter {\n\tp.data.Pattern = pattern\n\treturn p\n}\n\n// Minimum sets the minimum field and returns the receiver\nfunc (p *Parameter) Minimum(minimum float64) *Parameter {\n\tp.data.Minimum = &minimum\n\treturn p\n}\n\n// Maximum sets the maximum field and returns the receiver\nfunc (p *Parameter) Maximum(maximum float64) *Parameter {\n\tp.data.Maximum = &maximum\n\treturn p\n}\n\n// MinLength sets the minLength field and returns the receiver\nfunc (p *Parameter) MinLength(minLength int64) *Parameter {\n\tp.data.MinLength = &minLength\n\treturn p\n}\n\n// MaxLength sets the maxLength field and returns the receiver\nfunc (p *Parameter) MaxLength(maxLength int64) *Parameter {\n\tp.data.MaxLength = &maxLength\n\treturn p\n}\n\n// MinItems sets the minItems field and returns the receiver\nfunc (p *Parameter) MinItems(minItems int64) *Parameter {\n\tp.data.MinItems = &minItems\n\treturn p\n}\n\n// MaxItems sets the maxItems field and returns the receiver\nfunc (p *Parameter) MaxItems(maxItems int64) *Parameter {\n\tp.data.MaxItems = &maxItems\n\treturn p\n}\n\n// UniqueItems sets the uniqueItems field and returns the receiver\nfunc (p *Parameter) UniqueItems(uniqueItems bool) *Parameter {\n\tp.data.UniqueItems = uniqueItems\n\treturn p\n}\n"
        },
        {
          "name": "path_expression.go",
          "type": "blob",
          "size": 2.515625,
          "content": "package restful\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"strings\"\n)\n\n// PathExpression holds a compiled path expression (RegExp) needed to match against\n// Http request paths and to extract path parameter values.\ntype pathExpression struct {\n\tLiteralCount int      // the number of literal characters (means those not resulting from template variable substitution)\n\tVarNames     []string // the names of parameters (enclosed by {}) in the path\n\tVarCount     int      // the number of named parameters (enclosed by {}) in the path\n\tMatcher      *regexp.Regexp\n\tSource       string // Path as defined by the RouteBuilder\n\ttokens       []string\n}\n\n// NewPathExpression creates a PathExpression from the input URL path.\n// Returns an error if the path is invalid.\nfunc newPathExpression(path string) (*pathExpression, error) {\n\texpression, literalCount, varNames, varCount, tokens := templateToRegularExpression(path)\n\tcompiled, err := regexp.Compile(expression)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &pathExpression{literalCount, varNames, varCount, compiled, expression, tokens}, nil\n}\n\n// http://jsr311.java.net/nonav/releases/1.1/spec/spec3.html#x3-370003.7.3\nfunc templateToRegularExpression(template string) (expression string, literalCount int, varNames []string, varCount int, tokens []string) {\n\tvar buffer bytes.Buffer\n\tbuffer.WriteString(\"^\")\n\t//tokens = strings.Split(template, \"/\")\n\ttokens = tokenizePath(template)\n\tfor _, each := range tokens {\n\t\tif each == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tbuffer.WriteString(\"/\")\n\t\tif strings.HasPrefix(each, \"{\") {\n\t\t\t// check for regular expression in variable\n\t\t\tcolon := strings.Index(each, \":\")\n\t\t\tvar varName string\n\t\t\tif colon != -1 {\n\t\t\t\t// extract expression\n\t\t\t\tvarName = strings.TrimSpace(each[1:colon])\n\t\t\t\tparamExpr := strings.TrimSpace(each[colon+1 : len(each)-1])\n\t\t\t\tif paramExpr == \"*\" { // special case\n\t\t\t\t\tbuffer.WriteString(\"(.*)\")\n\t\t\t\t} else {\n\t\t\t\t\tbuffer.WriteString(fmt.Sprintf(\"(%s)\", paramExpr)) // between colon and closing moustache\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// plain var\n\t\t\t\tvarName = strings.TrimSpace(each[1 : len(each)-1])\n\t\t\t\tbuffer.WriteString(\"([^/]+?)\")\n\t\t\t}\n\t\t\tvarNames = append(varNames, varName)\n\t\t\tvarCount += 1\n\t\t} else {\n\t\t\tliteralCount += len(each)\n\t\t\tencoded := each // TODO URI encode\n\t\t\tbuffer.WriteString(regexp.QuoteMeta(encoded))\n\t\t}\n\t}\n\treturn strings.TrimRight(buffer.String(), \"/\") + \"(/.*)?$\", literalCount, varNames, varCount, tokens\n}\n"
        },
        {
          "name": "path_expression_test.go",
          "type": "blob",
          "size": 1.427734375,
          "content": "package restful\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nvar tempregexs = []struct {\n\ttemplate, regex        string\n\tnames                  []string\n\tliteralCount, varCount int\n}{\n\t{\"\", \"^(/.*)?$\", nil, 0, 0},\n\t{\"/a/{b}/c/\", \"^/a/([^/]+?)/c(/.*)?$\", []string{\"b\"}, 2, 1},\n\t{\"/{a}/{b}/{c-d-e}/\", \"^/([^/]+?)/([^/]+?)/([^/]+?)(/.*)?$\", []string{\"a\", \"b\", \"c-d-e\"}, 0, 3},\n\t{\"/{p}/abcde\", \"^/([^/]+?)/abcde(/.*)?$\", []string{\"p\"}, 5, 1},\n\t{\"/a/{b:*}\", \"^/a/(.*)(/.*)?$\", []string{\"b\"}, 1, 1},\n\t{\"/a/{b:[a-z]+}\", \"^/a/([a-z]+)(/.*)?$\", []string{\"b\"}, 1, 1},\n}\n\nfunc TestTemplateToRegularExpression(t *testing.T) {\n\tok := true\n\tfor i, fixture := range tempregexs {\n\t\tactual, lCount, varNames, vCount, _ := templateToRegularExpression(fixture.template)\n\t\tif actual != fixture.regex {\n\t\t\tt.Logf(\"regex mismatch, expected:%v , actual:%v, line:%v\\n\", fixture.regex, actual, i) // 11 = where the data starts\n\t\t\tok = false\n\t\t}\n\t\tif lCount != fixture.literalCount {\n\t\t\tt.Logf(\"literal count mismatch, expected:%v , actual:%v, line:%v\\n\", fixture.literalCount, lCount, i)\n\t\t\tok = false\n\t\t}\n\t\tif vCount != fixture.varCount {\n\t\t\tt.Logf(\"variable count mismatch, expected:%v , actual:%v, line:%v\\n\", fixture.varCount, vCount, i)\n\t\t\tok = false\n\t\t}\n\t\tif !reflect.DeepEqual(fixture.names, varNames) {\n\t\t\tt.Logf(\"variable name mismatch, expected:%v , actual:%v, line:%v\\n\", fixture.names, varNames, i)\n\t\t\tok = false\n\t\t}\n\t}\n\tif !ok {\n\t\tt.Fatal(\"one or more expression did not match\")\n\t}\n}\n"
        },
        {
          "name": "path_processor.go",
          "type": "blob",
          "size": 2.095703125,
          "content": "package restful\n\nimport (\n\t\"bytes\"\n\t\"strings\"\n)\n\n// Copyright 2018 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\n// PathProcessor is extra behaviour that a Router can provide to extract path parameters from the path.\n// If a Router does not implement this interface then the default behaviour will be used.\ntype PathProcessor interface {\n\t// ExtractParameters gets the path parameters defined in the route and webService from the urlPath\n\tExtractParameters(route *Route, webService *WebService, urlPath string) map[string]string\n}\n\ntype defaultPathProcessor struct{}\n\n// Extract the parameters from the request url path\nfunc (d defaultPathProcessor) ExtractParameters(r *Route, _ *WebService, urlPath string) map[string]string {\n\turlParts := tokenizePath(urlPath)\n\tpathParameters := map[string]string{}\n\tfor i, key := range r.pathParts {\n\t\tvar value string\n\t\tif i >= len(urlParts) {\n\t\t\tvalue = \"\"\n\t\t} else {\n\t\t\tvalue = urlParts[i]\n\t\t}\n\t\tif r.hasCustomVerb && hasCustomVerb(key) {\n\t\t\tkey = removeCustomVerb(key)\n\t\t\tvalue = removeCustomVerb(value)\n\t\t}\n\n\t\tif strings.Index(key, \"{\") > -1 { // path-parameter\n\t\t\tif colon := strings.Index(key, \":\"); colon != -1 {\n\t\t\t\t// extract by regex\n\t\t\t\tregPart := key[colon+1 : len(key)-1]\n\t\t\t\tkeyPart := key[1:colon]\n\t\t\t\tif regPart == \"*\" {\n\t\t\t\t\tpathParameters[keyPart] = untokenizePath(i, urlParts)\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\tpathParameters[keyPart] = value\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// without enclosing {}\n\t\t\t\tstartIndex := strings.Index(key, \"{\")\n\t\t\t\tendKeyIndex := strings.Index(key, \"}\")\n\n\t\t\t\tsuffixLength := len(key) - endKeyIndex - 1\n\t\t\t\tendValueIndex := len(value) - suffixLength\n\n\t\t\t\tpathParameters[key[startIndex+1:endKeyIndex]] = value[startIndex:endValueIndex]\n\t\t\t}\n\t\t}\n\t}\n\treturn pathParameters\n}\n\n// Untokenize back into an URL path using the slash separator\nfunc untokenizePath(offset int, parts []string) string {\n\tvar buffer bytes.Buffer\n\tfor p := offset; p < len(parts); p++ {\n\t\tbuffer.WriteString(parts[p])\n\t\t// do not end\n\t\tif p < len(parts)-1 {\n\t\t\tbuffer.WriteString(\"/\")\n\t\t}\n\t}\n\treturn buffer.String()\n}\n"
        },
        {
          "name": "path_processor_test.go",
          "type": "blob",
          "size": 3.2890625,
          "content": "package restful\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMatchesPath_OneParam(t *testing.T) {\n\tparams := doExtractParams(\"/from/{source}\", 2, \"/from/here\", t)\n\tif params[\"source\"] != \"here\" {\n\t\tt.Errorf(\"parameter mismatch here\")\n\t}\n}\n\nfunc TestMatchesPath_Slash(t *testing.T) {\n\tparams := doExtractParams(\"/\", 0, \"/\", t)\n\tif len(params) != 0 {\n\t\tt.Errorf(\"expected empty parameters\")\n\t}\n}\n\nfunc TestMatchesPath_SlashNonVar(t *testing.T) {\n\tparams := doExtractParams(\"/any\", 1, \"/any\", t)\n\tif len(params) != 0 {\n\t\tt.Errorf(\"expected empty parameters\")\n\t}\n}\n\nfunc TestMatchesPath_TwoVars(t *testing.T) {\n\tparams := doExtractParams(\"/from/{source}/to/{destination}\", 4, \"/from/AMS/to/NY\", t)\n\tif params[\"source\"] != \"AMS\" {\n\t\tt.Errorf(\"parameter mismatch AMS\")\n\t}\n}\n\nfunc TestMatchesPath_VarOnFront(t *testing.T) {\n\tparams := doExtractParams(\"{what}/from/{source}/\", 3, \"who/from/SOS/\", t)\n\tif params[\"source\"] != \"SOS\" {\n\t\tt.Errorf(\"parameter mismatch SOS\")\n\t}\n}\n\nfunc TestMatchesPath_VarOnFront_KeepSlash(t *testing.T) {\n\tTrimRightSlashEnabled = false\n\tparams := doExtractParams(\"{what}/from/{source}/\", 4, \"who/from/SOS/\", t)\n\tif params[\"source\"] != \"SOS\" {\n\t\tt.Errorf(\"parameter mismatch SOS\")\n\t}\n}\n\nfunc TestExtractParameters_EmptyValue(t *testing.T) {\n\tparams := doExtractParams(\"/fixed/{var}\", 2, \"/fixed/\", t)\n\tif params[\"var\"] != \"\" {\n\t\tt.Errorf(\"parameter mismatch var\")\n\t}\n}\n\nfunc TestExtractParameters_Dot(t *testing.T) {\n\tparams := doExtractParams(\"/fixed/{var}.foo\", 2, \"/fixed/barrr.foo\", t)\n\tif params[\"var\"] != \"barrr\" {\n\t\tt.Errorf(\"parameter mismatch var\")\n\t}\n}\n\nfunc TestExtractParameters_Prefix(t *testing.T) {\n\tparams := doExtractParams(\"/fixed/foo_{var}\", 2, \"/fixed/foo_barrr\", t)\n\tif params[\"var\"] != \"barrr\" {\n\t\tt.Errorf(\"parameter mismatch var\")\n\t}\n}\n\nfunc TestExtractParameters_Suffix(t *testing.T) {\n\tparams := doExtractParams(\"/fixed/{var}_foo\", 2, \"/fixed/barrr_foo\", t)\n\tif params[\"var\"] != \"barrr\" {\n\t\tt.Errorf(\"parameter mismatch var\")\n\t}\n}\n\nfunc TestExtractParameters_Mixed(t *testing.T) {\n\tparams := doExtractParams(\"/fixed/foo_{var}_bar\", 2, \"/fixed/foo_barrr_bar\", t)\n\tif params[\"var\"] != \"barrr\" {\n\t\tt.Errorf(\"parameter mismatch var\")\n\t}\n}\n\nfunc TestExtractParameters_RegexAndCustomVerb(t *testing.T) {\n\ttestCase := []struct {\n\t\troute     string\n\t\tsize      int\n\t\tpath      string\n\t\tcheckList map[string]string\n\t}{\n\t\t{\"/projects/{projectId}/users/{id:^prefix-}:custom\", 4, \"/projects/110/users/prefix-userId:custom\", map[string]string{\n\t\t\t\"projectId\": \"110\",\n\t\t\t\"id\":        \"prefix-userId\"}},\n\t\t{\"/projects/{projectId}/users/{id:*}\", 4, \"/projects/110/users/prefix-userId:custom\", map[string]string{\n\t\t\t\"projectId\": \"110\",\n\t\t\t\"id\":        \"prefix-userId:custom\"}},\n\t}\n\n\tfor idx, v := range testCase {\n\t\tparams := doExtractParams(v.route, v.size, v.path, t)\n\t\tfor k, val := range v.checkList {\n\t\t\tif params[k] != val {\n\t\t\t\tt.Errorf(\"[%v] params: %v mismatch, expected: %v, actual: %v\", idx, k, v.checkList[k], params[k])\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc doExtractParams(routePath string, size int, urlPath string, t *testing.T) map[string]string {\n\tr := Route{Path: routePath}\n\tr.postBuild()\n\tif len(r.pathParts) != size {\n\t\tfor i, each := range r.pathParts {\n\t\t\tt.Logf(\"%d:%q\", i, each)\n\t\t}\n\t\tt.Fatalf(\"len not %v, but %v\", size, len(r.pathParts))\n\t}\n\tpathProcessor := defaultPathProcessor{}\n\treturn pathProcessor.ExtractParameters(&r, nil, urlPath)\n}\n"
        },
        {
          "name": "request.go",
          "type": "blob",
          "size": 4.2421875,
          "content": "package restful\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport (\n\t\"compress/zlib\"\n\t\"net/http\"\n)\n\nvar defaultRequestContentType string\n\n// Request is a wrapper for a http Request that provides convenience methods\ntype Request struct {\n\tRequest        *http.Request\n\tpathParameters map[string]string\n\tattributes     map[string]interface{} // for storing request-scoped values\n\tselectedRoute  *Route                 // is nil when no route was matched\n}\n\nfunc NewRequest(httpRequest *http.Request) *Request {\n\treturn &Request{\n\t\tRequest:        httpRequest,\n\t\tpathParameters: map[string]string{},\n\t\tattributes:     map[string]interface{}{},\n\t} // empty parameters, attributes\n}\n\n// If ContentType is missing or */* is given then fall back to this type, otherwise\n// a \"Unable to unmarshal content of type:\" response is returned.\n// Valid values are restful.MIME_JSON and restful.MIME_XML\n// Example:\n//\n//\trestful.DefaultRequestContentType(restful.MIME_JSON)\nfunc DefaultRequestContentType(mime string) {\n\tdefaultRequestContentType = mime\n}\n\n// PathParameter accesses the Path parameter value by its name\nfunc (r *Request) PathParameter(name string) string {\n\treturn r.pathParameters[name]\n}\n\n// PathParameters accesses the Path parameter values\nfunc (r *Request) PathParameters() map[string]string {\n\treturn r.pathParameters\n}\n\n// QueryParameter returns the (first) Query parameter value by its name\nfunc (r *Request) QueryParameter(name string) string {\n\treturn r.Request.URL.Query().Get(name)\n}\n\n// QueryParameters returns the all the query parameters values by name\nfunc (r *Request) QueryParameters(name string) []string {\n\treturn r.Request.URL.Query()[name]\n}\n\n// BodyParameter parses the body of the request (once for typically a POST or a PUT) and returns the value of the given name or an error.\nfunc (r *Request) BodyParameter(name string) (string, error) {\n\terr := r.Request.ParseForm()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn r.Request.PostFormValue(name), nil\n}\n\n// HeaderParameter returns the HTTP Header value of a Header name or empty if missing\nfunc (r *Request) HeaderParameter(name string) string {\n\treturn r.Request.Header.Get(name)\n}\n\n// ReadEntity checks the Accept header and reads the content into the entityPointer.\nfunc (r *Request) ReadEntity(entityPointer interface{}) (err error) {\n\tcontentType := r.Request.Header.Get(HEADER_ContentType)\n\tcontentEncoding := r.Request.Header.Get(HEADER_ContentEncoding)\n\n\t// check if the request body needs decompression\n\tif ENCODING_GZIP == contentEncoding {\n\t\tgzipReader := currentCompressorProvider.AcquireGzipReader()\n\t\tdefer currentCompressorProvider.ReleaseGzipReader(gzipReader)\n\t\tgzipReader.Reset(r.Request.Body)\n\t\tr.Request.Body = gzipReader\n\t} else if ENCODING_DEFLATE == contentEncoding {\n\t\tzlibReader, err := zlib.NewReader(r.Request.Body)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tr.Request.Body = zlibReader\n\t}\n\n\t// lookup the EntityReader, use defaultRequestContentType if needed and provided\n\tentityReader, ok := entityAccessRegistry.accessorAt(contentType)\n\tif !ok {\n\t\tif len(defaultRequestContentType) != 0 {\n\t\t\tentityReader, ok = entityAccessRegistry.accessorAt(defaultRequestContentType)\n\t\t}\n\t\tif !ok {\n\t\t\treturn NewError(http.StatusBadRequest, \"Unable to unmarshal content of type:\"+contentType)\n\t\t}\n\t}\n\treturn entityReader.Read(r, entityPointer)\n}\n\n// SetAttribute adds or replaces the attribute with the given value.\nfunc (r *Request) SetAttribute(name string, value interface{}) {\n\tr.attributes[name] = value\n}\n\n// Attribute returns the value associated to the given name. Returns nil if absent.\nfunc (r Request) Attribute(name string) interface{} {\n\treturn r.attributes[name]\n}\n\n// SelectedRoutePath root path + route path that matched the request, e.g. /meetings/{id}/attendees\n// If no route was matched then return an empty string.\nfunc (r Request) SelectedRoutePath() string {\n\tif r.selectedRoute == nil {\n\t\treturn \"\"\n\t}\n\t// skip creating an accessor\n\treturn r.selectedRoute.Path\n}\n\n// SelectedRoute returns a reader to access the selected Route by the container\n// Returns nil if no route was matched.\nfunc (r Request) SelectedRoute() RouteReader {\n\tif r.selectedRoute == nil {\n\t\treturn nil\n\t}\n\treturn routeAccessor{route: r.selectedRoute}\n}\n"
        },
        {
          "name": "request_test.go",
          "type": "blob",
          "size": 4.2470703125,
          "content": "package restful\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestQueryParameter(t *testing.T) {\n\threq := http.Request{Method: \"GET\"}\n\threq.URL, _ = url.Parse(\"http://www.google.com/search?q=foo&q=bar\")\n\trreq := Request{Request: &hreq}\n\tif rreq.QueryParameter(\"q\") != \"foo\" {\n\t\tt.Errorf(\"q!=foo %#v\", rreq)\n\t}\n}\n\nfunc TestQueryParameters(t *testing.T) {\n\threq := http.Request{Method: \"GET\"}\n\threq.URL, _ = url.Parse(\"http://www.google.com/search?q=foo&q=bar\")\n\trreq := Request{Request: &hreq}\n\tparameters := rreq.QueryParameters(\"q\")\n\tif len(parameters) != 2 {\n\t\tt.Fatalf(\"len(q)!=2 %#v\", rreq)\n\t} else {\n\t\tif parameters[0] != \"foo\" || parameters[1] != \"bar\" {\n\t\t\tt.Fatalf(\"invalid content: required [\\\"foo\\\" \\\"bar\\\", got: %#v\", parameters)\n\t\t}\n\t}\n}\n\ntype Anything map[string]interface{}\n\ntype Number struct {\n\tValueFloat float64\n\tValueInt   int64\n}\n\ntype Sample struct {\n\tValue string\n}\n\nfunc TestReadEntityJson(t *testing.T) {\n\tbodyReader := strings.NewReader(`{\"Value\" : \"42\"}`)\n\thttpRequest, _ := http.NewRequest(\"GET\", \"/test\", bodyReader)\n\thttpRequest.Header.Set(\"Content-Type\", \"application/json\")\n\trequest := &Request{Request: httpRequest}\n\tsam := new(Sample)\n\trequest.ReadEntity(sam)\n\tif sam.Value != \"42\" {\n\t\tt.Fatal(\"read failed\")\n\t}\n}\n\nfunc TestReadEntityJsonCharset(t *testing.T) {\n\tbodyReader := strings.NewReader(`{\"Value\" : \"42\"}`)\n\thttpRequest, _ := http.NewRequest(\"GET\", \"/test\", bodyReader)\n\thttpRequest.Header.Set(\"Content-Type\", \"application/json; charset=UTF-8\")\n\trequest := NewRequest(httpRequest)\n\tsam := new(Sample)\n\trequest.ReadEntity(sam)\n\tif sam.Value != \"42\" {\n\t\tt.Fatal(\"read failed\")\n\t}\n}\n\nfunc TestReadEntityJsonNumber(t *testing.T) {\n\tbodyReader := strings.NewReader(`{\"Value\" : 4899710515899924123}`)\n\thttpRequest, _ := http.NewRequest(\"GET\", \"/test\", bodyReader)\n\thttpRequest.Header.Set(\"Content-Type\", \"application/json\")\n\trequest := &Request{Request: httpRequest}\n\tany := make(Anything)\n\trequest.ReadEntity(&any)\n\tnumber, ok := any[\"Value\"].(json.Number)\n\tif !ok {\n\t\tt.Fatal(\"read failed\")\n\t}\n\tvint, err := number.Int64()\n\tif err != nil {\n\t\tt.Fatal(\"convert failed\")\n\t}\n\tif vint != 4899710515899924123 {\n\t\tt.Fatal(\"read failed\")\n\t}\n\tvfloat, err := number.Float64()\n\tif err != nil {\n\t\tt.Fatal(\"convert failed\")\n\t}\n\t// match the default behaviour\n\tvstring := strconv.FormatFloat(vfloat, 'e', 15, 64)\n\tif vstring != \"4.899710515899924e+18\" {\n\t\tt.Fatal(\"convert float64 failed\")\n\t}\n}\n\nfunc TestReadEntityJsonLong(t *testing.T) {\n\tbodyReader := strings.NewReader(`{\"ValueFloat\" : 4899710515899924123, \"ValueInt\": 4899710515899924123}`)\n\thttpRequest, _ := http.NewRequest(\"GET\", \"/test\", bodyReader)\n\thttpRequest.Header.Set(\"Content-Type\", \"application/json\")\n\trequest := &Request{Request: httpRequest}\n\tnumber := new(Number)\n\trequest.ReadEntity(&number)\n\tif number.ValueInt != 4899710515899924123 {\n\t\tt.Fatal(\"read failed\")\n\t}\n\t// match the default behaviour\n\tvstring := strconv.FormatFloat(number.ValueFloat, 'e', 15, 64)\n\tif vstring != \"4.899710515899924e+18\" {\n\t\tt.Fatal(\"convert float64 failed\")\n\t}\n}\n\nfunc TestBodyParameter(t *testing.T) {\n\tbodyReader := strings.NewReader(`value1=42&value2=43`)\n\thttpRequest, _ := http.NewRequest(\"POST\", \"/test?value1=44\", bodyReader) // POST and PUT body parameters take precedence over URL query string\n\thttpRequest.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded; charset=UTF-8\")\n\trequest := NewRequest(httpRequest)\n\tv1, err := request.BodyParameter(\"value1\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tv2, err := request.BodyParameter(\"value2\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif v1 != \"42\" || v2 != \"43\" {\n\t\tt.Fatal(\"read failed\")\n\t}\n}\n\nfunc TestReadEntityUnkown(t *testing.T) {\n\tbodyReader := strings.NewReader(\"?\")\n\thttpRequest, _ := http.NewRequest(\"GET\", \"/test\", bodyReader)\n\thttpRequest.Header.Set(\"Content-Type\", \"application/rubbish\")\n\trequest := NewRequest(httpRequest)\n\tsam := new(Sample)\n\terr := request.ReadEntity(sam)\n\tif err == nil {\n\t\tt.Fatal(\"read should be in error\")\n\t}\n}\n\nfunc TestSetAttribute(t *testing.T) {\n\tbodyReader := strings.NewReader(\"?\")\n\thttpRequest, _ := http.NewRequest(\"GET\", \"/test\", bodyReader)\n\trequest := NewRequest(httpRequest)\n\trequest.SetAttribute(\"go\", \"there\")\n\tthere := request.Attribute(\"go\")\n\tif there != \"there\" {\n\t\tt.Fatalf(\"missing request attribute:%v\", there)\n\t}\n}\n"
        },
        {
          "name": "response.go",
          "type": "blob",
          "size": 10.1767578125,
          "content": "package restful\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"net\"\n\t\"net/http\"\n)\n\n// DefaultResponseMimeType is DEPRECATED, use DefaultResponseContentType(mime)\nvar DefaultResponseMimeType string\n\n//PrettyPrintResponses controls the indentation feature of XML and JSON serialization\nvar PrettyPrintResponses = true\n\n// Response is a wrapper on the actual http ResponseWriter\n// It provides several convenience methods to prepare and write response content.\ntype Response struct {\n\thttp.ResponseWriter\n\trequestAccept string        // mime-type what the Http Request says it wants to receive\n\trouteProduces []string      // mime-types what the Route says it can produce\n\tstatusCode    int           // HTTP status code that has been written explicitly (if zero then net/http has written 200)\n\tcontentLength int           // number of bytes written for the response body\n\tprettyPrint   bool          // controls the indentation feature of XML and JSON serialization. It is initialized using var PrettyPrintResponses.\n\terr           error         // err property is kept when WriteError is called\n\thijacker      http.Hijacker // if underlying ResponseWriter supports it\n}\n\n// NewResponse creates a new response based on a http ResponseWriter.\nfunc NewResponse(httpWriter http.ResponseWriter) *Response {\n\thijacker, _ := httpWriter.(http.Hijacker)\n\treturn &Response{ResponseWriter: httpWriter, routeProduces: []string{}, statusCode: http.StatusOK, prettyPrint: PrettyPrintResponses, hijacker: hijacker}\n}\n\n// DefaultResponseContentType set a default.\n// If Accept header matching fails, fall back to this type.\n// Valid values are restful.MIME_JSON and restful.MIME_XML\n// Example:\n// \trestful.DefaultResponseContentType(restful.MIME_JSON)\nfunc DefaultResponseContentType(mime string) {\n\tDefaultResponseMimeType = mime\n}\n\n// InternalServerError writes the StatusInternalServerError header.\n// DEPRECATED, use WriteErrorString(http.StatusInternalServerError,reason)\nfunc (r Response) InternalServerError() Response {\n\tr.WriteHeader(http.StatusInternalServerError)\n\treturn r\n}\n\n// Hijack implements the http.Hijacker interface.  This expands\n// the Response to fulfill http.Hijacker if the underlying\n// http.ResponseWriter supports it.\nfunc (r *Response) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\tif r.hijacker == nil {\n\t\treturn nil, nil, errors.New(\"http.Hijacker not implemented by underlying http.ResponseWriter\")\n\t}\n\treturn r.hijacker.Hijack()\n}\n\n// PrettyPrint changes whether this response must produce pretty (line-by-line, indented) JSON or XML output.\nfunc (r *Response) PrettyPrint(bePretty bool) {\n\tr.prettyPrint = bePretty\n}\n\n// AddHeader is a shortcut for .Header().Add(header,value)\nfunc (r Response) AddHeader(header string, value string) Response {\n\tr.Header().Add(header, value)\n\treturn r\n}\n\n// SetRequestAccepts tells the response what Mime-type(s) the HTTP request said it wants to accept. Exposed for testing.\nfunc (r *Response) SetRequestAccepts(mime string) {\n\tr.requestAccept = mime\n}\n\n// EntityWriter returns the registered EntityWriter that the entity (requested resource)\n// can write according to what the request wants (Accept) and what the Route can produce or what the restful defaults say.\n// If called before WriteEntity and WriteHeader then a false return value can be used to write a 406: Not Acceptable.\nfunc (r *Response) EntityWriter() (EntityReaderWriter, bool) {\n\tsorted := sortedMimes(r.requestAccept)\n\tfor _, eachAccept := range sorted {\n\t\tfor _, eachProduce := range r.routeProduces {\n\t\t\tif eachProduce == eachAccept.media {\n\t\t\t\tif w, ok := entityAccessRegistry.accessorAt(eachAccept.media); ok {\n\t\t\t\t\treturn w, true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif eachAccept.media == \"*/*\" {\n\t\t\tfor _, each := range r.routeProduces {\n\t\t\t\tif w, ok := entityAccessRegistry.accessorAt(each); ok {\n\t\t\t\t\treturn w, true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// if requestAccept is empty\n\twriter, ok := entityAccessRegistry.accessorAt(r.requestAccept)\n\tif !ok {\n\t\t// if not registered then fallback to the defaults (if set)\n\t\tif DefaultResponseMimeType == MIME_JSON {\n\t\t\treturn entityAccessRegistry.accessorAt(MIME_JSON)\n\t\t}\n\t\tif DefaultResponseMimeType == MIME_XML {\n\t\t\treturn entityAccessRegistry.accessorAt(MIME_XML)\n\t\t}\n\t\tif DefaultResponseMimeType == MIME_ZIP {\n\t\t\treturn entityAccessRegistry.accessorAt(MIME_ZIP)\n\t\t}\n\t\t// Fallback to whatever the route says it can produce.\n\t\t// https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\n\t\tfor _, each := range r.routeProduces {\n\t\t\tif w, ok := entityAccessRegistry.accessorAt(each); ok {\n\t\t\t\treturn w, true\n\t\t\t}\n\t\t}\n\t\tif trace {\n\t\t\ttraceLogger.Printf(\"no registered EntityReaderWriter found for %s\", r.requestAccept)\n\t\t}\n\t}\n\treturn writer, ok\n}\n\n// WriteEntity calls WriteHeaderAndEntity with Http Status OK (200)\nfunc (r *Response) WriteEntity(value interface{}) error {\n\treturn r.WriteHeaderAndEntity(http.StatusOK, value)\n}\n\n// WriteHeaderAndEntity marshals the value using the representation denoted by the Accept Header and the registered EntityWriters.\n// If no Accept header is specified (or */*) then respond with the Content-Type as specified by the first in the Route.Produces.\n// If an Accept header is specified then respond with the Content-Type as specified by the first in the Route.Produces that is matched with the Accept header.\n// If the value is nil then no response is send except for the Http status. You may want to call WriteHeader(http.StatusNotFound) instead.\n// If there is no writer available that can represent the value in the requested MIME type then Http Status NotAcceptable is written.\n// Current implementation ignores any q-parameters in the Accept Header.\n// Returns an error if the value could not be written on the response.\nfunc (r *Response) WriteHeaderAndEntity(status int, value interface{}) error {\n\twriter, ok := r.EntityWriter()\n\tif !ok {\n\t\tr.WriteHeader(http.StatusNotAcceptable)\n\t\treturn nil\n\t}\n\treturn writer.Write(r, status, value)\n}\n\n// WriteAsXml is a convenience method for writing a value in xml (requires Xml tags on the value)\n// It uses the standard encoding/xml package for marshalling the value ; not using a registered EntityReaderWriter.\nfunc (r *Response) WriteAsXml(value interface{}) error {\n\treturn writeXML(r, http.StatusOK, MIME_XML, value)\n}\n\n// WriteHeaderAndXml is a convenience method for writing a status and value in xml (requires Xml tags on the value)\n// It uses the standard encoding/xml package for marshalling the value ; not using a registered EntityReaderWriter.\nfunc (r *Response) WriteHeaderAndXml(status int, value interface{}) error {\n\treturn writeXML(r, status, MIME_XML, value)\n}\n\n// WriteAsJson is a convenience method for writing a value in json.\n// It uses the standard encoding/json package for marshalling the value ; not using a registered EntityReaderWriter.\nfunc (r *Response) WriteAsJson(value interface{}) error {\n\treturn writeJSON(r, http.StatusOK, MIME_JSON, value)\n}\n\n// WriteJson is a convenience method for writing a value in Json with a given Content-Type.\n// It uses the standard encoding/json package for marshalling the value ; not using a registered EntityReaderWriter.\nfunc (r *Response) WriteJson(value interface{}, contentType string) error {\n\treturn writeJSON(r, http.StatusOK, contentType, value)\n}\n\n// WriteHeaderAndJson is a convenience method for writing the status and a value in Json with a given Content-Type.\n// It uses the standard encoding/json package for marshalling the value ; not using a registered EntityReaderWriter.\nfunc (r *Response) WriteHeaderAndJson(status int, value interface{}, contentType string) error {\n\treturn writeJSON(r, status, contentType, value)\n}\n\n// WriteError writes the http status and the error string on the response. err can be nil.\n// Return an error if writing was not successful.\nfunc (r *Response) WriteError(httpStatus int, err error) (writeErr error) {\n\tr.err = err\n\tif err == nil {\n\t\twriteErr = r.WriteErrorString(httpStatus, \"\")\n\t} else {\n\t\twriteErr = r.WriteErrorString(httpStatus, err.Error())\n\t}\n\treturn writeErr\n}\n\n// WriteServiceError is a convenience method for a responding with a status and a ServiceError\nfunc (r *Response) WriteServiceError(httpStatus int, err ServiceError) error {\n\tr.err = err\n\treturn r.WriteHeaderAndEntity(httpStatus, err)\n}\n\n// WriteErrorString is a convenience method for an error status with the actual error\nfunc (r *Response) WriteErrorString(httpStatus int, errorReason string) error {\n\tif r.err == nil {\n\t\t// if not called from WriteError\n\t\tr.err = errors.New(errorReason)\n\t}\n\tr.WriteHeader(httpStatus)\n\tif _, err := r.Write([]byte(errorReason)); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Flush implements http.Flusher interface, which sends any buffered data to the client.\nfunc (r *Response) Flush() {\n\tif f, ok := r.ResponseWriter.(http.Flusher); ok {\n\t\tf.Flush()\n\t} else if trace {\n\t\ttraceLogger.Printf(\"ResponseWriter %v doesn't support Flush\", r)\n\t}\n}\n\n// WriteHeader is overridden to remember the Status Code that has been written.\n// Changes to the Header of the response have no effect after this.\nfunc (r *Response) WriteHeader(httpStatus int) {\n\tr.statusCode = httpStatus\n\tr.ResponseWriter.WriteHeader(httpStatus)\n}\n\n// StatusCode returns the code that has been written using WriteHeader.\nfunc (r Response) StatusCode() int {\n\tif 0 == r.statusCode {\n\t\t// no status code has been written yet; assume OK\n\t\treturn http.StatusOK\n\t}\n\treturn r.statusCode\n}\n\n// Write writes the data to the connection as part of an HTTP reply.\n// Write is part of http.ResponseWriter interface.\nfunc (r *Response) Write(bytes []byte) (int, error) {\n\twritten, err := r.ResponseWriter.Write(bytes)\n\tr.contentLength += written\n\treturn written, err\n}\n\n// ContentLength returns the number of bytes written for the response content.\n// Note that this value is only correct if all data is written through the Response using its Write* methods.\n// Data written directly using the underlying http.ResponseWriter is not accounted for.\nfunc (r Response) ContentLength() int {\n\treturn r.contentLength\n}\n\n// CloseNotify is part of http.CloseNotifier interface\nfunc (r Response) CloseNotify() <-chan bool {\n\treturn r.ResponseWriter.(http.CloseNotifier).CloseNotify()\n}\n\n// Error returns the err created by WriteError\nfunc (r Response) Error() error {\n\treturn r.err\n}\n"
        },
        {
          "name": "response_test.go",
          "type": "blob",
          "size": 8.3818359375,
          "content": "package restful\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestWriteHeader(t *testing.T) {\n\thttpWriter := httptest.NewRecorder()\n\tresp := Response{ResponseWriter: httpWriter, requestAccept: \"*/*\", routeProduces: []string{\"*/*\"}, prettyPrint: true}\n\tresp.WriteHeader(123)\n\tif resp.StatusCode() != 123 {\n\t\tt.Errorf(\"Unexpected status code:%d\", resp.StatusCode())\n\t}\n}\n\nfunc TestNoWriteHeader(t *testing.T) {\n\thttpWriter := httptest.NewRecorder()\n\tresp := Response{ResponseWriter: httpWriter, requestAccept: \"*/*\", routeProduces: []string{\"*/*\"}, prettyPrint: true}\n\tif resp.StatusCode() != http.StatusOK {\n\t\tt.Errorf(\"Unexpected status code:%d\", resp.StatusCode())\n\t}\n}\n\ntype food struct {\n\tKind string\n}\n\n// go test -v -test.run TestMeasureContentLengthXml ...restful\nfunc TestMeasureContentLengthXml(t *testing.T) {\n\thttpWriter := httptest.NewRecorder()\n\tresp := Response{ResponseWriter: httpWriter, requestAccept: \"*/*\", routeProduces: []string{\"*/*\"}, prettyPrint: true}\n\tresp.WriteAsXml(food{\"apple\"})\n\tif resp.ContentLength() != 76 {\n\t\tt.Errorf(\"Incorrect measured length:%d\", resp.ContentLength())\n\t}\n}\n\n// go test -v -test.run TestMeasureContentLengthJson ...restful\nfunc TestMeasureContentLengthJson(t *testing.T) {\n\thttpWriter := httptest.NewRecorder()\n\tresp := Response{ResponseWriter: httpWriter, requestAccept: \"*/*\", routeProduces: []string{\"*/*\"}, prettyPrint: true}\n\tresp.WriteAsJson(food{\"apple\"})\n\tif resp.ContentLength() != 20 {\n\t\tt.Errorf(\"Incorrect measured length:%d\", resp.ContentLength())\n\t}\n}\n\n// go test -v -test.run TestMeasureContentLengthJsonNotPretty ...restful\nfunc TestMeasureContentLengthJsonNotPretty(t *testing.T) {\n\thttpWriter := httptest.NewRecorder()\n\tresp := Response{ResponseWriter: httpWriter, requestAccept: \"*/*\", routeProduces: []string{\"*/*\"}}\n\tresp.WriteAsJson(food{\"apple\"})\n\tif resp.ContentLength() != 17 { // 16+1 using the Encoder directly yields another /n\n\t\tt.Errorf(\"Incorrect measured length:%d\", resp.ContentLength())\n\t}\n}\n\n// go test -v -test.run TestMeasureContentLengthWriteErrorString ...restful\nfunc TestMeasureContentLengthWriteErrorString(t *testing.T) {\n\thttpWriter := httptest.NewRecorder()\n\tresp := Response{ResponseWriter: httpWriter, requestAccept: \"*/*\", routeProduces: []string{\"*/*\"}, prettyPrint: true}\n\tresp.WriteErrorString(404, \"Invalid\")\n\tif resp.ContentLength() != len(\"Invalid\") {\n\t\tt.Errorf(\"Incorrect measured length:%d\", resp.ContentLength())\n\t}\n}\n\n// go test -v -test.run TestStatusIsPassedToResponse ...restful\nfunc TestStatusIsPassedToResponse(t *testing.T) {\n\tfor _, each := range []struct {\n\t\twrite, read int\n\t}{\n\t\t{write: 204, read: 204},\n\t\t{write: 304, read: 304},\n\t\t{write: 200, read: 200},\n\t\t{write: 400, read: 400},\n\t} {\n\t\thttpWriter := httptest.NewRecorder()\n\t\tresp := Response{ResponseWriter: httpWriter, requestAccept: \"*/*\", routeProduces: []string{\"*/*\"}, prettyPrint: true}\n\t\tresp.WriteHeader(each.write)\n\t\tif got, want := httpWriter.Code, each.read; got != want {\n\t\t\tt.Errorf(\"got %v want %v\", got, want)\n\t\t}\n\t}\n}\n\n// go test -v -test.run TestStatusCreatedAndContentTypeJson_Issue54 ...restful\nfunc TestStatusCreatedAndContentTypeJson_Issue54(t *testing.T) {\n\thttpWriter := httptest.NewRecorder()\n\tresp := Response{ResponseWriter: httpWriter, requestAccept: \"application/json\", routeProduces: []string{\"application/json\"}, prettyPrint: true}\n\tresp.WriteHeader(201)\n\tresp.WriteAsJson(food{\"Juicy\"})\n\tif httpWriter.HeaderMap.Get(\"Content-Type\") != \"application/json\" {\n\t\tt.Errorf(\"Expected content type json but got:%s\", httpWriter.HeaderMap.Get(\"Content-Type\"))\n\t}\n\tif httpWriter.Code != 201 {\n\t\tt.Errorf(\"Expected status 201 but got:%d\", httpWriter.Code)\n\t}\n}\n\ntype errorOnWriteRecorder struct {\n\t*httptest.ResponseRecorder\n}\n\nfunc (e errorOnWriteRecorder) Write(bytes []byte) (int, error) {\n\treturn 0, errors.New(\"fail\")\n}\n\n// go test -v -test.run TestLastWriteErrorCaught ...restful\nfunc TestLastWriteErrorCaught(t *testing.T) {\n\thttpWriter := errorOnWriteRecorder{httptest.NewRecorder()}\n\tresp := Response{ResponseWriter: httpWriter, requestAccept: \"application/json\", routeProduces: []string{\"application/json\"}, prettyPrint: true}\n\terr := resp.WriteAsJson(food{\"Juicy\"})\n\tif err.Error() != \"fail\" {\n\t\tt.Errorf(\"Unexpected error message:%v\", err)\n\t}\n}\n\n// go test -v -test.run TestAcceptStarStar_Issue83 ...restful\nfunc TestAcceptStarStar_Issue83(t *testing.T) {\n\thttpWriter := httptest.NewRecorder()\n\t//\t\t\t\t\t\t\t\tAccept\t\t\t\t\t\t\t\t\tProduces\n\tresp := Response{ResponseWriter: httpWriter, requestAccept: \"application/bogus,*/*;q=0.8\", routeProduces: []string{\"application/json\"}, prettyPrint: true}\n\tresp.WriteEntity(food{\"Juicy\"})\n\tct := httpWriter.Header().Get(\"Content-Type\")\n\tif \"application/json\" != ct {\n\t\tt.Errorf(\"Unexpected content type:%s\", ct)\n\t}\n}\n\n// go test -v -test.run TestAcceptSkipStarStar_Issue83 ...restful\nfunc TestAcceptSkipStarStar_Issue83(t *testing.T) {\n\thttpWriter := httptest.NewRecorder()\n\t//\t\t\t\t\t\t\t\tAccept\t\t\t\t\t\t\t\t\tProduces\n\tresp := Response{ResponseWriter: httpWriter, requestAccept: \" application/xml ,*/* ; q=0.8\", routeProduces: []string{\"application/json\", \"application/xml\"}, prettyPrint: true}\n\tresp.WriteEntity(food{\"Juicy\"})\n\tct := httpWriter.Header().Get(\"Content-Type\")\n\tif \"application/xml\" != ct {\n\t\tt.Errorf(\"Unexpected content type:%s\", ct)\n\t}\n}\n\n// go test -v -test.run TestAcceptXmlBeforeStarStar_Issue83 ...restful\nfunc TestAcceptXmlBeforeStarStar_Issue83(t *testing.T) {\n\thttpWriter := httptest.NewRecorder()\n\t//\t\t\t\t\t\t\t\tAccept\t\t\t\t\t\t\t\t\tProduces\n\tresp := Response{ResponseWriter: httpWriter, requestAccept: \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", routeProduces: []string{\"application/json\"}, prettyPrint: true}\n\tresp.WriteEntity(food{\"Juicy\"})\n\tct := httpWriter.Header().Get(\"Content-Type\")\n\tif \"application/json\" != ct {\n\t\tt.Errorf(\"Unexpected content type:%s\", ct)\n\t}\n}\n\n// go test -v -test.run TestWriteHeaderNoContent_Issue124 ...restful\nfunc TestWriteHeaderNoContent_Issue124(t *testing.T) {\n\thttpWriter := httptest.NewRecorder()\n\tresp := Response{ResponseWriter: httpWriter, requestAccept: \"text/plain\", routeProduces: []string{\"text/plain\"}, prettyPrint: true}\n\tresp.WriteHeader(http.StatusNoContent)\n\tif httpWriter.Code != http.StatusNoContent {\n\t\tt.Errorf(\"got %d want %d\", httpWriter.Code, http.StatusNoContent)\n\t}\n}\n\n// go test -v -test.run TestStatusCreatedAndContentTypeJson_Issue163 ...restful\nfunc TestStatusCreatedAndContentTypeJson_Issue163(t *testing.T) {\n\thttpWriter := httptest.NewRecorder()\n\tresp := Response{ResponseWriter: httpWriter, requestAccept: \"application/json\", routeProduces: []string{\"application/json\"}, prettyPrint: true}\n\tresp.WriteHeader(http.StatusNotModified)\n\tif httpWriter.Code != http.StatusNotModified {\n\t\tt.Errorf(\"Got %d want %d\", httpWriter.Code, http.StatusNotModified)\n\t}\n}\n\nfunc TestWriteHeaderAndEntity_Issue235(t *testing.T) {\n\thttpWriter := httptest.NewRecorder()\n\tresp := Response{ResponseWriter: httpWriter, requestAccept: \"application/json\", routeProduces: []string{\"application/json\"}, prettyPrint: true}\n\tvar pong = struct {\n\t\tFoo string `json:\"foo\"`\n\t}{Foo: \"123\"}\n\tresp.WriteHeaderAndEntity(404, pong)\n\tif httpWriter.Code != http.StatusNotFound {\n\t\tt.Errorf(\"got %d want %d\", httpWriter.Code, http.StatusNoContent)\n\t}\n\tif got, want := httpWriter.Header().Get(\"Content-Type\"), \"application/json\"; got != want {\n\t\tt.Errorf(\"got %v want %v\", got, want)\n\t}\n\tif !strings.HasPrefix(httpWriter.Body.String(), \"{\") {\n\t\tt.Errorf(\"expected pong struct in json:%s\", httpWriter.Body.String())\n\t}\n}\n\nfunc TestWriteEntityNoAcceptMatchWithProduces(t *testing.T) {\n\thttpWriter := httptest.NewRecorder()\n\tresp := Response{ResponseWriter: httpWriter, requestAccept: \"application/bogus\", routeProduces: []string{\"application/json\"}, prettyPrint: true}\n\tresp.WriteEntity(\"done\")\n\tif httpWriter.Code != http.StatusOK {\n\t\tt.Errorf(\"got %d want %d\", httpWriter.Code, http.StatusOK)\n\t}\n}\n\nfunc TestWriteEntityNoAcceptMatchNoProduces(t *testing.T) {\n\thttpWriter := httptest.NewRecorder()\n\tresp := Response{ResponseWriter: httpWriter, requestAccept: \"application/bogus\", routeProduces: []string{}, prettyPrint: true}\n\tresp.WriteEntity(\"done\")\n\tif httpWriter.Code != http.StatusNotAcceptable {\n\t\tt.Errorf(\"got %d want %d\", httpWriter.Code, http.StatusNotAcceptable)\n\t}\n}\n\nfunc TestWriteErrorWithNil(t *testing.T) {\n\thttpWriter := httptest.NewRecorder()\n\tresp := Response{ResponseWriter: httpWriter}\n\tresp.WriteError(http.StatusGone, nil)\n\tif httpWriter.Code != http.StatusGone {\n\t\tt.Errorf(\"got %d want %d\", httpWriter.Code, http.StatusGone)\n\t}\n}\n"
        },
        {
          "name": "route.go",
          "type": "blob",
          "size": 5.7490234375,
          "content": "package restful\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n)\n\n// RouteFunction declares the signature of a function that can be bound to a Route.\ntype RouteFunction func(*Request, *Response)\n\n// RouteSelectionConditionFunction declares the signature of a function that\n// can be used to add extra conditional logic when selecting whether the route\n// matches the HTTP request.\ntype RouteSelectionConditionFunction func(httpRequest *http.Request) bool\n\n// Route binds a HTTP Method,Path,Consumes combination to a RouteFunction.\ntype Route struct {\n\tExtensionProperties\n\tMethod   string\n\tProduces []string\n\tConsumes []string\n\tPath     string // webservice root path + described path\n\tFunction RouteFunction\n\tFilters  []FilterFunction\n\tIf       []RouteSelectionConditionFunction\n\n\t// cached values for dispatching\n\trelativePath string\n\tpathParts    []string\n\tpathExpr     *pathExpression // cached compilation of relativePath as RegExp\n\n\t// documentation\n\tDoc                     string\n\tNotes                   string\n\tOperation               string\n\tParameterDocs           []*Parameter\n\tResponseErrors          map[int]ResponseError\n\tDefaultResponse         *ResponseError\n\tReadSample, WriteSample interface{}   // structs that model an example request or response payload\n\tWriteSamples            []interface{} // if more than one return types is possible (oneof) then this will contain multiple values\n\n\t// Extra information used to store custom information about the route.\n\tMetadata map[string]interface{}\n\n\t// marks a route as deprecated\n\tDeprecated bool\n\n\t//Overrides the container.contentEncodingEnabled\n\tcontentEncodingEnabled *bool\n\n\t// indicate route path has custom verb\n\thasCustomVerb bool\n\n\t// if a request does not include a content-type header then\n\t// depending on the method, it may return a 415 Unsupported Media\n\t// Must have uppercase HTTP Method names such as GET,HEAD,OPTIONS,...\n\tallowedMethodsWithoutContentType []string\n}\n\n// Initialize for Route\nfunc (r *Route) postBuild() {\n\tr.pathParts = tokenizePath(r.Path)\n\tr.hasCustomVerb = hasCustomVerb(r.Path)\n}\n\n// Create Request and Response from their http versions\nfunc (r *Route) wrapRequestResponse(httpWriter http.ResponseWriter, httpRequest *http.Request, pathParams map[string]string) (*Request, *Response) {\n\twrappedRequest := NewRequest(httpRequest)\n\twrappedRequest.pathParameters = pathParams\n\twrappedRequest.selectedRoute = r\n\twrappedResponse := NewResponse(httpWriter)\n\twrappedResponse.requestAccept = httpRequest.Header.Get(HEADER_Accept)\n\twrappedResponse.routeProduces = r.Produces\n\treturn wrappedRequest, wrappedResponse\n}\n\nfunc stringTrimSpaceCutset(r rune) bool {\n\treturn r == ' '\n}\n\n// Return whether the mimeType matches to what this Route can produce.\nfunc (r Route) matchesAccept(mimeTypesWithQuality string) bool {\n\tremaining := mimeTypesWithQuality\n\tfor {\n\t\tvar mimeType string\n\t\tif end := strings.Index(remaining, \",\"); end == -1 {\n\t\t\tmimeType, remaining = remaining, \"\"\n\t\t} else {\n\t\t\tmimeType, remaining = remaining[:end], remaining[end+1:]\n\t\t}\n\t\tif quality := strings.Index(mimeType, \";\"); quality != -1 {\n\t\t\tmimeType = mimeType[:quality]\n\t\t}\n\t\tmimeType = strings.TrimFunc(mimeType, stringTrimSpaceCutset)\n\t\tif mimeType == \"*/*\" {\n\t\t\treturn true\n\t\t}\n\t\tfor _, producibleType := range r.Produces {\n\t\t\tif producibleType == \"*/*\" || producibleType == mimeType {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\tif len(remaining) == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n}\n\n// Return whether this Route can consume content with a type specified by mimeTypes (can be empty).\nfunc (r Route) matchesContentType(mimeTypes string) bool {\n\n\tif len(r.Consumes) == 0 {\n\t\t// did not specify what it can consume ;  any media type (“*/*”) is assumed\n\t\treturn true\n\t}\n\n\tif len(mimeTypes) == 0 {\n\t\t// idempotent methods with (most-likely or guaranteed) empty content match missing Content-Type\n\t\tm := r.Method\n\t\t// if route specifies less or non-idempotent methods then use that\n\t\tif len(r.allowedMethodsWithoutContentType) > 0 {\n\t\t\tfor _, each := range r.allowedMethodsWithoutContentType {\n\t\t\t\tif m == each {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif m == \"GET\" || m == \"HEAD\" || m == \"OPTIONS\" || m == \"DELETE\" || m == \"TRACE\" {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\t// proceed with default\n\t\tmimeTypes = MIME_OCTET\n\t}\n\n\tremaining := mimeTypes\n\tfor {\n\t\tvar mimeType string\n\t\tif end := strings.Index(remaining, \",\"); end == -1 {\n\t\t\tmimeType, remaining = remaining, \"\"\n\t\t} else {\n\t\t\tmimeType, remaining = remaining[:end], remaining[end+1:]\n\t\t}\n\t\tif quality := strings.Index(mimeType, \";\"); quality != -1 {\n\t\t\tmimeType = mimeType[:quality]\n\t\t}\n\t\tmimeType = strings.TrimFunc(mimeType, stringTrimSpaceCutset)\n\t\tfor _, consumeableType := range r.Consumes {\n\t\t\tif consumeableType == \"*/*\" || consumeableType == mimeType {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\tif len(remaining) == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n}\n\n// Tokenize an URL path using the slash separator ; the result does not have empty tokens\nfunc tokenizePath(path string) []string {\n\tif \"/\" == path {\n\t\treturn nil\n\t}\n\tif TrimRightSlashEnabled {\n\t\t// 3.9.0\n\t\treturn strings.Split(strings.Trim(path, \"/\"), \"/\")\n\t} else {\n\t\t// 3.10.2\n\t\treturn strings.Split(strings.TrimLeft(path, \"/\"), \"/\")\n\t}\n}\n\n// for debugging\nfunc (r *Route) String() string {\n\treturn r.Method + \" \" + r.Path\n}\n\n// EnableContentEncoding (default=false) allows for GZIP or DEFLATE encoding of responses. Overrides the container.contentEncodingEnabled value.\nfunc (r *Route) EnableContentEncoding(enabled bool) {\n\tr.contentEncodingEnabled = &enabled\n}\n\n// TrimRightSlashEnabled controls whether\n// - path on route building is using path.Join\n// - the path of the incoming request is trimmed of its slash suffux.\n// Value of true matches the behavior of <= 3.9.0\nvar TrimRightSlashEnabled = true\n"
        },
        {
          "name": "route_builder.go",
          "type": "blob",
          "size": 12.806640625,
          "content": "package restful\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync/atomic\"\n\n\t\"github.com/emicklei/go-restful/v3/log\"\n)\n\n// RouteBuilder is a helper to construct Routes.\ntype RouteBuilder struct {\n\trootPath                         string\n\tcurrentPath                      string\n\tproduces                         []string\n\tconsumes                         []string\n\thttpMethod                       string        // required\n\tfunction                         RouteFunction // required\n\tfilters                          []FilterFunction\n\tconditions                       []RouteSelectionConditionFunction\n\tallowedMethodsWithoutContentType []string // see Route\n\n\ttypeNameHandleFunc TypeNameHandleFunction // required\n\n\t// documentation\n\tdoc                    string\n\tnotes                  string\n\toperation              string\n\treadSample             interface{}\n\twriteSamples           []interface{}\n\tparameters             []*Parameter\n\terrorMap               map[int]ResponseError\n\tdefaultResponse        *ResponseError\n\tmetadata               map[string]interface{}\n\textensions             map[string]interface{}\n\tdeprecated             bool\n\tcontentEncodingEnabled *bool\n}\n\n// Do evaluates each argument with the RouteBuilder itself.\n// This allows you to follow DRY principles without breaking the fluent programming style.\n// Example:\n//\n//\tws.Route(ws.DELETE(\"/{name}\").To(t.deletePerson).Do(Returns200, Returns500))\n//\n//\tfunc Returns500(b *RouteBuilder) {\n//\t\tb.Returns(500, \"Internal Server Error\", restful.ServiceError{})\n//\t}\nfunc (b *RouteBuilder) Do(oneArgBlocks ...func(*RouteBuilder)) *RouteBuilder {\n\tfor _, each := range oneArgBlocks {\n\t\teach(b)\n\t}\n\treturn b\n}\n\n// To bind the route to a function.\n// If this route is matched with the incoming Http Request then call this function with the *Request,*Response pair. Required.\nfunc (b *RouteBuilder) To(function RouteFunction) *RouteBuilder {\n\tb.function = function\n\treturn b\n}\n\n// Method specifies what HTTP method to match. Required.\nfunc (b *RouteBuilder) Method(method string) *RouteBuilder {\n\tb.httpMethod = method\n\treturn b\n}\n\n// Produces specifies what MIME types can be produced ; the matched one will appear in the Content-Type Http header.\nfunc (b *RouteBuilder) Produces(mimeTypes ...string) *RouteBuilder {\n\tb.produces = mimeTypes\n\treturn b\n}\n\n// Consumes specifies what MIME types can be consumes ; the Accept Http header must matched any of these\nfunc (b *RouteBuilder) Consumes(mimeTypes ...string) *RouteBuilder {\n\tb.consumes = mimeTypes\n\treturn b\n}\n\n// Path specifies the relative (w.r.t WebService root path) URL path to match. Default is \"/\".\nfunc (b *RouteBuilder) Path(subPath string) *RouteBuilder {\n\tb.currentPath = subPath\n\treturn b\n}\n\n// Doc tells what this route is all about. Optional.\nfunc (b *RouteBuilder) Doc(documentation string) *RouteBuilder {\n\tb.doc = documentation\n\treturn b\n}\n\n// Notes is a verbose explanation of the operation behavior. Optional.\nfunc (b *RouteBuilder) Notes(notes string) *RouteBuilder {\n\tb.notes = notes\n\treturn b\n}\n\n// Reads tells what resource type will be read from the request payload. Optional.\n// A parameter of type \"body\" is added ,required is set to true and the dataType is set to the qualified name of the sample's type.\nfunc (b *RouteBuilder) Reads(sample interface{}, optionalDescription ...string) *RouteBuilder {\n\tfn := b.typeNameHandleFunc\n\tif fn == nil {\n\t\tfn = reflectTypeName\n\t}\n\ttypeAsName := fn(sample)\n\tdescription := \"\"\n\tif len(optionalDescription) > 0 {\n\t\tdescription = optionalDescription[0]\n\t}\n\tb.readSample = sample\n\tbodyParameter := &Parameter{&ParameterData{Name: \"body\", Description: description}}\n\tbodyParameter.beBody()\n\tbodyParameter.Required(true)\n\tbodyParameter.DataType(typeAsName)\n\tb.Param(bodyParameter)\n\treturn b\n}\n\n// ParameterNamed returns a Parameter already known to the RouteBuilder. Returns nil if not.\n// Use this to modify or extend information for the Parameter (through its Data()).\nfunc (b RouteBuilder) ParameterNamed(name string) (p *Parameter) {\n\tfor _, each := range b.parameters {\n\t\tif each.Data().Name == name {\n\t\t\treturn each\n\t\t}\n\t}\n\treturn p\n}\n\n// Writes tells which one of the resource types will be written as the response payload. Optional.\nfunc (b *RouteBuilder) Writes(samples ...interface{}) *RouteBuilder {\n\tb.writeSamples = samples // oneof\n\treturn b\n}\n\n// Param allows you to document the parameters of the Route. It adds a new Parameter (does not check for duplicates).\nfunc (b *RouteBuilder) Param(parameter *Parameter) *RouteBuilder {\n\tif b.parameters == nil {\n\t\tb.parameters = []*Parameter{}\n\t}\n\tb.parameters = append(b.parameters, parameter)\n\treturn b\n}\n\n// Operation allows you to document what the actual method/function call is of the Route.\n// Unless called, the operation name is derived from the RouteFunction set using To(..).\nfunc (b *RouteBuilder) Operation(name string) *RouteBuilder {\n\tb.operation = name\n\treturn b\n}\n\n// ReturnsError is deprecated, use Returns instead.\nfunc (b *RouteBuilder) ReturnsError(code int, message string, model interface{}) *RouteBuilder {\n\tlog.Print(\"ReturnsError is deprecated, use Returns instead.\")\n\treturn b.Returns(code, message, model)\n}\n\n// Returns allows you to document what responses (errors or regular) can be expected.\n// The model parameter is optional ; either pass a struct instance or use nil if not applicable.\nfunc (b *RouteBuilder) Returns(code int, message string, model interface{}) *RouteBuilder {\n\terr := ResponseError{\n\t\tCode:      code,\n\t\tMessage:   message,\n\t\tModel:     model,\n\t\tIsDefault: false, // this field is deprecated, use default response instead.\n\t}\n\t// lazy init because there is no NewRouteBuilder (yet)\n\tif b.errorMap == nil {\n\t\tb.errorMap = map[int]ResponseError{}\n\t}\n\tb.errorMap[code] = err\n\treturn b\n}\n\n// ReturnsWithHeaders is similar to Returns, but can specify response headers\nfunc (b *RouteBuilder) ReturnsWithHeaders(code int, message string, model interface{}, headers map[string]Header) *RouteBuilder {\n\tb.Returns(code, message, model)\n\terr := b.errorMap[code]\n\terr.Headers = headers\n\tb.errorMap[code] = err\n\treturn b\n}\n\n// DefaultReturns is a special Returns call that sets the default of the response.\nfunc (b *RouteBuilder) DefaultReturns(message string, model interface{}) *RouteBuilder {\n\tb.defaultResponse = &ResponseError{\n\t\tMessage: message,\n\t\tModel:   model,\n\t}\n\treturn b\n}\n\n// Metadata adds or updates a key=value pair to the metadata map.\nfunc (b *RouteBuilder) Metadata(key string, value interface{}) *RouteBuilder {\n\tif b.metadata == nil {\n\t\tb.metadata = map[string]interface{}{}\n\t}\n\tb.metadata[key] = value\n\treturn b\n}\n\n// AddExtension adds or updates a key=value pair to the extensions map.\nfunc (b *RouteBuilder) AddExtension(key string, value interface{}) *RouteBuilder {\n\tif b.extensions == nil {\n\t\tb.extensions = map[string]interface{}{}\n\t}\n\tb.extensions[key] = value\n\treturn b\n}\n\n// Deprecate sets the value of deprecated to true.  Deprecated routes have a special UI treatment to warn against use\nfunc (b *RouteBuilder) Deprecate() *RouteBuilder {\n\tb.deprecated = true\n\treturn b\n}\n\n// AllowedMethodsWithoutContentType overrides the default list GET,HEAD,OPTIONS,DELETE,TRACE\n// If a request does not include a content-type header then\n// depending on the method, it may return a 415 Unsupported Media.\n// Must have uppercase HTTP Method names such as GET,HEAD,OPTIONS,...\nfunc (b *RouteBuilder) AllowedMethodsWithoutContentType(methods []string) *RouteBuilder {\n\tb.allowedMethodsWithoutContentType = methods\n\treturn b\n}\n\n// ResponseError represents a response; not necessarily an error.\ntype ResponseError struct {\n\tExtensionProperties\n\tCode      int\n\tMessage   string\n\tModel     interface{}\n\tHeaders   map[string]Header\n\tIsDefault bool\n}\n\n// Header describes a header for a response of the API\n//\n// For more information: http://goo.gl/8us55a#headerObject\ntype Header struct {\n\t*Items\n\tDescription string\n}\n\n// Items describe swagger simple schemas for headers\ntype Items struct {\n\tType             string\n\tFormat           string\n\tItems            *Items\n\tCollectionFormat string\n\tDefault          interface{}\n}\n\nfunc (b *RouteBuilder) servicePath(path string) *RouteBuilder {\n\tb.rootPath = path\n\treturn b\n}\n\n// Filter appends a FilterFunction to the end of filters for this Route to build.\nfunc (b *RouteBuilder) Filter(filter FilterFunction) *RouteBuilder {\n\tb.filters = append(b.filters, filter)\n\treturn b\n}\n\n// If sets a condition function that controls matching the Route based on custom logic.\n// The condition function is provided the HTTP request and should return true if the route\n// should be considered.\n//\n// Efficiency note: the condition function is called before checking the method, produces, and\n// consumes criteria, so that the correct HTTP status code can be returned.\n//\n// Lifecycle note: no filter functions have been called prior to calling the condition function,\n// so the condition function should not depend on any context that might be set up by container\n// or route filters.\nfunc (b *RouteBuilder) If(condition RouteSelectionConditionFunction) *RouteBuilder {\n\tb.conditions = append(b.conditions, condition)\n\treturn b\n}\n\n// ContentEncodingEnabled allows you to override the Containers value for auto-compressing this route response.\nfunc (b *RouteBuilder) ContentEncodingEnabled(enabled bool) *RouteBuilder {\n\tb.contentEncodingEnabled = &enabled\n\treturn b\n}\n\n// If no specific Route path then set to rootPath\n// If no specific Produces then set to rootProduces\n// If no specific Consumes then set to rootConsumes\nfunc (b *RouteBuilder) copyDefaults(rootProduces, rootConsumes []string) {\n\tif len(b.produces) == 0 {\n\t\tb.produces = rootProduces\n\t}\n\tif len(b.consumes) == 0 {\n\t\tb.consumes = rootConsumes\n\t}\n}\n\n// typeNameHandler sets the function that will convert types to strings in the parameter\n// and model definitions.\nfunc (b *RouteBuilder) typeNameHandler(handler TypeNameHandleFunction) *RouteBuilder {\n\tb.typeNameHandleFunc = handler\n\treturn b\n}\n\n// Build creates a new Route using the specification details collected by the RouteBuilder\nfunc (b *RouteBuilder) Build() Route {\n\tpathExpr, err := newPathExpression(b.currentPath)\n\tif err != nil {\n\t\tlog.Printf(\"Invalid path:%s because:%v\", b.currentPath, err)\n\t\tos.Exit(1)\n\t}\n\tif b.function == nil {\n\t\tlog.Printf(\"No function specified for route:\" + b.currentPath)\n\t\tos.Exit(1)\n\t}\n\toperationName := b.operation\n\tif len(operationName) == 0 && b.function != nil {\n\t\t// extract from definition\n\t\toperationName = nameOfFunction(b.function)\n\t}\n\troute := Route{\n\t\tMethod:                           b.httpMethod,\n\t\tPath:                             concatPath(b.rootPath, b.currentPath),\n\t\tProduces:                         b.produces,\n\t\tConsumes:                         b.consumes,\n\t\tFunction:                         b.function,\n\t\tFilters:                          b.filters,\n\t\tIf:                               b.conditions,\n\t\trelativePath:                     b.currentPath,\n\t\tpathExpr:                         pathExpr,\n\t\tDoc:                              b.doc,\n\t\tNotes:                            b.notes,\n\t\tOperation:                        operationName,\n\t\tParameterDocs:                    b.parameters,\n\t\tResponseErrors:                   b.errorMap,\n\t\tDefaultResponse:                  b.defaultResponse,\n\t\tReadSample:                       b.readSample,\n\t\tWriteSamples:                     b.writeSamples,\n\t\tMetadata:                         b.metadata,\n\t\tDeprecated:                       b.deprecated,\n\t\tcontentEncodingEnabled:           b.contentEncodingEnabled,\n\t\tallowedMethodsWithoutContentType: b.allowedMethodsWithoutContentType,\n\t}\n\t// set WriteSample if one specified\n\tif len(b.writeSamples) == 1 {\n\t\troute.WriteSample = b.writeSamples[0]\n\t}\n\troute.Extensions = b.extensions\n\troute.postBuild()\n\treturn route\n}\n\n// merge two paths using the current (package global) merge path strategy.\nfunc concatPath(rootPath, routePath string) string {\n\n\tif TrimRightSlashEnabled {\n\t\treturn strings.TrimRight(rootPath, \"/\") + \"/\" + strings.TrimLeft(routePath, \"/\")\n\t} else {\n\t\treturn path.Join(rootPath, routePath)\n\t}\n}\n\nvar anonymousFuncCount int32\n\n// nameOfFunction returns the short name of the function f for documentation.\n// It uses a runtime feature for debugging ; its value may change for later Go versions.\nfunc nameOfFunction(f interface{}) string {\n\tfun := runtime.FuncForPC(reflect.ValueOf(f).Pointer())\n\ttokenized := strings.Split(fun.Name(), \".\")\n\tlast := tokenized[len(tokenized)-1]\n\tlast = strings.TrimSuffix(last, \")·fm\") // < Go 1.5\n\tlast = strings.TrimSuffix(last, \")-fm\") // Go 1.5\n\tlast = strings.TrimSuffix(last, \"·fm\")  // < Go 1.5\n\tlast = strings.TrimSuffix(last, \"-fm\")  // Go 1.5\n\tif last == \"func1\" {                    // this could mean conflicts in API docs\n\t\tval := atomic.AddInt32(&anonymousFuncCount, 1)\n\t\tlast = \"func\" + fmt.Sprintf(\"%d\", val)\n\t\tatomic.StoreInt32(&anonymousFuncCount, val)\n\t}\n\treturn last\n}\n"
        },
        {
          "name": "route_builder_test.go",
          "type": "blob",
          "size": 3.48828125,
          "content": "package restful\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestRouteBuilderWrites(t *testing.T) {\n\tb := new(RouteBuilder)\n\tb.To(dummy)\n\ttype StructA struct{}\n\ttype StructB struct{}\n\tb.Writes(StructA{})\n\tif got, want := len(b.writeSamples), 1; got != want {\n\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t}\n\t{\n\t\tr := b.Build()\n\t\tvar null interface{}\n\t\tif r.WriteSample == null {\n\t\t\tt.Fail()\n\t\t}\n\t}\n\tb.Writes(StructA{}, StructB{})\n\tif got, want := len(b.writeSamples), 2; got != want {\n\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t}\n\t{\n\t\tr := b.Build()\n\t\tvar null interface{}\n\t\tif got, want := r.WriteSample, null; got != want {\n\t\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t\t}\n\t}\n}\n\nfunc TestRouteBuilder_PathParameter(t *testing.T) {\n\tp := &Parameter{&ParameterData{Name: \"name\", Description: \"desc\"}}\n\tp.AllowMultiple(true)\n\tp.DataType(\"int\")\n\tp.Required(true)\n\tvalues := []string{\"a\"}\n\tp.PossibleValues(values)\n\tp.bePath()\n\n\tb := new(RouteBuilder)\n\tb.function = dummy\n\tb.Param(p)\n\tr := b.Build()\n\tif !r.ParameterDocs[0].Data().AllowMultiple {\n\t\tt.Error(\"AllowMultiple invalid\")\n\t}\n\tif r.ParameterDocs[0].Data().DataType != \"int\" {\n\t\tt.Error(\"dataType invalid\")\n\t}\n\tif !r.ParameterDocs[0].Data().Required {\n\t\tt.Error(\"required invalid\")\n\t}\n\tif r.ParameterDocs[0].Data().Kind != PathParameterKind {\n\t\tt.Error(\"kind invalid\")\n\t}\n\tif r.ParameterDocs[0].Data().PossibleValues[0] != \"a\" {\n\t\tt.Error(\"PossibleValues invalid\")\n\t}\n\tif b.ParameterNamed(\"name\") == nil {\n\t\tt.Error(\"access to parameter failed\")\n\t}\n}\n\nfunc TestRouteBuilder(t *testing.T) {\n\tjson := \"application/json\"\n\tb := new(RouteBuilder)\n\tb.To(dummy)\n\tb.Path(\"/routes\").\n\t\tMethod(\"HEAD\").\n\t\tConsumes(json).\n\t\tProduces(json).\n\t\tMetadata(\"test\", \"test-value\").\n\t\tAddExtension(\"x-restful-test\", \"test-value\").\n\t\tDefaultReturns(\"default\", time.Now())\n\tr := b.Build()\n\tif r.Path != \"/routes\" {\n\t\tt.Error(\"path invalid\")\n\t}\n\tif r.Produces[0] != json {\n\t\tt.Error(\"produces invalid\")\n\t}\n\tif r.Consumes[0] != json {\n\t\tt.Error(\"consumes invalid\")\n\t}\n\tif r.Operation != \"dummy\" {\n\t\tt.Error(\"Operation not set\")\n\t}\n\tif r.Metadata[\"test\"] != \"test-value\" {\n\t\tt.Errorf(\"Metadata not set\")\n\t}\n\tif r.Extensions[\"x-restful-test\"] != \"test-value\" {\n\t\tt.Errorf(\"Extensions not set\")\n\t}\n\tif r.DefaultResponse == nil {\n\t\tt.Fatal(\"expected default response\")\n\t}\n\tif r.hasCustomVerb {\n\t\tt.Errorf(\"hasCustomVerb should not be true\")\n\t}\n\n\tcustomVerbRoute := new(RouteBuilder)\n\tcustomVerbRoute.To(dummy)\n\tcustomVerbRoute.Path(\"/users:init\")\n\tif !customVerbRoute.Build().hasCustomVerb {\n\t\tt.Errorf(\"hasCustomVerb should be true\")\n\t}\n}\n\nfunc TestAnonymousFuncNaming(t *testing.T) {\n\tf1 := func() {}\n\tf2 := func() {}\n\tif got, want := nameOfFunction(f1), \"func1\"; got != want {\n\t\tt.Errorf(\"got %v want %v\", got, want)\n\t}\n\tif got, want := nameOfFunction(f2), \"func2\"; got != want {\n\t\tt.Errorf(\"got %v want %v\", got, want)\n\t}\n}\n\nfunc TestContentEncodingEnabled(t *testing.T) {\n\tb := new(RouteBuilder)\n\tb.function = dummy\n\tr := b.Build()\n\n\tgot := r.contentEncodingEnabled\n\tvar want *bool // nil\n\n\tif got != want {\n\t\tt.Errorf(\"got %v want %v (default nil)\", got, want)\n\t}\n\n\t// true\n\tb = new(RouteBuilder)\n\tb.function = dummy\n\tb.ContentEncodingEnabled(true)\n\tr = b.Build()\n\tgot = r.contentEncodingEnabled\n\n\tif *got != true {\n\t\tt.Errorf(\"got %v want %v (explicit true)\", *got, true)\n\t}\n\n\t// true\n\tb = new(RouteBuilder)\n\tb.function = dummy\n\tb.ContentEncodingEnabled(false)\n\tr = b.Build()\n\tgot = r.contentEncodingEnabled\n\n\tif *got != false {\n\t\tt.Errorf(\"got %v want %v (explicit false)\", *got, false)\n\t}\n\n}\n"
        },
        {
          "name": "route_reader.go",
          "type": "blob",
          "size": 1.396484375,
          "content": "package restful\n\n// Copyright 2021 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\ntype RouteReader interface {\n\tMethod() string\n\tConsumes() []string\n\tPath() string\n\tDoc() string\n\tNotes() string\n\tOperation() string\n\tParameterDocs() []*Parameter\n\t// Returns a copy\n\tMetadata() map[string]interface{}\n\tDeprecated() bool\n}\n\ntype routeAccessor struct {\n\troute *Route\n}\n\nfunc (r routeAccessor) Method() string {\n\treturn r.route.Method\n}\nfunc (r routeAccessor) Consumes() []string {\n\treturn r.route.Consumes[:]\n}\nfunc (r routeAccessor) Path() string {\n\treturn r.route.Path\n}\nfunc (r routeAccessor) Doc() string {\n\treturn r.route.Doc\n}\nfunc (r routeAccessor) Notes() string {\n\treturn r.route.Notes\n}\nfunc (r routeAccessor) Operation() string {\n\treturn r.route.Operation\n}\nfunc (r routeAccessor) ParameterDocs() []*Parameter {\n\treturn r.route.ParameterDocs[:]\n}\n\n// Returns a copy\nfunc (r routeAccessor) Metadata() map[string]interface{} {\n\treturn copyMap(r.route.Metadata)\n}\nfunc (r routeAccessor) Deprecated() bool {\n\treturn r.route.Deprecated\n}\n\n// https://stackoverflow.com/questions/23057785/how-to-copy-a-map\nfunc copyMap(m map[string]interface{}) map[string]interface{} {\n\tcp := make(map[string]interface{})\n\tfor k, v := range m {\n\t\tvm, ok := v.(map[string]interface{})\n\t\tif ok {\n\t\t\tcp[k] = copyMap(vm)\n\t\t} else {\n\t\t\tcp[k] = v\n\t\t}\n\t}\n\treturn cp\n}\n"
        },
        {
          "name": "route_test.go",
          "type": "blob",
          "size": 1.990234375,
          "content": "package restful\n\nimport (\n\t\"testing\"\n)\n\n// accept should match produces\nfunc TestMatchesAcceptPlainTextWhenProducePlainTextAsLast(t *testing.T) {\n\tr := Route{Produces: []string{\"application/json\", \"text/plain\"}}\n\tif !r.matchesAccept(\"text/plain\") {\n\t\tt.Errorf(\"accept should match text/plain\")\n\t}\n}\n\n// accept should match produces\nfunc TestMatchesAcceptStar(t *testing.T) {\n\tr := Route{Produces: []string{\"application/xml\"}}\n\tif !r.matchesAccept(\"*/*\") {\n\t\tt.Errorf(\"accept should match star\")\n\t}\n}\n\n// accept should match produces\nfunc TestMatchesAcceptIE(t *testing.T) {\n\tr := Route{Produces: []string{\"application/xml\"}}\n\tif !r.matchesAccept(\"text/html, application/xhtml+xml, */*\") {\n\t\tt.Errorf(\"accept should match star\")\n\t}\n}\n\n// accept should match produces\nfunc TestMatchesAcceptXml(t *testing.T) {\n\tr := Route{Produces: []string{\"application/xml\"}}\n\tif r.matchesAccept(\"application/json\") {\n\t\tt.Errorf(\"accept should not match json\")\n\t}\n\tif !r.matchesAccept(\"application/xml\") {\n\t\tt.Errorf(\"accept should match xml\")\n\t}\n}\n\n// accept should match produces\nfunc TestMatchesAcceptAny(t *testing.T) {\n\tr := Route{Produces: []string{\"*/*\"}}\n\tif !r.matchesAccept(\"application/json\") {\n\t\tt.Errorf(\"accept should match json\")\n\t}\n\tif !r.matchesAccept(\"application/xml\") {\n\t\tt.Errorf(\"accept should match xml\")\n\t}\n}\n\n// content type should match consumes\nfunc TestMatchesContentTypeXml(t *testing.T) {\n\tr := Route{Consumes: []string{\"application/xml\"}}\n\tif r.matchesContentType(\"application/json\") {\n\t\tt.Errorf(\"accept should not match json\")\n\t}\n\tif !r.matchesContentType(\"application/xml\") {\n\t\tt.Errorf(\"accept should match xml\")\n\t}\n}\n\n// content type should match consumes\nfunc TestMatchesContentTypeCharsetInformation(t *testing.T) {\n\tr := Route{Consumes: []string{\"application/json\"}}\n\tif !r.matchesContentType(\"application/json; charset=UTF-8\") {\n\t\tt.Errorf(\"matchesContentType should ignore charset information\")\n\t}\n}\n\nfunc TestTokenizePath(t *testing.T) {\n\tif len(tokenizePath(\"/\")) != 0 {\n\t\tt.Errorf(\"not empty path tokens\")\n\t}\n}\n"
        },
        {
          "name": "router.go",
          "type": "blob",
          "size": 0.748046875,
          "content": "package restful\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport \"net/http\"\n\n// A RouteSelector finds the best matching Route given the input HTTP Request\n// RouteSelectors can optionally also implement the PathProcessor interface to also calculate the\n// path parameters after the route has been selected.\ntype RouteSelector interface {\n\n\t// SelectRoute finds a Route given the input HTTP Request and a list of WebServices.\n\t// It returns a selected Route and its containing WebService or an error indicating\n\t// a problem.\n\tSelectRoute(\n\t\twebServices []*WebService,\n\t\thttpRequest *http.Request) (selectedService *WebService, selected *Route, err error)\n}\n"
        },
        {
          "name": "service_error.go",
          "type": "blob",
          "size": 0.95703125,
          "content": "package restful\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// ServiceError is a transport object to pass information about a non-Http error occurred in a WebService while processing a request.\ntype ServiceError struct {\n\tCode    int\n\tMessage string\n\tHeader  http.Header\n}\n\n// NewError returns a ServiceError using the code and reason\nfunc NewError(code int, message string) ServiceError {\n\treturn ServiceError{Code: code, Message: message}\n}\n\n// NewErrorWithHeader returns a ServiceError using the code, reason and header\nfunc NewErrorWithHeader(code int, message string, header http.Header) ServiceError {\n\treturn ServiceError{Code: code, Message: message, Header: header}\n}\n\n// Error returns a text representation of the service error\nfunc (s ServiceError) Error() string {\n\treturn fmt.Sprintf(\"[ServiceError:%v] %v\", s.Code, s.Message)\n}\n"
        },
        {
          "name": "tracer_test.go",
          "type": "blob",
          "size": 0.287109375,
          "content": "package restful\n\nimport \"testing\"\n\n// Use like this:\n//\n//\tTraceLogger(testLogger{t})\ntype testLogger struct {\n\tt *testing.T\n}\n\nfunc (l testLogger) Print(v ...interface{}) {\n\tl.t.Log(v...)\n}\n\nfunc (l testLogger) Printf(format string, v ...interface{}) {\n\tl.t.Helper()\n\tl.t.Logf(format, v...)\n}\n"
        },
        {
          "name": "web_service.go",
          "type": "blob",
          "size": 10.701171875,
          "content": "package restful\n\nimport (\n\t\"errors\"\n\t\"os\"\n\t\"reflect\"\n\t\"sync\"\n\n\t\"github.com/emicklei/go-restful/v3/log\"\n)\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\n// WebService holds a collection of Route values that bind a Http Method + URL Path to a function.\ntype WebService struct {\n\trootPath       string\n\tpathExpr       *pathExpression // cached compilation of rootPath as RegExp\n\troutes         []Route\n\tproduces       []string\n\tconsumes       []string\n\tpathParameters []*Parameter\n\tfilters        []FilterFunction\n\tdocumentation  string\n\tapiVersion     string\n\n\ttypeNameHandleFunc TypeNameHandleFunction\n\n\tdynamicRoutes bool\n\n\t// protects 'routes' if dynamic routes are enabled\n\troutesLock sync.RWMutex\n}\n\nfunc (w *WebService) SetDynamicRoutes(enable bool) {\n\tw.dynamicRoutes = enable\n}\n\n// TypeNameHandleFunction declares functions that can handle translating the name of a sample object\n// into the restful documentation for the service.\ntype TypeNameHandleFunction func(sample interface{}) string\n\n// TypeNameHandler sets the function that will convert types to strings in the parameter\n// and model definitions. If not set, the web service will invoke\n// reflect.TypeOf(object).String().\nfunc (w *WebService) TypeNameHandler(handler TypeNameHandleFunction) *WebService {\n\tw.typeNameHandleFunc = handler\n\treturn w\n}\n\n// reflectTypeName is the default TypeNameHandleFunction and for a given object\n// returns the name that Go identifies it with (e.g. \"string\" or \"v1.Object\") via\n// the reflection API.\nfunc reflectTypeName(sample interface{}) string {\n\treturn reflect.TypeOf(sample).String()\n}\n\n// compilePathExpression ensures that the path is compiled into a RegEx for those routers that need it.\nfunc (w *WebService) compilePathExpression() {\n\tcompiled, err := newPathExpression(w.rootPath)\n\tif err != nil {\n\t\tlog.Printf(\"invalid path:%s because:%v\", w.rootPath, err)\n\t\tos.Exit(1)\n\t}\n\tw.pathExpr = compiled\n}\n\n// ApiVersion sets the API version for documentation purposes.\nfunc (w *WebService) ApiVersion(apiVersion string) *WebService {\n\tw.apiVersion = apiVersion\n\treturn w\n}\n\n// Version returns the API version for documentation purposes.\nfunc (w *WebService) Version() string { return w.apiVersion }\n\n// Path specifies the root URL template path of the WebService.\n// All Routes will be relative to this path.\nfunc (w *WebService) Path(root string) *WebService {\n\tw.rootPath = root\n\tif len(w.rootPath) == 0 {\n\t\tw.rootPath = \"/\"\n\t}\n\tw.compilePathExpression()\n\treturn w\n}\n\n// Param adds a PathParameter to document parameters used in the root path.\nfunc (w *WebService) Param(parameter *Parameter) *WebService {\n\tif w.pathParameters == nil {\n\t\tw.pathParameters = []*Parameter{}\n\t}\n\tw.pathParameters = append(w.pathParameters, parameter)\n\treturn w\n}\n\n// PathParameter creates a new Parameter of kind Path for documentation purposes.\n// It is initialized as required with string as its DataType.\nfunc (w *WebService) PathParameter(name, description string) *Parameter {\n\treturn PathParameter(name, description)\n}\n\n// PathParameter creates a new Parameter of kind Path for documentation purposes.\n// It is initialized as required with string as its DataType.\nfunc PathParameter(name, description string) *Parameter {\n\tp := &Parameter{&ParameterData{Name: name, Description: description, Required: true, DataType: \"string\"}}\n\tp.bePath()\n\treturn p\n}\n\n// QueryParameter creates a new Parameter of kind Query for documentation purposes.\n// It is initialized as not required with string as its DataType.\nfunc (w *WebService) QueryParameter(name, description string) *Parameter {\n\treturn QueryParameter(name, description)\n}\n\n// QueryParameter creates a new Parameter of kind Query for documentation purposes.\n// It is initialized as not required with string as its DataType.\nfunc QueryParameter(name, description string) *Parameter {\n\tp := &Parameter{&ParameterData{Name: name, Description: description, Required: false, DataType: \"string\", CollectionFormat: CollectionFormatCSV.String()}}\n\tp.beQuery()\n\treturn p\n}\n\n// BodyParameter creates a new Parameter of kind Body for documentation purposes.\n// It is initialized as required without a DataType.\nfunc (w *WebService) BodyParameter(name, description string) *Parameter {\n\treturn BodyParameter(name, description)\n}\n\n// BodyParameter creates a new Parameter of kind Body for documentation purposes.\n// It is initialized as required without a DataType.\nfunc BodyParameter(name, description string) *Parameter {\n\tp := &Parameter{&ParameterData{Name: name, Description: description, Required: true}}\n\tp.beBody()\n\treturn p\n}\n\n// HeaderParameter creates a new Parameter of kind (Http) Header for documentation purposes.\n// It is initialized as not required with string as its DataType.\nfunc (w *WebService) HeaderParameter(name, description string) *Parameter {\n\treturn HeaderParameter(name, description)\n}\n\n// HeaderParameter creates a new Parameter of kind (Http) Header for documentation purposes.\n// It is initialized as not required with string as its DataType.\nfunc HeaderParameter(name, description string) *Parameter {\n\tp := &Parameter{&ParameterData{Name: name, Description: description, Required: false, DataType: \"string\"}}\n\tp.beHeader()\n\treturn p\n}\n\n// FormParameter creates a new Parameter of kind Form (using application/x-www-form-urlencoded) for documentation purposes.\n// It is initialized as required with string as its DataType.\nfunc (w *WebService) FormParameter(name, description string) *Parameter {\n\treturn FormParameter(name, description)\n}\n\n// FormParameter creates a new Parameter of kind Form (using application/x-www-form-urlencoded) for documentation purposes.\n// It is initialized as required with string as its DataType.\nfunc FormParameter(name, description string) *Parameter {\n\tp := &Parameter{&ParameterData{Name: name, Description: description, Required: false, DataType: \"string\"}}\n\tp.beForm()\n\treturn p\n}\n\n// MultiPartFormParameter creates a new Parameter of kind Form (using multipart/form-data) for documentation purposes.\n// It is initialized as required with string as its DataType.\nfunc (w *WebService) MultiPartFormParameter(name, description string) *Parameter {\n\treturn MultiPartFormParameter(name, description)\n}\n\nfunc MultiPartFormParameter(name, description string) *Parameter {\n\tp := &Parameter{&ParameterData{Name: name, Description: description, Required: false, DataType: \"string\"}}\n\tp.beMultiPartForm()\n\treturn p\n}\n\n// Route creates a new Route using the RouteBuilder and add to the ordered list of Routes.\nfunc (w *WebService) Route(builder *RouteBuilder) *WebService {\n\tw.routesLock.Lock()\n\tdefer w.routesLock.Unlock()\n\tbuilder.copyDefaults(w.produces, w.consumes)\n\tw.routes = append(w.routes, builder.Build())\n\treturn w\n}\n\n// RemoveRoute removes the specified route, looks for something that matches 'path' and 'method'\nfunc (w *WebService) RemoveRoute(path, method string) error {\n    if !w.dynamicRoutes {\n        return errors.New(\"dynamic routes are not enabled.\")\n    }\n    w.routesLock.Lock()\n    defer w.routesLock.Unlock()\n    newRoutes := []Route{}\n    for _, route := range w.routes {\n        if route.Method == method && route.Path == path {\n            continue\n        }\n        newRoutes = append(newRoutes, route)\n    }\n    w.routes = newRoutes\n    return nil\n}\n\n// Method creates a new RouteBuilder and initialize its http method\nfunc (w *WebService) Method(httpMethod string) *RouteBuilder {\n\treturn new(RouteBuilder).typeNameHandler(w.typeNameHandleFunc).servicePath(w.rootPath).Method(httpMethod)\n}\n\n// Produces specifies that this WebService can produce one or more MIME types.\n// Http requests must have one of these values set for the Accept header.\nfunc (w *WebService) Produces(contentTypes ...string) *WebService {\n\tw.produces = contentTypes\n\treturn w\n}\n\n// Consumes specifies that this WebService can consume one or more MIME types.\n// Http requests must have one of these values set for the Content-Type header.\nfunc (w *WebService) Consumes(accepts ...string) *WebService {\n\tw.consumes = accepts\n\treturn w\n}\n\n// Routes returns the Routes associated with this WebService\nfunc (w *WebService) Routes() []Route {\n\tif !w.dynamicRoutes {\n\t\treturn w.routes\n\t}\n\t// Make a copy of the array to prevent concurrency problems\n\tw.routesLock.RLock()\n\tdefer w.routesLock.RUnlock()\n\tresult := make([]Route, len(w.routes))\n\tfor ix := range w.routes {\n\t\tresult[ix] = w.routes[ix]\n\t}\n\treturn result\n}\n\n// RootPath returns the RootPath associated with this WebService. Default \"/\"\nfunc (w *WebService) RootPath() string {\n\treturn w.rootPath\n}\n\n// PathParameters return the path parameter names for (shared among its Routes)\nfunc (w *WebService) PathParameters() []*Parameter {\n\treturn w.pathParameters\n}\n\n// Filter adds a filter function to the chain of filters applicable to all its Routes\nfunc (w *WebService) Filter(filter FilterFunction) *WebService {\n\tw.filters = append(w.filters, filter)\n\treturn w\n}\n\n// Doc is used to set the documentation of this service.\nfunc (w *WebService) Doc(plainText string) *WebService {\n\tw.documentation = plainText\n\treturn w\n}\n\n// Documentation returns it.\nfunc (w *WebService) Documentation() string {\n\treturn w.documentation\n}\n\n/*\n\tConvenience methods\n*/\n\n// HEAD is a shortcut for .Method(\"HEAD\").Path(subPath)\nfunc (w *WebService) HEAD(subPath string) *RouteBuilder {\n\treturn new(RouteBuilder).typeNameHandler(w.typeNameHandleFunc).servicePath(w.rootPath).Method(\"HEAD\").Path(subPath)\n}\n\n// GET is a shortcut for .Method(\"GET\").Path(subPath)\nfunc (w *WebService) GET(subPath string) *RouteBuilder {\n\treturn new(RouteBuilder).typeNameHandler(w.typeNameHandleFunc).servicePath(w.rootPath).Method(\"GET\").Path(subPath)\n}\n\n// POST is a shortcut for .Method(\"POST\").Path(subPath)\nfunc (w *WebService) POST(subPath string) *RouteBuilder {\n\treturn new(RouteBuilder).typeNameHandler(w.typeNameHandleFunc).servicePath(w.rootPath).Method(\"POST\").Path(subPath)\n}\n\n// PUT is a shortcut for .Method(\"PUT\").Path(subPath)\nfunc (w *WebService) PUT(subPath string) *RouteBuilder {\n\treturn new(RouteBuilder).typeNameHandler(w.typeNameHandleFunc).servicePath(w.rootPath).Method(\"PUT\").Path(subPath)\n}\n\n// PATCH is a shortcut for .Method(\"PATCH\").Path(subPath)\nfunc (w *WebService) PATCH(subPath string) *RouteBuilder {\n\treturn new(RouteBuilder).typeNameHandler(w.typeNameHandleFunc).servicePath(w.rootPath).Method(\"PATCH\").Path(subPath)\n}\n\n// DELETE is a shortcut for .Method(\"DELETE\").Path(subPath)\nfunc (w *WebService) DELETE(subPath string) *RouteBuilder {\n\treturn new(RouteBuilder).typeNameHandler(w.typeNameHandleFunc).servicePath(w.rootPath).Method(\"DELETE\").Path(subPath)\n}\n\n// OPTIONS is a shortcut for .Method(\"OPTIONS\").Path(subPath)\nfunc (w *WebService) OPTIONS(subPath string) *RouteBuilder {\n\treturn new(RouteBuilder).typeNameHandler(w.typeNameHandleFunc).servicePath(w.rootPath).Method(\"OPTIONS\").Path(subPath)\n}\n"
        },
        {
          "name": "web_service_container.go",
          "type": "blob",
          "size": 1.2294921875,
          "content": "package restful\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport (\n\t\"net/http\"\n)\n\n// DefaultContainer is a restful.Container that uses http.DefaultServeMux\nvar DefaultContainer *Container\n\nfunc init() {\n\tDefaultContainer = NewContainer()\n\tDefaultContainer.ServeMux = http.DefaultServeMux\n}\n\n// If set the true then panics will not be caught to return HTTP 500.\n// In that case, Route functions are responsible for handling any error situation.\n// Default value is false = recover from panics. This has performance implications.\n// OBSOLETE ; use restful.DefaultContainer.DoNotRecover(true)\nvar DoNotRecover = false\n\n// Add registers a new WebService add it to the DefaultContainer.\nfunc Add(service *WebService) {\n\tDefaultContainer.Add(service)\n}\n\n// Filter appends a container FilterFunction from the DefaultContainer.\n// These are called before dispatching a http.Request to a WebService.\nfunc Filter(filter FilterFunction) {\n\tDefaultContainer.Filter(filter)\n}\n\n// RegisteredWebServices returns the collections of WebServices from the DefaultContainer\nfunc RegisteredWebServices() []*WebService {\n\treturn DefaultContainer.RegisteredWebServices()\n}\n"
        },
        {
          "name": "web_service_test.go",
          "type": "blob",
          "size": 12.400390625,
          "content": "package restful\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\nconst (\n\tpathGetFriends = \"/get/{userId}/friends\"\n)\n\nfunc TestParameter(t *testing.T) {\n\tp := &Parameter{&ParameterData{Name: \"name\", Description: \"desc\"}}\n\tp.AllowMultiple(true)\n\tp.DataType(\"int\")\n\tp.Required(true)\n\tvalues := map[string]string{\"a\": \"b\"}\n\tp.AllowableValues(values)\n\tp.bePath()\n\n\tws := new(WebService)\n\tws.Param(p)\n\tif ws.pathParameters[0].Data().Name != \"name\" {\n\t\tt.Error(\"path parameter (or name) invalid\")\n\t}\n}\nfunc TestWebService_CanCreateParameterKinds(t *testing.T) {\n\tws := new(WebService)\n\tif ws.BodyParameter(\"b\", \"b\").Kind() != BodyParameterKind {\n\t\tt.Error(\"body parameter expected\")\n\t}\n\tif ws.PathParameter(\"p\", \"p\").Kind() != PathParameterKind {\n\t\tt.Error(\"path parameter expected\")\n\t}\n\tif ws.QueryParameter(\"q\", \"q\").Kind() != QueryParameterKind {\n\t\tt.Error(\"query parameter expected\")\n\t}\n}\n\nfunc TestCapturePanic(t *testing.T) {\n\ttearDown()\n\tAdd(newPanicingService())\n\thttpRequest, _ := http.NewRequest(\"GET\", \"http://here.com/fire\", nil)\n\thttpRequest.Header.Set(\"Accept\", \"*/*\")\n\thttpWriter := httptest.NewRecorder()\n\t// override the default here\n\tDefaultContainer.DoNotRecover(false)\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif 500 != httpWriter.Code {\n\t\tt.Error(\"500 expected on fire\")\n\t}\n}\n\nfunc TestCapturePanicWithEncoded(t *testing.T) {\n\ttearDown()\n\tAdd(newPanicingService())\n\tDefaultContainer.EnableContentEncoding(true)\n\thttpRequest, _ := http.NewRequest(\"GET\", \"http://here.com/fire\", nil)\n\thttpRequest.Header.Set(\"Accept\", \"*/*\")\n\thttpRequest.Header.Set(\"Accept-Encoding\", \"gzip\")\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif 500 != httpWriter.Code {\n\t\tt.Error(\"500 expected on fire, got\", httpWriter.Code)\n\t}\n}\n\nfunc TestNotFound(t *testing.T) {\n\ttearDown()\n\thttpRequest, _ := http.NewRequest(\"GET\", \"http://here.com/missing\", nil)\n\thttpRequest.Header.Set(\"Accept\", \"*/*\")\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif 404 != httpWriter.Code {\n\t\tt.Error(\"404 expected on missing\")\n\t}\n}\n\nfunc TestMethodNotAllowed(t *testing.T) {\n\ttearDown()\n\tAdd(newGetOnlyService())\n\thttpRequest, _ := http.NewRequest(\"POST\", \"http://here.com/get\", nil)\n\thttpRequest.Header.Set(\"Accept\", \"*/*\")\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif 405 != httpWriter.Code {\n\t\tt.Error(\"405 expected method not allowed\")\n\t}\n}\n\nfunc TestMethodNotAllowed_Issue435(t *testing.T) {\n\ttearDown()\n\tAdd(newPutGetDeleteWithDuplicateService())\n\thttpRequest, _ := http.NewRequest(\"POST\", \"http://here/thing\", nil)\n\thttpRequest.Header.Set(\"Accept\", \"*/*\")\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif 405 != httpWriter.Code {\n\t\tt.Error(\"405 expected method not allowed\")\n\t}\n\tif \"PUT, GET, DELETE\" != httpWriter.Header().Get(\"Allow\") {\n\t\tt.Error(\"405 expected Allowed header got \", httpWriter.Header())\n\t}\n}\n\nfunc TestNotAcceptable_Issue434(t *testing.T) {\n\ttearDown()\n\tAdd(newGetPlainTextOrJsonService())\n\thttpRequest, _ := http.NewRequest(\"GET\", \"http://here.com/get\", nil)\n\thttpRequest.Header.Set(\"Accept\", \"application/toml\")\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif 406 != httpWriter.Code {\n\t\tt.Error(\"406 expected not acceptable\", httpWriter.Code)\n\t}\n\texpected := `406: Not Acceptable\n\nAvailable representations: text/plain, application/json`\n\tbody, _ := ioutil.ReadAll(httpWriter.Body)\n\tif expected != string(body) {\n\t\tt.Errorf(\"Expected body:\\n%s\\ngot:\\n%s\\n\", expected, string(body))\n\t}\n}\n\nfunc TestUnsupportedMedia_Issue492(t *testing.T) {\n\ttearDown()\n\tAdd(newPostTestService())\n\tfor _, method := range []string{\"POST\", \"PUT\", \"PATCH\"} {\n\t\thttpRequest, _ := http.NewRequest(method, \"http://here.com/test\", nil)\n\t\thttpRequest.Header.Set(\"Accept\", \"application/json\")\n\t\thttpWriter := httptest.NewRecorder()\n\t\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\t\tif 415 != httpWriter.Code {\n\t\t\tt.Errorf(\"[%s] 415 expected got %d\", method, httpWriter.Code)\n\t\t}\n\t}\n}\n\nfunc TestSelectedRoutePath_Issue100(t *testing.T) {\n\ttearDown()\n\tAdd(newSelectedRouteTestingService())\n\thttpRequest, _ := http.NewRequest(\"GET\", \"http://here.com/get/232452/friends\", nil)\n\thttpRequest.Header.Set(\"Accept\", \"*/*\")\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif http.StatusOK != httpWriter.Code {\n\t\tt.Error(http.StatusOK, \"expected,\", httpWriter.Code, \"received.\")\n\t}\n}\n\nfunc TestContentType415_Issue170(t *testing.T) {\n\ttearDown()\n\tAdd(newGetOnlyJsonOnlyService())\n\thttpRequest, _ := http.NewRequest(\"GET\", \"http://here.com/get\", nil)\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif 200 != httpWriter.Code {\n\t\tt.Errorf(\"Expected 200, got %d\", httpWriter.Code)\n\t}\n}\n\nfunc TestNoContentTypePOST(t *testing.T) {\n\ttearDown()\n\tAdd(newPostNoConsumesService())\n\thttpRequest, _ := http.NewRequest(\"POST\", \"http://here.com/post\", nil)\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif 204 != httpWriter.Code {\n\t\tt.Errorf(\"Expected 204, got %d\", httpWriter.Code)\n\t}\n}\n\nfunc TestContentType415_POST_Issue170(t *testing.T) {\n\ttearDown()\n\tAdd(newPostOnlyJsonOnlyService())\n\thttpRequest, _ := http.NewRequest(\"POST\", \"http://here.com/post\", nil)\n\thttpRequest.Header.Set(\"Content-Type\", \"application/json\")\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif 200 != httpWriter.Code {\n\t\tt.Errorf(\"Expected 200, got %d\", httpWriter.Code)\n\t}\n}\n\n// go test -v -test.run TestContentType406PlainJson ...restful\nfunc TestContentType406PlainJson(t *testing.T) {\n\ttearDown()\n\tTraceLogger(testLogger{t})\n\tAdd(newGetPlainTextOrJsonService())\n\thttpRequest, _ := http.NewRequest(\"GET\", \"http://here.com/get\", nil)\n\thttpRequest.Header.Set(\"Accept\", \"text/plain\")\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif got, want := httpWriter.Code, 200; got != want {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n}\n\nfunc TestRemoveRoute(t *testing.T) {\n\ttearDown()\n\tTraceLogger(testLogger{t})\n\tws := newGetPlainTextOrJsonService()\n\tAdd(ws)\n\thttpRequest, _ := http.NewRequest(\"GET\", \"http://here.com/get\", nil)\n\thttpRequest.Header.Set(\"Accept\", \"text/plain\")\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif got, want := httpWriter.Code, 200; got != want {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n\n\t// dynamic apis are disabled, should error and do nothing\n\tif err := ws.RemoveRoute(\"/get\", \"GET\"); err == nil {\n\t\tt.Error(\"unexpected non-error\")\n\t}\n\n\thttpWriter = httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif got, want := httpWriter.Code, 200; got != want {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n\n\tws.SetDynamicRoutes(true)\n\tif err := ws.RemoveRoute(\"/get\", \"GET\"); err != nil {\n\t\tt.Errorf(\"unexpected error %v\", err)\n\t}\n\n\thttpWriter = httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif got, want := httpWriter.Code, 404; got != want {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n}\nfunc TestRemoveLastRoute(t *testing.T) {\n\ttearDown()\n\tTraceLogger(testLogger{t})\n\tws := newGetPlainTextOrJsonServiceMultiRoute()\n\tAdd(ws)\n\thttpRequest, _ := http.NewRequest(\"GET\", \"http://here.com/get\", nil)\n\thttpRequest.Header.Set(\"Accept\", \"text/plain\")\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif got, want := httpWriter.Code, 200; got != want {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n\n\t// dynamic apis are disabled, should error and do nothing\n\tif err := ws.RemoveRoute(\"/get\", \"GET\"); err == nil {\n\t\tt.Error(\"unexpected non-error\")\n\t}\n\n\thttpWriter = httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif got, want := httpWriter.Code, 200; got != want {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n\n\tws.SetDynamicRoutes(true)\n\tif err := ws.RemoveRoute(\"/get\", \"GET\"); err != nil {\n\t\tt.Errorf(\"unexpected error %v\", err)\n\t}\n\n\thttpWriter = httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif got, want := httpWriter.Code, 404; got != want {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n}\n\n// go test -v -test.run TestContentTypeOctet_Issue170 ...restful\nfunc TestContentTypeOctet_Issue170(t *testing.T) {\n\ttearDown()\n\tAdd(newGetConsumingOctetStreamService())\n\t// with content-type\n\thttpRequest, _ := http.NewRequest(\"GET\", \"http://here.com/get\", nil)\n\thttpRequest.Header.Set(\"Content-Type\", MIME_OCTET)\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif 200 != httpWriter.Code {\n\t\tt.Errorf(\"Expected 200, got %d\", httpWriter.Code)\n\t}\n\t// without content-type\n\thttpRequest, _ = http.NewRequest(\"GET\", \"http://here.com/get\", nil)\n\thttpWriter = httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif 200 != httpWriter.Code {\n\t\tt.Errorf(\"Expected 200, got %d\", httpWriter.Code)\n\t}\n}\n\ntype exampleBody struct{}\n\nfunc TestParameterDataTypeDefaults(t *testing.T) {\n\ttearDown()\n\tws := new(WebService)\n\troute := ws.POST(\"/post\").Reads(&exampleBody{}, \"\")\n\tif route.parameters[0].data.DataType != \"*restful.exampleBody\" {\n\t\tt.Errorf(\"body parameter incorrect name: %#v\", route.parameters[0].data)\n\t}\n}\n\nfunc TestParameterDataTypeCustomization(t *testing.T) {\n\ttearDown()\n\tws := new(WebService)\n\tws.TypeNameHandler(func(sample interface{}) string {\n\t\treturn \"my.custom.type.name\"\n\t})\n\troute := ws.POST(\"/post\").Reads(&exampleBody{}, \"\")\n\tif route.parameters[0].data.DataType != \"my.custom.type.name\" {\n\t\tt.Errorf(\"body parameter incorrect name: %#v\", route.parameters[0].data)\n\t}\n}\n\nfunc TestOptionsShortcut(t *testing.T) {\n\ttearDown()\n\tws := new(WebService).Path(\"\")\n\tws.Route(ws.OPTIONS(\"/options\").To(return200))\n\tAdd(ws)\n\n\thttpRequest, _ := http.NewRequest(\"OPTIONS\", \"http://here.com/options\", nil)\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.dispatch(httpWriter, httpRequest)\n\tif got, want := httpWriter.Code, 200; got != want {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n}\n\nfunc newPanicingService() *WebService {\n\tws := new(WebService).Path(\"\")\n\tws.Route(ws.GET(\"/fire\").To(doPanic))\n\treturn ws\n}\n\nfunc newGetOnlyService() *WebService {\n\tws := new(WebService).Path(\"\")\n\tws.Route(ws.GET(\"/get\").To(doPanic))\n\treturn ws\n}\n\nfunc newPutGetDeleteWithDuplicateService() *WebService {\n\tws := new(WebService).Path(\"\")\n\tws.Route(ws.PUT(\"/thing\").To(doPanic))\n\tws.Route(ws.GET(\"/thing\").To(doPanic))\n\tws.Route(ws.DELETE(\"/thing\").To(doPanic))\n\tws.Route(ws.GET(\"/thing\").To(doPanic))\n\treturn ws\n}\n\nfunc newPostOnlyJsonOnlyService() *WebService {\n\tws := new(WebService).Path(\"\")\n\tws.Consumes(\"application/json\")\n\tws.Route(ws.POST(\"/post\").To(doNothing))\n\treturn ws\n}\n\nfunc newGetOnlyJsonOnlyService() *WebService {\n\tws := new(WebService).Path(\"\")\n\tws.Consumes(\"application/json\")\n\tws.Route(ws.GET(\"/get\").To(doNothing))\n\treturn ws\n}\n\nfunc newGetPlainTextOrJsonService() *WebService {\n\tws := new(WebService).Path(\"\")\n\tws.Produces(\"text/plain\", \"application/json\")\n\tws.Route(ws.GET(\"/get\").To(doNothing))\n\treturn ws\n}\n\nfunc newGetPlainTextOrJsonServiceMultiRoute() *WebService {\n\tws := new(WebService).Path(\"\")\n\tws.Produces(\"text/plain\", \"application/json\")\n\tws.Route(ws.GET(\"/get\").To(doNothing))\n\tws.Route(ws.GET(\"/status\").To(doNothing))\n\treturn ws\n}\n\nfunc newGetConsumingOctetStreamService() *WebService {\n\tws := new(WebService).Path(\"\")\n\tws.Consumes(\"application/octet-stream\")\n\tws.Route(ws.GET(\"/get\").To(doNothing))\n\treturn ws\n}\n\nfunc newPostNoConsumesService() *WebService {\n\tws := new(WebService).Path(\"\")\n\tws.Route(ws.POST(\"/post\").To(return204))\n\treturn ws\n}\n\nfunc newPostTestService() *WebService {\n\tws := new(WebService).Path(\"\")\n\tws.Consumes(\"application/json\")\n\tws.Produces(\"application/json\")\n\tws.Route(ws.POST(\"/test\").To(doNothing))\n\tws.Route(ws.PUT(\"/test\").To(doNothing))\n\tws.Route(ws.PATCH(\"/test\").To(doNothing))\n\treturn ws\n}\n\nfunc newSelectedRouteTestingService() *WebService {\n\tws := new(WebService).Path(\"\")\n\tws.Route(ws.GET(pathGetFriends).To(selectedRouteChecker))\n\treturn ws\n}\n\nfunc selectedRouteChecker(req *Request, resp *Response) {\n\tif req.SelectedRoute() == nil {\n\t\tresp.InternalServerError()\n\t\treturn\n\t}\n\tif req.SelectedRoutePath() != pathGetFriends {\n\t\tresp.InternalServerError()\n\t}\n}\n\nfunc doPanic(req *Request, resp *Response) {\n\tprintln(\"lightning...\")\n\tpanic(\"fire\")\n}\n\nfunc doNothing(req *Request, resp *Response) {\n}\n\nfunc return204(req *Request, resp *Response) {\n\tresp.WriteHeader(204)\n}\n\nfunc return200(req *Request, resp *Response) {\n\tresp.WriteHeader(200)\n}\n"
        }
      ]
    }
  ]
}